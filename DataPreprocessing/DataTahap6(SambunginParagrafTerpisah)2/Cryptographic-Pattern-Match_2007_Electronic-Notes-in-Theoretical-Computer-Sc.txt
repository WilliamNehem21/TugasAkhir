We construct a language extension for process calculi for modelling the exchange of cryptographically composed data. More specifically, we devise a succinct syntax for terms and patterns that captures the intention behind perfect cryptography. The proposed language extension is independent of the choice of process calculus and is applicable to any calculus that supports exchange of data. Initially we restrict the model to symmetric cryptography, but we also show how it can be extended with support for asymmetric encryption and digital signatures.

The modelling of security protocols often relies on process calculi. As a common method for ensuring security in a system is the application of cryptography, several process calculi have emerged which incorporates cryptography in the design, e.g. LySa [3,4] and the Spi-calculus [1]. However, the modelling of cryptography and the underlying communication model are orthogonal factors in the resulting system, and this motivates an independent development of these components.

In this paper we shall design a language extension for process calculi that allows for modelling the use of cryptographic operations for securing the exchange of data. Specifically, we develop a term language with pattern matching that captures the intention behind perfect cryptography in an intuitive and succinct manner. The design is independent of the underlying communication model, and the language extension can be applied to any process calculus that supports exchange of data.

The other basic building block is patterns. As mentioned already, patterns are used to match on terms. Hence the syntax for patterns is identical to the syntax for terms, except that a pattern includes a list of the variables that should be mapped within the term.

The matching T(n, m) D T(y, m) a [y] in P should succeed because the tuple T(n, m) matches T(y, m). This results in the mapping of the variable y to the name n in the continuation process P . The matching T(n, m) D T(y, y) a [y] in P on the other hand would not succeed as both n and m cannot match the pattern y, and thus further execution is garbled.

The syntax and semantics of our language extension does not enforce the usual assumption of perfect cryptography. Matching on a pattern such as Ex(y) a [x, y] obviously violates this assumption, as it allows for learning x based only on an encrypted message. This design choice has been made to make the model as flexible as possible, one may want to encode the possibility of a principal to guess certain keys or encrypted contents in order to analyse different attack scenarios. Perfect cryptography is only one such scenario, although the most commonly used one, and thus we shall design a well-formedness condition for enforcing this assumption, hereby allowing the protocol analyst to choose when this criteria should apply.

In (1) the new variable x is learnt by decryption with K, an already known name. Similarly in (2) y is learnt using the prior knowledge of x to decrypt the encryption. In (3) z can be learnt from the third element of the tuple, then the second part of the tuple can be decrypted using z hereby learning y, and finally from the first part of the tuple x can be learnt using y.

Sieves are supposed to match on terms and thus the syntax is merely terms extended with a wildcard for a sieve that matches everything, i.e. variables defined with the sieve correspond to the variables of the basic model. Notice that sieves allow for both recursive variable definitions and for defining variables based on the mappings to other variables. Recursive variable definitions such as in the pattern xa

The examples of how well-formedness ensures that perfect cryptography is en- forced in the basic model presented in Example 2.2, naturally also apply to the extended model. The extended model however, introduces new ways to circumvent perfect cryptography, and the following example shows how the well-formedness condition presented above also captures these.

applicable to a large variety of process calculi, we cannot assume anything about the underlying semantics of the communication model. Instead, we shall formalise the protocol in an extended protocol narration [3], where we distinguish between outputs and corresponding inputs, and between encryptions and corresponding decryptions. In the encodings we follow [3] and extend each sent message with source and destination information as the first two elements, simulating the IP address along the lines of IPv4 and IPv6. Upon receipt of a message the principal will always check whether the message is intended for it; occasionally it will also check that the

Each line in the simple Alice-Bob protocol narration, has been translated into three lines in the extended narration. The first line describes the actions of the sender, the second line then describe how the recipient inputs the message, and the third line describes how the recipient decrypts some of the received elements using pattern matching. Notice that this encoding assumes that the distributed key K is fresh, and that S knows the master key of A and B, called KA and KB respectively.

In this appendix we shall show some important properties of our language extension. The first is that well-formedness is preserved in the semantics, and the second that a well-formed pattern guarantees perfect cryptography. As was the case for the development of the language extension, we shall proceed in two phases. First we shall prove that the results apply to the basic model, and then using the same proof technique we shall extend the results to the extended model.

It can extend its knowledge by decomposing the values according to perfect cryp- tography (rules (I2) and (I3)), i.e. decrypting using known keys and decomposing tuples. Furthermore, I has the ability to construct new values from its knowledge by concatenating known values into new tuples and creating new encryptions from known keys and contents (rules (I4) and (I5)).

