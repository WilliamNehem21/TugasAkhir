Several other frameworks for describing memory consistency have been proposed but are not central to this paper. The framework of Adir, Attiya and Shurek [1] is very similar to ours and precedes ours. Arvind and Maessem [2] provide a framework for serializable memory models. We are unaware, however, of how to use these

Itanium provides a distributed-shared memory (DSM) architecture where each processor maintains a replicated copy of the shared address space. For this paper the shared memory consists of only shared variables. That is, instructions either load or store a shared variable. Loads are satisfied by returning the value in the local replica, without any communication with the other processors. However, stores are performed by updating the local replica and broadcasting the update to every other processor to apply it in their replicas. Stores by a processor are visible to that processor before they can be visible to other processors. The channels between processors are not necessarily FIFO when two instructions are applied to different variables. The rules that govern processor execution and inter-processor interaction are complicated and give rise to complex behaviors.

An instruction is an instruction invocation completed with a response. In our setting the response of a store instruction invocation or a fence instruction invoca- tion is an acknowledgment and is ignored. The response of a load invocation is the value returned by the invocation. A (multiprocess) computation of an Itanium-based

The Itanium memory consistency model is specified at the architectural level, with- out a reference architecture implementation. Such a low-level specification can be very useful to chip verification. However, they are not convenient to programmers and algorithm designers, who normally reason about their programs at a higher level. This work attempts but fails to formulate a programmer-centric description of the Itanium memory consistency model. Instead, it provides two very similar definitions (stronger and weaker than Itanium) that bound the official lower-level specifications. These two definitions differ in the way the load-acquires are imple- mented in the presence of write-buffers, such as if and when a load-acquire causes the buffer to be flushed.

Though these definitions do not tightly capture Itanium, they are still very useful to programmers. For instance to prove that a problem cannot be solved with Itanium, it suffices to show it is not solvable using Strong Itanium. To prove the correctness of an algorithm for Itanium, it suffices to show correctness under Weak Itanium. This however does not replace a single programmer-centric definition that is tightly captures the Itanium behavior. This work shows that this goal is a real challenge. We hope that the techniques demonstrated in this paper allow us to achieve this goal.

