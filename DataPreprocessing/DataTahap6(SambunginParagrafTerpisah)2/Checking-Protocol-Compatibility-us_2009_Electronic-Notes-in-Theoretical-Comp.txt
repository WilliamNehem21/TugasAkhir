Checking compatibility of services accessed through their behavioural interfaces is a crucial issue in Service Oriented Computing which aims at building new systems from existing software services. In this paper, we consider a model of services which takes value passing and non-observable actions into account. We propose an approach to check in a unified way several compatibility notions between two service protocols using the rewriting logic system Maude. In particular, we illustrate our approach with three widely used compatibility notions, namely opposite behaviours, unspecified receptions and deadlock freeness. These notions as well as several strategies to handle non-observable actions have been formalised and fully implemented into a prototype tool which is able to automatically detect whether two services are compatible, and return a counterexample if they are not.

The main principle of Component Based Software Engineering (CBSE) and Service- Oriented Computing (SOC) is the reuse of existing software components or Web services 4 when building new systems in order to save time and efforts. In this context, interoperability issues must be avoided and reused services have to fit with other services in the system being developed. Therefore, compatibility checking is a crucial concern to ensure whether services can interoperate successfully. However, verifying compatibility is especially difficult when the model of services takes inter- action protocols into account which is essential [20] to avoid erroneous behaviours or deadlock situations when executing together a set of services.

Our model of service interfaces allows to specify interaction protocols (messages and their application order). Value-passing and internal actions are also consid- ered. Our framework provides a uniform and systematic way of checking different notions of compatibility, considering different strategies to deal with internal ac- tions. Here, we focus on three widely used compatibility notions, namely opposite behaviours [21], unspecified receptions [3,23], and deadlock freeness [2]. But other

Our solution for checking protocol compatibility is independent of any specific application, and therefore can be useful for several issues, such as automatic service composition, software adaptation, service substitution, service discovery, code re- engineering, etc. Our proposal has been implemented in the rewriting logic system Maude [7]. Its powerful rewriting engine and searching capabilities open a very wide range of possibilities. Moreover, its expressivity has allowed us to implement the different notions and strategies at a very high level of abstraction, without compro- mising efficiency, and allowing such a flexible and extensible general framework.

The remainder of this paper is structured as follows. Section 2 formalises our model of services. Section 3 introduces some preliminaries and the notions of com- patibility we use in this paper for illustration purposes. In Section 4, we present how service compatibility is checked using Maude. Section 5 presents a comparison with related approaches. Finally, Section 6 draws up some conclusions.

emission ! or a reception ?), and (p1,... , pn ) is either a list of data terms if the label where m is the message name, d stands for the communication direction (either an corresponds to an emission, or a list of variables if the label is a reception.

cation, composition or adaptation purposes). For space reasons, in the rest of the paper, we will describe service interfaces only with their STSs. Signatures will be left implicit, yet they can be inferred from the typing of arguments (made explicit here) in STS labels.

Opposite behaviours. The strongest and most intuitive compatibility notion is that of opposite behaviours. In this paper, our definition of opposite behaviours compatibility is inspired from the bisimilarity concept originally stated by Mil- ner [21]. Here, the opposite behaviours compatibility consists in the fact that when one service can send a message, then the other service must be willing to receive that message, and when one service is waiting to receive a message, then the other

Deadlock freeness. This notion is less restrictive than the two previous ones. It considers that two service protocols are compatible if and only if, starting from their initial states, they can always evolve until reaching a final global state. In order to formalise our deadlock freeness compatibility, we took inspiration from [2].

notion. In the very first step, the opposite-behaviours operation (line 1) ac- cepts as arguments two STS objects and returns a tuple consisting of a Boolean value and a counterexample (Tuple{Bool, Tuple{List{Transition}}}). Then, in order to check the protocol compatibility at all global reachable states using a recursive execution, an auxiliary opposite-behaviours operation (lines 8-10) is called. As it is shown in line 13, the auxiliary opposite-behaviours operation calls

So far, our prototype tool has been validated on more than 75 examples, which range from small examples to real-world ones. The largest example of our database consists of two services where each one consists of more than 85 states and around 90 transitions. The maximum computation time for this example was about 7 seconds, and that was needed to check the trace deadlock freeness compatibility.

During the last 25 years, compatibility has been intensively studied as a main is- sue in Software Engineering. Let us survey some key related works in this area. [3,23] have formally defined a compatibility notion for software components using an automata-based formalism. Their compatibility notion consists of checking two pro- tocol properties, namely unspecified receptions and deadlock. More recently, [1,5] have used a Finite State Machine (FSM) model to formalise a compatibility notion for Web services which aims to check whether one service can substitute another service. In [1], the authors adopt an asymmetric relation, namely simulation, for determining if a new version of a service behaviour simulates a previous one. [5] gives a restrictive notion of behavioural compatibility saying that each trace in one Web service must also be preserved in another Web service. In [16,17,14], the au- thors rely on bisimulation algorithms to define the compatibility of Web services

passing is not taken into account. In addition, only a few proposals [1,5] have at their disposal an implementation to automatically check the proposed compatibil- ity notions. Compared to these works, we consider a formal interface model which takes into account both non-observable actions and value-passing. Moreover, we propose a framework which enables to check, in a unified manner, several compati- bility notions, and therefore make our proposal useful for many possible application

