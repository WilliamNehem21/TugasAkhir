)Inductive Constructions (pCic; see [20], Chapter 4) to Coq can be straightforward although routine [1]. On the contrary, there seems to be a central problem with the representation of data sent by the computer algebra system such as GAP [5,10]. Namely, the objects of the pCic are terms; even proofs are terms constructed from smaller terms. The question is how to interpret arbitrary non-pCic data that can come packaged in OpenMath objects. Such data may not correspond to terms for the reason that computer algebra data are not in general constructed but rather given, and we cannot establish a constructive proof of how the values in the OpenMath object were obtained.

One can formally assign mathematical meaning to objects of Strong OpenMath, a strict subset of OpenMath. Hence there is a chance that Strong OpenMath objects can be mapped to the pCic by means of formal analysis. However, we do not see a way to restrict or convert to Strong OpenMath the set of objects generated by GAP.

To faithfully translate a given OpenMath object to the pure pCic with no axioms one needs to represent that object in terms of the pCic. For example, if GAP computes a group of permutations, one must have a constructive definition of a group of permutations in the pCic rather than arrays of numbers that would likely be the external GAP representation of such a group. We are inclined to think that this is possible to satisfy at least partially if we take group-theoretic definitions that already exist in SSReflect [11]. However, many constructive objects of that kind depend on proofs (of algebraic properties, for instance), which renders a fully automated translation impossible. Therefore some form of user interaction is still

In a type-theoretic proof system, type-checking is a problem of deciding whether a typing judgement is derivable according to the rules of the system. Although this problem is undecidable in general, it is decidable for most systems of interest, in particular, for injective ones [4]. In proof assistants, this job is delegated to the module known as type-checker.

and C is neither SORT nor FUN. Let t : C t1 ... tn be a well-typed term inhabiting the class C. We can define the application of f to t as f @t = f t1 ... tn t. The type

?1, ..., ?n (partially) unknown arguments and t the known value of this projec- tion applied to the arguments. This mechanism is provided by canonical structures. A canonical structure [20] is a purposely marked instance of a record (that possibly contains functional abstractions at the topmost level). The type checker employs such marked instances when attempting to solve unification problems. This can be expressed in a rule below:

A similar mapping from a polynomial to an OpenMath dictionary field should also be provided. Mappings are represented by Coq terms with names of OpenMath dictionaries and dictionary fields being qualified identifiers defined in Coq. These identifiers are processed by the tactic and respective string values are obtained for XML field names.

In order to represent this as a Coq term, the user should have defined translation rules for the corresponding entries in the OpenMath content dictionaries in Coq. In general, representation of an OpenMath object in Coq depends very much on the context. Therefore it is quite impossible to have a fixed set of translation rules. Instead, we should provide means to the user to define appropriate mappings.

