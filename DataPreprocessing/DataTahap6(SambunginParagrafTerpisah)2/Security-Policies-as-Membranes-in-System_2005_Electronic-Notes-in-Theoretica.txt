We propose a simple global computing framework, whose main concern is code migration. Systems are structured in sites, and each site is divided into two parts: a computing body, and a membrane which regulates the interactions between the computing body and the external environment. More precisely, membranes are filters which control access to the associated site, and they also rely on the well-established notion of trust between sites. We develop a basic theory to express and enforce security policies via membranes. Initially, these only control the actions incoming agents intend to perform locally. We then adapt the basic theory to encompass more sophisticated policies, where the number of actions an agent wants to perform, and also their order, are considered.

paper, and start with the straightforward policy which only prescribes the actions an agent can perform when running in a site. In Section 3, we enhance the theory to control also how many (and not only which kind of) actions an agent wants to perform in a site, and their order of execution. Finally, in Section 4 we extend the theory to control the overall computation taking place at a site, and not only the behaviour of single agents. The paper concludes in Section 5 where a comparison with related work is also given. The theoretical results are proved in the full paper [8].

Deciding on when to apply the second possibility presupposes a trust man- agement framework for systems, which is the topic of much current research. To simplify matters, here we simply assume that each site contains, as part of its membrane, a record of the level of trust it has in other sites. Moreover, we assume only three possible levels: lbad, loc and lgood.

(i.e. typechecked) and which ones are not. However, for economy, we prefer to record this information in the membranes, by demanding that the trust knowledge at trustworthy sites is a proper reflection of this division. This is more easily defined if we assume the following ordering over trust levels:

uncertainty is when k classifies l as loc: then l may be either lgood or lbad. Of course, in coherent systems we expect sites which have been classified as trustworthy to act in a trustworthy manner, which amounts to say that code running at such a k must have at one time gained entry there by satisfying the entry policy. Note that by using policies as in Definition 2.1, if P satisfies an entry policy Mk, then it continues to satisfy the policy while running at k (cf. Theorem 2.7 below).

In the full paper, we prove that the enforcement predicate can be estab- lished efficiently, while DFA satisfaction is decidable, but extremely hard to establish. This substantiate our hypothesis that verifying digests is preferable to inspecting the full code from the point of view computational complexity. We are now ready to state the soundness of this variation. It simply consists in finding a proper notion of well-formed systems. Like in Section 3.1, the entry policy can only express properties of single threads, instead of coalitions

Here we change the intended interpretation of policies. In the previous section a policy dictated the proposed behaviour of an agent prior to execution in a site, at the point of entry. This implied that safety in well-formed systems was a thread-wise property (see rules (wf-g.siteM) and (wf-g.siteA)). Here we focus on policies which are intended to describe the permitted (coalitional) behaviour of agents during execution at a site. Nevertheless these resident policies are still used to determine whether a new agent is allowed access to the site in question; entry will only be permitted if the addition of this incoming agent to the code currently executing at the site does not violate the policy.

Example 4.1 Let licence serv be the site name of a server that makes available K licences to download and install a software product. The distri- bution policy is based on a queue: the first K agents landing in the site are granted the licence, the following ones are denied. The policy of the server then need to analyse the incoming code in parallel with the resident code R. It should be clear that the theory developed in Section 3.1 is readily adapted to this revised reduction semantics. In particular the Subject Reduction and Safety theorems remain true; we spare the reader the details. However it should also be clear that this approach to enforcing resident policies has serious practical drawbacks. An implementation would need to:

Related Work. In the last decade, several calculi for distributed systems with code mobility have appeared in literature. In particular, structuring a system as a (flat or hierarchical) collection of named sites introduced the possibility of dealing with sophisticated concrete features. For example, sites can be considered as the unity of failure [6,1], mobility [6,3] or access control [10,16,9]. The present work can be seen as a contribution to the last research line.

Membranes as filters between the computing body of a site and the external environment are also considered in [5,2,17]. There, membranes are computa- tionally capable objects, and can be considered as a kind of processes. They can evolve and communicate both with the outer and with the inner part of the associated node, in order to regulate the life of the node. This differs from our conception of membranes as simple tools for the verification of incoming agents.

