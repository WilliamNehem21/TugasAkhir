This talk will start by presenting theoretical results on determinism for asyn- chronous distributed components. It will then show how to apply those results in a practical implementation, available as Open Source within the ObjectWeb Open Source community. Further, current work aiming at defining a joint European component model for Grid computing (GCM) will be summarized. Finally, it will conclude with challenges at hand with component systems, especially work related to capturing behavioral properties. Current work aiming at defining behavioural models and techniques for hierarchical components will be introduced.

Within the GCM, collective operations, previously achieved at the level of ob- jects, are being abstracted into elements of the interface. This shift first represents an achievement in terms of readability, and reuse. Second, functional methods can be used in various contexts, standard non-collective code and at the same time in powerful group interactions. Moreover, it also achieves an important increase in the level of abstraction used by the programmer: interfaces versus the old API style for controlling parallelism, multicasting and synchronizations. Finally, it permits typing of collective behaviour.

From an historical stand, with a hierarchy of modules then objects then compo- nents, components could be viewed as moving backwards in programming evolution. We are moving to a more static topology, while we have shifted from module (static assembly) to objects where the inter-connection between pieces of code is often purely dynamic. With components, the interconnection is static, and can only move back to dynamicity using controllers at execution, like binding controllers. In other words, only some specific entities of the architecture authorize the intro- duction of dynamicity. Somehow, components can be viewed as dynamicity under control ! nature: remote method invocations typed with interfaces. One would not be able to check large systems without some of the guaranties given by a static type system. The absence of unstructured call-backs and ports makes a tremendous difference with respect to verifying a component system.

