Compilers for languages with type inference algorithms produce confusing type error messages and give a single error location which is often far away from the real location of the type error. Attempts at solving this problem 1) fail to include the multiple program points which make up the type error, 2) often report tree fragments which do not correspond to any place in the user program, and 3) give incorrect type information/diagnosis which can be highly confusing. We present Skalpel, a type error slicing tool which solves these problems by giving the programmer all and only the information involved with a type error to significantly aid in diagnosis and repair of type errors. Skalpel consists of a sophisticated new constraint generator which is linear in size and a new constraint solver which is terminating.

Automatically finding type errors in programming languages is a difficult task. Successful attempts need to address constraint systems (systems which use a con- straint based approach in order to locate errors, unlike compilers which use a substitution-based approach) but these have only been built for toy-like languages in [8] and [5]. A more promising approach has been taken in [14], but again the supported portion of the languages used to demonstrate the key ideas is small. Moreover, existing proposals to solve poor type error reporting (e.g., [2], [6], and [13]) simply repeat calls to the compiler and remove/add back in portions of the untypable program to narrow the point of error. The problem of finding type errors and of reporting possible solutions is very difficult and to solve it automatically is even more difficult. Every piece of syntax in the program must be automatically labelled, constraints need to be automatically generated and solved and finding so- lutions can lead to new constraints and a combinatorial constraints size explosion.

We have developed a new method and tool (Skalpel) which solves the above problems. Skalpel attaches program points (labels) to constraints that are gen- erated, so that when unification fails, we can report the labels attributed to the constraints which were generated, giving a full description of the error. We anno- tate constraints with these labels to describe what set of program points a constraint is involved with. When Skalpel is asked to check a program for type errors, it runs its sophisticated constraint generator/solver (which is linear in size and terminat- ing). If solving the constraints fails (i.e., if there is an error in the code), Skalpel must automatically decide which parts (slice) of the program was responsible for the error. Then, Skalpel generates a type error slice highlighting the minimum amount of information responsible for the type error in the code. By looking at the high- lighted regions, the user can be confident that the type error can be fixed in one of the highlighted locations and that non-highlighted locations do not contribute to any error. Our contributions include the following:

In section 2 we discuss the basic notation used. In Section 3 we give the technical core of Skalpel. In particular, we discuss our new constraint representation which was vital for us overcoming the constraint size explosion challenge when dealing with an entire programming language such as SML. We show that constraint generation is linear and that constraint solving terminates. We conclude in Section 4.

Although SML distinguishes value variables and datatype constructors by as- signing statuses in the type system, we distinguish them by defining two disjoint sets ValVar and DatCon. As opposed to the Skalpel core, for fully correct minimal error slices, Section 14.1 of [12] handles identifier statuses. Also, to simplify the presentation of the Skalpel core for this paper, datatypes have been restricted to one constructor and one type argument.

is to build environments that avoid duplication at initial constraint generation or during constraint solving. Note that Earlier systems (e.g. [4]) are too restrictive to represent module systems because they only support very limited cases of our binders. With our constraints, we can easily define a compositional constraint generation algorithm.

It can be seen that datatype declarations only have one constructor by looking at rules (G17), (G14), and (G16). We have defined the core in this manner in order to reduce the complexity of the core. In rule (G13) we define the datatype names to have exactly one type variable argument.

Proof. By inspection of the rules. For a polymorphic (let-bound) function (rules (G2), (G6), and (G17)) we do not eagerly copy constraints for the function body. Instead, we generate poly and composition environments, and binders force solving the constraints for the body before copying its type for each use of the function. 2 (G21). For a constraint generation run cstgenj(PL, v ) either PL will be atomic in nature or it will not. If not, we recurse with cstgenj(PLj, v j), on some PLj inside PL, such that PLj is strictly smaller than PL. Rules which recurse with strictly smaller parts of external syntax are rules (G2) (let syntax removed in recursive call), (G3) (application syntax removed), (G4) (fn syntax removed), (G8)

We further analyze some interesting constraint solving rules. Rule (C1) demon- strates how we handle our composition environments. We take the first environment and recurse on that first to solve the constraints inside, and only after they are han- dled we inspect the second environment. Polymorphism is handled in rule (P1), where we make a binder polymorphic by quantifying over the type variables which are to be made polymorphic, and creating a new binder with this information.

A crucial property of Skalpel is that it must present to the user all of the possible points where the user may fix the error. Skalpel must not present any program points which are irrelevant to the error. In order to ensure that this is always the case, we perform minimisation. When the constraint solver terminates with an error (which contains the program points, l ) the minimisation algorithm tests that all of the labels present in the reported error. It does this by removing a program point l from the program, replacing it with a dummy expression, and running the constraint solver again. If this run terminates in success, then the label was crucial to the error, and so it must be presented to the user. If the constraint solver terminates with

Naturally, Skalpel is at its most effective in large codebases. If global changes to an entire project are needed to fix a type error, Skalpel will highlight where the problem may be fixed in all areas of the project. Furthermore, when large code bases are used, and the type error is limited to a few small functions, Skalpel will eliminate the rest of the program for the user, which is irrelevant, as opposed to existing compilers which do not rule out anything, as they only present the point where unification failed. This is achieved as a) determining which program parts to highlight (labels involved in the error) is calculated accurately by our constraint solver, as label sets are attached to each constraint, so we know which parts of the user program include conditions on other parts of the program, and b) the process of minimisation also ensures that no irrelevant part of the program is highlighted to the user.

