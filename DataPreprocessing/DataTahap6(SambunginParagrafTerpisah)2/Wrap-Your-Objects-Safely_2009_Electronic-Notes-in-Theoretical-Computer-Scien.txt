Open distributed systems and embedded devices offer many new challenges to the research community, from design to correct functioning, including modeling, prac- tical implementation issues, and most notably security. The latter in particular is a crucial aspect to be taken into account, as the uploading or downloading of an ap- plication to a device may compromise data privacy, confidentiality or integrity. The above justifies the need to find new solutions to guarantee a minimum of security at run-time. This is far from easy since the openness of modern systems implies that we do not know with what possible environments the software will be interacting.

It has long been identified that the shared-state concurrency model is not ideal for open distributed systems. This is despite the fact that one of the most widespread languages used nowadays, namely Java, relies on such model. The natural style for modeling distributed systems is by message-passing and concurrency, for instance objects running concurrently communicating asynchronously through method calls, as in the Creol model [10]. In order to formalize and experiment with our proposal, we have chosen Creol as the underlying language, due to its communication model, its simple semantics, and simulation tools directly related to the operational seman- tics. In addition, Creol supports dynamic upgrade of classes, allowing new code to be communicated, where wrappers may also protect against unsafe code.

the classes and objects in a distributed manner, and installed independently at the affected objects, without stopping execution. Since the upgrade of classes is done through messages, it means that insertion of new upgrades in a hostile environment may be unsafe, with the result that unsafe code may be installed and executed. By focusing on controlling the flow of messages in and out of wrappers, we then address the issues of unsafe data and code flow.

is a short form of t!x.m(e); await t?; t?(v), where t is a fresh (or unused) label. Furthermore, the synchronous and blocking method call p(e; v) is a short form of t!x.m(e); t?(v), where the unguarded reply statement corresponds to active waiting. Thus synchronous calls can be reduced to asynchronous calls. A local call m(e; v) is understood as a remote call to self, this.m(e; v) (and measures are taken to provide self reentry). Remote method calls are typically programmed by non-blocking calls, thereby avoiding deadlock and active waiting.

Guards are used to control processor release and may consist of Boolean condi- tions, return tests, and definite release (wait). When a process is released or com- pleted, an enabled process (if any) is chosen from the local process queue. Therefore explicit signaling is not part of the language. The run method of an object is called upon creation, and initiates active behavior. Release points in the run method, for instance an asynchronous recursive call, allow processes in the process queue to be handled. Notice that a method call creates an invocation event message sent to the callee, which results in an activation of the called method, which is placed on the process queue of the callee. And the completion of a method activation generates a return event message sent back to the caller (with the caller and tag value as implicit parameters).

where C is the class name, M a multiset of method declarations (each with code and local variables), and A a list of attributes (with initial values). For simplicity, we ignore inheritance in this paper, otherwise there would be a field Inh : S defining the inheritance list. In the rules we omit fields not relevant for the rule, following the convention of Full Maude. For instance, the following rule defines object creation in Creol (ignoring class parameters for simplicity):

Second, we need to add the notion of locality. Currently all messages go to a global pool, also containing all objects and classes, and there is no way to group them into units with a local pool. Locality is needed, among other things, to model local networks and computers connected to the network. In Maude we can create localities in a very similar way as we create wrappers.

A wrapped object will then perform as before with standard Creol rules, without being aware that it is wrapped, including processing of method invocations and reply statements. Method binding is also done as in standard Creol since copies of the relevant class declarations are found inside the wrapper (adjusting the (Bind) rule to the syntax for components). However, we must add rules to control the flow of messages from inside the wrapped component to its environment, and vice versa. The rule for importing into the wrapper is as follows: where MSG denotes a message content, SS a system state, output the output func- tion of a state machine for a given input, state the state resulting from the step taken by the automaton, and accept the accepting condition. An automaton takes two kinds of inputs: messages directed into the wrapper and messages directed out of the wrapper. To make an automaton distinguish between these, we use the two constructors import and export, letting import encode messages directed into the wrapper, and export for messages directed out of the wrapper. In our setting an automaton can be defined in the functional sublanguage of Creol defining construc- tors for each automaton state (including variable substitutions), and by defining the three functions: output, state, and accept, given an automaton state and input. The rule for exporting from the wrapper is as follows:

Standard object creation can still be done by the previous (New) rule (adjusted to the component syntax). Thereby objects may be added inside a wrapped com- ponent, resulting in components that contain many objects and many classes, in such a manner that all code is found within the wrapper. The resulting system may contain several copies of the classes involved, some inside wrappers and some outside. This has the benefit that each wrapped unit may decide which class up- grades it does accept and which it does not accept. As a result the different class copies may evolve differently and exist in different versions of the same class. The rules given handle this. We have so far not defined components with their own identity which may be manipulated in the context of other components. That is, we cannot import third-parties components, delete them, etc. This stronger notion of component could be added to Creol, but it is not presented in this paper.

[2] and the Seal calculus [4]. The above calculi concentrate on the construction and communication of ambients, including mobility through ambient migration. This is, however, a feature not needed for modeling web services, which is one of our do- main of application. Our setting is based on objects communicating asynchronously through message passing (method calls) and although it is possible to model objects (e.g. by using input channels in the Seal calculus), none of the above calculi are inherently object-oriented. Moreover, in these calculi messages need to be coded as ambients, adding an extra complexity on the design.

The expressive power of aspect-oriented programming (AOP) [13] is different from that of wrappers, as it may involve control of low-level issues such as the number of assignments to particular variables, which we have not addressed with our wrappers. On the other hand, a wrapper may remove or replace a call to or from an environment, for instance in order to make incompatible components compatible. This is not possible with AOP. The notion of wrapper has been motivated by the desire to build abstract protection concepts with a simple semantics which may be exploited by formal program analysis tools. However, the ideas presented may also be reused to build more low-level wrappers, reacting on for instance assignments, but then with a less modular semantics.

where it is established what are the obligations, permissions and prohibitions of each party. Contracts may be written in a contract logic, as for instance the ones presented in [5,18], and the wrapper may consist of an automaton automatically extracted from such contract specification. This seems to be particularly useful for wrapping components [17].

An interesting application domain, besides the Internet, is embedded systems. In particular, the state-of-the-art of open smart cards allowing post-issue upload of multiple-applets is unreliable from the security point of view. The main problem is that the current model of firewalls between applets does not work properly, and many attacks are possible due to failures in the model, the implementation of the virtual machine, or other related bugs [15,16,20]. We do not claim that our proposal will solve all those problems, but that at least will mitigate some of them.

The definition of wrappers as we did in Creol could be the starting point of defining different layers of localities. In fact local networks and computers may be represented as wrappers, without the notion of automaton controlling the input and the output. The only issue will be the addition of a local pool where only explicit rules will allow a given message to navigate in or out from the wrapper. We will need to extend it with an identifier, since localities may need to be referenced. Firewalls could be added in a straightforward manner: a locality with a firewall will essentially be the same as a wrapper as we defined it for the safeNew (with the automaton) but over a collection of objects and classes. Thus, firewalls are instances of wrappers in the second sense mentioned in the introduction, where the untrusted part is the environment.

