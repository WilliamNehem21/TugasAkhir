After introducing the syntax of the SMEPP primitives (Section 2), we present an abstract semantics for a simple calculus over these primitives (Section 3). Such a semantics formally establishes whether a set of processes (viz., peer or service codes) can be executed together without locking, and it provides a solid ground to develop tools for the analysis and verification of SMEPP specifications.

Peers have to be uniquely identifiable. Groups have to provide basic abstraction for service providing. Furthermore, security has to be bound to groups. Peers have to be able to securely create, locate, and join groups. (Provider) peers have to offer services in groups. Then, (client) peers have to join the respective groups to be able to invoke the offered services. Services have to be identified by contracts, which will include information to allow their discovery, adaptation, use or composition with other services. The middleware has to support asynchronous, synchronous, and event-based communication between peers and services.

Events are a loose way of communication among entities. For simplicity, we model events as operations, hence raising an event is somewhat similar to invoking an operation, while waiting for an event is somewhat similar to waiting for an operation to be invoked. Modelling events as operations allows us to use only one schema to define both (asynchronous) operations and events, as well as, to use only one primitive for the reception of messages modelling both, operation invocations, and events. Different from operations, the entity that raises an event does not have to wait for another entity (viz., an event subscriber) to receive it.

the peer, that is, to check whether the caller peer is allowed to join the group. If the call succeeds, the middleware adds the caller peer to the list of members of the groupId group. A peer may join several groups. Joining the same group several

times does not raise an exception. However, a mismatch between the credentials supplied by the peer wishing to join the group, and the securityLevel of the group raises an accessDenied exception. Furthermore, calling joinGroup with an invalid groupId raises an invalidGroupId exception.

Peers use the leaveGroup primitive to exit a group identified by groupId. When a peerId peer leaves a groupId group (or when peerId terminates unexpectedly), the peerId will be removed from the list of members of the groupId group. Similarly, all the services published by peerId in groupId will be removed from the list of services offered by the groupId group (see publish on page 5).

Peers stop to offer services in a group by unpublishing them from the respective group. If the call succeeds, the middleware removes the service identified by service- Contract from the list of services published in the groupId group. Unpublish raises the same exceptions as publish.

getServices allows to match published services. The output consists of a list of triples: services identified by serviceContracts, which are published in groupId groups, and that have id identifiers. The groupId and peerId (optional) input parameters restrict the service discovery to the groupId group, and to the peerId peer, respectively. Id stands for groupServiceId or peerServiceId. getServices raises exceptions when the input group, the peer identifier, or the contract of the desired service are not valid.

Event is somewhat similar to an asynchronous invoke. It raises an operation event that contains some input data, which is similar to invoking an operation with an in- put message. The main difference is that event is non-blocking, hence the caller does not have to wait for a matching receive in the provider. Note that the middleware is event, and that are in a same group with the provider. Note that if the provider attempts to catch events using receives on synchronous operations, the middleware raises an invalidOperation exception. The rest of the exceptions raised by event are similar to the ones raised by the invoke.

As previously mentioned, receive serves to wait for clients to invoke the respective (synchronous or asynchronous) operation, or for operation events to be raised. Note that, for services, the provider peer of the service that calls receive has to have pre- viously published a contract that defines the respective operation in its signature. 3 The output of the receive contains the identifier of the caller (viz., callerId, which can be a peerId, or a peerServiceId), as well as the input message of the operation

The reply marks the termination of a synchronous operation. Hence, the caller of the reply has to have previously executed a corresponding receive on the same operation. Once the reply is executed, the invoker (viz., client) of the operation unlocks from its invocation. Output is the return message of the operation. Again, the exceptions raised by the reply are similar to the ones raised by the invoke.

g. The behavior of publish is modelled by rule Publish, which is applied when the service has not been previously published by p in g. In this case, the new service is added to Sr and a new provider [program(cs, p)]g.p.s (the code residing in p, whose contract service is cs) is started.

The two previous rules have modelled primitives to invoke operations which were hosted by specific entities. However, the SMEPP model permits the invocation of services provided by a group, independently of the peer which is actually servicing it. These alternative invoke primitives also have the corresponding synchronous (rule Invoke Sync Group) and asynchronous (rule Invoke Async Group) versions.

Finally, an entity locked by the auxiliar primitive suspend may progress only if a reply primitive is executed answering the previous invocation (rule Reply). The provider entity replies by using the invoker locator provided by the invocation. The entity waiting for the answer receives the result before continuing its execution. The entity which originally made the invocation and the entity providing the result must

Finally, when a group g' includes a service g.p.s among its subscribed services, which is not active in the group g because of a certain reason (e.g. the peer leaves the group, the service is unsubscribed, . . . ), it must be removed from the set of subscribed services in g' (rule Subscribe W).

reasoning on abstract specifications of P2P systems. To this end, we have presented a semantics based on a calculus where judgements represent concurrent executions controlled by the middleware (which is explicitly modelled by two components, the environment and the polling context). The idea behind of providing such a seman- tics is giving the possibility of constructing a verification environment to analyse properties like lock freedom, correct termination, etc.

Although the actual usability of the service model in embedded system is one of the key objectives of the SMEPP project, the proposed model can be employed to specify general (i.e., not necessarily embedded) peer-to-peer systems. The embed- dedness will be addressed at the software architecture and at the implementation level by deploying prototypes of the middleware for devices with different computing capabilities (ranging from laptops to pocket PCs to smart phones).

Bisignano et al. [2] introduce JMobiPeer, a P2P computing platform developed on top of JXTA. JMobiPeer defines modules for transport and service protocols, for peer and peer group management, and for peer advertisement and discovery management. Similarly to JXTA, advertisements provide information of available services, peers

As future work, we have to explore the expressiveness of the model by specifying real and more complex case studies in order to validate it on specific domains such as environmental monitoring in industrial plants, and mobile telephony. In addition, the model has to be extended with more complex compositional structures, such as an event handler or a fault handler. Furthermore, we also aim to develop a verification tool based on the rules presented in this paper.

