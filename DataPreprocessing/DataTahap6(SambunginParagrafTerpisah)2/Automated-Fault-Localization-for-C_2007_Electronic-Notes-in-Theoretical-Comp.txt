We present an automatic approach for fault localization in C programs. The method is based on model checking and reports only components that can be changed such that the difference between actual and intended behavior of the example is removed. To identify these components, we use the bounded model checker CBMC on an instrumented version of the program. We present experimental data that supports the applicability of our approach.

Debugging consists of three steps: detecting that the program contains a fault, localizing the fault, and correcting the fault. Detecting faults has been an active area of research. There exists less work on fault localization and correction. In this work we focus on localization and present a novel method for determining the cause of faults in C programs.

We assume that we are given a program written in C and a specification. Suppose the program contains a fault, and we have a counterexample showing that the specification does not hold. We use the counterexample to create an extended version of the program. We fix the inputs of the program according to the values of the counterexample and introduce abnormal predicates for every component in the program. If the abnormal predicate of a component is true, we assume that the component works abnormally. Therefore, we suspend the original behavior of the component and replace it by a new input. The localization problem is then one of finding which abnormal predicates need to be asserted and how the respective components have to be replaced in order to fulfill the original specification. In order to find abnormal predicates we negate the original specification to state that it is not possible to satisfy it by suspending components, and again use a model checker to verify the new system. If we find a failing run, we can derive from it the components that work abnormally and a replacement such that the program is fixed for the original counterexample.

In [15,23] a game based approach is presented for debugging. Using an LTL specification, the approach is able to locate a fault and provide a correction that is valid for all possible input values. Recently, this work was extended to pushdown systems to handle recursive Boolean programs. Details on the approach and its application to abstractions from C programs, are given in [10]. The problem of finding a correction that is valid for all inputs is computationally hard and therefore the approach is less efficient than the one presented in this paper, where we only provide a correction for the considered counterexamples.

Other existing work does not report possible fault locations, but rather gives a deeper understanding of the nature of a failure. In [14] segments of the coun- terexample are identified that force the error to occur. Zeller and Hildebrandt [27] point out the significant difference between a failure inducing program input and a successful input. Groce and Visser [12] generate and analyze similar versions of a program run (successful and faulty runs) in order to obtain more information about the cause of the failure.

In the next section, we give the details of our approach in the general case. Section 3 gives the instantiation for the case of localizing faults in C programs as well as details on the used tools and methods. We show the applicability of the approach in Section 4 by examining two examples and explaining the gathered results. We conclude and give some outlook for future work in Section 5.

In this section we describe, in general terms, how a model checker can be used for fault localization. Efficiency is not our prime concern in this section. In section 3 we give a specific instantiation of the approach to localize faults in C programs.

The theory presented here is quite general. It is not restricted to finite domains, as long as the modifications mentioned in point ii can be expressed. Likewise, the restriction that a signal is defined by exactly one component is unnecessary. If it is removed, general constraint systems can be diagnosed [8].

In order to apply the approach to C programs, we first give a short description on the used model checker CBMC and bounded model checking for software. Subsec- tion 3.2 presents our approach to finding faults in C programs, which is a variation on the general approach described in the last section.

The assert in Line 12 is an unwind assertion, which is added by CBMC to decide whether or not the unwinding is deep enough. If it is violated, we found a run which traverses the loop more than three times. We have to call CBMC again with a higher bound for the unwinding.

In the unwound program, CBMC supports assume statements as well as assert statements. CBMC turns the unwound program into a propositional logic formula that is satisfiable if and only if there is an execution of the program that ends in the violation of an assert statement and satisfies all assume statements that it encounters. Satisfiability is checked by a standard SAT solver.

The new counterexample again is computed using CBMC. If no new counterex- ample is found we can look for dual faults or increase the number of unwinds. Keeping the unwind assertion unchanged in the previous step helps to adjust the correct number of unwinds.

The full diagnosis for a given counterexample is built iteratively: when an ex- pression is found, we add an assume statement to the program code to avoid that the same component is reported a second time. CBMC is run repeatedly until no more expressions are found. A more efficient way would be to add blocking clauses to the SAT instance.

In the following we illustrate our approach using a simple C program. Listing 2 shows a program P that adds and multiplies the variables a and b. As specification we use an assert statement in Line 12. In Line 4, a is assigned 5, which is incorrect and should be 6. Note that there are no loops in the code and thus Pk = P .

Assume that the counterexample sets a, b, c, d to the values 1, vb, vc, and vd, respectively. (Values vb, vc, and vd are irrelevant, a can be set to any nonzero value.) Listing 3 shows P ' . In Line 3 the new variable diag is introduced. The counterexample is fixed in Line 6, but no value is fixed for e in Line 14. The statement assert(false) is added to the end of the program and each expression is replaced to include the appropriate check for the diag variable. The numbers used for the expressions correspond to the line numbers in Listing 2.

By using expressions as components, we get a fine grained and quite natural model for localization of the fault. Examining expressions allows us to localize faults in assignments, function calls and return statements as well as in conditions for if- statements or loops. Because we do not only examine if an expression contributes to a fault, but also if it is possible to change it to avoid the fault, our results are more exact than comparable methods. The corrected version of the program in Listing 2 assigns 6 to variable a in Line 7. Groce [11], Zeller [26], Ball et al. [1], and the dynamic slice [24] for this example comprise all assignments from Line 4 to Line 7 while we are able to correctly pinpoint the fault to Line 4.

Our approach returns all expressions that can be changed such that we can generate a correct run from a given counterexample. Note that in case of a faulty value which is propagated through the program, it is not possible to tell which of the involved expressions is to change if the program is weakly specified. Again have a look at the example in Listing 2. If we change the assert in Line 12 to assert(d == 36), it is not possible to tell if the fault is located in Line 4 or Line 7.

We show the applicability of the approach by considering two examples: The fol- lowing section shows the results from the TCAS task of the Siemens test suite [6]. The Siemens suite contains five tasks which are widely used in literature. Each task consists of a C program and several versions of it with faults introduced. The position and kind of the faults is known. Besides the source-files, a number of test cases along with the information which of the code versions pass them is provided. In the second example, we check the implementation of a data structure. Section

Because no specification is given, we use failing test cases as counterexamples and the correct value for the test case as specification. Except for v38, for which no test case is given, the test suite provides between 3 and 130 failing test runs for each program version, 1500 in total. The program contains 34 expressions in assignments and conditions, which were identified as potential cause of an error and instrumented as described above.

We will now have a closer look at v2, its source code is given in Listing 4. Functions that are not important for the example and initialization of the variables are omitted. Constants are written in capital letters, global variables representing input values from the test case start with a capital letter, and local variables start with lower case letters. The failure was introduced in function Inhibit Biased Climb, Line 4 by confusing two constants, the original version is shown as annotation in the line above.

A repair in Line 8 is more complicated. A look at the counterexample showed that to remove the error, function OBT has to return false when called in Line 42, and true when called in Line 25. Because OBT compares two input variables, it should always return the same values within a run. A repair at this position

In addition to the diagnosis, the approach gives us the value of nondet() that was chosen to avoid the wrong behavior for each of the identified expressions. This information is valuable to understand how to repair the program. In the example above, the condition of the conditional statement in Line 4 always selects the second, smaller, expression for return. To avoid the fault, we can also we replace the left expression by a negative value, indicating that the returned value should be smaller. Other versions of TCAS give even better replacements for the faulty expression.

E.g. in version 7, the fault was introduced by initializing a constant by 501 instead of 500. Examination of the suggested value for this line resulted in the correct assignment of 500 in order to remove the fault for all test cases.

Insert-, remove- and search-operations are implemented as with usual binary search trees. After such an operation, the tree is examined to check if it is consistent with the rules above. If not, constant time rotation and repainting operations are performed to restore the consistency. This ensures that the tree remains balanced and guarantees the time bounds.

rule (iv) and binary search tree order: after insert operations, a routine is called which traverses the tree. If a red node is found, it checks that both children are black. The same routine also performs a comparison of the values to ensure the correct order of the binary search tree.

Every node first is inserted to the tree like in a usual binary search tree. There- fore the tree is traversed to find the proper position for the new node. In the traversion routine, a comparison was changed from <= to == leading to a wrong order of the tree.

The first fault resulted in only one element giving the correct line of the fault for every test case. The second fault does not cause an incorrect tree for the first test cases. The second and third test case, however, lead to a diagnosis of three expressions containing the correct line. The state space for the fourth test case exceeded memory limits for the full diagnosis, but it was possible to check one by one if a expression from a previous test cases was also a in the diagnosis for the fourth test case. That way, we were able to rule out one expression and resulted in a final diagnosis with two elements.

We presented a new approach to localize faults in C programs by constructing a modified system that allows a given number of expressions to be changed arbitrarily. The new system contains the inverted specification from the original program. If we can find an error trace for the new system, we found expressions to repair the original program.

We have demonstrated the applicability of the approach on two examples. The run time of the approach can still be improved. A significant portion of the time is taken by parsing, unwinding and generating the internal representation of the program. This representation does not change during calculation of the diagnosis for a single program. Overall run time would be significantly reduced by using blocking clauses and rerun the SAT solver to find the full diagnosis, instead of rerunning the complete CBMC process.

