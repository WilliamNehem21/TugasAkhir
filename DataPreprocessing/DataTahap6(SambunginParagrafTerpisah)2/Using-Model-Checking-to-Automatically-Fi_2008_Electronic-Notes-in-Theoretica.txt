Downward and upward simulations form a sound and jointly complete methodology for verifying relational data refinement in state-based specification languages such as Z and B. In previous work, we showed how both downward and upward simulation conditions can be discharged using a CTL model checker. The approach was implemented in the SAL tool suite. Given the retrieve relation, each of the simulation conditions can be proven fully automatically. It has been recognised, however, that finding retrieve relations is often very hard. In this paper, we show how it is feasible to use the SAL model checkers to also generate retrieve relations.

SAL [6] is a tool-suite for the analysis and verification of systems specified as state-transition systems. Its aim is to allow different verification tools to be combined, all working on an input language designed as a format into which programming and specification languages can be translated. The input language provides a range of features to support this aim, and can, in fact, be used as a specification language in its own right. The tool-suite currently comprises a simulator and four model checkers, including LTL and CTL model checkers which we use here.

A specification is given as a SAL context. For example, below we have a context alloc representing the specification of a unique number allocator. A context groups together a number of definitions which include types, constants and modules for describing the state transition system. In our example we declare a type NAT , a subrange of the naturals whose maximum element is defined by the constant MAX . The module main declares a local variable as, a set of NAT 3 , and an output variable out of type NAT (representing the --> assignments. The guard is an arbitrary predicate which may refer to primed (i.e., post-state) variables. A guarded command is able to occur when- ever there exists values of the primed variables which satisfy both the guard and the assignments. The assignments may be nondeterministic as illustrated by the assignment to out ' in the transition aop. Any variables not explicitly assigned a value are unchanged.

Data refinement [7] is a formal notion of development, based around the idea that a concrete specification can be substituted for an abstract one as long as its behaviour is consistent with that defined in the abstract specification. An example refinement of the Z specification in Section 2.1 is given below.

[22] takes a more incremental approach, building the abstract and concrete transition systems as it executes. One of the reasons for developing this second algorithm was to avoid the need to supply the complete transition systems in advance. However, the approach is limited to downward simulation.

The fact that a retrieve relation exists is enough to know that we have a refinement. However, if we wished to know the retrieve relation, we could simply negate the property. Then, if a retrieve relation exists, the model checker will provide us with a counter-example which ends in a state with a retrieve relation. It will, in fact, be the weakest retrieve relation [22].

The SAL encoding is straightforward. We provide types AS and CS de- noting the set of abstract and concrete states respectively. These types are generally tuple types, each element being the type of a state variable. For example, if the abstract state has two variables, one of type X and one of type Y , then in SAL we would have:

Then we can define the type of R as a set of tuples of type [CS , AS ]. We can also define the initialisation of R, the condition Rok , and the deletion transition directly as above. A complete encoding for the unique number allocator refinement of Section 2 is shown below.

As shown in our previous work [26], the simulation conditions for data refine- ment can be encoded in SAL. Specifically, the branching time temporal logic CTL can be used to encode the standard downward and upward simulation conditions under both the blocking and non-blocking interpretations. Given a retrieve relation, these encodings can be used to automatically verify data refinements.

Consider the two Z specifications of the unique number allocator of Section 2. To check the refinement with a CTL model checker, we begin by combin- ing the abstract and concrete specifications into one specification by merging their state variables and operations. In general, we assume the variable and operation names of the abstract and concrete specifications are disjoint as in this example (if they were not, they could be made disjoint by a systematic renaming).

To check applicability we use the transitions corresponding to the abstract and concrete operations. The applicability condition holds if whenever an abstract operation can be performed, the corresponding concrete operation can be performed from any related concrete state. Thus the CTL check is as follows.

In the approach above the CTL property must hold on all initial states of the system, i.e, all possible pairs of abstract and concrete states. It relies on the fact that the same retrieve relation (that captured by the state variable R) is used when checking the property for each such pair of states.

Thus in our example SAL encoding described above, we add types AS and CS corresponding to the abstract and concrete state spaces allowing us to declare R as a set of pairs of concrete and abstract states (as in Section 3.2). Since chooseR is always enabled, we remove the skip transition. We also

In this paper, we have shown that temporal logic model checking can be used to automatically find retrieve relations between abstract and concrete state- based specifications. The existence of such a retrieve relation implies the concrete specification is a data refinement of the abstract one. Hence, the approach enables fully automatic checking of data refinements.

While we have shown this is feasible, we have not yet provided a practical method. The size of the state spaces, and hence specifications, we can handle is quite limited. This is mostly due to the fact that we need to include the retrieve relation (a set of abstract and concrete state pairs) as part of the state-space of our model. In our previous work where we provided, rather than calculated, the retrieve relation [26], it could be represented by a boolean variable, rather than a set, resulting in much greater efficiency.

The efficiency of the approaches in this paper could be improved using the optimisation features supported by the model checkers we have used. We have not investigated this possibility, using only the basic functionality of the tools. However, it seems likely that this will not solve the problem for any but the smallest of specifications.

A more promising way forward would be to use a technique which allows us to reduce the size of our models while maintaining the verity of the proper- ties we wish to prove. Such techniques include data abstraction [9], predicate abstraction [5,28] and data independence [24]. For example, data indepen- dence is based on the fact that sometimes properties we wish to prove are independent of the values associated with particular types. By these means it is possible to show that the refinement between the abstract and concrete unique number allocator specifications in this paper are independent of the maximum number allocated. Hence, verifying the refinement when this value is 2 infers the refinement for any other value. Exploration of this is left as future work.

