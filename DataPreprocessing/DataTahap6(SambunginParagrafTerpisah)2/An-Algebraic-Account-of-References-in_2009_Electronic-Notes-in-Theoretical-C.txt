We study the algebraic structure of a programming language with higher-order store, in the style of ML references. Instead of working directly on the operational semantics of the language, we consider its fully abstract game semantics defined by Abramsky, Honda and McCusker one decade ago. This alternative description of the language is nice and conceptual, except on one significant point: the interactive behavior of the higher-order memory cell is reflected in the model by a strategy cell whose definition remains slightly enigmatic. The purpose of our work is precisely to clarify this point, by providing a neat algebraic definition of the strategy. This conceptual reconstruction of the memory cell is based on the idea that a general reference behaves essentially as a linear feedback (or trace operator) in an ambient category of Conway games and strategies. This analysis leads to a purely axiomatic proof of soundness of the model, based on a natural refinement of the replication modality of tensor logic.

Abramsky, Honda and McCusker carried on in this line and established a similar result for a call-by-value language with higher-order store, in the style of ML general references. Recall that general references can store not only values of ground types (i.e. integers, booleans) but also those of higher types (procedures, higher-order functions, or references themselves). They provide a useful and powerful program- ming construct: the ability to write, to read and to transmit higher-order informa- tion through the store is essential not only for efficiency but also for clarity of the program structures involving states. Thus, the definition of a fully abstract model characterizing the programs written in this paradigm was an important achievement of game semantics. The interested reader will find in [22] a recent application of the model to an investigation of aspect-oriented programming.

is an isomorphism. One main reason for relaxing linear logic into tensor logic is that this enables to define a general notion of replication modality for categories of games and strategies. Indeed, such a category of games and strategies typically defines a dialogue category C. A replication modality is then defined as a monoidal adjunction between the dialogue category C and a cartesian category M

One missing ingredient in Conway games (however) is a notion of well-bracketing which enables to constraint the strategies of arena games. Hence, we take advantage of our recent construction of a compact closed category of Conway games and well- bracketed strategies, see [19]. In fact, our construction goes much further than this, since we are able to see the very notion of well-bracketing as an effect of linearity conditions on games and strategies. Although this logical aspect of the construction is fundamental, its role is very limited here. So, we will avoid discussing the details of the construction. Let us simply mention that in order to define a notion of bracketing on Conway games, while keeping the self-dual nature of Conway games, one needs to replace the traditional notions of question and answer by the more conceptual (and expressive) notions of query and response attached to the moves. See [19] and [26] for details.

It appears that the category of call-by-value games defined by Abramsky, Honda and McCusker is isomorphic to a well-understood subcategory of the Kleisli category induced by the replication modality on our category of bracketed games. In fact, we could easily use their full abstraction result directly in order to obtain a full abstraction result for our model. But this is not really our point, here. The only novelty of our work is that the strategy cellA interpreting a memory cell of type A is obtained in a nice and conceptual way in our formulation.

One embarrassing point about this game-theoretic approach on references is that one needs to extend the programming language with a bad variable constructor in order to achieve the expected full abstraction result, characterizing programs as visible (or thread-independent) well-bracketed strategies. This particular problem is nicely explained and corrected in [18] and [21] for ground type references, by refining the notion of arena game. The main idea is to constrain the use of read and write moves by introducing new relations on plays and strategies to express an aspect of uniformity characterizing the interaction of every memory cell strategy. The main idea is that in absence of bad variables, each variable operation, whether a Read or a Write, produces the same side-effects while it is being completed.

There are not so many axiomatic approaches to programming languages based on game semantics. Let us mention three of them however. Abramsky gave a purely axiomatic proof of definability for PCF [1] followed by an axiomatic proof of full completeness for models of ML polymorphic types, in collaboration with Lenisa [3]. A few years later, Laird worked out an axiomatic proof of definability for a language with higher-order store [14]. His construction starts from the definition of an asymmetric tensor product on games, discussed with the first author a few years whose task is to enforce that every time a read access is performed on the memory cell, it reads the last written value. We start by defining this strategy in the language of Conway games, before describing the series of algebraic properties it satisfies. It is worth observing already that since the strategy is not innocent (not even visible), there is no hope to define it using structural morphisms. Given a play s of the game

Coarsely speaking, Diagram (9) states that the memory cell behaves as the constant cell on the first copy. Diagram (10) states that the copy in B are linked to the last opened copy of A. It is worth stressing here the crucial use of the strength of the monad T in order to express the order in which the different copies are opened and played.

type system of the original programming language, in order to integrate the hugely extended notion of control provided by linear logic. It would be also interesting to analyze the models defined by McCusker [18] and Murawski [21] in order to avoid the bad variable constructor mkvar in the definition of the language. More gener- ally, we believe that much remains to be done in order to understand the algebraic structure of memory in game semantics. Ideally, this algebraic analysis should con- nect the game models based on visible or thread-independent strategies studied in this paper, with the monadic approach to general references recently advocated by Tzevelekos [27] which is based on innocent strategies and a state monad defined by recursion on all types.

