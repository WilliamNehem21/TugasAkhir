Refactoring is the process of improving the design of a program whilst pre- serving its behaviour. Separating general software updates into functionality changes and refactorings has well-known benefits. This process is supported both by catalogues documenting the effects and side-conditions of refactor- ing steps and, more importantly, by tools. Tools can ensure the validity of refactoring steps by automating both the checking of the conditions for the refactoring (using various program analyses) and the application of the refac- toring itself, thus making refactoring less painful and less error-prone.

The initial release of HaRe contained a repertoire of scope-related single- module refactorings; multiple-module versions of these refactorings were added in HaRe 0.2, and various data refactorings were added in HaRe 0.3. This version restructures HaRe to expose an API to our infrastructure for imple- menting refactorings and more general transformations of Haskell programs.

In worker the functions applyTP, once buTP, failTP and adhocTP are type-preserving strategy combinators from Strafunski [2]. once buTP performs a bottom-up traversal of the AST, terminating after its argument function succeeds at one node. In this case its argument fails at every type except HsExpP, where it calls function inExp. This latter function transforms the current expression into a case expression if the expression refers to the same occurrence as the user-selected expression, otherwise, it fails. So, the overall effect is to transform the first (and only) occurrence of exp.

