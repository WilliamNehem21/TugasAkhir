In the Unified Modeling Language (UML) different views of software systems are specified by different models. The abstract syntax of the modelling languages is defined precisely in the UML standard, but the (dynamic) semantics up to now are only sketched in natural language descriptions. Moreover, the correspondences between the different models are not described precisely. In this paper I present an abstract semantic domain that has been defined independently of the UML and can be used to provide formal semantics for the different modelling languages. Since one common domain is employed also the integration of the different viewpoint models is supported by this approach.

In the UML standard the abstract syntax of the language(s) is defined precisely using the meta model. The semantics, however, in particular the dynamic semantics of the behaviour models, are only informally described in natural language. Obviously, this leads to a certain lack of precision, and some important design decision are left open. Furthermore, the are no precise statements about the semantic interrelations and correspondences between the different models. That means the integration problem cannot be addressed satisfactorily yet.

In order to establish transformation systems as an internal model of the UML the different modelling techniques have to be mapped to this domain, i.e., their semantics have to be defined in terms of transformation systems. Thereby the meaning of the constructs can be made precise, and the cor- respondences between the different techniques can be formulated, since all languages are interpreted in the same domain. Due to the complexity of the UML languages these mappings should be defined incrementally of course, starting with kernel languages that are extended step by step.

semantics of a UML model as a set of transformation systems, that contains all admissible interpretations as elements. Furthermore, different models may address different levels of abstraction and granularity. For example, some models specify single objects whereas others concern collections of objects. Thus mappings of transformation systems are needed, like projections, that allow us to relate such different models and formalize their correspondences. Sets of transformation systems as formal semantics of viewpoint models, to- gether with the appropriate mappings reflecting their correspondences, then allow us to define the semantic integration of a collection of models by the intersection oftheir admissible interpretations. A collection ofmodels is con- sistent ifthe intersection is not empty, and it is complete ifit has exactly one element, i.e., ifall models together specify the system completely.

As mentioned above the domain of transformation systems beyond the single models also provides composition operations and development relations. As an added value ofthe approach presented here these can be reflected to the UML languages to discuss and make precise notions ofobject composition and refinement for example. This aspect, however, will not be discussed further in this paper.

Transformation systems are extended labelled transition systems, where both the transitions and the states are labelled. The unlabelled part ofthe system, given by a set of control states and transitions, is just a directed graph , called the transition graph of the system. It represents the skeleton of the dynamic behaviour, by stating the existence of control states and transitions, without showing their internal structure or contents. The labels for the transition graph are provided by the data space of the system, that contains all possi- ble data states and data state transformations according to the given static structure.

A system snapshot, given by the states ofa collection ofobjects and their links, can be modelled by replacing algebras as data states by families of algebras, where each member represents the data state of one of the objects. In this way the projection to a single object is supported, and collections need not be encoded into single algebras artificially. Then object references can be represented by introducing designated class sorts and additional reference functions that map elements of class sorts (= object references) to members of the family of algebras (= object states). A state of a system is thus formally modelled by o.t is evaluated in a snapshot, starting at a designated algebra C0, asfollows. Evaluation of o yields a reference r = oC0 in a class sort of C0. Applying ref 0 yields the index j = ref 0(r) ofthe algebra Cj, where finally t is evaluated. The term marriedWith.name evaluated at object C0 for example yields 'Sabine',

elements of the corresponding class sort. The relation models the links as instances of the association in the actual state, whereas the constants make possible to navigate along the association. They can be restricted accordingly to represent uni-directional associations and multiplicities. Compositions and aggregations are represented analogously; concerning the static viewpoint they are just associations.

Finally inheritance relations give rise to extensions of the local class data space signatures, where the signature corresponding to the super class is added to the one of the subclass. Note that the extensions of the local class data space signatures w.r.t. the relations must proceed in the right order. For example, associations are inherited, whence the association attribute role has to be added before the inheritance relation is translated. More details on the translation from class diagrams to diagrams of transformation specifications can be found in [12].

As mentioned above a data space usually contains much more data states and transformations than intended. Although finally the mapping from the transition graph selects the right parts, the data space can also be reduced in advance by adding further constraints or axioms to the data space signature. According to the structure of transformation systems and data spaces (and signatures) they can be grouped as follows.

Pre and post conditions constrain single transformation steps. In order to constrain the set of transition graphs, i.e., the overall behaviour, other specification means have to be considered. As opposed to the static properties and pre and post conditions, there is no canonical choice in this case. In

The discussion ofthe specification means should have shown the intended application to the UML already. In a UML model object constraints specified in the object constraints language OCL [14] are used to reduce the set ofdata states and transformations. The most important features, data invariants, navigation, and pre and post conditions have been discussed above, indicating the intended mapping ofthe OCL. Other behaviour specifications are specified next.

In [5] a transition system semantics for UML state machines has been de- fined, based on a corresponding construction in [4] for STATEMATE state charts. Since it is very close to the aspired transformation system semantics it only remains to rephrase this construction w.r.t. the terminology of transfor- mation systems and to point out which items are under-specified and lead to sets ofadmissible interpretations. The main difference with [5] is in fact that the action semantics are assumed to be specified completely there, whereas in the transformation system approach all admissible interpretations of the given information are considered.

4. global clock and local timer states (see [5] for details). Furthermore, since a unique data state has to be attached to the control state, sufficient data state information has to be added which the complete data state can be re- covered from. This additional data information is represented in the formal object model introduced in [15] for example by taking the cartesian product of (pure) control states and data states. Considering the corresponding pairs immediately as control states is just a formal variant that is needed here to obtain the label mappings as total functions.

To define the data states the attribute declaration of the corresponding class, including the concerned data types, has to be given at least. (In fact, state machines cannot be built without a corresponding class.) It yields the algebraic part of the data space signature. The corresponding algebras may have a fixed part for the static data types. The values of the independent attributes in an algebra representing a data state must be obtained from the control state it is attached to. That means, these values must be contained in the control state. Further derived parts, like derived attributes, can then be constructed to obtain the complete data state. Different interpretations are admissible at this point if static data types are declared but not completely

The transitions for the transition graph are given by sets of state machine transitions that are enabled (w.r.t. a given event e and a condition), con- sistent, maximal, and have highest possible priority (see [5,9]). Their input and output control states in the transition graph are given as defined in the state machines semantics. Note, however, that these now contain also data state information. In the example mentioned above for example at least the value ofthe attribute att must be given in the control state in order to obtain its data state. Accordingly, each transition also determines the data state transformation corresponding to it. This yields further choices for admissible interpretations, since the effect ofthe method m is not specified. Correspond- ing OCL constraints in the class could reduce the number of interpretations, but need not determine exactly one.

According to the semantics ofstate machines each transition (ofthe transi- tion graph) contains exactly one event. This fact will be used for the composi- tion ofstate machines represented by the corresponding composition operation applied to the transformation systems associated with the state machines. It is based on a synchronization ofsteps, where in this case a method call (event) can be synchronized with the execution ofa method (action). (Concerning the definition and further discussion of composition operations for transformation system see [6,8].)

Transformation systems constitute a formal semantic domain for the interpre- tation of different software specification techniques. By mapping a language to this domain its semantics can be made precise and formalized. Moreover, relations between different languages can be investigated on the semantic level. Reflecting these back to the syntactic level correspondences between different models are obtained. Furthermore, also consistency of heterogeneous specifi- cations can be checked due to the interpretation in one common domain. This yields a very flexible and general integration framework for software specifica- tion techniques.

