The Matlab Simulink tool is widely used to construct and analyse control law diagrams. Many have worked on techniques to enhance analysis facilities, and previously, we have considered the complementary problem of proving correctness of implementations of diagrams. We use Circus, a refinement language that combines Z and CSP, and can capture both functional and behavioural aspects of diagrams and programs. We defined a Circus semantics for an extensive subset of discrete-time diagrams, and now extend it to cover Stateflow blocks, which are themselves defined by diagrams written in (a variant of) the statechart notation. We highlight the challenging features of the semantics of a diagram, describe how Circus models can be constructed, and discuss the formalisation of the Circus semantics as algebraic translation rules.

Control law diagrams are very popular among engineers as a design notation for control systems; in particular, the Simulink tool is widely used in the avionics and automotive sections [11]. It supports construction of diagrams and analysis based on simulation. A diagram is composed of blocks connected by wires. The input and output signals are indicated by special blocks; the wires determine the flow of signals and blocks embed functionality that determines how the outputs are calculated.

The subset of Simulink that we model using Circus is extensive, including action and enabled subsystems and merge blocks. Here, we take a first step to extend this work to tackle Stateflow blocks. We give a Circus semantics to Stateflow diagrams that can be used as a component of the model of the Simulink diagram that includes it. We aim at using refinement to verify implementations of Stateflow blocks.

A CSP semantics for the statechart notation as used in UML state diagrams is provided in [13]. In addition, Circus is used in [15] to give semantics to UML- RT, a UML profile tailored for concurrent applications. That work covers the state diagrams, which are again a variant of statecharts, and also part of a more compre- hensive description of the system including class and structure diagrams. In both works, refinement is the basis for reasoning, either using the CSP refinement model checker, or refinement laws for model transformation. The statechart diagrams that we consider here, however, are rather different from those in UML and UML-RT.

The Stateflow notation is rather complex. A state can have outer transitions that lead to state change, and inner transitions that model computations carried out whenever the state is active: a state can itself include flowcharts. Junctions can be used to break an outer or inner transition in segments. Transitions to junctions backtrack if they do not eventually lead to a new state, or to a terminal junction.

In this paper, we propose a Circus semantics that covers all these features. In the next section, we give a brief overview of Circus, and Section 3 explains the main features of Stateflow diagrams. The structure of the Circus models of Stateflow diagrams that we propose is discussed in Section 4; formalisation of the semantics is considered later on in Section 5. In Section 6 we use small examples to illustrate how we can handle some of the more intricate features of the diagrammatic notation. Finally, in Section 7, we discuss related and future work.

A process encapsulates a state and exhibits some behaviour. The state is defined by schemas, like in Z. The behaviour is defined using a (main) action, which possibly combines data operations specified in Z, CSP constructs like prefixing, choice, and parallelism, and imperative commands like assignments and conditionals.

The transmission uses the power generated by the engine to move the wheels. The block ManeuversGUI defines the inputs Throttle and BrakeTorque; the block PlotResults defines the outputs EngineRPM and VehicleSpeed. The system takes the amount of air entering the engine (that is, the throttle) and the force applied on the brakes, and outputs the speed of the engine and of the vehicle. Its behaviour is cyclic: it repeatedly samples the inputs and produces the outputs, possibly using information calculated in the previous cycle.

The blocks of the diagram model the components of the system. A transmission has two impellers: one interacts with the engine and the other with the wheels. Roughly, the Engine block calculates the speed of the engine as a function of the torque of the first impeller and the throttle. The engine speed, the gear, and the in parallel, but are active in parallel. Each of them is defined by OR (exclusive) states, which can only be active one at a time. All these substates are basic: they have no further substates. The events UP and DOWN are broadcast internally; they are directed to gearstate and are treated by whichever one of its substates is active.

A condition is a boolean expression on the data variables. We omit the precise def- inition of the syntax, and assume that there is a direct correspondence between the elements of a given set Condition and Circus conditions. If a condition is missing, we define it as true. The transitions between the substates of gearstate, for example, are guarded by events, and those in selectionstate are guarded by conditions.

For each of them, we give the set of channels that it uses. The parallelism re- quires that the processes synchronise on their common channels. Internal chan- nels like ImpellerTorque, upth, downth, gear , CALC TH , and so on are hid- den. In this way, autotrans communicates with its environment using the channels Throttle, BrakeTorque, EngineRPM , and VehicleSpeed , which model the inputs and outputs of the diagram, and end cycle. The process Engine interacts with Transmission on ImpellerTorque, EngineRPM , and end cycle. Similarly, ShiftLogic and Transmission interact on gear and end cycle.

In the diagrams, the hierarchical state structure is used to define the scope of events and data. The transitions, however, do not respect this organised nesting of scope; they can direct flow of execution between states at any level of the hierarchy. For this reason, in our model, we have an action Cycle, which reads and stores all data, and makes it available for another action Chart , which models the behaviour of the statechart. In each cycle, the inputs are read, and made available to Chart through internal channels. Similarly, internal channels are used to read the outputs from Chart ; they are communicated just before the end of the cycle. There is an internal channel for each input and output channel; in our example, they are ispeed , iupth, idownth, igear , and iCALC TH . The type of these channels is  ; it is not part of standard Z, but a universal type in the dialect of ProofPower-Z, the theorem prover that we use to mechanise our models and verifications.

In the life-cycle of a diagram, all states are initially inactive; in the first cy- cle, some states are entered and become active, due to (a combination of) default transitions and AND compositions. Afterwards, in each cycle, the active states ex- ecute, that is, process its transitions and any events generated, and then sleep. The sleeping status is signalled using a channel sleeping , which is used by the action Cycle to determine the point in which the outputs should be communicated, before signalling the end of the cycle using end cycle.

These channels are grouped in the set IChannels, defined as follows for our example. channelset IChannels =^ {| ispeed , iupth, idownth, igear , iCALC TH , sleeping |} The components of the state of a Stateflow process hold the values of the inputs and outputs, and of any local data variables. The action Cycle updates them.

In a parallelism of actions, we need to associate with each parallel action the subset of the variables in scope that it can update; these subsets must be disjoint to avoid racing conditions. In our case, Cycle has control over all state components; they are grouped in a set called vVar . The action Chart modifies no variables.

The action Input reads all the inputs of the diagram; it is used by Cycle at the beginning of each cycle. It is an interleaving that reads each input and records it in the corresponding variable. Strictly speaking, in an interleaving, we also need to define the name set associated with each action; we omit these in our example, as they are obvious. Similarly, the Output action communicates the values of the outputs, and is used by Cycle after the chart sleeps.

In each cycle, the action Cycle initialises the value of the variables that corre- spond to output events to 0; in our example, Cycle initialises vCALC TH . Event signals can take the value 0 or 1. If a chart does not raise an event in a cycle, then by default its value is 0. For output data we do not have such concern, since the chart should always define its value explicitly.

Each state S of the diagram is modelled by three actions called S Enter , S , and S Exit , as needed. The S Enter action models the behaviour of S when it is entered, S models its behaviour when it is active, and S Exit when it becomes inactive. The definitions of these state actions depend on whether S has an OR composition, an AND composition, or is a basic state.

For a state with an AND composition, the Circus Enter action executes the entry action of the state, and then executes all Enter actions of the substates in parallel. In addition, the S action is run in parallel to control their order of execution, using the channels start and stop. The synchronisation sets are defined by the pattern of communication between states, which can be determined by the raising and accepting states of the local events . This is further discussed in Section 5.

The S action of a state with an AND composition controls the order of execution of the substates. In our example, in each cycle Top uses start .1 to start the execution of Topgear state, waits for it to become ready to sleep, which is signalled by stop.1, and then does the same for Topselectionstate using start .2 and stop.2. The Enter actions of Topgear state and Topselectionstate also use start and stop to determine when they can start and signal when they are ready to sleep.

In our example, the state gearstate does not have any of these components, so that Topgear state is simply Skip, and we omit it. On the other hand, selectionstate has a during action, which raises CALCTH. This is modelled in Topselectionstate by synchronisation on the internal channel iCALC TH .

Similarly, an action of a basic state handles the during action, the transi- tions, and then sleeps if no outer transition is taken. An example is the action Topselectionstateupshifting . It calls the action for its superstate, then it reads the variables that it needs to make decisions on the transitions, and then checks which transition conditions are valid. In this case, the conditions are mutually ex- clusive and the conditional is quite simple. In the general case, we need to guarantee the order of testing; this is further discussed in Section 5.

Since parallel states execute in order, their substates have to wait for a synchronisation on start before they can execute. As already mentioned, the Enter actions of the parallel states wait to synchronise on start . The Enter ac- tion of a basic substate signals that it is ready to sleep using stop; the action Topselectionstateupshifting Enter is an example. Since there is no entry action in this case, it immediately signals stop. The action Topselectionstateupshifting , as a basic substate of a parallel composition, also uses start and stop to control its points of execution. In fact, in our example, since the chart is composed of parallel states, every basic state uses the start and stop channels.

To define Cycle, we introduce four sets of pairs of names. The first, inputs, contains the pairs formed by a name of an input data or event, associated with the corresponding v -prefixed name; similarly, outputs contains the pairs corresponding to names of outputs. Finally, iinputs and ioutputs contains pairs of matching i - prefixed and v -prefixed names; iinputs contains the names coming from inputs and local variables, and ioutputs those from outputs and local variables. In iinputs the local variables are prefixed with iread , and in ioutputs, with iwrite. Using these sets, we define the actions below used in the definition of Cycle sponding state component; the second outputs the value of the state components. The actions IChartOut and IChartInp define the interface between Cycle and Chart . The Cycle is always willing to output the value of any of the input data, or read the value of any of the outputs; local variables can be both read and written by the chart. The name sets associated with the interleaved actions are the singletons that contain the assigned variable, if any; they are omitted above.

The action Np is similar to Np Enter , but instead of executing the entry ac- tion, it executes the during action st .state(s).during , and instead of executing the default transitions, it executes the outer and inner transitions. In fact, the tran- sitions can only be handled here if the substates do not have exit actions. Other- wise, each substate has to handle the transition of this superstate. The function O [[ st .state(s).outer ]]TS translates the outer transitions; it takes as an extra pa- rameter the action to be taken if none of the transitions are available: we give the

A first concern of many works is the reliance on positioning of parallel states and transitions to determine the order in which they are executed. In our work, this is handled by the parser of Stateflow diagrams; our abstract notation is explicit about the order. So, this issue is handled in the semantics in a straightforward way, as already explained and exemplified in the previous sections.

Another issue is related to the possibility of the treatment of a local event raising that same event again, which leads to nonterminating behaviour. The following diagram is considered in [17]. It is an OR composition, whose default transition enters a state A. The entry action of A raises the event E, and it is treated by A.

In the environment that records the source and target of E, we can immediately identify that E is both raised and received by A. In this case, the use of the interrupt operator to treat E is not appropriate. Instead we conflate the generation and treatment of E into a single event. Since the channel E is hidden in the model of the diagram, the event happens as soon as it becomes available.

To model backtracking, transitions need to be executed in parallel, with channels ok and backtrack used to signal whether a transition succeeded, and the others should be abandoned, or whether it failed and the second should take over. For each pair of transitions, a fresh pair of ok and backtrack channels is needed. Since the data is managed separately by Cycle, all transitions have access to it.

To model such behaviour, a History action is run in parallel with the immediate superstate of the composite state. It keeps track of the active substates, and is used by the Enter action to determine the substate to be activated. In addition, the History action uses the default transitions to determine the state that becomes active the first time the composite state is entered.

If a history junction is the target of an inner transition, if it is followed, the current substate is exited and re-entered. So, the Enter action is not affected in this case. It is possible to have a History action that determines the next state to be entered when the inner transaction is taken, or a model that executes the exit and enter actions directly. The first approach is more general.

The work presented in [2] models Stateflow diagrams as finite state machines de- scribed in SMV. The translation from the Stateflow notation to SMV is automated, but not formalised. The subset of Stateflow considered does not allow nested event generation and does not include non-Boolean input signals, junctions with more than one input transition, transition actions, or output events.

An automaton model is used in [18]; this work suggests a reasoning approach for hybrid systems based on traditional model checking techniques. The encoding of Stateflow diagrams as communicating pushdown automata is informally described, as is its further translation to SAL. The subset of the Stateflow notation covered does not allow inner transitions or junctions, although the work can be extended.

Our model does present some limitations; we still have to study the impact of transitions to and from substates of a parallel composition that cross the parallel state, for example. In addition, further validation of the models is also necessary, since so far we have considered only small examples, and still have to complete the definition of the semantic functions. Our next step is the automation of the model construction, so that large case studies can be conducted. Our long-term goal is to extend the refinement-based verification technique for implementations of Simulink diagrams to cover implementations of Stateflow blocks.

