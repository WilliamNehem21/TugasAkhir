and undirected graph variables, a nucleus of basic constraints upon which more complex and useful constraints can be provided ranging from constraints to impose graph properties (order, size, degree, reachability, connectedness, path, . . . ) and to impose graph relationships (underlying and oriented, reverse, complementary graph relationships). As demonstrated in [26,27], GRASPER appeared as an alternative to CP(Graph), the state-of-the-art graph constraint solver [10,9] in the comparison made between the two for the Metabolic Pathways Problem [1,24,17], a problem which can be viewed as a path discovery problem in biochemical networks.

A problem where relations between variables (to which values must be assigned) are restricted by a number of constraints that must be satisfied, is referred to as a Constraint Satisfaction Problem (CSP) [16]. The goal, in Constraint Programming (CP), is to assign values to all the variables without violating any constraint, or to prove this to be impossible. The space formed by all possible combinations of assignments is referred to as the search space.

Recently, graph domain variables were defined [10,9,26,27] providing new oppor- tunities for modelling graph-related constraint problems. Graph domain variables were defined over two finite sets, one for the set of vertices and one for the set of edges, each edge being a pair of elements in the set of vertices. Examples of graph-related problems are job-shop scheduling [13], planning [19], graph colouring [11], circuit analysis [14], among others. Finite graph variables also allow a direct implementation of constraint graphs, where each vertex represents a variable and each edge a constraint imposed on those variables making it a very intuitive way of understanding and programming constraint networks.

constraints. If the domain of some variable becomes empty after the application of such techniques, then the CSP is insoluble. Otherwise, the CSP is said to be consistent (with regard to some properties) and there may be a solution, which has to be found to definitely prove one exists.

Definition 3.1 [Set variable] A set variable X is represented by [aX, bX ]cX where aX is the set of elements known to belong to X (its greatest lower bound (glb)), bX is the set of elements not excluded from X (its least upper bound (lub)), and cX its cardinality (a finite domain variable). We define pX = bX \ aX to be the set of elements, not yet excluded from X and that can still be added to aX (or, to put it short, poss).

In this section we explain how the path constraint was implemented in GRASPER and also explain, in general terms, how CP(Graph) imposed this constraint, ana- lyzing both solutions. For the next sections, we will denote S' as the new state of a variable S (after propagation) and S as its previous state. The glb of S will be represented by S and the lub of S by S.

which is basically a direct translation of the problem into a network of constraints. The major difference between both methods is the underlying structure that is used to impose these constraints. In the case of GRASPER we fetched a priori all the predecessor and successor sets for each vertex, which as explained previously, is very time and space consuming, whereas CP(Graph) opted for developing a view over the graph raw domain structure which could provide very efficient access to the vertices adjacency sets.

Finally, to solve the constraint of mandatory molecules, it is sufficient to add the vertices representing these molecules to the graph thus ensuring that any solution must contain all the specified vertices. With this mechanism, however, it is not guaranteed that the intended pathway is the shortest pathway between the given initial and final vertices (e.g. one of the mandatory vertices does not belong to the shortest path), so we cannot rely on breadth-first search and must find a different search strategy for solving this problem.

of all the vertices and edges of the problem, that v0 and vf are the initial and the final vertices, that Mand = {v1,..., vn} is the set of mandatory vertices, that Excl = {(ve11, ve12),..., (vem1, vem2)} is the set of exclusive pairs of vertices and that Wf is a function mapping each vertex to its degree, this problem can be easily modeled in GRASPER as:

The minimisation function can be found built-in in almost every constraint pro- gramming environment. The subgraph relation is directly mapped to our subgraph constraint (consult [27] for details on the subgraph constraint) and its objective is to allow the extraction of the actual pathway from the original graph containing ev- ery vertex and edge from the original problem. The introduction of the mandatory vertices is easily achieved by a mere set inclusion operation. The exclusive pairs of reactions demand the implementation of a very simple propagator which basically removes one vertex once it is known that another vertex has been added to the graph and they form an exclusive pair of reactions. The weighting of the graph is performed using the weight constraint (consult [27] for details on the weight constraint). These simple operations sketch the basic modelling for this problem, however it is still necessary to perform search so as to trigger the propagators and determine the set of vertices that belong to the pathway and the edges that connect them.

We use a labeling strategy that consists in iteratively extending a path (initially formed only by the starting vertex) until reaching the final vertex. At every step, we determine the next vertex which extends the current path to the final vertex minimizing the overall path cost. Having this vertex we obtain the next edge to label by considering the first edge extending the current path until the determined vertex. The choice step consists in including/excluding the edge from the graph variable. If the edge is included the current path is updated and the last vertex of the path is the out-vertex of the included edge, otherwise the path remains unchanged and we try another extension. The search ends as soon as the final vertex is reached and the path is minimal. This heuristic shall be referred as shortest-path [23].

