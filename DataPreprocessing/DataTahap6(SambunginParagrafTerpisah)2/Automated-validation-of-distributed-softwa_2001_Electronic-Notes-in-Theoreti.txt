This paper summarizes our experience with IF, an open validation environment for distributed software systems. Indeed, face to the increasing complexity of such systems, none of the existing tools can cover by itself the whole validation process. The IF environment was built upon an expressive intermediate language and al- lows to connect several validation tools, providing most of the advanced techniques currently available. The results obtained on several large case-studies, including telecommunication protocols and embedded software systems, con rm the practical interest of this approach.

Automated validation of distributed software is a desirable objective to im- prove the industrial production of correct systems like communication proto- cols or embedded systems. In spite of the numerous ongoing researches and tool developments carried out in this area, this activity remains di cult in practice: on the one hand the initial software description is usually provided in a high-level formalism (either a programming language or a formal design notation like Lotos [23], Sdl [25] or Uml [30]), and, on the other hand, a wide range of tools are necessary to cover the whole development process, operat- ing at di erent levels of program descriptions. Even if several interesting tools are currently available, either commercial or academic ones, none of them can ful ll in itself all the practical needs.

Commercial tools (such as ObjectGeode [32], Tau [1], StateMate [22], Rational Rose [31], etc.) provide several development facilities, like editing, code generation and testing. However, they are usually restricted to basic veri cation techniques (exhaustive simulation, deadlock detection, etc) and are \closed" in the sense that there are only limited possibilities to interface them with others. On the other hand, there exist numerous academic tools (like Smv [28], Hytech [19], Kronos [34], Uppaal [27], Spin [20], InVeSt [2], etc.) o ering a broad spectrum of quite e cient veri cation facilities (symbolic veri cation, on-the- y veri cation, abstraction techniques, etc.), but often supporting only low-level input languages. This may restrict their use at an industrial scale.

The speci cation level is the initial program description, expressed for instance using an existing language. To be processed, this description is (auto- matically) translated into its IF representation. The main input speci cation formalism is Sdl, but connections with other languages such as Uml, Lotos and Promela are envisaged.

gates. Processes are based on timed automata with deadlines [3], extended with discrete variables. Process transitions are guarded commands consisting of synchronous/asynchronous inputs and outputs, variable assignments, and clock settings. Bu ers have various queuing policies ( fo, stack, bag, etc.), can be bounded or unbounded, and reliable or lossy.

A well-de ned api allows to consult and modify the abstract tree of the IF representation. Since all the variables, clocks, bu ers and the communication structure are still explicit, high-level transformations based on static analysis (such as live variables computation) or program abstraction can be applied. Moreover, this api is also well suited to implement translators from IF to other speci cation formalisms.

In the symbolic representation sets of states and transitions of the Lts are expressed by their characteristic predicates over a set of nite variables. These predicates are implemented using decision diagrams (Bdds). Existing applications based on this api are symbolic model-checking and minimal model generation.

The Sscop (Service Speci c Connection Oriented) protocol is standardized un- der reference itu-t q2110 [24]. Originally, it was conceived to reliably transfer data between two high bandwidth network entities. Although its design makes it ready to treat signi cant volumes of data, currently its use is con ned in ones of the underlayers of the aal layer (Atm Adaptation Layer). The services it provides are connection control (establishment, ow-control, release), data transfer, and error detection.

The Sscop standardization document contains an Sdl description of the protocol. This description has been coded by France Telecom R&D using ObjectGeode.	It consists in approximately 2000 lines of Sdl textual code which describes the protocol as one single process with 10 control states, 134 variables, and 4 timers. The description was centered on signaling and some simpli cations have been made according to Sscop implementations available in France Telecom R&D. Our main goals were the formal validation of the speci cation and, in addition, automatic test-case generation starting from it. Clearly, the size and complexity of this speci cation made any brute force validation approach not applicable. In particular the data part was very large, and each state of the underlying model could not be stored in less than 2kB.

techniques. More precisely we considered a system consisting in a pair of enti- ties, communicating through a bounded fo channel, and we concentrated our validation e ort to a set of representative distinct scenarios (connection estab- lishment, disconnection, data transfer, . . . ). Using speci c slicing criteria, it was therefore possible to (automatically) simplify even more the speci cation, depending on the property under veri cation or the test purpose. The under- lying models obtained were about 20 000 states large, and errors were found in the data transfer phase of the speci cation. The complete experiment is reported in [9].

The Mascara(Mobile Access Scheme based on Contention And Reservation for Atm) protocol is a special medium access control protocol designed for wire- less Atm communication and developed by the wand(Wireless Atm Network Demonstrator) consortium [13]. A wireless Atm network extends transparently services to mobile terminals (mt) via a number of geographically distributed access points (ap). The task of the Mascara protocol is to mediate between aps and mts via a wireless link. The protocol has a layered structure, where we consider only the highest layer, the Mascara control layer.

The overall description of the Mascara protocol which we got is 300 pages of Sdl textual code. We concentrate on the veri cation of the Mascara con- trol layer, for which the Sdl description could be made reasonably complete. Here we brie y present the veri cation of the dynamic control. For complete information, we refer the reader to [17] which reports the complete experiment on the dynamic part. In addition, another veri cation experiment has been carried out on static control[4].

The IF environment has already been used to analyze some representative Sdl speci cations such as Sscop, an Atm signalisation protocol, Mascara, an Atm wireless transport protocol and Ariane-5 ight program, a part of the embedded software of Ariane-5 launchers. It is currently used in several on going industrial case-studies, including respectively real-time multicast proto- cols Pgm and Rmtp-ii, and the session initiation protocol Sip. The bene ts of combining several techniques, working at di erent program level, were clearly demonstrated. In particular, traditional model-checking techniques were not su cient to complete on these large size examples.

rst direction of improvement concerns the IF language. As currently de ned, it allows only the description of static systems, were the number of compo- nents (processes and bu ers) as well as their interactions are xed throughout the execution. This strongly limits our ability to handle complex dynamic speci cations. We work on a less restrictive de nition, where both parameter- ized descriptions (containing some xed number of replicated components) as well as general dynamic creation and destruction of components are allowed. Furthermore, some improvements will be made regarding the description of components itself, such as the possibility to express structured control using composed states (like in statecharts).

