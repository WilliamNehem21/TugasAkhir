The tracer Hat records in a detailed trace the computation of a program written in the lazy functional language Haskell. The trace can then be viewed in various ways to support program comprehension and debugging. The trace was named the augmented redex trail. Its structure was inspired by standard graph rewriting implementations of functional languages. Here we describe a model of the trace that captures its essential properties and allows formal reasoning. The trace is a graph constructed by graph rewriting but goes beyond simple term graphs. Although the trace is a graph whose structure is independent of any rewriting strategy, we define the trace inductively, thus giving us a powerful method for proving its properties.

Usually, a computation is treated as a black box that performs input and output actions. However, we have to look into the black box when we want to see how the different parts of the program cause the computation to perform the input/output actions. The most common need for doing this is debugging: When there is a disparity between the actual and the intended semantics of a program, we need to locate the part of the program that causes the disparity. Other reasons for observing how a program works are checking internal consistency properties (cf. assertions), reverse-engineering of an insufficiently documented program, and learning to pro- gram. Tracing is the process of obtaining additional information about the internal workings of a computation.

Haskell tracer Hat integrates several methods [27]. During a computation a single unified trace, the augmented redex trail (ART), is generated. Separate tools provide different views of the ART, for example algorithmic debugging [23,19,22], following redex trails [26] and observing functions [12].

Hat transforms a Haskell program into a new Haskell program. When the compiled new program is executed, it writes the ART to a file in addition to any normal I/O the original program would perform. This indirect definition of the ART through program transformation makes it hard to determine the ART of even a simple computation by hand. Because two programs are involved, the original and the transformed one, it is hard to disentangle which assumptions about the semantics of each are made. The ART also includes many special constructs, because Haskell is a large and complex language.

We first motivate our choice of programming language in Section 2. Then we give in Section 3 an informal introduction to the ART based on its origin in graph rewriting implementations of functional languages. Sections 4 and 5 define ARTs. In Section 6 we prove some simple properties of ARTs to get a better understanding and to demonstrate that our definitions allow relatively simple proofs. We prove in Section 7 that ARTs are acyclic directed graphs and in Section 9 that their structure is independent of any particular evaluation order. Section 8 establishes a property central to using ARTs for producing views of computations. Section 10 shows how ARTs can express runtime errors. We discuss related work in Section 11 and conclude in Section conclusion.

Term graph rewriting [21] provides an operational semantics for functional pro- grams that is abstract and closely related to standard term rewriting semantics. In contrast to terms, graphs allow the sharing of common subterms as it happens in real implementations of functional languages, such as the G-machine [13] or the more efficient STG-machine [20]. Term graph rewriting can correctly model the asymptotic time and space complexity of real implementations [1]. For us sharing is the key for a space efficient trace structure and closeness to the implementation also promises easy creation of a trace.

Graphs have the disadvantage that the choice of node and edge elements is usually irrelevant because we are mostly interested in the labels. The notion of graph mor- phism becomes central, because we do not want to distinguish isomorphic graphs. Isomorphism classes of graphs are inconvenient to handle. Hence we choose a stan- dard representation of graphs where a node describes the path from the root of the graph to the node. A node is a (possibly empty) string of the letters f, a and r,

We do not explicitly include reduction edges in the graph, because they are already implicitly given through our choice of nodes. A reduction edge always points from a node n to the node nr. If and only if node nr exists in the graph, there is a reduction edge from node n to node nr.

Terms contain both nodes and variables. A label term is a term that does not contain variables. A program term is a term that does not contain nodes (as defined before). A computation term is a term that contains neither variables nor nodes.

An ART is constructed by a finite number of reduction steps. The definition of ARTs could be extended to cover infinite, non-terminating computations, but then it would no longer be an inductive definition that enables simple proofs. In practice we can produce a trace only for a finite number of steps; we cannot produce some limit of an infinite number of steps.

In this section we list a number of properties of the ART that give a feeling for the structure of an ART and the constraints it meets compared to an arbitrary term graph. Such simple properties can also be of practical value: Hat comprises a tool called hat-check that performs a number of sanity checks on an ART generated by Hat. This testing tool proved very valuable for discovering faults in the Hat tracer. The checks of hat-check are relatively low-level and implementation dependent, but should be extended to include most of the properties listed here. The proof of each property takes advantage of the inductive definition of an ART and uses some related properties of matching and graph construction.

For rewriting a constant symbol our definition deviates from real implementations and the real Hat ART. There a constant symbol is only reduced once during a whole computation and the reduct is shared by all use occurrences of the constant symbol. Modelling this behaviour would add substantial complexity; in particular, because constant symbols can be recursive, it would lead to cyclic ARTs and infinite (regular) terms. Hence we leave this extension and a comparison with the simpler model defined here for future work.

Our rewriting is non-deterministic. We have not defined any reduction strategy. All properties given in this paper hold without reference to any particular reduction strategy. This generality proves that the ART can be used for different reduction strategies, in particular for optimising implementations of non-strict functional lan- guages that mix eager and lazy evaluation [11,18,10]. For a language with strict semantics we would need to disallow some reduction steps, but otherwise all def- initions and properties carry over as well. For using an ART to locate a fault it is only important that every reduction step is correct with respect to the language semantics. 1

Our programs are almost non-overlapping. For generality we do allow for non- deterministic functions; we do permit the left-hand sides of two rewrite rules for the same function symbol to have common instance. There may be different computa- tions for the same program and initial term. Hence normal rewriting and thus also ART rewriting cannot be confluent. However, rewriting on ARTs is almost sub- commutative, which means that whenever an ART has several unreduced redexes, these can be reduced in any order always yielding the same ART.

The main aim of tracing is to support locating the cause of an observed faulty behaviour. For functional programs there are three types of faulty behaviour: an incorrect result, a runtime error or non-termination. As currently defined an ART is useful for locating the cause of an incorrect result and it may also be used to consider an interrupted non-terminating computation. However, we have not yet modelled any runtime error. A runtime error may be raised by a built-in function, but for our programs the most natural source of a runtime error is pattern match failure. The left-hand sides of rewrite rules for a function symbol may not be complete, for example for a function determining the head element of a (non-empty) list.

The first author sketched a semantics for ARTs in [6]. This semantics is only for a small core language into which the full language has to be translated and it is still too complex for proving interesting properties. A formal definition of an ART- like trace for a functional-logic language has been given by extending an abstract machine to generate the trace [4]. This paper also uses a small core language and proofs are hard. Although the trace is very similar to the ART, it differs in two respects (besides small extensions for logical variables and non-determinism): First, parent edges have a different meaning; the parent edge of an expression points to the dynamic redex that forced its evaluation, not the static redex that produced it. Second, the trace only contains expressions that were needed for the computation, that is, that were matched against in a reduction or that are part of the final result. In contrast we defined the ART here so that a reduction step always adds the full right-hand side of the rewrite rule to the trace, even if parts of that will never be used. In [24] we consider a variant of our definition that allows for non- deterministically adding only a part of a right-hand side. We intend to explore this variant further.

We have motivated and presented a theory of tracing for functional programs. We have given a formal definition of the augmented redex trail (ART). The ART is a complex structure that encodes a wealth of information about a computation such that it can easily be retrieved but the ART is still compact. Nonetheless our definition is relatively simple and can be used for formal proof as numerous exam- ples demonstrate. Although the ART is a graph that takes advantage of sharing, we have given an inductive definition, thus making the powerful inductive proof method available for proofs about ARTs. Despite this inductive definition, the ART is inde- pendent of any particular evaluation order, demonstrating that we really abstract from such low-level details. It was non-trivial to prove that the ART is acyclic. Most importantly we have shown how each reduction step of a computation can easily be reconstructed from the ART. These reconstructed reductions are used in nearly all views of computations based on the ART.

Future work goes in two orthogonal directions. First, we have to determine and prove essential properties of various views based on ARTs. We have already proved the correctness of the algorithmic debugging method based on ARTs and intend to prove similar results for other views, in particular the redex trailing method for locating faults.

