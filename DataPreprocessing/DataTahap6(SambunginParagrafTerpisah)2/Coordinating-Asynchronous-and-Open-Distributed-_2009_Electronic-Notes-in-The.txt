Control-driven models isolate coordination by considering functional entities as black boxes. For example, the Abstract Behavior Type (ABT) model [4] and its language Reo [3] extend the IWIM by treating both computation and coordination components as composable ABTs. The emphasis in Reo is on the connectors, and the coordination and communication patterns which they impose on the compo- nents, but not on the components which are the entities being coordinated (coordi- natees). Moreover, specifications of timing constraints are supported in the Timed Data Stream (TDS) semantics of Reo. Some control-driven models, such as TuC- SoN with ACC [22], CoLaS [11], and ROAD [10], address the scalability issues of open distributed systems through the concept of groups.

The ARC model [26] partitions coordination into two disjoint categories, i.e., intra-role and inter-role coordination, and uses roles and coordinators, respectively, to abstract these behaviors (see Section 2). The coordinatees in the ARC model are actors [1] which are computational entities that interact by asynchronous message exchange. Coordination in ARC is achieved through exogenous message manipula- tions in space and time (constraining message destination and dispatch time) which are transparent to the coordinated actors. Our earlier paper [28] gives detailed com- parison of the ARC model with the Reo and the Reflect Russian Dolls (RRD) [18] coordination models.

The main contributions of this paper are twofold. Firstly, coordination constraints are mapped into semiring-based timing constraints and their effects on actor com- putations are studied. Linear programming analog of the shortest path problem al- lows us to give necessary and sufficient conditions for the inclusion relation between feasible regions of timing constraint sets in the real-time case. The result is fur- ther generalized to semiring-based timing constraints based on morphisms between semirings. Secondly, the ARC model and the semiring-based timing constraints are integrated through the Maude [9] specification language to model exogenous and composable coordination of open systems. We use a canonical open distributed system example, the Restaurant for Dining Philosophers [8], to illustrate such inte- gration.

The rest of this paper is organized as follows: for self-containment, Section 2 gives a brief description of the ARC model. A detailed description of the ARC model can be found in [26,28]. Section 3 discusses semiring-based timing constraints and their properties. Section 4 presents a specification of the ARC model and semiring-based timing constraints in Maude and gives an example to show how such a formal spec- ification facilitates reasoning about coordination properties. Finally, we conclude in Section 5.

In the ARC model, the representation of constraints is built upon events which correspond to message dispatches. As an illustrative example, consider a sensor system consisting of three sensors and a decision unit that aggregates data sensed from the three sensors (e.g., by certain voting mechanisms). Clearly, the event that the decision unit aggregates the data must happen after the events that raw data

As discussed in previous sections, coordination constraints can be distributed, but need to be conjunctively applied to the actors being constrained; thus for a pair of events, there can be multiple types of constraints imposed on them. For overlap- ping constraints, there often exists an implicit constraint derivable from the given constraint set that is a tighter constraint on the event pair than any of the explicitly specified ones. However, the existence of different constraint types complicates the derivation of implicit constraints. In this section, we unify precedence and real- time constraints in a semiring-based timing constraint model, utilize the all-pairs extremal paths algorithm on closed semirings to derive most stringent implicit con- straints, and develop theories (inclusions and intersections) regarding the feasible regions of semiring-based timing constraints.

Example 3.1 In the sensor system mentioned in Section 2, we assume that the corresponding events of the three sensor actors sending their data are e1, e2, and e3, respectively. To guarantee the consistency of the votes, we constrain the differences between the occurrence times of the three events t(e1), t(e2), and t(e3) to be within certain ranges using real-time constraints as discussed above. The constraint set and its corresponding constraint matrix are given in (1) 6 Due to the synchronous event-based control mechanism of the ARC model mentioned in Section 2 and detailed in Section 4, event orders will indicate the corresponding message delivery orders. Also note that although we constrain only a predefined finite set of events, the complete trace with all events can be formed by permutating unconstrained events and the inclusion relation still holds. Moreover, given that the system is stabilized, such finite set of constrained events is obtainable.

From Lemma 3.2, similar results can be given for intersections between feasible regions of timing constraint sets. An intersection of two constraint sets (not nec- essarily on the same set of events) can be used for deriving a constraint set that satisfies both sets of constraints. Such intersections are derived by forming the union of the constraint sets and applying Algorithm 1 with the corresponding constraint semirings. As the intersection of convex sets is still convex, similar proofs can be developed.

The problem can be naturally expressed using the ARC model. More specifically, under the ARC model, philosophers and forks are actors. Two types of roles, i.e., seat roles and fork roles, are introduced to shield dynamicity from coordinators: n seat roles and n fork roles are circularly arranged as in the original problem of dining philosophers. Philosopher and fork actors can join and leave corresponding roles at any time. However, any role can only hold at most one actor at any instance of time. To simplify the presentation without loosing the relevant features of the model, we assume that fork actors are static, i.e., each fork role holds a fork actor and the membership does not change.  On the other hand, the seat crl[membership-change] guarantees that each actor may play one and only one role at any time. In order for an actor to change its role membership, it leaves a role R (causing changes in the state of R), becomes an actor with another behavior (causing changes in the state of itself), and joins another role R'(causing changes in the state of R'). The leave, become, and join operations must be done atomically to avoid dangling actors.

