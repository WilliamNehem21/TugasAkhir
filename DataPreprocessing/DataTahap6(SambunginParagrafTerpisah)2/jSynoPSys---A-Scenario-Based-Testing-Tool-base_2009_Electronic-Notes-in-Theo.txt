This paper presents the jSynoPSys tool that implements the concept of Scenario-Based Testing from B machines. This consists in describing execution scenarios, expressed as regular expressions over the opera- tions of the system, coupled with intermediate system states that have to be reached when the scenario is unfolded. The tool relies on the BZ-Testing-Tools engine, originally designed to perform symbolic anima- tion and boundary test generation from B machines. The main advantage of our Scenario-Based Testing technique is that it performs a full abstraction of the operation parameter values, that are instantiated at the end, when the scenario has been completely unfolded, using constraint solving techniques.

Model-Based Testing, or black-box testing [5], consists in using a formal model, de- scribing the behavior of the system, for both computing the test cases and computing the oracle. This latter that makes it possible to establish the conformance verdict that indicates whether the system conforms, or not, to the considered model. The computation of the test cases can be performed according to different techniques that aim at covering the model, depending on its kind. For example, a model for- malized as a finite state machine (FSM) is traditionally covered by state exploration or transition coverage algorithms (such as the Chinese Postman algorithm) [17]. In the case of behavioral specifications of the system, where the operations are de- scribed using generalized substitutions, as in B [1], or through pre/postconditions,

We propose to use a constraint solver that is in charge of performing the anima- tion of the model, and is thus able to perform a thin enumeration of resulting test cases, using a native backtracking mechanism. This principle is based on the actual constraint solver of BZ-Testing-Tools (BZ-TT) [2], an animation and boundary test generation framework, for B machines, from which LTG originates. These princi- ples have been successfully experimented on several realistic case studies, such as a model of a POSIX-compliant file system [10]. This technique is implemented within a tool, named jSynoPSys, a graphical user interface written in Java, coupled with a dedicated Prolog constraints solver. This paper presents the principles and the main features of the tool.

Similarily to every smart card application, Demoney presents a notion of life cy- cle that starts with a personalization phase, during which the different parameters of the card, namely the maximal balance, the maximal debit and the PIN code values, are set using the PUT_DATA command. Then, the personalization is validated by in- voking the STORE_DATA command, that brings the card to the use phase. During this phase, the user may start a credit or debit transaction using the INIT_TRANSACTION command and validate this transaction, using COMMIT_TRANSACTION. If the user wants to credit the purse, he first has to authenticate with his PIN code, using the VERIFY_PIN command. When the user fails to authenticate three times, the card is then in the blocked state. To unblock it, the bank has to authentify, also using the VERIFY_PIN command and then change the user PIN code, using the

When a B model is animated, the user chooses which operation he wants to invoke. Depending on the current state of the system and the values of the param- eters, different resulting states can be obtained. We now describe the principle of symbolic animation.

The Prolog animation engine of BZ-Testing-Tools [8] that we use relies on a decom- position of the B machines operations into behaviors. Each behavior is defined as a predicate, representing its activation condition, and a substitution that indicates the evolution of the state variables and the instantiation of the return parameters of the operation. These behaviors are computed as the paths in the control flow graph of the considered B operation. They consist in two parts: an activation condition and a substitution.

In practice, the selection of the behaviors to be activated is done in a transparent manner and the enumeration of the possible combinations of behaviors chaining is explored using backtracking mechanisms. For animating B models, we use CLPS- BZ [8], a set-theoretical constraint solver written in SICStus Prolog that is able to handle a large subset of the data structures existing in the B machines (sets, relations, functions, integers, atoms, etc.).

jSynoPSys, like BZ-Testing-Tools, is based on the CLPS-BZ constraint solver that is able of handling data types such as integers (using the classical clp(fd) for finite domain integers), sets, relations, or functions used in the B notation. The AC- 3 arc consistency algorithm used in the solver does not make it possible to necessarily detect inconsistencies as soon as they appear in the constraint system. Thus, a labeling phase has to be performed to ensure the consistency of the constraints, i.e., the constraint system is consistent if and only if the labeling succeeds. In our approach, the labeling of a variable may happen at two steps: either when asserting that a given state has been reached, or, eventually, when the test case is instantiated, at the end of the unfolding, in order to assign values to the parameters.

In [3], the authors propose an approach for the automated scenario generation from environment models for testing of real-time reactive systems. The behavior of the system is defined as a set of events. The process relies on an attributed event grammar (AEG) that specifies possible event traces. Even if the targeted applica- tions are different, the AEG can be seen as a generalization of regular expressions that we consider.

Indirectly, the test purposes of the STG [9] tool, described as IOSTS (In- put/Output Symbolic Transition Systems) can be seen as scenarios. Indeed, the test purposes are combined with an IOSTS of the system under test, by an automata product, that restricts the possible executions of the system to those illustrating the test purpose. Such an approach has also been adapted to the B machines, in [14].

