bMSCs alone do not have a sufficient expressive power: they can only de- fine finite behaviors, without real alternatives (the only alternatives in the behaviors depicted by a bMSC are due to possible interleavings). For this reason, MSCs have been extended with higher-level constructs, namely HM- SCs [18]. Roughly speaking, HMSCs are a kind of transition systems labeled by bMSCs.

The common understanding of choices in HMSCs is that the first instance able to perform a choice selects a behavior. The following instances reaching the same occurrence of this choice have to conform to the chosen scenario. So, the MSC semantics assumes an implicit agreement between instances (e.g., one instance decides and communicates its decision to all other instances, while

Notice that the local choice property can be checked by considering maxi- mal acyclic paths only. It is therefore decidable on finite HMSCs. Section 5, shows how a consensus algorithm can be inserted automatically to transform a non-local HMSC into a local one.

of M1 and M2 will create a symmetry, which can be easily detected. In such case, the two scenarios are incompatible, at least if one considers a match- ing between events symbolizing actions a and b in both operands. For more considerations about amalgamated sum properties, consult [4].

We propose a solution based on a partially synchronized product of HMSCs inspired by the fibered product of asynchronous transition systems proposed in [3]. The fibered product of HMSCs is twofold: First, transitions of the two support automata are synchronized partially. Then, the amalgamated sums of the bMSCs attached to the transitions being synchronized are computed to create new bMSCs. As for the amalgamated sum of section 3, the formal definition of the fibered product of HMSCs relies on a notion of morphism.

The partially synchronized product of labeled transition systems was first introduced by Arnold [1]. It is parameterized by a set of synchronization vectors, which is used to define which pairs of labels must be synchronized. Here, a set of pairs of transitions (instead of labels) is used for this purpose.

Let us illustrate our HMSC product on a concrete application. As mentioned in Section 2, some HMSCs can contain non-local choices. During implementa- tion, this abstraction is error prone. To implement a system described by such a HMSC, an experimented programmer would certainly add some communi- cation messages to the HMSC, so that any non-local choice would be turned

The approach proposed in this section is to integrate automatically a con- sensus protocol described with HMSC in a non-local description of a system. This integration is done using the fibered product between the non-local choice HMSC and another HMSC describing the consensus protocol. An interesting property of this HMSC transformation is that it can be used for an arbitrary number of instances participating to a non-local choice.

This transformation raises two important issues. The first one is the cre- ation of an election protocol for an arbitrary number of instances. Indeed, to make such an approach usable, one cannot ask a user to design n scenarios when n instances participate in a non-local choice. Fortunately, building such scenarios can be accomplished as an application of the amalgamated sum of bMSCs, and can be completely automated. The second issue is the insertion of the protocols right after choice nodes. This can be accomplished using the fibered product of HMSCs described in section 4. For this application, the interface HMSC is simple and can be computed automatically.

As mentioned before, we have chosen to add a supervisor with a first arrived, first served policy to ensure locality of choices. The main idea is to insert a preamble Ci on each branch Bi of a non-local choice. Each preamble is a protocol in which the supervisor sends messages to all instances that are participating to the non-local choice. The first instance i that answers receives

This paper has proposed a formal notion of merge for bMSCs and HMSCs. This definition is based on the notions of synchronous product for transition systems and amalgamated sum. The use of this formalism on a concrete example shows the applicability of the method.

An advantage of this composition method is that it allows the inductive definition of merging, and hence provides composition schemes for arbitrary number of instances. This product also defines a rough notion of coherence : if the HMSC obtained after composition is well formed, then the two operands are coherent on the set of events identified through the morphisms. If not, the fusion of both views are inconsistent.

libraries of formally defined patterns, than can be reused after instantiation of a limited number of parameters. Composition can also be used to create automatically concrete scenarios involving numerous instances that cannot be designed by hand from generic scenarios. These concrete scenarios could then be used for deployment, test and simulation purposes.

