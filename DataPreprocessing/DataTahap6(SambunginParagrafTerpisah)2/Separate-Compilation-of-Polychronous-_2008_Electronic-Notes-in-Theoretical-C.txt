To gain from the flexibility and ergonomy that separate compilation services would offer, we propose a simple analysis and code generation technique that ad- dresses this limitation. Our approach consists in weakening the global safety objec- tive usually targeted in related frameworks: isochrony. Instead, we consider a more liberal one of weak isochrony recently proposed in [14].

Endochrony guarantees that the system responds to events incoming from an asynchronous environment by locally and deterministically choosing which of them needs to be synchronized at all times. Endochrony ensures the insensitivity of local computations and communications to global network latency. But, it is unfortu- nately not compositional.

A different approach is proposed by Girault [3] in the context of the Lustre and Esterel languages. It consists of the replication of the automaton obtained from the synchronous module and then on the optimized elimination of replicated transitions, replaced by inter-partition communications. Of course, distributed code generation is based on the objective of globally preserving the formal property secured locally: endochrony.

Our approach consists in maintaining a less costly yet compositional objective of weak-isochrony while considering the composition of endochronous modules. This appears to be a much more cost-effcient approach to code generation. Our con- tribution consists in an implementation of this methodology that efficiently reuses most of Polychronys compilation tool-chain to propose a simple synthesis scheme ensuring the aimed compilation objectives.

The article presents existing and contributed compilation techniques in the manner of a tutorial and through a series of illustrative examples. It does not address or prove the related formal aspects. Instead, it merely relies on existing analysis algorithms (and proofs) implemented in Polychrony.

The article starts, Section 2, as a tutorial on the Signal data-flow specification language and on its analysis of synchronization and scheduling relations. Section 3 continues this tutorial with a presentation of the code generation techniques cur- rently implemented in Polychrony, the toolset supporting the Signal language. Our contribution, built upon these techniques, is presented in Section 4.

The data-flow synchronous formalism Signal supports a representation of the control-flow and data-flow graphs of multi-clocked specifications for the purpose of analysis and transformation. In this structure, a clock c denotes a set of instants and defines a discrete sample of time. It is used as the condition upon which (or the time at which) a data-flow relation is executed.

The most interesting part is the transition function. It translates the structure of the hierarchy and of the serialized scheduling graph in C code. It also makes a few optimizations along the way. For instance, r has disappeared from the generated code. Since the value stored in y from one iteration to another is the same as that of r, it is used in place of it for that purpose.

Also notice that the return code is true, line 11, when the transition function finalizes, but false if it fails to get the signal y from its input stream, line 4. This is fine for simulation code, as we expect the simulation to end when the input stream sample reaches the end. Embedded code does, of course, operate differently. It either waits for y or suspends execution of the transition function until it arrives.

The buffer process satisfies the property of endochrony. Literally, this means that the buffer is locally timed. In the transition function of the buffer, this is easy to notice by observing that, at all times, the function synchronizes on either receiving y from its environment or sending x to its environment. Hence, the activity of the transition function is locally paced by the instants at which the signals x and y are present.

For instance, the composition of the producer and of the consumer is weakly endochronous. The presence of all signals in this composition is locally determined from the value or presence of signals in either the producer or the consumer (it is deterministic) and the very order of execution: producer first, consumer first, or both, does not matter (they satisfy the diamond property). This is the very definition of weak endochrony in [14].

In the controlled main program, variables prefixed with pre_ register the values of signal (of corresponding suffix) until the next cycle. The generated r variables translate the synchronization obligation implied by the reported clock constraint as r = ra && rb. Functions named {r|w}_main_x read and write the signal x.

A necessary condition is that the graph of p | q must be acyclic and a sufficient condition is that the p | q should not incur a reaction to the absence of a signal i.e. that all clocks in the graph of p | q should have a disjunctive form.

The generated code is otherwise unchanged. We obtain a concurrent code gener- ation scheme that modularly and compositionally supports separate compilation. It efficiently uses existing report functionalities of the present implementation of Poly- chrony to effectively support the synthesis of a controller that is able to assemble endochronous processes so as to maintain a global objective of weak isochrony.

We write T (s) for the chain of tags of a signal s and min s and max s for its minimal and maximal tag. We write V(b) for the domain of a behavior b (a set of signal names). The restriction of a behavior b to X is noted b|X (i.e. s.t. V(b|X )=

X). Its complementary b/X (i.e. s.t. V(b/X )= V(b) \ X) satisfies b = b|X  b/X . We overload the use of T and V to talk about the tags of a behavior b and the set of signal names of a process p.

