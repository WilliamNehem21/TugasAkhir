LSCs allow us to distinguish between possible and mandatory behaviour, and express forbidden behaviour also called anti-scenarios. Since they were first introduced in [5] several aspects have been added including time, symbolic instances and classes. We do not consider these special features here but focus on basic LSCs with assignments, conditions, subcharts and forbidden elements. A detailed description of LSCs and their (partial) implementation in a tool called the Play Engine can be found in [9].

There are several ways of achieving synchronisation in LSCs. The begin- ning of a prechart and the main chart are default synchronisation points. All instances enter the prechart simultaneously, while the main chart can be en- tered only after all the instances have successfully completed their activities in the prechart. In the same way, the beginning and the end of a subchart are synchronisation points for all participating instances. As a result, a subchart can be entered only when all the instances that participate in it arrive at the subchart initial location and can be exited only when all those instances have completed their activities (or if it contains a condition that evaluates to false).

In general, there is no partial order between the events and the condition in the chart body. Therefore, as soon as an instance reaches a condition, if this evaluates to true, the instance can progress beyond the condition. LSCs allow to synchronise the progress of one or several objects with the evaluation of a condition, that is, none of the synchronised instances may progress beyond the condition until all of them reach it and it is actually evaluated.

LSCs allow the definition of anti-scenarios corresponding to scenarios that the system should not be allowed to execute. This is achieved through uni- versal charts where the forbidden scenario is specified in the prechart and the main chart consists only of the hot condition FALSE. If the forbidden scenario is successfully executed, the main chart is activated and the hot condition evaluated. Since this condition is always guaranteed to fail, it causes a viola- tion.

A message is a communication between two instances that conveys infor- mation with the expectation that action will ensue. A message will cause an operation to be invoked, a signal to be raised, or an instance to be created or destroyed. Messages are shown as a horizontal arrow from the lifeline of one instance to the lifeline of another instance. A message specifies not only the kind of communication between instances, but also the sender and receiver event occurrences associated to it.

tween the behaviours of the operands, i.e. the ordering of event occurrences within each of the operands are maintained whereas event occurrences on different lifelines from different operands may come in any order, and event occurrences on the same lifeline from different operands are ordered such that an event occurrence of the first operand comes before that of the second operand.

It should be noticed that the above description taken literally from [14] is incomplete and ambiguous. For example, it is not clear whether it should be possible to have several guard expressions in an alt operator evaluating to true, and in such a case how to determine or enforce a particular operand to be executed. Further, using a neg operator it is not clear when a trace becomes invalid (negative), though one could expect that a prefix of the negative trace is still valid and therefore positive.

In the previous versions of UML, it was not possible to express that, at any time, a specific scenario should not occur. However, as mentioned at the beginning of this section, a new operator called neg has been introduced for this purpose in UML 2.0. Therefore, to model what is called an anti-scenario in LSCs, we simply place it inside an interaction fragment within the scope of a neg.

The diagram shows an interaction between a user and three system in- stances. The interaction is triggered by the user sending message m1 to in- stance i. The intended meaning of the diagram is that after m1 and m2 have been sent the system must continue as described in the assert fragment. Whilst in the assert fragment, the user is not allowed to resend message m1 at any time (this is indicated by the neg fragment containing message m1 within a par fragment, whereby the intended execution is described in the first operand. Semantically it means that m1 is not allowed to occur inter- leaved with whatever happens in the first operand). After messages m3 and m4 are sent 4 an alt fragment is entered, where the condition is given by k.n>0 (where n is for instance an attribute of instance k). In the second operand of alt, Ready is a state invariant over instance i. Recall that if a state invariant is evaluated to false the whole trace is invalid. The valid execution finishes with instance i sending message m9 to the user.

It should be noted that message expressions in OCL 2.0 can only be used in a postcondition of an operation/method (say o) and have the underlying meaning that the message must have been sent during the execution of o. Our usage within an AE template is not incompatible with this intention because messages are always sent between instances while executing certain opera- tions. Further, the OCL 2.0 specification document does not include a formal semantics for message expressions. A recent paper describes an extension of the usual semantics given to OCL expressions for message expressions [6]. Our approach is in accordance with the semantics of [6].

For liveness constraints of case 2 we mainly need to refer to different lo- cations in the lifeline of one instance, which is the contextual instance of the constraint. Several situations are possible depending on what either of the locations are: message send event, message receive event, condition, assign- ment, state invariant, entering or exiting an interaction fragment. Notice that state invariants are also considered interaction fragments (see [14] page 433) but they should be treated differently as they only concern one instance.

Condition (d) basically states that the messages m1 and m2 constitute a precondition for the assert fragment. Both messages have to be sent before any instance is allowed to progress and reach the assert fragment or any lo- cation thereafter. We can add here the constraint that the instances have to synchronise when entering the assert fragment. Condition (d) is described by the following constraint

Further, we can now describe also that an assert fragment must finish, i.e., after all instances are at the beginning of the interaction fragment, eventually all instances must reach the end of the (same) fragment and synchronise. This refers to condition (c).

Finally, in case (e) we are imposing that m8 has to be received before instance i enters state Ready. The constraint is global, because message m8 is exchanged between instances k and j whilst the state invariant refers to instance i. Without this constraint, instance i is allowed to enter state Ready before m8 was sent and received. There are two possible ways to deal with this case. Either we use OCL as described below or we enclose the messages and the state invariant within a strict combined fragment.

