In this section we briefly present the Save component modeling language [8], which will be used in the case study of this paper. The language is part of a larger frame- work, called SaveCCM, for component-based design of real-time and embedded system [1]. The SaveCCM language consists of a graphical syntax and an associ- ated formal semantics. Due to space limitation, the presentation in this section is restricted to a short informal overview of SaveCCM. For a complete description of the language we refer the reader to [8].

The execution of a PFSM starts in the special control state start. At a given state, an outgoing transition may be executed only if its associated guard evaluates to true; in this case we say that the transition is enabled. In case more than one outgoing transitions are enabled, one can be executed non-deterministically. A filled circle denotes the start control state and a semi-filled circle denotes the exit control

In the run-to-completion (RTC) execution model, the component is executing in indivisible steps, without interruption from any concurrent activity. The key ad- vantage of the RTC semantics is simplicity and guaranteed absence of deadlocks. Another advantage is that it might prune away unnecessary interleavings, thus speeding up formal verification and bringing the model closer to implementation. The pattern is commonly used in high-level behavioral modeling languages like Stat- echarts and its variants [12,17]. In Statecharts, the events are handled in an RTC manner, along possibly compound transitions (i.e., paths of adjacent arrows).

Execution history is a core feature of behavior modeling techniques [2,12]. The history mechanism of a behavior remembers which state was last visited during execution, before exiting. This state can then be re-entered next time the execution re-starts. In the hierarchical state-machine modeling of Statecharts [12], an inner state may be exited and re-entered directly, by using the history mechanism. A similar approach is adopted in CHARON, a formal modeling framework for hybrid systems [2].

The pattern is implemented as a TA, by using an integer variable H, which is updated along each edge connecting any states different from the start, and exit states, with the corresponding location identifier. Special edges connect the start state to each of the states of interest, while appropriately testing the variable H. In addition, exit edges connect each state of interest to the exit control state. Variable H can be re-initialized appropriately when entering a specified final location.

For embedded and real-time systems, it is often interesting to specify and analyze the best or worst execution time of components. The variation in execution time also gives rise to, e.g., non-deterministic timing, jitter, and varying end-to-end timing, which represent phenomena that are important to analyze (and master) at design time. In the following, we introduce a pattern for specifying the best and worst execution times of components.

Pattern description.  In this pattern, we assume that the total accumulated time of executing a component is within an interval where the lower and upper bounds are the shortest and longest possible execution times, respectively. Hence, the component will produce output (data and trigger) at some time instance, in the interval.

We also assume that the component is annotated with an interval specifying the lower and upper bound on the execution time. To implement the pattern, we use a dedicated clock, say exec, which is used to measure the time since the component was triggered. The clock is reset on the edge outgoing from location start. We further introduce a location, say delay, and an edge from location delay to the exit location. Location delay is annotated with an invariant over exec, corresponding to the upper bound of the execution interval, whereas the exit edge is decorated with a guard corresponding to the lower execution bound.

Drilling and testing are the most critical tool positions, as the overall purpose of the production cell is the verified drilling of products that flow through the cell. All slots of the rotary disc may be occupied at the same time, and products are processed in parallel. When a cycle completes, meaning that all positions complete their functionality, the rotary disc rotates 90 degrees thus positioning the products for the next phase of processing. As the rotation is initiated by signals from tools that are not time deterministic, there is no fixed period between rotation of the slots.

the tester is a sensor sTesterDown, that measures the hole within 2 time units since the beginning of the test process. When triggered the component checks the status of the slot at position 2. If empty, it does nothing, otherwise it measures the hole drilled in the product, and updates the status according to its verdict.

The TestTool works similarly to the drill, moving down by command from an actuator until a sensor is activated, and then moving up again by command from a different actuator until the corresponding sensor is activated. Also Disc is modeled with two states, wait and turning. The transition from wait to turning is initiated by the actuator aRotate, clears the sensor value sCompleted, and resets a clock ensuring the transition back to wait within TURN TIME time units, when the sensor value sCompleted is also set.

The Statemate toolkit [14] is an early working environment for the development of complex reactive systems. Modularity of the system development is provided in terms of different views, such as structure, functionality, and behavior. Our ap- proach for behavior specification of components (modules in Statemate) is similar to the Statecharts [13], the behavioral language of Statemate. Though not hierarchical, our FSM notation for component behaviors (see Section 3), combined with the pat- terns proposed in this paper, is similar to the Statechart features run-to-completion and execution history.

