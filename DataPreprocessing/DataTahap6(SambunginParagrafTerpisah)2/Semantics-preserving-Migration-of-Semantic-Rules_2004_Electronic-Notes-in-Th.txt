Several tools for source-to-source transformation are based on top down parsers. This restricts the user to use grammars without left recursion. Removing left recursion of a given grammar often makes it unreadable, preventing a user from concentrating on the original grammar. Additionally, the question arises, whether the tool implements the semantics of the original language, if it is implemented based on a different grammar than in the original language definition. Moreover, existing implementations of semantics for the original grammar cannot be reused directly.

The paper contributes to the field of automatic migration of software (here semantic rules) induced by a grammar change. It revises removal of left recursion in the context of grammar adaptations and demonstrates, that while removing left recursion at the same time the semantic rules can be migrated automatically. Thus, a programmer can continue to use semantic rules on a left recursive grammar. The problem is explained and justified.

Need for left recursion removal Removal of left recursion in grammars is an adaptation of the grammar to fit technical demands. Many syntactical structures are expressed naturally using recursion, often both, left and right recursion. However, there are tools like ANTLR, JavaCC, TXL, Prolog-based tools, dealing somehow with recursive descent parser generation, for the ease of combination with semantics [21], which would fall into infinite recursion. Removal of left recursion is known in compiler construction for over 40 years, and mostly considered wrt. to context-free grammars or to development of compilers. However, necessity of left recursion removal arises not only in compiler construction, but also during language development, prototyping, and in software maintenance, especially for adaptations in already used and tested grammars.

Technical challenge The first problem is that removal of left recursion leads to a badly readable grammar. More elaborate semantic rules are neces- sary. However, the user wants to work on the most comprehensible grammar, or even the reference grammar, if possible. Often the grammar is rewritten using EBNF, where left recursion turns into iteration, which might result in a problem with semantics in loops. Next, a language definition consists of syntax and semantics definitions. If the syntax is modified due to technical demands, this leads to changed semantics. Is the meaning of a language con- struct unchanged? Finally, if there are semantic rules for the left recursive grammar already (e.g. given as logic language), how are they affected by the change? Can they be reused or have all to be discarded?

Section 2 recalls the notions of attribute grammars. Section 3 uses the small example of arithmetic expressions to explain the basic idea for the trans- formation of semantic rules in Section 4. Section 5 gives a justification. Treat- ment of other kinds of attribute grammars is disussed in Section 6. Section 7 reports on practical experience so far. Section 8 points to some related work, before the paper is summarised in Section 9.

This section recalls the definition of attribute grammars (AG). The following formal definition is similar to [1]. Semantic conditions, which can restrict the language generated by the context-free grammar are omitted without loss of generality of our approach. The semantics is as given in [1]. For the origin of attribute grammars, the reader is referred to Irons [6], and Knuth [9].

The section gives the algorithm for left recursion removal for S-attribute gram- mars. The approach to migrate semantic rules guarantees that the root of the transformed syntax tree contains the same attribute values as the root in the original tree. A justification will be given in the next section.

Prototype The given approach has been implemented as proof-of-concept pro- totype for multi-pass attribute grammar. I.e. it demonstrates the algorithm for simple examples, but is not ready for practical applications. For the im- plementation TXL [2] was chosen. For the experiments, we used grammars as

We discussed that grammars are not only changed to implement compilers. The need of an engineering discipline for grammarware is emphasised in [8]. In [15] the authors propose an approach to the construction of grammars for existing languages. The main characteristic of the approach is that the gram- mars are not constructed from scratch but they are rather recovered by ex- tracting them from language references, compilers, and other artifacts. They provide a structured process to recover grammars including the automated transformation of raw extracted grammars and the derivation of parsers. Ex- amples for tool support for grammar engineering are Grammar Deployment Kit (GDK) [7] and F ramework for S DF T ransformation (FST) [16]. GDK provides support in the process to turn a grammar specification into a work- ing parser. FST supports the adaptation of grammars based on the syntax definition formalism SDF, where, for example, EBNF patterns are removed (YACCification) or introduced (deYACCification). Transformations by Cordy et al. to enable agile parsing based on problem-specific grammars [3,4] are ex- amples for grammar engineering as well as the transformations for deriving an abstract from a concrete syntax by Wile [23].

Related to this paper is a former paper on automatic migration of trans- formation rules after a grammar extension has been made [17]. The approach can be used to reuse transformation rules after a grammar extension, so that they do not break with code for the new grammar. It was shown on the prob- lem, how to make rewrite rules able to store layout information in the rewrite pattern. On the level for the rewriter, that information was invisible, thus the approach helped to reduce complexity of rewrite patterns for users.

Summary The paper contributes to the work on grammar adaptations and concentrates on semantics rules associated to grammar productions. The ap- proach attempts to reuse existing semantic rules for the new grammar. More- over, it offers the programmer of a program transformation the opportunity to specify semantic rules on a grammar closer to a grammar specification, while grammar and semantic rules can be adapted to meet technical demands, here left recursion removal. Hence, we provide the rewriter with a simpler gram- mar than necessary for the tool. The necessary transformation steps for the grammar are given, as well as a justification of the approach.

A disadvantage of the approach is the doubling of attribute numbers, and the introduction of additional copy rules. Though the added complexity is hidden, the problem might be the time overhead it adds to the process of tool construction. Semantic rules using the original grammar have to be adapted each time a tool is built from rules and grammar. In the case of interpretative used environments, e.g. in a Prolog setting, this may become annoying for larger grammars.

