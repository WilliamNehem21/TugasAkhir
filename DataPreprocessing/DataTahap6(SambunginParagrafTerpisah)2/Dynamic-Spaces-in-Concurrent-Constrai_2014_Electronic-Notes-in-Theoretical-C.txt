[6] proposed Linear Concurrent Constraint Programming (lcc), inspired on linear logic [8] and linear logic programming [11], allowing the use of linear constraints, that is, constraints that once used by an agent are removed from the global store. On the other hand, Saraswat et al. proposed Timed CCP (tcc) [24], which is an extension of CCP with time modalities. More recently, Knight et al. [12] proposed another CCP-based language with spatial (sccp) and epistemic (eccp) modalities (see in [20] a survey of the state of the art in CCP).

systems to represent, for instance, agents that can update/change the content of the distributed spaces. Also, by changing the underlying subexponential structure, different modalities can be put in the hands of the modelers and programmers. And most importantly, now it is possible to use all the linear logic meta-theory for reasoning about such systems.

There are at least two ways of proceeding in this direction. One aspect that could be explored is that of proposing richer subexponential signatures in SELLA, hence having different computational behaviors. For example, it seems that if the initial signature is the [0, 1] interval, then the correspondent calculus has a probabilistic flavor. Hence one could think of more elaborated topological spaces as signatures, like Hilbert spaces for example, achieving in the other side interesting concurrent systems.

The key difference to standard presentations of linear logic is that while linear logic has only seven logically distinct prefixes of bangs and question-marks, SELL allows for an unbounded number of such prefixes, e.g., !i, or !i?j. As showed in [18], agents can have an internal structure, i.e., its local store can be divided into locations. For that, we shall identify such locations as different subexponential indices in the signature as we did in [18]. Unlike sccp [12], we shall allow unbounded and linear locations to specify spaces where information can be updated;

Similar to most processes calculi, the language of processes of dccp features a small number of constructors and it is powerful enough to express interesting behaviors of concurrent and distributed systems. Common to all languages based on CCP, we include constructs to add (tell) new information to the store, to hide (local) variables and to compose processes in parallel. Following the developments of lcc [6,10] and utcc [21], we allow the quantification of free variables in ask processes. Furthermore, as in lcc, ask agents consume information when evolving due to the linear nature of the store. Here we notice that, by changing the subexponential structure, we can specify that some stores are persistent while some others are linear. Finally, following the developments of spatial CCP (sccp) [12], we allow processes to be confined to a given space (see [P ]s below). However, unlike sccp, in dccp it is possible to create and communicate shared spaces of communication between agents. Later we show that this ability is not ad hoc since we can give it a declarative meaning thanks to the connectives d and A in SELLA.

Restriction (i) prevents agents to execute processes in the space of other agents. Restriction (2) disallows agents able to read from the store of another agent. More- over, as we shall see, processes of the form tell([c]g(l)) in the agent f will be inter- preted as an asynchronous communication from f to g.

To explain the rule RS, consider the process [tell(c)]l. What we observe from this process is that the constraint [c]l is added to the store. This means that the output of tell(c) is confined to the space l. Now consider the process [ask c then Q]l. In this case, to decide if Q must be executed, we need to infer whether c can be deduced from the information in location l. Hence, the premise of Rule R considers only the store `fi(l) di. Moreover, the new store in that location, i.e., dj is again placed at location l as shown in the conclusion of the rule.

