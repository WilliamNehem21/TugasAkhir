allocation techniques and ILP instruction scheduling. If a classical register al- location is done early, the introduced false dependences inhibit a good further ILP extraction. However, this conclusion does not prevent any compiler from performing effectively an early register allocation, but with the condition that the used allocator should be sensitive to the scheduler as done in [12,11,8].

In some cases, we must introduce spill code and hence we change the problem (the input DDG). Also, a combined pass of scheduling with register allocation presents an important drawback if not enough registers are available. During scheduling, we may need to insert load-store operations if no enough free registers exist. We cannot guarantee the existence of a valid issue time for these introduced memory access in an already scheduled code; resource or data dependence constraints may prevent from finding a valid issue slot inside an already scheduled code. This fact forces to iteratively apply scheduling followed by spilling until reaching a solution.

is provided in Section 4. Our large range of experiments show that our initial heuristics [14] are nearly optimal in Section 5. Before concluding, we make a discussion in Section 6 to argument why the RS concept is a better way for handling register constraints prior to ILP scheduling.

We prove that ReduceRS problem reduces from the problem of scheduling under register constraints. Let us start by defining the latter problem. For the sake of clarity of this proof, we assume that the considered register type t is implicit (we do not include t in our notations inside this proof).

The intLP system tries to build a coloring of the interference graph with exactly Rt colors (the maximal number of available registers). If no solution can be found with Rt registers, then solve another intLP after decrementing Rt (until to 1). If no final solution can be found when reaching one avail- able register, then the register saturation cannot be reduced and spilling is unavoidable. The variables xi t are computed using following constraints.

We did an extensive set of experiments on some scientific codes extracted from SpecFP, whetstone, livermore and linpack We used CPLEX to solve our intLP programs. Since all the problems of RS computation and reduction are NP- hard, reaching the optimal solutions were very time consuming (from many seconds to many days). The experimented DAGs are simply some loop bodies (excluding branches). Detailed numerical results and plots are shown in [15]. Basically, all our heuristics presented in [14] are nearly optimal.

Clearly, our RS reduction algorithm is very efficient : it, in most of times, optimally reduces RS with optimal ILP loss. Sub-optimal ILP loss is, in most of times, accompanied with optimal RS reduction, while sub-optimal RS reduction is mostly accompanied with super-optimal ILP loss. We get both sub-optimal ILP loss and sub-optimal RS reducing in less than 1% of the cases.

Our DAG and processor model admit explicit reading from and writing to registers. Thus, our method is more generic than the existing techniques, and can be applied for superscalar, VLIW and EPIC codes. For the two later cases, a special care must be taken when reducing RS : we must prohibit non-positive circuits in the resulted DAGs.

Computing the register saturation of a DAG is NP-complete. An intLP exact formulation is presented. Our formal mathematical modeling and the- oretical study in [14] enables us to give nearly optimal heuristics. In the presence of branches, global RS of an acyclic CFG is brought back to RS in DAGs (basic blocs) by inserting entry and exit values with the corresponding flow arcs (see [15]).

