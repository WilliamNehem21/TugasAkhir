The development of a system can start with the creation of a specification. Following this viewpoint, we claim that often a specification can be constructed from the combination of specifications which can be seen as composition. Event-B is a formal method that allows modelling and refinement of systems. The combination, reuse and validation of component specifications are not currently supported in Event-B. We extend the Event-B formalism using shared event composition as an option for developing (distributed) systems. Refinement is used in the development of specifications using composed machines and we prove that properties and proof obligations of specifications can be reused to ensure valid composed specifications. The main contributions of this work are the Event-B extension to support shared event composition and refinement including the proof obligations for a composed machine.

Systems can often be seen as a combination and interaction of several sub- specifications (hereafter called sub-components) where each sub-component has its own functionality aspect. This view introduces modularity in the system: differ- ent sub-components represent a particular functionality and changes in the sub- components are accommodated more gracefully [12] in the system specification. We use composition to structure specifications through the interaction of sub- components seen as independent modules. This use of composition is not new in other formal notations: examples are [22,13,15]. Here we express how we can use (and reuse) composition for building specifications in Event-B [2] through sub- components (modules) interaction, benefiting from their properties and proof obli- gations (POs). The interesting part of composition involves the interaction of sub- components which usually occurs by shared state [4], shared operations [7] ora com- bination of both (for example, fusion composition [15]). Although sub-components have states, we mainly focus on their (visible) events similar to CSP [11,14]: we fol- low a shared event composition approach where events are synchronised in parallel. This document is structured as follows: Sect. 2 briefly describes Event-B. Sec- tion 3 introduces the notion and properties for shared event approach. Composed machine, POs and the monotonicity property are introduced in Sect. 4. Related

The semantics of the parallel composition of machines M and N corresponds to the set of failure-divergence for each individual machine in parallel. From the correspondence between action systems and Event-B, machines M and N can be refined independently which is one of the most important and powerful properties that shared event composition in Event-B inherits from CSP. The monotonicity property for the shared event composition in Event-B is proved by means of proof obligation in Sect. 4.4. When sub-components are composed it is desirable to define properties that relate the individual sub-components allowing interactions. These properties are expressed by adding composition invariants ICM (s, c, v1,..., vm) to the composed machine constraining the variables of all machines being composed.

POs play an important role in Event-B developments. POs are generated to verify the properties of a model. For simplicity we define POs in terms of a composition of two machines M1 and M2 that refine machine M0, but the rules generalise easily to the composition of n machines. Furthermore context elements in the formulas (s, c, A(s, c)) are not considered. The POs defined for standard machines (invariant preservation, well-definedness, refinement, etc) [2] are defined for composed ma- chines. We simplify the composed machines POs by assuming that the POs of the individual machines hold. We define the additional POs necessary to ensure that the composed machine satisfies all the standard POs. We consider that the POs of the M 0, M1 and M2 hold. The respective composition POs are described as follows.

Well-definedness for expressions (guards, actions, invariants, etc) needs to be verified. These are verified by means of POs in Event-B [3]. For composed machines, well-definedness POs are only generated for ICM (v0, v1, v2). Other expressions are verified in the individual machines.

We also need to prove the monotonicity for single (non-composed) events that appear at both levels of abstraction. We shall prove it using machines M 1 and CM 2. In this case, the gluing invariant described in (12) does not use neither the variables (vN ) neither the invariants(IN ) neither events (evtN1) from N 1. Therefore it can be simplified and rewritten as:

New events can be added during refinement, respecting the refinement POs. The refinement PO proof for new events is similar to the previous cases but applied to a single event refined by a composed event. Due to the lack of space we do not present it here.

