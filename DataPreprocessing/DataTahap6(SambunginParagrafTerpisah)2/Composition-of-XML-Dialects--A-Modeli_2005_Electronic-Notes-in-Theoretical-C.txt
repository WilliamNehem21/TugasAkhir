This paper investigates how software composition and transformation can be applied to domain specific languages used today in modeling and simulation of physical systems. More specifically, we address the composition and transformation of the Modelica language. The composition targets the ModelicaXML dialect which is the XML representation of the Modelica language. By extending the COMPOST concrete composition layer with a component model for Modelica, we provide composition and transformation of Modelica. The design of our COMPOST extension is presented togheter with examples of composition programs for Modelica.

Modelica [10] [4] [5] is an object-oriented modeling language used for modeling of multi-domain (i.e. mechanical, electrical, electronic, hydraulic, etc) complex physical systems. Modeling with Modelica has a component-oriented approach where components can be connected togheter to form a complex system. To have access to the structure of a model, ModelicaXML [17] has been developed as an XML representation (serialization) of Modelica language.

The use of XML technology for software engineering purposes is highly present in the literature today. The SmartTools system [6] uses XML tech- nologies to automatically generate programming environments specially tai- lored to a specific XML dialect that represents the abstract syntax of some desired language. The use of Abstract Syntax Trees represented as XML for aspect-oriented programming and component weaving is presented in [18]. The OpenModelica [11] project investigates some transformations on Model- ica code like meta-programming [1]. The bases of uniform composition for XML, XHTML dialect and the Java language were developed in the Euro- pean project Easycomp [9]. However, the possibilities of this framework can be further extended and tested by supporting composition for an advanced domain specific language like Modelica.

The paper is structured as follows. The next section introduces Modelica, ModelicaXML, and COMPOST. Section 3 presents our COMPOST extension and its usage through various examples of composition and transformation programs for Modelica. Conclusion and future work can be found in Section

The translation of the Modelica into ModelicaXML is straightforward. The abstract syntax tree (AST) of the Modelica code is serialized as XML using the ModelicaXML format. 2 ModelicaXML is validated using modelica.dtd Doc- ument Type Definition (DTD). Using the XML representation for Modelica, generation of documentation, translation to/from other modeling languages can be simplified.

nents, i.e., templates containing declared and implicit hooks, are read from file. Then, a composition program in Java applies composition operations to the templates, and transforms them towards their final form. (The transfor- mations rely on standard program transformation techniques.) After all hooks have been filled, the components can be pretty-printed to textual form in a file again. They should no longer contain declared hooks so that they can be compiled to binary form.

Transformation Engine Layer The most basic layer encapsulates knowl- edge about the contents of the components, i.e., about the concrete lan- guage of the component. Fragment-based component composition need a transformation engine that transforms the representation of components [2]. For such transformation engines, COMPOST reuses external tools, such as the Java refactoring engine RECODER [14]. This transforma- tion engine layer contains adapters between COMPOST and the external

Concrete Composition Layer On top of the pure fragment layer, this layer adds information for a concrete component model, e.g., Java frag- ment components, or ModelicaXML fragment components. Concrete composition constraints are incorporated that describe valid composi- tions, which can refer to the contents of the components. For instance, a constraint could be defined that disallows to encapsulating a Java method component into another Java method component.

For COMPOST applications, UNICOMP hides underlying concrete infor- mation about the component model to a large extent. An application uses COMPOST in a similar way as a component framework with an Abstract Factory [12]. When a component is created, its concrete type is given to the COMPOST factory. However, after creation, the application only uses the UNICOMP generic interfaces. Hence, generic applications can be developed that work for different component models, but use generic composition op- erations. Already on the Abstract Composition Level, the following uniform operations for fragment components are available:

Uniform inheritance. On the abstract composition layer COMPOST de- fines several inheritance operators that can be employed to share compo- nents, be it Java, or XML-based components. Inheritance is explained as a copy-and-extend operation, and both copy and extend operations are available in the most abstract layer.

The great advantage of the layer structure is that new component models, e.g., for XML languages, can be added easily as we show in this paper. In fact, COMPOST is built for extension: adding a new component model is easy, it consists of adding appropriate classes in the concrete composition levels, subclassing from the abstract composition level as we show in Section 3.

Secondly, COMPOST can be used to prepare components such that they fit into component models of stage 2 and 3. For instance, COMPOST connectors can prepare a Java class for use in CORBA context [3]. They can also be used to insert event-emitting code, to prepare a class for Aspect-Oriented Programming.

In our case the boxes (templates) are mapped to their specific element types in the ModelicaXML representation. For example, the ModelicaClass box is mapped to a <define ident="ClassName">..</define> element. The ModelicaClass box can contain several ModelicaElement boxes and can con- tain itself in the case that one Modelica class is declared inside another class. The boxes that inherit from ModelicaContainer represents the usual con-

This subsection gives concrete examples on the usages of our framework. The examples are written in Java, but they could easily be performed using a tool that has visual abstractions for the composition operators. For presenta- tion issues only the Modelica code is given in the examples below and their corresponding ModelicaXML representation is presented in Section 5.

When designing libraries one would like to split specific classes into a more general part and a more specific part. As an example, one could split the class defined below into two classes that inherits from each other, one more generic and one more specific in order to exploit reuse. Also if one wants to add a third class, e.g. RectangularBody, to the created hierarchy the transformation above would be beneficial. The specific class that should be modified is given below:

Similar transformations can be used to compose Modelica models based on the interpretation of other modeling languages. During such composition some classes need to be wrapped to provide a different interface. For example, when there is only a force specified for moving a robot arm, but the available library of components only provides electrical motors that generate a force proportional to a voltage input.

Mixin composition of the entire contents of two or more classes into one an- other is performed when the models are flattened i.e. as the first operation in model obfuscation or at compilation time. The content of the classes com- posed below is not relevant for this particular operation. The composition

Modelica should provide additional constraints on composition, based on the domain knowledge. These constraints are specifying, for example, that specific components should not be connected even if their connectors allows it. We would like to further investigate how these constraints could be specified by library developers.

