Our generalization is based on the introduction of histories into OCL. Histories describe the ex- ternal behavior of objects and groups of objects. Moreover, to reason compositionally about the behavior of a complex system we distinguish between local specifications of a single object and global specifications describing the interaction between objects. These two types of specifications are expressed in syntactically different dialects of OCL. Our notion of compositionality, which is formalized in this paper by a compatibility predicate on histories, allows the verification of models during the early stages of a design.

The behavioral concepts in OCL are pre- and postconditions of opera- tions. The additional behavioral concept of a message expression has been introduced in OCL 2.0 [3]. Message expressions are expressions on messages sent by a particular object. As we shall demonstrate this imposes a real re- striction.

Adhering to the encapsulation principle of object-oriented programming we separate specifications into a local part describing the behavior of an ob- ject, and a global part describing the collaboration between different objects to achieve a common goal. More precisely, a local specification consists of a specification of the internal structure of an object and a specification of the observable behavior of an object, its local history. A global specification specifies how the objects are associated to each other and how they exchange messages using a global history.

The remainder of this paper is structured as follows: In the next section we summarize the current proposal on extending OCL with message expres- sions and demonstrate a weakness of their approach when applied to message expressions. In Section 3 we describe the notion of events and histories used in our extension of OCL. We identify the observable behavior of an object for the assertional specification of objects. We use the traditional choice of messages sent and received by an object. In Section 4 we describe how our method facilitates compositional specifications and reasoning. We explain the distinction between local specifications, local behavioral specifications, and global specifications. In Section 5 we describe our compositional verification method. Finally, we draw some conclusions and compare our results to related work. We use the terminology defined in [3,15,16].

We describe the means of specifying interactions between objects in OCL 2.0, and in what respect they are not sufficient from a pragmatic point of view. To explain this, we introduce the Sieve of Erasthostenes as an example, and follow the ideas presented in [1].

Events drive the computation of UML models. An event is a specification of a kind of an observation, e.g., calling an operation or receiving a return value. The observation of an event is assumed to take place at an instant in time without duration. For our discussion we distinguish two kinds of events: signal events and call events.

Its message. For an operation call we pass two messages: The first message is sent to initiate a call. It consists of the name of the operation and the actual parameter values passed to the receiver. The second message is used to acknowledge the completion of an operation call and to send return values back. For a signal we pass one message. A message consists of:

We distinguish between a local and a global history. A local history con- tains the externally observable events of a single object and describes the interface of it. A global history contains all observable events of the complete system. These observable events are all events generated by all objects of a system during its computation and the events received from its environment, in the order in which they occur.

We show that our notion of history in OCL is at least as expressive as the message expressions proposed in OCL 2.0, proceeding as follows. First we show how the data types used for message expressions can be represented in our formalism. Then we explain how OCL 2.0 message expressions can be ex- pressed as history expressions. We shall point out some semantic ambiguities in the standard, and how they may be corrected.

We have shown that, in addition to our data types and a mechanism which updates histories, everything needed for behavioral specifications is already present in standard OCL. In this section we show that our proposed extension is more general than the message expressions of OCL 2.0.

We refine the concept of histories in OCL by the notion of local and global specifications. A local specification is a constraint on a single object. A global specification is a constraint on the links between a group of objects. This distinction is introduced to separate different concerns:

Local specifications are used to specify the behavior of a single object in any possible environment in which this object can be used. Such specifications are used to constrain the instance variables of an object. Most important is that such a specification is not part of the interface of an object. A client of an object need not have any knowledge of these constraints.

Quantification is bounded by a local collection. A local collection is a collection which can be constructed without navigation expressions and the use of allInstances; e.g., Integer{2..(p-1)} is a local collection. We may construct such a collection from the local history, local attribute values, and the local association relations:

Local specifications usually constrain the implementation of an object. As such, the client of such an object should not need to know about implemen- tation details. For example, it is not necessary to know that the behavior of an object is implemented or specified by a state machine.

In the last example we do not refer to the sender of the signal received or the receiver of the signal sent. This cannot be done with state machines or message diagrams. It is, on the other hand, useful during top-down design, because we can postpone the decision of to whom we send the signal, or even decide to send it to self.

Our purpose is to verify the feasibility of the composition of objects by proving consistency of a set of local behavioral specifications through the use of a compatibility predicate. Compatibility essentially means that a set of objects has a global computation. This means that for its local histories we can find a matching global history.

We briefly sketch the soundness proof of our approach, assuming the cor- rectness of every object and that each object is active, i.e., has its own thread of control. The soundness proof is a generalization of the soundness proof of the compositional trace semantics of CSP-like processes communicating via channels to take into account the lifting of local specifications to the global level, and by this also to the level of objects, and that links between objects, which play the role of channels, may change and that different association ends may alias each other. See [9] for details.

The message expressions discussed in this paper are introduced in OCL 2.0 [3]. In [13] Kleppe and Warmer define the semantics of the action clause in terms of histories of events. This paper inspired our definition of histories. We have shown that the proposal for message expressions in OCL fails to take received messages into account. We have introduced an extension of OCL which does take these received messages into account. Our formalism, based on histories of events, can emulate the message expressions of OCL 2.0 and is more expressive.

Our extension of OCL is conservative. It does not add any new syntactic constructor to the language and does not lead to any change of the OCL meta-model. Instead, histories and events are introduced as new data types and their operators can be defined within existing OCL. Using this approach makes the meaning of a message expression immediately apparent to users of OCL. The drawback is that such expressions are often hard to read.

