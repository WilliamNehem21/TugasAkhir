We describe an interactive visualization tool for large natural deduction proof searches. The tool permits the display of a search as it progresses, as well as the proof tree itself. We discuss the feature set and architecture of the tool, including aspects of extensibility and the interface for interaction with other user-provided analysis and visualization code.

ity (IARPA) Collaboration and Analyst System Effectiveness (CASE) Program, contract FA8750-06-C-0194 issued by Air Force Research Laboratory (AFRL). HNC Software is a subcontractor of the University of South Carolina in this contract. The views and conclu- sions are those of the authors, not of the US Government or its agencies.

There are two main reasons why automated theorem proving in natural de- duction particularly benefits from visualization. First, natural deduction is generally considered to be easier to read than most other logics (4; 15; 19); one motivation for doing theorem proving in natural deduction (ND) is to pro- duce easily-comprehensible proofs, but in order to be understood they must first be put in an accessible form. Second, automated theorem proving (ATP) in natural deduction is still in early stages of study, and visualization provides a much-needed tool to assist in understanding the operation of experimental algorithms. By proving and visualizing in natural deduction, a single tool can display both human-readable proofs and be faithful enough to the data structures used by the reasoner to allow easy development of theorem proving algorithms.

Many ideas have been developed to aid in the comprehension of automat- ically generated proofs. Some we adopt for our purposes, such as graphical display (23). Others are unnecessary, such as converting proofs to natural deduction (15). Still others may aid proof comprehension but would do so at the cost of obscuring the function of the underlying theorem prover, such as conversion to natural language (6), and so we eschew them. We did not ex- pect HTML-based browsers such as IWBrowser (of the Inference Web project,

ViPrS was built specifically for the SILK theorem proving project, which we describe in section 2. The design is intended to be decoupled from SILK as much as possible, but effort was not spent in this initial version on allowing ViPrS to interact with arbitrary reasoning engines. SILK reads in proofs specified in a fairly simple XML format (described in (26)). Section 3 describes ViPrS, including its interface, implementation, and architecture. In section 4 we discuss experience with ViPrS to date, and possible future work is discussed in section 5.

Automated theorem provers have traditionally been directed toward prob- lem solving in the domain of mathematics (24; 22). Although they have been successfully adapted to other formal domains, such as circuit verifica- tion, adaptation to informal domains of human knowledge has proven much more challenging. Large ontologies (18; 17) have been constructed to formal- ize reasoning in many domains, and the semantic web (2) offers the promise of ever growing amounts of formal knowledge over which software will attempt to reason. Traditional approaches to automated reasoning suffer from the combinatorial explosion of the search space that follows from the enormous number of concepts and axioms in large knowledgebases.

The intercalation theory underlying natural deduction search has been proven sound but has not received the large-scale implementation attention that has been given to resolution and other standard automated theorem proving techniques (12; 1). Reasoning directly in CL is novel, and the practical complexities are yet to be discovered. Reasoning in large knowledgebases of course yields very large search spaces and often large proofs as well, as inherited properties of classes must be established by reasoning through the subclass hierarchy. For all of these reasons, development of a practical, usable system such as SILK is likely to encounter many unforeseen obstacles which may be difficult to understand and overcome without tools such as ViPrS, which provide insights into the search patterns and inefficiencies that arise in practical application. SILK is in very early stages of development. It has not yet been reported on and is not available for public access.

A complete proof, then, consists of the proposition to be proved at the root, various internal nodes, and axioms and assumptions as leaves. A proof search graph is similar, except that its leaves may include formulas whose truth is as-yet undetermined. As such, proofs are merely a special class of proof search graphs, namely, completed ones. For conciseness we will henceforth refer to the object of visualization as a proof search.

The main part of the ViPrS interface is the viewing pane. Here, the proof search is displayed in a traditional graphical format, with nodes represented as boxes and their relationships as lines between them. By default rule nodes have text indicating their type (which rule is being applied), while line nodes are blank (due to the lengthy propositions of most interesting proofs). The contents of a line node are viewable in a tooltip, or can be displayed using the command-line interface, as described in section 3.1.2.

The viewing pane allows various types of mouse-based interaction. Scrolling the mouse wheel zooms in and out of the proof, allowing inspection of the fine detail of proofs that are too large to easily fit on screen. Clicking and dragging pans the display. Clicking on a node selects it, causing it to visually increase in size and making it the object of future button presses. Hovering over a line node displays a tool-tip that contains its formula and the formulas that make up its context.

3. Clicking on one end of a crossing edge automatically pans the display to the far end of the edge and darkens both ends of the edge. The panning is most important when the far end of the edge is offscreen; the highlighting is especially useful when multiple crossing edge endpoints are visible.

Sited below the main viewing pane is the Command Line Interface (CLI), the primary means for the user to manipulate the proof search. The CLI lets the user interact programmatically with the visualization and the reason- ing engine. Specifically, the user can enter arbitrary Python code and have it interpreted. Through predefined library functions and specially exposed variables, this code can interact with the visualization. This means that the user can query and manipulate every property of the proof search without the need for any explicit prior implementation of the particular interaction.

From that abstract model, we derive a concrete visualization of the graph, with fields for all of the values salient to a visual display, including position, text, color, size, shape, and so forth. The main display and minimap are each a view onto this visualization. 5 These two displays, along with the other inter- face elements, are uniformly represented as Java Swing JComponent objects. The command dispatcher responds to button presses and entries in the command line window by passing the code to be run to the command in- terpreter. The command interpreter, which holds references to the relevant objects of interest, evaluates the given code, and then asks the visualization

The prefuse visualization toolkit 6 (10) is the open source software package used to drive the visual component of ViPrS. It is a software toolkit specifically designed for the visualization of graphs. It provides classes to model a graph with various visual characteristics, and then renders that model to a Java Swing JComponent which is embedded in the GUI.

Beyond detection of bugs (coding errors), the real goal of the system is to understand the structure of the search space in order to improve search efficiency. The full search space can potentially contain redundant subtrees. These are recognized during search and treated specially so that redundant search does not occur. However, the use of Skolem functions and Herbrand terms during search introduces the possibility of parts of the search space which are redundant without being identical (rather, they are identical up to variable renaming). Proper treatment of these redundancies is best handled

Extensibility was the primary consideration in the design of the ViPrS archi- tecture. The simplest type of extension, as described above, is the addition of Python functions that can be called from the CLI. Colorings which high- light structural properties of the search space have been written already, such as those which highlight nodes that have been successfully proven, or those which are major premises (as the ND search is driven by restriction to normal deductions).

possibility is embedding nodes into points on the plane without rendering in- dividual nodes or edges. The points of the plane could be colored to represent properties of nodes, such as a heat map representing the ages of nodes to indicate the order in which parts of a tree were visited. Other maps might represent the number of free variables occurring in each node, or the num- ber of instances of members a given set of formal symbols (names) from the knowledgebase that might be of particular interest to a user.

One of the motivations of ND theorem proving is to provide a more human- readable proof. The fact that intercalation always finds normal proofs can be exploited to automatically collapse parts of the visualization based on mini- mal nodes and the branch structure of normal derivations. The plans which SILK generates to provide guidance for proof search should give guidance for collapsing as well, and future work should provide the ability to present a plan which expands to the underlying proof.

Further extensions of SILK will likely also lead to extensions of the vi- sualization. SILK is currently being extended to interoperate with BRUSE, a Bayesian network software system which provides soft evidential updating (26; 27). SILK proofs are being converted into network fragments as a means of automating network construction, and the ViPrS system is likely to be extended to provide visualization of the resulting Bayesian networks.

