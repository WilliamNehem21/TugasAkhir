In [2] we proposed a parallel graph algorithm for detecting cycles in very large directed graphs distributed over a network of workstations. The algorithm employs back-level edges as computed by the breadth first search. In this paper we describe how to turn the algorithm into an explicit state distributed memory LTL model checker by extending it with detection of accepting cycles, counterexample generation and partial order reduction. We discuss these extensions and show experimental results.

The rest of the paper is organized as follows. In the next section we recall the main ideas of the graph algorithm as given in [2]. The following sections deal with accepting cycle detection, counterexample generation, and partial order reduction, respectively. In a separate section, we summarize the experimental evaluation of the algorithm.

A distributed graph is such a graph whose vertices are divided into as many disjoint sets as there are participating workstations. In particular, a parti- tion function is introduced to assign to each vertex a workstation the vertex belongs to (the workstation owns the vertex). The entire distributed compu- tation is started and terminated by one of the workstations involved. This distinguished workstation is called the manager.

The graph is supposed to be given implicitly, i.e. by an initial vertex and a function that for a given vertex returns its immediate successors. During the computation of the algorithm all the generated vertices of the graph are stored on the corresponding workstations. Thus each workstation keeps its own part of the distributed graph. If an exploration should proceed to a vertex that does not belong to the workstation, a message containing the vertex is sent to the workstation owning it and the local exploration of the vertex is skipped. The vertex is further processed by the destination workstation.

Before explaining the idea of the algorithm we recall the definition of a back-level edge. In short, a back-level edge is such an edge in the graph that does not increase the distance from the initial vertex. For simplicity, we assume that all vertices of the given graph are reachable.

It is easy to see that for each cycle in the graph there is a maximal k such that the cycle contains a vertex from Levelk. Moreover, any edge on the cycle leading from a vertex in Levelk has to be a back-level edge. Since all vertices in the cycle have a successor it is obvious that each cycle in the graph contains at least one back-level edge.

The cycle detection algorithm works as follows. There are two proce- dures that the algorithm performs alternately. The task of the first procedure (henceforth called primary) is to find all the back-level edges by exploring the graph gradually level by level, while the task of the second procedure (hence- forth called nested ) is to test each discovered back-level edge for being a part of a cycle. The primary procedure is implemented as a level synchronized breadth first search of the graph. As soon as a level is completely explored, the nested procedures are initiated for all the back-level edges emanating from a vertex on the current level (called current back-level edges) in order to detect cycles. Thus the goal of a nested procedure initiated for a back-level edge is to hit the vertex from which the back-level edge emanates (called target). If at least one nested procedure succeeds then the presence of a cycle is ensured and the algorithm is terminated. Otherwise, the primary procedure continues with the exploration of the next level. Each nested procedure searches for its target in a depth first manner. Since there are many nested procedures per- formed concurrently, the target of each nested procedure has to be propagated by the procedure itself. Unlike the standard DFS, the vertices are not marked as visited and so may be revisited. Note that the search space of nested pro- cedures can be limited to the vertices that have already been visited by the primary procedure.

The basic idea behind detection of accepting cycles in partially accepting components is to prevent the algorithm from detecting non-accepting cycles. For this purpose each nested procedure maintains an additional (accepting ) bit to indicate that it has passed through an accepting state since its last pass through a current back-level edge. In particular, this accepting bit is set to true whenever the procedure reaches an accepting state and is set to false whenever the procedure passes a current back-level edge. The bit is set to false initially.

Let us first assume that procedure [F, 0] arrives at state C before procedure [A, 0] or that A < F . In such a case procedure [F, 0] continues through states C and E and hits its target (the state F ). While in the graph d) the procedure reaches its target with the accepting bit set to true, in the graph b) it reaches its target with the bit set to false. Obviously, this can distinguish between accepting and non-accepting cycles.

Let us assume now that A > F and procedure [A, 0] arrives at state C before procedure [F, 0] does. In such a case procedure [F, 0] is stopped when it arrives at state C, while procedure [A, 0] continues in the search. In the case of the graph b) procedure [A, 0] passes current back-level edge (F, B) without increasing its counter of passed current back-level edges because its accepting bit remains set to false. This means that the procedure does not change its identification and so it is stopped when it arrives at state C for the second time. In the case of the graph d) the [A, 0] procedure sets its accepting bit to true when it passes the accepting state E which allows the procedure to increase its counter of passed back-level edges when it passes the back-level edge (F, B). Note that the accepting bit is reset to false when the counter is increased. The procedure then arrives at state C for the second time being identified as [A, 1]. This means that the procedure is not stopped but it continues in the search. At state E it sets its accepting bit to true and passes the back level-edge (F, B) changing its identifier to [A, 2]. Then it goes through state C for the third time. At the state E it sets the accepting bit to true again and after passing the back-level edge (F, B) it exceeds the number of current back-level edges. Hence, the existence of an accepting cycle is correctly detected.

The proof exploits the correctness of the algorithm for distributed back- level edge detection as presented in [2]. In addition, several facts have to be taken into account. If there is an accepting cycle in the graph then at least one (shallowest) cycle is explored completely by a nested procedure because either all queues BBLQ are emptied before the next level of the graph is processed or the presence of an accepting cycle is reported. Another important fact is that no nested procedure can pass through a non-accepting cycle infinitely many times. For a more detailed proof see the full version of the paper [3].

Model checking algorithms should be able to provide the user with a counterex- ample in the case the verified property is violated. In general, the computed counterexamples can be quite long which might make it difficult to locate an error. Thus computing the shortest possible counterexample greatly facilitates the debugging process. In this section we present a technique to generate short counterexamples.

More precisely, for each vertex v the value par (v) is stored during the primary search which is the parent of the vertex v in the search (called BFS parent). Note that it is assigned only once during the whole computation. In addition, we also store the value par -dfs(v) which is the parent of the vertex v in a nested search (called DFS parent). It is assigned every time a nested procedure is allowed to pass through the vertex. In both cases, the parents induce edges in the following way. If v is a vertex and par (v) is the BFS parent of v, then (v, par (v)) is the induced edge in the BFS parent graph, similarly the DFS parents define the DFS parent graph. In the following we show how the counterexample can be found by traversing the BFS and DFS parent graphs.

A significant positive feature of our algorithm is related to the length of counterexamples it provides. Since the algorithm is primarily based on breadth first search exploration, the counterexamples tend to be short. See the section on experiments for a few examples.

The reduced state transition system is generated by a modified generation algorithm which explores only a subset of transitions, enabled at each state encountered during the generation, called an ample set. The ample set can be defined in a manner that does not depend on the particular way the state transition system is generated. This is accomplished by a set of conditions relating the full state transition system to the corresponding reduced one. Note that there could be more than one ample set satisfying the conditions for a given state. We say that a state s is fully expanded whenever ample(s)= enabled(s).

To utilize partial order reduction within our distributed memory on-the- fly algorithm we use the similar approach as implemented e.g. in the model checker SPIN [13]. The approach combines the construction of the state space with checking that it satisfies the specification by exploring the product graph. The only condition that needs attention is obviously the cycle condition C3- bfs. It can be shown that it is correct to check the condition with respect to cycles of the product. We have implemented the method and experimentally confirmed reductions in space and time.

As expected the counterexamples were very short compared to those re- turned by the Nested DFS algorithm. This is due to the breadth first like nature of the state space generation. However, the time to find the counterex- ample was generally longer and more states had to be explored. We stress that the shortness of a counterexample is crucial in debugging.

