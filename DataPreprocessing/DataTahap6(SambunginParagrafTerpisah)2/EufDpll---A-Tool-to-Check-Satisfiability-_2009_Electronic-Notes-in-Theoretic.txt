The GDPLL procedure [2] is a generalisation of the well-known DPLL proce- dure [6] which was introduced in the early 60s as a proof procedure for first-order logic. The GDPLL procedure is defined in terms of four basic operations (REDUCE, Eligible, SatCriterion and Filter), that have to be filled in for a particular logic. An original DPLL procedure is an instance of GDPLL in case of propositional logic.

The satisfiability problem for EUF logic naturally fits into the GDPLL frame- work. In this paper we provide an algorithm for this logic which is an instance of GDPLL. Since the algorithm is an instance of GDPLL, we have to check its soundness and completeness by verifying the conditions mentioned in Section 3.

Testing and verification are the bottleneck of development of complex systems. This applies, in particular, to hardware and software systems. Recently theorem provers were used to verify a pipelined microprocessor. The method proposed by Burch and Dill [5] greatly enhanced verification techniques. The state of a register at any point in the computation can be represented by a symbolic term. Uninterpreted functions can be used to abstract blocks of combinational logic, for example ALU, as black boxes. Uninterpreted functions without arguments are considered as term variable and can be used to abstract constant values that have special semantic meaning,

The DPLL procedure, due to Davis, Putnam, Logemann, and Loveland, is the basis of some of the most successful propositional satisfiability solvers. The original DPLL procedure was developed as a proof-procedure for first-order logic. It has been used so far almost exclusively for propositional logic because of its highly inefficient treatment of quantifiers. In this chapter we sketch the basic ideas of GDPLL, the general version of the DPLL procedure. For a full description the reader is referred to [2].

The DPLL algorithm is a complete, backtracking-based algorithm for deciding the satisfiability of propositional logic formulas in conjunctive normal form. It consists of the following three rules: the unit clause rule, the splitting rule, and the pure literal rule. These rules reduce a formula according to some criteria. Therefore, a function REDUCE which performs all rules for formula reduction is assumed. Like DPLL, GDPLL has a splitting rule, which carries out a case analysis with respect to an atom a.

We prove in Section 4.1 that the set of reduction rules is terminating, so at least one normal form exists. Unfortunately, the rules are not confluent as it is shown by the following example. So the normal form is not unique.

The function Eligible() allows us to choose literals from the purely positive clauses of length more than one, i.e. from the core of a formula. Hence, we may terminate with SAT as soon as the core of a reduced formula is empty and the formula does not contain the empty clause.

Furthermore we have experimented with random formulas. Starting with a set random clauses, a number of random substitutions were applied (like x := f (x)), to ensure that reduction could be applied. The problem size was about 1000 clauses and 10 different symbols. The EufDpll algorithm was able to solve all these problems. However, the BarcelogicTools program (winner of the SMT-COMP 2005 competition) [11] could do the same and was significantly faster in determining the solution.

