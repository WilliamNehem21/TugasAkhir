The trend towards self-organization of systems like peer-to-peer or ad hoc networks generates increasing needs for designing distributed storage schemes that should themselves be self-organized and cooperative. Unfortunately, in such systems, the data stored are exposed to new disruption attacks either because of the selfishness of participating nodes with respect to their resources or even because self-organization that leaves such systems much more subject to maliciousness. This setting, combined with the high churnout of nodes and with the high chances of network partition, particularly in mobile ad hoc systems, makes it quite uneasy to ensure the long-term availability of data stored in such fashion. This paper discusses a verification framework based on the probabilistic assessment of small cryptographic verifications in order to assess storage and to prevent data destruction. A protocol for determining the availability of data stored in an ad hoc fashion is detailed. The design of a reputation system based on this protocol and inciting nodes to cooperate towards storage is then discussed.

Anonymity: anonymity can refer to the data owner identity, the data holder identity, or the interaction details operated between them. Anonymity avoids attacks where the attacker targets all holders of a given data, thus extinguishing data from the whole system. Systems that seek to provide anonymity often employ infrastructures for providing anonymous connection layers, e.g., onion routing [7].

This section describes the architecture of the storage framework designed for ad hoc networks , and in particular how verifications can be implemented. A typical multi-hop mobile ad hoc network consists of mobile nodes which communicate with each other through multiple routes. The storage application allows a data owner node to select a given holder node in its vicinity and to send it the data to store once the holder has agreed to store the data. It is likely that the owner node will repeat this operation for the same data at several holders, with the aim of fostering data availability by replication. The application should permit the owner node to periodically verify if the holder node still possesses the data it has pledged to store, the verification consisting in a challenge-response protocol between the owner node and the holder node (see Section 3). Intermediary nodes on the route between the two nodes may as well verify the holder response, thereby making it possible for them to evaluate the behavior of the holder node, and to get a rough idea of the trustworthiness of the holder by themselves even if they do not store data at this node.

The proposed protocol verifies the completeness property because if the correct answer of P to a challenge suffices V to be convinced that H is keeping all data. Regarding the soundness property, if H destroys the data or a portion of the data, P cannot answer challenges sent by V with high probability (this is analyzed in the following subsection). H answer challenges for a specific data just only from eligible nodes: the data owner O and owner delegates including throwboxes, denoted V . In the protocol, the timestamp concatenated to the challenge message guarantees that the message is sent by O. For a delegate, the challenge message must comprise in addition to the signed timestamp a certificate proving the legitimacy of the verifier as a delegate in the form of CertO(O, PKV , validity), signed by O. Also considering the verifiability property, any node that has knowledge of the respective public

A holder can pretend to be storing data while in fact proxying in front of another data holder. Then, the attacker simply passes data back and forth between the originator and the holder, making the data originator believe that it is the data holder, and the data holder that it is the originator of the data. This problem can be addressed by having the index j for each challenge randomly chosen by both parties as suggested in the random-read protocol presented in [9] in which both parties randomly choose the offset of the block to be checked.

