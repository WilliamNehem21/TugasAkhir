available in Eclipse. These include code browsing, text-editing with in- dentation, syntax-directed editing, semantic browsing, compilation, de- bugging, a UML-like CASE tool and an interface builder. Furthermore, other features of modern IDEs such as syntax colouring and semantic tool-tips should be available.

Plug-ins for BETA should be implemented in BETA. The reason for this is that it will allow for reuse of existing BETA code from the MjolnerTool. Furthermore, if BETA developers and users would have to switch to Java in order to implement BETA tools, the motivation for using Eclipse will be smaller.

BETA libraries and frameworks should in general be usable together with Eclipse. For the non-GUI frameworks no problems were expected, but for the GUI libraries it is not at all clear to what extent this can be done when e.g. implementing Eclipse plug-ins.

Below two approaches for integrating BETA with Eclipse are described. The initial approach is to use JNI to bridge Java and BETA via C. In this way, it is possible, in principle, to write parts of the plug-ins in BETA. As said below, this turns out to be tiresome and very complicated to debug.

It is, however, a major task to generate class files from BETA. class files are designed to support Java and in many ways BETA is more general than Java. The reason why this was considered a realistic alternative was that the BETA.Eclipse project was carried out at the same time as a project for implementing BETA on JVM 4 and Microsofts CLR/.NET platform.

For Eclipse text editing, a so-called indent strategy can be associated. This specifies a default behaviour for indentation of code. A default indent strategy called DefaultAutoIndentStrategy exists in the Eclipse class library. Imple- menting a specific language indent strategy is obtained by overriding methods

The JDK 6 library provides an interface to native methods called JNI 7 . This allows code running in the Java Virtual Machine to access library me- thods written in C. BETA also has a C interface, which combined with JNI makes interoperability between Java and BETA possible through C.

The implementation of the BETA indent strategy by reusing BETA li- braries through JNI consists of more than 1000 lines of BETA code in several source files. This shows that this technique is possible to use for a non-trivial example. However, it has several disadvantages: One problem is that three different languages are used. This makes the integration tedious and compli- cated. Not only is it complicated to write the code, but more importantly once written and compiled it is far from certain that it will work. Loading of the libraries happens at run-time and this late binding of the code makes it impossible for the compiler to make even simple syntactic and semantic checks on e.g. the various method invocations. When a run-time error occurs in external code there is little information from the JVM. Often one has to suffice with the error message Crashed somewhere outside the VM. Debug- ging such a bug is done by carefully looking at the source code and using print statements everywhere!

Note that this paper is not an attempt to present the rationale behind the generality of BETA. The purpose is to present some of the issues in mapping BETA to JVM. This will be illustrated by more or less useful examples. The rationale behind BETA has been presented in a number of other places such as [10,11]. A short summary of BETA is given in the appendix.

The Calculator pattern has three attributes R, set and add. R is an instance variable holding the current value of the Calculator. The attributes set and add describe operations on the calculator. The operation set is used to set the value of R to the value of the enter-parameter V. The operation add adds the value of the enter-parameter V to R and returns (exit) the value of R to the caller.

The above example illustrates how a subset of BETA is mapped to Java. Of the remaining parts of BETA, the most challenging ones to map are inner, virtual patterns used as virtual classes, leave and restart (essential goto) out of nested method calls, patterns as variables and coroutines, concurrency and synchronization. The full mapping is described in [1]. [1] also describes the mapping to C#, which at the language level essentially is identical in terms of structure to the mapping to Java. One major difference is that .NET/CLR and thus C# does not support full inner classes, which means that the mapping of nested classes has to include an explicit reference to the enclosing object. At the bytecode level there are of course minor technical differences between JVM and CLR.

This pattern calls the indentation library directly, so with an implementation of BETA on JVM, it is possible to drop all of the external libraries used for JNI. Note that the solution could just as well have kept BetaAutoIndentStrategy in Java, and accessed the BETA library from there. This is up to the pro- grammer.

The BETA IDE described so far gives the user the possibility to edit, indent, compile and run BETA programs. Another important part of an IDE is the debugger. As mentioned above, the MjolnerTool has a native debugger, so there are two solutions for adding a debugger to the BETA plug-in: use the classic BETA debugger or somehow use the Java debugger available in the Eclipse Java-IDE, called the JDT debugger.

What complicates the setting of breakpoints in BETA sources, is the type name that has to be specified. As described in section 3, a BETA source file is compiled into several class files, i.e. many types. Given a specific BETA file and a line number it is not trivial to find the corresponding generated class file. In a future version, the BETA compiler would, however, be able to supply this information for the BETA plug-in 9 .

In the proof-of-concept implementation of the BETA IDE, it is possible to add line breakpoints to the BETA source 10 . I.e. the debugger can stop execu- tion on specific BETA imperatives. It is possible to perform single stepping, and objects may be inspected and modified with full source code information including BETA names of classes and variables [3]. This behaviour is mainly a property of JVM, which has complete type information, symbolic names, and source code line numbers for a given program. It is, however, impressive that it is possible to develop generic tools like Eclipse and JVM that given a compiler that generates JVM bytecode can support a full symbolic debugger for a considerably different language like BETA.

Part of the project[1] in porting BETA to CLR/.NET has been to investigate the use of Microsoft Visual Studio .NET [12] as an IDE supporting BETA. Visual Studio .NET (VS) is a powerful IDE supporting a number of languages and in this way, it is a possible alternative to Eclipse. As indicated by its name, this IDE supports the languages of the Microsoft .NET platform, which in many ways resembles the Java platform. Unlike Java, .NET is designed to support multiple programming languages.

The BETA IDE in Eclipse has been used by a small team of people for browsing, text editing, indentation and compilation. This has been a promis- ing experience and in the future increased use of Eclipse as an IDE for BETA is to be expected. Furthermore, when a full integration into Visual Studio has been produced, using BETA in Visual Studio is to be expected as well. Time will tell which of the two will turn out to be the preferred IDE on Windows.

number of new ones. Most object-oriented languages have classes, subclasses and virtual procedures and some have procedure variables. Since a pattern is a generalization of say class, procedure, function, the notions of subpat- tern, virtual pattern, nested pattern and pattern variable also apply to these abstraction mechanisms.

The subpattern covers subclasses as in most other languages. In addition, procedures may be organized in a subprocedure hierarchy in the same way as classes may be organized in a subclass hierarchy. Since patterns may also be used to describe functions, coroutines, concurrent processes, and exceptions, these may also be organized in a pattern hierarchy.

The notion of virtual pattern covers virtual procedures as in Simula, Java and C#. In addition, virtual patterns cover virtual classes, virtual coroutines, virtual concurrent processes, and virtual exceptions. Virtual classes provide a more general alternative to generic classes as in Eiffel or templates as in C++. A nested pattern is a pattern defined textually within another pattern.

Nested procedures are known from Algol and Pascal. In addition to nested procedure patterns, BETA also supports nesting of class patterns. Java sup- ports nested classes in the form of inner classes. In C++ and C# a restricted form of nested classes is supported, but data-items in the enclosing object cannot be referenced from inner classes.

BETA includes the notion of pattern variable. This implies that pat- terns are first class values, that may be passed around as parameters to other patterns. By using pattern variables instead of virtual patterns, it is possible dynamically to change the behavior of an object after its generation. Pattern variables cover procedure variables (i.e. a variable that may be assigned dif- ferent procedures). Since patterns may be used as classes, it is also possible to have variables that may be assigned different classes, etc.

