Many cryptographic protocols and attacks on these protocols make use of the fact that the order in which encryption is performed does not affect the result of the encryption, i.e., encryption is commutative. However, most models for the automatic analysis of cryptographic protocols can not handle such encryption functions since in these models the message space is considered a free term algebra. In this paper, we present an NP decision procedure for the insecurity of protocols that employ RSA encryption, which is one of the most important instances of commuting public key encryption.

Only recently the perfect encryption assumption for protocol analysis has been slightly relaxed. In [12], unification algorithms are designed for handling properties of Diffie-Hellman cryptographic systems. Although these results are useful, they do not solve the more general insecurity problem. In [7,8], decidability of security has been proved for protocols that employ exclusive or. In [6], we have extended this result to protocols that are based on Diffie- Hellman exponentiation. Diffie-Hellman exponentiation has also been studied in [13] and [3]. However, in the former work no decision procedure is provided and in the latter severe restrictions are imposed on the protocol and intruder model.

Let us illustrate by two simple examples given in [17] how commutative proper- ties of public key encryption schemes are employed in cryptographic protocols. The first protocol is due to Shamir. The aim of this protocol is to permit secure communication between two agents who neither share a symmetric key nor know the public key of the other agent. The protocol uses the commuta-

Agent A4 can then also sign the contract using her private key k4. The point here is that due to the commutativity property, A4 does not need to know in what order the agents signed the message. Certainly, this protocol, when for instance used as a contract signing protocol, has many problems, which, however, we do not want to discuss here.

message. These conditions do not seem to exclude realistic protocols. See [6] for more detailed remarks on the above conditions. Note that in our model, a protocol corresponds to a specification in the Alice&Bob notation together with an instantiation. As a result, several sessions are modelled as only one protocol.

<= {((A, 1), (A, 2))}, i.e., it only satisfies (A, 1) < (A, 2), and thus, makes sure that (A, 1) must be performed before (A, 2). The initial intruder knowledge is {1, KI, K' }, i.e., besides the constant 1, the intruder knows her public and

While the first three conditions are standard for Dolev-Yao intruders, the last condition, which gives the intruder the ability to perform commuting public key encryption, is new. We call this extended intruder the RSA intruder. Note that by performing pubic key encryption, the intruder can both encrypt and decrypt messages. Also note that if E is a set of normalized messages, then so is forge(E).

In Definition 3.2 we restrict ourselves to k = Card(I) for simplifying no- tations. Considering k < Card(I) would amount to detect attack even with partial (i.e. unfinished) sessions. This kind of attacks can be captured too by analyzing protocols with some final steps removed.

