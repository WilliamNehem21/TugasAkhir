Contemporary research into embedded system design [22,13,7] has advocated a significant change to the process outlined above, whereby the major functionalities are first modeled at a high level before being mapped to specific technologies, such as a DSP or ASIC. Modeling is realized through a collection of formalisms covering a variety communication, concurrency, and computation schemes. In the Ptolemy II system design environment [13], for example, an engineer can describe computations using combinations of the many supported models, including data-flow network and discrete-event models. By separating functionality from implementation, tools such as Ptolemy II attempt to coordinate the system design process and produce verified designs more quickly by leveraging modularity and abstraction. In limited cases, automated tools have been able to produce implementations directly from these high-level models.

The rest of this paper is organized as follows. Section 2 presents, by way of ABEL, a high-level overview of how the syntax and semantics of a hardware descrip- tion language are specified in Maude. Section 3 explains in detail our framework for specifying and trace checking co-designs and illustrates our proposed method through two in-depth case studies. Section 4 discusses related work, and Section 5 presents some conclusions.

Synchronous digital circuits need to respect two separate notions of execution order. First, during each clock cycle, the topology of the combinational (non-state carrying) network must be respected: each internal node value within the circuit is considered accurate only after its inputs become accurate, and some amount of time has elapsed to compute the value from the stabilized inputs. Second, latches should respect a global clock and should all be updated in parallel.

Clearly, the verification of a co-design project should include the interactions between hardware and software; both to ensure system wide correctness and to validate the engineering choices that led to the partitioning scheme. If, for example, the instruction throughput is never high enough to take advantage of all of the functional units, then it might be worthwhile to use this information to reevaluate the hardware partition and scale back the design. If the software is complicated and depends on many subtle interactions with the available hardware, then this inefficiency might be very hard to uncover without an implementation to test on, or without formal analysis. If, as a second example, the co-design effort tried to minimize power consumption, then it would be useful to formally validate how the power saving features perform when the software is executing on the chip. Hence, validation of the co-design decisions after implementation may be necessary to guide redesign or other efforts in the future.

Creating a Maude specification for the semantics of an HDL such as ABEL represents our first step in an effort to facilitate co-verification. The strong modeling properties of rewriting logic, and Maude in particular, allow a user to take both the hardware and software components of a design and instantly embed them into a unified mathematical framework. In addition, meta-level properties of the system (e.g. software data structures) can also be conveniently modeled and related to the rest of the design. This allows the engineer to specify properties of his/her system in the most appropriate and natural language, hence promoting a modular verification effort that abstracts away unnecessary details and helps avoid error-prone encodings.

cycle in the fetch stage. All of these are interesting features that can be monitored during simulation. If there is a violation of one of these properties, the executing software can help to put the trace into a more understandable context. On the other hand, if a piece of software is producing incorrect results, but the property passes the test, then the programmer might want to look at the software itself.

would generally depend on the application binary interface (ABI) for argument and stack conventions, and also on the array implementation assumed. It would also rely on the specific register allocation map used. The ABI would be defined before any circuit design work is started, and the register map would be known by the engineer who wrote the assembly code or the compiler that generated it.

In trying to schedule the instructions for high performance, we initially made a mistake that caused the program to compute incorrect results. This was caught by ps-02 and we updated the code. When we fixed the code, a load-use dependency was unintentionally created and caused a pipeline stall, this was immediately found by ps-01 and fixed.

trace checking tool for digital circuits. It can check simulation traces for violations of properties specified in a linear temporal logic augmented with first-order vari- ables, arrays, and queues. The data structures permit property specification at a higher level of abstraction, thus improving usability and reducing low-level speci- fication errors. However, neither of these tools can easily be used to understand hardware/software interactions.

In the embedded design space, there are industrial tools that allow a certain degree of hardware/software debugging. The Xilinx EDK [25], for example, allows the user to debug his/her software with GDB and to scope the internal hardware signals when a breakpoint is triggered. However, it does not work in the other direction: hardware events cannot be used to stop the software. Furthermore, formal analysis is not supported by these debugging tools.

ing the properties related to their interactions with such environments, is as crucial as specifying and verifying the hardware/software system itself: both tasks should be done together. Although we have addressed some real-time and performance issues in our case studies, a full modeling of environments, though very important, is beyond the scope of this paper. The natural approach for modeling such environ- ments is viewing embedded systems as real-time systems that can be hybrid, and can even be both stochastic and hybrid. Therefore, from a rewriting logic perspec- tive the natural techniques and tools to use will include real-time rewrite theories [20], probabilistic rewrite theories [3], the modeling of stochastic hybrid systems [17], and tools such as Real-Time Maude [21] and the upcoming PMaude [3] and SHYMaude [17]. This should enable us to handle mechanical and sensing interfaces, such as those in many control systems, for example, anti-lock brakes systems. In the terminology of this paper it will also provide a natural extension of the meta-level properties that can be formally specified and analyzed.

