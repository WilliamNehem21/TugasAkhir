Static variables and methods are part of almost every modern object-oriented programming language. Static elements are for instance indispensable for certain kinds of design patterns applied during programming. Object-oriented specification formalisms on the other hand lack such concepts. This can prevent writing formal specifications close to the actual implementation, and can thus hamper a refinement-based stepwise development.

In this paper, we present such an enhancement of a formal specification language with static class elements. As language we use the object-oriented state-based method Object-Z [13,5], which already contains the main object-oriented features like object creation, inheritance and polymorphism. By making just a small exten- sion of the language (and its semantics), we can incorporate static variables and methods into Object-Z. This extension essentially concerns the addition of informa- tion about the class an object belongs to: like self referring to the object identity, we now have a property classname referring to the class of an object. With this single new concept we can model static class elements in Object-Z specifications. As this always involves a number of additional class definitions (for instance, one class being the root of all objects, and another class being the root of all classes), we fur- thermore define a shorthand notation which allows to simply write static variables and methods within normal Object-Z classes. We then show that creation patterns (more specifically, the Singleton pattern) can be modelled with this extension of Object-Z.

Static variables and methods will most often be used during the final step of developing a model close to an object-oriented implementation. Thus, during the development we will have a transition from a specification without to one with static elements. This transition should of course be a valid refinement step. Hence, we furthermore study refinement in this new setting of Object-Z with static elements. As it turns out, refinement between classes with static elements can simply be patterns, more specifically the Singleton pattern. We furthermore give a Java code fragment to show how the pattern can be modelled with static variables. The next section will then present our extension of Object-Z. Section 4 discusses the issue of refinement and compositionality, and the last section concludes.

Each instance of this class C holds its own variable logFile, therefore, if we have multiple instances, each l .getMessage returns a subset of all messages generated. Instead we would like the system to have just one instance of the logFile on which all instances of C write (more precisely, we would like one instance of Log only).

This particular issue of single object instantiation is a well-known problem in OO- programming languages and it can be solved with static variables. Static variables are created only once per class, not once per instance like normal object variables of classes. Static operations are similar, the operation is created once for a class and cannot use any internal information of an instance (unless it has a static variable with a reference to instances). In Java code static variables and operations are marked with the keyword static.

In object-oriented programming languages the concept of static variables and operations thus allows to formulate the Singleton pattern (and also other creation patterns). In Object-Z we would need to use global variables and/or functions to achieve the same effect. This would however break the object-oriented structuring: the unique Log instance would not be attached to the Log class anymore. This gets the more inappropriate the more such variables or methods we have. Moreover, as object-oriented programming languages either do not have global variables or consider their usage to be bad style, a specification close to the implementation should not have global variables.

of a class. The variable classname will take values out of the universe of all possible names of classes CNames. A more formal definition could first define a new meta- function name (see [13] for other meta-functions for classes), and use this to derive the name of the class of an object. The above definition can also be extended to cover polymorphism and class union.

i.e. every (object-side) class has to say what its class-side class is. This function classref , the classname construct and the constraint over the variable class are key to our framework: These constructs ensure that only one (and always the same)

With this we have finished the definition and usage of the framework. Now we can use the Singleton pattern. Consider again the class C from the last section having a variable of type Log . This class is next changed: the initialization of this variable now proceeds via an operation of class LogClass. Class C however does not need to know what the class-side of Log2 is, this can be calculated by using function classref .

We are ultimately interested in using the concept of static elements in a refinement- based design, where we start with an abstract model and gradually refine it into a specification close to an actual implementation. Being a programming concept, static elements will most likely appear in later stages when we introduce object- oriented programming structures into our design. Thus we have to see what re- finement means in this setting at all, and furthermore whether the introduction of static elements is a valid refinement step.

This means in particular that the class A may have references to objects of classes A1,..., An , i.e. have variables of type Ai , i = 1,... n. In our framework we in par- ticular have the object-side containing a reference to the class-side via the variable class, and possibly also vice versa. The appropriate notion of refinement is thus conditions of downward simulation essentially relies on this argument. Moreover, we can also extend this result to non-empty class-sides, using exactly the same argument. Here, we however need one small sidecondition: since the class-side can now also have variables, we have to make sure that there are valid bindings for the class-side. In particular, there must be a binding in the class-side that satisfies the Init predicate. Using the notation of above, but this time with an arbitrary class inside C , the condition is

The last step towards a proper usage of these elements would consist of changing the classes holding references to classes with static elements (in our log example, C ). Since this change essentially depends on the application itself, no general result can be established for it. Instead, this last step always needs an individual proof of refinement.

