We solve this efficiency problem by extending the execution mechanism for aspect-oriented programs. Typically, aspect-oriented programs are executed by mapping aspect-oriented constructs to Java bytecode which is then executed on a standard Java virtual machine. Recent approaches [6,7] investigate the extension of the executing Java virtual machine by aspect-oriented features. Concerning the optimization potential of these two approaches, it turns out that the first solution offers only restricted optimization gains because it is restrained entirely on the lim- ited operations of the Java bytecode. In contrast, the second solution offers much better optimization gains. Supporting aspect dispatch mechanisms at the level of the JVM is more promising as this allows for efficient weaving policies tailored to the specific needs of static and dynamic weaving in systems with only limited memory and computation power.

bytecode, which is eventually executed by a Java virtual machine. In our work presented in this paper, we are extending the JamVM virtual machine such that different parts of the aspect execution mechanism for OT/J are optimized. First experimental results show that we significantly reduce the execution time with our approach and, hence, improve run-time performance.

This paper is structured as follows: Section 2 gives an overview of the founda- tions of aspect-oriented programming. In Section 3, we present our optimizations of aspect execution. In Section 4, we explain our implementation of selected optimiza- tions in the existing execution environment of OT/J together with first experimental results. In Section 5, we discuss related work and in Section 6, we conclude and outline future work.

Aspect-oriented programming (AOP) provides for enhanced separation of concerns. It facilitates a modularization of crosscutting concerns, which would be scattered across the module structure in purely object-oriented designs. The core functionality is implemented in the base program, while the crosscutting concerns are defined in separate aspect modules. These aspects define the crosscutting functionality together with aspect bindings, specifying the points in the execution of the base program (join points) at which they should be executed.

There is no closed definition of aspect-orientation, resulting in a large variety of aspect-oriented programing languages. Several of them allow for dynamic activation (and deactivation) of aspects. This also applies to ObjectTeams/Java (OT/J) [8], which supports advanced modularization concepts. In OT/J, aspect functionality is defined in role classes which adapt individual base classes. Roles are contained in team classes, which define a collaboration context for them.

The aspect code has to be woven into the base code at some point in time so that it can be executed at the defined join points of the base program. There are different approaches to accomplish aspect weaving: Compile-time weaving statically weaves the aspect functionality into the base code. Run-time weaving can be performed at class loading time, before the base classes are executed by the JVM, or even later during the execution of the program. This can be done by a run-time component outside the JVM or inside the JVM itself. The later the aspect weaving is performed, the more dynamically the aspects can be added to the base program allowing for more flexible context-aware adaption of the executed applications. Unfortunately, dynamic aspect weaving suffers from more effort at run-time. Static weaving, on the other hand, increases the code size, which is also critical for small devices.

such woven program code can be optimized by enhancing the functionality of the executing JVM. This pays off by a significant gain in execution time, as we have shown in our first experiments described in Section 4. And moreover, it paves the road for our long-term goal, namely the dynamic weaving of aspects at run-time, instead of at class loading time, in order to also further optimize the code size of the executed applications.

Purely additive realizations of aspect-oriented programming languages per se pro- duce a certain amount of overhead, compared to the programming language they extend. In this section, we start by illustrating the overhead caused by the different tasks performed during aspect execution. In the succeeding subsection, we present our optimizations for the different kinds of overhead. The subsections in 3.2 propose optimizations for the overhead identified in the corresponding subsections in 3.1.

The overhead of aspect-oriented program execution is caused by additional control flow using additional data structures. Furthermore, the overhead of the weaving process itself has to be considered, especially for languages that apply post-compile time weaving, like OT/J. One could argue that the execution time is more relevant because weaving is done only at an initial phase. Nevertheless, dynamic class loading blurs the border between these two phases. Thus the overhead of the weaving process can also be critical during program execution. Taking this consideration into account, we can classify the sources of overhead for the language OT/J by the following categories.

adds additional dynamic method lookup(s). This is necessary if the aspect lan- guage supports polymorphic method overriding also at the aspect side. Dynamic method dispatch is always expensive and should be avoided due to performance rea- sons, if possible. The identification of avoidable dynamic dispatch constitutes good potential for possible optimizations. The execution of aspectual code is subject to special conditions, which does not hold for method dispatch in general. Possible optimizations could exploit these conditions.

In the current OT/J implementation, the infrastructure necessary for team (as- pect) activation is added to every adapted base class.  Arrays for storing as- pect instances and methods to access these data structures (addTeam(Team) and removeTeam(Team)) are added to the corresponding class files. These methods are called by the de-/activation methods of the teams.

We propose to develop a specialized aspect dispatch mechanism working on the VM-internal activation infrastructures introduced in 3.2.1. On the bytecode-level, this mechanism can be addressed via a new bytecode instruction (invokeaspect). Thus, the current wrapper-based approach can be refined. Furthermore, we plan to introduce a special (non-dynamic) method lookup calling the original base method during execution of replacing aspect functionality (base calls).  This is possible

Roles of a team implicitly inherit from roles with the same name in a super team. This inheritance relationship is no normal type inheritance and is only valid in the context of a surrounding team instance. We plan to add a reference to the implicit super role for role classes in the VM, analogously to the super class reference stored in class structures, avoiding code copying and additional interfaces.

The selected VM implementation had to fullfill a set of criteria: availability (open- source), extensibility, performance, target architectures and compatibility to the existing OT/J. We have selected the JamVM [1] for implementing our optimizations. It supports the full JVM specification version 2, although it is extremely small and applicable for embedded devices. For example, the JamVM has been ported to iPAQ 3950 and Neo1973. The JamVM is implemented in C, with a small amount of platform dependent assembler code.

Other candidates we considered were the KVM [3] and the phoneME [2] VM. In contrast to the JamVM, both only support Java ME. The KVM does not seem to be maintained during the last time. phoneME features a JIT compiler, but this

In a first step, we have moved the team registration mechanism to the VM- level. The data structure representing a class inside the JamVM was extended by a reference to the newly introduced registration data structure. In contrast to the previous weaving strategy of OT/J, now every class has this structure. Initially, this causes a very small overhead (20 bytes on x86 architecture), and only if a class is actually adapted by an aspect (team) advanced initialization and memory allocation take place.

As before, an interface for adding and removing team instances to a base class is needed. Additional functionality to access the array of active team instances is necessary because the remaining aspect execution mechanism resides at bytecode- level at this stage of optimization. We were able to integrate this functionality into the interface of the JamVM very conveniently. The JamVM provides internal implementation of Java mechanisms like class loading and reflection. At the Java- side, a class with native method declarations serves as interface. Calls to internal native methods are not executed via JNI (Java Native Interface), but directly im- plemented in the VM code. This approach was transfered to the team registration mechanism. Finally, we have adapted the weaving strategy of the OTRE to use the new VM-internal mechanism.

With our experiments, we have shown that the time efficiency of aspect activa- tion can be improved significantly. By implementing also the other optimizations that we have proposed in Section 3.2, we expect to further improve the execution of aspect-oriented embedded applications.

As embedded software grows significantly, it becomes more and more important to apply software engineering methods in this area. In this paper, we have proposed optimizations of the aspect execution mechanism on the VM-level aiming for an applicability of AOP for embedded mobile devices. Our first results show a consid- erable performance gain for the aspect activation mechanism of OT/J. So far, the presented benchmarks did not involve actual aspect execution. In future work, we plan to implement more optimizations, particularly an aspect dispatch mechanism working on the VM-internal activation infrastructures, and to measure and to evalu- ate the overall benefit. We also plan to investigate hybrid approaches that combine compile-time and run-time weaving, e.g. by weaving large code dynamically and small code statically.

This work has been funded by the German Science Foundation (DFG) under the Emmy Noether Grant No. GL 360/1-2. We also thank our student Magdalena Luniak for her assistance regarding the implementation of the optimization and the analysis of the measurement.

