With the advent and widespread use of embedded systems, which are ubiquitous reactive computing systems ranging from simple home appliances to very complex applications in avionics and defense, the need for formal methods in the design of reactive systems is growing. One very common approach to verification of reac- tive systems has been model checking. A model checker takes a formula in some temporal logic [14] as a desirable property and performs formal analysis over a finite- state model of a system (called a Kripke structure [3], a special class of finite state machines). The model checking process is essentially an automated reachability analysis task over the finite state model of the system. This task either terminates with a proof that the temporal property holds over the model or on failure generates a counter example.

An open system maintains an ongoing interaction with its environment. Hence, the state-space of such a system may be partitioned into a set of states that are open (also called external or environment states) and another set of states that are closed (also called internal or system states) [8,9]. An environment state reacts to events in the external environment of the open system and the environment is considered asynchronous and uncontrollable. A system state, on the other hand, takes no inputs from the external environment and the system automatically chooses one of the transitions based on some internal decision (such as say the value of a variable or the result returned by a function). Kupferman et al. have recently shown that model checking may not be enough for open systems due to the presence of environment states and when branching formulas are considered in the specification [9]. The proposed technique, called module checking, takes the asynchronous environment into account while doing a proof for branching-time logics. [6,5] further discuss techniques devoted to issues concerning verification of open systems.

We have developed a local module checker by extending NuSMV [2]. Local module checking has been compared with the generation of the maximal envi- ronment under which the given CTL property is satisfied to demonstrate the performance gain of the proposed approach. The benchmarks are examples from NuSMV with both environment and system states.

In contrast to model checking where all transitions in every state of the model are always enabled, module checking is specifically directed for verification of models of open systems with states where the environment decides which transitions are enabled. Typically, in models of open systems, modules in short, the states are partitioned into two sets Ss and Se where Ss consists of system states with all outgoing transitions enabled while Se is the set of environment-controlled states where some (at least one) transitions are enabled. Note that, the environment can enable one or more transitions but cannot disable all transitions.

It is important to note here that the above is not an implementation of global module checking. Global module checking advocates the need to check if the given property is satisfied by the module under all environments. However, the above approach constructs only a single environment under which the given CTL property is satisfied by the module. However, unlike the local module checker which attempts to generate a small witness, the algorithm for global module checking constructs the biggest environment under which the module satisfies the given property. This is done by enabling all but those transitions in reachable environment states which may lead to the dissatisfaction of the given property. It was observed that on the average, computing the maximal environment under which the original CTL property is satisfied consumes more time than computing a small witness under which it fails.

Note that for many modules, the original property and its negation were both satisfied under different environments. A majority of models had multiple start states. In these cases, the local module checker (and the maximal witness generater) was executed on each start state. Models with dense transition relations such as dme1 and syncarb5 took significantly more time. Models with relatively sparse transitions relations such as abp4 and idle took lesser time even though they had a higher number of reachable states. The local module checker took slightly longer when the original CTL formula was satisfied by the module (abp4, pqueue, periodic).

