A particular class of MDA processes which can be merged with a BDD approach is agile MDA processes [14] which applies agile principles (e.g. testing first, imme- diate execution) into a classical MDA process. For such processes models act just like code.

In section 2 we present the general context for BDD and MDD. The third and fourth sections present the proposed UML profile and library, and Section 5 de- scribes our development tool. In section 6 we discuss related work, while the last section contains conclusions and future works.

Moreover, we restrict our investigations only to the structural and behavioural constructs defined by the fUML specification. fUML structural constructs do not include components, composite structures, and collaborations, while the behavioural constructs do not include interactions and state machines. In this context the system structure is defined using packages, classes, properties, associations, and operations, while the system behaviour is defined through activities.

As the MDA guide indicates, starting from a PIM, code may be generated to- wards different target platforms. The generated code is meant to be complete, with no code placeholders for the developer to fill out. Generating the structure of classes is straightforward. However, generating code for the behavior of the operations is more complex, because the structure of the elements and the way the actions are

Scenario description. The stereotypes given, when, and then can be used for describing scenarios and can be applied to any fUML action. The same stereotype can be applied multiple times but only respecting this order: given, when, and then. The description process can be made by any user (customers, analysts, or developer) before scenario implementation.

representing the null value, and handling properties that have 0..1 or 0..* multiplic- ities represent the most difficult tasks for creating the then part of the scenarios. TestIdentityAction must be used in order to test if two values are identical objects, but this action constrains the multiplicity of the input pins to be 1..1. So, when we

test a property having a multiplicity 0..1 we must perform first a test for null using the ListSize primitive function from fUML and then call the TestIdentityAction. Another difficult and repetitive task is to test if a value belongs to a list of val-

Implementing scenarios using this infrastructure is possible but it is a tedious task. Moreover, if we do not keep a good nesting of actions using structured ac- tivities, we could not perform model-to-text transformations towards structured programming languages (e.g. Java). The next section presents our agile solution for easy creation of fUML scenarios.

A model corresponding to an iteration may be also split into several models which correspond to the developers who accept the stories. Dividing the initial model into fragments by iterations and developers is also helpful when the users perform change management operations. Having a model which contains the ac- cepted stories of a given user within the current iteration, helps the user to execute only his/her stories in order to make estimates related to the amount of work done or which must be done.

does, bUML automatically manages the story and scenario status. When a scenario is executed then the verdict is automatically set to the model scenario. Moreover, given a story, when all scenarios pass then the story status is automatically changed to completed. As a result, when users open the project artifacts, they see the status of the project progress automatically updated after the last scenario execution.

To the best of our knowledge, no other existing works combine BDD and MDD approaches. As we have shown in Section 3 and 4, our approach for constructing fUML models is close to easyb [6], a platform specific BDD framework. There are a lot of other BDD platform specific frameworks (e.g. [8], [30]), but all represent the same concepts presented in Section 2.

