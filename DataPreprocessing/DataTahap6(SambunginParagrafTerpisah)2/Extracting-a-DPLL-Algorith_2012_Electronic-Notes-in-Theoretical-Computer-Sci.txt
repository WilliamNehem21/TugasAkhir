We formalize a completeness proof for the DPLL proof system and extract a DPLL SAT solver from it. When applied to a propositional formula in conjunctive normal form the program produces either a satisfying assignment or a DPLL derivation which shows that it is unsatisfiable. We use non-computational quantifiers to remove redundant computational content from the extracted program and improve its performance. The formalization is carried out in the Minlog system.

Program extraction aims at producing formally verified programs from a con- structive proof. An example of early work with program extraction is that done in the Nuprl system [10]. Examples of program extraction in Minlog can be found in [5,3]. Other mature interactive theorem provers that support program extraction are Coq [6], which is based on the calculus of inductive constructions, and Isabelle [22,21], a generic theorem prover with extensions for many logics. More recently, other interactive theorem provers based on dependent types [PM80], such as Agda

Significant work has also been performed in Isabelle with several decision pro- cedures having been verified and integrated into the system. The DPLL algorithm has been formalized in [16]. The automatic theorem prover Metis [23] was formally verified inside Isabelle and is now used to reconstruct proofs from faster external procedures such as the ones used in Sledgehammer [8].

The approaches [15,16] to formalizing a DPLL SAT-solver in both Coq and Isabelle involve explicitly stating the algorithm to be verified. In contrast, we prove a theorem that just states that each formula in CNF is either unsatisfiable or has a model, and synthesise the program from the proof. In the long run we would like to integrate automatic verification techniques into Minlog. Extracting a SAT-solver in Minlog is one step towards our end goal.

The program extraction procedure respects the different kind of quantifiers by omit- ting in the nc case any information corresponding to the quantified variable. The proof rules for the nc-quantifiers are subject to stricter variable conditions ensuring that the omitted information is indeed not needed in the extracted program. Minlog is able to automatically detect the maximal set of occurrences of quantifiers in a proof that can be made non-computational without compromising the correctness of the proof [24].

In order to apply the solver practically we need to translate the extracted Minlog term into a functional programming language such as Scheme or Haskell. Currently a translation mechanism from Minlog into Scheme is available, however it does not extract inductive definitions and general recursion. We would like to extend this translation to cover these definitions. Having our DPLL solver as a Haskell program would allow us to observe how lazy evaluation affects performance.

