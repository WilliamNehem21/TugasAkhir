For new implementations of an architecture, applications usually have to be recompiled for peakperformance. An Independent Software Vendor (ISV) will more likely recompile an application, if it is cost efficient. It is cost efficient, if the system, the compiler and the source base are reliable and recompilation consistently gives measurable performance gains. This paper describes efficient techniques to evaluate the source code and to validate the compiler during the usual software application test cycle. For the compiler, we additionally propose more aggressive self-validation methods. Our methods can be a step towards reducing the debugging overhead in the software development cycle and thus improve the cost efficiency and practicability of recompilations.

The rest of the paper is structured as follows: Section 2 gives a brief overview of the register stack engine (RSE) and speculation on Itanium. Section 3 de- scribes two common software glitches and how the compiler can detect them. Section 4 demonstrates that the compiler can employ self-checking or instru- mentation techniques to catch NaT (=Not A Thing) consumption faults [9] triggered by un-initialized registers or automatic variables. Section 5 presents examples for speculation and recovery code and shows how the compiler can help evaluating correctness of the speculation code and the generated recovery code. Section 6 presents the conclusions.

(2) when bar() tries to write to r33, because the caller foo() did not allocate the parameter register on the register stack. In both, pseudo assembly 2 and pseudo assembly 3 of Example 2, the result could be a NaT consumption fault if the NaT bit for r33 is set. This can happen again because the caller foo() did not allocate and define the corresponding parameter register. The compiler can avoid generating the code in pseudo assembly 1 by blocking instructions that define a parameter register from being scheduled across an alloc instruc- tion. However, there is nothing the compiler can do in the other cases. In case of pseudo assembly 2 or 3, there are three alternatives:

Obviously, the ultimate remedy for the situation in Example 2 would be to declare prototypes and provide a warning free port. An alternative is for the compiler to instrument the application so the software bug gets detected at evaluation time. This gives the programmer the opportunity to add the miss- ing parameter in the callee or clean up the dead parameter in the caller. In

On the Itanium architecture the compiler can allocate more data objects in registers. Thus the probability of exposing missing volatile declarations in the source code is higher than on other architectures. Missing volatile declarations are usually costly in terms of debugging time, and any method to detect them early should be helpful. According to the ANSI C standard a program has to declare an automatic variable as volatile if there is a use after a longjmp() of the variable that is defined on a path from a setjmp() call to any other call that could result in a longjmp() call [2].

Algorithm 1 is a context-insensitive algorithm that finds variables that may have to be declared as volatile in the source code. We note without proof that this is the best one can hope for: in general detecting variables that are to be declared as volatile is undecidable. The rationale for this is that a program could halt on a path from a setjmp() call to (one of) its corresponding longjmp() calls.

ture is more likely to expose bugs in poorly implemented software applications. Two examples for this are parameter mismatches and missing volatile declara- tions. In both cases, an Itanium compiler can help detecting these issues either at compile-time or at run-time. While the parameter mismatch issue in section

In this section we describe validation algorithms that a compiler can employ to prevent NaT consumption faults in generated code. It is especially useful in compiler that aggressively try to minimize the usage of NaT bits (NaT consumption). The first section gives post-pass algorithms to detect possible NaT consumption faults, which could potentially be introduced by optimizing compilers. The second section gives a generic stress-testing technique to force NaT consumption faults at run-time during the software test cycle. We note that the RSE does not clear the NaT bits for the registers on the register stackframe. When the generated code stores a stacked register before it gets defined, a NaT consumption fault could occur at run-time [9].

a register that could trigger a NaT consumption fault, Algorithm 2 inserts initialization code into the function entry blocks. This clears the NaT bit and prevents a potential NaT consumption fault at run-time. In any case, the NaT consumption fault prevention algorithm can be used in the compiler as a safety net. It can warn the compiler developer about that issue during compiler testing and it can insert the initialization code to guarantee program correctness, should it detect a potential NaT consumption fault.

The previous section discussed one specific instance when the compiler could introduce an un-initialized register that could cause a NaT consumption fault at run-time, and demonstrated how the compiler can safely catch and repair this situation. However, un-initialized registers could come also from un- initialized variables or bugs in aggressive compiler optimizations, like partial- redundancy elimination [13] [7] [14] and global code scheduling [5] [3] [4]. In any case, the un-initialized registers can be detected and reported by Al- gorithm 2. But the result of the algorithm may be conservative in the sense that it reports un-initialized registers although they are not. One example for this are rotating registers in a software-pipelined loop [15] [4] that are defined in a previous rotation. In this case, Algorithm 2 may report such a register as un-initialized although it is not. To find the actual un-initialized registers, Algorithm 2 can be complimented or substituted by Algorithm 3, which in- struments compiled code in function entries so that every register used in the function has its NaT bit initially set. For NT applications and Linux kernels, the instrumentation code is a speculated load from address zero. For Linux applications, a speculated load from the kernel address space guarantees that the NaT bit for the target register is set.

We presented validation algorithms that detect at compile- or run-time po- tentially un-initialized registers that could cause a NaT consumption fault at run-time. Since the results of our compile-time algorithm can be conservative, it can be complimented or substituted by an instrumentation method that forces a set NaT bit for each register used in a function. Both methods can be employed in assembly or binary-rewriting tools as well. All methods in this section can be extended to workfor floating-point registers also.

speculation, the Itanium architecture provides an advanced load (ld.a) and two advanced load check (chk.a, ld.c) instructions for data speculation. This enables the code generator to schedule a load across a potentially aliasing store. In both cases, when the speculation was not successful, the check in- struction jumps to the recovery code, which re-executes the non-speculated load and its dependent instructions [9] [16]. Example 7 shows recovery code for both, control- and data speculation. From the validation point of view, two problems can arise: a) the compiler generates wrong recovery code or b) the compiler does not generate the (load) check instruction at all. Both missteps can result in hard to debug non-deterministic program behavior.

However, there could also be the case that the compiler erroneously did not generate the check instructions at all. In this case, the compiler could instrument the code to force a NaT consumption fault at run-time. One method to do this is to convert advanced loads to speculative loads from a canary address. A canary address guarantees that the speculative load will miss and the NaT bit for the target register of the speculative load will be set. On Windows or for Unix kernels, address zero can serve as the canary address. For Unix applications, a kernel address would do the same job. In this case, the compiler could reserve a special address register and load the canary address into it at function entry. Then every speculative load can be instrumented so it loads from the canary address and will fail. One caveat of this method is, however, that it does not workfor speculative post-increment loads. In this case, the compiler can split the speculative post-increment load into a regular load from a canary address and an address increment for the regular address.

We designed and implemented various compiler validation and evaluation methods. Some of the methods are generally applicable, but some are specific to the Itanium architecture. In section 3 we discussed source code evaluation techniques to find parameter mismatches at run-time and missing volatile declarations at compile-time. In section 4 we demonstrated compiler self- validation techniques, which safeguard generated code from NaT consumption faults. In section 5 we presented the forced branch and canary address method for stress-testing recovery code.

