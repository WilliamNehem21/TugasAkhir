We propose a new simple trace logic that can be used to specify local security properties, i.e. security properties that refer to a single participant of the protocol specification. Our technique allows a protocol designer to provide a formal specification of the desired security properties, and integrate it naturally into the design process of cryptographic protocols. Furthermore, the logic can be used for formal verification. We illustrate the utility of our technique by exposing new attacks on the well studied TMN protocol.

In this paper, on the other hand, we propose a logic that can be used to express local security properties, i.e. properties that refer to the specification of one agent, namely the agent which they belong to. As we show in the following sections, local security properties are expressive enough to assert the properties that are commonly desired for cryptographic protocols (e.g., freshness of a nonce.)

Plan of the paper. In Section 2, we describe our security protocol model. Then, in Section 3 we introduce our trace logic language. In Section 4, the TMN protocol is studied and some novel attacks upon it are presented. In Section 5 elaborates the related work and finally conclusions and future work are discussed in Section 6.

intruder can generate a term t using knowledge K. This procedure may involve instantiation of variables in t or K; for example, t may unify with a term in K, representing that t is already in K, i.e., is already known by the intruder (see [13] for details.)

We denote Vernam encryption by v(t1, t2) 6 . Here, keys R1 and R2 are sent from A and B to S, respectively. After Message 4 is received, A can obtain R2, thus making R2 the shared key between A and B.

The last step involves deciding where to put FveshR1 and FveshR2 in the server role. This is easy: we make the decision that the formulae for checking the freshness of the received values should be placed as soon as the values are received. Thus, FveshR1 can be put as F5, that is, after R1 is received. Similarly, we set FveshR2 as F7.

After receiving messages 1 and 3, the server can authenticate A and B, respectively, since (by assumption) secrets SA and SB are shared only between the server and the respective agents. To check if the protocol accomplishes the authentication goal of A and B to S, we translate this in a formula that states that if S received a message M apparently from A (resp. B), then it was really sent by A (B). Server S authenticates A after receiving the

As future work, we plan to apply the methodology to more complex case studies, such as multicast protocols e.g. LKH group communications protocol [20]. We also plan to study how to compose local security specifications: we believe this is a very important advantage of our approach over the other global ones.

