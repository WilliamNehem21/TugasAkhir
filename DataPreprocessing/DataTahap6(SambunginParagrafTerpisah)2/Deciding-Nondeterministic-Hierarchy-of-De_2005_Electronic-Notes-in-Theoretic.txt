The problem appears somewhat easier if the input automaton is deter- ministic. Deterministic tree languages form a proper, but effective, subclass of all recognizable tree languages (we can determinize an automaton in EX- PTIME [13], whenever possible). Computing the level in the deterministic hierarchy can be accomplished by reduction to an analogous problem for word automata [12], see Remark 2.4 below. Note however that the level of a deter- ministic language in a nondeterministic hierarchy can be arbitrarily smaller than in the deterministic one 5 .

Given a tree t in T (A), there is a unique run of A^ on t. This defines parts of the tree accepted by different strongly connected components (SCCs) of A^. We can have an automaton without acceptance conditions that calculates in each node the state of the unique run of A on t. The automaton we want to construct will be a product of this automaton and (1, 2) automata, one for each SCC of A^. The role of the latter automata will be to check if all paths of the run of A^ that stay forever in a given SCC are accepting. The composition of these automata will give us (1, 2) automaton recognizing T (A).

