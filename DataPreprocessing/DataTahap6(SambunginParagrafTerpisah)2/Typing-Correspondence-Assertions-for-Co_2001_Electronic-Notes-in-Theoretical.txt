We say a program is safe if it satisfies the intentions induced by the begin- and end-assertions. More precisely, a program is safe just if for every run of the program and for every label L, there is a distinct begin-event labelled L preceding every end-event labelled L. (We formalize this definition in Sec- tion 5.)

Example 1 uses one instance of the sender and one instance of the receiver to represent a single instance of the protocol. The restriction new(c); makes the channel c private to the sender and the receiver. This assembly is safe; its only run correctly implements the handshake protocol.

Our type and effect system is based on the idea of assigning types to names and effects to processes. A type describes what operations are allowed on a name, such as what messages may be communicated on a channel name. An effect describes the collection of labels of events the process may end while not itself beginning. We compute effects based on the intuition that end- events are accounted for by preceding begin-events; a begin-event is a credit while an end-event is a debit. According to this metaphor, the effect of a process is an upper bound on the debt a process may incur. If we can assign a process the empty effect, we know all of its end-events are accounted for by begin-events. Therefore, we know that the process is safe, that is, its correspondence assertions are true.

To see why our definition implies that a matching begin-event must precede each end-event in each trace of a safe process, suppose a safe process has a trace s, end L, t. By definition of traces, the process also has the shorter trace s, end L, which must be a correspondence, since it is a trace of a safe process. Therefore, the end-event end L is preceded by a matching begin-event in s.

We can now state the formal result of the paper, Theorem 5.2, that every effect-free process is safe. This gives us a compositional technique for verifying the safety of communications protocols. It follows from a subject reduction result, Theorem 5.1. The most difficult parts of the formal development to check in detail are the parts associated with the (Proc Cond) rule, because of

Gifford and Lucassen introduced type and effect systems [11,16] to man- age side-effects in functional programming. There is a substantial literature. Early work on concurrent languages includes systems by Nielson and Niel- son [19,20] and Talpin [24]. Recent applications of type and effect systems include memory management for high-level [26] and low-level [5] languages, race-condition avoidance [7], and access control [23].

A companion paper [9] begins the work of applying these ideas to crypto- graphic protocols as formalized in the spi-calculus of Abadi and Gordon [1], and has already proved useful in identifying known issues in published proto- cols. Our first type system for spi is specific to cryptographic protocols based on symmetric key cryptography. Instead of attaching latent effects to channel types, as in this paper, we attach them to a new type for nonces, to formalize a specific idiom for preventing replay attacks. Another avenue for future work is type inference algorithms.

