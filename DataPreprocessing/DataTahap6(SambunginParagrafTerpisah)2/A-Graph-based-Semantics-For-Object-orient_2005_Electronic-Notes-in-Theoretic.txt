Graphs can provide a model of computation if combined with graph rules, to form a graph transformation system. The theory of graph grammars (graph transformation systems with an initial graph) studies a variety of formalisms which expand the theory of formal languages, to encompass more general structures specified as graphs [5]. The algebraical approach to graph gram- mars, presented for the first time in [7] makes use of categorical constructs to define the relevant aspects of the model of computation provided by graphs grammars. That approach is currently known as double-pushout approach, because derivations are based on two pushout constructions in the category of graphs and total graph morphisms. The single-pushout approach [13], on the other hand, has derivations characterized as a pushout construction in the category of graphs and partial graph morphisms. It is a proper extension of the double-pushout approach [4] capable of dealing with addition and deletion of items in unknown contexts, which is an important feature for distributed systems. Graph grammars have been used to specify various kinds of software systems, where the graphs correspond to the states and the graph productions to the operations or transformations of such systems [6]. Concepts of parallel and distributed productions and derivations in the algebraic approach are very useful to model concurrent access, aspects of synchronization, and distributed

This paper is structured as follows: Section 2 presents the order relations used to express the inheritance relation on objects and overriding relation between methods. Section 3 shows how those relations can be combined into a graph structure to represent an object-oriented class structure, and how this construction gives rise to a category whose objects are object-oriented system specifications and whose morphisms are relations between them. Section 4 presents how the semantics of common features of object-oriented languages, namely extension by inheritance, object aggregation and system composition can be defined in terms of special colimits of the category defined in the previous section. Most of the proofs of Sections 2, 3 and 4 are omitted because of space limitations, but they are really straightforward, and the details can be easily checked. Finally, Section 5 draws some conclusions about the work developed herein.

The restrictions imposed to a strict ordered function are related to the mapping coherence between the strict ordered sets underlying relations. Spe- cifically, if an element is mapped then all elements from the chain to which it belongs (respecting the strict relation on its set) must also be mapped accord- ingly. It can be shown that the upper set of any element is indeed a (finite) chain, and therefore has both a least and a greatest element. This restriction is needed to assure that the strict relation structure is maintained when the sets are combined. Before showing how this combinations can be performed, however, some properties of strict ordered functions will be shown, together with the proof that strict ordered sets and strict ordered functions constitute a category.

Proof (sketch) Strict ordered sets and strict ordered functions are special kinds of, respectively, partially ordered sets and monotone functions. It can be easily shown that strict ordered functions are closed under composition, and that their composition is associative. Identities are build as in POSET.

Object-oriented systems consist of instances of previously defined classes which have an internal structure defined by attributes and communicate among themselves solely through message passing. That approach underlies the struc- ture of the graphs used to model those systems. Each graph node is a class identifier, hyperarcs departing from it correspond to its internal attributes, and messages addressed to it consist of the services it provides to the exterior (i.e., its methods). Notice that the restrictions put to the structure of the hyperarcs assure, as expected, that messages target and attributes belong to a single object.

The inheritance hierarchy is also portrayed, by imposing a strict relation (Definition 2.1) amongst the graph nodes. Hyperarcs also possess an order structure, which reflects the possibility of a derived object to redefine the methods inherited from their ancestors. This feature is used to define a formal semantics for dynamic binding based on graph computations [9], [10].

A class-model graph morphism is a restricted labelled hypergraph morph- ism. The restrictions are related to the mapping coherence regarding the order relations on nodes and edges. Specifically, if a vertex (or arc) is mapped then all elements from the chain to which it belongs regarding to the inheritance (or redefinition) relation in the first graph must also be mapped accordingly. This restriction is needed to assure that single inheritance is maintained when the structures are combined. Before showing how this combinations can be performed, however, the following result must be stated:

Software systems are generally built from previously constructed subsystems, which are later combined. The object-oriented paradigm favors that approach: existent objects can be aggregated or derived to form new ones. Composition is one of the most fundamental operations over systems, and it must be form- alized in such a way that its result is compatible with the way systems are in fact combined. Modularity plays a key role in software development, allowing a complete specification to be constructed from different pieces of specifica- tions. The need for integration tools is also a key issue in software development [16], since that task is considerably demanding in terms of effort if it is not automatized. Hence, specification formalisms should allow composition which can be performed systematically, guaranteeing a meaning for the operations in terms of the composed result. Composition of class-model graphs is described next.

The class-model graph morphism t from Definition 4.1 represents a map- ping between elements (objects, attributes or methods) which are considered to be the same in two different subsystems. It is fairly common, when pro- gramming a class, to make use of methods from objects defined elsewhere. It is not necessary to have knowledge of the complete specification of a class to use it as an attribute or to call on some of its methods. However, when the compiled files are linked together, the whole system must be fully specified. The morphism used to perform specifications composition plays the role of identify which elements are shared by both subsystems and which ones belong to just one of them. Since composition is given by a colimit, it is well defined and unique up to isomorphism.

Notice that in order to construct a class-model graph to perform specializ- ation through inheritance, there must be at least one node to which the new element must be connected (i.e., at least one primitive class). This particu- lar node must be connected to the primitive object (the one to be derived) on the existing class-model graph. The number of such objects on the con- structed hierarchy depends on the methods the derived object is intended to redefine: there must be as many objects on the node chain as there are ele- ments between the primitive object and the one to which the method to be redefined belongs. The coherent mapping is achieved by assuring that it is a strict ordered function.

The relation on the nodes is used to make the (single) inheritance relation among objects explicit. The relation on edges is used to model method redefin- ition (overriding) within derived classes. Class-model graphs are meant to re- flect more precisely the underlying structure of the object-oriented paradigm, and so improve the compactness and understandability of graph specifications. Our main motivation is to use graphs as a mean of object-oriented system specification that are easy to produce and maintain, and which can be under- stood by all participants in the software development process, even if they are not experts in formal methods. The way classes in an object-oriented system can be specified with class-model graphs resembles the way they are created in most programming languages, such as C++ or Java. This is useful, in the sense that translations from one language to another can be made directly, and programmers do not need to worry about how a class can be defined in

Class-model graphs were built to provide a typing structure for graphs modelling object-oriented systems and their computations. A first step into this direction was done in [9]. However, if this typing structure is meant to reflect the way object-oriented systems are programmed, the most common features of programming must be also explained within this framework. We have described how new objects can be created by aggregating already spe- cified objects as attributes or message parameters, or by extending an already existing object by inheritance. It was also shown how those constructions can be explained as colimits on the category CGraph of class-model graphs and their morphisms. Having the meaning of such constructions defined within category theory offers two major benefits: the first, and more obvious one, is that all knowledge available from research in category theory itself and in the specific categories of partial orders and graphs can be used; the second is that the results obtained, being colimits, are unique up to isomorphism, and can be defined without any ambiguity.

