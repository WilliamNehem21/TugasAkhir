First, the control code that implements the constraints is written manually in these approaches. Second, this code is not well-modularized as it is tangled with the functional code of the application and scattered across the imple- mentation of different components, which makes it non reusable. Third, the code that implements the constraints may not be conform to the formal spec- ification. This is accentuated especially by the scattering problem. Fourth, if the formal specification changes, it is necessary to change the code that implements the constraints manually.

The remainder of this paper is organized as follows. In Section 2, we intro- duce the Z specification language, Petri nets, and Aspect-Oriented Program- ming. In Section 3, we present our approach for controlling the architecture evolution of component-based applications. Section 4 describes our case study collaborative authoring system. Section 5 reports on some related work and section 6 concludes this paper.

The Z notation, as presented in [30], is a formal specification language. Z defines a mathematical language, a schema language, and a refinement theory between abstract data types. The mathematical language is based on the set theory and on mathematical logic i.e., first order predicate logic. The schema language allows to describe the state of a system and the manners according to which this state can change. The refinement theory allows to develop a system by building an abstract model from a system design.

A Z specification can be defined as a collection of state schemes and op- eration schemes. The state schema State describes the system state and the invariant relationships, which are maintained when the system is updated. This schema consists of two parts: a declaration part and a predicate part.

According the separation of concerns principle, AOP provides language means to separate the code implementing a crosscutting concern from the functional code of a software application. Using AOP, an application consists of two parts: The base program, which implements the core functionalities, and the aspects, which implement the crosscutting concerns. Aspects are new units of modularity, which aim at modularizing crosscutting concerns in complex systems by using join points, pointcuts, and advices.

Join points are well-defined points in the execution of a program. In As- pectJ [16], which is an aspect-oriented extension to Java, join points corre- spond to method calls, constructor calls, field read/write, etc. The pointcut allows to select a set of join points, where some crosscutting functionality should be executed.

The advice is a piece of code implementing a crosscutting functionality, which can be associated with a pointcut. The advice is executed whenever a join point in the set identified by the pointcut is reached. It may be executed before, after, or instead of the join point at hand; this corresponds respectively to the advice types before, after and around in AspectJ. With an around advice, the aspect can control the execution of the original join point: it can integrate the further execution of the intercepted join point in the middle of some other code (using proceed ).

architectural style (i.e. definition of component and architectural constraints) using the Z notation and model the coordination protocol using Petri nets. The base code implementation phase consists in implementing the functional code of the application using any Java-based component model. The aspect code implementation phase is the verification phase which allows the connec- tion between the formal specification and the application.

In our approach, we can define constraints in the architectural style and coordination protocol without modifying any functional code of the applica- tion. To do that, we just model a new Z specification and a new Petri net. In this way, we can provide a better control and a strong reuse of code. Using as- pects in our approach allows us to separate the control and coordination code from the functional code of the application, which reduces the complexity of distributed applications, and bridges the gap between the application imple- mentation and its formal specification. Moreover, if the formal specification changes, a few well-defined modules need to be changed in a non invasive way, namely the aspects.

System Specification : The system specification consists in defining the types of components, the types of relations between components, and the ar- chitectural properties specified in terms of first-order predicates. The system structure is specified using the following Z schema. Ci , Rij define respectively the component and the relation between them, Cstri represents an architec- tural constraint. Each component defined in the system schema must be already specified using a Z schema and include the internal behavior bhri in terms of predicate logic.

To verify that our system does not contain any contradictions between the defined constraints, we should verify the system consistency by ensuring that at least one valid state exists [32]. This verification is specified by the following consistency theorem. SystemInit corresponds to a Z schema which describes a valid state of the system. In order to validate and reason about the architectural style, we use the tool Z/EVES [20], which supports syntax and type checking as well as theorem proving.

In this section, we explain how the collaborative authoring application is built according to our three-phase approach. The authors can have two roles: the writer role can modify, create, and delete sections of a document, whereas the reviewer role can correct a section and add annotations to it. Problems such as overlaps between sections that are accessed by different actors cannot occur because appropriate constraints that hinder such problems are specified formally and enforced by appropriate control aspects.

Our collaborative authoring application is implemented as a Client/Server application. The functional level comprises only code providing the core func- tionalities such as editing, i.e., access control to the shared documents and control of the architecture evolution is out of scope. For instance, in this phase two writers can modify simultaneously the same section of a document.

Control module: The control module manages the evolution of the architec- ture since new users can connect and/or disconnect to the documents during the execution of the application. In the architectural style of our application, we specified a static constraint expressing that each client can modify one section only at a given point of time (constraint [C5] in the system schema). Therefore, an aspect is necessary to prohibit clients from locking more than one section simultaneously.

In addition, we have specified a dynamic constraint on the connection of a new writer. Before a new writer can connect, an aspect interprets the formal pre-conditions generated from the operation schema connectWriter and the style schema CollaborativeAuthoringSystem. This aspect defines a pointcut that selects all calls to the method ConnectWriter , which allows an actor to access the shared document as writer. The aspect uses an around advice to allow/disallow a new writer to connect.

In the following, we present a skeleton of an aspect which checks whether a section can be executed using the corresponding transition in the Petri net. The aspect SectionAccessControl defines a pointcut, which selects calls to the method ConnectWriter (lines 2 and 3 in Listing 1). The around advice of this aspect checks according to the XML representation of the Petri net if the transition ConnectWriter is enabled (line 7). If that is the case, the actor gets access to the document, i.e., the operation is executed (using proceed as shown in line 10) and the advice saves the new marking describing the new system state. If not, the aspect prohibits the execution of the method ConnectWriter (lines 13-16).

constraints (i.e. static aspect). However, they do not propose any formal solution to check if the architectural constraints specified in Z are preserved when the architecture evolves. In our approach, we can specify and prove the pre-condition theorem by using the Z/EVES theorem prover. Petri nets and colored Petri nets 5 were combined with different type of temporal logic [10,28] in order to define the architecture constraints and architecture evolution using temporal constraints and specify coordination constraints using Petri nets. However, Z, which is based on predicate logic and set theory allows a low-level description of architectural invariants. To support the temporal properties in our approach, we plan to combine linear temporal logic and Z notation.

The main contribution of this paper is the control of software architecture evolution in component-based applications in modular way using aspects. Our approach combines Aspect-Oriented Programming and formal methods and enables a reliable and modular verification. The reliability of our approach is ensured by the formal specification and validation of architectural constraints using Z and Petri nets. The use of an aspect-based control module in our approach, improves the modularity and the reusability of control code, as this code is well-modularized using aspects and separated from business logic.

As future work, we will study expressive pointcut languages such as [3,6,25], which allow the expression of temporal relationships in the point- cut to, e.g., express that a certain operation must be called before another. We will also investigate whether and to what extent the usage of such pointcut languages would replace the usage of Petri nets in our approach. We will also target automatic generation of control and coordination aspects.

