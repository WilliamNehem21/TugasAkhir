Current practice in software engineering employs object-oriented models as a description of the artifact to be constructed. This approach is useful, because models and diagrams based thereon allow abstraction of distracting detail and thus aid comprehension. [2] shows that design reuse is more effective and beneficial than code reuse. Like source code, models gain complexity in the course of development as detail is added. To allow free flow of ideas and breadth of approaches, innate integrity constraints of model systems must be weak. In defined software processes like UMLComponents [4] and Catalysis [7], such constraints often take the form of dependencies or mappings between stereotypical elements. Because CASE tools lack a standardized means of automation, such dependencies currently have to be enforced manually, which causes effort, increases cost, and makes processes error-prone.

In contrast to the QVT candidates, Prime is designed as an environment for transformations, with strong impetus on the tooling aspect (RR12). Adher- ence to design patterns and common terminology (RR05) aims to support implementers understanding of the environment. Syntaxes were designed to support adoption. Popular languages were chosen for OCLPrime as the refer- ence language implementation to lower the learning barrier.

Transformation takes the role of the AbstractExpression at the root of the meta-language. The three partial languages Validation, Query and Im- plementation are TerminalExpressions. In a simple, non-recursive scenario, the Transformation collaborates with them in the following way: It receives a Context from the client, which contains parameters that are passed on to the query (OR5). It invokes a Validation as pre-validation, hands model into a Query, transfers the selected model elements to the Implementation and in- vokes another Validation as post-validation on the target model. Afterwards, the target model either replaces the original model or a copy is placed in a different location to create a view (MR5)(OR6). In this case, the Client re- ceives a Uniform Resource Locator (URL) of the location, where the view was materialized.

Validation, Query and Implementation are implemented as services in ex- ternal components. They receive the Context, i.e. the invocation environ- ment, in the form of named primitive parameters, similar to Java Properties, but based on OCL Basic Types. Services may return feedback in any textual form, but Resource Description Framework (RDF) syntax [14] is preferred.

Queries are written in a query language (MR1). They receive a valid source model and provide variables that contain collections of model elements to the Transformation. To aid in optimizing queries, access path descriptions may be returned as feedback. OCLPrime implements Queries as OCL ex- pressions.

Implementations construct the output model. They are provided with a target model and a set of variables primed by a Query. Execution traces and operations performed on the repository may be returned as feedback. In OCLPrime, the construction language is SQL DML.

practitioners. OCLPrime, our reference implementation of a Transformation language, uses OCL as the query language (MR1). Although OCL is not widely used in the software industry today, it is easy to learn and pervasive in the context of UML. Users of a model Transformation language will likely be familiar with the semantics chapter of the UML standard, the meta-model and the purpose of OCL constraints contained therein. As implementation lan- guage the Data Manipulation Language (DML) part of the Structured Query Language (SQL) is used. SQL is well known in software engineering because of the spread of relational database management systems and it has a sound theoretic foundation [20] [15]. Both SQL and OCL are declarative languages (RR2)(MR6).

OCL Basic Values and Types are used to pass parameters to a transformation. As OCL basic types do not have upper bounds, implementations need to abort gracefully if an impedance mismatch occurs. Parameters have the namespace scope of the surrounding transformation. Parameters are read only and thus cannot be used to transfer values between transformations. transformations may use the declared parameters, but do not have to. Parameters may be left undefined when calling a transformation. If parameter values are provided by the client, their name may be defined by a regular expression to achieve multiple matches. This allows efficient parameterization of a larger number of transformations in the namespace scope.

Transformation is the root component of the hybrid language. Its definition is similar to that of transformations in the Common Warehouse Metamodel (CWM) Standard [16]. The following sections describe attributes, expressed in the type system XML DTDs, default values and correlating reserved para- meters. Care has been taken to ensure that values can be mapped to MOF and JMI.

Closure Some Transformations need to be repeated until every possible Trans- formation is applied. A closure marker with a depth value indicates this condition. If present, the closure Transformation will be repeated, until a Query cannot be completely satisfied. This happens if a variable defined by the Query does not contain a reference to any model element, or is invalid, in named locations. The location is a URI. If no location is defined, the Transformation manipulates the current model. If a location is defined but the resource does not exist, it copies the source model to the target model. If a resource does exist, the Transformation projects the changes into the existing target model. The target of the top-level Transformation may also be passed as a parameter via the reserved name target.

Because the JMI model repository only checks constraints derived from the class structure, additional constraints may need to be verified externally both before Transformation begins and after it has finished, as described in [29]. Such checks are defined as Validations and carried out by services called val- idators. A validator is provided with a model and an optional constraint description. The constraint description may be either a literal description or a resource described by a URI. A constraint description is supplied to

In our implementation of OCLPrime, both pre and postvalidation apply the UML Profile Validator. This specific validator expects a UML Model of a version between 1.1 and 1.5. To allow feedback to be delivered, the con- straint descriptor may be used to transfer the base URI of the profile used for validation. First, the process validates all built-in constraints of the meta model of that version for all model elements addressed. Then it extracts the profile constraints and validates them for all model elements stereotyped ac- cordingly. Feedback is provided in the form of RDF statements. The defective model is stored and the URI of that location is the basis for pointers to of- fending elements. The second element of the RDF triplet is a pointer to a description of the constraint which was violated, based on the URI received along with the constraint descriptor, the third element points to the location in the Transformation where the error occurred.

To allow structured reuse, a Transformation is made up of Steps. Each Step is declared either a package, a Rule or a Source. A package is the role-name of a Transformation, which contains another Transformation. This notion of package differs slightly from that in MOF, because Transformations are expressed as documents (ordered trees). Therefore, packages also have an order. This difference is aligned by assigning order attributes on the level of the metamodel.

Based on the package structure, Transformations can be seen as hierarch- ical transactions. Branch steps (packages) enclose leaf steps (Rules), which perform the actual work. Every Transformation creates a partial result. If the top-level Transformation closes, the whole manipulation will be commit- ted to the repository. If the Transformation is a closure, it will attempt to repeat the operation. The namespace also enables the use of Transformations as libraries.

Each component is described in terms of a class. In the case Web services, the class describes the URI where the service or its WSDL description resides. In the case of Java, it is the name of the class to be sought on the service class path, which can be handed to Prime as a parameter with the reserved name serviceClassPath or scp.

Query binds a query service and a compatible QueryExpression. The Query- Expression is embedded verbatim in the Query element. The service receives the expression and the source model and returns a dictionary of collections of model elements. The model elements are uniquely identifiable within the model by their MOF identifiers. A query service may raise an exception if the query cannot be processed.

In OCLPrime, an OCL Query Service performs the Query. By default, the Query is carried out by a local OCL 1.5 interpreter. Other versions may be explicitly invoked by parameterizing the service element. Although the Object Query Language [1] or SQL might be used as a query language, OCLPrime uses OCL Expressions. This application of OCL, the first usage scenario in [25], has also been adopted by three of eight submissions to the QVT RFP ([9]). OCL is well suited as a query language, as it is easy to understand and implement [11]. Reasonable use of formal features helps to avoid unexpected or undefined behavior: OCL is well-typed, declarative, and designed for object- oriented schemata. Also, using the same language for constraints and query expressions avoids the need for additional training and leads to a better chance of adoption. OCLPrime aims to support the different adopted versions of OCL, to allow users of the language to make use of the language quickly. Clarifications on the use of OCL in MOF vs. UML are compact [21], so practitioners should be able to use OCL in MOF context. In the course of the UML 2.0 alignment, these differences will likely be further reduced. The following paragraphs describe the different versions and how they can be used in the language context.

Implementation languages use the selection to either affect a model or create a report. The type system combined with these operations influences the choice and design of languages, because it defines the form in which selections of the model are available to the implementation language. We will discuss it in terms of the OCL type system in the next section. Building on that, we characterize stereotypical primary operations of construction, removal, and change of elements, along with the secondary operation of report generation. Finally, language choices for the realization of these operations are discussed shortly.

Bags have to be turned into a Set to serve as an association feature of an ob- ject. Most model manipulation languages, like our SQL dialect, will follow this norm. Bags should be avoided, because the aforementioned behavior introduces an implicit type cast.

A transformation language has four operational uses: Element Construc- tion and Removal, Feature Change and Report on Model Elements. The primary operations work within the domain of models on MOF-Classifiers, secondary operations project from a model into other languages. During ex- ecution of a primary operation the target model can temporarily be left in a state where constraints are unsatisfied due to insertion, deletion or change of elements. This relaxation is useful if information like a MOF ID only becomes available after several steps. It is possible because JMI allows to defer the constraint check.

Element Removal deletes instances of a MOF-classifier. Instances are des- ignated by type-compliant collections. Removal of elements does not cas- cade to other elements in the repository. Inconsistencies with a metamodel introduced in this way must be addressed explicitly. Element removal can take place in Update Transformations only.

OCLPrime does not address generation of software artifacts that are not models, like source code and documentation. However, a number of com- ponents for generative programming [5] that are based on JMI and XMI, are now publicly available and could be reused in Prime. Also, the emergence of RDF as a general standard for semantic information opens up interesting perspective for documentation and reasoning on models. For example, aspects of the model rendered in RDF could be examined with query languages like RDQL[19] to check higher-level properties.

Because Action Semantics define a full-featured programming language, they could be used to encode the behavior of the implementation part. They could also be applied to describe the semantics of the language as proposed by [24]. However, at the current time, no checker or interpreter for UML action semantics is publicly available. Thus, neither practical nor theoretic proof can be given on the correctness of such mappings. For these reasons, the use of action semantics in the project context is deferred.

In the dimensions of [9] OCLPrime can be characterized as a hybrid unidirec- tional language with selective, declarative queries, driven by a single input model to produce multiple output. This position is quite far from the ideal, which the recommended capability spaces of the report describe. Although we agree that these capabilities would be a desirable target for the development of the standard, we see the attainable goal and best starting point in the area where OCLPrime is located.

Because collaboration and distribution are so important to EVE, these properties are propagated to the design of Prime. For example, parameter passing between Client and interpreter is modeled as documents, because asynchronous calling conventions are useful in web applications. Services are described by general metadata to allow late binding. All resources are meant to be loaded from or stored in, distributed servers. Even if Prime is used without EVE, these properties can still be useful in local operation.

