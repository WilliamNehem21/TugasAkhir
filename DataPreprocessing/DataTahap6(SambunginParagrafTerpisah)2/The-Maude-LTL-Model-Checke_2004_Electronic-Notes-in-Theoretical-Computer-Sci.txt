The Maude LTL model checker supports on-the-fly explicit-state model checking of concurrent systems expressed as rewrite theories with performance comparable to that of current tools of that kind, such as SPIN. This greatly expands the range of applications amenable to model checking analysis. Besides traditional areas well supported by current tools, such as hardware and communication protocols, many new applications in areas such as rewriting logic models of cell biology, or next- generation reflective distributed systems can be easily specified and model checked with our tool.

Furthermore, the Maude LTL checker can model check systems whose states involve data in data types of infinite cardinality, such as numbers, lists, or multisets of arbitrary size; in fact, in any algebraic data types. The only assumption is that the set of states reachable from a given initial state is fi- nite. This finitary reachability condition can be dropped in the case of the semidecidable search for counterexamples for safety properties of infinite-state systems supported in Maude by its search command (this capability is not discussed in this paper, due to space limitations).

The paper is organized as follows. The semantics of linear temporal logic for an arbitrary rewrite theory R is explained in Section 2. The functionality of the LTL model checker is described in Section 3, and the satisfiability and tautology checker in Section 4. The algorithms and implementation are then described in Section 5. Performance comparisons with SPIN are given in Section 6. Conclusions are drawn in Section 7.

defining the syntax of the state predicates we wish to use by means of con- stants and operators of sort Prop, a subsort of the sort Formula (i.e., LTL formulas) in the module MODEL-CHECKER; we can define parameterless state predicates as constants of sort Prop, and parameterized state predicates by operators from the sorts of their parameters to the Prop sort.

and by semantic rules where a UserStatement not in LoopingUserStatement always terminates, but a LoopingUserStatement may not terminate. The code of process 2 is entirely symmetric. The Maude specification of the se- mantics of a simple parallel language supporting the above features is given in Appendix A. The two processes are defined in a module DEKKER that imports the module PARALLEL defining the semantics of the parallel language.

C. An SCC C is alive if it is fair or if there is a arc from C to an alive SCC; otherwise C is dead. Dead SCCs and any arcs entering them can trivially be eliminated. Fairness information can be deleted from all arcs not lying within a fair SCC.

SPIN uses a high-level language called PROMELA [10] to specify systems descriptions. We compare the performance of the model checkers as follows. Given a system specified in PROMELA, we specify it in Maude, and then compare, for a given model checking problem, the running times as well as memory consumptions of SPIN and of the Maude LTL model checker on the respective specifications. The results of such a comparison are given below.

Except where stated, the default settings for SPIN were used everywhere. In all the above situations, only properties satisfied by the corresponding sys- tems were model checked; no generation of counterexamples was attempted. The reason for this choice is that, since the two different model checkers im- plement two different search strategies, which model checker generates a coun- terexample first may vary from case to case depending on the particular search strategy of each tool, rather than on the speed of the model checker itself, which is what we are trying to estimate. A property that actually does hold for the specification forces the exploration of the entire synchronous product search space, resulting in more meaningful benchmarks.

1.13 GHz Pentium III machine with 384MB RAM running Red Hat Linux 7.3. In most of the cases, both model checkers finished fairly quickly whenever memory was available; lack of memory proved to be the main bottleneck for scalability in both cases. In all cases, the memory benchmark refers to the total memory footprint of the program, including the memory occupied by the code.

