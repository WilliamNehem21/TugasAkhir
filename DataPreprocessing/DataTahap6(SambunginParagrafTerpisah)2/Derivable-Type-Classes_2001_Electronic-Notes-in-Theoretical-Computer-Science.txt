Generic programming allows you to write a function once, and use it many times at different types. A lot of good foundational work on generic programming has been done. The goal of this paper is to propose a practical way of supporting generic programming within the Haskell language, without radically changing the language or its type system. The key idea is to present generic programming as a richer language in which to write default method definitions in a class declaration.

we would, as remarked earlier, just get an infinite loop. We have to provide some real code somewhere! What we want is a richer language in which to write default methods. That is what we turn our attention to now.

We describe these instance declarations for generic representation types as generic instance declarations. They are not written explicitly by the pro- grammer, but instead are derived by the compiler from a class declaration that has generic default methods. We discuss generic instance declarations further in Section 4.3.

Let us return briefly to the first step above. In the case of showBin it was fairly simple to convert the argument to its generic representation type. On the other hand readBin was a bit more complicated because it returned a pair, only one component of which had to be converted. How, in general, does the compiler perform this conversion? We devote the whole of Section 5 to this topic. First, though, we elaborate on the programmer-visible aspects of our

Haskell allows the programmer to assign labels to the components of a constructor, and these, too, are needed by read and show . For the purpose of presentation, however, we choose to ignore field names. In fact, they can be handled completely analogously to constructor names.

We will deal only with single-parameter type classes, but see Section 9. We also assume, for notational clarity, that the type of method op is given simply by Op a. We can always introduce a type synonym to make this so 4 . Now suppose that the programmer writes the instance declaration

This definition is not proper Haskell; bimap should be thought of as a meta- function, evaluated at compile time, that returns a Haskell expression. It takes as arguments: a type (written in curly braces), and an environment Q mapping type variables to expressions. The syntax [a := ep-a ] means an environment that binds a to ep-a.

Our design makes do with just binary sum and product. Algebraic data types with many constructors, each of which has many fields, are encoded as nested uses of sum and product. The exact way in which the nesting is done is unimportant to our method. For example:

One may wonder about the efficiency of translating a user-defined data type into a generic form before operating on it, especially if everything is encoded with only binary sums and products. However, sufficiently vigorous inlining means that the generic data representations never exist at run-time (see Sec- tion 6.6). But, in fact, we might want to explore space-time trade-offs, by getting much more compact code in exchange for some data translation. Our design allows this trade-off to be made on a case-by-case basis.

How do we translate a method call op :: Op T ? We must create a C -dictionary for T if op is a method of class C . In the higher-order kinded situation, we may need to create a dictionary transformer to pass to op. Fortunately, it turns out that the now-standard machinery to construct the correct dictionary to pass can easily be extended to construct dictionary transformers too.

There seem to be two main shortcomings. Firstly, the details of implement- ing the generic default methods (representation types, bidirectional mapping functions, and so on) are undeniably subtle, which is often a bad sign. Sec- ondly, the technology to deal with constructor and field labels does not fit in as elegantly as we would wish.

