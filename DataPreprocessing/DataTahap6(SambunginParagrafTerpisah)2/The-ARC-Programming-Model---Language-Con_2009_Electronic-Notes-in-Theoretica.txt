A basic actor must implement the abstract interface of a role in order for the basic actor to acquire membership in the role. A role member actor is a basic actor with membership in one or more roles. A role actor is a coordination actor that enacts intra-role coordination within its set of role member actors. Multiple role actors may exist for each role. A role actor may also serve as a parameter to a coordination actor called a coordinator actor. A coordinator actor enacts inter- role coordination upon role member actors via its role actor parameters and avoids persistent knowledge of individual role member actors.

The coordination distributed to basic actors, role actors, and coordinator actors is examined in detail in this paper. We introduce the ARC programming model and the ARC Programming Language (ARC-PL), emphasizing the syntax and informal semantics of new language constructs designed to enable modular coordination in the ARC model. Section 2 discusses related work on coordination models. Sections 3, 4, and 5 discuss programming in the ARC model using several examples to introduce the syntax and semantics of language constructs designed to facilitate local coordination, intra-role coordination, and inter-role coordination, respectively. Section 6 concludes and discusses future work. The formal syntax of ARC-PL and its operational semantics are introduced in an appendix.

Coordination has been an active area of research for over two decades. A broad sur- vey [21] of coordination models and languages concluded that coordination models can be categorized as data-driven or control-driven. In data-driven models such as Linda [14] and its extensions, coordination tends to be endogenous and embedded within computational entities. In control-driven models, coordination tends to be exogenous and isolated from computational entities. Control-driven models such as ABT [4], ROAD [7], IWIM [3], and CoLaS [9] isolate coordination by considering functional entities as black boxes. Both IWIM and ABT address computation and coordination concerns in separate and independent levels. ABT treats both com- putation and coordination components as composable Abstract Behavior Types. Hybrid approaches such as tuple center [20] and ReSpecT [19] combine the data- driven and control-driven models.

Several coordination models address decentralization. TuCSoN [8] provides dis- tributed tuple centers, each with its own local coordination rules. CoLaS parti- tions a distributed system into multiple coordination groups, and each coordination group enacts an independent set of coordination policies. ROAD provides a recur- sive structure that composes fine-grained coordination groups into coarse-grained groups. LGI [25] provides a controller for every object in the system and therefore implements completely decentralized coordination. The ARC model differs from these models by separating intra-role coordination and inter-role coordination and logically distributing the responsibility for coordination based on roles.

We illustrate intra-role coordination in the ARC model by implementing a GUI selection list of items. Each list item is either selected or unselected. Selecting an item toggles the selection state of the item and deselects any previous selection in the list. Thus, the list may have either no selection or a single selection. The

The coordination policies enacted by role actors are state-based and may vary over time. The state of a role actor is composed of the local variables defined in the associated role construct and the dynamic set of role member actors coordinated by the role actor. A ListItem role actor uses its local variable selection to identify the role member Item actor that is the current selection within the selection list. The coordination enacted by a ListItem role actor is based upon the value of the current list selection.

Role actors are hybrid actors with capabilities of both basic actors and meta actors. As a basic actor, a role actor may exchange join and exit messages with role member actors. As a meta actor, a role actor is able to react to meta-level messages, called events, that involve itself or the role member actors currently coordinated by the role actor. A role actor begins execution in the start state defined in the associated role construct. After processing a constructor message in the start state, the behavior of a role actor transitions to an implicit event-processing loop where events are processed serially and to completion. Events may be triggered for a role actor in three scenarios.

The parameters in the focus message signature are initialized from the values trans- mitted in the message and are available as local variables when reacting to the event. Events may be constrained by specifying an optional Boolean condition based on local variables. If the Boolean condition for an event is omitted, the default condi- tion if (true) is assumed. Only messages that satisfy the Boolean condition will trigger events. A message that triggers a receive event is discarded from the mailbox of the focus actor after triggering the event and is therefore never dispatched and processed by the focus actor.

For example, the dispatch { item.toggle(); selection.toggle(); } statement used in the first alternative of the ListItem event [item <- toggle()] atomically toggles the two Item role member actors indicated by item and selection. The atomic action results in a new list selection, since the actor indicated by selection is deselected after dispatching the toggle message it is sent, and the actor indicated by item is selected after dispatching the toggle message it is sent. The ListItem role actor therefore updates its local selection variable upon completion of the dispatch statement.

The capability to send messages via the dispatch statement distinguishes ARC coordination actors from constructs (e.g. the synchronizer) that coordinate only existing messages sent by basic actors. The tension between the capability to send messages and the separation of computation and coordination is tempered by en- suring that coordination actors send messages only to role members in reaction to events. A coordination actor does not initiate arbitrary computation.

Since role membership is acquired and released via explicit message exchange be- tween a basic actor and a role actor, basic actor behaviors must be aware of roles, and ARC-PL must ensure that role membership is processed atomically. Role mem- bership capabilities are integrated into the EFSM of a basic actor behavior via the designated join and exit messages discussed above. Like other messages, the join and exit messages are dispatched only in states that define inputs for the messages. A basic actor is implicitly locked and sensitized to a role actor immediately after the basic actor sends a join or exit message to the role actor, effectively suspending the basic actor (after any further processing of the current input) until the join or exit reply message is received from the role actor.

A basic actor may be a member of multiple roles simultaneously. A behavior has conflicting role memberships if the behavior permits multiple role memberships and two or more of the roles define a receive event with the same focus message. An ARC-PL static semantic check disallows behaviors with conflicting role mem- berships. Role conflicts must be resolved by defining a composite role in which overlapping events defined by the conflicting roles are appropriately unified. The decision to disallow conflicting role memberships is motivated by the fact that the trigger condition for a receive event may depend on variables local to individual role actors. Without conflicting roles, a message will be processed by the basic actor that received the message if a receive event is not triggered at a role actor. If conflicting roles are allowed, an event may be triggered at one role actor but not at a second role actor, resulting in an undesirable scenario in which the first role actor assumes the received message is not processed by the basic actor, while the second role actor assumes the received message is processed by the basic actor.

The coordination enacted by coordinator actors often includes the sending and atomic dispatch of actor messages. However, scalability concerns dictate that co- ordinator actors not have persistent knowledge of individual role member actors. Instead, two queries with synchronous call/return semantics are implicitly exported by a coordinated role actor to its coordinator actor.

