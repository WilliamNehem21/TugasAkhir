We propose in this paper a way to measure the coverage of a Java test suite by considering the JML specification associed to the Java program under test. This approach is based on extracting a predicate- based graph from the JML method specifications. We then measure the coverage of this latter w.r.t. nodes of the graph that are visited by the test suite. In addition, we propose to check whether the test suite satisfies classical condition coverage criteria. We also introduce a tool, to be used as precompiler for Java, that is in charge of measuring and reporting the coverage according to these criteria.

The essence of testing consists in executing the system under test in order to find bugs [21]. Nevertheless, testing can not be a complete approach since exhaustive testing is not applicable; the validation engineer is often left with a test suite that did not detect any bug in the program. How can he/she be sure that the test suite that was run is relevant enough to be confident in the program? One solution is to evaluate the quality of the test suite.

Several works on test suite evaluation exist, such as exercising the test suite on mutations of a program. The most relevant technique is to measure the coverage of the test suite. Usually, the coverage is measured on the control-flow graph of the program [21], or on the data-flow of the program [24]. In addition, a specification coverage can possibly be measured.

Model-based testing [2] consists in computing test suites from a model of the considered program or system. Model-based conformance testing consists in ensur- ing that the program does not have an unintended behavior w.r.t. its specification. This conformance can be observed through observation points or using a run-time assertion checking mechanism if the proximity of both the specification and the program makes it possible. In this context, the Java Modeling Language [16] (JML) has been introduced to act as a behavioral interface specification language (BISL) for Java programs. JML can be used as an oracle for testing, considering that if no JML assertion is ever violated during the program execution, then the test succeeds, otherwise, it fails.

The paper is organized as follows. Section 2 introduces the modeling possibilities provided by the Java Modeling Language. The first coverage criterion, based on the method specifications, is presented in Sect. 3. Section 4 is dedicated to the condition coverage definition. The principles of the measure and especially the implementation and the experiments are detailed in Sect. 5. Section 6 presents the related work, before concluding and providing a glimpse of the future work in Sect. 7.

The JML Runtime Assertion Checker (RAC) [5] has been developed to check the JML specification clauses when running the program. This tool, provided in the JML releases, acts as a precompiler which modifies the source of the program to add the following verifications on the JML model: (i) checking of the preconditions and the invariant when a method is entered, (ii) catching exceptions that may be thrown and checking of the exceptional postcondition related to the considered exception before throwing the exception again, (iii) checking of the normal postconditions if the method terminates normally. Notice that the invariant and history constraints are also checked during steps (ii) and (iii).

For practical reasons, all these rewritings are only applied on the positive pre- conditions of the method specification blocks. Indeed, the application of these rewritings on negations of the preconditions would lead to a combinatorial explo- sion of the number of cases. Nevertheless, it is possible to apply RW1 or RW2, which may be an indicator of whether the test suite tries to perform unauthorized actions, and the contexts these actions are tried to be activated.

The principle of checking the coverage of a JML specification is similar to the run- time checking of the assertions as performed in the RAC. It is presented as a pre- processing which enriches the original Java code with the verification of the JML predicates. In addition, we need to setup a Coverage Report Manager (CRM) ded- icated to the measures must be performed.

We have experimented our approach on a case study, adapted from an industrial example, named Demoney [19]. Demoney is an applet designed by Trusted Logics, implementing an electronic purse. For the experimental prupose, we have developed a simplified version of the implementation, which had been previously annotated with JML to describe its functional behavior. The classes of the application represent about 500 lines of JML spread in 4 classes.

First, we ran Jartege on the Demoney class. Since Jartege is a random testing tool, we were interested in evaluating the efficiency of such a tool. Its use shows the practicability of our approach, as well as an interesting feedback on the produced test suites. Indeed, the possibility to connect Jartege with jmlCoverage to help has appeared to be an interesting option. In this context, jmlCoverage can be used to limit the number of generated test cases, by generating tests until a user-defined specification coverage rate is reached. Second, we designed 5 testing schemas that Tobias unfolded in 162 test cases. The resulting abstract tests were concretized to a Java test program. We have been able to establish the overall coverage of our testing schema. Here again, our tool can be used to master the combinatorial

The results show that the cost of executing jmlCoverage is very little, regardless to executing the RAC. This is due to the fact that the RAC performs lot more checkings than jmlCoverage, since it systematically checks invariants and history constraints. But, the additional cost of using jmlCoverage on top of the RAC is minimal, even for larger test suites.

The JML Runtime Assertion Checker [5] is already able to report a partial coverage of a JML method specification, indicating if a precondition has been covered once, more than once, or never. Nevertheless, it does not present the same granularity as our approach and can not be considered as a relevant coverage measure tool. VDMTools [11] also adopt a DBC approach. They provide coverage tools which consider pre- and postconditions as ordinary statements and measure how much of the specification has been exercised. In other words, it provides an extended notion of statement coverage which is most of the time weaker than our measures. Works have also been led on the coverage measure of UML specifications [1], especially based on the structural coverage of statecharts diagrams. Simulink Stateflow [12] is also able to perform model coverage measurement on statecharts diagrams. A complementary view of test suite measurement is the code coverage measurement, that can be achieved with tools such as JCover [14], JCoverage [15], clover [7] or EMMA [10].

The approach we have proposed is inspired of both classical control-flow graph coverage criteria [21], and classical condition coverage criteria [22]. The novelty is the application of these criteria to a predicate-based graph extracted from a JML method specification. Moreover, the interest of using a specification coverage tool instead of a code coverage is that the specification makes it possible to express properties independently from a specific implementation, and thus, allows more specific measurements, based on a black-box view of the program.

