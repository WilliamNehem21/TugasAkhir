Communication protocols are notoriously difficult to get right. Not only do the usual challenges of distributed and concurrent programming apply, but they provide a service that other applications depend upon. Thus the performance of a protocol is critical to its success. For example, if a routing protocol fails to react quickly to changes in topology, the network can be brought to a standstill. Similarly, a reliable transport-layer protocol must be able to maintain a reasonable throughput, even when the network is congested. Because of this, it is vital to understand the performance characteristics of these protocols.

Stochastic extensions to existing formalisms in concurrency theory, such as pro- cess algebra, have considerably mitigated this last problem. In particular, the Per- formance Evaluation Process Algebra (PEPA) [10] is a high-level and compositional language, in which models describe continuous time Markov chains (CTMCs). This is arguably more intuitive, and less prone to error, than working directly with these mathematical structures.

Despite these advances, performance models are still very much removed from implementations. Work has been done to derive PEPA models from UML [3], but this is at a higher level than the implementation itself. In most cases, the model is validated empirically, by comparing its predictions to measurements taken from the real system (and refining the model if necessary). However, when the source code of the system is available, we can obtain a much more definite handle on what it means for a model to be correct. In this paper we present the first steps towards solving this problem, by describing an abstraction to a performance model, directly from source code.

In this paper, we begin by introducing the structure of the protocols we will be analysing, and the language of the source code we consider, in Section 2. We then briefly introduce the PEPA language in Section 3. In the following two sections (4 and 5 respectively), we describe how to construct a PEPA model first at the structural level (i.e. how to build a model of the system from models of the functions) and then at the functional level (i.e. how to build a model of a function from its source code). To illustrate this, we analyse a simple transport protocol in Section 6. We conclude with some comments on future work in Section 7.

In this paper, we will limit our analysis to that of end-to-end communication proto- cols. In other words, we will not consider hop-by-hop protocols, such as those used for routing, since representing the topology of such systems leads to an unmanage- able state space. We do, however, wish to deal with real protocols, and so we need to analyse real-world languages. In this case, that means C.

The restriction on conditions is quite a strict one. In particular, we can see that pro- cedures like exponential backoff do not satisfy this. We expect that this restriction can be relaxed somewhat (for example, allowing bit-shifting operations to access flags in a field of a packet), but that is the subject of future work.

Cooperation (P1 D P2): the components P1 and P2 synchronise over the cooper- ation set L. For activities whose type is not in L, the two components proceed independently. Otherwise, they must perform the activity together, at the rate of the slowest component. At most one of the components may be passive with respect to this action type.

There are many alternative formalisms that could be applied in this setting, but a Markovian approach has the advantage that it can be solved analytically. We choose CTMCs over discrete-time Markov chains, since we our execution model is at a higher level than that of a clocked processor. As we shall see, the states in the model correspond to basic blocks in the code, each having a different duration that is not deterministic (the processor may be pre-empted, etc.). Hence a continuous-time setting where we can attribute a rate seems most appropriate. Note that all choices in the model take some amount of time, since some condition must be evaluated, so we do not need zero-duration activities.

where i ranges over the abstract environment space of packets (i.e. it encodes an abstracted version of the packet contents), and j over that of the user interface (i.e. the API calls, and corresponding arguments, that the user can make). The states RecvX , UserCallX , and TimeoutX correspond to models of the corresponding functions on the client, whose construction is described in Section 5. Note that this implies a single-threaded client, since only one function can be called at a time. We can model multi-threaded clients by composing the functions in parallel.

Explicitly embed a model of the function. This is more general, and is ap- propriate when the function has a more complex behaviour that we wish to capture. The disadvantage is in remembering which environment we were in before calling the function, so that we can recover the correct state afterwards, which leads to an exponential blowup of state. We assume that such a call is synchronous.

Model the function as a separate process running in parallel, which synchronises over call and return actions. This separates the functionality of one function from another, at the expense of an exponential blowup of state when we do a Markovian analysis. We will use this abstraction when two components are communicating over the network, and the call is assumed to be asynchronous.

To allow us to represent a function by these states, we introduce two more atomic commands; goto and call. The first of these specifies a set of labels, L1,... , Ln, which determine the set of reachable states that may follow. The second encodes the assignment of a variable X to a function call g, followed by a continuation L. The syntax of commands is extended as follows:

We can now bring together the control-flow and data abstractions to build a PEPA model. In this model, each state identifies a (path, environment) pair. The rates depend on both the expected duration of a path (which is determined by basic block profiling), and the probability of moving from one environment to another. We describe this process more precisely as follows.

The top-level environment, ET , defines a rectilinear volume in n-dimensional space (where n is the number of basis vectors). Hence we are computing the probability of a set of linear conditions holding in this volume. To compute these probabilities generally, we apply a dart-throwing Monte Carlo method. The basic approach here is to take a sample of points from the environment defined by ES, and evaluate the compound condition (left hand side of the conditional probability) for each of them. The proportion of points for which the condition evaluates to true gives an estimate of the probability of the condition being true over the population.

When we return from a function, it is the caller that needs to specify the abstract en- vironment of the return value. We represent this calling context as a triple (R, l,X) of an interval space R, an index l into that space, and a variable X to update. R = Ri is the environment from which the function was called, and the callee eval- uates the probability of moving to other states in R when it returns. Note that

Use functional rates [11]. Here we only have one model of the function, in parallel with that of the caller, and the rates are expressed as a function of the state of the caller. To model this, we introduce an additional component, recording the calling context, which can be passively set by the caller, and queried by the function. We can think of this component as an oracle, allowing the correct probabilities of environment change to be represented in the model.

In this paper, we presented an abstract interpretation from source code to a perfor- mance model. There is still much work to be done in formalising this with respect to the errors involved, and it seems that a proper formulation in the context of abstract interpretation [5] would be appropriate. By this, we refer to the static component of the abstraction, which maps to a domain of labelled probabilistic automata. In- corporating the empirically derived rates, SR, takes us to a PEPA model. Note that this is different to the probabilistic abstract interpretation of [19,16], which is denotational rather than state-based.

Furthermore, we have not considered the size of the models that can be gener- ated. Whilst we cannot avoid the state space explosion problem if we remain in a Markovian setting, there are many existing simplification techniques [4,6,15] to re- duce the size of the models. One promising approach that we are currently pursuing is the use of stochastic bounds [8] at the level of a PEPA model, to compositionally construct upper and lower lumpable bounding matrices for the model.

Whilst this work is still in its early stages, the abstraction techniques we have considered seem to be feasible, and future work looks to be promising. This is certainly a tool that is needed, and would be widely appreciated by both the software engineering and performance evaluation communities. Although there are many challenges yet to be faced, we have taken the first few steps, and look forward to continuing along this path.

