An event algebra is used to define the complex triggering conditions. This algebra has a relatively simple declarative semantics and well documented algebraic properties, which facilitates formal and informal reasoning about the system. The algebra also ensures that detection of triggering conditions can be efficiently implemented with limited resources, which is critical in embedded applications.

The alternative outlined in this paper is to provide detection of complex event patterns as a part of the component model. Complex triggering condi- tions are specified on a high level, with well-defined formal semantics, which supports formal analysis at design-time when the access to component source code is limited. At compile-time, code that detects the specified situations is automatically generated.

The rest of the paper is organised as follows: Section 2 surveys related work and Section 3 gives an overview of SaveCCM. A description of the proposed extension, including an informal introduction to the event algebra, is given in Section 4. In Section 5 the event algebra is presented more formally, and we outline how the properties of this particular algebra impact on the extended component model. Finally, Section 6 concludes the paper.

Koala [14] is a component technology developed and used internally by Philips. Component binding flexibility can be achieved with switches, as in SaveCCM. Switches choose between interfaces offered by different components at run time, with possible static reduction at compile-time. ROBOCOP [5] is a continuation to enhance the Koala model with, e.g., support for real-time constrains and analysis.

PECOS [15] is a collaborative project between ABB and academia, with the aim to develop a technology adjusted for field-devices. Pecos support dif- ferent trigger-types associated with components; they can be of passive, active or event-type. Passive components do not have their own execution thread, and have to be triggered by other types of components. Active components have their own thread that is periodically triggered. Event components are components that are triggered by an external event and have a thread of control.

Outside the domain of component-based architecture, event detection mech- anisms of various kinds are used in a wide range of areas. For example, some large distributed systems have an architecture based on event subscribers and publishers. In such a system, rather than having subscribers register their interest in simple event types, and perform their own filtering and pattern de- tection, this functionality can be provided by the publisher. The subscribers register event patterns, specified for example in an event algebra. The pub- lisher performs the event detection and notifies the individual subscribers when their pattern is detected. Many systems of this type has been proposed, e.g., the READY event notification service by Gruber et al. that contains a simple event algebra for registering event patterns [9].

On a system level, execution can be triggered by clocks or external events. Then, the control propagates through the system according to the triggering port connections. A component is triggered once all of its input triggering ports have been activated. If more than one output triggering port is con- nected to the same input triggering port, this input port is activated as soon as one of the connected output ports are activated.

When a component is activated, it first reads from all its input ports and then performs the associated computation. Then, output is written to output ports, which includes activating all output triggering ports of the component. Finally, all input triggering ports are reset to a non-active state.

At compile time, the components are allocated to tasks in such a way that triggering conditions, precedence relations and component communica- tion are preserved. An analysis phase derives task properties from component attributes and from the system architecture, and performs further analysis based on these, e.g., response time and schedulability analysis. Finally, tar- get specific code is generated for each task, where calls to the component entry function are interleaved with code that handles data exchange between components within the task and with other tasks.

We propose an extension to the triggering mechanism that allows more elabo- rate triggering conditions to be specified. This functionality is provided in the form of an event algebra, i.e., a number of operators from which expressions can be constructed that represent complex triggering conditions.

First, we give an informal description of the algebra operators, and show how the event algebra is incorporated into SaveCCM. The formal semantics and a number of important properties of the algebra is discussed in Section 5. For a detailed description of the algebra, including implementation details, the reader is referred to [2] or [3].

Currently, the semantics of the event element is defined in terms of the original notation. The main motivation for this is that the extension can be included in the prototype tool with minimal effort. In the future, we intend to develop a more direct semantics for the event element, and handle them explicitly in the analysis and code generation phases to avoid unnecessary overhead.

We believe that the overhead introduced by the auxiliary components is reasonably low. They will typically be allocated at the end of existing tasks, and the component code can be inlined by the compiler since it is only accessed from a single point. Explicit handling of event elements in the code generation phase would remove the need for these auxiliary components.

An activation of an input port is characterised by the port name, occurrence time and the associated data. Formally, we represent each activation as a singleton set to allow uniform treatment of primitive and complex event in- stances. Together, all activations of a certain port during the system lifetime form an event stream.

The restriction policy is defined as a binary relation rem over event streams, where rem(S, S') means that S' is a valid restriction of S. For reasons of repeatability, it is typically desirable that an implementation of the algebra is deterministic. From a theoretical point of view, however, we prefer to leave as many detailed design decisions as possible open, and guarantee that any implementation which is consistent with the restriction policy relation have the properties described in the paper.

An argument for extending the component model with an event algebra is that it facilitates analysis on a system design level, compared to developing a new component for each triggering condition. The algebraic laws presented above can be used to rewrite expressions into a form that can be more efficiently detected, e.g., as illustrated by the transformation algorithm presented in earlier work [2]. From the component model point of view, we want to be able

Our ongoing work includes defining a more direct semantics for the event element, rather than defining it in terms of other architectural elements. The compile-time phases of the prototype tool should be modified accordingly, so that the event detection activities are implemented as efficiently as possible. Then, case studies should be carried out to evaluate the usefulness of the method and to identify possible improvements.

