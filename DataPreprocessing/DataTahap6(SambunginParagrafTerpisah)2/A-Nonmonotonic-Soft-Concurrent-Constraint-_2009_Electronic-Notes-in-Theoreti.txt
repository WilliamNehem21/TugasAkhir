We present an extension of the Soft Concurrent Constraint language that allows the nonmonotonic evolution of the constraint store. To accomplish this, we introduce some new operations: the retract(c) reduces the current store by c, the updateX (c) transactionally relaxes all the constraints of the store that deal with the variables in the set X, and then adds a constraint c; the nask(c) tests if c is not entailed by the store. We present this framework as a possible solution to the management of resources (e.g. web services and

The inspiration for this work comes from [9] and [11]: in [11] the authors present a nonmonotonic framework for Concurrent Constraint Programming (ccp) [20], to- gether with its semantics. Our nask and update operations (see Sec. 3) are the soft versions of those described in [11], while the atell, which adds a constraint only if it is consistent with the store, can be trivially modelled with the classical (valued) tell of sccp. A negative ask like our nask is described also in [19]. The idea for a fine-grained removal of constraints (the retract in Sec. 3) comes from [9], which describes a different nonmonotonic framework for ccp. Its main purpose was not to add any additional nondeterminism (besides the choice operator) by keeping track of the dependencies among constraints in the same parallel computation, otherwise the nonmonotonic evolution could yield different results if executed with different scheduling policies. However, in our language we decided to allow this kind of non- determinism, since we believe it is more natural to experience this behaviour during the negotiation interactions in open systems. Other examples of nonmonotonic evo- lution of the constraint store in ccp are presented in [13], and their line of research is usually called Linear Concurrent Constraint Programming.

while in classical sccp this is not possible: sccp being monotonic, since the consis- tency level of the store can only be decreased during the executions of the agents, it is only meaningful to prune those computations that decrease this level too much. On the other hand, in nmsccp there is the possibility to remove constraints from the store, and thus the level can be increased again (this leads to the absence of a fail agent). For this reason we claim the importance of checking also that the consistency level of the store will not exceed a given threshold.

Parallelism and nondeterminism: the composition operators + and  re- spectively model nondeterminism and parallelism. A parallel agent (rules R3 and R4) will succeed when both agents succeed. This operator is modelled in terms of interleaving (as in the classical ccp): each time, the agent A  B can execute only one between the initial enabled actions of A and B (R3); a parallel agent will succeed if all the composing agents succeed (R4). The nondeterministic rule R5 chooses one of the agents whose guard succeeds, and clearly gives rise to global nondeterminism.

Example 4.3 [Nask] In a negotiation scenario, the nask operation can be used for several purposes. Since it checks the absence of information (see Sec. 3), for example it can be used to check if the own policy is still implied by the store or

Nonmonotonicity has been extensively studied for crisp constraints in the so-called linear cc programming [17] and in following works as [1,9,11,16]. Regarding re- lated SLA negotiation models, the process calculus introduced in [12] is focused on controlling and coordinating distributed process interactions while respecting QoS parameters expressed as c-semiring values; however, the model does not cover nego- tiation. In [2] and [15] the authors define SLAs at a lower level of abstraction and their description is separated from their negotiation (while soft constraint systems cover both cases).

store. We have chosen to extend sccp because soft constraints [3,6] enhance the classical constraints in order to represent consistency levels, and to provide a way to express preferences, fuzziness, and uncertainty. We think that having preference values directly embedded in the language represents a valuable solution to manage SLA negotiation, particularly when a given QoS is associated with the resources. Soft constraints can be used to model different problems by only parameterizing the semiring structure.

