Injectivity is essential when studying the correctness of authentication protocols, because non- injective protocols may suffer from replay attacks. The standard ways of verifying injectivity either make use of a counting argument, which only seems to be applicable in a verification methodology based on model-checking, or draw conclusions on the basis of the details of the data-model used. We propose and study a property, the loop property, that can be syntactically verified and is sufficient to guarantee injectivity. Our result is generic in the sense that it holds for a wide range of security protocol models, and does not depend on the details of message contents or nonce freshness.

The introduction of a causal chain of messages from the initiator to the responder and back to the initiator seems to do the trick. We will call such a chain a loop. This property plays a key role in the discussion on injectivity below.

The class of security protocol semantics for which our result holds, is characterized by the closure of the set of execution traces under swapping of events. This class contains e.g. the process algebraic approach with the standard Dolev-Yao intruder model. Apart from this swap property, we will need no other assumptions on the data model and the intruder model. Since the loop property can easily be verified by means of static analysis of the security protocol description, we provide a practical syntactic criterion for verifying injectivity.

The achievement of this paper is that we have identified a general property that allows for a modular proof of injective synchronization: once non-injective synchronization has been proven, it is easy to prove injective synchronization. Interestingly, the property does not depend on the data model, and therefore does not rely on the properties of e.g. nonces, or functions that are applied to the nonces.

The remainder of this paper is structured as follows. In Section 2 we describe a formal model of security protocols and the underlying assumptions of our main result. In Section 3 we formalize injective authentication and the loop property and we prove their relation. Finally, in Section 4 we draw some conclusions and indicate options for future research.

Role events are all decorated with labels, typically l taken from the set Label . Each role event in a security protocol has a unique label, except for corre- sponding send and read events. We say that the send event sendl(r, r', m1) and read l(r, r', m2) match with sender r, receiver r'. (Note that we allow for the messages being different as, generally, the perspective of the sender and that of the receiver differ too.) The format of messages in RoleMess is left unspecified, as is the format of claims in Claim. Other types of role events may be present in RoleEvent as well.

The semantics of a security protocol is a set of traces. However, in order to deal with the possibility of several role definitions being executed by the same party, we first introduce some additional machinery. Let Agent be the set of agents. A role executed by an agent is called a run. Because each agent can execute multiple (possibly identical) instances of a role, we assume that a unique identifier rid from RunId has been assigned to each run. An event e with run identifier rid is denoted by e rid. This yields a set RunEvent of so-called run events:

Please note that the labels and run identifiers are not part of the messages, and are therefore not under control of the intruder. They represent informa- tion that is often left implicit in the semantical models. The label indicates the state of the agent when the event is executed, and the run identifier expresses in which run an event takes place.

In this section we define a syntactic criterion for authentication protocols, called the loop property, and show that it suffices to prove injectivity. First we define a strong authentication property, called synchronization. Second, we define the syntactic criterion and prove the main result.

The general definition of synchronization refers to a specific protocol p and a claim label. For simplicity of notation, we will assume in the following that there is a single protocol p having a single claim role event denoted by claim. However, note that multiple claim run events may occur in a trace. This is the case when the role carrying the claim has been assigned to various agents or more than once to the same agent.

Intuitively, these lemmas express that the events involved in a valid syn- chronization claim are independent of the other events in the trace. A valid synchronization can occur at any point in the trace, because it does not re- quire the involvement of other runs, or of the intruder. However, other events in the trace might depend on events involved in the synchronization. Thus we cannot shift the synchronizing events to the right; but we can shift them to the left, which ensures that any dependencies are not be broken.

We have shown that for a large class of security protocol models, injectivity of authentication protocols is easy to verify, once synchronization has been established. Until now, injectivity and authentication have been strongly con- nected. Our new results establish that it suffices to verify the non-injective variant of synchronization. Verifying injectivity is a simple and separate task, which does not depend on any specific (data) model.

We did not choose a specific security protocol model for this result. Instead, we have characterized a class of models in which the theorem holds. This class contains nearly all models found in the literature, such as the Strand Spaces model, Casper/FDR without time, and term rewrite systems [15,9,5]. These models share the following properties:

Almost all correct protocols satisfy NI -SYNCH as well as LOOP . It seems that LOOP is a necessary condition for injectivity. We know that this holds for the Dolev-Yao intruder model. However, for peculiar intruder models LOOP is not a necessary condition for injectivity.

