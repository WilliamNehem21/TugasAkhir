We predict the maximal number of rule applications, i.e. worst-case derivation lengths of computations, in rule-based constraint solver programs written in the CHR language. CHR are a committed-choice concurrent constraint logic program- ming language consisting of multi-headed guarded rules. The derivation lengths are derived from rankings used in termination proofs for the respective programs. We are especially interested in rankings that give us a good upper bound, we call such rankings tight. Based on test-runs with randomized data, we compare our predic- tions with empirical results by considering constraint solvers ranging from Boolean and terminological constraints to arc-consistency and path-consistency.

In [9], to prove termination of CHR programs, we use a ranking that maps head and body of each rule in a CHR program to natural numbers, such that the rank of the head is strictly larger than the rank of the body. Intuitively then, the rank of a query yields an upper bound on the number of rule applications (derivation steps), i.e. derivation lengths.

If a constraint matches the head of a rule, it is replaced by the body of the rule. If no rule matches a constraint, the constraint delays. For example, the query even(N) delays. The query even(0) reduces to true with the first rule. To the query even(s(N)) the second rule is applicable, the answer is N=s(M),even(M). The query even(s(0)) results in an inconsistency after application of the second rule, since 0=s(M) is inconsistent.

Related Work. To the best of our knowledge, there is no work in logic programming concerned with predicting derivation lengths for concrete pro- grams. Somewhat related is [4], where an instance of quantative observables is used to prove termination of probabilistic CCP programs based on finite average derivation lengths. In the context of transforming CCP programs, where derivation length corresponds to the number of procedure expansions (unfolding steps), this measure is used to compare the efficiency of transformed programs in [3].

Overview of the Paper. This paper is a revised and extended version of [8]. The main extension concerns the empirical results which are presented here for the first time. We will first give syntax and semantics for CHR. Then, we introduce rankings and show how they can be used to derive tight upper bounds for worst-case derivation lengths. The main, fourth section reviews various CHR constraint solver programs and gives rankings for them. Based on the rankings, derivation lengths are discussed and empirical results from randomized test-runs of the constraint solvers are presented and evaluated. We conclude with a discussion of the results obtained.

A constraint is a predicate (atomic formula) in first-order logic. We distin- guish between built-in (or predefined) constraints and CHR (or user-defined) constraints. Built-in constraints are those handled by a given constraint solver. CHR constraints are those defined by a CHR program.

where the rule has an optional name N followed by the symbol @. The multi- head H is a conjunction of CHR constraints. The optional guard G followed by the symbol | is a conjunction of built-in constraints. The body B is a conjunction of built-in and CHR constraints.

Definition 2.2 A state (or: goal) is a conjunction of built-in and CHR con- straints. An initial state (or: query) is an arbitrary state. In a final state (or: answer) either the built-in constraints are inconsistent or no derivation step is possible anymore.

In [9] we prove termination for CHR programs under any scheduling of rule applications (independent from the search and selection rule). Roughly, a CHR program can be proven to terminate if we can prove that in each rule, the rank of the head is strictly larger than the rank of the body. We rely on polynomial interpretations, where the rank of a term or atom is defined by a linear positive combination of the rankings of its arguments.

Theorem 3.4 [8] Given a CHR program P without propagation rules. If the ranking condition holds for each rule in P, then the worst-case derivation length DP for a bounded goal G in P is bounded by the rank of G. We write

We are interested in CHR rankings that get us as close as possible to the actual derivation lengths. This is the case if differences between the ranks of the heads and bodies of the rules in a program are bounded from above by a constant. We call such rankings tight.

Definition 3.5 Given a CHR ranking of a simplification rule H <=> G | B. The ranking is exact for the rule H <=> G | B iff rank(H) = rank(B)+ 1. The ranking is tight by n for the rule H <=> G | B iff rank(H)= rank(B)+ n, where n is a natural number. The ranking is tight by n for a CHR program P iff the ranking is tight by ni for all rules in P and n is the maximum of all ni.

It can be much smaller. For example, the goal and(U,V,W) delays, its deriva- tion length is zero. Another example is a goal that contains the constraint and(0,Y,1). If it is selected first, it will reduce to the inconsistent built-in constraint 1=0 in one derivation step. Because of the inconsistency, this is a final state of the derivation.

It will reduce to the constraint X=Y in 8 derivation steps. The Prolog predicate test/3 produces a chain of and constraints, where the last variable of one constraint is the first variable of the next constraint. The first (A) and the last (B) variable are returned.

The rank adds one to the length of the list in order to give a cardinality with the empty list a positive rank. For example, consider the goal #(0,0,[],0). Any of the three satisfaction rules can be applied to it and the derivation length will always be one.

The ranking is exact for the two recursive reduction rules, because of the order constraint implied by delete. It is tight by l only for the three satisfac- tion rules, since a cardinality constraint with arbitrary rank may be reduced to built-in constraints with rank 0 in one derivation step. Hence the solver program Card is tight by l.

Every rule application removes at least one primitive constraint and at most all of them from the set of primitive constraints R3 by intersecting it with R12. If the maximum number of primitive constraints is p, the ranking is tight by at most p. The actual tightness depends on the intersection behavior of the set of primitive constraints.

Assume we drop the rule add from the solver. Then the interval computations use only min and max, i.e. no new numbers can be computed for the interval bounds. Let there be n different numbers in the intervals of the goal. Then we can replace the maximal interval constraint rank w by the tighter n.

Terminological formalisms (aka description logics) [17] are used to represent the terminological knowledge of a particular problem domain on an abstract logical level. One starts with atomic concepts and roles, and then defines new concepts and their relationship in terms of existing concepts and roles. Con- cepts can be considered as unary relations similar to types. Roles correspond to binary relations over objects. In this paper, we use a natural language like syntax to help readers not familiar with the formalism.

