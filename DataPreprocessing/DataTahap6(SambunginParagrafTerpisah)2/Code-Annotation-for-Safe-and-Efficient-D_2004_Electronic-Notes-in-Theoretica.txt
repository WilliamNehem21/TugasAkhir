Unfortunately in the presence of dynamic loading, the static object resolution of even simple applications is often infeasible. Indeed, in most cases the information necessary for object resolution is only available at execution time when the contents of external methods are available. Running a simple escape analysis algorithm for the Java Grande Benchmark programs, it turned out that most of the candidates found for object resolution cannot be optimized at compile time due f.e. unknown constructors of created objects from different classes or the access to fields of arrays where the index is not known. Deferring the analysis until runtime, however, means that the CPU cycles spent performing the escape analysis are CPU cycles that are not spent executing the program. For this reason, it is beneficial to minimize the runtime cost of the escape analysis; this can be done by performing a partial escape analysis at compile-time and attaching the results as annotations to the individual program modules.

Null-checking and index-checking can be generalized to include all type-cast operations: an xupcast operation involves a dynamic check and will cause an ex- ception if it fails. In the case of success, it will copy the value being cast to the next available free register on the plane of the target type (only the dynamic check will result in actual code at the target machine, but not the copy operation). The downcast operation never fails and will never result in any actual target code.

where base-type identifies the static type of the receiver object, receiver desig- nates the register number of the actual receiver object on the corresponding plane, method is a symbolic reference to the method being invoked, and operand1 ... operandN designate register numbers on the respective planes corresponding to the parameter types of the method. The result will be deposited into the next available register on

In checkIntersect parameter p1 is assigned the type sbnd as the compile stat- ically can verify that that reference is safely bounded. In contrast, the reference to object produced by the new operator will be assigned type mbnd as it will be passed as an argument to the method intersects. In method intersects the parameter is assigned type mbnd as it will be given as an argument to method incDefBorder, but the parameter definition in method incDefBorder is assigned a sbnd type since the reference variable created from p1 is safely bounded to the method.

Because the method checkIntersect will be called during program execution and the JIT-Compiler has not already compiled this method, the classloader first will load class FrameCheck. Preliminary analysis of method checkIntersect reveals that the object referenced by variable lower could be a candidate for an object resolution since lower is of type mbnd. Checking if an object resolution on this object can be performed, the classloader will first load class FRect and verifies whether the parameter of intersects escapes the method. Since the parameter of intersects is not defined as a sbnd type, class FrameBorders has to be loaded and the analysis will proceed with the method incDefBorder. The sbnd parameter declaration of method incDefBorder indicates that the parameter does not escape its method. As a result the analyzer concludes that the parameter definition of method intersects also is safely bound and therefore can be transformed into a sbnd type. This means that an object reference that is passed to intersects cannot escape the method and hence an object resolution on the object accessible via variable lower can be performed.

Earliest investigations in escape analysis were done by Park and Goldberg[15], which developed an escape analysis for functional languages, which is based on reference lifetime, and operating on lists. In [18] Steensgaard has develops an in- terprocedural flow-insensitive points-to analysis with near-linear time-complexity. Whaley combines points-to and escape analysis into a points-to-escape graph, and uses this data structure in order to eliminate superfluous synchronization of thread- bound objects and to stack-allocate strongly-bounded objects [20]. Threads are also handled in [16], where Salcianu describes a technique for obtaining precise points-to and escape information for objects accessed by multiple threads. Vivien et al.[19] provide an algorithm for incremental pointer and alias analysis.

Code annotation for program representations have not been as thoroughly re- searched as escape analysis, but recently, various annotations have been proposed for enhancing the performance of JIT compilers using Java bytecode and other in- termediate representations[3]. Krintz et al.[13] annotates bytecode for increasing the performance of programs executed by JVMs. Franz et al.[8] annotate programs syntax trees with escape information and encode them for safe transportation. Both [13] and [8] guarantee the safety of their annotations. Hannan uses a functional approach for the annotation of escape information types in [10]. In contrast to our work, he excludes dynamic class loading and gives no algorithm for the computa- tion of types.

