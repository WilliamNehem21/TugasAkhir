Service-oriented Computing (SOC) [11,16] has now become the prominent paradigm for distributed computing and e-commerce, creating opportunities for service providers and application developers to use services as fundamental elements in their application development processes. It provides a mean to design Service-oriented Applications (SOAs) that span organizations and computing platforms by exploit- ing and composing services available over the network. Nowadays, an increasing number of companies and organizations implement only their core businesses and use other application services over the Internet to support their needs. Services are platform- and network-independent components that support rapid low-cost com- position of distributed applications and can be described, published, discovered, and loosely coupled in novel ways.

Object Access Protocol (SOAP) [20], which intend to provide languages that allow easy integration of services. Some other initiatives such as the Business Process Execution Language for Web Services (BPEL4WS or BPEL) [2], are focused on representing service compositions where flow of a process and bindings between services are known a priori. Despite all these efforts, composition of services still remains a highly complex task, and automatic composition of services is a critical problem. Conspicuously, the principles of component-based software development (CBSD) [18] are not yet integrated in the various methods that currently exist for custom composition of services.

Until now, most of the existing methods only describe how to communicate with a service (the syntax), but not the expected effects of such communications (the semantics). Therefore, the information that can be obtained from the service descriptions given in these approaches is limited to the signature of operations provided by the services. In particular, no information about the effect of invoking the operations can be obtained from the service descriptions.

The organization of this paper is as follows: Section 2 introduces the concepts of interfaces, contracts and services. Section 3 and Section 4 show how we can put contracts and services together to form more complex contracts and services. Rela- tionships between services, including bisimulation and bisimulation up to a natural transformation, are presented in Section 5. Section 6 investigates the refinement relations for contracts and services respectively. Section 7 presents a family of op- erators on composing services. Final remarks appear in Section 8.

In a service-oriented application, interfaces are used to model the seams between different services. A service encapsulates a number of operations through a public interface which provides limited access to the service. By declaring an interface, one can specify the desired behavior type of a service independent of its implementation.

Taking into account the nature of services, an interface should be comprised of three kinds of features: the type feature, the variable feature and the value feature. The type feature includes the information that is state-independent and gives the data context in which the service is placed. The variable feature denotes a family of variables and keeps the information that is state dependent. The value feature accounts for the observations and actions that the service may perform.

We first come to the notion of contracts. It is clear that for most services it is necessary to have developers working on different services simultaneously to reduce overall schedule time. To make developers work with a reasonable degree of independence, the services and interfaces should be identified and specified with no ambiguity. A contract is such a clear, unambiguous statement, which says precisely what the essential properties of the services (interfaces) are.

In the previous section we discussed interfaces, contracts as interface specifications, and single services as instantiations of contracts. One of the most important char- acterizations of SOC technology is the support for building complex applications by composition of services. Formal tools for this purpose can be borrowed from category theory, the idea is to put service units as coalgebras together to make applications, which are still coalgebras. Hence, we need to provide a notion of morphism between coalgebras of different functors (i.e. services with different in- terfaces) and build a category of these coalgebras. Before that, we first have a look at the interface morphisms and contract morphisms.

Often a service is specified via a collection of actions over a shared state space, each of which is specified by a contract and can be taken as an independent service. We can pack such different services together and get an aggregated service, which has an additive interface. Furthermore, its behavior is unique and already known from that of its component services.

In general, a refinement of contracts involves two contracts: an abstract one and a concrete one as its refinement. The idea involved in contract refinement is that the concrete contract adds implementation details which are left open in the abstract contract. For example, it can reduce the level of underspecification / nondetermin- ism.

In the case of large-scale applications consisting of many services, it is not prac- tical to consider the whole system each time we want to refine one of its services. On the contrary, we prefer to do the refinement steps locally for the particular ser- vice being considered. Fortunately, behavioural refinement is well behaved in this respect.

In this section, we move on to a brief introduction of service composition. Compo- sition enables prefabricated services to be reused by rearranging them in ever-new composites. Resulting composite services can be used as basic services in further compositions or offered as complete applications and solutions to service clients. Or- thogonal to the vertical refinement of concrete services from abstract specifications, composition operations are needed to support the horizontal decomposition of the applications into component services. That means, an application is represented by specifying its component services and their composition. By stating how services are composed together, we can get a view of the architecture of the application.

In this paper, we have shown how a formal framework for assisting service-oriented applications development can be defined around the notions of interface, contract, service and corresponding notions of morphisms. In such a formalism, services are described by coalgebras whose signature functors are derived from the corresponding interfaces, and satisfy the axioms given in corresponding contracts. This work pro- vides a unifying framework for different notions (interfaces, contracts and services) in SOA development.

With respect to the composition of services, we adopt the categorical approach which can be traced back to the work of Goguen et al[8]. Indeed, the category of services forms the cofibration over the corresponding category of interfaces, and thus provides the starting point for the definition of combinators for services. Preliminary work can be found in [13].

