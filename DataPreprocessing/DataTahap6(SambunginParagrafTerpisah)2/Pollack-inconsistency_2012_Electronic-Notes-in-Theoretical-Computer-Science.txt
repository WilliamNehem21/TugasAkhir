For interactive theorem provers a very desirable property is consistency : it should not be possible to prove false theorems. However, this is not enough: it also should not be possible to think that a theorem that actually is false has been proved. More precisely: the user should be able to know what it is that the interactive theorem prover is proving.

We argue that a good interactive theorem prover should be Pollack-consistent. We show with examples that many interactive theorem provers currently are not Pollack-consistent. Finally we describe a simple approach for making a system Pollack-consistent, which only consists of a small modification to the printing code of the system.

1 Thanks to Randy Pollack, Mark Adams and Christian Urban for the inspiration for this note. Thanks to James McKinna and Josef Urban for valuable advise. Thanks to Makarius Wenzel for the Isabelle examples from Section 4. Thanks to the anonymous referees for helpful comments.

computer science and from mathematics. The technology of interactive theorem proving gives an almost 100% chance of getting all of the details of a proof right. 2 It is much better in this respect than any other method of proof development. Fur- thermore, although the technology is still in its infancy, already impressive formal theories have been constructed [6,7,12,14,16].

These LCF kernels are sufficiently small that they can be inspected manually to get a very high confidence in their correctness. For example, the HOL Light kernel only has about 400 non-blank lines of code. For some of these systems the code of the kernel even has been formally proved correct [1,2,10].

These issues are closely related to a system not being able to parse what it printed itself. Often, a message from a system will contain a term or formula, that the user would like to copy/paste into the proof development. Generally this works, but regularly it does not. The system then gives error messages about its own output or sometimes, worse, will silently interpret it in a wrong way. This again is about the parsing and printing part of the system. A system that exhibits this behavior also might be called incorrect.

The first generally is a partial function (not all strings represent a term), while the second generally is total. Often there will be different variants of the printt function, possibly selected by setting parameters of the system. In the rest of the paper we only consider the default version of this function, the one that is used when running the system with all parameters having their default value.

The print functions in this definition should be the default print functions of the system. No printing of extra type annotations, hidden arguments, coercions, etc. should be turned on that normally is turned off. However custom notation is not excluded. This feature is such an ingrained part of most systems that excluding it does not make sense. We do not consider custom notation to be a deviation from the default printer, as well as a special form of definition.

1. The pretty-printer of the system does not realize that something strange is going on with these variable names. But when parsing these names, they of course will be read as the numbers 0 and 1. Again, we have strong Pollack-inconsistency here. By playing with variable names like this, one can make this example even more extreme:

The lines prefixed by > are the input processed by Isabelle, while the lines without that prefix are the output from the system. In the first example it is shown that Isabelle omits types in quantifiers in exactly the same way as HOL Light does. In the second example Isabelle proves a statement that reads False by changing the notation for True in the system.

The Mizar system [20,23] in a strict sense does not have a printing function. All it prints are error numbers associated with specific locations in the source files. Therefore the notion of Pollack-inconsistency does not apply to it. However, there is an interface for Mizar by Josef Urban, built on top of emacs [24,25]. This is installed by default with the system, and it does contain code to print Mizar formulas

The number 0 both has the types natural number and real number. The second definition of [x] hides the first, hence the value of [0] is 0. However, if one removes the type natural number using the qua construction, the second definition does not apply anymore, and the value becomes 1. Of course these numbers are different, and hence the theorem is accepted without error messages.

It is much easier to show that a system is Pollack-inconsistent than to show that it is Pollack-consistent. In the first case it is sufficient to exhibit an example of one or more Pollack-axioms that imply a contradiction, while in the second case one needs to prove a relationship between rather complicated parsing and printing functions. Generally for a serious system that will be quite difficult.

When discussing Pollack-inconsistency with users of interactive theorem provers, often they appear to consider it a non-issue. They agree that the printing function of their system sometimes can be a bit quirky and misleading, but then they argue that if it really is needed then one can turn on more information in the printing function. The fact that on the inside of the system everything is guaranteed to be meaningful seems to be sufficient for them.

The main task ahead of us is to convince the makers of interactive theorem provers that these issues are worth looking into. That is, to convince them to modify their parsing/printing functions to make their systems Pollack-consistent. Or at least to make these functions closer to being well-behaved than they are today.

