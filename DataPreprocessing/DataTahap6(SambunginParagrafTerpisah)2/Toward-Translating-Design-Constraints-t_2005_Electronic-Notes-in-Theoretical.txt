This translation approach may be contrasted with approaches that essen- tially embed an assertion language interpreter in the run-time environment. A translational approach is in some ways less powerful than the interpreter approach, because it can only support design assertion constructs that have fairly straightforward translations into an implementation assertion language. The benefit of simplicity is flexibility: It is relatively easy to modify transla- tion rules, possibly creating multiple variants, and creating a new binding to a different implementation language or a different assertion language is sim- pler than producing a new interpreter. The translation approach should be particularly appropriate for systems implemented in a mix of languages, like component-based systems.

The remainder of the paper is organized as follows: Section 2 illustrates the main ideas of the approach and some issues through application to a hypothetical system. Section 3 describes an initial prototype implementation which includes a customizable translator for OCL. Section 4 discusses the relation of our current work to related research in assertion systems, and particularly alternative approaches to supporting OCL. Section 5 concludes the paper.

Here a comment provides the link to the UML model and triggers a trans- lator that would insert assertions in (for example) the iContract assertion language [3]. We use this assertion system to exemplify the approach, but several other Java assertions languages would have helped in the same way. A slightly different solution would have been the use of assert statements of the Java programming language. The tradeoff is between flexibility and more special-purpose constructs. The direct use of the features offered by the lan- guage allows for flexibility, but lets the user free to state the assertions he/she prefers. A special-purpose assertion system better constraints what the user can do.

4 The obvious constraint that Off at must always be greater than On at is not the same as what stated here. The fact that the times in each row must increase moving left to right is quite obvious. Less obvious is that each leg of the trip obeys the constraints defined above.

As in programming language processors, there is no bright line separat- ing translation and interpretation. Interpreters usually involve at least some translation to an intermediate form, and translators usually depend at least partly on provision of run-time libraries. One can easily imagine solutions in which design constraints are partly translated, with library support filling the gaps between the design constraint language and the functionality provided by existing assertion languages.

Prior approaches to supporting OCL have thus far involved special-purpose interpreters. For example, [11] proposes a meta-model for OCL as the starting point for implementing an interpreter. A similar approach is taken by [2], which describes some experiences on interpreting OCL, and by [1], which proposes some efficient ways for executing complex OCL assertions.

