PeerCheck [1] is a lightweight library-based approach to implement symbolic execution over object-oriented languages without modifying the analyzed code. Unlike traditional symbolic execution engines, the symbolic semantics is built as an external library that runs together with the target program. They can accomplish this task thanks to special features of the python programming language which allows one to implement symbolic values with class objects. However, their approach is limited to symbolic execution on primitive types. In this work, we show an extension that enables one to perform symbolic execution with user-defined class objects. In addition, we build a new verification tool, called PEF, which implements the described technique, and our extension. This tool can be used to verify programs written in the Python programming language, and we developed in python on top of the Z3 SMT solver. We used the tool to verify its own code, showing its potential and usefulness to test programs in production. We also evaluate the tool for testing well known algorithms and data structures.

To solve these problems, PeerCheck [1] proposes a novel alternative. It intro- duces a peer architecture, where the symbolic execution engine works alongside the program. Rather than defining a new interpreter or compiler, it simply implements the symbolic execution engine as a library in the target language. The peer ar- chitecture exploits the capabilities provided by dynamic and pure object oriented languages. The idea is based mainly on their ability to dynamically dispatch primi- tive operators such as arithmetic operators, array accesses, conditional branch tests, etc.

However, the peer architecture has been criticized [14] since it only allows one to check programs implemented with primitive types. This paper shows that it is feasible to extend PeerCheck to handle user-defined class objects. The extension opens a new path to build verification tools with little effort and only restricted by the ability of the automated provers. Nonetheless, the power of these provers, like SMT solvers [7], is constantly advancing.

We present the technique applied to programs written in Python. Python is a pure object oriented language used to implement high level functionality over a wide variety of systems. However, achieving a high degree of coverage testing on Python programs has been recognized as a necessity due to the lack of static type checking in this language. Moreover, our methodology can by applied to other object oriented program languages.

In order to realize our approach, we implement the PEF (Python Error Finder) verification tool. The tool works as a proof of concept of the improved peer ar- chitecture technique mentioned above. It was developed by integrating the Z3 [6] SMT solver with our Python (version 3) code. The tool also implements a con- tract system for expressing pre and postconditions, program exceptions, and type restrictions.

The rest of the paper is organized as follows: In Section 2, we give an overview of the symbolic execution technique. Section 3 describes the PEF architecture and its subsystems. Section 4 presents the implemented contract system. Section 6 shows how the tool was used to verify its own code. Section 7 shows some results by applying the tool on well known algorithms and data structures. In Section 8, we discuss related work. Finally, Section 9 presents the conclusions and discusses

In step ii, if both path conditions are satisfiables, the method first chooses the THEN branch. Thus, the tree is generated in DFS order. In this case, the method arrive at a free branch, otherwise we say that is a forced branch.

If the program contains loops or recursive calls this technique can be generalized with the inconvenience that it can produce infinite trees. One solution, which ensures termination, is to limit the depth of the generated tree [10]. The solution is also useful when the size of the tree is large, to avoid scalability problems.

PEF follows the peer architecture proposed in [1]. The symbolic execution engine is implemented as a language library, which allows one its execution as a peer of the target program. This program is executed by the engine with special input arguments called proxy objects instead of concrete values. The proxy objects act as symbolic values for the symbolic execution technique.

It is a list of boolean values that point out the chosen path in a free branch node. The boolean _path[i] indicates the current branch choice (THEN or ELSE) for the ith free branch in a path. So, the symbolic execution engine uses this list to schedule each path of exploration. Also, the same list is used for the full analysis of the target program.

These variables are a means of communication between the subsystem and the proxy objects. This allows the subsystem to execute all DFS paths of the execution tree: PEF uses the information stored in _path to obtain the prefix of the new path to be explore. At beginning of each iteration (line 9), the list _pathcondition is emptied. Then, the postfix of false values in _path is removed (line 19), and the last true value is negated. This process allows one to explore the negative branches. When _path is empty (line 20) all the branches where explored, and the process ends. Moreover, branches are explored to some depth or until the prover cannot decide the satisfiability of the expressions involved. PEF informs the user about the branches that are ignored.

The symbolic execution process have to be modified to ensure termination (Sec- tion 2). This was done by bounding the scanning depth of the execution tree. The default limit was taken from [1], but can be easily changed if necessary. This value was in practice sufficient for our analyzed example programs. More information about these results will be presented in Section 7.

Object-oriented languages, such as Smalltalk, Ruby or Python, represent all data as objects. In addition, its operations are translated into method calls. The trans- lation is also performed on operations of primitive types such as +, >, ==, and, etc. Moreover, the type of the objects is defined only by the name of its attributes and methods, regardless of whether it is a primitive or user defined type. This prop- erty of languages is known as Duck Typing 4 . Our work is based on these features: PEF executes the target program replacing its arguments with proxy objects, which have the same methods and attributes names. Therefore, proxy objects simulate the behavior of real objects, while tracking the execution of the program.

We first describe the constructor method. The call to smt.fresh_var(int) (line 8) generates a fresh integer variable for the prover, thus creating a sym- bolic value. If an initialization value is passed, the constructor calls the method smt.make_symbolic(value) (line 10) which creates an integer constant instead. Besides, if the initialization value is already symbolic, it is stored unmodified.

Each time a conditional predicate contains proxy objects, the _ bool  class method is called by the Python interpreter to decide which path have to take. Therefore, the prover is consulted for the feasibility of the paths. It decides whether the formula stored in the BoolProxy object or its negation are satisfied along with the rest of the formulas in _pathcondition (line 16 to 20). If only one of these set of formulas is satisfied (i.e. the program execution arrives to a forced branch), the method returns the boolean value of the associated branch to the interpreter

If _path contains more values than the length of the path condition, the ex- ecution arrived at an already explored free branch. In this case, the method appends the formula or its negation to the path condition, according the cur- rent truth value of the branch stored in  path. Finally, it returns to the interpreter the boolean value associated with the branch to be executed in the current run (line 27 to 35).

When the function is called with a symbolic list ls, the symbolic execution generates three different path conditions: [len(ls)==0]; [len(ls)>0, ls[0]<0], and [len(ls)>0, !ls[0]<0] (line 2). In the first path PEF throw the IndexError exception since it cannot evaluate ls[0] in the condition. In the second path, the symbolic execution performs the list update (line 3). The last path corresponds to the else branch.

This else branch continues with a loop over the symbolic list (line 5). The first iteration is performed without branching since the path condition includes the constraint len(ls) > 0. In the following iterations, the symbolic execution branches a path: one path returns None, and the other continues in the loop. In

The list proxy objects implemented in PEF cannot store values of different types since Z3 arrays have this restriction. Furthermore, our current implementation only allows us to store symbolic or concrete integer values. Anyway, concrete lists can store concrete or symbolic values with different types, since in this case, it is not necessary to represent them in Z3.

In order to support all operations on lists, it was necessary to implement interme- diary slices. Slices are widely used since they allow the extraction of list segments, and they are widely used by Python programmers. For example, given the slice a:b, ls[a:b] is the sub-list from the position a (starting at 0) to the position b-1. The strings and lists have a similar implementation. Strings were represented in

From line 9, the result variable accumulates the possible instantiated proxy objects from the input class. For that matter, the loop (next line) operates over each possible list of types of constructor arguments (variable argTypesComb). For each type in this list, the function performs a recursive call returning a set of proxy objects for each argument in the input class. The variable argProxyObjs accumulates the received objects, which can also be some instances of primitive types or user-defined classes. Note that, these recursive calls end since user-defined classes are eventually implemented with built-in types.

The function then generates all possible combinations of the proxy objects re- turned by its recursive calls (line 16). Each combination will be a set of symbolic arguments for the constructor of the input class. These are stored in the variable argProxyObjCombinations.

In order to generate these proxy objects, the function symbolically executes the constructor of the input class ( line 19), obtaining a proxy object of this class for each execution path. The symbolic execution uses as arguments of the constructor each combination of the proxy objects stored in argProxyObjCombinations. The generated proxy objects are accumulated in the result variable, and returned as a result of the function.

It should be noted that this algorithm has a limitation: only variables declared inside the constructor are instantiated to proxy objects. Therefore, user-defined classes modifying class variables or global variables cannot be fully instantiated to proxy objects. This only limits the coverage of the symbolic execution algorithms, possibly ignoring some execution paths of the target program.

Throughout the development of PEF, we find some problems implementing the proxy objects methods. This was because a poor documentation of the built-in types or the complexity of the involved operation. Therefore, we decided to apply this tool on itself. The result is a real use-case applied on a software in production showing the potential of PEF.

The task was performed using the tool as a library (PEF can also be exe- cuted in command line interface). The program is available with the PEF code (implementation_test.py file). It performs the symbolic execution of the proxy object methods implemented by PEF. Then, the symbolic result of each path is compared with the result of built-in operations in Python. The task is fully auto- matically performed:

Given a class c, PEF explores the executions paths of its methods. For each method, PEF returns a set of tuples by performing symbolic execution. These tuples contain some input proxy objects, a symbolic result, a path condition, and a thrown exceptions if any (Section 3.1). Each tuple corresponds to an execution path.

With a path condition and a symbolic result, PEF can build a test case for the real(c) built-in method: it obtains a variable assignment that satisfies the path condition (obtains a model) by using the Z3 prover. This variable assignment is used as concrete arguments in the built-in method. Also, an expected concrete return value is obtained with the same assignment applied to the symbolic result.

The program runs the built-in method using the input arguments obtained in the previous step. If the built-in method and the execution of the path re- turn the same exception, the path is considered correct. If the built-in method returns the generated expected value, the path is also considered correct. Oth- erwise the path has an error.

We found several errors in PEF by using this program. For example, we have to read the C implementation of the function indices (used in the built-in slide class) in order to build the SlideProxy class. This code is part of the standard Python interpreter called CPython 6 . The misinterpretation of the code caused several errors in our implementation. Thanks to the program presented here we were able to detect them.

As we see, the number of explored paths is the factorial of the list length, as expected. The depth of the execution tree is the number of free branches. This number is lower since its growth is quadratic with respect to the size of the list. The last column shows that it is only necessary to execute QuickSort with lists containing three elements to achieve full coverage of the branches.

The only mature tool, oriented to Python language, known for the authors is Chef [2]. This tool performs symbolic execution on the target program and the interpreter at the same time. Therefore, the tool needs a great processing power, not available in personal computers.

Peer architecture [1] is a promising technique for analyzing programs through sym- bolic execution. The proposal is based on the fact that pure object oriented lan- guages can perform symbolic execution using its own defined objects as symbolic values. Therefore, the technique is implemented without modifying the program code neither the underlying interpreter or compiler.

Our work improves the technique by allowing the generation of symbolic values for user-defined class objects. This advance overcomes the problem described in [14]. The paper invalidates the technique since it only supports symbolic execution over primitive types. Therefore, the method was considered useless for real cases.

We also implement the technique building a tool called PEF (Python Error Finder). Thus, we apply the concepts of our work in order to automatically explore paths, and detect errors in Python programs. Besides, we implement a contract system which allows us to validate conditions and write restrictions over programs. These are written as noninvasive comments using Python conventions. The result is a proof of concept for the peer architecture including our extension. We show that this tool is powerful enough to verify its own code. PEF is available at https:

As future improvement of the technique we are interested in the implementation of symbolic global variables. Currently our tool only allows us to work with concrete values for these variables. Hence, there may be unexplored paths in the symbolic execution process.

