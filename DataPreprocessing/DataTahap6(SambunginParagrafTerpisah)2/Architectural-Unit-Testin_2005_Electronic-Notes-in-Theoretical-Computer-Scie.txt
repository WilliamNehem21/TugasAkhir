We recall that the syntax of transition labels of UML state diagrams con- sists of a triple event guard / action, where each of the three components may be absent 3 . Our style prescriptions so far amount to only use input operation names as events, whereas actions are output operation names. Furthermore, a limited form of guard is admitted, written [bCond], where bCond is just a literal for a boolean condition (thus a possibly negated name).

Finally, the semantics of output actions deserves attention; they model operation invoications on other server objects, but we deliberately disregard consideration of including the server object reference into the action itself. This is motivated by the inherently local character of architectural unit test- ing, whereas collaboration between objects is of concern to integration testing proper. As a preliminary hint to questions for further research, concurrent state diagrams, interaction diagrams and activity diagrams seem to be the appropriate models where collaboration between objects is to be specified, thus providing the appropriate basis for integration testing suites.

by a LTS, and is defined by a set of inference rules. In general, a LOTOS spec- ification describes a system using a process hierarchy. A process is an entity that may execute internal, unobservable actions, and may interact with other processes through its gates, or interaction points. Complex interactions be- tween processes are built up of elementary units of synchronization which are called events, or (atomic) interactions, or simply actions. A system consists of a set of interacting processes. The environment of a system may also be seen as an observer process, which could be a human, that is assumed to be always ready to observe any observable action at the system interface. Plenty of examples of analysis and verification of properties of LOTOS specifications can be found in the literature, such as [18,24,25], to mention but a few.

Practically, verification and test case generation are based on a possibly partial exploration of the LTS that describes the behaviour of the system un- der test. IOLTS semantics is somewhat different from LTS semantics because of the partitioning of the action alphabet into I/O and internal actions. This is circumvented, in our methodology as well as in IOLTS-based test gener- ation tools, by declaring the action partitioning outside the (Basic) LOTOS specification.

Test purposes enable tools to limit the specification graph exploration by taking a synchronous product of the specification with the test purpose, where specified actions that are not in the I/O alphabets of the test purpose IOLTS are considered as internal actions of the specification. By giving priority to test purpose actions, an effective pruning of the specification graph is obtained. This is explained in some more detail as follows.

IUT. Basically, the conformance relation is the ioco| relation described in [26]. Informally, the conformance relation states that a IUT I conforms to a speci- fication S, according to a set of traces  if, after every observable trace in , the outputs of I is included in the outputs of S. In our methodology,  is the subset of the traces of S that in the test purpose lead to an accepting state.

To use the TGV tool, the specification must be defined as a Binary Coded Graph (BCG), spec.bcg, or as a LOTOS specification, while the test purpose must be described as a BCG, say file tp.bcg, or in Aldebaran format, say file tp.aut [13,17].

According to the style prescriptions defined in section 2.2 for architectural state diagrams, we let every nonempty transition label consist of only one out of the three label components allowed by UML syntax, viz. event, guard, action, resp. corresponding to input, internal action, output.

Upon creation, a TrajectoryGen object is in the Idle state, waiting for new data and, in particular, new positions for the controlled robot(s). When it receives these data, the object moves to the Check state, to see whether the final position is within reach (TestPosition) and, if so, for the absence of obstacles and possible collisions (TestObstacle). If the verification succeeds, the object moves to the WaitGetT state, otherwise it goes back to Idle.

In the WaitGetT state the object waits for a getTrajectory input. When this occurs, the condition whether the position received is either a modification of a previous trajectory, or a new position used to generate a new trajectory, fires a transition, resp. to CompModT or to CompNewT. When the computation in either state terminates, the object moves to state TrajReady, where it outputs

If the presence of a new obstacle is signalled, the object moves to the Control state, where it checks whether a collision with the obstacle may occur ([collisionDetected]). If so, then the object goes to the Approach state, where the previous trajectory is modified, so that the robot approaches the obsta- cle without collisions. The new trajectory is output to the robot, and the trajectory generator goes to the Check state again, where the new trajectory is computed, to reach the final position from the newly reached point. When the new obstacle does not lie on the trajectory, the trajectory generator outputs the computed trajectory to the robot and moves back to Idle.

As mentioned above, this translation is not exactly a direct translation of the given state diagram because of a complaint by the Caesar compiler w.r.t. the translation of the composite state Check, with its outgoing transitions, using the Basic LOTOS disabling operator [>. It seems instructive, though, to report such a translation as well, that goes as follows.

A single experiment is no definite assessment, of course, yet no reason of principle seems to hamper feasibility of further experiments, e.g. other tools such as TorX [27] or Promela/SPIN [5] seem to deserve attention, perhaps to overcome certain drawbacks which have surfaced in our first experiment.

Further directions of this research relate to: 1) extension of the methodol- ogy to other architectural testing scopes, viz. integration and system testing, involving other kinds of UML models, particularly those provided by concur- rent state diagrams, interaction diagrams and activity diagrams; 2) investi- gation of relationships with testing at more advanced development phases, whereby models are built in a more prescriptive, possibly complete specifi- cation perspective; 3) on the formal side of the previous research direction, extension of the expressive means of testing models to cater for data, e.g. in the form of parameter passing in I/O operations, evaluation in internal actions, etc.

