The interpreter for a syntactic theory corresponding to its evaluation func- tion naturally consists of a decompose-contract-plug loop. Often, the only viable implementation of decomposition is a depth-first search in the abstract syntax tree. The decompose step therefore introduces a significant overhead, proportional to the program size. Likewise, plugging can also take time linear in the program size, although it always takes at most as long as the following decomposition, if there is one, and as illustrated below.

First, we can assume some properties of the grammar of the language. We are working with abstract syntax, i.e., a program is an abstract-syntax tree where each node is created by a production in the language grammar. Because the abstract syntax need not correspond to the concrete syntax, we can, without loss of generality, assume (1) that all productions are of the form

Some syntactic categories contain only values, e.g., the syntactic categories of literals. We assume that there are no evaluation contexts for those syntactic categories, since such evaluation contexts could never occur in a decomposition into context and redex anyway, and as such they are irrelevant to the semantics of a language. Likewise, there is no reason to distinguish between values and expressions, so we only represent the syntactic category by the term identifier and never by the associated value identifier.

Unique decomposition is so fundamental to syntactic theories for determin- istic languages that it is almost always the first property to be established. Its proof is often technically simple, but because of its many small cases, it tends to be tedious and error-prone. This state of affairs motivated Xiao, Sabry, and Ariola to develop an automated support for proving unique-decomposition properties [11].

If the syntactic theory satisfies a unique-decomposition property, then its redexes are exactly the non-value terms that can only be trivially decomposed. A decomposition, E[e] is trivial if either e is a value or E is the empty con- text. That redexes are exactly the non-value terms that can only be trivially decomposed follows from the following two inclusions.

Let e be a non-value term that can only be trivially decomposed. Then by unique decomposition e can be uniquely decomposed as E[r]. Since this decomposition must be trivial, and r is a redex and thus not a value, it follows that E = [ ] and thus e = r is itself a redex.

In their work on reasoning about programs in continuation-passing style (CPS), Sabry and Felleisen designed a new CPS transformation [8, Definition 5]. This CPS transformation integrates a notion of generalized reduction and thus yields very compact CPS programs [2]. It is also unusual in the sense that it builds on the notion of a syntactic theory, rather than on operational seman- tics [1,7] or denotational semantics [9]. Therefore, and unlike all the other formalized CPS transformations we are aware of, it is not defined by struc- tural induction over its input. Instead, it is defined as the transitive closure of decomposing, performing an elementary CPS transformation, and plugging. Therefore, its direct implementation incurs the same overhead as considered in Section 2. In the rest of this section, we derive an implementation that operates in linear time over the source program.

The original specification is indexed with 0 (Section 4.1). We first make decomposition and plugging explicit, indexing this specification with 1 (Sec- tion 4.2). Then, we present a version that explicitly uses a refocus function, indexing this specification with 2 (Section 4.3). Using the construction of

Olivier Danvy and Lasse R. Nielsen. Syntactic theories in practice. Technical Report BRICS RS-01-31, DAIMI, Department of Computer Science, University of Aarhus, Aarhus, Denmark, July 2001. Extended version of an article to appear in the informal proceedings of the Second International Workshop on Rule-Based Programming (RULE 2001), Firenze, Italy, September 4, 2001.

