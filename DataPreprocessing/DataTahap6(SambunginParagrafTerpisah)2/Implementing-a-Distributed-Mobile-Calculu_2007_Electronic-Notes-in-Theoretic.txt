Very often to assess the quality of the proposed new calculi the different research groups have also produced prototype implementations of the calculi that could be used as kernel programming languages for mobile distributed systems. Prompted by the growing number of experiments and from the need of easing the implementation phase, we have implemented a generic Java framework called IMC (Implementing Mobile Calculi ) that can be used as a kind of middleware for the implementation of different distributed calculi [3]. IMC aims at providing the necessary tools for implementing the run-time system of new languages directly derived from calculi for mobility. Our aim has been that of enabling the implementer of a new language to concentrate on the parts that are really specific of his/her system, and to rely on our framework for the recurrent standard mechanisms for distribution and mobility thus avoiding to deal with low-level details. Java has been chosen as the production language because it provides many useful features for building network applications with mobile code (indeed, many existing implementations of mobile and distributed systems are written in Java).

IMC provides means for transparent code mobility, for building communica- tion protocols by composing sub-components dynamically and for managing node topology. All these mechanisms are rendered as abstract as possible to ease, e.g., switching from a specific communication protocol to another, without modifying the other parts of an application. IMC can be straightforwardly used if no specific advanced feature is needed. A user can however customize parts of the framework by providing its own implementations for the interfaces used in the package. Cus- tomizations can take advantage of design patterns such as factory method, abstract factory, template method and strategy [10] that are used throughout the packages. The framework was designed to achieve both transparency and adaptability.

For instance, for code mobility, the framework provides all the basic functional- ities for making code mobility transparent to the programmer: all issues related to code marshalling and code dispatch are handled automatically by the classes of the framework. Its components are designed to deal with object marshalling, code migration, and dynamic loading of code. The framework can also be adapted to deal with many network topologies (flat, hierarchical, peer-to-peer networks, etc.) and with message dispatching and forwarding. To the best of our knowledge there are no others similar general frameworks available in the literature.

We now sketch the main functionalities and interfaces of the framework. For the sake of simplicity, we will not get into deep details. IMC consists of three main subpackages: protocols, mobility and topology that deal with communication protocols, code mobility and network topology, respectively. We present the IMC components in the order we suggest to use them when implementing a run-time system for a mobile calculus. The first thing the developer should think of is the implementation of the communication protocol; then he/she can implement the node functionalities by using the communication protocols. Finally, he can imple- ment the functionalities of processes that will rely on the features provided by the implementation of nodes. Of course, this is not a mandatory schema, but we found this path very useful when using IMC (see also Section 4).

The protocol states abstract away from the specific communication layers. This enables re-using of a protocol implementation independently from the underlying communication means: the same protocol can then be executed on a TCP socket, on UDP packets or even on streams attached to a file (e.g., to simulate a protocol execution). This abstraction is implemented by specialized streams: Marshaler (for writing) and UnMarshaler (for reading). These streams provide high-level and encoding-independent representations of information to be sent or received. They are basically an extension of standard DataOutput and DataInput Java streams, with the addition of means to send and receive mobile code (explained later) and serialize and deserialize objects.

A participant in a network is an instance of the class Node of the package topology. A node is also a container of running processes that can be thought of as the computational units. The framework provides all the means for a process to access the resources contained in a node and to migrate to other nodes. A process is an instance of a subclass of the class NodeProcess that implements the JavaMi- gratingCode base class (this allows to easily migrate a process to a remote site), and can be added to a node for execution with the method addProcess of the class Node. Thus, a node keeps track of all the processes that are currently in execution. A concurrent process is started by calling start on the NodeProcess thread; the final implementation of run will initialize the process structure (not detailed here) and then invoke execute, the abstract method in NodeProcess that must be implemented by the programmer. Actually, a process can interact with the node it is running on only through a NodeProxy, which ensures security by restricting the node interface visibility to a subset. If the class Node is extended by a derived class with new functionalities that we want to make available to the processes, we will also have to extend NodeProxy (Section 4.2 uses this technique). The framework already provides some implemented protocols to deal with ses- sions. The concept of session is logical, since it can then rely on a physical con- nection (e.g., TCP sockets) or on a connectionless communication layer (e.g., UDP packets). A SessionManager instance will keep track of all the sessions. This can be used to implement several network topology structures: a flat network where only one server manages connections and all the clients are at the same level; a hi- erarchical network where a client can be in turn a server and where the structure of the network can be a tree or, in general, an acyclic graph of nodes; or, a peer-to-peer

In this section we describe the protocol used by the participants of a JDpi network. First, messages exchanged by these participants are presented, hence the Protocol used by each network component is introduced. The implementation of this part of the framework is considerably simplified by the use of both mobility and protocol packages of IMC.

Channels are referenced using class JDpiChannelName<T> that enables the iden- tification of a channel used to exchange values of type T. The method out permits sending an object of type T over the channel referenced by c. Conversely, method in permits retrieving an object of type T from the channel referenced by c.

The method executeCommand simply invokes method execute on the command instance c with the proxy for the current node. A command is sent remotely using a JDpiSender. This is an object that sends a command over a given protocol stack (sender.send()) and then waits for the result (sender.getReply()).

Method getNodeStack permits retrieving the ProtocolStack (see Section 2) to interact with the node identified by l. Please notice that the node referenced by l might not be directly connected to the local one. In this case, the actual imple- mentation of JDpiAbstractNode has to choose (if it exists) a remote participant to use for communicating with l. Hence, every node could play also the role of intermediary in a communication. To define how a node behaves when a message (a JDpiCommand) for another node is received, abstract method forwardCommand has to be implemented. Finally, by implementing method start the programmer provides the initialization procedure for the node.

AcceptNodeCoordinator is an IMC specialized NodeCoordinator that continu- ously waits for incoming connections: when a new connection is established this will be handled by a thread executing the protocol created through the specified ProtocolFactory. In this case we create an instance of the protocol described above and compose it (through the specialized IMC protocol, ProtocolComposite) with an initial state, ReadLocalityState (not detailed here) that reads the locality of the connected node. Even in this case we use the protocol compositionality features of IMC. Basically, AcceptNodeCoordinator implements a recurrent programming pattern for implementing a multithreaded server, that can be customized by the

To model this kind of topology class JDpiFNode, which extends JDpiAbstract- Node, is introduced. A JDpiFNode can get connected to and accept connections from different nodes. Following the same interaction model proposed in DpiF, two nodes can interact if and only if they are directly connected. A JDpiFNode behaves exactly like a domain but for the fact that a JDpiFNode can host threads execution and can open outgoing connections.

behavior of the implemented process (the NodeProcess abstract method execute is implemented in JDpiProcess in order to perform further initialization procedures). A JDpiProcess interacts with the hosting node by using a JDpiNodeProxy described before. Indeed, JDpiProcess simply delegates the execution of these operations to its proxy, e.g.:

In this section we describe two simple mobile agents implemented in JDpi. However, due to lack of space, all the implementation details are not presented here. We refer the interested reader to [13] where IMC and JDpi, with a few simple applications and examples, are available for downloading.

Example 4.3 The following is the code of an agent that migrates over a set of localities, each of which plays the role of an electronic market, in search of the best place where a given article (art) can be bought. At the end of the search, the agent migrates to locality home and provides its result on channel result.

