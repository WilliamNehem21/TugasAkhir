This paper presents rmltop, the ReactiveML counterpart of the OCaml toplevel. This toplevel allows a programmer to interactively write ReactiveML programs which are type-checked, compiled and loaded on the fly. The user can then progressively run concurrent processes and observe the interactions between them.

The main strength of rmltop is that all valid ReactiveML expressions are accepted in the toplevel with the same semantics as in the compiler. This allows to use the ReactiveML toplevel as a debugger. Furthermore, the interpreted code is as efficient as if it was compiled. Moreover, a toplevel interpreter being itself a reactive system, another originality of rmltop is its own implementation in ReactiveML which makes it relatively light.

ReactiveML phrases on the standard input, compiles them and executes them. Moreover it provides control directives to run a process, suspend the execution of the running processes, execute only the next n reactions or resume the execution. Those directives are directly launched in the toplevel. Additionally, the suspension directive can be launched by processes. It allows to program an observer that decides to suspend the execution when a certain condition is verified.

Any ReactiveML program accepted by the compiler can be executed in the toplevel. Moreover, the execution is as efficient as the compiled version of the program. The ReactiveML toplevel does not interpret programs. It compiles them into bytecode and executes the bytecode.

Notice that contrary to Esterel, ReactiveML follows the Boussinot seman- tics: the reaction to absence of signals is delayed. This restriction ensures that programs are causal by construction (a signal cannot be present and absent during an instant). In the following, we assume that the reader has some notions of the OCaml language [14] and of synchronous programming [1]. We will not present the ReactiveML language in details here, but only what is necessary for the following. For more details on ReactiveML the reader can refer to [15,16].

The process planet creates a new random planet and enters in an infinite rep- etition of three parts. First it emits the position of the planet on the signal env to communicate it to other planets. Then it waits for the value of this signal (the list of all planets) which is available at the next instant. Finally, it uses this information to compute the new position of the planet. To summarize, all the planets emit their position on the signal env. It is used by the window process for display and by each planet to compute its position at the next instant. We now run the process planet.

It would be very difficult to suspend by hand the simulation exactly when a planet is in front of the sun, and tedious to execute the system step by step until an eclipse occurs. Fortunately, the #suspend directive can be launched by processes. We can thus define a process eclipse_observer that suspends the simulation if a planet is at an eclipse position.

The process eclipse_observer is a synchronous observer. It can observe dy- namic properties without modifying the behavior of the system. The combination of this feature with the possibility to suspend the simulation allows to set semantic breakpoints. These breakpoints are defined by arbitrarily complex conditions ex- pressed in the language itself. This is an original and powerful way to suspend the execution of a program.

The reactive machine and its controller run in a separate thread of the OCaml toplevel. This software architecture allows the reactive machine to share the en- vironment of the OCaml toplevel. The communication between the two threads is made through shared memory. So we use a lock Rmltop_global.mutex to pre- vent data races. This lock is taken during the execution of ReactiveML phrases (compiled into OCaml).

The execution of a directive sets a global reference in the execution environment. The controller can then access the reference to treat the directive. There is one reference by directive, defined in the module Rmltop_global. Let us now present the reactive machine.

machine_controller. It determines when the reactive machine must compute a new instant. It is composed of two modes : (1) the sampled mode and (2) the step by step mode. It must switch from the first one to the second one when the signal suspend is emitted, and from the second one to the first one when resume is emitted. When the machine is in the second mode, if the signal step is emitted, then a fix number of instants (given by the value associated to step) is computed. This computation can be interrupted if the signal suspend is emitted.

The controller is also in charge of the translation of directives into ReactiveML signals. We have seen in Section 3.1 that the reactive machine and the controller communicate through shared variables (suspend, resume and step) defined in the Rml_global module. The controller monitors these global variables and emits the corresponding signal when the status of a variable changes. This behavior is imple- mented by the following generate_signals process.

Due to the software architecture of rmltop, any valid ReactiveML expression is accepted in the toplevel and has the same semantics and efficiency as the compiled version. Indeed, the same ReactiveML compiler is used for the two versions of the language and the OCaml toplevel is as efficient as the bytecode compiler. Moreover this software architecture results in a light implementation.

First, we can remark that it is not possible to implement a reactive toplevel based on the semantics of Esterel. In this model, processes cannot be dynamically added to a running program because causality loops may appear when two expressions are composed in parallel. For example, in the following expression, even if each present expression is causal, the parallel composition of the two is not causal.

Here, with Esterel semantics, if we suppose that s1 is absent we can deduce that it is emitted in the same instant. If we suppose that it is present, we can deduce that it is not emitted. Hence, this program is absurd.

With ReactiveML semantics, if we suppose that s1 is absent then we can de- duce that it will be emitted at the next instant: there is no causality loop. With the reactive model of Boussinot, all programs are causal by construction. So, contrary to Esterel, it is always possible to add a process to a running machine.

The killable process is a higher order process. It associates a fresh identifier to p using the gen_id function and prints it such that the user can know it. Then the body of the process executes p under the supervision of a kill_me signal: the presence of this signal interrupts the execution. kill_me is emitted when the identifier of the process belongs to the list of processes to kill (the value associated to kill) or when the execution of p is terminated.

The body of the function contains a join-definition (def/in) that introduces three channels (state, set and get). This join-definition is made of two reaction rules. The first one defines the behavior of set: it updates the state of the buffer. The second one defines the behavior of get: it returns the value contained in the buffer.

We have presented rmltop, an interactive mode for the ReactiveML language. It can be helpful to design and debug reactive systems and for teaching purposes. It provides a way to execute a program in a sampled mode or step by step and to dynamically modify the behavior of a system. An originality of this toplevel lies in the fact that it is itself coded in ReactiveML. It results in a light and elegant code, that could be even better if ReactiveML would provide asynchronous tasks. This gives a good motivation to add such a feature to the ReactiveML language.

