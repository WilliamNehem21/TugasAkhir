Section 2 and Section 3 review security protocols, and the formal frame- work, respectively, to put the reader in context. The verification methodology is illustrated in Section 4. A comparison with similar approaches in literature is reported in Section 5. Section 6 contains some concluding remarks.

one key, called public key, is used for encryption, and a complementary private key, is used for decryption. Any principal can encrypt a message for another principal by means of its public key. The latter is the only one that can decrypt the message with its private key.

Example 2.1 The Wide Mouthed Frog (WMF) protocol [10] aims at letting A send a fresh session key kab, i.e. a key to be used within a limited temporal interval, to B through a trusted server S. Both A and B share two private

Protocols have been designed to enforce many security properties. Among them we consider integrity (the intruder cannot corrupt exchanged cryp- tograms), secrecy (the intruder cannot know exchanged cryptograms), and authentication (the intruder cannot let a principal misunderstand the identity of its partners in the communications). Different kinds of security properties, like fairness and non-repudiation, will be addressed in future investigations.

We adopt the (widely accepted) Dolev-Yao intruder model [17]: The intruder is a principal that can interfere with all the communications, e.g. by hiding, reading and modifying messages, with the only limit of the perfect encryption hypothesis. The intruder can have some private data, and can store data exchanged in previous runs of a protocol. It can be characterised in terms to explicitly indicate how principals can be connected together, i.e. how keys can be shared by them. It consists of an instance of the IP-calculus, a process algebra introduced in [9] for describing the behavioural composition of compo- nents in open systems. The logic is used to formalise the properties that the protocol is expected to enforce. It predicates over the intruder knowledge, the way principals share keys and the data they exchange. Moreover it allows for quantification over principal instances in order to uniformly express properties about multiple-runs of protocols.

output actions do not contain binders and input actions contain at most one binder of each variable). A variable can hence be instantiated either when a communication action is executed, or when the principal is dynamically con- nected to its partners in a protocol execution. Note that open variables has been introduced in [8] as a general mechanism to express the sharing of re- sources, e.g. communication channels, between components which are dynam- ically connected together. In this paper, this mechanism has been specialised to the sharing of cryptographic keys that allow principals to interact within a protocol run. Names and variables are syntactically distinguished entities, the former are constant terms, the latter placeholders that can be substituted with terms or opportunely renamed. A principal must be closed: Variables must be bound by either input actions or open variables.

To model multiple-runs, principals may be replicated in principal instances, obtained by indexing all variables (open or not) and all names in E with a dis- tinguished natural number, e.g. A1  (x1, xas1)[out(A1, {ta1, x1, kab1}xas1 )]. Principal instances with different indexes are distinguished, i.e. A1 /= A3.

In step 2 a connection formula is specified, in order to constraint the al- lowed connections and the sharing of keys between principals. Consider, for instance, principals A and S of the WMF protocol as described in Example 3.1; if S is trusted, we might be interested in verifying only the executions of the protocol where (any instance of) A properly shares a secret key with (a cor- responding instance of) S. This can be expressed by the following connection formula which, intuitively, states that the intruder cannot behave as a server. Connec- tion formulae, together with the join operation, are a distinguished feature of our approach. Whenever a join operation is executed, the connection formula is checked and, if it does not hold, then the analysis of that trace is aborted. Moreover, formulae constitute a formal device that the user can exploit for pruning the state space. Indeed, by tuning the connection formula, the user can formally state assumptions that are usually implicit in the informal pre- sentation of the protocol (e.g., the trustworthy of the server in the WMF protocol). The result of a verification session sometimes reveals that some assumptions on the protocol have not been correctly formalised. By refining the hypotheses on principal connections, false attacks can be filtered out. Ba- sically, connection formulae can be exploited for focussing the verification on those states that are interesting to the verifier.

an open system, where components dynamically access running contexts by connecting to other participants. For instance, considering web services, the components are the services and new services are built by properly connecting existing components. In the current practice, this is statically done by the programmer; while the join operation and the connection formula would allow the programmers to specify the constraints over the dynamic connections of their components.

Step 3 specifies the initial knowledge of the intruder so that a protocol is checked under weaker conditions. This knowledge is mainly used for two purposes: (i) to let the intruder know some secrets (e.g. compromised keys) enhancing its attacking power, for instance to test the robustness of the pro- tocol, and (ii) to let the intruder know something about past interactions between principals (cryptograms exchanged in previous sessions). The lat- ter is especially useful in finding replay attacks where the intruder exploits messages appeared in previous session.

thentication. Namely, each further interaction between A and B starts from message (6). Server S shares a symmetric key with each principal. Initiator A generates a nonce na, and sends it to B. Then B asks S for a new session key, S generates kab and, in (3), encrypts the session key in two cryptograms

It is important to point out the role played by open variables. Principal S has variables a and b respectively for the identity of the initiator and the responder. The server needs two further variables, ak and bk that are meant to store the symmetric keys that S shares with A and B, respectively. Similarly, A and B use sk for storing the keys they share with S. Notice that variables are distinct in different principals.

In [15] and [4] encryption/decryption primitives have been embedded into communication actions. Though the linguistic properties of the resulting cal- culi are very similar to those in cIP, our verification approach is different with respect to both [15] and [4]. Indeed, [15] introduces an event-based semantics where events are defined in terms of the enhanced communication; the se- mantics is then exploited to draw the relationships among Petri Nets, Strand Spaces and the inductive proof technique of [29,28]. In [4], this enhanced synchronisation mechanism simplifies the static analysis of cryptographic pro- tocols. The main difference wrt [15] and [4] lies in the verification techniques adopted, which are completely different in the three approaches. Indeed, em- bedding cryptographic primitive in the communication primitives allows us to define a symbolic semantics on the top of which our model checking algorithm works. This also allows us to avoid generating states that are considered not interesting (according to our working hypothesis). Regarding efficiency issues, the amount of time used by ASPASyA is comparable to those used by STA sumes time in generating initial contexts and checking connection formulae. However, STA stops as soon as the first attack trace is found whereas TRUST and ASPASyA perform a search over the whole state space. TRUST generates the largest state space, mainly because it is based on a small step semantics. ASPASyA and STA have more compact state spaces whose difference lies in the fact that ASPASyA initially applies the join mechanism.

