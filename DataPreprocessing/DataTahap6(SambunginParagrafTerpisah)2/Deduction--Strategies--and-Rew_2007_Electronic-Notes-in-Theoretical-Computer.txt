Automated deduction methods should be specified not procedurally, but declaratively, as inference systems which are proved correct regardless of implementation details. Then, different algorithms to implement a given inference system should be specified as strategies to apply the inference rules. The inference rules themselves can be naturally specified as (possibly conditional) rewrite rules. Using a high-performance rewriting language implementation and a strategy language to guide rewriting computations, we can obtain in a modular way implementations of both the inference rules of automated deduction procedures and of algorithms controling their application. This paper presents the design of a strategy language for the Maude rewriting language that supports this modular decomposition: inference systems are specified in system modules, and strategies in strategy modules. We give a set-theoretic semantics for this strategy language, present its different combinators, illustrate its main ideas with several examples, and describe both a reflective prototype in Maude and an ongoing C++ implementation.

gies can be defined by rules at the metalevel in its META-LEVEL module. There is great freedom to define in this way different strategy languages [9], which can then be used to specify and execute strategies for any object theory of interest. The se- mantics of the strategy language in question is used to ensure that all computations allowed are correct deductions in the object theory.

However, pragmatic considerations are important to guide strategy language designs that can deal well with relevant applications. Therefore, we have undertaken the project of providing a basic strategy language for Maude [20]. To make the language easier to use we have made it available at the object level, rather than at the metalevel. Our strategy language allows the definition of strategy expressions that control the way a term is rewritten. We have benefitted from our own previous experience designing strategy languages in Maude, and also from the experience of other languages like ELAN [4] and Stratego [27]. Our design is based on a strict separation between the rewrite rules in system modules and the strategy expressions, that are specified in separate strategy modules. Thus, in our proposal it is not possible to use strategy expressions in the rewrite rules of a system module: they can only be specified in a separate strategy module. In fact, this separation makes possible defining different strategy modules to control in different ways the rewrites of a single system module.

In order to validate our strategy language design, we have mainly focused on automated deduction and programming language semantics applications. Besides the short examples presented in [20], the language has been successfully used in the implementation of the operational semantics of the ambient calculus [23], the two- level operational semantics of the parallel functional programming language Eden [14], and basic completion algorithms [26]. Moreover, as a further contribution of this paper, we apply here the strategy language to congruence closure algorithms.

The basic strategies consist of the application of a rule (identified by the corre- sponding rule label) to a given term. In this case a rule is applied anywhere in the term where it matches satisfying its condition, with no further constraints on the substitution instantiation. In case of conditional rules, the default breadth-first search strategy is used for checking the rewrites in the condition. Therefore, if l is a rule label and t a term, the semantics of l @ t is the set of terms to which t rewrites

A strategy expression of the form L[S]{E1 ... En} denotes a basic strategy that applies anywhere in a given state term the rule L with variables instantiated by means of the substitution S and using E1, . . . , En as strategy expressions to check the rewrites in the condition of L. The number of rewrite condition fragments appearing in the condition of rule L must be exactly n for the expression to be meaningful.

Recursion is achieved by giving a name to a strategy expression and using this name in the strategy expression itself or in other related strategies. This is done in strategy modules (see Section 3.9). Concrete examples will be shown in Section 4.

The basic idea is that these strategy declarations provide useful abbreviations for strategy expressions E that the user can then utilize in a (strategy rewrite) command srew T using E, which rewrites a term T using a strategy expression E. A strategy identifier can have data arguments, that are terms built with the syntax defined in the system module M. When a strategy identifier is declared (with the keyword strat), the types of its arguments (if any) are specified between the symbols : and @. After the symbol @, the type of the terms to which this strategy

A strategy definition (introduced with the keyword sd) associates a strategy expression (on the righthand side of the symbol :=) with a strategy identifier (on the lefthand side) with patterns as arguments, used to capture the values passed when the strategy is invoked. These strategy definitions can be conditional (with keyword csd). There may be several definitions for the same strategy identifier but they should refer to disjoint cases of the arguments, due either to the usage of different constructors in the patterns or to the conditions used.

The first example is a simple game. We have a blackboard on which several natural numbers have been written. A legal move consists in selecting two numbers in the blackboard, removing them, and writing their arithmetic mean. The objective of the game is to get the greatest possible number written on the blackboard at the end. The specification of the game in Maude is also quite simple.

A player can choose the numbers randomly, or can follow some strategy. Possible strategies consist in taking always the two greatest numbers, or the two smallest, or taking the greatest and the smallest. The following EXT-BLACKBOARD module extends the BLACKBOARD module with operations to get the maximum and the min- imum numbers in a blackboard, and for removing an element in the blackboard.

The first proposal of the language was implemented as a prototype by using the Maude metalevel features (Section 5.1). This prototype has been relatively easy to develop and very useful for experimental purposes to reach a definitive strategy language design. Currently, the enhanced strategy language is being implemented in C++, so that it can be integrated with the rest of the Maude system (Section 5.2).

The two main functions are first and next. The combination of these two functions serves to find all the solutions for the application of a strategy to a given state term. They are implemented in a mutually recursive way, distinguishing cases on the strategy expression in the last node of the given path, and with the help of the metalevel descent functions metaApply, metaXapply, metaMatch, and metaXmatch [7, Section 10.4].

The processes exist on a circular double linked list. Processes can pop out of existence at any time and new processes can be created, just ahead of the currently running process. This location is effectively the back of the queue with respect to the running process and ensures that unbounded expansion of the process queue cannot cause starvation. Each process, when it runs, does a small amount of computation to advance its piece of the search.

When a process or task succeeds, it unlinks itself from its owners list and informs the owning task of the success. When a process or task terminates it likewise unlinks itself from its owners list. In both cases, it checks if it was the last process or task belonging to its owner. In that case it informs its owner that subsearch is exhausted.

