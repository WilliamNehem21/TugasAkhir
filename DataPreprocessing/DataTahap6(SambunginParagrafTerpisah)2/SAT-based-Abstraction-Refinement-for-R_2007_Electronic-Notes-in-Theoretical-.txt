The computational complexity introduced by the infinite state space of these real-time systems leads to severe limitations in scalability even within very well-es- tablished model checkers like Uppaal (http://www.uppaal.com). Aside from the omniscient state explosion problem [4] already present in finite state model checking, current model checking techniques for real-time systems are still limited in the num- ber of concurrent quantitative temporal observations (measured by clocks). A par- ticularly dramatic cause of the state explosion problem is the exponential blow-up obtained by forming the cross product for parallel composition of timed automata (TA). To avoid this, we define a linear-size parallel composition for the logical repre- sentation of TA. Typically, only a reduced part of the full parallel composition has to be expanded from our representation during satisfiability checking (SAT solving).

Very sophisticated and well-optimised techniques (e.g., [10]) guide high-end SAT solvers to explore only a comparably narrow fragment around the part of the state space relevant for the particular safety property. We build upon this development by choosing a linear arithmetic/propositional encoding (as opposed to implementing new algorithms for the restricted domain of TA from scratch): a philosophy that has successfully proven its great potential in finite state systems [3]. With this basis, we exploit the particularities of transition systems induced by timed automata using abstraction refinement to deal with the challenges of infinite states.

Abstraction refinement [4,6] is a promising direction of research to overcome the challenges of the state explosion problem and infinite state model checking, while preserving correctness of verification results. Abstraction techniques over- approximate system behaviour by removing constraints that are considered irrele- vant for verifying a particular specification. If the abstract system is safe (no error state is reachable) then, by conservative over-approximation, so is the original.

Jhala and McMillan [7] present an abstraction refinement approach for predicate abstraction. Using interpolants, they generate refinements which take into account specific characteristics of the property. A limitation, however, is the fact that their approach relies on an appropriate choice of predicates for predicate abstraction. Our approach can be considered as a quick (hence, scalable) approximation of predicate abstraction, where predicate discovery is evident by exploiting the nature of TA.

Kripke structures originating from finite state programs. In contrast, our approach deals with the challenges of infinite state model checking as introduced by the notion of real-time clocks. Further, we directly use a formula representation tailored for SAT-based bounded model checking.

After introducing real-time systems and bounded model checking in Section 2, we present a faithful representation of TA in propositional logic with linear arith- metic for bounded model checking in Section 3, and give a soundness result. In Section 4, we introduce a uniform abstraction, and extend the algebraic perspective on soundness from Section 3 to correspondence results about abstraction. Section 5 closes the abstraction refinement loop by investigating how spurious counterexam- ples can be exploited for refining abstractions, before concluding with a summary and future work in Section 6.

Moreover, our representation is specifically tailored for SAT solving technology. In addition to providing conjunctive normal form (CNF) whenever possible, observe that (5) and (6) are binary clauses, which are very efficient (the 2-SAT problem is polynomial since binary clauses do not increase the breadth of the search space). Formula (7) also corresponds to a set of binary clauses, whereas (4) gives rise to unit clauses. Note that it is immediate to adapt our representation to logarithmic

In order to relate our logical abstraction refinement approach to abstraction on TA, and emphasise the structural relationships, we prove a stronger correctness result than the one expressed by Lemma 4.2. For this, we use a homomorphic correspondence between concrete and abstract system [4].

Besides those generalisations, future work includes performance comparisons of our implementation on case studies, and an analysis of the effect of choosing a logarithmic encoding for states (state abstraction is slightly more involved in that case, though). The overall performance might be improved using a SAT solver that is tailored towards bounded model checking with pseudo-boolean constraints or isomorphy inference. Moreover, we intend to examine different settings for balancing counter-example guided abstraction refinement versus refinement based on Craig interpolants.

