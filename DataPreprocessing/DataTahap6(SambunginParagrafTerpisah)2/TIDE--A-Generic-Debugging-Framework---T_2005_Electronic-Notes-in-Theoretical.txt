A language specific interactive debugger is one of the tools that we expect in any mature pro- gramming environment. We present applications of TIDE: a generic debugging framework that is related to the ASF+SDF Meta-Environment. TIDE can be applied to different levels of debugging that occur in language design.

The development of mature programming environments for small languages, such as domain specific languages, is in general not feasible due to the develop- ment and maintenance overhead. The construction of a parser, an interpreter or a compiler already involves a tremendous amount of effort. The ASF+SDF Meta-Environment [1] supports the prototyping of (domain specific) languages on both the syntactic and semantic level. Given the developed specification, tools such as parsers, interpreters and pretty printers are derivable.

The ASF+SDF Meta-Environment [1] is a language definition and program manipulation environment. It can be used interactively to define languages and to generate tools from these definitions. A language specification in ASF+SDF [3] typically includes a definition of the syntax, pretty-printing, type-checking, and execution of programs of the target language.

For this demonstration we will concentrate on the ASF formalism. ASF is a declarative formalism based on conditional rewrite rules. It is a first-order strongly typed language which provides functionality for list matching and a tree traversal mechanism. Furthermore, ASF is strongly connected with SDF in the sense that ASF reuses the syntax defined in the SDF part to obtain user defined (concrete) syntax.

debugger to the user. Besides facilities for stepping through the program at hand TIDE also provides facilities to set breakpoints, and inspect variables and stack frames. Depending on the specific language that is debugged, more or less features of TIDE are applicable.

At these breakpoints at least the source location of the current point of exe- cution must be known, and passed to the TIDE library. For more features, the nesting depth (i.e. the stack depth) and a serialized representation of a variable environment can also be passed to TIDE.

The ASF interpreter defines 21 logical breakpoints during interpretation of a specification. For example, two breakpoints logically identify rewrite rule application: one before matching the left-hand side, and another just before constructing the right-hand side. The marshalling of the ASF value environment to TIDE is implemented in 350 lines of C code. That is enough to obtain a full-fledged ASF debugger.

When a language is already defined in ASF+SDF, it should not be hard to obtain a TIDE-based debugger for this language. We provide a generic ASF+SDF module that encapsulates and hides the TIDE adapter API. Now we can instrument an ASF+SDF specification by adding calls to this module in any language specification. For example, the language specification of Pico was extended with calls to the tide-step function, obtaining a debugger that supports stepping through a Pico program and setting breakpoints.

Naturally, this route does not offer the full expressivity that can be ob- tained by writing a TIDE adapter manually. Indeed, the interface offered is abstract but functional. The design of the ASF+SDF debugging module is a trade-off between automation (less coding for the user) and expressivity (more coding for the user).

