Open systems have well defined interfaces that specify how a system can interact with any environment. For example, the header of a method specifies input values and types for method invocation and such an invocation resolves the nondetermin- ism of that interface at runtime. Parallel composition of process algebra terms and modular model checking also express and analyze open systems and the external nondeterminism stemming from their interaction with environments.

Note that in transition systems, it is only possible to opt for one of the interpreta- tions of nondeterminism if such an interpretation is to be applied uniformly within a transition system. This suggests to use another class of models for expressing resolvable and persistent kinds of nondeterminism in the same model. The idea be- hind the approach proposed in this paper is to use again a kind of ready-simulation. Therefore, we treat the persistent nondeterminism present in transition systems not in the conventional manner of using multiple transitions per label and source state; rather we use exactly one transition per label and source state that points to a set of successor states. In particular, a state with no outgoing transitions with label e has, in this approach, one e-labeled transition pointing to the empty set.

We first discuss the semantics of state machines informally. At each step a single event e is dispatched from the event pool where the order of dispatching is left open in [25]. This event enables a transition if (i) its source is currently active, (ii) e is its trigger, and (iii) its guard evaluates to true with respect to the current variable assignment. Among all enabled transitions, one is chosen, its corresponding SM- (e) but nothing else (g). Output events can only be sent in such intermediate states (b). If the SM-action is different from a send-action, a hypertransition subsuming all the possible outcomes with respect to calc is derived (d). In case no transition is enabled for an event (f), a transition to the state cr, which abstracts

We assume that the formal semantics is given in terms of transition systems that are obtained by derivation rules (small step semantics). Also, we assume that the derivation rules use an evaluation function calc for the SM-actions, i.e., calc maps a SM-action together with a variable assignment to a variable assignment (and possibly additional information). This kind of formal semantics occurs, e.g., in [10,32].

Next, the derivation rules are adapted such that hypertransitions are obtained. This is done by replacing the target of the derived transition by the set consisting of the original target. But when calc is used for the derivation, the target set contains all possible variations with respect to the result of calc. For example rule

A random choice operator can be used to express a probability distribution. Prob- ability distributions are a form of persistent choice. For example, the probabilistic choice of a successor state of state s in a Markov chain expresses a nondeterministic choice that remains to be nondeterministic each time state s is visited. Of course, this persistence is controllable to some degree through the use of familiar tools from stochastic processes.

This approach can also deal with randomized choice that is under-specified. Exact knowledge of distributions is often not a realistic assumption and does not facili- tate top-down-development, because abstract systems already need to specify exact probabilities. Therefore, approaches emerged [18] where only sets or intervals of allowed probabilities are given. We can accommodate this as follows:

In order to give the formal semantics, calc has to be adapted such that sets of distributions rather than distributions are obtained. The adaption of the existing semantics is then made similar to that in Section 4.3. The exact development of the theoretical foundation of this class of models, including precise refinement and satisfaction definitions, is a topic of future work.

2.0 state machines without persistent choice. As already mentioned, refinement patterns of statecharts are presented in [28], where the underlying formal semantics are streams and therefore no persistent nondeterminism is handled. In [6] state machines are mapped to terms of CSP and so a stronger semantics is given by considering trace- and failure-based refinement.

