are represented by means of rewrite systems. For this purpose, we introduce an appropriate notion of dependence that can be used for computing program slices. Also, since the notion of static slice is generally undecidable, we introduce a complete approximation for computing static slices which is based on the construction of a term dependence graph, the counterpart of program dependence graphs.

Program slicing [13] is a method for decomposing programs by analyzing their data and control flow. Roughly speaking, a program slice consists of those program state- ments which are (potentially) related with the values computed at some program point and/or variable, referred to as a slicing criterion. In imperative programming, slicing criteria are usually given by a pair (program line, variable).

While PDGs are good to represent the data and control flow behavior of imper- ative programs, their level of granularity (i.e., considering all function bodies as a whole) is not appropriate for representing dependences in functional programming. In this work, we present a new notion of dependence in term rewriting that can be used to give an appropriate definition of static slicing. Unfortunately, the

The rest of the paper is organized as follows. In the next section, we recall some notions on term rewriting that will be used throughout the paper. Then, in Section 3, we present our approach to static slicing within a functional context. Section 4 introduces a new data structure, called term dependence graph, than can be used to compute static slices. Finally, Section 5 discusses some related work and concludes.

Definition 4.1 (Tree term) We consider that terms are represented by trees in the usual way. Formally, the tree term T of a term t is a tree with nodes labeled with the symbols of t and directed edges from each symbol to the root symbols of its arguments (if any).

Trivially, this algorithm always terminates. The completeness of the algorithm (i.e., that all the program positions of the slice according to Definition 3.10 are collected) can be proved by showing that all possible computations can be traced using the term dependence graph.

The first attempt to adapt PDGs to the functional paradigm has been recently introduced by Rodrigues and Barbosa [10]. They have defined the functional de- pendence graphs (FDG), which represent control relations in functional programs. However, the original aim of FDGs was the component identification in functional programs and thus they only consider high level functional program entities (i.e., the lowest level of granularity they consider are functions).

