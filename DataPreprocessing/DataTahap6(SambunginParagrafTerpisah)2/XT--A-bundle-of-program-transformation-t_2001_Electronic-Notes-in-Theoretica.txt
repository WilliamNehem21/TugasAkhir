Program transformation encompasses a variety of different, but related, language processing scenarios, such as optimization, compilation, normalization, and reno- vation. Across these scenarios, many common, or similar subtasks can be distin- guished, which opens possibilities for software reuse. To support and demonstrate such reuse across program transformation project boundaries, we have developed XT. XT is a bundle of existing and newly developed libraries and tools useful in the

In this short paper, we will provide an overview of XT and an indication of what is possible with it. Section 2 fixes terminology and discusses common program transformation scenarios. Section 3 outlines the program transformation develop- ment process that we want to support. Section 4 discusses the actual content of the XT bundle, and explains how its constituents can be used to support program transformation development tasks. Section 5 summarizes our experiences with XT so far, and Section 6 wraps up with concluding remarks.

Program transformation is the act of changing one program into another. The term program transformation is also used for a program, or any other description of an algorithm, that implements program transformation. The language in which the program being transformed and the resulting program are written are called the source and target languages respectively. Below we will distinguish scenarios where the source and target language are different (translations) from scenarios where they are the same (rephrasings).

Program transformation is used in many areas of software engineering, including compiler construction, software visualization, documentation generation, and au- tomatic software renovation. At the basis of all these different applications lie the main program transformation scenarios of translation and rephrasing. These main scenarios can be refined into a number of typical sub-scenarios.

In a rephrasing scenario a program is transformed into a different program in the same language, i.e., source and target language are the same. Examples of rephrasing scenarios are normalization, renovation, refactoring, and optimization. In a normalization a program is reduced to a program in a sub-language. In ren- ovation some aspect of a program is improved. For example, repairing a Y2K

The list of sub-scenarios is not complete, and in practice many program trans- formations are a combination of sub-scenarios. For example, a single compiler may perform code optimization after transforming its input to a target language. In fact, XT supports component-based development of program transformations, where each component might follow a different transformation scenario.

Design a transformation pipeline. Generally, this pipeline consists of parsers and pretty-printers as front and back ends, and contains a variety of rephrasing and translation components. The interfaces between the components of the pipeline need to be established in this phase.

An implementation of a transformation system for a subset of HASKELL incor- porating the warm fusion algorithm was undertaken as a case study in program transformation with rewriting strategies [10]. The transformation system consists of a parser, a normalization phase to eliminate syntactic sugar, a typechecker, the warm fusion transformation itself and a pretty-printer. The warm fusion algorithm rephrases explicitly recursive functions as functions defined using catamorphisms to enable elimination of intermediate data structures (deforestation) of lazy func- tional programs. By inlining functions rephrased in this manner, compositions of functions can be fused. The bodies of all function definitions are simplified using standard reduction rules for functional programs.

The grammar for HASKELL98 has been semi-automatically re-engineered from a YACC grammar using the yacc2sdf tool. A pretty-printer for HASKELL was built using GPP. The transformations have been implemented in Stratego and make extensive use of the generic algorithms in the Stratego library, in particular those for substitution, free variable extraction and bound variable renaming.

The SDL grammar was obtained from YACC using yacc2sdf, GPP was used for pretty-printing, and sdfcons was used for abstract syntax generation. Fur- thermore, the grammars used in addition to SDL where already available for reuse in the Grammar Base. All programming was performed with Stratego.

XT and all its constituent components are free software [16], i.e. they are dis- tributed as open source under the GNU General Public License [8], and anyone is allowed to use, modify, and redistribute them. XT can be downloaded from http://www.program-transformation.org/xt. The distribution makes use of auto- bundle, autoconf, and automake, which make installation a nearly trivial job. XT is known to install and run successfully on various platforms, among which SUN- Solaris, BSD-Unix, and Linux.

XT shares its bundling infrastructure and the SDF and ATERMs packages with a peer bundle: the ASF+SDF Meta-Environment [2]. This bundle integrates these packages with a compiler and interpreter for the ASF programming language, a structure editor, a GUI, and other components into an interactive development en- vironment for language definitions and tools. By contrast, XT supports multiple programming languages, and offers an extendible set of components that can com- bined in various ways.

