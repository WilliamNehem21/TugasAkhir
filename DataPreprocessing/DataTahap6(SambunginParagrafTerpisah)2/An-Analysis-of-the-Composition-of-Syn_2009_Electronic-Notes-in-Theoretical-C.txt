Safety-critical embedded applications are often distributed. For example, software in an automotive control or in avionics control are distributed over a large number of distributed processors which are connected over some domain specific buses. Correctness of such applications is of paramount importance due to their safety-critical nature. Synchronous programming models (e.g. Esterel, SIGNAL, Lustre) make synchrony assumption (zero time intra-module computation and zero time inter module communication) while model- ing such applications so that the model is easier to verify. Once verified, models built with such assumptions need to be distributed over an asynchronous communication based platform which brings out the challenge ensures safe communication between modules. In this paper, first we provide a more general sufficient condition for isochrony. Second, we generalize the definition of isochrony for weakly-endochronous mod- ules. Further, we introduce the notion of directional isochrony which provides sufficient conditions for safe communication between modules in one direction but not in the other direction. The results in this paper not only simplifies the understanding of the conditions under which a polychronous specification can be implemented in GALS, but also sheds interesting lights on causality and isochrony. When the synchronous modules are reused as IPs, the conditions described here can be checked to see whether those modules can be composed asynchronously with the same behavior as their synchronous composition.

reaching one end of the chip from another end within a clock cycle is becoming difficult; second, the power consumed in the clock distribution network is too much compared to the power consumed in computation. Therefore, a push towards mul- tiple clock domains, and signals crossing clock domains have given rise to interest in GALS design. Since it is widely accepted that synchronous design is much easier than asynchronous designs, it is important to develop methodologies and tools for GALS design.

This means that a new value of y is computed by function f by sampling the values at signals x1,x2,...,xn. It is the responsibility of the modeler to ensure that the values of each signal is present at its rate. In other words, the usage of signals by the modeler itself will indicate to the compiler that rates at which the values of x1,x2,...,xn are updated are the same, and y gets updated at the same rate, as by synchrony hypothesis, f computes in zero time. The SIGNAL compiler assumes the environment will supply the inputs at each clock instant and will show errors in case the clock calculus reveals this cannot be guaranteed.

where x, y, and z must have the same data type, and whenever x gets sampled or evaluated, y gets the value of x. If x is not evaluated or updated but z does get evaluated or updated, then y gets that value. So it is a deterministic merge with priority to the signal x over z.

signals have to be evaluated. Even though the statements in SIGNAL are in parallel composition, there exists dependency between some of the signals which necessitates this ordering. This causality is caused by boolean gaurds in Sampler operator, availability of inputs etc. which gives rise to rate relations. We are interested in the evaluation of these rate relations and how they influence the communication between components.

SIGNAL language has a syntactic construct called process which is its way of modularizing the dataflow specification. The processes are assumed concurrent modules. As a result, if process boundaries are deleted, one gets a large dataflow network where operators are connected with some other operators via signals. The signals at the boundaries of modules or processes also communicate in zero time as per synchrony assumption. However, when distributed in a GALS environment, usually separate modules are deployed at different sites. As a result, signals that cross the module boundaries call for special attention, because the zero time com- munication for these signals cannot be assumed any more. The concept of isochrony concerns particularly these signals.

So the clocks of the signals computed by the operators must be related to check for this condition. When signals cross boundaries of modules, this is particularly problematic to check, because the modules may be coming from different modelers, and may already be compiled into code. Hence, the clock relations of all signals in- side each module must be exported along with the compiled module when exporting a module as an IP. The clock relations between different modules should be analyzed using clock calculus to check for such cycles. In the rest of this paper, we assume that such cycles have been checked before trying to create GALS implementation of the model.

The clock of a signal specifies when the signal is valid. When two signals are used in a SIGNAL statement on either sides of the assignment operator, their clocks are said to be related. Now we formally define a clock relation.

Here process Endo1 has two output signals which are received by Endo2 through an asynchronous medium. According to the order of arrival of inputs to Endo2, the value of c will change. Two cases of reconstruction of c for different rates of out2 is shown below.

Sharing of clock information between IPs in a distributed environment involves exchanging meta-information about the clock relations for these endochronous pro- cesses. This information will include the signals and their rate relations which can be used to check for isochronoy. It is not possible to add any clock information into the IP, once it is implemented and shipped as an IP. So the meta-information will help in checking for isochorny and to redesign the IPs to make them isochronous. Now we formalize a sufficient condition for isochrony. For two endochronous pro- cesses Pi and Pj, where the set of signals of is Vi and Vj respectively, we define a communication structure Cij.

The communication structure consists of the shared signals in both processes and the clock relations between them. The relation r will depend on the relation between signals in Pi. For an endochronous process, there exists a direct or indirect relation between any two signals. Now A2 can be rewritten as follows.

isochrony is verified. Another way of correcting the example would be to share the signal a along with out1 and out2 and maintain the relation between them in the communicating IP. Since correcting IP blocks while composition is not feasible, care has to be taken to ensure that the communication structure and relations are complete, during the design process of an IP.

Another important factor is the independence of clocks of signals in weakly en- dochronous processes. In WEndo3, the clocks (b^1, b^2) and (b^1, c^1) are totally inde- pendent. Similar is the case in R43. To formally express this situation, we use the confirms with the known result. Since any endochronous processes is also a weakly endochronous processes, Assertion A4 also works for two endochronous processes. This demonstrates a uniform way to sufficiently evaluate correct communication (isochrony) for two endochronous or two weakly endochronous processes.

The composition of Endo5 with WEndo6 is correct since the statements in WEndo6 are concurrent. The clock dependencies in Endo5 are not relevant, since the state- ments in WEndo6 are independent. WEndo6 can be reconstructed with multiple be- haviors which will have the same output. On the other hand, the communication from WEndo7 to Endo8 results in loss of values since Endo8 get values of c2 only when d2 > 0 holds. From these examples we can conclude: opposite direction cannot be guaranteed. We can observe similar behaviour for WEndo7 and Endo8. Assertion A5 is not limited for only (endochronous, weakly en- dochronous) processes, it can also be used to analyze any two weakly endochronous processes by checking the clock relations between any pair of shared variables.

In other synchronous languages, different code generation strategies for incorpo- rating distributed operation has been proposed. In Esterel, code has been divided into atomic tasks which is scheduled with parallelism by referring a linked list con- taining the dependencies [6]. More focus is given to the study of compositionality of processes which will later help in designing compilers with the goal of distributed implementation. In the SIGNAL language, one of the earliest work was regarding the clustering and schedulability of SIGNAL programs discussed in [13]. A promi- nent work in distributed execution of synchronous languages was done by converting them into a common Object Code (OC) and then parallelizing this code into the many computing sites [5]. In this work, no characterization of the modules or the inter-module communication were done to check for distributed deployment. It was assumed that a global clock is implemented distributively by virtue of clock synchronization algorithms. However, since global clock synchronization is expen- sive, in the SIGNAL literature or in this work, it is not considered. Instead, one seeks characterizations under which such expensive protocols would not be needed for GALS execution. Multi-threaded code generation remains an important mile- stone in achieving a separated, but centralized implementation for synchronous programs. In the current Polychrony compiler, only endochronous processes can be implemented. A beta version of multi-threaded code generating compiler is being developed. Process based threading for weakly endochronous programs with sepa- rate compilation for composing processes have been implemented using the existing compiler for SIGNAL [10] and a synchronous data-flow based threading strategy has been proposed in [11].

