Programming languages are the key link between computers and the software that runs on them. While programming languages usually have a formally defined syntax, this is not true of their semantics. Semantics is most often given in natural language, in the form of a reference manual or reference implementation, but rarely using mathematics. However, without a formal language semantics, it is impossible to rigorously reason about programs in that language. Moreover, a formal semantics of a language is a specification offering its users and implementers a solid basis for agreeing on the meaning of programs. Of course, providing a complete formal semantics for a programming language is notoriously difficult. This is partly because of the mathematics involved, and partly because of poor tool support, but also because of the poor scalability of many frameworks, both in terms of modularity at a definitional level and in terms of simulation, execution and/or analysis time.

In addition to the predefined semantic categories (computations, lists, sets, bags, maps), the K tool provides a number of built-in syntactic categories/datatypes, and semantic operations for them. The dynamically evolving list of these built in operations can be found in the files from the include/builtins directory from the distribution. Among the currently supported built-ins are Booleans (Bool), unbounded integers (Int), floats (Float), strings (String), and identifiers (Id).

K contexts can be used to solve this problem, by generalizing strictness annotations. They allow the user to declare that a position in an arbitrary term should be evaluated. K contexts are similar to evaluation contexts [8, 16]. For example, here is the context declaration needed above:

Although good in theory, the unrestricted use of heating/cooling rules may create an immense, often unfeasible large space of possibilities to analyze. Therefore, for performance reasons, the K tool chooses a default arbitrary, but fixed, order to evaluate the arguments of a strict language construct. Specifically, similarly to refocusing semantics [4], once a path to a redex is chosen, no other path is chosen until all redexes on that path are evaluated. This has the side effect of potentially losing behaviors due to missed interleavings.

To restore these missing interleavings, the K tool offers a superheat/supercooling process. These allow the user to customize the level of strictness-based nondeter- minism available. They bear no theoretical signification, in that they do not affect the semantics of the language in any way. However, they have practical relevance, specific to our implementation of the K tool. More precisely, productions whose attributes are specified as superheat suring compilation is used to tell the K tool that we want to exhaustively explore all the nondeterministic evaluation choices for the strictness of the corresponding language construct. Similarly, whenever a rule tagged with an attribute specified as supercool during compilation is applied, the K tool will reset the current context, restarting the search for a redex. Upon this step, the rules defining the descent towards the next redex have the possibility to pick another evaluation order.

After recompiling the K definition with kompile -superheat "plus", we can run the program p3.exp ((print(1) + print(2)) + print(3)) using the --search option of krun. The tool finds four solutions, differing only in the contents of their out cell, containing strings "213", "123", "321", and "312". Why only four different outputs and not six? In the absence of any supercool rule, superheat only offers nondeterministic choice. That is, once an argument of a construct was chosen to be evaluated, it will be evaluated completely. In order to observe full nondeterminism, the rules whose behavior we consider observable, e.g., the output rule, must be specified as supercooling:

We would like to mention several other platforms and tools to help the language researcher in experimenting with various designs and features which are closely related to our research. Rascal [10, 17, 32] and Spoofax [14, 15] target developing IDEs for domain specific languages with Eclipse integration and code generation fea- tures. PLanCompS (Programming Language Components and Specifications) [22,23] focuses on modularity and on the development of a component-based framework for the design, specification and implementation of programming languages. Re- dex [7, 19, 20] focuses on specifying and debugging operational semantics and allows interactive exploration of term reductions and using randomized test generation.

