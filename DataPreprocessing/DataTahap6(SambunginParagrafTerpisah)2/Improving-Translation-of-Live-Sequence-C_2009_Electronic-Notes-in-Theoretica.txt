of industrial-strength protocols. Previous work shows that the LSC-to-temporal logic and LSC-to-automata translations can be automated and formalized for the LSC language. In the LSC-to-temporal logic transla- tion, the extraordinary size of the resulting formula limits the scalability of the charts that can be translated and verified. Our work, on the other hand, leverages intuitive temporal logic reductions to generate a for- mula that is at most quadratic in the size of the chart and demonstrates the benefits of the improved translation on several examples.

Pivotal to any verification effort is the ability to develop specifications against which the system in question is to be verified. Traditionally, English has been the default language choice for specifying and describing communication protocols. In our experience, English is not an ideal medium for expressing protocol specifications because of its context sensitive, imprecise, and cumbersome nature.

LSCs can be used at various stages of the development and verification process. Initially, LSCs can be used to verify properties of the communication protocol to guarantee behaviors of the protocol. Further in the development and testing stages of the system, LSCs can provide a specification against which implementations are verified. LSCs can also be published as the supported interface of the IP core.

formulas that are of quadratic size with respect to the size of the chart [15,18], which in the average case, is much larger compared to the number of maximal messages in the chart. The translation uses logic minimization over the until (U) operator to improve upon earlier translations. We prove that our improved translation covers the same set of behaviors as those specified by the quadratic translation in [15] and is more than competitive with the work presented in [11], which translates LSCs directly to automata. Further, we extend the translation to other constructs of the LSC grammar that have not been directly translated to temporal logic in earlier research. Finally, we present results in explicit and symbolic model checking that show the benefits of using a smaller formula during verification as generated by our improved translation. Specifically, the verification time and state space are greatly reduced, especially in cases where counterexamples need to be generated.

LSCs extend the semantics of MSCs to be able to specify provisional behav- ior [16,7,5]. Additionally, LSCs have also been used in the past to model and verify systems. Work in [4] describes the modeling of an air traffic control system and the verification performed on the system. Work in [14] describes the modeling of an automotive system using LSCs. Other such examples utilize the expressive power of LSCs to concisely describe and verify systems and relate them to other specification languages [3,12,8].

There is ongoing interest in the model checking of LSCs and translation of LSCs to automata for the automatic synthesis of systems [13,1,9,10]. Additionally there has been significant work done in translating LSCs to temporal logic for verification of systems. The major limitation of translating LSCs to temporal logic is the sheer size of the resulting temporal logic formula [15,18]. In [6], small and efficient-to- verify ordering properties are generated from LSCs but no formal relationship is established between the system and the specification. Although the system satisfies the ordering properties, the properties do not imply that the system implements the LSC specification. In [15], an LSC is translated to an LTL formula that is quadratic in the size of the LSC. The size of the LTL formula is large enough to hinder the verification of anything but small LSCs. The work in [15] forms the basis of our work.

The work in [11,17], and [18] give an alternate verification approach in an effort to avoid the explosion encountered during the LSC-to-automata translation. The approach unwinds the LSC to create an automaton with size proportional to the number of reachable states in the LSC, and it uses the automaton in a multi-tiered verification effort comprised of four different model checking procedures ordered by least-to-worst algorithmic complexity: reachability analysis with safety observer, ACTL model checking with and without observer, and finally LTL model check- ing. If a less powerful technique is not able to complete the verification, then the approach moves to the next procedure until it arrives at full LTL model checking. Although the approach deals with the full semantic model of LSCs, except Kleene

The work presented in this paper can translate all constructs except non-bonded conditions (conditions not tied to a specific message), temperatures (progress is forced or unforced), tolerant behavior (allowing multiple instances of an event within a chart), and multiplicities (Kleene star). In our experience, these constructs are rare in practice, and charts omitting these constructs are more than expressive enough to specify IP core interactions. We briefly present extensions to remaining constructs.

Asynchronous Messages: Asynchronous messages drawn in charts with an open ended arrow head are used to specify messages where the receiver may not be ready to receive the message. We build a new a-relation that ranges over the individual send and receive events and forces the send event to always occur before the receive event. Properties are then generated from this new a-relation.

Co-regions: Co-regions, specified by dashed lines parallel to the agent instance line, are used to express unordered events. To translate co-regions into temporal logic, we do not explicitly specify the order of all the events. Instead, we specify the order of the events that are to occur before and after the co-region and force the existence of the co-region events in the correct order.

Bonded Conditions: Bonded conditions are boolean predicates that are checked with a message in a simultaneous region (all events occur in the same state); thus, they are bonded to the message. Since a message always occurs with the condition (simultaneous region), the temporal logic translation only needs to consider the conjunction of the boolean predicate of the condition and the message. Invariants: Invariants are boolean predicates that can be specified for a certain region of the LSC. We treat invariants as a set of bonded conditions where each event in the invariant region is conjuncted with the invariant condition. Using this

We are interested in understanding the performance of our improved LSC-to- temporal logic translation in both explicit and symbolic state model checking in terms of total verification time. Ideally, we would like to directly compare verifica- tion time using our translation to that in [15] and verification using the iterative approach in [11]. Such a direct comparison to [11] is not possible, however, because we do not have access to the implementation of the approach (which builds on VIS). Since the specification descriptions of [11] are the worst-case specifications for the translation process, we design an experiment using the specification descriptions from the empirical study in [11], and only indirectly compare the results.

There are three key threats to validity in this empirical study. First, the omitted times for LTL-to-automata synthesis in explicit state model checking. The LTL synthesis time is a one time cost that either completes or does not complete. We assume that once synthesized, the formula is reused over several verification runs as the system is implemented. In our experiment, all LTL synthesis occurred in less than three minutes of wall clock time. The second threat to validity is the indirect comparison to the multi-tiered approach of [11]. Our experiments try to duplicate the models in [11] as closely as possible. Anecdotally, our results scale to the A4 and A5 specifications in very little time and with great ease in NuSMV, which is of prime importance, since the specifications represent our worst-case for this translation. Real world specifications tend to be much less concurrent and smaller as compared to the Ax specifications. The third and final threat is the model checker implementations. It is not known if a different model checker such as VIS would give different results to invalidate those presented here. We suspect such a result to be highly unlikely since we know that formula size (as well as nesting depth) directly affects the verification cost.

