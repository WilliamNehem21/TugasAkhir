The paper is structured as follows. We first provide an intuitive expla- nation of the purpose of tokenizing Java Card class files by describing the differences between method resolution for Java Card class files and for Java Card CAP files (Section 2). We then proceed (Section 3) to describe the PVS formalization of the class file and the CAP format on which the CAP converter operates. Section 4 presents the development and accompanying proofs of the tokenization part of the converter. Section 5 on componentisation describes the specification and the implementation of constant pool merging in the CAP format.

In this section we present the PVS specification of Class file format and CAP format. Each of them is built as a PVS Abstract Data Type, defined by its set of constructors, associated recognizer predicates and accessors. The PVS models are strongly idealized versions of Java Card class and CAP files.

A class hierarchy is a forest that can be empty or which is of the form nodeHier(c, s, b) where c is a class, s is the forest of its sons and b is the forest of its brothers. For instance, a class c1 having two children c2 and c3 will be represented by a term nodeHier(c1, nodeHier(c2, empty, nodeHier(c3, empty, empty)), empty), where c1 has a son c2 which has a brother c3. In the above datatype, class, sons and brothers are the accessors and empty?, nodeHier? are the recognizers.

corresponding to listMet and the inherited methods. The integer field next is used during the recursive calls to count every method defined in mt super in order to find the number of the first token that can be used to tokenize the methods in listMet. If a method s is associated with a token t in mt super and if s occurs in listMet then the searchMethod function ensures that s will be numbered by the same token t in the class c.

In the Java bytecode format, constants like integers, real numbers, strings, class and method names are all stored in an array called a constant pool. There is one constant pool per class. In the bytecode of the methods of the class, every occurrence of a constant is replaced by its corresponding index in the constant pool.

This section deals with the componentisation of Java Card packages. The Java Card definition specifies how a package of class files must be split into a number of components (method, class, export, constant pool, etc) that together represent the package. We will not deal with all these aspects of componentisation but focus on how to build the constant pool component. More precisely, we will show how to define and prove correct a function that is given a class hierarchy and produces two results: a global package constant pool and an offset function f . The global constant pool is produced by merging all the constant pools of the classes contained in the hierarchy. For every class of the hierarchy, the offset function gives the jump to perform in the global constant pool to find back the content of the constant pool of the class. In particular, the offset function will be used to backpatch the bytecode of every

In section 5.1, we define a specific theory to deal with basic array copying and merging problems. In section 5.2, we show how to use this simple the- ory in order to achieve the componentisation function and its proof on class hierarchies.

copies the content of an array t1 between indexes from pos and to pos into an array t2 at a position at pos. The type of the result of this function could be more precise. In particular, we could specify in the type that in the resulting constant pool, (1) we must find the values of t1 between the indexes at pos and at pos + (to pos - from pos) and (2) we must find back the original values of t2 outside of these indexes. However, using such a very precise subtype tends to generate Type Checking Conditions (TCCs for short) that are more intricate and more difficult to prove than if the property is proven outside the typing, as additional lemmas: correct copy for property (1) and copy not modif outside values for property (2):

Thanks to the previous array copy function it is easy to define a function sum that concatenates two constant pools. Moreover, using the two previous lemmas it is easy to show that the sum function is correct i.e. in the sum of two constant pools t1 and t2, t1 can be found in the sum from indexes 0

Like in section 4.2 for the tokenization functions, the componentisation function is supposed to be applied to a valid hierarchy. However, for com- ponentisation an additional assumption is necessary: we assume that there is a bijection between classes and their names. The following main theorem states that for all valid class hierarchies, if comp cp is the componentised con- stant pool, if off fun is the related offset function, then for every class file cf in this hierarchy (having a non empty constant pool), we can find back the i-th cell of the constant pool of cf at position jump + i in comp cp, where jump =get(get assoc(name(cf), off fun)). The value of the jumpis in fact the value associated to the name of the class cf into the association list off fun.

However, typing this theorem raises two non trivial proof obligations (TCCs) revealing two implicit assumptions that have to be proved first, as lemmas. The first lemma states that by looking for the name of the class cf in the association list we will obtain at least one value for the jump, i.e. that the offset function is total with regards to the class names of the hierarchy. The second lemma states that for every class file cf, jump + i is within the bounds of the global componentised constant pool comp cp. Even if the details are rather different, the global proof sketches for those two lemmas and for cor- rectness cp component are similar. We perform an induction on the structure of the hierarchy ch. The base case of the empty hierarchy is easily discarded since it is contradictory with the fact that cf is known to be in the hierarchy ch. Then for the general case, we achieve a proof by cases on the definition of

We have specified the core algorithms of a CAP converter in PVS. These algorithms deals with the tokenization and the componentisation of Java Card class files. The tokenization algorithm was proved correct by showing that it fulfills the constraints detailed in the Java Card definition of the CAP format. As was shown in previous work [3], this is sufficient to prove the correctness of the conversion. Componentisation was proved correct in the particular case of merging constant pools.

