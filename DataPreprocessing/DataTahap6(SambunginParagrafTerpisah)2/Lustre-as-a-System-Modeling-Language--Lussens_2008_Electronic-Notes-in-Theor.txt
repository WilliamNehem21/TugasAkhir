Wireless Sensor Networks (WSNs) are distributed computer systems composed of a large number of small sensor nodes. There are many potential application areas [3]. The nodes have three main tasks: sensing their environment, processing the data and communicating with the other nodes. All the nodes are identical, except one or several sink nodes. A sink monitors the network. It collects the data and sends

The Lustre model is 1500 lines long. It has been developed by K. Baradon and A. Vasseur, two master students of the Telecom department of INPGrenoble. It includes detailed energy models for all hardware parts that have a significant energy consumption. The connection to validation tools has been established.

In an accurate sensor network model, the various modes of the radio and their associated consumption should be detailed. Moreover, the way the MAC protocol triggers mode changes has to be described. This is because we want to observe properties related to energy consumption. Other properties like latency, throughput, bandwidth utilization or fairness are secondary.

Even if the radio consumes a lot, the energy used to process data cannot be ne- glected. According to Yuan and Qu [27], the processor is responsible for a consump- tion of 30 percent of the total consumption of the node. Moreover for some MAC protocols the micro-controller can be responsible for more than 90 % of the total energy needed to receive one data packet [20]. A technique used to optimize the energy consumed by the micro-controller is Dynamic Voltage Scaling (DVS). DVS consists in adapting dynamically the voltage of the micro-controller according to the load. This modifies the tradeoff between the consumption and the efficiency of the MCU. When the voltage is low, the consumption is low too but the micro-controller works slowly. This idea can be used in sensor networks [27].

The consumption of the memory is less important but researches are conducted on this topic [5,15]. If we want to take memory consumption into account, we should include the description of the memory consumption, depending on the type (RAM, Flash, ...). Some memories can have a standby mode in which they cannot be read or written to, but consume less. In order to read or write, one has to put the memory in normal mode first. Such a mechanism may also be driven by explicit operations in the object code of an application program, if a static analysis has identified pieces of the program during which some variables need not be accessed.

some of them need random values (e.g., the protocols). All the random values needed in the components are exposed as explicit inputs, connected to global in- puts of the model, and then to an external generator. We could use a call to an external C function locally, but exposing the random value as an input is better for analysis purposes, because explicit abstractions can be made on its value.

is the right modeling since the physical node itself is a synchronous circuit. Between the sensors however, it is not the case. Although the physical nodes of a sensor net- work do have a physical clock, these clocks cannot be assumed to be synchronized during the whole lifetime of the network. Modeling the whole network is therefore

The model should describe what happens precisely in the communication medium, i.e., the air in which the radio transmission occurs. We could even include electro- magnetic perturbations, or other similar phenomena. All these modeling aspects are grouped in a Lustre node called channel that knows about the topology of

Exploiting the various energy modes of hardware devices may be done in several ways. Our global model should provide a way to model any solution. Conse- quently, we provide a coordination between the model component that represents the application code, and the energy models of the CPU and the memory (see also section 4.3).

The state is encoded by an integer or by a vector of Boolean values, depending on what we want to do with the model. For simulation purposes, it is better to use an int, but for validation purposes it is usually better to exhibit Boolean encodings wherever it is possible (because the exploration of the model becomes decidable). The transformation between the two forms can be done automatically in Lustre.

to switch between modes, because of its very small order of magnitude, compared to other times in the global model. But it could be done easily (see the principle on the radio model). The consumptions to be attached to the states are taken from the documentation of the STMicroelectronics SRAM DS2016.

In this paper we consider that the protocol layers are implemented in software. In order to include them in our global model, with the appropriate level of detail, we need to consider their object code. Indeed, when some software element drives the energy-saving mechanisms of the hardware, it is visible at the granularity level of the machine instructions. An assembly-line code can be easily described by an automaton (the control graph of the program), and that is what we do here. The automaton is then encoded into Lustre.

The MAC protocol implemented in Lussensor is a preamble MAC protocol (see, for instance, WiseMAC [6]). Each node periodically checks whether the channel is free. If the channel is busy, the node will let its radio on to get the packet that follows the preamble. Otherwise, it goes back to sleep mode. To avoid collisions we implement a back-off: the sender has to wait for a random time before emitting anything, then it scans the channel and if the channel is clear (Clear Channel Assessment, CCA), it sends the preamble and then the message. Otherwise, it delays the emission by setting a timer at random between 0 and cwmax. A preamble precedes each data packet for alerting the receiving node. All nodes in the network sample the medium with a common period.

The application code is a simple algorithm that emits the value sensed on a regular basis. It has 8 control states, and computes the commands mode sensor, mode cpu, mode flash and mode ram to be connected to the corresponding inputs of the hard- ware device models. For the moment, the values of these commands are entirely defined by the control state. The effect of any static analysis that would insert such commands in the object code of the application can be easily included in our model. In Lussensor, the channel is the part of the global model that takes care of the air where communications take place, and knows about the topology of the

Because network simulators are extensively used in the network community re- search, many relevant simulators have been developed. NS-2 [1] is a packet-level simulator that was first designed for wired networks. NS-2 is a discrete event simu- lator. The interest of having one single simulator is to enable comparisons between different protocols without the need to implement the protocol we want to compare with. Indeed, NS offers a large protocol library. However, NS is not really scalable: it is convenient for simulating a few hundred nodes only. Because one of the key issues in sensor networks is power consumption, people began to develop simulators that take the energy consumption into account.

Avrora [26] is written in Java and is cycle-accurate. It is able to execute the binary code of an application. The efficiency of the simulation relies on a quite complex synchronization pattern which in fact constitutes the model of the radio. For the environment, models are still needed, and the interaction between a model of some component and the exact description of another component is not formalized. It would be hard to use this framework to play with various abstractions.

TOSSIM [17] is the simulator dedicated to TinyOS [25] applications. TOSSIM does not provide a model of the consumption. To overcome this limitation, it has been extended with PowerTOSSIM [24]. In PowerTOSSIM, each state of the CPU, Radio and EEPROM is associated with a cost. Running the simulator computes the energy consumption of each node.

None of these simulators uses a formal model that could be used for validation. On the other hand, the formal validation community does not seem to have started working specifically on sensor networks. To our knowledge, there is no other approach for the formal and global modeling of sensor networks, for which we can hope to use validation tools. Some experiments in modeling and analyzing sensor networks have been made with tools like HyTech [8] or Uppaal [14], but the

Lucky [10,11] belongs to the Lustre toolbox. It allows to describe non-deterministic reactive behaviors as sets of parallel communicating automata with weights repre- senting probabilities. A Lucky component may be used in our global model to replace any of the Lustre components, provided it has the same input/output interface.

abilistic modelings that have been proposed for these phenomena in the network community. The Lustre model is an appropriate platform for these experiments. A similar use of Lucky would be to replace a part of the network (a subset of the nodes) by a traffic generator, i.e., a non-deterministic process that generates the states of the channel for the remaining nodes. This is related to the next point,

details on the behavior of the computing parts. Indeed, as mentioned in section 5, the mathematical models used for the performance evaluation of protocols are too simple when it comes to representing complete protocol stacks or complex radio channel behaviors (i.e., collisions).

Samper, L., F. Maraninchi, L. Mounier, E. Jahier and P. Raymond, On the importance of modeling the environment when analyzing sensor networks, in: Proceedings of International Workshop on Wireless Ad-Hoc Networks 2006 (IWWAN 2006), New York, United States, 2006, p. 7.

