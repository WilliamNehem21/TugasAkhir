Membrane computing is a rather young area of natural computing aiming to abstract computing ideas and models from the structure and the functioning of living cells. Several extensions comes both from biology, i.e., from the desire to capture more and more biological facts, and from mathematics and computer science, i.e., from the desire to have more powerful or more elegant models.

ing. Closer to membrane computing are the multiset processing languages, the most known of them being Gamma [5]. Membrane systems restricts the form of rules in Gamma, looking for both biological roots and mathematical simplicity and elegance. Membranes appear also in the Chemical Abstract Machine (CHAM). However the membranes of CHAM are not membranes as in cell biology, but correspond to the contents of membranes (multisets). The description and the goals of CHAM [6] are different from those of membrane systems; they are closer to the process algebras approach. Related formalisms are represented by mobile ambient calculus [8,18] and brane calculus [9]. A formal relationship between mobile ambients and mobile membranes is given in [1].

Membrane computing deals with distributed and parallel computing models, processing multisets of symbol objects in a localized manner (evolution rules and evolving objects are encapsulated into compartments delimited by membranes). Membrane computing was not initiated as an area aiming to provide models to biology, models of the cell in particular. At this moment, after developments at the theoretical level, the domain is prepared to offer such models to biology, and considerable advances toward such achievements have been reported.

ural numbers) [7]. If the maximal number of rules with promoters present in any membrane is 6, the number of membranes necessary to achieve universal computa- tions can be reduced to 1. If the maximal number of rules with inhibitors present in any membrane is 6, the number of membranes necessary to achieve universal computations can be reduced to 3 (more details are presented in [7]).

and rulesIn : Label -> RuleSet is used to present the rules inside a membrane. We work with register membranes even when implementing message passing and dissolving. This does not modify in any way the semantics, since we identify a membrane M with the register membrane HM , as in the Propositions 3.6 and

In this stage a membrane evolves in a single rewriting step: if the set MM of children membranes is msg-reducible, then MM rewrites to a msg-irreducible MM 1(rule crl [5]); the membrane M with objects W 1 which contains MM is rewritten to the membrane M 1 with objects W 1+ W 2+ out(MM 1) (i.e. the ob- jects with messages of form (a, here) are transformed in objects of form a, and the objects sent out by the set MM 1 of membranes are added), and children emptyOut(sendIn(A, MM 1)) (i.e. the objects of form (a, inj) are sent into the membrane with label j and then the objects with messages of form (a, out) are erased from every child membrane). The result is msg-irreducible, because the only objects with messages are in the membrane M 1, and they are of the form (a, out) (if M 1 is the skin not even those objects remain). If the set MM of children mem- branes is msg-irreducible, then the same process takes place, except that instead of MM 1 it is still MM (rule [7]).

