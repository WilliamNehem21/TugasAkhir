Through the years, computer systems have advanced in integration, performance, functionality, and applications. A clear example of this evolution are CPUs (Cen- tral Processing Unit) which are the most widely used resource for computers. Ini- tially, CPUs were conceived to process general purpose tasks but now incorporate application-specific circuitry for functions like video processing, acceleration of vec- tor operations, multimedia decoding, and hardware acceleration for scientific ap- plications [16][26][29]. Nonetheless, CPUs show notorious performance limitations when processing big data sets or when the task at hand has a large number of computing operations [16] [26].

computers. Pixel color computation for an image can be performed in parallel (us- ing rasterization) by several processors. This observation guided the design of the Graphics Processing Unit or GPU: a circuit that incorporates a lot of minimalist processors highly optimized for the mathematical operations needed for this specific task. The performance gain obtained in computer graphics with GPUs is massive, and, now, it is widely used in video games and multimedia applications [29].

Due to the limitations of CPU performance in several tasks, a lot of research has been targeted toward the GPU architecture to utilize it as a general purpose processor [20][26][27]. This research has improved the execution time of several computationally intensive workloads (e.g., artificial intelligence, blockchain, bioin- formatics, etc. [16]). Thus, the GPU has positioned itself as the default architecture in a significant number of demanding workloads due to its parallel processing capa- bilities and high optimization for mathematical operations [16][20].

In 2011, with the introduction of novel specialized circuits in the CPU die, a new type of computer architecture known as APU (Accelerated Processing Unit) was born [20]. This setup has a CPU and a GPU that share system memory (RAM) in the same integrated circuit, with a coherence mechanism between their memories and the possibility of efficiently sharing data structures. The APU design brings up the opportunity to create specialized algorithms that make use of these specific characteristics [16][20]. Nonetheless, [20] point out that there is a lot of pending work in evaluating the performance of APUs in tasks where GPU performance is not practical due to constraints like the PCI-Express bus transfer rate, inability of sharing data structures between the CPU and GPU or when the GPU is executing code with a high number of branches [20]. Also, the same authors mention that the design and evaluation of tightly coupled algorithms, that can take advantage of the specific characteristics of the APU architecture to improve performance, are opportunities to be explored [20].

Section 2 shows the different efforts made to accelerate the ray tracing algorithm through approaches and the obtained results of this initiatives, while Section 3 de- scribes the design and details of our implementation of an acceleration mechanism for the APU. The experiments executed for this research, including the experiment design, the hardware used, and the analysis method for the data obtained are de- tailed in Section 4. In turn, the results of these experiments are presented in Section 5 and discussed in Section 6. Finally, Section 7 summarizes all the conclusions of his paper and identifies avenues for future work.

just for ray tracing, it does not spend time in instruction fetch and instruction de- code cycles like a typical CPU. On the other hand, this solution was just a prototype with limited functionality. Besides, it was developed on an FPGA due to the high cost of implementing the design on silicon by the time of the publication.

Another approach of using pre-processed data structures as an acceleration mechanism is the Bounding Volume Hierarchy (BVH). This method analyses each one of the elements in the scene and adds them to bounding boxes that progres- sively will be added inside bigger containers, creating a binary tree data structure. In this way, when a ray does not crosses a bounding box, all the objects in the sub-tree and in that container are discarded, saving a lot of processing time [27]. A high-performance gain can be obtained through this acceleration mechanism as it avoids the unnecessary calculation of several ray/object intersections [33]. That algorithm was initially conceived to run in CPUs, and it was ported later to GPUs by [6], however, a specific implementation for APUs is yet to be found.

We focus on showing APUs as viable architectures for improving the performance of computationally intensive workloads, in particular ray tracing. This is pertinent because APUs are widely available and present in a lots of commodity hardware [14][20]. We are not just looking for a porting of an algorithm from the CPU to the GPU nor the optimization of an existent algorithm. A novel ray tracing algorithm for the APU that presents an insight into how the specific characteristics of this architecture can be used to improve the performance of computationally intensive workloads was designed. For instance, we depend heavily on the ability to share in an efficient manner data structures between the integrated GPU and the CPU because the memory is shared by both processors, which avoids the communication bottleneck of the PCI-Express bus. The amount of memory can be expanded to the same memory available to the operating system [16]. Furthermore, the tasks

The very same ray tracing algorithm was developed for CPU (using C) and GPU (using OpenCL). Even the data structures are the same. The implementations do not provide any optimization that favors any architecture. It is based on [27][28][30]. The GPU development followed the recommendations pointed out by [20] to improve the performance when processing a general workload. The code for the APU is exactly the same code as the CPU architecture for its internal CPU rendering, as well as the same code of the discrete GPU for its internal GPU. Thus, any optimization to these components, would be present in all the affected actors.

loads as the unit to be given to a processor to render. For each available CPU core in the system, a thread that checks if there is any available workload pending is spawned. If this is the case, the thread executes the workload, saves its result to memory and looks for the next workload. Each thread finishes if there is no more pending work. Since each of the work assignments to the GPU component of the APU implies an overhead, there should be at least enough work to maximize the GPU resources utilization, i.e., all its processing units should have enough workload. AMD documentation recommends experimenting with different workload sizes to achieve optimal performance [4][20]. As a rule of thumb, we found that if there are

Factorial Analysis of Variance (ANOVA) experiments are designed to evaluate efficiently the effects that different factors under research might have on a response variable [23]. This methodology was chosen due to its capacity to evaluate the per- formance of the ray tracing algorithm across the APU, CPU and GPU architecture and several other factors that directly impact rendering time [27]. For practicality, the evaluation of the effects (anti-aliasing, reflections, transparencies) uses a 2k form, which significantly reduced the number of executed experiments while preserving the influence of those effects in rendering time.

Image resolution: Image quality is dependent on the level of detail that it can contain [17]. A pixel is the smallest possible detail that is present in a digital picture, so it is directly related to the quality. This means that more pixels in an image (more resolution), the better quality it has. Three common computer resolutions were selected for the experiment:

The basic scene used for the experiments is constituted by the quantity and position of the objects. From there, the factors of resolution, effects, and archi- tecture were adjusted to fit a specific combination. A complex ray-traced image has several objects distributed across all the scene [27]. This criterion was used to randomly distribute the objects in the x and y axis of the projection frame and the z axis of the scene. Different object sizes and shapes were used to simulate the unpredictability of the elements contained in a typical ray-traced scene.

We presented an alternative low-cost architecture for accelerating computationally intensive workloads. Our design utilizes all available computing resources in the APU (integrated GPU and CPU) to process a computationally intensive task, in this specific case, ray tracing. Our approach takes advantage of the particular char- acteristics of the APU architecture, for instance, its ability to share data structures from RAM and the ability to efficiently coordinate work within its internal proces- sors.

should be studied to measure whether the APU keeps its performance and cost- efficiency advantage in those tasks. As the APU uses the same code as their CPU and GPU counterparts, it would be interesting to explore the effects of extensive optimization of the rendering code in the three architectures. Also, an in-depth exploration of the PCI-Express and memory transfers in the discrete GPU solution could provide an interesting insight into ways to obtain more performance from the APU. Finally, as there are several techniques to minimize the FP32 rounding error [27], the experiments could be run focusing on FP32 operations.

