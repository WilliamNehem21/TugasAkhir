A Java developer using Eclipse can take advantage of continuous compilation; after every saved change, a compilation is (incrementally) run, which brings the generated class files up to date with the source files, and quickly notifies the developer if any compilation errors are encountered. This feedback may sometimes be useless or redundant. However, the popularity and effective- ness of continuous compilation indicate that the feedback provided is valuable enough, and processors are fast enough, to make it worthwhile.

We implemented a preliminary version of continuous testing for Emacs, and used it for a user study on student developers (see Section 2.1). Encouraged by the results, we built a full-featured implementation of continuous testing as a plug-in for the Eclipse integrated development environment [3].

Eclipse already contains support for integrated unit testing, automatic asyn- chronous compilation, and automatic notification of compile errors. This meant that much of the infrastructure for continuous testing already existed, both in the technical implementation, and in user expectations and metaphors. This allowed us to provide more functionality more quickly than we could in Emacs, and we hope it will allow us to develop a user base more quickly.

Developers using our plug-in can associate a test suite with each Java development project. Whenever the code in the project changes, the test suite is run asynchronously, and any test failures are indicated to the developer similarly to compilation errors. To reduce the average time needed to find a failure, developers can enable test prioritization, which tries to run first the tests most likely to fail. The plug-in does not interfere with manual use of JUnit, and it uses unobtrusive signals to indicate its progress to an interested developer, without being overly distracting.

Future reuse: When reuse is impossible, design for future reuse. In some cases, the plug-in we wished to extend did not provide an extension point where we needed it, so it was necessary to cut and paste code from the existing plug-in into our plug-in. In these cases, we kept the copied code as close to the original as possible, so that if extension points are provided in the future, it will be easy to make use of them.

Minimal distraction: The plug-in uses common-sense heuristics to avoid annoying the user with obviously redundant information. If there are com- pile errors in the code under test, test failures are uninteresting. If two projects both reference the same test, its failure should be indicated only once. Any status change other than a newly failing test should be indicated only subtly, so that the developer can easily ignore it.

This paper is organized as follows. We first review related work on con- tinuous testing and related topics (Section 2). Then we describe the design of the continuous testing plug-in, both its user interface (Section 3) and technical architecture (Section 4). Finally, we describe opportunities to improve both our plug-in and the Eclipse frameworks on which it is based (Section 5), and it helped them produce correct answers faster and write better code. Staff said that students quickly built an intuitive approach to using the additional features. 94% of users said that they intended to use the tool on coursework after the study, and 90% would recommend the tool to others. Few users found the feedback distracting, and no negative effects on productivity were observed.

Continuous compilation : As soon as a developer writes code that con- tains a compilation error, Eclipse highlights the error in the text and the margin, and creates a task in the Problems view. This makes it easy both to quickly learn of problems, and to step through and fix problems in an or- derly fashion. With continuous testing, the developer gets the same kind of notification when writing or editing code that causes a test to fail. However, test failures differ from compile errors in that test failures sometimes cannot easily be tracked to a single line of code, and test failures can provide more information, such as a backtrace, than compile errors.

In this section, we put forth some of the salient design points of Eclipse that influenced the design of the continuous testing plug-in. We focus on the static structure and dynamic behavior of the auto-building framework and the JUnit launch framework. This is a high-level overview of the Eclipse design, omitting lower-level details where possible.

will consider each project as a simple container of source files. Each project also references an ordered list of zero or more builders, which are contributed through an extension point. Each builder is responsible for responding to incremental changes to keep project state consistent. For example, the Java builder uses a compiler to keep built class files up to date with the Java source files in the project, whereas the RMI builder keeps generated skeleton and stub files up to date with any RMI interfaces in the project.

From our experience in the design and implementation of this plug-in, Eclipse has shown great promise as a platform for the evaluation and distri- bution of experimental tools for software productivity. Individual components are well-designed for extensibility, both technically, and in terms of creating user metaphors that are easily extended to new functionality. The princi- ples and experiences discussed in this paper should prove valuable as more researchers look to Eclipse as a proving ground for new ideas in software en- gineering.

We intend to work with the developers of Eclipse to make the necessary changes to the plug-in and Eclipse to allow them to integrate even better. We will continue to support and promote the plug-in, to build a user base that can benefit from the functionality, provide feedback about their usage, and help prioritize future development. We hope that many developers will find continuous testing to be an effective way to work more quickly and confidently.

