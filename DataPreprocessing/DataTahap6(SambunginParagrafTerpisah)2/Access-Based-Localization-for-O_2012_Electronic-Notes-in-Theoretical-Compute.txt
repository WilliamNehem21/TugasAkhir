Access-based localization [8] is a two step procedure: First, memory locations accessed in code blocks are estimated conservatively using an efficient flow-insensitive preanalysis. Second, the actual analysis is run restricting input states of code blocks to the determined sets of accessed memory locations. Propagating smaller states improves performance of fixed-point computation w.r.t. the issuses discussed above. Additionally, smaller input states lower the number of necessary iterations as a reanalysis of a procedure is unnecessary if only those parts of the abstract state were changed that are not accessed in the procedure.

It has been shown that an interval-based analysis of function g taking into account this form of access-information [8] needs to consider only x to converge onto a sound over-approximation. Likewise, it is sufficient to restrict the input state of h to the interval that describes x. Variable y is not accessed in these functions; its corresponding interval prior to g (resp. f) is thus identical to the intervals after analyzing g (resp. h).

We call the approach presented first the access-based approach as the transferred input state is derived directly from access-information. Taking into account depen- dencies, we name the approach presented secondly the dependency-based approach. In the last approach, xslack is used as an anchor that relates x to its input value. Therefore, we shall refer to this approach as anchoring.

From now on, we refer to the set of constraints in o that are significant for f as Sigf (o). Without taking significance into account, dependency is a purely syntactic criterion to determine whether an octagonal constraint may be relevant in a callee. By considering significance as well, the constraints passed to a callee depend on the state of the octagonal abstraction. Intuitively, an octagonal constraint is propagated into a callee using the dependency-based strategy iff it is dependent and significant.

In principle, analyzing a concrete procedure f subject to an octagonal input state o amounts to applying the abstract counterpart f # of f to o. The output of the analysis is thus f #(o) = oout. Clearly, f # can be designed as the composition of the abstract counterparts of all operations that constitute f . Localization refines this approach by applying f # to a sub-state of o that is (often) strictly smaller than o. This section formally discusses our approaches to localization and provides arguments for correctness and optimality criteria in terms of maintaining precision.

We have implemented the different localization strategies for octagons in Java. Our framework provides a flow- and context-sensitive abstract interpretation in the octagon domain. The benchmarks we analyzed consist of a number of programs which, e.g., implement sorting algorithms or perform integer arithmetic. Without localization, i.e., considering all variables at all points in program, our analyzer runs out of memory after a few minutes, consuming approximately 1GB of RAM.

The overall results with localization are given in Tab. 1. There, Acc refers to the access-based approach, Dep to the dependency-based approach, and Anc to anchoring. Beside runtime, we determined the number of different procedure contexts found during the analysis, the average sizes of DBMs used to represent octagonal constraints, the total number of constraints, and also the portion of significant constraints. Interestingly, the numbers of variables traced along procedure calls using Dep and Anc is only slightly larger compared to Acc. Yet, interprocedural analyses using Dep and Anc are more precise.

Analogously to results reported by Oh et al. [8], we observe that localization decreases the number of necessary re-analyses of procedures. This is because it is often the case that only constraints in the octagon change that are irrelevant for the analysis of the callee. The smaller number of different contexts analyzed

Early approaches to localization mainly focused on reachability, which is a criterion much coarser than considering access-sets, with the expected drawbacks in terms of effectiveness. For a survey of related work in this field, we refer to [8] who give a thorough discussion in the context of introducing access-based localization. The authors [8] also extend localization for intervals from procedure boundaries to arbitrary code blocks. Adapting this approach is also possible for the octagon domain, using merely identical techniques.

Independently of the chosen numeric domain, the efficiency of access-based localization suffers from the fact that often global variables are carried along many nodes unnecessarily until they are finally accessed in a sub-routine, deep down in the call-tree. Most importantly, all global variables accessed in the program are considered in the input state of the main function. In [10], the notion of bypassing is introduced to mitigate this effect. The idea is to bypass the abstract values of variables to transitively called procedures instead of propagating them through the procedure bodies. This idea implemented for the interval domain can also be transferred to the octagon domain. However, due to the relational nature of octagons, this is technically more involved. At each call site, all implicit constraints need to be derived in order to propagate updated constraints and dependencies to callees.

Other related work can be found in work handling the large abstract states of complex abstract domains. Variable packing where only few variables can be related to each other is a way to make relational domains feasible with respect to memory consumption and analysis time [5]. For the octagon abstract domain an octagon packing [7], i.e., a collection of small packs of variables, is determined based on observable dependencies in the program. For example, the control variable in an if statement will be assigned to the pack that includes a variable accessed in the corre- sponding then block (and else block, respectively) as there is a direct dependency between these variables. Octagon packing has been successfully integrated into static analyzers, thereby reducing memory consumption to a reasonable amount while still achieving satisfying precision [2]. Using localization to reduce the size of abstract states can be seen as a method orthogonal to octagon packing. Both approaches reduce memory consumption and computational cost. By way of comparison, our approach guarantees maximal precision, whereas octagon packing does not as not all constraints are derived.

In [11], Venet and Brat report that packs of variables determined statically based on syntactic criterion do no always provided satisfactory precision. They consider the problem of using DBMs for the analysis that involves pointer variables and array indices. The evaluation of a dereference is then based on a base address and an offset, the values of both of which are extracted from the abstract state. Their solution is to create and merge DBMs dynamically, during the analysis, whenever an operation causes new relations between variables associated with different DBMs. This way all relations are derived at the cost of reorganizing DBMs perpetually. Furthermore, the procedure does not include localization so that many constraints are unnecessarily propagated along many paths.

In this paper, we have revisited access-based localization and identified drawbacks of approaches that use either only access-sets or syntactic dependencies between variables. Even though access-based localization has proven precise for intervals, (weakly-) relational domains such as octagons impose different needs on the local- ization strategy to capture the exposed relations without propagating too many redundant constraints. We have thus provided a dependency-based technique, which is based on the notion of significant constraints. The anchoring approach is, in turn, based on the idea of augmenting the input state with auxiliary (slack or anchor) variables to track the differences between values on input and output of a procedure.

