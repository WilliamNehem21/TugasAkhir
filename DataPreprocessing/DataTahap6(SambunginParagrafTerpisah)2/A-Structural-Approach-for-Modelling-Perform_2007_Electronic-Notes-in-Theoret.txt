In this paper, we discuss a structural approach to automatic performance modelling of skeleton based applications. This uses a synthesis of performance evaluation process algebra (pepa) and a pattern-oriented hierarchical expression scheme. Such approaches are important in parallel and distributed systems where the performance models must be updated regularly based on the current state of the resources.

This synchronisation respects the notion of bounded capacity, meaning that a com- ponent cannot be made to go faster by synchronisation. Thus the duration of the shared activity is governed by the minimum of the random variables associated with each of the contributing activities. In some cases a component is passive with re- spect to a synchronised activity, meaning that it will participate at whatever rate its partner component expects. This is denoted by the distinguished symbol T,

The skeleton hierarchy tree encapsulates most of the information provided in the description (the overall structural and component details of the system). Additional information is derived from this tree automatically, when needed (for example, the data dependency graph connecting the tasks). We shall now discuss these in detail.

Generation of pepa performance models, from a given description of a structured application, can be divided into three phases. In the first phase, the directed acyclic graph (which represents data dependency between task components) is derived from the skeleton hierarchy tree. This graph is then used in the following phases. In the second phase, the process definitions for each of the task components are determined. Finally, in the third phase, the overall system is modelled by combining the task components, and skeletal components, based on their hierarchical organisation. The final phase is important because it completes the performance model by establishing the synchronisation sets, which will be used by the model solver while synchronising task components at different levels of composition.

Furthermore, since enumerating all the cases can be quite involving, we shall condense the case investigations further by making some observations on the rela- tionship between the different interaction functions (based on the definition of the skeleton constructs, see Section 3). These observations are: (a) the Deal interac- tion function is a special case of the Farm, where probabilistic non-determinism in the Farm is removed by enforcing a round-robin data distribution policy. (b) the Pipeline interaction function is a special case of the Deal, where the source (or des- tination) list is a singleton set. Based on the later observation, discussion of cases involving the Pipeline will be ignored, since it is covered in the cases with Deal. We will, however, cover the combinations of Deal and Farm interaction functions.

To generate all the process definitions of all the tasks in the skeleton hierarchy tree, we traverse the hierarchy tree and invoke Algorithm 2 for all the nodes which is a task node. Once this is done, we have completed the second phase of performance model generation. We therefore proceed with the final phase where we define the synchronisation sets. Before we proceed, it will be worth recalling that the moveij and moveji activities, which correspond to the communications between tasks, will be used while defining these synchronisation sets.

All the process definitions generated at the end of the second phase only model the performance of each task component, independently of the others. Since the structured application is a cooperative manifestation of these tasks, they must be synchronised accordingly with respect to the level of hierarchical composition. This is done in the final phase of model generation, which we shall now discuss.

The model which we have generated so far is incomplete in two ways. Although we have the task definitions and the structure of their interactions, both computa- tion and communication rates are passive. Since active rates are necessary while performing synchronisation, we complete the model by introducing the relevant active rates to the model.

In this paper, we have discussed an automated approach which generates pepa per- formance models from skeleton-based applications. Such automatic approaches are important in systems where the model must be updated regularly, and dynamically, depending on the current state of the resources. We have demonstrated in a practi- cal setting the advantages of the generated models by contrasting the performances achieved through various task replication schemes.

