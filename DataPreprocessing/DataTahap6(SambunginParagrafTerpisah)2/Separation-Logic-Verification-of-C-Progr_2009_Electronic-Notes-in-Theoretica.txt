Separation logic [17,24] is a promising new approach tailored for specifying and verifying properties of heap allocated data. It supports local reasoning by allowing small specifications that speak only about memory footprints. That is, in order to specify how a piece of code works one only needs to deal with the part of the memory that the code actually accesses. This often leads to simpler specifications and proofs than one would have in other formalisms.

have been described in greater detail: Leroy and Blazy [19] describe a formal verification of a memory model for low-level imperative languages such as C; Moy [20] shows how unions and casts can be encoded as structure subtyping; and Norrish [23] deals with formalizing most aspects of C semantics in HOL. Separation logic has already evidenced promising results in verifying high- level procedural programs [4,5], and object-oriented programs [7,14]. Design of our verification tool has been influenced by [14], while the programming language constructs for specifying contracts are adopted from Spec# [3] and VCC [11]. Conceptually similar work to ours is [1] on verifying Cminor pro- grams using separation logic. Also related to our work is research in shape

Use of SMT solvers for automated verification of heap properties is also not new, see e.g., [6,18] or [26]. A closely related work with respect to using an SMT solver for checking validity of separation logic formulae is [22]: the authors use an SMT solver for checking validity of pure formulae (they do not, however, use it for congruence closure computation).

The rest of this paper is structured as follows. We begin with motivating our approach on an example in Section 2. Section 3 explains how we represent the C memory model by use of rewrite rules. We give the architecture of our prototype tool in Section 4, and then describe its key components: the symbolic interpreter in Section 5, and the theorem prover in Section 6. The final Section 7 gives concluding remarks and discusses future work.

Let us now move on to a more interesting example. The goal is to specify, implement and verify operations of a queue data structure. Due to page limits, we show the final annotation for one operation only, but we explain all the ingredients.

This section describes the C memory model that we use in our approach. Here the memory model refers to the formal description of the memory layout of different C objects (in particular, primitive types, structures, unions and arrays). The key feature is determining how to provide enough aliasing and anti-aliasing information about objects in memory to make operations based on pointer arithmetic feasible.

Type-safe languages such as Java or C# see memory as a collection of objects, and the aliasing between two objects can happen only if two pointers (of the same type) are pointing to the same object. This approach is not sound for C since in C objects can overlap almost arbitrarily, however, it can be extended to become sound and complete with respect to the byte-level C memory model (see [9] for a detailed discussion). The key ingredient is having a way to represent when an object is a structural descendent of another, and this is the step we follow as well.

The symbolic interpreter symbolically executes the control flow graph of each function in the CoreC*program. The state of the heap gets updated according to the symbolic execution rules. Since states of the heap are rep- resented with separation logic formulae, a support from a theorem prover is needed.

This paper described a methodology for automated modular verification of C programs against specifications written in separation logic that we imple- mented in a prototype tool. The tool is in an early stage of development and has been tested just on a handful of small examples. It performs at a rea- sonable speed; for instance, the queue example from Section 2 takes about 8 seconds to verify.

An important drawback is lack of termination guarantees. If the tool stops, then it has either proven the program to be correct against the specifications or has found a failing point. However, it may loop forever. In order to ensure termination, it would be sensible to apply abstraction in the spirit of abstract interpretation, as it has been done in the jStar tool [14].

