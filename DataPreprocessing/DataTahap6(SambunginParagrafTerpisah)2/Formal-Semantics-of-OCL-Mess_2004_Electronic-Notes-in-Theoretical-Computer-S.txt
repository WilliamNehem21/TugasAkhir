The latest OCL 2.0 proposal provides two semantic descriptions, i.e., a metamodel-based semantics that uses UML itself to associate the semantic domain with the language concepts and a formal semantics based on a set-theoretic approach called object model. Unfortunately, these two seman- tics are currently neither consistent nor complete, as (a) the formal semantics does not consider the newly introduced concept of OCL messages and (b) both semantics lack an integration of Statecharts and a semantic definition of state-related operations.

This article focuses on a formal semantics for OCL messages as a foundation for consistency among the two OCL semantics. We extend object models and present an extended definition of a system state that comprises all relevant information to be able to evaluate OCL expressions also w.r.t. OCL messages.

In the remainder of this article, a particular instantiation of an object model is called a system. A system is in different states as it changes over time, i.e., the (number of) objects, their attribute values, and other characteristics change during execution of the system. In the OCL 2.0 proposal, a system state

However, the formal semantics provided in the OCL 2.0 proposal is not complete, as it is not possible with the information given by a system state to reason about currently activated Statechart states or messages that have been sent. Thus, it is not possible to provide a formal semantics for state-related operations and operations on OCL messages.

The concept of OCL messages has been newly introduced in the OCL 2.0 proposal to specify behavioral constraints over messages sent by objects. It is based on work presented in [7,8]. Basically, an OCL message refers to a signal sent or a (synchronous or asynchronous) operation called. While signals sent are asynchronous by nature and the calling object simply continues its execution, synchronous operation calls make the invoking operation wait for a return value. In contrast, an asynchronous operation call is like sending a signal, such that a potential return value is simply discarded. For more details about messaging actions, see the action semantics of UML 1.5 [9, Section 2.24]. Note here that the UML action semantics also define broadcast signal actions, while a corresponding kind of OCL message is not yet defined.

To check whether a message has been sent, the hasSent operator ^ can be used, e.g., the expression targetObj^setValue(17) results in true iff a message setValue(17) has been sent to targetObj during execution of the considered operation. More examples can be found in [6, Section 2.7.3].

Subsection 3.1 explains the syntactical elements of extended object models. In Subsection 3.2, we then present an extended version of system states. This extension enables us to give a semantics to message-related operations that could so far not formally be defined.

Note that we do not further describe the tuple components of extended object models here. For more details on sets CLASS, ATT , OP , and ASSOC, readers are referred to the corresponding sources [6,10]. We also omit the formal syntax definitions for signals and Statecharts and refer to [5] for further details.

Additional runtime information has to be taken into account to be able to evaluate expressions that access OCL messages. This mainly concerns the currently executed operations and the histories of signals and messages sent. This relates to the local snapshots defined in the metamodel-based semantics for OCL 2.0 [6, Section 5.2].

Note that this identity is not quite correctly treated in the OCL 2.0 pro- posal, as the definition of OclMessageExpCS says that the number of messages sent to the target object is exactly = 1 (instead of > 0) [6, Section 4.3].

and an additional function to capture free variables. The set Post-Expr of valid OCL postcondition expressions is defined in the same way as Expr, but with additional rules for allowing operation oclIsN ew(), operator @pre, and a predefined result variable named result [6, Section A.3.2.2].

Based upon our previous work that already captures Statecharts and state- related operations, we presented further extensions to object models and sys- tem states, such that a formal semantics for OCL messages and corresponding operators and operations could be given. This article is therefore to be seen as a direct contribution to the finalization process of OCL 2.0.

For OCL messages, we used explicit call identifiers to distinguish messages sent from source objects to target objects. When returning from a synchronous operation call, this identifier can be used to update the corresponding param- eter values. This is an abstraction from the UML semantics that assumes that a specific reply object is generated and sent [9, Section 2.24].

