A set of laws for OCCAM was given in [18]. Rather than simplification via communication elimination, the focus there was to obtain normal forms and to define the semantics of the notation. Some laws for SPL are given in [15], with an SPL semantics based on fair transition systems (FTS), but communication elimination laws are not given there. In the framework of SVL++, some laws are given in [7] but they do not suffice for communication elimination.

This notion was introduced in [2] combining the notions of SPL module [15,8] and procedure. As modules, modular procedures can be composed in parallel, but may be invoked by procedure reference statements, which make explicit the names of all the interface channels and variables. Common variables are prohibited. The notation r ::= P (p) will be used for a procedure reference, where r and p stand for the result and parameter lists of the interface, and P is the procedure name. Modular procedures will be referred to more simply as procedures. An example of procedure is given below. Its procedure reference stands at the left, and the procedure body at the right.

Notice that r and p are variables whereas cr and cp are channels. r and cr are the results, and p and cp are the parameters of the procedure. The exact meaning of modes out and external in is not important here, since processes are disjoint and communication is point to point and half-duplex. The declaration at the head of a procedure body will be omitted often in this work. No common variables or channels are allowed.

A channel variable records, as a triplet, the value passed at a communi- cation event, a count reflecting the order of the channel event, and an in- put/output mark (i,o). When the event is internal, a dot replaces the in- put/output mark. For the above procedure, this set is O : {r, p, cr, cp}, where cr and cp are the auxiliary variables associated to the channels.

Some extended notions, needed in the paper are introduced next. An input/output computation (io-computation) records the value histories of both the variables and the channels of the procedure body during an execution. It has a row for each value change and a column for each variable or channel.

Its rows are separated in sublists by its internal communication event rows, constructed first as follows: their variable components are filled in with the values of the corresponding variables of the matching rows of the two io-behaviors, with the exception of the internal communi- cation event triplet, constructed with the value and the count of the two matching triplets. A dot will be placed in its third component, replacing the i and the o. This assumes deadlock freeness.

Justification	Let IR , IAg , and IBg denote the sets of io-behaviors of R, the alternative of A and the alternative of B, respectively, and IA and IB be the sets of io-behaviors of A and B, respectively. If the statement is a regular selection, then IAg and IBg are formed with the io-behaviors of IA and IB, respectively, whose first rows satisfy the boolean guard of g. However, if the statement is a communications selection, each io-behavior of IAg is obtained by post-coupling an io-behavior of the IAg of the last case to the io-behavior of to the send or receive statement in the guard g. The same is true for IBg.

Attention will be restricted to statements whose communications are under the scope of neither selections nor iterations. We will refer to these statements as bounded communication (BC) statements. The number of communication events generated by their execution is finite and constant.

The laws to be given below allow the elimination of communications from BC statements. Communication elimination for some extended forms, with indefinite iterations, will also be covered in next section. For each BC state- ment S we define a set I of internal channels, whose communications have to be eliminated. The rest of the channels involved in S are external in the sense that communication statements over these channels never match with other communications in S. The following are two intuitive communication elimination laws.

which captures the essential behavior of the pipelined processor software model. As this program makes explicit, the processor interprets programs with ALU register to register instructions only. The instruction register is ir. The destination and source register indexes are ir.rd, ir.rs1 and ir.rs2. Procedure alures gives the result of the ALU operation selected by ir.func. Integer n is the length of the program in mem.

The cout and cin names denote the lists of output and input channels respec- tively. Procedure Pipeline2 above has references to the procedures with inner parallelism, Pipeline2: Pipeline[IDP ar, EXP ar]. Pipeline is a procedure with one level of parallelism and two holes for the references to ID and EX.

