We show that all the ingredients of a graph transformation system can be spec- ified as labelled port graphs. Port graph rewrite rules are labelled port graphs consisting of two port graphs (the left- and right-hand sides) and a special node (the arrow node) that links ports from the left-hand side and right-hand side. For- mally, the arrow node defines a morphism which is used to give a single pushout semantics for rewriting. Since there is usually more than one way to apply rules to a graph to generate rewriting steps, a strategy expression is used to select the rule to be applied and the position in the graph where rules should (or not) apply. We define located graphs as labelled port graphs that include labels to specify the rewriting position and the subgraphs that should be protected (i.e., not rewritten). Rewriting derivations, controlled by a strategy, can also be represented as a labelled port graph, whose nodes are labelled by graphs and strategies.

ture to design and implement, so the implementation efforts can focus on this task, and since the rewrite rules are themselves graphs, the formalism is by construction reflective. Reflection is a key property in logical frameworks and facilitates the design of extensions (see, e.g., rewriting logic [23]).

The paper is organised as follows: Section 2 introduces the concept of labelled port graph as a generic structure, and presents the specific instance used in Porgy. Section 3 illustrates this structure with examples taken from various domains. Rules and rewriting are defined in Section 4, where it is shown that rules are also labelled port graphs and the rewriting mechanism on this structure is presented. Section 5 presents located port graphs as labelled port graphs. Derivation graphs, another instance of labelled graphs, are defined in Section 6 and used as a mechanism to visualise the dynamic behaviour of systems modelled by means of labelled port graphs, rewrite rules and strategies. Section 7 describes related works and gives directions for future work.

Definition 2.2 is generic in the sense that the set D of labels is actually a pa- rameter that can be instantiated in different ways. If D is empty, we obtain plain (unlabelled) port graphs, consisting only of sets of nodes with ports and edges con- necting nodes via ports; if D is a set of atomic labels, we obtain the notion of labelled port graphs defined in [1,2,12]. Richer definitions of labels have been pro- posed for graphs, which bring much more expressivity: for instance, in [25], the labels of E-graphs are represented by label nodes connected to edges and nodes, while in symbolic graphs, they are variables constrained by a set of formulas and interpreted over an algebra; in [9], attributed graph labels are the values of a given data algebra. Below we assume familiarity with basic notions of universal algebra (we refer the reader to [10] for details).

(a1 := v1,..., an := vn), where ai, called attribute, is a constant in a set A or a variable in a set XA, and vi is the value of ai. The elements ai are pairwise distinct. The first attribute in each label ll is its name and identifies the type of the label in the following sense: for all ll = (Name := v1,..., an := vn),

Labelled Port Graphs have been used to describe complex models in various do- mains: biology, social networks, interaction nets, capital markets, etc. We give examples below, including visual representations of system states (port graphs), obtained using Porgy. These examples illustrate the kind of labels supported in the current version of Porgy.

Molecular species are represented by labelled port graphs in a natural way: each molecule is represented by a node whose ports correspond to its binding or, for instance, phosphorylation sites. The attribute Name in each node identifies the type of species represented by the node. Attributes Colour and Shape have the same value for all nodes with the same Name. Ports have an attribute State indicating whether it is bound or phosphorylated and a related attribute Colour that reflects the value of the state.

an arrow node with a set of rewiring ports and a set of edges that each connect a port of the arrow node to ports in L or R. Each port has a label Type that can have one of three different values: bridge, wire and blackhole. The value indicates how a rewriting step using this rule should affect the edges that connect the redex to the rest of the graph.

In addition, the arrow node has two ports, labelled Left and Right, and edges connecting Left to all the nodes in L and Right to all the nodes in R, using a distinguished port Side in nodes of L and R. The arrow node also has the following predefined labels: a label Where that expresses a condition to trigger rule application, and Saturated, whose value is the list of ports in L that are not connected to a bridge, wire or blackhole port of the arrow node. These two labels are used to select appropriate matching morphisms and to ensure non-dangling conditions in the rewriting process.

PKA to a bridge port in the arrow node. This is because in the graph where this rule is applied, there could be other edges arriving to s2 from the outside. However, no edges can be connected to cAMP since its port is not connected to the arrow node: if an edge arrives to cAMP from the outside the Saturated condition fails and the rule does not apply.

In a located graph GQ, P is the subgraph of G made of nodes where the Pos label has value on, and related edges. This is the focus of the next step(s). Q is a protected subgraph, made of nodes with a Ban label on, where transformations are forbidden. We put the additional restriction that initially it is not possible to have the same node in the position and in the banned subgraph. P and Q are disjoint.

Labels are quite useful in this graph too. Edges have labels recording information on the rewriting step: the rule applied, the redex(es); in case of a probabilistic choice of transitions, the probability associated to the choice of this rule. Different types of edges can be visually distinguished thanks to labels Colour and Shape. For example, additional edges can be created as shortcuts between two states, for

Definition 6.2 [Symbolic derivation graph] A symbolic derivation graph for a strat- egy language L is a labelled port graph where nodes have two distinguished labels: Current graph is a located port graph, and Strategy is an expression of the strategy language L. Edges are labelled by strategy expressions. Each node has two ports, named Parent and Successors, respectively.

Semantic considerations for labelled port graph rewriting as defined in this paper need to be addressed. In [13], we show that a large subclass of labelled port graphs are attributed graph structures as defined in [22], and explore the correspondence between the operational notion of rewriting given above and the construction of single pushout (SPO) objects. However these first results have to be extended to the whole class of labelled port graphs and graph rewriting as defined in this paper and covering for instance node duplication and port graph cloning, in the direction proposed by [7].

graphs, which justifies to consider DPO/SPO rewriting semantics for labelled port graphs. Symbolic labels may in particular allow us to take into account constraint satisfiability. In this line, we plan to consider a more abstract notion of constraint where graph structures and labels interpreted in semantic domains are used to generate graphs. Such a generic notion of constraint-based labelled port graph may be interesting for reasoning on graph rewriting, narrowing and completion.

In this work, strategies are expressions in a formal language to control rule application. An open question is to represent strategies as labelled port graphs, in a way similar to the representation of strategies as rho-terms in rho-calculus [6]. The first step is already achieved since a strategy reduced to one rule is already a labelled port graph and preliminary work in this direction is provided in [3]. This would open the way to design a reflective logical framework based on a rho-graph calculus.

