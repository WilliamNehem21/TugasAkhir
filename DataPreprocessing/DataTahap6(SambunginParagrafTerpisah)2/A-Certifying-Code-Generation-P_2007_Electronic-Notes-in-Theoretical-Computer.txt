Most software systems are described in high-level model or programming languages. Their runtime behavior, however, is controlled by the compiled code. For software in critical systems, it is of great importance that static analyses and formal methods can be applied on the source code level, because this level is more abstract and better suited for such techniques. However, the analysis results can only be carried over to the machine code level, if we can establish the correctness of the compilation. Thus, compilation correctness is essential to close the formalization chain from high-level formal methods to the machine-code level.

Compared to compiler certification, the technique of compilers certifying their re- sults has two advantages. First, the issue of implementation correctness can be completely avoided, that is, we do not have to trust the implementation of the compiler algorithms on a hardware system or prove it correct (cf. [19,5] on this problem). Second, similar to the proof carrying code approach ([14,13,1]), the tech- nique provides a clear interface between compiler producer and user. In the certified compiler approach, compiler users need access to the compiler correctness proof to assure themselves of the correctness. Thus, the compiler producer has to reveal the internal details of the compiler whereas the translation certificates can be in- dependent of compiler implementation details. The disadvantages of the certifying compiler approach is that users have to check the certificates for each (critical) compilation and this check might fail if the compiler has a bug.

This paper presents details about the construction and extension of the code generation phase as well as the checking of the certificates. We emphasize on the practical applicability of our approach. This means in particular to optimize the time it takes to check a certificate. The main technical contributions of this paper are:

The structuring and optimization of the compiler generated certificates to mini- mize the time it takes to conduct the proofs. For this goal, we distinguish between program independent parts, parts that have to be conducted once per program and parts that have to be done for each instruction in the program separately. In particular we present a solution to prove certificates more efficiently correct by proving the injectivity of a mapping function once for each program enabling us to abandon a complicated case distinction for each instruction in the program.

We describe the intermediate language, the generated MIPS machine code and their relation in Section 2. The code generation algorithm and the certifying correctness proofs are described in Section 3. Section 4 describes the automation and perfor- mance enhancement of the certifying process. In Section 5, we evaluate our work. Related work is discussed in Section 6 and a conclusion is drawn in Section 7.

The codegeneration phase as implemented in our compiler takes an intermediate language program and outputs MIPS assembly code. In addition, several theory files for use with the Isabelle theorem prover are created. These files are a collection of facts about the program and compilation process as well as subproofs. At the very beginning the original intermediate language program is converted to an Isabelle representation and written in a separate file. Likewise at the end the MIPS assembly

This section deals with performance issues of our certifying code generator and its Isabelle proofs. The time it takes to generate and conduct the proofs is crucial for the acceptance of the certifying compiler approach in industry and science. We present strategies that made the conduction of the proofs much faster than our first naive approaches. The time the proof generation within the compiler takes is negligible in the code generation phase. The actual code generator takes almost linear time, including the part that writes the Isabelle representation and proofs into files. However, the verification of the proofs within the Isabelle theorem prover takes a comparable large amount of time and it was a nontrivial task to reduce this time. This section presents our implemented solutions as well as estimations of their runtime complexity.

In this section we evaluate the implementation of our code generation phase. We focus on crucial parts of our implementation and show some statistics. We have implemented a complete compiler comprising a frontend, an intermediate repre- sentation with optimizations as well as a code generation phase including register allocation. The code generation phase presented in this paper is well integrated into

It can be seen that with doubling the amount of variables in the fibo program the verification of the code generation takes nearly twice as much time. The sorting algorithms take longer due to the processing of more and complicated instructions. Without the injectivity proof from section 4.3 all of these proofs would fail due to ressource limitations. However with intermediate language programs containing less than ten variables both approaches deliver comparable results.

The original codegeneration phase comprises 334 lines of ML code. The proof generator has 864 lines of additional code. Note that both proof generator and compiler do not belong to the trusted computing base (TCB). A more sophisticated code generation phase could easily grow to more than 10000 lines of code. However, the proof generator part would stay almost the same.

Our academic prototype shows that certifying code generations is in general feasible for realistic compilers.  It turned out that the time it takes to conduct a correctness proof in Isabelle/HOL is crucial. Most of the time complexity gets in because of linear lookup operations in Isabelle datatypes. The advent of more efficient datatypes in Isabelle/HOL can decrease the time and time complexity to conduct the correctness proofs significantly.

