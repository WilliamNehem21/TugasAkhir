Formal verification within interactive or automated theorem provers has become more and more important during the last ten years due to several reasons: First of all, machine proofs guarantee that no special cases have been overlooked and, hence, that the verified properties will indeed hold under all specified circumstances. Secondly, mechanized theorem provers allow for managing even large correctness proofs for large systems that cannot be managed by humans without machine help due to sheer complexity. And last but not least, the efficiency and user-friendliness of theorem provers has improved so much over the last years that they can be used in real-life verification problems. Nevertheless, there are still many unsolved problems. Especially the question how proofs are to be formalized in a theorem

In recent years, coalgebraic methods, in particular coinduction, have gained in- creased interest and importance in the specification of and reasoning about state- based systems [10]. In Subsection 3.1 we summarize the most important concepts in this area. In Subsection 3.2 we show how the coinductive definition and proof principle can be used in the theorem prover Isabelle/HOL [15].

Coalgebraic types are available in Isabelle/HOL in the extension described in [17]. This extension makes use of coinductively defined sets, a definition principle avail- able in Isabelle/HOL, and uses it to define lazy lists. As an example, consider the coinductive definition of possibly infinite lists as stated in [17]. The following definition specifies the set of lazy lists llist (A) over a given set A.

Lately, also coalgebraic methods have been used successfully in the specification of and reasoning about programming languages and systems. In [7,9], the seman- tics of object-oriented programming languages has been defined coalgebraically. The goal of the VFiasco project [8] is the verification of an operating system with coal- gebraic methods. [19] describes the coalgebraic class specification language CCSL. Coalgebraic proof methods are not the only formalism capturing the characteris- tics of semantics for non-terminating programs. One can also use labeled transition systems [13]. Bisimulation can be used within both formalisms. Our notion of bisimulation with collapsings (operating on coalgebraic datatypes) und the notion of weak bisimulation [13] (operating on labeled transition systems) may be used for

In our own work [1] we have proved a dead code elimination algorithm as used in compilers correct using bisimulation on Kripke structures. In [5], we describe how coalgebras and coinduction may be used in compiler verification. Finally, our work on formalizing and transforming data flow dependent computations [2] also shows, as the work presented in this paper, that the choice of formalization is vital for the proof success when using theorem provers.

