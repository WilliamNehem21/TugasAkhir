Creol [9] allows explicit control over data-flow synchronisations. In [2], Creol has been extended to support first class futures, although the future access is explicit (using get and await ). ASP [4] and ProActive [3], have transparent first-class fu- tures. Thus, the synchronisation is transparent and data-flow oriented. In Ambi- entTalk [5], futures are also first-class and are transparently manipulated; but the future access is a non-blocking operation: it is an asynchronous call that returns another future. This avoids the possibility of a dead lock as there is no synchroni- sation.

This differs from the approach adopted in other frameworks where access to a future is blocking. In [9], all processes interested in the future are registered as observers. When the result for the future is computed, all the registered observers are notified; this is very similar to eager-message based strategy as specified in [10]. In [16] a safe extension to Java futures is proposed, but with explicit creation and access.

In [2], the authors provide the semantics of an object-oriented language based on Creol [9]; it features active objects, asynchronous method calls, and futures. They provide a proof system for proving properties relating to concurrency. The model is multi-threaded, with only one thread active at a given time. Our approach is quite close to this work except that we study a component model featuring high level of abstraction, and hierarchical composition.

In [11], a formalisation of the Fractal component model using Alloy, a specification language, is presented. Fractal allows for hierarchical composition of components, and separation of functional and non-functional concerns. The authors provide a analyser to check the consistency of model, they define key invariants and other properties of interest. Compared to [11], we consider asynchronous components and focus on the component dynamic behaviour. This is crucial when specifying future management procedures.

Our work extends [8] which presents a component model giving a semantics to GCM, including hierarchical components, asynchronous communication, and first class futures. Building on the structural description provided in GCM, [8] for- malises the component composition and communication semantics in the presence of futures. In order to prove properties related to the implementation of futures, we have extended [8] with the precise definition of future update strategies, including semantics and constructs for the management of futures. With mechanised proofs, we show that our formalisation is complete and enables proofs on properties on fu- tures and their update strategies, thus ensuring correctness of the ProActive/GCM implementation.

Our model inherit most of its structure from GCM. GCM allows hierarchical com- position of components. A coarse-grained component may be formed by compo- sition of several fine-grained components. A component containing one or more subcomponents is referred to as a composite component. Primitive components do not contain other components, they are leaf-level components that implement the business functionality.

First class futures can be updated using different strategies [4,10,14]. We classify those strategies as either eager or lazy. Strategies are called eager when all the references to a future are updated as soon as the future value is calculated. They are the future. For this, all components receiving the future must register themselves as a future recipient. Finally, the lazy home strategy is the lazy version of eager home strategy where the future values are transferred on-demand: accessing a future reference triggers the future update.

form of rules is due to the component structure. Classically there are two rules for stating that a component is willing to send a communication (one for primitives and one for composites). Additionally, as there are three kind of bindings (from a parent component to a subcomponent, between two subcomponents, or from a subcomponent to its parent), there are three kind of communication rules (resp.

RcvResultComposite(1): This rule expresses future update for a composite component which is the destination of the update. At the component N , the state s is updated such that the new value v for the future f , replaces the old value inside both the results and queue. The values for any futures inside v should be sent to N , this is recorded in the RL list.

The reduction rules for the primitive components are similar and appear in Appendix A. We only show one of the rules below. RcvResultPrim expresses the future update for a primitive component. All references to the future f are replaced with the new value v. Entries are made in the FRL for any futures present inside v. Interaction between the component semantics and the internal state of the primitive is enabled by triggering transitions on the primitive behaviour, here ReceiveResult.

First, the definition of the component structure and the component semantics are directly translated from the preceding sections as we will show below. Then this section will describe the properties we proved using our formalisation. This is clearly the most innovative part of this paper as it shows that our formalisation is able to handle mechanised proofs entailing reasoning on components, their structure, and futures. While the formalisation represents a few hundreds lines of code, the proofs are much longer (above 5000 lines) and entail reasoning interleaving component structure, semantics, and future registration aspects.

We now have sufficient formal constructs and tools to express future update strategies and to study their properties. This work showed that it is possible to formally prove completeness and correctness of our future update mechanism, and of the corresponding implementation in ProActive/GCM. The proofs are relatively long due to the numerous reduction rules, and the rich component structure, thus a lot of cases had to be considered. One of the main difficulties was to design the good representation for our model in the Isabelle theorem prover. A crucial point during the specification phase was to find the good Isabelle/HOL abstraction to represent the component structures. We think we found a good balance between expressiveness and abstraction, that allows formal reasoning but is close enough to the component model implementation.

