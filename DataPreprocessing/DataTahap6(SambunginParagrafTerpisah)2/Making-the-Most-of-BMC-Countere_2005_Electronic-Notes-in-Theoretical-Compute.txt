The value of model checking counterexamples for debugging programs (and specifications) is widely recognized. Unfortunately, bounded model checkers often produce counterexamples that are diffi- cult to understand due to the values chosen by a SAT solver. This paper presents two approaches to making better use of BMC counterexamples. The first contribution is a new notion of counterex- ample minimization that minimizes values with respect to the type system of the language being model checked, rather than at the level of SAT variables. Greedy and optimal approaches to the minimization problem are presented and compared. The second contribution extends a BMC-based error explanation approach to automatically hypothesize causes for the error in a counterexample. These hypotheses (in terms of relationships between variables) can be automatically checked to de- termine if a causal dependence exists. Experimental results show that causes can be automatically determined for errors in interesting ANSI C programs.

1 This research was sponsored by the Gigascale Systems Research Center (GSRC) un- der contract no. 9278-1-1010315, the National Science Foundation (NSF) under grant no. CCR-9803774, the Office of Naval Research (ONR), the Naval Research Laboratory (NRL) under contract no. N00014-01-1-0796, the Army Research Office (ARO) under contract no. DAAD19-01-1-0485, and the General Motors Collaborative Research Lab at CMU. The views and conclusions contained in this document are those of the author and should not be interpreted as representing the official policies, either expressed or implied, of GSRC, NSF, ONR, NRL, ARO, GM, or the U.S. government.

A model checking counterexample is intended to be read by a person and used for debugging. Ideally, such a counterexample would be the most succinct and easily comprehensible witness to the existence of an error. The utility of small (in various senses, including length) counterexamples is widely recog- nized. Minimization of counterexamples, both in bounded [23] and explicit- state [14] model checking is a topic of ongoing research.

these formulas for satisfiability typically return the first satisfying assignment produced. The counterexample values, therefore, are highly dependent on the decision heuristics used by the SAT solver. That these choices may result in needlessly large values for the actual program variables is independent of the issue of unnecessarily complete assignments addressed by other minimization work [23]. The issue is an artifact of the bit-level translation; however, using an integer-based technique such as UCLID [5] would not preserve the proper bit operation and overflow semantics of ANSI C.

In this case, the decision heuristics used by ZChaff [22] assign 1 to a large number of bits. This results in large values for the program variables, making it difficult to follow what is happening. This problem, already evident in a small example program, is greatly exacerbated when many variable values are involved.

This paper presents two approaches to value minimization. The first is a greedy approach that makes use of incremental SAT (Section 4.1), while the second solves an optimization problem in order to guarantee true min- imality (Section 4.2). Both approaches are used for counterexample length

The second issue addressed in this work is that of making better use of counterexamples. Minimization directly improves the usability of counterex- amples. Error explanation [15] provides information about the causality of errors beyond that contained in the counterexample alone. The explain tool [16] automatically generates explanations for CBMC counterexamples, based on the counterfactual theory of causality proposed by David Lewis [21].

Minimization of counterexample length has been addressed in various contexts, including heuristic approaches [9,14,13]. Other kinds of minimization, based on game-semantics or minimal SAT assignments [18,23] have also appeared. The approach presented here for minimizing counterexample values can also be used to minimize counterexample lengths.

The algorithm continues with the next guard from the sorted list until all guards have been used. The heuristic approach only then attempts to minimize the variables that are used in the counterexample trace. Because the guard values are now fixed, the only values minimized are those that will appear in the counterexample: assignments guarded by false conditions are not taken into account. Alternatively, one could attempt to minimize first values and then execution steps.

values during execution of the program. Therefore, the sum that is minimized is over all program variables after loop unrolling and static single assignment [2], in this case |a#0| + |a#1| + |a#2| + |a#3| + |a#4| + |b#0| + ...

For the MediaBench benchmarks, the results are mixed. The greedy heuris- tic is typically slower than the true optimization, but results in smaller values in some cases (the values are a secondary goal, and larger values in the optimal algorithm can be caused by different control flow traces computed in the first stage). On two benchmarks, hardly any minimization is achieved by either algorithm. These benchmarks make heavy use of large lookup-arrays, which are computed at run-time.

Find an execution b such that (1) c does not hold and (2) the distance d(a, b) is minimal. b is an execution that is as similar as possible to the counterexample a, except that the potential cause c is present in a but not in b. If the error e is present in b, it is not causally dependent on c.

and the method implemented in CBMC is that no causality checking is done for (1) comparisons with constants and (2) comparisons with temporary re- sults that are never stored in a variable (i.e. x > (y + 50)) are not checked for causality. On the other hand, comparisons between values that do not appear in guards together are checked. Causal dependencies that are directly present in a guard in the source code are generally not as difficult to detect as indirect dependencies: a change in guard value is likely to appear in the explanation. For this reason, it seems at least reasonable to expect that the current tradeoff is often the correct choice. More extensive evaluation will be needed to determine if a source code-mining approach is preferable.

