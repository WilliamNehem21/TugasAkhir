There is a substantial body of related work on Java logics, semantics and theorem proving tools, such as, for example, [16,14,13,15,9,20,17,2,3]. We discuss this related work in Section 6; we also discuss there work closer to ours such as the Maude ITP [4], on which our tool is based, the ASIP-ITP tool [6,22], and of course the JavaFAN project [7,8], to which this work contributes at the theorem proving level. The rest of the paper is organized as follows. The CPS semantics of our Java fragment is summarized in Section 2. The first-order semantics of Hoare triples based on the initial algebra semantics of the language is explained in Section 3. Our Hoare logic and its justification are treated in Section 4. The mechanization of such a logic in the Java+ITP tool, and its use in examples are discussed in Section 5. Section 6 treats related work and conclusions. The related technical report [24] contains a mathematical proof of correctness for the loop rule, and two proof scripts for Java programs.

A program variable will not be directly mapped to its value but to a location in the store. This leads to a two-level mapping, of variables to locations and of locations to values. The LOCATION module defines what a location is, an example location is l(17). It also shows how to concatenate multiple locations together, as we generally work on lists of expressions, etc.

the point of view of program verification, as shown in [6,22] for a very simple lan- guage. But a more abstract concept of environment/stores does not work nicely with the side-effects and hiding that are possible in our language, for which the concrete variant we have chosen is preferable. Furthermore, this will make it easier to extend this subset of Java to a more complete version of Java in the future. In contrast, a more abstract definition of state would not allow more complex information, like exception, loop, or lock information, to be explicitly stored.

Thanks to this structure we can check for termination of a program by simply checking the sort of the state. If it is of sort SuperState, there is still some contin- uation, and therefore code, left and the program has not yet terminated. If instead the resulting state is a WrappedState, we know that all code has been executed. The definition of what happens to an empty continuation needs to support this and does so.

not change the state. Whenever the state S is not obvious, we will fall back on the evalTst notation. The other way we use t in is in the code part as usual (within if or while constructs) or just for its possible state change as described above. The different uses of t are illustrated in our Hoare rule for conditionals,

false. In the state before the final state it did indeed evaluate to false, but its side effect could cause its next evaluation to be true again. To prevent this, the Hoare triple (q) has to be added to the proof obligation of the loop rule.

In conclusion, we view Java+ITP as a research vehicle to investigate modularity and extensibility of programming languages and of Hoare logics. It has served us well for this purpose, by uncovering subtleties in the Hoare logic needed for Java not present in toy languages, and not even present in the Hoare logics of Java tools like Jive. Keeping the compositional Hoare logic reasoning at the source code level is also one of the goals that, in contrast to other approaches, we have advanced. But of course this is just a snapshot of work in progress. Our Java fragment is still quite modest, so we should soon add new features to it such as exceptions and objects; we expect this to be easy thanks to the CPS semantics. After this, threads and concurrency should also be added, and Hoare rules for these new features should also be investigated. Our goal is of course modularity, so that our Hoare rules will be applicable not just to Java, but to any other languages using some of the same features in a modular way, but this still remains an exciting goal for the future.

