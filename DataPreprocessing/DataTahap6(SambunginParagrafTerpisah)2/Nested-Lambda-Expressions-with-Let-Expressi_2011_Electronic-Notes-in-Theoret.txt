More and more C++ applications use template metaprograms directly or indirectly by using libraries based on them. Since C++ template metaprograms follow the functional paradigm, the well known and widely used tools of functional programming should be available for developers of C++ template metaprograms as well. Many functional languages support let expressions to bind expressions to names locally. It simplifies the source code, reduces duplications and avoids the pollution of the namespace or namespaces. In this paper we present how let expressions can be introduced in C++ template metaprograms. We also show how let expressions can be used to implement lambda expressions. The Boost Metaprogramming Library provides lambda expressions for template metaprograms, we show their limitations with nested lambda expressions and how our implementation can handle those cases as well.

C++ template metaprograms are functional programs [7,11]. Unfortunately they have a complex syntax leading to programs that are difficult to write and understand. Template metaprograms consist of template metafunctions [1]. There may be sub expressions that are used multiple times in the body of a metafunction, which has to be copied leading to maintenance issues or moved to a new meta- function leading to namespace pollution. The ability to bind expressions to names locally in metafunctions could simplify both the development and maintenance of C++ template metaprograms.

The Boost Metaprogramming Library [17] provides tools to build lambda ex- pressions for algorithms executed at compilation time. Arguments of the lambda expressions are called 1, 2, etc. This causes issues when programmers have to create nested lambda expressions inside other lambda expressions. The solution we present for let expressions can be used to implement lambda expressions in C++ template metaprograms that can express nested lambda expressions correctly. A library implemented based on the ideas presented here is available at [18].

The rest of the paper is organised as the following. In section 2 we detail the concept of let expressions. In section 3 we present our approach to add let expressions to a functional language, that has no built-in support for it. In section 4 we present how our approach can be used to implement nested lambda expressions. In section 5 we extend our approach to support recursive let expressions. We present future works in section 6 and we summarise our results in section 7.

Most functional languages supporting let expressions have built-in support for them in the language. These constructs are part of the language and the compiler has to deal with them. Template metaprogramming was not a design goal of C++ and has no compiler support for constructs like let expressions. In this section we present how let expressions can be added using only standard C++ features.

Lambda functions provide a solution to this issue. It is a technique for im- plementing small utility functors in-place in the middle of a piece of code. These functions have no names unless we store them in variables. This solution makes implementing the functors for generic algorithms in-place possible.

It is a metafunction class [1] taking the name of the argument and the body of the lambda expression as arguments. When an argument is applied on the metafunction class, it uses let to bind the argument to the name in the body. We leave the extension of it to support more than one argument as a future work. Using lambda the above example can be implemented the following way:

Let expressions are one of the basic building blocks of many functional programming languages, like Haskell, Lisp, etc. We have shown that support for expressions can be added to C++ template metaprogramming, a functional language without built-in support for this. We have also shown how let expressions can be used to add support for lambda expressions. We have built a library supporting lambda expressions and let expressions for C++ template metaprogramming [18]. Using our let solution a fundamental improvement can be achieved for the Boost Metaprogramming Library. We have shown that lambda expressions built following the approach presented in this paper can deal with nested lambda expressions as well.

