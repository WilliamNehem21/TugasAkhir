Assertion-based dynamic verifiers automatically pick up execution traces, which satisfy or violate certain property assertions, during the simulation of DUVs (De- sign Under Verification). The automation can significantly reduce the verification cost and promote the design quality [12]. Therefore, assertion-based verification is becoming a more and more important engineering practice.

Alternating Finite Automata (AFA) [4] are exponentially more succinct than NFA in expressing temporal logic formulas. The size of resulting AFA is linear to that of f . Feikbeiner and Sipma [9] proposed three algorithms to check at run-time whether a reactive system satisfies a LTL specification by AFA. Those algorithms traversed an AFA in different ways: breadth-first search, width-first search and

PSL has four layers of language structures: Boolean, temporal, verification and modelling. The temporal layer is the heart of PSL. It is used to describe complex temporal relations between signals. The temporal layer of PSL supports regular expressions, linear temporal logic and branching temporal logic. Here, we work on formulas in regular expressions and linear temporal logic.

The until! constructor is different from abort. For f abort b, it is unnecessary to verify f any more when b is asserted. But for f until! b, even if b is asserted already, one must keep on verifying the strong satisfaction of f on all words starting before the assertion of b.

U is a set of statements which update local variables whenever the transition takes place. For instance, {c1 := c1 + 1, c2 := a} states that c1 will increase by 1 and c2 will get the value of a. We do not allow a U to have multiple assignments which updates a common local variable .

For a state with external transitions,  it has an internal transition (s, trueLV , us, {s}). The internal transition is triggered if the state has no more enabled internal transitions and it is still not the time for external transition scheduling. By the internal transition, a state waits in the current state for the next clock event. Thus, samplings on V are executed synchronously.

The second clause of Definition 4.3 will not trigger the self-loop transition (s, trueLV , us, S) provided that there are active states which have enabled internal guards other than trueLV . Meanwhile, the clause removes infinite loops of trueLV guarded transitions which are regarded as chaos [15] or live-lock [19].

Once the the conditions for strong accepting [16] hold, the transitions T4 and T5 move a monitor to the strong accepting state qs. T4 is triggered from the pending state. If the strong accepting holds at the first sampling, T5 is expected to take place.

Now, let us have an analysis on the time complexity of the verification process by our dynamic verifiers. Since we have DAGs represent all possible runs, we need not try all branches for searching strong satisfying or violating words. Therefore, the time complexity of our approach is linear to the depth of simulation. The good result comes from features of PSLSimple which emphasizes that conveys the idea that for a successful synchronization, both ss(r1) and ss(r2) shall be active and both of them have common histories of universal choices. The update part activates sf and assigns the T.pop as histories to sf . T is a temporary variable. It is just the common histories of ss(r1) and ss(r2). T.pop removes the branching time which is pushed into historic tress on leaving s0. Both ss(r1) and ss(r2) are deactivated once the automata reaches sf .

By this example, we can also see the effect of the trueLV guarded self-loop transition. By the semantics of PSL [7], The length of a SERE is counted on clock events. Internal transitions within two external transitions do not take time. It may takes different internal transitions to reach ss(r1) and ss(r2). With the self-loop transition, ss(r1) will not miss the synchronization with ss(r2) only if ss(r2) can be active in the current clock cycle.

Icarus-Verilog is a package of back-end tool kits for the Verilog HDL as described in the IEEE-1364 standard [1]. It includes a compiler iverilog,a simulator VVP, an XNF (Xilinx Netlist Format) generator and an EDIF FPGA netlist generator. For batch simulation, the compiler iverilog transforms Verilog code into some interme- diate assembly codes called vvp. The simulation engine VVP reads the vvp assembly codes and outputs the result in Value-Change-Dump (vcd) format. The GTKWave is a wave viewer. It interprets the vcd files and paints the signal values. The Icarus-Verilog/GTKWave combination makes a small but complete Verilog design environment. However, none of them supports assertion-based dynamic verification. We enhance Icarus-Verilog and GTKWave with new functionalities as plugins.

In addition, we plan to extend our approach to specification assurance meth- ods. Conflicting properties will put verification effort into vain. For developing a specification-centric methodology, we must ensure the consistency of properties before handing them out. Besides these, automatic test generation from PSLSimpleis also an interesting topic to us.

