We describe a true-concurrent approach for managing dependencies between distributed and concurrent coordinator components of a long-running transaction. In previous work we have described how interac- tions specified in a scenario can be translated into a tuples-based behavioural description, namely vector languages. In this paper we show how reasoning against order-theoretic properties of such languages can reveal missing behaviours which are not explicitly described in the scenario but are still possible. Our approach supports the gradual refinement of scenarios of interaction into a complete set of behaviours that includes all desirable orderings of execution and prohibits emergent behaviour of the transaction.

We describe how reasoning against order-theoretic properties of vector languages can identify missing behaviours that infer additional scenarios. These were simply unthought in the initial design specification or indicate emergent behaviour, e.g. due to the subtle interplay between concurrency and nondeterminism in the inter- action. Our approach is effectively used to elaborate the initial scenarios of interac- tion to more comprehensive ones, which are gradually refined to exclude emergent behaviour and include all desirable orderings of execution.

At this stage it suffices to understand that each transaction vector provides a snapshot of behaviour that captures what actions have already occurred and on which part (component) of the transaction. In describing the behaviour of a transaction however we are interested only in those vectors describing (orderings of) actions that we expect the coordinator components to engage in during the course of the transaction execution. In other words, for a given transaction T we are interested in a particular subset of all possible vectors formed over T .

In describing the behaviour of a transaction we are interested in the actions (acti- vations) on its various components. These are captured in our model using column vectors. Thus, instead of considering all possible transaction vectors we would like to be concerned with those obtained by concatenations with column vectors only. This gives the behaviour of the transaction in terms of actions of its coordinator components and can be used to enforce the coordination of the underlying services.

We have seen that transaction vectors are obtained by coordinate-wise concate- nation. Hence, they can be seen to be built up starting from the empty vector by a series of concatenations with column vectors which represent actions. The study of vector languages in [16,9] shows that in order to ensure that vectors considered are the result of concatenations with column vectors only, the set of transaction vectors must satisfy certain properties. We introduce these properties next.

There are some cases however in which this rationale does not apply. In par- ticular, locations within different operands of an alt or par need to be treated differently. This is because we have to take into account the various execution se- quences that are possible when encountering these interaction fragments. Note that a location is also used to mark the beginning and the end of interaction fragments superimposed on the diagram. The first location of each operand in an alt or par fragment is considered in relation to the start location of the fragment rather than its immediately preceding location. The vectors of the end location of an alt frag- ment with k operands are considered in relation to the last location of each operand - to reflect the fact there are k alternative scenarios. The vectors of the end location of a par fragment are carefully obtained to reflect the fact the actions appearing within are effectively unordered. Full details of the formal construction behind the translation can be found in [8].

