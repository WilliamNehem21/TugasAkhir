We illuminate important aspects of the semantics of higher-order functions that are common in the presence of local state, exceptions, names and type abstraction via a series of examples that add to those given by Stark. Most importantly we show that any of these language features gives rise to the phenomenon that certain behaviour of higher-order functions can only be observed by providing them with arguments which internally call the functions again. Other examples show the need for the observer to accumulate values received from the program and generate new names. This provides evidence for the necessity of complex conditions for functions in the definition of environmental bisimulation, which deviates in each of these ways from that of applicative bisimulation.

calculi [7], and languages with I/O [33]. However, several recent bisimulation se- mantics of languages (stateful and pure) with higher-order functions are based on environmental bisimulation [31,32,27,15,5,14,16], a definition with significantly more complex conditions. Despite its applicability to numerous higher-order languages, the additional complexity of environmental bisimulation has not been sufficiently justified. The question we ask in this paper (which we answer in the affirmative) is whether this complexity is necessary.

In a stateful language (or a language with names), the necessity of the first devi- ation is quite plausible. Accumulation is needed because a function may return a different value the second time it is applied. But the necessity of resourceful argu- ments appears more questionable. Even more so in a language with exceptions and polymorphism.

In this paper we investigate two versions of environmental bisimulations, one with no accumulation and one without resourceful arguments. We emphasize the bisimulation without resourceful arguments since it is the more subtle. We show by examples that these bisimulations are unsound in an array of languages that use state, exceptions, names, and polymorphism. In this way we identify common aspects in the behaviour of higher-order functions in all of these languages, and to generate fresh locations, which we call private since the context of the term has no direct access to them. The particular selection of the gensym operation leaves the semantics unaffected. Thus, without loss of generality, we assume that there is a countably infinite set of locations that is disjoint from the range of gensym. We call these locations public and use them in the following section as the domain

When the context calls a function, the public state provides additional commu- nication between a function and its context, besides the argument and the result. It is essentially another argument to the function and, when the function returns, it is another result which needs to be ultimately pattern-matched. Note that this is not the case for private state since the context has no access to it.

As in the applicative setting, a relatee is organized in three zones (separated by semicolons), representing public information and the two situations that we want to relate. Here the public information contains the type of the public state, besides the types of the functions. The other two zones contain the private state (and its type) that may be used in the functions.

so that C4[M4] returns false and C4[Mj ] returns true. Note that the context C4 employs accumulation: it uses the function f, obtained before the application of g, as an argument to h, obtained as a result of the application of g. The terms M4 and Mj are no-accumulation bisimilar, because by the time a non-accumulating context has obtained h by applying g, it has discarded the function f.

Evidently C5[M5] evaluates to true while C5[Mj ] evaluates to false. On the other hand, M5 and Mj are closed-argument bisimilar, because a closed argument cannot know about n. In particular, it cannot store n when applied to it, for future use, because the language does not allow storage of names.	2

Jeffrey and Rathke [10] showed the unsoundness of an accumulating but closed- argument form of bisimulation for the nu-calculus. The addition of infinitely many global name references makes their bisimulation sound and complete. That language is unaffected by Ex. 4.3 because names may be stored, and unaffected by Ex. 3.4 because there are no local references. On the other hand, their notion of bisimulation for a fragment of Concurrent ML [11] both accumulates values and uses resourceful arguments.

