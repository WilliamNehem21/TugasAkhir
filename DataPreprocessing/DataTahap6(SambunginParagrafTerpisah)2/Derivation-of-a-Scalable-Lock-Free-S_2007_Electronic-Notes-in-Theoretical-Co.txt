We show how a sophisticated, lock-free concurrent stack implementation can be derived from an abstract specification in a series of verifiable steps. The algorithm is a simplified version of one described by Hendler, Shavit and Yerushalmi [6], which allows push and pop operations to be paired off and eliminated without affecting the central stack. This reduces contention on the stack compared with other implementations, and allows multiple pairs of push and pop operations to be performed in parallel.

We consider a system consisting of a finite set of concurrent processes which access a shared stack with elements of some type T . Each process occasionally performs an operation on the stack, and otherwise performs actions which do not involve the stack. We can model such a system by abstracting away from its other behaviour and just considering its stack operations.

In [6], a process p performing a stack operation first attempts its operation on the stack, as described in Section 3. If this attempt fails, instead of immediately retrying, p attempts to match up with a complementary operation so that both operations can be eliminated. If the elimination attempt fails, p tries its operation on the stack again. This strict alternation between attempting the operation on the stack and attempting to eliminate may not give optimal performance under all conditions, so it may be better to use an adaptive scheme to determine, for each attempt, whether to try on the stack or to try to eliminate (this approach is taken in [13] to implement a scalable lock-free queue).

of tryPushElim and tryPopElim are transformed in the same way that occurrences of tryPush and tryPop were transformed in Section 2.2. In order to prove lock-freedom, we would need to show that an operation cannot continually try to eliminate without ever trying to perform its operation on the stack, since tryPushElim and tryPopElim can fail without another stack operation being completed.

9 This is convenient since the push operation has already constructed this Node value. However, it also creates a linkage between the implementation of the elimination mechanism and the underlying stack. Thus, if we want to use the elimination mechanism with a stack implementation using a different data structure, we would need to modify this part of the elimination mechanism.

