Constant folding is a well-known optimization of compilers which evaluates con- stant expressions already at compile time. Constant folding is valid only if the results computed by the compiler are exactly the same as the results which would be computed at run-time by the target machine arithmetic. We classify different arithmetics by deriving a general condition under which a target-machine arithmetic can be replaced by a compiler arithmetic. Furthermore, we consider integer arith- metics as a special case. They can be described by residue class arithmetics. We show that these arithmetics form a lattice. Using the order relation in this lattice, we establish a necessary and sufficient criterion under which constant folding can be done in a residue class arithmetic that is different from the one of the target machine. Concerning formal verification, we have formalized our proofs in the Is- abelle/HOL system. As examples, we discuss the Java and C integer arithmetics and show which compiler arithmetics are valid for constant folding. This discussion reveals also potential sources of incorrect behavior of C compilers.

As a rather amusing motivation for the importance of the compiler arith- metic consider the following presumably true story [Poo94]. In 1994, a major city bank in the UK wanted to find out which of their Pentium processors were afflicted with the Pentium bug. They compiled a test program and checked all their Pentium machines with it. Surprisingly, all of them had the bug. Just to double-check, they also tested their other machines and, even more surprisingly, discovered that they also showed the Pentium bug. After some confusion, they came up with this explanation. The compiler did constant folding, computing the expression intended to reveal the Pentium bug already at compile time. This compiling processor was a buggy Pentium which hard- wired the wrong result into the translated machine program. Hence, in turn, the mistake showed up in each run of the program, independently of the arith- metic of the executing processor. This story demonstrates that the arithmetic of the compiler is important and needs to behave exactly as the arithmetic of the target machine in order to guarantee that the optimized target program behaves exactly as the unoptimized target program would do.

With our results in this paper, we introduce a general framework for the substitutability relation between arithmetics. We specialize this general set- ting for integer arithmetics, yielding an efficiently decidable criterion for sub- stitutability between different integer arithmetics. In section 2, we recall some notations and results from universal and abstract algebra. In section 3, we

At first sight, one might think that the integer and floating point arithmetics in programming languages are rings and fields, resp. For the modulo-arithmetic on integer numbers, this is true. But already for saturating integer arithmetic, we do not have arithmetic on rings any more. Analogously, floating-point arithmetic behaves like the arithmetic in a field only as long as no rounding errors or overflows occur. In this section, we define the notion of arithmetics and derive the notion of substitutability between algebras. Furthermore, we define substitutability with respect to one specific constant expression.

The german Verifix project [GZ99] has the goal of constructing correct compilers. This project has achieved progress by establishing the claim that it is possible to build provably correct compilers within the standard frame- work of compiler construction. In [Nec00], it is shown how some backend optimizations of the GCC can be validated. Proof-carrying code [NL98] is another weaker approach to the construction of correct compilers which guar- antees that the generated code fulfills certain necessary correctness conditions. Pnueli [PSS98,ZPL01] also addresses the problem of constructing correct com- pilers. [GGB02] investigates verification of compiler optimizations specific for embedded processors. None of these works addresses the problem of dealing with different arithmetics in programming languages and their compilers. In particular, none of these works establishes a general substitutability criterion between different arithmetics.

