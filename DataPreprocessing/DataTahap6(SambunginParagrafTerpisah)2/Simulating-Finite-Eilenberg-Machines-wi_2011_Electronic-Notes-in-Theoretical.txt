X. The set X abstracts data structures common in language theory such as tapes, counters, stacks, etc, used by automata on words, push-down automata, transducers etc. Moreover binary relations give a built-in notion of non-determinism. Many translations [4] of usual computational models such as automata, transducers, real- time transducers, two-way automata, push-down automata and Turing machines can be presented as Eilenberg machines.

The proof of correctness uses an inductive principle based on the multiset or- dering [3] over three mutually recursive predicates. Due to the subtlety of the termination argument we find necessary to formalize the simulation in a proof as- sistant. Using the Coq proof assistant [2] and its PROGRAM extension [10], we provide a specification of finite Eilenberg machines along with mechanized proof of its termination and correctness.

First omit parameters h1, h2 and h in this definition. The function react checks whether the state is terminal and then provides an element of the stream delaying the rest of the exploration calling the function choose. This function choose performs the non-deterministic search over transitions, choosing them in the natural order induced by the list data structure. The function continue manages the backtracking mechanism and the enumeration of finite streams of relations; it always chooses to backtrack on the last pushed value in the resumption. Remark that these three mutually recursive functions do not use any side effect and are written in a pure functional style completely tail-recursive using the resumption as a continuation mechanism.

The three functions ensure that arguments computed are well formed as a post- condition if arguments are well-formed as a pre-condition in the predicate h1. The predicate h2 ensures a part of the well-formedness of the list of transitions in function choose. The termination is ensured using the accessibility predicate on list of chi in the predicate h; the property WfRext is used to ensure that all recursive calls are performed with structurally less argument of h.

The formal development above used as specification language the Calculus of Induc- tive Constructions, a version of higher-order logic suited for abstract mathematical development, but also for constructive reasoning about computational objects. Here the sort Prop is needed for logical properties, when the sort Set is used for compu- tational objects. This allows a technique of program extraction which can be evoked for extracting an actual computer program verifying the logical specification. Thus, using OCaml as the target extraction language, the Coq proof assistant provides mechanically the following program:

We have presented a complete specification of the finite Eilenberg machines model. We have designed and formally specified a restriction of the multiset ordering [3]. It has allowed us to implement the reactive engine simulating finite Eilenberg machines into the Coq logic of total functions. Thanks to those formalizations we have been able to prove formally the correctness (soundness and completeness) of the reactive engine with regard to finite Eilenberg machines. The reactive engine presented here has taken benefit from the PROGRAM extension of Coq [10]. Its definition is very close to the one presented in OCaml in the article introducing the finite Eilenberg machine model [8].

