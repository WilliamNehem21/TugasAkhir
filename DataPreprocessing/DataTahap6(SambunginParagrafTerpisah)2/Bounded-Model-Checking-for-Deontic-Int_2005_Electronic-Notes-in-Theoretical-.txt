even a thoroughly-designed distributed system may encounter. In mission- critical software as well as in particularly sensitive applications such as Internet protocols, the worldwide electronic banking system, etc., software engineers are interested in analysing the properties of software, and in particular in checking whether particular conditions, from the basic ones of deadlock to more complex ones, hold for a particular system.

The area of multi-agent systems is also interested in a similar set of prob- lems. Multi-agent systems [17] are distributed systems in which the individual processes, or agents, are autonomous entities that engage in social activities such as coordination, negotiation, cooperation, etc. Since multi-agent systems are autonomous and social, their range of possible behaviours is even greater than the one of traditional distributed systems. It follows from this that the issue of verification of the properties a system satisfies is just as important in multi-agent systems.

Software validation, i.e., the process of checking that a piece of software satisfies certain characteristics, is currently conducted by means of three main techniques: testing, theorem proving, and model checking. Testing involves searching the state-space of the possible inputs of a program looking for po- tentially problematic outputs. Theorem proving techniques are based on the representation of a program by means of a system of formal logic; in its sim- plest instance, checking whether a property is satisfied amounts to checking whether a formula is a theorem of the logic that represents the program. Model checking in its mainstream approach involves representing all possible com- putational traces of a program by means of a temporal model (appropriately represented) and checking whether or not a temporal formula, representing the property to be verified, holds in this model.

The paper is organised as follows. In Section 2, we fix the notation on the semantics of deontic interpreted systems. In Section 3 we present the language of CTLKD, an extension of CTLK, representing correct/incorrect function- ing behaviour of the agents. In Section 4 we present a bounded semantics definition for satisfaction that we use in Section 5 to define the algorithm of bounded model checking. In Section 6 we apply the formalism to an example close to the multi-agent systems literature: the bit transmission problem with faults.

In this section we are interested in applying the machinery of bounded model checking to verify a version of the scenario above where one agent does not operate as it is supposed to. This version of the scenario was first described in [10]. In particular we examine in detail only the possibility that R is faulty 9 . Specifically, we shall consider in this section the possibility that R may send acknowledgements without having received the bit. This is a simple example of an agent not following its specification. This scenario can be analysed by means of deontic interpreted systems. We report here briefly part of the analysis that was conducted in [10], and then proceed to model check the example.

Note that if R performs a faulty action there is no possibility of recovery. It should be straightforward to infer the transition system that is induced by the informal description of the scenario we considered above together with the local states and protocols defined above. We refer to [10] for further discussion. We now encode the local states in binary form in order to use them in the model checking technique. Since the sender S can be in 4 different local green states we shall need 2 bits to encode its state; we take: (0, 0) = 0, (0, 1) = 1, (1, 0) = 0-ack, (1, 1) = 1-ack. Since the receiver R can be in 3 different

Property (i) says that forever in the future if an ack is received by S, then S knows that in all the states where R is functioning correctly, R knows the value of the bit. Property (ii) states that in all the states where R is functioning correctly S has received an acknowledgement and R does not know the value of the bit. Property (iii) says that forever in the future in all the states where R is functioning correctly, S knows that R knows the value of the bit. Property (iv) says that at one point at the future an ack is received by S and at all the preceding points in time in all states where R was operating as intended R knew the value of the bit.

the benefits of BMC are most apparent when only a fraction of the model is generated. For example this happens in formulas (ii), (iii) and (iv) where we need to check validity of an ECTLKD formula in the model. For the purposes of this paper we check validity of the formula (iii). The negated formula is:

