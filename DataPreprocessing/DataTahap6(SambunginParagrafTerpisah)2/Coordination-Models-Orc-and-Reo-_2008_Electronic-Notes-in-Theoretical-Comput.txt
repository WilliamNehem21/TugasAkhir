Although the field of coordination languages and models has been around for some time, the recent interest in Service-oriented Computing (SoC) and Web-service choreography and orchestration 3 has precipitated greater interest in the field, resulting in both new models and new application domains for existing models. Service-oriented computing is based on the idea that software is composed of ser- vices which reside on third party machines. Web services are a common realization of this idea. Since the conception of SoC, research has focussed on developing languages to compose or coordinate services into either composite services or appli- cations.

Reo is a channel-based coordination language designed by Arbab [4] that is based on a simple notion of channel composition. It differs from existing models in that composition propagates synchronization and exclusion constraints through connec- tors. In combination with stateful channels, an expressive coordination language emerges.

Reo. We also discuss the difficulties of embedding in the other direction. Section 2 describes our encoding of Orc into Reo. Section 3 argues that the encoding in the other direction is not as trivial. Section 4 compares the two models on a variety of points. Section 5 discusses some related work, and Section 6 concludes and discusses future work. But first, we introduce Orc and Reo, and give a small example.

An Orc program consists on an Orc expression together with a set of definitions. Basic services, such as data manipulation, are assumed to be provided by primitive sites. An Orc expression can be a primitive site call, a reference to another Orc expression, or a composition of Orc expressions.

A site call is written as M (p), where p is a tuple of arguments which can be constants or variables. When executed all variables have to be instantiated, that is, evaluation is strict, and the site returns at most one value. Examples of primitive sites are 0, which never responds, and let(v), which responds value v. We use E to range over possibly recursive definitions of Orc expressions.

Here, uk and me are constant values, x and d are variables, and CNN (uk, d), BBC(uk) and email(me, x) are site calls that retrieve the news for UK on the day d from CNN, retrieve the news for UK from BBC for today, and send an email to me with value x. Thus EmailNews(d) and EmailNewsOnce(d) invoke the news service from CNN and BBC and send the content by e-mail to me. The difference between these two expressions is that EmailNews sends the news from both CNN and BBC (when the services reply), while EmailNewsOnce e-mails only the value of the first reply, ignoring the second reply.

Reo is a powerful coordination model arising from the propagation of synchroni- sation and other constraints imposed by individual channels through connectors formed by plugging channels together, in combination with mutual exclusive data merging and synchronous data replication through nodes. A key characteristic of Reo is that synchrony is propagated through composition. We present the semantics of Reo connectors in an adaptation of the Q-automata model [11], which in turn extends constraint automata [8].

nodes act as n-replicators, where data must flow to every connected input channel end. If n = 0, we assume that the data is consumed. The formal description we present differs slightly from the original description of Reo, without fundamentally changing anything, in order to simplify our formal results.

Theorem 2.10 is the main result of this section, which relates Orc expressions with their Reo encodings. The proof uses the lemmas introduced above, in par- ticular, Corollary 2.6 deals with inductive applications of the construction, and Lemma 2.9 handles the base case.

considered. An example use of more complex primitive site calls can be found in the work by Cook et al. [14], where the authors encode in Orc the set of workflow patterns proposed by Van der Aalst [2]. A similar approach could be attempted

Component/Service Instantiation In Reo components are attached externally to a connector, whereas Orc can dynamically initiate contact with services. Orc is thus more dynamic, although it is tightly bound to the actual sites being called. These limitations seem easy to lift.

Asynchrony vs synchrony Orc offers highly asynchronous connectives that gracefully deal with failing sites. Reo is highly synchronous and susceptible to fail- ure. Recall that failure can also be handled with timed connectors, as mentioned in Section 2.2, although this solution is less transparent, as failure must explicitly be handled. In principle, synchrony (or in any case, atomicity) can form the basis of high-level abstractions. Much of this work remains to be done. In fact, the jury is still out regarding whether synchrony is a good idea in a distributed setting, even though it has the potential to offer better abstractions.

