Verification of a concurrent system by model checking [5,17] involves exhaustively searching the state-space associated with a finite state model of the system, checking whether a given temporal property holds at each state. For models of realistic systems, the size of the state-space associated with a model grows exponentially with the number of system components (where a component is e.g. a process or channel). This exponential growth means that the state-space for a system with many components may be prohibitively large, rendering straightforward exhaustive search impossible within practical limits.

Symmetry reduction techniques (see e.g. [4,10,19] or [21] for a survey) aim to alleviate the state-space explosion problem by exploiting replication in a concurrent system. If a system contains many identical processes connected in a regular topol- ogy (e.g. a star or clique) then a system state s belongs to a class of states which are step (ii), the swapping of component identifiers. We develop an efficient vector swap procedure, and show that by organising a state so that component identifiers are stored contiguously it is possible to swap process identifiers in parallel using vector instructions common to modern processor architectures. We have implemented this technique in TopSPIN [7], a symmetry reduction package for the SPIN model checker [17], and present experimental results showing the speedups obtained by vectorising symmetry reduction for two case-studies running on the Cell Broadband Engine processor [16].

Consider a simple concurrent system comprised of eight Client processes which route messages to one another in a peer-to-peer fashion. We refer to this example as the message passing system. The state of each client in the message passing system consists of an integer program counter together with two variables, sender and receiver, which holds process identifiers relevant to the message which a given client is currently routing.

More sophisticated techniques for computing rep(s) have been developed [1,8,9,13]. These techniques involve minimising states with respect to suitably chosen subsets of G. We present our vectorisation techniques in terms of the basic approach to symmetry reduction, but our methods can be readily applied in more sophisticated settings.

We use an example to show how these data types and operations can be used to implementa swap operation on a single vector. Let v = (1,3,2,4,5,4,6,7,4,5,3,3,5,1,2,3), a = 3 and b = 5. Suppose we wish to compute a vector, w, identical to v except that occurrences of a and b are swapped. We proceed as follows:

The vectorSwap procedure (Listing 3) is first invoked to efficiently swap occur- rences of a and b in the identifier block for s. The variable tempClient is then used analogously as in Listing 2 to swap the local states of Client processes a and b in the original state. This swapping of Client state involves a small amount of redundancy since the component identifier variables for Client processes are still exchanged even though these are all set to the default value 0.

While the speedups obtained through vectorisation for our example specifica- tions are significant, they do not approach the theoretical maximum speedup factor for vectorisation. This factor is 16 on the PowerPC architecture, since vector oper- ations allow 16 operations on characters to be performed using a single instruction. One reason why the speedups we have observed do not approach the theoretical limit is that memory copy and comparison operations contribute significantly to the time taken for representative computation, and these operations are more expensive to perform on augmented states than on standard states.

