Having information about the execution cost [17,11] of a piece of code is quite useful; in many cases, this aspect is crucial in choosing among different implementations of the same specification. Moreover, this may allow certifying that the execution of an application meets the specified resource-consumption constraints [10]. Cost analysis is also (and especially) very useful in the context of mobile code, where resources are very limited and we may want to accept or reject code depending on its cost. In the limit, accepting mobile code without cost guarantees [6,12] can be a source of denial-of-service attacks, since execution can be very (or infinitely) costly. It is important to note that it is unlikely to have access to the source code in the above-mentioned situations; rather, we can only directly deal with the compiled

In general, cost analysis is far from being trivial; it takes a good amount of expertise for programmers to have an intuition about which implementation tech- niques might lead to more efficient programs. This is particularly difficult when we are dealing with a low-level, object-oriented language such as Java bytecode. In some sense, it is to be expected that automating cost analysis of Java bytecode will not always succeed in giving meaningful results, especially for very intricate code. Thus, one of the main questions about the cost analysis framework we have recently proposed [5], and which we assess in practice in the present work, is whether the generated cost relations can be automatically simplified into a closed form solu- tion [22] when considering the simple cost model traditionally used in complexity analysis, which counts the number of execution steps (bytecode instructions).

The rest of this paper is structured as follows. Sec. 2 provides an overview of our cost analysis framework for Java bytecode [5]. Afterwards, we study three classes of benchmarks. In Sec. 3, we analyze some well-known recursive procedures which, due to their structure, give rise to cost relations which can be easily handled

From the CFG we obtain a recursive representation of the method, where iteration is transformed into recursion. In this representation, each block in the graph is represented as a rule. In addition, the operand stack is flattened by converting its content into a series of additional local variables. Note that this is possible since, in every valid bytecode program, the height of the local stack at each program point can be computed statically.

As for path length analysis, our analyzer does not support the analysis of arbi- trary programs yet; in particular, the program is supposed to satisfy some correct- ness conditions [19]: (1) data structures are not cyclic; and (2) whenever a reference is passed to a method, it is guaranteed that the corresponding structure (on the heap) is not updated by that method. In order to overcome these limitations, we should enrich our analyzer by Sharing and Cyclicity components [19]. This is the subject of ongoing work.

Moreover, it is important to identify the set of variables which are relevant to the cost, i.e., whose value may influence the execution time of the program. As an example, the index of a for -like loop is usually relevant since it affects the number of iterations; on the other hand, a variable which is used to store partial results has no effects in the cost, unless its value takes part in computations whose execution time is not fixed. Relevant variables turn out to be those which are involved in guards or method calls, since (i) a guard affects the control flow of a program and, therefore, its execution time; and (ii) the cost of executing external methods can be clearly relevant to the overall cost. This analysis is similar, in its purpose, to program slicing [20]; it is performed by propagating backwards through the control flow graph variables which are found to be relevant. In the end, when a fixpoint is reached, every block is labeled with the sets of input and output relevant variables which will be used to produce cost relations. The use of slicing in fib does not lead to the elimination of any variables from the relations, since, after the optimization described above, there is only one variable, n, which is clearly relevant to the cost. However, in the other examples (see Section 3.1), several variables can be eliminated, thus leading to a simpler form for cost relations which could not be solved otherwise.

In this section, we infer the cost of two classical recursive procedures. In both cases, and in general for recursive procedures whose base case depends on constant values, the cost relations obtained by our analysis are directly solvable by Mathematica. For simplicity, in the following the cost of all bytecode instructions is assumed to be 1; using a more refined cost model which assigns different costs to different bytecodes would not introduce further complications. For readability, we present only the original Java code, instead of the bytecode.

We want to infer the cost of a simple reverse method which reverses the elements of an array. The recursive representation of reverse in our system takes the form reverse(a, i, r), where a represents the input array, i is the local variable and r is the resulting array. Basically, the execution time depends on the number of loop iterations; therefore, relevant variables are those appearing in the guard of the recurrence relation for m2 (which denotes the termination condition of the loop). Only a and i appear in the cost relation yielded by our system, while r is removed. The size analysis abstracts the array a to its length and infers that the variable i decreases by one unit in each iteration.

In this section, we study several object-oriented features. First, we see how we deal with dynamic dispatching in the context of cost analysis. Then, we analyze the cost of reversing a list implemented as a class with field attributes. Finally, we infer the cost of a linear search algorithm over the list. To the best of our knowledge, these examples illustrate novel object-oriented features which are not studied in existing cost analyses for other languages and paradigms.

In order to assess the practicality of our cost analysis framework, we have imple- mented a prototype analyzer in Ciao [9]. The experiments have been performed on an Intel P4 Xeon 2 GHz with 4 GB of RAM, running GNU Linux FC-2, 2.6.9.

Our experimental results are very preliminary, and there is still plenty of room for optimization (mainly in the size analysis phase). The main planned optimization is the use of abstract compilation techniques in order to avoid re-computation of abstract operations which are related to the bytecodes. This can be done since the analysis is denotational, so that those bytecodes will always have the same abstract approximations.

This work was funded in part by the Information Society Technologies program of the European Commission, Future and Emerging Technologies under the IST-15905 MOBIUS project, by the Spanish Ministry of Education under the TIN-2005-09207 MERIT project, and the Madrid Regional Government under the S-0505/TIC/0407 PROMESAS project. S. Genaim was supported by a Juan de la Cierva Fellowship awarded by MEC.

