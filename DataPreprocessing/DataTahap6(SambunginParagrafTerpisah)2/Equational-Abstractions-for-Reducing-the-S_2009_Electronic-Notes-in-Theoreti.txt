state changes (such as communication operations) by explicit transitions. We show how this optimization can be implemented by transforming the Rewriting Logic specification, avoiding the construction of the full state space. Moreover we establish the correctness of our technique by proving that the original and the reduced system are weakly bisimilar, and demonstrate its usability by applying it to the concurrent functional programming language Erlang.

The remainder of this paper is organized as follows. Section 2 introduces the Rewriting Logic framework, which is then employed in Section 3 to formalize the operational semantics of the Erlang programming language. In Section 4 we present our abstraction technique, demonstrate its application to Erlang in Section 5, and establish its correctness in Section 6. Finally Section 7 concludes with some remarks.

In the following we consider a core fragment of the Erlang programming language which supports the implementation of dynamic networks of processes operating on data types such as atomic constants (atoms), integers, lists, tuples, and process identifiers (pids), using asynchronous, call-by-value communication via unbounded ordered message queues called mailboxes. Real Erlang has several additional fea- tures such as modules, distribution of processes (onto nodes), and support for ro- bust programming and for interoperation with non-Erlang code written in, e.g., C or Java.

value of e does not match p, and where this value is returned as the result otherwise. The constructs involving non-functional behavior (i.e., side effects) are e1!e2 which denotes an output operation, sending the value of e2 asynchronously to the process identified by e1, whereas receive cs end inspects the mailbox q of the local process and retrieves (and removes) the first element in q that matches any pattern in cs. Once such an element v has been found, evaluation continues analogously to case v of cs end; otherwise, the process waits for a corresponding message to arrive. The expression spawn(e1, e2) dynamically creates a new process in which the function given by e1 is applied to the arguments given by the list e2 (and returns

Any Erlang program consists of a set of modules. Each module basically contains a list of function declarations. In our example the system is defined in one module. It is initialized using the start function, which, according to the export declaration, is the only function accessible from outside the locker module. By calling the spawn function, it generates three new processes: one locker and two clients.

The Erlang runtime system maintains a set of user processes. Any such process consists of three components: an Erlang expression which has to be evaluated, a process identifier which uniquely identifies the respective process, and which is internally determined by the system, and a mailbox for incoming messages, which is essentially a list of Erlang values. Moreover we will attribute a current evaluation environment to a process, which stores the bindings between the Erlang variables and the values assigned to them.

Finally the following rule handles one of the central concepts of Erlang: asyn- chronous sending of messages. As we shall see the message will be appended to the mailbox of the target process. Note that a process can also send a message to itself.

