as the genetic algorithm (GA), to search for CA able to exhibit a desired compu- tational behavior over their rule space. Two of the most studied computational tasks in this context are the synchronization task (ST) [3] [19] [8] and the density classification task (DCT) [10] [6] [4] [22]. These tasks have been historically studied in 1D cellular automata rule spaces, except for some explorations about DCT in 2D spaces using Moore Neighborhood [22] [12]-[14].

Some results and considerations about investigations we performed in both these computational tasks are presented here. We explore ST and DCT in classical 1D space using radius 2 and radius 3 rules, resulting in rules with 32 and 128 bits respectively. Besides, we investigated these tasks in 2D spaces using von Neumann and Moore neighborhoods, resulting in rules with 32 and 512 bits.

Section 2 gives a brief description about two computational problems widely employed in CA studies. Section 3 describes the previous usage of evolutionary algorithms to find good CA rules that perform a specific task. Section 4 presents a brief historical discussion about experiments involving synchronization task and density classification task in one and two-dimensional CA lattices, including the results and analysis of current experiments. The main conclusions of this work are present in section 5.

ST is also nontrivial since a small-radius CA employs only local interactions while synchronous oscillation is a global property. The locality of interaction can directly lead to regions of local synchrony and it is more difficult to design a CA that will guarantee that spatially distant regions are in phase 0. An effective CA rule must transfer information over large space-time distances.

Other evolutionary computation techniques were used to find such kind of CA rules. Genetic programming was also used as a search procedure for CA rules to perform the density classification task [1]. Furthermore, for the same task, an important radius-3 rule was obtained by a coevolutionary approach [6]. It has an efficacy of 86% in performing DCT and it remained as the best-known rule for this task until 2008. Recently, Wolz and de Oliveira (2008) have found a large set of 1D radius 3 rules (more than 100 rules) able to perform this task with an efficacy above 88% [22]. They have used a two-tier evolutionary environment and the best rule found in this work is 1461077C0F00CEBF1721047F0F333FBF (the rules are presented by their hexadecimal code representing the output bits from neighborhood 0000000 to 1111111). It is the best-known rule for this task and it has an efficacy of 88.99%.

the experiments reported in [3] a genetic search was used to look for radius-3 rules able to perform the synchronization task. Several radius-3 1D rules that perform ST with an efficacy of 100% were obtained. By other hand, they did not obtain success in CA with radius-2. In this rule space, they only found rules with virtually 0% of efficacy [3]. Later on, Oliveira and collaborators (2001) had evidenced that a simple GA as the employed in [3] was able to find radius-2 rules with efficacy around 80% [19]. Moreover, by introducing a kind of parameter information it was possible to find radius-2 CA rules with more than 90% of efficacy solving ST. Re- cently, Mariano and Oliveira found the best known rule for this task with 96.4% of efficacy: FD9E9042 [8].

In previous works, a simple GA environment was modified to incorporate a heuristic based on some forecast parameters and it was used to find DCT and ST rules [19] [15]. This approach uses parameter bands where good rules are more likely to occur. Once this information is available, it is used in an active way, as an auxiliary metric to guide the processes underlying the GA search. This approach has been previously used to search for CA rules in: 1D DCT [4] [15], 2D DCT [13] [14] and 1D ST [19] [8].

Since we already knew about the existence of 1D radius 3 rules able to solve this task with 100% of efficacy, formed by 128 bits, the results with Moore neighborhood were not surprising, once they have 512 bits. However, in the case of von Neumann neighborhood, the rules have exactly the same size of radius 2 1D rules: 32 bits. Therefore, the spatial arrangement of the 144 cells has facilitate the communication among cells in a such manner that they were able to solve the problem with a better performance than the linear arrangement of 149 cells used with radius 2 CA rules. This behavior was also observed in DCT experiments reported in next section.

WO rule related to the lattice sizes: it performance oscillates between odd and even lattices, being that it efficacy is high in odd-size lattices and significant low in even- size one. The performance of this rule is very similar to what was observed with 32-bits rule 111315FF: both rules oscillate and each one has a better performance when applied in lattices with the same parity in which it has been evolved. The other rule evolved in the even-size lattice (OS) exhibits a lower oscillation as the observed for 32-bits rule 040F35BF.

of adaptive fitness evaluation was used. It was established in [10] that the initial lat- tices used to evaluate the individuals should be generated by a uniform distribution for a better performance of the evolutionary search. However, the best rule found is evaluated in a sample of random lattices generated by a Gaussian distribution in the final of each GA run. A strategy that has presented a better performance is starting from the uniform distributed lattices and as the rules becoming better we change to sort a portion of the lattice using Gaussian distribution. As better as the rules turned on, as larger as the portion sorted by Gaussian distribution. This strategy was previously used in [4] and [2] to find rules with high performance on 1D DCT. However, it was not used in [13] to find OS rule in the experiments with 2D DCT. Another kind of adaptive evaluation was also used in [22] but it is not the same used here and in references [4] and [2] as the initial lattices do not start from a totally uniform sample; besides in [22] the lattices started with small sizes and they are smoothly shifted towards larger sizes during the evolution.

evaluation) to use a heuristic related to BWLR-symmetry to guide the evolutionary search. This information was incorporated not in the same way as in [4] as a repairing infeasible solutions procedure. We incorporated it in a similar way to what was done in the parameter-based heuristic described in [15] and [16]. The parameter BWLR-symmetry was the only one used in this heuristic with a desirable range defined as above 0.9. A series of GA runs was executed using this parameter-

In this work, we try to perform a more extensive inquiry over two of the most-studied computational tasks in CA context: synchronization task and density classification task. To do this, we evaluated the two computational tasks applying them to two different neighborhoods in both one-dimensional and two-dimensional cases. Using 1D lattices, we analyzed neighborhoods of radius 2 and 3 generating 32-bits and 128-bits rules, respectively. In 2D lattices, it was analyzed von Neumann and Moore neighborhoods generating rules of 32 bits and 512 bits, respectively.

