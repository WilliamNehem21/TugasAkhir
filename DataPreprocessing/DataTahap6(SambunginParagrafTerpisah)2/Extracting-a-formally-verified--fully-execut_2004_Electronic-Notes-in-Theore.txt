In this paper, we illustrate the procedure for the translation process from a subset of Java source language to Java bytecode (see Section 2). We show how core functions can be derived from a comprehensive, even though simplified, formalization of Java, presented in Section 3.2. In particular, we look at

As mentioned in Section 2, the structures we obtain from parsing Java source files are abstract syntax trees, called pre-programs, -terms and the like here, which are then converted to genuine programs, terms etc.. In our presentation, we concentrate on attributed syntax trees and then make the correspondence to pre-terms precise.

For some constructs, more readable mixfix syntax is defined, enclosed in brackets. As compared to Java input syntax, our expressions contain type annotations, enclosed in braces. They indicate the name (cname ) of the defining class for field access, field assignment and method call, and the types (ty list ) of method parameters. Their role will become apparent when looking at the typing rules in Section 3.3.1.

structures in different ways: on the Java source level for terms and for pre- terms, and then again on the bytecode level. For the source level, we take java_mb prog, where java_mb consists of a list of parameter names, list of local variables (i.e. names and types), and a statement block, terminated with a single result expression (this again is a deviation from original Java).

For terms, we have typing judgements making precise what the type of a term is, under a given environment. These judgements essentially serve as type checking rules. For pre-terms, we additionally want to infer type annotations, provided the pre-term is well-typed, so the typing judgements are combined type checking and type inference rules.

Note that our compiler makes no attempt at optimizing generated code. For example, in order to maintain the invariant used in the compiler correct- ness statement, the bytecode for an assignment expression of the form vn::=e contains the instruction Dup which duplicates the value on top of the operand stack. When used as an assignment statement of the form Expr (vn::=e), this and the following Pop instruction are superfluous.

Compilation is then gradually extended to the more complex structures presented in Section 3.2.1, such as methods, classes and entire programs. Sine Java source and bytecode are sufficiently similar, hardly any data refinement is necessary. For lack of space, we skip their definition.

States on the Java source level essentially are a triple: exception com- ponent (indicating the presence of an exception), heap hp and local variable assignment loc. The structure of states on the JVM level is more complex. However, for the purpose of compiler verification, we can focus on the heap, a local operand stack os and local variable assignment.

Consider clause pNewC. Assume E and pNewC C are known. We can then find out the value of C (since pNewC is a constructor) and hence know the value of NewC C and Class C. Therefore, the mode {1, 2} is legal for this clause.

Quite a pragmatic approach is taken in [Nec00]: Here, an intermediate program format is compared between successive stages of compiler optimiza- tions, and transformations leading from the initial to the resulting program are inferred and proved to be semantics-preserving. The approach uses no ex- plicit model of program semantics, which makes it hard to reason about side conditions of some transformations (in fact, some of them, such as aliasing, are glossed over). Besides, it may be wondered whether the approach scales up to complex transformations.

On the more practical side, our coverage of the Java language is far from complete. Many operations are missing both on the source and the bytecode level, class initialization is still treated in an ad-hoc manner. Besides, it is not quite clear how to integrate libraries, such as for input/output, and how to generate useful error messages for incorrect programs.

A great part of the formalizations presented here has been developed by Ger- win Klein and David von Oheimb. The parser has been implemented by Tao Yu. We are grateful to Tobias Nipkow, Norbert Schirmer and Martin Wild- moser for discussions about this work.

