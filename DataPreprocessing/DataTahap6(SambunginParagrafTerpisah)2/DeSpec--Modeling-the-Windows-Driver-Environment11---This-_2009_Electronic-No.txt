In recent years, efforts to verify correctness of Windows kernel drivers [22] have emerged as it is crucial for stability of the whole operating system. Microsoft itself has developed several tools for driver verification including the latest Static Driver Verifier model checker. The key to successful application of the model checking approach in this area is a reasonable choice of the environment model. However, the environment models used in current tools are too (1) non-deterministic, degrading preciseness of the model checker reports, and (2) oversimplified, loosing the ability to check more specific kinds of properties of drivers. On the other hand, neither a formal or readable specification usable for documentation purposes is provided by these models. This paper targets these issues by introducing a new language for formal specification and modeling of kernel drivers and their environment.

Windows kernel drivers are relatively small libraries usually written in the C lan- guage. They run in a privileged mode that enables them to work directly with hardware. This introduces a high risk of damaging other parts of the kernel if a driver contains an error. Hence the correctness of drivers is crucial for security and stability of an operating system and drivers are common subject of software verification.

The rest of the paper is laid out as follows. Section 2 briefly describes the Win- dows kernel environment from a point of view of the driver verification. Section 3 introduces the DeSpec language, explains its part on an example and describes how a model extractor should work with DeSpec specifications. Section 4 discusses related work and Section 5 concludes.

tures). It is designed as a bridge between constructs of the C language and their models in the Zing language. In particular the models of pointers, function pointers, unions and other constructs that are not directly expressible in the Zing language are hidden behind the syntax of DeSpec language. This allows to adjust models for these features without a need to rewrite the specifications.

Apparently, some constructs exploiting memory layout, such as reinterpreting casts or unions, cannot be modeled in a feasible way. Therefore they are not directly expressible in the DeSpec language. Fortunately, the driver as well as environment interface should be as platform independent as possible and thus these constructs should be used rarely.

The DeSpec language is similar to the C# language in its syntactical structure. Each source file contains a list of declarations grouped to namespaces. Declarations include classes, integer enumerations, integer ranges, method delegates and method groups. A class declaration comprises of its members. Apart from fields and meth- ods, which are common for standard object-oriented languages, DeSpec classes can also contain rules. A rule specifies constrains on fields and methods by means of temporal logic patterns. This section briefly describes DeSpec namespaces, classes and rules.

The signature of a method abstracting a kernel function defines how parameters of the function are treated within the specification. The placeholder token (a single underscore) is used for arguments that are not important for the specification. The models of IoAttach- functions do not care about the second parameter. When a specification refers to the IoAttachDevice method, only one argument is stated in the list of actual arguments. The instance argument is picked from the argument list out before the method to denote the target instance using the dot notation. Arguments on the positions of placeholders are also omitted in the actual argument list. Methods declared in Example 1 are referred to as follows: used only for the sole purpose of modeling. Such fields are marked by the synthetic keyword. Similarly, synthetic methods and also synthetic classes can be defined in the specification. In general, DeSpec distinguishes synthetic language elements from non-synthetic ones. Note that all elements used in the first example are non- synthetic. Synthetic classes contain no abstractions, particularly no kernel function is mapped to a method of a synthetic class. Example of a class containing synthetic attributes follows:

sions. The pattern used in Example 3 can be generalized to {P} corresponds to {Q} Each temporal logic pattern is formed by pattern keywords and pattern expres- parts: the property and the scope. In this case, the property is {P} corresponds to globally, where P and Q are Boolean expressions. Each pattern can be split into two

terns of instance rules are implicitly quantified by a variable of the declaring type. Instance rules can refer to that variable by using this keyword. This keyword can be omitted when referring to the instance members of the type. Unlike Bandera [8], DeSpec allows to quantify over value types (i. e. integers, Boolean, enumera- tions). Zing symbolic value types can be used for the implementation. The reference type quantification may be implemented in the same way as in the Bandera, how- ever more scalable implementation would be possible using Zing symbolic reference types, which should be available in the next version of the Zing.

In Example 3, the source code event defined by the method(args)::succeeded op- erator establishes a watchdog for successful returns from the kernel function IoAt- tachDevice. It is triggered by only such function return that the third argument can be unified with the device quantification variable and the function return value means a successful call. The first two arguments could have been arbitrary when the function was called.

Once the top-level model is chosen, the model extractor generates Zing model of the driver (using its C source code and kernel headers) and combines it with the environment model. Since the resulting model is too large to be verified, the slicing [13,10] should take place retaining only those parts transitively referred to by the top-level model and the constrains being verified. As a final result, a Zing model of the driver and the related kernel functions and structures are output.

Finding errors in drivers is not limited to the model checking technique. Microsoft PREfast tool for drivers [19] performs static analysis of the source code and searches for common error patterns. It can, for example, find memory leaks incurred by missing function calls, dereferences of null pointers, buffer overruns, kernel functions called on incorrect IRQL level, and so on. The analysis is function scoped and hence it introduces false negatives and also restricts a set of errors it is able to detect.

