One of the benefits of a well-structured system is the reduction of its overall com- plexity, which in turn should lead to a more dependable system. Dependability is defined as the ability of a system to deliver service that can justifiably be trusted [2]. The process of system structuring may occur at different stages of the development or at different levels of abstraction. Reasoning about dependability at the architec- tural level has lately grown in importance because of the complexity of emerging applications, and the trend of building trustworthy systems from existing untrust- worthy components, such as off-the-shelf (OTS) components and legacy systems, that were not originally designed to interact with each other. One major prob- lem when using existing components is the inability to change, or even to access, their internal designs and implementations. Moreover, since the evolution of these components might be outside the control of the system architect, solutions that are dependent on a specific component implementation become unfeasible. Based on these limitations, the delivery of correct service, and the justification of this ability, has to be obtained from the components interfaces and their interactions rather than from their internal designs or implementations. Hence the drive for considering dependability concerns at the architectural level, rather than late in the development process. From the perspective of software engineering, which strives to build software systems that are free of faults, the architectural consideration of dependability compels the acceptance of faults, rather than their avoidance. Thus the need for novel notations, methods and techniques that provides the necessary support for reasoning about faults at the architectural level. For example, nota- tions should be able to represent non-functional properties and failure assumptions, and techniques should be able to extract from the architectural representations the information that is relevant for evaluating the system architecture from a certain perspective.

The provision of fault tolerance relies on the existence of redundancy, which can be incorporated either implicitly or explicitly at the architectural level. An exam- ple of implicit redundancy is the usage of exception handling for supporting error recovery. If special care is not taken when structuring the system, the normal and abnormal specifications can be entangled thus increasing system complexity. Ex- plicit redundancy is an inherent aspect of strongly-structured systems, i.e., systems in which the structuring of redundancy is part of the actual system, thus restricting the impact of faults. Examples of explicit redundancy are N-version programming and recovery blocks, which are two software fault tolerance techniques.

The points in which to inject faults are derived from the B-Method and CSP specifications. For identifying the places in which faults can occur, the proposed ap- proach relies on both structural and behavioural dependencies between architectural elements. In brief, the architecture specification is used to determine the depen- dencies among architecture elements. The idea is to select the points of injection (elements to inject) so that, if the objective is to determine the impact of failures in the rest of the system by a given architectural element, we can select to inject those

The development of fault-tolerant software system can be more effective if archi- tectural abstractions are employed. These are able to abstract away from system details while providing the means for analysing how errors are propagated, detected and handled, and how faults are handled. Associated with these abstractions, we have defined a general rigorous development approach for the formal specification, verification and validation of software architectures that are based on these ab- stractions. In this paper, we have presented two distinct architectural abstractions from which fault-tolerant software systems can be built: the idealised fault-tolerant architectural element (iFTE), and the halt-on-failure architectural element (HoFE).

