We present a system of refinement types for LF in the style of recent formulations where only canonical forms are well-typed. Both the usual LF rules and the rules for type refinements are bidirectional, leading to a straightforward proof of decidability of type-checking even in the presence of intersection types. Because we insist on canonical forms, structural rules for subtyping can now be derived rather than being assumed as primitive. We illustrate the expressive power of our system with several examples in the domain of logics and programming languages.

LF was created as a framework for defining logics [6]. Since its inception, it has been used to formalize reasoning about a number of deductive systems (see [13] for an introduction). In its most recent incarnation as the Twelf metalogic [14], it has been used to encode and mechanize the metatheory of programming languages that are prohibitively complex to reason about on paper [3,9].

In the remainder of the paper, we describe our refinement type system alongside several illustrative examples (Section 2). Then we explore its metatheory and give proof sketches of important results, including decidability (Section 3). We note that our approach leads to subtyping only being defined on atomic types, but we show that subtyping at higher types is already present in our system by proving that the usual declarative rules are sound and complete with respect to an intrinsic notion of subtyping (Section 4). Finally, we discuss some related work (Section 5) and summarize our results (Section 6).

intersection elimination rules. As Reynolds has shown, this non-determinism causes intersection type checking to be PSPACE-hard [16], even for normal terms as we have here [15]. Using techniques such as focusing, we believe that for practical cases they can be analyzed efficiently for the purpose of sort checking. 5

As a final example, we present the Calculus of Constructions. Usually, there is a great deal of redundancy in its presentation because of repeated constructs at the level of objects, families, and kinds. Using sorts, we can enforce the stratification and write typing rules that are as simple as if we assumed the infamous type : type.

In this section, we present some metatheoretic results about our framework. These follow a similar pattern as previous work using hereditary substitutions [17,11,7]. To conserve space, we omit proofs that are similar to those from prior work, and only sketch novel results. We refer the interested reader to the companion technical report [10], which contains complete proofs of all thoerems.

