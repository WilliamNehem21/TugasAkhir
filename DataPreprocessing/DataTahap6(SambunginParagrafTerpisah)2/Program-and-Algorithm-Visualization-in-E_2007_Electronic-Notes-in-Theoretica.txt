In developing the TM [8,9], we thought about that problem a lot. Working with weaker students in the lab, we found a lot of superstitious behaviour: they would throw lines of code at a problem as if they were spells, with little understanding of what they meant. We found ourselves preaching that every line of code had a specific meaning and purpose, that it was an instruction to a machine. Developing in the students an effective mental model of that machine goes a long way toward teaching them to reason about the code they write. That machine, T , we were programming (and which we wanted the students to understand) was not really a computer, at least in the conventional sense. Consider the following simple C++ code:

The Teaching Machine reads in standard C++ or Java files, generally prepared using conventional tools. There are some restrictions on what it can handle, as neither compiler is a complete implementation. For example, we have implemented neither threads in Java nor templates in C++. Nevertheless, the subsets that are supported are large, standards conforming, and work well in the courses in which the TM has been used.

There is a window that displays expressions being evaluated (upper middle). This display, called the Expression Engine, is similar to the Expression Evaluation Area of Jeliot 3 [6]. There is a display for console input and output (lower left). All views evolve dynamically as the program is executed.

At Memorial University, the TM is used in a three course stream in Electrical and Computer Engineering: Structured Programming (ENGI-2420), Advanced Pro- gramming (ENGI 3891), and Data Structures (ENGI-4892). ENGI-2420 teaches the basics of programming to all Engineering students, while 3891 emphasizes the use of classes and introduces pointers and heap allocation. ENGI-4892 emphasizes re- cursion and linked structures such as linked lists and trees.

From 1999 to 2001, we continued to use our old lecture transparencies but moved to the TM to illustrate specific points of interest. The TM was used more than the debugger, since it could show constructs the debugger could not. We spent less time at the blackboard drawing and spent more time discussing examples with the students. Using the TM, however, drew us to different examples. Its use

In 2002, in order to provide a fully integrated experience in the lecture and to give students access to interactive notes afterwards, we took advantage of the fact that the TM was a Java applet to integrate it directly into the notes, which were rewritten in HTML. We realized that we had to make it as easy as possible for instructors to author such interactive notes, so we created WebWriter++ [1], a set of javascripts with a couple of additional applets. The smooth integration considerably increased the amount of lecture time spent running examples in the TM. ENGI 4892 moved to the same format the next academic year, with the Linked View being used predominantly.

At the University of Athens one of the authors has been teaching the subject of Principles of Programming Languages and Programming Techniques for the past six years, as part of the curriculum of a joint M.Sc. degree between the Depart- ments of Physics and Informatics & Telecommunications. It is a well-known and highly respected conversion programme in which mostly Physics graduates from a number of Greek Universities enrol. The course is divided into three parts: the first and second parts discuss syntax (regular expressions, BNF) and computation as- pects of programming languages, respectively; the third part discusses programming techniques (structured programming, top down program development).

The TM was introduced the fall 2005 semester augmenting teaching for the second and longest part, the computational aspects. Our teaching approach is an- alytical rather than empirical, aiming for exposing students to concepts recurring in programming languages, rather than teaching a specific language; students sep- arately follow a two hour per week course on C. The teaching material for the past three years has been based on the six computation chapters of Part II of Fisher [4], which fits well with our teaching approach. Students were given a number of small course-work exercises, which aim to practice and establish concepts.

ciation of variable names to objects in memory is a misconception. We relied on the expression execution of the TM to demonstrate that expressions in C++ may be undefined and return strange results. We demonstrated the differences between parameter passing by (pointer) value and by reference; a misconception found not only among students but also in a number of programming books.

Finally, we have come to realize that the TM is a solid platform for new develop- ments. It is easy to use, robust, flexible, and reasonably complete. Its data model is easily extendable to more powerful, algorithmic visualizations. By providing it with specialized input and output plugins we can provide better visualizations and better interactivity; we expect that adding such plugins will be far easier than developing specialized visualizers from scratch.

