The pure untyped lambda calculus [2] is often taught as part of the computer science curriculum. It may be taught in a computability course as a classical computation model [3]. It may be taught in a semantics course as the founda- tion for denotational semantics. It may be taught in a functional programming course as the archetypical minimal functional programming language. It may be taught in a programming language concepts course for the same reason, or to demonstrate that a very small language can be universal, e.g. can encode arithmetics (as well as data structures, recursive function definitions and so on), using encodings such as these:

A free variable is similar to a data constructor (in Standard ML or Haskell), that is, an uninterpreted function symbol. If the free variable is in function position (x e2), then call-by-value should reduce the argument expression e2, whereas call-by-name should not. This is consistent with constructors being strict in strict languages (e.g. ML) and non-strict in non-strict languages (e.g. Haskell).

To produce a trace of the reduction, we modify the reduction functions defined in Section 6 to take an extra context argument c and to use the extended substitution function csubst, passing c to csubst. Then csubst will apply c to the redex before contracting it. We take the call-by-name reduction function cbn (Section 6.1) as an example; the other reduction functions are handled similarly. The reduction function must build up the context c as it descends into the term. It does so by composing the context with the appropriate context builder (in this case, only in the App branch):

A web-based interface can be created by defining a function htmllam that prints HTML code, and calling cbnc from a CGI script on the webserver with htmllam as argument. Such an implementation written in Moscow ML [7] is available at http://www.dina.kvl.dk/~sestoft/lamreduce/.

For experimentation it is useful to be able to perform one beta-reduction at a time, or in other words, to single-step the reduction. Again, this can be achieved using side effects in the meta-language Standard ML. We simply make the context function c count the number of redexes contracted (substi- tutions performed), and set a step limit N before evaluation is started.

When N redexes have been contracted, c aborts the reduction by raising an exception Enough e', which carries as its argument the term e' that had been obtained when reaching the limit. An enclosing exception handler handles this exception and reports e' as the result of the reduction. The next invocation of the reduction function simply sets the step limit N one higher, and so on. Thus the reduction of the original term starts over for every new step, but we create the illusion of reducing the term one step at a time.

We have described a simple way to implement lambda calculus reduction, describing reduction strategies using big-step operational semantics, imple- menting reduction by straightforward reduction functions in Standard ML, and instrumenting them to produce a trace of the reduction, using contexts. This approach is easily extended to other reduction strategies describable by big-step operational semantics. The extension to lazy evaluation, whether us- ing graph reduction or an explicit heap, would be complicated mostly because of the need to print the current graph or heap.

