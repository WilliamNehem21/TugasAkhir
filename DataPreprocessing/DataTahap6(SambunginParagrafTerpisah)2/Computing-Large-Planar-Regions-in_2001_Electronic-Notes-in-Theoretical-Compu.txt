We consider the problem of computing the largest region in a terrain that is ap- proximately contained in some two-dimensional plane. We reduce this problem to the following one. Given an embedding of a degree-3 graph G on the unit sphere S2, whose vertices are weighted, compute a connected subgraph of maximum weight that is contained in some spherical disk of a fixed radius. We given an algorithm that solves this problem in O(n2 log n(log log n)3) time, where n denotes the number of vertices of G or, alternatively, the number of faces of the terrain. We also give a heuristic that can be used to compute sufficiently large regions in a terrain that are approximately planar. We discuss a web-based implementation of this heuristic, and show some results for terrains representing three-dimensional (topographical) images of fracture surfaces of metals obtained by confocal laser scanning microscopy.

Lee [4] for the case when S is a set of points in the Euclidean plane. They showed that the problem can be solved in O(n2) time. The related problem of computing the deepest point in an arrangement of halfplanes is 3SUM- hard, see Gajentaan and Overmars [6]. This indicates that it is probably very difficult to solve the disk placement problem in subquadratic time. Recently, Agarwal et al. [1] gave an alternative O(n2)-time algorithm for the optimal disk placement problem, as well as approximation algorithms whose running times are close to linear. Our algorithm in Section 2 for solving Problem 1.1 has been inspired by the O(n2)-time algorithm in [1].

Throughout this section, we make the following general-position assump- tion about the set S. We assume that the elements of S are pairwise distinct. Moreover, we assume that for any two distinct points p and q of S, the spheri- cal disks Dp and Dq are either disjoint or have an intersection of positive area (hence, Dp and Dq do not touch each other). Finally, for any three distinct points p, q, and r of S the spherical disks Dp, Dq, and Dr do not intersect in a single point. We make this assumption only to simplify the description of our algorithm. This algorithm can easily be extended to handle arbitrary sets of points.

It is clear that this algorithm correctly solves Problem 1.1. Let us analyze its running time. Recall that n denotes the number of elements of the point set S. Since each vertex of the graph J has a degree of at most three, J has at most 3n/2 edges.

The arrangement A can be computed in O(n2) time using, e.g., the al- gorithm of Amato et al. [3]. Consider any vertex x of A. The graph Jx, its connected components, and the value Wx can be computed in O(n) time. Since A has O(n2) vertices, Step 2 takes O(n3) time. Hence, the entire algorithm takes O(n3) time.

We now show how to improve the running time considerably. Note that the bottleneck of the previous algorithm is Step 2. The idea of the improved algorithm is to traverse the arrangement A and maintain the connected com- ponents of Jx in a data structure. Consider what happens when we walk along an edge of A from one vertex x to a neighboring vertex y. At this moment, we know the connected components of the graph Jx, and want to compute the connected components of Jy as fast as possible. Walking from x to y means that we move the spherical disk Dx along an edge of A to the position Dy. During this move, at most one point of S can enter or leave the spherical disk. (Here we use our general-position assumption.) Since the graph J has degree three, it follows that the graph Jy can be obtained from Jx by performing at most a constant number of edge insertions and deletions.

Step 3: Starting at x, traverse the vertices of the arrangement A, e.g., in depth-first order. In a generic step, we walk from a vertex y to a neighboring vertex z. At this moment, we have the data structure CC y, storing the con- nected components of the graph Jy, together with their weights. The graph Jz can be obtained by inserting and deleting at most a constant number of edges in the current graph Jy. Hence, we obtain the data structure CC z by performing these updates in the data structure CC y. Afterwards, we query CC z to find the value of Wz, and set W := max(W, Wz).

The correctness of this algorithm is clear. Steps 1 and 4 take O(n2) and O(1) time, respectively. The times for Steps 2 and 3 depend on the data structure CC . Let P (n), U (n), and Q(n) denote the preprocessing time, update time, and query time of this data structure, respectively. Then Step 2 takes O(n + P (n)) time. In Step 3, we spend O(U (n)+ Q(n)) time for each vertex of A. Since this arrangement has O(n2) vertices, it follows that the total running time of the algorithm is the center of D gives the optimal solution to Problem 1.1. If we move the disk D, then either the point p or the point q leaves the disk and, hence, each connected subgraph of J that is contained in the disk consists of one single vertex. This shows that any approximation algorithm for Problem 1.1 must return the center of D. Because of this, we believe that it is difficult to solve the approximation version of Problem 1.1 in subquadratic time.

We have considered the problem of computing large regions in a terrain that are connected and approximately planar. We showed that the problem of computing the largest such region can be solved in a time that is roughly quadratic in the number of triangles in the terrain, and argued that it is unlikely to solve the problem faster. We leave open the problem of proving this rigorously. We also argued that it may even be hard to approximate this largest region. Proving this claim formally is also left as an open problem.

