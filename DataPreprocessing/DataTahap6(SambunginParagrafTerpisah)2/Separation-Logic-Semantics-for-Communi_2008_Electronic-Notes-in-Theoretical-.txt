This use of sets of primitive events, and particularly the respesentation of con- summated communications, has been chosen because it leads to a particularly sim- ple notion of event composition using set union. Also, our sets of primitive events represent several actions happening at the same time. For example, we can have offered communications on different channels, [c!3, d!4], or even two simultaneous consummated communications, [c!3, c?3, d!4, d?4].

for any channel c. We have chosen to record only communication events in the traces. In particular, note that we do not regard allocation and deallocation as events: They are represented by their change of alphabet alone. In t(c) we can see that new extends the alphabet with the two ends of a channel c (also binding c to x in the environment), where dispose removes those channels from the alphabet. dispose x must have both ends of the channel denoted by x in its pre-alphabet in order to successfully execute.

Not all sets of primitive events are sensible. For example, a set [d!3, d!4] indicates two concurrent sends on d, with different values, at the same time. Another, subtler, example is [c!(d!), d!3] where 3 is sent on channel d, and concurrently the send permission for d is sent on channel c; this second example conflicts with the point- to-point idea, that two processes cannot sumultaneously possess the send permission on a channel.

consistent for them to occur at the same time. We can formalize this notion of consistency by appealing to the notion pre(e) of the pre-alphabet for an event. The alphabet pre(e) describes the resources needed for the event e to occur. Consistency of e and e' then means that pre(e) and pre(e') do not overlap; that is what is needed for the events to occur concurrently.

The semantics traces(P ) of a process is a predicate denoting a set of traces. To be literal, it denotes a function from environments to trace sets. For simplicity, we will use logical notation in the usual semi-formal way to write down these predicates, relying on predicate calculus to do all environment manipulation (see later in the section for elaboration).

which is just a standard semantics of the predicate calculus notation. That is, the environment-free presentation of the semantics for new is relying on the ability of a complete boolean algebra to model quantification in the standard way. With these remarks, we expect that no confusion is likely to arise from our use of logical notation in this way.

The idea of the Synchronization Property from Section 4.3 is that when a process has a resource it will have it exclusively. So, when a process has both ends of a channel, and it offers a communication on that channel, it is impossible for any other process to reciprocate. The following example illustrates this point further:

The sender sends a stream of messages on the left channel to the buffer, which copies them out to a right channel. The sender indicates that it is done by sending the write permission for left to the buffer, which then sends the left channel back to the channel manager. The buffer assumes responsibility for disposing the left channel, but hands off all responsibility for managing the right channel.

Finally, it is worth remarking that the buffer is programmed in a dangerous style. If the sender process happens to send the left ! channel end, then everything will be alright. But, if the sender mistakenly sent another channel end, then the buffer would mistakenly attempt to dispose that channel. A safer, but less efficient way to program the buffer is

This discussion of safety of the buffer program brings up a limitation of the trace model in this paper. In the model we are using STOP as the receptacle of several kinds of error, including deadlock, divergence, and channel faults. The former two are standard for trace models; we comment on the third.

The basic problem is that, since traces(P +STOP)= traces(P ), it is impossible to use the trace model to say when errors represented by STOP will be avoided. In CSP, refined models have been used to distinguish the different kinds of error represented together by STOP in the basic trace semantics. The divergences model separates out infinite looping with no external communication, and the failures model separates out deadlock. Similarly, we would like a model that lets us prove that channel faults are avoided.

In this section we describe some basic theoretical properties enjoyed by the seman- tics. Generally, these properties will correspond to healthiness conditions, which identify conditions on predicates preserved by the semantics of process terms. We also formulate a result on footprints, which formalizes some of our intuitions about resources.

We should argue that the Unity restriction is reasonable. First, consider skip; A = A = A; skip. If processes are allowed to stutter and be closed under prefixes, as we want, then it makes no difference to add stuttering on either end.

Proposition 6.2 The set of trace sets satisfying the three healthiness conditions is a complete lattice under the subset order, with lubs being calculated by union, with traces(STOP) being the least element and the set L of legal traces the greatest. The trace semantics of each construct is Scott-continuous in its process arguments.

This result gives us enough information to calculate the semantics of recursion using either least or greatest fixed-points. Both have their uses. The least fixed- point corresponds to a partial-correctness semantics, where the greatest fixed-point corresponds to a specification-oriented semantics in which the order of reverse subset is regarded as an ordering of refinement.

Our use of partial alphabet composition is similar to how substructural typing limits the number of processes that can access a channel. Beyond that basic similar- ity, the techniques developed here and in the work on types for pi-calculus appear to be complementary. Indeed, it would be conceivable to use ideas like in session typing to underapproximate safe states for our illustrative language (cf, Section 5.3). Conversely, it might be possible to employ techniques like those developed here to provide denotational models of session typing systems, where the changing alphabet is an explicit part of the semantics.

A number of authors have used substructural logics to reason about process calculi [9,8,20]. The approach has been to first set down an operational semantics of a process calculus, and then use the parallel composition to define a separating conjunction connective as described in Section 2. The approach in this paper is in a sense inverse. We first set down a ternary relation model or models, and then use the induced separation connectives in the description of the denotational semantics of processes. So, we use separation conjunctions to provide the semantics of pro- cess terms, where [9,8,20] use process terms to provide the semantics of separating conjunctions (in the generalized sense of Section 2).

We carried out our study by marrying some of the ideas in CSL and CSP, two formalisms which have led to modular reasoning methods in different arenas. We described the semantics of a message-passing language with dynamic allocation and deallocation of channels, where the trace semantics of parallel composition uses a composition operation on traces that partitions channel ends between processes. Results were given on the footprint of a process, expressing a sense in which the model accounts for resources locally.

