Although very simple and elegant, Linda-style coordination models lack the notion of time, and are therefore not able to precisely model real-life coordination applications. Nevertheless, industrial proposals such as TSpaces and JavaSpaces, inspired from Linda, have incorporated time constructs. This paper aims at a systematic study of the introduction of relative time in coordination models. It builds upon previous work to study the expressiveness of Linda, Linda extended with a delay mechanism and Linda primitives extended to support the duration of tuples and of the suspension of communication operations.

In this context, a clear separation between the interactional and the com- putational aspects of software components has been advocated by Gelernter and Carriero in [15]. Their claim has been supported by the design of a model, Linda ([9]), originally presented as a set of inter-agent communication prim- itives which may be added to almost any programming language. Besides process creation, this set includes primitives for adding, deleting, and testing the presence/absence of data in a shared dataspace.

adopt the classical two-phase functioning approach to real-time systems illus- trated by languages such as Lustre ([10]), Esterel ([3]) and Statecharts ([16]). This approach may be described as follows. In a first phase, elementary ac- tions of statements are executed. They are assumed to be atomic in the sense that they take no time. Similarly, composition operators are assumed to be executed at no cost. In a second phase, when no actions can be reduced or when all the components encounter a special timed action, time progresses by one unit.

In this paper, we consider only the first two extensions. These extensions were introduced in [19] with some expressiveness results. However, as will be appreciated by the reader, this paper aims at a much deeper study of these expressiveness results. In particular, all the results of sections 3 and 4.2 are original with respect to [19] while the comparisons of sections 4.1 and 4.3 have lead to 8 new results with respect to [19].

To start with, consider the family of languages L(X ), parameterized on the set of Linda-like communication primitives X . This set X consists of the basic Linda primitives out, in, and rd, for putting an object in a shared dataspace, getting it and checking for its presence, respectively, together with a primitive testing the absence of an object from the dataspace. Formally, the language is defined as follows.

language and qualify E as an agent. However, to meet the intuitive expectaion, we shall always rewrite agents of the form (E ; A), (E || A), and (A || E) as A. This is technically achieved by defining the extended set of agents as follows, and through simplifications derived by imposing a bimonoid structure.

As delay(i) succeeds on the empty store, the agent B1 has to suceeds. This derivation provides then a valid prefix for a successful derivation of the agent. This contradicts, by property P 3, the fact that delay(i) + (delay(0) ; ask(t)) has only failling computations on the empty store. The absence of choice starting with a tell and delay(0) primitive can be shown similarly.

As delay(i + 1) succeeds on the empty store, this derivation provides a valid prefix for a successful derivation of the agent. This contradicts, by property P 3, the fact that delay(i + 1) + (delay(i) ; ask(t)) has only failing com- putations on the empty store. Any kl must then be strictly greater than at least one of the jl. By the induction principle, any jl is greater than i, and therefore any kl is greater than i + 1.

Proof. (i). Because of the infinite enumerability of the tokens, we associate with each token t a pair of tokens that, for simplicity, we denote tf and ti. Intuitively, they correspond to a token t on the store with, a finite or infinite duration, respectively. As there is no nask primitives, decreasing the duration of finite tokens in the transitions will occur only in case of failing computation.

By property P 3, the coding of delay(1) has only successful computations on the empty set. The first step of any such computation corresponds to the execution of a telld(t) or naskd(t) primitive on the empty set and thus is not a temporal step. Any computation can be represented as follow.

The third observation is about the delay primitives appearing in the cod- ing. None of the j1,... , jl > 0 can have 1 as value. Indeed, if jJ = 1, in view of our second observation, the coding of the agent telli(t); (naski(t) + naski+1(t)) accepts the following derivation

Other related proposals for the introduction of time in coordination-like languages are [27] and [28]. Both pieces of work concern concurrent constraint languages ([29]), which may be viewed as a variant of Linda restricted to two communication primitives putting information in a tuple space and checking the presence of information in it. Technically, concurrent constraint languages can thus be viewed as the language L({ask, tell}). The paper [27] introduces time in this context by identifying quiescent points in the computation where no new information is introduced and by providing an operator for delaying computations by one unit. At each quiescent point in time, the tuple space is reinitialized to an empty content. The paper [28] extends this framework, on the one hand, by introducing a primitive for checking the absence of in- formation and reacting on this absence during the same unit of time and, on the other hand, by generalizing the delay(1) mechanism in a hence A con- struct which states that A holds at every instant after the considered time.

De Boer, Gabbrielli, and Meo have presented in [4] a timed interpretation of concurrent languages by fixing the time needed for the execution of parallel tell and ask operations as one unit and by interpreting action prefixing as the next operator. A delay mechanism is presented in Oz ([31]), a language which combines object oriented features with symbolic computation and constraints, and, (relative) time-outs have been introduced in TSpaces ([34]) and JavaS- paces ([14]). A formal semantics of these time-outs and other mechanisms, different from our expressiveness study, is presented in [7].

Another piece of work on the expressiveness of timed constraint systems is [24]. There, various extensions of the tcc languages have been studied: extension with replication and recursive procedures with static scoping. De- cidability results are proved as well as several encodings, which are however not of the form of modular embeddings studied in this paper.

Finally, [8] investigates the impact of various mechanisms for expired data collection on the expressiveness of coordination systems. However, the study is based on Random Access Machines, on ordered and unordered tells of timed data and on decidability results. In contrast, we study a richer class of mech- anisms and foccus on modular embeddings.

