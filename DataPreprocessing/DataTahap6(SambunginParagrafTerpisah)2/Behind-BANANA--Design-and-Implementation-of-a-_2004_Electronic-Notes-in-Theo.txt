We present a survey of the work on control-flow analysis carried on by the Venice Team during the Mefisto project. We study security issues, in particular information leakage detection, in the context of the Mobile Ambient calculus. We describe BANANA, a Java-based tool for ambient nesting analysis, by focussing on analysis accuracy and algorithmic optimizations.

These security issues constitute a very interesting workbench to evaluate the theoretical and practical impact of static analysis techniques. Giving a way for statically verifying a security property has, in principle, the advantage of making the checking of the properties more efficient; moreover it allows us to write programs which are secure-by-construction, e.g., when the performed analysis is proved to imply some behavioural security properties. A substan- tial body of research is available, relying on different static techniques and modeling languages, verifying different security properties [3,14,16,25].

(i) No Read Up, a low level entity cannot access information of a high level entity; (ii)No Write Down, a high level entity cannot leak information to a low level entity. In order to detect information leakages, a typical approach (see, e.g., [1,2]) consists of directly defining how information may flow from one level to another one. Then, it is sufficient to verify if, in any system exe- cution, no flow of information is possible from level high to level low. We have followed the above approach.

The starting point of our research was the Control Flow Analysis by Niel- son et al. presented in [15]. In [7], we refined such an analysis in order to detect information leakage. Both analyses have been implemented in the Banana(Boundary Ambient Nesting ANAlysis) tool [4], a Java applet avail-

The rest of the paper is organized as follows. In Section 2 we introduce the basic terminology of Mobile Ambient calculus and we briefly report the control flow analyses of [15,20] and of [6,7]. Then, in Section 3, we present the algorithms implemented in the Banana tool, which is described in detail in Section 4. Section 5 concludes the paper.

Initially, envelope is in site venice. Then, it exits venice and enters site pisa by applying its capabilities out venice and in pisa, respectively. Once site pisa receives envelope, it reads its content by consuming its open envelope capability. Finally, process P1 reaches the state: venice [ Q ] | pisa [ 0 ] .

This is the first motivation behind the work presented in [23] by Nielson and Seidl. Assuming N is the size of a process, the authors introduce two different algorithms that in O(N 4) and O(N 3) steps, respectively compute the ambient nesting analysis. The algorithms first perform a translation of the Control Flow Analysis constraints into ground Horn clauses. Then, these clauses are processed through satisfiability standard algorithms [12] in order to compute the least solution. As such algorithms always consider all the ground clauses corresponding to the analysis constraints, even in the best case, all the clauses need to be generated.

complexity of those algorithms is O(N 4 log N ) and O(N 3 log N ) bits, respec- tively, while the one of both our algorithms is O(N 2 log N ) bits. Regarding time, the worst case complexity is of the same order, i.e., O(N 4) and O(N 3) steps, respectively. In the Nielson and Seidl techniques, those complexities are tight because of the need of generating all the ground Horn clauses, as ex- plained above. Instead, our schemes perform better for some particular small solutions (e.g., solutions that are linear to the size of the process), reaching a complexity of O(N 3) and O(N 2) steps, respectively.

These improvements are first achieved by enhancing the data structure representations. Then, we attack the problem with a direct operational ap- proach, i.e., without passing through Horn formulas. Finally, we reduce the computation to the Control Flow Analysis constraints that are effectively nec- essary to get to the least solution. In fact, the algorithms dynamically choose, in an on the fly manner, only the constraints that are effectively necessary for the computation of the analysis. This implies that no useless repetition occurs and there is no need of representing in memory all the possible instantiation of constraints as done in the Nielson and Seidel approach.

In Section 2.3 we described the analysis in terms of a representation and a specification function. It is possible to prove that a least solution for this analysis always exists and it may be computed as follows: first apply the representation function to the process P , then apply the analysis to validate the correctness of the proposed solution, adding, if needed, new information to the triplet until a fix-point is reached. The iterative procedure computes the least solution independent of the iteration order.

An analyzer which computes an over approximation of all possible nestings occurring at run-time. The tool supports three different control flow anal- yses, namely the one of Nielson et al. in [15], the one by Braghin et al. in [6] (called Focardi Cortesi Braghin in the tool), and the one by Braghin et al. in [8] (FCB Boundary Inference). Five different implementations of the analysis described in [15] are available in the tool. They correspond to:

A post-processing module, that interprets the results of the analysis in terms of the boundary-based information-flow model proposed in [6], where infor- mation flows correspond to leakages of high-level (i.e., secret) ambients out of protective (i.e., boundary) ambients, toward the low-level (i.e., untrusted) environment.

The user can then choose to launch one of the algorithms which implement the analysis described in [6,8,15]. Once the analysis has started, the tool parses the process, builds a syntax tree, and computes the algorithm yielding to an over-approximation of all possible ambient nestings. The result of the analysis is reported in the Output Console as a list of pairs of labels.

