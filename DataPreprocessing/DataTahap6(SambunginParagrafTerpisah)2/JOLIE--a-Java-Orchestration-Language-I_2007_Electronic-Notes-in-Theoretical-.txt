The peculiar and original characteristic of JOLIE is that it combines a solid mathematical basis provided by the orchestration process calculus discussed above with a programmer friendly development and execution environment based on a C/Java-like (instead of a XML-based) syntax. This contrasts with most of the actual Web Services orchestration languages for which the formal operational semantics has been investigated and (partially) defined after the syntax. This contrasts also with the trend of developments of WS-BPEL for which, only after the definition of the orchestration language, an extension that includes the possibility to exploit and invoke Java programs is currently under development (see e.g. BPELJ [6]).

Moreover, JOLIE is a fundamental step in our research in orchestration and choreography languages because it permits us to experimentally verify whether the theoretical approach taken during the design of the process calculi are actually sat- isfactory also when the orchestration programs are to be actually run and executed. For instance, we had to add some additional constructs to JOLIE which where not included in the corresponding process calculus. In particular, JOLIE implements also an iterative statement while and a timing statement sleep(msec) for pro- gramming processes that wait for a certain amount of milliseconds. The latter is particularly useful to program orchestrators which are not willing to wait indefi- nitely for a service response that will never arrive due to either a communication or a service fault. It is also worth to underline that JOLIE has been developed by strongly exploiting the encapsulation principle and in a modular way which allows us to be protocol and communication medium independent. Namely, it is simple to extend the engine in order to run orchestrators that exploit different and het- erogeneous communication medium such as SOAP, Internet sockets, shared files, etc.

JOLIE provides a C-like syntax for designing orchestrator services. A C-like syntax makes the language intuitive and easy to learn for a programmer customed to it. In the following we introduce some basics of the JOLIE language, except expression and condition syntaxes which are similar to that of C language.

JOLIE communications are socket based: an orchestrator waits for messages on a network port (the default is 2555 4 ). In order to communicate with another orchestrator it is fundamental to know its hostname (or ip address) and the port it is listening to: these information are stored in a location. A location definition joins an identifier to a hostname and a port. The non-terminal follows:

By definition, input operations expect a list of identifiers, while the output ones expect a list of pairs id =id (we have identified such a list by using the notation id-assign list ). As far as the output operations are concerned we distinguish be- tween the operation name used within the orchestrator and the bound operation name of the invoked one. In a pair idA=idB, idA represents the internal operation name whereas idB the bound name of the external one to be invoked. Such a lan- guage characteristic allows us to decouple the orchestrator code from the external operation name binding. In the following a program fragment shows an example of operation declaration.

Definitions allows to define a procedure which will be callable by another one by exploiting the call statement. Each definition joins an identifier to a Process. Syn- tactically, a Process is a piece of code composed by JOLIE statements. Informally, the process defined within a definition can be viewed as the body of a C function.

id @id<id list > : uses the Notification operation represented by the first id to send a message which contains the values of the id list variables, to the orchestrator located at the second id. The second id can be a location declared in the locations block, or a variable containing a string that can be evaluated as a location. It is worth noting that such a feature allows to implement the location mobility. It is possible, indeed, to receive a location which can be exploited for performing a Notification or a Solicit-Response.

linkIn( id ) : linkIn and linkOut are used for parallel processes synchronization and must be always considered together. In particular the linkIn waits for a linkOut trigger on the same internal link identified by id. In case there are already one or more linkOut processes triggering for the same internal link, it synchronizes itself with one of them by following a non-deterministic policy.

The guards are defined within square brackets. When a non-deterministic choice is programmed it makes the interpreter waiting for an input on one of its guards. Once an input has come, the related p process is executed and the other branches are deactivated.

Future works will cover the implementation of a new format for locations, which will be aimed to exploit the communication medium independency of the Commu- nication Core. By now, every communication uses network sockets. The future format will permit to specify the communication medium in a location definition, giving the possibility to use sockets, files, internal pipes, etc. Moreover, another objective is to make the operations block interacting with WSDL definitions. To do so, we will exploit the object oriented internal operations implementation, along with the Communication Core data protocol independency. In this way, an orches- trator will be able to use other protocols in order to exchange data with external applications.

