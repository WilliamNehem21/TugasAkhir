COMMUNITY is a formal approach to software architecture. It has a precise, yet intuitive mathematical seman- tics based on category theory. It supports, at the methodological level, a clear separation between computation, coordination, and distribution (including mobility). It provides a simple state-based language for describing component behaviour that is inspired by Unity and Interacting Processes. It also addresses composition as a first class concern and accounts for the emergence of global system properties from interconnections. This paper describes the approach and available tool support by modelling essential aspects of the GSM handover protocol. We also sketch a framework that we are implementing for the distributed execution of such specifi- cations using Klava, a Java library for mobile agent systems based on tuple spaces.

COMMUNITY provides, like Darwin [10], Wright [1], or LEDA [3], among others, a formal approach to software architecture. It has several advantages over other approaches, the main one being a precise mathematical semantics: architectures are not just depicted through lines and boxes; they are diagrams in the sense of category theory [5], involving explicit superposition and refinement relationships between architectural components. This graphical semantics (in both the mathematical and visual sense) mirrors closely and intuitively the design of the architecture. The categorical semantics has also allowed us to study connectors in a deep, rigorous, and language-independent way [6]. In particular, we have defined higher-order connectors and shown how they can be used to put together complex interactions (e.g., an encrypted compressed asynchronous communication), (re)using simpler ones, and in a systematic way [9].

Like most architectural approaches, COMMUNITY enforces a strict separation between computation and coordination. More recently, we have extended the ap- proach with a small set of semantic concepts and syntactical constructs in order to include a distribution dimension that is kept separate from the other two [8]. The granularity of distribution is very fine in order to provide maximum flexibil- ity: the execution of an action may be distributed over many different locations; at each location, it performs whatever computations are prescribed according to the available resources, and communicates with its environment through the communi- cation channels that are in touch with the location. Changes to locations correspond to mobility of data or code. So far we have illustrated our approach with small ex- amples. The goal of this paper is to show how it applies to larger examples taken from real applications in which distribution and mobility are key concerns. For this purpose, we chose to model the GSM handover protocol. Due to space constraints, we only show a fragment; the complete details are given in [13].

The structure of this paper is as follows. We start with the description of the handover protocol as we use it. In Section 3, we present an informal review of COMMUNITY. Formal definitions can be found in the papers cited above. Ex- amples are taken from the GSM case-study. Next, we describe the COMMUNITY Workbench and the architecture description language. In Section 5, we show how the handover protocol can be modelled with COMMUNITY and tested with the workbench. We finish the paper with some concluding remarks.

Handover command : The new BSC prepares its BTS for receiving the new MS (step 1.b). Then, the new BSC initiates the handover by transmitting the handover command message to the MS through the old BSC (step 2). This step permits the MS to locate the radio channel of the new BTS/BSC.

In order to model systems that are location-aware, a recent extension [8] of COMMUNITY was developed that adopts an explicit representation of the space within which movement takes place, but does not assume any specific notion of space. In this way, Computation, Coordination, and Distribution/Mobility are ex- plicitly separated as architectural dimensions. The remaining of this section ex- plains how this separation is achieved.

Each local channel x is associated with a location variable l. We make this as- signment explicit by writing x@l in the declaration of x. The value of l indicates the current position of the space where the values of x are made available. A modification in the value of l entails the movement of x as well as of the other channels and actions located at l;

Every set of actions that are synchronized is represented by a single action whose occurrence captures the joint execution of the actions in the set. The transfor- mations performed by the joint action are distributed over the locations of the synchronized actions. Each located action is specified by the conjunction of the specifications of the local effects of each of the localized actions.

The COMMUNITY Workbench [12] implements directly over Java the construc- tions of coordination and distribution that give semantics to COMMUNITY as an architectural description language. Although COMMUNITY is independent of the actual data types used, the Workbench provides a fixed set of types: integer and real numbers, booleans, lists, arrays, records, and enumerations. The workbench also includes an export utility to save the whole architecture or just some connec- tors as a textual specification that can be easily read and understood without the tool as will be explained in the next section. The workbench is available from the COMMUNITY web site (www.fiadeiro.org/jose/CommUnity).

Specify the Loc type and the relations touch and reach: The location type is defined in terms of the pre-defined types (e.g., as a record of two integers to represent a 2 dimensional space). The relations are defined as boolean expressions with both parameters of location type.

Distribution This phase starts by checking the possible topological distribu- tion for each design and glue resulting from the previous phases. In case of re- quired distribution, the corresponding design or glue has to be extended/adapted with appropriate location variables and actions dealing with them (e.g., to ex-

Execution The architecture is executed with different initial values in order to test it. In the current version of the workbench, the execution of the specified architecture is centralized, in the sense that it is simulated by the execution of the generated colimit. In the future we will make available a distributed execution mode: the location values will be mapped to physical hosts and the physical mobility will be real (for more details see Section 5.5).

The bsc measure receives the measurements from its corresponding BTS (trough the respective connector bts measure), then verifies if the best measurement corre- sponds to its BTS. The result of the verification is send to the component BSC. For this purpose, it uses one input channel (distdist2) and one action (receive distdist2) to receive the measurements. The result is made available with the output chan- nel newId. As for the ms measure this design results from the abstraction of the treatment of the measurements and the communication into different components. And finally the bsc measure has an boolean input channel communication that is used as guard to the action which is used to receive the measurements. There is no sense to receive the measurements if this BSC is not the current one used on the communication.

This phase details each of the interactions identified in Section 5.1. That is, for each connector, its glue, roles, and attachments are completely defined. We show and discuss the details of the BTS entity. The separation of the two layers is represented by different connectors.

This is a binary connector relating the MS instance to a BSC instance. The glue part of this connector is a design with two input channels (inMsg and outMsg) for the incoming messages and outgoing messages during the communication, and two actions for transferring the messages (transferIn, transferOut). The roles of this connector are very simple designs, each having two channels and two actions to be refined with component instances of the architecture (see below). After declaring one instance of the glue (btsI) and one instance for each role (msroleinfoI, bscrole- infoI), the attachment part defines the interactions of the glue channels and actions with those in both roles. For example, the output channel outMsg (resp. inMsg) has to be linked with the msroleinfoI instance through inMsg (resp. outMsg) and with the bscroleinfoI through outMsg (resp. inMsg). The same linking is to be applied between the transfer, send, and receive actions.

We now present a summary of the architecture for distributed execution that we are currently implementing in the Workbench, based on the Klava package [2]. This library for mobile agent systems based on tuple spaces contains some facilities for specifying hosts, and logical and physical locations. The communication between hosts is encapsulated in a sub-layer, and because of that, we can abstract from the communication implementation layer. The Klava package has support for nodes that are located on the hosts and support for execution of processes on the nodes.

The specification of the architecture is distributed over a set of hosts, where we give an important role to one host, called the global host, which has the centralized knowledge of the architecture in COMMUNITY. We define a mapping from the location values of the location types to the existent hosts. The touch and reach relations are implemented directly in Java over the location type.

