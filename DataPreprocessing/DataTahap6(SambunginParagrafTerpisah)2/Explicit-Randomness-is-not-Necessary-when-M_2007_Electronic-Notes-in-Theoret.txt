One of the most popular abstraction used in security analysis uses abstract, symbolic terms to model the bit strings sent over the network. However, the high level of abstraction blurs the significance of proofs carried out in such models with respect to real executions. In particular, although good encryption functions are randomized, most existing symbolic models for security do not capture explicitly the randomization of ciphertexts.

In this paper we put forth a more practical alternative. We show that for a large class of security properties (that includes rather standard formulations of secrecy and authenticity), security of protocols with respect to the simpler model implies security in the model that uses labels. Combined with the computational soundness result of [4], our theorem enables the translation of security results obtained in symbolic mod- els that do not use labels to standard computational security. Based on these results, we have recently implemented an AVISPA module for verifying security properties in a standard cryptographic model.

A central feature of the computational, complexity-based models is the ability to capture and reason explicitly about the use of randomness. Moreover, randomness is essential to achieve any meaningful notion of security for encryption. In contrast, symbolic models rarely represent randomness directly. For example, a typical rep- resentation for the encryption of message m under the public key of entity B is the term {m}ek(B). Notice that the symbolic representation does not capture the dependency on the randomness used to generate this ciphertext. While this ab- straction may be sufficiently accurate in certain settings [11], in some other settings it is not sufficient.

A model that employs labels to capture the randomness used in ciphertexts (and signatures) has recently been used to establish soundness of symbolic analysis with respect to computational models [4]. Their results are based on an emulation lemma: for protocol executions, every computational trace can be mapped to a valid sym- bolic trace. The mapping is then used to translate security properties that hold in the symbolic model to computational analogues. Note that the use of labels is necessary even when there is no explicit repetition of cyphertexts to distinguish for example the encrypted messages generated by the agents from those generated by the adversary.

In this paper we put forth and clarify an alternative solution, used implicitly in [4]. The idea is to keep existing tools unchanged, use their underlying (unla- beled) model to prove security properties, and then show that the results are in fact meaningful for the model with labels. The main result of this paper is to prove that for a large class of security properties the approach that we propose is indeed feasible.

erties for protocols with and without labels, respectively. Informally, the formulas of L1 are obtained by removing the labels from formulas of Ll . Both logics are quite expressive. For example, it can be used to express standard formulations for secrecy and authenticity properties.

In this section we provide the syntax of protocols with labels. The presentation is adapted from [4]. The specification language is similar to the one of Casrul [12]; it allows parties to exchange messages built from identities and randomly generated nonces using public key encryption and digital signatures. Protocols that do not use labels are obtained straightforwardly.

parties by outputting a set of identities. He receives in return the secret keys corresponding to the identities. It happens only once at the beginning of the execution. We focus on static corruption because the soundness result using explicit labels in [4] only considers this kind of corruption. However, in our formal context, our reduction result should be easily extended to the case of adaptive corruption (when agents are corrupted at any time during the execution) since we can map traces with dynamic corruption to traces where all corrupted agents are so at the beginning.

We use the deduction relations to characterize the set of valid execution traces. We say that the trace (SId1, f1, H1),... , (SIdn, fn, Hn) is valid if the messages sent by the adversary can be computed by Dolev-Yao operations. More precisely, we

Proof  The key argument is that only pattern matching is performed in protocols and when a term with labels matches some pattern, the unlabeled term matches the corresponding unlabeled pattern. The proof is done by induction on the length of the trace. Full details are provided in Appendix A.

The AVISPA project [2] provides a platform for automatic verification of security protocols. The platform includes a specification language called HLPSL that can be used for specifying both protocols and security properties. Protocols specified in this language can be verified with four different tools. Three of them, OFMC, ATSE, and SATMC, use symbolic models where the number of sessions that can be executed in parallel is bounded. The fourth tool, TA4SP, provides verification abilities for an unbounded number of sessions. The tools can be used to verify three security properties: secrecy, weak authentication, and replay protection.

