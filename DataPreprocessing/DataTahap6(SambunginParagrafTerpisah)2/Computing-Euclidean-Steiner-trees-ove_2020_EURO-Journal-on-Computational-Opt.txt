In the classical Euclidean Steiner minimum tree problem, the input is just a set of points called the terminals. It has many applications and has been widely investigated since its introduction. The most efficient publicly available implementation is the GeoSteiner package of Juhl et al. (2018), which implements a two-phase approach first introduced by Winter (1985). In the first phase, a superset of so-called full components is generated, and in the second phase, the minimal subset of this superset is computed, leading to a Steiner tree. Algorithms for the first phase are based on an approach of Winter and Zachariasen (1997), whereas the second phase is based on an approach by Warme (1998). Alternatively, the second phase can be solved by using an algorithm for the Steiner tree problem in graphs, as shown in Polzin and Daneshmand (2003). Computational studies and several improvements are given in follow-up papers (Juhl et al. 2018; Warme et al. 1999, 2000).

The authors mentioned above considered several variants of the Euclidean Steiner tree problem, such as obstacle-avoiding Steiner trees (Zachariasen and Winter 1999), Steiner trees in other metrics like the Manhattan distance (Warme 1997) and Steiner trees that lie within polygons (Winter et al. 2002). To the best of our knowledge, the problem we are investigating has not been considered before.

Our algorithm is based on a structural theorem of Steiner minimum trees over seg- ments that will allow us to use an algorithm that is very similar to the one implemented in GeoSteiner, so we can reuse their implementation of the second phase. Our approach solves the problem exactly and is more efficient than the inexact solution when we sample the given segments (see Sect. 5 for a description of the sampling approach used in the comparison).

The paper is organized as follows: In the following section, we formally define the problem and introduce necessary notations and definitions. In Sect. 3, we prove our main theorem and discuss how the algorithm for the first phase in GeoSteiner has to be modified. In Sect. 4, we show how to reduce the size of the computed superset of full components. We show some computational experiments in Sect. 5 and finally conclude in Sect. 6.

terminal segments and Steiner points. Hence, in a topology, the positions of the ter- minal points are fixed, the positions of the open terminal segments are on a segment but not on one of its endpoints and the positions of the Steiner points are free. The topology represents the nodes and edges of a graph, but without an exact statement about the length of the edges or the positions of the nodes. They only specify adjacent nodes. Notice that these definitions slightly differ from those of Brazil and Zachariasen (2016), as our problem is more general.

each such cycle to a single node, it becomes a tree, denoted as T |S . The contraction of an edge (u, v) of a graph G = (V , E) results in the graph Gr = (V r, E r) in which u and v are replaced by a single node [uv] and each endpoint of an edge that is either u or v is replaced by [uv]. The contraction of a cycle is the contraction of all the edges on it.

label of one of the vertices is different (the vertex that attaches to the segment on the top left is a terminal point in this last topology and a open terminal segment in the first two). Our structural theorem shows that we can restrict the full topologies to full topologies of at most one open terminal segment, i.e., we do not have to consider the first two, but only the third

In the second phase, we select a minimum cost subset of the enumerated full com- ponents whose union forms a Steiner tree. It works exactly as in the classical SMT. We interpret the superset of full components as weighted hyperedges in a hypergraph and compute the minimum cost spanning tree in the hypergraph. In our experiments, we used the implementation provided with Juhl et al. (2018).

First, we can restrict the arc due to geometry, i.e., if the Steiner point of the root lies within its feasible subarc, all other Steiner points must lie on their feasible subarcs too (see e.g., Brazil and Zachariasen 2016). Another example of a well-known pruning test is the lune property (see again Brazil and Zachariasen 2016), which works as

We implemented the algorithm to construct a superset of full components of an optimal Steiner tree in Java, using only the basic pruning tests that were known already for the classical SMT problem. For the selection of the full components of the optimal tree, we used the implementation of GeoSteiner 5.1 of Juhl et al. (2018). All experiments were done on a single core of an Intel Core i5 2430M processor with 2.40 GHz and 6 GB DDR3-SDRAM memory.

