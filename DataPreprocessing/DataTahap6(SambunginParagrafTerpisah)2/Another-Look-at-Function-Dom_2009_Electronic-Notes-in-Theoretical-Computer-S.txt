Here we present a new approach for dealing with partial and general recursive functions that preserves the advantages of the method by Bove and Capretta, but which does not rely on inductive-recursive definitions. In this approach, we start by inductively defining the graph of the function, from which we first define the domain and afterwards the type-theoretic version of the function. We show two ways of proving the formal specification of the functions defined with this new approach: by induction on the graph, or by using an induction principle in the style of the induction principle associated to the domain predicates of the Bove-Capretta method.

As we have already said, the type-theoretic version of the function following the Bove-Capretta method (which we call f91 below) takes as an extra argument the proof that the input belongs to the domain of the function (which we call dom91 below). We now analyse the above definition of f in order to identify its domain. It is clear that the function terminates on any element n such that 100 < n. On the other hand, if n <= 100 then the function terminates on n if it terminates on the arguments n + 11 and f(n + 11). From this analysis, it is easy to see the simultaneous dependency between the function and its domain in the presence of nested recursive calls.

(If we have a proof that dom91 is satisfied by every natural number, we could elimi- nate the dependency of the above induction principle on the domain predicate and obtain a simpler induction principle where the predicate has just type Nat -> Set.) In a system like Agda, however, we can express structural induction directly by using pattern matching. According to the Curry-Howard isomorphism, a proof by structural induction corresponds to a definition of a function by structural recursion: recursive calls correspond to the use of induction hypotheses. This way of writing proofs is actually very convenient since the use of pattern matching facilitates the

In the remaining case, that is, when n < 100, we analyse an intermediate result: the fact that either 100 < n+11 or n+11 <= 100. If 100 < n+11, we call res-100< on the argument of the first recursive call and we do induction on the argument of the second recursive call. If n + 11 <= 100, we do induction on the arguments of both recursive calls.

The new proof of res-<=100 is also very similar to that presented in the previous section. Here again, we can choose between having an auxiliary function where we pattern match directly on the graph argument, or having only one function where we first pattern match on the domain argument and then pattern match on its graph component. In Section A.2 we show only this last alternative.

We could add here that if we use the induction principle associated to the pred- icate dom91 to prove this property when referring to the function f91, we obtain almost the same code as in Section A.3, the only difference being that in that case we would need a proof that n satisfies dom91 (instead of Dom91) to be passed as an argument to res-==100. What this observation tells us is that the difference in the structure and readability of the proof does not depend on the new approach, but on the use of the induction principle to obtain the proof in place of the pattern match- ing and the structural recursion on an inductively defined argument, for which the Agda system is designed.

We presented an alternative method to define partial and general recursive func- tions in constructive type theory. Here, instead of defining an inductive predicate characterising the domain of the function, we inductively define the graph of the function. From the graph, the domain of the function is defined and thereafter the type-theoretic version of the function, which takes an extra argument with a proof that the input satisfies the domain.

During the last decade there has been several ideas on how to deal with partial and general recursive functions in a total setting. We give a rather detailed survey of those ideas in the related work section of a previous paper [6]. Since the publication of that article, there have been a couple of papers that use co-inductive types to model partiality [9,7], and a suggestion to extend type theory with a type of partial recursive functions [8]. See the introduction section of this last article for a survey of other approaches to defining a type of partial functions in type theory.

In [15], McKinna addresses the problem of how to prove properties of a function that has been already defined. In his work, which is done together with C. McBride, McKinna presents the idea of using graph induction for this purpose. While the presentation shows how one can use the Epigram system [14] (a system in the spirit of the Agda system we use here) to make the proofs, the issue he discuses is not really the one we address in here, in the sense that our starting point is how to define the function that we will later verify.

Barthe et al [2] present a tool to define and prove properties of recursive functions in Coq. From a pseudo-code of a function, the tool generates the graph of the function, basically with the same information as the graphs we use here. From this graph, the tool by Barthe et al can define the function in two different ways. In one of the approaches, the domain of the function and the function itself are defined basically as in the Bove-Capretta method. In the second approach, the user must provide a measure and proofs that each recursive call is performed on smaller arguments according to that measure. Given the graph and the measure, the proof obligations the user must prove are automatically generated by the tool. Using well-founded induction, the tool can now define the total function that is given by the graph. This second approach can then only be used for total functions. Among other things, an induction principle is generated for the function.

Using the tool developed by Barthe et al, partial functions can only be repre- sented by using the first approach described above, that is, by defining the domain and the function as in the Bove-Capretta method. Coq type system does not sup- port simultaneous inductive-recursive definitions, so no nested recursive function can be formalised with this tool. Since the second approach described above can- not be applied to partial functions there is no way to deal with partial and nested recursive functions using the tool described in [2].

There are a few reasons behind this less readable code, some of them related to the fact that Agda has mainly been design to work with definitions by pattern matching instead of with induction principles and recursive combinators. First, Agda does not provide a way to perform case analysis on the right hand side of a definition, and even though the result of analysing cases on the expression (co 100 (n + 11)) is basically the same as the result of performing an ||-elimination on the same expression, the code is more readable when using the former way. In addition, performing an ||-elimination instead of pattern matching on a proof that n <= 100 makes the code longer and more difficult to read. Finally, in the case where n == 100 (last case), we need to call the lemma res-==100 with a proof that n satisfies Dom91; this proof is a bit cumbersome to obtain from the information available from the induction principle.

