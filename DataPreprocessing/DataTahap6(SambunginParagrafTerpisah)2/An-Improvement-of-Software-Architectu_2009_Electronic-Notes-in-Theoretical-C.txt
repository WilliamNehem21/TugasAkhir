Static analysis is an approach to program behavior verification without execution. The approach is particularly useful in identifying program design errors prior to implementation. It has been demonstrated that detecting errors early in the lifecycle greatly reduces the cost of fixing those errors. A number of static analysis techniques

In general all existing approaches appear to be very sensitive to the size of the program being analyzed in terms of the use of concurrency constructs and the num- ber of asynchronous processes. Particularly, reachability analysis may cause state space explosion problem since it has to exhaustively explore all the reachable state space to detect concurrency errors. Although many techniques have been proposed to combat this explosion, such as state space reductions, compositional techniques, abstraction, the state explosion problem still is the main technical obstacle to tran- sition from research to practice.

Current concurrent systems are described as discrete event system models which are suited to model system concurrency. However, the discrete will lead to state explosion problem since model checkers build a finite state transition system and ex- haustively explore the reachable state space searching for violations of the properties under investigation [3]. Hence, to thoroughly solve the state explosion problem, one solution is that the discrete event system model should be continunized to continu- ous system model, such that the systems can be described with analytic expressions. Therefore, instead of counting states, we can analyze the solutions of the analytic expressions.

Petri net seems a good candidate that bridges discrete event systems and con- tinuous systems. On one hand, Petri nets have been used extensively as tools for the modeling, analysis and synthesis of discrete event systems. Petri nets offer ad- vantages over finite automata, particularly when the issues of model complexity and concurrency of processes are of concern. On the other hand, a continuous system can be approximated by a Petri net [20] and a Petri net model is used as discrete event representation of the continuous variable system by Lunze et al. [17].

As in [19], we will check two specifications of the architecture. The first one is a critical race, in which one customer pays for gas and the second customer then pays and takes the pump before the first customer gets gas. The second specification is that no customer receives gas without paying for it.

Hierarchy and modules: The basic Petri-net model does not support hierarchy and composition explicitly. As in most ADL specifications, a whole system is nor- mally composed of components and connectors, which are most suitably described as submodules of a whole system. To support this, we introduce the module concept into the Petri-net model. We can map each component or connector into a small Petri-net module (sub-graph). With all the modules, together with the IO-nets concept below, we can model the whole system.

This mapping is actually a conversion of CSP operators into Petri-net transition structures. A set of conversion rules have been defined to cover the most common CSP operations [22]. Under these rules, the properties of the architecture, such as deadlock, will be reserved.

Definition 3.1 A Place/Transition Chain is a net such that transitions are con- nected by a head place that has one output arc and no input arc, an end place that has one input arc and no output arc, and places that have one input arc and one output arc. If the head place and the end place are overlapping, then the chain is called Place/Transition Cycle.

The Petri net obtained in the last section is discrete Petri net, in which the number of marks in the places are integers. A transition is enabled if each input place of the transition is marked with a token. An enabled transition fires by removing a token from each input place and adding a token to each output place.

Later, we will prove that the states of each process cycle take values from [0,1]. For a state , if () = 1, then we say that the program is completely in the state , or simply in the state . If () = 0, then we say that the program is not in the state .

All the i defined above are the state measures. So, if new marking is moved into a place, we say that the state is increasing; if some marking is moved out from a place, we say that the state is decreasing. The change rate of state measure can be calculated as the following.

Here we use () to represent some other state measures. If more than two processes are involved in sharing , say 3 processes 1  2 and 3, then we will have two parameters: 1 and 2. Let 1, 3 and 5 be the input transitions that need resource.

As the next step study, we will check the efficiency of our method applied to the systems that consist of large number of behaviorally similar processes, e.g. in the gas station example there exist lots of customer processes, pump processes and casher processes, and find out how our model complement to those discrete event based models, e.g. [23], that are used to handle the large number of processes.

