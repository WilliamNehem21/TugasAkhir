The last two decades have been the most productive from the point of view of tech- niques and tools for testing and ensuring the reliability of complex software. The investment in formal methods has produced a number of powerful languages, algo- rithms, methodologies and tools to be successfully employed with software models. Today, we can think of applying the same methods to real programs in a transparent way, integrating the verification functionality within the compiler.

This promising scenario is mainly due to the advances in two major techniques: static program analysis and model checking. In a few words, a static analysis carries out a static (abstract) execution of a program in order to extract correct informa- tion about its behavior during execution. This information is typically utilized to discard some programming errors as soon as possible, and to improve the program compilation. Regarding model checking, it is a technique based on exhaustive explo- ration of states produced by (concurrent) programs, to check the satisfiability of a desirable program behavior. Our work exploits the use of model checking as a static analysis implementation method that can be naturally coupled with compilers.

includes the intended result for the LV analysis. It shows which variables x or y are live on the different program points. For instance, variable y is not live at the first two lines of the program, because its value is updated before being read.

gram analysis. We illustrate the Bes specification capability by encoding classical Dfas [15]. The resulting Dfas are nicely implemented thanks to a generic algorithm, which evaluates the different Bes encodings over a given program described as an implicit Labeled Transition System (Lts). The algorithm was integrated into the well-known Cadp toolbox [8], and experiments confirmed that it worked efficiently for realistic examples.

store the program counter (an element of set {0, 1, 2, 3, 4, 5}). Actions in P are the boolean expressions and assignments in the code. We remark that, since only the Cfg is kept in the Lts, the current value of program variables in each state is ignored.

variables. Moreover, three labels BOOL, ASSERT, and API respectively establish if the corresponding program instruction is a boolean or assignment expression, or a system call to an Api of interest. This information is relevant for some static analyses, like influence analysis [2, 4, 5] and makes possible both property verifica- tions and program optimizations. Such a format further allows to automatically and incrementally construct the (strict necessary parts of the) resulting Lts considering a program Cfg.

Since variable Xs,e is recursively defined in terms of its successors Xs',e, solving Xs,e forces to traverse the whole Lts. Xs,e being a tautology, its final value is always true. Once Xs,e is computed, testing the inclusion of Ys,e in computed(Y ) gives that expression e is not available at state s. If Ys,e is not included in computed(Y ), then testing the inclusion of Zs,e in computed(Z) gives that expression e is available at state s. Otherwise, e is not available at s.

We discuss below the behavior of algorithm Analyse w.r.t. efficiency. Every transition in the Lts is traversed exactly once per program variable or expression. We assume that Bes resolutions are linear in the size of the Lts [14]. Since the constructed Bes is unique for all states given a variable or an expression, resolution of already solved boolean variables is done in constant time. Therefore, each call

We performed several experiments to compare the results of our Dfas with those observed in the literature [15]. We considered twelve classical C program examples showing the interest of using one or the other Dfa to simplify the compilation of the program. We also performed a series of experiments for investigating the effectiveness of influence analysis [4, 5]. Besides Promela examples extracted from the literature [2], we also considered ten other C program examples specific for each one of the implemented influence analyses.

To show the applicability of our tool to a third specification language, we took a Lotos description of the Dekker mutual exclusion protocol 2 (89 lines of Lotos, 2 processes, 9 variables, 954 states, 1 908 transitions, and 17 labels) on which we tested the nine currently implemented Dfas. The first step was to automatically extract out of the specification a specific Petri net, called network, that can be fur- ther processed to obtain a Cfg of the protocol (25 states, 134 transitions) [9]. The graph was then transformed into our abstract model, by appropriately relabeling the transitions. Finally, the resulting abstract Lts was processed by Annotator. From the results, we conclude that, among the nine variables present in the specifi- cation, none of them were live at all states. This means that an explicit verification of the program can ignore many variables in the state vector at different control point without loosing any information relevant for a formula to be evaluated (as purpose, the static analysis resulting from the interconnection of Annotator and C.Open into Cadp could then be integrated to the model extractor SocketMC [3]. Finally, we will seek solutions to other static analysis problems, such as reset vari- ables analysis [9], by investigating their translation in terms of Bes resolution, and by studying the a priori natural and efficient connection of existing compilers to our abstract Cfg model.

