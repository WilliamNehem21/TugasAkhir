We propose generic invariant-driven strategies that control the execution of systems by guarantee- ing that the given invariants are satisfied. Our strategies are generic in the sense that they are parameterized by the system whose execution they control, by the logic in which the invariants are expressed, and by the invariants themselves. We illustrate the use of the strategies in the case of invariants expressed in propositional logic. However, the good properties of Maude as a logical and semantic framework, in which many different logics and formalisms can be expressed and executed allow us to use other logics as parameter of our strategies.

To deal with nonterminating and nonconfluent systems, we need good ways of controlling the rewriting inference process. In this line, different languages offer different mechanisms, including approaches based on metaprogramming, like Maude [2,3], or on strategy languages, like ELAN [1]. However, although the separation of logic and control greatly simplifies such a task, these mecha- nisms are sometimes hard to use, specially for beginners, and usually compro- mise fundamental properties like extensibility, reusability, and maintainability.

The execution or simulation of specifications with constraining invariants is typically based on integrating somehow the invariants into the system code. However, such an integration is clearly unsatisfactory: the invariants get lost amidst the code, and become difficult to locate, trace, and maintain. More- over, the programs and the invariants to be satisfied on them are usually expressed in different formalisms, and live at different levels of abstraction: invariants are defined on programs. Therefore, it is interesting to have some way of expressing them separately, thus avoiding the mixing of invariants and code.

In this paper we propose generic invariant-driven strategies to control the execution of systems by guaranteeing that the given invariants are always satisfied. Our strategies are generic in the sense that they are parameterized by the system whose execution they control, by the logic in which the invariants are expressed, and by the invariants themselves. The good properties of Maude as a logical and semantic framework [8], in which many different logics and formalisms can be expressed and executed, allow us to say that other logics and formalisms may be used as parameters of our strategies. We will use in this paper the case of propositional logic, although we have also experimented with future time linear temporal logic.

The paper is structured as follows. Section 2 serves as a brief introduction to rewriting logic and Maude. Section 3 introduces the definition of strate- gies in Maude, and serves as a basis for the introduction of invariant-guided strategies in Section 4. Section 5 describes as an example the case of invari- ants expressed using propositional calculus. Finally, Section 6 draws some conclusions.

where O is the name of the object, and vi are the current values of its at- tributes. Objects can interact in a number of different ways, including mes- sage passing. Messages are declared in Maude in msg clauses, in which the syntax and arguments of the messages are defined.

The system behavior is defined by four rules, each one representing a local transition of the system. For example, the rule labeled as grab may be fired when a philosopher object I is hungry and it receives a message indicating that the chopstick J is free, being the chopstick J one of the chopsticks I can grab. As a result, the message is consumed, and the number of chopsticks grabbed by the philosopher is increased. The syntax for rules and conditional rules is, respectively, rl [l]: t => t' and crl [l]: t => t' if c, with l a rule label, t and t' terms, and c a rule condition.

To illustrate the general approach, and as a first step towards our final goal, let us suppose that we are interested in a strategy that rewrites a given term by applying on it all the rules in a given module, in any order. The strategy should just try to apply the rules one by one on the current term until it gets rewritten. Once a rule can be applied on it, the term resulting from such an application becomes the current term, and we start again. If none of the rules can be applied on a term, then it is returned as the result of the rewriting process. Such a strategy can be specified as follows: term representing the initial state of the system. rewAux takes three argu- ments: the module describing the system, the term being rewritten, and a continuation structure with the labels of the rules in the module, which allows us to iterate on the labels in some order. The strategy gives as result a term which cannot be further rewritten.

Now the auxiliary function is invoked if the initial state satisfies the invari- ant. Notice that the operator rewInv is declared using ~>, meaning that if not reduced, it will return an error term of sort [Term], which represents the kind of the sort Term and all sorts in its connected component. 6 A kind is seman- tically interpreted as the set containing all the well-formed expressions in the sorts determining it, and also error expressions. Moreover, the strategy takes a rewriting step only if the term can be rewritten using a particular rule and it yields to a next state which satisfies the invariant. An invariant I is checked by

The logic in which the invariants are expressed is independent of the system to be executed. This would allow us to use one logic or another to express our invariants depending on our needs. We illustrate our approach with proposi- tional logic.

op _and_ : Formula Formula -> Formula [assoc comm prec 55] . op _or_ : Formula Formula -> Formula [assoc comm prec 59] . op _xor_ : Formula Formula -> Formula [assoc comm prec 57] . op not_ : Formula -> Formula [prec 53] .

The module PROPOSITIONAL-CALCULUS introduces the sort Formula of well-formed propositional formulae, with two designated formulae, namely True and False, with the obvious meaning. The sort Proposition, corre- sponding to the set of atomic propositions, is declared as subsort of Formula. Proposition is by the moment left unspecified; we shall see below how such atomic propositions are defined for a given system module. Then, the usual operators are declared. These declarations follow quite closely the definition of Boolean values in Maude and OBJ3 [5], which are based on the decision procedure proposed by Hsiang [7]. This procedure reduces valid propositional formulae to the constant True, and all the others to some canonical form which consists of an exclusive or of conjunctions.

We have proposed generic invariant-driven strategies, which control the exe- cution of systems by guaranteeing that the given invariants are satisfied. Our strategies are generic in the sense that they are parameterized by the sys- tem whose execution they control, by the logic in which the invariants are expressed, and by the invariants themselves. This parameterization, together with the level of modularization of the approach, allows improving quality factors such as extensibility, understandability, usability, or maintainability. We have illustrated its use with invariants expressed in propositional calcu- lus. However, the good properties of Maude as a logical and semantic frame- work [8], in which many different logics and formalisms can be expressed and executed, allow us to use other logics as parameters of our strategies.

