[10] a translation of a specific class of graph grammars, Object Based Graph Gram- mars (OBGG), to PROMELA was defined, which allows verification using the SPIN model checker [14]. [15] presents an approach to verify a timed extension of graph grammars, allowing the automatic verification of real-time systems using the UP- PAAL model checker [4]. Different approaches for model-checking other kinds of graph grammars can be found in [17].

logical languages. In [7] the description of graph properties and the transformation of graphs in monadic second-order logic is proposed. However, these works are not particularly interested in effectively verifying the properties of graph transformation systems (GTSs). On the other hand, other authors have investigated the analysis of GTSs based on relational logic or set theory. Baresi and Spoletini [3] explore the formal language Alloy to find instances and counterexamples for models and GTSs. In fact, with Alloy, they only analyze the system for a finite scope, whose size is user-defined. Strecker [21], aiming to verify structural properties of GTSs, proposes a formalization of graph transformations in a set-theoretic model. Nevertheless, this work does not use a logical approach and it just presents a glimpse on how to reason about graph transformations.

The rest of the paper is organized as follows. In Section 2, we introduce graph grammars according to the SPO-approach [20]. In Section 3 we present our rep- resentation of graph grammars by relational structures and in Section 4 we use first-order formulas to define rule applications as graph grammar transformations. Finally, in Section 5 we use our approach to verify properties of systems specified in graph grammars through mathematical induction. Final remarks are given in Section 6.

We illustrate the use of graph grammars specifying the token-ring protocol. This protocol is used to control the access of various stations to a shared transmission medium in a ring topology network [22]. According to the protocol, a special bit pattern, called the token, is transmitted from station to station in only one direc- tion. When a station wants to send some content through the network, it waits for the token, holds it, and sends the message (data frame) to the ring. The message circulates the ring and all stations may copy its contents. When the message com- pletes the cycle, it is received by the originating station, which then removes the message from the ring and sends the token to the next station, restarting the cycle. If only one token exists, only one station may be transmitting at a given time. Here we will model a token-ring protocol in an environment in which new stations may be added at any time.

Aiming to define a theory that allows the formulation of properties and the develop- ment of proofs for systems specified as graph grammars, we propose a representation of graph grammars by relational structures (i.e., by structures with relations only). A relational structure [8] is a tuple formed by a set and by a family of relations over this set.

We start by defining a relational structure to model graphs, and establishing a relational representation for graph morphisms, typed graphs and rules, which will later be used to build the relational structure associated to a graph grammar. Due to space limitations, proofs about the well-definedness of the relational representations were omitted. A relational structure representing a graph G is a tuple composed of a set, the domain of the structure, representing all vertices and edges of G and by two finite relations: a unary relation, vertG, defining the set of vertices of G and a ternary relation incG representing the incidence relation between vertices and edges of G.

The relational representation of a graph morphism g from a graph G toa graph H is obtained through two binary relations: one to relate vertices (gV ) and other to relate edges (gE). Since these relations just map vertices and edges names, we have to impose some restrictions to ensure that they represent a morphism. The existence condition states that if two vertices are related by gV then the first one must be a vertex of G and the second one a vertex of H, and if two edges are related by gE, then the first one must be an edge of G and the second one an edge of H. The commutativity condition assures that the mapping of edges preserves the mapping of source and target vertices.

A relational graph morphism is also the basis of the relational definition of a rule from a graph L to a graph R. Since both graphs mapped by a rule are typed over the same graph T , a compatibility condition assures that the mappings of vertices and edges preserve types. Besides, rules must not collapse vertices or edges, nor delete vertices.

Given a graph grammar GG = (T, G0, R), we define a relational structure |GG| associated to it as a tuple composed of a set and a collection of relations. The set describes the domain of the structure. The relations define the type graph, the initial graph and the rules. The type graph is defined by relations of a Rgr- structure representing T . The initial graph G0, the left- and right-hand sides of rules are specified by relations of Rgr-structures representing graphs, which are typed over T by relational typing morphisms. Relational rules map the graphs of left-hand side and right-hand side of rules.

(obtaining a graph G0' according to the transduction defined in Section 4). The standard library must provide a collection of (recursive) functions that can be used to enunciate and prove desirable properties. For instance, we define two functions: one to determine the types of edges of a reachable graph and another to indicate if a reachable graph has a ring topology. Let |GG| be the relational structure associated to a graph grammar. 5

We have introduced a relational and logical approach to graph grammars to al- low the analysis of asynchronous distributed systems with infinite state space. In order to represent this specification language, we have used a relational structure to characterize a graph grammar and defined rule applications as first-order defin- able transductions. The main aim of this work is to enable the use of the theorem proving technique to prove properties about graph grammars, especially properties about reachable states.

We plan to extend the approach proposed here to specific classes of graph gram- mars such as, for example, object-based graph grammars [10], appropriate for the specification of object-based systems, or timed object-based graph grammars, suit- able to specify real time systems. In the first case, the set of vertices of the graph grammar must be partitioned in two subsets of objects and values (of abstract data types) and the set of edges should be replaced by a set of hyperedges that must be partitioned into sets of message and attribute edges. In the second case, we also have to add time stamps to the messages. This extension will allow the proof of properties usually not analyzed in model-checkers of object-based systems such as properties about the internal states of objects and their attributes. Another topic of future work is the implementation of the proposed approach using, for example, the Isabelle theorem prover [16].

