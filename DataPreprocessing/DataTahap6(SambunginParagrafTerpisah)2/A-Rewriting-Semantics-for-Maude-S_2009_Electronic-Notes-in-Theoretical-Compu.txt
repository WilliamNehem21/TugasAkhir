of the language, although they of course import the system module M whose exe- cution the strategies in SM control. This strict division of labor between M and SM has some advantages. On the one hand, the strictly declarative nature of M is preserved. On the other, this separation facilitates modularity, since the same system module M can have many different strategy modules SM for different pur- poses. In ELAN, since it is possible to include strategy expressions within a rewrite rule definition, this separation is not enforced by the language. However, we believe that it is possible to develop ELAN modules following the separation methodology that we advocate here.

substitution S and using E1, . .., En as strategy expressions to check the rewrites in the condition of L. The number of rewrite condition fragments appearing in the condition of rule L must be exactly n for the expression to be meaningful.

With the previous combinators we cannot force the application of a strategy to a specific subterm of the given initial term. In particular, the scope of the substitution in the (a)match combinators is only the corresponding condition. We can have more control over the way different subterms of a given state are rewritten by means of the (a)matchrew combinators. When the strategy expression ..., Expn are strategy expressions (over the language of labels provided by M), where the identifiers can appear, thus allowing (mutually) recursive definitions. The basic idea is that these strategy declarations provide useful abbreviations for strategy expressions E that the user can then utilize in a (strategy rewrite) command srew T using E, which rewrites a term T using a strategy expression E.

syntax defined in the system module M. When a strategy identifier is declared (with the keyword strat), the types of its arguments (if any) are specified between the symbols : and @. After the symbol @, the type of the terms to which this strategy can be applied is also specified.

Applying a strategy to a term is a task that, in the process of rewriting, can give rise to more tasks. Therefore, the sort Tasks represents sets of tasks by means of an associative, commutative, and idempotent operator written as juxtaposition, with identity the empty set none. Solved tasks are of the form sol(t), meaning that the term t is a solution. Sometimes, these solutions are only the intermediate results in a task that must be continued with another process; therefore, there is also some syntax to represent continuations as terms of sort Cont.

The treatment of conditional rules is much more complex, because we need to make sure that each solution satisfies the rewrites in the condition using the appropriate strategies. Moreover, we need to guarantee that no solution exists when returning the empty set. For these reasons, we make use of a continuation that handles this situation. Let us consider a conditional rule of the form

The following rules describe the behavior of the mrew continuation. For each solution obtained from the previous task, this continuation finds the appropriate fragment to be rewritten using the next strategy in the strategy list. When the strategy list is empty, the continuation simply takes care of rebuilding the whole term by putting together the solution inside the appropriate contexts.

In our rewriting semantics, the initial terms denoting the application of a strat- egy to a state term have the form <E @ t> and are of sort Task. When this term is rewritten using the rules described in the previous section, new tasks are created, so that rewriting takes place at the level of the sort Tasks representing sets of tasks. Those tasks (at the top level) of the form sol(t) represent the solutions obtained up to the moment. Then, the abstract function sols mentioned in Section 2 is defined in our case as follows: for a term w of sort Tasks, sols(w) is the set of terms t such that sol(t) is a subterm at the top of w.

By taking advantage of the reflective properties of rewriting logic, which allow to consider metalevel entities such as theories as usual data, the transformation described in Section 4 could be implemented as an operation from rewrite theories to rewrite theories, specified itself in rewriting logic. More specifically, we could write this kind of transformation as an extension of Full Maude, as other theory transformations described in [4, Chapter 15]. Full Maude is an extension of Maude, written in Maude itself using the features of the predefined META-LEVEL module, which provides an efficient implementation of the reflective features of rewriting logic. In particular, by going to the metalevel, the getMatch and getAmatch could be implemented by means of the descent functions metaMatch and metaXmatch provided in META-LEVEL as generic operations for matching, either at the top or at all possible positions in a term, together with the operations up and down that relate the object level and the metalevel.

Application of a nonconditional rule is now based on the metaXapply descent function. In addition, the apply-everywhere and apply-top auxiliary operations collect in a single term all the possible results for the different ways of matching, either due to finding the same pattern in different positions of a given state term, or to structural axioms in such a term (such as commutativity, for example). In- stead of returning sets of matches, as the operations getMatch and getAmatch we have previously considered in our transformation, the descent functions metaMatch, metaXmatch, metaApply, and metaXapply have a natural number argument which is used to enumerate all the possible solutions. The same technique appears as the fourth argument of the operations apply-everywhere and apply-top.

