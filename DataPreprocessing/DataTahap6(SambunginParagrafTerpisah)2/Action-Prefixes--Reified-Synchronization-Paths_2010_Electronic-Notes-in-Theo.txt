Partition refinement can effectively reduce the size and the complexity of com- posite component interaction automata [13]. There are, however, instances in which partition refinement produces unexpected outcomes. In particular, we notice a fre- quent appearance of newly-observable non-deterministic transitions in minimal com- posite component interaction automata, even when there were none before. These non-deterministic transitions can cause harm since their elimination, in order to im-

In the original definition [2,5], the set of provided actions P and the set of re- quired actions R originate from a secondary specification outside the Component Interaction Automata formalism. Incorporating these architectural constraints into the specification of component interaction automata does not affect the underlying composition rules, but it rather makes the relationship with the associated automata more explicit and eases the computation of composition [13]. We abbreviate, how- ever, the annotation in a natural way if an automaton is enabled in all actions and omit the corresponding specification.

We can model Customer, Store, and Bank as component interaction automata as follows. We write (Customer), (Store), and (Bank) to denote the architecture of the component interaction automata Customer, Store, and Bank. More precisely, the three automata are primitive (or plain) components with an opaque structure (i.e., no explicit hierarchical relationships):

The composition of component interaction automata is defined as the cross- product over their state spaces. Furthermore, the sets P and R determine, which input and output transitions occur in the composite system (i.e., interface with the environment). By convention, if any state is rendered inaccessible in the composite automaton, then we remove it immediately from the state space in order to obtain the most concise result. The behavior of the composite automaton is completely captured by its reachable states.

all states in V are start states. We write AP [q] to denote the action prefix generator for prefix state q. If WP is the set of all prefix strings that AP [q] accepts in q, we say that WP is the action prefix language of AP [q] and write L(AP [q]) = WP .

Finally, the outcome of partition refinement can be improved even further, if we erase the information about the underlying composition hierarchy by making the analyzed component primitive before refinement [13]. The composition of mul- tiple instances of the same component can produce identical sub-structures in the resulting composite automaton. However, the unique component identifiers used to disambiguate shared actions prevent partition refinement from simplifying com- mon sub-structures into a single, unifying one. We can overcome this difficulty by creating a fresh image of a given component interaction automaton in which all component names are the same. We will lose, though, the information, which chronizations that define guards for component interactions with the environment. Partition refinement removes synchronization cliques from the specification of given component interaction automaton. But, in this paper, we have presented a workable solution to restore pre-conditions in reduced automata, when necessary.

