In this work, we compare three rule-based programming tools used for building an expert system for microbiological laboratory data validation and bacteria infections monitoring. The rst prototype of the system was implemented in KAPPA-PC. We report on the implementation and performance by comparing KAPPA-PC with two other more recent tools, namely JESS and ILOG JRULES. In order to test each tool we realized three simple test applications capable to perform some tasks that are peculiar of our expert system.

This work is part of a project for Nosocomial Infection Monitoring. Hospital- acquired or nosocomial infection diseases are developed by patients after the admission to the hospital. They are more dangerous than non-nosocomial infections because they are caused by bacteria that are much more resistant to antibiotics.

the analyses performed by a microbiological laboratory (antibiograms): the quality of analyses results is critical because clinicians use directly these re- sults for therapy de nition. ESMIS importa bacteria The system should also identify critical situations such as unexpected resistance of a bacterium or contagion events in an hospital unit and alarm the microbiologist. ESMIS importa bacteria antibiograms, performs validation of the antibiogras controls described in section 3 and returning evaluation results back to laboratory per- sonnel so, in order to perform a signi cant trial, test application will performs the same steps on bacteria antibiograms.

In the paper we describe the rst ESMIS prototype. It adopts a rule-based approach to identify critical situations and correspondingly generate alarms. The rules applied have been obtained by analyzing international standard guidelines for microbiological laboratory practice and by integrating them with expert suggestions.

The rst prototype was implemented using KAPPA-PC [3], a tool for expert system development. A tool has now to be chosen for implementing the nal ESMIS prototype. In order to make this choice, we have analyzed the available commercial tools and we have selected the JESS [4] and JRULES [5] for deeper investigation and testing. The feature presented by these tools are described in section 4.

In order to test each tool we realized three simple test applications capa- ble of performing some ESMIS tasks. For each tool, the techniques adopted for implementing these applications and the performance obtained for each trial are described. One criteria for the choice is the performance of the test application because ESMIS will work in real time.

The paper is organized as follows: in section 2 the basic concepts of micro- biological data analysis are presented. In section 3 the speci cations of ESMIS are dedscribed. In section 4 the various development tools are described. In section 5 the test applications are described together with the performance results obtained. Section 6 presents an overall comaparison of the tools and section 7 concludes the paper.

For each isolated bacterium, the antibiogram represents its resistance to a series of antibiotics [6]. The antibiogram is a vector of couples (antibiotic, result), where four types of results are recorded: R if the bacterium is resistant to the antibiotic, I if it is intermediate, S if it is sensitive and null when unknown. Bacteria of the same species with the same antibiograms represent a particular "strain".

men, patient characteristics and infection history. A system, capable of using all available information, may represent a better support for laboratory per- sonnel in the validation task. This system should also control the application of standard antibiotic testing guidelines: these guidelines, used by almost all microbiological laboratories, indicate the execution of antibiotic test meth- ods and the interpretation of results. Examples of problems that this sys- tem should solve are: automatic correction of antibiotic results for particular species that present in vitro susceptibility but in vivo resistance, controls on the list of tested antibiotics, predictions of test results for a group of antibi- otics using some representative antibiotic (ex. Tetracycline is representative for all tetracyclines), intelligent reporting.

A surveillance system may be realized using an Expert System programming approach. This Arti cial Intelligence programming technique has been applied to the medical eld since 1980. In an Expert System [1], also called Knowledge Based System (KBS), knowledge about the problem is translated into special data structures and rules. An inference engine applies these rules to the available data to perform speci c tasks.

possible antibiotic results for a particular species and it tests common relations between antibiotic results. In the intelligent reporting task, the system asso- ciates to each antibiotics a suitability, obtained considering some antibiotic characteristics: costs, infection site, bacteria specie and hospital ward. In the bacterium alarms task, the system provides information regarding the bacte- ria (dangerous resistance, multiresistant bacteria, etc.). In the patient alarms task, it issues alarms regarding the infection history of the patient. Example of possible alarms are:

as described in gure 2. ESMIS introduces an automatic validation step in the process: in this step ESMIS presents the results of its controls to labora- tory personnel that will decide to agree or disagree with them and to make, if necessary, changes on antibiotic test results. ESMIS also produces the nal report and issues alarms regarding the patient clinical situation.

Inference engine: kappa-PC inference engine may use either forward or backward chaining. Rules are applied using pattern matching in exhaustive mode: in every inference step all rules and all conditions in each rule are tested in order to identify applicable rules. During forward chaining, four di erent strategy may be used for selecting the rule to be applied from a set of rules with the same priority: best rst, depth rst, breadth rst or selective.

Rule syntax: Rules are speci ed with a IF Condition THEN Conclusion syntax. Condition is composed by a set of tests on object attributes linked by logic operator (AND, OR, XOR). Conclusion is composed by a set of actions to be performed on working memory objects.

Language syntax: As in the LISP language, the JESS language main concept is that of atom. The head of a list represents a speci c function and the elements in the tail represent the function arguments. A variable is an atom in which has ? as rst character, and may contain a single atom, a number or a string. Atoms in which the last character is a $ represent multiple variables.

Inference engine: JESS inference engine uses the RETE algorithm. This algorithm grants better performance than standard pattern matching ex- haustive techniques. Rules are compiled in a particular net in which each test on an object is executed only one time even if this test is included in more rules. Rules may be applied in forward and backward chaining. In forward chaining two di erent strategies may be applied for con ict reso- lution: depth or breadth. In the depth strategy the last activated rule is applied before the other ones. In the breadth strategy rules are applied in the activation order.

This rule is univocally identi ed by the name "thief alarm" and subdivided in two parts by "=>". The rst part contains the conditions to be tested and the second the actions to take if all the conditions speci ed in the rst part are veri ed. The patterns in the conditional part are used for selecting an object of the working memory matching the pattern. In the example shown above, the rule will be activated if the (thief-identi ed) fact is present in the knowledge base or in the working memory. Each rule has a "salience" that indicates the rule priority.

Inference engine: JRULES inference engine uses the RETE algorithm. The inference engine works in forward chaining, applying instantiated rules on working memory objects. Rules are selected considering priority and par- ticular criteria (Refraction, Priority, Recency, Lexicographic order of rule names) are used to resolve con icts when several rule instances are candi- dates for ring at the same time.

Rule activation may lead to changes in the working memory and rule applicability is tested until new objects are added into it. Rules can be grouped together as rule packets. Associating rules in a packet provides a way to activate and deactivate the rules by using the packet name.

Truth Maintenance System: A Truth Maintenance System has the aim of eliminating facts deduced from hypotheses that have since turned out to be false. It is implemented by means of logical objects. Labeling an object as logical means that its existence is based upon some kind of justi cation. A logical object is maintained in the working memory as long as the condition part, which constitutes its justi cations, remains true. If the condition part becomes false, the logical object loses one of its justi cations. A justi cation counter is associated with the logical object to record the number of times it has been justi ed. The logical object itself continues to exist in the working memory as long as the value of the counter has not dropped to zero.

Database connection: The JRULES database connectivity tool is a Java application-programming interface (API), which provides access to rela- tional databases. Using the database connectivity tool (DBTool) the user can access any JDBC-compliant database from an ILOG JRULES applica- tion. This allows the user to use rules on remote objects and provides a way to construct three-tier architecture applications. DBTool is provided with a graphical user interface (GUI), which allows you to easily select and implement a mapping from database entities to Java objects.

test results using a JDBC interface and create the relative objects. JESS inference engine can not directly interact with java objects so it is necessary to build an interface between JESS objects and JAVA objects. The KAPPA-PC testing application executes the same tasks using an ODBC connections and the database connectivity functions provided by KAL language. Descriptions of the working memory classes and rule base implementation are presented below for each tool.

KAPPA-PC testing application is written using only the dedicated KAL language. JESS and JRULES testing applications were merged into a sin- gle JAVA application in which we included the system classes necessary for embedding JESS and JRULES reasoning. In this JAVA application we cre- ated an 'ExpertSystem' abstract class containing only abstract methods, that represents the interface for JESS and JRULES subclasses containing method implementations. These classes are instantiated according to user choice: 'JrulesExpertSystem' subclass of 'ExpertSystem' class: In the initialization phase an object of the JRULES 'IlrContextIlr' class and of the JRULES 'IlrRuleset' class are created. The 'IlrContextIlr' object contains the expert system functions and structure, while the JRULES 'IlrRuleset' object con- tains the application rules. Methods for knowledge base construction (data about bacteria and antibiotics) and inference management are de ned too.

In our testing environment, we have built three lists of rules, containing respec- tively rules in JESS syntax, rules in JRULES syntax and rules in KAPPA-PC syntax. We formalized 34 rules obtained by analysing the NCCLS document for the Staphilococcus Aureus species, and considering expert suggestions. These rules control antibiotic the validity of test results by working on objects describing antibiotic characteristics and representing relations that need to be veri ed. A rule example is:

One criteria for nal tool choice is represented by the performance of the test applications. ESMIS will work in real time importing bacteria antibiograms, performing the controls described in section 3, and returning evaluation results back to the laboratory personnel. Therefore, in order to perform a signi cant trial, the test applications will performs the same steps on bacteria antibi- ograms.

