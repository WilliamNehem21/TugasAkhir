The different software modules (e.g., components) that constitute a system are not isolated entities. In fact, they need to interact according to a certain coordination protocol in order to achieve a common goal. This coordination protocol crosscuts the different software modules, hindering their reusability, independence, maintenance and evolution, but these drawbacks can be solved by separating coordination from computa- tions and encapsulating coordination outside the components that perform computations. Aspect-Oriented Programming has been demonstrated to be an interesting technology for handling certain crosscutting con- cerns, such as coordination. This paper explains how coordination protocols can be implemented outside computational modules using general purpose aspect-oriented programming languages.

The software modules into which a system is decomposed are not isolated, they need to interact following a certain coordination protocol in order to achieve a common goal. In traditional software decomposition techniques, like Object-Oriented [27] or Component-Based [35] techniques, such a coordination protocol cannot be ap- propriately encapsulated into a single module (e.g., object or component). Thus, each software module that is part of a system has to perform two tasks related to two different issues: (1) computation, i.e., the execution of its functionality; and

Aspect-Oriented Programming (AOP) [20] has proven in recent years to be an appropriate technique to implement crosscutting concerns, such as coordination, outside the software module they crosscut. This paper explains how general pur- pose aspect-oriented programming languages can be used to implement coordination outside computational modules, according to an exogenous coordination model. We will focus on component-based systems, because we have previous experience in this paradigm and it can be easily understood. Furthermore, the ideas exposed through- out this paper can be easily generalised to other paradigms, such as for example Agent-Oriented [26] ones.

After this introduction, this paper is structured as follows: Section 2 describes the Auction System example. Section 3 justifies why coordination is a crosscutting concern. Section 4 provides some background on Aspect-Oriented Software De- velopment. Section 5 explains how to handle coordination as an aspect. Section 6 shows a specific implementation of coordination as an aspect using JAsCo [34]. Sec- tion 7 provides some reflections on our approach. Section 8 comments on related work. Finally, Section 9 outlines conclusions and future work.

As already commented, software modules are not isolated entities. They commu- nicate with each other following a pattern, called the coordination protocol, which governs their communications and interactions. The purpose of the coordination protocol is to provide a means of integrating a certain number of possibly hetero- geneous modules together, by interfacing with each module in such a way that the collective set forms a single application [29].

Additionally, the Auction component offers a special service directBuy: the seller of each item specifies an amount that is an upper bound to the price of the auctioned item. Customers can invoke this service during the CollectBids phase if they desire to acquire the item for this amount, without making more bids. In this case, the Auction will finish, and the winner of the Auction will be the invoker of the service. There- fore, transitions between states can happen either as result of time consumption or actions executed by the components.

Customers would now be able to make several bids on the same item, thus, the guard isFirstBid(id) is removed from the proposeBid transition. Additionally, as the auction is now public, each time a new bid is placed, all registered buyers must be notified about such a bid. Hence, a callForProposal(bid) message is broadcasted to all them, offering the possibility of making a higher bid.

Each software module permits the injection of crosscutting concerns at specific points, called joinpoints of their execution flows (e.g., after they have executed a method). When aspect-orientation is applied to component-based systems, joinpoints only refer to the behaviour exposed by the component public inter- face, such as component creation/destruction, message incoming/outcoming, event throwing, etc.

Special composition rules, named pointcuts, specify those specific joinpoints of software modules where crosscutting concerns must be injected (e.g., after the execution of all the methods called foo()). In addition, pointcuts may specify constraints that must be satisfied at runtime in order to execute an aspect on a joinpoint (e.g., that the system is in a specific state).

We would like to point out that, in any case, there is no necessity to view or modify the result of the woven application. If the application needs to be updated, the corresponding changes would be performed on the base modules, the point- cuts and/or the aspects. Then, the system will be recompiled (or rewoven). So,

A pointcut is a pattern that selects several joinpoints of the application execution flow. This pattern is usually composed of: (1) an expression that represents a certain event in the application execution flow (e.g., the reception of a message); and (2) some constraints that must be satisfied in order to execute the advice associated to the pointcut (e.g., that some attributes have some specific values). The expressiveness of each aspect-oriented language regarding these constraints varies widely, so it is not possible to provide general rules about how to translate the steps (ii).c and (ii).d into a pointcut. Sometimes, they could be placed in the pointcut itself and other times these constraints will have to be checked at the beginning of the advice code.

After implementing all the transitions, a filter advice is added to the coordination aspect. It filters all the messages that have not fired any transition, according to state machine semantics. This implies, for instance, that a join message sent by a Customer to an Auction out of the Init state, will never reach the target. Optionally, the coordination aspect could raise an exception in order to notify the sender about this special situation.

JAsCo (Java Aspect Components) [34] is an aspect-oriented extension to Java that introduces mainly two new concepts: aspect beans and connectors 7 . Aspect beans encapsulate crosscutting concerns independently of specific component types. As- pect beans can be considered a special kind of components, which encapsulate cross- cutting concerns. They can be compiled and deployed independently of base compo- nents. Connectors deploy one or more aspect beans within a particular application.

This hook is executed when a message is sent. This means that all the con- structors will have HookName(method(..args) as their signature and they will have call(method), which is the JAsCo abstract pointcut for intercepting the sending of a message, as their body.

The guard of the transition is transferred to the isApplicable clause, which checks that the guard is satisfied at runtime. Additionally, the isApplicable clause also has to check that the protocol is in the source state of the transition. Otherwise, the transition could not be fired.

The isApplicable clause (Lines 18-20) returns true if the system is in the COLLECT BIDS state, i.e., the source state of the transition, (Line 19), and the transition guard is satisfied (Line 20). If both conditions do not hold at runtime, the hook body will not be executed. If they hold, the hook body (Lines 22-29) will be executed around (Line 22), i.e. substituting, the sending of a message. This means we can perform actions before and after such message sending, and even disregard it.

In the introduction of this paper it is claimed that aspect-orientation allows devel- opers to achieve a better modularisation of their systems thereby making system de- velopment, maintenance and evolution easier. An in-depth verification of this claim is beyond the scope of this paper, but the interested reader can found quantitative studies about these issues in Videira and Bajracharya [37] and Garcia et al [14], where the authors study how Aspect-Orientation can add value to our systems im- proving the modularisation. On the other hand however, it may add complexity and additional problems such as new dependencies or aspect interactions.

As the complexity of the coordination pattern grows, the size of the coordination aspect bean would also increase, running the risk of becoming an unmanageable piece of code. Most recent aspect-oriented languages, such as JAsCo or EAOP 9 , are able to apply aspects to aspects. This feature could be used to define coordinators of coordinators, permitting the creation of complex coordinators by composing simple coordination patterns, such as in Reo [4] or exogenous connectors [25].

Several design patterns [13] focus on solving coordination problems. For instance, the Mediator pattern tries to decouple components reducing the number of in- terconnections. The Wrapper and Role patterns are used to extend or limit the functionality of a software module. However, design patterns have some drawbacks:

Endogenous models and languages, like Linda [15], provide coordination primitives that must be incorporated within a computation. These coordination models have focused on decoupling the senders and the receiver of a message, but entities are still responsible for using communication primitives, localising communication chan- nels, etc. They also have to implement the coordination protocol. If this protocol changed, components would become obsolete. The coordination primitives of en- dogenous languages crosscut application components, with the discussed drawbacks regarding ease of maintenance, evolution and reusability. Such drawbacks do not exist in aspect-oriented coordination.

Using Aspect-Orientation, exogenous coordinators are introduced transparently to base components. Additionally, the linguistic support for aspect-orientations can also be used to implement adaptors [6,12] and/or to separate other crosscutting concerns, such as Persistence [33] or Scheduling [23], among others [24]. However, at the current moment, Aspect-Orientation should not be considered the Holy Grail to separate easily any kind of crosscutting concern, as there are still some challenges to solve [22,21].

Encapsulation of the coordination concern into an aspect makes system mainte- nance and evolution easier. Components are also more reusable and are composed more easily. In addition, Aspect-Orientation allows components to be unaware of the existence of coordinator entities, avoiding the necessity of keeping references to external coordinators. Aspect-Orientation composition mechanisms can be non- invasive, so the coordination concern may be added to components without the necessity of modifying their internal structure.

Amor, M., L. Fuentes and M. Pinto, Coordination as an aspect in middleware infrastructures, in: Proc. of the 5th Int. Workshop on Aspects, Components and Patterns for Infrastructute Software (ACP4IS), 5th Int. Conference on Aspect-Oriented Software Development (AOSD), Bonn (Germany), 2006.

