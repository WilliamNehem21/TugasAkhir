The computer representation of lines and curves has been an active subject of research for nearly half a century [3,4,5,14]. Related work even earlier on the theory of words [1] (specifically, on mechanical or Sturmian words) remained unnoticed in the pattern recognition community. This paper reviews the subject of digital straightness with respect to its interactions with other disciplines (many of which are listed in [44]), as well as its role within the pattern recognition literature itself.

This paper is structured as follows: Section 2 reviews alternative defini- tions of digital rays or digital straight lines, and specifies digitized lines by distances between tangential lines. Self-similarity studies in the context of pattern recognition are reviewed in Section 3, and in the context of the theory of words in Section 4. Number-theoretical results are briefly listed in Section 5. A review of recognition algorithms for digital straight segments is presented in Section 6. Section 7 concludes the paper.

Proof. First we show that G(u) satisfies the chord property if u is a digital straight segment (Theorem 1 in [14]). Let p, q be points of G(u). The line segment pq intersects grid lines x = n that lie between p and q. Thus for any

Assume that the 8-arc u connects grid point (n, y0) with grid point (n + m, ym), with m > 0 and ym  y0  m. In case ym  y0 = m we have a diagonal, and the chord property implies that G(u) contains exactly all grid points along this diagonal, i.e. u is a digital straight segment.

Note that [26] does not contain a theorem but statements about an algo- rithm specified by a flow-chart. However, it is easily seen that this algorithm is actually an implementation of the DSS property as cited above, i.e. [26] actually contains a proof of Theorem 3.5, covering the generation of straight lines having rational or irrational slopes.

Self-similarity studies have a long history in number theory and astronomy. The theory of words [35,59] is a more recent discipline which also contains many interesting results on self-similarity, often with a special focus on irra- tional straight rays. Rational digital rays are specific periodic infinite words, and irrational digital rays are aperiodic infinite words which are studied under the name of Sturmian words. 10 This section gives basic definitions and results as presented in [59]. We also cite a few proofs for purposes of illustration.

A right special factor of an infinite word w is a finite word u such that u0 and u1 are factors of w. A word w is Sturmian iff it has exactly one right special factor of each length n  0. The empty word is always the special right factor of length zero. For the Fibonacci word f we have: 11 is not a factor, so 0 is the only right special factor of length one; 000 and 011 are not factors, so 10 is the only factor of length two; etc.

Digital rays, i.e. infinite words, are defined for rational or irrational slope by using the slope of the generating ray. The following theorem from [1] was actually formulated for mechanical words, which is what digital rays are called in the theory of words.

A finite word u is balanced iff it is a factor of some irrational digital ray [59]. Due to Corollary 4.4 it follows that any finite balanced word u is also a factor of some rational digital ray, i.e. Theorem 5.1 actually specifies the number of digital straight segments of length n starting at the origin (0, 0). The technical report [52]contains an alternative proof of Theorem 5.1 and also an algorithm for random generation of lower digital straight segments of length n.

and further characterizations have also been used for the design of DSS recog- nition algorithms. Approaches following (C4) are normally called linguistic techniques. For an early version of a linguistic DSS recognition algorithm see [16] (however, this was not yet based on the correct DSS property, which became known later).

[27] also specifies a linguistic technique (i.e. type (C4)) for segmenting an 8-arc into DSSs. As in CHW 1982a, the algorithm S 1983 involves only integer operations following the syntactic rules specified in the DSS property. A parser checks the rules related to one layer k, and (eventually) activates a parser for the next layer k + 1. Several parsers at different levels may be active simultaneously.

The maximum number m of layers is bounded by 4.785 log10n + 1.672, and this maximum is taken on in cases of digital rays having slope a/b where a and b are consecutive Fibonacci numbers [8], but the average depth is less than half of this value [8].

u. Then u is uniquely specified either by n and q1, q2, or by n and r1, r2. [30] describes a linear off-line (!) algorithm for calculating the nearest support below and/or above. A final test (Corollary 4) decides whether or not u is a DSS.

[36] specifies three different linear on-line DSS recognition algorithms. The first one is a slightly improved version of algorithm CHW 1982b. The sec- ond one also follows approach (C1); however, this time the grid-intersection digitization definition is used to perform DSS recognition based on solving a separability problem for a monotone polygon.

[42] discusses the recognition of digital 4-straight segments (the boundaries of cellular complexes) following approach (C2.3). It specifies the calculation of a narrowest strip, defined by the nearest support below and above, and briefly sketches a linear on-line DSS recognition algorithm (see also the linear off-line algorithm AK 1985, and the linear on-line algorithm CHS 1988b, both for 8-arcs). Algorithm K 1990 is reported in greater detail in [57].

A straight line seems to be a simple object. Our review (which is not yet complete) demonstrates that digital straight lines are actually a very chal- lenging subject, and many interesting results are known to date. Missing is still a comprehensive and comparative performance evaluation of the DSS recognition algorithms suggested so far in the literature. A statistical analysis of measured time complexities would also be of interest. The random DSS generation algorithm of [52]may be used for input data.

