We study the synthesis of test cases for symbolic real-time systems. By symbolic, we mean that the specification of the implementation under test (IUT) contains variables and parameters. And by real-time, we mean that the specification of the IUT contains timing constraints. Our method combines and generalizes two test methods presented in previous work, namely : 1) a method for synthesizing test cases for (non-symbolic) real-time systems, and 2) a method for synthesizing test cases for (non-real-time) symbolic systems.

Conformance testing (or more briefly, testing ) aims at checking whether an implementation under test (IUT) conforms to a formal specification of the desired behavior of the IUT. Test activity consists of: synthesizing (or gen- erating ) test cases from the specification, and executing them on the IUT. We study the synthesis phase, but we also propose a test architecture for the execution phase. Among existing work on testing, we are interested by the following two complementary works:

Test of symbolic systems (or symbolic test): the specification of the IUT contains variables and parameters. A few symbolic test methods have been developed [23,22,8]. These methods aim at avoiding the generation of test cases where all variables are instantiated. Note that symbolic techniques have also been developed in other areas than testing, e.g., model-checking [3] and diagnosis [26].

Step 1: we express the test problem into a non-real-time form, by using a transformation of a Tiosa into an automaton called Set-Exp-IOSA (SEiosa). SetExp denotes such a transformation, and SetExp(A) denotes the SEiosa obtained by transformation of a Tiosa A. SetExp basically adds to the struc- ture of a Tiosa two additional types of actions: Set and Exp that model the setting and expiring of clocks, respectively.

Remark 2.2 Unlike [1], with our model consecutive actions cannot occur at the same time. Actually this is not a restriction, because we consider that if an action e is followed an action f , then e and f are not simultaneous.

Lemma 3.3 implies that we can replace a Tiosa S by its input-completion before checking whether a Tiosa I conforms to it, w.r.t. confTiosa . However, Def. 3.2 is not constructive and we do not know how to compute InpComp(S )) from a Tiosa S in the general case. Hence, we will use the following hypothesis:

A transformation, called SetExp, is presented in [18] and applied in [13,16,17,14,15]. SetExp basically transforms a timed automaton (TA) into a finite state automaton by adding to the structure of the TA two additional types of actions: Set and Exp, that capture the temporal aspect of the TA. In the present article, we apply SetExp to Tiosa instead of TA. When apply- ing SetExp to Tiosa, the semantics of data and their DG and VA is ignored, that is, they are processed just like action labels. The latter is taken into ac- count when using (interpreting, processing, ...) the automaton called SEiosa that results from SetExp. Our test problem will be solved in Sect. 6 by using SetExp.

In order to give a trivial example that illustrates SetExp, let us consider the following two specifications. Specification 1: a task must be realized in less than two units of time. Specification 2: at the beginning of the task an alarm is programmed for occurring after two time units, and the task must be terminated before the alarm. It is clear that these two specifications define the same timing constraint. In this example, SetExp can be used to obtain the second specification from the first one. The programming of the alarm corresponds to a Set action, and the occurrence of the alarm corresponds to an Exp action.

Intuitively, Theorem 4.4 states that from a behavioral point of view, there is no difference between A and SetExp(A) for an observer who does not see (or ignores) Set and Exp actions. In a sense, SetExp(A) does nothing but add some new actions (Set and Exp) to A that capture the relevant temporal aspect of A. As we will see in the next section, in our test method, these Set and Exp are physical actions that are produced by the test system.

This architecture is applicable only if transitions executing internal (i.e., unobservable) actions do not reset clocks. In fact, in order to generate Set actions, Test-Controller needs to observe every action to which is associated a clock reset. Hence the following hypothesis:

Real-time test consists of testing systems which must guarantee timing con- straints. Symbolic test consists of testing systems without enumerating values of their data. The contribution of this work is the combination of those two types of testing. An advantage of our method is its simplicity because the main treatment of the real-time aspect is concentrated into one step. Our method combines in a rigorous way the method STG of symbolic testing of [23] and the method of real-time testing of [16]. Since the test method in [16] is a rigorous generalization of TGV [10] to the real-time case, we can say that our method is a rigorous generalization of STG and TGV 7 to the real-time case. We are optimistic for the applicability of our method because both TGV and STG have led to interesting software tools. But we recognize that such applicability remains to be demonstrated with real world examples.

