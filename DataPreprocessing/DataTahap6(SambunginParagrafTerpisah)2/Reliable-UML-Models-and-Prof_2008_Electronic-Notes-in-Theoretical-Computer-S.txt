During the last few years, Model-driven Architecture (MDA) [15] gained more and more importance in software development. This includes attended techniques such as Model-driven Development (MDD) or Model-based Testing. The main idea in MDA is the platform-independent model (PIM) that serves as source for all other activities, e.g. transformation to platform-specific models (PSM), code generation, validation, verification, or testing. Hence, the model becomes the center of the software development process.

independent from scale and domain. The UML is accompanied by the Object Con- straints Language (OCL) [16] that allows to navigate in a model and formulate constraints on it and several other helpful mechanisms. One of them - the profile mechanism - is paid a lot of attention since the standardization of UML2 as it allows to tailor the UML to a specific domain.

New ideas in software development call for new modeling strategies. This holds especially for the UML as a successful application with respect to MDA makes new demands on the language. At the moment, UML is a loose compound of modeling techniques that lack formal semantics. Static semantics are at least partly formally defined by OCL constraints. Behavioral semantics and more static semantics are defined in natural language that is claimed to be precise. Nevertheless, lots of ambiguities are introduced. To give an example, Fecher et. al. list 29 uncertainties in the definition of UML statemachines [11].

The imprecise definition of UML is partly intended as the developers did not want to fix all semantic details to allow the application of UML for all kinds of software systems. Semantic variation points offer the possibility to adapt the UML to each domain. This is sensible as each application area has its own needs. Even if UML as a broad approach is used, developers tend to used domain-specific semantics to interpret their models. This is one reason for the success of profiles.

A completely different point is static semantics that defines the well-formedness of a model. Albeit the behavioral interpretation of models differs from domain to domain, a sound structure is needed as foundation since behavior is always related to structure in UML. Furthermore, transformations and code generation are tasks that need an unambiguous structure as source. Currently, the static semantics of UML that have been formalized are not sufficient to ensure sound models which delegates the validation of models to the tools that process them. This situation is in particular disappointing with respect to models that use profiles as each profile may define additional static semantics that have to be considered.

semantics can be strengthened by analyzing the UML specification and formulating constraints. Sec. 4 deals with the extension to profiles, while Sec. 5 handles the automated validation process. We conclude with an outlook to future work and a discussion in Sec. 6.

The specification of a (modeling) language is structured in two parts - syntax and semantics [8]. Syntax is split into abstract syntax that defines the elements of the language and concrete syntax that provides a usable notation for users. Semantics give meaning to a language. On the one hand, these are static semantics that define the correct composition of syntactic elements to programs or models and behavioral semantics that define their runtime properties.

Contrary, critics argue that a certain degree of formality is definitely needed for several reasons: clarity, expendability, interoperability [10]. It is neither desirable that different persons interpret the same model differently nor that tools do the same; especially if verification or code generation is performed. This does not mean that every detail in UML shall be explicitly specified. More convenient would be a solid foundation and a well-defined extension mechanism that allows to tailor the UML to specific domains. Numerous approaches address formal (behavioral) semantics for UML, e.g. denotational [6], by Z [7], or process algebra [12]. Most of these have in common that they focus on a subset of UML, often inspired by later usage in a specific domain like real-time systems [9]. Static semantics seem to be a poor cousin of behavioral ones as they are not discussed in detail.

For UML, an appropriate means to define static semantics is OCL as we can nav- igate in the model and perform checks automatically, e.g. with the tool USE (see Sec. 5). In the UML specification documents, each modeling element has a con- straints section, where OCL is partly used. Unfortunately, these constraints are often not flawless and definitely not complete. Some static semantics are hidden in the semantics section of each modeling element that in fact should contain behav- ioral semantics; some - that are obvious - are not mentioned at all. To improve this situation, the following steps have to be taken: (a) rectify mistakes in existing con- straints, (b) formalize constraints in natural language, (c) identify static semantics in descriptions and formalize them, (d) identify missing parts.

The concrete validation process is performed with the tool USE [1] that expects a (meta)model in textual notation as input. For syntax, we refer to [22] and [23]. The tool implements the set-theoretic semantics described in [21] in detail. The key feature for our purposes is the interpreter that evaluates OCL constraints. The evaluation time is dependent on the number of elements in the model, the number of instances of the modeling element, the number of constraints and also the kind of constraints that range from very simple to quite complex as we have seen in Sec. 3 and Sec. 4. In general, we can only say that the complexity is polynomial with respect to the named inputs.

In our case, the input model is the UML metamodel - respectively a part of it that is necessary for class and object diagrams as described below. Further, profile can be added to the metamodel. On this basis, instance models can be checked with respect to the invariants in the metamodel. The instance model consists of both class layer and object layer. A similar application of USE with respect to the four metamodeling layers of UML is shown in [13]. Here, the application of USE in metamodeling is shown by a small example.

Our metamodel is constructed from one input file for the UML2 metamodel and one input file for each applied profile. The result is one large metamodel. The reasons for this procedure is simple as we want to be able to check models that do not apply profiles and models that apply one or more profiles. Also, we are interested if a profile is compliant to UML. So far, no OCL tool is capable of checking the consistency of a set of OCL constraints. Therefore, we assume a profile compliant to UML as long as both the constraints in the metamodel and the constraints in the profile(s) are all valid which is of course no proof. At least, we are able to test the compliance of profiles and their reference metamodels by example.

In the metamodel file, a description of classes with attributes and operations, asso- ciations, and OCL constraints is expected. OCL expressions are either invariants, definitions of operations, or pre-and postconditions of operations. Only operations whose return value is directly specified in OCL and not dependent on preconditions are considered side-effect free and may be used in invariants. For the validation process all invariants must be fulfilled by the instance model(s).

(b) Some names - mostly association ends - had to be changed to guarantee unam- biguous navigation in the model. (c) USE does not support UnlimitedNatural as type. This problem has been overcome by using Integer and additional constraints that restrict corresponding values to N. We do not support nested packages. A short excerpt of the metamodel in the textual notation of USE is shown below:

Evaluating constraints is possible for instances of the given (meta)model. In our case, this includes the class and object level of UML, as classes and instances are both defined in the metamodel and can be instantiated. Classes, associations, ob- jects, links, etc. form one large instance model that is generated from a UML model created with some kind of CASE tool. The generation of USE code is decoupled

As the validation is performed automatically, it is highly useful to ensure the soundness of a model before other tasks such as verification, simulation, or code generation are performed. The validation of the model for each of these tasks can be omitted as the model is assumed reliable. Another effect of the validation with USE is the improvement of the OCL constraints themselves. As most case tools have no OCL support, it is hard to detect if constraints exhibit syntax errors or if complicated constraints really have the intended meaning.

Some effort has to be made to attain this goal. First, static semantics of UML have to be improved as they are erroneous and incomplete. Second, static semantics for a profile must be defined formally. Both UML and a potential profile must be expressed as a USE model to allow automated validation. As these tasks are performed once (per profile), the effort seems reasonable. The generation of USE input code based on CASE tool output is performed automatically.

So far, most work on UML semantics focuses on behavioral semantics - e.g. [6], [7], [9], or [12] - while static semantics are not discussed in detail. As we can see from these examples, these behavioral semantics differ from approach to approach; not at least a result from the different application domains their developers had in mind. This seems appropriate as each domain has it own needs. In contrast, we believe that static semantics for UML can be unified and formalized as shown in

The validation of OCL constraints of the UML metamodel with USE has been performed for UML1 and UML2.0 before as shown in [22] and [2]. This has been extended to UML2.1 in this work. We are not aware that a thorough correction of existing constraints and formalization of constraints in natural language and of absent constraints has been performed before for class and object diagrams of UML2. In [11], similar work is done with respect to the static and behavioral semantics of statecharts given in natural language in UML2. The usage of OCL in metamodeling has been suggested in [13], but the application of this concept for profiles and the automatic validation of profiled models designed with CASE tools has not been performed before. More details with respect to the example profile can be found in [4].

The validation of profiles has been shown by an example. An adaption of the validation process to other profiles can be performed straightforward as the same kinds of constraints should appear. Validation is sensible for each profile whose application relies on a solid and unambiguous model. The RCSD profile used as ex- ample has shown that this is possible for real-world applications and problems. Even complex constraints can be formalized with OCL. Future work should investigate the usage of OCL for the formalization of static semantics of other profiles.

Also, the improvement of static semantics of UML should be pushed further to stabilize the backbone of the language. In this paper, only the basic features of UML in class and object diagrams have been considered. More work in this direction seems reasonable as a new UML standard cannot be expected in the next few years as we know from experience from the standardization of UML2. Furthermore, results for static semantics are valuable as they can be incorporated in new UML versions.

