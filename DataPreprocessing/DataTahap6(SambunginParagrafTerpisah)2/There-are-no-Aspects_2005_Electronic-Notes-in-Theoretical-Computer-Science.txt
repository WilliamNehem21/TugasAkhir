3 There is currently no unanimous vision on CBSE. For example, several different ap- proaches exist that motivate why black-box, grey-box or white-box component composition is the better choice. In this paper, we assume the Szyperski vision [29] on CBSE with black-box component composition.

The main claim of this paper is that a specialized aspect module should not exist. Instead, we would like to apply aspect-oriented composition mech- anisms to existing module constructs. As such, software components do not need to be adapted in order to alter the composition mechanism. To support this claim, we propose both a modeling framework, called CoCompose, and a programming language, called FuseJ. Both approaches allow separating the composition mechanism from the behavior specification. CoCompose employs Model Driven Development (MDD) [16] in order to apply different composition mechanisms on generic design elements. CoCompose allows to refine a model with non-typed, generic concepts to a model that uses components, methods and events. Generic composition concepts can also be refined to both regular and aspect-oriented composition mechanisms. Using these MDD refinements, it is possible to postpone the choice for a specific implementation construct to the lowest level design.

FuseJ is a programming language that recuperates aspect-oriented ideas and allows implementing all concerns as Java Beans. In addition, FuseJ pro- vides a strong composition mechanism that is able to describe both aspect- oriented and component-based compositions. As such, new composition mech- anisms are made as unobtrusive as possible, e.g. when representing a software

The next section introduces the CoCompose modeling framework and mo- tivates why an explicit aspect-oriented composition mechanism is better than a separate aspect module at the design level. Afterwards, the FuseJ program- ming language is introduced that maps seamlessly onto the CoCompose ideas. In section 4, we present the tool support we are currently implementing for supporting the CoCompose/FuseJ approach. Section 5 discusses related work that also avoids introducing an extra modularization construct for aspects. Finally, we state our conclusions.

CoCompose is a Model Driven Development framework that can be used for the stepwise refinement [33] of software designs. In addition, CoCompose can automatically determine which refinement alternatives to use. Current OO design approaches, such as UML [17], do not explicitly support refinement alternatives. A refined version of the design is made, thereby prematurely eliminating other feasible refinements [2]. UML already starts halfway the refinement process, since it forces the developer to choose one of its specific constructs to represent a design element (e.g. class, operation, package, at- tribute, ... ).

that represents an implementation language construct. The Java implementa- tion generator for a Class concept, for instance, generates Java class skeleton code and pastes in an implementation pattern, if any. While the Class concept itself does not have any implementation patterns, a concept inheriting from Class may have one and can reuse the Class implementation generator.

communication of one (or more) gate(s) with the incoming communication of one (or more) gate(s). Connectors are responsible for describing both regu- lar and aspect-oriented compositions between components, as this description is omitted in both the component and the gate implementation. Connectors which specify regular component compositions are quite similar to the connec- tors found in most component models. They are used for glueing together the gates of two components by resolving mismatches between method names or argument types. Connectors are however also able to specify aspect-oriented composition between components. In this case, their corresponding gates are glued together in an aspect-oriented way.

Deferring the aspect-oriented interaction specification to the component composition mechanism, in this case the gates and the connectors, has multi- ple advantages at the implementation level. The reusability of a component is increased, as a component developer does not need to decide at develop- ment time whether a component is supposed to interact in a regular or an aspect-oriented way with the other components which are available within the software system. All concerns are implemented as regular components, and it is the connector that is responsible for specifying how the interaction between components takes place. As a result, the features of a component can be reused in both regular and aspect-oriented compositions at the same time. This concept even allows existing components to be reused within an aspect-oriented context.

A gate specification typically consists out of two parts. A pattern part which describes the mapping of the gate upon the internal implementation of the component and an expose part which exposes the gate properties (input arguments, return value, ... ). The gate-interface of the BookingService com- ponent for instance provides two gates. The pattern part of the BookHotel-gate (line 4 to 6) maps this gate upon the bookHotel-method of the BookingService component (line 5). The BookHotel-gate exposes the inputHotelName prop- erty (line 8) that represents the name of the hotel that is given as input. The outputPrice property (line 9) exposes the return value of the bookHotel-method upon which the gate is mapped. Likewise, the ChargeForHotel-gate is mapped upon the event which is thrown in order to charge the customer for the hotel booking (line 13 to 20).

The BookingDiscount-connector is responsible for specifying the compo- sition between the BookHotel-gate of the BookingService-component and the Discount-gate of the DiscountService-component. The BookingDiscount-connector is responsible for specifying an aspect-oriented composition. An aspect-oriented connector is specified in a similar way as a regular component composition con- nector. The connection-part now specifies an aspect-oriented interaction be- tween the related gates. In this particular case, the after-clause specifies that the return value of the BookHotel-gate should be replaced with the return value of the Discount-gate. Again, a mapping-part is provided which maps the inputPrice-property of the Discount-gate upon the outputPrice-property

In section 2, generic compositions between concepts are introduced which can be refined towards regular or aspect-oriented composition mechanisms. However, the decision of whether a concept should be mapped upon an aspect or a component still needs to be made at the lowest level of design. In FuseJ, all concerns of a software system are described as regular components, and an expressive composition mechanism is employed for combining them. As a result, FuseJ eases the refinement process at the lowest level of design.

Recently, the Object Management Group has introduced the Model-Driven Architecture (MDA) standard [16]. MDA forms an abstraction layer to specific implementation platforms. It uses model transformations to refine a high-level design (described using a Platform-Independent Model or PIM) to a platform- specific design (described using a Platform-Specific Model or PSM). Several layered PSMs can be defined to gradually refine the design. CoCompose fits in the MDA vision as it also uses several layered refinements, which are described using meta-level solution patterns. These form the intermediate Platform Models (PMs) that define the transformation from a Platform Independent Model (PIM) to a Platform Specific Model (PSM).

In generative programming [8] and step-wise refinement [4], features and feature models are used to create a family of software systems instead of a single system. Features can be optional or mandatory for a software system, depending on the presence of other features. CoCompose can model optional features through solution pattern roles, which can be left unfilled. Alternative features can be modeled by alternative concept refinements.

In this paper, we claim that a specialized aspect module should not exist. In order to support our claim, both a modeling framework and a programming language are proposed that do not introduce a specialized aspect module. Instead, a powerful composition mechanism is provided that supports aspect- oriented composition. The CoCompose modeling framework is based on MDD and allows step-wise refinement from a high-level design to the lowest level design or code level. Using these refinements, CoCompose allows postpon- ing the decision concerning the modularization construct that is chosen for a particular concern. The drawback of targeting traditional aspect-oriented programming languages in a refinement is that a specific aspect module has to be selected in order to modularize certain concerns at this refined design level. Therefore, the FuseJ programming language is introduced as a better target for implementing CoCompose designs. The FuseJ programming lan- guage allows to implement all concerns as regular components and provides an explicit composition mechanism that supports aspect-oriented composition

The proposed FuseJ gate and connector language is only a first prototype of our ideas. At the moment, the expressiveness of the FuseJ connectors does not cover the complete aspect-oriented composition possibilities, as only sim- ple aspect compositions, such as before and after are supported. Identifying whether and how other aspect-oriented composition mechanism can map in this model is subject to further research. A possible problem with the CoCom- pose approach is scalability. Because every design element can have multiple refinements, a multitude of possible refinement combinations are available. Experience with the first version of CoCompose that targets Java, ConcernJ and JAsCo already suggests that scalability issues can be overcome. In the future, real-life experiments of CoCompose/FuseJ have to reveal whether this approach is feasible.

