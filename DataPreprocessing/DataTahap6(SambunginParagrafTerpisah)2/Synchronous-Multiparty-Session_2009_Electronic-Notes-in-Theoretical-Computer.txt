Multiparty session types for a calculus of asynchronous communication have re- cently been introduced by Honda et al. [10] and Bonelli-Compagnoni [1]. The idea of multiparty session types in the first work is based on the choreography metaphor to describe interactions between processes: interactions are described as a global scenario. Whilst, the second work is based on the orchestration metaphor: interac- tions between processes are described as a centralised scenario between one master process and many slave processes. The system introduced in this paper follows the metaphor of the first work.

and of the other participant Client, Successor and Predecessor is the same to binary session types. Addition is represented now by only one interactive structure. Hence, the use of global types allows a more complete and intelligible definition of communication protocols in multiparty sessions.

A race condition problem is introduced if different interactions use the same channel. That is, two senders are sending two different messages on the same channel and two receivers are trying to receive at the same time a message on that same channel. Even though, there is no communication error, as for each send corresponds one receive and vice versa, the ambiguity introduced on which of the two receivers will the message be delivered may break the causalities. Unfortunately, global types alone do not guarantee from a possible race condition problem.

A Simpler Calculus. The syntax of the calculus is more relaxed than the one introduced by Honda et al. [10]. We do not distinguish syntactically between a primitive value send and a session channel send following the idea firstly proposed in [8]. The syntax of the calculus does not introduce queues, neither at the programmer code level nor at the runtime code level, in contrast to [10].

Organization. In the remainder of this paper, Section 2 defines the syntax and operational semantics of the calculus. Section 3 defines the syntax of global types and introduces the linearity property. Section 4 gives the programming methodol- ogy, syntax of local types, projection algorithm and type system. Section 5 con- cludes by comparing the system with related works and gives possible future work. Appendixes A gives the full proofs of the theorems presented in the paper.

[Link] initiates a session between n peers. The result of the reduction is generation of session channels and substitution of them in processes. Note that session channels for each process are labeled by a multipolarity index ranging [1, ..., n], where n is the number of participants involved in a session. The calculus uses multipolarity

[MultiLabel] actions the selection-branching communication between two and more participants. The selection process sends the label l i to the branching pro- cesses and the result of the communication is the resting part of the label selection process (P 1) in parallel with the process labeled by l i (P [2..k]i).

Addition Protocol. The program below implements the session between Client- Addition-Successor-Predecessor introduced in Section 1. The process addition implements the communication pattern of adding two natural numbers; successor and predecessor processes implement the communication pattern of receiving a num- ber and sending its successor and predecessor, respectively.

Fire Alarm Protocol. The fire alarm protocol given in Section 1 is a simple representation of the communication pattern of a fire alarm system. Only two of the main components are considered: notification appliances and building safety interfaces. The implementation of the fire alarm protocol in the MS-calculus is: semantically correct. In order to reduce, the receiver should possess the channel k' before the communication take place. It would be nice if a system could allow the transmission of channels with the receiver not possessing the channel before the communication. Yoshida and Vasconcelos [19] describe different extensions to the operational semantics and analyze soundness of the type system with respect to the operational semantics. The first solution is to rename the bound channel k'' into k' but that might bind the free occurrences of k' in P2. Another solution could be to change the operational semantic rule in

is not well-typed under the same type system because in the derived term the type of k' involves one read and one write rather than only one write as it was in the starting definition of the second process. Even though, this example might be controversial if it is useful or not in practice, it is a well formed term of the calculus that breaks soundness of the type system. The solution proposed by Yoshida and Vasconcelos defines channels as runtime entities; i.e. they are not part of the syntax used by programmers and are generated at initiation time, as in the calculus introduced in this paper. The above example written in their system is

is well-typed as k' of one endpoint differs by a polarity sign from the other. SJ [12], an implementation of binary session types in Java, rejects at runtime the above example. Indeed, this term stucks in a non final value state and fails progress of the system.

The system given in this paper uses the same logic of [19,8] to represent channels. The only change is that of having multipolarity. That is, their system used a binary polarity (+, -) because in binary sessions only two processes are involved, but for the multiparty calculus the number processes participating in a session is generally more than two, thus we introduce an index label ranging [1, ..., n], where n is the number of processes involved in a session. As it can be noticed in the operational semantics rule, a polarity label is assigned to every channel of the session when substituted in a process.

in G for some m and do not occur in different branches of a branching, then both input and output dependencies exist from n1 to n2. In case of multicasting (values or labels), all the chains achieved by distributing each prefix of multicasting on the rest of G have to be checked if they satisfy the above conditions. If G carries other global types, we inductively demand the same.

Multiparty session types have been firstly studied for asynchronous communi- cation calculi [10,1]. In these calculi, for problems that specify a strict order of communications, programmers have to specify the order by adding extra communi- cations, that send an empty message, and channels to preserve linearity of the late ones. Considering the fire alarm system introduced in Section 1 for a calculus of asynchronous communications e.g. [10], the global type is now defined:

Recently, contracts for web-services [5] have been studied for a calculus of syn- chronous communications. A contract is a binary session type between a client and a service, that can capture a combination of an internal and external choice at participants. The work on contracts does not address ordering and causalities of communications in a multiparty session. Merging of sessions is modeled via inter- actions inside a session and locations in [3]; the result of the type safety property is left as future work.

A calculus of service-oriented computing is introduced in [17], where a conversa- tion models the interactions between a client and various services. New primitives of communication are introduced such as conversation context (shared interaction point) communication and communication inside an end-point. An exception han- dling mechanism similar to those proposed for functional languages is introduced for the calculus. The calculus in essence is similar to the ones presented for session types [9,16] but does not address resolution of safe communications at static time.

As future work, we plan to develop a typing theory that checks global types from inner-delegation scenarios and rejects implementation of such scenarios. We plan to extend delegation with multicasting; i.e. allowing delegation of different behaviors that do not have dependencies between them to a group of participants simultane- ously.

Subject reduction ensures that the type of an expression is preserved during its evaluation. For the proof of subject reduction, we need three standard properties: channel replacement, weakening and substitution lemma. We need the channel replacement lemma for rules [Link], [Multicasting] and [Def], weakening for rule [Def] and subject congruence, and substitution for rule [Multicasting] and [Def].

Definition A.7 (merge set) Assume G is coherent. Then we say two prefixes in G in different branches of a branching prefix are mergeable with each other when they are collapsed in its projection. A prefix is always mergeable with itself. Given a prefix n, its merge set is the set of prefixes mergeable with n.

Proof. For (1), observe that redexes in the base rules over session typing, [TR-Mult], [TR-MultD] and [TR-MultL], are in the minimal positions and since there is no permuation of prefixes, as it is for the asyn- chronoous calculus for OO, we conclude. (Two output-output actions are strictly orderd due to synchrony.) For (2) , first, for linearity, suppose n1,2 are in G' sharing a channel. Then they are also in G and causal edges between them do not differ so they have the same dependencies as in G. Second, the coherence

For (3), the first part is immediate from the construction. For the second point assume there is a redex pair in [G ] whose two parts have different pre-images. Then we have co-occurring prefixes in G which are not related by the two dependencies, by (1) and the first part of (3), a contradiction.

