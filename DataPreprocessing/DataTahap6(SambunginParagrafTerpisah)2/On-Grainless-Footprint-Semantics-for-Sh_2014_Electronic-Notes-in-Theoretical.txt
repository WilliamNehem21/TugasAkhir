partial correctness, as in concurrent separation logic [8]. The new treatment of race detection allows for more refined analysis of racy programs. By framing our ideas and concepts in a general manner we hope that our results may be applied in a wider setting.

Shared-memory programs are difficult to reason about, because of the potential for interference between concurrent processes when updating the same piece of shared state. Similar difficulties arise in constructing semantic models of shared-memory programs. Most traditional models have assumed a fixed granularity of execution, for example atomic assignments or atomic reads and writes [2,10]. Such assumptions 1 This research was sponsored by the National Science Foundation under grant no. CCF-1017011. The views and conclusions contained in this document are those of the author and should not be interpreted as representing the official policies, either expressed or implied, of any sponsoring institution, the U.S. government or any other entity.

Resources behave like binary semaphores with atomic operations for locking and unlocking, so conditional critical regions can be used to ensure mutually exclusive access to shared variables. We abbreviate with r when true do c as with r do c. The static semantics of commands is summarized in the following definitions.

For steps in which multiple reads and writes occur, there may be several possible choices of flow relation, expressing different dependencies. For example, in the step ([x : 0,y : 0], {(y, y)}, [y : 1]) the update to y does not depend on the read of x, whereas in ([x : 0,y : 0], {(x, y), (y, y)}, [y : 1]) the update to y depends on both x and y. These two steps have the same overall effect, but different flow relations.

A write to x concurrent with a read of x only constitutes a significant race if the read influences the value of some identifier. The following examples show how races get handled, specifically that the correct identifiers get tainted, when the flow relations are non-trivial. To facilitate comparison with the above definition we enumerate the flow relations explicitly.

The clause for critical regions shows how entry and exit are modeled as lock (r) and unlock (r), and the resource-sensitive nature of interleaving ensures that c1  c2 correctly models concurrent execution while obeying the atomicity and mutual ex- clusion constraints on resources. Since we only care here about partial correctness behavior we do not include infinite traces to represent the busy-waiting caused by perpetually unavailable resources and/or the falsity of the entry condition b. Simi- larly the clause for while-loops does not include infinite iteration.

Consider the program with r do (x:=x + 1; x:=x + 1). Our semantics does not distinguish this from with r do x:=x + 2. There is no need to distinguish them, because no other process can tell them apart without causing a race.

Let p and q be boolean-valued expressions in which identifiers may occur free. (We do not allow resource names to appear free in such expressions.) Let |p| be the set of states satisfying p. The safe partial correctness formula {p}c{q} is valid iff all finite executions of c from a state satisfying p are race-free and end in a state satisfying to programs (i)  x:=2 and (ii)  x:=2. The new semantics distinguishes (i) from (ii), because they induce different flow relations: only in (i) is y dependent on x. (We made a similar comment in an example, earlier.) Moreover, this distinction is worth making, because when run in parallel with a program that (only) writes to x, for (i) the value of y gets tainted but for (ii) it does not. Thus there is a program context in which (i) and (ii) have different observable behavior. In particular, the new semantics distinguishes (correctly) between the programs (i)  x:=2 and (ii)  x:=2.

