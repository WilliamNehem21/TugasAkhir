Formalised mathematics is a computer science discipline largely ignored by mathematicians. There are good reasons for this. It takes months to become a competent user of any proof assistant. Once the tool has been mastered, even the most elementary results take days of tedious labour to reproduce. Perhaps worst of all, the resulting formal text is mostly incomprehensible to anyone unfamiliar with the tool in question.

This is a difficult piece of work to understand unless you are familiar with constructive dependent type theory. Its relationship to category theory as usually presented in maths texts is indirect at best. However, it does develop more category theory than the other existing formalisations.

The main difference between the two Mizar developments is the treatment of arrows. One uses the usual definition where a category has a collection of arrows, and has source and target functions from arrows to objects. Homsets are then defined in terms of these. The other development follows the alter-

The source files for this development seem to be unavailable. It would be unlikely to work with the current version of the system in any case. The exposition in [4] is very limited. It is claimed that definitions were given for subobjects, limits, adjunctions, Cartesian closed categories and triples. The development is focused on proving the adjoint functor theorem [16, V.6, Theorem 2].

The full text of the formal development, produced automatically by Isabelle, is 27 pages long. It is available on the internet [20], along with the Isabelle/HOL source files. In what follows we give most of the definitions, some of the results and a couple of proofs.

We skip the few trivial lemmas about categories, and move on to the definition of the category of sets. Rather than assuming that there is one universe that contains every set, we define the category of subsets of a given universe set U . MacLane [16, page 11] calls these categories EnsU or just Ens. The type of this set is a parameter determining the type of the category.

We would like to write FA and Ff , as is the usual informal notation. Although we could define a particular F to be overloaded in this way, we can not define functors as functions that take objects to objects and arrows to arrows. Attempting to do so yields an angry message from the type inference module. Instead we define an alternative explicit notation.

We do things a little differently with functors. The properties of functors are defined as predicates in a locale containing two categories. The locale saves us two arguments on each predicate. Defining and naming the predicates allows us to use them in our reasoning.

Here is an example of a simple result with its proof. Some assertions are given numbers as names, so that they can be referred to later. To show that we have a homset element, we must show that it is an arrow, and has the correct domain and codomain.

To check that we have defined what we think we have defined, it is prudent to construct an obvious instance for each concept, and to prove that is is an instance. We show that the pair containing the object and arrow identity functions is a functor. We define a function which gives us this pair for a given category, and a locale in which to prove our result.

The Isar proofs we have shown are cumbersome when compared to informal text-book proofs. Much of the reasoning is there for the benefit of the prover, not the reader. It is likely that better results can be obtained by more skillful application of the existing automation. There are probably lessons to be learned from a careful examination of the other formalisations. It is not our aim to automate everything though, just the steps that we expect the human reader to make for herself.

