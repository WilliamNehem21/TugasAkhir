Evaluation of attributes w.r.t. an attribute grammar can be obtained by inductively computing a function expressing the dependencies of the synthesized attributes on inherited attributes. This higher-order func- tional approach to attribute grammars leads to a straightforward implementation using a higher-order lazy functional language like Haskell. The resulting evaluation functions are, however, not easily amenable to optimization rules. We present an alternative first-order functional interpretation of attribute grammars where the input tree is replaced with an extended cyclic tree each node of which is aware of its context viewed as an additional child tree. By the way, we demonstrate that these cyclic representations of zip- pers (trees with their context) are natural generalizations of doubly-linked lists to trees over an arbitrary signature.

The set of input trees is a regular set of trees given as the set of abtract-syntax trees of a context-free grammar or, if we are not interested in the concrete syntax but only on the abstract structure of trees, as the set of terms build from a multi- sorted signature. Values of attributes are defined with a set of recursive definitions given by the so-called semantic rules of the attribute grammar. If the attribute grammar is non circular (there are no cyclic dependencies between attributes) then one can can compute the value of each attribute using a topological sort of the dependency graph (whose arcs indicate the dependencies between attribute values). One can nevertheless use an order-algebraic approach based on least fixed-points [6,23] in order to compute attributes for potentially circular attribute grammars (and on potentially infinite input trees).

General attribute grammars use both synthesized and inherited attributes bear- ing information respectively from the subtree stemming from the given node and the context of that subtree. Attribute grammars with only synthesized attributes amount to primitive recursive schemes [9] and value of attributes are easily com- puted by structural recursion on trees. Things are more involved for general at- tribute grammars due to the manipulation of contextual information. However it was soon recognized that we can resort to attribute grammars with only synthe- sized attributes whose attributes are functions expressing the dependencies of the synthesized attributes on inherited attributes. Thus attribute grammars reduce to structural induction on trees at the price of using higher-order values. This higher-order functional approach to attribute grammars [19,11,2,22] leads to effi- cient implementations in a higher-order lazy functional language like Haskell. The Elegant system developped at Philips [1] and the UUAG system [25] from Utrecht university both illustrate this approach.

Unfortunately the resulting evaluation functions are not easily amenable to opti- mization techniques like short-cut fusion which are based on first-order representa- tions of functions. We thus present an alternative first-order functional interpreta- tion of attribute grammars where the input tree is replaced with an extended cyclic tree where each node is aware of its context viewed as an additional child tree. The price to pay is a preprocessing phase to unfold a tree into its extended cyclic version. By the way, we demonstrate that these cyclic representations of zippers (trees with their context [16]) are natural generalizations of doubly-linked lists to trees over an arbitrary signature. More precisely there are two natural ways of representing

The rest of the paper is organized as follows. In section 2 we recall the basic def- initions on attribute grammars and present a variant of the higher-order functional interpretation of attribute grammars. In section 3 we introduce the zippers, and the evaluation of attributes based on zipper representation. In section 4 we intro- duce the cyclic representation of zippers and the unfolding of a tree into its cyclic representation. In section 5 we introduce our first-order interpretation of attribute grammars based on the cyclic representation of trees.

The above semantics of attribute grammars follows the approaches presented in [19,2], it also draws its inspiration from [23,6] in the sense that it gives a fixed-point semantics of attribute grammars. We have an almost literal transcription of the above definition into the language Haskell as the mechanism of lazy evaluation es- capes the apparent cyclicity of the resulting program [5]. A translation of attribute grammars into catamorphism (evaluation function for an algebra) was already pre- sented in [11]. However the presentation that we have just given is, in our opinion, more explicit and far more elementary than the one given there and it leads to a straightforward implementation in Haskell. Notice that another advantage of lazy evaluation is that we can define computations of attributes on potentially infinite data structures. For instance we can define semantics rules on streams as long as every approximations of the value of a given attribute can be computed using only a finite prefix of the stream.

In order to account for context-dependent information we manipulate a subtree together with its corresponding context. We restrict attention to trees whose sort is the axiom. A zipper (of sort s) is given by a pair made of a tree of sort s together with a context for that tree. The representation of a context in the zipper comes from the following observation: either the context of the considered subtree t is empty or it is of the form states that the inherited attribute coflat when applied to a context of the form LCxt cxt right and a subtree left is given by the synthesized attribute flatten for subtree right in the corresponding context, namely RCxt left cxt. We can make this extra parameter implicit if each subtree is aware of its context, given as an extra parameter, and symmetrically each context is aware of the subtree to which it is applied. We achieve this result using cyclic representations of zippers which we define in the next section.

First we introduce an extended signature such that the corresponding trees are encodings of cyclic representations of zippers. In a second part we describe the process of unfolding a rooted tree (i.e. with an initial empty context) into its cyclic representation.

Therefore result (unfold  tree)A  coincides with the value return tree returned by the rooted attribute grammar G from the given input tree. It gives an algorithm for computing that value by simple structural recursion on the unfolding of the input tree. In our running example, we obtain the following Haskell code.

much easier to compose (top-down) tree transducers than to compute the syntactic composition of attribute grammars. The latter operation introduced by Ganzinger and Giegerich, as the co-called attributed coupled grammars [12], has already been related to the functional programming deforestation technique in [8,10]. We would like to recover the syntactic composition of attribute grammars through the compo- sition of the associated (top-down) tree transducers acting on cyclic representations of zippers.

We can notice that the Haskell code we ended with is almost an immediate tran- scription of the semantic rules of the attribute grammar. Still the programmer need to be aware of the underlying cyclic representation of zippers and this is an unde- sirable overhead and a potential source of programming errors. We would like to be able to encapsulate these aspects into a structure of monad (or a structure of arrows) so that all these considerations would be totally transparent to the programmer. we are thus looking for a set of functional combinators (similar to the functional monadic parser combinators [17]) providing an attribute grammar designer with a Domain Specific Language embedded in Haskell. Using these combinators it would specify an attribute grammar (mainly by writing down semantic rules) but by doing so he would actually build an Haskell program for the corresponding evaluator of attributes or for related tools.

