Operational Transformation (OT) is an approach which has been proposed to overcome the divergence problem, especially for building real-time groupware [1,8]. This approach consists of an algorithm which transforms an operation (previously executed by some other site) according to local concurrent ones in order to achieve convergence. It has been used in several group editors [1,6,8,7,11,9], and it is em- ployed in other replication-based groupwares such as a generic synchronizer [5]. The advantages of this approach are: (i) it is independent of the replica state and de- pends only on concurrent operations; (ii) it enables an unconstrained concurrency,

Until now the OT approach has been used to only deal with simple collaborative objects, such as a string object. When we consider a complex object (such as a filesystem or an XML document that are composite of several primitive objects) the formal design of its OT algorithm becomes very tedious because of the large number of updates and synchronization situations to be considered if we start from scratch. As continuation of [4], we propose in the present work a compositional method for specifying complex collaborative objects. The most important feature of our method is that designing an OT algorithm for the composed collaborative object can be done by reusing the OT algorithms of component collaborative objects. By using our method, we can start from correct small collaborative objects (i.e. they satisfy convergence conditions) which are relatively easy to handle and incrementally combine them to build more complex collaborative objects that are also correct.

This paper is organized as follows: in Section 2 we give the basic concepts of the OT approach. The ingredients of our formalization for specifying the collaborative object and OT algorithm are given in Section 3. In Section 4, we present two constructions for composing collaborative objects in algebraic framework. Finally, we give conclusions and present future work.

To maintain convergence, an OT approach has been proposed in [1]. It consists of application-dependent transformation algorithm such that for every possible pair of concurrent updates, the application programmer has to specify how to merge these updates regardless of reception order. We denote this algorithm by a function IT , called inclusion transformation [8].

this method is possible. For this we use a boolean function Poss that indicates the conditions under which a method is enabled. The OT algorithm is denoted by the function symbol IT which takes two methods as arguments and produces another method.

CCHAR has one method putchar and one attribute getchar. Axiom (2) gives how to transform two concurrent putchar in order to achieve the data convergence. For that, we use function maxchar that computes the maximum of two character values. Note we could have used another way to enforce convergence.

The concurrent interaction in a collaborative context is an essential feature of the object paradigm. More attention is paid for allowing concurrent executions to achieve convergence. This section describes how to build complex collaborative objects from components using two kinds of composition. For that, we are inspired of work of Goguen et al [2].

The following theorem is very important in the sense that it stipulates that the consistency property (see Definition 3.8) can be obtained by composition. Indeed, composing consistent components produces a consistent composite object provided that the components are independent between them.

As second construction, we allow the component specifications to interact. It is possible to get situations where the component specifications share some methods and attributes. These components are said synchronized by their shared part. Such a shared part is just a way for component objects to communicate.

This work is a first step toward to give a compositional method for specifying and verifying complex collaborative objects. In this respect, we have proposed two constructions for composing collaborative objects: (i) the first construction has as a basic semantic property to combine several components without allowing these components to interact; (ii) as for the second one it enables components to communicate by means of a shared part. Moreover, we have provided sufficient conditions for preserving TP 1 and TP 2 by both constructions.

Many features are planned to be investigated effectively with large systems. We plan to deal with composition of arbitrary number of collaborative objects by using a dynamic composition such that the objects are created and deleted dynamically. Next, we intend to study the semantic properties of compositions given in this paper. Finally, we want to implement these compositions in our tool VOTE [4].

