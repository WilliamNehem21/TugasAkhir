A number of formal approaches to component-based software development have been proposed, based on the idea of using formal specifications as a basis for retrieval. These approaches provide good recall and precision when searching for components. More recently, the problem of component adaptation has begun to be addressed, in recognition of the fact that a library component will rarely meet the needs of the user exactly. However the main weakness of the current approaches is they only cater for a single adaptation step.

In practice this approach often involves a number of mundane and tedious steps. In this paper we define search tactics, which can be used to combine multiple match- ing and adaptation steps into a single step. The idea is analogous to the use of tactics in interactive theorem provers, and indeed we draw much inspiration from this work. With these search tactics we aim to automate common component adap- tation steps, allowing the software engineering to concentrate on more important design decisions.

In this paper we define a collection of search tactics used to semi-automate component adaptation and retrieval. It is our intention that the tactics should be applicable to any approach that uses formal-based matching and adaptation techniques. We therefore begin in Section 2 by defining a generic model for matching and adapting formally specified components. We consider individual units and modular components separately.

In Section 3 we define the general form of search tactics. We also define a collection of basic search tactics from which more complex tactics will be built. In Section 4 we define a collection of tacticals, used to combine basic tactics to build more complex tactics. In Section 5 we illustrate the use of the search tactics, by looking at a simple example using the CARE language and tools. Section 6 contains a comparison of our approach to other related work.

In this section we present a generic framework for matching and adapting formally specified components. The framework generalises existing approaches to specifica- tion matching, capturing the general notion of matching components with respect to adaptations of the components. The framework used here is based on a generic framework presented in an earlier paper [6]; however there are several changes which are noted in the text below. We model the framework using the Z specification lan- guage [14].

which consist of multiple units. This separation allows us to focus on matching and adaptation techniques relevant to the particular level of granularity. In developing matching methods for individual units, we do not need to consider how a collec- tion of units will be matched. Similarly, when developing methods for matching modules, we can assume there is a method for matching the individual units.

We begin by considering the basic individual units that are contained within mod- ular library components and programs. Examples of units include functions, types, theorems etc. We model these units using a generic type, representing a set of values that are not further defined.

We will typically only be interested in supporting relatively straightforward adap- tations at this point. By straightforward, we mean adaptations that can be readily computed using automated techniques such as unification of unit specifications. Ex- amples of such techniques include identifier renaming (e.g., for variables and type names), and higher-order variable instantiation. In cases where there are different kinds of adaptations that can be applied, we would model Adapt as a tuple.

Finally a method (or methods if there are different kinds of units) for matching units is defined. The matching method must conform to the matches predicate below, which is defined in terms of the satisfies relationship and the adaptation function. For this paper it is sufficient to define abstractly what it means for two units to match.

The exact nature of these functions will depend on the particular modules in ques- tion. For a flat module, they will just return the set of units contained in the module. However for hierarchically structured modules they may represent a recur- sive function which returns the set of units contained within the nested modules. Similarly, in object-oriented programming, the function may need to traverse the inheritance structure.

We generalise this to a series of module matches, where the results from one match step form part of the input into the next matching step. To do this we define the notion of a search tactic, which generalises any combination of module matching steps. A search tactic is analogous to proof tactics used in interactive theorem provers [4]. Proof tactics are designed to combine multiple simple proof steps into a single more complicated step, thus automating the more mundane steps. Analogously, we aim to combine multiple individual search steps into a single complex search step.

The following tactics are useful when combining a number of search steps. Each search step may introduce new subgoals, which are appended to the end of the subgoal list. The tactics below give us a way of searching for matches for the oldest subgoals first, before looking for matches for newly added subgoals. In effect they enable breadth first searching strategies to be implemented.

how more complex search tactics can be constructed using tacticals. Tacticals are a mechanism that allow individual tactics to be combined. The tacticals defined in this section are based on those originally proposed for use in interactive theorem provers [4]. However their definition is quite different due to the fact that we not only return the final set of subgoals, but also the search history, at the completion of the search tactic.

