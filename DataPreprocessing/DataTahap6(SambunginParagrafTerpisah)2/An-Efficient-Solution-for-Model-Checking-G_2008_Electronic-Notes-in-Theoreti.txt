This paper presents an efficient solution for modeling checking graph transformation systems. The approach transforms AGG specifications into Bogor models and supports both attributed typed graphs and layered transformations. Resulting models are amenable to check interesting properties expressed as combinations of LTL (Linear Temporal Logic) and graph transformation rules. The first experimental results are encouraging and show that in most cases our proposal improves existing approaches, both in terms of performance and expressiveness.

If we reason on single rules, which describe local changes, we can only understand how the underlying graph evolves locally, but we loose its global behavior. Powerful analysis solutions must bypass this limitation and allow the user to reason on how the different rules impact the behavior of the graph as a whole. CheckVML [28] and GROOVE [14] exploit model checking techniques to provide such analysis capabilities, but their usefulness is limited for different reasons. They both do not support layered graph transformation systems directly. CheckVML does not efficiently support dynamic systems, that is, systems whose nodes are added/deleted by transformation rules while the system evolves, and GROOVE support attributed graphs partially and in a non native way.

Graphs are translated into the input language of the model checker, called BIR (Bandera Intermediate Language, [10]), while properties are rendered by means of LTL (Linear Temporal Logic) and special-purpose rules. The result is used to feed Bogor, which performs the verification. The approach handles dynamic systems, but obviously their maximum size is limited to a user-defined threshold.

Section 3 briefly introduces Bogor and motivates the choice of this model checker with respect to other options. Section 4 describes our approach and shows how we encode a graph transformation system in BIR through an illus- trative example. Section 5 presents some experimental results and compares them with existing approaches. Section 6 concludes the paper.

Heckel et al. [19] provide the theoretical foundations for the verification of graph transformation systems through model checking by proposing to inter- pret graphs as states and transformation rules as transitions. This idea is exploited by GROOVE [24], CheckVML [28], and also by our approach.

since it might result in good runtime performance. Finally, Baresi and Spo- letini [7] describe a methodology to analyze graph transformation systems by means of Alloy [21]. The authors present an encoding of AGG systems into Alloy, but the Alloy analyzer only deals with a-priori limited domains.

The input language, called BIR (Bandera Intermediate Representation), provides the basic constructs commonly supplied by the modeling languages of verification tools (e.g., Promela). For example, it supports primitive and non-primitive data types, function pointers, dynamic creation of threads and objects, automatic memory management (garbage collector), and generic data types. Control-flow and actions in BIR are stated in a guarded command format: guard expressions evaluate expressions, while actions (commands) modify the state of the system. It is also possible to create different locations by labeling parts of the code and modify the control-flow by explicitly jumping among them.

After defining the data structures, we create a thread main to drive the behavior of the whole system. This thread is divided into locations and the first one (loc0) is used to instantiate the type graph and implement the host graph. We first create a variable of type graph, and we suitably dimension the arrays it contains. More precisely, we dimension the arrays by distinguishing between static and dynamic nodes. The former can neither be added nor deleted in the RHS of a rule, while the latter can. The dimension of the arrays for static nodes is the number of these nodes in the host graph, while the maximum number of dynamic nodes is not always known a-priori, and the host graph only defines a lower bound.

tains different constants, one for each array. For example, instruction instance.customers:=new customer[limits.num_customer] allocates the space for the Customers in the host graph (two in this case), and instance.customer[0].cash:=10 sets the value of field cash for the first customer in the model to 10. In our example, the only dynamic node is Bill, which is not present in the initial host graph (the lower bound is 0). In this particular case, the maximum value is 2, since each Bill is associated with at most one Customer, and we only have two of these (static) instances in the host graph.

The problem of encoding rules is split into two different sub-problems: match- ing and acting, i.e., the LHS (and the NAC, if present) and the RHS, respec- tively. The matching procedure is located in the main thread, while each action is defined as a particular thread. The matching is performed in the second location of the main thread (loc1) and uses a vector for each rule, which contains the main components of the LHS, that is, the minimum set of node types in the LHS that allows one to access all the other nodes in the LHS. More precisely, the vector only contains the nodes that are not reachable from others. If the LHS graph contains a cycle, it is cut nondeterministically to identify the node(s) to be stored in the vector.

The matching for layered transformation systems is performed as described above, but instead of using one location for all the matchings, we use one lo- cation for each layer. Since a location represents the matching for a particular layer, the matching procedure starts from the first location and looks for matchings. If it succeeds, we execute the corresponding action, otherwise the matching is performed on the next location.

(2) the concurrent append example, and (3) the dining philosophers problem, presented in [25]. Our experiments were run on a 1.66 GHz Pentium IV pro- cessor with 512 MB of memory. As for CheckVML, we use the results in [25], where they used a 3GHz Pentium IV processor with 1 GB of memory, and as for GROOVE, we used the results provided by the GROOVE group (obtained on GROOVE 1.4.2 with a 3.2GHz processor with 500MB of memory).

Although the main idea of our approach is similar to CheckVML, there are many differences in the details. One of them, which highly impacts the performance of our approach, is the way we manage dynamic nodes and edges. As we mentioned before, we store a graph as a record in BIR and we use a linear array for each node type in this record. Moreover, the use of the navigation support provided by Bogor to handle associations and attributes further improves the efficiency of the proposal.

As for the properties we can check, we implemented the examples in [17,29]. In these works, the authors describe a formal semantics for dynamic meta modeling with graph transformation systems and, as an example, they men- tion a formal semantics for activity diagrams based on token flow semantics to model and analyze workflows. They use GROOVE and define a liveness property based on token semantics and, at the end, they check whether activ- ity diagrams are live. As they mention, their approach only checks whether the tokens in all the paths reach the final node in the activity diagram, but they cannot check the liveness property of a single activity node. Again, we implemented this example with our approach and besides being able to check liveness for a complete activity diagram, we also checked the liveness of all the nodes in the model.

The approach can also be quite naturally extended to hierarchical graph transformation systems [12]. Indeed, the approach already supports inheri- tance and this extension can be combined with layered graph transformation systems to assign different rules to different levels of the hierarchy. This would further improve the average performance of our model checking approach. In the worst case, the model checker would explore the entire state space both in the flat case and in the modular one. In many situations, however, if the model presents different levels of abstraction, the model checker does not explore the entire space, but it can work incrementally by traversing the different levels.

