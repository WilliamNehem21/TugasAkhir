We study information flow security properties which are persistent, in the sense that if a system is secure then all of its reachable states are secure too. We present a uniform characterization of these properties in terms of a general unwinding schema. This unwinding characterization allows us to prove several compositionality properties of the considered security classes. Moreover, we exploit the unwinding condition to dictate the form of the rules we can use to incrementally develop secure processes and to rectify insecure processes.

Information flow security properties have been proposed as a means to ensure confidentiality of classified information in multilevel systems. These properties impose constraints on information flow among different groups of entities with different security levels. Often only two groups are considered and are labelled with the security levels high (H) and low (L). The condition is that no information should flow from H to L.

The paper is organized as follows. In Section 2, we recall the syntax and the semantics of the SPA language. In Section 3 we introduce the security properties BNDC and P BNDC. Moreover, in Section 3.1 we define a general unwinding schema and give a uniform presentation of the security properties P BNDC, SBNDC, CP BNDC, and PP BNDC as different instances of the general schema. In Section 4 we analize the relationships between unwind- ing conditions and compositionality with respect to the SPA operators and refinement. We exploit these results to develop proof systems for properties characterized through unwinding. In Section 5 we exploit the general unwind- ing schema to present a method for rectifying insecure processes. Finally, in Section 6 we draw some conclusions.

(i) no low level user can read from high level objects; (ii) no high user can write into low level objects. Indeed, these are the only two (direct) ways for leaking confidential information. Sometimes they are sufficient to ensure security as described in the following example.

Other bisimulation based persistent security properties have been studied in the literature. We recall here the following: Strong BNDC (SBNDC, for short), introduced in [13], Compositional P BNDC (CP BNDC, for short), introduced in [8], and Progressing P BNDC (PP BNDC, for short), introduced in [9]. All these properties are included in the BNDC class, i.e., if a process satisfies one of them, then it is BNDC. In the next subsection we introduce them through a uniform unwinding definition.

Example 3.7 Consider the memory cells Mh x and ML x described in Ex- ample 3.4. Exploiting the unwinding characterization of P BNDC given in Theorem 3.6 it is easy to see that both Mh 0 and Mh 1 are P BNDC . First, tinguish between the two states. As a matter of fact, the only possible low level actions are the two write operations wL 0, wL 1 which, both in Mh 0 and in Mh 1, move the system into the same states. The fact that ML 0 and ML 1 are P BNDC is even easier to prove: the only high level actions rh 0, rh 1 do not change the system state. Moreover, since neither Mh x nor ML x perform

Besides standard algebra operators, we also consider refinement operators which are useful for the stepwise development of secure processes. Indeed, one usually starts from a very abstract specification of the desired system which is then refined and decomposed until one arrives at a concrete specification that can directly be implemented. If properties are preserved under each refinement step then those properties which have been already investigated in some phase need not to be re-investigated in later phases.

Unwinding conditions are also useful for giving efficient proof techniques. In- deed, we used them to define proof systems which allow us to statically prove that a process is secure, i.e., by just inspecting its syntax [7,10]. These sys- tems offer a means to build processes which are secure by construction, in an incremental way. They extend the one given in [24] for finite processes, i.e.,

Example 5.4 The memory cell M x presented in Example 3.2 was not secure. We transformed it into two memory cells, a high level one and a low level one. Since the low level user cannot read from the high memory cell and the high level user cannot write on the low memory cell we obtain that the two memory cell are secure. Imagine now that we want to model the low level memory cell in such a way that each value can be read at most once. At the beginning the cell QL e is empty, when a low level user writes a value x the cell is moved in the state QL x in which it remains until either a high or a low level user read the value. After a reading the cell is reset in the state QL e.

