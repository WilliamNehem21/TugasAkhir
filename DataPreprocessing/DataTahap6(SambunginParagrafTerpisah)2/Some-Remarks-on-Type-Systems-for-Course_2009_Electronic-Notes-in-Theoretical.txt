definitions by iteration and coiteration have been successfully used to implement safe type systems extending the second-order polymorphic lambda calculus, system F. Hence it is natural to pursuit the definition and implementation of fold operators corresponding to course-of-value recursion as well. This paper proposes some new such extensions and states some important remarks emerged while verifying the correctness and safety properties of their operational semantics, relying not only on the categorical, but also on the logical approach based on fixed-point operators. Our observations should be considered as a starting point for a deeper study of the interrelation between these two approaches.

This paper concentrates in another useful pattern known as course-of-value re- cursion, captured by a construction called histomorphism in [21]. However, we do not focus in the categorical concepts, but rather in their implementation as type systems, which has been succesfully achieved for other schemes (see [13,17]). Our overall goal is to implement recursion principles in the setting of typed lambda calculus, taking the categorical approach discussed above, as well as a fixed-point approach, usual in logics with inductive definitions, as a foundation. Although the formalisms presented here are not new strictly speaking (see [21,22]), our contribu- tion, apart from present them in the framework of Curry-style type systems and generalizing them with full monotonicity instead of positivity, is to state some im- portant remarks about their static and dynamic semantics. Moreover this work intends to be a starting point for a deeper comparison of two distinct approaches to model course-of-value recursion.

corresponding to different implementations of the course-of-value fold operator, this is made clear in the case of natural numbers. After a brief discussion on termination (strong normalization) and its high price, we adopt the point of view of [20], and still pursuit this property by abandoning the realm of categories in favor of the fixed-point approach in section 6, where we present an alternative system for course- of-value iteration which happens to be terminating. Here we realize that for natural numbers there are still some operational problems and propose full course-of-value primitive recursion as definitive solution in section 7. Finally in section 8 we provide some closing remarks and future work.

An interesting task is to model course-of-value recursive types in Kleisli cate- gories or to compare histomorphisms with Kleisli or Eilenberg-Moore constructions. However, it is not a goal of this paper to further develop the work on category theory (for this see [19,21]), but rather to implement recursion principles in the setting of typed lambda calculi, taking the categorical approach as a foundation. We discuss next the general idea to model later the principle of course-of-value iteration.

Our goal is to implement the course-of-value iteration scheme as defined by histo- morphisms. This categorical approach is interesting and useful to obtain recursion combinators in typed lambda calculus. Recall that although the untyped lambda calculus has general recursion, the simple typed lambda calculus lacks recursion, for fixed-point operators like Y are not typable and, although simple iteration princi- ples can be modelled in the second-order lambda calculus (system F), the encodings are impredicative and very hard to handle from a practical point of view.

As we have seen in the previous section, the principle of course-of-value iteration can be faithfully modelled in a type system. However a natural question when proposing a new language is if the new constructors could be defined, as syntactic sugar, in a basis language, which usually already has some important properties like safety or termination. It turns out that this holds in our case. Consider the following alternative reduction rule for course-of-value iteration:

Proof This can be easily achieved in a similar way to the proof for the systems in [17], which is based in the one for system F given in [11]. Observe that the property is not trivial as it would be for a Church-style system. The systems are presented here in Curry-style and therefore the rules for polymorphic typing are not syntax-directed.

The termination of these new systems is carried out by a type-respecting and reduction-preserving embedding into a terminal system developed in [17], which is basically the one described in section 4.1 plus the above operational rules for inversion. The essential part of this embedding can be read from the definition of histomorphisms by catamorphisms (simple iteration) of proposition 3.6.

It is well-known that the inefficiency of an iterative predecessor vanishes using prim- itive recursion instead of simple iteration to define it (see [18]). Therefore, we think that the needed well-behaved predecessor for course-of-value natural numbers can be obtained using primitive course-of-value recursion. Moreover, this would solve the problem not only for natural numbers, but also for the destructor of any course- of-value monotone inductive type.

Matthes, R., Monotone fixed-point types and strong normalization. In Georg Gottlob, Etienne Grandjean, and Katrin Seyr, editors, Computer Science Logic, 12th International Workshop, Brno, Czech Republic, August 24-28, 1998, Proceedings, volume 1584 of Lecture Notes in Computer Science, pages 298-312. Springer Verlag, 1999.

