We have designed an implementation framework [6] to develop several visu- alization systems, one per design technique. To illustrate the feasibility of this framework, a first system was implemented to visualize recursion, called SRec [20]. Now, we are addressing the design of a visualization system for a proper algorithm design technique, namely divide-and-conquer.

We assume that the definition of divide-and-conquer algorithms is well known, but we list here the terms used in the rest of the paper. A problem solved by divide-and-conquer is decomposed into subproblems. They are recursively solved, resulting in subsolutions whose combination gives place to the solution of the original problem.

Divide-and-conquer algorithms often traverse and manipulate a data structure. Each subproblem is constrained to a part of the structure, i.e. a substructure. We only deal here with one- and two-dimensional arrays, thus we often use the terms (sub)arrays, (sub)vectors and (sub)matrices. The most common and efficient way of delimiting subarrays is by using a range, defined with a lower and a higher index.

[20]. The system allows the user to select the parameters or results to display; when a method does not return any value but produces side-effects, the origi- nal and final value of the parameters are displayed. It also has several facilities (zoom+panning, overview+detail) to handle large-scale activation trees. Finally, a user-defined colouring scheme can be used to differentiate input/output values, and the status of a call in the global process (executed, active or pending). In spite of all of these facilities, the resulting visualizations are not satisfactory.

The partition tree (pp. 41, 91, 158) is a variation of an activation tree that suc- cessfully combines recursion and vector representations. In summary, it consists of a tree isomorphic to an activation tree, where an element of the vector is dis- played either as a node of the tree (when it is at its final position) or as a part of a subvector (when it has not been processed yet).

A different analysis of the visualization of recursive algorithms can be found at Stern [18]. They propose differentiating three kinds of algorithms, depending on how they handle a data structure (namely, algorithms that modify, traverse or construct it), rather than considering their recursion scheme. However, it is not obvious whether their visualizations can be generalized: the visualizations they propose contain vectors for the first class of algorithms, and trees for the other two classes. The visualization included in the article for the former class corresponds to a divide-and-conquer algorithm (namely, quicksort). It displays horizontally the vector and underlies it with horizontal bars that mirror recursive calls.

We have implemented a working prototype of the design presented here. How- ever, more work is necessary to become a fully operational system. Usability eval- uations performed by experts (i.e. instructors) and in sessions with students are important to assess their validity, as described in [20] for the SRec system.

