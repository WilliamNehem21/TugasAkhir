We present a method for testing the implementation of graph transformation specifications focusing on test case generation for graph pattern matching. We propose an extensible fault model for the implementation of transformations based on common programmer faults and the technicalities of graph transformations. We integrate traditional hardware testing (combinational circuits) and software testing techniques (mutant generation) for generating test cases.

In order to detect conceptual flaws in transformations, typically, either verifica- tion (termination, confluence, semantic correctness, etc.) and/or testing techniques are applied. In general, verification is mainly used in the design phase of transforma- tions, while testing is appropriate in the implementation phase, when a stand-alone transformation plug-in has been created for the corresponding specification. Testing has typically two main advantages: (i) it can be used for large models without com- binatorial explosion, (ii) tests are executed directly on the implementation, which in case of model checking often cannot be guaranteed.

We propose a fault model to incorporate potential flaws in the implementation. Test generation is performed by using a combinational circuit representation derived from the preconditions of graph transformation (further: GT) rules. Possible faults are mapped to stuck-at-faults (a signal lines is assumed to be stuck at a fixed logic value, regardless of the inputs), as there are various hardware testing methods for the combinational circuit and this fault model. With the help of systematic fault injection, single binary (stuck-at-faults) faults are inserted into the circuit and test vectors are calculated. The exact test cases are generated by mutation rules in the form of test graphs.

Example 2.1 According to the metamodel, a well-formed instance of a finite au- tomaton is composed of states and transitions. A transition is leading between its from state and to state. The initial states of the automaton are marked with init, the active states are marked with current edges. Special, e.g. colored states, are definable by inheritance.

Graph transformation [20] is a pattern and rule based formalism for the manipula- tion of graph models. On rule application, a graph is transformed by replacing a part of it by another graph. With the definition of a metamodel and a set of rules over that metamodel the dynamic changes of an initial model can be described. On rule application, a graph is transformed by replacing a part of it by another graph. A graph transformation rule R contains a left-hand side graph LHS, a right-hand side graph RHS, and negative application condition graphs NACs. The LHS and

Pattern Matching Criteria The logical criteria for the successful matching of each rule is extracted from the transformation specification in the form of a Boolean expression. The formula is satisfied, when a successful matching is found for the belonging GT rule. The idea is to reuse existing techniques for hardware testing, therefore the Boolean formula is depicted in form of a combinational circuit, for which traditional test generation algorithms can be applied.

Test Generation With systematic fault injection, single faults are injected into the inputs of the circuit. For its simplicity, the method of Boolean differences [16,21] is applied here which generates binary test vectors for stuck-at-faults in the combinational circuit representing the pattern matching. The method of Boolean differences guarantees that with the generated test vectors the fault is observable on the output of the circuit. If a variable in the generated test vector is one, then the corresponding condition is satisfied, else it is not satisfied. For further details see Section 4.2.

Test Set Optimization The set of produced test graphs should be examined for test optimization, in order to create a more compact set of test cases, it should be optimized. Naturally, it has to be decided, whether the aim is only fault detection or diagnosis as well. In the latter case, test compaction can only be carefully applied, not to loose information for diagnosis.

The general, formal criteria for a match are presented in [23]. The idea is to describe these criteria for each GT rule in the rule set of the specification, and to create a combinational circuit representation of this Boolean formula, which will supply us with the usability of traditional testing methods. The formula evaluates to 1, if a match fulfills the defined criteria meaning that the pattern matching was successful.

The dangling edge condition: All nodes and edges in LHS of a GT rule R but not in RHS are deleted when the rule is applied. When applying this rule R on a instance graph, all the edges to and from these nodes which are not part of the match are the dangling edges. The dangling edge condition is fulfilled, if no dangling edges will be produced on rule application.

The NAC condition: If only single, non-hierarchical NAC graphs are used, the NAC condition is satisfied, if its elements cannot be found in the match. The Boolean formula can be written for the NAC graph as above, and it is inverted before connecting it to the pattern matching criteria. In case of hierarchical NAC conditions, the Boolean formula of a lower level NAC is inverted before connecting it to the higher level condition. More on this topic can be found in [19].

An automated formal verification technique is presented in [18,7,24] based on various model-checking techniques to prove semantic correctness criteria in graph transformation systems starting from a concrete initial graph. A static analysis technique is proposed in [1] to investigate the correctness of graph transformation systems by using a Petri net abstraction. A tool for checking inductive invariants has been presented recently in [4]. To guarantee the preservation of constraints during model transformations, aspect-oriented techniques are proposed in [13].

The testing of code generators specified by graph transformation rules has been addressed in the literature by adapting well-known test strategies such as test case generation by model checking [2] or the classification tree method [22]. In [11] tests are generated for black-box implementations of web services based upon domain partitioning. While the overall goal i.e. to derive test cases directly from GT rules is similar, we assume that implementation is strongly linked to the GT specifica- tion, furthermore we use systematic fault injection and combinational circuit testing techniques in the background.

Our aim is to extend our testing method with the consideration of rule applica- tion, the RHS or postcondition of GT rules as well. Secondly, we plan to improve the fault model with control flow faults and design methods for testing the control structure of graph transformations as well. Furthermore, more work has to be done in the area of test set optimization. It is a future goal to examine the usability of our method for not only fault detection, but also for diagnosis as well, and to try out our method on graph transformation implementations.

