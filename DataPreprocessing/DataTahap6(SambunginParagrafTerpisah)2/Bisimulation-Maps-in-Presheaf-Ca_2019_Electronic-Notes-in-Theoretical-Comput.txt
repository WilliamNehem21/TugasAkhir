executions (inspired by [10, 28]) because the branching structure of a state in the presence of invisible actions is described by the set of executions (not states). This situation further escalates when one is interested in infinite executions (e.g. fairness properties [17, 25]) or dense executions which are omnipresent in hybrid systems (e.g. [12]). The point is not that executions are inexpressible in a coalgebra, but rather that we need a semantic framework where they are treated as first-class citizens just as states are in a coalgebraic framework. Thus, our hypothesis is that behaviour of a system is given solely by its executions.

The objective of this section is to describe our semantic framework in which one can model behaviour of a dynamical system. By behaviour of a dynamical system, we understand some phenomena that evolve over time. Our aim is to formalise this intuition. We begin by modelling time as a small category T, whose objects are points in time and arrows describe passing of time.

One possibility is to use the open maps of Joyal et al. [23], which gave a unified definition of functional bisimulations over the range of computational models. In particular, when invoked in a presheaf category, open maps correspond to natu- ral transformations whose naturality squares are the weak-pullback squares in Set (see [8, Proposition 2.3]). Nevertheless, an open map falls short in capturing the complete refinement point of view since an arbitrary open map may not even be a surjective map at the level of executions; i.e., our implementation may not even implement or cover all the behaviour present in the specification.

Remark 3.2 It is interesting to note that a similar definition for sheaves can be derived from the definition of embedding-open maps as given in [5]. First, note that Sh(C,J) is concrete over PSh(C) due to the forgetful functor i, which is fully faithful. Moreover, embeddings in this concrete category are actually monomor- phisms. This is because any mono is a regular mono in Sh(C,J) and the faithful functor i preserves regular monos (since i is right adjoint to the associated sheaf functor a [27]). Lastly, every regular mono is an embedding whenever the faithful functor preserves regular monos [2, Proposition 8.7.3]. Thus, we have the exact same definition of bisimulation maps in Sh(C,J).

We end this section by capturing functional bisimulations in terms of bisimu- lation maps whose proof can be extracted from the proof of Theorem 4.3. Note that a similar theorem was proven earlier in the seminal paper [23] for functional bisimulation; however, the difference is that we use bisimulation maps (not open maps) in our characterisation.

Before we prove Theorem 5.11, we need a category theoretic result (which is probably folklore; see [26, Exercise IV.2.7] for a dual statement), namely, that the colimit of a diagram can be decomposed into the coproducts of the colimits of diagrams with smaller shapes under certain restrictions.

Open maps between presheaves as defined in [23] are instances of the open maps in a topos as introduced in [22]. This is because open maps between presheaves (as in [23]) are natural transformations whose naturality square is a weak pullback in Set (cf. [22, Example 1.1]). We discarded the open maps between presheaves because they are incapable of establishing complete refinement between an implementation and its specficiation; though it is still interesting to assert whether the bisimulation maps (Def. 3.1) satisfy the axioms given in [22].

Prefix orders are generalisations of trees proposed in [10] to study executions of dynamical systems in an order theoretic manner. In [5], the authors defined functional bisimulation between prefix orders by reinterpreting the definition of open maps in concrete categories. Our bisimulation maps are an instance of this general definition (Section 3). It is unclear, though, how to enrich prefix orders with observations so that we can model labelled executions in a uniformly. This question lead us to model observations as presheaves.

