Binary Decision Diagrams (BDDs) and their multi-terminal extensions have shown to be very helpful for the quantitative verification of systems. Many different approaches have been proposed for deriving symbolic state graph (SG) representations from high-level model descriptions, where compositionality has shown to be crucial for the efficiency of the schemes. Since the symbolic composition schemes deliver the potential SG of a high-level model, one must execute a reachability analysis on the level of the symbolic structures. This step is the main resource of CPU-time and peak memory consumption when it comes to symbolic SG generation. In this work a new operator for zero-suppressed BDDs and their multi-terminal extensions for carrying out (partitioned) symbolic reachability analysis is presented. This algorithm not only replaces standard BDD-based schemes, it even makes symbolic composition as found in contemporary symbolic model checkers such as Prism and Caspa obsolete.

The author of [19] gives a highly detailed overview on techniques related to sym- bolic reachability analysis and computation of relational products when one employs BDDs for representing transition relations. The workings [5] and [13] also present algorithms for computing relational products, where in case of the former BDDs and in case of the latter ZBDDs are addressed. Similar to these contributions our new algorithm combines conjunction and existential quantification into a single al- gorithm. However, the here presented work differs with respect to the state graph generation method and thus leads to a different algorithm. Like many other sym- bolic verification tools we also emphasize the usage of high-level modelling methods for describing systems, thus in our approach we assume compositionally constructed transition relations. In such a context one commonly inserts identity structures on the position of the sub-model-independent state variables before combining the in- dividual transition relations and executing a symbolic reachability analysis. The algorithm as introduced here, makes this unnecessary, since it advises an identity semantic when recursing on such variables.

Sec. 2 introduces the basic setting and makes the reader familiar with Decision Diagrams (DDs). Sec. 3 introduces the new symbolic reachability algorithm. Its practical feasibility is investigated in Sec. 4, where standard benchmarking models as known from the literature are analyzed. Sec. 5 concludes the paper.

Within shared BDD-environments ZDD-nodes lose their uniqueness as soon as the represented functions are defined on different sets of input variables. To solve this problem, [9,12] introduced the concept of partially shared ZDDs (pZDDs) and algo- rithms for manipulating them. The basic idea of this approach is as follows: When working with pZDDs, i.e. with ZDDs having different set of input variables, one also iterates over the input variables of the operand pZDDs. This allows one to assign a specific semantics to each visited but skipped variable on the current path. The most important algorithms as far as it is from concern here are the followings:

The symbolic representation of a (submodel/partition-) local transition function takes only those SVs as input variables, which are in the dependency set of the activities encapsulated in the resp. submodel or partition, i.e. one solely encodes here the values of submodel- or partition-local (dependent) SVs SD.

If vc is a s-variable one simply recurse with the current node into the else- and then-branch, where a node must be allocated for vc only if there is a node allocated within Zunex, which gives way for skipping variables (see discussion below). In case vc is a t-variable a more complex behavior depending on the current recursion applies: (i) Within the then-branch of the recursion the else- child of the current node is the terminal 0-node and the then-child is the current node itself. (ii) Within the else-branch of the recursion one is enabled to skip one recursive call, since the node to be allocated here would be eliminated due to the 0-sup.-reduction rule anyway.

Activity for BDDs and standard Multi-terminal Binary Decision Diagrams [1] one need to adapt the terminal conditions, the conditions for cache look-ups and in- sertion, and assign the current node g (f ) resp., to the then-child g1 (f 1) instead of the 0-node (line 22,31,42,45). Also it must be taken care of the node allocating function, so that it implements the correct node elimination rule (line 58).

the variables {s1,... , t2} are non-function variables for Zl, whereas {s3,... , t6} are its input variables. Within the first recursive call the else-branch takes node l and f as argument, and the then-branch takes node h and f as argument. As one can see, it is often also not necessary to stop for each variable in V, since when return- ing from the recursion sometimes no node will be allocated at the respective level,

