There are different algebraic structures that one can use to model notions of computation. The most well- known are monads, but lately, applicative functors have been gaining popularity. These two structures can be understood as instances of the unifying notion of monoid in a monoidal category. When dealing with non-determinism, it is usual to extend monads and applicative functors with additional structure. However, depending on the desired non-determinism, there are different options of interaction between the existing and the additional structure. This article studies one of those options, which is captured algebraically by dioids. We generalise dioids to dioid categories and show how dioids in such a category model non- determinism in monads and applicative functors. Moreover, we study the construction of free dioids in a programming context.

Algebraic structures have been central to the modelling of computational effects. For example, monads [12,13,21,17] have been used to model many computational effects such as global state, exceptions, environments, input/output, and continuations. More recently, applicative functors [11] are becoming popular in diverse applications such as modelling parsers [18], characterising traversals [4,7], and in combination with monads to obtain concurrent queries [10].

category [9]. This unification of concepts is extremely useful, as it allows us to translate concepts, properties, and techniques from one structure to the other. For example, through the unified framework, an old optimisation technique for lists [6] is shown to be essentially the same as a newer one for monads [20], and led to the discovery of a new one for applicative functors [14] by means of a simple translation. In many applications of monads and applicative functors one has to deal with non-determinism. There are different flavours of non-determinism [19], but in func- tional programming the most common are deep backtracking and shallow backtrack- ing [16]. When modelling deep backtracking, the algebraic structure that arises is near-semirings. This insight lead to a unified framework for deep-backtracking non- determinism in monads and applicative functors [15]. If, on the other hand, one wants to model shallow backtracking, then one arrives at the algebraic structure of

This article studies the shallow-backtracking variant of non-determinism by studying the categories that support the definition of dioids, namely dioid cate- gories. Working at this level of abstraction allows us to obtain a unified model of shallow-backtracking non-determinism for both monads and applicative functors. Moreover, we study the construction of free dioids. Intuitively, free dioids can be thought of as the programs that can be written when only the dioid interface is exposed, and therefore provide a canonical representation for programs structured as a computation with shallow-backtracking non-determinism.

The article is structured as follows: In Section 2 we introduce monoids and monoidal categories, and show how they provide a unified framework to study the notions of monads and applicative functors. In Section 3, we introduce dioids and dioid categories. Moreover, we show how these categories provide a unified frame- work to study shallow non-determinism in monads and applicative functors. In Section 4, we turn to the construction of free dioids. We provide a formula that allows to construct dioids on Set (the category of sets and functions) and to con- struct the free dioid applicative. Unfortunately, it does not allow us to express the free dioid monad. Finally, in Section 5, we conclude.

This makes the structure a near-semiring. See the work of Rivas, Jaskelioff and Schrijvers [15] for details. In this case it is possible to explore different results, whereas in the shallow case, we explore possible results in order only until one is found.

We can use Lemma 3.3 to extend the monoidal categories of endofunctors discussed in Sections 2.4 and 2.5 to dioid categories. We need to establish that the category of endofunctors on a category C has terminal object and binary products. If the base category C has terminal object, then the constant functor to the terminal object is the terminal object on the category of endofunctors.

An important non-example of MonadPlus subject to these axioms are lists. While the empty list and list concatenation would give an implementation for mzero and mplus, such implementation would not satisfy the law mplus (return x ) u = return x . (In fact, lists are the canonical example of deep-backtracking non-determinism.)

Starting with the analysis of the free monoid, we have generalised the solution to monoidal categories, and then we have used this formula to obtain the free monad and the free applicative. General conditions for the existence of free monoids can be found in the work of Kelly [8]. The case of free monads and free applicative functors is analysed in detail by Rivas and Jaskelioff [14].

