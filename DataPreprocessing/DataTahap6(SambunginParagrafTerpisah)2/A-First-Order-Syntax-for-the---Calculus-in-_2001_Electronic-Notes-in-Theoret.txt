!az:zx :zx :P 0 and C d=ef ( y)a y:y b:y c:C0. Process P is a procedure 2 that each time it is called along channel a and transmitted two arguments, launches an instantiation of its body P 0. Process C, on the other hand, models a client creating a new channel y over which it then transmits its parameters b and c to P . Assuming that z does not occur in P 0 and y does not occur in C0, the following communication can be established between the two processes

We use the general-purpose theorem-prover Isabelle [27], based on higher- order intuitionistic logic, and formalize the -calculus in its instantiation HOL for higher-order logic [25]. Proofs in Isabelle are based on uni cation, and are usually conducted in a backward-resolution style: the user formulates the goal he/she intends to prove, and then|in interaction with Isabelle| continuously reduces it to simpler subgoals until all of the subgoals have been accepted by the tool. Upon this, the goal can be stored in the theorem- database of Isabelle/HOL to be applicable in further proofs. The prover o ers various tactics, most of them applying to single subgoals. The basic resolution tactic resolve_tac, for instance, allows the user to instantiate a theorem from Isabelle's database so that its conclusion can be applied to transform a current subgoal into instantiations of its premises. Besides these classical tactics, Isabelle o ers simpli cation tactics based on algebraic transformations. Powerful automatic tactics apply the basic tactics to prove given subgoals according to di erent heuristics. The automatic solver auto_tac, for example, combines classical reasoning and simpli cation over sets of rules that can be modi ed by the user. The tactic

The -calculus [23,24] is the mobile counterpart of CCS, reducing its prede- cessor to basics by identifying the sort of messages and channels, referring to both as names. This gives processes the possibility to declare new names and send them to other processes, thus create private communication lines with them. It is this syntactic simplicity, from which the  -calculus draws the power to model mobile communication systems [23] and higher-order lan- guages [3,18,22,31].

Consider an at least countably in nite set of names, ranged over by a; b;::: ; x; y;:: :. In our formalization, we have not chosen a particular type, but axiomatically accept every type that is at least countably in nite. We have adopted this approach already in [28,29], leaving the possibility for speci c instantiations, such as with naturals or reals. Naturals, for instance, can increase automation in certain cases, because fresh names can be computed by determining the maximal name in the involved processes and choosing the successor.

The actual syntax may vary from one application to another. Often, mis- matching is omitted due to its semantic misbehaviour in various cases, or output pre xes may stand for themselves only, as in asynchronous -calculi. We formalize the full syntax to be comparable with previous works [17,28,29].

When it comes to formalizing a language, the rst question that naturally arises is which syntax to choose. In this section, we present a classi cation of the approaches known up to date, based on (mostly own) practical experience. We describe the main features of the approaches, point out strengths and weaknesses with respect to formalizations, and try to give a guideline for possible areas of application. Sticking to the -calculus as an exemplaric language, we point to formalizations of it within the various schemes. In a second part of this section, we discuss in more detail rst-order formalizations; for discussions about higher-order formalizations, see, for instance, [11,17,29].

object-level using object-variables, for free and bound parameters alike. An alternative way is to apply a shallow implementation strategy, de ning binders in terms of meta-level functions, thus representing bound names by meta- variables, whereas free parameters are further denoted by object-variables. These two implementation strategies can be combined with a rst-order or a higher-order syntactic description of the language. Applying rst-order syn- tax, of course, one always obtains a deep embedding, because it does not distinguish between binders and other operators on the syntactic level. Ta- ble 5 gives an overview of the three ways of formalization.

case that free and bound names are not merely distinct but incomparable (on the object-level, on which proofs are conducted) with the former being object- variables and the latter meta-variables. The approach is particularly useful to concrete processes, and enjoys increasing popularity also in meta-theoretical reasoning. On the other hand, the meta-levels provided by general-purpose theorem-provers are often so powerful that exotic terms can arise, making an axiomatisation of syntactic properties extremely delicate (see [14,16,17,29]).

