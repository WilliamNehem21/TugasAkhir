This paper describes the semantics of a timed, resource-constrained extension of the Creol modeling lan- guage. Creol is an object-oriented modeling language with a design that is suited for modeling distributed systems. However, the computation model of Creol assumes infinite memory and infinite parallelism within an object. This paper describes a way to extend Creol with a notion of resource constraints and a way to quantitatively assess the effects of introducing resource constraints on a given model. We discuss possible semantics of message delivery under resource constraints, their implementation and their impact on the model. The method is illustrated with a case study modeling a biomedical sensor network.

The rest of this paper is structured as follows: Section 2 gives an overview of the features of the Creol language pertaining the modeling of distributed systems, Section 3 explains how the Creol semantics and interpreter were altered to allow modeling of resource constraints. Section 4 presents an extended example and some experiences gained from introducing resource constraints in a larger case study. Section 5 gives an overview of related work in this area, and Section 6 concludes the paper.

Each Creol object is executing its own thread of control, interleaving active and reactive behavior. All method calls (including self-calls) create a new process within the called object. At most one process is active for each object and has exclusive access to the objects attributes. Special statements allow to change between pro- cesses, which manifest the cooperative multiprogramming style. A process need not distinguish whether it was created from a synchronous or asynchronous call.

The base Creol language does not model time or progress, but recently Kyas and Johnsen designed a Creol extension for real-time constraints [8]. The extension is common and simple: the value of a global clock is accessible to all objects through the expression now, which behaves like a read-only global variable of type Time. Values of type Time can be stored in variables and compared with other Time values. There is no absolute notion of time; progress can be expressed by adding Duration values to observations to obtain other values of type Time. An advantage of this design is that specifications in timed Creol are shift invariant; i.e. properties involving time hold no matter at which point in (absolute) time the evaluation happens. Indeed, this time extension is inspired by the time model of the Ada programming language [13, Appendix D.8].

In contrast to the Ada programming language, Creol focuses on modeling and not on implementations. As such, a Creol model is a logical description and we ignore certain aspects like preemption due to interrupts in this paper. Interrupt handlers may be modeled by methods of singleton objects, which are invoked as a result of an interrupt signal. Thus, the method described in this paper allows to model the effect of interrupts without the need of taking the actual machine into account.

Here, line 3 guarantees that evaluating SL takes at most 10 time units. A posit statement expresses a global property of the system and may result in a system that has no behavior at all; all posit statements are proof obligations on the statement level. For details and exact semantics of timed Creol, we once again refer to [8].

The execution semantics of Creol assume that an object can execute an arbitrary number of processes. Especially for small embedded systems, this assumption does not hold. It is therefore desirable to be able to model the operating constraints of real systems in Creol. This section presents the implementation approach that was taken to adapt the semantics and execution engine of Creol to deal with resource constraints.

O, C, AL, BL, SL, and PL are typed variables, where object O is an instance of class C with instance variables AL and an active process that consists of local variable bindings BL and a list of statements SL. The list of pending processes is represented by PL. Classes and method invocations have a similar Maude notation.

The left-hand side of this rule matches any object with an active process having skip as its next statement. Such an object is replaced with an object identical in every way except that the skip statement is removed and the remaining statement list SL left for execution. Rules for other statements follow the same pattern, but typically have more effect, such as rebinding variables, creating, destroying and scheduling processes or creating new objects.

The case study presented in this section was developed as part of the Credo project [3]. It models a sensor network consisting of a set of sensor nodes and one sink node. Sensor nodes are actively monitoring their environment and sending out their measurements. In addition, sensor nodes have the task of routing messages from neighboring sensor nodes towards the sink node. The sink node, typically connected to back-end processing, receives data from all nodes but does not create

Modeling bounded computing resources is relevant because micro-controllers expose the programmer to a bounded call depth, either explicitly or because of memory constraints. For example, the PIC family of micro-controllers has an explicit maxi- mal call depth between 2 and 31, depending on the model. Version 2 of TinyOS [9], an operating system for wireless sensor networks, contains tos-ramsize, a tool for static stack depth analysis calculating worst-case memory usage by summing stack usage at call points for the longest path through the call graph, and adding stack usage of all interrupt handlers. The theory behind this tool is presented in [12]. Being a simple tool, tos-ramsize does not handle recursion. McCartney and Sridhar [10] present stack-estimator, a similar tool for the TinyThread library. The value of our work is that resource constraints can be expressed already on the modeling level, and that the model can be validated by simulation. Also, we present a unified approach to modeling call stack depth and restricted parallelism in a model.

Our work deals with modeling systems on a lower level of abstraction than using automata models, using Creol [7], an imperative, object-oriented modeling language with asynchronous communication between objects. Similar work was done by Ver- hoef et al. [14], who use the timed variant of the modeling language VDM++ to model distributed embedded systems. They model processing time, schedulability and bandwidth resources by enriching timed VDM++ with a notion of CPUs, com- munication buses and asynchronous communication, and loosening the global time model of standard timed VDM++. Creol supports many of the changes necessary for modeling distributed systems in the core language already. Kyas and Johnsen [8] use Creol to model timing aspects of wireless sensors, but do not consider resource constraints of that platform.

