A distributed system consists of a collection of autonomous computers, so called nodes or hosts, connected through a network and distribution middleware, which enables nodes to coordinate their activities and to share the resources of the system, so that users perceive the system as a single and integrated computing facility [23]. The implementation of distributed systems is a difficult task, in part because, current mainstream approaches and tools do not provide mechanisms to explicitly define, coordinate and implement distributed algorithms and communication pat- terns. Instead, programmers are forced to design defensibly and to create isolated, complex and disjoint software components to implicitly control the behavior and communication protocols of distributed applications. Consider, for example, a 3 tier application. On such an application, communications are restricted to contiguous layers and, in most cases, such a restriction implies that communication between two

To address the limitations of current tools and approaches for distribution, sev- eral design techniques and architectural styles have been proposed, see for exam- ple design patterns [9,1] and integration patterns over messaging middlewares [10]. However, most of these approaches are catalogs of best practices, idioms, and rec- ommended usage scenarios that deal with the restrictions of current tools an do not improve on the tools main abstractions. Furthermore, recent research has shown that the usage of these best practices and patterns do not improve on the actual complexity of resulting code. For example, Benavides et al. showed in [6] that the implementation of complex communication patterns used to replicate dynamic session information on clusters of JEE application servers, resulted in tangled and scattered code difficult to understand and maintain. Even tough, the communica- tion patterns were clearly defined, well documented, and developed according to current best practices.

This document is structured as follows. First, in Section 2 we motivate our work by means of detailed analysis of non trivial scenarios found on distributed applications. Then, we present the design considerations for the kernel library in section 3. Section 4, discusses the implementation of the kernel library to support the proposed constructs. Section 5 presents a qualitative evaluation by means of the implementation of a Distributed Aspect Oriented Language. Finally, section 6

In this paper, we argue for a mechanism to explicitly construct and coordinate complex interactions and communication patterns on distributed applications. In this section, we present three non-trivial scenarios that show what kind of problems arise when dealing with distributed events on distributed applications. First, we present an abstract scenario where a set of events are communicated between the nodes participating in the application. Then, we discuss two concrete cases in the context of typical debugging and testing tasks of distributed middleware.

Currently, several approaches to define and validate relationships among con- straints on events in distributed systems have been proposed. For instance, data path expressions for concurrent programs [21], causal event relationships based on logical clocks [2,8,15], and control-flow based event relationships [16]. However, the declarative flavor of these proposals have not been integrated into mainstream middlewares. Hence, besides that relationships involving multiple hosts have to be expressed using complex and isolated encodings, independent components have to be aware of catching false positives/negatives and deal with them.

With respect to the debugging session, for example, the error was difficult to reproduce because the incorrect interleaving of events, that generated the deadlock, were reproduced randomly by the scheduler. Thus, in a common debugging session with limited number of threads and big delays imposed by the debugger the error is almost impossible to generate. Thereby, since current debugging tools do not provide abstractions to concisely express such cases, programmers once again have to manually encode integration information in order to deduct the distributed state. This tactic implies applying programming tricks, such as polluting the original code with state information, in order to track the necessary control flow dependencies. Often these debugging tasks can be much facilitated by ensuring that occurrences of

The situation is similar when writing a test case for such error. A common idiom used when testing errors involving random interleaving of events is to trigger several threads at the same time, in order to reproduce the error randomly. For example, in JBoss Cache there is a test case with such an idiom. Concretely, the test case uses two caches, actions on the first cache are replicated into the second cache by means of the replication framework. The test case triggers multiple workers in multiple threads. Each worker starts a transaction, puts a value in the cache and commits the transaction. The deadlock occurs when a worker, after a successful prepare phase of the two phase commit protocol, commits a transaction and releases the lock over the source cache after the local commit, but before completing the final commit phase with the remote caches. There, other workers may interleave their transaction operations, in particular, acquire the lock at the same cache position and thus preclude the first transaction to terminate its remote commit phase, thus entering a deadlock situation, because no worker can acquire all necessary local and remote locks anymore.

This section discusses the main considerations and assumptions we did in order to design the kernel library. We first discuss the event model, then we discuss how patterns of events may be detected using a model based on finite state automata. Finally, we consider a dynamic model for time constrains and several usage scenarios for the library.

Finally, the model has to expose a fully distributed architecture, i.e. without centralized processors or bottlenecks, and with all events being notified to the other nodes. In this model each node participating in the application may receive and send messages regarding the occurrence of events. The model is also dynamic, meaning that nodes may enter and leave the distributed application at any time. As such, there is not any centralized server or broker managing the notifications. For the purpose of designing the kernel library we consider that all events occurring on any node are notified to the other nodes. Note that this last restriction is just there to help us with design, leveraging the burden of what events should be distributed. In our case we consider that all events are distributed. Afterwards, the reader will see that this restriction is not made explicit for the library to work, and that in concrete applications (see aspect language implementation on section 5) intelligent selection of events makes the quantity of distributed events very low.

In the previous section, we introduced the design considerations for a model where an atomic event can be detected on any node participating in a distributed appli- cation. Now, in order to detect a complex pattern, we propose to use a finite state automata-based model. This model will consider that on each node, interested in a particular pattern of events, an automaton will be deployed. The automaton will consume event notifications to trigger the transitions.

events will trigger transitions t1 and t3 respectively, starting and stopping repli- cation. Transition t2 will be triggered by remote events push or pop. Note that we have not bound explicitly a behavior to transitions, however we can do it, for example by binding the necessary code to replicate on the local stack the detected push and pop remote events.

In this section we describe the main components of our event-based kernel library. We first present the architecture, its elements, and how such elements implement the model described in the previous section. We then, show in detail how we build the automata framework to support the detection and management of patterns of distributed events. The library code can be found at [17].

The Distribution Layer provides the main abstractions to distribute event messages and listen to event messages sent by other nodes. The layer provides a distributed architecture (i.e. with no centralized component) based on group communication (see JGroups [14]). Each node on the distributed application must have a deployed instance of the kernel library.

Having the possibility of adding expressions to transitions provides immediate support for guards. In order to build a sophisticated guard expressions the program- mer may use Not, And, Or constructs. For this, the library provides a hierarchy of expressions constructs including the unary Not expression and the binary expres- sions And and or. However, for flexibility, the user may create its own expressions library according to its needs.

AWED proposes three main concepts: Aspect, Distributed Pointcut, and Dis- tributed Advice. Aspects are class like constructs that are used to define crosscut- ting concerns. Those aspects, contain pointcut definitions and advices. Distributed Pointcuts are declarative constructs that are used to match specific events over the execution trace of a distributed program. AWED proposes a pointcut language that is sensible to event localization. For instance, AWED not only provides pointcuts to match events like method calls, methods execution, variable update, but it also provides pointcuts to match events that occurred on an specific host or group of hosts. Advices are method like constructs that are bound to pointcuts and that are executed once a specific pointcut matches an event.

In order to select an Automata Engine component, we studied several libraries and applications which target is the modeling of situations using automata and regular expressions. In this section, as a representative piece, we present four of them. We also discuss current distributed event-based models.

tion of distributed events, and we evaluated our approach. We included in the kernel library constructors to encapsulate inside well defined components the coordination of distributed applications, instead of delegating the coordination to disjoint com- ponents; for this, the architecture of the library is based on an automata library implementing basic automata operations. Our evaluation has shown that our li- brary can be used to build or improve a sophisticated distributed aspect oriented language such as AWED.

Our work prepares the way for several leads of future work in two main areas, model and appliction. For model extension we will explore more complex patterns and concepts, e.g. epsilon transitions, push down automata. With respect to appli- cations, we will study the implementation of a fully distributed debugger for Java, and the development of dynamic graphical modeling tools to generate software ar- tifacts.

