Model-based runtime verification is an extension to the state-of-the-art runtime verification, aimed at check- ing at runtime the system implementation against the system model (consistency checking) and the system model against the system specification (safety checking). Notice that our runtime verification works at the model level, thus, we do not need to strictly synchronize this runtime verification with the system execu- tion. In fact, we mainly use the runtime information (current states) obtained from the system execution to reduce the state space (of the system model) to be explored. It means that this model-based runtime verification might run before or after the system execution, i.e., switch alternately between a preventive pre-checking mode and a maintaining post-checking mode. In order to make it run ahead of the system

However, for a complex system, simulation and testing only explore some of the possible behaviors and scenarios of the system implementation. Although model checking conducts an exhaustive exploration of all possible behaviors, it has to face the state explosion problem. In addition, it is usually difficult to decide if the set of the system properties to be checked is complete or not.

Because we check correctness at model level, this kind of runtime verification can make progress even if the current state of the system execution is not observed yet. That is, it is possible for the model-based runtime verification to run ahead of the system execution and thus the property violations might be detected before they have already occurred. In essence, the monitored (concrete) states are used to locate the corresponding (abstract) states in the system model so as to reduce the state space to be explored.

Therefore, the model-based runtime verification can do pre-checking and post- checking according to whether this runtime verification takes the leading position against the system execution or not. It looks as if the runtime verification and the system execution are involved into a two-player game. Of course, it is desirable that the runtime verification can run ahead of the system execution for as long time as possible in the course of the game. For this purpose, we present two strategies to make the runtime verification have more chance or higher probability to win against the system execution.

The implementation of a component is in fact a refinement of the model of the component, i.e., the model is an abstraction of the implementation of the compo- nent. Thus, an ACTL/LTL formula being true at the model level implies that it is also true at the implementation level, while its being false at the model level does not imply that it is also false at the implementation level. In this sense, our runtime safety checking is conservative due to its being applied to the model level. However, the benefits of predicting and thus avoiding potential errors are gained just due to its being applied to the model level.

properties is implemented. We have done some experiments for randomly generated state transition graphs so far. The execution traces are also generated randomly from the corresponding state transition graphs by simulation, which can simplify the monitoring procedure to capture the runtime information (current states) used for runtime model checking. In order to imitate the runtime verification running faster than the system execution, we make our runtime verifier run more time than the system execution does at each checking round. For example, if the speed of the runtime verification is supposed to be two times faster than that of the system execution, then we make our runtime checker run two times more time than the system execution does. In this way, we can estimate the performance of our model- based runtime verification to some degree.

Compared to the usual (off-line) model checking, our model-based runtime ver- ification can reduce the state space to be explored by using the monitored states obtained while the system is running. On this view, the computational complexity of the model-based runtime verification is less than that of the traditional model checking. Compared to the usual runtime verification, our model-based runtime verification checks the system properties at the model level while just using the monitored states to do consistency checking and then to shrink the state space to be explored. As a result, the computational complexity of the model-based runtime verification is greater than that of the conventional runtime verification. However, if we make our model-based runtime verification look ahead only several time steps at each checking round, then its computational complexity in terms of time and memory overhead will be closer to that of the state-of-the-art runtime verification. In addition, our model-based runtime verification can check more general properties specified by ACTL and/or LTL formulas, since [7] shows that the property patterns to be checked in practice are usually not very complex.

Ideally, we wish that the model-based runtime verification could always run enough time steps ahead of the system execution. However, we have to face the reality that the runtime verification might fall behind the system execution. To deal with this problem, we introduce two checking modes: pre-checking and post-checking. We say that the runtime verification is in pre-checking mode, if the runtime verification runs ahead of the system execution; otherwise, it is in post-checking mode.

In pre-checking mode, the runtime verification can predict violations before they really happen. In post-checking mode, violations can be detected after they have already happened. In fact, the model-based runtime verification can also predict violations even in post-checking mode because our runtime verification checks at the model level. If an error is found at some place in the partial state space being checked but without overlap with the monitored execution trace, then we can predict that the error might happen in the future. In any case, both checking modes are useful for safety-critical systems.

Notice that the model-based runtime verification can observe the actual exe- cution trace of the system once it falls behind the system running. This means that the runtime verification only needs to explore a rather small state space in post-checking mode. Recall that the processing speed of the runtime verification is supposed to be faster than that of the system execution. Therefore, it is reasonable to argue that there still exists chance for the runtime verification to pass over the system running quickly.

On this view, it seems as if the runtime verification and the system execution are involved into a two-player game. In the course of the game, we say that the runtime verification wins against the system execution, if the runtime verification takes the leading position for a longer time than the system execution does. To achieve this purpose, we need to find a better strategy to make the runtime verification have more chance or higher probability to win against the system execution.

Notice that the checking speed of the runtime verification is heavily affected by the out-degrees of the states in the system model. Let d be a predefined upper bound for the out-degrees of the states in the system model. We say that a state is critical, if the number of the outgoing transitions of the state exceeds the threshold d.

Of course, these probabilities might not be very accurate. In fact, we just use them to set an initial order to the outgoing transitions of the critical states. This order will be updated later at runtime. For each critical state si, we order the outgoing transitions of si decreasingly according to the probabilities of these transitions. We then classify the first d transitions as the major transitions and the rest as the minor transitions of si.

Let selected(si) be a set of the major transitions of si. During the checking procedure, each time a critical state is reached, the runtime verification can inten- tionally explore only the transitions in selected(si). In this way, the state space to be checked is reduced to some extent. The runtime verification could thus look ahead further even within a limited time interval. The selected transitions are the major transitions of the critical states, which have higher probabilities than those of the unselected transitions. Thus, the chance is high that the monitored states do fall inside the selectively reduced state space having been checked safe.

Meanwhile, the runtime verification needs to adjust the selected transitions of si. There are different ways to do so. Let deviated(si) be a set of the transitions from si that can reach sj. A way to update the selected transitions of si is to replace some of the transitions in selected(si) with the transitions in deviated(si). Thus, if the runtime verification visits si again, it can intentionally explore the partial state

Suppose that the two concrete states s' and s'' in the system implementation map to the same abstract state s in the system model. If there exist a next state of s' mapping to s1 and a next state of s'' mapping to s3, then we add the extra information a in s' and b in s'' to the transitions (s, s1) and (s, s3) respectively. In this way, whenever s' (or s'') is monitored, the runtime verification can reduce the state space by only selecting the transition with the additional information a (or b). However, adding too much extra information to the system model might increase the complexity of the system model as well as the overhead of the communication between the runtime verification and the system execution. Therefore, we only add the extra information to the critical states in the system model.

Recall that our model-based runtime verification explores the system model even before the current state is known and then shrinks the state space after the current state is known. That is, the progress of our runtime verification is not strictly bound to the execution of the system implementation, i.e., it may run before or after the system execution. As long as the processing speed is fast enough, the runtime verification could keep running certain time steps before the system execution and then tell the system how many time steps ahead is safe. Also, our runtime verification can check more general properties specified by ACTL and/or LTL formulas.

Validation and verification are widely-accepted techniques to ensure the correctness of a system under development. Verification checks the correctness of the system at the model level while validation checks at the implementation level. State-of-the-art runtime verification combines verification with system execution, aimed at checking the consistency of a monitored execution trace against the system specification by passively observing an actual execution trace while the system is running. Notice that in this approach even if the monitored execution trace is checked correct with respect to the system properties, it does not mean that this monitored execution trace really conforms to the system model and the system model satisfies the same properties as well.

As an extension to this runtime verification, our model-based runtime verifica- tion takes the system implementation, the system model and the system specifi- cation together into account. The basic idea is to check at runtime whether the monitored execution trace of the system conforms to the system model on the one hand and whether a partial system model that covers the monitored states satisfies the system properties on the other hand. Due to its working at the model level, our runtime verification can make progress even if the current state of the system running is not observed yet. In fact, the monitored states are used in consistency checking and then used to shrink the state space to be checked by the runtime ver- ification. Therefore, the model-based runtime verification may run before or after the system execution as if there exists a competition between them. In this sense, our model-based runtime verification is more flexible than state-of-the-art runtime verification.

Of course, we have to pay some cost for this flexibility. The computational complexity of the model-based runtime verification is less than that of the offline model checking but greater than that of the state-of-the-art runtime verification. However, our experience shows that it is good enough to have the model-based runtime verification look ahead only several time steps at each checking round, which make its computational complexity in terms of time and memory overhead much closer to that of the state-of-the-art runtime verification.

Shukla, S., D. J. Rosenkrantz, H. B. Hunt III and R. E. Stearns, A HORNSAT Based Approach to the Polynomial Time Decidability of Simulation Relations for Finite State Processes, DIMACS Series in Discrete Mathematics and Theoretical Computer Science, American Mathematical Society 35 (1997).

