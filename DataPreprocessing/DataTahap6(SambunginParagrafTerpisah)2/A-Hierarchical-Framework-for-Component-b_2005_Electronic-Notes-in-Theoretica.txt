In this paper, we describe a methodology for the design and the development of component-based real-time systems. In our model, a component consists of a set of concurrent real-time threads that communicate by means of synchronous and asynchronous operations. In addition, each component can specify its own local scheduling algorithm. We also discuss the support that must be provided at the operating system level, and present an implementation in the SHaRK operating system.

characterization of the quality of service of a component from a temporal point of view. This characterization is especially useful in the real-time domain, where components consist of concurrent cyclic tasks with temporal constraints (e.g. deadlines). In fact, when we integrate all the components in the final system, we must be able to analyse the schedulability of the system (i.e. to check if the temporal constraints are respected).

Lipari, Bini and Fohler [10] presented a model for real-time concurrent components. A component consists of one or more concurrent real-time threads and it is characterized by a demand function that describes its temporal re- quirements. The methodology was later extended by Lipari and Bini [9]. However, in these papers, simplified model is considered in which components can communicate only asynchronously. In this paper, we refine the model of a real-time concurrent component by considering blocking primitives, like syn- chronized methods. We also present an implementation of these techniques in the real-time operating system SHaRK.

The thread model of concurrent programming is very popular and it is sup- ported by most operating systems. In this model, concurrency is supported at two levels: processes and threads. Each process has its own address space and processes communicate mainly exchanging messages by means of operat- ing system primitives. Creating a process is an expensive operation because it involves a lot of steps like creating the address space, setting up the file descriptors, etc. Moreover, context switch among processes is an expensive operation.

A process can be multi-threaded, i.e. it can consist of several concurrent threads. Different threads belonging to the same process share address space, file descriptors, and other resources. Since threads belonging to the same process share the address space, the communication is often realized by means of shared data structures protected by mutexes. Creating a new thread is far less expensive than creating a new process. Also, context switch among threads of the same process is faster. The thread model is supported by all general purpose operating systems because it has a lot of advantages with respect to the pure process models. The designer of a concurrent application can design the application as a set of cooperating threads, simplifying the communication and reducing the overhead of the implementation.

Classical hard real-time systems usually consist of periodic or sporadic tasks that tightly cooperate to fulfill the system goal. For efficiency reasons, they communicate mainly through shared memory, and appropriate synchroniza- tion mechanisms are used to regulate the access to shared data. Since all tasks in the system are designed to cooperate, a global schedulability analysis is done on the whole system to guarantee that the temporal constraints will be respected. There is no need to protect one subset of tasks from the others. Therefore, we can assimilate a hard real-time system to a single multi-threaded process where the real-time tasks are modeled by threads.

operating systems we have to take into consideration multi-threaded program- ming. According to the multi-thread model, in this paper we assume that real-time tasks are implemented as threads, and a classical real-time applica- tion as one single multi-thread process. Therefore, a real-time application is a process that can be multi-threaded, that is, it can consists of many real-time tasks. In the remainder of the paper, we will use the terms thread and task as synonyms. The same for the terms application and process.

Nielse and Agha [14] propose to further constraint a component in order to separate the functional specification from the timing constraints. For example, a component is not allowed to specify the scheduling policy, nor priorities or deadlines. The timing constrains are specified separately and verified after integration. In contrast, in our work paper we explicitly allow components to specify their own scheduling policy.

Stankovic [21] proposes a tool set called VEST that allows the construction and the analysis of component based real-time systems. Again, a component is not allowed to specify its own scheduling algorithm. Moreover, a failing component can influence the behaviors of all other components in the systems, since there is no temporal isolation between components.

Recently, many techniques have been proposed for extending the resource reservation framework to hierarchical scheduling. Baruah and Lipari in [8] propose the H-CBS algorithm, which permits to compose CBS schedulers at arbitrary levels of the hierarchy. The H-CBS is also able to reclaim the spare time due to tasks that execute less than expected according to the hierarchical structure. However, the only scheduling algorithm permitted at all levels is the EDF algorithm. A similar work has been done by Saewong et al. [19] in the context of the resource kernels. They propose a schedulability analysis based on the worst-case response time for a local fixed priority scheduler.

This blocking time has to be taken into account for checking the performance of the component. If the blocking time is too long, some deadline could be missed. In the next section, we will briefly describe a methodology for com- puting such blocking time.

In this section we discuss the basic mechanisms to be provided by the op- erating system to support our methodology. These mechanisms have been implemented in the SHaRK OS [3], an open source real-time kernel. A brief description of the implementation is given in Section 6.

There is no way to solve this problem. If two components interact through synchronized operations, there is no way to separate the temporal behavior of the two. Therefore, we need to take this blocking time into account during the integration phase. Our analysis is detailed in the next section.

We now apply the methodology described in [9] to compute the server budget Qi and the server period Pi for each component. Actually, there are many possible values for Qi and Pi. We chose one possible value according to some heuristics. For example, in general it is convenient to assign a period that it the largest possible, to reduce the overhead of context switch.

SHaRK (Soft and Hard Real-time Kernel) is an open source real-time operat- ing system [3] designed for modularity and extensibility. It has been developed over the years as a kernel for didactic purposes. The goal is to teach how to implement new scheduling algorithms on a real-time system, and to compare the performance of different scheduling algorithm. For these reasons, SHaRK allows programmers to define their own algorithm.

The structure of SHaRK is based on the concept of module. A module is a small component that provides an interface toward a generic scheduling mechanism and an interface to the threads. Every thread, upon creation, is assigned to a module. Modules are organized on a pile, and each module is assigned a unique order number.

For each component (application), a dedicated module implements the lo- cal scheduling mechanism. Each module implements the local scheduling strategy. It communicates with the CBSSTAR scheduling module to select which thread has to be scheduled when a certain component is selected to execute.

In this paper, we described a methodology for the design and the development of component-based real-time systems. Unlike previous proposals, we propose a model of a component consisting of a set of concurrent real-time threads plus their scheduling algorithm. Therefore, we can compose components with different temporal constraints and schedulers. After describing the model of the component, we described the support needed at the operating system level. Moreover, we present the implementation of this framework on the SHaRK operating system.

