A simple, easy-to-trust analysis checker verifies the validity of the infor- mation on the mobile code. It is indeed a specialized abstract interpreter which does not need to iterate in order to reach a fixpoint (in contrast to standard analyzers). Efficiency is achieved by taking advantage of the analysis information gathered in a previous analysis phase.

guage which is used to define our safety policy. Section 3 presents the certi- fication process together with the generation of the verification condition to attest compliance with the safety policy. In Section 4, we outline the process of checking the validity of the safety information. Finally, Section 5 discusses the work presented in this paper together with related work.

The purpose of a safety policy is to specify precisely the conditions under which the execution of a program is considered safe. In existing approaches, safety policies usually correspond to some variants of type safety (which may also control the correct access of memory or array bounds [14]). We propose the use of (a subset of) the high-level assertion language [15] available in CiaoPP to define the safety policy in the context of constraint logic programs.

Example 2.2 In the context of mobile code, it is a safety issue whether the code tries to access files which are not related to the application in the machine consuming the code. A very simple safety policy can be to enforce that the mobile code only accesses temporary files. For example, in a UNIX system this can be controlled (under some assumptions) by ensuring that the file resides in the directory /tmp/.

The regtype declarations are used to define new regular types in CiaoPP. In fact, auxiliary predicates used to define a regular type, like alphanum code, alpha code, or num code must be declared using regtype as well. The con- struction member(C,"0123456789") is a shortcut for expressing that C can correspond to any of the codes in the list from character 0 to 9.

The coexistence of different domains in CiaoPP [7] allows expressing a wide range of properties using the assertion language. They include modes, types, non-failure, termination, determinacy, non-suspension, non-floundering and cost bounds and their combinations. This idea is related to the notion of models addressed in the work on Model-Carrying Code (MCC) [18] to capture the security-relevant properties of code. MCC enables code consumers to try out different security policies of interest and select one that can be statically proved to be consistent with the model associated to the untrusted code. In our framework, the coexistence of different domains recalls the existence of various models in MCC. However, models are intended to describe low-level properties and their combination has not been approached, which differs from our idea of combining (high-level) abstract domains.

In contrast to other approaches, assertions are not compulsory for every predicate. This is important since assertions have to be provided manually. Thus, the user can decide how much effort to put into writing assertions: the more of them there are, the more complete the partial correctness of the program is described and more possibilities to detect problems. However, pre- and post-conditions are often provided by programmers since they are often easy to write and very useful for generating program documentation.

internal predicates. Nevertheless, they can still be automatically generated by assuming T as the abstract substitution (i.e., no initial information is given) for all exported predicates. Although the idea is to improve this information by means of the initial calling patterns.

i) the VC is indeed checked, as it happens in the above example; ii) it is disproved, and thus the certificate is not valid and the code is definitely not safe to run (we should obviously correct the program before continuing the process); iii) it cannot be proved nor disproved, which may be due to several circumstances. For instance, it can happen that the analysis is not able to infer precise enough information to verify the conditions. The user can then provide a more refined description of initial calling patterns or choose a different, finer- grained, domain. In both the ii) and iii) cases the certification process needs to be restarted until achieving a VC which meets i).

After certifying the safety of the code, the supplier sends the program together with the certificate to the consumer. To retain the safety guarantees, the consumer can trust neither the code nor the certificate. Thus, in the validation process, a code consumer not only checks the validity of the certificate w.r.t. the program but it also (re-)generates a trustworthy VC. This section describes only the former part of the validation process, since the latter is identical to that already discussed in the previous section.

The idea of using the results of abstract interpretation for program verification and debugging is not new. For instance, a dataflow analysis applied to a type- level abstract interpretation of the Java virtual machine is the basis of all existing bytecode verifiers [11,10]. Analysis results allow proving that the program is correct w.r.t. non-trivial correctness conditions. This is also the case in CiaoPP, whose combination of abstract interpretation with a flexible assertion language opens the door to many uses of abstract interpretation for program development.

In this paper, we have introduced a novel approach to mobile code safety which follows the standard strategy of associating safety certificates to pro- grams, proposed by PCC and related techniques, but which is based through- out on the use of abstract interpretation. In particular, it differs from PCC in the following aspects. In our case, the burden on the consumer side is reduced by replacing an analysis phase with a simple one-traversal abstract interpretation-based checker. The certificate takes the form of a particular slice of the analysis results generated by an abstract interpreter. The cer- tificate checker on the consumer side is itself in fact a very simplified and efficient specialized abstract-interpreter. The importance of our definition of the checker comes from the fact that, while abstract interpretation is a pow- erful technique, in return it is not without cost: the results it provides are guaranteed to be correct and often sufficiently precise in order to be useful, but obtaining analysis results is a costly task, mainly due to the fact that an analysis fixpoint has to be reached. The checker that we have proposed, on the other hand, greatly reduces the cost on the receiving side.

expect that a relatively large amount of untrusted source code is available to the consumer. Part of our interest in open-source is due to the fact that Ciao is itself a GNU-Licensed Prolog System based on the availability of the source code for its reviewing and modification. The advantages of open-source with respect to safety are important since it allows inspecting the code and applying powerful techniques for program analysis and validation which allow inferring information which may be difficult to observe at low-level, compiled code. This enables handling more involved properties which in turn allow more expressive safety policies. Therefore, we share with PCC the idea of reducing the load in the consumer but our method is somehow applied in a different manner.

