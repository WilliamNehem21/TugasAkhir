ocl is intended to be a formal specification language. It is used for adding precision that uml models lack. Its omg standard [15] defines the syntax of the language, and, to some extent, its semantics. However, despite many academic works on ocl (some of which are referenced in the Related Works section) there is curently no commmercial tool that offers full support for it.

Part of the problem is the standard, which is imprecise, incomplete, and flawed in some places. This is common to many languages for which the semantics is informally described in manuals declared as standards (see, e.g., the definition of C [9]). Some of these problems include the nondeterministic cast operations from unordered to ordered sets and bags, the question of whether a singleton set {a} and the set element a should be distinct or not (answered differently in different pages of the standard [15]), and issues due to the presence of an invalid value.

The rest of the paper is composed as follows: Section 2 provides some background on uml, ocl, and the K framework. In Section 3 we present our K definition of ocl and illustrate it on examples. Section 4 concludes and discusses related and future work . An online tool implementing our definition is available [1].

The annotated grammar of our K definition of ocl is shown in Appendix A. We currently support the usual integer, real, and Boolean expressions (including Boolean expressions with quantifiers) ; strings and concatenation; collection expressions, including navigation, and iterators; and other expressions (e.g., let-in, if-then-else). Since the K definitions are modular, we may add new expressions without changing the old ones. Note that ocl is an evolving language and the K framework can help in experimenting the new constructs introduced in the language.

Hence, expressions of the form A /0 are not reduced by the above rule to a legitimate ocl value (here, an integer). Such expressions model the invalid value of the ocl standard [15]. The advantage of our definition with respect to the standard is that we do not need to give explicit rules saying how the invalid value is propagated: expressions that contain an undefined value (i.e., a subexpression that is not reduced to a value) are also undefined, because they are not reduced to a value.

K. One of them is the substitution operator, which is actually implemented in K itself using a visitor pattern [22]. We shall come back to the substitution operator later in this section when we define the semantics of the let-in expression and compare it with the corresponding semantics in the ocl standard [15]. The other K mechanism we use extensively here is the automatic generation of rules that evaluate arguments of strict operators.

Related Work  We have already mentioned the informative Annex of the ocl standard [15]. Despite its shortcomings, mainly due to numerous typos, the Annex is based on solid formal ground - set-theoretical foundations [19]. We do not know of formal tools implementing the set-theoretical semantics of the ocl standard.

