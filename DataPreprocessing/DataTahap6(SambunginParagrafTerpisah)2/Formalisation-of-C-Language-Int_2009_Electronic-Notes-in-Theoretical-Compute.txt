In practical computing, implementations of programming languages provide an interface that allow programs written in a language to call code written in another programming language, most often C. Usually, those language interfaces are left out of the formal definition of the language, and reasoning about multi-language programs is very difficult due to the lack of precise specifications for the language interfaces. In this paper, we present an application of a framework for the interoperability of programming languages, in which we specified in a systematic way the C interface of a real, rule-based programming language. Our framework is based on simple combinations of the small-step operational semantics of programming languages. We give the main elements of a small-step semantics for the C programming language that can be used to specify the same kind of interfaces for other programming languages implemented in C.

A very important aspect of the actual global society is the free access to informa- tion from anywhere in the world. It makes easier the exchanges and the agreements between individuals and enterprises, which can decide to work together in order to carry out their respective goals. Computing systems must adapt to those environ- ments, and a non negligible task for software developers is to adapt the existing systems to make them work together, that is, to make them interoperate.

In this paper, we present the formal definition of a C interface for a real, rule- based programming language, Russel [4]. This is an application of the conceptual framework for programming languages interoperability defined in [9][10], which is based on the combination of the small-step operational semantics of interoperating languages. We present the difficulties to reason about mixed Russel-C code, because of potential side effects of the C code on the Russel implementation. Our framework overcomes those difficulties by a precise description of how inter-language calls affect the execution in both sides of a Russel-C program, and we can still use the reasoning mechanisms given by the original semantics of Russel and C.

The essentials of our programming language interoperability framework are shown in next section. Then, we present the main elements for a complete op- erational semantics of C, and especially its memory model. Afterwards, we show the application of our framework to a description of a C interface for a real program- ming language, and we give some directions for our further work before concluding.

Interoperating programs can be executed by different processes in the same machine or in different machines, or by a unique process. The later case is proper to C interfaces, where both C code and language code are compiled into the same object language. In [9][10] we mentioned three kinds of information exchange that can be supported by a FLI for each execution context.

At this time, we have built two operational semantics for languages A and B with no relation between each other. In such case, we say that A and B are at the same level of abstraction. Concretely, this means that implementations of A and B are independent, and without any interoperability, there is no way to affect the execution of a program written in A by a program written in B.

as the set of environments. There are two kinds of environments: the global environ- ment, used for global variables, global arrays and all the byte string constants de- fined by the program; and local environments used for local variables and arrays de- fined locally in a function. The global environment is created by the makeGlobalEnv operation, which takes a C store and the sets of global objects declared in the pro- gram and returns the global environment and the C store with the memory zones allocated for those objects.

Here is an example of a Russel program fragment containing a rule that counts the failed logins recorded on the audit trail where records have the fields evt and res. When the number of failed logins exceeds the number passed in the rule parameter, a global variable toomany is set to 1. Notice that this code does not use any call to a C function.

Informally, we can describe the execution of a Russel program as follows. The program reads the first record in the audit trail, and an initial action is executed. That initial action triggers rule instances to be effectively executed either for the current record, for the next record, or at the end of the audit trail. When all the actions are executed, the program selects randomly another triggered rule instance for the current record and executes its respective action. When all triggered rule instances for the current record are executed, the program reads the next record and takes the rule instances which have been triggered for that record. When all records in the trail have been read, the program takes the triggered instances for the end of the analysis.

Calls to C functions from Russel programs are made with annotated expressions, which indicate how the Russel data is effectively passed to the C program. Single Russel expressions are passed by value. An annotated expression ref v means that the Russel variable v is passed by result, that is, a Russel value will be assigned to v after the C function returns. The C programmer must ensure that a value respecting the type declaration of v is effectively built and put in the corresponding parameter, as we will precise in the next subsection.

