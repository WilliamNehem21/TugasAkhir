In this paper, an LQN performance model of a Linux Apache-PHP web appli- cation with PostgreSQL backend-database is presented. The solution of the model provides performance metrics such as steady-state throughput and response times. The model results are compared with measurement results derived from load testing the system for model validation. The analysis of the model results is provided and includes identification of the bottleneck resource with mention of an approach that would scale the system by avoiding the bottleneck resource saturation early.

The paper is organized as follows: Section 2 lists related works in the area of web performance modeling. Section 3 gives a brief overview of LQN. Section 4 provides the design details of Web Application. Section 5 describes the Load Testing setup. Section 6 presents the LQN model of the application. Section 7 presents the measurements and model evaluation results with further analysis to ease bottleneck resource. Section 8 presents the conclusions and future work.

Liu et al. [27] describe a closed QN model of a 3-tiered web application com- prising of Apache Web server, Tomcat Application server and MySQL Database server. To model the concurrency limits such as maximum number of concurrently running threads/processes of Apache and MySQL servers, multi-station queues are used.

Also, similar to our work, Dilley et al. [22] and Pastsyak et al. [2] have used LQN to model a CGI Web server and an Apache-PHP-MySQL system, respectively. The CGI Web server model [22] incorporates serving of both dynamic and static contents by the server, however no database tier is considered in the study. The re- sponse time from the model evaluation is found to match closely with response time measurements over a period of two months. Measurement data collected through custom instrumentation serve as input parameters to the LQN model and are also used for model-validation. The web system LQN model by Pastsyak et al. [2] is evaluated for 40 users and compared with the load test results, which show the successful prediction of performance by the model. The system consists of two Web servers, a Load balancer and a Database server. Other performance modeling for- malisms such as Stochastic Process Algebra (SPA) and Stochastic Petri Nets (SPN) have also been evaluated in this paper.

ing of pre-rendered map tiles/images residing on the server. PostgreSQL database functions as the storage facility of the bike routes data and provides best path rout- ing features, where the routing functionality is made available by the pgRouting 4 project [12]. For displaying bike routes data or for route-search, OpenLayers at client-side basically communicates with the PostgreSQL backend-database through an Apache-PHP server.

MyBikeRoutes-OSM derives from the MyBikeRoutes 5 web application [13], which is functionality-wise similar but an online web replica of its derivative project. The apparent difference is the use of mapping services from Google Maps API 6 [14] to display Google Maps and route information by MyBikeRoutes website, where the bicycle routes data is housed in a MySQL backend-database. Furthermore, the best path search on the MyBikeRoutes site actually uses bike routes for the search. Here the client-side JavaScript interacts with Google Maps API, whereas the MyBikeRoutes-OSM project uses pgRouting at the Database server layer to provide the search functionality.

For the other longer queries, i.e. the two routing searches, the viewing routes query, and the two insertion of new routes queries, JMeter tests with one user load and no think time were run for a duration of 900 sec. Applying Utilization Law, and following similar calculations as for Example1 the service demands were found.

In this section the performance metrics obtained from the model evaluation are pre- sented along with the measurements in both tabular and graphical formats for model validation. Based on the results the performance objective for the Base-Scenario is defined. Furthermore, performance analysis is done to achieve performance objec- tives.

The model evaluation has been carried out for up to 150 users. This number was chosen because the AppServer task multiplicity is set to 150, which signifies the maximum number of running Apache processes. The model was evaluated on a dual Intel Xeon 3.0 Ghz CPU with hyper-threading enabled, running on 2 GB of RAM. Taking an average of 10 runs for 120 users case, the Base-Scenario model was solved in 376ms while utilizing 47% of CPU.

The above results are helpful but they show that web application will not be able to support large number of users at satisfactory response times, showing poor performance. Based on the functionality provided by the web application, a reason- able performance objective is to sustain 40 to 50 users with a session response time of 12 seconds without think time. Considering such as objective, the web appli- cation performance has to be improved. Through previous analysis the bottleneck resource has already been identified to be pApache CPU. Next, we use intuitive modifications to the model such that performance objectives are met.

To achieve performance objectives, designs that ease the bottleneck have to be determined. From previous analysis it is found that the pApache server is the bot- tleneck for the MyBikeRoutes-OSM web application. To scale the system, options include adding threads, using a multi-processor system or using copies (replicas) of the server [20]. Since the bottleneck is hardware, addition of threads of AppServer task or the DB task will not be helpful. We evaluate the performance model for two possible solutions: (i) Multi-processor machine and, (ii) Separating AppServer and DB task into separate identical machines. Following are the details of the modifications:

Multiprocessor pApache: The models have been evaluated for processors with multiplicity of two and four, which are referred as Base-Scenario-m2 and Base-Scenario-m4 models respectively. (Note that LQNS did not support PS scheduling for pApache multiprocessor. For two and four multiprocessors, First Come First Serve discipline was used).

Separate machine for Database: Instead of having both Application and Database software servers run on the pApache machine, the database-tier can be deployed on a separate and identical machine. The changes to the model include creating a new pDB processor which will be hosting the DB task and its entries while the Disk2 task on pDisk2 will now handle the disk I/O for the DB task. The previous pDisk is renamed as pDisk1, and the Disk task is renamed as Disk1 which will handle disk I/O for AppServer. The model will be referred as SeparateDB-Scenario. There are two assumptions made for this model. One is that service times for the disk I/O is divided by two to derive the service times of each entries of Disk1 and Disk2 tasks. Second, no network delay between the pApache and the pDB machines are considered. In a LAN environment the delay would not be very large, however, for very detailed study significant delays should be considered.

