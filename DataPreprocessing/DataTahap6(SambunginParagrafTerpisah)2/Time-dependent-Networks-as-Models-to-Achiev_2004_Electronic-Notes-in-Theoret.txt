The key idea in a time-dependent network is that the time-delay of a link depends on the point in time the link is used. This model is natural in several other situations, for example data-packets on the Internet or cars on a road network. This models the phenomenon, that the delay a link induces depends on the path that is used to reach this link. In general shortest path questions on such networks are hard to answer, but important special cases allow for fast algorithms. These kind of networks have been considered in the literature, see for example [7,8] for a survey. The use of this type of modeling for routing passengers is described in [1], where the focus is on travelers using cars on the road network.

In [11] the authors address the question, whether it is feasible to compute optimal itineraries for the German railway system. This question is also the example in [12]. They propose several heuristic running time improvements that allow for sufficiently quick answers. Our modeling is compatible to these heuristics, they can immediately be applied in the time-dependent algorithms as well. We expect that our modeling and algorithmic approach will lead to significant running time improvements that allow for a bigger or more detailed network (including local busses, extending to all of Europe). For our lack of real world data the analysis of our approach is a theoretical comparison against [11]. The modification of the network considered in [12] also modifies only the station-aspect of the used graph, our algorithms proposed here can easily adopt the speed-up techniques of [12].

Some simple calculation about problem sizes and modern hardware shows that it can be feasible to precompute the answers to all possible queries and store the result on a hard-disk. If the network size allows this, it can be a viable alternative to an algorithmic solution. This should be the case if the network is not too big. Of course this approach still needs to find fast itinerary in a preprocessing step.

We assume that we have a set T that represents time, like the real numbers, the integers (e.g. seconds since 1.1.2000), or the set {0:00, 0:01,..., 23:59}. We only assume that we have a total ordering of the elements in T. Sometimes we additionally assume that there is an addition operation defined over T.

These definitions have some severe restrictions. At a station we can not distinguish between continuing in the same train and transfer. We also dis- allow the traveler to use any other means of transportation like walking 200 meters from one station to another. In Section 5 we will address these is- sues, allowing us to impose restrictions on the maximum number of transfers or accounting for the time it takes to walk inside the station as part of a transfer.

Be aware that there are some obvious alternatives to this model. For example, one could deviate from the cycle of edges at one station and explicitly have an edge if a passenger can actually change trains as suggested by a combination of arrival/departure events. This model uses in general a lot more edges, but it allows for a much more detailed modeling. We could for example make sure that the walking inside the station actually allows the transfer.

In this section we develop the terminology for time-dependent networks (or graphs, which is precisely the same) and proof the correctness of a fastest path algorithm, that works in the situation we have here. We omit a discussion of the feasibility of shortest path questions in the more general setting, allowing negative delays and/or non-monotonic functions. In this more involved set- ting, it is important to specify a waiting policy. See [7,8] for a discussion of this type of network.

The domain of time is a linearly ordered set T. In this section we do not assume that there is an addition operation defined on T. Typical examples for the set T are the real numbers and the integers, but also finite sets are interesting.

The earliest arrival question for a source node s, a destination d, and a departure time t asks for a timed path p from s to d of which the arrival time is minimal. Similarly the latest departure question is well defined if we fix an upper bound for the arrival time, i.e. we ask for a path that has the latest departure time at s under the constraint that the arrival time is not after the specified arrival time.

Let I be an itinerary. Then we find a timed path p in G that is never later at a certain station than I is. The path p is therefore a timed path that does not arrive later at the destination than I does.

One well known potential technique is to modify the value that is used in the priority queue by a lower bound on the remaining path-length to the destination. If the network is embedded into the plane, this can be an ap- propriate multiplicative of the Euclidean distance to the destination. One way to convince oneself about the correctness of this method is to think of modifying the edge weights of the graph according to some potential, i.e.

Another, more direct way to reduce the size of the inspected part of the graph is to remove edges and nodes that are not relevant, i.e. not on a shortest path for the current s and d. In the extreme, again, we might have precom- puted a shortest path for all possible choices of s and d, and stored the resulting path. Now we can on the fly disregard all the edges that cannot be on the current path. The algorithm will then only explore the path itself. Again, in this situation there is no need to run an algorithm anymore. The interesting versions of this method are those where we do not need a lot of memory to store the result of the precomputation, and where evaluating whether a link can be disregarded is easy. A good example is the pruning technique used

Here we do not consider the time the algorithm spends maintaining the priority queue. There are several results in the literature discussing how to obtain fast priority queues in this context, for example using the fact that edge weights are integers. This kind of priority queue can be used for the time- dependent networks as well, if we restrict time to be integers. We note that even a more substantial change to the shortest path algorithm as proposed in [5] can easily incorporated into the time-dependent algorithm.

If we take a modular approach, we will implement the link-traversal functions completely independent of each other. That is, we will have a procedure that produces the value fuv(t) given t. This can easily be achieved with log2(k) comparisons if k is the number of connections from u to v, i.e. k = |Cuv|.

Let d be the out-degree of the node in the time-dependent network correspond- ing to a. To avoid the space-overhead, we can put all the outgoing events of a station a into one array A sorted by their departure time. We can do this in the following way: we place d such events (so called primary entries), then we leave d empty spaces, then the next d events, and so on. Let t'' be the time of the last event before some empty spaces. Then we put for every outgoing direction the next event after t'' into the so far empty entries of A (secondary entries). We put all primary entries into one balanced search tree.

Even so the last presented algorithm is the fastest algorithm if we consider asymptotic worst-case running time on the unit cost RAM, it might not be the fastest in practice. One thing is that the possibility to save constant factors in the running time is hard to foresee and an important factor in actual running time. More importantly we should also consider that the running time on a real machine can be heavily influenced by cache-faults. In this respect the last algorithm might not really be a good idea: It could lead to one cache miss for every item we place in the priority queue, whereas the lookup in the list could use the locality of the used entries. If additionally the the priority queue is small enough to fit into cache, we would expect the list-lookup to be faster.

Instead of using an array with primary and secondary entries we can consider the list of next events as a persistent linked list that (in the preprocessing) changes as time progresses. See [4] for details on this idea. This construction gives the same asymptotic behavior. It has the additional advantage that it can easily carried over to the exploration saving idea of Section 4.6.

The algorithmic problem discussed so far made the unrealistic assumption, that transfer between trains is assumed to take no time and no cost. It seems, that we do not get a more realistic modeling of transfer for free. For a start we try to include some time for the walking inside the station in the itinerary, extending the network by as little as we can. We consider every platform to be a station of its own right. Then we connect the platforms by walking links, either following the geometry of the station or with a star to the concourse of the station. The link traversal functions for the walking links have constant delay, i.e. they are of the form f (t) = t + c for some constant c that reflects the walking distance. (This assumes that we have addition for our set T.)

The above modeling of train changes can also be used to count the number of changes. Without extending the network further we do not consider a change of trains, if it does not involve moving from one platform to another. If we want to be more precise, we can introduce virtual platforms, one for every train-line. Then we do not capture changing of trains within a train line, which is no restriction, as it can always be avoided. Note that we basically return to the explicit network if every train has to be considered as a train line of its own.

