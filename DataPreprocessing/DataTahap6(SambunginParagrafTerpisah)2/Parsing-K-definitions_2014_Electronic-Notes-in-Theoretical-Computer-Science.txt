This paper describes our approach in parsing a K definition. The difficulty of the problem is given by the nature of the K-framework, where the user can define the operational semantics of a language by inserting pieces of concrete syntax in the K code in a natural way. Our main contribution shows how to make use of SDF and the disambiguation mechanisms in the context of K-framework.

K-Maude [15], the current tool supporting K, proved to be quite scalable and applicable to real world programming languages such as Scheme [17], Verilog [16], Java 1.4 [8] and C [7] (with others underway). However, since K-Maude relies on the Maude parser to parse K definitions, there are cases when new definitions intro- duce ambiguities. Moreover, in order to be translated in Maude, these definitions need to be syntactically correct; therefore it is preferable to have a parser able to handle K definitions. The design of such a parser is an intricate task because the K definitions are quite complex, combining K syntactical constructs with fragments of syntax from the defined language. After several experiments we quickly ruled out parsers that use a scanner before the parser because they do not offer the generality of parsing different styles of programs embedded into one another. The solution came in the form of SDF [9] and its scannerless generalized parser. We generate several parsers for different purposes: one to extract the syntax declarations from a definition, another one is used to parse programs, and the last is used to parse the semantic rules (this is the most complex as it must handle constructors from two languages at the same time).

This paper is divided into 6 sections where in Section 2 we introduce a repre- sentative example to demonstrate the main problem that we are trying to solve. Following in Section 3 we present an abstract view of the chosen solution as a way of dealing with ambiguities in languages that embed other languages. Section 4 provides a more in depth view of the technique used and explains some of the de- tails that lead to the chosen method. Some tools that have similar solutions are presented in Section 5.

variables to values. We initialize them with empty (identity) elements. In general the cells can have one of the five main syntactic categories (or sorts) used in K: K, Bag, List, Set and Map. The sort K is considered special as it can be extended with new syntactical constructs from the defined language and it is mainly used to match on computations.

The back-end of the K tool is designed to accept K definitions represented as a collection of abstract syntactic trees (ASTs). An AST is the collapsed representation of the parse tree resulted after parsing a text. Working with the AST makes handling the input a lot easier as the unnecessary information is eliminated in the parsing process (e.g., white spaces and comments - which have no semantic meaning to the language). To obtain the AST we need a tool able to parse definitions as above, solve the ambiguities, infer the types for each construct and transform them into pure K definitions (using ASTs) like the following one:

The current implementation of the K-tool [15] has a front-end that transforms an annotated BNF definition of a language into a Maude [4] module which is later used to parse the K rewrite rules. This solution often leads to ambiguities because of mixfix operators and the preregularity property that needs to be satisfied by the ordered sorts. The biggest downfall was the lack of support for solving the ambiguities and conflicts provided by Maude.

The embedding of language constructs in the K syntax is done with the help of the sort K. In fact this is the place where the name of the technique comes from. A term of sort K represents a computation which from a parsing perspective is a language construct. For the rewrite rules we also need meta-variables, which can take the place of non-terminals in syntactic constructs. In practice, putting all of these together is tricky because we want to offer the user easy access to the concrete syntax but also maintain the sanity of the definition.

The chosen method is similar to the one used in ASF+SDF [19] in the sense that we add new transitions to connect the grammar of K and the grammar given by the user. For each non-terminal X defined by the user, we add two new produc- tions: X -> K and K -> X. This technique will allow the flexibility of matching the syntactic constructs in contexts that normally would not be allowed by the type system. The idea is to allow the user to write rules as he/she would write the AST representation, but with the convenience of concrete syntax (mixfix form) which in some cases can be more intuitive than writing the constructor. Details about how this is being solved are presented in Section 4.2.

The K syntax declarations are a rearrangement of the SDF syntax to be closer to the BNF style. It starts with the keyword syntax, an identifier specifying the sort of the constructs and a list of production rules. The list of production rules can be separated by ">" to specify that productions in the left hand side have a higher priority than the ones in the right. Inside a priority block there can be specified other productions separated by "|" and will be considered to have the same priority. Syntactic productions and blocks can be annotated with the typical SDF dis- ambiguation filters: left, right or non-assoc. Also the prefer and avoid non-

The third step from the above list generates a grammar similar to the one for programs. The difference is made at step four, where we add transitions to and from sort K. These will allow the user to insert and replace parts of code from the users language. To stop the parser from entering an infinite cycle, we will limit their use with the priority system (see: [19]).

The second step is the list of constructors and the original sort. For example the Exp "*" Exp -> Exp {left, cons("C1Syn")} construct will generate the fol- lowing term: ("C1Syn", "Exp", ["Exp", "Exp"]). This information is used in the second type checking filters presented in Section 3. The exact details will be presented in the next section.

This step is responsible for connecting all of the steps previously described, thus becoming the most complex one in the front end. Firstly, the grammar described in Section 4.2 is compiled into a new parser that can recognize the K definition.

The sort of a term is the most general sort that the term can be represented by. This information will be used later to disambiguate the cells in rules. From the AST obtained at this step, the K Intermediate Language will be generated in the form of XML.

Secondly, this section describes the method of parsing the rules. This is the most difficult part to get right because here can be found the most complex combinations of K syntax and user defined syntax. This is why the parser after this step will return an Abstract Syntax Forrest, that will be processed afterwards. The disambiguation filter is composed out of four main steps (introduced in Section 3):

One of the newest tools that uses syntax definition and rewrite rules that match on concrete syntax, is Rascal [11]. This tool is the continuation of the ASF+SDF tool set and is based on similar theory when it comes to syntax definition. The program transformation is a bit different, as it is based on customizing visitors. This solution allows for more control, but loses conciseness.

This work started because of the need to replace the K-Maude tool, currently used to parse K definitions. After comparing different parser generators, the most promis- ing solution turned out to be SDF and its generalized parser. Having the possibility to write modular grammars, allowed us to integrate easily the two grammars in dis- cussion (the K grammar and the defined language grammar). Because the downside of the context-free declarative grammars are ambiguities, special procedures needed to be developed to cope with the nondeterminism of the parsing step (most of these problems are generated because of the integration method).

complexity of a K rewrite rule. The second step is to parse the entire definition and get a parse forest. The last step is necessary to filter the unwanted parsing possibilities. The final result should be a clean AST that represents the intended definition and which can now be used in the next steps of the compilation, towards a rewrite engine.

Because SDF has a very good connection with Eclipse with the help of Spoofax, future work in this direction includes a user friendly interface that will speed up the editing and testing phase. We are also working towards giving more intuitive error messages. This involves working with more permissive grammars that accept a bigger language, but with more complex disambiguation filters can reach the same result.

