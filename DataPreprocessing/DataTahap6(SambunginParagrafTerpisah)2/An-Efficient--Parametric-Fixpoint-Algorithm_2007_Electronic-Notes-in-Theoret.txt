1 The authors would like to thank Samir Genaim for useful discussions on the topic of the paper, as well as the anonymous reviewers. The authors are supported by the Prince of Asturias Chair in Information Science and Technology at UNM. This work was also funded in part by the Information Society Technologies program of the European Commission, Future and Emerging Technologies under the IST-15905 MOBIUS project, by the Spanish Ministry of Education under the TIN-2005-09207 MERIT project, and the Madrid Regional Government under the PROMESAS project.

sis. This program transformation includes a certain level of decompilation of the bytecode which recovers part of the original code structure lost in the bytecode rep- resentation. Our decompilation process is based in part on existing tools [23,35] to which we add a number of steps (normalizing the intermediate representation which is actually analyzed, representing different classes of statements in a unified way, automatically introducing relational information between initial and final states on methods calls, etc.) which we argue greatly simplify the burden of designing new analyses and abstract operations. While not the subject of this paper, the algorithm can also be applied to Java source code, applying a similar transformation.

Java programs rely heavily on libraries and analysis thus usually expands to many imported classes. Thus, modular analysis is definitely an important issue in this context. However, and in order to concentrate on the description of the fixpoint algorithm, we will not deal with modular analysis issues in this paper. Instead, we assume that methods exported by libraries are annotated in an assertion language that describes which output abstract states are provided for certain input abstract states (we use a particular assertion language based on [28] but adapted to resemble the Java Modeling Language [16], however we omit also a detailed description of this assertion language from the description for brevity). A solution for modular analysis in the context of Java can be found for example in [27], and, more specifically relevant to our algorithm, in [4,7].

A particularly useful and efficient way of controlling the interpretation process is to follow a top-down strategy starting from the program main entry point and an abstraction of the input data (or a topmost value, if such abstraction is not avail- able). The top-down strategy proposed implicitly creates a graph during analysis where nodes (statements) with several descendants correspond to branches in the concrete execution (conditionals, virtual calls, loops), all of them abstracted as invo- cations of OR-tuples. Nodes with one descendant indicate serial execution and are abstracted by recursively applying the process to the child node. More precisely, an invocation is an OR-node whose children are the bodies of all the OR-tuples whose signature matches that of the call, and each body is an AND-node where the semantics of each statement (possibly containing further OR-nodes) are composed.

Note that precision can be further improved if, for example, the abstraction cap- tures the run-time class of the objects invoked. Our solution to this issue makes use in the implementation of object orientation by allowing specialization of the base framework through subclassing. For the particular example in hand, domains con- taining class analysis information [1,10] would just overwrite the implementation of the comp predicate in order to obtain smaller sets of candidate methods to analyze. In addition to the points above, there is one more issue that needs to be ad- dressed. The overall abstract interpretation framework scheme described works in a relatively straightforward way if the (transformed) program has no recursion (i.e., there are no loops or recursion in the original bytecode). Consider, on the other hand, a recursive OR-tuple. If there are two OR-nodes for the tuple in the tree such that the actual parameters apars and input state CA are identical, and one node is a descendant of the other, then the tree is infinite and analysis does not terminate. In order to ensure termination, some sort of fixpoint computation is needed. This is the subject of the following section.

Space limitations obviously prevent us from showing the entire process in detail. We will instead assume that the starting program point for analysis is right before the call to append in the Vector implementation of add. Note that the method creates a vector V which contains a shallow copy of Element so that the three objects (T his, Element and, V ) cannot point to the same location in memory and CAV ector = {{T his, T his} , {Element, Element} , {V, V }}.

