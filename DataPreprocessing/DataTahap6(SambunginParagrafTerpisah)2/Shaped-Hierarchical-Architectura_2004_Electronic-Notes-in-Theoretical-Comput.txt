Style (or shape) checking implies that an architecture is an instance of some Software Architecture (SA) Style that characterizes a class of structures exhibiting a common pattern. A style can be seen as a type for a given archi- tecture. Generalizing the idea of style as a type, from now on we use the name shape for the rules used to type systems. This term is taken from work on graph grammars for typing programming language pointer-based data struc-

In summary, our goal is to cope with modeling problems for SA. The use of type systems and linear representation of structures allow the hope of taking advantage of existing work on programming languages and static type checking. In addition, there is a corresponding graphical view for all elements in the approach. As a possible instantiation of the approach we present a type inference system for shapes with hierarchies and global references. Taking some initial ideas from [8,9], judgments describe graphs and shape rules (graph rewriting rules), hierarchy constructors are typed as rules and architectures are derived by typing proofs.

[2] proposes graph-reduction (GR) specifications to specify classes of pointer data structures (shapes). GR rules are just reversed graph grammar produc- tions. In [6] context-free graph grammars are proposed to model shape types. Both propose algorithms for testing membership and analyze their complex-

pendently and relation between levels is defined as new morphisms. For this, the double-pushout [14] approach for graph transformation is extended to hi- erarchical graphs by recursively constructing pushouts and morphisms. Also, they present a flattening operation where frames in each level are replaced by their contents. Hierarchy is strict and it does not allow border-crossing. In this line, the work of [10] integrates hierarchy and shapes, where edges and nodes are hierarchical, and shapes (context-free rules) are used to type hierar- chical levels. Types are defined for variables that must correspond to a shape. In these works the theory of double-pushout is redefined to handle hierarchy.

As running example we use the Airport Case Study [1]. The basic scenario is as follows. In airports there are passengers and planes. Planes run flights, and land and take off, transporting passengers and their luggage between airports. Here we take a simplified view of the example for a clear presentation. We con- centrate on classes concerning locations, which define a hierarchy. Countries may contain airports, which can contain planes and passengers.

This section introduces the approach for representing styles using types. Gen- eralizing the idea of style as a type, we use the name shape ([2,6]) as a char- acterization for a class of graphs (representing instances of a style) which are generated from a set of rewriting rules over graphs called shape rules (i.e., rules specifying systems typing). Then, typing proofs define a general frame- work based on inference rules, which can be instantiated producing different type systems allowing to choose the most convenient solution for some spe-

Our intention is to propose a general structure of inference rules but for space limitations, in this paper we directly present one possible instantiation that allows handling global references. This case also shows how the approach is more general than hyperedge replacement and specially relevant with re- spect to the integration of shapes and hierarchies. Hierarchy can be treated as a strict structure where nesting implies that elements cannot know other elements outside their same level, i.e. there are no global references. Neverthe- less, many programming languages allow global references, and architectural or design languages like UML make use of global references.

Definition 3.2 [Type System] A type system TS =< A, I > is defined as a set of type judgments for axioms A and an inference rule I over judgments. A proof term is a composition of judgment names. A proof term is well typed if a typing proof exists that generates it. Here, we consider standard proof terms

Graph terms contain edges (as in Definition 3.1) and variables that work as placeholders (for other graphs) connecting some nodes (as for edges). Graphs and shape rules are type judgments. Basic types identify nonterminal symbols and variables represent nonterminal instances appearing in rules and derived graphs using them. Types and variables are ranked according to the number of nonterminal tentacles.

We have seen in detail a type system for shapes with global references, but the study has to continue on other possible instantiations. With respect to shape analysis, we consider that some of the results in the related work for pointer data structures can be relevant to our approach as well, specially given the correspondence with Hyperedge Replacement stated in Theorem 3.6.

