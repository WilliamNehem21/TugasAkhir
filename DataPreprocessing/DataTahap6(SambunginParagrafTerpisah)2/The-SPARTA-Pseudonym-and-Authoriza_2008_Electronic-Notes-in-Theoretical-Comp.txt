The infrastructure in charge to assign and revert pseudonyms is reduced to a simple distributed infrastructure whose only goal is to provide valid pseudonym certificates. This allows us to rely on widely accepted and standard-based certificate formats (X.509), and on the efficient and mature means to handle them in a PKI (Public Key Infrastructure). The proposed approach is distributed and user-centric, meaning that the user has the freedom to decide which, and how many, entities composing the infrastructure will be involved in her assigned pseudonyms (possibly multiple). While no single entity involved in a pseudonym assignment is capable to trace the user, the system retains the possibility to determine the real identity behind a pseudonym through explicit interoperation (e.g., triggered by an authority) among all the entities involved in its assignment. In other words, rather than being forced to trust a specific and single third party, the user needs only to trust that two or more entities selected by the user herself will not collude against her privacy rights.

S. This agreement may be further based on supplementary information eventually presented by the user at registration time, as well as procedures, such as payment of a flat fare, performed (or documented) at registration time. No anonymity or privacy protection is provided, in our framework, for data presented during this phase.

3 We remark that the extension to federated identity management systems, e.g. Liberty Alliance [19] is conceptually straightforward - the difference being that in such case a further indirection exists between the provider that offers the service, which we referred to as SP , and the central entity that manages the user identity. In the provided description, for ease of presentation, we non restrictively assume coincidence between these two entities.

During such registration phase, the user will receive one or more authorization permissions through which she will be able to access S at later times. An autho- rization permission consists in having the SP signing, with a signature key specific for each service or resource S, a pseudonym certificate blindly submitted to the SP (pseudonym authorization). As such, an authorization permission is account- able, i.e. reuse of a same access permission implies reuse of the same authorized pseudonym. Clearly, the user may prevent linkability by asking the SP to authorize more than one pseudonym during registration phase, and then change pseudonyms, among the authorized ones, through different access sessions.

The procedure to assign a pseudonym certificate P to an user is done offline, i.e. before the actual access to the service, and as such does not add extra time and/or and/or computational burden to the service provision. Since a pseudonym P shall be submitted by the user at registration time (see section 2), the pseudonym assignment procedure is performed after the real identity certificate U is issued and before the registration time.

then carried out. Finally, if all checks are successful, the IR embeds the provided public key ei into a new token certificate Ti. As final pseudonym P , the user simply choses the last token in this chain (where we stress that such chain is freely decided by the user).

Despite its extreme simplicity, this approach is indeed effective and may be extended to give raise to a full-fledged Identity Management PKI driven by the user decisions. In fact, it is up to the user to decide which IRs to use, and whether to use a single IR or a multiplicity (for improved robustness of the reversion of this process). This makes all the framework strongly user centric.

In parallel, the set of deployed IRs form a PKI infrastructure. This means that the IR must maintain a list of trusted CAs (both IRs and SPs), and accept certificates issued by other CAs depending on deployed policies (regulatory, etc). For instance, this allows the user to derive tokens (pseudonyms) from a chain of IRs involving different administrative domains or even states, which they may be later on accepted as valid by the SP depending on the specifically issued service (in other words, for some services it is possible to impose that the pseudonym must be issued by a subset of IRs - e.g. from a same state). We point out that the choice of obtaining a pseudonym through a given chain of SP/IRs clearly affects the regulatory conditions under which the pseudonym may be reverted. For a trivial example, the fact that a pseudonym has been obtained by chaining two IRs from two different states means that the authority capable of reverting it must be a trans-national one.

As shown in the next section, the revocation of an authorization permission for a single misbehaving pseudonym is locally managed by the SP itself. In fact we will show that an authorization permission is a credential issued by the SP only, with no involvement of the described pseudonym PKI. A more elaborated problem is the revocation of all the pseudonyms associated to a same real user identity. This can be accomplished in a distributed way by the PKI components through the usual revocation approaches (management of Certificate Revocation Lists). Particularly, each IR server shall periodically check that its issued certificates are not included in the CRL. If an issued certificate is found to be revoked, we can take advantage of the mapping internally hold by the IR, and accelerate the pseudonym revocation procedure by selectively informing the parent IR in the chain.

The detailed security analysis of the proposed signature mechanism is outside the goals of the present paper, and it is object of work in progress. Some preliminary considerations follow, with the double goal of i) understanding the rationale behind the proposed approach, and ii) describing how the proposed approach is devised to defend against some simple forgeability and traceability attacks. In the following discussion we assume that the communication channel is secure and the communi- cating peers authenticated (i.e. no MITM attacks).

The transmission of the server side random value y occurs at step (1). Due to the discrete logarithm hashing, it is computationally hard for the user to obtain y. Note that this random value must remain unknown to the user during the handshake as, otherwise, it would be trivial for the user to forge a value R' and vanish the desired properties of this signature mechanism. This would be obtained by sending

An integrated implementation approach has been followed. Rather than imple- menting each different server as a separate entity, a general Multi Purpose Server (MPS) integrates the server side logic for the pseudonym assignment handshake (sec- tion 3) as well as the authorization credential issuing handshake (section 4). The MPS is implemented as a multithreaded server thus allowing the management of several clients in parallel without significant performance impairments. The server stores the transactions log in a back-end database. We used the MySQL database [26], which is well known by the open software community and guarantees good performances while processing logs of many concurrent clients. On the user side, we developed a Pseudonym Manager tool to assist the user through the various token/pseudonym assignment, registration and verification procedures. We choose to develop a command-line tool, for ease of integrability in other softwares, with a GUI commander for standalone user friendly operation. As regards the creden- tial verification at the time of service provisioning we also developed a standalone command-line verification tool, with the intent of being easily integrable in the logic of the service application.

All the messages are conveyed over TCP sockets. As discussed in section 5.1, we assume the presence of an underlying security protocol to secure all the communi- cations, and our implementation choice was TLS, mostly for ease of implementation and the possibility to deploy the proposed solution in a web service scenario (section 5.4).

