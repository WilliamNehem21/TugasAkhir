A compiler-compiler for visual languages is presented. It has been designed as a framework for building visual programming environments that translate schemas into textual representation as well as into programs representing the deep meaning of schemas. The deep semantics is imple- mented by applying attribute grammars to schema languages; attribute dependencies are imple- mented as methods of Java classes. Unlike compiler-compilers of textual languages, a large part of the framework is needed for support of interactive usage of a visual language.

Our idea has been to develop a compiler-compiler for visual languages analo- gous to the compiler compilers of programming languages, to be used as a tool for rapid development of domain-specific visual languages. To be able to de- scribe both syntax and semantics of languages considered, we have restricted the class of languages to schema languages with well-defined abstract syntax. On the semantic side, we are able to specify precisely shallow semantics that produces a textual representation of schemas without loss of essential informa- tion included in a schema. Furthermore, we give a general way to implement

In several ways, COCOVILA is similar to meta-modelling tools such as MetaEdit[2] or AToM3 [3]. However, our treatment of scheme semantics is quite different. Unlike the latter we are using a technique of dynamic evalua- tion of attributes of the syntactic graph underlying the scheme.

for calculating loads and kinematics of a gearbox has been loaded. Gears are connected to each other by arranging them on top or next to each other; lines connect other objects (motor and monitoring device). The toolbar at the top of the scheme is used for adding objects and relations to the scheme. One pop-up window is designed for instantiating object attributes, another pop- up window is designed for manipulating the scheme - deleting and arranging objects etc.

The way to handle large schemes in the scheme editor is to use hierarchical composition in building the scheme. Any part of a scheme can be encapsulated as a separate class, so a large scheme can consist of a hierarchy of schemes, where each scheme object can contain subschemes. This means that schemes can be viewed in several different levels of abstraction, in order to encapsulate and manipulate parts of the scheme which are relevant to a particular issue.

