effective solving engines, allowing to specifying a given (search) problem rather than programming the algorithm for solving it. In other words, given a search problem, a programmer specifies the search space domain and problem-specific properties. Combined, let an ASP solver propose solutions called answer sets.

Currently, ASP is robust and mature enough, offering many important language constructs like aggregation, (weak) constraints, different types of negations, and optimization statements to mention a few, as well as high-performance solvers. An example of a state-of-the-art and award-winning ASP solvers is clasp [7] demon- strating its competitiveness and versatility, by winning first places at various solver contests since 2011 (eg. ASP, CASC, MISC, PB, and SAT competitions). 2 clasp, combined with the grounder gringo [9], composes clingo [10], an ASP system to ground and solve logic programs. For this article, we expect the reader to be familiar with ASP. For technical aspects, including theoretical works, implementations, and applications, see [11,8,10]. On the other hand, we refer to [13] as an introductory yet complete reading of ASP.

we cover the best practices for designing and developing ASP programs from a software engineering perspective. We close this section with a brief description of the formalities of parity constraints as well as the xorro system. To set the context of the intended process, Section 3 illustrates a running example using ASP as an overview to reverse the standard solving process, followed by a more fine-grained details including ASP codifications around parity constraints. From there, we discuss our results by showing the only representation available, that satisfies different properties from the classical logic xor operator, which is also consistent with the semantics of parity constraints from xorro. Lastly, we conclude the paper and direct future work in Section 4.

Integrate into the existing environment Choose the best ASP program alternative from the feasibility study.Evaluate other solving strategies, and answer sets handling. Design interfaces towards a complete implementation, benefiting standard libraries and API from ASP solvers like clingo in languages like Python or C++.

Furthermore, in [14], they use an Object-Oriented approach (OO) into ASP called OOASP, which allows analyzing OO software models and their instances employing ASP. The OOASP approach has been successfully implemented in Siemens, as an extension to any OO modeling environment. It has been evaluated together with Siemens internal tools. This modeling approach is currently out of the scope of this paper, but it will be considered for future work development.

xorro is a system that provides six alternatives to handle parity constraints into ASP solving through a standard syntax. On the one hand, xorro draws upon the advanced interfaces of clingo for integrating foreign constraints and corresponding forms of inference. On the other hand, xorro takes advantage of the sophisticated solving techniques developed in SAT for handling parity constraints. More precisely, xorro proposes two types of approaches, namely eager ones that rely on ASP encodings of parity constraints, and lazy ones using theory propagators within

The experiments from the paper evaluate the different approaches in view of their impact on solving performance while varying the number and density of parity constraints, compared against clingo solving time (without parity constraints). The results show that xorro scales depending on the combination of the number, density, and preprocessing of the parity constraints. When increasing the number of high- density constraints as used in sampling (xors with a size of half the program variables), we start to see that the solving time increases concerning clingo.

As mentioned before, the user can benefit from SE properties to delimit more the search. This means the user can straightforwardly specify in SPF the desired properties to satisfy. For example, the user can ask for a representation that satisfies commutativity, associativity, and identity. Calling again SPF coupled with the user-given properties, clingo encounters four intermediate representations.

Let us mention that these intermediate representations consist of a 3x3 matrix based on G3 as shown in 2a and 2b. Now suppose we have two users, the first one, decides to refine more the search by adding another property, for example idempotency. Now clingo yields a single matrix, allowing the user to move to the second stage. The second user instead, asks ProgramBuilder to take two matrices M1 and M2 from the four remaining, postponing the decision, and moving also to the second stage.

With the example above, we propose a first step methodology with the possibility to implement it into an interactive software that construct ASP programs through defined properties. Also, this software could include transformation modules to visualize multiple forms of constructed programs. Furthermore, this example serves to inspire the conception of a more general framework or concrete examples, as shown next.

To do so, we could either add our intermediate representation or follow the standard guess-and-check paradigm of ASP. In both cases, solution candidates are tested for feasibility with the possibility of yielding none, one, or multiple answer sets. Typically, these answer sets serve as the solutions of an encoded program, but for our purposes, they are interpretations in G3 which allow us to construct formulas. Before delving into the three stages, let us explain that we have two types of answer sets (due to our meta-programming approach), the answer sets given as input, and the answer sets as intermediate representations. From now on, we easily differentiate them as answer set(s)input and answer set(s)output respectively, and we use them interchangeably.

From the code above, we represent each property as an integrity constraint, where the atom op(X,Y,R) corresponds to the desired operator of two arguments (variables) X and Y and its result R. Let us allow to get ahead, and mention that this atom is part of the answer setsoutput or intermediate representation. Before we move to the second stage, we describe the encodings that yield the intermediate representations.

Describing an overview of the main function of this code, the first four rules from Listing 6, captures the completions needed for all possible answer sets (related to answer setinput) concerning our inputs p and q. Then, the facts in line 6, display the correspondence between the constants p and q with all the possible answer sets, followed by (facts) mappings into string representations in line 8. Line 10 forms the completion concerning the operator. Then, the completion must be consistent (line 12), and we define what incompleteness is (lines 13 and 14). Lastly, line 16, derives the corresponding answer sets in string representation via their correlated code. These answer sets must satisfy consistency and completeness, as well as the answer setsinput (Listing 1).

Finally, we need to guarantee G3 persistence properties [29,25]. They are dis- played in Listing 7. Here, line 1 states that it is not possible that in case there exist an interpretation {1,0,2}, then exist another intepretation with inputs 2 and 0, that evaluates to any other value different than 2. Line 2 describes the commutated property, and line 3 states that, is not possible that an interpretation resulting in 1, comes from inputs different than 1.

Solving both, the instance, and the encoding produces the intermediate repre- sentations to move to the second stage. However, for either both cases (using the classical xor formula or guessing for one), there are no answer setsoutput. This means it is not possible to represent an xor operator as a two arguments function in ASP, that besides, satisfy all four properties. Despite the negative solution where there is no formula to construct, it is positive in the sense that this methodology can save time, money, and resources from a software engineering perspective. Also, this fits perfectly into iterative software engineering methodologies, taking the user

After asking exhaustively for all possible intermediate representations, clingo found a single answer setoutput. This means, there is only one alternative to represent an xor as a constraint in ASP satisfying the aforementioned properties as shown in matrix 2. With this intermediate representation as a matrix of the form of M1 or M2 (from the running example), we can move to the second stage.

tioned encoding, logical operators (Listings 5), theory completion (Listings 6), and G3 persistency properties (Listings 7). Therefore, clingo yields the answer sets {p} and {q}, as well as the same G3 representation shown in matrix 2. This means that the founded formula semantically behaves as a parity constraint used in xorro.

