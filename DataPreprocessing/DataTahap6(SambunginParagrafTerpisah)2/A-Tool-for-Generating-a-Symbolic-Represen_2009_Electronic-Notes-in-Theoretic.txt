The Timed Concurrent Constraint language (tccp) was defined by F. de Boer et al. as an extension of the Concurrent Constraint Paradigm (Saraswat, 1993) for specifying reactive and embedded systems. In this paper, we describe the StructGenerator system which, given the specification of a tccp program, constructs a symbolic representation (a tccp Structure) modeling the behavior of such tccp program. The resulting structure allows one to verify the program by using a model-checking algorithm. It is similar to a Kripke Structure but, due to the nature of the ccp model, it differs from the classical approach in some important points that will be described along the paper. The StructGenerator system, implemented in C++, takes as input a file containing the specification of a tccp program and generates the associated tccp Structure. Along the paper, we cover the design and implementation of StructGenerator. We also demonstrate its functionality carrying out the execution of two practical examples.

The Concurrent Constraint Paradigm (ccp in short) [10] is a simple but powerful model based on the notion of store-as-constraint instead of the classical notion of store-as-valuation. Therefore, the computational model is based on states which are composed of a conjunction of constraints instead of being defined as a valuation of variables. The Timed Concurrent Constraint language (tccp in short) was intro- duced in [4] as an extension of ccp for specifying reactive systems in an intuitive way. The authors introduced a notion of time within the language semantics and new agents to handle negative information, i.e., information that is not present in

During the last years, verification techniques for concurrent and reactive sys- tems have been widely developed. The model-checking technique [5] is a formal technique that allows one to verify whether a property is satisfied by a model. This technique suffers the so-called state explosion problem which motivates the develop- ment of many optimization approaches to mitigate it. We can find in the literature many optimizations based on abstract interpretation, partial order, symbolic repre- sentations, etc. for different modeling and (fragments of) programming languages. The ccp framework in general, and the tccp language in particular, thanks to the store-as-constraint approach, symbolically represents sets of classical states as con- junctions of constraints, thus achieving a natural compression of the search space. Note that this fact does not prevent us from applying other optimization techniques such as [1,2].

A model-checking algorithm for tccp was proposed in [6] which given a tccp program transforms it into a symbolic representation (the tccp Structure) which is the input of the verification phase. The proposal in [6] is similar to the classical one, with the tccp Structure playing the role of the Kripke Structure. However, as we will show later, the tccp Structure differs from the Kripke Structure in some important points, so the verification algorithm had to be reformulated and adapted to the ccp model.

In this paper we present StructGenerator, a system that automatically constructs the tccp Structure given the specification of a tccp program. The construction algorithm differs in some aspects w.r.t. the one proposed in [6], incorporating some notions from [3] that make the tccp framework more flexible.

The paper is organized as follows. Section 2 briefly presents the tccp language. Section 3 describes the notion of tccp Structure presenting the main difficulties from dealing with the ccp model. In that section we also show how we implemented the construction of the tccp Structure. Section 4 shows how to use the tool by developing two running examples and, finally, Section 5 concludes.

The Timed Concurrent Constraint Language, tccp, is a concurrent declarative lan- guage defined in [4] as an extension of the Concurrent Constraint Programming paradigm (ccp, [10]). In the ccp model, the notion of store-as-valuation is replaced by the notion of store-as-constraint. The computational model is based on (1) a global store where constraints are accumulated, and (2) a set of agents that may interact with others via the store. The ccp model is non-deterministic and there is no notion of time defined. Intuitively, the execution of a ccp program evolves by asking and telling information to the store. It is a simple but powerful model in which partial information can easily be handled. The temporal extension of tccp introduces a notion of time within the semantics, i.e., no special agent for time passing is defined. However, a new agent able to handle negative information (the conditional agent ) is introduced. We can find other approaches to the temporal ex- tension of ccp in the literature that make different design choices [11,7,9]. In tccp, the execution of a program evolves, again, by asking and telling information to the store, but this time these actions consume time. In practice this means that both, consults and updates to the store, take time. Finally, we remark that it is not pos- sible to remove information from the store, thus differently from other extensions, the store behaves monotonically.

Agents are synchronized by means of a global clock. In the semantics of tccp, the only agents that consume time are the tell, the choice, and the procedure call agents. The store in the original tccp execution model [4] can be seen as a black- board where information is continuously written and never canceled. The store grows monotonically, thus it is not possible to change the value of a given variable. We can use streams to model the evolution of variable values along the time. This allows one to handle imperative-style variables. In order to retrieve in a simpler way information regarding the order in which the information was added to the store,

A graph structure (tccp Structure) for modeling tccp traces was proposed in [6] in the context of the definition of a model-checking algorithm. This structure can be seen as a variant of a Kripke Structure where, following the ccp model, the notion of state as valuation of variables is replaced by the notion of state as a conjunction of constraints. This means that a node in the tccp Structure can represent a set of classical nodes of a Kripke Structure. The StructGenerator system implements the construction of such structure. As we will show, the main difficulties for this constructions arise from the monotonic nature of the tccp store. Moreover, both in the construction of the tccp Structure phase and later in the verification phase, we have to take into consideration that, differently from the classical approach, the absence of some information in the store does not (necessary) mean that the negation of that information holds.

Let us briefly describe the symbolic representation. A state of the tccp Structure contains a set of atomic propositions; more specifically, it consists of a set of atomic constraints from the underlying constraint system in tccp. Each state of the tccp Structure also contains a set of labels representing the current execution step. These labels are uniquely associated to each occurrence of an agent in the tccp program. Note that a pre-process for labeling the program is needed. Labels allow us to set those agents that must be executed in the following time instant.

StructGenerator has been implemented in C++. It consists of approximately 3100 lines of code divided in 10 classes. Each class handles one of the entities of tccp (agents, constraints, declarations, stores, states, . . . ). We decided to implement the

As we have said above, the StructGenerator system constructs in an automatic way the already described tccp Structure, so it aims to representing in a symbolic way the behavior of a tccp program. An algorithm for this construction was pro- posed in [6]. We have followed the main ideas in that algorithm, but, as mentioned above, we decided to refine some of the definitions by using the more flexible com- putational model in [3] which allowed us to deal more easily with streams.

In this section, we present two practical examples. The first one is the (partial) specification of a microwave oven controller that we have borrowed from [6]. The second one is the specification of the scheduler example used in [1] to motive the symbolic version of the model checker. We first provide the tccp specification of the concurrent system and then we provide the tccp Structure generated by StructGen- erator. We also show graphically the connection between nodes.

The procedure declaration microwave error models the process of detecting when the door of a microwave is open at the same time that the system is turned- on. This situation is controlled by the conditional agent ln8. In case the condition holds, the process forces (with the tell agent lt13) the microwave to be turned- off in the following time instant. Note that the tell agent is executed at the same time instant when the error is detected, but the told constraint is only available to others in the following time instant. Moreover, an error signal must be emitted (agent lt11). If the condition does not hold, then the program emits (via another tell agent lt15) a signal of no error that will be available in the global store at the following time instant. These signals may be captured by other processes, thus it can be seen that the store allows the synchronization of processes.

In this example, just one tree is generated since there is just one procedure declaration. We can see this fact since all nodes are in tree: 0. The system generates as many trees as declarations in the program. Note that some relations, for example those of state 0 to state 1 and state 2, have no renaming. Renaming predicate get constraints. In parallel, an ask agent checks whether the value of the three variables are instantiated to integer numbers and, in that case, several constraints representing the scheduling restrictions are added to the store. Finally, a recursive call to the building process is made, allowing us to recalculate the planning schedule. The predicate get constraints is simpler since it just adds to the store the values of the different duration of tasks.

The resulting structure from the execution of StructGenerator is shown below. Note that in state 1, the set of labels contains the label to the procedure call agent lx2. state 1 is linked to nodes state 2 and state 3, that, as one can observe, have labels from agents in the get constraint declaration and in the build declaration.

represents when the condition does not hold. state 2 is related to state 4 which is related again to state 2 and also to state 3. This is due to the execution of the procedure call agent lc10-build which models the recursive call to the building process. The second tree represents the predicate get constraints composed by three states which describe the process of adding the corresponding variables to the store.

As future work, we plan to consider in this tool the new agents recently presented in [8]. We also plan to adapt the model-checking algorithm to this new framework (including the new agents and formulated within the structured computation model of [3]). Note that the tccp Structure generated by StructGenerator has enough information to be the input of such model-checking tool. Finally, we would like to improve the interface of our tool, by automatically showing the graphical version of the relation between nodes.

