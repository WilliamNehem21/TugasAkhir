The increasing use of logics in practical applications, and in particular non-classical logics, poses challenges for automated reasoning. A key issue currently addressed by the automated reasoning community, is how one can improve scalability of already successful methods. Besides optimizing the implementations, this can primarily be achieved in two ways: either by improving the proof calculus or by finding more clever ways of applying the rules.

Our focus on the strategy level makes Maude attractive as an implementation platform. This is partly due to its support for reflection [6], which allows strategic choices at run-time [5]. In particular, this gives a satisfying separation between deduction and strategic choices, allowing us to experiment with different strategies over the same deductive core. Ideally, theorem proving can be as simple as con- structing a specification containing all the deductive rules (as rewrite rules), and then rewriting an appropriate term. This also gives a close relationship between the calculus and its specification.

The main rationale behind the isolation of a strategy layer is that more eas- ily understood procedures are less error-prone than procedures in which rules and strategies are intermixed. Moreover if one opts for the other extreme, i.e., to build the strategy into the rules, the strategy will most likely be hard to modify. In prac- tice one will often need to have a little of both, even if one tries to separate the layers, since pruning the search space may in some cases be easier to implement by means of inference rules than tacticals.

M is a disjunction of clauses. It is well-known that any FOL formula A can be effectively transformed into a PDNF formula B, such that A is valid iff B is valid. Hereafter, we assume that all input formulas are on PDNF. This matrix represen- tation exploits graphical metaphors. To illustrate the idea let Ai, Bi,..., Ri be literals. The PDNF formula

Proof search with the connection calculus is a connection-driven path-exploring process; the multiplicity is increased on demand and unification constrains the set of potentially closing substitutions. Complete strategies must fairly balance the incremental extension of partial paths (based on identification of new connections), the update of partial substitutions (with new unifiers), and the addition of copies of clauses. All implementations we know use iterative deepening, either on the number of inferences or on proof depth; i.e., the search space is explored up to a fixed multiplicity, which can gradually be increased. Our strategies will also use iterative deepening and backtracking.

Maude [5] is a tool for rewriting logic which includes facilities to meta-represent a theory R and to apply rules from R to the meta-representation of a term C using descent functions. Metalevel rewrite rules may be used to select which rule from R to apply to which subterm of C by defining a function which takes as arguments a finitely presented rewrite theory R, a term C, and a deterministic strategy S. Further details on the theory and the use of reflection in rewriting logic and Maude may be found in [5,6].

able index, based on the two literals and the old index. The substitution is used to propagate variable substitutions in the calculus, based on a most general unifier for the free variables in literals. In the presentation, we omit the application of the substitution; the new unifier is applied to all literals of the initial matrix between rewrite steps.

We present the main components of the implementation separately, leading to the formulation of a connection-based search procedure in Section 5.5. For simplicity, this procedure assumes a fixed multiplicity and does hence not implement iterative deepening. For a complete search procedure, all that is omitted in Section 5.5 is a function which gradually increases the multiplicity.

function terminates and the term is returned. The function mguNewIndex distributes information about variable bindings (mgu) and newly generated fresh variables, so other SearchState elements can update their newIndex and substitute variables. This is only relevant if the rewrite rule we are applying is a variable binding rule, hence the occurs check.

The basic search component defines a strategy where an active clause is selected by an init rule. Then, we recursively attempt to apply rules to the currently in- vestigated SearchState element, respecting a given order and keeping track of sub- stitutions and index values. Let gt and dt be wrapper functions for getTerm and downTerm. The strategy terminates once it locates a path without connections. In particular, it does not solve the matrix in Example 2.1.

We now address clause copying. The function below implements static copying ; i.e., copies are introduced before the proof search begins. The presented function makes a single copy of each clause with free variables, this can easily be modified by increasing the last parameter of the strategy function.

If our current rule applies, the number of the next potential matching position is stored in the BackTrackList. Backtracking is then a matter of calling the search function with the elements of the backtrack-term, which are now stored in a list. Note that we can select the members of the label list; i.e., the rewrite rules to which backtracking should apply.

a copy of the selected clause is placed in the remaining matrix. Recall that the function copyClause provides a fresh copy of the input clause, that newIndex provides a new variable index based on the two literals and the old index, and that the function cntFree counts the number of free variables in a clause. Next, we modify the rule extensionRule, which prunes the search by locating connections between elements in the active clause and the remaining matrix. Here, a fresh clause is generated and added to the second search state.

The index of the SearchState elements is increased due to the free variable inside the clause that is copied. The main idea is that binding the variable Y should not affect the clauses left in the remaining matrix when the substitution is applied. Since a fresh copy of this clause is allowed, we replace the original clause with a copy to avoid name capture. Note that the original version of the clause could be left inside the remaining matrix as well. An iterative procedure where original versions of the clauses are left inside the remaining matrix is needed for completeness of the connection method.

By selecting the initial active SearchState element with rule init2 and replacing extensionRule with extensionRule2 in basicSearch, we get a search strategy dy- namicCopySearch which incorporates a possible solution for dynamic fresh clause copies. (Note that there are several options for when to introduce copies; e.g., ex- tendPath could also copy the activated clause.) In order to include backtracking over the variable binding rewrite rules, we define a strategy dynamicCopyBacktrack combining the backtracking strategy given in Section 5.4 with the new rule set. The strategy function is used once again, it should be noted that backtracking over the init-rules have not been presented, this is however only a minor detail to implement.

The paper presents a rewriting logic approach to the implementation of a connection- driven search engine for FOL. A rewrite theory is defined for the connection method, and variations of search strategies are explored at the Maude meta-level. This fa- cilitates comparison and experimentation with strategies for proof search, as these control the same underlying rewrite theory.

