Therefore, we developed Refine, an educational tool for refinement. The initial version of the tool was presented in [5], but it had few facilities of development management. Moreover, the supported language did not include procedures and recursions. In this paper, we present a new version of Refine that addresses these issues.

In Section 2 we give a brief explanation of refinement calculus, and of the proce- dure and recursion laws that we consider. Section 3 presents Refine, and Section 4 describes the results of the integration of the procedure and recursion laws. Finally, in Section 5 we summarise related and future work.

For each step in the refinement process, the current program, or some subpro- gram of the current program, is transformed by the application of a refinement law. For some transformations, proof obligations are generated. If the proof obligation can be discharged, the correctness of the generated program is guaranteed.

A specification has the form w : [pre, post]. Its precondition (pre) describes the initial state in which execution of the program is well behaved. The postcondition (post) describes the final states that can be obtained if the precondition is satisfied. The frame (w) lists the variables whose values can change. The language used to define the preconditions and postconditions is the predicate calculus. If the initial state satisfies the precondition, then the variables listed in the frame can be modified in such a way that the final state satisfies the postcondition. If the initial state does not satisfy the precondition, the result cannot be predicted. A precondition true can be omitted.

Example 2.1 As an example, we consider a program that computes the square root of the inverse of a positive number. We adopt x : [0 < x, x2 = 1/x0] as the initial specification of this program. Each law used in the development can be found

At first, we introduce a block that defines a procedure that computes the square root of a number. The name of the procedure is Sqrts; its parameters are a, passed by value, and b, passed by result; the procedure body is the specification b : [0 < a, b2 = a0]. The main program is the initial specification. The procedure block results from the application of the Parameterized Procedure Introduction law.

Refinement Management.  It is possible to save developments into a file and to recover the development saved in a file. When a development is saved, information about the proof obligations and the generated code is saved too. Therefore, when the development is recovered, the additional information is readily available as well. The undo and redo operations help in the correction of

Refine associates the proof obligations and the laws that generated them. To find out which law application generated a specific proof obligation, we must select the proof obligation in the proof-obligations window. The tool will automatically select the part of the refinement, in the refinement window, that generated the proof obligation selected.

To support the application of the laws related to procedures, we implemented a facility for code collection. As we explain in detail later on, some of these laws are applied to parts of the developed program that are not necessarily available in the development window. By collecting the code, we record an updated view of the developed program obtained so far, and we can consider the refinement of its con- stituent commands. To illustrate this functionality and others, we will continue the development of the square root procedure (Example 4.1) and start the development of a recursive program that evaluates the factorial of any number (Example 4.2).

specification of the procedure body (f:[f=fat(x)]), the variant name (V), the variant expression (x), and the procedure parameters (val x). The result of this law application is presented below. Refine includes automatically the predicate variant name = expression variant (V=x) in the precondition of the procedure body specification.

The first step of the development is to transform the main program of the block into a program similar to the procedure body, in order to replace it with a procedure call. For this, we first apply the Strengthen Postcondition law (using the predicate (f=fat(x))[x,x0\n,n0] as argument). This give us the following specification.

We transform the specification above into a program that is similar to the initial specification of Fact, with the variant being decreased. Then, we ap- ply the Strengthen Postcondition and Weaken Precondition laws, using the pred- icates (f=fat(x))[x,x0\x-1,x0-1] and (0<=x & x<V)[x\x-1] as arguments, re- spectively. This results in the following specification.

In this paper, we presented a tool that supports the use of the refinement cal- culus. Refine includes facilities to manage developments and, most importantly, supports the use of (possibly recursive) procedures in accordance with [6]. As we saw, Refine allows and helps the process of development navigation; moreover, it automates the recursion law applications, what demands a complete knowledge of the development description.

Refine has been used successfully in teaching for almost four years and it has already proved to be useful as an educational tool. It was developed using Java, and amounts to about 45000 lines of code, in 203 classes. Details of Refine are available in its site [26], where we can also find UML documentation of the design, a tutorial, and development examples.

Besides, Refine was also extended with a tactic tool, called Gabriel [19,20]. It allows the definition of refinement tactics which document routine law applications, as for example, tactics for iteration developments, and for introduction of procedure calls. Using Gabriel, these tactics can be used as ordinary laws; an extra window lists the available tactics, and provides facilities to define and edit new tactics.

