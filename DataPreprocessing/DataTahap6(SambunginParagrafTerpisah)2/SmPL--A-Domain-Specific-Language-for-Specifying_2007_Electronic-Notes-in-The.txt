We have studied the collateral evolution problem in the context of Linux device drivers. Currently, collateral evolutions in Linux are mostly done manually using a text editor, possibly with the help of tools such as grep. The large number of Linux drivers, however, implies that this approach is time-consuming and unreliable, leading to subtle errors when modifications are not done consistently.

In previous work [16], we have identified the phenomenon of collateral evolution, in which an evolution that affects the interface of a generic library entails modifica- tions, i.e., collateral evolutions, in all library clients. As part of this previous work, we have furthermore studied this phenomenon in the context of Linux device drivers.

In this paper, we propose a declarative transformation language, SmPL (Se- mantic Patch Language), to express precisely and concisely collateral evolutions of Linux device drivers. Linux programmers are accustomed to exchanging, reading, and manipulating patch files that provide a record of previously performed changes. Thus, we base the syntax of SmPL on the patch file notation. Unlike traditional patches, which record changes at specific sites in specific files, SmPL can describe generic transformations that apply to multiple collateral evolution sites. In particu- lar, transformations are defined in terms of control-flow graphs rather than abstract syntax trees, and thus follow not the syntax of the C code but its semantics. We thus refer to the transformation rules expressed using SmPL as semantic patches.

The rest of this paper is organized as follows. Section 2 describes a set of collateral evolutions that will be used as our running example. Section 3 illustrates how one of these collateral evolutions is expressed using the standard patch notation.

The collateral evolutions in the proc info functions were triggered by the decision that it is undesirable for drivers to directly use the functions scsi host hn get to obtain access to a representation of the device and scsi host put to give up this access, because any incorrect use of these functions can break the integrity of associated reference counts [11]. Starting in Linux 2.5.71, these functions were no longer exported by the SCSI driver support library. To compensate for this evolution, the proc info functions were then passed a representation of the device as an extra argument. An existing parameter that was used as the argument of scsi host hn get was also removed. Among the drivers in the Linux source tree, these collateral evolutions affect 19 SCSI driver files, in 4 different directories.

Normally, a patch file is applied to a file that is identical to the one used by the Linux developer to create it. It is possible to instruct the patch tool to ignore the line numbers or some of the lines of context, to be able to apply a patch to a file that is similar but not identical to the one intended. Nevertheless, because there is no semantic analysis of either the meaning of the patch or that of the affected source code, this approach is error prone. Furthermore, in practice, patches are quite brittle, and variations in the source code imply that parts of the patch cannot be applied at all.

To express collateral evolutions, we propose a new language SmPL as a means of generalizing patches to semantic patches. A semantic patch is a specification that visually resembles a patch, but whose application is based on the semantics of the code to be transformed, rather than its syntax. The complete language is defined in the appendix. Here, we present SmPL via an example, a semantic patch expressing the collateral evolutions described in Section 2. We develop the semantic patch incrementally, by showing successive excerpts that each illustrate a feature of SmPL. In contrast to a patch that applies to only one file, the semantic patch can be applied to all of the files in the Linux source tree, to selected files, to an individual file, or even to files outside the Linux source tree.

The previous rule assumes that the proc info function has parameters buffer, start, etc. In practice, however, the parameter names vary from one driver to another. To make the rule insensitive to the choice of names, we replace the ex- plicit names by metavariables. These are declared in a section delimited by @@ that appears before each transformation, as illustrated below:

The metavariables buffer, start, offset, length, hostno, and inout are used on lines annotated with - or space, and thus match terms in the original source program. They are declared as identifier, indicating that they match any iden- tifier. The metavariable hostptr represents a parameter that is newly added to the function signature. We thus declare it as a fresh identifier, indicating that some identifier should be chosen that does not conflict with the other identifiers in the program.

The rule above is written as a direct assignment of the proc info field to the name of a local function. In the code to be transformed, however, the right-hand- side of this assignment could be some other expression that is the alias of a local function. The patterns of such aliasing that we have observed in driver code are very simple, such as initializing a local variable to a different function in each branch of a conditional, and then using this local variable immediately thereafter. Such aliases can be detected by a standard dataflow analysis.

Recall that in Section 4.2, we created a fresh identifier as the new parameter hostptr. In fact, when the collateral evolutions were performed by hand, the pa- rameter was always given the name of the deleted Scsi Host-typed local variable. Now that we have expanded the semantic patch excerpt to contain both the param- eter and the local variable declaration, we can express this naming strategy by using the same metavariable, declared as an identifier, in both cases. This repetition implies that both occurrences refer to the same term, thus transmitting the name of the old local variable to the new parameter. Metavariables are thus similar to logic variables, in that every occurrence of a metavariable within a rule refers to the same set of terms. Unlike the logic variables of Prolog, however, metavariables are always bound to ground terms.

The collateral evolution described in this section introduced some bugs in the Linux 2.5.71 version. For example, in two files the hostno parameter was not dropped, resulting in a function that expected too many arguments. This problem was fixed in Linux 2.6.0, which was released 6 months later.

Influences. The design of SmPL was influenced by a number of sources. Fore- most among these is our target domain, the world of Linux device drivers. Linux programmers manipulate patches extensively, have designed various tools around them [13], and use its syntax informally in e-mail to describe software evolutions. This has encouraged us to consider the patch syntax as a valid alternative to clas- sical rewriting systems. Other influences include the Structured Search and Replace (SSR) facility of the IDEA development environment from JetBrains [14], which al- lows specifying patterns using metavariables and provides some isomorphisms, and the work of De Volder on JQuery [3], which uses Prolog logic variables in a system for browsing source code. Finally, we were inspired to base the semantics of SmPL on control-flow graphs rather than abstract syntax trees by the work of Lacey and de Moor on formally specifying compiler optimizations. [8]

Coady et al. have used Aspect-Oriented Programming (AOP) to extend OS code with new features [2,5]. Nevertheless, AOP is targeted towards modulariz- ing concerns rather than integrating them into a monolithic source code. In the case of collateral evolutions, our observations suggest that Linux developers favor approaches that update the source code, resulting in uniformity among driver im- plementations. For example, on occasion, wrapper functions have been introduced to allow code respecting both old and new versions of an interface to coexist, but these wrapper functions have typically been removed after a few versions, when a concerted effort has been made to update the code to respect the new version of the interface.

The Linux community has recently begun using various tools to better analyze C code. Sparse [18] is a library that, like a compiler front end, provides convenient access to the abstract syntax tree and typing information of a C program. This library has been used to implement some static analyses targeting bug detection, building on annotations added to variable declarations, in the spirit of the familiar static and const. Smatch [19] is a similar project and enables a programmer to write Perl scripts to analyze C code. Both projects were inspired by the work of Engler et al. [4] on automated bug finding in operating systems code. These examples show that the Linux community is open to the use of automated tools to improve code quality, particularly when these tools build on the traditional areas of expertise of Linux developers.

This language is based on the patch syntax familiar to Linux developers, but enables transformations to be expressed in a more general form. The use of isomorphisms in particular allows a concise representation of a transformation that can nevertheless accommodate multiple programming styles. SmPL furthermore addresses all of the elements of the taxonomy of the kinds of collateral evolutions in Linux device drivers identified in our previous work.

The grammar uses some rules where the left-hand side is in all capital letters. These are macros, which take one or more grammar rule right-hand-sides as argu- ments. The grammar also uses some unspecified nonterminals, such as id, const, etc. These refer to the sets suggested by the name, i.e., id refers to the set of possible C-language identifiers, while const refers to the set of possible C-language constants.

The grammar of the transformation is not actually the grammar of the SmPL code that can be written by the programmer, but the grammar of the slice of this consisting of the - annotated and the unannotated code (the context of the transformed lines), or the + annotated code and the unannotated code. For example, for parsing purposes, the transformation presented in Section 4.5 is split into the two variants shown below and each is parsed separately.

OR is a macro that generates a disjunction of patterns. The tokens (, |, and ) must appear in the leftmost column, to differentiate them from the parentheses and bit-or tokens that can appear within expressions (and cannot appear in the leftmost column). These tokens are furthermore different from (, |, and ), which are part of the grammar metalanguage.

