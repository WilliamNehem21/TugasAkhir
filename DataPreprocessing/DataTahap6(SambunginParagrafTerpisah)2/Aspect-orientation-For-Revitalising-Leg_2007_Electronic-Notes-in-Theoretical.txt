Business applications are instantiations of specific business processes, and as such they are highly susceptible to the evolution thereof. With increased globalisation of enterprises, and ever greater demand for interconnectivity between companies, comes increasing pressure to scale up and integrate business applications. Aside from difficulties in integrating the different business models and their associated business processes, getting the business applications to cooperate is a major hur- dle: in all but a few cases the documentation and support of these applications is insufficient (or even absent).

Second, LMP can be used for expressing business concepts and architectural descriptions of business applications in a declarative way. This makes it possible to work with applications at a higher level of abstraction, which will allow better architectural descriptions to emerge. By making these descriptions available for practical use we can actively encourage development and understanding thereof.

In order to help legacy systems evolve, one needs a thorough understanding of the systems at hand. As in these environments there is most often a lack of (up-to-date) documentation, one is forced into applying reverse engineering techniques. Dynamic analyses offer one approach to this, by analysing traces of the dynamic run-time behaviour of systems [6,17]. The role for AOP which we will be discussing here is to enable such techniques by applying some tracing aspect to existing applications.

context-specific information on the current runtime event being advised for output to the trace. The second is the use of Type as a kind of generic type specifier. It is used inside the tracing advice (line 7) to deal with the various possible return types which may occur, and which C is not able to handle in a uniform way. The value of this type specifier is something which gets extracted by the aspect weaver during the matching of join points in the base program (type predicate on line 5), and which is instantiated in the advice like a C++ template parameter. These two additions provide reflective and context information lacking in the legacy base language. Without them, AOP would not be viable in legacy languages, whereas many modern OO languages already offer these features by themselves.

all of which were generated. Without intimate knowledge of the build system, it was hard to tell whether source files were first compiled before linking all applications, or (more likely) whether all applications were compiled and linked one after the other. As such, our weaving approach was not immediately applicable and we had to resort to an ad hoc solution, resulting in (slightly) degraded performance of the woven application.

While dynamic analyses can be enabled using aspects without the need to pre- pare the source code of legacy applications in any way, one is still faced with having to prepare the build system for these applications (once). As many such applications rely on custom defined and sometimes complex makefile hierarchies (or similar), any real use of AOP for revitalising legacy software (see e.g. section 4) will depend on a solution to this problem.

This outputs the name and value for all sending data items (lines 4 and 5) before execution of any of the above statements. This allows us to see the contribut- ing values. Lastly, we want to know the new value for BNS-EOY which has been calculated.

This tests whether the culprit statement gets triggered during the process of any of the other employees. If it does, then something about our assumption is wrong. Or it may be that the accounting department has missed one of the lucky employees.

I.e., whenever a new employee record has been read (line 2 and 3), and that record is one for a lucky employee (line 5), we set the flag to true (line 7). We also do some initial logging (line 8). The next advice is needed for stopping the trace when we have reached the culprit statement:

This is where the investigation ends. For those curious, we find that B31241 is part of the following business rule: it is a bonus an employee receives when he or she has sold at least 100 items of the product with number 31241. Apparently this product code had been assigned to a new product the year before. It was once associated to another product which had been discontinued for several years. The associated bonus was left behind in the code, and was never triggered until employees started selling the new product.

AOP+LMP provided us with a flexible and powerful tool to perform our investi- gation. Dynamic aspects allow for easy inspection of the behaviour of applications by enabling smart tracing, verification of assumptions and mining of business logic. LMP adds to this the capability of recording and exploiting recovered knowledge.

only get triggered when METHOD-NAME matches the name of the selected paragraph (extraction of this name happens on line 4). This is encoded in a runtime condition on line 5. Finally, the advice body, when activated, simply calls the right paragraph (PERFORM statement on line 7).

We are left with the question of where METHOD-NAME is defined, and how it enters our program. The answer to the first question is simply this: any arguments which get passed into a Cobol program from the outside must be defined in a linkage section. I.e.:

Despite the inherent complexity of the problem, AOP+LMP allowed us to write down our crosscutting concern in a generic way with certain ease. LMP was lever- aged to define our aspect by reasoning over the program, while AOP was used to tackle the actual modification of the application. Granted, we quite happily made use of a slicing predicate to do most of the hard work (line 11). Still, the use of libraries which hide such algorithms is another bonus we can get from LMP.

The Y2K-bug is probably the best-known example of unexpected change in legacy systems, somewhere ahead of the conversion to the Euro currency. It is important to understand that at the heart of this was not a lack of technology or maturity thereof, but rather the understandable failure to recognize that code written as early as the sixties would still be around some forty years later. So might AOP+LMP have helped solving the problem? The problem statement certainly presents a crosscutting concern: whenever a date is accessed in some way, make sure the year is extended.

The biggest problem lies in the weaving. When committed to a source-to-source approach, as we are with Cobble, weaving anything below the statement level 9 becomes impossible. As Cobol lacks the idea of functions 10 , we can not replace access to a data item with a call to a procedure (whether advice or the original kind) as we could do in C. The remedy for this would be to switch to machine-code weaving, but we are reluctant to do so, as we would lose platform independence. Common virtual machine solutions (e.g. as with ACUCobol) are not widespread either.

As for the Y2K restructuring problem, the semantics of Cobol, especially its lack of typing, present too much of a limitation for an AOP solution. In C, the Y2K38 problem can still be managed reasonably, precisely because it does feature better typing support. Also, the limited number of C dialects makes it much easier to build a widely useful aspect weaver.

