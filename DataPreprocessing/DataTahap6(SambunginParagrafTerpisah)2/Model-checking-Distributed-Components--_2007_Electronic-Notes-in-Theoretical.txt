Amongst the research work being done on the formalisation of distributed com- ponent behaviour, the closest to our motivations certainly is the one developed by the Sofa team [17], similar to the Fractal component model. In Sofa, components have a frame (specification) and an architecture (implementation) protocols, and verification is done through a trace language inclusion of the architecture within the target frame. In a different flavor, the work of Carrez et al on behavioural typing of components [7] defines a sound assembly and compatibility concepts which ensure correctness of the composition, but in a framework based on the Corba component model CCM [15], where they have no hierarchy of components.

There exist a number of verification platforms for process algebras. The only one supporting behaviours of hierarchical components that we are aware of is Sofa; it includes a static analysis module based on the Java Path Finder tool, and a home-made model-checker implementing the Sofa compliance relation. The main difference with our approach is that being based on a trace language semantics, they have no support for (congruent) minimization of state space.

For addressing as early as possible the well-known issue of state-explosion, we include in ADL2N a number of hiding and abstraction techniques. Hiding is used by individually selecting which method calls the user wants to observe, while the others become unobservable. Data domain abstraction has been discussed in the introduction.

We have defined Parameterized FC2 as an instance of FC2, using the extension mechanism of the FC2 syntax and adding elements for parameters and operators (reference manual in [2]). It is a textual format for compatibility reasons, but not intended to be written by humans. It has the advantages of being structured and compact, and that one given parameterized model could later be transformed using different instantiations.

The parameterized network is the input for the tool FC2Instantiate. Given a system of communicating LTSs with parameters and the domain of its unbound parameters, FC2Instantiate is a Java tool that generates a finite system of com- municating automata by translating each of the parameters to all the values in its domain. The output is in FC2 format.

The LOTOS specifications of primitive components are compiled into LTSs using the CAESAR tool of CADP. In addition, we need to map the names of the LOTOS gates and offers with the actions specified in the pNets. Currently this is not done automatically by our tools and must be provided by the user.

the corresponding diagnostic is shown in Listing 3. Breadth-first-search is used to find the shortest trace. We believe our platform is able to exhibit more compact traces than the ones found by Sofa [16], that contain interleaved actions not related to the deadlock.

We modelled the login method as being void, which means no confirmation is sent back to the user with his new status, thus it is natural that the client logs in again. Supposing he does log in twice, the Arbitrator, still processing the first login call, queries the database for the ticket information, then tries to send back the new access policy to the Firewall. The problem arises because the latter is blocked trying to make a second login call to the Arbitrator. It is a clear deadlock, yet realistic and difficult to detect without exhaustive tools, that can be model-checked with this methodology.

Remark that this interesting result was detected in a synchronous call context. A ProActive implementation of the system would not deadlock due to asynchronous services provided by the library. As in our current version of ADL2N asynchronous mechanisms are not modelled, the analysis of this scenario is not yet possible. We shall relieve this limitation as soon as the new version of ADL2N (see section 4) is released.

The new version of the ADL2N tool includes a two-phases compilation of ADL files. First, we create an abstract model encoding the common semantics between different Fractal implementations. Then, all implementation-specific controllers are added depending on the component model the user selects.

Of particular interest are tools that deal directly with some classes of param- eterized or infinite models. We expect to study the connection with tools such as FAST or TReX, from the Persee Project [11]. Integrating these techniques into our models is not trivial, but they could allow infinite (yet regular) systems to be checked directly from the parameterized models, avoiding the state-explosion that occurs during the instantiation.

Although our platform is not yet complete, we believe it is a step towards a realistic automatic component verification framework. Many intermediate formats are used through the process, but the platform is evolving to relieve the overhead of manipulating these complex languages through the use of automatic or quasi- automatic tools that we provide. We expect to attract ProActive users by providing useful diagnostics of non-trivial design flaws.

