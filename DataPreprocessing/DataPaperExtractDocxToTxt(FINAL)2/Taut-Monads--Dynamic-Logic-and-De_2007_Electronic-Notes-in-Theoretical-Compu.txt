

Electronic Notes in Theoretical Computer Science 173 (2007) 241–262
www.elsevier.com/locate/entcs

Taut Monads, Dynamic Logic and Determinism
Ernie Manes 1
Department of Mathematics and Statistics University of Massachusetts Amherst, MA 01003, USA

Abstract
Studied are Kleisli categories of monads of sets which satisfy two properties motivated by functional prop- erties of collections. Such categories have box and diamond operators which follow the laws of (loop-free) dynamic logic. A theorem of Kozen states that the category of sets and relations is complete for loop-free dynamic logic. It is shown that the Kleisli category of the filter monad is likewise complete. A morphism α is deterministic if <α> Q ⊂ [α]Q for all Q. Each “output value” αx is associated with a filter which is forced to be an ultrafilter when α is deterministic and αx is defined. Early work in the theory of domains abstracted from the partially ordered set of partial functions between two sets, ordered by extension. A different abstraction, suited to conditional constructs rather than recursive fixed point equations, is the no- tion of a locally Boolean poset, and this is used to compare restriction categories with deterministic Kleisli categories. The laws of dynamic logic in terms of [α]Q and <α> Q for a single α hold in any topological
space with [α]Q the interior operator and <α> Q the closure operator.
Keywords: dynamic logic, collection type, taut monad, Boolean category, deterministic map, locally Boolean poset, filter, restriction category


Introduction
In this paper, a monad T in the category Set of sets and (total) functions induces three constructs of interest. The first is the Kleisli category SetT which may be thought of as the category in which expressions are evaluated when the monad class T has been activated. The second is the category SetT of algebras over the monad, which is used to determine if the monad is of collection type. The third is a class of topological spaces determined by certain endomorphisms of the Kleisli category whose box and diamond operators are the interior and closure operators.
A function f : X → Y maps a “point” x to another point f x. When the outputs are more general “distributions” on Y , write the set of such distributions as TY and consider functions of form f : X → TY . Carrying this line of thought to

1 Email: manes@math.umass.edu



1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2007.02.037

its logical conclusion leads to the Kleisli category of a monad in Set. [10] is the first paper to classify monads from this point of view. More recently, programming interpretations have been given to such monads, “notions of computation” in [16] and monad classes (as in Haskell) in [21] where one “keeps the code and changes the monad on the fly”.
In three papers [12,13,15], the author has explored monads suitable to describe collection data types. A collection is a structure which holds values. A deterministic collection is such a structure which holds at most one value, and this paper studies such deterministic monads. In the finitary case, there are few surprises. In the infinitary case, however, the most generalized “deterministic value” (as is forced by the theory, not by definition) is an ultrafilter. The interpretation of an ultrafilter as a “generalized point” dates to the first paper about them [19].
But let us begin at the beginning.

Monads as Collection Types
η
We assume familiarity with the definition of a monad T = (T, η, μ) with id −−→
μ
T ←−− TT natural transformations subject to three equations and with the equiv-
alent formulation T = (T, η, (·)#) where α : X → TY '→ α# : TX → TY subject to three equations. (Monad basics can be found in [14], and uncited defi- nitions and facts throughout the paper can be found there). The Kleisli category SetT has sets as objects, functions X → TY as morphisms X → Y with com-

position β ◦ α = X
−−α→ TY 
β#
−−→ TZ and ηX as the identity morphism of X.

That this forms a category is the essence of the axioms on a monad. Recall that

α# = TX 
−T−→α 
TTY	μY
TY and that μX
= (idTX 
)# and for f : X → Y ,

Tf = (f o)# where f o = X	f
η
−−→
TY . For Lemma 2.24 and Proposition 5.7,

we recall that a monad map λ : (S, η, (·)#) → (T, η, (·)#) is characterized by the equations ηλ = η and the following commutative squares induced by α : X → SY :
SX	λX) TX

α# v
v(λY α)#

SY 	) TY
λY
Example 2.1 The list monad is L = (L, η, μ) with LX the set of all lists [x1,... , xn], (n ≥ 0), with xi ∈ X; (Lf )[x, ... , xn] = [f x1,... ,fxn]; ηX (x) = [x]; μX[w1,... , wn] is the concatenation w1 + ··· +wn. For α : X → LY , α#[x1,... , xn] is obtained by substituting α(xi) for xi and then flattening.
Aspects of the monad structure are subject to well-known functional program- ming interpretations and we discuss two such aspects using the list monad as a specific example. Lf is M ap f and we generally give this interpretation to Tf . Similarly, μX is thought of as a “flatten” operator. Not every monad would be- have correctly with respect to such interpretations about collections. One imagines that there is a large wish list of potential axioms for a useful theory. Surprisingly,

we shall require only two such axioms. In what follows, we write 2 = {0, 1} with 0 = F alse, 1 = True. Thus the characteristic function χA : X → 2 of A ⊂ X satisfies χ−1(1) = A. The two properties can loosely be expressed as follows.
Given A ⊂ X, there exists a 2-valued functional expression to determine if
τ ∈ TX holds only elements of A.
Given that τ ∈ T 22 holds elements in A ⊂ T 2 and that each element of A holds only the value True, then μ2(τ ) holds only the value True.
That these properties hold for the list monad is easily seen. Consider Boolean
L(χA)

“and” ∧ : L2 → 2 with ∧[x1,... , xn] = 1 ⇔ xi = 1 for all i. Then LX
∧
−−−−→

L2 −−→ 2 is true of [x1,... , xn] if and only if each xi ∈ A.	Thus the desired
functional expression to establish (1) is that which maps χA on the input list and then folds the result with “and”. (2) asserts that each symbol in w1 + ··· +wn is True if and only if this holds for each wi.
It is not hard to formalize (1,2) as requirements for an arbitrary monad of Set. T preserves monics (even empty ones) [13, Page 84]. Hence for A ⊂ X, “TA ⊂ TX” so that TA formalizes {τ ∈ TX : τ holds only elements of A}. In particular, ψ = χT 1 : T 2 → 2 formalizes the elements of T 2 which hold only 1 (where, recall, 1 = True). Thus the functional expression to determine if τ ∈ TX 
T (χA)	ψ
holds only elements in A ⊂ X is TX −−−−→ T 2 −−→ 2 and the formal statement
that this expression works is that the squares
TA 	) 
Ti	1	(3)
v	v
	)
TX	ψT (χA)	2
(which always commute) are pullbacks. (Here, A ⊂ X has inclusion i : A → X. We use as a one-element set rather than 1 to avoid confusion with True). For A = {1} ⊂ 2, χA = id so if (3) is always a pullback, the square
T 	) 1


T (True)
v
	)
True
v

T 2	ψ	2
in particular is, that is in general,
(4)	ψ = χT 1
(2) may be expressed by saying that for τ ∈ TT 2, μ2(τ ) ∈ T 1 ⇔ (T χT 1 )τ ∈ T 1, that is, the square



TT 2
μ2
Tψ	) T 2
ψ	(5)

v	v
	)


commutes.
T 2	ψ	2

We are now ready to talk about the category SetT of algebras of the monad T. See [9,14] for basic facts. The objects are all (X, ξ) with ξ : TX → X the structure map satisfying the two equations at the left, with maps called T-homomorphisms satisfying the square on the right:

X	ηX ) TX
TTX 
T ξ) TX 
TX	T f) TY 

id	ξ
   v
μX	ξ
v	v
	)

ξ	θ	(6)
v	) v

X	TX	ξ	X	X	f	Y
By the monad laws for T, (T X, μX ) isa T-algebra. It is freely generated by X (in the same sense as one talks about free monoids, groups and modules), since for each
function f : X → Y with (Y, θ)a T-algebra, f # = TX Tf TY −−θ→ Y is the unique
T-homomorphism with f #ηX = f . The earlier α# : TX → TY is a special case of this construction. Thus to prove that two T-homomorphisms f, g : (T X, μX ) → (Y, θ) are equal it suffices to show equality restricted to the “generators” ηX , that is, that f ηX = gηX . By the naturality of μ, Tf : (T X, μX ) → (TY, μY ) is a T- homomorphism for any f : X → Y . By the middle square in (6), every structure map is a T-homorphism. This proves directly that f # : (T X, μX ) → (Y, θ) is a T-homomorphism.
The categories of form SetT are precisely the equationally definable classes of universal algebras (with not necessarily finitary operations) with the only exceptions being situations such as complete lattices whose free algebras are “too large to have a cardinal number”.
Say that a monad T is trivial if it has no algebra with two or more elements. In particular, |TX| ≤ 1. There are only two trivial monads, easily discovered by the reader, and we will henceforth work only with non-trivial monads. In that case, by taking cartesian products in the category of algebras, there exist algebras of arbitrarily large cardinality.
Lemma 2.2 For a non-trivial monad T = (T, η, μ), if a /= b ∈ X then ηX(a) ∈/ Tb 
in TX. (We abuse notation and write Ta for T {a}, here and elsewhere).
Proof  Let (Y, θ) bea T-algebra with at least three elements and let f, g : X → Y be functions with f a, f b, ga distinct and fb = gb. Then f #, g# : (T X, μX ) → (Y, θ) agree on Tb but disagree on ηX (a) so ηX(a) ∈/ Tb.	 
Corollary 2.3 For a non-trivial monad, ηX is componentwise monic.	 

In [13, Definition 3.1] a support classifier for a monad T was defined to be a T-algebra (2, ψ) satisfying that (3) is always a pullback. In that case, (4,5) hold since (4) follows from (3) being a pullback and (5) is one of the T-algebra equations in (6). Conversely, to show that (3)-pullback and (5) implies support classifier (with

ψ defined by (4)) we need only show the remaining algebra law that 2 η2
ψ
T 2 −−→

2 = id. By Lemma 2.2, 0 ∈/ T 1 so ψη2(0) = 0. As 1 ∈ T 1, ψη2(1) = 1. Thus the axioms (3)-pullback and (5), motivated by functional programming concerns about collections, are equivalent to the existence of a support classifier.
Example 2.4 Let TX be the set of all formal real linear combinations λ1x1 + ··· + λnxn with λi real and xi ∈ X, ηX (x)= 1x, α#(λ1x1 + ··· + λnxn)= λ1α(x1)+ ··· + λnα(xn), simplified in the usual way. The algebras are real vector spaces. Since there is no two-element real vector space, this monad has no support classifier.
We have motivated that T should have a support classifier and we now reap the benefits of known theorems. For that, a few definitions are needed. An inverse

f
image square is a pullback of X −−→ Y
j
←−− Q with j monic. A functor F is taut

if it maps inverse image squares to pullbacks (which are then necessarily inverse image squares). A natural transformation is taut if the naturality squares induced by monics are pullbacks. A monad (T, η, μ) is taut if T, η, μ all are.
Theorem 2.5 [13, Theorem3.3] A monad has a support classiﬁer if and only if it is non-trivial and taut.	 
In the interests of brief terminology, we will hence favor the term “taut monad” for a monad with a support classifier.
Example 2.6 The filter monad F = (F, η, μ) is a taut monad. Though well known, we review the definition here. FX is the set of all filters on X (i.e. the set of all filters on the Boolean algebra 2X ) including the improper filter 2X , (Ff )F = {B ⊂ Y : f −1B ∈ F}, ηX (x) is the principal ultrafilter prin(x) = {A ⊂ X : x ∈ A}, μX(H)= {A ⊂ X :  A ∈ H} (where  A = {F ∈ FX : A ∈ F}), α#F = {B ⊂ Y :
{x ∈ X : B ∈ αx} ∈ F}. By the theorems of [6,22], the category of F-algebras is
continuous lattices with morphisms that preserve directed suprema and arbitrary infima, the structure map ξ : FL → L of the continuous lattice L being the lim-inf operation ξ(F)=  F ∈F  F . F is taut with support classifier 2 with 0 < 1.
The filter monad is intimately connected with general taut monads as the next result shows.
Theorem 2.7 [13, theorem 3.3] A monad T is taut if and only if there exists a taut monad map T → F. In that case, the support map
supp
−−−−−−→ FX,	τ '→ {A ⊂ X : τ ∈ T A}
deﬁnes a canonical taut monad map T → F.
Any monad map λ : S → T for monads in a category K induces a forgetful func-

tor KT → KS defined by (X, TX	ξ
X) '→ (X, SX λX
ξ
TX −−→
X). Applying

this in the context of the previous theorem, we see that if L is any continuous lattice and T is any taut monad, then ξ : TL → L, ξ(ω)=  ω∈TA  A is a T-algebra. It is routine to check that if L = 2 with 0 < 1, then the resulting T-algebra is the support classifier of T.
We now veer off in what seems at first to be a totally unrelated direction, but which will provide us with yet another characterization of taut monads. We consider how to interpret loop-free dynamic logic [7,8,18] in a Kleisli category.
Definition 2.8 A category B is a Boolean category [11] if the following four axioms hold.
(B.1) B has finite coproducts. The initial object is denoted 0.

f
(B.2) For X −−→ Y
j
←−− Q, with j a coproduct injection, there exists a pullback

[f ]Q
i v
g) Q
vj

X 	) Y
f
with i a coproduct injection.
(B.3) A coproduct injection pulls back a coproduct to a coproduct.
(B.4) If X −−1→ X ←−1− X is a coproduct, then X is an initial object.
Proposition 2.9 [11, Proposition 5.15, Theorem 5.11] The following hold in any Boolean category.
Every coproduct injection is an equalizer. The subobjects of X represented by a coproduct injection are called summands of X and the class of such is denoted Summ(X).
Summ(X) is a Boolean algebra with least element 0 → X, greatest element 1: X → X, intersection via pullback and Boolean complement via (unique) coprod- uct complement. For Q, R ∈ Summ(X), Q → Q ∪ R ← R is a coproduct if and only if Q ∩ R = 0.	 
As explained in [11], a Boolean category is a semantic model of dynamic logic with box operator [f ]Q and diamond operator <f > Q = ([f ]Q')'. A number of examples will be given shortly.
For any monad T in a category K, there is a canonical functor K → KT which is the identity on objects and which maps f : X → Y to f o : X → TY (as defined at the beginning of this section). For a non-trivial monad in Set, η is pointwise monic, so this functor may be regarded as the inclusion of a subcategory. In general, this functor has a right adjoint, the functor which maps α : X → Y

in KT to α : X → TY in K. In particular, if P
−−i→ X	j
Q is a coproduct in

io	jo
K, P −−→ X ←−− Q is a coproduct in KT. We now come to a subtle point. Even
though coproducts in a category are unique up to isomorphism, the sub-poset of summands in K and KT can be quite different. First observe, that for every non- trivial monad, the Kleisli category is equivalent to the category of free algebras via

α : X → TY  '→ α# : (T X, μX ) → (TY, μY ). Consider the real vector space monad of Example 2.4. The Kleisli category of this monad is equivalent to the category of algebras, all real vector spaces, because every vector space has a basis. The only

nondegenerate coproduct decomposition of 2 is 
−−T−r−u→e
2 ←F−a−ls−−e
 . Now, T 2 is

the plane and the induced coproduct decomposition of the plane is as the direct sum of the x-axis and the y-axis. But any pair of distinct lines through the origin gives a coproduct decomposition in the Kleisli category. The four-element Boolean algebra 22 has been enlarged to a non-Boolean infinite poset of summands. From our current point of view, the summands are the tests of the assertion logic. In adding a monad “on the fly” we want the new assertion logic to apply to the same tests. But here we get ahead of ourselves, so let us turn to the requisite definition and theorem.
Definition 2.10 For a monad T in K, say that summands are standard if for

every coproduct P
−−α→ X	β
Q in KT there exists a coproduct A −−i→ X	j	B

in K and an isomorphism ϕ in KT such that the triangle
A	i	) X
ϕ	/’
	/
P
commutes in KT.
In the vector space example, summands are not standard. If in the triangle above, A is the x-axis and P is the line y = x, then A and P are isomorphic vector spaces but no isomorphism between them makes the triangle commute.
We are now ready to give our final characterization theorem of general taut monads.
Theorem 2.11 [15, Theorem 9.2] A non-trivial monad T is taut if and only if SetT is a Boolean category for which the functor Set → SetT is taut and for which summands are standard.	 
Any endomorphism α : X → TX in SetT is a “one-object model” of dynamic logic. This generalizes the Kripke models first introduced (see e.g. [8]).
The introduction of the box operator in SetT creates the need to better under- stand these pullbacks. This problem has a straightforward solution as follows.
Proposition 2.12 Let T be a taut monad, and let α : X → TY , P ⊂ X with inclusion i : P → X, Q ⊂ Y with inclusion j : Q → Y . Consider the squares

i	) X
TP   T i) TX 
P 	i ) X

β v  (A)
vα	β# v
(B)
vα#
β v  (C)	vα

jo	Y
TQ 	) TY 
Tj 
TQ 	) TY 
Tj 

where (A) is in SetT and (B, C) are in Set. Then if any square commutes, they all do. If any square is a pullback, they all are.

Proof	The result for (A,B) holds even more generally and for any monad in any category [11, Lemma 6.10 (2)]. Now consider the diagram
P	ηP ) TP	β	TQ 

i v (D)
vTi 
(B)
vTj 

X	ηX
) TX	) TY 
α#

whose perimeter is (C). As the naturality square (D) commutes, (C) commutes if
(B) does. Conversely, both paths in (B) are homomorphisms from the free algebra (TP, μP ) so (B) commutes if it commutes restricted to the “generators” ηP , that is,
(B) commutes if (C) does. Since (D) is a pullback as η is taut, (C) is a pullback if
(B) is. Conversely, as α# = μY (T α), β# = μQ(Tβ), the diagram

TP	T β) TTQ 
Ti v	vTTj 
μQ ) TQ 
vTj 

TX 	) TTY 
Tα 
) TY 
Y

and the tautness of T and μ give that (B) is a pullback if (C) is.	 
We now use the tools from Theorems 2.7, 2.11 to obtain a useful result:
Proposition 2.13 For T a taut monad, α : X → TY , Q ⊂ Y ,
[α]Q = {x ∈ X : Q ∈ suppY (αx)}
<α> Q = {x ∈ X : Q' ∈/ supp (αx)}
(where Q' = Y \ Q is the complement of Q in Y ).
Proof Because summands are standard in SetT, if (A) in Proposition 2.12 is a pullback, it constructs P = [α]Q in SetT. By that proposition, the pullback (C) in Set has P = [α]Q so that x ∈ [α]Q ⇔ αx ∈ TQ ⇔ Q ∈ suppY (αx). Thus
x ∈<α> Q ⇔ x ∈ ([α]Q')' ⇔ x ∈/ [α]Q' ⇔ Q' ∈/ supp (αx).	 
We round out the section by giving a number of examples and discussing their properties.
Example 2.14 Let E be a set of “exceptions”. Then (T, η, μ) is a taut monad if

TX = X + E, η
= X	inX
<inX ,inE,inE>

X	−−−−→ X + E, μX = X + E + E −−−−−−−−−−−→ X + E.
In the Kleisli category, a program behavior α : X → Y + E either maps x to an output y ∈ Y or raises an exception e ∈ E. (If divergence is considered as an exception in E, it is not “raised” of course). For β : Y → Z + E, β# =< α, inE > so (β ◦ α)x = e ∈ E if αx = e; that is, an exception“sticks”. For Q ⊂ Y we have
[α]Q = {x ∈ X : αx ∈ Q + E}
<α> Q = {x ∈ X : αx ∈ Q}
An algebra is a pair (X, p) where X is a set and p : E → X is any function. Homomorphisms f : (X, p) → (Y, q) satisfy ft = q. The support classifier is (2, p) with p(e) = True for all e. When E is empty, the Kleisli category is Set. When E has one element, the Kleisli category is the category Pfn of sets and partial

functions, and the category of algebras is the category of sets with base point. Here the box and diamond operators are
[α]Q = {x ∈ X : if αx is defined then αx ∈ Q}
<α> Q = {x ∈ X : αx is defined and αx ∈ Q}
We call the case when E has one element the exception monad and write it
Ex = (Ex, η, μ).
Example 2.15 The power set monad is the taut monad given by P = (P, η, μ) has PX = 2X , (Pf )A = fA = {fa : a ∈ A}, ηX (x) = {x}, μX (A) =   A, α#A = a∈A α(a). The Kleisli category is isomorphic to the category Rel of sets and relations where α : X → 2Y corresponds to the relation R ⊂ X × Y via
xR y ⇔ y ∈ α(x). For R ⊂ X × Y , S ⊂ Y × Z, the composition that corresponds to Kleisli composition is the usual one, x SR z ⇔ ∃ y, x R y, y S z. The algebras of this monad are complete sup-semilattices where the structure map ξ : PX → X is the supremum. Thus x ≤ y ⇔ ξ{x, y} = y. The support classifier is 2 with 0 < 1.
The box and diamond operators here are
[α]Q = {x ∈ X : αx ⊂ Q}
<α> Q = {x ∈ X : αx ∩ Q /= ∅}
Rel is the standard model of multi-valued semantics. One can choose submonads to enforce further properties, e.g. non-empty subsets or finite subsets; these are submonads because a singleton is non-empty and finite and because a non-empty union of non-empty sets is non-empty and a finite union of finite sets is finite.
Example 2.16 We continue the discussion of the list monad of Example 2.1. The algebras are monoids, where the structure map ξ : LX → X of a monoid (X, ·, 1) is ξ[x1,... , xn]= x1	xn. Conversely, given an algebra (X, ξ), define x · y = ξ[x, y]
with unit ξ[ ]. This is a taut monad; the support classifier is 2 with unit True and multiplication ∧, as was central to our earlier motivations. The box and diamond operators are defined by
[α]Q = {x ∈ X : αx ∈ LQ}  (possibly αx empty)
<α> Q = {x ∈ X : αx has a symbol in Q}
Example 2.17 Define the probability monad Pr = (P r, η, μ) as follows. Pr X is the set of all countable-support probability distributions Σx λxx with λx ∈ [0, 1] the real unit interval, and Σ λx = 1. “Countable support” means that λx /= 0
for at most countably many x. This is a submonad of the real-vectorspace monad
of Example 2.4. To see this, consider α#(Σx λxx) = Σx λxα(x) and use stan-
dard properties of absolutely convergent series: if α(x) = Σy βxy, Σy Σx λxβx =

Σx λx Σy
x = Σx
λx = 1. In the Kleisli category, outputs are probability dis-

tributions. Flipping a coin is a map α : 1 → {H, T }. Let β(H) cause two dice
to be summed whereas β(T ) causes one die to be rolled. The Kleisli composition β ◦ α :1 → {1,... , 12} performs a correct probability calculation. Noting that Pr 2 can be identified with [0, 1], the subobject classifier is the characteristic function of
{1}, [0, 1] → 2. The box and diamond operators are

[α]Q = {x ∈ X : if α(x)= Σ λyy, then λy /=0 ⇒ y ∈ Q}
y
<α> Q = {x ∈ X : if α(x)= Σ λyy then there exists y ∈ Q with λy /= 0}
y
We now paraphrase the Kozen completeness theorem [8] generalized to the set- ting of Boolean categories [11, Theorem 11.15].
Theorem 2.18 Let B be a Boolean category. For X an object of B, let βX be the set of ultraﬁlters on the Boolean algebra Summ(X). Deﬁne the Kozen functor K : B → Rel by KX = βX and, for α : X → Y , U (Kα) V ⇔ ∀ V ∈ V <α> V ∈ U . Then K is a taut functor which preserves ﬁnite coproducts. By the properties of this functor one shows that any valid sentence of loop-free dynamic logic which is true in Rel is true in B.	 
Remark 2.19 By Proposition 2.13, The Kozen functor for SetT is
U (Kα) V	⇔  ∀ V ∈ V {x ∈ X : V ' ∈/ suppY (αx)} ∈ U
Example 2.20 It follows from Theorem 2.7 that any non-trivial submonad of the filter monad F is taut. Here, the box and diamond operators are given by
[α]Q = {x ∈ X : Q ∈ αx}
<α> Q = {x ∈ X : Q' ∈/ αx}
We now offer a few heuristic remarks concerning proper filters as distributions. A proper filter F “homes in” in stages where each A ∈ F is a stage. When stages A1,... , An have been selected, A1 ∩ ··· ∩ An is a finer stage. Fixing α : X → FY , Q ⊂ Y , [α]Q = {x ∈ X : Q ∈ αx} is the set of all inputs whose outputs allow Q as a stage. The principal ultrafilter prin(x) is a true point because {x} is a stage. In general, the more stages the more a filter can home in so it is natural to consider maximal filters as generalized points. We assume the Boolean prime ideal theorem without further comment, so each (proper) filter is the (nonempty) intersection of the ultrafilters that contain it. The set of such ultrafilters is the set of generalized
points the filter homes in on.
A compact Hausdorff space may be regarded as a structure that realizes an actual point for each ultrafilter. Now β is a submonad of F and it is well known that its algebras are precisely the compact Hausdorff space whose structure map βX → X is ultrafilter convergence. The forgetful functor from continuous lattices to compact Hausdorff spaces induced by the monad map β → F assigns the Lawson topology.
The following proposition supports the single-valuedness of ultrafilters as op- posed to filters.
Proposition 2.21 If G is a submonad of β, the Kozen functor K : SetG → Rel
factors through Pfn.
Proof  Let α : X → GY and let U (Kα) V, U (Kα) W. If V /= W then, as V, W
are ultrafilters, ∃ V ∈ V with V ' ∈ W. Then <α> V = {x ∈ X : V ' ∈/ αx} ∈ U

and <α> V ' = {x ∈ X : V
∈/ αx} ∈ U. As any two elements of U have non-empty

intersection, there exists x with V, V ' ∈/
αx, and this is impossible as αx is an

ultrafilter. Thus V = W.	 
While Rel is the prototypical Boolean category, the theory of this section sug- gests that SetF is the prototypical taut-monad Kleisli category. This point of view can be pushed further by independently proving a “Kozen completeness the- orem” for SetF. To begin, first observe that for any monad map λ : S → T over any category K, there is an induced functor Hλ : KS → KT defined by

Hλ(X
−−α→ SY ) = X
−−α→ SY	λY
TY . For a taut monad with support map

supp : T → F, H
supp(X
−−α→ TY )	= X
−−α→ TY	suppY
FY . Comparing the

formulas of Proposition 2.13 and Example 2.20, [α]Q = {x ∈ X : Q ∈ supp(αx)} =
{x ∈ X : Q ∈ (Hsupp α) x} = [Hsupp α]Q, so that any dynamic-logic assertions which are universally valid in SetF must be universally valid in SetT. In particular, if an assertion holds in SetF it holds in Rel = SetP. Applying Theorem 2.18, we have
Theorem 2.22 Any loop-free assertion of dynamic logic that is valid in SetF is valid in all Boolean categories.	 
For the most standard collections such as lists, probability distributions, bags, and so forth, a distribution τ has a definite set of members mem(τ ), e.g.
mem[a, b, a, c, b] = {a, b, c}, for τ = Σ λx x ∈ Pr X, mem(τ ) is {x : λx /= 0}. In
such cases, supp(τ )= prin(mem(τ )) is a principal filter (prin(A)= {B : A ⊂ B}). The submonad of principal filters is the subsets monad prin : P → F. In the prin- cipal case, the completeness theorem for Rel results via a monad map to P. We formalize this definition as follows.
Definition 2.23 A taut monad is principal if its support map factors through prin : P → F. In that case, for τ ∈ TX, suppX (τ )= prinX (memX (τ )) = {A ⊂ X : memX (τ ) ⊂ A} which defines the subset memX (τ ) of members of τ .
The next lemma will be used in Proposition 5.7. This property was used as an axiom on collections in [12].
Lemma 2.24 Let T be a principal monad, α : X → TY , τ ∈ TX. Then

mem  (α#τ )  =	 
memY (αx)

x∈memX (τ)
Proof	Because mem : T → P is a monad map, the following square commutes (as reviewed at the beginning of Section 2).

TX 
α# v
TY 
memX) PX 
(mem
)	v
mem	PY 


α)#

Applying the definition of (·)# for the power set monad, we have

mem (α#τ ) = (mem  α)# mem  (τ ) =	 
memY (αx)	 

x∈memX (τ)
Deterministic Monads
Partial functions are deterministic in that it is not possible to witness two-valued behavior. This may be defined in any category as follows.
Definition 3.1 A morphism f : X → Y in any category is deterministic if for every coproduct decomposition Q −→ Y ←− Q' of Y there exists a commutative diagram
P  ) X (	 P '
v	vf	v
Q  ) Y (	 Q'
in which the top row is a coproduct decomposition of X. If, addition, this can always be done with both squares pullbacks, we say f is crisp.
This definition does not require any coproducts or pullbacks to exist. For the Kleisli category of any monad in Set, coproducts are disjoint unions which meshes well with the philosophy behind the definition.
Definition 3.2 A monad is deterministic if all morphisms in its Kleisli category are deterministic. Similarly, a monad is crisp if all morphisms in its Kleisli category are crisp.
Example 3.3 Let β٨X = {U ∈ FX : U is an ultrafilter or U = 2X }. We check that β٨ is a submonad of F . We have prin(x) ∈ βX ⊂ β٨X. Now let α : X → β٨Y , U ∈ β٨X. We must show that α#U = {B ⊂ Y : {x ∈ X : B ∈ αx} ∈ U} ∈ β٨Y . Clearly U = 2X ⇒ α#U = 2Y . Otherwise, U ∈ βX. Let B ⊂ Y . To show: B ∈ α#U or B' ∈ α#U (possibly both). Suppose B ∈/ α#U. As U is an ultrafilter, U = {x : B ∈/ αx} ∈ U. For x ∈ U , αx /= 2Y so αx ∈ βY and {x : B' ∈ αx} = U ∈ U, so B' ∈ α#U as desired.
It is easy to check that the β∗-algebras are compact Hausdorff spaces with base point and that the discrete space 2 with base point True is the support classifier.

Definition 3.4 In a Boolean category, f : X → Y is total if [f ]0 = 0.
Lemma 3.5 [11, Proposition 12.2, Corollary 12.3] For f : X → Y in a Boolean category, the following hold.
f is total ⇔ ∀ Q  <α>Q ⊃ [α]Q.
f is deterministic ⇔ ∀ Q <α>Q ⊂ [α]Q.
f is crisp ⇔ ∀ Q  <α>Q = [α]Q.

f is crisp ⇔ Q '→ [f ]Q is a Boolean algebra homomorphism Summ(Y ) →
Summ(X).	 

Thus a map in a Boolean category is crisp if and only if it is total and deter- ministic.
By [13, Proposition 3.12] any submonad G of the filter monad F is taut and the inclusion ι : G → F is a taut monad map.

For f : X → Y a function and T a taut monad, f o = X	f
η
−−→
TY is

crisp in SetT. the converse is far from true, as we see in the next proposition, which provides further evidence that ultrafilters are like points.
Proposition 3.6 Every submonad of β is crisp.
Proof Let G be a submonad of β . For α : X → GY , [α]Q = {x ∈ X : Q ∈ αx} and <α> Q = {x ∈ X : Q' ∈/ αx} = {x ∈ X : Q ∈ αx} as αx is an ultrafilter. Thus [α]Q = <α> Q so α is crisp.	 
We can now relate deterministic maps to β∗.
Proposition 3.7 For a taut monad T, T is crisp if and only if supp : T → F
factors through β. T is deterministic if and only if supp factors through β∗.
Proof For α : X → TY is crisp ⇔ ∀ Q [α]Q =<α> Q. By Proposition 2.13 this happens if and only if (∀ x ∀ Q Q ∈ supp(αx) ⇔ Q' ∈/ supp(αx)) ⇔ ∀ x αx ∈ βX. As any τ ∈ TX has form αx for some α, this proves the first statement. Similarly, α is deterministic ⇔ (∀ x ∀ Q Q' ∈/ supp(αx) ⇒ Q ∈ supp(αx)) ⇔ ∀ x αx ∈ β٨X. 

Corollary 3.8 Any taut monad T contains a largest crisp submonad Tcrisp whose Kleisli category consists of the crisp morphisms of SetT. Similarly, T has a largest deterministic submonad Tdet whose Kleisli category consists of the deterministic morphisms of SetT.
Proof Form the pointwise pullbacks (which are pullbacks in the category of mon- ads and monad maps)
Tcrisp 	) Tdet 	) T

v	v
	)		)
supp
v

β	β∗	F
and then use the Proposition. (All monad maps in the diagram are taut).	 
Lemma 3.9 Let S, T be taut monads, λ : S → T a taut monad map. Then if T
is deterministic so, too, is S; if T is crisp then S is also.
Proof	For α : X → SY , Q ⊂ Y with inclusions j : Q → Y , j' : Q' → Y , consider the diagram whose explanation follows:

P 	i	) X
β
'
P '
α	β'

v	Sj
v	Sj'	v

SQ 	)
SY (	 SQ'

λQ v
TQ 	)
Tj 
λ
v
TY (


Tj'
λ '
vQ
TQ'

The bottom squares are the naturality squares for λ induced by the monics j, j' and so these are pullbacks. As λY α is deterministic in SetT by hypothesis, there exists P ⊂ X with inclusions i : P → X, i' : P ' → X and maps P → TQ, P ' → TQ' completing the perimeter of the diagram. By the pullback property, these maps factor via β, β' through SQ and SQ', completing the diagram. Thus α is deterministic. If λY α is crisp as well then, from the same diagram, using elementary pullback-pasting and the fact that S preserves monics, α is crisp. 
Theorem 3.10 Let T be a taut monad in Set. Then T is deterministic if and only if there exists a taut monad map T →β∗. T is crisp if and only if there exists a taut monad map T → β.
Proof We give the proof for “deterministic”, the crisp case being entirely similar. If T is deterministic, by Proposition 3.7, supp = T −−λ→ β∗ −−ι→ F with ι the submonad inclusion. As ι and ιλ are taut monad maps, so is λ. Conversely, suppose
λ : T → β∗ is a taut monad map. The taut inclusion ι : β∗ → F is its own support map by [13, Proposition 3.6] so that β∗ is deterministic by Proposition 3.7. Thus T is deterministic by Lemma 3.9.	 
We emphasize that T is necessarily a taut monad if it admits a taut monad map to a taut monad, so the a priori assumption that T be taut in the previous theorem is necessary only in one direction.
Example 3.11 The exception monad Ex of Example 2.14 is taut and deterministic since
prin  +id
−−−−−−−−−−−→ β٨X
is a taut monad map. (This holds, as well, for any set E of exceptions in that example).
Theorem 3.12 Let T be a principal taut monad. Then T is deterministic if and only if T admits a taut monad map to the exception monad.
Proof	If prin(A) is an ultrafilter, A is a singleton so β∗X ∩ PX = Ex X.	 
At this point one might wonder if every deterministic taut monad admits a taut monad map to the exception monad. The next example shows that this is not the case.
Example 3.13 There is no monad map β∗→ Ex. To see this, note that the variety of Ex-algebras is the category Set∗ of sets with base point whereas, as has already been discussed above, the variety of β∗-algebras is the category CT2∗ of

compact Hausdorff spaces with base point. It must be shown, then, that there is no forgetful functor H(X, ∗) = (X, ∗, 7 ) with 7 a compact Hausdorff topology on X in such a way that every function f : (X, ∗) → (Y, ) with f (∗) =  is such that f : H(X, ∗) → H(Y, ) is continuous. To find a contradiction, suppose that such H exists and choose X = {x1, x2,.. .} with base point x1 and write

H(X, x1) = (X, x1, 7 ). By Hausdorff, there exists ∅ /= U ∈ 7 with x1 ∈/
U . For

any ∅ /= A ⊂ X with x1 ∈/ A, let f : X → X be any function with f (x) = x1 if
x ∈/ A whereas f (A) ⊂ U . Then A = f −1(U ) is open. This shows that X \ {x1} is an open discrete subspace. Now let x1 ∈ V ∈ 7 . As {V }∪ {{x} : x ∈/ V } has a finite subcover, X \ V is finite. Thus if £ is the one-point-compactification topology induced by adding x1 to the locally compact discrete space X \ {x1}, 7 ⊂ £. As both topologies are compact Hausdorff, 7 = £. Now let g : X → X be defined by g(x1) = x1, g(x) = x2 if x /= x1. As lim(xn : n = 0, 1,... , ) = x1, g is not continuous. This is the desired contradiction.
Example 3.14 Reldet = Pfn. For the submonad P0 of the subsets monad P, P0X = {A ⊂ X : A is finite}, The Kleisli category is the category of sets and finite-valued relations. The deterministic maps also produce the category Pfn.
Example 3.15 Let L = (L, η, μ) be the list monad. The deterministic maps f : X → LY in SetL satisfy fx = yn for some y ∈ Y , n ≥ 0 because Ld arises as the pullback
Ld 	) Ex
v	v
L	mem ) P0
where EX = X +  —→ P0X maps x to {x} and the unique element of  to ∅. Noting that y0 = z0 even if y /= z, let N+ = {1, 2, 3,.. .}, and define LdX = (X ×N+)+{⊥}. In the Kleisli category, maps are partial functions whose values include an integer
≥ 1 and these integers multiply when maps are composed.
Example 3.16 Let M be a monoid with unit e and multiplication mn. Let






μ
————→
TX	=  (X + {⊥}) × M
η
————→ TX,	x '→ (x, e)
TX,	(⊥, m) '→ (⊥, m),  ((x, m), n) '→ (x, mn)

Such T is a deterministic taut monad. When M is (N, +, 0), the morphisms may be interpreted as partial functions whose values return a computation time.
Example 3.17 It is obvious that Fdet = β∗. It is easily checked that NX = {J ∈ FX :  J /= ∅} is a submonad of F. We called this the neighborhood monad in [10] since the most well known example of elements of NX are neighborhood filters in a topological space. As NX ∩ β∗X is the set of principal ultrafilters on X, Ndet = N ∩ β∗ is the identity monad. Thus the only deterministic maps in the Kleisli category of N are the ordinary total functions between sets.

The N-algebras are “continuous lattices without top”. A more precise descrip- tion is as follows. An N -semilattice is a partially ordered set with all non-empty infima (and hence all bounded suprema) such that for every non-empty family (Di : i ∈ I) with each Di a bounded directed subset of X, the following equation
holds:
  (  Di) =	   (  di)
i	d∈Q Di i
We leave it to the reader to verify that SetN is the category of all N -semilattices with morphisms that preserve non-empty infima and bounded directed suprema. (Hint: show that (NX, ⊂) is the free N -semilattice generated by X with f # : NX → Y defined by f #(J)=  A∈F  (f A) ).

Comparison with Restriction Categories

Definition 4.1 A restriction category [4] is a category equipped with a unary operation f : X → Y '→ f : X → X subject to the following four axioms:
(R.1) For f : X → Y , f f = f .
(R.2) For f : X → Y , g : X → Z, f g = g f .
(R.3) For f : X → Y , g : X → Z, g f = g f .

f
(R.4) For X ——→ Y
g



——→ Z, gf = f gf .



In any restriction category, each endomorphism of form f : X → X is an idempo- tent. We call it a restriction idempotent and the set R(X) of all such restriction idempotents is a commutative idempotent semigroup and so forms a semilattice. The interpretation of f is “the domain of definition of f ”, e.g. fx = x if fx is defined and is otherwise undefined. It is discussed in precise detail in [5] that the axioms are not compatible with “more than one exception”, so our discussion here is only intuitive. In any restriction category, a morphism f is total if f = id. Any category is a restriction category if all maps are declared total, so that there need not be any exceptions. The interpretation of Axiom (R.4) is that all maps are de- terministic. To see the idea, suppose fx includes two distinct outputs a, b. Let ga be defined, gb not. Then b is an output of f gf x = fx whereas gf x = a so (R.4) fails.
Let us be more precise for SetT with T taut. View T ∅ (the distributions on the empty set) as the set of exceptions of T. The condition that there is exactly one exception is then that T ∅ = and we call T a zero monad if it satisfies this condition since then ∅ is the zero object of the Kleisli category. This Kleisli category then has a natural definition of restriction as follows:
Definition 4.2 For α : X → TY with T a zero monad, define α : X → TX by the following diagram in which the top row is a coproduct:

[α]∅
'
X	([α]∅)

v	vα	vi
T ∅ 	) T X(	 X
Tj'	ηX
where i', i,j are inclusions.
Theorem 4.3 [15, Theorem 6.4] For a taut zero monad T with the restriction operator of Deﬁnition 4.2, SetT is a restriction category if and only if T is a deterministic monad.	 
Example 4.4 The monad β∗ is a deterministic zero monad. F is a zero monad which is not deterministic. β and N are not zero monads.
The intense study of domains in computation theory begins by observing that the set Pfn(X, Y ) of partial functions from X to Y is ordered by extension. This is available in any restriction category as follows.
Every restriction category is an ordered category. For f, g : X → Y say that f ≤ g if g f = f , literally “g restricted to the domain of f is f ”. This is always a partial order and composition on either side is monotone.
The study of domains has for the most part not focused on the more mundane programming constructs such as if-then-else. But this construct is readily available in the ordered category Pfn: if P ⊂ X with inclusions i : P → X, i' : P ' → X, and f, g : X → Y , if P then f else g : X → Y is f i ∨ gi'. What happens here, is that the semilattice R(X) of restriction idempotents is 2X and this is the Boolean algebra of tests. A general class of ordered sets that have the necessary structure was introduced in [5], and are defined next.
Definition 4.5 A partially ordered set P with a least element 0 is a locally Boolean poset if for all x ∈ P the principal downset ↓x = [0, x] is a Boolean algebra whose finite suprema are suprema in P . If P, Q are locally Boolean posets, a function f : P → Q is a locally Boolean map if f is monotone, f (0) = 0 and, for all x, the induced function [0, x] → [0,f x] is a Boolean algebra homomorphism. Denote the category of locally Boolean posets as LBP.
A natural associated class of restriction categories is then as follows.
Definition 4.6 A classical restriction category is a restriction category C which satisfies the following two axioms:
(CR.1) C is enriched over LBP, that is, the homset C(X, Y ) under the restriction ordering f ≤ g if g f = f is a locally Boolean poset and composition on either side is a locally Boolean map.
(CR.2) Denoting the least element of C(X, Y ) as 0 : X → Y , if f, g : X → Y are
disjoint, written f ⊥ g, in that f g =0 then f ∨ g exists in C(X, Y ).
We regard Boolean algebras as forming a variety of universal algebras. As such, 0 is the terminal object so [0, x] → [0, 0] is a Boolean algebra homomorphism.



Example 4.7 Pfn is a classical restriction category. Here, f (x)= x if fx is defined and is otherwise undefined. [0,f ] ∼= 2D with D = {x : fx is defined} is how homsets are locally Boolean posets. A somewhat more gradual explanation can be given as follows. In LBP, coproducts exist as the disjoint union poset with all least elements identified. Products exist in LBP using the pointwise-ordered product poset. Every Boolean algebra is a locally Boolean poset. Start with the Boolean algebra 2. The flat poset A⊥ obtained by adding a bottom element to discrete A a simply a typical copower of 2 in LBP. The locally Boolean poset power (Y⊥)X is precisely the poset Pfn(X, Y ). The local Booleanness of composing on either side now follows from standard properties of product and coproduct.
Ex is a deterministic zero monad and its Kleisli category (namely Pfn) is a classical restriction category. A surprise of this paper is that this happens for every deterministic zero monad.
Theorem 4.8 The Kleisli category of a deterministic zero monad T = (T, η, μ) is a classical restriction category.
Proof SetT is a Boolean category with zero maps and all maps deterministic, and is a restriction category as in Definition 4.2 by Theorem 4.3. That such a category is a classical restriction category is one of the main theorems of [5]. We briefly indicate how the locally Boolean structure arises in this specific context. The lattice structure of [0, γ] is as follows. If α, β, γ : X → Y with α, β ≤ γ. The infimum α ∧ β is αβ. The supremum α ∨ β is defined by

[α]∅ 	i ) X io
( j

α ∨ β
([α]∅)'
jo

v 	)	v (		v
TX	α	TY	β	TX 
where i, j are inclusions. Now, the restriction idempotents of X constitute the interval [0, 1] which is order-isomorphic to Summ(X) by [11, Theorem 8.15] and so forms a Boolean algebra. Thus [0, γ] is an interval in a Boolean algebra so is itself a Boolean algebra. It is shown that [0, γ] → [0, γ], α '→ α is an order isomorphism. 

Dynamic Logic of Spaces
In this section, we observe that for any topological space X there is an appropriate endomorphism α in a taut-monad Kleisli category for which [α]Q, <α> Q are, respectively, the interior and closure operators of the space. Thus any valid formula of dynamic logic involving one α is a law of topological spaces. We also study classes of topological spaces induced by taut monads. We begin with a general definition and proposition for taut monads.
Definition 5.1 Let T be a taut monad. A T-topological space is a pair (X, t) with t : X → TX an idempotent in SetT such that [t]Q ⊂ Q for all Q ⊂ X. A subset Q is t-open if [t]Q = Q.

Proposition 5.2 For a T-topological space (X, t), the t-open sets form a topology with interior operator [t]Q and closure operator <t> Q.
Proof ∅ is open since [t]∅ ⊂ ∅. By elementary facts about pullbacks, [t]X = X and [t](Q ∩ R) = [t]Q ∩ [t]R so X is t-open and a finite intersection of t-opens is t-open. If V =  Vi with each Vi t-open, x ∈ V ⇒ ∃ i x ∈ Vi = [t]Vi ⊂ [t]V so V is t-open. So far, the t-opens form a topology. For any Q ⊂ X, [t]Q is t-open since (in any Boolean category) [α]([β]Q)= [βα]Q and t is idempotent with [t]Q ⊂ Q. If x ∈ Q○ there exists U = [t]U with x ∈ U ⊂ Q. Thus x ∈ [t]U ⊂ [t]Q. This shows [t]Q = Q○. But then Q = Q'○ ' = ([t]Q')' =<t> Q.	 
Theorem 5.3 Every topological space is an F-topological space for the ﬁlter monad
F.
Proof	Let X be a topological space with neighborhood filter 𝒩x at x. Define
t : X → FX by tx = 𝒩x. Then t# : FX → FX maps J to {A ⊂ X : {x ∈ X : A ∈
𝒩x} ∈ J} = {A ⊂ X : A○ ∈ J} so that t#(tx)= t#(𝒩x)= {A ⊂ X : A○ ∈ 𝒩x} =
𝒩x, which shows t is idempotent. By Example 2.20, [t]Q = {x ∈ X : Q ∈ tx} =
{x ∈ X : Q ∈ 𝒩x} = Q○ so [t]Q ⊂ Q.	 
Example 5.4 Segerburg’s axiom [20] is
[α]Q ∩ <α> R  ⊂ <α> (Q ∩ R)
This example is obviously true in Rel, so by the Kozen completeness theorem it must hold in all Boolean categories. Hence any topological space must satisfy

Q○ ∩ R  ⊂  Q ∩ R
Example 5.5 In Rel, α : X → PY is a partial function if and only if for all subsets Q, R of Y , <α> (Q ∪ R) = <α> Q ∪ <α> R. Equivalently, α is a partial function if and only if <α> Q ⊂ [α]Q for all Q. It follows that a topological space is discrete if and only if (Q ∪ R)○ = Q○ ∪ R○ since Q ⊂ Q○ obviously forces discreteness.
It is clear that Theorem 5.3 can be proved using any submonad of F which contains all neighborhood filters, such as N. However, no submonads of β∗ will yield interesting spaces, as the following example attests.
Example 5.6 If T is a deterministic monad then every T-topological space is dis- crete. This follows from Lemma 3.5 (2) since any T-topological space satisfies Q ⊂ Q○.
A topological space is an Alexandroff space [1] if every intersection of open sets is open. It is well known that the category of Alexandroff spaces and continu- ous maps is isomorphic to the category of preordered sets (sets with reflexive and transitive relation) and monotone maps. The open sets are the lower sets, so ↓x is the minimum neighborhood of x, and the closed sets are the upper sets. Here, x ≤ y ⇔ y ∈ {x}.

Proposition 5.7 If T is a principal monad then every T-topological space is Alexandroff.
Proof	Let (X, t) be a T-topological space, so that t ◦ t = t, [t]Q ⊂ Q. We have [t]Q  =  {x ∈ X : Q ∈ supp(tx)}  =  {x ∈ X : mem(tx) ⊂ Q}
so Q is open if and only if mem(tx) ⊂ Q ⇒ x ∈ Q. Write x ≤ y if y ∈ mem(tx). As mem(tx) ⊂ mem(tx), x ∈ [t](mem(tx) ⊂ mem(tx), so x ≤ x. By Lemma 2.24,

mem(tx)  =  mem(t#(tx))  =	 
mem(ty)

y∈mem(tx)
so y ∈ mem(tx) ⇒ mem(ty) ⊂ mem(tx). Thus if x ≤ y, y ≤ z then y ∈ mem(tx), z ∈ mem(ty) ⊂ mem(tx) and x ≤ z. This shows that ≤ is a preorder. If x ∈ Q○ = [t]Q and x ≤ y then y ∈ mem(tx) ⊂ Q ⇒ mem(ty) ⊂ mem(tx) ⊂ Q, so y ∈ Q○. Thus Q○ is an upper set. Conversely, if Q is an upper set and x ∈ Q, y ∈ mem(tx) then x ≤ y ⇒ y ∈ Q so mem(tx) ⊂ Q. This shows that Q ⊂ [t]Q. We have shown that the open sets are the upper sets of a preorder, so the space is Alexandroff. 
Example 5.8 For P the power set monad, the P-topological spaces are precisely the Alexandroff spaces.
To see this, since P is a principal monad, the previous proposition gives that all its topological spaces are Alexandroff. Conversely, if t : X → PX is any reflexive and transitive relation then t ◦ t (being the composition in Rel) ⊂ t whereas t = t idX ⊂ t ◦ t, so t is idempotent. If tx ⊂ Q then x ∈ tx ⊂ Q so [t]Q ⊂ Q. Thus a reflexive and transitive relation is a P-topology. As tx =↑x, Q○ = [t]Q = {x :
↑x ⊂ Q}, the open sets are the upper sets. Hence an arbitrary Alexandroff space is a P-topological space.	 
The nicest results for G-topological spaces arise when G is a submonad of the filter monad and we conclude with some results of that type, beginning with
Proposition 5.9 Let G be a submonad of the ﬁlter monad F. Then the following hold.
If (X, t) is a G-topological space, ∀ x ∈ X, tx is the neighborhood ﬁlter 𝒩x of
x.
A space X arises as a G-topological space if and only if ∀ x ∈ X, 𝒩x ∈ GX.
Proof  Let (X, t) be a G-topological space. By Example 2.20, Q○ = [t]Q = {x ∈
X : Q ∈ tx} so that 𝒩x = {Q ⊂ X : x ∈ Q○} = {Q ⊂ X : Q ∈ tx} = tx. This proves the first statement from which the second is clear, given the proof of Theorem 5.3.	 
Despite the uselessness of submonads of β for producing spaces, as demonstrated by Example 5.6, the next proposition provides a construction which transforms arbitrary submonads of F (including of β) into useful submonads.

Proposition 5.10 Let G be a submonad of F. Then
G^X	= {J ∈ FX : J =  (Gi : i ∈ I) with I /= ∅, Gi ∈ GX}
is again a submonad of F.
Proof	For x ∈ X, prin(x) ∈ GX ⊂ GX. Now let α : X → GY , J ∈ GX and write J =  Gi with Gi ∈ GX. then B ∈ α#J ⇔ {x : B ∈ αx} ∈ J ⇔ ∀ i {x : B ∈ αx} ∈ Gi ⇔ ∀ i B ∈ α#Gi. As α#Gi ∈ GY , α#J =  i α#Gi ∈ GY .		 Recall [17] that a space has countable tightness if whenever x ∈ A there
exists a countable subset C ⊂ A with x ∈ C.
Proposition 5.11 Let βωX = {U ∈ βX : some member of U is countable}. Then
βω is a submonad of β and every β^ω -topological space has countable tightness.
Proof  For x ∈ X, prin(x) ∈ βω X since {x} is countable. Now let α : X → βωY , U ∈ βωX. Let A be a countable member of U and let Bx be a countable member of αx. Then C =  x∈A Bx is countable. For x ∈ A, Bx ∈ αx ⇒ C ∈ αx. Thus
{x ∈ X : C ∈ αx} ⊃ A so A is a countable member of α#U. This proves βω is
a submonad. Now let (X, t) be a βω -topological space. Applying Proposition 5.9,
'
every neighborhood filter is in β^ω X. Let x ∈ A. Then A ∈/ 𝒩x so there exists
V ∈ βωX with 𝒩x ∪ {A} ⊂ V. Let C be a countable member of V. Then A ∩ C is
a countable subset of A. As A ∩ C ∈ V, every neighborhood of x intersects it, so
x ∈ A ∩ C.	 

References
P. S. Alexandroff, U¨ber die Metrisation der im kleinen kompakten topologische Ra¨ume, Mathematische Annalen 92, 1924, 294–301.
Barr, M., Coequalizers and free triples, Mathematische Zeitschrift 116, 1970, 307–322.
Bird, R. and de Moor, O., Algebra of Programming, Prentice-Hall, Europe, 1998.
Cockett, J. R. B. and Lack, S., Restriction Categories I: Categories of partial maps, Theoretical Computer Science 270 (2002), 223–259.
Cockett, J. R. B. and Manes, E. G., From Boolean categories to classical restriction categories, to appear.
Day, A., Filter monads, continuous lattices and closure systems, Canadian Journal of Mathematics XXVII, 1975, 50–59.
Fischer, M. J., and Ladner, R. E., Propositional dynamic logic of regular programs, Journal of Computer and System Sciences 18, 1979, 282–294.
Kozen, D., A representation theorem for models of *-free PDL, in J. W. de Bakker and J. Van Leeuwen (eds.), Automata, Languages and Programming, ICALP ’80, Lecture Notes in Computer Science 85, Springer, 1980, 351–362.
Mac Lane, S., Categories for the Working Mathematician, Springer, Berline, 1971.
Manes, E. G., A class of fuzzy theories, Journal of Mathematical Analysis and Applications 85, 1982, 409–451.
Manes, E. G., Predicate Transformer Semantics, Cambridge University Press, 1992.
Manes, E. G., Implementing collection classes with monads, Mathematical Structures in Computer Science 8 (1998), 231–276.

Manes, E. G., Taut monads and T 0 spaces, Theoretical Computer Science 275 (2002), 79–109.
Manes, E. G., Monads of Sets, in M. Hazewinkel (ed.), Handbook of Algebra, Vol. 3, Elsevier, Amsterdam, 2003, 67–153.
Manes, E. G., Boolean restriction categories and taut monads, Theoretical Computer Science, 360 (2006), 77–95.
Moggi, E., Notions of computation and monads, Information and Computation 93 (1991), 55–92.
Moore, R. C. and Mr´owka, S., Topologies determined by countable objects, Notices of the American Mathematical Society 11, 1964, 554.
Pratt, V. R., Semantical considerations on Floyd-Hoare logic, Proceedings of the 17th IEEE Symposium on the Foundations of Computer Science, 1976, 109–121.
Riesz, F., Stetigskeitbegriff und abstrakte mengenlehre, Proceedings of the International Congress of Mathematicians, Series I, Fourth Congress, Rome, 2 (1908), 18–24; Kraus Reprint Limited, Nendeln/Liechtenstein, 1967.
Segerburg, K., A completeness theorem in the modal logic of programs, Notices of the American Mathematical Society 24, 1977, A-522.
Wadler, P., Comprehending monads, Mathematical Structures in Computer Science 2 (1992), 461–493.
Wyler, O., Algebraic theories of continuous lattices, Lecture Notes in Mathematics 871, Springer, Berlin, 1981, 390–413.
