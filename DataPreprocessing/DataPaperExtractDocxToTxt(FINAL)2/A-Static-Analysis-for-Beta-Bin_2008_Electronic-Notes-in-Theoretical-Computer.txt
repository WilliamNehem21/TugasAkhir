Electronic Notes in Theoretical Computer Science 194 (2008) 69–85	
www.elsevier.com/locate/entcs
A Static Analysis for Beta-Binders
Chiara Bodei
Dipartimento di Informatica, Universita` di Pisa,
Via Pontecorvo, 56127 Pisa - Italia
chiara@di.unipi.it


Abstract
We introduce a Control Flow Analysis, that statically approximates the dynamic behaviour of processes, expressed in the Beta-Binders calculus. Our analysis of a system is able to describe the essential behaviour of each box, tracking all the possible bindings of variables and all the possible intra- e inter-boxes commu- nications. The analysis offers a basis for establishing static checks of biological dynamic properties. We finally apply our analysis to an example, based on an abstract specification of the interaction between a virus and cells of the immune system.
Keywords: Control Flow Analysis, Beta Binders

Introduction
A recent research line exploits well established theories and techniques of Formal Methods for Systems Biology, by using them to support the interpretation of the big amount of raw biological data now available for analysis. Among the several formalisms used to this aim, we recall process calculi, that abstractly describe inter- actions and communications between independent agents or processes. In particu- lar, π-calculus [6] and Ambient Calculus [3] have been transferred from theoretical computer science setting to the biology setting, where suitable biological versions of them, such as the Biochemical stochastic π-calculus [15,17] and BioAmbients [16] have been introduced. Also a version of CCS, RCCS [4], that addresses biological issues, has been presented. Other calculi have been instead specifically defined for biological modelling, such as κ-calculus [5], Brane calculi [2] and Beta Binders [13].
The underlying idea is that a biological system can be abstractly modelled as a concurrent system. The behaviour is usually given in terms of its transition system, whose size can be huge, making its exploration computationally hard. Resorting to static techniques offers the possibility of drastically reducing the computational costs, particular high when modelling complex biological systems. The specifica- tion of the system is statically (i.e. at compile time) analysed in order to extract

1571-0661 © 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2007.12.006

information on the dynamic behaviour and to check the related dynamic proper- ties, without actually running the corresponding program. The price is a loss in precision, because these techniques usually give approximations of the behaviour.
We present here a control flow analysis for a subset of Beta Binders calculus. In this language, processes are enveloped inside boxes, that represent the borders of biological entities. Boxes are equipped with typed interaction sites, through which interactions inter-boxes can happen. Our control flow analysis safely approximates the behaviour of systems, tracking all the possible bindings of variables and all the possible intra- e inter-boxes communications. This information offers a basis
for studying dynamic properties, by suitably handling the approximation the static analysis introduces. We have indeed an over-approximation of the exact behaviour of a system. This means that all those events that the analysis does not include will never happen, while all the events that the analysis does include can happen,
i.e. they are only possible. Therefore, the analysis offers a basis for establishing static checks of biological dynamic properties. We can prove some basic facts, that can be immediately exploited to establish simple properties, such as the absence of interaction of two boxes or the isolation of a box.
The paper follows the tradition initiated by [10,9] of applying static techniques and, in particular, control flow analysis to process calculi used in modelling biolog- ical phenomena. These analyses are and can be inspired by the analyses previously applied to several process calculi, such as π-calculus (e.g. [1]) and Ambient calcu-
lus (e.g. [8]) to establish security properties. The biological framework requires a suitable tuning and, at the same time, can suggest the introduction of finer or new techniques.
The rest of the paper is organised as follows. In Section 2, we present the Beta Binders formalism. We introduce the Control Flow Analysis in Section 3. In Section 4, we propose some possible applications for our analysis. In Section 5, we show how the Control Flow Analysis works on an example. We conclude in Section 6 with an assessment of our approach.

The Calculus
We briefly introduce the kernel of Beta Binders and we refer the interested reader to [13,14] for more details. In particular, for the sake of simplicity, we do not consider the join and the split semantic constructs.

The syntax
Essentially, processes are the parallel composition of boxes that contain π-calculus like [6] processes. As in the π-calculus, communication can occur when an input and an output synchronize on a particular channel. Boxes represent the borders of biological entities and are equipped with typed interaction sites or binders, which regulate the interactions with the environment. As in the π-calculus, we assume the existence of a countably infinite set N of names (ranged over by lower-case letters).

Binders
A special class of binders, called beta binders is introduced. Each binder char- acterises an interaction site and an associated type.
Definition 2.1 An elementary beta binder has either the form β(x : Γ) (active binder) or the form βh(x : Γ) (hidden binder), where we let βˆ ∈ {β, βh} and:
the name x is the subject of the beta binder,
Γ is the type of x. It is a non-empty set of names such that x ∈/ Γ.
Definition 2.2 Composite beta-binders are generated by the following grammar:
B ::= β(x : Γ)| βh(x : Γ)| β(x : Γ)B| βh(x : Γ)B
A composite beta-binder is said to be well-formed when the subjects of its elemen- tary components are all distinct. We let well-formed beta-binders be ranged over by B, B1, B2,   Let sub(B) denote the set of the subjects of all the elementary beta
binders in B, and B∗ denote either a beta binder or the empty string of elementary beta binders.

Pi Processes
Processes, which are incapsulated into boxes, are a variation of standard π- calculus, that makes handling of beta binders possible from inside boxes. They are called pi processes.

P ::=	Pi Processes
nil	inactive process
(νy)P	restriction
P|P	parallel composition
!P	replication
xy	output
x(y)	input
expose(x, Γ)	addition of a new site hide(x)	hiding of a site unhide(x)	unhiding of a site
Pi processes behave just as π-calculus processes. The process nil is inactive. The name x in (νx)P acts as a static binder for x in P . The operator | describes parallel composition of processes. Intuitively, P and Q in P|Q act independently and can also communicate when one performs an input and the other an output on the same common link. Replication !P behaves as P|P|··· as many times as needed. The

output prefix xy sends name y on link x. The input prefix x(y) binds the name y
in the prefixed process. Intuitively, some name y is received along the link named
x. The additional prefixes expose(x, Γ), hide(x), unhide(x) are used to manipulate beta binders. Prefixes hide(x) and unhide(x) make the elementary binder with subject x not available (hidden) and available (not hidden), respectively. A hidden binder cannot be used in a communication. Finally, the prefix expose(x, Γ) adds the elementary beta binder β(x : Γ) to the box and acts as a binder for x in the process it prefixes. The definitions of name substitution and of free and bound names (defined as fn() and bn()) are treated as in the π-calculus and are extended to the above syntax in the obvious way. The names occurring in the types declared in expose prefixes are free, and therefore can be affected by substitution.

Beta Processes
The set of beta processes, ranged over by B, B1, B2, ... is defined as follows. Boxes are nameless entities, but to facilitate our analysis, we annotate boxes as in B[P ]μ, to distinguish different syntactic occurrences of boxes. We refer to μ ∈ Box as the identity of the box, where Box is the finite set of box identities.

B ::=	Beta Processes
Nil	inactive beta process B[P ]μ	basic beta process B||B	parallel composition
A beta process is either empty (Nil) or a single box (B[P ]μ) or the parallel composi- tion of two boxes (B||B). When in the above grammar B is taken to be well-formed, the generated process B is said to be well-formed. Graphically, each process (B[P ]μ) can rendered as a single box, where binders indicate the sites through which the boxes can interact with the external world. Finally, note that nesting of boxes is forbidden (see also Section 4).

Semantics
To simplify the definition of our control flow analysis in Section 3, we partition all the names used by a process into finitely many equivalence classes and we use the names of the equivalence classes instead of the actual names. This partition works in a way that names from the same equivalence class are assigned a common canonical name and consequently there are only finitely many canonical names in any execution of a given process. The canonical name [n♩ is for a name n. Not to further overload our notation, we simply write n for [n♩, when unambiguous. Furthermore, we demand that two names are α-convertible only when they have the same canonical name. In this way, we statically maintain the identity of values and variables that may be lost by freely applying α-conversions. Therefore, we discipline the α-renaming of bound values and variables, allowed by the structural

congruence given below. Finally, we assume that the bound names of a process are renamed apart and that they do not clash with the free names.
The semantics of beta processes is given in terms of a reduction semantics, that in turn, uses a structural congruence relation. Below we present the standard structural congruence ≡ on pi processes and beta processes.  The symbol ≡ is
overloaded and holds in both cases; the context can disambiguate the intended relation. The structural congruence over pi processes is standard and is the least congruence satisfying the following clauses:
P ≡ Q if P and Q are disciplined α-equivalent (as explained above);
(P≡, |, nil) is a commutative monoid;
(νn)nil ≡ nil,  (νn)(νn')P ≡ (νn')(νn)P ,  (νn)(P | Q) ≡ P | (νn)Q   if
n /∈ fn(P ),
!P ≡ P | !P
The structural congruence over beta processes is the least congruence satisfying the following clauses:
B[P ]μ ≡ B[Q]μ if P ≡ Q;
(B/≡, ||,Nil) is a commutative monoid;
B1B2[P ]μ ≡ B2B1[P ]μ,
B∗βˆ(x : Γ)[P ]μ ≡ B∗βˆ(x' : Γ)[P{x'/x}]μ, provided that [x'♩ = [x♩.
The axioms over beta processes state, respectively, that: (i) the structural con- gruence of pi processes is reflected at the level of boxes; (ii) the parallel composition of beta processes is a monoidal operation with neutral element; (iii) the actual or- dering of elementary beta binders within a composite binder is irrelevant; (iv) the subject of an elementary beta binder is a placeholder that can be changed at any time under the proviso that name clashes are avoided and well-formedness of beta binders is preserved.
The reduction relation, →, is the smallest relation over beta processes obtained by applying the axioms and rules in Table 1. The semantics preserves the well- formedness of processes. We assume that all the names are initially distinct. Fur- thermore, we use u˜ as a shorthand for {u1, ..., un} and (νu˜) for {(νu1), ..., (νun)}. The axiom Intra lifts to the level of beta processes any communication between pi processes within the same box. The axiom Inter models beta processes in- teractions between boxes with complementary action (input/output) over comple- mentary sites (with non disjoint types). When the types are non disjoint (dis- joint, respectively), we call them compatible (incompatible, respectively). The rules Expose, Hide, Unhide allow the dynamic modifications of beta binders. The rule Expose adds an extra site with the declared type: the name introduced is a place- holder which can be renamed to avoid clashes with the subjects of the other binders of the containing box. Finally, the rule Hide, Unhide force the specified site to become hidden and unhidden, respectively.




Table 1
Reduction semantics for Beta-Binders.

Static Analysis
We develop a control flow analysis for analysing beta processes, based on the analysis of π-calculus [1]. The aim of the analysis is to safely over-approximate all the possible behaviour.  The result of analysing a beta process B and a pi process P , is a tuple (ι, ϵ, ρ, κ), called estimate for B (P , respectively), that satisfies the judgements defined by the axioms and rules in the upper (lower, respectively) part of Table 2. The analysis is defined in the flavour of Flow Logic [7]. The first component ι gives information on the binders of boxes. The second component ϵ,

given a subject of a binder, gives information about the set of names it may be associated with. The third component ρ gives information about the set of values to which names can be bound. Finally, the last component, κ gives information about the set of channels that can be sent over given channels. The judgements for analysing beta processes and pi processes are (ι, ϵ, ρ, κ) |=∗ B and (ι, ϵ, ρ, κ) |=μ P , expressing respectively. More precisely,
∗ stands for the universe in which boxes are, while μ ∈ Box annotates |= to keep track of the box in which the process is.
ι : {∗} ∪ Box → ℘(Box) (N ∪ Nh ∪ Nu) is the binder repository, where Nh (Nu, resp.), ranged over by xh (xu, resp.) represent the set of names in the hidden (unhidden) version, and where N ∪ Nh ∪ Nu is ranged over by xˆ. In ι(∗) are collected all the names μ of the boxes under analysis and in ι(μ) all the binder names x that are declared in the box labelled μ, and that may appear in the form x, xh and xu. These last two keep track of the fact that the corresponding name can appear as hidden or unhiddent, respectively.
ϵ : Box → (N → ℘(N)) is the abstract binder environment that maps a binder of a certain box μ to its possible type set.
ρ : N → ℘(N) is the abstract environment that maps a name to the set of binders or names it can be bound to. We assume that for each name x, we have that ρ(x) ⊇ {x}. Moreover, we write ρ({v1, ..., vn}) as a shorthand for ρ(v1) ×  × ρ(vn).
κ : Box → (N → ℘(N)) is the abstract channel environment that maps a binder or a name occurring in a box μ, to the set of values that can be sent over it.
For keeping the analysis component finite, as said above, we have partitioned all the names used by a process into finitely many equivalence classes and we have used the names of the equivalence classes instead of the actual names.

Analysis of Beta Processes
The rule for inactive beta process does not restrict the analysis result, while the rule for parallel composition || ensures that the analysis also holds for the immediate subprocesses.
The rules for composite beta binders checks whether the types Γ of new binders are included in the component ϵ. Furthermore, in the active binder case (hidden binder case, resp.) the inclusion of x (xh, resp.) in ι(μ) is checked. Finally, when the string of beta binders is empty, the analysis keeps track of the label of the box and the pi process in the box is passed to the process analysis.

Analysis of Pi Processes
Similarly to the upper part rules, the rule for inactive pi process does not re- strict the analysis result, while the rules for parallel composition |, restriction, and replication ensure that the analysis also holds for the immediate subprocesses. The first condition of the rule for output requires that the set of names – recorded in



Table 2
Analysis for Beta Processes: (ι, є, ρ, κ) |=∗ B and for Pi Processes: (ι, є, ρ, κ) |=μ P .

the component κ – that can be sent along each element of ρ(x), inside the box μ, includes the set of values to which y can evaluate. The rule for input is more struc- tured, because it takes into account both the communication intra- and inter-boxes. The first conjunct (intra-) requires that the set of names that can be sent along a channel with the same name is included in the set of values to which y can evaluate. The second conjunct (inter-) requires that set of values to which y can evaluate includes the set of names that can be sent along a binder name b – provided that b is a binder that occurs active or unhidden in another box μ' – and received along a – provided that a is a binder that occurs active or unhidden in μ, under the condition that the type of b is compatible with the one of a . To exemplify, suppose to have the process P = x(y).P1| xz.P2 inside the box μP (see the complete example below). Since z can be sent along the channel x, then it should be included in κ(μP )(x), and therefore could be bound to the variable y occurring in the corresponding input on the shared channel x, i.e. {z}⊆ κ(μP )(x) ⊆ ρ(x). Moreover, imagine to have in parallel another process Q = u1v1.Q1 inside the box μQ, such that the types of x and of u1 are compatible (i.e. ϵ(μP )(x) ∩ϵ(μQ)(u1) /= ∅) and can both participate in a communication (i.e. {x, xu}∩ ι(μP ) /= ∅ and {u1, uu}∩ ι(μQ) /= ∅). Since v1 can

be sent on the channel u1, i.e. it should be included in κ(μQ)(u1), therefore it could be bound to y, because a communication between the boxes μP and μQ is possible.
The rule for expose demands that for all the possible values a of x, a is included in ι(μ) and all the possible values to which the elements of Γ may evaluate to are included in ϵ(μ)(a). The rule for hide (unhide, resp.) demands that for all the possible values a of x, ah (au, resp.) is included in ι(μ). Recall that an unhide prefix unhide(x) can only follow an hide or a declaration of a hidden binder and therefore there is no need to check whether ϵ(μ)(x) includes the type of x.

Example 1: Intra- and Inter-Box Communication
The analysis of the simple beta process B
B = BP ||BQ||BR = β(x : {c1, c2})[P ]μP ||β(u1 : {c1})[Q]μQ ||β(u2 : {c2})[R]μR ,
where P = x(y).P1| xz.P2	Q = u1v1.Q1	R = u2v2.R1
gives rise to the analysis components ι, ϵ, ρ and κ with the following entries:

ι(∗) = {μP , μQ, μR}
ι(μP ) = {x}	ι(μQ) = {u1}	ι(μR) = {u2}
ϵ(μP )(x) = {c1, c2}, ϵ(μQ)(u1) = {c1},	ϵ(μR)(u2) = {c2}
κ(μP )(x) = {z},	κ(μQ)(u1) = {v1},	κ(μR)(u2) = {v2}
ρ(y) = {z, v1, v2}	ρ(n) = {n} for n ∈ fn(B)

In fact, we have that,
(ι, ϵ, ρ, κ) |=μP P , because (ι, ϵ, ρ, κ) |=μP xz.P2 and (ι, ϵ, ρ, κ) |=μP x(y).P1;
(ι, ϵ, ρ, κ) |=μQ Q, because ρ(u1) ⊇ {u1}, ρ(v1) ⊆ {v1} and {v1}⊆ κ(μQ)(u1);
(ι, ϵ, ρ, κ) |=μR R, because ρ(u2) ⊇ {u2}, ρ(v2) ⊇ {v2} and {v2}⊆ κ(μR)(u2);
(ι, ϵ, ρ, κ) |=μP xz.P2, because ρ(x) ⊇ {x},  ρ(z) ⊇ {z} and {z}⊆ κ(μP )(x);
(ι, ϵ, ρ, κ) |=μP x(y).P1, because

{z}⊆ ρ(y), since {z}⊆ κ(μP )(x);
since x ∈ ι(μP ) and u1 ∈ ι(μQ) and ϵ(μP )(x) ∩ ϵ(μQ)(u1) ⊇ {c1} then {v1} ⊆ 
ρ(y), because {v1}⊆ κ(μQ)(u1);
since x ∈ ι(μP ) and u2 ∈ ι(μR) and ϵ(μP )(x) ∩ ϵ(μR)(u2) ⊇ {c2} then {v2} ⊆ 
ρ(y), because {v2}⊆ κ(μR)(u2);
Note that ρ(y) includes the value z, hence correctly predicting the possibility of a communication internal to BP on the channel x, that corresponds to the follow- ing transition (where we annotate the transition arrow → with the corresponding semantic rule):
B →(Intra) β(x : {c1, c2})[P1{z/y}| P2]μP ||β(u1 : {c1})[Q]μQ ||β(u2 : {c2})[R]μR

Moreover, it includes both v1 and v2, therefore correctly predicting that an inter- action between BP and either BQ, accounting for the following transition with BQ (similarly with BR):
B →(Inter) β(x : {c1, c2})[P1{v1/y}| P2]μP ||β(u1 : {c1})[Q1]μQ ||β(u2 : {c2})[R]μR

The binder x, u1 and u2 are included in their active form inside ι(μP ), ι(μQ) and ι(μR), respectively. Moreover, the condition ϵ(μP )(x)∩ϵ(μQ)(u1) = {c1} shows that the types of x and u1 are compatible and a similar condition holds for the types of x and u2.

Example 2: Interface Handling (1)
The analysis of a slightly different beta process B'


B' = B' ||B ||B'
= β(x : {c ,c })[P ']μ' ||β(u : {c })[Q]μQ ||β(u
: {b })[R]μ' ,

P	Q	R
1  2	P	1	1
2	2	R

where P ' = x(y).expose(z, {y, b2}).z(w).P'	Q = u1v1.Q1	R' = u2v2.R'
gives rise to:
ι(∗) = {μ' , μQ, μ' }
P	R
ι(μ' ) = {x, z}	ι(μQ) = {u1}	ι(μ' ) = {u2}

P
'
P
⎩ ϵ(μ' )(z) = {v1, b2},
R

ϵ(μQ)(u1) = {a1},	ϵ(μQ)(u2) = {b2}

κ(μ' )(x) = ∅,	κ(μ' )(u1) = {v1},	κ(μ' )(u2) = {v2}
P	R	R
ρ(y) = {v1}	ρ(w) = {v2}

The prefix expose causes the addition of z to the binders of the first box BP ' , as stated by the inclusion of z in ι(μP ' ). Furthermore, the first box can initially only communicate with the second one, while it can communicate with the third one, after the expose, as shown by the following transitions, where B' becomes

β(x :{c ,c })[expose(z, {v ,b }).z(w).P'{v /y}]μ'
|| β(u
:{c })[Q ]μQ

1  2	1  2
1	1	P
1	1	1
' μ'

|| β(u2 :{b2})[R ] R

and after the expose and the following communication it becomes:


β(x : {c ,c })β(z :{v ,b })[P '{v /y}{v /w}]μ' ||β(u
: {c })[Q ]μQ ||β(u
: {b })[R' ]μ'

1  2	1  2	1	1
2	P	1	1	1
2	2	1 R

Note	that	after	the	first	communication,	expose(z, {y, b2})	becomes
expose(z, {v1, b2}), as correctly reported by the analysis, where ϵ(μ' )(z) = {v1, b2},
because ρ({y, b2}) = ρ(y) × ρ(b2) = {v1, b2}.

Example 3: Interface Handling (2)
The analysis of another beta process B'


B'' = B'' ||B ||B
= β(x : {c ,c })[P ']μ'' ||β(u : {c })[Q]μQ ||β(u : {c })[R]μR ,

P	Q	R
1  2	P	1	1	2	2

where P '' = x(y).hide(x).x(w).P''	Q = u1v1.Q1	R = u2v2.R1
gives rise to:

ι(∗) = {μ'' , μQ, μR}
ι(μ'' ) = {x, xh}	ι(μQ) = {u1}	ι(μR) = {u2}
ϵ(μ'' )(x) = {c1, c2} ϵ(μQ)(u1) = {c1},	ϵ(μR)(u2) = {c2}
κ(μ'' )(x) = ∅,	κ(μQ)(u1) = {v1},	κ(μR)(u2) = {v2}
ρ(y) = {v1, v2},	ρ(w) = {v1, v2}

Note that the prefix hide causes the hiding of x and therefore the isolation of the first box B' . For instance, if the first transition leads B' to

β(x : {c ,c })[hide(x).xh(w).P ''{v /y}]μ'' || β(u
: {c })[Q ]μQ

1  2	1	1	P
1	1	1

|| β(u2 : {c2})[u2v2.R1]μR


and the second to
β(xh : {c ,c })[xh(w).P ''{v /y}]μ'' ||β(u


: {c })[Q ]μQ ||β(u


: {c })[u v .R ]μR


1  2	1	1
P	1	1	1
2	2	2 2	1

then, there is no possible communication between B'' and BR: the sites x and u2
have non disjoint types, but x is hidden and therefore no communication is possible on x.
The analysis instead considers that communication possible and also the analo- gous communication between x and u1, as shown by the fact that ρ(w) = {v1, v2}. We are still on the safe side of approximation, because what the analysis includes corresponds to something that can happen. Nevertheless, the analysis is not precise. This observation leads us to the following considerations.

On the precision of the analysis
As seen above, the presence of hide and unhide constructs represents a peculiar source of imprecision in beta binders. In fact, they can occur in a particular sub- process included in a certain box, but their effect is on the overall process contained in the box, e.g. in the process Bβ(x : Γ))[hide(x).P1|P2] the firing of hide impacts on both the continuation P1 and on the parallel process P2. The decision of hiding and of unhiding is unilateral, but affects the whole context. The binder is a shared object, whose access is concurrent. This concurrent feature is responsible for the analysis imprecision. Suppose to have the following process:


Bβ(x : Γ)[!hide(x).P1|x(y).Q1|xz.Q2|Q3|!unhide(x).P2]
It is impossible (since it is undecidable) to predict at compile time if the com- munication between x(y).Q1 and xz.Q2 will be fired at run time. The binder x could be indeed either hidden or unhidden, depending on which is the last interface operation occurred. In our analysis, the communication is predicted as possible.
We  could  obtain  more  precision  in  special  cases,  like  in  the  process
[hide(x).P1|P2], when x ∈/ fn(P2). Here the effect of the hide operation is only
on the continuation P1, where x is hidden until an unhide(x) occurs. More in gen-
eral, there are cases in which we can decide, at compile time, by a simple syntactic inspection, in which parts of the process a variable x occurs hidden. This is the case of the process B'' above.
In these cases, to reflect the fact the hidden occurrences of a variable cannot be used for possible communications, we could (i) replace the variable x with a new variable xh, representing the hidden version of the corresponding binder, and, (ii) we could impose then that for each variable xh, ϵ(μ)(xh) = κ(μ)(xh) = ∅.
With this safeguard, the analysis would correctly predict the absence of any communication on the hidden occurrence of x, since for i = 1, 2, ϵ(μP ' )(xh) ∩ ϵ(μR)(ui) = ∅ and ρ(w) = ∅.

Validation
Our analysis is semantically correct. More precisely, we prove a subject reduction result: if (ϵ, ρ, κ) is a valid estimate for a beta process B, than it is still a valid estimate also for all the states passed through a computation of B.
To obtain this result the following lemmata are necessary. The first states that estimates are resistant to substitution of closed terms for variables, and it holds for both processes and beta processes.
Lemma 3.1 (Substitution result)
(ι, ϵ, ρ, κ) |=μ P and v ∈ ρ(x) imply (ι, ϵ, ρ, κ) |=μ P{v/x};
(ι, ϵ, ρ, κ) |=∗ B and v ∈ ρ(x) imply (ι, ϵ, ρ, κ) |=∗ B{v/x};
Proof. [Sketch] Both proofs proceed by structural induction.	 
The second lemma says that an estimate for a process P or for a beta process
B is valid for every process congruent to P or B, respectively.
Lemma 3.2 (Congruence)

If P ≡ Q and (ι, ϵ, ρ, κ) |=μ P then (ι, ϵ, ρ, κ) |=μ Q
If B ≡ B' and (ι, ϵ, ρ, κ) |=∗ B then (ι, ϵ, ρ, κ) |=∗ B'
Proof. [Sketch] The proof amounts to a straightforward inspection of each of the clauses defining the structural congruence clauses.	 

We are now ready to state the subject reduction result. It expresses that our analysis is semantically correct with respect to the given semantics.
Theorem 3.3 (Subject reduction) If B → B' and (ι, ϵ, ρ, κ) |=∗ B then also
(ι, ϵ, ρ, κ) |=∗ B'.
Proof. [sketch] By induction on the inference of →.	 
One can show that for any given B there always is a least choice of ϵ, ρ and κ. Moreover, the analysis that computes the least estimate that satisfies the judgements in Table 2 can be implemented along the lines of the control flow analysis of the π-calculus and that of the BioAmbients [1,11,9].

Possible application of the analysis
Our analysis of a system statically approximates the essential behaviour of each box, tracking all the possible bindings of variables and all the possible intra- e inter-boxes communications, recording where and between which communications may occur. In particular, we have an over-approximation of the exact behaviour of each box, i.e. we consider as effective all the communications that might occur through suitable shared channels inside the box and all those that might occur between the box with boxes endowed with compatible binders. At run time, only part of these communications can be however viable, due to the dynamic evolution of processes. As a consequence, on the one hand, we can only assess the possibility of certain events, like communications, to happen, when reported in the analysis estimate. On the other hand, the analysis can guarantee that if an event, such as a communication, is not included in the analysis estimate, then it will never happen.
Exploiting the soundness of our analysis, we can therefore prove, among others, the following basic facts, that can be immediately used to establish simple proper- ties, without resorting to the exploration of the whole transition system.
propensity for communication of a binder x: The binder x can be possibly involved in a communication if {x, xu}∩ ι(μP ) /= ∅, i.e. if it can occur active or unhidden.
compatibility between B[P ]μP and B[Q]μQ : B[P ]μP and B[Q]μQ have compatible types if ∃a  :  {a, ah, au}  ∈  ι(μP ) and ∃b  :  {b, bh, bu}  ∈ ι(μQ) such that ϵ(μP )(a) ∩ ϵ(μQ)(b) /= ∅.
no interaction between B[P ]μP and B[Q]μQ : The process B[P ]μP cannot communicate with B[Q]μQ , ∀a : {a, au}∩ ι(μP ) /= ∅, and ∀b : {b, bu}∩ ι(μQ) /= ∅ then ϵ(μP )(a) ∩ ϵ(μQ)(b) = ∅, i.e. all the possible pairs of binders that show propensity for communication are incompatible.
isolation of B[P ]μP : The process B[P ]μP is isolated, when ∀μQ ∈ ι(∗), B[P ]μP cannot interact with B[Q]μQ .
no flow of information from B[P ]μP to B[Q]μQ : The process B[P ]μP cannot send anything to B[Q]μQ , when ∀a : {a, au}∩ι(μP ) /= ∅, and ∀b : {b, bu}∩ι(μQ) /=

∅ such that ϵ(μP )(a) ∩ ϵ(μQ)(b) /= ∅, we have that κ(μP )(a) = ∅. i.e. even in the presence of a pair of binders that are compatible, and that show propensity for communication, there is no possible output from box μP .
virtual nesting of B[Q]μQ in B[P ]μP : B[Q]μQ is virtually nested in B[P ]μP , when (i) B[P ]μP  and B[Q]μQ are such that B[Q]μQ has only one binder b and
∃a : {a, ah, au} ∈ ι(μP ) such that ϵ(μQ)(b) = ϵ(μP )(a); moreover (ii) ∀μR ∈ ι(∗), with μR /= μP B[P ]μP cannot communicate with B[R]μR .
As far as the last property is concerned, we must recall that nesting is forbidden to keep the formalism simple. However, (see [14]), the operational semantics of in- teractions between boxes can express a form of virtual nesting, properly defining the types of sites. This happens when the box virtually nested B[Q]μQ , can only per- form intra-communications and can be involved in inter-communications with the nesting box B[P ]μP through a site with exactly the same type of the one in B[Q]μQ .


Example: An Abstract Virus Attack
We illustrate our approach, by using an abstract specification, found in [13] of the interaction between a virus and cells of the immune system. The specification describes a cell C of the immune system that has engulfed the virus V1 and that has to elaborate it, produce the antigene molecule and display the antigene on its surface. A specialized lymphocyte L1 can recognize the antigen a1 associated with
viruses of sort v1 (the antigen a' associated with viruses of sort v' , respectively)
and then activate the immune replay.


B = BC||BL = β(x : {v1, ..., vn})[C]μC ||β(z : {a1, a' })[L1]μL1 , where

C =!x(w).expose(u, {w}).ur| C1| V1	V1 = xa1.V res	L1 = z(y).Lact
The analysis gives rise to:

ι(∗) = {μC, μL1 }
ι(μC) = {x, u}	ι(μL1 ) = {z}

⎧⎨ ϵ(μC)(x) = {v1, ..., vn}

ϵ(μ	)(z) = {a , a' }

⎩ ϵ(μC)(u) = {a1},
⎨ κ(μC)(u) = {r},
⎩ κ(μC)(x) = {a1},
L1



κ(μL1
1	1


)(z) = ∅

ρ(w) = {a1}	ρ(y) = {r}

that reflects one of the possible dynamic evolutions of the process:

B ≡[4]	β(x : {v1, ..., vn})[x(w).expose(u, {w}).ur| C1| xa1.V res|C]μC ||β(z : {a1, a' })[L1]μL1
1	1
→Intra  β(x : {v1, ..., vn})[expose(u, {a1}).ur| C1| V res|C]μC ||β(z : {a1, a' })[L1]μL1
1	1
→Expose β(x : {v1, ..., vn})β(u : {a1})[ur| C1| V res|C]μC ||β(z : {a1, a' })[z(y).Lact]μL1
1	1	1
→Inter	β(x : {v1, ..., vn})β(u : {a1})[C1| V res|C]μC ||β(z : {a1, a' })[Lact{r/y}]μL1
1	1	1
Note that, in particular, at the beginning, the two boxes cannot communicate each other, because their binders are incompatible.
Suppose instead that C engulfs a different virus V2, for which the lymphocyte
L1 cannot activate any immune replay.
C =!x(w).expose(u, {w}).ur| C1| V2	V2 = xa2.V res	L1 = z(y).Lact

In this case, the analysis would be:

ι(∗) = {μC, μL1 }
ι(μC) = {x, u}	ι(μL1 ) = {z}

⎧⎨ ϵ(μC)(x) = {v1, ..., vn}

ϵ(μ	)(z) = {a , a' }

⎩ ϵ(μC)(u) = {a2},
⎨ κ(μC)(u) = {r},
⎩ κ(μC)(x) = {a2},
L1



κ(μL1
1	1


)(z) = ∅

ρ(w) = {a2}	ρ(y) = ∅
reflecting the fact that the two boxes cannot communicate. Indeed, we have that
u ∈ ι(μC), z ∈ ι(μL1 ), but ϵ(μC)(u) ∩ ϵ(μL1 )(z) = ∅.
Conclusions and Future Work
The paper presents a control flow analysis for Beta Binders, able to describe the essential behaviour of each of its boxes, in terms of possible interactions. Mainly, the analysis gives an over-approximations of (i) the binders of a box; (ii) the set of names the subject of a binder may be associated with; (iii) the set of values to which names can be bound, and of (iv) the set of names that can be sent over given channels.
Simply exploiting the soundness of our analysis, we can prove some basic facts, that can be immediately used to establish simple properties, such as the absence of interaction of two boxes or the isolation of a box. These properties are quite simple, but are useful for illustrating how suitable static techniques can be adapted to model biological systems, giving some insights on their behaviour.

The study of Beta Binders suggests at least two possible future directions. In fact, in classical process algebras, communications are modelled in a key-lock style, by requiring that an input and an output can communicate only if they synchronize on the same channel. In Beta Binders the key-lock model for interaction is partially relaxed. Interactions between boxes are allowed when the types of binders share some common value. This is a nice feature, when formalising biological behaviour, maybe collecting part of specifications in different databases, because it allows to easily put together the needed components. It is sufficient to put them in different boxes, just establishing the proper binders. This is a feature that can be explored also from the static analysis point of view, looking for suitable ways of composing independent analyses of parts of systems.
It would also be interesting to understand how to analyse some more complex forms of interactions, that are currently studied in Beta Binders and that seem to be closer to biological interactions. Indeed, the requirement that the intersection of the types are not empty to allow an inter-boxes communication can result too ab- stract. In [12], for instance, this notion is made finer, by introducing a more general notion of affinity, based, in turn, on a larger notion of compatibility between types. Compatibility can give a measure of how much favourable a biological interaction is and could be cabled inside our analysis.
In perspective, static analysis can be fruitfully exploited to study dynamic prop- erties of large biological systems, by keeping the computational costs low. Further- more, it can be used to reason about the model chosen for describing the biological system under consideration, by checking the properties on the model and by com- paring the obtained results with the experimental ones reported in the literature.
Acknowledgement
We are grateful to Pierpaolo Degano for his helpful discussions and comments.

References
Chiara Bodei, Pierpaolo Degano, Flemming Nielson, and Hanne Riis Nielson. Static analysis for the
π-calculus with their application to security. Information and Computation (165): 68-92, 2001.
Luca Cardelli. Brane Calculi - Interactions of Biological Membranes. Proc. of CMSB 2004. LNCS 3082, Springer, 2005.
Luca Cardelli and Andrew D. Gordon. Mobile Ambients. Theoretical Computer Science 240(1): 177-213 (2000).
Vincent Danos, Jean Krivine. Transactions in RCCS. In Proc. of CONCUR 2005, pp. 398-412.
Vincent Danos, Cosimo Laneve. Graphs for Core Molecular Biology. In Proc. of CMSB 2003, pp. 34-46
Robin Milner. Communicating and mobile systems: the π-calculus. Cambridge University Press, 1999.
Hanne Riis Nielson and Flemming Nielson. Flow Logic: a multi-paradigmatic approach to static analysis. The Essence of Computation: Complexity, Analysis, Transformation LNCS 2566, pp. 223-244, Springer Verlag, 2002.
Flemming Nielson, Hanne Riis Nielson, Ren Rydhof Hansen. Validating firewalls using flow logics
Theoretical Computer Science 283(2): 381-418 (2002).


Flemming Nielson, Hanne Riis Nielson, Corrado Priami, and Debora Schuch da Rosa. Control flow analysis for BioAmbients. Electronic Notes in Theoretical Computer Science, 2003.
Flemming Nielson, Hanne Riis Nielson, Debora Schuch da Rosa, and Corrado Priami. Static analysis for systems biology. In Proc. of workshop on Systeomatics - dynamic biological systems informatics. Computer Science Press, Trinity College Dublin, 2004.
Flemming Nielson and Helmut Seidl. Control-flow analysis in cubic time. In Proc. of European Symposium on Programming (ESOP’01), LNCS 2028, pp. 252-268. Springer Verlag, 2001.
Davide Prandi, Corrado Priami and Paola Quaglia. Shape spaces in formal interactions, ComPlexUs, 2(3-4):128139, 2006.
Corrado Priami and Paola Quaglia. Beta Binders for Biological Interactions, CMSB ’04, LNBI 3082, Springer (2005).
Corrado Priami and Paola Quaglia. Operational patterns in beta-binders, Transactions on Computational Systems Biology, LNCS 3380, Springer (2005).
Corrado Priami, Aviv Regev, Ehud Y. Shapiro, William Silverman. Application of a stochastic name- passing calculus to representation and simulation of molecular processes. Inf. Process. Lett. 80(1): 25-31 (2001).
Aviv Regev, Ekaterina M. Panina, William Silverman, Luca Cardelli, and Ehud Y. Shapiro.
BioAmbients: An abstraction for biological compartments. Theoretical Computer Science 325(1): 141-
167. 2004, Elsevier.
Aviv Regev, William Silverman, Ehud Y. Shapiro. Representation and Simulation of Biochemical Processes Using the pi-Calculus Process Algebra. Pacific Symposium on Biocomputing 2001, pp. 459- 470.
