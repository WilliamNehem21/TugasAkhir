Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 292 (2013) 119–133
www.elsevier.com/locate/entcs

Sorting Permutations by Reversals through a Hybrid Genetic Algorithm based on Breakpoint Elimination and Exact Solutions for Signed Permutations 1
Jos´e Luis Soncco-A´lvarez2 Mauricio Ayala-Rinc´on3
Grupo de Teoria da Computa¸c˜ao Departamentos de Matem´atica e Ciˆencia da Computa¸c˜ao
Universidade de Bras´ılia Bras´ılia D.F., Brazil


Abstract
Sorting permutations by reversals is one of the most challenging problems related with the analysis of the evolutionary distance between organisms. Genome rearrangement can be done through several operations with biological significance, such as block interchange, transposition and reversal, among others; but sorting by reversals, that consists in finding the shortest sequence of reversals to transform one genome into another, came arise as one of the most challenging problems from the combinatorial and algebraic points of view. In fact, sorting by reversal unsigned permutations is an NP-hard problem, for which the question of NP- completeness remains open for more than two decades and for which several interesting combinatorial questions, such as the average number of reversals needed to sort permutations of the same size, remain without solution. In contrast to the unsigned case, sorting by reversals signed permutations belongs to
P. In this paper, a standard genetic algorithm for solving the problem of sorting by reversals unsigned permutations is proposed. This approach is based on Auyeung and Abraham’s method which uses exact solutions for the signed case in order to build approximate solutions for the unsorted one. Additionally, an improved genetic algorithm is proposed, that in the initial generations applies reversals that simultaneously eliminate two breakpoints, a heuristic mechanism used by several approximation algorithms. As control mechanism for estimating the precision of the results, a correct implementation of an 1.5-approximation algorithm was developed. Also, the results were compared with permutations for which exact solutions are known, such as Gollan’s permutations and their inverses. Several experiments with randomly generated permutations were performed and the results showed that in average the precision of the outputs provided by both the standard and improved genetic algorithms overcome the results given by the 1.5-approximation algorithm as well as those results provided by previous known genetic approaches.
Keywords: Sorting permutations by reversals, Genetic Algorithms, Approximate Algorithms.



1 Research funded by grants FAPDF PRONEX and CNPq Universal.
2 Email: josesoal@hotmail.com. Author funded by the Brazilian Coordination for the Improvement of Higher Education Personnel CAPES.
3 Email: ayala@unb.br. Author partially funded by the Brazilian National Counsel of Technological and Scientific Development CNPq.

1571-0661 © 2013 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2013.02.009

Introduction

Comparison of biological sequences is a relevant problem in bioinformatics for de- termining the evolutionary relationships between organisms. This problem can be addressed using algorithms that take into consideration local mutations (deletions, insertions and substitutions), such as the classical algorithm of dynamic program- ming to align two DNA sequences. But when one tries to understand how genetic sequences mutate at the chromosome level, it is necessary to consider global opera- tions such as reversals, block interchanges and transpositions. One of the operations that occurs commonly in genome rearrangements is the reversal of a substring.
The order of genes in a genome can be represented in string notation as a permutation π = (π1, π2,..., πn) of the set {1,..., n}, that is a bijective function from {1,..., n} into itself, where n is the number of genes. Two different types of permutations have received attention from the biological point of view: signed and unsigned permutations. On unsigned permutations, genes are abstracted without any orientation, while on signed permutations, each πi has a positive or negative sign reflecting its orientation within the genome; either from left to right or from
right to left, denoted respectively as −→πi or →π−.
Given two permutations we wish to determine the minimum number of reversals to transform one permutation into another, that is the reversal distance between two permutations. By simple algebraic properties of permutations, this problem results equivalent to the problem of determining the minimum number of reversals to transform one permutation into the identity permutation, denoted as ı (i.e., in string notation, for the unsigned case, the permutation sorted in increasing order and for the signed case the permutation sorted in increasing order and in which
each πi has positive orientation, −→π ). This problem is known as sorting by reversals.
The problem of sorting by reversals has been extensively studied both in the field of combinatorics of permutations and in bioinformatics for decades. For the case of sorting signed permutations by reversals, initially, Kececioglu and Sankoff
[11] conjectured that the problem was NP-hard and proposed a 2-approximation algorithm. Afterwards, Bafna and Pevzner [3] improved the approximation ratio to 1.5, by using the data structure of breakpoint graphs. Finally, Hannenhalli and Pevzner [10] gave an exact polynomial (O(n4)) algorithm that computes the reversal distance without providing the sequence of sorting reversals, by using the data structure of overlap graph. Further, more efficient algorithms based on this polynomial algorithm ([10]) have been introduced; among them, the O(nα(n)) time algorithm proposed by Berman and Hannenhalli in [4], where α(n) is the inverse of Ackermann function and, the linear time algorithm proposed by Bader, Moret and Yang in [2] that uses a new data structure called overlap forest. Increasing these complexities, these algorithms can be applied not only to compute the reversal distance, but also to build a minimal sequence of reversals.
For unsigned permutations, that are the ones treated in this paper, the problem was shown to be NP-hard by Caprara [7]. Before the complexity was known, Kece- cioglu and Sankoff [11] gave a 2-approximation algorithm, and Bafna and Pevzner[3]

presented an 1.75-approximation algorithm. Later on, the approximation ratio was improved to 1.5 by Christie [8] (although the given methodology presents several imprecisions) and then to 1.375 by Berman, Hannenhalli and Karpinski [5]. The latter approximation algorithm is of theoretical interest being its practical imple- mentation of great difficulty.
Evolutionary techniques like genetic algorithms were proposed to deal with the unsigned case due to the complexity of the problem. Auyeung and Abraham [1] suggested a genetic algorithm (GA) approach to solve the problem of sorting un- signed permutations by reversals based on mapping unsigned permutations of size n into a subset of the 2n possible signed versions of each permutation of size n. For a given unsigned permutation, a set of signed permutations is generated by randomly assigning either a positive or a negative parity to each component of the permutation. The exact solution of one of this signed permutations corresponds to a feasible solution of the original unsigned permutation. The fitness function of each signed permutation is given by its exact reversal distance that is computed by Hannenhalli’s et al polynomial time algorithm.
Subsequently, modifications to Auyeung and Abraham’s method were reported in [14], but without changing the central premisses of this approach. More recently, Ghaffarizadeh, Ahmadi and Flann [9] proposed a modified version of the standard GA using individuals of different sizes to reduce the runtime of the algorithm. All these approaches have been reported to improve the results obtained applying Christie’s 1.5-approximation algorithm in order to control the precision of the so- lutions. But two problem arise in these papers: firstly, Christie’s approximation algorithm presented some conceptual problems whose solutions were not reported in [1], [9] or [14], and secondly, because of the given results, the way in which per- mutations were randomly generated in some of these papers is imprecise as it will be discussed. In [12], the authors, presented a simple GA approach that is based on heuristics of well-known approximation mechanisms (e.g., [8,5]) focused in apply- ing in each generation reversals that maximally reduce the number of breakpoints appearing in each individual. A fixed version of Christie’s approach was initially reported by the authors in [12] and used as quality control mechanism, as is done in this paper too. Additionally, experiments were performed over random permu- tations generated in two different manners: by direct application of the C language rand function and by randomly applying reversals to the identity permutation.
In this paper two GA based on Auyeung and Abraham’s method are proposed.
Firstly, for an approach `a la Auyeung and Abraham in which the parameters of the GA were established in a precise manner, the experiments gave results that effectively and correctly have improved the results previously reported by other authors and that are better than the approximate solutions given by the fixed 1.5-approximation algorithm.
Secondly, a hybrid GA-approximate modification is proposed in which, initially, the input permutation is sorted by randomly applying all possible reversals that simultaneously eliminate two breakpoints and then, the Auyeung and Abraham’s GA approach is applied for the obtained permutation.

The modified GA give better results when the input permutations are large. The differences between both GA solutions and the approximated ones is smaller than the differences previously reported in other papers, but the comparison given in this paper is more precise since here a fixed 1.5-approximation algorithm is applied. Finally, experiments were performed with permutations for which exact solutions are known such as Gollan’s permutations and their inverses for which both GA approaches compute exact outputs.
The paper is organized in the following sections: in Section 2, the necessary notations and notions are given; in Section 3, the proposed GA and its modification are presented; in Section 4, experiments and results are given; in Section 5, the method and the results are discussed and; finally, concluding remarks and future work are presented in Section 6.
Background
Terminology
Most definitions and terminology presented in this section, were introduced by Bafna and Pevzner in their seminal paper [3].
A permutation in the symmetry group Sn is a bijection π from {1,..., n} into itself. A permutation π, denoted in string notation as π = (π1, π2,..., πn) is extend by adding an initial and a final pivot, π0 = 0 and πn+1 = n + 1. A reversal ρi..j of an interval [i, j], for 1 ≤ i ≤ j ≤ n, transforms the extended permutation π into
πj = (π0,..., πi—1, πj,..., πi, πj+1,..., πn+1)
For example, consider the permutation
π = (0, 3, 1, 5, 2, 4, 6)
The reversal ρ2..4 transforms π into
πj = (0, 3, 2, 5, 1, 4, 6)
Note that the reversal reverts the interval [2, 4] of π.
Observe that a reversal is also a permutation in Sn:


(ρi..j )k
= ⎧⎨ k, if k < i or k > j;
⎩ i + (j − k), if i ≤ k ≤ j.


Thus, in postfix notation πρi..j denotes the application of the reversal ρi..j to the permutation π.
Given two permutations π and σ, the reversal distance problem is the problem of finding a shortest sequence of reversals needed to transform π into σ. The reversal distance between π and σ is the minimum number of reversals required to transform π into σ.

By simple algebraic properties of symmetry groups, the reversal distance be- tween π and σ is equal to the reversal distance between σ—1π and the identity permutation ı. In fact, notice that if ρ1 ... ρk, is a sequence of (reversal) permu- tations that transforms π into σ, then it holds that πρ1 ... ρk = σ, if and only if (σ—1π)ρ1 ... ρk = σ—1σ = ı. Thus, the problem of sorting by reversals corresponds to find the reversal distance between a permutation π and the identity permutation ı, that is denoted as d(π). Since the identity permutation ı is the only sorted per- mutation, the reversal distance problem is also known as the problem of sorting by reversals.
Let i ∼ j denote the property |i − j| = 1. Given two consecutive elements πi
and πj of π; that is, 0 < i < n + 1 and either j = i − 1 or j = i + 1,
they are said to be adjacent if πi ∼ πj and
they are said to form a breakpoint if πi  πj.
Observe that the identity permutation is the unique permutation without break- points. The number of breakpoints in π is denoted by b(π).
Let ρ be a reversal that transforms π into πj, then it is easy to observe that b(π) −b(πj) ∈ {−2, −1, 0, 1, 2}. Reversals that reduce the number of breakpoints by i, are called i-reversals.
Given a permutation π, one defines the cycle graph of π (also called as breakpoint graph) , G(π) as a undirected edge-colored graph derived from the adjacency and breakpoint relations in π with n + 2 vertices labeled by 0, 1,..., n,n + 1. Two vertices i and j are joined by a black edge if (i, j) is a breakpoint of π. Two vertices i and j are joined by a gray edge if i ∼ j and i, j are not consecutive in π. An example of a cycle graph is shown in Fig.1.

Fig. 1. Cycle graph G(π) for the permutation π = (4, 2, 3, 5, 1, 6)

Note that for all permutations π, G(π) can be completely decomposed into dis- joint cycles of alternated colored edges, since each node has an equal number of black and gray incident edges. However, there are probably many different cycle decompositions of G(π) of alternated colored edges. For simplicity, cycles of alter- nating colored edges will be called either alternating cycles or simply cycles. The graph in Fig. 1 decomposes either in one or two cycles. The maximum number of cycles in a cycle decomposition of G(π), denoted as c(π), provides an useful bound for the reversal distance [3]: d(π) ≥ b(π) − c(π). The observation that this bound is in fact close to the reversal distance (mostly for signed permutation) motivated the development of approximation algorithms that are based on the elimination of breakpoints.
For π = (4, 2, 3, 5, 1, 6), whose cycle graph is presented in Fig. 1, d(π) ≥ 5 − 2= 

3. Eliminating two breakpoints, by applying the 2-reversal ρ2..4, one obtains the permutation πj = (4, 5, 3, 2, 1, 6), whose cycle graph is presented in Fig. 2, and for which this bound gives d(πj) ≥ 3 − 1= 2.

Fig. 2. Cycle graph G(π′) for the permutation π′ = (4, 5, 3, 2, 1, 6)
Observe that no 2-reversal is applicable to πj. Applying the 1-reversal ρ1..2, one obtains πjj = (5, 4, 3, 2, 1, 6), for which the bound gives d(πjj)=2 − 1 = 1. See Fig.
3. Finally, πjj can be sorted by applying the 2-reversal ρ1..5.

Fig. 3. Cycle graph G(π′′) for the permutation π′′ = (5, 4, 3, 2, 1, 6)


The genetic algorithm for sorting unsigned permuta- tions by reversals
Our method is based on the approach introduced in [1]. The search space consists of 2n signed permutations, that are the signed versions of the initial unsigned permu- tation to be sorted. For example let the initial unsigned permutation be π = (2, 1),

the search space would be { −→ −→
−→ →−
→− −→
→− →− }. Signed permutations

( 2 , 1 ), ( 2 , 1 ), ( 2 , 1 ), ( 2 , 1) 
can be sorted polynomially and one knows that an optimal solution that solves any signed permutation of the search space also solves the initial unsigned permutation. So, one of the optimal solutions of the elements of the search space is an optimal solution for the initial unsigned permutation. This fact guides the proposed genetic algorithm.
The standard GA approach is used. Initially, a random population of signed permutations for the input permutation is generated; after that, for each gener- ation, the reproduction is performed in the following manner: two individuals of the population are taken for which crossover and mutation operations are applied producing two offspring. Then, the two new obtained offspring are returned to the population. The GA finishes after all the generations have been completed.
The developed improvement made over the standard GA approach consists of applying just to the initial unsigned permutation, reversals that eliminate simultane- ously two breakpoints, that is 2-reversals. This is done randomly until no additional 2-reversals are applicable. Although this is a greedy mechanism that not necessarily will produce an optimal sorting, giving priority to the elimination of (2-)breakpoints has been applied as local optimization method in several approximation algorithms because a high number of 2-reversals tend to be present in optimal solutions (e.g., [11,3,8,5]).

The four stages of the breeding cycle of the GA are described below.
The selection is the stage where all the population is sorted by their fitness value in order to make it easier to choose individuals for the crossover. It is also here where the best solution found is saved.
The crossover chooses the best individuals of the population and makes them breed, producing an offspring.
The mutation is applied over the offspring produced by the crossover operator. The mutation should not occur very often because it could alter too much some of the individuals of the offspring that represent good solutions.
The replacement is the last stage where the offspring must return to the pop- ulation, replacing the worst individuals.
The value of the fitness is the optimal number of reversals for sorting the signed permutation that represents each individual. We use the implementation of the exact algorithm proposed and provided by the authors in [2] to calculate the fitness of each individual in the population. With this algorithm the reversal distance of signed permutations is computed in linear running time.
The fact that the bound d(π) ≥ b(π) − c(π) was observed to be very close to the reversal distance for signed permutations gave rise to other bounds. In [10] the concept of hurdles, denoted as h(π) was developed and proved that b(π) − c(π)+ h(π) ≤ d(π) ≤ b(π) − c(π)+ h(π) + 1. The proof of this bound requires additional elaborated notions such as the ones of fortress and this development, started in [10], is the basis of polynomial algorithms for solving the problem of sorting by reversals signed permutation.
The pseudo-code of our proposed genetic algorithms is shown in Algorithm 1.

Algorithm 1 Sorting by Reversals’ GA with parameter for applying the GA im- proved version
Input: an unsigned permutation π, a boolean “improve” indicating whether or not to apply initially two-reversals.
Output: a number of reversals to sort the permutation π.
if “improve” then
apply 2-reversals until no reversals that eliminate two breakpoints are applicable updating π;
end if
generate an initial population of signed permutations for π; evaluate fitness for each individual of the initial population; for i = 2 to number of generations do
selection; crossover; mutation;
evaluate fitness of offspring; replacement;
end for

Let n be the length of the input permutation. The initial population size is fixed as n log n. Each individual of the population was generated from the input permutation in linear time by randomly assigning a sign to each of its elements. Thus, generating the initial population takes running time O(n2 log n).
The algorithm used to sort the population by their fitness, in the selection stage, is the counting sort that is well-known to take running time O(n log n) since one has to order n log n elements.
In the crossover stage, the best individuals of the population are chosen to be the parents. For each pair of parents the crossover is done in linear time generating two offspring. So the total running time for executing the crossover stage is O(n2 log n). In the mutation stage, mutation is applied to each offspring produced by the crossover. For each element of the individuals in the offspring, it should be checked whether the mutation occurs or not.  The total time taken by the mutation is
O(n2 log n).
Evaluating the fitness values and making the necessary replacements of individ- uals take running time O(n2 log n) each.
The genetic algorithm finishes after n generations, then the overall time com- plexity is O(n3 log n).

Experiments and Results
In order to validate the proposed GA approaches several tests were performed. Tests were done for permutations for which, it is known the reversal distance and for randomly generated permutations. For the latter ones, test differs in the way the input permutations were generated, but in general the tests share the following characteristics.
Hundred permutations were generated for each length i ∈ {10, 20, 30, ..., 150}. For each length i, the average of the results over the hundred generated permutations for the 1.5-approximation algorithm was calculated. Also, averages for the standard GA and the improved GA were calculated. It is worth mentioning that for a given permutation the standard and improved GAs were executed ten times and then, the average of the ten obtained results was calculated. This average represents the result for each permutation. Moreover, for each set of hundred permutations of length i, the standard deviation was calculated, that represents how far the results are from the average.
The crossover operation was performed with a single point crossover. The crossover rate used is 0.9 and the mutation rate used is 0.02. The selection of parents for the crossover was made over the 60% of the population that represent the best individuals. The replacement of the offspring was made over 60% of the population that represent the worst individuals.
The 1.5-approximation algorithm and the standard and improved GAs were implemented in C language and executed in OS X platforms with Intel core I5, I7 processors and other similar platforms.

Table 1
Results of the 1.5-approximation algorithm and the standard and improved GAs for Gollan’s permutations

Experiments with Gollan’s permutations
This experiment was done as a control mechanism considering the most difficult unsigned permutations to be sorted by reversals, that are Gollan’s permutations and their inverses. In [3] it was proved that in the symmetry group Sn, only both Gollan’s permutation, denoted as γn, and its inverse, γ—1, need exactly n − 1 reversals to be sorted. All other permutations in Sn can be sorted with less than n − 1 reversals.
Gollan’s permutation, in cycle notation, is defined as follows:
γ  = ⎧⎨ (1 3 5 7...n − 1 n...864 2), for n even,
⎩ (1 3 5 7...n n − 1...864 2), for n odd.
For instance, γ10 = (13579 10864 2) and γ—1 = (2468 109753 1).
Let i and j be two consecutive elements of Gollan’s permutation γn or its inverse
γ—1 in cycle notation, the corresponding permutation in string notation is generated

putting the element i in the position j and, in addition, the last element is placed in the position given by the first element. For instance, γ10 in string notation is given by (2, 4, 1, 6, 3, 8, 5, 10, 7, 9) and its inverse γ—1 by (3, 1, 5, 2, 7, 4, 9, 6, 10, 8).
Since exact solutions are known, these permutations are used in order to control validity of the outputs provided by our implementations of the 1.5-approximation algorithm and the GAs.
The results of this experiment are presented in Table 1. The values before the slash are the results for γn and after, for its inverse. Observe that all answers given by both the standard and the improved GA are exact, while the 1.5-approximate algorithm fails to compute exact solutions for γ—1, for n = 10, 30, 50, 70, 90, 110, 130
and 150.
Experiments with randomly generated permutations
For this experiment permutations of size n were generated applying repeatedly the function rand available in the standard library of the language C in the following way: π1 is generated as a random number between 1 and n and then, for each 1 < i ≤ n, πi is generated as a random number between 1 and n excluding {π1,..., πi—1}. Assuming that in fact rand generates each random selection independently, this mechanism generates each possible permutation correctly with probability 1/n!
The results of this experiment are shown in Table 2
Additional experiments were performed with permutations of size n generated starting from the identity permutation and then, applying n random reversals. This was done in order to obtain additional information to compare our results with related ones. The results of this experiment are shown in Table 3. The motivation to perform this experiment is that the average number of reversals to sort by reversals permutations of length n is unknown and related works have used permutations as inputs that provide results that suggest different averages.
Discussion and Comparison with Related Work
As previously mentioned, from Table 1 one can see that the results given by both the standard and improved GAs are exact for Gollan permutations and their inverses, in contrast to a few inexact results obtained by the 1.5-approximation algorithm. The unique previous work that reports outputs for specific permutations was [14] in which the permutation in S36
(12, 31, 34, 28, 26, 17, 29, 4, 9, 36, 18, 35, 19, 1, 16, 14, 32, 33,
22, 15, 11, 27, 5, 20, 13, 30, 23, 10, 6, 3, 24, 21, 8, 25, 2, 7)
was sorted with 26 reversals as it was also done by both our GA approaches.
A few considerations are necessary before discussing our results for randomly generated permutations. Here it is relevant to stress that not much information is know about the form of solutions of this problem. In fact, several properties of the

Table 2
Results of the 1.5-approximation and the standard and improved GAs with random permutations

outputs that are known for other sorting operations different from reversals are un- known; for instance, the average number of reversals to sort unsigned permutations of Sn is an interesting open question, while this number is known, for example, for the problem of sorting by block interchange [6].
Surprisingly, previous related works report contrasting results on randomly gen- erated permutations. From the obtained results in [1,14] and [9], respectively the following percents of number of reversals over the length of permutations needed to sort permutations of medium sizes (lengths between 50 and 150) are suggested:
~ 83%, ∼ 46% and ∼ 80%. Namely, the manner in which input random permuta- tions are generated in [14] was not reported in that paper, but because of the results from the other works, including the current one, the average number of reversals needed to sort permutations of length n is much greater than n/2, which suggest us the authors of that work have applied a very peculiar mechanism for the generation of input permutations.
Additionally, as previously mentioned, previous works compare GA results with implementations of approximation algorithms without reporting problems in Christie’s original 1.5 approximation ratio proposal [8], initially fixed in [12]. For

Table 3
Results of the 1.5-approximation and the GAs with permutations obtained by applying n random reversals to ı


example, the approximate outputs in [1] for permutation of medium sizes (lengths between 50 and 150) suggest a number of reversals of ∼ 94% for sorting permuta- tions of size n, while the fixed 1.5-algorithm used in this paper (as well as in [12]) of ∼ 87%, allowing in this way a fair analysis of the real improvement over the approximation algorithm obtained with the corresponding GA approaches.
The results for randomly generated permutations in the table 2 can be compared with the ones obtained by the simple GA in [12] and are illustrated in the bars Fig.4. Results reported in [12] are close to the ones provided by the fixed 1.5-approximation algorithm and both the standard and improved GA approaches proposed in this paper provide better results than the 1.5-approximation algorithm.
The results for permutations obtained by applying random reversal to the iden- tity presented in the table 3 can only be compared with precision with those pre- sented in [1], because it is the only work that presents a table with numeric results. Comparisons with results in [9] are presented, but they are imprecise because in- stead numeric values, the authors presented only a graphic image (restricted to permutations of length less than or equal to 110) from which approximate numer-



Fig. 4. Comparison of results for the 1.5-approximate algorithm (1.5AA), the simple GA in [12] (dGA) and the standard and improved GAs (sGA and iGA)

ical values were extracted and included in the figure 5. In this figure, graphs are built for the approximate mechanism applied in [1] and [9] and Auyeung’s GA ap- proach using numerical results taken directly from [1]. It can be observed that all approaches perform better than the approximate method presented in [1] and [9], but only the results of the (standard) and improved GA approaches presented in this paper are better than the results provided by the fixed 1.5-approximation algo- rithm. In this point one observes that the crossover and mutation rates used here are 0.9 and 0.02, respectively, while in [1] these rates are respectively 0.3 and 0.8. A very small crossover rate and very high mutation rate affects directly the results in the experiment.

Fig. 5. Comparison of results for the 1.5-approximate algorithm (1.5AA), the improved GA (iGA), the approximate algorithm (AA[1,9])and GA in [1] and the GA in [9]

The standard deviation of the results was also included in tables 2 and 3. It can be seen that when the length of the permutation grows the standard devia- tion also grows, this indicates that the results are far from the average. This also indicates that the results provided by the GAs are more distant from the results obtained by the approximation algorithm. Since one always has better results one can say that the results presented in this paper overcome the results by the fixed 1.5-approximation algorithm.
In summary, from the experiments, one can conclude that both the standard and improved GAs compute better results on average than the ones obtained by the fixed 1.5-approximation algorithm. These results are better than the ones reported pre- viously by the authors in [12] for the simple GA based purely on elimination of breakpoints in each generation. Also, the standard and improved proposed GAs outperform the GA approaches presented in [1] and in [9]. Finally, it can be ob- served that for permutations o length greater than or equal to 50, the improved GA outperforms the standard GA.
Conclusion
A standard genetic algorithm based on the Auyeung’s et al method ([1]) for solv- ing the problem of sorting by reversals was proposed and subsequently improved including the heuristic of eliminating breakpoints usually applied in approximation algorithms ([3,10]). In addition to the main distinguishing feature that is the hybrid application of a fitness mechanism based on the computation of exact solutions for signed permutations, through the linear time algorithm in [2], and the elimination of breakpoints in the early generations, in the proposed approaches the parameters of the GA were adequately established and comparison were precisely done with a fixed 1.5-approximation algorithm. The experiments shows that results obtained by both the standard and the improved GAs overcome the results obtained by the 1.5 approximation algorithm as well as the ones presented by previous related works.
It is necessary to stress here, that the fitness calculation is restricted to the reversal distance without computing the sequence of necessary reversals to sort a permutation. From the biological point of view this is not a drawback, since it unnecessary for phylogenetic reconstruction and, moreover, it is usually meaningless because there are many different optimal sorting sequences. From the combinatorial point of view, construction of optimal sequences may be of great interest and it is an interesting future work. In order to obtain the sequences, one might apply sub- quadratic algorithm presented by Swenson et al [13] that works in O(n log n) time for almost the majority of signed permutations.

References
Andy Auyeung and Ajith Abraham. Estimating genome reversal distance by genetic algorithm. In
Evolutionary Computation, 2003. CEC ’03. The 2003 Congress on, volume 2, pages 1157 – 1161 Vol.2,
dec. 2003.
David A. Bader, Bernard M. E. Moret, and Mi Yan. A linear-time algorithm for computing inversion


distance between signed permutations with an experimental study. In Frank K. H. A. Dehne, Jo¨rg- Ru¨diger Sack, and Roberto Tamassia, editors, WADS, volume 2125 of Lecture Notes in Computer Science, pages 365–376. Springer, 2001.
Vineet Bafna and Pavel A. Pevzner. Genome rearrangements and sorting by reversals. In Foundations of Computer Science, 1993. Proceedings., 34th Annual Symposium on, pages 148 –157, nov 1993.
Piotr Berman and Sridhar Hannenhalli. Fast sorting by reversal. In Daniel S. Hirschberg and Eugene W. Myers, editors, CPM, volume 1075 of Lecture Notes in Computer Science, pages 168–185. Springer, 1996.
Piotr Berman, Sridhar Hannenhalli, and Marek Karpinski. 1.375-approximation algorithm for sorting by reversals. In Proceedings of the 10th Annual European Symposium on Algorithms, ESA ’02, pages 200–210, London, UK, UK, 2002. Springer-Verlag.
Miklos B´ona and Ryan Flynn. The average number of block interchanges needed to sort a permutation and a recent result of stanley. Inf. Process. Lett., 109(16):927–931, 2009.
Alberto Caprara. Sorting by reversals is difficult. In Proceedings of the first annual international conference on Computational molecular biology, RECOMB ’97, pages 75–83, New York, NY, USA, 1997. ACM.
David A. Christie. A 3/2-approximation algorithm for sorting by reversals. In Proceedings of the ninth annual ACM-SIAM symposium on Discrete algorithms, SODA ’98, pages 244–252, Philadelphia, PA, USA, 1998. Society for Industrial and Applied Mathematics.
Ahmadreza Ghaffarizadeh, Kamilia Ahmadi, and Nicholas S. Flann. Sorting unsigned permutations by reversals using multi-objective evolutionary algorithms with variable size individuals. In Evolutionary Computation (CEC), 2011 IEEE Congress on, pages 292 –295, june 2011.
Sridhar Hannenhalli and Pavel Pevzner. Transforming cabbage into turnip: polynomial algorithm for sorting signed permutations by reversals. In Proceedings of the twenty-seventh annual ACM symposium on Theory of computing, STOC ’95, pages 178–189, New York, NY, USA, 1995. ACM.
John Kececioglu and David Sankoff. Exact and approximation algorithms for the inversion distance between two chromosomes. In Alberto Apostolico, Maxime Crochemore, Zvi Galil, and Udi Manber, editors, Combinatorial Pattern Matching, volume 684 of Lecture Notes in Computer Science, pages 87–105. Springer Berlin / Heidelberg, 1993. 10.1007/BFb0029799.
Jos´e Luis Soncco-A´lvarez and Mauricio Ayala-Rinc´on. A genetic approach with a simple fitness function for sorting unsigned permutations by reversals. In Seventh Colombian Computing Conference - 7CCC. IEEE Xpress, 2012.
Krister Swenson, Vaibhav Rajan, Yu Lin, and Bernard Moret. Sorting signed permutations by inversions in o (nlogn) time. In Serafim Batzoglou, editor, Research in Computational Molecular Biology, volume 5541 of Lecture Notes in Computer Science, pages 386–399. Springer Berlin / Heidelberg, 2009.
Mo Zhongxi and Zeng Tao. An improved genetic algorithm for problem of genome rearrangement.
Wuhan University Journal of Natural Sciences, 11:498–502, 2006. 10.1007/BF02836651.
