Electronic Notes in Theoretical Computer Science 182 (2007) 73–90	
www.elsevier.com/locate/entcs

A Calculus of Components with Dynamic Type-Checking 1
Sonia Fagorzi2 and Elena Zucca3
DISI
University of Genova Genova, Italy

Abstract
We present a simple module calculus modeling software composition in an open environment, where some components can be provided from the outside after execution has started. Operators for combining software components are as in previous module calculi; here, we focus on the new problems posed by the fact that components are not all available at compile time. In particular, we want to be able to statically check internal consistency of local code, by only specifying a required type for missing components, and then to perform dynamic checks which ensure that code received from the outside, which is assumed to travel with its type, can be successfully accepted, without requiring to type-check the whole code again.
We consider two alternative solutions. The former uses simple dynamic checks based on standard subtyping, that is, a component can be safely combined with local code if it provides the expected features, and all additional features are hidden, thus avoiding conflict problems. The latter preserves the semantics we would get having all components statically available, but requires a more involved type system based on constraints, where dynamic checks prevent conflicts.
Keywords: Module calculi, type systems, dynamic type-checking


Introduction
Component-based software systems are increasingly supporting reconfiguration fea- tures, allowing the system structure to dynamically change after starting execution of an application. Moreover, in an open scenario, some software components can become available (e.g., are received from a different site) only after execution has started. Hence, it is not possible to perform a global static analysis; still we would like to guarantee that execution will never crash.
A convenient, modular way for doing this, advocated for instance in [4] in the context of a coordination language for mobile processes that exchange object-

1 Partially supported by APPSEM II - Thematic network IST-2001-38957, and MIUR EOS - Extensible Object Systems.
2 Email: fagorzi@disi.unige.it
3 Email: zucca@disi.unige.it

1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2006.09.032

oriented code, is by a combination of local static checks and dynamic checks, more precisely:
Statically available code is checked and compiled by only relying on requirements on missing components (formally expressed by a type).
Dynamically available components are equipped with their type, obtained by the previous phase.
At execution time, when an external component is retrieved, it is accepted only if it satisfies the expected requirements; formally, this is expressed by a subtyping relation between the expected type and the provided type.
The combination of static type system and dynamic checks via subtyping ensures that, if an external component is accepted, then it can be safely composed with the running application without any need of inspecting code again.
Though the schema above is clearly desirable and very abstract, that is, not bound to any specific language or system, few attempts have been made until now of formalization and investigation of related problems in a general framework for software composition. In this paper, we give a contribution in this direction by formalizing the above schema in the context of a rather general framework for soft- ware composition we have developed in previous work. In particular, our technical development here takes as starting point the R-calculus [1,7,8,9], a module calculus which improves over its direct predecessors [3,19] by allowing interleaving between execution of a module component and reconfiguration steps due to execution of module operators.
Here, in order to model an open environment, we add to the R-calculus a receive primitive, written rcv τ where τ is the required type of the expression. 4 Then, we face the problem of defining, for the language extended in this way, a combination of static type system and dynamic checks guaranteeing safe composition, following the schema proposed above.
Note that, even though a rcv τ expression can be considered as a formal param- eter of type τ , this problem is not exactly the same we would have in the static case by, say, function abstraction. Indeed, in the case of dynamic retrieval, an important issue is also to reject incoming code in as few cases as possible. Hence, a possible policy for guaranteeing safe composition of a received software component with lo- cal code can be to modify its behaviour, whereas this would be non acceptable if the component was statically available.
A policy of this kind is adopted by the former solution to the problem we present, which uses simple dynamic checks based on standard subtyping. That is, a compo- nent can be safely combined with running code if it provides the expected features, and all additional features are hidden, avoiding conflict problems. The latter solu- tion we present, instead, preserves the semantics we would get in the static case, but requires a more involved type system based on constraints, where dynamic checks

4 Indeed, our aim here is to focus on the problem of type safe dynamic retrieval of code, hence we do not care about where this code comes from; an explicit process layer with standard send/receive primitives is considered in our subsequent paper [10].



X, Y, Z,... ∈ Name	name
x, y, z,... ∈ Var	variable
e ∈ Exp	::=	expression
.. .	core expression
|  x	variable
|  [ι; o; ρ]	(dom(ι)∩dom(ρ)= ∅)	basic module
|  [ι; o; ρ| e]	(dom(ι)∩dom(ρ)= ∅, ) basic configuration
|  e1 + e2	sum
|  e\X	delete
|  freezeX e	freeze
|  e ↓X	run
|  e ↑	result

ι	:= xi: cτ
i∈I
i '→ Xi
(Xi
= Xj
⇒ cτi
= cτj) input part

o	:= Xj
j∈O
'→ ej	output part

ρ	:= xl: cτ
l∈L
l '→ el
local part

cτ ∈ CType	core type

Fig. 1. R-calculus syntax
prevent conflicts. The two solutions, even if applied here to a fixed, though rather general, formalism, can be considered paradigmatic. We prove that both solutions are sound, in the sense that they prevent ill-formed combination of components, and formally compare the two approaches.
The paper is structured as follows. In Sect.2 we provide a brief informal in- troduction to the R-calculus. In Sect.3 we extend the calculus with the receive primitive, discuss informally the problem of guaranteeing safe composition in this case, and present the hiding-based solution. In Sect.4 we present the constraint- based solution and compare the two approaches. Finally, in Sect.5 we summarize the contribution of the paper and briefly discuss related and further work. To ease the reader, we have added in the Appendix the formal definition of the R-calculus, together with proofs.

An overview of the R-calculus
In this section we provide a brief introduction to the R-calculus [1,7,8,9] through examples. The syntax is given in Fig.1, whereas reduction and typing rules are reported in the Appendix.
The R-calculus is a parametric calculus, which can be instantiated over different core languages, as modeled by the first production. Terms of the calculus which are not core expressions denote either modules or conﬁgurations. For simplicity, we do not consider here higher-order modules or configurations (see the Conclusion for more comments).
A module models a software component, seen as a collection of entities whose nature depends on the underlying core language (in the examples we will just use integer expressions for simplicity), which can be either defined inside the module or deferred, that is, to be imported later when composing the module with others.
A basic module consists of three parts: a map ι from deferred variables to input

names, a map o from output names to expressions, and a map ρ from local variables to expressions. Names are used to refer to a module entity from outside (hence they are used by module operators), while variables, which are annotated with core types 5 , are used to refer to an entity from inside the module.
A basic module, e.g., [x '→ X, z '→ Z; X '→ 0,Y '→ x + y; y '→ 2+ z], declares four kinds of entities: Z is deferred, since its name is only input; among entities defined inside the module, X is virtual, since its name is both input and output; Y is frozen, since its name is only output; finally, y is local, since it has no name, hence is only internally available.
Modules can be combined by the three operators of sum, delete, and freeze. Summing two modules means performing the union of deferred entities and the disjoint union of virtual, frozen and local entities. Conflicts among variables are solved by α-renaming. Deleting an output name from a module means that the corresponding definition is removed: as a consequence, a virtual entity becomes deferred, whereas a frozen entity just disappears. Freezing a virtual entity means that its input name disappears, and all variables mapped into it become local, taking as defining expression the current entity definition. As a consequence, the entity becomes frozen.
A configuration models a software component together with a running program, whose execution may refer to the entities declared by the component. A basic con- ﬁguration is a pair consisting of a basic module and a core expression, modeling the program. For instance, [x '→ X, z '→ Z; X '→ 0,Y '→ x + y; y '→ 2+ z| y] is a basic configura- tion with program y.
A basic configuration can evolve by reduction steps at the core level of the pro- gram, or by replacing both local and virtual variables by their defining expressions. Moreover, it is possible to apply module simplification steps to the module part of a configuration. That is, module operators can be applied to configurations as well, and act as reconfiguration operators, in the sense that they allow to modify the context of a program during its execution.
Thanks to reconfiguration steps, a needed deferred entity can become available, as shown below:
[x '→ X, z '→ Z; X '→ 0,Y '→ x + y; y '→ 2+ z| y] \Y + [; Z '→ 3; ] (lo)cal)
[x '→ X, z '→ Z; X '→ 0,Y '→ x + y; y '→ 2+ z| 2+ z] \Y + [; Z '→ 3; ] (d)el)
[x '→ X, z '→ Z; X '→ 0; y '→ 2+ z| 2+ z]+ [; Z '→ 3; ] (su)m)
[x '→ X, z '→ Z; X '→ 0,Z '→ 3; y '→ 2+ z| 2+ z] (virt)ual)
[x '→ X, z '→ Z; X '→ 0,Z '→ 3; y '→ 2+ z| 2+ 3] ( co)re)
[x '→ X, z '→ Z; X '→ 0,Z '→ 3; y '→ 2+ z| 5]
The difference between virtual and frozen entities is that changes to their defining expressions during execution affect references to these entities only in the virtual case. For instance, assuming to replace program variable from left to right 6 , the configuration

5 We will omit type annotations when not necessary.
6 Formally, assuming core evaluation contexts of the form E + e and v + E, with v integer value.



τ ∈ Type ::=	type
cτ	core type
|  [πι; πo]	module type
|  [πι; πo; cτ ]	configuration type
π	:= Xi: cτi∈I	signature
Fig. 2. R-calculus types

[x '→ X, z '→ Z; X '→ 1; | x + z + x] \X + [; X '→ 2,Z '→ 0; ]
reduces to [x '→ X, z '→ Z; X '→ 2,Z '→ 0; | 1+ 0+ 2].  Indeed, the definition of z be- comes available only by performing the delete and sum operators, that also change the definition of x. Instead, the configuration
(freezeX [x '→ X, z '→ Z; X '→ 1; | x + z + x]) \X + [; X '→ 2,Z '→ 0; ]
reduces to [z '→ Z; X '→ 1; x '→ 1| 1+ z + x] \X + [; X '→ 2,Z '→ 0; ]
and then to [z '→ Z; X '→ 2,Z '→ 0; x '→ 1| 1+ 0+ 1].
The run operator gets a basic configuration from a (basic) module, by starting the execution of one of its output entities. For instance, the expression
[; X '→ x; y '→ 1,x '→ 2+ y] ↓X
reduces to the basic configuration [; X '→ x; y '→ 1,x '→ 2+ y| x].
The result operator allows to extract the program from a configuration 7 , hence, to get a core value as the result of an inner computation. For instance, the expression
[z '→ Z; Z '→ ([x '→ X; ; | x]+ [; X '→ 2; ]) ↑; | z + 1]
reduces to [z '→ Z; Z '→ 2; | 2+ 1] .
Types are defined in Fig.2, and include, besides core types, module and con- ﬁguration types. A module type consists of an input signature πι and an output signature πo. A signature is a sequence Xi: cτi∈I of pairs consisting of an entity name and a (core) type, where order and repetitions are immaterial. In a configuration type, the first two components have the same meaning as for module types, while cτ is the (core) type of the program running in the configuration. The typing rules are given in Fig.A.3 in the Appendix. They derive judgments of shape Γ▶ e : τ where a context is an assignment of well-formed (core) types to variables.
The R-calculus enjoys usual progress and subject reduction properties (see in the Appendix), under the assumption that analogous properties hold for the core calculus as well.

Solving dynamic clashes by hiding
The R-calculus presented until now models applications which can be dynamically reconfigured, in the sense that the software components composing the application can be manipulated after execution has started. However, these components are all available from the beginning. We now consider a different scenario, in which some

7 When it does no longer refer to entities declared by the component.

component is not available at application compile-time, but will be provided later during execution.
We model this in a simple way by adding a receive primitive, written rcv τ where τ is the required type of the expression which will be dynamically retrieved, as shown in Fig.3.



e ∈ Exp ::= .. . | rcv τ	receive (rcv)


Γ▶ rcv τ : τ


Fig. 3. Extended syntax and typing rule

For instance, in the configuration c =Δ [x: int '→ X; Y '→ 1; | x + 1] + rcv [Y : int; X: int], the second argument of the sum is not statically available, but is required to be a module having type [Y : int; X: int], that is, with an input and an output entity of type int.
Intuitively, we expect the following semantics for the receive primitive: a receive expression rcv τ can be executed if/when 8 the external environment makes available some software component, which is assumed to travel with its type. 9 We model
e:τ '
this by a labelled reduction step 	) . If the reduction step is legal (that is,
the external code can be safely accepted, see below), then the receive expression is replaced by the component received from the outside. For example
int'→	'→	int	int
c	) [x: int '→ X; Y '→ 1; | x + 1] + [y: int '→ Y ; X '→ 2; ].
The type annotation τ in the receive primitive allows to statically type-check the local code before execution, and then to perform a run-time check. Indeed, external code is accepted only if it provides the expected functionalities, formally expressed by the type τ . Note that in this way code is never reinspected, since dynamic checks are performed on types.
However, requiring an exact match between required and dynamically available type, as in the above example, would be a too restrictive constraint, forcing to reject many components which could be safely composed with local code. A less restrictive requirement which seems rather natural is to accept dynamically available code whose type τ ' is a subtype (in the sense of the standard width/depth subtyping relation) of the required type τ . For instance, in the previous example, one could safely accept the module [; X '→ 2,Z '→ 3; ], containing more output and less input entities than those required, obtaining [x: int '→ X; Y '→ 1; | x + 1] + [; X '→ 2,Z '→ 3; ] which is a well-typed expression.
However, assuming the simple semantics by replacement of the receive primitive described above, a standard subtyping rule is not enough. Indeed, as it is well- known in object and module calculi [15,3,4], there is the problem of unintentional clashes. For instance, if in the example above we receive the module [; X '→ 2,Y '→ 0; ] of type [; X: int,Y : int], which is a subtype of the required type, then we would obtain

8 We abstract here from the details of the communication mechanism.
9 We assume here to trust the incoming type information to be correct: a more sophisticated approach would require a proof, as in [14]. Moreover, we assume the retrieved expression to be ground. Formally, we
assume the judgment ∅▶ e : τ ' to hold.

the expression [x: int '→ X; Y '→ 1; | x + 1] + [; X '→ 2,Y '→ 0; ] which cannot be reduced since there are two conflicting definitions for Y .
In this section, we present a first solution to this problem, which keeps the type system of the R-calculus and the dynamic checks based on a standard subtyping relation described above, and solves conflicts by adopting a more involved semantics of the receive primitive. That is, all entities which were not explicitly required are hidden to local code. This choice is analogous to that made in [4]. In this way more external components can be accepted, but the result is different from that we would obtain if code was statically available.
The calculus which exploits the hiding-based solution is called Rrcv . The new reduction rules are given in Fig.4, where, for H = X1 ... Xn, we write freezeH e for freezeX1 .. . freezeXn e and e\H for e \X1 .. . \Xn .

(c-rcv)



(rcv)
rcv cτ  e:c)τ2 e

cτ2 ≤core cτ1

τ2 ≤ τ1
τi ≡ ˆπι; πo˜ ∨ τi ≡ ˆπι; πo; cτi˜ ,i ∈ {1, 2}

rcv τ1	) (freezeH e) \H
H = dom(πo)\dom(πo)

(err)
rcv τ  e:)τ2 err
2	1
τ2 /≤ τ1


πι ≤ πι  πo ≤ πo
ˆπι ; πo˜ ≤ ˆπι ; πo˜  cτ ≤	cτ
J ⊆ I	ncτj ≤corecτ ' | j ∈ J o

  2	1	1	2 
ˆπι ; πo˜ ≤ ˆπι ; πo˜
  1	1	2	2	1  core  2 
ˆπι ; πo; cτ1˜ ≤ ˆπι ; πo; cτ2˜
j


Xi: cτi∈I ≤ Xj: cτ 'j∈J


Fig. 4. Semantics `a la MoMi for the receive primitive and subtyping relation
Rules (c-rcv) and (rcv) model successful retrieval of a core and module/configuration expression, respectively. The reduction step can be performed only if the type of the incoming expression is a subtype of the required type (side-condition in both rules) and the effect is that the receive primitive is replaced by the external code. However, in case a module/configuration is received, this replacement takes place only after all non explicitly required output names have been hidden. The hiding operator can be expressed, as usual in module calculi [3], by a combination of freeze and delete; indeed, virtual entities need to be frozen before being deleted, in order to make their definitions local 10 .
Rule (err) raises an error if the type of the incoming expression is not a subtype of the required type. We omit error propagation rules through one hole contexts, which are standard. Moreover, we assume that standard contextual closure (rule (E) in Fig.A.1 in the Appendix) also holds for labelled steps.
The subtyping relation is defined assuming a subtyping relation ≤core on core types 11 , and allows to replace a module or a configuration by another having less input and more output entities, with covariant subtyping for output and contravari- ant subtyping for input. For instance, in the configuration
c1 =Δ [x: int '→ X, y: int '→ Y ; Y '→ 1,Z '→ 2; | y + x]+ rcv [Y : int,W : int; X: int]

10 The freeze operator has no effect on entities which are already frozen.
11 We assume that ≤core satisfies subsumption property, that is, Γ ▶ e : cτ1 and cτ1 ≤core cτ2 implies Γ▶ e : cτ2.

the module m =Δ [y: int '→ Y ; X '→ 3+ y, Y '→ 4,Z '→ 5; ] can be safely received, leading to:

m:[Y :int; X:int,Y :int,Z:int]
c1
[x: int '→ X, y: int '→ Y ; Y '→ 1,Z '→ 2; | y + x]+ (freezeY,Z m)\Y,Z (fre)eze) (d)el)

[x: int '→ X, y: int '→ Y ; Y '→ 1,Z '→ 2; | y + x]+ [; X '→ 3+ y; y '→ 4] (su)m)
[x: int '→ X, y: int '→ Y ; Y '→ 1,Z '→ 2,X '→ 3+ y'; y' '→ 4| y + x]  ) .. .
Note that, in case a deferred (that is, only input) entity is required, and a virtual entity is provided (as happens for Y in the example), since unexpected output entities are hidden, the virtual entity becomes local. This reflects the intuition that local code wants to supply a definition for Y (Y '→ 1 in the example) but, since external code already has its own definition (Y '→ 4), the latter takes the precedence. An alternative semantics giving precedence to local code would be obtained by replacing, in rule (rcv), (freezeH e) \H by e\H . The example above would become:

m:[Y :int; X:int,Y :int,Z:int]
c1
[x: int '→ X, y: int '→ Y ; Y '→ 1,Z '→ 2; | y + x]+ m\Y,Z (d)el)

[x: int '→ X, y: int '→ Y ; Y '→ 1,Z '→ 2; | y + x]+ [y: int '→ Y ; X '→ 3+ y; ] (su)m)
[x: int '→ X, y: int '→ Y, y': int '→ Y ; Y '→ 1,Z '→ 2,X '→ 3+ y'; | y + x]  ) .. .
Analogously, a frozen entity can be provided when a virtual is required.

As the example shows, Rrcv
does not preserve the semantics of the R-calculus.

That is, when dynamically retrieving an expression the behaviour is different from
that we would get if the expression was statically available (see Theorem 4.5 in the next section).
Soundness of the Rrcv -calculus is guaranteed by soundness of the R-calculus (Theorems A.2 and A.3 in the Appendix), together with the theorem below which states that dynamic retrieval of an expression leads to a well-typed term.
e:τ
Theorem 3.1 (Subject Reduction) If Γ ▶ e1 : τ1 and e1  ) e2, then Γ ▶ e2 :
τ2, for some τ2 ≤ τ1.

Preventing dynamic clashes by constraints checking
In this section we consider a different solution to the problem of unintentional clashes, which keeps a simple semantics by replacement for the receive primitive by means of a more sophisticated type system which prevents dynamic conflicts. The resulting new calculus is called Rrcv . Before giving the formal definitions, we illustrate the approach on a simple example. Consider the following configuration
c2 =Δ [x: int '→ X, y: int '→ Y ; Z '→ 2; | y + x]+ rcv [W : int; X: int]
In order to avoid conflicts with local code, the type of the expression to be re- trieved, besides being a subtype of [W : int; X: int], should satisfy the following informal constraints:
no output entity named Z should be present, since this would cause a conflict with the definition in c2;
in case an output entity named Y is present, its type should be int (otherwise we would get an ill-formed module type where the input type of a virtual entity is different from its output type).

In order to formally express these constraints, we assign to the receive subexpression a polymorphic (module) type of shape [W : int; X: int, r] , where r is a row variable [18] which models the unknown additional features of code which will be retrieved at run time. Consequently, the type assigned to c2 is the following constrained polymorphic (conﬁguration) type:
Z: int#r, Y : int  r ⇒[W : int,Y : int; Z: int, X: int, r; int]
where Z: int#r and Y : int  r mean that Z: int and r have disjoint domain 12 and that r
assigns type int to Y entity, if any, respectively.
The row variable r will be replaced during execution by the actual unexpected output signature of the received module. For instance, if the module [; X '→ 2,Y '→ 3; ]: [; X: int,Y : int] is dynamically retrieved, then r is replaced by Y : int. This replacement is safe since the ground constraints Y : int#Z: int and Y : int  Y : int are valid. On the contrary, the module [; X '→ 2,Z '→ 2; ] of type [; X: int,Z: int] is rejected, since Z: int violates the first constraint.
We now formally define the Rrcv -calculus.

Type system
First, we introduce constrained polymorphic types in Fig.5.  They are pairs

C⇒ τˆ	constrained polymorphic type
τˆ∈Type ::= cτ | [πι; πˆo] | [πι; πˆo; cτ ]	polymorphic type
πˆ	:= π, R	polymorphic signature
R	::= ri∈I	row variables
C	::= ci∈I	constraints
c	::= π  πˆ | πˆ1#πˆ2 (RVar(πˆ1)∩RVar(πˆ2)=∅)	constraint

Fig. 5. Rrcv constrained polymorphic types
consisting of a sequence of constraints C and a polymorphic type τˆ. Polymorphic types are a generalization of R-calculus types (as in Fig.2) where output signatures πˆo may contain row variables (one for each receive subexpression). We convention- ally write row variables at the end, and denote by RVar(πˆ) the set of row variables
inside πˆ, defined in the obvious way, and analogously for C. Standard R-calculus types (types of terms which do not contain receive subexpressions) are obtained by taking empty constraint and row variable sequences. As explained above, the former constraint requires a non-polymorphic (input) signature to be compatible
with a polymorphic (output) signature, whereas the latter requires two polymor-
phic (output) signatures to have disjoint domains. The condition RVar(πˆo)∩RVar(πˆo)=∅
1	2
prevents row variable clashes.
The type system is in Fig.6. It derives judgments of the form Γˆ ▶ e : C⇒ τˆ, where a context Γˆ is an assignment of constrained polymorphic (core) types to variables. We assume to associate to each receive expression a fresh row variable. That is, an expression rcv [πι; πo] becomes rcv [πι; πo, r], with r fresh.

12 Even though this form of constraint does not depend on the type of entities, we write a signature rather than just a set of names for uniformity with the other form.

We use the following abbreviations: π1  π2 for ∀X∈dom(π1)∩dom(π2). π1(X)= π2(X), that is, the two signatures agree on their common domain; πo#πo for dom(πo) ∩ dom(πo) = 
1	2	1	2
∅, that is, the two (output) signatures have disjoint domains. Typing rules are


.. .  (typing rules for core operators)
(var)
Γˆ ▶ x : Γˆ(x)

nΓˆ, xi: Ci ⇒ cτi∈I∪L ▶ eh : Ch ⇒ cτh | h∈O ∪ Lo

i∈I


j∈O

(m-basic)	»
i∈I

j∈O
l∈L  –
Xi: cτi	Xj: cτj

k  ˆX : cτi∈I ; X : cτj∈O˜
i	i	j	j
ι	ι
1  2

(m-sum)
πo#πo

1	2
πι πo, πι πo



(m-del)
Γˆ ▶ e : C⇒[πι; πo, R]


Γˆ ▶ e\X : C⇒[πι; πo \X, R]
Γˆ ▶ e : C⇒[πι; πo, R]

X∈dom(πo)
1  2  2  1

(m-freeze)
Γˆ ▶freezeX e: C⇒[πι \X; πo, R]
X∈dom(πι) ⇒ X∈dom(πo)

Γˆ, xi: Ci ⇒ cτi∈I∪L ▶ e : C⇒ cτ	nΓˆ, xi: Ci ⇒ cτi∈I∪L ▶ eh : Ch ⇒ cτh | h ∈ O ∪ Lo

(basic)
i
»	i∈I

j∈O
i
l∈L	–
Xi: cτi∈I Xh: cτ h∈O

ˆXi: cτi∈I ; Xj: cτj∈O; cτ ˜
i	j
ι	ι
1  2

(sum)
πo#πo

1	2
πι πo, πι πo



(del)
Γˆ ▶ e : C⇒[πι; πo, R; cτ ]


Γˆ ▶ e\X : C⇒[πι; πo \X, R; cτ ]
Γˆ ▶ e : C⇒[πι; πo, R; cτ ]

X∈dom(πo)
1  2  2  1

(freeze)


(run)
Γˆ ▶freezeX e : C⇒[πι \X; πo, R; cτ ] Γˆ ▶ e : C⇒[πι; πˆo]
(res)
X∈dom(πι) ⇒ X∈dom(πo)
Γˆ ▶ e : C⇒[∅; πˆo; cτ ]





(rcv)


▶ τˆ

Γˆ ▶ e ↓X: C⇒[πι; πˆo; πˆo(X)]
Γˆ ▶ e ↑: C⇒ cτ
Fig. 6. Rrcv typing rules
Γˆ ▶ rcv τˆ: ∅⇒ τˆ



analogous to those given for the R-calculus (see Fig.A.3 in the Appendix), with the difference that types assigned to expressions with receive subexpressions contain row variables in the output signature and may contain constraints. In particular, row variables are generated by the (rcv) rule, that assigns to a receive expression rcv τˆ the polymorphic type τˆ, which must be well-formed (side-condition), where well-formed polymorphic types are defined in Fig.8. Then, constraints are generated by rules (m-sum) and (sum), to guarantee that statically unknown output entities of an argument will be type compatible with deferred (only input) 13 entities of the other (first two constraints), and there are no conflicts between statically unknown output entities of an argument and output entities (both statically known and unknown) of the other (last three constraints). All other rules only propagate constraints.
Note that in rule (m-basic) and (basic) constraints inferred for module entities and

13 Compatibility with input entities which are output as well (that is, are virtual) is implied by the stronger third and fourth constraints.





(rcv)

e:C2⇒τˆ2
RVar(C1 ⇒ τˆ1) ∩ RVar(C2 ⇒ τˆ2)= ∅ C, C ⇒ τˆ ≤ C ⇒ τˆ

⟨rcv τˆ1, C1⟩ 	) ⟨e, C, C2⟩
2	2	1	1


(err)

e:C2⇒τˆ2
RVar(C1 ⇒ τˆ1) ∩ RVar(C2 ⇒ τˆ2)= ∅ C, C ⇒ τˆ /≤ C ⇒ τˆ

⟨rcv τˆ1, C1⟩ 	) err
2	2	1	1


C⇒ τˆ ≤ C' ⇒ τˆ' iff C ▶ C'{ρ} and τˆ ≤ρ τˆ' (for some ρ)
C' ▶ C1 C' ▶ C2

  1	2	

C' , C' ▶ C1, C2	c ▶ ∅ 
c ::= πι  R
|  πo#R
πι πo

1  2
|  R1#R2

πo#πo

πo#R2, πo#R1, R1#R2 ▶ πo, R1#πo, R2	1	2

πι ≤ πι
1	2
πo ≤ πo	o
1	2
o	ˆπι ; πˆo˜ ≤ρ ˆπι ; πˆo˜ cτ1 ≤core cτ2

ˆπι ; πo, πˆo˜ ≤
ˆπι ; πo, R˜
ρ(R)= πˆo
ˆπι ; πˆo; cτ ˜ ≤
ˆπι ; πˆo; cτ ˜

Fig. 7. Semantics with dynamic checks for the receive primitive and subtyping relation
program are propagated to the whole module/configuration. For instance, the con- figuration
[x: int '→X; X '→ (rcv [; Y : bool, r]+ [y: bool '→ Y ; P '→ if y then 0 else 1; ] ↓P ) ↑; | x].
can be safely reduced only under the constraint P : int#r.

Semantics
The semantics is given on pairs of the form ⟨e, C⟩, where C is assumed to contain all constraints inferred during the type-checking of e (see Theorem 4.2 below). Fig.7 contains reduction rules for the receive primitive. Other rules are omitted since they
are analogous to those of the R-calculus (see Fig.A.1 in the Appendix) with the constraints component unchanged. Note that, since this also holds for contextual closure, in reduction rules for receive expressions in Fig.7 constraints are global, that is, are those of the enclosing top-level expression.
Rule (rcv) deals with the dynamic retrieval of an expression. The former side- condition prevents row variable clashes between local and external code and can always be satisfied by an appropriate α-conversion. The latter side-condition allows the reduction step only if type τˆ2 is a subtype of the required type τˆ1 modulo sub- stitution of the row variable with the unexpected output signature, and, moreover, all required constraints are valid by applying this substitution. This is formally modeled by the subtyping relation in Fig.7.
For instance, the expression rcv [; X: int, r']+ [x: int '→ X; P '→ x + 1; ] requires the con- straint P : int#r'. Reduction under this constraint can proceed by dynamically re- trieving the module freezeZ ([z: int '→ Z; X '→ z ∗ 2,W '→ 1; ] + rcv [; Z: int, r]) of type X: int,W : int#r ⇒ [; X: int,W : int, Z: int, r] (r' is replaced by W : int,Z : int,r and the ground constraint P : int#W : int,Z : int is satisfied). After the (rcv) step, we get an expression requiring the constraints P : int#r, X: int,W : int#r which, indeed, have been added in the current constraint sequence.
Rule (err) raises an error err if the required subtyping relation does not hold. We

omit error propagation rules through one hole contexts, which are standard.
Note that constraints are solved incrementally, as shown by the following exam- ple. Consider the configuration c3 =Δ rcv [X: int; Y : int, r1]+ rcv [Y : int; Z: int, r2] , for which constraints C = X: int  r2, Z: int#r1,Y : int#r2, r1#r2 are inferred. Assume to reduce sum ar- guments from left to right and to first receive a module m = [x: int '→ X; Y '→ 0,W '→ 1; ]; then, since Z: int#W : int, constraints can be successfully simplified as follows:
m : ∅⇒[X: int; Y : int,W : int]
⟨c3, C⟩	)
⟨[x: int '→ X; Y '→ 0,W '→ 1; ] + rcv [Y : int; Z: int, r2] , X: int  r2,Y : int#r2,W : int#r2⟩.
Assume to receive now the module [; Z '→ 2,W '→ 1; ] , whose type is a subtype of the required type. Constraints are not satisfied, hence we get an error.

Results
First of all, types inferred by the type system are well-formed, in the sense that their non polymorphic parts are well-formed R-calculus types (see Fig.8). Well- formedness of R-calculus types is defined in Fig.A.2 in the Appendix, and means that signatures πι and πo together define a map from entity names into well-formed (core) types (this implies in particular that the input and output signature agree on the type of a virtual entity). Moreover, constraints inferred by the type system are in normal form, in the sense that they do not contain ground constraints whose validity could be checked. This is formalized by the proposition below.



▶[πι; πo]
▶[πι; πo, R]
▶[πι; πo; cτ ]


▶[πι; πo, R; cτ ]

Fig. 8. Rrcv -calculus well-formed types
Proposition 4.1 If Γˆ ▶ e : C⇒ τˆ, then C ▶ C and ▶ τˆ.
Soundness of the Rrcv -calculus is guaranteed by soundness of the R-calculus, to- gether with the theorem below which states that dynamic retrieval of an expression leads to a well-typed term.
ˆ	e:C⇒τˆ
Theorem 4.2 (Subject Reduction) If Γ▶ e1 : C1 ⇒ τˆ1 and ⟨e1, C1⟩   ) ⟨e2, C2⟩,
then Γˆ ▶ e2 : C2 ⇒ τˆ2, with C2 ⇒ τˆ2 ≤ C1 ⇒ τˆ1.
Finally, we state some results of comparison between the approach based on hiding and that based on constraint checking. To this end, we denote by ¨ ¨ an
erasure function forgetting row variables in expressions and types; moreover, we
add an index in reductions and type judgments, to make clear to which approach they are related.
The following proposition states that the constraint-based system derives types which are an extension with row variables and constraints of those derived by the hiding-based system.

Proposition 4.3
cstr
Γˆ ▶ e : C⇒ τˆ
iff	¨Γˆ¨ hide ¨e¨ : ¨τˆ¨.

The following theorem states that the hiding-based approach is strictly more per- missive than the constraint-based, in the sense that more external code is accepted.


Theorem 4.4
cstr
ˆ

e:C⇒τˆ

¨  ¨ e:¨τˆ¨

If Γ
▶ e1 : C1 ⇒ τˆ1, and ⟨e1, C1⟩ 	) ⟨e2, C2⟩, then e1
  ) e , for some e .
hide

The converse does not hold.
Finally, the following theorem states that the constraint-based approach pre- serves the R-calculus semantics, in the sense that a term containing receive subex- pressions reduces, by dynamically retrieving code, to the same term we would get if code was statically available. This property does not hold for the Rrcv -calculus (see for instance the reduction sequence for c1 in Sect.3). Here, we denote by E[ ]1 .. .[ ]n
e1:τ1...en:τn
a context with n holes, and we abbreviate by 	) a reduction sequence
∗	e1:τ1	∗	∗	en:τn	∗

  )   )   ) ...   )   )   ) .
Theorem 4.5 Given e = E[rcv τ1]1 .. .[rcv τn]n s.t. equivalently by Prop.4.3, ¨Γˆ¨ hide ¨e¨ : ¨τˆ¨ ),

cstr
Γˆ ▶ e : C ⇒ τˆ

holds (or,

e1:τ1...en:τn	'	'	∗	'

if ⟨e, C⟩
cstr ) ⟨e , C ⟩, then E[e1]1 .. .[en]n
  ) e .

e1:τ1...en:τn	'	∗	'

if e
  )
hide ) e , then E[e1]1 .. .[en]n	e
does not hold.

Conclusion
The main contribution of the paper is to illustrate, in a simple and expressive formal framework for software composition, two different approaches to the problem of guaranteeing safe composition of software components retrieved at run-time with local code.
Both approaches are based on run-time checks which compare requirements statically made on external code with functionalities actually provided at run-time, and model this comparison by a relation between types. The former keeps dynamic checks simple, and solves interference problems by hiding functionalities which were not explicitly required. As already mentioned, this approach is advocated in [4] with the motivation that, whereas static name clashes should be considered as errors, dynamic name clashes should be allowed since they represent only an homonymy problem to be solved by static bindings. However, a drawback of this solution is that it does not preserve the semantics we would get if code would have been statically available. The latter solution, on the contrary, preserves the semantics we would get in the static case, by means of a more involved type system based on constraints, where dynamic checks prevents conflicts.
Our aim here is not to defend either choice, but rather to show that both can be modeled in a rather simple way, proved to be sound, and formally compared, in our calculus. In particular, it is worth to note that in the general and powerful frame-

work for software composition provided by mixin modules the operation consisting in solving clashes by renaming can be nicely internalized in terms of the primitive language operators, whereas in previous work [11,4] this operation can be only de- fined at a metatheory level and sometimes in a rather tricky way. However, by a preliminary analysis there seems to be no trivial way to generalize this approach to the higher-order case, since we would need an hiding operator propagating to subcomponents as well, which can be hardly be expressed as a derived module op- erator. This can be seen as another drawback of the hiding-based approach versus the constraint-based, which can be immediately generalized to higher-order mod- ules.
An hybrid solution could adopt the constraint-based type system given for Rrcv , but with a different treatment of unexpected output components violating con-

straints, which could be hidden as in Rrcv
rather than just rejecting external code.

As final remark, it is worth to mention that the problem of name clashes is, of course, not significant if components are just put side by side as black boxes, and ambiguity solved by using qualified names; however, in this case references to other components are hard links. Instead, modularity and software reuse can be greatly improved if a component’s code abstracts from used components, by just specifying the services they should provide, hence can be possibly instantiated in many contexts, as, e.g., in the component frameworks for Java-like languages proposed in [2].
As already mentioned, the schema we adopt here, based on a combination of static typechecking of local code and dynamic checks via subtyping is the same as in MoMi [4]. However, there are many differences with this work. First, in MoMi exchanged code is object-oriented (more precisely, classes or mixin classes), whereas here we are interested in a more general framework for software composition where entities which are exchanged are mixin modules on an arbitrary core language. Note, in particular, that this allows symmetric composition (by sum) of local and external code, differently from MoMi where composition is always in one direction (instantiation of a mixin class on a parent). Moreover, in MoMi there is an explicit language for the process layer, different from the language used for the object- oriented code; here instead for simplicity we have just a receive primitive integrated in the language, since this addition was enough in order to study the problem of dynamic checks.
Other work which has directly inspired this paper is that on dynamic software updating in, e.g., [5,17,12]. However, our approach here is in the context of mod- ule/fragment calculi rather than lambda-calculi, and we take as basic primitive a receive primitive for retrieving external code on demand, whereas in [5,17,12] the basic primitive is an update primitive which when performed changes some part of the local code in a less controlled way.
The type system based on constraints used in the latter solution is similar to that defined in [13] for getting principal typings for mixin modules. However, here more simple constraints are enough since we consider an explicitly typed module calculus, where the only source of polymorphism is the receive primitive which is,

however, also annotated with the required components. A precise comparison with the type system defined in [13] is subject of further work.
Finally, other works on formalization of components are, e.g., [6,16].
Other directions for further work, are the integration of our approach with an
explicit language for the process layer, as in MoMi, and, as mentioned above,
the extension to a higher-order calculus. Finally, even though the framework for software composition offered by the R-calculus is rather general and powerful, we are bound to a fixed arbitrary set of operators; hence, we would like to investigate an even more abstract framework for expressing and studying safe combination of local and retrieved code via dynamic checks. All these directions have already been partly investigated in [10].

References
Ancona, D., S. Fagorzi and E. Zucca, Mixin modules for dynamic rebinding, in: R. D. Nicola and
D. Sangiorgi, editors, TGC 2005 - Trustworthy Global Computing, International Symposium, Revised Selected Papers, number 3705 in Lecture Notes in Computer Science (2005), pp. 279–298.
Ancona, D., G. Lagorio and E. Zucca, Flexible type-safe linking of components for Java-like languages, in: JMLC’06 - Joint Modular Languages Conference, Lecture Notes in Computer Science (2006), to appear.
Ancona, D. and E. Zucca, A calculus of module systems, Journ. of Functional Programming 12 (2002),
pp. 91–132.
Bettini, L., B. Venneri and V. Bono, MOMI: a calculus for mobile mixins, Acta Informatica 42 (2005),
pp. 143–190.
Bierman, G., M. W. Hicks, P. Sewell, G. Stoyle and K. Wansbrough, Dynamic rebinding for marshalling and update, with destruct-time λ, in: C. Runciman and O. Shivers, editors, Intl. Conf. on Functional Programming 2003 (2003), pp. 99–110.
Bruneton, E., T. Coupaye, M. Leclercq, V. Qu´ema and J.-B. Stefani, An open component model and its support in Java, in: CBSE’04 - Component-Based Software Engineering, 2004, pp. 7–22.
Fagorzi, S., “Module Calculi for Dynamic Reconfiguration,” Ph.D. thesis, Dipartimento di Informatica e Scienze dell’Informazione, Universit`a di Genova (2005).
Fagorzi, S. and E. Zucca, A calculus for reconfiguration, Electronic Notes in Theoretical Computer Science 135 (2005), DCM 2005 - International Workshop on Developments in Computational Models.
Fagorzi, S. and E. Zucca, A calculus for reconfiguration, Technical report, Dipartimento di Informatica e Scienze dell’Informazione, Universit`a di Genova (2005), extended version of [8], submitted for journal publication.
Fagorzi, S. and E. Zucca, A framework for type safe exchange of mobile code, Technical report, Dipartimento di Informatica e Scienze dell’Informazione, Universit`a di Genova (2006), submitted for publication.
Flatt, M., S. Krishnamurthi and M. Felleisen, Classes and mixins, in: ACM Symp. on Principles of Programming Languages 1998 (1998), pp. 171–183.
Hicks, M. W. and S. Nettles, Dynamic software updating., ACM Transactions on Programming Languages and Systems 27 (2005), pp. 1049–1096.
Makholm, H. and J. B. Wells, Type inference, principal typings, and let-polymorphism for first-class mixin modules, in: O. Danvy and B. Pierce, editors, Intl. Conf. on Functional Programming 2005 (2005), pp. 156–167.
Necula, G. C., Proof-carrying code., in: ACM Symp. on Principles of Programming Languages 1997
(1997), pp. 106–119.
Riecke, J. G. and C. A. Stone, Privacy via subsumption, Information and Computation 172 (2002),
pp. 2–28.

Schmitt, A. and J.-B. Stefani, The kell calculus: A family of higher-order distributed process calculi, in: C. Priami and P. Quaglia, editors, GC2004 - Global Computing IST/FET International Workshop
- Revised Selected Papers, Lecture Notes in Computer Science 3267 (2005), pp. 146 – 178.
Stoyle, G., M. W. Hicks, G. Bierman, P. Sewell and I. Neamtiu, Mutatis mutandis: safe and predictable dynamic software updating, in: ACM Symp. on Principles of Programming Languages 2005 (2005),
pp. 183–194.
Wand, M., Complete type inference for simple objects, in: Proc. IEEE Symp. on Logic in Computer Science 1987, 1987, pp. 37–44, a corrigendum appeared at LICS 1988.
Wells, J. B. and R. Vestergaard, Confluent equational reasoning for linking with first-class primitive modules, in: ESOP 2000 - European Symposium on Programming 2000, number 1782 in Lecture Notes in Computer Science (2000), pp. 412–428.

Formal definition of the R-calculus
We report semantics and type system of the R-calculus in Fig.A.1-A.2-A.3-A.4, and state related results. We refer to [1,7,8,9] for the formal (standard) definitions of free variables of an expression FV(e), hole binders of a context HB (E), capture avoiding hole substitution E {e} and proofs.



One hole contexts
E ::=  | (core c.o.n. texts)

| [ι; X '→ E, o; ρ] | [ι; o; x '→ E, ρ] | [ι; X '→ E, o; ρ| e] | [ι; o; x '→ E, ρ| e] |




(E)
[ι; o; ρ| E] | E + e | e + E | E \X | freezeX E | E↓X | E↑
e  ) e'
E[e]  ) E[e']	.. . (rules for core terms)

Module simplification
(m-sum) [ι ; o ; ρ ]+ [ι ; o ; ρ ]  ) [ι , ι ; o , o ; ρ , ρ ]

dom(ι1, ρ1) ∩ FV([ι2; o2; ρ2]) = ∅
dom(ι2, ρ2) ∩ FV([ι1; o1; ρ1]) = ∅


(m-del)
[ι; o; ρ] \X  ) [ι; o\X; ρ]
X∈dom(o)

	 F = {x | ι(x)= X}

(m-freeze)
h	x∈F	i F /= ∅ ⇒ X∈dom(o)




Reconfiguration
(sum) [ι ; o ; ρ | e]+ [ι ; o ; ρ ]  ) [ι , ι ; o , o ; ρ , ρ | e]

dom(ι1, ρ1) ∩ FV([ι2; o2; ρ2]) = ∅
dom(ι2, ρ2) ∩ FV([ι1; o1; ρ1]) = ∅


(del)
[ι; o; ρ| e] \X  ) [ι; o\X; ρ| e]
X∈dom(o)

	 F = {x | ι(x)= X}

(freeze)
freezeX [ι; o; ρ| e]	) hι\F ; o; ρ, x x F o(X)| ei
∈
F /=∅ ⇒ X∈dom(o)

	 x /∈ HB (E)

(local)
[ι; o; ρ| E[x]]  ) [ι; o; ρ| E {ρ(x)}]
x∈dom(ρ)

	 x /∈ HB (E)

(virtual)
[ι; o; ρ| E[x]]  ) [ι; o; ρ| E {o(ι(x))}]
x∈dom(ι) ∧ ι(x) ∈ dom(o)

Run and result
(run) [ι; o; ρ] ↓	 ) [ι; o; ρ| o(X)]
Reconfiguration contexts
R ::=  | R + e | R \X | freezeX R


(res)
(R[ι; o; ρ| e]) ↑  ) e

FV(e) ∩ dom(ι, ρ)= ∅

Fig. A.1. R-calculus reduction rules





▶ πι, πo
core
▶ cτ

▶ πι, πo
core
▶ cτi | i ∈ I

∀h, k ∈ I.Xh = Xk ⇒ cτh = cτk

▶[πι; πo; cτ ]
▶[πι; πo]
▶ Xi: cτi∈I

Fig. A.2. R-calculus well-formed types



.. .  (typing rules for core operators)
nΓ, xi: cτi∈I∪L ▶ eh : cτh | h ∈ O ∪ Lo
(var)


i∈I


Γ▶ x : Γ(x)

j∈O

(m-basic)	»
i∈I

j∈O
l∈L  –  ˆ
Xi: cτi	
Xj: cτj

Γ▶ e1 : ˆπι ; πo˜
l	l	i	j

Γ▶ e
: ˆπι ; πo˜
πι πι
Γ▶ e : [πι; πo]

Γ▶ e1 + e2 : ˆπι , πι ; πo, πo˜ π1   2	 π


Γ▶ e\X : [πι; πo \X]

Γ▶ e : [πι; πo]
1  2  2  1

(m-freeze)
Γ▶freezeX e : [πι \X; πo]
X ∈ dom(πι) ⇒ X ∈ dom(πo)

nΓ, xi: cτi∈I∪L ▶ eh : cτh | h ∈ O∪Lo  Γ, xi: cτ i∈I∪L ▶ e : cτ

(basic)	»
i

i∈I

j∈O
i
l∈L	–  ˆ
Xi: cτ i∈I
˜
Xj: cτ j∈O

l	l	i	j
Γ▶ e1 : ˆπι ; πo; cτ ˜	

Γ▶ e
: ˆπι ; πo˜
πι πι
Γ▶ e : [πι; πo; cτ ]

Γ▶ e1 + e2 : ˆπι , πι ; πo, πo; cτ ˜  π1   2	 π


Γ▶ e\X : [πι; πo \X; cτ ]


(freeze)
Γ▶ e : [πι; πo; cτ ]
Γ▶freezeX e : ˆπι \X; πo; cτ ˜
X ∈ dom(πι) ⇒
X ∈ dom(πo)

(run)
Γ▶ e : [πι; πo]


Γ▶ e ↓X : [πι; πo; πo(X)]


(res)
Γ▶ e : [∅; πo; cτ ] Γ▶ e ↑: cτ



Fig. A.3. R-calculus typing rules




v ∈ Val ::=	value
.. .	core values
|  [ι; o; ρ]	basic module
| [ι; o; ρ| v]	basic configuration Fig. A.4. R-calculus values
In typing rules we use the abbreviations π1  π2 and πo#πo introduced in Sect.4.
1	2
The following proposition states that the type system only derives well-formed types (defined in Fig.A.2).
Proposition A.1 If Γ▶ e : τ, then ▶ τ.
Theorem A.2 (Progress) If ∅▶ e : τ, then either e ∈ Val, or e   ) e', for some
e'.
Theorem A.3 (Subject Reduction) If Γ▶ e : τ and e   ) e', then Γ▶ e' : τ.
Proofs
Proof of Theorem 3.1. Induction on reduction rules. We only show the two base cases (c-rcv) and (rcv).

e:cτ
(c-rcv) In this case we have rcv cτ1	) e, with cτ ≤core cτ1, and by hypothesis Γ ▶
rcv cτ1 : cτ ' . This last judgment can only be derived by using typing rule (rcv),
hence, it must be cτ ' = cτ1. Moreover, we assume ∅▶ e : cτ (see footnote at page 6) and thus (by applying a weakening lemma) we get Γ▶ e : cτ .
(rcv) In this case we have rcv τ1	) (freezeH e) \H , with τ2 ≤ τ1 (*). We consider
the case τi ≡ [πι; πo] (the other one is similar).  By hypothesis we have Γ ▶
i	i
rcv [πι ; πo] : τ ' . To derive this last judgment, the only applicable rule is (rcv),
1	1	1
hence it must be τ ' ≡ [πι ; πo]. Moreover, we assume ∅▶ e : [πι ; πo] (see footnote
1	1	1	2	2
at page 6) and thus ∅▶ (freezeHe) \H : [πι \H; πo\H ], with H = dom(πo)\dom(πo).
2	2	2	1
By applying a weakening lemma we have that Γ ▶ (freezeHe) \H : [πι \H ; πo\H].
2	2
We can now conclude by observing that dom(πo\H)= dom(πo) and thus πι ≤
2	1	1
πι \H and πo\H ≤ πo (from (*)); hence, [πι \H; πo\H ] ≤ [πι ; πo].
2	2	1	2	2	1	1
Proof of Proposition 4.1. Induction on typing rules.
Proof of Theorem 4.2. We consider the following more general property:
ˆ	'	e:C⇒τˆ	'	'
If Γ ▶ e1 : C1 ⇒ τˆ1 and ⟨e1, C1⟩ 	) ⟨e2, C2⟩ with C1 ⊆ C1, then Γˆ ▶ e2 : C2 ⇒ τˆ2
with C' ⊆ C2 and C2 ⇒ τˆ2 ≤ C1 ⇒ τˆ1.
proved by induction on reduction rules. We illustrate the base case (rcv). We have
⟨rcv τˆ1, C1⟩	) ⟨e, C, C2⟩, with C, C2 ⇒ τˆ2 ≤ C1 ⇒ τˆ1, and, by hypothesis, Γˆ ▶ rcv τˆ1 :
C' ⇒ τˆ' , with C' ⊆ C1. This typing judgment can only be derived by using rule (rcv),
1	1	1

hence, it must be C'
= ∅ and τˆ'
= τˆ1. Moreover, we assume that ∅▶ e : C2 ⇒ τˆ2,

and thus (by applying a weakening lemma) we have Γˆ ▶ e : C2 ⇒ τˆ2. We can now
conclude by observing that C2 ⊆ C, C2.
Proof of Proposition 4.3. Induction on typing rules.
Proof of Theorem 4.4. Case analysis on reduction rules used to derive
e:C⇒τˆ
⟨e , C ⟩	) ⟨e , C ⟩ (the only applicable rules are (c-rcv) and (rcv)).
cstr
Proof of Theorem 4.5. Induction on the length n of the reduction sequence

) and induction on typing rules used to derive Γˆ
cstr
▶ e : C⇒ τˆ.
