Electronic Notes in Theoretical Computer Science 140 (2005) 31–39	
www.elsevier.com/locate/entcs

A Semantics of Realisability for the Classical Propositional Natural Deduction
Karim Nour
Equipe de Logique, Universit´e de Savoie 73376 Le Bourget du Lac, France
Khelifa Saber
Equipe de Logique, Universit´e de Savoie 73376 Le Bourget du Lac, France

Abstract
In this paper, we introduce a semantics of realisability for the classical propositional natural de- duction and we prove a correctness theorem. This allows to characterize the operational behaviour of some typed terms.
Keywords: classical natural deduction, semantics of realisability, correctness theorem.


Introduction
Natural deduction system is one of the main logical system which was intro- duced by Gentzen [4] to study the notion of proof. The full classical natural deduction system is well adapted for the human reasoning. By full we mean that all the connectives (→, ∧ and ∨) and ⊥ (for the absurdity) are considered as primitive and they have their intuitionistic meaning. As usual, the nega- tion is defined by ¬A = A →⊥. Considering this logic from the computer science of view is interesting because, by the Curry-Howard correspondence,

1 Email: knour@univ-savoie.fr
2 Email: ksabe@univ-savoie.fr




1571-0661 © 2005 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2005.06.026

formulas can be seen as types for the functional programming languages and correct programs can be extracted. By this correspondence the corresponding calculus is an extension of the λμ-calculus with product and co-product.
Until very recently (see the introduction of [3] for a brief history), no proof of the strong normalization of the cut-elimination procedure was known for full logic. In [3], P. De Groote gives a such proof for classical propositional natural deduction by using the CPS-transformation. R. David and the first author give in [2] a direct and syntactical proof of this result. R. Matthes recently found another semantical proof of this result (see [6]).
In order to prove the strong normalization of classical propositional natural deduction, we introduce in [8] a variant of the reducibility candidates, which was already present in [11]. This method has been introduced by J.Y. Girard. It consists in associating to each type A a set of terms |A|, such that every term is in the interpretation of its type (this is called “the adequation lemma”). To the best of our knowledge, we obtain the shortest proof of this result.
In this paper, we define a semantics of realisability of classical propositional natural deduction inspired by [8] and we estabilish a correctness theorem. The idea is to replace the set of strongly normalizing terms used in the proof presented in [8] by a set having the properties necessary to keep the adequation lemma. This result allows to characterize the operational behaviour of terms having some particular types.
The paper is organized as follows. Section 2 is an introduction to the typed system and the relative cut-elimination procedure. In section 3, we define the semantics of realisability and we prove the correctness theorem. In section 4, we give some applications of this result.

Notations and definitions
Definition 2.1  We use notations inspired by the paper [1].
Let X and A be two disjoint alphabets for distinguishing the λ-variables and μ-variables respectively. We code deductions by using a set of terms T which extends the λ-terms and is given by the following grammars:
T := X | λX .T | (T E) | ⟨T , T⟩ | ω1T | ω2T | μA.T | (A T )
E := T | π1 | π2 | [X .T , X .T ]
An element of the set E is said to be an E-term.
The meaning of the new constructors is given by the typing rules below where Γ (resp. Δ) is a context, i.e. a set of declarations of the form x : A (resp. a : A) where x is a λ-variable (resp. a is a μ-variable) and A is a formula.

ax
Γ,x : A ▶ x : A ; Δ 

Γ,x : A ▶ t : B;Δ →
Γ ▶ u : A → B;Δ	Γ ▶ v : A;Δ 



Γ ▶ λx.t : A → B;Δ	i
Γ ▶ (u v): B;Δ	→e

Γ ▶ u : A;Δ	Γ ▶ v : B;Δ 
Γ ▶ ⟨u, v⟩ : A ∧ B;Δ	∧i
Γ ▶ t : A ∧ B;Δ ∧1	Γ ▶ t : A ∧ B;Δ ∧2
	
Γ ▶ (t π1): A;Δ e	Γ ▶ (t π2): B;Δ e
Γ ▶ t : A;Δ	∨1	Γ ▶ t : B;Δ	∨2
	
Γ ▶ ω1t : A ∨ B;Δ i	Γ ▶ ω2t : A ∨ B;Δ i
Γ ▶ t : A ∨ B;Δ	Γ,x : A ▶ u : C;Δ	Γ,y : B ▶ v : C;Δ 
Γ ▶ (t [x.u, y.v]) : C;Δ	∨e

Γ ▶ t : A; Δ,a : A
Γ ▶ (a t): ⊥; Δ,a : A absi
Γ ▶ t : ⊥; Δ,a : A
Γ ▶ μa.t : A;Δ abse

The cut-elimination procedure corresponds to the reduction rules given below. They are those we need to the subformula property.
(λx.u v) d u[x := v]
(⟨t1, t2⟩ πi) d ti
(ωit [x1.u1, x2.u2]) d ui[xi := t]
((t [x1.u1, x2.u2]) ε) d (t [x1.(u1 ε), x2.(u2 ε)])
(μa.t ε) d μa.t[a :=∗ ε].
where t[a :=∗ ε] is obtained from t by replacing inductively each sub- term in the form (a v) by (a (v ε)).
Let t and t' be E-terms. The notation t d t' means that t reduces to t' by using one step of the reduction rules given above. Similarly, t d∗ t' means that t reduces to t' by using some steps of the reduction rules given above.
The following result is straightforward
Theorem 2.2  (Subject reduction) If Γ ▶ t : A;Δ and t d∗ t', then Γ ▶ t' :
A; Δ.
We have also the following properties (see [1], [2], [3], [8] and [9]).
Theorem 2.3  (Confluence) If td∗ t1 and td∗ t2, then there exists t3 such that
t1 d∗ t3 and t2 d∗ t3.
Theorem 2.4  (Strong normalization) If Γ ▶ t : A; Δ, then t is strongly normalizable.

The semantics
Definition 3.1   (i) We denote by E <ω the set of finite sequences of E-terms.
The empty sequence is denoted by ∅.
We denote by w¯ the sequence w1w2...wn. If w¯ = w1w2...wn, then (t w¯) is t if n =0 and ((t w1) w2...wn) if n /= 0. The term t[a :=∗ w¯] is the term obtained from t by replacing inductively each subterm in the form (a v) by (a (v w¯)).
A set of terms S is said to be μ-saturated iff:
For each terms u and v, if u ∈ S and v d∗ u, then v ∈ S.
For each a ∈A and for each t ∈ S, μa.t ∈ S and (a t) ∈ S.
Consider two sets of terms K, L and a μ-saturated set S, we define new sets of terms:
K → L = {t / (t u) ∈ L, for each u ∈ K}.
K ∧ L = {t / (t π1) ∈ K and (t π2) ∈ L}.
K ∨ L = {t / for each u, v: if (for each r ∈ K,s ∈ L: u[x := r] ∈ S and
v[y := s] ∈ S), then (t [x.u, y.v]) ∈ S}.
Let S be a μ-saturated set and {Ri}i∈I subsets of terms such that Ri = Xi → S for certains Xi ⊆ E <ω. A model M = ⟨S; {Ri}i∈I⟩ is the smallest set of subsets of terms containing S and Ri and closed under constructors
→, ∧ and ∨.
Lemma 3.2  Let M = ⟨S; {Ri}i∈I⟩ be a model and G ∈ M. There exists a set X ⊆ E <ω such that G = X → S.
Proof	By induction on G.
G = S: Take X = {∅}, it is clear that S = {∅} → S.
G = G1 → G2: We have G2 = X2 → S for a certain set X2. Take X = {u v¯
/ u ∈ G1, v¯ ∈ X2}. We can easly check that G = X → S.
G = G1 ∧ G2: Similar to the previous case.
G = G1 ∨ G2: Take X = {[x.u, y.v] / for each r ∈ G1 and s ∈ G2 , u[x :=
∈ S and v[y := s] ∈ S}. By definition G = X → S.


Definition 3.3 Let M = ⟨S; {Ri}i∈I⟩ be a model and G ∈ M, we define the set G⊥ = ∪{X / G = X → S}.
Lemma 3.4 Let M = ⟨S; {Ri}i∈I⟩ be a model and G ∈ M.
We have G = G⊥ → S (G⊥ is the greatest X such that G = X → S).

Proof  This comes from the fact that: if, for every j ∈ J , G = Xj → S, then G = ∪j∈J Xj → S.	 

Definition 3.5  (i) Let M = ⟨S; {Ri}i∈I⟩ be a model. An M-interpretation I is an application from the set of propositional variables to M which we extend for any type as follows:
I(⊥)= S
I(A → B)= I(A) → I(B).
I(A ∧ B)= I(A) ∧ I(B).
I(A ∨ B)= I(A) ∨ I(B).
The set |A|M = ∩{I(A) / I an M-interpretation} is the interpretation of A in M.
(ii) The set |A| = ∩{|A|M / M a model} is the interpretation of A.
Lemma 3.6 (Adequation lemma) Let M = ⟨S; {Ri}i∈I⟩ be a model, I a M-interpretation, Γ = {xi : Ai}1≤i≤n, Δ = {aj : Bj}1≤j≤m, ui ∈ I(Ai), v¯j ∈ I(Bj)⊥.

If Γ ▶ t : A; Δ, then t[x1 := u1, ..., xn := un, a1 :=∗
I(A).
Proof	Let us denote by s' the term
s[x1 := u1, ..., xn := un, a1 :=∗ v¯1, ..., am :=∗ v¯m].
v¯1, ..., am :=∗
v¯m] ∈

The proof is by induction on the derivation, we consider the last rule:
ax, →e and ∧e: Easy.
→i: In this case t = λx.u and A = B → C such that Γ,x : B ▶ u :
C ; Δ. By induction hypothesis, u'[x := v] ∈ I(C) = I(C)⊥ → S for

each v ∈ I(B), then (u'[x := v]
w¯) ∈ S for each w¯
∈ I(C)⊥, hence

((λx.u' v)
w¯) ∈ S because ((λx.u' v)
w¯) d∗ (u'[x := v]
w¯). Therefore

t' = λx.u' ∈ I(B) → I(C)= I(A).
∧i and ∨j: A similar proof.
∨e: In this case t = (t1 [x.u, y.v]) with (Γ ▶ t1 : B ∨ C; Δ), (Γ,x : B ▶
u : A; Δ) and (Γ,y : C ▶ v : A; Δ). Let r ∈ I(B) and s ∈ I(C), by
induction hypothesis, t' ∈ I(B) ∨ I(C), u'[x := r] ∈ I(A) and v'[y :=

∈ I(A).	Let w¯
∈ I(A)⊥, then (u'[x := r]
w¯) ∈ S and (v'[y :=

s] w¯) ∈ S, hence (t'
[x.(u' w¯), y.(v' w¯)]) ∈ S, since ((t'
[x.u', y.v')] w¯) d∗

(t'
[x.(u'
w¯), y.(v'
w¯)]) then ((t'
[x.u', y.v')]
w¯) ∈ S. Therefore t' =

(t' [x.u', y.v']) ∈ I(A).
abse: In this case t = μa.t1 and Γ ▶ t1 :⊥ ; Δ',a : A. Let v¯ ∈ I(A)⊥.
It suffies to prove that (μa.t' v¯) ∈ S. By induction hypothesis, t' [a :=∗

v¯] ∈ I(⊥)= S, then μa.t' [a :=∗ v¯] ∈ S and (μa.t'
v¯) ∈ S.

1	1

absi: In this case t = (aj u) and Γ ▶ u : Bj; Δ', aj : Bj. We have to prove that t' ∈ S. By induction hypothesis u' ∈ I(Bj), then (u' v¯j) ∈ S, hence t' = (a (u' v¯j)) ∈ S.

Theorem 3.7  (Correctness theorem) If ▶ t : A, then t ∈ |A|.
Proof   Immediately from the previous lemma.	 


The operational behaviors of some typed terms
The following results are some applications of the correctness theorem.
Definition 4.1  Let t be a term. We denote Mt the smallest set containing t such that: if u ∈ Mt and a ∈ A, then μa.u ∈ Mt and (a u) ∈ Mt. Each element of Mt is denoted μ.t. For exemple, the term μa.μb.(a (b (μc.(a μd.t)))) is denoted by μ.t.
In the next of the paper, the letter P denotes a propositional variable which represents an arbitrary type.

Terms of type ⊥→ P “Ex falso sequitur quodlibet”
Example 4.2  Let T = λz.μa.z. We have T :⊥→ P and for every term t
and u¯ ∈T <ω, ((T t) u¯) d∗ μa.t.
Remark 4.3 The term (T t) modelizes an instruction like exit(t) (exit is to be understood as in the C programming language). In the reduction of a term, if the sub-term (T t) appears in head position (the term has the form ((T t) u¯)), then after some reductions, we obtain t as result.
The general operational behavior of terms of type ⊥→ P is given in the following theorem:
Theorem 4.4  Let T be a closed term of type ⊥→ P, then for every term t
and u¯ ∈ E <ω, ((T t) u¯) d∗ μ.t.
Proof  Let t be a term and u¯ ∈ E <ω. Take S = {v / v d∗ μ.t} and R =
{u¯} → S. It is clear that S is μ-saturated set and t ∈ S. Let M = ⟨S; R⟩ and I an M-interpretation such that I(P )= R. By the theorem 3.7, we have T ∈ S → ({u¯}→ S), then ((T t) u¯) ∈ S and ((T t) u¯) d∗ μ.t.	 

Terms of type (¬P → P ) → P “Pierce law”
Example 4.5  Let C1 = λz.μa.(a (z λy.(a y))) and
C2 = λz.μa.(a (z (λx.a(z λy.(a x))))).
We have ▶ Ci : (¬P → P ) → P for i ∈ {1, 2}. Let u, v1, v2 be terms and t¯ ∈ E <ω, we have :
((C1 u) t¯) d∗ μa.a ((u θ1) t¯) and (θ1 v1) d∗ (a (v1 t¯))
and
((C2 u) t¯)d∗μa.((a ((u θ1) t¯)) t¯), (θ1 v1)d∗(a ((u θ2) t¯)) and (θ2 v2)d∗(a (v1 t¯)).
Remark 4.6	The term C1 allows to modelizing the Call/cc instruction in the Scheme functional programming language.
The following theorem describes the general operational behavior of terms with type (¬P → P ) → P .
Theorem 4.7 Let T bea closed term of type (¬P → P ) → P, then for every term u and t¯ ∈ E <ω, there exist m ∈ N and terms θ1, ..., θm such that for every terms v1, ..., vm, we have:
((T u) t¯) d∗ μ.((u θ1) t¯)
(θi vi) d∗ μ.((u θi+1) t¯) for every 1 ≤ i ≤ m − 1 (θm vm) d∗ μ.(vi0 t¯) for a certain 1 ≤ i0 ≤ m
Proof  Let u be a λ-variable and t¯ ∈ E <ω. Take S = {t / ∃m ≥ 0, ∃θ1, ..., θm
: td∗ μ.((u θ1) t¯), (θi vi) d∗ μ.((u θi+1) t¯) for every 1 ≤ i ≤ m − 1 and (θm vm) d∗ μ.(vi0 t¯) for a certain 1 ≤ i0 ≤ m} and R = {t¯} → S. It is clear that S is a μ-saturated set. Let M = ⟨S; R⟩ and an M-interpretation I such that I(P ) = R. By the theorem 3.7, T ∈ [(R → S) → R] → ({t¯} → S). It is suffies to check that u ∈ (R → S) → R. For this, we take θ ∈ (R → S) and we prove that (u θ) ∈ R i.e. ((u θ) t¯) ∈ S. But by the definition of S, it suffies to have (θ vi) ∈ S, which is true since the terms vi ∈ R, because (vi t¯) ∈ S. 

Terms of type ¬P ∨ P “Tertium non datur”
Example 4.8 Let W = μb.(b ω1μa.(b ω2λy.(a y))). We have ▶W : ¬P ∨ P . Let x1, x2 be λ-variables, u1, u2,v terms and t¯ ∈ E <ω. We have:
(W [x1.u1, x2.u2]) d∗ μb.(b u1 [x1 := θ1])
(θ1 t¯) d∗ μa.(b u2 [x2 := θ2])
1	2
(θ2 v) d∗ (a(v t¯))
where θ1 = μa.(b (ω2λy.(a y) [x1.u1, x2.u2])) and θ2 = λy.(a (y t¯)).
1	2
Remark 4.9	The term W allows to modelizing the try...with... instruction in the Caml programming language.

The following theorem gives the behavior of all terms with type ¬P ∨ P .
Theorem 4.10  Let T be a closed term of type ¬P ∨ P, then for every λ- variables x1, x2 and terms u1, u2 and (t¯n)n≥1 a sequence of E <ω, there exist

m ∈ N and terms θi , ..., θi
1 ≤ i ≤ 2 such that for all terms v1, ..., vm, we

1	m
have:
(T [x1.u1, x2.u2]) d∗ μ.ui[xi := θi ]

(θ1 t¯j ) d∗ μ.ui[xi := θi
] for all 1 ≤ j ≤ m − 1

j	j+1

(θ2 vj) d∗ μ.ui[xi := θi
] for all 1 ≤ j ≤ m − 1

j	j+1
(θ1 t¯m) d∗ μ.(vp t¯q ) for a certain 1 ≤ p ≤ m and a certain 1 ≤ q ≤ m
(θ2 vm) d∗ μ.(vp t¯q ) for a certain 1 ≤ p ≤ m and a certain 1 ≤ q ≤ m
Proof	Let u1, u2 be terms and (t¯n)n≥1 a sequence of E <ω. Take then S = {t

/ ∃m ≥ 0, ∃θi , ..., θi 1 ≤ i ≤ 2: td∗ μ.ui[xi := θi ], (θ1 t¯j ) d∗ μ.ui[xi := θi
] for

1	m	1	j	j+1
all 1 ≤ j ≤ m − 1, (θ2 vj) d∗ μ.ui[xi := θi	] for all 1 ≤ j ≤ m − 1, (θ1 t¯m) d∗
j	j+1	m
μ.vp(t¯q ) for certain (1 ≤ p ≤ m and 1 ≤ q ≤ m) and (θ2 vm) d∗ μ.(vp t¯q ) for
certain (1 ≤ p ≤ m and 1 ≤ q ≤ m)}. R = {t¯1, ..., t¯n} → S. By definition S
is a μ-saturated set. Let M = ⟨S; R⟩ and an M-interpretation I such that I(P ) = R. By the theorem 3.7, T ∈ [R → S] ∨ R. Let θ ∈ R, then, for all i, (θ t¯i) ∈ S. Let θ' ∈ R → S, hence (θ' vi) ∈ S since vi ∈ R (because (vi t¯i) ∈ S), therefore (T [x1.u1, x2.u2]) ∈ S.	 

References
Y. Andou. Church-Rosser property of simple reduction for full ﬁrst-order classical natural deduction. Annals of Pure and Applied Logic 119 (2003) 225-237.
R. David and K. Nour. A short proof of the Strong Normalization of Classical Natural Deduction with Disjunction. Journal of Symbolic Logic, vol 68, num 4, pp 1277-1288, 2003.
P. de Groote. Strong normalization of classical natural deduction with disjunction. In 5th International Conference on Typed Lambda Calculi and Applications, TLCA’01. LNCS (2044),
pp. 182-196. Springer Verlag, 2001.
G. Gentzen. Recherches sur la d´eduction logique. Press Universitaires de France, 1955. Traduction et commentaires par R. Feys et J. Ladri`ere.
J.-L. Krivine. Lambda calcul, types et mod`ele. Masson, Paris, 1990.
R. Matthes. Inductive Constructions for Classical Natural Deduction. To be submitted.
K. Nour. Mixed Logic and Storage Operators. Archive for Mathematical Logic, vol 39, pp. 261-280, 2000.
K. Nour and K. Saber. A semantical proof of strong normalization natural classical deduction with disjunction. Manuscript, 2004.
K. Nour and K. Saber. Church- Rosser property of full propositional classical natural deduction. Manuscrit, 2004.
M. Parigot. λμ-calculus: an algorithmic interpretation of classical natural deduction. Lecture Notes in Artificial Intelligence, 624, Springer Verlag, 1992.


M. Parigot. Proofs of strong normalization for second order classical natural deduction. Journal of Symbolic Logic, 62 (4), pp. 1461-1479, 1997.
