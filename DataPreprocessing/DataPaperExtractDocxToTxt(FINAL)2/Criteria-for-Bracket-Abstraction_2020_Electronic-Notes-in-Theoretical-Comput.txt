Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 349 (2020) 25–48
www.elsevier.com/locate/entcs
Criteria for Bracket Abstractions Design
Federico Flaviani1
Department of Computing and Information Technologies Universidad Simo´n Bol´ıvar
Caracas, Venezuela
Elias Tahhan Bitar2
Department of Pure and Applied Mathematics Universidad Simo´n Bol´ıvar
Caracas, Venezuela

Abstract
A bracket abstraction is a syntactic operator to abstract variables in combinatory logic. There are different algorithms for different combinator systems. In this paper we present a recursive algorithm scheme, which generates a family of brackets abstractions, in which all the bracket abstractions referenced here are found. In addition, theorems with certain hypotheses are enunciated about the scheme, which state that the resulting abstraction operators, has one property or another. Thus forming a criteria for designing bracket abstractions that comply with a given property.

Keywords: Bracket Abstraction; Recursive Scheme, Combinators, Injectivity.

1	Introduction
The combinatory logic can be understood as a rewriting system [1], on an application language with variables and constants. Application language is understood as a language AL(V ar, ΣZ) with a set of variables V ar and a signature ΣZ := Z ∪ {.} consisting of a binary operator . and a set of constants Z. The description is recursively
If p ∈ V ar or p ∈ Z then p ∈ AL(V ar, ΣZ),
If p, q ∈ AL(V ar, ΣZ) then p.q ∈ AL(V ar, ΣZ).
To simplify notation, it is assumed that the association is made to the left and
pq denotes p.q.

1 Email: fflaviani@usb.ve
2 Email: etahhan@usb.ve

https://doi.org/10.1016/j.entcs.2020.02.011
1571-0661/© 2020 The Author(s). Published by Elsevier B.V.
This is an open access article under the CC BY license (http://creativecommons.org/licenses/by/4.0/).

The language of lambda terms λ-term(V ar, ΣλZ ) is such that it hasa signature

ΣλZ := [
x∈V ar
{λx.}∪{(.)}∪Z and is recursively defined as AL(V ar, ΣZ), but adding

that if p ∈ λ-term(V ar, ΣλZ ) then λx.p ∈ λ-term(V ar, ΣλZ ). This definition implies
that AL(V ar, Z) ⊂ λ-term(V ar, ΣλZ ).
The concept of bound and free variable are those that are defined in [2]. To simplify notation, given t ∈ λ-term(V ar, ΣλZ ), we will write x ∈ t and x ∈ V ar(t) to say that x occurs as a free variable and occurs as a free or bound variable respectively, in t.
On λ-term(V ar, ΣλZ ), if x ∈ V ar and p ∈ λ-term(V ar, ΣλZ ), the simple substi- tution operator is defined as follows
x < p|x >:= p if x ∈ V ar,
y < p|x >:= y if y ∈ Z or, y ∈ V ar and x /= y,
(qr) < p|x >:= q < p|x > r < p|x >,
(λx.q) < p|x >:= λx.q,
(λy.q) < p|x >:= λy.(q < p|x >) if x /= y.
In this way since AL(V ar, ΣZ) ⊂ λ-term(V ar, ΣλZ ), then < p|x > is also defined in AL(V ar, Z).
In lambda calculus it is usual to consider that two equal terms, except for the name of their bound variables, are equivalent. This relationship is denoted ≡α and recursively defined as:
If u ∈ V ar ∪ Z: u ≡α uj if and only if u = uj,
If u = pq: u ≡α uj if and only if uj = pjqj, with p ≡α pj and q ≡α qj
If u = λx.v: u ≡α uj if and only if uj = λy.vj with
(∃A ⊆ V ar ∧ A finite) such that
(∀z ∈ V ar \ A)(v < z|x >≡α vj < z|y >) .
We denote as Λ the set λ-term(V ar, ΣλZ )/ ≡α, and given p, q ∈ Λ and x ∈ V ar, we define the α substitution q[p|x], as the class of Λ, of the terms qj < pj|x >, where qj and pj are in the class of q and p respectively, and qj has names of its bound variables, which avoid variable capture. If in q there are no λ abstractions, then [p|x] behaves isomorphic to < p|x >, so to unify notation, we will use [p|x] to also refer to the operator < p|x > in AL(V ar, ΣZ). The concept of reduction →β in Λ, is the same as in [3].
A combinator is a lambda term without free variables and without constants. Usually some combinators are abbreviated by constant symbols of Z, when this is the case, it is said that AL(V ar, ΣZ) is a combinatory logic language and is denoted rather as CL(V ar, ΣZ).
On CL(V ar, ΣZ) the rewriting relation →0 is defined such that, if C ∈ Z is a combinator, then ⟨Cp1p2 ... pn, t2⟩ ∈→0 if and only if, n is the least natural, such that it is possible to apply several β reductions to Cp1p2 ... pn, only in redex caused

by the λ abstractions of C, until all the sub-term C disappears, which results in the term t2.
For example, the combinator S := λx.λy.λz.(xz)(yz) fulfills that 3 is the least natural to make Sp1p2p3 →β (λy.λz.(p1z)(yz))p2p3 →β (λz.(p1z)(p2z))p3 →β (p1p3)(p2p3) where all the sub-term S disappeared. Using the above definition, it is true that Sp1p2p3 →0 (p1p3)(p2p3).
Other commonly used combinators are I := λx.x, K := λx.λy.x, B :=
λx.λy.λz.x(yz) and C := λx.λy.λz.xzy.
The relation → in CL(V ar, ΣZ) is the smallest one that contains →0 and pass to the context (terminology of [3] in French). To pass to the context means that, if t → tj, then λx.t → λx.tj, ut → utj and tu → tju.
The central definition of this work is the bracket abstraction of a single vari- able, which is a syntactic operator that given x ∈ V ar and combinatory term t ∈ CL(V ar, ΣZ), returns a new term in CL(V ar, ΣZ), denoted [x]t, which satisfies:
FreeV ar([x]t)= FreeV ar(t) \ {x}
([x]t)p →∗ t[p|x]. (The abbreviation BA will be used to refer to this property)
Remark 1.1 Some authors use [x]t =βη λx.t instead of BA for the previous defi- nition.
The original idea of the bracket abstraction was introduced in [4], which although in [4] there is no explicitly an algorithm to calculate [x]t, a calculation strategy can be implicitly inferred. Although it was Curry [5] who made this algorithm explicit, it has been called by the community as the Sch¨onfinkel algorithm (abbreviated with SH). This algorithm is defined recursively as follows:
[x]x := I,
[x]p = Kp if x /∈ p,
[x]px = p if x /∈ p (η rule),
[x]pq = C([x]p)q if x ∈ p and x /∈ q,
[x]pq = Bp([x]q) if x /∈ p and x ∈ q,
[x]pq = S([x]p)([x]q) if x ∈ p and x ∈ q.
(When there is ambiguity about which rule to use, the one that is listed first is used)
Over the years, other algorithms were defined in different combinator systems, each with certain properties, and in this work, to differentiate one algorithm from another, [x]A will be written where sub-index A indicates the algorithm used. For example, in [5], in order to simplify the foundations of combinatory logic, a simpler algorithm (which he called fab) was defined as follows:
[x]fabx := I,
[x]fabp = Ky if p ∈ V ar and p /= x,
[x]fabpq = S([x]p)([x]q).

By replacing I in the first rule with SKK, we have the Hilbert algorithm (H), named for being isomorphic (by Curry-Howard correspondence) to the algorithm that converts the natural deduction inference rule, into a derivation in the Hilbert system. Also a variant to fab was made in the same book of Curry [5], called abf , is defined by changing the condition of the second rule by x /∈ p. A variant to abf was made in the book of Hindley and Seldin (HS) [6] in which add the rule η to abf .
Functional languages are usually interpreted in a combinator machine, so al- gorithms for computing bracket abstractions are important for the implementa- tion of functional languages, because they induce a <>A: λ-term(V ar, ΣλZ′ ) → CL(V ar, ΣZ) translation, defined as follows:
< p >A= p if p ∈ V ar or p ∈ Zj
< pq >A=< p >A< q >A
< λx.p >A= [x]A < p >A
(Z is Zj plus the symbols representing combinators)
The properties studied in this work on bracket abstractions and different trans- lations to combinators, are the following:
WD: If p, q ∈ λ-term(V ar, ΣλZ′ ) then p ≡α q ⇒< p >A=< q >A
SC: If q, t ∈ λ-term(V ar, ΣλZ′ ) and x ∈ V ar then < p[t|x] >A=< p >A [< t >A |x]
SBA: ([x]Ap)t → p[t|x]
I: If p, q ∈ λ − term(V ar, ΣλZ′ ) then < p >A=< q >A⇒ p ≡α q.
The WD property is fulfilled by all bracket abstraction, and states that an Λ translation would be Well Defined as follows:
<>Λ:Λ → CL(V ar, ΣZ)
< p >Λ=< pj >
with pj any representative of p
The SC property states that the Substitution Commutes with respect to <>A. The SBA property is a Stronger property than BA. Property I states that the translation <>Λ, with domain in Λ, is Injective.
Contribution
As mentioned in the previous section, there are several algorithms for bracket ab- straction, but there is no unified theory to generalize all these algorithms, in fact the properties described in the previous section are demonstrated from scratch for each algorithm and combinator system. In this way, these types of demonstrations are repeated over and over throughout the bibliography.
In this work, a recursive algorithm scheme is defined that defines in general, an infinite family of bracket abstractions, where all the bracket abstraction of the bibliography referenced here are found. On this scheme a unified theory is developed

to demonstrate the properties described in the previous section, indicating for each of them, which are the hypotheses that must be assumed on the scheme, for the property to be true.
The defined scheme can be used as a basis when designing a new abstraction algorithm, since depending on the desired properties, the scheme and the hypotheses of the theorems that guarantee the compliance of the properties, would be a criterion to take in mind, during the design of the new algorithm.
On the other hand, here are criteria that the recursive scheme must have, in order for I to be fulfilled, a property that is apparently irrelevant for the compila- tion of functional languages, and therefore has not been studied by other authors. However, it is relevant together with the SBA property, since they almost estab- lish an isomorphism of rewriting systems between Λ and the image of <>Λ. With the bracket abstraction of Broda and Damas (which will be denoted [x]BD), it is shown in [7], that SBA is almost fulfilled (see Remark 4.17), but this paper shows that eliminating the η rule of this bracket abstraction (algorithm that will be de- noted BD−η), then SBA is fulfilled. With the I and WD properties, in Broda and Damas’s bracket abstraction without η rule, a lambda calculus normalization algorithm was designed, and implemented in the web application [8].
Property I and WD suggest an algorithm to decide whether two terms p, q ∈ λ-term(V ar) are α-equivalent. This algorithm consists in computing the image of both terms by the function <>, and if those are equal, then they are α-equivalent and otherwise they are not. This algorithm is the one used in [8], to avoid that two α-equivalent versions of the same term are stored in the terms database.
Additionally for those bracket abstraction that comply with I,a <>−1 algorithm is enunciated to calculate the inverse of < t >. This algorithm was used in the web application [9], which is a proof assistant for the calculative logic, where each theorem t was coded as an λ-term, so that, thanks to I, < t > uniquely indexes t, regardless of the name of the bound variables. In this way < t > is stored in the database, but to the user, << t >>−1 is presented. This type of techniques thanks to I, are relevant, since the use of combinators for interactive and automatic theorem proving is a subject of study recently.
Related Works
The algorithms H, fab, abf, SH are not particularly efficient in terms of the size of the term [x]At with respect to the size of t. For example, fab and H are exponential and abf is O(n3), so they are not useful for implementing functional languages. In [10, 11], the size of [x]At for different algorithms is analyzed.
The first improvement to Sch¨onfinkel’s algorithm was due to Turner [12], who defined optimization rules that were later used for the implementation of application languages [13]. The complexity in the worst case of the Turner algorithm is O(n2)
[11] and on average O(n3/2) [14]. There are several forms of the Turner algorithm, because its formulation contains ambiguities. In [15], different interpretations of the Turner algorithm is studied, and the one based on recursive equations with side conditions, is the algorithm taken for this job.

The advance in implementation techniques in functional languages meant an advance for the bracket abstraction theory. Bunder [16] discusses different exten- tions of the Turner algorithm. Then in [17] it is affirmed that using the combinator B∗ := λfxyz.f (x(yz)) instead of Bj := λkxyz.kx(yz), in one of its optimization rules, the Turner algorithm is improved. However other ways of implementing application languages became standard, because produced faster implementations, among these techniques are those of super combinators [18].
A radical change in the way of abstraction of variables was due to the director Strings [19,20], although this was a formal system other than combinatorial logic, it was a precursor to the iconic representation. A significant contribution in the design of algorithms for the abstraction of variables in combinatorial logic was made by Stevens [21], who began using iconic representation to represent combinators, where the combinator’s behavior could be read from his representation. Later Broda and Damas [7] defined a combinators base with iconic representation and an algorithm of abstraction of complexity O(n2) in the worst case. Finally, Antoni Diller [22], defined combinators with iconic representation and an algorithm of abstraction of complexity O(a2n) in the worst case, when a is the number of variables abstracted. The properties WD, BA, SBA, SC and I were studied in the master thesis [23], for the algorithms H, abf , HS, SH and BD separately. In the present work the same study is done but in the framework of a unified theory of all abstraction algorithms. An application of the WD, I and SBA properties, in a modified Broda and Damas bracket abstraction, is found in the grade thesis [24], which explains the details of an algorithm to evaluate lambda calculus, using these properties and the
details of a implementation located in [8].
Recently the use of combinators and bracket abstraction in interactive or auto- matic theorem proving has been studied. For example, Jacques Carette and Russell O’Connor in work [25], rewritten almost entirely in [26], has suggested making use of combinators to represent formulas, with the intention of generating a database of theorems scalable and without redundancy. His proposal is to use combinators, to represent the application structure of the mathematical statements and theo- ries, in order to identify and keep common structures in the different mathematical theories.
From an experimental point of view, in [27], a comparison is made of the per- formance of several of the bracket abstractions algorithms studied here, but in the context of abstraction of variables in first-order mathematical theories, to accelerate the build of formal proofs, in an interactive theorem proving.
General recursion scheme
In the bracket abstraction algorithms presented in the introduction, it can be seen that [x]p depends on some sub-terms of p. and the position of the sub-terms to use depends on how it is p. For this reason it is convenient to formalize the concepts of positions and replacement in a subterm position.
Definition 2.1 The positions Pos(p) of a term p are defined as the set of strings

on the positive integer alphabet, recursively defined as:
If p ∈ V ar or p ∈ Z then Pos(p)= {ϵ}, where ϵ denotes the empty string.
If p is of the form qr, then
Pos(p)= {ϵ}∪ {1σ|σ ∈ Pos(q)}∪ {2σ|σ ∈ Pos(r)}
The positions p and q are said to be parallel (p||q) iff they are incomparable with respect to the prefix order.
Definition 2.2 If σ ∈ Pos(p), then the sub-term of p in the position σ is defined, denoted by p|σ, recursively:
p|є = p
If p = qr, then p|1σ = q|σ
If p = qr, then p|2σ = r|σ
Definition 2.3 If σ ∈ Pos(p), then p[t]σ is defined as the replacement by t of the sub-term at the position σ of p. Recursively:
p[t]є = t,
If p = qr then p[t]1σ = q[t]σr
If p = qr then p[t]2σ = q(r[t]σ)
If σ1,..., σk is a list of positions, then p[t1,..., tk]σ1,...,σk is an abbreviation of ((p[t1]σ1 )[t2]σ2 ) ... [tk]σk .
Definition 2.4 |p|q it is an abbreviation of the term recursively defined as:
|p|(qt) := |pq|t, |p|q := pq y |p|ϵ := p.
The previous definition is for short that |p|w is associated to the left tak- ing as arguments all the applications of w associated to the right. For example
|p|(w1(w2(w3w4))) is an abbreviation of pw1w2w3w4.
To state a general recursive algorithm scheme, to define a bracket abstraction, a list of positions σj will be used, to indicate which are the sub-terms that will be used of p, when p has a certain form or belongs to a certain set Ai.
Let CL(V ar, ΣZ) be a combinatory logic, let m and k be such that 1 ≤ k ≤ m

and let {Ai}m
be a family of subsets of V ar × CL(V ar, ΣZ) such that:

∪iAi = V ar × CL(V ar, ΣZ)
For all x exists i with 1 ≤ i ≤ k such that (x, p) ∈ Ai when p is variable or constant
Let y, z ∈ V ar. If i is the smallest index such that (x, p) ∈ Ai and x ∈/ {y, z}
then i is the smallest index such that (x, p[z|y]) ∈ Ai
Let z ∈ V ar. If i is the smallest index such that (x, p) ∈ Ai and z ∈/ p then i is the smallest index such that (z, p[z|x]) ∈ Ai
For 1 ≤ i ≤ m, let σi be lists of positions of length ni. σi will be denoted to the

jth element of the ith list of positions σi. If i > k then no position σi is ϵ.

For 1 ≤ i ≤
n′
m, let be ti : Π i
CL(V ar, ΣZ)
→ CL(V ar, ΣZ
) where nj
= ni

when 1 ≤ i ≤ k and nj = 2ni when k +1 ≤ i ≤ m. The functions ti are such that:
are homomorphisms with respect to the substitution operator [z|y] (z ∈ V ar) i.e.
ti(p1,..., pn′ )[z|y]= ti(p1[z|y],..., pn′ [z|y]).
i	i

if (x, p) ∈ Ai, then x ∈/ ti(p|σi ,..., p|σi
) when 1 ≤ i ≤ k

1	ni

if (x, p) ∈ Ai, then x ∈/ ti(p|σi ,..., p|σi
, r1,..., rni ) when k +1 ≤ i ≤ m and

1	ni
x ∈/ rj ∈ CL(V ar, ΣZ).
Definition 2.5 To define a bracket abstraction, the general recursive algorithm scheme is defined, as follows:
[x]p = t1(p|σ1 ,..., p|σ1 ) if (x, p) ∈ A1
1	n1
. .

[x]p = tk(p|σk ,..., p|σk
) if (x, p) ∈ Ak

1	nk

[x]p = tk+1(p|σk+1 , .., p|σk+1 , [x](p|σk+1 ), .., [x](p|σk+1
)) if (x, p) ∈ Ak+1

1	nk+1	1
. .
nk+1

[x]p = tm(p|σm ,..., p|σm  , [x](p|σm ),..., [x](p|σm
)) if (x, p) ∈ Am

1	nm	1	nm
Remark 2.6 In case the pair (x, p) belongs to several Ai’s, then the clause that is listed first will have priority. Also the possibility that m = ∞, is considered (like in Definition 3.11).

Classic Bracket Abstractions and General Recursive Scheme
This section shows how the bracket abstractions of the bibliography adapts to the general recursive scheme.
Definition 3.1 [fab [5]] The fab algorithm can be defined by instantiating the general scheme with k = 2, t1(p) = I, t2(p) = Kp, t3(p, q, r, w) = Srw, with the lists of positions σ1 := ϵ, σ2 := ϵ and σ3 := 1, 2 and with the sets
A1 := {(x, p) ∈ A|x = p},
A2 := {(x, p) ∈ A|(p ∈ V ar ∧ p /= x) ∨ p ∈ Z} and
A3 := {(x, p) ∈ A|(∃q, r)(p = qr)}, where
A := V ar × CL(V ar, ΣZ′∪{I,S,K})
Definition 3.2 [Hilbert (H)] Hilbert’s algorithm (H) is defined as fab except that
t1(p)= SKK and A := V ar × CL(V ar, ΣZ′∪{S,K}).
Definition 3.3 [abf [3]] The abf algorithm is defined the same as fab except that
A2 := {(x, p) ∈ A|x ∈/ p}.
Definition 3.4 [Hindley, Lercher y Seldin (HS) [6]] The HS algorithm can be defined by instantiating the general scheme with k := 3, t1(p) = I, t2(p) = Kp,

t3(p, q)= p, t4(p, q, r, w)= Srw, with the same lists of fab plus σ4 := 1, 2 and with the sets A1, A2 as in abf ,
A3 := {(x, p) ∈ A|(∃q)(p = qx ∧ x ∈/ q)} and
A4 := {(x, p) ∈ A|(∃q, r)(p = qr)}, with A as in fab.
Definition 3.5 [ Scho¨nfinkel (SH) [4]] The SH algorithm is defined as HS except that t4(p, q, r, w) = Crq, t5(p, q, r, w) = Bpw, t6(p, q, r, w) = Srw, σ5 := 1, 2, σ6 := 1, 2 and the sets
A4 := {(x, p) ∈ A|(∃q, r)(p = qr ∧ x ∈ q ∧ x ∈/ r)},
A5 := {(x, p) ∈ A|(∃q, r)(p = qr ∧ x ∈/ q ∧ x ∈ r)}
A6 := {(x, p) ∈ A|(∃q, r)(p = qr ∧ x ∈ q ∧ x ∈ r)} where
A := V ar × CL(V ar, ΣZ′∪{I,S,K,B,C}).
Definition 3.6 [Sch¨onfinkel modified (SH—η)] The algorithm SH—η is defined the same as SH but eliminating the η rule. This corresponds to making k := 2, removing the t3, σ3, A3 from SH and subtracting 1 from the indices of the functions ti, sets Ai and lists σi with i > 3.
Definition 3.7 [Turner (T) [12]] The T algorithm is defined as SH except that k := 4, t4(p, q)= Cpq, t5(p, q, r, w)= Spw, t6(p, q, t, r, w, s)= Bjpqs, t7(p, q, t, r, w, s)= 
Cjpwt, t8(p, q, t, r, w, s) = Sjpws, σ4 := 11, 2, σ5 := 11, 2, σ6 := 11, 12, 2, σ7 := 11, 12, 2, σ8 := 11, 12, 2, and t9, t10, t11, σ9, σ10, σ11, A9, A10, A11 as t4, t5, t6, σ4,
σ5, σ6, A4, A5, A6 of SH respectively, and with the sets
A4 := {(x, p) ∈ A|(∃q, r)(p = qxr ∧ x ∈/ qr)}
A5 := {(x, p) ∈ A|(∃q, r)(p = qxr ∧ x ∈/ q ∧ x ∈ r)}
A6 := {(x, p) ∈ A|(∃q, s, r)(p = qsr ∧ x ∈/ qs ∧ x ∈ r)}
A7 := {(x, p) ∈ A|(∃q, s, r)(p = qsr ∧ x ∈/ qr ∧ x ∈ s)}
A8 := {(x, p) ∈ A|(∃q, s, r)(p = qsr ∧ x ∈/ q ∧ x ∈ s ∧ x ∈ r)} where
A := V ar × CL(V ar, ΣZ′∪{I,S,K,B,C,S′,B′,C′}).
Definition 3.8 [Broda and Damas (BD) [7]] The Broda and Damas indexes A are strings of letters b and c with the following formation rules: ϵ ∈ A (ϵ is the empty string) and if α1, α2 ∈ A , then cα1, bα1, (α1, α2) ∈ A . The combinators of Broda and Damas are constants of the form ΦK or Φα with α ∈ A . The set of these combinators is denoted K .
The BD algorithm is defined the same as SH but taking A := V ar ×
CL(V ar, ΣZ′∪K ) with the functions t1(p)= Φє, t2(p)= ΦKp, t3(p, q)= p,
t (p, q, r ,r )= ⎨ |Φcα|(qw) if r1 = |Φα|w

4	1  2
⎩⎧ Φє	otherwise

t (p, q, r ,r )= ⎨ |Φbα|(pw) if r2 = |Φα|w

5	1  2
⎩⎧ Φє	otherwise

t (p, q, r ,r )= ⎨ ||Φ(α1,α2)|w1|w2	if	r1 = |Φα1 |w1	and	r2 = |Φα2 |w2

6	1  2
⎩ Φє	otherwise

This is the expedited definition of Bunder [28].
Remark 3.9 In the conditions of the pieces of the previous functions it is contem- plated that w, w1, w2, α, α1 and α2 can be ϵ
Definition 3.10 [Broda and Damas modified (BD—η)] The BD—η algorithm is defined the same as BD but eliminating the η rule. This corresponds to making k := 2, removing the t3, σ3, A3 from BD and subtracting 1 the indices of the functions ti, sets Ai and lists σi with i > 3.
Definition 3.11 [Diller (D) [22]] The combinators of Diller, called yn-strings, are strings of letters y and n. Algorithm D is defined by instantiating the general scheme with k := 2, σ1, σ2 := ϵ, ϵ, t1(p) = yI, t2(p) = np, and A1, A2 as fab.

Defining J
:= 3j—3 and q q ...q 
as (i− J ) written in base3 when J
≤ i < J	,

j	2	1 2	j
j
j—1 times j—2 times
j	j+1

it is instantiated m := ∞ ni := j, σi := ¸1 .x.`. 1˛ ,
1¸ .x.`. 1˛ 2,..., 12, 2 for all i > 2

and t (p ,...,p ,r ,...,r ) = φ  ...φ Q1 ... Qj
where φ  = y, Ql = I, Fl :=

i  1	j	1
j	q1
qj  q1	qj
0	0	0

(pl = x), φ1 = y, Ql = rl, Fl := (x ∈ pl ∧ pl /= x), φ2 = n, Ql = pl, Fl := (x ∈/ pl).
1	1	2	2
And the sets Ai := {(x, p) ∈ A|
(∃p ,...,p )(p = p ...p ∧p ∈ V ar∪Z∧F 1 ∧..∧Fj )} with A := V ar×CL(V ar×

1	j	1	j	1
q1	qj

ΣZ′∪{I}∪yn-strings).
Each of the functions ti are homomorphisms with respect to [z|x]. For ex- ample in SH, is fulfilled t5(p, q, r, w)[z|y] = (Bpw)[z|y] = Bp[z|y]w[z|y] = t5(p[z|y], q[z|y], r[z|y], w[z|y]). For the rest of the ti, similar proves can be made.
Properties of Bracket Abstractions
<>Λ is Well Deﬁned (WD)
This section will show that with the bracket abstraction of the general recursion scheme [x], the WD property is satisfied
Lemma 4.1 If x, y ∈ V ar, p ∈ CL(V ar, ΣZ) then x ∈/ [x]p, and if x /= y ∈/ p then
y ∈/ [x]p
Proof. Note that if y ∈/ p then y ∈/ p|σ for any position σ. (*) The proof is by structural induction on p.
If p ∈ V ar ∪ Z:
By definition the lowest index such that (x, p) ∈ Ai, fulfills i ≤ k, then [x]p =
def
ti(p|σi ,..., p|σi ) /e x. Furthermore, if x /= y ∈/ p, then assuming y ∈ [x]p
1	ni
(∗)
leads to a contradiction because taken z /= y, then ti(p|σi [z|y],..., p|σi [z|y]) =
1	ni
z/=y∈[x]p

ti(p|σi ,..., p|σi )= [x]p	/=	([x]p)[z|y]= ti(p|σi ,..., p|σi
)[z|y] but impossible

1	ni	1	ni
because ti is an homomorphism with respect [z|y]. Therefore y ∈/ [x]p.

If p /∈ V ar ∪ Z then it separates in cases:

Case 1: The smallest index i such that (x, p) ∈ Ai, fulfills 1 ≤ i ≤ k. The proof is the same as the base case
Case 2: The smallest index i such that (x, p) ∈ Ai, fulfills k +1 ≤ i ≤ m

[x]p	=	ti(p|σi ,..., p|σi  , [x]p|σi ,..., [x]p|σi
)  since  by  I.H. (Inductive

1	ni	1	ni

Hypothesis) x ∈/
[x]p|σi , then x  ∈/  ti(p|σi ,..., p|σi , [x]p|σi ,..., [x]p|σi )

j	1	ni	1	ni

by	definition	of	ti.	Furthermore,	if	x	/=	y	∈/
p,	then	as-

suming	y	∈	[x]p	leads	to	a	contradiction	because	with
(∗),I.H.
z	/=	y,	ti(p|σi [z|y]..p|σi [z|y], ([x]p|σi )[z|y]..([x]p|σi )[z|y])	=

1	ni
1	ni
z/=y∈[x]p

ti(p|σi ,..., p|σi  , [x]p|σi ,..., [x]p|σi
)	=	[x]p
/=	([x]p)[z|y]	=

1	ni	1	ni

ti(p|σi ,..., p|σi  , [x]p|σi ,... [x]p|σi
)[z|y] but impossible because ti  is an

1	ni	1	ni
homomorphism with respect [z|y]. Therefore y ∈/ [x]p.
2
Lemma 4.2 If x, z ∈ V ar, p ∈ CL(V ar, ΣZ) and z ∈/ p then [z](p[z|x]) = [x]p

Proof. Since z ∈/ p then z ∈/ p|σ for any position σ. (*) It is separated by cases:
Case 1: z = x
[z](p[z|x]) x==z [x](p[x|x]) = [x]p
Case 2: z /= x. The proof is by structural induction on p

If p ∈ V ar∪Z then, by definition the smallest index such that (x, p) ∈ Ai, fulfills 1 ≤ i ≤ k, then

[x]p	Lemm=a 4.1
ti(p|σi [z|x],..., p|σi
def
([x]p)[z|x]	=
[z|x])
ti(p|
i ,..., p|
1
)[z|x]	ti is homo
ni

1	ni
On the other hand, i is the smallest index such that (z, p[z|x]) ∈ Ai (by definition of Ai), therefore the computation of [z](p[z|x]) takes the rule ti. For this reason

[z](p[z|x]) = ti(p[z|x]|σi ,..., p[z|x]|σi
)= ti(p|σi [z|x],..., p|σi
[z|x])

1
∴ [x]p = [z](p[z|x])
ni	1	ni

If p ∈/ V ar ∪ Z then it separates in cases
Case 2.2: The smallest index i such that (x, p) ∈ Ai, fulfills 1 ≤ i ≤ k. The proof is like the base case
Case 2.1: The smallest index i such that (x, p) ∈ Ai, fulfills k +1 ≤ i ≤ m

[x]p Lemm=a 4.1 ([x]p)[z|
def
|  ,..., p|
, [x]p|
,..., [x]p|
)[z|x] ti is homo

x] = ti(p i
1
i	i	i	=
ni	1	ni

ti(p| i [z|x]..p| i [z|x], ([x]p| i )[z|x]..([x]p| i
)[z|x])	Lem=ma4.1

σ1	σni	σ1	σni

ti(p|σi [z|x],..., p|σi  [z|x], [x]p|σi , .., [x]p|σi  )
1	ni	1	ni
On the other hand, i is the smallest index such that (z, p[z|x]) ∈ Ai (by defi- nition of Ai), then the computation of [z](p[z|x]) takes the rule ti. Therefore
[z](p[z|x])	=	ti(p[z|x]|σi ,..., p[z|x]|σi  , [z](p[z|x]|σi ),..., [z](p[z|x]|σi  ))

1	ni
1	ni
(∗) and I.H

=	ti(p|σi [z|x].., p|σi  [z|x], [z](p|σi [z|x]).., [z](p|σi
[z|x]))	=

1	ni	1	ni
ti(p|σi [z|x] ..., p|σi  [z|x], [x]p|σi .., [x]p|σi  )
1	ni	1	ni
∴ [x]p = [z](p[z|x])
2
Lemma 4.3 If x, y, z ∈ V ar, p ∈ CL(V ar, ΣZ) and y ∈/ {x, z} then [y](p[z|x]) = ([y]p)[z|x]
Proof. By structural induction on p:
If p ∈ V ar ∪ Z:
By definition the smallest index i such that (y, p) ∈ Ai, fulfills 1 ≤ i ≤ k,

then ([y]p)[z|
def
|  ,..., p|
)[z|x] ti is homo t (p|
[z|x],..., p|
[z|x]) =

x] = ti(p i	i
1	ni
=	i	i	i
1	ni

ti(p[z|x]|σi ,..., p[z|x]|σi  ).
1	ni
On the other hand since i is the smallest index such that (y, p[z|x]) ∈ Ai then
[y](p[z|x]) = ti(p[z|x]|σi ,..., p[z|x]|σi  )
1	ni
∴ ([y]p)[z|x]= [y](p[z|x])
If p ∈/ V ar ∪ Z then it is separated in cases:
Case 1: The smallest index i such that (y, p) ∈ Ai, fulfills 1 ≤ i ≤ k. The proof is the same as the base case
Case 2: The smallest index i such that (y, p) ∈ Ai, fulfills k +1 ≤ i ≤ m
def
([y]p)[z|x] = ti(p|σi , .., p|σi  , [y]p|σi , .., [y]p|σi  )[z|x]

ti is homo
1	ni	1	ni

=	ti(p|σi [z|x].., p|σi  [z|x], ([y]p|σi )[z|x].., ([y]p|σi
)[z|x])

1	ni	1	ni

I=.H.
ti(p| i [z|x].., p| i [z|x], [y](p| i [z|x]).., [y](p| i
[z|x]))

σ1	σni	σ1	σni
=	ti(p[z|x]|σi .., p[z|x]|σi  , [y](p[z|x]|σi ).., [y](p[z|x]|σi  ))
1	ni	1	ni
On the other hand since i is the smallest index such that (y, p[z|x]) ∈ Ai then
[y](p[z|x]) = ti(p[z|x]|σi .., p[z|x]|σi , [y](p[z|x]|σi ).., [y](p[z|x]|σi ))
1	ni	1	ni
∴ ([y]p)[z|x]= [y](p[z|x])
2
Remark 4.4 The previous lemma is not generally true if z is not a variable, for example for Hilbert’s bracket abstraction, we have:
[y]H (x[Kx|x]) = [y]H (Kx) = S([y]HK)([y]Hx) = S(KK)(Kx) On the other hand
([y]Hx)[Kx|x]= (Kx)[Kx|x]= K(Kx)

Thus
[y]H (x[Kx|x]) /= ([y]Hx)[Kx|x]
However, it is later determined that by adding conditions to the general recur- sion scheme, the substitution commutes with the bracket abstraction, regardless of whether the term to be substituted is not a variable.
With the three previous lemmas it is possible to prove:
Lemma 4.5 If r ∈ λ-term(V ar, ΣλZ′ ) and x, z ∈ V ar such that z ∈/ V ar(r) then
< r < z|x >>=< r > [z|x]
Proof. By structural induction on r:
If r ∈ V ar and r = x:
< r < z|x >>=< z >= z = x[z|x]= r[z|x] =< r > [z|x].
If r ∈ Zj or, r ∈ V ar and r /= x:
< r < z|x >>=< r >= r = r[z|x] =< r > [z|x].
If r = pq with p, q ∈ λ-term(V ar, ΣλZ′ ):
< r < z|x >>=< pq < z|x >>=< p < z|x > q < z|x >>=< p < z|x >>< q <
z∈/V ar(p)Λz∈/V ar(q), I.H.
z|x >>	=
< p > [z|x] < q > [z|x]= (< p >< q >)[z|x] =< pq > [z|x] =< r > [z|x] .
If r = λy.p with y ∈ V ar and p ∈ λ-term(V ar, ΣλZ′ ): It separates in two cases.
Case 1 y = x:
< r < z|x >>=< (λy.p) < z|x >>=< λy.p >= [y] < p >Lemm=a 4.1 ([y] < p > 
)[z|y]= 
([y] < p >)[z|x] =< λy.p > [z|x] =< r > [z|x] .
Case 2 y /= x:
< r < z|x >>=< (λy.p) < z|x >>= < λy.(p < z|x >) >= [y] < p <
z∈/V ar(p), I.H.

z|x >>
=
(z∈/V ar(r)Λx/=y⇒z/=yΛx/=y)ΛLemma 4.3

[y](< p > [z|x])
[z|x] =< r > [z|x] .
=	([y] < p >)[z|x] =< λy.p > 

2

Theorem 4.6 (WD) If p, q ∈ λ-term(V ar, ΣλZ′ ) then
p ≡α q ⇒< p >=< q >
Proof. By structural induction on p. If p ∈ V ar ∪ Zj:

p ≡α q
def
⇐⇒ p = q
def
⇒ < p >= p = q =< q >.

If p = rt with r, t ∈ λ-term(V ar, ΣλZ′ ):

p ≡α
def
q ⇐⇒
q = rjtj with

rj, tj ∈ λ-term(V ar, Σλ ′ ), r ≡α rj and t ≡α tj. By inductive hypothesis
< r >=< rj > and < t >=< tj >
⇒
< r >< t >=< rj >< tj >
⇒
< p >=< rt >=< r >< t >=< rj >< tj >=< rjtj >=< q >.
If p = λx.r with x ∈ V ar and r ∈ λ-term(V ar, ΣλZ′ ):

p ≡α
def
q ⇐⇒
q = λy.rj with rj ∈ λ-term(V ar, Σ

λZ′
), y ∈ V ar and there is finite

A ⊆ V ar such that
r < z|x >≡α rj < z|y > for all z ∈ V ar \ A.
By Inductive Hypothesis < r < z|x >>=< rj < z|y >> for all z ∈ V ar \ A and defining
Aj := A ∪ {x ∈ V ar|x ∈ V ar(< r >< rj > rrj)} then
< r > [z|x] Lemm=a 4.5< r < z|x >>=
< rj < z|y >> Lemm=a 4.5< rj > [z|y] for all z ∈ V ar \ Aj
[z] is a function
⇒
[z](< r > [z|x]) = [z](< rj > [z|y]) for all z ∈ V ar \ Aj
z∈/<r>Λz∈/<r′>Λ Lemma 4.2
⇒
[x] < r >= [y] < rj >
⇐⇒
< p >=< λx.r >=< λy.rj >=< q >
2
Lemma 4.7 If the variable x does not occur free in t ∈ λ-term(V ar, ΣλZ′ ), then
x ∈/< t > 
Proof. By structural induction on t and Lemma 4.1.	2
SC Property
The SC property is not true in general, for example translating with the Hilbert bracket abstraction we have to
< (λy.x)[λy.x|x] >H =< λy.(x[λy.x|x]) >H =< λy.λy.x >H =
Remark 4.4
[y]H ([y]Hx)= [y]H (x[[y]Hx|x]) /=	([y]Hx)[[y]Hx|x] =< λy.x >H [< λy.x >H |x]
However, we can add conditions to the general recursion scheme so that SC is true. These conditions are:
The functions ti are homomorphisms with respect to the operator [t|y] where
t ∈ CL(V ar, ΣZ)
Let y ∈ V ar and t ∈ CL(V ar, ΣZ). If i is the smallest index such that (x, p) ∈ Ai, x /= y and x ∈/ t then i is the smallest index such that (x, p[t|y]) ∈ Ai.

Notation When an operator [x] satisfies the conditions of the recursion scheme of the previous section, together with these conditions, [x] is said to fit to the strong recursion scheme
Under these conditions Lemma 4.3 can be generalized
Lemma 4.8 If [x] ﬁts the strong recursion scheme then. If p ∈ CL(V ar, ΣZ), y ∈/ t
and y /= x then [y](p[t|x]) = ([y]p)[t|x]
Proof. The proof is identical to that of Lemma 4.3 replacing z with t.	2

With this it is easy to prove SC.
Theorem 4.9 (SC) If q, t ∈ Λ and <>Λ was deﬁned using a bracket abstraction that ﬁts with the strong recursion scheme, then < q[t|x] >Λ=< q >Λ [< t >Λ |x] .

Proof. By structural induction on q. If q ∈ V ar .
Case 1 q = x . 
< q[t|x] >Λ=< x[t|x] >Λ=< t >Λ= x[< t >Λ |x] =< x >Λ [< t >Λ |x] =< q >Λ
[< t >Λ |x] .
Case 2 q /= x . 
< q[t|x] >Λ=< q >Λ= q = q[< t >Λ |x] =< q >Λ [< t >Λ |x] .
If q = pr with p, r ∈ Λ .
< q[t|x] >Λ=< (pr)[t|x] >Λ=< p[t|x]r[t|x] >Λ=
< p[t|x] >Λ< r[t|x] >ΛI=.H.
< p >Λ [< t >Λ |x] < r >Λ [< t >Λ |x]= (< p >Λ< r >Λ)[< t >Λ |x]= 
< pr >Λ [< t >Λ |x] =< q >Λ [< t >Λ |x]
If q = λy.p with y ∈ V ar and p ∈ Λ .
< q[t|x] >Λ=< (λy.p)[t|x] >Λ=< (λyj.pj) < tj|x >> where yj ∈ V ar, with yj /= x

and pj, tj ∈ λ-term(V ar, Σλ
FreeV ar(tj) /= ∅.
⇒
′ ) such that λyj.pj ∈ q, tj ∈ t and BoundV ar(λyj.pj)∩

< q[t|x] >
=< (λyj.pj) < tj|
y′/=x
j	j	j|x >) >= [yj] < pj <

Λ
tj|x >>=
x >> = < λy .(p < t

[yj] < p[t|x] >ΛI=.H. [yj](< p >Λ [< t >Λ |x]) Lemma 4=.8 and 4.7 ([yj] < p >Λ)[< t >Λ
|x] T heor=em 4.6
([yj] < pj >)[< t >Λ |x] =< λyj.pj > [< t >Λ |x] T heor=em 4.6< λy.p >Λ [< t >Λ
|x] =< q >Λ [< t >Λ |x]
2

Reduction Property BA
All bracket abstraction must fulfills the property BA. However, in general, there is no deterministic algorithm that specify the reduction strategy to reduct ([x]p)t to p[t|x]. For example, in the case of [x]A with A ∈ {HS, SH}, we have to ([x]A(Ix))t = It →0 It = (Ix)[t|x], but for another side, ([x]Ax)t is also equal to It and It → t = x[t|x]. This prove that the term ([x]Ap)t, by itself, in general is not enough to know the reduction strategy that leads to p[t|x], although it is known that it exists said strategy.
This section is dedicated to explaining what additional conditions, the general recursion scheme needs, so that BA is true and the term ([x]p)t, by itself, is enough to determine the reduction strategy that leads it to p[t|x].
Theorem 4.10 (BA) If a bracket abstraction ﬁt the general recursion scheme, and additionally satisﬁes the following conditions:
If (x, p) ∈ Ai with 1 ≤ i ≤ k, then there is a succession of reductions, indepen-

dent of who (x, p) is in Ai, that converts ti(p|σi ,..., p|σi
)r to p[r|x],

1	ni
If (x, p) ∈ Ai with k < i ≤ m, then there is a succession of reductions, indepen-
dent of who (x, p) is in Ai, that converts ti(p|σi ,..., p|σi  , [x]p|σi ,..., [x]p|σi  )r
1	ni	1	ni
to p[([x]p|σi )r,..., ([x]p|σi )r]σi ,...,σi , where Par := {σi ,..., σi } is a subset

j1	jl
j1	jl
j1	jl

of parallel positions of {σi }ni
, such that “all occurrences of x in p are found

k k=1

in the subterms p|σi
j1
,..., p|σi ” (∗∗)
jl

then ([x]p)r →∗ p[r|x], and if additionally satisﬁes the following:
If [x]p = [xj]pj and i is the smallest index such that (x, p) ∈ Ai then i is the smallest index such that (xj, pj) ∈ Ai,
then, the result of the succession of reductions over ([x]p)r, deﬁnes a function κ : Dom → CL(V ar, ΣZ) where Dom := {qr|(∃x ∈ V ar)(q ∈ Img([x])) ∧ r ∈ CL(V ar, ΣZ)}, which fulﬁlls κ(([x]p)r)= p[r|x], and is computed with the following recursive rules:

κ(([x]p)r)= q with ([x]p)r
ith succ of reductions
→∗	q if (x, p) ∈ Ai with 1 ≤ i ≤ k and,

κ(([x]p)r)= p[κ(([x]p|σi
)r), .., κ(([x]p|σi )r)]σi ,...,σi
if (x, p) ∈ Ai only with k < 

i ≤ m.
j1	jl
j1	jl

Proof. Apply the same sequence of reductions to equal terms, results in equal terms (∗∗ ∗).
With the set of pairs κ := {t|(∃x, p, r)((x, p) ∈ A ∧ r ∈ CL(V ar, ΣZ) ∧
⟨([x]p)r, p[r|x]⟩ = t)}, it proves by structural induction that ([x]p)r →∗ p[r|x] and κ is a function if (iii) (The latter will be done by proving that p[r|x] = pj[rj|xj] if ([x]p)r = ([xj]pj)rj).
If p ∈ V ar ∪ Z or (x, p) ∈ Ai with 1 ≤ i ≤ k
In both cases exists i ≤ k such that ([x]p)= ti(p|σi ,..., p|σi  ).
1	ni

According to (i) ([x]p)r = ti(p|σ ,..., p|σ  )r  →∗  p[r|x].	Secondly, if

the third condition is fulfilled, ([x]p)r  = ([xj]pj)rj (iii)
ti(p|
i ,..., p|
1
i )r =
ni

ti(pj|σi ,..., pj|σi
)rj, applying the ith sequence of reductions on both sides

1	ni
item (i) and (∗∗∗)
∗	j  j  j  ∗	j	j	j

⇒	ti(p|σi ,..., p|σi  )r → p[r|x]= p [r |x ] → ti(p |σi ,...,p |σi  )r
1	ni	1	ni
If p is an application and the smallest index i such that (x, p) ∈ Ai, fulfills k < i ≤ m
In this case
[x]p = ti(p|σi ,..., p|σi , [x]p|σi ,..., [x]p|σi )
1	ni	1	ni
According to (ii)
([x]p)r →∗ p[([x]p|σi )r,..., ([x]p|σi )r]σi ,...,σi
j1	jl	j1	jl

I.H. and σj1 ,...,σjl are parallel positions
→∗	p[p|σi
[r|x],..., p|σi [r|x]]σi ,...,σi


p|σi
j1

,...,p|σi
jl

contains all
j1	jl
j1	jl

ocurrences of x in p (∗∗)
=	p[r x]. Secondly, if the third condition is fulfilled,

([x]p)r = ([xj]pj)rj (iii) t (p|  , .., p|	, [xj]p|  , .., [xj]p|
)r = ([x]p)r =

⇒ i	i	i	i	i
1	ni	1	ni
([xj]pj)rj	=	ti(pj|σi , .., pj|σi  , [xj]pj|σi , .., [xj]pj|σi  )rj,	applying	the	ith
1	ni	1	ni

item (ii) and (∗∗∗)
sequence	of	reductions	on	both	sides	⇒
([x]p)r	→∗

p[([x]p|σi )r,..., ([x]p|σi )r]σi ,...,σi
=	pj[([xj]pj|σi )rj,..., ([xj]pj|σi )rj]σi ,...,σi

j1	jl
j1	jl
j1	jl
j1	jl

∗→ ([xj]pj)rj, then ([x]p|σi
jk
)r = ([xj]pj|σi
jk
)rj ∀σi
k
∈ Par, and by I.H. p|σi
jk
[r|x]= 

pj|
[rj|xj] ∀σi
∈ Par, therefore p[r|
(∗∗)
|	[r|x],..., p|
[r|x]]	=

σi	jk
x] = p[p σi
σi	σi ,...,σi

jk
pj[pj|	[rj|xj],..., pj|
[rj|xj]]
(∗∗) j
j1
j|xj]
jl	j1	jl

σi	σi
σi ,...,σi = p [r

j1	jl	j1	jl
The recursive rules is due to construction of p[r|x] in the proof.	2
With the same example of the first paragraph of this subsection, it can be seen that [x]A with A ∈ {HS, SH, BD}, does not satisfy the third condition of the previous theorem. However, [x]A with A ∈ {f ab, H, abf, SH—η, BD—η} satisfies all three, but to prove this in BD—η, it is necessary to define K based on another combinatory logic.
Definition 4.11 A number is defined for each τ ∈ K which is called order of τ [7]. The order of Φα is defined as #α, which is the number of b, c and K that occur in α.
Definition 4.12 The following super combinators are defined: Bn := λx0,..., xn+1.x1(x0x2 ... xn+1), Cn := λx0,..., xn+1.(x0x2 ... xn+1)x1, Sn,m := λx0, .., xn+m+2.(x0x2 ... xn+1xn+m+2)(x1xn+2 ... xn+m+2). K can be defined in CL(V ar, ΣZ′∪{I,K}∪{Bn,Cm,Si,j} i,j≥0 ) as follows: Φє := I, ΦK := K and for
n,m>0

α1, α2 ∈ A you have to Φbα
:= B#bα1 Φα , Φcα  := C#cα1 Φα  and Φ(α ,α ) :=

1
S#α1,#α2 Φα Φα .
1	1	1	1  2

1	2
For the following theorem, the rewrite relation used for BD—η will be that of

CL(V ar, ΣZ′∪{I,K}∪{Bn,Cm,Si,j} i,j≥0 ).
n,m>0
Theorem 4.13 [x]A with A ∈ {fab, H, abf, SH—η, BD—η} satisﬁes the three con- ditions of the Theorem 4.10, furthermore [x]BD−η p is of the form |Φα|w (w could be ϵ), where w is formed by #α arguments. The fuction κ of Theorem 4.10 for BD—η is computed as follows:
κ(Φєq) := q,
κ(ΦKpq) := p,
κ(Φcαpp1 ... p#α+1) := κ(Φαp1 ... p#α+1)p,
κ(Φbαpp1 ... p#α+1) := pκ(Φαp1 ... p#α+1),
κ(Φ(α1,α2)p1 ... p#α1 q1 ... q#α2 t) := κ(Φα1 p1 ... p#α1 t)κ(Φα2 q1 ... q#α2 t)
for fab, abf is computed as follows:
κ(Iq) := q,
κ(Kpq) := p,
κ(Sp1p2r) := κ(p1r)κ(p2r)
for H is computed like fab replacing κ(Iq) := q by κ(SKKq) := q and for SH—η is computed as follows:
κ(Iq) := q,
κ(Kpq) := p,
κ(Cp1p2p3) := κ(p1p3)p2,
κ(Bp1p2p3) := p1κ(p2p3),
κ(Sp1p2r) := κ(p1r)κ(p2r)
Proof. Is easy to prove by structural induction that [x]BD−η p = |Φα|w = Φαp1..p#α. Now it is proved that the third condition is true.
The functions ti of these bracket abstractions are of the form |Ci|w where Ci is a combinator such that Ci /= Cj if i /= j. therefore, if (x, q) ∈ Ai and [x]q = [xj]r, then [xj]r must be an image of ti, since otherwise [x]q = |Ci|wj /= |Cj|w = [xj]r. This implies that (xj, r) ∈ Ai.
Now it is proved that the first condition is true:
Case 1: ti(p)= I = Φє or ti(p)= SKK
In this case (x, p) ∈ A1 and p = x, therefore ti(p)q = SKKq → Kq(Kq) → q = x[q|x]= p[q|x] if ti(p)= SKK or ti(p)q = Iq → q = x[q|x]= p[q|x] otherwise. Thus it is defined κ(SKKq) = q and κ(Φєq) = κ(Iq) = q. Note that since [x]BD−η q = |Φα|w, then ti(p|1, p|2, [x]BD−η p|1, [x]BD−η p|2) /= Φє.
Case 2: ti(p)= Kp (K = ΦK)

In this case (x, p) ∈ A2 and x ∈/ p, therefore ti(p)q = Kpq → p
it is defined κ(ΦKpq)= κ(Kpq)= p
Now it is proved that the second condition is true:
x∈/p
= p[q|x]. Thus

Case 1.1: ti(p|1, p|2, [x]p|1, [x]p|2)= C([x]p|1)p|2 or Case 1.2: ti(p|1, p|2, [x]p|1, [x]p|2)= |Φcα|(p|2w)
In both cases (x, p) ∈ A3 and x ∈/ p|2, therefore ti(p|1, p|2, [x]p|1, [x]p|2)r =
C([x]p|1)p|2r → ([x]p|1)rp|2 = p[([x]p|1)r]1 for case 1.1. For the other case,
ti(p|1, p|2, [x]p|1, [x]p|2)r = (|Φcα|(p|2w))r = (|Φcαp|2|w)r = (|C#cαΦαp|2|w)r =
C#cαΦαp|2p1 ... p#αr → (Φαp1 ... p#αr)p|2 = ([x]p|1)rp|2 = p[([x]p|1)r]1.
Note that 1 is a position belonging to the set of positions {1, 2}, which are the ones used for i = 3. All occurrences of x in p are found in p|1. In both cases, this reduction is independent of who (x, p) is in A3, and the definitions κ(Cp1p2p3) := κ(p1p3)p2 and κ(Φcαp0p1..p#αr) := κ(Φαp1..p#αr)p0 satisfies κ(([x]p)r)= p[κ(([x]p|1)r)]1 as in Theorem 4.10.
Case 2.1: ti(p|1, p|2, [x]p|1, [x]p|2)= Bp|1[x]p|2 or Case 2.2: ti(p|1, p|2, [x]p|1, [x]p|2)= |Φbα|(p|1w)
In both cases (x, p) ∈ A4 and x ∈/ p|1, therefore ti(p|1, p|2, [x]p|1, [x]p|2)r =
Bp|1([x]p|2)r → p|1(([x]p|2)r)=p[([x]p|2)r]2 for case 2.1. For the other case,
ti(p|1, p|2, [x]p|1, [x]p|2)r = (|Φbα|(p|1w))r = (|Φbαp|1|w)r = (|B#bαΦαp|1|w)r =
B#bαΦαp|1p1 ... p#αr → p|1(Φαp1 ... p#αr)= p|1(([x]p|2)r)= p[([x]p|2)r]2.
Note that 2 is a position belonging to the set of positions {1, 2}, which are the ones used for i = 4. All occurrences of x in p are found in p|2. In both cases, this reduction is independent of who (x, p) is in A4, and the definitions κ(Bp1p2p3) := p1κ(p2p3) and κ(Φbαp0p1..p#αr) := p0κ(Φαp1..p#αr) satisfies κ(([x]p)r)= p[κ(([x]p|2)r)]2 as in Theorem 4.10.
Case 3.1: ti(p|1, p|2, [x]p|1, [x]p|2)= S([x]p|1)[x]p|2 or Case 3.2: ti(p|1, p|2, [x]p|1, [x]p|2)= ||Φ(α1,α2)|w1|w2
ti(p|1, p|2, [x]p|1, [x]p|2)r  =  S([x]p|1)([x]p|2)r  →  (([x]p|1)r)(([x]p|2)r)  =
p[([x]p|1)r, ([x]p|2)r]1,2 for case 3.1. For the other case,
ti(p|1, p|2, [x]p|1, [x]p|2)r = (||Φ(α ,α )|w1|w2)r = (||Sα1,α2 Φα Φα |w1|w2)r →
(|Φα1 |w1)r((|Φα2 |w2)r) = (([x]p|1)r)(([x]p|2)r)= p[([x]p|1)r, ([x]p|2)r]1,2.
Note that 1 and 2 are positions belonging to {1, 2}, which are the ones used for i = 5 (in SH—η and BD—η) or i = 3 (for H, fab, abf ). All occur- rences of x in p are found in p|1 and p|2. In both cases, this reduction is independent of who (x, p) is, and the definitions κ(Sp1p2r) := κ(p1r)κ(p2r) and κ(Φ(α1,α2)p1..p#α1 q1..q#α2 r) := κ(Φα1 p1 ... p#α1 r)κ(Φα2 q1 ... q#α2 r) satis- fies κ(([x]p)r) = p[κ(([x]p|1)r), κ(([x]p|2)r)]1,2 as in Theorem 4.10.
2
Theorem 4.14 If [x] ﬁts the general recursion scheme and satisﬁes BA then
FreeV ar([x]p)= FreeV ar(p) \ {x}

Proof. BA implies ([x]p)x →∗ p[x|x] = p. Since in a contractum of a redex, subterms that are not in the redex cannot appear, but some of them may be absent, then FreeV ar(p) ⊆ FreeV ar(([x]p)x) = FreeV ar([x]p) ∪ {x}, therefore

FreeV ar(p) \ {x} ⊆ FreeV ar([x]p). On the other hand, since per Lemma 4.1
FreeV ar([x]p) ⊆ FreeV ar(p), but x ∈/ [x]p, then FreeV ar([x]p) ⊆ FreeV ar(p) \
{x}.	2
Theorem 4.15 If t ∈ λ-term(V ar, ΣλZ′ ) and < t > is computed with a bracket ab- straction that ﬁts the general recursion scheme and satisﬁes BA, then FreeV ar(t)= FreeV ar(< t >)
Proof. By structural induction on t and Theorem 4.14.	2
Strong Reduction Property SBA
For Broda and Damas Combinators in [7], a rewrite relation different from that of Theorem 4.13 is used. This definition is as follows:
Definition 4.16 The	following	redex	and	contractum	are	defined	for
CL(V ar, ΣZ′∪K )
Φαp1 ... p#α+1 →0 κ(Φαp1	p#α+1)
Where the κ function is defined as in Theorem 4.13.	The relation → in
CL(V ar, ΣZ′∪K ), is the smallest one that contains →0 and pass to the context
Remark 4.17 In [7] it is shown that SBA is almost true, precisely that
([x]BDp)t →0,1 p[t|x], however Theorem 4.13 has as a corollary, that for [x]BD	,
SBA is true using Definition 4.16 (this is the original definition in [7]).
Corollary 4.18 (SBA) If x ∈ V ar, p, t ∈ CL(V ar, ΣZ), and using → of the Deﬁnition 4.16, then ([x]BD−η p)t → p[t|x]

Injectivity of <>Λ (I)
Not all translations are injective, for example using the A ∈ {HS, SH, BD} algo- rithms we have to < (λx.yx)z >A= ([x]A < yx >A) < z >A= ([x]Ayx)z = yz, but on the other hand < yz >A=< y >A< z >A= yz. Since (λx.yx)z and yz belong to different classes of Λ, then <>Λ computed with the indicated algorithms, is not injective.
From the previous example can be inferred that the function <>Λ will never be injective, if the eta rule is used to compute [x]. The following theorem, states which are the conditions that must be assumed, for property I to be fulfilled.


Theorem 4.19 (I) If [x] ﬁts the general recursion scheme, [x]r ∈/
V ar ∪ Zj, [x]

satisﬁes the three conditions of theorem 4.10, and [x] < p > is not uniﬁable with
< q >< t > then:
If p, q ∈ λ-term(V ar, ΣλZ′ ) and < p >=< q > then p ≡α q
Proof. By structural induction. If p ∈ V ar ∪ Zj

p =< p >=< q > since [x]r ∈/ V ar ∪ Zj and if q = qjt then < q >=< qj >< t >∈/ V ar, then q ∈ V ar
⇒
p =< q >= q ⇒ p ≡α q
If p = qjt
< qj >< t >=< p >=< q >, since if q ∈ V ar then < q >∈ V ar, and [x] < qjj >
is not unifiable with < qj >< t >, then q = qjjtj. Therefore
< p >=< qj >< t >=< q >=< qjj >< tj >⇒
< qj >=< qjj > and < t >=< tj > I⇒.H. qj ≡α qjj and t ≡α tj ⇒ p = qjt ≡α qjjtj = q
If p = λx.qj
[x] < qj >=< p >=< q >, since [x] < qj >∈/ V ar ∪ Zj and [x] < qj > is not unifiable with
< qjj >< tj >, then q = λxj.t. Therefore

[x] < qj >=< q >= [xj] < t > V ar$xc fresh in q′t ([x] < qj >)x
= ([xj] < t >)xc

κ is a function
⇒
κ(([x] < qj >)x ) = κ(([xj] < t >)x ) def of κ < qj > [x |x] =< t > [x |xj]

c
Lema 4.5 xc fresh
⇒
c	⇒	c	c

< qj < xc|x >>=< t < xc|xj >> I⇒.H. qj < xc|x >≡α t < xc|xj >
Since xc was any fresh variable, then it can be generalized, obtaining
(∀xc ∈ V ar \ A)(qj < xc|x >≡α t < xc|xj >) where A is the set (finite) of the variables of qj and t. The latter is equivalent to p ≡α q.
2
Corollary 4.20 If [x] ﬁts the general recursion scheme, [x]r ∈/ V ar∪Zj, [x] satisﬁes the three conditions of theorem 4.10, and [x] < p > is not uniﬁable with < q >< t > then:
If p, q ∈ λ-term(V ar, ΣλZ′ ) then < p >=< q > ⇐⇒ p ≡α q
Now a recursive algorithm is defined, to compute the inverse function <>—1: Img(<>) → λ-term(V ar, ΣλZ′ ).
< p >—1= p if p ∈ V ar ∪ Zj,
< p >—1= λxc. < κ(pxc) >—1 if p is an image of [x] for some x and where xc is a fresh variable in p,
< pq >—1=< p >—1< q >—1
If there is ambiguity about what rule to take, the one listed first will be used.
Theorem 4.21 If [x] ﬁts the general recursion scheme, [x]r ∈/ V ar∪Zj, [x] satisﬁes the three conditions of theorem 4.10, [x] < p > is not uniﬁable with < q >< t > then:

If p ∈ λ-term(V ar, ΣλZ
′ ) then << p >>—1∈ λ-term(V ar, Σλ
<< p >>—1≡α p
′ ) and

Proof. Note that if u ≡α uj and y ∈/ BoundV ar(uuj) then u < y|x >≡α uj < y|x > 
(∗∗ ∗∗)
The proof is by structural induction over p. If p ∈ V ar ∪ Zj

<< p >>—1def
—1def

= < p > 
= p ≡α p and

<< p >>—1= p ∈ λ-term(V ar, Σλ ′ )
If p = qt with q, t ∈ λ-term(V ar, ΣλZ′ )
Since < qt >=< q >< t > is not unifiable with [x] < pj >, then
<< q >< t >>—1=<< q >>—1<< t >>—1. Since by I.H.
<<	q	>>—1∈	λ-term(V ar, Σλ ′ ),  <<	q	>>—1≡α	q, <<	t	>>—1∈
—1
λ-term(V ar, ΣλZ′ ) and << t >>	≡α t, then by definition of ≡α, is fulfilled
that << p >>—1=<< q >>—1<< t >>—1≡α qt = p and
<< p >>—1=<< q >>—1<< t >>—1∈ λ-term(V ar, Σλ ′ ).
If p = λx.q with x ∈ V ar and q ∈ λ-term(V ar, ΣλZ′ )

—1	—1
—1[x]<q>∈/V ar∪Z′ and definition of <>−1

<< p >>	=<< λx.q >>
=< [x] < q >>	=



λxc.	<	κ(([x]	<	q	>)xc)	>—1T heor=em 4.10
—1q′≡αq Λ xc∈/BoundV ar(q′) Λ T heorem 4.6
λxc.	<<	q	>

[xc|x] >	=
λxc. << qj > [xc|x] >—1.
It is now proved by cases that < qj > [xc|x] =< qj < xc|x >>.
If xc = x then < qj > [xc|x] =< qj > [x|x] =< qj >=< qj < x|x >>=< qj < xc|x >>.
If xc  /= x then, since xc is fresh in [x] < q  >, it is necessary that

xc ∈/
FreeV ar([x] < q >) T heor=em 4.14
FreeV ar(< q >) \ {x} T heor=em 4.15

FreeV ar(q) \ {x} = FreeV ar(qj) \ {x}, so xc ∈/ FreeV ar(qj), in addition qj

was chosen such that xc ∈/
BoundV ar(qj) and therefore xc ∈/
V ar(qj).  Using

Lemma 4.5 we have to < qj > [xc|x] =< qj < xc|x >>.
Thus << p >>—1= λxc. << qj > [xc|x] >—1= λxc. << qj < xc|x >>>—1
On the other hand defining A := BoundV ar(<< qj < xc|x >>>—1 (qj < xc|x >)) ∪ BoundV ar(qqj) and taking y ∈ V ar \ A, is fulfilled that:
<< qj < xc|x >>>—1< y|xc >
y∈/BoundV ar(<<q′<xc|x>>>−1(q′<xc|x>)), (∗∗∗∗) and I.H.
≡α
(qj < xc|x >) < y|xc >
xc∈/BoundV ar(q′) and xc∈/F reeV ar(q′)\{x}
=
qj < y|x > 
y∈/BoundV ar(qq′) and (∗∗∗∗)
≡α
q < y|x > 
Since y was any variable in V ar \ A, then it can be generalized, obtaining
(∀y ∈ V ar \ A)(<< qj < xc|x >>>—1< y|xc >≡α q < y|x >) where A is a finite

set. The latter is equivalent to:
<< p >>—1= λxc. << qj < xc|x >>>—1≡α λx.q = p
2

References
F. Baader, T. Nipkow, Term Rewriting and All That,Cambridge University Press, Cambridge, 1998.
H. Barendregt, The Lamba calculus, its syntax and semantics,North-Holland, Amsterdam, 1981.
Jean-Louis Krivine, Lambda-calcul: types et mod`eles.,Masson Editores, Paris, 1990.
M. Sch¨onfinkel, U¨ber die Bausteine der mathematischen Logik,Mathematische Annalen, Vol 92 (1924),
pp. 305-316.
H. B. Curry, Robert Feys and William Craig, Combinatory Logic,volume 1. North-Holland, 1958.
J.R.Hindley, B.Lercher y J.P.Seldin, Introduction to Combinatory Logic.,Cambridge University Press, Cambridge, 1972.
S. Broda y L. Damas, Compact Bracket Abstraction in Combinatory Logic,The Journal of Symbolic Logic, Vol 62 (1997), pp. 729-740.
Aledania: Lambda Calculus Evaluator. Avalaible http://stilgar.ldc.usb.ve/Aledania
CalcLogic: Calculative Logic Asistant. Avalaible http://stilgar.ldc.usb.ve/CalcLogic
M. S. Joy, V. J. Rayward-Smith and F. W. Burton. Efficient combinator code.Computer Languages, 10(3/4):211-224, 1985.
M. S. Joy. On the efficient implementation of combinators as an object code for functional programs.PhD thesis, University of East Anglia, 1984.
D. A. Turner, Another algorithm for bracket abstraction. The Journal of Symbolic Logic, 44:267- 270,1979.
D. A. Turner, A new implementation technique for applicative languages. Software-Practice and Experience, 9:31-49, 1979.
T. Hikita, On the average size of Turner’s translation to combinator programs. Journal of Information Processing, 7(3):164-169, 1984.
L. Czajka, On the equivalence off different presentations of Turner’s bracket abstraction algorithm. CoRR, abs/1510.03794, 2015.
M. W. Bunder, Some improvements to Turner’s algorithm for bracket abstraction. Journal of Symbolic Logic, 55(2):656-669, 1990.
S. L. P. Jones, The Implementation of Functional Programming Languages. Prentice-Hall, 19877.
R. J. M. Hughes, Supercombinators: A new implementation method for applicative languages. In LISP and Functional Programming. ACM Press, 1982.
J. R. Kennaway and M. R. Sleep, Variable abstraction in O(n log n) space. Information Processing Letters, 24:343-349, 1987.
R. Kennaway and M. R. Sleep, Director strings as combinators. ACM Trans. Program. Lang. Syst, 10(4):602-626, 1988.
D. Stevens, Variable substitution with iconic combinators. In Andrzej M. Borzyszkowski and Stefan Sokolowski, editors, Mathematical Foundations of Computer Science, volume 711 of Lecture Notes in Computer Science, pages 724-733, Berlin, 1993. Springer-Verlag.
A. R. Diller, Efficent Bracket Abstraction Using Iconic Representations for Combinators. Research Report, School of Computer Science, University of Birmingham, CSR-11-05, 2011.
F. Flaviani, Estudio comparativo de operadores de abstracci´on para la l´ogica combinatoria. Universidad Sim´on Bol´ıvar, Caracas, 2011.


F. Flaviani, Algoritmo de evaluaci´on del λ c´alculo basado en propiedades biyectivas de operadores de abstracci´on. Universidad Sim´on Bol´ıvar, Caracas, 2014.
J. Carette, R. O’Connor, Theory Presentation Combinators. International Conf. on Intelligent Computer Mathematics, Lecture Notes in Computer Science, 2012.
J. Carette, R. O’Connor, Theory Presentation Combinators. preprint of Journal of Formal Reasoning, 2018.
L. Czajka, Improving Automation in Interactive Theorem Provers by Efficient Encoding of Lambda- Abstractions.Proc. ot the 5th ACM SIGPLAN Conf. on Certified Programs and Proofs, St. Petersburg, USA, 2016.
M. Bunder, Expedited Broda-Damas bracket abstraction. Journal of Symbolic Logic, 65(4):1850-1857, 2000.
