

Electronic Notes in Theoretical Computer Science 259 (2009) 177–191
www.elsevier.com/locate/entcs

Guarded Operations, Refinement and Simulation
Steve Reeves1	David Streader2
Department of Computer Science University of Waikato Hamilton, New Zealand

Abstract
Simulation rules have long been used as an effective computational means to decide refinement relations in state-based formalisms. Here we investigate how they might be amended so as to decide the event-based notion of singleton failures refinement of abstract data types, or processes, that have operations with a “guarded” interpretation.
Keywords: refinement, simulation, guards


Introduction
In this paper we do two main things: we look at the consequences of two ways of lifting and completing relations with regard to refinement and simulation for abstract data types (ADTs) in a state-based world; we also look at the consequences of restricting what counts as a simulation in the context of the event-based view of refinement characterised by single failures refinement.

Data reﬁnement and the state-based world
We will review some of the known results about abstract data type (ADT) refine- ment and simulation (and note that we have machine-checked those of interest to us). First, we need to note (much more is said on this later) that state-lifted data types are those where the local state of the data type has a special element added (usually denoted by ⊥), and then the operations of the ADT are given meaning by

1 Email:stever@cs.waikato.ac.nz
2 Email:dstr@cs.waikato.ac.nz

1571-0661 © 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.12.024

relations over this lifted state. In contrast, operation-lifted ADTs are those where each operation in the ADT is first given meaning by a relation over the (unlifted) state and then each operation in the ADT is also lifted by adding ⊥ to its domain and range and adding, according to various prescriptions to be illustrated later, new pairs to the relation that gives the meaning of the operation. Finally, the state is lifted as previously. In addition to the above liftings we can totalise too—this means that in either lifting case we require total relations as the outcome. These subtle differences between ways of lifting in ADTs lead to important results:
forward and backward simulation are sound and jointly complete for state-lifted data type refinement [1]
a single complete simulation rule for data refinement [2]
forward and backward simulation are not jointly complete for data refinement with operation-lifted data types [3]
The standard result of soundness and joint completeness of forward and back- ward simulation with respect to refinement in [1] can be applied equally to partial relations and to total relations (and more specifically, to the total relations that are the outcome of lifting and totalising). The completeness proof involves the construction of an intermediate data type via a power-set construction.
The single complete simulation rule of [2], unlike the joint completeness of [1], does not require the construction of an intermediate ADT. [2] uses the same power- set construction as in the proof of completeness in [1], but in [2] the structure built by the power-set construction is simply part of a computational step in ascertaining whether one ADT is indeed a refinement of another. Hence, in [2], the outcome of the power-set construction need not satisfy the definition of what constitutes an ADT.
The construction of the intermediate structure has been shown [3] to be very sensitive to the detailed definition of ADTs. Whether the outcome of the power-set construction is a valid data type or not actually depends on the definition of “data type” you choose. With the completely reasonable logical definition chosen in [3] the output of the power-set construction is not a valid data type (as we noted above). With an alternative and more liberal definition (to be given later) of “data type” the standard HHS result can be applied and we get a completeness proof again.
Consequently we have two possibilities: one, we can keep the logical definition
[3] of data type with the consequence that the completeness proof fails; two, we can liberalise the definition of data type to include the results of the power-set construction and have a valid completeness proof.
It turns out that the two sorts of ADT differ in a very small way in their definitions and which is chosen is largely a matter of personal taste, and anyhow the literature already contains several subtly distinct definitions of ADTs.

Singleton failures reﬁnement and the event-based world
We know that
data refinement is not equal to singleton failures refinement [4]
backward simulation is not sound with respect to singleton failures refinement [5]
so we will analyse singleton failures refinement further (since it is not the same as data refinement it is interesting to see what its properties are). It will turn out that with a restricted definition of simulation we can establish the following results:
restricted forward and backward simulation are sound with respect to singleton failures refinement and either sort of lifting
restricted forward and backward simulation are complete for singleton failures refinement and data types with lifted state
restricted forward and backward simulation are not complete for singleton fail- ures refinement and data types with lifted operations
there is one complete simulation rule for singleton failures refinement and data types with either lifted state or lifted operations
restricted forward and backward simulation are not complete for data refine- ment and data types with either lifted state or lifted operations
These results and those labelled with Theorem in the rest of the paper have been machine checked using Isabelle [6].

Abstract data types with guarded operations
An ADT consists of a set of named operations that act on private (local to the ADT) state State plus two special operations:
init that initialises the data type by relating the public (the global state in which the ADT is used) state to the private state and
final that terminates the data type by relating the private state back to the public state
All operations will be given a relational semantics.
Definition 2.1 Simple Data Type D, where NamesD is a set of names for the operations of D, StateD is the local (private) state of D and Stateg the global (public) state of a program which uses D, is given by:
(StateD, OpD, initD, finalD, NamesD) and
OpD : NamesD → StateD × StateD
initD : Stateg × StateD

finalD : StateD × Stateg
We view this as saying that the operations in D are named relations, so for the semantics of the (purely syntactic) operation name a ∈ NamesD from ADT D, which we write D.a when we need to disambiguate, we write D.a)  OpD(a).
For example, for ADT A the relations which give semantics to the operation names a, b and c are given by the solid lines in figure 1 (ignore anything involving
⊥ for now).

init
•
A.a
A.b
A.c
final



p = a;b;c





Fig. 1.  A.p)T  initA; A.a)T; A.b)T; A.c)⊥;finalA

The simple ADTs captured by definition 2.1 are open to several informal inter- pretations. Their operations could be undefined outside of precondition (outside of the domain of the relation they denote) or they could be guarded outside of the precondition. In addition the behaviour inside the precondition could have a totally correct interpretation, i.e. the operation will terminate and will terminate in one of the post-states indicated by the relation or it could have a partially correct inter- pretation, i.e. the operation might terminate and if it terminates it will terminate in one of the post-states indicated by the relation.
One way to formalise the desired interpretation is to lift and totalise the (in general, partial) relation that gives the meaning of an operation name appropriately. A second way is to keep the original relations as the operations and define refinement that is consistent with (captures) the desired interpretation.

Lifting and totalising operations
We can lift and totalise the relations in many ways. Here we are interested in interpreting the operations:
as guarded outside of precondition
with a choice of termination interpretation:
the total correctness interpretation, i.e. they must terminate
the partial correctness interpretation, i.e. they may terminate
Point two is often not mentioned but because we are going to use ⊥ to repre- sent “not terminated” our semantics can explicitly distinguish operations that may

terminate from operations that must terminate.
For example, in figure 1, if we consider the relations given by all the lines in the diagram, then we have lifted and totalised our operations to give them a guarded, total correctness meaning.
In contrast, the partially correct interpretation of guarded operations can be formalised by allowing an operation to always be able to not terminate. Thus the relations relate all pre-states to ⊥, indicating that termination is never guaranteed and hence it is always possible to not terminate: for example add (1, ⊥) to operation a in figure 1.
It is the exclusion of states from which an operation both might terminate and might fail to terminate that characterises the total correctness interpretation and which makes the completeness proof of [1] fail.
We will formally define these possibilities for ADTs in the next section, but for now we introduce transformations on the semantics of single operations, like a, from some simple ADT D which reflect the above discussion.
First, the semantics that reflects guarded operations that must terminate (T for “total”):
 D.a)T   D.a) ∪ {(x , ⊥) | x ∈ StateD ∪ {⊥} ∧ ¬ ∃ y .(x , y ) ∈ D.a)}
Secondly, the semantics that reflects guarded operations that may terminate (P for “partial”):
 D.a)P   D.a) ∪ {(x , ⊥) | x ∈ StateD ∪ {⊥}}

Lifting and totalising data types
As we have indicated above, we have two ways to define extensions (completions) of data types whose operations have a lifted and totalised relational semantics. We now give formal definitions for these alternatives.
Firstly we deal with data types over lifted state. That an ADT has been extended in this way is indicated by placing S⊥ as a superscript to the ADT name: this indicates that the relational semantics of the operations of the original simple ADT have been extended to give a new ADT over a lifted state. In order that we can lift this new value to whole programs (later) the global space is similarly lifted.
Definition 2.2 Let D be some simple ADT (StateD, OpD, initD, finalD, NamesD). DS⊥ is a state-lifted extension of D. The state-space StateDS⊥  StateD ∪ {⊥} of DS⊥ contains a special value denoted by ⊥. DS⊥ has the form
(StateDS⊥ , OpDS⊥ , initDS⊥ , finalDS⊥ , NamesD) where
OpDS⊥ : NamesD → StateDS⊥ × StateDS⊥ initDS⊥ : (Stateg ∪ {⊥}) × StateDS⊥ finalDS⊥ : StateDS⊥ × (Stateg ∪ {⊥})
and

∀ a ∈ NamesD.OpDS⊥ (a) ⊇ OpD(a)
initDS⊥ ⊇ initD finalDS⊥ ⊇ finalD
and all the relations are total.
Note that for state-lifted ADTs the operations (following the definition for simple ADTs) are, for any operation name a ∈ NamesD,
 DS⊥ .a)S  OpDS⊥ (a)
Further note that there are no restrictions as to which relations are allowed as operations, save that they be total, including initialisation and finalisation.
Next, we deal with data types with (explicitly) lifted operations. Here the only relational semantics we admit as valid are those that are the result of a particular lifting of the operations of a simple abstract data type which is an example of either of the formalisations of must or may terminate from section 2.1.
Definition 2.3 Let D be some simple ADT (StateD, OpD, initD, finalD, NamesD).
DOT⊥ is an operation-lifted abstract data type with total correctness extension of
D. The state-space StateDOT⊥   StateD ∪ {⊥} contains a special value denoted by
⊥. DOT⊥ has the form
(State OT  , Op OT  , initOT⊥ , finalOT⊥ , NamesD)
D  ⊥	D  ⊥	D	D
where
OpDOT⊥ : NamesD → StateDOT⊥ × StateDOT⊥

initOT⊥ : (Stateg ∪ {⊥}) × State
DOT⊥

finalOT⊥ : State
DOT⊥
× (Stateg ∪ {⊥})

and
∀ a ∈ NamesD.OpDOT⊥ (a) ⊇ OpD(a) initDOT⊥ = initD ∪ {(⊥, ⊥)} finalDOT⊥ = finalD ∪ {(⊥, ⊥)}
and, for any operation a from NamesD,  DOT⊥ .a)   D.a)T
Definition 2.4 Let D be some simple ADT (StateD, OpD, initD, finalD, NamesD).
DOP⊥ is an operation-lifted abstract data type with partial correctness extension of
D. The state-space StateDOP⊥   StateD ∪ {⊥} contains a special value denoted by
⊥. DOP⊥ has the form
(State OP  , Op OP  , initOP⊥ , finalOP⊥ , NamesD)
D  ⊥	D  ⊥	D	D
where
OpDOP⊥ : NamesD → StateDOP⊥ × StateDOP⊥

initOP⊥ : (Stateg ∪ {⊥}) × State
DOP⊥

finalOP⊥ : State
DOP⊥
× (Stateg ∪ {⊥})

and
∀ a ∈ NamesD.OpDOP⊥ (a) ⊇ OpD(a)

initDOP⊥ = initD ∪ {(⊥, ⊥)}
finalDOP⊥ = finalD ∪ {(⊥, ⊥)}
and, for any operation a from NamesD  DOP⊥ .a)   D.a)P.
Clearly a data type with lifted operations is an example of a data type over lifted state. But there are data types over lifted state that are not a data type with lifted operations. Importantly the data types built by the power-set construction, used in [1] to prove the completeness result, are not ADTs with lifted operations. The behaviour of lifted “must terminate” operations is restricted so that in any state they either can be performed and must terminate or cannot be performed and are blocked. Operations that from some state may be performed and terminate or may fail to terminate and are blocked do not satisfy the lifted operation definitions in definition 2.3 and definition 2.4. So, any constructions containing such operations cannot be ADTs with lifted operations, hence the failure of the completeness proof.

Data refinement and simulation
A program p calls a sequence of operations each from some ADT 3 . This sequence must always start with init and end with final. For ease of writing init and final will often be omitted, but must be assumed to be present.
Definition 3.1 If {oi}1≤i≤n are operation names from ADT D and p is the program oi1 ; oi2 ; ....; oim where 1 ≤ ij ≤ n for 1 ≤ j ≤ m then we say p is a program over D and
D.p  init ; D.oi1 ; D.oi2 ; ...; D.oim ; final
We also extend the various ways of giving semantics to operation names to programs in the obvious way.
Definition 3.2 If {oi}1≤i≤n are operation names from ADT D and p is the program
oi1 ; oi2 ; ....; oim where 1 ≤ ij ≤ n for 1 ≤ j ≤ m then
 D.p)X  initD ;  D.oi )X ;  D.oi )X ; ...;  D.oi )X ; finalD
where X can be any of S, T or P and the appropriate extensions of initialisation and finalisation for X are also used.
Definition 3.3 Data Refinement for guarded operations, written ± (and possibly decorated with super- and sub-scripts), is dependent on the semantics (of the op- erations) of the two data types which it relates. If A and C are two data types and p is some program over those ADTs, then A ±X C   C.p)X ⊆ A.p)X, where X can be any of S, T or P.

3 In what follows we allow “ADT” to range over all the possibilities for ADTs (simple or extensions) that we have seen so far.

If we can construct a simulation on a partial relation semantics, either forward or backward, between the A and C above then we know there is a data refinement A ± C from the well-known soundness of simulation.

•	•



Fig. 2. Simulation

Definition 3.4 Let A and C be ADTs. There is a backward simulation relation between them iff there exists some α ⊆ StateC × StateA such that
B1.	initC;α ⊆ initA
B2.	∀ o ∈ OpA. C.o)X;α ⊆ α; A.o)X
B3.	finalC ⊆ α;finalA
Further, there is a forward simulation relation between A and C iff there exists some
α ⊆ StateC × StateA such that
F1.	initC ⊆ initA;α−1
F2.	∀ o ∈ OpA.α−1; C.o)X ⊆ A.o)X;α−1
F3.	α−1;finalC ⊆ finalA
where X can be any of S, T or P and the appropriate extensions of initialisation and finalisation for X are also used.
Thus we have one definition for backward and one for forward simulation. These can be applied to both types of ADT: the state-lifted ADTs of definition 2.2; and the operation-lifted ADTs of definition 2.3 and definition 2.4.


Soundness and Completeness
We write ±X for backward simulation and ±X

for forward simulation. The Hoare,

α	α−1
He and Saunders soundness result applies to all the various lifting and totalising
regimes we have looked at above.
Theorem 3.5 Soundness of forward and backward simulation [1]
A ±X C implies A ±X C
A ±X	C implies A ±X C
Definition 3.6 Forward and backward simulation are jointly complete iff there exist ADTs B1 ... Bn−1 and there exist relations α1 ... αn such that
A ±α1 B1 ±α2 B2 ... ±αn C

The important point is the existence of the intermediate data types and the relations. Hence this definition is dependent upon what it means to be an ADT and what is an acceptable relation in this context.
The standard Hoare He and Saunders result [1] that forward and backward sim- ulation are sound and jointly complete certainly applies to the data types over lifted state. But as Boiten and Derrick [3] point out the joint completeness is not valid for what we call operation-lifted data types with the must-terminate interpretation. It should be noted that the result fails because of the restriction placed on what operations are valid in the ADT and thus it is not always possible to compute chains of simulation between operation-lifted data types that refine each other. In order to regain the completeness property all we need to do is relax this restriction.
2	b	⊥	c	⊥	final	⊥
c	5	final	•




{1}	a	{2, 3}  b {4, ⊥}  c {5, ⊥}
℘T(A)
final  •
final ⊥



{w}  a {x, y, z} b {s, t, ⊥}  c {r, ⊥}














Fig. 3. A ± C as A ±T ℘T(A) ±T ℘T(C) ±T−1 C
∈	∈
The power-set construction [8] builds an intermediate ADT (see figure 3). We have adopted the usual event-based convention and do not show the operations that are blocked; in state-based terminology these are operations that end at ⊥.
Definition 3.7 Power-set construction on operation-lifted semantics.
Let A be some operation-lifted must-terminate ADT
(StateA, OpA, initA, finalA, NamesA)
Let • be a member of the global state (we assume it is the only one since we need

no more).
Let R(X )  {y | ∃ x ∈ X .(x , y ) ∈ R}. In particular, for any operation name
a ∈ NamesA:


Then,
 a)T(X )  {y | ∃ x ∈ X .(x , y ) ∈ a)T}.

℘T(A)  (℘(StateA), ℘T(initA), ℘T(OpA), ℘T(finalA), NamesA) where
℘T(initA)  (•, initA(•))
℘T(OpA)  {(a, (X , a)T(X ))) | X ⊆ StateA ∧ a ∈ NamesA}
℘T(finalA)  {(X , f ) | X ⊆ StateA ∧ f ∈ finalA(X )}
To show that forward and backward simulation are complete with respect to data refinement we apply the power-set construction to the (lifted, totalised) A and C thus building ℘T(A) and ℘T(C). A standard result is the existence (by construction)
of a backward simulation A ±T ℘T(A) and a forward simulation ℘T(C) ±T	C.
∈	∈−1
We can view the output from the power-set construction as a normal form and it can be seen that A ± C if and only if ℘T(A) ± ℘T(C). Further we can rename the nodes used in the power-set construction so that ℘T(A) ± ℘T(C) if and only if when we ignore all unreachable states the concrete operations, including init and final, are a subset of the abstract operations with the same name: ∀ o.℘T(A.o) ⊇ ℘T(C.o).
Theorem 3.8 Completeness of simulation with respect to reﬁnement for ADTs A
and C:
[1] If A ± C there exists a sequence of simulations between ADTs from A to C
[3] A ± C iff ℘T(A) ± ℘T(C)
Thus for both data types with lifted operations which must terminate and data types over lifted state, forward and backward simulation are sound and we have that ∀ o.℘T(A.o) ⊇ ℘T(C.o) acts as a complete test for refinement.
The Logical Style of deﬁning simulation
There are two basic styles we can take when defining simulation between ADTs, the logical and the relational (as in the previous sections) styles.
The logical style usually makes use of pre- and post-condition predicates (hence our name for it). The pre-condition defines where the operation is defined (the im- age of its relational semantics) and the post-condition defines the relation between the initial and final state of an operation. For simulation on a simple ADT (defini- tion 2.1) with no particular interpretation all that is needed in the logical style is the strengthening of the post-condition (remember we are dealing with guarded— blocking—semantics here).
Where the operations are to be interpreted as guarded outside of precondition and totally correct:

Relational style we lift (add ⊥) and totalise the relational semantics and treat ⊥
as part of the state space (definition 3.4);
Logical style we define simulation as the preservation of the pre-condition and the strengthening of the post-condition.
This can be translated into conditions on the relational semantics and is often done in such a way that no reference to ⊥ is needed. For people who are uneasy with the inclusion of ⊥ (“what does ⊥ really mean?” is a common puzzle) this is an advantage.
Definition 3.9 Logical style Let A and C be ADTs. There is a backward simu- lation between them iff there exists some α ⊆ StateC × StateA such that
initC;α ⊆ initA

∀ o ∈ OpA.dom C.o) ⊆ α−1(dom A.o))
∀ o ∈ OpA. C.o);α ⊆ α; A.o)
finalC ⊆ α;finalA
Clause (ii) is the preservation of the pre-condition or an applicability condition and clause (iii) is the strengthening of the post-condition or a correctness condition. With data types over lifted operations (definition 2.3 and definition 2.4) the logical and relational styles of simulation are the same. But when we use data
types over lifted state (definition 2.2) this is no longer true.
Remember there are data types over lifted state that are not data types with lifted operations. By looking at these extra data types we can see that using defi- nition 3.4 is not the same as using definition 3.9 on a data type over lifted state.
Any logical style of simulation that characterised definition 3.4 would, because of the extended set of relations allowable, require an additional explicit predicate to indicate that some states were related to ⊥.
From this logical perspective we can say that the cost of not allowing ⊥ to be included in the predicates defining the behaviour of an operation is that the completeness result has been lost for operation-lifted ADTs.
The lack of completeness of forward and backward simulation for data types with lifted operations is important as it tells us that we cannot compute all refinements by constructing intermediate data types (with no explicit reference to non-termination) and computing forward or backward simulations. If on the other hand we permitted the definition of operations to make reference to non-termination then we would have the completeness result.

Singleton Failures semantics
First, a little notation: for ADT A let s−a→⊥ be event-based notation short for (s, ⊥) ∈  a)T and where ρ is a sequence of operations let sA−ρ→s be notation for

(•, sA) ∈ initA ∧ (sA, s) ∈  ρ)T (so sA is a start-state and ρ is a program).
Definition 4.1 Singleton failures semantics of an ADT A is given by sF where:
sF (A)  {{(ρ, a)} | s ∈ State ∧ s −ρ→s ∧ s−a→⊥}∪
{(ρ, {}) | sA ∈ StateA ∧ ∃ s.sA−ρ→s}
Also, for any ADTs A and C, A ±sF C  sF (C) ⊆ sF (A)

Sound restricted simulation relations
Previously, using the particular processes in A and C in figure 3, we have shown that backward simulation is not sound with respect to singleton failures semantics [4]. Here we will show that using restricted simulation relations we can establish that forward and backward simulation are sound with respect to singleton failures semantics.
The definition of singleton failures semantics depends on the existence of a state n such that n /= ⊥ (the second element of the union in definition 4.1) but this property is not preserved by the (usual) simulation relations as in the previous section, whereas restricted simulation relations do preserve the property.
Definition 4.2 A restricted simulation relation α is a simulation relation where if (x , y ) ∈ α then x /= ⊥⇔ y /= ⊥.
Soundness with respect to singleton failures semantics follows for this restricted notion of simulation relations.
Theorem 4.3 Soundness. Let there be a restricted simulation relation α between ADTs A and C. Then:
A ±T C implies A ±sF C
A ±T	C implies A ±sF C
From the soundness we can see that any sequence of simulations relates pairs of processes that are singleton failures refinements of each other only. Given the transitivity of singleton failures refinement we can see that we will never be able to relate A to C by a restricted simulation relation in figure 3 as it is easy to verify that A /±sF C. But A ± C (data refinement) does hold, hence with the restricted simulation relation forward and backward simulation are not complete with respect to data refinement, even if we use operation-lifted data types.

Completeness
To show completeness we apply a “guarded” power-set construction. This is the application of the power-set construction to the original states (i.e. not including
⊥) only.

Definition 4.4  Guarded	power-set	construction	of	on	ADT	A	 
(StateA, initA, OpA, finalA) where
℘(A)  (℘(StateA \ {⊥}) ∪ {⊥}, ℘(initA), ℘(OpA), ℘(final))
℘(initA)  (•, initA(•))
℘(OpA)  {℘(a) | a ∈ NamesA}
℘(a)  {(X , a)(X )) | X ⊆ StateA \ {⊥}}∪ {(X , ⊥) | ∃ x ∈ X .(x , ⊥) ∈ a)T}
∪ {(⊥, ⊥)}
℘(finalA)  {(X , f ) | X ⊆ StateA \ {⊥}∧ f ∈ finalA(X )}∪ {(⊥, ⊥)}
A program using the constructed data types has a deterministic path between elements of ℘(State), but with potential non-determinism where one branch ends at ⊥. Just like for data refinement this construction requires data types from definition 2.2 not definition 2.3 or definition 2.4. Hence our completeness proof, like that in section 3 for ADT, is correct for state-lifted ADT only and is incorrect for operation-lifted ADT.
See figure 4 for an example of the use of the definition. Note that since the simulation relations are now restricted we are able to construct simulation relations between a restricted set of ADTs only. Although ∀ o.℘T(A.o) ⊇ ℘T(C.o) (figure 3) we find that ¬ ∀ o.℘(A.o) ⊇ ℘(C.o) (figure 4). In particular, ℘(A) does not contain and counterpart to ({s, t }, ⊥) in ℘(C). This is just what we want as A /±sF C but C ±sF A. (Note that ∈⊥ ∈∪ {(⊥, ⊥)}.)
2	b	⊥	c	⊥	final	⊥
1	A
3	b	4	c	5	final	•
∈⊥
{1}	a	{2, 3}	b	{4}	c	{5}	final	•
℘(A)

⊥	c	⊥
final	⊥



{w}  a {x, y, z}
b	{s, t}
c	{r}
final	•

b	c	℘(C)

−1
⊥
x		b	s C
⊥	c	⊥


c
final	⊥

w
y	b	⊥
c	⊥	final	⊥

z	b	t	c	r	final	•

Fig. 4.

The ∈⊥ relation between A and ℘(A) preserves the singleton failures, as does the ∈−1 relation between ℘(C) and C.

From definition 4.4, i.e. by construction, it is easy to see that ∀ o.℘(A.o) ⊇ ℘(C.o) if and only if ℘(A) ±sF ℘(C).

Theorem 4.5 Completeness of restricted simulation with respect to singleton fail- ures reﬁnement for ADTs A and C. (Similar to known results for data reﬁnement.)
Similar to [1] If A ±sF C then there exists a sequence of restricted simulations between ADTs from A to C
Similar to [3] A ±sF C iff ℘(A) ±sF ℘(C)

Theorem 4.5 provides us with a single complete rule for singleton failures se- mantics.
Although our completeness proof is applicable to state-lifted ADT only, we are not asserting that an alternative approach might not provide a completeness proof for operation-lifted ADTs too. Constructing an intermediate ADT where all nonde- terminism appears in the init operation appears a promising first step in the design of such a proof.


Conclusion
The known results for ADTs with guarded operations and a total correctness inter- pretation are:
State-lifted ADT have the properties:
forward and backward simulation are sound [1]
forward and backward simulation are jointly complete [1]
there is a single complete refinement rule: A ± C ⇔ ℘T(A) ± ℘T(C) [2]
Operation-lifted ADT  have the properties:
forward and backward simulation are sound [1]
℘T(A) is not a data type with lifted operations and forward and backward simulation are not jointly complete [3]
there is a single complete refinement rule: A ± C ⇔ ℘T(A) ± ℘T(C) [2]
The results for singleton failures semantics that we have machine checked are:
Singleton failures refinement for state-lifted ADT has the properties:
restricted forward and backward simulation are sound
restricted forward and backward simulation are jointly complete
there is a single complete refinement rule: A ±sF C ⇔ ℘(A) ±sF ℘(C)
The restriction we have made to the definition of simulation relations has been motivated simply by considering what can be observed when an operation is exe- cuted.

References
He, J., Hoare, C.A.R., Sanders, J.W.: Data refinement refined. In: Proc. of the European symposium on programming on ESOP 86, New York, NY, USA, Springer-Verlag New York, Inc. (1986) 187–196
Derrick, J.: A single complete refinement rule for Z. Journal of Logic and Computation 10 (2000) 663–675
Boiten, E., Derrick, J.: Incompleteness of relational simulations in the blocking paradigm. Draft (2008)
Reeves, S., Streader, D.: General refinement, part two: flexible refinement. Proceedings of Refine 2008, Electronic Notes in Theoretical Computer Science (2008)
Reeves, S., Streader, D.: State-based and event-based refinement: reconciling differences. Technical report, University of Waikato (2008) In http://researchcommons.waikato.ac.nz/cms.
Nipkow, T., Paulson, L.C., Wenzel, M.: Isabelle/HOL — A Proof Assistant for Higher-Order Logic. Volume 2283 of LNCS. Springer (2002)
Spivey, J.M.: The Z notation: A reference manual. 2nd. edn. Prentice-Hall International series in computer science. Prentice Hall (1992)
de Roever, W.P., Engelhardt, K.: Data Refinement: Model oriented proof methods and their comparison. Number 47 in Cambridge Tracts in Theoretical Computer Science. Cambridge University Press (1998)
Reeves, S., Streader, D.: General refinement, part one: interfaces, determinism and special refinement. Proceedings of Refine 2008, Electronic Notes in Theoretical Computer Science (2008)
