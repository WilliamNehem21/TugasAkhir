Electronic Notes in Theoretical Computer Science 137 (2005) 65–75	
www.elsevier.com/locate/entcs

Factbase Filtering Issues in an Ontology-Based Reverse Engineering Tool Integration System
Dean Jin1
Department of Computer Science University of Manitoba Winnipeg, Canada
James R. Cordy2
School of Computing Queen’s University Kingston, Canada

Abstract
The Ontological Adaptive Service-Sharing Integration System (OASIS) facilitates reverse engineer- ing tool interoperability by sharing services among tools that represent software in a conceptually equivalent manner. OASIS uses a domain ontology to record the representational and service- related concepts each tool offers. Specialized adapters use a filtering process to map factbase in- stances to domain ontology concepts and apply shared services. This paper examines three issues related to the filtering process: representational correspondence, loss of precision and information dilution.
Keywords: reverse engineering, tool integration, interoperability, service-sharing, domain ontology, factbase filtering


Introduction
Previous approaches to reverse engineering tool integration have concentrated on the exchange of data through specialized hardcoded interfaces (APIs) or

1 Email: djin@cs.umanitoba.ca
2 Email: cordy@cs.queensu.ca




1571-0661 © 2005 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2005.07.006

rigid standardized exchange formats [13]. These methods have failed to pro- vide software maintainers with a unified environment for supporting and au- tomating reverse engineering tasks [2,6,9,11]. This is because these approaches are prescriptive, forcing tool developers to provide a particular functionality to another tool or conform to an idiomatic standard in order to participate in the integration process.
The Ontological Adaptive Service-Sharing Integration System (OASIS) is a novel approach to integration that provides a means for reverse engineering tools to work cooperatively to share services and assist maintainers in carry- ing out reverse engineering tasks. OASIS makes use of specially constructed, external tool adapters and a domain ontology to facilitate integration among a set of reverse engineering tools. A proof of concept implementation of OA- SIS was recently carried out by researchers involved in the Software Design Ontology Project at Queen’s University. This implementation was success- ful in sharing services among three reverse engineering tools: ASDT [8,1], Fahmy Tool [4] and Rigi [10,12]. This paper provides an overview of OASIS and focuses on three issues that arise from the use of factbase filtering in the integration process.

OASIS Overview
In an OASIS implementation, a set of reverse engineering tools are selected to participate in an integration. Each tool offers a set of services to the in- tegration that are shared among the other participants. A tool service is the functionality provided by a tool that, when given a set of one or more inputs, generates a corresponding output that is relevant for maintainers. In the case of reverse engineering tools the inputs are typically source code (or facts about source code) and the output is typically a report or visualization.
Figure 1 provides an architectural overview of OASIS. The components in an integration consisting of two participant tools (T1 and T2) are shown. An actual OASIS implementation can have any number of participants. Only two are shown here for simplicity. Each tool consists of a factbase instance (I1 and I2) containing software facts whose form is dictated by a schema (S1 and S2). A set of transactions (Q 1 and Q 2) conform to the schema and operate on the instance. In [7] we argued that most reverse engineering tools are database systems that are specially tailored to store, manipulate and analyze software facts. The terminology (i.e. transaction, schema, instance) we use to describe the operational characteristics of reverse engineering tools is equivalent to the terms used by researchers in the database systems community (for example, see [3]).










Fig. 1. The OASIS Architecture

An OASIS implementation involves the construction of two types of com- ponents: a domain ontology (O) and tool-specific conceptual service adapters (A1 and A2). All the knowledge required to support service-sharing among each of the tools participating in the integration is stored in the domain on- tology. Our domain ontology is a tabularized, cross-referenced compilation of shared representational concepts and services offered by each participant in the integration. Only one domain ontology is constructed for an OASIS im- plementation. The conceptual service adapters (CSAs) operate as integration facilitators. One CSA is affiliated with each integration participant. Although all the CSAs have the same architecture and operational characteristics, each is tailored to handle the functional and information filtering aspects of it’s corresponding tool that are required to facilitate interoperability. A service offered by a tool participating in the integration can be shared only when the concepts required by the service intersect with the concepts supported by another participant tool.

Factbase Filtering
The domain ontology has knowledge of the concepts that are shared among all the tools participating in the integration. Taken together, these concepts de- fine a conceptual space, consisting of conceptual ‘slots’ that factbase instances fit into. A factbase instance fits into a slot when the concept it represents matches a concept in the domain ontology. The representation in the concep-



Fig. 2. inFilters, outFilters and the Conceptual Space
Each conceptual service adapter uses an inFilter and outFilter to respectively map software facts to and from a factbase instance and the conceptual space deﬁned by the domain ontology. Facts stored in a factbase always conform to a tool schema. The conceptual space representation is not bound by a schema, as facts exist there only if they exhibit a conceptual equivalence to a domain ontology concept.

tual space is based on conceptual equivalence, so it is not bound by a schema and is free of constraints.
Shared services only operate on fact instances that actually fit into the conceptual slots. When a service is being shared, the CSAs for the two tools involved map all factbase instances into and out of the conceptual space. We call this process of mapping to and from the conceptual space ﬁltering. An inFilter maps factbase instances to the conceptual space. An outFilter maps conceptually represented facts in the conceptual space back to a tool factbase instance. The relationship between a factbase instance, an inFilter, an outFilter and the conceptual space is shown in Figure 2.
The inFilter and outFilter used by each CSA is specially tailored to work with the representation supported by the tool the CSA corresponds to. In the OASIS proof of concept implementation, the filters were constructed using using a combination of LINUX shell scripts and executable grok [5] tool scripts.
It is important to understand the actual filtering that is performed by each of the inFilters and outFilters. Although not formally specified, Figures 3 and 4 show the filtering that occurs for ASDT and Fahmy Tool. In each of these

figures, the left column indicates the entities and relationships from the schema for the tool that take part in the filtering process. The right column shows the domain ontology concepts that make up the conceptual space. The arrows between the two columns indicate the mapping the inFilters and outFilters perform. The inFilters map from the left column to the right. The outFilters map from the right column to the left. For example, in Figure 4 the module entity from the Fahmy Tool schema is mapped to the concept SubProgram in the conceptual space. Likewise, in Figure 3 Containment from the conceptual space is mapped to ASDT’s contains relationship.
A number of issues related to factbase filtering are apparent in Figures 3 and 4. In particular, we discuss representational correspondence, loss of pre- cision and information dilution in the following sections.

Representational Correspondence
Representational correspondence is a significant consideration that relates to the mapping of factbase instances to the conceptual space. There are three ways that these mappings can occur:
One-To-One. This mapping occurs when a tool natively represents a con- cept found in the conceptual space. There is no loss in representational detail in either direction as the factbase instance passes through the concep- tual space. For example, ‘contains’ is commonly represented in the schema for reverse engineering tools and can be considered a one-to-one mapping to the Containment concept in the conceptual space.
Fanning Out. When a single tool schema entry yields more than one con- ceptual space concept, we refer to the mapping as fanning out. A good example is the usevar relationship in Fahmy Tool (see Figure 4) which cor- responds to a Variable entity and a Containment and Use relationship in the conceptual space. We call such a representation ‘conceptually rich’. The mapping itself is constructive, as it yields three concepts for every usevar factbase instance encountered.
Note that fanning out is different from multi-concept equivalence, where a single tool schema entry is conceptually equivalent to multiple concep- tual space concepts. This situation is strongly indicative of concept over classification in the domain ontology. If concept classification is too finely grained, the distinction between concepts becomes blurred and conceptual equivalence for tool schema entries becomes difficult to determine.
Fanning In. In this case, multiple entities or relationships combine to- gether to correspond to a single conceptual space concept. Fanning in is apparent in the ASDT tool (see Figure 3), where the function and procedure


ASDT inFilter


ASDT outFilter



(S+)


(m)


(s)
program


module


function procedure
System


Module


SubProgram






(v)
constant
const_parameter pervasive_constant variable
var_param eter



Variable



contains

S+	m
S+	s
S+	v
m	m
m	s
m	v
s	v




Containm ent
<entity>  <entity>



calls
calls_indirect


(5)


(3)

S+	s
m	s
s	s

read_ref read_ref_indirect
S+	v
m	v
s	v







(5)
Us e

<entity>  <entity>







<entity>  <Variable>

write_ref
write_ref_indirec t
S+	v
m	v
s	v

(5)




Loss of Precision: SubProgram is reconciled to procedure
Loss of Precision: Variable is reconciled to variable
Loss of Precision: Use is reconciled to calls
Loss of Precision: Use is reconciled to read ref
The relationships calls indirect, read ref indirect and write ref indirect are produced by the Slice service. The ASDT outFilter does not map conceptually represented facts from the conceptual space into these relationships.

Fig. 3. In and Out Filtering ASDT Schema to the Conceptual Space


Fahmy Tool inFilter


Fahmy Tool outFilter



(S+)


(m)


(s)
system


subsystem


module


no representation













(2)
System


Module


SubProgram


Variable



contain
S+	m
m	m
m	s

Containm ent
<entity>  <entity>



(2)
no representation

<entity>  <Variable>



hlu (4)
m	m

Use


<entity>  <entity>

useproc
s	s
m	s
s	m



(3)
(3)




usevar
s	s
m	s
s	m





(3)
(3)
(2)



(1)


<entity>  <Variable>



This is a special case of Use where each Variable in the range is expressed in terms of the
SubProgram that contains it.
Although Fahmy Tool does not support the representation of variables, we are able to induce them from the usevar representation. Unique Variable instances are generated based on the name of the entity where the variable is contained. These instances are identifiable in the range of the usevar relationship. Each usevar instance generates a Variable and Containment and Use relationships in the conceptual space.
These constraints exist in the results of the Hide Interior service. The Fahmy Tool outFilter does not map conceptually represented facts from the conceptual space into these relationship constraints. The inFilter does map these fact instances into the conceptual space.
The relationship hlu is produced by the High Level Use service. The Fahmy Tool outFilter does not map conceptually represented facts from the conceptual space into this relationship.

Fig. 4. In and Out Filtering Fahmy Tool Schema to the Conceptual Space

representations together constitute SubProgram in the conceptual space. This mapping is lossy because representational detail is lost in the mapping from ASDT to the conceptual space.

Loss of Precision
Loss of Precision is the converse of ‘fanning in’ representational correspon- dence discussed in Section 3.1. It occurs when conceptually represented facts correspond to more than one representation in a local tool factbase instance. A single mapping without loss of representational detail is not possible. In this situation the OASIS implementor must decide which local tool representation more closely matches the conceptually represented fact. The outFilter for the tool must be programmed to map those conceptually represented facts to the local representation chosen.
Three examples of loss of precision can be observed in the ASDT out- Filter shown in Figure 3. The SubProgram entity is reconciled to procedure, resulting in the loss of the function representation. The Variable entity is rec- onciled to variable, resulting in the loss of four entity representations: constant, const parameter, pervasive constant and var parameter. Finally, the Use rela- tionship between an <entity> and <Variable> is reconciled to read ref, resulting in the loss of the write ref relationship representation.
The negative effects of loss of precision may be minimal. For example, loss of precision for fact instances being brought into a tool for shared-service execution is generally not a problem. The service operates only on the ‘lower precision’ facts anyway. Nevertheless, results returned from a shared-service may not make sense.
The loss of precision in an OASIS implementation may be an indicator of the need to reevaluate the domain ontology. It may be necessary to expand the ontology to differentiate an important concept from another. This would have the effect of increasing the precision of the ontology so that the distinction between two concepts is no longer lost when it is mapped from the conceptual space.

Information Dilution
A very important consideration when facilitating shared-services in an OASIS implementation is the problem of Information Dilution. It is often the case that the user of a particular tool has expectations of a shared-service that go beyond what the service is capable of providing. Often there are very subtle differences in the representations supported by tools participating in an OASIS implementation. These representational differences affect the fact

instances that get forwarded through the conceptual space to a shared-service and ultimately lead to unexpected results.
Consider the High Level Use service offered by Fahmy Tool. In Figure 5 (a) we see the ASDT representation of a hypothetical software system. Executing Fahmy Tool’s High Level Use service on this representation yields the results shown in Figure 5 (b). The calls relation between the functions foo and bar is ‘lifted’ to indicate a high level use relation (labelled hlu) between module 1 and module A.
Now consider a similar ASDT representation shown in Figure 5 (c). Here module 3 calls function foo. Since ASDT supports this representation, we can assume that this representation is not at all uncommon in the software representations supported by the tool. Nevertheless, executing Fahmy Tool’s High Level Use service on this representation yields no lifted hlu relation.
In this second situation, the reasons why the results are not as expected are clear. Figure 3 shows that ASDT supports the representation of calls relationships between module and function entities. This representation is preserved when the ASDT inFilter maps them into the conceptual space. Figure 4 shows that Fahmy Tool only supports useproc relationships from module to module entities. The Fahmy Tool outFilter will not map into Fahmy Tool all the facts in the conceptual space originally from ASDT. It is at this point that information dilution occurs. As a result, the High Level Use service yields results that the user does not expect.
Information dilution is problematic because it appears that the integration ‘works’, but the results do not appear correct, even though they are. More troublesome is the possibility that no realization is made that information dilution has occurred. The real problem in the scenario we provide above is that the ASDT user was not warned that information dilution had occurred and consequently the results might not be as expected.

Discussion and Future Work
Perhaps the most difficult aspect to understand about an OASIS implementa- tion is the idea behind the ontology and the conceptual space that it defines. A schema typically defines the allowable characteristics for the information stored in a factbase instance. In OASIS, the domain ontology is a list of representational and service-related concepts that tools participating in the integration support. The domain ontology used in an OASIS implementa- tion is not a schema and it does not impose constraints on the conceptual space representation. The goal in OASIS is to identify conceptual equivalen- cies among the representations supported by the tool participants. When two




hlu


contains
contains
contains
contains










(a)
(b)
(c)


Fig. 5. High Level Use Service (Fahmy Tool)
tools support the same concept, the services that operate on those concepts can be effectively shared.
While the success of the OASIS proof of concept implementation is evi- dent, there is much work that can be done to improve the system. One major consideration is the expansion of the integration to include more tools. In particular, we are interested in exploring the integration of tools that operate at vastly differing levels of abstractive detail with respect to their represen- tations of software. Accommodating these tools would require a significant broadening in the range of concepts that the domain ontology would need to support. Our expectation is that as the ontology grows, so does its usefulness as a facilitator of integration among a wider array of reverse engineering tools. At the same time, augmenting the ontology in this manner would likely intro- duce a significant amount of detail that would make it much more difficult to manage.

Conclusion
The OASIS proof of concept implementation successfully demonstrated the feasibility of service-sharing as a means to facilitate the integration of infor- mation and services among a set of reverse engineering tools. It has also provided the opportunity to examine issues that arise as a result of the way an OASIS implementation is constructed. In this paper we have examined three areas of concern related to the factbase filtering process used by OASIS to manage the flow of information through the system. Further research is needed to further explore the impact these issues have on reverse engineering tool integration and system integration in general.

References
Cordy, J. R. and K. A. Schneider, “Architectural Design Recovery Using Source Transformation”, in: CASE’95 Workshop on Software Architecture, Toronto, 1995.
Ebert, J., B. Kullbach and A. Winter, “GraX – An Interchange Format for Reengineering Tools”, in: Proceedings of the 6th Working Conference on Reverse Engineering (WCRE’99) (1999), pp. 89–98.
Elmasri, R. and S. B. Navathe, “Fundamentals of Database Systems,” Addison-Wesley, 2000, 3rd edition.
Fahmy, H. M., R. C. Holt and J. R. Cordy, “Wins and Losses of Algebraic Transformations of Software Architectures”, in: Proceedings of the 16th IEEE International Conference on Automated Software Engineering (ASE’2001), San Diego, California, 2001.
Holt, R. C., “Structural Manipulations of Software Architecture Using Tarski Relational Algebra”, in: Proceedings of the 5th Working Conference on Reverse Engineering (WCRE’98), Honolulu, Hawaii, 1998.
Holt, R. C., A. Winter and A. Schu¨rr, “GXL: Toward a Standard Exchange Format”, in: Proceedings of the 7th Working Conference on Reverse Engineering (WCRE’00) Panel on Reengineering Exchange Formats (2000).
Jin, D., J. R. Cordy and T. R. Dean, “Transparent Reverse Engineering Tool Integration Using a Conceptual Transaction Adapter”, in: Proceedings of the 7th European Conference on Software Maintenance and Reengineering (CSMR 2003), Benevento, Italy, 2003, pp. 399–408.
Lamb, D. A. and K. A. Schneider, “Formalization of Information Hiding Design Methods”, in:
J. Botsford, A. Ryman, J. Slonim and D. Taylor, editors, Proceedings of the 1992 Centre for Advanced Studies Conference (CASCON’92), Toronto, Ontairo, 1992, pp. 201–214.
Mu¨ller, H. A., J. H. Jahnke, D. B. Smith, M.-A. Storey, S. R. Tilley and K. Wong, “Reverse Engineering: A Roadmap”, in: A. Finkelstein, editor, The Future of Software Engineering, International Conference on Software Engineering (ICSE’00) (2000).
Mu¨ller, H. A. and K. Klashinsky, “Rigi – A system for Programming-in-the-Large”, in: Proceedings of the International Conference on Software Engineering (ICSE’88), 1988, pp. 80–86.
Perelgut, S., “The Case for a Single Data Exchange Format”, in: Proceedings of the 7th Working Conference on Reverse Engineering (WCRE’00) (2000).
Rigi Group Home Page, URL: http://www.rigi.csc.uvic.ca/.
Sim, S. E., “Next Generation Data Interchange: Tool-to-Tool Application Program Interfaces”, in: Proceedings of the 7th Working Conference on Reverse Engineering (WCRE’00) (2000), pp. 278–283.
