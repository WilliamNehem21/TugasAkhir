Electronic Notes in Theoretical Computer Science 71 (2003)
URL: http://www.elsevier.nl/locate/entcs/volume71.html 20 pages


Outermost Ground Termination

Olivier Fissore 1, Isabelle Gnaedig 1, and H´el`ene Kirchner 1
LORIA-INRIA & LORIA-CNRS,
54506 Vandoeuvre-l`es-Nancy, BP 239 Cedex, France.


Abstract
We propose a semi-automatic inductive process to prove termination of outermost rewriting on ground term algebras. The method is based on an abstraction mech- anism, schematizing normalisation of subterms, and on narrowing, schematizing reductions on ground terms. The induction ordering is not needed a priori, but is a solution of constraints set along the proof. Our method applies in particular to systems that are non-terminating for the standard strategy nor even for the lazy strategy.
Key words: Rewriting, termination, outermost, strategy, rule based languages, induction, narrowing, ordering constraints


Introducing the problem
Termination of rewriting is a crucial problem in automated deduction, for equational logic, as well as in programming, for rule based languages. The property is important in itself, but it is also required to decide of properties like confluence and sufficient completeness, or to allow proofs by consistency. Most of existing methods for proving termination of term rewriting systems (TRS in short) essentially tackle the universal termination problem: they work on free term algebras and prove termination for standard rewriting (rewriting without any strategy). Many are based on syntactic or semantic noetherian orderings containing the rewriting relation induced by the TRS [15,7,20,3,8]. Other methods consist of transforming the termination problem of a TRS R into the termination problem of another TRS R', provable with techniques of the previous category. Examples are semantic labelling [25], and the depen- dency pair method [2].
In this paper, like in [16], we address the termination problem in the con- text of proof environments for rule-based programming languages, such as ASF+SDF [17], Maude [5], Cafe-OBJ [13], or ELAN [4], where a program is

1 Email: {fissore,gnaedig,Helene.Kirchner}@loria.fr
◯c 2003 Published by Elsevier Science B. V. Open access under CC BY-NC-ND license.


a term rewriting system and the evaluation of a query consists of rewriting a ground expression. In such a context, one needs more specific termination proof tools than those previously cited, allowing one to prove termination un- der specific reduction strategies. There are still few results in this domain, although the need is important. To our knowledge, methods have only been given for the innermost strategy [1,14], the context-sensitive rewriting includ- ing particular kinds of local strategies [21], and general local strategies [10].
The outermost strategy for evaluating expressions in the context of pro- gramming is essentially used when one knows that computations can be non- terminating. The intuition suggests that rewriting a term at the highest pos- sible position gives more chance than with another strategy to lead to an irreducible form. Indeed, outermost rewriting may succeed when innermost fails, as illustrated by the expression second(dec(1), 0), with the rewrite rules second(x, y) → y and dec(x) → dec(x − 1) on integers. Innermost rewriting fails to terminate, because it first evaluates dec(1) into dec(0), dec(−1), and so on.Outermost rewriting, however, gives 0 in one rewriting step.Moreover, out- ermost derivations are often shorter : in our example, to reduce second(u, v), one does not need to reduce u, which can lead to infinite computations or, at least, to a useless evaluation.This advantage makes the outermost strategy an interesting strategy for rule-based languages, by allowing the interpreters to be more efficient, as well as for theorem proving, by allowing the rewriting-based proofs to be shorter.
Outermost computations are of interest in particular for functional lan- guages like Miranda, Haskell, or Clean, where interpreters or compilers gener- ally involve a strategy for call by name.Often, lazy evaluation is used instead: labelling operators in terms as lazy or eager, it consists in reducing the ea- ger subterms only when their reduction allows a reduction step higher in the term [23].
However, lazy evaluation may diverge while the outermost computa- tion terminates, which gives an additional motivation for studying out- ermost termination. For instance, let us consider the evaluation of the expression inf (0) with the following two rules : cons(x, cons(y, z)) → big, inf (x)→ cons(x, inf (s(x))). Evaluated in a lazy manner, inf (0) is re- duced to cons(0, inf (s(0))), and then, since application of the first rule fails, the sub-expression inf (s(0)) has to be evaluated before considering the whole expression, which leads to an infinite evaluation. Evaluated in an outermost manner, inf (0) is also reduced to cons(0, inf (s(0))), but then inf (s(0)) is reduced to cons(s(0), inf (s(s(0)))), and then the whole expression is reduced to big.
Although not generally used with the rule-based evaluation process, the outermost strategy could be of interest for languages like Maude, OBJ or ELAN, for the previous efficiency reasons.A better knowledge of this strategy
w.r.t. more usual ones in this context, like the innermost or local strategies, would be interesting, and could help to choose the good one when program-

ming in these languages. Studying in particular the termination problem for these different strategies, we have pointed out the fact that it is distinct for the innermost, the outermost and the lazy strategies : termination for one of these strategies does not imply termination for any other of them [12].
Lazy termination of functional languages has already been studied (see for example [24]), but to our knowledge, no termination proof tool exists for specifically proving outermost termination of rewriting. We propose here a proof method for checking termination of outermost computations, even if rewriting without strategy or with other strategies diverges.
Our termination proof method for outermost rewriting on ground terms is based on an explicit induction mechanism on the termination property. The main idea is to use induction on the termination property in order to prove that any element t of a given set of terms T terminates, i.e. there is no infinite derivation chain starting from t.So this approach needs a noetherian ordering on terms used in the induction principle. Unlike classical induction proofs, where the ordering is given, we do not need to define it a priori.We only have to check its existence by ensuring satisfiability of ordering constraints incre- mentally set along the termination proof. Thanks to the power of induction, the generated constraints are often simple to solve.
The method is based on an abstraction mechanism, schematizing normal- ization of subterms, and on narrowing, schematizing reductions on ground terms. It is semi-automatic : it can stop with success, then establishing out- ermost termination of a given TRS ; it can stop with failure or diverge, in which case nothing can be concluded about termination. Constraints solving can be handled by the procedure itself, or can be left to the user or delegated to external automatic constraint solvers.
In section 2, the background is presented. Section 3 introduces the basic concepts of our inductive proof mechanism.Section 4 builds on these concepts to propose a proof technique for outermost termination. Proofs can be found in [12].

The background
We assume that the reader is familiar with the basic definitions and notations of term rewriting given for instance in [9]. T (F, X ) is the set of terms built from a given finite set F of function symbols f having arity n ∈ N, and a set X of variables denoted x,y .. .. T (F) is the set of ground terms (without variables). The terms composed by a symbol of arity 0 are called constants. Positions in a term are represented as sequences of integers. The empty se- quence ϵ denotes the top position.Let p and p' be two positions.The position p is said to be (a strict) prefix of p' (and p' suffix of p) iff p' = pλ, where λ is a non-empty sequence of integers. Given a term t, V ar(t) is the set of variables of t, O(t) is the set of positions of t, inductively defined as follows: O(t) = {ϵ} if t ∈ X, O(t) = {ϵ}∪ {i.p | 1 ≤ i ≤ n and p ∈ O(ti)} if t =

f (t1,..., tn).We denote OV (t) the set of variable positions in t.The notation t|p stands for the subterm of t at position p. If p ∈ O(t), then t[t']p denotes the term obtained from t by replacing the subterm at position p by the term t'.
A substitution is an assignment from X to T (F, X ), written σ = (x '→ t) ... (y '→ u).It uniquely extends to an endomorphism of T (F, X ).We iden- tify a substitution σ = (x '→ t) ... (y '→ u) with the finite set of equations (x = t) ∧ ... ∧ (y = u). The result of applying σ to a term t ∈ T (F, X ) is written σ(t) or σt. The domain of σ, denoted Dom(σ) is the finite sub- set of X such that σx /= x. The range of σ, denoted Ran(σ), is defined by Ran(σ)= x∈Dom(σ) V ar(σx).We have in addition Dom(σ) ∩ Ran(σ)= ∅.A ground substitution or instantiation is an assignment from X to T (F). The composition of substitutions σ1 followed by σ2 is denoted σ2σ1. Given two substitutions σ1 and σ2, we write σ1 ≤ σ2[X] iff ∃θ such that σ2 = θσ1[X] i.e.
∀x ∈ X, σ2x = θσ1x (σ1 is said more general than σ2).Given a subset X1 of X , we write σX1 for the restriction of σ to the variables of X1, i.e. the substitution such that Dom(σX1 ) ⊆ X1 and ∀x ∈ Dom(σX1 ): σX1 x = σx.
Given a set R of rewrite rules (a set of pairs of terms of T (F, X ), denoted
l → r, such that V ar(r) ⊆ V ar(l)) or term rewriting system on T (F, X ), a function symbol in F is called a constructor iff it does not occur in R at the top position of the left-hand side of a rule, and is called a defined function symbol otherwise.The set of defined function symbols of F for R is denoted by Def R (R is omitted when there is no ambiguity).The rewriting relation induced by R is denoted by →R (→ if there is no ambiguity on R), and defined by s → t iff there exists a substitution σ and a position p in s such that s|p = σl for some rule l → r of R, and t = s[σr]p.This is written s →p,l→r,σ t where either p or l → r or σ may be omitted; s|p is called a redex. The transitive (resp. reflexive transitive) closure of the rewriting relation induced by R is denoted
by →+ (resp. →∗ ). If t →∗ t' and t' cannot be rewritten anymore, then t' is
called a normal form of t and denoted by t↓.Remark that given t, t↓ may be
not unique.
An ordering > on T (F, X ) is said to be noetherian iff there is no infinite decreasing chain for this ordering. It is F-stable iff for any pair of terms t, t' of T (F, X ), for any context f (... .. .), t > t' implies f (...t.. .) > f (... t' .. .). It has the subterm property iff for any t of T (F, X ), f (...t.. .) > t. Observe that, for F and X finite, if > is F-stable and has the subterm property, then it is noetherian [19]. If, in addition, > is stable by substitution (for any substitution σ, any pair of terms t, t' ∈ T (F, X ), t > t' implies σt > σt'), then it is called a simplification ordering.Let t be a term of T (F); let us recall that t terminates iff every rewriting derivation (or derivation chain) starting from t is finite.
We say that s outermost rewrites into t at position p, which is written

s →out
t iff s rewrites into t at position p and there is no prefix position p'

of p such that s rewrites at position p'. Let t be a term of T (F); like for the

standard rewriting, we say that t outermost terminates iff every outermost rewriting derivation starting from t is finite. From now on, t↓ denotes an outermost (rewriting) normal form of t.
Let us now recall the definition of narrowing.Let R be a TRS on T (F, X ). A term t is narrowed into t', at the non-variable position p, using the rewrite rule l → r of R and the substitution σ, iff σ is a most general unifier of t|p and l, and t' = σ(t[r]p). This is denoted t ❀p,l→r,σ t' where either p, or l → r or σ may be omitted. It is always assumed that there is no variable in common between the rule and the term, i.e. that V ar(l) ∩ V ar(t)= ∅.
The requirement of disjoint variables is easily fulfilled by an appropriate renaming of variables in the rules when narrowing is performed.Observe that for the most general unifier σ used in the above definition, Dom(σ) ⊆ V ar(l)∪ V ar(t) and we can choose Ran(σ) ∩ (V ar(l) ∪ V ar(t)) = ∅, thus introducing in the range of σ only fresh variables.

Induction for termination
The main intuition is to observe the outermost rewriting derivation tree start- ing from a ground term t which is an instance of a term g(x1,..., xm), for some defined function symbol g ∈ Def , and variables x1,..., xm.Proving ter- mination on ground terms amounts to prove that all these outermost rewriting derivation trees have only finite branches.
For proving that every term t of T (F) outermost terminates, we proceed by induction on T (F) with a noetherian ordering >, assuming that for any t' such that t > t', t' outermost terminates.We first prove that a basic set of minimal elements for > outermost terminates. As we will see, it is natural to suppose termination of subterms to prove termination of the terms themselves.So the subterm property for > is required, and then the set of minimal elements for
> is a subset of the set of constants of F. We then simulate the rewriting derivation trees starting from any instance of g(x1,..., xm), for all g ∈ Def , for proving that all branches are finite.
Each derivation tree is simulated by a proof tree starting from g(x1,..., xm), and developed by alternatively using two main concepts, namely narrowing and abstraction. More precisely, narrowing schematizes, thanks to all possible narrowing unifiers, all outermost rewriting possibilities of the ground terms in the derivations. The abstraction process simulates the nor- malization of subterms in the derivations, according to the outermost strategy. This abstraction step is performed on subterms that can be assumed outer- most terminating by induction hypothesis.
So the proof process amounts to develop abstract trees whose nodes are composed of a current term that may have variables, and a set of ground substitutions appropriately represented by a constraint. This constraint re- sults from the conjunction of the successive unifiers used for narrowing, from g(x1,..., xm) to the current term. Each node schematizes a possibly empty

set of ground terms, namely all instances of the current term given by substi- tutions that are ground solutions of the constraint.
Obviously, the induction ordering > has to be the same along the proof : for all branches in each abstract tree with a root g(x1,..., xm),g ∈ Ðef , and for all abstract trees.It is however important to point out the flexibility of the proof method that allows the combination with auxiliary termination proofs using a different technique: when the induction hypothesis cannot be applied on a term u, it is sometimes possible to prove outermost termination of every ground instance of u by another way.In the following, we will use a predicate TERMIN (u) that is true iff every ground instance of u outermost terminates. The termination proof procedure given in this paper is described by a set of inference rules applied with a special strategy S.To prove termination of Y on every term t ∈7 (J) we proceed as follows: for each defined symbol g ∈ Ðef , we consider a so-called reference term tref = g(x1,..., xm) and a trivial set of constraints denoted T. Applying the rules according to the strategy S to the initial state ({g(x1,..., xm)}, T) builds a proof tree, whose nodes are the states produced by the inference rules.Branching is obtained by the different narrowing steps for all possible rewrite rules. Different kinds of constraints occur: equality, disequality and reduction constraints during the process and
ordering constraints at the end of the process.
As said before, there are three cases for the behavior of the termination proof procedure. The good case is when the strategy terminates because the rules do not apply anymore and all terminal states of all proof trees have an empty set of terms.The strategy can also stop with failure, when the rules do not apply anymore on states having non empty sets of terms. Finally, it may not terminate if there is an infinite number of applications of rules on one of the reference terms.In the last two cases, we cannot conclude anything about termination.
Outermost termination
Let us reconsider the previous ideas in a more detailed way. Consider the following example, that is outermost terminating, but not terminating for the standard rewriting relation, nor for the innermost strategy, nor even for the lazy evaluation strategy.
f (g(a)) → a
f (f (x)) → b
g(x)	→ f (g(x))
Let us first prove “by hand” that Y is outermost terminating on 7 (J) (J = {f : 1,g : 1,a : 0,b : 0}) in the following way. First, consider the constants a and b: they are obviously outermost terminating. Let us then

study the termination of the ground terms of the form f (t). If t = g(a), f (t) outermost rewrites into a, which is in normal form. Similarly, if t is of the form f (t'), f (t) rewrites into b. Otherwise, f (t) is not reducible at the top position. Using an ordering > with the subterm property as induction ordering, we get f (t) > t. So, by induction hypothesis, we assume that t outermost terminates.Now, either t is irreducible, and then, since f (t) is not reducible at the top position, f (t) is in normal form, or t normalizes into t↓. Let t' be any intermediate term of the outermost reduction chain from t to t↓. Either f (t') is outermost reducible at the top position into a or b, or the outermost redex is in t'. In the second case, t' is reduced into another intermediate term, on which we can apply the same reasoning.As t is supposed to be terminating, the number of intermediate terms is finite, which allows to conclude that f (t) outermost terminates. We finally study the termination of the ground terms of the form g(t). Any ground term of the form g(t) first rewrites into f (g(t)).Then, if t = a, f (g(t)) normalizes into a.If t /= a, f (g(t)) outermost rewrites into f (f (g(t))) at position 1 with the third rule. Finally, the obtained term rewrites into b with the second rule, which ends the proof. Let us show how to formalize and automate such a reasoning with narrow-
ing and abstraction.

Induction
As said previously, we observe the outermost rewriting derivation trees starting from tref = g(x1,..., xm), for every g ∈ J, where x1,..., xm are variables that can be instantiated by any ground term. The outermost rewriting relation is simulated by narrowing and abstracting as follows:
First, we observe outermost rewriting from g(x1,..., xm), following the pos- sible values of x1,..., xm, either on top directly or on top after reduction of subterms.Indeed, any ground instance of g(x1,..., xm) may be reducible on top directly or after outermost reductions of its subterm instances of variables x1,..., xm.
So to precisely modelize the outermost rewriting relation on ground terms, we first have to replace x1,..., xm by new and all different variables x' ,..., 
' defined as follows.Given any ground instance αg(x1,..., xm) of g(x1,..., 
xm), the x' ,..., x' represent the first reduced form of αx1,..., αxm gener-
1	m
ating an outermost reduction higher in the term (here, at the top), in any
outermost rewriting chain starting from αg(x1,..., xm).
We memorize this replacement and we apply a step of outermost nar-

rowing to g(x' , ..., x'
) in all possible ways, to get terms v. This is the

1	m
narrowing step.
Then the idea is to apply the induction hypothesis as efficiently as possible on each resulting narrowed term v.For that we try to apply this induction hypothesis to the “smallest“ (w.r.t. the size) subterms vi of v, replacing them by a variable yi, representing any of its normal forms. Indeed, when

the vi are smaller, there is more chance to satisfy the ordering constraints
tref > vi.
According to the outermost strategy, this can be done only if during their normalization, the vi do not introduce outermost redexes higher in the term v.More formally, the induction hypothesis is applied to the subterms v|p1 ,..., v|pn of the current terms v, provided αt > αv|p1 ,..., αv|pn for every ground substitution α, for the induction ordering > and provided s = v[y1]p1
... [yn]pn is not narrowable for the outermost narrowing relation, defined
below. This implies that every ground instance of the term s outermost terminates.This is the abstracting step, which is a final step on the branches of the proof tree it applies on.If v cannot be abstracted, we attempt again a narrowing step.
Our mechanism also includes the case where the induction hypothesis can directly be applied on the current term v, when αtref > αv for every ground substitution α, which ends the proof on the branch of v, since every deriva- tion starting from v in the derivation tree of t is supposed to terminate by induction.In fact, this case is a particular case of the abstracting step. 
Outermost narrowing
We first formally define the variable replacement performed before a narrowing step.
Definition 4.1 Let t ∈7 (J, X ) be a term whose variable occurrences from left to right in t are x1,..., xm. The reduction renaming of t consists in re- placing the xi by new and all different variables x' in t, and is denoted by the

so called reduction formula
R(t)= (x1 →∗ x' ,..., xm →∗ x'

)[t].

1	m
The result of the reduction renaming applied to t is denoted Ren(t).
Satisfaction of the reduction formulas is given in such a way that we simu- late the outermost reduction relation by alternatively using reduction renam- ing and narrowing steps.
Definition 4.2 Let t ∈7 (J, X ) be a term whose variable occurrences from left to right are x1,..., xm, at positions p1,..., pm respectively.A ground sub-

stitution θ satisfies the reduction formula R(t)= (x1 →∗ x' ,..., xm →∗ x'
)[t]

1	m
iff there exists an outermost rewriting chain starting from θt, such that either

t[θx' ]p
... [θx'
]pm
is the first reduced form of θt = t[θx1]p1
... [θxm]pm
on this

chain having an outermost rewriting position at a non variable position of t,

if this position exists, or θx'
= (θx1↓),..., θx'
= (θxm↓) if there is no such

position.
Before going on, a few remarks on this definition can be made. In the second case of satisfiability, t[θx1↓]1 ... [θxm↓]m is in normal form. More- over, R(t) is always satisfiable : it is sufficient to take a ground substitu-

tion θ such that t[θx1]p1 ... [θxm]pm has an outermost rewriting position at a non variable position of t, and then to extend its domain {x1,..., xm} to
{x1,..., xm, x' ,..., x' } by choosing for each i ∈ {1, ..., m}, θx' = θxi.If such
1	m	i
a substitution does not exist, then every ground instance of t has no outermost
rewriting position at a non variable position of t, and it is sufficient to take

a ground substitution θ such that θx1 = ... = θxm = θx'
= ... = θx'
= u,

with u any ground term in normal form.
However, there may exist several substitutions solution of such constraints. Let us consider for instance the rewrite system R = {f (a) → f (c),b → a} and the reduction formula R(f (x)) = (x →∗ x')[f (x)]. The substitution θ1(x) = θ1(x') = a and θ2(x) = b, θ2(x') = a are two distinct solutions. With the substitution θ2, f (a) is the first reduced form of f (b) having an outermost rewriting position at a non variable position of f (x) (here at top).
Finally, quite often, the reduction formula is reducible to a simple renam- ing. Let t ∈ 7 (J, X ) be a term whose variables are x1,..., xm, at positions

p1,..., pm respectively. Let us consider R(t) = (x1 →∗ x' ,..., xm →∗ x'
)[t]

1	m
and let us denote It = {i ∈ [1..m]|t outermost rewrites at a prefix position
p' of pi}. Then R(t) is equivalent (in the sense that the same set of ground
i
'
satisfying R(t), for any i ∈ It, t[θx1]p1 ... [θxi]pi ... [θxm]pm has at least one outermost rewriting position at a non variable position of t : the position p'
or a prefix position of p' .Then we have θx' = θxi.
i	i
To illustrate this, let us consider the system {g(x) → x, f (x, x) → x}
(the right-hand sides of the rules are not important here), and the reduc- tion formula R(f (x, g(y))) = (x →∗ x',y →∗ y')[f (x, g(y))]. Then, since f (x, g(y)) outermost rewrites at the position of g, R(f (x, g(y))) is equiva- lent to R'(f (x, g(y))) = (x →∗ x')[f (x, g(y))] ∧ y = y'. Indeed, whatever the ground instance θy, the term g(θy) outermost rewrites only at the top posi- tion, and there is no outermost reduction of θy.Then, following Definition 4.2,
θy' = θy. Finally, note that if It = {1,..., m}, then R(t) is equivalent to the
renaming Vm xi = x' , where the xi are the variable occurrences from left to
right in t.
To schematize outermost rewriting on ground terms, we need to introduce a new specific narrowing relation.
Definition 4.3 A term t ∈ 7 (J, X ) outermost narrows into a term t' ∈ 7 (J, X ) at the non-variable position p, using the rule l → r ∈ Y with the
most general unifier σ, which is written t ❀out	t' iff
σ(l)= σ(t|p) and
t' = σ(t[r]p) and
there exist no prefix position p' of p, no rule l' → r' of Y and no substi- tution σ such that σ can unify σt|p' and l .
It is always assumed that there is no variable in common between the rule

and the term, i.e. that V ar(l) ∩ V ar(t)= ∅.
The third point of the above definition does not appear in the classical definition of narrowing. This special condition is needed here to define an outermost narrowing mechanism modeling the outermost rewriting relation on ground terms.
The outermost narrowing steps applying to a given term t are computed in the following way. We look at every position p of t such that t|p unifies with the left-hand side of a rule using a substitution σ. The position p is an outermost narrowing position of t, according to Definition 4.3, iff there is no prefix position p of t such that σt|p' unifies with a left-hand side of rule.Then we look for every prefix position p of p in t such that σt|p' narrows with some substitutions σ' and some rule l' → r', and we set a constraint to exclude these substitutions.
Let us consider the previous system {f (g(a)) → a, f (f (x)) → b, g(x) → f (g(x))}. With the standard narrowing relation used at the outermost po- sition, f (g(x1)) only narrows into a with the first rule and the substitution σ = (x1 = a).With the outermost narrowing relation defined above, f (g(x1)) narrows into a with the first rule and σ = (x1 = a), and into f (f (g(x2))) with the third rule and the substitution σ = (x1 = x2 Λ x' = x2) satisfying the disequality x2 /= a. Observe that x' comes from the renaming of variables in the rule.
As illustrated by this example, the substitutions used to narrow a term according to Definition 4.3 have in general to satisfy a set of disequalities. To make this remark precise, we need a few notations and definitions.
Let σ be a substitution on 7 (J, X ) identified with the formula Vi(xi = ti),
with xi ∈ X , ti ∈7 (J, X ), and where = is the syntactic equality. We denote by σ the formula i(xi /= ti).
Definition 4.4 A substitution σ Vis sWaid to satisfy a formula Vi Wji (xji /= tji ),
During the proof process, we memorize the previously defined reduction re- namings of variables and the substitutions satisfying disequalities (also called constrained substitutions) used in the successive narrowing steps in a substi- tution constraint formula.
Definition 4.5 A substitution constraint formula (SCF for short) is a for-

mula V (xl
→∗ x' ,..., xl
→∗ x'
)[ul] V (xi = ti) V (W
xk  /= tk ), with

xl , x' ..., xl  , x' , xi, xk  ∈ X, ti, tk
∈ 7 (J, X ). The empty formula is de-

1	l1	m	lm	j	j
noted T.
Then the nodes of the proof trees are composed of a current term, and a set of ground substitutions represented by a substitution constraint formula.Each node schematizes a possibly empty set of ground terms, namely all instances of the current term given by substitutions that are ground solutions of the substitution constraint formula.

Definition 4.6 A substitution constraint formula

V (xl
→∗ x' ,..., xl
→∗ x'
)[ul] V (xi = ti) V (W
xk	/= tk ) is said to

be sVatisWﬁable iff there exists at least onVe instantiation θ such that Vi(θxi =
In practice, one can solve the equality and disequality part of the constraint and then check whether the solution θ satisfies the reduction formulas. This is trivial in cases where θ only instantiates the x' , since it can be extended by setting θ(xi)= θ(x' ).Unfortunately, when θ also instantiates the xi, we get an undecidable problem: given two ground terms t and t', can t be transformed into t' by repeated application of a given set of rewriting rules?
But fortunately, our process is sound even when inference rules are applied on nodes of the proof tree representing empty sets of terms [12]. So in the narrowing step, we do not attempt to check satisfiability of the constraints.
Nevertheless, we keep trace of the cumulated constraints along a branch of narrowing steps. If at any point, the constraints can be shown unsatisfiable, then the branch can be cut.
For the abstraction step, the satisfiability of an SCF has to be combined with the satisfiability of ordering constraints.
Definition 4.7 Let t, u1,..., um ∈ 7 (J, X ) and Σ an SCF. The constraint (Σ,t > u1,..., um) is said to be satisfiable iff there exists an J-stable order- ing > on 7 (J) having the subterm property such that θt > θui,i ∈ [1..m], for every ground substitution θ satisfying Σ, and whose domain contains the variables of t and of the ui,i ∈ [1..m]. Such an ordering > is said to satisfy (Σ,t > u1,..., um).
The satisfiability of (Σ,t > u1,..., um) is undecidable. But a sufficient condition for an ordering > to satisfy this constraint is that > is stable by substitution (the induction ordering is then a simplification ordering) and t > u1,..., um.Remark that consequently, (Σ,t > u1,..., um) may be proved satisfiable, even if Σ is not.
As said before, we store in an SCF Σ the reduction renamings of variables performed before the narrowing steps and the constrained substitutions used at each narrowing step, for unifying the current term u with a left-hand side of rule l, and whose domain is V ar(u)∪V ar(l).However, since V ar(u)∩V ar(l)= 
∅, we do not need to know the information related to the variables occurring in l because we are only interested by the transformations applied on u. So only the restriction of σ to V ar(u) and the negation of the restriction of each σ' (see Definition 4.3) to V ar(σu), respectively denoted σV ar(u) and σ'V ar(σu), are stored in Σ.
Abstraction
Let us now formalize our abstracting mechanism. The abstraction of a term
u relies on the concept of generalization.

Definition 4.8 A term t ∈7 (J, X ) is a generalization of u ∈7 (J, X ) iff u is an instance of t (i.e. ∃σ such that σt = u).Given two generalizations s and t of a term u, t is said to be greater than s iff s is a generalization of t. The generalization t is called linear generalization if t is linear.
Then, abstracting a term u consists of finding the greatest linear general- ization t with variables at positions p1,..., pm such that
the induction hypothesis applies to the u|pi , i.e. (Σ, tref > u|p1 ,..., u|pm ) is satisfiable,
the generalization t = u[y1]p1 ... [ym]pm , where y1,..., ym are fresh distinct variables, is not narrowable.
The following obvious lemma allows us to conclude on termination of any ground instance of u, if u can be abstracted into a term t.
Lemma 4.9 Let u ∈7 (J, X ). Let t be a generalization of u, and {p1,..., pm}
be the set of variable positions in t. If t is not narrowable, then:
in every ground instance of t,the only redex positions are suﬃxes of pi,i ∈
[1 ... m],
consequently, if all ground instances of u|p1 ,..., u|pm outermost termi- nate, then every ground instance of u outermost terminates.
Inference rules
The inference rules for outermost termination, given in Table 1, work on pairs (T, Σ), where:
T is a set of terms of 7 (J, X ), containing the current term whose ground instances have to be proved outermost terminating.This is either a singleton or the empty set.
Σ is an SCF, enriched by the formulas expressing the reduction renaming of the variables of the terms to be narrowed and a new constrained substitution each time a narrowing step is performed.
The inference rules work as follows:
The narrowing step is expressed by a rule Narrow applying on ({u}, Σ): the variables of u are renamed as specified in Definition 4.1. Then Ren(u) is outermost narrowed in all possible ways in one step, with all possible rewrite rules of the rewrite system Y, into terms v. For any possible v, ({u}, Σ) is rVeplaced by ({v}, Σ Λ R(u) Λ σV ar(Ren(u)) i σ'i V ar(σRen(u))) where
tion allowing outermost narrowing of Ren(u) into v.
The abstracting step is expressed by a rule Abstract applying on ({u}, Σ): we look for the greatest possible generalization t of the current term u, such as required in Section 4.3. If (Σ, tref > u|p1 ,..., u|pk ) is satisfiable for {p1,..., pk} ⊆ OV (t) and TERMIN (u|i) for i ∈ OV (t) \ {p1,..., pk}


Table 1
Inference rules for outermost tref -termination


then, by induction hypothesis in the first case, and by hypothesis in the second one, all ground instances of u|p1 ,..., u|pk and of the u|i terminate. By Lemma 4.9, every ground instance of u outermost terminates, which ends the proof on the current derivation chain. So ({u}, Σ) is replaced by (∅, Σ).
As said before, we also can test for the current term u, whether (Σ, tref > u) is satisfiable or TERMIN (u).Then, as previously, by induction hypothesis or by hypothesis, every ground instance of u outermost terminates, which also ends the proof on the current derivation chain.This is a particular case of the rule Abstract, where the generalization of u is a variable y.
For establishing that TERMIN (u) is true, in some cases, the notion of usable rules, proposed in [1], can be used. Given a TRS Y on 7 (J, X ) and a term u ∈7 (J, X ), the usable rules are defined as a computable superset of the rewrite rules, that may apply to any ground instance of u, for the standard rewriting relation, until its ground normal form is reached, if it exists.Proving termination of any ground instance of u then comes down to proving termi- nation of its usable rules, which is often much easier than orienting the whole TRS. The usable rules can be proved terminating with classical termination methods like simplification orderings - we then obtain termination of the stan- dard rewriting relation, which implies outermost termination of u - or with our inductive method itself : we then directly prove outermost termination of u. An interesting point of this method is that the ordering used to prove termination of the usable rules, either with classical methods or inductively, is completely independent of the main induction ordering. Remark that the case where the initial TRS can be proved terminating with other well known methods (orienting rules by a simplification ordering or using dependency pairs) is taken into account with our method: the usable rules of the first term

g(x1,..., xm) of any proof tree consist of the initial whole TRS, and then the previously mentioned methods can be used to prove their termination.
Remark also that for proving termination of the constants, usable rules can also be used. The notion of usable rules, their computation and their properties are fully developed in [14].
According to the remark following Definition 4.2, the reduction formulas in Σ may be reduced to simple variable renamings. In this case, Σ only con- tains variable renamings and constrained substitutions, that can be used to show that the ordering constraint needed to apply Abstract is satisfiable (see Examples B.1 and B.4 in [12]). The following lemma can also be established. It enables to apply Abstract when the current term is either a variable, or a non narrowable term.
Lemma 4.10 Let ({ti}, Σi) be the ith state of any branch of the derivation tree obtained by applying the strategy S on ({tref }, T), and > an J-stable ordering having the subterm property. If every reduction formula in Σi can be
reduced to a formula Vj xj = x , then we have:
'

6x ∈ V ar(ti): (Σi, tref > x) is satisﬁable by >.
To prove outermost termination of Y on every term t ∈ 7 (J), for each defined symbol g ∈ Ðef , we apply the rules on the initial set of terms T = {tref = g(x1,..., xm)} and the trivial constraint T. These rules must be applied with the strategy S: try to apply Abstract. If Abstract does not apply, then apply Narrow.Then repeat the process until no rule applies anymore.
Let us emphasize some important points about the inference rules:
Narrow is a non-deterministic rule that can produce several results: it is applied with all possible rewrite rules at all outermost positions.
After Abstract, no rule applies anymore.
The three cases for the behavior of the termination proof procedure can now be described more precisely. The strategy applied to the initial state ({tref }, T) may stop with states having non empty sets of terms, it may not terminate if there is an infinite number of applications of Narrow.The good case is when the strategy terminates because the rules do not apply anymore and all states are of the form (∅, Σ).
Let us write SUCCESS(g, >) iff the application of the inference rules on ({g(x1,..., xm)}, T), whose conditions are satisfied by >, gives a state of the form (∅, Σ) at the end of all branches of the derivation tree.We then can state the main result.
Theorem 4.11 Let Y be a TRS on 7 (J, X ), such that the constants of J are outermost terminating. If there exists an J-stable ordering > hav- ing the subterm property, such that for each non-constant deﬁned symbol g, SUCCESS(g, >), then every term of 7 (J) outermost terminates.

We now develop examples, giving the states of the proof trees. Other ex- amples can be found in [12].




Example 4.12 Consider the previous example Y  =  {f (g(a))  → a, f (f (x)) → b, g(x) → f (g(x))}, that is outermost terminating, but not ter- minating for the standard rewriting relation. We prove that Y is outermost terminating on 7 (J) where J = {f : 1,g : 1,a : 0,b : 0}.
The defined symbols of J for Y are f and g.Applying the rules on f (x1), we get:




f (x1)
Σ= T¸¸

uuuu
Narrowuuuu uuu
a
¸¸¸
¸¸N¸ arrow
¸z%
b

Σ= ((x1 →∗ x' )[f (x1)]
Σ= ((x →∗ x' )[f (x )]

1	1	1	1

Λ x'
= g(a))
Λ x' = f (x2))

(σ = (x' = g(a)))
(σ = (x' = f (x ) Λ x' = x ))

1
Abstract
J²
1	2	2
Abstract
J²

∅
Σ= ((x1 →∗ x' )[f (x1)]
∅
Σ= ((x1 →∗ x' )[f (x1)]

Λ x'
= g(a))
Λ x'
= f (x2))





The variable x' comes from the renaming of x in the left-hand side of rule. For the first Abstract, a is generalized into x3, since (Σ,f(x1) > a) is satisfi- able by a Lexicographic Path Ordering (LPO in short) > with the precedence (ordering on J) f >F a. For the second Abstract, b is generalized into x4, since (Σ,f(x1) > b) is satisfiable by the previous LPO with the additional precedence f >F b. We recall that the induction ordering has to be the same for all the branches of all the derivation trees.
Applying the rules on g(x1), we get:



g(x1) Σ= T

Narrow
J²
f (g(x' ))
Σ= ((x1 →∗ x' )[g(x1)]) (σ = (x' = x' ))

.....
Narro.w...
....
a
¸¸¸
¸¸N¸ arrow
¸z&


f (f (g(x'')))

Σ= ((x
→∗ x' )[g(x )]
Σ= ((x1 →∗ x' )[g(x1)]

1	1	1
1
'	∗	'

Λ (x' →∗ x'')[f (g(x' ))]
Λ (x1 →  x'')[f (g(x ))]

1	1	1
Λ x'' = a)
''
1	1
Λ x'' /= a)
(σ = (x'' = x'')

(σ = (x1 = a))	''	1


Abstract

J²
∅
satisfies (x1 /= a))
Narrow
J²
b
Σ= ((x1 →∗ x' )[g(x1)]

Σ= ((x1 →∗ x' )[g(x1)]
Λ (x'
→∗ x'')[f (g(x' ))]

1	1	1	1

Λ (x' →∗ x'')[f (g(x' ))]
Λ (x'' →∗ x''')[f (f (g(x'')))]

1	1	1
Λ x'' = a)
1	1	1
Λ x'' /= a)

(σ = (x''' = g(x''')))
Abstract
J²
∅
Σ= ((x1 →∗ x' )[g(x1)]
Λ (x' →∗ x'')[f (g(x' ))]
1	1	1
Λ (x'' →∗ x''')[f (f (g(x'')))]
1	1	1
Λ x'' /= a)
Abstract is applied on a and b with the previous LPO with the extra precedence g >F a, b.When narrowing f (g(x' )), we first try the top position, and find a possible unification with the first rule (the left branch). One also must consider the third rule if x'' is such that x'' /= a; thus, if x'' /= a, f (g(x''))
1	1	1	1
is narrowed at position 1 with the third rule (second branch).
Example 4.13 Let Y be the TRS cited in the introduction, built on J =
{cons : 2, inf : 1, big : 0} :
cons(x, cons(y, z)) → big
inf (x)	→ cons(x, inf (s(x)))
Applying the inference rules on inf (x1), we get :


inf (x1) Σ= T

Narrow
J²
cons(x' , inf (s(x' )))
1	1
Σ= ((x1 →∗ x' )[inf (x1)]) (σ = (x' = x' ))
JN a²rrow
cons(x'', cons(s(x'''), inf (s(s(x''')))))
1	1	1
Σ= ((x1 →∗ x' )[inf (x1)]

Λ (x'
→∗ x'', x'
→∗ x''')[cons(x' , inf (s(x' )))])

1	1	1	1	1	1
(σ = (x'' = s(x''')))

JN a²rrow
big
Σ= ((x1 →∗ x' )[inf (x1)]

Λ (x'
→∗ x'', x'
→∗ x''')[cons(x' , inf (s(x' )))]

1	1	1	1	1	1
Λ (x'' →∗ x(iv), x''' →∗ x(v), x''' →∗ x(vi))
1	1	1	1	1	1
[cons(x'', cons(s(x'''), inf (s(s(x''')))))])
1	1	1
(σ = (x''' = x(iv) Λ y' = s(x(v)) Λ z' = inf (s(s(x(vi))))))
1	1	1
Abstract
J²
∅
Σ= ((x1 →∗ x' )[inf (x1)]

Λ (x'
→∗ x'', x'
→∗ x''')[cons(x' , inf (s(x' )))]

1	1	1	1	1	1
Λ (x'' →∗ x(iv), x''' →∗ x(v), x''' →∗ x(vi))
1	1	1	1	1	1
[cons(x'', cons(s(x'''), inf (s(s(x''')))))])
1	1	1
Applying the inference rules on cons(x1, x2), we get :
cons(x1, x2) Σ= T


JN a²rrow
big
Σ= ((x1 →∗ x' , x2 →∗ x' )[cons(x1, x2)]
1	2
Λ x' = cons(x3, x4))

(σ = (x'
= cons(x3, x4) Λ x' = x'
Λ y' = x3 Λ z' = x4))

Abstract
J²
∅
Σ= ((x1 →∗ x' , x2 →∗ x' )[cons(x1, x2)]
1	2
Λ x' = cons(x3, x4))

Conclusion and perspectives
In this paper, we have proposed a method to prove outermost termination of term rewriting systems by explicit induction on the termination property. Our method works on the ground term algebra using as induction relation an J-stable ordering having the subterm property. The general proof principle relies on the simple idea that for establishing termination of a ground term t, it is enough to suppose that subterms of t are smaller than t for this ordering, and that rewriting the context leads to terminating chains.Iterating this pro- cess until obtaining a context which is not reducible anymore establishes the termination of t.
An important point to automate our proof principle is the satisfaction of the ordering constraints. On many examples, this is immediate: since the ordering constraints only express the subterm property, they are trivially sat- isfied by any simplification ordering, so we do not need any ordering constraint solver.Elsewhere, we can use an ordering constraint solver as CiME [6].
Up to our knowledge, our algorithm is the first automated method for prov- ing outermost termination of non-terminating systems, and whose generality allows covering other reduction strategies.
Indeed, our process, based on narrowing and abstraction, can also be ex- tended to other strategies. We recently have proposed inference rules for the innermost strategy [14], and for local strategies on operators [10], as they are used in OBJ3, CafeOBJ or Maude.Note that the leftmost innermost strategy can be expressed by local strategies, and, as shown in [18], the termination problem of leftmost innermost rewriting is equivalent to the termination prob- lem of innermost rewriting. So our termination procedure for local strategies holds for proving innermost termination.On the contrary, the outermost strat- egy cannot be expressed by local strategies.Indeed, strategies like innermost, lazy or local strategies are intrinsically recursive in the sense that, during the evaluation, subterms have to be completely evaluated (i.e. normalized) before the whole term is reduced. This is not the case for the outermost evaluation. The termination procedure proposed in this paper is thus specific to the out- ermost case.With respect to innermost or local strategies, the order in which narrowing and abstraction apply is changed.Moreover, the narrowing process itself had to be adapted to suitably schematize outermost rewriting on ground terms. This led us to define and deal with specific appropriate constraints, different from those of the innermost and local strategy cases.
Since our induction principle is based on the rewriting relation itself, the extension to the associative-commutative case, as well as to the typed case seems to be easy.
We recently have implemented the algorithm proposed in this paper.This implementation is integrated in CARIBOO [11], a tool recently proposed for proving termination of rewriting under strategies, in which our inductive pro- cedures for the innermost and local strategies are also implemented.

References
T. Arts and J. Giesl. Proving innermost normalization automatically. Technical Report 96/39, Technische Hochschule Darmstadt, Germany, 1996.
T. Arts and J. Giesl. Termination of term rewriting using dependency pairs.
Theoretical Computer Science, 236:133–178, 2000.
A. Ben Cherifa and P. Lescanne. Termination of rewriting systems by polynomial interpretations and its implementation. Science of Computer Programming, 9(2):137–160, October 1987.
P. Borovansky´, C. Kirchner, H. Kirchner, P.-E. Moreau, and C. Ringeissen. An overview of ELAN. In C. Kirchner and H. Kirchner, editors, Proceedings of the second International Workshop on Rewriting Logic and Applications,
volume 15, http://www.elsevier.nl/locate/entcs/volume15.html, Pont-`a- Mousson (France), September 1998. Electronic Notes in Theoretical Computer Science. Report LORIA 98-R-316.
M. Clavel, S. Eker, P. Lincoln, and J. Meseguer.  Principles of Maude. In J. Meseguer, editor, Proceedings of the 1st International Workshop on Rewriting Logic and its Applications, volume 5 of Electronic Notes in Theoretical Computer Science, Asilomar, Pacific Grove, CA, USA, September 1996. North Holland.
E. Contejean, C. March´e, B. Monate, and X. Urbain. CiME version 2. Prerelease available at http://cime.lri.fr.
N. Dershowitz. Orderings for term rewriting systems. Theoretical Computer Science, 17:279–301, 1982.
N. Dershowitz and C. Hoot. Natural termination. Theoretical Computer Science, 142(2):179–207, 1995.
N. Dershowitz and J.-P. Jouannaud. Handbook of Theoretical Computer Science, volume B, chapter 6: Rewrite Systems, pages 244–320. Elsevier Science Publishers B. V. (North-Holland), 1990. Also as: Research report 478, LRI.
O. Fissore, I. Gnaedig, and H. Kirchner. Termination of rewriting with local strategies. In M. P. Bonacina and B. Gramlich, editors, Selected papers of the 4th International Workshop on Strategies in Automated Deduction, volume 58 of Electronic Notes in Theoretical Computer Science. Elsevier Science Publishers, 2001. Also available as Technical Report A01-R-177, LORIA, Nancy, France.
O. Fissore, I. Gnaedig, and H. Kirchner. CARIBOO : An induction based proof tool for termination with strategies. In Proceedings of the Fourth International Conference on Principles and Practice of Declarative Programming (PPDP), Pittsburgh, USA, October 2002. ACM Press.
O. Fissore, I. Gnaedig, and H. Kirchner.	Outermost ground termination
Extended version. Technical report A02-R-493, LORIA, Nancy, France, December 2002.


K. Futatsugi and A. Nakagawa. An overview of CAFE specification environment – an algebraic approach for creating, verifying, and maintaining formal specifications over networks. In Proceedings of the 1st IEEE Int. Conference on Formal Engineering Methods, 1997.
I. Gnaedig, H. Kirchner, and O. Fissore. Induction for innermost and outermost ground termination. Technical Report A01-R-178, LORIA, Nancy, France, 2001.
S. Kamin and J.-J. L´evy. Attempts for generalizing the recursive path ordering. Unpublished manuscript, 1980.
H. Kirchner and I. Gnaedig. Termination and normalisation under strategy
Proofs in ELAN.  In Proceedigs of the Third International Workshop on Rewriting Logic and its Applications, volume 36 of Elecronic Notes In Theoretical Computer Science, Kanazawa, JAPAN, September 2000. Elsevier Science Publishers.
P. Klint. A meta-environment for generating programming environments. ACM Transactions on Software Engineering and Methodology, 2:176–201, 1993.
M. R. K. Krishna Rao.	Some characteristics of strong normalization.
Theoretical Computer Science, 239:141–164, 2000.
J. B. Kruskal. Well-quasi ordering, the tree theorem and Vazsonyi’s conjecture.
Trans. Amer. Math. Soc., 95:210–225, 1960.
D. S. Lankford. On proving term rewriting systems are noetherian. Technical report, Louisiana Tech. University, Mathematics Dept., Ruston LA, 1979.
S. Lucas. Termination of rewriting with strategy annotations. In A. Voronkov and R. Nieuwenhuis, editors, Proc. of 8th International Conference on Logic for Programming, Artiﬁcial Intelligence and Reasoning, LPAR’01, volume 2250 of Lecture Notes in Artiﬁcial Intelligence, pages 669–684, La Habana, Cuba, December 2001. Springer-Verlag, Berlin.
A. Middeldorp and E. Hamoen. Completeness results for basic narrowing. Applicable algebra in Engineering, Communication and Computation, 5(3&4):213–253, 1994.
Q.-H. Nguyen. Compact normalisation trace via lazy rewriting. In S Lucas and B Gramlich, editors, Proc. 1st International Workshop on Reduction Strategies in Rewriting and Programming (WRS 2001), volume 57. Elsevier Science Publishers B. V. (North-Holland), May 2001.  Available at http:
//www.elsevier.com/locate/entcs/volume57.html.
S. E. Panitz and M. Schmidt-Schauss. TEA:Automatically proving termination of programs in a non-strict higher-order functional language,. In Proceedings of Static Analysis Symposium’97, volume 1302 of Lecture Notes in Computer Science, pages 345–360. Springer-Verlag, 1997.
H. Zantema. Termination of term rewriting by semantic labelling. Fundamenta Informaticae, 24:89–105, 1995.
