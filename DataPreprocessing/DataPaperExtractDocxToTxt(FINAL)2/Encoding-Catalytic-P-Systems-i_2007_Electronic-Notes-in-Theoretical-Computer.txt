	Electronic Notes in Theoretical Computer Science 171 (2007) 171–186	
www.elsevier.com/locate/entcs

Encoding Catalytic P Systems in π@
Cristian Versari1
Dipartimento di Scienze dell’Informazione Universita’ di Bologna
Bologna, Italy

Abstract
P systems are theoretical computing devices abstracted away from the biological architecture of the cell, introduced some years ago by Gheorghe P˘aun and now intensely studied. In the area of concurrent systems, process calculi have recently been applied and extended with similar aim, to simulate (and formalise) the behaviour of the cell. Although many common points can be found between the two approaches, no formal and exhaustive comparison has been carried out yet.
π@ is a new calculus, strongly π-Calculus based, well-suited to easily encode biologically inspired process calculi. In this paper the encoding in π@ of one variant of P systems is proposed, thus allowing a better understanding of similarities between P systems and bio-inspired process calculi.
Keywords: systems biology, membrane computing, catalytic P systems, process algebra, priority


Introduction
Membrane computing ([6]) arises as a branch of natural computing, with the aim of formalising and studying biologically inspired devices — P systems — from the point of view of automata and formal languages theory. Though initially they were not intended to provide models for the cell, recent research reported many advances in this direction, thus meeting the efforts of recent applications of another com- puter science research area — concurrency theory — to biology. In the first of these applications ([10]) biological entities (molecules, enzymes, and so on) were mod- eled in π-Calculus ([4,5]) as processes and pathways as sequences of inter-process communications. While very suited to model mobility and interaction of biologi- cal elements, π-Calculus lacked an explicit expression for the idea of compartment. Subsequent approaches (like [9,8,2]) added that notion, trying to retain concurrency and mobility capabilities: compartment becomes an ambient in BioAmbients, a box in Beta Binders, or the content of a membrane in Brane Calculus. Although un- derlying different sides of the biology of the cell, these languages presented many

1 Email: versari@cs.unibo.it

1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2007.05.015

common aspects due to this idea of compartment: localisation of interaction within the same compartment, atomicity of complex operations, mass object movements between different compartments. Even if P systems come from a very different computer science branch, they present many similar aspects to these process calculi
— concurrency/distribution, nondeterminism, interaction, mobility, compartmen- talisation — which make a comparison very interesting. One way to perform this comparison is to encode all of them in the same language.
π@ is a conservative, strongly π-Calculus based language with two key features: polyadic synchronisation (structured names for channels) to represent compart- ments, and priority to achieve atomicity for complex, mass movement operations. These features allowed simple encodings in π@ of biologically inspired calculi like Bioambients and Brane Calculi ([11]), with the aim of showing their common char- acteristics. To this same purpose we now present the encoding of a simple kind of P systems, by exploiting the key features of π@ to overcome the significant differences between membrane systems and process algebras (first of all maximal parallelism), thus proposing π@ as a new core calculus suited to encode and compare a wide variety of biologically inspired formalisms.
This paper is organised as follows: in section 2 basic definitions for catalytic P systems are recalled, then in section 3 π@ is introduced, with some example; section 4 presents step by step the complete definition for an encoding function in π@ of catalytic P systems. In section 5 some final observation is posed.

P systems
Quoting from [7]:
“The essential ingredient of a P system is its membrane structure, which can be a hierarchical arrangement of membranes, like in a cell (hence described by a tree), or a net of membranes (placed in the nodes of a graph), like in a tissue, or in a neural net. The intuition behind the notion of a membrane is that from biology, of a three-dimensional vesicle, but the concept itself is generalised/idealised to interpreting a membrane as a separator of two regions (of the Euclidean space), a finite inside and an infinite outside, also providing the possibility of a selective communication among the two regions.
The variety of suggestions from biology and the range of possibilities to define the architecture and the functioning of a membrane-based-multiset-processing device are practically endless – and already the literature of membrane computing contains a very large number of models.”
The high number of P systems models imposes a choice on the most similar to process calculi and initially easier to encode: catalytic P systems have been chosen for the simplicity of evolution rules and static structure of the membrane tree. Below, preliminary definitions are recalled, then formal definition of catalytic P systems is given.
Definition 2.1 Given a set S,a ﬁnite multiset over S is a function m : S → IN such

that the set dom(m)= {s ∈ S | m(s) /= 0} is finite. The multiplicity of an element s in m is given by the natural number m(s). The set of all finite multisets over S, denoted by Mfin(S), is ranged over by m. A multiset m such that dom(m)= ∅ is called empty . The empty multiset is denoted by ∅.
Given the multiset m and m', m ⊆ m' holds if m(s) ≤ m'(s) for all s ∈ S while
⊕ denotes their multiset union: m ⊕ m'(s)= m(s)+ m'(s). The operator \ denotes multiset difference: (m \ m')(s) = if m(s) ≥ m'(s) then m(s) − m'(s) else 0. The scalar product, j · m, of a number j with m is (j · m)(s)= j · (m(s)). The cardinality of a multiset is the number of occurrences of elements contained in the multiset:
|m| = Σs∈S m(s).
Some basic definitions on strings, cartesian products and relations are then given.

Definition 2.2 A string over S is a finite (possibly empty) sequence of elements in S. The length of a string is the number of occurrences of elements contained in
S. With S∗ we denote the set of strings over S, and u, v, w,... range over S.
Given a string u = x1 ... xn, the multiset corresponding to u is defined as follows: for all s ∈ S, mu(s)= |{i | xi = s ∧ 1 ≤ i ≤ n}|. With abuse of notation, we use u to denote also mu.
The definition of membrane structure follows.
Definition 2.3 Given the alphabet V = {[, ]}, the set MS is the least set induc- tively defined by the following rules:
[ ] ∈ MS 
if μ1, μ2,... , μn ∈ MS, n ≥ 1, then [μ1 ... μn] ∈ MS 
We define the following relation over MS: x ∼ y if and only if the two strings can be	written	in	the	form	x	=	[1... [2.. .]2 ... [3.. .]3 .. .]1	and
y = [1... [3.. .]3 ... [2.. .]2 .. .]1 (i.e., if two pairs of parenthesis that are neighbours can be swapped together with their contents).
The set MS of membrane structures is defined as the set of equivalence classes
w.r.t. the relation ∼∗.
We call a membrane each matching pair of parenthesis appearing in the mem- brane structure. A membrane structure μ can be represented as a Venn diagram, in which any closed space (delimited by a membrane and by the membranes imme- diately inside) is called a region of μ.
Definition 2.4 A catalytic P system (of degree d, with d ≥ 1) is a construct
Π= (V, C, μ, w0,... , w0, R1,... , Rd, i0)
1	d
where
V is a finite alphabet whose elements are called objects;
C ⊆ V is a set of catalysts;

μ is a membrane structure consisting of d membranes (usually labelled with i
and represented by corresponding brackets [i and ]i, with 1 ≤ i ≤ d);
w0, 1 ≤ i ≤ d, are strings over V associated with the regions 1, 2,... ,d of μ; they represent multisets of objects present in the regions of μ (the multiplicity of a symbol in a region is given by the number of occurrences of this symbol in the string corresponding to that region);
Ri, 1 ≤ i ≤ d, are finite sets of evolution rules over V associated with the regions 1, 2,... ,d of μ; these evolution rules are of the forms a → v or ca → cv, where c is a catalyst, a is an object from V \ C, and v is a string from ((V \ C) × {here, out, in})∗;
i0 is a number between 1 and d and it specifies the output membrane of Π.

The π@ language
The π@ calculus — pronounced like the french “paillette” — is essentially π- Calculus with the addition of two features: polyadic synchronisation and prioritised communication.


Polyadic Synchronisation
In π-Calculus channels and names are usually synonyms. Polyadic synchronisa- tion ([1]) introduces a sort of structure in channels: they are represented by a vector of one or more names. The idea of compartment is then expressed by adopting for communication a channel composed of two parts. One common example is the rep- resentation of an e-mail address: user@domain is a channel composed of 2 names, both necessary to send an email to the desired user. Polyadic syntax is represented in π@ exactly in the same way: names in a channel are separated by the character ‘@’. Thus, the communication of the datum d on the channel name chan in the compartment comp is usually written in π@ as

chan@comp⟨d⟩.P  chan@comp(x).Q	→	P  Q{d/x}
where the first process sends d and then becomes the process P , while the second receives d and executes the actions specified in Q. In π@ semantics, interaction between two processes may occur only if the channels involved in the input/output operation are composed of the same number of names, with the same multiplicity and in the same order. Consequently, we have

x@y⟨⟩.P y@x().Q		~	(x /= y) x⟨⟩.P x@x().Q	~
because the channel x@y is different from y@x, and x is different from x@x.

Priority
Priority behaves as expected: a high-priority process holds the central process- ing unit and executes its job before any low priority process. In π@ high priority synchronisations or communications are executed before any other low priority ac- tion. Usually a high priority action is indicated by underlining the name of the channel one or more times. For example, the expression


stand⟨x⟩.P  walk⟨y⟩.Q  run⟨z⟩
contains three processes with different, increasing priority. To express more than three levels of priority another notation is used, where the priority of the process is represented by a number following the channel names. The above expression may be rewritten as

stand : 2⟨x⟩.P  walk : 1⟨y⟩.Q  run : 0⟨z⟩
where a lower priority action is labelled with a higher number (the highest priority is denoted by 0).
Interaction between processes may occur only if channels have the same priority.
In this example
x⟨y⟩.P  x(z).Q	~
x⟨y⟩.P  x(z).Q	→	P  Q{y/z}
only the second interaction is allowed, because the expressions x and x denote actually two different channels. Finally, as expected, low priority actions occur only if no higher priority action may occur:

l⟨w⟩  l(x).P  h⟨y⟩  h(z).Q	~
0  P {w/x} h⟨y⟩ h(z).Q

l⟨w⟩  l(x).P  h⟨y⟩  h(z).Q	→
l⟨w⟩  l(x).P  0  Q{y/z}	→
0  P {w/x}  0  Q{y/z}
Interactions on low-priority channel l may happen only after the high-priority com- munication on channel h.
In the next section the syntax and reduction semantics of π-Calculus is briefly recalled, then in 3.2 the simple extensions which lead to π@ are presented.

π-Calculus
Definition 3.1 Let
N be a set of names on a finite alphabet, x, y, z,... ∈N ;

N = {x | x ∈ N }

The syntax of π-Calculus is defined as

P	::=	0	 
Σ πi.Pi	 

P  Q	 
! P	 
(νx)P

 
π	::=	τ	 

i∈I
x(y)	 
 

x⟨y⟩

Definition 3.2 The congruence relation ≡ is defined as the least congruence satis- fying alpha conversion, the commutative monoidal laws with respect to both ( ,0) and (+,0) and the following axioms:
(νx)P Q ≡ (νx)(P Q)	if x ∈/ fn(Q); (νx)P ≡ P		if x ∈/ fn(P )
! P ≡ ! P  P
where the function fn is defined as

fn(τ )
fn(x(y)) fn(x⟨y⟩) fn(0)
fn(π.P )
def
=	∅
def
=	{x}
def
=	{x, y}
def
=	∅
def
=	fn(π) ∪ fn(P )

fn(Σ
def
π .P )
fn(π .P )

def
fn(P	Q)	=
def
fn(P ) ∪ fn(Q)

fn(! P )
fn((νx)P )
=	fn(P )
def
=	fn(P ) \ {x}

Definition 3.3 π-Calculus semantics is given in terms of the reduction system described by the following rules:



τ.P → P
P → P '


(ν x)P → (ν x)P '



(μ(y).P + M )  (μ⟨z⟩.Q + N ) → P {z/y}  Q

P → P '


P  Q → P ' Q
P ≡ Q	P  → P '	P ' ≡ Q'


Q → Q'

See [4] for an exaustive introduction to π-Calculus.

π@ syntax and semantics
π@ is very close to pi-Calculus: from a syntactical point of view the only difference is the structure of channels, composed of multiple names followed by the priority of the action. We use μ to denote a vector of names x1,... , xn and μ : k to denote a channel, that is a vector of names μ followed by a colon and a natural number k specifying the priority. As usual, μ : k represents an output operation along channel μ : k, while α : k stands for a generic input, output or silent action τ of priority k.

Definition 3.4 Let
N be a set of names on finite alphabet, x, y, z,... ∈N ;
N + =  i>0 N i ,	μ ∈ N + ;
N + = {μ | μ ∈ N +} ;
α ∈	N + ∪N + ∪ {τ }  ;


The syntax of π@ defined as

P	::=	0	 

Σ πi.Pi	 


P  Q	 


! P	 


(νx)P

i∈I

π	::=	τ : k	 
μ : k(x)	 
μ : k⟨x⟩


As previously introduced, some abbreviations are very often used in this paper:

μ(x) = μ : 2(x)	μ⟨x⟩ = μ : 2⟨x⟩
μ(x) = μ : 1(x)	μ⟨x⟩ = μ : 1⟨x⟩
μ(x) = μ : 0(x)	μ⟨x⟩ = μ : 0⟨x⟩
	



The definition for structural congruence ≡ is exactly the same as given for π- Calculus, where the function fn is naturally extended to the π@ syntax. The reduc- tion semantics is very similar, but defined in terms of an auxiliary function Ik(P ), representing the set of actions of priority k which the process P may immediately execute. For example, if

P = a.Q  b  c.R  d + e.S  a.T

then I0(P ) = {c, e}, I1(P ) = {b, d}, I2(P ) = {a, a, τ }, where the availability of τ
action derives from the interaction of the first and last process.

Definition 3.5 Let Ik(P ) be
Ik Σ αi : li.Pi  = {αi | li = k};
i

Ik (ν y) P  = Ik(P ) \ α | y ∈ {x1,... , xn}∧
(α = x1@ ... @xn ∨ α = x1@ ... @xn)};
Ik !P  = Ik(P  P );

Ik P  Q = Ik(P ) ∪ Ik(Q) ∪ {τ | Ik(P ) ∩ Ik(Q) /= ∅}, withIk (Q)= α | α ∈ Ik(Q)}
π@ semantics is given in terms of the following reduction system:

τ ∈/  i<k Ii(M )
τ : k.P + M →k P
P →k P '


(ν x)P  →k (ν x)P '

τ ∈/  i<k Ii(M  N )
(μ : k(y).P + M )  (μ : k⟨z⟩.Q + N ) →k P {z/y}  Q
cP →k P '	τ ∈/	Ii(P  Q)	P ≡ Q	P →k P '	P ' ≡ Q'

P  Q →k P '  Q
Q →k Q'

π@ reduction rules are exactly the same of π-Calculus, except for the additional condition τ ∈/  i<k Ii(.. .) which avoids the execution of low priority actions if higher priority communications (represented by τ actions) are immediately available.
For a comprehensive formal treatment of priority in process algebras, see [3].
Encoding catalytic P systems in π@
P systems and process calculi present many similar aspects: interaction between different elements (by direct communication in π-Calculus-like languages, by tran- sition rules in P systems), localisation of interaction (within the same membrane in P systems, within the scope of a name in π-Calculus-like languages or within the same compartment in bio-inspired calculi), concurrency, nondeterminism. Anyway, they come from distant areas, in fact they are composed of totally different ele- ments: P systems are made of objects, (sometimes prioritised) rules, membranes. In process calculi there is only one kind of elements: processes. So it is quite natural expecting that every element of a P system will be translated to a π@ process. One non trivial difference to overcome is the maximal parallelism typical of P systems: even if process calculi deal with concurrent objects and describe parallel evolution, there is no immediate correspondence with such a strong constraint in π@, which means that maximal parallelism must be injected in some way within the behaviour of every process.

In the next section basic ideas of encoding catalytic P systems in π@ are pre- sented, first defining the general form of the encoding function and then specifying its simplest parts without considering the difficulties introduced by maximal par- allelism. In section 4.2 the encoding function is finally specified, preserving modu- larity and divergence/termination properties of the encoded systems even after the introduction of maximal parallelism constraints.

Encoding ideas
Obviously there is no unique translation. The intention is to choose the one which best fits some characteristics we require.
First, the encoding should preserve some kind of operational correspondence: in other words, if we have a transition between two configurations of a P system
steps) a transition	C1	=⇒  C2  , while if  C1  =⇒ Q, then a configuration
C should exist such that Q =⇒  C  and C1 −→ ... −→ C.
Another important requirement is modularity: the encoding of an element shall be independent of the encoding of any other element, disregarding the order which they have been taken into account, the membrane they are going to be located in, or the number and type of the adjacent elements. In other words, we want to be able to translate a P system, analyse or execute it, and later to change it by adding (or eliminating) objects or rules (or even membranes with arbitrary content) without having to re-encode all the system, or better without modifying at all the already encoded part.
Finally, a reasonable condition is the preservation of divergence / termination properties: it is advisable that the encoded systems terminate their computation if (and only if) the original ones do, but this raises many problems because of the maximal parallelism typical of P systems.
In this section we pursue the first two requirements, trying to make clear the general encoding ideas, while in the next section we show the final version of the encoding function which also preserves divergence/termination properties.
Before sketching the first encodings, we define the encoding function in its gen- eral form:
Definition 4.1 Given a catalytic P system Π ∈ ΠDom

Π= (V, C, μ, w0,... , w0, R1,... , Rd, i0)
1	d
where ΠDom represents the domain of all the possible catalytic P systems, the encoding function	: ΠDom −→ P is defined as


 Π  def
 μ  MS 
   w0, 1 
 ...   w0,d 

 R1, 1  R  ...   Rd,d  R

where

	: MS −→ P,	   : V ∗ × IN −→ P,	   : RDom × IN −→ P,


MS, V ∗, RDom standing respectively for the sets of all possible membrane struc- tures, multisets of objects (i.e. strings) and evolution rules.

 Th e next task is the definition of   MS ,   S ,   R, on which the definition
of	depends, but some remarks are due before.
Even without specifying the functions   MS ,   S ,   R, it is easy to observe
that the encoding is completely modular: every piece can be added, eliminated or
modified without affecting the rest of the encoded system. In this way we obtain exactly our aim, rules do not depend on objects and viceversa, but there is something more: objects or rules encoding does not depend on membrane structure, since the only information needed is the number (or the label) of the membrane containing the object or rule.
A P systems is essentially a set of objects observing certain evolution rules: if we have the rule ca → cbd, the object a can evolve to two new objects b, d, but only if a catalyst c is nearby. Perhaps the most natural way to compose the steps of this evolution is: “if an object of type a meets the catalyst c, then it evolves into two new objects b and d”, thus the objects are thought as the main actors of this process. But if we add another rule, a → e, then the behaviour of the object a considerably changes: “one possibility is that if the object a meets the catalyst c, then it evolves into two new objects b and d; another one is that the object a evolves into the object e”. So if we think objects as the main actors of evolution, probably we are not going to find a modular encoding. The key for avoiding this problem is to spot the real actors: evolution rules. The rule ca → cbd could be expressed in this way: “forever do: check if an object of type a is nearby, then check if a catalyst c is nearby too; if they are, replace a with b and d”. Hence, adding another rule would be not difficult: a → e would just become another process executing “forever do: if a is nearby, then replace it with e”. The behaviour of objects would then become trivial, in fact a would be “if some rule asks for object a, say a is present”. Obviously other issues would then pop up, caused for example by rules competing for the same objects, but we will face them later.
Following this interpretation, we could have (ignoring the second parameter of the encoding functions, for the moment)

 a  S = a ,	 c S = c

 ca → cbd  R	=	! c.a.(c  b  d)

In fact

a  c  ! c.a.(c  b  d)	→
a  a.(c  b  d)  ! c.a.(c  b  d)	→
c  b  d  ! c.a.(c  b  d)
but in this way if the object a is not present, object c disappears even if not used and the rule process is deadlocked:

c ! c.a.(c b d)	→	a.(c b d) ! c.a.(c b d) So a correction is necessary
 ca → cbd R	=	! c.(c + a.(c  b  d))
so that the checking phase does not delete even unused objects. But another issue appears, because the rule above may execute forever without producing its output objects, even if input objects a and c are present: we have introduced divergence. In fact, after checking the presence of c, we should be able to give some kind of precedence to the second term of the choice, in order to ensure that if some object a is present, then the rule completes its job. By means of prioritised choice, it is possible to model this kind of precedence:

 ca → cbd R	=	! c.(τ.c + a.(c  b  d))
In this way we obtain that if a given rule may be applied, for sure it is applied, any- way divergence is not completely removed yet: if only object c is present, the above process would continue its checking forever. Since maximal parallelism introduces again the same kind of problem, we defer the final solution to the next section.
One aspect we can consider before dealing with complex encodings is the local- isation of communication: objects located in one membrane shall not interact with rules located in another membrane. π@ allows to model this constraint in a very
simple way, by means of polyadic synchronisation. The encoding functions	R, S require two parameters: the first is the object or rule to be encoded, the second is the number (or label) of the surrounding membrane. Localised communi- cation is then obtained easily by specifying the membrane number for every object
manipulated by evolution rules:

 c, n  R	=	c@n ,	 a, n R	=	a@n

 ca → cbd, n  R	=	! c@n.(τ.c@n + a@n.(c@n  b@n  d@n))
The next step is to understand how to express rules producing objects outside membrane boundaries. For example, encoding the rule ca → c(b, out), which ejects b in the external membrane, requires some knowledge about membrane structure.

The definition 4.1 asserts that the only process owing this knowledge is μ MS , which is supposed to be properly queried. Thus, a possible solution may be

 ca → c(b, out),n  R	=	! c@n.(τ.c@n + a@n.(c@n  out@n(x).b@x))
where the instruction out@n(x) queries the membrane structure process about the label of the outer membrane.
Hence, membrane structure process could be seen as a service replying to two types of queries: “tell me the label of the membrane surrounding membrane n”, or “tell me the label of one of membranes inside membrane n”. The second type of query introduces some kind of nondeterminism, because each membrane may contain more than one child membrane, so it is necessary to preserve this nonde- terministic behaviour after the encoding. The easiest way to translate a membrane structure in π@ is considering each membrane as a separated process. Thus, the first type of query imposes that every membrane process “knows” the label of its surrounding membrane. In other words, if membrane structure is a tree, we are going to implement it with pointers from child membranes to parent membranes. But the second type of rule requires that pointers from parent membranes to the inner ones also exist: including these pointers in the child membranes processes allows to encode each membrane completely disregarding its content.
Definition 4.2 Given a membrane structure μ ∈ MS, the encoding function

  MS : MS −→ P
is defined as

 [1

μi1
,... , μik ]1 MS 

def
=

! out@1⟨outside⟩   μi1


, 1  '



 ...   μik



, 1  '

where

is defined as

'
MS : MS × IN −→ P


 [n


μi1
,... , μik
] , p  '

def
=


	
! out@n⟨p⟩  ! in@p⟨n⟩   μi1 ,n	 ...   μ ,n 
'	'
ik
The main encoding function   MS is defined in terms of an auxiliary function

  '
, which requires an additional parameter: the label of the parent membrane.

MS 
The skin has no parent membrane, so we provide a fictitious name outside to express
the compartment containing the objects ejected from skin and never allowed to enter again. The encoding of each membrane is completely modular, hence any change to the membrane structure tree affects only the encodings of the nodes directly

involved: adding or removing a whole subtree requires no changes to the remaining structure.
Before facing divergence issues and maximal parallelism, the definition of   S
is given.
Definition 4.3 Given a string s ∈ V ∗,s = s1s2 ... sn, the encoding function
   : V ∗ −→ P


is defined as

 s 

def


s  s   ... s 

Again, the encoding is completely modular. Furthermore, it does not distinguish catalysts from common objects, in fact the distinction is only useful before compile- time to check the correctness of P system rules. The reason for the higher degree of priority will be clear in the next section.

Final encodings
Two issues persist: the divergence introduced in the encoding of evolution rules and maximal parallelism. Divergence is caused essentially by an endless loop. In fact, the rule

 ca → cbd R	=	! c.(τ.c + a.(c  b  d))
contains a guarded loop, but the guard has no effect if the catalyst c is present, because it never disappears. So an additional guard is required:

 ca → cbd  R	=	coin  ! coin.c.(τ.c + a.(c  b  d  coin))
First, a coin is given, then every execution of the rule eats a coin, but only a succesfull execution produces another coin: after the first failure, the loop ends. Yet, there are issues: in presence of two or more rules, the coin owned by a rule could be used by another one. Furthermore, if object a or c is absent, the process may pause in a spurious state and allow other rules to begin computing before ending execution or releasing back the catalyst c. Even if it is possible to prove that the final result does not change, this breaks the idea of atomicity for the application of a rule. Thus, channel coin must be private and the priority of every action shall be increased:

 ca → cbd R	=	(ν coin)(coin  ! coin.(τ + c.(τ .c + a.(c  b  d  coin))))
Maximal parallelism is a heavy constraint on the order of actions: objects may be used only once for every tick of a sort of global clock. From an algorithmic point of view, it may be thought as a global loop of this kind:

until (in each tick at least one rule can be applied) do until (in current tick some rule can be applied) do
apply a rule, freezing, for current tick, produced objects done
let clock tick, unfreezing just produced objects done
The outermost loop can be translated with the same scheme used to overcome divergence in the encoding of rules: the only requirement is that rules signal in some way their application performed during each clock tick, in order to allow the loop to continue if at least one rule has been applied at least once:



 ca → cbd R	=	(ν coin)(! coin.(τ .tick.coin + c.(τ .(c tick.coin)+ a.(tick(c  b  d)  coin  worked)))  tick.coin)

Now, every application of the rule produces a worked process, signaling its application, and the rule waits for its coin from the tick of the global clock. When the rule application fails (i.e. when the τ actions are performed), a new process waits for next coin. The objects c, b, d produced by the rule are also frozen until next clock tick. The global clock can expressed by a low priority loop:

! clock : 3.worked.bcast⟨worked⟩.τ.bcast⟨tick⟩.clock :3 clock :3  worked

The first instruction, executed with the lowest priority, clock : 3, is the guard for the global clock loop, working in the same way of the one previously seen: its coin is represented by clock : 3. As soon as this low priority guard fires, the presence of at least one worked process is checked and the potential duplicates are burned by a subsequent broadcast on the same name. Finally, all the processes waiting for next clock tick (rules waiting for their coin, or frozen objects) are awakened by another broadcast.
Recalling previous considerations about localisation and movement of objects between membranes, the encoding function for rules can finally be formalised:
Definition 4.4 Given an evolution rule E ∈ RDom, the function

  R : RDom × IN −→ P


is defined as

 E, n  R



def
=


(ν coin)(! coin.(τ .tick.coin +  E, n  ' )  tick.coin) 
 CLOCK  BCAST

where


CLOCK	≡	! clock : 3.worked.bcast⟨worked⟩.τ.bcast⟨tick⟩.clock :3 

 clock :3  worked
BCAST	≡	! bcast(x).(τ + x.bcast⟨x⟩)



The function
is defined as
  '

: RDom

× IN −→ P

 ca → cv, n  '
def
=

		
c@n.(τ .(c@n  tick.coin)+  a → (c, here)v, n  ' )



 a → v
... v ,n '	def
a@n.(coin  worked 

1	k	R	=
	

  v ,n  ''

 ...   v

,n  '' )

where a ∈ V \ C, c ∈ C, v ∈ (V × {here, out, in})∗, v = v1 ... vn, V alphabet of the P system, C set of catalysts.
Finally, the function

  ''
: (V × {here, out, in}) × IN −→ P



is defined as

 (a, here),n  ''

 (a, out),n  ''

 (a, in),n  ''


def
=
def
=
def
=

tick.a@n out@n(x).tick.a@x in@n(x).tick.a@x

The definition of CLOCK and BCAST does not depend on any rule, so an
immediate optimisation would be insert them in the encoding of the function in order to avoid useless duplicates, but this affects only the compilation phase.

Conclusion
In this paper we defined one possible encoding in π@ of catalytic P systems. We showed that it is possible to encode in a completely modular way such kind of P systems, using 4 levels of priority and vectors of names of size ≤ 2 for channels.
The encoding preserves all the peculiarities of P systems: nondeterminism, max- imal parallelism, divergence/termination. While the first characteristic is an imme- diate consequence of the intrinsic nondeterminism typical of process calculi, maxi- mal parallelism and termination are reached by means of a quite sophisticated use

of priorities. Membrane structure and localisation of objects and rules is expressed by means of polyadic synchronisation.
The encoding of catalytic P systems is only a preliminar step towards more complex and interesting encodings, in particular those pertaining P systems with dynamical membrane structure, in order to investigate the affinities between them and bio-inspired languages like Brane Calculi.

References
M. Carbone, S. Maffeis. On the Expressive Power of Polyadic Synchronisation in pi-calculus. In Nordic Journal of Computing 10(2): 70-98, 2003.
L. Cardelli. Brane Calculi - Interactions of Biological Membranes. In Computational Methods in Systems Biology, 2004.
R. Cleaveland, G. Lu¨ttgen, V. Natarajan. Priority in Process Algebra. In J.A. Bergstra, A. Ponse, S.
A. Smolka, editors, Handbook of Process Algebra, Elsevier, 2001..
R. Milner. The Polyadic π-Calculus: a Tutorial. In F. L. Hamer, W. Brauer and H. Schwichtenberg, editors, Logic and Algebra of Specification. Springer-Verlag, 1993.
R. Milner. Communicating and Mobile Systems: The π-Calculus. Cambridge University Press, 1999.
G. Pa˘un. Computing with membranes. Journal of Computer and System Sciences, 61(1):108–143, 2000.
G. Pa˘un. Introduction to Membrane Computing. First Brainstorming Workshop on Uncertainty in Membrane Computing, Palma de Mallorca, Spain, November 2004, 17-65.
C. Priami, P. Quaglia. Beta binders for biological interactions. In Computational Methods in Systems Biology, 2004.
A. Regev, E. Panina, W. Silverman, L. Cardelli, E. Shapiro. BioAmbients: an abstraction for biological compartments. Theoretical Computer Science, 2004.
A. Regev, W. Silverman, E. Shapiro. Representing Biomolecular Processes with Computer Process Algebra: π-Calculus programs of Signal Transduction pathways. 2000.
C. Versari. Formal representation of complex biological systems. Master Thesys (in italian), University of Bologna, 2005.
