

Electronic Notes in Theoretical Computer Science 239 (2009) 43–56
www.elsevier.com/locate/entcs

Bounded Communication Reachability Analysis of Process Rewrite Systems with Ordered Parallelism
Mihaela Sighireanu
Liafa, CNRS and University Paris Diderot, France
sighireanu@liafa.jussieu.fr

Tayssir Touili
Liafa, CNRS and University Paris Diderot, France
touili@liafa.jussieu.fr


Abstract
We define a new model called O-PRS that extends the Process Rewrite Systems formalism with a new as- sociative operator, “ ”, that allows to model parallel composition while keeping the order between parallel processes. Indeed, sometimes, it is important to remember the order between the parallel processes. The reachability problem of O-PRS being undecidable, we develop tree automata techniques allowing to build polynomial finite representations of (1) the exact reachable configurations in O-PRS modulo various equiv-
alences that omit the associativity of “ ”, and (2) underapproximations of the reachable configurations if the associativity of “ ” is considered. We show that these underapproximations are exact if the number of communications between ordered parallel processes is bounded. We implemented our algorithms in a tool that was used for the analysis of a concurrent lexer server.
Keywords: Multithreaded programs with procedure calls, synchronisation, process algebra, program analysis, verification.

Introduction
Analysis of concurrent software represents a major challenge in the model-checking community. Indeed, concurrent programs include various complex features such as
(1) the manipulation of data ranging over unbounded domains, (2) the presence of recursive procedure calls, which can lead to an unbounded number of calls, (3) the dynamic creation of parallel processes, and (4) the existence of synchronization statements. Ramalingam [21] has shown that checking whether a given control point is reachable is undecidable, even if the program includes only recursive procedures and synchronisation statements. Therefore, to be able to analyse such programs,

1571-0661/© 2009 Published by Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.05.029

we need either to restrict ourselves to decidable subclasses, or to use approximative techniques.
During the last few years, several authors have addressed this issue. In partic- ular, Process Rewrite Systems (PRS for short) [19] have been successfully used in [11,12] to model and analyse such programs. A PRS is a finite set of rules of the form t → t' where t and t' are terms built up from the idle process (“0”), a finite set of process variables (X), sequential composition (“·”), and asynchronous parallel composition (“||”). The semantics of PRSs considers terms modulo a structural equivalence  which expresses the fact that 0 is a neutral element of “·” and “||”, that “·” is associative, and that “||” is associative and commutative.
To model a program in this framework, process variables are used to represent control points in the program, rules of the form X → X1 · X2 represent sequential recursive calls, whereas rules of the form X → X1||X2 model dynamic creation of parallel processes. Moreover, rules of the form X1 · X2 → X and X1||X2 → X allow to model some sort of communication between sequential and parallel processes, respectively. Therefore, due to the commutativity of the parallel composition “||”, PRS can only model programs where the order between the concurrent processes is not important. However, sometimes, it is important to keep the order between the parallel processes. This holds for example if the communication is done between processes that are neighbors. This is the case for example of the concurrent lexer server described in Section 5.
To overcome this restriction, we consider a new model, called O-PRS, that ex- tends the PRS model with a new parallel operator that is associative but not commutative, and hence it preserves the order between parallel processes. Note that O-PRS involves the two parallel operators “||” and “ ” since a given program may involve the two kinds of communications: the ordered ( ) and the unordered (||) one. Note also that  is different from the sequential composition “·” since this latter has a prefix rewriting strategy, whereas  does not.
Unfortunately, while reachability between terms is decidable for PRS [19], it be- comes undecidable for O-PRS due to the associativity of  [16]. Despite this unde- cidability, we consider in this paper the reachability problem between two (infinite) sets of terms. Since process terms can be seen as trees, we consider representations of sets of terms based on (bottom-up) tree automata. To sidestep the undecidability result, we proceed as follows:
First, we follow the approach used in [11] and perform the exact reachability analysis of O-PRS modulo restricted equivalences that omit the associativity of  (the cause of undecidability). Indeed, as discussed in [11], the reach- ability analysis modulo all the equivalences can be shown in many cases to be reducible to computing representatives of the reachability set modulo some stronger equivalence.
In case the associativity of  cannot be avoided, we compute representatives of underapproximations of the reachability sets by allowing the ordered processes to communicate only a fixed number of times k. These approximations enable the discovery of bugs in the system. Then, increasing k allows to compute

better underapproximations. Moreover, if for k and k + 1 the computed under- approximations are the same, then we know that we have computed an exact representative of the reachability set. Note that the underapproximations we compute are exact if the ordered processes can only perform a bounded number of communications. This is the case of our case study, which is a real example.
All the constructions that we give are polynomial. We implemented our algo-
rithms in a prototype called Press. Press has been applied to several academic
examples and to an interesting example called the concurrent lexer server [3].
Related work.  The results in this paper generalize those given in [18,15] for the PA case, and in [11] for PRS, where tree automata are computed to represent representatives of the reachability sets modulo different equivalences between terms. Models based on communication via message passing have been considered in [5,6,7,24,13]. However, all these models do not consider ordered parallel processes. In [9], a model called CDPN has been introduced. This model allows a “restricted ordered” communication where a process can only communicate with his children (the processes that he created). Our model allows arbitrary ordered communication
between parallel processes.
The idea of performing reachability analysis while bounding the number of com- munications is known as bounded context switch reachability, and has been intro- duced in [20], and considered later in [4]. However, in [20,4] the parallel processes are not ordered.
Communication between ordered processes has been extensively studied in the context of parametrized systems verification using Regular Model Checking [1,8,10,2]. These works do not consider dynamic creation of processes.

Preliminaries
Terms and tree automata
An alphabet Σ is ranked if it is endowed with a mapping rank :Σ → N. For k ≥ 0, Σk is the set of elements of rank k. Let X be a fixed denumerable set of variables
{x1, x2,.. .}. The set TΣ[X ] of terms over Σ and X is the smallest set that satisfies: Σ0 ∪ X ⊆ TΣ[X ], and if k ≥ 1, f ∈ Σk and t1,... , tk ∈ TΣ[X ], then f (t1,... , tk) is in TΣ[X ]. TΣ stands for TΣ[∅]. Terms in TΣ are called ground terms. A term in TΣ[X ] is linear if each variable occurs at most once. A context C is a linear term of TΣ[X ]. Let t1,... , tn be terms of TΣ, then C[t1,... , tn] denotes the term obtained by replacing in the context C the occurrence of the variable xi by the term ti, for each 1 ≤ i ≤ n.
Definition 2.1 [[14]] A tree automaton is a tuple A = (Q, Σ, F, δ) where Q is a set of states, Σ is a ranked alphabet, F ⊆ Q is a set of final states, and δ is a set of rules of the form (1) f (q1,... , qn) → q, or (2) a → q, or (3) q → q', where a ∈ Σ0, n ≥ 0, f ∈ Σn, and q1,... , qn, q, q' ∈ Q. If Q is finite, A is called a ﬁnite tree automaton.

Let →δ be the move relation of A defined as follows: Given t and t' two terms of TΣ∪Q, then t →δ t' iff there exist a context C ∈ TΣ∪Q[X ], and (1)
n ground terms t1,... , tn ∈ TΣ, and a r ule f (q1,... , qn) → q in δ, such that
δ, such that t = C[a], and t' = C[q(a)], or (3) a rule q → q' in δ, such that

t = C[q(u)], and t' = C[q'(u)]. Let ∗
be the reflexive-transitive closure of →δ.
∗

A term t is accepted by a state q ∈ Q iff t −→δ q(t). In this case, we say that t is
annotated with q. Let L be the set of terms accepted by q. The language accepted by the automaton A is L(A) = {Lq | q ∈ F }. A tree language is regular if it is accepted by a finite tree automaton.
The class of regular tree languages is closed under union, intersection, and com- plementation. Moreover, the emptiness problem of these automata can be solved in linear time.
Process Rewrite Systems with Ordered Parllelism
Deﬁnition
Let V ar = {X, Y,.. .} be a set of process variables, and Tp be the set of process terms t defined by the following syntax, where X is an arbitrary constant from V ar:
t ::= 0 | X | t · t | t||t | t  t

Intuitively, 0 is the null process and “.” denotes sequential composition, “||” denotes asynchronous parallel composition, and “ ” denotes the ordered parallel composi- tion. We use both prefix and infix notations to represent process terms.
Definition 3.1 A Process Rewrite System with Ordered Parallelism (O-PRS for short) is a finite set of rules of the form t1 → t2, where t1, t2 ∈ Tp. A PRS [19] is an O-PRS without the “ ” operator. An O-PAD (resp. PAD) is an O-PRS (resp. PRS) where all the rules have no parallel composition “||” in the left hand sides of the rules.
An O-PRS R induces a transition relation →R over Tp defined by the following inference rules:

t1 → t2 ∈ R ;
t1 →R t2
t1 →R t' t1||t2 →R t' ||t2
t1 →R t'
t1  t2 →R t'  t2
t1 →R t'
t1 · t2 →R t' · t2
t2 →R t' t1||t2 →R t1||t'

t2 →R t'	t1 ∼0 0 ,  t2 →R t'
2	' ;	' 2
	
t1  t2 →R t1  t2	t1 · t2 →R t1 · t2
where ∼0 is an equivalence between process terms that identifies the terminated processes. It expresses the neutrality of the null process “0” w.r.t. “||”, “ ”, and “.”. ∼0 is defined by the following axiom:
A1:	t · 0 ∼0 0 · t ∼0 t||0 ∼0 0||t ∼0 t ∼0 t  0 ∼0 0  t

We consider the structural equivalence ∼ generated by the axioms A1 and the following axioms:
A2:	(t · t') · t'' ∼ t · (t' · t'')	 : associativity of “.”, A3:			t||t' ∼ t'||t	: commutativity of “||”, A4:		(t||t')||t'' ∼ t||(t'||t'')	: associativity of “||”,
A5:	(t  t')  t'' ∼ t  (t'  t'')	: associativity of “ ”.
We denote by ∼s the equivalence induced by the axioms A1 and A2, by ∼ the equivalence induced by A5, by ∼ ,s the equivalence induced by the axioms A1, A2, and A5, and by  the equivalence induced by the axioms A1, A2, A3, and A4. For each equivalence ≡, we denote by [t]≡ the equivalence class modulo ≡ of the process term t, i.e., [t]≡ = {t' ∈ Tp | t ≡ t'}. This definition is extended to sets of terms straightforwardly. A set of terms L is ≡-compatible if [L]≡ = L. A set of terms L' is a ≡-representative of L if [L']≡ = L. Each equivalence ≡ induces a transition relation ⇒≡,R defined as follows:
∀t, t' ∈ Tp,t ⇒≡,R t' iff ∃u, u' ∈ Tp such that t ≡ u, u →R u', and u' ≡ t'


∗
Let ⇒≡,R
be the reflexive transitive closure of ⇒

≡,R
. Let Post∗
(t) = {t' ∈ Tp |

t ∗	'
⇒≡,R t }. This definition is extended to sets of terms in the standard way. We
omit the subscript ≡ when it corresponds to the identity (=).
An O-PRS R is in normal form if R = R' ∪ R  where R' is a PRS and R  is a set of rules of the form t1 → t2 where t1 and t2 are either 0, X, or X  Y . Notice that the systems R' and R are not independent in the sense that they can share process constants.
It can be shown, by adapting the proof of a very close fact in [19], that for every O-PRS R over a set of process constants V ar, it is possible to associate an O-PRS R' in normal form over a new set of process constants V ar' (which extends V ar by some auxiliary process constants), and there exist two ground term substitutions
S1 and S2 such that Post∗ = S2 ◦ Post∗ ' ◦ S1. Therefore, we assume w.l.o.g. in the
remainder of the paper that O-PRS are always in normal form.

Reachability analysis problem
An O-PRS process term can be seen as a tree over the alphabet Σ = Σ0 ∪ Σ2, where Σ0 = {0} ∪ V ar and Σ2 = {., ||, }. A set of terms is regular if it can be represented by a finite tree automaton. The ≡-reachability problem consists in,

given two regular sets of terms L1 and L2, deciding whether Post∗
(L1) ∩ L2 /= ∅.

Unfortunately, because of the associativity of the  operator, it follows from [16] that:
Theorem 3.2 The ≡-reachability problem is undecidable for O-PRS if ≡∈ {∼ 

, ∼ ,s, ∼}. This holds even if L1 and L2 are single terms. 1
Therefore, the basic problems we consider in this paper is to compute, given a regular set L of terms, representations of the sets (resp. of underapproximations

of the sets) Post∗
(L) if ≡∈ {=, ∼0, ∼s, } (resp. if ≡∈ {∼ , ∼ ,s, ∼}). More

precisely, since these sets are in general not regular due to the associativity of “·” and “ ”, and to the associativity-commutativity of “  ”, we will compute representatives of them. Indeed:

Lemma 3.3 Let L1, L2 be two sets of terms, and let L'
be a ≡-representative of

'	1
L1. If L2 is ≡-compatible, then L1 ∩ L2 /= ∅ iff L1 ∩ L2 /= ∅.
Therefore, computing regular ≡-representatives of (approximations of) the

Post∗
images of regular sets allows to solve reachability problems.

Reachability Analysis of O-PRS
Reachability modulo term equality, ∼0, ∼s, and 
It has been shown in [11] that if R is a PRS and L a regular set of PRS terms, then:

Post∗ (L) and Post∗
(L) are regular and effectively computable.

R	R,∼0

A regular ∼s-representative of Post∗
(L) can be effectively computed. This

∗	R,∼s
gives a  -representative of PostR, (L) if R is a PAD since in this case, a ∼s-
representative of Post∗	(L) is also a  -representative of Post∗	(L) [11,23].
Since in absence of the associativity of  and of the associativity/commutativity of ||, these two operators are similar, the constructions given in [11] can straight- forwardly be extended to O-PRSs (simply by treating the new operator  as “||”). Therefore, we get the following result:
Theorem 4.1 Let R be an O-PRS, L be a regular set of process terms, and A be a ﬁnite tree automaton that recognizes L. Then, we can effectively compute ﬁnite

tree automata that recognize Post∗ (L), Post∗
(L), and a ∼s-representative of

R	R,∼0

Post∗
s
(L). Moreover, if R is an O-PAD, then we can effectively compute a ﬁnite
∗

tree automaton that recognizes a  -representative of PostR, (L).
Reachability modulo ∼ , ∼ ,s, and ∼
As mentioned in Theorem 3.2, reachability is undecidable modulo ∼  , ∼  ,s, and
∼. Therefore, we propose in this section to compute ≡-representatives of underap-

proximations of the reachability sets Post∗
for ≡∈ {∼  , ∼  ,s, ∼}. The sets

that we compute are underapproximations because we will allow to each process to communicate only a bounded number of times with his neighbors using the rules X  Y → t. These underapproximations enable the discovery of bugs in the system.
Let us start with ∼ . The main difficulty in reasoning modulo this equivalence comes from the fact that the rules of the form X  Y → t are not applied locally

1 This is not the case for PRS even if “·” is associative thanks to its prefix-rewriting semantics.

anymore. Indeed, so far such a rule is applied to a term u only if u has X Y as an explicit subterm. This is no longer the case when we consider terms modulo ∼ . Indee d, this rule sh ould be applied for instance to the terms X  Y  (Z  T ) and
argue that the same problem occurs with the rules of the form X · Y → t when we consider the equivalence ∼s. This is true, but the case of the operator  is much more complicated due to the fact that the operator “·” follows a prefix-rewriting strategy, whereas  does not. To be able to handle this kind of rules of the form X Y → t, since due to the undecidability result it is impossible to compute a representative of the whole reachability set, we will compute a representative of the set of terms that are reachable from L by applying these rules an arbitrary number of times in different positions of the terms of L, while ensuring that at each leaf, only one rewriting occurs. Intuitively, since rules of the form X Y → t model communication between ordered processes, this means that we will compute representatives of the sets of configurations that are reachable by allowing every process to communicate only once with his neighbors. We first show how we solve the problem when the system R contains only rules of the form above, and then, we show how to handle the general case.

The case where R has only rules of the form X  Y → t
We suppose in this subsection that R contains only rules of the form X  Y → t. We suppose w.l.o.g. that all the rules of R are of the form X  Y → Z  T , where T is either a variable in V ar, or the null process 0 (we write the rules of the form X  Y → Z as X  Y → Z  0).
Let L be a regular set of terms. We show in what follows how to compute a

finite-state automaton that recognizes a representative of Post⊙
defined as

the set of terms that are reachable from L by applying the rules of R an arbitrary
number of times in different positions of the terms of L, and such that at each leaf, only one rewriting occurs. To do so, let us introduce the notion of  -context:
Definition 4.2 Let x, y ∈ X , a  -context is a 2-variable context C[x, y] such that there exist 2 single-variable contexts C1 and C2 such that: (1) C[x, y] =
 (C1[x], C2[y]), (2) x is the rightmost leaf of C1, and y is the leftmost leaf of C2, and (3) all the ancestors of the variables x and y in C1 and C2, respectively, are labeled by “ ”.
Then, modulo ∼ , a rule X  Y → Z  T can be applied to any term of the form C[X, Y ] for a -context C, to yield a term that is ∼ -equivalent to C[Z, T ]. We define the relation ΞR that performs this transformation as follows: For every rule X Y → Z T in R, and every -context C, C[X, Y ],C[Z, T ] ∈ ΞR. This transformation is depicted on Figure 1, where the bold lines represent nodes labeled by “ ”. It can be shown that ΞR(L) is a ∼ -representative of PostR,∼ (L).
Let t be a term. We define Ξ⊙(t) as the set of terms obtained by applying ΞR an arbitrary number of times to t, while ensuring that each leaf is rewritten at most
once. This definition is extended to sets of terms in the obvious manner. We prove


	
X	Y	Z	T
Fig. 1. Application of the rule X  Y → Z  T modulo ∼ 

in what follows that for any regular language L, Ξ⊙(L) is effectively regular.

Ξ⊙(L) is effectively regular.
Let R1,... , Rn be the different rules of R.	Let A = (Q, Σ, F, δ) be a tree
automaton that recognizes L. We define the automaton A' = (Q', Σ,F ', δ') as follows:
Q' = Q ∪ {(q, Ri), (q, R¯i), (q, RiR¯j ) | q ∈ Q, Ri, Rj ∈ R}.
F ' = F .
δ' contains δ and the following rules:
(α1) If Ri = X  Y → Z  T is a rule of R, then:

∗
if Y −→δ
∗
if X −→δ
q(Y ), then T → (q, Ri) ∈ δ';
q(X), then Z → (q, R¯i) ∈ δ'.

(α2) If  (q1, q2) → q ∈ δ, then for every Ri, Rj, Rk ∈ R, we have:
(q1, Ri), q2 → (q, Ri) ∈ δ',
q1, (q2, R¯i) → (q, R¯i) ∈ δ',
(q1, R¯i), (q2, Ri) → q ∈ δ',
(q1, Ri), (q2, R¯j ) → (q, RiR¯j ) ∈ δ',
(q1, RiR¯j ), (q2, RjR¯k ) → (q, RiR¯k) ∈ δ',
(q1, RiR¯j ), (q2, Rj) → (q, Ri) ∈ δ',
(q1, R¯j ), (q2, RjR¯k) → (q, R¯k ) ∈ δ'.
The intuition behind the construction above is the following: If we consider the rewriting step depicted in Figure 1, the automaton A' needs to recognize the term on the right side as a successor of the term on the left side. To do so, it has to guess that in the place of the Z was an X, that in the place of the T there was a Y , and that these two positions were rewritten using a rule of the form Ri = X  Y → Z  T .
To do so, the automaton annotates the Z by state (q , R¯ ) if X ∗	q (X) (rule α b),
1	i	−→δ 1	1
∗
and the T by state (q2, Ri) if Y −→δ q2(Y ) (rule α1a). These guesses have then to
reach the root of the term where they have to be validated. The role of the rules (α2) is to propagate the guesses upward the terms until they are validated. Validation is done using the rules c, e, f, and g. States of the form (q, RiR¯j ) memorize two guesses. We do not need to memorize more because only one rewriting is allowed at each leaf. So, at the end, we get that:
∗	⊙
Lemma 4.3 t −→δ' q(t) iff t ∈ ΞR(Lq).

The proof of this lemma follows the lines of the proofs given in [11]. It follows that:
Theorem 4.4 Let L be a regular set of process terms, and A = (Q, Σ, F, δ) be a
ﬁnite tree automaton that recognizes L. Then, Ξ⊙(L) is recognized by the ﬁnite tree

automaton
R
A'.


Example.
Let us illustrate the construction above with an example. Let t be the term depicted on the left side of Figure 2 (the nodes are labeled with , we do not depict them for the sake of presentation). Let R = {R1, R2} where R1 = Y  Z → A B and R2 = T  W → C  D. t is recognized by the automaton having the states Q = {q1,... , q9}, F = {q9}, and the rules δ = {X → q1,Y → q2,Z → q3,T → q4,W → q8, (q1, q2) → q5, (q3, q4) → q6, (q5, q6) → q7, (q7, q8) → q9}.



ΞR
W		D




X Y	Z T	X A	B C


n9


n8




n1 n2  n3 n4
Names of the nodes
Fig. 2. An example

Then, the term on the right side of the figure will be recognized by the automaton
A' constructed from A as follows:
X is annotated with q1, since δ ⊆ δ';
A is annotated with (q2, R¯1), and C with (q4, R¯2) using α1b;
B is annotated with (q3, R1), and D with (q8, R2) using α1a;
node n5 is annotated with (q5, R¯1) using α2b;
node n6 is annotated with (q6, R1R¯2) using α2d;
node n7 is annotated with (q7, R¯2) using α2g;
Finally, node n9 is annotated with q9 using α2c.
Since the root of the term is annotated by q9 ∈ F , this means that the computed automaton recognizes this term as a successor of t.
Remark 4.5 Observe that the fact that each leaf can be rewritten only once is crucial for our construction to work. Indeed, if we omit this condition, then the

automaton would need an infinite number of states to perform the guesses, since at each leaf, an arbitrary number of rewritings (and therefore of guesses) can occur.

Reachability analysis of arbitrary O-PRS
Let R = R' ∪ R  be an O-PRS, where R' is a PRS and R  has rules involving
only the operator  . Let R1 be the rules of R  of the form X → t, and R2 be
the rules of R  of the form X  Y → t. Then, we can compute a representative of
an underapproximation of Post∗	(L) where the ordered processes communicate a

bounded number of times k. To do so, it suffices to compute Ξ⊙
 
Post∗
 k(L) by

applying the construction underlying Theorem 4.1 followed by the Ξ⊙
 
construction
∗

k times. Obviously, the obtained set is an underapproximation of PostR,∼  (L).
Further, when increasing k, we can compute better underapproximations. Moreover, if for k and k + 1 the computed underapproximations are the same, then we know

that we have computed an exact representative of Post∗
(L).

The same principle can be applied to compute underapproximations of ∼ ,s-

representatives of Post∗
(L).	To do so, it suffices to apply the construc-
∗

tion of Theorem 4.1 that produces ∼s-representatives of PostR,∼s (L) instead of
Post∗	(L). This gives us ∼-representatives of underapproximations of Post∗	(L)
in the case of O-PAD.

A case study and experiments
We implemented our algorithms in a prototype called Press [22]. Press has been applied to several academic examples and to an interesting example called the con- current lexer server [3].

The concurrent lexer server
We consider a multi-threaded server whose service is to do lexical analysis of texts it receives from clients. Each time that a client request arrives, i.e., a connection of the client to the server is successful, the server creates a thread that does the lexical analysis work and communicates the result to the client.
The main specificity of this example is that the lexical analysis is done in a concurrent manner, as suggested in [3]. The advantage of concurrency is that it improves the complexity of the analysis.
Let us specify the work done by the lexical analyzer. We suppose that the input language of texts sent by clients is a simple language of arithmetical expressions, i.e., the input texts tin are sequences of blanks, letters, digits, and arithmetical operators (e.g., +, −, ∗). The output of the analyzer should be an array of length equal to the length of tin, each entry of the result being either BL (for blank), ID (identifier), NUM (for number) or OP (for arithmetical operator). Identifiers are C-like identifiers, i.e., they begin with a letter and may contain letters or digits. Numbers are strings built from digits only.

The implementation of the specification above is concurrent inside each thread launched by the server. A thread starts a number of sub-threads equal to the length of the input text. The sub-thread i computes the output for the i-th entry of the input text. If the ith position of tin is a blank, a letter or an operator, then the corresponding sub-thread terminates returning respectively BL, ID, OP. Otherwise, i.e., if it is a digit, the corresponding sub-thread has to wait for the result of its left neighbor. If this latter computed BL, NUM, or OP, then the sub-thread returns NUM; otherwise it returns ID.
The model
We give in this subsection the O-PRS model of the server example described above. Note that to be able to model this server of concurrent lexers, we need all the operators “·”, “||”, and “ ”. Indeed, the two first operators model the server, and “ ” is needed to model the concurrency between the sub-threads: the order between them is important since each sub-thread corresponds to a position in the input arithmetical expression. Sub-threads work in parallel, but they maintain their ordering. Hence, the parallel operator || cannot be used here since it is commutative. Note also that in this example, at most two communications are done between sub- tasks. Therefore, our algorithms compute representatives of the exact reachability sets.
The JAVA code below corresponds to a concurrent server that launches a new thread that does the lexical analysis for each new client request. The number of launched threads is unbounded.
1	public void  se rve r () {
2	Socket s o c k e t ;
3	while( true ) {
4	try{
5	s o c k e t=s e r v e r S o c k e t . accep t ( ) ;
6	} catch  ( Exception e ){
7	System . e r r ( e ) ;
8	continue ;
9	}
10	Thread t=new Thread ( r unLexer Service ( s o ck et ) ) ;
11	t . s t a r t (); 
12	}
13	}
The entry point of the server is represented by the process variable X. The server is waiting for connections (line 5). If a request for connection arrives (process variable Y ), it may be successful (process variable T ) or erroneous (process variable F ). For successful connections (line 10), the server launches a thread in parallel (line 11, process variable L) and waits for another connection. In case of failures (lines 7–8), the server simply loops to wait for another connection.
The above server can be modeled by the following rules:

X → Y . X	server waits for a request for a connection
Y → T	successful request, Y returns true
Y → F		failure request, Y returns false T . X → X  L	new thread is launched if successful connection F → 0			request ignored if failure
The O-PRS model of each thread of the server (process variable L) is given below. The thread starts in parallel a number of sub-threads (process variable P ). The order in which these sub-threads are created is important since each of them corresponds to a position in the input arithmetical expression. Sub-threads work in parallel, but they maintain their ordering. Hence, we need to use the new operator
  to model the parallelism between these subthreads, since it preserves the order.
Each process P reads its input. If the character read is an operator, a blank or a letter, it returns directly the result (process variables OP, BL, ID). Otherwise, it had read a digit and it has to wait for the result of its left brother: if it is an operator, a blank or a number, then it returns NUM, if not, it returns identifier. The “ ” operator allows to model communications between neighbor sub-tasks. It is important to remark that at most two communications are done between sub-tasks. Therefore, our algorithms compute representatives of the exact reachability sets. Note also that to model this example, we needed all the operators of O-PRS (“·”, “||”, and “ ”).
L → BL  loop	start to create sub-threads
loop → loop  P	create sub-threads
loop → P	end of sub-thread creation
P → OP	sub-thread reads and returns an operator
P → BL		sub-thread reads and returns a blank P → ID	sub-thread reads a letter and returns identifier P → dig			sub-thread reads a digit
OP  dig → OP  NUM	digit sub-thread begins a number
BL  dig → BL  NUM
NUM  dig → NUM  NUM	digit sub-thread belongs to a number
ID  dig → ID  ID	digit sub-thread belongs to an identifier

5.3	The analysis
Our aim is to check that the lexical analysis is correct, i.e., that the lexer does not output terms having ID  NUM as subterms. The set of such terms can be rep-

Table 1
Experimental results for concurent lexer server.

resented by a finite tree automaton, and we need to check whether the intersection of the reachability set with these bad configurations is empty. To perform this, we applied our algorithms and we found that the intersection is indeed empty, which means that the program is correct. Indeed, our algorithms compute representa- tives of the exact reachability sets in this case since (1) the obtained model is an O-PAD, and (2) at most two communications are done between the ordered parallel processes.

Implementation and experiments
We implemented our algorithms in a tool called Press [22]. The input of the tool is an O-PRS model, a tree automaton describing the set of initial process terms, and a list of tree automata describing the target reachability process terms.

We used the Timbuk [17] library for the manipulation of tree automata.
Tim-

buk is written in Ocaml and provides all the functions we needed for tree automata.
Press has been applied to several academic examples and to the concurrent lexer server described previously. For this last example, we considered two models:
Server: full specification of the server of concurrent lexers with initial configu- ration X (process name corresponding to the entry point of the server), and
CLexer: one thread specification with the initial configuration L.
The experimental results obtained are given on Table 1. They have been ob- tained on a bi-processor Pentium with 4 Go of memory running on Linux. The execution time includes the computation of the set of reachable configurations, the minimization of this set, and its intersection with the target sets. However, in both cases, more than 90% of the execution time is taken by the reachability computation.

References
P.A. Abdulla, A. Bouajjani, B. Jonsson, and M. Nilsson. Handling global conditions in parameterized system verification. In CAV, LNCS, pages 134–145. Springer-Verlag, 1999.
P.A. Abdulla, B. Jonsson, M. Nilsson, and J. d’Orso. Algorithmic improvements in regular model checking. In CAV, volume 2725 of LNCS, pages 236–248. Springer-Verlag, 2003.
G. Andrews. Concurrent programming: principles and practice. Addison-Wesley, 1991.


A. Bouajjani, J. Esparza, S. Schwoon, and J. Strejcek. Reachability analysis of multithreaded software with asynchronous communication. In FSTTCS, volume 3821 of LNCS, pages 348–359. Springer-Verlag, 2005.
A. Bouajjani, J. Esparza, and T. Touili. A generic approach to the static analysis of concurrent programs with procedures. In POPL, pages 62–73. ACM, 2003.
A. Bouajjani, J. Esparza, and T. Touili. A generic approach to the static analysis of concurrent programs with procedures. Int. J. Found. Comput. Sci., 14(4):551–, 2003.
A. Bouajjani, J. Esparza, and T. Touili. Reachability analysis of synchronized pa systems. Electr. Notes Theor. Comput. Sci., 138(3):153–178, 2005.
A. Bouajjani, B. Jonsson, M. Nilsson, and T. Touili. Regular model checking. In CAV, volume 1855 of
LNCS, pages 403–418. Springer-Verlag, 2000.
A. Bouajjani, M. Mu¨ller-Olm, and T. Touili. Regular symbolic analysis of dynamic networks of pushdown systems. In CONCUR, volume 3653 of LNCS, pages 473–487. Springer-Verlag, 2005.
A. Bouajjani, A. Muscholl, and T. Touili. Permutation rewriting and algorithmic verification. In LICS. IEEE, 2001.
A. Bouajjani and T. Touili. Reachability analysis of process rewrite systems. In FSTTCS, volume 2914 of LNCS, pages 74–87. Springer-Verlag, 2003.
A. Bouajjani and T. Touili. On computing reachability sets of process rewrite systems. In RTA, volume 3467 of LNCS, pages 484–499. Springer-Verlag, 2005.
Sagar Chaki, Edmund M. Clarke, Nicholas Kidd, Thomas W. Reps, and Tayssir Touili. Verifying concurrent message-passing c programs with recursive calls. In TACAS, volume 3920 of LNCS, pages 334–349. Springer-Verlag, 2006.
H. Comon, M. Dauchet, R. Gilleron, F. Jacquemard, D. Lugiez, S. Tison, and M. Tommasi. Tree automata techniques and applications. Available on: http://www.grappa.univ-lille3.fr/tata , 1997.
J. Esparza and A. Podelski. Efficient algorithms for pre* and post* on interprocedural parallel flow graphs. In POPL, pages 1–11. ACM, 2000.
R. Gilleron and A. Deruyver. The reachability problem for ground TRS and some extensions. In
TAPSOFT, volume 351 of LNCS, pages 227–243. Springer-Verlag, 1989.
T. Genet. Timbuk. http://www.irisa.fr/lande/genet/timbuk/.
D. Lugiez and Ph. Schnoebelen. The regular viewpoint on PA-processes. In CONCUR, volume 1466 of LNCS, pages 50–66. Springer-Verlag, 1998.
R. Mayr. Decidability and Complexity of Model Checking Problems for Infinite-State Systems. PhD thesis, Munich University, 1998.
S. Qadeer and J. Rehof. Context-bounded model checking of concurrent software. In TACAS, volume 3440 of LNCS, pages 93–107. Springer-Verlag, 2005.
G. Ramalingam. Context-sensitive synchronization-sensitive analysis is undecidable. ACM Transactions on Programming Languages and Systems (TOPLAS), 22:416–430, 2000.
M. Sighireanu and T. Touili. The PRESS tool. http://www.liafa.jussieu.fr/∼sighirea/press/.
Tayssir Touili. Analyse symbolique de syst`emes infinis bas´ee sur les automates: Application a` la v´erification de syst`emes param´etr´es et dynamiques. PhD thesis, University Paris Diderot, 2003.
T. Touili. Dealing with communication for dynamic multithreaded recursive programs. In 1st VISSAS workshop. IOS PRESS, 2005. Invited Paper.
