Electronic Notes in Theoretical Computer Science 53 (2003)
URL:  http://www.elsevier.nl/locate/entcs/volume53.html  18 pages

Galois Connections in Categorial Type Logic

Carlos Areces a,1 ,2 Raffaella Bernardi b,3 Michael Moortgat b,4
a ILLC, University of Amsterdam, Amsterdam, The Netherlands
b UiL-OTS, University of Utrecht, Utrecht, The Netherlands


Abstract
The introduction of unary connectives has proved to be an important addition to the categorial vocabulary. The connectives considered so far are order-preserving; in this paper instead, we consider the addition of order-reversing, Galois con- nected operators. In §2 we do the basic model-theoretic and proof-theoretic groundwork. In §3 we use the expressive power of the Galois connected oper- ators to restrict the scopal possibilities of generalized quantifier expressions, and to describe a typology of polarity items.



Introduction
Categorial type logic provides a vocabulary of logical constants for the as- sembly of form and meaning in natural language. The binary product operator • captures the composition of grammatical parts, the residual implications = and \ express incompleteness with respect to the composi- tion relation. In [11,18] the categorial vocabulary has been extended with a pair of unary operators, 3 and its residual 2#. This addition greatly in- creases the analytical power of the categorial type language. In combina- tion with the binary connectives, the unary operators can be used as li- censing features, providing lexically anchored control over structural rea- soning. But already in the grammatical base logic NL(3), the unary con-

1 We would like to thank Dick Oehrle for the interesting discussions we had during his visit at the University of Utrecht about the relation between residuated and Galois con- nected operators, and Rajeev Gore´ for his constant help and prompt clarifications.
Email: carlos@science.uva.nl
Email:  Raffaella.Bernardi@let.uu.nl
Email: Michael.Moortgat@let.uu.nl
◯c 2003 Published by Elsevier Science B. V. Open access under CC BY-NC-ND license.


stants yield refinements of type assignments that would be over-generating without the 3; 2# decoration.
The 3; 2# connectives form a residuated pair, which means they are order-preserving operators with respect to the derivability relation. The algebraic structure of the base logic also provides roomfor a pair of order- reversing Galois connected operators, which in this paper we will write as 0·; ·0. To understand the relation between these two concepts, it may be useful to situate them in their natural algebraic context. Residuated and Galois connected pairs of mappings were studied in the work of Birkhoff [5] and Ore [20], among others. The relevance of this early work for current research on substructural logics has been emphasized by Michael Dunn, fromwhose [7] we draw the following definitions.
Definition 1.1 Consider two posets A = (A; ≤A) and B = (B; ≤B ), and functions f : A → B; g : B → A. The pair (f; g) is said to be residuated iff
[RES]	fa ≤B b iff a ≤A gb:
The pair (f; g) is said to be Galois connected iff
[GC]	b ≤B fa iff a ≤A gb:
Keeping the posets A and B distinct helps understanding the connection between residuated and Galois connected pairs of mappings. Let’s intro- duce a third poset B0 = (B; (≤B ) 1) where (≤B ) 1 = {(b; a) | a ≤B b}, and consider a function h : B → A. Following [RES] the functions f; h form a residuated pair iff the biconditional fa (≤B ) 1 b ⇔ a ≤A hb holds. But now, replacing (≤B ) 1 by ≤B , we obtain that b ≤B fa ⇔ a ≤B hb, i.e. the pair f; h is Galois connected with respect to the orders ≤B and ≤A. As Dunn [7] puts it, the Galois connected pair is obtained by turning around the inequality ≤B in the characterization of residuation.
When we cast this algebraic discussion in terms of categorial type log- ics the objects we will be considering are types, ordered by their deriv- ability relation. Galois connected operators have been also studied in the context of Linear Logic [12,1,9,21] where they are intended to exhibit negation-like behavior. This means that the Galois properties have to be mixed with extra features guaranteeing, for example, a double negation law 0(A0) = A = (0A)0. In related work, Jim Lambek [13,14] considers algebraic structures he calls pregroups, where each element a has a left and a right adjoint, written al and ar . Also in these structures, one has alr = a = arl . In this paper, we do not consider these stronger notions, but we concentrate on the pure Galois properties and investigate the ef- fect of adding 0·; ·0 to the base logic NL(3). We are interested in the base logic because we think it opens a window on the invariants of grammatical composition — the laws of the base logic are universals in the sense that they do not depend on structural postulates (that is, non-logical axioms).


The paper is organized as follows. In §2 we provide the basic model- theoretic and proof-theoretic groundwork. We show how the complete- ness result for the standard Kripke-style semantics for NL(3) can be ex- tended to the Galois connected operators, and how a cut-free Gentzen style presentation can be obtained. In §3, we turn to Beghelli and Stowell’s analysis of ways of scope taking [3] and to Giannakidou’s theory of polar- ity items distribution [8], to provide linguistic motivation for the Galois connected operators. We exploit the new derivability patterns introduced by the Galois operators to constrain the scopal possibilities of generalized quantifier expressions and describe a typology of polarity items. In this way we improve on the analysis of [4], which was given in terms of the residuated operators 3; 2#.


Formal preliminaries
Axiomatic presentation, completeness
There are two ways to extend the standard axiomatic presentation of NL(3) (see [19]) with Galois operators. The system NL(3,·0) can be obtained by extending NL(3) with the axioms (A1), (A2) and the rules (R1), (R2) below. It is easy to show that (GC) is a derived rule in this setting. Alternatively, one adds (GC) to NL(3). It can be shown then that (A1), (A2) and the rules (R1), (R2) are derivable.

(A1) ▶ A ⇒ 0(A0):
(A2) ▶ A ⇒ (0A)0:
(R1) From ▶ A ⇒ B infer ▶ B0 ⇒ A0: (R2) From ▶ A ⇒ B infer ▶ 0B ⇒ 0A:
(GC) ▶ A ⇒ 0B if and only if ▶ B ⇒ A0:

NL(3) has a Kripke-style semantics [10] which can be straightforwardly ex- tended to NL(3,·0). A model for NL(3,·0) is a tuple M = ⟨W; R3; R2; R2;V ⟩
1	2
where W is a non-empty set, R3  ⊆ W 3, R2  ⊆ W 2, and V is a valuation
V : PROP → 2W . The R3 relation governs the residuated triple •; \; =, the
R2 relation governs the residuated pair 3; 2#, while R2 governs the Ga-
1	2
lois connected pair ·0; 0·. For simplicity, in what follows we will restrict ourselves to models M = ⟨W; R;V ⟩ where R is the relation governing the Galois operators.
Given a model M = ⟨W; R;V ⟩ and m ∈ W we define

M;m   A0 iff ∀m0:(Rmm0 ⇒ M; m0 /   A):
M;m   0A iff ∀m0:(Rm0m ⇒ M; m0 /   A):


Given an arrow A ⇒ B, a model M = ⟨W; R;V ⟩ and m ∈ W , we say that
M;m |= A ⇒ B iff M;m   A implies M;m   B. M |= A ⇒ B iff for all
m ∈ W , M;m  A ⇒ B. We say that A ⇒ B is valid (notation |= A ⇒ B), iff for any model M, M |= A ⇒ B.
It is easy to show that the axioms (A1) and (A2) are true in all Kripke models, and that the rules (R1) and (R2) preserve validity, establishing soundness. For completeness, we can extend the formula-based canoni- cal construction for NL(3) (cf. [6,10]). The canonicalmodel Mc = ⟨W c; Rc;V c ⟩ has

W c = FORM (the set of all formulas in the language);
¬Rc AB iff ▶ A ⇒ B0; and
A ∈ V c (p) iff ▶ A ⇒ p:

Notice that we define when two elements of W are not related by R. This, of course, defines also which elements are related. But we can do even better than Mc . Given an arrow A ⇒ B, we can restrict W c to be simply W c = Sub(A) ∪ Sub(B) (the set of subformulas of A and B) and prove the following truth lemma.

Lemma 2.1 (Truth Lemma) Given A ⇒ B, then for all A0 ; B0  ∈ Sub(A) ∪
Sub(B) Mc ; A0   B0 iff ▶ A0 ⇒ B0 :

With this lemma, we can prove completeness with respect to a class of finite models, and hence obtain also decidability (actually, even an upper bound on complexity).

Proof. The proof proceeds by induction on the complexity of the conse- quent formula. For B ∈ PROP, Mc ;A  B iff A ∈ V c(B) iff, by definition of V c , ▶ A ⇒ B. We assume as induction hypothesis (IH) that the lemma is true for formulas of lower or equal complexity than B.
We consider 0B (the case for B0 being even simpler).
[⇒] direction. Mc;A 0B iff for all B0 ∈ W c if Rc B0 A then Mc ; B0 /  B. By contraposition and definition of Rc , for all B0 , Mc; B0 B implies ▶ B0 ⇒ A0. By definition of W c , B0 is in Sub(A) ∪ Sub(B) and we can apply IH to obtain that for all B0 ∈ W c , ▶ B0 ⇒ B implies ▶ B0 ⇒ A0. In particular,
B ∈ W c and by (REFL) ▶ B ⇒ B, hence ▶ B ⇒ A0. By (GC), ▶ A ⇒ 0B.
[⇐] direction. Assume ▶ A ⇒ 0B to prove Mc;A  0B. Take B0 such that Rc B0 A, we should prove Mc; B0 /  B. Notice that by definition of Rc , we have that /▶ B0 ⇒ A0. For contradiction, suppose Mc ; B0   B, then by IH,
▶ B0 ⇒ B, but then we can prove ▶ B0 ⇒ A0 as follows





▶ A ⇒ 0B
0
▶ 0B ⇒ 0B0  (R2)

0  0	(TRANS)
(GC)
(1)


▶ B0 ⇒ A0
2
Theorem 2.2 (Completeness) Given A ⇒ B, then |= A ⇒ B implies ▶
A ⇒ B.
Proof. Suppose /▶ A ⇒ B. Then by Lemma 2.1 Mc;A / B. As Mc;A  A, we have Mc |= A ⇒ B and hence |= A ⇒ B.	2
As we already said, Lemma 2.1 actually establishes a strong finite model property (an arrow A ⇒ B is valid iff B is satisfied in Mc ; A, a (pointed) model whose size is polynomial in |A| ∪ |B|). From this, an NP upper bound in the complexity of the validity problem for NL(3,·0) follows.
Theorem 2.3 Given A ⇒ B ∈ NL(3,·0), deciding whether A ⇒ B is valid can be done in non-deterministic polynomial time.

Gentzen presentation, cut-elimination
In this section, we extend the Gentzen presentation of NL(3) of [18] to NL(3,·0). We show that the Cut rule can be eliminated, yielding decidable proof search. Our Gentzen presentation has sequents  ⇒  , with  ;  ∈
STRUC. Structures are defined as STRUC ::= FORM | [STRUC | ]STRUC,
with structural connectives [ and ] matching the logical connectives 0· and
·0, respectively.
In [9,21], the proof theory for the Galois connected operators is given in the framework of Display Calculus. [2] shows how to move from display calculus to a Gentzen calculus for (unary and binary) residuated and Ga- lois connected operators. In display calculus, [ and ] are related by (DGC) (the structural counterpart of (GC))  ⇒ [ iff  ⇒ ] , which makes it possible to give the following logical rules for the connectives:



   ⇒ A  (D1)	  ⇒ A  (D2)	  ⇒ [A (D3)
(D4)	(2)

0A ⇒ [ 
A0 ⇒ ] 
  ⇒ 0A
  ⇒ A0


In the Gentzen presentation, we want to compile away (DGC) (and part of the Cut rule) in the logical rules. Because the Galois operators are order- reversing, we have to distinguish positive and negative contexts in the statement of the Cut rule. We write [ ] for a structure with a substruc- ture  in an isotone position (dominated by an even number of structural connectives), and  {  } for a structure  with  in an antitone position


(dominated by an odd number of structural connectives). In (3) we give the four instances of the Cut rule we have to consider.


  ⇒ A	 [A] ⇒  0


 [ ] ⇒  0

  ⇒ A	  0 ⇒  {A}


  0 ⇒  {  }
(C1)



(C3)
  0 ⇒ [A]	A ⇒ 


  0 ⇒ [ ]

 {A}⇒  0	A ⇒ 


 {  }⇒  0
(C2)



(C4)


(3)

The left introduction logical rules below are as in the display calculus pre- sentation, the right introduction rules compile in an application of (DGC).



   ⇒ A  (0·L)	  ⇒ A  (·0L)	(0·R)	 A ⇒ [  (·0R)	(4)

0A ⇒ [ 
A0 ⇒ ] 
  ⇒ 0A
  ⇒ A0


The logical rules in (4) swap around antecedent and succedent of a se- quent. For cut elimination to go through, we also need contextual versions of the rules, compiling in the axiom schemata (A1)/(A2) with (C2)/(C4), and the complementary rules (L ), (R+) replacing the logical connectives by their respective structural counterparts.


 {A}⇒ 


 {]0A}⇒ 
(0·L+)	 {A}⇒ 
 {[A0}⇒ 

(·0L+ )	(5)



  ⇒ [A]


  ⇒ []0A]
(0·R  )	  ⇒ [A]
  ⇒ [[A0]

(·0R  )	(6)

We will call Seq-NL(3,·0) the Gentzen presentation of NL(3,·0), to distin- guish it fromits Hilbert presentation Hil-NL(3,·0).
Theorem 2.4 (Cut elimination) In Seq-NL(3,·0), every valid sequent A ⇒
B has a cut-free proof.
The proof proceeds by induction on the complexity of the Cut inferences. Below, we present the principal cases of the cut elimination transforma- tion: the cases where a cut on a complex cut formula is replaced by a cut on its subformula, thus decreasing the complexity. The other cases follow the same ideas.
In (7) and (8), isotone cuts (C1; C3) on the complex formula A0 are re- placed by antitone cuts (C4; C2). Similarly for cuts on 0A. (We use double lines for the instantiation of the premise that makes a logical rule applica- ble.)




Γ{A}⇒ ∆0
0
(·0L+)

A ⇒ b∆
(·0R)
Γ{b(A )}⇒ ∆0

∆ ⇒ A0

Γ[∆] Γ
Γ[A0] ⇒ ∆0
(C1)
⇒ ∆0
;
0

Γ{A}⇒ ∆0	A ⇒ b∆ Γ{b∆}⇒ ∆0
(7)
(C4)



A ⇒ b∆
∆ ⇒ A0
(·0R)
∆0
∆0 ⇒ Γ[A]
∆0 ⇒ Γ[b(A0)]
∆0 ⇒ Γ{A0}
(·0R  )
(C3)
∆0 ⇒ Γ[A]	A ⇒ b∆
(8)


⇒ Γ{∆}		 (C2)

∆0 ⇒ Γ[b∆]
;	∆0 ⇒ Γ[b∆]

In (9) and (10), antitone cuts (C4; C2) are replaced by isotone cuts (C1; C3).




Γ{ A}⇒ ∆0
Γ{A0}⇒ ∆0
(·0L  )
∆ ⇒ A
A0 ⇒ ∆
(·0L)
∆ ⇒ A	Γ{ A}⇒ ∆0

(9)

Γ{ ∆}⇒ ∆0	(C4)	;	Γ{ ∆}⇒ ∆0	(C1)


∆0 ⇒ Γ[ A]
∆0 ⇒ Γ[A0]
(·0R+)
∆ ⇒ A
A0 ⇒ ∆
(·0L)
∆ ⇒ A	∆0 ⇒ Γ[ A]
(10)

∆0 ⇒ Γ[ ∆]	(C2)	;	∆0 ⇒ Γ[ ∆]	(C3)
Soundness and completeness of Seq-NL(3,·0)
We start by proving the following.
Proposition 2.5 Let M = ⟨W; R;V ⟩ be a model, and m ∈ W then
M;m |=  ⇒  0 [A] and |= A ⇒ B then  ⇒  0 [B].
M;m |=  [A] ⇒  0 and |= B ⇒ A then [B] ⇒  0 .
M;m |=  ⇒  0 {A} and |= B ⇒ A then  ⇒  0 {B}.
M;m |=  {A}⇒  0 and |= A ⇒ B then  {B}⇒  0 .
Proof. By induction on the number of operators surrounding A.	2
Now define the following forgetting function.


Definition 2.6 We define the following translation Tr : STRUC → FORM
as follows,
Tr(p) = p for p ∈ PROP
Tr(0(A)) = 0(Tr(A)) Tr([(A)) = 0(Tr(A))
Tr((A)0) = (Tr(A))0 Tr(](A)) = (Tr(A))0:
Theorem 2.7 (Soundness of Seq-NL(3,·0)) The sequent presentation of the logic NL(3,·0) is sound.
Proof. Given a rule
 A ⇒ B 
C ⇒ D
we prove that if |= Tr(A) ⇒ Tr(B) then |= Tr(C) ⇒ Tr(D), and similarly for rules with two premises.
Notice that Proposition 2.5 proves soundness of the Cut rules. For rules (0·R), (·0R), (0·L) and (·0L) use the fact that the (GC) rule is sound. For rules (0·R ), (·0R ), (0·L+ ) and (·0L+) use Proposition 2.5 plus the fact that axioms (A1) and (A2) are valid.	2
Theorem 2.8 (Equivalence of Seq-NL(3,·0) and Hil-NL(3,·0)) If A ⇒ B is a theorem of Hil-NL(3,·0) then there is a proof of A ⇒ B in Seq-NL(3,·0). And for every proof of a sequent  ⇒  in Seq-NL(3,·0), Tr( ) ⇒ Tr( ) is a theorem of Hil-NL(3,·0).

Linguistic application
Now that the logical properties of NL(3,·0) have been explained in detail, let us turn to its linguistic application. In order to explore the possible uses of the Galois unary operators it is important to look at the new properties they introduce. As we pointed out in the beginning, these new operators differ from the residuated ones in their monotonicity properties, and in their derivability relation with respect to their argument when consider- ing their composition (viz. while A derives both (0A)0 and 0(A0), it derives
2#3A but not 32#A).
If we consider complex types as composition of functions, we realize that having at our disposal downward monotonic operators gives a way to modify the polarity position of their arguments. For example, if we con- sider the composition of 0· with the binary function =, which is positive in its first argument and negative in the other, we see that their monotonic properties are reversed. More specifically, if 0A composes with B=· giv- ing B=0(A), A will be in a positive position, and if it composes with ·=B, resulting in 0(A)=B, A will be in a negative position. Since the monotonic- ity properties of the connectives govern the derivability relation among


types, having added the Galois operators increases the connections be- tween types which is the main feature of categorial type logic.
In the next part of this section we will show how to use the derivability patterns between the types of NL(3,·0) to account for the different distri- bution of generalized quantifiers with respect to negation and to describe a typology of polarity items.

Generalized Quantifiers Scope
We start with an example of how to account for scope phenomena using the composition of the Galois operators and the fact that (0s)0←→ 2#3s, where A −→ B means that the formula is a tautology, viz. A −→ B iff
|= A ⇒ B.
A well known problem of general quantifiers expressions (GQs) in the categorial literature is the proper characterization of an in situ binding op- eration such as required for the scope possibilities of GQs. In [17]a “scop- ing constructor” operator q(A; B; C) is introduced to capture this behav- ior. A GQ is assigned the type q(np; s; s) because it acts locally like a noun phrase but takes scope semantically at a higher sentential level. The logi- cal rule governing this operator is:
 [A] ⇒ B	 [C] ⇒ D

 [ [q(A; B; C)]] ⇒ D
(qL):

The introduction of this connective raises a number of model-theoretical and proof-theoretical questions which have been addressed in [16], where it is shown that the q connective can be obtained as a defined operator of standard categorial type systems, and the above (qL) rule as a derived rule of inference. The solution there proposed can be further simplified, but for reason of space we cannot go in the detail of this aspect.
The scoping constructor q is intended to provide the full set of com- binatorially possible scope relations in a multiple quantifier context — in that sense, it could be seen as the deductive version of May’s [15] Scope Uniformity thesis. Beghelli and Stowell [3] have convincingly shown that GQs have non-uniformscope possibilities. The main claimof their theory is that, for certain combinations of quantifier types, the natural language grammar simply excludes certain logically possible scope construals. In our setting this requires type-refinement of the subtypes of a q(np; s; s) as- signment.
A first analysis following these ideas was provided in [4]. In this pa- per, the derivability relation, 32#s −→ s −→ 2#3s is used to distinguish three different sentential levels: the one lower than negation (32#s), the negative one (s), and the one higher than negation (2#3s). The different distribution of GQs like every N, a N and some N, with respect to these sentential levels is encoded in their type assignments.


However, the linear derivability relation given by a pair of residuated operators, is not enough to account for more complex linguistic phenom- ena. For example, the type assignment proposed in [4] could not block the occurrences of negative polarity expressions like any N in a positive sentence.
We will show by means of an example, how we can use the type (0s)0 to solve this problemand how the different scope possibilities of positive vs. negative polarity items can be accounted for. Let’s start with the lexicon entries we are interested in.

The occurrence of any in a positive context, e.g. anybody left, is blocked as shown by the proof below (as (0s)0 −→ 2#3s cannot be derived in the calculus):

np ⇒ np	s ⇒ (0s)0
np • np\s ⇒ (0 s)0	(\L)
q(np; (0s)0; (0 s)0) • np\s ⇒ 2#3s



(qL)

The ungrammaticality of, e.g., anybody didn’t leave is proved in a similar way.
We now turn to the non-uniform behavior of polarity items with re- spect to negation. The combination of GQ and negation gives rise to scope ambiguity, which in type logic grammars corresponds to multiple proofs. In the case of polarity items (PI) not all the logical possibilities are allowed. In particular, negative PI will allow only for the reading with the negation having wide scope (¬GQ), while positive PI will produce the reading with negation having narrow scope (GQ¬). The proof-schemata in Figures 2 and 3 illustrate how the lexicon entries above correctly predict these lin- guistic phenomena.
When instantiating the quantifier q(np; s1; s2) with a positive polarity item like some book, e.g. John didn’t read some book, the proof-schema in Figure 2 will fail, while the one in Figure 3 will not. Applying the type assigned above to some book, q(np; 2#3s; 2#3s), the sentential types of the quantifier, s1; s2, will both be instantiated with 2#3s. Therefore in Figure 2
the derivation s2 −→ (0 s)0 will fail (as 2#3s −→ (0s)0 ). While both the displayed derivations in Figure 3 will be provable, viz. s −→ 2#3s and
2#3s −→ 2#3s.
On the other hand, when considering the derivations as a proof of John didn’t read any book, the sentential types assigned to the negative polarity item any book, will be s1 = s2 = (0 s)0, which give the correct derivations s −→ (0s)0 and (0s)0 −→ (0s)0 in Figure 2, and block the derivation in


Figure 3 with (0s)0−→ 2#3s.
These simple examples show that different scope distribution exhib- ited by items which belong to the same syntactic category can be accounted for by means of derivability patterns among types. More precisely, the unary operators (3; 2#;0 ·; ·0) provide a way to encode the different fea- tures which characterizes items of the same category. In the above ex- amples we have used only a small part of the rich pattern of types at our disposal in NL(3,·0). The picture in Figure 1 summarizes some of the re- lations we have. Note that these relations can be further extended with a third level since besides the derivation A −→ (0A)0, A −→ 0(A0) holds as well. In the next pages we will refer to the types using the corresponding abbreviations si given in Figure 1.



















0 : (02#3s)0

  6@I
	@
	@
@
@

0 : (02#332#s)0 
2#3s
q
0 : (0s)0
q

6@I
@
@ 
@I	 6
@	 
@ 


s4 : 2#332#s
  @	 @
@		@
@	@ s

0
@I	1
: (q 032#s)0	q

@
@
@
@
@ 
s1 : 32#s

Fig. 1. Some derivability patterns in NL(3,·0)








np ⇒ np
np ⇒ np
np • np\s ⇒ s

(\L)






np • ((np\s)=np •

) ⇒ (0s)0
(qL)


np ⇒ s=(np\s)	s ⇒ 2#3s

(np\s)=np • q(np; s ;s ) ⇒ np\(0 s)0	(\R)
(\L)
np • (s=(np\s))\s ⇒ 2#3s

np •(((s=(np\s))\s)=(np\(0s)0) •((np\s)=np • q(np; s ;s ))) ⇒ 2#3s	(=L)

|{z}
subject
|	{z	}
negation
|	{z	}
trans. verb
|	{z	}
gen. quantifier

Fig. 2. Wide scope negation (¬GQ)




s ⇒ (0s)0	np ⇒ np
np\s ⇒ np\(0 s)0	(\R; L)

np • (s=(np\s))\s ⇒ s1

(\L)

np ⇒ np
np • (((s=(np\s))\s)=(np\(0s)0) • np\s) ⇒ s
(=L)

np • (((s=(np\s))\s)=(np\(0s)0) • ((np\s)=np • np)) ⇒ s
(=L)

(qL)

np •(((s=(np\s))\s)=(np\(0s)0) •((np\s)=np •	)) ⇒ 2#3s

|{z}
subject
|	{z	}
negation
|	{z	}
trans. verb
|	{z	}
gen. quantifier

Fig. 3. Narrow scope negation (GQ¬)

In the remaining part of the paper we show how the above derivability pat- terns give a precise way to (i) gain a deeper understanding of the typology of polarity items proposed in the literature of formal linguistics; (ii) clarify the consequences predicted by the typologies, opening the way to further investigations; (iii) carry out cross-linguistic comparisons. In particular we will look at the typology of Greek polarity items discussed in [8] and compare it with Italian data and types.

A typology of polarity items in NL(3,·0)
Extending the results presented in [23,22] Giannakidou gives in [8] an in depth analysis of polarity items in terms of sensitivity to (non)-veridicality
— where, intuitively, a non-veridical expression NV is such that when com- posed with a proposition p it does not entail that p is true. Besides the standard distinctions we introduced above between negative and positive polarity items, she gives evidence for a further classification among items of the former group. For reasons which will become clear soon, she refers to the whole group as affective PI (API) leaving the adjective “negative” to denote a particular kind of API. The polarity items which do not be- long to API are considered as positive polarity items (PPI). We now roughly present the theory and sketch its typological account.
To give a categorial type logic (CTL) analysis of polarity items the main observations to keep in mind are the following. (a) Episodic sentences (E) can be either veridical or non-veridical, where the difference is marked by the occurrences of veridical vs. non-veridical expressions (e.g. now vs. may, respectively). (b) Among the non-veridical expressions we can dis- tinguish the subset of the anti-veridical ones (AV) which are negation-like operators (e.g. without, does not). (c) Among the affective polarity items we have to differentiate negative polarity items (NPIs) which are defined as the items which require to be the argument of AV, and APIs which are felicitous also within the scope of NV. In CTL terms (a) means that the ap- plication of NV (and therefore AV) expressions will return an episodic sen- tence; (b) means that the type of AV must derive the type of NV; (c) says that APIs are of a weaker type than NPIs, hence the type assigned to API must derive the one of NPI. Let us illustrate this by means of the deriva- tions sketched below.
Let NV ∈ E=P I; AV ∈ E=NP I and E=NP I −→ E=P I, then


AV ∈ E/N PI	NPI ∈ NPI


AV ◦ NPI ∈ E
NV ∈ E/PI	API ∈ AP I


NV ◦ API ∈ E



AV ∈ E/N PI


AV ∈ E/AP I	PI ∈ AP I
NV ∈ E/AP I


NV ∈ E/N PI
[∗]
NPI ∈ NPI

AV ◦ API ∈ E	 NV ◦ NPI ∈ E


The derivations show that if we assign to AV and NV types governed by the relations above, then an anti-veridical expression will compose both with a NPI and with an API, but a non veridical operator will not compose with
NPI (as the inference in [*] fails). Due to the logical properties of the =, E=AP I—→ E=NP I implies NP I—→ AP I and E=NP I —→ E=AP I means AP I —→ NP I. Therefore point (c) simply follows from (b).
More formally, this simple fact can be expressed using (one of ) the derivability relations given in Figure 1. But the cube offers a much richer hierarchy of types which will allow us to make more fine-grained distinc- tions among polarity items as actually is required by the linguistic data. We look at the Greek data presented in [8] and to Italian data for a cross- linguistic analysis. In Giannakidou’s analysis free choice items (FCIs) are shown to be sensitive to (non)-veridicality, and in particular to be a spe- cial case in the group of affective polarity items. We will include them in our data. In the examples below the licensing operator is emphasized and the licensed item is underlined. The > stands for the scope distribution,
e.g. Neg > API means Neg has scope over API.
Greek
NPI: ipe leksi, API: kanenan, FCI: opudhipote
Dhen idha kanenan.	Neg > API (tr. I didn’t see anybody)
Dhen ipe leksi oli mera	Neg > NPI (tr. He didn’t say a word all day)
*Dhen idha opjondhipote	*Neg > FCI (tr. I didn’t see anybody)
Opjosdhipote fititis bori na lisi afto to provlima.	Modal > FCI (tr. Any student can solve this problem.)
An dhis tin Elena [puthena/opudhipote], :::	Cond > API/FCI (tr. If you see Elena anywhere, :: :)
An pis leksi tha se skotoso.	Cond > NPI (tr. If you say a word, I will kill you)
For the reasons discussed above the following types will correctly predict these data. For completeness we include also the type for the PPI kapjos (tr. somebody).

Lexicon

PPI: q(np; s ;s ), kapjos	NPI: np\s0 , ipe leksi
4	4	2
API: q(np; s0 ; s0 ), kanenan	FCI: q(np; s0 ; s0 ), opudhipote
1	1	4	4
modal: (((s0 =np)\s0 )\s )=(np\s0 ), bori	neg.: (np\s )=(np\s0 ), dhen
4	4	1	4	1	2
cond.: (s =s0 )=s0 , an
1	1	3
We can compare the Greek data and types with the Italian ones.
Italian
NPI: nessuno, API:mai, FCI: chiunque
Non gioco mai	Neg > API
(tr. I don’t play ever)
Non ho visto nessuno	Neg > NPI (tr. I haven’t seen anybody)
*Non ho visto chiunque	*Neg > FCI (tr. I haven’t seen anybody)
Chiunque puo` risolvere questo problema	Modal > FCI (tr. Anybody can solve this problem)
*Puoi giocare mai	*Modal > API (tr. You can play ever)
*Puoi prendere in prestito nessun libro	*Modal > NPI (tr. You can borrow any book)
Se verrai mai a trovarmi, :::	Cond > API (tr. If you ever come to visit me, :: :)
Lexicon

PPI: q(np; s ;s ), qualcuno	NPI: q(np; s0 ; s0 ), nessuno
4	4	2	2
API: (np\s )\(np\s0 ), mai	FCI: q(np; s00 ; s00 ), chiunque
1	1	4	4
modal: (((s00 =np)\s00 )\s )=(np\s00 ), puo`	neg.: (np\s )=(np\s0 ), non
4	4	1	4	1	2
cond: (s =s0 )=s0 , se
1	1	4
The reader is referred to [8] for the complete analysis of the Greek data.

We summarize the results in the table below comparing it with the Italian ones.

Finally, the lexicon type assignments given for Greek and Italian can be summarized as follows:
Cond




 
FCI/Modal
q
q
  6I@
 



q
@
@
@
@
NPI/Neg
q



 
Cond 
q
  6@I
	@
@
@
@
q



NPI/Neg
q

6@I
@
I@	 6
@	 
6I@
@
@I	 6
@	 

@	@ 
  @	 @
@	@ 
  @	 @

PPI
q
@	@
@	@
PPI
q
@	@
@	@

I@	6API
@
@
@	 
@	 
@I	6API
@
@
@	 
@	 

@	FCI/Modal ?	@ 


Greek	Italian
From this comparison the following conclusions can be drawn: (i) there could be contexts where both PPI and API are felicitous (e.g. conditionals and modal operators); (ii) there could be non-veridical operators which do not license polarity items (eg. in Italian FCI are not allowed in condi- tionals), (iii) there can be other sorts of polarity items sensitive to these and to other kinds of non-veridical expressions.

Conclusions
In this paper, we have focused on the minimal implementation of Galois connected operators in the base logic, and shown how this minimal addi- tion enhances the accuracy of the grammatical logic.
An obvious topic for further research is the communication between the Galois operators and the unary and binary residuated families.

Another interesting direction is to investigate which is the true impact of the addition of order-reversing operators to the categorial types. In the main linguistic application in §3 we made use only of the composition of Galois operators (0(·))0 0((·)0) which are in themselves order-preserving operators.
Furthermore, our search for the right lexical type assignments suggests
a possible connection between non-verdicality and (0· ·0), and veridicality
and (2#; 3). This might shed light on the understanding of the semantic interpretations of these operators when used to reason with linguistic re- sources.

References
Abrusci, V., Phase semantics and sequent calculus for pure noncommutative classical linear propositional logic, The Journal of Symbolic Logic 56 (1991),
pp. 1403–1451.
Areces, C. and R. Bernardi, Analyzing the core of categorial grammar, in:
P. Blackburn and M. Kohlhase, editors, Proceedings of ICoS-3, 2001, pp. 7–28.
Beghelli, F. and T. Stowell, Distributivity and negation: The syntax of each and every, in: A. Szabolcsi, editor, Ways of Scope Taking, Kluwer, 1997 pp. 72–107.
Bernardi, R. and R. Moot, Generalized quantifiers in declarative and interrogative sentences, in: Proceedings of ICoS-2, Dagstuhl, 2000, pp. 1–15.
Birkhoff, G., “Lattice Theory,” American Mathematical Society, Providence, 1940, 1948, 1967.
Dosˇen, K., A brief survey of frames for the Lambek calculus, Zeitschrift fu¨r mathematischen Logik und Grundlagen der Mathematik 38 (1992), pp. 179– 187.
Dunn, J., An abstraction of Galois connections and residuation with application to negation and various logical operations, in: JELIA 1990. Proceedings of the European Workshop on Logics in Artificial Intelligence, 1991, pp. 31–51.
Giannakidou, A., “The landscape of polarity items,” Ph.D. thesis, University of Groningen (1997).
Gore´, R., Substructural logics on display, Logic Journal of the IGPL 6 (1998),
pp. 451–504.
Kurtonina, N., “Frames and labels. A modal analysis of categorial inference,” Ph.D. thesis, OTS Utrecht University, ILLC Amsterdam University (1995).
Kurtonina, N. and M. Moortgat, Structural control, in: P. Blackburn and
M. de Rijke, editors, Specifying syntactic structures (Amsterdam, 1994), CSLI Publications, Stanford, CA, 1997 pp. 75–113.

Lambek, J., From categorial to bilinear logic, in: K. Dosˇen and P. Schro¨der- Heister, editors, Substructural Logics, Oxford University Press, 1993 pp. 207– 237.
Lambek, J., Type grammar revisited, in: Logical aspects of computational linguistics (Nancy, 1997), Springer, Berlin, 1999 pp. 1–27.
Lambek, J., Type grammars as pregroups, Grammars 4 (2001).
May, R., “The grammar of quantification,” Ph.D. thesis, MIT (1977).
Moortgat, M., In situ binding: A modal analysis, in: P. Dekker and M. Stokhof, editors, Proceedings of the Tenth Amsterdam Colloqium, ILLC, 1995, pp. 539– 549.
Moortgat,	M.,	Generalized	quantification and discontinuous type constructors, in: H. Bunt and A. van Horck, editors, Discontinuous Constituency, Mouton de Gruyter, Berlin, 1996 pp. 181–207.
Moortgat, M., Multimodal linguistic inference, Journal of Logic, Language and Information 5 (1996), pp. 349–385.
Moortgat, M., Categorial type logics, in: J. van Benthem and A. ter Meulen, editors, Handbook of Logic and Language, The MIT Press, Cambridge, Massachusetts, 1997 pp. 93–178.
Ore, O., Galois connections, Transactions of the American Mathematical Society 55 (1944), pp. 493–513.
Restall, G., “An introduction to substructural logics,” Routledge, 2000.
van der Wouden, T., “Negative contexts,” Ph.D. thesis, Unversity of Groningen (1994).
Zwarts, F., Nonveridical contexts, Linguistic Analysis 25 (1995), pp. 286–312.
