Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 319 (2015) 37–49
www.elsevier.com/locate/entcs

Representation of Partial Traces
Marc Bagnol
Department of Mathematics and Statistics – University of Ottawa

Abstract
The notion of trace in a monoidal category has been introduced to give a categorical account of a situation occurring in very different settings: linear algebra, topology, knot theory, proof theory. . . with the trace operation understood as a feedback operation.
Partially traced categories were later introduced to account for cases where the trace is not always defined, and it was shown that partially traced category can always be seen as a subcategory of a totally traced one. We give a new proof of this representation theorem, using a construction that is different from the original one. However, since they satisfy the same universal property they are naturally isomorphic.
Keywords: monoidal category, trace, feedback, representation theorem.


Introduction
Traced monoidal categories were introduced by A. Joyal, R. Street and D. Verity [9] as a common categorical axiomatization of a structure that occurs in very different settings such as linear algebra, topology, knot theory, proof theory. . . In particular, traced monoidal categories constitute the basis of the categorical approach [1,5] to J.-Y. Girard’s geometry of interaction program [3].
The basic idea is that a trace is an operation associating to any f : A⊗U → B⊗U in a monoidal category, a new morphism TrU (f ) : A → B , this operation being understood as a feedback along U , which is acknowledged in the graphical language for these categories [9] by depicting TrU (f ) as




A	B

This operation has to satisfy a number of axioms that capture formally what is expected of such a notion of feedback.

http://dx.doi.org/10.1016/j.entcs.2015.12.004 1571-0661/© 2015 Published by Elsevier B.V.
This is an open access article under the CC BY-NC-ND license (http://creativecommons.org/licenses/by-nc-nd/4.0/).

More recently, E. Haghverdi and P. J. Scott [6] introduced the notion of partial trace, accounting for the fact that the trace operation can be only partially defined. This is a situation that occur very naturally in practice: think of the trace in infinite- dimensional Hilbert spaces 1 or feedback loops in synchronous circuits, for instance. Later on, O. Malherbe, P. J. Scott and P. Selinger [11] showed a representation theorem for partial traces, relating them to total traces: any partially traced category embeds in a totally traced one, with an embedding reflecting the partial trace. Their construction is based on P. Freyd’s paracategories [7] and a partial version of the Int(·) construction [9]. It enjoys a universal property factoring any functor reflecting the partial trace structure.
In this article, we will give a new proof of this result, via a different construction based on tools used in the categorical approach to equivalence of automata [2]. Our proof is more straightforward and does not rely on a delicate argumentation about partially defined operations. As a consequence, the formulation of the universal property we obtain is also more direct as it does not involve compact closed categories as an intermediate step. However, the two constructions satisfy in the end the same universal property that can be rephrased as being left adjoint to the identity functor (they are “free constructions”). Because adjoints are unique up to natural isomorphism, the two construction must be naturally isomorphic.

Outline of the article
In section 1 we fix the notations and vocabulary used in the rest of the article; we recall the definition of a partially traced category, and the associated notion of traced functor.
We then introduce in section 2 the key ingredient of our construction: the dialect construction, that allows morphisms to have private interfaces. With this construction comes a hiding operation which sets the basis for total extensions of partial traces.
A congruence is then defined in section 3 and its interplay with the monoidal and traced structures is explored. We will show that quotienting the dialect category by this equivalence turns the hiding operation into a total trace (section 3.1).
In section 3.2 and section 4.1, we will show that the original partially traced category embeds in this quotiented category, via an embedding reflecting the partial trace. Finally, we show that our construction enjoys the expected universal property in section 4.2.

Partially traced categories
We begin by setting notations and recalling some background definitions.
Notation 1.1 We write the composition of morphisms in a category in the usual order, omitting the ◦ symbol: if we have f : A → B and g : B → C then

1 Although this case actually fails to satisfy axiom (v) of definition 1.5 and would need a relaxing of the framework (and a non-trivial, if possible, adaptation of our proof of the representation theorem) to be considered as a partial trace in the categorical sense.

gf : A → C . We may also omit the parenthesis when applying functors to objects and morphisms: if we have F : C → D and f : A → B in C , then Ff : FA → FB .
When manipulating two categories with similar operations, we will use subscripts to indicate in which category an operation occurs when not clear from the context.
Definition 1.2 A monoidal category is a category C together with a bifunctor
⊗ : C× C → C and a distinguished object 1 satisfying:
	The functor ⊗ is associative: for any objects A, B, C of C , A ⊗ (B ⊗ C) = (A⊗B) ⊗C , which we then write A⊗B⊗C , and the same holds for morphisms.
The object 1 is neutral: for any object A, A ⊗ 1 = 1 ⊗ A = A, and Id1 ⊗ f =
f ⊗ Id1 = f for any f .
It is called a symmetric monoidal category if it enjoys a natural family of isomorphisms
σA,B : A ⊗ B → B ⊗ A such that σ—1	= σA,B and σA⊗B,C decomposes as
σA⊗B,C = (σA,C ⊗ IdB)(IdA ⊗ σB,C).
Remark 1.3 We consider, as in the work of O. Malherbe, P. J. Scott and P. Selinger [11], the strict variant of symmetric monoidal categories to work with lighter notations. This is relatively harmless since any symmetric monoidal category is equivalent to a strict one [10] and hence our results can be extended (with a bit of extra work) in a non-strict setting building upon this this equivalence.
As we will manipulate operations that are only partially defined, we will use the Kleene equality notation to describe situations where one of the two equated expressions might be undefined.
Notation 1.4 When handling equality between potentially undefined expressions, we will use the following notations:
E −~− Ej means that if E is defined, then Ej is and in that case E = Ej .
E −-− Ej means that if Ej is defined, then E is and in that case E = Ej .
E  Ej means that E is defined if and only if Ej is and in that case E = Ej . When both sides are always defined, we simply write E = Ej .
Let us now introduce the notion of partial trace in a symmetric monoidal category. As mentioned in the introduction, an intuitive way to understand it is to think of a feedback operator. Most of the axioms are very natural from that perspective, especially if written in the associated graphical language [9], see fig. 1.
Definition 1.5 [11] A partial trace in a symmetric monoidal category is a partially defined operation on morphisms (parametrized by an object U and two objects A, B which we leave implicit) TrU [·] that inputs a morphism f : A ⊗ U → B ⊗ U and outputs (when defined) TrU [f ] : A → B .
It must satisfy the following axioms:
Superposing: for all f : A ⊗ U → B ⊗ U and g : C → D , we have
TrU [f ] ⊗ g −~− TrU [f ⊗ g]

Tightening: for all f : A ⊗ U → B ⊗ U , g : Aj → A and h : B → Bj , we have
h TrU [f ] g −~− TrU (h ⊗ IdU )f (g ⊗ IdU ) 

Sliding: for all f : A ⊗ Uj → B ⊗ U and g : U → Uj , we have
TrU f (Id ⊗ g)   TrU′ (Id ⊗ g)f 
Vanishing: for all f : A ⊗ 1 → B ⊗ 1 , we have
Tr1[f ]= f
Associativity: for all f : A ⊗ U ⊗ V → B ⊗ U ⊗ V , if TrV [f ] is defined we have
TrU⊗V [f ]  TrU TrV [f ] 
Yanking: for any object A, we have
TrA[σA,A]= IdA

A symmetric monoidal category equipped with a partial trace will be called a partially traced category. In case TrU [·] is always defined, we call it a totally traced category.
Definition 1.6 Let us also set a weaker variant of axiom (iii):
(iii)’ Weak sliding: for all f : A ⊗ Uj → B ⊗ U and isomorphism g : U → Uj , we have
TrU f (IdA ⊗ g)   TrU (Id  ⊗ g)f 
′
With these notions of categories come notions of functors preserving their structures. The concept of traced embeddings allows to formulate precisely how a partially traced category embeds into a total one.
Definition 1.7 A symmetric monoidal functor 2 F : C → D between symmetric monoidal categories is a functor together with a natural family of isomorphisms mA,B : FA ⊗Q FB → F(A ⊗C B) and an isomorphism m1 : 1Q → F(1C ) satisfying some coherence axioms expressing compatibility with the symmetric monoidal structure [10].
If moreover C and D are partially traced, it will be called a traced functor if it is compatible with the partial trace: TrFU [Ff ]= Fg if and only if TrU [f ]= g .
Q	C
A functor will be called an embedding if it is injective both on objects and morphisms.
Remark 1.8 The traced property means that the functor F reflects the trace: in D , the trace of Ff is defined and yields a morphism in the image of F exactly when the

2 We actually define here strong (as opposed to lax ) monoidal functors. As we will only consider strong functors in this work, we will not need to specify this later on.





A	B	−~−	A	B

C	D	C	D








Aj
−~−
Bj	Bj	Aj








A	B	A	B





A	B	=	A	B












A	B	A	B





A	A	=	A  A


Figure 1. The axioms of partial traces, graphically.

trace of f is defined. In particular, when D is a totally traced category, TrFU [Ff ] is always defined and is equal to some Fg exactly when TrU [f ] is defined.

The dialect construction
We introduce now the notion of the dialect category built out of a (strict) monoidal category. The basic idea is the following: a morphism from A to B in the category D(C) is a morphism f : A ⊗ U → B ⊗ U in the category C , the object U being thought of as a state space which is private to f . The composition in D(C) is given following this intuition: when composing two morphisms with a state space, neither of them has access to information about the state space of the other. This appears more clearly when looking at the graphical representation of composition in fig. 2.
This construction has been used in categorical approaches to automata equiv- alence [2] and — while it has not been emphasized as a generic construction in these cases — when dealing with the additive connectives of linear logic both in the context of proofnets [8], where it is related to the notion of slice, and in geometry of interaction [4].
Definition 2.1 Given a symmetric monoidal category C we define its dialect category
D(C) as follows:
The objects of D(C) are the objects of C .
The morphisms of D(C) are of the form (f, U ) : A → B where U is an object of C and f : A ⊗ U → B ⊗ U is a morphism of C .
The identity on A is the morphism (IdA, 1).
Composition of (f, U ) : A → B and (g, V ) : B → C is defined as
(g, V )(f, U )=  (IdC ⊗ σV,U )(g ⊗ IdU )(IdB ⊗ σU,V )(f ⊗ IdV ) , U ⊗ V 
Remark 2.2 The fact that D(C) is a category without needing further modification is a consequence of the strictness of C , which we assume in this article. Indeed, if for instance we do not have (U ⊗ V ) ⊗ W = U ⊗ (V ⊗ W ) but only an isomorphism between the two, then we get the associativity of composition f (gh)= (fg)h only up to isomorphism.

V	V
U	U
A	C

Figure 2. Composition in D(C). The exerted eye might notice the similarity with the composition in the case of the Int(·) construction [9].

Now we can define an operation in D(C) that will, after proper quotienting, become a total trace: hiding. Given a morphism in D(C), one can always decide to privatize part of its interface, moving it to the state space.

Definition 2.3 If (f, V ) : A ⊗ U → B ⊗ U is a morphism in D(C), then we define
HU [f, V ]= (f, U ⊗ V ) : A → B
We cannot say much on this operation for the moment, since we do not have yet any monoidal structure for which it could be candidate to be a trace. This is the topic of the next section.

Congruences and partial traces
In this section we will use the concept of quotient category that allows us to identify morphisms of D(C) to get a monoidal structure for which the hiding operation is a trace.
A congruence is the general notion of equivalence relation that can be used in the quotient category construction: it must be compatible with composition.
Definition 3.1 If C is a category, an equivalence relation on morphisms (with same domain and codomain) ∗ is said to be a congruence if f ∗ fj implies fg ∗ fjg and hf ∗ hfj for all g, h.
Definition 3.2 If C is a category and ∗ a congruence, the quotient category C /∗ is defined as
Objects of C /∗ are the objects of C .
Morphisms of C /∗ are the morphisms of C modulo ∗ .
Composition and identities are induced by C modulo ∗ .
We then set up some basic relations capturing what we would like to be equalities in the quotient of D(C) we are going to consider: morphisms with a state space should be considered equal up to isomorphism and tracing (when defined) on their state part. We will then quotient by the induced equivalence relation.
Definition 3.3 Let C be a partially traced category, (f, U ) and (g, V ) morphisms in D(C). We define the following relations:
If there is an isomorphism ϕ : U → V in C such that (IdB ⊗ϕ)f (IdA⊗ϕ—1)= g
then (f, U ) ∼ (g, V ).
If U = V ⊗ Uj and TrU′ [f ]= g then (g, V ) ≺ (f, U ) and (f, U ) > (g, V ).
The relation ≈ is the equivalence relation generated by ∼ , ≺ and > .
Remark 3.4 Note that ≺ and > are reflexive: (f, U )= (f, U ⊗ 1) > (f, U ) by the vanishing axiom ((iv) of definition 1.5).
Now the first thing to check is that this ≈ equivalence relation is indeed a congruence, so that we can look at what happens when quotienting by it. We do this by showing that its basic components are all compatible with composition.
Lemma 3.5 If ∗ is ∼, ≺ or >, then (f, U ) ∗ (fj,Uj) implies (f, U )(g, V ) ∗
(fj,Uj)(g, V ) and (h, W )(f, U ) ∗ (h, W )(fj,Uj) for all (g, V ) and (h, W ) .

Proof The case of ∼ is straightforward, therefore let us have look at ≺ ( > being similar): if (f, U ) ≺ (fj,Uj), it means that Uj = U ⊗Ujj and TrU′′ [fj]= f . Applying the superposing and tightening axioms, we get the required relations.	2
Corollary 3.6 The above defined ≈ is a congruence.
Proof If (f, U ) ≈ (fj,Uj), we have a chain of relations from (f, U ) to (fj,Uj).
Applying repeatedly lemma 3.5 we can obtain an identical chain for both
(f, U )(g, V ) ≈ (fj,Uj)(g, V ) and (h, W )(f, U ) ≈ (h, W )(fj,Uj).	2
We finally set the category that will be shown to be totally traced and in which
C embeds: the dialect category quotiented by ≈ .
Definition 3.7 If C is a partially traced category, we define T(C)= D(C) / ≈ and keep writing H[·] the induced operation on morphisms of T(C).
The operation H[·] can indeed be transported to T(C) because it is compatible with ≈ as (f, U ) ≈ (g, V ) implies HW [f, U ] ≈ HW [g, V ] for any suitable W .

From partial to total
We will now show that T(C) is a totally traced category. Let us first identify its monoidal structure, induced by that of C .
Definition 3.8 If C is a partially traced category, we define the following operation
⊗ on morphisms of D(C): if we have (f, U ) : A → B and (g, V ) : C → D
(f, U ) ⊗ (g, V )= (IdB ⊗ σD,U ⊗ IdV )(f ⊗ g)(IdA ⊗ σU,C ⊗ IdV ) , U ⊗ V 
Moreover, we set τA,B = (σA,B, 1).

V	V
U	U
C	D
A	B

Figure 3. Monoidal structure in D(C).

Lemma 3.9 If ∗ is either ∼, ≺ or >, then (f, U ) ∗ (fj,Uj) implies that both
 (f, U ) ⊗ (g, V ) ∗ (fj,Uj) ⊗ (g, V ) and (g, V ) ⊗ (f, U ) ∗ (g, V ) ⊗ (fj,Uj) for any (g, V ) .
Proof This is similar to the proof of lemma 3.5, using the superposing axiom instead of tightening in the cases of ≺ and > .	2
The lemma above ensures that ⊗ induces a well-defined operation on T(C). Note that before quotienting by ≈ , this operation is not a bifunctor since the compositions

 (f, U ) ⊗ Id  Id ⊗ (g, V ) = (··· ,U ⊗ V )
 Id ⊗ (g, V )  (f, U ) ⊗ Id = (··· ,V ⊗ U )
cannot be equal (but are related by ∼ ).
Proposition 3.10 The category T(C) is symmetric monoidal.
Proof The monoidal structure is given by the above defined ⊗ operation (which is a bifunctor once we quotient by ≈ ) and the object 1 . The symmetries are the τA,B . 2
We finally turn to proving that the hiding operation on T(C) is actually a trace which encompasses the partial trace of C given how we defined the relation ≈ . We notice first that once we quotient by ≈ , H[·] immediately enjoys some of the properties of a trace.
Proposition 3.11 (feedback properties) The operation H[·] in T(C) satisfies all axioms of definition 1.5 except (iii) (sliding) and (vi) (yanking). It also satisfies (iii)’ (weak sliding).
Now let us mention the following lemma saying that it is enough to have sliding on isomorphisms in presence of the other axioms of the trace to get full sliding.
Lemma 3.12 ([9, lemma 2.1]) In presence of the other axioms of the trace, the weak sliding axiom (iii’) implies its full variant.
Putting all this together, we can finally show that H[·] is indeed a trace in T(C).
Corollary 3.13 The category T(C) is totally traced with H[·] as a trace.
Proof Proposition 3.11 lists the properties of a trace H[·] satisfies: all of them but
(iii) and (vi). It also satisfies (iii’). As Tr[·] satisfies axiom (vi), we have in addition that HA[τA,A]= (σA,A, A) > (IdA, 1), that is to say H[·] also satisfies (vi) in T(C). By lemma 3.12, H[·] satisfies the full axiom (iii) in T(C). Therefore H[·] is a total trace in T(C).	2
Embedding in T(C)
We now turn to the question of embedding C into T(C), the basic idea being that f in a partially traced category C will be represented as (f, 1) in T(C). The main difficulty here is to make sure that the equivalence relation we introduced does not happen to equate two morphisms that were different in C . In order to prove this, we have a series of lemmas that allow us to progressively rewrite chains of equivalences into assertions that some trace is defined when morphisms of the form (f, 1) are involved.
Lemma 3.14 If (f, 1) ∼ (g, U ) , (f, 1) > (g, U ) or (f, 1) ≺ (g, U ) then TrU [g]= f
(i.e. TrU [g] is defined and equal to f ).

Proof If (f, 1) > (g, U ), it means that 1 = U ⊗ V with TrV [f ] defined, equal to g . By associativity and vanishing, TrU [g] TrU TrV [f ]  TrU⊗V [f ] Tr1[f ]= f . Therefore TrU [g] is defined and equal to f . The case of (f, 1) ≺ (g, U ) is similar.
If (f, 1) ∼ (g, U ), we get TrU [g]  Tr1[f ]= f by sliding and vanishing.   2
Lemma 3.15 If TrU [g]= f and (g, U ) ∼ (h, V ) , then TrV [h]= f .
Proof By the sliding axiom, TrV [h]  TrU [g]= f .	2
Lemma 3.16 If TrU [g]= f and (g, U ) ≺ (h, V ) , then TrV [h]= f .
Proof We have V = U ⊗ V j and TrV ′ [h]= g . By the associativity axiom, we get that TrV [h]  TrU⊗V ′ [h]  TrU TrV ′ [h]  TrU g]= f .	2
Lemma 3.17 If TrV [g]= f and (g, V ) > (h, U ) , then TrU [h]= f .
Proof We have V = U ⊗ V j and TrV ′ [g]= h. By the associativity axiom, we get that TrU [h]  TrU TrV ′ [g]  TrU⊗V ′ [g]  TrV [g]= f .	2
Combining all this, we get that equivalence to a morphism of the form (f, 1) implies the definiteness of the trace. As a consequence, we will be able to show that we have indeed an embedding of C into T(C) that reflects the partial trace.
Proposition 3.18 If (f, 1) ≈ (g, U ) , then TrU [g]= f .
In particular, if (f, 1) ≈ (g, 1) then f = g .
Proof Given two equivalent morphisms (f, 1) ≈ (g, U ), we can repeatedly apply lemmas 3.14–3.17 to transform (starting from Tr1[f ] = f ) the chain of relations between them into the required TrU [g]= f .
In the particular case where (f, 1) ≈ (g, 1) we get g = Tr1[g]= f .	2
Corollary 3.19 (embedding) The functor EC : C → T(C) defined as
EC (A)= A	(on objects)
EC (f )= (f, 1) (on morphisms) is a symmetric monoidal embedding.
Proof As it acts as the identity on objects, EC is what is called a strict symmetric
monoidal embedding: the m isomorphisms are actually identities and moreover EC (f ⊗ g)= EC (f ) ⊗ EC (g) for any morphisms f, g . The fact that it is an embedding follows from the second part of proposition 3.18.	2
Representation theorem
We finally come to formulate and prove the main result of this article, the representation theorem for partially traced categories.

It is split into two parts: first we show that the embedding defined in the previous section is traced, which means that any partially traced category embeds (reflecting the trace) into a totally traced one by the T(·) construction; second, we show that this construction enjoys a universal property ensuring that any traced functor from a partially traced category to a total one factors as the embedding followed by a traced functor.
Reflecting the trace
A consequence of proposition 3.18 is the following lemma, from which the traced nature of EC follows: the trace of a morphism in C is defined exactly when its hiding in T(C) is equivalent to some (g, 1), that is to say exactly when it is in the image of the embedding of C into T(C).
Lemma 4.1 Given a f : A ⊗ U → B ⊗ U in a partially traced category C , we have that TrU [f ] is defined if and only if there is a morphism of the form (g, 1) in T(C) such that (f, U ) ≈ (g, 1) .
Proof The fact that TrU [f ] is defined implies (f, U ) > (TrU [f ], 1) by definition. Conversely, if (f, U ) ≈ (g, 1) the first part of proposition 3.18 tells us that TrU [f ] is defined.	2
Theorem 4.2 The functor EC : C → T(C) is a traced embedding.
Proof We already know by corollary 3.19 that it is a (strict) monoidal embedding, therefore we only have to check its traced nature, which is an immediate consequence of lemma 4.1.	2
Universal property
Now we can consider equivalent morphisms (f, U ) ≈ (g, V ) and show that the traces of their images through any traced functor to a totally traced category must be equal. This will allow us to properly define the factorization through T(C) in the universal property.
Lemma 4.3 If we have f : A⊗ U → B ⊗ U and g : A⊗ V → B ⊗ V in a partially traced category C such that (f, U ) ≈ (g, V ) and a traced functor F : C → D with D totally traced, then TrFU (Ff )= TrFV (Fg) .
Proof It is enough to show that (f, U ) ∼ (g, V ), (f, U ) ≺ (g, V ) and (f, U ) > (g, V ) all imply TrFU (Ff ) = TrFV (Fg), which are straightforward consequences of the axioms of trace and of the functor being traced.	2
Theorem 4.4 If C is a partially traced category, D a totally traced category and F
a traced functor from C to D, then F factors uniquely as



F = G ◦ EC


with G : T(C) → D a traced functor.
Proof Define G as
EC
C  T(C)
 G
D

GA = FA	(on objects)
G(f, U )= TrFU [Ff ]	(on morphisms) the m isomorphisms are those of F
This is well-defined thanks to lemma 4.3. Checking that G is traced is routine, using the fact that F is traced and the axioms of trace. Moreover for any f : A → B we have
(G ◦ EC )(f )= G(f, 1)= TrF1[Ff ]= Tr1[(IdB ⊗ m—1)(Ff )(IdA ⊗ m1)]
using the isomorphism m1 : 1 → F1 and the sliding axiom. By the vanishing axiom and the coherence properties of m1 , (G◦EC )(f )= (IdB ⊗m—1)(Ff )(IdA ⊗m1)= Ff .
Now for the uniqueness of G , suppose we have two traced functors G, K making our diagram commute. We readily see that we must have GA = KA = FA, so G and K agree on objects. Moreover, the diagram tells us that they must agree on morphisms of the form (f, 1). Now, given (f, U ) in T(C) we have that (f, U )= HU [f, 1] and because G and K are traced we get
G(f, U )= G(HU [f, 1]) = TrGU [G(f, 1)] = TrKU [K(f, 1)] = K(HU [f, 1]) = K(f, U )
2

Conclusion
We gave a new proof of the representation theorem for partially traced categories, using an approach that is quite different from the original proof of the result. The interest of this theorem remains the same: all equational reasoning that can be carried out in totally traced categories (in particular using their graphical language) will be valid in partially traced categories provided the equated expressions are defined.
One can study further the relation between the two constructions, ours based on hiding and quotients and the previous one based on paths in paracategories, we already explained in the introduction that they are naturally isomorphic via an abstract argument. Can we understand more concretely how this isomorphism works? Another direction for future work would be to give a relaxed definition of partial traces

that still enjoy the representation theorem and encompasses more general situations, such as infinite-dimensional Hilbert spaces, as mentioned in the introduction.

Acknowledgement
The author wishes to thank Phil Scott for his feedback and discussions on this topic and the anonymous referees for their useful comments and crucial suggestions.

References
Abramsky, S., E. Haghverdi and P. J. Scott, Geometry of interaction and linear combinatory algebras, MSCS 12 (2002), pp. 625–665.
Bartha, M., Simulation equivalence of automata and circuits., in: E. Csuhaj-Varjú and Z. Ésik, editors,
AFL, 2008, pp. 86–99.
	Girard, J.-Y., Towards a geometry of interaction, in: J. W. Gray and A. Ščedrov, editors, Proceedings of the AMS-IMS-SIAM Joint Summer Research Conference held June 14-20, 1987, Categories in Computer Science and Logic 92 (1989), pp. 69–108.
Girard, J.-Y., Geometry of interaction III: accommodating the additives, number 222 in London Math. Soc. Lecture Note Ser., CUP, 1995 pp. 329–389.
Haghverdi, E. and P. Scott, A categorical model for the geometry of interaction, in: J. Díaz, J. Karhumäki,
A. Lepistö and D. Sannella, editors, Automata, Languages and Programming, Lecture Notes in Computer Science 3142, Springer Berlin Heidelberg, 2004 pp. 708–720.
	Haghverdi, E. and P. J. Scott, Towards a typed geometry of interaction, in: Proceedings of the 19th International Conference on Computer Science Logic, CSL’05 (2005), pp. 216–231.
Hermida, C. and P. Mateus, Paracategories I: Internal paracategories and saturated partial algebras, Comp. Sci 309 (2002), pp. 125–156.
	Hughes, D. J. D. and R. J. van Glabbeek, Proof nets for unit-free multiplicative-additive linear logic, ACM Trans. Comput. Log. 6 (2005), pp. 784–842.
Joyal, A., R. Street and D. Verity, Traced monoidal categories, Mathematical Proceedings of the Cambridge Philosophical Society 119 (1996), pp. 447–468.
Mac Lane, S., “Categories for the Working Mathematician,” Number 5 in Graduate Texts in Mathematics, Springer New York, 1971.
Malherbe, O., P. J. Scott and P. Selinger, Partially traced categories, J. Pure Appl. Algebra 216 (2012),
pp. 2563–2585.
