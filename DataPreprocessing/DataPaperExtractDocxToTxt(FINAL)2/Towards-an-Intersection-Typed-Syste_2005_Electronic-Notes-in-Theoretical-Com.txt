Electronic Notes in Theoretical Computer Science 136 (2005) 43–56  
www.elsevier.com/locate/entcs


Towards an Intersection Typed System à la Church
Luigi Liquori
INRIA Sophia Antipolis, France
Simona Ronchi della Rocca
CS, University of Turin, Italy

Abstract
In this paper, we presents a comfortable fully typed lambda calculus based on the well-known intersection type system discipline where proof are not only feasible but easy; the present system is the counterpart à la Church of the type assignment system as invented by Coppo and Dezani.
Keywords: Typed lambda calculus, intersection type, Church type assignment system, Curry-Howard correspondence

Introduction
The Intersection Type Assignment System (Λu∧) is a set of inference rules for assigning Intersection types to terms of the untyped λ-calculus. Intersec- tion types are formulæ of the implicational and conjunctive fragment of the predicate logic. The syntax and the typing rules are presented in Figure 1. Intersection types were introduced by Coppo and Dezani at the end of ’70s, to increase the typability power of Curry’s type assignment system for the λ-calculus [5]. Since then, intersection types have been fruitfully used for designing static semantics of programming languages (e.g. Algol-like [12], and object-oriented [11]), for characterizing interesting classes of λ-terms (e.g. the strongly normalizing ones [10]), and for studying denotational semantics of various untyped λ-calculi [1, 2].


1571-0661 © 2005 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2005.06.015


Syntax of Λu∧
M ::= x | λx.M | M M σ ::= α | σ→σ | σ ∧ σ
Let α range over a denumerable set V of constants, and Γ ≡ {x1:σ1,... , xn:σn}, where i /= j implies xi /≡ xj. The operator “ ∧” takes precedence over “ →”.


Typing Rules
x:σ ∈ Γ
(Var)
Γ ▶∧ x : σ

Γ, x:σ1 ▶∧ M : σ2
Γ ▶∧ λx.M : σ1→σ2



(→I)

Γ ▶∧ M : σ1→σ2	Γ ▶∧ N : σ1
Γ ▶∧ M N : σ2

(→E)
Γ ▶∧ M : σ1	Γ ▶∧ M : σ2
Γ ▶∧ M : σ1 ∧ σ2

(∧I)

Γ ▶∧ M : σ1 ∧ σ2
Γ ▶∧ M : σ1

(∧EL)
Γ ▶∧ M : σ1 ∧ σ2
Γ ▶∧ M : σ2

(∧ER)

Figure 1. The Intersection Type Assignment System Λu∧



There are many versions in the literature of intersection type assignment systems. Here we choses that one presented as “System D” by Krivine [9], characterized by the presence of explicit rules for dealing with the introduction and elimination of the intersection. Note that, differently from the big part of the systems presented in the literature, as for example [6], in this system the connective ∧ is neither commutative nor associative nor idempotent, This last choice has been done since we are looking for a typed version of the calculus, and in this setting it is natural to consider types as syntactical entities. In any case this choice does not have any consequence on the typability power of the system, which is well known to characterize all and only the strongly normalizing terms [9].
Following a standard terminology, let us call à la Curry a system assigning types to untyped terms, and à la Church a system assigning types to typed terms, i.e. where types are part of the syntax of terms. Differently from other type assignment systems à la Curry, Λu∧ has no natural counterpart à la Church. The classical example is the polymorphic identity in Λu∧ that has the



following type-derivation:
x:σ1 ▶∧ x : σ1
▶∧ λx.x : σ1→σ1



(→I)

x:σ2 ▶∧ x : σ2
▶∧ λx.x : σ2→σ2



(→I)
(∧I)

▶∧ λx.x : (σ1→σ1) ∧ (σ2→σ2)
but is untypable using a naïve corresponding rule à la Church for the intro- duction of intersection types [8].


x:σ1 ▶∧ x : σ1
▶∧ λx:σ1.x : σ1→σ1

(→I)
x:σ2 ▶∧ x : σ2
▶∧ λx:σ2.x : σ2→σ2

(→I)
(∧I)

▶∧ λx:	.x : (σ1→σ1) ∧ (σ2→σ2)
By the Curry-Howard isomorphism, the λ-term must record the shape of its type-derivation. Naïve solutions of λ-calculi à la Church lead to incomplete- ness, in the sense that the resulting typed system has less typability power of the type assignment one (see for example [12]). The problem is, as the skilled reader can understand, the presence of non syntax-directed rules that disconnect the λ-term with its type-derivation (hence losing Curry-Howard correspondence).
It is important to point out that this problem does not depend on the chosen intersection type assignment system; indeed no one of the type assign- ment systems presented in the literature is completely syntax directed (and not-even it cannot be!) .
Our goal is to build a typed λ-calculus à la Church with related typing system, such that the underlying untyped calculus is exactly the λ-calculus à la Curry, and its relation with the type assignment system follows the standard path designed in [3]. Namely the following requirements must be satisfied:
there exists an erasing function J , erasing type informations from terms, such that, if M is a typed term, then J (M ) ∈ Λ;
typed and type assignment proofs are isomorphic, i.e. both the applica- tion of the erasing function J on all terms in a typed proofs produces a correct type assignment proof, and every type assignment proof is ob- tained from a typed one by erasure.
Moreover, we want that the intersection calculus à la Church inherits all the properties of intersection calculus à la Curry, namely:
subject reduction;
strong normalization of typable terms;

plus the following ones:
unicity of typing;
decidability of type reconstruction and of type checking.
No one of the proposals present in the literature satisfies all the given require- ments. The typed languages proposed in [12] and [11] are not complete with respect to the type assignment, the ones in [4], [13] and [16] do not satisfy requirement 1, while the language in [17] does not satisfy requirement 2.
In order to build such a calculus, our attempt has been to design a calculus, where typing depends not only on a new “imperative” formulation of context, now assigning types to term variables at a given location, but also on a new notion of store, that remembers the associations between locations and types. The further task of a store is to record the shape of a proof. Hence a store is a truly typed proof calculus that can be executed by means of suitable reduction rules; reduction in this calculus models cut-elimination. The store-calculus can be defined per se, as decoration of the implicative and conjunctive fragment of intuitionistic logic. So it codifies a set of proofs that is strictly bigger than these corresponding to intersection type-derivations (see [15]).
Finally the desired intersection typed calculus can be built, where stores can be seen as modalities for terms. Very roughly speaking, a modality is a unary operator that can be used for decorating a logical formula, saying additional informations about its provability. In particular the information carried out by a modality can be a meta-theoretical information about the structure of the proof, as for example the modality ! in Linear Logic [7], that denotes a possible not linear use of a premise. In [14] a typed language has been showed, where a modality on terms is the counterpart of the modality on types, and it is used for characterizing the variables that can occur not linearly. Here the modality is used for describing the structure of the type- derivation. In fact, packing together λ-terms and stores as modalities restrict the stores to describe just the intersection type-derivations. So the typed identity with type (σ1→σ1) ∧ (σ2→σ2) now is the term: λx : 0.x, where 0 is a location, and the modality of this term is: (λ0:σ1.0) ∧ (λ0:σ2.0). The typed λ-calculus so obtained satisfies all the above requirements. In particular the type reconstruction and type checking are decidable, and the algorithms are pretty easy.
The paper is organized as follows: In Section 2 the calculus of stores is presented, in Section 3 the whole intersection typed λ-calculus is showed, Sec- tion 4 lists its properties, and in particular it contain the type checking and the type inference algorithm. The conclusion presents some final considerations.

The Typed Proof-calculus
The syntax of intersection types is that of the formulas of the implicative and
conjunctive fragment of the intuitionistic logic (L∧→,∧) , if we think to the connective → as the implication and to the connective ∧ as the conjunction.
However the intersection type assignment system is not corresponding, in the Curry-Howard sense, to this logic, because of the “anomalous” decoration of the rules dealing with the conjunction.
In this section we define a typed calculus, decorating the proof of such a logic. The calculus is a typed λ-calculus, but it is built, instead on vari- ables, on locations. In fact it will be used as a (particular notion of) store, for remembering both the association between locations and types and the structure of the type-derivation.


Syntax of ΛP.
Definition 2.1
Type-locations (or type-addresses) range over Nat.
Intersection types are defined as follows:
σ ::= α | σ→σ | σ ∧ σ
where α range over a denumerable set V of constants.
Contexts are finite associations between locations and types, and are defined by the following grammar:
Γ ::= ϵ | Γ, ι:σ
Tree-stores are labeled unary/binary trees defined as follows:

∆ ::= ι | λι:σ.∆ | ∆∆	(for syntax directed rules)
∆∧∆ | (∆ | ∆	(for intersection rules)
The set Fl(∆) of the free locations in a tree-store ∆ is an easy adaptation to free-stores of the notion of the set of free variables in a λ-term.
In what follows, the symbol ≡ denotes the syntactic equality for terms, types, contexts, type-locations and tree-stores, respectively.



ι:σ ∈ Γ Γ ▶P ι : σ

(Var)
Γ, ι:σ1 ▶P ∆ : σ2
Γ ▶P λι:σ1.∆ : σ1→σ2

(→I)

Γ ▶P ∆1 : σ1→σ2	Γ ▶P ∆2 : σ1
Γ ▶P ∆1 ∆2 : σ2

(→E)
Γ ▶P ∆1 : σ1	Γ ▶P ∆2 : σ2
Γ ▶P ∆1∧∆2 : σ1 ∧ σ2

(∧I)

Γ ▶P ∆ : σ1 ∧ σ2
Γ ▶P (∆ : σ1

(∧EL)
Γ ▶P ∆ : σ1 ∧ σ2
Γ ▶P ∆ : σ2

(∧ER)

Figure 2. The Proof-calculus ΛP.
Type System of ΛP.
The system proves judgments of the shape:
Γ ▶P ∆ : σ
Intuitively: in the judgment, the type-context Γ assigns intersection types to store-locations of ∆; the tree-store keeps track of the type of the used location together with a written trace of the skeleton of the typing proof, where the skeleton of a proof is the tree obtained from it by erasing all the informations but the name of the applied rules. So the tree-store ∆ plays the role of the “road map” to backtrack (i.e. roll back) the derivation tree. The typing rules are presented in Figure 2. Some comments are in order:
(Var) gives types to free-locations;
(→I) the tree-store ∆ evolves in a new tree-store enriched with the binding for the location ι;
(→E) observes that the two type-stores of the premises become sub tree- stores in the conclusion (the hidden application operator being the root);
(∧I) (∧EL), and (∧ER) are the three standard rules that introduce/eliminate intersection-types; note that in order to keep track of which branch is chosen in the intersection-elimination (and keep unicity of typing), tree-stores are marked with two place-holders ( and indicating the correct branch to select.


Reduction Semantics of ΛP.
Being every term in ΛP a decorations of a proof of L∧→,∧, the reduction rules of the languages correspond to the cut-elimination steps of the logic. So
the →-cut elimination gives rise to the following reduction rule (similar to the

standard β-rule) :
(λι:σ.∆1) ∆2 →ι ∆1[∆2/ι]
and the ∧-cut eliminations give rise to the following two reduction rules:
((∆1 ∧ ∆2) →π1 ∆1 (∆1 ∧ ∆2) →π2 ∆2
The reduction relation →ιπ is the contextual closure of the reduction rules
→ι, →π1 , →π2 . In particular, we denote by →π the contextual, reflexive and transitive closure of the two rules →π1 and →π2 .
We also work modulo α-conversion, which can be rephrased in our ΛP as the symmetric, reflexive, transitive and contextual closure of the following rules:
λι1:σ.∆ →αι λι2:σ.∆[ι2/ι1]	if ι2 /∈ Fl(∆)
Every type-derivation in Λu∧, when terms are erased, corresponds to a proof in L∧→,∧, but the vice-versa is not true, since the rule (→ I) corresponds to a
meta-theoretical condition on the proofs of the two premises. For a complete
analysis of the relation between Λu∧ and L∧→,∧ see [15]. Here just note that, for example, the skeleton of the proof encoded by the tree-store (λ0:σ.0) ∧ 1
is the following:
(V ar)
(→ I)	(V ar)
(∧I)
which cannot be the skeleton of any intersection type assignment derivation.
Example 2.2  We show a type-derivation for the tree-store (λ0:σ1.0)∧(λ0:σ2.0).




0:σ1 ▶P 0 : σ1
(Var)
(→I)


0:σ2 ▶P 0 : σ2
(Var)
(→I)

▶P λ0:σ1.0 : σ1→σ1
▶P λ0:σ2.0 : σ2→σ2
(∧I)

▶P (λ0:σ1.0) ∧ (λ0:σ2.0) : (σ1→σ1) ∧ (σ2→σ2)
The Intersection Typed System Λt∧
The Intersection Typed System Λt∧ is built starting from a particular notion of context. In fact, now a context associates a type to a variable at a given location, i.e., it both associates the type to the variable and takes a free loc- ation for storing the variable itself. This trick allows for remembering, in the rule (→I), just the location, being the corresponding type stored in the


tree-store, built by the system in parallel with the typed term. In this way the underlying term is a term of the classical untyped λ-calculus. Moreover, since the tree-store describes the structure of the type-derivation, we obtain the decidability property of typing.

Syntax of Λt∧.
Definition 3.1	(i) Type-locations, intersection types and tree-stores are defined as in Definition 2.1.
(ii) Contexts are finite associations between variables and types at a given location, and they are defined as follows:
Γ ::= ϵ | Γ, x@ι:σ
The set Λt∧ of intersection typed terms is defined as follows:
M ::= x | λx:ι.M | M M 

Type System of Λt∧.
The intersection typed calculus Λt∧ is in some sense a modal calculus, where terms of ΛP represent the modality. The typed system proves statements of the shape:
Γ ▶ M @∆ : σ
where Γ is a context, M ∈ Λt∧, and ∆ ∈ ΛP. Intuitively: in the judgment, the type-context Γ assigns intersection types to the free-variables of M allocated in the free store-locations; the tree-store keeps track of the type of the used location together with a written trace of the skeleton of the derivation tree. The tree-store ∆ plays the role of the road map to backtrack (i.e. roll back) the derivation tree. The typing rules are presented in Figure 3. Some comments are in order:
(Var) gives types to free-variables at a given location;
(→I) is a quasi-classical abstraction rule, but it records in the term only the type-location associated to the abstracted variable; the tree-store ∆ evolves in a new tree-store enriched with the binding for the location ι;
(→E) is a quasi-classical application rule; observe that the two type-stores of the premises become sub tree-stores in the conclusion (the hidden applic- ation operator being the root.)
(∧I) is the most important rule; given two judgments for M proving type σ1 and type σ2, (both proved in the same context Γ but with different tree- stores ∆1, and ∆2), we can assign the intersection type σ1 ∧ σ2 to M in



x@ι:σ ∈ Γ Γ ▶ x : σ

(Var)

Γ, x@ι:σ1 ▶ M @∆ : σ2


Γ ▶ (λx:ι.M)@(λι:σ1.∆) : σ1→σ2

(→I)



Γ ▶ M @∆1 : σ1→σ2	Γ ▶ N @∆2 : σ1

Γ ▶ (M N)@(∆1 ∆2) : σ2

(→E)



Γ ▶ M @∆1 : σ1	Γ ▶ M @∆2 : σ2


Γ ▶ M @(∆1∧∆2) : σ1 ∧ σ2

(∧I)



Γ ▶ M @∆ : σ1 ∧ σ2


Γ ▶ M @((∆) : σ1

(∧EL)



Γ ▶ M @∆ : σ1 ∧ σ2


Γ ▶ M @(∆ ) : σ2

(∧ER)


Figure 3. The Intersection Typed System Λt∧.
the context Γ but in the new tree-store ∆1 ∧ ∆2. At this point the λ-term M loses the one-to-one correspondence with its proof. Luckily, the new tree-store keeps track of the derivation and guarantees unicity of typing;
(∧EL), and (∧ER) are the two standard rules that eliminate intersection types. Also in this case the λ-term M loses the one-to-one correspondence with its (logical) proof, But the proof is memorized by the tree-store, thanks to the two place-holders ( and , indicating the applied rule.

Reduction Semantics of Λt∧.
In order to maintain the correct relation between a term and its modality, the reduction works in parallel both on terms and on tree-stores. Formally, the reduction relation →βι of Λt∧ is the contextual closure of the following reduction rules:
((λx:ι.M)N )@((λι:σ.∆1) ∆2) →β M [N/x]@∆1[∆2/ι]

M @((∆1 ∧ ∆2) →π1 M @∆1 M @(∆1 ∧ ∆2) →π2 M @∆2


We also work modulo α-conversion, which is the symmetric, reflexive, trans- itive and contextual closure of the following rules:

(λx@ι.M)@∆  →α (λy:ι.M[y/x])@∆	if y /∈ Fv(M )
M @(λι1:σ.∆) →αι M [ι2/ι1]@(λι2:σ.∆[ι2/ι1])	if ι2 /∈ Fv(∆)


Example 3.2 [Classical polymorphic identity] We show a polymorphic type- derivation for the classical polymorphic identity λx:0.x in the tree-store
(λ0:σ1.0) ∧ (λ0:σ2.0)




x@0:σ1 ▶ x@0 : σ1
(Var)


(→I)


x@0:σ2 ▶ x@0 : σ2
(Var)


(→I)

▶ (λx:0.x)@(λ0:σ1.0) : σ1→σ1
▶ (λx:0.x)@(λ0:σ2.0) : σ2→σ2
(∧I)

▶ (λx:0.x)@((λ0:σ1.0) ∧ (λ0:σ2.0)) : (σ1→σ1) ∧ (σ2→σ2)
Example 3.3 [The polymorphic self-application] Let Γ ≡ x:0:σ2, with σ2 ≡ (σ1→σ1) ∧ σ1. We show a polymorphic type-derivation for the classical self- application λx:0.x x in the tree-store λ0:σ2.((0) (0 ).


Γ ▶ x@0 : σ2


Γ ▶ x:((0) : σ1→σ1

(∧EL)


Γ ▶ x@(0 ) : σ1

(∧ER)
(→E)

Γ ▶ (x x)@((0) (0 ) : σ1


▶ (λx:0.x x)@(λ0:σ2.((0) (0 )) : σ2 → σ1
(→I)

Note how the tree-store memorizes exactly the skeleton of the type-derivation.

Sketch of the Proof-theoretical Development
The system Λt∧ enjoys all the properties we asked for. In order to list them, we need to define an erasure function, connecting Λt∧ with Λu∧.
Definition 4.1 [Erasure]
Let J : Λt∧ → Λ be inductively defined on terms and point-wise extended to contexts and tree-stores as follows:

J (x@_) = x
J ((λx@ι.M)@_) = λx.J (M @_)
J ((M N)@_) = J (M @_) J (N @_)
J (ϵ) = ϵ
J (Γ, x@ι:σ) = J (Γ), x:σ


The notion of skeleton of a proof, defined for the system ΛT , can be nat- urally extended to the system Λt∧.

Theorem 4.2 (Galleria)	(i) (Isomorphism)
If D : Γ ▶ M @∆ : σ, then there exists D', such that D' : J (Γ) ▶∧ J (M @∆) : σ, with D and D' having the same skeleton;
If D : Γ ▶∧ M : σ, then there exists D', M ' and ∆, such that D' :
Γ' ▶ M '@∆ : σ, and J (M '@∆) = M, and J (Γ') = Γ, with D and D'
having the same skeleton.
(Subject Reduction) If Γ ▶ P @∆ : σ, and P @∆ →β Q@∆', then Γ ▶
Q@∆'' : σ with ∆' →π ∆''.
(Strong Normalization) Γ ▶ M @∆ : σ if and only if M@∆ is strongly normalizing.
(Unicity of Typing) If Γ ▶ P @∆ : σ, and Γ ▶ P @∆ : σ', then σ ≡ σ'.
(Type Reconstruction) Given a context Γ, a type-store ∆, and a term M, there is a type σ such that Γ ▶ M @∆ : σ if and only if Type∧(Γ,M@∆) =
σ.
(Type Checking) Given a context Γ, a tree-store ∆,a term M anda type
σ, Γ ▶ M @∆ : σ if and only if Typecheck∧(Γ,M@∆, σ) = true.

Properties 4, 5 and 6 of this galleria are reached thanks to the notion of tree-store. Figure 4 shows, in ML-style, the type reconstruction and type- checking algorithms.
As far as the properties listed at the points 1,2,3 of the galleria are con- cerned, the key one is the isomorphism property between the system Λt∧ and the system Λu∧, which can be easily proved by induction on type-derivations. Both the subject reduction and the strong normalization property are con- sequences of it.



Type∧(Γ,M@∆)
=Δ	match (M @∆) with

(_@((∆1))	⇒ σ1	if Type∧(Γ,M@∆1) = σ1 ∧ σ2
(_@(∆1 ))	⇒ σ2	if Type∧(Γ,M@∆1) = σ1 ∧ σ2
(_@(∆1∧∆2))	⇒  σ1 ∧ σ2 if Type∧(Γ,M@∆1) = σ1 and
Type∧(Γ,M@∆2) = σ2
(x@_)	⇒ σ	if x@ι:σ ∈ Γ ((λx@ι.M1)@(λι:σ1.∆1)) ⇒ σ1→σ2 if Type∧((Γ, x@ι:σ1), M1@∆1) = σ2
((M1 M2)@(∆1 ∆2))	⇒ σ2	if Type∧(Γ, M1@∆1) = σ1→σ2 and
Type∧(Γ, M2@∆1) = σ1
(_@_)	⇒ false	otherwise


Typecheck∧(Γ,M@∆, σ)
=Δ	Type∧(Γ,M@∆) = σ


Figure 4. The Type Reconstruction and Type Checking Algorithms for Λt∧.
Conclusions
We studied in this paper the problem of designing a Church version of the intersection type assignment system. In particular we asked for a typed lan- guage such that its relationship with the intersection type assignment system enjoys all the standard requirements we posed in [3]. Examples of such “good” correspondences are respectively the Church and Curry version of the simple typed λ-calculus, the typed and type assignment version of the second order λ-calculus. We succeed in designing a language satisfying the given require- ments, which is based essentially on two tools: an imperative notion of typ- ing, when types are assigned to variables “at a given location”, and a typed language, describing intersection type-derivations, whose terms are used as modalities for the terms of the target language.
A reader interested in particular in programming applications could object


that the used language is far for being “usable”, since the user needs to specify not only the typed terms, but also their modalities, which are codings of type- derivations. The answer can be twofold. From a programming languages point of view, in every typed language the user, in order to write explicitly the type of a term, in some sense needs to “guess” the correct type-derivation assigning that type to the term itself. Here obviously the type-derivations are more difficult than in the simple typed case. But if we think, for example, to the second order typed λ-calculus, in order to write the term
Λβ.Λγ.λx:∀α.α.x(β → γ) of type ∀β.∀γ.(∀α.α) → (β → γ)
it is necessary to know exactly how the rules for introducing and eliminat- ing the universal quantifier work. However, we think that the production of an usable language is not the only justification for the problem we studied. The relationship between typed and type assignment systems is an important theoretical issue, that is interesting in itself.

Acknowledgement
Simona was kindly supported by QSL: Qualité et Sûrété du Logiciel, CPER, Région Lorraine, Nancy, and by INRIA; Luigi was visiting the Department of Informatics, University of Sussex, Brighton; he would like to thank his hosts Matthew Hennessy and Vladimiro Sassone, and the whole Department of In- formatics for the ideal working conditions they provided. The two anonymous referees give also useful comments.

References
Barendregt H., Coppo M., and Dezani-Ciancaglini M. “A Filter Lambda Model and the Completeness of Type Assignment”, Journal of Symbolic Logic, 48(4):931-940, 1983.
Coppo M., Dezani-Ciancaglini M., Honsell F., and Longo G. “Extended Type Structures and Filter Lambda Models”, Logic Colloquium ’82, pp.241-262, 1983.
van Bakel S., Liquori L., Ronchi Della Rocca S., and Urzyczyn P. “Comparing Cubes of Typed and Type Assignment systems", Annals of Pure and Applied Logic, 86(3):267–303, 1997.
Capitani B., Venneri B. “Hyperformulæ, Parallel Deductions and Intersection Types”, Proc. BOTH 2001, ENTCS, 50(2):180-198, 2001.
Coppo M. , Dezani-Ciancaglini M. “An extension of the basic functionality theory for the
λ-calculus”, Notre Dame J. Formal Logic, 21(4):685–693, 1980.
Dezani-Ciancaglini M., Giovannetti E., de’ Liguoro U. “Intersection types, lambda-models and Böhm trees”. In MSJ-Memoir Vol. 2 “Theories of Types and Proofs”, volume 2, pages 45-97. Mathematical Society of Japan, 1998.
Jean-Yves Girard. Linear Logic. Theoretical Computer Science, 50:1-102, 1987.



Hindley J. R. “Coppo Dezani types do not correspond to propositional logic”, Theoretical Computer Science, 28(1-2):235-236, 1984.
Krivine J.L. “Lambda-calcul, types et modèles”, Masson, 1990.
Pottinger G. “A type assignment for the strongly normalizable λ- terms”, in: To H. B. Curry: essays on combinatory logic, lambda calculus and formalism, pp.561-577, Academic Press, London, 1980.

Pierce, B., C. and Turner, D., N. “Simple Type-theoretic foundations for object-oriented programming”, Journal of Functional Programming, 4(2):207–247, 1994.
Reynolds J.C. “Design of the programming language Forsythe”, in:Algol-like Languages, O’Hearn and Tennent ed.s, Birkhauser, 1996.
Ronchi Della Rocca S. “Intersection Typed Lambda-Calculus", In Proc of ICTRS, ENTCS, 70(1), 2002.
S. Ronchi della Rocca and L. Roversi. “ Lambda calculus and intuitionistic linear logic”. Studia Logica, 59(3), 1997.
Ronchi Della Rocca S. and Roversi L. “Intersection logic”, Proc. of CSL, LNCS 2142, pp.414- 428, Springer-Verlag, 2001.
Wells J.B., Dimock A., Muller R., and Turbak F., “A Calculus with Polymorphic and Polyvariant Flow Types”, Journal of Functional Programming, 12(3), pp. 183-227, 2002.
Wells J.B., and Haack C. “Branching Types”, Information and Computation, 200X.
