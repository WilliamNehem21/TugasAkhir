Electronic Notes in Theoretical Computer Science 53 (2003)
URL:  http://www.elsevier.nl/locate/entcs/volume53.html  13 pages

A characterization of monotonicity with collective quantifiers

Gilad Ben-Avi and Yoad Winter
Computer Science Department Technion – Israel Institute of Technology Haifa 32000 Israel


Abstract
This paper studies the monotonicity behavior of plural determiners that quantify over collections. Following previous work, we describe the collective interpreta- tion of determiners such as all, some and most using generalized quantifiers of a higher type that are obtained systematically by applying a type shifting operator to the standard meanings of determiners in Generalized Quantifier Theory. Un- like previous proposals, one unified determiner fitting operator both captures ex- istential quantification with plural determiners and respects their monotonicity properties. However, some previously unnoticed facts indicate that monotonicity of plural determiners is not always preserved when they apply to collective pred- icates. We show that the proposed operator describes this behavior correctly, and characterize the monotonicity of the collective determiners it derives. It is proved that determiner fitting always preserves monotonicity properties of determiners in their second argument, but monotonicity in the first argument of a determiner is preserved if and only if it is monotonic in the same direction in the second ar- gument.


Introduction
Monotonicity and collectivity phenomena are pivotal in logical theories of natural language semantics. However, despite the many advances in the formal investigation of these phenomena, relatively little attention has been paid to the effects of collective interpretations of quantifiers on their monotonicity properties. In this paper we aim to formally study these re- lations. Using a novel collectivity operator on determiners that combines insights from previous works in generalized quantifier theory, we show that the conservativity of quantification in natural language is responsi- ble for two curious asymmetries in the monotonicity properties of collec- tive determiners. First, natural language determiners change their mono- tonicity behavior when they quantify over collections only if their stan-
◯c 2003 Published by Elsevier Science B. V. Open access under CC BY-NC-ND license.


dard monotonicity properties are different in their two arguments. Sec- ond, only the first argument of the determiner may change its monotonic- ity properties when the determiner quantifies over collections. These two asymmetries follow from the conservativity of collective quantification as implemented in the proposed operator, together with standard assump- tions about their “logical constancy” and “non-triviality”.
Generalized Quantifier Theory (GQT), as was applied to natural lan- guage semantics in the influential works of [1], [7] and [3], concentrated on the behavior of determiners in sentences such as the following.
All the students are happy. Some girls arrived. Most teachers are Repub- lican
In these sentences, the denotations of both the nominal (e.g. students, girls, etc.) and the predicate (e.g. happy, arrived, etc.) are traditionally treated as distributive predicates, which correspond to subsets of a do- main of (arbitrary) atomic entities. Standard GQT assigns determiners such as all, some and most denotations that are relations between such sets of atomic entities.
However, this treatment does not account for the interactions between quantifiers and collective predicates as in the following sentences.
All the colleagues cooperated. Some girls gathered. Most of the sisters saw each other.
According to most theories of plurals, nominals such as colleagues and sisters and verb phrases such as cooperated, gathered and saw each other denote sets of collections of atomic entities. For our purposes in this paper it is sufficient to assume that collections are sets of atomic entities. Thus, we assume that collective predicates denote sets of sets of atomic entities. Consequently, the standard denotation of determiners in GQT as relations between sets of atoms is not directly applicable to sentences with collec- tive predicates.
Early contributions to the study of collective quantification in natu- ral language, most notably [5], propose that meanings of “collective state- ments” as in (2) are systematically obtained from standard “distributive” denotations of determiners in GQT. More recent works, including (among others) [9,10] and [11,12], use type shifting operators that apply to a stan- dard determiner over a domain E, and derive a determiner of a higher type, which ranges over collections of elements in E. In this paper we fol- low [12] and adopt one general type shifting operator that is referred to as determiner fitting (dfit). This operator maps standard determiners over E to “collective” determiners over }(E) (relations between subsets of }(E)). A natural question that arises in this context is: what are the relations between the semantic properties of a standard determiner D and the prop- erties of its “collectivized” version d t(D)? Especially, we are interested here in the relations between the monotonicity properties of standard de-


terminers and the monotonicity of their collectivized counterparts. We first observe that monotonicity entailments are not always preserved when a determiner quantifies over collections. Consider for instance the con- trast between the sound entailment in (3a) and the lack of entailment in (3b) below.
a. All the students are happy ⇒ All the rich students are happy.
b. All the students drank a whole glass of beer together /⇒ All the rich students drank a whole glass of beer together.
In a situation where the students are s1; s2 and s3 and the rich students are s1 and s2 , assume that the group {s1; s2; s3} drank a whole glass of beer together, but no other group did. In this situation, the antecedent in (3b) is obviously true, but the consequent is false. This observation shows that when the determiner all quantifies over collections it “loses” its downward left monotonicity property.
It should be noted that the use of the collective predicate drank a whole glass of beer together is crucial in the observation that all loses its left mono- tonicity with collective predicates. However, this observation is obscured with many other collective predicates. For instance, the predicate be sim- ilar is reasonably “downward monotone” in the sense that if a set A is in its extension (i.e. the members of A are similar to each other), so is any subset of A with at least two members. Consequently, the entailment in
below holds, in contrast to (3b).
All the students are similar ⇒ All the rich students are similar.
However, in order to conclude that all is not left downward monotone with collective predicates, the existence of cases like (3b) is sufficient. The predicate drink a whole glass of beer together is general enough to establish non-left-monotonicity of all, since the existence of a set A whose mem- bers drank a whole glass of beer together does not entail the existence of any other set with the same property.
Unlike all, many other determiners do not lose their monotonicity prop- erties when they quantify over collections. For example, consider the de- terminer some, which is upward monotone in both its arguments. That some remains upward left monotone also with collective predicates can be observed in the following entailment.
Some rich students drank a whole glass of beer together ⇒ Some stu- dents drank a whole glass of beer together.
In distinction to this contrast between determiners concerning their left monotonicity, we claim that right monotonicity of determiners is al- ways preserved when they quantify over collections. This claim can be exemplified by entailments such as the following.
All the/more than five/some students drank a whole glass of dark beer together ⇒ All the/more than five/some students drank a whole glass of


beer together.
We will prove that using the dfit operator, these two general contrasts – between different determiners and between the left and right arguments – follow from the asymmetric conservativity principle of quantification in natural language that this operator presupposes.


Notions from Generalized Quantifier Theory
This section reviews some familiar notions from standard GQT that are important for the developments in subsequent sections. For an exhaus- tive survey of standard GQT see [4].
A generalized quantifier over a domain E is a function from }(E) to
{0; 1}. A determiner DE over a domain E is a function that maps each sub- set of E to a generalized quantifier over E. Thus, a determiner is a func- tion from }(E) × }(E) to {0; 1}. When the E domain is understood from the context, we omit it and sloppily refer to the determiner DE by ’D’. The main property of determiners that is studied in this paper is monotonicity.

Definition 2.1 (monotonicity) A determiner DE is left upward monotone
iff for all A; A0 ;B ⊆ E if A ⊆ A0 then DE (A)(B) = 1 ⇒ DE (A0 )(B) = 1.
DE is left downward monotone iff for all A; A0 ;B ⊆ E if A0  ⊆ A then
DE (A)(B) = 1 ⇒ DE (A0 )(B) = 1.
DE is right upward monotone iff for all A; B; B0 ⊆ E if B ⊆ B0 then DE (A)(B) = 
1 ⇒ DE (A)(B0 ) = 1.
DE is right downward monotone iff for all A; B; B0 ⊆ E if B0 ⊆ B then
DE (A)(B) = 1 ⇒ DE (A)(B0 ) = 1.
We say that DE is left (right) monotone iff it is either left (right) upward monotone or left (right) downward monotone.
We use the notations ↑MON, ↓MON and ∼MON for the classes of deter- miners that are upward-, downward- and non-monotone in their left ar- gument. Similarly for the right argument.
The denotation of determiner expressions varies with the choice of the domain E. A global determiner is a functional that maps a domain E to a (local) determiner DE . We say that a determiner expression and the global determiner functional D that it denotes are upward (downward) mono- tonic in their left (right) argument if DE has this property for every choice of E.
The following property characterizes the class of global determiners that remains “constant” across different isomorphic domains.
Definition 2.2 (isomorphism invariance) A global determiner D is isomor- phism invariant (ISOM) iff for all bijections   : E → E0 , for all A; B ⊆ E: DE0 ({ (x) : x ∈ A})({ (y) : y ∈ B}) = DE (A)(B).


We say that a global determiner D satisfies extension if the truth value that DE assigns to two subsets of E does not change when E is replaced by a superset of E. Formally,
Definition 2.3 (extension) A global determiner D satisfies extension
(EXT) iff for all A; B ⊆ E ⊆ E0 : D (A)(B) = D 0 (A)(B).
The well-known conservativity property of natural language determin- ers says that the truth value that they assign to any pair of sets does not depend on entities that are not members of the first argument. Formally,
Definition 2.4 (conservativity) A (local) determiner DE is conservative (CONS) over E iff for all A; B ⊆ E: DE (A)(B) = DE (A)(A ∩ B).
We say that a global determiner D is conservative if DE is conservative for every domain E.
The ISOM and EXT properties characterize the “logical” behavior of most natural language determiners. Conservativity is a restriction on the class of logical determiners, which reflects the special role of the first argu- ment of natural language determiners in restricting the domain of quan- tification. The following definition characterizes two trivial classes of con- servative logical determiners.
Definition 2.5 (left and right triviality) A (local) determiner DE is called left trivial (LTRIV) iff for all A; A0 ;B ⊆ E: D(A)(B) = D(A0 )(B). D  is called right trivial (RTRIV) iff for all A; B; B0  ⊆ E: D(A)(B) = D(A)(B0 ).
We say that a global determiner D is left (right) trivial if the local deter- miner DE is left (right) trivial for every domain E. Intuitively, a left (right) trivial determiner is insensitive to the identity of its left (right) argument. We occasionally restrict our attention to determiners that are not right trivial, because every such a conservative determiner is also not left trivial.
1
In this paper we study the monotonicity properties of non-RTRIV global determiners that satisfy ISOM, EXT and CONS. These determiners, which are the main focus of GQT, are referred to as quantifying non-trivial (QNT) determiners.

Determiner fitting and the witness condition
The dfit operator is defined as a conjunction of two operators. One oper- ator, called count, is a reformulation of the “neutral” operator of [5] and

1 Proof: Assume that D is conservative and LTRIV. For any domain E, by left triviality of D, we have for all A, B ⊆ E: DE (A)(B) = 1 iff DE (∅)(B) = 1. Conservativity of D entails that for every B ⊆ E: DE (∅)(B) = 1 iff DE (∅)(∅) = 1. We conclude that for all A, B ⊆ E: DE (A)(B) = 1 iff DE (∅)(∅) = 1. Especially: D is RTRIV. On the other hand, the determiner D s.t. DE (A)(B) = 1 iff A /= ∅ is an example for a conservative determiner that is RTRIV but not LTRIV.


[9,10].
Definition 3.1 (counting operator) Let D be a (local) determiner over E. The corresponding determiner count (D) over }(E) is defined for all A; B ⊆ 
}(E) by:

(count (D))(A)(B)
=  D(∪A)(∪(A∩ B)).

This process of counting members of collections consists of two sepa- rate steps: (i) a conservativity step, in which the second argument is mod- ified by intersecting it with the first argument; (ii) a participation step, in which the first argument and the result of step (i) are both unioned, and serve as the first and second arguments of the determiner respectively. To illustrate the process consider sentence (7) and its analysis in (8) be- low. Note that, as in most other theories of plurals, distributive predicates, which range over atoms, can be mapped to predicates that range over sets of atoms using a distributivity operator. The powerset operator } is suf- ficient as a distributivity operator for our purposes in this paper. For in- stance, the plural common noun students in (8) is treated as denoting the powerset of the singular noun student.
Exactly 5 students drank a whole glass of beer together.
count (exactly 50 )(}(student0 ))(drink beer0 )
⇔  exactly 5 (∪}(student ))(∪(}(student ) ∩ drink beer ))
⇔ |{x ∈ A : A ⊆ student ∧ drink beer (A)}| = 5 
The analysis in (8) guarantees that exactly five students participated in sets of students drinking beer.
It is easy to verify that the count operator respects the semantics of conservative determiners on distributive predicates in the following sense.

Fact 3.2 For every conservative determiner D over E, for all A; B ⊆ E: (count (D))(}(A))(}(B)) =  D(A)(B).
The major problem with the count operator is that its outcome is not always the intuitively correct one due to the lack of an existential require- ment. Reconsider sentence (7) and its analysis in (8) above. Proposition
(8) can be true in a situation where there is no set of five students who drank a whole glass of beer together. For instance, this may happen when there are exactly two sets of students in the extension of drank a whole glass of beer together: {s1; s2; s3} and {s4 ; s5}. Despite the truth of (8) in this situation, sentence (7) is intuitively false in these conditions. To solve this problem, we add to the count operator an “existential” condition that is formalized using a witness operator.
Definition 3.3 (witness operator) Let D be a local determiner over E. The corresponding determiner wit (D) over }(E) is defined for all A; B ⊆ }(E) by:


(wit (D))(A)(B) = 1 ⇔ A ∩ B = ∅∨ ∃W ∈A ∩ B[D(∪A)(W ) = 1].
In words: the witness operator maps a determiner D over E to a deter- miner over }(E) that holds of any two sets of sets A; B iff their intersection A∩ B is empty or contains a witness set of D and ∪A. 2
To exemplify the operation of the witness operator, consider the anal- ysis in (9) below of sentence (7).
wit (exactly 50 )(}(student0 ))(drink beer0 )
⇔ [}(student ) ∩ drink beer  /= ∅→ 
∃W ∈ }(student ) ∩ drink beer [exactly 5 (∪}(student ))(W )]]
⇔ ∃W ⊆ student [drink beer (W ) ∧ |W | = 5]
The analysis in (9) verifies that there exists at least one set constituted by exactly five students who drank a whole glass of beer together. By conjoin- ing (9) with (8) we get the intuitively correct interpretation of sentence (7). Accordingly, the general determiner fitting operator is a conjunction of the counting operator and the witness operator.
Definition 3.4 (determiner fitting operator) Let D be a local determiner over E. The corresponding determiner d t (D) over }(E) is defined for all A; B ⊆ }(E) by:
(d t(D))(A)(B) = 1  ⇔  (count (D))(A)(B) = 1 ∧ (wit(D))(A)(B) = 1:
This operator, similarly to the bounded composition operator of Dalrym- ple et al. in [2], 3 imposes an existential requirement on non-MON↓ de- terminers, but does not lead to undesired existential analyses with MON↓ determiners (cf. the warning in [8, p. 52-53]). The disjunct A ∩ B = ∅ within the witness operator prevents such undesired analyses.
It can be shown that fact 3.2 about the count operator is generalized to the case of the dfit operator. Formally,
Fact 3.5 For every conservative determiner D over E, for all A; B ⊆ E: (d t(D))(}(A))(}(B)) = D(A)(B).
Thus, when both arguments of a conservative determiner are distributive predicates, the witness operator is redundant in dfit.

2 Following [1], a witness set of a determiner D and a set A is any subset W of A that sat- isfies D(A)(W ) = 1. [1] define witness sets on generalized quantifiers explicitly, but they reach the argument A indirectly by defining what they call a live on set of the quantifier. This complication is unnecessary for our purposes.
A similar strategy for quantification over witness sets is proposed by Szabolcsi in [6]. While Szabolcsi’s witness operation is used only for MON↑ determiners, the witness op- erator that is defined above is designed to be used for all determiners.
3 The dfit operator and Dalrymple et al’s BC operator differ in their counting process. For instance, for sentence (7) to be true, the BC operator does not require that the total number of students who participated in groups of students drinking beer is exactly five, but only requires that each such group of maximal cardinality includes exactly five stu- dents. We leave a detailed comparison between Dalrymple et al’s BC operator and the proposed dfit operator to another occasion


Monotonicity properties of collective determiners
The main result in this paper is that determiners like all and not all, which are monotone in their left argument but have a different monotonicity property in their right argument, lose their left monotonicity under count. In contrast, determiners like some and no that have similar monotonic- ities in both arguments do not lose their left monotonicity under count. Right monotonicity is always preserved under count, as well as (right and left) non-monotonicity. Although we concentrate here on the count op- erator, it is not hard to show that all these results are naturally extended to the case of the general operator, dfit. Thus, it is not the existential re- quirement within the dfit operator that is responsible for the exceptional monotonicity properties of collective determiners, but the counting pro- cess itself that collective quantification involves.
The final results are summarized in table 1 for each of the nine classes of (non-)monotone determiners. The exclamation marks emphasize the cases in which left monotonicity is not preserved.

Table 1
(non-)monotonicity under dfit

The following simple fact characterizes all the cases in which mono- tonicity of determiners is preserved under count.
Fact 4.1 Let D be a determiner over E. If D is ↑MON↑ (↓MON↓), then the determiner count (D) over }(E) is also ↑MON↑ (↓MON↓). If D is MON↓ (MON↑), then count (D) is MON↓ (MON↑).
The proof of this fact follows directly from the definition of the count op- erator.
Non-monotonicity of QNT determiners is preserved under count, as stated in fact 4.2 below. The proof of this fact follows directly from fact 3.2.


Fact 4.2 Let D be a QNT determiner that is ∼MON (MON∼). Then the de- terminer count (D) over }(E) is also ∼MON (MON∼).
Proof. We only prove this fact for the case of ∼MON determiners. The proof for MON∼ determiners is similar.
Let E be a domain in which DE is ∼MON. Such a domain exists since there exist E0 and E00 such that D 0 is not ↓MON and D 00 is not ↑MON. Since D is EXT, we can choose E = E0 ∪ E00 .
Thus, there exist A ; A0 ;B ;A ; A0 ;B  ⊆ E such that A  ⊆ A0 and A  ⊆ A0 ,
1	1	1	2	2	2	1	1	2	2
and the following hold:
D  (A )(B ) = 1 and D  (A0 )(B ) = 0 (D is not ↑MON);
D  (A0 )(B ) = 1 and D  (A )(B ) = 0 (D is not ↓MON).
By corollary 3.2 (page 6) the following hold:

(count (D
))(}(A ))(}(B )) = 1 and (count (D
))(}(A ))(}(B )) = 0;

E	1	1
E	1	1

(count (D
))(}(A0 ))(}(B )) = 1 and (count (D
))(}(A ))(}(B )) = 0:

Since }(A ) ⊆ }(A0 ) and }(A0 ) ⊆ }(A ), we get that count (D ) is ∼MON,
1	1	2	2	E
which implies that count (D) is ∼MON.
Results pertaining to non-preservation of monotonicity under count are less straightforward, and they are therefore in the focus of the rest of this paper.
As mentioned above, the contrast between determiners with “mixed” monotonicity and determiners with similar monotonicity in both argu- ments, and the difference between the left argument and the right argu- ment, both stem from the “conservativity process” within count that inter- sects the right argument with the left argument. Recall that by definition,
(count (D))(A)(B) = D(∪A)(∪(A ∩ B)).  Intuitively, when D is a ↓MON↑
(↑MON↓) determiner and A and B are two sets of sets, replacing A in the left argument of count (D) by a subset (superset) A0 of A, does not guar- antee that the set ∪(A0 ∩ B) remains the same as ∪(A ∩ B), or a super- set (subset) of this set.  Hence, there is no guarantee that count (D) is a
↓MON (↑MON) determiner over }(E). By contrast, replacing A by a super- set (subset) A0 of A does guarantee that ∪(A0 ∩ B) is a superset (subset) of
∪(A∩ B) or equal to this set, which is the reason why for ↑MON↑ (↓MON↓) determiners left monotonicity is preserved.
Here we prove a “non-preservation” theorem for ↓MON↑ determiners. The “non-preservation” proof for the case of ↑MON↓ determiners follows directly, using the fact that any ↑MON↓ determiner is the negation of a
↓MON↑ determiner. Similarly, the non-preservation proof for ↑MON∼ de- terminers follows directly from the non-preservation theorem for ↓MON∼ determiners that is proven below.
Before we turn to the non-preservation theorems, it should be men- tioned that in each of the two classes, ↓MON↑ and ↑MON↓, there is a sin- gle QNT determiner that does not lose its left monotonicity under count.


These two determiners have a property to which we refer as triviality for plurals (PTRIV). Formally:
Definition 4.3 (triviality for plurals) A (local) determiner DE is called triv- ial for plurals (PTRIV) iff for all A; B; B0 ⊆ E: if |A| > 1 then D(A)(B) = D(A)(B0 ).
Informally, a PTRIV determiner is indifferent to the identity of its right argument, whenever its left argument is a set with two or more entities. However, plural nouns presuppose semantic plurality (e.g. the noun stu- dents presupposes that there are at least two students). Consequently, no plural noun could appear with such a determiner without leading to a triv- ial statement. Therefore, PTRIV determiners are not expected to be mem- bers of the class of plural determiners in natural language.
For the sake of presentation of our non-preservation results, we define the following condition.
Condition 1 We say that a global determiner D satisfies condition 1 iff there exist a domain E and three subsets of E: X; Y and Y 0 with |X| > 1 and Y 0 ⊆ Y ⊆ X such that:
(∗) DE (X)(Y ) = 1 and DE (X)(Y 0 ) = 0.
The next lemma claims that MON↑ determiners that are not PTRIV sat- isfy condition 1.
Lemma 4.4 Let D be a conservative global determiner that is MON↑ and not PTRIV. Then D satisfies condition 1.
Proof. Let E be a domain in which DE is not PTRIV. Then there exist A; B; B0 ⊆ E with |A| > 1 such that DE (A)(B) = 1 and DE (A)(B0 ) = 0. From conser- vativity of D we can assume, without loss of generality, that both B and
B0 are subsets of A. Since D is MON↑, it follows from DE (A)(B) = 1 that DE (A)(B ∪ B0 ) = 1. Therefore, the result holds for X = A, Y = B ∪ B0 and Y 0 = B0 .
Determiners that are ↓MON∼ satisfy condition 1 as well. This is proven in the next lemma. Note that this lemma also implies that a ↓MON∼ deter- miner is necessarily not PTRIV, and hence so is any ↑MON∼ determiner. This is the reason why there is no PTRIV exception for the case of ↓MON∼ and ↑MON∼ determiners.
Lemma 4.5 Let D be a QNT determiner that is ↓MON∼. Then D satisfies condition 1.
Proof. Let E be a domain in which DE is ↓MON∼ (cf. the proof of fact 4.2). Thus, there exist six subsets of E: A, A0 , B, B0 , C and C0 with B0 ⊆ B and C  ⊆ C0  such that DE (A)(B) = 1, DE (A)(B0 ) = 0, DE (A0 )(C) = 1 and
DE (A0 )(C0 ) = 0. ¿From conservativity, we can assume that B0 ⊆ B ⊆ A
and C ⊆ C0 ⊆ A0 , and it follows that both A and A0 are not the empty set.


If |A| > 1 then we simply choose X = A, Y = B and Y 0 = B0 . Otherwise, A = B = {x} for some x in E, and B0 = ∅. Since D is ISOM, we can assume that A ⊂ A0 (otherwise choose any permutation on E that maps x to an element in A0 ), and it follows that |A0 | > 1. By ↓MON, it follows from
DE (A)(B0 ) = 0 that DE (A0 )(B0 ) = 0. Therefore, we can choose X = A0 , Y = C and Y 0 = B0 = ∅.
Non-preservation of monotonicity in the left argument will follow imme- diately from the following lemma.
Lemma 4.6 Let D be a QNT determiner that is ↓MON. If D satisfies condi- tion 1, then the determiner count (D) over }(E) is ∼MON.
Proof. Using X; Y and Y 0 in condition 1, we define the following three subsets of }(E): A = }(X); A0 = }(X) \ {Y } and B = {Y; Y 0 }. With these definitions, the following relations hold: A0 ⊆ A; ∪A = X; ∪A0 = X; ∪(A∩ B) = Y and ∪(A0 ∩B) = Y 0 . By substitution in (∗) in condition 1 we get that:
DE (∪A)(∪(A∩ B)) = (count (DE ))(A)(B) = 1 and DE (∪A0 )(∪(A0 ∩ B)) =
(count (DE ))(A0)(B) = 0. Since A0 ⊆ A, it follows that count (DE ) ∈= ↓MON.
To prove that count (D) ∈= ↑MON, note that since D is not LTRIV, it follows from D ∈ ↓MON that D ∈= ↑MON. Thus, there exist a domain E and three subsets of E: A; A0 and B such that A ⊆ A0 , DE (A)(B) = 1 and DE (A0 )(B) = 
0. The rest of the proof directly follows from fact 3.2.
It is now straightforward to show that determiners that are ↓MON↑ or
↓MON∼ lose their left monotonicity property under count.
Theorem 4.7 Let D be a QNT determiner that is ↓MON↑. Then the deter- miner count (D) over }(E) is ∼MON↑ iff D is not PTRIV.
Proof. (⇐) Assume, first, that D is not PTRIV. It follows directly from lemma 4.4 and lemma 4.6 that count (D) is ∼MON. By fact 4.1, count (D) is MON↑.
(⇒) Assume that D is PTRIV. By fact 4.1, count (D) is MON↑. Let E be a do- main and let A; A0 and B be three subsets of }(E) such that A0  ⊆ A and
(count (DE ))(A)(B) = DE (∪A)(∪(A∩B)) = 1. We Show that (count (DE ))(A0)(B) = 
DE (∪A0 )(∪(A0 ∩ B)) = 1. There are three possibilities: |∪ A| > 1, ∪A = ∅ and ∪A = {x}. In the first two cases the proof is trivial. For the third case, note that from upward right monotonicity of D, D({x})({x}) =	1
and by CONS and ↓MON, D(∅)(∅) = 1. If ∪A0 = ∪A, then the lemma triv- ially holds. Otherwise, ∪A0 = ∅, which implies that DE (∪A0 )(∪(A0 ∩ B)) = D(∅)(∅) = 1.
Theorem 4.8 Let D be a QNT determiner that is ↓MON∼. Then the deter- miner count (D) over }(E) is ∼MON∼.
Proof. Directly by lemmas 4.5 and 4.6, count (D) is ∼MON. By fact 4.2,
count (D) is MON∼.
Examples for the result in theorem 4.8 with natural language determin-


ers are more complex, since we are not familiar with any lexical deter- miner that is monotone in its left argument but non-monotone in its right argument. However, such a compound determiner can be obtained by conjoining a determiner that is ↑MON↑ (e.g. some) with a determiner that is ↑MON↓ (e.g. not all). The result is a determiner such as some but not all, which is ↑MON∼ with distributive predicates. However, with collective predicates, some but not all is not ↑MON. Consider the lack of entailment in (10) below.
Some but not all of the rich students drank a whole glass of beer together
/⇒
Some but not all of the students drank a whole glass of beer together.
In a situation where the students are s1 , s2, s3 and s4 , the rich students are s1, s2 and s3, and there are only two groups that drank a whole glass of beer together: {s1; s2} and {s1; s2; s3; s4}, most speakers we consulted consider the antecedent of (10) to be true, whereas the consequent is false, in agreement with the analysis using the dfit operator.


Conclusion

The formal study of the interactions between quantifiers and collective predicates has to deal with many seemingly conflicting pieces of evidence that threaten to blur the interesting logical questions that these phenom- ena raise. In this paper we have studied the monotonicity properties of collective quantification, which is a central aspect of the problem of col- lectivity. We showed that to a large extent, the principles that underly monotonicity of collective quantification follow from standard assump- tions on quantification in natural language in general. The count operator, which is a straightforward extension of Scha’s ’neutral’ analysis of collec- tive determiners, involves a simple ’conservativity element’ – intersection of the right argument with the left argument, and a ‘participation element’ – union of both set of sets arguments. The conservativity element within the count operator is responsible for the two a priori unexpected asym- metries in the monotonicity behavior of collective determiners:
Only determiners with ’mixed’ monotonicity properties change their behavior when they quantify over collections.
Only the left monotonicity properties of such determiners may change in these cases.
We believe that the reduction of certain asymmetries in the domain of col- lective quantification to the well-known asymmetric conservativity prin- ciple is a desirable result that reveals another aspect of the central role that this principle plays in natural language semantics.


Acknowledgement
This research was supported by grant no. 1999210 (”Extensions and Implementations of Natural Logic”) from the United States-Israel Binational Science Foundation (BSF), Jerusalem, Israel. The second author was also partly supported by the fund for the pro- motion of research at the Technion, research no. 120-042. Part of the research by the sec- ond author was curried out during a stay at the Utrecht University, which was supported by an NWO grant no. B30-541. We are indebted to Johan van Benthem for his remarks, which initiated our interest in questions of monotonicity and collectivity. Thanks also to Nissim Francez, Ed Keenan and Shuly Wintner for their comments.

References
J. Barwise and R. Cooper.	Generalized quantifiers and natural language.
Linguistics and Philosophy, 4:159–219, 1981.
M. Dalrymple, M. Kanazawa, Y. Kim, S. Mchombo, and S. Peters. Reciprocal expressions and the concept of reciprocity. Linguistics and Philosophy, 21:159–210, 1998.
E. Keenan and J. Stavi. A semantic characterization of natural language determiners. Linguistics and Philosophy, 9:253–326, 1986.
E. Keenan and D. Westersta˚hl. Generalized quantifiers in linguistics and logic. In J. van Benthem and A. ter Meulen, editors, Handbook of Logic and Language. Elsevier, Amsterdam, 1996.
R. Scha.	Distributive, collective and cumulative quantification.	In
J. Groenendijk, M. Stokhof, and T. M. V. Janssen, editors, Formal Methods in the Study of Language. Mathematisch Centrum, Amsterdam, 1981.
A. Szabolcsi. Strategies for scope taking. In A. Szabolcsi, editor, Ways of Scope Taking. Kluwer, Dordrecht, 1997.
J. van Benthem. Questions about quantifiers. Journal of Symbolic Logic, 49:443–466, 1984.
J. van Benthem. Essays in Logical Semantics. D. Reidel, Dordrecht, 1986.
J. van der Does. Applied Quantifier Logics: collectives, naked infinitives. PhD thesis, University of Amsterdam, 1992.
J. van der Does. Sums and quantifiers. Linguistics and Philosophy, 16:509– 550, 1993.
Y. Winter. Flexible Boolean Semantics: coordination, plurality and scope in natural language. PhD thesis, Utrecht University, 1998.
Y. Winter. Flexibility Principles in Boolean Semantics: coordination, plurality and scope in natural language. MIT Press, Cambridge, Massachusetts, 2001. in press.
