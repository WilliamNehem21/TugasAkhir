Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 304 (2014) 127–149
www.elsevier.com/locate/entcs
Abstract Semantics for
K Module Composition
Codruta Girlea1 Grigore Rosu2
Computer Science Department University of Illinois at Urbana - Champaign
Urbana, USA

Abstract
A structured K definition is easier to write, understand and debug than one single module containing the whole definition. Furthermore, modularization makes it easy to reuse work between definitions that share some principles or features. Therefore, it is useful to have a semantics for module composition operations that allows the properties of the resulting modules to be well understood at every step of the composition process. This paper presents an abstract semantics for a module system proposal for the K framework. It describes K modules and module transformations in terms of institution-based model theory introduced by Goguen and Burstall.
Keywords: Module System, K, Semantics, Institutions, Abstract Modules


Introduction
The K executable semantic framework [1] allows one to define programming lan- guages, calculi and even algorithms, by means of configurations, computations and rules. For example, in order to define a certain programming language, one must: define the syntax of the language; define the initial configuration of any program written in that language — thus also establishing the structure of its configura- tions; and specify the semantics of programs by means of rewrite rules that show how the language constructs affect the program configuration. More details on the K framework can be found in [1].
The K technique allows for modularization and parallelism by means of conﬁgu- ration abstraction, which means that in order to add features to a certain program- ming language, one only has to add the desired rules and configuration cells, without changing anything that has been written so far. But adding a certain feature still

1 Email: girlea2@illinois.edu
2 Email: grosu@illinois.edu

http://dx.doi.org/10.1016/j.entcs.2014.05.007
1571-0661/© 2014 Elsevier B.V. All rights reserved.

involves editing the existing definition, which means creating different extensions of a language, with different sets of features; furthermore, if one wants to add, for example, barriers to two or more programming languages that support threads, one would still have to do it separately for each of those languages.
Ideally, in order to add new features to programming languages, one should not have to write anything in the existing definitions. This can be done by writing a module for each feature, and in order to use the extended language, by using the existing definition together with the modules that define the features — as will be seen, this operation is called aggregation. To ensure that the semantics is preserved between the base definition and the feature definitions, each module has a section that specifies which constructs must be available to it and what behavior it expects from them — this is the ’required’ part of the module. To ensure proper encapsulation, every module should state which constructs and behaviors it defines, that are accessible to any other module — this is the ’exported’ part of the module.
For example, in order to add the ’++’ increment operation to a very simple imperative language, IMP (see, e.g., [1]), one would define a module that:
requires sorts Int, AExp, Id, Map; an operation + on Int; two configuration cells
<env/> and <store/>, each holding a Map; additionally, certain properties of these operations may also be required;
adds ++Id as a new AExp language construct and defines its desired behavior,
rule <k> ++X:Id => I + 1 ...</k>
<env>... X |-> N:Int ...</env>
<store>... N |-> (I:Int => I + 1) ...</store>
exports AExp and ++.
Barriers are synchronization mechanisms that ensure that all threads have reached a certain point in a program before the computation in any of the threads continues. In order to add barrier as a language construct to IMP, one would only require a sort Stmt and a cell <thread/>, define the behavior of a new language construct barrier and export barrier and Stmt.
As mentioned before, in order to get the extended language, one only has to aggregate the feature modules and the module of the basic definition; the names of the required definition in the feature modules need not be the same as the names in the original definition — before the aggregation mentioned above, a renaming step can be performed so that the proper names are given to the syntactic entities and cells. Furthermore, in some cases, the same feature modules can be reused, with different renamings, for different base languages.
Another way to extend a definition is to use enriching, directly — this is prefer- able when the features added are either not complex enough or have limited potential for reusability.
Another way to reuse a module is by hiding some features. For example, after defining exceptions in a functional programming language, by means of call-with- current-continuation (call/cc), one may want to hide the call/cc construct and allow users of the language to only use the exceptions provided.

The motivation for this paper comes from the need for a module system for K, and the inspiration for our particular notation and format for modules comes from previous work by Hills and Rosu [9], where they describe the intended syntax and usage of K modules from a pragmatic point of view. Indeed, the distinction be- tween the visible part and the rest of the signature reduces the interactions between modules, whereas allowing a required part simplifies dealing with those interactions, however complex, since one does not need to be concerned with the order in which modules are implemented. We analyze the theoretical properties of our module system using institution-based model theory [6]. The K Institution is assumed to have the desired properties — proving that this is indeed the case is left as future work, and so it the implementation of our module system. Given the nature of this work, although the K module system is the main motivation, we believe that the proposed abstract module system may prove useful to other systems as well.
Our semantics is similar to the module semantics described by Goguen and Rosu [7,3]. Thus, a module is seen as a presentation in a given institution (the definition of the module), where the visible part of the module (visible signature or interface) is a sub-signature of the module definition signature (the working signature), and the visible theorems are the restriction to this signature of the set of theorems of the module [7]. In addition to those, a K module may assume a part of its definition as already implemented and state this part as a required presentation. As such, the definition of a K module has the following general form:
module M {
requires ρ, Kρ
exports ψ
Σ,K
}
Σ, ψ and ρ are the working, visible and required signatures, respectively (where ψ and ρ are subsignatures of Σ) and Kρ, K are the required and working theorems, respectively.
We assume the institution we are working in has an inclusion system [2] on signatures, wherein each signature morphism σ can be factored (uniquely up to isomorphism) as the composition σ = e; ι of an abstract surjection e and an abstract inclusion ι. Furthermore, we assume the institution is inclusive [3] and that the model functor of the institution (Mod) preserves pushouts and coproducts.
The module operations we define the semantics of are: renaming, hiding, en- riching and aggregation.
Renaming allows the reuse of modules with different names for the required and visible symbols and it only makes sense if it translates the symbols that those two signatures share in a consistent manner. Intuitively, renaming does not add new symbols to the signature, thus the morphims that define the renaming are surjections.
Hiding allows a part of the visible signature to no longer be visible in the new module.

Enriching, as opposed to hiding, adds new symbols and sentences to the module. One can also add new symbols and particularly sentences to the set of requirements, which is still, by definition, an enriching, but in this case the effect is that of constraining (if new sentences are added), as the set of elements required to define the module grows.
Aggregation allows two modules to be combined into one single module.
If a module defines everything it requires, it is called complete. Using all the above operations on a set of modules, one can define a structured module. One can obtain a complete structured module even if some or all the base modules used are incomplete.

1.1	Related Work
Probably the first module system for specification languages was described by Bergstra et. al. [11]. Their system is not based on institutions, but their mod- ule operations were used in a similar manner in most institution-based module systems to follow. They do not describe parametrization and, while not directly specifying a visible sub-signature, parts of the signature can be hidden using the hiding operation.
The first abstract module system using institution-based model theory was pro- posed by Diaconescu et. al. [2]; here, a module was just a presentation, consisting of a signature in a certain institution, and a set of sentences of the signature, spec- ifying the behaviour of the constructs. Operations for sum, renaming and hiding are defined on modules and some properties of those operations such as distributive laws are analyzed.
The system proposed by Goguen et. al. [8] allows a module to specify its imported modules, as well as its visible part. The modules are defined here using partial signatures. The notion of an implementation module, for a specification module, is introduced. Hiding, enriching, renaming and aggregation operations are defined for specification modules, and renaming and aggregation of implementation modules are also introduced.
The module system of the CASL specification language [13] allows hiding and revealing sorts from a specification. These operations are supported by our module system as hiding and a particular type of enriching. CASL also support the free operation, that changes the semantics of a module to the initial/free model.
Maude’s module system [12] allows module imports, as well as more general morphisms, parametrization and freeness constraints. Our system does not allow freeness constraints, or any operations that specifically target the semantics of a module. This kind of constraints may be worth exploring once the K institution has been defined and its liberality explored.
This work in this paper particular is an extension of the abstract module system introduced by Rosu and Goguen [7] [3] — in particular, the exported part of the module is defined in the same way as the visible signature, as a sub-signature of the working signature. In addition, we add the required part of the module, also

a sub-signature of the working signature, and the required behaviours, as a set of sentences. This addition makes it possible to assume that some elements a module relies on are already implemented and treat them as such, after stating the fact that they are required. Even though, at implementation time, these ’required’ elements make that particular module incomplete, all the modules involved, implemented separately, will be aggregated into a final system that is complete and additionally makes it easier to handle the interdependecies between modules, particularly when these are too complex to structure using only imports and views.
Even though most operations used in the Rosu and Goguen’s module system can be adapted without much difficulty to this new setting, keeping track of the required sub-signature leads to interesting situations and, in fact, to some particular cases of the module operations than can be significant operations in their own right. An example is enriching, where ’enriching’ the required sub-signature and in particular the required behaviour has an opposite effect, of ’constraining’ the elements needed for the module. Rosu and Goguen define the hiding, enriching, renaming, aggregation and parametrization operations for the modules they define. We only analyze hiding, enriching, renaming and aggregation here.
Parametrization is an interesting case because, again, there are two directions from which we can parametrize. We can parametrize a module in a way similar to the one described by Rosu and Goguen [7]. We need to make sure that when we instantiate the module, the module morphisms from parameters to the modules we use to instantiate are consistent on the required and visible part, in a manner similar to the way we will require renaming to be consistent. This way, the instantiated module will have a well defined required signature, including the (transformed) requirements of ’instantiated’ parameters. On the other hand, we may be interested in parametrizing the required signature. We leave to future work an analysis of the interactions between requirements and parametrization, as well as the usefulness of including both or just one of the previously mentioned cases of parametrization.
ELAN [10] also uses a module system based on a visible part (specified by the keyword global) and a hidden signature (specified by the keyword local). The ELAN module system uses imports, but does not specify required elements for the module. Our module system allows visibility control by specifying the exported elements and by using the hiding and enriching operations. Furthermore, using a required signatures allows more flexibility in implementation.
Background
In this section we introduce some concepts needed for the work presented in this paper; we assume the reader familiar with basic concepts of category theory [14] and only go over the concepts to be used in the rest of the paper.
Inclusion systems
We use the inclusion systems as defined in [2] — intuitively, these systems generalize the ’natural’ inclusion system of sets, where each function can be factorized as a

A,˛ ι	zB,

Fig. 1. Pushouts which preserve inclusions

composition of a surjection and an inclusion. Unions and intersections are also gen- eralized as coproducts and respectively products of inclusions. Inclusive categories and functors are as defined in [3].
Definition 2.1 Let C be a category. An inclusion system is a pair of subcate- gories (I, E ) of C, called inclusions and respectively surjections, with the following properties:
|C| = |I| = |E|
I(A, B) has at most one element for each A, B ∈ |C|
for every A, B ∈ |C|, if both I(A, B) and I(B, A) are non-empty, then A = B
for any morphism f ∈ C(A, B), there is a unique C ∈ C and a unique pair (e, i) ∈ |E (A, C)|× |I(C, B)| such that e; i = f
I has finite coproducts
Definition 2.2 A category C is called inclusive (or it has strong inclusions) if there is a subcategory I of C such that the following hold:
I is a poset
I has finite products ∩ (called intersections)
I has finite coproducts ∩ (called unions)
for every pair A, B ∈ |C|, A ∪ B is a pushout of A ∩ B
I has an initial object ∅
If I(A, B), then let A ‹→ B be the unique morphism in I(A, B).
Definition 2.3 Let A, B be two categories. A functor F : A → B is called inclusive
if it takes inclusions in A to inclusions in B.

Definition 2.4 A category C has pushouts which preserve inclusions if:
it is inclusive
for any objects A, Aj,B in |C| and any morphisms f : A → Aj, ι : A → B, where ι is an inclusion, there is a pushout {Bj,fj, ιj}, with fj : B → Bj and ιj : Aj → Bj, such that ιj is also an inclusion (see Figure 1)

Institutions
Institutions were introduced by Goguen and Burstall [6] as a means to represent logical systems in a unified, abstract manner: the syntax is given by a category of signatures and a functor that gives, for each signature, its set of sentences; the semantics is given by a functor that attaches a category of models to each signature, and by the satisfaction relation between models and sentences of the same signature. Many logics have been formalized as institutions, including equational logic [4], higher order logic [5] and many others [15].
Definition 2.5 An institution I is a tuple (Sign, Sen, Mod, |=) where:
Sign is a category; the objects of Sign are called signatures
Sen : Sign → Set is a functor; the objects of Sen(Σ), where Σ ∈ |Sign| is a signature, are called the sentences of Σ
Mod : Signop → Cat is a functor; the objects of Mod(Σ), where Σ ∈ |Sign| is a signature, are called the models of Σ
for each Σ ∈ Sign, |= is a relation |=⊂ |Mod(Σ)|× |Sen(Σ)|; if M ∈ Mod(Σ), φ ∈ Sen(Σ) and M |= φ, we say M satisfies φ.
For an institution I = (Sign, Sen,Mod, |=), for Σ, Σj ∈ Sign, f : Σ → Σj and Mj ∈ |Mod(Σj)|, Mod(f )(Mj) ∈ Mod(Σ) is called the reduct of Mj via f and is written Mj Tf . If the signature morphism is clear from the context, we will write Mj TΣ. The intuition is that the reduct is that part of the model of the second signature, that can be recovered using only symbols from the first signature, and is usually ’smaller’. The meaning of this, as the actual definition of the reduct, varies across logics. A simple example is for the case of First Order Logic, for a signature morphimsm that adds a sort s to a signature Σ. Given a model M of Σ {s}, its reduct is a model that is exactly the same as M , but without the interpretation of s.
Conservativeness is a property of signature morphism that ensures that models are not ’lost’ in translating between signatures. More specifically, it means that every model in the first signature has a corresponding model in the second, that reduces to it.
Definition 2.6 Given an institution I = (Sign, Sen, Mod, |=), a signature mor- phism f :Σ → Σj is conservative if for every model M ∈ Mod(Σ), there is a model Mj ∈ Mod(Σj) such that Mj Tf = M
We further describe the notion of inclusive institution, which assumes an inclu- sion system on the category of signature, which translates in an intuitive manner to inclusions of respective sets of sentences and to interpretations.
Definition 2.7 An institution I = (Sign, Sen, Mod, |=) is inclusive if:
Sign is an inclusive category;
Sen is an inclusive functor;

Σ, M1 T = M2 Tgg	zΣ2,, M2

f
,	f′

g′
j , 

Σ1, M1 	zΣ,∃!M
Fig. 2. Model amalgamation
Mod preserves pushouts which preserve inclusions
Model amalgamation is a property that allows consistent aggregation of signa- tures - and eventually of specifications, as we will see. It essentially says that if two signatures ’share’ some symbols, then any two models of the signatures that are consistent on the ’shared’ symbols can be extended to the same model in the sum of the two signatures - and there is only one model in the sum of the signatures with this property.
Definition 2.8 An institution I = (Sign, Sen,Mod, |=) has model amalgamation iff for every pushout square (f : Σ → Σ1,g : Σ → Σ2,fj : Σ1 → Σj, gj : Σ2 → Σj) of signatures (see Figure 2), for every M1 ∈ |Mod(Σ1)|, M2 ∈ |Mod(Σ2)| such that M1 Tf = M2 Tg, there is a unique model M ∈ |Mod(Σj)| such that M Tf′ = M1 and M Tg′ = M2.
Without requiring uniqueness, this is called weak amalgamation. A more re- strictive property similar to amalgamation is exactness:
Definition 2.9 An institution I = (Sign, Sen, Mod, |=) is exact if the Mod functor preserves colimits, i.e. it translates signature colimits to limits in Cat.
A weaker form of exactness, called semiexactness, only requires Mod to preserve pushouts.
The Abstract Module System
In this section, we give the definition of an abstract module, show some of its properties and define the abstract module operations.
In the following we will assume we are working in an inclusive institution
I = (Sign, Sen, Mod, |=) ; let I be the inclusion subcategory and E the surjection subcategory. The inclusions will also be referred to as ‹→. In addition, we assume the category of signatures Sign has strong inclusions and pushouts which preserve inclusions and that Mod preserves pushouts and coproducts.
Although we haven’t yet formalized the K institution, we believe that it will satisfy many of these properties. The essential property here is the inclusive signa- ture category, i.e. inclusions, unions and intersections of signatures, in the intuitive sense. We believe that this is a necessary and likely requirement for any module system, and that for K, it will result from the inclusion system on sets. For this latter reason, the sentence functor is also expected to be inclusive, inclusions on signatures translating to inclusions of their sentence sets. It may be challenging to analyse the model functor’s effect on pushouts and coproducts, but we do note

that preserving them is only necessary for aggregation. However, as also mentioned for model amalgamation, at least a weak version of this property is essential for aggregation in general.
The Modules
A module can be represented as:
module M {
requires ρ, Kρ
exports ψ
Σ,K
}
where Σ, ψ and ρ are the working, visible and required signatures, respectively (where ψ and ρ are subsignatures of Σ) and Kρ, K are the required and working theorems, respectively. Formally:
Definition 3.1 A module specification is a structure of the form
M = (ρ, Kρ, ψ, Σ, K) where:
Σ, ρ,ψ ∈ Sign and ιρ : ρ ‹→ Σ, ιψ : ψ ‹→ Σ are signature inclusions; Σ is the working signature of the module, ρ is the required signature and ψ is the visible signature (or interface) of M;
Th(M)= K ∈ Sen(Σ) is the set of working theorems of the module ; 
Rth(M)= Kρ ∈ Sen(ρ) is the set of assumed or required theorems of the module. The visible theorems of M are therefore
V th(M)= Kψ = ι—1((K ∪ ιρ(Kρ))•)	(1) where, for a set Γ of sentences with signature Σ, Γ• is its semantic closure:
Γ• = {ρ ∈ Sen(Σ) | ∀M ∈ Mod(Σ), if M |=Γ then M |= ρ}	(2)
Below we prove that unions of semantically closed sets are also semantically closed, and in particular this holds for the visible theorems of a module.
Fact 3.2 If Σ ∈ Sign and A, Aj ∈ Sen(Σ) are closed sets of sentences, then:
A ∩ Aj = (A ∩ Aj)•
Proof.
The direct inclusion follows from the closure definition: A ∩ Aj ⊆ (A ∩ Aj)•.
For the inverse inclusion, let a ∈ A ∩ Aj. Then a ∈ A and a ∈ Aj, and since A
and Aj are both closed, i.e. A = A• and Aj = Aj•, this means
∀ρ ∈ A, ∀m ∈ Mod(Σ) such that m |= ρ, it follows m |= a, and
∀ρj ∈ Aj, ∀mj ∈ Mod(Σ) such that mj |= ρj, it follows mj |= a

This means that ∀ρ ∈ A ∩ Aj, ∀m ∈ Mod(Σ) such that m |= ρ, it follows m |= a, which means that a ∈ (A ∩ Aj)•	2
Fact 3.3 Given a module speciﬁcation M, its set of its visible theorems is seman- tically closed:

Proof.
V th(M)= V th(M)•

Let Γ = K ∪ ιρ(Kρ) ∈ Sen(Σ).
Since the working institution is inclusive, it follows
V th(M)= ι—1(Γ•)= Sen(ψ) ∩ Γ•	(3)
Since Sen(ψ) is trivially closed, using Fact 3.2 (note that K and iρ(Kρ) have the same signature Σ):
V th(M)• = (Sen(ψ) ∩ Γ•)• = Sen(ψ) ∩ Γ• = V th(M)	(4)
2
A module is complete if it defines everything it requires. We need this notion because we are not working with partial signatures: we have defined the required signature to be a subsignature of the working signature; therefore, what we really describe when we write the definition is the part of the working signature not contained in the required signature, so if what the module defines does not in fact entail what it requires, the module is incomplete, and we cannot work with it. Ideally, after applying module operations, we will eventually obtain and work with complete modules.
Definition 3.4 We say a module M = (ρ, Kρ, ψ, Σ, K) is complete if ιρ(Kρ) ⊆ K•
Consequently, the visible theorems of a complete module are Kψ = ι—1(K•)
The module operations we will further define will be special cases of module morphisms, as defined below:
Definition 3.5 The module specification morphisms (g, h) : (ρ, Kρ, ψ, Σ, K) →
(ρj, Kρ′ , ψj, Σj, Kj) are pairs of morphisms where
g : (ρ, Kρ) → (ρj, Kρ′ ) is a presentation morphism
h : ψ → ψj is a signature morphism with h(V th(M)) ⊆ V th(Mj)
So essentially, a module morphism specifies transformations on the visible, as well as on the required part of the module.
A model of a module must follow the behaviour specified by the visible theorems. Additionally, it must have a respective model that satisfies the required behaviour. This follows automatically if the model can be extended to the full, hidden signature.
Definition 3.6 Let M = (ρ, Kρ, ψ, Σ, K) be a module specification and m a ψ model. Then model m satisfies the module specification, or m |= M, if m |=ψ V th(M) and there is an expansion mj of m to Σ such that mj Tρ|=ρ Kρ,

Note 1 If all the inclusions are conservative signature morphisms, then m |=ψ V th(M) is a sufficient condition for module satisfaction: if there is an expansion mj of m to Σ, then it follows using the deﬁnition of the satisfaction relation that mj Tρ|=ρ Kρ.
The Module Operations
In this subsection, we will define and analyze the semantics of the following module operations: renaming, hiding, enriching and aggregation; parametrization will be analyzed as future work.
Renaming allows reusing modules by translating the names of the required and visible symbols. Intuitively, renaming does not add new symbols to the signature, thus the morphims that define the renaming are surjections. Hiding allows a part of the visible signature to be ’retracted’ or hidden, thus no longer accessible to other modules. Enriching adds new constructs and behaviours to the module. Similarly to the way renaming can be seen as a ’surjection’ on modules, hiding and enriching make use of inclusions. Aggregation allows two modules to be combined into one single module.
For the rest of this section, we will consider this small example:
module Xor
requires sort Bool
requires op or: Bool Bool -> Bool requires op not: Bool -> Bool requires op and: Bool Bool -> Bool exports op xor: Bool Bool -> Bool exports sort Bool
rule X:Bool xor Y:Bool => (X and not Y) or (not X and Y) end module
Renaming
Renaming only makes sense if it translates the symbols that those two signatures share in a consistent manner. Then, renaming can be performed on the union of the two signatures.
This is what the following lemma states:
Lemma 3.7 • Let ρ, ψ ∈ Sign and surjections g : ρ → ρj, h : ψ → ψj such that if ιρ; g = eg; ιg is the unique factorization of ιρ; g and ιψ; h = eh; ιh is the unique factorization of ιψ; h, then eg = eh = e (where ιρ : ρ∩ψ ‹→ ρ, ιψ : ρ∩ψ ‹→ ψ); then there is a unique f (g, h): ρ∪ψ → ρj∪ψj such that (ρ ‹→ ρ∪ψ); f = g; (ρj ‹→ ρj∪ψj) and (ψ ‹→ ρ ∪ ψ); f = h; (ψj ‹→ ρj ∪ ψj) and furthermore f (g, h) is a surjection as well.
Let ρ, ψ ∈ Sign, ιρ : ρ∩ψ ‹→ ρ, ιψ : ρ∩ψ ‹→ ψ and a surjection f : ρ∪ψ → (ρ∪ψ)j; then there is a unique pair of surjections g(f ): ρ → ρj, h(f ): ψ → ψj such that if ιρ; g(f )= eg; ιg is the unique factorization of ιρ; g(f ) and ιψ; h(f )= eh; ιh is the unique factorization of ιψ; h(f ), then eg = eh = e and furthermore (ρ∪ψ)j = ρj∪ψj

ρ ˛ 
g	zzρj,,˛¸




ιρ



,,	e
r¸
ρ ∪ ψ
 ,	f
,,
c¸ zρ ,∪ ψ
 ,

ι2

ρ ∩ ψ˛ 
zzX,,. _
ιh
r,,¸	c,, 

ψ	zzψ,j,
h
Fig. 3. Building f(g,h)
If g : ρ → ρj, h : ψ → ψj are as above then g(f (g, h)) = g and h(f (g, h)) = h
If f : ρ ∪ ψ → (ρ ∪ ψ)j is as above then f (g(f ), h(f )) = f
Proof.
Since Sign has strong inclusions, it follows that the union is a pushout of any pair of inclusions from the same object. Then let (ι1, ι2, ρj ∪ ψj) be the pushout of (ιg, ιh) (it follows ιg; ι1 = ιh; ι2).
Since (ρ ‹→ ρ ∪ ψ, ψ ‹→ ρ ∪ ψ, ρ ∪ ψ) is a pushout in Sign and ιρ; g; ι1 = e; ιg; ι1 = e; ιh; ι2 = ιψ; h; ι2, it follows there is a unique f : ρ ∪ ψ → ρj ∪ ψj such that (ρ ‹→ ρ ∪ ψ); f = g; ι1 and (ψ ‹→ ρ ∪ ψ); f = h; ι2.
In order to prove f is a surjection, let f = ef ; ιf be the unique factorization of f and (ψ ‹→ ρ ∪ ψ); ef = ej; ιj the unique factorization of (ψ ‹→ ρ ∪ ψ); ef . Let X be such that ef : ψ ∪ ρ → X.
Then using the properties of f , (ψ ‹→ ρ∪ψ); f = (ψ ‹→ ρ∪ψ); ef ; ιf = ej; ιj; ιf = g; (ψj ‹→ ρj ∪ ψj) and since g ∈E and due to the uniqueness of the factorization, it follows ej = g and (ψj ‹→ ρj ∪ ψj)= ιj; ιf .
Therefore ιj : ψj → X and analogously we can find an inclusion ιjj : ρj → X; since the union is a coproduct, it follows there is a unique inclusion ιjjj : ψj ∪ ρj → X; given ιf : X → ψj ∪ ρj it follows X = ψj ∪ ρj, therefore ιf = 1ψ′∪ρ′ and ef = f , therefore f is a surjection.

Let g; ιj
= (ρ ‹→ ρ ∪ ψ); f be the unique factorization of (ρ ‹→ ρ ∪ ψ); f and

h; ιj
= (ψ ‹→ ρ ∪ ψ); f , the unique factorization of (ψ ‹→ ρ ∪ ψ); f (with g, h ∈ E ).

Let (ι1, ι2, ρj ∩ψj) be the pullback of (ιj , ιj , (ρ∪ψ)j). Since (ιρ; g); ιj
= ιρ; (ρ ‹→

1  2	1
ρ∪ψ); f = ιψ; (ψ ‹→ ρ∪ψ); f = (ιψ; h); ιj , it follows there is a unique fj : ρ∩ψ →
ρj ∩ ψj such that fj; ι1 = ιρ; g and fj; ι2 = ιψ; h.
From here we can derive the unique factorizations for ιρ; g as ef′ ; (ιf′ ; ι1) and for ιψ; h as ef′ ; (ιf′ ; ι2) with the desired property (where fj = ef′ ; ιf′ is the unique factorization of fj)
Let ι : ρj ∪ ψj ‹→ (ρ ∪ ψ)j be the inclusion defined by the coproduct property of the union. In order to prove (ρ ∪ ψ)j = ρj ∪ ψj, it is enough to find an inclusion from (ρ ∪ ψ)j to ρj ∪ ψj.

Since as shown ιρ; g; ιj
= ιψ; h; ιj
it follows:

· since Sign has strong inclusions, (ρ ∪ ψ, ρ ‹→ ρ ∪ ψ, ψ ‹→ ρ ∪ ψ) is a pushout in

ρ ˛ 
g	zρj,˛¸



r¸
ρ ∪ ψ
 ,
f (g,h)
jc¸ j
zρ ,∪ ψ˛ 








ιψ
,,,
r¸	f (g,h)Σ
 ˛

ιψ′
,j¸
r¸ zΣ(,g,h)

ψ	h	zψ,
Fig. 4. Renaming

Sign, therefore, since by construction g; ιj
= (ρ ‹→ ρ ∪ ψ); f and h; ιj
= (ψ ‹→

ρ ∪ ψ); f , f is unique with this property.
· since inclusions are monomorphisms and (ρj ‹→ ρj ∪ ψj); ι = ι1 and (ψj ‹→ ρj ∪ ψj); ι = ι2, it follows ιρ; g; (ρj ‹→ ρj ∪ ψj) = ιψ; h; (ψj ‹→ ρj ∪ ψj) and given (ρ ∪ ψ, ρ ‹→ ρ ∪ ψ, ψ ‹→ ρ ∪ ψ) is a pushout in Sign, there is a unique fjj : ρ ∪ ψ → ρj ∪ ψj with g; (ρj ‹→ ρj ∪ ψj) = (ρ ‹→ ρ ∪ ψ); fjj and h; (ψj ‹→ ρj ∪ ψj)= (ψ ‹→ ρ ∪ ψ); fjj and let fjj = ef′′ ; ιf′′ be its unique factorization.
Then
(ρ ‹→ ρ ∪ ψ); fjj; ι = g; (ρj ‹→ ρj ∪ ψj); ι = g; ι1 and analogously (ψ ‹→ ρ ∪ ψ); fjj; ι = h; ι2, therefore using the previous result f = fjj; ι = ef′′ ; (ιf′′ ; ι) and since f is a surjection, it follows ιf′′ ; ι is an identity and ιf′′ : (ρ ∪ ψ)j ‹→ ρj ∪ ψj Since (ρ ∪ ψ)j ‹→ ρj ∪ ψj and ρj ∪ ψj ‹→ (ρ ∪ ψ)j, it follows ρj ∪ ψj = (ρ ∪ ψ)j
The last two claims follow from the points above.
2
If the renamings on the visible and required part are consistent, then the renamed module can be retrieved from the pushout of the original hidden signature and the union of the renamed interfaces. If the signatures are sets, this means that we only rename the interfaces, and possibly symbols in the hidden signature if they clash with new names in the interfaces, the latter being added in the new hidden signature as distinct copies.
Definition 3.8 Let M = (ρ, Kρ, ψ, Σ, K) be a module specification and g : ρ → ρj, h : ψ → ψj surjective signature morphisms such that if (ρ ∩ ψ ‹→ ρ); g = eg; ιg and (ρ ∩ ψ ‹→ ψ); h = eh; ιh are the unique factorizations, then eg = eh = e. The renaming of M by (g, h), written M∗ (g, h), is defined as
M∗ (g, h)= ρj, g(Kρ), ψj, Σ(g,h),f (g, h)Σ(K))
where (ι, f (g, h)Σ, Σ(g,h)) is the pushout of ((ρ ∪ ψ ‹→ Σ),f (g, h)).
Given the lemma and since ρ ‹→ Σ, ψ ‹→ Σ and Sign has pushouts that preserve inclusions, the definition is consistent.
We also note that given the assumption on the model functor, the renamed interfaces are included in the new hidden signature: since f (g, h): ρ ∪ ψ → ρj ∪ ψj,

it follows (ρj ‹→ ρj ∪ ψj); ι : ρj ‹→ Σf and (ψj ‹→ ρj ∪ ψj); ι : ψj ‹→ Σf , therefore
M∗ (g, h) is a module specification in the sense of Definition 3.1.
Equivalently, the renaming can be defined using a single morphism on the unions f  : ρ ∪ ψ → ρj(f ) ∪ ψj(f ) (as in the lemma) as M ∗ f  = (ρj(f ), g(f )(Kρ), ψj(f ), Σf , fΣ(K)).
The following theorem ensures that the required and visible sentences are trans- lated consistently via renaming.
Theorem 3.9 The renaming of a module speciﬁcation is a module speciﬁcation morphism (in the sense of Deﬁnition 3.5).
Proof.
Let M∗ (g, h) be the renaming of M by (g, h). Then g, h are as follows, fulfilling the conditions of Definition 3.5:
g : (ρ, Kρ) → (ρj, g(Kρ)) is trivially a presentation morphism (g(Kρ) |= g(Kρ));
for h : ψ → ψj, since h(V th(M)) ⊆ V th(Mj) and h; ιψ′ = ιψ; f (g, h)Σ(K), it follows
f (g, h)Σ((K ∪ ιρ(Kρ)) ) ⊆ (f (g, h)Σ(K) ∪ ιρ′ (g(Kρ)))	(5)
since g; ιρ′ = ιρ; f (g, h) and also given the commutativity in the pushout diagram, it follows from here that
f (g, h)Σ(K) ∪ ιρ′ (g(Kρ)) |= f (g, h)Σ((K ∪ ιρ(Kρ)) )	(6)
2
The following theorem establishes the semantics of renaming, showing the con- nection between the semantics of the initial module and the semantics of the module obtained by means of renaming.
Theorem 3.10 Given M = (ρ, Kρ, ψ, Σ, K) a module speciﬁcation, M∗ (g, h) its renaming by g and h and m ∈ Mod(M∗ (g, h)):
m |= M∗ (g, h) ⇒ m Th|= M
If additionally the inclusions are conservative, m |= M∗ (g, h) iff m Th|= M
Proof.
(i) ⇒
Assume m |= M∗ (g, h). Then m |= V th(M∗ (g, h)) and there is mj ∈
Mod(Σ(g,h)) with mj Tψ′ = m and mj Tρ′ |= g(Kρ).
Using Theorem 3.9 above and Definition 3.5, it follows m Th|= V th(M). Given g; ιρ′ = ιρ; f (g, h), h; ιψ′ = ιψ; f (g, h) and the commutativity in the

pushout square, it follows mj Tf (g,h)
is an expansion of m Th such that its

reduct to ρ satisfies the assumed theorems.
Therefore m Th|= M.
(ii) ⇐

ρ ._

j,˛	c 
._
ψ
Fig. 5. Hiding
Assume m Th|= M and inclusions are conservative. Then there is mj ∈
Mod(Σ(g,h)) such that mj Tψ′ = m.

Then (see Figure 4), it follows mj Tf (g,h)
Tιψ
= m Th|= ι—1((K ∪ ιρ(Kρ))•)

whence, given aforementioned commutative squares, m |= V th(M∗ (g, h))
2
Let us go back to the Xor example at the beginnig of the section. The following module can be used to define symmetric difference on sets:
Xor * (Bool |-> Set, or |-> union, and |-> intersect, not |-> complement, xor |-> sminus)
Hiding
As previously stated, a hiding operations retracts a part of the visible signature back into the hidden signature. For example, one may define natural numbers on top of integers by first retracting the substraction operation, renaming and then adding a total order on numbers and some properties of the numbers with respect to this order. This translated as a hiding, followed by a renaming and an enriching.
Definition 3.11 Given a module specification M = (ρ, Kρ, ψ, Σ, K) and ι : ψj ‹→ ψ, then the hiding is defined as the module specification
ψj2M = (ρ, Kρ, ψj, Σ, K)
Notice that the inclusion is from the new visible signature to the old one, since we are removing symbols from the latter. Back to the Xor example,
sort Bool2Xor
hides the xor operator.
Theorem 3.12 Given M = (ρ, Kρ, ψ, Σ, K) a module speciﬁcation and ψj2M the module speciﬁcation induced by hiding (where ι : ψj ‹→ ψ), the pair (1ρ, ι): ψj2M→ M is a module speciﬁcation morphism.
Proof.
The conclusions follows since 1ρ is trivially a presentation morphism and, given
ι ′ = ι; ι  (see Figure 5), it follows ι(ι—1(Γ)) ⊆ ι—1(Γ), therefore ι(V th(ψj2M)) ⊆
ψ	ψ	ψ′	ψ
V th(M) (where Γ = (K ∪ ιρ(Kρ))•).	2
The semantics of hiding is as expected, the models of the new module are the

reducts (via inclusions) of the models of the original module. Intuitively, the inter- pretations of the hidden symbols are deleted.
Theorem 3.13 Given M = (ρ, Kρ, ψ, Σ, K) a module speciﬁcation, ψj2M the module speciﬁcation induced by hiding (ι : ψj ‹→ ψ) and m ∈ Mod(M), then
m |= M⇒ m Tι|= ψj2M
If additionally the inclusions are conservative, m |= M iff m Tι|= ψj2M.
Proof.
(i) ⇒
Let mj be an expansion of m. Then mj is also an expansion of m Tι (see Figure 5).
Then, if m = mj Tψ|= V th(M), also m Tι|= V th(M) and since it has an expansion, it follows m Tι|= M.
(ii) ⇐
Assume m Tι|= M. Then m |= V th(M).
If the inclusions are conservative, then there is an expansion mj of m and since m |= V th(M), it follows mj Tρ|= Kρ.
2
Note: It might be worth investigating the effects of relaxing the restrictions on a module specifications, i.e. ’hiding’ symbols and/or sentences from the requirements (ρj ‹→ ρ, Kρ′ ⊂ Kρ).
As long as the visible sentences of the ’relaxed’ module remain unchanged, this operation could be done consistently, however enforcing this condition is not com- putationally feasible.
Enriching
An enriching operation adds new elements to the existing module. Given the com- plexity of a module, this can mean many things. One can add, as notable cases:
new hidden symbols, usually specifying either new behaviours of new constructs, if the symbols are also added to the visible signature, or otherwise more complex behaviours of old constructs;
new visible symbols: if these symbols were already in the hidden signature, this operation can be seen as the reverse of hiding; if not, these new symbols are added in Σ as well, usually specifying new constructs;
new required symbols: if needed to specify the new behaviours mentioned above;
new required sentences for old symbols: these constrain the required constructs; one example may be an enriching from a module requiring a preorder, to a module requiring a partial order.
Definition 3.14 Given a module specification M = (ρ, Kρ, ψ, Σ, K) and another module specification Mj = (ρj, Kρ′ , ψj, Σj, Kj) such that ρ ‹→ ρj, ψ ‹→ ψj and

,˛	zj,

ρ ._
ρ ._

ιρ′






˛ ιψ
r,˛˛	cj 
 ,

.,˛	zj,
ψ	ψ
Fig. 6. Enriching
Σ ‹→ Σj, the enriching of M by Mj is defined as

j	j	j	j	j	j	j	j
M∗ (add ρ , Kρ′ ,ψ , Σ ,K )= (ρ , Kρ ∪ Kρ′ ,ψ , Σ ,K ∪ K )
Theorem 3.15 Given M = (ρ, Kρ, ψ, Σ, K), Mj = (ρj, Kρ′ , ψj, Σj, Kj) two mod- ule speciﬁcations such that M∗ (add ρj, Kρ′ , ψj, Σj, Kj) is an enriching (of M by Mj), the pair (ρ ‹→ ρj,ψ ‹→ ψj) : M → M ∗ (add ρj, Kρ′ , ψj, Σj, Kj) is a module speciﬁcation morphism.
Proof.
Let ι1 : ρ ‹→ ρj, ι2 : ψ ‹→ ψj and ι3 :Σ ‹→ Σj. Then:
ι1 : (ρ, Kρ) → (ρj, Kρ ∪ Kρ′ ) is trivially a presentation morphism (since Kρ ⊆
Kρ ∪ Kρ′ thus Kρ ⊆ (Kρ ∪ Kρ′ )•);
ι (V th(M)) ⊆ V th(Mj) or ι (ι—1((K∪ι (K ))•)) ⊆ ι—1((K∪Kj∪ι ′ (K ∪K ′ ))•):

2	2  ψ	ρ	ρ	ψ′
ρ	ρ	ρ
2

Predictably, the models of the enriched module are expansions of the models of the original module.
Theorem 3.16 Given M = (ρ, Kρ, ψ, Σ, K), Mj = (ρj, Kρ′ , ψj, Σj, Kj) two module speciﬁcations such that M∗ (add ρj, Kρ′ , ψj, Σj, Kj) is an enriching (of M by Mj) and m ∈ Mod(M∗ (add ρj, Kρ′ , ψj, Σj, Kj)), then

j	j	j	j
m |= M∗ (add ρ , Kρ′ ,ψ , Σ ,K )


implies

m Tψ|= M

If additionally the inclusions are conservative,

j	j	j	j
m |= M∗ (add ρ , Kρ′ ,ψ , Σ ,K )


iff

m Tψ|= M

Proof.
(i) ⇒

Let mj be an expansion of m to Σj. Then mj TΣ is an expansion of m Tψ as (mj TΣ) Tψ= (mj Tψ′ ) Tψ= m Tψ.
Assume m |= V th(M∗ (add ρj, Kρ′ , ψj, Σj, Kj)). Then it follows
mj TΣ|= K ∪ ι—1(Kρ)	(7)


therefore

(ii) ⇐

m Tψ|= V th(M)	(8)

If the inclusions are conservative, then m has an expansion mj to Σj. Fur- thermore, mj TΣ is an expansion of m Tψ.
Then we only need to prove that if m Tψ|= V th(M), then m |= V th(M∗ 
(add ρj, Kρ′ , ψj, Σj, Kj)), which can be done analogously to the previous case.
2
Note: These are some particular cases of enriching that might arise in practice:
Basic enriching The enriching morphism is (1ρ,ψ ‹→ ψj) and Kρ′ = ∅; this is the case where new elements are added and specified completely, without adding anything else to the required signature ρ. In the case of the Xor example, a case of basic enriching is
Xor * (add
exports op xnor: Bool Bool -> Bool
rule X:Bool xnor Y:Bool => (X and Y) or (not X and not Y))
Constraining The enriching morphism is (ρ ‹→ ρj, 1ψ); this is the case where new elements are required to define the module, with no effect on the output. One further particular case is the one where the requirement inclusion is an identity,
i.e. only new sentences are required (therefore the term for this kind of enriching); In the case of the Xor example, a case of constraining is requiring an additional property of the boolean operations
Xor * (add requires eq not (X:Var or Y:Var) = not X and not Y)
Completeness preserving enriching New elements are added both to the required signature and the exported signature; this can be seen as a single inclusion (of intersections), wherefrom the new interface and requirements can be deduced (as pushouts).
Aggregation
Aggregation means combining two modules into one. The signatures and sentences of the resulting module are unions of the respective signatures and sentences of the initial modules.
Definition 3.17 Given two module specifications M = (ρ, Kρ, ψ, Σ, K) and Mj = (ρj, Kρ′ , ψj, Σj, Kj), their aggregation is defined as
M + Mj = (ρ ∪ ρj, Kρ ∪ Kρ′ ,ψ ∪ ψj, Σ ∪ Σj,K ∪ Kj)

ρ,˛ ιρ zρ ,∪ ρj
ιρ′
ρzj

˛¸	,r	r ¸
˛  ι∪ρ	ι
ι1

c,¸˛  ιΣ
˛.
ι2
,	¸˛ ι∪ψ
t¸  ι
zΣ,˛∪‚Σ ,r r˛Σ ,

,	ι4

¸
ψ	zψ,∪ ψ ,r	rψ
ιψ	ιψ′
Fig. 7. Aggregation
This definition is correct since by definition of coproducts there is a unique inclusion ι∪ρ : ρ ∪ ρj ‹→ Σ ∪ Σj and a unique inclusion ι∪ψ : ψ ∪ ψj ‹→ Σ ∪ Σj such that:
ιρ; ι∪ρ = ι1; ιΣ
ιψ; ι∪ψ = ι2; ιΣ
ιρ′ ; ι∪ρ = ι3; ιΣ′
ιψ′ ; ι∪ψ = ι4; ιΣ′
(see also Figure 7) . 
Furthermore, this operation is a simple module morphism, where the signature morphisms are inclusions, also translating visible theorems to visible theorems.
Theorem 3.18 Given two module speciﬁcations M = (ρ, Kρ, ψ, Σ, K) and Mj = (ρj, Kρ′ , ψj, Σj, Kj) and their aggregation M + Mj, the pairs (ιρ, ιψ) and (ιρ′ , ιψ′ ) are module speciﬁcation morphisms.
Proof.
For (ιρ, ιψ):
ιρ is trivially a presentation morphism from (ρ, Kρ) to (ρ ∪ ρj, Kρ ∪ Kρ′ ) (since
Kρ ∪ Kρ′ |= Kρ)
ιψ(V th(M)) ⊆ V th(M + Mj) or
ιψ(ι—1((K ∪ ι1(Kρ))•)) ⊆ ι—1((K ∪ Kj ∪ ι∪ρ(Kρ ∪ Kρ′ ))•) as follows :
2	∪ψ

ιψ(ι—1((K ∪ ι1(Kρ))•))
= ι—1(ιΣ((K ∪ ι1(Kρ))•))(given the commutative diagram)
= ι—1((ιΣ(K ∪ ι1(Kρ)))•)
= ι—1((ιΣ(K) ∪ ιΣ(ι1(Kρ)))•)(since Sen preserves inclusions)
= ι—1((ιΣ(K) ∪ ι∪ρ(ιρ(Kρ)))•)

⊆ ι—1((K ∪ Kj
∪ ι∪ρ(Kρ ∪ Kρ′ )) )

The proof for (ιρ′ , ιψ′ ) is analogous.	2
Going further to the semantics, it is easy to retrieve models of the initial modules, as reducts of a model of an aggregated module. However, we need the model functor

to preserve coproducts in order to be able to define models of the aggregated module, starting from models of the inital module.

Theorem 3.19 Given two module speciﬁcations M = (ρ, Kρ, ψ, Σ, K) and Mj = (ρj, Kρ′ , ψj, Σj, Kj), their aggregation M + Mj, and m ∈ Mod(M + Mj), then

m |= M + M iff m Tψ|= M and m Tψ′ |= M

Proof.
⇒ Assume m |= M + Mj
Then m Tψ|= M as follows:
m |= M + Mj implies m |= V th(M + Mj) and given Theorem 3.18 this implies
m Tψ|= V th(M) thus m Tψ|= M.
Furthermore, let mj be an expansion of m to Σ ∪ Σj. Then

(mj Tι ) Tι = mj Tι ;ι
= mj Tι ;ι
= (mj Tι	) Tι
= m Tψ


thus mj Tι
is an expansion of m Tψ to Σ.

Analogously m Tψ′ |= Mj.
Assume m Tψ|= M and m Tψ′ |= Mj.
Let mj be an expansion of m Tψ to Σ and mjj, an expansion of m Tψ′ to Σj, i.e.
mj Tι = m Tψ and mjj Tι = m Tψ′ . Given the hypothesis, we have that
2	4

mj |= K ∪ ι1(Kρ)


and

m  |= K ∪ ι3(Kρ′ )	(9)

From this we can find an expansion of m using the model amalgamation prop- erty.
Let ι∩ψ : ψ ∩ ψj ‹→ ψ, ι∩ψ′ : ψ ∩ ψj ‹→ ψj, ι∩Σ :Σ ∩ Σj ‹→ Σ, ι∩Σ′ :Σ ∩ Σj ‹→ Σj as in Figure 8.
Since the intersections are coproducts in the category of inclusions, given the pair (ι∩ψ; ι2, ι∩ψ′ ; ι4), it follows that there is a unique inclusion ι (see Figure 8) such that ι; ι∩Σ = ι∩ψ; ι2 and ι; ι∩Σ′ = ι∩ψ′ ; ι4.

ι2	zΣ,





ψ ∩
c¸ j ˛
 ,

ι	zΣ,∩ ,,j


ι∩Σ




ι∩Σ′
c¸ j
zΣ,∪ Σ,


ιΣ′

cj¸,,	cj¸,,

ψ ,˛
ι4	zΣ,




Then:
Fig. 8. Finding an expansion of m



mj Tι	;ι = (mj Tι ) Tι
= (m Tψ) Tι∩ψ
= m Tιψ ;ι∩ψ
= m Tιψ′ ;ι∩ψ′
= (m Tj ) Tι

ψ	∩ψ′
= (mjj Tι ) Tι
= mjj Tι	;ι

and since (Σ ∪ Σj, ιΣ, ιΣ′ ) is a pushout in the category of inclusions (of pair (ι∩ψ; ι2, ι∩ψ′ ; ι4)), it follows using the model amalgamation property that there is a unique model m0 ∈ Mod(Σ ∪ Σj) such that m0 TΣ= mj and m0 TΣ′ = mjj.
Then,






and analogously (m0 Tι
(m0 Tι∪ψ ) Tιψ = (m0 TιΣ ) Tι2
= (m0 TΣ) Tι2
= mj Tι
= m Tιψ
) Tι ′ = m Tι ′ . But since ψ∪ψj is a coproduct, and Mod

∪ψ	ψ	ψ
preserves coproducts (i.e. for any models m1 ∈ Mod(ψ), m2 ∈ Mod(ψj), there is a unique model m3 ∈ Mod(ψ ∪ ψj) such that m3 Tψ= m1 and m3 Tψ′ = m2) it follows that m0 Tι∪ψ = m, thus m0 is an expansion of m.

Furthermore, from m0 TιΣ
it follows, on one hand,
= mj |= K ∪ι1(Kρ) and m0 Tι
′ = mjj |= Kj ∪ι3(Kρ′ ),


and on the other and analogously
m0 |= K ∪ Kj	(10)

m0 |= ιΣ(ι1(Kρ)) = ι∪ρ(ιρ(Kρ))	(11)

m0 |= ι∪ρ(ιρ′ (Kρ′ ))	(12)

thus thus

m0 |= ι∪ρ(Kρ∪Kρ′ )	(13)

m0 |= (K ∪ K ∪ ι∪ρ(Kρ ∪ Kρ′ ))	(14)

and since m0 Tι∪Σ = m, it follows
—1	j	•	j
m |= ι∪Σ((K ∪ K ∪ ι∪ρ(Kρ ∪ Kρ′ )) )= V th(M + M )	(15)
thus m |= M + Mj.
2
Conclusions and Future Work
We have defined abstract modules and module operations intended to be used for the K framework; apart from the constructs and behaviours it defines - as a signa- ture and set of sentences, an abstract module specifies which of those constructs it exports and what it requires other modules to export. Module operations defined and analyzed here are: renaming, hiding, enriching and aggregation.
The K institution is assumed to be an inclusive institution with strong inclusions and pushouts which preserve inclusions; additionally, the model functor is required to preserves pushouts and coproducts. Formally defining the K institution, as well as proving that these properties hold for the instititution, are the subject of future work.
Other directions of future work are analyzing parametrization and some prop- erties of the module system, as well as implementing the module system in the K tool.

References
Ro¸su, Grigore, and Traian Florin S¸erb˘anu¸ta˘ , An Overview of the K Semantic Framework, Journal of Logic and Algebraic Programming 79 (2010), 397–434
Diaconescu, Razvan, Joseph Goguen, and Petros Stefaneas, Logical support for modularisation, Logical Environments (1993), Cambridge University Press, 83–130
Goguen, Joseph and Grigore Rosu, Composing Hidden Information Modules over Inclusive Institutions, From Object-Orientation to Formal Methods, LLNCS 2635 (2004), Springer Berlin / Heidelberg, 96– 123
Rosu, Grigore, The Institution of order-sorted equational logic, Bulletin of EATCS, 53 (1994)
Borzyszkowski, Tomasz, Higher-Order Logic and Theorem Proving for Structured Specifications, in Algebraic Development Techniques, (WADT 99), LNCS (1999), Springer, 401–418
Goguen, Joseph A. and Rod M. Burstall, Institutions: abstract model theory for specification and programming, J. ACM. 39 (1992), 95–146.
Ro¸su, Grigore, Abstract semantics for module composition, Technical Report CSE2000–0653, University of California at San Diego, May 2000. Written August 1997.
Goguen, Joseph, and Will Tracz, An Implementation-Oriented Semantics for Module Composition, Foundations of component-based systems (2000), Leavens, Gary T. and Sitaraman, Murali, 231–263


Hills, Mark, and Grigore Ro¸su, Towards a Module System for K, Recent Trends in Algebraic Development Techniques (WADT’08), LNCS 5486 (2008), 187–205
Borovansky, Peter, Claude Kirchner, Helene Kirchner, Pierre-etienne Moreau, and Christophe Ringeissen, An Overview of ELAN, ENTCS 15 (1998), 55–70
Bergstra, Jan A., Jan Heering, and Paul Klint, Module Algebra, J. ACM 37 (1990), 335–372
Dur´an, Francisco, and Jos´e Meseguer, Maude’s module algebra, Sci. Comput. Program. 66 (2007), 125–153
Astesiano, Egidio, Michel Bidoit, H´el`ene Kirchner, Bernd Krieg-Bru¨ckner, Peter D. Mosses, Donald Sannella, and Andrzej Tarlecki, CASL: the Common Algebraic Specification Language, Theor. Comput.
Sci. 286 (2002), 153–196
Mac Lane, Saunders, ”Categories for the Working Mathematician”, Springer, 1971
Diaconescu, Razvan, ”Institution-independent Model Theory”, Birkh¨auser, 2008
