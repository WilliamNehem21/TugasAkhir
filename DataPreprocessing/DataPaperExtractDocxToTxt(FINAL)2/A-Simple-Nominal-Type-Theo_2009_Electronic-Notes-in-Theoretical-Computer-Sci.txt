

Electronic Notes in Theoretical Computer Science 228 (2009) 37–52
www.elsevier.com/locate/entcs
A Simple Nominal Type Theory
James Cheney1
University of Edinburgh 11 Crichton Street
Edinburgh EH8 9LE, United Kingdom

Abstract
Nominal logic is an extension of first-order logic with features useful for reasoning about abstract syntax with bound names. For computational applications such as programming and formal reasoning, it is desirable to develop constructive type theories for nominal logic that extend standard type theories for propositional, first- or higher-order logic. This has proven difficult, largely because of complex interactions between nominal logic’s name-abstraction operation and ordinary functional abstraction. This difficulty already arises in the case of propositional logic and simple type theory. In this paper we show how this difficulty can be overcome, and present a simple nominal type theory that enjoys properties such as type soundness and strong normalization, and that can be soundly interpreted using existing nominal set models of nominal logic. We also sketch how recursion combinators for languages with binding structure can be provided. This is a first step towards understanding the constructive content of nominal logic and incorporating it into existing constructive logics and type theories.
Keywords: nominal terms, type systems


Introduction
Nominal logic [14] is a variant of first-order logic that axiomatizes name-binding and alpha-equivalence using permutative renamings, or swappings. So far, nominal logic has been studied primarily using classical model theory [3,14] or proof the- ory [2,6] to formalize explicit reasoning about equational and freshness properties. While this analysis lends itself to implementations within theorem proving systems based on classical logic [25], nominal logic has resisted incorporation into construc- tive systems based on typed lambda-calculi. This is unfortunate, because nominal logic seems promising as a foundation for inductive reasoning about name-binding in a variety of settings, and constructive logics have many advantages due to the propositions-as-types and proofs-as programs principles: a constructive proof of a formula can be viewed as a program for performing a computation of the corre- sponding type.  In particular, we would like a type theory for nominal logic to

1 Email: jcheney@inf.ed.ac.uk

1571-0661/© 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.12.115

internalize the freshness reasoning about name-abstractions that currently needs to be performed explicitly to justify recursion and induction for nominal abstract syntax (for example, in [9,15,23]).
Although proof theories for intuitionistic nominal logic has been considered al- ready in work by Gabbay and Cheney [6,2,5], those systems consider only provabil- ity, not proof terms. The proof trees available in such systems could themselves be viewed as proof terms, but doing so does not immediately yield a well-behaved type theory with nice properties. Moreover, both systems involve significant amounts of explicit reasoning about equality and freshness.
Nominal type theory has also been investigated by Scho¨pp and Stark [19,22], who have developed a family of type theories based on categorical models of nomi- nal logic. Their approach to nominal dependent type theory is very expressive, but motivated primarily by semantics. Computationally important syntactic properties such as strong normalization and the decidability of typechecking have not been studied, and seem difficult to obtain due to the complexity of the system. Thus, the problem of identifying type theoretic presentations of nominal logic with com- putational properties that make them suitable for use in automated reasoning and programming remains open.
In this paper, we consider a simple case of this problem. Specifically, we in- troduce an extension of the simply-typed lambda calculus that incorporates names and name-abstraction types ⟨α⟩A with introduction form ⟨a:α⟩M (abstraction) and elimination form M @ a (concretion). Moreover, our approach can also be extended with recursion combinators for object languages in a syntactically and semantically sound way.
A key difficulty encountered in this approach is the interaction of name-ab- straction with ordinary functional (λ-) abstraction. Specifically, at a semantic level, the name-concretion operation requires that the name passed as an argument to an abstraction is not already free in the body of the abstraction. Thus, the term M1 = (⟨a:α⟩(a, b))@b is ill-defined — it applies the partial function M2 = ⟨a:α⟩(a, b) to a value not in its domain. Similarly, the term M3 = ((λx:α.⟨a:α⟩(a, x)) b)@b is ill- defined, since it β-reduces to M1. And more subtly, the term M4 = (⟨a:α⟩λx.x@a) is also ill-defined, since (M4@b) (⟨a:α⟩(a, b)) also reduces to M1.
Previous systems have dealt with this by requiring explicit reasoning about swapping, freshness and equality (cf. [2,6,9,15,19,22,23,25]). However, as pointed out by a number of authors, the name-abstraction type constructor ⟨α⟩A can be interpreted in two isomorphic ways: as the quotient of the set of pairs, with respect to an α-equivalence relation (α × A)/≡α , or as a (partial) function space, α −◦ A, consisting of functions that may only be applied to a “fresh” name, similar to the “magic wand” connective/type constructor in the logic of bunched implications (BI) and its type theories [11]. Scho¨pp and Stark’s type theory takes the approach that name-abstractions have the introduction and elimination forms of both quotiented- pair and partial-function presentations, using BI-style bunched contexts. (Their system also considers dependent product and sum types, which add further compli- cations.) In this paper, we consider the consequences of designing a “simple” nom-

inal type theory with name-abstractions corresponding only to the partial-function presentation, using a simpler form of bunched contexts that is specialized to this situation.
The introduction form of the name-abstraction type is then a name-abstraction term ⟨a:α⟩M , where a is bound in M (in the same sense as x is bound in M in a λ-abstraction λx:A.M ). The elimination form is the “concretion” operation M @ a, familiar from some versions of FreshML. This leads naturally to typing rules:

Γ#a:α ▶ M : A	(a /∈ Γ) Γ ▶ ⟨a:α⟩M : ⟨α⟩A
Γ ▶ M : ⟨α⟩A	Γ ▶ a : α (∗) Γ ▶ M @ a : B

However, the second typing rule (∗) fails to express the freshness constraint on concretions; it permits all of the ill-defined terms M1–M4 above.
In order to obtain a type theory that defines only expressions that make sense in the universe of nominal sets, the typing rule for concretions M @ a must ensure that a cannot appear in M , no matter how M is instantiated. The basic idea is to use a context with additional structure expressing freshness information, as previously explored in [2] for full nominal logic and in [22,19] in more generality. We consider contexts Γ that may have ordinary variable bindings Γ, x:A, where A is an arbitrary type, as well as “fresh name bindings” Γ#a:α, where α is a base type of names. When we typecheck a concretion M @ a, we must be able to use the information in the context to prove that a is fresh for all of the symbols present in M . This leads to a rule

Γ ▶ a : α \ Γ'	Γ' ▶ M : ⟨α⟩A (
Γ ▶ M @ a : B
∗∗)

This rule uses an auxiliary judgment Γ ▶ a : α \ Γ' which, intuitively, removes a:α from Γ to produce Γ', and also removes all variables that could be substituted with something containing a. The abstraction subterm M is typechecked with respect to this diminished context Γ'. This ensures that the concretion is well-defined.
The main contributions of this paper are as follows. We introduce (Section 2) a simple nominal type theory (here abbreviated SNTT) based on the (**) rule, and prove type soundness (Section 2.1) and strong normalization (Section 2.2) for SNTT. We also (Section 2.3) relate SNTT to nominal logic by showing how to interpret it using nominal sets. In Section 3 we show how SNTT can be extended with conditionals, name-equality, and primitive recursion combinators which can be used to define functions such as capture-avoiding substitution. We conclude in Sections 4 and 5 by relating SNTT to other systems and discussing future directions.

Simple nominal type theory
The basic syntactic classes of SNTT include countable, disjoint sets of variables V = {x, y, z, . . .} and names (or atoms) A = {a, b, c, . . .}; atomic data-type symbols δ, δ',... and name-type symbols α, α',.. .; and constant symbols c, d,.   Additional
syntactic classes include types A, B, terms M, N , contexts Γ, and substitutions θ, whose abstract syntax is described by the following grammar rules:

FVN (()) = FVN (c)= ∅	FVN (z) = {z}  (z ∈ V ∪ A)
FVN (λx.M) = FVN (M) − {x}  FVN (πi(M)) = FVN (M @ a) = FVN (M)
FVN (⟨a:α⟩M) = FVN (M) − {a}	FVN (M, N)= FVN (M N) = FVN (M) ∪ FVN (N)
FV (M) = FVN (M) ∩ V	FN (M) = FVN (M) ∩ A
FVN (·)= ∅	FVN (θ, M/x)= FVN (θ) ∪ FVN (M)	FVN (θ, b/a)= FVN (θ) ∪ {b}

Fig. 1. Free-variables and free-names functions



x[θ] = θ(x)	a[θ] = a
c[θ] = c	()[θ] = ()
πi(M)[θ] = πi(M[θ])	(M, M ')[θ] = (M[θ],M '[θ])
(M M ')[θ] = M[θ] M '[θ]	(λy:A.M)[θ] = λy:A.M[θ, y/y] (y /∈ FV (θ))
(M @ a)[θ] = M[θ − a] @ θ(a)  (⟨a:α⟩M)[θ] = ⟨a:α⟩M[θ, a/a] (a /∈ FN (θ)) Fig. 2. Capture-avoiding substitution/renaming

A, B ::= 1 | A × B | A → B | ⟨α⟩A | α | δ
M, N ::= c | x | () | (M, N ) | πi(M ) | λx:A.M | M N | a | ⟨a:α⟩M | M @ a
Γ ::= ·| Γ, x:A | Γ#a:α	θ ::= ·| θ, M/x | θ, b/a
Many of the types (units, pairing and function types) and their associated introduc- tion and elimination forms are standard. Names a are always of some name type α; the abstraction type ⟨α⟩A is associated with introduction form ⟨a:α⟩M , called name-abstraction, and elimination form M @ a, called name-concretion.
We define the sets of free names FN (M ) and free variables FV (M ) of a term in Figure 1, treating a as binding in the abstraction operation ⟨a:α⟩M and x as binding in λx:A.M . We also extend FV and FN to substitutions. Order matters in contexts. We consider terms equivalent modulo consistent renaming of bound names and variables; also, by convention, we write contexts as x:A or a:α instead of
·, x:A or ·#a:α, respectively. We write M [θ] for the result of applying a substitution θ to M ; this is defined in Figure 2. We give the full definitions to eliminate any risk of confusion: in particular, observe that renamings and FN are syntactic operations only; they should not be confused with the concepts of swapping and support in nominal sets, discussed in Section 2.3.
We assume a fixed signature Σ = {c : A, . . .} assigning unique types to the constants of the language. The term well-formedness rules for SNTT are shown in Figure 4. The restriction judgment Γ ▶ a : α \ Γ', defined in Figure 3, intuitively means that a:α appears in Γ and Γ' is the result of removing all bindings from Γ whose values may depend on a. Note the differences between the second and third rules. We write a:α ∈ Γ or x:A ∈ Γ to say that a binding for a or x with the given type is present in Γ and write a ∈/ Γ or x /∈ Γ to say that no such binding for a or x is present respectively. We assume all signatures and contexts are valid, that is, contain no duplicate variable or name bindings.
The rewriting rules for reducing and expanding the terms of SNTT include the



Γ#a:α ▶ a : α \ Γ
(a /= b) Γ ▶ a : α \ Γ' Γ#b:β ▶ a : α \ Γ'#b:β
Γ ▶ a : α \ Γ' Γ, x:A ▶ a : α \ Γ'


Fig. 3. Context restriction judgment


c : A ∈ Σ con
Γ ▶ c : A


Γ ▶ () : 1
Γ ▶ M1 : A1  Γ ▶ M2 : A2
unitI	Γ ▶ (M1, M2): A1 × A2
Γ ▶ M : A1 × A2
∧I	Γ ▶ πi(M): Ai  ∧E

x : A ∈ Γ var  Γ, x:A ▶ M : B  (x /∈ Γ) ⇒I  Γ ▶ M : A → B  Γ ▶ N : A ⇒E

Γ ▶ x : A
 a:α ∈ Γ name
Γ ▶ a : α
Γ ▶ λx:A.M : A → B
Γ#a:α ▶ M : A  (a /∈ Γ)
Γ ▶ ⟨a:α⟩M : ⟨α⟩A	absI
Γ ▶ M N : B
Γ ▶ a : α \ Γ' Γ' ▶ M : ⟨α⟩A
Γ ▶ M @ a : A	absE


Fig. 4. Simple nominal type theory: well-formedness

following rules, most of which are standard:
πi(M1, M2) dβ Mi	M : A1 × A2 dη (π1(M), π2(M))
(λx.M) N dβ M[N/x]	M : A → B dη λx:A.M x	(x /∈ FV (M)) (⟨a:α⟩M) @ b dβ M[b/a]		M : ⟨α⟩B dη ⟨a:α⟩M @ a	(a /∈ FN (M))
M : 1 dη ()

We write −→β, −→η for the rewriting relations generated by dβ, dη and write
M ←→∗  N to indicate that M and N are βη-convertible to a common form. We
write M ⇓β N to indicate that M converges to normal form N under β-reduction and M ⇓β for ∃N.M ⇓β N .
Besides arbitrary signatures involving higher-order constants, we also consider nominal signatures (following [15,24]). These are signatures in which all constants c have types A → δ, where A is first-order (i.e., does not use →) and δ is a data type. We also define a sublanguage of the terms of SNTT called ground nominal terms, which are essentially the same as the ground nominal terms of [15,24]:
M0, N0 ::= () | c M0 | (M0, N0) | ⟨a:α⟩M0 | a
SNTT includes all of the rules of simply-typed lambda calculus with unit and product types (which we call simple type theory or STT), so any well-typed pure λ- term can be typechecked in SNTT with the same type. Also any well-typed ground nominal term can be typechecked in SNTT with respect to its nominal signature and a context consisting only of names. We will later show (Corollary 2.13) that SNTT is a conservative extension of both systems.
Examples. Before proceeding to the formal results, we show some illustrative examples (Figure 5) of well- and ill-formed terms involving both name-abstraction and λ-abstraction. Example (a) illustrates a term whose type corresponds to a “weakening” law A → ⟨α⟩A for name-abstraction types. Example (b) shows how to typecheck the term λx:⟨α⟩A.⟨a:α⟩x@a, which is the fully η-expanded identity function at type ⟨α⟩A. Examples (c) and (d) provide partial derivations of non- typeable terms; in (d), there is no name that can be filled in for ?? that will make the term typecheck. Examples (e)–(j) shows additional properties of the name- abstraction type, omitting derivations. Example (e) gives a term that proves a “name-exchange” law; this is one direction of an isomorphism of types ⟨α⟩⟨α'⟩A


 


(a)


x:A#a:α ▶ x : A x:A ▶ ⟨a:α⟩x : ⟨α⟩A
· ▶ λx:A.⟨a:α⟩x : A → ⟨α⟩A

(b)
x:⟨α⟩A#a:α ▶ a : α \ x:⟨α⟩A  x:⟨α⟩A ▶ x : ⟨α⟩A


x:⟨α⟩A#a:α ▶ x@a : A x:⟨α⟩A ▶ ⟨a:α⟩x@a : ⟨α⟩A
· ▶ λx:⟨α⟩A.⟨a:α⟩x@a : ⟨α⟩A → ⟨α⟩A




a:α ▶ a : α \ · 


a:α, x:⟨α⟩A ▶ a : α \ · 
stuck
· ▶ x : ⟨α⟩A

stuck since no name a:α is known

(c)


a:α, x:⟨α⟩A ▶ x @ a : A
a:α ▶ λx:⟨α⟩A.x @ a : ⟨α⟩A → A
▶ ⟨a:α⟩λx:⟨α⟩A.x @ a : ⟨α⟩(⟨α⟩A → A)
(d)
x:⟨α⟩A ▶ x @?? : A

· ▶ λx.x @?? : ⟨α⟩A → A

(e) ▶ λx : ⟨α⟩⟨α'⟩A. ⟨a : α'⟩⟨b : α⟩((x @ b) @ a): ⟨α⟩⟨α'⟩A → ⟨α'⟩⟨α⟩A
(f) /▶ λx : ⟨α⟩⟨α⟩A. ⟨a : α⟩(x @ a) @ a : ⟨α⟩⟨α⟩A → ⟨α⟩A
(g) ▶ λx : ⟨α⟩(A → B). λy : ⟨α⟩A. ⟨a : α⟩(x @ a) (y @ a): ⟨α⟩(A → B) → ⟨α⟩A → ⟨α⟩B
(h) /▶ λx : ⟨α⟩A → ⟨α⟩B. ⟨a : α⟩λy.(x ??) @ a : (⟨α⟩A → ⟨α⟩B) → ⟨α⟩(A → B)
▶ λx : ⟨α⟩(A × B). (⟨a : α⟩π1(x @ a), ⟨a⟩π2(x @ a)) : ⟨α⟩(A × B) → ⟨α⟩A × ⟨α⟩B
▶ λx : ⟨α⟩A × ⟨α⟩B. ⟨a : α⟩(π1(x) @ a, π2(x) @ a): (⟨α⟩A × ⟨α⟩B) → ⟨α⟩(A × B) Fig. 5. Example derivations and non-derivations



Γ ▶ · : ·
Γ ▶ M : A  Γ ▶ θ : Γ'

Γ ▶ θ, M/x : Γ', x:A
Γ ▶ b : α \ Γ0 Γ0 ▶ θ : Γ' Γ ▶ θ, b/a : Γ'#a:α


Fig. 6. Well-formed substitutions

and ⟨α'⟩⟨α⟩A. Example (f) shows the failure of a “contraction” law for name- abstraction; (g) shows that we can push name-abstraction inside function types; (h) shows that the converse fails in SNTT; and (i) and (j) show that name-abstractions can be pushed into and pulled out of pairs.

Formal properties
To simplify the following discussion, we introduce a “well-formedness” judgment for substitutions in Figure 6. For example, note that we may not re-use a name in a substitution once it has been used to replace some other name; that is, θ = a/b, a/c and θ = (a, b)/x, b/c are ill-formed. This is because the third rule requires us to typecheck θ, b/a by typechecking θ after removing b and all variables that may depend on b from the context. Moreover, substitutions can only perform injective renamings.
We write idΓ for the identity substitution on Γ. We abbreviate M [idΓ, N/x] as M [N/x] and M [idΓ, b/a] as M [b/a], provided Γ is clear from context. We say that a context Γ is contained in another context Γ' (written Γ ≤ Γ') if Γ' ▶ idΓ : Γ. Two contexts are equivalent (Γ ≡ Γ') if Γ ≤ Γ' ≤ Γ. For example, y:B#a:α, x:A ≤ x:A, y:B#a:α, z:C, while x:A, y:B ≡ y:B, x:A.
Weakening can be established using relatively straightforward techniques. The proof is not completely trivial because we need to prove weakening for the context

restriction judgment as well, which requires proving several auxiliary properties which we omit here.
Lemma 2.1 (Weakening) If Γ ≤ Γ' and Γ ▶ M : A then Γ' ▶ M : A.
Next, we can prove a general substitution lemma:
Lemma 2.2 (General substitution) If Γ' ▶ θ : Γ and Γ ▶ M : A then Γ' ▶
M [θ] : A.
More traditional substitution and renaming properties follow immediately by suitable choices of θ.
Lemma 2.3 (Substitution) Suppose x does not appear in Γ. If Γ ▶ N : B and
Γ, x:B ▶ M : A then Γ ▶ M [N/x] : A.
Lemma 2.4 (Renaming) Suppose b does not appear in Γ. If Γ#a:α ▶ M : A
then Γ#b:α ▶ M [b/a] : A.
We will also need a few properties of the context restriction judgment that are easy to prove by induction:
Lemma 2.5 (Restriction) If Γ ▶ a : α \ Γ' then a /∈ Γ' and Γ'#a:α ≤ Γ.
We conclude by showing “local soundness” and “local completeness” properties stating that name-abstractions can be eliminated and then reintroduces without gaining or losing information (and vice versa).
Lemma 2.6 (Local soundness) If Γ ▶ M : A and M dβ N then Γ ▶ N : A.
Proof. Proof is by cases on the rewriting step and inversion on derivations. For the case of name-abstraction, the reduction step is straightforward using renaming and weakening:



Γ ▶ b : α \ Γ'
Γ'#a:α ▶ M : A
Γ' ▶ ⟨a:α⟩M : ⟨α⟩A absI
Γ'#a:α ▶ M : A
=⇒ Γ'#b:α ▶ M[b/a]: A R

Γ ▶ (⟨a:α⟩M) @ b : A	absE	Γ ▶ M[b/a]: A	W
since by Lemma 2.5, b:α /∈ Γ' and Γ'#b:α ≤ Γ.	 
Lemma 2.7 (Local completeness) If M dη N then Γ ▶ M : A if and only if
Γ ▶ N : A.
Proof. Again, the only new case is for name-abstraction. If we have M : ⟨α⟩A dη
⟨a:α⟩M @ a for some a /∈ FN (M ), then



Γ ▶ M : ⟨α⟩A ⇐⇒
Γ#a:α ▶ a : α \ Γ Γ ▶ M : ⟨α⟩A
 Γ#a:α ▶ M @ a : A 	absE
Γ ▶ ⟨a:α⟩M @ a : ⟨α⟩A absI


Theorem 2.8 (Subject reduction) If ▶ M : A and M −→β N or M −→η N
then ▶ N : A.

We have formalized the development to this point using the Isabelle/HOL- Nominal system [25].
Strong normalization and canonicalization
In this section we wish to show that SNTT enjoys the properties of strong normaliza- tion and canonicalization (existence of β-normal η-long canonical forms). Both the Church-Rosser and Strong Normalization theorems can be proved using essentially the same arguments as for the λ-calculus.
Theorem 2.9 (Church-Rosser) If M −→β M1 and M −→β M2 then there exists
N such that M1 −→∗ N and M2 −→∗ N.
β	β
Theorem 2.10 (Strong Normalization) If M : A then M ⇓β V for a unique
V : A.
Strong normalization has several useful consequences: we can obtain unique β- normal, η-long canonical forms by first η-expanding each subterm once according to its type and then β-normalizing. This gives a decision procedure for βη-equivalence.

Corollary 2.11 (Canonicalization) If M : A then M has a unique βη-canonical form.
Corollary 2.12 (Decidability) Both β- and βη-equivalence are decidable.
Moreover, SNTT is a conservative extension of both ordinary simple type theory (STT) and the language of ground nominal terms.
Corollary 2.13 (Conservativity) A judgment ▶ M : A of STT is derivable if and only if ▶ M : A is derivable in SNTT. Moreover, given a nominal signature Σ and ground nominal term M0, M0 is a well-formed term of type δ with names a1:α1,..., an:αn if and only if a1:α1# ··· #an:αn ▶ M0 : δ is derivable in SNTT.
Nominal set semantics
Although the subject reduction and strong normalization theorems imply that SNTT is a consistent equational theory, they do not explain how SNTT relates to nominal abstract syntax. In this section we show how the judgments and equa- tions of SNTT can be interpreted using nominal sets [14]. This means that SNTT is sound for reasoning about names, name-abstractions, and functions in ordinary nominal logic. We leave the issues of expressiveness and completeness (for example, with respect to a suitable generalization of cartesian closed categories) for future work.
In this section, we consider the special case where there is a single name-type α, which shall correspond to the set A of all names. Generalizing to multiple name- types is straightforward but notationally burdensome.
We recapitulate some of the basic definitions concerning permutations, group actions and nominal sets needed for the semantics (introduced in prior work by

Gabbay and Pitts [7,14,15]). We write Pfin(A) for the set of all finite sets of names and G = FSym(A) for the group of all (ﬁnite) permutations π on A; that is, invertible functions such that π(a) = a for all but finitely many a ∈ A. We often write π · a for π(a) and π · S for {π · x | x ∈ S} if S ∈ Pfin(A). A G-set is a structure X = (|X|, ·X) consisting of a set X equipped with a permutation action
·X : G × |X|→ |X|, satisfying id · x = x and π · π' · x = (π ◦π') · x. We write Sax to indicate that S ∈ Pfin(A) supports x ∈ |X|; that is, that ∀a, b ∈ A−S. (a b)·X x = x. A nominal set is a G-set in which every element has a finite support (there is then necessarily a unique least finite support). If an element x of a nominal set has empty support, it is called equivariant, and clearly π · x = x for any π ∈ G.
It has been established in previous work [7] that nominal sets form a category 2 Nom, which includes a terminal nominal set 1Nom, standard constructions in- cluding Cartesian products X ×Nom Y and function spaces X →Nom Y , and a name-abstraction construction ⟨A⟩X. We briefly review these constructions.
Definition 2.14 The terminal nominal set 1Nom is defined by taking |1Nom| =
{ }. The swapping action is defined by π ·  = .
Definition 2.15 The cartesian product of two nominal sets X, Y is defined by taking |X ×Nom Y | = |X|× |Y | and defining the action by the rule π · (x, y) = (π · x, π · y).
Definition 2.16 The nominal set X →Nom Y of (finitely-supported) functions from X to Y is defined by taking |X →Nom Y | = {f : |X|→ |Y || ∃S ∈ Pfin(A). S a f} where the swapping action is defined as (π · f )(x) = π · (f (π−1 · x)).
Definition 2.17 The set of names A is a nominal set with π ·A a = π(a).
Definition 2.18 Given nominal set X, the set of abstractions of X is called ⟨⟨A⟩⟩X and defined by taking |⟨⟨A⟩⟩X| = (A × |X|)/≡α , where ≡α is the least equivalence relation satisfying
(a /∈ supp(y) ∧ x = (a b) ·X y) ⇒ (a, x) ≡α (b, y) .

The swapping action is defined as (b b') · [(a, x)]α = [((b b') · a, (b b') · x)]α. We often abbreviate [(a, x)]α as ⟨⟨a⟩⟩x. Moreover, if y ∈ ⟨⟨A⟩⟩X and a /∈ supp(y) then we define y @ a as y(a), viewing y as a partial function.
Semantic name-abstractions satisfy analogues of the beta-reduction and eta- expansion laws for SNTT name-abstractions. We need the following key properties of name-abstraction and concretion:
Proposition 2.19 (i) If ⟨⟨a⟩⟩x ∈ ⟨⟨A⟩⟩X and b /∈ supp(⟨⟨a⟩⟩x) then (⟨⟨a⟩⟩x) @ b = (a b) · x and supp(⟨⟨a⟩⟩x) = supp(x) − {a}.
(ii) If y ∈ ⟨⟨A⟩⟩X and a /∈ supp(y) then y = ⟨⟨a⟩⟩(y @ a) and supp(y @ a) ⊆
supp(y) ∪ {a}.

2 Nom is, as noted elsewhere [7,22,19], isomorphic to a well-known category called the Schanuel topos.




T [[1]] = 1Nom T [[δ]] = T0[[δ]] T [[α]] = A
T [[A × B]] = T [[A]] ×Nom T [[B]]
T [[A → B]] = T [[A]] →Nom T [[B]]
T [[⟨α⟩A]] = ⟨⟨A⟩⟩(T [[A]])
E [[Γ ▶ x : A]]γ = γ(x)	E [[Γ ▶ c : A]]γ = E0[[c : A]]
E [[Γ ▶ a : α]]γ = γ(a)	E [[Γ ▶ () : 1]]γ = ٨
E [[Γ ▶ (M, N): A1 × A2]]γ = (E [[Γ ▶ M : A1]]γ, E [[Γ ▶ N : A2]]γ)
E [[Γ ▶ πi(M): Ai]]γ = Πi(E [[Γ ▶ M : A1 × A2]]γ)
E [[Γ ▶ λx.M : A → B]]γ = Λv ∈ T [[A]]. E [[Γ, x:A ▶ M : B]]γ[x '→ v]
E [[Γ ▶ M N : B]]γ = (E [[Γ ▶ M : A → B]]γ)(E [[Γ ▶ N : A]]γ)
E [[Γ ▶ ⟨a⟩M : ⟨α⟩A]]γ = ⟨⟨a'⟩⟩E [[Γ#a:α ▶ M : A]]γ[a '→ a']
(a' ∈/ supp(γ))
E [[Γ ▶ M @ a : A]]γ = E [[Γ' ▶ M : ⟨α⟩A]] (Γ' ▶ a : α \ Γ)


S[[Γ' ▶ · : ·]]γ = [·]
S[[Γ' ▶ θ, M/x : Γ,x : A]]γ = S[[Γ' ▶ θ : Γ ][x '→ E [[M ]]γ]
S[[Γ' ▶ θ, b/a : Γ#a:α]]γ = S[[Γ'' ▶ θ : Γ']][a '→ γ(b)] (Γ' ▶ b : α \ Γ'')

Fig. 7. Type, substitution, and expression interpretations

Suppose we are given an interpretation of the data types δ as nominal sets T0[[δ]]. We interpret the other types of SNTT as nominal sets T [[A ] as shown in Figure 7. We define the universe U of the interpretation as the disjoint union of all interpretations of types  A T [[A]]. This is a nominal set.
A valuation is a function γ from a finite subset of V ∪ A (recall that V and A are disjoint) to the universe U . We write [·] for the empty valuation and γ[x '→ v] or γ[a '→ b] for the result of extending valuation γ with a binding for a variable x /∈ dom(γ) or name a /∈ dom(γ), respectively. We define swappings to act on valuations pointwise: (π · γ)(x) = π · (γ(x)) for all x ∈ dom(γ). This swapping action makes valuations into a nominal set, isomorphic to the set of finite products of U indexed by subsets of V ∪ A.
We define the set of valuations satisfying a context Γ as follows:
[[·]] = {[·]}
[[Γ, x:A]] = {γ[x '→ v] | γ ∈ [[Γ]],v ∈T [[A]]}
[[Γ#a:α]] = {γ[a '→ b] | γ ∈ [[Γ]],b ∈ A − supp(γ)}
Intuitively a valuation satisfies a context Γ if it maps variables to values of the appropriate types in Γ and satisfies all of the freshness constraints in Γ. Note, in particular, that no two names in dom(γ) can be mapped to the same name if γ ∈ [[Γ]] for some Γ.
Now suppose equivariant interpretations E0[[c : A]] ∈ T [[A ] are fixed for each constant c : A ∈ Σ. We interpret well-formed expressions M as functions E [[Γ ▶ M : A ] : [[Γ]] →T [[A ] as shown in Figure 7 (technically, the definition is by recursion on derivation trees). Note that the side-condition on the definition of name-abstraction that can always be satisfied by renaming the bound name a away from the support of γ. We also interpret (well-formed) substitutions θ as functions S[[Γ' ▶ θ : Γ]] : [[Γ']] → [[Γ]]. We often abbreviate these to just E [[M ]] or S[[θ ] respectively. We have the following basic properties:
Proposition 2.20 (Equivariance) For any Γ, M,A satisfying Γ ▶ M : A, we have E [[M ]] is equivariant, in the sense that for any π ∈ FSym(A) and γ ∈ [[Γ]],

π · (S [[M ]]γ) = S [[M ]](π · γ). Moreover, supp(S [[M ]]γ) ⊆ supp(γ).
Proof. The first part follows by induction on M . The second is immediate: for any equivariant function f : X → Y on nominal sets X, Y , supp(f (x)) ⊆ supp(x). 
Lemma 2.21 (Soundness of restriction) If γ ∈ [[Γ]] and Γ ▶ a : α \ Γ' then there exists γ' ∈ [[Γ']] such that γ(a) /∈ supp(γ') and γ' agrees with γ on Γ'.
Theorem 2.22 (Semantic soundness) Let Γ,γ ∈ [[Γ]] be given. Then (1) if Γ ▶
M : A then S [[M ]]γ ∈7 [[A]], (2) if Γ ▶ θ : Γ' then £[[θ]]γ ∈ [[Γ']]
Proposition 2.23 (Semantic substitution) If Γ ▶ M : A and Γ' ▶ θ : Γ then for any γ ∈ [[Γ']] we have S [[M [θ]]]γ = S [[M ]](£[[θ]]γ).
Theorem 2.24 (Equational soundness) If Γ ▶ M, N : A and M ←→∗  N then
for any γ ∈ [[Γ]] we have S [[M ]]γ = S [[N ]]γ.

Extensions
By itself, SNTT is not very expressive. It cannot, for example, define the size, sub- stitution, or free-variables functions for a nominal datatype representing the syntax of a language such as the λ-calculus or π-calculus. To do so, we need booleans, numbers, conditionals, name-equality tests, and perhaps additional type construc- tions such as lists. More importantly, we need structural recursion over nominal datatypes. In this section we show how these features can be accommodated soundly in SNTT, by adding types, constants, and rewriting rules.

Conditionals and name-equality
Consider the type bool, constants true, false, and conditionals and equality tests:
if (−) then (−) else (−) : bool → A → A → A	(=) : α → α → bool

The reduction rules and denotational semantics for booleans and conditionals are standard. For equality tests, we consider rules:


a = a dβ true
a = b dβ false
S [[M = N ]]γ =	true (E [[M ]]γ = E [[N ]]γ)
false (E [[M ]]γ /= E [[N ]]γ)

Note that in the reduction rules, we only consider names, not arbitrary terms.
In order for the Church-Rosser and semantic soundness properties to hold, it is essential that the second β-rule a = b —→β false is valid no matter how a and b are interpreted. Thus, we need to ensure that two syntactically distinct names never are identified as the result of a β-reduction. This is accomplished by context restriction in the absE rule. Furthermore, at the denotational level, the equality reduction rule is sound for well-typed terms precisely because if context Γ contains two distinct names a, b, then γ ∈ [[Γ]] must satisfy γ(a) /= γ(b).

Numbers and lists
Natural numbers and lists also can be defined in Nom. Thus, we can extend SNTT with the types nat and listA and constants:


zero : nat
succ : nat → nat
(+) : nat → nat → nat
[]A : listA
M ::A N : A → listA → listA appendA : listA → listA → listA removeA : ⟨α⟩listα → listα

Standard recursion primitives can also be added. The semantics of these operations are standard, except for remove, which we define operationally as:


remove(⟨a⟩[]) dβ
[]	remove(⟨a⟩(a :: M)) dβ remove(⟨a⟩M )
remove(⟨a⟩(b :: M)) dβ b :: remove(⟨a⟩M )  (a /= b)

Note that, like name-equality, these rules rely on the fact that syntactically distinct names always differ semantically.
Nominal recursion combinators
One of the main advertised benefits of nominal logic (and related approaches such as binding algebras [4]) over other techniques has been the availability of principles for inductive reasoning and recursive definitions that extend well-known principles for induction and recursion for “first-order” languages without binding.
As one example, we consider a signature ΣΛ with constants that define the
syntax of lambda-terms modulo alpha-equivalence using nominal terms: ΣΛ = {var : α → Λ,  app : Λ × Λ → Λ,  lam : ⟨α⟩Λ → Λ}
It has been shown in several places (see e.g. [3,15]) that it is possible to model this language using a least fixed point construction on nominal sets , since X '→ ⟨⟨A⟩⟩X
is a continuous operator on nominal sets. The resulting nominal set Λ ∼= A+Λ×Λ+
⟨⟨A⟩⟩Λ is isomorphic to the set of all (open) lambda-terms modulo α-equivalence.
Unfortunately, existing approaches to recursion on nominal terms still seem more complex than for ordinary datatypes, since additional reasoning about freshness needs to be performed. For example, in the approaches of Norrish [9], Pitts [15] and Urban and Berghofer [23], the function defining the lam case must satisfy a “freshness condition on binders” (FCB) stating, informally, that bound names do not escape.
In SNTT, this constraint is internalized into the implicit restrictions on names and name-abstractions enforced by the type system. We can therefore (as in [22,19]) simply introduce a recursion combinator and associated βη-conversions for lambda- term syntax as follows, by analogy with ordinary algebraic datatypes:
recB : (α → B) → (B × B → B) → (⟨α⟩B → B) → (Λ → B) ∈ ΣΛ
recB fvar fapp flam (var M) dβ fvar M
recB fvar fapp flam (app M) dβ fapp (recB(π1(M)), recB(π2(M)))
Λ	Λ	Λ
recB fvar fapp flam (lam M) dβ flam (⟨a⟩recB(M @ a))
Λ	Λ
M :Λ dη recΛ (var) (app) (lam) M

size = λx.recnat (λv.1) (λm, n.m + n + 1) (λn.n + 1) x  : Λ → int
subst = λx, f.recΛ (f) (app) (lam) x	: Λ → (α → Λ) → Λ
subst1 = λx, y, v.subst x (λw.if v = w then y else var(w)) : Λ → Λ → α → Λ
fvs = λx.reclistα (λv.[v]) (append) (remove) x	: Λ → listα

Fig. 8. Examples of recursive definitions.
A few examples are shown in Figure 8, including the size function, capture- avoiding substitution functions (for both simultaneous and single substitution), and the free variables function. All of these examples typecheck, and this is all that is necessary to ensure that they correspond to total, terminating functions on λ-terms. As in (pure) FreshML, we cannot define a “bound variables function” bvs that returns, for example, [a] given lam(⟨a⟩var(a)). No such “function” exists in the nominal set semantics. Moreover, the type system prevents us from defining such a function because given a variable of type ⟨α⟩A, there is no way to generate a name of type α that we can return in the case for lam. Conversely, many (computable) functions exist in the nominal set semantics but cannot be defined using SNTT. In particular, functions that rely on “well-behaved” use of local names, such as Pitts’
definition of normalization by evaluation [15], cannot be handled in SNTT.
As noted earlier, SNTT signatures and terms generalize the nominal signatures and ground nominal terms considered in prior work [15,24]. Given any nominal sig- nature Σ, it is straightforward to define recursion principles for all of its datatypes, along with suitable β-reduction and η-expansion rules, to obtain an extended system SNTT(Σ). Moreover, we conjecture that Theorems 2.8–2.22 continue to hold for any such extension, but have not proved this; a complete investigation is deferred to future work.
Related and Future Work
A great deal of research on both nominal and other techniques for abstract syntax with binding informs and motivates this work; we cannot give a complete survey here. We have discussed closely related research in the body of the paper, and in this section will briefly discuss additional closely related and recent work; more detailed discussion can be found in [3,15].
SNTT’s contexts are a simplified form of the bunched contexts in the αλ- calculus [11]. It would be natural to add a type α#A consisting of “fresh” pairs
(a, x) where a ∈/ supp(x); this would be a simple form of the ∗-type in the αλ-
calculus, and would be adjoint to name-abstraction However, we would need to make contexts more complicated to handle this.
Pottier [16] has recently revisited the problem of inferring freshness information for “pure” FreshML [12]. This approach reduces freshness inference to set constraint solving and is aimed towards practical programming rather than deduction. This system can typecheck more programs, but may require programmers to decorate types with freshness constraints.
Recursion for nominal abstract syntax has been studied by several authors

[9,23,15]. Recursion principles have also been developed using other techniques such as binding algebras [4], functor category semantics [8], the Theory of Contexts [1], modal type systems [20] and parametricity [26]. Schu¨rmann, Poswolsky, and Sarnat’s ∇-calculus [21] is a core language for the Elphin programming language, a language for functional programming with simply-typed higher-order abstract syn- tax. More recently [18] have extended this approach in the language Delphin that permits functional programming over arbitrary dependent LF signatures. Pien- tka [13] has developed a related, but distinct approach to functional programming over LF specifications using explicit contexts and context polymorphism.
These approaches seem to require more effort to use than recursion in SNTT. Previous nominal techniques involve checking freshness side-conditions; techniques such as binding algebras and the Theory of Contexts rely on nontrivial type- theoretic or category-theoretic foundations; and most previous higher-order tech- niques do not provide equality on names. SNTT’s simplicity comes at the (apparent) price of expressiveness; however, little is known about how any of these approaches compare (or should be compared) in terms of expressiveness. Comparing the ex- pressiveness of these approaches seems like a crucial area for future work.
Another immediate direction for future work is extending SNTT to richer type theories such as dependent or polymorphic types which could serve as proof sys- tems for larger fragments of nominal logic. We believe that SNTT addresses the main obstacle to combining nominal terms with ordinary λ-calculi, but, as in the dependent type theories of Scho¨pp and Stark [22,19], there may be complications arising from the interaction of names and dependency or polymorphism.
One feature of nominal logic not presently reflected in SNTT is the equivari- ance principle [14] stating that validity is preserved by bijective (or, equivalently, injective) renaming. In SNTT, this would take the form of an explicit swapping proof term π · M , where π is a permutation. We have omitted explicit permutation
terms because they seem to complicate the presentation (for example, by making the Church-Rosser property more difficult to prove) without contributing much; nevertheless, they may be necessary to model full nominal logic.
Another direction for future work is developing a type-theoretic version of nom- inal logic’s freshness principle, which says that we may always obtain a fresh name. In SNTT, a natural way to model the freshness principle is to incorporate a name- generation term νa:α.M . By analogy with the ν construct in the π-calculus, and
with FreshML’s let fresh construct, such an operator would permit us to obtain a fresh name a and use it within M . However, the behavior of νa:α.M as a proof term is problematic. Similar name-generation operators has been studied indepen- dently of name-binding by Pitts and Stark [17] and Odersky [10]. Pitts and Stark’s semantics for ν is, like FreshML’s let fresh, generative; conversely, Odersky’s ap- proach is purely functional but it admits well-formed, “stuck” terms such as νa.a that are not considered to be values. Neither approach seems compatible with a denotational reading of proof terms as pure functions, at least without making the system considerably more complex to prevent ν-generated names from “escaping”. Resolving the tension between νa.M ’s intuitive generative reading and the needs of

a pure type theory seems a significant challenge, which we hope to tackle next.
Of course, we are also interested in completely formalizing and verifying the metatheory of SNTT itself; we have already formalized the key syntactic properties (up to subject reduction) using Isabelle/HOL-Nominal system [25].

Conclusion
Although proof systems for classical nominal logic have been studied extensively, constructive techniques have received less attention. This paper develops a simple type theory for nominal terms, called SNTT, that combines ordinary unit, pair, and function types with the names and name-abstractions of nominal logic. SNTT is sound and strongly normalizing, can be interpreted using nominal sets, and can easily be extended with recursion combinators for languages with binding that are simpler, albeit less expressive, than in previous systems. Extensions to richer type theories or larger fragments of nominal logic remain to be investigated.

Acknowledgement
The author was supported by EPSRC grant EP/F028288/1 while performing this research. Thanks are also due to Andrew Pitts, Christian Urban and the anonymous reviewers for detailed comments and suggestions.

References
Anna Bucalo, Furio Honsell, Marino Miculan, Ivan Scagnetto, and Martin Hoffman. Consistency of the theory of contexts. J. Funct. Program., 16(3):327–372, 2006.
J. Cheney. A simpler proof theory for nominal logic. In FOSSACS 2005, volume 3441 of LNCS, pages 379–394. Springer-Verlag, 2005.
J. Cheney. Completeness and Herbrand theorems for nominal logic. Journal of Symbolic Logic, 71(1):299–320, 2006.
M. P. Fiore, G. D. Plotkin, and D. Turi. Abstract syntax and variable binding. In LICS 1999, pages 193–202. IEEE Press, 1999.
M. J. Gabbay. Fresh logic: proof-theory and semantics for FM and nominal techniques. Journal of Applied Logic, 5(2):356–387, June 2007.
M. J. Gabbay and J. Cheney. A sequent calculus for nominal logic. In LICS 2004, pages 139–148. IEEE, 2004.
M. J. Gabbay and A. M. Pitts. A new approach to abstract syntax with variable binding. Formal Aspects of Computing, 13:341–363, 2002.
Martin Hofmann. Semantical analysis of higher-order abstract syntax. In Giuseppe Longo, editor, Proceedings of the 14th Annual IEEE Symposium on Logic in Computer Science, pages 204–213, Washington, DC, 1999. IEEE, IEEE Press.
M. Norrish. Recursive function definitions for types with binders. In TPHOLs, number 3223 in LNCS, pages 241–256. Springer-Verlag, 2004.
Martin Odersky. A functional theory of local names. In Proc. 21st ACM Symposium on Principles of Programming Languages, pages 48–59, January 1994.
Peter O’Hearn. On bunched typing. J. Funct. Program., 13(4):747–796, 2003.


A. M. Pitts and M. J. Gabbay. A metalanguage for programming with bound names modulo renaming. In MPC 2000, number 1837 in LNCS, pages 230–255. Springer-Verlag, 2000.
Brigitte Pientka. A type-theoretic foundation for programming with higher-order abstract syntax and first-class substitutions. In POPL, pages 371–382, 2008.
A. M. Pitts. Nominal logic, a first order theory of names and binding. Information and Computation, 183:165–193, 2003.
Andrew M. Pitts. Alpha-structural recursion and induction. Journal of the ACM, 53(3):459–506, May 2006.
Fran¸cois Pottier. Static name control for FreshML. In LICS 2007, pages 356–365, Wroclaw, Poland, July 2007.
Andrew Pitts and Ian Stark. Observable properties of higher order functions that dynamically create local names, or: What’s new? In MFCS 1993, number 711 in LNCS, pages 122–141. Springer-Verlag, 1993.
Adam Poswolsky and Carsten Schu¨rmann. Practical programming with higher-order encodings and dependent types. In ESOP, number 4960 in LNCS, pages 93–107, 2008.
Ulrich Sch¨opp. Names and Binding in Type Theory. PhD thesis, University of Edinburgh, 2006.
Carsten Schu¨rmann, Joelle Despeyroux, and Frank Pfenning. Primitive recursion for higher-order abstract syntax. Theoretical Computer Science, 266:1–57, 2001.
Carsten Schu¨rmann, Adam Poswolsky, and Jeffrey Sarnat. The [triangle]-calculus. functional programming with higher-order encodings. In Pawel Urzyczyn, editor, TLCA, volume 3461 of Lecture Notes in Computer Science, pages 339–353. Springer, 2005.
Ulrich Sch¨opp and Ian Stark. A dependent type theory with names and binding. In CSL 2004, number 3210 in LNCS, pages 235–249, Karpacz, Poland, 2004.
C. Urban and S. Berghofer. A recursion combinator for nominal datatypes implemented in Isabelle/HOL. In IJCAR, volume 4130 of LNCS, pages 498–512. Springer-Verlag, 2006.
C. Urban, A. M. Pitts, and M. J. Gabbay. Nominal unification. Theoretical Computer Science, 323(1– 3):473–497, 2004.
Christian Urban. Nominal techniques in Isabelle/HOL. Journal of Automated Reasoning, 40(4):327– 356, 2008.
G. Washburn and S. Weirich. Boxes go bananas: Encoding higher-order abstract syntax with parametric polymorphism. In ICFP 2003, pages 249–262, 2003.
