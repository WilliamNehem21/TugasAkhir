Electronic Notes in Theoretical Computer Science 209 (2008) 55–81	
www.elsevier.com/locate/entcs

Parallel Processes with Implicit Computational Capital 1
J. A. Bergstraa,b,2
a Programming Research Group University of Amsterdam Amsterdam, the Netherlands
C. A. Middelburga,3
b Department of Philosophy Utrecht University
Utrecht, the Netherlands

Abstract
We propose a process algebra which is concerned with processes that have an implicit computational capital. This process algebra is intended to be helpful when designing computer-based systems of which the behaviour is related to money handling. It goes along with the development that the behaviour of computer-based systems, organizations and persons is increasingly more related to money handling.
Keywords: Process algebra, Implicit computational capital, Preservation of computational money.

Introduction
The objective of the work reported upon in this paper is to develop new ways to use formal methods from computer science as tools for understanding money handling in a computerized setting.
Money can take different forms in practice. However, there are indications that money will become a computational phenomenon altogether: (i) the use of cash money is declining whereas different forms of electronic money are increasingly more used; (ii) in several domains, the use of cash money is already phased out in

1 This research has been carried out in the framework of the Jacquard-project Symbiosis, which is funded by the Netherlands Organisation for Scientific Research (NWO). This research has been partly carried out while the second author was also at Eindhoven University of Technology, Department of Mathematics and Computer Science.
2 Email: J.A.Bergstra@uva.nl
3 Email: C.A.Middelburg@uva.nl

1571-0661 © 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.04.004

favour of forms of electronic money. An important consequence of this development is the following: it will become a matter of computational correctness that unwanted effects, such as creation of money from nowhere and leakage of money, do not take place.
It is not an easy matter to determine what are the basics of money handling. Money is what is considered and used as money by a group of people. This implies that economics, sociology and ethnography are involved in deciding what is money and what is not. For that reason, we do not aim at covering all aspects of money handling.
We propose to use the term computational money for quantities that are treated
in a computerized setting as if they are money, ignoring the question whether from the perspective of the philosophy of economics these quantities represent money. On the one hand, thinking in terms of computational money instead of ‘real money’ is a drastic simplification. On the other hand, it does not preclude the possibility that computational money is at the same time considered a form of real money.
In this paper, we take up the challenge to formalize an elementary theory of computational money that is helpful when designing systems of which the behaviour is related to money handling. Rather than developing a new formalism from scratch, we will extend an existing formalism. We will add a form of computational money to ACP [3,2] to obtain a process algebra which is concerned with processes that have
an implicit computational capital. This process algebra, which is called ACPicc,
goes along with the development that the behaviour of computer-based systems, organizations and persons is increasingly more related to money handling. We show how bisimulation models of ACP can be expanded to models of ACPicc.
We also extend ACPicc with abstraction from internal actions. It happens that restrictions must be imposed on the actions from which abstraction is allowed in order to preclude unexpected effects of this kind of abstraction on the implicit com- putational capital of processes. The approach to abstraction from internal actions followed in this paper is based on the notion of branching bisimulation [13].
Although a subtly different approach to abstraction from internal actions is followed in CCS [9,10], the work presented in this paper can easily be adapted to CCS.
It is imaginable that, when money has become a computational phenomenon altogether, the very concept of money will be gradually superseded by new concepts that are connected with the different ways in which money handling is related to the behaviour of computer-based systems, persons and organizations. Speculating about this is interesting, but beyond the scope of computer science research.
The structure of this paper is as follows. First, we review ACP (Section 2) and guarded recursion in the setting of ACP (Section 3). Next, we introduce a simple theory about computational money values called CMV (Section 4) and extend ACP, using CMV, to a theory about processes that have an implicit computational capital (Section 5). After that, we introduce some notions concerning transition systems
which will be used later on (Section 6). Then, we show how bisimulation models of ACP can be expanded to models of ACPicc (Section 7) and discuss the notion

of preservation of computational money (Section 8). Thereupon, we extend ACPicc with abstraction from internal actions (Section 9). Following this, we give examples of the use of ACPicc (Section 10). Finally, we make some concluding remarks and mention some options for future work (Section 11).

Algebra of Communicating Processes
In this section, we shortly review ACP (Algebra of Communicating Processes), introduced in [3]. For a comprehensive overview of ACP, the reader is referred to [2]. Although ACP is one-sorted, we make this sort explicit. The reason for this is that we will extend ACP with a second sort in Section 5.
In ACP, it is assumed that a fixed but arbitrary finite set of actions A, with δ  A has been given. We write Aδ for A  δ . It is further assumed that a fixed but arbitrary commutative and associative communication function :Aδ Aδ  Aδ, such that δ a = δ for all a  Aδ, has been given. The function  is regarded to give
the result of synchronously performing any two actions for which this is possible, and to be δ otherwise.
The algebraic theory ACP has one sort: the sort P of processes. To build terms
of sort P, ACP has the following constants and operators:
the deadlock constant δ : P;
for each a ∈ A, the action constant a : P;
the binary alternative composition operator + : P × P → P;
the binary sequential composition operator · : P × P → P;
the binary parallel composition operator  : P × P → P;
the binary left merge operator [[ : P × P → P;
the binary communication merge operator | : P × P → P;
for each H ⊆ A, the unary encapsulation operator ∂H : P → P.
Terms of sorts P are built as usual for a one-sorted signature (see e.g. [14,11]). Throughout the paper, we assume that there are infinitely many variables of sort P, including x, y, z.
We use infix notation for the binary operators. The following precedence con- ventions are used to reduce the need for parentheses. The operator + binds weaker than all other binary operators to build terms of sort P and the operator binds stronger than all other binary operators to build terms of sort P.
Let p and q be closed terms of sort P, a  A, and H  A. Intuitively, the constants and operators to build terms of sort P can be explained as follows:
δ can neither perform an action nor terminate successfully;
a first performs action a and then terminates successfully;
p + q behaves either as p or as q, but not both;
p·q first behaves as p, but when p terminates successfully it continues by behaving

Table 1 Axioms of ACP


(x + y)+ z = x + (y + z)	A2
x + x = x	A3
(x + y) z = x z + y z	A4 (x y) z = x (y  z)	A5
x + δ = x	A6
δ · x = δ	A7


∂H (a) = a	if a	H D1
∂H (a) = δ	if a	H D2
∂H (x + y) = ∂H (x)+ ∂H (y) D3
∂H (x · y) = ∂H (x) · ∂H (y)	D4

as q;
a [[ x = a · x	CM2
a · x [[ y = a · (x y)	CM3 (x + y) [[ z = x [[ z + y [[ z CM4 a · x | b = (a | b) · x	CM5
a | b · x = (a | b) · x	CM6 a · x | b · y = (a | b) · (x y) CM7 (x + y) | z = x | z + y | z   CM8 x | (y + z) = x | y + x | z   CM9

a | b = b | a	C1
(a | b) | c = a | (b | c)	C2
δ | a = δ	C3

p  q behaves as the process that proceeds with p and q in parallel;
p	q behaves the same as p  q, except that it starts with performing an action of p;
p q behaves the same as p  q, except that it starts with performing an action of
p and an action of q synchronously;
∂H (p) behaves the same as p, except that actions from H are blocked.
We write Σi∈I pi, where I = {i1,..., in} and pi1 ,..., pin are terms of sort P, for pi1 + ... + pin . The convention is that Σi∈I pi stands for δ if I = ∅.
The axioms of ACP are the axioms given in Table 1. CM2–CM3, CM5–CM7,
C1–C3 and D1–D4 are actually axiom schemas in which a, b and c stand for arbitrary constants of sort P (keep in mind that also the deadlock constant belongs to the constants of sort P) and H stands for an arbitrary subset of A.
For the main models of ACP, the reader is referred to [2].

Guarded Recursion
In this section, we shortly review guarded recursion in the setting of ACP.
Not all processes in a model of ACP have to be the interpretation of some closed term of sort P. Those processes may be definable over ACP.
A process in some model of ACP is deﬁnable over ACP if there exists a guarded recursive specification over ACP of which that process is the unique solution.
A recursive speciﬁcation over ACP is a set of equations E = X = tX X	V where V is a set of variables and each tX is a term of sort P from the language of ACP that only contains variables from V . We write V(E) for the set of all variables that occur on the left-hand side of an equation in E. A solution of a recursive specification E is a set of processes (in some model of ACP) {PX | X ∈ V(E)} such

Table 2 Axioms for recursion

⟨X|E⟩ = ⟨t|E⟩	if X = t ∈ E RDP
E ⇒ X = ⟨X|E⟩ if X ∈ V(E) RSP


Table 3 Approximation induction principle

  n≥0πn(x) = πn(y) ⇒ x = y AIP


that the equations of E hold if, for all X ∈ V(E), X stands for PX .
Let t be a term of sort P from the language of ACP containing a variable X. Then an occurrence of X in t is guarded if t has a subterm of the form a t' where a
A and t' is a term containing this occurrence of X. Let E be a recursive specification
over ACP. Then E is a guarded recursive speciﬁcation if, in each equation X = t  E, all occurrences of variables in t are guarded or t can be rewritten to such a term using the axioms of ACP in either direction and/or the equations in E except the equation X = t from left to right. We are only interested in models of ACP in which guarded recursive specifications have unique solutions.
For each guarded recursive specification E and each variable X V(E), we introduce a constant of sort P standing for the unique solution of E for X. This constant is denoted by X E . We often write X for X E if E is clear from the context. In such cases, it should also be clear from the context that we use X as a constant.
The additional axioms for recursion are given in Table 2. In this table, we write t E  for t with, for all X  V(E), all occurrences of X in t replaced by X E . Both RDP and RSP are axiom schemas. Side conditions are added to restrict the variables, terms and guarded recursive specifications for which X, t and E stand.
We will write ACP+REC for ACP extended with the constants standing for the unique solutions of guarded recursive specifications and the axioms RDP and RSP. Each closed term of sort P from the language of ACP denotes a finite process,
i.e. a process of which the length of the sequences of actions that it can perform is bounded. However, not each closed term over the signature of ACP+REC denotes a finite process: recursion gives rise to infinite processes. Closed terms over the signature of ACP+REC that denote the same infinite process cannot always be proved equal by means of the axioms of ACP+REC. To remedy this, we introduce the approximation induction principle.
The approximation induction principle, AIP in short, is based on the view that two processes are identical if their approximations up to any finite depth are iden- tical. The approximation up to depth n of a process behaves the same as that process, except that it cannot perform any further action after n actions have been performed.
AIP is the infinitary conditional equation given in Table 3. Here, approximation up to depth n is phrased in terms of a unary projection operator πn. The axioms for the projection operators are given in Table 4. Axioms PR1–PR5 are actually
axiom schemas in which a stands for an arbitrary constants of sort P and n stands

Table 4
Axioms for projection operators

π0(a) = δ	PR1
πn+1(a) = a	PR2
π0(a x) = δ	PR3 πn+1(a x) = a πn(x)  PR4 πn(x + y) = πn(x)+ πn(y) PR5
for an arbitrary natural number.
Let T stand for either ACP or ACP+REC. Then we will write T +PR for T
extended with the projections operators πn and the axioms PR1–PR5.
AIP is consistent with ACP+PR and ACP+REC+PR, but it does not hold in all models for ACP and ACP+REC. RSP is derivable from the axioms of ACP, RDP and AIP.
Computational Money Values
In this section, we present an algebraic theory about computational money values. The presented theory is called CMV.
The algebraic theory CMV has one sort: the sort M of computational money values. The algebraic theory CMV has the following constants and operators:
the constant 0 : M;
the constant 1 : M;
the binary addition operator + : M × M → M;
the unary additive inverse operator − : M → M;
the binary multiplication operator · : M × M → M;
the binary maximum operator max : M × M → M.
Terms of sort M are built as usual for a one-sorted signature. Throughout the paper, we assume that there are infinitely many variables of sort M, including i, j, k, l.
As usual, we use prefix notation for the unary operator  and infix notation for the binary operators + and  . The following additional precedence convention is used to reduce the need for parentheses. The binary operator + binds weaker than all other operators to build terms of sort M and the unary operator binds stronger than all other operators to build terms of sort M. We introduce the following abbreviation: m2, where m is term of sort M, abbreviates m · m.
The constants and operators of CMV are adopted from integer arithmetic and need no further explanation.
The axioms of CMV are the axioms given in Tables 5. Axioms CMV1–CMV8 are the axioms of a commutative ring with unit. Axioms CMV9–CMV11 are the defining axioms of max. In axiom CMV11, use is made of Lagrange’s theorem that every natural number can be represented as the sum of four squares. In this way, the introduction of the ordering relation concerned is saved.
The initial model of CMV is considered the standard model of CMV.

Table 5
Axioms for computational money values

(i + j)+ k = i + (j + k)	CMV1
i + j = j + i	CMV2
i +0 = i	CMV3
i +	i = 0	CMV4
(i  j)  k = i  (j  k)	CMV5
i j = j  i	CMV6
i  1 = i	CMV7
i (j + k) = i j + i k	CMV8
max(i, j) = max(j, i)	CMV9
max(i + k, j + k) = max(i, j)+ k	CMV10 max(0, i2 + j2 + k2 + l2) = i2 + j2 + k2 + l2 CMV11
Parallel Processes with Computational Capital
In this section, we take up the extension of ACP to a theory about processes that have an implicit computational capital. The resulting theory is called ACPicc.
First of all, we give a picture of the ideas that underlie the design of this exten- sion. There are three kinds of actions: actions with which an amount of compu- tational money is spent, actions with which an amount of computational money is acquired and actions with which no computational money is spent or acquired. As for spending or acquiring computational money, the effect of performing two actions synchronously is the joint effect of the two actions concerned.
The implicit computational capital of a process is the amount of computational money that the process has available to spend by performing actions, measured as a natural number. As the name suggests, the implicit computational capital of a process is looked upon as an implicit property of the process. It is the least amount
of computational money that is needed to account for the behaviour of the process. 4
Neither what a process is capable of using exceeds its implicit computational capital nor the other way round. The fact that the implicit computational capital of a process does not exceed what the process is capable of using corresponds to the liquidity assumption that the whole capital can potentially be used. The monetary effects of performing actions do not affect the behaviour of a process that has an implicit computational capital.
Now for the presentation of the extension of ACPicc. It has the sorts, constants
and operators of both ACP and CMV, the projection operators πn, and in addition the following constants and operators to build terms of sort M:
for each a ∈ A, the computational money transfer constant q(a): M;
the unary implicit computational capital operator Q : P → M.
The projection operators are included because they are needed in the axioms con- cerning the implicit computational capital of infinite processes.

4 In ACP-like process algebras, it is usual to consider the terms process and behaviour synonyms. This is not the case in ACPicc, where a process is made up of behaviour and implicit computational capital.

Table 6
Axioms for computational money transfer

q(c) = q(a)+ q(b)	if a | b = c CMTC

Table 7
Axioms for implicit computational capital

Q(δ) = 0	ICC1
Q(a) = max (q(a), 0)	ICC2
max(Q(x), 0) = Q(x)  Q(a x) = max(q(a)+ Q(x), 0)	ICC3 max(Q(x), 0) = Q(x)  max(Q(y), 0) = Q(y)   Q(x + y) = max(Q(x), Q(y)) ICC4
  m≥0 max(Q(πm(x)), Q(πn(x))) = Q(πn(x)) ⇒ Q(x) = Q(πn(x))	ICC5
  n≥0  m≥0 max(Q(πm(x)), Q(πn(x))+ 1) = Q(πm(x)) ⇒ Q(x) = −1	ICC6

Let p be a closed term of sort P. Intuitively, the computational money trans- fer constants and the implicit computational capital operator can be explained as follows:
if q(a) > 0, then q(a) is the amount of computational money spent by a process on performing action a;
if q(a) < 0, then	q(a) is the amount of computational money acquired by a process on performing action a;
if q(a) = 0, then nothing is spent or acquired by a process on performing action
a;
Q(p) is the amount of computational money that process p has available to spend by performing actions.
If q(a) = 0, then action a is called CM-neutral.
It is assumed that for each a  A, a fixed but arbitrary equation q(a) = m, where m is a closed term of sort M from the language of CMV has been given. We write CMT for the set of all those equations. It is further assumed that, for all a, b, c  A for which a b = c, the equation q(c) = q(a)+ q(b) is derivable from CMT and the axioms of CMV.
The axioms of ACPicc are the axioms of ACP, the axioms of CMV, axioms PR1–PR5 from Table 4, the equations from CMT, and the axioms given in Tables 6 and 7. CMTC and ICC2–ICC3 are actually axiom schemas in which a, b and c stand for arbitrary constants of sort P different from δ.
The equations from CMT and axiom CMTC concern spending and acquiring computational money on performing actions. The equations from CMT are the defining equations of the computational money transfer constants. CMTC expresses that, as for spending or acquiring computational money, the effect of performing two actions synchronously is the joint effect of the two actions concerned.
The implicit computational capital of a process is the amount of computational money that the process is capable of using. This amount cannot be negative. How- ever, it can be undefined if the process is infinite. In order to circumvent the use of algebras with partial operations, which is not considered in elementary algebraic specifications (see e.g. [7]), −1 is used to represent the undefinedness of the implicit

computational capital of a process. Axioms ICC1–ICC4 cover the case where the process is finite. Axioms ICC5 and ICC6 cover the case where the process is infi- nite. Axiom ICC5 states that the implicit computational capital of a process is the greatest capital among the implicit computational capitals of all finite approxima- tions of the process if it exists. Otherwise, axiom ICC6 applies. ICC5 and ICC6 are infinitary formulas, but ICC5 is still a conditional equation.
Proposition 5.1 For all closed terms p1 and p2 of sort P from the language of
ACP, the following is derivable from the axioms of ACPicc:

Q(p1 · p2) ≤ Q(p1)+ Q(p2) ,
Q(p1 + p2) ≤ Q(p1)+ Q(p2) ,
Q(∂H (p1)) ≤ Q(p1) ,
Q(p1  p2) = Q(p1)+ Q(p2) ,
Q(p1 [[ p2) ≤ Q(p1)+ Q(p2) ,
Q(p1 | p2) ≤ Q(p1)+ Q(p2) .

Proof. Straightforward, by induction on the structure p1 and p2.	 
Guarded recursion can be added to ACPicc as it is added to ACP in Section 3.
We will write ACPicc+REC for the resulting theory.
The following example goes into the implicit computational capital of an infinite process. In case q(a) > 0, the process  X  X = a  X  repeats forever a step on which the amount q(a) is spent. Because no capital is large enough for that, the implicit computational capital of X X = a X  is undefined if q(a) > 0. Assuming q(a) > 0, we derive from axioms RDP, PR3, PR4 and ICC6, using an inductive argument, that Q( X  X = a  X  ) =  1. In case q(a) < 0, the process
X  X = a  X  repeats forever a step on which the amount  q(a) is acquired. In case q(a) = 0, the process X X = a X  repeats forever a step on which nothing is spent or acquired. Because in both cases no capital is needed, the implicit computational capital of X  X = a X  is zero if q(a)  0. Assuming q(a)  0, we derive from axioms RDP, PR3, PR4 and ICC5, using an inductive argument, that Q(⟨X|{X = a · X}⟩) = 0.
Let p be a closed term of sort P. Then p denotes a “money source” iff Q(p) =  1. It is not that easy to characterize “money sinks”, i.e. processes that accumulate computational money, in terms of Q. Exclusion of money sources by taking the

infinitary formula
 

   max(Q(πm(x)), Q(πn(x))) = Q(πn(x))

n≥0 m≥0
as additional axiom is possible only if we drop RDP: it is inconsistent with RDP.
The set of formulas represented by the schema
q(a) /=⇒0  (a | a' /=δ ∧ q(a)+ q(a') = 0) ,
a'∈A
where a stands for an arbitrary constant of sort P different from δ, can be added to the axioms of ACPicc. These formulas express that, for each action with which an amount of computational money is spent, there exists another action with which it can be performed synchronously and the same amount is acquired, and similarly, for each action with which an amount of computational money is acquired, there exists another action with which it can be performed synchronously and the same

amount is spent. In other words, they say that the monetary effect of performing an action can always be neutralized by performing it synchronously with some other action. It can be useful to hypothesize this neutralization property in derivations concerning a system that is not supposed to interact with its environment, but not otherwise.
In ACPicc, amounts of computational money are not used for book-keeping of
debts. The reason for this is that implicitly abstracting from the process to which a debt is owed is far from obvious.
The models of ACPicc of which the restriction to the signature of CMV is the initial model of CMV are considered the standard models of ACPicc.

Transition Systems Induced by Models of ACP
In this section, we introduce the notions of transition system induced by a model of ACP, paths in a transition system and bisimilarity of transition systems. Those notions will be used in Section 7 to show how bisimulation models of ACP can be expanded to models of ACPicc. Prior to all that, we make precise what we understand by a transition system.
A transition system consists of the following:
a set S of states;

a set −→a
a set −→a
⊆ S × S, for each a ∈ A;
√ ⊆ S, for each a ∈ A;

an initial state s0 ∈ S.
We write s −→a s' instead of (s, s') ∈ −→a and s −→a √ instead of s ∈ −→a √. Furthermore,

we write −→ for the family of sets (−→a )a∈A and −→ √ for the family of sets (−→a
√)a∈A.

Let T1 = (S1, −→1, −→ √ , s0) and T2 = (S2, −→2, −→ √ , s0) be transition systems.
Then a bisimulation B between T1 and T2 is a binary relation B	S1	S2 such
that B(s0, s0) and for all s1, s2 such that B(s1, s2):


s1 −→a
1	2
iff s2 −→a √ ;

if s1 −→a 1 s' , then there is a state s'
such that s2 −→a 2 s'
and B(s' , s' );

if s2 −→a 2 s' , then there is a state s' such that s1 −→a 1 s' and B(s' , s' ).
Two transition systems T1 and T2 are bisimilar, written T1 ↔ T2, if there exists a bisimulation B between T1 and T2.
Let T = (S, −→, −→ √, s0) be a transition system.  Then the set of paths in T ,
written P(T ), is the smallest subset of {π a ⟨s⟩| π ∈ (S × A)∗ ∧ s ∈ S} such that: 5
⟨s0⟩∈ P(T ),
if π a ⟨s⟩∈ P(T ) and s −→a s', then π a ⟨s, a, s'⟩∈ P(T ).
A transition system may have states that are not reachable from its initial state

5 We write ⟨⟩ for the empty sequence, ⟨e⟩ for the sequence having e as sole element and σ a σ' for the concatenation of sequences σ and σ'; and we use ⟨e1,..., en⟩ as a shorthand for ⟨e1⟩ a ... a ⟨en⟩.

by a path in the transition system. We exclude transition systems with unreachable states as follows.
Let T = (S,	,	√, s0) be a transition system. The connected part of T , written
Γ(T ), is defined as follows:


where

and for every a ∈ A:
Γ(T ) = (S', −→', −→ √', s0) ,

S' = {s ∈ S | ∃π ∈ (S × A)∗ • π a ⟨s⟩∈ P(T )} ,

−→a '	= −→a  ∩ (S' × S') ,
−→ √' = −→a √ ∩ S' .
Let A be a model of ACP, let P be the domain of A, and let p	P . Then the transition system of p induced by A, written TS(A, p), is the transition system
Γ(P, −→, −→ √, p) where, for every a ∈ A:
−→ √ = {(p1, p2) | A |= x1 = x1 + a · x2 [p1, p2]} ,
−→	= {p1 | A |= x = x + a [p1]} .
Expanding Models of ACP to Models of ACPicc
In ACPicc, the implicit computational capital of a process is the least amount of computational money that is needed to account for the behaviour of the process. This amount is implicit in the behaviour of the process. In this section, we show that each bisimulation model of ACP can be expanded to a model of ACPicc, provided that it can be expanded to a model of ACP+PR.
Let A be a model of ACP. Then A is a bisimulation model of ACP if for all p
and p' from the domain of A, TS(A, p) ↔ TS(A, p') implies p = p'.
In [6], the full bisimulation models of ACPfo, a first-order extension of ACP, are introduced. The full bisimulation models of ACP are the restrictions of those models to the signature of ACP. The full bisimulation models of ACP are the main models of ACP. We gather from [6]:
the full bisimulation models of ACP are bisimulation models;
each bisimulation model of ACP can be isomorphically embedded in one of the full bisimulation models of ACP;
in each full bisimulation model of ACP, all finite and countably infinite guarded recursive specifications over ACP have a unique solution;
all full bisimulation models of ACP can be expanded to models of ACP+PR;
the full bisimulation model of ACP with the smallest domain can be expanded to a model of ACP+PR in which AIP holds.
Below, we will write ACPcm for ACPicc without the implicit computational capital operator Q and consequently without the axioms ICC1–ICC6. Moreover, we write CMV+CMT for CMV extended with the computational money transfer constants q(a) and the equations from CMT.

Lemma 7.1 For each bisimulation model A of ACP that can be expanded to a model of ACP+PR and each model B of CMV, there exists a model C of ACPcm such that the restriction of C to the signature of ACP is A and the restriction of C to the signature of CMV is B.
Proof. Let A be a bisimulation model of ACP that can be expanded to a model of ACP+PR, and let A' be an expansion of A to a model of ACP+PR. Let B be a model of CMV, and let B' be the unique expansion of B to a model of CMV+CMT. This unique expansion exists because CMV+CMT is a definitional extension of CMV. Moreover, the instances of axiom schema CMTC hold in B' because they are derivable from CMT and the axioms of CMV. From this and the fact that the signatures of A' and B' are disjoint, it follows, by the amalgamation result about expansions presented as Theorem 6.1.1 in [8] (adapted to the many- sorted case), that there exists a model C of ACPcm such that the restriction to the signature of ACP+PR is A' and the restriction to the signature of CMV+CMT is B'. Because A' is an expansion of A and B' is an expansion of B, the restriction of C to the signature of ACP is A and the restriction of C to the signature of CMV is B.	 
Theorem 7.2 For each bisimulation model A of ACP that can be expanded to a model of ACP+PR, there exists a model A' of ACPicc such that the restriction of A' to the signature of ACP is A.
Proof. Let A be a bisimulation model of ACP that can be expanded to a model of ACP+PR. Let B be a model of CMV, and let  be the ordering on the domain of B such that, for all i and j from the domain of B, i  j iff max(i, j) = j. It is easy to see that the subset of the domain of B that consists of all elements that are the interpretation of some closed term of sort M is totally ordered by . By Lemma 7.1, there exists a model C of ACPcm of which the restriction to the signature of ACP is A and the restriction to the signature of CMV is B. Let A' be C expanded with the function Q from the domain of A to the domain of B such that, for all p from the domain of A:
Q(p) is the greatest element of Q'(π) π  P(TS(A, p)) with respect to , where Q' is defined inductively by Q'( p' ) = 0 and Q'( p', a aπ) = max(q(a)+Q'(π), 0), if it exists;
Q(p) is −1 otherwise.
Because C is an expansion of A, the restriction of A' to the signature of ACP is A. It remains to be proved that A' is a model of ACPicc. Because A' is an expansion of C, it is sufficient to prove that ICC1–ICC6 hold in A'. Moreover, because each bisimulation model of ACP can be isomorphically embedded in one of the full bisimulation models of ACP, it may be assumed that A is a full bisimulation model of ACP. Then A can be expanded to a model of ACP+PR in a similar way as graph models of ACP are expanded with projection operations in [2]. Without loss of generality, it may be assumed that the restriction of C to the signature of ACP+PR is the expansion of A to a model of ACP+PR obtained in that way. Let

A'' be this expansion of A. Then for all p from the domain of A, P(TS(A'', πn(p))) = π  P(TS(A'', p))  len(π)  n , where len(π) is the length of the sequence from A∗ obtained by leaving out all states in π. From this and the construction of the full bisimulation models of ACP given in [6], it follows easily that ICC1–ICC6 hold in A'.	 

Preservation of Computational Money
In this section, we discuss the notion of preservation of computational money.
Let A be a model of ACPicc, let P be the domain associated with P in A, let
p   P , and let T = (P ',  ,  √, p) be the transition system of p induced by A.
Then p is CM-preserving if:
Q(p') = q(a) for all p' ∈ P ' and a ∈ A such that p' −→a √;

Q(p') = q(a)+ Q(p'') for all p', p'' ∈ P ' and a ∈ A such that p' −→a
Q(p') = Q(p'') for all p', p'' ∈ P \ {δ} such that p' + p'' ∈ P '.
p'';

Using the terminology of [6], CM-preserving belongs to the external properties of processes in models of ACPicc. It is an open problem whether a first-order axiom- atization of this property is possible.
The next proposition states that the implicit computational capital of a CM- preserving process remains constant if it evolves through a number of CM-neutral steps. To make precise what it means to evolve through a number of CM-neutral steps, we introduce the notion of CM-neutral paths.
Let T = (S,	,	√, s0) be a transition system.  Then the set of CM-neutral
paths in T , written NP(T ), is the smallest subset of P(T ) such that:
⟨s0⟩∈ NP(T );
if π a ⟨s⟩∈ NP(T ), s −→a  s' and q(a) = 0, then π a ⟨s, a, s'⟩∈ NP(T ).
Proposition 8.1 Let A be a model of ACPicc, let P be the domain associated with P in A, let p  P, let P '  P be the set of states of TS(A, p), and let p'  P '. Then, for all π  (P '  A)∗, p is CM-preserving and π a p'  NP(TS(A, p)) implies Q(p) = Q(p').
Proof. Straightforward, by induction on the length of π.	 
It is plausible that an electronic device, such as an electronic wallet, is modelled in ACPicc as a process that deadlocks if the device crashes because of a technical failure. In such cases, it is likely that the process is not CM-preserving. This indi- cates that preservation of computational money is not a fact of life, but a constraint on how to model. Modelling with CM-preserving processes may enforce the intro- duction of a hypothetical process to which computational money is transferred just before the crash takes place. The problem with that process is that, unless it is able to dispose of its computational money, it accumulates computational money and by doing so it is not CM-preserving.
In general, in order to make a process that accumulates computational money

CM-preserving, it must be made capable of sending that computational money via a ghost channel that is only used for sending.
As an example, we consider the process X X = a X  where q(a) =  1. This process is clearly accumulating computational money and therefore not CM- preserving. We assume that for all closed terms m and m' of sort M from the lan-
guage of CMV with max(m, 1) = m and max(m', 1) = m', respectively: sghost (m)
A, sghost (m)  sghost (m') = sghost (m + m') and q(sghost (m)) = m.  The process
X X = a (X  sghost (1))  behaves as X X = a X  , except that it can send its computational money in arbitrary amounts at once when needed.

Abstraction from Internal Actions
In this section, we extend ACPicc with abstraction from internal actions. The result
is called ACPτ . In [4], abstraction from internal actions was first introduced in
ACP. The approach to abstraction from internal actions followed in that paper is based on the notion of observation equivalence which originates from [9]. In this paper, a subtly different approach is followed. It is based on the notion of branching bisimulation equivalence which originates from [12].
The sorts, constants and operators of ACPτ	are those of ACPicc, and in addi-
tion:
the silent step constant τ : P;
for each I ⊆ {a ∈ A | q(a) = 0}, the unary abstraction operator τI : P → P.
Let p be a closed term of sort P, and I	a	A	q(a) = 0 . Intuitively, the silent step constant and the abstraction operators can be explained as follows:
τ performs an action that is unobservable and then terminates successfully;
τI (p) behaves the same as p, except that actions from I are turned into silent steps.
It is assumed that τ /∈Aδ. We write Aδτ for Aδ ∪ {τ}. The communication function | : Aδ × Aδ → Aδ is extended to a function | : Aδτ × Aδτ → Aδ by stipulating that a | τ = τ | a = δ for all a ∈ Aδτ .
The axioms of ACPτ  are the axioms of ACPicc and the axioms given in Table 8.
Axioms TI1–TI4 and C4 are actually axiom schemas in which a stands for an arbitrary constant of sort P and I stands for an arbitrary subset of {a ∈ A | q(a) = 0}.
Axioms B1 and B2 reflect the intuition that the presence of a non-initial silent step cannot be inferred from the observable behaviour of a process if the process can perform that silent step without discarding any of the alternatives that it had before. Axioms TI1–TI4 says that abstraction from certain actions turns those actions into silent steps. Axioms PRT1 and PRT2 express that the silent step does not count in projections. Abstraction from actions that are not CM-neutral is excluded because it is considered counter-intuitive to take actions that are not CM- neutral for internal. In agreement with that, axiom CMTT states that the silent

Table 8 Axioms for abstraction

x · τ = x	B1
x · (τ · (y + z)+ y) = x · (y + z) B2
τI (a) = a	if a	I TI1
τI (a) = τ	if a	I TI2
τI (x + y) = τI (x)+ τI (y)	TI3
τI (x · y) = τI (x) · τI (y)	TI4
a | τ = δ	C4
πn(τ ) = τ	PRT1
πn(τ · x) = τ · πn(x)	PRT2
q(τ ) = 0	CMTT

step is CM-neutral. Notice that by this axiom abstraction from actions that are not CM-neutral could lead to change of implicit computational capital as side-effect.
Guarded recursion can be added to ACPτ	as it is added to ACP in Section 3.
The definition of guardedness of an occurrence of a variable in a term must be taken strictly. For example, the rightmost occurrence of X in a · X + τ · X is not guarded. ACP extended with the silent step constant τ , the abstraction operator τI for
each I ∈ A, and the axioms B1, B2 and TI1–TI4, is known as ACPτ . Notice that,
different from ACPτ , ACPτ has an abstraction operator for each I ⊆ A. For a
comprehensive overview of ACPτ , the reader is referred to [2].


Some Examples
In this section, we illustrate the use of ACPicc by means of some examples con- cerning simple vending machines. We have aimed at examples that make an aid in understanding of the notion of implicit computational capital of a process.
If it is possible to perform two actions synchronously, then it is usual that the nature of one of them is active and the nature of the other is passive. In such cases, we use the convention that the constant for the active action with the prefix ∼ is taken as the constant for the passive action. Moreover, the constant of the active action with overlining is taken as the constant for the action that is the result of synchronously performing the active action and the passive action. We take the
| : Aδ × Aδ → Aδ such that for all a ∈ A for which ∼a ∈ A:

a | ∼a = a;
a | b = δ for all b ∈ A \ {∼a};
b | ∼a = δ for all b ∈ A \ {a}.
For all a  A for which ∼a  A, we will always take q(a) and q(∼a) such that q(a)+ q(∼a) = 0.

Example 1
The first example concerns a very simple vending machine. A cup of coffee is the only product that can be bought. Two additives can be ordered, namely milk and sugar. The price of a cup of coffee is € 0.50. Payments can be made by means of coins with value € 0.50 only. The coins are collected in a cash-box with a capacity of 400 coins. The cash-box can be emptied at any time. This simple vending machine, with k0 coins in the cash-box (k0  0,..., 400 ), can be defined by the guarded recursive specification over ACPicc that consists of the following equations:

VM1 k0
VM1 '
= VM1 '
0
= ∼push button(milk ) · VM1 '

as,k
as∪{milk},k
+ ∼push button(sugar ) · VM1 '
+ ∼insert coin · deliver coffee(as) · VM1 '

+ ∼empty cash box (k) · VM1 '
(for every as ⊆ {milk, sugar} and k ∈ {0,..., 399}) ,

'
∅,400
= ∼empty cash box (400) · VM1 '	.

Using € 0.01 as the unit of payment, we take:
q(∼push button(milk )) = 0 , q(∼push button(sugar )) = 0 , q(∼insert coin) =	50 , q(deliver coffee(as)) = 0 ,
q(∼empty cash box (k)) = 50 · k . 
We can prove by means of axioms ICC1–ICC5 that
Q(VM1 k0 ) = 50 · k0 .
This equation indicates that 50 · k0 is the least amount of money that is needed to account for the behaviour of VM1 k0 . This is in agreement with our intuition:
no money is needed for button pushing, coin insertion and coffee delivery;
50 k0 units of money are needed for emptying the cash-box for the first time before the first coin insertion;
50 k0 units of money are also needed for emptying the cash-box for the first time after a number of coin insertions because the additional units of money spent on emptying the cash-box have been acquired by the coin insertions;
no money is needed for emptying the cash-box for a subsequent time because all units of money spent on emptying the cash-box have first been acquired by coin insertions.
We consider a user User1 buying one cup of coffee without additives and one cup of coffee with milk and without sugar:
User1 = insert coin · ∼deliver coffee(∅) ·
push button(milk ) · insert coin · ∼deliver coffee({milk}) .

Using € 0.01 as the unit of payment, we take:
q(push button(milk )) = 0 , q(push button(sugar )) = 0 , q(insert coin) = 50 , q(∼deliver coffee(as)) = 0 .
We can prove by means of axioms ICC1–ICC5 that
Q(User1 ) = 100 .
This equation indicates that 100 is the least amount of money that is needed to account for the behaviour of User1 . This is in agreement with our intuition: no money is needed for button pushing and coffee delivery, and 100 units of money are needed for the two coin insertions because no money is acquired beforehand.
We look at the process described by ∂H1 (VM1 k0  User1 ), where
H1 = {push button(a), ∼push button(a) | a ∈ {milk , sugar}}
∪ {insert coin, ∼insert coin}
∪ {deliver coffee(as), ∼deliver coffee(as) | as ⊆ {milk, sugar}} .
We can easily derive that in the case where k0 ≤ 398:
∂H1 (VM1 k0   User1 ) = 
insert coin · deliver  coffee(∅) ·  	
push button(milk ) · insert coin · deliver coffee({milk}) ·
∂H1 (VM1 k0+2) .
From this, it follows easily that
Q(∂H1 (VM1 k0  User1 )) = 50 · (k0 + 2)
in the case where k0 ≤ 398. This equation indicates that 50 · (k0 + 2) is the least amount of money that is needed to account for the behaviour of ∂H1 (VM1 k0 User1 ). This is in agreement with our intuition: the interactions between VM1 k0 and User1 are all CM-neutral, and after those interactions ∂H1 (VM1 k0 ) behaves as
∂H1 (VM1 k0+2).


Example 2
The second example concerns a vending machine like the one from Section 10.1. The main difference is that payments can be made by means of coins with value
€ 0.50 and coins with value € 1.00. These two kinds of coins are collected in separate cash-boxes. Coins with value € 1.00 are accepted only if the cash-box for coins with value € 0.50 is not empty. This vending machine, with k0 coins in the cash-box
for coins with value € 0.50 and l0 coins in the cash-box for coins with value € 1.00 (k0, l0 ∈ {0,..., 400}), can be defined by the guarded recursive specification over

ACPicc that consists of the following equations:
VM2 k ,l	= VM2 '
0 0	∅,k0,l0
VM2 '	= ∼push button(milk ) · VM2 '

as,0,l
as∪{milk},0,l
+ ∼push button(sugar ) · VM2 '
+ ∼insert coin(50) · deliver coffee(as) · VM2 '

+ ∼empty cash box (50, 0) · VM2 '
+ ∼empty cash box (100, l) · VM2 '
(for every as ⊆ {milk, sugar} and l ∈ {0,..., 400}) ,

'
as,k,l
= ∼push button(milk ) · VM2 '
+ ∼push button(sugar ) · VM2 '
+ ∼insert coin(50) · deliver coffee(as) · VM2 '

+ ∼insert coin(100) · return coin(50)
· deliver coffee(as) · VM2 '
+ ∼empty cash box (50, k) · VM2 '
+ ∼empty cash box (100, l) · VM2 '
(for every as ⊆ {milk, sugar}, k ∈ {1,..., 399} and l ∈ {0,..., 399}) ,

'
as,400,l
= ∼push button(milk ) · VM2 '
+ ∼push button(sugar ) · VM2 '
+ ∼insert coin(100) · return coin(50)
· deliver coffee(as) · VM2 '

+ ∼empty cash box (50, 400) · VM2 '
+ ∼empty cash box (100, l) · VM2 '
(for every as ⊆ {milk, sugar} and l ∈ {0,..., 399}) ,

'
∅,400,400
= ∼empty cash box (50, 400) · VM2 '
+ ∼empty cash box (100, 400) · VM2 '	.

Using € 0.01 as the unit of payment, we take:
q(∼push button(milk )) = 0 , q(∼push button(sugar )) = 0 , q(∼insert coin(m)) =	m , q(return coin(m)) = m , q(deliver coffee(as)) = 0 ,
q(∼empty cash box (m, k)) = m · k . 
We can prove by means of axioms ICC1–ICC5 that
Q(VM2 k0,l0 ) = 50 · k0 + 100 · l0 .
That this equation agrees with our intuition can be seen like in the case of the equation Q(VM1 k0 ) = 50 k0. One additional remark is in order here: no money is needed for a coin return because sufficient units of money have been acquired by the preceding coin insertion.
We consider a user User2 buying one cup of coffee without additives and one cup of coffee with milk and without sugar using a coin with value € 1.00 for the

first cup of coffee and the coin with value € 0.50 returned by the vending machine for the second cup of coffee:
User2 =
insert coin(100) · ∼return coin(50) · ∼deliver coffee(∅) ·
push button(milk ) · insert coin(50) · ∼deliver coffee({milk}) .
Using € 0.01 as the unit of payment, we take:
q(push button(milk )) = 0 , q(push button(sugar )) = 0 , q(insert coin(m)) = m , q(∼return coin(m)) =	m , q(∼deliver coffee(as)) = 0 .
We can prove by means of axioms ICC1–ICC5 that
Q(User2 ) = 100 .
That this equation agrees with our intuition can be seen like in the case of the equation Q(User1 ) = 100. One additional remark is in order here: 100 units of money are needed for the two coin insertions because 50 units of money is acquired by the coin return following the first coin insertion.
We look at the process described by ∂H2 (VM2 k0,l0  User2 ), where
H2 = {push button(a), ∼push button(a) | a ∈ {milk , sugar}}
∪ {insert coin(m), ∼insert coin(m) | m ∈ {50, 100}}
∪ {return coin(50), ∼return coin(50)}
∪ {deliver coffee(as), ∼deliver coffee(as) | as ⊆ {milk, sugar}} .
We can easily derive that in the case where k0 ≥ 1 and l0 ≤ 399:
∂H2 (VM2 k0,l0	User2 ) = 
insert coin(100) · return coin(50) · deliver coffee(∅) ·	
push button(milk ) · insert coin(50) · deliver coffee({milk}) ·
∂H2 (VM2 k0,l0+1) .
From this, it follows easily that
Q(∂H2 (VM2 k0,l0  User2 )) = 50 · k0 + 100 · (l0 + 1)
in the case where k0 ≥ 1 and l0 ≤ 399. That this equation agrees with our intuition can be seen like in the case of the equation Q(∂H1 (VM1 k0  User1 )) = 50 · (k0 + 2). We also consider a user User2 ' buying one cup of coffee without additives and one cup of coffee with milk and without sugar using a coin with value € 0.50 for the
first cup of coffee and a coin with value € 1.00 for the second cup of coffee:
User2 ' =
insert coin(50) · ∼deliver coffee(∅) ·
push button(milk ) ·
insert coin(100) · ∼return coin(50) · ∼deliver coffee({milk}) .
We can prove by means of axioms ICC1–ICC5 that
Q(User2 ') = 150 .

This shows that, although User2 ' does not pay more for two cups of coffee than User2 , more money is needed for the behaviour of User2 ' than for the behaviour of User2 . We can derive that
Q(∂H2 (VM2 k ,l  User2 ')) = Q(∂H2 (VM2 k ,l  User2 ))
in the case where 1 ≤ k0 ≤ 399 and l0 ≤ 399. This can be seen as follows: after the
interactions between VM2 k ,l and User2 ', as well as after the interactions between
0 0
VM2 k0,l0 and User2 , ∂H2 (VM2 k0,l0 ) behaves as ∂H2 (VM2 k0,l0+1).

Example 3
The third example concerns a vending machine like the one from Section 10.1. The main difference is that this vending machine accepts tokens instead of coins. This vending machine, with k0 tokens in the token-box (k0  0,..., 400 ), can be defined by the guarded recursive specification over ACPicc that consists of the following equations:

VM3 k0
VM3 '
= VM3 '
0
= ∼push button(milk ) · VM3 '

as,k
as∪{milk},k
+ ∼push button(sugar ) · VM3 '
+ ∼insert token · deliver coffee(as) · VM3 '

+ ∼empty token box (k) · VM3 '
(for every as ⊆ {milk, sugar} and k ∈ {0,..., 399}) ,

'
∅,400
= ∼empty token box (400) · VM3 '	.

We might take the view that tokens are a form of money. In that case, there would be no essential difference between the example from Section 10.1 and this one. Here, we take the view that tokens are not a form of money. This means that, using € 0.01 as the unit of payment, we take:
q(∼push button(milk )) = 0 , q(∼push button(sugar )) = 0 , q(∼insert token) = 0 ,
q(deliver coffee(as)) = 0 , q(∼empty token box (k)) = 0 .
We can prove by means of axioms ICC1–ICC5 that
Q(VM3 k0 ) = 0 .
This equation indicates that 0 is the least amount of money that is needed to account for the behaviour of VM3 k0 . This is in agreement with our intuition: like in the case of VM1 k0 , no money is needed for button pushing, token insertion and coffee delivery, and moreover no money is needed for emptying the token-box because tokens are not considered as money.
The tokens are obtained from a token-issuing machine. This is a machine by which tokens can be bought. The price of a token is € 0.50. Payments can be made by means of coins with value € 0.50 only. The coins are collected in a cash-box

with a capacity of 400 coins that can be emptied at any time. The token-issuing machine, with l0 coins in the cash-box (l0  0,..., 400 ), can be defined by the guarded recursive specification over ACPicc that consists of the following equations:

TM l0
= TM '

TM l	= ∼insert coin · deliver token · TM l+1
+ ∼empty cash box (l) · TM 0
(for every l ∈ {0,..., 399}) ,
TM 400 = ∼empty cash box (400) · TM 0 .
Using € 0.01 as the unit of payment, we take:
q(∼insert coin) =	50 ,
q(deliver token) = 0 ,
q(∼empty cash box (l)) = 50 · l . 
We can prove by means of axioms ICC1–ICC5 that
Q(TM l0 ) = 50 · l0 .
That this equation agrees with our intuition can be seen like in the case of the equation Q(VM1 k0 ) = 50 k0 because TM l0 is essentially the same as VM1 l0 , but tokens are sold instead of cups of coffee.
We consider a user User3 buying one cup of coffee without additives and one cup of coffee with milk and without sugar:
User3 =
insert coin · ∼deliver token · insert coin · ∼deliver token ·
insert token · ∼deliver coffee(∅) ·
push button(milk ) · insert token · ∼deliver coffee({milk}) .
Using € 0.01 as the unit of payment, we take:
q(insert coin) = 50 , q(∼deliver token) = 0 , q(push button(milk )) = 0 , q(push button(sugar )) = 0 , q(insert token) = 0 ,
q(∼deliver coffee(as)) = 0 .
We can prove by means of axioms ICC1–ICC5 that
Q(User3 ) = 100 .
That this equation agrees with our intuition can be seen like in the case of the equation Q(User1 ) = 100 because User3 is essentially the same as User1 , but tokens are bought instead of cups of coffee and then exchanged for cups of coffee.
We look at the process described by ∂H3 (VM3 k0  TM l0  User3 ), where
H3 = {insert coin, ∼insert coin}
∪ {deliver token, ∼deliver token}
∪ {push button(a), ∼push button(a) | a ∈ {milk , sugar}}
∪ {insert token, ∼insert token}
∪ {deliver coffee(as), ∼deliver coffee(as) | as ⊆ {milk, sugar}} .

We can easily derive that in the case where k0 ≤ 398 and l0 ≤ 398:
∂H3 (VM3 k0   TM l0	User3 ) = 
insert coin · deliver token · insert coin · deliver token ·
insert token · deliver coffee(∅) ·  	
push button(milk ) · insert token · deliver coffee({milk}) ·
∂H3 (VM3 k0+2	TM l0+2)
From this, it follows easily that
Q(∂H3 (VM3 k0  TM l0  User3 )) = 50 · (l0 + 2)
in the case where k0 ≤ 398 and l0 ≤ 398. That this equation agrees with our intuition can be seen like in the case of the equation Q(∂H1 (VM1 k0  User1 )) = 50 · (k0 + 2). One additional remark is in order here: there are no interactions between VM3 k0 and TM l0 .


Example 4
Chipcards with an electronic wallet appear to provide an electronic pendant of tokens. The fourth example concerns a vending machine like the one from Sec- tion 10.3. The main difference is that it accepts this electronic pendant of tokens instead of tokens.
We take the view that, unlike tokens, the electronic pendant of tokens provided by a chipcard with an electronic wallet constitutes a form of money. The reason for this is that it is considered and used as money by a large group of people. The electronic payments are collected in an electronic cash-box. The value of the electronic money in the electronic cash-box is at most € 1000. Assuming that the value of the electronic money in the electronic wallet on a chipcard is at most € 100,
the vending machine, with the amount m0 of electronic money in the electronic cash-
box (m0  0,..., 100000 ), can be defined by the guarded recursive specification over ACPicc that consists of the following equations:

VM4 m0
= VM4 '	,
0

'
as,m
= ∼push button(milk ) · VM4 '
+ ∼push button(sugar ) · VM4 '

+ Σ ∼
as∪{sugar},m
insert chipcard (m') · return chipcard (m'
— 50)

m'∈M
· deliver coffee(as) · VM4 '

+ m'≥50
∅,m+50
'

∼empty ecash box (m) · VM4 ∅,0
(for every as ⊆ {milk, sugar} and m ∈ {0,..., 99950}) ,

'
∅,100000
= ∼empty ecash box (100000) · VM4 '	,

In this specification and forthcoming specifications, we write M for m	M 0 m	10000 . Using € 0.01 as the unit of payment, M is the set of possible values of the electronic money in the electronic wallet on a chipcard. Using € 0.01 as the

unit of payment, we take:
q(∼push button(milk )) = 0 , q(∼push button(sugar )) = 0 , q(∼insert chipcard (m)) =	m , q(return chipcard (m)) = m , q(deliver coffee(as)) = 0 , q(∼empty ecash box (m)) = m . 
We can prove by means of axioms ICC1–ICC5 that
Q(VM4 m0 ) = m0 .
That this equation agrees with our intuition can be seen like in the case of the equation Q(VM1 k0 ) = 50 k0. One additional remark is in order here: no money is needed for returning the chipcard because sufficient units of money have been acquired by the preceding chipcard insertion.
Electronic money is loaded into a chipcard by means of an electronic cash dis- penser. The value of the electronic money that can be loaded at a time is € 10. Moreover, no electronic money can be loaded if the balance of the bank account associated with the chipcard is less than € 10 or the value of the electronic money in the electronic wallet would exceed € 100 after loading.
Seeing that the behaviour of an electronic cash dispenser depends upon the balance of the bank accounts for which chipcards with an electronic wallet have been issued, the balance of all those accounts together make up a parameter of the electronic cash dispenser. We formalize this parameter using account numbers. We assume that a finite set N of account numbers has been given. N is considered to be the set of all account numbers of bank accounts for which chipcards with an electronic wallet have been issued. The parameter is formalized by a function
ba : N   M.  This function is considered to map each account number to the
balance of the bank account with that account number. We write BA for the set of all functions ba : N → M.
The electronic cash dispenser, parametrized by ba0  BA, can be defined by the guarded recursive specification over ACPicc that consists of the following equa- tions: 6

ECD ba0
ECD'
= ECD'	,
=	Σ
n∈N

Σ

m∈M

∼insert chipcard (n, m)

ba(n)≥1000 m+1000∈M
· return chipcard (m + 1000) · ECD'

+	Σ	Σ
n∈N	m∈M
∼insert chipcard (n, m)
· return chipcard (m) · ECD'

ba(nΣ)<1000 m+1Σ000∈M
ba
∼insert chipcard (n, m)

n∈N
m∈M m+1000/∈M
· return chipcard (m) · ECD'  .



6 We use the following notation for functions: [ ] for the empty function; [d '→ r] for the function f with dom(f )= {d} such that f (d)= r; f ⊕ g for the function h with dom(h)= dom(f ) ∪ dom(g) such that for all d ∈ dom(h), h(d)= f (d) if d /∈ dom(g) and h(d)= g(d) otherwise.

Using € 0.01 as the unit of payment, we take:
q(∼insert chipcard (n, m)) =	m , 
q(return chipcard (m)) = m . 
We can prove by means of axioms ICC1–ICC5 that
Q(ECD ba0 ) = 1000 · Σn∈N max{k | 1000 · k ≤ ba0(n)} .
This equation indicates that 1000 · Σn∈N max{k | 1000 · k ≤ ba0(n)} is the least amount of money that is needed to account for the behaviour of ECD ba0 . This is in
agreement with our intuition: money is needed only for returning a chipcard with more electronic money in the electronic wallet than on the preceding insertion of the chipcard, 1000 units of money are needed for that, and it can take place for every chipcard with an electronic wallet issued as many times as allowed by the balance of the associated bank account.
We consider a user User4 n0 (n0  N ), with an empty electronic wallet on his or
her chipcard, buying one cup of coffee without additives and one cup of coffee with milk and without sugar:
User4 n0 =
insert chipcard (n0, 0) · ∼return chipcard (1000) ·
insert chipcard (1000) · ∼return chipcard (950) · ∼deliver coffee(∅) ·
push button(milk ) ·
insert chipcard (950) · ∼return chipcard (900) · ∼deliver coffee({milk}) .
Using € 0.01 as the unit of payment, we take:
q(insert chipcard (n, m)) = m , q(∼return chipcard (m)) =	m , q(push button(milk )) = 0 , q(push button(sugar )) = 0 , q(insert chipcard (m)) = m , q(∼deliver coffee(as)) = 0 .
We can prove by means of axioms ICC1–ICC5 that
Q(User4 n0 ) = 0 .
This equation indicates that 0 is the least amount of money that is needed to account for the behaviour of User4 n0 . This is in agreement with our intuition: no money is needed for the first chipcard insertion because it concerns an empty electronic
wallet, and no money is needed for the second and third chipcard insertion because enough money has been acquired by the preceding chipcard return. Notice that User4 n0 would have an implicit computational capital greater than zero if he or she
would start with a non-empty electronic wallet.
We look at the process described by ∂H4 (VM4 m0  ECD ba0  User4 n0 ), where
H4 = {insert chipcard (n, m), ∼insert chipcard (n, m) | n ∈ N ∧ m ∈ M}
∪ {return chipcard (m), ∼return chipcard (m) | m ∈ M}
∪ {push button(a), ∼push button(a) | a ∈ {milk , sugar}}
∪ {insert chipcard (m), ∼insert chipcard (m) | m ∈ M}
∪ {deliver coffee(as), ∼deliver coffee(as) | as ⊆ {milk, sugar}} .

We can easily derive that in the case where ba0(n0) ≥ 1000:
∂H4 (VM4 m0	ECD ba0   User4 n0 ) = 
insert chipcard (n0, 0) · return chipcard (1000) ·
insert chipcard (1000) · return chipcard (950) · deliver coffee(∅) ·
push button(milk ) ·  	
insert chipcard (950) · return chipcard (900) · deliver coffee({milk}) ·
∂H4 (VM4 m0+100	ECD ba0⊕[n0'→ba0(n0)−1000]) .
From this, it follows easily that
Q(∂H4 (VM4 m0  ECD ba0  User4 n0 )) =

m0 + 100 + 1000 · Σ

n∈N
max{k | 1000 · k ≤ ba' (n)} ,

where ba' = ba0 ⊕ [n0 '→ ba0(n0) − 1000], in the case where ba0(n0) ≥ 1000. That
this equation agrees with our intuition can be seen like in the case of the equation Q(∂H1 (VM1 k0  User1 )) = 50 · (k0 + 2). One additional remark is in order here: there are no interactions between VM4 m0 and ECD ba0 .

Closing Remark on the Examples
Vending machines that are more realistic than the ones treated in the examples given above can easily be devised, e.g.:
vending machines where several products can be bought, and different products may have different prices;
vending machines where payments can be made by means of more than two kinds of coins;
vending machines where the products do not have to be paid one at a time;
vending machines where payments can be made using coins as well as electronic forms of money;
vending machines with a bounded stock of the products that can be bought;
vending machines with a user interface that incorporates features aimed at ease of operation.
We believe that additional examples concerning more realistic vending machines do not add to a better understanding of the notion of implicit computational capital of a process. A realistic vending machines might be the subject of a first case-study to assess the degree of usefulness of ACPicc in practical applications, but such a case study is considered outside the scope of this paper.

Conclusions
In this paper, we build on earlier work on ACP. The algebraic theory ACP was first presented in [3], abstraction from internal actions was added in [4], and RDP, RSP and AIP were first formulated in [5]. Transition systems as defined in this paper are basically the process graphs from early work on ACP, which are most extensively

described in [1]. The notion of transition system induced by a model of ACP was recently introduced in [6].
To the best of our knowledge, there is no related work. Many options for future work remain. We mention:
investigations into plausible mechanisms to model preferences in spending and acquiring computational money;
investigations into plausible mechanisms to reveal the implicit computational cap- ital of a process to other processes;
investigations into plausible mechanisms to transform some of the actions of in- finite processes that can perform CM-neutral actions only into non-CM-neutral actions in a way that prevents the resulting processes from becoming money sources;
investigations into decidability and computability issues concerning Q.
The work presented in this paper was carried out in the framework of a project investigating IT sourcing. In that project, we look at IT sourcing from the per- spective of formal methods. IT sourcing is mainly actuated by financial issues. We believe that the idea of processes with an implicit computational capital may be helpful to understand those financial issues.
Acknowledgement
We thank an anonymous referee for his/her helpful suggestions.

References
Baeten, J. C. M., J. A. Bergstra and J. W. Klop, On the consistency of Koomen’s fair abstraction rule, Theoretical Computer Science 51 (1987), pp. 129–176.
Baeten, J. C. M. and W. P. Weijland, “Process Algebra,” Cambridge Tracts in Theoretical Computer Science 18, Cambridge University Press, Cambridge, 1990.
Bergstra, J. A. and J. W. Klop, Process algebra for synchronous communication, Information and Control 60 (1984), pp. 109–137.
Bergstra, J. A. and J. W. Klop, Algebra of communicating processes with abstraction, Theoretical Computer Science 37 (1985), pp. 77–121.
Bergstra, J. A. and J. W. Klop, Process algebra: Specification and verification in bisimulation semantics, in: M. Hazewinkel, J. K. Lenstra and L. G. L. T. Meertens, editors, Proceedings Mathematics and Computer Science II, CWI Monograph 4 (1986), pp. 61–94.
Bergstra, J. A. and C. A. Middelburg, Model theory for process algebra, in: A. Middeldorp, V. van Oostrom, F. van Raamsdonk and R. C. de Vrijer, editors, Processes, Terms and Cycles: Steps on the Road to Infinity, Lecture Notes in Computer Science 3838 (2005), pp. 445–495.
Bergstra, J. A. and J. V. Tucker, Elementary algebraic specification of the rational complex numbers, in: K. Futatsugi et al., editors, Goguen Festschrift, Lecture Notes in Computer Science 4060 (2006),
pp. 459–475.
Hodges, W. A., “Model Theory,” Encyclopedia of Mathematics and Its Applications 42, Cambridge University Press, Cambridge, 1993.
Milner, R., “A Calculus of Communicating Systems,” Lecture Notes in Computer Science 92, Springer- Verlag, Berlin, 1980.

Milner, R., “Communication and Concurrency,” Prentice-Hall, Englewood Cliffs, 1989.
Sannella, D. and A. Tarlecki, Algebraic preliminaries, in: E. Astesiano, H.-J. Kreowski and B. Krieg- Bru¨ckner, editors, Algebraic Foundations of Systems Specification, Springer-Verlag, Berlin, 1999, pp. 13–30.
van Glabbeek, R. J. and W. P. Weijland, Branching time and abstraction in bisimulation semantics (extended abstract), in: G. X. Ritter, editor, Information Processing 89 (1989), pp. 613–618, see [13] for the full version.
van Glabbeek, R. J. and W. P. Weijland, Branching time and abstraction in bisimulation semantics, Journal of the ACM 43 (1996), pp. 555–600.
Wirsing, M., Algebraic specification, in: J. van Leeuwen, editor, Handbook of Theoretical Computer Science, B, Elsevier, Amsterdam, 1990, pp. 675–788.
