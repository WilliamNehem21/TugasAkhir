Electronic Notes in Theoretical Computer Science 72 (2007) 75–86	
www.elsevier.com/locate/entcs

Package Duplication in Interaction Nets and Weak Head Reduction in the lambda-calculus
Sylvain Lippi1
Institut de Math´ematiques de Luminy Marseille, France

Abstract
We present a simple implementation of weak head reduction in the λ-calculus with interaction nets using package duplication.
Keywords: Weak head reduction, interaction nets, lambda calculus


Introduction
Interaction nets introduced by Yves Lafont [5] can be considered as a programming language with a real interpreter [9] or as a graphical model of computation. In the second point view, a typical application is the encoding of optimal reduction for the λ-calculus [1]. Those translations are usually complicated giving quite complex nets during the reduction. We propose to focus on weak head reduction. The consequence is that we shift the problem to the duplication of some classes of nets: packages. We present two results on the duplication of packages: a negative one which sets the intrinsic limits of the interaction net paradigm and a positive one by exhibiting a very simple translation of λ-terms.

The interaction net paradigm
We present the interaction net paradigm in a practical way by introducing a simple example: the interaction combinators. For a more detailed presentation see [5].

1 lippi@iml.univ-mrs.fr

1571-0661 © 2007 Published by Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2002.09.006

Graphical syntax
The basic ingredient is a symbol with its arity. Our example system has three symbols: δ and γ of arity 2 and ε of arity 0.
Occurrences of symbols are called cells. Cells have one principal port and their number of auxiliary ports is given by the arity of their corresponding symbol. The γ-, δ- and ε-cells are pictured like this:
1	2	1	2
0
0	0
γ- and δ-cells have three ports: one principal port (0) and two auxiliary ports (1 and 2). ε-cells have only one (principal) port. For esthetic reasons, cells with no auxiliary port are pictured with a circle; the important point is to distinguish the principal port of a cell.
Convention. Auxiliary ports are not interchangeable. For instance, one can number them from 1 to n, keeping 0 for the principal port. In practice, the ports will always be implicitly numbered in clockwise order.

A net is a graph built with cells and free ports. Ports (principal ports, auxiliary ports or free ports) are connected pairwise by wires. An example of a net built with the combinators can be found in figure 1

A rule is a pair of nets (left member  right member ) with the same number of free ports. The important restriction is that the left member must be built with two cells connected by their principal ports; such a net is called a cut. 2 There is, at most, one rule for each pair of symbols. Figure 2 gives the rules for the combinators.
Execution
Once a set of symbols and rules has been fixed, we can apply one of those rules to a net obtaining another net and so on until we have reached an irreducible one. The reduction relation is denoted by  and its reflexive and transitive closure by ∗ . Here is an example of reduction where a net is duplicated by a δ-cell:

∗
	
δγ	δε

There may be several cuts in a net but the order in which they are eliminated does not matter. The reason is that two instances of a cut are necessarily disjoint,

2 if the two cells of the left member share the same symbol, there is also a symmetry condition on the right member (see [6]).

so we can apply the corresponding rules independently. All reduction strategies lead to the same irreducible net and have the same length (see [6]).
Proposition 2.1 (strong confluence) If a net μ reduces in one step to ν and ν', with ν /= ν', then ν and ν' reduce in one step to a common net ξ.
μ
ν	ν'
ξ

Proof The two instances of the left members are necessarily distinct so, we can apply the corresponding rules independently.	 
Corollary 2.2 (reduction) If a net μ reduces to an irreducible net ν in n steps, then any reduction starting from μ eventually reaches ν in n steps.

Package duplication
One of the most important features of the interaction net is that duplication must be explicitly described. To begin with, let us give the definition of three important classes of nets:
A tree is a net with one distinguished free port, called the root. It is either a single wire, in which case the root is fixed arbitrarily, or it is obtained by plugging the auxiliary ports of a cell to the root of smaller trees. In this case, the root is the free port which is connected to the principal port of this cell.
A wiring is a net built only with free ports and wires i.e with no cell.
Notation:  represents a bundle of parallel wires ( ... ).

A package is obtained by plugging a wiring ω with a tree τ as follows:

A typical situation is the duplication of packages. An example of implementation is given by the interaction combinators where the following proposition holds:
Proposition 3.1 (Package duplication and erasing) For any package π with- out any δ-cell:
∗	∗
	


Proof The proof relies on the decomposition of a package given above by induction on τ and ω. The detailed proof can be found in [6].	 

The restriction on the duplicated packages is quite important for duplication. In fact, it is not due to the system of the combinators; it is an intrinsic limitation of the interaction nets.
Proposition 3.2 There is no interaction system containing a symbol δ such that for any package π:
∗




Proof.
Let us suppose we have such a system and consider the following rule:

where ν is a reduced net invariant by rotation. In particular, we have:
∗
	


If	=	,
The wire that connect two free ports of ν can be identified to each of the four wires of the right member, with two possible orientations in each case. So there are eight cases:


·	=
impossible since ν is invariant by rotation.




·	=
idem.




·	=
impossible: we just have to consider the duplication of an-


other package built with δ-cells.


·	=
impossible since ν is invariant by rotation.


The four other cases are similar.

+
Otherwise,		.
So there is (at least) one cut in the net of the left hand side: the two free ports of “the upper part” of ν are connected with principal ports.
Since ν is invariant by rotation the two free ports of “the lower part” of ν are connected with principal ports of cells having the same symbols. So we have a reduced net μ that is invariant by rotation such that:

=


Thus,


=	+


So, α = β = δ and we have the following reduction:






=
δδ
∗	(1)





· If μ is a wiring: Let us consider the two nets of the right hand side in reduction
1. Obviously, they are not equal since they do not have the same number of cells. So, the last reduction takes at least one step and its left member contains at least one cut. Thus, there is (at least) two ports of “the upper part” of μ that are connected together. μ is invariant by rotation, so there is a wiring ω such that:
=	impossible: we just have to consider the duplication of another package built with δ-cells.
=	idem




=
impossible because of reduction 1.



The three other cases are similar to the previous one.
· Otherwise, μ is a reduced net with at least one cell. So it exists a free port connected to a principal port. Moreover, μ is invariant by rotation, so there is a symbol γ and a net ϕ such that, for example:

=

Because of 1, we have:


∗







this is impossible.


Weak head reduction
We show that a “na¨ıve” translation of λ-terms into interaction nets is well-adapted for weak head reduction [3]. Whereas other translations such as [7,2,11,8] need auxiliary symbols to tackle with the so-called bureaucratie, we just introduce a set of four symbols (@, λ, δ and ε). Further more, each λ-term has a unique translation consequently, the correctness proof is much simpler. On the other hand, we just give an implementation of weak head reduction.

Notation: λ-terms (denoted by u, v, w, t, t1, t2,.. .) are written with the Krivine notation: x, y, z, x1, x2,... are variables, (u)v is the application of u to v and λxu is a λ-abstraction.
Let us call process a pair (t, π) composed of a λ-term t and a stack π of closed
λ-terms. We define weak head reduction on processes (noted > ) by:

(u)v, π > u, v · π	(2)


λxu, v · π > u[v/x]	(3)


Translations
The translation that is given below is the same as the one into sharing graphs [1] except that special symbols such as croissants or brackets are omitted. Intuitively, the translation of a λ-term can be obtained from its syntactic tree by connecting occurrences of variables directly to their corresponding λ. The translation of a λ-term t is represented by:
x1	xÆ
... 


where the unique free port at the bottom corresponds to the root of the λ-term and each free port at the top corresponds to an occurrence of a free variable. Those free ports are grouped into bundles corresponding to variable names. Let us define the translation of a λ-term t by induction on t:
A variable xi is simply translated by a single wire.
(u)v is translated by introducing a binary cell: @. The auxiliary ports of @ respectively connected to the translations of u and v.
λxu is translated by connecting the translation of u to the first auxiliary port of a binary λ-cell. The second auxiliary port of λ is connected to the ports corresponding to free occurrences of x in u. At this point, we must introduce a new binary cell δ called duplicator. Indeed, there may be more than one occurrence of x in u and free ports are connected pairwise, so we “gather” the occurrences of x with a tree built with duplicators and connect the root to the second auxiliary port of the λ-cell. In case there is no free occurrence of x, the second auxiliary port of λ is connected to a cell ε of arity zero.
The translation of a λ-term is summed up in figure 3. Δ represents a generalized duplicator i.e a tree built with δ-cells as defined in figure 4.
Remark 4.1 A tree built with δ- and ε-cells is not necessarily a generalized dupli- cator. A generalized duplicator of arity n is a comb built with n δ-cells and one ε-cell. We shall se how to use this restriction to duplicate a package containing duplicators.
The translation of a stack π of λ-terms (noted	) is inductively defined by:

The translation of the empty stack is






Figure 2. Interaction rules for the combinators

Figure 3. Translation of a λ-term


The translation of t · π is


Finally a process (t, π) is translated by

Duplication and erasing of a λ-term
During reduction, some λ-terms are duplicated or erased. The translation of a closed λ-term is a package that contains duplicators. According to proposition 3.2, we can think that our translation is not well-designed. On the other side, we do not have to implement duplication for any packages but only for packages that are translations of a λ-term. So, we can take advantage of the geometry of a translation. In particular, the principal port of a δ-cell is connected to the second auxiliary port of a λ- or δ-cell and nowhere else.
Consequently, we introduce a binary symbol γ dedicated to the duplication of δ-cells. According to the previous remark, γ-cells appear when an abstraction is duplicated ; the λ-cell is duplicated and then the body of the abstraction is duplicated by a δ-cell whereas the linker part is duplicated by a γ-cell. The δ-cell is duplicated by a γ-cell ; the first auxiliary port of a δ-cell is not connected to the principal port of a δ-cell whereas the second one is. The rules δ@ and δδ are the usual commutations and annihilation rules (see [6]) and correspond respectively to the duplication of an @-cell and of a link between two auxiliary ports. The set of duplication rules is summed up in figure 5.
Finally, the rest of the rules are devoted to the ε-cell and can be summed up by the following scheme of rules:

where x ∈ {@, λ, δ, γ}
Remark 4.2 The εγ rule can be interpreted both as the duplication of ε-cells or as the erasing of a γ-cell.
Remark 4.3 These erasing rules correspond to garbage collection. A reduction can be done even if they are omitted from the system; the consequence is simply a “waste of cells” (see [10] for a precise formulation).

Weak head reduction
Rule a@ corresponds to equation 2: the argument of an application is pushed on the stack. Rule aλ corresponds to equation 3: the linker part of the abstraction is

connected to the λ-term on the top of the stack and the body of the abstraction to the rest of the stack. Those rules are grouped in figure 6 and an example of reduction can be found in figure 7.
The correctness of the implementation is stated by the following proposition:
Proposition 4.4 For any processes p and p' if p > p' then,
∗


Proof We have the analog of proposition 3.1 since the translation of a λ-term is a package. The only difference is that δ-rules have been slightly modified since a translation may contain δ-rules.	 






=


Figure 4. Generalized duplicators



Figure 5. Duplication rules


Figure 6. Weak head reduction rules




a@	aλ	∗
	







Figure 7. First steps of the reduction for (λx (x)x)2

References
Andrea Asperti and Stefano Guerrini. The Optimal Implementation of Functional Programming Languages, volume 45 of Cambridge Tracts in Theoretical Computer Science. Cambridge University Press, 1998.
M. Abadi G. Gonthier and J.-J. L´evy. The geometry of optimal lambda reduction. In proceedings of the 19th Annnual ACM Symposium on Principles of Programming Languages (POPL’92), ACM Press., pages 15–26, 1992.
J.-L. Krivine. Lambda-calculus, types and models. Ellis Horwood Series in Computers and their Applications., 1993. Transl. from the French by Ren´e Cori. (English).
Y. Lafont. Interaction nets. In proceedings of the 17th Annnual ACM Symposium on Principles of Programming Languages, Orlando (Fla., USA), pages 95–108, 1990.
Y. Lafont. From proof-nets to interaction nets. In Advances in Linear Logic, London Mathematical Society Lecture Note Series 222. Cambridge University Press, 1995.
Y. Lafont. Interaction combinators. Information and Computation, 137(1):69–101, 1997.
J. Lamping. An algorithm for optimal lambda-calculus reduction. In proceedings of the 17th Annnual ACM Symposium on Principles of Programming Languages, Orlando (Fla., USA), 1990.
Sylvain Lippi. Encoding left reduction in the lambda-calculus with interaction nets. Mathematical Structures in Computer Science, 12:1–26, 2002.
Sylvain Lippi. in2: a graphical interpreter for the interaction nets. In Proceedings of Rewriting Techniques and Applications (RTA ’02). Springer Verlag, 2002.
Sylvain Lippi. Th´eorie et pratique des r´eseaux d’interaction. PhD thesis, Universit´e de la m´editerran´ee, 2002.
I. Mackie. The geometry of implementation. PhD thesis, Department of Computing, Imperial College of Science, Technology and Medicine, 1994.
