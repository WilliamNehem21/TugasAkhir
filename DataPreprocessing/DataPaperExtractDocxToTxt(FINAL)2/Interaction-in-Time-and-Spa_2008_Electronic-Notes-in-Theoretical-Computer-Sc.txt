Electronic Notes in Theoretical Computer Science 203 (2008) 5–18	
www.elsevier.com/locate/entcs
Interaction in Time and Space
Gabriel Ciobanu1
Faculty of Computer Science “A.I.Cuza” University
Ia¸si, Romania

Abstract
Distributed π-calculus and ambient calculus are extended with timers which may trigger timeout recovery processes. Timers provide a useful notion of relative time with respect to the interaction in a distributed system. The rather flat notion of space in timed distributed π-calculus is improved by considering a hierarchical representation of space in timed mobile ambients. Some basic results are proven, making sound both formal approaches. An easily understood example is used for both extensions, showing how it is possible to describe a non-monotonic behaviour and use a decentralized control to coordinate the interacting components in time and space.
Keywords: timed distributed π-calculus, timed mobile ambients, interaction

Introduction
We refer to systems with a large number of interacting processes located at different sites which can migrate from one location to another. In order to manage the large nondeterminism of interaction, we add new quantitative ingredients restricting the interaction between processes.
Concurrent processes may overlap in time during their computation, and thus time represents an important aspect of concurrency. Distribution occurs when the system components are separated in space, and thus space represents an impor- tant aspect of distribution. We present two formalisms (called timed distributed π-calculus and timed mobile ambients, respectively) where explicit notions of lo- cation, timers, capacity, and other ingredients are used to control interaction and mobility in distributed systems. Explicit timeout of interactions and other quanti- tative elements can define a non-monotonic behaviour; for instance, when a timer expires, it may trigger a timeout recovery processes. Several challenges related to these systems include the specification of global behaviour and how local descrip- tions lead to such a global behaviour, mechanisms and techniques of coordination

1 Email: gabriel@info.uaic.ro

1571-0661 © 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.04.083

based on the restriction of the nondeterminism, a decentralized control taking into account the relative time of interaction and other quantitative aspects. When we work with a large number of processes, the global behaviour could represent more than the sum of parts behaviour, certain emergent behaviour being possible.
We work with local clocks, considering the relative time of interaction given by timers. The decreasing of a timer measures the relative time, and this procedure is uniform (it is similar for each local clock). The timers define the available resources; the resources are accessed by interaction according to the interval of time given by timers. Using such a time control, we can restrict the nondeterminism of the evolution by selecting only the processes ready to interact according to their timers and satisfying certain quantitative requirements.
Throughout this paper we consider the following example which can motivate and illustrate our approach. We assume the situation of a student finishing his lectures, moving out the university building and looking for an available vehicle in order to move to a given place. In front of the university there are a tram stop, a bus stop, and taxicabs. The student has the possibility to use any of the three types of vehicles: bus, tram and cab to reach the target location. Since the three variants (vehicles) have different costs, the student can establish a priority among them: the bus has the highest priority, followed by the tram, and finally the cab. The bus and the tram are moving according to a predetermined schedule which is evolving according to their own clocks. Our scenario involves a bus, a tram and two cabs (a hired cab and an available cab).
Interaction in time is associated with the ability to specify a starting and an ending point providing the availability of a resource. Interaction in space relates to the ability to identify a specific location in which a required and available resource exists. We use extensions with timers of both timed distributed π-calculus and timed mobile ambients.

Timed Distributed π-calculus
Distributed π-calculus (Dπ) as an extension with types and locations of the π- calculus [7]. Dπ is presented in [6], and provides a theoretical framework for de- scribing communications between distributed processes with restricted resource ac- cess. In [4] we extend the distributed π-calculus by introducing timers over channel names in order to define timeouts for communications. The resulting formalism is called timed distributed π-calculus (tDπ). Over this formalism it is possible to define a coordination of the whole system by assigning specific values to timers and defining a set of time constraints [5].
In tDπ, waiting for a communication on a channel is no longer indefinite (like in Dπ); if no communication happens in a predefined interval of time, the waiting process goes to another state. This approach leads to a method of sharing the channels in time. The timer Δt of each channel makes the channel available for communication only for the period of time determined by the discrete value t. To simplify our presentation we choose a simpler π-calculus and omit the syntax for

matching or summation. A communication channel is considered a fixed resource at a certain location.
The syntax of Input and Output communication uses a pair of processes. For instance, an Input expression aΔt?(X : T ).(P, Q) evolves to P whenever a commu-
nication is established during the interval of time given by Δt; otherwise it evolves to Q. The variable X is considered bound only in P and we should provide its type T; the type system is presented in [4].

Table 1: Syntax of timed distributed π-calculus

u ::= x
| aΔt l ::= x
| k
v ::= bv
| u | l
| u@l
| (v1,..,vn)
X::= x
| X@l
Variable Name Timed Channel Variable Name Location Name Base Value Name
Located Name Tuple of Values Variable Located Variable
P , Q ::= stop
| P | Q
| (ν u : A)P
| go l.(P, Q)
| u!⟨v⟩.(P, Q)
| u?(X : T ).(P, Q)
| ∗P
M , N ::= M | N
| (ν u@l : T )N
| l[[P ]]Γ
Termination Composition Channel Restriction Movement
Output Input Replication Composition
Located Restriction Located Process

| (X1,..,Xn) Tuple of Variables
Two channels are equal aΔt1 = aΔt2 if and only if a1 = a2 and t1 = t2. Waiting
1	2
indefinitely on a channel a is allowed by considering Δt as ∞. For example, an output process defined by the expression a∞!⟨v⟩.(P, Q) awaits forever to send the value v, simulating the behaviour of an output process in untimed π-calculus. In the expression below, two processes are running in parallel and can interact along the common channel a:
aΔt!⟨v⟩.(P, Q) | aΔt' ?(X : T ).(P ', Q') −→ P | P'{v/  }
We define a type environment Γ as a set of location types. The purpose of the type environment associated with a specific process is to restrict the range of resources the process can access. Formally, Γ ⊆ L × K is a relation associating to a location name a location type. A location type is a set of location capabilities which may contain channel types, move capability (i.e., permission to migrate to that location), or channel creation capability (i.e., permission to create channels).
We extend the channel types of Dπ with timers of the form Δt. Communica- tion is now permitted on channels only in the interval of time given by the timer value t (i.e. until the timer of the channel type expires). These timers define the existence of the channel types inside the type environment. Timers decrease with each ”tick” of their local clock, and this decreasing process is the same for each clock. Upon expiration, the channel types are discarded. Timers are created at once with the channel types, and are activated when the types are added to the type environment. When the processes receive new channel names, types for the new channels become available. It means that the processes can communicate on the new channels according to the new types. For example, if a process receives through an input channel a located name a@k, then it gains the capability to move to location k, and to communicate on channel a.
We define a function ψ which affects only the set of capabilities. It decreases

the timers of the channel types and removes the types with an expired timer. By removing channel types, it is possible to get location types with only go capability (we call them empty locations). A process can move to an empty location, but there it does not have the capability to perform any action, and consequently produces a runtime error. Thus ψ removes also the empty locations.
The passage of time is formalized by a time-stepping function φΔ defined over the set PΔ of tagged located processes. The possible communications are performed at each tick of the local clock, and the active channels are those that could be involved in these communications. φΔ affects the active channels which do not communicate (the channels involved in communication disappear together with their timers). Due to timers, the capabilities can be lost, which leads to ”errors”. We define φΔ to check the existence of the needed types and change the process accordingly.
Definition 2.1 (Tagged time-stepping function)
We define φΔ : PΔ → PΔ, where Γ' is obtained by application of the cleanup function ψ. Note that we use a concise notation aΔt.(R, Q) to stand for both aΔt!⟨v⟩.(R, Q) and aΔt?(X : T ).(R, Q).
8k[[R]]Γ'	if P = go k.(R, Q) and Γ(k) <: loc{go}
l[[Q]]Γ'	if P = go k.(R, Q) and k /∈ dom(Γ) l[[aΔ(t−1).(R, Q)]]Γ'	if P = aΔt.(R, Q), t > 1 and t/= ∞
><l[[Q]]Γ'	if P = aΔt.(R, Q), t ≤ 1

φΔ(l[[P ]]Γ)= 
l[[Q]]Γ'	if P = aΔt
>
.(R, Q), t > 1 and Γ≮: Γ(l, a)

φΔ(l[[R]]Γ) | φΔ(l[[Q]]Γ)	if P = R | Q
(νa@l : A)φΔ(l[[R]]Γ{a@l:A})if P = (νa : A)R l[[P ]]Γ'	otherwise
As φΔ decreases the channel timers, we extend it to take care of the type en- vironments (by applying the cleanup function ψ). In the definition of φΔ we omit the channel type and the transmitted message in the input and output processes for brevity. For the go k syntax if the location type contains the capability go, then R is executed; if k is not defined in Γ, then Q is executed. If go is not present, the process is considered to do something against its permissions and an error is generated.
Well-typedness of processes is defined by a set of static rules (a detailed presen- tation of the static typing rules is given in [4]). These rules express the behaviour of a process with regard to its types. If a process tries to communicate on a channel for which it has no capability, it can still be well-typed if the alternative process Q is well-typed. Q is called the safety process.
We write Γ ▶ P and say that process P is well-typed with respect to type environ- ment Γ; we also write Γ ▶k P and say that P is well-typed to run at location k. To say that P = aΔt!⟨v⟩.(R, Q) is well-typed to run at location k, with respect to type environment Γ, the following statements should hold: (i) Γ ▶k v : T which means that v is a well-formed value at location k of type T ; (ii) Γ ▶k a : res{w⟨T⟩}Δt which means that channel a exists at location k and may communicate values of type T for another t units of time; (iii) Γ ▶k R; Γ ▶k Q which means that R and Q are well-typed at location k. For a tagged located process k[[P ]]Δ, the well-typedness relation is denoted by H, and it is defined by using the well-typedness relation ▶k

for a process P running at location k.
Since the function ψ changes the capability set Γ by removing channel and location types, we are interested if the process is still well-typed under the new Γ'. The following lemma relates the typing environment of the processes with the passage of time.

Lemma 2.2 (Well-typedness is preserved by the cleanup function)
If Γ H l[[P ]]Δ then Γ H ψ(l[[P ]]Δ).

We consider the tagged located processes ranged over by N and M (e.g., N represents l[[P ]]Γ). We denote by /→ the fact that rules (RΓ-COM1) and (RΓ- COM2) cannot be applied. Using these notations, we give the following reduction rules providing a dynamic semantics for tDπ.
l[[P ]]Γ /→

(RΓ-IDLE)


l[[P ]]Γ → φΔ(l[[P ]]Γ)

Γ(l, a) <: res{r⟨T ⟩}
(RΓ-COM1) l[[aΔt!⟨v⟩.(P, Q)]] | l[[aΔt' ?(X : T ).(P ', Q')]] →
ψ(l[[P ]]Δ) | ψ(l[[P'{v/X}]]ΓH{v@l:T })
Γ(l, a) <: res{ro⟨T ⟩}
(RΓ-COM2) l[[aΔt!⟨v⟩.(P, Q)]] | l[[aΔt' ?(X : T ).(P ', Q')]] →




(R -PAR)
ψ(l[[P ]]Δ) | ψ(l[[P'{v/X}]]Γ)
N → N'	M → M'	'
N | M → N' | M'	(R -RES)	N → N


Γ	Γ	(νa@l : T )N → (νa@l : T )N'


(RΓ-CONG)
N ≡ N'	N → M	M ≡ M'


N' → M'

Several results are presented in [4]; here we mention two of them claiming that the passage of time does not interfere with the typing system, and that once well- typed, a process remains well-typed (subject reduction).

Proposition 2.3	If Γ H l[[P ]]Δ then Γ H φΔ(l[[P ]]Δ).

Theorem 2.4 (Subject Reduction)
For all tagged located processes
If N ≡ N' then Γ H N if and only if Γ H N'.
If N → N' then Γ H N if and only if Γ H N'.

We describe the evolution of a system in timed distributed π-calculus by con- sidering the example in which a student intends to move from university to another location. This migration involves a bus, a tram and two cabs. The scenario could be described as follows:

inuniv = busΔt1 !⟨studuniv⟩.busΔt2 ?(i).inuniv
univ	univ
incamp = busΔt3 ?(i).busΔt4 !⟨studcamp⟩.incamp

bus = busΔt5 ?(i).go camp.busΔt6
!⟨stud1⟩.busΔt7
?(i).go univ.

univ
busΔt8 !⟨stud2⟩.bus
camp
camp

system = camp[[incamp]] | univ[[inuniv | bus]] where
stud1 - the number of students that get out of bus in camp
stud2 - the number of students that get out of bus in univ studuniv - the number of students that get into bus in univ studcamp - the number of students that get into bus in camp
Using bold letters to emphasize the interacting elements, a possible evolution of the system is given by
system = camp[[incamp]] | univ[[inuniv | bus]] =
= camp[[incamp]] | univ[[busΔt1 !⟨studuniv⟩.busΔt2 ?(i).inuniv | busΔt5 ?(i).

univ
univ
univ

go camp.busΔt6
!⟨stud1⟩.busΔt7
?(i).go univ.busΔt8 !⟨stud2⟩.bus]]

→ camp[[busΔt3
?(i).busΔt4
!⟨studcamp⟩.incamp]] | univ[[busΔt2 ?(i).inuniv|

go camp.busΔt6
!⟨stud1⟩.busΔt7
?(i).go univ.busΔt8 !⟨stud2⟩.bus]]

→ camp[[busΔt3
?(i).busΔt4
!⟨studcamp⟩.incamp | busΔt6
!⟨stud1⟩.

busΔt7 ?(i).go univ.busΔt8 !⟨stud2⟩.bus]] | univ[[busΔt2 ?(i).inuniv]]

camp
→ camp[[busΔt4
univ
!⟨studcamp⟩.incamp |
univ

busΔt7 ?(i).go univ.busΔt8 !⟨stud2⟩.bus]] | univ[[busΔt2 ?(i).inuniv]]

camp
univ
univ

→ camp[[incamp| go univ.busΔt8 !⟨stud2⟩.bus]] | univ[[busΔt2 ?(i).inuniv]]
univ	univ
→ camp[[incamp]] | univ[[busΔt2 ?(i).inuniv | busΔt8 !⟨stud2⟩.bus]]
univ	univ
→ camp[[incamp]] | univ[[inuniv | bus]] = system
A problem which appears in this description is the fact that the information ex- changed in the interaction of the system components are lost. There is no way to remember the number of persons inside the bus, or the number of the persons who entered or exited the bus at each stop.
We can remark that the notion of space (location) used in tDπ is flat. A more realistic account of physical distribution is obtained using a hierarchical represen- tation of space (locality) as in the ambient calculus [3].

Mobile Ambients with Time Constraints
Ambient calculus [3] is a formalism for describing distributed and mobile compu- tation in terms of ambients. An ambient is both a named location and the unit of movement. The mobility of an ambient is controlled by the capabilities in, out,

and open. In an ambient we have processes which may exchange messages. In [2] we introduce timed Mobile Ambients (tMA) where communication actions, capa- bilities and ambients are used as temporal resources. We add timers to ambients, capabilities, input and output actions. A timer Δt of each temporal resource makes the resource available only for a determined period of time t. Here we ignore the types, emphasizing how the interaction between ambients depends on timers and space proximity. A related approach is presented in [1].
We imagine large populations of interacting processes defining an interaction field. This means that we embed the viewpoint of interaction as a pair (action, reac- tion) into an interaction field where emergence properties and non-compositionality could play important roles. Since we do not know how to describe/specify this kind of interaction field, we use a notion of proximity expressing the fact that the inter- action between pairs of processes depend on a dynamically changing topology given by the whole interaction field. A possible example could be the flocking behaviour given by the formation of flocks by birds and their evolution. In order to emphasize the spatial nature of interaction in the framework of an interaction fields, we denote by p(n, r) the area of (inter)action of an ambient n; it depends on the radius of (inter)action r it has at a certain time.
We denote by nΔt	[P ] the fact that an ambient n has assigned a timer Δt, a 
capacity l representing the number of its free resources, a weight h representing the number of resources allocated in the parent ambient, and a radius r of its spatial proximity. If t > 0 the ambient behaves exactly as in untimed ambient calculus.
Since the timer Δt can expire (t = 0), we use a pair (nΔt	[P ],k  Q) to denote a
timed ambient, where Q is a safety process. The prefix k  represents the number of
resources needed by process Q to be executed. If a process k  Q does not have at least k free resources, Q cannot be executed and awaits until the required resources are available. If nothing happens in t units of time, the ambient n is dissolved, process P running inside the ambient is reduced to 0, and process k Q | ♦h is executed. h represents the total weight of the dissolved ambient; by ♦h we denote that h resources become available in the parent ambient of the dissolved ambient n.

If Q = 0 we can simply write nΔt
[P ] instead of (nΔt
[P ],k  Q). The behaviour

of an untimed mobile ambient is given by using ∞ instead of Δt, and 0 instead of h, k, l and r. We use a pair of processes for the input, output and movement processes. The process openΔtn.(P, k  Q) evolves to P whenever in time Δt the
process becomes sibling to an ambient n; otherwise evolves to k  Q. The process
!⟨m⟩Δt.(P, k  Q) evolves to P whenever in time Δt the process becomes sibling to a process which is willing to capture the name m; otherwise evolves to k Q. The syntax of the timed Mobile Ambients is defined in the following table.



We define various technical ingredients, e.g, a function weight which counts the resources needed by a process to be executed. Timed Mobile Ambients use a discrete time. The passage of time is described by a (discrete) time-stepping function φΔ defined over the set P of tMA-processes in a similar way as in tDπ. The local communication (given by the interaction between !⟨m⟩Δt.(P, Q) and ?(x)Δt.(R, k Q) inside the same ambient) does not consume time, so it is not included in the definition of φΔ. This function is used in the definition of the reduction rules.
The semantics of the timed mobile ambients is given by two relations: structural proximity relation and reduction relation. Structural proximity relation P ≡p Q relates different syntactic representations of the same process; reduction relation P → Q describes the evolution of processes.
Processes are grouped into equivalence classes by ≡p. This relation provides a way of re-arranging expressions such that the interacting parts can be brought together. The structural relation ≡p over the timed mobile processes is the least relation satisfying the following requirements:
Table 3: Structural proximity congruence

(S-Refl)	P ≡p P	(S-Sym) P ≡p Q implies Q ≡p P
(S-Trans)	P ≡p R, R ≡p Q implies P ≡p Q (S-Res)	P ≡p Q implies (νn)P ≡p (νn)Q (S-LPar)	P ≡p Q implies R | P ≡p R | Q (S-RPar)	P ≡p Q implies P | R ≡p Q | R
(S-Repl)	P ≡p Q implies ∗(k Q P ) ≡p ∗(k Q Q)

(S-Amb)	P ≡p Q and R ≡p R' implies (nΔt
[P ],k Q R) ≡p (nΔt
[Q],k Q R')

(S-Cap)	P ≡p Q and R ≡p R' implies M Δt.(P, k Q R) ≡p M Δt.(Q, k Q R')
(S-Par Com) if weight(P ) = 0 then P | Q ≡p Q | P
(S-Par Assoc) (P | Q) | R ≡p P | (Q | R)
(S-Repl Par) ∗(k Q P ) ≡p k Q P | ∗ (k Q P )
(S-Res Res)  (νn)(νm)P ≡p (νm)(νn)P if n /= m
(S-Res LPar) (νn)(P | Q) ≡p P | (νn)Q if (n) ∈/ fn(P )
(S-Res RPar) (νn)(P | Q) ≡p (νn)P | Q if (n) ∈/ fn(Q)

(S-Res Amb) (νn)(mΔt
[P ],k Q Q) ≡p (mΔt
[(νn)P ],k Q Q) if n /= m

(S-Zero Par) P | 0 ≡p P (S-Zero Res) (νn)0 ≡p 0 (S-Zero Repl) ∗0 ≡p 0
Proposition 3.1 If P ≡p Q then weight(P ) = weight(Q).
The timers of P in processes M Δt.(P, Q), !⟨m⟩Δt.(P, Q) and ?(x)Δt.(P, Q) are activated only after the consumption of M Δt, !⟨m⟩Δt, and ?(x)Δt, respectively. We denote by /→ the fact that rules (R-Free), (R-Alloc), (R-In), (R-Out), (R-Open) and

(R-Com) cannot be applied. The behaviour of processes is given by the reduction rules of Table 4.
Table 4: Reduction Rules

P /→

(R-Idle)


P → φΔ(P )
—

(R-Free)
(nΔt
[R | ♦ ], k' Q Q) → (nΔt
[ R ], k' Q Q)

(l,h,r)
k
k ≤ l
(l+k,h,r)

(R-Alloc)
Δt (l,h,r)
[k Q Q], R) → (nΔt
h' ≤ (l−k,h,r)
[Q], R)
∈ p(n, r )

(R-In)
(nΔt'
l'', r' ≤ r'', m	'
[inΔtm.(P, P') | Q], k' Q S') | (mΔt''
[R], k'' Q S'') →

(l',h',r' )
Δt''     (l'' −h',h'',r'' )
Δt' (l',h',r' )
(l'',h'',r'' )
[P | Q], k' Q S') | R], k'' Q S'')

h'' ≤ l, p(n, r'') ∩ p(m, r') /= ∅

(R-OuΔt)t
Δt'
Δt''
Δt	'
''	''	'	'

(k(l,h,r)[(m(l',h',r' )[(n(l'',h'',r'' )[out
m.(P, P ) | Q],k 
Q S ) | R],k Q S )],k Q S) →

(kΔt
[(nΔt''
[P | Q], k'' Q S'') | (mΔt'
[R], k' Q S')],k Q S)

(l−h'',h,r)
(l'',h'',r'' )
—	(l' +h'',h',r' )

(R-Open)
Δt' (l',h',r' )
[openΔtn. (P, P') | (nΔt''
[Q], k'' Q S'')], k' Q S') →

Δt'    (l' +l'',h',r' )
—
[P | Q], k' Q S')

(R-Com)


!⟨m⟩Δt.(P, Q) | ?(x)Δt' .(P ', Q') → P | P'{m/x}
P → Q

(R-Amb)
Δt (l,h,r)
[P ],k Q R) → (nΔt
[Q],k Q R)

(R-LPar)
P → Q


R | P → R | Q
P → Q, P' → Q'
(R-RPar)
P → Q
P | R → Q | R P → Q

(R-Par)

(R-Sum)
P | P' → Q | Q'	(R-Res)
P → P'
P + Q → P' + Q	(R-Struct)
(νn)P → (νn)Q
P' ≡p P, P → Q, Q ≡p Q' P' → Q'


The function φΔ decreases the timers, and for expired timers it discards the actions, capabilities and ambients. If one process evolves by one of the rules (R-In), (R-Out), (R-Open) and (R-Amb), while another one does not perform any reduction, then one of the rules (R-LPar), (R-RPar) should be applied. If more than one process evolve in parallel by applying one of the rules (R-In), (R-Out), (R-Open) and (R-Amb), then rule (R-Par) should be applied. When all the ambients become passive, the rule (R-Idle) is applied to simulate the passage of time, and so permitting the ambients to participate in other reductions in the next unit of time.
The resources are preserved through reduction only in a closed system, namely a system which is surrounded by an ambient which cannot be opened, and any ambient can pass through it. In an open system, the resources are not preserved through reduction because a process may acquire new resources from the environment, or transfer resources to the environment. Some resources may become restricted, and
so unavailable for any other process, e.g. (νn)(nΔt	[P ],k  Q).

We denote by P
φΔ
−→t Q
the fact that P evolves to Q after applying the rule

(R-Idle) for t ≥ 0 times, and with tφΔ(R) the fact that function φΔ is applied t
times to R. The passage of time cannot cause a nondeterministic behaviour.


Proposition 3.2 If P ≡p Q,
φΔ
P −→t P
' and
φΔ
Q −→t Q
' then P ' ≡p
Q'.

We can define several bisimulations in tMA, and some of them can require to match the timing aspects. Some bisimulations in tMA are presented in [2].

Interaction in Timed Mobile Ambients
We consider the example of an ambient student using any of the three trans- port ambients bus, tram and cab to reach a given location. Each of these enti- ties is encoded in an ambient having the corresponding label. For an ambient A, free resources(A) represents the (dynamically evolving) capacity l of A. If bus is in the proximity of radius r of the student (bus ∈ p(student, r)), and it has free resources (free resource(bus) > 0) then the student enters the bus. If the bus does not have free resources and the tram is in the proximity of radius r of the student, and it has free resources (free resources(tram) > 0) then the student enters the tram. If the tram does not have free resources and the cab is in the proximity of the student, and it has free resources (free resources(cab) > 0) then the student enters the cab. If the tram is not in the proximity of the student, the time needed for the tram to enter that proximity is greater that the time the student decided to wait for the tram, the cab is in the proximity of the student and it has free resources free resources(cab) > 0, then the student enters the cab.
If bus is not in the proximity of student, the time needed for the bus to enter that proximity is greater than the time the student decided to wait for the bus, the tram is in the proximity of radius r of the student and it has free resources (free resource(tram) > 0) then the student enters the tram. If the tram does not have free resources and the cab is in the proximity of radius r of the student and it has free resources (free resources(cab) > 0), then the student enter the cab. If the tram is not in the proximity of the student, the time needed for the tram to enter that proximity is greater that the time the student decided to wait for the tram, then the student searches for a cab; if the cab is in the proximity of the student and it has free resources free resources(cab) > 0, then the student enters the cab. If none of the above conditions holds, the time-stepping function
φΔ is applied (simulating the passing of time), and then the above conditions are
re-checked.
For this scenario the bus ambient can be described as:
bus schedule	=	inΔt1 univ.outΔt2 univ.inΔt3 camp.outΔt2 camp.bus schedule

∞
(l bus,h bus,r bus)
[bus schedule]

where
Δt1 - time the bus ambient needs to reach the univ starting from camp;
Δt2 - time the bus ambient awaits at a stop;
Δt3 - time the bus ambient needs to reach the ambient camp;
l bus - the free resources of the bus ambient;
h bus - the capacity of the bus ambient;
r bus - the proximity radius of the bus ambient.

Similarly, the tram ambient can be described as follows:
tram schedule	=	inΔt4 univ.outΔt5 univ.inΔt6 camp.outΔt5 camp.tram schedule

∞
(l tram,h tram,r tram)
[tram schedule]

The cab and the client can be described as in [9]; since our example contains only two locations, the description can be simplified. The cab can be described as follows:
cab route	=	outΔt7 univ.inΔt8 camp.cab route + outΔt7 camp.inΔt9 univ.cab route

∞
(l cab,h cab,r cab)
[cab route]

The description of student is more elaborated:

student	=	student∞
[travel]


travel	=	in∞univ.travel univ + in∞camp.travel camp travel camp	=	bus camp + tram camp + cab camp
travel univ	=	bus univ + tram univ + cab univ
cab camp	=	inΔt15 cab.(outΔt9 cab.outΔt17 univ.travel, cab camp) cab univ	=	inΔt14 cab.(outΔt8 cab.outΔt16 camp.travel, cab univ)
tram camp = inΔt13 tram.(outΔt4 tram.outΔt17 univ.travel, tram camp) tram univ  = inΔt12 tram.(outΔt6 tram.outΔt16 camp.travel, tram univ) bus camp	=  inΔt11 bus.(outΔt1 bus.outΔt17 univ.travel, bus camp)
bus univ	=  inΔt10 bus.(outΔt3 bus.outΔt16 camp.travel, bus univ)
According to the above definitions, the bus and the tram move based on a predefined schedule, even they contain or do not contain student ambients inside, while the cab ambient has no (time) restriction to move. Each cab has a cyclic movement between the two locations univ and camp even it has or does not have a student inside. The student can enter in the ambient found in his proximity, with no constraint imposed by other ambients. In the moment the student is at univ location, we can have one of the following scenarios:
two of the ambients bus, tram and cab, or all are at univ and at least one of them has free resources; in this case student enters one of them which has free resources, by choosing nondeterministically with no regard to the cost of the trip;
one of the ambients bus, tram and cab are at the univ location and has a free resource; in this case the student enters it with no regard to the cost of the trip, or the schedule of the others;
one, two or all of the ambients bus, tram and cab are at the univ location, but no free resources are available; in this case the student awaits for an ambient with free resources, and moves to be in its proximity.
The cost of the trip is not considered in all these scenarios. We can add prior- ities and interaction requirements acting over an initial assignment of the timers, capacities and proximities.
Over tMA we can define a coordination pair (T , CP). The first component T of this coordinating pair is a function assigning initial values to the timers, capacities and proximities. The second component CR is given by a set of rules. In our example
the timer t10 should have initially a smaller value than the timer t1, because the
student is not willing to wait for a bus which has to cover a distance bigger or equal than the one from the two locations univ and camp. Having similar motivations, the timers t11, t12 and t13 can be smaller that the initial value for t3, t4, respectively
t6. The rules given by CR influence the evolution of the system, and decide a certain

behaviour according to the requirements expressed by the rules. For example, the student establishes a strategy for lowering its travel costs by imposing his priority order: bus > tram > cab. Now we can impose the following rules:
[l cab /= h cab], [l cab = h cab], [t10 < t1], [t11 < t3] ,

[t10 < t1 Λ t12 < t4], [t11 < t3 Λ t13 < t6] .
These rules could be integrated in the syntax, and so the processes cab and student can be rewritten. Since the cab should make a trip only when it has a student inside, and it should accept a student only after it completes the previous trip, we rewrite the syntax of the cab ambient as

∞
(l cab,h cab,r cab)
[ [l cab = h cab]cab route]

cab route	=	[l cab /= h cab]outΔt7 univ.inΔt8 camp.[l cab = h cab]cab route
+	[l cab /= h cab]outΔt7 camp.inΔt9 univ.[l cab = h cab]cab route, where
l cab /= h cab - denotes the fact that the cab has an student inside it;
l cab = h cab - denotes the fact that the cab is available.
The initial student ambient has no strategy of lowering its travel cost by choosing a appropriate travel ambient. The coordinated student taking care of this aspect has the following syntax:

student	=	student∞
[travel]


travel	=	in∞univ.travel univ + in∞camp.travel camp travel camp	=	bus camp + tram camp + cab camp
travel univ	=	bus univ + tram univ + cab univ cab camp	=	[t11 < t3 Λ t13 < t6]inΔt15 cab.
(outΔt9 cab.outΔt17 univ.travel, cab camp) cab univ	=	[t10 < t1 Λ t12 < t4]inΔt14 cab.
(outΔt8 cab.outΔt16 camp.travel, cab univ) tram camp	=	[t11 < t3]inΔt13 tram.
(outΔt4 tram.outΔt17 univ.travel, tram camp) tram univ	=	[t10 < t1]inΔt12 tram.
(outΔt6 tram.outΔt16 camp.travel, tram univ)
bus camp	=	inΔt11 bus.(outΔt1 bus.outΔt17 univ.travel, bus camp)
bus univ	=	inΔt10 bus.(outΔt3 bus.outΔt16 camp.travel, bus univ),  where
t10 < t1 - compares the time (t10) needed for the bus to reach univ, with the time (t1) the student is willing to wait for bus;
t11 < t3 - compares the time (t11) needed for the bus to reach camp, with the time (t3) the student is willing to wait for bus;
t12 < t4 - compares the time (t12) needed for the tram to reach univ, with the time (t4) the student is willing to wait for tram;
t13 < t5 - compares the time (t13) needed for the tram to reach camp, with the time (t5) the student is willing to wait for tram.
The rules restrict the evolution of a system, acting when we have more than one interaction choice in a reduction step. In what follows we describe the possible evolutions of the system when the student is placed in the proximity of the univ

ambient, after rewriting the ambients cab and student. When student is at univ
location, we have the following reduction:

∞
(1,1,r student)
(l univ,h univ,r univ)[ ] 

∞
(l univ−1,h univ,r univ)
∞
(1,1,r student)
[travel univ]] 

If one the following scenarios holds:
the ambient bus having free resources and is in the proximity of student;
the bus is not at univ location, t10 > t1 (meaning that student waits for the bus) and the bus is arriving after t1 units of time and has free resources;
the second reduction in the system is:

∞
(1,1,r student)
(l bus,h bus,r bus)[ ] 

∞
(l bus−1,h bus,r bus)
∞
(1,1,r student)
[outΔt3 bus.outΔt16 camp.travel]] 

If one the following scenarios holds:
in the univ ambient there is no bus ambient; ambient tram, having free resources, is inside univ in the proximity of the student ambient, and t10 < t1 (which means that the student is not willing to wait for the bus);
tram is not inside univ, t12 > t4 (student is willing to wait for a tram), t10 < t1
and the tram is arriving after t4 units of time, and has free resources;
the second reduction in the system is:

∞
(1,1,r student)
(l tram,h tram,r tram)[ ] 

∞
(l tram−1,h tram,r tram)
∞
(1,1,r student)
[outΔt6 tram.outΔt16 camp.travel]] 

If one the following scenarios holds:
in the univ ambient there is no bus or tram ambient; ambient cab, having free resources, is inside univ is in the proximity of the student ambient, t10 < t1 (which means that the student is not willing to wait for the bus) and t12 < t4 (which means that the student is not willing to wait for the tram);
the cab is not inside univ, t14 > t9 (student is willing to wait for a cab), t10 < t1, t12 < t4 and an available cab is arriving after t9 units of time;
the second reduction in the system is:

∞
(1,1,r student)
(l cab,h cab,r cab)[ ] 

∞
(l cab−1,h cab,r cab)
∞
(1,1,r student)
[outΔt8 cab.outΔt16 camp.travel]] 

After the student enters one of the ambients bus, tram or cab by applying one of the three steps above, student is carried to the camp ambient where student is discarded. Then student exits the camp ambient, and we can have a similar scenario in order to move student from camp to univ.

Conclusion
Both timed distributed π-calculus and timed mobile ambients use discrete and rel- ative time given by timers, based on local clocks whose timers decrease uniformly.

Timers are used to restrict the interaction between components, and they can be used to control the resource availability. In timed mobile ambients we have a hier- archical representation of space, and a more realistic description of the distributed computation and mobility. In timed mobile ambients the interaction between com- ponents depends also on a proximity function which suggest a dynamic topology related to an interaction field, and allow the interaction between two processes in a general context.
In both formalisms we can have a clear separation of the coordination aspects from the computation aspects. Interaction in time and space could be controlled by assigning specific values to timers, and by a set of rules restricting the evolution of the system, acting also when we have more than one interaction choice.
Acknowledgement
The author thanks the referees for their helpful comments. Many thanks to Cristian Prisacariu for his collaboration concerning timed distributed π-calculus, and to Bogdan Aman for his collaboration concerning timed mobile ambients.

References
B. Aman, G. Ciobanu. Timers and Proximities for Mobile Ambients. Proceedings CSR, Lecture Notes in Computer Science vol.4649, Springer, 33–43, 2007.
B. Aman, G. Ciobanu. Mobile Ambients with Timers and Types. Proceedings ICTAC, Lecture Notes in Computer Science vol.4711, Springer, 50–63, 2007.
L. Cardelli, A. Gordon. Mobile Ambients. Foundations of Software Science and Computation Structures, Lecture Notes in Computer Science vol.1378, Springer, 140–155, 1998.
G. Ciobanu, C. Prisacariu. Timers for Distributed Systems. Electronic Notes in Theoretical Computer Science vol.164, 81–99, 2006.
G. Ciobanu, C. Prisacariu. Coordination by Timers for Channel-Based Anonymous Communications.
Electronic Notes in Theoretical Computer Science, vol.175, 3-17, 2007.
M. Hennessy, J. Riely. Resource access control in systems of mobile agents. Information and Computation vol.173, 82–120, 2002.
R. Milner. Communicating and Mobile Systems: the π-calculus. Cambridge University Press, 1999.
G.A. Papadopoulos, F. Arbab. Coordination Models and Languages. Advances in Computers vol.46, Academic Press, 329–400, 1998.
D. Teller, P. Zimmer, D. Hirschkoff. Using Ambients to Control Resources. Concurrency Theory , Lecture Notes in Computer Science vol.2421, Springer, 288–303, 2002.
