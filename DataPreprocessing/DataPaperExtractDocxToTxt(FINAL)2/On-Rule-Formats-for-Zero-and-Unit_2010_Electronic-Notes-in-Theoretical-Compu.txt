

Electronic Notes in Theoretical Computer Science 265 (2010) 145–160
www.elsevier.com/locate/entcs
On Rule Formats for Zero and Unit Elements
Luca Aceto1 Matteo Cimini1 Anna Ingolfsdottir1
ICE-TCS, School of Computer Science Reykjavik University
Menntavegur 1, IS 101 Reykjavik, Iceland
MohammadReza Mousavi Michel A. Reniers2
Department of Computer Science Eindhoven University of Technology
P.O. Box 513, NL-5600 MB Eindhoven, The Netherlands

Abstract
This paper proposes a rule format for Structural Operational Semantics guaranteeing that certain constants act as left or right zero elements for a set of binary operators. Our design approach is also applied to reformulate an earlier rule format for unit elements developed by some of the authors. Examples of left and right zero, as well as unit, elements from the literature are shown to be checkable using the provided formats.
Keywords: Structural Operational Semantics (SOS), GSOS format, bisimulation equivalence, zero element, unit element


Introduction
In the last three decades,  Structural Operational Semantics (SOS), see, e.g., [4,17,19,20], has been shown to be a powerful way to specify the semantics of programming and specification languages. In this approach to semantics, lan- guages can be given a clear behaviour in terms of states and transitions, where the collection of transitions is specified by means of a set of syntax-driven inference rules. Based on this semantics in terms of state transitions, we often want to prove general algebraic laws about the languages, which describe semantic properties of the various operators they involve modulo a notion of behavioural equivalence or preorder of interest. For example, the reader may think about the field of process

1 The work of Aceto, Cimini and Ingolfsdottir has been partially supported by the projects ‘New De- velopments in Operational Semantics’ (nr. 080039021) and ‘Meta-theory of Algebraic Process Theories’ (nr. 100014021) of the Icelandic Research Fund.
2 Email: m.a.reniers@tue.nl

1571-0661 © 2010 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2010.08.009

algebra, where it is important to check whether certain operators are, say, commu- tative and associative with respect to bisimilarity.
This paper aims at contributing to an ongoing line of research whose goal is to ensure the validity of algebraic properties by design, using the so called SOS rule for- mats [5]. Results in this research area roughly state that if the specification of (parts
of) the operational semantics of a language has a certain form then some semantic property is guaranteed to hold. The literature on SOS provides rule formats for basic algebraic properties of operators such as commutativity [16], associativity [12] and idempotence [1]. The main advantage of this approach is that one is able to verify the desired property by syntactic checks that can be mechanized. Moreover, it is interesting to develop rule formats for establishing semantic properties since results so obtained apply to a broad class of languages.
Recently, some of the authors provided in [6] a rule format guaranteeing another basic algebraic property not addressed before: the existence of left and right unit elements for operators. In the present paper, we follow the work presented in [6] and we develop a rule format guaranteeing instead that certain constants act as left or right zero elements for a set of binary operators. Namely, a function f has a left (respectively, right) zero element c, modulo some notion of behavioural equivalence, whenever the equation f (c, x) = c (respectively, f (x, c) = c) holds. A constant c satisfying the above equation(s) is also said to be absorbing for the operator f .
A classic example of a left zero element within the realm of process algebra is provided by the constant δ, for deadlock, from BPA [9], which satisfies the laws:



δ · x = δ	and	δ  x = δ ,



where ‘·’ and ‘’ stand for sequential composition and left merge, respectively.
In this paper, we formulate our zero-element format within the GSOS languages of Bloom, Istrail and Meyer [11]. In particular, we benefit from the logic of transition formulae developed by some of the authors in [2], which is tailored for reasoning about the satisfiability of premises of GSOS rules. (The full version of the paper [3] offers also a syntactic rule format for left and right zero elements that applies to SOS rules that are more general than GSOS ones.)
The final part of the paper is devoted to applying the design ideas underlying the GSOS-based format for left and right zero elements to reformulate the format for left and right unit elements from [6]. The resulting format turns out to be incomparable in power to the original one, but it is expressive enough to check all the examples discussed in [6].
Mechanizing the rule formats in a tool-set is a long-term goal of research on SOS rule formats. We believe that the GSOS-based rule formats we present in this paper are strong candidates for mechanization insofar as zero and unit elements are concerned.

Roadmap of the paper
Section 2 repeats some standard definitions from the theory of SOS and from the logic of initial transitions from [2]. Section 3 provides the format for left and right zero elements and Section 4 shows how several examples of left and right zero elements from the literature fit the format. In Section 5 we provide a rule format for unit elements adapting the ideas from Section 3. We conclude the paper in Section 6 with an overview of its main contributions and with a mention of further results that may be found in the full version of the paper [3].

Preliminaries
In this section we recall some standard definitions from the theory of SOS. We refer the readers to, e.g., [4] and [17] for more information.

Transition system speciﬁcations and bisimilarity
Definition 2.1 [Signatures, terms and substitutions] We let V denote an infinite set of variables and use x, x', xi, y, y', yi,... to range over elements of V . A signature Σ is a set of function symbols, each with a fixed arity. We call these symbols operators and usually represent them by f, g, . . . . An operator with arity zero is called a constant. We define the set T(Σ) of terms over Σ as the smallest set satisfying the following constraints.
A variable x ∈ V is a term.
If f ∈ Σ has arity n and t1,..., tn are terms, then f (t1,..., tn) is a term.
We use s, t, possibly subscripted and/or superscripted, to range over terms. We write t1 ≡ t2 if t1 and t2 are syntactically equal. The function vars : T(Σ) → 2V gives the set of variables appearing in a term. The set C(Σ) ⊆ T(Σ) is the set of closed terms, i.e., terms that contain no variables. We use p, q, p', pi,... to range over closed terms. A substitution σ is a function of type V → T(Σ). We extend the domain of substitutions to terms homomorphically and write σ(t) for the result of applying the substitution σ to the term t. If the range of a substitution lies in C(Σ), we say that it is a closed substitution.
Definition 2.2 [Transition system specification] A transition system speciﬁcation
(TSS) is a triple (Σ, L, D) where
Σ is a signature.
L is a set of labels (or actions) ranged over by a, b, l. If l ∈ L, and t, t' ∈ T(Σ)

we say that t →l
t' is a positive transition formula and t ~l
is a negative transition

formula. A transition formula (or just formula), typically denoted by φ or ψ, is
either a negative transition formula or a positive one.
D is a set of deduction rules, i.e., tuples of the form (Φ, φ) where Φ is a set of formulae and φ is a positive formula. We call the formulae contained in Φ the premises of the rule and φ the conclusion.

We write vars(r) to denote the set of variables appearing in a deduction rule r. We say that a formula or a deduction rule is closed if all of its terms are closed. Substitutions are also extended to formulae and sets of formulae in the natural way. For a rule r and a substitution σ, the rule σ(r) is called a substitution instance of
r. A set of positive closed formulae is called a transition relation.


We often refer to a positive transition formula t →l
t' as a transition with t being

its source, l its label, and t' its target. A deduction rule (Φ, φ) is typically written as Φ . An axiom is a deduction rule with an empty set of premises. We call a deduction rule f -deﬁning when the outermost function symbol appearing in the source of its
conclusion is f .
In this paper, for each constant c, we assume that each c-deﬁning deduction rule

is an axiom of the form c →l
p for some label l and closed term p. This is not a real

restriction since all practical cases we know of do actually satisfy this property. For GSOS languages [11], whose definition is given below and that will be our focus in the remainder of this study, this restriction is automatically satisfied.
Definition 2.3 [GSOS rule] Suppose Σ is a signature. A GSOS rule r over Σ is a rule of the form:

Sl	nx


aij
y
|1 ≤ j ≤ m , ∪	Sl

bik |1 ≤ k ≤ n 

i=1
i → ij
i

f (x1,..., xl) →c
i=1

t
xi ~
i
(1)


where all the variables are distinct, mi, ni ≥ 0, aij, bik, and c are actions from a finite set, f is a function symbol from Σ with arity l, and t is a term in T(Σ) such that vars(t) ⊆ {x1,..., xl}∪ {yij | 1 ≤ i ≤ l, 1 ≤ j ≤ mi}.
Definition 2.4 A GSOS language is a triple G = (ΣG, L, RG), where ΣG is a finite signature, L is a finite set of action labels and RG is a finite set of GSOS rules over ΣG. The transition relation →G associated with a GSOS language G is the one defined by the rules using structural induction over closed ΣG-terms.
Definition 2.5 (Bisimulation and bisimilarity [15,18]) Let G = (ΣG, L, RG)
be a GSOS language. A relation R ⊆ C(ΣG) × C(ΣG) is a bisimulation relation if
and only if R is symmetric and, for all p0, p1, p' ∈ C(ΣG) and l ∈ L,


(p0 Rp1 ∧ p0 →l
G p' ) ⇒ ∃p' ∈ C(ΣG). (p1 →l G p' ∧ p' Rp' ).

0	1	1	0	1
Two terms p0, p1 ∈ C(ΣG) are called bisimilar, denoted by p0 ↔–– p1, when there exists a bisimulation relation R such that p0 Rp1.
Bisimilarity is extended to open terms by requiring that s, t ∈ T(Σ) are bisimilar when σ(s) ↔–– σ(t) for each closed substitution σ : V → C(ΣG).

The logic of initial transitions
In this section, for the sake of completeness, we discuss the logic we employ in the definition of our rule format for left and right zero elements based on GSOS. The logic of initial transitions has been recently introduced by some of the authors in [2] in order to reason about the satisfiability of the premises of GSOS rules. The set of initial transition formulae over a finite set of actions L is defined by the following grammar, where a ∈ L:

F ::=	True | x →a
| ¬F | F ∧ F .

As usual, we write False for ¬True, and F ∨ F' for ¬(¬F ∧ ¬F ').
The semantics of this logic is given by a satisfaction relation |= that is defined, relative to a GSOS language G = (ΣG, L, RG), by structural recursion on F in the following way, where σ is a closed substitution and →G is the collection of transitions that can be proven using the rules in RG:
→G,σ |= True  always
→G,σ |= x →a ⇔ σ(x) →a G p, for some p
→G,σ |= ¬F ⇔ not →G,σ |= F
→G,σ |= F ∧ F' ⇔ →G,σ |= F and →G,σ |= F' .
The reader familiar with Hennessy-Milner logic [13] will have noticed that the propo-
sitions of the form x →a correspond to Hennessy-Milner formulae of the form ⟨a⟩True.
In what follows, we consider formulae up to commutativity and associativity of ∧. We use the logic to turn the set of premises Φ of a GSOS rule into a formula that describes the collection of closed substitutions that satisfy Φ. The conversion
procedure hyps is borrowed from [2]. Formally,
hyps(∅)= True
hyps({x →a y}∪ Φ) = (x →a ) ∧ hyps(Φ \ {x →a y})
hyps({x ~a }∪ Φ) = ¬(x →a ) ∧ hyps(Φ \ {x ~a }) .
Intuitively, if Φ is the set of premises of a rule then hyps(Φ) is the conjunction of the corresponding initial transition formulae. For example,
hyps({x →a y, z ~b }) = (x →a ) ∧ ¬(z →b ) .
If J is a finite set of GSOS rules, we overload hyps and write:
hyps(J ) =	hyps(Φr) ,
r∈J

where Φr is the set of premises of rule r.
We write |=G F ⇒ F' iff every substitution that satisfies F also satisfies F'.
This semantic entailment preorder is decidable, as shown in [2].
Theorem 2.6 (Decidability of entailment) Let G be a GSOS language. Then, for all formulae F and F', it is decidable whether |=G F ⇒ F' holds.

As a matter of fact, when Φ is the set of the premises of a rule r, checking whether
|=G True ⇒ hyps(Φ) holds is equivalent to checking whether the rule r is always firable. Conversely, checking whether |=G hyps(Φ) ⇒ False holds is equivalent to checking whether the rule r never fires. These considerations will be useful in the
remainder of the paper. Our definition of the rule format for left and right zero elements makes use of the logic and especially of these two kinds of entailment. The semantic entailment is, moreover, used in a simplified fashion where one does not need to check all the closed substitutions, but only those that map one variable to the left or right zero element constant under consideration. We now proceed to formalize this notion.
Definition 2.7 Let G = (ΣG, L, RG) be a GSOS language. For each formula F , constant c ∈ ΣG and variable x, we define the formula F [x '→ c] by structural recursion on F as follows:
True[x '→ c]= True
a	 True	if there is a c-defining axiom c →a p for some p



(y →a )[x '→ c]= y →a
if x /= y

(¬F )[x '→ c]= ¬(F [x '→ c])
(F1 ∧ F2)[x '→ c]= (F1[x '→ c]) ∧ (F2[x '→ c]) .
The connection between F and F [x '→ c] is provided by the following lemma.
Lemma 2.8 Let G = (ΣG, L, RG) be a GSOS language. Let F be a formula, c be a constant in ΣG and x be a variable. Then, for each closed substitution σ,
→G,σ |= F [x '→ c] iff	→G, σ[x '→ c] |= F ,
where σ[x '→ c] denotes the substitution that maps x to c and acts like σ on all the other variables.
As a consequence of the above lemma, checking whether F holds for all substi- tutions that map variable x to a constant c amounts to showing that the formula F [x '→ c] is satisfied by all substitutions—that is, showing that F [x '→ c] is a tautology over G.

Rule format for zero elements
In this section we provide a rule format guaranteeing that certain constants act as left or right zero elements for a set of binary operators. To this end we employ a variation on the technique developed by some of the authors in [6] for left or right unit elements.
As in [6], we make use of an equivalence relation between terms called zero- context equivalence, which is the counterpart of the unit-context equivalence
from [6]. Intuitively if c is a left zero element for an operator f and c is also a

right zero element for g, then the terms f (c, t1) and g(t2, c) are both zero-context equivalent to c and zero-context equivalent to each other.
In the following formal definition of zero-context equivalence, it is useful to consider (f, c) ∈ L as stating that ‘c acts as a left zero element for the operator f ’ and analogously (f, c) ∈ R indicates that the constant c is a right zero element for f .
Definition 3.1 [Zero-context equivalent terms] Given sets L, R ⊆ Σ × Σ of pairs
L,R
of binary function symbols and constants, ∼=0 is the smallest equivalence relation
satisfying the following constraints, for each s ∈ T(Σ):
L,R
∀(f, c) ∈ L. c =0 f (c, s), and
L,R
∀(g, d) ∈ R. d =0 g(s, d).
L,R
We say that two terms s, t ∈ T(Σ) are zero-context equivalent, if s =0 t.
Since the sets L and R are always clear from the context, in the remainder of
L,R
the paper we write ∼=0 in place of =0 .
Theorem 3.2 (Decidability of zero-context equivalence) Let L, R ⊆ Σ × Σ
be ﬁnite sets of pairs of binary function symbols and constants. Then, for all terms
L,R
t, u ∈ T(Σ), it is decidable whether t =0 u holds.
In order to remain in line with the terminology in [6], in the following definition we talk about left- and right-aligned pairs. The conditions of our format will not try to ensure firability/unfirability of rules by syntactic means as in the rule format for unit elements from [6], but they instead exploit the logic of initial transition formulae to incorporate a modicum of semantic reasoning within the rule format.
Definition 3.3 [Left- and right-aligned pairs] Let G be a GSOS language. The sets L and R of pairs of binary function symbols and constants are the largest sets satisfying the following constraints.
For each (f, c) ∈ L, the following conditions hold.
For each axiom c →a t, there exists a set J of rules of the form
Φ

f (x0, x1) →a t'
such that
|=G True ⇒ hyps(J )[x0 '→ c], and
for each rule in J , one of the following cases holds:
there is some variable y ∈ vars(t') such that x0 →a y ∈ Φ and σ(t') ∼=0 t, where σ is the substitution mapping x0 to c, y to t and is the identity on
all the other variables, or
σ(t') ∼=0 t, where σ is the substitution mapping x0 to c and is the identity
on all the other variables.

For each f -defining deduction rule
Φ

f (x0, x1) →a t'
one of the following cases holds:
there exists an axiom c →a t such that
there is some variable y ∈ vars(t') such that x0 →a y ∈ Φ and σ(t') ∼=0 t, where σ is the substitution mapping x0 to c, y to t and is the identity on
all the other variables, or
σ(t') ∼=0 t, where σ is the substitution mapping x0 to c and is the identity
on all the other variables.
|=G hyps(Φ)[x0 '→ c] ⇒ False.
	The definition of right-aligned pairs of operators and constant symbols—that is, those such that (f, c) ∈ R—is symmetric and is not repeated here.
For a function symbol f and a constant c, we call (f, c) left aligned (respectively,
right aligned ) if (f, c) ∈ L (respectively, (f, c) ∈ R).
Let G be a GSOS language over a signature including at least one constant. Since hyps(J ) is a disjunctive formula, condition 1.a.i. in the above definition implies that the set J is non-empty. On the other hand, condition 1.b.ii. says that the premises of the rule under consideration cannot be satisfied by any closed substitution that maps the variable x0 to the constant c.
In condition 1.a. and its symmetric counterpart, one must identify a set J of rules. To understand why, the reader should consider the following TSS with con- stants 0 (with no rule) and RUNa, and a function symbol f defined as follows





RUNa →a RUNa

(y)
x →a x'	y →a y'


f (x, y) →a x'

(not–y)
x →a x'	y ~a
.
f (x, y) →a x'

The rules (y) and (not–y) only together allow the operator f to simulate the behaviour of the constant RUNa: no matter what closed term is substituted for the argument variable y, we are sure that one of the two rules fires and that the transition leads to RUNa. In Definition 3.3, these two properties are guaranteed, respectively, by conditions 1.a.i. and 1.a.ii.
Theorem 3.4 Let G be a GSOS language. Assume that L and R are the sets of left- and right-aligned function symbols according to Deﬁnition 3.3. For each (f, c) ∈ L, it holds that f (c, x) ↔–– c. Symmetrically, for each (f, c) ∈ R, it holds that f (x, c) ↔–– c.
The following result is a consequence of Theorems 2.6 and 3.2.
Theorem 3.5 For GSOS languages, the sets L and R can be effectively constructed.
We conclude this section by discussing some of the constraints in Definition 3.3

in order to argue that they cannot be easily relaxed. In what follows, we focus on the conditions that left-aligned pairs must meet. First of all, note that relaxing the constraint of GSOS rules that x0 /≡ x1 would jeopardize Theorem 3.4. To see this, consider the TSS with constant RUNa and binary operator f with rule

x0 →a y0
.
f (x0, x0) →a y0
It is not hard to check that L = {(f, RUNa)} and R = ∅ satisfy all the other constraints of GSOS rules and Definition 3.3. Due to the presence of axiom RUNa →a RUNa constraint 1.b.i.A. is met in this case. However, RUNa is not a left zero element for f . For example, the term f (RUNa,f (RUNa, RUNa)) affords no transition and therefore cannot be bisimilar to RUNa.
The following example shows that relaxing the GSOS requirement that x1 /∈
{yij | 1 ≤ i ≤ l, 1 ≤ j ≤ mi} would also invalidate Theorem 3.4. To see this, consider the TSS with constant RUNa and binary operator f with rule

x0 →a x1
.
f (x0, x1) →a x1
Again, it is not hard to check that L = {(f, RUNa)} and R = ∅ satisfy all the other constraints of GSOS rules and Definition 3.3. However, f (RUNa,f (RUNa, RUNa)) affords no transition and therefore cannot be bisimilar to RUNa. This means that RUNa is not a left zero element for f .
The role played by requirements 1.a.i. and 1.a.ii. in ensuring that, modulo bisim- ilarity, f (c, p) affords ‘the same transitions as c’, for each p, is highlighted by the following two examples.
Example 3.6 Consider the TSS with constants 0 and a&b, and a binary operator
f with rules:


x0 ~b	x0 →a y0
		

x0 ~a	x0 →b y0
.

a&b →a 0	a&b →b 0
f (x0, x1) →a y0
f (x0, x1) →b y0

It is not hard to check that L = {(f, a&b)} and R = ∅ satisfy all the constraints in Definition 3.3 apart from 1.a.i. In particular, any singleton set J of f -defining deduction rules satisfies constraint 1.a.ii.A. (and thus constraint 1.a.). However, the term f (a&b, 0) affords no transition unlike a&b. Therefore a&b is not a left zero element for f .	☒
Example 3.7 Consider the TSS with constants RUNa, RUNb and c and a binary operator f with rules:




x1 →a y1	x1 →b y1

	
c →a RUNa	c →a RUNb


f (x0, x1) →a RUNa


f (x0, x1) →a RUNb


Let L = {(f, c)} and R be empty. We claim that all the conditions in Definition
3.3 are met, apart from 1.a.ii. To see this, note, first of all, that each closed term in this language initially affords an a-labelled or a b-labelled transition. Therefore,

the formula x1 →a
∨ x1 →b
is a tautology. It follows that condition 1.a.i. can be

met for both the c-defining axioms by taking J to contain both f -defining rules. Observe that condition 1.a.ii. fails for this J , but condition 1.b.i.B. is met for both f -defining rules by matching the first f -defining rule with the first rule for c and the second f -defining rule with the second rule for c.
However, c is not a left zero element for f .  For example, f (c, RUNa) only
affords an a-labelled transition to RUNa and therefore cannot match the transition
c →a RUNb.	☒
As witnessed, e.g., by Example 4.3 to follow, constraint 1.b.i. enhances the gen- erality of our format. Indeed, if we removed constraint 1.b.i. and a left-aligned pair (f, c) satisfied condition 1.b.ii., then no rule for f would be applicable to a closed term of the form f (c, p). Therefore, no term of the form f (c, p) would afford a transition. Since (f, c) satisfies condition 1.a. in Definition 3.3, the collection of c-defining axioms must be empty. As a consequence, the resulting format would be unable to handle left zero elements such as RUNa that afford some transition. Ex- amples of constants with deduction axioms in the literature are immediate deadlock [8], which acts as a left zero element for sequential composition, parallel composi- tion, left merge and communication merge and as a right zero element for parallel composition and communication merge, and delayable deadlock from [7], which is a left zero element for sequential composition.

Examples
In this section we show that several examples of zero elements from the literature indeed fit the format described in Section 3.
Example 4.1 [Synchronous parallel composition] Consider the synchronous paral- lel composition from CSP [14] over a set of actions L with rules:
x →a x'	y →a y'



x L y →a x'  L y'
(a ∈ L) .

We know that the inaction constant 0, with no rules, is a left and right zero element for  L. Let L = R = {(  L, 0)}. Since the constant 0 has no axioms, condition 1.a. is vacuously satisfied. In order to see that also condition 1.b. is satisfied, it is sufficient to notice that the only rule for L can never fire because 0 has no transitions.

a	a
Indeed, the entailment |=G (x → ∧ y → )[x '→ 0] ⇒ False holds and condition 1.b.ii.
is met. The symmetric counterpart of clause 1.b. is handled in similar fashion. The well-known laws
0  L y ↔–– 0	and	x  L 0 ↔–– 0
thus follow from Theorem 3.4.	☒
Example 4.2 [Left merge operator] Consider the left merge operator from [9].
x →a x'

x  y →a x'  y
Here  stands for the merge operator from [9], whose SOS specification is immaterial for this example; see Example 4.3 to follow. Let L = {(, 0)} and R = ∅. We claim that L meets the constraints in Definition 3.3. It is easy to check that the claim is true by the same reasoning used in Example 4.1. This time it is sufficient to check condition 1. because 0 is just a left zero element for . By Theorem 3.4 the validity of the law 0  y ↔–– 0 follows. Note that the pair {( , 0)} cannot be added to R because the symmetric version of condition 1.b. would be violated. Indeed 0 is not a right zero element for .	☒
Example 4.3 [Merge operator] Let L be the set of actions. Consider the classic merge operator  with the following rules, where a ∈ L.


x →a x'
x	y →a x'	y
y →a y'

x	y →a x	y'

Let RUNL be a constant defined by axioms RUNL →a RUNL for each action a ∈ L. We claim that the constant RUNL is both a left and right zero element for  . This can be checked using Theorem 3.4. Indeed, let L = R = {(  , RUNL)}. It is easy to see that condition 1.a. in Definition 3.3 is met for RUNL →a RUNL by taking the instance of the left-hand rule for  with action a. Condition 1.b. is for the left- hand deduction rule met via constraint 1.b.i.A. due to the presence of the axiom for RUNL for action a. For the right-hand rule for  with action a, condition 1.b.i.B is met since
σ(x  y') ≡ RUNL  σ(y') ∼=0 RUNL
for a substitution σ with σ(x) = RUNL and that acts as the identity function otherwise, and RUNL →a RUNL is one of the axioms for the constant RUNL.   ☒
Example 4.4 [A right-choice operator] In this example we apply our format to a non-standard operator. For the sake of simplicity we assume that a is the only action. Consider a variant of the choice operator of Milner’s CCS [15], where the right-hand argument has a higher priority than the left-hand argument, i.e., the scheduler executes the left-hand argument only when the other one has no transi- tions. The rules for such an operator are as follows:



x →a x'	y ~a
x ←+ y →a x'
y →a y'
.
x ←+ y →a y'

Let c be any constant whose behaviour is defined by a non-empty, finite collection of axioms {c →a pi | i ∈ I}, where I is some index set. Reasoning as in the previous examples, using Theorem 3.4, we are able to prove the validity of the law x ←+ c ↔–– c. We leave the details to the reader. The operator studied in this example bears resemblance with the preferential choice operator →+ from [10].	☒

From zero to unit
In this section we reformulate the unit element format of [6] following the lines of Definition 3.3. For the sake of clarity and completeness we repeat here the definition of unit-context equivalence from [6].
Definition 5.1 [Unit-context equivalence [6]] Given sets L, R ⊆ Σ × Σ of pairs
L,R
of binary function symbols and constants, = is the smallest equivalence relation
satisfying the following constraints, for each s ∈ T(Σ):
L,R
∀(f, c) ∈ L. s = f (c, s), and
L,R
∀(g, c) ∈ R. s = g(s, c).
L,R
We say that two terms s, t ∈ T(Σ) are unit-context equivalent, if s = t.
Since the sets L and R are always clear from the context, we write ∼= in place
L,R
of = .
Theorem 5.2 (Decidability of unit-context equivalence) Let L, R ⊆ Σ × Σ
be ﬁnite sets of pairs of binary function symbols and constants. Then, for all terms
L,R
t, u ∈ T(Σ), it is decidable whether t = u holds.
Definition 5.3 [Left- and right-aligned pairs for unit elements] Given a GSOS language G, the sets L and R of pairs of binary function symbols and constants are the largest sets satisfying the following constraints.
For each (f, c) ∈ L, the following conditions hold:
For each action a ∈ L, there exists at least one deduction rule of the form
Φ ∪ {x1 →a y1}



where
|=G





x1 →a
,
f (x0, x1) →a t'

⇒ hyps(Φ)[x0 '→ c], and

one of the following cases holds:

there are a premise x0 →b
y ∈ Φ, for some b ∈L and y ∈ vars(t'), and an

axiom c →b t such that σ(t') ∼= y1, where σ is the substitution mapping x0
to c, y to t and is the identity on all the other variables, or
σ(t') ∼= y1, where σ is the substitution mapping x0 to c and is the identity
on all the other variables.
For each f -defining deduction rule
Φ

f (x0, x1) →a t'
one of the following cases holds:
x1 →a y1 ∈ Φ for some variable y1 and

either there is a premise x0 →b
y ∈ Φ, for some b ∈ L and variable

y ∈ vars(t'), such that c has a single axiom with label b—say, c →b t—
and σ(t') ∼= y1, where σ is the substitution mapping x0 to c, y to t and is
the identity on all the other variables,
or σ(t') ∼= y1, where σ is the substitution mapping x0 to c and is the
identity on all the other variables.
|=G hyps(Φ)[x0 '→ c] ⇒ False.
	The definition of right-aligned pairs of operators and constant symbols—that is, those such that (f, c) ∈ R—is symmetric and is not repeated here.
For a function symbol f and a constant c, we call (f, c) left aligned (respectively,
right aligned ) if (f, c) ∈ L (respectively, (f, c) ∈ R).
The following theorem states the correctness of the rule format defined above.
Theorem 5.4 Let G be a GSOS language. Assume that L and R are the sets of left- and right-aligned function symbols according to Deﬁnition 5.3. For each (f, c) ∈ L, it holds that f (c, x) ↔–– x. Symmetrically, for each (f, c) ∈ R, it holds that f (x, c) ↔–– x.

Remark 5.5 The constraint that c →b
t be the only c-defining axiom with label b

in condition 1.b.i.A. of Definition 5.3 is necessary for the validity of Theorem 5.4. To see this, consider, for instance, the TSS over set of labels {a} with constants 0, RUNa and c, and the binary operator  L defined in Example 4.1. The rules for the constant c are
.
c →a c	c →a 0
Observe that the sets L = {L, c)} and R = ∅ would satisfy the conditions in Definition 5.3 if the uniqueness requirement were dropped from condition 1.b.i.A. On the other hand, c L RUNa is not bisimilar to RUNa because
c L RUNa →a 0 L RUNa ~a ,
while RUNa can only perform action a forever. Therefore c is not a left unit element for  L.	☒

The following result is a consequence of Theorems 2.6 and 5.2.
Theorem 5.6 For GSOS languages, the sets L and R can be effectively constructed.
The format for left and right unit elements proposed above is incomparable to the one offered in [6]. Indeed, the latter allows for complex terms as source of the conclusions and in the premises, which the GSOS format forbids. On the other hand, in condition 1.a. above, the set of premises Φ may contain several tests on the argument variable x1, which is forbidden by the purely syntactic format in [6]. A concrete, albeit admittedly inexpressive, example of a TSS exploiting this feature is discussed below.
Example 5.7 Consider a TSS, over the set of labels {a, b}, with constants RUNa and RUNb, and a binary function symbol f defined by the rules below.


y →a y'	y ~b
y →b
y'	y ~a


	
f (x, y) →a y'	f (x, y) →b y'
The constants RUNa and RUNb are both left unit elements for f . Indeed, every
closed term is a left unit element for f . This holds true because each closed term is bisimilar to one of the constants RUNa and RUNb. Therefore, every process is either able to perform initially an a-transition or is able to perform initially a b-transition, but never both.
It is not hard to check that the sets L = {(f, RUNa), (f, RUNb)} and R = ∅ satisfy the conditions in Definition 5.3. On the other hand, the format from [6] fails on this basic scenario since y is tested twice in the rules for f .	☒
All the examples from the literature mentioned in [6] can be handled by the rule format presented in Definition 5.3. By way of illustration, we limit ourselves to discussing just a single example addressed in [6].
Example 5.8 [Synchronous Parallel Composition] Assume that a is the only ac- tion in L. Consider the constant RUNa and the synchronous parallel composition operator  L from Example 4.1. For ease of reference, we recall that  L is specified by the rule

x →a x'	y →a y'


x L y →a x'  L y'
(a ∈ L) .

Take L = R = {(  L, RUNa)}. These sets L and R meet the constraints in Defini- tion 5.3. Let us discuss first the set L.
Consider the rule above. Since (x →a )[x '→ RUNa] = True, the entailment
|=  y →a  ⇒ (x →a )[x '→ RUNa]
is trivially satisfied. Therefore condition 1.a.i. is met. Note, moreover, that x →a x'
is a premise of the rule above. Since we can pick the axiom
RUNa →a RUNa ,

and the substitution σ that maps x and x' to RUNa and that is the identity function on all the other variables. Then, σ(x'  L y') ≡ RUNa  L y' ∼= y'. Therefore condition 1.a.ii.A. is met.
Reasoning as above, we can easily check that rule above meets condi- tion 1.b.i.A. in Definition 5.3.
A similar reasoning shows that (  L, RUNa) is also right aligned.	☒
Conclusions
In this paper we have provided a rule format ensuring that certain constants in a language act as left or right zero elements for a set of binary operators. The format for left and right zero elements presented in Section 3 follows the techniques developed by some of the authors in [6], where a format for left and right unit elements was offered, but the actual details are rather different.
The format makes use of the logic of initial transitions as proposed in [2] and is restricted to the so-called GSOS languages. It therefore does not include advanced features such as complex terms in the source of the conclusions of rules, like the one in [6] does for unit elements, but is still able to check relevant cases.
Following the design of the format for zero elements, we also provided an alter- native rule format for left and right unit elements. Although this format is incom- parable to the format from [6], it is still able to check all relevant cases from the literature and also some basic unit elements not addressed by the format from [6]. We believe that the formats we propose in this paper for GSOS languages are good candidates for mechanization in a tool-set for checking algebraic laws based
on rule formats.
In [3], the full version of this paper, we also give a format for zero elements that is not restricted to GSOS languages, but follows the approach of [6] more closely, and apply it to a variety of examples from the literature. In this paper we have not included any material about the use of premises in deduction rules. In [3] we show that predicates can easily be dealt with.

References
Aceto, L., A. Birgisson, A. Ingolfsdottir, M. R. Mousavi and M. A. Reniers, Rule formats for determinism and idempotence, in: F. Arbab and M. Sirjani, editors, Fundamentals of Software Engineering, Third IPM International Conference, FSEN 2009, Kish Island, Iran, April 15-17, 2009, Revised Selected Papers, Lecture Notes in Computer Science 5961 (2010), pp. 146–161.
Aceto, L., M. Cimini and A. Ingolfsdottir, A bisimulation-based method for proving the validity of equations in GSOS languages, in: Proceedings of Structural Operational Semantics 2009, August 31, 2009, Bologna (Italy), Electronic Proceedings in Theoretical Computer Science 18, 2010, pp. 1–16.
Aceto, L., M. Cimini, A. Ingolfsdottir, M. Mousavi and M. A. Reniers, On rule formats for zero and unit elements, Technical Report CSR 10/03, TU/e (2010).
Aceto, L., W. Fokkink and C. Verhoef, Structural operational semantics, in: Handbook of Process Algebra (1999), pp. 197–292.
Aceto, L., A. Ingolfsdottir, M. Mousavi and M. A. Reniers, Algebraic properties for free!, Bulletin of the EATCS 99 (2009), pp. 81–104.


Aceto, L., A. Ingolfsdottir, M. Mousavi and M. A. Reniers, Rule formats for unit elements, in: J. van Leeuwen, A. Muscholl, D. Peleg, J. Pokorny´ and B. Rumpe, editors, SOFSEM 2010, 36th Conference on Current Trends in Theory and Practice of Computer Science, Sˇpindleruv Ml´yn, Czech Republic, January 23-29, 2010. Proceedings, Lecture Notes in Computer Science 5901 (2010), pp. 141–152.
Baeten, J., T. Basten and M. Reniers, “Process Algebra: Equational Theories of Communicating Processes,” Cambridge Tracts in Theoretical Computer Science 50, Cambridge University Press, 2009.
Baeten, J. and C. Middelburg, “Process Algebra with Timing,” Monographs in Theoretical Computer Science, An EATCS Series, Springer-Verlag, Berlin, 2002.
Bergstra, J. and J. W. Klop, Fixedpoint semantics in process algebra, Technical Report IW 206/82, Center for Mathematics, Amsterdam, The Netherlands (1982).
Bergstra, J. A. and C. A. Middelburg, Preferential choice and coordination conditions, J. Log. Algebr. Program. 70 (2007), pp. 172–200.
Bloom, B., S. Istrail and A. R. Meyer, Bisimulation can’t be traced, J. ACM 42 (1995), pp. 232–268.
Cranen, S., M. Mousavi and M. A. Reniers, A rule format for associativity, in: F. van Breugel and M. Chechik, editors, Proceedings of the 19th International Conference on Concurrency Theory (CONCUR’08), Lecture Notes in Computer Science 5201 (2008), pp. 447–461.
Hennessy, M. and R. Milner, Algebraic laws for nondeterminism and concurrency, J. ACM 32 (1985),
pp. 137–161.
Hoare, C. A. R., Communicating sequential processes, Commun. ACM 21 (1978), pp. 666–677.
Milner, R., “Communication and concurrency,” Prentice-Hall, Inc., Upper Saddle River, NJ, USA, 1989.
Mousavi, M., M. Reniers and J. F. Groote, A syntactic commutativity format for SOS, Information Processing Letters 93 (2005), pp. 217–223.
Mousavi, M. R., M. A. Reniers and J. F. Groote, SOS formats and meta-theory: 20 years after, Theor. Comput. Sci. 373 (2007), pp. 238–272.
Park, D., Concurrency and automata on infinite sequences, in: Proceedings of the 5th GI-Conference on Theoretical Computer Science (1981), pp. 167–183.
Plotkin, G. D., A Structural Approach to Operational Semantics, Technical Report DAIMI FN-19, University of Aarhus (1981).
Plotkin, G. D., A structural approach to operational semantics, J. Log. Algebr. Program. 60-61 (2004),
pp. 17–139.
