URL:  http://www.elsevier.nl/locate/entcs/volume54.html  14 pages



On the Serializability of Transactions in JavaSpaces



Nadia Busi  and  Gianluigi Zavattaro

Dipartimento di Scienze dell'Informazione, Universita  di Bologna, Italy.
E-mail:    busi,zavattar@cs.unibo.it



Abstract
JavaSpaces is a coordination infrastructure inspired by the shared dataspace model: processes interact by introducing, consuming, and testing for the presence/absence of data in a common repository. Besides these traditional operations, an event based coordination mechanism is considered which allows for the noti cation of the introduction of new instances of data in the repository.
JavaSpaces also supports transactions: multiple coordination operations can be grouped into a bundle that acts as a single atomic operation. In this paper we adopt serializability as a criterion to evaluate the correctness of the JavaSpaces transaction semantics: we prove that serializability is satis ed only if we restrict to output, input, and read operations. On the other hand, in the presence of either test for absence or event noti cation, serializability is not satis ed; we propose an alternative semantics and we prove that it supports serializability.


1	Introduction

Coordination middlewares are emerging as suitable architectures for mak- ing easier the programming of distributed applications. JavaSpaces [3] and TSpaces [9], produced by Sun Microsystem and IBM respectively, are the most prominent examples. Both proposals borrow the main features of both the data-driven and the control-driven coordination models [8]:
 the generative communication operations of Linda [5], according to which processes communicate through production, consumption and test for pres- ence of data in a common data repository; besides the traditional blocking input and read operations also versions which terminates by signalling the absence of matching data are provided;
 an event noti cation mechanism, allowing for a process to register its inter- est in the future arrivals of some data, and then receive communication of each occurrence of this event.
 c 2001 Published by Elsevier Science B. V. Open access under CC BY-NC-ND license.

A further feature, relevant for distributed applications and supported by both the aforementioned proposals, is a transaction mechanism. A set of coordina- tion operations can be grouped in a transaction, and executed in such a way that either all of them succeed or none of them is performed.
Consistency of the data repository in the JavaSpaces speci cations [6] is ensured by requiring transactions to satisfy the so called ACID (atomicity, consistency, isolation and durability) properties, traditionally supported by database management systems. In particular, in this paper we are concerned with preservation of the isolation property, also called serializability: \Ongoing transactions should not a ect each other. Any observer should be able to see other transactions executing in some sequential order".
To meet the isolation requirement for transactions, in the JavaSpaces spec- i cation the semantics of coordination operations is a ected as follows. A datum produced within a transaction will become accessible from outside the transaction only when the transaction commits; data consumption or test for presence within a transaction can operate on items emitted either within the transaction or in the common dataspace. Moreover, a datum tested for presence within a transaction cannot be consumed by processes outside the transaction until the transaction commits. Concerning the test for absence operations, if the only occurrences of matching data have been withdrawn by another transaction, the operation will wait until that transaction commits before reporting an operation failure. Event noti cations performed within a transaction will receive noti cation of data productions occurring both within the transaction and in the common dataspace. When a transaction commits, all the event noti cations local to the transaction are dropped; moreover, the data produced, but not consumed, within that transaction become available in the shared dataspace, and are noti ed to event registrations performed outside the transactions.
In this paper we provide a formal investigation of the serializability of transactions in JavaSpaces. To this aim, we abstract away from the con- crete language, by embedding the coordination primitives in a process cal- culus equipped with a CHAM-like [1] operational semantics. 1 The proof of serializability relies on a stronger notion, similar to con ict serializability in databases [4]: a pair of consecutive operations, performed within two di er- ent transactions (or the rst outside any transaction and the second within a transaction), can be swapped without altering the nal result.
We start our investigation with a rst calculus, comprising the basic co- ordination primitives for data production, consumption and test for presence: in this case, the constraints on the semantics imposed by JavaSpaces speci - cations [6] are suÆcient to guarantee serializability of transactions.



1 To simplify the treatment, we also forbid nested transactions and we provide only suc- cessful termination (commit) of transactions.

Then, we extend the calculus with the test for absence operations, and we provide an example showing that the constraints imposed by [6] on these operations, although necessary, no longer suÆce to ensure serializability. We propose an improved, serializable semantics, obtained by adding further con- straints on data production and on test for absence operations.
Furthermore, to guarantee the serializability of the calculus extended with an event noti cation mechanism, we show that it is necessary to modify the semantics of noti cation operations performed within a transaction speci ed in [6].
In this paper we abstract away from timeouts, used in JavaSpaces to avoid undesired in nite blocking of processes. However, our examples of non- serializable transactions remain valid also in presence of timeouts.
To the best of our knowledge this is the rst work concerned with transac- tions in a shared dataspace coordination language containing test for absence and event noti cation primitives. A formal treatment of transaction serial- izability in the slightly di erent setting of shared variables (hence concerned with read and write primitives only) can be found in [2].


2	Transactions and the Basic Coordination Primitives

The JavaSpaces speci cations adopts the following lock mechanism for trans- actions: \When read, an entry is added to the set of entries read by the pro- vided transaction. Such an entry may be read in any other transaction to which the entry is visible, but cannot be taken". This policy in necessary in order to ensure serializability of transactions as described by the following example. Consider the con guration
hai j create(x ):read (a):take(b):commit(x ) j create(y):take(a):write(b):commit(y)
containing a datum a, a transaction x which reads datum a and consumes b, and a transaction y which removes a and then produces b.
If the above policy is not taken into account, the following non-serializable computation may be executed: the datum a is rst read inside the transaction x , and then consumed by the transaction y; after, the datum b is rst produced inside transaction y and then consumed inside transaction x ; at this point both the transactions may commit. This computation is clearly non-serializable because the two transactions cannot be executed atomically one after the other.
The remainder of this section is devoted to prove that the above policy is enough to ensure serializability of transactions in the case only the basic coordination operations read, write, and take are taken into account.

2.1	The calculus

Let Name be a set of data ranged over by a, b, :: :, Const be a set of program constants ranged over by K , K 0, :: :, and Txn a set of transaction names ranged over by x , y, :: :.  We use capital letters X , Y , :: :, to range over
}(Txn) (ie. the power-set of Txn); we represent sets and multisets with the
classical bracket notation, sometimes omitting the brackets in the case of singletons, ie. fx g is represented also with x .
Let Conf ranged over by P , Q, ::: be the set of the possible con gurations de ned by the following grammar:






where:
P ::= haiX j C j x fP g j x : C fP g j P jP C ::= 0 j  :C j C jC j K


  ::= write(a) j read (a) j take(a) j create(x ) j commit(x )

Con gurations are the parallel composition of available data, programs, and active transactions. Available data are modelled by terms haiX , where a de- notes the datum and X the set of active transaction from which the datum has been read (it is usually omitted when empty); this information is necessary to implement the transaction policy described above. Programs are represented by terms C containing the coordination primitives.
Active transactions are denoted in two possible ways: on the one hand, x fP g models a transaction with name x and involved programs and data described by the con guration P ; on the other hand, x : C fP g represents a transaction x containing a program C which is interested in performing a co- ordination operation requiring interaction with the environment outside the transaction. The second kind of notation is necessary to permit the interac- tion between operations performed inside a transactions and the environment external to the transaction: for instance, we use x : take(a):P fQg to denote a transaction x , containing a program which requires to consume a datum a outside the transaction.
To denote parallel composition we adopt the usual j operator; in the fol- lowing we use Qi Pi to denote the parallel composition of the indexed terms
Pi .
A program can be a terminated program 0 (which is usually omitted), a pre x form :P , the parallel composition of subprograms, or a program constant K .
A pre x can be one of the coordination primitives write(a), which in- troduces a new object hai inside the data repository, read (a), which tests for the presence of an instance of object hai, and take(a), which consumes an instance of object hai. We consider two further operations: create(x ) to start a new transaction, and commit(x ) for successful transaction termination.

Constants are used to permit the de nition of programs with in nite be- haviours. We assume that each constant K is equipped with exactly one de nition K = C ; as usual we assume also that only guarded recursion is used [7].
We use a structural congruence relation on con gurations to denote terms with a di erent syntax but representing the same con guration; this is denoted by  and it is de ned as the smallest congruence satisfying the following axioms
(i )  P j0  P	(ii ) P jQ  QjP
(iii ) P j(QjR)  (P jQ)jR   (iv ) C  K   if K = C (v ) x fC jP g  x : C fP g
comprising the standard axioms for parallel composition (i ){(iii ), the stan- dard axiom for program constants (iv ), plus an axiom used to permit to a program inside a transaction to move in a position which allows it to perform a coordination operation requiring interaction with the environment outside the transaction.
A transaction is started by a create operation and it is possibly terminated by a commitment operation, performed by all the involved processes. When performed within a transaction, a read operation may test for presence either a datum produced under that transaction or a datum in the external envi- ronment. As discussed above, when a datum is read within a transaction it cannot be consumed by processes outside that transaction. A take operation behaves in a similar way, and the selected datum is withdrawn from the datas- pace. A datum written within a transaction will not be visible to processes outside the transaction until the transaction commits; before commitment, this datum can be consumed by a process inside the transaction; in that case, the object will never become externally visible.
The semantics of the language is described by a labelled transition system (Conf , Label , !) where Label = fX: ; X: ; X:  j X 2 }(Txn); jX j  1g (ranged over by , , :: :) is the set of the possible labels; with abuse of notation we use  to denote also part of a label as in X :  . With x : we denote fx g :  and with  we represent ; :  . The label X :  denotes a standard computation step, while X :  and X :  the beginning and the end of a transaction, respectively. The labelled transition relation ! is the smallest one satisfying the axioms and rules in Table 1. Observe that rule (10) makes use of the function Data(Q) (used to denote the set of data available in the con guration Q) inductively de ned as follows:
Data(haiX ) = fag	Data(P jQ) = Data(P ) [ Data(Q) Data(C ) = Data(x fP g) = Data(x : C fP g) = ;
Axiom (1) indicates that hai; can be consumed by a process performing a take(a) operation; the subscript set of transaction names should be empty


(1) take(a):Pjhai; ! P
(2) read (a):PjhaiX ! PjhaiX
(3) write(a):P ! hai;jP
y: 
(4)  create(x ):P  ! yfP[y=x ]g	y fresh

(5)  x : take(a):PfQ gjhai	 x!: 
x : PfQ g	Y   fx g

(6)  x : read (a):PfQ gjhaiY
 x!: 
x : PfQ gjhaiY [fx g

(7) x fQ commit (x ):P j Q ha igj Q hb i	 x :! 
P X!:  P0
Qi Pi j Qj haj ij Qh hbh iYh nx

(8)


(9)


PjQ X!: P0jQ P ! P0
  = ; 

x fPg x!:  x fP0g


(10)


(11)
P x:!  P0

PjQ x :!   P0jQ
Q  P	P  ! P0	P0  Q 0


Q  ! Q 0

Data(Q ) = ;




Table 1
Operational semantics for the basic calculus (symmetric rules omitted).


because the datum should not be previously read within active transactions. Axiom (2) models the read operation (in this case the subscript set of trans- action names does not play any role). Axiom (3) indicates that the e ect of the execution of a write(a) operation is the production of the datum hai; (the subscript set of transaction names is initially empty).
Each active transaction is identi ed by a unique name; we model this naming mechanism by associating to each transaction a fresh name (i.e. a new name which has not been previously used in the agent). For the sake of simplicity, we do not formally model any mechanism to ensure the global freshness of names, however, standard mechanisms can be exploited which allow for the propagation of locally-fresh names.
When a new transaction is started by a program create(x ):P , a fresh name y is used to identify uniquely the new transaction; this name must be substi- tuted for x inside P . This is described in axiom (4) where P [y=x ] denotes the substitution of x with y inside P . Axioms (5) and (6) describe take and read operations, performed by processes inside a transaction, on data in the exter- nal environment; in the case of consumption, the removed datum should not be previously read within other active transactions (this is ensured by the side

condition Y  fx g); in the case of read, the name of the transaction should be added to the subscript set of transaction names associated with the read datum. Axiom (7) describes transaction commitment: the processes inside the transaction must agree on the commitment operation, the data produced inside the transaction become available to the external environment, and the name of the committed transaction should be removed from the subscript set of transaction names associated to the data in the external environment.
Rule (8) is the usual local rule, while (9) is the application of the local rule to transactions: observe that the transaction name is added to the label in order to denote the transaction under which the action is taken.  Rule
(10) indicates that a transaction commitment performed by the con guration
P can be performed also in P jQ provided that Q does not contain data; this side condition is necessary in order to ensure that all the data in the environment are taken into account by the axiom (7) which introduces the transaction commitment action. Finally, rule (11) is the standard rule for structural congruence.
It is worth noting that we do not x any constraints concerning the use of the transaction operations create and commit inside programs. For example, the set of con guration Conf comprises also the program commit(y):start(y) which requires to commit a transaction before it is created. However, the oper- ational semantics ensures that this kind of terms have no outgoing transitions (see the axiom (7)). Moreover, it is also worth noting that the operational semantics does not permit the execution of nested transactions, ie. transac- tions inside an outer transaction. Even if this a simpli cation, we claim that the results we prove on serializability apply also in a more general setting in which nested transactions are supported.


2.2  Serializability
Serializability is a generally accepted criterion for correctness of the execution of transactions. Given the interleaving execution of a set of transactions, it is serializable if the same result can be reached by a serialized execution of the transaction. An execution is serialized if all the actions taken inside the same transaction are executed sequentially, one after the other, without interleaving with actions outside the transaction:
In the following we need the following notation: txn(X: ) = txn(X: ) = txn(X: ) = X to denote the transaction names occurring in a transition label and actxn(P ) = fx  j 9C ; Q s.t. x fQg or x : C fQg is a subterm of P g to denote the set of the transactions active in a con guration.

 n
De nition 2.1 Given the transition sequence P  ! Pi  ! ::: ! Pn we
 
denote it also with P ! P 0 where  =   :::  n. The transition sequence
P  ! P 0, with actxn(P ) = actxn(P 0) = ;, is serialized i   = x :  implies

i+1
= x :  or  i
= x :   for i = 1;::: ; n  1. A transition sequence P  ! P 0

is serializable if there exists a permutation  0 serialized transition sequence.
of  such that P
0
 ! P 0
is a

The following lemma proves that each transition performed inside a trans- action can be delayed and executed after a subsequent transition, provided that the latter is performed outside the transaction.


 Lemma 2.2 If P !
P 00  ! P 0 with  = x :  0 where  0 6=  , and txn( ) 6=

txn( ) then there exists P 000 such that P ! P 000	 
P	0.

We are now ready to present the theorem which reports the serializability result for the calculus with the basic coordination operations only.


Theorem 2.3 Let P be a con guration and P  !1 such that actxn(P 0) = ;.
P 0 be a transition sequence

  If actxn(P ) = ; then there exists a permutation 2 of  1 s.t. P ! serialized.
P 0 is

  If actxn(P ) = fx g then there exist  2 and  3 s.t.  for each   2  2 then
 3
txn( ) = fx g,  2 3 is a permutation of  1, and P ! P 00 ! P 0 where
actxn(P 00) = ;.

3	Adding Test for Absence

In this section we extend the previous calculus with two further coordination primitives read 9 and take9 which are variants of the read and take operations which embed the possibility to test for the absence of matching data, respec- tively. These operations behave like the corresponding read and take only in the case the required datum is available for reading or consumption; other- wise, they terminate by indicating the absence of the required datum. These two coordination primitives correspond to the readIfExists and takeIfExists operations of JavaSpaces.
The two operations are guards for programs with two possible continua- tions: read 9(a)?P Q and take9(a)?P Q, where P is the continuation chosen in the case the operation succeeds, while Q is chosen if the required datum is not available.
Before presenting the formal syntax and semantics of the extended calcu- lus, we discuss some problems related to serializability.
Consider the following con guration in which a datum is required to be consumed within a transaction and tested for absence outside that transaction:
hai j create(x ):take(a):take(b):commit(x ) j read 9(a)?0 write(b)
Consider now the following computation: the consumption of hai inside the transaction occurs, subsequently the test for absence outside the transaction is performed; after, the datum hbi is rst produced and then consumed inside

the transaction; nally, the transaction commits. This computation is clearly non-serializable because the unique way to perform the test for absence and the output operation outside the transaction is to execute them after the take(a) but before the take(b) operations inside the transaction. This kind of problem is solved in JavaSpaces by avoiding the consumption of data taken within a transaction: these data are simply locked and they are removed only when the transaction commits. Locked data can be neither read nor consumed, and disallow the execution of operations testing the absence of data of that kind. We now discuss a further problem concerning serializability in the pres- ence of test for absence operations which is not addressed in the JavaSpaces
speci cations.
Consider the con guration
create(x ):take9(a)?0  (take(b):commit(x )) j write(a):write(b)
and its following computation: the transaction starts, the take9(a) opera- tion tests the absence of a and activates the continuation take(b):commit(x ); subsequently the two output operations outside the transaction are executed;
 nally the input operation inside the transition occurs and the transaction
commits.
This computation is clearly non-serializable because the unique way for the transaction to commit is that the two write operations outside the transaction are executed exactly between the test for absence and the input operation inside the transaction. To solve this problem we propose the following further lock policy: after a test for absence is performed inside a transaction on a certain kind of data, no data of that kind can be introduced in the shared dataspace before the end of the transaction.
This new constraint forbids the execution of the write(a) operation in the computation described above. On the other hand, it does not forbid the exe- cution of output operations performed inside transactions; indeed, data pro- duced inside transactions are not introduced in the globally shared dataspace until the transaction commits. For example, in the con guration
create(x ):take9(a)?0  (take(b):commit(x )) j
create(y):write(a):take(a):write(b):commit(y)
the write(a) operation inside the transaction y could be executed even after the test for absence in transaction x .
Consider now a similar con guration in which the datum hai produced inside the transaction y is not removed before the transaction commits:
create(x ):take9(a)?0 (take(b):commit(x )) j create(y):write(a):write(b):commit(y)
In this case the transaction y cannot commit if the test for absence inside
transaction x has been already performed due to the lock policy we have adopted; indeed, if the transaction commits, the emitted datum hbi should be

(30) write(a):P ~a! haijP
(40) create(x ):P y:  yfP[y=x ]g;


y fresh

 !
(50) x : take(a):PfQ gR jhaiY
;
 x!: 

x : PfQ gR[a


x : j aj 

Y   fx g

(70) x fQ
commit (x ):Pi j Q haj igR j Q hbh iY
   !

i	j	T	h	h
Qi Pi j Qj haj ij Qh hbh iYh nx
(12) take9(a)?P Q jhai ! P
(13) read 9(a)?P Q jhaiX ! PjhaiX
(14) take9(a)?P Q :!a Q
(15) read 9(a)?P Q :!a Q

(16) x : take9(a):P Q fRgR jhaiY
 x!: 
x : PfRgR[a
Y   fx g

(17) x : read 9(a):P Q fRgR jhaiY
 x!: 
x : PfRgR jhai

Y [x


(18)
P X :!:a P0
PjQ X :!:a P0jQ

a 62 Data(Q ) [ Rem(Q )


(19)
P :!a P0


x fPgR x :!:a x fP0gR


(20)


(21)


(22)
T
P x :A!  P0
PjQ x :A! P0jQ P ~a! P0
PjQ  ~a! P0jQ
P  ~a! P0
T [fag

Data(Q ) = ; and A \ Tfa(Q ) = ;


a 62 Tfa(Q )

x fPgR x!: 
x fP0gR




Table 2
Operational semantics for test for absence (symmetric rules omitted).

introduced in the globally shared dataspace and this cannot happen due to the lock introduced by the previously executed test for absence operation.
We are now ready to present the formal syntax and semantics of the cal- culus with test for absence. Formally, the two new operations are introduced as guards for programs with two possible continuations:




where:
C ::= ::: j  ?C C


  ::= read 9(a) j take9(a)

Moreover, we have to add two kinds of information to active transactions: the set of data tested for absence and those removed during the transaction. This is achieved by using the new con gurations:
P ::= ::: j x fP gR  j x : C fP gR
where R; T 2 }(Name) are two sets of data representing the kind of data removed and tested for absence inside the transaction, respectively.
The new set of con gurations is denoted by Conf9; while the new set of labels is denoted by Label9 = Label [ fX::a; X:~a; X:A   j X : }(Txn); a	2
Name; A  Nameg. The rst label is used to model test for absence operations on datum a, the second label denotes the execution of a write(a) operation, while the third label is the new label for transaction commitment indicating also the multisets of data which have been produced, but not consumed, dur- ing the transaction and should be introduced in the shared repository after transaction commitment.
The rule (v ) of the structural congruence  should be modi ed according to the new syntax:

(v 0) x fC jP gR   x : C fP gR
T	T
The operational semantics is de ned by the labelled transition system (Conf9, Label9, !) where the labelled transition relation ! is the smallest one satisfying the axioms and rules in Table 1 and in Table 2 where (30), (40) (50), and (70) are substituted for the corresponding rules in Table 1. The rules
(18) and (20) use the two functions Rem(P ) and Tfa(P ), denoting the set of
data removed and those tested for absence inside transactions active in the con guration P , respectively. They are inductively de ned as follows:

Rem(x fP gR ) = Rem(x : C fP gR ) = R	Tfa(x fP gR ) = Tfa(x : C fP gR ) = T
T	T	T	T

Rem(P jQ) = Rem(P ) [ Rem(Q) Rem(C ) = Data(haiX ) = ;
Tfa(P jQ) = Tfa(P ) [ Tfa(Q) Tfa(C ) = Tfa(haiX ) = ;

Axiom (30) introduces the new label ~a denoting the execution of a write(a) operation. Axioms (40) and (50) are the adaptations of the corresponding rules to the new syntax; in particular, (50) updates the set of data removed from the environment by input operations inside the transaction. Axiom (70) intro- duces the new label X:A  (the notation  j aj denotes the multiset union of all the singletons faj g).
Axioms (12) and (13) describe the successful execution of the new take9(a) and read 9(a) operations, respectively. These new operations fail when no datum hai is found in the environment; this is modelled by the label :a introduced by the axioms (14) and (15). Axioms (16) and (17) are adaptations

of (12) and (13) to the case in which the operations are executed inside a transaction; in (16) the set of data removed inside the transaction is updated, while in (17) the subscript set of transaction names associated to the read datum is extended with the name of the current transaction.
A transition labelled with :a, representing a test for absence of a, can be performed only if the environment does not contain any hai and also no hai have been previously consumed inside an active transaction (see rule (18)). Moreover, when a test for absence is performed inside a transaction, the sub- script set T of data tested for absence must be updated (see rule (19)). Ac- cording to rule (20) a transaction can commit only if the data it introduces in the shared repository are not currently tested for absence inside other active transactions; moreover, the side condition Data(Q) = ; ensures that all the data available in the environment when a transaction commits are taken into account by the rule (70) (which introduces transaction commitment). Rule
(21) ensures that an output operation of hai is performed only if active trans-
action exists which already tested for the absence of that kind of datum. On the other hand, this output operation can be performed if executed inside a transaction (see rule (22)).
The lock policy that we propose ensures the serializability of transaction; this is formally proved by the fact that the Lemma 2.2 and the Theorem	2.3
hold also in the new calculus extended with test for absence.


4  Adding Event Noti cation

In this section we extend the calculus with an event noti cation mechanism inspired by the notify primitive of JavaSpaces.
The syntax of the kernel language is simply extended with a new pre x:

  ::= :::	j  notify(a; C )
The new program notify(a; C ):P can register its interest in the future in- coming arrivals of the data of kind a, and then receive communication of each occurrence of this event. When this event occurs, a new instance of the program C is activated as reaction to the event. This behaviour can be modelled by introducing a new term on(a; C ), which is a listener that spawns an instance of program C every time a new object hai is introduced in the dataspace. Formally we extend the con gurations as follows:
P ::= :::	j  on(a; P )
The new set of con gurations is denoted with Confn.
According to the JavaSpaces speci cation \a notify ... applies to write operations that are committed to the entire space. A notify performed under a ... transaction additionally provides noti cation of writes performed under that transaction." Following this approach a listener inside a transaction has


(23) notify(a; P):Q  ! on(a; P)jQ
(300)  write(a):Pj Qi on(a; Pi )  ! haijPj Qi (Pi jon(a; Pi ))

(700)  x fQi
commit (x ):Pi j Qj haj ij Qk
on(ck ; Rk )gR j Qh
hbh iYh
j Ql
on(dl ; Ql )



(2000)
x : j aj 
    ! Qi Pi j Qj haj ij Qh hbh iYh nx j Ql (on(dl ; Ql )j Q( j aj )(dl ) Ql )
x :A	0
Data(Q ) = ; and A \ Tfa(Q ) = ;



(2100)
PjQ x :A!  P0jQ
P  ~a! P0


PjQ  ~a! P0jQ
and A \ On(Q ) = ;

a 62 Tfa(Q ) [ On(Q )




Table 3
Operational semantics for event noti cation (symmetric rules omitted).

visibility of new data produced also outside that transaction. For example in the con guration
create(x ):notify(a; commit(x )) j write(a)
the transaction may commit.  Indeed, consider the following computation:
 rst the transaction is started, then the notify operation produces the lis- tener on(a; commit(x )); then the output operation outside the transaction is executed and activates as reaction the program commit(x ) inside the transac- tion; at this point the transaction may commit. This computation is clearly non-serializable because the transaction can commit only if the output opera- tion outside the transaction is performed after the notify operation inside the transaction.
To tackle this problem, we propose to change the semantics of event noti-
 cation performed inside transactions: a notify operation performed under a transaction applies only to write operations committed inside the same trans- action.
In order to prove that transaction serializability is now satis ed we de ne the following formal semantics: (Confn; Labeln; !) where the labels are the same as those of the calculus with test for absence Labeln = Label9 and the transition relation ! is de ned by the axioms and rules in Table 1, in Table 2, and in Table 3, where (300), (700), (2000), and (2100) are substituted for the corresponding rules in the previous tables.
The unique new axiom is (23) which produces a listener as e ect of the execution of a notify operation. The other rules are adaptations of previous rules: (300) noti es to listeners the occurrence of a write operation; whereas, (700) noti es the introduction of all the data produced by a transaction which is currently under commitment. As for (70) the notation j aj denotes the multiset union of all the singletons faj g; here, we use also (  j aj )(dl ) to denote

the number of occurrences of dl inside the multiset ( j aj ).
The rules (2000) and (2100) use a new function On(P ) which returns the set of data on which there exist listeners active in the con guration P ; it is inductively de ned as follows:
On(on(a; C )) = fag	On(P jQ) = On(P ) [ On(Q)
On(C ) = On(haiX ) = On(x fP gR ) = On(x : C fP gR ) = ;
T	T
This function is used in order to ensure that no other listeners exist in the environment which could be interested in data produced by a write operation (rule (2000)) or by a committed transaction (rule (2100)).
The semantics we propose ensures the serializability of transaction as the Lemma 2.2 and the Theorem 2.3 hold also in the complete calculus comprising both the test for absence and the event noti cation operations.


References

[1] G. Berry and G. Boudol. The Chemical Abstract Machine. Theoretical Computer Science, 96:217{248,	1992.
[2] N. De Francesco, U. Montanari, and G. Ristori. Modelling Concurrent Accesses to Shared Data via Petri Nets. In Proc. Programming Concepts, Methods and Calculi (PROCOMET), pages 403{422. Elsevier Publisher, 1994.
[3] E. Freeman, S. Hupfer, and K. Arnold. JavaSpaces Principles, Patterns, and Practice. Addison-Wesley, 1999.
[4] H. Garcia-Molina, J.D. Ullman, and J. Widom. Database System Implementation. Prentice-Hall, 2000.
[5] D. Gelernter. Generative Communication in Linda. ACM Transactions on Programming Languages and Systems, 7(1):80{112,	1985.
[6] Sun  Microsystems.	JavaSpaces Service Speci cation, available at http://java.sun.com/products/javaspaces.   1998.
[7] R. Milner. Communication and Concurrency. Prentice-Hall, 1989.
[8] G.A. Papadopoulos and F. Arbab. Coordination Models and Languages. Advances in Computers, 46:329{400,	1998.
[9] P. Wycko , S. McLaughry, T. Lehman, and D. Ford. T spaces. IBM Systems Journal, 37(3):454{474,	1998.
