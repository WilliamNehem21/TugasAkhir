

Electronic Notes in Theoretical Computer Science 255 (2009) 3–21
www.elsevier.com/locate/entcs

Model-checking Web Services Orchestrations using BP-calculus
Faisal Abouzaid and John Mullins
CRAC Lab., Computer & Software Eng. Dept., E´cole Polytechnique de Montr´eal.
P.O. Box 6079, Station Centre-ville, Montreal (Quebec), Canada, H3C 3P8. 2

Abstract
The Business Process Execution Language for Web Services (BPEL) is the standard for implementing orchestrated business processes designed but not limited to, as web services. BPEL is a powerful language but lacks a widely accepted formal semantics, and this makes it difficult to formally validate the correct execution of BPEL implementations. In the other hand, process algebras have proved their efficiency in the specification of web services orchestrations. In this paper we improve the BP-calculus, a π-calculus based formalism designed to ease the automatic generation of verified BPEL code, by defining specific equivalence and logic in order to verify BPEL implementations through their formal specification expressed in this calculus. The formal specification of service-oriented applications allows the checking of functional properties described by means of the new logic, that is shown to be well suited to capture peculiar aspects of services formalized in π-like languages. As an illustrative example, we present the BP-calculus specification and the verification results of a trade market service scenario.
Keywords: Web Services; Orchestration languages; BPEL; Process algebras; π-calculus


Introduction
Web services represent a well accepted implementation of service-oriented com- puting (SOC)and their composition allows for the creation of customized complex applications based on reutilization and composition of existing services. Orchestra- tions describe the way in which separate Web Services can be brought together in a consistent manner to provide a higher value service. Business Process Execution Language for Web Services (BPEL) [12] is the widely accepted standard that per- mits to define the business logic between processes interacting in an orchestration. A BPEL process defines how multiple service interactions between partners can be coordinated internally, that is their orchestration, in order to achieve a business goal.

1 Research partially supported by the author’s NSERC grant (Canada)
2 Email: m.abouzaid,john.mullins@polymtl.ca

1571-0661 © 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.10.022

Since bad orchestration will result in bad and unprofitable services, it is impor- tant to have tools and means to ensure the correctness of such compositions. Current software engineering technologies for SOC, do not support verification tools and lot of researches are devoted to this purpose. However, existing researches tend to pro- vide a formal semantics for BPEL, expressed in terms of various formalisms such as Petri nets, abstract state machines (ASM) or process algebras. But except the work in [17] and [3], none of them provides a way to realize a refinement process or the re-engineering of existing BPEL implementations.
Process algebras (PAs) and associated logics allow a design time verification of the model behavior and strengthen the correctness of service compositions [16] because they are based on solid theoretical concepts. One of the most relevant method is the rich theory of the π-calculus [10] because of its capacity to model mobility, by passing channel names, as data, through channels.
Our objective is to create a system based on a π-like formalism that allows the property checking of real-world business processes and also for the generation of readable and verified BPEL code. Moreover the same approach is used to verify and correct existing BPEL specification by extracting abstract representation from existing implementations.
In order to analyze SOC applications, it is convenient to exploit a logic with modalities indexed by π-calculus actions such as the π-logic [5].
Once the formal specification of the system is verified and validated, the cor- responding BPEL code is automatically generated and proved to be correct and complete.

Contributions:
This article provides some theoretical basis for the encoding of BP-processes into readabable BPEL code. For the sake of readability of the generated BPEL code, we need to choose the best suited construct that reflects intentions of the designers. For this purpose, the BP-calculus uses annotations on selected constructs. The novel contribution in this paper is to define an equivalence relation a logic (the BP-logic) that are proved to be adequate. Finally, we illustrate the usability of the encoding by providing examples of non trivial properties of a case study we checked with the HAL-Toolkit [5].

Related works:
Numerous works have been devoted to the formal specification of business pro- cess languages, especially BPEL, using different formalisms such as Petri Nets ([17]) or Abstract State Machines ([4]). But the more promising approaches use process algebras and several formalisms based on PA have been proposed: SOCK [7], COWS [8], each one handling particular features of the problem. The framework we present is based on the π-calculus, and differ from the cited approaches since it focuses on a lower level of abstraction and is closer to BPEL.
In [3] authors present a two-way mapping between BPEL and LOTOS that is limited to some basic constructs of BPEL and no formal proof of the correctness of

the mapping is provided, arguing the lack of a semantics for BPEL.
Lucchi and Mazzara [9] provided the first π-calculus based semantics to BPEL by defining a formalism called webπ, tailored to study a simplified version of the scope construct of BPEL. We base our study on this semantics.


Structure of the paper:
This paper is organized as follows. Section 2 introduces some preliminaries e.g. syntax and semantics of the BP-calculus (Section 2.2) and the logics (Section 3.2). In Section 3 we present the behavioural properties of the BP language. Section 4 presents the verification framework that is used in Section 5 to verify the illustrating example and to present the results of the verification. In Section 6 we conclude and provide and some directions for future works.

Preliminaries
BPEL
BPEL [12] is an XML-based specification language for describing business processes orchestrating the interaction of different, existing and possibly dynamically emer- ging Web Services. As such, it builds on top of the WSDL language for describing the interface of Web Services. This is specified in terms of port types, actions, and messages. BPEL supports the definition of two types of processes: executable and abstract processes. An abstract, (not executable) process is a business protocol, specifying the message exchange behavior between different parties. An executable process, specifies the execution order between a number of activities. However, in this paper we will mainly refer to executable BPEL processes.
Activities describe the precise behavior of the business process. Basic activ- ities include activities such as sending (invoke), receiving (receive) requests and replies (reply ), which can specify one or more existing correlation sets they must adhere to, or new correlation sets to be initialized. Among other basic activities, there are variable assignment (assign), synchronization of internal concurrent ac-
tivities through private source and target links (links), waiting for a timeout (wait ), and raising faults (throw ). Structured activities realize sequential composition (se- quence), guarded choice (pick ), parallel composition (flow ), iteration cycles (while, foreach and repeat ), and conditional (if then else).

The BP-calculus
The π-calculus is sufficient to reason on orchestrated services. However, this could be very difficult and confusing. This the reason why we introduce other orchestra- tion primitives in a variant of the π-calculus we call the BP-calculus. We present in this section its syntax and operational semantics.

Terms
t	::=	x	(variables)
|	u	(names)
|	f (t1,... tk)	(tuple)
C	::=	null | C[x˜ ← t]	(correlation set) Processes :
P, Q	::=	IG	(input guard )
|	ct⟨M⟩.P	(annotated output)
|	τ.P	(silent action)
|	P|Q	(parallel composition)
|	P dc(M ) Q	(sequential composition)



Guarded choice :
|	A(x1,..., xn)	(service definition)
|	[C : P ]c(x˜).A(y˜)	(instance spawn)
|	S	(scope)

IG	::=	0	(empty process)
|	cs(u).P	(annotated input)
|	IG + IG'	(guarded choice)
|	if M = N then IG else IG	(conditional)
|	[x˜ ← f (M1, ..., Mn)]IG	(function evaluation)
Scopes :
S	::=	{x˜, P, H}	(scope)
H	::=	i Wi(Pi1 , ··· , Pini )	(handlers)
Table 1
BP-calculus Syntax

Syntax of the BP-calculus
Terms: The set of terms T consists of variables V, names N and values (U ) (integers, booleans, strings, ...). For each term t, fv(t) is the set of variables in t. A message is a closed term (i.e. not containing variables). The set of messages is denoted M.
Functions: Functions model primitives that manipulate messages:  F ⊆
[Mk → Mn].
Syntax: We let x˜ = (x1, ..., xn), (resp. a˜ = (a1, ..., am), u˜ = (u1, ..., um)) range over the infinite set of n-tuples of variable (resp. name, value) identifiers. We denote x˜ ← u˜ the assignment of values u˜ to variables x˜.
Table 1 introduces the syntax of the BP-calculus.

Interpretation
The intended interpretation of the processes is as follows:
IG is an input guarded process and IG + IG' behaves like a guarded choice and is intended to be translated by a <pick>.
at⟨M⟩ (t ∈ {invoke, reply, throw}) is the usual output which can be an invoca- tion, or a reply to a solicitation, or the throw of a fault, and are translated by a an <invoke>, <reply> or a <throw>, respectively . The annotations on input or output operations are used to ease the translation into BPEL.
τ is the silent action. This action is useful to modelize communication. Altough BPEL does not provide a silent action, it can be easily specified by means of a

sequence and an aempty process.
P|Q is the parallel composition of processes P and Q. However the sequential operator imposes that the process A = P|Q terminates when both P and Q terminate.
P dc(M ) Q expresses a sequential composition from process P passing M to Q (Q can perform actions when P has terminated). M carries binding information between proccesses P and Q. This construct allows to easily mimic the ’s element
<sequence>.
if then else expresses a classical choice based on messages identity is intended to be translated by an if then else construct in BPEL 2.0.
C is a correlation set, i.e a set of specific valued variables within a scope act- ing as properties and transported by dedicated parts of a message. Its values, once initiated, can be thought of as an identity of the business process instance. Intuitively, [C : P ]cA(x˜).A(y˜) (Instance spawn) represents an orchestration ser- vice running a process defined as cA(x˜).A(y˜). A reception of a message M over the dedicated channel cA causes a new service instance (defined as A(y˜)) to be spawned. The process P represents the parallel composition of service instances already spawned, C the correlation set characterizing instances and y˜ the corre- lation part of M .
[x ← f (M1, ..., Mn)]P assigns the value f (M1, ..., Mn) to variable x before ex- ecuting process P . For instance, [x ← build(M1, ..., Mn)]c⟨x⟩ means that the n-tuple M is built from components M1, ..., Mn before being sent over the chan- nel c.
A scope is a wrapper for variables, a primary activity and handlers represented as contexts.
Let S ::= {x˜, P, H} be a scope, with handlers H ::=  i Wi(Pi1 , ··· , Pini ).
Then,
x˜ are the local variables of the scope, and P its primary activity,
H is the scope’s execution environment that is modeled as the parallel com- position of handlers Wi. Each handler is a wrapper for a tuple of processes P = (P1,..., Pn) that correspond to the activities the handler has to run when invoked. Not all handlers are mandatory.
Wi(Pi1, ··· , Pini ) is the process obtained from the multi-hole context
Wi[·]1 ··· [·]ni by replacing each occurrence of [·]j with Pij.
Note that the case where the variable x is restricted to a simple process P and that no handler is defined within the scope, corresponds to the usual restriction

of the π-calculus that is denoted (νx)P ; that is (νu˜)P d=ef
{u˜, P, 0}. In this

case, c⟨νn⟩ where c, n are names will denote a bound output action.
Due to the lack of place, we refer the reader to [1] for the handlers’ syntax.


P | 0 ≡ P	P | Q ≡ Q | P	P | (Q | R) ≡ (P | Q) | R
{u˜, P, ∅} ≡ (νu˜)P	{u˜, {v˜, P, ∅}, ∅} ≡ {v˜, {u˜, P, ∅}, ∅}
{u˜, P, ∅} | Q ≡ {u˜, P | Q, ∅} (∀ i ui /∈ fn(Q))
{x˜, P, H} | {x˜, Q, H'} ≡ {x˜, Q, H'} | {x˜, P, H}	{x˜, P, H} | 0 ≡ {x˜, P, H}
{x˜, P, H} | `{x˜, Q, H'} | {x˜, R, H''}´ ≡ `{x˜, P, H} | ({x˜, Q, H'}´ | {x˜, R, H''}
P Qc(M ) 0 ≡ P	0 Qc(M ) P ≡ P
P Qc(M ) (Q Qc(M' ) R) ≡ (P Qc(M ) Q) Qc(M' ) R
(IG1 + IG2) Qc(M ) P ≡ IG1 Qc(M ) P + IG2 Qc(M ) P
[C : P ]cA(x˜).A(y˜) ≡ [null, C : P ]cA(x˜).A(y˜)
[C : P ]cA(x˜).A(y˜) Qc(M ) [C : Q]cB(x˜).B(y˜) ≡ [C : Q]cB(x˜).B(y˜) Qc(M ) [C : P ]cA(x˜).A(y˜)

Table 2 Structural Congruence.


Operational Semantics
The structural congruence is the smallest equivalence relation closed under the rules in Table 2. The first six rules are standard rules of the π-calculus. All the other rules but the last are about the sequence and scopes and we refer the reader to [1] for detailed comments. The last rule is closely related to the semantics of correlation set update (rule C-SPF in Table 3) which guarantees uniqueness of each running instance. Also, the last rule ensures that the correlation sets C and null, C will be considered as equal along this recursive process.
The operational semantics of the BP-calculus is a labeled transition system gen- erated by inference rules given in Table 3. Note that the sequential operator implies to introduce a termination predicate denoted (C), e.g P terminates  ⇔ P C. The
semantics of this operator is given by: if sC and s →α s' then s'C.
Rules SCO, HAN and S-PAR define the behavior of scopes and handlers. These con- structs are defined as multihole contexts. Thus, they can be derived from previous rules since handlers are processes. Rules IFT-M and IFF-M model the conditional. Rule EVAL handles function evaluation.
Rules C-SP1, C-SPT and C-SPF cope with correlation mechanisms. Actually, the construct [C : P ]c(x˜).A(y˜) may be viewed as an indexing replication. While rule C-SP1 allows a spawned service P to execute as standalone service, rule C-SPT handles the initial spawning of an instance and the initialization of a correlation set after a reception. Rule C-SPF manages the subsequent instance creation. The correlation set C is updated and an instance of P is created that runs concurrently with existing ones.
The other rules are standard semantic rules of π-calculus ([10] , [14]).


Equivalences
Process creation and sequentiality operations need a special attention since they induce nontrivial questions of variable scope.



au  '

a(u)
P
aνu  '

Open	P −→P  a/=u
(νu)P −aν→uP '
RES	P →α P' n/∈fn(α)∪bn(α) (νn)P →(νn)P
OUT
ct⟨M⟩.Pc(M⟩P
Close

TAU IN
 −→P  Q−→Q u/∈fn(P )
P|Q−τ→(νu)P '|Q'

τ.P →τ P

c(M )
c(x).P → P{M/x}

PAR	P →α P' bn(α)∩fn(Q)=∅ P|Q→P |Q
P≡P'	P'→α Q'	Q≡Q'


SYNC	P →α P' Q→α Q'
P|Q →P |Q
Pi→α P' i∈{1,2}

STRUCT	α	CHOICE	i  α

P→Q
P1+P2→P'

DEF	P{y˜/x˜} →α P' A(x˜)=P


A(x˜) →α P'
SCO	P →α P'

HAN	H→α H'


{x,P,H}→α {x,P',H}	{x,P,H}→α {x,P,H'}

S-PAR	P →α P'	Q→α Q'
{x,P,H1}|{x,Q,H2} →τ {x,P',H1}|{x,Q',H2}

IFT-M	P →α P' M =N
if (M =N ) then P else Q→P
IFF-M	Q→α Q' M/=N
if (M =N ) then P else Q → Q'

EVAL
M˜ =f (M1,...,Mn) P{M˜ /x˜}→α P'

[x˜←f (M1,...,Mn)]P →α P'
C-SP1	P →α P'
[C:P ]cA(x˜).A(y˜)→α [C:P']cA(x˜).A(y˜)

C-SPT	createInstance(M )=true  [z˜←u˜]=correlationP art(M )
cA(M )
[null:0]cA(x˜).A(y˜)	[[z˜←u˜]:A(u˜)]c (x˜).A(y˜)
C-SPF	createInstance(M )=true  [z˜←u˜]=correlationPart(M ) [z˜←u˜]/∈C
cA(M )
[C:P ]cA(x˜).A(y˜)	[C,[z˜←u˜]:P |A(u˜)]c (x˜).A(y˜)

Table 3
Operational semantics of the BP-calculus.

Bisimulation and congruence
In this section we develop formal reasoning mechanisms and analytical tools for checking that the BPEL services resulting from an automatic code generation meet desirable correctness properties and do not manifest unexpected behaviors. A stan- dard approach is the use of a bisimulation equivalence ([15], [11]).
Definition 3.1 A binary relation B over a set of BP-processes is a simulation if, whenever P B Q, we have that :
if P  →α  P' and f n(P, Q) ∩ bn(α) = ∅, then there exists Q’ such that Q →α  Q'
and P’ B Q’.
if P C then QC
Relation B is a bisimulation if both B and B−1 are simulations.
Two agents P and Q are bisimilar, written P ∼. bp Q if P R Q for some bisimu- lation R. We call relation ∼. bp bisimilarity.
The side condition (f n(P, Q) ∩ bn(μ) = ∅) ensures that there is no free name captured in both processes.

The condition on process termination is added to handle the specific case of the spawn operator. Indeed, two processes are equivalent if they have the same behavior, and in particular if they terminate. The termination predicate (C) induces a new behavior since terminated terms may at the same time still perform actions if they are spawned off as parallel processes as shown in the following example.
Example 3.2 Let A = a ⟨⟩ the process to be spawned and [[1] : 0]cA(M ).a ⟨⟩
the first spawned instance. Without the condition on the termination predicates
we would have [[1] : 0]cA(M ).a ⟨⟩ ∼.  a ⟨⟩, where ∼.  is the standard bisimilarity,
but these terms generate different behavior in the context of sequential composition:

	

[[1] : 0]c
(M ).a ⟨⟩ D b	b⟨⟩ [[1] : 0]c (M ).a ⟨⟩ D 0 but a ⟨⟩ D b
b⟨⟩.

A		⟨⟩ →	A			⟨⟩ →/
When mobility is involved, e.g. when it is possible to communicate channel names, the bisimulation is not always preserved because of input actions. As a consequence, the bisimulation is not a congruence.
This lack of congruence of prefixing w.r.t. standard bisimilarity ∼. is well-known
from the π-calculus. For instance, x(z).0 | y ⟨z⟩ .0 ∼.	x(z).y ⟨z⟩ .0 + y ⟨z⟩ .x(z).0
but y(z).0 | y ⟨z⟩ .0 ∼/ .  y(z).y ⟨z⟩ .0 + y ⟨z⟩ .y(z).0 since both processes are discrim-
inated by a τ -derivation.  Thus w(x). (x(z).0 | y ⟨z⟩ .0)	/∼.	w(x). (x(z).y ⟨z⟩ .0 +
y ⟨z⟩ .x(z).0) since the name y may be received on w. Hence, there is a context,
w(x).[·], not preserving the bisimulation. Consequently, the same remark applies to
∼. bp.
The bisimilarity ∼. bp not being preserved by input prefixing forces to define the
largest congruence .	included in:
Definition 3.3 Two processes P and Q are congruent (denoted P  .	Q) if for
any substitution σ = [y1/x1, ...yn/xn] we have: Pσ ∼. bp Qσ, where Pσ is P with
yi = σ(xi) substituted to xi for every xi ∈ f n(P ).
However, we are interested to check whether crucial properties (such as a variety of safety and liveness properties) hold. We, thus, need to introduce a logic that is adequate (see definition 3.4) w.r.t the congruence.

The pi-logic
The π-logic permits to formally and unambiguously specify the behavior of a system written in the π-calculus. This logic has been introduced in [5] to express temporal properties of π-processes. It adds the possible future modalities EFφ and EF{χ}φ modalities to the modalities for strong next EX and weak next < μ > modalities defined by Milner [11]. Syntax of the π-formulas is:
φ ::= true | ∼ φ | φ & φ' | EX{μ}φ | EFφ | EF{χ}φ
where μ is a π-calculus action and χ could be μ, ∼ μ, or  i∈I μi and where I is a finite set.
The semantics of the π-formulae is given below:

P |= true for any process P ;
P |=∼ φ iff P |= φ;
P |= φ ∧ φ' iff P |= φ and P |= φ' ;
P |= EX{μ}φ iff there exists P' such as P	μ




P' and P' |= φ (strong next);

P |= EFφ iff there exists P0, ..., Pn and μ1, ..., μn, with n ≥ 0, such as P =

μ
P0 −→ P1...
−→ Pn and Pn |= φ. The meaning of EFφ is that φ must be true

sometimes in a possible future.
P |= EF{χ}φ if and only if there exists P0, ..., Pn and ν1, ..., νn , with n ≥ 0, such
that P = P0 −ν→1	P1... −ν→n	Pn and Pn |= φ with:
χ = μ for all 1 ≤ j ≤ n, νj = μ or νj = τ ;
χ =∼ μ for all 1 ≤ j ≤ n, νj /= μ or νj = τ ;
χ =	i∈I μi : for all 1 ≤ j ≤ n, νj = μi for some i ∈ I or νj = τ .
The meaning of EF{χ}φ is that the truth of φ must be preceded by the occurrence of a sequence of actions χ.
Some useful dual operators are defined as usual: φ ∨ φ, AX{μ}φ, < μ > φ 
(weak next), [μ]φ (Dual of weak next), AGφ (AG{χ}) (always).
π-logic formulae are expressive enough to naturally specify and verify liveness and safety properties and others.
The BP-logic
Since we are working on BP-calculus specifications we need to adapt the π-logic to this language. For this purpose, we only need to extend the logic to handle the termination predicate, introducing therefore the BP-logic.
The syntax of the BP-logic is:
φ ::= true | C | ∼ φ | φ & φ' | EX{μ}φ | EFφ | EF{χ}φ
where μ is a π-calculus action and χ could be μ, ∼ μ, or  i∈I μi and where I is a finite set.
The interpretation of the logic formulæ defined by the above syntax is the same as the interpretation of the π-formulæ extended with the explicit interpretation of the termination predicate C:   P |= C iff P C.

Adequacy
The adequacy allows the checking of the bisimulation rather than checking each property separately and thus is useful for the refinement process, since a process may be subtitued to an equivalent one with preservation of desired properties.
Definition 3.4 [Adequacy] A logic L is adequate with respect to, a relation (R) defined on a given process language P, if
(∀φ ∈ L, ∀P, Q ∈ P, P |= φ ⇔ Q |= φ) ⇔ P R Q

That is, P R Q if and only if P and Q satisfy the same formulae.

Let Th(P ) = {φ : P |= φ}, and the relation be the congruence ( .	), thus the
previous requirement is written: P .	Q  ⇔  T h(P ) = T h(Q) that is a strong
requirement ; while weak adequacy is defined by : P .	Q  ⇒ Th(P ) = Th(Q)
It has been proved [6] that the π-logic is adequate with respect to the strong early bisimulation equivalence [11] of the π-calculus. This means that two π-calculus agents satisfy the same properties that can be expressed in the π-logic provided that they are early bisimilar. We may extend the result to the congruence ( . ) since it
is included in the bisimulation.
At this stage, we need to prove the weak adequacy of the BP-logic w.r.t .	.
Since the BP-calculus differs from the π-calculus only by the sequential composition and process spawn operators, we only need to study the effect of these two operators on the adequacy.
Theorem 3.5 The BP-logic is (weakly) adequate w.r.t congruence ( .	).
The proof is based on the result of [6] that states the adequacy of the π-logic w.r.t the strong early bisimulation of the π-calculus. In fact, we only need to examine the sequential operator and the instance spawn. We also need to analyze the effect of the termination predicate on the adequacy.
If P and P' are two BP-processes not containing sequential operator nor instance spawn, one can apply the results of [6]. Now, let’s see what happens with these two operators:
Sequential operator :
Let P and P' such as P  .	P' and P |= φ, therefore P' |= φ (induction

hypothesis). But P .

P'	⇒

P dc(M )
.
Q  bp

P' d


c(M )
Q due to the definition of the

congruence and by applying rule SEQ1 of the operational semantics. We reason by induction on each modality of the BP-logic.
· By definition of EX{μ}φ, P dc(M ) Q |= EX{μ}φ, means that ∃μ such as P dc(M )
Q μ	.	'
→ P1 dc(M ) Q and P1 dc(M ) Q |= φ. But P dc(M ) Q  bp P dc(M ) Q implies that

P' d
Q μ	'	.	'

c(M )
→ P1 dc(M ) Q and P1 dc(M ) Q  bp P1 dc(M ) Q. From the induction

hypothesis we deduce that P' dc(M ) Q |= φ. Finally : P' dc(M ) Q |= EX{μ}φ.

· By definition of EFφ, a path P d 
Q →α1 P  d
Q →α2 ... αk P  d
Q of

c(M )
1  c(M )
→	k  c(M )

length k ≥ 0 exists such that Pk dc(M ) Q |= φ .

But P dc(M )
.
Q  bp
P' dc(M )
Q implies that P' dc(M )
Q →α1 P' d
c(M )
Q →α2 ... αk

P' d
c(M )
Q and P' d
c(M )
.
Q  bp
P' dc(M )
Q. From the induction hypothesis we

deduce that P' dc(M ) Q |= φ. Finally : P' dc(M ) Q |= EFφ.
Finally, P' dc(M ) Q |= EFφ.
· The same reasonning holds for P |= EF{χ}φ.
The proof is similar for the second operand: Let Q and Q' such as Q .	Q'
and Q |= φ, therefore Q' |= φ by induction hypothesis.
We suppose that P C and thus, does not contain a spawning term (this case is treated in the second half of the proof). We then may apply rule SEQ2 of the

operational semantics: due to the definition of the congruence

P C and Q  bp
Q' ⇒
P dc(M )
.
Q  bp
P dc(M ) Q'

Thus, Q .
Q'andP C and P dc(M )
Q |= φ ⇒
P dc(M )
Q' |= φ.

Finally and for the same reasons than in the previous case:


.
P C ∧ Q  bp

Q' ∧

P dc(M )
Q |= φ ⇒

P dc(M )
Q' |= φ

Instance spawn:
Let P = cA(x˜).A(y˜) and P |= φ and C a correlation set related to P .

If C = ∅, then [null : 0]cA
(x˜).A(y˜) cA(M )
[z˜ ← u˜] : A(u˜)]cA
(x˜).A(y˜) (rule

C-SPT of the operational semantics). In this case, the resulting process is P , that obviously satisfies φ.

If C /= ∅ then [C : P ]cA
(x˜).A(y˜)	cA(M )
[C, [z˜ ←
u˜] : P|A(u˜)]cA
(x˜).A(y˜)

(rule C-SPF of the operational semantics). In this case, the resulting process is
P | P | ... | P , that satisfies φ by induction hypothesis (P |= φ ⇒ P|P |= φ).
Finally:

P |= φ ∧ C is a correlation set ⇒ [C : P ]c(x˜).A(y˜) |= φ

The congruence contains a constraint on the termination of involved processes (both congruent processes must terminate). Since this is a restrictive constraint, and since the adequacy holds for all processes, it holds for terminating processes.
 

Veriﬁcation

.
 bp
be the congruence we defined in 3.1 and ∼. e
be the early bisimulation of the

π-calculus.
Let P be a BP-process. P ’s translation to BPEL is denoted bpel(P ) and we denote P ) the translation of bpel(P ) to π-calculus. P ) is obtained by means of Lucchi and Mazzara’s semantics that we extend for the missing operators (see [2]). For the purpose of verifying BP-processes using a π-calculus model-checker, we need to define a correspondance between the π-logic and the BP-logic and then to
guarantee a soundness property.
Since the only difference between the two logic is the termination modality (C), we can proceed as follows: If a BP-formula does not contain the C modality it is translated to a π-formula with exactly the same syntax. Otherwise, the formula is translated the same way and the process is checked for termination. This brings us to the following result about soundness.

Soundness
Since P ) is obtained by a translation through BPEL, we only need to show that P and P ) satisfy the same set of equivalent properties, to prove that bpel(P ) also satisfies the desired properties.

Theorem 3.6
∀φ, P ) |= φ	⇒ P |= φbp

The proof uses the mapping from BP-calculus to BPEL and Lucchi and Maz- zara’s semantics and is given in Appendix.
As an important consequence, since the π-process is obtained through a mapping to BPEL, one can deduce that if a property holds for the initial BP-process, then the same propery holds for the translation to BPEL. This way, we state the correctness of the mapping.

Verification framework
The definition of the BP-calculus presented in Section 2.2 indicates the possible use of functions and equations exactly as it is done in the applied π-calculus. However, since the choice was made to use first the HAL Toolkit [5] associated with the π-logic, this aspect of the BP-calculus is not used here. That means that the specification and the verification stay at a lower level than it could be.

The veriﬁcation/reﬁnement process
The HAL formulae checker is used to verify and refine a specification written in BP- calculus. BPEL programs are automatically translated into BP-calculus processes or directly specified in the BP-calculus language. We also specify the desired properties by means of the π-logic. BP-processes are translated to π-processes and the validity of the translation, e.g. the preservation of properties, is asserted by the results of Section 3.6.
We then check if the formulas hold for the defined processes. If they are invali- dated by the tool, we iteratively correct the processes and/or the formulas and we repeat the verification process until the system is validated. At this time, a version of the BPEL process is automatically generated.
We can also need to minimize any of the initial or the final formal specification and then we can use the HAL bisimulation checker to verify correctness of this minimization.
The example in the next section shows that the approach is practically feasible. since design languages usually describe few, interesting properties of a system (e.g. its behavior w.r.t. concurrency and communication), while often full verification is impossible due to the size of the implementation

Modelling and Verifying the Trading Service
The example presented here is intended to illustrate our approach and is adapted from [13].

The trading market service
A customer places an order to sell a quantity of shares by contacting a Broker service. The broker invokes other composite services to check the feasability of the transaction and to perform it. This scenario is well-suited to our study because it involves several composite services.
The case study scenario is informally described as follows: The Customer con- tacts the Broker composite service intending to sell the shares. The Broker invokes
the Analytic service with the request parameters. The trend information is cal- culated and a trading plan is generated and returned by the Analytic service to the Customer for confirmation. The Customer checks the plan and approves it or rejects it. In case of approval, the Broker service submits order according to the plan to the Exchange service. Each order that is placed on the Exchange service successfully generates a receipt which is returned to the Customer. The Surveil- lance service monitors each order and the generated trades to detect possible illegal
actions.

Formal description
We model the scenario by means of the BP-calculus; we do not use the correla- tion mechanism in this example and thus the processes do not contain the spawn construct. However the example is relevant since it includes handlers.
Let u˜ = (a, b, decision, o, p, q, r, s, t), then the whole BP-process is:
CapitalMarket(qty, plan, receipt, ok) := Customer(s, p, qty, a, ok, nok, r)
| Broker(s, p, plan, q, qty, a, r, receipt) | Analytic(q, p, plan)
| Exchange(o, t, b, ok, r, receipt) | Surveillance(b, t, decision)

We focus on the Broker process that we define with as scope. This scope is a wrapper for local variables and event and fault handlers. Note that we use the handlers’ syntax we developed in [1].
The event handler manages the occurrence of timeout event. Each service has a finite period of time for providing a response to a request. If this time is elapsed, the calling service triggers a timeout event caught by the event handler.
The fault handler manages faults occurring while invoking the Broker service. We consider the three following faults for this service : the Broker is busy (fbb), the Analytic service is down or busy (fasd), the Exchange service is down or busy (fesd),
We now formalize the Broker service and its handlers.
Let u˜ = (eneh, enfh, diseh, disfh, t, timeout, p, receipt, fbb, fesd, fasd, yeh, yfh) and w˜ = (a, ok, s, qty, order, q, o, plan, eneh, enfh, diseh, disfh, r, x, bb, esd, asd)
The Broker is defined by: Broker := {u˜, B, H} where B is its main activity and H the set of handlers (event and fault handlers, here):

B(w˜) := s(qty). qinv⟨qty⟩.a(decision).if (decision = ok)oinv⟨order⟩

+ timeout	⟨⟩ + Error()

where Error() := f throw⟨⟩ + f  throw⟨⟩ + f  throw⟨⟩
When receiving a plan approval, the Broker may send the order to the Exchange service, or trigger a timeout event; In the latter case, the event handler runs the timeout event handling action (AT imeout). Finally, it may trigger a fault; in this case the fault handler is invoked that runs the corresponding action (Fbb, Fasd or Fesd).
H = {EH(eeh, yeh, deh, timeout, t),FH(fbb, fesd, fasd, efh, yfh, bb, esd, asd, r)}
The Event handler is as follows:
EH(eeh, yeh, deh, timeout, t) := (νet)  eneh().  timeout().etinv⟨⟩
+ diseh().yehinv  | et().AT imeout   where AT imeout := pinv⟨timeout⟩
The event handler is enabled using the eneh channel and waits for a unique event (the timeout) on channel et. Then, it processes an activity (AT imeout) asso- ciated with this event. It is disabled using the diseh channel and yeh signals the disabling of the event handler.
The Fault handler is expressed by :

FH(f  ,f	,f	,e	,y	, bb, esd, asd, r) := en	().   f (p, u˜). throwinv⟨⟩


| Fbb
(p)   +  f

esd
(p, u˜). throwinv⟨⟩ | F

esd
(p)  +  f

asd
(p, u˜). throwinv⟨⟩


	
| Fasd(p)    d  rinv⟨⟩ | yinv⟨⟩  + disfh()  where each process associated with
a fault defined as:

Fbb(p, brokerbusy) := p⟨brokerbusy⟩	(to handle ”broker service busy” fault) Fesd(p, esd) := p⟨esd⟩	(to handle ”exchange service down” fault) Fasd(p, asd) := p⟨asd⟩		(to handle ”analytic service down” fault)

The fault handler deals with three kinds of faults : Sf = {fbb, fesd, fasd} together with their associated activities : F = {Fbb, Fesd, Fasd}. It is enabled using the efh channel and then the activity associated with the triggered fault is processed. Finally it signals its termination to the calling scope and the activating throw using the yfh and the channel r. It is finally disabled using the channel disfh.
The same model is applicable to other composite services which may also contain scopes.
It is worth noting that introducing a scope in the model has involved of a big amount of complexity. The generation of the History Dependent automaton using the HAL Toolkit for the model without scope has been made within one half second and has resulted in a six-state automaton. While the Broker’s model with scopes, which is only a part of the whole model, has generated an automaton with more than a 1000 states in more than 600 seconds. This illustrates the fact that the BPEL language is very powerful but its formal verification is not an easy task applied to weighty cases.

Once the system is formally specified, on needs to proceed to the formal verifi- cation of desired properties.

Veriﬁcation of functional properties
Many properties of interest for services and SOC applications have been defined so far ([16]): Availability, reliability , responsiveness, fairness, or fault-tolerance. Here are some examples of the verification of such properties applied to the case study of Section 5.1.

Responsiveness:
A service is responsive if it guarantees a response to every received request in finite time. The property stating that whenever the customer sends a sell order, he will obtain a plan after a finite time, and whenever a customer agrees a selling plan, and the order is approved by the surveillance service, he will receive a receipt, is a responsiveness property. This property can be formalized by the following π-formula: φ1 & φ2 where:
φ1 = AG([s?qty]EF (< p![plan] > true))
φ2 = AG(([a?(ok)][b?(ok)])EF ([r!receipt]true))
This property has been validated on the model with the HAL toolkit.

Availability
A service is said available when it is available at any time. The property stating that in every state the broker service may accept a request is an availability property. The π-formula is: AG([s?qty]true).
This property has also been validated on the model with the HAL toolkit.

Reliability
Reliability is the capability to deliver response continuously in time (service reliability) and the capability to correctly deliver messages between two endpoints (message reliability). The property stating that the reception of a plan delivery is guaranteed whenever a sell order has been sent is a reliability property. This can be expressed as a π-formula as follows :  AG([s?qty]EF < p!plan > true)
This property has also been validated on the model with the HAL toolkit.

Fairness
Fairness stipulates that if a process is continuously enable to communicate on a channel, then it must eventually proceed. The property stating that if a customer sends an infinite number of sell orders, then he will receive an infinite number of plans and receipts, is a fairness property. This can be expressed as a π-formula as follows:

φ1 ∨ AG(ψ1 & ψ2) where φ1 = ¬AG(EF < s?∗ > true)
ψ2 = EF < r!receipt > true ψ2 = EF < p!plan > true
This property has also been validated on the model with the HAL toolkit.


Safety
This properties assert that some bad event never happens in the course of a computation. For instance, the property that states that a receipt should never be sent before it has been approved by the surveillance service is a safety property. The π-formula is:  ∼ EF (∼< b!ok > true & < r?∗ > true) This property has been invalidated and that is acceptable since a receipt is sent only if the decision is ok.

Liveness
Liveness properties assert that some event does eventually happen. An example of a liveness property relevant to the capital market use case is the following: the system will eventually execute the action t!order (order’s checking) whenever it has executed the action a!ok (plan’s approval). The π-formula is:  AG(< a!ok > EF < t!order > true)
This property has been validated on the model with the HAL toolkit.
In this model all the desired properties have been validated (except one safety property that is accepted anyway). In the case where some properties are invali- dated, one must modify the specification in such a way that all the properties are accepted. The verification process is re-iterated until all the desired properties are validated. At this time, we can proceed to the automatic generation of the BPEL code.
Since some verifications are time consuming, a formal reasoning might processed upon certain parts of a system, in order to validate these parts of the project requirements. Tis increases the practical feasibility of the approach.

Conclusion
In this paper we have presented some theoretical results for the BP-calculus, a π-like calculus that is designed for formal specification of Web Service orchestrations and that allows verification and automatic generation of readable, easy to support and correct BPEL code. We have defined a congruence, that permits to demonstrate the correctness of the mapping from the BP-calculus to BPEL w.r.t the BP-logic. We have also proved the adequacy of this logic w.r.t the congruence.
As an illustration of the applicability of the the calculus, we presented a mean- ingful case study (the Capital Market process): we first specified the case study, including complex constructs such as handlers, then we used the logic to assert and verify some desirable properties of the system. Using an iterative process, we veri-

fied the correctness of the system and then proceeded to its automatic translation to BPEL.
While some previous works have been done on integrating model-checker toolkits and generating BPEL code that has the same behavior as the model ([17]), our proposal takes into account many significant structured activities, including scopes and handlers and offers integration to a verification/refinement framework for the design.
We are developing a tool integrating the BP-calculus to the the HAL toolkit. Our tool will also be used to generate the correct BPEL code of the business process from the formally verified specification.

References
F. Abouzaid and J. Mullins. A calculus for generation, verification and refinement of bpel specifications.
Electronic Notes in Theoretical Computer Science, 200(3):43–65, 2008.
F. Abouzaid and J. Mullins. Translating bp-calculus specifications to verified bpel code : A proof of correctness. Technical report, Ecole Polytechnique de Montreal, www.polymtl.ca/crac/abouzaid/rr01- 2009.pdf, 2009.
A. Chirichiello and Gwen G. Salau¨n. Encoding process algebraic descriptions of web services into bpel.
Web Intelli. and Agent Sys., 5(4):419–434, 2007.
D. Fahland and W. Reisig.  ASM-based semantics for BPEL: The negative Control Flow.  In
D. Beauquier, E. Biger, and A. Slissenko, editors, Proceedings of the 12th International Workshop on Abstract State Machines (ASM’05), pages 131–151. Paris XII, March 2005.
G.L. Ferrari, S. Gnesi, U. Montanari, and M. Pistore. A model-checking verification environment for mobile processes. ACM Trans. Softw. Eng. Methodol., 12(4):440–473, 2003.
S. Gnesi and G. Ristori. A model checking algorithm for pi-calculus agents. In Applied Logic Series, volume 16, pages 339–358. Kluwer, 2000.
C. Guidi, R. Lucchi, R. Gorrieri, N. Busi, and G. Zavattaro. Sock : A calculus for service oriented computing. In Springer Berlin / Heidelberg, editor, Service-Oriented Computing ICSOC 2006, volume 4294/2006 of Lecture Notes in Computer Science, pages 327–338, 2006.
A. Lapadula, R. Pugliese, and F. Tiezzi. A Calculus for Orchestration of Web Services. In Proc. of 16th European Symposium on Programming (ESOP’07), volume 4421 of Lecture Notes in Computer Science, pages 33–47. Springer, 2007.
R. Lucchi and M. Mazzara. A pi-calculus based semantics for ws-bpel. Journal of Logic and Algebraic Programming, 2007.
R. Milner. Communicating and Mobile Systems: The Pi-Calculus. Cambridge University Press, Cambridge, UK, 1999.
R. Milner, J. Parrow, and D. Walker. Modal logics for mobile processes. Theoretical Computer Science, 1993.
Oasis. Web service business process execution language version 2.0 specification, oasis standard. http :
//docs.oasis − open.org/wsbpel/2.0/wsbpel − v2.0.pdf , april 2007.
F. A. Rabhi, F. T. Dabous, Hairong Yu, B. Benatallah, and Y. K. Lee. A case study in developing web services for capital markets. In Proc. of the 2004 IEEE International Conference on e-Technology, e-Commerce and e-Service (EEE 04), 2004.
D. Sangiorgi and D. Walker. The π-calculus: A Theory of Mobile Processes. Cambridge University Press, 2001.
Davide Sangiorgi and David Walker. On barbed equivalences in pi-calculus. In CONCUR, pages 292–304, 2001.
M.H. ter Beek, A. Bucchiarone, and S. Gnesi. Formal methods for service composition. Annals of Mathematics, Computing & Teleinformatics, 1(5):1–10, 2007.
W. M. P. van der Aalst and K. B. Lassen. Translating unstructured workflow processes to readable bpel: Theory and implementation. the International Journal of Information and Software Technology (INFSOF), December 2006.

Appendix
A	Proof of Theorem 3.6.
A BP-process P is translated to a BPEL process bpel(P ) by means of the map- ping. bpel(P ) is then mapped to a π-calculus process llbracketP rrbracket, using the semantics we deduced from Lucchi and Mazzara’s one and that we completed by providing a semantics for missing operators. For the need of the proof we introduce the following abstract syntax of BPEL’s main constructs:
A := invoke(x,˜i, o˜)	(synchronous invoke)
| invoke(x,˜i)	(asynchronous invoke)
| receive(x,˜i)	(receive)
| receive(x, (C), ˜i)	(receivewithcorrelation)
| reply(x, o˜)	(reply)
| sequence(P, Q, M )	(sequence)
| flow(P, Q)	(parallel)
| Conditional(cond, P, Q)	(conditional)
| scope(x˜, P, H)	(scope)
| spawn(C,P )	(instance spawn)

The proof of the theorem is conducted upon all operators of the language for which we prove that they preserve π-logic properties.
Let P = x¯inv ˜i then bpel(P ) = invoke(x,˜i) and P ) = x¯ ˜i . It is obvious that
 P ) |= φ ⇒ P |= φ.
the same thing holds for the synchronous output (P = x¯rep) and input (P = x(o˜)).
Parallel operator : Let P = P1|P2, then bpel(P ) = flow(P1, P2) and  P ) =
 P1)| P2).
By construction:  P1) →α  P') ⇒ P1 →α P'.

1
Therefore,	α	'
1
α	'	(by semantics rule

 P1)| P2) →  P1)| P2) and thus P1|P2 → P1|P2
PAR). We deduce :  P1)| P2) |= φ ⇒ P1|P2 |= φ.
conditional :
Sequential operator : Let P = P1 dc(M ) P2, then bpel(P ) = sequential(P1, P2,M ). Suppose that P1 is of the form P'.c¯⟨M ⟩ that means that P1 indicates its termination by performing an output on the private channel c.
Then  P ) = (νc)( P').c¯⟨M ⟩ |c(M ). P2)).


Thus, P' →α
P1” ⇒  P ) →α
(νc)( P1”).c¯⟨M ⟩ |c(M ). P2)), that is the same

behavior expressed by semantics rule SEQ1.
On the other side, if P2 →α P' and α /= x(˜i) and P1 terminates, e.g. does not
2
α	'
contain a spawn construct, then P ) → P2) that is the same behavior expressed
by semantics rule SEQ2.

If P1 does contain a spawn construct and α is an input, then
 P ) →α ( P')| P2)), that is the same behavior expressed by semantics rule SEQ2’.
In both cases, the behavior of P and P ) is the same and thus,
 P ) |= φ ⇒ P |= φ.
spawn operator : Let Q = [C : P ]cA(M ).A be a BP-process with correlation set (C), then bpel(P ) = receive(cA, (C),M ). Finally, P ) can be modelled in π-calculus this way:

BProc(x) :=!x(y).(νz)bary ⟨z⟩ .Instance(z) Client(x, y) := barx ⟨y⟩ .y(z).Session(z)
