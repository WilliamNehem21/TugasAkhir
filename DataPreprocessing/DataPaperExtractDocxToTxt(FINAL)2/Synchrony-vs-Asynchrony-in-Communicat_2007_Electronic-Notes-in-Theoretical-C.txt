	Electronic Notes in Theoretical Computer Science 175 (2007) 87–108	
www.elsevier.com/locate/entcs

Synchrony vs Asynchrony in Communication Primitives
Daniele Gorla1
Dip. di Informatica, Univ. di Roma “La Sapienza”, Italy

Abstract
We study, from the expressiveness point of view, the impact of synchrony in the communication primitives that arise when combining together some common and useful programming features like arity of data, communication medium and possibility of pattern matching. For some primitives, we show how their synchronous version can be encoded in their asynchronous counterpart via a fully abstract encoding, thus proving that the two versions have the same expressive power. For the remaining primitives, we prove that no ‘reasonable’ encoding can exist, thus proving that synchrony adds expressiveness to the language.
Keywords: Expressiveness, Encodings, Communication Primitives, Process Calculi.


Introduction
One distinguishing feature of languages for concurrent systems is the choice of the communication primitives they use for inter-process exchange. These primitives can range from very skeletal ones [15,7] to more sophisticated and powerful pro- gramming constructs [12,17,3,8]. It is then natural to formally study and compare these primitives from the expressive power perspective. As a consequence, results in this research line show the peculiarities of every primitive and, thus, they can be exploited to choose the ‘right’ primitive when designing new languages and for- malisms.
In [13], we studied asynchronous communication primitives and the impact that some very common and useful programming features (like arity of data, commu- nication medium and possibility of pattern-matching) have on their expressiveness. As a result, we came out with:
eight languages (that, for the sake of uniformity, were small variants of the π- calculus [21]), whose communication primitives were obtained by combining the

1 Email: gorla@di.uniroma1.it

1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2006.10.054



Fig. 1. The Impact of Synchrony in Communication Primitives
above mentioned features;
and with a hierarchy of such languages, based on their relative expressive power.
In this paper, we extend the results presented in [13] to assess, from the expressive- ness point of view, the impact of synchrony on such primitives. Indeed, as we shall prove, the claim “for many purposes, synchronous message passing can be regarded as a special case of asynchronous message passing” [25] strongly relies on the ac- cessory features that equip the communication primitives. In particular, for each of the eight languages studied in [13], we shall see whether their synchronous version has the same expressive power as their asynchronous counterpart or not. In the first case, we can freely implement the primitives asynchronously, since asynchrony usually poses fewer implementative problems; in the second case, asynchronous im- plementations are less innocuous.
Our results are summarised in Figure 1.   There,  M and P denote
monadic/polyadic data exchanges; C and D denote channels/dataspaces; Pm
and No denote presence/absence of pattern matching; s and a denote syn-
chrony/asynchrony; finally, s → a means that the synchronous version of the prim- itive is strictly more expressive than its asynchronous counterpart, whereas s ↔ a means that the two versions have the same expressive power.
To study the expressive power of a programming language, several techniques can be exploited. A first, very rough, test is to determine whether a language is Turing complete or not; however, since almost all ‘useful’ languages are Turing complete, this criterion is too coarse to compare different languages. A second, more informative, approach to show that a language is more expressive than another one is to find a problem that can be solved in the former under some conditions that cannot be met by any solution in the latter.
Another interesting approach to compare two languages consists in encoding one in the other (where an encoding is a function that translates terms of one language in terms of the other language) and studying the properties of the encoding functions. This is the approach we shall follow in this paper and it is very appealing for at least two reasons. First, it is a natural way to show how the key features of a language can be rendered in the other one. Second, it allows us to also carry out quantitative measures on language expressiveness: we can consider aspects like the size and the complexity of the encoding of a term w.r.t. the source term and, consequently, quantitatively assess the encoding proposed.
This paper is organised as follows. In Section 2, we start by comparing the

impact of synchrony in the π-calculus [17]; in this way, we gently introduce the reader to the problem and sum up the main related achievements. In Section 3, we present the sixteen concurrent languages arising from the combination of the four features studied (synchrony, arity of data, communication medium and presence of pattern-matching). In Section 4, we present some criteria that an encoding should satisfy to be a good means for language comparison. Then, in Section 5, we prove the results depicted in Figure 1; more precisely, we shall provide (i) a fully abstract encoding for all those languages whose synchronous and asynchronous versions have the same expressive power, and (ii) a formal proof of the impossibility for a ‘rea- sonable’ encoding for all those languages where synchrony improves expressiveness. Finally, Section 6 concludes the paper by discussing the results in Figure 1.

Synchrony and Asynchrony in the π-calculus
The π-calculus was originally equipped with synchronous, monadic and channel- based communication primitives [17]; a few years later, its asynchronous version appeared in literature [14,2] and became a reference point for its simplicity of dis- tributed implementation [11,22]. Some effort has been spent to prove that the two formalisms have the same expressive power [14,2,23,5]; nowadays, it is widely believed that this is the case.
The idea underlying these encodings is that a synchronous exchange can be simulated by a sequence of asynchronous exchanges. As an example, consider the encodings from [14,2]:

where a⟨b⟩.P denotes the output prefix (send b along a and, after reception, behave like P ), a(x).P denotes the input prefix (receive something from a and use it to replace x in the continuation P ), (νc)P denotes the restriction of c to P (c is acces- sible only from within P ) and P | Q denotes the parallel composition of processes P and Q.
These encodings are proved sound by exploiting some ad hoc techniques; e.g., Boudol only proves that his encoding is adequate w.r.t. a Morris-like preorder. On the other hand, [23,5] aim at stronger results for such an encoding: in particular, the first paper shows that it enjoys full abstraction w.r.t. a typed version of barbed equivalence [18], whereas the second paper proves full abstraction w.r.t. to may and fair testing [10,19] restricted to the translation of synchronous contexts. In both cases, it is necessary to reduce the observational power of the contexts since a context that does not abide by the protocol put forward by the encoding can easily break full abstraction. 2  In the first case, the type system characterises the respectful

2  For example, processes a⟨b⟩.a⟨b⟩ and a⟨b⟩ | a⟨b⟩ are equated both by barbed equivalence and by may/fair

contexts, whereas in the second case the encoding itself yields them. Of course, the first alternative entails a stronger full abstraction result, because in general it accepts more contexts than the translated ones; however, it is usually much more complex. Thus, for the sake of simplicity, in this paper we shall adopt the second alternative; we strongly believe that all our full abstraction results could be also formulated in terms of typed equivalences, instead of translated equivalences.
Recently [6], it has been proved that there is no encoding of the synchronous π-calculus in its asynchronous version preserving must testing [10] and enjoying a few minimal properties. 3 This raises the problem of which equivalence should be adopted when defining the full abstraction property to assess expressiveness of two languages. As testified by the case of the π-calculus, such a choice is crucial, mainly when proving that a language L1 is more expressive than another language L2: every separation result based on a fixed equivalence could be criticised by saying that it actually compares not the expressive power of the languages, but the discriminating power of the equivalences. For this reason, to prove that L1 is at least as expressive as L2, we shall fix a set of minimal properties that every encoding should satisfy and prove that no encoding of L2 in L1 satisfying such properties exists.

A Family of Process Languages
Syntax. We assume a countable set of names, N, ranged over by a, b, x, y, n, m, ··· . Notationally, when a name is used as a channel, we shall prefer letters a, b, c, ··· ; when a name is used as an input variable, we shall prefer letters x, y, z, ··· ; to denote a generic name, we shall use letters n, m, ··· . The (parametric) syntax of our languages is given in the upper part of Figure 2. The different languages are obtained by plugging into this basic syntax a proper definition for input prefixes (IN ) and output processes (OutProc). As usual, 0 and P |Q denote the terminated process and the parallel composition of two processes, resp.; (νn)P restricts to P the visibility of n; finally, if n = m then P and !P are the standard constructs for name matching and process replication. 4
In this paper, we study the synchronous/asynchronous versions of the prim- itives arising by the possible combinations of three features: arity (monadic vs. polyadic data), communication medium (channels vs. shared dataspaces) and pattern-matching. As a result, we have a family of sixteen languages, denoted as

β1
β2, β3, β4
, where

β1 = s, if we have synchronous communications, and β1 = a, otherwise;
β2 = p, if we have polyadic data, and β2 = m, otherwise;

testing; nevertheless, [ a⟨b⟩.a⟨b⟩ ]] and [[ a⟨b⟩ | a⟨b⟩ ] are not equivalent anymore. The problem is that [[ a⟨b⟩ | a⟨b⟩ ] can exhibit two top-level outputs, whereas [ a⟨b⟩.a⟨b⟩ ] only one; if the receiving context sends no acknowledgement back, the second output of [ a⟨b⟩.a⟨b⟩ ] (that is blocked by the encoding of the first prefix) is never unleashed. The same problem holds for Honda and Tokoro’s encoding, but with processes a(x).a(y) and a(x) | a(y).
3 Another impossibility result is [20], but it relies on the interplay between output prefixes and non- deterministic choice.
4 Notice that, for the sake of simplicity, we used here replication and a if - then construct instead of recursion and the more powerful if-then-else used in [13]; this choice does not undermine all our results that still hold also with the other operators.


Basic Processes:
 P, Q, R ::=	0  OutProc  IN.P  (νn)P  P |Q  if n = m then P  !P 


a	:	OutProc ::= OUT
L s, ,	:	OutProc ::= OUT.P
L m,d,no :	P, Q, R ::= ...	IN ::= (x)	OUT ::= ⟨b⟩
L m,d,pm :	P, Q, R ::= ...	IN ::= (T )	OUT ::= ⟨b⟩
L m,c,no :	P, Q, R ::= ...	IN ::= a(x)	OUT ::= a⟨b⟩
L m,c,pm :	P, Q, R ::= ...	IN ::= a(T )	OUT ::= a⟨b⟩
L p,d,no :	P, Q, R ::= ...	IN ::= (x˜)	OUT ::= ⟨˜b⟩
L p,d,pm :	P, Q, R ::= ...	IN ::= (T˜)	OUT ::= ⟨˜b⟩

L p,c,no L p,c,pm
:	P, Q, R ::= ...	IN ::= a(x˜)	OUT ::= a⟨˜b⟩
:	P, Q, R ::= ...	IN ::= a(T˜)	OUT ::= a⟨˜b⟩

where	T ::= x	  n’	(Template)

Fig. 2. Syntax of the 16 Languages
β3 = c, if we have channel-based communications, and β3 = d, otherwise;
β4 = pm, if we have pattern-matching, and β4 = no, otherwise.
Now, the full syntax of every language is obtained from the productions in the lower part of Figure 2. There, denotes a (possibly empty) sequence of elements of kind . Whenever useful, we shall write a tuple as the sequence of its elements, separated by a comma; sometimes, we shall also consider tuples simply as sets. Templates of kind x are called formal and can be replaced by every name upon withdrawal of a datum; templates of kind n’ are called actual and impose that the datum withdrawn contains exactly name n. As usual, a(··· , x, ··· ).P and (νx)P bind x in P ; the corresponding notions of free and bound names of a process, Fn(P ) and Bn(P ), and of alpha-conversion, =α, are assumed. We let N(P ) denote Fn(P ) ∪ Bn(P ).
Notice that in L , ,pm the if - then construct is redundant because it can be implemented via pattern matching; we kept it for the sake of uniformity with the

other languages. Finally, notice that L a
can be seen as the sub-language of

L s, , where every output prefix is followed by a 0 continuation. Thus, the non- trivial contribution of this work is in giving a converse encoding, or in proving that this cannot exist.
Operational semantics.   The operational semantics of the languages is given

by means of a labelled transition system (LTS) describing the actions a process can perform to evolve. Judgements take the form P −−α→ P ', meaning that P can become P ' upon exhibition of label α. Labels take the form
α	::=	τ  a?˜b (ν˜c)a!˜b ?˜b (ν˜c)!˜b

Traditionally, τ denotes an internal computation; a?b and (νc)a!b denote the re- ception/sending of a sequence of names b along channel a; when channels are not present, ?b and (νc)!b denote the withdrawal/emission of b from/in the shared datas- pace. In (νc)a!b and (νc)!b, some of the sent names, viz. c (⊆ b), are restricted. Notationally, (ν˜c) !˜b stands for either (ν˜c)a!˜b or (ν˜c)!˜b; similarly, ?˜b stands for either
a?˜b or ?˜b. As usual, Bn((ν˜c) !b˜)  c˜; Fn(α) and N(α) are defined accordingly.
The LTS provides some rules shared by all the languages; the different semantics are obtained from the axioms for input/output actions. The LTS relies on π-calculus structural equivalence, ≡, that rearranges a process to let it evolve according to the rules of the LTS and that is defined by the following standard axioms [21]:

The common rules of the LTS are reported below (since they are an easy adaptation of an early-style LTS for the π-calculus, we do not comment on them and refer the interested reader to [21]):

e	e	e	e

P −−?b→ P '	Q −−!b→ Q'

P | Q −−τ→ P ' | Q'
P −−a−?b→ P '	Q −−a−!b→ Q'

P | Q −−τ→ P ' | Q'



P −−α→ P '	n /∈ N(α) (νn)P −−α→ (νn)P '
(νce) !eb
P −−−−−→ P '
n ∈ b \{ , c}
(νn,ce) !eb


P −−α→ P '

Bn(α) ∩ Fn(Q)= ∅
(νn)P −−−−−−→ P '
P ≡ P1 −−α→ P2 ≡ P '

P | Q −−α→ P ' | Q


P −−α→ P '

The rules for output actions in languages L a
a
,c,
, L s

,d,
and L s

,c,
are,

respectively,
!eb


a!eb


!eb


a!eb

⟨˜b⟩ −−→ 0	a⟨˜b⟩ −−−→ 0	⟨˜b⟩.P
−−→ P	a⟨˜b⟩.P
−−−→ P

On the other hand, to define the semantics for the input actions, we must specify when a template matches a datum. Intuitively, this happens whenever both have the same length and corresponding fields match (i.e., n’ matches n and x matches every

name). This can be formalised via a partial function, called pattern-matching and written Match, that also returns a substitution σ; the latter will be applied to the process that performed the input to replace formal templates with the corresponding names of the datum retrieved. These intuitions are formalised by the following rules:


Match( ; ) = ϵ
Match( n’; n)= ϵ
Match(x; n)= {n/x}

Match(T ; b)= σ1	Match(T˜; ˜b)= σ2

Match(T, T˜ ; b, ˜b)= σ1 ◦ σ2
where ‘ϵ’ denotes the empty substitution and ‘◦’ denotes substitution composition. Now, the operational rules for input actions in languages L ,d,  and L ,c,  are


(T˜).P
e
−−?b→ Pσ	a(T ).P
e
−−a−?b→ Pσ 

whenever Match(T˜ ; ˜b)= σ.
Notation:	A substitution σ is a finite partial mapping of names for names; Pσ 
denotes the (capture avoiding) application of σ to P . As usual, we let =⇒ stand for
the reflexive and transitive closure of −−τ→ , ==⇒ stand for =⇒ −−→ =⇒ and −−τ→k
denote a sequence of k τ -steps. We shall write P −−α→ to mean that there exists a
process P ' such that P −−α→ P '; a similar notation is adopted for P =⇒ and P ==⇒ .
Moreover, we let φ range over visible actions (i.e. labels different from τ ) and ρ to range over (possibly empty) sequences of visible actions. Formally, ρ ::= ε | φ · ρ, where ‘ε’ denotes the empty sequence of actions and ‘·’ represents concatenation;
ε	φ·ρ	φ	ρ
then, N ==⇒ is defined as N =⇒ and N ===⇒ is defined as N ==⇒ ==⇒ .
We conclude this part with a proposition collecting together some properties of the LTSs we have just defined, that will be useful in the sequel; the proof of these results easily follows from the definition of the LTSs.
Proposition 3.1 The following facts hold:
e

if P ∈ L
˜b;


, ,no
and P
−−?−b→ , then P	?ce
for every ˜c of the same length as

if P
−−τ→ P ' then P ≡ (ν˜c)(P1 | P2) and P ' ≡ (ν˜c)(P '
| P '), where either

?eb	'
!eb	'
a?eb	'
a!eb	'

P1 −−→ P1 and P2 −−→ P2, or P1 −−−→ P1 and P2 −−−→ P2;
a	(νce) !eb	α	'

if	P	∈	L , ,	and P −−−−−→ −−→ P , for


c˜ ∩ N(α)	=	∅, then

P −−→ −−−−−→ P ; moreover, if α =	?˜b, then P
−−→ (ν˜c)P .

Quality of an Encoding
We now compare the synchronous and the asynchronous version of the communi- cation primitives just presented by trying to encode every synchronous language in

its asynchronous version. Formally, an encoding [[ · ] is a function mapping terms of the source language into terms of the target language. As already said, the relative expressive power of our languages can be established by defining some criteria to evaluate the quality of the encodings or to prove impossibility results.
Roughly speaking, the encoding must not change the semantics of a source term,
i.e. it must preserve the observable behaviour of the term without introducing new behaviours. This means that the encoded term and the source one should be engageable in the same kinds of interactions and that aspects like deadlock and divergence are either present in both terms or in neither of them. We now discuss two possible ways of formalising this requirement. The first one, called full abstraction, is usually exploited for encodability results; the second one, called reasonableness, is usually exploited in the impossibility results.

Full abstraction.
When a language can be encoded in another one, we shall prove that the encod- ing function enjoys full abstraction w.r.t. barbed equivalence restricted to translated contexts. This is a satisfying result since (weak) barbed equivalence is often consid- ered to be the ‘touchstone’ semantic theory for several process languages. Barbed equivalence is obtained by closing under name restriction and parallel composition a relation called barbed bisimilarity, that equates two terms that offer the same observable behaviour along all possible computations.
In our framework, a context C[·] is a process built up from a hole [·] (to be filled with any process) by using parallel composition and restriction. Formally,
C[·]	::=	[·]  P | C[·]	 (νn)C[·]
Definition 4.1 [Barbs] 5
e
(νce)!eb	(νce)a!b
P ↓OUT k holds true iff P −−−−→ and |˜b| = k; P ↓OUTa holds true iff P −−−−−→ .
e
?eb	a?b
P ↓INk holds true iff P −−→ and |b| = k; P ↓INa holds true iff P −−−→ .
Let	o	range  over	{OUTk, OUTa,INk,INa};	then,	P	⇓o	stands  for
∃P '.P =⇒ P ' ↓o.
Definition 4.2 [Barbed Bisimilarity and Equivalence] A symmetric relation ঩ be- tween processes is a barbed bisimulation if, for every (P, Q) ∈ ঩, it holds that
P ↓o implies Q ⇓o, and
P −−τ→ P ' implies Q =⇒ Q', for some Q' such that (P ', Q') ∈ ঩.
•

Barbed bisimilarity,
∼=, is the largest barbed bisimulation. P and Q are barbed
•

equivalent, written P ∼= Q, if and only if C[P ] ∼= C[Q], for every context C[·].


5 In order to obtain meaningful equivalences, barbs in L M,D, should be defined by also specifying the argument of the action. However, since we shall not give full abstraction results for such languages, we ignore this aspect. By the way, notice that for languages L P,D, the arguments of the action are not strictly necessary, since the barbed equivalence arising from this different kind of barbs would coincide with ∼= defined here.

As already said in Section 2, a good form of full abstraction for a given en- coding [ · ]] : L1 → L2 is w.r.t. translated observers, i.e. observers that abide by the schema imposed by the encoding function. Thus, we now restrict the equiv- alences introduced so far to keep this choice into account: first, not all the barbs from Definition 5 can be observed by a translated observer; second, we only need to consider translated contexts when defining barbed equivalence. The following definition formalises these ideas; there, we say that an action α performed by a
ρ	α'
L2-process can be consumed by the translation of a L1-process R if [ R ]] ==⇒ −−→ ,
with α' synchronisable with α (i.e., with α' =	?˜b and α = (ν˜c) !˜b, or vice versa)
Definition 4.3 [Translated Barbed Bisimilarity and Equivalence] Fix an encoding [[ · ]] : L1 → L2.

Let P be a L2-process; P ↓tr
holds true iff P ↓o with an action that can be

consumed by the translation of some L1-process; P ⇓tr is defined accordingly.
A symmetric relation ঩ between L2-processes isa translated barbed bisimulation
if, for every (P, Q) ∈ ঩, it holds that
P ↓tr implies Q ⇓tr, and
o	o
P −−τ→ P ' implies Q =⇒ Q', for some Q' such that (P ', Q') ∈ ঩.
•

Translated barbed bisimilarity,
∼= tr, is the largest translated barbed bisimulation.

P and Q are translated barbed equivalent, written P ∼= trQ, if and only if C[P ] =∼ tr C[Q], for every context C[·] resulting from the translation of a L1-context via [ · ] extended with [[ [·] ]]  [·].
Reasonable Encoding. To prove that two languages have different expressive power, we shall leave full abstraction out (since it requires to fix an equivalence relation): instead, we shall collect together some ‘reasonable’ requirements and prove that no encoding function satisfying them exists. The main requirement is faithfulness: the encoding must preserve and reflect the barbs (i.e., the encoding should maintain all the original barbs without introducing new ones); moreover, it should also preserve and reflect divergence. However, these two requirements alone are not enough to control deadlock. Thus, we shall also require that the computations of a process correspond to the computations of its encoding, and vice versa; this property is usually known as operational correspondence. Furthermore, a good encoding cannot depend on the particular names involved in the source process, since we are dealing with a family of name-passing languages; we call this property name invariance. Finally, the encoding should not decrease the degree of parallelism in favour of centralised entities that control the behaviour of the encoded term; we express this last property as homomorphism w.r.t. ‘|’.
Definition 4.4 [Reasonable Encoding] An encoding [ · ]] is reasonable if it enjoys the following properties:
(homomorphism w.r.t. ‘|’): [[ P1|P2 ]]   [[ P1 ]] | [[ P2 ]].
(name invariance): [[ Pσ ]]   [[ P ]]σ, for every permutation of source language

names σ.
(faithfulness): P ⇓o iff [ P ]] ⇓o' ; P diverges iff [ P ]] diverges.
(operational correspondence):
if P =⇒ P ' then [ P ]] =⇒ [[ P ' ]];
if [ P ]] =⇒ Q then there exists a P ' such that P =⇒ P ' and Q =⇒ [[ P ' ]].

Evaluation criteria. To sum up, for our encodability results we aim at proving that the encoding function does not introduce divergence and that it enjoys full ab- straction w.r.t. translated barbed equivalence; on the other hand, we shall establish our impossibility results by proving that no reasonable encoding exists. Usually, the latter proofs are by contradiction: we assume that a reasonable encoding exists and show that it cannot be reasonable. This can require a lot of work. However, in this paper, we shall exploit the simple proof-technique developed in [13]: exhibit a process that cannot reduce but whose encoding reduces. This fact, together with operational correspondence, implies that the encoding introduces divergence.

Proposition 4.5 Let P be a process such that P
not reasonable.
−−τ→/
but [[ P ]]
−−τ→ ; then, [[ · ]] is

The Impact of Synchrony in Communication Primi- tives
In this section, we first consider those languages in which synchrony does not play a crucial rˆole, i.e. those primitives whose synchronous and asynchronous versions have the same expressive power. We then analyse those primitives in which the presence of synchrony matters, i.e. those primitives whose asynchronous version is less expressive than the synchronous one.


s m,c,no
a m,c,no
have the same expressive power.

Easily, Boudol’s encoding [2] can be used to prove that L s
is encodable in

a m,c,no
with an encoding function that does not introduce divergence (trivially)

and that enjoys full abstraction w.r.t. translated barbed equivalence (see [23]).


s p,c,pm
a p,c,pm
have the same expressive power.

To prove that L s
can be reasonably encoded in L a
, it suffices to impose

that the first name of every datum is a restricted channel used to unleash the continuation of the output prefix; conversely, every template starts with a new variable over which an acknowledgement is sent upon reception of the datum. This discipline is rendered by the following encoding:
[[ a⟨˜b⟩.P ]]  (νc)(a⟨c, ˜b⟩ | c( ).[[ P ]])	for c fresh
[[ a(T˜).P ]]  a(x, T˜).(x⟨⟩ | [[ P ]])	for x fresh

The encoding just presented is satisfying because it does not introduce diver- gence and enjoys full abstraction, as proved in the following theorem.

Theorem 5.1 The encoding [[ · ]] : L s
a p,c,pm
does not introduce diver-

gence; moreover, P ∼= Q if and only if [[ P ]] ∼= tr[[ Q ]].
Proof. See Appendix A.	 


s p,c,no
a p,c,no
have the same expressive power.

This result is an easy corollary of the encodability of L s
a p,c,pm
: it

suffices to restrict both the domain and the range of the encoding function to the

sub-calculi of L s
a p,c,pm
with templates made up only by formal fields.



s p,d,pm
a p,d,pm
have the same expressive power.

To prove that L s
can be encoded in L a
, consider the following trans-

lation:
[[ ⟨b1,... , bk⟩.P ]]  (νc)(⟨c, c, b1,... , bk⟩ | ( c’).[[ P ]])	for c fresh
[[ (T1,... , Tk).P ]]  (x, y, T1,... , Tk).(⟨x⟩ | [[ P ]])	for x and y fresh
Intuitively, data of length one in a translated term are ‘auxiliary’ messages used as acknowledgements (ack, for short), to activate the continuation of an output action. The translation of output prefixes guarantees that ‘actual’ data in the source term are translated to data whose length is at least two; this clear distinction ensures us that no interference between an ‘actual’ data exchange and an ‘auxiliary’ ack exchange can ever happen. Moreover, the fact that acks rely on restricted names rules out interferences between different acks.

Theorem 5.2 The encoding [[ · ]] : L s
a p,d,pm
does not introduce diver-

gence; moreover, P ∼= Q if and only if [[ P ]] ∼= tr[[ Q ]].
Proof. The proof is similar to the one for Theorem 5.1; all details are in Ap- pendix A.	 


s p,d,no
a p,d,no
have the same expressive power.
k

Let us define the following notation: ⟨ .. .⟩ denotes ⟨b1,... , bk⟩, where the bi’s
are any names; similarly, (.. .) denotes (x1,... , xk), where the xi’s are pairwise and

distinct names. Now, consider the following encoding of L s
p,d,no:



4k+1
4k+2
4k+3

[[ ⟨b1,... , bk⟩.P ]]  ⟨ ... ⟩ | ( ... ).(⟨b1, b1, b1, b1, ··· , bk, bk, bk, bk⟩ | ( ... ).[[ P ]])


4k+1
4k+2
4k+3

[[ (x1,... , xk).P ]]  ( ... ).(⟨ ... ⟩ | (x1, y1, w1, z1, ··· , xk, yk, wk, zk).(⟨ ... ⟩ | [[ P ]]))
for y1, w1, z1,... , yk, wk, zk fresh and pairwise distinct names and with the input

4k+1
4k+2
4k+3

variables in ( ... ), ( ... ) and ( ... ) fresh for the continuation process. Intuitively,

data of arity 4k within translated terms correspond to actual source data; data of arity 4k+1, 4k+2 and 4k+3 are, instead, only used for synchronisation purposes. In particular, an exchange of arity 4k +1 (that, from now on will be called preliminary) intuitively means “a datum of arity k is available”; an exchange of arity 4k +2 (that, from now on will be called initial) intuitively means “a datum of arity k is going to be consumed”; finally, an exchange of arity 4k + 3 (that, from now on will be called ﬁnal) intuitively means “a datum of arity k has been consumed”. Consumption of a k-ary source level datum happens within a 4k-ary exchange (that, from now on will be called consumptive).
Of course, it is easy to have interferences between the auxiliary data introduced by the encoding of different processes, but this does not create any problem since such data only depend on the length of the translated actions. Consider, e.g., the

encoding of the L s
-process (x).P | ⟨b⟩ | (y).Q | ⟨c⟩ and the reduction that

replaces x with b in P and y with c in Q. It is immaterial which of the two 5-ary ‘preliminary’ data (either the one from [ ⟨b⟩ ] or the one from [ ⟨c⟩ ]) is accessed by [[ (x).P ], since these are top-level asynchronous outputs and the names appearing in it are irrelevant. A similar argument holds also for the ‘initial’ 6-ary and the ‘final’ 7-ary data.
We believe that also this encoding enjoys full abstraction w.r.t. translated barbed equivalence; however, because of the interferences just discussed, we have still not been able to prove this result, though no counter-example against this con- jecture has emerged yet. We leave this aspect for future work; for the moment, we

prove the (not trivial) reasonableness of this encoding and argue that L s
and

a p,d,no
have a comparable expressive power.



Lemma 5.3 If [[ P ]]
−−τ→ np+ni+nc+nf Q, where np/ni/nc/nf are the number of

preliminary/initial/consumptive/ﬁnal steps in the reduction from [[ P ]] into Q, then
np ≥ ni ≥ nc ≥ nf .
Proof. Trivial, by construction of the encoding.	 


Lemma 5.4 Let	[[ P ]]
−−τ→ np+ni+nc+nf  Q, where np/ni/nc/nf are the number

of preliminary/initial/consumptive/ﬁnal steps in the reduction from [[ P ]] into Q. Then,


h=1
  ni−nc (⟨ 4kj ⟩ | 4kj +3
h
2	|	4kj
h
⟨ 4kj +3⟩ | [[ Q2 ]])) |

 nc−nf ((4k.m.+. 3 ).[[ P 3 ]] | ⟨ 4k.m.+. 3⟩)	|	[[ R ]] )


where  k
Pi denotes P1 | ... | Pk, if k > 0, and denotes 0, otherwise.

Proof. Let n = np + ni + nc + nf ; the proof is by induction on n. The base case

(n = 0) is trivial. For the inductive case, let [ P ]]
−−τ→ n Q' −−τ→ Q; by induction,



h=1
  ni−nc (⟨ 4kj ⟩ | 4kj +3
h
2	|	4kj
h
⟨ 4kj +3⟩ | [[ Q2 ]])) |

 nc−nf ((4k.m. +. 3).[[ P 3 ]] | ⟨ 4k.m.+. 3 ⟩)	|	[[ R ]] )

where np + ni + nc + nf = n. We consider two sub-cases, according to whether the step Q' −−τ→ Q is preliminary or not.

if Q' −−τ→ Q is preliminary, then it must be (by construction) that [ R ]] where
−−τ→ R',


R' ≡ (ν˜c)( (4.k.+.2 ).(⟨b ,b ,b ,b ,... ,b ,b ,b ,b ⟩ | (4.k.+.3 ).[[ R ]])
| ⟨ ... ⟩ | (x1, y1, w1, z1,... , xk, yk, wk, zk).(⟨ ... ⟩ | [[ R2 ]]) | [[ R3 ]])

Then,


h=1
h
| ⟨ 4k.h.+.2⟩ | (4.k.h.).(⟨ 4k.h.+.3⟩ | [[ Q1 ]])) |

  ni−nc (⟨ 4kj ⟩ | 4kj +3
2	|	4kj
⟨ 4kj +3⟩ | [[ Q2 ]])) |

 nc−nf ((4k.m.+. 3).[[ P 3 ]] | ⟨ 4k.m. +. 3⟩)	|	[[ R
]] )



by letting k
= k, ⟨ 4knp +1−ni ⟩ = ⟨b ,b ,b ,b ,... ,b ,b ,b ,b ⟩, P 1	=

np+1−ni
4knp +1−ni
... 
1  1  1  1
k  k  k k
1
np+1−ni

R1,( 
...	)= (x1, y1, w1, z1,... , xk, yk, wk, zk) and Qnp+1−ni = R2.

Otherwise, it must be that either  np−ni ··· , or  ni−nc ··· , or  nc−nf ··· per-
form the τ -step, according to whether Q' −−τ→ Q is initial, consumptive or final. We then work like in the previous case.	 


Lemma 5.5 If [[ P ]]
−−τ→ n Q, then P
−−τ→ np P ' and Q −−τ→ 4np −n [[ P ' ]], where

np is the number of preliminary steps in the reduction from [[ P ]] into Q.
Proof. By induction on n; the base case is trivial.  For the inductive case, let
[[ P ]] −−τ→ n Q' −−τ→ Q with


h=1
  ni−nc (⟨ 4kj ⟩ | 4kj +3
h
2	|	4kj
h
⟨ 4kj +3⟩ | [[ Q2 ]])) |

 nc−nf ((4k.m. +. 3).[[ P 3 ]] | ⟨ 4k.m.+. 3 ⟩)	|	[[ R ]] )

by Lemma 5.4. It is then easy to see that Q' −−τ→ 4np−n [[ P ' ]], where
[[ P ' ]] ≡ (νn˜)( np−ni ([[ P 1 ]] | [[ Q1 σ1 ]]) |  ni−nc ([[ P 2 ]] | [[ Q2σ2 ]]) |
  nc−nf [[ P 3 ]]	|	[[ R ]] )
for some substitutions σ1’s and σ2’s.	If Q' −−τ→ Q is not preliminary, then
h	j
it cannot have been performed by [ R ]];	thus,	Q −−τ→ 4np−n−1  [[ P ' ],  i.e.
Q −−τ→ 4np−(n+1) [[ P ' ]]. Otherwise,
R ≡ (ν˜c)(⟨˜b⟩.R1 | (x˜).R2 | R3) for |˜b| = |x˜| = k. Now, consider
P ''  (νn˜, c˜)( np−ni (P 1 | Q1 σ1) |  ni−nc (P 2 | Q2σ2)

|   nc−nf P 3
| R | R {e xe} | R )

Trivially, P ' −−τ→ P '' and Q −−τ→ 4np−n+3 [[ P '' ], i.e. Q −−τ→ 4(np+1)−(n+1) [[ P '' ]]. 

Proposition 5.6 The encoding [[ · ]] : L s
a p,d,no
is reasonable.

Proof. By Lemma 5.5, operational correspondence is easy to prove; divergence freedom is a corollary of Lemmata 5.3 and 5.5; the remaining requirements are trivial.	 


s m,d,no
is more expressive than L a	.

Theorem 5.7 There exists no reasonable encoding of L s
m,d,no.

Proof. Consider the processes P   ⟨b⟩.(x).if x = b then Ω and Q  (x).⟨a⟩.if x = a then Ω, where Ω denotes a divergent process. Clearly, P |Q does not diverge while, as we shall now prove, its encoding diverges. First, observe that in the evolution of [ P |Q ]] to [[ 0 ] (that must happen, because of operational correspondence), both [[ P ]] and [[ Q ] must perform an input and an output action: [ P ] must send b and [[ Q ] must send a. Then, consider the sequence of actions performed by [ P ]], say ρ, and its first input label, say ?n; thus, ρ = ρ1·?n · ρ2. Notice that, by barb preservation, ρ1 cannot be empty and must contain at least an output label, say

(νm˜ )!m; by Proposition 3.1(3,1), [ P ]]



−−?−m→  that, again by Proposition 3.1(3),



s m,d,pm
is more expressive than L a	.

The impossibility proof relies on a preliminary Lemma.

Lemma 5.8 Let [[ · ]] be a reasonable encoding of L s
a m,c,pm
. Then,

[[ ⟨b⟩.P ]]
preﬁx;
−−!b→ and [[ ( b’) ]] −−?b→ , with the input action relying on an actual input

[[ ⟨b⟩.P ]]
−−!k→ implies that k = b.

Proof. Easy derivable from the more complex proof of Lemma 5.10 later on.	 

Theorem 5.9 There exists no reasonable encoding of L s
m,d,pm.

Proof. Consider [ ⟨b⟩.Ω | ( b’) ]]; by operational correspondence, such a process must evolve in [ Ω ] that diverges, because of faithfulness. Since [ ⟨b⟩.Ω ] cannot perform a τ -step, [ ⟨b⟩.Ω ] must exhibit at least an input label in every trace. Moreover, by using Proposition 3.1(2) and Lemma 5.8(1), we can say that
[[ ( b’) ]] −−?b→	ρ1⇒ −−!m−→	ρ2⇒ P	and	[ ⟨b⟩.Ω ]] −−!b→	ρ3⇒ −−?−m→	ρ4⇒ P
==	==	1	==	==	2
where ρ1 and ρ2 are synchronisable with ρ3 and ρ4, resp., (νn˜)(P1 | P2) is struc-
turally equivalent to [ Ω ]], where n˜ = Bn(ρ1, ρ2, ρ3, ρ4), and ?m is the first input
in the trace from [ ⟨b⟩.Ω ]]. Moreover, m /= b and the input ?m relies on an actual template (otherwise, by Proposition 3.1(1) and (3), [ ⟨b⟩.Ω ]] −−τ→ and [ · ]] would not be reasonable). Finally, by construction, ρ3 is only made up by output labels that, by Lemma 5.8(2), are either of the form !b or (νd)!d.
Now, choose a /∈ {b, m} and consider the process
P   ⟨a⟩ | ( a’) | ⟨b⟩.Ω | !⟨a⟩ | !⟨b⟩
Clearly, P does not diverge while, as we shall now prove, [ P ] diverges. Let ρ' be
ρi with a and b swapped, for i = 1,... , 4. Now, synchronise

?a · ρ'
of [ ( a’) ]] with !a · ρ'
of [ ⟨a⟩ ]];

!m of the prosecution of [ ( a’) ]] with ?m of [ ⟨b⟩.Ω ]];
' of the prosecution of [ ( a’) ]] with ρ4 of the prosecution of [ ⟨b⟩.Ω ]]; this can be
freely done except when the action involves a or b. In such cases, synchronise

every ?a in ρ'
with one of the !a from the encoding of !⟨a⟩, and

every ?b in ρ4 with one of the !b from the encoding of !⟨b⟩.
This yields a process containing the component
P '   P ' | P2 | [[ !⟨a⟩ ]] | [[ !⟨b⟩ ]]
where P ' is P1 with a and b swapped. Since (νn˜)(P1 | P2) diverges, we also have
that P ' diverges: every time that P ' or P2 need a ?a or a ?b to evolve, we can
synchronise such actions with a corresponding !a or !b from the encoding of the replicated processes.	 


s m,c,pm
is more expressive than L a	.

Intuitively, communications in L s
atomically verify the channel and the sent

value (if pattern matching is involved) and simultaneously activate the continuation

of the sending process. Thus, L a
should provide the possibility of atomically

verifying the channel and the sent value as well, but this excludes any information for synchronisation purposes.
The impossibility proof relies on a preliminary Lemma, that generalises Lemma 5.8.
Lemma 5.10 Let a, b and c be pairwise distinct names and [[ · ]] be a reasonable

encoding of L s
a m,c,pm
. Then,

[[ a⟨b⟩.a⟨c⟩ ]]
−−a−!b→ and [[ a( b’).a( c’) ]] −−a−?b→ , with the input action relying on

an actual input preﬁx;

[[ a⟨b⟩.a⟨c⟩ ]]
−−h−!k→ implies that h = a and k = b;

[[ a(x) ]] −−a−?b→ , with the input action relying on a formal input preﬁx;
(νk)h!k
[[ a⟨b⟩.a⟨c⟩ ]] −−−−−−→ implies that h = a;
or the same claims with a and b swapped in every label.
Proof.

(νme )n!m
By barb preservation, [ a⟨b⟩.a⟨c⟩ ]] −−−−−−→
and [ a( b’).a( c’) ]] −−n−?−m→ . We

prove that m˜
= ∅ and that {n, m} = {a, b}; let us reason by contradic-

tion.	If m˜
/= ∅, then the input label n?m must come from a formal in-
n?m'

put action in [ a( b’).a( c’) ]]; thus, [ a( b’).a( c’) ]] −−−−→ , for every name
m', and this would imply that [ c⟨b⟩.c⟨a⟩ ]] | [[ a( b’).a( c’) ]] −−τ→ , if n /= a, and [ a⟨c⟩.a⟨b⟩ ]] | [[ a( b’).a( c’) ]] −−τ→ , otherwise. Now, assume that {n, m} /=
{a, b}; we have three possible cases:
{n, m} ∩ {a, b}	=	∅:	pick up any d	/∈	{a, b, c, n, m}  and the

	
permutation swapping a and d;	then,	[ d⟨b⟩.d⟨c⟩ ]] [[ d⟨b⟩.d⟨c⟩ ]] | [[ a( b’).a( c’) ]] −−τ→ .
−−n!−m→	and so

{n, m}∩ {a, b} = {n}: if n = b we work like in case (a); otherwise, pick up d /∈ {a, b, c, n, m}, consider the permutation swapping b and d and conclude that [ a⟨d⟩.a⟨c⟩ ]] | [[ a( b’).a( c’) ]] −−τ→ .
{n, m}∩ {a, b} = {m}: similar to case (b).
This proves that [ a⟨b⟩.a⟨c⟩ ] must exhibit either label a!b or label b!a and, consequently, that [ a( b’).a( c’) ] must exhibit either label a?b or label b?a.

By point 1 of this Lemma, we have that [ a⟨b⟩.a⟨c⟩ ]]
−−a−!b→ and [ a( b’) ]] −−a−?b→

(the other case is similar). By name invariance, we have that [ h( k’) ]] −−h−?k→ ;

this fact, together with the hypothesis [ a⟨b⟩.a⟨c⟩ ]]
−−h−!k→ , would be in contra-

diction with reasonableness of [ · ] whenever h /= a or k /= b.
Consider now the process a⟨b⟩.a⟨c⟩ | a(x); like before, [ a⟨b⟩.a⟨c⟩ ]]

(νke)h!k
−−−−−→

and [ a(x) ]] −−h−?k→ but, as we shall now prove, the input label h?k must come from a formal input action in [ a(x) ]]. Indeed, if k /= ∅, the input must be formal. If k = ∅, because of point 2 of this Proposition, it must be that h = a and k = b, or vice versa; in both cases, the input cannot rely on an actual template, otherwise [ a(x) ] would have an infinite number of parallel components (one for every name n, since a⟨n⟩.a⟨c⟩ | a(x) −−τ→ ).

By contradiction, let h /= a; then, we would have that [ a(x) ]] −−h−?k→ (since the input is formal, see point 3 of this Proposition) and so [[ d⟨b⟩.d⟨c⟩ ]] | [[ a(x) ]] −−τ→ , for any d /∈ {a, b, c, h, k}.	 


Theorem 5.11 There exists no reasonable encoding of L s
m,c,pm.

Proof. From Lemma 5.10(1,2,4), we know that the process [ a⟨b⟩.a⟨c⟩ ]] (with a, b and c pairwise distinct) must exhibit the label a!b and, possibly, some bound outputs over a (the case for a and b swapped is similar). Moreover, by a reasoning similar to the proof of Theorem 5.7, we have at least a trace of [ a⟨b⟩.a⟨c⟩ ]] with at least an input action; let n?m be the first of such input actions. If n = a and m = b,
then, by Proposition 3.1(3), we would have that [ a⟨b⟩.a⟨c⟩ ]] −−τ→ . Then, it must be
that n /= a or m /= b; if we now prove that no bound output can be produced from

[[ a⟨b⟩.a⟨c⟩ ]], then [[ a⟨b⟩.a⟨c⟩ ]] | [[ n⟨m⟩.n⟨b⟩ ]]
−−τ→ , since [ n⟨m⟩.n⟨b⟩ ]]
−−n!−m→ .

Let us consider the process	[ a⟨b⟩.a⟨c⟩ | a(x) ] and assume,	for the sake of simplicity,  that only one a!b  and one bound output action can

be produced before n?m, i.e.	[ a⟨b⟩.a⟨c⟩ ]]
−−a−!b→ P
(νk)a!k
P  −−n−?−m→ P
and

1 −−−−−→	2	3

[[ a(x) ]] −−a−?b→ Q
−−a−?k→ Q
(νme )n!m
Q , for (νk, m˜ )(P
| Q ) =⇒ [[ a⟨c⟩ ]]. Notice

that both the a?b and the a?k labels must have been originated from formal input actions: the first one because of Lemma 5.10(3), the second one because k was restricted in P1. Now, consider the process [ a⟨b⟩.a⟨c⟩ | a(x) | a(x) ] and the compu-
tation [ a⟨b⟩.a⟨c⟩ | a(x) | a(x) ]] −−τ→ P  | Q  | [[ a(x) ]] −−τ→ (νk)(P  | Q  | Q {k/b}).
1	1	1

Clearly, Q
−−a−?→	and Q {k/b} −−a−?→ , whereas P −−a−!→
Then, by Defi-

1	1	2	/  .
nition 4.4(4).b, it must be that either Q1{k/b} =⇒ Q' −−a−!k→ Q'' =⇒ [[ a(x) ]] or
Q1 =⇒ Q' −−a−!b→ Q'' =⇒ [[ a(x) ]; let us consider the second case, since the first one
τ
is similar. It is easy to prove that Q' ≡ a⟨b⟩ | Q''; so, Q1 =⇒ a⟨b⟩ | [[ a(x) ]] −−→ Q .
Hence, by assuming that [ a⟨b⟩.a⟨c⟩ ] exhibits one bound output we have proved that [ a⟨b⟩.a⟨c⟩ | a(x) | a(x) ] diverges, whereas a⟨b⟩.a⟨c⟩ | a(x) | a(x) does not; thus, [ · ] is not reasonable.	 

Concluding Assessment
We have studied the impact of synchrony in the eight communication primitives that arise when combining three common and useful programming features: arity of data, communication medium and presence of pattern matching. Our results have been summarised in Figure 1; we now briefly discuss them.
It is evident that polyadicity is the only feature that alone ensures fully abstract encodings of synchrony in asynchrony: this is related to the possibility of equipping polyadic data exchanges with auxiliary information (either a restricted channel that will be exploited for acknowledgement purposes, or the length of the data) used to synchronise the sending and the receiving process.
For monadic and channel-based communications, we have that absence of pat- tern matching makes synchrony encodable asynchronously, whereas presence of pat-

tern matching rules out any such (reasonable) encoding. The problem is that pattern matching introduces the possibility of atomically matching the name transmitted in the communication; this leaves no space for any auxiliary synchronisation infor- mation.
Finally, monadic and dataspace-based communications are too weak to ensure any reasonable encoding: the problem is that there is no way to associate a datum with the process that emitted it. The latter fact entails that those languages that exploit such primitives (e.g., Ambient [7] or CCS [15]) cannot freely interchange their synchronous and asynchronous versions, though the latter ones are still Turing powerful [7,4].

Acknowledgement
We would like to thank the EXPRESS’06 reviewers for their positive attitude and for several fruitful comments that improved the presentation of the work.

References
S. Arun-Kumar and M. Hennessy. An efficiency preorder for processes. Acta Informatica, 29(8):737– 760, 1992.
G. Boudol. Asynchrony and the π-calculus (note). Rapport de Recherche 1702, INRIA Sophia- Antipolis, May 1992.
A. Brown, C. Laneve, and G. Meredith. πduce: a process calculus with native XML datatypes. In
Proc. of 2nd Int. Workshop on Services and Formal Methods, volume 3670 of LNCS. Springer, 2005.
N. Busi, R. Gorrieri, and G. Zavattaro. A process algebraic view of Linda coordination primitives.
Theoretical Computer Science, 192(2):167–199, 1998.
D. Cacciagrano and F. Corradini. On synchronous and asynchronous communication paradigms. In
Proc. of ICTCS’01, number 2202 in LNCS, pages 256–268. Springer, 2001.
D. Cacciagrano, F. Corradini, and C. Palamidessi. Separation of synchronous and asynchronous communication via testing. In Proc. of EXPRESS, ENTCS. Elsevier, 2005.
L. Cardelli and A. D. Gordon. Mobile ambients. Theoretical Computer Science, 240(1):177–213, 2000.
G. Castagna, R. De Nicola, and D. Varacca. Semantic subtyping for the π-calculus. In Proc. of LICS, pages 92–101. IEEE Computer Society, 2005.
R. De Nicola, D. Gorla, and R. Pugliese. On the expressive power of KLAIM-based calculi. Theoretical Computer Science, 356(3):387–421, 2006.
R. De Nicola and M. Hennessy. Testing equivalence for processes. Theoretical Computer Science, 34:83–133, 1984.
C. Fournet and G. Gonthier. The reflexive chemical abstract machine and the join-calculus. In
Proceedings of POPL ’96, pages 372–385. ACM, Jan. 1996.
D. Gelernter. Generative Communication in Linda. ACM Transactions on Programming Languages and Systems, 7(1):80–112, 1985.
D. Gorla. On the relative expressive power of asynchronous communication primitives. In Proc. of FoSSaCS’06, volume 3921 of LNCS, pages 47–62. Springer, 2006.
K. Honda and M. Tokoro. An object calculus for asynchronous communication. In Proc. of ECOOP ’91, volume 512 of LNCS, pages 133–147. Springer, 1991.
R. Milner. Communication and Concurrency. Prentice Hall, 1989.

R. Milner. The polyadic π-calculus: A tutorial. In Logic and Algebra of Specification, volume 94 of
Series F. NATO ASI, Springer, 1993.
R. Milner, J. Parrow, and J. Walker. A Calculus of Mobile Processes, I and II. Information and Computation, 100(1):1–40, 41–77, 1992.
R. Milner and D. Sangiorgi. Barbed bisimulation. In Proc. of ICALP ’92, volume 623 of LNCS, pages 685–695. Springer, 1992.
V. Natarajan and R. Cleaveland. Divergence and fair testing. In Proc. of ICALP’95, volume 944 of
LNCS, pages 648–659. Springer, 1995.
C. Palamidessi. Comparing the expressive power of the synchronous and the asynchronous π-calculi.
Mathematical Structures in Computer Science, 13(5):685–719, 2003.
J. Parrow. An introduction to the pi-calculus. In Handbook of Process Algebra, pages 479–543. Elsevier Science, 2001.
B. C. Pierce and D. N. Turner. Pict: A programming language based on the pi-calculus. In Proof, Language and Interaction: Essays in Honour of Robin Milner, Foundations of Computing. MIT Press, May 2000.
P. Quaglia and D. Walker. On synchronous and asynchronous mobile processes. In Proceedings of FoSSaCS 2000, volume 1784 of LNCS, pages 283–296. Springer, 2000.
D. Sangiorgi and R. Milner. The problem of “weak bisimulation up to”. In Proc. of CONCUR, volume 630 of LNCS, pages 32–46. Springer, 1992.
G. Tel. Introduction to distributed algorithms. Cambridge University Press, 1995.


A	Omitted Proofs
To prove full abstraction results for the encodings of L s


a p,c,pm

and of

s p,d,pm
a p,d,pm
, we rely on a well-know up-to proof-technique for weak (barbed)

bisimulation [24], i.e. the up-to expansion technique. Intuitively, an expansion
relates two weakly barbed equivalent processes by taking into account the number of their τ -steps; roughly speaking, if P  Q, then P ∼= Q but P ‘has more’ τ -steps than Q.
However, we are interested in proving relations closed only under translated contexts for a fixed encoding function [ · ]] : L1 → L2; moreover, we want to precisely count the difference between the τ -steps of the processes related by an expansion. Thus, we shall slightly adapt the definition of the expansion preorder [1], as follows. There, we use  tr to denote the strong version of translated barbed equivalence,
i.e. the relation defined like in Definition 4.2 with ↓ in place of ⇓ and −−τ→ in place of =⇒ everywhere.
Definition A.1 [Translated one-step expansion] Given an encoding function [ · ]] : L1 → L2,  tr is the largest preorder between L2-processes such that, whenever P  trQ, it holds that
P −−τ→ P ' implies that either Q −−τ→ Q' for some Q' such that P '  trQ' or
P '  trQ;
P −−α→ P ', where α can be consumed by a translated process, implies that
Q −−α→ Q' for some Q' such that P '  trQ';
Q −−τ→ Q' implies that either P −−τ→ P ' for some P ' such that P '  trQ' or
P −−τ→ −−τ→ P ' for some P ' such that P '  trQ';

Q −−α→ Q', where α can be consumed by a translated process, implies that either P −−α→ P ' for some P ' such that P '  trQ' or P −−τ→ −−α→ P ' for some P ' such that P ' trQ'.
When notationally convenient, P  trQ could be also written as Q  trP . The first crucial property of tr is that it preserves and reflects divergence, as proved below.
Proposition A.2 If P  trQ then P diverges if and only if Q diverges.
Proof. The proof simply follows from Definition A.1, once observed that tr pre- serves and reflects divergence.	 
The second crucial property of tr is that translated barbed bisimilarity and equivalence up-to translated expansion (defined below) coincide with translated barbed bisimilarity and equivalence, respectively.
Definition A.3 Fix an encoding [ · ]] : L1 → L2.
A symmetric relation ঩ between L2-processes isa translated barbed bisimulation up-to expansion if, for every (P, Q) ∈ ঩, it holds that
P ↓tr implies Q ⇓tr, and
o	o
P −−τ→ P ' implies Q =⇒ Q', for some Q' such that P '  tr঩  trQ'.
tr
~

Translated barbed bisimilarity up-to expansion, =
barbed bisimulation up-to expansion.
, is the largest translated

P and Q are translated barbed equivalent up-to expansion, written P ∼=  tr Q, if
∼•  tr
and only if C[P ] =	C[Q], for every context C[·] resulting from the translation
of a L1-context via [ · ] extended with [[ [·] ]]  [·].

tr
Proposition A.4	(i) If P =
(ii) if P ∼=  trQ, then P ∼= trQ.
Q, then P ∼= trQ;

Proof. For the first claim, it suffices to prove that relation {(P, Q)  : P trP ' ∼= trQ' trQ} is a translated barbed bisimulation; this follows straightfor- wardly from Definitions A.1 and 4.2. The second claim is an easy corollary of the first one.	 
We are now ready to prove full abstraction and divergence freedom for the encodings presented in the body of the paper. They rely on a slightly enhanced version of the operational correspondence property presented in Definition 4.4.

Lemma A.5 Consider the encoding [[ · ]] : L s
a p,c,pm
s p,c,pm
-process

P. Then,

P
−−τ→ P '
implies that [[ P ]]
==⇒ [[ P ]];

[[ P ]]
−−τ→ Q implies that P
−−τ→ P ' for some P ' such that Q  tr[[ P ' ]].

Proof. Both claims are proved by a simple induction over the inference of
the  −−τ→  in their premise.	For the second claim, it is crucial to note that
(νc)(c⟨⟩ | c().P )  tr P , whenever c ∈/ Fn(P ).	 

Theorem A.6 Consider the encoding [[ · ]] : L s
a p,c,pm
p,c,pm-

process P. Then, P ∼= tr[[ P ]].
Proof. We prove that {(P, [[ P ]])} is a translated barbed bisimulation up-to trans- lated expansion. By definition of [ · ], it holds that P ↓o if and only if [ P ]] ↓o.
If P −−τ→ P ' then, by Proposition A.5(1), [ P ]] ==⇒ [[ P ]]. Finally, if [ P ]] −−τ→ Q,
then, by Proposition A.5(2), P −−τ→ P ' and Q  tr[[ P ' ]; because of Proposition A.4,
this suffices to conclude.	 
Corollary A.7 (completing Theorem 5.1) The encoding [[ · ]] : L s	−→

a p,c,pm
enjoys full abstraction w.r.t. translated barbed equivalence and does not

introduce divergence.
Proof. Full abstraction w.r.t. translated barbed equivalence easily holds by The-
•
orem A.6 and transitivity of ∼= tr. The fact that [ · ] does not introduce diver-
gence is proved by building up a divergent computation for every P such that
[[ P ]] −−τ→ω. This is an easy task, thanks to Lemma A.5(2): indeed, if [ P ]] diverges,
then [ P ]] −−τ→ Q, for some Q that diverges. Then, we can find a P ' such that
P −−τ→ P ' and Q  tr[[ P ' ]; because of Proposition A.2, also [[ P ' ]] diverges. Thus, P
reduces to a process whose encoding diverges; by iterating this reasoning arbitrarily, we can conclude that also P diverges.	 

We now prove similar results for the encoding of L s
a p,d,pm
; however,

since the encoding changes the barbs of any translated process (remember that every
source language input/output of arity k is translated in a (k + 2)-ary input/output), an analogous of Theorem A.6 cannot hold. This makes the proof of full abstraction slightly more complex; on the contrary, divergence freedom is proved exactly in the same way (thus, we shall not mention it anymore).

Lemma A.8 Consider the encoding [[ · ]] : L s
a p,d,pm
p,d,pm-

process P. Then,

P
−−τ→ P '
implies that [[ P ]]
==⇒ [[ P ]];

[[ P ]]
−−τ→ Q implies that P
−−τ→ P ' for some P ' such that Q  tr[[ P ' ]].

Proof.  Like	the	proof	of	Lemma	A.5,	but	relying	on	the	fact	that
(νc)(⟨c⟩ | ( c’).P )  tr P , whenever c /∈ Fn(P ). Indeed, (νc)(⟨c⟩ | ( c’).P ) −−?→c/ ,
(νc)!c
whereas (νc)(⟨c⟩ | ( c’).P ) −−−−→ ; however, there exists no translated process
able to exhibit a trace ρ·?c without having c ∈ Bn(ρ). Thus, (νc)(⟨c⟩ | ( c’).P ) ↓tr
cannot hold and this suffices to conclude.	 

Theorem A.9 Consider the encoding [[ · ]] : L s
a p,c,pm
•
; then, [[ · ]] is

fully abstract w.r.t. translated barbed bisimilarity, i.e. P
[[ P ]] ∼= tr [[ Q ]].
∼= Q	if and only if

Proof. For the “only if” part, we prove that


঩  {([[ P ]], [[ Q ]]) : P ∼= Q }
is a translated barbed bisimulation up-to  tr.	Let [ P ]] ↓tr


k  (the case for

[[ P ]] ↓tr k is similar); by definition of [ · ]], k = h +2 and P ↓tr	h ; then, Q ⇓tr	h

IN
and hence [ Q ]] ⇓tr	k
. Let [ P ]]
OUT
−−τ→ P ; then, by Lemma A.8(2), P
•
OUT
−−τ→ P ' and

P1  tr [[ P ' ]. Then, Q =⇒ Q' and P ' =∼ Q'; by Lemma A.8(1), this implies that [[ Q ]] =⇒ [[ Q' ]] and (P1, [[ Q' ]]) ∈঩ up-to  tr.
For the “if” part, we prove that
঩   {(P, Q) : [ P ]] =∼ tr [[ Q ]] }
is a barbed bisimulation.	Let P  ↓tr	k  (the case for P  ↓tr k  is similar);

then, [ P ]] ↓tr	k+2
and, hence, [ Q ]] ⇓tr	k+2
.	Let [ Q ]]
τ  n	tr
OUT k+2

by induction on n, we now prove that Q  ⇓tr
k , as desired.	The base

case is trivial:	[ Q ]] ↓tr
k+2 implies Q ↓tr
k .	For the inductive case, let

[[ Q ]]
−−τ→ R −−τ→ n ↓tr
; by Lemma A.8(2), Q −−τ→ Q' and R  tr [[ Q' ]]. By

definition of  tr, [[ Q' ]] conclude.
τ  m  tr
OUT k+2
, for m ≤ n, that, by induction, allows us to

Finally, let P −−τ→ P '; by Lemma A.8(1), this implies that [ P ]] =⇒ [[ P ' ]] that in
turn entails [ Q ]] =⇒ R and [ P ' ]] =∼ tr R. Let [ Q ]] −−τ→ nR; by induction on n we now
prove that R  tr [[ Q' ]], for some Q' such that Q =⇒ Q'. This suffices to conclude,

since (P ', Q') ∈ ঩ (thanks to  tr ⊆ ∼= tr and transitivity of
∼= tr). The base case

is trivial, since R = [ Q ]. For the inductive case, let [ Q ]] −−τ→ R' −−τ→ nR; by
Lemma A.8(2), Q −−τ→ Q'' and R'  tr [[ Q'' ]. By definition of  tr, [[ Q'' ]] −−τ→ mR,
for m ≤ n, that, by induction and transitivity of  tr, allows us to conclude.	 
Corollary A.10 (completing Theorem 5.2) The encoding [[ · ]] : L s	−→

a p,d,pm
enjoys full abstraction w.r.t. translated barbed equivalence and does not

introduce divergence.
