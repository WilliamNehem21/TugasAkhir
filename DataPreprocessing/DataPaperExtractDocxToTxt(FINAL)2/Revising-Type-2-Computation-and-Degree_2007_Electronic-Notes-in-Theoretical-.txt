	Electronic Notes in Theoretical Computer Science 167 (2007) 255–274	
www.elsevier.com/locate/entcs

Revising Type-2 Computation and Degrees of Discontinuity
Martin Ziegler1,2
Japan Advanced Institute of Science and Technology (JAIST) School of Information Science, 1-1 Asahidai, Nomi, Ishikawa 923-1292

Abstract
By the sometimes so-called Main Theorem of Recursive Analysis, every computable real function is neces- sarily continuous. Weihrauch and Zheng (TCS 2000), Brattka (MLQ 2005), and Ziegler (ToCS 2006) have considered different relaxed notions of computability to cover also discontinuous functions. The present work compares and unifies these approaches. This is based on the concept of the jump of a representation: both a TTE–counterpart to the well known recursion-theoretic jump on Kleene’s Arithmetical Hierarchy of hypercomputation: and a formalization of revising computation in the sense of Shoenfield.
We also consider Markov and Banach/Mazur oracle–computation of discontinuous functions and charac- terize the computational power of Type-2 nondeterminism to coincide with the first level of the Analytical Hierarchy.
Keywords: Hypercomputation, Recursion Theory, Type-2 Theory of Effectivity (TTE), Kleene and Borel Hierarchies


Introduction
Every computable real function f is necessarily continuous!
Computability here refers to effective (ρ→ρ)–evaluation in the sense of x input to a Turing machine by means of a ρ–name, that is a fast converging sequence of rationals (qn); and y = f (x) output in form of a similar sequence (pm). Equivalently: the pre-image f−1[V ] of an open set V ⊆ R is open ; and the mapping V '→ f−1[V ] is effective in the sense that, giving an enumeration of (the centers and radii of) open rational balls exhausting V , a Turing machine can output a similar list exhausting f−1[V ]. This amounts to (θ< →θ<)–computability of V '→ f−1[V ].
How can we relax this notion to include also discontinuous functions f : X → R? 3

1 Supported by JSPS grant PE 05501. The author wishes to express further gratitude to his Japanese host professor Hajime ISHIHARA for exuberant assistance and latitude!
2 Email: mziegler@jaist.ac.jp
3 Here and in the sequel, X denotes a fixed recursively open (i.e. θ< –computable) subset of RD for some
D ∈ N.

1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2006.08.015

A representation (and thus a computability notion) for L2–functions or distri- butions is devised easily and naturally [28]; but evaluation x '→ f (x) thereon is neither effective nor mathematically well-defined.
Granting a Type-2 machine access to an oracle like, say, the Halting problem increases its recursion-theoretic power but does not lift the topological restric- tion to continuous real functions; see e.g. [26, Lemma 8].
Weihrauch and Zheng (2000) have considered (ρ →ρ<)–computable functions where the output representation ρ< encodes y = f (x) ∈ R as a rational se- quence (pm) with y = supm pm. Such functions are in general only lower semi- continuous [22], that is, the pre-image f−1[V ] is open for every V = (y, ∞). As a matter of fact, f is (ρ→ρ<)–computable if and only if a '→ f−1[(y, ∞)] is (ρ> →θ<)–computable [22, Theorem 4.5].
Motivated by (a different) work of Zheng and Weihrauch (2001), [26] introduced representations ρ', ρ' , ρ'', . . . , ρ(d), ρ(d) weakening ρ and ρ<. A real number
<	<
x is ρ–computable relative to the Halting problem ∅' if and only if it is ρ'– computable [10]. More generally, x is ρ–computable relative to ∅(d) if and
only if x is ρ(d)–computable [27]; similarly for ρ(d). These representations thus parallel the levels Σd of Kleene’s Arithmetical Hierarchy.
Brattka relaxes the pre-image mapping V '→ f−1[V ] from being open and effectively open and instead considers Σd–measurability [3]. This condition requires that f−1[V ] bea Σd set in Borel’s topological hierarchy. For its ground level Σ1(X) of open subsets of X, he thus recovers classical continuity; Σ2(X) consists of the Fσ sets, and so on. The mapping V '→ f−1[V ] must furthermore be effective in the sense that, given a θ<–name of V ,a Type-2 machine must be able to obtain a name of f−1[V ] in terms of the natural representation δΣ (X)
of Σd(X);  δΣ1(X) ≡ θ<.
Real nondeterminism had been introduced in [25,26, Section 5]. A correspond- ing machine computing y = f (x) may make a binary choice at each step, as long as any infinite output sequence (qn) constitutes a ρ–name of y. This notion has been shown to include all (ρ→ρ(d))–computable functions [26, Theorem 28].
Notice that proceeding from (ρ → ρ)–computability to (ρ → ρ(d))–computability amounts to weakening the information to be output for the values (image) of the function f under consideration; whereas proceeding from effective Σ1–measurability (equivalent to (ρ→ρ)–computability) to, say, effective Σd+1–measurability amounts to weakening the encoding on the pre-image side (i.e. the domain) of f .

Overview
The present work unifies and extends approaches iii), iv), and v) above. Some main results are collected in the following
Theorem 1.1 Fix a function f : X → R and d ∈ N.
f is (ρ→ρ(d−1))–computable if and only if it is effectively Σd–measurable.

f is (ρ→ρ(d−1))–computable if and only if the mapping R e y '→ f−1[(y, ∞)] ∈
Σd(X) is well-deﬁned and (ρ> →δΣd(X))–computable.
There exists a nondeterministically computable total real function which is not
(ρ→ρ(d))–computable for any d ∈ N whatsoever.
In particular, weakly evaluable functions (in the sense of iv) range arbitrarily high on Borel’s taxonomy of discontinuity but are strictly succeeded by nondeter- minism (vi). Theorem 1.1a) also gives one explanation for the dominance in [3] of the Borel classes Σd over the (seemingly more symmetric ones) Δd.
Claims a) and b) in the above theorem turn out to actually hold even uniformly in f . To this end, we introduce in Section 4 the notion of Σd–semi measurability and a representation for according functions: a generalization unifying both [27] and [3]. The central concept in the present work is that of the jump α' of a representation α (Section 2). For the case α = ρ, it coincides with the notion from [26] and simplifies the proofs therein.
Motivated by revising computation, Section 3 considers an equally natural but different kind of jump operator on representations. The power of Type-2 Nonde- terminism [25,26, Section 5] is the topic of Section 5. And before concluding, we also briefly dive into oracle–supported Markov and Banach/Mazur computability (Section 6).
The Jump of a Representation
Ho has shown that a real number x is ρ–computable (that is admits effective ap- proximations by a fast converging rational sequence) relative to the Halting problem
∅' if and only if x is the (unconditional) limit of a computable rational sequence [10, Theorem 9]. This has suggested the alternative name ρ' for the naive Cauchy representation encoding x as an ultimately converging rational sequence. Another example, Brattka has weakened (and extended) the representation θ< ≡ δΣ1(X) for open sets to δΣd(X) mentioned above. The present section unifies these and several other notions.
We start with Cantor space {0, 1}ω which is usually and canonically represented by the identity ı [21, Definition 3.1.2.1].
Definition 2.1 Let the representation ı' :⊆ {0, 1}ω → {0, 1}ω encode an infinite string σ¯ ∈ {0, 1}ω as (the pairing of) a sequence of infinite strings ultimately con- verging to σ¯.
This amounts to the naive Cauchy representation of the effective metric Can-
tor space [2, Section 6].	An ı'–name for (σn)	is thus (an ı–name for) some

 (	)
0 1 ω such that, for each
n
= lim
. The name

ı', reminiscent of the recursion-theoretic jump, is justified because Shoenfield’s Limit Lemma immediately yields
Remark 2.2 Let O denote an arbitrary oracle. An infinite string is (ı–) computable
relative to O' if and only if it is ı'–computable relative to O.

Moreover we have
Lemma 2.3	a) Every ((ı → ı)–) computable string function F :⊆ {0, 1}ω →
{0, 1}ω is also (ı' →ı')–computable;
more precisely the apply operator (F, σ¯) '→ F (σ¯) is (ηωω × ı' →ı')–computable.
Every (ı' →ı')–continuous string function F :⊆ {0, 1}ω → {0, 1}ω is (Cantor–
)continuous.
Whenever α :⊆ {0, 1}ω → A is a representation for A, then so is α ◦ ı'.
α ≤ β implies α ◦ ı' ≤ β ◦ ı'.
In b), ηωω denotes a natural representation for continuous string functions [21, Section 2.3].
Proof.
follows from b).
Let τ˜m := F (τ¯m) where F :⊆ {0, 1}ω → {0, 1}ω is continuous. Then limm τ˜m =
F limm τ¯m .
See [2, Section 6].
immediate.
Let F denote a computable string function converting α–names to β–names. By a), F has a computable (ı' →ı')–realization G :⊆ {0, 1}ω → {0, 1}ω. This G converts (α ◦ ı')–names to (β ◦ ı')–names.	 
The rest of this section relates several known representations to ones of the form
α ◦ ı' for some α.

Weak Real Representations
Recall from [25,26, Section 2] the following
Definition 2.4 Consider the representations of R where a real y is encoded as
ρ	: a rational sequence (pm) such that |y − pm|≤ 2−m (i.e. fast convergence)
ρ< : a rational sequence (pm) such that y = sup pm (i.e. lower approximation)
m
ρ'  : a rational sequence (pm) such that y = lim pm (i.e. ultimate convergence)
m

ρ'  : a rational sequence (p ) such that y = sup inf p
(equivalently: lim inf)

<	m	m	n
⟨m,n⟩

ρ'' : a rational sequence (pm) such that y = lim lim p⟨m,n⟩
m	n
ρ'' : a rational sequence (p ) such that y = sup inf sup p

<	m	m	n	k
.
⟨m,n,k⟩

ρ(d): a rational sequence (pm) such that y = lim lim lim ··· lim p⟨n ,n ,...,n ⟩

n1 n2 n3
nd	1  2	d

Since the limit (ρ' of course coincides with the well-known naive Cauchy- representation ρCn.) These encodings constitute a hierarchy


ρ ≤ ρ< ≤ ρ' ≤ ρ'
≤ ρ'' ≤ ρ''
≤ ... ≤ ρ(d) ≤ ρ(d)
≤ ... 

of representations introduced in [26, Section 2.2]. This hierarchy correspond to—and is in particular as strict as—Kleene’s Arithmetical Hierarchy of hypercomputation
Δ1 Ç Σ1 Ç Δ2 Ç Σ2 ⊆ Δ3 ⊆ Σ3 ⊆ ... ⊆ Δd+1 ⊆ Σd+1 ⊆ ... 
in the following way: A real number y is ρ(d)–computable if and only if y is ρ(k)– computable relative to ∅(d−k) for some (or, equivalently, for every) 0 ≤ k ≤ d; and y
is ρ(d)–computable if and only if y is ρ(k)–computable relative to to ∅(d−k), see [27,
<	<
Section 7]. Notice how this extends Shoenfield’s Limit Lemma from discrete to the continuous realm [27, Section 4].
Jump of the Cauchy Representation
Proposition 2.5  ρ ◦ ı' ≡ ρ'.
In combination with Remark 2.2, this implies [10, Theorem 9]; and together with Lemma 2.3b) it includes [26, Scholium 17].
Proof. A (ρ ◦ ı')–name for x ∈ R is (basically) a sequence of rational sequences eventually stabilizing (elementwise) to a fast converging Cauchy sequence (q(n,∞))n ; that is a double sequence (q(n,m)) in Q such that
∀n ∃m0 ∀m ≥ m0 :	q(n,m) = q(n,m0) ∧ |x − q(n,m0)|≤ 2−n .
≤: For each m, let (q(1,m), q(2,m),..., q(Nm,m)) denote the longest initial part of (q(1,m),..., q(m,m)) satisfying
|q(n,m) − q(n',m)| ≤ 21−n	∀1 ≤ n ≤ n' ≤ Nm .	(1) Since (q(n,∞))n is a ρ–name and due to the eventual stabilization, Nm → ∞ as
m → ∞. Also, the sequence (Nm)m is computable from the above input. Consider
the following algorithm, starting with empty output tape:
For each m = 1, 2,.. ., test whether the initial parts of q(·,m) and q(·,m−1) up to Nm coincide: (q(1,m),..., q(Nm,m))= (q(1,m−1),..., q(Nm,m−1))? (For notational convenience, set qn,0 :≡∞ and N0 := 0.) If so, then obviously Nm ≥ Nm−1; so ap- pend (the possibly empty sequence) (q(Nm−1,m),..., q(Nm,m)) to the output. Oth- erwise let nm be maximal with (q(1,m),..., q(nm,m)) = (q(1,m−1),..., q(nm,m−1)); obviously nm < Nm, so append (q(nm,m),..., q(Nm,m)) to the output in this case. It remains to show that that yields a valid ρ'–name for x. Let ϵ = 21−n. Then
|q(n,∞) −q(n',∞)|≤ ϵ for all n' ≥ n because q(n,∞) constitutes a ρ–name. Moreover due to stabilization, there exists some maximal m with q(n,m) /= q(n,m−1). During the phase no.m corresponding to that last change, the above algorithm will detect

nm < Nm and thus output (a finite sequence beginning with) q(n,m). Moreover as q(n,·) afterwards does not change anymore, all elements q(n',m') appended sub- sequently will have n' ≥ n and m' ≥ m; in fact Nm' ≥ n' ≥ nm' ≥ n, hence
|q(n',m') − q(n,m)|≤ ϵ because q(n,m') = q(n,m) and due to Equation (1). Therefore the output constitutes a (naive) Cauchy sequence converging to x.
≥: Let (qn)n be a sequence in Q ultimately converging to x. There exists an in- creasing sequence (nm)m in N such that
∀k ≥ nm :	|qn  − qk| ≤ 2−m−1 .	(2)
The subsequence (qnm )m constitutes a ρ–name for x. For each single m, Condi- tion (2) can be falsified (formally: is co-r.e. in the input). A Turing machine is therefore able to iteratively try for nm all integer values from nm−1 on and fail only finitely often for each m.
Trial no.l thus yields a sequence (n'	)m≤l of length l such that, for each m,

'
(·,m)
eventually stabilizes to nm satisfying (2). By artificially extending each

finite sequence to an infinite one, we obtain a ρ ◦ ı'–name for x.	 

Jump of Lower Real Representation
Our next result includes, in view of Lemma 2.3a+c), [26, Theorem 11a+b) and Theorem 15b+c)] because (ρ → ρ<)–continuity implies lower-semicontinuity and (ρ< →ρ<)–continuity requires monotonicity [22].
Proposition 2.6  ρ< ◦ ı' ≡ ρ' .
Proof. A (ρ< ◦ ı')–name for x ∈ R amounts to a sequence of rational sequences eventually stabilizing (elementwise) to a sequence approaching x from below, that is a double sequence (q(n,m)) in Q such that
∀n ∃m0 = m0(n) ∀m ≥ m0 :	q(n,m) = q(n,m0) ∧ x = sup q(n,m0(n)) .

≤: Since the limit (which exists) coincides with the least accumulation point, we have


x = sup lim q(n,m)
n	m

= sup sup inf q
n	j  m≥j



(n,m)
= sup inf ⎧⎨ q(n,m) : m ≥ j
⟨n,j⟩ m ⎩ ∞	: m < j 


deduced a ρ' –name for x.
≥: Let (q(n,m) be the given double sequence in Q with x = supn infm q(n,m). We may suppose that all single sequences q(n,·), n ∈ N, are monotonically nonincreasing; and that the single sequence infm q(n,m) is nondecreasing: by proceeding (in either order!) from q(n,m) to mink≤m q(n,k) and to maxl≤n q(l,m), respectively. Moreover one can assert each single sequence q(n,·) to eventually stabilize, thus yielding a ρ< ◦ ı'–name of x: Consider for m ∈ N the function [· ♩m : Q → Q

mapping every rational to the next lower dyadic rational having denominator
2−m; formally: a/b '→ [a·2m/b♩ where [·♩ = [·♩  denotes the usual floor function
2m	0
on integers. Then proceeding from q(n,m) to [q(n,m)♩m satisfies this requirement without affecting x = supn infm q(n,m).

Jump of the Weierstraft Representation
The limit of a uniformly converging sequence of polynomials is of course continuous again. Weierstraß has shown that the converse holds as well: Any continuous function on a compact set is the uniform limit of a sequence of polynomials. This leads to the Weierstraß Representation [ρ → ρ] of the class C(K) of continuous functions f : K → R for compact K := [0, 1]D: a name of f ∈ C(K) is (an encoding of the degrees and coefficients of) a sequence of polynomials Pn ∈ Q[X] with


sup |f (x) − Pn
x∈K
(x)| =: f − Pn 
!
≤ 2−n .	(3)

By the famous Effective Weierstraß Theorem, it is equivalent to several other natural representations of C(K) [21, Section 6.1]. [25, Lemma 12b] and [26, Lemma 22] employ a representation [ρ→ρ]' for C(K) where the required fast uniform conver- gence bound 2−n in Equation (3) is weakened to ‘ultimate’ uniform convergence f − Pn  → 0. This kind of naive Weierstraßrepresentation, too, results from a jump:
Proposition 2.7  [ρ→ρ] ◦ ı' ≡ [ρ→ρ]'.
This result includes [10, Theorem 16]. The proof proceeds similarly to that of Proposition 2.5 because Equations (1) and (2) are still decidable and co-r.e. when replacing rational numbers q with rational polynomials Q and absolute value |q| with maximum norm Q  :
Fact 2.8 Given q0,..., qm,b ∈ Q (in binary encoding, say), sup0≤x≤1 |q0 + q1x +
... + qmxm| = b is decidable: by virtue of constructive root bounds, see e.g. [11].

Iterated Jumps
Climbing up in Kleene’s Arithmetical Hierarchy corresponds to iterated jumps of the Halting problem. We proceed similarly with our hierarchy of representations:
Definition 2.9 Let ı(d+1) := ı(d) ◦ ı' = ı' ◦ ı(d).
Straight forward inductive application of Remark 2.2 shows that ı(d)– computability is equivalent to ı–computability relative to ∅(d). If F and G are partial (ı→ı')–computable string functions, then their composition G◦F is (ı→ı'')– computable by Lemma 2.3a).
Theorem 2.10 For each d ∈ N, it holds ρ(d) ≡ ρ ◦ ı(d) and ρ(d) ≡ ρ< ◦ ı(d).

Proof. The induction start d = 1 has been treated in Propositions 2.5 and 2.6, respectively. Since a ρ(d+1)–name of x ∈ R is the join of ρ(d)–names of elements xn with x = limn xn, Proposition 2.5 together with Lemma 2.3e) also provides the induction step; similarly for ρ(d+1).		 
As a consequence, we obtain the following extension of [26, Theorems 11 and 15]:
Corollary 2.11 Fix f : X → R.
If f is (ρ(d) → ρ(d))–continuous, then it is continuous. If f is (ρ(d) → ρ(d))– computable, then it is also (ρ(d+1) →ρ(d+1))–computable,
If f is (ρ(d) → ρ(d))–continuous, then it is lower semi-continuous. If f is
(ρ(d) →ρ(d))–computable, then it is also (ρ(d+1) →ρ(d+1))–computable.
<	<
If f is (ρ(d) →ρ(d))–continuous, then it is monotonically nondecreasing. If f is
<	<
(ρ(d) →ρ(d))–computable, then it is also (ρ(d+1) →ρ(d+1))–computable.
<	<	<
The proof of [26, Theorem 11] covers as many as five pages of text and treated only very small values of d. Now it boils down to a mere application of Lemma 2.3a+c) inductively in d.
Borel Set Representations
The representation θ< encodes an open subset U of X as a list of (centers and radii) of open rational balls exhausting U . For a topological space X, the Borel Hierarchy starts with the class Σ1(X) of open subsets U of X and proceeds inductively from Σd(X) to the class Σd+1(X) of countable unions m(X \ Sm) over complements of sets Sm from Σd(X). Brattka has renamed θ< to δΣ1(X) and generalized it to higher order Borel sets:
Definition 2.12 Consider the following representations of Borel subsets of X: δΣ1(X) encodes U ∈ Σ1(X) as a list Bm of open rational balls s.t. U =  Bm
m
δΣ2(X)  encodes S ∈ Σ2(X) as a list Bm of open rational balls such that
.	S	=	 m X \  n B⟨m,n⟩ 
δΣd (X) encodes S ∈ Σd(X) as (the join of) Σd−1–names of sets Sm ∈ Σd−1(X)
such that S =  m(X \ Sm).
It turns out that these natural representations are related to jumps, too:

Proposition 2.13	θ<
ı' ≤ δ

Σ2(X)
Σ1(X).

Recall that Σ1(X) denotes the class of open subsets of X which θ< ≡ δΣ1(X) is a representation for. Of course the restriction of δΣ2(X) is thus necessary for the equivalence to make sense.

Proof. A (θ< ◦ ı')–name for U ∈ O(X) consists of two rational double sequences (c(n,m)) and (r(n,m)) such that each single sequence c(n,·) and r(n,·), n ∈ N, eventually stabilizes to some c(·,∞) and r(·,∞) where U =  n∈N B(c(n,∞), r(n,∞)) and B(c, r) denotes the open ball with center c and radius r.
Both representations admit effective countable unions: apply Lemma 2.3a) to [21, Example 5.1.19.1] and see [3, Proposition 3.2(5)], respectively. It therefore suffices to show them equivalent on open rational balls, that is we may suppose w.l.o.g. U = B(cm, rm) for all m ≥ m0.
So let


An	:=
⎧⎪⎨ B cm, rm · (1 − 2−n)  : (ck, rk)= (ck+1, rk+1)∀k ≥ m
⎪⎩ ∅	: otherwise

so U = n An. Moreover the closed set An can be ψ>–computed, uniformly in n and the given sequences (cm) and (rm): start generating B(··· ); if the co-r.e. condition “∀k ≥ m” eventually turns out to fail, the machine may still revert to a ψ>–name for ∅ by adding further negative information to the output. Hence we obtain a δΣ2(X)–name for U .	 
The following extends [21, Example 5.1.17.2] and [27, Corollary 6.6a)]:
Example 2.14 For reals a < b, the open interval U = (a, b) ⊆ R is Σd–computable if and only if +b and −a are both ρ(d−1)–computable.

Conjecture 2.15 The converse of Proposition 2.13 holds as well: δΣ2(X)
Σ1(X)  ≤

θ< ◦ ı'.
Problem 2.16 Recalling the weak representations of regular sets ψ◦

and θ> from

[24, Definition 3.3], characterize them in terms of ı' and some known representa- tions!
Revising Computation
This section provides some motivation and related background to the jump α' of a representation α as well as for a different kind of jump α to be introduced in Section 3.3 below.
An important (though somewhat hidden) point in the definition of a Type-2 ma- chine is that its output tape be one-way; compare e.g. [21, top of p.15]. This condition allows to abort a real number computation as soon as the desired preci- sion is reached, knowing that this preliminary approximation will not be reverted. It also is crucial for the Main Theorem to hold.
In the Type-1 setting, revising computations have been studied well. Here a machine writes only a finite string, but it does not terminate and may revert its output an arbitrary finite number of times. The model with this semantics goes under such names as Limiting [6], Trial-and-Error [16], Inductive [4], or General [17]

Turing Machines. It is motivated by the capabilities of early display terminals (see Section 3.2 below) as well as by Shoenfield’s Limit Lemma.
A sequence (σn)n of finite strings (Type-1) converges (to a finite string) if and only if the sequence σn,i of i-th symbols eventually stabilizes for each i. For infinite strings (Type-2 setting) however, one has to carefully distinguish both conditions: symbol-wise convergence underlies Definition 2.1 whereas overall stabilization will be required in Definition 3.6.
Both appear naturally when formalizing the output displayed by a (not neces- sarily terminating) program to a terminal as explicated in Section 3.2. They also arise as input fed to a streaming algorithm:

Revising Input: Streams
Many practical applications are desired to run ‘forever’: a scheduler, a router, a monitor all are not supposed to terminate but to continue processing the stream of data presented to them. This has led to the prospering field of Data Stream Algorithms 4 . It distinguishes various ways in which the input can be presented to the program [12, Section 4.1]:
In the Time Series Model, all data items (binary digits, say) are to be enumerated in order; in particular, they must not later be reverted.
This corresponds in TTE to the identity presentation ı of an infinite string by itself.
The Turnstile Model on the other hand permits (finitely many) later updates to previously enumerated items.
This corresponds to the presentation ı' from Definition 2.1.

Revising Output: Terminals
Recall the two most basic ascii control characters understood already by the ear-

liest text display consoles [23]:
and
. The first, called “backspace”, moves

the cursor left by one position, thus allowing the last printed symbol to be over- written; whereas the second, “carriage return”, commands to restart output from the beginning (of the present line).
Example 3.1 The character sequence

o o d  b y e
e l l o,  M r s
w o r l d

will display as: Hello, world.
So consider a program generating an infinite sequence of characters including
and	; how do they appear on an (infinitely long, one-line) display? Let us
require that each character position does settle down eventually, leading ultimately
to the display of a truly infinite string (without	and	).

4 which usually focuses on the (space) complexity of randomized approximations of discrete problems, though

Definition 3.2 A –name of σ¯ ∈ {0, 1}ω is an infinite string over {0, 1,	,	}
which leads to the display of σ¯ in the above sense.
Now this is exactly what we had already considered in Definition 2.1:
Remark 3.3 ≡ ı'.
Each occurrence of the control character	leads to the entire display being
purged.  In order for already the first character to eventually stabilize, a valid
–name may thus contain at most finitely many	’s. Let us now consider a

terminal incapable of processing
, that is, restrict to {0, 1,
}ω. Then any

valid name will make the displayed text settle down not only character-wise but globally. This motivates a different jump operator α '→ α formally introduced in the sequel:
Remark 3.4  {0,1,	}ω ≡ ^ı.
Hopefully you, most valued reader, are now indeed curious enough to read on and learn about the computational power induced by this
Other Kind of Jump
[26, Section 5.1] characterizes the computational power of Chadzelek and Hotz’ quasi-strongly δ–Q–analytic machines in terms of Type-2 machines by introducing the representation ρH as follows:
Definition 3.5 A ρH–name for x ∈ R is a sequence (qn)n in Q such that
∃N ∈ N ∀n ≥ N :	|qn − x|≤ 2−n

This representation is non-uniformly equivalent to ρ yet uniformly (in terms of reducibility that is) lies strictly between ρ and ρ'.
Similarly to Section 2, we now generalize this particular construction into a generic way:
Definition 3.6 For a representation α :⊆ {0, 1}ω → A, write α := α ◦ ı.
The representation ^ı :⊆ {0, 1}ω → {0, 1}ω in turn encodes an infinite string
		 
m ∈ N, such that there is some M ∈ N with τ¯m = σ¯ for all m ≥ M .
In contrast to Definition 2.1, the sequence (τ¯m) is thus required to ultimately stabilize uniformly in the position index n.
In view of Claim f) of the following lemma, Claims a) to c) generalize [26, Lemma 31]; and Claims d+e) generalize [26, Proposition 32b+a].
Lemma 3.7 Fix representations α of A and β of B.
An element a ∈ A is α–computable if and only if it is α^–computable.
It holds α ≤ α^ ≤ α'. The converse reductions are in general discontinuous.

For any function f :⊆ A → B, (α→ β)–computability is equivalent to (α → β)– computability.
Every (α → β)–computable function f is also (α → β)–computable; even uni- formly in f.
An (α → β)–computable function need not be (α→β)–continuous.
ρ ≡ ρH.
Proof. It suffices to treat the case (A, α) = (B, β) = ({0, 1}ω, ı)—except for f) of course.
Encode the M from Definition 3.6 into the machine computing (τ(n,m))(n,m) and make it output (τ(n,M ))n .
The positive claims are immediate, the negative ones are straight-forward dis- continuity arguments.
By a), every (ı → ı)–computable function is (ı → ı)–computable, too. For the converse implication, take the Type-2 Machine M converting ı–names for x ∈ R to ı–names for y = f (x). Let (σ¯m) be given with σ¯m = σ¯M for all m ≥ M , M ∈ N unknown.
Now simulate M on σ¯1 (implicitly supposing M = 1) and simultaneously check that σ¯1 = σ¯m for all m ≥ 1. If (or, rather, when) the latter turns out to fail, restart under the presumption M = 2 and so on. The check will however succeed after finitely many tries (after reaching the ‘true’ M used in the input). We thus obtain a finite sequence of output strings, that is a valid ı–name for f (σ¯).
The apply operator (F, σ¯) → F (σ¯) is (ηωω × ı → ı)–computable: if τ¯m = σ¯ for all m ≥ M , then also F (τ¯m)= F (σ¯) for all m ≥ M .
Consider the discontinuous function F (1ω ) := 1ω , F (σ¯) := 0ω for σ¯ /= 1ω . We assert it to be (ı→ı)–computable; the claim the follows by c).
Given σ¯ = (σn)n , for each n = 1, 2,... test σn = 1 and, as long as this holds, append 1 to the output. Otherwise restart the output to 0ω . Since this restart takes place (if at all) after finite time, we obtain in either case a valid ^ı–name.
Given (τ¯m)m with τ¯m = σ¯ for all m ≥ M , consider for each m the longest
initial segment of τm constituting the beginning of a valid ρ–name. This is computable because dom(ρ) is r.e.; and it yields a ρH–name for ρ(σ¯), i.e. we have “ρ^ ≤ ρCn”. The converse reduction proceeds similarly.	 

Real Hypercomputation and Degrees of Discontinu- ity
Computability of a function f : X → R in Recursive Analysis means (ρ → ρ)– computability; equivalently [21, Lemma 6.1.7]: the pre-image f−1[V ]= {x : f (x) ∈ V } of any open V ⊆ R is again open (that is in Σ1(X)) and the pre-image mapping
V '→ f−1[V ] is (θ< → δΣ (X))–computable. In particular, every computable real

function is necessarily continuous.
How can we extend the notion of computability to incorporate also (at least some) discontinuous functions?
Recalling the introduction, one may
iii) consider (ρ→ρ<)–computable functions.
A function f : X → R is (ρ → ρ<)–continuous  if and only if  it is low- ersemi continuous, i.e., f−1[V ] is open for any V = (y, ∞). It is (ρ → ρ<)– computable if and only if the mapping R e y '→ f−1 (y, ∞) ∈ Σ1(X) is well- defined and (ρ> →δΣ1(X))–computable [22, Theorem 4.5(1) and Corollary 5.1(2)]. A natural representation (here denoted by [ρ→ρ<]) of lower-semicontinuous functions on X encodes f as the join of the θ<–names of the open sets f−1[(y, ∞)], y ∈ Q; cf. [22, Definition 3.2].
Another approach due to Brattka, it is equally natural to
v) consider functions f : X → R for which the pre-image f−1[V ] of any open V ⊆ R belongs to the Borel class Σd(X) (is Σd–measurable) and the mapping V '→ f−1[V ] is (θ< →δΣ (X))–computable (called effectively Σd–measurable).
The comprehensive paper [3] thoroughly studies this notion and its consequences. It is as general as to include also partial and multi-valued functions on arbitrary computable metric spaces but in that respect goes beyond our purpose. [3] also introduces a natural representation δΣd(X→R) for Σd–measurable functions as the join of δΣ (X)–names of the sets f−1[V ], V running through all open rational balls. For reasons which will be come clear soon, the present work prefers to write [ρ → ρ(d−1)] for δΣ (X→R).
Let us unify these two Approaches iii) and v):
Definition 4.1 Call f : X → R be Σd–lowersemimeasurable if f−1 (y, ∞)  ∈
Σd(X) for all y ∈ R.  It is effectively Σd–lowersemimeasurable if R e y '→

f−1 (y, ∞) is in addition (ρ> →δ

Σd(X)
)–computable. The representation [ρ→ρ(d)]

of all Σd+1–lowersemimeasurable functions is defined to encode f : X → R as the join of δΣ (X)–names of f−1 (y, ∞) for all y ∈ Q.
Obviously [ρ→ρ(d)] ≡ [ρ→ρ(d)] ∧ [ρ→ρ(d)], exploiting f−1[U ∩ V ]= f−1[U ] ∩
<	>
f−1[V ] and [3, Proposition 3.2(4)] as well as ρ(d) ≡ ρ(d) ∧ ρ(d) by Lemma 2.3a) and
<	>
Theorem 2.10.
The main result of the present section connects these notions to weak function evaluation (ρ→ρ(d)) and (ρ→ρ(d))—recall Section 1, Approach iv)—with the repre- sentations from Section 2.1. In fact, justifying the above names for representations of (lowersemi)measurable functions, we show
Theorem 4.2 a) The uniformly characteristic function 1 : Σd(X) ×X → {0, 1}, deﬁned by (S, x) '→ 1S(x) :=1 if x ∈ S and 1S(x) :=0 if x /∈ S, is (δΣd(X) × ρ→ρ(d−1))–computable.

The apply operator (f, x) '→ f (x) of Σd+1–lowersemimeasurable functions on
X is  [ρ→ρ(d)] × ρ→ρ(d) –computable.

Every (ρ→ρ(d))–continuous function f : X → R is Σ
d+1
–lowersemimeasurable;

every (ρ→ρ(d))–computable one is effectively Σ
d+1
–lowersemimeasurable,

uniformly in f given by an ηωω–name of a realization.

Claims b) and c) together immediately establish the non-uniform Theorem 1.1b) which in turn yields Theorem 1.1a).
An alternative proof of Theorem 1.1a), however only for d ≥ 3, could proceed by induction [3, Corollary 9.6] and exploit that the pointwise limit f of a sequence fn of (ρ→ρ(d−2))–computable functions is (ρ→ρ(d−1))–computable.

Proof (Theorem 4.2)
By induction on d, starting with d = 1: Given a ρ–name of x ∈ X and a θ<–name of an open U ⊆ U , membership “x ∈ U ” is semi-decidable; so output 0s while uncertain and start writing 1s as soon as membership has been established: this yields a ρ<–name of 1U (x).
Now let S =  n(X \ Sn) ∈ Σd+1(X) be given by the joint δΣ(d)(X)–names of
S  ∈ Σ (X), n ∈ N. By induction hypothesis, ρ(d−1)–compute the respective
n	d	<
values yn := 1Sn (x). Since x ∈ S ⇔ ∃n : x /∈ Sn, we have 1S(x)= supn(1 −
yn).
Given (a ρ–name of) x ∈ X, compute for all y ∈ Q a δΣd+1(X)–name of Sy :=
f−1 (y, ∞) . Claim a) yields from that a ρ(d)–name of zy := 1S (x), that is
y
zy =1 in case x ∈ Sy and zy =0 in case x /∈ Sy. Easy scaling converts that to
' = a in case f (x) > y and to z' = −∞ in case f (x) ≤ y. We finally obtain

a ρ(d)–name of sup z' = f (x) because R¯ N e (x )
'→ sup x
∈ R¯ is obviously

<	y y
n n	n  n

 (ρ(d))N →ρ(d) –computable.
To start with, recall the proof of [22, Theorem 3.7] the classical case
d = 0: Evaluate f simultaneously on all x ∈ X to obtain rational sequences px,n with f (x) = supn px,n. More precisely, using feasible countable (as opposed to infeasible uncountable) dove-tailing, simulate the machine evaluating f on all initial parts of ρ–names of x ∈ X, that is on all finite rational sequences q¯ = (q1, q2,..., qN ) with N ∈ N and |qn − qk| ≤ 2−n∀n ≤ k ≤ N . For each q¯, we obtain as output a finite rational sequence (pq¯,m)m≤M . Observe that q¯ is initial segment of a ρ–name to any x ∈ Bq¯ :=  N (q¯) B(qn, 2−n), Bq¯ having
non-empty interior. Hence


◦
∃m : pq¯,m > a	⇔	∀x ∈ Bq¯ : f (x) > a	⇔	∃x ∈ Bq¯ : f (x) > a 

which implies


f−1 (a, ∞)
=	  ⎧⎨ Bq¯
:: p


q¯,m
> a ⎫⎬	=
 ◦ 
Bq¯
:: p


q¯,m
> a ⎫⎬

q¯,m ⎩
∅ :	pq¯,m ≤ a ⎭
q¯,m ⎩ ∅ :	pq¯,m ≤ a ⎭

`	∈˛Σ¸1	x
and immediately yields δΣ (X)–computability of f−1[(a, ∞)] for given a ∈ Q.
d = 1: Similarly evaluate f on all x ∈ X to obtain sequences px,n,m with f (x) = sup inf px,n,m. More precisely countable dove-tailing yields, to each finite ρ–
n	m
initial segment q¯, a finite sequence (pq¯,m,n)m,n in Q with
◦
∃m∀n : pq¯,m,n > a	⇔	∀x ∈ Bq¯ : f (x) > a	⇔	∃x ∈ Bq¯ : f (x) > a 
and hence


¸  ⎧⎨ B
=:Aq¯,m∈Π1
:: xp`
> a ⎫⎬˛

⎧⎨ ◦

:: p

> a ⎫⎬

q¯,m n ⎩ ∅ :	pq¯,m,n ≤ a ⎭
q¯,m n ⎩
∅ :	pq¯,m,n ≤ a ⎭

`	∈˛Σ¸2	x
a δΣ (X)–name of f−1[(a, ∞)] as the δΣ (X)–names of all open X \ Aq¯,m. d = 2: Compute finite rational sequences (pq¯,m,n,k)m,n,k with
◦
∃m∀n∃k : pq¯,m,n,k > a	⇔	∀x ∈ Bq¯ : f (x) > a	⇔	∃x ∈ Bq¯ : f (x) > a ,

f−1 (a, ∞)	=	     ⎧⎨ Bq¯ : pq¯,m,n,k > a ⎫⎬

q¯,m n
k ⎩ ∅ : pq¯,m,n,k ≤ a ⎭
¸



⎧⎨  ◦ 


∈Σ1
x`

⎫⎬˛

=	 
Bq¯ : pq¯,m,n,k > a 

q¯,m n k ⎩ ∅ : pq¯,m,n,k ≤ a ⎭
`	∈˛Π¸2	x
d ≥ 3: analogously.	 

Power of Type-2 Nondeterminism
We now expand on Approach vi) from the introduction of the present work: Moti- vated by Bu¨chi’s discovery of nondeterministic automata as the appropriate notion

of regular languages over infinite strings [20] as well as by the famous Immerman– Szelepsc´enyi concept of nondeterministic function computation [15, Theorem 7.6] and by fair nondeterminism [19], we introduced in [25,26, Section 5] the nondeter- ministic Type-2 Model:
Definition 5.1 Let A and B be sets with respective representations α :⊆ {0, 1}ω → A and β :⊆ {0, 1}ω → B. A function f :⊆ A → B is called nondeterministically (α → β)–computable if some nondeterministic one-way Turing Machine M,
upon input of any α–name σ¯ ∈ {0, 1}ω for some a ∈ dom(f ),
has a computation which outputs a β–name for b = f (a)	and
every infinite computation of M on σ¯ outputs a β–name for b = f (a).
A subset L of A is nondeterministically decidable if the characteristic function 1L :
A → {0, 1}×{ }ω is nondeterministically (α → ı)–computable.
While admittedly even less realistic than a classical NP–machine, its capabili- ties have turned out to exhibit (in addition to closure under composition) particular structural elegance: All presentations ρ(d), d ∈ N, can nondeterministically be con- verted to and from each other. Hence we may simply speak of nondeterministic com- putability and observe that this notion includes all functions (ρ→ρ(d))–computable for any d, that is by Theorem 1.1a) the entirety of Brattka’s hierarchy of effective measurability.
Remark 5.2 In [25, Definition 14], we had defined nondeterministic computability in a way with the third condition in Definition 5.1 requiring that any infinite output of M on σ¯ constitutes a β–name for b = f (a). Since any infinite output requires infinite computation but not vice versa, this may seem to lead to a different notion. However both do coincide: M may additionally guess and verify a function F : N → N such that the n–th symbol is output after F (n) steps. If F has been guessed incorrectly (and in particular if, for the given input σ¯, no such F exists at all), then this can be detected within finite time and abort the computation, thus complying with the (only seemingly stronger) Definition 5.1.
The question of exactly characterizing the power of these machines, left open in [26, Section 5], is now answered in terms of the Analytical Hierarchy:
Theorem 5.3 For L ⊆ N, the characteristic function 1L : N → {0, 1}×{ }ω is nondeterministically computable if and only if L ∈ Δ1.
In particular, the power of Type-2 nondeterminism goes strictly beyond effective measurability; see Corollary 5.6 below.
The following notion turns out as both natural and useful in the proof of Theo- rem 5.3:
Definition 5.4 A set L ⊆ N is nondeterministically semi-decidable if there exists a nondeterministic Turing machine M which, upon input of x ∈ N,
has a computational path which outputs an infinite string	in case x ∈ L;

in case x /∈ L, aborts after finite time on all computational paths.
L is nondeterministically enumerable if a nondeterministic Turing machine M with- out input
has a computational path which outputs a list (xn)n of integers with L = {xn :
n ∈ N};
every infinite computation of M prints a list (xn)n of integers with L = {xn : n ∈
N}.
Nondeterministic enumerability thus amounts to nondeterministic computability of an En–name, cf. [21, Definition 3.1.2.5]. Surprisingly, it turns out as equivalent not to nondeterministic semi-decidability but to nondeterministic decidability:
Proposition 5.5 With respect to Type-2 nondeterminism, it holds:
En ≡ Cf, where the latter refers to the representation of the powerset of N
enumerating a set’s members in order [21, Definition 3.1.2.6].
L ⊆ N is decidable if and only if it has a computable Cf–name; equivalently: both L and its complement are semi-decidable.
L ⊆ N is semi-decidable if and only if L ∈ Σ1.
Proof.
“Cf ≤ En” holds already deterministically. For the converse we are given a list (xn)n of integers enumerating L. Guess a function F : N → N with xn ≥ m∀n ≥ F (m): Such obviously F exists; and an incorrect guess can be detected within finite time. Knowing F , we can determine and sort all restrictions L ∩ [1, m], m ∈ N.
Immediate.
Let L ∈ Σ1. By the Normal Form Theorem—see e.g. [13, Proposition IV.2.5]—
L	=	 x ∈ N ∃¯b = (bn) ∈ {0, 1}ω ∀n ∈ N : P (x, n, ⟨b1,..., bn⟩)}	(4) for some decidable predicate P . A nondeterministic Type-2 machine M, given
x, may therefore guess ¯b, check P (x, n, ¯b|≤n) to hold (and output a dummy
symbol) for each n ∈ N and, when it fails, abort within finite time: This yields nondeterministic semi-decision of L.
Conversely let L be semi-decided by M. Then x ∈ N belongs to L if and
only if  there exists a sequence (bn)n of guesses bn ∈ {0, 1}	such that M
ω
makes at last n steps on x and ¯b. The latter predicate P (x, n, ⟨b1,..., bn⟩) being decidable, L is of the form (4).	 

Claims b) and c) together yield Theorem 5.3. Moreover we have
Corollary 5.6 There is nondeterministically computable real c which does not be-

long to (any ﬁnite 5 level of) Weihrauch and Zheng’s Arithmetical Hierarchy of real numbers.
The constant function f (x) ≡ c establishes Theorem 1.1c).
Proof (Corollary 5.6) Take some hyperarithmetical but not arithmetical L ⊆ N, that is, L ∈ Δ1 \ Σ1; see e.g. [14, Theorem §16.1.XI] or [13, Corollary IV.2.23].
1	0
Since L is nondeterministically decidable, it leads to a nondeterministically ρb,2– computable real c := n∈L 2−n ∈ R; compare [21, Theorem 4.1.13]. Were c ρ(d)– computable for some d ∈ N, its (unique!) binary expansion would be decidable relative to ∅(d) [27, Theorem 7.8], that is in Σd+1 ⊆ Σ1, contradiction.	 
Markov Oracle–Computation
Returning to Approach ii) in Section 1, oracle access to the, say, Halting problem does not permit computational evaluation x '→ f (x) of any discontinuous real func- tion f in the sense of Recursive Analysis, that is with respect to input x and output f (x) by means of fast convergent rational sequences. Other notions of effectivity due to A.A. Markov, Jr. [21, Section 9.6] and S. Mazur [21, Section 9.1] restrict real functions to computable arguments x ∈ Rc.
Definition 6.1 A function f :⊆ Rc → R is Markov–computable if is admits a (classically, i.e. discretely) computable Markov realization, that is a function F :⊆ N → N such that, whenever e is G¨odel index of a Turing machine Me ρ–computing x ∈ dom(f ), then F (e) is defined and index of a machine ρ–computing f (x). Call f BM–computable if f (xn)  is a computable real sequence whenever (xn)n ∈ dom(f ) is.
A (ρ→ρ)–computable function is obviously Markov–computable which in turn implies BM–computability. Moreover Mazur’s theorem asserts every total BM– computable function to be continuous; and Markov–computability of a total real function requires (ρ → ρ)–computability according to Tseitin [21, Theorem 9.6.6]. See [7,8] for a thorough comparison of all these notions.
Now, as opposed to (ρ→ρ)–computability, Markov–computability does benefit even topologically from oracle access:
Example 6.2 The discontinuous sign function sgn : Rc → {−1, 0, +1} is, relative to the Halting problem ∅', both Markov–computable and BM–computable.
Observe that in accordance with Definition 6.1, sgn is considered on the com- putable reals only.
Proof. Given a Go¨del index e of some machine Me computing x, modify Me slightly to abort in case x /= 0. Feed this new machine’s index e˜ into Halting oracle. A negative answer implies x = 0; the remaining cases x < 0 and x > 0 are trivial. Similarly for BM–computability.	 

5 It may however belong to a transfinite one [1].

We are currently working the following generalizations of Mazur’s and Tseitin’s Theorems:
Problem 6.3 Fix a total function f : Rc → R.
If f is Markov–computable relative to ∅', then it is Σ2–measurable?
If f maps every ρ'–computable sequence to a ρ'–computable one, then it is continuous?
Characterize the class of total functions Markov–computable relative to ∅'!
How about higher degrees?
Conclusion
We have characterized (ρ→ρ(d))–computable functions f : X → R to coincide with Brattka’s condition of effective Σd+1–measurability; and shown his representation


d+1
(X→R) to be natural for the class of (ρ → ρ(d))–continuous functions.  We

furthermore have characterized (ρ → ρ(d))–computable functions and, extending work of Weihrauch and Zheng, found a natural representation for the class of (ρ→ ρ(d))–continuous ones.
Problem 7.1 Find a simple characterization of the respective classes of (ρ(k) →
ρ(d))–continuous, (ρ(k) → ρ(d))–continuous, and (ρ(k) → ρ(d))–continuous functions
<	<	<
with 1 ≤ k ≤ d arbitrary but ﬁxed; and devise natural representations for them.

If α is an admissible representation, then α(d) is usually not for d ≥ 1, at least not in the strict sense. This seems to call for Schr¨oder’s theory of generalized admissibility [18]. On the other hand, Corollary 2.11 succeeded well without this notion.

Acknowledgments:
The author is grateful to K. Weihrauch, V. Brattka, P. Hertling, and X. Zheng for constant support and seminal discussions. Section 5 results from research initiated by U. Kohlenbach and D. Norman during CiE’05. I would also like to repeat the many thanks expressed in Footnote 1 .

References
G. Barmpalias: “A Transfinite Hierarchy of Reals”, pp.163–172 in Mathematical Logic Quarterly
vol.49(2) (2003).
V. Brattka, P. Hertling: “Topological Properties of Real Number Representations”, pp.241–257 in
Theoretical Computer Science
V. Brattka: “Effective Borel measurability and reducibility of functions”, pp.19–44 in Mathematical Logic Quarterly vol.51 (2005).
M. Burgin: “Algorithmic Complexity of Recursive and Inductive Algorithms”, pp.31–60 in Theoretical Computer Science vol.317 (2004).

T. Chadzelek, G. Hotz: “Analytic Machines”, pp.151–167 in Theoretical Computer Science vol.219 (1999).
E.M. Gold: “Limiting Recursion”, pp.28–48 in Journal of Symbolic Logic vol.30:1 (1965).
P. Hertling: “A Sequentially Computable Function that is not Effectively Continuous at any Point”, pp.131–148 in Proc. 2nd International Conference on Computability and Complexity in Analysis (CCA’05).
P. Hertling: “A Banach–Mazur computable but not Markov computable function on the computable real numbers”, pp.227–246 in Ann. Pure Appl. Logic vol.132 (2005).
P.G. Hinman: “Recursion–Theoretic Hierarchies”, Springer Perspectives in Mathematical Logic (1978).
C.-K. Ho: “Relatively Recursive Real Numbers and Real Functions”, pp.99–120 in Theoretical Computer Science vol.210 (1999).
M. Mignotte: “Identification of Algebraic Numbers”, pp.197–204 in Journal of Algorithms vol.3 (1982).
S. Muthukrishnan: “Data Streams: Algorithms and Applications”, vol.1:2 of Foundations and Trends◯R
in Theoretical Computer Science (Editor: Madhu Sudan), now publishers (2005); preliminary version: http://www.cs.rutgers.edu/~muthu/stream-1-1.ps

P. Odifreddi: “Classical Recursion Theory ”, North-Holland (1989).
H. Rogers, Jr.: “Theory of Recursive Functions and Effective Computability ”, MIT Press (1987).
C.H. Papadimitriou: “Computational Complexity ”, Addison-Wesley (1994).
H. Putnam: “Trial and Error Predicates”, pp.49–57 in Journal of Symbolic Logic vol.30:1 (1965).
J. Schmidhuber: “Hierarchies of Generalized Kolmogorov Complexities and Nonenumerable Universal Measures Computable in the Limit”, pp.587–612 in International Journal of Foundations of Computer Science vol.13:4 (2002).
M. Schr¨oder: “Admissible Representations in Computable Analysis”, pp.471–480 in Proc. 2nd Conference on Computability in Europe (CiE’06), Springer LNCS vol.3988.
E. Spaan, L. Torenvliet, P. van Emde Boas: “Nondeterminism, Fairness and a Fundamental Analogy”, pp.186–193 in The Bulletin of the European Association for Theoretical Computer Science (EATCS Bulletin) vol.37 (1989).
Thomas, W.: “Automata on Infinite Objects”, pp.133–191 in Handbook of Theoretical Computer Science, vol.B (Formal Models and Semantics), Elsevier (1990).
K. Weihrauch: “Computable Analysis”, Springer (2000).
K. Weihrauch, X. Zheng: “Computability on continuous, lower semi-continuous and upper semi- continuous real functions”, pp.109–133 in Theoretical Computer Science vol.234 (2000).
Wikipedia,	the	free	encyclopedia:	“Computer	terminal”,
http://en.wikipedia.org/wiki/Computer terminal

M. Ziegler: “Computability on Regular Subsets of Euclidean Space”, pp.157-181 in Mathematical Logic Quarterly 48+1 (2002).
M. Ziegler: “Computability and Continuity on the Real Arithmetic Hierarchy and the Power of Type-
2 Nondeterminism”, pp.562–571 in Proc. 1st Conference on Computability in Europe (CiE’2005), Springer LNCS vol.3526.
M. Ziegler: “Real Hypercomputation and Continuity”, to appear in Theory of Computing Systems; pre-print http://arxiv.org/cs.LO/0508069

X. Zheng, K. Weihrauch: “The Arithmetical Hierarchy of Real Numbers”, pp.51–65 in Mathematical Logic Quarterly vol.47 (2001).
N. Zhong, K. Weihrauch: “Computability Theory of Generalized Functions”, pp.469–505 in J. ACM
vol.50 (2003).
