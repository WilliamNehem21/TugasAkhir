

Electronic Notes in Theoretical Computer Science 248 (2009) 131–147
www.elsevier.com/locate/entcs

Bousi∼Prolog: a Prolog Extension Language for Flexible Query Answering 
Pascual Julia´n-Iranzo1	Clemente Rubio-Manzano2 Juan Gallardo-Casero3
Dep. of Information Technologies and Systems, University of Castilla-La Mancha,
Spain.

Abstract
In this paper we present the main features and implementation details of a programming language that we call Bousi∼Prolog. It can be seen as an extension of Prolog able to deal with similarity-based fuzzy unification (“Bousi” is the Spanish acronym for “fuzzy unification by similarity”). The main goal is the implementation of a declarative programming language well suited for flexible query answering.
The operational semantics of Bousi∼Prolog is an adaptation of the SLD resolution principle where classical unification has been replaced by an algorithm based on similarity relations defined on a syntactic domain. A similarity relation is an extension of the standard notion of equivalence relation and it can be useful in any context where the concept of equality must be weakened. Hence, the syntax of Bousi∼Prolog is an extension of the Prolog’s language: in general, a Bousi∼Prolog program is a set of Prolog clauses plus a set of similarity equations.
Keywords: Fuzzy Logic Programming, Fuzzy Prolog, Unification by Similarity, Weak SLD Resolution.


Introduction
Fuzzy Logic Programming integrates fuzzy logic and pure logic programming in order to provide these languages with the ability of dealing with uncertainty and approximate reasoning. There is no common method for this integration, though, most of the works in this field can be grouped in two main streams. See for instance: [9,14,18,2,21,28], for the first line, and [4,5,6,7,25] for the second one. A possible way to go, if we want to grapple with the issue of flexible query answering 4 , is to follow

٨ This work has been partially supported by FEDER and the Spanish Science and Education Ministry (MEC) under grants TIN 2004-07943-C04-03 and TIN 2007-65749.
1 Email: Pascual.Julian@uclm.es
2 Email: Clemente.Rubio@alu.uclm.es
3 Email: Juan.Gallardo@alu.uclm.es
4 If you are pursuing a different objective, other approaches are preferable.

1571-0661 © 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.07.064

the conceptual approach introduced in [25] where the notion of “approximation” is managed at a syntactic level by means of similarity relations. A similarity relation is an extension of the standard notion of equivalence relation and it can be useful in any context where the concept of equality must be weakened. In [25]a new modified version of the Linear resolution strategy with Selection function for Definite clauses (SLD resolution) is defined, which is named similarity-based SLD resolution (or weak SLD resolution —WSLD—). This operational mechanism can be seen as a variant of the SLD resolution procedure where the classical unification algorithm has been replaced by the weak unification algorithm formally described in [25] (and reformulated in terms of a transition system in [16]). Informally, Maria Sessa’s weak unification algorithm states that two terms f (t1,... , tn) and g(s1,... , sn) weakly unify if the root symbols f and g are considered similar and each of their arguments ti and si weakly unify. Therefore, the weak unification algorithm does not produce a failure when there is a clash of two syntactical distinct symbols whenever they are similar.
In this paper we present the main features and implementation details of a pro- gramming language that we call Bousi∼Prolog (BPL for short), with an operational semantics based on the weak SLD resolution principle of [25]. Hence, Bousi∼Prolog computes answers as well as approximation degrees. Essentially, the Bousi∼Prolog syntax is just the Prolog syntax but enriched with a built-in symbol “∼∼” used for describing similarity relations by means of similarity equations of the form:
<alphabet symbol> ~~ <alphabet symbol> = <similarity degree>.

Although, formally, a similarity equation represents an arbitrary fuzzy binary re- lation, its intuitive reading is that two constants, n-ary function symbols or n-ary predicate symbols are similar with a certain degree. Informally, we use the built-in symbol “∼∼” as a compressed notation for the symmetric closure of an arbitrary fuzzy binary relation (that is, a similarity equation a ∼∼ b = α can be understood in both directions: a is similar to b and b is similar to a with degree α). Therefore, a Bousi∼Prolog program is a sequence of Prolog facts and rules followed by a sequence of similarity equations.
The structure of the paper is as follows. Some motivating examples are given in Section 2. The examples serve to introduce syntactical aspects of the Bousi∼Prolog language as well as to sustain the usefulness of the proposal. Section 3 presents the Bousi∼Prolog system structure, briefly describing its main components. Section 4, after recalling the definition of a similarity relation, gives some insight about its internal representation and how it is computed. The rest of this section is devoted to the implementation of the weak unification algorithm, which is the basis of the similarity-based SLD resolution principle. Section 5 presents the formal definition of Sessa’s Weak SLD resolution principle and details of its concrete implementation in our system. In Section 6, information about distinct classes of cuts and negations are given. Section 7 discusses the relation of our work to other research lines on fuzzy logic programming. Finally, in Section 8 we give our conclusions and some lines of future research.

In the following, we assume some familiarity on the basic concepts of logic pro- gramming [1].

Motivating examples
Our first example serves to illustrate BPL syntax as well as some features of its operational behavior in a very simple context.
Example 2.1 Consider the program Autumn that consists of the following clauses and similarity equations:
% FACTS	warm :- sunny.	% SIMILARITY EQUATIONS
In an standard Prolog system a query as “?- happy” fails, since we are specifying that it is warm if it is summer time (first rule) and, actually, it is autumn. Similarly, the query “?- rainy” fails also.
However, the BPL system is able to compute the following successful deriva- tions 5 :
⟨← happy, id, 1⟩ =⇒WSLD ⟨← warm, id, 1⟩ =⇒WSLD ⟨← summer, id, 1⟩
=⇒WSLD ⟨ , id, 0.5⟩.
Here, the last step is possible because summer weakly unifies with the fact autumn, since there is a transitive connection between summer and autumn with approxi- mation degree 0.5 (the minimum of 0.7 and 0.5). Therefore, the system answers “Yes, with approximation degree 0.5”.
⟨← rainy, id, 1⟩ =⇒WSLD ⟨← spring, id, 1⟩ =⇒WSLD ⟨  , id, 0.7⟩.
In this case, the system answers “Yes, with approximation degree 0.7” be- cause spring and autumn weakly unify with approximation degree 0.7 and the last step is possible.
In general, Bousi∼Prolog computes answers as well as approximation degrees which are the minimum of the approximation degrees obtained in each step of a derivation.
The second example shows how Bousi∼Prolog is well suited for flexible query answering.
Example 2.2 This BPL program fragment specifies features and preferences on books stored in a data base. The preferences are specified by means of similarity equations:
% FACTS
adventures(treasure_island). adventures(the_call_of_the_wild).

5 The symbol “id” denotes the identity substitution and “ ” the empty clause.

sim(interesting, adventures, 0.9).	sim(mystery, science_fiction, 0.5).
sim(interesting, mystery, 0.5).	sim(horror, interesting, 0.5).
sim(interesting, horror, 0.5).	sim(horror, adventures, 0.5).
sim(interesting, science_fiction, 0.8).	sim(horror, mystery, 0.9).
sim(adventures, interesting, 0.9).	sim(horror, science_fiction, 0.5).
sim(adventures, mystery, 0.5).	sim(science_fiction, interesting, 0.8).
sim(adventures, horror, 0.5).	sim(science_fiction, adventures, 0.8).
sim(adventures, science_fiction, 0.8).	sim(science_fiction, mystery, 0.5).
sim(mystery, interesting, 0.5).	sim(science_fiction, horror, 0.5).
sim(mystery, adventures, 0.5).	sim(_G1282, _G1282, 1.0).
sim(mystery, horror, 0.9).

Fig. 1. Similarity relation generated from the similarity equations in Example 2.2.

mystery(murders_in_the_rue_morgue). horror(dracula). science_fiction(the_city_and_the_stars). science_fiction(the_martian_chronicles).

% RULES
good(X) :- interesting(X).

% SIMILARITY EQUATIONS
adventures~~mystery = 0.5.	adventures~~science_fiction = 0.8.
adventures~~interesting = 0.9.	mystery~~science_fiction = 0.5.
science_fiction~~horror = 0.5.	mystery~~horror = 0.9.
When this program is loaded an internal procedure constructs a similarity rela- tion (i.e. a reflexive, symmetric, transitive, fuzzy binary relation) on the syntactic domain of the program alphabet. More information about how a similarity relation is constructed, starting from an arbitrary fuzzy binary relation, is given in Sec- tion 4. Figure 1 shows the compiled code generated when the similarity relation is obtained from the similarity equations of this example. Therefore, all kind of books considered as interesting are retrieved by the query “BPL> sv good(X)”. Note that, in the last query, “sv” is a shell command of the Bousi∼Prolog system used for solving goals (see Section 3).
The third example shows how similarity equations can be used to obtain a clean separation between logic and control in a pattern matching program.
Example 2.3 The following program gives the number of occurrences of a pattern
[e1,e2] in a list of elements, where e1 must be a and e2 may be b or c.
% SIMILARITY EQUATIONS
e1~~a=1.	e2~~b=1.	e2~~c=1.

% FACTS and RULES
search([ ],0).	search([X|R],N):-search1([X|R],N).

search1([ ],0).
search1([X|R],N):-X~~e1 -> search2(R,N); search1(R,N). search2([ ],0).
search2([X|R],N):-X~~e2 -> search([X|R],N1), N is N1+1;


search([X|R],N).

occurrences(N):-search([a,b,c,a,c,b,d,a,c,d,b,b,a,b,c,c,a,c,a,b],N).
Here, “~~” is the weak unification operator and the expression “X~~e1” means that (the value bound to) “X” and “e1” weakly unify with approximation degree greater than zero. Since the programmer wrote the similarity equation “e1~~a=1” in the program, the expression will succeed when X will be instantiated to “a”. The same can be said for the expression “X~~e2”.
It is easy to adapt the above program permitting the search of more complex combinations of patterns. For instance, by introducing the similarity equation: e1~~b=1. In order to reach our goal, in this case, it is mandatory not to generate the transitive closure of the fuzzy relation defined by the set of similarity equations. This can be done by means of the BPL directive “:- transitivity(no)”, which inhibits the construction of the transitive closure, during the translation phase. The idea is to avoid the ascription of “e1” and “e2” to the same equivalence class, that can be a problem for the intended behavior of the new program.
Summarizing, with the new sentences added, the resulting program will count the number of occurrences of a pattern [e1,e2] in a list of elements, where e1 may be a or b and e2 may be b or c.
The last example shows how similarity equations can be used as a fuzzy model for information retrieval where textual information is selected or analyzed using an ontology [8], that is, a structured collection of terms that formally defines the relations among them. Hence, inside a semantic context instead of a purely syntactic context. This is an extreme useful application in a world dominated by the Semantic Web [3], where people are exposed to great amounts of (textual) information.
Example 2.4 A practical textual inference task is finding concepts which are struc- turally analogous 6 . Similarity equations can help in this task. The set of similarity equations shown below has been obtained using ConceptNet [13], a freely available commonsense knowledge-base and natural-language-processing toolkit 7 . Concept- Net is structured as a network of semi-structured natural language fragments. It has a GetAnalogousConcepts() function that returns a list of structurally analo- gous concepts given a source concept. In our case the source concept is “wheat”. The degree of structural analogy between terms is also provided by ConceptNet. The set of similarity equations is a partial view of the original output, which was hand-made adapted by ourselves.
We want to extract information on terms structurally analogous to “wheat” on a given text. In our example, the input text is borrowed from Reuters, a test collection for text categorization research 8 . The data in this collection was originally collected and labeled by Carnegie Group, Inc. and Reuters, Ltd. in the course of developing

6 By structurally analogous we mean that they share similar properties and have similar functions (e.g.: “scissors”, “razor”, “nail clipper”, and “sword” are perhaps like a “knife” because they are all “sharp”, and can be used to “cut something”).
7 Available at http://web.media.mit.edu/ hugo/conceptnet/.
8 Available at http://www.daviddlewis.com/resources/testcollections/reuters21578/.

the CONSTRUE text categorization system. The fragment text of our example is one classified with the label (topic) “wheat” and processed by erasing stop words and the endings of a word stem.
% SIMILARITY EQUATIONS
wheat~~bean=0.315.	bean~~corn=0.48.	bean~~potato=0.5. wheat~~corn=0.315.	bean~~animal=0.35.	bean~~crop=0.315. wheat~~grass=0.315.	bean~~child=0.33.	bean~~flower=0.315. wheat~~horse=0.315.	bean~~grass=0.315.	bean~~table=0.35. wheat~~human=0.205.	bean~~horse=0.335.

% FACTS and RULES
%% searchTerm(T,L1,L2), true (with approximation degree 1) if
%% T is a (constant) term, L1 is a list of (constant) terms
%% (representing a text) and L2 is a list of triples t(X,N,D);
%% where X is a term similar to T with degree D, which occurs
%% N times in the text L1 searchTerm(T,[],[]).
searchTerm(T,[X|R],L):- (T~~X=AD ->
searchTerm(T,R,L1), insert(t(X,1,AD),L1,L); searchTerm(T,R,L)).

insert(t(T,N,D), [], [t(T,N,D)]).
insert(t(T1,N1,D), [t(T2,N2,_)|R], [t(T1,N,D)|R]) :-
T1 == T2, N is N1+N2. insert(t(T1,N1,D), [t(T2,N2,D2)|R2], [t(T2,N2,D2)|R]) :-
T1 \== T2, insert(t(T1,N1,D), R2, R).

% GOAL
g(T,L):-searchTerm(T,[agriculture,department,report,farm,own,
reserve,national,average,price,loan,release, price,reserves,matured,bean, grain,enter,corn, sorghum,rates,bean,potato], L).
The following illustrate a simple session with the Bousi∼Prolog system.
BPL> sv g(corn,L)
With approximation degree: 1.0
L = [t(potato, 1, 0.48), t(bean, 2, 0.48), t(corn, 1, 1.0)] Yes
The information returned by the goal can be used lately to analyze the input text or to obtain a degree of preference in a retrieval process.











Fig. 2. Functional dependency graph of the Bousi∼Prolog system
Bousi∼Prolog System Architecture Structure
The Bousi∼Prolog system we are presenting is a prototype, high level implemen- tation written on top of SWI-Prolog [30] and is publicly available 9 . The complete implementation consists of about 900 lines of code. Figure 2 shows the structure of the BPL system through a functional dependency graph.
The bousi module contains the bpl shell/0 main predicate which implements a command shell. Hence, providing the interface for the user. The relevant commands are:
ld -> (load) reads a file containing the source program for loading;
lt -> (list) displays the current loaded program;
sv -> (solve) solves a (possibly conjunctive) query;
lc -> (lambda-cut) reads or sets the lower bound for the approximation degree in a weak unification process (see later for a more detailed explanation of this feature).
The rest of commands are implemented as interface to the (unix) system environ- ment.
The bplHelp module provides on-line explanation about the syntax of the com- mands and how they work.
The parserTranslator module contains the parseTranslate/2 predicate. This predicate parses a BPL InputFile and translates (compiles) it into an Out- putFile which contains an intermediate Prolog representation of the source BPL code. The intermediate Prolog code is called “TPL code” (Translated BPL code). The parser phase is delegated to standard Prolog predicates. This is an imperfect solution because we lost the control of the whole parsing process and it imposes some real limitations 10 . However this is the cheapest solution. The improvement of the parser phase is let for future work.
The evaluator module implements the weak unification algorithm and the weak SLD resolution principle, which is the operational semantics of the language. Weak SLD resolution is implemented by means of a meta-interpreter [27]. The next two sections are devoted to precise the details of this implementation. The evaluator

9	The prototype implementation of the Bousi∼Prolog system can be found at the URL address
http://www.inf-cr.uclm.es/www/pjulian/bousi.html.
10 For instance, we cannot use operators defined by the user, that is the “:- op( , , )” directive.


prog.bpl	prog.tpl






Goals


Results
Fig. 3. Flow diagram overview of the Bousi∼Prolog system
module uses the builtin module, which contains a relation of predicates which are sent directly to the SWI-Prolog interpreter.
The utilities module contains a repository of predicates used by other mod- ules.
A schematic overview of the translation, load and execution of BPL programs is shown in Figure 3. In this figure, boxes denote different components of the system and names in boldface denote (intermediate) files. The source code of the BPL program must be stored in a file with the suffix “.bpl” (e.g., prog.bpl). The parserTranslator parses the BPL source file and translates (compiles) it into an intermediate Prolog representation of the source BPL code, which is stored in a file with the suffix “.tpl”. Finally, the clauses in the TPL file are loaded into the Prolog workspace. Then, the system is ready to admit queries which are solved by the evaluator meta-interpreter.

Similarity Equations and Weak Unification
The weak unification algorithm operates on the basis of a similarity relation. A similarity relation on a set U is a fuzzy binary relation on U × U , that is, a mapping Y : U × U → [0, 1], holding the following properties: reflexive; symmetric and transitive. In this context, “transitive” means that Y(x, z) ≥ Y(x, y)ΔY(y, z) for any x, y, z ∈ U ; where the operator ‘Δ’ is an arbitrary t-norm. Following [25], in the sequel, we restrict ourselves to similarity relations on a syntactic domain where the operator Δ = Λ (that is, it is the minimum of two elements).
Similarity equations of the form “<symbol> ~~ <symbol> = <degree>” are used to represent an arbitrary fuzzy binary relation Y.  A similarity equation a ~~ b = α is representing the entry Y(a, b)= α. Internally, a similarity equation like the last one is coded as: sim(a, b, α).
The user supplies an initial subset of similarity equations and then, the system automatically generates a reflexive, symmetric, transitive closure to obtain, by de- fault, a similarity relation. However, if the BPL directive “:- transitivity(no)” is included at the beginning of a BPL program, only the reflexive, symmetric closure is computed. Therefore, a similarity equation a ~~ b = α can be understood in both directions: a is similar to b and b is similar to a with degree α.
A foreign predicate, closure/3, written in the C programming language [17], implements the algorithm for the construction of the similarity relation. This algo- rithm, has three steps. The first step computes the reflexive closure of the initial

relation; the second the symmetric closure. The third step is an extension of the well-known Warshall’s algorithm for computing the transitive closure of a binary relation, where the classical meet and joint operators on the set {0, 1} have been changed by the maximum (MAX) and the minimum (MIN) operators on the real interval [0, 1] respectively:
for(k = 0; k < nTotal; k++) { for(i = 0; i < nTotal; i++) {
for(j = 0; j < nTotal; j++) { dMatrix[i][j] = MAX(dMatrix[i][j],
MIN(dMatrix[i][k], dMatrix[k][j]));
}}}
Here, initially, dMatrix is the adjacency matrix representing the reflexive, symmet- ric closure of the original fuzzy binary relation on a syntactic set. An interesting property of this algorithm is that it preserves the approximation degrees provided by the programmer in the similarity equations 11 . See [15] for more details about the construction of a similarity relation and the properties of the transitive closure algorithm we are using. How to link a foreign predicate into the Prolog environment is explained in the SWI-Prolog reference manual [30].
The specific weak unification algorithm is implemented following closely Martelli and Montanari’s unification algorithm for syntactic unification [20], but as usual in Prolog systems we do not use occur check:
% Term decomposition
unify(T1,T2,D) :- compound(T1), compound(T2), !,
functor(T1, F1, Aridad1), functor(T2, F2, Aridad2), Aridad1 =:= Aridad2, sim(F1, F2, D1),
T1 =.. [F1| ArgsT1], T2 =.. [F2| ArgsT2],
unifyArgs(ArgsT1, ArgsT2, D2), min(D1, D2, D). unify(C1, C2, D) :- atomic(C1), atomic(C2), !, sim(C1, C2, D).
% Swap
unify(T,X, D) :- nonvar(T), var(X), !, unify(X,T, D).

% Variable elimination unify(X,T, 1) :- var(X), X = T.

11 Whenever the elements of the initial matrix fulfill the so called “transitivity property” [15]. Given an adjacency matrix, M = [mij ], an element mij /= 0 preserves transitivity if for each k ∈ {1, ... , n}, mik ∧ mkj ≤ mij . Informally, this means that an initial set of similarity equations such as a ∼∼ b = 0.7,
b ∼∼ c = 0.8 and a ∼∼ c = 0.5, is not an admissible entry for the predicate closure/3. In this case, the transitive closure algorithm produces the outputs sim(a, c, 0.7) and sim(c, a, 0.7), overlapping the initial approximation degree provided by the user.

The predicate unifyArgs(ArgsT1, ArgsT2, D) checks if the terms (arguments) in the lists ArgsT1 and ArgsT2 can unify one with each other, obtaining a certain approximation degree D.
In order to understand the behavior of the predicate unify/3, the following comments are useful:
As stated by the first clause defining the predicate unify/3 the weak unification algorithm does not produce a failure when there is a clash of two syntactical distinct symbols F1 and F2 whenever they are similar. That is, the goal sim(F1, F2, D1) succeeds with approximation degree D1, because there exists a similarity relation between F1 and F2.
The fourth clause defining the predicate unify/3 is the point where variables are instantiated, generating the bindings of the weak most general unifier.
Hence, this algorithm provides a weak most general unifier as well as a numerical value, called the uniﬁcation degree in [25]. Intuitively, the unification degree will represent the truth degree associated with the (query) computed instance.
Bousi~Prolog implements a weak unification operator, denoted by “~~”, which is the fuzzy counterpart of the syntactical unification operator “=” of standard Prolog. It can be used, in the source language, to construct expres- sions like “Term1 ~~ Term2 =:= Degree” which is interpreted as follows: The expression is true if Term1 and Term2 are unifiable by similarity with approx- imation degree AD equal to Degree. In general, we can construct expressions “Term1 ~~ Term2 <op> Degree” where “<op>” is a comparison arithmetic opera- tor (that is, an operator in the set {=:=, =\=, >, <, >=, =<}). Observe that the expression “Term1 ~~ Term2” is syntactic sugar of “Term1 ~~ Term2 > 0”. Also it is possible the following construction: Term1 ~~ Term2 = Degree which succeeds if Term1 and Term2 are weak unifiable with approximation degree Degree; otherwise fails. When Degree is a variable it is bound to the unification degree of Term1 and Term2. These expressions may be introduced in a query as well as in the body of a clause.

Example 4.1 Assume that the BPL program of Example 2.2 is loaded. The fol- lowing is a simple session with the BPL system:
BPL> sv adventures(X) ~~ interesting(Y) > 0.5 With approximation degree: 1
X = _G1248 Y = _G1248
Yes

BPL> sv adventures ~~ mystery With approximation degree: 1 Yes
Both goals succeed with approximation degree 1 because: adventures(X) and
interesting(Y) weakly unify with unification degree 0.9, greater than 0.5;

adventures and mystery directly weakly unify with unification degree 0.5, greater than 0; and the comparison operator is a crisp 12 one.
BPL> sv adventures(X) ~~ mystery(Y) = D With approximation degree: 1
X = _G1714 Y = _G1714 D = 0.5;
No answers
This goal succeeds with approximation degree 1 because it is completely true that adventures(X) and mystery(Y) weakly unify with unification degree 0.5. There are not more answers since only a weak unifier representative is returned.
Note that the last goal is equivalent to the following one:
BPL> sv unify(adventures(X), mystery(Y), D) With approximation degree: 1
X = _G2522 Y = _G2522 D = 0.5
Yes

Finally observe that Bousi~Prolog also provides the standard syntactic uni- fication operator “=”. The operator symbol “=” is overloaded and it can be used in different contexts with different meanings: i) it behaves as an iden- tity when it is used inside a similarity equation or inside the construction “Term1 ~~ Term2 = Degree”; ii) it behaves as the syntactic unification operator when it is used dissociated of the weak unification operator “~~”.

Operational Semantics
Let Π be a set of Horn clauses and Y a similarity relation on the first order alphabet induced by Π. We define Weak SLD (WSLD) resolution as a transition system
⟨E, =⇒WSLD⟩ where E is a set of triples ⟨G, θ, α⟩ (goal, substitution, approximation degree), that we call the state of a computation, and whose transition relation
=⇒WSLD⊆ (E × E) is the smallest relation which satisfies:
C = (A ←Q) << Π, σ = wmgu(A,A') /= fail, λ = Y(σ(A),σ(A'))
⟨(←A',Q'), θ, α⟩ =⇒WSLD ⟨← σ(Q, Q'),σ ◦ θ, λ Λ α⟩
where σ is the weak most general unifier of A and A', λ is the unification degree obtained by applying the (extended) similarity relation Y to terms σ(A) and σ(A'), Q, and Q' are conjunctions of atoms, and the notation “C << Π” is representing that C is a standardized apart clause in Π.

12 That is, it is a boolean operator with values ranging in the set {0, 1}.

% solve(Goal): solve Goal giving a computer answer
% and its approximation degree. solve(Goal) :- solve(Goal, Degree),
write(’With approximation degree: ’), write(Degree),
nl.

% solve(Goal, Degree): true if there is a refutation
% for ’Goal’ with approximation degree ’Degree’. solve(true,1):- !.
% Crisp Negation As Failure solve(\+(A), D) :- !, (solve(A, DA)
-> (DA = 1 -> fail; D = 1); D = 1).
solve((A,B), D) :- !,
solve(A, DA),
solve(B, DB),
min(DA, DB, D).
solve((C -> A), D):- !, (solve(C, DC) -> solve(A, DA), min(DC, DA, D)).
solve((C -> A;B), D):- !, (solve(C, DC) ->
solve(A, DA), min(DC, DA, D) ; solve(B, DB), D = DB).
solve((A;B), D) :- !, (solve(A, DA), D = DA ; solve(B, DB), D = DB).
% Weak Negation As Failure solve(not(A), D) :- !, (solve(A, DA)
-> (DA = 1 -> fail; D is 1 - DA); D = 1).
solve(A, 1) :- built(A), !, call(A). solve(A, D) :- rule(H,B),
unify(A, H, AD), lambdaCut(L),
AD >= L,
solve(B, DB),
min(AD, DB, D).

Fig. 4. A meta-interpreter for executing BPL code

A WSLD derivation for Π ∪ {G0} is a sequence of steps ⟨G0, id, 1⟩ =⇒WSLD
...  =⇒WSLD	⟨Gn, θn, λn⟩.	and a WSLD refutation is a WSLD derivation
⟨G0, id, 1⟩ =⇒WSLD∗ ⟨ , σ, λ⟩, where σ is a computed answer substitution and λ is its approximation degree. Certainly, a WSLD refutation computes a family of answers, in the sense that, if σ = {x1/t1,... , xn/tn} then whatever substitution θ' = {x1/s1,... , xn/sn}, holding that si ≡R,λ ti (i.e., Y(si, ti) ≥ λ), for any
1 ≤ i ≤ n, is also a computed answer substitution with approximation degree
λ. However, in practice, we only return a representative of the family of answers.
As it was commented in Section 3, the parseTranslate/2 predicate of the parserTranslator module translates (compiles) rules and facts of the source BPL code into an intermediate Prolog code representation which is called “TPL code” (Translated BPL code). More precisely, a rule “Head :- Body” is translated to “rule(Head, Body)” and a fact “Head” to “rule(Head, true)”
A meta-interpreter executes the TPL code according to the WSLD resolution principle. Figure 4 shows the implementation of the meta-interpreter.
The following clauses are the core of the WSLD resolution principle implemen- tation:
solve(true,1):- !.
solve((A,B), D) :- !, solve(A, DA), solve(B, DB), min(DA, DB, D). solve(A, D) :- rule(H,B), unify(A, H, AD),
lambdaCut(L), AD >= L, solve(B, DB), min(AD, DB, D).
These clauses assert that:

The goal true is solved with approximation degree 1.
In order to solve a conjunctive goal (A, B) firts solve the atom A, obtaining an approximation degree DA, and then the remaining conjunctive goal B, obtaining an approximation degree DB. The approximation degree of the hole conjunctive goal is the minimum of DA and DB.
In order to solve the atom A, select a rule whose head H and A weakly unify with approximation degree AD. If AD is greater or equal than the current LambdaCut value L (see below), solve the body B of the rule, obtaining an approximation degree DB. Then, the approximation degree of the goal is the minimum of AD and DB.

Distinct Classes of Cuts and Negations
We can impose a limit to the expansion of the search space in a computation by what we called a “lambda-cut”. When the LambdaCut flag is set to a value different to zero, the weak unification process fails if the computed approximation degree goes below the stored LambdaCut value. Therefore, the computation also fails and all possible branches starting from that choice point are discarded. By default the LambdaCut value is zero (that is, no restriction to a computation is imposed). However, the LambdaCut flag can be set to a different value by means of a lambdaCut directive introduced inside of a BPL program or the lc command of the BPL shell. The lc command can be used to show which is the current Lambdacut value or to set a new Lambdacut value.
Bousi~Prolog can use the standard cut predicate of the Prolog language, “!”, but, in an indirect way, embedded into more declarative predicates and operators, such as: not (weak negation as failure —see below—), \+ (crisp negation as failure
—see below—) and -> (if-then and if-then-else operators).
On the other hand Bousi~Prolog provides an operator “\+” for crisp negation as failure and a predicate “not” for weak negation as failure. As we shall see, the last one presents a soft shape, instead of the characteristic function’s crisp slope of an ordinary set, with values ranging in the real interval [0, 1]. The implementation of these distinct classes of Negation is as follows:
A goal \+(A) fails only if solve(A, DA) succeeds with approximation degree DA
=1. Otherwise \+(A) is true with approximation degree 1. That is “\+” operates as the classical negation as failure.
% Crisp negation as failure solve(\+(A), D) :- !, (solve(A, DA)
-> (DA = 1 -> fail; D = 1); D = 1).
A goal not(A) fails only if solve(A, DA) succeeds with approximation degree DA
=1. When solve(A, DA) succeeds, but the approximation degree DA is less than 1, not(A) also succeeds with approximation degree D = 1 - DA. If it is the case that solve(A, DA) fails, not(A) succeeds with approximation degree D = 1.
% Weak negation as failure


solve(not(A), D) :- !, (solve(A, DA)
-> (DA = 1 -> fail; D is 1 - DA); D = 1).

Related Work
Several fuzzy extensions of the resolution rule [23], used in classical logic program- ming, with similarity relations have been proposed during the last decade. Although all these approaches rely in the replacement of the classical syntactic unification al- gorithm by a similarity-based unification algorithm, we can distinguish two main lines of research:
The first one is represented by the theoretical works [6,7] and [5], where the concept of unification by similarity was first developed. However they use the cum- bersome notions of clouds, systems of clouds and closures operators in its definition. From our point of view, these notions endangers the efficiency of the operational semantics which uses them, because they are costly to compute. The main prac- tical realization of this line of work is the fuzzy logic language LIKELOG [4]: it is mainly implemented in Prolog using the aforementioned concepts and rather direct techniques.
The second line of research is represented by the theoretical works [24] and [25], where the concept of weak unification was developed. The proposed algorithm is a clean extension of Martelli and Montanari’s unification algorithm for syntactic uni- fication [20]. From our point of view, the weak unification algorithm is better suited for computing. As it was commented, the combination of the weak unification algo- rithm with the SLD resolution rule produces the weak SLD operational semantics that we use, in part, for our Bousi~Prolog implementation. In [19], an interpreter of a fuzzy logic programming language, named SiLog, is presented. SiLog is written in Java and implements an inference engine based on the weak SLD operational semantics. SiLog provides a graphical interface in order to help the programmer in the management of similarity relations. This graphical interface is the surface of an step-by-step procedure, first defined in [24], which constructs a similarity relation starting from a finite set U and an ordered set of similarity degrees Λ = {λ0,... , λn} with 0 = λ0 < λ1 < ... < λn = 1. The algorithm is interactive because, for each iteration, the programmer defines a more refined set of partitions on the basis of subjective choices (he decides which elements of U can be considered similar with a certain approximation degree λi).
Ending this paragraph, let we say that Bousi~Prolog differs from SiLog in the following relevant points:
Bousi~Prolog is a true Prolog extension (covering the main features of the Prolog language) and not a simple interpreter able to execute the weak SLD resolution principle.
Bousi~Prolog manages similarity relations in a different way as SiLog does. Bousi~Prolog allows the partial specification of a similarity relation by means of a set of similarity equations. Similarity equations are constituents of a pro- gram and, actually, they are defining an arbitrary fuzzy relationship. Starting

from the similarity equations, using an algorithm able to generate several clo- sures of the original fuzzy relation, it is possible to obtain, optionally, either a proximity relation (when the reflexive, symmetric closure is generated) or a similarity relation (when additionally to the reflexive, symmetric closure, the transitive closure is also generated —which is the actual default option—). Such a mechanism is more flexible and useful. On the one hand, the user inter- vention is not required because the algorithm is automatic. Finally, to allow the use of proximity relations may produce expressive advantages [26] and it may be determinant in order to solve certain problems (See Example 2.3).
Since, in practice, the Bousi~Prolog operational mechanism uses proximity relations (as well as similarity relations), it is more general and flexible than SiLog operational mechanism which is exclusively based on similarity relations.
Despite the interest of systems like LIKELOG or SiLog, a limited amount of imple- mentation details are provided about them, preventing a more extensive comparison. Also, for the best of our knowledge, the implementation of these systems are not publicly available and, therefore, it is not possible an experimental comparison with our system.
Another piece of related work is the wide research area of classification analysis and retrieval of information [22,11], since a number of proposals in this area are based on the use of ontologies [8,10]. An ontology defines (specifies) the concepts, relationships, and other distinctions that are relevant for modeling a semantic do- main. It can be something as simple as a collection of terms (with or without an explicit defined meaning) organized into a hierarchical structure, or something as complex as a semantic network [13,12]. Example 2.4 demonstrates that working with an ontology as simple as a fuzzy taxonomy of terms is also useful. Similarity equations can specify such a class of fuzzy ontologies.

Conclusions and Further Research
In this paper we present the main features and implementation details of a pro- gramming language that we call Bousi~Prolog (“Bousi” is the spanish acronym for “fuzzy unification by similarity”). It can be seen as an extension of Prolog which incorporates similarity-based fuzzy unification, leading to a system well suited to be used for approximate reasoning and flexible query answering.
The so called weak unification algorithm [25] is based on similarity relations defined on a syntactic domain. At a syntactic level, Bousi~Prolog represents simi- larity relations by means of similarity equations. The syntax of Bousi~Prolog is an extension of the standard Prolog language: in general, a Bousi~Prolog program is a set of Prolog clauses plus a set of similarity equations.
Bousi~Prolog implements a weak unification operator, denoted by “~~”, which is the fuzzy counterpart of the syntactical unification operator “=” of standard Prolog. The weak unification operator can be included in a query or in the body of a rule.
Although Bousi~Prolog implements the main features of a standard Prolog, other

features, such as the ability for implementing user defined operators and working with modules, are not covered. In the future we want to add these missing features to our language. Also we want to improve certain modules of our system, such as the parser, and to incorporate new non standard features. Regarding to this last point, we are working for adding to the system: a repository of fuzzy ontologies and an automatic generator of fuzzy ontologies in the line of the one proposed in [29].
On the other hand, the operational semantics used by Bousi~Prolog is imple- mented by means of a meta-interpreter. This is a cheap solution from the implemen- tation point of view but expensive from the point of view of the efficient execution. In order to solve the efficiency problem, we have investigated how to incorporate the weak unification algorithm into the Warren Abstract Machine. Some preliminary results for a pure subset of Prolog can be find in [16]. Also we want to develop this line of work to cover all the present and future features of Bousi~Prolog in a more efficient implementation.
Finally, on the theoretical side, as it was said, Bousi~Prolog actually may use proximity relations instead similarity relations (which are subsets of the former ones). Therefore, it is important to study the formal properties of proximity rela- tions in combination with the SLD resolution principle.

Acknowledgement
We would like to thank Francisco Pascual Romero by his valuable comments on the field of information retrieval and its connection with ontologies. Also by providing us the structural analogy and the input text used in Example 2.4.

References
K. R. Apt. From Logic Programming to Prolog. Prentice Hall, Englewood Cliffs, NJ, 1997.
J. F. Baldwin, T. P. Martin, and B. W. Pilsworth. Fril- Fuzzy and Evidential Reasoning in Artificial Intelligence. John Wiley &amp; Sons, Inc., 1995.
T. Berners-Lee, J. Hendler, and O. Lassila. The semantic web. Scientific American, pages –, May 2001. Also in http://www.w3.org/2001/sw/.
F. A. Fontana and F. Formato. Likelog: A logic programming language for flexible data retrieval. In
Proc. of SAC, pages 260–267, 1999.
F. A. Fontana and F. Formato. A similarity-based resolution rule. Int. J. Intell. Syst., 17(9):853–872, 2002.
F. Formato, G. Gerla, and M. I. Sessa. Extension of logic programming by similarity. In APPIA- GULP-PRODE, pages 397–410, 1999.
F. Formato, G. Gerla, and M I. Sessa. Similarity-based unification. Fundam. Inform., 41(4):393–414, 2000.
T. R. Gruber. Toward principles for the design of ontologies used for knowledge sharing. International Journal Human-Computer Studies, 43(5-6):907–928, 1995.
S. Guadarrama, S. Mun˜oz, and C. Vaucheret. Fuzzy Prolog: A new approach using soft constraints propagation. Fuzzy Sets and Systems, Elsevier, 144(1):127–150, 2004.
N. Guarino. Formal ontology, conceptual analysis and knowledge representation. International Journal Human-Computer Studies, 43(5-6):625–640, 1995.

N. Guarino, C. Masolo, and G. Vetere. Ontoseek: Content-based access to the web. IEEE Intelligent Systems, 14(3):70–80, 1999.
H.Liu and P. Singh. Commonsense reasoning in and over natural language. In Proc. of the 8th Internl. Conf. KES, pages 293–306, 2004.
H.Liu and P. Singh. Conceptnet – a practical commonsense reasoning tool-kit. BT Technology Journal, 22(4):211–226, 2004.
M. Ishizuka and N. Kanai. Prolog-ELF Incorporating Fuzzy Logic. In Proceedings of the 9th IJCAI, pages 701–703. Morgan Kaufmann, 1985.
P. Juli´an-Iranzo. A procedure for the construction of a similarity relation. In Proc. of the 12th IPMU, pages 489–496. Univ. M´alaga, 2008.
P. Juli´an-Iranzo and C. Rubio-Manzano. A wam implementation for flexible query answering. In Proc. of the 10th IASTED ASC, pages 262–267. ACTA Press, 2006.
B.W. Kernighan and D.M. Ritchie. The C Programming Language, 2nd Edition. Prentice-Hall, 1988.
R.C.T. Lee. Fuzzy Logic and the Resolution Principle. Journal of the ACM, 19(1):119–129, 1972.
V. Loia, S. Senatore, and M. I. Sessa. Similarity-based SLD resolution and its implementation in an extended prolog system. In FUZZ-IEEE, pages 650–653, 2001.
A. Martelli and U. Montanari. An Efficient Unification Algorithm. ACM Transactions on Programming Languages and Systems, 4:258–282, 1982.
J. Medina, M. Ojeda, and P. Vojt´aˇs. Similarity-based unification: a multi-adjoint approach. Fuzzy Sets and Systems, 146(1):43–62, 2004.
S. Miyamoto. Information retrieval based on fuzzy associations. Fuzzy Sets and Systems, 38(2):191–205, 1990.
J.A. Robinson. A Machine-oriented Logic Based on the Resolution Principle. Journal of the ACM, 12(1):23–41, January 1965.
M. I. Sessa. Flexible querying in deductive database. In School on Soft Computing at Salerno University: Selected Lectures 1996-1999, pages 257–276. Springer Verlag, 2000.
M. I. Sessa. Approximate reasoning by similarity-based SLD resolution. Theoretical Computer Science, 275(1-2):389–426, 2002.
S. Shenoi and A. Melton. Proximity relations in the fuzzy relational database model. Fuzzy Sets and Systems, 100:51–62, 1999.
L. Sterling and E. Shapiro. The Art of Prolog (Second Edition). The MIT Press, 1994.
P. Vojtas. Fuzzy Logic Programming. Fuzzy Sets and Systems, 124(1):361–370, 2001.
D.H. Widyantoro and J. Yen. Incorporating fuzzy ontology of term relations in a search engine. In
Proc. of BISC International Workshop on Fuzzy Logic and the Internet. Univ. of California, 2001.
J. Wielemaker. SWI-Prolog 5.6 Reference Manual. TR: ver. 5.6.52, March 2008, Univ. of Amsterdam, 2008.
