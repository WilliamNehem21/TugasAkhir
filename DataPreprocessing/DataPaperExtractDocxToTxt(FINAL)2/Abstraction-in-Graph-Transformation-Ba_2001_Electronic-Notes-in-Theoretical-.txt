Electronic Notes in Theoretical Computer Science 50 No. 3 (2001) { Proc. GT-VMT 2001 URL:  http://www.elsevier.nl/locate/entcs/volume50.html  7 pages



Abstraction in Graph-Transformation Based Diagram Editors



Oliver Koth and Mark Minas 1

Lehrstuhl fur Programmiersprachen, Universitat Erlangen-Nurnberg, Martensstr. 3, 91058 Erlangen, Germany


Abstract
This extended abstract recalls how visual language editors bene t from graph gram- mars and how the editor-generator DiaGen is based on this approach. We then outline how generated editors can create abstract diagram representations for fur- ther processing, e. g. for communication with other tools or for diagram visualiza- tions with varying, adjustable detail level which is a valuable aid when editing large diagrams. These concepts are illustrated with UML class diagrams.




1	Introduction

An important application of graph grammars and graph parsing techniques is the de nition of visual languages (VLs) and the creation of VL editors [2]. The use of a parser for the analysis of diagrams allows to treat the graphical interface as a kind of extended drawing program; thus the same front-end can be used across a broad spectrum of di erent VLs with very little adaption; only the set of allowed VL symbols (boxes, arrows, etc.) must be speci ed. The diagrams are then created by drawing these symbols using \direct ma- nipulation"; the resulting drawings are analyzed by a VL parser to check the correctness of the diagram and create an abstract representation for further processing.
In this paper we explain how these concepts are realized in the DiaGen system [6,7] and show how the grammar and the parsing process can be ex- ploited to generate such an abstract (graph) model in a very direct and simple manner. Subsequently, we present a way of using the same abstraction con- cepts to enhance the usability of VL editors. This can be done by generating
\abstraction views" of a diagram, which allow the user to concentrate on the
diagram parts that are important for the current editing task.

1 Email: Mark.Minas@informatik.uni-erlangen.de
 c 2001 Published by Elsevier Science B. V. Open access under CC BY-NC-ND license.


The main advantage of including a parser in a VL editor is that it avoids the necessity for specifying a complete set of structure-based editing operations so that the language-speci c part of the editor is kept as small as possible. This makes it possible to use an \editor generator" in combination with a class library to create editors for complex VLs from relatively short and concise syntax descriptions. DiaGen is such an editor-generator framework, which combines the parsing approach for VL editors with the transformation-oriented approach, because it also allows complex structure-based transformations on the edited diagrams (described as graph transformations on the internal graph model of the diagram [7]).


2	Modeling Diagram Syntax

For the rest of this paper, we will use a DiaGen editor for UML class diagrams as an example. Fig. 1a shows a small model created with this editor. Examples for the di erent graph structures that we will discuss can be found in Fig. 1c through f (The graphs cover only a part of the sample diagram.) Except for the ASG in Fig. 1e, all structures have been simpli ed somewhat to show the underlying concepts more clearly.
DiaGen represents diagrams internally as a labeled hypergraph consisting of \component" and \relation" (hyper) edges. A component edge corresponds to a visual symbol in the actual diagram. Every symbol has a number of \con- nector regions" where it can interact with other components. Those connector regions are mapped into hypergraph nodes which the respective component hyperedge attachs to. Finally, the syntax description can de ne arbitrary ge- ometric relations between the connector regions (most often containment and intersection) which are mapped into binary relation edges that connect the corresponding nodes.
The resulting hypergraph model (HGM, cf. Fig. 1c) of the diagram is subjected to a two-step analysis process: rst it is converted into a \reduced hypergraph model" (rHGM, cf. Fig. 1d) by a kind of graph transformation [7]. The hyperedges of the rHGM then serve as the terminal set for the parsing process. DiaGen uses context-free hypergraph grammars with some exten- sions (described in [2,7]) for the description of the VL syntax. A fault-tolerant parser analyzes the rHGM and creates a derivation structure, which mostly consists of (context-free) derivation trees, but it also contains \embedding" edges. These express the fact that elements that are not part of a single major entity (nonterminal) but are embedded into a context of several non- terminals. The derivation structure thus forms a directed acyclic graph (the derivation DAG or DDAG, cf. Fig. 1f), but the \nodes" of this graph (ter- minals and nonterminals) are themselves hyperedges which connect to nodes (from the rHGM, not shown in the gure). All the mentioned edge types can be attributed, and attribute propagation rules allow to build an abstract rep- resentation of the diagram from the properties of the symbols (e. g. textual




Fig. 1. A sample UML class diagram (a), its focus and context view (b), and the di erent models (c{f) of (a). Nodes are drawn as circles. Hyperedges are either shown as rectangles which are connected to nodes, or as arrows. Numbers indicate the order of visited nodes.


content) and the diagram structure [7].


3	Generating Abstract Models of Diagrams

The graph grammar that describes the syntax of a VL and the DDAG that is generated from a diagram can not only be used as a means of determin- ing its correctness; in addition, they also capture larger conceptual entities in the diagram and describe the way they are related, and thus have a con- crete \meaning". In the UML for instance, there exist entities like \classes",
\packages" and \associations" that consist of several subparts; a parallel hi-
erarchy exists in the grammar that describes the visual syntax of UML class diagrams. This o ers an easy way to gain an abstract model of the diagram: We simply take all the nonterminals from the DDAG that bear one of a set of
\meaningful" types (e. g. \package") along with all connected nodes (remem-
ber that the nonterminals are themselves hyperedges connected to nodes) and treat this subgraph as a high-level model of the diagram (an "abstract syntax graph" or ASG, cf. Fig. 1e)
In the simple case of the example, the ASG is almost identical to the rHGM. In general, the rHGM may also contain additional edges that cannot be parsed correctly or groups of edges that are combined into a single ASG entity. Also, for some UML elements there exist multiple alternative visualizations that lead to di erent rHGM structures, but all of them are derived from the same nonterminal type.
In the case of UML class diagrams, we would additionally like the ASG of the diagram to conform to the o√Ücial de nition of the \abstract model" behind UML diagrams. The UML standard describes this abstract model as an object model based on the \UML metamodel" [8]. As an example, every package in an UML diagram must be represented by a \package" object with attributes like \name" and \visibility" in its abstract model. Our approach does not create an object model for a diagram, but instead a hypergraph struc- ture (the ASG). But it is possible to de ne a mapping from object structures to hypergraphs that allows a very close correspondence: For instance, objects with their attributes correspond to hyperedges with attributes, and associa- tions between objects are mapped to nodes which the respective hyperedges attach to. The correspondence is close enough that we can write out a tree traversal of the ASG of a UML class diagram into the standardized XMI le format [8], and use the abstract description in other industry UML tools (e. g. Together, www.togethersoft.com).
This way of integrating abstract graph models into the syntax description (graph grammar) of a VL o ers the possibility to create them from a con- crete diagram and check them for correctness with standard graph parsing techniques. It should also be possible to use the graph grammar productions to create a concrete diagram from an abstract model, although we have not yet dealt with this \unparsing" problem.  This would allow to generate vi-


sual representations from abstract diagram models (e. g. XMI data) or to use graph transformations to describe modi cations of the abstract model (pro- gram structure transformations in the case of UML) and visualize the results directly.

4	Visualizing Abstraction

Abstraction concepts are not only useful in internal models of diagrams; they also o er a valuable aid for diagram editing when they are visualized: En- tities in the diagram that are not currently of interest to the user can be replaced with (smaller) abstraction visualizations, while other parts remain visible in full detail. The resulting technique is known as \focus and context" viewing [11]; it leads to a better utilization of screen space and enhances us- ability [10]. Fig. 1b shows a focus and context view of the example diagram that concentrates on the \Customer" class.
Previous approaches to applying this concept were either restricted to spe- ci c applications or operated on the basis of optical display transformations only (e. g. sheye views [5]). The use of hypergraphs as a common model for diagram languages allows us to support structure-based abstraction that is individually tailored to the speci c diagram language while keeping the re- quired programming e ort small. We achieve this by treating abstraction as just a special case of diagram transformation: For UML class diagrams, we have de ned two abstraction transformations that simplify classes and pack- ages; their e ect can be seen in the \Account" and \Personal" elements in the diagram (cf. Fig. 1b).
As described in [7] and mentioned in section 1, diagram transformations are speci ed in the form of graph transformation rules that nd and replace patterns in the HGM of the diagram; higher-level transformation programs provide a control structure and allow iterated or conditional execution of sub- programs or basic rules. Adding or removing component hyperedges creates or deletes visual symbols; adding or removing relation edges can cause adaption of the diagram layout.
These mechanisms must only be slightly extended for the de nition of ab- straction transformations: such a transformation receives a (user selected) diagram element as an argument; it uses one or more patterns to select all the graph parts that represent details of the desired diagram entity and (temporar- ily) removes them from the diagram. Of course it is necessary to add inverse
\expansion" transformations that re-insert these details if they need to be
considered again later. Therefore the graph elements are not actually deleted; instead they remain in the HGM structure but are marked as \hidden", so they are neither visualized nor considered by the analysis process.
To render the speci cation of abstraction transformation as easy as pos- sible, we want to make use of the information contained in the derivation structures for selecting the details of a diagram entity. To this end, we have


introduced cross-model links that connect corresponding edges in the di erent internal graph structures (HGM, rHGM and DDAG) and can be included in graph patterns or transformation rules. Although complex graph patterns of- fer many possibilities for selecting the desired elements of the diagram (resp. the HGM), we have found that, in most cases, abstraction transformations need to use only a simple standard pattern: The selection starts from a dia- gram element selected by the user (e. g. a package frame, cf. Fig. 1a and c), it follows the cross-model links to the DDAG, and walks \up" the DDAG to the rst nonterminal symbol of a certain type (e. g. \Package") representing the desired higher-level entity; nally it follows \down" the DDAG edges and against the cross-model links to include everything derived from that nonter- minal. Fig. 1a{f give an idea how this selection leads through the elements with a gray background to nd all parts of the \Personal" package.
Since we use freely programmable diagram transformations to create ab- straction views, it is also possible to include other adaptions of the diagram that are necessary to preserve its correctness, e. g. to use language-speci c abstraction symbols. Finally, the individual abstraction transformations for single diagram entities like UML classes or packages can be combined into higher-level transformations that create suitable abstraction views of the whole diagram as seen in Fig. 1b.

5	Related Work

There are several other approaches for generating visual language editors from a formal speci cation. The ones which are based on an abstract graph model (e. g. GenGEd [1], Kogge [4]) automatically come with \built-in" abstract representations. Other tools which avoid abstract internal models (e. g. Pen- guins based on Constraint Multiset Grammars [3]) lack this immediate avail- ability of abstract models; they rather have to explicitely create external dia- gram representations by attribute evaluation.
However, as far as we know, there is no other editor-generator framework which supports visualization abstractions with varying, adjustable, structure- based detail level. The only tools with \focus and context" viewing are either special purpose tools (e. g. [9]), or they o er distorted \ sheye views" only (e. g. [5]).


References

[1] R. Bardohl. GenGEd: A generic graphical editor for visual languages based on algebraic graph grammars. In Proc. 1998 Symp. on Visual Languages (VL'98), pages 48{55, 1998.
[2] R. Bardohl, M. Minas, A. Schurr, and G. Taentzer. Application of graph transformation to visual languages.  In H. Ehrig, G. Engels, H.-J. Kreowski,


and G. Rozenberg, editors, Handbook of Graph Grammars and Computing by Graph Transformation. Vol. II: Applications, Languages and Tools, pages 105{
180. World Scienti c, Singapore, 1999.
[3] S. S. Chok and K. Marriott. Automatic construction of user interfaces pen- based computers. In Proc. 3rd Int. Workshop on Advanced Visual Interfaces, Gubbio, Italy, 1996.
[4] J. Ebert, R. Suttenbach, and I. Uhe. Meta-CASE in practice: a case for KOGGE. In Advanced Information Systems Engineering, Proc. 9th Int. Conf. (CAiSE'97), LNCS 1250, pages 203{216. Springer, 1997.
[5] T. A. Keahey and E. L. Robertson. Techniques for non-linear magni cation transformations. In Proc. IEEE Symp. on Information Visualization, IEEE Visualization, pages 38{45, 1996.
[6] M. Minas.  Creating semantic representations of diagrams.  In M. Nagl and
Schurr, editors, Int. Workshop on Applications of Graph Transformations with Industrial Relevance (Agtive'99), Selected Papers, LNCS 1779, pages 209{
224. Springer, Mar. 2000.
[7] M. Minas.  Concepts and realization of a diagram editor generator based on hypergraph transformation. Appears in Journal of Science of Computer Programming (SCP), 2001.
[8] Object  Management  Group.	Meta Object Facility Speci cation. http://www.omg.org/uml/.
[9] S. Pook, E. Lecolinet, G. Vaysseix, and E. Barillot. Context and interaction in zoomable user interfaces. In Proc. Advanced Visual Interfaces 2000 (AVI'2000), pages 227{231,	2000.
[10] D. Scha er et al. Navigating hierarchically clustered networks through sheye and full-zoom methods. ACM Transactions on CHI, 3(2):162{188,	1996.
[11] M. Sheelagh, T. Carpendale, D. Coperthwaite, and F. Fracchia. Making distortions comprehensible. In Proc. 1997 Symp. on Visual Languages (VL'97), pages 36{45, 1997.
