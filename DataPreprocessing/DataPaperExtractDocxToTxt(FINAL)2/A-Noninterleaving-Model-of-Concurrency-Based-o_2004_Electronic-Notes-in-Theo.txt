Electronic Notes in Theoretical Computer Science 106 (2004) 261–277 
www.elsevier.com/locate/entcs


A Noninterleaving Model of Concurrency Based on Transition Systems with Spatial Structure
Lu´ıs Monteiro1
Departamento de Informa´tica Faculdade de Ciˆencias e Tecnologia Universidade Nova de Lisboa

Abstract
In an attempt to devise a general notion of model for spatial logic, we have been led to consider transition systems with an additional so-called spatial structure on the states, with both the tran- sition and the spatial structures described in coalgebraic terms. In this paper we argue that such transition systems with spatial structure can be seen as a noninterleaving model of concurrency, by providing translations to and from a certain category of Petri nets.
Keywords: Spatial logic, coalgebra, transition system, Petri nets.


Introduction
There has been recently a growing interest in logics that support in a inte- grated way both behavioural and so-called spatial properties of concurrent systems [1] [3] [4] [6] [14] [15]. The most basic examples of a spatial operator are probably 0 (void, nullary) and | (composition, binary): 0 is satisfied by any inactive process and φ|ψ is satisfied by any process which is a parallel com- position of a process satisfying φ with a process satisfying ψ. Other spatial operators allow to state properties of systems that deal with private resources like nonces and channels, but they will not concern us here.

1 This work was supported by project PROFUNDIS (IST-2001-33100).


1571-0661 © 2004 Published by Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2004.02.035


The models for spatial logic that have been considered so far have been mostly for concrete domains like the ambient calculus [6], the asynchronous
[3] or synchronous [2] π-calculus, semistructured data [5] and mutable data structures [15], among others. One would like to have an abstract notion of model to study the properties of the logic in all generality.
Take the example of Hennessy-Milner logic [11], whose models are tran- sition systems. What could be the models of Hennessy-Milner logic enriched with the spatial operators void and composition? To be precise, consider the logic described by the following syntax:

φ, ψ	::=	T	|	чφ	|	φ Λ ψ	|	♦φ	|	0	|	φ|ψ
Thus, we have the propositional constants T for true, ч for negation and Λ for conjunction; the modality ♦ is associated with an internal transition (for simplicity we disregard labelled transitions); the remaining two formulas are the spatial formulas encountered before.
The first four types of formulas are interpreted in a transition system
⟨S, tr : S → Уfin(S)⟩
in the standard way (we used here the coalgebraic formulation of transition systems using the finite powerset functor Уfin; for material on coalgebras see [9,16,8]). To interpret the spatial formulas we need an additional structure on the set S of states. Several authors have advocated the use of a mixed algebraic-coalgebraic approach to deal with such cases (e.g. [10,7]), leading in the present situation to endow S with a monoid structure. Here we propose to describe the spatial structure in coalgebraic terms, since interpreting the logic requires observing the structure of states rather than building new states from given ones. Thus, to the previous transition structure we add a spatial function
sp : S → {1} + Уfin(S × S)
with the following interpretation: if (s1, s2) ∈ sp(s), then s is a parallel com- position of s1 and s2; if sp(s) = ∅, then s is inactive; finally, if sp(s) = 1, then s is a “local” state, which is neither active nor a parallel composition. Of course, it is expected that the spatial function obey some properties, for example to capture the idea that parallel composition is commutative, or to relate the transition and the spatial structures. But that is not required to interpret the spatial formulas:
s |=0 iff sp(s)= ∅.
s |= φ|ψ iff there is (s', s'') ∈ sp(s) such that s' |= φ and s'' |= ψ.


It has sometimes been argued that the logical equivalence of states in- duced by spatial logic is perhaps too intensional, being finer than (behavioural) bisimilarity. A pleasing consequence of our model, however, is that the cor- responding notion of bisimulation takes into account both the transition and the spatial structures, and it can be shown that bisimilarity is equivalent to logical equivalence [13], thus extending Hennessy-Milner’s result [11] to the present framework.
A spatial transition system ⟨S, ⟨tr, sp⟩⟩ is a coalgebra for the functor Уfin(−)
×({1} + Уfin(−× −)). Since a final coalgebra for this functor exists, an idea that immediately suggests itself is to define semantics for concurrent languages in that coalgebra. This is relatively straightforward: it is only necessary to complement the usual operational semantics based on transition systems with the definition of an appropriate spatial operator; the unique morphism to the final coalgebra takes care of the rest. We illustrate the process with the semantics of CCS in the version presented in [12].
We recall briefly the main aspects of the syntax and operational semantics of CCS without pretending to be complete. Let Id be a set of process identiﬁers and Act d=ef N ∪ N ∪ {τ } a set of actions, where N is a set of names; process identifiers will be denoted by A, actions by α, β and names by a, b. The set Proc of processes is described by the following syntax:

P	::=	A⟨a1,... , an⟩	|	Σ αi.Pi	|	P1|P2	|	new aP
i∈I
where I is a finite index set; if I = ∅, the summation is written 0. It is assumed that every process identifier A has a deﬁning equation A(→a) d=ef PA, where PA is a summation and →a = a1,..., an is a list of distinct names that comprise all the free names fn(PA) of PA. We do not distinguish between processes that differ only in the bound names.
Structural congruence is the least congruence on the set of processes such that the following conditions hold:
Σi∈I αi.Pi = Σi∈I ασ(i).Pσ(i) where σ : I → I is a bijection.
P |0 ≡ P , P |Q ≡ Q|P , P |(Q|R) ≡ (P |Q)|R.
new a(P |Q) ≡ P |new aQ if a /∈ fn(P ),
new a0 ≡ 0, new abP ≡ new baP .
A⟨→b⟩ ≡ {→b/→a}PA if A⟨→a⟩ d=ef PA, where {→b/→a} is the substitution of →b for the free occurrences of →a.
We write P Ç if P is “local”, that is, if P /≡ 0 and if P ≡ P1|P2 implies P1 ≡ 0


or P2 ≡ 0. For convenience we also define the spatial congruence ≡sp by the same conditions above with the exception of P |0 ≡ P and new a0 ≡ 0. The reason for the omission is that the equivalence classes of ≡sp are finite sets, which guarantees that tr(P ) and sp(P ) are finite sets without having to take the quotient of Proc by ≡.
The transition function tr : Proc → Уfin(Proc) is characterized by reaction rules that define the transition relation →⊆ Proc × Proc. In the reaction rules that follow, P, P ', Q, Q' are arbitrary processes, M, N are summations and a is a name:
τ.P + M → P .
(a.P + M)|(a.Q + N) → P |Q.
P → P ' implies P |Q → P '|Q.
P → P ' implies new aP → new aP '.
P ≡sp Q → Q' ≡sp P ' imply P → P '.
We now come to the main point of the exercise, which is to define a spatial function for CCS that complements the standard transition function. The spatial function sp : Proc → {1} + Уfin(Proc × Proc) is defined by:
⎧⎨ 1	if P Ç,

sp(P )= 
⎩ {(P1, P2): P ≡sp P1|P2}	otherwise.


An unexpected benefit of this approach is that spatial transition systems are a noninterleaving model of concurrency—in particular, the previous con- struction gives a noninterleaving model of CCS. The remainder of the paper is devoted to support this statement. It will be shown how to translate spa- tial transition systems to Petri nets and Petri nets back to spatial transition systems. Furthermore, these translations are shown to be an adjunction for appropriate notions of morphism in the two categories. The morphisms we use, especially for Petri nets, do not coincide with the usual ones, and owe much to the coalgebraic approach followed throughout the paper.

Transition systems with spatial structure
For convenience, the notion of spatial transition system that will be used in the comparison with Petri nets differs slightly from the one presented in the introduction in that instead of spatial functions with the format sp : S →
{1} +Уfin(S × S) we shall consider spatial functions sp : S → M(S) that map elements of S to (finite) multisets of elements of S. Thus, before embarking on


our programme we recall basic notions of multisets; in an appendix we show how under certain conditions our previous notion of spatial transition system (which is more “primitive”) gives rise to the new one (which is mathematically more convenient for the present purpose).
A (finite) multiset M over a set S is a function M from S to the set of natural numbers such that M(x) = 0 for all but a finite set of elements x ∈ S. If M(x) > 0 we sometimes write x ∈ M, otherwise x /∈ M. If x1,... , xn are the elements in M, possibly repeated, we write M = [x1,... , xn]. If f is a function defined on a finite set or multiset M, the image of f counting repetitions is a multiset, denoted [f (x): x ∈ M]. The empty multiset, [], maps every x to 0. If M and N are multisets, their union M ⊕ N maps every x to M(x)+ N(x). If N(x) ≤ M(x) for every x, in which case we write N ⊆ M, then M − N maps every x to M(x) − N(x). We have (M ⊕ N) − N = M, hence M ⊕ N = P ⊕ N implies M = P . Thus, if N ⊆ M, there is a unique P such that N ⊕ P = M.
The set of all (finite) multisets over S will be written M(S). Moreover, (M(S), [], ⊕) is the free commutative monoid generated by the singletons [s] for s ∈ S. If f : S → T is a function and M ∈ M(S), we define the function M(f ) : M(S) → M(T ) by M(f )(M) = [f (x) : x ∈ M]; this is nothing but the unique monoid morphism that maps each generator [s] to [f (s)].
A spatial transition system, or just STsystem, is a triple
S = ⟨S, ⟨tr, sp⟩⟩, where S is a set of states and tr, sp are functions
tr : S → Уfin(S),
sp : S → M(S)
that describe the transition and the spatial structures of S. These functions are required to satisfy axioms ST1 through ST3 below, but first we introduce some definitions and notations.
We abbreviate sp(s) to |s| for readability and call it the extent of s. A local state is a state whose extent reduces to itself, that is, an s for which |s| = [s]. The set of local states is written Loc(S). If s, t are states and t ∈ tr(s), we write s → t and call → the transition relation of S and s → t a transition. The set of all transitions is written Tr.
For convenience, we define a transition relation on M(Loc(S)), also de- noted by →, as follows: P → Q if, and only if, there exist a transition s → t and M ∈ M(Loc(S)) such that P = |s|⊕ M and Q = |t|⊕ M. Note that


s → t implies |s|→ |t|; the converse is not true, but a weaker form is implied by axiom (ST3) below.
We can now state the axioms of STsystems:
(ST1) |s|∈ M(Loc(S)).
(ST2) P ⊆ |s| implies P = |t| for some t.
(ST3) |s|→ P implies s → t for some t such that |t| = P . These axioms have the following intuitive reading:
The extent of any state consists of local states only.
Any choice of elements in the extent of a state is itself the extent of another state (a “substate” of the former).
Any transition of a substate determines a transition of the superstate.
Remark 2.1 Additional axioms may be needed for different purposes. For example, in some cases it may make sense to require that |s| = [] only if s /→, which means that states with empty extent have no transitions. Also, if we have labelled transition systems, where transitions have names and conames
as labels as in CCS, we require that if |s| = M ⊕ P , M →a  N and P →a  Q,
then there exists t such that s →τ t and |t| = N ⊕ Q.
Proposition 2.2 If s → t and |s| = |s'|, there exists t' such that s' → t' and
|t| = |t'|.
Proof. If s → t, then |s|→ |t|, hence |s'|→ |t|. By axiom (ST3), s' → t' for some t' such that |t| = |t'|.	 
Thus, the relation sp(−) = sp(−) on S of having the same extent is a behavioural bisimulation.
To turn the class of STsystems into a category we must define the corre- sponding morphisms. Since STsystems are coalgebras, a morphism f : S → S' from S = ⟨S, ⟨tr, sp⟩⟩ to S' = ⟨S', ⟨tr', sp'⟩⟩ is a function f : S → S' such that
sp' ◦ f = M(f ) ◦ sp,
tr' ◦ f = У(f ) ◦ tr.
Thus, we must have, for every s ∈ S,
|f (s)| = [f (t): t ∈ |s| ],
tr'(f (s)) = {f (t): t ∈ tr(s)},

where we used the same notation |−| for both sp(−) and sp'(−). The second

condition unfolds unto two subconditions:
s → t	⇒	f (s) → f (t),
f (s) → t'	⇒	∃t s → t & f (t)= t'.

Note that morphisms preserve locality and emptyness of states (that is, |s| = [s] and |s| = []). In the sequel we need a more specialized notion of morphism.
We define the subsumption relation ≤ on the set Tr of transitions by p → q ≤ s → t if, and only if, |s| = |p|⊕ M and |t| = |q|⊕ M for some M ∈ M(Loc(S)) (intuitively, p → q “causes” s → t). We say s → t is a local transition if p → q ≤ s → t implies s → t ≤ p → q for every transition p → q, that is, |p| = |s| and |q| = |t| (so a local transition is not properly subsumed by any other transition). The set of all local transitions will be written Loc(Tr).
Proposition 2.3 Let f : S → S' be a morphism. If s → t is a transition in
S such that f (s) → f (t) is local in S', then s → t is local in S.
Proof. Suppose p → q is a transition in S and M ∈ M(Loc(S)) are such that |s| = |p|⊕ M and |t| = |q|⊕ M. Then |f (s)| = M(f )(|s|)= M(f )(|p|) ⊕ M(f )(M)= |f (p)|⊕ M(f )(M) and |f (t)| = |f (q)|⊕ M(f )(M). As f (s) → f (t) is local, we must have M(f )(M) = [], hence M = []. This shows s → t is local.	 
The converse of the previous result is not necessarily true. A morphism
f : S → S' is strict if the following condition holds:
s → t local in S implies f (s) → f (t) local in S'.
Given M ∈ M(Loc(S)), we are interested in those states whose extent is contained in M, to be called the states of M and required to be preserved by morphisms. More precisely, the set St(M) of states of M is the set of all states s such that |s|⊆ M. This defines a function St : M(Loc(S)) → У(S). A morphism f : S → S' is conservative if the images of the states of any M are the states in the image of M:
У(f ) ◦ St = St' ◦ M(f ).
Let M ∈ M(Loc(S)) and put M ' = M(f )(M). If |s| ⊆ M, then M =
|s|⊕ P for some P , so M ' = M(f )(|s|) ⊕M(f )(P )= |f (s)|⊕M(f )(P ), hence
|f (s)|⊆ M '. This shows the states of M are mapped on states of M '. Thus, the important part of the conservativity condition is that every s' ∈ St'(M ') has the form f (s) for some s ∈ St(M), that is, every state of M ' is the image of some state of M.
A morphism f preserves the transitions on M(Loc(S)), in the sense that


P → Q implies M(f )(P ) → M(f )(Q). If the morphism is conservative we also have that M(f )(P ) → Q' implies that there exists Q such that P → Q and M(f )(Q)= Q'. This is the contents of the next proposition, which for uni- formity is stated in terms of the function TR : M(Loc(S)) → У(M(Loc(S))) where TR(P )= {Q : P → Q}.
Proposition 2.4 For any conservative morphism f,
TR' ◦ M(f )= У(M(f )) ◦ TR.
Proof. If P → Q, there exist a transition s → t and M such that P =
|s|⊕ M and Q = |t|⊕ M. We have M(f )(P ) = M(f )(|s|) ⊕ M(f )(M) = 
|f (s)|⊕ M(f )(M) and similarly M(f )(Q)= |f (t)|⊕ M(f )(M). But f (s) → f (t), since f preserves transitions, hence M(f )(P ) → M(f )(Q). Conversely, suppose M(f )(P ) → Q'. By definition, there exist s' → t' and M ' such that M(f )(P ) = |s'|⊕ M ' and Q' = |t'|⊕ M '. In particular, s' is a state of M(f )(P ), so there is a state s of P such that f (s) = s'. We can write P = |s|⊕ M for some M and clearly M(f )(M)= M '. Since f (s) → t', there is t such that s → t and f (t)= t'. Putting Q = |t|⊕M we have M(f )(Q)= Q' as required.	 
The relationship between STsystems and nets will be established in terms of strict and conservative morphisms. Accordingly, in the sequel by morphism we shall always understand a strict and conservative morphism. The category of STsystems with stricti and conservative morphisms will be denoted STsys.
Petri nets
A (Petri) net 2 is a list
N = ⟨B, E, pre, post⟩
where B and E are sets and pre, post are functions from E to M(B) satisfying axiom N below. The elements of B are called conditions, those of E events and the functions pre, post assign pre- and postconditions to events. As usual, pre(e) is abbreviated to •e and post(e) to e•.
A state of N is a finite multiset over B. State M enables event e if •e ⊆ M.
In that case we write M →e N with N = (M − •e) ⊕ e• and call M →e N a step
of N . Equivalently, there is a step M →e N if, and only if, M = •e ⊕ P and
N = e• ⊕ P for some state P . The set of all events enabled by M is written En(M). This defines a function En : M(B) → У(E).

2 This definition was inspired by the one in [17] but does not quite agree with it in minor details; the notion of morphism we use, however, is quite different from the one in that paper.


In this paper we shall assume nets satisfy the following condition:
(N) •e' = •e ⊕ M and e'• = e• ⊕ M imply M = [] and e = e'.
If we say that e subsumes e' if •e' = •e ⊕ M and e'• = e• ⊕ M for some M, this defines a partial order and the axiom states that the subsumption order is the identity. The next picture illustrates the kind of situation discarded by the axiom.





If N = ⟨B, E, pre, post⟩ and N ' = ⟨B', E', pre', post'⟩ are nets, a morphism
f : N → N ' is a pair of functions fB : B → B' and fE : E → E' such that
pre' ◦ fE = M(fB) ◦ pre,
post' ◦ fE = M(fB) ◦ post,
En' ◦ M(fB)= У(fE) ◦ En.
This notion of net morphism is not standard, but is the more suitable one for our purposes. (Note that fE is uniquely determined by fB, by axiom (N).) The category of nets and their morphisms will be denoted by Net.
Remark 3.1 The first condition of the definition of net morphism already implies half of the third one, namely, En' ◦ M(fB) ⊇ У(fE) ◦ En. First note that this condition reads: If e ∈ E is enabled by M ∈ M(B), then fE(e) is enabled by M(fB)(M). Now, if e is enabled by M, then •e ⊆ M, hence
fE(e)= M(fB)(•e) ⊆ M(fB)(M), so fE(e) is enabled by M(fB)(M). Thus, in practice we only need to check that En' ◦ M(fB) ⊆ У(fE) ◦ En.

From nets to STsystems
Given a net N = ⟨B, E, pre, post⟩ we define an STsystem
ns(N )= ⟨M(B), ⟨sp, tr⟩⟩


where
sp(M)= [[b]: b ∈ M],
tr(M)= {N : ∃ M →e


N}.

Lemma 4.1 ns(N ) is an STsystem.


Proof. Axiom ST1 results from the observation that M ∈ M(B) is local if, and only if, M is a singleton. For ST2, if P ⊆ |M| for some state M, then P = |N| for N =  P , the union of the singletons in P . As to ST3, suppose |M|→ P for some M and P . To find N such that M → N just take N =  P .	 
Lemma 4.2 The local transitions of ns(N ) are those of the form •e → e• for
e ∈ E.
Proof. If M → N ≤ •e → e•, there is P such that •e = M ⊕ P and e• = N ⊕ P . But M → N, so there are e' and Q such that M = •e' ⊕ Q and N = e'• ⊕ Q. It follows that •e = •e' ⊕ Q ⊕ P and e• = e'• ⊕ Q ⊕ P , so Q ⊕ P = [] by axiom N. In particular, P = [], hence •e → e• is a local transition.
Conversely, assume M → N is local. There are e and P such that M =
e ⊕ P and N = e• ⊕ P . As M → N is local, P = [], so M → N is in fact
e → e•.	 
A net morphism f : N → N ' defines an STsystem morphism ns(f ): ns(N ) → ns(N '),	ns(f )= M(fB).
The following lemma checks that ns(f ) is indeed a (strict and conservative) STsystem morphism.
Lemma 4.3 For all M, N ∈ M(B) and N ' ∈ M(B'):
| ns(f )(M)| = [ns(f )([b]) : b ∈ M].
M → N implies ns(f )(M) → ns(f )(N). Moreover, ns(f )(M) → ns(f )(N)
is local if M → N is local.
ns(f )(M) → N ' implies M → N and ns(f )(N)= N ' for some N.
У(ns(f )) ◦ St = St' ◦ M(ns(f )).
Proof. For the first statement just note that both sides evaluate to [[fB(b)] : b ∈ M]. For the second one suppose that M → N, so that there is e ∈ E and a state P such that M = •e ⊕ P and N = e• ⊕ P . Let e' = fE(e). As M(fB) is a monoid morphism and f preserves pre- and postconditions, we have ns(f )(M)= •e' ⊕ ns(f )(P ) and ns(f )(N)= e'• ⊕ ns(f )(P ), which gives the desired transition. If M → N is local, then P = [], hence ns(f )(P ) = [], so locality is preserved, because •e' → e'• is local. For the third statement, assume ns(f )(M) → N ', so that ns(f )(M) = •e' ⊕ P ' and N ' = e'• ⊕ P ' for some e' and P '. In particular e' ∈ En'(ns(f )(M)) = En'(M(fB)(M)), so by definition of net morphism, e' ∈ {fE(e) : e ∈ En(M)}. This shows that


e' = fE(e) for some e ∈ En(M). There is then a state P such that M = •e⊕P . As ns(f ) is a monoid morphism that takes •e to •e', we have •e' ⊕ ns(f )(P )= 
e' ⊕ P ', hence P ' = ns(f )(P ). Thus, if we make N = e• ⊕ P , we have

M → N and ns(f )(N) = N ', as required. Finally, let Mˆ
∈ M(Loc(M(B)))

and Mˆ ' = M(ns(f )(Mˆ )). We must show that every P ' ∈ St'(Mˆ ') has the
form ns(f )(P ) for some P ∈ St(Mˆ ). If we put M =  Mˆ and M ' =  Mˆ ',
then M ' = ns(f )(M). Now |P '| ⊆ Mˆ ' if, and only if, P ' ⊆ M ', so there is
Q' such that M ' = P ' ⊕ Q'. As M ' = ns(f )(M), there exist P, Q such that

M = P ⊕ Q, P ' = ns(f )(P ) and Q' = ns(f )(Q). Thus, Mˆ
= |P |⊕ |Q|, so that

P ∈ St(Mˆ ), and P ' = ns(f )(P ), as required.	 

From STsystems to nets
We associate the net
sn(S)= ⟨Loc(S), Loc(T r), pre, post⟩ with STsystem S = ⟨S, ⟨sp, tr⟩⟩, where
pre(s → t)= |s|,
post(s → t)= |t|.
Lemma 5.1 sn(S) is a net.
Proof. We must check axiom N. Let M ∈ M(Loc(S)) and e, e' ∈ Loc(T r) such that •e' = •e ⊕ M and e'• = e• ⊕ M, so that we have to show that M = []. Say e = p → q and e' = s → t. The conditions translate to |s| = |p|⊕ M and
|t| = |q|⊕ M, that is p → q ≤ s → t. The conclusion M = [] follows from the fact that the transition s → t is local.	 
Lemma 5.2 For M ∈ M(Loc(S)) and s → t ∈ Loc(T r), we have s → t ∈ En(M) if, and only if, s ∈ St(M). Thus, En(M) = {s → t ∈ Loc(T r) : s ∈ St(M)}.
Proof. This is because s → t ∈ En(M) if, and only if, •(s → t) ⊆ M, and
(s → t)= |s|.	 
For a (strict and conservative) STsystem morphism f : S → S', define sn(f ): sn(S) → sn(S') by
sn(f )B = f T Loc(S),
sn(f )E = (f × f ) T Loc(T r).
Lemma 5.3 sn(f ) is well-deﬁned and is a net morphism.


Proof. sn(f ) is well-defined because f preserves local states and local tran- sitions. We have pre'(sn(f )E(s → t)) = pre'(f (s) → f (t)) = |f (s)| and M(sn(f )B)(pre(s → t)) = M(f )(|s|) and the equality follows from the def- inition of f . Similarly, post'(sn(f )E(s → t)) = M(sn(f )B)(post(s → t)). Finally, for M ∈ M(Loc(s)), we have

У(sn(f )E)(En(M)) = У(sn(f )E)({s → t ∈ Loc(T r): s ∈ St(M)})
= {f (s) → f (t): s → t ∈ Loc(T r),s ∈ St(M)}

and

En'(M(sn(f )B)(M)) = En'(M(f )(M))
= {s' → t' ∈ Loc(T r'): s' ∈ St'(M(f )(M))}
= {f (s) → t' ∈ Loc(T r'): s ∈ St(M)}
= {f (s) → f (t): s → t ∈ Loc(T r),s ∈ St(M)} where the third equality is justified by the fact that f is conservative.	 


Relating the categories

Having defined the functors ns : Net → STsys and sn : STsys → Net, we next show that sn is left adjoint to ns. First, we establish some auxiliary results.

Lemma 6.1 Let S be an STsystem. The function η = ηS : S → M(Loc(S))
deﬁned by η(s)= |s| is a morphism from S to ns(sn(S)).

Proof. Let us denote by sp' : M(Loc(S)) → M(M(Loc(S))) and tr' : M(Loc(S)) → У(M(Loc(S))), respectively, the spatial and the transition functions of ns(sn(S)); they are given by sp'([s1,... , sn]) = [[s1],... , [sn]] and tr'(P ) = TR(P ) = {Q : P → Q in S}. Let s ∈ S and |s| = [s1,... , sn]. We

calculate:
sp'(η(s)) = sp'(|s|)
= sp'([s1,... , sn])
= [[s1],... , [sn]],
M(η)(sp(s)) = M(η)([s1,... , sn])
= [|s1|,... , |sn|]
= [[s1],... , [sn]],
tr'(η(s)) = {P : |s|→ P in S}
= {|t| : s → t in S},
У(η)(tr(s)) = У(η)({t : s → t in S}
= {|t| : s → t in S},
which shows that η is a morphism.	 
Lemma 6.2 Let S be an STsystem, N a net, f : S → ns(N ) a morphism and s ∈ S. If |s| = [s1,... , sn] and f (s)= [b1,... , bk], then n = k and, up to a permutation of b1,... , bn, f (si)= [bi] for 1 ≤ i ≤ n.
Proof. Denoting by spN the spatial map in ns(N ), the morphism condition spN ◦ f = M(f ) ◦ sp gives spN (f (s)) = [[b1],... , [bk]] and M(f )(sp(s)) = [f (s1),...,f (sn)], hence the conclusion.	 
Proposition 6.3 Let S be an STsystem and η : S → ns(sn(S)) the morphism deﬁned by η(s) = |s|. For any net N and any STsystem morphism f : S → ns(N ), there is a unique net morphism g : sn(S) →N such that ns(g) ◦ η = f.
Proof. We use the notations of the previous two lemmas. We must define
gB : Loc(S) → B and gE : Loc(Tr) → E. We put
gB(s)	= b where f (s)= [b],
gE(s → t) = the unique e such that •e = f (s) and e• = f (t).
Note that gB is well defined because f (s) is local if s is, and so has the form
[b] for some b ∈ B. On the other hand, gE is well defined because s → t local implies f (s) → f (t) local, and the local transitions of ns(N ) have the form
e → e• for a unique e ∈ E.
Before showing that g = (gB, gE) is a net morphism, let us check that ns(g) ◦ η = f . Take s ∈ S and assume that |s| = [s1,... , sn] and f (s) = 

[b1,..., bn] with f (si)= [bi] for 1 ≤ i ≤ n. We have:
ns(g)(η(s)) = M(gB)(|s|)
= [gB(s1),... , gB(sn)]
= [b1,... , bn]
= f (s).

This also implies the uniqueness of gB; since gE is uniquely determined by gB, the uniqueness of g follows.
For future reference let M = [s1,... , sn] ∈ M(Loc(S)). Then
M(f )(M)= [f (s1),...,f (sn)]
= [[gB(s1)],... , [gB(sn)]]
= spN ([gB(s1),... , gB(sn)])
= spN (M(gB)(M)).

To end the proof we must check that g is a net morphism. Let pre' and post' be the pre- and post-maps defined in sn(N ). Let s → t ∈ Loc(T r) and let e ∈ E be the unique event such that •e = f (s) and e• = f (t). We have
pre(gE(s → t)) = pre(e)
= f (s),
M(gB)(pre'(s → t)) = M(gB)(|s|)
= f (s),

and similarly, post(gE(s → t)) = f (t) = M(gB)(post'(s → t)). Finally, we must show that En(M(gB)(M)) ⊆ У(gE)(En'(M)) for any M ∈ M(Loc(S)). Suppose e ∈ E is enabled by M(gB)(M). Then •e ⊆ M(gB)(M), hence |•e|⊆ spN (M(gB)(M)) = M(f )(M). This means that •e is a state of M(f )(M), so there is a state s of M such that f (s) =• e. As •e → e•, there is a transition s → t such that f (t) = e•. But •e → e• is local, so s → t is also local and gE(s → t) = e. This shows that e ∈ У(gE)(En'(M)) = У(gE)({s → t ∈ Loc(Tr): |s|⊆ M}), as required.	 
Corollary 6.4 The functor sn : STsys → Net is left adjoint to the functor
ns : Net → STsys.

Appendix: Relating two notions of spatial system
In this appendix we show how a spatial system of the form
⟨S, sp : S → {1} + Уfin(S × S)⟩
gives rise to a spatial system of the form
⟨S, sp+ : S → M(S)⟩
provided the original system satisfies well-foundedness, determinacy, inactiv- ity, commutativity and associativity conditions, to be presented shortly.
Given sp : S → {1} +Уfin(S × S), we shall use the following abbreviations: sÇ for sp(s)= 1, s⊥ for sp(s)= ∅ and s[t, u] for (t, u) ∈ sp(s). We shall also write s[t[u, v], w] for s[t, w] and t[u, v], and similarly for s[t, u[v, w]].
Let ≺ be the relation on S such that s' ≺ s iff s[s', s''] or s[s'', s'] for some
s'' ∈ S. We shall assume ⟨S, sp⟩ satisfies the following conditions:
Well-foundedness The relation ≺ is well-founded.
Inaction There is s with s⊥.
Commutativity If s[t, u], then s[u, t].
Associativity If s[t[u, v], w], there is z such that s[u, z[v, w]], and if s[u, z[v, w]], there is t such that s[t[u, v], w].
Determinacy Whenever s[s', s''] and s[t', t''] (same s), then s[t', t''] can be deduced from s[s', s''] using commutativity and associativity.
Note that the spatial system for CCS satisfies all conditions.
If ≺∗ is the reflexive-transitive closure of ≺ and t ≺∗ s we say t is a substate of s. The set of substates of s will be written Sub(s). Since sp(t) is finite, the set {u : u ≺ t} is finite, so Sub(s) can be seen as a finitely branching acyclic graph where the set of successors of t is {u : u ≺ t}. If ≺ is well-founded, the graph is finite (otherwise it would have an infinite branch by Ko¨nig’s lemma, contradicting well-foundedness). In that case we let h(s) to be the height of the graph. Note that if h(s) = 0, then either sÇ or s⊥.
For a spatial system satisfying the above conditions, we define a function sp+ : S → M(S) by induction on the height of the elements in S:

⎧

sp+(s)= 

[]	if s⊥,
[s]	if sÇ,

⎪⎪⎩ sp+(s') ⊕ sp+(s'') if s[s', s''].


Of course we must show that the definition does not depend on the choice of the pair (s', s'') in sp(s), but that is a consequence of determinacy. By induction on the height it is easy to see that sp+(s) consists only of local states (with respect to sp+), so ⟨S, sp+⟩ satisfies axiom (ST1). It is not difficult to see that ⟨S, sp+⟩ also satisfies axiom (ST3), so is a spatial system of the second kind.
The correspondence
⟨S, sp : S → {1} + Уfin(S × S)⟩	'→	⟨S, sp+ : S → M(S)⟩
is the object function of a functor which is the identity on morphisms (that is, if f : S → T is a morphism of spatial systems of the first kind, it is also a morphism of spatial systems of the other kind). We omit the details.
We could also define in a straightforward way a functor in the reverse direction, but we omit the construction since it is not useful to assign a non- interleaving semantics for calculi as exemplified for CCS.

Acknowledgements
Thanks to Lu´ıs Caires for discussions on related topics. The referees are thanked for their comments.

References
L. Caires. A model for Declarative Programming and Speciﬁcation with Concurrency and Mobility. PhD thesis, Dept. Informatica, FCT, Universidade Nova de Lisboa, 1999.
L. Caires. Behavioral and Spatial Properties in a Logic for the Pi-Calculus. In I. Walukiwicz, editor, Proc. of Foundations of Software Science and Computation Structures (FoSSaCS’2004), Lecture Notes in Computer Science, Springer-Verlag (to appear).
L. Caires and L. Cardelli. A Spatial Logic for Concurrency (Part I). Information and Computation (2003), 186 (2), 194–235.
L. Caires and L. Cardelli. A Spatial Logic for Concurrency (Part II). In CONCUR 2002 (13th International Conference), Lecture Notes in Computer Science, Springer-Verlag, 2002.
L. Cardelli, P. Gardner and G. Ghelli. Manipulating trees with hidden labels. In A.D Gordon, editor, Proc. Foundations of Software Science and Computation Structures (FoSSaCS’2003), Lecture Notes in Computer Science, Springer-Verlag, 2003.
L. Cardelli and A.D. Gordon. Anytime, Anywhere. Modal Logics for Mobile Ambients. In Proc. 27th ACM Symposium on Principles of Programming Languages, ACM, 2000, pages 365–377.
A. Corradini, R. Heckel and U. Montanari. From SOS specifications to structured coalgebras: How to make bisimulations a congruence. In Proc. CMCS’99, ENTCS 19, Elsevier Science, 1999.
H.P. Gumm. Elements of the General Theory of Coalgebras. LUATCS’99, Johannesburg, 1999.
B. Jacobs and J.J.M.M. Rutten. A tutorial on (co)algebras and (co)induction. EATCS Bulletin
(1997), 62, 222–259.


A. Kurz. Logics for Coalgebras and Applications to Computer Science. PhD thesis, Universit¨at Mu¨nchen, 2000.
R. Milner. Communication and Concurrency. Prentice-Hall, 1989.
R. Milner. Communicating and Mobile Systems: the π-Calculus. Cambridge University Press, Cambridge UK, 1999.
L. Monteiro. A note on models for spatial logic based on transition systems with spatial structure. Tecnical report, Dept. Informatica, FCT, Universidade Nova de Lisboa, 2003.
P. O’Hearn and D. Pym. The logic of bunched implications. The Bulletin of Symbolic Logic,5 
(2) (1999), 215–243.
J.C. Reynolds. Separation logic: a logic for shared mutable data structures. In Proceedings of the 17th Annual Symposium on Logic in Computer Science, IEEE Computer Society Press, 2002.
J.J.M.M. Rutten. Universal coalgebra: a theory of systems. Theoretical Computer Science, 249, 3–80, 2000.
G. Winskel and M. Nielsen. Models for Concurrency. In S. Abramsky, D.M. Gabbay and T.S.E. Maibaum, editors, Handbook of Logic in Computer Science, volume 4, pages 1–148, Oxford Science Publications, 1995.
