Electronic Notes in Theoretical Computer Science 113 (2005) 145–162 
www.elsevier.com/locate/entcs


Monitoring Algorithms for Metric Temporal Logic Specifications
Prasanna Thati and Grigore Ro¸su
Department of Computer Science University of Illinois at Urbana Champaign, USA
{thati,grosu}@cs.uiuc.edu
September 11, 2004

Abstract
Program execution traces can be so large in practical testing and monitoring applications that it would be very expensive, if not impossible, to store them for detailed analysis. Monitoring execution traces without storing them, can be a nontrivial matter for many specification formalisms, because complex formulae may require a considerable amount of information about the past. Metric temporal logic (MTL) is an extension of propositional linear temporal logic with discrete-time- bounded temporal operators. In MTL, one can specify time limits within which certain temporal properties must hold, thus making it very suitable to express real-time monitoring requirements. In this paper, we present monitoring algorithms for checking timestamped execution traces against formulae in MTL or certain important sublogics of it. We also present lower bounds for the monitoring problem, showing that the presented algorithms are asymptotically optimal.
Keywords: Runtime verification, execution trace, specification, metric temporal logic.

Introduction
Runtime veriﬁcation and monitoring have been proposed as lightweight formal verification methods [13] with the explicit goal of checking systems against their formal requirements while they execute. In most monitoring applications, execution traces are available only incrementally and they are much larger than the formulae against which they are checked. Storing an entire execution trace and then performing the formal analysis by having random access to the trace is very expensive and sometimes even impossible. For example, the monitor may lack resources, e.g., if it runs within an embedded system, or the monitor

1571-0661 © 2004 Published by Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2004.01.029


may be expected to react promptly when its requirements are violated, in order for the system to safely take a recovery or a shutdown action.
In this paper, we adopt the position that a monitoring algorithm does not store execution traces, but rather consumes the events as they are re- ceived from the monitored program. The problem of checking execution traces against temporal specifications is known to have very simple and efficient al- gorithms for several temporal logics, as shown for example in [19], but most of these algorithms assume that the entire execution trace is available before- hand, so they violate the assumptions for a monitoring algorithm.
In this paper, we investigate monitoring algorithms for the metric tempo- ral logic (MTL) [1,15] and its sublogics. MTL is an extension of propositional linear temporal logic (LTL) that can refer to discrete-timed properties, and its models are timestamped state-sequences, thus making it an appealing for- malism for expressing monitoring requirements in real-time systems. Besides the propositional operators, MTL allows future and past time linear temporal operators which are bounded by discrete-time intervals. For example, φU[3,7]ψ states that ψ should hold between 3 and 7 time units from now, and until then φ should hold. One or both of the ends of an interval can be 0 or ∞. LTL can be seen as a special case of MTL where every interval is [0,  ). As introduced in [1], MTL also provides congruences that allow one to state that a formula should hold periodically with respect to an absolute time. We call these abso- lute congruences and support them in our MTL specifications as well, but in addition we introduce a novel variant that we call relative congruence. Rela- tive congruences allow one to refer to moments that occur periodically starting with the current time.
We first present a general MTL monitoring algorithm based on the idea of transforming the MTL formula as each time-stamped observation (or event, for short) is received from the monitored program. The underlying principle of the algorithm is “resolve the past and derive the future”. By “resolving the past” we mean that the MTL formula is transformed into an equivalent formula with the property that it has no past time operator rooted subfor- mulae which are not guarded by other temporal operators. By “deriving the future” we mean that the MTL formula is transformed into a new MTL for- mula with the property that the current formula holds before processing the newly received event if and only if the derived formula holds after process- ing the event. We show that this MTL monitoring algorithm runs in space O(m2m) and takes time O(m323m) for processing each event, where m equals φ plus the sum of all the numeric constants occurring in φ, and φ is φ with all the timing subscripts droped. The reader may note that although expo- nential, these bounds are independent of the size of execution trace which is


typically much larger than the formula being monitored We also show that the algorithm has better bounds for certain sublogics of MTL, including LTL. In fact, the bounds for past and future time LTL match the previously best known monitoring algorithms for these logics [11,12]. Finally, we derive lower bounds for monitoring MTL and its sublogics, which show that our algorithm is close to optimal.
The proofs of all the claims have been omitted in the interest of space, but they can all be found in [21].
Related Work. MTL was introduced in [1], where its complexity of expres- siveness is investigated. MTL is just one amongst a variety of extensions of linear temporal logics for specifying real-time systems (see [2] for a survey). Our idea of deriving an MTL formula with an observed event is an adapation of the classical tableaux construction for temporal logics [22,9], where formu- las in the current state represent constriants on the remainder of the input trace and are systematically propogated from the current state to the next. Drusinski [6] implements monitors for MTL formulae in his commercial Tem- poral Rover system, but the implementation and algorithmic details of this implementation are not available.
Java PathExplorer (JPaX) [10] is a NASA runtime verification system pro- viding monitoring algorithms for past and future time LTL. MTL non-trivially generalizes LTL, and the motivation for generalizing the LTL monitoring al- gorithms to MTL is clear - one would often like to monitor not only qualitative specifications such as those that can be expressed in LTL, but also quantita- tive specifications that refer to timing constriants. The algorithms we present, when used on LTL specifications, are as efficient or more efficient than the cor- responding specialized algorithms in JPaX.
Eagle [4] is a fix-point based logic formalism designed around and for JPaX, combining temporal aspects and data, thus allowing one to define temporal operators and support time. It is shown that Eagle is capable of defining and implementing several finite trace monitoring logics including the Metric Temporal Logic [4]. In a recent and independent work, upper bounds of O(m22m log m) for space complexity and O(m422mlog2m) for time complexity have been shown [3] for Eagle when specialized to future and past time LTL. These are comparable to the bounds we establish for our MTL monitoring algorithm when specialized to LTL.
The complexity of checking a path against temporal formulas has been discussed in the context of “model-checking a path” in [19], but metric tem- poral logic was not covered there. We describe a dynamic programming based procedure in the style of [19], but argue that it is not a monitoring procedure because it has to store the entire execution trace. A tableaux based-simply


exponential method to detect “bad prefixes” for a subset of LTL formulae is presented in [8]. We show that our general algorithm, when used on LTL formulae, not only has a better complexity than the algorithm in [8], but also works on any LTL formula, including both future and past operators. Us- ing alternating automata in monitoring is also an appealing approach, started with [7] for LTL, but it is not clear how easily it can be used in the context of timed sequences of events.
Metric Temporal Logic
In this section, we briefly recap MTL; the reader is referred to [1] for more details. Given a finite set P of propositions, the set of MTL formulas is inductively defined as follows.
φ := true | false | p | φ1 ∧ φ2 | φ1 ⊕ φ2 | ◦Iφ | φ1UI φ2 | ◦·Iφ | φ1SIφ2
where p ∈ P , and I is one of the following:
An interval of the non-negative real line whose left and right end-points are natural numbers or ∞. For a number n, the expression ±I ± n denotes the interval {±y ± n | y ∈ I}∩ [0, ∞).
A relative congruence expression ≈d c for integers d ≥ 2 and c ≥ 0.
y ∈ ≈d c denotes y = c mod d, and ±I ± n the set {y | y = ±c ± n mod d}.
An absolute congruence expression =d c for integers d ≥ 2 and c ≥ 0. The expression y ∈ =d c denotes y = c mod d and ±I ± n the set {y | y = c mod d}.
We use exclusive disjunction instead of negation to simplify certain tech- nicalities in the Section 3.
We assume that the integer constants that occur in a formula are encoded in binary format. We interpret MTL formulas over ﬁnite timed state sequences. A timed state sequence ρ = (π, τ ) is a pair consisting of a finite sequence π of states πi ⊆ P , and a finite sequence of real numbers τ with |π| = |τ | and τi ≤ τi+1 for each i. Define |ρ| = |π|. Intuitively, a sequence ρ represents a timed execution of a system and is understood as follows: at time τi the system was observed to be in state πi. Let π[i, j] denote πiπi+1 ... πj, and similarly for τ [i, j], and let ρ[i, j]= (π[i, j],τ [i, j]). Given a timed state sequence ρ and a position 1 ≤ i ≤ |ρ|, we define what it means for (ρ, i) to satisfy a formula φ, written (ρ, i)  φ, as follows:
(ρ, i) ▶ true	is always true
(ρ, i) ▶ false    is always false
(ρ, i) ▶ p	iff p ∈ πi
(ρ, i) ▶ φ1 ∧ φ2	iff (ρ, i) ▶ φ1 and (ρ, i) ▶ φ2


(ρ, i) ▶ φ1 ⊕ φ2	 iff exactly one of (ρ, i) ▶ φ1 and (ρ, i) ▶ φ2 holds (ρ, i) ▶ ◦Iφ	iff i < |ρ|, (ρ, i + 1) ▶ φ, and τi+1 ∈ τi + I
(ρ, i) ▶ φ1UIφ2	iff (ρ, j) ▶ φ2 for some j ≥ i with τj ∈ τi + I and
(ρ, k) ▶ φ1 for all i ≤ k < j
(ρ, i) ▶ ◦·Iφ	iff i > 1, (ρ, i − 1) ▶ φ, and τi−1 ∈ τi − I
(ρ, i) ▶ φ1SIφ2	iff (ρ, j) ▶ φ2 for some j ≤ i with τj ∈ τi − I and
(ρ, k) ▶ φ1 for all j < k ≤ i
We write ρ ▶ φ as shorthand for (ρ, 1) ▶ φ. Note that intervals and relative congruences express timing constraints relative to the “current” time, while absolute congruences refer to the absolute time. For example, at position i,
[m,n]true holds if τi+1 − τi ∈ [m, n], and ◦≈dctrue holds if τi+1 − τi = c mod d, while =dctrue holds if τi+1 = c mod d. MTL as originally defined in [1] contains only absolute congruences as primitives, but we introduce relative congruences since they naturally arise in many specifications. The following are some useful abbreviations:
¬φ = true ⊕ φ	φ1 ∨ φ2 = φ1 ⊕ φ2 ⊕ (φ1 ∧ φ2)	 Iφ = true UIφ
 Iφ = ¬ I ¬φ	 ·Iφ = true SIφ	 I φ = ¬ ·I¬φ

We write U for U[0,∞), U≤m for U[0,m], U>m for U(m,∞), Um for U[m,m], and similarly for the other temporal operators. Note that the standard LTL falls as a degenerate sublogic of MTL where only the interval [0, ∞) is allowed, which amounts to “ignoring” the timestamps in execution traces.
Recursive definitions of satisfaction typically lead to efficient dynamic pro- gramming based algorithms for checking membership of a trace in the set of traces defined by a formula [19]. An equivalent recursive definition of the semantics above can be easily devised:
(ρ, i) ▶ φ1UIφ2	iff 0 ∈ I and (ρ, i) ▶ φ2, or i < |ρ| and (ρ, i) ▶ φ1 and
(ρ, i + 1) ▶ φ1UI' φ2 where I = I − τi+1 + τi
(ρ, i) ▶ φ1SIφ2	iff 0 ∈ I and (ρ, i) ▶ φ2, or i > 1 and (ρ, i) ▶ φ1 and
(ρ, i − 1) ▶ φ1SI' φ2 where I = I − τi + τi−1
An efficient dynamic programming algorithm for testing (ρ, i) ▶ φ follows naturally: allocate a table d of size ρ  φ  c of bits, where c is the largest integer constant occuring in φ. The idea is that d(i, j, c) is 1 if and only if (ρ, i) satisfies the formula ψ that is obtained from the jth subformula of φ by substracting c from the interval at the root of the subformula (if any). By carefully traversing the table d, one can fill it in time linear on its size. See [19] for related algorithms for other temporal logics. However, such an algorithm is highly undesirable in the context of monitoring, because it not only requires


the entire trace to be stored, which is intolerable while monitoring very long executions, but it also is not online in nature.
Monitoring MTL Formulae over Finite Traces
In this section, we present our main monitoring algorithm for MTL.
Resolving the Past and Deriving the Future
We define two mutually recursive formula transformations, one for past and one for future. The transformation [ρ, i]φ resolves all the top-level past-time operators in φ according to the events until the ith one in ρ, i.e. according to the events observed so far. The resulting formula is an equivalent formula that does not contain any unguarded past-time operators, i.e. every top-level temporal operator is a future-time operator (see Lemma 3.2). The transfor- mation φ ρ, i derives the formula φ with respect to the ith event in ρ, so that the resulting formula holds after the event if and only if φ holds before the event (see Lemma 3.2).
Definition 3.1 Let ρ be a timed state sequence, and 1 ≤ i ≤ |ρ|. We define
[ρ, i]true = true	[ρ, i]false = false
[ρ, i]p = p ∈ πi	[ρ, i](φ1 ∧ φ2)= ([ρ, i]φ1) ∧ ([ρ, i]φ2)
[ρ, i](φ1 ⊕ φ2)= ([ρ, i]φ1) ⊕ ([ρ, i]φ2) [ρ, i]◦Iφ = ◦Iφ
[ρ, i](φ1UIφ2)= φ1UI φ2	[ρ, i]◦·Iφ = if i =1 or τi−1 ∈/ τi − I
⎛	then false else [ρ, i](φ{ρ, i − 1})
[ρ, i](φ S φ )= ⎝ if 0 ∈ I then [ρ, i]φ2 ⎞ ∨ ⎛ if i =1 then false	⎞

1 I 2
else false
⎠	⎝ else [ρ, i](φ1 ∧ (φ1SI' φ2){ρ, i − 1}) ⎠

where I' = I − τi + τi−1

true{ρ, i} = true	false{ρ, i} = false
p{ρ, i} = p ∈ πi	(φ1 ∧ φ2){ρ, i} = (φ1{ρ, i}) ∧ (φ2{ρ, i}) (φ1 ⊕ φ2){ρ, i} = (φ1{ρ, i}) ⊕ (φ2{ρ, i}) (◦·Iφ){ρ, i} = ([ρ, i]◦·Iφ){ρ, i}
(φ1SI φ2){ρ, i} = ([ρ, i](φ1SI φ2)){ρ, i}
(◦Iφ){ρ, i} = if i = |ρ| or τi+1 ∈/ τi + I then false else φ

⎛ if 0 ∈ I then φ2{ρ, i} ⎞	⎛ if i = |ρ| then false	⎞

(φ1UIφ2){ρ, i} = ⎝
else false
⎠ ∨ ⎝
else (φ1{ρ, i}∧ (φ1UI' φ2)) ⎠

where I' = I − τi+1 + τi

From now on we adopt the convention that the operators [ρ, i]· and ·{ρ, i} bind weaker than all the logical connectives. E.g., [ρ, i]φ1SIφ2 denotes [ρ, i](φ1SIφ2), and φ1SI φ2{ρ, i} denotes (φ1SIφ2){ρ, i}.
Let F(φ) be the set of all subformulae of φ that are either rooted at a temporal operator or are atomic propositions. Let Fˆ(φ) be the set of formulas in F(φ) which have an occurrence in φ that is not guarded by a temporal operator,
i.e. formulas in (φ) that are at the “top-level”. Let φ denote the formula obtained by dropping all the intervals in φ (i.e., implicitly replacing every interval with [0, ∞)). For instance, for φ = p1UI(p2 ∧ p3), we have F(φ) = 
{p1, p2, p3, φ}, Fˆ(φ)= {φ}, and φ = p1U(p2 ∧ p3). Let
(φ)= F(φ) ∪ {φ1UI' φ2 | φ1UI φ2 ∈ F(φ),I = I − n for some n} F (φ)= F(φ) ∪ {φ1SI' φ2 | φ1SI φ2 ∈ F(φ),I = I − n for some n}
+	−
F (φ)= F (φ) ∪ F (φ)
The following lemma states certain properties of the formula transformations in Definition 3.1, that we informally claimed earlier in this section.
Lemma 3.2 For a timed state sequence ρ and 1 ≤ i ≤ |ρ|,
F([ρ, i]φ) ⊆ F+(φ). Further, if φ is rooted at a past time temporal oper- ator then F([ρ, i]φ) ⊆ F+(φ) \ φ.
Every formula in Fˆ([ρ, i]φ) is rooted at a future time temporal operator.
(ρ, i) ▶ φ if and only if (ρ, i) ▶ [ρ, i]φ.
F(φ{ρ, i}) ⊆ F+(φ). Further, if φ is rooted at a past time temporal operator then F(φ{ρ, i}) ⊆ F+(φ) \ φ.
F(φ{ρ, |ρ|}) is empty, i.e. φ{ρ, |ρ|} is equivalent to true or false.
For i < |ρ|, (ρ, i) ▶ φ if and only if (ρ, i + 1) ▶ φ{ρ, i}, and (ρ, |ρ|) ▶ φ if and only if φ{ρ, |ρ|}.	 

Canonical Forms
While transforming the MTL formulae after every event, it is crucial to keep the size of the transformed formulae small. An important component of our monitoring algorithm is a procedure which keeps formulae in a canonical form that is guaranteed not to grow larger than exponential in size of the original


formula. Moreover, the formula representations can be updated also in simple exponential time with the size of the original formula. As explained below, the correctness of this procedure is based on a result by Hsiang [14], regarding propositional calculus as a Boolean ring by reducing propositions to canoni- cal forms consisting of exclusive disjunction of conjunctions. The encoding of propositions that follows is specialized for the particular operations required by our main monitoring algorithm. Whether BDDs [5] or other more stan- dard encodings, such as CNF or DNF, can also be viable possibilities in our monitoring framework, as well as the viceversa, namely whether our encoding can outperform the others in some situations, are definitely issues deserving further investigation. However, for the time being we prefer the Boolean ring encoding presented next because it relieves us from dealing with negations and, more importantly, it allows very simple and efficient implementations of several propositional operations, including a non-trivial substitution.
Let P = {p1, p2, ..., pm be a set of “parameters”, and let Prop⊕∧( ) be the set of -canonical propositions over symbols in  true, false . By - canonical it is meant canonical modulo the associativity and commutativity equations of ⊕ and ∧, using the other equations below as rewriting rules:
(1) (φ1 ∧ φ2) ∧ φ3 = φ1 ∧ (φ2 ∧ φ3)	(2) φ1 ∧ φ2 = φ2 ∧ φ1
(3) φ ∧ true = φ	(4) φ ∧ φ = φ
(5) (φ1 ⊕ φ2) ⊕ φ3 = φ1 ⊕ (φ2 ⊕ φ3)	(6) φ1 ⊕ φ2 = φ2 ⊕ φ1
(7) φ ⊕ false = φ	(8) φ ⊕ φ = false
(9) (φ1 ⊕ φ2) ∧ φ3 = (φ1 ∧ φ3) ⊕ (φ2 ∧ φ3)
Let E be the set of equations above. Since ⊕ and ∧ are commutative and associative, we can unambiguously write expressions such as φ1 ⊕ ... ⊕ φn and
φ1 ∧ ... ∧ φn, or ⊕n  φi and ∧n  φi, respectively. Due to the Church-Rosser
and termination of the AC-rewriting system above [14], it is not hard to see
that ⊕∧-canonical forms have unique forms ⊕i∈I ∧j∈Ji Cij, where
Cij ∈P ∪ {true, false} for all i ∈ I and j ∈ Ji;
for each i ∈ I, the elements Cij form a set, that is, Cij /= Cik for j /= k;
the sets {Cij | j ∈ Ji} also form a set;
true	Cij	j	Ji except when Ji = 1, and if this is the case then i is the only index in I with this property;
false /∈ {Cij | j ∈ Ji} except when |Ji| =1 and |I| = 1.
Notice that |I|≤ 2m and |Ji|≤ m. Because of the above, one can regard any


⊕∧-canonical form as a set of sets of elements in P. In order for this to work, we need to adopt the standard convention that ∧j∈∅ is true, and that ⊕i∈∅ is false.
We next describe how ⊕∧-canonical propositions over parameters in P =
{p1, p2, ..., pm} can be encoded on 2	bits, and also how several common op-
erations on propositions encoded this way can be performed efficiently. Since
⊕∧-canonical propositions can be seen as sets of sets of at most m elements, we start by encoding each subset P of P by a sequence of m bits b with the property that b[j] = 1 if and only if pj  P . Now each b corresponds to a number between 0 and 2m−1, which allows us to assign exactly 2m bits to any
th
⊕∧-canonical proposition φ; the idea being that the i	bit is 1 if and only if
the set corresponding to the binary m-bit representation of i corresponds to one of the conjuncts of φ. A sequence of 2m zeros encodes the formula false; if φ is of the form true ⊕ φ', then the bit corresponding to i =0 in the 2m-bit representation of φ is 1. In particular, the proposition true is encoded as 1, regarded as a 2m-bit number.
Let us next define corresponding bitwise transformations for the various operations on ⊕∧-canonical propositions. From now, due to the one-to-one correspondence, we make no distinction between a -canonical proposition and its binary representation. Therefore, in particular, we say φ[i]= 1 if and only if φ contains the conjunct formed with the corresponding propositions in the binary representation of i.
Exclusive disjunction. For ⊕∧-canonical propositions φ and ψ, the binary rep- resentation of the canonical form of φ ψ, is nothing but the bitwise xor operation applied to the binary representations of φ and ψ. Indeed, each bit in the binary representation corresponds to a set of propositions forming a corresponding conjunct, and by equations (8) and (7), the same set cannot appear twice in a normal form. This simple procedure takes time O(m2m), be- cause one also needs to increment the m-bit counter traversing the two 2m-bit sequences.
Conjunction. For -canonical propositions φ and ψ, we claim that the fol- lowing O(m22m) procedure calculates the binary representation of the - canonical form of their conjunction in ξ:
ξ =0 
for i, j =0 to 2m − 1
k = binary(i) or binary(j)
ξ[k]= ξ[k] xor (φ[i] and ψ[j])
The operators or, xor and and above are bitwise, and binary(i) is the binary representation of i. If i and j are already in binary representation then the increments of the for loop, and the calculation of k and ξ[k], take time O(m).

To keep the notation simple, we ambiguously let φ	ψ also denote the 2m-bit
ξ calculated by the procedure above.
Other boolean operators. One can define other boolean operations as well. For example, ¬φ can be calculated in constant time, by xor-ing the first bit of φ (the one corresponding to true) with 1. Similarly, φ pk, for some pk  , can be calculated like in the general conjunction φ ψ, but with the optimization that since j = 2k is the only bit in ψ that is a 1, the conjunction can be computed in time O(m2m). Finally, since standard disjunction φ ∨ ψ reduces to φ ⊕ ψ ⊕ (φ ∧ ψ), it can be computed in time O(m22m).
Substitution. A very frequent operation on propositions that we will use, is that of applying a substitution. More precisely, suppose that T : [1, m] → [0, 2m − 1] is a map assigning to parameters pj ∈ P, abstracted by their in- dex, a ⊕∧-canonical proposition in binary representation. Now given another
-canonical proposition in binary representation, say φ, the problem is to efficiently calculate the proposition obtained by the substitution given by T to the formula φ, after putting it in  -canonical form. The following code run- ning in time O(m223m) calculates the binary representation of this proposition in ξ:
ξ =0 
for i =1 to 2m  1
if φ[i] then γ =1 (as a 2m-bit number)
for j =1 to m
if binary(i)[j] then γ = γ ∧ T [j]
ξ = ξ ⊕ γ
The outer loop and conditional traverse all conjuncts of φ; then the inner loop and conditional traverse all the propositions occurring in a conjunct, and apply them the substitution incrementally, propagating the bottom-up, due to the distributivity rule (9). Finally, the newly obtained proposition γ which is in  -canonical form, needs to be merged with the already existing similar propositions obtained for different i. Let subst(φ, T ) be the ξ calculated above.
All the above allow us to state the following important result:
Theorem 3.3	-canonical propositions over parameters in	= p1, p2, ..., pm can be stored in space 2m such that the operations of exclusive disjunction, conjunction and substitution, run in time O(m2m), O(m22m) and O(m223m), respectively.			 

Monitoring MTL Formulas
The MTL monitoring algorithm can be now relatively easily defined, following the mutually recursive formula transformation relations in Definition 3.1, and



monitor(φ, ρ)
allocate R[1 ... m], D[1 ... m]
for i = 1 to |ρ| do
for j =1 to m do R[j] = resolve(formula(j), R, D, ρ, i)
for j =1 to m do D[j] = derive(formula(j), R, D, ρ, i)
φ = subst(φ, D)
if φ = false or φ = true then break
return φ
end monitor

Fig. 1. The MTL monitoring algorithm over finite timed state sequences.
taking advantage of the 2m-bit representations of propositions in  -canonical forms and the efficient implementation of basic propositional operations. Our algorithm is essentially a dynamic programming algorithm that implements the recursive relations in Definition 3.1.
Given a formula φ in ⊕∧-canonical form, which one can accomplish off-line, using a procedure like Hsiang’s [14], let m = |F±(φ)|. Note that m ≤ |φ|+Σφ, where Σφ is the sum of all the numeric constants associated to each occurrence of UI and SI in φ as follows: if I = [m, n] then n; if I = [m, ∞] then m; if I = ≈d c then d; 0 otherwise. For each ψ ∈ F±(φ) assign a unique integer 1 ≤ index(ψ) ≤ m s.t. whenever ψ1 ∈ F±(ψ2) then index(ψ1) ≤ index(ψ2). For 1 ≤ i ≤ m let formula(i) return ψ such that index(ψ)= i.
Figure 1 shows the pseudocode of the main monitoring algorithm. This procedure always keeps the formulas that it handles in 2m-bit canonical form. These canonical forms will be over parameters F±(φ) = {ψ1,... , ψm} where index(ψi)= i, and are encoded as described in Subsection 3.2. Note that the initial 2m-bit representation of φ can be calculated in time O(m2m).
The monitoring procedure maintains two arrays, R and D, each of length m, which are updated by the loop in line 3, each time the next element in the observed timed sequence ρ is available. If formula(j) = ψ then after the ith iteration R[j] will be [ρ, i]ψ and D[j] will be ψ ρ, i . Further, R[j] and D[j] are kept in canonical form. We note that it is possible to use the same parameter set ψ1,... , ψm for encoding the canonical representation of R[j] and D[j] because as a consequence of Lemma 3.2 (D[j]),  (R[j])  ±(φ). The arrays R and D are computed using two mutually recursive procedures
- resolve and derive - shown in Figure 2. These follow Definition 3.1 and hence are self explanatory. Note that the computation of R in the current iteration uses D from the previous iteration, and the computation of D is the current iteration uses R from the current iteration. Thus, in each iteration R is updated before D.



resolve(φ, R, D, ρ, i) case φ of
p	:	ψ = p ∈ πi
◦·Iφ1	:	if i =1 or τi−1 ∈/ τi − I then ψ = false
else ψ = subst(subst(φ1, D), R)
φ1SI φ2	:	if 0 ∈ I then ψ2 = subst(φ2, R) else ψ2 = false
if i =1 then ψ1 = false
else I' = I − τi + τi−1
ψ1 = subst(φ1, R) ∧ subst(D[index(φ1SI' φ2)], R) ψ = ψ1 ∨ ψ2
Iφ1, φ1UIφ2 :	ψ = φ
return ψ
end resolve

derive(φ, R, D, ρ, i) case φ of
p	:	ψ = p ∈ πi
Iφ1	:	if i = |ρ| or τi+1 ∈/ τi + I then ψ= false else ψ = φ1 φ1UI φ2	:	if 0 ∈ I then ψ1 = subst(φ2, D) else ψ1 = false
if i = |ρ| then ψ2 = false
else I' = I − τi+1 + τi
ψ2 = subst(φ1, D) ∧ φ1UI' φ2 ψ = ψ1 ∨ ψ2
Iφ1, φ1 Iφ2 :	ψ=subst(R[index(φ)], D)
return ψ
end derive

Fig. 2. Resolving the past and deriving the future.

Theorem 3.4 The procedure monitor(φ, ρ) returns true iff ρ ▶ φ. It takes space O(m2m) and time O(|ρ|m323m), where m = |F±(φ)|≤ |φ| + Σφ.	 

We end this section with a couple of observations. First, note that in the ith iteration the monitoring procedure only access ρi−1, ρi and ρi+1, and thus we need not store the entire timed sequence observed. Second, the space re- quirement of the procedure can be further optimized by having entries in R for only those ψ ∈ F±(φ) that are rooted at past time operators. This is be- cause the entries in R for atomic propositions coincide with the corresponding entries in D, and the entries for ψ rooted at future time operators contain ψ itself.

Stronger Performance Results for Sublogics of MTL
A more refined performance analysis of the monitoring algorithm for certain sublogics of MTL shows that the algorithm has much better performance over these sublogics in comparison to entire MTL. We consider two such sublogics
- MTL with only past time operators, and LTL.

MTL with Only Past Time Operators
A large class of safety properties, often called canonical safety [18] properties, can be expressed compactly and naturally as a past time formula φ which has to hold at every moment in an execution trace. In MTL, this is the same as checking for  φ (  [0,∞)φ). Such properties can be monitored very efficiently:
Theorem 4.1 Suppose φ is an MTL formula with only past time operators. Then monitor( φ, ρ) takes time O(|ρ|m) and space O(m), where m = |F±(φ)|. 
The reader can check that monitoring MTL with only future time operators has the same complexity as MTL with both future and past time operators.

Linear Temporal Logics
The monitoring algorithm for MTL can be specialized to obtain an algorithm for LTL. Recall that LTL formulas can be seen as MTL formulas with only in- tervals of form [0, ); although LTL formulas are interpreted over (untimed) state sequences. The monitoring algorithm can be specialized by simply drop- ping all references to time in the resolve and derive procedures.
As corollaries to Theorems 3.4 and 4.1 we get that LTL with both past and future time operators can be monitored in time O(|ρ||φ|323|φ|) and space O(|φ|2 ) (note that φ = φ), while LTL with only past time operators can be monitored in time O(|ρ||φ|) and space O(|φ|). Indeed monitoring algorithms with the same complexity bounds are known for LTL with only future time operators [11] and LTL with only past time operators [12]. But the algorithm for LTL with both past and future time operators seems to be novel.

Exponential Lower Bounds for Space
We now derive some space lower bound results which show that the our mon- itoring algorithm for MTL and its sublogics is close to optimal.

Lower Bounds for MTL
Consider a monitoring scenario with only one proposition and hence only two states, say 0 and 1. For natural numbers k, n define the following language of finite timed sequences ρ = (π, τ ):
Lk,n = {ρ | τ1 = ... = τk, τi+k = τi + 1, ∃l s.t. |π| = lkn, and
∃i < l s.t. π[(i − 1)kn + 1, ikn]= π[(l − 1)kn + 1, lkn]}
Lk,n contains only those timed sequences whose length is a multiple of kn, and where time increases by one every k steps. Further, if the underlying state sequence is w1 ... wm, where each wi is of length kn, then wm = wi for some i < m.
Lemma 5.1 Any monitoring algorithm for Lk,n requires space Ω(2kn).	 
Now, we give an MTL formula φk,n that defines the language	k,n. The following ’macros’ will be useful for this purpose.
tick = ◦1true	end = ¬◦true
startcell = ◦k−1true	lastword = ¬ ntrue
where we write ◦k−1 for a sequence of ◦0 operators of length k − 1. The
predicate tick is true at a position if the time in the next position is exactly one more than the time in the current position, while end holds only at the last position in a timed sequence. The predicate startcell holds at a position only if the time does not advance in the next k  1 steps, while lastword holds at a position if the time in all the subsequent positions is at most n  1 units more than the time at the current position. The idea is that, since we are interested in the timed sequences where time increases only every k positions, startcell is true at positions that are one more than a multiple of k. In addition, since we are interested in sequences whose length is a multiple of kn, lastword is true only in the last kn positions. Define


φk,n = ψ1
∧ ψk,n
∧ ψk,n



where ψi
are defined as follows.

ψ1	= ◦k−1(tick ∨ end) ∧  (tick → ◦1◦k−1(tick ∨ end))
The predicate above expresses the condition that τ1 = ... = τk and τi+k =
τi + 1.

2
k,n
=  ≈n0  n−1true



The predicate ψ2
in conjunction with ψ1
expresses the condition that the

length of the timed sequence is a multiple of kn.

3
k,n
=  ≈n0(¬lastword ∧ startcell ∧

 [0,n−1](startcell →
k	i−1	i−1
∧i=1(◦0 0 →  ≈n0(lastword ∧ startcell ∧ ◦0 0) ∧
i−1	i−1
0 1 →  ≈n0(lastword ∧ startcell ∧ ◦0 1))))

The predicate ψ3
in conjunction with ψ1	and ψ2	enforces the additional

condition that ρ[(l − 1)kn + 1, lkn] = ρ[(i − 1)kn + 1, ikn] for some i < l.
Note the critical use of relative congruences in the above predicates instead of absolute congruences.

Theorem 5.2 Let A be any monitoring algorithm for MTL.
There is a formula ψ, to monitor which A requires space Ω(2αc

  
|ψ|),

where c is the largest constant occurring in ψ, and α is a ﬁxed constant.
There is a formula ψ, to monitor which	requires space Ω(22α|ψ| ) for a ﬁxed constant α.		 
In the formula ψ of Theorem 5.2.1, let c be as in the statement. Then we have for c > 1				

c	|ψ| ≥	(c + 1)|ψ| ≥	|ψ| + Σψ using the fact that Σψ ≤ c|ψ|.
Finally, note that since φk,n contains only future time operators, the lower
bounds established above also apply to MTL with only future time operators.

Lower Bounds for MTL with Intervals Only
We prove lower bounds for sublogics of MTL with no congruences (absolute or relative). We first prove a lower bound for MTL with only intervals of form [0, ∞). Note that this will also give us a lower bound for LTL.
Consider a monitoring framework with only two atomic predicates and therefore only four possible states, say 0, 1, # and $. For a natural number k, define Lk to be the set of all timed sequences (π, τ ) such that
π ∈ {σ#w#σ'$wσ'' | w ∈ {0, 1}k and σ, σ', σ'' ∈ {0, 1, #}∗}
A similar language was previously used in several works [16,17,20] to prove lower bounds in model checking and in monitoring extended regular expres- sions.
Lemma 5.3 Any monitoring algorithm for Lk requires space Ω(2k).	 


Theorem 5.4 Let A be any monitoring algorithm for MTL with only inter- vals o√f  form [0, ∞). There is a formula φ, to monitor which A requires space
Ω(2α  |φ|) for a ﬁxed constant α.	 

This lower bound can be improved for the sublogic of MTL with arbitrary intervals. Using the arguments similar to that in proof of Lemma 5.1, we can easily show that any monitoring algorithm would require space Ω(n) to mon- itor the formula p ( ( ntrue) ( nq)). Thus, in general any monitoring algorithm would require space Ω(2αφ) to monitor a formula φ. The above happened because φ contains a constant that is exponentially larger than φ . The following shows that even if the largest constant occurring in a formula is much smaller than the size of the formula, any monitor would still need an exponential space.
Theorem 5.5 Suppose is a monitoring algorithm for MTL with arbitrary intervals. There is a formula φ such that the largest constant occurring in it is smaller than |φ| and A requires space Ω(2α|φ|/ log |φ|), for a ﬁxed constant α. 


Conclusion and Future Work
A general monitoring algorithm for requirements expressed in metric tempo- ral logic (MTL) has been presented, together with instantiations for various sublogics of MTL. It was shown that the algorithm is exponential in the num- ber of temporal operators and atomic predicates, and in the sum of numeric constants in the original MTL formula, and also that the exponential bound cannot be avoided even for simple sublogics of MTL. The number of propo- sitional operators, which often take most of the size of a specification, does not affect the complexity of our algorithms. Since MTL is an expressive and powerful logic for monitoring requirements, the presented novel and close to optimal algorithms can be used in practical runtime verification and testing tools, such as JPaX [10].

Acknowledgement
We are thankful to Koushik Sen for stimulating us in doing a better space analysis of the presented technique, thus improving the space requirement of our monitoring algorithm from our original rough 2O(m) to the current O(m2m).

References
R. Alur and T. Henzinger. Real time logics: complexity and expressiveness. In Fifth annual symposium on logic in computer science, pages 390–401. IEEE Computer Society Press, 1990.
R. Alur and T. Henzinger. Logics and models of real time: A survey. In Real Time: Theory in Practice, volume 600 of Lecture Notes in Computer Science. Springer Verlag, 1992.
H. Barringer, A. Goldberg, K. Havelund, and K. Sen. Program monitoring with LTL in Eagle. In Workshop on Parallel and Distributed Systems: Testing and Debugging, 2004. To appear.
H. Barringer, A. Goldberg, K. Havelund, and K. Sen. Rule-based runtime verification. In Proceedings of 5th International Conference on Veriﬁcation, Model Checking and Abstract Interpretation (VMCAI’04), Lecture Notes in Computer Science, 2004.
R.E. Bryant. Graph-based algorithms for boolean function manipulation. IEEE Transactions on Computers, 35(8):677–691, 1986.
Doron Drusinsky. The Temporal Rover and the ATG Rover. In SPIN Model Checking and Software Veriﬁcation, volume 1885 of Lecture Notes in Computer Science, pages 323–330. Springer, 2000.
B. Finkbeiner and H. Sipma. Checking finite traces using alternating automata. Electronic Notes in Theoretical Computer Science, 55(2), 2001.
M. Geilen. On the construction of monitors for temporal logic properties. Electronic Notes in Theoretical Computer Science, 55(2), 2001.
M.C.W. Geilen. An improved on-the-fly tableau construction for a real-time temporal logic. In International Conference on Computer Aided Veriﬁcation, July 2003.
K. Havelund and G. Ro¸su. Monitoring Java programs with Java PathExplorer. Electronic Notes in Theoretical Computer Science, 55(2), 2001.
K. Havelund and G. Ro¸su. Monitoring programs using rewriting. In Automated Software Engineering. Institute of Electrical and Electronics Engineers Computer Society, 2001.
K. Havelund and G. Ro¸su. Synthesizing monitors for safety properties. In Tools and Algorithms for Construction and Analysis of Systems, Lecture Notes in Computer Science 2280, pages 342– 356, 2002.
Klaus Havelund and Grigore Ro¸su. Runtime Veriﬁcation 2001, volume 55 of Electronic Notes in Theoretical Computer Science. Elsevier Science, 2001. Proceedings of a Computer Aided Veriﬁcation (CAV’01) satellite workshop.
Jieh Hsiang. Refutational Theorem Proving using Term Rewriting Systems. Artiﬁcial Intelligence, 25:255–300, 1985.
R. Koymans. Specifying real-time properties with metric temporal logic. Real Time Systems, 2(4):255–299, 1990.
O. Kupferman and M. Y. Vardi. Freedom, Weakness, and Determinism: From linear-time to branching-time. In Proceedings of the IEEE Symposium on Logic in Computer Science, pages 81–92, 1998.
O. Kupferman and M. Y. Vardi. Model Checking of Safety Properties. In Proceedings of the Conference on Computer-Aided Veriﬁcation, Lecture Notes in Computer Science, 1999.
Zohar Manna and Amir Pnueli. Temporal Veriﬁcation of Reactive Systems: Safety. Springer, New York, 1995.
N. Markey and Ph. Schnoebelen. Model checking a path (preliminary report). In 14th Int. Conf. Concurrency Theory, Lecture Notes in Computer Science 2761, pages 251–265. Springer, 2003.


G. Ro¸su and M. Viswanathan. Testing extended regular language membership incrementally by rewriting. In Rewriting Techniques and Applications, Lecture Notes in Computer Science 2706, 2003.
P. Thati and G. Rosu. Monitoring algorithms for metric temporal logic specifications. Technical Report UIUC DCS-R-2003-2395, Department of Computer Science, University of Illinois at Urbana Champaign, 2003.
P. Wolper. Synthesis of Communicating Processes from Temporal Logic Speciﬁcations. PhD thesis, Stanford University, Dpeartment of Computer Science, 1982.
