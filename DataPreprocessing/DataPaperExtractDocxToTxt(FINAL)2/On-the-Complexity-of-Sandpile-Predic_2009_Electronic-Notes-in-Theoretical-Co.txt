

Electronic Notes in Theoretical Computer Science 252 (2009) 229–245
www.elsevier.com/locate/entcs

On the Complexity of Sandpile Prediction Problems
J. Andr´es Montoya 1,2 Carolina Mej´ıa3
Escuela de Matema´ticas Universidad Industrial de Santander Bucaramanga, Santander, Colombia


Abstract
In this work we study the complexity of Sandpile prediction problems on several classes of directed graphs. We focus our research on low-dimensional directed lattices. We prove some upper and lower bounds for those problems. Our approach is based on the analysis of some reachability problems related to sandpiles.
Keywords: Graph Automata, Complexity classes, Prediction Tasks, Discrete Dynamical Systems, Abelian Sandpile Model, Cellular Automata.


Introduction
The abelian sandpile model has been intensively studied in the physics milieu since its introduction by Bak et al [5]. This model allows us to simulate dissipative dynamical process such as forest fires, earth quakes, extinction events, the dynamic of the stock market, or avalanches [4].
One can look at The Abelian Sandpile Model as an special class of graph au- tomata. If one assume this point of view there are several algorithmic issues that one can (has to) take into account.  In [3] Babai defines The Sandpile Prediction
Problem which we study in this paper.  Babai asks for a characterization of its
complexity. It is known that the problem is in P when restricted to undirected graphs, so few is known about the complexity of the problem in the directed case.

1 Thanks to VIE-UIS and thanks to COLCIENCIAS research proyect 111548925292
2 Email: juamonto@uis.edu.co
3 Email: cmejiam@uis.edu.co

1571-0661 © 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.09.023

Relations to previous work and contributions
In [3] Babai defines some computational problems related to The Abelian Sand- pile Model, he shows that most of those problems can be reduced to The Sandpile Prediction Problem. It follows from the work of Tardos [13] that The Sandpile Pre- diction Problem, and each one of the problems considered by Babai, is polynomial time solvable when restricted to undirected graphs. Babai asks for lower bounds concerning the complexity of those problems in the directed case. This problem, Babai’s lower bounds problem, is still open and we have not solved it in this paper. Besides of Babai’s work there exists some previous work concerning the complexity of prediction problems related to sandpiles. First at all, it is important to remark that The Abelian Sandpile Model is close related to the Chip-ﬁring game of Bjorner et al [7]. In the Chip-firing game framework one can consider graphs without sink, and it implies that infinite long avalanches can occur. Bjorner and Lovasz stud- ied the Chip-firing game on directed graphs [6], they obtained a fine classification of Chip-firing’s possible dynamics, and as a corollary they could establish upper bounds on the algorithmic hardness of the Chip-ﬁring Game Prediction Problem.
If we consider the restriction of The Sandpile Prediction Problem to undirected graphs, this problem belongs to P. Questions concerning lower bounds come from parallel complexity ; circuit complexity and applications [4], [12]. Moore and Nilsson proved in [12], that the problem is already P -complete when restricted to lattices (grids) of dimension bigger than 2. The complexity of one-dimensional lattices is well understood thanks to Miltersen’s work [11] and our contributions: we prove TC0-hardness for The Sandpile Reachability Problem on one-dimensional undirected lattices, and we prove that the same problem belongs to AC0 when restricted to one-dimensional directed lattices.
Dimension two is highly non trivial. We show that, on two-dimensional di- rected lattices, exponential long avalanches can occur. It implies that we can not simulate the associated sandpile automata in polynomial time. We don’t know if the prediction problem on directed lattices belongs to P. In the two-dimensional case the gap between upper and lower bounds is very high. The best lower bound is L-hardness. The best upper bound comes from the best upper bound for the general case: we know that the prediction problem on directed graphs belongs to UP (Unambiguous Polynomial Time) [10].
We have established lower bounds for some restrictions of The Sandpile Predic-
tion Problem: we prove L-hardness for the restrictions to planar digraphs and di- rected two-dimensional lattices, we prove P -hardness and √n-strict P-completeness
for the restriction to acyclic digraphs.

Organization of the work
This work is organized into five sections including the introduction. In section two we introduce The Abelian Sandpile Model on directed graphs. In section three we define The Sandpile Prediction Problem and The Sandpile Reachability Problem, and we study the restrictions of these two problems to undirected graphs, planar

graphs and directed acyclic graphs. In section four we study the sandpile prediction and the sandpile reachability problems when restricted to directed and undirected lattices of dimensions one and two. In section five we state some important open problems.

Sandpiles: The directed case
In this section we introduce the basic definitions and some of the basic results concerning The Abelian Sandpile Model.
Definition 2.1 A sandpile graph is a pair (G, S) , where G is a finite digraph and
S ⊆ V (G) is a nonempty set of nodes satisfying the following two conditions.
For any v	S we have that deg+ (v) = 0, where deg+ (v) denotes the outdegree of G.
Given w ∈ V (G) − S, there exists a path from w to some element of S.
Given (G, S) a sandpile graph, the set S will be called the sink. Most of the time we will say that G is a sandpile graph and that S is the sink of G. We will use the symbol V (G)∗ to denote the set V (G) − S, that is: V (G)∗ denotes the set of nodes of G out of the sink. A conﬁguration on G is a function g : V (G)∗ → N. Given g a configuration on G and given v ∈ V (G)∗ we will say that v is g-stable if and only if g (v) ; deg+ (v) , and we will say that g is an stable conﬁguration if and only if for all v ∈ V (G)∗, we have that v is g-stable.
Definition 2.2 Given (G, S) a sandpile graph, the sandpile automaton on G is the graph automaton SP (G) defined by
The set of cells of SP (G) is the set V (G)∗ .
The set of configurations of SP (G) is the set {g : g is a configuration on G}.
Given g a configuration of SP (G) and given v a cell, the state of v under g is equal to g (v) .
Given g a configuration, the set of possible transitions from g is given by the following transition rule:
Given v	V (G)∗ , if g (v)	deg+ (v) , then we have that g	gv is a possible
transition, where gv is the configuration on G defined by
⎧⎪	g (v) − deg+ (v), if w = v
gv (w) := ⎪⎨ g (w)+ 1, if v is an ancestor of w
⎪⎪⎩ g (w) if v is not an ancestor of w

Any transition of SP (G) is called a ﬁring or a toppling. So, given g a configu- ration, the transition g  gv is a firing, and if such a transition occurs, we say that the node v was fired (toppled) or we say that a firing (toppling) at v has occurred.

Remark 2.3 We will only consider graphs without loops and without multiple edges.
Given (G, S) a sandpile graph and given g an initial configuration, we can choose an unstable node, fire it and obtain a new configuration. Note that we can choose any unstable node to produce a firing, in this sense sandpile automata are nonde- terministic.  A sequence of firings g1  g2  ...  gn is called an avalanche of length n with initial configuration g, and we say that it is an avalanche from g to gn. If gn is stable we say that gn is a stabilization or a relaxation of g. If we fix a configuration g on V, we can consider the following three sets: Aval (G, g) , the set of avalanches whose initial configuration is g; AvalM (G, g) the set of maximal avalanches beginning in g (A is maximal if and only if A can not be extended, that is: A is maximal if and only if its final configuration is stable); st (G, g) the set of relaxations of g.
Furthermore, given G, g and
A = g → g1 → ... → gn

an avalanche, the score vector of A, which we denote SCA, is equal to
∗
(tv)v∈V (G)∗ , where for any v ∈ V (G) the entry tv is equal to the number of times
node v was fired during the occurrence of A.
Theorem 2.4 (The fundamental theorem of sandpiles)
Let (G, S) be a sandpile graph and let g be a conﬁguration, we have:
Any avalanche beginning in g is ﬁnite.
|st (G, g)| = 1.
Given A,B ∈ AvalM (G, g), we have that SCA = SCB.
A proof of this theorem can be found in [14]. Theorem 2.4 says many things about sandpile automata. Item 1 says that sandpile automata are terminating. Item 2 says that sandpile automata are confluent, i.e. the input (the initial config- uration) determines an unique output (its stabilization). Item 3 says that, though there are many computation paths, sandpile automata are strongly determinis- tic, since given SP (G) a sandpile automaton and given two computation paths of SP (G) on input g, the second path is simply a permutation of the first, and as a consequence they have the same length.

The Sandpile prediction problem
Given C (G) = NV (G)∗ the set of all the configurations on G and given st (G) the set of all the stable configurations on G, we can define two functions stG : C (G) → st (G) and SCG : C (G) → C (G) in the following way:
stG (g) := the stabilization of g.
SCG (g) := SCA, where A is any element of AvalM (G, g) .

Note that, for any sandpile graph (G, S) , the functions stG and SCG are com- putable, since the avalanches are always finite. Given g a configuration on G, in order to compute either stG (g) or SCG (g), we only have to simulate the automaton SP (G) on input g.
Notation 3.1  Given g	C (G) we will use the symbol SCg to denote the vector
SCG (g) .
We can obtain as an easy consequence of the invariance of the score vector the following theorem
Theorem 3.1 Given (G, S) a sandpile graph and given f1, f2 and f3 three conﬁg- urations, we have that
stG (f1 + f2 + f3) = stG (stG (f1 + f2)+ f3) .
stG (f1 + f2) = stG (f2 + f1) = stG (stG (f2)+ stG (f1)) .
We are ready to define The Sandpile Prediction Problem, with its definition we finish this subsection
Problem 3.2 (SPP, sandpile prediction)
Input: A sandpile graph (G, S) and an initial conﬁguration g ∈ C (G) .
Problem: Compute stG (g) .

Sandpile reachability
Let us introduce a second computational problem related to sandpile prediction.
Problem 3.3 (SPR, sandpile reachability)
Input: ((G, S) , g, v), where (G, S) is a sandpile graph, g is a conﬁguration on G
and v ∈ V (G)∗ .
Problem: Decide if SCg (v) ≥ 1.
Theorem 3.4 SPR is reducible to SPP
Proof. Given (G, S) a sandpile graph on {1, ..., n, n + 1, ..., n + k} , whose sink S is equal to n + 1, ..., n + k , the laplacian of (G, S) is the matrix LS (G) = [aij]i,j≤n defined by
Given i ≤ n we have that aii = − deg+ (i) .
Given i /= j we have that aij = 1 if (i, j) ∈ E (G), otherwise aij = 0.
Suppose that g is a configuration on G, we can think of g as an element of Nn. If node v fires, we obtain a new configuration gv. Note that gv = g + LS (G), where LS (G) is the v-th row of LS (G).  Thus, we have that for any configuration g


stG
(g) = g + LS (G) T (SC )


where LS (G) T is the transposition of LS (G).  We call last equation the motion equation of sandpiles. This equation has many important consequences, it allows us

to compute in polynomial time the vector stG (g) if oracle access to SCg is provided. Interesting enough the reciprocal is true, that is: given stG (g) we can compute in polynomial time the vector SCg. Suppose we can solve the problem SPP in polynomial time. First at all we compute (in polynomial time) the vector stG (g) . Now we note that LS (G) is a non singular matrix, (according to Kirchhoff’s matrix theorem, see reference [14], we have that det LS (G) is equal to the number of spanning forests of G directed to S. Note that this quantity is not zero, since S is accessible from any node v ∈ V (G)∗). Then, we have that the linear system
st (g) − g = LS (G) T X

has a unique solution which is equal to SCg.  Hence, we can solve the linear system and compute SCg. Therefore, we have that we can solve SPR in polynomial time, (if oracle access to SPP is provided).  By the way, we have proven that these two vectors associated to the pair (G, g) are polynomial time equivalent (the computations of these two vectors are Turing equivalent).	 

Restrictions of SPP
Given  a class of sandpile graphs, SPP [ ] will denote the restriction of SPP to the class , (we define SPR [ ] accordingly). Along this paper we will consider several such restrictions.

Undirected graphs
Let be the class of undirected sandpiles. Note that, we can think of an undirected graph as if it were a symmetric digraph. Furthermore, we can characterize the class of undirected sandpile graphs as the class of symmetric sandpile digraphs: an undirected sandpile graph is a sandpile digraph (G, S) such that G−S is symmetric.
Theorem 3.5 SPP [U ] is P-complete.
Proof. Given ((G, S) , g) an input of SPP [ ] , we can compute stG (g) by running the sandpile automaton SP (G) on input g. This computation is polynomial time bounded, since Tardos’ bound [13] implies that the size of any avalanche beginning in g is polynomial bounded, and the simulation of any toppling can be carried out in linear time (constant time on bounded degree graphs, constant time on a parallel computer with deg (G) processors, constant time on the sandpile automaton SP (G)). Thus, we have that SPP [U ] ∈ P.
Moore and Nilsson [12] proved that SPP is P -hard when restricted to undirected grids of dimension 3. It implies that SPP [U ] is P -hard.	 

Acyclic graphs
Let  be the class of acyclic sandpiles. Because of the confluence of avalanches we can fix, in advance, an evaluation scheme.
Definition 3.6 (order evaluation scheme)

Let (G, S) be a sandpile graph, if ≤ is an ordering of V (G)∗ , we define the order evaluation scheme of SP (G) , given the ordering ≤, in the following way:
At any stage of the computation we look for the	-lowest unstable vertex, and we fire it.
Theorem 3.7 SPP [A] ∈ P.
Proof. Let M be the algorithm defined by:
Given (G, S) an acyclic sandpile graph and given g	C (G) , the algorithm M
works on input ((G, S) , g) in the following way.
M computes ≤, a topological order of G.
Until all nodes in V (G)∗ become stable, the algorithm M computes the	- lowest unstable node, and M fires it.

Suppose  g   =
v∈V (G)
It is easy to verify that the sandpile triple
∗

((G, S) , g) becomes stable after at most |V (G)∗| g  firings. Hence, M is a poly- nomial time algorithm (the size of ((G, S) , g) is equal to |V (G)| g ).	 
Remark 3.8 Suppose that M is the algorithm used in the proof of theorem 3.4. Note that, given ((G, S) , g, v) an instance of SPR, the algorithm M, on input ((G, S) , g, v) , makes a single query to the oracle, this single query is equal to: what is stG (g)? It implies that for any class C of sandpile graphs the problem SPR [C] is Turing reducible to SPP [C] .
Theorem 3.9 SPR [A] is P-complete
Proof. We show that the evaluation of monotone boolean circuits is log space re- ducible to SPR [ ] . The reduction is very similar to the reduction used by Moore and Nilsson in [12]. Moore and Nilsson defined a reduction from the monotone circuit value problem, (MCV P for short), to SPP [ ]. Our reduction is a little bit more elementary, since directed edges allow us to avoid the construction of diodes, which are the gadgets used by Moore and Nilsson to force irreversibility on chips’ movement.  Furthermore, we have used the orientations of our edges to achieve a reduction of MCV P into SPR [A], which seems to be a problem easier than SPP [A].
Let (C, f ) be an instance of MCV P . We can suppose, without loss of generality, that C is stratified and that for any inner gate of C, say v, we have that deg− (v) = 2 and deg+ (v) = 1. We have to design some gadgets which allow us to simulate: and gates, or gates, the output gate and the input gates. The simulation is based on the following analogy
After its evaluation, gate v sends a true-signal to gate w, (along the wire connecting v to w), if and only if node v ﬁres
and sends a chip to node w, (along the edge connecting v to w)
So, we define a sandpile graph (G, S) whose nodes are the gates of C plus an additional node s. Furthermore, the directed edges of G correspond to the directed

wires of C plus the edge (o, s), where o is the output gate of C.  Finally we set
S = {s}∪ v : deg+ (v) = 0}

To simulate the boolean type(role) of each one of the gates we play with the values of g.
If c is a Λ-gate whose outdegree is equal to n /= 0, we place n — 2 chips on c, that is we set g (c) = n — 2 = deg+ (c) — 2.
If c is an V-gate whose outdegree is equal to m /= 0, we place m — 1 chips on
c, that is we define g (c) = m — 1 = deg+ (c) — 1.
If c is an input gate whose outdegree is equal to m. Then, if f (c) = 1 we place m chips on c , otherwise we do not place chips on c, that is we set g (c) = f (c) deg+ (c).
Given (C, f ), the algorithm M can compute the tuple ((G, S) , g, o) using loga- rithmic space. It is easy to check that f satisfies C if and only if SCg (o) ≥ 1. Remark 3.10 The same proof can be used to prove that SPR [ ] is strictly √n- hard for P (more information can be found in [8]).

Planar Sandpiles
Let be the class of planar sandpile digraphs. We can use the same reduction of theorem 3.9 to prove that the planar restriction of MCV P (MPCV P for short) is NC1-reducible to SPR [ ] . It is known (see reference [9]) that MPCV P is L-hard under quantifier free reductions, (hence L-hard under NC1-reductions).
We  will  prove  that  The  Directed  Planar  Reachability  Problem ( REACH (planar) for short) is NC1-reducible to SPR [У].
Problem 3.11 (REACH (planar), directed planar reachability)
Input: (G, s, t), where G is a planar digraph and s, t ∈ V (G) .
Problem: Decides if t is accessible from s.
Remark 3.12 The problem REACH (planar) is L-hard under uniform projec- tions [1], and it is a problem supposed to be harder than MPCV P .
Given G a planar graph, a combinatorial embedding of G is an algorithm cG, which on input v V (G) outputs a cyclic ordering of the edges that are incident with v. We will suppose that, given (G, s, t) an instance of REACH (planar) , a combinatorial embedding cG of G is attached to the code of (G, s, t) .
Remark 3.13 Combinatorial embeddings of planar graphs can be computed using logarithmic space (see reference [1]).
Let REACH (У) be the directed planar reachability problem restricted to У.
Theorem 3.14 REACH (planar) is NC1-reducible to REACH (У) .

Proof. Let (G, s, t) be an instance of REACH (planar). Let Gu be the undirected planar graph obtained from G by forgetting the orientations of its edges. First at all we add a center node to any face of G. We can use cGu to recognize the faces of Gu. To this end we can use the following procedure.
Given v a node and given e an edge incident with v, we go from v to u, the other end of e. After entering u we choose the next edge (next to e in the cyclic ordering cGu (u)). We continue our walk till node v is reached again, along the walk we obey the following rule:

each time we enter a node, we leave it using the next edge

The nodes which we visit, and the edges that we use along a single walk consti- tute a single face. So, given v and e we can compute one of the two faces determined by v and e. If we use last procedure on any pair (v, e) we can compute all the faces of G.
Given F a face of G, we add a new node vF , and given u a node which lies on the border of F we add the edge (u, vF ) . Let HG be the output graph of our procedure. Note that HG was obtained from G by adding a center-sink node to any face of G, and by connecting each one of those center-sink nodes to the nodes located on the borders of their corresponding faces (the edges being directed from the border to the center). Furthermore, given s, t V (G), we have that (G, s, t) REACH (planar) if and only if (HG, s, t) REACH ( ). What have we gained with the construction of HG? Note that HG is a planar sandpile graph, since each one of the centers is a sink node, and any node is either a sink or can reach at least one center-sink in one step.
We can suppose,  without loss of generality,  that any face of G has O (log (|V (G)|)) edges. Thus, we have proven that REACH (planar) is NC1- reducible to REACH (У).	 
Let (G, s, t) be an instance of REACH (the reachability problem on general digraphs). We use the symbol N (t) to denote the set of ancestors of t, and we use the symbol ϕ (s, t, m) to denote the sentence v  N (t) (SCmes (v)  1) . We define the sandpile distance between s and t in the following way.
δ  (s, t) = ⎧⎨ If dG (s, t) ; ∞.  Then δG (s, t) = minm {ϕ (s, t, m)}
⎩	∞ else
Note that δG (s, t) is equal to the minimum number of chips one have to place on s in order to fire at least one neighbor of t.
Lemma 3.15 (G, s, t) ∈ REACH (У) if and only if δG (s, t) ≤ nn.
Proof. Suppose that (G, s, t)  REACH ( ).  Let s, v1, v2, ..., vm,t be a simple path from s to t and let D be an upper bound on the outdegrees of the nodes s, v1, v2, ..., vm. Note that m, D  n  1.  Suppose that there are nn chips placed on s.  We fire s until we place at least nn−1 chips on v1. Then, we fire v1 until

we place at least nn−2 chips on v2 and so on. We can show, using an inductive argument, that we can place at least nn−m ≥ n chips on vm. Hence, we can fire vm, since deg+ (vm) ≤ n — 1 and n — m ≥ 1. It is clear that if (G, s, t) ∈/ REACH (У), then δt (s, t) = ∞. Thus, we have proven that (G, s, t) ∈ REACH (У) if and only if δt (s, t) ≤ nn.	 
Corollary 3.16 REACH (У) is NC1- reducible to SPR [У].
Sandpile lattices
In this section we consider a very special class of sandpile graphs, the class of sandpile lattices. We focus our research on sandpile reachability problems.
A directed lattice of dimension d is an orientation of a finite hypercubic lattice (grid) of dimension d (square lattice if d = 2, cubic lattice if d = 3). A sandpile lattice is a sandpile graph H = (G, S) such that G is a directed lattice
Let SPR [d] denotes the problem SPR restricted to d-dimensional sandpile lat- tices, we want to analyze the complexity of SPR [d] .
Theorem 4.1 If d ≥ 3, we have that SPR [d] is P-hard.
Proof. To prove the theorem we can use the same reduction of theorem 3.9. It is sufficient to note that given an acyclic digraph G, there exists a, suitable, log space computable embedding of G into a sandpile lattice of dimension 3 (see reference [12]).	 
From now on, we will focus our analysis on low-dimensional lattices

One-dimensional lattices
The behavior of directed sandpiles seems to be strictly more complex than the behavior of undirected sandpiles. This is true if we consider either general graphs or d-dimensional sandpile lattices with d 2. It is an interesting fact that in the one-dimensional case we have just the opposite fact. Let SPRu [1] be the sandpile reachability problem restricted to undirected one-dimensional lattices. We will show that SPRu [1] is hard for TC0 with respect to constant depth reductions. Hence, SPRu [1] is not in AC1−є for any ϵ ; 0. On the other hand, we will show that SPR [1] belongs to AC0. Therefore, we will have that SPR [1] is strictly easier than SPRu [1] .

The lower bound: TC0-hardness of SPRu [1]
Let (Gn, Sn) be the one-dimensional undirected sandpile lattice on 0, 1, ..., 3n + 1 , (we have that Sn = 0, 3n + 1 ). Suppose that g is a configuration on Gn which satisfies the following three conditions.
If i ≤ n, then we have g (i) = 0.
If i ∈ {n + 1, ..., 2n}, then we have g (i) ∈ {1, 2} .
If i ≥ 2n + 1, then we have g (i) = 0.

Let  g  = Σi g (i) ≤ 2n
Theorem 4.2 There exist numbers i, j ∈ {0, 1, ..., 3n + 1} such that
i ; j and j — i ∈{  g  , g  — 1}
If k ∈/ {i, i + 1, ..., j}, then sttn (g) (k) = 0.
If k ∈ {i, i + 1, ..., j}, then sttn (g) (k) ∈ {0, 1} ; and there exists at most one
k such that i ; k ; j and sttn (g) (k) = 0.
Proof. Let i1  i2  ...  ik be the positions where the value of g is equal to 2. Let g0 be the configuration which takes the value 1 on the set n + 1, ..., 2n and the value 0 on its complement. Note that
g = g0 + ei1 + ... + eik
The abelian property of the abelian sandpile model (3.1) implies that
stt (g) = stt (gk−1 + eik )

where g1 = stt (g0 + ei1 ) and given gir we have that gr+1 = stt gr + eir+1 . First at all we try to compute g1. It is easy to check that g1 is a configuration constituted by a zero floating in a connected sea of ones, and that the position of the isolated zero is the mass center of the configuration g0 + ei1 , that is: we have a position j1 ∈ {n + 1, ..., 2n} such that g1 (j) = 0. Furthermore, we have that if j ∈ {n + 1, ..., 2n}— {j1}, then g1 (j) = 1; and either g1 (n) = 1 or g1 (2n + 1) = 1.
Now, we try to compute g2.	If j1 = i2, then there exists an interval I1 ⊇
{n + 1, ..., 2n} such that g1 + ei2 takes the value 1 on I1 and the value 0 out of I1. In this case g1 + ei2 is already a stable configuration and is equal to g2. If j1 /= i2, then there exists an interval I1 ⊇ {n + 1, ..., 2n} such that g1 + ei2 takes the value 0 out of I1; (g1 + ei2 ) (j1) = 0; (g1 + ei2 ) (i2) = 2; and g1 + ei2 takes the value 1 on any other point of I1. So, the configuration g1 + ei2 looks like a zero and a two floating in a connected and isolated sea of ones. It is easy to check that g2 = stt (g1 + ei2 ) is a stable configuration of one of the following two types:
(Type 1) There exists an interval I2  n + 1, ..., 2n such that stt (g1 + ei2 ) takes the value 0 out of I2 and the value 1 on I2. Furthermore, the length of I2 is n + 2.
(Type 2) There exists an interval I2 ⊇ {n + 1, ..., 2n} such that stt (g1 + ei2 ) takes the value 0 out of I2 and the value 1 on I2 — {x} , where x ∈ I2 and stt (g1 + ei2 ) (x) = 0. Furthermore, the length of I2 is n + 3.
At this point, it should be clear that we can use an inductive argument to prove that for any j  k, the configuration gj is a configuration of one of the following two types:
(Type 1) There exists an interval Ij  n + 1, ..., 2n such that gj takes the value 0 out of Ij and the value 1 on Ij. Furthermore, the length of Ij is n + j.

(Type 2) There exists an interval Ij  n + 1, ..., 2n such that gj takes the value 0 out of Ij and the value 1 on Ij  x , where x Ij and gj (x) = 0. Furthermore, the length of Ij is n + j + 1.
If we take j = k we obtain the theorem.	 
We are ready to prove the main theorem of this subsection. We will prove that the computation of the majority function is constant depth reducible to SPRu [1].
Given (x1, ..., xn) , we have that M aj (x1, ..., xn) = 1 if and only if Σ xi ≥ [ n♩+1.
Note that M aj (x , ..., x ,x	= x , ..., x	= x ) = 1 if and only if Σ x ≥ 2 +1 

if and only if Σ xi ; n.
n+1	1
2n	n	i	n

Theorem 4.3 SPRu [1] is TC0-hard.
Proof. We show that the computation of the majority function is constant depth reducible to SPRu [1].  Suppose that x = (x1, ..., xn) is a boolean vector.  Let m = 2n and let (y1, ..., ym) = (x1, ..., xn, x1, ..., xn).  We define a configuration gx on {0, 1, ..., 3m + 1} as follows
g (i) = ,⎨ yj +1 if i = m + j and j ∈ {1, ..., m}
,	0 else
Note that gx satisfies the conditions in the statement of theorem 4.2. Let us call the shadow of gx to the area out of m + 1, ..., 2m that will be filled with chips after the relaxation process.  If Maj (x) = 1, then the shadow of gx will be large, it will fill at least n + 2 positions. On the other side, if Maj (x) = 0, then the shadow of gx will be small, it will fill at most n + 1 positions. Let Am be equal to the set
{(i, j) : 0 ≤ i ≤ m & j ; 2m & j — i ≥ m + n + 1} Note that M aj (x1, ..., xn) = 1 if and only if

 
(i,j)∈Am
(((Gm, g,i + 1) ∈ SPRu [1]) Λ ((Gm, g,j — 1) ∈ SPRu [1]))

Thus, we have proven that we can compute the majority function using a D log time uniform family of depth-three circuits, with an or gate on the top; a second layer composed by and-gates and a first layer composed by SPRu [1] oracle gates. Therefore, we have that SPRu [1] is TC0-hard.	 
Remark 4.4 (upper bounds) It follows from the work of Moore and Nilsson that
SPRu [1] belongs to NC3.

The upper bound
In this subsection we prove an upper bound for SPR [1], specifically we prove that
SPR [1] belongs to AC0.
Theorem 4.5 SPR [1] belongs to AC0.

Proof. Let G be a directed one dimensional lattice, we suppose that the universe of G is equal to 1, ..., n . Note that, the nodes of G can be classified into three groups as follows:
Source nodes, which are nodes whose outdegree is 2.
Dummy nodes, which are nodes whose outdegree is 1.
Sink nodes, which are nodes whose outdegree is 0.
We will suppose that any node is an inner node, i.e. in order to avoid some technicalities we will impose periodic conditions on our one-dimensional lattices. Additionally we will suppose that

S (G) = {v : v is a sink node}

is a nonempty set.  Let g be a configuration on G and let i be a node, note that
If i is a source node, then SCg (i) ≥ 1 if and only if g (i) ≥ 2.
If i is a dummy node, there exists a pair j, k  1, ..., n such that j ; i ; k; for any l such that j ; l ; k we have that l is a dummy node; and one of the two nodes j, k is a source, while the other one is a sink. Furthermore, we have that if x  j, k is a source, then SCg (i)  1 if and only if either g (x)  2 or there exists j in the interval between x and i (the interval (x, i] , which includes i and excludes x) such that g (j) ≥ 1.
If i is a sink node, then we have that SCg (i) = 0.
Given ((G, S) , g) , we codify ((G, S) , g) as a vector tt,g = (ti)i≤n , where for any
i ≤ n we have that ti is equal to the boolean triple (li, ri, gi) defined by
li = 1 if and only if the edge on the left of i is an outgoing edge.
ri = 1 if and only if the edge on the right of i is an outgoing edge.
gi = 1g(i).
Given k, i, h	n (we suppose that 1 ; i ; n), the boolean formula αkih is defined in the following way:
If k ; i ; h we have that αkih is equal to βkih V γkih, where βkih is the formula

⎛	⎛
(lk Λ rk) Λ (∼ li Λ ri) Λ (∼ lhΛ∼ rh) Λ	(gk ≥ 2) V
⎞⎞
gj ≥ 1




⎛
⎝k;j;i
⎝

Λ

(∼ lj Λ rj)	Λ	 
i;j;h
⎝k;j≤i	⎠⎠

⎞
(∼ lj Λ rj)⎠


The formula γkih is defined accordingly (interchanging the role of k and h).
If k = i = h, then αiii = (li Λ ri Λ gi ≥ 2)

Finally we define a formula ψi in the following way

⎛
ψi = αiii V


αkih

⎝k;i;h	⎠
It is easy to check that ψi (tt,g) = 1 if and only if SCg (i) 1. Note that the formula ψi has a depth which is upperbounded by 6. Thus, we have proven that we can solve the problem SPR [1] using a D log time uniform family of circuits of bounded depth and defined on the logical basis , , , i.e. we have proven that SPR [1] belongs to AC0.	 

Two-dimensional lattices
In this section we will analyze the problems SPR [2] and SPP [2]. We will prove that:
On two-dimensional sandpile directed lattices exponential long avalanches can occur.
SPR [2] is L-hard under NC1 reductions.

Long avalanches
In this section we prove that there are not polynomial bound on the size of the avalanches, when we consider the class of two-dimensional sandpile lattices. This theorem rules out the possibility of using the naive sandpile automata simulation algorithm to solve, in polynomial time, the problems SPP [2] and SPR [2] .
Let (G, S) be a sandpile graph such that S =  s  and there exists a path
v0, v1, v2, ..., vn,s with the following three properties:
deg+ (v0) = 1.
For any i, if 1 ≤ i ≤ n, then deg+ (vi) ≥ 2.
For any i ≥ 0 we have that deg− (vi) = 1.
Lemma 4.6 Given g =  |G|2 + 1 ev , the length of any maximal avalanche trig-
gered by g is lowerbounded by 2n.
Proof. First we note that, in order to stabilize the sandpile it is necessary to throw at least one chip trough the sink. It implies that SCg (vn)  1. Note that in order to place one chip on vn we have to fire vn−1 at least one time. Hence, one toppling at node vn forces at least two topplings at node vn−1. Two topplings at node vn−1 forces at least four topplings at node vn−2, and so on. We can show, using an inductive argument, that one toppling at node vn forces at least 2n topplings at node v0.  Thus, we have proven that the length of any maximal avalanche with
initial configuration  |G|2 + 1 ev  is bigger than 2n.	 
Theorem 4.7 There is not polynomial bound on the size of the avalanches for The Abelian Sandpile Model on two-dimensional sandpile directed lattices.

Proof. First at all we define ((Gn, Sn))n≥1 a sequence of two-dimensional sandpile directed lattices. Given n ≥ 1 we define (Gn, Sn) in the following way:
V (Gn) = {(m, i) : m ≤ n + 1 and i ∈ {0, 1}}.
E (Gn) = A1 ∪ A2 ∪ A3, where
A1 = {((m, 0) , (m + 1, 0)) : m ≤ n}
A2 = {((m, 1) , (m — 1, 1)) : 1 ≤ m ≤ n + 1}
A3 = {((m, 0) , (m, 1)) : 1 ≤ m ≤ n}
∪ {((0, 1) , (0, 0)) , ((n + 1, 1) , (n + 1, 0))} .


Sn = {(n + 1, 0)} .
Note that the path (0, 0) , (1, 0) , ..., (n + 1, 0) satisfies the conditions in the state- ment of lemma 4.6, and note that |Gn| = 2n + 4.	From l emma 4.6 we h ave that
lowerbounded by 2n.	 
Remark 4.8 Note that if we define gn as (n + 1) e(0,0) we obtain the same lower bound on the length of the maximal avalanches triggered by gn.
Last theorem rules out the possibility of solving in polynomial time the problem SPP [2] by means of the naive sandpile automata simulation algorithm.  It does not imply that we can not solve SPP [2] in polynomial time, note that, with some effort we could compute a closed-form formula (of low arithmetical complexity) for
the function h : N → NV (tn)∗ defined by h (n) = st	(g ) 4
n
So, we can predict, (even better than in polynomial time), the final states of our exponential long avalanches. Can we always predict? At the moment we do not know if SPP [2] belongs to P, this problem could be intractable, but we conjecture that SPP [2] ∈ P .
Remark 4.9 In this paper we have chosen a sequential updating protocol (we choose one unstable node v and we fire v).  There are other updating protocols, like for example the parallel updating protocol (we fire all unstable nodes at once). Those others protocols yield only polynomial speed ups. Hence, exponential long avalanches remains exponential long and exponential problematic.
Lower bounds for SPR [2]
In this section we will prove that SPR [2] is L-hard under NC1 reductions. Consider the following problem

4 Note that given n, m ≥ 1 and given gn,m = me(0,0) ∈ C (tn), the relaxation of gn is the configuration
g∗ defined by
g∗ ((k, i)) = j1,	if 1 ≤ k ≤ (m  mod (n + 1)),

Problem 4.10 (REACH (grids), directed grid reachability)
Input: (G, s, t), where G is a grid digraph and s, t ∈ V (G) .
Problem: Decides if t is accessible from s.
In this subsection we prove that this problem is NC1 reducible to SPR [2] . It is known that the problem REACH (grids) is L-hard under quantifier free reductions (see reference [2]).
Theorem 4.11 REACH (grids) is NC1 reducible to SPR [2].
Proof. We can work along the lines of the proofs of theorem 3.14 and corollary 3.16. It is important to remark that in the case of grid graphs we don’t have to compute the faces, which is the most consuming part of the reductions used in theorem 3.14 and corollary 3.16.	 
Corollary 4.12 SPR [2] is L — hard under NC1 reductions.
Open problems
Let us finish this work stating some interesting open problems.
We know that SPR [2] is L-hard, but the best upper bound is UP - computability. Improve the lower and(or) upper bounds for SPR [2]. We conjecture that SPR [2] belongs to P .
We know that SPR [У] is L-hard, but the best upper bound is UP - computability. Improve the lower and(or) upper bounds for SPR [У].
We know that if d  3, SPR and SPR [d] are equivalent and P -hard, but we don’t know if SPR belongs to P. Prove that SPR belongs to P .

References
E. Allender, S. Datta, S. Roy. The Directed Planar Reachability Problem. Proceedings FST & TCS, LNCS 3821: 238-249, 2005.
E. Allender, D. Barrintong, T. Chakraborty, S. Datta, S. Roy. Grid Graph Reachability Problem. In
Electronic Colloquium on Computational Complexity. Report No. 149 (2005).
L. Babai. The abelian sandpile model. Manuscript, available at http://people.cs.uchicago.edu/
\char126\relaxlaci/REU05/.
P. Bak. How nature works: The science of self-organized criticality. Copernicus, NY, 1996.
P. Bak, C. Tang, K. Wiesenfeld. Self Organized Criticality. Physical Review A, 38:364-374 (1988).
A. Bjorner, L. Lovasz. Chip-firing Games on Directed Graphs. J. Algebraic Combinatorics. 1:305-328, 1992.
A. Bjorner, L. Lovasz, P. Shor. Chip-firing Games on Graphs. Europ. J. Comb. 12:283-291, 1991.
A. Condon. A Theory of Strict P -completeness. STACS proceedings:33-44, 1992.
T. Chakraborty, S. Datta. One-input-face MPCVP is hard for L, but in LogDCFL. In Electronic Colloquium on Computational Complexity. Report No. 130 (2006).

C. Mej´ıa. El modelo de pilas de arena, el caso dirigido. Revista Integraci´on-UIS, 24(2):101-116, 2006 (in spanish).
P. Miltersen. The computational complexity of one-dimensional sandpiles. Theory of computing systems. 41(1):119-125, 2007.
C. Moore, M. Nilsson. The computational complexity of sandpiles. Journal of Statistical Physics.
96:205-224, 1999.
G. Tardos. Polynomial bound for a chip firing game on graphs. SIAM J. Discrete Mathematics.
1:397-398, 1988.
E. Toumpakari. On the abelian sandpile model. Ph.D. Thesis, University of Chicago, 2005.
