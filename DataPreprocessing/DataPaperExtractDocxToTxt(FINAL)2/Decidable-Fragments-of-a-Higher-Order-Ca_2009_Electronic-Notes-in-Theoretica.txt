

Electronic Notes in Theoretical Computer Science 242 (2009) 113–138
www.elsevier.com/locate/entcs

Decidable Fragments of a Higher Order Calculus with Locations
Mikkel Bundgaard1 ,3	Jens Chr. Godskesen2 ,4
The Programming, Logic, and Semantics group IT University of Copenhagen
Denmark
Bjørn Haagensen5	Hans Hu¨ttel6
Department of Computer Science Aalborg University
Denmark

Abstract
Homer is a higher order process calculus with locations. In this paper we study Homer in the setting of the semantic finite control property, which is a finite reachability criterion that implies decidability of barbed bisimilarity. We show that strong and weak barbed bisimilarity are undecidable for Homer. We then identify and compare two distinct subcalculi of Homer that both satisfy the semantic finite control property. One subcalculus is obtained by using a type system bounding the size of process terms. The other subcalculus is obtained by considering the image of the encoding of the finite control π-calculus in Homer.
Keywords: Decidability, higher order process passing, locations, semantic finite control


Introduction
The calculus Homer [7] is a higher order process calculus with nested location hier- archies and active process mobility. Its syntax and semantics are inspired by calculi such as Plain CHOCS [17] and the higher order π-calculus [15]. Similar to these

1 Supported by grant no. 274-06-0415 and 2059-03-0031 from the Danish Research Council for Technology and Production and the IT University of Copenhagen (the CosmoBiz and BPL projects).
2 Supported by grant no. 272-05-0258 from the Danish Research Agency.
3 Email: mikkelbu@itu.dk
4 Email: jcg@itu.dk
5 Email: bh@cs.aau.dk
6 Email: hans@cs.aau.dk

1571-0661 © 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.06.016

calculi we have the ability to send a passive resource r (along the name a),
a⟨r⟩.p | a(x).q −−−→ p | q{r/x} .
Active process mobility and nested location hierarchies are introduced in the cal- culus by the location prefix, a⟨r⟩.p, where r is an active resource computing at the location a. A process can take an active resource and bind it to a process variable using the complementary prefix a(x).q according to the following reduction rule
a⟨r⟩.p | a(x).q −−−→ p | q{r/x} .
We can communicate with processes residing in locations by allowing sequences of names in the prefixes. E.g. we can take the resource r from the location b inside the location a using the composite address ab

a⟨b⟨r⟩| p'⟩.p | ab(x).q −−−→ a⟨p'⟩.p | q{r/x} .
In a similar manner we can send a passive resource to a receiver residing in a sublocation.
a⟨b(x).p' | p''⟩.p | ab⟨r⟩.q −−−→ a⟨p'{r/x}| p''⟩.p | q .
Homer can encode persistent locations [7], mobility as in the Seal calculus [9], and name passing as in the π-calculus [1,2], thus exemplifying some of its expressive power. The purpose of this work is to investigate decidability of barbed bisimilarity in Homer with all operators. Results of this type are useful as a basis for model- and equivalence-checking. Apart from the results mentioned below, few results of this type exist in the context of higher order calculi with locations, and the question is non-trivial since Homer can encode Turing machines.
Intuitively, a ﬁnite control calculus is a calculus where the control structure is finite. I.e. starting in any state, the number of states reachable via internal reduc- tion steps are finite. This paper shows that in a full higher order calculus with locations, finite control [6] is a complicated issue. In the context of CCS [12] and the π-calculus [16] it has been shown that finite control can be obtained simply by prohibiting the use of the operator for parallel composition in recursive defini- tions [6]. The solution is not equally simple in higher order calculi such as Homer and HOπ. There are several reasons for this. First, there is no explicit recursion or replication operator in Homer since recursion is a derived operator [9]. Moreover, process-variables may be instantiated with arbitrary processes. But most impor- tant is the observation that even without using parallel composition in recursion, one can define a process with infinitely many non-barbed bisimilar reducts. We can construct such a process in Homer by using that process variables can occur at sublocations as in a(x).a⟨n⟨x⟩⟩, where an extra level of nesting (the location n) is added to the process received on channel a.
In order to find a decidable characterisation of a subcalculus of Homer for which barbed bisimilarity is decidable we explore two different approaches. The first ap- proach is to use a type system which bounds the size of processes in terms of the

number of parallel components, sequential length, and nesting of locations. The resulting subcalculus of Homer is called HFC Γ. The resulting calculus is too re- strictive and does not allow for infinite reductions. Therefore a recursion operator is added to Homer. Since processes in HFC Γ cannot acquire new free names, this ensures us that there are only finitely many different α-equivalence classes reachable from any process. The second approach is to consider an encoding of the π-calculus into Homer [1,2]. We apply it to the finite control π-calculus, FC π, and consider the image of the encoding as a subcalculus of Homer, HFCπ. It is shown that the finite control property is preserved by the encoding.
HFCπ as well as HFC Γ are subcalculi of the full calculus Homer, and the finite- ness results for HFCπ and HFC Γ imply that the inclusions are strict. Moreover we show that there are HFC Γ-processes which do not have semantically equivalent counterparts in HFCπ. For the converse, there are HFCπ-processes which are not well-typed as HFC Γ-processes. However it is an open question as to whether there exists an semantically equivalent HFCπ-process which is well-typed.

Related work
The extent to which higher order communication adds to the expressiveness of the first order π-calculus has been studied in [16], where it is shown that one can encode the higher order π-calculus, HOπ, in the first order π-calculus by passing “triggers” instead of passing processes. However the encoding breaks down, when we introduce locations to the calculi. So the results for the π-calculus and HOπ are not directly applicable in our setting. In the context of calculi with hierarchical locations, the work on the calculus of Mobile Ambient [4] is related. The expressive power of different of subcalculi of Mobile Ambients have been examined in [18], [3], and [11]. In [18] the expressive power of Pure Safe Ambient Calculus is examined by giving an encoding of the synchronous π-calculus. In [3] it is examined whether restriction and ambient movement can be removed from the pure mobile ambient calculus without losing expressive power. Building upon this [11] examines the connection between operators and minimal Turing-complete fragments. In the paper it is shown that Turing completeness can be achieved merely using the movement capabilities of ambients.
Closer related to the subject of the present paper is [5]. In the paper the authors examine a finite control fragment of the ambient calculus. Similar to one of the ap- proaches examined in this paper the finite control fragment is obtained by the usage of a type system instead of, as usual, relying on syntactic restrictions. However, the Ambient Calculus cannot be considered be be higher-order in the sense that the values exchanged in communications contain processes. In the Ambient Calculus processes can move around in the location hierarchy, but they cannot be copied or discarded as part of a synchronisation, hence the communication is essential linear, as opposed to non-linear as in Homer or HOπ.
Recent work in [10] considers a minimal variant of the HOπ-calculus. Con- trary to the full HOπ-calculus this variant has asynchronous output and no name- restriction. The resulting calculus is shown to be Turing complete, hence its termi-

nation problem is undecidable. However, perhaps surprisingly, it holds that strong bisimilarity is decidable, which in turn implies that barbed congruence is decidable. It is also shown that if at least four static (i.e., top-level) restrictions are added to the calculus then strong bisimilarity becomes undecidable.

Structure of the paper
In Section 2 we present the syntax and the reduction semantics of Homer, and we define the notion of semantic finite control and give an indication of the expressiveness of calculi satisfying the semantic finite control property. In Sec- tion refsec:undec-results we prove that strong/weak barbed bisimilarity are unde- cidable. Therefore we present two fragments of Homer where barbed bisimilarity is decidable: in Section 4 we define HFC Γ using a type system, and in Section 5 we define HFCπ using an encoding of the finite control π-calculus. We compare the calculi in Section 6. Finally in Section 7 we conclude and propose future work.
The Calculus Homer
The syntax and semantics of Homer as presented by Bundgaard et. al. in [1] are given as follows. Let N be an infinite set of names and let N ∗ denote the set of all sequences of names formed by using names from N , let N + ⊂ N ∗ denote the set of non-empty sequences of names, and let n˜ range over finite sets of names. Let a, b, n, m,... range over N , γ over N ∗ and δ over N +. Let V be an infinite set of process variables ranged over by x, y, z,... . Finally let U be a set of recursion variables ranged over by X and Y . The set of Homer processes is given by the following grammar.
p ::= 0	|		rec X.p		|		p | p'		|		(n)p	|	π.p	|	x	|	X π ::= δ(x)	|	δ(x)	|	δ⟨p⟩	|	δ⟨p⟩
The primitives for the inactive process, recursion, parallel composition, and restric- tion have the same meaning as in other higher order process calculi. There are two prefixes representing a resource at a location δ, where δ is a sequence of names enabling addressing at sub-locations as described in the introduction. The active δ⟨p⟩, and the passive δ⟨p⟩ prefix. The process p can perform internal reactions in δ⟨p⟩, and the context can communicate with p; this is not the case for p in δ⟨p⟩. In Homer names are bound by restriction, (n)p, and process variables are bound by δ(x).p or δ(x).p, and recursion variables are bound as in rec X.p. For a process p the set of free and bound names and variables are defined accordingly and denoted fn(p), bn(p), fv(p) and bv(p). We will often omit trailing occurrences of 0 in e.g. δ⟨p⟩.0. We will also let ϕ range over δ and δ.
Let ≡α denote α-equivalence both with respect to names and variables. If fv(p) = ∅, then p is called a closed process. Let P denote the set of processes given by the grammar (up to α-equivalence) and let p, q, r,... range over P. Fur- thermore let Pc ⊂ P denote the set of closed processes ranged over by the same meta-variables as P. Contexts are defined as process terms with a single hole.

Definition 2.1 (Contexts) Homer contexts C and evaluation contexts E are given by the following grammars:


A recursion variable X is said to be guarded in p if its occurces are always underneath some prefix π.
Definition 2.2 (Linearity and guarded) Let p ∈ Pc. Then p is linear if for every sub-process δ(x).q or δ(x).q of p, x occurs free at most once in q. A process p is guarded if for every occurrence of rec X.p' in p, all occurrences of X in p' are guarded.
From now on we only consider guarded processes. Structural congruence is the least equivalence relation on ≡⊆ P × P which is closed under application of process contexts and which satisfies the following axioms.

p | 0 ≡ p	p | q ≡ q | p	p | (q | r) ≡ (p | q) | r (n)0 ≡ 0	(n)p | q ≡ (n)(p | q), where n ∈/ fn(q)  (n)(m)p ≡ (m)(n)p rec X.X ≡ 0  rec X.p ≡ p{rec X.p/X}
As usual we also identify processes up to α-conversion. In order to handle addressing at sublocations the reduction rules are given using so-called path indexed contexts,

C m˜ , where γ is the path to the hole, and m˜
γ
the names bound in the hole.

Definition 2.3 (Path-indexed contexts) Let p, q ∈ Pc and δ ∈ N + and γ ∈ N ∗. Then inductively deﬁne path-indexed contexts by


C ∅ d=ef (−)	C n˜m˜ def
⟨(n˜)C m˜ | p)⟩.q, where n˜ ∩ γ = ∅ .

є	δγ	= δ	γ
Vertical scope extrusion is deﬁned using an open operator on path contexts.


C ∅ \ o˜ d=ef C ∅
C n˜m˜ \
def
⟨(n˜ \ o˜)C m˜ \ o˜| p⟩.q,

є	є	δγ
o˜ = δ	γ

if C n˜m˜ = δ⟨(n˜)C m˜ | p⟩.q and (m˜ ∪ n˜) ∩ fn(C m˜n˜)= ∅ .
δγ	γ	δγ

When a resource is moved from a location it may be necessary to extend the scope of a name vertical through the location boundary using the open operator. For instance given the path context C = n⟨(m, m')n'⟨(−)⟩⟩, and for simplicity assume that all names are distinct, then we can apply the open operator on C with the argument m' (i.e. C \ m') obtaining the path context n⟨(m)n'⟨(−)⟩⟩.
Definition 2.4 (Reduction relation) The reduction relation is the least binary relation on Pc which is closed under structural congruence and evaluation contexts

and which satisﬁes the following axioms.

(Send) γδ⟨p⟩.p' | C m˜ (δ(x).q) −−−→ p' | C m˜ (q{p/x})
γ	γ
where m˜ ∩ (fn(p) ∪ δ)= ∅

(Take) C m˜ (δ⟨p⟩.p') | γδ(x).q −−−→ (m˜ ∩ n˜) (C m˜ \ n˜)(p') | q{p/x} 


In general, we allow interaction with arbitrarily deeply nested subprocesses. How- ever, note that two processes that are neither locally parallel nor in the sub/super process relation in the location hierarchy need a common super process to act as a router that mediates communication. For instance, the processes at locations n and m in the process
n⟨b⟨r⟩.q' | q''⟩| m⟨b(x).p' | p''⟩ ,
cannot communicate synchronously with each other, and need the super process at the top level to first retrieve the process r from location b inside location n and then pass the resource on to the receiving prefix inside location m. As illustrated by the following sequence of reductions.

n⟨b⟨r⟩.q' | q''⟩| nb(x).mb⟨x⟩| m⟨b(x).p' | p''⟩ −−−→

n⟨q' | q''⟩| mb⟨r⟩| m⟨b(x).p' | p''⟩ −−−→
n⟨q' | q''⟩| m⟨p'{r/x}| p''⟩ .

Note that in the (Take)-rule the names bound in the hole are vertically extruded if and only if they are actually free in p. For example in
a⟨(n)(b⟨r⟩| p)⟩| ab(y).(y | y) ,

the scope of n is extruded (through the location boundary of a) iff n is free in r, so each copy of r will share the name n. Otherwise r leaves the scope of n. A detailed discussion of this choice is presented in [9]. The rest of the side conditions in Definition 2.3 and Definition 2.4 are standard and prevent free names from being captured. Let −−−→∗ denote the transitive and reflexive closure of −−−→.
We define strong and weak barbs in the usual manner, i.e. the possibility of observing a prefix (possibly residing in the location hierarchy).
Definition 2.5 (Strong and weak barbs) Deﬁne:
p ↓o γδ if p ≡ C m˜ ((m˜ ')(δ⟨q⟩.q' | q'')), where δ ∩ (m˜ ∪ m˜ ')= ∅.
p ↓i γδ if p ≡ C m˜ ((m˜ ')(δ(x).q' | q'')), where δ ∩ (m˜ ∪ m˜ ')= ∅.

p ↓o δ if p ≡ (m˜ ')(δ⟨q⟩.q' | q''), where δ ∩ m˜ ' = ∅.
p ↓i δ if p ≡ (m˜ ')(δ(x).q' | q''), where δ ∩ m˜ ' = ∅.

We will let p ↓ ϕ range over p ↓o ϕ and p ↓i ϕ. (Recall, that we let ϕ range over δ
and δ.) Weak barbs are then deﬁned in terms of strong barbs in the usual manner.
p ⇓ ϕ if there is p' such that p −−−→∗ p' and p' ↓ ϕ.
To illustrate our notion of barbs consider the following process.

p = (n)  m⟨n'⟨q⟩| a⟨q'''⟩⟩ | (m')(n''(x).q'') | b(x').p' 

The process p has the following barbs: p ↓o m, p ↓o mn', p ↓i n'', and p ↓i b
(assuming that {n}∩ {m, n', n'', b} = ∅ and {m'}∩ {n''} = ∅).
Definition 2.6 (Strong and weak barbed bisimilarity) A binary symmetric relation R⊆ Pc × Pc is called a strong barbed bisimulation if whenever (p, q) ∈R the following holds:
If p ↓ ϕ then q ↓ ϕ
If p −−−→ p' then q −−−→ q' and (p', q') ∈ R.
Processes p and q are called strong barbed bisimilar, denoted p ∼ q, if there is a strong barbed bisimulation R such that (p, q) ∈ R.
Weak barbed bisimilarity is obtained by replacing (i) and (ii) with:
If p ↓ ϕ then q ⇓ ϕ
If p −−−→ p' then q −−−→∗ q' and (p', q') ∈ R.
Processes p and q are weakly bisimilar, denoted p ≈ q, if there is a weak bisimulation
such that (p, q) ∈ R.
For rec-free well-formed processes the following finiteness property can be proven by observing that all reductions strictly reduce the size of processes. The corre- sponding result does not hold for full Homer.
Lemma 2.7 If p is a linear process term built from the grammar without resorting to the rec X.p construction, then {p' | p −−−→∗ p'}/≡ is ﬁnite.
Strong, respectively weak, barbed bisimilarity are too coarse for many purposes, specifically in most cases only the congruence versions coincide with strong and weak bisimilarity. Indeed this is the case for Homer [9]. The coarsest bisimulation equivalence is reduction bisimilarity, ∼r. This holds since reduction bisimilarity only requires equivalent processes to match on τ -actions, whereas they, contrary to barbed bisimilarity, need not have equivalent barbs, i.e. observable actions. It is indeed necessary that ∼r is decidable for the congruences to be decidable. This is seen since decidability of reduction bisimilarity can be reduced to deciding barbed congruence, ∼c. For any processes p and q let,
p ∼r q if and only if (n˜)p ∼c (m˜ )q, where n˜ = fn(p) and m˜ = fn(q) .

Therefore, even though our decidability results only applies to the non-congruence versions, they must indeed hold in any formalism for which the congruences are

decidable. For the positive results in this paper we will use the following finite control property.
Definition 2.8 (Semantic finite control (SFC)) Let A be a process calculus and  be some decidable equivalence such that ⊆≈, ∼. Then A is called semantic finite control up to  if the set {p' | p −−−→∗ p'}/  is ﬁnite for any process p ∈ A.
Lemma 2.9 If p is SFC up to  , then the set
A = {p' | p −−−→∗ p'}/ 
is computable.
Proof. Either p terminates, or p does not terminate. By assumption A is finite. Moreover −−−→ is finitely branching up to . If p0 −−−→ p1 −−−→ ··· is an infinite reduc- tion sequence the set A can be constructed in a breadth-first manner by considering all outgoing reductions from p0, p1, etc. Moreover there must be some pj such that for some pi, i < j and pi pj. When such a pj is found, noting that  is decidable, we know that any reduction from pj must visit a previously seen state.	 
By definition p  q implies that p ∼ q and p ≈ q. Hence  is said to respect barbs
in the sense that if p  q, we have that p ↓ φ iff q ↓ φ, and similarily p ⇓ φ iff q ⇓ φ.

Lemma 2.10 If p is SFC, then p ↓ ϕ and p ⇓ ϕ are decidable.
Proof. We can decided p ↓ ϕ by inductively checking whether there are any top- level prefixes with ϕ in the subject position, or if we can decompose ϕ into an address and a prefix residing at this address, and that this ϕ is not restricted. By assumption the set,
{p' | p −−−→∗ p'}/  ,
is finite and computable by Lemma 2.9 Therefore, since  respects barbs we only need to check whether p' ↓ ϕ for finitely many p'.	 
Proposition 2.11 If A is SFC up to  , then ≈ and ∼ are decidable.
Proof. Let p and q be processes in A and related by either ≈ or ∼. From the SFC property we know that the sets,
{p' | p −−−→∗ p'}/  and {q' | q −−−→∗ q'}/  ,

are both finite. By Proposition 2.10 strong and weak barbs are decidable. Moreover both sets are computable by Lemma 2.9 so deciding reduction bisimilarity is just a matter of checking whether the two sets contains the same equivalence classes. 
As an indication of the expressiveness of SFC calculi, the next result shows that the traces of processes from calculi satisfying the SFC property are simple in structure. Below we let b range over i and o.

Definition 2.12 (Barbed Trace) Let A be a process calculus and let p ∈A be a process. α = ϕ1b1 ··· ϕkbk is a barbed trace of p ending in p' if there exists
p −−−→∗↓b1 ϕ1 −−−→−−−→∗↓b2 ϕ2 ··· −−−→−−−→∗ p' ↓b ϕk .
We let p −−−α→∗ p' denote such a reduction sequence. The set of barbed traces generated by p is denoted BTrace (p).
Lemma 2.13 (Pumping Lemma) Let A be a process calculus which is SFC up to  and assume  respects barbed traces, and let p ∈ A. Then there is a number n such that if α ∈ BTrace (p) and |α| ≥ n, then there are α1, α2, and α3 such that α = α1α2α3 and for each i ∈ N the following holds:
α1αi α3 ∈ BTrace (p)
|α2| > 0.
Proof. Let n = |{p' | p −−−→∗ p'}/ | +1 and α a barbed trace, with |α| = n' and n' ≥ n. Then there must exist a sequence of transitions visiting at least n' states. Thus by the pigeonhole principle one can now prove that some equivalence class, with respect to  , must repeat. Or more precisely, that at some point a state is reach which belongs to the same equivalence class as some previously seen
α1 ∗
state. Denote the first of occurrence of this state pj and the second pk. Then p
p −−−→−−α−→2 ∗ p  −−−→−−α−→3 ∗ p', for some p'. Then it easy to see that α αi α ∈ BTrace (p)
j	k	1 2 3
for all i ≥ 0, as we can loop via α2.	 
Corollary 2.14 Let A be a process calculus which is SFC up to  and assume that
  respects barbed traces. Then there is no p ∈A and addresses ϕ and ϕ' and b and
b' such that BTrace (p)= {(ϕb)i(ϕ'b')i | for all i ∈ N }.
In the following sections we first present some undecidability results, then we characterise SFC processes in two different ways: first using a type system which bounds the size of processes, and second using an encoding of the (finite control) π-calculus into Homer.

Undecidability Results
In [1,2] it is shown that Homer can encode the π-calculus. From that result it follows that Homer is Turing-complete. Although Turing-completeness usually implies that semantic properties of processes are undecidable, the recent paper [10] shows that undecidability of barbed congruence does not follow from the ability to encode Minsky machines in a termination preserving manner.
Definition 3.1 A ≈-property S is a set of ≈-equivalence classes. S is non-trivial
if there exists a C1 ∈S and C2 /∈ S.
Theorem 3.2 If S is a non-trivial ≈-property, then LS = {p |∃ C ∈ S. p ∈ C} is undecidable.

Proof. Reduction from the halting problem for Turing machines. Since S is non- trivial, there exist equivalence classes C1 ∈ S and C2 /∈ S. We choose a process p1 ∈ C1. Further, we assume without loss of generality that p2 ∈ C2, where
p2 = (a)(rec X.a(z).X | rec Y.a⟨0⟩.Y ) ,

is a non-terminating process.
Given a Turing machine M and an input x we can construct a Homer process pM,x whose only free name is w and such that w is only used to signal termination and such that pM,x ⇓o w iff M halts on input x. Now construct the process p0 = (w)(pM,x | w(y).p1) with y fresh for p1. Then we have that p0 ∈ C1 if M halts on x and that p0 ∈ C2 if M does not halt on x.
M halts on x: Then
Id ∪ {(p' , p1) | p0 −−−→∗ p' } ,
0	0
is a weak bisimulation up to ≡ containing the pair (p0, p1). M does not halt on x: Then
Id ∪ {(p' , p2) | p0 −−−→∗ p' } ,
0	0
is a weak bisimulation up to ≡ containing the pair (p0, p2).	 
Corollary 3.3 ≈ is undecidable.
The proof of Theorem 3.2 remains valid also for barbed congruence and even for reduction bisimilarity. Consequently Corollary 3.3 also remains true for both equivalences. The analogous result for strong barbed bisimilarity is obtained by an encoding of the λ-calculus in Homer, inspired by the encoding in Plain CHOCS [17]. Assuming that a and i /∈ fn( M )) ∪ fn( N )).

def
 x) = x
def
 λx.M ) = i(x). M )

def
 MN ) = (a)
a⟨ M )⟩| ai⟨ N )⟩.a(x).x	.


This encoding, while only being correct up to weak equivalence, is termination preserving, and moreover it takes exactly 2 reduciton-steps for the encoding to simulate a reduction in a λ-term. Therefore, for a λ-term M

(i)( M )) ∼ rec X.(a)(a | a.X) iff M diverges ,

which is a reduction from the divergence problem for the λ-calculus to the problem of checking strong barbed bisimilarity. Note that we used CCS-prefixes in the previous statement. The prefixes a and a can easily be encoded by passing the inactive process. We will throughout the remaining paper use CCS-prefixes.

The Calculus HFC Γ
In this section we present the typed subcalculus HFC Γ of Homer. The basic purpose of the type system is to ensure that the size of a typeable process is bounded under reduction, i.e. that for any well-typed process p where p −−−→∗ p' the size of p' is bounded by the size of p. Types in the type system are triples of natural numbers. In a type (d, w, s), d, w, and s are upper bounds on the depth of nested locations, width, i.e. the number of parallel processes structurally different from 0, and the sequential length of processes (in case of a recursive process it is the highest number of prefixes any recursive process will be able to pass through before a recursive call must be made).
Definition 4.1 (Types) Types are triples (d, w, s) of non-negative natural num- bers, N, ranged over by S and T.
We write (d, w, s) ≤ (d', w', s') if d ≤ d',w ≤ w', and s ≤ s'.
Definition 4.2 (Type environments) A type environment is a ﬁnite partial function Γ: N ∪ V ∪ U ‹→ N × N × N.
Type environments can be regarded as finite sets of type assignments a : T , where a ∈ N ∪V ∪U and T ∈ N×N×N and an environment is written {a1 : T1,... , an : Tn} where ai /= aj when i /= j. Type environments can be extended. This is written Γ ∪ {a : T }, and is only defined if a is not defined in Γ. Recall that we let ϕ range over δ and δ. There are two type judgement relations for HFC Γ.
Definition 4.3 The type relation for names, ▶n, is given by the following rules


(TName)
Γ ∪ {a : T } ▶n a : T

(TSeqName) Γ ▶n δ : T	Γ ▶n a : S
Γ ▶n δa : S
Definition 4.4 The type relation for processes, ▶, is given by the following rules
(TProcVar) Γ ∪ {x : T }▶ x : T

(TRecVar)	Γ ∪ {X : T }▶ X : T

(TNil)	Γ ▶ 0 : (0, 0, 0)


(TNew)
(TPar) (TTake|TIn)
Γ ∪ {n : S}▶ p : T


Γ ▶ (n)p : T
Γ ▶ p : (d, w, s)	Γ ▶ q : (d', w', s')


Γ ▶ p | q : (max{d, d'},w + w',s + s')
Γ ∪ {x : S}▶ p : (d', w', s')	Γ ▶n ϕ : T
Γ ▶ ϕ(x).p : (d', max{w', 1}, 1+ s')	, if T ≤ S



Γ ▶n ϕ : (d', w', s')	Γ ▶ p : (d', w', s')	Γ ▶ q : (d, w, s)
(TSend|TOut) Γ ▶ ϕ⟨p⟩.q : (max{d' + 1, d}, max{w', w, 1}, max{s',s + 1})

(TSub)

(TRec)
Γ ▶ p : T , if T ≤ T '
Γ ▶ p : T '
Γ ∪ {X : (d, w, 0)}▶ p : (d, w, s) Γ ▶ rec X.p : (d, w, s)

The meaning of the rules are fairly self-explanatory. The (TRec) rule enforces, through its side-conditions, that the recursion variable cannot be placed freely in p. In particular, in rec X.p, if the recursion variable occurs free in p, then there cannot be any occurrences of | in p. This is similar to the finite control condition in FC π. Moreover, the recursion variable cannot be placed inside a location either. Hence a well-typed recursive process will have the following form rec X.π1.π2   πn.X
(recalling that π ranges over prefixes).
The rules (TSend|TOut) express that a resource residing in a location should be typable with the type of the address. The rules (TTake|TIn) express that we should treat input as possibly having a larger type than the type of the address.
Together these rules enforce that we cannot type processes such as
a(x).a⟨n⟨x⟩⟩ or a(x).a⟨π.x⟩ ,
which could be used as part of counter-examples to SFC. In the following, the notation is overloaded so ▶ denotes ▶ as well as ▶n relying on the context to make it clear which one is meant.
Definition 4.5 (Well-typedness) A process p is well-typed if there is some Γ
and T such that Γ ▶ p : T.
We can prove the usual lemmas for (most) type systems: strengthening, weakening, and substitution. All the lemmas can be proven by induction in the derivation of the typing.
Lemma 4.6 (Strengthening) If Γ∪ {x : T }▶ p : S and x ∈/ fv(p), then Γ ▶ p : S.
Lemma 4.7 (Weakening) If Γ ▶ p : S then Γ ∪ {u : T }▶ p : S for any T and u
such that u /∈ dom(Γ).
Lemma 4.8 (Substitution lemma) If Γ ∪ {x : S} ▶ p : T and Γ ▶ q : S' with
S' ≤ S then it holds that Γ ▶ p{q/x} : T ' where T ' ≤ T.
Corollary 4.9 Suppose Γ ▶ C m˜ (δ(x).q) : T, Γ ▶ δ : S, and Γ ▶ p : S', where
S' ≤ S. Then Γ ▶ C m˜ (q{p/x}): T ', where T ' ≤ T.
The following results establish subject reduction for well-typed processes. First note that the type prescribed to some process need not be unique. For instance the process
rec X.n⟨0⟩.X

can be typed with the type (d, w, 1) for all d and w larger than 1, assuming that the type environment assigns (0, 0, 0) to n. And in general we can apply subsumption in any typing derivation. Second the type prescribed to a process by the type system is not stable with respect to folding and unfolding of recursive definitions. Therefore we will be interested in the least type prescribed to a process satisfying certain structural properties which we will introduce below.
Definition 4.10 (Least type) Let p be a process. If Γ ▶ p : T, then T is called the least type of p with respect to Γ if for all T ' such that Γ ▶ p : T ' it holds that T ≤ T '. We write Γ ▶μ p : T if Γ ▶ p : T where T is the least type of p with respect to Γ.
As a first step towards our normal form we first transform processes to a folded form,
i.e. we fold all recursive definitions as much as possible, and we remove unnecessary restrictions and inactive processes.
Definition 4.11 (Folding) We deﬁne the binary relation fold, written >, on pro- cess terms by the axioms

p | 0 > p	0 | p > p	(n)p > p, if n ∈/ fn(p) (n)(p | q) > (n)p | q, if n ∈/ fn(q)	(n)(p | q) > p | (n)q, if n ∈/ fn(p) p{rec X.p/X} > rec X.p, if X ∈ fv(p)
and closure under process contexts. p is said to be on folded form if p />.
Let >∗ denote the transitive closure of >. It is easy to see that any process is either on folded form, or can be brought on folded form.
Lemma 4.12 For any p either p is on folded form, or there is some p' such that
p >∗ p' and p' is on folded form.
Moreover the relation > is convergent and a sub-relation of ≡. Therefore we will often assume that processes are on folded form (or a variant of folded form) for the remaining part of this section.
By requiring that processes are on folded form we can avoid problems such as structural congruence unnecessarily unfolding recursive definitions, adding 0- processes in parallel, or adding restrictions. However it is not sufficient to consider processes on folded form as the following process illustrates
p | q, where p = rec X.b.b.X and q = rec Y.b.b.Y  .

Now p | q is on folded form, and the s-component of the least type of p and q is 2, so the s-component of the least type of p | q is 4. But the two processes can perform one reduction as follows
p | q −−−→ b. rec X.b.b.X | b. rec Y.b.b.Y  .

In the reduct the two parallel components are both on folded form, but the s- component of their least type is 6. So it seems that we need to be able to let the s-component grow under reduction. However for any process p and reduct p' of p, there is a uniform upper bound on the s-component of p' which only depends on p and which is closely related to the unfolding of recursive definitions.
We define a function, OUF (once-unfold) from processes to processes. The purpose of the function is to unfold every recursive definition exactly once. To define OUF we use an auxiliary function OUF’ from processes and sets of recursion variables to processes. OUF’ is defined as follows.
OUF’(p, ∅)= p
OUF’(0, χ)= 0
OUF’(p1 | p2, χ)= OUF’(p1, χ) | OUF’(p2, χ)
OUF’(ϕ⟨p1⟩.p2, χ)= ϕ⟨OUF’(p1, χ)⟩. OUF’(p2, χ)
OUF’(ϕ(x).p, χ)= ϕ(x). OUF’(p, χ)
OUF’((n)p, χ)= (n) OUF’(p, χ)
OUF’(rec X.p, χ)=	OUF’(p{rec X.p/X},χ \ X)	, if X ∈ χ
rec X. OUF’(p, χ)	, if X /∈ χ
Let p be a closed process. We can then make sure that all recursive definitions use distinct recursion-variables by α-converting, so assume for the rest of this document that all recursion variables are pairwise distinct. Note that as part of the unfolding of nested recursive definitions, e.g. rec X.a⟨rec Y.π.Y ⟩.X, we can obtain a process where there are two (or more) recursive definitions using the “same” recursion variable. However, this will not affect the following results. Now let Ξ denote the set of recursion variables occurring in p and let OUF(p)= OUF’(p, Ξ).
Lemma 4.13 Let p be a closed process, then there is p' such that p' = OUF(p).
Proof (Sketch). We argue that OUF’ terminates by observing that in all cases exactly one of the following holds:
the syntactical size of the remaining process decreases
the size of the set χ of remaining recursion variables decreases
the function terminates directly yielding a process.

Lemma 4.14 If p' = OUF(p), then p ≡ p'.
Proof (Sketch). By examining all the cases defining OUF’ one sees that each case yields a structurally equivalent process.	 
Recall that we have shown that all processes can be brought on folded form where all occurrences of recursion are folded as much as possible.
Definition 4.15 A process p is said to be on once-unfolded-form ( OUFF) if there is some p' such that p' is on folded form and p = OUF(p'). Whenever p = OUF(p')

for some p' on folded form we say that p is the OUFF of p'.
Definition 4.16 p is rec-guarded if every occurrence of rec X.p' in p occurs un- derneath a preﬁx. If p is not rec-guarded, then p is rec-exposed.
As stated above structural congruence does not preserve types due to the folding and unfolding of recursive definitions. Letting ≡m denote structural congruence without the two axioms for recursive definitions we have the following weaker result.
Lemma 4.17 Suppose p ≡m q then Γ ▶μ p : T if and only if Γ ▶μ q : T and p
rec-guarded if and only q rec-guarded.
The idea of subject reduction is roughly that we will only unfold recursive def- inition in a process when the definition is rec-exposed. Moreover a process p is brought on a particular form (OUFF) before initially typed ensuring that the type of p is “large” enough to capture all reducts of p. With this type system we can show that the number of different well-typed processes reachable starting from any well-typed process is finite up to ≡. We will call a reduction p −−−→ p' for consuming if the unfolding axiom was not as part of the structural congruence used in inferring the reduction.
Theorem 4.18 (Subject reduction) Suppose that p is rec-guarded and Γ ▶μ p : T, then for all p' with p −−−→ p', where −−−→ is consuming, we have Γ ▶μ p' : T ' for some T ' such that T ' ≤ T.
For readability we have placed the proof of this theorem in the appendix.
Corollary 4.19 Let p be on OUFF and suppose Γ ▶μ p : T then for all p' on folded form where p −−−→∗ p' it holds that Γ ▶μ p' : T.
Proof (Sketch). The idea behind the proof is to analyze how much the sequential coordinate of a type can change as the result of a series of reductions (note that both the depth and the width coordinate can only decrease); some additional bookkeeping (but essentially the same line of reasoning) is needed, if reductions happen within a location. Since we only consider process up to structural congruence in the following results we can consider a reduction sequence such as
p = p0 −−−→ p1 −−−→ ... −−−→ pk ...	(1)
where p0 is on OUFF and hence rec-guarded, and Γ ▶μ p0 : (d, w, s). For each pi, 0 ≤ i ≤ k we can apply Theorem 4.18 to get an upper bound on the type. Now suppose pk is the first successor of p0 that fails to be rec-guarded. pk must have arisen as the result of a series of communications that have left the subprocesses in
the set E = {q1,... , qj} rec-exposed. By the proof of Theorem 4.18 any process qi ∈
E must have a type (di, wi, si) where si < s. Moreover, the sum Σj	si ≤ s − 2k,
since all qi’s have contributed with a total of at least 2k prefixes to the reduction
sequence. Let p' be the OUFF of pk which we basically obtain by applying OUF

on all processes in E. However, this can only increase the s-component of p'
by 2k

(since it took k steps to get from an OUFF to a rec-exposed form). Finally note that for any well-typed process its folded form has a smaller type.	 
Lemma 4.20 Let p −−−→∗ p'. Then fn(p') ⊆ fn(p).
Proposition 4.21 Let n˜ ⊂N be a ﬁnite set of names. Then for all types T ', there are only ﬁnitely many α-inequivalent processes p such that
p is on folded form
Γ ▶μ p : T, where T ≤ T '
fn(p) ∪ bn(p) ⊆ n˜
Proposition 4.22 The set of reachable conﬁgurations is ﬁnite, i.e.
|{p' | Γ ▶μ p : T, and p −−−→∗ p'}|/≡ < ∞ .

Proposition 4.22 says that for a well-typed process there are only finitely many reachable processes up to ≡.
Lemma 4.23 Assume Γ ▶μ p : T. Then p ↓ ϕ and p ⇓ ϕ are decidable.
We will write HFC Γ for the subcalculus of Homer consisting of all well-typed processes.
Theorem 4.24 Strong and weak barbed bisimilarity are decidable for HFC Γ.
We now show that within the current setting the types bounding the depth, width, and length of prefix sequences are all necessary to obtain finite control. In
the following let HFC −d, HFC −w, and HFC −s denote subcalculi of Homer defined in
Γ	Γ	Γ
the same way as HFC Γ, but with the type-system slightly modified by removing the
i’th component of the types and adapting the rules accordingly. The corresponding typing judgements are Γ−d ▶μ p, Γ−w ▶μ p, and Γ−s ▶μ p respectively.
Proposition 4.25 Strong/weak barbed bisimilarity are undecidable for HFC −d.
Proof. The proposition is proven by showing that HFC −d can encode Minsky ma- chines [14] in a deterministic and termination preserving manner. A Minsky machine consists of a list of instructions {L1,... Lk} (indexed by i) where the instructions operates on two counters c1 and c2. Each instruction Li is either Inc(cj, n), which in- crements the value of counter cj and jumps to the next instruction n, or Dec(cj, n, m) which jumps to instruction n if cj = 0, otherwise the counter cj is decremented by 1 followed by a jump to instruction m. A program counter (PC) keeps track of the current executing instruction. Execution starts with the first instruction and halts if the PC gets assigned a value outside the range 1,... , k. The semantics of a Minsky machine is a transition system over configurations (i, c1, c2), where i is the PC and ci, the values of the counters. The transition system is generated by the

following rules (letting 1=2 and 2= 1).
Li = Inc(cj, n)	c' = cj +1	c'  = c

(Inc:)
j	j	j
(i, c ,c ) −−−→ (n, c' , c' )

1  2	1  2

(Dec-1:)
Li = Dec(cj, n, m)	cj =0 (i, c1, c2) −−−→ (n, c1, c2)
Li = Dec(cj, n, m)	cj /=0	c' = cj − 1	c'  = c


(Dec-2:)
j	j	j
(i, c ,c ) −−−→ (m, c' , c' )

1  2	1  2
In the following we write a⟨0⟩.0 as a. Numbers are encoded as  0) = z and
 n + 1) = n⟨ n)⟩. In the encoding we use two persistent register locations, r1 and r2 from which the values of the counters c1 and c2 are read and saved. The encoding of persistent locations is described in more detail in [9]. Instructions are encoded as recursive processes as follows (below we assume that we are encoding the instruction indexed by m).
 Inc(ci, n)) = rec X.lm.ri(x).ri⟨n⟨x⟩⟩.l' .X .
The encoding of an instruction is guarded (the CCS prefix lm above) to ensure that we only can execute the instruction if it has been activated. For the encoding of Inc(ci, n) we first read the content of location ri and then place this content inside a location n in ri. Finally, we activate the instruction indexed by n through the forwarder process defined below.
For the encoding of Dec(ci, n, m) we split the encoding into several parts.

Get(ci)	= rec Y.lm.ri(x).a⟨x⟩.b.Y

Zero(n)	= rec X'.az(y).ri⟨z⟩.b.l' .X'

NonZero(m) = rec Y '.an(y).ri⟨y⟩.b.l'  .Y '
Now the encoding of the if-then-else instruction is given as follows
 Dec(ci, n, m)) = (a, b)(Get(ci) | Zero(n) | NonZero(m)) .

Again we guard the encoding of the instruction. For the encoding of Dec(ci, n, m) we read the content of the location ri and place the content in the local location
a. Now either Zero or NonZero can synchronise with the content inside a using the address az or an respectively (depending on whether the encoded number inside a is zero or non-zero). If the number was zero we place zero inside ri, signal the Get-process using b, and activate the instruction indexed by n. If the number was non-zero we place the content of the outermost n-location, thus decrementing the number by one, inside ri, signal the Get-process using b, and activate the instruction indexed by m.
Finally, we need one “forwarder” process for each instruction, to be able to represent instructions that loop, e.g. (i, c1, c2) −−−→ (i, c' , c' ), hence in the encoding
1  2

the instruction indexed by i should be able to activate the instruction indexed by
i. We obtain this by using a forwarder process defined as follows.

Fi = rec Y.l'.li.Y .
The full encoding is defined by encoding the instructions in parallel with the en- coding of the counters.



where m˜
(m˜ ) ( L1) | ... |  Lk) | F1 | ... | Fk | r1⟨ c1)⟩.R1 | r2⟨ c2)⟩.R2) ,
= {l1,... , lk, l' ,... , l' , r1, r2, n, z} and Ri = rec X.ri(x).ri⟨x⟩.X. To rep-

1	k

resent the PC (in instruction i) we just replace Fi with li.Fi, so that we are ready
to activate the process representing the instruction indexed by 1. Letting L denote the list of instructions {L1,... Lk} we write this encoding of the Minsky machine in instruction i and with counters c1 and c2 as follows (L, i, c1, c2)). We now state the close operational correspondence.
Lemma 4.26 For a Minsky machine with instructions L if (i, c1, c2) −−−→ (j, c' , c' ),
1  2
then we have  (L, i, c1, c2)) −−−→k  (L, j, c' , c' )), where k is either 4 or 6.
1  2
Lemma 4.27 For a Minsky machine with instructions L.
If  (L, i, c1, c2)) −−−→4 c and the instruction indexed by i is an Inc then c =
 (L, j, c' , c' )) for some j, c' , and c' and we have the reduction (i, c1, c2) −−−→
1  2	1	2
(j, c' , c' ).
1  2
If  (L, i, c1, c2)) −−−→6 c and the instruction indexed by i is a Dec then c =
 (L, j, c' , c' )) for some j, c' , and c' and we have the reduction (i, c1, c2) −−−→
1  2	1	2
(j, c' , c' ).
1  2

In a similar manner we can prove that strong and weak barbed bisimilarity are undecidable for HFC −s by encoding numbers using sequencing instead of nesting of locations. Hence we represent the number 2 by n.n.z in the encoding instead of n⟨n⟨z⟩⟩, and we change the encodings of Inc and Dec accordingly to handle this change in representation.
Proposition 4.28 Strong/weak barbed bisimilarity are undecidable for HFC −s.
For HFC −w we have the weaker result.
Proposition 4.29 The calculus HFC −w is not ﬁnite control.
Proof. We prove the statement by providing a counter-example.
a⟨(n)n⟨0⟩⟩ | rec X.a(x).a⟨x⟩.X | rec Y.a(x).a⟨n⟨0⟩| x⟩.Y  ,

which places an n⟨0⟩ process in parallel for each iteration of the two recursive definitions.	 

Recalling the comments in Section 2, Theorem 4.24 is, in our setting, an upper bound on the expressivity of a calculus for which strong and weak barbed congru- ence can be decidable. We believe that strong and weak barbed bisimilarity are also undecidable for HFC −w, but we have not been able to improve the result in
Proposition 4.29.
The Calculus HFC π
Contrast to Homer, the π-calculus is a first order calculus without a primitive notion of locations. The syntax and main reduction rule is reminiscent of Homer. However, whereas processes are passed over named channels in Homer, only names can be passed in the π-calculus. We briefly present the π-calculus and recommend [16,13] for details.
P ::= 0	|	P | Q	|	(νn)P	|	rec X.P	|	X	|	n⟨m⟩.P	|	n(m).P
The finite control segment is obtained by imposing the following simple restrictions on the recursion operator, rec X.P . First, all occurrences of X in P must occur under a prefix, n⟨m⟩ or n(m). Second, there should be no parallel compositions in P . These two conditions are sufficient for obtaining finite control in the π- calculus [6]. Process contexts and evaluation contexts are defined as usual.
Definition 5.1 π-calculus contexts Cπ and evaluation contexts Eπ are given by the following grammars:

Structural congruence ≡π is obtained in the usual manner, i.e. as the smallest congruence satisfying the following axioms.
P | 0 ≡π P   P | Q ≡π Q | P	P | (Q | R) ≡π (P | Q) | R
(νn)0 ≡π 0	(νn)P | Q ≡π (νn)(P | Q), where n ∈/ fn(Q) (n)(m)P ≡ (m)(n)P rec X.X ≡ 0 rec X.P ≡ P {rec X.P/X}
The semantics of the finite control π-calculus is given as the least binary relation
−−−→π over π-calculus terms closed under evaluation contexts and ≡π and satisfying the following axiom
(React) n(m).P | n⟨m'⟩.Q −−−→π P {m'/m}| Q .

Next follows a brief account of the encoding of the π-calculus in Homer from [2] applied to FC π. The full encoding,  ·)2, is defined in terms of an encoding of names,
 ·), and an encoding of processes,  ·)1. A π-calculus name n is encoded as a mobile

resource  n) that performs two tasks; sending and receiving.
Sendn d=ef v(x).c(y).n⟨x⟩.y
Receiven d=ef c(x).n(y).(a) a⟨x⟩| ab⟨y⟩.a(z).z
 n) d=ef s⟨Sendn⟩| r⟨Receiven⟩
Sendn expects the encoding of the name to be communicated on v, and the contin- uation of the prefix on c. Receiven expects the encoding of the continuation and is then ready to synchronise with the resulting Sendn prefix. The significant cases of the encoding are input, output, and restriction.

 n⟨m⟩
def	⟨n'⟩| asv⟨m'⟩.asc⟨ P ) ⟩.as(z).a(z').z 

def	'	'
def	'

Note that the names n' and m' are free process variables which will be replaced by
 n) and m) on top-level in the encoding. The encoding of n⟨m⟩.P sends m) to the Sendn process followed by the encoding of P . The Sendn-process is now located in a and ready to send m) on n after which it becomes P )1. This Sendn process is now fetched from a and placed on top-level ready to communicate with Receiven. The encoding of an input n(x).P sends the encoding of the continuation prefixed with an input on which it can receive the m) which was sent by Sendn. The actual π-calculus communication can now be executed before the result is finally fetched from a and placed at the top level. The a(z') in both encodings garbage collects the unused part of the encoding of a name. It is assumed that there is a one-to- one mapping between π-calculus names n and process variables n'. The encoding is homomorphic on 0, | , and rec X.P . The full encoding of a π-calculus process P with

free names n1,... , nm is P ) d=ef P ) { n1) /n' ,... nm) /n'
}, where n' ,... n'
are

2	1	1
names in bijection with n1,... , nm.
m	1	m

Example 5.2 The encoding of P = n⟨m⟩| n(x).x⟨x⟩ −−−→π m⟨m⟩.
 P )2 =  (a) a⟨n'⟩| asv⟨m'⟩.asv⟨ 0)1⟩.as(z).a(z').z  |
(a) a⟨n'⟩| arc⟨b(x). x⟨x⟩)1⟩.ar(z).a(z').z	{ n) /n', m) /m'}
= (a) a⟨ n)⟩| asv⟨ m)⟩.asv⟨ 0) ⟩.as(z).a(z').z  |
(a) a⟨ n)⟩| arc⟨b(x). x⟨x⟩)1⟩.ar(z).a(z').z
Thus we have the reductions

 P )  −−−→∗n⟨ m)⟩| n(y).(a) a⟨b(x). x⟨x⟩) ⟩| ab⟨y⟩.a(z).z
−−−→∗(a) a⟨b(x). x⟨x⟩)1⟩| ab⟨ m)⟩.a(z).z
−−−→∗ x⟨x⟩)1 { m) /x} = m⟨m⟩)2

The following lemmas are direct consequences of the results in [2] for arbitrary,
i.e. not finite control π-calculus processes.
Theorem 5.3 (Dynamic correspondence [2]) P −−−→π P ' iff  P )2 −−−→10 P ')2.
Thus if there are only finitely many reducts in the π-calculus, this must be reflected in the encoded process.

Corollary 5.4 |{P ' | P −−−→∗
P '}| < ∞ implies |{ P '')2
|  P )2
−−−→∗ P '')2}|/≡ <

∞.
The next proposition generalises the preceding lemma to arbitrary reductions in the encoded process.
Proposition 5.5 |{P ' | P −−−→∗ P '}| < ∞ implies |{c | P ) −−−→∗ c}|/≡ < ∞.
π	2
Let HFCπ denote the subset of Homer-processes obtained as the taking the encoding of all FC π processes together with their reducts.
Lemma 5.6 If p is a HFCπ-process. Then p ↓ ϕ and p ⇓ ϕ are decidable.
Theorem 5.7 Strong and weak barbed bisimilarity are decidable for HFCπ.
Although Theorem 4.24 and Theorem 5.7 only gives us SFC up to ≡, stronger statements can be obtained by using the labelled transition semantics without ≡ instead [7].

Comparing Homer, HFC Γ, and HFC π
In this section we show that Homer, HFC Γ, and HFCπ are different calculi with respect to weak bisimilarity. Let A, B ∈ {Homer, HFC Γ, HFC π}. We compare the calculi according to the following criteria.
A € B if for all p ∈ A there exists q ∈ B such that p ≈ q
A ≈ B if A € B and B € A.	A /≈ B if A /€ B and B /€ A .
First we show that both HFC Γ and HFCπ are strictly contained in Homer.
Proposition 6.1 (i) HFC Γ € Homer and (ii) Homer /€ HFC Γ
Proof. (i) holds since any HFC Γ process is also a Homer-process. (ii) holds since one can easily construct a Homer-process which has an infinite sequence of reduc- tions going through mutually non-equivalent states. This is not possible in HFC Γ due to Proposition 4.22.	 
In a similar manner we get.
Proposition 6.2 (i) HFCπ € Homer and (ii) Homer /€ HFCπ




Fig. 1. Relationship between Homer, FCHomer, HFC Γ, and HFC π.
We have that the question of membership in HFC Γ is decidable (i.e. type check- ing is decidable). At the moment we have not been able to prove a similar result for HFCπ.
Proposition 6.3 Let p ∈ Homer. Then the question of whether p ∈ HFC Γ is decidable.
We have yet to fully explore the relationship between HFC Γ and HFCπ, but the following is presently known.
Proposition 6.4 We have HFC Γ /€ HFCπ.
Proof. Take any process p in HFC Γ with a barb whose length is strictly greater than 3, i.e. a⟨b⟨c⟨d⟨0⟩⟩⟩⟩ having the barb abcd. Such p cannot be equivalent to any process in HFCπ since the nesting depth of any HFCπ-process is at most 3. 
Letting FCHomer denote the full subcalculus of Homer where barbed bisimilarity is decidable we depict the calculi and inclusions with respect to ≈ in Figure 1. In Figure 1 the inclusion of HFC Γ and HFCπ in Homer are strict with respect to ≈. Moreover we conjecture that that HFCπ /€ HFC Γ. Obviously HFC Γ and HFCπ have a non-empty intersection since e.g. the 0-process is typeable as well as the encoding of 0. For the same reason we note that HFC Γ and HFCπ are not closed with respect to ≈, as there are processes which are deadlocked but not typeable or in the encoding.

Conclusion
This paper deals with decidability of barbed bisimilarity in a higher order process calculus with locations called Homer. Since Homer is Turing-complete most seman- tic properties are undecidable. In particular barbs and hence barbed bisimilarity. The problem of decidability of barbed bisimilarity seems much more complicated than for CCS, the π-calculus, and Mobile Ambients.

These negative results lead us to pursue characterisations of subcalculi of Homer where bisimilarity is decidable. To fix a point of reference we defined semantic finite control up to a decidable relation . Semantic finite control then implies decidability of any relation containing . In this paper we provide two different characterisations. One characterisation is obtained by using a type system which bounds the size of processes. The typed calculus is a subcalculus of Homer which is semantic finite control. The other characterisation draws on results from the finite control π-calculus and a relatively recent published encoding of the π-calculus into Homer. Combining these results we again obtain a subcalculus of Homer which is semantic finite control.
In regards to future work the most pressing issue is whether our results extends to congruences. In Homer, early context bisimilarity characterises barbed congru- ence. We have not, so far, succeeded in extending the present results to barbed congruence, or equivalently early context bisimilarity. The reason for this is that in the presence of higher order communication the early (labelled) context bisimilar- ity relation does not get rid of the universal quantification over contexts. However recent work in [10] shows that in a certain case it is possible to derive a quantifi- cation free characterisation of barbed congruence. Whether the same approach is applicable in our setting would be interesting to examine.
We have shown that HFC Γ /€ HFCπ and that Homer is strictly more expressive than both of these calculi. It is also clear that at the syntactic level, there are processes in HFCπ which are not in HFC Γ and vice versa. E.g. there are processes in HFCπ (i.e. processes which are in the image of the encoding of the finite control π-calculus) which cannot be typed with the type system presented in this paper. Conversely, there are well-typed processes in HFC Γ which are not under the image of the encoding.
We conjecture that HFCπ /€ HFC Γ. However we note that if the conjecture does not holds, then it is indeed possible that HFCπ could be embedded in HFC Γ. Thus showing that despite the rather strict conditions imposed by the type-system, HFC Γ would be at least as expressive as the finite control π-calculus. We would like to investigate more about the expressive power of HFC Γ and HFCπ. In particular it will be interesting to examine whether some of the abstract approaches outlined in [8] are applicable in our setting. Finally, note that HFCπ is at least as expressive as the finite control π-calculus.
Also of interest is to find some more general notion of what decidable procedures could characterise semantic finite control. A natural extension of such work would then be to study the relationship between various notions of semantic finite control. Finally, we would like to relax the type system for HFC Γ. Currently the type system is quite strict, and it would be interesting to examine weaker variants of the type system which would allow us to type a larger class of processes, hopefully the
entire subcalculus HFCπ.

References
Bundgaard, M., T. Hildebrandt and J. C. Godskesen, A CPS encoding of name-passing in higher-order mobile embedded resources, Theoretical Computer Science 356 (2006), pp. 422–439.
Bundgaard, M., T. Hildebrandt and J. C. Godskesen, On encoding the π-calculus in higher-order calculi, Technical Report TR-2008-106, IT University of Copenhagen (2008).
Busi, N. and G. Zavattaro, On the expressive power of movement and restriction in pure mobile ambients, Theoretical Computer Science 322 (2004), pp. 477–515.
Cardelli, L. and A. D. Gordon, Mobile ambients, Theoretical Computer Science 240 (2000), pp. 177– 213.
Charatonik, W., A. D. Gordon and J.-M. Talbot, Finite-control mobile ambients, in: Proceedings of the 11th European Symposium on Programming (ESOP’02), Lecture Notes in Computer Science 2305 (2002), pp. 295–313.
Dam, M., On the decidability of process equivalences for the π-calculus, Theoretical Computer Science
183 (1997), pp. 215–228.
Godskesen, J. C. and T. Hildebrandt, Extending Howe’s method to early bisimulations for typed mobile embedded resources with local names, in: Proceedings of the 25th Conference on the Foundations of Software Technology and Theoretical Computer Science (FSTTCS’05), Lecture Notes in Computer Science 3821 (2005), pp. 140–151.
Gorla, D., Towards a unified approach to encodability and separation results for process calculi, in: Proceedings of the 19th International Conference on Concurrency Theory (CONCUR’08), Lecture Notes in Computer Science 5201 (2008), pp. 492–507.
Hildebrandt, T., J. C. Godskesen and M. Bundgaard, Bisimulation congruences for Homer — a calculus of higher order mobile embedded resources, Technical Report TR-2004-52, IT University of Copenhagen (2004).
Lanese, I., J. A. P´erez, D. Sangiorgi and A. Schmitt, On the expressiveness and decidability of higher- order process calculi, in: Proceedings of the 23th Annual IEEE Symposium on Logic in Computer Science (LICS’08) (2008), pp. 145–155.
Maffeis, S. and I. Phillips, On the computational strength of pure ambient calculi, Theoretical Computer Science 330 (2005), pp. 501–551.
Milner, R., “A Calculus of Communicating Systems,” Lecture Notes in Computer Science 92, Springer Verlag, 1980.
Milner, R., “Communicating and Mobile Systems: the π-calculus,” Cambridge University Press, 1999.
Minsky, M., “Computation: Finite and infinite machines,” Prentice-Hall, 1967.
Sangiorgi, D., “Expressing Mobility in Process Algebras: First-Order and Higher-Order Paradigms,” Ph.D. thesis, University of Edinburgh, Dept. of Computer Science (1993).
Sangiorgi, D. and D. Walker, “The π-Calculus: a Theory of Mobile Processes,” Cambridge University Press, 2001.
Thomsen, B., Plain CHOCS: A second generation calculus for higher order processes, Acta Informatica
30 (1993), pp. 1–59.
Zimmer, P., On the expressiveness of pure safe ambients, Mathematical Structures in Computer Science
13 (2004), pp. 721–770.

A	Appendix
Proof of Theorem 4.18 (Subject Reduction). Induction in height of the derivation of p −−−→ p'.
(Send): We have
γδ⟨p⟩.p' | C m˜ (δ(x).q) −−−→ p' | C m˜ (q{p/x}) ,
γ	γ
where m˜ ∩ (fn(p) ∪ δ)= ∅. This sub-case is proven by induction in the length of the path γ in C m˜ .

Assume C m˜ = (−). To carry out the proof of this case we perform a relatively tedious analysis of the
typing of δ⟨p⟩.p' | δ(x).q where the goal is to show that the type of p' | q{p/x} is smaller than the type of the former process. The derivation bottom up starts with some applications of the (TSub)-rule followed by the (TPar)-rule. In general the (TSub)-rule could be applied anywhere in the derivation, as the rule is not syntax-directed. For simplicity we tacitly ignore the (TSub)-rule in this presentation of the proof, as the rule does not change the overall structure of the proof, and in some cases actually makes the proof easier.
So we have
Γ ▶μ δ⟨p⟩.p' : (k1 , k1 , k1 )	Γ ▶μ δ(x).q : (l1 , l1 , l1 )

1	2	3
'
1	2	3
(A.1)

Γ ▶μ δ⟨p⟩.p | δ(x).q : (n1, n2, n3)
with the following equations
n1 = max{k11 , l11 }	n2 = k12 + l12	n3 = k13 + l13 .	(A.2)
The typing of the left premise of Inference (A.1) is
Γ ▶μ δ : (k2 , k2 , k2 )	Γ ▶μ p : (k2 , k2 , k2 )	Γ ▶μ p' : (k3 , k3 , k3 )

1	2	3
1	2	3
'
1	2	3
(A.3)

Γ ▶μ δ⟨p⟩.p : (k11 , k12 , k13 )
with the equations
k11 = max{k21 + 1, k31 }  k12 = max{k22 , k32 , 1}  k13 = max{k23 , k33 + 1} .	(A.4)

The typing of the right premise of Inference (A.1) is
Γ,x : (l2 , l2 , l2 ) ▶μ q : (l3 , l3 , l3 )	Γ ▶μ δ : (l'


, l'


, l' )

1	2	3
1	2	3
21 22 23
(A.5)

Γ ▶μ δ(x).q : (l11 , l12 , l13 )

with equations

l11 = l31	l12 = max{l32 , 1}	l13 = l33 +1 .	(A.6)

From Inference (A.3) and Inference (A.5) we get the equations
k21 ≤ l21	k22 ≤ l22	k23 ≤ l23 .
Thus we can apply the substitution Lemma 4.8 to infer
Γ ▶μ q{p/x} : (m11 , m12 , m13 ) ,	(A.7) where m1 ≤ l3 for i ∈ {1, 2, 3}. Combining with the inference of p' in Inference (A.3) we obtain
Γ ▶μ p' | q{p/x} : (m2 , m2 , m2 ) ,

where

m21 = max{k31 , m11 }	m22 = k32 + m12	m23 = k33 + m13 .	(A.8)

Now the only thing left is to show that this type is less than the type of the original process. We know that k3i ≤ k1i from Equation (A.4) and m1i ≤ l3i from Equation (A.7) for i ∈ {1, 2, 3}. Hence the result follows from Equation (A.2) and Equation (A.8).
Proceeding with the inductive step, assume γ = δ'γ' for some non-empty sequence of names δ' and a possibly empty sequence of names γ', and m˜ = n˜n˜' for some names n˜ and n˜' such that
C m˜ = C n˜n˜' = δ'⟨(n˜)C n˜' | q ⟩.q .

γ	δ' γ'
γ'	2  3

As in the base-case we carry out an analysis of the typing of the process

Γ ▶ γδ⟨p⟩.p' : (k

,k  ,k 

)	Γ ▶

δ'⟨(n˜)C n˜' (δ(x).q) | q ⟩.q

: (l

,l  ,l  )

μ	11
12  13
'  '
μ	γ'
n˜'
2  3	11 12 13
(A.9)

Γ ▶μ γδ⟨p⟩.p | δ ⟨(n˜)C ' (δ(x).q) | q2⟩.q3 : (n1, n2, n3)

where
n1 = max{k11 , l11 }	n2 = k12 + l12	n3 = k13 + l13 .	(A.10)

The proof of the left premise of Inference (A.9) is
Γ ▶μ γδ : (k2 , k2 , k2 )	Γ ▶μ p : (k2 , k2 , k2 )	Γ ▶μ p' : (k3 , k3 , k3 )

1	2	3
1	2	3
'
1	2	3
(A.11)

Γ ▶μ γδ⟨p⟩.p : (k11 , k12 , k13 )



where
k11 = max{k21 + 1, k31 }  k12 = max{k22 , k32 , 1}  k13 = max{k23 , k33 + 1} .	(A.12)

By Corollary 4.9 the right premise of Inference (A.9) yields


Γ ▶ δ'⟨(n˜)C n˜' (q{p/x}) | q ⟩.q

'	'	'
: (l

(A.13)

μ	γ'
2  3	11 , l12 , l13 ) ,


where l'
≤ l1i
for i ∈ {1, 2, 3}. Thus by Inference (A.11) we get


Γ ▶ p' : (k

,k  ,k 


'
)	Γ ▶ δ'⟨C n˜ (q{p/x}) | q ⟩.q

: (l'
, l' , l' )

μ	31
32  33
'  '
μ	γ'
n˜'
2  3	11
'	'	'
12 13
(A.14)

Γ ▶μ p | δ ⟨C ' (q{p/x}) | q2⟩.q3 : (m1 , m2 , m3 )

where
'	'	'	'	'	'

m1 = max{k31 , l11 }	m2 = k32 + l12	m3 = k33 + l13 .	(A.15)

Now by Equation (A.12) we have k3i
≤ k1i
and by Inference A.13 we know that l'
≤ l1i
for i ∈ {1, 2, 3},

thus by Equation (A.10) and Equation (A.15) we have as needed m' ≤ ni for i ∈ {1, 2, 3}. The (Take)-rule is handled in a similar manner, except that we need to handle the open operator for scope extension.
If the reduction was derived by closure under structural congruence (without using the unfolding ax- ioms), i.e. we have
p ≡m q −−−→ q' ≡m p'
p −−−→ p'	.
From Γ ▶μ p : T and p rec-guarded and using Lemma 4.17 we know that Γ ▶μ q : T and q rec-guarded. By the induction hypothesis we have that Γ ▶μ q' : S for some S such that S ≤ T and again by Lemma 4.17 we have that Γ ▶μ p' : S as needed.
Finally we consider the case where the reduction is closed under evaluation contexts. But in all the
cases the result follows directly by the induction hypothesis.	 
