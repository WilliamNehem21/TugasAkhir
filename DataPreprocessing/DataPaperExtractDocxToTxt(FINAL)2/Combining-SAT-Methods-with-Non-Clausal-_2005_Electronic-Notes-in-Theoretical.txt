Electronic Notes in Theoretical Computer Science 125 (2005) 3–12	
www.elsevier.com/locate/entcs


Combining SAT Methods with Non-Clausal Decision Heuristics 1
Clark Barrett 2
New York University

Jacob Donham 3

Abstract
A decision procedure for arbitrary first-order formulas can be viewed as combining a propositional search with a decision procedure for conjunctions of first-order literals, so Boolean SAT methods can be used for the propositional search in order to improve the performance of the overall decision procedure. We show how to combine some Boolean SAT methods with non-clausal heuristics developed for first-order decision procedures. The combination of methods leads to a smaller number of decisions than either method alone.
Keywords: satisfiability modulo theories, Boolean satisfiability, non-clausal, decision heuristics, CVC Lite


Introduction
Decision procedures for domain-specific first-order theories and combinations of such theories are useful in applications such as hardware verification, trans- lation validation, extended static checking, and proof-carrying code. These first-order decision procedures are based on core algorithms that decide the satisfiability of a conjunction of literals. In order to decide arbitrary formulas,

1 This research was supported by a grant from Intel Corporation. The content of this paper does not necessarily reflect the position or the policy of Intel.
2 Email: barrett@cs.nyu.edu
3 Email: jake@bitmechanic.com



1571-0661 © 2005 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2004.09.042


we must layer a propositional satisfiability procedure on top of the first-order procedure.
We can view the overall process as follows: Form a propositional abstraction of the formula by replacing each distinct atomic formula with a Boolean vari- able; find a variable assignment which satisfies the propositional abstraction; convert the assignment to a conjunction of first-order literals by replacing each Boolean variable assigned true or false with the corresponding atomic formula or its negation, respectively; finally, check that the conjunction of literals is satisfiable using the first-order decision procedure.
For large formulas with significant Boolean structure, the size of the propo- sitional search tree dominates the overall performance, so heuristics and clever search algorithms for SAT are important. We can combine SAT methods with non-clausal heuristics developed for first-order decision procedures to obtain a method which takes fewer decisions to decide a formula than either one by itself. Section 2 reviews existing methods for propositional satisfiability and describes some non-clausal search heuristics. Section 3 describes our imple- mentation combining these methods, and Section 4 gives quantitative results obtained using CVC Lite [2], a proof-producing decision procedure for a com- bination of theories without quantifiers.

Efficient SAT Algorithms
The essence of the standard Davis-Putnam-Logemann-Loveland (DPLL) al- gorithm for SAT [5,6] is shown in in Figure 1. It explores the space of partial variable assignments depth-first and checks each one to see if it satisfies the formula. The variable φ represents the formula under consideration, and ∆ represents the partial assignment so far. If φ simplifies to T under ∆ then
∆ is a satisfying assignment. If φ simplifies to ⊥ then ∆ is an unsatisfying assignment. If φ simplifies to neither T nor ⊥, then the algorithm chooses an unassigned variable (a splitter ; such a choice is a decision), and then calls checkSat on the simplified formula along with ∆ augmented first with the split-
ter assigned to T and then to ⊥. The algorithm incrementally builds a partial assignment until the assignment satisfies the formula or exhausts the tree of possible assignments.
Many modern SAT solvers like GRASP [11] and Chaff [12] are based on re- finements of the basic DPLL algorithm. The two most important refinements are Boolean constraint propagation and conflict clauses.
Boolean constraint propagation (BCP) takes advantage of the fact that for a formula in conjunctive normal form (CNF), every clause must be satisfied by a satisfying assignment. So if there are n literals in a clause and n— 1 of them


checkSat(∆, φ)
φ' = simplify(∆, φ);
if (φ' ∈ (T, ⊥)) return φ'; α = findSplitter(φ');
if (checkSat(∆ ∪ {α = T}, φ') == T) return T; if (checkSat(∆ ∪ {α = ⊥}, φ') == T) return T; return ⊥;

Fig. 1. Propositional DPLL algorithm

evaluate to ⊥ under the current partial assignment (such clauses are called unit clauses), then the nth must evaluate to T in order to satisfy the clause. By propagating Boolean constraints until there are no more unit clauses the algorithm may deduce the values of many variables and avoid having to split on them.
If we find the formula to be unsatisfiable under a particular assignment ∆, then there is a minimal set δ ⊆ ∆ which makes the formula unsatisfiable. If the algorithm later generates a ∆' such that δ ⊆ ∆' then it can immediately determine that the formula is unsatisfiable under ∆' and save some work. A
conflict clause asserts that at least one assignment in δ is false. For example,
if δ = {a = T,b = ⊥,c = T} then the conflict clause is (чa V b V чc). When φ simplifies to ⊥ under some ∆, we find a minimal conflict set δ by tracing the implication graph describing how each variable got its value—whether directly from an assignment or through a chain of propagations from some set
of assignments—and add a conflict clause derived from δ to φ. Then if a ∆' is generated such that δ ⊆ ∆', BCP on the conflict clause cuts off the search tree immediately.
In the first-order version of DPLL, we replace variable assignments with first-order assumptions. Propositionally satisfying assignments are checked by submitting the conjunction of first-order literals induced by a propositional assignment to the first-order decision procedure. If the first-order decision procedure is online (like CVC Lite is) then first-order literals can be submitted as the partial assignment is built, rather than when the algorithm finds a propositionally satisfying assignment. The algorithm may then discover much earlier that a partial assignment does not first-order satisfy the formula.
In the first-order version of conflict clauses, the cause of a conflict can be richer than a simple implication graph over propositional variables. CVC Lite is a proof-producing decision procedure; it can generate a proof object giving justification of its conclusion [1]. So when φ simplifies to ⊥ under ∆, CVC Lite produces a proof of that fact, and the assumptions that are used in the proof comprise exactly the subset of ∆ that contributes to the conflict.
Other systems which use conflict clauses generated from first order decision procedures include CVC, ICS, and Verifun. CVC [4,13] (the predecessor to


CVC Lite) uses the same strategy of generating conflict clauses based on proof assumptions. The ICS decision procedure [7] does an optimized trial-and-error elimination of irrelevant literals in a clause rather than tracking dependencies on assumptions. Verifun [8] takes an intermediate approach: it cannot produce proofs, but it does track just enough dependency information to enable the production of conflict clauses.

Non-Clausal Decision Heuristics
A great difficulty of the DPLL algorithm is choosing splitters.  The order in which splitters are chosen can have a huge impact on the performance of the algorithm, because a particular choice may prune a large subtree of the decision tree. SAT solvers such as Chaff incorporate decision heuristics which work well on many pure Boolean problems given in CNF. But we can do better by taking advantage of the structure of a non-clausal (i.e. non-CNF) formula to guide the search.
We have implemented the “depth-first-search” and “caching” heuristics that were developed for SVC [3,10] (a predecessor of CVC Lite). In what follows, the formulas under consideration are in non-clausal form. The logic
of these formulas includes a Boolean if-then-else operator, defined as if a then
b else c ≡ (a → b) ∧ (чa → c), and a similar operator for terms. A formula containing the term if a then t1 else t2 can be translated to an equisatisfiable formula by replacing the if-then-else with a fresh variable v and conjoining the side conditions a → v = t1 and чa → v = t2. While these operators add no expressive power to the logic, they are very useful in applications.
The depth-first-search (DFS) heuristic chooses as the splitter the top-most, left-most atomic subformula within the formula being checked. The intuition behind this heuristic is that in the best case, when the top-level expression of the formula is an if-then-else with a literal as its condition and the consequent and alternate are of equal size and share no literals, then the heuristic splits on the condition and divides the problem into two sub-problems which are half the size of the original. Of course, in the general case, these criteria are not all satisfied and the sub-problems can be almost as large as the original problem. A refinement is to search the sub-trees of an expression in order of their height in the hope of splitting a larger sub-tree and yielding smaller sub-problems.
The caching heuristic identifies splitters that are effective and caches them for use in similar sub-problems. Given a partial assignment ∆, a splitter α
is effective if it terminates the recursive case-splitting of checkSat; that is, if both checkSat(∆ ∪ {α = T}, φ') and checkSat(∆ ∪ {α = ⊥}, φ') reach a conflict without any further case splits. When the heuristic finds an effective splitter


it adds the splitters in the current partial assignment to an LRU cache, and when choosing a splitter it favors those that are in the cache. The intuition here is that we will encounter similar sub-problems for which the splitters in the cache are also effective.
However, we may encounter a sub-problem that contains a splitter that is in the cache, but is not effective for the sub-problem; the sub-problem is not closely related to the sub-problem for which the splitter was originally effective. In particular, when a splitter is added to the cache because it is effective for a small sub-problem, it is unlikely that it will be effective for a much larger sub-problem. Moreover, a poor splitter choice in a large sub- problem is worse, in terms of the amount of extra work it causes, than in a small sub-problem.
To mitigate these effects, the caching heuristic maintains a “trust” metric for each splitter in the cache. A splitter starts out with an initial trust, and each time it is found to be effective its trust is increased. If it is evicted from the cache it loses the trust it has earned. When choosing a splitter for a sub- problem of height h (where the height of a sub-problem is the height of the formula’s parse tree), only those splitters in the cache with a trust of at least h are considered.
Finally, the splitters in the cache are ordered according to how recently they were added to the cache. So for a particular sub-problem, the newest splitter that is in the sub-problem and has sufficient trust for the height of the sub-problem is chosen. If no such splitter exists in the cache we fall back to the DFS heuristic.
The caching heuristic is similar in some respects to the heuristics in Chaff (both VSIDS and the heuristic that chooses a splitter from the most recent conflict clause if possible), insofar as they both try to take advantage of the adjacency of similar sub-problems as the decision tree is searched. The dif- ferences are that the caching heuristic is somewhat more conservative (it puts splitters in the cache only when it finds an effective splitter, not on every con- flict), it falls back to the DFS heuristic when there are no applicable splitters in the cache, it makes no attempt to weed out splitters that do not contribute to the two conflicts of an effective splitter (corresponding to conflict-clause minimization), and it maintains a trust metric to avoid poor splitter choices. While the caching heuristic is somewhat ad hoc, it works well in practice.


(p → x = 1) ∧ (q → x = 2) ∧ (чq → x = 3)

p, x = 1 

(q → x = 2) ∧ (чq → x = 3)

p, x = 1, q,x = 2	p, x = 1, чq, x = 3 

unsat	unsat
Fig. 2. q is an effective splitter

Combining Non-Clausal Heuristics with SAT Meth- ods
The SVC decision procedure uses DPLL without conflict clauses or BCP, and works directly on non-clausal formulas. CVC has a mode where it converts the formula to CNF and calls Chaff for the propositional search; it annotates the CNF variables in order to reconstruct the non-clausal structure of the formula and use the DFS heuristic. CVC Lite implements its own Chaff-style Boolean search with BCP and conflict clauses. It stores the clausal part of the formula (i.e. any part of the formula already in CNF, and any conflict clauses generated during the search) separately from the non-clausal part, and does BCP on the clausal part only. The default strategy for CVC Lite is to use the simple DFS heuristic on the non-clausal part of the formula, and fall back to Chaff’s VSIDS heuristic when there are no splitters left in the non-clausal part.
In the present work we add the caching heuristic to CVC Lite. The main difference between our implementation and the implementation in SVC is how effective splitters are determined. In SVC, if there are two conflicts in a row at the same decision level, that means that both polarities for the most recent splitter have been tried without needing to split again. With BCP and conflict clauses, the first conflict causes a conflict clause to be added, and subsequent BCP causes the most recent splitter to be asserted in the opposite polarity
(this is known as a failure-driven assertion). If there is a second conflict before
choosing another splitter, then the formula is unsatisfiable under the current partial assignment with the splitter in either assignment, which corresponds to our definition of an effective splitter.
Consider Figure 2, which shows part of a decision tree for a simple formula. First p is chosen as a splitter, which implies x = 1. Next q is chosen as a


(a ∧ b) V (c ∧ d) ≡
(e1 Ve2)∧(e1 VчaVчb)∧(чe1 Va)∧(чe1 Vb)∧(e2 VчcVчd)∧(чe2 Vc)∧(чe2 Vd)
Fig. 3. Definitional CNF

splitter, which implies x = 2. The first-order decision procedure detects that this combination of literals is unsatisfiable.
When the basic DPLL search detects the contradiction it backtracks one level in the tree and asserts чq, which implies x = 3. Again the first-order decision procedure detects that this is unsatisfiable. Since asserting q in either polarity results in a contradiction, q is an effective splitter.
When DPLL augmented with BCP and conflict clauses detects the con- tradiction, it backtracks one level in the tree and adds the conflict clause (чp V чq). Next it does BCP, and because p is asserted it deduces чq from the newly-added conflict clause, which implies x = 3, causing another con- tradiction. It then backtracks again and adds the conflict clause чp (since p is the only assumption). Since two conflicts have occurred in a row without an intervening decision, q is an effective splitter. Because in the core DPLL algorithm, the current ∆ is lost when the algorithm backtracks, our imple- mentation of the caching heuristic saves ∆ as soon as it reaches a conflict, in case it turns out that the last splitter is effective.

Non-Clausal Boolean Constraint Propagation
If we translate a formula to CNF, we may be able to make valuable deductions by BCP that we would not be able to make on the formula in non-clausal form (since BCP as described works only on clauses). But the non-clausal heuristics depend on the structure of the formula, which is lost in translation to CNF. We can get the benefits of both approaches by keeping both the non-clausal formula and its CNF translation, and using the first for non- clausal heuristics and the second for BCP. (We convert to an equisatisfiable formula in definitional CNF, introducing a fresh variable for each non-atomic sub-expression to avoid the potentially exponential blowup in the size of the result.)
Consider Figure 3, which shows the translation of a simple formula to definitional CNF. Fresh variables e1 and e2 are introduced to represent (a ∧ b) and (c ∧ d), respectively, and the formulas e1 ↔ (a ∧ b) and e2 ↔ (c ∧ d) are translated into 3 clauses each. Now if we make a decision чa then BCP will deduce чe1 by the third clause, e2 by the first clause, c by the sixth clause, and d by the seventh clause.
Following [9] we tried implementing propagation directly on Boolean con- nectives rather than doing BCP on the CNF translation. For example, if the


result of an AND expression is known to be true, then both of its child expres- sions must be true. This direct propagation can be done more efficiently than BCP on the CNF translation. However, in our present implementation the cost of the first-order decision procedure is much greater than that of BCP, so this optimization does not significantly improve the overall results.


Results
Figure 4 gives empirical results for the various methods we have discussed on a number of benchmarks from verification efforts. We treat the “simple” DPLL search with the DFS splitter heuristic as a baseline, and compare it to the “fast” search (incorporating BCP and conflict clauses), the fast search with additional clauses (generated by CNF conversion of the original formula), the simple search with the caching heuristic, and the combination of the caching heuristic with the fast search and additional CNF clauses.
The table shows the number of splits, the number of splits normalized to the simple search with DFS, the time in seconds, and the normalized time in seconds for each benchmark and method. Smaller numbers in the normalized fields in the table mean that the method does better than simple search with DFS. At the bottom we show the geometric mean of the normalized numbers to provide an overall comparison.
With simple search, the caching heuristic improves on DFS in both number of decisions and time. The fast search with DFS improves on the simple search in number of decisions, and the addition of CNF clauses to the fast search improves further on the number of decisions. Finally, the combination of the fast search with CNF clauses and the caching heuristic does better than either method alone in number of decisions, but is somewhat slower than the caching heuristic alone.
Notice that in general, the current implementation of the “fast” search achieves fewer splits, but requires more time. The implementation of the “fast” search is not the subject of this paper, but in future work, we expect to be able to optimize its performance significantly. One primary reason for our optimism is that our previous system, CVC, whose implementation is similar to that of the “fast” engine, except that the Boolean part does not produce proofs, is able to do many more splits per second than the “fast” engine of CVC Lite. We do not believe that proof-production accounts for all of the performance difference. This work shows that we can vastly decrease the number of splits by combining non-clausal and SAT-based heuristics. With further work we should be able to achieve a similar improvement in performance.









Fig. 4. Results

References
Clark Barrett and Sergey Berezin. A proof-producing boolean search engine. In CADE-19 Workshop: Pragmatics of Decision Procedures in Automated Reasoning (PDPAR), July 2003. Miami, Florida, USA.

Clark Barrett and Sergey Berezin. CVC-Lite: A new implementation of the cooperating validity checker. In Proceedings of the 16th International Conference on Computer-Aided Veriﬁcation (CAV), April 2004. To appear.
Clark Barrett, David Dill, and Jeremy Levitt. Validity checking for combinations of theories with equality. In Mandayam Srivas and Albert Camilleri, editors, Formal Methods in Computer-Aided Design, volume 1166 of Lecture Notes in Computer Science, pages 187–201. Springer-Verlag, November 1996. Palo Alto, California, November 6–8.
Clark W. Barrett, David L. Dill, and Aaron Stump. Checking Satisfiability of First-Order Formulas by Incremental Translation to SAT. In Ed Brinksma and Kim Guldstrand Larsen, editors, 14th International Conference on Computer Aided Veriﬁcation (CAV), volume 2404 of Lecture Notes in Computer Science, pages 236–249. Springer-Verlag, 2002. Copenhagen, Denmark.

Martin Davis, George Logemann, and Donald Loveland. A machine program for theorem- proving. Communications of the ACM, 5:394–397, July 1962.
Martin Davis and Hilary Putnam. A computing procedure for quantification theory. Journal of the ACM, 7(3):201–215, July 1960.
Leonardo de Moura, Harald Ruess, and Maria Sorea. Lazy Theorem Proving for Bounded Model Checking over Infinite Domains. In 18th International Conference on Automated Deduction, 2002.
Cormac Flanagan, Rajeev Joshi, Xinming Ou, and James Saxe. Theorem Proving using Lazy Proof Explication. In 15th International Conference on Computer Aided Veriﬁcation (CAV), Lecture Notes in Computer Science. Springer-Verlag, 2003.
Malay K. Ganai, Pranav Ashar, Aarti Gupta, Lintao Zhang, and Sharad Malik. Combining strengths of circuit-based and cnf-based algorithms for a high-performance sat solver. In Proceedings of the 39th Conference on Design Automation, pages 747–750. ACM Press, 2002.
Jeremy R. Levitt. Formal Veriﬁcation Techniques for Digital Systems. PhD thesis, Stanford University, December 1998.
J. Marques-Silva and K. Sakallah. GRASP: A Search Algorithm for Propositional Satisfiability.
IEEE Transactions on Computers, 48(5):506–521, 1999.
M. Moskewicz, C. Madigan, Y. Zhaod, L. Zhang, and S. Malik. Chaff: Engineering an Efficient SAT Solver. In 39th Design Automation Conference, 2001.
Aaron Stump, Clark W. Barrett, and David L. Dill. CVC: A Cooperating Validity Checker. In Ed Brinksma and Kim Guldstrand Larsen, editors, 14th International Conference on Computer Aided Veriﬁcation (CAV), volume 2404 of Lecture Notes in Computer Science, pages 500–504. Springer-Verlag, 2002. Copenhagen, Denmark.
