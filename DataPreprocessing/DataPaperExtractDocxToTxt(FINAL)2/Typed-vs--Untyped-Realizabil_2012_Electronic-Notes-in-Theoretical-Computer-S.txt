Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 286 (2012) 57–71
www.elsevier.com/locate/entcs
Typed vs. Untyped Realizability
Ulrich Berger1 Tie Hou2
Computer Science Department Swansea University
Swansea, UK

Abstract
We study the domain-theoretic semantics of a Church-style typed λ-calculus with constructors, pattern matching and recursion, and show that it is closely related to the semantics of its untyped counterpart. The motivation for this study comes from program extraction from proofs via realizability where one has the choice of extracting typed or untyped terms from proofs. Our result shows that under a certain regularity condition, the choice is irrelevant. The regularity condition is that in every use of a fixed point type fix α.ρ, α occurs only positively in ρ.
Keywords: Scott domain, typed and untyped λ-calculus, program extraction, logical relation, realizability.


Introduction
This paper is part of a research project aiming at a semantical foundation for pro- gram extraction from proofs [7]. It contributes to a soundness proof for a language of realizers of proofs involving inductive and coinductive definitions. The natural language of realizers for inductive and coinductive definitions is a typed lambda cal- culus with types modeling initial algebras and final coalgebras, and terms modeling structural recursion and corecursion. In this paper we study a more general calculus that allows fixed points of arbitrary type operators and definitions of functions by general recursion. The advantage of this generality is that our results will apply to all conceivable extensions of our theory of realizers of inductive and coinductive definitions.
We study the domain-theoretic semantics of a Church-style typed λ-calculus with constructors, pattern matching and recursion, and compare it with its untyped counterpart. We work with polymorphic types that allow fixed points of arbitrary type operators. A type ρ is interpreted as (the image of) a finitary projection ⟨ρ⟩,

1 Email: u.berger@swansea.ac.uk
2 Email: cshou@swansea.ac.uk

1571-0661 © 2012 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2012.08.005

following [2]. The main result (Theorem 4.15) relates the semantics of a typed term M with its untyped variant M−: if M has type ρ, where ρ is a regular type, that is, fixed points are only taken of positive operators, then
⟨ρ⟩[[M −]]= [[M ]].
The proof uses logical relations. We do not know whether the result also holds if ρ
is not regular.
A similar problem was studied by Reynolds [13,14] who established a coherence between the typed and untyped meanings of expressions based on cpo models of a version of PCF. The main differences to our work are as follows: Reynolds considers simple types over the base types of natural numbers and booleans while we allow arbitrary recursive types. On the other hand, he includes subtyping which we do not. Regarding the typed semantics, Reynolds interprets typing derivations in a typed model while we interpret terms with a typed abstraction in an untyped model.
The motivation for this study comes from program extraction from proofs via realizability (see e.g. [6,4,7,8] for applications in constructive analysis) where one has the choice of extracting typed or untyped terms from proofs. Our result shows that if the extracted type is regular, the choice is irrelevant. In fact, regularity is a harmless restriction because in the intended realizability interpretation the types of realizing terms will always be regular. In [5] the soundness of a realizabil- ity interpretation based on a fragment of the untyped version of our calculus was proven, and the calculus was shown to be computationally adequate with respect to a domain-theoretic semantics (the same semantics we are considering here). In
[9] it was shown that the extracted programs admit a Curry-style typing. In the present paper we provide the missing semantical link to Curry-style typing.
The application to realizability is also our motivation for working with Scott domains (instead of arbitrary cpos, as Reynolds does): the adequacy proof in [5] uses the fact that all semantic objects can be approximated by compact ones, hence we have to ensure that types are interpreted in a cartesian closed category of algebraic domains. This is achieved by interpreting types as finitary projections. Apart from that, the results of this paper could also be obtained using arbitrary cpos and embedding-retraction pairs.
The problem of relating typed and untyped realizability was also studied by Longley [10]. He used a condition called (constructive) logical full abstraction to connect realizability over typed and untyped structures by means of partial combi- natory algebra.
Our paper is organized as follows. Section 2 introduces the syntax of types and typed terms, and typing rules for typed terms. Next, in Section 3, the semantics of types and typed terms are described in the setting of Scott domains and its correct- ness is proved. In Section 4, the relation between the domain-theoretic semantics of typed terms and the semantics of their untyped counterparts are studied. The proof uses logical relations, which are related to Tait’s computability method and Girard’s method of reducibility candidates. Finally, Section 5 concludes the paper

and outlines some future work.


Types and terms
In this and the next section we study the syntax and semantics of types and typed terms. Untyped terms will be introduced in Section 4.
Definition 2.1 [Types] The set of types is defined by the following grammar:

Type e ρ, σ, τ ::= α | ρ → σ | 1 | ρ × σ | ρ + σ | fix α.ρ.

where α ranges over a set TVar of type variables. A fixed-point construction, fix α.ρ, binds all free occurrences of α in ρ.

We work with a Church-style typed lambda-calculus with constructors, pattern matching and recursion which we call Language of Realizers (LoR) because its terms are intended to be used as extracted programs from proofs obtained by a realizability interpretation.
We consider only the constructors Nil (nullary), Pair (binary), and Left, Right, In (unary). The intention behind the first four constructors should be obvious. The constructor In is used to model type fixed points up to isomorphism. Many definitions and results could be extended to an arbitrary set of constructors.
Definition 2.2 [Terms] The set of (Church-style typed) terms is defined by
LoR e M, N, Ri ::= x | λx : ρ.M | MN | rec x : ρ.M | C(M1,..., Mn) |
case M of {Ci(xi) → Ri}i∈{1,...,n}.
where x ranges over a set of variables Var, C is a constructor of arity n, and in case M of {Ci(xi) → Ri}i∈{1,...,n} all constructors Ci are distinct and each xi is a vector of distinct variables whose length coincide with the arity of Ci. Lambda abstraction, λx : ρ.M , and recursion, rec x : ρ.M , bind all free occurrences of x in M , and a pattern matching clause, Ci(xi) → Ri, binds all free occurrences of xi in Ri.

We introduce typing rules for LoR-terms. A type context is a set of pairs Γ := x1 : ρ1,..., xn : ρn (for notational convenience we omit the curly braces) where ρi are types and xi are distinct variables. The set of variables {x1,..., xn} (which may be empty) is denoted by dom(Γ).
The relation Γ ▶ M : ρ (M is a LoR term of type ρ in context Γ) is inductively defined as follows. Note that in the definition of terms (Definition 2.2), a case expression can have in general many clauses, but our typing rules only allow two or

one clauses.
Γ ▶ Nil : 1	Γ,x : ρ ▶ x : ρ


Γ,x : ρ ▶ M : σ
Γ ▶ λx : ρ.M : ρ → σ
Γ,x : τ ▶ M : τ
Γ ▶ rec x : τ.M : τ



Γ ▶ M : ρ → σ	Γ ▶ N : ρ
Γ ▶ M N : σ
Γ ▶ M : ρ	Γ ▶ N : σ


Γ ▶ Pair(M, N ): ρ × σ



Γ ▶ M : ρ
Γ ▶ Left(M ): ρ + σ
Γ ▶ M : σ

Γ ▶ Right(M ): ρ + σ


Γ ▶ M : ρ + σ	Γ, x1 : ρ ▶ L : τ	Γ, x2 : σ ▶ R : τ
Γ ▶ case M of {Left(x1) → L; Right(x2) → R} : τ

Γ ▶ M : ρ × σ	Γ,x : ρ, y : σ ▶ N : τ
Γ ▶ case M of {Pair(x, y) → N} : τ

Γ ▶ M : ρ[fix α.ρ/α] Γ ▶ In(M ): fix α.ρ

Γ ▶ M : fix α.ρ	Γ,x : ρ[fix α.ρ/α] ▶ N : σ
Γ ▶ case M of {In(x) → N} : σ
Domain-theoretic semantics
We assume familiarity with the basic theory of Scott domains and the method of defining domains by recursive domain equations [15,1,3]. We omit the proofs of the most basic results since they are rather elementary, or can be found in the above cited literature. The reason for working with Scott domains is that all the semantic constructions we need are readily available, e.g. cartesian closure, solutions to recursive domain equation, recursive definition of functions, interpretation of types, including recursive types, as finitary projections. All these constructions are very elementary and do not require a heavy category-theoretical machinery.
By a Scott-domain, or domain for short, we mean a bounded complete ω- algebraic dcpo with least element. We will denote the least element of a domain by
⊥. By 1 we denote the sole-element domain {Nil}, and by (D1 + ... + Dn)⊥, D×E, [D → E] the separated sum, cartesian product, and continuous function space of domains 3 .

3 These domain operations should not be confused with the syntactic constructors for types which for simplicity we denoted by the same symbols.

Due to ω-algebraicity, every element x of a domain D is the directed countable supremum of compact elements, where y ∈ D is called compact if for every directed A ⊆ D, A has a supremum HA and y ± HA s.t. y ± z for some z ∈ A. By Dc we denote the set of compact elements of D.
Definition 3.1 [Subdomain] E ⊆ D is a subdomain of D if
⊥D ∈ E.
If A ⊆ E and HDA exists in D, then HDA ∈ E and HDA = HEA.
If x is compact in E, then x is compact in D.
∀y ∈ Dc∀x ∈ E(y ± x → ∃yj ∈ Ec(y ± yj ± x)).
Lemma 3.2 Let E ⊆ D be a subdomain of D. Then E is a domain.
Proof. By verifying clauses (directed complete, algebraic, bounded complete) of the definition of domain.	2
Following [2] we interpret types as finitary projections in D. Since the range of a finitary projection is a subdomain of D the semantics of types can be viewed as a domain. This approach provides an easy solution to the problem of defining the semantics of a fixed point type: one can simply take the least fixed point of a suitable continuous function on the domain [D → D].
Definition 3.3 [Finitary projection] f : D → D is a projection if
f is continuous,
f ± id, i.e. ∀x ∈ D.f (x) ± x,
f ◦ f = f , i.e. ∀x ∈ D.f (f (x)) = f (x).
A projection f is ﬁnitary if the range of f , denoted by f (D), is a subdomain of
D.
For f : D → D we set Fix(f ) := {x ∈ D | f (x) = x}. Obviously, if f ◦ f = f , then f (D) = Fix(f ).
In the following two lemmas we assume that p : D → D is a projection, and we set p(D)c := Dc ∩ p(D). We omit their proofs since they are easy.
Lemma 3.4 E is a subdomain of D if and only if there exists a ﬁnitary projection
p : D → D such that E = p(D).
Lemma 3.5 The following are equivalent:
p is ﬁnitary
∀x ∈ D(Ax := {a ∈ p(D)c | a ± x}) is directed and p(x)= HAx.
∃A ⊆ Dc.∀x ∈ D(p(x)= H{a ∈ A | a ± x}).
Lemma 3.6 If for all n, pn is a ﬁnitary projection and pn ± pn+1, then Hnpn is a ﬁnitary projection.

Proof. Let p := Hnpn.	By Lemma 3.5 (c), it suffices to show that p(x) =
H{a ∈ p(D)c | a ± x}.	We first show that p is idempotent:	p(p(x)) =
(∗)
(Hnpn)((Hmpm)(x)) = Hn Hm (pn(pm(x)))  =  Hn(pn(pn(x))) = Hn(pn(x)) =
(Hnpn)(x) = p(x). Equation (∗) easily follows from the fact that the double se- quence pn(pm(x)) is increasing in m and in n. Hence, we get p(D)= {x | p(x)= x}, and therefore, H{a ∈ p(D)c | a ± x} = H{a ∈ Dc | p(a)= a Λ a ± x} = H{a ∈ Dc | Hn(pn(a)) = a Λ a ± x} = H{a ∈ Dc | En.pn(a) = a Λ a ± x} (by compactness) = Hn(H{a ∈ Dc | pn(a)= a Λ a ± x})= Hn(pn(x)) = p(x).	2

Now we define by a recursive domain equation a particular domain D which we will use to interpret types and terms.
Definition 3.7 We define the Scott domain D by the recursive domain equation: D  (1 +D+D+D+D × D+ [D → D])⊥
Using the constructors of LoR as names for the injections into the sum, each ele- ment in D has exactly one of the following forms: ⊥, Nil, Left(a), Right(a), In(a), Pair(a, b), Fun(f ), where a and b range over D, and f ranges over continuous func- tion from D to D.
It will be convenient to use the continuous functions

caseC1,...,Cn
:D → [Darity(C1) → D] → ... → [Darity(Cn) → D] → D


case

a f ...f 
:= ⎧⎨ fi(bi) if a = Ci(bi),

C1,...,Cn	1
⎩ ⊥	otherwise.

We also use an informal lambda-notation λa.f (a) and composition f ◦ g to define continuous functions on D. We do not prove the continuity in each case since this follows from well-known fact about the category of Scott domains and continuous functions. We also let LFP : [D → D] → D be the continuous least fixed point
operator, which can be defined by LFP(f )= .n fn(⊥).
The following definition gives an unexpected interpretation of a type ρ as a finitary projection ⟨ρ⟩, but from this one can derive a more familiar definition as a set, namely the image (or, equivalently, set of fixed points) of ⟨ρ⟩. Also, ⟨ρ⟩ will be used later in Theorem 4.15, and act as a function (not only a type), providing a link between the two semantics.
Definition 3.8 [Semantics of types] For every type ρ we define
⟨ρ⟩ : [[D → D]TVar → [D → D]] 4


4 [D → D]TVar is the set of type environments, i.e., functions from TVar to [D → D].


⟨1⟩ζ(a) = case


Nil
a Nil	(= ⎧⎨ Nil if a = Nil )
⎩ ⊥  otherwise

⟨α⟩ζ(a)= ζ(α)(a)
⟨ρ + σ⟩ζ(a) = caseLeft,Right a (Left ◦ ⟨ρ⟩ζ) (Right ◦ ⟨σ⟩ζ)
⟨ρ × σ⟩ζ(a) = casePair a (λb1b2.Pair(⟨ρ⟩ζ(b1), ⟨σ⟩ζ(b2)))
⟨ρ → σ⟩ζ(a) = caseFun a (λf.Fun(⟨σ⟩ζ ◦ f ◦ ⟨ρ⟩ζ))
⟨fix α.ρ⟩ζ = LFP(λp.λa.caseIn a (λb.In(⟨ρ⟩ζ[α := p](b)))) We set [ρ]]ζ := (⟨ρ⟩ζ)(D).
We call ζ : [D → D]TVar a finitary projection if ζ(α) is a finitary projection for all α ∈ TVar.
Lemma 3.9 If ζ is a ﬁnitary projection, then ⟨ρ⟩ζ is a ﬁnitary projection.
Proof. By induction on ρ using Lemma 3.4 and 3.5. We only look at the interesting case which is fixed point types. Let
f := λp.λa.caseIn a (λb.In(⟨ρ⟩ζ[α := p](b))),
hence ⟨fix α.ρ⟩ζ = LFP(f ) = Hn∈N fn(⊥). Therefore, by Lemma 3.6, it suffices to show that ∀n.fn(⊥) is a finitary projection. We do a side induction on n.
n = 0: To show f 0(⊥) is a finitary projection. Since f 0(⊥) = ⊥ and ⊥ is a finitary projection, f 0(⊥) is a finitary projection.
n + 1: Assume p := fn(⊥) is a finitary projection. To show f (p) is a finitary projection. We first show that f (p) is a projection. We have
f (p)= λa.caseIn a (λb.In(⟨ρ⟩ζ[α := p](b))).
By definition of caseIn, f (p) is a continuous function, since, by I.H., ⟨ρ⟩ζ[α := p] is a continuous function/finitary projection. To show f (p) ± id. We have
f (p)(x)= ⎧⎨ In(⟨ρ⟩ζ[α := p](b)) if x = In(b)
⎩ ⊥	otherwise
where In(⟨ρ⟩ζ[α := p](b)) ± In(b), since by I.H. ⟨ρ⟩ζ[α := p] is a projection. There- fore, f (p)(x) ± x. To show f (p)(f (p)(x)) = f (p)(x). If x = In(b), we have f (p)(f (p)(x)) = In(⟨ρ⟩ζ[α := p](⟨ρ⟩ζ[α := p](b))) = In(⟨ρ⟩ζ[α := p](b)) = f (p)(x), since by I.H. ⟨ρ⟩ζ[α := p] is idempotent. Otherwise, we get f (p)(f (p)(x)) = ⊥ = f (p)(x). Therefore, f (p) is a projection.
Now we show that f (p)(D) is a subdomain of D. Let
A := {⟨ρ⟩ζ[α := p](b) | b ∈ D} = ⟨ρ⟩ζ[α := p](D).
By I.H. ⟨ρ⟩ζ[α := p] is a finitary projection. Thus, A is a subdomain of D. By the

definition of f , f (p)(D) = In(A) ∪ {⊥}. It is easy to prove that In(A) ∪ {⊥} is a subdomain of D.	2
Now we are ready to define the semantics of LoR-terms. The leading idea in the definition of the value of a typed lambda-abstraction λx : ρ.M is that the domain of the resulting function is (the semantics of) ρ. Therefore, the incoming argument a is first projected down to ρ.
Definition 3.10 [Semantics of terms] For all environments ζ : [D → D]TVar, η : DVar, and every LoR term M we define the value [M ]]ζη ∈ D.
[[x]]ζη = η(x)
[[C(M1,..., Mn)]]ζη = C([[M1]]ζη,	, [[Mn]]ζη)
[[MN ]]ζη = caseFun ([[M ]]ζη) (λf.f ([[N ]]ζη))
[[λx : ρ.M ]]ζη = Fun(λa.[[M ]]ζη[x := ⟨ρ⟩ζ(a)])
[[rec x : τ.M ]]ζη = LFP(λa.[[M ]]ζη[x := ⟨τ⟩ζ(a)])
[[case M of {Ci(xi) → Ri}i]]ζη = caseC ,...,C  ([[M ]]ζη) (λa.[[Ri]]ζη[xi := a])i
One can prove the following soundness theorem, stating that if from a context Γ we can derive LoR term M with type ρ, and for every variable x ∈ dom(Γ), η(x) is an element of [[Γ(x)]]ζ (we will write η ∈ [Γ]]ζ for this), then the value of term M is an element of the value of type ρ.
Theorem 3.11 (Soundness For LoR terms) Let ζ be a ﬁnitary projection. If
Γ ▶ M : ρ and η ∈ [Γ]]ζ, then [[M ]]ζη ∈ [[ρ]]ζ.
Proof. By induction on the definition of the relation Γ ▶ M : ρ.	2

Relating typed and untyped terms
We now relate the semantics of typed terms with the semantics of untyped terms which are defined exactly as typed terms except that the type annotations for abstraction and recursion are omitted:
Definition 4.1 [Untyped terms]
LoR− e M, N, Ri ::= x | λx.M | MN | rec x.M | C(M1,.	, Mn) |
case M of {Ci(xi) → Ri}i∈{1,. ,n}
The same provisions made in Definition 2.2 for typed terms apply here.
The semantics of untyped terms is straightforward. It can be defined exactly as in the typed case except that the type environment ζ : [D → D]TVar and finitary projections involved in typed abstraction and recursion are omitted.
Definition 4.2 [Semantics of untyped terms] For every environment η : Var → D and every LoR− term M we define the value [M ]]η ∈ D.

[[x]]η = η(x)
[[C(M1,..., Mn)]]η = C([[M1]]η, ..., [[Mn]]η)
[[MN ]]η = caseFun ([[M ]]η) (λf.f ([[N ]]η))
[[λx.M ]]η = Fun(λa.[[M ]]η[x := a])
[[rec x.M ]]η = LFP(λa.[[M ]]η[x := a])
[[case M of {Ci(xi) → Ri}i]]η = caseC1,...,Cn ([[M ]]η) (λa.[[Ri]]η[xi := a])i

Our main result, the Coincidence Theorem 4.15, only applies to terms that are typed w.r.t. to a restricted notion of types where fixed point types fix α.ρ are allowed only if ρ is positive in α.

Definition 4.3 [ρ positive/negative in α] α is positive in α.
1 is positive and negative in α.
ρ → σ is positive in α if ρ is negative in α and σ is positive in α. ρ → σ is negative in α if ρ is positive in α and σ is negative in α. ρ + σ and ρ × σ are positive in α if ρ and σ are positive in α.
ρ + σ and ρ × σ are negative in α if ρ and σ are negative in α. fix β.ρ is positive in α if α = β or ρ is positive in α.
fix β.ρ is negative in α if α = β or ρ is negative in α.

Definition 4.4 [Regular types] We define regular types ρ as follows.
1 is regular.
α is regular.
ρ + σ, ρ × σ, ρ → σ are regular if ρ and σ are regular. fix α.ρ is regular if ρ is regular and ρ is positive in α.

Example 4.5 fix α.(α → α) is not regular, since α → α is not positive in α.

In the following all types are assumed to be regular.
To prove our main result we define a logical relation ∼R⊆ D × D which can intuitively be understood as a notion of equivalence of elements of a regular type ρ. We use the informal (second-order) lambda abstraction Λr ⊆ D2. to define functions on the set P(D2) of binary relations on D.
Definition 4.6 and Lemma 4.8 below should be considered simultaneously, since in the clause of fix α.ρ, the clause is well-defined only if ∼R[α:=r] is monotone in r.

Definition 4.6 [Logical Relation] In the following definition it assumed that R ∈ P(D2)TVar.

∼R := {(⊥, ⊥), (Nil, Nil)}
∼R := R(α)
∼R	:= {(⊥, ⊥)}∪ {(Pair(a1, a2), Pair(b1, b2)) | a1 ∼R



b1, a2 ∼R



b2}

ρ1×ρ2
R
ρ1+ρ2
:= {(⊥, ⊥)}∪ {(Left(a1), Left(b1)) | a1 ∼R
ρ1	ρ2
b1}

∪ {(Right(a2), Right(b2)) | a2 ∼R
b2}

R
ρ→σ
:= {(⊥, ⊥)}∪ {(Fun(f ), Fun(g)) |
∀a, b ∈ D(a ∼R b ⇒ f (a) ∼R g(b))

ρ	σ

R
fix α.ρ
:= LFP(Λr ⊆ D2.{(⊥, ⊥)}∪ {(In(a), In(b)) | a ∼R[α:=r] b})

Remark 4.7 Logical relations [12] have been used successfully to prove properties of typed systems. Famous examples are the strong normalization proofs by Tait and Girard using logical relations called computability predicates or reducibility candidates. The crucial feature of a logical relation is that it is a family of relations indexed by types and defined by induction on types such that all type constructors are interpreted by their logical interpretations, e.g. → is interpreted as logical implication.
Lemma 4.8
If ρ is positive in α, then Λr ⊆ D2. ∼R[α:=r] is monotone.
If ρ is negative in α, then Λr ⊆ D2. ∼R[α:=r] is anti-monotone.
Proof. By induction on ρ.	2
The notion of admissibility has been used in [1] and generalized in [11], where it is used to prove properties of least fixed points.
Definition 4.9 [Admissible relation] A relation r ⊆ D2 is called admissible if it satisfies
(⊥, ⊥) ∈ r.
If (dn, dj ) ∈ r and (dn, dj ) ± (dn+1, dj	) for all n, then Hn∈N (dn, dj ) ∈ r.
n	n	n+1	n
Note that a finite relation r ⊆ D2 with (⊥, ⊥) ∈ r is always admissible. Let Ad := {r ⊆ D2 | r is admissible}.
Lemma 4.10 Ad is a complete lattice. Moreover, if A is a directed set of admis- sible sets, then  A is admissible.
Proof. Easy.	2
We call R ∈ (D2)TVar admissible if R(α) is admissible for all α ∈ TVar.
Lemma 4.11 If R is admissible, then ∼R is admissible.
Proof. By induction on ρ. We only look at the most interesting case, which is

fix α.ρ. We have ∼R
= LFP(Φ) where

Φ: P(D2) → P(D2)
Φ(r) = {(⊥, ⊥)}∪ {(In(a), In(b)) | a ∼R[α:=r] b}.
Clearly (⊥, ⊥) ∈ Φ(r) for every r ⊆ D2. Hence, we have LFP(Φ) = rβ for some ordinal β0, where for every ordinal β, rβ is defined by r0 = {}, rβ+1 = Φ(rβ), rλ =  {rβ | β < λ} (λ a limit ordinal).
It is easy to see that if r ∈ Ad, then Φ(r) ∈ Ad, i.e. Φ : Ad → Ad. Hence by induction on ordinals and Lemma 4.10 it follows that all rβ where β > 0 are admissible.	2
Definition 4.12 [Compatibility] Let r ⊆ D2 and p ∈ [D → D]. We call r and p
compatible, in symbols r ≈ p, if
∀a, b ∈ D (r(a, b) → p(a)= p(b)).
∀a ∈ D r(p(a), p(a)).
∀a, b ∈ D (r(a, b) → r(p(a), b)).
We call R ∈ P(D2)TVar and ζ ∈ [D → D]TVar compatible, in symbols R ≈ ζ if
R(α) ≈ ζ(α) holds for all α ∈ TVar.
To obtain an example of compatibility one may take any idempotent p ∈ [D → D] and define r ⊆ D2 by r := {(a, b) ∈ D2 | p(a)= p(b)}. Then, clearly, r ≈ p.
Lemma 4.13	If R is admissible, ζ is a ﬁnitary projection, and R ≈ ζ, then
∼R ≈ ⟨ρ⟩ζ.
Proof. We write r ≈i,ii p for the notion of compatibility obtained by deleting property (iii) in Definition 4.12. Similarly, r ≈iii p means compatibility where properties (i) and (ii) are deleted. The notions R ≈i,ii ζ and R ≈iii ζ are defined mutatis mutandis as in Definition 4.12.
We show that if R is admissible and ζ(α) is a finitary projection, then:
If R ≈i,ii ζ, then ∼R ≈i,ii ⟨ρ⟩ζ.
If R ≈iii ζ, then ∼R ≈iii ⟨ρ⟩ζ.
Both statements are proved by induction on ρ. We only look at the interesting cases which are function and fixed point types.

Case ρ → σ: (i) Assume a ∼R
b. We have to show ⟨ρ → σ⟩ζ(a)= ⟨ρ →

σ⟩ζ(b). If a = b = ⊥, then this is trivial. If a = Fun(f ) and b = Fun(g). By the

definition of ∼R
(Definition 4.6), we have
∀c, d ∈ D(c ∼R d ⇒ f (c) ∼R g(d))	(∗)

ρ	σ
By Definition 3.8, we have ⟨ρ → σ⟩ζ(f )= Fun(⟨σ⟩ζ ◦ f ◦ ⟨ρ⟩ζ) and ⟨ρ → σ⟩ζ(g)= Fun(⟨σ⟩ζ◦g◦⟨ρ⟩ζ). Let c ∈ D. We need to show ⟨σ⟩ζ(f (⟨ρ⟩ζ(c))) = ⟨σ⟩ζ(g(⟨ρ⟩ζ(c))).

By induction hypothesis (ii) for ρ, we have ⟨ρ⟩ζ(c) ∼R
⟨ρ⟩ζ(c). Then by (∗) we

have f (⟨ρ⟩ζ(c)) ∼R g(⟨ρ⟩ζ(c)). And then by induction hypothesis (i) for σ, we have
⟨σ⟩ζ(f (⟨ρ⟩ζ(c))) = ⟨σ⟩ζ(g(⟨ρ⟩ζ(c))).

(ii) Let a ∈ D. We have to show ⟨ρ → σ⟩ζ(a) ∼R
⟨ρ → σ⟩ζ(a). If a = ⊥.

Then ⟨ρ → σ⟩ζ(a)= ⊥. Thus ⊥ ∼R
⊥. If a = Fun(f ), then, by Definition 3.8, we

have ⟨ρ → σ⟩ζ(a) = Fun(⟨σ⟩ζ ◦f ◦⟨ρ⟩ζ). We need to show Fun(⟨σ⟩ζ ◦f ◦ ⟨ρ⟩ζ) ∼R

Fun(⟨σ⟩ζ ◦ f ◦ ⟨ρ⟩ζ). By the definition of ∼R
(Definition 4.6), it is to show

∀c, d ∈ D(c ∼R d ⇒ ⟨σ⟩ζ(f (⟨ρ⟩ζ(c))) ∼R ⟨σ⟩ζ(f (⟨ρ⟩ζ(d)))).
ρ	σ
Assume c ∼R d. By induction hypothesis (i) for ρ, we have ⟨ρ⟩ζ(c) = ⟨ρ⟩ζ(d). Then f (⟨ρ⟩ζ(c)) = f (⟨ρ⟩ζ(d)). And then by induction hypothesis (ii) for σ, we have
⟨σ⟩ζ(f (⟨ρ⟩ζ(c))) ∼R ⟨σ⟩ζ(f (⟨ρ⟩ζ(d))).
Case fix α.ρ: By Definition 3.8, we have ⟨fix α.ρ⟩ζ = .n pn where p0 = λa.⊥,
pn+1 = λa.caseIn a (λb.In(⟨ρ⟩ζ[α := pn](b))). We set r := ∼R	and show r ≈i,ii pn
by a side induction on n. This will be sufficient, since, as one easily sees, because r is admissible (by Lemma 4.11), the conditions (i) and (ii) of compatibility are closed under taking directed suprema of the right argument. Hence from r ≈i,ii pn for all n it follows r ≈i,ii p.
n = 0: (i) is trivial since p0 is constant. (ii) holds since p0(a)= ⊥ and (⊥, ⊥) ∈ r
since r is admissible, by Lemma 4.11.
n + 1: (i) Assume r(a, b). We have to show pn+1(a) = pn+1(b). If a = b =
⊥, the equation trivially holds. Now assume a = In(c) and b = In(d). Then
pn+1(a) = In(⟨ρ⟩ζ[α := pn](c)) and pn+1(b) = In(⟨ρ⟩ζ[α := pn](d)), and we have

c ∼R[α:=r] d by the definition of r. By the side induction hypothesis, r ≈
i,ii
pn.

Hence, by the main induction hypothesis, ∼R[α:=r]
≈i,ii
⟨ρ⟩ζ[α := pn
], since r is

admissible and pn is a finitary projection (see proof of Lemma 3.9). It follows
⟨ρ⟩ζ[α := pn](c)= ⟨ρ⟩ζ[α := pn](d) and therefore pn+1(a)= pn+1(b).
(ii) Let a ∈ D. We have to show r(pn+1(a), pn+1(a)). If a = ⊥, then pn+1(a)= ⊥ and r(⊥, ⊥) holds by admissibility of r. If a = In(c), then pn+1(a)= In(⟨ρ⟩ζ[α := pn](c)). By the side induction hypothesis, r ≈i,ii pn. Hence, by the main induction

hypothesis, ∼R[α:=r]
≈i,ii
⟨ρ⟩ζ[α := pn
], since r is admissible and pn
is a finitary

projection (see proof of Lemma 3.9). It follows ⟨ρ⟩ζ[α := pn
](c) ∼R[α:=r] ⟨ρ⟩ζ[α :=

pn](c) and therefore pn+1(a) ∼R
pn+1(a), i.e. r(pn+1(a), pn+1(a)).

Case ρ → σ: Assume a ∼R	b. We have to show ⟨ρ → σ⟩ζ(a) ∼R	b.

If a = b = ⊥. Then ⟨ρ → σ⟩ζ(a) = ⊥ = b. Thus ⊥ ∼R
⊥. If a = Fun(f ) and

b = Fun(g), then by the definition of ∼R
, we have

∀c, d ∈ D(c ∼R d ⇒ f (c) ∼R g(d))	(∗)
ρ	σ
By Definition 3.8, we have ⟨ρ → σ⟩ζ(a) = Fun(⟨σ⟩ζ ◦ f ◦ ⟨ρ⟩ζ). We need to show

Fun(⟨σ⟩ζ ◦ f ◦ ⟨ρ⟩ζ) ∼R
Fun(g). By the definition of ∼R
, it is to show ∀c, d ∈

D(c ∼R d ⇒ ⟨σ⟩ζ(f (⟨ρ⟩ζ(c))) ∼R g(d)). Assume c ∼R d. By induction hypothesis
ρ	σ	ρ

for ρ, we have ⟨ρ⟩ζ(c) ∼R
d. Then by (∗) we have f (⟨ρ⟩ζ(c)) ∼R
g(d), and by

induction hypothesis for σ, we have ⟨σ⟩ζ(f (⟨ρ⟩ζ(c))) ∼R g(d).

Case fix α.ρ: Set r := ∼R
and p := ⟨fix α.ρ⟩ζ. We have to show that r(a, b)

implies r(p(a), b), i.e. r ⊆ s where s := {(a, b) | r(p(a), b)}. We verify that r ∩ s ≈iii

p holds. Indeed, if (r∩s)(a, b), then r(p(a), b) since s(a, b) holds, and hence, since by Lemma 3.9 p is idempotent, r(p(p((a)), b) since s(p(a), b) holds, i.e. (r ∩ s)(p(a), b). Since r is the least fixed point of the operator Φ := Λr.{(⊥, ⊥)}∪ {(In(a), In(b)) | a ∼R[α:=r] b} we can attempt to prove the inclusion r ⊆ s by induction. In fact we use the strong induction principle (see, for example, [8]) according to which it suffices to show Φ(r ∩ s) ⊆ s (instead of Φ(s) ⊆ s). Clearly (⊥, ⊥) ∈ s. Hence

we assume a ∼R[α:=r∩s]
b and have to show r(p(In(a)), In(b)). Since p(In(a)) =

In(⟨ρ⟩ζ[α := p](a)) and r = Φ(r), we have to show Φ(r)(In(⟨ρ⟩ζ[α := p](a)), In(b)),

i.e., ⟨ρ⟩ζ[α := p](a) ∼R[α:=r] b. By induction hypothesis, and because r ∩ s ≈
iii p,

⟨ρ⟩ζ[α := p](a) ∼R[α:=r∩s] b and hence ⟨ρ⟩ζ[α := p](a) ∼R[α:=r] b, by monotonicity
ρ	ρ
(Lemma 4.8).	2

Let η ∼R
ηj denote the following: for all x ∈ dom(Γ), η(x) ∼R
ηj(x). Let

Γ ▶reg M : ρ mean that Γ ▶ M : ρ has been derived using regular types only.
Let M— be the untyped term obtained from the Church-style term M by deleting the type information in lambda abstractions. The following lemma is the core of the proof of the Coincidence Theorem.
Lemma 4.14 Assume R is admissible, ζ is a ﬁnitary projection, and R ≈ ζ. If
Γ ▶reg M : ρ and η ∼R ηj, then [[M ]]ζη ∼R [[M —]]ηj.
Γ	ρ
Proof. By induction on the definition of the relation Γ ▶reg M : ρ.
The interesting cases are lambda abstraction and recursion.
Γ,x : ρ ▶reg M : σ
(a)	.
Γ ▶reg λx : ρ.M : ρ → σ
We have to show [λx : ρ.M ]]ζη ∼R	[[λx.M —]]ηj. By Definition 3.10 and 4.2,
we have
[[λx : ρ.M ]]ζη = Fun(f )	where f (a)= [[M ]]ζη[x := ⟨ρ⟩ζ(a)],
[[λx.M —]]ηj = Fun(g)	where g(b)= [[M —]]ηj[x := b].

It is to show Fun(f ) ∼R
(Definition 4.6), it is to show
Fun(g). By definition of our logical relation

∀a, b ∈ D(a ∼R b ⇒ f (a) ∼R g(b))	(∗)
ρ	σ
By induction hypothesis for σ we have
∀a, b ∈ D(a ∼R b ⇒ [[M ]]ζη[x := a] ∼R [[M —]]ηj[x := b])	(IH)
ρ	σ
To prove (∗), assume a ∼R b. By Lemma 4.13 (iii) we have ⟨ρ⟩ζ(a) ∼R b.
Hence [M ]]ζη[x := ⟨ρ⟩ζ(a)] ∼R [[M —]]ηj[x := b]).

(b)
Γ,x : τ ▶reg M : τ
Γ ▶reg rec x : τ.M : τ  .
We have to show [rec x : τ.M ]]ζη ∼R

[[rec x.M—]]ηj.  By Definition 3.10

and 4.2, we have

[[rec x : τ.M ]]ζη = LFP(f )	where f (a)= [[M ]]ζη[x := ⟨τ⟩ζ(a)],
[[rec x.M—]]ηj = LFP(g)	where g(b)= [[M —]]ηj[x := b].

Now we have to show LFP(f ) ∼R
LFP(g).  By definition it is to show

Hnfn(⊥) ∼R Hngn(⊥). Since, by Lemma 4.11, ∼R is admissible, it suffices to
τ	τ
show that ∀n.fn(⊥) ∼R gn(⊥). We do a side induction on n.
n = 0: To show f 0(⊥) ∼R g0(⊥), i.e. ⊥ ∼R ⊥. This holds by Definition 4.6.
τ	τ
n + 1: Assume as side induction hypothesis, fn(⊥) ∼R gn(⊥), to show
f (n+1)(⊥) ∼R g(n+1)(⊥). We have
f (n+1)(⊥)= f (fn(⊥)) = [M ]]ζη[x := ⟨τ⟩ζ(fn(⊥))],
g(n+1)(⊥)= g(gn(⊥)) = [M—]]ηj[x := gn(⊥)].
It is to show [M ]]ζη[x := ⟨τ⟩ζ(fn(⊥))] ∼R [[M —]]ηj[x := gn(⊥)].  By side
induction hypothesis, we have ⟨τ⟩ζ(fn(⊥)) ∼R gn(⊥) by Lemma 4.13 (iii). By main induction hypothesis we have [M ]]ζη[x := ⟨τ⟩ζ(fn(⊥))] ∼R [[M —]]ηj[x :=
gn(⊥)].
2
The above lemma (Lemma 4.14) yields as an immediate consequence our main result that if from a context Γ we can derive a LoR term M with regular type ρ, and for every variable x ∈ dom(Γ), η(x) is an element of [Γ(x)]]ζ, then the value of M and its corresponding untyped term M— coincide up to the finitary projection
⟨ρ⟩ζ.
Theorem 4.15 (Coincidence) If Γ ▶reg M : ρ and η ∈ [Γ]]ζ where ζ is a ﬁnitary projection, then [[M ]]ζη = ⟨ρ⟩ζ([[M —]]η).
Proof. Given a finitary projection ζ, we define R(α) := {(a, b) ∈ D2 | ζ(α)(a) = 
p(b)}. Then R ≈ ζ, as explained in the example following Definition 4.12. By
Lemma 4.14, we then have [M ]]ζη ∼R [[M —]]η.	By Lemma 4.13 (i), we get
⟨ρ⟩ζ([[M ]]ζη) = ⟨ρ⟩ζ([[M —]]η). Then, by Soundness Theorem 3.11 and the defini- tion of ⟨ρ⟩ζ(D), we have [M ]]ζη = ⟨ρ⟩ζ([[M ]]ζη). Thus, [M ]]ζη = ⟨ρ⟩ζ([[M —]]η).  2

Conclusion
We have studied a domain-theoretic semantics for Church-style system LoR of typed lambda terms and proved that, when restricted to regular types, it is closely related to its untyped counterpart. The proof uses hybrid logical relations. The reason for studying this domain-theoretic semantics is that it allows for very simply and elegant proofs of computational adequacy, and hence the correctness of program extraction.
Our results could be easily extended to also include full second-order polymor- phism ∀α.ρ, Eα.ρ as in [2], but for our application, simple parametric and recursive types are sufficient.
As future work we intend to investigate whether the requirement of regularity is indeed necessary for our result to hold. Furthermore, we plan to compare the

Church-style system with a corresponding Curry-style system.
Acknowledgements
We are grateful to the anonymous referees for providing valuable suggestions and drawing our attention to related work.

References
Abramsky, S., and Jung, A., Domain theory. In Handbook of Logic in Computer Science (1994), S. Abramsky, D. Gabbay, and T. S. E. Maibaum, Eds., Oxford University Press, 1-168.
Amadio, R. M., Bruce, K. B., and Longo, G., The finitary projection model for second order lambda calculus and solutions to higher order domain equations. In First Annual IEEE Symposium on Logic in Computer Science, IEEE Computer Society Press (1986) 122-130.
Amadio, R. M., and Curien, P.-L., ”Domains and Lambda-Calculi”, vol. 46 of Cambridge Tracts in Theoretical Computer Science. Cambridge University Press, 1998.
Berger, U., From coinductive proofs to exact real arithmetic. LNCS 5771 (2009) 132-146.
Berger, U., Realisability for Induction and Coinduction with Applications to Constructive Analysis. Jour. Universal Comput. Sci. 16(18) (2010), 2535-2555.
Berger, U., and Hou, T., Coinduction for Exact Real Number Computation. Theory Comput. Sys. 43
(2008) 394-409.
Berger, U., and Seisenberger, M., Proofs, programs, processes. In (Ferreira, F., L¨owe, B., Mayordomo, E., Gomes, L. M., eds.) Programs, Proofs, Processes, CiE 2010, Ponta Delgada, Azores, Portugal LNCS 6158 (2010) 39-48.
Berger, U., From coinductive proofs to exact real arithmetic: theory and applications. Logical Methods in Comput. Sci. 7(1) (2011) 1-24.
Berger, U., and Seisenberger, M., Program extraction via typed realisability for induction and coinduction. In (Schindler, R., ed.) Ways of Proof Theory. Ontos Series in Mathematical Logic, Ontos Verlag, Frankfurt. (2011) 157-182.
Longley, J., Matching typed and untyped realizability. Electronic Notes in Theoretical Computer Science
35 (2000) 109-132.
Pitts, A. M., Relational properties of recursively defined domains. In Proceedings of the Eighth Annual IEEE Symp. on Logic in Computer Science, LICS 1993 (1993), M. Vardi, Ed., IEEE Computer Society Press, 86-97.
Plotkin, G.D., ”Lambda-definability and logical relations”. Memorandum SAIRM-4, University of Edinburgh, October 1973.
Reynolds, J.C., ”The meaning of types - from intrinsic to extrinsic semantics”. BRICS Report Series RS-00-32, University of Aarhus, December 2000.
Reynolds, J.C., What do types mean? - from intrinsic to extrinsic semantics, Essays on Programming Methodology, Springer (2003) 309 - 327.
Stoltenberg-Hansen, V., Lindstr¨om, I., and Griffor, E.R., ”Mathematical Theory of Domains”, vol. 22
of Cambridge Tracts in Theoretical Computer Science. Cambridge University Press, 1994.
