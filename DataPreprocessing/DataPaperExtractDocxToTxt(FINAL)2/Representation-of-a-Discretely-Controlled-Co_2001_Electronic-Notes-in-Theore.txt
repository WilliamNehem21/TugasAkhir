Electronic Notes in Theoretical Computer Science 42 (2001)
URL: http://www.elsevier.nl/locate/entcs/volume42.html 12 pages


Representation of a Discretely Controlled Continuous System in Tense Arithmetic

Tetsuya Mizutani a, Shigeru Igarashi a and Masayuki Shio b
a Institute of Information Science, University of Tsukuba, 1-1-1, Tennodai,
Tsukuba 3050006, JAPAN
b College of Community Development, Tokiwa University, 1-430-1, Miwa, Mito 3108585, JAPAN


Abstract
Specifications for a vehicle control system, as an example of discretely controlled continuous systems, are represented and verified in a formal system called tense arithmetic for concurrent programs with rational number time. In this formalism, computational sequences are characterized, or indexed, by spurs that are generaliza- tions of program schedulers and that are also temporal propositions. Our formalism describes analysis of the wake-up time of the next action from an observation time, and we obtain the actual rational time value for when the next action will occur. Additionally, we introduce the continuous variables with their first- and second- order derivatives, to analyze and verify programs that control discretely certain continuously physical or other external systems.

Introduction
In this paper we represent and analyze a vehicle control system [6], as an example of discretely controlled continuous systems, in tense arithmetic [8] (TA for short) for the verification of concurrent programs involving rational number time. This formalism has three characteristics. First, it deals with rational time, called tense, explicitly. Second, it interprets each formula P in an extended theory of rationals by its tense, denoted by [P♩, that is, the time length between an observation time, say t, and the time when P holds for the first time after t. (∞ is introduced as the abbreviation of [false♩.) In addition, we introduce the futurity operator “ ; ” that forwards the observation time to the future. Third, the observation time t is treated as the present tense or
now, i.e., 0, in the logic, so that we can dispense with the time variable t.
In this paper, we extend this formalism to treat continuous systems. To do this, the continuous variables with their first- and second-order derivatives will be introduced. Using these variables, we can analyze and verify programs that control discretely certain continuously physical or other external systems.
◯c 2001 Published by Elsevier Science B. V. Open access under CC BY-NC-ND license.


Many formalisms to verify realtime systems have been proposed, including the temporal logic [9], TCSP [4], the duration calculi [2], the hybrid automata [1], [3], [14], and so on, as well as our work [6], [7], [11] that is closely related to the present paper. Specifications of an autonomous vehicle control system are found and verified in [13]. The duration calculi and the hybrid automata can treat only first-order differential equations, while our formalism can treat both lower- and higher-order ones.
Section 2 shows the formal system and the semantics of TA, the original version of which can be found in [8]. A vehicle control system is then intro- duced and analyzed in Section 3. In this example, we consider the situation of a car merging with traffic at a T junction. We formulate this problem, then formally analyze and verify the conditions under which the merging car does not crash into others.

Tense arithmetic
Syntax of language
Let TQ be any appropriate first-order theory of rational numbers. Let V Q be the set of the free variables of TQ. An element of V Q is called a rational variable.
We extend TQ to TQ by adding individual constants J , J1, J2, ·· ·, corre- sponding to program variables over rational numbers, called special rational constants; by adding predicate constants l, l1, l2, ·· ·, corresponding to labels within programs; and by adding predicate constants γ˙ , γ˙1, γ˙2, ·· ·, correspond- ing to atomic spurs by which we construct spurs. Those predicate constants are called special boolean constants. The spurs are generalizations of program schedulers (see section 2.4). Moreover, we introduce other special rational constants ξ, ξ1, ξ2, ·· ·, η, η1, η2, ··· called continuous variables with their (first- and second-order) derivatives ξ', ξ' , ξ' , ·· ·, η', η' , η' , ·· ·, ξ'', ξ'', ξ'', ·· ·,
1	2	1	2	1	2
η'', η'', η'', ··· to describe continuous systems.
1	2
Terms and formulas of TA are called tense terms and tense formulas, re-
spectively, in order to distinguish them from those of TQ. Let V T be the set
of countably infinite tense variables.
Definition 2.1 Tense terms are defined as follows:
A term e of TQ is a tense term, which is called a rational tense term,
A tense variable x is a tense term,
For a formula P of TQ, [P♩ is a tense term, called the tense of P ,
If s is a tense term, then s; e, s; x and s; [P♩ are tense terms.	✷
The symbol [ ♩ will be called the tense symbol, while the semicolon “ ; ” as a symbol will be called the futurity operator, which is left-associative. s is called a prefix of s; x. In general, s is called a prefix of s; s1.


Definition 2.2 Tense formulas are defined as follows:
For a formula P of TQ, P is a tense formula,
If s and s1 are tense terms, then s = s1 and s ≤ s1 are tense formulas,
If x is a tense variable, r is a rational variable, and F and G are tense formulas, then ¬F , F ∨ G, ∀xF and ∀rF are tense formulas.	✷
A tense indicates the time relative to the observation time, called now. As a tense term, a rational expression e whose value is r represents the tense r. 0 represents now. The tense of P denoted by [P♩ is the earliest time when P holds after now. For the futurity operator “ ; ”, here are a few examples:
2.0; [J = 0♩ designates the tense when the program variable J reaches the value 0 after 2.0 time units, and
2.0; [J = 0♩ = ∞ reads “J will never come to be 0 after 2.0”.

Sequents and proof system
Definition 2.3 For tense formulas F1, ··· , Fm, G1, ··· , Gn (m, n ≥ 0),
F1, ··· , Fm → G1, ··· , Gn
is a sequent (of TA). The case that m = 0 is understood as ‘true’ and the case
n = 0 as ‘false’.	✷
A sequent F1, ··· , Fm → G1, ··· , Gn intuitively means that F1 ∧· · ·∧Fm ⊃ G1∨· · ·∨Gn holds for any ‘worlds’ (changing with time) and at any observation time. Thus, the sequent expresses the same thing as the formula ✷(F1 ∧· · · ∧ Fm ⊃ G1 ∨ ··· ∨ Gn) in temporal logic.
Definition 2.4 The symbol ∞ is an abbreviation of [false♩, so that
∞ = [false♩,
and “ : ” is defined by

In the definitions of “ : ”, each expansion rule on the left in the table pre- cedes the one to the right, and each upper precedes the lower, if there exists ambiguity to expand x : F .	✷
The colon “ : ” as a symbol is called the coincidental operator, which intu- itively means that the formula F is true at the tense x. As in s; [P♩, s or any prefix within s is called a prefix of s : F .


Definition 2.5 The inference rules of TA consist of the LK-like rules having the same form as the structural rules and the rules for the logical operators
¬, ∨ and ∀ of LK, with the only modification being that the rules for ∀x and
∀r are differentiated from each other. Additionally, the rule for futurity is adopted as follows:
→ x : F
→ F ∧ 0 ≤ s1 ∧ ··· ∧ 0 ≤ sn
where s1, ··· , sn are all of the prefixes of tense terms, which are arguments of equalities or inequalities in F .	✷
Definition 2.6 A derivation of TA consists of sequents arranged in tree form. An initial sequent, i.e., a leaf, of the derivation is any of the following:
identic sequent:  F → F,
axiomatic sequent:   → A, for any axiom A of TA.
Each inference results from one of the inference rules by a usual substitu- tion.
The end sequent, i.e., the root of the derivation, S is said to be derivable
(in TA), and the whole derivation is called a proof of S.	✷
Definition 2.7 If a sequent of the form → F is derivable, we say that F is
provable (in TA) and F is a theorem (of TA), which fact will be denoted by
▶ F .	✷

Axioms
We introduce the logical, or, proper axioms of TA. It must be noted that r and r1 are restricted within rationals (not containing ∞). The symbols = and ≤ are the same as those used in TQ and TQ, so that 0 < 1, ∀rr1(r + r1 = r1 + r), J = J1 ⊃ J +1 = J1 + 1, etc., hold, for example.
the ordinal order axioms for ≤.
axioms for tense:
tense axiom:   ∀x (∃r (x = r) ∨ x = ∞),
‘Never Land’ (unreachability) axiom:	∀r(r < ∞),
truth axiom:   [true♩ = 0,
futility axiom:	∀x (∞ = x; ∞),
axioms for futurity “ ; ”:
present axiom:	∀x (0 ≤ x ⊃ 0; x = x),
passage axiom:	∀xy (x ≤ x; y),
duration axiom: ∀rr1 (0 ≤ r1 ∧ r; r1 = r + r1 ∨ r1 < 0 ∧ r; r1 = r),
prefix substitution axiom:	∀xyz (x = y ⊃ x; z = y; z),
axioms for tense symbol [ ♩:
idempotent axiom:	[P♩ = [P♩; [P♩,


precedence axiom:	∀x (0 ≤ x ∧ x : P ⊃ [P♩≤ x),
advance consequence axiom:	[Q♩ ≤ [P♩, for any P and Q such that P ⊃ Q is a theorem of TQ that includes no continuous variable,
monotonicity axiom:	∀xy (x ≤ y ⊃ x; [P♩≤ y; [P♩),
theorems of TQ as axioms:	Any theorem of TQ is an axiom of TA.
C	C
axiom for continuous variables:
ξ' = c1 ∧ ξ = c2 ∧ ∀r (0 ≤ r < [ξ'' /= c♩ ⊃ r : (ξ'' = c)) ⊃
∀r (0 ≤ r ≤ [ξ'' /= c♩ ⊃ r : (ξ = c r2 + c1r + c2) ∧ r : (ξ' = cr + c1))
From the axiom (vi), we can treat second-order differential equations in TA. Obviously, our formalism can treat higher-order derivatives when the axioms corresponding to them that are similar to (vi), are introduced.

Spurs and program axioms
Let us suppose that each atomic spur satisfies the condition that it returns to being false after it has become true within the finite time period.
Definition 2.8 Let γ˙ be an atomic spur. A spur γ is [γ˙ ♩; [¬γ˙ ♩, which ex-

presses the time when γ˙
changes into false after γ˙
happens.	✷

Using spurs, we can represent each n-step execution of a process even if no actual time value of execution is given. For example, the tense of a 2- step execution can be written as γ; γ, which is an abbreviation of [γ˙ ♩; [¬γ˙ ♩ ; [γ˙ ♩; [¬γ˙ ♩. From axioms (4c) and (3a) with the rule for futurity, the fact that γ < γ; γ is guaranteed, while [γ˙ ♩ = [γ˙ ♩; [γ˙ ♩ by axiom (4a).
We express a program by some program axioms in the form of sequents, each of which represents one action step. Each program axiom is used as an initial sequent of a proof. A program axiom may contain a spur, a cur- rent program label, some next labels, some conditions and some actions, e.g., assignments. Additionally, we axiomatize the axiom of conservation [5], by which the values of the program variables are kept unchanged as long as no action is performed. The spurs are generalizations of schedulers of processes. We consider a multi-CPU parallel program system in which each process has its own CPU. So, we assign distinct spurs α, β, ··· as the schedulers to the various processes. Program labels are supposed to be exclusive of each other process-wise.

Semantics
Let Q be the standard model of rational numbers. An assignment ρQ of TQ is a function such that ρQ : V Q → Q. Q as a model of TQ can be expanded to a model M of TQ by adding an interpretation of the special constants. Each special constant may have different values in different models.
We regard the set Q + {∞} as tense. For ∞ we shall assume r ∈ Q ⇔
r < ∞, r + ∞ = ∞ + r = ∞ every r ∈ Q, and inf ∅ = ∞, ∅ denoting the


empty set.
An assignment ρ of TA is a pair ⟨ρQ, ρT ⟩ of functions, where ρQ is an assignment of TQ as above and ρT is a function, called an assignment to V T , such that ρT : Q→ V T → Q + {∞}, sending a tense variable x onto ρT (t, x). ρQ(e) and ρQ(P ) denote the expression and the formula obtained from, re- spectively, e and P by substituting the values specified by the assignment ρQ in place of the free variables.
The changes of models are described by a locus χ that is a function from a rational time to models, χ : Q→ E, where E is the set of such expansions designated by M. For a special rational constant J and a special boolean constant l, χ(t, J ) and χ(t, l) designate the rational value of J and the truth value of l at t(∈ Q) on χ, respectively. Whenever an assignment ρQ of TQ,
a locus χ and a time t(∈ Q) are given, the truth of a formula P of TQ is
determined. ρQ, χ(t) |= P expresses that P holds on ρQ and χ, at t, that is,
χ(t, ρQ(P )) = true.


Definition 2.9 An increasing rational sequence (ri)i=0,1,2,··· is discrete if it is either finite or contains arbitrarily large rationals.	✷


Definition 2.10 A function f : Q→ S, where S is an arbitrary set, is called a right-continuous discrete step function if and only if f (t) = xi for ri ≤ t < ri+1 for some xi belonging to S and a discrete rational sequence (ri)i=0,1,2,···.  ✷


Discreteness postulate. Every locus χ, except for continuous variables and their first-order derivatives, and every assignment ρT to V T must be discrete step functions.	✷
In order to treat continuous variables and their derivatives, we modify the semantics of the original TA [8]. The main modification is that loci are right-continuous step functions, instead of left-continuous.
Postulate for continuous systems. We suppose that each “variable” in the continuous system that we deal with in this paper, as a function sending a real time in a real value [5], [12], is continuous in realtime and is derivable except for (finite or infinite) discrete rational time points. For each rational time value, the value of the function must be rational. Every locus must reflect the values of the continuous variables corresponding to these functions. Additionally, every first-order derivative must be continuous.	✷
Given an assignment ρ of TA, a locus χ and an observation time t(∈ Q), a tense term s is interpreted into a value in Q + {∞} defined below.


Definition 2.11 The valuation ∼ of a tense term for given ρ, χ and t is


defined as follows:

~
ρ,χ
~
ρ,χ
3.	[P♩∼
(t) d=ef
(t) d=ef
(t) d=ef
χ(t, ρQ(e)), ρT (t, x),
min{u| 0 ≤ u, χ(t + u, ρQ(P )) = true}, (min ∅ = ∞),

4. (s; s )∼
(t) d=ef
(s∼
(t) < ∞→ 

1 ρ,χ
ρ,χ

~
ρ,χ
(t) + (0 ≤ s1∼
(t + s∼
(t)) → s1∼
(t + s∼
), 0),

∞).
where s1 is either e, x or [P♩. (a	→	b, c) is McCarthy’s operator [10], meaning “if a then b else c.”			✷
Definition 2.12 The truth valuation # of a tense formula for given ρ, χ and
t is defined as follows:

P # (t) = true
⇔def
~
ρ,χ
(t) = 0,

(s = s )#
(t) = true
⇔def
s∼ (t) = s ∼
(t),

1 ρ,χ
ρ,χ
1ρ,χ

(s ≤ s )#
(t) = true
⇔def
s∼ (t) ≤ s ∼
(t),

1 ρ,χ
ρ,χ
1ρ,χ

(¬F )#
(F ∨ G)#
(t) = true
(t) = true
⇔def
⇔def
F # (t) = false,
F # (t) = true or G#

(t) = true,

ρ,χ
(∀xF )#
(t) = true
⇔def
ρ,χ
#
⟨ρQ, ρ'T ⟩,χ
ρ,χ
(t) = true,	every ρ'T

such that ρ'T (u, y) = ρT (u, y)
each u and each y ∈ V T other than x,

(∀rF )#
(t) = true
⇔def
#
⟨ρ'Q, ρT ⟩,χ
(t) = true,	every ρ'Q

such that ρ'Q(v) = ρQ(v) each v ∈ V Q other than r.✷
Definition 2.13 A locus χ is said to satisfy F if and only if
F # (t) = true,	every ρ and t,
in which case we write χ |= F .
Let P be the set of loci satisfying the discreteness postulate. A locus χ ∈P is said to satisfy the sequent F1, ··· , Fm → G1, ··· , Gn if and only if it holds that
m + n > 0 and χ |= ¬F1 ∨ ··· ∨ ¬Fm ∨ G1 ∨ ··· ∨ Gn. ✷
Definition 2.14 Soundness of derivation. For sequents S1, ·· ·, Sn and S of TA, a derivation S from S1, ·· ·, Sn of TA is sound if and only if every locus χ satisfying all the sequents S1, ··· , Sn also satisfies S.


The soundness theorem of the original TA is guaranteed in [8]. For the modified system, the following soundness theorem can be easily shown in a similar way.
Theorem 2.15 If ▶ F, then χ |= F holds for every χ.	✷

Analysis of a vehicle control system
Let us consider two roads meeting at a T junction. Many cars car1, car2, ··· , carn, carn+1, ··· are running one way on the road at a constant speed v[m/s], and each pair of cars ⟨i, i + 1⟩ has a distance within this pair, ∆i. A car car0 wants to merge between carn and carn+1 with an initial speed 0 and an acceleration a = a0 (> 0) [m/s2] if ∆n is less than or equal to d. The driver’s decision to merge is delayed 0.5 [s] from the moment at which carn reaches a certain “safe” zone, and the beginning of the actual acceleration of the vehicle is delayed 1.5 [s] from the moment of the driver’s decision. Moreover, when the speed of the car is v0(< v), the driver decides to release the accelerator with 0.2
[s] delay, and the actual effect is delayed by 0.3 [s] after the decision. The car
carn+1, on the other hand, will decide to decrease its speed with a deceleration
−b=b0 (< 0) [m/s2] after 0.4 [s] from the time when the distance ∆0 between
car0 and itself will be less than or equal to e. The actual deceleration begins
0.6 [s] after the driver decides to decelerate.
Question: How large should d and e be to avoid a crash between car0 and
carn+1? (The original problem and its solution are found in [6].)

Program axioms
Let us consider a one-dimensional coordinate along the road, whose origin is at the junction. The positions of car0, carn, carn+1 are expressed by η, ξn, ξn+1, respectively. We suppose car0 is waiting at the crossing, that is, η = 0, and it finds the interval ∆n is greater than or equal to d and carn will be closer than or equal to −f . Additionally, let us suppose car0 does not crash into any car when it is at the crossing and that its speed is 0.
The program axioms of car0 are as follows:
Stand-by ∧ ¬Safe ∧ ¬Accel ⊃
(1)
[Safe♩ < α ∧ [Safe♩ : (0.5 = [Accel♩ = α).
¬Accel ⊃ [Accel♩ : (1.5 = [η'' = a♩ = α),
where, Stand-by ≡ η = 0 ∧ η' = 0 ∧ η'' = 0 and Safe ≡ −f ≤ ξn. The axiom
(1) intuitively means that when car0 is at the crossing and finds carn at f , the decision to accelerate (Accel), indicated by the spur α, is done with 0.5
[s] delay. In other words, if Stand-by holds, α arises as soon as Accel holds, and conversely, α does not hold before Accel. The axiom (2) means the actual acceleration begins 1.5 [s] after the decision Accel. Similarly, the deceleration


after the merge is represented as follows:
¬OverSpeed ⊃ [OverSpeed♩ : (0.2 = [ReleaseAccel♩ = α).
¬ReleaseAccel ⊃ [ReleaseAccel♩ : ([η'' = 0) ∧ η' = v♩ = α ≤ 0.3),
where OverSpeed ≡ v0 ≤ η'. This represents that when the speed of the car is v0(< v), the car decides to release the accelerator with 0.2 [s] delay and the actual effect is delayed 0.3 [s] after the decision.
In a similar manner, we represent the axiom of carn as
Cruisingn,
and those of carn+1 as
Cruisingn+1 ∧ ¬Brake ∧ ¬Dangerous ⊃

[Dangerous♩ < β ∧ [Dangerous♩ : (0.4 = [Break♩ = β).



¬Break ⊃ [Break♩ : (0.6 = [ξ''
= −b♩ = β),

where Cruisingi ≡ ξ' = v ∧ ξ'' = 0(i = n, n + 1) and Dangerous ≡ ∆0 ≤ e.
i	i

Analysis
Let us consider an initial condition in which Θ ≡ Stand-by∧ ¬Safe∧ ¬Accel ∧
¬ReleaseAccel∧ ¬Brake ∧ d ≤ ∆n.
From (1) and (2) of the axioms of car0 and the axiom of conservation, it holds that
Θ ⊃ η = 0 ∧ η' = 0 ∧ ∀r (0 ≤ r < [η'' = a♩⊃ r : (η'' = 0))

∧ [Safe♩ : ([η'' = a♩ = 0.5+ 1.5).
By the axiom of continuous variables,
Θ ⊃ ∀r (0 ≤ r ≤ [η'' = a♩⊃ r : (η = 0) ∧ r : (η' = 0)).

Thus, (10)

Θ ⊃ [η'' = a♩ : (η = 0 ∧ η' = 0).

From this fact and from (3),
Θ ⊃
(11)
[Safe♩;2 : (η = 0 ∧ η' = 0 ∧ ∀r (0 ≤ r < [η'' = 0♩ ⊃ η'' = a)).
Therefore, we have
Θ ⊃

(12)
[Safe♩;2 : ∀r (0 ≤ r ≤ [η'' = 0♩ ⊃ r : (η = a r2 ∧ r : η' = ar)).

from the axiom of continuous variables. This represents the position and speed of car0 once it has accelerated.


Furthermore,
¬OverSpeed	⊃

(13)
[OverSpeed ♩ : ∀r(0 < r ≤ [η'' = 0♩ ⊃ η' = ar + v0)
∧ [OverSpeed ♩ : (0.2 < [η'' = 0♩≤ 0.2+ 0.3).

by (12), (3) and (4). Therefore, we have v − 0.5a ≤ v0 < v − 0.2a since η' = v.
On the other hand, after deceleration begins the car drives as Θ ⊃

(14)


Thus, c1
[η'' = 0♩ : (η = c1 ∧ η' = v ∧
∀r (0 ≤ r ⊃ r : (η = vr + c1) ∧ r : (η' = v))).
v2 holds by (12).

Similarly, we have the behavior of carn+1 as
Θ ∧ ∆n = r1 ⊃ [Safe♩ : (ξn+1 = −f − r1 ∧ ξ'

= v)

(15)
∧ ∀r (0 ≤ r ≤ [ξ''
= −b♩ ⊃

r : (ξn+1 = vr − f − r1) ∧ r : (ξ'
= v)),




(16)
Θ ⊃ [Dangerous♩;1 :
(ξn+1 = c2 ⊃
∀r(0 ≤ r ⊃ r : (ξn+1 = −b r2 + vr + c2) ∧ r : (ξ'



= v − br))),

2	n+1
We solve the minimum values of d and e. If car0 decides to accelerate when f = 2v, and the condition d = e holds, then these are the minimum values. From (15) and (16), we can get:
Θ ⊃

(17)
[Safe♩;2 + 1 :
∀r (0 ≤ r ⊃ r : (ξn+1 = −b r2 + vr + v − d) ∧ r : (ξ'


= v − br)),

2
which indicates the position and the speed of carn+1.
n+1

From this formula with (8) under the conditions η = ξn+1 and η' = ξ'	,
i.e., car0 has just collided with carn+1, we have the minimum values of d and
e whenever the cars do not crash as:

(18)
d = e =
ab − 2bv + v2
.
2(a − b)

Finally, we calculate and get the solution when the actual (and reasonable) values are given. For example, suppose a = −b = 5[m/s2] and v = 50/3[m/s] (60 km/h). Hence, we have a solution that if d = e > 755/36[m] (about 21m), carn+1 does not crash into car0.

Conclusions
We have briefly demonstrated a new formalism TA, for parallel and realtime controlled programs, to analyze two intelligently controlled systems, briefly. In the analysis of a vehicle control system, we have shown, using the axiom of continuous variables, the actual and reasonable values necessary to avoid a collision between two vehicles.
Our future work is that we will make the axiom more sophisticated, in order to describe every n–th order derivative in a uniform manner.

Acknowledgements
This work was supported in part by Grants-in-Aid for Scientific Research from the Japanese Ministry of Education, Science and Culture (Nos. 09680322 and 10680332) and by Fuji Xerox.

References
Alur, R., Fix, L. and Henzinger, T. A. : Event-clockautomata: a determinizable class of timed automata, Theor. Comp. Sci., (1999), pp. 252–273.
Chaochen, Z.: Duration calculi: an overview, International Institute for Software Technology, The United Nations University, UNI/IIST Report, 10 (1993).
Henzinger, T. A. and Kopke, P. W.: Discrete-time control for rectangular hybrid automata, Theor. Comp. Sci., 211 (1999), pp. 369–392.
Hoare, C. A. R. : Communicating sequential processes, Prentice-Hall Internat., 1985.
Igarashi, S : The ν-conversion and an analytic semantics, R. E. A. Mason (ed.),
Information Processing 83, Elsevier Sci. Publ. B. V., (1983), pp. 769–774.
Igarashi, S., Mizutani, T., Shirogane, T. and Shio, M :  Formal analysis for continuous systems controlled by programs, Concurrency and Parallelism, Programming, Networking, and Security, Lecture Notes in Comp. Sci., 1179 (1996), pp. 347–348.
Igarashi, S, Shio, M., Shirogane , T. and Mizutani, T. : Formal verification and evaluation of execution time in the envelope theory, Concurrency and Parallelism, Programming, Networking, and Security, Lecture Notes in Comp. Sci., 1179, (1996), pp. 299–308.
Igarashi, S., Shirogane, T., Shio, M. and Mizutani, T. : Tense arithmetic I: formalization of properties of programs in rational arithmetics, Tensor, N. S., 59 (1998), in printing.
Kr¨oger, F : Temporal logic of programs, Springer-Verlag, New York, 1987.


McCarthy, J. : A basis for a mathematical theory of computation, P. Braffort and D. Hirschberg (eds.), Computer Programming and Formal Systems, Series of Studies in Logic and the Foundations of Mathematics, North-Holland Publ. Co., Amsterdam, 1963, pp. 33–70.
Mizutani, T., Igarashi, S., Tomita, K. and Shio, M. : Representation of discretely controlled continuous systems in software-oriented formal analysis, Advances in Computer Science, Lecture Notes in Comp. Sci., 1345 (1997), pp. 110–120.
Takeuti, G : Two applications of logic to mathematics, Princeton Univ. Press, Princeton, 1978.
Tomita, K., Igarashi, S., Hosono, C., Mizutani, T. and Tsugawa, S. : Representations of Autonomous Realtime Systems, TENSOR, N. S., 59 (1998), in printing.
Xuandong, L., Hung, D. V. and Tao, Z : Checking hybrid automata for linear duration invariants, Advances in Computer Science, Advances in Computer Science, Lecture Notes in Comp. Sci., 1345 (1997), pp. 166–180.
