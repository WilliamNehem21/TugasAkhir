Electronic Notes in Theoretical Computer Science 44 No. 1 (2001)
URL: http://www.elsevier.nl/locate/entcs/volume44.html 15 pages


When is a function a fold or an unfold?

Jeremy Gibbons
Oxford University Computing Laboratory, Wolfson Building, Parks Road, Oxford OX1 3QD, United Kingdom
Graham Hutton
Languages and Programming Group, School of Computer Science and IT, University of Nottingham, Jubilee Campus, Wollaton Road, Nottingham NG8 1BB, United Kingdom
Thorsten Altenkirch
Languages and Programming Group, School of Computer Science and IT, University of Nottingham, Jubilee Campus, Wollaton Road, Nottingham NG8 1BB, United Kingdom


Abstract
We give a necessary and sufficient condition for when a set-theoretic function can be written using the recursion operator fold, and a dual condition for the recursion operator unfold. The conditions are simple, practically useful, and generic in the underlying datatype.

Introduction
The recursion operator fold encapsulates a common pattern for defining pro- grams that consume values of a least fixpoint type such as finite lists. Dually, the recursion operator unfold encapsulates a common pattern for defining pro- grams that produce values of a greatest fixpoint type such as streams (infinite lists). Theory and applications of fold abound — see [11,4] for recent sur- veys — while in recent years it has become increasingly clear that the less well-known concept of unfold is just as useful [5,6,10,13,15].
Given the interest in fold and unfold, it is natural to ask when a program can be written using one of these operators. Surprisingly little is known about this question. This article gives a complete answer for the special case in which programs are total functions between sets. In particular, we give a necessary and sufficient condition for when a set-theoretic function can be written using fold, and a dual condition for unfold. The conditions are simple, practically
◯c 2001 Published by Elsevier Science B. V. Open access under CC BY-NC-ND license.


useful, and generic in the underlying datatype. However, our proofs are set- theoretic, and make essential use of classical logic and the Axiom of Choice; hence our results do not generalize to categories of constructive functions 1 .

Fold and unfold
In this section we review the categorical treatment of fold and unfold in terms of initial algebras and final coalgebras; for further details see [18,20,14,1].
Suppose that we fix a category C and a functor F : C → C. An algebra is pair (A, f ) comprising an object A and an arrow f : F A → A, and a homomorphism h : (A, f ) → (B, g) from one such algebra to another is an arrow h : A → B such that the following square commutes:
F A	Fh	 F B 

f	g

J	J 
A	h	 B 
An initial algebra is an initial object in the category with algebras as objects and homomorphisms as arrows. We write (µF, in) for an initial algebra, and fold f for the unique homomorphism h : (µF, in) → (A, f ) from the initial algebra to any other algebra (A, f ). That is, fold f is defined as the unique arrow that makes the following square commute:
F (µF )	F (fold f )	 F A 


in	f

J	J 
µF	fold f	 A 
The dual notions of coalgebra, cohomomorphism, and terminal coalgebra are defined similarly. We write (νF, out) for a terminal coalgebra,and unfold f for the unique cohomomorphism h : (A, f ) → (νF, out) from any coalgebra (A, f ) to the terminal coalgebra. That is, unfold f is defined as the unique arrow that makes the following square commute:
A	unfold f	 νF 

f	out
J	J 
F A	F (unfold f ) F (νF )
In the literature, fold f and unfold f are sometimes written as (|f|) and [(f )|♩,

1 Such as the effective topos or the category of ω-sets.

and called catamorphisms and anamorphisms respectively.
Example: finite lists
Suppose that we define a functor L : SET → SET by LA = 1 + (N ×A) and Lf = id1+(idN×f ),where N is the set of natural numbers. Then an algebra is a pair (A, f ) comprising a set A and a function f : 1+(N×A) → A. Functions of this type can always be uniquely decomposed into the form f = [g, h] for some other functions g : 1 → A and h : N × A → A. A homomorphism f : (A, [g, h]) → (B, [i, j]) is a function f : A → B such that f · g = i and f · h = j · (idN × f ).
The functor L has an initial algebra (µL, in) = (List (N), [nil , cons]),where List (A) is the set of all finite lists with elements drawn from A,and nil : 1 → List (N) and cons : N × List (N) → List (N) are constructors for this set. Given any other set A and two functions i : 1 → A and j : N × A → A,the function fold [i, j]: List (N) → A is uniquely defined by the following two equations:
fold [i, j] · nil   =  i
fold [i, j] · cons  =  j · (idN × fold [i, j])
That is, fold [i, j] processes a list by replacing the nil constructor at the end of the list by the function i, and each cons constructor within the list by the function j. For example, the function sum : List (N) → N that sums a list of naturals can be defined by sum = fold [zero, plus], where zero : 1 → N and plus : N × N → N are given by zero () = 0 and plus (x, y) = x + y.
We will use this datatype in examples later. For notational simplicity, we
will write ‘[ ]’ for nil (), and ‘x : xs’ for cons (x, xs). Thus, we might have written the above definition of fold more perspicuously as:
(fold [i, j]) [ ]	=	i
(fold [i, j]) (x : xs)	=	j (x, (fold [i, j]) xs)
Example: streams
Suppose that we define a functor S : SET → SET by SA = N × A and Sf = idN × f . Then a coalgebra is a pair (A, f ) comprising a set A and a function f : A → N × A. Functions of this type can always be uniquely decomposed into the form f = ⟨g, h⟩ for some other functions g : A → N and h : A → A. A cohomomorphism f : (A, ⟨g, h⟩) → (B, ⟨i, j⟩) is a function f : A → B such that i · f = g and j · f = f · h.
The functor S has a terminal coalgebra (νS, out) = (Stream(N), ⟨head, tail⟩),where Stream(A) is the set of all streams with elements drawn from A, and head : Stream(N) → N and tail : Stream(N) → Stream(N) are destructors for this set. Given any other set A and two functions g : A → N and h : A → A, the function unfold ⟨g, h⟩ : A → Stream(N) is uniquely defined by the

following two equations:
head · unfold ⟨g, h⟩	=	g
tail	· unfold ⟨g, h⟩	=	unfold ⟨g, h⟩ · h
That is, unfold ⟨g, h⟩ produces a stream by using the function g to produce the head of the stream, and the function h to generate another value that is then itself unfolded in the same way to produce the tail of the stream. For example,the function from : N → Stream(N),which produces a stream of naturals ascending in steps of one,can be defined by from = unfold ⟨idN, succ⟩ where succ : N → N is given by succ x = x + 1.


When is an arrow a fold or an unfold?
The fold operator encapsulates a common pattern for defining an arrow of type µF → A. It is natural then to ask when an arrow of this type can be written using fold. More precisely, when can an arbitrary arrow h : µF → A be written in the form h = fold f for some other arrow f : FA → A?
A technically complete,but nonetheless unsatisfactory,answer to this ques- tion is provided by the universal property of the fold operator [18],which can be stated as the following equivalence:
h = fold f	⇔	h · in = f · F h 
The ⇒ direction of this equivalence states that fold f is a homomorphism from the initial algebra (µF, in) to another algebra (A, f ), while the ⇐ direction states that any other homomorphism h between these two algebras must be equal to fold f . Taken as a whole, the universal property expresses the fact that fold f is the unique homomorphism from (µF, in) to (A, f ).
The universal property provides a complete answer to our question — h can be written in the form fold f precisely when h · in = f · F h — but is less helpful than it might be because it requires that we already know f . Given a specific h, however, the universal property can often be used to guide the construction of an appropriate f [11],but we do not consider this a completely satisfactory answer either,because this approach is only a heuristic,and it is sometimes difficult to apply in practice.
The problem with the universal property is that it concerns an intensional aspect of h, namely the function f that forms part of its implementation. Often a condition based on purely extensional aspects is more useful. A partial answer to our question with purely extensional concerns is that every left invertible arrow h : µF → A can be written using fold [20]. Formally, if we assume that there exists an arrow g : A → µF such that g · h = idµF , then the equation h = fold f can be solved for f as follows:


h = fold f
⇔	{ universal property }
h · in = f · F h 
⇔	{ identities }
h · in · idF (µF ) = f · F h 
⇔	{ functors }
h · in · F (idµF ) = f · F h 
⇔	{ assumption }
h · in · F (g · h) = f · F h 
⇔	{ functors }
h · in · F g · F h = f · F h 
⇐	{ substitutivity }
f = h · in · F g 
In summary,we have derived the following implication:
g · h = idµF	⇒	h = fold (h · in · F g)
As an example, the function rev : List (N) → List (N) that reverses a list is its own inverse, and hence it is immediate that rev can be written using fold by the above implication. Note, however, that this implication only provides a partial answer to our question, because the converse is not true in general. That is, not every arrow h : µF → A that can be written using fold is left invertible. For example, the function sum : List (N) → N was written using fold in the previous section,but is not left invertible.
Dually, the unfold operator also satisfies a universal property, which can be used to show that every right invertible arrow of type A → νF can be written using unfold [20]. For example, the function evenpos : Stream(N) → Stream(N) that removes every other element from a stream has a right inverse (any function that inserts an element between each adjacent pair in a stream), and hence it is immediate that evenpos can be written using unfold. However, not every arrow h : A → νF that can be written using unfold is right invertible. For example, the function from : N → Stream(N) was written using unfold in the previous section,but is not right invertible.
As far as we are aware, the invertibility results above are the only known results that state when arbitrary arrows of the correct type can be written using fold or unfold. We conclude this section by noting that much more progress has been made concerning specific kinds of arrows. For example,the fusion law states that the composition of a homomorphism and a fold can

always be written as a fold, while the banana split law states that two folds applied to the same argument can always be written as a single fold [20].



When is a function a fold?
In this section we give a necessary and sufficient condition for when an arrow can be written using fold, for the special case of the category SET in which the arrows are total functions between sets. We dualize the result to unfold in the following section.
The result depends on the following definition:

Definition 4.1 The kernel [17] of a function f : A → B is the set of pairs of elements that are identified by f :
ker f  =  { (a, a') ∈ A × A | f a = f a' }


The main result of this section is a necessary and sufficient condition for when an arbitrary arrow h : µF → A in SET can be written in the form h = fold f for some other arrow f : F A → A.

Theorem 4.2 Suppose that h : µF → A. Then
(∃g : F A → A.	h = fold g)	⇔	ker (F h) ⊆ ker (h · in)

(Another way of saying this is that h is a fold iff ker h is a congruence under in; that is,writing Rel(F )(R) for the relational lifting to a relation on F A of relation R on A [12],iff (x, y) ∈ Rel(F )(ker h) implies (in x, in y) ∈ ker h.)
The crux of the proof is the well-known observation that inclusion of kernels is equivalent to the existence of ‘postfactors’:

Lemma 4.3 Suppose that f : A → B and h : A → C. Then
(∃g : B → C.	h = g · f )	⇔	(ker f ⊆ ker h ∧ B → C /= ∅)

Proof. The proof is straightforward. For the ⇒ direction, assume that g :
B → C and h = g · f ; then clearly B → C /= ∅,and moreover, 


(a, a') ∈ ker f
⇔	{ kernels }
f a = f a'
⇒	{ substitutivity }
g (f a)= g (f a')
⇔	{ h = g · f }
ha = h a'
⇔	{ kernels }
(a, a') ∈ ker h
Conversely, assume that ker f ⊆ ker h and B → C /= ∅, so that either B = ∅ or C /= ∅. When B = ∅, let g be the unique function in B → C; note that g is the ‘empty function’, and so g · f is empty too. Moreover, A = ∅ because of the type of f ,so h is also empty and hence equal to g · f . When C /= ∅,we define gb for b in the range of f by gb = ha for some a with f a = b; this is a proper definition, because if there are two choices a, a' with f a = f a' = b, then ha = h a' also by assumption. For b outside the range of f ,we define gb arbitrarily. By construction,this gives ha = g (f a) for every a.	✷
We also use the following simple fact concerning initial algebras:
Lemma 4.4
µF → A /= ∅	⇒	F A → A /= ∅

Proof. We note that F A → A /= ∅ is equivalent to A = ∅ ⇒ F A = ∅,which implication can then be verified as follows:
A = ∅
⇒	{ µF → A /= ∅ } 
µF = ∅
⇒	{ in : F (µF ) → µF }
F (µF )= ∅
⇒	{ µF = ∅ = A }
F A = ∅
✷
Proof of Theorem 4.2 Given the two lemmata above, the proof of the theorem is almost embarrassingly simple:


∃g : F A → A.	h = fold g
⇔	{ universal property }
∃g : F A → A.	h · in = g · F h 
⇔	{ Lemma 4.3 }
ker (F h) ⊆ ker (h · in) ∧ F A → A /= ∅
⇔	{ Lemma 4.4, h : µF → A }
ker (F h) ⊆ ker (h · in)
✷













Remark 4.5 For the type List (A) of finite lists with elements drawn from A, with constructors nil : 1 → List (A) and cons : A × List (A) → List (A), Theorem 4.2 reduces to stating that an arbitrary function h : List (A) → B can be written directly as a fold precisely when the lists that are identified by h are closed under cons,in the sense that for all x, xs, ys,
h xs = h ys  ⇒  h (x : xs) = h (x : ys)

Example 4.6 If we define sum : List (N) → N by the equations
sum []     =  0
sum (x : xs)  =  x + sum xs
then it is easy to show that the lists identified by sum are closed under cons:
sum (x : xs) = sum (x : ys)
⇔   { definition of sum }
x + sum xs = x + sum ys
⇐   { substitutivity }
sum xs = sum ys
Hence, sum can be written directly using fold.
Example 4.7 In contrast, if we define a function stail : List (N) → List (N) (for ‘safe tail’) by the equations
stail []     =  [ ]
stail (x : xs)  =  xs
then a simple counterexample verifies that the lists identified by stail are not closed under cons: for example, with xs = [ ] and ys = 0 : [ ], we have stail xs = [ ] = stail ys, but stail (1 : xs) = [ ] /= 0 : [ ] = stail (1 : ys). Therefore stail cannot be written directly as a fold.
Example 4.8 For the type List (R) of finite lists of reals,consider the problem of computing floorsum = floor · rsum, where rsum : List (R) → R sums a list of reals and floor : R → Z rounds a real r down to the largest integer at most r. Because the result is an integer,one might wonder whether floorsum can be carried out as a fold to integers,thereby avoiding the computationally more expensive real arithmetic. It cannot: we have floorsum (0.3 : [ ]) = floorsum (0.6 : [ ]),but floorsum (0.5: 0.3: [ ]) /= floorsum (0.5: 0.6: [ ]).
On the other hand, the reverse composition sum · map floor , which floors every element of the list before summing,can be written as a fold: an argument similar to Example 4.6 applies. This is an instance of deforestation [24], an optimisation whereby two computations are combined into one and the intermediate data structure (here of type List (Z)) is eliminated.
Remark 4.9 For the type Tree(A) of binary trees with constructors leaf : A → Tree(A) and node : Tree(A) × Tree(A) → Tree(A),Theorem 4.2 reduces to stating that an arbitrary function h : Tree(A) → B can be written directly as a fold precisely when the trees that are identified by h are closed under node,in the sense that for all t, u,
h t = h t ' ∧ h u = h u'  ⇒  h (node (t, u)) = h (node (t', u'))

Example 4.10 For another deforestation example,consider flatsum = sum · flatten, where flatten : Tree(A) → List (A) generates a list of the elements of a tree. The intermediate list in flatsum can be eliminated,because
flatsum (node (t, u))
=   { definition of flatsum }
sum (flatten (node (t, u)))
=	{ definition of flatten }
sum (flatten t ++ flatten u)
=	{ sum distributes over ++ }
sum (flatten t)+ sum (flatten u)
=	{ definition of flatsum }
flatsum t + flatsum u
from which we conclude that trees identified under flatsum are closed under
node. (Here,‘++’ concatenates two lists.)
Example 4.11 The predicate bal : Tree(A) → B that holds of tree iff it is bal- anced (all the leaves at the same depth) is not a fold: with tree t being balanced and of depth 1, and tree u being balanced and of depth 2, both t and u are identified by bal (both yielding true),yet bal (node (t, t)) /= bal (node (t, u)).
Example 4.12 However,the function dbal : Tree(A) → N × B that computes a pair,the depth of the tree and whether it is balanced,is a fold. Because
depth (node (t, u))  =  1 + max (depth t, depth u)
bal (node (t, u))   =  bal t ∧ bal u ∧ depth t = depth u
trees identified by dbal are closed under node. This is an example of a mu- tumorphism [7] or almost homomorphism [3,8]; transforming a function into such a form is an important step towards constructing an efficient data-parallel algorithm for computing it.

When is a function an unfold?
Dualising Theorem 4.2 to unfold is straightforward. The appropriate dual to the notion of the kernel of a function is simply its image:
Definition 5.1 The image of a function f : A → B is the set of elements that are produced by f :
img f  =  { b ∈ B | ∃a ∈ A.  f a = b }


The duality between kernels and images is perhaps not immediately evi- dent, but is revealed by thinking relationally. In particular, if functions are viewed as relations in the obvious way, then the relational composition f◦ · f of a function f with its converse f◦ is precisely the kernel of f ,while the dual composition f · f◦ is (the identity relation on) the image of f .
We can now present our result for unfold, which gives a necessary and sufficient condition for when an arbitrary arrow h : A → νF in SET can be written in the form h = unfold g for some other arrow g : A → F A.
Theorem 5.2 Suppose that h : A → νF. Then
(∃g : A → F A.	h = unfold g)	⇔	img (F h) ⊇ img (out · h)
(Another way of saying this is that h is an unfold iff img h is an invariant of out; that is,writing Pred(F )(P ) for the predicate lifting to a predicate on F A of predicate P on A [12],iff Pred(F )(∈ img h) (out x) follows from (∈ img h) x.)
The crux of the proof is the dual of Lemma 4.3, namely that inclusion of images is equivalent to the existence of ‘prefactors’:
Lemma 5.3 Suppose that f : B → C and h : A → C. Then
(∃g : A → B.	h = f · g)	⇔	(img f ⊇ img h ∧ A → B /= ∅)
Proof. For the ⇒ direction, assume that g : A → B and h = f · g; then clearly A → B /= ∅,and moreover, 
c ∈ img h
⇔	{ images }
∃a.	h a = c
⇔	{ h = f · g }
∃a.	f (g a)= c
⇒	{ g : A → B }
∃b.	f b = c
⇔	{ images }
c ∈ img f
Conversely, assume that img f ⊇ img h and A → B /= ∅, so that either A = ∅ or B /= ∅. When A = ∅, then h is the empty function; let g be the empty function too, so f · g is also empty and hence equal to h. When B /= ∅, we define ga for a ∈ A as follows. Let c = h a; by assumption, c ∈ img f too, so there exists b ∈ B with f b = c, and we define ga to be such a b. If there is more than one such b, it doesn’t matter which one that we choose. By construction,this gives ha = f (g a) for every a.	✷

We also use the dual of Lemma 4.4:
Lemma 5.4
A → νF /= ∅	⇒	A → F A /= ∅
Proof. We note that A → F A /= ∅ is equivalent to A /= ∅⇒ F A /= ∅,which implication can then be verified by combining the two calculations:
A /= ∅
⇒	{ A → νF /= ∅ } 
νF /= ∅
⇒	{ out : νF → F (νF ) }
F (νF ) /= ∅
and
A /= ∅
⇒	{ functions }
νF → A /= ∅
⇒	{ functors }
F (νF ) → F A /= ∅
That is, A /= ∅ implies that F (νF ) /= ∅ and F (νF ) → F A /= ∅, which conjunction in turn implies that F A /= ∅,as required.	✷
Proof of Theorem 5.2 Again,the proof is simple:
Eg : A → F A.	h = unfold g
e	{ universal property }
Eg : A → F A.	out · h = F h · g
e	{ Lemma 5.3 }
img (F h) ≥ img (out · h) Λ A → F A /= ∅ e	{ Lemma 5.4, h : A → νF }
img (F h) ≥ img (out · h)
✷
Remark 5.5 For the type Stream(A) of streams with elements drawn from A, with destructors head : Stream(A) → A and tail : Stream(A) → Stream(A), Theorem 5.2 reduces to stating that an arbitrary function h : B → Stream(A) can be written directly as an unfold precisely when the tail of every stream pro- ducible by h is itself producible by h,in the sense that: img (tail · h) ⊆ img h.

Example 5.6 Consider the function from : N → Stream(N) defined in Sec- tion 2.2. Then (tail · from) n is the stream [n + 1,n + 2,.. .], and in general, img (tail · from) is the set of streams { [n + 1,n + 2,.. .] | n ∈ N }, which is in included in img from, the set of streams { [n, n + 1,.. .] | n ∈ N }. Hence, from can be written directly using unfold.
Example 5.7 In contrast, if we define a function mults : N → Stream(N) such that mults n produces the stream of multiples [0, n,n × 2,n × 3,.. .] ofa natural n,then (tail ·mults) n is the stream [n, n×2,.. .],and so img (tail ·mults) is not included in img mults, which only includes streams whose head is 0. Therefore mults cannot be written directly as an unfold.
Remark 5.8 For the type CoTree(A) of infinite binary trees with elements drawn from A, with destructors root : CoTree(A) → A and left, right : CoTree(A) → CoTree(A), Theorem 5.2 reduces to stating that an arbitrary function h : B → CoTree(A) can be written as an unfold precisely when the left and right of every tree producible by h are themselves producible by h:
img (left · h) ⊆ img h img (right · h) ⊆ img h
Example 5.9 Consider the infinite binary tree with every node labelled by its path,a finite list of booleans recording the left and right turns from the root in order to reach that node. The function paths : 1 → CoTree(List (B)) that produces this tree is not an unfold,because img (left · paths) and img (right · paths) contain trees with singleton lists at their roots,which are not included in img paths,which contains a tree with the empty list at its root.
Example 5.10 In contrast,the more general function pathsfrom : List (B) → CoTree(List (B)) that generates the tree of paths starting from a given path is an unfold,because (left · pathsfrom) bs = pathsfrom (false : bs) implies that img (left · pathsfrom) is included in img pathsfrom,and similarly for right .
Conclusion
We have given the first complete results for when an arbitrary arrow can be written directly as a fold or unfold,for the special case of the category SET . In future work we will investigate whether the results can be generalised to other categories,and to other patterns of recursion,such as primitive (co-)recursion [19,22] and course-of-value (co-)iteration [23].
As well as being interesting from a theoretical point of view, we also ex- pect the results to have practical applications in program optimisation. A well-structured program is typically factored into several phases, each phase generating a data structure that is consumed by the subsequent phase; defor- estation [9,16,21] fuses adjacent phases and eliminates the intermediate data structures. When performed as a compiler optimisation,it yields efficient ob-

ject code without sacrificing the structure and clarity of the source code. Our results can be used to determine when two phases cannot be fused to a fold or an unfold. It might be possible to use an automatic testing system such as QuickCheck [2] to find counterexamples to the appropriate inclusions.
Acknowledgements
We are very grateful to Lambert Meertens, whose suggestions lead to a sub- stantial simplification of our proofs. We also thank the anonymous referees for their useful comments. Graham Hutton was supported by EPSRC grant Structured Recursive Programming ,and together with Thorsten Altenkirch by ESPRIT Working Group Applied Semantics.

References
[1] R. Bird and O. de Moor. Algebra of Programming. Prentice Hall, 1997.
[2] K. Claessen and J. Hughes. Quickcheck: A lightweight tool for random testing of Haskell programs. In Proc. 5th ACM SIGPLAN International Conference on Functional Programming, September 2000.
[3] M. Cole. Parallel programming with list homomorphisms. Parallel Processing Letters, 5(2):191–203, 1995.
[4] J. Gibbons. Calculating functional programs. In Summer School and Workshop on Algebraic and Coalgebraic Methods in the Mathematics of Program Construction, Oxford, April 2000.
[5] J. Gibbons and G. Hutton. Proof methods for structured corecursive programs. In Proc. 1st Scottish Functional Programming Workshop, Stirling, Scotland, August 1999.
[6] J. Gibbons and G. Jones. The under-appreciated unfold. In Proc. 3rd ACM SIGPLAN International Conference on Functional Programming, Baltimore, Maryland, September 1998.
[7] M. M. Fokkinga. Law and Order in Algorithmics. PhD thesis, Universiteit Twente, 1992.
[8] S. Gorlatch. Extracting and implementing list homomorphisms in parallel program development. Science of Computer Programming, 33:1–27, 1999.
[9] Z. Hu, H. Iwasaki and M. Takeichi. Deriving structural hylomorphisms from recursive definitions. In Proc. 1st ACM SIGPLAN International Conference on Functional Programming, 1996.
[10] G. Hutton. Fold and unfold for program semantics. In Proc. 3rd ACM SIGPLAN International Conference on Functional Programming, Baltimore, Maryland, September 1998.


[11] G. Hutton. A tutorial on the universality and expressiveness of fold. Journal of Functional Programming, 9(4):355–372, July 1999.
[12] B. Jacobs. Exercises in coalgebraic specification. In Summer School and Workshop on Algebraic and Coalgebraic Methods in the Mathematics of Program Construction, Oxford, April 2000.
[13] B. Jacobs, L. Moss, H. Reichel, and J. Rutten, editors. Proc. of the First Workshop on Coalgebraic Methods in Computer Science. Elsevier Science B.V., 1998. Electronic Notes in Theoretical Computer Science Volume 11.
[14] B. Jacobs and J. Rutten. A tutorial on (co)algebras and (co)induction. Bulletin of the European Association for Theoretical Computer Science, 62:222–259, 1997.
[15] B. Jacobs and J. Rutten, editors. Proc. of the Second Workshop on Coalgebraic Methods in Computer Science. Elsevier Science B.V., 1999. Electronic Notes in Theoretical Computer Science Volume 19.
[16] J. Launchbury and T. Sheard. Warm fusion: Deriving build-catas from recursive definitions. In Proc. Conference on Functional Programming Languages and Computer Architecture, ACM Press, 1995.
[17] S. Mac Lane. Categories for the Working Mathematician. Number 5 in Graduate Texts in Mathematics. Springer-Verlag, 1971.
[18] G. Malcolm. Algebraic data types and program transformation. Science of Computer Programming, 14(2-3):255–280, September 1990.
[19] L. Meertens. Paramorphisms. Formal Aspects of Computing, 4(5):413–424, 1992.
[20] E. Meijer, M. Fokkinga, and R. Paterson. Functional programming with bananas, lenses, envelopes and barbed wire. In J. Hughes, editor, Proc. Conference on Functional Programming and Computer Architecture, number 523 in LNCS. Springer-Verlag, 1991.
[21] A. Takano and E. Meijer. Shortcut deforestation in calculational form. In Proc. Conference on Functional Programming Languages and Computer Architecture, ACM Press, 1995.
[22] V. Vene and T. Uustalu. Functional programming with apomorphisms (corecursion). Proceedings of the Estonian Academy of Sciences: Physics, Mathematics, 47(3):147–161, 1998.
[23] V. Vene. Categorical Programming with Inductive and Coinductive Types. PhD thesis, Universitity of Tartu, 2000.
[24] P. Wadler.	Deforestation:  Transforming  programs  to  eliminate  trees.
Theoretical Computer Science, 73:231–248, 1990.
