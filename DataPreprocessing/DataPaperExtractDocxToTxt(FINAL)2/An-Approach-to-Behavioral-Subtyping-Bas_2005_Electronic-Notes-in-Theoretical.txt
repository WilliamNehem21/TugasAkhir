Electronic Notes in Theoretical Computer Science 116 (2005) 157–170 
www.elsevier.com/locate/entcs


An Approach to Behavioral Subtyping Based on Static Analysis
Francesco Logozzo 1
STIX - E´cole Polytechnique F-91128 Palaiseau, France

Abstract
In mainstream object oriented languages the subclass relation is defined in terms of subtyping,
i.e. a class A is a subclass of B if the type of A is a subtype of B. In this paper this notion is extended to consider arbitrary class properties obtained by a modular static analysis of the class. In such a setting, the subclass relation boils down to the order relation on the abstract domain used for the analysis of the classes. Furthermore we show how this approach yields a more semantic characterization of class hierarchies and how it can be used for an effective modular analysis of polymorphic code.
Keywords: Abstract Interpretation, Inheritance, Object Oriented Languages, Semantics, Specialized Application Languages, Static Analysis


Introduction
Subclassing is one of the main features of object oriented languages. It allows a form of incremental programming and of code reuse. Moreover it allows the structuring of the code in a hierarchy, so that the classes composing a program (or a library) are organized in a subclass hierarchy. The traditional definition of the subclass relation is that a class A is subclass of class B if its type is a subtype of that of B. Stated otherwise this means that an object that belongs to A can be used in any context that requires an object of B without causing a type-error at runtime. However, the subtyping relation is not strong enough to ensure, for instance, that an object of A does not cause a division by zero,

1 Email: Francesco.Logozzo@Polytechnique.fr



1571-0661 © 2004 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2004.02.074


if the B’s object did not. Behavioral subtyping tries to overcome this problem [7,10].
Roughly speaking the behavioral subtype relationship guarantees that no unexpected behavior occurs when subtype objects replace supertype’s ones. The essential idea is to annotate the class source code with a property in a suitable formal language. Such a property is called the behavior type of the class [7]. Then the behavioral subtyping relation is defined in terms of property implication: A is a subclass of B if its behavioral type implies that of B. The checking of this implication can be done in several ways: by a hand-proof [7], a theorem prover [6] or even at runtime [10]. However, most of the times the formal correspondence between the class semantics and the hand-provided behavioral type is neglected.
In this paper we present an approach to behavioral subtyping based on a modular static analysis [8,9]. The main idea is to analyze a class on a suitable abstract domain to infer a class invariant as well as methods preconditions and postconditions. We call the result of the analysis of A the observable of A, O(A). An observable is a sound approximation of the class semantics, thus it is a behavioral type of A. The correspondence between the semantics of A and O(A) is straightforwardly given by the soundness of the static analysis.

The behavioral subtyping relation boils down to the order ±¯
on the abstract

domain: given two classes A and B, then O(A) ±¯ O(B) means that A preserves
the behavior of B. In other words A is a behavioral subtype of B.
Our approach to behavioral subtyping has several advantages. At first as it is based on static analysis it does not require any human intervention for the annotation of the source code. Furthermore, the observable is ensured to be a sound approximation of the class semantics and it saves programmer

time. Eventually, as the order relation ±¯
is decidable it can be automatically

checked. Thus there is no need of using a theorem prover or to rely on unsound methods as runtime assertion monitoring [10]. Furthermore the definition of the behavioral subtyping in the abstract interpretation framework allows to use standard techniques as for instance domain refinement [4] in order to systematically improve the precision of the observables.
Motivating Examples
As an example, let us consider the classes in Fig. 1. They implement different kinds of bags. They have a method to add an element to the container, add(e) and addSq(e), and to extract an element from it, remove(). However, they differ in the handling of the elements: the method remove() of Queue returns the elements in the same order they have been inserted whereas that of Stack, PosStack and SqStack returns them in the reverse order. Moreover PosStack



class Stack is s : list of int; init() : s = []
add(e): s = e :: s
remove() : let s = e :: ls in s = ls;
return e
Stack
class Queue is s : list of int; init() : s = [];
add(e): s = s :: e
remove() : let s = e :: ls in s = ls;
return e
Queue





class PosStack is s : list of int; init() : s = []
add(e): s = |e| :: s remove() : let s = e :: ls in
s = ls; return e
PosStack
class SqStack is s : list of int; init() : s = []
add(e): s = |e| :: s
addSq(e): s = (e ∗ e) :: s remove() : let s = e :: ls in
s = ls; return e
SqStack


Fig. 1. The paper running examples

and SqStack contain only positive integers and SqStack has a further method that inserts the square of its argument. For the sake of simplicity we do not consider such errors, as removing an element from an empty container.

Class Hierarchy.
It is evident that the four classes have different behaviors. However the three are not totally unrelated, so which is the relation between them? Which are the admissible class hierarchies? To put it another way, when is it safe to replace an object s of Stack with an object q of Queue? The answer depends on the meaning of “safe”. In type theory “safe” means that the use of q at the


place of s will not cause a run-time type error, if s did not cause one. Thus in the example, the classes Stack, PosStack and Queue have the same type so that for instance Stack may be a subtype of Queue and conversely. Only SqStack has to be a subtype of Stack, PosStack or Queue, due to method addSq. This is the only constraint on the possible class hierarchies.
On the other hand, if the context requires that the values extracted from the bag are in the reverse order with respect to the insertion one then it is not “safe” anymore to replace s with q. Thus the order of the elements of a bag is a property, different from types, that induces a different subclassing relationship. In particular, from this point of view Stack and SqStack exhibit the same property, so that Stack may be defined as a subclass of SqStack. Therefore, the admissible class hierarchies are different from that allowed by the subtyping relation.
Systematic Reﬁnement of the Class Hierarchy.
Types and element ordering are both properties of classes that can be dis-
covered once they are analyzed on suitable abstract domains, say T¯ and S¯
respectively. The two domains can be combined together using the reduced product P¯ = T¯ × S¯ [4]. Thus, using the more precise abstract domain P¯ it is possible to infer more precise class properties. In the example SqStack can
only be a subclass of Stack or of PosStack. However it is still admissible to have Stack subclass of PosStack and vice versa. This is essentially a con-

sequence of the fact that P¯
does not capture the sign of the elements in s.

Therefore, P¯ can be combined with the Si¯gn abstract domain [3] in order to

capture such a property:
R¯ = P¯ × Si¯gn. Thereafter, using R¯ we obtain that

Stack can never be subclass of PosStack as it does not preserve the property that all the elements in s are positive integers. Only four class hierarchies preserve the properties captured by R¯: the trivial one in which the subclass
relation is the identity and the three listed in Fig. 2.
Modular Veriﬁcation.
The initial motivation of our work was the application of behavioral subtyping to the modular analysis of polymorphic object oriented code, robust with respect to the addition of subclasses. Consider for example the following function that references an object of type PosStack:
sqrt(PosStack p) : return √p.remove().
One would like to prove sqrt correct for all possible future subclasses of PosStack, as all these may be passed as a parameter. This is possible if the subclasses do not violate the PosStack property that the elements are always



Sta,ck,
Queue
S. ta¸ck¸,¸¸
Queue

PosSt,a,ck SqStack
(a)
.....
.....
PosStack



(b)
¸¸¸
¸¸¸
SqStack


Stack	Queue	PosSt,a,ck

SqStack
(c)

Fig. 2. Admissible class hierarchies using R¯
positive. It is evident that the subtyping-based subclass relation is too weak to ensure this property.
However, if only subclass relations based on the properties encoded in R¯ are
allowed, then all the subclasses of PosStack preserve the required invariants. This reduces the proof that sqrt never performs the square root of a negative number to proving it with PosStack as an argument.

Abstract Semantics
A class A can be seen as a triple ⟨F, init, M⟩ where init is the class constructor, F is a set of fields, and M is a set of methods. For the sake of generality we assume that untyped fields and methods. The concrete semantics  A) of a class A can be given as a set of trees. Roughly, each tree is the semantics of an instance of A and it represents all the possible interactions between the context and the object. For a formal definition of the class semantics we refer the reader to [8].
Given a class A, a static analysis of A is an approximation of its concrete semantics. In the abstract interpretation framework [3] this can be formalized by an abstract semantic function ¯ A) defined on an abstract domain ⟨D¯ , ±¯ ⟩. The elements of D¯ are computer-representable approximations of the concrete

properties and the ±¯
order on the abstract domain D¯
is the abstract coun-

terpart for the logical implication. The correspondence between the concrete and abstract domain is given by a Galois connection ⟨α, γ⟩. The concretiza-

tion of the abstract semantics, γ( ¯ A)), expresses the abstract information available about the semantics of A in concrete terms. It should be a sound approximation of the concrete semantics, i.e.  A) ⊆ γ( ¯ A)).
A behavioral type of a class A is a property of the semantics of A. In this paper we consider behavioral types that are the result of a static analysis of A, and we define them as observables of the class: O(A) = ¯ A).
The advantage of defining the behavioral type of a class as the result of a static analysis of its source is that it can be automatically inferred. Moreover, given two classes A and B, it is sufficient to check if O(A)±¯ O(B) in order to verify if they are in the behavioral subtype relation. In the following we define

a decidable ±¯
relation.


Static Analysis of a Class
Given a class A = ⟨init, F, M⟩, an abstract domain ⟨P¯, ≤¯ ⟩ and an abstraction
of the methods semantics ¯ ·) ∈ [M → P¯ → P¯] it is possible to modularly
analyze A in order to infer a class invariant as well as methods preconditions and postconditions [9,8]. In fact, let us consider the following equation system:

I = I H¯.¯ I
i
I0 = ¯ init)
Ii = ¯ mi)(I)	mi ∈ M.

It can be solved using standard fixpoint iteration techniques [3]. Then it is possible to show that I is a class invariant and {Ii} are the methods postcon- ditions [9]. The method preconditions are obtained by a backward analysis starting from the postcondition: Pi = ¯ < mi)(Ii). Finally, the result of the static analysis of A is:
¯ A) = ⟨I, {mi : Pi → Ii | mi ∈ M}⟩.

Remark 2.1 It is possible to extend the equation system above in order to derive a sound class invariant even when an object exposes a part of its state to the context [9]. Roughly, the abstract domain P¯ must be refined in order
to capture escape information Nevertheless, in order to focus ourselves on the topic of the paper, we make the simplifying assumption that an object does not expose (a part of) its state.

Domain of Observables
The domain of the observables, ⟨O¯ , ±¯ ⟩, is built on the top of the domain used for the analysis, ⟨P¯, ≤¯ ⟩. Hence the elements belong to the set
O¯ = {⟨I, {mi : Pi → Ii}⟩ | I ∈ P¯, ∀i. Pi, Ii ∈ P¯}.
The order relation ±¯ is defined point-wise. Let o1 = ⟨I, {mi : Pi → Ii}⟩ and
o2 = ⟨J, {mj : Qj → Jj}⟩ be two elements 2 of O¯ . Then
o1±¯ o2 ⇐⇒ I≤¯ J ∧ (∀mi. Qi≤¯ Pi ∧ Ii≤¯ Ji).
Roughly speaking, if o1 and o2 are the observables of two classes A and B

then the order ±¯
ensures that A preserves the class invariant of B and that

the methods of A are a “safe” replacement of those with the same name in
B. Intuitively, the precondition condition says that if the context satisfies Qi then it satisfies the inherited method precondition Pi too. Thus the inherited method can be used in any context where its ancestor can. On the other hand, the postcondition of the inherited method may be stronger than that of the ancestor.
Having defined ±¯ , it is routine to check that if P¯ is a complete lattice then

⟨⊥¯ , {mi : T¯
→ ⊥¯ }⟩ is the smallest element of O¯
and ⟨T¯ , {mi : ⊥¯
→ T¯ }⟩ is

the largest one. The join and the meet operations can be defined point-wise. Thus the abstract domain ⟨O¯ , ±¯ ⟩ is a complete lattice.

Moreover, let us suppose that the order relation ≤¯
is decidable. This is

the case of an abstract domain used for an effective static analysis. As ±¯

is defined in terms of ≤¯
and the universal quantification ranges on a finite

number of methods then ±¯
is decidable too. To sum up, we have shown:

Theorem 2.2 Let ⟨P¯, ≤¯ ⟩ be a complete lattice. Then ⟨O¯ , ±¯ ⟩ is a complete

lattice. Moreover, if ≤¯
is decidable then ±¯
is decidable.


Subclassing through Observables
It is now possible to formally give the definition of subclassing as inclusion relation between elements of the abstract domain:
Definition 2.3 Let A and B be two classes, ⟨O¯ , ±¯ ⟩ a domain of observables. Then A is a subclass of B, A Ð B, with respect to the properties encoded by O¯

iff O(A) ±¯
O(B).



2 We use the same index for methods with the same name. For instance Pi and Qi are the preconditions for the homonym method mi of o1 and o2.

Observe that when ⟨O¯ , ±¯ ⟩ is instantiated with the types abstract domain
[2] then the relation defined above coincides with the traditional subtyping- based definition of subclassing [1].
The Def. 2.3 can be visualized by the following diagram:
Static
B,, Semantics   B) 	Analysis	 O (B)
Ḏ	Static	±¯
A 	Semantics   A) 	Analysis	 O J 
This diagram essentially shows how the concept of subclassing is linked to the semantics of classes. It states that when the abstract semantics of A and B are compared, that of A implies the one of B. That means that A refines B
w.r.t. the properties encoded by the abstract domain O¯ . This is in accord
with the mundane understanding of inheritance which states that a subclass is a specialization of the ancestor.
Moreover we have made no-hypothesis on the abstraction of the concrete semantics. In particular we do not differentiate between history properties and state properties, unlike [7], the two being just different abstractions of the concrete semantics. In fact, history properties correspond to trace abstractions and state properties to state abstractions.

Static Checking of Behavioral Subtyping.
The main advantage of our approach is that the subclassing relation can au- tomatically be checked by a compiler: the derivation of class observables is automatic and their inclusion is decidable. As a consequence a compiler can accept subclasses only if they preserve the parent behavior. For instance, this is in the spirit of Eiffel subclassing mechanism [10]. However, the specifica- tion of Eiffel requires to check the preservation of the ancestor invariants at runtime. An interesting future work can be the extension of our work on subclassing to the Eiffel language.

Modular Veriﬁcation.
A major advantage of having the compiler which rejects subclass definitions, that do not preserve the parent properties, is that it enables a form of mod- ular analysis for polymorphic functions. Consider the following polymorphic function f, that references an object of type B:
f(B b) : ... b.m(v) .. ..


Now, suppose to analyze it on the ⟨P¯, ≤¯ ⟩ abstract domain. If the analysis is performed using B then the call b.m(v) resolves to the invocation of the method mB of B. Having an observable of B, the precondition Q and the post- condition J of mB can be used in the analysis, so that the body of the methods
does not need to be analyzed again. Thus, if ¯v ∈ P¯ is the approximation of
the concrete values taken by the variable v then
¯v≤¯ Q =⇒ ¯ mB)(¯v)≤¯ J.
The result of such an analysis is valid for all the invocations f(a) where a is an instance of a class A Ð B. This can be shown as follows. If A Ð B then O(A)
±¯ O(B). Then, by definition of the order relation ±¯ the method mA of A is such
that mA : P → I with Q≤¯ P and I≤¯ J . So:
¯v≤¯ Q≤¯ P =⇒ ¯ mA)(¯v)≤¯ I ∧ I≤¯ J.
Thus J is a sound approximation of the semantics of the method mA. As a matter of fact we have proved the following theorem:
Theorem 2.4 Let A and B two classes such that A Ð B. Let mB be a method of B and mA the homonym method that belongs to A. Let mB : Q → J and mA : P → I. Then
∀¯v ∈ P¯. ¯v≤¯ Q =⇒ ¯ mA)(¯v)≤¯ J.
Hence the analysis of polymorphic code using the superclass is enough to state that the result is valid for all the subclasses. So, it is not necessary to reanalyze the code for each subclass of B.
Domain Reﬁnement.
A further advantage of formalizing the behavioral subtyping in the abstraction interpretation framework is that it is possible to apply well-known abstract domain refinement techniques [4,5] in order to improve the precision of the observables. Hence having more fine-grain class hierarchies. In particular, the use of the reduced product is practical for refining the precision of the captured properties.
An abstract domain of observables must, at least, encapsulate the types abstract domain T¯. On the other hand we have argued before how a further

abstract domain D¯
is needed to capture non-typing properties, e.g. the sign

of the field values. Then the domain of observables can be built on the top

of the reduced product of the two:
P¯ = T¯ × D¯ . As a consequence, from a

well-known result in abstract interpretation (cfr. Th. 10.1.0.2 of [4]) it follows that P¯ is a domain more precise than types, so that the resulting Ð relation is more precise than the subtyping one.


... T¯ ¸¸¸¸	 T¯ ¸¸¸

...
...
straight
¸¸¸
¸¸¸
¸¸
¸¸¸
re.verse
....
...
   
   
pos¸¸¸
¸¸¸¸¸
¸¸¸
¸¸
neg
     
    

¸	..
empty

empty


⊥¯
The abstract domain S¯
⊥¯
The abstract domain Si¯gn


Fig. 3. Abstracts domains expressing the order of elements and their sign

  , , T¯ ¸¸¸¸¸¸¸¸¸
     ,,,,	¸¸¸¸¸ ¸¸¸¸¸¸¸¸¸

,,,,,
¸¸¸¸¸	¸¸¸¸¸¸¸¸¸¸

     
straight¸¸¸¸
,,,,
pos ,,,
¸¸¸¸¸¸¸¸¸
¸
,,,,,,, neg
¸¸¸¸¸
¸¸¸¸
reverse
,,,

¸¸¸,¸,,,,
¸¸¸¸,¸,¸,¸,,,,
¸¸¸,¸,,,

,,,,,, ¸¸¸¸¸
,,,,,,,,	¸¸¸¸¸¸¸
,,,,,, ¸¸¸¸¸

⟨straight, pos⟩ ¸¸	⟨straight, n¸eg⟩
⟨reverse, pos⟩
 ⟨reverse, neg⟩

¸¸¸¸¸¸¸¸¸¸
¸¸¸¸¸
,,,,,

¸¸¸¸¸¸¸¸¸¸¸¸¸¸	,,,,, 
empty

⊥¯
Fig. 4. The abstract domain H¯ = S¯ × Si¯gn

Application to the Examples
In this section we show how the definition of the previous section applies to the examples of Sect. 1.1. At first we show how when instantiating the underline abstract domain with types, the definition of Ð reduces to the traditional subtype-based one.
It is known that types can be seen as an abstract interpretation [2]. We

call T¯
the corresponding abstract domain 3 . Then if we instantiate the Def.



3 Actually in the cited paper the author considered several abstract domains corresponding to several typing system. The abstract domain T¯ that we consider is that of Church/Curry monotypes.

2.3 with the abstract domain T¯ we obtain that:

O(Stack)= O(Queue)= O(PosStack)= 
{⟨s : list of int⟩,
{init : void → void; add : int → void; remove : void → int}},
O(SqStack)= {⟨s : list of int⟩, {init : void → void;
add, addSq : int → void; remove : void → int}}


Therefore the only constraint on the definition of the subclassing relation is that SqStack cannot be the ancestor of any of the other three. This is because O(SqStack) is a subtype of O(Stack) [1].
A different subclassing relation can be obtained using the abstract domain in Fig. 3(a), whom intuitive meaning is to consider if the elements of the list are inserted at the head or tail position. It is worth noting that the order of
the elements is a history property. In that case, the observables using S¯ are:

O(Stack)= O(PosStack)= {⟨s : reverse⟩,
{init : ⊥¯ → empty; add : reverse → reverse;
remove : reverse → reverse}},
O(SqStack)= {⟨s : reverse⟩, {init : ⊥¯ → empty;
add, addSq : reverse → reverse;
remove : reverse → reverse}},
O(Queue)= {⟨s : straight⟩, {init : ⊥¯ → empty;
add : straight → straight;
remove : straight → straight}}.


In this last example, it happens that for instance Queue and Stack can never be in the subclass relation as neither O(Queue) ±¯ O(Stack) nor O(Stack) ±¯ O(Queue). However nothing avoids to have Stack Ð PosStack as S¯ do not capture the sign of the elements in s, but just the order in which they are inserted. Therefore it is possible to refine S¯ using the domain Si¯gn of Fig.

3(b). In that case we consider the domain H¯
of Fig. 4 that is the reduced

product of the two: H¯ = S¯ × Si¯gn . Thus the resulting observables for the two

classes are:
O(Stack)= {s : reverse, {init : ⊥¯ → empty;
add : reverse → reverse;
remove : reverse → reverse}},
O(PosStack)= {s : ⟨reverse, pos⟩, {init : ⊥¯ → empty;
add : ⟨reverse, pos⟩→ ⟨reverse, pos⟩;
remove : ⟨reverse, pos⟩ → ⟨reverse, pos⟩}}.

It is routine to check that Stack /Ð PosStack. Eventually, the subclass rela- tion that brings to the class hierarchies in Fig. 2 is obtained considering the properties encoded by the abstract domain R¯ = T¯ × H¯ = T¯ × S¯ × Si¯gn.

Conclusions and Future Work
In this work we have presented an approach to the behavioral subtyping based on a modular static analysis of classes’ source. In particular we have shown how the subclassing relation can be defined in terms of the order on the under- lying abstract domain. Our approach has several advantages over traditional subtyping and behavioral subtyping: the class behavioral type is automatically inferred, the subtyping is decidable, it is more semantically characterized and it is formulated in the abstract interpretation framework so that well-known techniques on the composition and refinement of abstracts domain can be used. Moreover, in this setting the problem of analyzing, and hence verifying, polymorphic code is by far more simple. In fact as every subclass extension preserves, by definition, the ancestor invariant then it is not required to rean- alyze the code once a new subclass is defined.
However, an open problem is the choice of the abstract domain used for the inference of observables. For what concerns general purposes object oriented languages, it is difficult to fix in advance the properties that one wishes to be preserved by subclasses. Types have been shown to be effective for that purpose, so that an abstract domain of observables must at least include them. One can think to continue in that direction considering other runtime errors,
e.g. division by zero, overflow or null-pointer dereferencing, so that given a class, all its subclasses are assured not to introduce runtime errors.
On the other hand we are trustful that our approach can be effective for the design and the development of problem-specific object oriented languages. As an example, let us consider a language for smartcards programming. In this setting security is important, so that a wished property is that if a sub- class does not reveal a secret, so do the subclasses. In that case, we can use a


domain of observables able to capture security and information-flow proper- ties. Embedded systems are another field that may take advantage of a more constrained subclass relation. In fact, in such a field it is immediate to see the benefits of having a language that ensures that subclasses does not violate the space and time constraints of the superclass.
In the future we plan to extend the present work to cope with multiple inheritance and Java interfaces, too. The first extension is quite straightfor- ward. The case of interfaces is more difficult: an interface is essentially a type specification, though most of the time such a specification is not expressive enough. Consider for example the case of a Java thread, which can be defined using either the Runnable interface or the Thread class. In both cases the class implementing a thread needs to define a method run. So what is the difference between a class implementing Runnable or extending Thread? The intuition is that in both cases the behavioral type of the class is the same, the difference being just syntactic We plan to define a specification language in order to cope with not-typing properties able to express properties imposed by interfaces. Then we will use it to prove that a class correctly implements an interface.

Acknowledgments
We would like to thanks A. Cortesi, J. Feret, C. Hymans, A. Simon and E. Upton.

References
L. Cardelli. A semantics of multiple inheritance. In Semantics of Data Types, volume 173 of
LNCS, pages 51–67. Springer-Verlag, 1984.
P. Cousot. Types as abstract interpretations, invited paper. In POPL ’97, pages 316–331. ACM Press, January 1997.
P. Cousot and R. Cousot. Abstract interpretation: a unified lattice model for static analysis of programs by construction or approximation of fixpoints. In POPL ’77, pages 238–252. ACM Press, January 1977.
P. Cousot and R. Cousot. Systematic design of program analysis frameworks. In POPL ’79, pages 269–282. ACM Press, January 1979.
R. Giacobazzi, F. Ranzato, and F. Scozzari. Making abstract interpretations complete. Journal of the ACM, 47(2):361–416, 2000.
G. T. Leavens and K. K. Dhara.  Concepts of behavioral subtyping and a sketch of their extension to component-based systems. In Foundations of Component-Based Systems, chapter 6, pages 113–135. Cambridge University Press, 2000.
B. H. Liskov and J. M. Wing. A behavioral notion of subtyping. TOPLAS, 16(6):1811–1841, November 1994.


F. Logozzo. Class-level modular analysis for object oriented languages. In SAS ’03, volume 2694 of LNCS. Springer-Verlag, June 2003.
F. Logozzo. Automatic inference of class invariants. In VMCAI ’04, volume 2937 of LNCS. Springer-Verlag, January 2004.
B. Meyer. Eiffel: The Language. Prentice Hall, 1992.
