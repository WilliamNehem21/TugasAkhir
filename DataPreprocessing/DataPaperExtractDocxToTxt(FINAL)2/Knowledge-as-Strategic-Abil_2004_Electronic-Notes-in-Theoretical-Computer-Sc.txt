Electronic Notes in Theoretical Computer Science 85 No. 2 (2004)
URL: http://www.elsevier.nl/locate/entcs/volume85.html  24 pages


Knowledge as Strategic Ability

Sieuwert van Otterloo 1 Wiebe van der Hoek 1 Michael Wooldridge 1
Department of Computer Science University of Liverpool Liverpool L69 7ZF, UK



Abstract
The ultimate goal of our research is to develop techniques for model checking knowl- edge properties of multi-agent systems. ATEL, an extension of the Alternating-time Temporal Logic of Alur et al, is a logic for specifying epistemic and strategic proper- ties of such systems. We present a technique for reducing the ATEL model checking problem to one of model checking in ATL, whereby epistemic relations are explicitly encoded in ATL models as as dynamic transitions. The techniques is illustrated by means of a knowledge game, which is used as a running example throughout the paper.


Introduction
Alternating-time Temporal Logic (ATL) is a powerful logic for reasoning about the abilities ofcoalitions in multi-agent systems [2,3]. ATL has been extended to Alternating-time Temporal Epistemic Logic (ATEL) in which the knowl- edge of agents, (in the sense ofthe Fagin-Halpern-Moses-Vardi model ofknowl- edge [6]), is also considered [11]. ATEL can be used to express properties of agent communication, for instance whether communication is necessary in a certain situation, and whether communication has been successful.
Model checking is a widely used, and highly successful method for evalu- ating logic formulas on finite state systems [5]. A general method for ATEL model checking would clearly be ofgreat interest for the verification ofagent communication protocols and the planning of communication in multi-agent systems. While automatic model checkers for ATL exist [1], no such model checkers yet exist for ATEL. In the line of a previous approach [10], this paper

1 Email: {sieuwert,wiebe,mjw}@csc.liv.ac.uk
◯c 2004 Published by Elsevier Science B. V. Open access under CC BY-NC-ND license.


further explores use of existing model checking tools for protocols involving knowledge.
A model checker takes a specification of a transition system T and a for- mula φ, and evaluates the validity (or truth) of φ on T ; typically, we write T |= φ to mean that φ is true in the system T [5]. From a mathematical point of view, a model checker is a function MC which takes a system T and a formula φ as input and return a truth value MC(T, φ). Since ATEL appears to be more expressive than ATL, it may not be possible to find a general reduction R from an ATEL formula φ to an ATL-formula R(φ) such that T |= φ ⇔ MC(T, R(φ)). We here assume that T can serve as a model for ATEL and ATL — this seems a reasonable assumption, since the ATEL models we define contain an ATL model. Instead of only converting the for- mula one wants to check, changes to the transition system T might also be considered. That is, we can try to construct functions t and f such that T |= φ ⇔ MC(t(T ),f (φ)). These functions are intended to work on models which represent systems in which each step is completely determined by a single agent and in which no infinite computations can occur. These systems are called turn-based acyclic. This is a limited but important class of models because it allows one to use ATEL for studying extensive games [9].
An argument for the existence of such reductions is that epistemic logic is a modal logic like ATL [4]. Both have a Kripke semantics, and thus can be evaluated on a transition system. In ATL, transitions correspond to compu- tation steps, while ATEL contains transitions corresponding to computations and epistemic uncertainty. In order to evaluate epistemic formulas, one may extend the transition system with additional transitions modelling the epis- temic relations. If these alterations to the transition system are manageable, (in that there is no exponential blow-up in the number of transitions), then this might be a good way to model check.
Ofcourse, we do not claim that all knowledge-related model checking prob- lems can be solved using existing model checkers. But, nevertheless, we think it is useful to investigate which problems can be solved using existing tools. In this paper we show one approach to model checking knowledge and evaluate the relative merits ofthis method.
In section 2 we introduce the example protocol and the logic ATEL used to reason about the protocol. Section 3 informally presents the main idea of this paper. Section 4 explains the theory underpinning the technique. Section 5 formally defines the method and contains a correctness proof. In section 6, the illustrate the technique by using it to prove all the properties introduced in section 2. Section 7 presents some conclusions.

A Running Example
Knowledge games [12] based on card deals are a rich source of examples of multi-agent Knowledge Problems. The example given here is derived from

the Russian Cards Problem [13]. It involves three agents, sharing five cards. Assume agent A holds cards 0 and 1, agent B has cards 2 and 3, while agent C holds card 4. We denote this deal by 01|23|4. All agents know their own cards, which cards exist and how many cards each agent has. All of this is common knowledge, and nothing else is known. Thus, for agent A the deal 01|34|2 is a possibility, while 01|2|34 is not (it knows B has two cards), and neither is 04|23|1, because A knows its own cards. Agent B, however considers 04|23|1 a possibility.
Even without the additional richness allowed by introducing actions into this framework, interesting properties of this scenario can be formulated in epistemic logic. In the next table we list three properties of interest. In the logical formulation often used for these situations [12,13] the proposition Xi is used to express that agent X holds card i. To express the fact that agent X knows φ, we write KXφ.

All formulas are evaluated with the card deal 01|23|4. Epistemic formulas are evaluated before anything has been communicated. To make this a dy- namic scenario, we introduce one action: A is allowed to make one of three statements, each corresponding to a logical formula. However, A can only make true statements. The whole structure of this situation, i.e., which card deals are possible, which statements A is allowed to make, that only A can say something, that each agent only knows its own cards, is assumed to be common knowledge. The possibilities are as follows.

For each possible world at least one statement is true. The limitation to just these three moves may seem artificial, but it makes the example smaller and thus easier to understand.
Suppose that in the actual world 01|23|4 agent A opts to say: I have card 1 or card 2 (the second ofthese formulas). This clearly changes the knowledge ofthe agents — both ofthose listening to the statement and the speaker ofthe statement (who knows that epistemic state ofthose listening to the statement has changed). The following formulas were false in the initial situation, so it is interesting to see whether they are true in the situation after that statement.


The use of ATEL allows one to formulate abilities of (coalitions of) play- ers. In addition to the epistemic operators Ki, ATEL contains two additional operators for each set of agents Γ: ⟨⟨Γ⟩⟩ ⬦ φ and ⟨⟨Γ⟩⟩✷φ. These operators refer to what the agents in Γ can achieve based on their available choices. In ATL and ATEL, t |= ⟨⟨Γ⟩⟩ ⬦ φ is true if and only ifthere is a set ofstrategies, one for each agent in Γ, such that ifall agents in Γ follow their strategy, eventually a state s such that s |= φ will be reached. For all Γ and φ, t |= ⟨⟨Γ⟩⟩✷φ is true if and only if there is a set of strategies, one for each agent in Γ, such that if all agents in Γ follow their strategy, s |= φ is true for all future states s.
In this example, we would like to express that agent A can achieve certain goals by selecting the right moves. The following formulae, which combine both epistemic and strategic modalities, are evaluated in 01|23|4.

The above formulas have been chosen because they illustrate some inter- esting combinations ofdifferent operators.
The semantics we use for ATEL is one in which no knowledge restrictions are placed upon strategies. This is the simplest semantics and the one pro- posed originally [11]. In this semantics, players can base their decisions upon things they are supposed not to know. This may seem counter-intuitive in certain situations. If needed it can be solved by assuming a different seman- tics [8,7].

Modelling Epistemic Relations
The initial situation of the card game example can be captured in a Kripke structure [6,4]. Nodes in the structure correspond to different possible deals, and arcs capture the epistemic alternatives of agent (i.e., an arc d1 → d2 for agent i means that i cannot distinguish the deal d1 from deal d2). Figure 1 shows just four ofthe states with one connection ofeach kind, but the actual number ofdifferent card deals in our example is 30 (note that different styles of lines connect states indistinguishable for different agents in this figure — reflexive arcs are not drawn).
Dynamic transitions are represented in figure 2. A choice is available only in the initial situation: agent A has two options in the depicted situation; the third possible statement, a3 ∨ a4, is not true in under the initial card deal and therefore this is not a possible action for A.


Fig. 1. epistemic relations

01|23|4
A
01|24|3
B
03|24|1
C
23|04|1


Fig. 2. dynamical transitions
01|23|4	a1 ∨ a2
A	a4 ∨ a0



Fig. 3. epistemic model T

01|24|3
A
01|23|4
A
01|34|2


We need to combine the information contained in the model describing the choices (figure 2) and the epistemic information of figure 1. The idea is to explicitly encode the epistemic transitions as a special kind of choice. Since these transitions must not be confused with the transitions corresponding to actions, we introduce additional epistemic agents, for whom the choices will be the epistemic alternatives of the “real” agents. Thus in addition to the agents {A, B, C} we use {eA, eB, eC, actA, actB, actC, E}: we will call eA, eB, eC the epistemic agents. Each agent eX can choose a next state that is indistinguishable for agent X.
To better understand this idea, consider the formula φ = KAp, where p is some proposition regarding the card deal. We will evaluate this formula in the epistemic situation offigure 1. We consider 01|23|4 the current card deal. We call this model T . The three states that agent A considers possible are shown in figure 3 — the dashed lines suggest the equivalence relation for agent A. (The possible choices ofagent A are not in the picture because the formula φ does not use the choices of A.)
The procedure we propose will produce a new model T ' = t(T, φ) and a new formula φ' = f (φ). The new model T ' must encode information about the knowledge of A. Therefore from the state with the real card deal, choices are available to agent eA to states with card deal that A considers possible. This new model is shown in figure 4. In this model the proposition t has been introduced. It indicates that a state is a final state.
The new formula φ' is derived from φ by replacing knowledge operators by


Fig. 4. System T '




01|23|4
eA
t 01|34|2 t 01|23|4 t 01|24|3


strategic operators. The intended meaning of the new formula is ‘Whatever choice eA makes, p will hold’. This can be expressed by the formula ⟨⟨⟩⟩⬦(t∧p). This intuitive idea is formalized in the next sections. The title of this paper refers to the interpretation of knowledge properties in ATEL as ATL formulas referring to strategic ability: ATL formulas are used to express the existence of ‘winning’ strategies — strategies which allow players to reach or
avoid certain situations.

Definitions
In this section we define the languages that are used in the remainder of the paper, and the semantic models over which these languages are interpreted. The most important languages we deal with are ATL and ATEL. A common subset ofthese languages is propositional logic, which will be defined as well.
Definition 4.1 [Turn-Based System] A turn-based system (TBS) is a tuple (S, P, π, Σ, a, label), where S is a set of states, P a set of propositions, π : P × S → {true, false} is the function interpreting all propositions, Σ is the set of agents, a ⊆ S × S is a transition relation and label : a → Σ labels all transitions with one of the agents. It is required that transitions with the same source must have the same label: ∀s, t, t' label(s, t)= label(s, t').
The intended meaning oflabels on transitions is that these labels indicate the agent that can decide which transition will be the next step in the compu- tation. Thus this kind of system models a game-like situation, such as chess or checkers. We will use T as a variable for TBS.
It is possible to attach labels to positions instead of states. This does not result in important differences but some details will be different. In our formalisation no labels are attached to nodes from which no transitions leave. We see this as an advantage. The domain ofthe label function is the relation a, so only pairs (s, t) between which there is a transition get a label attached.
Definition 4.2 [Turn-Based Epistemic System] A turn-based epistemic sys- tem (TBES) is a tuple ((S, P, π, Σ, a, label), {∼X |X ∈ Γ}). The first element,

(S, P, π, Σ, a, label), is a TBS, while the second set contains for each agent X
an equivalence relation ∼X⊆ S × S.
The variable B will be used to denote TBES.
Definition 4.3 [Pointed System] Let M be either a TBS or a TBES and let S be the set of states of M . For each state s ∈ S in the system M , the tuple (M, s) isa pointed system.
We will write TBS∗ for the set of all pointed TBS and TBES∗ for the set for all pointed TBES.
Definition 4.4 [Propositional Logic] Let P be a set ofpropositions. Standard propositional logic PL is the smallest language L such that P ⊂ L and such that for all φ ∈ L and ψ ∈ L it is the case that ¬φ ∈ L and φ ∨ ψ ∈ L.
Given an interpretation function π : P × S → {true, false} and a state
s ∈ S we can interpret propositional logic formulas as follows.
π, s |= p if and only if π(p, s) is true
π, s |= ¬φ ifand only ifnot π, s |= φ
π, s |= φ ∨ ψ ifand only if π, s |= φ or π, s |= ψ
Alternating-time Temporal Logic extends propositional logic with two strate- gic operators.
Definition 4.5 [Alternating-time Temporal Logic] Let P be a set of propo- sitions and Σ a set of agents. The language AT L with propositions P is the smallest language L such that P ⊂ L and for any φ, ψ ∈ L and Γ ⊆ Σ it is the case that ¬φ ∈ L, φ ∨ ψ ∈ L,⟨⟨Γ⟩⟩ ⬦ φ ∈ L and ⟨⟨Γ⟩⟩✷φ ∈ L.
Let T = (S, P, π, Σ, a, label) be a TBS and s ∈ S. We will define, for each formula φ ∈ AT L, the circumstances under which T ,s |= φ. The semantics for ATL is the semantics of propositional logic extended with two new clauses for the two new operators. These operators make use of strategies. A strategy is a function f : S+ → S: given a sequence ofstates (... , s) ending in state s the strategy selects a next state t such that (s, t) ∈ a.
A run r is a sequence of states r = (s0, s1,... , sn) such that all pairs (si, si+1) are element of a and there is no t such that (sn, t) ∈ a. We say that in a certain run r = (s0, s1,.. .) the agent X used strategy f if for all (si, si+1) ∈ r with label(si, si+1)= X it is the case that f ((s0,... , si)) = si+1. It is not important what f (s) is for states s in which it is not X’s turn. This idea ofa strategy is used in the following definition, which gives the semantics ofATL.
T ,s |= p if and only if π(p, s) is true
T ,s |= ¬φ if and only if not T ,s |= φ
T ,s |= φ ∨ ψ ifand only if T ,s |= φ or T ,s |= ψ


T , s0 |= ⟨⟨Γ⟩⟩ ⬦ φ if and only if there is a strategy for each agent in Γ such that in all runs r = (s0, s1,.. .) in which the agents in Γ used their strategy, a state si exists such that T , si |= φ
T , s0 |= ⟨⟨Γ⟩⟩✷φ if and only if there is a strategy for each agent in Γ such that in all runs r = (s0, s1,.. .) in which the agents in Γ used their strategy, in every state si it holds that T , si |= φ.
It is possible to define a semantics for AT L for systems that are not turn based. However, a slightly different notion ofa strategy must be used [2].
In a turn based system, we can define ⟨⟨Γ⟩⟩✷φ := ¬⟨⟨Σ\Γ⟩⟩⬦¬φ. This is not true in all ATL semantics, but for turn based systems we can use the minimax statement from game theory. The minimax theorem for games states that any zero-sum game has a unique value and that both players have a strategy to reach that value. Instead of applying this theorem we will provide a proof in terms ofTBS.
Theorem 4.6 For any TBS T = (S, P, π, Σ, a, label) and any state s
T ,s |= ⟨⟨Γ⟩⟩ ⬦ φ ↔ ¬⟨⟨Σ \ Γ⟩⟩✷¬φ
Proof. Let T = (S, P, π, Σ, a, label) be a TBS and φ an ATL formula. We will show that for any state s ∈ S either T ,s |= ⟨⟨Γ⟩⟩⬦φ or T ,s |= ⟨⟨Σ\Γ⟩⟩✷¬φ. For this proof we construct a function v : S → {1,... , ∞}. The function is deﬁned by the next rules. The deﬁnition is recursive: we ﬁrst deﬁne when it is 1. Then we deﬁne for any value n, when the function takes the value n + 1. Finally we assign the value ∞ to the states for which the function did not have a value yet.
If T ,s |= φ then v(s)= 1
If there is no transition (s, t) ∈ a then v(s)= ∞
If there is a transition (s, t) ∈ a and label(s, t) ∈ Γ, then v(s) = 1 + min(s,t')∈a v(t').
If there is a transition (s, t) ∈ a and label(s, t) ∈/ Γ, and for all (s, t') ∈ a v(t') < ∞, then v(s)=1 + max(s,t')∈a v(t').
v(s)= ∞ otherwise
Since v is a function for any s either v(s) < ∞ or v(s)= ∞, and never both. We will show that v(s) < ∞ implies T ,s |= ⟨⟨Γ⟩⟩ ⬦ φ and v(s) = ∞ implies T ,s |= ⟨⟨Σ \ Γ⟩⟩✷¬φ.
Assume that s ∈ S. We will show by induction for any natural number n, that v(s)= n implies T ,s |= ⟨⟨Γ⟩⟩ ⬦ φ. The strategy we propose for coalition Γ is to choose the next state t for which v(t) is minimal. This is a valid strategy. Assume that (s0, s1, s2,.. .) is a run in which Γ uses this strategy. If v(si) > 0 then v(si+1) < v(si). This can be seen from the second and third line of the deﬁnition. Therefore eventually a state tj will be reached with v(sj)= 0, and then T , sj |= φ. This proofs that there is a strategy such that T ,s |= ⟨⟨Γ⟩⟩ ⬦ φ.

Now we show that v(s)= ∞ implies T ,s |= ⟨⟨Σ \ Γ⟩⟩✷¬φ. Assume a strat- egy for coalition Σ \ Γ such that they choose the next state s which maximizes
v(s). it is clear that v(s) = ∞ implies that T ,s |= φ. We will show that in any run (s0, s1, s2,.. .) in which the agents follow the strategy, v(sj) = ∞ implies v(sj+1) = ∞. First assume that label(sj, sj+1) ∈ Γ. If v(sj+1) < ∞, then v(sj) would have been less than or equal to v(sj+1). Next assume that label(sj, sj+1) ∈/ Γ. The strategy we assumed tells us that sj+1 was choses to maximize v(sj+1). If v(sj+1) would be ﬁnite, then v(sj) would be 1+ v(sj+1) hence ﬁnite. Therefore v(sj+1)= ∞. This shows that φ will not become true in this run and therefore T ,s |= ⟨⟨Σ \ Γ⟩⟩✷¬φ. This concludes the proof.  ✷
It may seem that the fact that we add agents might interfere with our appliation of the above theorem. This is not the case because the reduction method carefully constrains the actions ofthe new agents. This proofand the correctness proofofthe reduction method do not depend on each other.
Definition 4.7 [Alternating-time Temporal Epistemic Logic] Let P be a set ofpropositions and Σ a set ofagents. The language AT EL with propositions P is the smallest language L such that P ⊂ L and for any φ, ψ ∈ L, Γ ⊆ Σ and X ∈ Σ it is the case that ¬φ ∈ L, φ ∨ ψ ∈ L, KXφ ∈ L ⟨⟨Γ⟩⟩ ⬦ φ ∈ L and
⟨⟨Γ⟩⟩✷φ ∈ L.
ATEL can be interpreted over TBES. The interpretation for all connectives and operators also appearing in ATL is similar to the interpretation in ATL. We will omit these similar definitions and only define the interpretation ofthe knowledge operator.
B,s |= KXφ if and only if for each state s' with s' ∼X s it holds that
B, s' |= φ

The Reduction
We now present our main contribution, which permits a reduction ofthe ATEL model checking problem to ATL model checking. The reduction consists of two functions
f : AT EL → AT L
t : TBES∗ × AT EL → TBS∗
such that
t((B, s), φ) |= f (φ)	if and only if	B,s |= φ.
The definition of f makes use ofan auxiliary function f1, while the definition of t makes use ofauxiliary functions t1, t2, t3.
Throughout this section, the formula µ = KAb1 evaluated under card deal 01|23|4 is used as an example to show how all functions work. See figure 3

on page 5 for the epistemic accessability relations for this example and figure 4 (page 6) for an illustration of the resulting system. In this figure only the states reachable from the initial state are shown.
The next table shows the domain and range ofthe functions we will define next.

The first step in the transformation is that in the input formula φ, all subformulas (including the whole formula) are assigned a number from the set {0, 1, 2,.. .}. The whole formula gets the number 0. The numbers are written as in φi ∨ ψj, Kxφi, ⟨⟨Γ⟩⟩ ⬦ φi. Subformulas caused by negation, as in φ = ¬ψ get the same number, as in (¬ψ1)1, otherwise every subformula receives a unique number. For instance the input formula p ∨ KAq could be numbered as (p1 ∨ (KAq3)2)0. These numbers are used for matching steps introduced by t to operators introduced by f . The order in which subformu- las are numbered does not matter. The set of all formulas with numbered connectives is called AT ELn. We define the function number as numbering all subformulas top-down, left to right. We define f (φ)= f1(number(φ)) and t(E , φ)= t1(E , number(φ)).
For the example formula, we have:
number(µ)= (KA(b1)1)0 The function f1 is defined recursively, as follows.
χ	if χ ∈ PL 
⟨⟨E⟩⟩ ⬦ (donei ∧ f1(φ)) ∨ (donej ∧ f1(ψ)))	if χ = φ ∨ ψ
	
⟨⟨⟩⟩ ⬦ (done ∧ f (φ))	if χ = K  φi
⟨⟨Γ ∪ {E}⟩⟩ ⬦ (donei ∧ f1(φ))	if χ = ⟨⟨Γ⟩⟩ ⬦ φi
It is possible that both the first and either the second or the third clause can be used. In this case, the first rule takes precedence because this yields the

smallest translation.
The reason for the use of the environment agent E is that in case we want to determine whether B,s |= KAp ∨ KBp, the intuition is to define a model in which both transitions eA and transitions labeled eB begin in s. In the definition of a TBS it is required that transitions from the same node must have the same label. In order to overcome this, in the definition of t we will define that from s one transitions leads to a new state t1, where all the needed eA transition can start, and one transition leads to t2. All transitions from t2 are labeled eB. The environment plays a similar ‘administrative’ role in the translation ofthe strategic operators.
The translation ofour example formula is

f (µ)= f1(number(µ)) = ⟨⟨⟩⟩ ⬦ (done1 ∧ b1)
Suppose B = ((S, P, π, Σ, a, label), {∼i}i∈Σ) and that B,s is a pointed TBES. Let φ be a numbered AT EL formula and let N be the set of all numbers used in φ. Assume ((S',P ', π', Σ', a', label'), s') = t((B, s), φ). The next definitions apply.
S'	=	{state(s, j)|s ∈ S, j ∈ N } P '	=	P ∪ {donei|i ∈ N ∧ i > 0}
Σ'	=	{X|X ∈ Σ}∪ {eX|X ∈ Σ}∪ {E}
π'(p, state(s, j)) = π(p, s) for all p ∈ P π'(donei, state(s, j))  =  true if i = j, false otherwise
There is no proposition done0. The number 0 is assigned to the whole formula, but the function f is designed such that there is no need to refer to done0. The intuition behind the definition of P ' is that all old propositions can be used and the propositions donei which can be used as labels. In order to interpret these label propositions every state must encode which labels are valid. Luckily at most one label is applied to any state, therefore we can attach to any state the number of the donei proposition that is true. This explains the definition of π' and S'.
For the example model ((S',P ', π', Σ', a', label'), s')= t(T, µ) we have:

N = {0, 1}
P ' = {ai|0 < i < 6}∪ {bi|0 < i < 6}∪ {ci|0 < i < 6}∪ {done1} Σ' = {A, B, C, eA, eB, eC, E}
S' = {state(ab|cd|e, x)|{a, b, c, d, e} = {1, 2, 3, 4, 5}, a < b, c < d, x =0 ∨ x = 1}

and
π' : π'(done1, state(ab|cd|e, j)) = true if j = 1,false if j =0 
π' : π'(p, state(ab|cd|e, j)) = π(p, ab|cd|e) for all other p

We define the remaining components, a', label' and s' by the means ofthe tree T = t2((B, s), φ). First, we explain what is meant by a tree and how these parts can be derived from a tree. Then we define the function t2 that constructs such a tree.
The format of a tree is node(state(s, j), C). The first element state(s, j) must be in S' and is a state from the new model. The set C encodes where we can go from this state. C is a collection of pairs (X, U ). The X is the agent which can make this transition. For any two elements (X, U ) and (Y, V ), X and Y must be equal. The second element ofthe pair, U , is itself a tree.
Suppose we have a tree T = t2((B, s), φ), and we wish to know the initial state s', the transition relation a', and the label relation label' of the model ((S',P ', π', Σ', a', label'), s') = t(B, φ). The initial state s' is the state at the root of the tree, so if T = node(state(s0, j0), C0) for some s0, j0 and C0, then s' = state(s0, j0). The set a' consist of all pairs (state(s, j), state(t, k)) such that node(state(s, j), C) appears in the tree and (X, node(state(t, k), D)) ∈ C, so transitions are from a subtree to a child of that subtree. For the pair state(s, j), state(t, k), the label of the transition would be X, since X is the first element ofthe pair (X, node(state(t, k), D)) ∈ C.
The function t2 is defined in terms of t3. We will abuse notation slightly by writing t2(s, p) instead of t2((B, s), p), and by writing t3(s, p, j) instead of t3((B, s), p, j). In the following definition, the symbol S refers to the set of states of B and a refers to the transition relation of B.
t2(s, φi)	=	t3(s, φi, i)
t3(s, φi, l)	=	node(state(s, l), ∅) for any φ ∈ PL 
t3(s, (φi ∨ ψj)k, l)	=	node(state(s, l), {(E, t3(s, φi, i)), (E, t3(s, ψj, j))}) t3(s, (¬φi)i, l)	=	t3(s, φi, l)
t3(s, (KXφi)j, l)	=	node(state(s, l), {(eX, t3(s', φi, i))|s ∼X s'}) t3(s, (⟨⟨Γ⟩⟩ ⬦ φi)j, l)	=	node(state(s, l), {C1, C2})
where
C1	=	(E, t3(s, φi, i)),
C2	=	(E, node(state(s, 0), Z))),	and
Z	=	{(X, t3(t, (⟨⟨Γ⟩⟩ ⬦ φi)j, 0))|(s, t) ∈ a ∧ X = label(s, t)}
The last clause of this definition defines the translation of the strategic oper-

ator. We have modelled this with steps ofthe original system in set Z, which are interleaved by steps of the environment. The environment can choose whether it wants to continue selecting steps from Z, or move on to evaluating the formula to know φ. In the corresponding translation ofthe formula we see that indeed the environment and the coalition must work together in the new ATL system, instead ofonly the coalition as in the original ATEL system.
The tree would be infinite if φ contained a strategic operator and the transition relation a of the TBES B we started with contained cycles. We have thus assumed that this relation is acyclic.
Applying this reduction to the example formula µ and model T , we get the following
t2(01|23|4, µ)	=	node(state(01|23|4, 0), {X, Y, Z})
where:

s'  =  state(01|23|4, 0),  and
a'  =  {(state(01|23|4, 0), state(01|23|4, 1)),
(state(01|24|3, 0), state(01|24|3, 1)),
(state(01|34|2, 0), state(01|34|2, 1))}
The outcome of t3(T, µ) is depicted in figure 4, where t is the same as done1. The picture shows only four states. The two states not shown, state(01|24|3, 0) and state(01|34|2, 0) cannot be reached from the initial state (state(01|23|4, 0) and have been omitted to simplify the figure.
Theorem 5.1 For any pointed TBES (B, s) and any ATEL formula δ, B,s |= δ if and only if t((B, s), δ) |= f ((B, s), δ).
Proof. Let (B, s) be a pointed TBES and δ an ATEL formula. Let(T , t) = t((B, s), δ) and let φ' = f ((B, s), δ). We must show that B,s |= δ if and only if (T , t) |= φ'. We will prove this by proving the stronger claim that for any subformula ψj of number(δ) and state s ∈ B such that state(s, j) occurs in the tree t2((B, δ), 0), it holds that (B, s) |= ψj if and only if (T , state(s, j)) |= f1(ψ). We will prove this last claim by induction.
Let ψj be a subformula of number(δ). Suppose ﬁrst that ψ ∈ P L. In that case f1(ψj) = ψ. The interpretation of a formula in propositional logic only depends on the current state. π' is constructed such that for all p occurring in ψ, π'(p, state(s, j)) = π(p, s), and therefore (B, s) |= ψj if and only if (T , state(s, j)) |= f1(ψ), which we had to prove. This provides us with the inductive base.

For the next step suppose ψj = (¬χj)j. We will show that (B, s) |= (¬χj)j
if and only if (T , state(s, j)) |= f1((¬χj)j).
(B, s) |= (¬χj)j	⇔(ATEL semantic)
not (B, s) |= χj)	⇔(induction hypothesis) not (T , state(s, j)) |= χj	⇔(ATL semantic)
(T , state(s, j)) |= f1((¬χj)j)
Now suppose that ψj = (φi ∨ χk)j.

B,s |= ψj	⇔(ATEL sem.)
B,s |= φi or (B, s) |= χk	⇔(induction hyp.)
T , state(s, i) |= f1(φi) or (T , state(s, k)) |= f1(χk)	⇔(structure t3)
T , state(s, j) |= ⟨⟨E⟩⟩ ⬦ (donei ∧ f1(φi)) ∨ (donek ∧ f1(χk)))	⇔(deﬁnition f1)
T , state(s, j) |= f1(ψj)
The argument given above depends on the deﬁnition of t3, which is applied below. t3(s, (φi ∨ χk)j, l)= node(state(s, l), {(E, t3(s, φi, i)), (E, t3(s, ψj, j))}). One can see from this formula that the strategy for E can only make one choice out of two options. One options will be succesful if (T , state(s, i)) |= f1(φi), the other if (T , state(s, k)) |= f1(χk).
Next we deal with the strategic oprator. Let ψj = (⟨⟨Γ⟩⟩ ⬦ φi)j. We will ﬁrst proof that (B, s) |= ψj ⇒ (T , state(s, j)) |= f1(ψj), and then that (B, s) |= ψj ⇐ (T , state(s, j)) |= f1(ψj).
Assume that (B, s) |= ψj. This means that there is a strategy S for Γ such that ∀r = (s, s1,.. .) in which agents in Γ use S a state si exists such that (B, si) |= φ.
The structure of t3(ψj) is given next.
t3(ψj)	=	node(state(s, j), {A, B})
A	=	(E, t3(s, φi, i))
B	=	(E, node(state(s, 0), Z)))
Z	=	{(label(s, t), t3(t, ψj, 0))|(s, t) ∈ a}
Suppose that E decides to take option B for some amount of time and that Γ uses S. In that case for any run w we will arive in a state state(wx, l) for some l such that (B, wx) |= φ. Assume that here the environment chooses option
A. This brings us to a state state(wx, i) where donei will hold. Furthermore, by induction hypothesis, we know that T , state(wx, i)) |= f1(φi). Therefore we know that Γ ∪ {E} has a strategy for bringing about in some state in every run (donei ∧ f1(φi)), which means that (T , state(s, j)) |= ⟨⟨Γ ∪{E}⟩⟩ ⬦(donei ∧

f1(φi)) = f1(ψj).
For the second part assume that (T , state(s, j)) |= f1(ψj). Therefore Γ ∪
{E} has a strategy S such that for any run v starting in state(s, j) there is a state vx such that T , vx |= (donei ∧ f1(φi)). Let w be any run of B starting in s in which all agents of Γ use the strategy which corresponds to their strategy S. We can translate this run w to a run v in T where the environment will repeatedly choose option B. Since donei is never true on this run, the strategy S must at a certain point vx specify a different move for the environment. So assume that that v' is a run in which Γ ∪ {E} uses

strategy S such that v' ... v' = v0 ... vx and at v'
is a state state(s', i). This

0	x	x+1
is the only state of v' in which donei is true. Since we have assumed that the strategy S works for every run, we have T , state(s', i) |= (donei ∧ f1(φi)) and thus T , state(s', i) |= f1(φi). Using the induction hypothesis we know that
B, s' |= φ. From the deﬁnition of t3 we see that v' = vx = state(s', l) and
therefore wx = s'. Since we have shown the existence of such a state wx for any run w in which Γ uses the strategy corresponding to S, we can conclude (B, s) |= ψj.
Finally, suppose that ψj = (KXφi)j. Then f1((KXφi)j) =⟨⟨⟩⟩ ⬦ (donei ∧ f1(φi)), and t3(s, KXφi, j) =node(state(s, j), {(eX, t3(s', φ, i))|s ∼X s'}). We must prove that B,s |= ψ if and only if T , state(s, j) |= f1(ψ).
(B, s) |= ψj  ⇔(ATEL semantic)
∀t ∼X s : (B, t) |= φi  ⇔(induction hypothesis)
∀t ∼X s : (T , state(t, i)) |= f1(φi)
For any state t with s ∼X t there is in T a transition from state(s, j) to state(t, i). A statement regarding the empty coalition, such as ⟨⟨⟩⟩ ⬦ (donei ∧ f1(φi)), is only true if on all paths there is a state in which donei ∧ f1(φ) is true. Therefore the next equivalences hold.
∀t ∼X s : (T , state(t, i)) |= f1(φi)	⇔ T , state(t, j) |= ⟨⟨⟩⟩ ⬦ (donei ∧ f1(φi))	⇔
T , state(t, j) |= f1(ψj)
This concludes our the proof of our statement.	✷

Implementation in Mocha
In this section we demonstrate how the technique we have described can be applied to the Russian cards scenario. The example code has two goals. The first is to show how a turn-based system can be modelled in Mocha [1] using a controller or scheduler module. Secondly it shows how the reduction method from this paper can be implemented in Mocha. The first part of this section explains how the protocol has been modelled in the first place. The second part

shows which modifications and additions are being made when applying the reduction we propose. The Mocha code for this example can be downloaded from http://www.csc.liv.ac.uk/∼sieuwert/.

Modelling the Scenario in Mocha
Mocha is a intended for the modular verification of heterogeneous systems. It accepts a transition system described in the ReactiveModules language as input, and allows one to either simulate the system or else to check ATL properties on the system. The system is composed of several modules that run in parallel. Each variable can only be controlled by one module, but can be read by any module. Modules communicate by means of shared variables or by passing “events”.
The parallel setup is convenient for instance in the case of modelling digital circuits, where each path between components is translated into a variable. Our example can be seen as a turn-based synchronous system [2] and this requires a different approach. To make sure only one module acts at any time and all the modules act in the appropriate order, a separate module named Control has been introduced. This module signals all processes if they are expected to do something. One part ofthis module encodes the order ofsteps in the system, making it easy to change the order of steps or introduce new steps.
The state of the world in the example consists of the deal of cards and all announcements made. The deal of cards can be stored in five variables d, e, f, g, h each containing one card. Agent A holds the cards contained in d, e, B holds f, g and C holds h.
In turn-based systems it is possible that more than one module is in certain situations allowed to change the value ofa variable. In ReactiveModules this cannot be implemented directly. This issue of write-shared variables can be solved by giving Control write-access to these variables. Modules X that need to alter the value of such a variable y are in control of their own copies of this variables, called xy. The x is some identifier unique for module X to make sure all variables have a unique name. When the module Control ends the turn ofa certain module X, it copies the value of xy into the real variable y.
The technique for implementing turn-based systems described above has been used to obtain the implementation of the protocol. Below the full pro- gram is given, followed by details about the role of each variable.
type cards :{zero,one,two,three,four} type modules:{epA,epB,epC,none,actA,actB}
module actionA interface u1,u2:cards
external focus:modules;d,e:cards


atom step controls u1,u2 reads u1,u2,d,e awaits focus init
[] true -> u1’:=one;u2’:=one update
[] focus’=actA&(d=four|d=zero|e=four|e=zero) -> u1’:=four;u2’:=zero
[] focus’=actA&(d=one|d=two|e=one|e=two) -> u1’:=one;u2’:=two
[] focus’=actA&(d=four|d=three|e=four|e=three) -> u1’:=three;u2’:=four
[] default -> endatom endmodule
module Control
interface d,e,f,g,h:cards; stp:(0..10);
focus:modules; finish:bool
external af,ag,ah,bd,be,bh,cd,ce,cf,cg:cards
atom step
controls d,e,f,g,h,stp,focus,finish
reads d,e,f,g,h,stp,focus,finish,af,ag,ah,bd,be,bh,cd,ce,cf,cg init
[] true -> d’:=zero;e’:=one;f’:=two;g’:=three;h’:=four; stp’:=0;
finish’:=false; focus’:=none
update
-- insert here
[] focus=none & stp=0 ->	focus’:=actA [] focus=none & stp=1 -> finish’:=true
-- end of insert
--receive feedback from processes [] focus=actA ->
focus’:=none; stp’:=stp+1
endatom endmodule
The module that is allowed to make a transition is always stored in focus. It contains the name ofa module or the value none. The none value indicates that all variables wait for the module Control to do its work.
The module Control sets the boolean variable finished to true ifa run is finished. This variable can be used as a label is formulas, indicating a terminal state. Checks on the variable stp can be used as labels for other positions in

the protocol.
The basic setup of a turn-based system has been implemented with one module actionA. This module encodes the actions agent A ofour example can do. This agent can make one out ofthree statements, provided the statement is true. The statement is stored in the variables u1,u2. Initially, these variables have the same value. This indicates that no statement has been made yet. When these variable have a different value, the interpretation variables is that agent A makes the statement au1 ∧ au2.
The proposition a0 is expressed in the code as d=zero|e=zero (“d is zero or e is zero”), because d,e are A’s cards.
The specification given contains some redundant variables and values. These variables will be used later on. In order to avoid having to include almost similar code later on we have not stripped the code from unused vari- ables (af,ag,ah,bd,be,bh,cd,ce,cf,cg) or values (epA,epB,epC,actB).
Applying the reduction
In this section, we describe how an ATEL formula can be verified by checking a corresponding ATL formula on a modified model. Some of the modifications to the module are specific to the formula. First, we describe the addition of a module for each agent encoding that agent’s epistemic accessibility relation. These modules corresponds to the epistemic agents ofsection 5. They do not depend on the specific formula.
For each ofagent X an extra module called epistemicX was created. From the definition ofknowledge in an interpreted system [6] it follows that an agent knows its own variables. Each epistemic module reassigns all other variables in any consistent manner. For most systems, including the example system this is straightforward to implement.
Agent A has access to its own cards. The module epistemicA should therefore rearrange the cards of B and C. The next module implements the rearrangements. The variables af, ag, ah are copies of f, g, h allowing this module to suggest new values for these variables.
module epistemicA interface af,ag,ah:cards
external focus:modules;f,g,h:cards atom step
controls af,ag,ah reads f,g,h,af,ag,ah awaits focus
init
[]true->af’:=one;ag’:=one;ah’:=one update
[]focus’=epA -> af’:=f;ag’:=g;ah’:=h
[]focus’=epA -> af’:=h;ag’:=g;ah’:=f
[]focus’=epA -> af’:=f;ag’:=h;ah’:=g [] default ->
endatom


endmodule
In the example, agent A can make one of three statements. These state- ments do not affect the knowledge of agent A, so they have not been used in the definition of epistemicA. For the knowledge of B and C, the statements are of course relevant. The module epistemicB is similar to epistemicA, except that it depends on the statement made by A. Extra conditions have been prefixed to the possible swaps. One ofthe conditions is “No statements has been made yet”. In code, this is u1=u2, since by convention u1,u2 are only equal ifno statement has been made. The proposition encoded in u1,u2 is true ifone ofthe cards is indeed held by A:(u1=d|u1=e|u2=d|u2=e).
module epistemicB interface bd,be,bh:cards
external focus:modules;d,e,h,u1,u2:cards atom step
controls bd,be,bh
reads d,e,h,bd,be,bh,u1,u2 awaits focus
init
[]true->bd’:=one;be’:=one;bh’:=one update
[]focus’=epB & (u1=u2|u1=d|u1=e|u2=d|u2=e)-> bd’:=d;be’:=e;bh’:=h []focus’=epB & (u1=u2|u1=h|u1=e|u2=h|u2=e) -> bd’:=h;be’:=e;bh’:=d []focus’=epB &(u1=u2|u1=d|u1=h|u2=d|u2=h)-> bd’:=d;be’:=h;bh’:=e [] default ->
endatom endmodule
module epistemicC
interface cd,ce,cf,cg:cards
external focus:modules;d,e,f,g,u1,u2:cards atom step
controls cd,ce,cf,cg
reads d,e,f,g,cd,ce,cf,cg,u1,u2 awaits focus
init
[]true->cd’:=one;ce’:=one;cf’:=one;cg’:=one update
[]focus’=epC & (u1=u2|u1=d|u1=e|u2=d|u2=e) -> cd’:=d;ce’:=e;cf’:=f;cg’:=g []focus’=epC & (u1=u2|u1=d|u1=f|u2=d|u2=f)-> cd’:=d;ce’:=f;cf’:=e;cg’:=g []focus’=epC & (u1=u2|u1=d|u1=g|u2=d|u2=g)-> cd’:=d;ce’:=g;cf’:=f;cg’:=e []focus’=epC & (u1=u2|u1=f|u1=e|u2=f|u2=e)-> cd’:=f;ce’:=e;cf’:=d;cg’:=g []focus’=epC & (u1=u2|u1=g|u1=e|u2=g|u2=e)-> cd’:=g;ce’:=e;cf’:=f;cg’:=d []focus’=epC & (u1=u2|u1=f|u1=g|u2=f|u2=g)-> cd’:=f;ce’:=g;cf’:=d;cg’:=e [] default ->
endatom endmodule
The introduction of new modules imposes some additional bookkeeping requirements. The next lines must appear in the Control module. The lines are responsible for transferring the control back from each module to the

Control module. These lines are similar for the action and the epistemic modules. They replace the old part, starting with the comment --receive feedback from processes.
--receive feedback from processes [] focus=epA -> f’:=af;g’:=ag;h’:=ah; focus’:=none;
stp’:=stp+1 [] focus=epB ->
d’:=bd;e’:=be;h’:=bh; focus’:=none; stp’:=stp+1
[] focus=epC -> d’:=cd;e’:=ce;f’:=cf;g’:=cg; focus’:=none;
stp’:=stp+1
[] focus=actA -> focus’:=none; stp’:=stp+1
For each formula to check, we must alter the game structure: the epistemic modules ofthe agents involved must be used. In the program prior to modifi- cation, a comment appears saying -- insert here. At this point, the turns of the game are determined. In the original scenario, the module actionA was allowed to do one action (to make an announcement). This is modified to include epistemic transitions, matching the order ofepistemic operators in the formula to check.
In section 2, several epistemic and ATEL formulas are given. Here we give, for each formula, the translation in ATL, together with a new set of lines to be inserted in the program. The ATL formulas are given in the input format of Mocha. For each example formula φ a statement atl "anyname" φ; is given. This assigns the name anyname to the ATL formula φ. The difference between the logical notation and the Mocha notation for formulas is that the diamond
⬦ is replaced by F. The propositions referring to the cards are translated into simple tests on the five variables d,e,f,g,h. The next table illustrates the translation ofpropositions.

For the translation of epistemic operators we need labels, so that the for- mula can refer to the point in each run after the epistemic transitions have been made. These correspond to the donei propositions in the proof. The boolean variable finish was introduced to serve as a label for the final state

ofeach run. Tests on the variable stp can be used to refer to other points in each run.
The next ATL formulas and modifications correspond to the first three example formulas (page 3). The first line is the original formula. The following lines must be included in the Control module. The line starting with atl contains the resulting ATL formula, and the last line indicates the model checking result (either passed or failed).
-- Ka a0
-- [] focus=none & stp=0 ->	focus’:=epA
-- [] focus=none & stp=1 -> finish’:=true
atl "simple1" <<>> F (finish & (d=zero|e=zero));
--passed
-- Kb a0
-- [] focus=none & stp=0 ->	focus’:=epB
-- [] focus=none & stp=1 -> finish’:=true
atl "simple2" <<>> F (finish & (d=zero|e=zero));
-- failed
-- Ka-Kb a0
-- [] focus=none & stp=0 ->	focus’:=epA
-- [] focus=none & stp=1 ->	focus’:=epB
-- [] focus=none & stp=2 -> finish’:=true
atl "simple3" <<>> F (stp=1 & ~(<<>> F (finish & (d=zero|e=zero))));
-- passed
The results are correct, just as we expected. Since these examples are formulas in epistemic logic, this only shows that an ATL model checker can be used for checking epistemic properties.
The next examples illustrate the state of knowledge after A makes the statement a1 ∨ a2. These examples are still only epistemic, but they must be evaluated at a specific point, in only some runs of the system. In order to express in ATEL that a formula must be true after a certain move, an ad hoc notation must be introduced. The original ATEL formula for the next example can be written down using t as a proposition which is true in a terminal state, and u as a proposition true if A has announced a1 ∨ a2. The original ATEL formula for the first example is ⟨⟨⟩⟩ ⬦ (t ∧ (¬u ∨ KBa1)). In a run in which A makes a different statement to a1 ∨ a2, the value of u1 will not be equal to one. Therefore the test (∼u1=one) can be used in the code instead of u.
-- [after saying a1 or a2] Kb a1
-- [] focus=none & stp=0 ->	focus’:=actA
-- [] focus=none & stp=1 ->	focus’:=epB
-- [] focus=none & stp=2 -> finish’:=true
atl "dyn1" <<>> F (finish & ((~u1=one)|(d=one|e=one)) );
-- passed
-- [after saying a1 or a2] Ka Kb a1
-- [] focus=none & stp=0 ->	focus’:=actA
-- [] focus=none & stp=1 ->	focus’:=epA


-- [] focus=none & stp=2 ->	focus’:=epB
-- [] focus=none & stp=3 -> finish’:=true
atl "dyn2" <<>> F (finish & ((~u1=one)|(d=one|e=one)) );
-- failed
Again the true formula passes and the false formula fails. This illustrates how one can check knowledge at different points than the initial situation. The selection oftests to use in the formulas seem somewhat ad hoc. We have opted not to introduce extra variables to act as fresh propositions, but to use tests on existing variables. Enough variables are already available to create a simple test for any interesting point in a run.
The main question is of course whether we can also evaluate the final formulas, which combine knowledge and strategies. The next examples show translations for the last two example formulas which mix epistemic and strate- gic operators.
-- <<A>> KB a1
-- [] focus=none & stp=0 ->	focus’:=actA
-- [] focus=none & stp=1 ->	focus’:=epB
-- [] focus=none & stp=2 -> finish’:=true
atl "atel1" <<actionA>> F (finish&(d=one|e=one));
-- passed
-- KA <<A>> KB a1
-- [] focus=none & stp=0 ->	focus’:=epA
-- [] focus=none & stp=1 ->	focus’:=actA
-- [] focus=none & stp=2 ->	focus’:=epB
-- [] focus=none & stp=3 -> finish’:=true
atl "atel2" <<actionA>> F (finish&(d=one|e=one));
-- failed
The formulas given in this section have been simplified compared to the outcome of the procedure defined in section 5. In our example, knowledge monotonically increases. For instance in the formula KA⟨⟨A⟩⟩ ⬦ KBa1 the envi- ronment has not been explicitly introduced in the translation ofthe strategic operator. In this example that is not necessary since knowledge only in- creases in this scenario. Another simplification used is that we have replaced
⟨⟨Γ1⟩⟩ ⬦ (l1 ∧ ⟨⟨Γ2⟩⟩ ⬦ (l2 ∧ φ)) in certain cases by ⟨⟨Γ1 ∪ Γ2⟩⟩ ⬦ (l2 ∧ φ)). This is equivalent if all turns of Γ1 precede the turns of Γ2, which is the case in our example. In an automated translation process there is no need for these sim- plifications, but we hope that the resulting formulas are easier to read when they are simplified.
Again, the results are correct. We hope this example has convinced the reader that explicit encoding of epistemic relations is a feasible method for model checking ATEL.

Conclusion
We have demonstrated a technique for model checking ATEL, a logic for ex- pressing properties involving both knowledge and strategies, using an ATL model checker. The approach can be used for arbitrary ATEL formulas on any turn-based acyclic transition system. Since ATL model checkers already exist, we believe this is a useful result of immediate practical value.
Application of the method involves explicit encoding of transitions corre- sponding to epistemic relations. The example given shows how to derive such code for a small turn-based acyclic system.
An interesting question for future research is whether the approach can be extended to incorporate multi-agent notions of knowledge, such as common and distributed knowledge [6].

References
Alur, R., L. de Alfaro, T. A. Henzinger, S. C. Krishnan, F. Y. C. Mang,
S. Qadeer, S. K. Rajamani and S. Ta¸siran, mocha user manual, University of Berkeley Report (2000).
Alur, R., T. A. Henzinger and O. Kupferman, Alternating-time temporal logic, in: Proceedings of the 38th IEEE Symposium on Foundations of Computer Science, Florida, 1997, pp. 100–109.
Alur, R., T. A. Henzinger and O. Kupferman, Alternating-time temporal logic, Journal of the ACM 49 (2002), pp. 672–713.
Blackburn, P., M. de Rijke and Y. Venema, “Modal Logic,” Cambridge University Press: Cambridge, England, 2001.
Clarke, E. M., O. Grumberg and D. A. Peled, “Model Checking,” The MIT Press: Cambridge, MA, 2000.
Fagin, R., J. Y. Halpern, Y. Moses and M. Y. Vardi, “Reasoning about knowledge,” The MIT Press: Cambridge, MA, 1995.
Jamroga, W. and W. van der Hoek, Some remarks on alternating-time temporal epistemic logic (2003).
Jonker, G., Feasible strategies in alternating-time temporal epistemic logic
(2003), universiteit Utrecht Master Thesis.
Osborne, M. J. and A. Rubinstein, “A Course in Game Theory,” The MIT Press: Cambridge, MA, 1994.
van der Hoek, W. and M. Wooldridge, Model checking knowledge and time, in: D. Bo˘sna˘cki and S. Leue, editors, Model Checking Software, Proceedings of SPIN 2002 (LNCS Volume 2318) (2002), pp. 95–111.


van der Hoek, W. and M. Wooldridge, Cooperation, knowledge, and time: Alternating-time temporal epistemic logic and its applications, Studia Logica 75 (2003), pp. 125–157.
van Ditmarsch, H. P., “Knowledge Games,” Ph.D. thesis, University of Groningen, Groningen (2000).
van Ditmarsch, H. P., The russian cards problem, Studia Logica 75 (2003),
pp. 31–62.
