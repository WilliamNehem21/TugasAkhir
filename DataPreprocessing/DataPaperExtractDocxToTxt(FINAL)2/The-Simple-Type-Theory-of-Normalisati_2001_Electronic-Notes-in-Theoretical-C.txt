Electronic Notes in Theoretical Computer Science 57 (2001)
URL:  http://www.elsevier.nl/locate/entcs/volume57.html  21 pages



The Simple Type Theory
of Normalisation by Evaluation


Ren e Vestergaard 1;2 Institut de Math ematiques de Luminy
Centre National de la Recherche Scienti que Marseille, France


Abstract
We develop the type theory of the Normalisation by Evaluation (NbE) algorithm for the -calculus in the simply-typed case. In particular, we show that the algorithm computes long ( )-normal forms by means of Plotkin's call-by-name and call- by-value -evaluation semantics. This is noteworthy (i) as the algorithm decides full -equality and (ii) as the algorithm so-far only has been presented in model- theoretic terms. To showcase the e ective means of the algorithm, we provide an environment machine implementation of the semantics: the NbE Machine. We also analyse the semantics and the environment machine in terms of strategies on the
 -calculus and subsequently address the untyped case. The proof burden is slight.



1	Introduction

Normalisation by Evaluation (NbE) was rst studied in its own right by Berger and Schwichtenberg about a decade ago [6]. It is a method by which the meaning function (aka evaluation functional) of a model of a language can be used to normalise terms of the language. Simply put, NbE is a type- indexed function which takes as argument a semantic object corresponding to some term and returns that term's long  ( )-normal form at the given type. All computation is performed in the model; still, the result is a syntactic term rather than a semantic object in the traditional sense. Because of this functionality, the model theory of NbE typically involves augmenting standard models with the relevant syntax; something which is highly non-trivial.
The NbE algorithm applies in many contexts and has, among other things, been presented as \an inverse to the evaluation functional" [6], \reduction-free

1 Supported under EU TMR grant # ERBFMRXCT-980170: LINEAR.
2 Email: vester@iml.univ-mrs.fr, WWW: http://iml.univ-mrs.fr/~vester
 c 2001 Published by Elsevier Science B. V. Open access under CC BY-NC-ND license.


normalisation" [1,2], \type-directed partial evaluation" [10], as the computa- tional content of Tait's typed method for proving  strongly normalising [5], as a glueing construction in intuitionistic model theory [7], and as pertaining to the Yoneda embedding in (constructive) category theory [9].

1.1	Implications
The original motivation for the NbE algorithm was largely practical [6]. The algorithm was invented to obtain syntactic representations of the internal proof objects of the MinLog proof system at LMU, Munich. The main focus in [6], apart from the domain-theoretic correctness proof, was thus the use of the quote and unquote constructs of the programming language Scheme [16] to provide a native (as opposed to interpretative) implementation of the algo- rithm for the simply-typed  -calculus. 3 The non-trivial details of how such a native implementation works in a more traditional programming language setting are given in [12]. Related to this, [10,11] substantiates the usefulness of NbE for purposes of partial evaluation and, in particular, semantics-based compiling (i.e., automated compiler derivation).

The main theoretical impact of NbE, apart from the sheer amount of its technical incarnations, has so-far been considered to be the fact that the al- gorithm amounts to a non-rewriting-based decision procedure for typed - equivalence.

1.2	Our Contributions
We will show that NbE also has interesting theoretical implications in a rewriting-based setting. In particular, we will show that the algorithm com- putes long ( )-normal forms by using very limited computational powers, i.e., Plotkin-style -evaluation semantics [17], which makes it interesting from a practical, compiler-technology perspective as well. We accomplish this by

introducing an evaluation-strategy indexed two-level  -calculus:  NbE
with

b 2 f n; v; wg for call-by-name (CBN), call-by-value (CBV), and their com- bination: call-by-whatever (CBW). We use NbE to refer to all three in con- junction. One level of NbE takes the role of the model, the other that of the target syntax. The syntactic level is evidently not subjected to evaluation. The core of the NbE algorithm is expressed as the canonical inter-level term coercers in NbE.
 We give a formal presentation of NbE which is straight to the point and which does not involve intricate model-theoretic technicalities.
 We present the type theory and Plotkin-style -evaluation semantics of NbE and show (i) that the algorithm computes long  ( )-normal forms and (ii)

3 Native means that the computation needed to e ectuate the algorithm can be and is undertaken by the evaluation mechanism of the implementing language.



that the semantics is sound and complete for simply-typed   -equality.
 We present (and code in ML) an environment machine, the NbE Machine, which implements our type-theoretic NbE semantics.
 We analyse the above in terms of reduction strategies in the -calculus and, as a result, are able to extend NbE to a large class of untyped terms | the largest possible, in fact: all terms that have a simply-typed normal form.
Although the semantics-based approaches naturally use constructive mod- els, we feel that our approach is superior in explaining the actual, e ective means by which the computation of NbE is performed, e.g., via the NbE Ma- chine. We hope this will help facilitate more practical programming language applications of NbE.

1.3	Extensions and Limitations
Related to the above, we can mention that we successfully have extended our set-up to System F, as a second to the unpublished [2]. We have also provided the rst (interpreted) implementation (in ML) of NbE for System F via its environment machine, see the preliminary [19]. It is our impression that a native implementation of NbE for System F is not possible in any existing programming language. The reason is that a sub-term of a System F term can have its type changed by type instantiation (whereas the overall type naturally remains unchanged by the Subject Reduction Property) leading to the need for \delayed" NbE-ing at the point of the type change. This essentially means that type substitution needs to be de ned in a non-standard manner in settings with higher-order type constructors, such as System F. The NbE Machine is straightforwardly equipped to accomplish such extensions whereas that obviously is not the case for native implementations.

1.4	 ,  , and the  -Calculus
A quick summary of the relevant features of the  -calculus.
De nition 1.1 The pre-terms of the simply-typed  -calculus ( !) are e ::=





x j x:e j e @ e; following Figure 1, the terms proper are e 2  ,def 9 : . e : . The extensional equational theory of ! is   = =  , cf. Figure 2.
The extensional equational theory of ! is axiomatised by several di erent rewriting relations, all with di erent properties. For example, unrestricted
 -expansion (right-to-left orientation of the -equation in Figure 2) is not strongly normalising. When adding a unit type, -reduction (left-to-right orientation of the -equation in Figure 2) destroys con uence when combined with -reduction. The most robust axiomatisation seems to be -reduction combined with what is known as (Mints') restricted  -expansion, cf. Figure 3.
Theorem 1.2 ( ! is Extensionally Well-Behaved [4])
  Rewriting : =   is axiomatised by =  [ ! [   0 , cf. Figure	3.
  Completeness : ! [   0 is con uent (up-to  ) and SN.
  Consistency :    = =   is non-trivial.
   Decidability : =   is decidable.
It is known that restricted  -expansion is closely related to Huet's long


 ( )-normal forms [15] which enjoy an analyticity property: all typing is syn- tactically evident in the (syntax of the) terms.
De nition 1.3 [Long  ( )-normal forms] The long  ( )-normal forms,
  ( ) long, are the typable (cf. Figure 1) c's in Figure 4.
Lemma 1.4 ([4])	and the normal forms of ! [   0 coincide.
Furthermore,   0 combined with ! behaves well for other typing paradigms, e.g., unit types and System F! [4,13]. Further considerations in categorical rewriting [4] and algebraic rewriting [8], have lead to restricted -expansion assuming a de facto status as the choice -relation for most typed purposes. That said, the study of the rewriting properties of the restricted -relations is non-trivial [4,13].

1.5	CBN, CBV, and the  -Calculus
In the seminal [17], Plotkin established that there are close ties between CBN and CBV -evaluation of functional programming languages (in the form of the -calculus) and -equality in continuation-passing style (CPS) languages. The connection was later improved upon by Sabry and Felleisen in the context of control operators [18]. The gist of the work is that direct-style -evaluation semantics and CPS -equality are one and the same. On the one hand, this means that CBN and CBV can simulate each other. On the other hand, we know that the two set-ups are archetypical strands of compiler technology for functional languages and the results thus make it possible to formally reason about and compare the di erent ways of implementing functional languages [18]. These results have been further expanded up-on, e.g., by Hatcli and Danvy [14] in the case of another common compiler technology for languages with control operators: thunks. The point we are making is that Plotkin's CBN and CBV -evaluation semantics are integral parts of present-day com- piler technology, even when not used directly.

1.6	Overview of This Paper
In Section 2, we introduce the type theory of NbE: the NbE-calculi. In Section 3, we establish that the calculi indeed serve the intended NbE purpose. In Section 4, we present the NbE Machine which implements the semantics of the
 NbE-calculi (i.e., of NbE) as an environment machine. In Section 5, we present
example runs of the algorithm/environment machine. Finally, in Section 6, we conclude.

1.7	Acknowledgements
We wish to thank Olivier Danvy and Laurent Regnier for fruitful discussions and Ulrich Berger, Andrzej Filinski, Martin Hofmann, and the anonymous ref-




erees for their comments. Thanks are also due to Paul Taylor whose Prooftree macros we are using.

2	The   NbE-Calculi

We now introduce our two-level NbE-calculi with the intent of making them capture the type theory of the NbE algorithm under di erent evaluation paradigms. Some of the employed design techniques can be used to de ne a more general notion of two-level calculi. We have chosen to focus fairly narrowly on NbE.

The  NbE-calculi are constructed by taking a term model of ! (i.e.,



Plotkin-style -evaluation semantics) and augmenting it with the relevant syntax, viz.   ( )  long . The former is written with overlines while the latter is written with underlines. Overlap between the two levels is only allowed at ground type. The reason is one of analyticity of the type-indexed NbE algo- rithm and is closely connected to the ground-type restriction on d's in long
 ( )-normal forms, cf. Figures 4 and 5. This particular feature turns out to virtually be the de ning property of NbE's type theory on which most of the other properties hinge.
De nition 2.1 [NbE Terms] Following Figures 5 and 6, terms are as follows:
NbE
e 2	,	9 ;  : ;  .. e : 
c 2  C ,def 9 ;  : ;  .. c : 
d 2 D ,def 9 ;  : ;  .. d : 
 NbE =def  NbE [ C
We stress that we use two-sorted variable names in the NbE terms. The x's are used exclusively for the overlined level, the model, and the y's are used exclusively for the underlined level, the syntax.
De nition 2.2 Let p q be injection of ordinary -terms into the overlined level of the NbE terms and let x y be injection into the underlined level.
Before presenting the Plotkin-style evaluation semantics of the NbE terms, we point out that the notion of value we use for the CBV case, cf. Figure 8, does not match the standard notion exactly. In particular, we admit any strictly underlined term as a value (in the overlined level). This is done exclusively to simplify the proof of Lemma 3.2. In fact, it suÆces to consider y's as the underlined values, as is standard. Still, the notion we use is obviously justi ed in the present set-up.

De nition 2.3 Let  NbE be ( NbE; ! ) for b 2 f n; v; wg with !
and

b	b	 n

! given in Figures 7 respectively 8 and !
v	w
= !
n
[ ! .
v

Lemma 2.4 (Subject Reduction) For b 2 f n; v; wg

e 2  NbE ^ e !
e0 ) e0 2  NbE



Proof. Informally, it needs to be established (i) that the ground-type level- overlap property is not broken and (ii) that the syntactic constraints (long
 ( )-normal formedness) of the underlined level are respected. The second, (ii), essentially follows from (i). In turn, (i) is established from the subject reduction property of the simply-typed -calculus by observing that types of (residuals of) sub-terms and not merely of terms proper are preserved under reduction. 4 Alternatively, the result is established by the ML well-typedness of the evaluation mechanism of the NbE Machine as presented in Appendix
A.	2
As an interlude, we can show that NbE is sound with respect to !.
De nition 2.5 Let j  j :  NbE  !  be the function that strips o  over-
and underlines.
Lemma 2.6 For b 2 f n; v; wg, !b respects ! under j  j:

e !b
e0 ) j e j ! 
j e0 j

Proof. Straightforward.	2
Two easy consequences of Lemma 2.6 following Theorem 1.2 are: Lemma 2.7 (SN) For b 2 f n;  v;  wg, !b is SN.
Lemma 2.8 (Consistency) The equational theories of  NbE are non-trivial.

2.1	Type-Indexed Inter-Level Coercion in  NbE
We now derive the core of the NbE algorithm, re ect and reify, as the canonical inter-level term coercers in NbE, cf. Figure 9. Informally, coercion is:
  source-level application of function-typed terms till reaching ground type,

  actual term-transferral at ground type using (U2O) and (O2U), and

  target-level	abstraction corresponding to function types.
In order to explicate coercion, we consider two examples. In Section 5, we will revisit these examples in the context of the NbE machine.

4 This is where the simple and polymorphic type theory of NbE part ways.



Example: Simple Function Type
Let us consider x:x at type o ! o. By applying the term to, say, y at type
o (an underlined variable of ground type may occur in both levels), we get a term of ground type which also is allowed to occur in both levels; in particular, it may occur as the body of an underlined abstraction over y:  y:( x:x) @ y. Type theoretically this reads:



x : o; y : o .. x : o


(Var)


(! I)


; y : o .. y : o



(Var)



(U2O)

; y : o .. x:x : o ! o
; y : o .. y : o


(! E)

; y : o .. ( x:x) @ y : o


; y : o .. ( x:x) @ y : o
(O2U)


(! I)

; ..  y:( x:x) @ y : o ! o
The normal form of the constructed term is  y:y under all the evaluation paradigms we consider, cf. De nition 2.3.

Example: Negative Function Type
Consider x:x at type (o ! o) ! o ! o. We can bring the term into the underlined level by the above trick applied twice if we, starting from an underlined variable (y1 below), can construct a term at (the negatively occurring) type o ! o which belongs to the overlined level. We dualise the employed trick and get:

 y1: y2:(( x:x) @ ( x1:y1  @ x1)) @ y2
The normal form of the constructed term is  y1: y2:y1  @ y2 under all evalua- tion paradigms.

The two normal forms we have presented are easily seen to be long ( )- normal forms of the originating terms at the given type | and to exist in the other level.



Lemma 2.9 # :  NbE
 !  C
(reify) and "
:  D 
NbE
 ! 
(re ect), cf.

Figure 9, are well-de ned (given a way of picking new names).
Proof. By a simple induction on typing derivations. Alternatively, the result follows by ML well-typedness of our implementation of reify and re ect, cf. Appendix A.	2
On the issue of a correct way of picking fresh variable names for reify and re ect, we point out that there is a simple solution in our set-up with two- sorted variable names. As we shall see, # and " are only applied in a very speci c manner, cf. Theorem 3.3. In particular, their application always starts with #  being applied to a completely overlined term which thus contains no y's. The y's can therefore simply be picked in order starting from \the rst"
| that is, VNy is taken to be countably in nite. As for the x's, we notice that while reify (i.e., # ) is applied to arbitrary overlined terms, re ect (i.e., " ) is only applied to underlined terms that are themselves constructed by
reify and re ect, cf. the de nition of # 1 ! 2 , Figure 9. Di erently said, any abstraction over an x we have picked will only have other fresh x's (and y's) in its scope. Hence, they too can be picked starting from \the rst" | that is, VN x is taken to be countably in nite as well. No inspection of terms is needed as long as we maintain a counter of the last picked x and/or y.
Lemma 2.10 # and " respect = under j  j:

NbE
8e 2	: j e j =
j #  e j

8d 2  D : j d j = j " d j
Proof. By a simple induction on types.	2
We see that # and " do not respect   0 under j j as the functions can be applied to abstractions. On the other hand, Mints' restrictions serve to make -expansion terminating while # and " are well-de ned in themselves by virtue of being de ned inductively on types. Furthermore, the -part of NbE deciding = is exclusively accounted for by the (once-and-for-all type- indexed) use of the reify and re ect functions: at each type, the use of re ect and reify amounts to placing the considered term in a xed context. This should be contrasted with the term-indexed, so to speak, use of the  0 - relation in traditional rewriting settings: a term is repeatedly inspected in its entirety for the presence of redexes.
Normalisation by Evaluation

With the purpose-de ned  NbE
in place, the task of presenting the NbE al-

gorithm is almost trivial. For clarity of presentation, we will initially restrict attention to closed terms but will go on to address NbE for arbitrary open terms immediately afterwards.


De nition 3.1 [x-Closed Terms]

c
  Let    be the subset of   of terms with no free variables.



x
NbE
NbE

  Let	be the subset of	of terms with no free x's.

x
  Let  C  be the subset of  C  of terms with no free x's.
The following result, the only non-standard result we need, essentially says that reduction in NbE is capable of expressing the kind of semantics-to-syntax computation we need in order to perform NbE.
Lemma 3.2 (Overline-Free Normal Forms) Let b 2 f n;  v;  wg



x 8c 2  C
:c is ! -normal ) c 2 x  ( )  long y

Proof. The result is proved by a double structural induction (on terms) along- side the following property: 5
x	x

NbE
8e 2	:e is ! -normal ) (e 2  C
_ e   x:e0 )

b	o

The only non-trivial case is e  e1 @ e2 for the latter property. Assume e is
x
!b-normal. By de nition of !b, e1 is !b-normal and by I.H., e1 2  Co _

e    x:e0 . The rst disjunct is not possible by the typing constraints on
applications. In the case of the second disjunct, e is a redex and thus not ! -
n normal which means that we are done by contradiction. Consider, now, the
x

situation for !
v
. By de nition, e2 must be normal and thus e2 2  Co _ e2 

 x:e0
by I.H. For the  rst disjunct, we have that e2
2 x   ( )  long y by the

other I.H. and e is a !
v
-redex, contradicting normality. Similarly for the

other disjunct. The case of !
w
follows.	2

We are now ready to normalise  ! by evaluation. Before doing so we stress that ! and ! admit at most one redex in an overlined term by de nition
n	v
(and thus at most as many redexes as there are outermost overlined terms in
an underlined term). If present, the redex will be located in a pre-determined position. In fact, by Lemma 3.2 there will always be a redex in that position or the term will be underlined. No inspection of overlined terms is thus needed to perform a !b step and, furthermore, reduction will always terminate. This comment will be further explored in Sections 3.1 and 4.1.
Theorem 3.3 (Normalisation by Evaluation) Let b 2 f n; v; wg

b
8e 2  :9! c 2   ( )  long:e =
c ^ ((# peq) !
xcy)

Proof. From Lemmas 2.6, 2.7, 2.10, and 3.2. Uniqueness of c is up-to  and follows by the type-indexed uniqueness of long ( )-normal forms in !.	2

5 In fact, it is a triple structural induction, with a case for d as well | we thus use the primitive induction principle for the pre-terms of NbE, cf. Figure 5.


Proposition 3.4 Theorem 3.3 (but up-to ), can be extended to open terms (i.e., to e 2  ) if the free x's of the term and their types are provided.
Proof. Abstract the free variables with 's before applying # p q at the relevant type (and rename the extra abstractions back to what they were and then strip them o of c).	2
This is not the most elegant way of making the extension to open terms and we will present a more pleasing method later. However, it allows us to abstract out the full computational content of Theorem 3.3. In order to do so, we note that, as the proof of Theorem 3.3 is constructive, we can straightforwardly "Skolemise" the property it establishes:
9C :   !  ( )  long :8e 2  :e =  C(e) ^ ((# peq) ! xC(e)y)
The above C is what will give rise to our NbE , at each type . Our reason for indexing NbE with types is closely related to the fact the extensional equational theory of ! is type-indexed: an implicitly-typed term has a unique long ( )-normal form at all its types.
Proposition 3.5 Given the type of free variables, NbE :   !  ( ) long (e 7! c, cf. Theorem 3.3 and Proposition 3.4) is functional up-to .
Proof. Long ( )-normal forms, C(e), are unique up-to , cf. Theorem 1.2.2 Before focusing on the constructive features of NbE, its e ective means,
as we have called it, we brie y state its model-theoretic meaning.
Theorem 3.6 (NbE is Sound and Complete for =  in !) 8e1; e2 2  : e1 =  e2 , NbE (e1) = NbE (e2)

3.1	The Reduction Strategy of j  NbE j I: Leftmostness and Untyped Terms
The following de nition is inspired by [3]. 6 Some notions will not be used until Section 4.1.
De nition 3.7 [Strategies] A map, S : A ! A, is a 1-strategy with respect to !A A  A if a !A S(a). It is a strategy if a !!A S(a). A (1-)strategy is e ective if it not only codes a recursive function but is de ned recursively (i.e., by case-splitting) over terms. It is normalising if e ! e0 ^ (e0 is !
 normal) ) 9n:Sn(e) = e0 . It is 1-normalising if n = 1.
With the de nition in place, we can immediately present the following re- sult which clari es our remarks prior to Theorem 3.3. It also justi es and introduces the next section. We rst remark that the underlined level is im- mutable as far as evaluation goes.  This means that evaluation in the two

6 We use \recursively over terms" rather than Barendregt's \[computable] in a relatively simple way" in [3, Chapter 13: \Reduction Strategies"] to underpin \e ective". We also introduce \1-normalising".



subterms of an underlined application is strictly parallel and cannot interfere with each other.
Lemma 3.8 If we sequentialise the relevant rule of ! to:
n
d is ! normal	c ! c0 n		n
d  @ c ! d @ c0
n
NbE
! n (up-to j j) is an e ective, normalising 1-strategy for ! in j	j.
Proof. The relation is the leftmost  -reduction strategy of ! up-to j j and the result follows from [3, Theorem 13.2.2].	2
From the proof, we can immediately conclude the following result.
Proposition 3.9 (Normalisation by Evaluation of Untyped Terms)
  NbE  \works" for any untyped  -term with a  -normal form at type  .
  NbE  \works" for any untyped  -term which is   -equal to an e 2 
Proof. As for the rst, [3, Theorem 13.2.2] applies to untyped term. The sec- ond follows from the rst (it is, in fact, equivalent to it) by Subject Reduction of  in ! and Subject Reduction of both -reduction and -expansion.  2

The NbE Machine
We now present an environment machine that implements NbE. A similar ma- chine can be de ned for NbE. The fact that the machine is an environment machine, and thus never performs (full- edged) substitution but only instanti- ates variables not under an overlined abstraction, follows from the evaluation


semantics of NbE. A subtle point is thus that the machine never performs any renaming of bound overlined variables (the x's) to maintain correct binding under reduction.  Instead, the structure of the environments subsumes the

scoping rules of  NbE
as far as the x's are concerned. As for the (syntactic,

computationally immutable) y's, we simply fresh-name them as we pass them although Figure 10 does not actually show the details. Instead we refer the reader to the ML implementation of the NbE Machine in Appendix A where the y-fresh-naming is accomplished by the addition of an extra environment.
Note 1 (Term Environments)
? is the no-where de ned term environment, cf. Figure	10.
 [  !7	 ] is environment augmentation; it shadows existing bindings.
Theorem 4.1 (The NbE Machine) h ; ?i +u  :  C  *  C  as de ned in Figure 10 is a (partial) function which preserves =  under j j. It is total
x
on  C . In that case, it computes long  ( )-normal forms.
Proof. Functionality follows as +u and +o are given recursively over terms. Totality follows (i) from x-closedness making suitably de ned in the top-left rule and (ii) from a simple adaptation of the proof of Lemma 3.2: the left premise on the n-contraction rule is always met. The last point follows from Theorem 3.3.	2
Proposition 4.2 (Open Terms) The NbE Machine is total on  C if, for a given term, we take ? to send any free variable, x, to " y for a fresh y and the right	The resulting term with these y's changed back to the x's is a long
  -normal form of the original term.
We have implemented (straightforwardly) the environment machine in Fig- ure 10 in Moscow ML, cf. Appendix A. We refer the reader to our homepage for a downloadable version. The next section will present example runs of it. First, however, we nish our discussion of the reduction strategy underlying NbE.
The Reduction Strategy of j	j II: Implementing ! [  0 Following on from Section 3.1, we have the following result.
Lemma 4.3 NbE is an e ective, 1-normalising strategy for ! [   0 .
Proof. The fact that NbE is e ective follows from Proposition 4.2. The other properties follow directly from Lemma 3.8.	2
The main point of interest in the lemma is the fact that NbE is e ective. This means that NbE does not require extensive and repeated search for re- dexes but rather is de ned as a function (i.e., a one-step relation) directly by case-splitting over the terms (aka recursive descent). It also means that the overlined level is never inspected, only tested for sort, so to speak. In


particular, it is never necessary to \look inside" a closure, i.e., an overlined abstraction paired with an environment.


Examples

Our motivating examples for the de nition of reify and re ect, cf. Section 2.1, were the rei cation of the identity function at di erent types. We now re-do these and other examples using our implementation of the NbE machine, cf. Appendix A. All code is available from our homepage. The output has been edited for space, only. The pp * functions are pretty printers, double con- structors (e.g., @@ for application) belong to the overlined level, and single constructors belong to the underlined level.

First, we reify the identity function at increasingly more complex types:

(iv) - pp_type idtype4;
> val it = "(((a1 -> a1) -> (a1 -> a1))
-> ((a1 -> a1) -> (a1 -> a1)))" : string
- nbe idtype4 idterm;
val it =
"(la y8 . (la y9 . (la y10 .
((y8 @ (la y11 . (y9 @ y11))) @ y10))))":string Second, we do arithmetic with Church Numerals, all at the same type:
pp_type CNtype;
> val it = "((a1 -> a1) -> (a1 -> a1))" : string
pp_o add;
val it = "(lla x1 . (lla x2 . (lla x3 . (lla x4 .


((x1 @@ x3) @@ ((x2 @@ x3) @@ x4))))))" : string
pp_o mult;
val it = "(lla x1 . (lla x2 . (lla x3 .
(x1 @@ (x2 @@ x3)))))" : string
pp_o exp;
val it = "(lla x1 . (lla x2 . (x1 @@ x2)))" : string With the various de nitions done as suggested, we thus have:
zero :
pp_o zero;
val it = "(lla x1 . (lla x2 . x2))" : string
nbe CNtype zero;
val it = "(la y4 . (la y5 . y5))" : string one :
pp_o one;
val it = "(lla x1 . (lla x2 . (x1 @@ x2)))" : string
nbe CNtype one;
val it = "(la y4 . (la y5 . (y4 @ y5)))" : string two = (add one) one :
nbe CNtype two;
val it = "(la y4 . (la y5 . (y4 @ (y4 @ y5))))" : string three = (add one) two :
nbe CNtype three;
val it = "(la y4 . (la y5 .
(y4 @ (y4 @ (y4 @ y5)))))" : string four = (mult two) two :
nbe CNtype four;
val it = "(la y4 . (la y5 .
(y4 @ (y4 @ (y4 @ (y4 @ y5))))))" : string eight = (exp three) two :
nbe CNtype eight;
val it =
"(la y4 . (la y5 .
(y4@(y4@(y4@(y4@(y4@(y4@(y4@(y4@y5))))))))))":string


Conclusion

We have, as a rst, presented the type theory of the well-studied NbE al- gorithm by means of a Plotkin-style -evaluation semantics. The semantics was implemented with an environment machine. Succinctly stated, our main result is that the algorithm e ectively computes long  ( )-normal forms, and


thus decides full -equality in the simply-typed -calculus, by means of - evaluation only. No -reduction is employed. Instead, we de ned a \term skeleton", # , at each type which is wrapped around the considered term. The skeletons have the surprising e ect of bringing all redexes into head po- sition relative to the underlined level and making the resulting normal forms analytic (i.e., in   ( )  long ). Future work includes the treatment of System F
[19] and (embedded) applications of the NbE Machine.

References

[1] Thorsten Altenkirch, Martin Hofmann, and Thomas Streicher. Reduction-free normalisation for a polymorphic system. In Proceedings of the Eleventh Annual IEEE Symposium on Logic in Computer Science, New Brunswick, New Jersey, July 1996. IEEE Computer Society Press.
[2] Thorsten Altenkirch, Martin Hofmann, and Thomas Streicher. Reduction-free normalisation for system F. Manuscript, 1996.
[3] Henk Barendregt. The Lambda Calculus | Its Syntax and Semantics (Revised Edition). North-Holland, 1984.
[4] C. Barry Jay and Neil Ghani. The virtues of eta-expansion. Journal of Functional Programming, 5(2):135{154,	1995.
[5] Ulrich Berger. Program extraction from normalization proofs. In M. Bezem and J. F. Groote, editors, Typed Lambda Calculi and Applications, number 664 in Lecture Notes in Computer Science, pages 91{106, Utrecht, The Netherlands, March 1993.
[6] Ulrich Berger and Helmut Schwichtenberg. An inverse of the evaluation functional for typed -calculus. In Proceedings of the Sixth Annual IEEE Symposium on Logic in Computer Science, pages 203{211, Amsterdam, The Netherlands, July 1991. IEEE Computer Society Press.
[7] Thierry Coquand and Peter Dybjer. Intuitionistic model constructions and normalization proofs. Mathematical Structures in Computer Science, 7:73{94, 1997.
[8] Roberto Di Cosmo and Delia Kesner. Combining algebraic rewriting, extensional lambda calculi, and xpoints. Theoretical Computer Science, 169(2):201{220, 5 December 1996.
[9] Djordje C  ubri c, Peter Dybjer, and Philip Scott. Normalization and the Yoneda embedding. Mathematical Structures in Computer Science, 8(2):153{192, April 1998.
[10] Olivier Danvy. Type-directed partial evaluation. In Guy L. Steele Jr., editor, Proceedings of the Twenty-Third Annual ACM Symposium on Principles of Programming Languages, pages 242{257, St. Petersburg Beach, Florida, January 1996. ACM Press.


[11] Olivier Danvy and Ren e Vestergaard. Semantics-based compiling: A case study in type-directed partial evaluation. In Herbert Kuchen and Doaitse Swierstra, editors, Proceedings of PLILP-8, volume 982 of LNCS. Springer-Verlag,	1996.
Extended version available as the technical report BRICS-RS-96-13.
[12] Andrzej Filinski.  A semantic account of type-directed partial evaluation. In Gopalan Nadathur, editor, International Conference on Principles and Practice of Declarative Programming, number 1702 in Lecture Notes in Computer Science, pages 378{395, Paris, France, September 1999. Springer- Verlag. Extended version available as the technical report BRICS RS-99-17.
[13] Neil Ghani. Eta-expansions in F!. In Dirk van Dalen and Marc Bezem, editors, CSL-10, LNCS 1258, pages 182{197,	1996.
[14] John Hatcli and Olivier Danvy. Thunks and the -calculus. Journal of Functional Programming, 7(3):303{319, May 1997.
[15] G erard Huet. R esolution d' equations dans les langages d'ordre 1, 2,	, !. Th ese
d'E tat, Universit e de Paris VII, Paris, France, 1976.
[16] Richard Kelsey, William Clinger, and Jonathan Rees, editors. Revised5 report on the algorithmic language Scheme. Higher-Order and Symbolic Computation, 11(1):7{105, 1998. Also appears in ACM SIGPLAN Notices 33(9), September 1998.
[17] Gordon D. Plotkin. Call-by-name, call-by-value and the -calculus. Theoretical Computer Science, 1:125{159,	1975.
[18] Amr Sabry and Matthias Felleisen. Reasoning about programs in continuation- passing style. LISP and Symbolic Computation, 6(3/4):289{360, December 1993.
[19] Ren e Vestergaard. The polymorphic type theory of Normalisation by Evaluation (preliminary version). Available at the author's homepage, 2001.

A	The NbE Machine in (Moscow) ML
A.1	Abstract Syntax infixr -->;
type T_var = int;

datatype Ty = tvar of T_var
| --> of Ty * Ty; type O_var = int;
type U_var = int;


datatype O_term = ovar of O_var
| oabstr of O_var * O_term
| oappl of O_term * O_term
| u2o of U_deconst
and U_const	= uabstr of U_var * U_const
| deconst of U_deconst
| o2u of O_term and U_deconst	= uvar of U_var
| uappl of U_deconst * U_const;

val voidtype = tvar ~1; val voidterm = ovar ~1;


A.2	Up and Down Arrows and Evaluation load "Int";
val counter = ref 0;
fun newindex () = let val _ = counter := !counter +	1
in !counter end;

fun setcounter n = counter := n;
use "abstract-syntax.sml"; use "pretty-print.sml"; datatype Envval = envval of O_term
(int -> Envval)
(int -> U_deconst); exception unbound_variable of string;
exception ill_formed_term_or_wrong_type of string;

val init_env = (fn var =>
raise unbound_variable ("** "^(Int.toString var)));

fun aug_env tenv var closure = (fn var2 => if var=var2
then closure
else (tenv var2) handle unbound_variable str
=> raise unbound_variable ((Int.toString var) ^ " " ^ str));

fun down (tvar var) e =


o2u e
| down (t1 --> t2) e =
let val var = newindex()
in uabstr (var,(down t2 (oappl (e, up t1 (uvar var))))) end
and up (tvar var) d = u2o d
| up (t1 --> t2) d =
let val var = newindex()
in oabstr (var,(up t2 (uappl (d, down t1 (ovar var))))) end;

fun o_eval (ovar ov) term_env rename_env =
let val envval (ot,term_env1,rename_env1) = (term_env ov) in o_eval ot term_env1 rename_env1
end
| o_eval (oabstr (ov,ot)) term_env rename_env = ((oabstr (ov,ot)),term_env,rename_env)
| o_eval (oappl (ot1,ot2)) term_env rename_env = (let val (ot3,term_env1, rename_env1)
= o_eval ot1 term_env rename_env in (case ot3
of (oabstr (ov,ot4))
=> o_eval ot4
(aug_env term_env1 ov
(envval (ot2,term_env,rename_env))) rename_env1
| _ => raise ill_formed_term_or_wrong_type ((pp_o ot3)
^ " ** expected abstraction at fct type"))
end)
| o_eval (u2o ud) term_env rename_env =
(u2o (ud_eval ud term_env rename_env),init_env,init_env) and uc_eval (uabstr (uv,uc)) term_env rename_env=
let val var = newindex() in uabstr (var,
(uc_eval uc term_env
(aug_env rename_env uv (uvar var))))
end
| uc_eval (deconst ud) term_env rename_env = deconst (ud_eval ud term_env rename_env)
| uc_eval (o2u ot) term_env rename_env =
let val (ot1,_,_) = o_eval ot term_env rename_env in (o2u ot1)
end
and ud_eval (uvar uv) term_env rename_env = rename_env uv
| ud_eval (uappl (ud,uc)) term_env rename_env =


uappl ((ud_eval ud term_env rename_env), (uc_eval uc term_env rename_env));

fun nbe ty term
= let val _ = setcounter	0
in pp_uc (uc_eval (down ty term) init_env init_env) end;
