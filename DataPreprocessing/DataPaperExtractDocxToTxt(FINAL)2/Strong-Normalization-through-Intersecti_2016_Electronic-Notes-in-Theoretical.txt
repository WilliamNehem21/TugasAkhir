Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 323 (2016) 75–91
www.elsevier.com/locate/entcs

Strong Normalization through Intersection Types and Memory
Antonio Bucciarelli	Delia Kesner
Univ Paris Diderot, Sorbonne Paris Cit´e, PPS, CNRS, Paris, France
Daniel Ventura
Univ. Federal de Goia´s, Instituto de Inform´atica, Goiˆania, Brazil

Abstract
We characterize β-strongly normalizing λ-terms by means of a non-idempotent intersection type system. More precisely, we first define a memory calculus K together with a non-idempotent intersection type system K, and we show that a K-term t is typable in K if and only if t is K-strongly normalizing. We then show that β-strong normalization is equivalent to K-strong normalization. We conclude since λ-terms are strictly included in K-terms.
Keywords: Lambda-calculus, memory calculus, strong normalization, intersection types.

Introduction
It is well known that the β-strongly normalizing λ-terms can be characterized as those being typable in suitable intersection type (IT) systems. This result dates back to the late 1970s and early 1980s, when intersection types were invented to endow the pure lambda calculus with powerful type-assignment systems [2,12,28,26]. A survey of these results, out of the scope of this paper, can be found for instance in [35,3].
In more recent years, a revisitation of those early results has been driven by the introduction of resource aware semantics of λ-calculi [21,6,15,7] and the corre- sponding non-idempotent intersection types assignment systems. The inhabitation problem for instance, known to be undecidable in an idempotent setting [32], was proved to be decidable for non-idempotent types [8].
Just like their idempotent precursors, these type systems allow for a charac- terization of strong normalization [5,14] (as well as weak normalization and head normalization [15,9]), but they also grant a substantial improvement: proving that

http://dx.doi.org/10.1016/j.entcs.2016.06.006
1571-0661/© 2016 The Author(s). Published by Elsevier B.V.
This is an open access article under the CC BY license (http://creativecommons.org/licenses/by/4.0/).

typable terms are strongly normalizing becomes much simpler. Let us provide a brief account of this improvement, by highlighting in the way the quantitative character of non-idempotent intersection types versus the qualitative flavor of the idempotent ones. The proof of the highlighted statement above, in the non-idempotent case, goes roughly as follows: given a typing derivation for a term t, and willing to prove that t is strongly normalizing, take whatever β-reduct tj of t. The subject reduction lemma, in this case, ensures not only that tj is typable but also that there exists a typing derivation for tj whose size is smaller than the one of the typing derivation for t we started from. Hence any β-reduction sequence starting from t is finite.
This shrinking of the size of typing derivations along reduction sequences, in sharp contrast to what happens in the idempotent setting, is essentially due to the fact that a type derivation for a term of the shape (λx.u)v may require as many sub-derivations for v as the number of occurrences of x in u 1 . Let us provide a simple example involving the Church numeral n := λy.λx.y(y(...yx)...).
Why is the term u = λx.t(t(...tx)...), t being an arbitrarily complex term, “sim- pler to type” than its β-expanded form nt? The point is that the typical non- idempotent intersection type 2 that can be assigned to the Church numeral n is, in our notation, [[σ] → σ, ..., [σ] → σ] → [σ] → σ, the leftmost multiset containing n copies of [σ] → σ. Thus, in order to assign a type to nt, n typing derivations assigning [σ] → σ to t must be provided, exactly like in a type derivation for u. At the same time, the outermost application nt vanishes with the reduction nt →β u, so the typing derivation for u is smaller than that for nt.
In the idempotent case, on the other hand, a type 3 for n is an instance of
{{σ}→ σ}→ {σ}→ σ, and the typing derivations for u may be hugely bigger than those for nt, the former requiring n sub-derivations for t, the latter just one. That’s why, for idempotent intersection type systems, the proof of the result above cannot be combinatorial, and is typically based on the reducibility argument [31,17,25].
This shift of perspective goes beyond lowering the logical complexity of the proof: the quantitative information provided by typing derivations in the non-idempotent setting unveils interesting relations between typings (static) and reductions (dy- namic) of λ-terms. For instance, in [15], a correspondence between the size of a typing derivation for t and the number of steps taken by the Krivine machine to reduce t is presented, and in [5] it is shown how to compute the length of the longest β-reduction sequence starting from any typable strongly normalizing λ-term.
In this paper, we provide a characterization of strongly normalizing λ-terms via a typing system based on non-idempotent intersection types. The structure of the proof is the following:
We define the K-calculus, reminiscent of Klop’s I-calculus [24], where terms are defined by enriching λ-terms with a memory operator, β-reduction is split into two different non-erasing reductions, and terms are considered modulo an equivalence

1 More precisely, it requires exactly as many sub-derivations for v as the number of typed occurrences of x
in u.
2 Non-idempotent intersections are denoted by multisets, e.g. [τ, τ, σ] stands for τ Λ τ Λ σ.
3 Idempotent intersections are denoted by sets, e.g. {τ, σ} stands for τ Λ σ.

relation, reminiscent of Regnier’s σ-reduction [29]. In contrast to [24], λ-terms are strictly included in K-terms, which makes our development much easier.
We introduce the typing system K for K-terms, based on system Q for focused intuitionistic logic [18], and we show that a K-term is K-typable if and only if it is K-strongly normalizable. This proof is only based on typing properties of Subject Reduction and Subject Expansion, and does not use any reducibility argument.
We prove that λ-terms are K-strongly normalizable if and only if they are β- strongly normalizable in the λ-calculus.
Related works: It is only discussed here different approaches to prove strong nor- malization of λ-calculus by means of intersection types. Several characterizations of strong normalization via idempotent intersection types have been presented for the λ-calculus; a survey can be found for example in [3]. To the best of our knowledge, two characterizations of strong normalization via non-idempotent intersection types have been presented so far for the λ-calculus, by A. Bernadet and S. Lengrand [5] and by E. De Benedetti and S. Ronchi Della Rocca [14,13], respectively. Non-idempotent intersection is also used in the systems of [22,16], both for the λ-calculus, but char- acterization of strong normalization is achieved through a relation to an idempotent intersection type system.
In [5], a subtyping relation is introduced to get the subject reduction property, but the system types unnecessary instances of arguments, and turns out to be non relevant, i.e. some sort of weakening is allowed. Notions of optimality and principality 4 of typing derivations are used to derive an exact upper bound for reduction steps. Besides, the “strong normalizing implies typability” property is obtained in [5] through a subject expansion property on a restricted version of the β-reduction, where a memory set is used to trace the free variables of erased terms. In our memory calculus, which is non erasing, both the subject reduction and the subject expansion properties hold unconditionally.
In [14] the typing rule for term variables is weakened, thus the system is non relevant. The characterization of strong normalization, more precisely the “strong normalization implies typability” property, follows from an adaptation of the per- petuality proof in [27]. In [13] another proof of the same property is obtained through an inductive definition of the set of strongly normalizing terms, as done in [19] and in the present work.
In the extended framework of the λ-calculus with explicit substitution, non- idempotent types were also used to characterize strong normalization [5,19]. In [5] the typing system deals with two explicit substitution calculi based on the struc- tural propagation paradigm, while in [19] the substitution at a distance paradigm is investigated. In all the cases, the normalization property is proved by relying on the postponement of erasing steps, where the explicit substitution operator plays the role of a memory device.
Regarding the intuitionistic sequent calculus, Kikuchi [23] refines Valentini’s sys- tem [33] to yield an idempotent IT system which characterizes strong normalization.

4 The notion of principal typing in [5] is different from the usual definition in the literature, e.g. [30,37,22].

These ideas give rise to a non-idempotent intersection system for a computational interpretation of the focused intuitionistic calculus [20].
Structure of the paper: Section 2 presents the syntax and semantics of the K-calculus, while Section 3 introduces the non-idempotent typing system K for K-terms together with its properties. The characterization of β and K-strongly normalizing terms is developed in Section 4. We conclude in Section 5.

The memory calculus
We are going to characterize the set of strongly normalizing λ-terms by using a memory calculus called K-calculus – reminiscent of Klop’s I-calculus [24]– as main technical tool. The point of the memory device in [24] is to obtain a calculus in which strong and weak normalization coincide, which is possible when no information can be lost along reduction sequences 5 . This section introduces the syntax and the operational semantics of the K-calculus, which also uses a memory device to avoid loss of information.
Given a countable infinite set of symbols x, y, z, . . . we define the set of K-terms by means of the following grammar.

t, u, v ::= x | λx.t | tu | t[[u]]

The syntactic item [u ] is called a memory operator. Notice that the set of
λ-terms is strictly included in the set of K-terms.
The size of a term t, written |t|, is defined by |x| := 1, |λx.u| := |u| + 1,
|uv| := |u| + |v| + 1 and |t[[u]]| := |t| + |u| + 1. The notions of free and bound variables are defined as usual, in particular, fv(t[[u]]) := fv(t) ∪ fv(u), bv(t[[u]]) := bv(t) ∪ bv(u). We work with the standard notion of α-conversion i.e. renaming of bound variables. Substitutions are (finite) functions from variables to terms. We use the notation {x1/u1,..., xn/un} (n ≥ 0) for a finite substitution φ such that φ(xi)= ui for 1 ≤ i ≤ n. Application of the substitution φ to the term t, written tφ, may require α-conversions in order to avoid the capture of free variables. Hence we follow the common practice of considering terms up to α-equivalence. However, we feel free to represent α-equivalence classes by any of their members, provided they respect the usual Barendregt’s convention [1] stipulating that the sets of free and bound variables of any term are disjoint.
The standard notion of β-reduction on λ-terms, written →β, is generated by the closure by contexts of the rewriting rule (λx.t)u '→β t{x/u}. In other words, the rule β is compatible with the structure of λ-terms. Here is an example of β-reduction:
(λx.λy.y)xjyj →β (λy.y)yj →β yj

5 For instance, there is no loss of information in the λ-I-calculus as opposed to the full λ-calculus.

We now consider the following equation and rewriting rules on K-terms.
Equation:	Rules:
t[[u]]v	=σ (tv)[[u]]	(λx.t)u '→neb t{x/u} if x ∈ fv(t)
(λx.t)u '→m	t[[u]]	if x ∈/ fv(t)
The names neb and m mean, respectively, non-erasing beta and memory. The reduc- tion relation →neb,m is generated by the closure by contexts of the rewriting rules '→neb and '→m. The relation ∼σ, inspired by the σ-equivalence [29] used to identify some permutation of redexes, is the equivalence relation on K-terms generated by the equation =σ above. Two σ-equivalent terms are undistinguishable in many re- spects, as for instance the length of reduction sequences starting at them, and the size of their typing derivations.
The K-calculus is given by the set of K-terms and the reduction relation →K on K-terms, generated by the reduction →neb,m modulo the equivalence ∼σ. Thus for example


More precisely,
(λx.λy.y)xjyj →K (λy.y)[[xj]]yj →K yj[[xj]]

(λx.λy.y)xjyj →m (λy.y)[[xj]]yj ∼σ (λy.y)yj[[xj]] →neb yj[[xj]]
Remark that the term yj[[xj]] is not K-reducible anymore, i.e. it is a K-normal form. Another example is given by the following K-reduction sequence which occurs inside a memory operator
y[[(λw.(λx.x)z)[[zj]]xj]] →K y[[(λw.z)[[zj]]xj]] →K y[[z[[xj]][[zj]]]]
Given any reduction relation R,a term t is said to be R-strongly normalizing, written t ∈ SN (R), iff there is no infinite R-reduction sequence starting at t.
The Typing System
In this section we introduce a type system for K-terms, called K, whose intersection types, IT for short, are similar to those in [10,11].
Let A be a countable infinite set of type variables α, β, γ,.. .. The sets T of strict types, ranged over by σ, τ, .. ., and U of multiset types, ranged over by M, Mj,.. ., are defined by the following grammars:
σ, τ, ρ, γ ::= α | M→σ	M ::= [σi]i∈I, I finite set
Types are strict 6 , i.e. multiset types do not occur on the right-hand sides of arrows. The empty multiset is written [ ]. A multiset type should be read as the intersection of the strict types it contains. For instance, the multiset [τ, τ, σ] stands

6 The terminology is due to S. van Bakel [34].

for τ ∧ τ ∧ σ, where the symbol ∧ is associative, commutative and non-idempotent. Observe however that the commutativity, associativity and non-idempotency of the intersection symbol is granted by the multiset notation: no further equivalence relation on types is needed.
Type assignments, written Γ, Δ, are functions from variables to multiset types, assigning the empty multiset to all but a finite set of variables. The domain of Γ is given by dom(Γ) := {x | Γ(x) /= [ ]}. The intersection of type assignments, written Γ + Δ, is defined by (Γ + Δ)(x) := Γ(x)+ Δ(x), where + denotes multiset union. Hence, dom(Γ + Δ) = dom(Γ) ∪ dom(Δ). An example is {x:[σ], y:[τ ]} +
{x:[σj], z:[τ j]} = {x:[σ, σj], y:[τ ], z:[τ j]}.
When dom(Γ) and dom(Δ) are disjoint we write Γ; Δ instead of Γ + Δ. We write x:[σi]i∈I ; Γ, even when I = ∅, for the assignment (x:[σi]i∈I ; Γ)(x) = [σi]i∈I and (x:[σi]i∈I ; Γ)(y)= Γ(y) if y /= x. We write Γ \ x for the assignment (Γ \ x)(x)= [ ] and (Γ \ x)(y)= Γ(y) if y /= x.
The type assignment system K for K-terms is defined in Figure 1. Notice that, in contrast to [4,14] the system is syntax directed.


The typing rule (→e) could be specified by means of two different typing rules separating the cases I = ∅ and I /= ∅:

Γ ▶ t:[ ] →τ	Δ ▶ u:σ


Γ+Δ ▶ tu:τ
Γ ▶ t:[σi]i∈I →τ	I /= ∅	(Δi ▶ u:σi)i∈I


Γ +i∈I Δi ▶ tu:τ

Indeed, if I = ∅ in rule (→e), then the argument u is erasable, so that we require exactly one typing derivation for u (the typing witness), by setting |J| = 1 (notice that the type σ is ignored in the final conclusion of the rule); otherwise the argument u is not erasable and several typing derivations for u are required, one for each type of the multiset [σi]i∈I , thus J = I. We prefer however to capture both cases in the single rule (→e) in order to save some space in our proofs.
A (typing) derivation in system K is a tree Φ obtained by applying the (in- ductive) rules of the typing system. We write Φ d Γ ▶ t:τ if there is a derivation Φ in system K ending in the type judgment Γ ▶ t:τ . A term t is typable in system K iff there exist a derivation Φ, an assignments Γ and a type τ such that Φ d Γ ▶ t:τ . For any typing derivation tree Φ, we define sz(Φ) to be the number of nodes of Φ.

It is worth noticing that the rule (→e) makes the difference between an intersec- tion type system characterizing head/weak normalization [18,19] and one character- izing strong normalization. Indeed, in the former, the case I = ∅ would not impose to type the argument u, and one would obtain typing derivations of the form:
Γ ▶ t:[ ] →τ Γ ▶ tu:τ
where tu is typed but u is untyped. Conversely, in our system, all the subterms of a typable term have to be typable, thus guaranteeing termination for any reduction strategy.
As an example of typing derivation in K, for δ = λx.xx one has

	

Φδ :=
x : [[α] → β] ▶ x:[α] → β	x : [α] ▶ x:α


x : [[α], [α] → β] ▶ xx:β
▶ λx.xx:[[α], [α] → β] → β



hence



and also


z : [γ] ▶ z:γ
z : [γ] ▶ λy.z:[ ] → γ	Φδ d ▶ δ:[[α], [α] → β] → β z : [γ] ▶ (λy.z)δ:γ

z : [γ] ▶ z:γ	Φδ d ▶ δ:[[α], [α] → β] → β z : [γ] ▶ z[[δ]]:γ

On the other hand, neither (λy.z)Ω nor z[[Ω]] are typable in K for Ω = δδ. The K-system enjoys relevance (absence of weakening).
Lemma 3.1 (Relevance) If Φ d Γ ▶ t:τ then dom(Γ) = fv(t).
Proof. By induction on the derivation of Φ.	2
Moreover, the equivalence relation ∼σ does not alter at all the typing relation.
Lemma 3.2 (Typing Invariance for ∼σ) Let t0 ∼σ tj . Then Φ d Γ ▶ t0:τ iff
Φj d Γ ▶ tj :τ . Moreover, sz(Φ) = sz(Φj).
Proof. By induction on the proof of t0 ∼σ tj . We only show the base case, the
others being straightforward.
If t0 = t[[u]]v =σ (tv)[[u]] = tj , then by construction Γ = Δ + Π +j∈J Γj and Φ is
of the following form:

Φt d Δ ▶ t:[σi]i∈I →τ	Φu d Π ▶ u:ρ
Δ+Π ▶ t[[u]]:[σi]i∈I →τ	 Φj d Γj ▶ v:σj 
j∈J

Δ+Π +j∈J Γj ▶ t[[u]]v:τ

where |J| = 1 if I = ∅ and I = J otherwise. Moreover, sz(Φ) = sz(Φt)+ 

sz(Φu
) +j∈J




Φj :=
sz(Φj ) + 2. Then,
Φt d Δ ▶ t:[σi]i∈I →τ	(Φj d Γj ▶ v:σj)j∈J


Δ +j∈J Γj ▶ tv:τ	Φu d Π ▶ u:ρ
Δ +j∈J Γj +Π ▶ (tv)[[u]]:τ



where sz(Φj)= sz(Φ )+	sz(Φj )+ sz(Φ
)+2 = sz(Φ).	2

t	j∈J	v	u
We are now going to show the essential properties of the typing system K: Subject Reduction (Theorem 3.4) and Subject Expansion (Theorem 3.6), which follow, respectively, from Lemma 3.3 and Lemma 3.5.
Lemma 3.3 (Substitution) If Φt d x:[ρi]i∈I ;Γ ▶ t:τ and (Φi d Δi ▶ u:ρi)i∈I then
Φt{x/u} d Γ +i∈I Δi ▶ t{x/u}:τ where sz(Φt{x/u})= sz(Φt) +i∈I sz(Φi ) − |I|.
Proof. By induction on the structure of t.
If t = y /= x then t{x/u} = y. By relevance one has x : [ ]; Γ= {y : [τ ]} so that I = ∅ and Γ = {y : [τ ]} and sz(Φ) = 1. Therefore, sz(Φy{x/u})= sz(Φy)+0−0= sz(Φy) +i∈I sz(Φi ) − |I|.
If t = x then t{x/u} = u. By construction and relevance one has x : [ρi]i∈I ;Γ =
{x : [τ ]} so that I = {m} and Γ = ∅ and ρm = τ and sz(Φ) = 1. Therefore, for any context Δm such that Φm d Δm ▶ u:ρm the result holds, where sz(Φx{x/u})= sz(Φx)+ sz(Φm) − 1= sz(Φm).
u	u
If t = λy.v then by α-conversion one can suppose w.l.o.g. that y /= x, y ∈/

fv(u), y ∈/
dom(γ) and (y ∈/
dom(Δi))i∈I . By construction, τ = M → σ and

Φv dy : M; x : [ρi]i∈I ;Γ ▶ v:σ where sz(Φv)+1 = sz(Φλy.v). By the i.h., Φv{x/u} d (y : M; Γ) +i∈I Δi ▶ v{x/u}:σ where sz(Φv{x/u})= sz(Φv)+i∈I sz(Φi )−|I|. One has y ∈/ dom(Δi) for any i ∈ I thus (y : M; Γ) +i∈I Δi = y : M; (Γ +i∈I Δi). The derivation Φλy.v{x/u} is hence


Φv{x/u} dy : M;Γ +i∈I Δi ▶ v{x/u}:σ


Γ +i∈I Δi ▶ λy.v{x/u}:M→σ
(→i)

and sz(Φλy.v{x/u})= sz(Φv{x/u})+1 = sz(Φλy.v) +i∈I sz(Φi ) − |I|.
If t = pv then by construction one has x : [ρi]i∈I ;Γ = Δ +j∈J Γj, where Φp d

Δ ▶ p:[σ ]
→τ and (Φj d Γ ▶ v:σ )
and sz(Φ
)= sz(Φ )+	sz(Φj )+ 1,

k k∈K
v	j	j
j∈J
pv	p	j∈J	v

where either K = ∅ and |J| = 1, or K = J . One has Δ = x : [ρi]i∈I ; Δj and (Γj =
x : [ρi]i∈I ; Γj )j∈J where I = Ip ∪j∈J Ij, and Ip, (Ij)j∈J can be assumed to be pair-
j	j

wise disjoint sets w.l.o.g. By the i.h., Φp{x/u} d Δj +i∈I
Δi ▶ p{x/u}:[σk]k∈K →τ

j v{x/u}
d Γj +i∈I
Δi ▶ v{x/u}:σj)j∈J where sz(Φp{x/u}) = sz(Φp) +i∈Ip

sz(Φi ) − |I | and sz(Φj
)= sz(Φj )+	sz(Φi ) − |I |, for each j ∈ J . Note

u	p	v{x/u}
v	i∈Ij	u	j

that Δj +j∈J Γj = (x : [ρi]i∈I ; Γ) \\ x = Γ and that +i∈I Δi +j∈J (+k∈I Δk) = 
j	p	j

+i∈I Δi. Therefore, Φ(pv){x/u} is of the form


Φp{x/u} d Δ′ +i∈I

Δi ▶ p{x/u}:[σk]k∈K →τ	 Φj
Γ +i∈I Δi ▶ (pv){x/u}:τ

d Γ′ +i∈I

Δi ▶ v{x/u}:σj 



j∈J

where sz(Φ(pv){x/u})= sz(Φp{x/u})+j∈J sz(Φj
)+1 = sz(Φp)+i∈Ip
sz(Φi ) −

|I | +
sz(Φj )+	(+
sz(Φk)) −	|I | +1 = sz(Φ )+ 
sz(Φi ) − |I|.

p	j∈J
v	j∈J
k∈Ij
u	j∈J	j
pv	i∈I	u

If t = p[[v ] then by construction x : [ρi]i∈I ; Γ = Δ + Π such that Φp d Δ ▶ p:τ and Φv d Π ▶ v:σ, where sz(Φt)= sz(Φp)+ sz(Φv) + 1. One has Δ = x : [ρi]i∈I ; Δj and Π = x : [ρi]i∈I ; Πj where Ip ∪ Iv = I and Δj + Πj = Γ. Suppose w.l.o.g. that
Ip and Iv are disjoint. By the i.h., Φp{x/u} d Δj +i∈I Δi ▶ p{x/u}:τ and Φv{x/u} d

Πj +i∈I
Δi ▶ v{x/u}:σ such that sz(Φp{x/u}) = sz(Φp) +i∈Ip
sz(Φi ) − |Ip| and

i
sz(Φv{x/u})= sz(Φv) +i∈Iv sz(Φ ) − |Iv|. Then,


Φp[[v]]{x/u} :=

Φp{x/u} d Δ′ +i∈I

Δi ▶ p{x/u}:τ	Φv{x/u} d Π′ +i∈I Γ +i∈I Δi ▶ p{x/u}[[v{x/u}]]:τ

Δi ▶ v{x/u}:σ

where sz(Φp[[v]]{x/u})= sz(Φp{x/u})+ sz(Φv{x/u})+1 = sz(Φt) +i∈I sz(Φi ) −|I|.
2
Theorem 3.4 (Weighted Subject Reduction) Let Φ d Γ ▶ t:τ . If t →K tj then there exists Φj d Γ ▶ tj:τ such that sz(Φ) > sz(Φj).
Proof. By induction on the reduction relation →K using Lemma 3.2 to justify the statement for the equivalence relation ∼σ.
If t = (λx.v)u then by construction Γ = Δ +j∈J Γj and Φ has the form:
Φv dx : [σi]i∈I ;Δ ▶ v:τ
  Δ ▶ λx.v:[σi]i∈I →τ	(Φj d Γj ▶ u:σj)j∈J
Φ :=
Δ +j∈J Γj ▶ (λx.v)s:τ
Moreover, sz(Φ) = sz(Φ )+	sz(Φj ) + 2. There are two cases for tj.
v	j∈J	u

· If x ∈ fv(v) then tj = v{x/u}.
Suppose I = ∅ so that Γ = Δ + Γu and Φv d Δ ▶ v:τ where x ∈/
However, x ∈ fv(v) then, by Lemma 3.1, this case is not possible.
dom(Δ).

Suppose I /= ∅ (i.e. I = J ) so thatΓ = Δ+i∈I Γi where Φv dx : [σi]i∈I ;Δ ▶ v:τ
and (Φi d Γi ▶ u:σi)i∈I and sz(Φ) = sz(Φv) +i∈I sz(Φi ) + 2. By Lemma 3.3,
Φv{x/u} d Γ ▶ v{x/u}:τ where sz(Φv{x/u})= sz(Φv) +i∈I sz(Φi ) − |I| < sz(Φ).
We are done with this case taking Φj := Φv{x/u}.
· If x ∈/ fv(v) then tj = v[[u]]. Moreover, Lemma 3.1 gives I = ∅ so that J = {j}
where Γ = Δ + Γj. Then,
 Φv d Δ ▶ v:τ	Φj d Γj ▶ u:σj
Φ :=
Γ ▶ v[[u]]:τ
where sz(Φj)= sz(Φ )+ sz(Φj )+1 < sz(Φ).
v	u

All the inductive cases are straightforward.
2
We illustrate the Weighted Subject Reduction property by the following exam- ple. Let 2 be the Church numeral λy.λx.y(y(x)) and let t be an arbitrary closed term. Then u0 = 2t →β λx.t(t(x)) = u1. Suppose Φt d ▶ t:[σ] →σ. Then, given the following typing derivation Φ0 for u0


Φ0 :=
Φ2 d ▶ 2:[[σ] → σ, [σ] →σ] → [σ] →σ	Φt d ▶ t:[σ] →σ	Φt d ▶ t:[σ] →σ


▶ 2t:[σ] →σ

where Φ2 is the following typing derivation:

	



y : [[σ] →σ] ▶ y:[σ] →σ
y : [[σ] →σ] ▶ y:[σ] →σ	x : [σ] ▶ x:σ


y : [[σ] →σ],x : [σ] ▶ yx:σ


Φ2 :=
y : [[σ] → σ, [σ] →σ],x : [σ] ▶ y(yx):σ
y : [[σ] → σ, [σ] →σ] ▶ λx.y(yx):[σ] →σ
▶ λy.λx.y(yx):[[σ] → σ, [σ] →σ] → [σ] →σ

we can construct the following typing derivation Φ1 for u1





Φ1 :=
Φt d ▶ t:[σ] →σ
Φt d ▶ t:[σ] →σ	x : [σ] ▶ x:σ


x : [σ] ▶ tx:σ x : [σ] ▶ t(tx):σ
▶ λx.t(tx):[σ] →σ

such that sz(Φ0) > sz(Φ1). Indeed,
sz(Φ0)= sz(Φt) · 2+8 > sz(Φt) · 2+4 = sz(Φ1)
To obtain Subject Expansion we first need the following property.
Lemma 3.5 (Reverse Substitution) Let x, t, u be K-terms. If x ∈ fv(t) and Φ d Γ ▶ t{x/u}:τ then Γ = Δ +i∈I Γi where I /= ∅ and Φt d x : [σi]i∈I ;Δ ▶ t:τ and (Φi d Γi ▶ u:σi)i∈I.
Proof. By induction on the structure of t.
If t = x then t{x/u} = u and the result holds, for Δ = ∅ and I = {m} where σm = τ . The derivation Φt is obtained by an application of rule (ax). Observe that t = y would imply x ∈/ fv(t).
If t = λy.v then t{x/u} = λy.v{x/u} thus, by construction, τ = M → σ where Φ d y : M;Γ ▶ v{x/u}:σ.  By the i.h., y : M;Γ = ΔJ +i∈I Γi where Φv dx : [σi]i∈I ; ΔJ ▶ v:σ and (Φi d Γi ▶ u:σi)i∈I . By α-conversion one can suppose

w.l.o.g. that y ∈/ fv(u), then by Lemma 3.1 one has Δj = y : M; x : [σi]i∈I ;Δ and (x : [σi]i∈I ; Δ) +i∈I Γi = Γ. Then Φt dx : [σi]i∈I ;Δ ▶ λy.v:τ by rule (→i).
If t = pv then t{x/u} = p{x/u}v{x/u} and by construction Γ = Π +j∈J Πj and

Φp{x/u} d Π ▶ p{x/u}:[ρk]k∈K →τ and (Φj
d Πj ▶ v{x/u}:ρj)j∈J where either

K = ∅ and |J| =1 or K = J .
If x ∈ fv(p) and x ∈ fv(v) then, by the i.h. Π = Δp +i∈Ip Γi where Φp d x : [σi]i∈I ; Δp ▶ p:[ρk]k∈K →τ and (Φi dΓi ▶ u:σi)i∈I , and Πj = Δj+i∈I Γi where
p	u	p	j
Φv dx : [σi]i∈I ; Δj ▶ v:ρj and (Φi d Γi ▶ u:σi)i∈I , for each j ∈ J . Suppose w.l.o.g.
j	u	j
that Ip, (Ij)j∈J are pairwise disjoint and let I = Ip ∪j∈J Ij. Then, by rule (→e),
Φtdx : [σi]i∈I ; Δp +j∈J Δj ▶ pv:τ . We are done with this case for Δ := Δp+j∈J Δj since (x : [σi]i∈Ip ; Δp) +j∈J (x : [σi]i∈Ij ; Δj)= x : [σi]i∈I ; (Δp +j∈J Δj) and that Δp +j∈J Δj +i∈I Γi = Γ.
If either x ∈/ fv(v) or x ∈/ fv(p) then it is analogous to the case above.
If t = p[[v]] then t{x/u} = p{x/u}[[v{x/u} ] and by construction Γ = Π0 + Π1 such that Φp{x/u} d Π0 ▶ p{x/u}:τ and Φv{x/u} d Π1 ▶ v{x/u}:σ.
If x ∈ fv(p) and x ∈ fv(v) then by i.h. Π0 = Δp +i∈Ip Γi where Φp d

x : [σi]i∈I ; Δp ▶ p:τ and (Φi d Γi ▶ u:σi)i∈I  and Π1 = Δv +i∈I
Γi where Φv d

p	u	p	v
x : [σi]i∈I ; Δv ▶ v:σ and (Φi d Γi ▶ u:σi)i∈I . Suppose w.l.o.g. that Ip and Iv are
v	u	v
disjoint and let I = Ip ∪Iv. Then Φt dx : [σi]i∈I ; Δp + Δv ▶ p[[v]]:τ by the rule (m)
and we are done with Δ := Δp + Δv.
If x ∈/ fv(v) then v{x/u} = v and by the i.h. one has Π0 = Δp +i∈I Γi

such that Φp d x : [σi]i∈I ; Δp ▶ p:τ and (Φi
d Γi ▶ u:σi)i∈I . Then, by rule (m),

Φt dx : [σi]i∈I ; Δp + Π1 ▶ p[[v]]:τ and we are done with Δ := Δp + Π1.
If x ∈/ fv(p) then it is analogous to the one above.
2

Theorem 3.6 (Subject Expansion) Let Φj d Γ ▶ tj:τ. If t →K tj then Φ d Γ ▶ t:τ .

Proof. The proof is by induction on the reduction relation →K.
If t = (λx.v)u '→neb v{x/u} = tj, where x ∈ fv(v), then by Lemma 3.5 Γ = Δ +i∈I Γi where I /= ∅, Φv dx : [σi]i∈I ;Δ ▶ v:τ and (Φi d Γi ▶ u:σi)i∈I . Then

Φv dx : [σi]i∈I ;Δ ▶ v:τ
Δ ▶ λx.v:[σi]i∈I →τ	(Φi      d   Γi    ▶   u:σi)i∈I  		
→e
Γ ▶ (λx.v)u:τ
If t = (λx.v)u '→m v[[u]] = tj, where x ∈/ fv(v) then, by construction, Γ = Δ + Γ1 such that Φv d Δ ▶ v:τ and Φu d Γ1 ▶ u:σ. Note that, by Lemma 3.1, x ∈/ dom(Δ).

Then,
Φv d Δ ▶ v:τ
Δ ▶ λx.v:[ ] →τ	Φu d Γ1 ▶ u:σ
→e
Γ ▶ (λx.v)u:τ
All the inductive cases are straightforward.
2

The Strong Normalization Characterization
In this section we use K-typability to characterize β-strongly normalizing terms,
i.e. we show that a term is K-typable if and only if it is β-strongly normalizing. The proof does not use any reducibility/computability argument [31,17,25], but goes through the memory operator calculus K that we have introduced in Section 2. More precisely, we first show that K-terms are K-typable if and only if they are K-strongly normalizing. This proof is based on the properties presented in Section 3, namely, Weighted Subject Reduction and Subject Expansion. We then show that the sets of β and K strongly normalizing λ-terms are equivalent, a result which is obtained by means of appropriate inductive definitions for both sets.
It is well-known [36] that the set of β-strongly normalizing λ-terms, written
SN (β), can be characterized by the following alternative inductive definition:
If t1,..., tn (n ≥ 0) ∈ ISN (β), then xt1 ... tn ∈ ISN (β).
If t ∈ ISN (β), then λx.t ∈ ISN (β).
If t{x/u}t1 ... tn,u ∈ ISN (β), then (λx.t)ut1 ... tn ∈ ISN (β).
Remark that the base case of this inductive definition is given by the first item when n = 0. This is indeed a characterization, as expressed by the following Lemma:
Lemma 4.1 ([36]) SN (β)= ISN (β).
In the same spirit, the set of K-strongly normalizing K-terms, written SN (K), can be characterized by the following alternative definition:
(H) If t1,..., tn (n ≥ 0) ∈ ISN (K), then xt1 ... tn ∈ ISN (K).
(A) If t ∈ ISN (K), then λx.t ∈ ISN (K).
(I) If t{x/u}t1 ... tn ∈ ISN (K) and x ∈ fv(t), then (λx.t)ut1 ... tn ∈ ISN (K).
(G) If t[[u]]t1 ... tn ∈ ISN (K) and x ∈/ fv(t), then (λx.t)ut1 ... tn ∈ ISN (K).
(S) If (tt1 ... tn)[[u]] ∈ ISN (K) and n ≥ 1, then t[[u]]t1 ... tn ∈ ISN (K).
If t, u ∈ ISN (K), then t[[u]] ∈ ISN (K).
As before, the base case of this inductive definition is given by the first item when n = 0.
The set ISN (K) turns out to be equivalent to the set of K-strongly normalizing terms. In order to show that, we write ηK(t) to denote the maximal length of a

K-reduction sequence starting at t, when t is K-strongly normalizing.
Lemma 4.2 SN (K)= ISN (K).
Proof. If t ∈ SN (K), then we easily show that t ∈ ISN (K) by induction on the pair ⟨ηK(t), |t|⟩ using the corresponding lexicographic order.
The base case of the induction is when t = x (for which ⟨ηK(t), |t|⟩ = ⟨0, 1⟩). Then the rule (H) for n = 0 gives x ∈ ISN (K).
We reason by cases on the form of t for the inductive steps.
t = λx.u ∈ SN (K) implies u ∈ SN (K). Moreover, ⟨ηK(u), |u|⟩ <lex ⟨ηK(t), |t|⟩ so that the i.h. gives u ∈ ISN (K) and the rule (A) gives t ∈ ISN (K).
t = xu1 ... un ∈ SN (K) implies u1,..., un ∈ SN (K). Moreover, ⟨ηK(ui), |ui|⟩ <lex
⟨ηK(t), |t|⟩ so that the i.h. gives ui ∈ ISN (K) and the rule (H) gives t ∈ ISN (K).
t = (λx.u)vt1 ... tn ∈ SN (K) and x ∈ fv(u) implies tj = u{x/v}t1 ... tn ∈ SN (K). Moreover, ⟨ηK(tj), |tj|⟩ <lex ⟨ηK(t), |t|⟩ so that the i.h. gives tj ∈ ISN (K) and the rule (I) gives t ∈ ISN (K).
t = (λx.u)vt1 ... tn ∈ SN (K) and x ∈/ fv(u) implies tj = u[[v]]t1 ... tn ∈ SN (K). Moreover, ⟨ηK(tj), |tj|⟩ <lex ⟨ηK(t), |t|⟩ so that the i.h. gives tj ∈ ISN (K) and the rule (G) gives t ∈ ISN (K).
t = u[[v]] ∈ SN (K) implies u, v ∈ SN (K). Moreover, ⟨ηK(u), |u|⟩ <lex ⟨ηK(t), |t|⟩ and ⟨ηK(v), |v|⟩ <lex ⟨ηK(t), |t|⟩ so that the i.h. gives u, v ∈ ISN (K) and the rule (V ) gives t ∈ ISN (K).
t = u[[v]]t1 ... tn ∈ SN (K), where n ≥ 1. By definition we have ηK(u[[v]]t1 ... tn)= 
ηK((ut1 ... tn)[[v]]), so that ut1 ... tn,v ∈ SN (K).	Moreover ⟨ηK(v), |v|⟩ <lex
⟨ηK(t), |t|⟩ and ⟨ηK(ut1 ... tn), |ut1 ... tn|⟩ <lex ⟨ηK(t), |t|⟩ . By the i.h. we get ut1 ... tn,v ∈ ISN (K), and thus by rule (V) we get (ut1 ... tn)[[v]] ∈ ISN (K), and by rule (S) we obtain u[[v]]t1 ... tn ∈ ISN (K).
To show ISN (K) ⊆ SN (K) we reason by induction on the definition of ISN (K).
(H) If t = xt1 ... tn ∈ ISN (K), where t1,..., tn ∈ ISN (K), then the i.h. gives
t1,..., tn ∈ SN (K) so that the term xt1 ... tn is trivially in SN (K).
(A) If t = λx.v ∈ ISN (K), where v ∈ ISN (K), then the i.h. gives v ∈ SN (K) so that the term λx.v is trivially in SN (K).
(I) If t = (λx.v)ut1 ... tn ∈ ISN (K), where v{x/u}t1 ... tn ∈ ISN (K) and x ∈ fv(v), then the i.h. gives v{x/u}t1 ... tn ∈ SN (K) so that in particular v, u, ti ∈ SN (K). We show that t ∈ SN (K) by a second induction on ηK(v)+ ηK(u)+ Σi=1...nηK(ti).
Let us see how are all the reducts of t.
If t → (λx.vj)ut1 ... tn = tj, where v → vj or t → (λx.v)ujt1 ... tn = tj, where
u → uj, or t → (λx.v)ut1 ... tj ... tn = tj, where ti → tj, then tj ∈ SN (K) by the
i	i
second i.h..
If t → v{x/u}t1 ... tn = tj, then tj ∈ SN (K) as already remarked by the first
i.h.
Since all reducts of t are in SN (K), then t ∈ SN (K).
If t = (λx.v)ut1 ... tn ∈ ISN (K), where v[[u]]t1 ... tn ∈ ISN (K) and x ∈/ fv(v),

then the i.h. gives v[[u]]t1 ... tn ∈ SN (K), so that in particular v, u, ti ∈ SN (K). We show that t ∈ SN (K) by induction on ηK(v)+ ηK(u)+ Σi=1...nηK(ti).
As before, let us analyze the reducts of t.
If t → (λx.vj)ut1 ... tn = tj, where v → vj or t → (λx.v)ujt1 ... tn = tj, where
u → uj, or t → (λx.v)ut1 ... tj ... tn = tj, where ti → tj, then tj ∈ SN (K) by the
i	i
second i.h..
If t → v[[u]]t1 ... tn = tj, then we have remarked already that tj ∈ SN (K) by the first i.h.
Since all reducts of t are in SN (K), then t ∈ SN (K).
(S) If v[[u]]t1 ... tn ∈ ISN (K) where (vt1 ... tn)[[u]] ∈ ISN (K) and n ≥ 1, then the only possibility is vt1 ... tn,u ∈ ISN (K). We can then apply the i.h. to get vt1 ... tn,u ∈ SN (K), so that (vt1 ... tn)[[u]] ≡ v[[u]]t1 ... tn ∈ SN (K).
(V) If t = v[[u]] ∈ ISN (K), where v, u ∈ ISN (K), then the i.h. gives u, v ∈ SN (K) so that the term v[[u ] is trivially in SN (K).
2
Since SN (K) and ISN (K) are equivalent sets, we can now derive K-typability from K-strong normalization by using this equivalence.
Theorem 4.3 If t ∈ SN (K) then t is K-typable.
Proof. By induction on the structure of t ∈ ISN (K)= SN (K).
If t = xt1 ··· tn (n ≥ 0) where t1,..., tn ∈ ISN (K) then, by the i.h. ∀1≤i≤n, Γi ▶ ti:σi. Let τ = [σ1] → ··· [σn] →α, for α ∈ A, and Γ = x : [τ ]+ Γ1 + ··· + Γn. Then, x : [τ ] ▶ x:τ by the rule (ax) and, by n applications of the rule (→e), Γ ▶ xt1 ··· tn:α.
If t = λx.v where v ∈ ISN (K) then, by the i.h. Γ ▶ v:τ thus, by the rule (→i), Γ \ x ▶ λx.v:Γ(x) →τ .
(I) If t = (λx.v)ut1 ··· tn where x ∈ fv(v) and v{x/u}t1 ··· tn ∈ ISN (K) then, by the i.h. Γ ▶ v{x/u}t1 ··· tn:τ . Therefore, by Theorem 3.6, Γ ▶ (λx.v)ut1 ··· tn:τ .
(G) If t = (λx.v)ut1 ··· tn where x ∈/ fv(v) and v[[u]]t1 ··· tn ∈ ISN (K) then, by the
i.h. Γ ▶ v[[u]]t1 ··· tn:τ . Therefore, by Theorem 3.6, Γ ▶ (λx.v)ut1 ··· tn:τ .
(S) If t = v[[u]]t1 ··· tn where (vt1 ··· tn)[[u]] ∈ ISN (K), then by the i.h. we have Γ ▶ (vt1 ··· tn)[[u]]:τ and, by Lemma 3.2, Γ ▶ v[[u]]t1 ··· tn:τ .
If t = v[[u]] where v, u ∈ ISN (K) then, by the i.h. Γ0 ▶ v:τ and Γ1 ▶ u:σ thus, by the rule (m), Γ0 + Γ1 ▶ v[[u]]:τ .
2
The converse can be simply shown by using the Weighted Subject Reduction property. Notice that similar results for idempotent intersection type systems cannot be proved in a combinatorial way, they are typically based on reducibility arguments [31,17,25]. This is exactly the place where the quantitative approach by means of non-idempotent types makes the difference.
Theorem 4.4 If t is K-typable then t ∈ SN (K).

Proof. Let Φ d Γ ▶ t:τ and suppose that t ∈/ SN (K). Then, there exists an infinite reduction sequence t = t0 → t1 ∼ t2 → t3 ∼ t4 → · · · → t2n+1 ∼ t2n+2 → · · · . By Theorem 3.4 and Lemma 3.2 one has that ∀i ∈ N ∃Φi d Γ ▶ ti:τ such that sz(Φ2i) > sz(Φ2i+1) = sz(Φ2(i+1)). Contradiction, since sz(Φ) > 0, for any Φ. Therefore, t ∈ SN (K).	2
We have already remarked that the set of λ-terms is included in the set of K-terms. In order to conclude, we need to show that a λ-term t is β-strongly normalizable if and only if the K-term obtained by embedding t in the K-calculus is K-strongly normalizable.
Lemma 4.5 Let t be a λ-term. If t ∈ SN (K), then t ∈ SN (β).
Proof. By induction on ⟨ηK(t), |t|⟩. We only show the interesting case. Let t = (λx.v)ut1	tn. By hypothesis v, u, ti ∈ SN (K) so that by the i.h. we get v, u, ti ∈
SN (β). To prove that t ∈ SN (β) it is sufficient to show that every β-reduct of t is in SN (β). We proceed by induction on ηβ(v)+ ηβ(u)+ Σi=1	nηβ(ti).
If t →β tj reduces a subterm v, u, ti, then the property trivially holds. Otherwise, if t →β tj reduces the head redex, there are two cases to consider.
If x ∈ fv(v), then also t →K v{x/u}t1 ··· tn = tj, so that tj ∈ SN (β) by the first

i.h. If x ∈/
fv(v), then t →β vt1 ··· tn = tj. However, t →K v[[u]]t1 ··· tn = tj ≡

(vt1 ··· tn)[[u]]. We have ηK(vt1 ··· tn) ≤ ηK((vt1 ··· tn)[[u]]) < ηK(t) so that the first
i.h. gives vt1 ··· tn = tj ∈ SN (β) and thus we are done.	2
Lemma 4.6 Let t be a λ-term. If t ∈ SN (β), then t ∈ SN (K).
Proof. By Lemma 4.1 and Lemma 4.2 it is sufficient to show that t ∈ ISN (β) implies t ∈ ISN (K).
If t = xt1 ... tn ∈ ISN (β), where t1,..., tn ∈ ISN (β), then the i.h. gives
t1,.	, tn ∈ ISN (K) so that t ∈ ISN (K) by rule (H).
If t = λx.v ∈ ISN (β), where v ∈ ISN (β), then the i.h. gives v ∈ ISN (K) so that λx.v ∈ ISN (K) by rule (A).
If t = (λx.v)ut1 ... tn ∈ ISN (β), where v{x/u}t1 ... tn,u ∈ ISN (β), then we reason by cases.
Suppose x ∈ fv(v). The i.h. gives v{x/u}t1 ... tn ∈ ISN (K) so that t ∈ ISN (K) by rule (I).
Suppose x ∈/ fv(v). The i.h. gives vt1 ... tn,u ∈ ISN (K) so that (vt1	tn)[[u]] ∈
ISN (K) by rule (V), and thus t ∈ ISN (K) by rule (G).
2

The last two lemmas, and the fact the λ-terms are strictly included in K-terms, allow to conclude:
Corollary 4.7 Let t be a λ-term. Then t is K-typable if and only if t ∈ SN (β).

Conclusion
We have presented a characterization of β-strongly normalizing λ-terms via a typing system based on non-idempotent intersection types, through an embedding of the λ-calculus into the memory K-calculus.
As a matter of fact, the same result can be proved more directly by using tech- niques similar to those presented in [33,3]. This alternative proof goes as follows:
Prove that typable λ-terms are strongly normalizing, by induction on typing derivations, using the inductive characterization of strong normalization ISN (β), presented in Section 4, and the fact that weighted subject reduction holds for non-erasing β-reductions.
Prove that strongly normalizing λ-terms are typable, by induction on ISN (β), using the fact that subject expansion holds for non-erasing β-reductions.
It is possible to adapt this technique to the non-idempotent case. Still, the good point of the memory calculus is its awareness: nothing is lost along reductions, and therefore subject expansion does hold even for the type system characterizing strong normalization, whereas it does not hold for other calculi, in general. This allows for simple, modular proofs of strong normalization for calculi that can be embedded in a memory-like calculus. In this paper, we show the simplest case, namely the one of the pure λ-calculus, but extensions to other frameworks, inspired for instance by classical or linear calculi may naturally be conceived.

References
H. Barendregt. The Lambda Calculus: Its Syntax and Semantics (revised edition), volume 103 of Studies in Logic and the Foundations of Mathematics. Elsevier Science, Amsterdan, The Netherlands, 1984.
H. Barendregt, M. Coppo, and M. Dezani-Ciancaglini. A filter lambda model and the completeness of type assignment. Journal Symbolic Logic, 48(4):931–940, 1983.
H. Barendregt, W. Dekkers, and R. Statman. Lambda calculus with types. Perspectives in logic. Cambridge University Press, Cambridge, New York, 2013.
A. Bernadet and S. Lengrand. Complexity of strongly normalising λ-terms via non-idempotent intersection types. In the 14th International Conference on Foundations of Software Science and Computation Structures (FOSSACS), volume 6604 of LNCS, pages 88–107. Springer-Verlag, 2011.
A. Bernadet and S. Lengrand. Non-idempotent intersection types and strong normalisation. Logical Methods in Computer Science, 9(4):3, 2013.
G. Boudol, P.-L. Curien, and C. Lavatelli. A semantics for lambda calculi with resources. Mathematical Structures in Computer Science, 9(4):437–482, 1999.
A. Bucciarelli, T. Ehrhard, and G. Manzonetto. Not enough points is enough. In 21st International Workshop on Computer Science Logic (CSL), volume 4646 of LNCS, pages 298–312. Springer-Verlag, 2007.
A. Bucciarelli, D. Kesner, and S. Ronchi Della Rocca. The inhabitation problem for non-idempotent intersection types. In the 8th Int. Conference on Theoretical Computer Science (TCS), volume 8705 of LNCS, pages 341–354. Springer-Verlag, 2014.
A. Bucciarelli, D. Kesner, and D. Ventura. A combinatorial argument for termination. EBL 2014, XVII Brazilian Logic Conference, Petropolis.
M. Coppo and M. Dezani-Ciancaglini. An extension of the basic functionality theory for the λ-calculus.
Notre Dame, Journal of Formal Logic, 21:685–693, 1980.

M. Coppo, M. Dezani-Ciancaglini, and B. Venneri. Principal type schemes and λ-calculus semantics. To
H.B. Curry: Essays on Combinatory Logic, Lambda Calculus and Formalism, pages 536–560. Academic Press, 1980.
M. Coppo, M. Dezani-Ciancaglini, and B. Venneri. Functional characters of solvable terms. Zeitschrift fur mathematische Logik und Grundlagen der Mathematik, 27:45–58, 1981.
E. De Benedetti. Linear logic, type assignment systems and implicit computational complexity. PhD thesis, Universita’ degli Studi di Torino - ENS de Lyon, 2015.
E. De Benedetti and S. Ronchi Della Rocca. Bounding normalization time through intersection types. In the 6th Workshop on Intersection Types and Related Systems (ITRS), volume 121 of EPTCS, pages 48–57, 2013.
D. de Carvalho. S´emantiques de la logique lin´eaire et temps de calcul. These de doctorat, Universit´e Aix-Marseille II, 2007.
M. Florido and L. Damas. Linearization of the lambda-calculus and its relation with intersection type systems. Journal Functional Programming , 14(5):519–546, 2004.
J.-Y. Girard, Y. Lafont, and P. Taylor. Proofs and Types, volume 7 of Cambridge Tracts in Theoretical Computer Science. Cambridge University Press, 1989.
D. Kesner and D. Ventura. Quantitative types for intuitionistic calculi. Technical Report hal-00980868, Paris Cit´e Sorbonne, 2014.
D. Kesner and D. Ventura. Quantitative types for the linear substitution calculus. In IFIP Theoretical Computer Science (TCS), volume 8705 of LNCS, pages 296–310. Springer-Verlag, 2014.
D. Kesner and D. Ventura. A resource aware computational interpretation for herbelins syntax. In the 12th International Colloquium on Theoretical Aspects of Computing (ICTAC), volume 9399 of LNCS, pages 388–403. Springer-Verlag, 2015.
A. Kfoury. A linearization of the lambda-calculus and consequences. Technical report, Boston Universsity, 1996.
A. Kfoury and J. B. Wells. Principality and type inference for intersection types using expansion variables. Theoretical Computer Science, 311(1-3):1–70, 2004.
K. Kikuchi. Uniform proofs of normalisation and approximation for intersection types. In 7th Workshop on Intersection Types and Related Systems (ITRS), 2014.
J. W. Klop. Combinatory reduction systems. PhD thesis, Univ. Utrecht, 1980.
J.-L. Krivine. Lambda-calculus, types and models. Ellis Horwood, 1993.
D. Leivant. Polymorphic type inference. In the 10th ACM Symposium on Principles of Programming Languages (POPL), pages 88–98, 1983.
P. M. Neergard. Theoretical pearls: A bargain for intersection types: a simple strong normalization proof. Journal of Functional Programming, 15:669–677, 9 2005.
G. Pottinger. A type assignment for the strongly normalizable λ-terms. To H.B. Curry: Essays on Combinatory Logic, Lambda Calculus and Formalism, pages 561–578. Academic Press, 1980.
L. Regnier. Une ´equivalence sur les lambda-termes. Theoretical Computer Science , 2(126):281–292, 1994.
S. Ronchi Della Rocca.	Principal type scheme and unification for intersection type discipline.
Theoretical Computer Science, 59:1–29, 1988.
W. Tait. Intensional interpretations of functionals of finite type I. Journal Symbolic Logic, 32(2):198– 212, 1967.
P. Urzyczyn. The emptiness problem for intersection types. Journal of Symbolic Logic, 64(3):1195– 1215, 1999.
S. Valentini.	An elementary proof of strong normalization for intersection types.	Archive of Mathematical Logic, 40(7):475–488, 2001.
S. van Bakel. Complete restrictions of the intersection type discipline. Theoretical Computer Science, 102(1):135–163, 1992.
S. van Bakel. Strict intersection types for the lambda calculus. ACM Computing Surveys, page 20, 2011.
F. van Raamsdonk.	Confluence and Normalization for Higher-Order Rewriting.	PhD thesis, Amsterdam University, Netherlands, 1996.
J. B. Wells. The essence of principal typings. In the 29th International Colloquium on Automata, Languages and Programming (ICALP), volume 2380 of LNCS, pages 913–925. Springer-Verlag, 2002.
