Electronic Notes in Theoretical Computer Science 42 (2001)
URL: http://www.elsevier.nl/locate/entcs/volume42.html 15 pages


Embedding Display Calculi into Logical Frameworks: Comparing Twelf and Isabelle

Jeremy E. Dawson 1
Department of Computer Science, Faculty of Engineering and Information Technology, Australian National University

Rajeev Gor´e 2
Automated Reasoning Group, Computer Sciences Laboratory, Research School of Information Science and Engineering, Australian National University
and
Department of Computer Science, Faculty of Engineering and Information Technology, Australian National University


Abstract
Logical frameworks are computer systems which allow a user to formalise mathemat- ics using specially designed languages based upon mathematical logic and Church’s theory of types. They can be used to derive programs from logical specifications, thereby guaranteeing the correctness of the resulting programs. They can also be used to formalise rigorous proofs about logical systems. We compare several meth- ods of implementing the display (sequent) calculus δRA for relation algebra in the logical frameworks Isabelle and Twelf. We aim for an implementation enabling us to formalise, within the logical framework, proof-theoretic results such as the cut-elimination theorem for δRA and any associated increase in proof length. We discuss issues arising from this requirement.


Introduction and Motivation
Logical frameworks are computer systems which allow a user to formalise mathematics using specially designed languages based upon mathematical logic and Church’s theory of types. They can be used to derive programs from logical specifications, thereby guaranteeing the correctness of the result- ing programs. They can also be used to formalise rigorous proofs about logical systems.

1 Supported by an Australian Research Council Small Research Grant.
2 Supported by an Australian Research Council Queen Elizabeth II Fellowship.
◯c 2001 Published by Elsevier Science B. V. Open access under CC BY-NC-ND license.


Relation algebras [12] are extensions of Boolean algebras; whereas Boolean algebras model subsets of a given set, relation algebras model binary relations on a given set. Relation algebras have operations such as relational compo- sition and relational converse, and Boolean operations such as intersection (conjunction) and complement (negation). Relation algebras form the basis of relational databases [6] and of the specification and proof of correctness of programs, particularly in the style of Mili [15].
Display Logic [1] is a generalised sequent framework for non-classical logics, based on the Gentzen sequent calculus [7]. Its advantages include a generic cut-elimination theorem, which applies whenever the rules for the display cal- culus satisfy certain, easily checked, conditions. It is an extremely general logical formalism, applicable to many (classical and non-classical) logics in a uniform way [10], [22]. The generality of the display framework means that es- sentially the same meta-level proofs work for many different logics. A rigorous mechanical formalisation of such proofs is then widely applicable and worth pursuing. In this paper we discuss the implementation of δRA, a display calculus for relation algebras, as a case study for exploring various methods for such a mechanical formalisation of display calculi in general.
Display calculi extend Gentzen’s language of sequents with extra, complex, n-ary structural connectives, in addition to Gentzen’s sole structural connec- tive, the “comma”. Whereas Gentzen assumed the comma to be associative, commutative and inherently poly-valent, display calculi make no such implicit assumptions. Properties such as these are explicitly stated as structural rules. For example, δRA-sequents are built using a binary comma, a binary semi- colon, and unary ∗ and • structural connectives. Thus, whereas Gentzen’s sequents Γ ▶ ∆ assume that Γ and ∆ are comma-separated lists of formulae, δRA-sequents X ▶ Y assume that X and Y are complex tree-like structures built from formulae together with comma, semicolon, ∗ and •.
The defining feature of display calculi is that in all logical introduction rules, the principal formula is always “displayed” as the whole of the right- hand or left-hand side. For example, the rule (LK- ▶ ∨), shown below left, is typical of Gentzen’s sequent calculi like LK, while the rule (δRA- ▶ ∨) shown on the right is typical of display calculi:


Γ ▶ ∆, P,Q 


Γ ▶ ∆,P ∨ Q
(LK- ▶ ∨)
X ▶ P, Q


X ▶ P ∨ Q
(δRA- ▶ ∨)

Intuitively, to use this display calculus rule downwards on a sequent X' ▶ Y ', everything other than (P, Q) must be moved into the complex structure X on the left of ▶, thereby displaying the structure (P, Q) as the whole of the right- hand side. There are rules which enable any given structure to be displayed. After the rule application we can “undisplay” the moved material back to its original position (reversing the display steps used), so that the sole purpose of this rule is to “rewrite” some (P, Q) to P ∨ Q somewhere inside Y '. See [9] for a full account.


Isabelle is an automated proof assistant [17]. Its meta-logic is an intuition- istic typed higher-order logic, sufficient to support the built-in inference steps of higher-order unification and term rewriting. Isabelle accepts inference rules of the form “from α1, α2,..., αn, infer β” where the αi and β are expressions of the Isabelle meta-logic, or are expressions using a new syntax, defined by the user, for some “object logic”. An Isabelle user can encode a particular calculus CL for some logic L as an “object logic” by using these rule templates to encode the set of inference rules of CL. For example, if CL is a natural deduction calculus, then the αi and β will be formulae of L, whereas if CL is a sequent calculus, then the αi and β will be sequents of CL. Such an encoding is called an “object logic”, even though it is a (typically natural deduction or sequent) calculus for some particular logic L. In practice most users would build on one of the comprehensive “object logics” already supplied [18].
Twelf [20] is an implementation of the Edinburgh Logical Framework (LF) [11], which is based on a typed λ-calculus with dependent types. Logics are represented using a judgements as types principle, where each judgement of the form Γ,x : Q ▶ y : P is identified with the types of its proofs. Twelf also accepts inference rules of the form “from α1, α2,..., αn, infer β”. But now, the rule is expressed as the declaration of a λ-calculus term of type α1 → α2 → ... → αn → β. Once again, if the calculus we are trying to capture is a natural deduction calculus, then the αi and β will be formulae (types), but if the calculus is a sequent calculus, then the αi and β will be sequents (types).
In an earlier paper [4], we described the Isabelle implementation of δRA, a display calculus for relation algebra [9], as an object logic of Isabelle. In that paper we described how we had used the implementation to prove results comparing alternative formalisations of relation algebra from a proof-theoretic perspective. However we had not proved those results themselves in Isabelle, in the sense we now explain.
Suppose logic L is a set of formulae which we regard as valid with respect to some semantics, and P and Q are two calculi for L (each consisting of axioms and inference rules). Suppose also that we have mechanical implementations of P and Q. Then one can use the implementation of P to derive in P every axiom and rule of Q. One could then go outside the mechanical system and argue (by induction on the size, or structure, of a Q-derivation) that therefore every Q-derivable object (typically a formula or sequent) is also P-derivable.
In [4] we used the Isabelle δRA implementation to show the soundness of certain other calculi for relation algebra. These results were proved in the manner described in the previous paragraph. An alternative and, when one’s aim is the mechanical proof of proof-theoretic results, better approach would enable the inductive argument above to be carried out in the mechanical theorem-prover. This would require a different style of implementation of the calculi P and Q in the prover, so as to enable reasoning about the shape and form of P-derivations and Q-derivations. Typically this would require


modelling, in the theorem prover, the “tree” of steps used in a derivation and the fact that each step is an instance of a rule of the calculus P or Q; this in turn requires modelling the form of the statement of an inference rule of P or Q, and a method of obtaining particular substitutional instances of such rules of inference.
The terms “shallow embedding” and “deep embedding” are often used to distinguish these styles of implementation [2]. Thus our work in [4] (see Section 2) is an example of a shallow embedding, while the work reported in Section 4 is a deep embedding. Mikhajlova and von Wright [14] used a deep embedding in their comparison of classical first-order logic proof systems. This is the only other example of a deep embedding of a logical calculus of which we know. Other metamathematical results have also been mechanised – see, eg, [21].
In this paper we compare methods of embedding δRA in various logical frameworks. We explored the possibility of implementing a “deep embed- ding” in Twelf, Isabelle/CTT and Isabelle/HOL. In the subsequent sections we describe the original Isabelle/Pure implementation and this further work.

The Isabelle/Pure implementation
Isabelle is an interactive computer-based proof system, described in [17]. Its capabilities include higher-order unification and term rewriting. It is writ- ten in Standard ML [16]; the user can interact with it by entering further ML commands, and can program complex proof sequences in ML. As stated previously, the basic Isabelle constructs available to a user include inference rule templates of the form “from α1, α2,..., αn, infer β”. These can be used “forwards”, to obtain β from the αi, or “backwards”, to reduce a given goal β to subgoals α1, α2,..., αn. Isabelle provides a number of basic operations for backwards proof and proof-search (tactics), as well as tacticals for combining these. Isabelle also supports forward proof.
The inference rules collectively form a simple meta-logic: an intuitionistic typed higher-order logic. There are three logical operators: ==> (implication, or deducibility), == (equality, or substitutability), and !! (universal quantifi- cation). For example, [| A1; A2 |] ==> B, is the Isabelle representation for “from α1, α2, infer β”. These operators satisfy certain properties arising from their intended meanings. For example, since [| A1; A2 |] ==> B means that β can be deduced from α1 and α2, it is then possible to deduce β from α2 and α1, i.e., [| A2; A1 |] ==> B. Likewise, since A == B means that A can be replaced by B, or vice versa, == is reflexive, symmetric and transitive.
This meta-logic is known as Isabelle’s Pure theory. In most cases the user would augment this by defining additional constants to capture the syntax of the object logic. For example, to capture set theory, we would add a constant mem (say) to stand for the ∈ symbol, while sequents would require constants ‘|-’ and ‘,’. Several such object logics are packaged with the Isabelle


distribution [18]. Once these syntactic elements of the object logic are in place, we can build object-logic expressions into the αi and β. For example, in δRA, the (δRA- ▶ ∨) rule from Section 1 uses the meta-logical operator
==> discussed above, and could be entered as
"$X |- P, Q ==> $X |- P v Q".
where the $ distinguishes δRA-structures such as X from δRA-formulae such as P. This rule is an instance of the form “from α infer β”.
In [4] δRA was implemented in Isabelle directly on top of the Pure theory, so that the only inference rules available are those of δRA. As far as the Isabelle meta-logic is concerned, we can think of its atomic formulae as the formulae (for δRA, the sequents) of the object-logic. In this case these are δRA-sequents of the form X ▶ Y , built using object-logic “connectives” ‘▶’, ‘,’, ‘;’, ‘*’, ‘•’, ‘∧’, ‘∨’, etc. These can be combined into more complex Isabelle propositions using the Isabelle meta-logic connectives ==>, == and !!. It follows that expressions such as $X |- (P ==> Q) or A v (B ==> C) are not possible. Note that the αi and β as discussed above would most commonly simply be δRA-sequents, but could be “complex” Isabelle propositions, such as $X |- P ==> $Y |- Q.
We may declare axioms and inference rules of the δRA calculus to Isabelle. For example, the sequent p ▶ p is an initial sequent (axiom) in δRA; thus it is declared in Isabelle as a rule, P |- P, with no premises. Similarly, each rule of δRA is declared as an Isabelle rule, as in the example of the (▶ ∨)
rule above. That this is a shallow embedding is reflected in the fact that the horizontal bar of sequent rules becomes the Isabelle ==> operator. In a deep embedding, as in Section 4, the horizontal bar also becomes an object-level constant.
In this shallow embedding, access to and manipulation of the shape of δRA constructs (ie, sequents, structures, formulae) and derivations was provided only at the ML level. For example, in [4] we described having programmed a procedure to perform cut-elimination for δRA. The input to this was a δRA derivation (represented as a tree of sequent rule instances), and the output was a derivation not containing an instance of the cut rule. This required examining the shape of a derivation (represented as a tree of δRA rule instances) and of the Isabelle terms representing sequents. While the shape of an Isabelle term is easily accessible (by ML code), we had to change the Isabelle code somewhat, so as to record the elementary δRA rules used in a derivation, and to construct a derivation-tree which could be manipulated.
The aim of the work described in this paper is to perform the cut- elimination proof entirely within a theorem prover (rather than writing a cut-elimination program in ML). We therefore needed to model derivation trees, inference rules, substitution in them, and so on, within the language of the theorem prover, as discussed in §1.

Dependent Type Theory implementations
Introduction
In a dependent type theory, a type may be parametrised not only over a type variable, but also over a term variable. This, coupled with the judgements as types principle (where a judgement is identified with the types of its proofs) enables us to express the derivation of a display calculus derived rule.
A simpler example of a Curry-Howard isomorphism is between the simply- typed λ-calculus and a natural deduction calculus NDInt for intuitionistic propositional logic. Let A and B be formulae, and π be a derivation of A in NDInt. Suppose also that A → B is derivable in NDInt, and consider an NDInt-derivation of A → B where one assumes A and derives B. That is, it is a derivation of B in which A is regarded as true; at the points where A is used, it would contain some notation ξ meaning “true by assumption”. Let ρ(ξ) be this derivation of B. So if we substitute π (the derivation of A) for ξ in ρ(ξ), we get a derivation ρ(π) of B which does not rely on A as an assumption.
Then, using π : A to mean “π is a derivation of A”, we can write the rule
π : A	ρ(ξ) : A → B

ρ(π) : B
Erasing the annotations π, ρ and ‘:’ gives the well-known (→ E) natural deduction rule for intuitionistic logic; the rule as it stands also shows how to derive B. As indicated above, we can equally think of ρ(.) as a derivation of A → B or as a function which takes, as argument, a derivation of A such as π, and returns a derivation of B. If we also think of A as the type “derivations of proposition A” (and similarly for B) we get the functional type-theory interpretation, under which A → B means the type of functions which take an argument of type A and return a result of type B. (Conveniently, the same symbol ‘→’ is conventionally used for both purposes.)
Dependent types extend what can be done in the simply-typed λ-calculus in two distinct ways. Firstly, consider a type I of individuals, and a parametrised type A(i); that is, for each individual i ∈ I, there is a type
A(i). Then the dependent type A corresponds to a predicate A on I, and the type A(i) to the proposition A(i).
Secondly, we install an object logic at the level of terms, so that the expressions (formulae or sequents) of the object logic become terms of the dependently-typed λ-calculus. That is, we can install a syntax for terms using the syntax of the chosen object logic, and declare a type constructor P (.), so that for each term t, P (t) will mean “derivation of expression t”. This was our approach for modelling δRA.
Regarding an expression (formula or sequent) t as derivable when we have a term of type P (t) has certain consequences. For example, since from functions of type X → Z, U → V → W and S → S → T we can construct functions


of type X → Y → Z, V → U → W and S → T , we unavoidably have weakening, exchange and contraction. Note, however, that in our formulation of δRA, these are in the meta-logic level, not in the object logic.
Two theories based on dependent types are the Edinburgh Logical Frame- work (LF) [11] and Constructive Type Theory (CTT) [13].


The Twelf implementation
Twelf [20] is an implementation of the Edinburgh Logical Framework (LF) [11]. This is based on a typed λ-calculus with dependent types. Twelf is written in Standard ML, and the user can interact with the system using its “ML Interface”, but only a limited range of functions is available. Figure 1 is an extract of our Twelf source file.

struct : type.
|- : struct -> struct -> type.
* : struct -> struct.
% Display postulates
sA : (* X |- Y) -> (* Y |- X).
sS : (X |- * Y) -> (Y |- * X).
% Derived structural rules
ssASl = [D] sA (sS D).
Fig. 1. Sample Twelf source code

Line 1 declares struct as a new type to represent the δRA structures. Line 2 declares |- as a binary type constructor, taking two term arguments of type struct and returning a type. Following the description above, we should declare sequent as a new type to represent δRA sequents, and P as a function taking a term argument of type sequent and returning a type, thus:
sequent : type.
|- : struct -> struct -> sequent. P : sequent -> type.
The actual code in Figure 1 abbreviates this by removing the type con- structor P and (in effect) changing |- from a term constructor to a type constructor. Thus, for structures X and Y, the construct X |- Y represents derivations of the sequent X ▶ Y . (We did this only to simplify the printed output). Line 3 declares * as a unary structure operator. Lines 4 and 7 are comments.
In lines 5 and 6 the terms sA and sS are declared with the types that represent derivations of the δRA rules (see [9]) shown below:



∗X ▶ Y


∗Y ▶ X
X ▶ ∗Y
(sA)
Y ▶ ∗X
(sS)

We can think of these declarations as assertions that there are derivations (which we name sA and sS) of these rules, or as defining these as “primitive” rules (one-step derivations).
Now, treating sA and sS (which stand for “star in the antecedent” and “star in the succedent”) as functions each taking a derivation of a sequent to a derivation of another sequent, they can be composed for some given sequent U ▶∗ ∗ V as follows

derivation of
U ▶∗ ∗ V	−→
derivation of
∗V ▶ ∗U	−→
derivation of
∗∗ U ▶ V

The definition of ssSAl on line 8 does this; the notation means λD.sA(sS D). Twelf computes the type of ssSAl, giving (S1 ▶ ∗ ∗ S2) → (∗∗ S1 ▶ S2). Note that X, Y, S1 and S2 are variables (S1 and S2 being names chosen by Twelf).
In a manner akin to Prolog [5], Twelf allows one to make a query such as
ssASl : (X1 |- * * Y1) -> (* * X1 |- Y1).
which searches for a term of the specified type (i.e., searches for a derivation of the stated rule) and instantiates ssASl with that term. In this example, because Twelf allows substituting for X1 and Y1 in the query as well as for the variables X and Y in the declarations of sA and sS, the search proceeds along an infinite branch in the wrong direction.
On the other hand, the code
%theorem
ssASl_th : exists {DerivedRule:{S1:struct} {S2:struct} (S1 |- * * S2) -> (* * S1 |- S2)} true.
%prove 2 {} (ssASl_th DerivedRule).
successfully uses Twelf’s theorem prover to find the derivation, returning
/ssASl_th/: ssASl_th ([S1:struct] [S2:struct]
[D:S1 |- * * S2] sA (sS D)).
(Here the variables S1 and S2 need to be explicitly abstracted over – in the earlier code they were free variables).
Twelf’s theorem prover is not extensively documented, and is stated to be under active development, with the proof search component expected to undergo major changes. The proof search strategy can be controlled by the user to only a limited extent, whereas we have found that considerable user control (using tactics differing from proof to proof) is generally necessary in our work.
We found that certain aspects of Isabelle which we very much appreciated are absent from Twelf.  Isabelle offers a substantial number of user “com-


mands”, in the form of documented ML functions, which enable the user to programme proof procedures, or to examine the shape of a term or type ex- pression. For example, one might write a tactic which explicitly examines the current proof state and then decides which of several tactics to apply. There are many expressive “glue” functions for combining tactics in Isabelle. Inad- equacies in the documentation, or in the selection of functions documented, can often be circumvented by looking at the source code, which can also be a great help to the user in programming his/her own tactics.
At this stage, Twelf does not appear to offer comparable capabilities to the user. Thus, although the theorem prover did successfully find the derivation above, we felt uncertain that we could use it to find all required derivations, primarily because of the lack of user control over a proof.

The Cut-Elimination Theorem in Twelf
At this point we should refer to the proof of a cut-elimination theorem, using Twelf, described in [19]. This uses a rather ingenious representation of se- quents; a cut-free proof of a traditional Gentzen sequent A ▶ B is represented as the type neg A -> pos B -> @, and a cut-free proof of it as neg A -> pos B -> #, as explained in [19]. The two rules shown below left are both represented as the type shown on the right:


Γ,A ▶ ∆ Γ, A&B ▶ ∆
A ▶

A&B ▶
(neg A -> #) -> (neg (A and B) -> #)

In fact, the second rule shown would be directly represented by the type shown,
but the first rule shown could be directly represented by
(neg Γ -> pos ∆ -> neg A -> #) ->
(neg Γ -> pos ∆ -> neg (A and B) -> #)
However the existence of a term (function) of the type shown first trivially implies the existence of a term (function) of the type shown second. Further constructed types represent stages of the transformation of a proof into a cut- free proof, and a termination checker checks that the function performing the entire transformation from a proof to a cut-free proof terminates. However, this termination checker only checks that the function would not run forever. It does not check that it terminates with a cut-free derivation – it does not complain if the code is run with some cases deleted.
This work on the cut-elimination theorem is based on an ingenious way of representing the problem in a way that fits into Twelf; even so, getting a proof of the cut-elimination theorem from it relies on the heuristically-based termination checker and upon a manual check that all possible cases for the rules used just above the “cut” have been covered. On the other hand, the Twelf type-checker proves that each individual step is correct, in that the changed derivation in fact does derive the sequent which it purports to derive.


Thus this proof of cut-elimination lies between our previous work (where we just programmed a cut-elimination function in ML) and a fully formal proof.

The Isabelle/CTT implementation
We then turned to the CTT theory of Isabelle, since it is based on a logic which is very similar to that of Twelf, in that it includes dependent types. We implemented δRA similarly to its implementation in Twelf, so that we had, for example, (omitting premises of the form ?X : str)

"sA : * ?X |- ?Y --> * ?Y |- ?X" : thm
"sA oo sS : ?X |- * * ?Y --> * * ?X |- ?Y" : thm
where oo denotes function composition. Tactics were written to determine the type of a term (ie, to determine the derived rule obtained by a given combi- nation of rules), by solving a goal such as sA oo sS : ?t (which contains the type variable ?t). We explored tactics to search for a term of a given type (ie, a proof of a given term), by solving a goal such as the one below, which contains the term variable ?P.
"?P : ( X |- * * Y) --> ( * * X |- Y)".
The CTT theory of Isabelle is not as extensively developed as some other theories are; we found it necessary to prove some general but elementary theorems.

Conclusions
We experimented with Twelf because it had appeared that we would get our hands on the proofs “for free”, in that in the course of deriving a sequent or sequent rule, we produce a term which embodies the derivation performed. Given our intention to do a fully mechanised proof of the cut-elimination theorem (in which we manipulate derivations extensively) it had seemed that this feature of Twelf would be useful. Our work with Isabelle/CTT seemed to indicate that the same things could be done in it as in Twelf (with some effort to produce appropriate derived rules and tactics).
However we realised that although we could produce a term which repre- sented the derivation and showed the elementary steps from which it is com- posed, we could not analyse derivations, in the logic of the theorem prover, in the required ways: for example, to ask which rule was used in the final step of the derivation. In the light of this, there seemed to be no benefit in pursuing an implementation using dependent type theory.
We have referred to a proof in Twelf of the cut-elimination theorem, noting that it was based on an ingenious way of representing the problem in a way that fits into Twelf, and that it was not a fully formal proof. Since we are aiming for a formal proof, using techniques which would apply equally for


other proof-theoretic results, we felt that this cut-elimination proof does not indicate that dependent type theory would be powerful enough for our needs.

The Isabelle/HOL implementation
HOL is an Isabelle theory based on the higher-order logic of Church [3] and the HOL system of Gordon [8]. Thus it includes quantification and abstraction over higher-order functions and predicates. The HOL theory uses Isabelle’s own type system and function application and abstraction (that is, object- level types and functions are identified with meta-level types and functions). Isabelle/HOL contains constructs found in functional programming languages (such as datatype and let) which greatly facilitates re-implementing a pro- gram in Isabelle/HOL, and then reasoning about it. However limitations (not found in, say, Standard ML itself) prevent defining types which are empty or which are not sets, or functions which may not terminate.
Isabelle/HOL turned out to be entirely suitable for the deep embedding of δRA. The most significant factor leading us to this conclusion is the facility for datatype type declarations and associated primitive recursive function defini- tions, which was enormously helpful. For example, we model δRA structure expressions (see [9]) as follows
datatype structr = Comma structr structr
| SemiC structr structr
| Star structr
| Blob structr
| I
| E
| Structform formula
| SV string
The first six lines correspond to the structure operators of δRA and the next line is for “casting” a formula of δRA as a structure of δRA. The last line had no analogue in the shallow embedding, where we just used an Isabelle variable such as ?S to refer to any δRA-structure. In the deep embedding, SV ‘‘X‘‘ refers to the structure variable named X appearing in (say) the statement of a rule. Thus we can now write SV ?V, which Isabelle will match with a structure expression consisting of a single structure variable, or ?S to match any structure. We also defined functions (in Isabelle/HOL) which (for example) find all the variables in a structure expression, or substitute a given structure for such a variable. We also wrote such functions for the work described in §2, but in Standard ML, not in Isabelle.
For describing the structure of a derivation we have
datatype pftree = Pr sequent rule (pftree list)
| Unf sequent
where Pr seq rule pts is a derivation of the sequent seq, the last step of the


derivation uses the δRA rule rule, and the premises of that last step are the conclusions of the derivations in the list pts.  Unf (“unfinished”) means that a leaf is a sequent which is not an axiom, so is an assumption (or a “premise”) of the derivation tree as a whole.
We give examples of results which show how we can reason about provabil- ity in this embedding. Here IsProvableR rules prems concl means that sequent concl can be derived from sequents prems using rules rules, and IsProvable rules rule means that the conclusion of the statement of rule may be derived from its premises using rules.
val IsProvableR_trans =
"[| IsProvableR rules prems’ concl ;
ALL p:prems’. IsProvableR rules prems p |] ==> IsProvableR rules prems concl"
val IsProvableR_deriv =
"[| ALL rule:rules’. IsProvable rules rule ; IsProvableR rules’ prems concl |] ==>
IsProvableR rules prems concl"
While we think that the corresponding results, for particular instances of the sequents and derivations involved, could be proved more easily in Twelf than in Isabelle, we cannot see how to express the general results in Twelf or Isabelle/CTT, without, in effect, doing a deep embedding in those systems, as mentioned in the next section.

Further work and Related Work
A proof of the cut-elimination theorem for δRA has been completed, and will be reported in another paper. Using the deep embedding into Isabelle/HOL, we were able to specify and reason about derivability and derivation trees. Clearly the Isabelle/HOL logic is well-equipped for writing specifications which describe the process of performing proofs by substituting for variables in the rules of a given logical calculus. We attribute this to the richness of the logic, containing not only sum and product types, but recursive datatypes (as in the programming languages ML and Haskell), and to the fact that Isabelle/HOL provides the theorems which characterise each such type. It was thus a suitable choice for this project.
As one of the referees has pointed out, our final embedding of δRA into Isabelle/HOL is very deep, making use of recursive datatypes and other fea- tures of Isabelle/HOL. The need for such a deep embedding was discovered in the process of trying out the various shallow embeddings and finding them unsuitable for our proof-theoretical needs. An interesting question is whether an equally deep embedding of δRA would be feasible in Isabelle/Pure, Is- abelle/CTT and Twelf.  Our personal view is that this would be possible,


but that such an embedding would be extremely complicated and difficult because we would have to virtually reimplement essential features such as re- cursive datatypes which are not available in Isabelle/Pure, Isabelle/CTT or Twelf.
We aimed to produce a “deep” embedding of display calculi, sufficient (for example) to enable a mechanised proof of the cut-elimination theorem. While we have done this (in a sense), our work has elucidated some further points.
Belnap’s cut-elimination theorem for display calculi is generic. It applies to all display calculi whose rules satisfy certain conditions. We have modelled a particular display calculus, δRA (for relation algebra). Accordingly, we have proved the cut-elimination theorem for δRA. While we can identify the properties of the δRA rules used in the proof, and match these with Belnap’s conditions, we have not proved the theorem as stated by Belnap (which applies to any display calculus). To model an arbitrary display calculus in Isabelle/HOL would be a further (and harder) activity.



Conclusion
We have reviewed earlier work which described a shallow embedding of the δRA calculus into the Isabelle/Pure logic, and noted its drawbacks for prov- ing proof-theoretic results in Isabelle itself. Attracted by the notion that the tools based on dependent type theory would give expressiveness about proofs “for free”, we then looked at the Twelf tool. While the Twelf tool is still under active development, we noted how a similar logic is available in Is- abelle/CTT, which offers the advantages of Isabelle, such as access to a wide range of documented ML functions for programming proof tactics. However we also found that, while Twelf and Isabelle/CTT facilitate identifying the derivation of a sequent or derived rule, they do not facilitate reasoning about the shape of that derivation, or of the sequents found in it. Thus we turned to Isabelle/HOL, which appears to offer the best facility for deeply embedding a calculus such as δRA, and reasoning about derivability, derivation trees and the associated proof-theoretic concepts we needed. Needless to say, this was the advice we received from Larry Paulson from the start.



Acknowledgement
We are grateful to Paul Jackson, Randy Pollack and Mark Staples for many useful discussions on the notions of “shallow” and “deep” embeddings, to Frank Pfenning and Larry Paulson for answering our questions about Twelf and Isabelle, and to Jim Grundy for helpful comments.

References
N D Belnap. Display logic. Journal of Philosophical Logic, 11:375–417, 1982.
R J Boulton, A D Gordon, M J C Gordon, J R Harrison, J Herbert, and J van Tassel. Experience with embedding hardware description languages in HOL. Proc. Intl. Conf. on Theorem Provers in Circuit Design: Theory, Practice and Experience, IFIP Trans. volume A-10:129–156. North-Holland/Elsevier, 1992.
A Church. A formulation of the simple theory of types. Journal of Symbolic Logic, 5:56–68, 1940.
J Dawson and R Gor´e. A mechanised proof system for relation algebra using display logic. In JELIA98: Logic in Artificial Intelligence, LNAI 1489:264–278. Springer, 1998.
P Deransart, A Ed-Dbali, and L Cervoni. Prolog: The Standard. Springer- Verlag, 1996.
R A Elmasri and S B Navathe. Fundamentals of Database Systems. Benjamin/Cummings, Redwood City, 2 edition, 1994.
J. H. Gallier. Logic for Computer Science: Foundations of Automatic Theorem Proving. John Wiley and Sons, 1987.
M J C Gordon and T F Melham. Introduction to HOL: a Theorem Proving Environment for Higher Order Logic. Cambridge University Press, 1993.
R Gor´e. Cut-free display calculi for relation algebras. In CSL96: Computer Science Logic, LNCS 1258:198–210, Springer, 1997.
R Gor´e. Substructural logics on display. Logic Journal of the Interest Group in Pure and Applied Logic, 6(3):451–504, 1998.
R Harper, F Honsell, and G Plotkin. A framework for defining logics. Journal of the ACM, 40:143–184, 1993.
R D Maddux. Introductory course on relation algebras, finite-dimensional cylindric algebras, and their interconnections. In Algebraic Logic, Colloquia Mathematica Societatis Janos Bolyai, Volume 54:361–392. North-Holland, 1991.
P Martin-L¨of. Intuitionistic Type Theory. Bibliopolis, 1984.
A Mikhajlova and J von Wright. Proving isomorphism of first-order proof systems in HOL. In Theorem Proving in Higher-Order Logics, LNCS 1479:295–
314. Springer, 1998.
A Mili. A relational approach to the design of deterministic programs. Acta Informatica, 20:315–328, 1983.
R Milner, M Tofte, R Harper, and D MacQueen. The Definition of Standard ML (Revised). The MIT Press, 1997.


L C Paulson. The Isabelle Reference Manual. Computer Laboratory, University of Cambridge, 1999.
L C Paulson. Isabelle’s Logics. Computer Lab. Univ. of Cambridge, 1999.
F Pfenning. Structural cut elimination. In Proc. Tenth Annual Symposium on Logic in Comp. Sci. , pages 156–166. IEEE Computer Society Press, 1995.
F Pfenning and C Schu¨rmann. System description: Twelf - a meta-logical framework for deductive systems. In CADE-16 Proc. 16th Intl. Conf. on Automated Deduction , LNAI 1632:202–206. Springer, 1999.
Natarajan Shankar. Metamathematics, Machines, and Goedel’s Proof. Cambridge University Press, 1994.
Heinrich Wansing. Displaying Modal Logic, volume 3 of Trends in Logic. Kluwer Academic Publishers, Dordrecht, August 1998.
