

Electronic Notes in Theoretical Computer Science 250 (2009) 71–86
www.elsevier.com/locate/entcs

Refinement Sensitive Formal Semantics of State Machines With Persistent Choice 1
Harald Fecher2 and Michael Huth3
Imperial College London, United Kingdom
Heiko Schmidt4 and Jens Sch¨onborn5
Christian-Albrechts-Universita¨t zu Kiel, Germany

Abstract
Modeling languages usually support two kinds of nondeterminism, an external one for interactions of a system with its environment, and one that stems from under-specification as familiar in models of behavioral requirements. Both forms of nondeterminism are resolvable by composing a system with an environment model and by refining under-specified behavior (respectively). Modeling languages usually don’t support nondeterminism that is persistent in that neither the composition with an environment nor refinements of under-specification will resolve it. Persistent nondeterminism is used, e.g., for modeling faulty systems. We present a formal semantics for UML state machines enriched with an operator “persistent choice” that models persistent nondeterminism. This semantics is based on abstract models – μ-automata with a novel refinement relation – and a sound three-valued satisfaction relation for properties expressed in the μ-calculus.
Keywords: modeling language, nondeterminism, μ-calculus, 3-valued satisfaction, formal semantics


Introduction
Nondeterminism is a central concept in modeling and analysis of systems. For example, the abstraction of a program’s control and data introduces nondeterminism that analyzers have to control. In program analysis and software verification, such control is achieved by a judicious over- or under-approximation of the deterministic program, which yields sound but potentially imprecise results.

1 This work is in part financially supported by the DFG projects FE 942/1-1, FE 942/2-1, and by the UK EPSRC project Complete and Efficient Checks for Branching-Time Abstractions EP/E028985/1.
2 Email: hfecher@doc.ic.ac.uk
3 Email: mrh@doc.ic.ac.uk
4 Email: hsc@informatik.uni-kiel.de
5 Email: jes@informatik.uni-kiel.de

1571-0661 © 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.08.006



¸¸¸ref [x>0] x:=pscho {0,1}

inc
ref

x:=0¸¸¸	c
  ,r¸~0,~ , ¸¸¸,¸ 
,, r,z~¸1~ , ¸z

ref [x>0] x:=0
inc [x<3] x:=x+1
¸¸¸¸¸ref ,,,,	,,

¸	 ref
,¸,¸,
inc
ref



inc [x=3] send(full)
r,~¸~ ,  full z,r¸~~ , ,,,,ref
inc
ref¸¸¸¸r,~¸(~ , z

Fig. 1. Left: state machine with initial value x = 0. Transitions are labeled with triples of synchronization event, guard, and execution description; e.g. on event inc variable x is incremented by 1 if x < 3, and an
output event full is sent if x = 3. Right: Transition system as semantics of state machine on the left. The presence of pscho makes this semantics incorrect for refinements based on bisimulation or ready simulation.

Open systems have well defined interfaces that specify how a system can interact with any environment. For example, the header of a method specifies input values and types for method invocation and such an invocation resolves the nondetermin- ism of that interface at runtime. Parallel composition of process algebra terms and modular model checking also express and analyze open systems and the external nondeterminism stemming from their interaction with environments.
Descriptions of requirements may exhibit an additional form of nondeterminism, that of under-specification. A local access control policy may be silent on accesses pertaining to a non-local resource. An architecture may specify that at most four servers may be used for data processing of an e-commerce application. A state machine may say that the implementation of an audit logging facility is optional. Etc. This nondeterminism is resolvable, ideally in a stepwise fashion, by a controlled choice of implementation alternatives, e.g. the decision not to implement audit logs or the decision to deny all accesses to non-local resources.
A further form of nondeterminism may be needed in the modeling of behavior. Bisimulation and its probabilistic variants treat nondeterminism as persistent. For a labeled transition system its bisimulation quotient is a behavioral model that has not lost any nondeterminism present in the original labeled transition system. Another example of persistent nondeterminism can be found in modeling and reasoning about faulty systems (as seen below), or in the modeling of random behavior without knowledge of any distributions [26]. A method header may have an input x of static type String but a complex precondition may enforce semantic constraints on legal inputs, e.g. “at most two coding errors occur in string x”. One then wants to reason about the correctness of an implementation of that method for all inputs with at most two coding errors. The implementor or verifier is then not in control over the choice of input (zero, one or two coding errors) that meets these constraints, and seeks assurance against all such choices. In particular, this need to consider all scenarios persists even when the method body is fully implemented – including its communication details with external services.
Modeling languages usually handle well the resolvable forms of nondetermin- ism, whereas they may not adequately support persistent nondeterminism. In this paper we focus on UML state machines [25] – a variant of statecharts [12,13,14] – which model behavioral aspects of an object in an object-oriented application. The example below already exhibits resolvable and persistent nondeterminism.
Example 1.1 The state machine on the left in Fig. 1 models the part of a system

that counts the number of currently occupied sectors of memory, stored in variable x. Setting x to 0 models reformatting, all sectors are freed up again. This is the initial state and up to three sectors may be occupied. External nondeterminism is present, e.g., in the choice of events ref (reformatting) and inc (increment sector count) when 0 < x ≤ 3. Persistent nondeterminism is expressed with the “persistent choice” operator pscho {0, 1, 2, 3}. On event ref and positive value of x, that variable can be set to any value n between 0 and 3 where n is understood to be the leftmost non- faulty sector. We cannot control the choice of that value since x := pscho {0, 1, 2, 3} models all relevant fault scenarios. (However, to keep this running example small, we will use only a persistent choice between no fault and a fault in the first sector, expressible as x := pscho {0, 1}.) This state machine has resolvable nondeterminism between this persistent choice and that of x := 0. The latter transition is risky as it ignores any fault in any modelled sector of memory.
In the above example, program and faulty memory are combined into a single model. This is advantageous in model checking, when the verification property won’t have to specify any fault scenarios, since property specifications become more transparent and reusable and one can compensate for the increased complexity of the model through further model abstraction.
Persistent nondeterminism is not supported in UML state machines explicitly. But even without such explicit support, it has an implicit presence as soon as the underlying programming language has a “persistent choice” operator as seen in Example 1.1 – which could also be implemented by a random choice. To our knowledge, no formal semantics of UML state machines in the extant literature can express such a construct adequately.

Contribution and outline of paper.
Our aim is to support verification on an abstract level for systems that also have persistently nondeterministic behavior, where we mainly focus on state machine, respectively statechart, formalisms. Specifically:
Section 2: We develop a new class of models, which employ hypertransitions, together with a refinement notion that can handle all external and persistent nondeterminism and under-specification.
Section 3: We define a 3-valued satisfaction relation between our models and the modal μ-calculus [19,33], and prove its soundness under our refinement notion.
Section 4: We discuss state machine semantics in terms of our new class of se- mantic models.
Subsection 4.1: We present a formal semantics for a simple state-machine vari- ant with a persistent choice operator for arithmetic expressions.
Subsection 4.3: We discuss how existing formal semantics of more complex state machine variants can be accommodated to handle persistent choice operators adequately with respect to the common refinement notion in state machines.
Section 5: We sketch how our technique can be generalized to state machine variants with, possibly underspecified, random choice operators.

ν-automata
Before we introduce our new class of semantic models, we present labeled transition systems. We do not consider predicates on states, as they appear, e.g., in Kripke structures, but our theory can be easily extended to allow for this.
We use the following notation: L denotes a set of transition labels. |A| denotes the cardinality of a set A. The set of total functions from A to B is denoted by BA. Therefore we may write 2A for the power set of A. For a binary relation R ⊆ M1×M2 and for X ⊆ M1, we define X.R = {m2 ∈ M2 | ∃m1 ∈ X : (m1, m2) ∈ R}. For a
ternary relation ~ ⊆ M1 ×L× M2 we write m1 ~e m2 for (m1, e, m2) ∈ ~ and ~e

for the binary relation {(m1, m2) | m1 ~e m2}.

Transition systems
m2}, thus {m1}. ~e
= {m2 ∈ M2 | m1 ~e


Definition 2.1 A labeled transition system (TS) with respect to the label set L is a tuple (C, ci, ~), where C is its set of states, ci its initial state, and ~ ⊆ C ×L× C its transition relation.
Nondeterminism in transition systems appears as multiple transitions going out from the same state and having the same label. A resolvable approach to this nondeterminism is obtained by using, e.g., the refinement notion of ready-simulation [2], whereas a persistent approach is, e.g., obtained by using bisimulation [24] as underlying equivalence notion. Both notions are made formal as follows:
Definition 2.2 Suppose T1 and T2 are two TSs. Then T1 is ready-simulated by T2
if there exists a relation R ⊆ C1 × C2 such that the initial states are related, i.e.,
(ci , ci ) ∈ R, and
1  2

for (c1, c2) ∈ R we have
∀e ∈ L, c' ∈ {c1}. ~e 1: ∃c'
∈ {c2}. ~e 2: (c' , c' ) ∈ R and

1 '	e	'	2	'	1  2	'
{e ∈L| ∃c : c1 ~1 c } = {e ∈L| ∃c : c2 ~e 2 c }.
1	1	2	2
Constraint (i) states that every concrete transition has an abstract counterpart and (ii) states that every label present at the abstract level has to be present at the concrete level (and vice versa by constraint (i)). Similarly, in the definition of bisimulation every transition in T1 has a counterpart in T2 and vice versa.
Definition 2.3 Two TSs T1 and T2 are bisimilar if there exists a relation R ⊆
C1 × C2 such that the initial states are related, i.e.,
(ci , ci ) ∈ R, and
1  2

for (c1, c2) ∈ R we have
∀e ∈ L, c' ∈ {c1}. ~e 1: ∃c'
∈ {c2}. ~e 2: (c' , c' ) ∈ R and

1	e	2	e	1  2
∀e ∈ L, c' ∈ {c2}. ~2: ∃c' ∈ {c1}. ~1: (c' , c' ) ∈ R.
2	1	1  2

,,,,
e1,,,,˛,,. , ,, 
,,,, e1
¸,¸,,,_,,. , ,, 

,,v. , ,, ,¸,z,, e
 ,,. , ,, 
e3 , ,,v. , ,, ¸,,z,,
¸¸z,,. , ,, _

 1
e2 ¸¸¸z,,. , ,, 
∅,,,
¸¸¸¸¸¸¸z,,. , ,, 


Fig. 2. Transformation of a transition system, interpreted with persistent nondeterminism and depicted on the left, to the ν-automata syntax, depicted on the right. The set of labels is L = {e1, e2, e3}.

ref,inc,full	ref

  r,~¸~ , ¸re,f r,~¸0J~ , ¸ , inc 	 ,r¸~1 ~, 
ref
r,~¸0J~ , ¸ , inc	 ,r¸~1 ~, 

s  ,
,,,¸
,,,..,,,¸	
 ,
,,,..,,,¸	

ref,inc,full
ref
ref ...ref¸¸¸
inc
..r.ef¸¸¸
inc

ss r,~¸~ ,  full zr,~¸~ , ....
¸¸¸,r¸~J ~, 
r,~¸~ ,  full zr,~¸~ , ....
¸¸¸,r¸~J ~, 

∅ 3 ¸¸3 ¸¸
inc
2
inc
3 ¸¸3 ¸¸
inc
2
inc

Fig. 3. Two ν-automata. Hypertransitions are illustrated by an arrow with a single starting point, a single label and several targets. A set of hypertransitions sharing the same targets and label are combined using a small circle. All states that do not have for e ∈ L a drawn outgoing transition have an implicit transition with label e to ∅. For later references, some states are named by numbers, drawn inside the circles. Here,
the set of labels is L = {ref, inc, full}.


ν-automata syntax
Note that in transition systems, it is only possible to opt for one of the interpreta- tions of nondeterminism if such an interpretation is to be applied uniformly within a transition system. This suggests to use another class of models for expressing resolvable and persistent kinds of nondeterminism in the same model. The idea be- hind the approach proposed in this paper is to use again a kind of ready-simulation. Therefore, we treat the persistent nondeterminism present in transition systems not in the conventional manner of using multiple transitions per label and source state; rather we use exactly one transition per label and source state that points to a set of successor states. In particular, a state with no outgoing transitions with label e has, in this approach, one e-labeled transition pointing to the empty set.
Example 2.4 Consider Fig. 2 where a transition system, interpreted with persis- tent nondeterminism, and its transformed system are presented. The transformation will be given formally in Proposition 2.7.
If we now allow more than one outgoing hypertransition per state and label, we can model resolvable nondeterminism in the sense of ready-simulation. We first define the models of interest.
Definition 2.5 A ν-automaton with respect to L is a tuple (C, Ci, '−→), with C its set of states, Ci ⊆ C its initial states, and '−→ ⊆ C ×L× 2C its hypertransition relation. A ν-automaton is concrete if it has exactly one initial state (|Ci| = 1) and exactly one transition per label and per source state: ∀c ∈ C, e ∈L : |{c}. '−e→ | = 1.
A state that does not have outgoing transitions for a label from L cannot be related to a concrete state, i.e., such a state is unsatisfiable (shown below). Examples of ν-automata are depicted in Fig. 3. We now define the desired refinement notion.

ν-reﬁnement
The adaption of ready-simulation to our class of models leads to the following refine- ment notion, where every refining initial state has a related abstract initial state; and any refining hypertransition can be matched by an abstract hypertransition with the same label and target sets that are pairwise related. Formally:
Definition 2.6 We say the ν-automaton (C1,Ci , '−→1) ν-refines the ν-automaton (C2,Ci , '−→2) if there is a ν-refinement R, i.e., a relation R ⊆ C1 × C2 such that
∀ci ∈ Ci : ∃ci ∈ Ci : (ci , ci ) ∈ R, and
1	1	2	2	1  2
∀(c1, c2) ∈ R, e ∈ L, Θ1 ∈ {c1}. '−e→1: ∃Θ2 ∈ {c2}. '−→e 2:
(∀c' ∈ Θ1 : ∃c' ∈ Θ2 : c' Rc' ) ∧ (∀c' ∈ Θ2 : ∃c' ∈ Θ1 : c' Rc' ).
1	2	1	2	2	1	1	2
For example, the ν-automaton on the right hand side in Fig. 3 is a ν-refinement of the ν-automaton on the left hand side in the same figure. Transition systems with resolvable nondeterminism, as well as transition systems with persistent non- determinism, can be embedded into ν-automata:
Proposition 2.7	(i) The embedding δps from transition systems into ν-automata, deﬁned by δps(C, ci, ~) = (C, {ci}, {(c, e, Θ) | c ∈ C ∧ e ∈ L ∧ Θ = {c' |
c ~e  c'}}) ensures that two transition systems are related via bisimulation iff
their transformations are related via ν-reﬁnement. Moreover, the image of δps
captures exactly the concrete ν-automata.
(ii) The embedding δr(C, ci, ~) of the transition system (C, ci, ~)s into a ν-automata
is deﬁned as δr(C, ci, ~) = (C, {ci}, {(c, e, {c'}) | c ~e c'}∪ {(c, e, ∅) | {c}. ~e
= ∅}), and ensures that two transition systems are ready bisimilar iff their transformation are related via ν-reﬁnement.
Discussion
μ-automata [16] are extensions of transition systems, which are also able to han- dle resolvable and persistent nondeterminism in a single formalism. The syntax of μ-automata can be defined to be that for ν-automata, but they differ in their refine- ment notion and so also in their concrete elements. In μ-automata, every transition at the abstract level has to be matched by the concrete system, but with possibly less target states. In other words, persistent nondeterminism is encoded via the outgoing transitions and resolvable nondeterminism is encoded by using a set of states as transition target. This is dual to ν-automata, where resolvable nondeter- minism is encoded via outgoing transitions having the same label and persistent nondeterminism is encoded by using a set of states as transition target.
In our approach we can freely alternate persistent and resolvable non-determinism, since at each state of a ν-automata the modeler can decide whether to express per- sistent or (non-exclusively) resolvable non-determinism.
We consider every label of a transition system to be reactive, i.e., to denote an incoming communication. But generative labels correspond to asynchronous output communication of the system (e.g., label full in Fig. 3). If different generative labels

are used, the set of concrete systems of ν-automata has a different constraint for generative labels: From any state there may be at most one outgoing transition with a generative label. Our refinement notion then has to be amended such that transitions having generative labels can be removed, as long as one remains present.
Satisfaction
We give a 3-valued satisfaction relation between ν-automata and the μ-calculus [19]. We chose this logic since persistent choice leads us into the world of branching time and the μ-calculus is a canonical branching-time logic in which many popular branching-time logics, such as CTL, can be translated. The set of all μ-calculus formulas F is generated by the following BNF-grammar:
φ ::= tt | ff | Z | φ ∧ φ | φ ∨ φ | ⟨e⟩ φ | [e] φ | μZ.φ | νZ.φ
where e ∈L and Z is from a μ-calculus variable set Var. The dual formula dual(φ) of a μ-calculus formula φ is obtained by replacing tt by ff, ∧ by ∨, ⟨e⟩ by [e], μ by ν, and vice versa.
Definition 3.1 Suppose A = (C, Ci, '−→) is a ν-automaton. Then the semantic function  ) : F × (Var → 2C) → 2C with respect to A is:
 tt)ρ = C	 ff)ρ = ∅	 Z)ρ = ρ(Z)
 φ1 ∧ φ2)ρ = φ1)ρ ∩ φ2)ρ	 ⟨e⟩ φ)ρ = {c ∈ C | ∀Θ ∈ {c}. '−e→:Θ ∩ φ)ρ /= ∅}

 φ1 ∨ φ2)ρ = φ1)ρ ∪ φ2)ρ	 [e] φ)ρ = {c ∈ C | ∀Θ ∈ {c}. '−→e
:Θ ⊆ φ)ρ}

 μZ.φ)ρ =  {C¨ | φ)ρ[Z→C¨] ⊆ C¨}	 νZ.φ)ρ =  {C¨ | C¨ ⊆ φ)ρ[Z→C¨]}
Let φ be a closed formula, i.e., every variable Z only occurs in φ under the scope of μZ or νZ. Then A satisﬁes φ, written A |= φ, if Ci ⊆ φ)ρ0 , where ρ0 maps every variable to the empty set. Furthermore, A falsiﬁes φ if A |= dual(φ).
The above satisfaction definition is standard except for the diamond and box operators: To guarantee that satisfaction of  ⟨e⟩ φ)ρ under ρ is being preserved at every refinement, all transitions labeled e in the ν-automaton (refinement can remove all but one) must have a suitable candidate in its target set Θ, i.e., Θ∩ φ)ρ /=
∅ is required. To guarantee that satisfaction of [e] φ)ρ under ρ is being preserved at every refinement, all targets Θ of any transition labeled e in the ν-automata must be suitable candidates: Θ ⊆ φ)ρ.
An example illustrates that this satisfaction definition is indeed 3-valued: The ν-automaton A = ({c}, {c}, {(c, e, {c}), (c, e, ∅)}) neither satisfies nor falsifies the formula ⟨e⟩ tt. However, for concrete ν-automata the satisfaction definition is two- valued, and corresponds to the normal μ-calculus satisfaction for transition systems (where the dual formula corresponds to negation) in their image under δps. Note that A might not satisfy φ, although all concrete refinements of A satisfy φ. This is, e.g., the case for the above ν-automaton A and the formula φ = ⟨e⟩ tt ∨ [e] ff. However, our satisfaction is sound, as stated by the following theorem:

Theorem 3.2 Satisfaction is sound for reﬁnement: If a ν-automaton A1 reﬁnes a
ν-automaton A2, then for any closed formula φ ∈F we have A2 |= φ ⇒ A1 |= φ.

State machine semantics
Simple state machine with a persistent choice operator
The basic modules of UML state machines 6 are variables, states and annotated transitions between them. The structure of, and notation for, our simple state ma- chines is given as follows: A simple state machine SM is a tuple (V, σinit , S, sinit ,T ) comprising a set of integer-variables V , an initial variable assignment σinit ,a set of states S, an initial state sinit ∈ S, and a set of transitions T . A transition t com- prises a source πsrc(t) ∈ S, a target πtgt(t) ∈ S, an event πev(t) ∈ E denoting the external trigger, a guard πgd(t) denoting a necessary condition for enabledness, and an SM-action πact(t), which has to be executed when the transition is taken. For sake of simplicity we restrict the set of guards (g ∈)G to boolean expressions over
V . An SM-action consists of a ‘do nothing’-action skip, the sending of an event, or a variable assignment – where exp may contain instances of the persistent choice operator (pscho ) that models persistent nondeterminism for variable assignments. Formally, an SM-action α is given by the following BNF-grammar:
α ::= skip | send(e) | v := exp	exp ::= v | n | exp ⊗ exp | pscho N

where v is a variable from V , n an integer-constant, e an element from the set of output events E of the state machine, ⊗ any standard binary operator on integers such as addition or subtraction, and N is a (finite) set of integer-constants – the possible return values of the persistent choice operator. The set of all SM-actions is denoted by Act.
Remark 4.1 So far we modeled only persistent nondeterminism with respect to variable assignments. Choice pseudostates 7 , which exist in UML state machines, can be used to model persistent nondeterminism with respect to state machine states
{si | i ∈ I}. To that end we take a choice pseudostate, let it point to state machine targets si with guards [x = i] for i ∈ I, and then put a SM-action x := pscho I on the incoming transition for said choice pseudo-state.
We first discuss the semantics of state machines informally. At each step a single event e is dispatched from the event pool where the order of dispatching is left open in [25]. This event enables a transition if (i) its source is currently active, (ii) e is its trigger, and (iii) its guard evaluates to true with respect to the current variable assignment. Among all enabled transitions, one is chosen, its corresponding SM-

6 Note that it is possible to introduce persistent nondeterminism to statechart semantics in a similar way. But since the semantics of triggering events are different (sets of events in statecharts in contrast to single events in state machines) this simple but cumbersome adaption is omitted.
7 Choice pseudo-states are intermediate states with respect to the run to completion steps – where decisions via guarded transitions are made and no external communication is excepted.

action is executed, and the active state becomes its target instead of its source. If no transition is currently enabled for e, different interpretations are possible:
U (‘no enabled transition’, corresponds to under-specification): Arbitrary behavior is possible after consuming e. A transition in state machines can be added as long as its guard conjoined with the guard of any other transition from the same source and with the same event is unsatisfiable. This harmonizes with the refinement pattern of [28].
D (‘no enabled transition’, corresponds to discarding): e is consumed without exe- cuting any SM-action. This corresponds to the standard interpretation of UML state machines 8 .
We first provide formal semantics to the U-approach, the formal semantics to the
D-approach is given in Example 4.2.
V denotes the set of all possible variable assignments of V . The guards are evaluated with respect to a variable assignment in the usual way by a function eval : G ×V → {T, ⊥}, where T corresponds to the boolean value true and ⊥ to false. Function calc : Act ×V → 2V yields the set of updated variable assignments, which is in general a singleton set except in the case of the usage of the persistent choice operator. Formally:
calc(α, σ)= ⎨ {σ[v '→ n] | n ∈ c˜alc(exp, σ)} if α is v := exp
⎩ {σ}	otherwise

˜	⎪⎨ {n}	if exp is constant n
calc(exp, σ)= 
⎪ {n1 ⊗ n2 | ∀j ∈ {1, 2} : nj ∈ c˜alc(expj , σ)} if exp is exp1 ⊗ exp2
The formal semantics is given as a ν-automaton: Its state space consists of (i) configurations – SM-states combined with variable assignments – (ii) intermediate states for modeling the sending of output events, and (iii) an additional state cr, which corresponds to a ν-automaton state abstracting anything. Formally, its state space is (S × V) ∪ (E × S × V) ∪ {cr}. Its only initial state is the initial SM-state combined with the initial variable assignment (sinit, σinit). Its hypertransitions are given by the derivation rules in Fig. 4, where its underlying set of labels is E ∪ E.
Example 4.2 The formal semantics of the state machine on the left in Fig. 1 and of the one in Fig. 5 is the ν-automaton on the left (respectively right) in Fig. 3. Here, the state machine constraint “all other events discarded” means that the D-approach is taken, in which case rule (f) is replaced by
'  ∀t ∈ T : (πsrc(t)= s ∧ πev(t)= e) ⇒ eval(πgd(t), σ)= ⊥

(f )
(s, σ) >e
{(s, σ)}



8 In UML state machines an event can also be declared to be deferred at a state, in which case the triggering or discarding of this event is moved to a subsequent state where it is no longer deferred and becomes active.




(a)
t ∈ T	eval(πgd(t), σ)= T	πact(t)= send(e)
πev (t)


(b)   e ∈ E	
(s, σ) >e

(c)


 e ∈ E ∪ E
e

(πsrc(t), σ)
> {(e, πtgt(t), σ)}
∅	cr > {cr}




(d)

t ∈ T	eval(πgd(t), σ)= T	∀e ∈ E : πact(t) /= send(e)
πev(t)


(e)
c  >e  ∅

e

(πsrc(t), σ) > {(πtgt(t), σ') | σ' ∈ calc(πact(t), σ)}
(e, s, σ) > {(s, σ)}


∀t ∈ T : (πsrc(t)= s ∧ πev(t)= e) ⇒ eval(πgd(t), σ)= ⊥	e ∈ E ∪ E \ {e}

(f)
(s, σ) >e
(g)
{cr}
(e, s, σ) >e  ∅



Fig. 4. Transition derivation rules. The firing of a transition that sends an output event leads (by adapting the active SM-state) to an intermediate state (a), which only sends exactly the corresponding output event
(e) but nothing else (g). Output events can only be sent in such intermediate states (b). If the SM-action is different from a send-action, a hypertransition subsuming all the possible outcomes with respect to calc is derived (d). In case no transition is enabled for an event (f), a transition to the state cr, which abstracts
e

everything ensured by (c), is derived. Note that (c) encodes two rules: one where cr
e
conclusion, another where cr > ∅ is the conclusion – both having the same premise.
> {cr} is the


¸¸¸	ref [x>0] x:=pscho {0,1}
x:=0¸¸¸zz˛z,c
,¸inc [x<3] x:=x+1



inc [x=3] send(full)
all other events discarded

Fig. 5. State machine from Fig. 1 after its leftmost transition, labeled with ref, is removed and non-present events are interpreted as “discarded”.

where self loops (discarding) – rather than the reaching of the state that abstracts everything – happen. Note that adding the constraint “all other events discarded” is a refinement step. This, and that the removal of transitions (as long as for every variable assignment the set of enabled events remains the same) is a refinement step, are illustrated by the example where the ν-automata on the right in Fig. 3 is a refinement of the one on the left in Fig. 3.

Discussion
The order of persistent and resolvable nondeterminism defined in μ-automata, intro- duced in Subsection 2.4, does not fit well the requirements for a semantics of state machines with persistent choice operator: ν-automata with their ready simulation approach of refinement allow direct use of variable assignments as ν-automaton states. This is possible, because under-specification is modeled similarly in state machines and ν-automata: Removing transitions in the state machine directly cor- responds to removing transitions in the semantic model. This correspondence does not exist between state machines and μ-automata. Consequently, it is necessary to use more complex μ-automaton states: In addition to variable assignments, addi- tional information is needed for expressing every possible choice of taken transitions


e1 [tt] x:=0
.
en [tt] x:=0
x:=0

J, ce1 [tt] x:=pscho {0,1}
.	e
en [tt] x:=pscho {0,1}

Fig. 6. A state machine together with its semantics in terms of ν-automata.

for each SM-action. This exponentially blows up the state space:
Example 4.3 A state machine and its semantics in terms of ν-automata are given in Fig. 6. The semantics in terms of μ-automata is significantly more complex, and for this reason not depicted. Its set of states is {0, 1}× 2n, its set of initial states is
{0}× 2n, and its transition relation is


 
j∈{1,2},C¨∈2n
({((j, C¨), {0}× 2n)}∪ {((j, C¨), {1}× 2n) | j ∈ C¨}


In different settings, μ-automata may well be more suitable than ν-automata;
e.g. in giving an operational semantics for a process algebra with parallel composi- tion and a persistent choice operator [9].

Adaption of existing semantics
We sketch how existing formal semantics of state machines can be easily adapted such that they can handle also persistent choice operators. Since our extension of state machines with persistent choice is orthogonal to their run to completion steps, concurrency, and hierarchies, those notions are still adequately handled in the presence of persistent choice operators.
We assume that the formal semantics is given in terms of transition systems that are obtained by derivation rules (small step semantics). Also, we assume that the derivation rules use an evaluation function calc for the SM-actions, i.e., calc maps a SM-action together with a variable assignment to a variable assignment (and possibly additional information). This kind of formal semantics occurs, e.g., in [10,32].
As the first transformation, function calc is adapted to SM-actions containing also persistent choice operators. This is achieved by changing the range of calc to sets (rather than elements) of variable assignments.
Next, the derivation rules are adapted such that hypertransitions are obtained. This is done by replacing the target of the derived transition by the set consisting of the original target. But when calc is used for the derivation, the target set contains all possible variations with respect to the result of calc. For example rule
α /= skip	calc(α, σ)= (l, α', σ')

(σ, A, do, H, α, s¨, β, T, T¨) >l
(σ', A, do, H, α', s¨, β, T, T¨)

taken from [10] – describing the execution of a SM-action – is transformed into
α /= skip

(σ, A, do, H, α, s¨, β, T, T¨) >l
{(σ', A, do, H, α', s¨, β, T, T¨) | (l, α', σ') ∈ calc(α, σ)}

Note that in the semantics of [10] the evaluation function also yields (i) a label (e.g. the sending of an output event), which will be the same for all elements of calc(α, σ),
(ii) a SM-action, which remains to be executed, and (iii) a variable assignment.
Finally, absence of outgoing transitions for a given label is handled such that it harmonizes with ν-refinement. If at a state there is no outgoing transition with a generative event (see Subsection 2.4), then a corresponding transition pointing to the empty set is added. The same is done for events whenever no events can be accepted in the current state, e.g., if some computation must first be finished. The absence of outgoing transitions – for an event e in a semantic state c where events can be accepted – is handled by a case analysis on the different interpretations introduced in Section 4.1:
U: Add a new state cr to the ν-automaton and add the additional two deriva- tion rules (c) from Fig. 4. Thus cr represents a state that is refined by any ν-automaton state. A transition labeled with e from c to {cr} is also added. 9
D: A self-loop from c labeled with event e is added.

Random choice operators
A random choice operator can be used to express a probability distribution. Prob- ability distributions are a form of persistent choice. For example, the probabilistic choice of a successor state of state s in a Markov chain expresses a nondeterministic choice that remains to be nondeterministic each time state s is visited. Of course, this persistence is controllable to some degree through the use of familiar tools from stochastic processes.
ν-automata and random choice
We sketch how ν-automata can be adapted to support random choice operators with an underlying distribution: First, they are extended by moving from power sets to distributions as transition targets, i.e., '−→ ⊆ C × L × Dist(C) where Dist(C) denotes the possible discrete distributions over the set C (total functions f from C to [0, 1] such that c∈C f (c) = 1). Furthermore, the refinement notion is adapted to handle probabilities by lifting the refinement relation to distributions, i.e., probabilistic automata with strong simulation [29] as refinement notion. Then
calc has to be adapted such that distributions rather than sets of states are obtained. The adaption of the existing semantics is then made similar to that in Section 4.3. Note that in such a probabilistic setting, satisfaction is defined over probabilistic logics, like PCTL [11], rather than over the μ-calculus.

9 An additional transition to the empty set is not needed here, since input enabledness is usually guaranteed. Otherwise, e.g. in the context of event deferral, such a transition has to be added.

..,,,..,,,¸¸¸ {0.2}
,,, _r,¸~¸~ , ,
,, r,~¸~ , ¸
r,¸~¸~ , ,

... {
{0.3,¸},,,
,,,
0.5 

...	0,.,5},,¸ ¸¸¸¸ {1}
[0,0.3]∪{0.5} {1}	1

J.. ., [0,0.3],
¸¸¸ ¸¸¸zJ˛ 
J,, ,,,		 J 
J 	J 

1) r,~¸~ ,¸¸ ,,,..,,,¸
 ¸¸
,, r,~¸~ , ¸
2) r,~¸~ , ¸¸¸¸ {0,0.3}	 r,~¸~ , 
3) r,~¸~ ,
,,.,,.,,¸¸¸
r,~¸~ ,

¸¸ [0.7,1]¸¸	,¸¸,	¸	¸

¸¸¸¸
{0.¸5¸}¸ ¸,¸,,,
¸¸{1}
{0.2,0.5}∪[0¸.7,1] {1}
¸¸¸ 1

¸¸¸,,,..,,, ,  {0.3} ¸¸¸¸¸¸ zr,z~¸ ~J , _  
¸¸¸¸zr,~¸J~  , ˛ 
0.5
¸r,z~¸J~ , 


Fig. 7. Illustration of 1) a ν-automaton extended with sets of probabilities, 2) a probabilistic specification system, which has all concrete refinements of 1) and is minimal with respect to refinement among those models having all concrete refinements of 1); and 3) a deterministic probabilistic automaton being a concrete refinement of 2) but not of 1). All three models have the same single event-label, which is therefore omitted.

Under-speciﬁed random choice
This approach can also deal with randomized choice that is under-specified. Exact knowledge of distributions is often not a realistic assumption and does not facili- tate top-down-development, because abstract systems already need to specify exact probabilities. Therefore, approaches emerged [18] where only sets or intervals of allowed probabilities are given. We can accommodate this as follows:
Probabilistic automata (PA) are extended by moving from distributions to sets of possible distributions as transition targets, i.e., '−→ ⊆ C ×L× (2[0,1])C which yields a generalization of probabilistic speciﬁcation systems (PSS) [18], where the transition relation is a subset of C × (2[0,1]) × C. Furthermore the refinement notion has to be adequately adapted, similar to the treatment in [18]. This new class of models, which we denote by PSSA, has more expressive power than PSS in the sense that more sets of concrete refinements can be described via refinement. This is informally argued in Fig. 7. Note that PSSA has also more expressive power than PA, first with respect to strong simulation – since probabilistic intervals cannot be finitely described by nondeterminism – and, second with respect to strong probabilistic simulation [29], since this has already less expressive power than PSS.
In order to give the formal semantics, calc has to be adapted such that sets of distributions rather than distributions are obtained. The adaption of the existing semantics is then made similar to that in Section 4.3. The exact development of the theoretical foundation of this class of models, including precise refinement and satisfaction definitions, is a topic of future work.

Related work
The process algebra CSP [15,27] has internal and external choice operators for ex- pressing nondeterminism. Since all CSP process terms appear to have deterministic refinements, CSP and FDR cannot explicitly support models with persistent choice but one can represent persistent non-determinism in an environment and instru- ment refinement checks such that all choices of the environment are non-resolvable for all implementations. Process algebras having persistent as well as resolvable choice operators occur in [1,9], differing in their interpretation of parallel compo- sition. Their semantics is given in terms of μ-automata and “persistent choice” is called “inherent choice” in loc. cit.
In the world of predicate transformers and Hoare logics as their cousins, there is

a rich body of work on combining probabilistic and (resolvable) non-deterministic choice, e.g. [23]. Such work is in the tradition of deductive verification and may exploit algebraic identities for the simplification of proofs. Such deductive reasoning,
e.g. in the form of assume-guarantee proof rules for model checking [7], is outside the scope of this paper.
In Subsection 4.2, we argued why μ-automata [16] are not suitable as seman- tic models for state machines having persistent choice operators. Further abstract models that can express persistent as well as resolvable nondeterminism are, e.g., (disjunctive) modal transition systems [21,22], mixed transition systems [4], gen- eralized Kripke modal transition systems [30], hypermixed Kripke structures [8], and modal automata [5]. These models have additional may-transitions meaning that refinements may have those transitions but not necessarily so. Hyper Kripke modal transition systems [31] interpret must-hypertransitions analogously to the μ- refinement approach, whereas may-hypertransitions are interpreted analogously to the ν-refinement approach. None of these models are suitable as semantic models for UML state machines by the same arguments as put forward for μ-automata. Note that the additional may-transitions do not help to define the semantics, since there is no concept in state machines that supports such kind of modeling directly (in state machine refinements, a transition per label has to remain, i.e., not all tran- sitions can be removed [28]). A comparison to probabilistic models is already made in Section 5. In [20], the authors use probabilistic games to differentiate between probabilistic (persistent) and resolvable nondeterminism. Their model is close to PSSA based on strong probabilistic simulation.
An overview of existing formal semantics of UML state machines is given in [3], where 26 different approaches are compared – and none of them features persistent choice. [10], which is not referenced in [3], gives a complete formal semantics of UML
2.0 state machines without persistent choice. As already mentioned, refinement patterns of statecharts are presented in [28], where the underlying formal semantics are streams and therefore no persistent nondeterminism is handled. In [6] state machines are mapped to terms of CSP and so a stronger semantics is given by considering trace- and failure-based refinement.
The work most closely related to ours is [17], where formal semantics in terms of probabilistic automata based on strong simulation is given to state machines having an additional randomized pseudo-state. Their semantic mapping corresponds more to a run to completion step rather than to the firing of transitions. This leads to the problems that (i) their refinement notion – implicitly given via probabilistic automata – is only sound but imprecise, i.e., there are unexpected semantic re- finements, illustrated in Fig. 8, (ii) a well formed condition – that every variable may only be changed by one of the firing transitions – is needed, and (iii) their state space is exponential in the number of enabled probabilistic transitions. None of these problems occur in our definition of probabilistic pseudo-states via choice pseudo-states (see the discussion in Remark 4.1).



flip
""flip

1 /heads


flip

1 /heads


a playin,g¸
 ,rP¸~ ~,  2	
1 /tails
b) playin,g¸
 ,rP¸~~ ,  2	
1
2

Fig. 8. a) A state machine having probabilistic pseudo-states and b) one of its possible (unwanted) refine- ment with respect to the formal semantics of [17], where heads, but no tails can occur.
Conclusion
We developed a new class of models, ν-automata, which describes sets of transition systems by a suitable refinement notion. ν-automata employ hypertransitions, their refinement notion generalizes ready simulation, and they are suitable as semantic models for systems that feature or benefit from persistent nondeterminism as well as resolvable nondeterminism. In particular, a formal semantics for a simple state machine language was given in ν-automata and it was sketched how existing seman- tics of state machines can be adapted if persistent choice operators are added to the underlying programming language. A compositional 3-valued satisfaction definition over the μ-calculus was given for ν-automata and proved to be sound for property verification.
It is future work to establish tool support based on the ν-automata semantics for satisfaction and refinement. In particular, it should be examined how ν-automata can be used in the context of abstraction in order to speed up verification.

References
Baeten, J. C. M. and J. A. Bergstra, Process algebra with partial choice., in: B. Jonsson and J. Parrow, editors, CONCUR, LNCS 836 (1994), pp. 465–480.
Bloom, B., S. Istrail and A. Meyer, Bisimulation can’t be traced, J. ACM 42 (1995), pp. 232–268.
Crane, M. L. and J. Dingel, On the semantics of UML state machines: Categorization and comparison, Technical Report 2005-501, Queen’s University (2005).
URL  http://www.cs.queensu.ca/TechReports/Reports/2005-501.pdf

Dams, D., R. Gerth and O. Grumberg, Abstract interpretation of reactive systems, ACM Trans. Program. Lang. Syst. 19 (1997), pp. 253–291.
Dams, D. and K. S. Namjoshi, Automata as abstractions, in: R. Cousot, editor, VMCAI, LNCS 3385
(2005), pp. 216–232.
Davies, J. and C. Crichton, Concurrency and refinement in the unified modeling language, Formal Aspects of Computing 15 (2003), pp. 118–145.
de Roever, W.-P., H. Langmaack and A. Pnueli, editors, “Compositionality: The Significant Difference,” LNCS 1536, Springer, 1998.
Fecher, H. and M. Huth, Ranked predicate abstraction for branching time: Complete, incremental, and precise., in: S. Graf and W. Zhang, editors, ATVA, LNCS 4218 (2006), pp. 322–336.
Fecher, H. and H. Schmidt, Process algebra having inherent choice: Revised semantics for concurrent systems., in: SOS, 2007, will appear in ENiTCS.
URL http://www.informatik.uni-kiel.de/~hf/papers/Fecher07sos.pdf

Fecher, H. and J. Sch¨onborn, UML 2.0 state machines: Complete formal semantics via core state machines., in: L. Brim, M. Leucker, B. R. Haverkort and J. van de Pol, editors, FMICS and PDMC 2006, LNCS 4346 (2007), pp. 244–260.

Hansson, H. and B. Jonsson, A logic for reasoning about time and reliability., Formal Asp. Comput. 6
(1994), pp. 512–535.
Harel, D., Statecharts: A visual formulation for complex systems., Sci. Comput. Program. 8 (1987),
pp. 231–274.
Harel, D. and E. Gery, Executable object modeling with statecharts., IEEE Computer 30 (1997), pp. 31– 42.
Harel, D. and H. Kugler, The Rhapsody Semantics of Statecharts (or, on the executable core of the UML), in: H. Ehrig, W. Damm, J. Desel, M. Große-Rhode, W. Reif, E. Schnieder and E. Westk¨amper, editors, SoftSpez Final Report, LNCS 3147 (2004), pp. 325–354.
Hoare, C. A. R., “Communications Sequential Processes,” International Series in Computer Science, Prentice Hall, 1985.
Janin, D. and I. Walukiewicz, Automata for the modal mu-calculus and related results, in:
J. Wiedermann and P. H´ajek, editors, Mathematical Foundations of Computer Science, LNCS 969
(1995), pp. 552–562.
Jansen, D. N., H. Hermanns and J.-P. Katoen, A probabilistic extension of UML statecharts., in:
W. Damm and E.-R. Olderog, editors, FTRTFT, LNCS 2469 (2002), pp. 355–374.
Jonsson, B. and K. G. Larsen, Specification and refinement of probabilistic processes, in: LICS (1991),
pp. 266–277.
Kozen, D., Results on the propositional μ-calculus, Theor. Comput. Sci. 27 (1983), pp. 333–354.
Kwiatkowska, M. Z., G. Norman and D. Parker, Game-based abstraction for Markov decision processes., in: QEST (2006), pp. 157–166.
Larsen, K. G. and B. Thomsen, A modal process logic, in: LICS (1988), pp. 203–210.
Larsen, K. G. and L. Xinxin, Equation solving using modal transition systems, in: LICS (1990), pp. 108–117.
McIver, A. and C. Morgan, “Abstraction, Refinement and Proof for Probabilistic Systems,” Springer, 2004.
Milner, R., “Communication and Concurrency,” International Series in Computer Science, Prentice Hall, 1989.
Object Management Group, “UML Superstructure Specification, v2.0 formal/05-07-04,” (2005).
URL  http://www.omg.org/cgi-bin/doc?formal/05-07-04

Refsdal, A., R. K. Runde and K. Stølen, Underspecification, inherent nondeterminism and probability in sequence diagrams., in: R. Gorrieri and H. Wehrheim, editors, FMOODS, LNCS 4037 (2006), pp. 138–155.
A. W. Roscoe. Theory and Practice of Concurrency. Prentice Hall, 1997.
Rumpe, B., “Formale Methodik des Entwurfs verteilter objektorientierter Systeme,” TUM Doktorarbeit, Technische Universit¨at Mu¨nchen (1996).
Segala, R., Probability and nondeterminism in operational models of concurrency., in: C. Baier and
H. Hermanns, editors, CONCUR, LNCS 4137 (2006), pp. 64–78.
Shoham, S. and O. Grumberg, Monotonic abstraction-refinement for CTL, in: K. Jensen and
A. Podelski, editors, TACAS, LNCS 2988 (2004), pp. 546–560.
Shoham, S. and O. Grumberg, 3-valued abstraction: More precision at less cost., in: LICS (2006), pp. 399–410.
von der Beeck, M., A structured operational semantics for UML-statecharts, Software and System Modeling 1 (2002), pp. 130–141.
Wilke, Th., Alternating tree automata, parity games, and modal μ-calculus, Bull. Soc. Math. Belg. 8
(2001), pp. 359–391.
