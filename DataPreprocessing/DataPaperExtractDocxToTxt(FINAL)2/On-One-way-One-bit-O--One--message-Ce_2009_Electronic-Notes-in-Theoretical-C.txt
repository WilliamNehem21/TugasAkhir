

Electronic Notes in Theoretical Computer Science 252 (2009) 77–91
www.elsevier.com/locate/entcs


On One-way One-bit O(One)-message Cellular Automata
Martin Kutrib1 and Andreas Malcher2
Institut fu¨r Informatik, Universita¨t Giessen Arndtstr. 2, 35392 Giessen, Germany

Abstract
Cellular automata are one-dimensional arrays of interconnected interacting finite automata, also called cells. Here, we investigate one of the weakest class of cellular automata, namely the class of real-time one-way cellular automata. Additionally, we impose two restrictions on the inter-cell communication. First, the number of allowed uses of the links between cells is bounded. Moreover, the amount of information to be communicated in one time step is bounded by a constant being independent from the given automaton. In the weakest case, we consider cellular automata with one-way information flow where each cell receives one bit of information exactly once. In this case, we obtain a characterization of the regular languages for unary alphabets and the acceptance of non-context-free languages for non-unary alphabets. Next, a proper language hierarchy can be derived when increasing the number of allowed uses of the links between cells step by step. Finally, decidability problems of these restricted cellular automata are studied and undecidability of almost all problems can be proven even in the most restricted case of one-way one-bit communication.
Keywords: cellular automata, limited communication, formal languages, decidability.


Introduction
Devices of homogeneous, interconnected, parallel acting automata have widely been investigated from a computational capacity point of view. In particular, many results are known about cellular automata (see, for example, the surveys [1,2]) which are linear arrays of identical copies of deterministic finite automata, where the single nodes, which are sometimes called cells, are homogeneously connected to their both immediate neighbors. Additionally, they work synchronously at discrete time steps.
Clearly, the computational power of systems of parallel acting automata, here cellular automata, relies on the ability of the system to communicate information between single automata within given time and space constraints. Thus, it is es- sential to know how communication should be organized in order to employ cellular

1 Email: kutrib@informatik.uni-giessen.de
2 Email: malcher@informatik.uni-giessen.de

1571-0661 © 2009 Published by Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.09.015

automata optimally. Additionally, it would be interesting to understand in which way the number of communications as well as the amount of information commu- nicated can be minimized or at least reduced.
Considering the (unrestricted) model of cellular automata, the state of each cell is communicated to its neighbors in every time step. That is, on the one hand the state is sent regardless of whether it is really required, and on the other hand, the number of bits sent is determined by the number of states. Much work has been done in studying restricted variants of cellular automata where the bandwidth of the communication links between two cells is bounded by some fixed constant. In the most restricted setting, only one bit of information is allowed to be communicated between two cells in one time step. However, despite their reduced communica- tion these cellular automata are still powerful enough to accept unary as well as non-unary non-context-free (even non-semilinear) languages. For some classes it is additionally known that almost all of the commonly investigated decidability problems are undecidable. Results may be found in [3,4,8,9,10,13].
Another resource restricted in order to study the power of communication has been investigated in [11,12]. There, two-way cellular automata are considered where the number of proper state changes is bounded. There are strong relations to inter- cell communication. Roughly speaking, a cell can remember the states received from its neighbors. As long as these do not change, no communication is neces- sary. In [5,6] real-time one-way cellular automata have been studied where the communication is quantitatively measured by counting the number of uses of the communication links between cells. One measure studied is the maximal number of communications that may appear between each two cells. Reducing the number of communications in such a way that each two neighboring cells may communicate constantly often only, leads to devices which still can accept non-context-free (even non-semilinear) languages. Again, almost all of their decidability questions can be shown to be undecidable.
In this paper, we combine these two approaches and study real-time one-way cellular automata which are allowed to communicate only a fixed, finite number of bits per time step. Additionally, the communication links between two cells are allowed to be used constantly often only. In the most restricted case, we consider real-time one-way cellular automata which can communicate one bit of information between two cells exactly once.
In the next section, we present some basic notions and definitions, and introduce the classes of communication bounded cellular automata with respect to the band- width of the communication links as well as to the number of uses of these links. In Section 3, we show that the restriction to one bit and one communication is so strong that the regular languages can be characterized by these devices in the unary case. However, in the non-unary case non-regular languages can be accepted with two communications per cell. Next, a proper hierarchy on the number of communi- cation steps is shown. That is, even in the setting of one-bit communication, devices with l communications are more powerful than devices with l − 1 communications. Section 4 concerns decidability problems. First, we show a lemma which relates

languages accepted by real-time one-way cellular automata with a constant number of communications with languages accepted by real-time one-way cellular automata with a constant number of communications and one-bit communication. In this way, undecidability results for the cellular automata in question can be derived from known undecidability results.

Definitions and preliminaries
We denote the positive integers and zero {0, 1, 2, ...} by N. The empty word is denoted by λ, the reversal of a word w by wR, and for the length of w we write |w|. For the number of occurrences of a subword x in w we use the notation |w|x. We use ⊆ for inclusions and ⊂ for strict inclusions. In order to avoid technical overloading in writing, two languages L and L' are considered to be equal, if they differ at most by the empty word, i.e., L − {λ} = L' − {λ}. Throughout the article two devices are said to be equivalent if and only if they accept the same language. A one-way cellular automaton is a linear array of identical deterministic finite state machines, sometimes called cells. Except for the rightmost cell each one is connected to its nearest neighbor to the right. We identify the cells by positive integers. The state transition depends on the current state of each cell and on the information which is currently sent by its neighbor. The information sent by a cell depends on its current state and is determined by so-called communication functions. The rightmost cell receives information associated with a boundary sym- bol on its free input line once during the first time step from the outside world.
Subsequently, these input line is never used again. A formal definition is
Definition 2.1 A  one-way  cellular  automaton  (OCA)  is  a  system
⟨S, F, A, B, #, bl, δ⟩, where S is the finite, nonempty set of cell states, F ⊆ S is the set of accepting states, A ⊆ S is the nonempty set of input symbols, B is the set of communication symbols, # ∈/ S is the boundary symbol, bl : (S∪{#}) → B∪{⊥} is the communication function which determines the information to be sent to the left neighbor, where ⊥ means nothing to send, and δ : S × (B ∪ {⊥}) → S is the local transition function.
A conﬁguration of a one-way cellular automaton ⟨S, F, A, B, #, bl, δ⟩ at time t ≥ 0 is a description of its global state, which is actually a mapping ct : {1, 2,... , n}→ S, for n ≥ 1. The operation starts at time 0 in a so-called initial conﬁguration. For a given input w = a1 ··· an ∈ A+ we set c0,w(i) = ai, for 1 ≤ i ≤ n. During the course of its computation an OCA steps through a sequence of configurations, whereby successor configurations are computed according to the global transition function Δ: Let ct, t ≥ 0, be a configuration. Then its successor configuration ct+1 = Δ(ct) is as follows. For 1 ≤ i ≤ n − 1, ct+1(i) = δ(ct(i), bl(ct(i + 1))), and for the rightmost cell we set c1(n)= δ(c0(n), bl(#)), ct+1(n)= δ(ct(n), ⊥), for t ≥ 1. Thus, the global transition function Δ is induced by δ, and the flow of information is one-way from right to left.
An input w is accepted by an OCA M if at some time i during its course of

computation the leftmost cell enters an accepting state. The language accepted by M is denoted by L(M). Let t : N → N, t(n) ≥ n, be a mapping. If all w ∈ L(M) are accepted with at most t(|w|) time steps, then M is said to be of time complexity t. In the sequel we are particularly interested in OCAs having weak resources. So, we call the time complexity t(n)= n real time.
In the following, we study the impact of communication in one-way cellular automata. In general, at every time step each link between two cells can be used to send information, and the communication function bl can be chosen to be the identity mapping. Here, we limit the bandwidth of the links between the cells, that is, we bound the number of communication symbols by some constant being independent of the number of states. Furthermore, we measure the communication by the number of uses of the links between cells. It is understood that whenever a communication symbol not equal to ⊥ is sent, a communication takes place. More precisely, the number of communications between cell i + 1 and cell i up to time step t is defined by
com(i, t)= |{ j | 0 ≤ j < t and bl(cj(i + 1)) /= ⊥) }| .
For computations we now consider the maximal number of communications be- tween two cells. Let c0, c1,... , ct(|w|) be the sequence of configurations computed on input w by some cellular automaton with time complexity t(n), that is, the computation on w. Then we define
mcom(w)= max{ com(i, t(|w|)) | 1 ≤ i ≤ |w|− 1 }.
Let f : N → N be a mapping. If all w ∈ L(M) are accepted with computations where mcom(w) ≤ f (|w|), then M is said to be max message bounded by f. As mentioned before, we are particularly interested in OCAs having weak resources. Therefore, we restrict the communication drastically to one communication symbol and a constant max message bound. Clearly, the minimum is reached if we allow just one use of each link. We denote the class of OCAs which have at most k ≥ 1
communication symbols and which are max communication bounded by some con-

stant l ≥ 1 by MC(l)-OCAk. For 

l≥1
MC(l)-OCAk we write MC(O(1))-OCAk.

The family of all languages which are accepted by some device X in real time is
denoted by Lrt(X).

Computational capacity
Concerning the constant max communication bound, in [6] it has been shown that the family Lrt(MC(O(1))-OCA) contains the non-context-free languages
{ anan ··· an | n ≥ 1 }, { anbmcndm | n, m ≥ 1 }, as well as the languages
1 2	k
{ anw | n ≥ 1 ∧ w ∈ (b∗c∗)kb∗ ∧ |w|b = n }, for all constants k ≥ 0.	All of
···	#
Fig. 1. Initial configuration of a one-way cellular automaton.

these languages are either semilinear or non-bounded. But in contrast to many other computational devices, for example certain multi-head finite automata, par- allel communicating finite automata, certain parallel communicating grammar sys-
tems, MC(O(1))-OCAs can accept non-semilinear bounded languages, for example,
the language { anbn+[√n♩ | n ≥ 1 } as well as the language { a2n bnc2n+n | n ≥ 1 }
also belong to the family Lrt(MC(O(1))-OCA) [5].
Concerning the bound on the number of communication symbols, two-way cel- lular automata as well as cellular automata with sequential input mode, so-called iterative arrays, have been investigated in [3,4,9,10]. The computational capacity of linear-time one-way cellular automata has been considered in [13].
Next, we study real-time OCAs with minimal communication, that is, the family Lrt(MC(1)-OCA1). We start with a minimal input alphabet containing one symbol only. It is known that even unrestricted massively parallel real-time OCAs cannot accept more unary languages than a single deterministic finite-state machine [7]. The following result shows that, to this end, one communication symbol and one use of the links suffice.
Theorem 3.1 A unary language belongs to the family Lrt(MC(1)-OCA1) if and only if it is regular.
Proof. Trivially, Lrt(MC(1)-OCA1) is included in Lrt(OCA). Since every unary language belonging to Lrt(OCA) is regular [7], the only if part follows.
Now, let M be some deterministic finite-state machine with a single input sym- bol a, state set S, initial state s0, set of accepting states F , and transition func- tion δ : S × {a}→ S. We construct a language equivalent real-time MC(1)-OCA1 M' = ⟨S',F ', A', B', #, bl, δ'⟩ by S' = S ∪ Sˆ ∪ {a, q}, where Sˆ = { sˆ | s ∈ S } is a
copy of S, F ' = { sˆ | s ∈ F }, A' = {a}, B' = {1},
bl(x)= ⊥, for x ∈ {a, q}∪ S, bl(x)= 1, for x ∈ {#}∪ Sˆ,
and
δ'(a, ⊥)= δ(s0, a),
δ'(s, ⊥)= δ(s, a), for s ∈ S,
δ'(a, 1) = sˆ2, for δ(s0, a)= s2,
δ'(s1, 1) = sˆ2, for δ(s1, a)= s2 and s1 ∈ S, δ'(sˆ, ⊥)= q, for sˆ ∈ Sˆ,
δ'(q, ⊥)= q.
Basically, M' works as follows. During the first time step the rightmost cell receives the message 1 associated with the boundary symbol. Any cell simulates the finite state machine M until it receives the message 1 from its neighbor. When this happens, the cells simulate one more step of M, but now change to the corre-
sponding state of Sˆ. Subsequently, they enter the state q, which is a rejecting sink

state not sending any information. Since only states from Sˆ are sending a message, every cell communicates exactly once. The set of accepting states is defined to be the subset of Sˆ that corresponds to the accepting states of M. On input an the leftmost cell of M' enters a state from Sˆ once at time step n. It is an accepting state if and only if the finite-state machine M accepts the input an.	 
The previous result raises the question whether we can characterize or possibly capture the general regular languages by MC(l)-OCA1s, for some constant l. The next example reveals that one communication symbol and two messages per cell are sufficient to accept a non-regular language. On the other hand, it is shown in [3] that there are regular languages which are not accepted by any real-time CA with 1-bit communication. Thus, there are regular languages which cannot be accepted by any MC(O(1))-OCA1.
Example 3.2 We describe the computation of an MC(2)-OCA1 M on inputs of the form anbcm. The acceptance of the language is governed by two signals. During the first time step the rightmost cell receives the message 1 associated with the boundary symbol and identifies itself to be the rightmost cell. During the second time step the cell with input symbol b (b-cell) sends a message. In this way, the unique a-cell with right neighboring b-cell can identify itself. Subsequently, the a- cell sends the message 1 with speed 1/2, and the rightmost cell sends the message 1 with maximal speed to the left. So, the slow signal starts at time step 2 in the rightmost a-cell, takes 2n − 2 further time steps to reach the leftmost cell, and, thus stays at time steps 2n and 2n + 1 in the leftmost cell. The fast signal is set up at time step 1 and takes n + m further time steps to reach the leftmost cell. When both signals meet in a cell, that is, n + m +1 = 2n + 1, an accepting state is entered. Therefore, the leftmost cell accepts if and only if n = m. Moreover, each cell sends at most two messages, and can be set up to send no more messages even for inputs of another form.
Now assume that the language accepted by M is regular. Since regular languages are closed under intersection, so is the language L(M) ∩ a∗bc∗ = anbcn, which is non-regular but context free.	 
So, we know that MC(l)-OCA1s, for some constant l > 1, cannot character- ize the regular languages. The next two results show that, for any l ≥ 1, there are regular languages over a two-letter alphabet which are not accepted by any MC(l)-OCA1. Moreover, they reveal a tight infinite hierarchy of language classes dependent on the number of messages allowed to be sent by each cell. For all l ≥ 1, we consider the witness languages
Ll = { w | w ∈ {a, b}+ and |w|b ≥ l }.
Theorem 3.3 Let l ≥ 1 be a constant. Then language Ll does not belong to the family Lrt(MC(l − 1)-OCA1).
Proof. In contrast to the assertion, we assume that Ll is accepted by some real- time MC(l − 1)-OCA1 M with state set S.

First, let δ(a, bL(a)) = a1, δ(a1, bL(a1)) = a2, δ(a2, bL(a2)) = a3, and so on, and consider the sequence a, a1, a2,... The sequence becomes cyclic, say, after p time steps with a cycle length of q, that is, ap = ap+q. Clearly, the states in the cycle must not send messages, since otherwise the leftmost cell of input infixes ai with i ≥ p + lq would send at least l messages.
Second, for 1 ≤ i ≤ l, let wi = ar1 bar2 b ··· ari b, where

r1 = p + (l + 1)|S|l and
rj+1 = p + (l + 1)|S|r1+r2+···+rj+j+l.



For 1 ≤ j ≤ i, we are interested in the time steps at which the leftmost cell of the j-th sequence of adjacent a-cells in wi (the j-th a-block) cannot send a message. With an eye towards further reasoning we consider inputs of the form uiwi, where ui ∈ {a, b}l (cf. Fig. 2). The leftmost cell of the j-th a-block becomes cyclic at time step p. Since it does not send messages while in the cycle, it does not send messages at time steps tj with p ≤ tj ≤ rj −1. The b which follows the a-block could break the cycle at time rj. In particular, there are r1 + r2 + ··· + rj−1 + j − 1+ l cells on the left of the j-th a-block. Between time p and rj = p + (l + 1)|S|r1 +r2 +···+rj−1 +j−1+l the sequence of these cells evolves without receiving a message from the right. So, the computation of the entire sequence of cells becomes cyclic at time p + |S|r1 +r2+···+rj−1 +j−1+l, at the latest. Therefore, up to time rj the cycle has been passed through at least l times which, in turn, implies that in the cycle there may occur no communication at all. Again, the b which follows the j-th a-block could break the cycle at time rj + 1. Taking into account the arrival of a message sent by this b-cell, we derive that the leftmost a-cell of the j'-th a-block, for 1 ≤ j' ≤ j − 1, does not send messages at time steps p + |S|r1 +r2 +···+rj−1 +j−1+l ≤ tj' ≤ rj' +1 + rj'+1 +1+ ··· + rj − 1.
We conclude that the leftmost a-cell of the i-th a-block cannot send a message at time steps p,... , ri − 1, and, for 1 ≤ j < i, the leftmost a-cell of the j-th a-block cannot send a message at time steps

p,... , rj − 1,
p + |S|r1 +r2 +···+rj +j+l,... , rj +1 + rj+1 − 1,
p + |S|r1 +r2 +···+rj+1+j+1+l,... , rj +1 + rj+1 +1+ rj+2 − 1,
.
p + |S|r1 +r2 +···+ri−1 +i−1+l,... , rj +1 + rj+1 +1+ ··· + ri − 1.


In particular, there are i time periods after time p during which the leftmost a-cell of the first a-block can send messages. We denote this periods as sets of time steps

l	r1	r2
t  0
p
p + |S|l
r1 r1 + l
p + |S|r1+1+l


r2




r2 + r1 +1 
r2 + r1 +1+ l p + |S|r1+r2+2+l

r3




Fig. 2. Schematic space-time diagram of a computation on an input-prefix of uiwi. In gray-shaded regions there cannot be any communication. For example, the computations in the hatched regions are identical.
by:
T1 = {r1,... ,p + |S|r1 +1+l − 1}
T2 = {r1 +1+ r2,... ,p + |S|r1 +r2+2+l − 1}
.
r1+r2+···+ri−1+i−1+l
Ti−1 = {r1 + r2 + ··· + ri−1 + i − 2,... ,p + |S|	− 1}
Ti = {r1 + r2 + ··· + ri + i − 1, r1 + r2 + ··· + ri + i}

Next, we claim that the leftmost a-cell of the first a-block must send at least one message in each period Tj, 1 ≤ j ≤ i, which will prove the theorem by setting i = l. To this end, we fix the input prefixes ui to be bl−iai, and consider the inputs uiwi, for 1 ≤ i ≤ l. All these inputs belong to Ll and, thus, have to be accepted by M.
On input uiwi, the leftmost cell of M cannot enter an accepting state before time step l + r1 +1 + r2 +1 + ··· + ri. Otherwise the input uiar1 bar2 b ··· aria ∈/ Ll would

be accepted, too. The leftmost a-cell of the i-th a-block cannot send a message from time p to ri − 1. At the latter time all the l + r1 +1 + r2 +1 + ··· + ri−1 + 1 cells to its left run through cycles and do not send messages. So, in order to obey real time, the leftmost a-cell of the i-th a-block has to send a message at time ri or ri + 1. This message has to break the cycles of all the l + r1 +1 + r2 +1 + ··· + ri−1 + 1 cells to the left. It can arrive at the leftmost cell at time l + r1 + r2 + ··· + ri + i − 1 at the earliest and one time step later at the latest. So, the leftmost a-cell of the first a-block has to send a message at time r1 + r2 + ··· + ri + i − 1 at the earliest (say, this is case Ai) and one time step later at the latest (this is case Bi). Similarly, on an extended input of the form uiar1 bar2 b ··· ari+mb, for all m ≥ 1, the leftmost a-cell of the first a-block has to send a message at time r1 + r2 + ··· + ri + i − 1+ m or one time step later.
This already shows the claim for i = 1.
Now, assume that the claim is true for some i ≥ 1. Due to the deterministic behavior of M, we conclude that on input ui+1wi+1 the leftmost a-cell of the first a-block sends a message in each period T1,... , Ti−1. In addition, we know from above, that it sends a message in period Ti+1. In case Ai, we observe that the message sent in period Ti (on input uiwi) is independent of a possible right neighbor of the rightmost symbol b (it could be another symbol or the boundary). So, we obtain also a message in period Ti on input ui+1wi+1. This shows the claim for i +1 and case Ai.
Assume for a moment that for case Bi there is no message in period Ti on input ui+1wi+1. Depending on whether case Ai+1 or Bi+1 applies, the leftmost a-cell of the first a-block sends the period Ti+1 message at time r1 + r2 +··· + ri+1 + i or r1 + r2 +
··· + ri+1 + i+ 1. For case A(i+ 1) we consider the input ui+1ar1 bar2 b ··· ari+ri+1+1b, and for case B(i + 1) the input ui+1ar1 bar2 b ··· ari+ri+1+2b. Both inputs do not belong to Ll. According to the computation on the extended input for i, we obtain for m = ri+1 and m = ri+1 + 1 that the leftmost a-cell of the first a-block sends also a message at time r1 + r2 + ··· + ri+1 + i or r1 + r2 + ··· + ri+1 + i + 1. So, in any case a wrong input is accepted. The contradiction shows the claim for i +1 and case Bi and, thus, concludes the induction and the proof.	 

In order to derive the infinite tight hierarchy it remains to be shown that lan- guage Ll is accepted by some MC(l)-OCA1 in real time.

Theorem 3.4 Let l ≥ 1 be a constant. Then language Ll belongs to the family
Lrt(MC(l)-OCA1).

Proof. Basically, a real-time MC(l)-OCA1 M accepting Ll works as follows. Each cell with input symbol b sends a message to the left. Whenever a cell receives a message a finite internal counter is increased up to l, and the message is forwarded to the left. After having counted up to l a cell accepts and absorbs any further incoming message. More formally, let M = ⟨S, F, A, B, #, bL, δ⟩, where S = {a, b}∪ 

{0, 1,... , l}∪ {ˆ0, ˆ1,... , lˆ}, F = {l, lˆ}, A = {a, b}, B = {1},
bL(x)= ⊥, for x ∈ {a, b}∪ {0, 1,... , l},
bL(x)= 1, for x ∈ {#}∪ {ˆ0, ˆ1,... , lˆ},

and
δ(a, ⊥)= δ(a, 1) = 0,
δ(b, ⊥)= δ(b, 1) = ˆ1,
δ(i, ⊥)= δ(ˆi, ⊥)= i, for 0 ≤ i < l, δ(i, 1) = δ(ˆi, 1) = i^+ 1, for 0 ≤ i < l, δ(l, ⊥)= δ(lˆ, ⊥)= l,
δ(l, 1) = δ(lˆ, 1) = l.

States with a hat send messages. During the first time step the internal counters are initialized and the b-cells change to a state that sends a message. The message associated with the boundary symbol is ignored. Roughly speaking, the counters indicate how many symbols b a cell is aware of. So, the counters of the b-cells are initialized with 1. Moreover, cells that are aware of l symbols b accept and ignore further messages from the right. Since a cell sends a message if and only if its counter is increased, any cell sends at most l messages.	 

Decidability problems
This section is devoted to investigating decidability problems. Despite their sparse communication even for the structurally weak real-time MC(O(1))-OCAs several problems are known to be undecidable. These results have been obtained in [6] by reduction of Hilbert’s tenth problem. Interestingly, the same is true if one trades bounded languages for a number of communications that is at least logarithmic in the length of the input [5]. Here we derive that the problems remain undecidable even for devices with drastically reduced communications, that is, each two neigh- boring cells may communicate constantly often only where, in addition, the set of communication symbols is reduced to a singleton. Needless to say, the undecidabil- ity carries over to all the other stronger devices.
Lemma 4.1 Let M = ⟨S, F, A, B, #, bL, δ⟩ be a real-time MC(O(1))-OCA and $ /∈ A
be a new symbol. Then a real-time MC(O(1))-OCA1 M' accepting the language
{w$(|B|+2)(|w|+1)v | v ∈ {$, A(A ∪ {$})∗},w ∈ L(M)} can effectively be constructed.
Proof. The main task of the construction is to cut down the communication be- tween each two cells to one bit in every time step. Obviously, the given OCA M may communicate one symbol from B ∪ {⊥} between each two cells in every time step. Thus, the principal idea of the construction is to insert a certain number of new symbols for each input symbol at the end of the input and to use these new

symbols, that is, the additional time provided by them, to encode the information to be sent.
First, we observe that M can be modified by introducing an additional time step such that in the first time step no communication takes place but the com- munication associated with the boundary symbol. Moreover, we may assume that the communication symbol associated with the boundary symbol is a new unique one, say b#. Next, we add m = |B| +2 symbols $ for each input symbol and the boundary symbol. We encode B ∪ {⊥, b#} by the following function γ. Let B = {b1, b2,... , b|B|}. Then γ(⊥) = 0m, γ(b#) = 1m, and γ(bi) = 10i10m−i−2, for i = 1, 2,... , |B|.
Let M' = ⟨S',F ',A ∪ {$}, B', #, b'L, δ'⟩ be an OCA where B' consists of the sole element 1 only. We start by considering inputs of the form w$m(|w|+1)$, where w ∈ A+, that is, v = $. In the first time step the only communication is the one associated with the boundary symbol. The remaining cells are not communicating. In this way, the rightmost $-cell can identify itself. In each of the next m time steps every $-cell but the rightmost one sends a 1 to its left neighbor as long as itself receives a 1 from its right neighbor. Since the rightmost $-cell does not communicate
at time step 1, the (m + 1)st $-cell from the right does not receive a 1 at time m. In the next time step, this cell starts a signal C by sending a 1 to its left neighbor which is forwarded with maximal speed to the left by all other $-cells. It should be remarked that by setting up an internal counter every cell can identify the (m + 1)st time step.
The cells carrying an input symbol from the set A do not communicate in the first m + 1 time steps. (Due to the above modification of the given OCA M this will not cause any delay.) The |w|-th cell from the left receives the encoding γ(b#)= 1m during the time steps 2, 3,... ,m+1, and can simulate one step of M suitably. After the (m + 1)st time step, the leftmost |w| cells simulate the computation of M by sending the encodings of the communication symbols in m time steps, whereby a 1 is sent for a 1, and nothing is sent for a 0. With an eye towards checking the correct number of $ symbols we provide an additional time step m + 1.
In addition to the simulation, a signal D with speed 1/(m + 1) is started in the
|w|-th cell at time 2(m + 1). In order to realize a signal with that speed, an internal counter is increased at every time step. When the counter reaches m+1, a message 1 is sent to the left neighboring cell which now starts a counting up to m + 1, and so on. The signal D reaches the leftmost cell at time 2(m + 1)+ (|w|− 1)(m + 1) = (|w|+1)(m+1). The signal D cannot interfere with with sending encodings, because the latter are sent at every time steps 1, 2,... ,m and the former is sent at most at time steps m + 1. Since M obeys real time plus one time step, every cell which has been passed by D can be obliged to stop its simulation of M. It now forwards any incoming 1 to the left.
Let us come back to the $-cells. The (m + 1)st $-cell from the right has started the signal C at time (m + 1). This signal reaches the |w|-th cell at time step m(|w| + 1) + 2 and is forwarded to the left by the remaining cells. Thus, it reaches the leftmost cell at time step m(|w| + 1)+2+ |w|− 1= (m + 1)(|w| + 1), that is,

at the same time step at which signal D reaches the cell. In this case, the input is accepted if the cell, in addition, simulates an accepting state of M. See Fig. 3 for a schematic computation.
Next, we want to show that M' performs only a constant number of communi- cations between each two cells. To this end, we observe that each cell communicates at most m messages during the first m + 1 time steps. Due to the encoding chosen, every communication symbol of M requires to send two messages in M'. Finally, the signal D as well as the signal C each cause one additional communication step per cell. Altogether, M' is a real-time MC(O(1))-OCA1.
Concerning the accepted inputs we know that an input is accepted if and only if the signals C and D meet in the leftmost cell, which simulates an accepting state of M. The simulation of M can only be accepting if initially the encoding of the unique symbol b# is communicated. This, in turn, can only be done by a $-cell. So, any accepted input starts with a prefix w ∈ L(M) followed by a number of $- symbols. Moreover, since the signal C has to arrive in due time, it has to be set up appropriately. Since in the first m+1 time steps A-cells do not communicate whereas all $-cells try to send the encoding 1m, all but the rightmost of the number of $-cells send at least one message. Thus, all but the rightmost $-cell can identify an A-cell to the right within the first m + 1 time steps and then block the computation. So, any accepted input is either of the form w$m(|w|+1)$ or w$m(|w|+1)xu, where w ∈ L(M), x ∈ A, and u ∈ A(A ∪ {$})∗. Conversely, every input of one of these forms in accepted.	 
It is straightforward to generalize this construction for cellular automata with two-way communication. Furthermore, since the construction increases the number of communication steps per cell only linearly, it is easy to see that the construction
0	#
1
2
3
4
5
. 9
. 14
.
19
20
Fig. 3. Schematic simulation of an MC(O(1))-OCA	with B = 2 on input s1s2s3, which evolves in its relevant part in the next time steps to s1s2s' , s4s5s6, s7s8, and s9 at time steps 5, 9, 14, 19. At time step 20

an accepting state of M'
3
is entered if the simulated state s9 is an accepting state in M.

also works for SC(f )-CAs and MC(f )-CAs where f is not necessarily a constant function. Here SC(f )-CA denotes the class of cellular automata whose total num- ber of communications (appearing anywhere in the array) during a computation is bounded by f . For a proper definition of these models we would like to refer to [6,5]. Now, we can use Lemma 4.1 to reduce the undecidability problems for
MC(O(1))-OCAs shown in [6] to MC(O(1))-OCA1.
Theorem 4.2 Given an arbitrary real-time MC(O(1))-OCA1 M, it is undecidable whether L(M) is empty.
Proof. The main idea to prove the undecidability of the emptiness problem in [6] is to construct a real-time MC(O(1))-OCA M which accepts a certain language L(p). From this fact the emptiness of L(p) can be related to the non-existence of solutions for Hilbert’s tenth problem whose known undecidability implies the undecidability of emptiness for real-time MC(O(1))-OCAs.
By Lemma 4.1 we can construct a real-time MC(O(1))-OCA1 M' for a given real-time MC(O(1))-OCA M over the alphabet A which accepts the language
L(M')= {w$m(|w|+1)v | v ∈ {$, A(A ∪ {$})∗},w ∈ L(M)}
for a suitable m depending on M. Since L(M) is empty if and only if L(M') is empty, we obtain the undecidability of emptiness for real-time MC(O(1))-OCA1s. 
Theorem 4.3 Emptiness, ﬁniteness, inﬁniteness, equivalence, inclusion, regular- ity, and context-freedom are undecidable for arbitrary real-time MC(O(1))-OCAks with k ≥ 1.
Proof. It is sufficient to show all claims for k = 1. At first, we show that the undecidability of emptiness implies the undecidability of inclusion and equivalence as well. Let M be an arbitrary real-time MC(O(1))-OCA1 and M' be a real-time MC(O(1))-OCA1 accepting the empty language. If we could decide the inclusion or equivalence of M and M', we could decide the emptiness of M as well which is a contradiction to Theorem 4.2.
Next, by using Lemma 4.1 we construct a real-time MC(O(1))-OCA1 M' for a given real-time MC(O(1))-OCA M over the alphabet A which accepts the lan- guage L(M') = {w$m(|w|+1)v | v ∈ {$, A(A ∪ {$})∗},w ∈ L(M)} for a suit- able m depending on M.  Since L(M') is finite (infinite) if and only if L(M') is empty (non-empty), we obtain the undecidability of finiteness and infiniteness for real-time MC(O(1))-OCA1s from the undecidability of emptiness for real-time MC(O(1))-OCAs shown in [6].
We turn to show that L(M') is regular if and only if L(M) is finite. Clearly, L(M') is regular, if L(M) is finite. To obtain that L(M') is not regular if L(M) is infinite, we assume that L(M') is regular. Then, the intersection of L(M') with the regular language A∗$∗ gives the regular language L'(M')= {w$m(|w|+1)+1 | w ∈ L(M)}. By an obvious application of the pumping lemma for regular languages, we can show that L'(M') is not regular. This gives the contradiction and shows the undecidability of regularity.

Finally, let M1 be an arbitrary real-time MC(O(1))-OCA accepting a language over some alphabet A. It is not difficult to construct a real-time MC(O(1))-OCA M2 accepting the language {w¢|w| | w ∈ M1} where ¢ /∈ A. By using Lemma 4.1 we can construct a real-time MC(O(1))-OCA1 M' which accepts the language
L(M')= {w¢|w|$m(2|w|+1)v | v ∈ {$, (A ∪ {¢})(A ∪ {¢, $})∗},w ∈ L(M1)}
for a suitable constant m. If L(M1) is finite, then L(M') is regular and, thus, context free. Next, we want to show that L(M') is not context free, if L(M1) is infinite. By way of contradiction, we assume that L(M') is context free. Then the intersection of L(M') with the regular language A∗¢∗$∗ gives the context-free language L'(M') = {w¢|w|$m(2|w|+1)+1 | w ∈ L(M1)}. By an obvious application of the pumping lemma for context-free languages, one can show that L'(M') is not context free. This gives the contradiction and shows that L(M1) is finite if and only if L(M') is context free. In this way, we obtain the undecidability of testing context-freedom for real-time MC(O(1))-OCA1s from the undecidability of finiteness for real-time MC(O(1))-OCAs shown in [6].	 
Clearly, the undecidability carries over to, for example, MC(O(1))-CAk with two- way communication and the models SC(O(n))-OCAk and SC(O(n))-CAk having a different measure on the number of communications (cf. [6,5]). In particular, the following corollary shows the undecidability of almost all decidability problems for k-bit one-way cellular automata studied in [13].
Corollary 4.4 Emptiness, ﬁniteness, inﬁniteness, equivalence, inclusion, regular- ity, and context-freedom are undecidable for arbitrary real-time OCAks with k ≥ 1.

References
Kutrib, M., Cellular automata – a computational point of view, in: New Developments in Formal Languages and Applications, Springer, 2008 pp. 183–227.
Kutrib, M., Cellular automata and language theory, in: Encyclopedia of Complexity and System Science, Springer, 2009 in press.
Kutrib, M. and A. Malcher, Fast cellular automata with restricted inter-cell communication: Computational capacity, in: Theoretical Computer Science (IFIP TCS2006), IFIP 209 (2006), pp. 151– 164.
Kutrib, M. and A. Malcher, Fast iterative arrays with restricted inter-cell communication: Constructions and decidability, in: Mathematical Foundations of Computer Science (MFCS 2006), LNCS 4162 (2006), pp. 634–645.
Kutrib, M. and A. Malcher, Bounded languages meet cellular automata with sparse communication, in:
Descriptional Complexity of Formal Systems (DCFS 2009), 2009.
Kutrib, M. and A. Malcher, Cellular automata with sparse communication, in: Implementation and Application of Automata (CIAA 2009), LNCS 5642 (2009), pp. 34–43.
Seidel, S. R., Language recognition and the synchronization of cellular automata, Technical Report 79-02, Department of Computer Science, University of Iowa, Iowa City (1979).
Umeo, H., Linear-time recognition of connectivity of binary images on 1-bit inter-cell communication cellular automaton, Parallel Comput. 27 (2001), pp. 587–599.


Umeo, H. and N. Kamikawa, A design of real-time non-regular sequence generation algorithms and their implementations on cellular automata with 1-bit inter-cell communications, Fund. Inform. 52 (2002), pp. 257–275.
Umeo, H. and N. Kamikawa, Real-time generation of primes by a 1-bit-communication cellular automaton, Fund. Inform. 58 (2003), pp. 421–435.
Vollmar, R., On cellular automata with a finite number of state changes, Computing 3 (1981), pp. 181– 191.
Vollmar, R., Some remarks about the ‘efficiency’ of polyautomata, Internat. J. Theoret. Phys. 21 (1982),
pp. 1007–1015.
Worsch, T., Linear time language recognition on cellular automata with restricted communication, in:
LATIN 2000: Theoretical Informatics, LNCS 1776 (2000), pp. 417–426.
