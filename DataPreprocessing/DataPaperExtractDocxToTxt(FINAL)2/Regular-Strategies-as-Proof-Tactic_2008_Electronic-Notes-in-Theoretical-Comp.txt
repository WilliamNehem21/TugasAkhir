Electronic Notes in Theoretical Computer Science 204 (2008) 83–98	
www.elsevier.com/locate/entcs

Regular Strategies as Proof Tactics for CIRC
Dorel Lucanu1 ,3
Faculty of Computer Science Alexandru Ioan Cuza University Ia¸si, Romania
Grigore Ro¸su2 ,4
Department of Computer Science University of Illinois
Urbana-Champaign, USA
Gheorghe Grigora¸s1 ,5
Faculty of Computer Science Alexandru Ioan Cuza University Ia¸si, Romania

Abstract
CIRC is an automated circular coinductive prover implemented as an extension of Maude. The main engine of CIRC consists of a set of rewriting rules implementing the circularity principle. The power of the prover can be increased by adding new capabilities implemented also by rewriting rules. In this paper we prove the correctness of the coinductive prover and show how rewriting strategies, expressed as regular expressions, can be used for specifying proof tactics for CIRC. We illustrate the strength of the method by defining a proof tactic combining the circular coinduction with a particular form of simplification for proving the equivalence of context-free processes.
Keywords: Behavioral equivalence, circular coinduction, regular strategies, proof tactics


Introduction
A behavioral algebraic specification is an algebraic specification where the sorts are split into visible (or observational) for data and hidden for states, and the

1 Partially supported by CEEX grant 47/2005 and CNCSIS grant 1162/2007.
2 Partially supported by NSF grants CCF-0448501 and CNS-0509321.
3 Email: dlucanu@info.uaic.ro
4 Email: grosu@cs.uiuc.edu
5 Email: grigoras@info.uaic.ro

1571-0661 © 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.03.055

equality is behavioral. Two states are behaviorally equivalent if and only if they appear to be the same under any visible experiment. The experiments are de- rived operations of visible result sort, and defined only with behavioral operations (derivatives). A canonical example is that of (infinite) streams. The sort Stream of streams is hidden, the sort of elements, e.g. Int, is visible, and the behavioral operations are the head hd(*:Stream) and the tail tl(*:Stream). The special vari- able *:Stream marks the place of the state parameter. Examples of experiments are hd(*:Stream), hd(tl(*:Stream)), hd(tl(tl(*:Stream))), and so on. The behavioral equivalence (equality) over streams is given by S ≡ S' iff hd(S)= hd(S') and tl(S) ≡ tl(S'). If this is the case, then all the above experiments return the same visible data value for S and S', respectively. Note that the behavioral equiv- alence coincides with the equality over the visible data. Therefore the behavioral equivalence over streams requires as the values returned by the head operation to be equal.
The main issue in behavioral specification theory is how to prove that two states are behavioral equivalent. The coalgebraic bisimulation (see, e.g., Jacobs and Rut- ten [10]) as well as Hennicker’s context induction [7] are both sound proof techniques for behavioral equivalence. Unfortunately, both of them need human intervention: coinduction to pick a “good” bisimulation relation, and context induction to device and prove auxiliary lemmas. Circular coinduction [4,14] is an automatic proof tech- nique for behavioral equivalence, supported in BOBJ. By circular coinduction one can prove, for instance, the equality zip(zeros, ones) = blink on streams as follows (zeros is the stream 0ω, ones is 1ω, blink is (01)ω, zip merges two streams):
check that the two streams have the same head, 0;
take the tail of the two streams and generate the new goal zip(ones, zeros) = 
1 blink; this becomes the next task;
check that the two new streams have the same head, 1;
take the tail of the two new streams; after simplification one gets the new goal
zip(zeros, ones)= blink, which is nothing but the original proof task;
conclude that zip(zeros, ones)= blink holds.
The intuition for the above “proof” is that the two streams have been exhaustively tried to be distinguished by iteratively checking their heads and taking their tails. Ending up in circles (we obtained the same new proof task as the original one) means that the two streams are indistinguishable, i.e., they are equal.
Circular coinduction can be explained and proved to be correct by reducing it to either bisimulation or context induction: it iteratively constructs a bisimulation, but it also discovers all lemmas needed by a context induction proof. Since the behavioral equivalence problem is Π0-complete [14] (it is so, even in the context of just streams [15]), there is no algorithm or proof system that is complete for behavioral equality in general, as well as no algorithm or proof system that is complete for inequality of streams. Therefore, the best we can do is to focus our efforts on exploring heuristics or deduction rules to prove or disprove equalities of streams that work well on examples of interest rather than in general.

BOBJ [4,14] was the first system supporting circular coinduction. Hausmann, Mossakowski, and Schro¨der [6] also developed circular coinductive techniques and tactics in the context of CoCASL. CIRC [12,11] is an automated circular coinduc- tive prover implemented in Full Maude [3] as a behavioral extension of the Maude system [2], making heavy use of meta-level and reflection capabilities of rewriting logic. Maude is by now a very mature system, with many uses, a high-performance rewrite engine and a broad spectrum of analysis tools. Maude’s current meta-level capabilities where not available when we developed the BOBJ system; consequently, BOBJ was a heavy system, with rather poor parsing and performance. By allow- ing the entire Maude system visible to the user, CIRC inherits all Maude’s uses, performance and analysis tools. CIRC implements the circularity principle, which generalizes circular coinductive deduction [5] and can be expressed as follows. As- sume that each equation of interest (to be proved) e admits a frozen form fr(e) and a set of derived equations, its derivatives, Der (e). The circularity principle says that if from hypotheses H together with fr (e) we can deduce Der (e), then e is a consequence of H. When fr (e) freezes the equation at the top, as in [5], the cir- cularity principle becomes circular coinduction. Interestingly, when the equation is frozen at the bottom on a variable, then it becomes a structural induction (on that variable) derivation rule. This way, CIRC supports both coinduction and induction as projections of a more general principle. This paper makes two main contribu- tions. First, we prove the correctness of CIRC’s coinductive capabilities. Second, we define and implement a strategy language for CIRC.
Version 1.2 of CIRC [11] provides automatic proving support for both coinduc- tion and induction, but not for combinations of them. A combination of the two techniques is possible only in an assisted way. In practice, there are many cases when the two must be combined with other techniques. CIRC’s proof capabilities are implemented using rewriting rules. A proof tactic constraints the application of rules according to a given aim. To express the proof tactics, we use a strategy language based on regular expressions over rule labels. Regular expressions can be behaviorally specified; CIRC includes a copy of this specification to handle the proof tactics. This new feature is included CIRC v1.3. We illustrate it by defining a proof tactic able to prove the equivalence of context-free processes.
The paper is structured as follows. Section 2 introduces behavioral specification and presents the coinductive capabilities of the CIRC, and shows the correctness of implementation of the circular coinduction as rewriting rules. We use the reg- ular expressions as an example of behavioral specification and we show that CIRC together with this specification supplies a fully automatic decision procedure for the equivalence of regular expressions. Section 3 introduces the regular strategies and defines proof tactics in terms of regular strategies. A proof tactic that com- bines coinduction with simplification of goals is presented. Section 4 shows how context-free processes can be behaviorally specified and presents a proof technique, based on coinduction and simplification, for proving the equivalence of context-free processes. The paper ends with concluding remarks.

Behavioral Algebraic Specifications
Let Σ be an algebraic signature consisting of a set Sorts (Σ) of sorts and an S∗×S- indexed set Op(Σ) = (Op(Σ)w,s | w ∈ S∗,s ∈ S) of operations. We assume Sorts (Σ) = V ∪ H, where V is a subset of visible sorts, H is a subset of hidden sorts, and V ∩ H = ∅. For each f ∈ Op(Σ)w,s, we use the following notations: arity (f )= w, sort (f )= s, and type (f )= (w, s) (also written w → s). Let X be a fixed S-indexed set of variables. TΣ(X ) is the Σ-algebra of terms with variables in
X . Let Var (t) denote the set of variables occurring in term t. A Σ-behavioral oper- ation for hidden sort h ∈ H, also called a derivative, is a term δ ∈ TΣ(X ∪ {∗:h}), where ∗:h is a special variable of sort h. The sort of δ is called δ’s result sort. A Σ-equation is a sentence (∀X) t = t' if c, where t and t' are Σ-terms over variables X ⊆ X having the same result sort, and c is the condition of the equation consisting of a finite set of pairs (ti, t') of terms over variables X and with visible result sorts; we only consider equations with finitely many visible conditions in this paper. A
condition c is also written as t1 = t' ∧ ··· ∧ tn = t' . If the sorts of t and t' are
hidden, then the equation is called behavioral. If the condition c is empty, then we get an unconditional Σ-equation and write it as (∀X) t = t'.
A behavioral speciﬁcation is a triple B = (Σ, Δ, E), where Σ is an algebraic signature, Δ is a set of behavioral operations, and E is a set of Σ-equations. Let
=E denote the standard equational derivability congruence over TΣ(X ) with the equations E (the E-equality), and let TΣ,E(X ) denote the quotient TΣ(X )/=E. A Δ-experiment for the hidden sort h ∈ H is inductively defined as follows: each behavioral operation for the hidden sort h ∈ H with visible result sort is a Δ- experiment for h; if γ is a Δ-experiment for h' and δ a behavioral operation for h with result sort h', then γ[δ/∗:h'] is a Δ-experiment for h.
The notion of behavioral equivalence is an inherently semantic one: there is a behavioral equivalence relation on each model which can be defined as “indistin- guishability under experiments”. For technical simplicity, we here prefer to avoid introducing models, so we give an alternative, proof theoretic definition. The Δ- behavioral equivalence ≡Δ over TΣ(X ) is the E-equality (closure under equational deduction with E) generated by the following: for each visible sort v ∈ V , ≡Δ,v is
=E,v; if h ∈ H and t, t' ∈ TΣ(X )h then t ≡Δ t' iff γ[t/∗:h] =E γ[t'/∗:h] for each Δ-experiment γ for h. (We here therefore assume that operations are behaviorally

congruent, i.e., f (t1,... , tn) ≡Δ f (t' ,... , t' ) whenever ti ≡Δ t'
for i = 1,... , n.)

1	n	i
We often write γ[t] for γ[t/∗:h]. Note that the relation ≡Δ is not algorithmic, be-
cause one needs an infinite number of experiments to decide it; the basis for the Π0 result in [14] is the observation that for each experiment there is some proof (thanks to the completeness of equational deduction). Moreover, the E-equality is undecidable for the general case. B behaviorally entails the behavioral Σ-equation e, written B |≡ e, iff
either e is of the form (∀X) t = t' (the condition is empty) and t ≡Δ t',

or e is of the form (∀X) t = t' if c with c consisting of t1 = t' ∧···∧tn = t'
and

1	n
'
B(c) |≡ (∀X) t = t , where B(c) is the behavioral specification (Σ ∪ X, Δ,E ∪

{(∀∅)ti = t' | i = 1,... , n}) (the variables in X are added as constants, then the condition is added as hypothesis).
The equational entailment is defined in a similar way: B |= e, iff
either e is of the form (∀X) t = t' and t =E t',
or e is of the form (∀X) t = t' if c and B(c) |= (∀∅) t = t'.

Example: Regular Expressions.
Regular expressions (RE) are finite presentations for possibly infinite languages. The languages denoted by REs are inductively defined using the operations union, concatenation, and Kleene closure. Formally, let Alph be an alphabet; the set of regular expressions over Alph is given by the grammar
R ::= ε | ∅ | a | R + R | R #R | R∗
where a ranges over Alph. The language denoted by a RE R is defined as follows:
L(ε) = {ε}, L(∅) = ∅, L(a) = {a}, L(R1 + R2) = L(R1) ∪ L(R2), L(R1#R2) = 
{ww' | w ∈ L(R1), w' ∈ L(R2)}, and L(R∗)= (L(R))∗. Two REs are equivalent iff they denote the same language. In [16,17] a behavioral specification for (Extended) REs is given, where the behavioral equivalence coincides with the RE equivalence. The behavioral operations (derivatives) defining behavioral equivalence are epsIn (testing the membership of ε to a RE) and { }, which takes a RE R and a letter a and returns an expression R{a} characterized by L(R{a}) = {w | aw ∈ L(R)}. R{a} is semantically equivalent to an RE because regular languages are closed under left-quotient by an arbitrary language. Here is a Maude description of REs:
(th RE is including BOOL .
sort Ere .	--- extended regular expressions
sort Alph .	--- the alphabet
ops a b : -> Alph .	--- the letters of the alphabet
vars R R1 R2 : Ere . vars A B : Alph .
op _‘{_‘} : Ere Alph -> Ere .	--- the letters derivatives
op epsIn_ : Ere -> Bool .	--- epsilon membership derivative
subsort Alph < Ere .	--- a letter eq epsIn A = false .
eq B { A } = if A == B then epsilon else empty fi .
op epsilon : -> Ere .	--- the empty word eq epsilon { A } = empty .
eq epsIn epsilon = true .
op empty : -> Ere .	--- the empty language eq empty { A } = empty .
eq epsIn empty = false .
op _#_ : Ere Ere -> Ere [assoc] .	--- concatenation ceq ( R1 # R2 ){ A } = ((R1 { A }) # R2) + (R2 { A })
if epsIn R1 = true .
ceq ( R1 # R2 ){ A } = (R1 { A }) # R2
if epsIn R1 = false .
eq epsIn ( R1 # R2 ) = epsIn R1 and epsIn R2 .
op _+_ : Ere Ere -> Ere [assoc comm] .	--- union

eq ( R1 + R2 ){ A } = (R1 { A }) + (R2 { A }) .
eq epsIn ( R1 + R2 ) = epsIn R1 or epsIn R2 .
op _* : Ere -> Ere .	--- star operator eq R * { A } = (R { A }) # (R *) .
eq epsIn R * = true .
--- simplifying equations eq empty + R = R .
eq R + R = R . 
eq empty # R = empty . eq epsilon # R = R .
endth)




Circular Coinduction
As mentioned in the introduction, CIRC implements the principle of circularity, which generalizes both structural induction and circular coinduction; we will dis- cuss this principle in depth elsewhere. We here focus on its coinductive instance. Circular coinduction [4,5,14], is a sound proof calculus for |≡, which can be defined as an instance of the circularity principle as follows: the “frozen” form of equation “(∀X) t = t' if c” is “(∀X)fr (t)= fr (t') if c”, where fr : sort (t) → new is a new operation and new is a new sort. The set Der Δ(e) is


{(∀X) fr (δ[t/∗:h]) = fr (δ[t'/∗:h]) if c | δ behavioral for h = sort(t)}.


The frozen operator ensures the sound use of the coinduction hypotheses. We take the liberty to also call fr(e) visible when e is visible, i.e., the left-hand side and right-hand side are terms of visible sorts.
In CIRC we use the standard rewriting-based semi-decision procedure to derive equations “(∀X) t = t' if c”: add the variables X as constants, then add the conditions in c to the set of equations, and then reduce t, t' to normal forms orienting all the equations into rewrite rules. In what follows we let E ▶ e denote the fact that e can be deduced from E using this standard approach (E is any set of equations). The inference relation ▶ is sound for |=, i.e., E ▶ e implies E |= e. We currently do not interfere with the rewriting procedure: if rewriting does not terminate during a proof session then CIRC does not terminate either. If we write E /▶ e then we mean “knowingly incapable of proving it”, that is, that the rewrite engine reduced the two terms to normal forms, but those are not equal. Obviously, this does not necessarily mean that the equation is not true.
CIRC implements circular coinduction as a nondeterministic procedure aiming at reducing a pair (E, fr(e)) to a pair (E , ∅), where E is the original set of equations in B and e is the equation to prove (the goal). If that is the case, then B |≡ e. While trying to do so, the procedure can also fail, in which case we conclude that it could

not prove B |≡ e, or it can run forever. Here are the reduction rules:
[EqRed] :
(E , G ∪ {fr(e)}) ⇒ (E , G)	if E ▶ fr(e) [CoindFail] :
(E , G ∪ {fr(e)}) ⇒ failure	if E /▶ fr(e) and e is visible [CCStep] :
(E , G ∪ {fr(e)}) ⇒ (E ∪ {nf(fr(e))}, G ∪ Der Δ(e)) if E /▶ fr(e) and e is hidden.
Let nf(e) denote the equation e where the left-hand and right-hand sides are re- duced to normal forms. [EqRed] removes a goal if it can be proved using ordinary equational reduction. [CoindFail] says that the procedure fails whenever it finds a visible goal which cannot be proved using ordinary equational reduction. Finally, [CCStep] implements the circularity principle: when a behavioral equation cannot be proved using ordinary equational reduction, its frozen form (or an equivalent variant of its frozen form, such as its normal form) is added to the specification and its derivatives are added to the set of goals.
Theorem 2.1 Let B = (Σ, Δ, E) be a behavioral speciﬁcation and let e be a Σ- equation such that (E, fr(e)) ⇒٨ (E , ∅) using the procedure above. Then B |≡ e.
The proof of Theorem 2.1 is based on the following two lemmas.
Lemma 2.2 If (Σ ∪ {fr }, Δ, E) |≡ fr (e), then (Σ, Δ, E) |≡ e.
Proof. We assume without lose the generality that e is an unconditional equation (∀X)t = t'. If γ is a Δ-experiment, then we have fr (γ[t]) =E fr (γ[t']) iff γ[t] =E γ[t'] by the definition of =E and by the fact that E does not include equations involving fr .	 
Lemma 2.3 Let E' be a set of equations obtained during the reduction (E, fr(e)) ⇒٨
(E , ∅) and let e' be a goal. If (Σ, Δ, E' ∪ {fr (e')}) |= Der Δ(e'), then (Σ, Δ, E') |≡ e'.
Proof. We assume again that e' is an unconditional equation (∀X)t = t'. Let < be the order over the experiments given by their depth. We show by Noetherian induction on < that γ[u] =E' γ[v], where u (resp. v) is θ(t) (resp. θ(t')), where θ is any substitution (possible the identity). Let γ be an appropriate experiment for t
'	'	'	'
(and t ). If γ[t]= γ[t ] is in Der Δ(e ), then we get γ[t] =E' γ[t ] by the hypothesis of
the lemma (fr (e') cannot be used in a derivation of γ[t]= γ[t']). Otherwise, there is a derivative δ ∈ Δ and an experiment γ' such that γ = γ'[δ] and δ[t] = δ[t']
'	'	'
in Der Δ(e ). If fr (δ[t]) =E'  fr (δ[t ]) (fr (e ) is not used in this derivation), then
fr (γ'[δ[t]]) =E' fr (γ'[δ[t']]) and hence γ[t] =E' γ[t']. If fr (e') is used in the derivation of fr (δ[t]) = fr (δ[t']), then there is a substitution θ such that fr (δ[t]) =E' fr (θ(t)) and
'	'	'	'	'	'
fr (δ[t ]) =E' fr (θ(t )). Since γ < γ, we have γ [θ(t)] =E' γ [θ(t )] by the inductive
hypothesis. Hence γ[t] =E' γ[t']. So, we get γ[t] =E' γ[t'] in both cases, which implies γ[θ(t)] =E' γ[θ(t')] for any substitution θ.	 
Corollary 2.4 If (Σ, Δ, E' ∪ {fr (e')}) |= G ∪ Der Δ(e'), then (Σ, Δ, E') |≡ G ∪ {e'}.

Proof of Theorem 2.1.
We proceed by induction on the number of applications of [CCStep]. If this rule is not applied, then (Σ, Δ,E ∪ {fr (e)}) |= Der Δ(e) and the conclusion of the theorem follows by Lemma 2.3. We assume that


(E, fr(e)) ⇒٨ (E', G' ∪{	' }) ⇒ (E' ∪{ 
' }, G' ∪
'	⇒٨ (E , ∅)

fr (e )
nf (fr (e ))
Der Δ(e ))

where the last reductions are given using only [EqRed]. Hence (Σ, Δ, E' ∪{fr (e')}) |= G' ∪ Der Δ(e'). It follows that (Σ, Δ, E') |≡ G' ∪ {e'} by the corollary of Lemma 2.3. The conclusion of Theorem 2.1 follows now applying the induction hypothesis. The successful termination of the CIRC procedure above, i.e., reaching of a con- figuration of the form (E', ∅), is not guaranteed. Let us consider, for instance, the addition of streams, behaviorally defined by hd (S + S') = hd (S)+ hd (S') and tl (S + S')= tl (S)+ tl (S'), and the (convolution) product of streams, behaviorally defined by hd (S × S')= hd (S) × hd (S') and tl (S × S')= tl (S) × S' + [hd (S)] × tl (S'), where [x] denotes the stream x0ω.	The execution of CIRC procedure for the input goal [0] × [0] = [0] produces an infinite process.	First [CCStep] is ap- plied, which replace the initial goal fr ([0] × [0]) = fr ([0]) with fr (hd ([0] × [0])) = fr (hd ([0])) and fr (tl ([0] × [0])) = fr (tl ([0])).	The former is solved by [EqRed] and the latter is reduced by [EqRed] to fr ([0] × [0] + [0] × [0]) = fr ([0]).	A new application of [CCStep] followed by [EqRed] (twice) will generate the goal fr ([0] × [0] + [0] × [0] + [0] × [0] + [0] × [0]) = fr ([0]). The process infinitely continues generating larger and larger goals. In Section 3 we extend CIRC with proof tactics
able to handle such cases.
Since the behavioral entailment problem is Π0-complete [14,15], we know that there can be no procedure to decide behavioral equalities or inequalities in general. The reaching of the configuration failure means a failing termination.
For regular expressions, we are in the happy case when CIRC together with the specification RE yield a fully automatic decision procedure for their equivalence:
Proposition 2.5 If one deﬁnes the behavioral operators to be the two derivatives and the test for epsilon membership, then CIRC becomes a fully automatic decision procedure for the equivalence of REs:
Regular expressions R1 and R2 are equivalent iff CIRC successfully terminates for the initial conﬁguration (Eqns (RE), {R1 = R2});
Regular expressions R1 and R2 are not equivalent iff CIRC fails for the initial conﬁguration (Eqns (RE), {R1 = R2}).
Therefore, no case analysis or other assisted tactics are needed to prove the equivalence of REs. Two REs are equivalent iff CIRC returns Proof succeeded, and are not equivalent iff CIRC returns failed during coinduction.
Here we show CIRC at work presenting how it proves the equivalence of two reg- ular expressions. CIRC extends Full-Maude [3] with a set of declarations and com- mands which allow the user to introduce information regarding behavioral specifica- tions and commands to assist the prover. First we have to introduce the behavioral

operations. These are included in a cmod...endcm module:
(cmod B-RE is importing RE . derivative epsIn(*:Ere) . derivative *:Ere { a } . derivative *:Ere { b } .
endcm)
After the modules RE and B-RE are loaded, we introduce the goal we want to prove:
Maude> (add goal (a + b)* = ((a *)#(b *))* .) Goal (a + b)* = (a * # b *)* added.
The circular coinduction algorithm is triggered with the command:
Maude> (coinduction .) Proof succeeded.

Regular Strategies as Proof Tactics
A successful reduction of the circular coinduction algorithm is of the form


CCStep
EqRed
CCStep
EqRed

(E0, G0) ====⇒ (E1, G1) ... ===⇒ (Ei, Gi) ... ====⇒ (Ej, Gj) ... ===⇒ (En, ∅)
and a failing reduction is of the form


CCStep
EqRed
CCStep
CoindFail

(E0, G0) ====⇒ (E1, G1) ... ===⇒ (Ei, Gi) ... ====⇒ (Ej, Gj) ... =====⇒ failure
If we consider only the labels of the rules applied in the reduction, then the former one is described by a word in the language given by the regular expression Rsucc = CCStep(CCStep + EqRed)∗EqRed, and the later one by a word given by the regular expression Rfail = CCStep(CCStep + EqRed)∗CoindFail. We say that the regular expression Rsucc + Rfail describes the circular coinduction proof tactic.
CIRC can be extended with new proof capabilities implemented as rewriting rules and new proof tactics described by regular expressions. We assume that the prover is given by a set of rewriting rules of the form l : C → C' if cond, where l is the label of the rule, C, C' are configurations, and cond is the condition of the rule. Let L denote the set of the rules labels. The same label may be shared by more rules. This is, e.g., the case of two rules whose conditions are complementary, i.e., if one condition is true, then the other one is false. The description of the proof could become simpler if we use the same label for the two rules. We say that a word w ∈ L∗ describes a reduction C ⇒∗ C' iff w = l1 ... ln and the reduction

l1
is given by C = C0 ===⇒
C ... =ln⇒ C  = C', where C
li
i−1 ===⇒ Ci means

that the configuration Ci is obtained from Ci−1 by applying the rule li. We write
w	'
C ===⇒ C .
A regular strategy term is a regular expression over L. The semantics of a

strategy term R consists of all the reductions C ===⇒ C'
with w ∈ L(R).

We extend the definition of configurations by adding a new component given by a regular strategy term. A rewriting rule
l : C → C'	if	cond

is replaced by
l : (C, R) →	'	'	if	cond Λ nf (R{l})= R' Λ R' /= empty.
(C ,R )
where nf (R{l}) = R' Λ R' /= empty means that there is a word starting with l in
w	'
L(R). We have (C, R) ===⇒ (C , ε) if and only if w ∈ L(R).
Let У = (Σ, Δ, S) be a behavioral specification. We say that a regular strategy
w
term R is a proof tactic for У if У |≡ e whenever (E, {fr (e)}, R) ===⇒ (S , ∅, ε).

Simpliﬁcation
Since circular coinduction uses frozen forms of the goals, the coinductive hypotheses added by [CCStep] can be applied only at the top. There are cases when it is sound to apply these hypotheses under the top. For instance, we assume that we have to show the following equality over streams: S × [0] = [0]. [CCStep] will add the hypothesis fr (S × [0]) = fr ([0]), and replace the above goal with fr (hd (S × [0])) = fr (hd ([0])) and fr (tl (S × [0])) = fr (tl ([0])). The former is solved by [EqRed] and the last is reduced to fr (tl (S) × [0] + [hd (S)] × [0]) = fr ([0]). It is easy to see that the circular coinduction algorithm produces a infinite set of new goals in this case. For streams it is sound to simplify the goals with the following rule:
S1 + S2 = S'
S = S'	if S2 = [0]
Then the above goal can be simplified to fr (tl (S) × [0]) = fr ([0]) because we get fr ([hd (S)] × [0]) = fr ([0]) applying the coinductive hypothesis. The remaining goal is proved in the same way. Note that the equality sign = in the above rule denotes the behavioural equivalence.
The following rule handles the general case:


[Simpl] :
(S , G ∪ {fr(e)}, R) ⇒ (S , G'
where

'
,R ) if nf (R

{Simpl}) /= empty Λ scond

 G ∪ {ti = t' if c | i = 1,... , n}	if e := f (t1,... , tn)= f (t' ,... , t' ) if c

R = nf (R{Simpl})
where scond is a condition which constraints the application of the rule (in the above example, S2 = [0] is such a condition). [Simpl] replaces a goal with the corresponding set of subgoals if the left hand side and right hand side of the equation e have in top the operator f , and let the set of goals unchanged in the other cases.
The rule [Simpl] must be used only in a controlled way, otherwise it could trigger infinite reductions, due to the “otherwise” case.

Theorem 3.1 Let У = (Σ, Δ, S) be a behavioral speciﬁcation, and let f ∈ Σ be an operation such that the proving of the goal f (t1,... , tn)= f (t' ,... , t' ) if c can be
1	n
'
simpliﬁed to the proving of the subgoals {ti = ti if c | i = 1,... , n} provided that
the simpliﬁcation condition scond holds. Then Rcosi = CCStep(Simpln # CCStep
+ Simpln # EqRed)∗EqRed is a proof tactic for У.
w
Proof. Let e be an equation such that (E, {fr (e)}, Rcosi ) ===⇒  (S , ∅, ε) with
w ∈ L(Rcosi ). We proceed by induction on the number representing how many times [Simpl] is applied. If [Simpl] is not applied, then w ∈ L(Rsucc) and we apply Theorem 2.1. We point out one application of [Simpl] which replaces a goal e' of
the form f (t1,... , tn) = f (t' ,... , t' ) if c with {ti = t' if c | i = 1,... , n}. We
'	1	n	i	'
have У |≡ ti = ti if c by the inductive hypothesis, for i = 1,... n. Hence У |≡ e by
the assumption on У and f .	 
[Simpl] is applied successively more than once when a goal of the form f (... f (.. .) .. .) = f (...f (.. .) .. .) if c is reached. The choice of n in the defini- tion of Rcosi could be a difficult task. A bigger value for n leads to a larger class of goals which can be proved by this tactic but to a less computationally efficient tactic; a smaller value leads to a more computationally efficient tactic but with a more restricted applicability. We may have both if we implement [Simpl] as follows:


[Simpl] :
(S , G ∪ {fr(e)}, R) ⇒ (S , G'
where

'
,R ) if nf (R

{Simpl}) /= empty Λ scond

⎧⎪	if e is f (t1,... , tn)= 
⎨(G ∪ {ti = t' if c | i = 1,... , n}, R)	'	'
⎪(G, nf (R{Simpl}))	otherwise
The above rule applies [Simpl] as long as there is a goal having the operator f ate the top. We may consider now n =1 in Theorem 3.1. In terms of strategy languages [13,18], the new rule [Simpl] is equivalent to [Simpl’] orelse id, where [Simpl’] is similar to [Simpl] but it is applied only if it simplifies a goal, and id is the identity strategy.
[Simpl] is implemented in CIRC (version 1.3) by extending the configuration with attribute proofStatus having as values regular strategies R. A copy of the specification RE is included and used to handle the regular strategies.

Equivalence of Context Free Processes
In this section we illustrate the usefulness of the regular strategies showing how the result of Proposition 2.5 can be extended to context-free grammars. We have to notice that we cannot obtain a fully automatic decision procedure for context-free grammars because the equivalence problem for these grammars is undecidable [8]. Baeten, Bergstra, and Klop [1] have shown that the equivalence problem is decidable

for normalized context free processes presented in Greibach normal forms. These processes are equivalent to simple (iredundant) context-free grammars. However the proof of decidability and the presentation of the algorithms are not easy and many researchers looked for simpler solutions, see , e.g., [9]. In this section we show that an adequate behavioral specification together with two simplifying rules and the proof tactic given in Theorem 3.1 supply a fully automatic semi-decision procedure for context free-processes. We prefer the formalism of context-free processes to that of context-free grammars because their equivalence is expressed as a bisimulation relation, which is more suitable for the behavioral approach.
BPA (Basic Process Algebra) expressions are defined by the following grammar:
E ::= a | X | E1 + E2 | E1E2
where a ranges over an alphabet Alph, X over variables, and E, E1, E2 over BPA expressions. A process is defined by a finite set of equations of the form Xi d=ef Ei. The operational semantics of BPA process is given by the following rules:
E	a	'	a	'	a	'

	1 −→ E1	
E2 −→ E2

E1 −→ E1


E + E	a	'
a	'	a	'

1	2 −→ E1
E1 + E2 −→ E2
E1E2 −→ E1E2

a	−→ E'
def

a −→ ε	if a ∈ Alph
X −→a
E'	if X = E

Note that ε is not a process; it is a configuration used to mark the end of a transition
process. The transition relation is extended to words w in Alph∗ as follows: p −a−→w q
if p a  p' and p' w  q. The norm |E| of an expression E is defined by structural
induction over BPA expressions: |a| = 1 if a ∈ Alph, |E1 + E2| = min(|E1|, |E2|),

|E1E2| = |E1| + |E2|, and |X| = |E|
def
if X = E. The norm has the following nice

property: |X| = min{length(w) | X −→w ε}. A process is normed if |Xi| is finite
def
for each equation Xi = Ei from its definition. A relation R over processes is a
bisimulation if it satisfies: pR q implies

if p a
if q −→a
p' then there is q' such that q a
q' then there is p' such that p −→a
q' and p' R q';
p' and p' R q'.

Two processes are bisimilar p ∼ q if there is a bisimulation R such that pR q.
The language defined by a variable X is L(X) = {w | X w  ε}. If X ∼ Y , then
L(X)= L(Y ).
Here is the behavioral specification we associate to BPA:
(th BPA is inc BOOL + INT .
sort Alph .	--- the alphabet
sort Pexp .	--- process expressions
sort Pid .	--- process ids
sort Peq .	--- process equations
sort Proc .	--- processes (sets of process equations) op pmain : -> Proc .
vars E E1 E2 : Pexp .	vars X Y X1 X2 : Pid . vars P P1 P2 Q : Proc .	vars A B : Alph .

op _=def_ : Pid Pexp -> Peq . subsort Peq < Proc .
op _‘,_ : Proc Proc -> Proc [assoc comm] .
eq (P , P) = P . 
op _‘{_‘} : Pexp Alph -> Pexp . --- the letters derivatives op |_| : Pexp -> Int .	--- the norm derivative
sort PidSet .	--- process variables
subsort Pid < PidSet .	--- sets of process variables op none : -> PidSet .
op _‘,_ : PidSet PidSet -> PidSet [assoc comm id: none] . vars PS PS’ : PidSet .
eq (X, X) = X .
op f : PidSet Pexp -> Int? .	--- auxiliary function eq f((X, PS), X) = infty .
ceq f((X, PS), Y) = f((X, Y, PS), E)
if ( (Y =def E), P ) := pmain /\ X =/= Y . eq f(PS, A ) = 1 .
eq f(PS, (E1 + E2)) = min(f(PS, E1), f(PS, E2)) .
eq f(PS, (E1 # E2)) = f(PS, E1) + f(PS, E2) .
subsort Alph < Pexp .	--- a letter
subsort Pid < Pexp .	--- a process id eq | A | = 1 . 
op epsilon : -> Pexp .
eq epsilon { A } = deadlock .
op deadlock : -> Pexp .
eq deadlock { A } = deadlock .
eq B { A } = if A == B then epsilon else deadlock fi .
op _+_ : Pexp Pexp -> Pexp [prec 33 assoc comm] . --- union eq ( E1 + E2 ){ A } = (E1 { A }) + (E2 { A }) .
eq | E1 + E2 | = min(| E1 |, | E2 |) .
op _#_ : Pexp Pexp -> Pexp [prec 32 assoc] .	--- concatenation eq ( E1 # E2 ){ A } = (E1 { A }) # E2 .
eq | E1 # E2 | = | E1 | + | E2 | .
ceq X { A } = E { A } if ( (X =def E), P ) := pmain . ceq | X | = f(X, E) if ( (X =def E), P ) := pmain .
--- simplifying equations eq deadlock + E = E .
eq deadlock # E = deadlock . eq epsilon # E = E .
eq E + E = E . 
eq (E1 + E2) # E = (E1 # E) + (E2 # E) .
endth)
The behavioral operators are the letter derivatives, defined in a similar way to those of regular expressions, and the norm. The sort for process variables is Pid. The definition of the norm requires an auxiliary function f (X, E), which returns the norm of the variable X with the definition E.
The following two simplification rules are sound for normed processes [9]:



E1E2 ∼ E' E2	E1 + E2 ∼ E' + E'	'	'

1	1	2
if |E1| = |E1|Λ |E2| = |E2|

E1 ∼ E'	E1 ∼ E' , E2 ∼ E'
1	1	2

We present here how CIRC 6 together with the proof tactic Rcosi given by The-

orem 3.1 are used for proving the equivalence X ∼
A, where X
def
= aXb + ab,

A d=ef aB + aY , B d=ef Ab, and Y d=ef b. Note that processes are not required to be in
Greibach normal form. Here is a Maude specification of the above process:
(th BPA-EX is including BPA .
ops a b : -> Alph .	ops X Y A B : -> Pid . eq pmain = ( X =def ( a # X # b ) + a # b ),
( A =def (a # B) + (a # Y) ),
( B =def A # b ), ( Y =def b ) .
endth)
The simplification rules are specified together with the derivatives in the cmod mod- ule:
(cmod B-BPA-EX is importing BPA-EX . derivative *:Pexp { a } . derivative *:Pexp { b } . derivative | *:Pexp | .
simplify
< E1:Pexp + E2:Pexp = E1’:Pexp + E2’:Pexp >
by
< E1:Pexp = E1’:Pexp > /\ < E2:Pexp = E2’:Pexp >
if
| E1:Pexp | = | E1’:Pexp | /\ | E2:Pexp | = | E2’:Pexp | .
simplify
< E1:Pexp # E2:Pexp = E1’:Pexp # E2’:Pexp >

by
if endcm)
< E1:Pexp = E1’:Pexp > E2:Pexp = E2’:Pexp .

We first introduce the goal and then the proof tactic Rcosi for this goal:
Maude> (add goal X = A .) Goal X = A added.
Maude> (coinduction and simplification .) Proof succeeded.
We can see the proof steps applied by the prover using “show history .” com- mand:
Maude> (show history .) Introduced beh spec B-BPA-EX Goal X = A added.
Hypothesis X = A added.
Goal X{a} = A{a} reduced to b + X # b = B + Y Goal b + X # b = B + Y simplified to
1 . X # b = B
2 . b = Y
Hypothesis X # b = B added. Goal b = Y reduced to b = Y Hypothesis b = Y added.
Goal X{b} = A{b} proved by reduction. Goal | X | = | A | proved by reduction.
Goal X # b{a} = B{a} reduced to
b # b + X # b # b = B # b + Y # b
Goal b # b + X # b # b = B # b + Y # b simplified to
X # b # b = B # b
b # b = Y # b 
Goal X # b # b = B # b simplified to X # b = B Goal X # b = B proved by reduction.
Goal b # b = Y # b simplified to b = Y Goal b = Y proved by reduction.

6 Regular strategies are included in the version 1.3 of CIRC.

Goal X # b{b} = B{b} proved by reduction. Goal | X # b | = | B | proved by reduction. Goal b{a} = Y{a} proved by reduction.
Goal b{b} = Y{b} proved by reduction. Goal | b | = | Y | proved by reduction. Proof succeeded.
Note the use of the simplification rules during the proving process:
b + Xb = B + Y is simplified to Xb = B and b = Y ,
bb + Xbb = Bb + Yb is simplified to Xbb = Bb and bb = Y b;
Xbb = Bb is simplified to Xb = B.
Without regular strategies, which allow to combine the circular coinduction steps with the simplification rule, the class of context-free processes for which CIRC is able to automatically prove the equivalence is much smaller. Regular strategies effectively enlarge the class of problems which can be automatically proved with CIRC. The problem of finding the complete subclass of context-free processes for which the equivalence can be automatically proved with CIRC remains open.

Conclusion
We presented CIRC, an automated prover supporting the principle of circularity and in particular circular coinduction. CIRC is implemented as an extension of Maude using its metalevel programming capabilities. Two novel contributions have been made in this paper. First, we showed the correctness of the circular coinductive proof strategy. Second, we showed how CIRC can be extended using regular strategies. The method is exemplified by adding a simplification rule and defining a proof tactic (as a regular strategy) used for proving the equivalence of context-free processes. The use of regular strategies as proof tactics enlarge the class of problems which can be automatically solved. CIRC implements also the circularity principle for proving properties by induction. Regular strategies make the use of proof tactics that combine coinduction with induction possible. This can be done now only in an assisted way.

References
Baeten, J. C. M., J. A. Bergstra and J. W. Klop, Decidability of bisimulation equivalence for process generating context-free languages, Journal of the ACM 40 (1993), pp. 653 – 682.
Clavel et al., M., Maude: Specification and Programming in Rewriting Logic, J. of TCS 285 (2002),
pp. 187–243.
Clavel, M., F. Dur´an, S. Eker and J. Meseguer, Building Equational Proving Tools by Reflection in Rewriting Logic, in: Cafe: An Industrial-Strength Algebraic Formal Method, Elsevier, 2000 .
Goguen, J., K. Lin and G. Ro¸su, Circular coinductive rewriting, in: Proceedings of Automated Software Engineering 2000 (2000), pp. 123–131.
Goguen, J., K. Lin and G. Ro¸su, Conditional Circular Coinductive Rewriting with Case Analysis, in:
WADT’02, LNCS 2755 (2003), pp. 216–232.
Hausmann, D., T. Mossakowski and L. Schr¨oder, Iterative Circular Coinduction for CoCASL in Isabelle/HOL, in: Fundamental Approaches to Software Engineering 2005, LNCS 3442 (2005), pp. 341–356.

Hennicker, R., Context induction: a proof principle for behavioral abstractions, Formal Aspects of Computing 3 (1991), pp. 326–345.
Hopcroft, J. and J.D.Ullman, “Introduction to automata theory, languages, and computation,” Addison–Wesley, 1979.
Hu¨ttel, H. and C. Stirling, Actions Speak Louder Than Words: Proving Bisimilarity for Context-Free Processes., J. Log. Comput. 8 (1998), pp. 485–509.
Jacobs, B. and J. Rutten, A tutorial on (co)algebras and (co)induction, Bulletin of the European Association for Theoretical Computer Science 62 (1997), pp. 222–259.
Lucanu, D. and G. Ro¸su, The CIRC Prover, http://fsl.cs.uiuc.edu/index.php/Circ.
Lucanu, D. and G. Ro¸su, Circ: A Circular Coinductive Prover, in: 2nd Conference on Algebra and Coalgebra in Computer Science (CALCO 2007), Bergen, Norway, 2007, to appear in Lecture Notes in Computer Science.
Marti-Oliet, N., J. Meseguer and A. Verdejo, Towards a Strategy Language for Maude, Electronic Notes of Theoretical Computer Science 117 (2005), pp. 417–441.
Ro¸su, G., “Hidden Logic,” Ph.D. thesis, University of California at San Diego (2000).
Ro¸su, G., Equality of Streams is a Π0-Complete Problem, in: the 11th ACM SIGPLAN Int. Conf. on Functional Programming (ICFP’06) (2006).
Ro¸su, G. and M. Viswanathan, Testing Extended Regular Language Membership Incrementally by Rewriting, in: RTA’03, LNCS 2706 (2003.), pp. 499–514.
Sen, K. and G. Rosu, Generating Optimal Monitors for Extended Regular Expressions., Electr. Notes Theor. Comput. Sci. 89 (2003).
Visser, E., Z. e. A. Benaissa and A. Tolmach, Building program optimizers with rewriting strategies, ACM SIGPLAN Notices 34 (1999), pp. 13–26.
