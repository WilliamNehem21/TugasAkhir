

Electronic Notes in Theoretical Computer Science 234 (2009) 55–75
www.elsevier.com/locate/entcs

Analysis of Rewrite-Based Access Control Policies
Claude Kirchner, H´el`ene Kirchner
INRIA
Bordeaux - Sud-Ouest Research Center
351, Cours de la lib´eration, 33405 Talence, France
Anderson Santana de Oliveira1
Universidade Federal do Rio Grande do Norte DIMAp - Campus Universita´rio - Lagoa Nova
59072-970, Natal-RN, Brazil

Abstract
The rewrite-based approach provides executable specifications for security policies, which can be indepen- dently designed, verified, and then anchored on programs using a modular discipline. In this paper, we describe how to perform queries over these rule-based policies in order to increase the trust of the policy author on the correct behavior of the policy. The analysis we provide is founded on the strategic narrowing process, which provides both the necessary abstraction for simulating executions of the policy over access requests and the mechanism for solving what-if queries from the security administrator. We illustrate this general approach by the analysis of a firewall system policy.
Keywords: Security Policies, Term Rewriting Systems, strategic rewriting, strategic narrowing.


Introduction
Security policies define what it means to be secure for a system. Policies establish constraints on how data are to be accessed, either by determining acceptable in- formation flows, or by describing the privileges principals have over the protected resources inside the system. Since policies reflect the security requirements for some organization, or generally speaking, for some entity, they are subject to fre- quent changes as new threats appear or as the architecture of the system in question evolves. One of the current challenges in computer security is to model rich, ex- pressive policies, usually given as a set of rules, such that their properties can be

1 Supported by CNPq 152373/2007-1.

1571-0661/© 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.02.072

formally stated and proved. For instance, policies should be non-ambiguous, which means that an access is not granted and denied at the same time. Policies should also cover all relevant situations a system may be exposed to: when dealing with access control, this means answering all possible access requests.
In [14,10] we proposed a formal model of policies, based on term rewriting, which provides several advantages: first, the language allows us to handle a wide range of security policies, because we can easily describe the form of the access requests and the set of possible authorization decisions, without restricting them to simply permit or deny. Moreover, policy application can be defined in a precise and expressive way, since it is possible to determine a strategy to control rule application.
Such an approach provides not only a clear semantics to access control policies, but also appropriate techniques to verify important properties, relying on the con- fluence, termination and sufficient completeness of the underlying rewrite systems. Moreover, the rewrite-based framework inherits from the modularity results for all these properties, which is a striking advantage over other frameworks, since one can reason about the impact of the policy composition over the properties of the component policies.
Besides proving these properties, a policy designer needs to understand how access decisions are generated. He may want to know how a policy deals with specific kinds of requests, specially those concerning the most sensitive information in the system. In the literature, this is often referred to as “administrator queries” [27,7], representing questions of the kind “what if a request is made under these conditions? Will access be conceded?” Answering these questions increases the confidence of the policy designer in a given specification.
In this paper, we build on our previous works to provide this kind of analysis for rewrite-based policies. The main mechanism behind the analysis is narrowing, which provides both the necessary abstraction for simulation of rewriting-based executions of the policy requests and the solving mechanism of queries. We extend the policy language with requests involving variables and we show how narrowing can be used to find which values can instantiate such variables in order to satisfy given requests, thus providing an adequate mechanism for solving these queries.
Due to the expressiveness and computational power of rewriting, the framework of rewrite-based security policies is general enough to be applied to a large variety of security problems. An illustrative example is provided by firewall policies. A firewall is a security component put in the entry point of a local network to control its interactions with the Internet. The main objective is to inspect the packet traffic from and into the local network and to decide whether a given packet should be transmitted or rejected. Real firewall implementations are usually given as a sequence (i.e. totally ordered set) of rules, which can make recursive calls, and may have default rules. This is the case for instance for NetFilter, which is the firewall system used in several variations of Linux distributions. It is important to notice that such a rule presentation is used as a description of the rule execution sequence. This is indeed an implicit rule execution strategy implemented by these systems, and the capacity of expressing such strategies explicitly is primordial to make the

policy semantics clear, maintainable and provable. In current systems, security administrators often face the problem of avoiding an inconsistent, redundant or incomplete set of rules as described for example in [24].
Here, we show how solving queries can be useful to identify such situations for this extremely important kind of policy, since they are the most current mechanism for protecting networks from numerous threats. But the technique is also applicable for any other form of flexible rewrite-based policy.
The structure of the paper is as follows. In Section 2, we recall and illustrate the definition of a rewrite-based security policy. In Section 3, the relevant definitions of rewriting, narrowing and strategies are given. It stresses the notion of strategic rewriting which is of prime interest in the context of policy rules where the appli- cation order and more generally the control are taken into account. Then Section 4 shows how to use strategic narrowing to solve queries and find the corresponding requests in a large class of policy specifications. It provides examples of what-if analysis. To support the reader intuition, a simplified firewall example is developed along the paper. Section 5 concludes with some perspectives for further work.
Rewrite-Based Policies
Basic definitions on term rewriting can be found in [29,31,4]. The following standard notations will be used in the following. T (F, X ) is the set of first-order terms built from a given finite set F of function symbols with their profile declarations and a denumerable set X of variables. Positions in a term are represented as sequences of integers and denoted by ω, while the empty sequence ϵ denotes the top position. They are ordered by lexicographic prefix ordering ≤. The notation t|ω is used to denote the subterm of t at position ω. We write t[s]ω (or sometimes simply t[s]) to emphasize that t contains the subterm s at position ω. The set of variables occurring in a term t is denoted by Var(t). If Var(t) is empty, t is called a ground term and T (F) is the set of ground terms.
A substitution σ is an assignment from X to T (F, X ), with a finite domain
{x1,..., xk} and written σ = {x1 '→ t1,..., xk '→ tk}.	The set of variables
{x1,..., xn} is called its domain and denoted D(σ). The set ∪i=1,...,n Var(ti) is denoted I(σ). We write σ|V the restriction of σ to the set of variables V , and σ = σ'[V ] means that ∀x ∈ V, σ(x) = σ'(x).
A rewrite rule is an ordered pair of terms l, r ∈ T (F, X ), denoted l→r, where it is often required that l is not a variable and Var(r) ⊆ Var(l). The terms l and r are respectively called the left-hand side and the right-hand side of the rule. A rewrite system is a (finite or infinite) set of rewrite rules. Rules can be labeled to easily talk about them.
In [14], we introduced a general definition of an access control policy that ab- stracts the set of possible requests and decisions, and thus supports a wide range of policies:
Definition 2.1 [Security Policy [14]] An access control security policy ℘ is a 5-tuple (F, D, R, Q,ζ) where:

F is a sorted signature; to deﬁne the vocabulary of the data-structure.
D is a non-empty set of closed terms: D ⊆ T (F); to formalize the set of decisions taken by the policy.
R is a set of rewrite rules over T (F, X ); to provide the local semantics of the policy.
Q is a set of terms from T (F): Q ⊆T (F); to describe the form of the acceptable requests.
ζ is a rewrite strategy for R; to guide the rule application and therefore provide the global semantics of the policy.
The notions of local and global semantics mentioned in the comments of this defi- nition are provided as an intuitive way to describe the fact that a rewrite rule is an entity that describes a local transformation and a strategy a way to combine these local application rules. This is formally developed in the next section (section 3).
In order to illustrate this definition, let us consider the following simple example.

Example 2.2 This example is taken from the NetFilter how-to 2 . Suppose an Internet user wants to set his firewall to block any traffic coming from the exterior to his local network. Since the interface associated to Internet connections is usually ppp0, a simple method is to reject all new packets coming from this source. In order to demonstrate the fact that it might be convenient for a policy to contain rules beyond those which directly compute decisions, we also give some additional rules which allow two different local computers to share the same external IP address: for each outgoing packet whose origin is a local machine, its head is rewritten to a single address.
The sorted signature F for this policy is:


The function pckt computes a decision for the packets being transmitted in the network.
The set of of constant symbols representing decisions is D = {accept, drop}.
Consider R as the following rules, where src, dst : Address, and s : State are

2 http://www.netfilter.org

variables:
pckt(src, dst, estab) → accept pckt(eth0, dst, new) → accept pckt(ppp0, dst, new) → drop
pckt(10.1.1.1, ppp0, s) → pckt(123.123.1.1, ppp0, s)
pckt(10.1.1.2, ppp0, s) → pckt(123.123.1.1, ppp0, s)
The first rule says that packets concerning established connections have to be accepted. The second rule matches any packet whose origin is the local network, which are accepted. The third rule rejects any new packet coming from the exter- nal network (ppp0). The last two rules match the IP address of the local machines and rewrites them to a single IP address visible from the external network.
The set Q consists in all ground terms having the symbol pckt at top position.
A common strategy for such firewall policy, is to apply rules in the order they are given. We will see how to formalize this strategy in the following section.
The above elements define a security policy. It is worth noticing the presence of recursive rules, which are important for the policy definition, but that do not directly derive permissions.
Further examples to illustrate this definition are given for instance in [14,10,12]. In this framework, policy evaluation corresponds to evaluation by strategic rewriting of ground requests. Let us introduce this concept in the next section.

Strategic rewriting and narrowing
Strategic rewriting and narrowing are defined and studied in [28]; the interested reader can refer to it for more details.
Given a rewrite system R, a term t in T (F, X ) rewrites to another term t' if there exists a rewrite rule l→r of R, a position ω in t, and a substitution σ such
that t|ω = σl and t' = t[σr]ω. This is written t→R	t' where either ω, l→r, σ
or R may be omitted. t|ω is called a redex. A term that has no redex is said to be irreducible for R or to be in R-normal form, or simply normalized. The reflexive transitive closure of the rewriting relation induced by R is denoted by ∗ R.
A term rewrite system R generates an abstract reduction system, i.e. a labeled oriented graph R = (OR, SR) whose nodes are terms OR ⊆ T (F, X ), and whose oriented edges are rewriting steps: SR = {t→t'|t→Rt' for ω a position in t}. An R-derivation or R-reduction sequence is a path π in the graph R; when it is finite, π can be written t0→φ0 t1→φ1 t2 ... →φn−1 tn where the φi are labels, and we say that t0 reduces to tn by the derivation π = φ0φ1 ... φn−1; this is also denoted t0→φ0φ1...φn−1 tn or simply t0→πtn; n is the length of π. A derivation is empty when its length is zero, in which case its source and target are the same. The empty derivation issued from t is denoted idt. The source of π is the singleton {t0}

denoted dom(π). The target of π is the singleton {tn} and it is denoted (π t0) or simply πt0 when there is no syntactic ambiguity; note that an R-derivation is the concatenation of its reduction steps. The concatenation of π1 and π2 when it exists, is a new R-derivation.
It is common to identify a rewrite system (i.e., a set of rewrite rules) with the abstract reduction system it generates (i.e., the set of all derivations allowed by R). To a rewrite system corresponds directly a unique abstract reduction system that can be seen as a generic way to describe the set of all derivations. The converse is not true since from a set of derivations, the generating rewrite system is not in general uniquely determined.

Strategic Rewriting
Definition 3.1 [Abstract Strategy] For a given abstract reduction system R:
An abstract strategy ζ is a subset of the set of all derivations (finite or not) of R. Applying the strategy ζ on an object t is denoted ζt. It denotes the set of all objects that can be reached from t using a derivation in ζ:
ζt = {t' | ∃π ∈ ζ such that t→πt'} = {πt | π ∈ ζ}.
When no derivation in ζ has source t, we say that the strategy application on t fails. Applying the strategy ζ on a set of objects consists in applying ζ to each element t of the set. The result is the union of ζt for all t in the set of objects. The domain of a strategy is the set of objects that are source of a derivation in ζ: dom(ζ) =  δ∈ζ dom(δ). The strategy that contains all the empty derivations is Id = {idt | t ∈ O}.
It is now possible to give the definition of strategic rewriting:
Definition 3.2 [Strategic rewriting [28]] Let R = (OR, SR) be the abstract reduc- tion system generated by a rewrite system R and ζ be a strategy of R. A strategic rewriting derivation (or rewriting derivation under strategy ζ) is an element of ζ. A strategic rewriting step under ζ is a rewriting step t→Rt' that occurs in a derivation of ζ, which is denoted t→ζt'.
A strategy can be described by enumerating all its elements or more suitably by a strategy language. Various approaches have been followed, yielding slightly different strategy languages such as ELAN [30,8], Stratego [36], Tom [6,5] 3 or more recently Maude [9]. All these languages share the concern to provide abstract ways to express control of rule applications, by using reflexivity and the meta-level for Maude, or the notion of rewriting strategies for ELAN or Stratego. Strategies such as bottom-up, top-down or leftmost-innermost are higher-order features that describe how rewrite rules should be applied. Tom, ELAN and Stratego provide flexible and expressive strategy languages where high-level strategies are defined by combining low level primitives. We refer to [28] for more details on these strategy languages.

3 http://tom.loria.fr

In the context of security policies that we want to consider here, a few strategies are of main interest: the strategy universal(R) represents all derivations generated by a set of rewrite rules R, innermost(R) represents derivations where rules of R are applied only on terms whose all strict subterms are irreducible. ordered(r1, ..., rk) represents derivations where rules r1, ..., rk are tried in this order on terms whose all strict subterms are irreducible. This last strategy corresponds to Innermost Priority rewriting (IP-rewriting for short) that is defined below.
When a rewrite system R is partially ordered with an ordering >, we say that r1 has a higher priority than r2 if r1 is greater than r2, denoted r1 > r2. Innermost Priority Rewriting can then be defined as follows:
Definition 3.3 [Innermost Priority Rewriting [21]] Given a rewrite system R with a partial ordering on rules, a term t in T (F, X ) IP-rewrites to t', if there exists a rewrite rule l→r of R, a position ω in t, and a substitution σ such that t|ω = σl
and t' = t[σr]ω such that t→R	t', no proper subterm of t|ω is IP-reducible, and
t|ω is not reducible by any other rule of higher priority than l→r. This is written

IP
ω,l→r,σ
t' where either ω, l→r, σ or R may be omitted. t|ω is called a IP-redex.

A term that has no IP-redex is said to be IP-normalized.
With this definition, we get:
Proposition 3.4 A term t is IP-normalized iff it is normalized.
Proof If t is normalized, t is indeed IP-normalized. Let us prove the converse by contraposition. If t is not in normal form, there exist an innermost position and a non empty set of rules that apply at this position. By choosing a rule with the higher-priority between them, we get an IP-rewriting step and t is not IP- normalized.	 
A substitution is said (ground) IP-normalized if all the terms in its image are (ground) IP-normalized. According to Proposition 3.4, we may simply consider normalized substitutions.

The narrowing process
The narrowing process, introduced in [26,16], is quite similar to rewriting but there, matching is replaced by unification. Let us recall its usual definition:
Definition 3.5 [Narrowing] Given a rewrite system R, a term t in T (F, X ) narrows to the term t' if there exists a rewrite rule l→r of R and a position ω in t and such that t|ω and l are unifiable with a most general unifier (mgu for short) σ. Then
t' = σ(t[r]ω). This is denoted t ~R	t' or t ~ t' when we do not need to make
precise which rewrite rule is used and where.
Let us remember that the variables in a rewrite rule are implicitly universally quantified and therefore, the set of variables in a rewrite rule may always be assumed distinct from those in the narrowed term (i.e. in the definition above, Var(t) ∩

Var(l) = ∅). Let us remark also that narrowing subsumes rewriting since a match between variable disjoint terms is also a unifier.
Based now on the narrowing process, a term rewrite system R generates another abstract reduction system N = (OR, SR) with OR ⊆ T (F, X ), and SR = {t ~

'	R
ω,l→r
t' for ω a position in t}. As for the rewriting relation, we can define

strategic narrowing.
Definition 3.6 [Strategic narrowing [28]] Given an abstract reduction system N = (OR, SR) generated by a rewrite system R, and a strategy ζ of N , a strategic narrowing derivation (or narrowing derivation under strategy ζ) is an element of ζ. A strategic narrowing step under ζ is a narrowing step t ~R t' that occurs in a derivation of ζ, which is denoted t ~ζ t'.

Simulation of rewriting by narrowing
We are now interested in formalizing precisely how (strategic) rewriting and (strate- gic) narrowing are related. It may be expressed thanks to the general notion of simulation on abstract reduction systems given in [22] and [15] independently.
Definition 3.7 [Simulation] Let (O1, →1) and (O2, →2) be two abstract reduction systems. (O1, →1) Γ-simulates (O2, →2) for a relation Γ ⊆ O1 × O2 when for every
reduction step s2 →2 s' with source s2 and target s' , there exists a corresponding
reduction step t1 →1 t' with source t1 and target t' , such that t1Γs2 and t' Γs' .
1	1	1	2
Let us define the relation Γ ⊆T (F) ×T (F, Y) as : tΓu if t is a ground instance of u. The following lemma entails the fact that the abstract reduction system (T (F), →) simulates the abstract reduction system (T (F, Y), ~).
Lemma 3.8 For any term t ∈T (F, Y) and rewrite system R, if t ~ω,l→r,σ t' then
σ(t)→ω,l→r,σt', and for any ground instance α of σ, α(t)→ω,l→r,σα(t').
Proof Clearly, if t ~ω,l→r,σ t' then σ(t)→ω,l→r,σt'.  Since α is an instance of σ, α = μσ. Then α(t) = μ(σ(t))→ω,l→rμ(t'). But t' = σ(t[r]ω), so μ(t') = μσ(t[r]ω) = α(t').	 
As a consequence, a derivation in the abstract reduction system (T (F, Y), ~) corresponds to a set of derivations in the abstract reduction system (T (F), →):
Proposition 3.9 For any term t ∈T (F, Y) and rewrite system R,

R
ω1,l1→r1,σ1
R
ωn,ln→rn,σn
tn, then

σn ... σ1(t)→R

ωn,ln→rn tn

and for any ground instance α of σn ... σ1(t),


R
ω1,l1→r1
R
ωn,ln→rn
α(tn).

Given a terminating rewrite system R, let us consider N , the subset of normal- ized ground instances of terms in T (F, X ). The relation ΓN ⊆ T (F, Y) ×N is

defined as : u ΓN t if t is a normalized ground instance of u. The fact that the ab- stract reduction system (T (F, Y), ~) ΓN -simulates the abstract reduction system (N, →) is a little more subtle to establish and is a consequence of the following lemma proved first by J.-M. Hullot [26].
Lemma 3.10 Let t0 be a term and ρ be a normalized substitution. If ρ(t0)→R	t' ,

then there exist substitutions σ and μ such that:
ω,l→r 1

R
ω,l→r,σ
t1,

μ(t1) = t' , μ is normalized,
ρ =Var(t0) μσ (i.e. ∀x ∈ Var(t0), ρ(x) = μσ(x)).
This result is easily extended by induction on the number of steps to any rewrit- ing derivation:
Proposition 3.11 Let t0 be a term and ρ be a normalized substitution such that:


ρ(t0)→R
... →R
t' .

ω1,l1→r1	ωn,ln→rn  n
Then there exist substitutions σi(i = 1,..., n) and μ such that:

R
ω1,l1→r1,σ1
R
ωn,ln→rn,σn
tn,

μ(tn) = t' , μ is normalized,
ρ =Var(t0) μσn ... σ1 (i.e. ∀x ∈ Var(t0), ρ(x) = μσn ... σ1(x)).
Narrowing derivations thus ΓN -simulates rewriting derivations when strategies are not taken into account. In the more general case of strategic rewriting and narrowing, simulation results have only been stated for specific strategies such as innermost or outermost rewriting [22], and we address this problem here for priority rewriting [21].
Completeness of the narrowing process for solving equational goals has been largely studied in the litterature. A summary of results can be found in [1]. Ter- mination of narrowing while preserving completeness has been less studied. Again a state of the art can be found in [1], as well as the definition of several classes of rewrite systems where narrowing has a finite search space, without requiring confluence of the rewrite system.

Simulation of IP-rewriting by IP-narrowing
Let us focus in this section on innermost priority rewriting and on the corresponding strategic narrowing relation. The idea is to capture any IP-rewriting α(t)→IP s by a constrained narrowing step (t, c) ~IP (t', c') by setting adequately the constraints c, c'. For all normalized ground substitution α satisfying c' (and c), we should get an IP rewriting step on α(t) and a resulting term α(t'). Constraints are first-order equational formulas, and the trivial constraint, always true, is denoted id.
Let us now analyze the construction of these constraints. In order to make possible the application of a rule l→r at some position ω in t, we first need to find

a mgu of t|ω and l, say σ. Then to be IP-reducible by the rule l→r at position ω, a ground normalized instance α(t) must satisfy the following conditions:
α is an instance of σ. Note that we can also consider a narrowing substitution σ of a term t at position ω with a rule l→r, as the solved form of an equational constraint t|ω =?l; in the following, we also denote by σ this solved form. Then α satisfies σ iff α is an instance of σ of the form α = μσ[Var(t) ∪ Var(l)].
There is no possible IP-rewriting at a position ω' suffix of ω (written ω' ≥ ω):
∀ω ≥ ω, ∀l →r ∈ R, ∀γ, α(t)|ω' /= γ(l ).
Since α is normalized, ω' is a non-variable position in t. In other words α must satisfy a constraint cinn which is a conjunction on all possible ω' and l' of dise- quality constraints:


cinn = 
∀Var(l ), t|ω' /= l .

ω'≥ω l'→r'∈R
There is no rule of higher priority to apply at position ω:
∀l'→r' > l→r ∈ R, ∀γ, α(t)|ω /= γ(l').
In other words α must satisfy a constraint cprio which is a conjunction on all possible l' of disequality constraints:


cprio =	 
l'→r'>l→r∈R
∀Var(l'), t|ω /= l'.

A few renaming conditions are imposed in this narrowing process involving σ
and l:
variables of rules are kept disjoint from the variables of terms: Var(t) ∪Var(σ(t)) and Var(l) are always disjoint sets;
variables introduced by a mgu σ, that is I(σ), are disjoint from D(σ). This condition implies that unifiers are idempotent (σσ = σ), so σ(t') = σ(σ(t[r]ω)) = t';
We will need the three following lemmas, borrowed or adapted from [34].
Lemma 3.12 If t is a term and σ a substitution, then Var(σ(t)) = Var(t) \ D(σ) ∪
I(σ)|Var(t).
It is useful to notive that, with the previous hypotheses, free variables of the constraints cinn and cprio belong to Var(t). As a consequence of Lemma 3.12, if σ is the unifier used in the narrowing step, σ(cinn) =  ω'≥ω  l'→r'inR ∀Var(l'), σ(t)|ω' /= l' and σ(cprio) =  l'→r'>l→r∈R ∀Var(l'), σ(t)|ω /= l' have free variables in Var(t) \
D(σ) ∪ I(σ)|Var(t).
Lemma 3.13 Suppose we have substitutions σ, θ, θ' and sets A, B of variables such that (B \ D(σ)) ∪ I(σ) ⊆ A. If θ = θ'[A] then θσ = θ'σ[B].

Lemma 3.14 Let R be a rewrite system with priorities and suppose we have sub- stitutions σ, θ, θ' and sets A, B of variables such that
θ|A is normalized
θ'σ = θ[A]
B ⊆ A \ D(σ)) ∪ I(σ)|A.
Then θ'	is also normalized.
IP-narrowing is then defined on constrained terms, i.e. pairs (t, c) of terms and first-order equational constraints.
Definition 3.15 [Constrained IP-narrowing] Let t be a term and c a constraint. A constrained IP-narrowing step on (t, c) is defined if there exist a rule l→r of the system R, a non-variable position ω in t, a substitution σ solution of the constraint t|ω =?l and a constraint cIP = cinn Λ cprio such that σ Λ c Λ cIP is satisfiable. Then
t' = σ(t[r]ω) and c' = σ(c) Λ σ(cIP ). This is denoted by (t, c) ~IP	(t', c').
A IP-narrowing derivation starting from (t0, c0) is a sequence of constrained IP-narrowing steps.
Taking into account the restrictions put by constraints, we get the following result.
Lemma 3.16 For any term t ∈ 7 (J, Y) and rewrite system R with priorities, if

IP
ω,l→r,σ
(t', c') then for any ground normalized instance of σ, α = μσ such

that μ satisﬁes c', α(t)→IP	α(t').
Proof Let us consider the term s = α(t). Its subterm s|ω is an instance of l and ω
is a position in t since α is normalized. Since α is an instance of σ, σ(t)→R	t' and
α(t) = μ(σ(t))→R	μ(t') = μ(σ(t[r]ω)) = α(t'). Moreover since μ satisfies σ(cIP ),
α satisfies cIP , so in particular of 6Var(l'), t|ω' /= l' for all non-variable position ω' ≥ ω in t. So α(t)|ω' cannot be an instance of a left-hand side of rule in R, and any proper subterm of s|ω is IP-irreducible. For the same reason, s|ω cannot be reducible by a rule l'→r' having a higher priority than l→r, since α is solution of 6Var(l'), t|ω /= l'. So the reduction step from α(t) to α(t') is innermost and respects priorities, and s = α(t) is IP-reducible to α(t').	 
Consequently, an IP-narrowing derivation corresponds to a set of derivations in the abstract reduction system (7 (J), →IP ).
Proposition 3.17 Let R be a rewrite system with priorities. For any term t0 ∈ 7 (J, Y), and any constraint c0, if


IP
ω1,l1→r1,σ1
IP
ωn,ln→rn,σn
(tn, cn)

then for any ground normalized instance of σ = σn ... σ1, α = μσ such that μ
satisﬁes cn, we have


IP
ω1,l1→r1
IP
ωn,ln→rn
α(tn).

Proof By induction on the length of the IP-narrowing derivation. Lemma 3.16 provides the case n = 1. Then for any ground normalized substitution α = μσ such that μ satisfies cn = σ(c0) Λ σ(cIP ) Λ σ(cIP ) Λ ... Λ σ(cIP ), α may also be
1	2	n
written α = μ'σ1 with μ' = μσn ... σ2. Then μ' satisfies c1 = σ1(c0) Λ σ1(cIP ), so

IP
ω1,l1→r1
α(t1).  By induction hypothesis, since α(t1) = μσn ... σ2(t1) and μ

satisfies cn, α(t1)→IP
IP
ωn,ln→rn
α(tn).	 

Instantiating the initial constraint by the trivial constraint id which is always true, we get the following corollary.
Corollary 3.18 Let R be a rewrite system with priorities. For any term t0 ∈ 7 (J, Y), if

IP
ω1,l1→r1,σ1
IP
ωn,ln→rn,σn
(tn, cn)

then for any ground normalized instance of σ = σn ... σ1, α = μσ such that μ
satisﬁes cn, we have

IP
ω1,l1→r1
IP
ωn,ln→rn
α(tn).

Conversely the following lifting lemma is inspired from [21] and [23].
Lemma 3.19 (IP-lifting Lemma) Let R be a rewrite system with priorities. Let s ∈ 7 (J, Y), α a substitution such that α(s) is IP-reducible at a non-variable po- sition ω of s, and V ⊆ Y a set of variables such that V ar(s) ∪ D(α) ⊆ V . If

IP
ω,l→r
t', and if α satisﬁes a constraint c, whose free variables are included in

V , then there exist a term s' ∈7 (J, Y), a constraint c' and normalized substitutions
μ, σ, such that:

(s, c) ~IP
μ(s') = t'
μσ = α[V ]
μ satisﬁes c'.
(s', c')

Proof We can always assume that Var(l) and V are disjoint. We have α(s)|ω = β(l) for some β with D(β) ⊆ Var(l). Since ω is a non-variable position in s, and since the domains of α and β are disjoint, s|ω and l are unifiable by α ∪ β = γ. Let σ be an idempotent most general unifier of these two terms. Let s' = σ(s[r]|ω). Since σ is a mgu, there exists ρ such that ρσ = α ∪ β = γ. Let V ' = (V \ D(σ)) ∪ I(σ) and μ = ρ|V ' . Clearly D(μ) ⊆ V '. On the other hand, Var(s') = Var(σ(s[r])) ⊆ Var(σ(s[l])) = Var(σ(s)) = Var(s)\D(σ)∪I(σ)|Var(s) by Lemma 3.12, so Var(s') ⊆
V '. Thus we get Var(s') ∪ D(μ) ⊆ V '. Since μ = ρ[V '], μ(s') = ρ(s') = ρσ(s[r]) =
ρσ(s)[ρσ(r)] = α(s)[β(r)] = t'.
Let us prove that μσ = α[V ]. Since μ = ρ[V '] and V ' = (V \ D(σ)) ∪ I(σ), we get by Lemma 3.13, μσ = ρσ[V ], thus μσ = α[V ].
Let us prove that μ satisfies the constraint c' = σ(c)Λσ(cinn)Λσ(cprio). Since the free variables of c, cinn, cprio are in V , the free variables of σ(c)Λσ(cinn)Λσ(cprio) are included in V '. Since μσ = α[V ] and α satisfies c on V , then μ satisfies σ(c). Since α(s)→IP t', α satisfies cinnΛcprio. Since μσ = α[V ], then μ satisfies σ(cinn)Λσ(cprio).

Finally, due to (iii), if α is normalized, μ is also normalized by 3.14.	 
This result can be extended by induction on the number of steps to rewriting derivations:
Proposition 3.20 Let t0 be a term, ρ be a normalized substitution, V ⊆ Y be a

set of variables such that V ar(t0) ∪ D(ρ) ⊆ V . If ρ(t0)→IP
t' ... →IP
t' ,

ω1,l1→r1 1	ωn,ln→rn  n
and if ρ satisﬁes a constraint c0 whose free variables are included in V , there exist normalized substitutions σi(i = 1,..., n), constraints ci(i = 1,..., n) and a ground normalized substitution μ such that:

IP
ω1,l1→r1,σ1
μ(tn) = t' ,
ρ = μσn ... σ1[V ],
μ satisﬁes cn.
IP
ωn,ln→rn,σn
(tn, cn),

Proof The proof is by induction on the length of the derivation.  For n = 1, it comes from Lemma 3.19.  Let us assume the property for n − 1 and consider

ρ(t0)→IP
t' ... →IP
t' . According to Lemma 3.19, for any c0 with free

ω1,l1→r1 1	ωn,ln→rn  n
variables in V such that α satisfies c0, there exists (t0, c0) ~IP	(t1, c1),
β(t1) = t' , βσ1 = ρ[V ] and β satisfies c1. Since β is normalized and satisfies c1, and

since t'
= β(t1)→IP
t' ... →IP
t' , by induction hypothesis, there exist

1	ω2,l2→r2 2	ωn,ln→rn  n
normalized substitutions σi(i = 2,..., n), constraints ci(i = 2,..., n) and a ground normalized substitution μ such that:

IP
ω2,l2→r2,σ2
μ(tn) = t' ,
β = μσn ... σ2[V '],
μ satisfies cn.
IP
ωn,ln→rn,σn
(tn, cn),

where V ' contains V ar(t1) ∪ D(ρ). Since βσ1 = ρ[V ], β = μσn ... σ2[V '] and V \
D(σ1) ∪ I(σ1) ⊆ V ', according to Lemma 3.13, we get ρ = βσ1 = μσn ... σ2σ1[V ]. 
Instantiating the initial constraint by the trivial constraint id which is always true, we get the following corollary.
Corollary 3.21 Let t0 be a term, ρ be a normalized substitution, V ⊆Y be a set of

variables such that V ar(t0) ∪ D(ρ) ⊆ V . If ρ(t0)→IP
t' ... →IP
t' , there

ω1,l1→r1 1	ωn,ln→rn  n
exist normalized substitutions σi(i = 1,..., n), constraints ci(i = 1,..., n) and a ground normalized substitution μ such that:

IP
ω1,l1→r1,σ1
μ(tn) = t' ,
ρ = μσn ... σ1[V ],
μ satisﬁes cn.
IP
ωn,ln→rn,σn
(tn, cn),

Example 3.22 Let us assume the following rules ordered as follows (higher priority

is the smaller label):

pckt(src, dst, estab)	→ accept
pckt(eth0, dst, new)	→ accept
pckt(ppp0, dst, new)	→ drop
pckt(10.1.1.1, ppp0, s) → pckt(123.123.1.1, ppp0, s)
pckt(10.1.1.2, ppp0, s) → pckt(123.123.1.1, ppp0, s)

Let us apply IP-narrowing to the term t = pckt(x, y, new) and the constraint iden- tity. Since new and estab are two different constants, rule 1 does not apply. The substitution σ = (x = eth0 Λ y = y' Λ dst = y') is a mgu with rule 2. Here

c' =  L'→r'∈R 6Var(l'), new /= l' Λ
6src, dst, pckt(etho, y', new) /= pckt(src, dst, estab)

that is equivalent to true. And therefore: t ~IP	accept.
Rule 3 also applies with the substitution σ' = (x = ppp0 Λ y = y'' Λ dst = y'').
Here the constraint is
c' =  L'→r'∈R 6Var(l'), new /= l' Λ
6z, pckt(ppp0, y'', new) /= pckt(eth0, z, new) Λ 6z', z'', pckt(ppp0, y'', new) /= pckt(z', z'', estab)
that is equivalent to true again. And thus t ~IP ' drop. IP-narrowing with rules
and 5 is similar.
We are now ready to apply these results on strategic rewriting and narrowing to rewriting-based policies.
Narrowing-based analysis of rewriting-based policies
In our framework, policy evaluation is performed by strategic rewriting of ground requests. Consequently, for the safe design of security policies, several properties have been identified [14,11].
Definition 4.1 [Termination, Consistency, Decision Completeness] [11] A security policy ℘ = (J, D, R, Q,ζ) is
terminating if for every q ∈ Q, all derivations of source q in ζ are finite.
consistent if for every query q ∈ Q, ζ applied to q returns at most one result:
6q ∈ Q, the cardinality of ζq ∩ D is less than or equal to 1.
decision complete if 6q ∈ Q, Ed ∈ D, such that d ∈ζq.

To deal with policy analysis, we add now the possibility to express queries:
Definition 4.2 [Queries] Given a security policy ℘ = (J, D, R, Q,ζ), a query is a term of 7 (J, Y) where Y is a set of query variables distinct from X . A constrained query is a pair of a term of 7 (J, Y) and a first-order equational constraint.
Based on the previous results of Section 3, we can now analyze the behavior of security policies by solving queries. The method relies on the construction of a narrowing tree for a given query: all possible (strategic) narrowing steps are ap- plied to this term and recursively to the resulting ones, yielding a possibly infinite tree. The general intuitive idea is that the narrowing trees provide a good sim- ulation of the rewriting derivation trees that correspond to requests evaluation of the policy. We make the assumption that the security policy is terminating, in or- der to consider normalized terms, substitutions and instantiations. There are quite powerful techniques to check termination such as recursive path orderings [13], se- mantic labeling [37], dependency pairs [3], etc. These and other techniques have been implemented by several tools that allow to verify termination for a large sets of rewrite systems: for example AProVE [20], TTT [25], and CiME [32], to cite a few. All these verification methods and tools check termination statically, which is very attractive for the specification of flexible policies.
Considering innermost termination in particular, specific methods have been given for instance in [2,19,23]. Techniques have also been studied for termination of outermost rewriting [23], for termination of lazy rewriting [18] or for termination of priority rewriting [35,21]. Moreover it is often possible to prove termination in general (i.e. for the universal strategy), which implies termination under any strategy.
Example 4.3 The policy from Example 2.2 is not decision complete: the request pckt(123.123.1.1, ppp0, new) is not reducible in this system and thus cannot be eval- uated into a decision. If we add to the system the rule
pckt(123.123.1.1, ppp0, new) → accept,
the policy becomes decision complete. In this example, a careful exhaustive explo- ration of all expressible requests and their reduction is possible. However in general, there is no method yet to prove this property formally for IP-rewriting. A promising approach may be found in [17] or [22].
The termination property can be easily checked by analyzing the rules of the policy and giving a simplification ordering > such that l > r for any left- and right- hand sides l, r of rules in R. This guarantees that the evaluation of any request will always terminate on a resulting term.
Consistency is also easily checked on this example since the critical pairs between rule 1 and rules 4 and 5 are convergent. However, note that confluence of IP- rewriting is not needed in the following, but would also require further study.
Thanks to the theoretical results of Section 3 stated both for rewriting and IP- rewriting, the narrowing-based analysis can be performed for IP-rewriting strategies

as well as for universal ones. More generally, whenever simulation of strategic rewriting by strategic narrowing can be established, the approach developed below for policy analysis can be followed. In order to cover IP and universal strategies, we consider in the following a narrowing relation on constrained terms, denoted by
~ for simplicity.

Reachability analysis
Narrowing has been studied in [33] to solve reachability problems in cryptographic protocols verification. The problem is to find all solutions of a reachability goal s→∗t, i.e. substitutions σ such that σ(s)→∗σ(t) with the rewrite system R which is terminating but possibly non-confluent. Narrowing is complete w.r.t. normalized substitutions: for every normalized substitution ρ, a more general solution η can be found by narrowing. The interested reader can refer to [33] to find other complete- ness results for solving reachability goals in particular classes of rewrite systems or of goals. These results can be useful for policy analysis and bear some similarities with the results we present below in the context of policy analysis.

What-if analysis
Let us first consider queries of the form q(x1,..., xn) where q is a term in 7 (J, Y) with variables x1,..., xn ∈ Y.
For a constrained term (u, c), we denote by ⟨u, c⟩ the set {θ(u) | θ ∈ Φ,θ ∈ Sol(c)} where Φ is the set of all ground normalized instances of 7 (J, Y) into 7 (J) and Sol(c) the set of ground normalized solutions of the constraint c.
Proposition 4.4 Let us consider the narrowing tree of the constrained query (q, id).
For every node (u, c) such that (q, id) ~∗ (u, c), all requests ⟨σ(q), c⟩ evaluate to ground instances of u in ⟨u, c⟩, where σ is the composition of normalized narrowing substitutions used in the narrowing derivation.
For any request t reachable by the policy from a request α(q), where α is nor- malized, there exists a node (u, c) in the narrowing tree of (q, id), such that (q, id) ~∗ (u, c) and t = μ(u), with μ normalized and μ satiﬁes c.
Proof
is a direct application of Proposition 3.9 and Corollary 3.18.
directly follows from Proposition 3.11 and Corollary 3.21.


Based on this result, we can make some what-if analysis, as shown on the simple firewall Example 2.2.
Example 4.5 Suppose we want to know which packets get accepted for a new connection. This amounts to solve the query pckt(x, y, new). We get the following

narrowing substitutions with the respective rules:

x = eth0	y = dst
x = ppp0	y = dst
x = 10.1.1.1	y = ppp0 new = s
x = 10.1.1.2	y = ppp0 new = s
x = 123.123.1.1 y = ppp0

giving respectively accept, drop and pckt(123.123.1.1, ppp0, new) twice, which can be reduced (i.e. narrowed with the identity substitution) to accept. These terms are no more narrowable. So possible requests that give an accept decision are
ground instances of pckt(eth0, dst, new)
and the requests
pckt(123.123.1.1, ppp0, new), pckt(10.1.1.1, ppp0, new), pckt(10.1.1.2, ppp0, new).

Analyzing decisions
Another interest of the approach is to provide also a methodology for analyzing the decisions taken by the policy. Let us first state some terminology and definitions. In this whole section, we assume that the policy ℘ is terminating and decisison complete.
A decision term is a ground term of D in normal form. A query pattern is a term p with variables x1,..., xn ∈ Y, that we will write p(x1,..., xn) when we want the variables to be explicit.
Let us assume from now on that the set Q of requests is defined as the set of ground instances of a finite set of query patterns. They are supposed non unifiable, so that in this way, every request is an instance of one query pattern.
The idea is that the narrowing trees built from this finite set of query patterns provide a correct and complete schematization of the request evaluation: correct means that every narrowing derivation represents a set of requests evaluations; com- plete means that every request evaluation is an instance of a narrowing derivation in the narrowing tree of its query pattern.
Then we can state the following results.
Proposition 4.6 (Correctness) For a given security policy ℘ with query patterns, let us consider the narrowing trees of the constrained query patterns (p, id).
If (p, id) ~∗ (u, c), u is a decision term and c is satisﬁable, where σ is the composi- tion of normalized narrowing substitutions, then the set ⟨σ(p), c⟩ is a set of requests leading to the decision u.
Proof This is a consequence of Proposition 4.4(i). Since u is a decision term, it is ground, so ⟨u, c⟩ = {u} provided c is satisfiable.	 
Proposition 4.7 (Completeness) For a given security policy ℘ with query patterns,

for any request q which is a ground normalized instance α of the query pattern p, there exists a narrowing derivation (p, id) ~∗ (u, c) with c satisﬁable, such that the evaluation of q = α(p) gives an instance of u in ⟨u, c⟩.
Proof This is a consequence of Proposition 4.4(ii).	 
Provided decisions are normalized terms (which is trivial when decisions are constants on which no rewrite rule applies), for a security policy ℘ with query patterns, in order to generate all possible requests leading to a given decision, we can collect all the narrowing branches leading to this decision (obviously a leaf since a decision is no more reducible nor narrowable) and consider the union of the composed substitutions along each branch.
Proposition 4.8 For a given security policy ℘ with m query patterns, let us con- sider the narrowing trees of the constrained query patterns (pi, id) for i = 1, ..., m. Let d be a decision that appears in one or more narrowing trees of the constrained

query patterns, say (p1, id) ~∗
(d, c1),..., (pk, id) ~∗
(d, ck) where σ1,...,σk are the

composed (constrained) substitutions. Then the set of ground normalized requests that evaluate to this decision d is ⟨σ1(p1), c1⟩∪ ... ∪ ⟨σk(pk), ck⟩.
Proof By correctness, every set ⟨σi(pi), ci⟩ is a set of requests leading to d. Con- versely, any request is a ground normalized instance of a pattern, and by complete- ness, there exists a narrowing derivation leading to d.	 
One can also prove that a given pattern is not reachable, by trying to unify this pattern with each node. If no node unifies with the pattern, the latter is unreachable. In our framework, this gives the following result:
Proposition 4.9 If a decision d is not an instance of any term u in a node (u, c)
in the narrowing trees, then d is not reachable.
Proof Assume that there exists a request leading to d. Then it would be a ground normalized instance of some pattern p and there would exist a rewriting derivation α(p) −∗→ d, with α ground normalized, and then a node (u, c) such that (p, id) ~∗ (u, c) and d = μ(u), which contradicts the hypothesis.	 
Let us come back to Example 2.2.
Example 4.10 Suppose we want to know which packets get accepted and which are dropped. This amounts to solve the query pckt(x, y, z). We get the following narrowing substitutions with the respective rules:

x = 10.1.1.1 y = ppp0 z = s
x = 10.1.1.2 y = ppp0 z = s

Narrowing with the two first rules transforms the query pckt(x, y, z) into accept, while the third rule transforms the query into drop. Narrowing with the two last rules transforms the query pckt(x, y, z) into pckt(123.123.1.1, ppp0, s). Then in each case a narrowing step can be again applied with the first rule, getting accept with z = estab. The two composed substitutions are (6)(x = 10.1.1.1,y = ppp0,z = estab) and (7)(x = 10.1.1.2,y = ppp0,z = estab).
There is then one more branch in the narrowing tree leading to accept with the substitution (8)(x = 123.123.1.1,y = ppp0,z = new). A complete set of queries leading to the decision accept is given by the set of substitutions {(1), (2), (6), (7), (8)}.
Conclusion
The general context of this research is the design of a foundational framework for the compositional design, maintenance and verification of security policies. The framework initially presented in [14,12] addresses the problem of authoring and analyzing access control policies in a modular way using techniques developed in the field of strategic rewriting. Rewrite rules transform input terms representing access requests into access decision terms. In order to tame the raw computational power of term rewriting and to enhance the agility of the policy specification language, strategies are used to explicitly control the rule application. In this approach, the correspondences between the properties of the rewrite system and the policy it implements are easy to understand, thus we are able to directly apply a rich corpus of existing proof techniques and tools. We have proposed here to use narrowing to contribute to improve the trust of a user or an administrator with respect to a policy, not only at the design stage, but also whenever a policy is updated. However, adapting new concepts such as strategic rewriting or strategic narrowing is yet an ongoing goal which this paper begins to contributes to. Future work concerns fine-tuned analysis tools for policies, especially to formalize and tackle the various strategies used by developers of policies.

References
Alpuente, M., S. Escobar and J. Iborra, Termination of narrowing revisited (2008), preprint submitted to Theoretical Computer Science.
Arts, T. and J. Giesl, Proving innermost normalisation automatically, in: Proceedings 8th Conference on Rewriting Techniques and Applications, Sitges (Spain), Lecture Notes in Computer Science 1232 (1997), pp. 157–171.
Arts, T. and J. Giesl, Termination of term rewriting using dependency pairs, Theoretical Computer Science 236 (2000), pp. 133–178.
Baader, F. and T. Nipkow, “Term Rewriting and all That,” Cambridge University Press, 1998.
Balland, E., P. Brauner, R. Kopetz, P.-E. Moreau and A. Reilles, “Tom Manual,” LORIA, Nancy (France), version 2.4 edition (2006).
Balland, E., P. Brauner, R. Kopetz, P.-E. Moreau and A. Reilles, Tom: Piggybacking rewriting on java, in: F. Baader, editor, RTA, Lecture Notes in Computer Science 4533 (2007), pp. 36–47.
Barker, S. and P. J. Stuckey, Flexible access control policy specification with constraint logic programming, ACM Trans. Inf. Syst. Secur. 6 (2003), pp. 501–546.

Borovansky´, P., C. Kirchner, H. Kirchner and C. Ringeissen, Rewriting with strategies in ELAN: a functional semantics, International Journal of Foundations of Computer Science 12 (2001), pp. 69–98.
Clavel, M., F. Dur´an, S. Eker, P. Lincoln, N. Mart´ı-Oliet, J. Meseguer and C. L. Talcott, Reflection, metalevel computation, and strategies, in: M. Clavel, F. Dur´an, S. Eker, P. Lincoln, N. Mart´ı-Oliet,
J. Meseguer and C. L. Talcott, editors, All About Maude, Lecture Notes in Computer Science 4350
(2007), pp. 419–458.
de Oliveira, A. S., Rewriting-based access control policies, Electr. Notes Theor. Comput. Sci. 171 (2007),
pp. 59–72.
de Oliveira, A. S., “R´e´ecriture et modularit´e pour les politiques de s´ecurit´e,” Ph.D. thesis, UHP Nancy 1 (2008).
de Oliveira, A. S., E. K. Wang, C. Kirchner and H. Kirchner, Weaving rewrite-based access control policies, in: FMSE ’07: Proceedings of the 2007 ACM workshop on Formal methods in security engineering (2007), pp. 71–80.
Dershowitz, N., Termination of rewriting, Journal of Symbolic Computation 3 (1987), pp. 69–116.
Dougherty, D. J., C. Kirchner, H. Kirchner and A. S. de Oliveira, Modular access control via strategic rewriting, in: Proceedings of 12th European Symposium On Research In Computer Security (ESORICS’07), Dresden, 2007, pp. 578–593.
Escobar, S. and J. Meseguer, Symbolic model checking of infinite-state systems using narrowing, in:
F. Baader, editor, Term Rewriting and Applications. 18th International Conference, RTA 2007, Lecture Notes in Computer Science 4533, 2007.
Fay, M., First order unification in equational theories, in: Proceedings 4th Workshop on Automated Deduction, Austin (Tex., USA), 1979, pp. 161–167.
Fissore, O., I. Gnaedig and H. Kirchner, A proof of weak termination providing the right way to terminate, in: Proceedings of the First International Conference on Theoretical Aspects of Computing ICTAC’2004, Lecture Notes in Computer Science 3407 (2004), pp. 356–371.
Giesl, J., S. Swiderski, P. Schneider-Kamp and R. Thiemann, Automated Termination Analysis for Haskell: From term rewriting to programming languages., in: Proceedings of the 17th International Conference on Rewriting Techniques and Applications, 2006, pp. 297–312.
Giesl, J., R. Thiemann, P. Schneider-Kamp and S. Falke, Improving dependency pairs, in: Proceedings of the 10th International Conference on Logic for Programming, Artificial Intelligence and Reasoning, Lecture Notes in Artificial Intelligence 2850 (2003), pp. 165–179.
Giesl, J., R. Thiemann, P. Schneider-Kamp and S. Falke, Automated termination proofs with AProVE, in: V. van Oostrom, editor, RTA, Lecture Notes in Computer Science 3091 (2004), pp. 210–220.
Gnaedig, I., Termination of Priority Rewriting, in: A. Dediu, M. Ionescu and C. Martin-Vide, editors, Proceedings of the 3rd International Conference on Language and Automata Theory and Applications, Lecture Notes in Computer Science (2009), preliminary version published as HAL-INRIA Open Archive Number inria-00243131. Available at http://hal.inria.fr/inria-00243131/en/.
Gnaedig, I. and H. Kirchner, Narrowing, abstraction and constraints for proving properties of reduction relations, in: H. Comon-Lundh, C. Kirchner and H. Kirchner, editors, Rewriting, Computation and Proof. Essays Dedicated to Jean-Pierre Jouannaud on the Occasion of His 60th Birthday, Lecture Notes in Computer Science 4600 (2007), pp. 44–67.
Gnaedig, I. and H. Kirchner, Termination of rewriting under strategies, ACM Transactions on Computational Logic 10 (2009), 56 p. Preliminary version as HAL-INRIA Open Archive Number INRIA-00113156.
Gouda, M. G. and A. X. Liu, Structured firewall design, Computer Networks 51 (2007), pp. 1106–1120.
Hirokawa, N. and A. Middeldorp, Tyrolean termination tool: Techniques and features, Inf. Comput.
205 (2007), pp. 474–511.
Hullot, J.-M., Canonical forms and unification, in: W. Bibel and R. Kowalski, editors, Proceedings 5th International Conference on Automated Deduction, Les Arcs (France), Lecture Notes in Computer Science 87 (1980), pp. 318–334.
Jajodia, S., P. Samarati, M. L. Sapino and V. S. Subrahmanian, Flexible support for multiple access control policies., ACM Trans. Database Syst. 26 (2001), pp. 214–260.
Kirchner, C., F. Kirchner and H. Kirchner, Strategic computations and deductions, in: Festchrift in honor of Peter Andrews, Studies in logic and the foundations of mathematics, Elsevier, 2008 .

Kirchner, C. and H. Kirchner, Rewriting, solving, proving, A preliminary version of a book available at
www.loria.fr/~ckirchne/rsp.ps.gz (1999).
Kirchner, C., H. Kirchner and M. Vittek, Designing constraint logic programming languages using computational systems, in: P. Van Hentenryck and V. Saraswat, editors, Principles and Practice of Constraint Programming. The Newport Papers., The MIT press, 1995 pp. 131–158.
Klop, J. W., Term Rewriting Systems, , 1, Oxford University Press, 1990 .
March´e, C. and X. Urbain, Modular and incremental proofs of ac-termination, J. Symb. Comput. 38
(2004), pp. 873–897.
Meseguer, J. and P. Thati, Symbolic reachability analysis using narrowing and its application to verification of cryptographic protocols, Higher-Order and Symbolic Computation 20 (2007), pp. 123– 160.
Middeldorp, A. and E. Hamoen, Completeness results for basic narrowing, Journal of Applicable Algebra in Engineering, Communication and Computing 5 (1994), pp. 213–253.
Mohan, C. K., Priority rewriting: Semantics, confluence, and conditionals, in: N. Dershowitz, editor, Proceedings 3rd Conference on Rewriting Techniques and Applications, Chapel Hill (N.C., USA), Lecture Notes in Computer Science 355 (1989), pp. 278–291.
Visser, E., Stratego: A language for program transformation based on rewriting strategies. System description of Stratego 0.5, in: A. Middeldorp, editor, Rewriting Techniques and Applications (RTA’01), Lecture Notes in Computer Science 2051 (2001), pp. 357–361.
Zantema, H., Termination of term rewriting by semantic labelling, Fundam. Inform. 24 (1995), pp. 89– 105.
