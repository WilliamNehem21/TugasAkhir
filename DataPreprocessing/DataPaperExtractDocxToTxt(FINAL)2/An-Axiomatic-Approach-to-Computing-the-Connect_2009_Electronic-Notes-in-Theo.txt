

Electronic Notes in Theoretical Computer Science 230 (2009) 79–102
www.elsevier.com/locate/entcs

An Axiomatic Approach to Computing the Connectivity of Synchronous and Asynchronous Systems
(Preliminary Version)

Maurice Herlihy 1
Department of Computer Science, Brown University Providence, RI 02912, USA
Sergio Rajsbaum 2
Instituto de Matema´ticas, UNAM Ciudad Universitaria, D.F. 04510, Mexico
Mark Tuttle3
HP Labs
One Cambridge Center, Cambridge, MA 02142, USA

Abstract
We present a unified, axiomatic approach to proving lower bounds for the k-set agreement problem in both synchronous and asynchronous message-passing models. The proof involves constructing the set of reachable states, proving that these states are highly connected, and then appealing to a well-known topological result that high connectivity implies that set agreement is impossible. We construct the set of reachable states in an iterative fashion using a round operator that we define, and our proof of connectivity is an inductive proof based on this iterative construction and simple properties of the round operator.
Keywords: Fault-tolerance, consensus, set agreement, synchronous, asynchronous, topology.


Introduction
The consensus problem [18] has received a great deal of attention. In this prob- lem, n + 1 processors begin with input values, and all must agree on one of these

1 Email: mph@cs.brown.edu
2 Email: rajsbaum@math.unam.mx. Partly supported by a PAPIIT-UNAM grant.
3 Email: mark.tuttle@hp.com

1571-0661/© 2009 Published by Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.02.018

values as their output value. Fischer, Lynch, and Paterson [7] surprised the world by showing that solving consensus is impossible in an asynchronous system if one processor is allowed to fail. This leads one to wonder if there is any way to weaken consensus to obtain a problem that can be solved in the presence of k−1 failures but not in the presence of k failures. Chaudhuri [5] defined the k-set agreement prob- lem and conjectured that this was one such problem, and a trio of papers [4,13,19] proved that she was right. The k-set agreement problem is a generalization of con- sensus, where we relax the requirement that processors agree on a single value: the set of output values chosen by the processors may contain as many as k distinct values, and not just 1.
Set agreement (and in particular consensus) has been studied in both syn- chronous and asynchronous models of computation, but mostly independently. In- deed, prior proofs for these models appeared to have little in common, as reflected by the organization of a main textbook in the area [14], where the first part is devoted to synchronous systems and the second part of the book to asynchronous systems. Recent work has been uncovering more and more features and structure in common to both models [8,12,15,16]. However, these results are in the form of transformations between models, or proofs that have a similar structure in both models. Only [15] describes an abstract model that encompasses both models, with clearly identified properties that are needed to carry out consensus impossibility results. To go from consensus to set agreement a big step in complexity is encoun- tered, since one must deal with higher dimensional topology instead of just graphs, as discovered by the trio of papers [4,13,19] mentioned above. The contribution of this paper is to present a new axiomatic approach were set consensus impossibility proofs can be derived in a uniform manner for both synchronous and asynchronous models.
All known proofs for the set agreement lower bound depend — either explicitly or implicitly — on a deep connection between computation and topology. These proofs essentially consider the simplicial complex representing all possible reachable states of a set agreement protocol, and then argue about the connectivity of this complex. These lower bounds for set agreement follow from the observation that set agreement cannot be solved if the complex of reachable states is sufficiently highly-connected. This connection between connectivity and set agreement has been established both in a generic way [11] and in ways specialized to particular models of computation [1,4,6,10,11,12,19]. Once the connection has been established, however, the problem reduces to reasoning about the connectivity of a protocol’s reachable complex.
The primary contribution of this work is a new, substantially simpler proof of how the connectivity of the synchronous and asynchronous complexes evolve over time. Our proof depends on two key insights:
The notion of a round operator that maps a global state to the set of global states reachable from this state by one round of computation, an operator satisfying a few simple algebraic properties.
The notion of an absorbing poset organizing the set of global states into a

partial order, from which the connectivity proof follows easily using the round operator’s algebraic properties.
We believe this new approach has several novel and elegant features. First, we are able to isolate a small set of elementary combinatorial properties of the round operator that suffice to establish the connection with classical topology in a model- independent way. Second, these properties require only local reasoning about how the computation evolves from one round to the next. Finally, most connectivity arguments can be difficult to follow because they mix semantic, combinatorial, and topological arguments. Those arguments are cleanly separated here. The round operator definition relies on semantics: it is a combinatorial restatement of the properties of the synchronous model. Once the round operator is defined, however, we no longer appeal to properties of the original model. We reason in a purely com- binatorial way about intersections of global states, and how they can be placed in a partial order. Once these combinatorial arguments are in place, we appeal directly to well-known theorems of topology to establish connectivity. These topology theo- rems are treated as “black boxes,” in the sense that we apply them directly without any need to make additional topological arguments. Furthermore, our absorbing posets are very similar to shellable complexes [3], yet one more link between the work of topologists and distributed computing.
Most of our proofs appear in the appendix.

Preliminaries
Models
We consider two (standard) message-passing models, the synchronous and asyn- chronous models. In both models, we restrict our attention to computations with a round structure: the initial state of each processor is its input value, and com- putation proceeds in a sequence of rounds. In each round, each processor sends messages to other processors, receives messages sent to it by the other processors in that round, performs some internal computation, and changes state. We assume that processors are following a full-information protocol, which means that each processor sends its entire local state to every processor in every round. This is a standard assumption to make when proving lower bounds. A processor can fail by crashing in the middle of a round, in which case it sends its state only to a subset of the processors in that round. Once a processor crashes, it never sends another message after that.
In the synchronous model [2,14], all processors execute round r at the same time, and processor P fails to receive a message from processor Q, then Q must have crashed, either in that round or in the previous round.
In the asynchronous model, there is no bound on processor step time nor on message delivery time, so a crashed processor cannot be distinguished from a slow processor. Our results, however, depend only on the unbounded message delivery time. Since our goal is to prove impossibility results, we are free to restrict our






 


Fig. 1. A global state S and the set S1(S) of global states after one round from S.
attention to executions in which processors take steps at a regular pace, and only message delivery times are delayed. In the behaviors we consider, messages from one processor to another are delivered in FIFO order, but when one message from P to Q is delivered, all outstanding messages from P to Q are delivered at the same time.
It is convenient to recast the asynchronous model in the following omissions- failure form. In each round, at most f processors exhibit faulty behavior, although
this set may change from round to round. In each round, the nonfaulty processors broadcast their states to all processors (including the faulty processors). Each faulty processor broadcasts its state to some subset of the processors, and may omit to send to the others. Processors never crash. It can be shown that k-set agreement lower bounds in this omissions failure model carry over to the standard asynchronous crash-failure model; see [9] for a similar argument.

Combinatorial Topology
We represent the local state of a processor with a vertex labeled with that processor’s id and its local state. We represent a global state as a set of labeled vertexes, labeled with distinct processors, representing the local state of each processor in that global state. In topology, a simplex is a set of vertexes, and a complex is a set of simplexes that is closed under containment. The dimension of a simplex is equal to its number of vertexes minus one. Applications of topology to distributed computing often assume that these vertexes are points in space and that the simplex is the convex hull of these points in order to be able to use standard topology results. As you read this paper, you might find it helpful to think of simplexes in this way, but in the purely combinatorial work done in this paper, a simplex is just a set of vertexes.
As an example, consider the simplex and complex illustrated in Figure 1. On the left side, we see a simplex representing an initial global state in which proces- sors P , Q, and R start with input values 0, 2, and 1. Each vertex is labeled with

a processor’s id and its local state (which is just its input value in this case). On the right we see a complex representing the set of states that arise after one round of computation from this initial state in the synchronous model if one processor is allowed to crash. The labeling of the vertexes is represented schematically by a processor id such as P and a string of processor ids such as P Q. The string PQ is intended to represent the fact that P heard from processors P and Q during the round but not from R, since R failed that round. (We are omitting input values on the right for notational simplicity.) The simplexes that represent states after one round are the 2-dimensional triangle in the center and the 1-dimensional edges that radiate from the triangle (including the edges of the triangle itself). The central triangle represents the state after a round in which no processor fails. Each edge represents a state after one processor failed. For example, the edge with vertexes labeled P ; PQR and Q; PQ represent the global state after a round in which R fails by sending a message to P and not sending to Q: P heard from all three processors, but Q did not hear from R.
What we do in this paper is define round operators like the round operator S1
that maps the simplex S on the left of Figure 1 to the complex S1(S) on the right, and then reason about the connectivity of S1(S). Informally, connectivity in dimension 0 is just ordinary graph connectivity, and connectivity in higher di- mensions means that there are no “holes” of that dimension in the complex. When we reason about connectivity, we often talk about the connectivity of a simplex S when we really mean the connectivity of the induced complex consisting of S and all of its faces. For example, both of the complexes in Figure 1 are 0-connected since they are connected in the graph-theoretic sense. In fact, the complex on the left is also 1-connected, but the complex on the right is not since there are “holes” formed by the three cycles of 1-dimensional edges.
Given a simplex S, a labeling of S from a set V is a new simplex constructed by replacing each vertex s of S with a pair (s, v), where v ∈ V .
Given a simplex S and a set V , we define the pseudosphere P(S, V ) to be this set of labelings of S with elements of V . (We call P(S, V ) a pseudosphere because is has some of the topological properties of a sphere.) The face S is called the base simplex of the pseudosphere, and given a simplex T of a pseudosphere P(S, V ), we define base(T ) to be the base simplex S of the pseudosphere.
The input complex for k-set agreement is P(S, V ), the pseudosphere in which each vertex is labeled with an input from a set V , where |V | > k. The set of all reachable states of a protocol P with initial states P(S, V ) is the protocol com- plex C = C(P(S, V )). The fundamental connection between k-set agreement and connectivity is expressed in the following theorem (e.g. [11]):
Theorem 2.1 Let P be a protocol, and let C be its protocol complex. If C is (k− 1)- connected, then P cannot solve k-set agreement.
Thus, our main task will be to prove that C is (k − 1)-connected. Proving that a union of complexes is connected is made easier by the following theorem 4 . Notice

4 Actually this theorem is a well-known corollary of the Mayer-Vietoris sequence, which is described in

that if A and B are complexes then both A ∪ B and A ∩ B are complexes.
Theorem 2.2 (Mayer-Vietoris) Let A, B be two complexes. Then A ∪ B is c- connected if A and B are c-connected and A ∩ B is (c − 1)-connected.
Think about the special one-dimensional case of this statement: a graph that is the union of subgraphs A, B is 0-connected (connected in the graph theoretic sense) if A and B are 0-connected and A ∩ B is −1-connected (nonempty).
To prove that a complex C is c-connected, we split C into subcomplexes with less and less simplexes, and apply repeatedly the Mayer-Vietoris theorem. At the bottom of this recursion, we get complexes with just one simplex, and use the following fact.
Theorem 2.3 A simplex of dimension at least l is (l − 1)-connected.
In this paper all we need to assume from topology is the previous two theorems. Both are very basic algebraic topology facts that appear in standard textbooks such as [17,20].
Absorbing Posets and Round Operators
The codimension of two simplexes S0 and S1 is a measure of how much they have in common defined by
codim(S0, S1) = max {dim(Si) − dim(∩jSj)}
i

where dim(∅) = −1 is the dimension of the empty simplex. Two useful properties of this definition are that if S ⊆ T then
codim(S, T ) = dim(T ) − dim(S),
and if S ⊆ X ⊆ T then
codim(S, T ) = codim(S, X)+ codim(X, T ).

Let S be a nonempty set of simplexes, and ≤ a partial order on S.
Definition 3.1 We say that (S, ≤) is an absorbing poset if for every two simplexes S
and T in S with T /≤ S there is a TS in S, TS ≤ T such that
S ∩ T ⊆ TS ∩ T	(1)
codim(TS,T ) = 1	(2)
codim(S ∩ T, TS) ≤ codim(S, T ).	(3)

The first two properties say that when considering pairwise intersections of sim- plexes — as we will frequently do in our Mayer-Vietoris arguments — pairs of high

most algebraic topology textbooks; see for example [20] Chapter 4, Section 6.

codimension are “absorbed” by pairs of low codimension, and we can restrict our attention to pairs of simplexes of codimension one. The third property just says that TS satisfies the same property that S and T do, namely, codim(S ∩ T, X) ≤ codim(S, T ) for X = S, T . An absorbing poset is almost equivalent to a shellable complex [3]. In a shellable complex, Equations 2 and 3 apply only to principal faces (“facets”) of the complex, while our construction allows one simplex in S to be a proper face of another. It follows that every absorbing poset induces a shellable complex, but not vice-versa.
Lemma 3.2 If A is a set of simplexes such that every pair of simplexes has codi- mension 1, then (A, <) is an absorbing poset, where < is any total order on A.
Proof. For any simplexes S and T in A such that S < T , pick TS = S. Substi- tuting S for TS, it is easy to check that the three conditions of Definition 3.1 are satisfied:
S ∩ T ⊆ S ∩ T
codim(S, T ) = 1 
codim(S ∩ T, S) ≤ codim(S, T ).



Axioms
A simplicial operator Q is a family of maps. Each map Ql carries a simplex of dimension m ≥ l to a nonempty set of simplexes, where each simplex has dimension at most m. The subscript l is the operator’s degree. For l < 0, it is convenient to define Ql(S) to be the empty set. Note that Ql(∅) = ∅ for all l, and Q0(S) /= ∅ for any nonempty simplex S.
Simplicial operators extend naturally to sets of simplexes. If A is a set of sim- plexes,
Ql(A) =	Ql(A).	(4)
A∈A
The semantic interpretation of simplicial operators varies from model to model. In the synchronous message-passing model, l is the number of processors that can crash in each round. In the asynchronous model, l is the number of processors that remain partially silent in each round.
We use QkQl(S) to denote the composition of Qk and Ql applied to S, Qr(S) to denote the r-fold composition of Ql applied to S, and Qr(S)  to denote the simplicial complex induced by the set Qr(S) (i.e., closed under containment).
We assume that simplicial operators satisfy the following axioms. The first axiom says that the states reachable after the failure of l processors are reachable after the failure of even more processors.
Axiom 3.3
Ql(S) ⊆ Qm(S)
when l ≤ m.

The second axiom describes multi-round executions. We introduce a model- specific, nonnegative, integer-valued linear function φ. Informally, φ(f ) is the num- ber of failures needed in a round to hide the existence of f faulty processors. We will see that in the synchronous model, faulty processors crash, so φ(f ) = 0. In the asynchronous model, faulty processors fail to send messages, so φ(f ) = f .
Axiom 3.4 Let k ≥ l, and let S ⊆ T , where c = codim(S, T ). For all r > 0,
for all S' ∈ Qr	Ql−c(S), there exists T ' ∈ Qr Ql(T )
such that S' ⊆ T ' and codim(S',T') ≤ c.

Executions from initial state T in which the processes not in S are silenced at every round look the same to processes in S as executions with fewer failures in which the silenced processes do not participate.
Axiom 3.5 Let k ≥ l. For all r > 0, if c = codim(S0, S1),
 Qr Ql(S0)  ∩ Qr Ql(S1)  ⊆ Qr	Ql−c(S0 ∩ S1)  .
k	k	k−φ(c)
The right-hand-side of this equation is the set of states for processors that cannot tell whether the initial state was S0 or S1. The processors that can tell the difference must be silenced in the first round, requiring an extra c failures, and must be kept silent for the remaining rounds, requiring φ(c) extra failures in each subsequent round.
The last axiom says there is a partial order such that
Axiom 3.6 For every simplex S, Ql(S) is an absorbing poset.
Theorems and Lemmas
The following is an immediate condequence of Axiom 3.4.
Lemma 4.1 Let i ≥ j. For all r > 0, if S ⊆ T ,
 QrQj(S)  ⊆ Qr	Qj+c(T ) 


where c = codim(S, T ).
i	i+φ(c)

Lemma 4.2 Let k ≥ l. For all r > 0, if c = codim(S0, S1),
 Qr Ql(S0)  ∩ Qr Ql(S1)  =  Qr	Ql−c(S0 ∩ S1)  .
k	k	k−φ(c)
Proof. The “⊆” direction is immediate from Axiom 3.5. Because S0 ∩ S1 ⊆ S1, and codim(S0 ∩ S1, S1) ≤ c, Axiom 3.4 implies that


r k−φ(c)
Ql−c(S0 ∩ S1)   ⊆ Qr Ql(S0)  ,

and symmetrically for  Qr Ql(S1)  .	 

Lemma 4.3 If (S, ≤) is an absorbing poset, and S, T , and TS are deﬁned as in Deﬁnition 3.1, then
codim(S ∩ T, TS ∩ T ) < codim(S, T ).
Proof. Because S ∩T ⊆ TS ∩T , codim(S ∩T, TS ∩T ) is just the number of vertexes in TS ∩ T but not in S ∩ T .
There are two cases to consider. First, suppose there is a vertex in T but not in TS. It follows that
codim(S ∩ T, TS ∩ T ) < codim(S ∩ T, T ) ≤ codim(S, T ).

Second, suppose instead that T ⊂ TS. Because T and TS are distinct, there is vertex in TS but not in T . It follows that
codim(S ∩ T, T ) < codim(S ∩ T, TS).

By Equation 3,
codim(S ∩ T, TS) ≤ codim(S, T ).
Combining these inequalities yields the bound.	 
The next lemma states that every state reachable with a certain number of failures is also reachable with more failures.
Lemma 4.4
QrQk(S) ⊆ QrQm(S).
j	l
when j ≤ l and k ≤ m.
Proof. We argue by induction on r ≥ 0. When r = 0, the claim follows from Axiom 3.3.
Suppose r > 0.  Since Qr−1Qk(S) ⊆ Qr−1Qm(S) by the induction hypothesis,
j	l
we have
QrQk(S) = QjQr−1Qk(S) ⊆ QjQr−1Qm(S) ⊆ QlQr−1Qm(S) = QrQm(S).
j	j	l	l	l
 
Lemma 4.5 Let (S, ≤) be an absorbing poset, and let T ∈S be a maximal simplex with respect to ≤. We claim that the following sets are both absorbing posets: (L, ≤), where L = {L|L ∈S − {T}}, and (M, ≤), where M = {T}.
Lemma 4.6 Let (A, ≤) be an absorbing poset containing more than one simplex, and let A ∈A be a maximal simplex with regards to ≤. For each B /= A in A, there exists a AB ∈A satisfying the three conditions of Deﬁnition 3.1. We claim that the set
B = {AB ∩ A|B ∈ A− {A}}
is an absorbing poset for any total order < on the elements of A− {A}

Lemma 4.7 If every simplex in Qr Ql(A) has dimension at least d, then so does
every simplex in A.
Lemma 4.8 Let Qr Ql be a composition of simplicial operators where k ≥ l. If (S, ≤
) is an absorbing poset then for every two simplexes S and T in S with T /≤ S there is a TS in S with TS ≤ T , such that
 Qr Ql(S)  ∩ Qr Ql(T )  ⊆ Qr Ql(TS)  ∩ Qr Ql(T ) 
k	k	k	k
codim(TS,T ) = 1 
codim(S ∩ T, TS) ≤ codim(S, T ).
Lemma 4.9 If (A, ≤) is an absorbing poset where l is the minimum dimension of any simplex in A, then A is (l − 1)-connected.
Theorem 4.10 Let Qr Ql be a composition of simplicial operators where k ≥ l, and
(A, ≤) an absorbing poset. If every simplex in Qr Ql(A) has dimension at least l,
then Qr Ql(A)  is (l − 1)-connected.
The Synchronous Model
We assume a standard synchronous message-passing model with crash failures [2,14]. The system has n + 1 processors, and at most f of them can crash in any given execution. Each processor begins in an initial state consisting of its input value, and computation proceeds in a sequence of rounds. In each round, each processor sends messages to other processors, receives messages sent to it by the other processors in that round, performs some internal computation, and changes state. We assume that processors are following a full-information protocol, which means that each processor sends its entire local state to every processor in every round. This is a standard assumption to make when proving lower bounds. A processor can fail by crashing in the middle of a round, in which case it sends its state only to a subset of the processors in that round. Once a processor crashes, it never sends another message after that
A simplex X is between two simplexes T and R if T ⊆ X ⊆ R. We use [T : R] to denote the set of simplexes between T and R.
Definition 5.1 Given simplexes S, T , and R, the pseudosphere P(S, [T : R]) is the set of all possible labelings of S with simplexes between T and R.
We call this set a pseudosphere because the induced complex has some of the topological properties of a sphere. The simplex S is called the base simplex of the pseudosphere, and given a simplex X of a pseudosphere P(S, [T : R]), we define base(X) to be S.
Given a simplex S and a set D of processors, let F = S/D be the face of S obtained from S by deleting the vertexes labeled with processors in D. The set of states reachable from S by one round of synchronous computation in which the processors in D fail can be represented by the pseudosphere P(F, [F : S]), the set of all possible labelings of F with simplexes between F and S.

Next, we define the failure operator. Given a simplex S and an integer l ≥ 0, the l-failure operator Fl(S) maps S to the set of all faces F of S with codim(F, S) ≤ l, which is the set of all faces obtained by deleting at most l vertexes from S. This models the sets of at most l processors that can fail in one round of computation from S.
Definition 5.2 For every integer l ≥ 0, the synchronous round operator Sl(S) is defined by

Sl(S) = 
F∈FÆ(S)
P(F, [F : S]).

We now check that the synchronous round operator satisfies our axioms.
Lemma 5.3 Sl satisﬁes Axiom 3.3:
Sl(S) ⊆ Sm(S)
when l ≤ m.
Proof. Since l ≤ m implies Fl(S) ⊆ Fm(S), it follows that


Sl(S) = 
F∈FÆ(S)
P(F, [F : S]) ⊆
F∈Fm(S)
P(F, [F : S]) = Sm(S).



In this model, the integer-valued linear function φ is simply φ(f ) = 0.
Lemma 5.4 Sl satisﬁes Axiom 3.4: Let k ≥ l, and let S ⊆ T , where c = codim(S, T ). For all r > 0,
for all S' ∈ Sr	Sl−c(S), there exists T ' ∈ SrSl(T )
such that S' ⊆ T ' and codim(S',T') ≤ c.
Lemma 5.5 Sl satisﬁes Axiom 3.5: Let k ≥ l. For all r > 0, if c = codim(S0, S1),
 SrSl(S0)  ∩ SrSl(S1)  ⊆ SrSl−c(S0 ∩ S1)  .
k	k	k
To show that Sl satisfies Axiom 3.6, we impose a partial order on simplexes of Sl(S). Recall that

Sl(S) = 
F∈FÆ(S)
P(F, [F : S]).

This expression suggests a lexicographic order. We will combine a total order on simplexes F in Fl(S) with a partial order on simplexes of each P(F, [F : S]).
We assume a total order ≤id on processor ids, which induces a total order on the vertexes of a simplex. We begin by imposing a lexicographic total order on the faces F of S. First we order the faces by decreasing dimension, so that large faces occur before small faces. Then we order faces of the same dimension with a rather arbitrary rule based on our total order on processor ids: we order F before G if the

smallest processor id labeling vertexes in F and not G comes before the smallest processor id labeling G and not F . Formally:
Definition 5.6 Define the total order <ƒ on the faces of a simplex S by F <ƒ G if
dim(F ) > dim(G) or
dim(F ) = dim(G) and pF <id pt where
pF = min {ids(F ) − ids(G)}	and	pt = min {ids(G) − ids(F )} .
Define F ≤ƒ G if F <ƒ G or F = G.
Next we order the simplexes in a pseudosphere P(F, [F : S]) using the following face ordering: we order A before B if, for each vertex v of the base simplex F , the face of S labeling v in A comes before the face of S labeling v in B. Formally:
Definition 5.7 Define the partial order ≤p on the simplexes of a pseudosphere P(F, [F :
S]) by A ≤p B if and only if Av ≤ƒ Bv for each vertex v in F , where Av and Bv are the simplexes labeling the vertex v in A and B.
Now we order Sl(S) lexicographically using the face and pseudosphere orders: we order the simplexes in a pseudosphere P(F, [F : S]) before the simplexes in a pseudosphere P(G, [G : S]) if F is ordered before G in the face ordering, and we order the simplexes within a single pseudosphere using the pseudosphere ordering. Formally:
Definition 5.8 Define the partial order ≤r on the simplexes in Sl(S) by A ≤r B
if and only if
different pseudospheres: base(A) <ƒ base(B) or
same pseudosphere: base(A) = base(B) and A ≤p B
Theorem 5.9 Sl satisﬁes Axiom 3.6: For every simplex S, (Sl(S), ≤r) is an ab- sorbing poset.
Theorem 5.10 Assume n + 1 ≥ f + k + 1. No synchronous protocol for k-set agreement halts in fewer than [f/k♩ +1 rounds in the presence of f crash failures.
Proof. Suppose there is a protocol that halts in fewer than [f/k♩ + 1 rounds, and assume without loss of generality that it halts in exactly r = [f/k♩ rounds in every execution. Consider the subset of executions in which at most k processors halt in every round. For the input complex P(S, V ), the set of final states of such executions is Sr(P(S, V )). Every simplex in this complex has dimension at least k. By Theorem 4.10, this complex is (k − 1)-connected, and by Theorem 2.1, the protocol cannot solve k-set agreement.	 
Asynchronous Model
Informally, the asynchronous round operator Al(S) is defined as follows. There are at most l faulty processors in each round, although the set of faulty processors

can change from round to round. Faulty processors never crash, but they can omit sending messages. In each round, all nonfaulty processors send their states to all the processors (including faulty ones), while the faulty processors send messages to an arbitrary subset of processors (perhaps none).
Definition 6.1 For every integer l ≥ 0, the asynchronous round operator Al(S) is defined by

Al(S) = 
F∈FÆ(S)
P(S, [F : S]).

The difference between the synchronous and asynchronous round operators is that every pseudosphere has the same base simplex S in the definition of the asyn- chronous operator. Notice that S and every simplex in Al(S) have the same dimen- sion. With the asynchronous round operator, every processor in S (not just those labeling a face F of S) is labeled with states that include all nonfaulty processors and some subset of faulty processors.
We now check that the asynchronous round operator satisfies our axioms.
Lemma 6.2 Al satisﬁes Axiom 3.3:
Al(S) ⊆ Am(S)
when l ≤ m.
Proof. Since l ≤ m implies Fl(S) ⊆ Fm(S), it follows that


Al(S) = 
F∈FÆ(S)
P(S, [F : S]) ⊆
F∈Fm(S)
P(S, [F : S]) = Am(S).



In this model, the integer-valued linear function φ is simply φ(f ) = f .
Lemma 6.3 Al satisﬁes Axiom 3.4: Let k ≥ l, and let S ⊆ T , where c =
codim(S, T ). For all r > 0,
for all S' ∈ Ar	Al−c(S), there exists T ' ∈ Ar Al(T )
such that S' ⊆ T ' and codim(S',T') ≤ c.
Lemma 6.4 Al satisﬁes Axiom 3.5: Let k ≥ l. For all r > 0, if c = codim(S0, S1),
 Ar Al(S0)    ∩ Ar Al(S1)    ⊆ Ar	Al−c(S0 ∩ S1)  .
k	k	k−c
To show that Al satisfies Axiom 3.6, we impose a partial order on simplexes of Al(S). Recall that

Al(S) = 
F∈FÆ(S)
P(S, [F : S]).

If F' ⊆ F , then P(S, [F ' : S]) ⊆ P(S, [F : S]), so we can restrict our attention to faces of codimension l. Unlike in the synchronous model, where simplexes have

varying dimensions, all simplexes in this set are labelings of S, and all have dimen- sion n.
We use the same total order ≤id on processor ids, the same total order <ƒ on
the faces of a simplex S. Next we order the simplexes in Al(S) using this face ordering: we order A before B if, for each vertex v of the base simplex S the face of F labeling v in A comes before the face of F labeling v in B. Formally:
Definition 6.5 Define the partial order ≤p on the simplexes of Al(S) by A ≤p B if and only if Av ≤ƒ Bv for each vertex v in S, where Av and Bv are the simplexes labeling the vertex v in A and B.
Theorem 6.6 Al satisﬁes Axiom 3.6: For every simplex S, (Al(S), ≤p) is an ab- sorbing poset.
Theorem 6.7 No asynchronous protocol for k-set agreement exists in the presence of k crash failures.

References
Hagit Attiya and Sergio Rajsbaum. The combinatorial structure of wait-free solvable tasks. In Proceedings of the 10th International Workshop on Distributed Algorithms, volume 1151 of Lecture Notes in Computer Science, pages 322–343. Springer-Verlag, October 1996.
Hagit Attiya and Jennifer Welch. Distributed Computing: Fundamentals, Simulations and Advanced Topics. McGraw–Hill, 1998.
Anders Bj¨orner and Michelle L. Wachs. Shellable nonpure complexes and posets, i. Transactions of the American Mathematical Society, 348(4):1299–1327, 1996.
E. Borowsky and E. Gafni. Generalized flp impossibility result for t-resilient asynchronous computations. In Proceedings of the 1993 ACM Symposium on Theory of Computing, May 1993.
S. Chaudhuri. Agreement is harder than consensus: Set consensus problems in totally asynchronous systems. In Proceedings Of The Ninth Annual ACM Symosium On Principles of Distributed Computing, pages 311–234, August 1990.
Soma Chaudhuri, Maurice Herlihy, Nancy A. Lynch, and Mark R. Tuttle. Tight bounds for k-set agreement. Journal of the ACM (JACM), 47(5):912–943, 2000.
M. Fischer, N.A. Lynch, and M.S. Paterson. Impossibility of distributed commit with one faulty process.
Journal of the ACM, 32(2), April 1985.
Eli Gafni. Round-by-round fault detectors (extended abstract): unifying synchrony and asynchrony. In Proceedings of the seventeenth annual ACM symposium on Principles of distributed computing, pages 143–152. ACM Press, 1998.
Maurice Herlihy and Lucia D. Penso. Tight bounds for k-set agreement with limited scope failure detectors. In Faith Fich, editor, Distributed Computing, 17th International Conference, DISC 2003, Sorrento, Italy, October 1-3, 2003 Proceedings, volume 2848 of Lecture Notes in Computer Science, pages 279–291. Springer, 2003.
Maurice Herlihy and Sergio Rajsbaum. Set consensus using arbitrary objects. In Proceedings of the 13th Annual ACM Symposium on Principles of Distributed Computing, pages 324–333, August 1994.
Maurice Herlihy and Sergio Rajsbaum. Algebraic spans. Mathematical Structures in Computer Science, 10(4):549–573, August 2000. Special Issue: Geometry and Concurrency.
Maurice Herlihy, Sergio Rajsbaum, and Mark R. Tuttle. Unifying synchronous and asynchronous message-passing models. In Proceedings of the seventeenth annual ACM symposium on Principles of distributed computing, pages 133–142. ACM Press, 1998.
Maurice Herlihy and Nir Shavit. The topological structure of asynchronous computability. Journal of the ACM (JACM), 46(6):858–923, 1999.

Nancy Lynch. Distributed Algorithms. Morgan Kaufmann, 1996.
Yoram Moses and Sergio Rajsbaum. A layered analysis of consensus. SIAM Journal of Computing (SICOMP), 31(4):989–1021, 2002.

Achour Most´efaoui, Sergio Rajsbaum, and Michel Raynal. The synchronous condition-based consensus hierarchy. In Rachid Guerraoui, editor, Distributed Computing, 18th International Conference, DISC 2004, Amsterdam, Netherlands, October 4-8, 2004 Proceedings, Lecture Notes in Computer Science. Springer, 2004.
J.R. Munkres. Elements Of Algebraic Topology. Addison Wesley, Reading MA, 1984. ISBN 0-201- 04586-9.
M. Pease, R. Shostak, and L. Lamport. Reaching agreement in the presence of faults. J. ACM, 27(2):228–234, 1980.
Michael Saks and Fotios Zaharoglou. Wait-free k-set agreement is impossible: The topology of public knowledge. SIAM Journal on Computing, 29(5):1449–1483, 2000.
E.H. Spanier. Algebraic Topology. Springer-Verlag, New York, 1966.

Proofs from Section 4
Lemma 4.5 Let (S, ≤) be an absorbing poset, and let T ∈ S be a maximal simplex with respect to ≤. We claim that the following sets are both absorbing posets: (L, ≤), where L = {L|L ∈S − {T}}, and (M, ≤), where M = {T}.
Proof. Because (S, ≤) is an absorbing poset, for every S in L, there is TS ∈ S such that TS ≤ T and satisfying the three absorbing poset conditions. Because T was chosen to be a maximal element of S and since TS ≤ T , it follows that TS ∈ S− {T} = L.
The singleton set {T} is trivially an absorbing poset.	 
Lemma 4.6 Let (A, ≤) be an absorbing poset containing more than one simplex, and let A ∈ A be a maximal simplex with regards to ≤. For each B /= A in A, there exists a AB ∈ A satisfying the three conditions of Definition 3.1. We claim that the set
B = {AB ∩ A|B ∈ A− {A}}
is an absorbing poset for any total order < on the elements of A− {A}
Proof. For any two distinct simplexes B0 and B1 in B, codim(B0, B1) = 1, and the claim follows from Lemma 3.2.	 
Lemma 4.7  If every simplex in Qr Ql(A) has dimension at least d, then so does
every simplex in A.
Proof. By induction on r.	When r = 0, for every A in A and B in Ql(A), dim(B) ≤ dim(A) by the definition of simplicial operators.
When r > 1, Qr Ql(A) = Qk(Qr−1Ql(A)). By the definition of a simplicial
k	k
operator Qk, every simplex in Qr−1Ql(A) has dimension at least d since every simplex in Qk(Qr−1Ql(A)) does. By the induction hypothesis, every simplex in A has dimension at least d since every simplex in Qr−1Ql(A) does.	 

Lemma 4.8  Let Qr Ql be a composition of simplicial operators where k ≥ l. If (S, ≤) is an absorbing poset then for every two simplexes S and T in S with T /≤ S there is a TS in S with TS ≤ T , such that
 Qr Ql(S)  ∩ Qr Ql(T )  ⊆ Qr Ql(TS)  ∩ Qr Ql(T ) 
k	k	k	k
codim(TS,T ) = 1 
codim(S ∩ T, TS) ≤ codim(S, T ).
Proof. Because (S, ≤) is an absorbing poset, for every two simplexes S and T in S with T /≤ S there is a TS in S with TS ≤ T satisfying Equations 1, 2, and 3. By Lemma 4.2,
 Qr Ql(S)  ∩ Qr Ql(T )  =  Qr	Ql−c(S ∩ T )  .
k	k	k−φ(c)
where c = codim(S, T ).
Let d = codim(S ∩ T, TS ∩ T ). By Lemma 4.1, and linearity of φ,


r k−φ(c)
Ql−c(S ∩ T )  ⊆ Qr
Ql−c+d(TS ∩ T )  .

By Lemma 4.3, d < c, so l − c + d ≤ l − 1 and k − φ(c − d) ≤ k − φ(1) since φ is nonnegative. By Lemma 4.4,


r k−φ(c−d)
Ql−c+d(TS ∩ T )    ⊆ Qr
Ql−1(TS ∩ T )  .

By Lemma 4.2,
 Qr	Ql−1(TS ∩ T )  =  Qr Ql(TS)  ∩ Qr Ql(T ) 
k−φ(1)	k	k
Combining these inclusions yields the desired result.	 
Lemma 4.9 If (A, ≤) is an absorbing poset where l is the minimum dimension of any simplex in A, then  A is (l − 1)-connected.
Proof. Suppose that A contains m simplexes. We argue by induction on m. When
m = 1, a single simplex of dimension at least l is (l − 1)-connected (Theorem 2.3).
Suppose m > 1 and the induction hypothesis holds for m − 1. Let T be a maximal element of A with respect to ≤, and let
L = {S|S ∈ A− {T}}	and	M = {T} .
By Lemma 4.5, both L and M are absorbing posets. By construction, each has fewer than m simplexes, all of which have dimension at least l. It follows from the induction hypothesis that complexes  L and  M are each (l − 1)-connected
We now claim that  L∩  M is (l− 2)-connected. Since (A, ≤) is an absorbing poset, for every L in L, there exists a TL in L such that
L ∩ T ⊆ TL ∩ T
codim(TL,T ) = 1.

Let N = {TL ∩ T |L ∈ L}. Note that N  =  L ∩ M. Lemma 4.6 implies that N is an absorbing poset containing fewer than m simplexes. By hypothesis, every simplex in Qr Ql(A) has dimension at least l. Because L⊆ A, so does every simplex in Qr Ql(L). By construction, for every simplex N in N , there is a simplex TS ∈L such that codim(N, TS) ≤ 1. Axiom 3.4 implies that for every simplex N' in

r k−φ(1)
Ql(N ), there exists a simplex L' in Qr Ql(L) such that codim(N', L') ≤ 1.

In particular, dim(N') ≥ l − 1, so every simplex in Qr	Ql(N ), has dimension
at least l− 1. The induction hypothesis for m implies that Qr	Ql(N ) is (l− 1)-
connected.
We have shown that L and M are each (l − 1)-connected, and  L ∩ M
is (l − 2) connected, so  L ∪ M is (l − 1)-connected by Mayer Vietoris.	 

Theorem 4.10 Let Qr Ql be a composition of simplicial operators where k ≥ l, and (A, ≤) an absorbing poset. If every simplex in Qr Ql(A) has dimension at
least l, then  Qr Ql(A)  is (l − 1)-connected.

Proof. We prove a stronger induction hypothesis: If k ≥ l ≥ lˆ and every simplex in Qr Ql(A) has dimension at least lˆ, then  Qr Ql(A)  is (lˆ− 1)-connected. Since
k	k
Qr Ql is an r + 1 fold composition of simplicial operators, we can view the case of r +1 = 0 or r = −1 as the special case of no operators at all: Qr Ql(A) = A. We argue by induction on r ≥ −1. When r = −1, the claim follows from Lemma 4.9.
Suppose r ≥ 0 and the induction hypothesis holds for r − 1. We argue by induction on m, the number of simplexes in A. When m = 1, let A be the unique simplex in A. If B = Ql(A), then

Qr Ql(A) = Qr (B) = Qr−1Qk(B).
k	k	k

The set B is an absorbing poset by Axiom 3.6. Since k ≥ k ≥ lˆand every simplex in
Qr−1Qk(B) = Qr (B) = Qr Ql(A) has dimension at least lˆ, the induction hypothesis
k	k	k
for r implies that Qr Ql(A) = Qr (B) = Qr−1Qk(B) is (lˆ− 1)-connected.
k	k	k
Suppose m > 1 and the induction hypothesis holds for m' < m. Let T be a maximal element of A with respect to ≤, and let

L = {S|S ∈ A− {T}}	and	M = {T} .

By Lemma 4.5, both L and M are absorbing posets, each containing fewer than m simplexes, all of dimension at least lˆ. It follows from the induction hypothesis for m that complexes  Qr Ql(L)  and  Qr Ql(M)  are each (lˆ− 1)-connected.

k
We now show that
k


 Qr Ql(L)  ∩ Qr Ql(M) 

k	k

is (lˆ− 2)-connected. Notice that

 Qr Ql(L)  ∩ Qr Ql(M)  =     Qr Ql(S)   ∩ Qr Ql(T ) 

=   (  Qr Ql(S)  ∩ Qr Ql(T )  ) .

Because (A, ≤) is an absorbing poset, Lemma 4.8 implies that for every S in L there is a TS in L such that
 Qr Ql(S)  ∩ Qr Ql(T )  ⊆ Qr Ql(TS)  ∩ Qr Ql(T ) 
k	k	k	k
codim(TS,T ) ≤ 1.

It follows that

 Qr Ql(L)  ∩ Qr Ql(M)  =   (  Qr Ql(S)  ∩ Qr Ql(T )  )





and it is easy to see that
 k		 k	
S∈L


  (  Qr Ql(TS)  ∩ Qr Ql(T )  ) ⊆   (  Qr Ql(S)  ∩ Qr Ql(T )  )

=  Qr Ql(L)  ∩ Qr Ql(M) 
k	k

since every TS is in L, so

 Qr Ql(L)  ∩ Qr Ql(M)  =   (  Qr Ql(TS)  ∩ Qr Ql(T )  )



with codim(TS,T ) = 1 for each TS. By Lemma 4.2,
  (  Qr Ql(TS)  ∩ Qr Ql(T )  ) =    Qr




Ql−1(TS ∩ T )  .

Let N = {TS ∩ T |S ∈ L}.


S ∈L 

r k−φ(1)
Ql−1(TS ∩ T )  =  Qr

Ql−1(N )  .

Lemma 4.6 states that N is an absorbing poset. Moreover, N is an absorbing poset containing fewer than m simplexes, where each simplex has dimension at least lˆ− 1. It follows that we can apply the induction hypothesis for m to deduce

r k−φ(1)
Ql−1(N )  is (lˆ− 2)-connected.

We have shown that Qr Ql(L)  and Qr Ql(M)  are each (lˆ− 1)-connected,
k	k
and that  Qr Ql(L)  ∩ Qr Ql(M)  is (lˆ− 2)-connected, so their union
k	k

 Qr Ql(L)  ∪ Qr Ql(M)  =  Qr Ql(A) 
k	k	k
is (lˆ− 1)-connected by Mayer-Vietoris.	 

Proofs from Section 5
Lemma 5.4  Sl satisfies Axiom 3.4: Let k ≥ l, and let S ⊆ T , where c =
codim(S, T ). For all r > 0,

for all S' ∈ Sr	Sl−c(S), there exists T ' ∈ SrSl(T )
such that S' ⊆ T ' and codim(S',T') ≤ c.

Proof. We show the stronger property that

SrSl−c(S) ⊆ SrSl(T ).
k	k
We argue by induction on r. Let r = 0. If A ∈ Sl−c(S), then A is a labeling of F
with simplexes in [F : S] for some face F of S satisfying codim(F, S) ≤ l − c.
codim(F, T ) = codim(F, S)+ codim(S, T )
≤ (l − c)+ c = l.

It follows that A ∈ Sl(T ).
Let r > 0. If A ∈ SrSl−c(S), then there is a B ∈ Sr−1Sl−c(S) such that A is a
k	k
labeling of F with simplexes in [F : B] for some face F of B satisfying codim(F, B) ≤
By the induction hypothesis, B ∈ Sr−1Sl(T ). Moreover, codim(F, B) ≤ k. It follows that A ∈ SrSl(T ).	 
Lemma 5.5 Sl satisfies Axiom 3.5: Let k ≥ l. For all r > 0, if c = codim(S0, S1),
 SrSl(S0)  ∩ SrSl(S1)  ⊆ SrSl−c(S0 ∩ S1)  .
k	k	k
Proof. We argue by induction on r that if A0 ∩ A1 is nonempty for Ai in SrSl(Si), then there exists an A in SrSl−c(S0 ∩ S1) such that A0 ∩ A1 ⊆ A and dim(A) = 
max {dim(A0), dim(A1)}.
Suppose r = 0. Each Ai is a labeling of a face Fi of Si by simplexes in [Fi : Si] where codim(Fi, Si) ≤ l. Their intersection A0 ∩A1 is a labeling of a face of F0 ∩F1 by simplexes in [F0 ∪F1 : S0 ∩S1]. (Because A0 ∩A1 is nonempty, F0 ∪F1 ⊆ S0 ∩S1.) Denote the simplex S0 or S1 of maximal dimension by Ss, and denote the simplex A0 or A1 of maximal dimension by Aa, which implies that Fa is the base simplex F0 or F1 of maximal dimension. We can extend this labeling A0 ∩ A1 of this face of F0 ∩ F1 to a labeling A of the maximal base simplex Fa by labeling each unlabeled

vertex with F0 ∪ F1. We know that F0 ∪ F1 is a face of S0 ∩ S1, so Fa is a face of
S0 ∩ S1 which is a face of Ss, and we have
codim(Fa, Ss) = codim(Fa, S0 ∩ S1)+ codim(S0 ∩ S1, Ss) = codim(Fa, S0 ∩ S1)+ c so
codim(Fa, S0 ∩ S1) = codim(Fa, Ss) − c
= (dim(Ss) − dim(Fa)) − c ≤ (dim(Ss) − dim(Fs)) − c
= codim(Fs, Ss) − c ≤ l − c.
It follows that A ∈ Sl−c(S0 ∩ S1), and dim(A) = max {dim(A0), dim(A1)} by con- struction.
Suppose r > 0. There exist Bi ∈ Sr−1Sl(Si) such that each Ai is a labeling of a face Fi of Bi by simplexes in [Fi : Bi] where codim(Fi, Bi) ≤ k. A0 ∩A1 is a labeling of a face of F0 ∩ F1 by simplexes in [F0 ∪ F1 : B0 ∩ B1]. (Because A is nonempty, F0 ∪F1 ⊆ B0 ∩B1.) Denote the simplex B0 or B1 of maximal dimension by Bb, and denote the simplex A0 or A1 of maximal dimension by Aa, which implies that Fa is the base simplex F0 or F1 of maximal dimension. By the induction hypothesis, there exists B ∈ Sr−1Sl−c(S0 ∩ S1) such that B0 ∩ B1 ⊆ B and dim(B) = dim(Bb). We can extend this labeling A0 ∩ A1 of this face of F0 ∩ F1 to a labeling A of the maximal base simplex Fa by labeling each unlabeled vertex with F0 ∪ F1. We know that F0 ∪ F1 is a face of B0 ∩ B1 ⊆ B, so Fa is a face of a face of B and Bb, and we have
codim(Fa, B) = dim(B) − dim(Fa)
= dim(Bb) − dim(Fa) ≤ dim(Bb) − dim(Fb)
= codim(Fb, Bb) ≤ k.
So A ∈ Sk(B) ∈ SrSl−c(S0 ∩ S1), and dim(A) = max {dim(A0), dim(A1)} by con- struction.	 
Theorem 5.9 Sl satisfies Axiom 3.6: For every simplex S, (Sl(S), ≤r) is an ab- sorbing poset.
Proof. Let A and B be two simplexes in Sl(S) satisfying B /≤r A. We consider two cases depending on whether A and B are in the same pseudosphere or not.
Case 1 : Suppose A and B are in the same pseudosphere P(F, [F : S]) for some
face F of S. The simplexes A and B are labelings of F with simplexes between F and S, so let Av and Bv denote the label of vertex v in A and B for every vertex v ∈ F . There must be some vertex v with Av <ƒ Bv since B /≤r A. Notice that the face Bv must not be the entire simplex S, since S is ordered before every proper face of S, including Av. Let BA be B with the label of v changed from Bv to S, and notice that BA and B are in the same pseudosphere. We have BA ≺r B since the label of v in BA is ordered before the label of v in B, and the labels of all other vertices are equal. We have A∩B ⊆ BA since v is not in A∩B due to the conflicting

labels for v, while all other vertexes of B and hence of A ∩ B are in BA. We have codim(BA, B) = 1 since BA and B differ only in the label of v. Finally, since A ∩ B is a face of both BA and B, and since BA and B have the same dimension, we have
codim(A ∩ B, BA) = dim(BA) − dim(A ∩ B)
= dim(B) − dim(A ∩ B)
≤ max {dim(A) − dim(A ∩ B), dim(B) − dim(A ∩ B)}
= codim(A, B)

Case 2 : Suppose A and B are in different pseudospheres P(FA, [FA : S]) and P(FB, [FB : S]) for distinct faces FA and FB of S. First, we can assume without loss of generality that every vertex of B −A is labeled with S, since if there is any vertex of B − A that is not labeled with S, then we can take BA to be B with this label replaced by S, and it is easy to check that BA ≺r B, A ∩ B ⊆ BA, codim(B, BA) = 1, and codim(A ∩ B, BA) ≤ codim(A, B). Second, the two base simplexes of A and B must be ordered FA <ƒ FB since B /≤r A. Let us consider the two cases induced by the ordering FA <ƒ FB.
Case 2a: Suppose dim(FA) > dim(FB). Since dim(FA) > dim(FB), the set FA−FB must be nonempty, so choose any vertex v ∈ FA−FB. Since A ∈ P(FA, [FA : S]), the simplex A must be a labeling of FA with simplexes between FA and S. Since v is a vertex of FA, this means that v appears in all simplexes labeling A, and hence in all simplexes labeling A ∩ B. Since we have assumed that S is the label of every vertex in B − A, and since S certainly contains the vertex v, the vertex v appears in all labels of B − A. It follows that v appears in every simplex labeling B. Let BA be the simplex consisting of B together with the vertex v labeled with S, and notice that BA is a simplex in Sl(S). We have BA ≺r B since dim(BA) = dim(B)+1 > dim(B). We have A ∩ B ⊆ BA since A ∩ B ⊆ B ⊆ BA. We have codim(B, BA) = 1 since B and BA differ only in v. Finally, since A ∩ B is a face of both B and BA, and since dim(BA) = dim(B)+1 ≤ dim(A), we have
codim(A ∩ B, BA) = dim(BA) − dim(A ∩ B)
≤ dim(A) − dim(A ∩ B)
≤ max {dim(A) − dim(A ∩ B), dim(B) − dim(A ∩ B)}
= codim(A, B).

Case 2b: Suppose dim(FA) = dim(FB), in which case we have pA ≺p pB where pA = min {ids(FA) − ids(FB)} and pB = min {ids(FB) − ids(FA)}. Let vA and vB be the vertexes for processors pA and pB in the faces FA and FB of S. Let FC be the face of S obtained from FB by replacing vB with vA, and let C be the labeling of FC obtained by labeling vA with S and every other vertex with its label in B. Since A is a labeling of FA with simplexes between FA and S, and since vA is a vertex of FA, the vertex vA appears in every simplex labeling A and hence A∩B; and since we are assuming that every vertex of B − A is labeled with S which certainly contains vA, it follows that every vertex of B − A is labeled with a simplex containing vA; and

hence it follows that every label in B contains FC. It follows that C ∈ Sl(S) since C is a labeling of a face FC of S with simplexes between FC and S. We have C ≺r B since
min {ids(FC) − ids(FB)} = pA ≺p pB = min {ids(FB) − ids(FC)} .
We have A ∩ B ⊆ C and codim(B, C) = 1, and we have
codim(A ∩ B, C) = dim(C) − dim(A ∩ B)
= dim(B) − dim(A ∩ B)
≤ max {dim(A) − dim(A ∩ B), dim(B) − dim(A ∩ B)}
= codim(A, B).

Taking BA = C, we are done.	 

Proofs from Section 6
Lemma 6.3  Al satisfies Axiom 3.4: Let k ≥ l, and let S ⊆ T , where c =
codim(S, T ). For all r > 0,

for all S' ∈ Ar	Al−c(S), there exists T ' ∈ Ar Al(T )
such that S' ⊆ T ' and codim(S',T') ≤ c.

Proof. We must show that every simplex A ∈ Ar	Al−c(S) is a face of simplex
B ∈ Ar Al(T ) of codimension at most c.
We argue by induction on r. Let r = 0. If A ∈ Al−c(S), then A is a labeling of S with simplexes in [F : S] for some face F of S satisfying codim(F, S) ≤ l − c. Extend A to a labeling B of T by labeling each remaining vertex with F . Since F is a face of S which is in turn a face of T , we have
codim(F, T ) = codim(F, S)+ codim(S, T )
≤ (l − c)+ c = l.

It follows that A ⊆ B ∈ Al(T ) with codimension at most c.
Let r > 0. By the induction hypothesis, every simplex A ∈ Ar−1Al−c(S) is a face of simplex B ∈ Ar−1Al(T ) where codim(A, B) ≤ c. Every simplex A' in Ak−c(B) is a labeling of A with simplexes in [F : A], where codim(F, A) ≤ k − c.
Extend A' to a labeling B' of B by labeling each remaining vertex with F . We know that
codim(F, B) = codim(F, A)+ codim(A, B),
and that codim(F, A) ≤ k − c. Because A is a face of B we have
codim(A, B) = dim(B) − dim(A)
= dim(T ) − dim(S) ≤ c.

The second equality follows from the fact that the asynchronous round operator does not decrease dimension. It follows that codim(F, B) ≤ k, so A' ⊂ B' ∈ Ar Al(Si), and codim(A', B') ≤ c.	 
Lemma 6.4 Al satisfies Axiom 3.5: Let k ≥ l. For all r > 0, if c = codim(S0, S1),

 Ar Al(S0)    ∩ Ar Al(S1)    ⊆ Ar	Al−c(S0 ∩ S1)  .
k	k	k−c
Proof. We argue by induction on r that if A0 ∩ A1 is nonempty for simplexes Ai
in Ar Al(Si), then there exist simplexes A' in Ar Al(Si) with codim(A' , A' ) = c,
k	i	k	0	1
A0 ∩A1 ⊆ A' ∩A' , dim(Ai) = dim(A' ) for each i, and A' ∩A' ∈ Ar	Al−c(S0 ∩S1).
0	1	i	0	1	k−c
Let r = 0. Each Ai is a labeling of Si by simplexes in [Fi, Si], where codim(Fi, Si) ≤
The intersection A0 ∩ A1 is a labeling of some S ⊆ S0 ∩ S1 by simplexes in [F0 ∪F1, S0 ∩S1]. We can extend this labeling of S ⊆ Si to a labeling A' of Si by la- beling the vertexes in (S0 ∩S1) −S with F0 ∪F1 and the remaining vertexes with Si. Notice that these labelings agree on S0 ∩S1 and differ on the remaining vertexes, so codim(A' , A' ) = codim(S0, S1) = c. Notice also that dim(Ai) = dim(Si) = dim(A' )
0	1	i
and that A0 ∩ A1 ⊆ A' ∩ A' by construction. Finally, the simplex A' ∩ A' is a
labeling of S0 ∩ S1 by simplexes of [F0 ∪ F1 : S0 ∩ S1]. Because

codim(F0 ∪ F1, Si) = codim(F0 ∪ F1, S0 ∩ S1)+ codim(S0 ∩ S1, Si),

codim(F0 ∪ F1, S0 ∩ S1) ≤ l − c. It follows that A' ∩ A' ∈ Al−c(S0 ∩ S1).
0	1
Suppose r > 0. Ai is a labeling of a simplex Bi ∈ Ar−1Al(Si) by simplexes in [Fi : Bi] where codim(Fi, Bi) ≤ k. By the induction hypothesis, there exist
simplexes B' ∈ Ar−1Al(S0) such that, codim(B' , B' ) = c, B0 ∩ B1 ⊆ B' ∩ B' ,
i	k	0	1	0	1
dim(Bi) = dim(B') for each i, and B' ∩ B' ∈ Ar−1Al−c(S0 ∩ S1).
i	0	1	k−c
The intersection A0 ∩ A1 is a labeling of some B ⊆ B0 ∩ B1 ⊆ B' ∩ B' by
simplexes in [F0 ∪ F1, B0 ∩ B1].  We can extend this labeling of B ⊆ B' to a
labeling A' of B' by labeling the vertexes in (B' ∩ B' ) − B with F0 ∪ F1 and the
i	i	0	1
remaining vertexes with B'. Notice that these labelings agree on B' ∩ B' and differ
i	0	1
on the remaining vertexes, so codim(A' , A' ) = codim(B' , B' ) = c.  Notice also
0	1	0	1
that dim(Ai) = dim(Bi) = dim(B') = dim(A' ) and that A0 ∩ A1 ⊆ A' ∩ A' by
i	i	0	1
construction. Finally, the simplex A' ∩ A' is a labeling of B' ∩ B' by simplexes
0	1	0	1
of [F0 ∪ F1 : B0 ∩ B1] and therefore of [F0 ∪ F1 : B' ∩ B' ]. Because Bi and B'
0	1	i
have the same dimension by hypothesis, codim(Fi, B') = codim(Fi, Bi) ≤ k. Thus
codim(F0 ∪ F1, B') ≤ k, and
codim(F0 ∪ F1, B') = codim(F0 ∪ F1, B' ∩ B' )+ codim(B' ∩ B' , B'),
i	0	1	0	1	i

implying that codim(F0∪F1, B' ∩B' ) ≤ k−c. It follows that A' ∩A' ∈ Ar
Al−c(S0∩

0	1	0	1	k−c
S1).	 
Theorem 6.6 Al satisfies Axiom 3.6: For every simplex S, (Al(S), ≤p) is an absorbing poset.

Proof. Let A and B be two simplexes in Al(S) satisfying B /≤p A. Let Av and Bv denote the label of vertex v in A and B for every vertex v ∈ S. There must be some vertex v with Av <ƒ Bv since B /≤p A. Notice that the face Bv must not be the entire simplex S, since S is ordered before every proper face of S, including Av. Let BA be B with the label of v changed from Bv to S, and notice that BA and B are in the same pseudosphere. We have BA ≤p B since the label of v in BA is ordered before the label of v in B, and the labels of all other vertices are equal. Equation 1 is satisfied: A∩B ⊆ BA ∩B since v is not in A∩B due to the conflicting labels for v, while all other vertexes of B and hence of A∩ B are in BA. Equation 2 is satisfied: codim(BA, B) = 1 since BA and B differ only in the label of v. Finally, Equation 3 is satisfied: since A∩B is a face of both BA and B, and since BA and B have the same dimension,
codim(A ∩ B, BA) = dim(BA) − dim(A ∩ B)
= dim(B) − dim(A ∩ B)
≤ max {dim(A) − dim(A ∩ B), dim(B) − dim(A ∩ B)}
= codim(A, B)
 
Theorem 6.7 No asynchronous protocol for k-set agreement exists in the presence of k crash failures.
Proof. Suppose there is a protocol that halts in r rounds. Consider the subset of executions in which at most k processors are silent in each round. For the input complex P(S, V ), the set of final states of such executions is Ar (P(S, V )). Every simplex in this complex has dimension n > k. By Theorem 4.10, this complex is (k− 1)-connected, and by Theorem 2.1, the protocol cannot solve k-set agreement. 
