	Electronic Notes in Theoretical Computer Science 176 (2007) 139–163	
www.elsevier.com/locate/entcs

A Local Graph-rewriting System for Deciding Equality in Sum-product Theories
Jos´e Bacelar Almeida1, Jorge Sousa Pinto2 and Miguel Vila¸ca3

Departamento de Inform´atica / CCTC Universidade do Minho
4710-057 Braga, Portugal

Abstract
In this paper we give a graph-based decision procedure for a calculus with sum and product types. Al- though our motivation comes from the Bird-Meertens approach to reasoning algebraically about functional programs, the language used here can be seen as the internal language of a category with binary products and coproducts. As such, the decision procedure presented has independent interest.
A standard approach based on term rewriting would work modulo a set of equations; the present work proposes a simpler approach, based on graph-rewriting. We show in turn how the system covers reflection equational laws, fusion laws, and cancellation laws.
Keywords: Graph-based decision procedure, point-free programming


Introduction
The point-free style of programming [3] has been defended as a good choice for reasoning about functional programs, as it avoids reference to variables. Instead, programs are constructed by a pure first order language over a basic set of combina- tors, whose semantics is given by a set of equations. The equality of two programs is established by constructing derivations in the corresponding equational theory. This ought to be compared with the pointwise approach, where programs are terms of an appropriate λ-calculus. The notion of equality induced by β-reduction is not sufficient for establishing that two programs behave equally (i.e. produce the same result when applied to equal arguments), which motivates the inclusion of extensionality into the reduction relation.

1 Email:jba@di.uminho.pt
2 Email:jsp@di.uminho.pt
3 Email:jmvilaca@di.uminho.pt

1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2006.10.031

The correspondence between point-free languages and extensional λ-calculi is well-known from Categorical Logic [10]. In fact both may be seen as different axiomatizations for the universal properties of categorical constructs: in the former, axioms are given in terms of morphisms, and in the latter in terms of elements (Plotkin [11] appropriately calls these “external” and “internal” axiomatizations).
In this paper, we consider a fragment containing only binary products and co- products. Due to the lack of exponentials, this fragment has very little compu- tational power. Nevertheless, the problem of deciding equality already exhibits interesting subtleties, since the interplay between products and coproducts forces certain equalities that must traditionally be handled by working modulo an equiv- alence relation [12,6].
We propose a decision procedure for equality, using a local graph-rewriting sys- tem. Our approach is based on the point-free presentation of the theory – the graphs are essentially data-flow representations for terms, with composition corresponding to an edge linking together two graphs. It is shown that this perspective effectively overcomes the need to consider an external equivalence.

Related Work.
The exact subject of this work has already been addressed in [12], where the au- thors describe a deductive system for categories with finite products and coproducts, which corresponds precisely to the theories under consideration here. A procedure for checking equality of morphisms is established in two steps: (i) a standard rewrit- ing system is studied and proved to be strongly normalizing and confluent modulo an appropriate equational theory E, and (ii) an algorithm is given for deciding equality under E.
Also related is the work of Ghani [6] on an extensional lambda-calculus with sums (sums had been considered earlier [5,4] with restricted versions of the exten- sionality axiom). Once again, decidability is established in two steps: a strongly normalizing reduction relation and a procedure for checking a ‘commuting’ conver- sion of (quasi-)normal forms. More recently, Altenkirch and colleagues [1] have used
a normalization by evaluation approach for solving the same problem. Although the
latter approach does not rely on rewriting, it shares with the work presented here the fact that normal forms do not correspond to terms, since they are computed in a distinctive semantic domain.
Our work also has similarities with work on optimal implementations of the
λ-calculus [2,8], and in particular to the use of safe operators that allow for the application of non-interaction rules (i.e. rules involving ports that are not principal) in an indexed, local graph-rewriting system. We remark however that the reasons for introducing indices are totally unrelated in both works.

Structure of the Paper.
The paper is organized as follows: Section 2 presents the sum-product theory. Section 3 defines sum-product nets, and Section 4 gives a translation of terms into these nets; Section 5 introduces informally the principles of our graph-rewriting

system. The main results of the paper appear in Section 6, where the system is formally defined and its properties are studied. We conclude in Section 7.
The Term Language and Theory
Consider the following language TPF for types and terms:
Type ::= A | Type × Type | Type + Type
Term ::= CA,A | idType | Term · Term | ⟨Term, Term⟩ | π1Type,Type |
π2Type,Type | [Term, Term] | i1Type,Type | i2Type,Type
where A ranges over a set of base types and CA,A is a set of constant functions (we assume that the sets in this indexed family are pairwise disjunct – thus a constant symbol uniquely determines its indexing types).
To each term we associate a domain and a codomain type – we denote f : A →
B the assertion that term f has domain A and codomain B. The typing rules associated to the language are the following


cA,B ∈ CA,B		
cA,B : A → B		idA : A → A f : A → C	g : B → C
f : A → B	g : B → C

g · f : A → C


[f, g] : (A + B) → C	π1A,B : (A × B) → A	π2A,B : (A × B) → B
f : A → B	g : A → C


⟨f, g⟩ : A → (B × C)	i1A,B : A → (A + B)	i2A,B : B → (A + B)
In the following, when referring to a term we assume its well-typedness. We will omit the type superscripts, which can be inferred from the context.
The type constructors × and + are characterized through their universal prop- erties, which may in turn be captured by the following set of equations:


This presentation of the equational theory is standard in the field of Algebraic Programming [3]. In the λ-calculus perspective, cancellation laws are β-equalities, and the reflection and fusion laws together are equivalent to η-equalities. For prod- ucts for instance, η-equality would be written as f = ⟨π1 ·f, π2 ·f⟩, also known as surjective pairing.
Deciding equality under the theory defined by these equations requires producing a decision procedure. The standard way to accomplish this would be to orient the equations to obtain a confluent, terminating rewriting system (by means of a

completion process). This method fails for this system, for reasons that will be hinted at when we explain our proposed solutions in Section 5. It will become clear that the factorization of the η rules is useful since it allows to treat independently issues raised by reflection and by fusion, which are of different natures.

Sum-product Nets
Sum-product Nets will be built from an alphabet of symbols; each symbol has an associated arity and co-arity. We introduce these symbols in dual pairs where the arity and co-arity are exchanged:
a makepair symbol with arity 2 and co-arity 1, depicted (, ); its dual choice is depicted ?;
two pair projection symbols with arity 1 and co-arity 1, depicted π1 and π2; their duals are the choice injections depicted i1 and i2;
an eraser symbol with arity 1 and co-arity 0, depicted ε; the dual co-eraser is
depicted  .
for every natural number n, a cancel symbol with arity and co-arity 1, depicted
 n; its dual co-cancel is depicted □n.
for every pair of natural numbers (n1, n2), a duplicator symbol with arity 1 and co-arity 2, depicted ∧(n1,n2); its dual is the co-duplicator, depicted ∨(n1,n2);
A node is a triple (s, I, O) where s is a symbol with arity as and co-arity cs, I is a set of input ports, and O is a set of output ports such that the number of elements of I (resp. O) is as (resp. cs).
A net is a tuple (S, E, Iˆ, Oˆ) where
S is a set of nodes; let IS = S	I and OS = S	O;
Iˆ, Oˆ are respectively the sets of input ports and output ports of the net;
E : OS ∪ Iˆ → IS ∪ Oˆ is a bijection. Pairs (o, i) ∈ E are called edges of the net.
A net is well-typed if there exists a labelling of the input and output ports of each of its nodes with a type, such that every edge connects equally labelled ports, and the constraints shown in Figure 1 hold for every node (capital letters denote type variables).
A position is a pair of non-negative integers (a, b), depicted as a· b. A net is well-formed if there exists a labelling of the input and output ports of each of its nodes with a position, such that every edge connects equally labelled ports, and the constraints also shown in Figure 1 hold for every node (S n denotes the successor of n). Well-formedness imposes a structural invariant on nets.
Definition 3.1 A sum-product net is an acyclic, well-typed and well-formed net with a single input and output.
Indices in sum-product nets will be used to control the duplication and mutual annihilation of nodes in the reduction system presented in section 6. Non-indexed



a·Sb
a·Sb

a·b	a·b

a·b

a·b


a·Sb

		

a·b
a·b
a·b
a·Sb
a·Sb
a·b


a·b

a·b	a·b

Sa·b

Sa·b



a·b






Sa·b


Sa·b

a·b

a·b

a·b
a·b

Sa·b


Fig. 1. Typing and Positioning Constraints

Fig. 2. Examples of Nets
or zero-indexed nodes – 0 for (co-)cancel, or (0, 0) for (co-)duplicators – will be called ground, and their indices will often be omitted. Figure 2 contains examples of nets that are not sum-product nets: the first net is not well-typed; the second is not well-formed; the third net has a cycle.

Term nets
In this section we give a type-directed translation T(·) from terms of TPF into sum-product nets.
The translation will already solve a confluence problem that is inherent to reflec- tion laws: taking the multiplicative sub-system, the orientation left to right seems sensible, but the reflection law creates unsolvable critical pairs. To illustrate this, consider the following derivation of surjective pairing
f = id · f = ⟨π1, π2⟩ · f = ⟨π1 ·f, π2 ·f⟩
Both extremes of the equality chain are in normal form with respect to the rewrite system obtained, thus it fails to be complete. The problem is that the rule resulting from orienting the reflection law drops structural information from the term that is essential for the confluence of the system – ⟨π1, π2⟩ is certainly more informative than id, since the type of the latter is more general.
The graph-rewriting system defined in the next sections always preserves the

structural information, which must be explicitly present in the initial representa- tions. Reflection is entirely dropped from the rewriting system, and becomes a rule for defining identities of structured types. As an example, the identity of type (A × B) × C will be represented as ⟨⟨π1, π2⟩ . π1, π2⟩.
The translation given below expands identities in accordance with this discus- sion, so that only identities of atomic types are represented as edges. Equations like surjective pairing are then satisfied by construction.
In the following, when a net is used to construct a bigger net, we assume that the input and output in the initial net are removed, and a new pair of input/output ports and corresponding edges are introduced in the new net. All the introduced nodes are ground.
Identity
T(idA→A), where A is a base type, is defined as the sum-product net consisting of a single edge connecting the input to the output;
T(idA × B→A × B) is the sum-product net I obtained by introducing 4 new nodes,
∧, π1, π2, and (, ), and new edges connecting the first (resp. second) output of
∧ to the input of π1 (resp. π2), the output of π1 (resp. π2) to the input of IA (resp. IB), and the output of IA (resp. IB) to the first (resp. second) input of (, ), where IA = T(idA→A) and IB = T(idB→B); and finally setting the input of I to be the input of ∧ and the output of I to be the output of (, ).
T(idA + B→A + B) is the sum-product net I obtained by introducing 4 new nodes,
?, i1, i2, and ∨, and new edges connecting the first (resp. second) output of ? to the input of IA (resp. IB), the output of IA (resp. IB) to the input of i1 (resp. i2), and the output of i1 (resp. i2) to the first (resp. second) input of ∨, where IA = T(idA→A) and IB = T(idB→B); and finally setting the input of I to be the input of ? and the output of I to be the output of ∨.
Composition
T(u . tA→C) is the sum-product net V obtained by connecting an edge from the output of T to the input of U , where T = T(tA→B) and U = T(uB→C). Naturally, the input of T becomes the input of V , and the output of U becomes the output of V .
Constant Function
T(π1A × B→A) is the net P1 obtained by introducing a new node π1 and a new edge connecting its output to the input of IA, where IA = T(idA→A), and setting the input of P1 to be the input of π1 and the output of P1 to be the output of IA.
T(π2A × B→B) is the net P2 obtained by introducing a new node π2 and a new edge connecting its output to the input of IB, where IB = T(idB→B), and setting the input of P2 to be the input of π2 and the output of P2 to be the output of IB.
T(i1A→A + B) is the net I1 obtained by introducing a new node i1 and a new edge connecting the output of IA to the input of i1, where IA = T(idA→A), and setting the input of I1 to be the input of IA and the output of I1 to be the

output of i1.
T(i2B→A + B) is the net I2 obtained by introducing a new node i2 and a new edge connecting the output of IB to the input of i2, where IB = T(idB→B), and setting the input of I2 to be the input of IB and the output of I2 to be the output of i2.
Split
Let G be the sum-product net obtained by introducing two new ∧ and (, ) nodes, and 4 new edges connecting the outputs of ∧ to the inputs of T and U , and the outputs of T and U to the inputs of (, ), where T = T(tE→A) and U = T(uE→B); the input of ∧ becomes the input of G and the output of (, ) becomes the output of G. Then:
T(⟨t, u⟩E→A × B), with E = C + D, is the sum-product net G' obtained by constructing the net I = T(idC + D→C + D), and an edge connecting its output to the input of G, setting the input of G' to be the input of I, and the output
of G' to be the output of G.
T(⟨t, u⟩E→A × B), where E is not of the form C + D, is just G.
Either
Let G be the sum-product net obtained by introducing two new ? and ∨ nodes, and 4 new edges connecting the outputs of ? to the inputs of T and U , and the outputs of T and U to the inputs of ∨, where T = T(tA→E) and U = T(uB→E); then the input of ? becomes the input of G and the output of ∨ becomes the output of G. We have:
T([t, u]A + B→E ), where E = C × D, is the sum-product net G' obtained by
constructing the net I = T(idC × D→C × D), and an edge connecting the output of G to the input of I; the input of G' is the input of G, and the output of G' is the output of I.
T([t, u]A + B→E ), where E is not of the form C × D, is just G.
Definition 4.1 The class of sum-product nets constructed by the translation T(·) are designated term nets.
The term nets T(id(A × B) ×(C × D)→(A × B) ×(C × D)) and T(π1(A + B) × C→A + B ) are shown below as examples.



 
Fig. 3. Fusion as Net Duplication

Fig. 4. Duplication of a Structured Net
It is straightforward to see that the net T(tA→B) has input of type A and output of type B. Two differently-typed, syntactically equal terms may be translated as different term nets. The principal type of the term represented by a net can always be uniquely determined.
Deciding Equality by Local Graph Rewriting
In this section we introduce informally the graph-rewriting system and the difficul- ties involved in its definition. The system will then be formally defined in the next section, and its properties studied. Here we consider in turn the treatment of fusion and cancellation.

Fusion
Fusion is accomplished by (co-)duplicator nodes. Intuitively, a duplicator interact- ing with a net should perform a copy of that net (see Figure 3). However, this “duplication” should be performed locally, i.e. the (co-)duplicators interact only with individual nodes. Moreover, both kinds of fusion (additive and multiplica- tive) can occur simultaneously and thus some care must be taken in order to avoid interferences in the process.
For the sake of clarity, we start by considering only the multiplicative fragment of our language. When a duplicator meets a structured net (necessarily a split of two terms), it must itself split in order to duplicate each component of the net. Once the duplication of each sub-net is concluded, it is still necessary to reorganize the duplicators on the top of the net to get the correct outcome for the duplication

of the structured net (see Figure 4). The need to control this reorganization of duplicators justifies the presence of indices in the duplicator symbol – let us assume indices are integers (they will be refined later to be pairs of integers). We are led to the following rules governing the interaction with duplicators.

The first rule is fairly obvious – the interaction with single-input / single-output nodes simply duplicates them. When a duplicator interacts with a pair constructor node, not only does it duplicate the node, but it also splits itself in two in order to duplicate each subnet. The last rule is the commutation rule between duplicators that allows for the two split copies of the original duplicator to be rejoined, while at the same time duplicating the top duplicator. Note the difference between splitting and duplication of duplicators.
Indices record “how deep” the corresponding duplicator is in the traversal of a structured net. Notice that the commutation rule restricts the top duplicator to be ground. We show an example of the duplication process:
We now turn to the interaction between sums and products. The above treat- ment of fusion corresponds to a left-to-right orientation of the fusion law. One problem that is raised at the term level when both sum and product types are present has to do with associativity of composition: there no longer exists a pre- ferred orientation for it, suggested by the left-to-right orientation of fusion. At the graph level this problem is avoided since graphs capture associativity of composition for free, and no rewriting is required.
A second problem has to do with the fact that products and sums interact in such a symmetrical way that it is not possible to choose a certain form to the detriment of its dual. As an example to illustrate this last observation, consider the following equality derivations for the same term:

⟨id, id⟩ · [id, id] = ⟨id ·[id, id], id ·[id, id]⟩ = ⟨[id, id], [id, id]⟩
⟨id, id⟩ · [id, id] = [⟨id, id⟩ · id, ⟨id, id⟩ · id] = [⟨id, id⟩, ⟨id, id⟩]

In fact this is an instance of a more general equality, known as the exchange law :
⟨[f, g], [h, k]⟩ = [⟨f, h⟩, ⟨g, k⟩]. Rather than working modulo an appropriate equa- tional theory that equates these terms (as in [12]), our graph-rewriting system will assign them to a unique normal form. The essence of this relies on letting du- plicators and co-duplicators perform their traversals without interfering with each other.
Returning to the ⟨id, id⟩ · [id, id] term, let us focus on the interaction of the co-
duplicator and duplicator. Structurally, it is fairly obvious that when a duplicator and a co-duplicator meet, they should pass through each other. The question is whether the nodes should be duplicated or split during this process (the impact on
their indices is different).
A first solution would be to state that only duplications take place. This corre- sponds to keeping both indices unaltered, and leads to a rule that allows duplicators to freely pass through choice nodes (without index regulation). The following ad- ditional rules (and their duals) would be required:

Our example term ⟨id, id⟩ · [id, id] reduces to a unique normal form, which does not correspond to the translation of any term. We will call these full normal forms, as they capture the fact that these nets can be read-back as different terms.

It can be readily verified that the translation of ⟨[id, id], [id, id]⟩ (resp. [⟨id, id⟩, ⟨id, id⟩]) also has the same normal form. Reduction is triggered by an extra identity net in- troduced by the translation function at the top (resp. bottom) of the net.
Unfortunately, with the above rules the indices no longer constrain appropri- ately the commutations that might take place. To see this, consider the following reduction sequence:



Note that the application of rule dupM-choice removes the ground duplicator needed to close the fusion started on the left-hand side sub-net. In fact, this is exactly the pattern of divergence that rule dupM-dupM avoids by restricting the top duplicator to be ground. This shows that indices should also restrict the application of rule dupM-choice.
A second approach would be to let both nodes be split (i.e. both nodes have their indices incremented). These are the corresponding rules:

Here the problem becomes subtler. Consider the following reduction sequence:
  
Notice that the traversal of the net by the co-duplicator on the top lifts the indices of all the duplicators in the lower sub-nets. This feature is not in accordance with the informal description given above, but it can be exploited fruitfully. In fact, if we continue the reduction process, we get:



Fig. 5. Example of an asymmetrical net

This example suggests that in order to reach full normal forms, it is sufficient to promote enough fusions (something that may be accomplished by pre- or post- composing with identities). The problem is that the additional reductions rely strongly on the symmetry of the net. More precisely, they rely on the number of duplicators and on the shape of the duplicator tree, on both sides of the choice node. However, even though term nets do exhibit a high degree of symmetry, it cannot be assured that all nets, under all reduction strategies, possess the required symmetry. Figure 5 shows precisely an example of an asymmetrical net. The reader is invited to apply fusion to it with [id, id] to check the problems of this approach.
A final approach is to have a mixed version of the previous solutions: informally, we take one of the nodes to be the ‘dominator’ of the interaction. This node is split (its index is increased), and the other is simply duplicated (its index remains unaltered). The problem here is how to define the domination relation, since the most obvious solutions fails to define a confluent system.
Our solution is given by the following characterization: a ∨ node dominates a ∧



(,)


dupM-pair
(k,Sn)	(k,Sn)
	



(k,n)

(,)
(,)





Where:
X = (k,n), if i > k X = (Sk,n), if i ≤ k Y = (i,j), if n > j Y = (i,Sj), if n ≤ j


Fig. 6. Fusion Rules



Fig. 7. Examples Fusions with Rules in Fig. 6



when “there is no ? node between them”. Being able to express this in the system is in fact the key reason for having pairs of integers as indices, since an additive and a multiplicative component need to be distinguished. Figure 6 implements this solution (a dual set of rules is used for co-duplicators), and Figure 7 illustrates its application.
Note that we only allow ∧ nodes to commute with the ? node associated with the co-duplicator that is performing the fusion (even if this ? becomes available only after commutation with other ∧s). Commutations involving ? nodes duplicated during the fusion process are inhibited.


  
Fig. 8. Cancellation as Erasing








> j


Fig. 9. Cancellation Rules

Cancellation
Cancellation is by nature related with erasing. Consider the structure of a cancel- lation rule given in Figure 8. The interaction of the bottom nodes should trigger the removal of the net g and the top duplicator. We follow the standard approach
of introducing a special erasing node ε (and its dual  ) that annihilates any other
node. The main difficulty is the removal of the top node, which acts as delimiter for the erasing process. For that, we use a □ (and dual  ) node, whose func- tion is to traverse the net f and remove the top duplicator as soon as g has been erased. Once again, it must be ensured that this process does not interfere with other cancellations and fusions.
With respect to indices, □ nodes behave like duplicators as they move upwards in the net. Indices are single integers, as they are not affected by the additive constructs. During the traversal, □ nodes perform a correction on the indices of co-duplicators. This is because co-duplicators may have crossed the top duplicator and had their indices updated.
A representative subset of the rules for cancellation is shown in Figure 9. In

brief, cancellation is triggered by the interaction between a pair-constructor and a projection node (rule cancelM-1), after which the ε node will discard the portion of the net that corresponds to the cancelled subterm. The □ node will then traverse the preserved subterm and synchronize with the ε node on the top duplicator. The example reduction shown below illustrates the use of cancellation laws.

Sum-product Net Rewriting
A local graph-rewriting system will now be given for sum-product nets, based on the ideas discussed informally in the previous section. We first need to establish an appropriate notion of graph-rewriting rule: both the left-hand side (LHS) and the right-hand side (RHS) of the rule are finite nets, with the same sets of input and output ports (in other words the rule preserves the interface of the net). Moreover both the LHS and RHS nets are well-typed and well-formed, the rule preserves type and position labellings of the inputs and outputs, and does not introduce cycles.
The application of a rule in a typed net replaces any subnet matching its LHS by its RHS; the conditions above guarantee that there will be no edges left dangling. The system introduced below enjoys additionally the following:
There are no two rules in the system with the same LHS, or such that the LHS of a rule is a subnet of the LHS of the other;
The RHS of each rule does not contain as a subnet the LHS of another rule;
The set of rules is dual-complete: the dual of each rule is also in the system.
This has some of the defining properties of an interaction net system [9]; fur- ther requirements of such a system are that each node should have a distinguished principal port, and the LHS of every rule should consist of two nodes with an edge connecting both principal ports. This requirement would be sufficient to guarantee strong local confluence, which is not a property of our system.
Definition 6.1 The Sum-Product Rewriting System is defined by the rules given in Appendix B. An admissible net is any reduct of a term net.
It is straightforward to see that the system is strongly normalizing (in general
∧ and □ nodes go up; ∨ and  nodes go down; commutations between three ∧ or ∨ nodes are index-regulated in a way that prevents non-termination). In what follows, we will implicitly invoke duality, which allows for a considerable economy

of effort during the study of the rewriting system.
When we restrict attention to admissible nets, the system has a controlled be- haviour that will be explored later when proving the main results of the paper. Let us now state one of these results for future reference (see appendix A for proof).
Lemma 6.2 In admissible nets, indices can be reset by reduction.

Confluence
It is easy to see that the rewriting system presented above is not in general confluent for sum-product nets. However it is confluent for admissible nets.
As usual, confluence of the system will be established by studying all the critical pairs induced by the rules. Most are resolved in a purely local fashion. For some pairs however, this will not be enough since the convergence of the reduction paths relies on global properties of admissible nets. In order to regain the locality in the analysis of critical-pairs, we will now introduce a suitable notion of equivalence.
Definition 6.3 Let N be a single input, n-output net and A a two-input, single- output node. We define JOIN(A, N ) as the two-input, n-output net composed of two copies of N and n copies of A (say Ai) where the inputs of the net are the inputs of each copy of N , the ith output of the first (resp. second) copy of N is connected to the first (resp. second) input of Ai, and the ith-output of the net is the output of Ai.
Definition 6.4 Let N1 and N2 be two single-input, n-output nets. They are said to be twin equivalent with respect to a node A, written N1 ∼=A N2, when for every net N containing an occurrence of JOIN(A, N1), N has a common reduct with the net resulting from substituting JOIN(A, N1) by JOIN(A, N2) in N .
Lemma 6.5 The following nets are twin-equivalents with respect to a ∨ node with some index (i, j).

Proof. Let us denote by N (a,b) and N (a,b) the following nets:
1	2





Each of these parameterized nets can be treated as an (indexed) node, by com- puting the derived rules of interaction between the net and (a node for) each symbol.


	

where	J = j	, if n > j;
Sj  , otherwise.


Fig. 10. Example Critical Pair


For every such symbol, the derived rule is exactly the same for N (a,b) and N (a,b).
1	2
Now consider a net N containing an occurrence of JOIN(A, N (a,b)). By Lemma 6.2,
the top duplicator in N (a,b) has a reduction sequence that resets its index to (0, 0). Finally, observe that this reduction sequence can be mimicked in the net N (a,b)
yielding N (0,0), and N (0,0) reduces by rule dupM-dupM to N (0,0). The impact on N
2	1	2
is precisely the same.	2
This proof illustrates the primary purpose of twin-equivalence in the proof of confluence: it allows to overcome the restrictions on the application of the commu- tation rules, which incidentally are introduced in the system precisely to achieve confluence, as they avoid critical pairs between commutations.
Proposition 6.6 The rewriting system is confluent for admissible nets.
Proof. Considering all the critical pairs generated by the rules given in appendix B. Let us illustrate this with the critical pair formed by rules dupM-dupM and dupM-dupS, which is an interesting case. We first assume that the first (additive)
component of the ∨ index is 0. We are led to the pair of reduction sequences shown in Figure 10, where ≡ denotes structural equality of nets and ∼= denotes the fact that the two nets have a common reduct, as granted by Lemma 6.5. When
∨ has a positive additive index, the index of the top duplicator is not modified, and the invocation of twin-equivalence can be replaced by the application of rule dupM-dupM.	2

Soundness and Completeness
The reduction system given in Appendix B induces the following definition of equiv- alence of term nets. Let ≡ denote structural equality of nets.
Definition 6.7 Two term nets  G1, G2 are equivalent, written G1 = G2, if there
exist sum-product nets  G' , G' such that G1 −→∗ G' and G2 −→∗ G' , and
1	2	1	2
' ≡ G' .
We may now establish the main results relating the equational theory and the graphical system.
Proposition 6.8 (Soundness) Let t, u be TPF terms. Then
t = u =⇒ T(t) = T(u)

Since reduction of a term net does not necessarily produce another term net, in the following completeness result the common reduct of T(t) and T(u) may be a sum-product net that is not a term net.
Proposition 6.9 (Completeness) Let t, u be TPF terms. Then
T(t) = T(u) =⇒ t = u

Proofs of both results can be found in Appendix A.

Conclusions and Future Work
Together, the translation T(·) and the graph-rewriting system solve three problems:
The translation directly captures the reflection laws, because it expands identities according to their types.
To ensure that the fusion laws are effectively captured, commutations between configurations involving 3 nodes must be allowed (rules dupM-dupM, dupM-choice, dupS-dupS and pair-dupS), regulated by an indexing scheme.
Finally, this indexing scheme must be capable of handling fusions in terms such as ⟨a, b⟩ .[c, d], which may happen in two directions. In our system, such a fusion results in a (unique) net, which is no longer a term net.
It is possible to draw a parallel between our translation phase and the use of expansions in extensional lambda-calculi. This is sharply seen when we compare it with the simulation account of expansions found in [4], where a similar preprocessing phase performs all the required expansions. Our translation is considerably simpler, since we do not need to simulate expansions on the translated terms.
An adequate treatment of the exponential fragment of the calculus is the next obvious step. This introduces new problems, related to the work on encodings of the λ-calculus into interaction nets. The initial and terminal objects and their associated morphisms can easily be incorporated in our system.

References
Thorsten Altenkirch and Peter Dybjer and Martin Hofmann and Phil Scott, Normalization by evaluation for typed lambda calculus with coproducts. In 16th Annual IEEE Symposium on Logic in Computer Science, pages 303-310. IEEE Press, 2001.
Asperti, A., Giovannetti, C., and Naletto, A. (1996). The Bologna optimal higher-order machine.
Journal of Functional Programming, 6(6):763–810.
Bird, R., de Moor, O.: Algebra of Programming, Prentice Hall, 1997.
Roberto di Cosmo and Delia Kesner. Simulating expansions without expansions. Math. Structures in Computer Science, 4(3):1-48, 1994
D. Dougherty, Some λ-calculi with categorical sums and products. In Rewriting Techniques and Applications, volume 690 of Lecture Notes in Computer Science, pages 137–151. Springer Verlag, 1993.
Neil Ghani, Beta-Eta Equality for Coproducts, In Proceedings of TLCA’95, pages 171-185, vol.902 LNCS. Springer-Verlag, 1995.
J.-Y. Girard: Towards a Geometry of Interaction, In Categories in Computer Science and Logic: Proc. of the Joint Summer Research Conference, pages 69–108. 1989.
Gonthier, G., Abadi, M., and Lvy, J.-J. (1992a). The geometry of optimal lambda reduction. In
Proceedings of ACM Symposium Principles of Programming Languages, pages 15–26.
Y. Lafont. Interaction nets. In Proceedings of the 17th ACM Symposium on Principles of Programming Languages (POPL’90), pages 95–108. ACM Press, Jan. 1990.
Joachim Lambek and Phil J. Scott. Introduction to higher order categorical logic, volume 7 of Cambridge studies in advanced mathematics. Cambridge University Press, 1986.
G. D. Plotkin. Post-graduate lecture notes in advanced domain theory (incorporating the ”Pisa Notes”). Dept. of Computer Science, Univ. of Edinburgh. Available from http://www.dcs.ed.ac.uk/home/gdp/ publications/, 1981.
J. R. B. Cockett and R. A. G. Seely Finite sum - product logic. In Theory and Applications of Categories, Vol. 8, 2001, No. 5, pp 63-99.

A	Proofs
Proof of Lemma 6.2
Rules dupM-dupM and dupM-choice are called commutation rules as they promote a swap of nodes. A net is said to admit “half a commutation” if it contains a subnet matching the top and one of the bottom nodes of the LHS of a commutation rule.
Lemma A.1 Let G be an admissible net that admits half a commutation. Then there exists a net G' such that G −→∗ G' and the partial match in G' is extended to the full match of the LHS of the commutation rule.
Proof. In an admissible net, for every ? or ∧ node with index (0, 0), the agent destined to commute with it (if any) can be identified by a recursive procedure that follows the definition of the net, starting from one output of the agent. The absence of commutation rules with non-ground duplicators guarantees that this node does not change until commutation actually occurs. Moreover, the fact that rules dupM-pair and dupM-dupS inject duplicators in both inputs of the interacting agents, guarantees that the result is the same when computed on any of the output ports of the given node.	2
With this we can now prove Lemma 6.2:

Proof. Indices are adjusted during reduction in accordance with well-formedness. On the other hand, rules for indexed nodes are such that they do not constrain interaction when the indices are non-zero. This means that an indexed node can only survive in a normal form if: (i) it reaches the top of the net; or (ii) it gets stuck in a commutation that is not possible. The well-formedness criterion guarantees that
(i) is not possible for admissible nets, and Lemma A.1 shows that (ii) could never occur in a normal form.	2
Soundness
Lemma A.2 Let t be a TPF term, and G∧(t) the net obtained by connecting a
∧ node with index (a, m) where m > 0, to the output of the term net T(t). Then G∧(t) −→∗ G∧(t), where G∧(t) consists of a ∧ node with index (a, m), whose outputs are connected to the inputs of two nets Gl, Gr such that Gl = Gr = T(t).
Proof. By induction on the structure of t. Note that the lemma is not valid for m = 0, in the particular case that t is of the form (or a composition of terms ending with) [f, g], in which case the duplicator node does not dominate the ∨.	2
Lemma A.3 Let t be a TPF term, and Gε(t) the net obtained by connecting an ε node to the output of the term net T(t). Then Gε(t) −→∗ Gε, where Gε consists of a single ε node.
Proof. By induction on the structure of t, using the rules where ε appears in the left-hand side.	2
Lemma A.4 Let t be a TPF term, G□(t) the net obtained by connecting the input of a □ node indexed with n to the output of the term net T(t), and G□(t) obtained by connecting the output of a □ node (again indexed with n) to the input of T(t). Then G□(t) −→∗ G□(t).
Proof. By induction on the structure of t, using rules where □ appears in the left-hand side.	2
Lemma A.5 Let N be a sum-product net with a single input and output, and let N∨ denote the net obtained by incrementing the second component of the indices of top co-duplicators in N, i.e. (a, m) becomes (a, m + 1) for every co-duplicator that is not located under another co-duplicator.
Let also N' be the net obtained by plugging a net T(id) (where the identity has the appropriate type) on top of N. Then N∨ = N'.
Proof. Straightforward induction on the type of the identity.	2
Dual lemmas to the above can be proved. We will refer to these as Lemmas A.2’, A.3’, A.4’,and A.5’.
Proposition A.6 (Soundness) Let t, u be TPF terms with t = u. Then T(t) =
T(u).
Proof. By cases of the definition of equality of terms.

T(id · f ) ≡ T(f · id) ≡ T(f ) (straightforward)
T((f · g) · h) ≡ T(f · (g · h)) (straightforward)
T(⟨π1, π2⟩) ≡ T(id)
Guaranteed by construction. Observe that the term ⟨π1, π2⟩ necessarily has type A × B → A × B for some types A, B, and

T(⟨π1, π2⟩A × B→A × B ) ≡ T(idA × B→A × B )

T([i1, i2]) ≡ T(id)
Dual to the previous case.
T(⟨f, g⟩ · h) = T(⟨f · h, g · h⟩)
By induction on the structure of h
h = h1 ·h2 – we use T((f ·g)·h) ≡ T(f ·(g·h)) and then the inductive hypothesis applies.
h is a constant – straightforward.
h = ⟨a, b⟩ – straightforward using Lemma A.2, which can be used since the duplicator has index (0,1) after duplicating the (, ) node.
h = [a, b] – this is the hard case since Lemma A.2 does not apply.
In the net T(⟨f, g⟩·[a, b]) after one step of rule dupM-dupS the split duplicators have indices (1,0); they will duplicate the nets T(a) and T(b) incrementing the (second component of the) indices of the top co-duplicators. Finally, the split duplicator will commute with the top ? node.
In the net T(⟨f · [a, b], g · [a, b]⟩) on the other hand, the translation introduces the encoding of an identity of sum type on top. Proceeding with reduction one obtains a net that is similar to the previously obtained, except that the nets T(a) and T(b) appear intact, with identities of sum type on top of each such net. Lemma A.5 then yields T(⟨f, g⟩ · [a, b]) = T(⟨f · [a, b], g · [a, b]⟩).
T(h · [f, g]) = T([h · f, h · g])
Dual to the previous case using Lemmas A.2’ and A.5’.
T(π1 ·⟨f, g⟩) = T(f ) and symmetrically T(π2 ·⟨f, g⟩) = T(g)
If the domain of ⟨f, g⟩ is not a sum type and the codomain of π1 is a ground type, then T(π1 ·⟨f, g⟩) −→∗ T(f ) by rule cancelM-1, Lemmas A.3 and A.4, and finally rule epsilon-dupM-2.
Otherwise,
If the domain of ⟨f, g⟩ is of the form C + D, the translation introduces an additional net on top, corresponding to the encoding of an identity of type C + D. We have T(π1 ·⟨f, g⟩) −→∗ T(f · id) = T(f ).
If the codomain of π1 is not a ground type, the translation introduces an addi-
tional net at the bottom, corresponding to the encoding of the identity at that type. We have T(π1 ·⟨f, g⟩) −→∗ T(id ·f ) = T(f ).
T([f, g] · i1) = T(f ) and symmetrically T([f, g] · i1) = T(g)

Dual to the previous case using Lemmas A.3’ and A.4’.
2




Completeness

The proof of completeness uses a path-based interpretation of terms, in the style of the Geometry of Interaction [7].


Definition A.7 (Read-back) We define a labelling of sum-product nets from top to bottom as follows, where the labels are TPF terms extended with the constants
L, R, and  .
If the input of a ∧ node is labelled α then both its outputs are labelled α.
If the inputs of a (, ) node are labelled β · α and β' · α (where α is the longest common suffix) then its output is labelled ⟨β, β'⟩ · α. Note that if the labels are equal then we take β = β' = id.
If the input of a ? node is labelled γ then its outputs are labelled L · γ and R · γ
respectively.
For ∨ nodes there are two cases:
· If its inputs are labelled β · α · L · γ and β · α' · R · γ (where β is the longest common prefix and γ is necessarily a common suffix) then its output is labelled β · [α, α'] · γ. Note that if β extends until L and R then α = α' = id.
· If its inputs are labelled α and β ·  (in any order) then its output is labelled α.
If the input of a pair projection node π1 (resp. π2) is labelled α then its output is labelled π1 ·α (resp. π2 ·α).
If the input of a choice injection node i1 (resp. i2) is labelled α then its output is labelled i1 ·α (resp. i2 ·α).
The output of a	node is labelled  .
If the input of a □ node is labelled α then its output is also labelled α.
If the input of a  node is labelled α then its output is also labelled α.
Given x ∈ TPF and a sum-product net N with a single input and a single output, we define its read-back Rx(N ) as the label of its output, given uniquely from the above rules after labelling the input of N with x. We will write simply R(N ) for Rid(N ).
For sum-product nets in general the read-back can be generalized as taking a vector of n inputs and producing a vector of m outputs (both indexed from left to right), Rx(N ) = y1, . . . , ym where x = x1, . . . , xn.
Finally, we extend the equational theory of terms with the following equations relating the new constants introduced in the labels (ranged over by α):


L · i1 = id	L · i2 =

R · i1 =


α ·	=
R · i2 = id

Lemma A.8 Let N1, N2 be sum-product nets; if N1 −→ N2 then Rx(N1) = Rx(N2).
Proof. All the net reduction rules preserve the read-back. We give two examples: in rule choice-dupS the inputs must have labels respectively of the form β · α1 · L · γ
and β · α2 · R · γ, or else α and β · ; in the first case, on both sides of the rule the
outputs will be labelled L · β · [α1, α2] · γ and R · β · [α1, α2] · γ; in the second case
the outputs are labelled L · α and R · α on both sides.
In rule cancel-S1, for input α we have output L· i1 ·α on the left-hand side and α
on the right-hand side, which are equal under the augmented equational theory. 2
We remark that the read-back of an admissible net is necessarily a term of TPF, and in particular:
Lemma A.9 For any t ∈ TPF, R(T(t)) = t.
Proof. The stronger result Rx(T(t)) = t · x can be proved by induction on the structure of t.	2
Proposition A.10 (Completeness) Let t, u ∈ TPF be such that T(t) = T(u). Then t = u.
Proof. For T(t) = T(u) to hold there must exist sum-product nets Gt, Gu such that T(t) −→∗ Gt, T(u) −→∗ Gu, and Gt ≡ Gu. By lemma A.8 we have that R(T(t)) = R(Gt) and R(T(u)) = R(Gu). Now by lemma A.9 and because structurally equal nets have the same read-back, we have t = u.	2
B  Full Set of Rewrite Rules





	




































j	X
dupM-cancelS	

(k,n)	j	j
Where:
X = (k-1,n), if k > j
X = (k,n), if k ≤ j








Where:




X = (n,k), if k ≤ j

X = (k,n), if i > k
X = (Sk,n), if i ≤ k
Y = (i,Sj), if n ≤ j















(n,k)


?






f = π1, π2, 1, 2





1, 2, 1, 2
