

Electronic Notes in Theoretical Computer Science 173 (2007) 85–102
www.elsevier.com/locate/entcs

Skeletons, Homomorphisms, and Shapes: Characterizing Protocol Executions 1
Shaddin F. Doghmi2 ,5
Stanford University Stanford, CA, USA
Joshua D. Guttman3
The MITRE Corporation Bedford, MA, USA
F. Javier Thayer4
The MITRE Corporation Bedford, MA, USA

Abstract
In this paper we develop a framework, based on strand spaces, for reasoning about cryptographic protocols and characterizing their executions. We define skeletons, homomorphisms, and shapes. Skeletons model partial information about regular (honest) behavior in an execution of a cryptographic protocol. A homo- morphism between skeletons is an information-preserving map. Much protocol analysis may be regarded as an exploration of the properties of the category of skeletons and homomorphisms. A set of skeletons can characterize all runs of the protocol; the smallest such set is the set of shapes. This approach is a foundation for mechanizing protocol analysis.
Keywords: protocol analysis, strand spaces, enumerating protocol executions, mechanizing protocol analysis.


Introduction
Most protocol analysis tools and techniques operate on formulas, proving or refuting formulas that express the security goals of a protocol in a specific logic. Starting

1 Supported by the National Security Agency and by MITRE-Sponsored Research.
2 Email: shaddin@cs.stanford.edu
3 Email: guttman@mitre.org
4 Email: jt@mitre.org
5 This research was conducted while the author was an employee at The MITRE Corporation.


1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2007.02.029

from some initial assumptions, theorem proving or model checking (such as in [9]) techniques can be used to check if a certain security property follows from a protocol definition. In this paper, we take a different approach to this problem.
Instead of checking each security property individually, we characterize all pro- tocol executions compatible with the initial assumptions. The resulting charac- terization is a set of protocol runs that is representative of all possible protocol runs. These representatives are the minimal, essentially different executions of the protocol. Some advantages of this approach are:
. We find that the proofs for different security properties often duplicate the same work. With this approach, all the work needed to characterize possible runs can be done once. Then it is easy for a human analyst or simple tool to “read off” the value of any security predicate from the characterization by evaluating that predicate on each run in the characterization.
. Security properties of the protocol that were not anticipated by the designer will become apparent.
. The analyst interested in a certain security property can see all the possible attacks/counterexamples as opposed to a single attack.
. Since all possible protocol runs are represented, this gives the protocol designer more insight into the effect of the different primitives used to construct the pro- tocol.
In this paper, we will present a framework, based on strand spaces, for analyzing protocols and characterizing their executions. While a generalized notion of our characterizations can capture both authentication and secrecy properties, we focus here on a simpler notion that captures authentication properties exclusively. We will discuss the applicability to secrecy elsewhere. In practice, any algorithm for constructing characterizations must reason about both secrecy and authentication. As motivation for this framework, consider a protocol analyst presented with some initial assumptions about a protocol run. Often this is the experience of a single participant and some secrecy and freshness assumptions. The analyst can then repeatedly apply inference rules such as the authentication tests [4] in order
to infer more about the structure of the protocol run.
At any point in the analysis, the analyst possesses partial information about the structure of possible protocol runs. We will represent this partial information in structures we will call skeletons. We will also define a notion of homomorphism between skeletons; homomorphisms are information-preserving maps. Thus, much of protocol analysis can be expressed in terms of skeletons and homomorphisms between them.
We discuss the actual algorithms used to construct these characterizations in [2]. In the present paper, we define the underlying framework for the algorithms. Given a set of initial assumptions (an initial skeleton), we will define how a set of protocol runs can characterize all possible runs. Furthermore, we will show that there is a minimum such characterization: the set of shapes. They are the minimal, essentially different executions possible for the protocol.


init	resp

	Na,A	)
¨
	Na,A	) •
¨

{|Nb, Na, A|}K−1	{|Nb, Na, A|}K−1

¨• (	
¨
(	 ¨•
¨

{|N ' , N , B|} −1
A
{|N ' , N , B|} −1
A

	)		) •

Fig. 1. iso Candidate Protocol


init	resp
	Na,A	) •
	{|Nb, Na, A|}K−1	 
¨• (	 ¨•
¨	{|N ' , N , B|} −1	¨ 
A
	) •

Fig. 2. Bundle: Intended Run

A Motivating Example
The protocol shown in Figure 1 was a candidate considered by an iso committee as a pure authentication protocol [3]. No shared secret is achieved. It uses asymmetric cryptography for digital signatures, and is intended to assure each principal that the expected partner intends to engage in a communication session. Figure 1 gives the roles of the protocol. Each of the two vertical columns describes a behavior that principals engaging in the protocol may follow. The column on the left orig- inates a session, while the column on the right is the responder’s behavior. Any principal Alice, Bob, etc., may engage in either of these roles, or possibly in several sessions of each role at the same time. An actual run of the protocol consists of any finite number of instances of these roles, connected by message transmissions and (possibly) actions of an adversary.
We call a vertical column connected by double arrows •⇒ • a strand, and use it to represent a single local session of a principal executing a protocol, or alternatively a sequence of adversary activities.
One kind of execution simply connects the corresponding arrows, and this models a session in which the messages sent by the principals, called A and B here, reach their destinations (Figure 2). We call such an execution a bundle. This is a small bundle. There are infinitely many larger bundles consisting of multiple copies of this diagram, possibly with different values of the parameters. However, the larger executions are only inessentially different from Figure 2.
However, this protocol was rejected by the committee, because they found that



Np,A 
resp

P¨ 	) B¨
  {|N , Np, A|} −1	¨ 
B
¨• (	 ¨•
resp	¨
N ,B 
¨A (	¨	¨
	{|Na, Nb, B|}K−1	¨
	A	¨
¨	¨
  {|Na, N , B|} −1	 
A
• 	) •

Fig. 3. Bundle: The Canadian Attack
another, essentially different execution is possible [3], shown in Figure 3. Since it was discovered by the Canadian representatives to the committee, it is sometimes called the Canadian attack [3]. The attacker is denoted by P . The attack involves two runs of the responder role, both stimulated by messages delivered by the adversary. This attack constitutes a failure of authentication from the perspective of re- sponder B. Even if both B and A had uncompromised private keys, the protocol does not guarantee to the responder B that A is running a corresponding instance of the initiator role. In this attack, A is running an instance of the responder role, although only the first two steps of the role have occurred; A is waiting for the third
message for this session, though it will never be delivered.
Suppose that these are all of the minimal, essentially different executions possi- ble containing a responder run using uncompromised private keys. In that case, we can read off the degree of authentication that B obtains. B knows at the end of a responder session that there has been an A session that agrees with B’s session on the participant’s identities and the parameters Na, Nb. However, B cannot know whether it is an initiator role of length three or a responder role of length two, since executions exist with each. Since the protocol designers wanted to ensure that B would know that there is a matching initiator run, the protocol was too weak to meet the goal.

The Idea of Shape
In the ensuing discussion we will use the term regular strand to refer to a run of some role of the protocol. Likewise we will use regular node to refer to a send or receive event occuring on a regular strand. We also use regular behavior to refer to all regular nodes in a particular run of the protocol as well as their causal ordering. We will also use the notation term(n) to refer to the message sent or received on node n.
In practice, protocols have remarkably few shapes. The ISO-reject protocol introduced above has two if we take the view of a responder, asking what global


 	Na,A	) B
¨
{|Nb, Na, A|}K−1
(	 ¨•
{|N ' , Nb, B|}  −1     ¨ 
	) •
non = {K−1, K−1}
A	B
unique = {Nb}

Fig. 4. ISO Candidate Responder Skeleton



Na,A 
≤	Na,A 

¨A 	) ............................................
¨
	) B¨
¨

{|Nb, Na, A|}K−1	≥	{|Nb, Na, A|}K−1

¨• (	
¨
............................................
(	 ¨•
¨

{|N ' , N , B|} −1
A
≤	{|N ' , Nb, B|} −1

	) ............................................
non = {K−1, K−1}
	) •

A	B
unique = {Na, Nb,N ' }

Fig. 5. ISO Candidate Intended Shape

 	Na,A	) B
¨

Nb,B 
≥	{|Nb, Na, A|}K−1

¨A (	
¨
.....................................
(	 ¨•
¨

{|N ' , N , B|} −1
A
≤	{|N ' , Nb, B|} −1

	) .....................................
non = {K−1, K−1}
	) •

A	B
unique = {Nb,N ' }

Fig. 6. ISO Candidate Attack Shape

behaviour must have occured if B has had a local run of the protocol.
In the ISO reject protocol, let us suppose that B’s nonce Nb has been freshly chosen and that the the party that B wishes to respond to, A, has an uncompromized private key K−1. Assume that the responder B completes a run of the protocol, executing the strand shown in 4. What must have happened elsewhere in the network? There are two possibilities.

3.0.1  ISO Shapes
The last message received by the responder has been signed by an uncompromised private key K−1. Let us consider the case where that message originated on an initiator strand. In this case, the initiator A must have had a partially matching strand, with the messages sent and received in the expected order. This is depicted in Fig. 5. The order of message sends and received can be deduced via the freshness assumption on nonce Nb, as well an assumption that any regular strand generates fresh nonces, in this case Na and N ' . The order is depicted by the arrows of both kinds and the connecting symbols ≤. These symbols mean that the endpoints are ordered, but that other behavior may intervene, whether adversary strands or regular strands.
Another possibility is that the signed message originated on a responder strand. In this case, we can use similar analysis to deduce that the events in Fig. 6 must have occured, in that order.
There is no alternative to these two shapes. Any diagram containing the re- sponder strand depicted in Fig. 4 must contain either an intiator strand with the events ordered as shown in Fig. 5, or a responder strand with the events ordered as in Fig. 6.
Such a diagram is a shape. A shape consists of the regular strands of some execution, forming a minimal set containing the initial regular strands (in this case, just the right-hand column). Possible executions may freely add adversary behavior. Each shape is relative to assumptions about keys and freshness, in this case that K−1 is uncompromised and Nb freshly chosen, and furthermore that regular strands generate fresh nonces.
In searching for shapes, one starts from some initial set of strands. Typically, the initial set is a singleton, which we refer to as the “point of view” of the analysis.
Skeletons, Homomorphisms, Shapes.
Newly introduced terminology is in boldface in this section.
A skeleton A is (1) a finite set of regular nodes, equipped with additional information. The additional information consists of (2) a partial order ≤A on the nodes indicating causal precedence; (3) a set of keys nonA; and (4) a set of atomic values uniqueA. Values in nonA must originate nowhere in A, whereas those in uniqueA originate at most once in A. 6 (See Def. 5.1.)
We say a skeleton A is realized if it has precisely the regular behavior of some execution. Every message received by a regular strand either should have been sent previously, or should be constructable by the adversary using messages sent previously.
Example 3.1 Fig. 5 shows skeleton Aiso1 , with nonA	= {K−1, K−1} and

uniqueA


iso1
= {Na, Nb,N ' }. Aiso1 is a realized skeleton.
iso1	A	B

Fig. 6 shows skeleton Aiso2 . This skeleton is realized, and depicts regular be- havior in the attack on the protocol.

6 When n ⇒∗ n' and n' ∈ A, we require n ∈ A and n ≤A n'.

The single responder strand depicted in Fig. 4, also forms a skeleton Ab with
non, unique as shown. Ab is not realized.
The first two nodes of Ab also form a skeleton Ab2 . This skeleton is realized, as the adversary can prepare the incoming message of its first node, and discard the outgoing message of its second node.
A homomorphism is a map H from A0 to A1, written H: A0 → A1. We represent it as a pair of maps (φ, α), where φ maps the nodes of A0 into those of A1, and α is a replacement mapping atomic values into atomic values. We write t · α for the result of applying a replacement α to a message t. H = (φ, α) is a homomorphism iff: (1) φ respects strand structure, and term(n) · α = term(φ(n)) for all n ∈ A0; (2) m ≤A0 n implies φ(m) ≤A1 φ(n); (3) nonA0 · α ⊆ nonA1 ; and (4)
uniqueA0 · α ⊆ uniqueA1 . (Defs. 4.1, 5.6.)
Homomorphisms are information-preserving transformations. Each skeleton A0 describes the realized skeletons reachable from A0 by homomorphisms. Since ho- momorphisms compose, if H: A0 → A1 then any realized skeleton accessible from A1 is accessible from A0. Thus, A1 preserves the information in A0: A1 describes a subset of the realized skeletons described by A0.
A homomorphism may supplement the strands of A0 with additional behavior in A1; it may affect atomic parameter values; and it may identify different nodes together, if their strands are compatible in messages sent and positions in the partial ordering.
Example 3.2 The map H: Ab → Aiso1 embedding the skeleton in Fig. 4 into the skeleton in Fig. 5 is a homomorphism. Likewise if we embed the first two nodes of B’s strand (rather than all of Ab) into Aiso1 .
Consider the variant A' of skeleton Aiso1 that we would get by renaming the variable A to B (that is, we are identifying A and B). There is a homomorphism H' mapping Ab to A', embedding as did H, but also renaming A to B.
A homomorphism H = (φ, α) is nodewise injective if the function φ on nodes is injective. The nodewise injective homomorphisms determine a useful partial order on homomorphisms: When for some nodewise injective H1, H1 ◦ H = H', we write H ≤n H'. If H ≤n H' ≤n H, then H and H' are isomorphic. We say a homomorphism H characterizes all realized homomorphisms H' such that H ≤n H'.
A homomorphism H: A0 → A1 is a shape iff (a) A1 is realized and (b) H is
≤n -minimal among homomorphisms from A0 to realized skeletons. If H is a shape,

and we can factor H into A0
H0  A'  H1
A1, where A' is realized, then A' cannot

contain fewer nodes than A1, or identify fewer atomic values. A1 is as small and as general as possible. (Def. 7.8.)
We call a skeleton A1 a shape when the homomorphism H (usually an embed- ding) is understood. In this looser sense, both Fig. 5 and Fig. 6 depict shapes. Strictly, the embeddings Hiso1 : Ab → Aiso1 and Hiso2 : Ab → Aiso2 are the shapes.
Shapes exist below realized skeletons: If H: A0 → A1 with A1 realized, then the set of shapes H1 with H1 ≤n H is finite and non-empty.

Background
In this section we define the core strand space notions.
We define our algebra A of terms. Terms in A are built from atomic terms via constructors. The atomic terms are partitioned into the types principals, texts, keys, and nonces. An inverse operator is defined on keys. There may be additional operations on atoms, such as an injective public key of function or an injective long term shared key of function mapping principals to keys. Atoms serve as indetermi- nates (variables), and are written in italics (e.g. a, Na, K−1). We assume A contains infinitely many atoms of each type.
Terms in A are freely built from atoms using concatenation and encryption. The concatenation of t0 and t1 is written t0, t1. Encryption takes a term t and an atomic key K, and yields a term written as {|t|}K . Instead of general substitutions, we use Replacements for simplicity. Replacements have only atoms in their range:
Definition 4.1 [Replacement, Application] A replacement is a function α mapping atoms in A to atoms in A, such that (1) for every atom a, α(a) is an atom of the same type as a, and (2) α is a homomorphism with respect to the operations on atoms, e.g. in the case of inverse keys, for every key K, K−1 · α = (K · α)−1.
The application of α to t, written t · α, homomorphically extends α’s action on atoms. More explicitly, if t = a is an atom, then a · α = α(a); and:
(t0, t1) · α = (t0 · α), (t1 · α) ({|t|}K ) · α = {|t · α|}K·α
Application distributes through pairing and sets. Thus, (x, y) · α = (x · α, y · α), and S · α = {x · α: x ∈ S}. If x /∈ A is a simple value such as an integer or a symbol, then x · α = x.
For the purposes of this paper and upcoming work, restricting ourselves to re- placements is a convenient simplification. However, our model is extensible to using a more general notion of substitution. We may concern ourselves with that in future work.
Since replacements map atoms to atoms, not to compound terms, unification is very simple. A replacement α unifies t1 and t2 if t1 · α = t2 · α. Two terms are unifiable if and only if they have the same abstract syntax tree structure, with the same type for atoms at corresponding leaves. If t1, t2 are unifiable, then t1 · α and t2 · β are unifiable. Any two unifiable terms t1, t2 have a unique (up to renaming) most general unifier.
The direction + means transmission, and the direction − means reception:
Definition 4.2 [Strand Spaces] A direction is one of the symbols +, −. A directed term is a pair (d, t) with t ∈ A and d a direction, normally written +t, −t. (±A)∗ is the set of finite sequences of directed terms.
A strand space over A is a structure containing a set Σ and two mappings: a trace mapping tr :Σ → (±A)∗ and a replacement application operator (s, α) → s · α such that (1) tr(s · α)= (tr(s)) · α, and (2) s · α = s' · α implies s = s'. Elements of

Σ are called strands.
By condition (2), any non-trivial Σ has infinitely many copies of each strand s,
i.e. strands s' with tr(s')= tr(s). Note that in this paper, when we refer to a strand we are implicitly also referring to its trace.
Definition 4.3 A penetrator strand has a trace of one of the following forms: M: ⟨+t⟩ where t ∈text, principal,nonce		K: ⟨+K⟩ C: ⟨−g, −h, +g, h⟩	S: ⟨−g, h, +g, +h⟩
E: ⟨−K, −h, +{|h|}K ⟩	D: ⟨−K−1, −{|h|}K, +h⟩.
If s is a penetrator strand, then s · α is a penetrator strand of the same kind.
Definition 4.4 [Protocols] A protocol Π = ⟨R, n, u⟩ consists of (1) a finite set R of strands called the roles of the protocol, and (2) for each role r ∈ R, two sets of atoms nr, ur giving origination data for r. The regular strands ΣΠ over Π consists of all strands with traces r · α for some r ∈ R and some replacement α.
Example 4.5 Figure 1 depicts the ISO Reject protocol. Note that the origination
data for the initiator role indicates that any honest initiator has an uncompromised private key K−1, and that he generates fresh nonces Na and N ' . Similarly any

A
honest responder has an uncompromised private key K−1
a
and generates a fresh

nonce Nb.
A node is a pair n = (s, i) where i ≤ length(tr(s)); strand(s, i) = s; and the direction and term of n are those of tr(s)(i). We call a node n = (s, i) regular if s is a regular strand and the relevant protocol is understood. We prefer to write s ↓ i for the node n = (s, i). The set N of all nodes forms a directed graph G = ⟨N , (→ ∪ ⇒)⟩ with edges n1 → n2 for communication (with the same term, directed from positive to negative node) and n1 ⇒ n2 for succession on the same strand.
The subterm relation, written и, is the least reflexive, transitive relation such that (1) t0 и t0, t1; (2) t1 и t0, t1; and (3) t и {|t|}K . Notice, however, K /и {|t|}K unless (anomalously) K и t. We say an atom a occurs in term t if a и t. We say that a key K is used for encryption in a term t if for some t0, {|t0|}K и t. If a occurs in t or is used in t, then a is mentioned in t.
A term t originates at node n if n is positive, t и term(n), and t /и term(m) whenever m ⇒+ n. Thus, t originates on n if t is part of a message transmitted on n, and t was neither sent nor received previously on this strand.
Definition 4.6 [Bundle] A finite acyclic subgraph B = ⟨NB, (→B ∪ ⇒B)⟩ of G is a bundle if (1) if n2 ∈ NB is negative, then there is a unique n1 ∈ NB with n1 →B n2; and (2) if n2 ∈ NB and n1 ⇒ n2, then n1 ⇒B n2. When B is a bundle, ≤B is the reflexive, transitive closure of (→B ∪ ⇒B).
A bundle B is over Π= ⟨R, n, u⟩ if for every s ↓ i ∈ B, (1) either s ∈ ΣΠ or s is a penetrator strand; (2) if s = r · α and a ∈ nr · α, then a does not originate in B; and (3) if s = r · α and a ∈ ur · α, then a originates at most once in B.

Example 4.7 Figures 2 and 3 depict two different bundles for the protocol in Figure 1
Proposition 4.8 Let B be a bundle. ≤B is a well-founded partial order. Every non-empty set of nodes of B has ≤B-minimal members. If α is a replacement, then B· α is a bundle.
We will also define the sub-bundle relation between bundles.
Definition 4.9 A bundle B1 is a sub-bundle of bundle B2 if B1 is a subgraph of
B2, up to (injective) renaming of nodes.

Skeletons and Homomorphisms
In this section we will define the framework of skeletons and homomorphisms.
A preskeleton describes the regular (honest) parts of a set of bundles.
Definition 5.1 A four-tuple A = (node, ≤, non, unique) is a preskeleton if:
node is a finite set of regular nodes; n1 ∈ node and n0 ⇒+ n1 implies n0 ∈ node;
≤ is a partial ordering on node such that n0 ⇒+ n1 implies n0 ≤ n1;
non is a set of keys where if K ∈ non, then for all n ∈ node, K /и term(n), and for some n' ∈ node, either K or K−1 is used in term(n');
unique is a set of atoms where if a ∈ unique, for some n ∈ node, a и term(n). A preskeleton A is a skeleton if in addition:
a ∈ unique implies a originates at no more than one n ∈ node.
A skeleton is similar to the notion of semi-bundle in [9]. The reason we define both preskeletons and skeletons is because preskeletons are useful as precursors to skeletons. One can transform a preskeleton to a skeleton by unifying and combining strands that originate the same atom a ∈ unique.
We select components of a preskeleton using subscripts. For instance, if A = (node, R, S, S'), then ≤A means R and uniqueA means S'. We write n ∈ A to mean n ∈ nodeA, and we say that a strand s is in A when at least one node of s is in
A. The A-height of s is the number of nodes of s in A. By Clauses iii and iv,
uniqueA ∩ nonA = ∅.
We will define the sub-[pre]skeleton relation analogously to the sub-bundle rela- tion:
Definition 5.2 A [pre]skeleton A is a sub-[pre]skeleton of A' if each of nodeA, ≤A
, nonA, uniqueA is a subset of nodeA' , ≤A' , nonA' , uniqueA' respectively, up to (injec- tive) renaming of nodes.
Bundles correspond to certain skeletons:
Definition 5.3 Bundle B realizes skeleton A if (1) the nodes of A are precisely the regular nodes of B; (2) n ≤A n' just in case n, n' ∈ nodeA and n ≤B n'; (3) K ∈ nonA

just in case K /и term(n) for any n ∈ B but K or K−1 is used in some n' ∈ B; (4) a ∈ uniqueA just in case a originates uniquely in B. if some B realizes A we say that A is a realized skeleton.
Example 5.4 The intended run bundle in Figure 2 realizes the skeleton in Figure
5. Likewise, the attack bundle in Figure 3 realizes the skeleton in Figure 6.
In fact, a bundle completely determines the skeleton it realizes.
Proposition 5.5 If B is a bundle, then there is a unique skeleton that it realizes. By condition (4), B does not realize A if A is a preskeleton but not a skeleton.

Homomorphisms.
Since preskeletons represent partial-information about a protocol run, it would be useful to define information-preserving maps between them: homomorphisms
Definition 5.6 Let A0, A1 be preskeletons, α a replacement, φ: nodeA0 → nodeA1 .
H = [φ, α] is a homomorphism if
For all n ∈ A0, term(φ(n)) = term(n) · α;
For all s, i, if s ↓ i ∈ A then there is an s' s.t. for all j ≤ i, φ(s ↓ j)= (s', j);
n ≤A0 m implies φ(n) ≤A1 φ(m);
nonA0 · α ⊂ nonA1 ;
uniqueA0 · α ⊂ uniqueA1 .
We write H: A0 → A1 when H is a homomorphism from A0 to A1.
Homomorphisms can transform preskeletons to skeletons by contracting nodes that originate the same a ∈ uniqueA. Furthermore, homomorphisms can transform preskeletons to realized skeletons.
There are many runs of the protocol compatible with a set of starting assump- tions represented by a preskeleton A. Homomorphisms from A to realized skeletons describe how A is part of a protocol run.
Definition 5.7 We say a homomorphism H realizes preskeleton A if it maps A to a realized skeleton A'. In this case, we say A is realizable. Realized skeletons are preskeletons that are realizable via the identity homomorphism.

Degeneracy
We use the notion of unique-origination to represent fresh generation of values such as nonces and session keys. This necessitates that we restrict the set of homomor- phisms we are interested in to homomorphisms that respect this intended real-world meaning of unique-origination.
Definition 6.1 [Degenerate Homomorphism] A replacement α is degenerate for A if there are distinct atoms a, b and a strand s where (1) a ∈ uniqueA originates at s ↓ i in A, (2) b occurs on s ↓ j for j ≤ i, and (3) a · α = b · α.



Na,A 
≤	Na,A 

¨A 	) .....................................
¨
	) B¨
¨

{|Na, Na, A|}K−1	≥	{|Na, Na, A|}K−1
¨• (	 ..................................... (	 ¨•

¨  {|N ' , Na, B|} −1
A
≤	{|N ' , Na, B|}  −1    ¨ 

	) .....................................
non = {K−1, K−1}
	) •

A	B
unique = {Na,N ' }

Fig. 7. Result of a degenerate homomorphism
H = [φ, α]: A0 → A is degenerate if α is degenerate for A0.
A degenerate replacement identifies a uniquely originating atom with some other atom already known at the time it is chosen. For example, a homomorphism that maps the skeleton in Figure 5 to the skeleton in Figure 7 by identifying Na and Nb is degenerate.
Degenerate homomorphisms are of negligible probability relative to stochastic models for protocols [5]. In the rest of this paper, the reader can assume every reference to homomorphisms is in fact restricted to non-degenerate homomorphisms.
In the same spirit, we are only interested in [pre]skeletons/bundles that respect the real-world meaning of unique-origination.
Definition 6.2 [Degenerate Preskeleton/Bundle] A [pre]skeleton/bundle is degen- erate if it contains a strand r · α of role r such that (1) a ∈ ur originates at r ↓ i (2) b occurs on r ↓ j for j ≤ i, and (3) a · α = b · α.
The skeleton in Figure 7 is degenerate.  Likewise, the reader can as- sume that every mention of [pre]skeletons/bundles is restricted to non-degenerate [pre]skeletons/bundles.

Shapes
Needham Schroeder
We saw that the ISO reject protocol has two shapes, one corresponding to the intended run and another corresponding to the attack. The Needham-Schoeder- Lowe [7,6] protocol has only one shape, corresponding to the intended run. This holds for NSL whether we take the point of view of a responder B, asking what global behavior must have occurred if B has had a local run of the protocol, or whether we start from a local run of an originator A. In either case, the other party must have had a matching run. A, however, can never be sure that the last message it sends was received by B, as A is no longer expecting to receive any further messages. Uniqueness of shape is perhaps not surprising for as strong a protocol as Needham-Schroeder-Lowe.


init	resp

	{|Na, A|}KB )
¨
  {|Na, A|}KB	) •
¨

¨
{|Na
, Nb|}KA
{|Na
¨
, Nb|}KA

¨• (		(	 ¨•

¨
{|Nb|}KB
¨
{|Nb|}KB

	)		) •
noninit = {K−1}	nonresp = {K−1}
A	B
uniqueinit = {Na}	uniqueresp = {Nb}

Fig. 8. The Needham Schroeder Protocol


{|Na, A|}KB'
≤	{|Na, A|}KB

¨A 	) ..................................... 	) B¨

¨
{|N
,N |}
≥	{|N
¨
,N |}

( a	b KA	..................................... ( a
¨
b  KA  •
¨

{|Nb|}KB'
≤	{|Nb|}KB

	) .....................................
non = {K−1, K−1}
	) •

A	B
unique = {Na, Nb}

Fig. 9. Only Shape for Needham Schroeder Responder
However, even a flawed protocol such as the original Needham-Schroeder proto- col, depicted in Figure 8 may have a unique shape, shown in Fig. 9, despite both the existence of an intended run depicted in Fig. 10 and an attack depicted in Fig. 11. Here we are studying Needham Schroeder starting from a local run of the responder role.
As a side note, notice that there is no attack on Needham Schroeder if we start from the initiator. That is, if we assume that an initiator A completes a run of

the protocol intended to be with B, and furthermore the private keys K−1
and

−1 of A and B respectively are not known to the penetrator, then it must be
the case that a matching run of responder B takes place. In contrast, the attack shown in 11 involves an initiator who intends to communicate with some B' having a compromised private key K−1. Hence, we do not consider it an attack on an initiator with reasonable key secrecy assumptions.
The NS Shape.
Recall that we are considering Needham-Schroeder from the perspective of a respon- der B intending to respond to A. Let us suppose that B’s nonce Nb has been freshly chosen and that the private keys K−1 and K−1 of A and B are both uncompromised,
A	B
and that B has executed the strand shown at the right in Fig. 9. In protocols using
asymmetric encryption, the private keys are used only by recipients to destructure


init	resp
•   {|Na, A|}KB ) •
¨	¨

¨
{|Na
¨
, Nb|}KA

¨• (	 ¨•
¨	¨
{|Nb|}KB
• 	) •

Fig. 10. Needham Schroeder Intended Run

{|Na, A|}KB'
¨A	) P¨

¨	¨ 
¨
{|Na, A|}KB

¨	• 	) B¨

¨
{|Na
¨
, Nb|}KA

¨• (	 ¨•
	{|Nb|}KB'	¨

	) P¨
¨ 
¨¨
{|Nb|}KB	 

• 	) •

Fig. 11. Bundle: Man-in-the-Middle attack on Needham-Schroeder

incoming messages. Given that—on a particular occasion—B received and sent these messages, what must have occurred elsewhere in the network?
A must have had a partially matching strand, with the messages sent and re- ceived in the order indicated by the arrows of both kinds and the connecting symbols
≤. These symbols mean that the endpoints are ordered, but that other behavior may intervene, whether adversary strands or regular strands. A’s strand is only partially matching, because the principal A meant to contact is some B' which may or may not equal B. There is no alternative: Any diagram containing the responder strand of Fig. 9 must contain at least an instance of the initiator strand, with the events ordered as shown, or it cannot have happened.
Although there is a single shape, there are two ways that this shape may be realized in executions. Either (1) B' /= B and hence B'’s private key may be compromised, in which case we may complete this diagram with adversary activity to obtain the Lowe attack [6]; or else (2) B' = B, leading to the intended run. Note that the shape expresses the most general scenario: there is some B' and we do not know whether or not it is equal to B.
Some protocols have more than one shape. ISO reject has two as we saw above. Otway-Rees has four. Recall that when searching for shapes we started from an initial ”skeleton”, often just a single strand representing the “point of view” of the analysis.


init	resp
{|Na, A|}KB	≤	{|Na, A|}KB
¨• 	)		) ¨•

¨
{|N
,N |}
≥	{|N
¨
,N |}

(	a	b KA	......... ( a
¨
b KA	•
¨

{|Nb|}KB	≤	{|Nb|}KB
	) ......... 	) •

Fig. 12. The Needham Schroeder Protocol Intended Run Skeleton
Formalizing Shapes
Due to the existence of an infinite set of homomorphisms realizing any preskeleton A, it is useful to find a small subset of those that characterizes all the runs. The notion of characterization is catered to an intuitive understanding of what it means for a protocol run to be an extension of another protocol run. Here we capture one notion of extension that we have, in our experience, found to be the most natural and useful.
Definition 7.1 A bundle B2 extends a bundle B1 if there is an atom replacement (note: not necessarily injective) α such that B1 · α is a sub-bundle of B2. Like- wise, for [pre]skeletons: A [pre]skeleton A2 extends a [pre]skeleton A1 if there is a replacement α such that A1 · α is a sub-[pre]skeleton of A2. Naturally extending this to homomorphisms: A homomorphism H2 : A → A2 extends a homomorphism H1 : A → A1 if there is an atom replacement α such that α ◦ H1 : A → A1 · α is simply a codomain restriction of H2. (i.e. A1 · α is a sub-[pre]skeleton of A2.)
This notion of extension can be equivalently, and more formally, stated as follows:
Definition 7.2 [Pre]Skeleton A2 extends [pre]skeleton A1 if and only if there is a node-injective homomorphism from A1 to A2.
Homomorphism H2 extends homomorphism H1 iff H2 = G ◦ H1 where G is a node-injective homomorphism.
Example 7.3 The intended-run skeleton for the Needham Schroeder responder in Fig. 12 extends the shape depicted in Fig. 9.
Now we can define what it means for a set of protocol runs (realized homomor- phisms/skeletons) to be a characterization for A.
Definition 7.4 A set X of homomorphisms is a characterization for A if
. Each H ∈ X realizes A
. Every homomorphism H' realizing A extends some H ∈ X
One may also think of a characterization for A as a set of realized skeletons (the set of codomains of the homomorphisms). However, regarding a characterization as a set of realizing homomorphisms from A is more informative, as it specifies how A

is part of the protocol runs. We may refer to “skeletons in the characterization”, in which case we are referring to the codomains of the homomorphisms in the characterization.
Clearly the set of all realizing homomorphisms for A is a characterization for A. However, we seek a characterization as small as possible: a minimal characteriza- tion, under some criterion of size (number of nodes, total size of messages... etc). We will show later that there is a single characterization that is a unique minimum for all these definitions of size simultaneously.
This notion of extension described above captures what it means for one proto- col run to simply be an elaboration on another run. One can make an argument for several alternative notions of extends, including not requiring node-injectivity for G in definition 7.2 above, and/or requiring atom-injectivity of G. Any of these defini- tions would yield characterizations that can be used to decide security predicates. However, they differ in their size, the ease by which they can be algorithmically constructed, and the ease by which an analyst can interpret the set of all runs and make judgements based on them. We chose this notion of extends based on our experience in automating protocol analysis, and we found that the minimum char- acterizations it yields succinctly capture the intuitive notion of “representative set of all protocol runs”.
Requiring node-injectivity in our definition of extends has another advantage, in that it results in a partial order as opposed to a preorder. Furthermore, the partial order is well-founded.
Definition 7.5 For skeletons, A1 ≤n A2 iff A2 extends A1. Likewise for homomor- phisms, H1 ≤n H2 iff H2 extends H1.
Proposition 7.6 ≤n is a well-founded partial order on skeletons (up to isomor- phism).
Proof. Clearly ≤n is reflexive and transitive.
Antisymmetry: if A≤n A' via H = [φ, α] and A'≤n A via H' then both have the same number of nodes. By considering the composition of H and H', we can see that H is node-bijective (φ is bijective) and atom-bijective (α is bijective). By considering the composition of H and H', we can also see that α is bijective from nonA to nonA' , and also from uniqueA to uniqueA' . Likewise φ is a bijection from the pairs in ≤A to
≤A' . Therefore H−1 = [φ−1, α−1] is a homomorphism, and is the inverse of H. H
is an isomomorphism.
Well-foundedness: For a skeleton A, let Occ(A) be the number of atom occurences in A. Let Atoms(A) be the number of distinct atoms in A, and define the atom- redundancy of a skeleton as red(A) = Occ(A) − Atoms(A). Also, let nonOcc(A) and uniqOcc(A) be the number of occurences in A of atoms in nonA and uniqueA, respectively. We can show that |node|, red , nonOcc, uniqOcc and | ≤ | are each non-decreasing with ≤n and lower bounded by 0. Let
Rank(A)= |nodeA| + red(A)+ nonOcc(A)+ uniqOcc(A)+ | ≤A |

The rank of a skeleton is non-decreasing with ≤n and lower bounded by 0. Fur- thermore, notice that if A ≤n A', and Rank(A) = Rank(A'), then A and A' must be isomorphic. It follows that ≤n is well-founded up to isomorphism.

This extends analogously to homomorphisms.
Corollary 7.7 ≤n is a well-founded partial order on homomorphisms (up to iso- morphism)
We will define shapes as the minimal realizing homomorphisms in this well- founded partial order
Definition 7.8 A homomorphism H is a shape for A if H realizes A and H is minimal under ≤n amongst homomorphisms realizing A. Let shapes(A) be the set of distinct (up to isomorphism) shapes of A.
Next, it becomes apparent that that the set of shapes of A describes (can be extended to) all runs compatible with A
Proposition 7.9 shapes(A) is a characterization for A
Proof. Since ≤n is well-founded, for any H' realizing A there is an H ∈ shapes(A) such that H ≤n H', and H' extends H.	 
In fact, the set of shapes is the minimum such set
Proposition 7.10 shapes(A) is a subset of any other characterization for A. Hence shapes(A) is the minimum characterization for A.
Proof. Take any other characterization X for A. Take any shape H ∈ shapes(A). Since X is a characterization, there must be some G ∈ X such that G ≤n H. Since H is minimal under ≤n then G  H.
 
From 7.10 we can see that shapes(A) is the smallest characterization for A under most definitions of size (number of nodes, total length of messages... etc).

Conclusions and Future Work
In cases where the set of shapes is finite, the shapes for a preskeleton A form a succint representation of all protocol runs compatible with A. In most protocols we have studied, we have found experimentally that any starting preskeleton yields a finite set of shapes. However, it would be useful to identify a subclass of protocols for which this is guaranteed. We expect that a subclass of protocols similar to those defined in [1] and [8] has this property.
We also developed an algorithm, discussed in [2], for constructing the set of shapes for a preskeleton. At a high level, the algorithm starts with the initial preskeleton, finds and solves an authentication test (see [4]) to yield a finite set of solution homomorphisms/preskeletons, then recurses on those. This results is a

tree of preskeletons with the shapes at the leaves. These shapes are annotated with secrecy information. The algorithm reasons about secrecy by trying to construct a shape that discloses a value. Further analysis of the properties of this algorithm will be the subject of future work.

References
Bruno Blanchet and Andreas Podelski. Verification of cryptographic protocols: Tagging enforces termination. In Andrew D. Gordon, editor, Foundations of Software Science and Computation Structures, number 2620 in LNCS, pages 136–152. Springer, April 2003.
Shaddin F. Doghmi, Joshua D. Guttman, and F. Javier Thayer. Searching for shapes in cryptographic protocols. In Tools and Algorithms for Construction and Analysis of Systems (TACAS), LNCS. Springer, March 2007. Extended version at URL:http://eprint.iacr.org/2006/435 .
Joshua D. Guttman. Security goals: Packet trajectories and strand spaces. In Roberto Gorrieri and Riccardo Focardi, editors, Foundations of Security Analysis and Design, volume 2171 of LNCS, pages 197–261. Springer Verlag, 2001.
Joshua D. Guttman and F. Javier Thayer. Authentication tests and the structure of bundles. Theoretical Computer Science, 283(2):333–380, June 2002.
Joshua D. Guttman, F. Javier Thayer, and Lenore D. Zuck. The faithfulness of abstract protocol analysis: Message authentication. Journal of Computer Security, 12(6):865–891, 2004.
Gavin Lowe. Breaking and fixing the Needham-Schroeder public-key protocol using FDR. In Proceeedings of tacas, volume 1055 of Lecture Notes in Computer Science, pages 147–166. Springer Verlag, 1996.
Roger Needham and Michael Schroeder. Using encryption for authentication in large networks of computers. Communications of the ACM, 21(12), 1978.
R. Ramanujam and S. P. Suresh. A decidable subclass of unbounded security protocol. In R. Gorrieri, editor, WITS ’03: Workshop on Issues in the Theory of Security, pages 11–20, Warsaw, April 2003.
Dawn Xiaodong Song. Athena: a new efficient automated checker for security protocol analysis. In Proceedings of the 12th IEEE Computer Security Foundations Workshop. IEEE Computer Society Press, June 1999.
