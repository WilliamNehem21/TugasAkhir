Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 286 (2012) 257–272
www.elsevier.com/locate/entcs

A Simply Typed λ-Calculus of Forward Automatic Differentiation
Oleksandr Manzyuk1,2
Department of Computer Science National University of Ireland Maynooth Maynooth, Ireland

Abstract
We present an extension of the simply typed λ-calculus with pushforward operators. This extension is motivated by the desire to incorporate forward automatic differentiation, which is an important technique in numeric computing, into functional programming. Our calculus is similar to Ehrhard and Regnier’s differential λ-calculus, but is based on the differential geometric idea of pushforward rather than derivative. We prove that, like the differential λ-calculus, our calculus can be soundly interpreted in differential λ- categories.
Keywords: tangent bundle, differential λ-calculus, differential category, categorical semantics.


Introduction
Automatic differentiation (AD) is a powerful technique for computing derivatives of functions given by programs in programming languages [6]. AD is superior to di- vided differences because AD-generated derivative values are free of approximation errors, and superior to symbolic differentiation because it can handle code of very high complexity and because it gives strong computational complexity guarantees. There exist many AD systems 3 (in the form of libraries and code pre-processors). A majority of these AD systems are built on top of imperative programming lan- guages (Fortran, C/C++), whereas the idea of AD is most naturally embodied in a functional programming language. Indeed, the differentiation operator is almost a paradigmatic example of a higher-order function. However, despite a huge body of

1 This work was supported, in part, by Science Foundation Ireland Principal Investigator grant 09/IN.1/I2637.
2 Email: manzyuk@gmail.com
3 http://www.autodiff.org/?module=Tools

1571-0661 © 2012 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2012.08.017

research 4 and proliferation of AD implementations, a clear semantics of AD in the presence of first-class functions is lacking, which inhibits the incorporation of AD into functional programming. Siskind and Pearlmutter [12] discuss the problems one faces trying to extend a functional programming language with AD operators. In particular, they emphasize the subtleties of AD of higher-order functions. They
describe [13] a novel AD system, Stalin∇, and claim that it correctly handles
higher-order functions. Although Stalin∇ does produce the correct answers for
examples where the other systems are known to fail, no correctness results are proven, which is hardly satisfactory.
In order to address these issues and to lay down a theoretical foundation for a functional programming language with support for AD, we suggest extending the λ-calculus with AD operators. In this paper, we make some first steps towards this goal. There are several variations of AD: forward, reverse, and mixtures thereof. We present a simply typed λ-calculus of forward AD, leaving the more complex reverse AD for future work.
The idea of extending the λ-calculus with differential operators is not novel. Drawing motivation from linear logic, Ehrhard and Regnier introduced the differ- ential λ-calculus [4]. Despite its origin in the denotational semantics of linear logic, the differential λ-calculus is also an attractive foundation on which to build a func- tional programming language with built-in support for differentiation. Unlike, for example, symbolic differentiation, the differential λ-calculus can handle not only mathematical expressions, but arbitrary λ-terms. Most notably, it can take deriva- tives through and of higher-order functions. However, like symbolic differentiation, the differential λ-calculus, implemented naively, yields a grossly inefficient way to compute derivatives, suffering from the loss of sharing.
We propose a variation of the differential λ-calculus, the perturbative λ-calculus, which, we conjecture, does not necessitate this loss of efficiency. Like forward AD, the perturbative λ-calculus is based on the differential geometric idea of pushforward rather than that of derivative. Like the differential λ-calculus, the perturbative λ-calculus can be interpreted in an arbitrary differential λ-category of Bucciarelli et al. [3]. We prove that the interpretation is sound. We believe that the proofs of confluence and strong normalization for the differential λ-calculus given in [4] can be adapted to the perturbative λ-calculus. However, a formal treatment of these questions is left for future research.
Forward AD
To motivate the definition of the perturbative λ-calculus, we briefly outline the ideas behind forward AD. They are most naturally explained in differential geometric terms. Let TX denote the tangent bundle of a smooth manifold X. For example, the tangent bundle T Rn of the Euclidean space Rn can be identified with the cartesian product Rn × Rn. An element (xj, x) of the tangent bundle T Rn is viewed

4 The publication database of the website http://www.autodiff.org contains 1277 entries at the moment of writing.

as a primal x ∈ Rn paired with a tangent (or perturbation) xj ∈ Rn. A smooth map between smooth manifolds f : X → Y gives rise to a smooth map Tf : TX → TY , called the pushforward of f . For example, the pushforward Tf : T Rm = Rm × Rm → Rn × Rn = T Rn of a smooth map f : Rm → Rn is given by Tf (xj, x) = (Jf (x) · xj,f (x)), where Jf (x) is the Jacobian of f at the point x. The correspondences X '→ TX, f '→ Tf constitute a functor from the category of smooth manifolds to itself. Preservation of composition is a consequence of the chain rule. Furthermore, T preserves products. Informally, this means that in order to compute the pushforward of a compound function it suffices to know the pushforwards of its constituents. The implementations of forward AD take advantage of this, typically in one of the following ways:
By overloading the primitives, so that they can accept both numbers and tangent bundle pairs as inputs. Each overloaded primitive denotes two functions: the function computed originally by that primitive and its pushforward. Then any user-defined procedure built out of the overloaded primitives also denotes (and can be used to compute by supplying arguments of appropriate types) two functions: a function f : Rm → Rn and its pushforward Tf : T Rm → T Rn.
By generating (either internally by the compiler or externally by a pre-processor) the source code of a procedure computing the pushforward Tf : T Rm → T Rn of a function f : Rm → Rn from the source code of a procedure computing the function f . This transformational approach can be seen as an enhancement of symbolic differentiation that recovers sharing by simultaneously manipulating the primal and tangent values.
In either way, defining in a program a procedure computing a function f automat- ically gives access to a procedure computing the pushforward of f .
Let us illustrate the method with an example covering ordinary arithmetic. Be- cause the tangent bundle functor T preserves products, it follows that the pushfor- wards T (+),T (·): T R ×T R  T (R × R) → T R of the operations +, · : R × R → R equip T R with the structure of a ring. The tangent bundle T R is isomorphic as a ring to the ring R[ε]/(ε2) of dual numbers via (xj, x) '→ x + xjε, and below we identify T R with R[ε]/(ε2). The operations + and · in T R correspond exactly to the pushforwards of the operations + and · in R. Hence, we can overload + and · to mean both. Computing the pushforward of a function built out of + and · amounts to interpreting the body of the function over the dual numbers.
For example, the derivative of λx. x2 + 1 at the point 3 is obtained by computing the pushforward of λx. x2 + 1 at the point 3+1ε = 3+ε and taking the perturbation part of the result. The former amounts to evaluating the expression x2 + 1 at the point 3 + ε interpreting + and · as addition and multiplication of dual numbers, respectively:
T (λx. x2 + 1)(3 + ε)= (λx. x2 + 1)(3 + ε)= (3 + ε) · (3 + ε)+1 = 10 + 6ε.
In other words, the derivative of a function f at a point x can be computed as
Df x = E (f (x + ε)), where E is given by E (x + xjε)= xj.

The story becomes more complicated in the presence of first-class functions because the spaces of procedure inputs and outputs need no longer be Euclidean and may be function spaces instead. Furthermore, as pointed out by Siskind and Pearlmutter [12], implementations must be careful not to confuse the perturbations that arise when pushing the same function forward multiple times.
We illustrate this problem of perturbation confusion with an example involving nested invocations of the derivative operator D, for example D (λx. x · D (λy. x) 2) 1. Because the inner derivative is equal to 0, the value of the whole expression should also be 0. However, applying the formula for D naively, we obtain:
D (λx. x · D (λy. x) 2)1 = E ((λx. x · D (λy. x) 2)(1 + ε))
= E ((1 + ε) · D (λy. (1 + ε)) 2)
= E ((1 + ε) · E ((λy. (1 + ε))(2 + ε)))
= E ((1 + ε) · E (1 + ε))
= E ((1 + ε) · 1) = E (1 + ε)=1 /= 0.
As explained in [12], the root of this error is our failure to distinguish between the perturbations introduced by the inner and outer invocations of D. There are ways to solve this problem, for instance by tagging perturbations with a fresh ε every time D is invoked and incurring the bookkeeping overhead of keeping track of which ε is associated with which invocation of D. Nonetheless, we hope the example serves to illustrate the value and nontriviality of a clear semantics for a λ-calculus with AD. What do we mean when we say that symbolic differentiation suffers from the loss of sharing? And how does forward AD fix this problem? Let us illustrate with an example. Consider the problem of computing the derivative of a product of n functions: f (x)= f1(x) · f2(x) · ... · fn(x). Applying the product rule, we arrive at
the expression for the derivative, which has size quadratic in n:
fj(x)= fj (x)·f2(x)·...·fn(x)+ f1(x)·fj (x)·...·fn(x)+···+ f1(x)·f2(x)·...·fj (x).
1	2	n
Evaluating it naively would result in evaluating each fi(x) n − 1 times. If our cost model is that evaluating fi(x) or fj(x) each cost 1, and the arithmetic operations are free, then f (x) has a cost of n, whereas fj(x) has a cost of n2. Contrast this with forward AD: the pushforward Tf (x + xjε) is the product (in the sense of dual numbers) of the pushforwards Tf1(x + xjε), Tf2(x + xjε), ..., Tfn(x + xjε). Evaluating each Tfi(x+xjε) amounts to evaluating fi(x) and fj(x), and hence has a cost of 2. Therefore, the cost of Tf (x + ε) is 2n. In general, forward AD guarantees that evaluating fj takes no more than a constant factor times as many operations as evaluating f .

Tangent Bundles in Differential λ-Categories
The definition of the interpretation of the perturbative λ-calculus as well as the proof of its soundness rely on the theory of tangent bundles in differential λ-categories

developed in [9]. To make this paper self-contained, we summarize the results of that theory here. The reader is referred to [9] for more details.
Let C be a cartesian category and X, Y , Z objects of C. We denote by X × Y the product of X and Y and by π1 : X × Y → X, π2 : X × Y → Y the projections. The terminal object is denoted by 1, and for any object X, we denote by !X the unique morphism from X to 1. For a pair of morphisms f : Z → X and g : Z → Y , denote by ⟨f, g⟩ : Z → X × Y the pairing of f and g, i.e., the unique morphism such that π1 ◦ ⟨f, g⟩ = f and π2 ◦ ⟨f, g⟩ = g.
A cartesian category C is called closed if for any pair of objects X and Y
of C there exists an object X ⇒ Y , called the exponential object, and a morphism evX,Y : (X ⇒ Y ) ×X → Y , called the evaluation morphism, satisfying the following universal property: the map Λ- : C(Z, X ⇒ Y ) → C(Z × X, Y ) given by Λ-(g) = evX,Y ◦(g × idX ) is bijective. Let Λ : C(Z × X, Y ) → C(Z, X ⇒ Y ) denote the inverse of Λ-. In other words, for a morphism f : Z × X → Y , Λ(f ): Z → X ⇒ Y is the unique morphism such that evX,Y ◦(Λ(f ) × idX )= f . The morphism Λ(f ) is called the currying of f . We shall make use of the equations
Λ(f ) ◦ g = Λ(f ◦ (g × id)),	(1) ev ◦⟨Λ(f ), g⟩ = f ◦ ⟨id, g⟩,	 (2)
which follow immediately from the definition of Λ.
The notion of cartesian differential category was introduced by Blute et al. [2] as an axiomatization of differentiable maps as well as a unifying framework in which to study different notions reminiscent of the differential calculus.
Definition 3.1 ([2, Definition 1.1.1]) A category C is left-additive if each hom- set is equipped with the structure of a commutative monoid (C(X, Y ), +, 0) such that (g + h) ◦ f = (g ◦ f )+ (h ◦ f ) and 0 ◦ f = 0. A morphism f in C is additive if it satisfies f ◦ (g + h)= (f ◦ g)+ (f ◦ h) and f ◦ 0= 0.
Definition 3.2 ([2, Definition 1.2.1]) A category is cartesian left-additive if it is a left-additive category with products such that all projections are additive, and all pairings of additive morphisms are additive.
Remark 3.3 Let C be a cartesian left-additive category. Then the pairing map
⟨−, −⟩ : C(Z, X)×C(Z, Y ) → C(Z, X ×Y ) is additive: ⟨f +g, h+k⟩ = ⟨f, h⟩+⟨g, k⟩ and ⟨0, 0⟩ = 0. Furthermore, for each pair of objects X and Y there are morphisms ι1 d=ef ⟨idX, 0⟩ : X → X × Y and ι2 d=ef ⟨0, idY ⟩ : Y → X × Y , which satisfy the equations π1 ◦ι1 = idX , π2 ◦ι2 = idY , πk ◦ιl =0 if k /= l, and ι1 ◦π1 +ι2 ◦π2 = idX×Y . Note, however, that in contrast with additive categories, in a left-additive category these equations do not imply that the morphisms ι1 and ι2 equip X × Y with the structure of a coproduct of X and Y . This is so on the subcategory of additive morphisms, but not necessarily on the full category.
Definition 3.4 ([2, Section 1.4, Definition 2.1.1], [3, Definition 4.2]) A cartesian closed category is cartesian closed left-additive if it is a cartesian left- additive category such that each currying map Λ : C(Z × X, Y ) → C(Z, X ⇒ Y )

is additive: Λ(f + g)= Λ(f )+ Λ(g) and Λ(0) = 0. A cartesian (closed) differential category is a cartesian (closed) left-additive category equipped with an operator D : C(X, Y ) → C(X × X, Y ) satisfying the following axioms:
D1. D(f + g)= D(f )+ D(g) and D(0) = 0.
D2. D(f ) ◦ ⟨h + k, v⟩ = D(f ) ◦ ⟨h, v⟩ + D(f ) ◦ ⟨k, v⟩ and D(f ) ◦ ⟨0, v⟩ = 0. D3. D(id) = π1, D(π1)= π1 ◦ π1, D(π2)= π2 ◦ π1.
D4. D(⟨f, g⟩)= ⟨D(f ), D(g)⟩.
D5. D(f ◦ g)= D(f ) ◦ ⟨D(g),g ◦ π2⟩.
D6. D(D(f )) ◦ ⟨⟨g, 0⟩, ⟨h, k⟩⟩ = D(f ) ◦ ⟨g, k⟩.
D7. D(D(f )) ◦ ⟨⟨0, h⟩, ⟨g, k⟩⟩ = D(D(f )) ◦ ⟨⟨0, g⟩, ⟨h, k⟩⟩.
The paradigmatic example of a cartesian differential category is the category of smooth maps, whose objects are natural numbers and morphisms m → n are smooth maps Rm → Rn. The operator D takes an f : Rm → Rn and produces a D(f ) : Rm × Rm → Rn given by D(f )(xj, x) = Jf (x) · xj, where Jf (x) is the Jacobian of f at the point x.
Some intuition for the axioms: D1 says D is additive; D2 that D(f ) is additive in its first coordinate; D3 and D4 assert that D is compatible with the product structure, and D5 is the chain rule. We refer the reader to [2, Lemma 2.2.2] for the proof that D6 is essentially requiring that D(f ) be linear (in the sense defined below) in its first variable. D7 is essentially independence of order of partial differentiation. Following [2], we say that a morphism f is linear if D(f ) = f ◦ π1. By [2,
Lemma 2.2.2], the class of linear morphisms is closed under sum, composition,
pairing, and product, and contains all identities, projections, and zero morphisms. Also, axiom D2 implies that any linear morphism is additive.
The notion of cartesian differential category was partly motivated by a desire to model the differential λ-calculus of Erhard and Regnier [4] categorically. Blute et al.
[2] proved that cartesian differential categories are sound and complete to model suitable term calculi. However, the properties of cartesian differential categories are too weak for modeling the full differential λ-calculus because the differential operator is not necessarily compatible with the cartesian closed structure. For this reason, Bucciarelli et al. [3] introduced the notion of differential λ-category.
Definition 3.5 ([3, Definition 4.4]) A differential λ-category is a cartesian closed differential category such that D(Λ(f )) = Λ(D(f ) ◦ ⟨π1 × 0X, π2 × idX ⟩) holds, for each f : Z × X → Y .
This differential λ-category axiom is essentially requiring that the evaluation morphism ev be linear in its first argument.
Example 3.6 Blute et al. [1] proved that the category of convenient vector spaces and smooth maps is a cartesian closed differential category. We have shown in [9] that it is in fact a differential λ-category. We refer the reader to [3] for two other examples of differential λ-categories.

The differential operator D allows us to replicate the construction of the tangent bundle of a smooth manifold from differential geometry in any cartesian differential category. Let C be a cartesian differential category. The tangent bundle functor T : C → C is defined by TX = X × X and T (f )= ⟨D(f ),f ◦ π2⟩.
Lemma 3.7 ([9, Lemma 3.1.3]) If f is linear, then T (f )= f × f.
The tangent bundle functor T is part of a monad. For each object X of C, the unit ηX of the monad is the morphism ⟨0, idX ⟩ : X → X × X = TX, and the multiplication μX of the monad is the morphism ⟨π2 ◦ π1 + π1 ◦ π2, π2 ◦ π2⟩ : TTX = (X×X)×(X×X) → X×X = TX. The monad (T, η, μ) is strong [10, Definition 3.2]. The tensorial strength tX,Y : X × TY → T (X × Y ), also called the right tensorial strength, is given by tX,Y = ⟨⟨0, π1 ◦ π2⟩, ⟨π1, π2 ◦ π2⟩⟩ = ⟨0 × π1, idX ×π2⟩. Using the symmetry cA,B = ⟨π2, π1⟩ : A × B → B × A of C, we may also define the left
tensorial strength by tj	= T (cY,X ) ◦ tY,X ◦ cTX,Y : TX × Y → T (X × Y ). More
explicitly, tj	= ⟨⟨π1 ◦ π1, 0⟩, ⟨π2 ◦ π1, π2⟩⟩ = ⟨π1 × 0, π2 × idY ⟩.
Because the functor T is part of a strong monad, by [7, Theorem 2.1] T becomes
a monoidal functor (T, ψ, ψ0) : C → C if we put ψX,Y equal to the composite
ψX,Y  = μX×Y ◦ T (tX,Y ) ◦ tj	: TX × TY → T (X × Y ) and by putting ψ0 =
η1 : 1 → T 1. The definition of ψX,Y is asymmetric, and indeed there is also a

morphism ψ˜X,Y = μX×Y ◦ T (tj
) ◦ tTX,Y : TX × TY → T (X × Y ) that also makes

T into a monoidal functor. The morphisms ψ and ψ˜ can be computed explicitly. It
is shown in [9, Lemmas 3.4.1, 3.4.2] that ψ and ψ˜ are equal and coincide with the
distributivity isomorphism σ. In particular, (T, η, μ) is a commutative monad [7, Definition 3.1].
Lemma 3.8 ([9, Lemma 3.4.5]) Let f : Z → X, g : Z → Y be morphisms in C. Then T ⟨f, g⟩ = ψ ◦ ⟨T (f ),T (g)⟩.
From now on we assume that C is a differential λ-category.
Proposition 3.9 ([9, Proposition 3.6.2]) Let g : A × B → C be a morphism in
C. Let h = T (g) ◦ tj : TA × B → TC. Then T (Λ(g)) = ⟨Λ(π1 ◦ h), Λ(π2 ◦ h)⟩ :
TA → T (B ⇒ C).
The cartesian closed category C is a symmetric monoidal closed category, with the monoidal structure given by product, and hence also a closed cate- gory of Eilenberg and Kelly [5].  By [5, Proposition 4.3], the monoidal functor
(T, ψ, ψ0) : C → C gives rise to a closed functor (T, ψˆ, ψ0) : C → C, where
ψˆ = ψˆX,Y : T (X ⇒ Y ) → (TX ⇒ TY ) is given by ψˆ = Λ(T (ev) ◦ ψ). We have
shown in [9, Section 3.7] that
T (ev)◦ψ = ⟨ev ◦(π1×π2)+D(ev)◦t◦(π2×id), ev ◦(π2×π2)⟩ : T (X ⇒ Y )×TX → TY.
(3)
The cartesian closed category C gives rise to a category C enriched in C: the objects of C are the objects of C, and C(X, Y )= X ⇒ Y , for each pair of object X and Y of C. By [8, Theorem 1.3], the functor T : C → C equipped with the

tensorial strength t gives rise to a C-functor T : C → C such that TX = TX and
T = TX,Y : (X ⇒ Y ) → (TX ⇒ TY ) is given by T = Λ(T (ev) ◦ t).
Theorem 3.10 ([9, Theorem 3.8.2]) T is a linear morphism.
Proposition 3.11 ([9, Proposition 3.8.3]) Let f : Z × X → Y be a morphism in C. Then T ◦ Λ(f )= Λ(T (f ) ◦ t).
We shall also need the following definition and easy lemma.
Definition 3.12 ([3, Definition 4.6]) Let sw = swX,Y,Z denote the morphism sw = ⟨⟨π1 ◦ π1, π2⟩, π2 ◦ π1⟩ : (X × Y ) × Z → (X × Z) × Y . Clearly, sw is a linear morphism. Furthermore, sw ◦⟨⟨f, g⟩, h⟩ = ⟨⟨f, h⟩, g⟩.
Lemma 3.13 T (sw) ◦ tj ◦ (t × id) = t ◦ sw : (X × TZ) × Y → T ((X × Y ) × Z).

Perturbative λ-Calculus
In this section we describe the perturbative λ-calculus. Its syntax is very similar to the syntax of the differential λ-calculus of Ehrhard and Regnier [4] with two notable differences:
Instead of introducing a syntactic form D s · t denoting the derivative of s in direction t, we extend the λ-calculus with a syntactic form T s denoting the pushforward of s.
To syntactically enforce the fact that pairs are linear, instead of introducing a syntax for pairs, we introduce two syntactic forms: ιks (injection of s into the kth factor of a product) and πks (projection of s onto the kth coordinate), k = 1, 2. With the syntax for injections, pairs can be introduced as syntactic sugar and linearity is automatic.
More formally, the set Λp of perturbative λ-terms and the set Λs of simple λ-terms
are defined by mutual induction as follows:

Λp :	M, N ::= 0 | s | s + N,
Λs :	s, t ::= x | λx. s | sN | T s | ιks | πks,	k = 1, 2,

Thus, every perturbative λ-term is a formal sum of a finite (possibly empty) bag of simple λ-terms. The operation + is extended to arbitrary perturbative λ-terms in the obvious way as the union of bags. The term 0 denoting the empty bag is the neutral element of the sum. We consider perturbative λ-terms up to α-conversion, associativity and commutativity of the sum. We write M ≡ N if M and N are syntactically equal up to the aforementioned equivalences. The term T s is the pushforward of s. The set FV(M ) of free variables of M is defined as usual. We



Γ(x)= σ Γ ▶ x : σ
Γ; x : σ ▶ s : τ
Γ ▶ λx. s : σ → τ
Γ ▶ s : σ → τ	Γ ▶ N : σ
Γ ▶ sN : τ



Γ ▶ 0: σ
Γ ▶ s : σ	Γ ▶ N : σ
Γ ▶ s + N : σ
Γ ▶ s : σk
Γ ▶ ιks : σ1 × σ2
Γ ▶ s : σ1 × σ2
Γ ▶ πks : σk

Γ ▶ s : σ → τ
Γ ▶ T s : T σ → T τ

Fig. 1. Typing rules of the perturbative λ-calculus
introduce the following syntactic sugar:

λx. Σn
s d=ef Σn
λx. s ,	ι  Σn
s d=ef Σn

ι s ,

T Σn
s d=ef Σn
T s ,	π  Σn
s d=ef Σn
π s ,

 Σn
s N d=ef Σn
s N,	⟨M ,M ⟩ d=ef ι M
+ ι M ,

where the sums reduce to the term 0 if n = 0. Note that the terms in the left hand sides of the above equations are not valid terms in the language. They are abbrevi- ations for the respective terms in the right hand sides of the equations. Note also that this way we syntactically capture the linearity of abstractions, pushforwards, injections, projections, pairs, and applications in the operator position.
Let us define the type system that characterizes the simply typed perturbative λ-calculus. We assume that we are given some atomic types α, β, . .., and if σ and τ are types, then so are σ × τ and σ → τ . We define 5 a type function T by Tσ = σ × σ. The typing rules are shown in Figure 1. They are the standard typing rules of the simply typed λ-calculus with products, extended by the typing rules for T and the sum.
Let M , P be perturbative λ-terms and x a variable. The substitution of P for x in M , denoted by M [P/x], is defined by induction on M as shown in Figure 2. The usual caveat applies to the definition of (λy. s)[P/x], namely that by α-conversion we may assume that x /= y and y /∈ FV(P ).
We impose the reduction rules listed in Figure 3:  the usual β-reduction
(λx. s)N →β s[N/x] and projection-injection rules πk(ιks) →× s and πk(ιls) →× 0, where k, l ∈ {1, 2}, k /= l. There is also a reduction rule for T, which is similar in shape to the reduction rule for D in the differential λ-calculus, but is suggested by the general categorical properties of tangent bundles in differential λ-categories [9]. More specifically, the reduction rule for T is T(λx. s) →T λx. Tx s, where Tx M is defined by induction on M according to the equations shown in Figure 4. The definition of Tx(λy. s) is subject to the standard side condition, namely that by

5 The definition of T is motivated by our desire to interpret the perturbative λ-calculus in differential λ-categories, for example, the category of convenient vector spaces and smooth maps. The tangent bundle of a convenient vector space E is isomorphic to E × E, which we reflect in the calculus by defining T σ to be σ × σ. It would be interesting to generalize T to allow types σ to be general smooth spaces and T σ the tangent bundle, which would not in general be definable as σ × σ. We leave this for future work.



y[P/x]=	P	if x = y,
y	otherwise,
0[P/x]= 0,

(λy. s)[P/x]= λy. (s[P/x]),	(s + N )[P/x]= s[P/x]+ N [P/x],
(sN )[P/x]= (s[P/x])(N [P/x]),	(ιks)[P/x]= ιk(s[P/x]),
(T s)[P/x]= T(s[P/x]),	(πks)[P/x]= πk(s[P/x]).

Fig. 2. Definition of substitution


(λx. s)N →β s[N/x]	πk(ιks) →× s	πk(ιls) →× 0	T(λx. s) →T λx. Tx s

Fig. 3. Reduction rules of the perturbative λ-calculus


T y =	x	if x = y
ι2y	otherwise
Tx 0=0 

Tx(λy. s)= ⟨λy. π1(Tx s), λy. π2(Tx s)⟩	Tx(s + N )= Tx s + Tx N
Tx(sN )= (Tx s) ⬦ (Tx N )	Tx(ιks)= ⟨ιk(π1(Tx s)), ιk(π2(Tx s))⟩
Tx(T s)= ⟨T (π1(Tx s)), T (π2(Tx s))⟩	Tx(πks)= ⟨πk(π1(Tx s)), πk(π2(Tx s))⟩ M ⬦ N d=ef ⟨(π1M )(π2N )+ π1((T (π2M )) N ), (π2M )(π2N )⟩
Fig. 4. Definition of Tx

α-conversion we may assume that x is different from y. To simplify the notation, we have introduced some syntactic sugar: the operation ⬦, which is also defined in Figure 4. The typing rule for ⬦ can be derived from the typing rules for other syntactic forms and reads as follows:
Γ ▶ M : T(σ → τ )	Γ ▶ N : T σ
Γ ▶ M ⬦ N : T τ
Let us provide some intuition for these equations. We define Tx x = x because the pushforward of the identity function is the identity function; similarly, we set Tx y = ι2y if x /= y because the pushforward of the constant function is a constant function returning the lifted value. The definitions of Tx over abstractions and applications are suggested by Proposition 3.9 and equation (3), respectively. The definitions of Tx over T, πk, and ιk have the given shape because T , πk, and ιk are linear morphisms (T is linear by Theorem 3.10). Finally, the definition of Tx over
sums follows from the additivity of the tangent bundle functor.
Denote by → the contextual closure of →β ∪ →× ∪ →T.
Lemma 4.1 The type system of the simply typed perturbative λ-calculus satisﬁes



Γ ▶ (λx. s)N : τ
Γ ▶ (λx. s)N = s[N/x]: τ
Γ; x : σ ▶ s = t : τ
Γ ▶ λx. s = λx. t : σ → τ Γ ▶ s = t : σ	x : τ /∈ Γ Γ; x : τ ▶ s = t : σ
Γ ▶ s = t : σ1 × σ2
Γ ▶ πks = πkt : σk
(β)

(ξ)

(W )

(π)
Γ ▶ T(λx. s): T σ → T τ

Γ ▶ T(λx. s)= λx. Tx s : T σ → T τ
Γ ▶ s1 = s2 : σ → τ	Γ ▶ N1 = N2 : σ

Γ ▶ s1N1 = s2N2 : τ
Γ ▶ s = t : σ → τ

Γ ▶ T s = T t : T σ → T τ
Γ ▶ s1 = s2 : σ	Γ ▶ N1 = N2 : σ Γ ▶ s1 + N1 = s2 + N2 : σ
(T)

(Ap)

(TAp)

(Sum)

	Γ ▶ s = t : σk	
Γ ▶ ιks = ιkt : σ1 × σ2
(ι)
Γ ▶ s : σ
Γ ▶ πk(ιks)= s : σ
Γ ▶ s : σ
Γ ▶ πk(ιls)=0: σ
(πι)

Fig. 5. Perturbative λ-theory rules
the following properties.
If Γ; x : σ ▶ M : τ and Γ ▶ N : σ, then Γ ▶ M [N/x]: τ.
If Γ; x : σ ▶ M : τ, then Γ; x : T σ ▶ Tx M : T τ.
If Γ ▶ πk(ιkN ): σ, then Γ ▶ N : σ.
If Γ ▶ N : σ and N → Nj, then Γ ▶ Nj : σ.
Proof. (a) and (b) follow by straightforward induction on the length of the proof of the corresponding typing judgment. (c) is obvious. (d) follows from (a), (b), and
(c) because type derivations are contextual.	2
To facilitate the proof that applying the reduction rules preserves the meaning, which is what soundness really means, we introduce the notion of perturbative λ- theory. Let T be a collection of judgments of the shape Γ ▶ M = N : σ such that Γ ▶ M : σ and Γ ▶ N : σ. T is called a perturbative λ-theory if it is closed under the rules shown in Figure 5 (where k, l ∈ {1, 2} and k /= l) together with the obvious rules for reflexivity, transitivity, and symmetry. Equations (β), (T), (πι) are imposed by the reduction rules. The remaining rules say that the equality relation is contextual.
5	Categorical Semantics
In this section we show that, like the simply typed variant of the differential λ-cal- culus of Ehrhard and Regnier [4], the simply typed perturbative λ-calculus can be modeled by differential λ-categories of Bucciarelli et al. [3]. We have shown in [9] that an arbitrary differential λ-category is equipped with a canonical pushforward construction. The perturbative λ-calculus captures the pushforward construction as a syntactic operation.
Let C be a differential λ-category. Let us define the interpretation of the simply typed perturbative λ-calculus from the previous section in the category C. The definition is similar to the interpretation of the simply typed differential λ-calculus

in a differential λ-category defined in [3]. Types are interpreted as follows: |α| = A, for some object A, |σ × τ | = |σ| × |τ |, and |σ → τ | = |σ| ⇒ |τ |. Contexts are interpreted as usual: |∅| = 1 and |Γ; x : σ| = |Γ| × |σ|. The interpretation of a judgment Γ ▶ M : σ will be a morphism from |Γ| to |σ| denoted by |Mσ|Γ and defined inductively as follows:
|xσ|Γ;x:σ = π2 : |Γ|× |σ| → |σ|;
|yτ |Γ;x:σ = |yτ |Γ ◦ π1 : |Γ|× |σ| → |τ | for x /= y;
|(sN )τ |Γ = ev ◦⟨|sσ→τ |Γ, |Nσ|Γ⟩ : |Γ| → |τ |;
|(λx. s)σ→τ |Γ = Λ(|sτ |Γ;x:σ): |Γ| → |σ| ⇒ |τ |;
|(T s)T σ→T τ |Γ = T |σ|,|τ| ◦ |sσ→τ |Γ : |Γ| → T |σ| ⇒ T |τ |;
|0σ|Γ =0: |Γ| → |σ|;
|(s + N )σ|Γ = |sσ|Γ + |Nσ|Γ : |Γ| → |σ|;
|(ιks)σ1×σ2 |Γ = ιk ◦ |sσk |Γ : |Γ| → |σ1|× |σ2|, k = 1, 2;
|(πks)σk |Γ = πk ◦ |sσ1×σ2 |Γ : |Γ| → |σk|, k = 1, 2.
The only interesting case is that of T s, which is what we were really after; the other cases are standard. It follows from the definitions that |⟨M, N ⟩|Γ = ⟨|M |Γ, |N |Γ⟩. We shall omit the superscript σ in |Mσ|Γ when there is no risk of confusion.
Given a differential λ-category C, we define the theory of C by
Th(C)= {Γ ▶ M = T : σ | Γ ▶ M : σ,	Γ ▶ N : σ,	|Mσ|Γ = |Nσ|Γ}.
We are going to prove that the interpretation | · | is sound for the simply typed perturbative λ-calculus, i.e., that Th(C) is a perturbative λ-theory. We begin by proving some lemmas. Lemmas 5.1 and 5.2 are standard.
Lemma 5.1 |M |Γ;x:σ;y:τ = |M |Γ;y:τ;x:σ ◦ sw.
Lemma 5.2 If Γ ▶ M : τ and x /∈ FV(M ), then |Mτ |Γ;x:σ = |Mτ |Γ ◦ π1.
Lemma 5.3 Let Γ ▶ M : T(σ → τ ) and Γ ▶ N : T σ. Then
|(M ⬦ N )T τ |Γ = T (ev) ◦ ψ ◦ ⟨|M T(σ→τ)|Γ, |N T σ|Γ⟩.
Proof. Expanding M ⬦ N and applying the definition of the interpretation, we find that |M ⬦ N |Γ is equal to
⟨ ev ◦⟨π1 ◦ |M |Γ, π2 ◦ |N |Γ⟩ + π1 ◦ ev ◦⟨T ◦ π2 ◦ |M |Γ, |N |Γ⟩,
ev ◦⟨π2 ◦ |M |Γ, π2 ◦ |N |Γ⟩⟩
= ⟨ ev ◦(π1 × π2)+ π1 ◦ ev ◦(T ◦ π2 × id), ev ◦(π2 × π2)⟩◦ ⟨|M |Γ, |N |Γ⟩.
The summand π1 ◦ ev ◦(T ◦ π2 × id) is equal to π1 ◦ T (ev) ◦ t ◦ (π2 × id) = D(ev) ◦
t ◦ (π2 × id) by the definitions of T and T . We conclude that |M ⬦ N |Γ is equal to
⟨ev ◦(π1 × π2)+ D(ev) ◦ t ◦ (π2 × id), ev ◦(π2 × π2)⟩◦ ⟨|M |Γ, |N |Γ⟩, which coincides with T (ev) ◦ ψ ◦ ⟨|M |Γ, |N |Γ⟩ by equation (3).	2

Lemma 5.4 (Substitution) Let Γ; x : σ ▶ M : τ and Γ ▶ P : σ.  Then
|(M [P/x])τ |Γ = |Mτ |Γ;x:σ ◦ ⟨id|Γ|, |Pσ|Γ⟩.

Proof. The proof is by induction on M . The only new cases are M ≡ T s, M ≡ ιks, and M ≡ πks. However, they are straightforward. For example, |(T s)[P/x]|Γ =
| T(s[P/x])|Γ = T ◦|s[P/x]|Γ by the definitions of substitution and |·|, which is equal to T ◦|s|Γ;x:σ ◦⟨id|Γ|, |P |Γ⟩ = | T s|Γ;x:σ ◦⟨id|Γ|, |P |Γ⟩ by the induction hypothesis and the definition of |· |.	2


Lemma 5.5 Let Γ; x : σ ▶ M : τ. Then |(Tx M )T τ |Γ;x:T σ = T (|Mτ |Γ;x:σ) ◦ t.

Proof. The proof is by induction on M .
M ≡ x. Then, on the one hand, | Tx x|Γ;x:T σ = |x|Γ;x:T σ = π2 by the definitions of Tx and | · |. On the other hand, expanding the definitions of | · | and t, and observing that T (π2) = π2 × π2 by Lemma 3.7 because π2 is linear, we obtain T (|x|Γ;x:σ) ◦ t = T (π2) ◦ t = (π2 × π2) ◦ ⟨0 × π1, id ×π2⟩, which reduces to π2 by the properties of left-additive cartesian categories.
M ≡ y /= x. Then, on the one hand, by the definitions of Tx and | · |, we have
| Tx y|Γ;x:T σ = |ι2y|Γ;x:T σ = ⟨0, |y|Γ;x:T σ⟩ = ⟨0, |y|Γ ◦ π1⟩. On the other hand, expanding the definitions of | · | and t, and observing that T (π1) = π1 × π1 by Lemma 3.7 because π1 is linear, we obtain T (|y|Γ;x:σ)◦t = T (|y|Γ◦π1)◦t = T (|y|Γ)◦ T (π1)◦t = T (|y|Γ)◦(π1 ×π1)◦⟨0×π1, id ×π2⟩, which reduces to T (|y|Γ)◦⟨0, π1⟩ by the properties of left-additive cartesian categories. It follows from the definition of the interpretation | · | that |y|Γ is a composition of projections, and hence is linear. Lemma 3.7 implies that T (|y|Γ) = |y|Γ × |y|Γ. Furthermore, each linear morphisms is additive, so that, in particular, |y|Γ ◦ 0 = 0. The assertion follows.
M ≡ sN . By the definition of Tx and Lemma 5.3, we have | Tx(sN )|Γ;x:T σ =
|(Tx s) ⬦ (Tx N )|Γ;x:T σ = T (ev) ◦ ψ ◦ ⟨| Tx s|Γ;x:T σ, | Tx N |Γ;x:T σ⟩. By the induc- tion hypothesis, | Tx s|Γ;x:T σ = T (|s|Γ;x:σ) ◦ t and | Tx N |Γ;x:T σ = T (|N |Γ;x:σ) ◦ t. Therefore, | Tx(sN )|Γ;x:T σ = T (ev) ◦ ψ ◦ ⟨T (|s|Γ;x:σ) ◦ t, T (|N |Γ;x:σ) ◦ t⟩ = T (ev) ◦ ψ ◦⟨T (|s|Γ;x:σ),T (|N |Γ;x:σ)⟩◦ t, which is equal to T (ev) ◦ T (⟨|s|Γ;x:σ, |N |Γ;x:σ⟩) ◦ t = T (ev ◦⟨|s|Γ;x:σ, |N |Γ;x:σ⟩) ◦ t = T (|sN |Γ;x:σ) ◦ t by Lemma 3.8, the functoriality of T , and the definition of |· |.
M ≡ (λy. s)τ1→τ2 , where by α-conversion we may assume that x is differ- ent from y. By the definitions of Tx and | · |, we have | Tx(λy. s)|Γ;x:T σ =
|⟨λy. π1(Tx s), λy. π2(Tx s)⟩|Γ;x:T σ = ⟨|λy. π1(Tx s)|Γ;x:T σ, |λy. π2(Tx s)|Γ;x:T σ⟩ =
⟨Λ(π1 ◦ | Tx s|Γ;x:T σ;y:τ1 ), Λ(π2 ◦ | Tx s|Γ;x:T σ;y:τ1 )⟩. By Lemma 5.1, this can be transformed as ⟨Λ(π1 ◦| Tx s|Γ;y:τ1;x:T σ ◦ sw), Λ(π2 ◦| Tx s|Γ;y:τ1;x:T σ ◦ sw)⟩ which coincides with ⟨Λ(π1 ◦ T (|s|Γ;y:τ1;x:σ ) ◦ t ◦ sw), Λ(π2 ◦ T (|s|Γ;y:τ1;x:σ ) ◦ t ◦ sw)⟩ by the induction hypothesis. Proposition 3.13, equation (1), and the functoriality of

T allows us to write this expression as follows:
⟨ Λ(π1 ◦ T (|s|Γ;y:τ ;x:σ) ◦ T (sw) ◦ tj ◦ (t × id)),
Λ(π2 ◦ T (|s|Γ;y:τ ;x:σ) ◦ T (sw) ◦ tj ◦ (t × id))⟩
= ⟨ Λ(π1 ◦ T (|s|Γ;y:τ ;x:σ ◦ sw) ◦ tj) ◦ t, Λ(π2 ◦ T (|s|Γ;y:τ ;x:σ ◦ sw) ◦ tj) ◦ t⟩
= ⟨ Λ(π1 ◦ T (|s|Γ;y:τ ;x:σ ◦ sw) ◦ tj), Λ(π2 ◦ T (|s|Γ;y:τ ;x:σ ◦ sw) ◦ tj)⟩◦ t.
By Proposition 3.9, the last expression is equal to T (Λ(|s|Γ;y:τ1;x:σ ◦sw)) ◦ t, which is in turn equal to T (Λ(|s|Γ;x:σ;y:τ1 )) ◦ t = T (|λy. s|Γ;x:σ) ◦ t by Lemma 5.1.
M ≡ T s. By the definitions of Tx and |·|, and by the induction hypothesis we have
| Tx(T s)|Γ;x:T σ = |⟨T(π1(Tx s)), T(π2(Tx s))⟩|Γ;x:T σ = ⟨T ◦π1◦| Tx s|Γ;x:T σ, T ◦π2◦
| Tx s|Γ;x:T σ⟩ = (T × T ) ◦| Tx s|Γ;x:T σ = (T × T ) ◦ T (|s|Γ;x:σ) ◦ t. The morphism T is linear by Theorem 3.10. Therefore T × T = T (T ) by Lemma 3.7. We conclude that | Tx(T s)|Γ;x:T σ = T (T ) ◦ T (|s|Γ;x:σ) ◦ t = T (T ◦ |s|Γ;x:σ) ◦ t = T (| T s|Γ;x:σ) ◦ t by the functoriality of T .
The remaining cases (M ≡ 0, M ≡ s + N , M ≡ ιks, and M ≡ πks) are straight- forward.
The lemma is proven.	2
Theorem 5.6 Let C be a differential λ-category. Then Th(C) is a perturbative
λ-theory.
Proof. We have to check that Th(C) is closed under the rules from Figure 5.
(β) By the definition of | · |, we have |(λx. s)N |Γ = ev ◦⟨Λ(|s|Γ;x:σ), |N |Γ⟩. On the other hand, by Lemma 5.4, we have |s[N/x]|Γ = |s|Γ;x:σ ◦ ⟨id|Γ|, |N |Γ⟩, which is equal to ev ◦⟨Λ(|s|Γ;x:σ), |N |Γ⟩ by (2).
(T) By the definition of | · |, we have |(T(λx. s))T σ→T τ |Γ = T ◦ Λ(|sτ |Γ;x:σ). On the other hand, by Lemma 5.5, |(λx. Tx s)T σ→T τ |Γ = Λ(|(Tx s)T τ |Γ;x:T σ) = Λ(T (|sτ |Γ;x:σ) ◦ t), which is equal to T ◦ Λ(|sτ |Γ;x:σ) by Proposition 3.11.
(πι) By the definition of |· |, we have |πk(ιls)|Γ = πk ◦ ιl ◦ |s|Γ, which is equal to
|s|Γ if k = l and to 0 otherwise.
The weakening rule (W ) follows from Lemma 5.2. Symmetry, reflexivity, and transitivity are obvious from the definition of Th(C). The remaining rules follow from the definition of the interpretation.	2

6  Conclusions and Future Work
We have presented a novel calculus, the perturbative λ-calculus, which shares some similarity with the differential λ-calculus of Ehrhard and Regnier [4], but is based on the differential geometric idea of pushforward rather than that of derivative. We believe that this feature makes the perturbative λ-calculus well suited for reasoning about forward AD. We have shown that the perturbative λ-calculus can be modeled by differential λ-categories. The following issues have been left open in this paper:
Confluence and strong normalization of the perturbative λ-calculus. We believe

that the proofs from [4] for the differential λ-calculus can be adapted for the perturbative λ-calculus.
We conjecture that the perturbative λ-calculus does not suffer from the inefficien- cies of the differential λ-calculus. Furthermore, we believe that the perturbative λ-calculus can provide the computational complexity guarantees of forward AD. Formal proofs of these statements require giving an operational semantics of the perturbative λ-calculus.
The practical value of the perturbative λ-calculus is rather limited. To become a theoretical foundation of a practical programming language, the perturbative λ- calculus has to be extended with other programming language features (recursion, sum types, polymorphism etc.).
We have considered only forward AD. The other modes of AD require other novel extensions to the λ-calculus.
We plan to address these issues in forthcoming papers.
Acknowledgement
I would like to thank Alexey Radul for fruitful discussions and for carefully reading the preliminary versions of this paper. I am grateful to anonymous referees for valuable suggestions that have improved the exposition.

References
Blute, R., T. Ehrhard and C. Tasson, A convenient differential category, Cahier de Topologie et G´eom´etrie Diff´erentielle Cat´egoriques (2011), to appear.
URL http://arxiv.org/abs/1006.3140
Blute, R. F., J. R. B. Cockett and R. A. G. Seely, Cartesian differential categories, Theory Appl. Categ.
22 (2009), pp. 622–672.
Bucciarelli, A., T. Ehrhard and G. Manzonetto, Categorical models for simply typed resource calculi, Electron. Notes Theor. Comput. Sci. 265 (2010), pp. 213–230.
Ehrhard, T. and L. Regnier, The differential lambda-calculus, Theoret. Comput. Sci. 309 (2003), pp. 1– 41.
Eilenberg, S. and G. M. Kelly, Closed categories, in: Proc. Conf. Categorical Algebra (La Jolla, Calif., 1965), Springer, New York, 1966 pp. 421–562.
Griewank, A., “Evaluating derivatives,” Frontiers in Applied Mathematics 19, Society for Industrial and Applied Mathematics (SIAM), Philadelphia, PA, 2000, xxiv+369 pp., principles and techniques of algorithmic differentiation.
Kock, A., Monads on symmetric monoidal closed categories, Arch. Math. (Basel) 21 (1970), pp. 1–10.
Kock, A., Strong functors and monoidal monads, Arch. Math. (Basel) 23 (1972), pp. 113–120.
Manzyuk, O., Tangent bundles in differential λ-categories (2012), preprint.
URL http://arxiv.org/abs/1202.0411

Moggi, E., Notions of computation and monads, Inform. and Comput. 93 (1991), pp. 55–92, selections from the 1989 IEEE Symposium on Logic in Computer Science.
Pearlmutter, B. A. and J. M. Siskind, Reverse-mode AD in a functional framework: Lambda the ultimate backpropagator, ACM Trans. Program. Lang. Syst. 30 (2008), pp. 1–36.

Siskind, J. M. and B. A. Pearlmutter, Nesting forward-mode AD in a functional framework, Higher Order Symbol. Comput. 21 (2008), pp. 361–376.
Siskind, J. M. and B. A. Pearlmutter, Using polyvariant union-free flow analysis to compile a higher- order functional-programming language with a first-class derivative operator to efficient Fortran- like code, Technical Report TR-ECE-08-01, School of Electrical and Computer Engineering, Purdue University, West Lafayette, IN, USA (2008).
URL http://docs.lib.purdue.edu/ecetr/367
