

Electronic Notes in Theoretical Computer Science 239 (2009) 155–165
www.elsevier.com/locate/entcs

Covering Steps Graphs of Time Petri Nets
Hanifa Boucheneb1
Laboratoire VeriForm, Department of Computer Engineering, E´cole Polytechnique de Montr´eal
P.O. Box 6079, Station Centre-ville, Montr´eal, Qu´ebec,Canada, H3C 3A7
Kamel Barkaoui2
Laboratoire CEDRIC, Conservatoire National des Arts et M´etiers, 292 rue Saint Martin, Paris Cedex 03, France

Abstract
We consider here time Petri nets and the covering steps graph technique proposed by Vernadat et al. for untimed Petri nets. In this technique, some transitions are put together to be fired in a single transition step. This paper investigates how this technique can be extended to be applied to time Petri nets.
Keywords: Time Petri nets, state class graph method, covering steps graph.


Introduction
The main obstacle for enumerative verification methods such as model checking is the state space explosion problem. Many techniques have been developed to alle- viate this problem such as abstraction [2,3,4,7,11,16] and partial order techniques [5,6,8,9,10,12,13,14,15,16].
Abstraction techniques aim to construct by removing some irrelevant details, a contraction of the state space, which preserves properties of interest. For better performances, the contraction should also be the smallest possible and computed with minor resources too (time and space). The preserved properties can be verified using the standard techniques on the contraction [11].
Partial order techniques aim to construct a smaller state space by addressing a specific reason behind the state space explosion, namely the existence of many

1 Email: hanifa.boucheneb@polymtl.ca
2 Email: kamel.barkaoui@cnam.fr


1571-0661/© 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.05.037

potentially equivalent firing sequences 3 which are not distinguishable by some prop- erties. The idea is to represent some equivalent firing sequences by only one or group in one step the firing of some transitions (covering steps graphs).
This paper investigates how the covering steps graph technique can be applied to time Petri nets (TPN in short). In section 2, we present the TPN model and its semantics. Section 3 deals with the abstraction of the TPN state space. Section 4 is devoted to the covering steps graph technique and its application to TPN.

Time Petri Nets
Let N be the set of nonnegative integers, Q+ the set of nonnegative rational numbers and INT the set of non empty intervals of the form: [a, b] or [a, ∞[, where a, b ∈ Q+. Formally, a TPN is a tuple (P, T, Pre, Post, M0,Is) where P and T are finite sets of places and transitions such that (P ∩ T = ∅), Pre and Post are the backward and the forward incidence functions (Pre, Post : P ×T −→ N), M0 is the initial marking (M0 : P −→ N), and Is is the static firing interval function (Is : T → INT ).
Let M be a marking and ti ∈ T . ti is enabled for M iff all required tokens for firing ti are present in M , i.e.: ∀p ∈ P, M (p) ≥ Pre(p, ti). Without loss of generality, for reasons of clarity in this paper, if a transition remains enabled after its firing, it is considered newly enabled. We denote by En(M ) the set of all transitions enabled for M , i.e.: En(M )= {ti ∈ T | ∀p ∈ P, Pre(p, ti) ≤ M (p)}.
Let M be a marking, ti ∈ En(M ) a transition enabled for M and M ' the marking reached by firing ti from M , i.e.: ∀p ∈ P, M '(p)= M (p) − Pre(p, ti)+ Post(p, ti). Nw(M, ti) denotes the set of all transitions enabled by firing ti from M , i.e.:
Nw(M, ti)= {tj ∈ En(M ') | tj = ti ∨ ∃p ∈ P, M (p) − Pre(p, ti) < Pre(p, tj)}.
CF (M, ti) denotes the set of transitions enabled in M but in conflict with ti, i.e.:
CF (M, ti)= {tk ∈ En(M ) | tk = ti ∨ ∃p ∈ P, M (p) < Pre(p, tk)+ Pre(p, ti)}.
The TPN state is defined as a pair s = (M, I), where M is a marking and I is a firing interval function (I : En(M ) → INT ). For some ti of En(M ), ↓ I(ti) and
↑ I(ti) denote respectively the lower and the upper bounds of the firing interval of
ti. The set of firing intervals {I(ti)|ti ∈ En(M )} is called the firing domain of s. The initial state is s0 = (M0, I0) where I0(ti)= Is(ti), for all ti ∈ En(M0).
The TPN state evolves either by time progressions or by firing transitions. When a transition ti becomes enabled, its firing interval is set to its static firing interval. The bounds of this interval decrease synchronously with time, until ti is fired or disabled by another firing. ti can fire if the lower bound of its firing interval reaches 0 but must fire, without any additional delay, if the upper bound of its firing interval reaches 0. The firing of a transition takes no time but may lead to another marking. Let s = (M, I) and s' = (M ',I') be two interval states of a TPN, θ ∈ R+ and tf ∈ T .
We write s θ  s', also denoted s + θ, iff s' is reachable from s after θ time units,
i.e.:		θ ≤ ↑ I(ti), M ' = M , ∀tj ∈ En(M '), ↓ I'(tj) = Max(↓ I(tj) − θ, 0)


3 Two firing sequences are equivalent if one of them can be obtained from the other by successive permu- tations.

and ↓ I'(tj)= ↑ I(tj) − θ.

tf
We write s →
s' iff s' is immediately reachable from s by firing transition tf
, i.e.:

tf ∈ En(M ), ↓ I(tf ) = 0, ∀p ∈ P, M '(p)= M (p) − Pre(p, tf )+ Post(p, tf ), and
∀ti ∈ En(M '), I'(ti)= Is(ti), if ti ∈ Nw(M, tf ) and I'(ti)= I(ti) otherwise.
The TPN state space is the structure (S, →, s0), where: s0 is the initial state
of the model and S = {s|s0 →∗ s} is the set of reachable states of the model (→∗
being the reflexive and transitive closure of relation → defined above). A run in the TPN state space (S, →, s0), starting with some state s, is a maximal sequence

s  θ1
t1	θ2

1 → s1 + θ1 → s2 → s2 + θ2....., such that s1 = s. A marking M is reachable iff
∃s ∈S s.t. its marking is M . Runs of the model are all runs starting with s0.

State Class Graph
Among the TPN state space abstractions proposed in the literature [2,4,7,16], we consider here the state class graph (SCG). In the SCG, all states reachable from the initial state by firing the same sequence of transitions are agglomerated in the same set of states. These sets are then considered modulo the relation of equivalence de- fined by: Two sets of states are equivalent iff they have the same marking and the same firing domain 4 . All equivalent sets are agglomerated in the same node called a state class defined as a pair α = (M, F ), where M is a marking and F is a formula which characterizes the firing domain of α. Each transition ti which is enabled in M is a variable with the same name in F representing its firing delay. Moreover, F can be rewritten as a set of atomic constraints of the form 5 : ti − tj ≤ c, ti ≤ c or
−tj ≤ c, where ti, tj are transitions, c ∈ Q ∪ {∞} and Q is the set of rational num-

bers. F has a unique canonical form defined by:
x,y∈En(M )∪{o}
x − y ≤ SupF (x − y),

where o is a symbol representing the value 0 and SupF (x − y) is the supremum (i.e.,
the least upper bound) of the difference x − y in the domain of F . Its computation is based on the shortest path Floyd-Warshall ’s algorithm and is considered as the most costly operation (cubic in the number of variables of F ).
Two state classes are said to be equal iff they share the same marking and their firing domains are equal (i.e., they have the same canonical form).
Starting from the initial state class α0 = (M0, F0), where M0 is the initial mark-

ing and F0 = ( 
x,y∈En(M0)∪{o}
x − y ≤↑ Is(x)− ↓ Is(y)) with ↓ Is(o) =↑ Is(o) = 0,

successor state classes are computed using the following firing rule: Let α = (M, F )
be a state class and tf a transition. α has a successor by tf (i.e., succ(α, tf ) /= ∅) iff tf is enabled in M and can be fired before any other enabled transition (i.e.:
F ∧ (		tf − ti ≤ 0) is consistent).
ti∈En(M )
If succ(α, tf ) /= ∅ then succ(α, tf )= (M ',F ') can be computed as follows 6 :
∀p ∈ P, M '(p)= M (p) − Pre(p, tf )+ Post(p, tf );

4 The firing domain of a set of states is the union of the firing domains of its states.
5 For economy of notation, we use operator ≤ even if c = ∞.
6 Variable tf is associated with the instance of transition tk that is newly enabled by tf from α.

Set F ' to F ∧		tf − ti ≤ 0 ∧	 
↓ Is(tk) ≤ tf − tf ≤↑ Is(tk);

ti∈En(M )	tk∈Nw(M,tf )
Put F ' in canonical form, eliminate o and all transitions of CF (M, tf ) − {tf };
Rename tf in o and each transition tf in tk.

Let α, α' be two state classes and tf
tf
a transition.	We write α −→
α' iff

α' = succ(α, tf ) /= ∅. The SCG of a TPN is the structure (C, −→, α0) where

α0 is the initial state class and C = {α|α0
−∗→ α} is the set of reachable state

classes. The SCG is finite for bounded TPN 7 and preserves linear properties [2]. Moreover, it is, in general, more compact than other state space abstractions [2,3]. In [3], authors have proposed a bisimulation relation  over the SCG, which induces more compact graphs preserving linear properties: ∀α1 = (M1, F1), α2 =
(M2, F2) ∈ C, α1  α2 iff (i) M1 = M2 and (ii) ∀ti, tj ∈ En(M1),
M in(0, SupF1 (ti − tj)) = M in(0, SupF2 (ti − tj))	if tj ∈ CF(M1, ti)
SupF1 (ti − tj)= SupF2 (ti − tj)	otherwise
Intuitively, the basic idea behind this relation is to eliminate information which are not needed to compute successor state classes. According with the firing rule given of the SCG, simple constraints 8 are not relevant for computing successor classes. Moreover, since the firing of a transition will disable all transitions conflicting with it, some time constraints between conflicting transitions are not relevant for com- puting successor state classes.
We propose, here, to define a class of equivalence of  as an over-approximation of its state classes. Let α = (M, F ) be a state class, in canonical form, its class of equivalence is the state class α = (M, F ), where F is the formula obtained from F by eliminating o and all constraints ti − tj ≤ c such that tj ∈ CF (M, ti) ∧ c ≥ 0, i.e.: Let E(α)= {(ti, tj) | ti, tj ∈ En(M ) ∧ (tj ∈ CF (M, ti) ⇒ SupF (ti − tj) < 0)}.

F =
(ti,tj)∈E(α)
t − t ≤ Sup (t − t ). Note that α ⊆ α.

Lemma 3.1 α and α have the same ﬁring sequences.
Proof. The proof is immediate from the fact that  is a bisimulation relation over the SCG [3] and α  αe. 
Note that the successor function succ, defined before, adds only constraints of the form ti − tj ≤ c, where ti, tj ∈ T and c ∈ {0, − ↓ Is(tj), ↑ Is(ti)}. Therefore, it can be used to compute successors of classes of equivalence. Let α, α' be two state

classes and t
i a transition such that α' = succ(α, ti) /= ∅. succ(α, ti) denotes the

i	˜	˜	i
In the rest of the paper, we consider the quotient graph of the SCG w.r.t.  , where equivalent state classes w.r.t.  are represented by their over-approximations defined above. This graph, called Contracted State Class Graph (CSCG), is defined

as a structure (B, ~,β ) where: (i)	β  = α
is the equivalence class w.r.t.   of

0	0	˜0
of equivalence defined by: β ~ti β' iff succ(β, t ) /= ∅ ∧ β' = succ(β, t ), and (iii)
i	i

7 A TPN is bounded iff it has a finite number of reachable markings.
8 Simple constraints are of the form: −ti ≤ c or ti ≤ c where ti ∈ T and c ∈ Q ∪ {∞}, Q being the set of rational numbers.

У = {β|β  ~∗
β}, ~∗
is the set of reachable classes of equivalence w.r.t.  .

A run in the CSCG starting from a state class β, is a maximal sequence ρ =
β  ~t1 β  ~t2 β  ~t3 ....., such that β  = β. Let β, β' be two state classes and ω a
1

sequence of transitions (ω ∈ T +). β ~ω
β' (with β' = succ(β, ω)) means that the

sequence ω is firable from β (i.e.: succ(β, ω) /= ∅) and its firing leads to β' in the CSCG.
Let β and β' be two state classes in canonical form having the same marking
M . β is included β' iff 6ti, tj ∈ En(M ), SupF (ti — tj) ≤ SupF ' (ti — tj).
The union of state classes may be not convex. The convex hull of the union of β and β', denoted β H β', is the state class β” = (M, F ”) defined by: 6ti, tj ∈ En(M ), SupF ”(ti — tj)= Max(SupF (ti — tj), SupF ' (ti — tj)). In case β ∪ β' is not convex, its convex hull contains some extra states which do not belong neither to β nor to β'. Otherwise, we have: β ∪ β' = β H β'.

Covering steps graphs for time Petri nets
Commonly, partial order techniques are shown to be very useful for specially a sys- tem composed of several concurrent processes. The construction of the global state space of such a system is mainly based on the interleaving semantics that may cause a blow-up of the state space. Partial order techniques aim to counter this problem, by considering only some representative firing sequences of concurrent transitions (reduced graphs) [8,10,14,12,16], or grouping into atomic firing steps some concur- rent transitions (covering steps graphs) [15]. In [13], the authors have shown how to combine the persistent set method [8] with the covering steps method [15] to verify LTL−X properties of untimed Petri nets 9 . Their approach consists of two steps: 1) computing, for each marking, the subset of enabled transitions to explore (persistent set) and then 2) computing groups of transitions within the persistent set to be fired together in an atomic step. We interest here to extend the covering steps method, proposed in [13,15] for Petri nets, to time Petri nets.
In general, partial order reduction techniques are based on the concept of
stuttering-equivalent sequences. In the context of the CSCG, this concept can be defined as follows: Let φ be an LTL−X formula whose atomic propositions are in- terpreted on markings and Lφ the label function which associates with each state class the set of atomic propositions of φ that are satisfied for its marking. Let ρ be run of the CSCG. The label set sequence of ρ w.r.t. φ is obtained by replacing each state class of ρ with its label set, and collapsing to a single set any maximal sequence of identical label sets. Two runs are stuttering-equivalent if they have identical label set sequences. It has been shown in [10,12,14] that for any LTL−X formula φ, the truth values of φ for stuttering-equivalent runs are the same. There- fore, to verify φ for all runs of a state class, it suffices to consider only runs which are not stuttering-equivalent (representative runs).
The selection of representative runs must be made by selecting, from each state class, transitions and/or firing steps to be considered, without exploring beforehand

9 LTL−X is a subclass of linear time logic where the next operator X is not allowed.

all runs. This selection is mainly based on two notions: visibility and independence of transitions. A transition ti is said to be invisible w.r.t. φ if its input and output places 10 do not appear in φ. We denote vis(φ) the set of transitions visible w.r.t. φ. The firing order of visible transitions may be relevant for the evaluation of φ. Intuitively, two transitions t1 and t2 are independent iff whenever t1 and t2 are firable, we can fire them in any order and the resulting state classes are equal.
The relation of independence is however less appropriate for time Petri nets. In- deed, in the TPN state space abstractions, a node represents, in fact, a finite/infinite set of states (state class) and two interleavings of concurrent transitions may lead to two different state classes. We show, by means of two examples, up to which level state classes, resulting from the interleaving of concurrent transitions, may be different.
The TPN in Fig.1 (left) shows that the different interleavings of the same set of transitions may lead to state classes which have different sets of firing se- quences. From the initial state β0 = (p0 + p1, —3 ≤ t1 — t2 ≤ 1), sequences t1t2 and t2t1 lead respectively to state classes β1 = (p3 + p4, —2 ≤ t3 — t4 ≤ —1) and β2 = (p3 + p4, —1 ≤ t3 — t4 ≤ 0).  Transition t4 is firable from β2 (since
—1 ≤ t3 — t4 ≤ 0 ∧ t4 — t3 ≤ 0 is consistent) but not firable from β1 (since
—2 ≤ t3 — t4 ≤ —1 ∧ t4 — t3 ≤ 0 is not consistent).
The TPN in Fig.1 (right) shows that the union of state classes resulting from the interleaving of concurrent transitions is not necessarily convex. From the initial state β0 = (p1 + p2, —3 ≤ t1 — t2 ≤ 1), the firings of sequences t1t2 and t2t1 lead respectively to state classes:
β1 = (p3 + p4 + p5, —2 ≤ t3 — t4 ≤ 0 ∧ —2 ≤ t3 — t5 ≤ 2 ∧ 0 ≤ t4 — t5 ≤ 2) and
β2 = (p3 + p4 + p5, —1 ≤ t3 — t4 ≤ 1 ∧ —1 ≤ t3 — t5 ≤ 2 ∧ —1 ≤ t4 — t5 ≤ 2).
These state classes are not equal and none of them is included in the other: β1 ¢ β2 and β2 ¢ β1. In addition, their union β1 ∪ β2 is not convex because β1 ∪ β2 /= β1 H β2. Indeed, β1 H β2 = (p3 + p4 + p5, —2 ≤ t3 — t4 ≤ 1∧—2 ≤ t3 — t5 ≤ 2∧—1 ≤ t4 — t5 ≤ 2) and the subdomain of β1 H β2 defined by: t3 — t4 = —1 ∧ t3 — t5 = —2 ∧ t4 — t5 = —1 is neither included in the domain of β1 nor in the domain of β2. For instance, the valuation (t3 = 0, t4 = 1, t5 = 2) belongs to the convex hull of the union of β1 and β2 but does not belong neither to β1 nor to β2.
p1	p2	p1	p2

t1[1, 3]	t2[2, 4]
p3	p4

t3[1, 1]	t4[2, 2]	t4[2, 2]

Fig. 1. Time Petri nets used to illustrate features of the interleaving

10 Input and output places of some transition ti are sets defined respectively by: ◦ti = {p ∈ P |Pre(p, ti) > 0} and ti◦ = {p ∈ P |P ost(p, ti) > 0}.

To introduce the principle of the covering steps method we propose here for time Petri nets, we consider a state class β of some system composed of n concurrent processes (TPN’s). Suppose that each process has exactly one firable transition from β and the property, to be verified, relates only to the state class β and state classes resulting from the different firing orders (without depending on the intermediate state classes). These firable transitions can be ordered in n! possible ways, which may lead to different state classes. In case the union of the resulting state classes is convex, it is much more efficient to represent the different firing orders by a single firing step and the resulting state classes by their union. In this way, intermediate state classes and different firing orders are not explored and the truth value of the property is preserved. To apply this reduction principle, we define the notion of weak-commutative over sets of transitions as follows:
Definition 4.1 Let β be a state class of У, φ an LTL−X  formula, Tf  =
{tf1 , tf2 , ..., tfn } ⊆ T (with n > 1) and Ω(Tf ) the set of sequences equivalent to the sequence tf1 tf2 ...tfn . Tf is weak-commutative, denoted Tf , in β w.r.t. φ iff:
The number of visible transitions w.r.t. φ in Tf does not exceed one (i.e.:
|vis(φ) ∩ Tf | ≤ 1);
6p ∈ P, M (p) ≥	Pre(p, tfi ) and 6tfi ∈ Tf , succ(β, tfi ) /= ∅;
tfi ∈Tf
	succ(β, ω) is convex.
ω∈Ω(Tf )
Note that condition (ii) implies that transitions of Tf can be fired in any order from
β.
The covering steps graphs of the CSCG is defined in a similar way as in [15], except that the classical independence relation is replaced by the weak-commutative relation defined above.
Definition 4.2 [15] Let (У, ~, β0) be the CSCG of some TPN. A covering steps graph of the CSCG w.r.t. an LTL−X formula φ, is a transition system (УR, ~R, β0R ) where:
β0R = β0. The initial class of the covering steps graph is exactly the initial state class of the CSCG.
УR is the set of reachable state classes of the covering steps graph s.t. 6βR ∈
УR, ∃β1, ..., βn ∈ У, βR =   βi. Each state class of the covering steps graph is
i=1,n
the union of some state classes of the CSCG.
~R∈ УR × (2T — {∅}) × УR is a transition relation which satisfies the following conditions:

6βR, β'
∈ УR, 6Tf ⊆ T,



β  ~Tf
'	⇒  Tf
in βR
w.r.t. φ ∧ β'
=
ω∈Ω(Tf )
ucc(βR
, ω)

6βR ∈ УR, 6ω ∈ T +, succ(βR, ω) /= ∅  ⇒
∃β' ∈ УR, ∃T 1f , ..., Tnf ⊆ T, ∃ω1 ∈ Ω(T 1f ), ..., ωn ∈ Ω(T nf ), ∃ω' ∈ T ∗ s.t.


succ(β , ωω') ⊆ β'
∧ ωω' = ω1ω2...ωn
T 1f T~2f ...T nf	'
R	R	R

Intuitively, condition (i) means that each firing step in the covering steps graph corresponds to the fusion of some firing sequences in the CSCG. Condition (ii) ensures that each firing sequence of the CSCG is represented in some sequence of steps in the covering graph.
Lemma 4.3 The covering steps graph of the CSCG w.r.t. φ preserves φ.
Proof. Each firing sequence ω in the CSCG is covered by a sequence of firing steps. Each sequence of firing steps in the covering graph is exactly the fusion of some firing sequences of the CSCG and in each firing step there is at most one visible transition
w.r.t. φ. It follows that for each run ρ in the CSCG, there is a run ρ', in the covering graph, stuttering-equivalent to ρ w.r.t. φ, and for each run ρ' in the covering graph, there is a run ρ, in the CSCG, stuttering-equivalent to ρ' w.r.t. φ.	 
Concretely, the construction of the covering steps graph needs to establish two main procedures:
A procedure to compute, for a given LTL−X formula φ and a state class β, sets of transitions to be fired together, in an atomic step, and those to be fired alone. Transitions to be fired in an atomic step must be weak-commutative in β w.r.t. φ. As different interleavings of the same set of transitions may lead to state classes whose union is not convex, we need, at this level, simple conditions which ensure convexity.
A procedure to calculate the successor state class by firing, in a single step, two or more transitions. This successor state class is the union of state classes resulting from the different firing orders.
Theorem 4.4 and Lemma 4.5 below establish two sufficient conditions which ensure convexity for the union of state classes reached by different interleavings of the same set of transitions. They also show how to compute this union without computing beforehand intermediate state classes.
Let β = (M, F ) be a state class and Tf = {tf1 , tf2 , ..., tfn } ⊆ T be a subset of transitions such that:

6p ∈ P, M (p) ≥
tfi ∈Tf
Pre(p, tfi )	and	6tfi ∈ Tf , succ(β, tfi ) /= ∅;

+	∗
6tfi ∈ Tf , 6ω1 ∈ T  , 6ω2 ∈ T  s.t. ω1tf ω2 ∈ Ω(Tf),
CF (Mω1 , tfi )= CF (M, tfi )  and  Nw(Mω1 , tfi )= Nw(M, tfi );
6tfi, tfj ∈ Tf s.t. tfi /= tfj , CF(M, tfi ) ∩ CF(M, tfj )= ∅
Intuitively, condition (ii) states that the firing of any transition tfi of Tf will disable and enable the same sets of transitions, independently of the firing order (Mω1 is the marking reached from M by ω1). Condition (iii) means that each transition of

Tf has its own conflicting transitions in M . We denote sc1(β, Tf ) the conjunction of conditions (i), (ii) and (iii) above.
Theorem 4.4 sc1(β, Tf ) ⇒ the domain of β' =	succ(β, ω) is convex and
ω∈Ω(Tf )
β' = (M ',F ') where 6p ∈ P, M '(p)= M (p)+ Σ Post(p, tf ) — Pre(p, tf ) and F '

tfi ∈Tf
is computed as follows: Let Old(M, Tf )= En(M ) —
tfi ∈Tf
i	i

CF (M, tfi ).

Set F ' to 11 :	F  ∧
tfi ∈Tf
[
tj ∈Old(M,Tf )∪CF (M,tfi )
tfi
— tj ≤ 0 ∧


↓ Is(tk) ≤ tfi — tf ≤↑ Is(tk) ∧		tf
i
— tfj ≤ 0]

tk∈Nw(M,tfi )	tfj ∈Tf ,tk∈Nw(M,tfj )


Put F ' in canonical form and eliminate all transitions of
tfi ∈Tf
CF (M, tfi ).

Rename each variable ti in tk and compute its equivalence class.
Proof. (sketch of proof) Let FC(β, Tf ) be the formula given in step (i). Since FC(β, Tf ) is a conjunction of atomic constraints (i.e.: its domain is convex), we have to show that: 6ω = tf1 tf2 ...tfn ∈ Ω(Tf ), FC(β, Tf ) ∧ tf1 ≤ tf2 ≤ ... ≤ tfn is equivalent to the firing condition of ω from β. We give here the proof for n = 3 (the proof is similar for n /= 3). FC(β, Tf ) ∧ tf1 ≤ tf2 ≤ tf3 is equivalent to:

F ∧ tf1 ≤ tf2 ≤ tf3 ∧	^
tj ∈Old(M,Tf )+CF (M,tf1 )
tf1 − tj ≤ 0 ∧

^

tj ∈Old(M,Tf )+CF (M,tf2 )
tf2 − tj ≤ 0 ∧	^
tj ∈Old(M,Tf )+CF (M,tf3 )

tf3 − tj ≤ 0 ∧

^

tfi ∈Tf ,tk∈Nw(M,tfi )
↓ Is(tk) ≤ tfi − tf
≤↑ Is(tk) ∧

^	tf
tfi ∈Tf ,tk ∈Nw(M,tf1 )
— tf1 ≤ 0 ∧	^	tf
tfi ∈Tf ,tk ∈Nw(M,tf2 )
— tf2 ≤ 0 ∧	^	tf
tfi ∈Tf ,tk ∈Nw(M,tf3 )
— tf3 ≤ 0

Using sc1(β, Tf ), tf1 ≤ tf2 ≤ tf3 , En(M )= Old(M, Tf )+CF (M, tf1 )+CF (M, tf2 )+

CF (M, tf3 ), and 6tfi
∈ Tf , tk ∈ Nw(M, tfi ), tfi
≤ tfi , we can show that the above

formula is equivalent to the firing condition of tf1 tf2 tf3 from β (see Section 3):

F ∧	^
tj ∈En(M )
tf1 −tj ≤ 0 ∧	^
tj ∈En(M )−CF (M,t1 )
tf2 −tj ≤ 0 ∧	^
tj ∈En(M )−(CF (M,t1 )+CF (M,t2))
tf3 −tj ≤ 0 ∧

^	tf2
tk ∈Mw(M,tf1 )
— tf1 ≤ 0 ∧	^	tf
tk ∈Nw(M,tf1 )
— tf1 ≤ 0 ∧	^	tf
tk ∈Nw(M,tf2 )

— tf2 ≤ 0 ∧

^

tfi ∈Tf ,tk ∈Nw(M,tfi )
↓ Is(tk) ≤ tfi − tf
≤↑ Is(tk)



11 Variable tfi is associated with the instance of transition tk that is newly enabled by firing transition tf
from M .

Note that for any LTL−X formula φ s.t. |vis(φ) ∩ Tf | ≤ 1, condition sc1(β, Tf ) implies that Tf in β w.r.t. φ. We now derive from the previous condition another sufficient condition based on the structure of the net. Let sc2(β, Tf ) be the con- junction of conditions: (i) 6tfi ∈ Tf , succ(β, tfi ) /= ∅ and

(ii) 6tf , tf ∈ Tf s.t. tf /= tf , 6tk ∈ T ,(◦tf ∪t◦ ) ∩ ◦tk /= ∅⇒ (◦tf
∪t◦ ) ∩ ◦tk = ∅.

i	j	i	j
fi
fj

Intuitively, condition (ii) means that there is no transition which shares input or
output places with more than one transition of Tf .

Lemma 4.5 sc2(β, Tf ) ⇒ the domain of β' =
ω∈Ω(Tf )
succ(β, ω) is convex and β'

is computed as shown in Theorem 4.4.
Proof. The proof is immediate from the fact that sc2(β, Tf ) implies sc1(β, Tf ). 

Conclusion
We proposed an extension to the covering steps graph technique [13] more appropri- ate to time Petri nets. The basic idea of this extension is to group, into an atomic step, the firing of some set of transitions such that the union of states reached by their different interleavings is convex. We proved however that this union is not necessarily convex. We then established two sufficient conditions sc1 and sc2 which ensure convexity for the contracted state class graph [3]. Moreover, we showed how to compute this union without computing beforehand intermediate state classes.
In [1], the authors showed that the union of state zones 12 reached by differ- ent interleavings of the same set of transitions is convex, for a CCS-like parallel composition of timed automata (with no shared variables). According to condition sc2, this result is also valid for the CSCG of any CCS-like parallel composition of time Petri nets and a set of transitions belonging to different nets. Note that this result is however not valid for the SCG of a CCS-like parallel composition of time Petri nets. Indeed, consider the TPN shown in Fig. 1. From the initial state class α0 = (p1 + p2, 1 ≤ t1 ≤ 3 ∧ 2 ≤ t2 ≤ 4), sequences t1t2 and t2t1 lead to two state classes α1 = (p3 + p4, 0 ≤ t3 ≤ 1 ∧ t4 = 2 ∧ —2 ≤ t3 — t4 ≤ —1) and α2 = (p3 + p4, t3 =1 ∧ 1 ≤ t4 ≤ 2 ∧ —1 ≤ t3 — t4 ≤ 0) such that their union is not convex.

References
R. Ben Salah, M. Bozga, O. Maler, On Interleaving in Timed Automata, CONCUR’ 06, 465-476, volume 4137 of LNCS, 2006.
B. Berthomieu, F. Vernadat, State class constructions for branching analysis of Time Petri nets, volume 2619 of LNCS, 2003.
H. Boucheneb, H. Rakkay, A more efficient time Petri net state space abstraction useful to model checking timed linear properties In Proc of the 7th International Conference on Application of Concurrency to System Design (ACSD). IEEE Computer Society Press, 2007 (extended version accepted for publication in a special issue of Fundamenta Informaticae journal).

12 A zone is a convex clock domain defined by a conjunction of atomic constraints on clocks.

H. Boucheneb, R. Hadjidj, CTL* model checking for Time Petri Nets, Journal of Theoretical Computer Science TCS, volume 353/1-3, 2006.
C. Daws, R. Gerth, B. Knaack, and R. Kuiper, Partial order reduction techniques for real-time model checking, Formal Aspects of Computing,(10), Springer, 1998.
S. Edelkamp, S. Leue, A. Lluch-Lafuente Partial order reduction and trail improvement in directed model checking, International Journal of Software Tools Technology Transfer (2004)6, Springer-Verlag, 2004.
G. Gardey, O. H. Roux, and O. F. Roux. Using zone graph method for computing the state space of a Time Petri Net, Springer-Verlag, volume 2791 of LNCS, 2004.
P. Godefroid. Partial Order Methods for the Verification of Concurrent Systems, Springer-Verlag, volume 1032 of LNCS, 1996.
D. Peled. All from one, one for all: on model checking using representatives, Springer-Verlag, volume 697 of LNCS, Springer-Verlag, 1993.
D. Peled and T. Wilke. Stutter invariant temporal properties are expressible without the next-time operator. Information Processing Letters, 63(5), 1997.
W. Penczek and A. P´olrola, Specification and Model Checking of Temporal Properties in Time Petri Nets and Timed Automata, In Proc. of ICATPN, Springer-Verlag, volume 3099 of LNCS, pages 37-76, Springer–Verlag, 2004.
W. Penczek, A. P´olrola, Abstraction and partial order reductions for checking branching properties of time Petri nets, In Proc. of ICATPN, Springer-Verlag, volume 2075 of LNCS, pages 323-342, 2001.
P.O.Ribet, F.Vernadat, B.Berthomieu, On combining the persitent sets method with the covering steps graph method, Springer-Verlag, volume 2529 of LNCS, 2002.
A. Valmari. A stubborn attack on state explosion, Springer-Verlag, volume 531 of LNCS, 1990.
F. Vernadat, P. Az´ema, F. Michel, Covering step graph. In proc. of ATPN’96, Springer Verlag, volume 1091 of LNCS, 1996.
D.Pradubsuwun, T.Yoneda, C. Myers, Partial order reduction for detecting safety and timing failures of timed circuits, IEICE Trans. Inf. & Syst., volume E88-D, No. 7, 2005.
