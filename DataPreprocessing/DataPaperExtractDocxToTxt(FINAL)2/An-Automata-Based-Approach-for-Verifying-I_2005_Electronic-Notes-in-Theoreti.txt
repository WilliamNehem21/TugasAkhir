Electronic Notes in Theoretical Computer Science 135 (2005) 39–58  
www.elsevier.com/locate/entcs


An Automata Based Approach for Verifying Information Flow Properties
Deepak D’Souza Raghavendra K.R. Barbara Sprick
Department of Computer Science and Automation Indian Institute of Science
Bangalore, India

Abstract
We present an automated verification technique to verify trace based information flow properties for finite state systems. We show that the Basic Security Predicates (BSPs) defined by Mantel in [5], which are shown to be the building blocks of known trace based information flow properties, can be characterised in terms of regularity preserving language theoretic operations. This leads to a decision procedure for checking whether a finite state system satisfies a given BSP. Verification techniques in the literature (e.g. unwinding) are based on the structure of the transition system and are incomplete in some cases. In contrast, our technique is language based and complete for all information flow properties that can be expressed in terms of BSPs.
Keywords: information flow control, verification, finite state systems

Introduction
Granting, restricting and controlling the flow of information is a core part of computing system security. In particular, confidential data needs to be pro- tected from undesired accesses. Access control policies are defined to serve this task by specifying which accesses are allowed for which users. However, access control methods can only restrict direct information flow (over open channels). Information leakage over covert channels (e.g. Trojan Horses, ob- servable behaviour and time or space availability, etc) is not controllable by access control methods.
In [4], Goguen and Meseguer first introduced the notion of Non-Interference as a means to control both direct as well as indirect information flow. Infor- mally, Goguen and Meseguer distinguish between high level and low level users


1571-0661 © 2005 Published by Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2005.06.005


and describe non-interference as What one group of users does using a cer- tain ability has no effect on what some other group of users does [4]. More precisely, their original notion of non-interference says that two systems (or users) S1 and S2 are non-interfering if the output of S2 does not depend on the input of S1.
Since Goguen and Meseguer’s initial work, many more definitions about non-interference have been proposed in the literature. They all follow the same principle of a low level entity not being able to infer too much informa- tion about a high level user or high level activity in general. These security
properties include, among others, non-inference [10,9,12] (which requires that
each system behavior projected to low level behavior is itself a possible be- havior), separability [9] (which requires that every possible low level behavior interleaved with every possible high level behaviour must be a possible be- haviour of a system), generalized non-interference [8] (which requires that for every possible trace and every possible perturbation there is a correction to the perturbation such that the resulting trace is again a possible trace of the system), nondeducability [11], restrictiveness [8], the perfect security property [12], and many more.
Though all these properties follow the main idea of ensuring, that informa- tion is not leaked from high level users to low level users, they differ in their strictness as well as in the type of system they are defined for.
In [7,5] Mantel has presented an approach to uniformly formalize all known trace based information flow properties. Based on sets of traces as the sys- tem model, Mantel has defined a set of basic security predicates (BSPs). He shows that all known trace based security properties can be represented as
conjunctions of these BSPs. For example generalized noninterference can be defined as the conjunction of the two BSPs insertion (I) and deletion (D). A set of traces L satisfies the BSP I if for every perturbation of a trace that
is obtained by inserting a confidential event after the last confidential event, there exists a correction of this perturbation obtained by inserting or deleting certain non-confidential events, such that the resulting trace is also in the lan- guage L. A set of traces L satisfies the BSP D if for every perturbation that is obtained by deleting the last confidential event, there exists a correction of this perturbation that is obtained by inserting or deleting certain non-confidential events, such that the resulting trace is also in the language L.
Our work is based on the modular framework presented in [5]. We present an automated verification technique to check whether a finite state system satisfies a given basic security predicate. Our approach is language based rather than structure based. We define a set of language theoretic operations and show that the question of whether a set of traces L satisfies a BSP P


boils down to checking whether a language L1 is contained in a language L2, where L1 and L2 are obtained from L by successive applications of the defined language-theoretic operations. Finally we show that the language-theoretic operations are regularity preserving, and effectively so. Thus if L is specified by a finite state transition system (and is hence regular), then L1 and L2 are also regular and the question of whether L1 ⊆ L2 can be answered effectively. As has been observed earlier, the BSPs are properties of sets of traces rather than properties of traces and hence cannot be handled by classical model checking approaches. Nonetheless, our work gives a method to “model check” these properties by reducing them to the language inclusion problem
for finite state systems.
Previous work dealing with the verification of trace based security prop- erties (e.g.[6,1,3]) mainly employ unwinding theorems as verification tech- nique for information flow properties. These techniques are typically sufficient though not necessary in all cases. We feel that this may be due to the fact that unwinding relations are based on the structure of the system rather than on the language of traces generated by the system. The only other work we are aware of which gives a decision procedure based on language inclusion
is [2]. While they have addressed the properties of non-deterministic nonin-
terference and strong non-deterministic noninterference (which is equivalent to the definition of noninference given in [9] and [10]), our approach gives a
decision procedure for the whole class of information flow properties that can be expressed in terms of BSPs.

Language-Theoretic Operations
By an alphabet we will mean a finite set of symbols representing events or actions of a system. For an alphabet Σ we use Σ∗ to denote the set of finite strings over Σ. The null or empty string is represented by the symbol ϵ. For
two strings α and β in Σ∗ we write αβ for the concatenation of α and β. A
language L over Σ is just a subset of Σ∗.
A marked language M over an alphabet Σ is a language over the alphabet Σ ∪ {q}, where ‘q’ is a special “mark” symbol different from those in Σ, and each string in M contains exactly one occurence of q.
For the rest of the paper we fix an alphabet of events Σ. We assume a partition of Σ into V, C, N, which in the framework of [5] correspond to events that are visible, conﬁdential, and neither visible nor confidential, from a particular user’s point of view.
Definition 2.1 (Language-theoretic operations) Let L be a language over
Σ modelling sets of possible traces of a system and let M be a marked language

over Σ. Let X be a subset of Σ.
We deﬁne the following language-theoretic operations on L:
L TX:= {τ TX	| τ ∈ L}, where τ TX is obtained from τ by deleting all events from τ that are not elements of X.
l-del(L) := {αβ | αcβ ∈ L, β TC= ϵ}.
Operation l-del corresponds to the deletion of the last conﬁdential event in a string. More precisely, this operation deletes the last occuring C-event from every string in L.
l-ins(L) := {αcβ | αβ ∈ L, β TC= ϵ, c ∈ C}.
Operation l-ins corresponds to the insertion of conﬁdential events in strings of L. More precisely, l-ins contains all strings γ ∈ Σ∗ obtained by insert- ing a C-event in a string τ ∈ L, in a position after which no C-events occur.
l-ins-admX(L) :=
{αcβ | αβ ∈ L, β TC= ϵ, there exists γc ∈ L, γ TX= α TX, c ∈ C}. Operation l-ins-admX corresponds to admissible insertion of conﬁdential events in strings of L. More precisely, this operation is similar to l-ins but allows only the insertion of admissible C-events. The insertion of an event c ∈ C is admissible after a preﬁx α in a string τ iff there exists another string γc ∈ L with γ projected to the set X being equal to α projected to X.
l-del-mark(L) := {αqβ | αcβ ∈ L, β TC= ϵ}.
Operation l-del-mark corresponds to marked deletion of the last conﬁden- tial event. More precisely, this operation replaces the last event c ∈ C in every string of L by the special mark symbol q.
l-ins-mark(L) := {αcqβ | αβ ∈ L, β TC= ϵ, c ∈ C}.
Operation l-ins-mark corresponds to marked insertion of a conﬁdential event. This operation is similar to l-ins, but additionally introduces a mark q after the newly inserted symbol.
l-ins-adm-markX (L) :=
{αcqβ | αβ ∈ L, β TC= ϵ, there exists γc ∈ L, γ TX= α TX, c ∈ C}. Operation l-ins-adm-markX corresponds to marked insertion of admissible events. More precisely, this operation is similar to l-ins-admX, but a mark q is introduced after the newly inserted (admissible) symbol c in the string.
mark(L) := {αqβ | αβ ∈ L}.
Operation mark corresponds to the insertion of a mark at an arbitrary position. More precisely mark contains all strings which can be obtained by the insertion of the mark symbol in an arbitrary position of a string

in L.
M Tm:= {αqβ' | αqβ ∈ L, β' = β TX}.
This operation corresponds to a marked projection. More precisely, this operates on a marked language M and is similar to Projection, but leaves every string intact upto the mark and projects to set X the suﬃx after the mark.
Let C' ⊆ C and V ' ⊆ V .
'	'
l-del-con-markC' ,V ' (L) := {αvqβ | αcvβ ∈ L, β TC= ϵ, c ∈ C , v ∈ V }.
Operation l-del-con-mark corresponds to marked deletion in the “context” of an event in V '. More precisely, this operation replaces the last conﬁ- dential event c in a string by the mark symbol, provided c belongs to C' and and is immediately followed by a V ' event in the string.
Let C' ⊆ C and V ' ⊆ V .
'	'
l-ins-con-markC' ,V ' (L) := {αcvqβ | αvβ ∈ L, β TC= ϵ, c ∈ C , v ∈ V }.
Operation l-ins-con-mark corresponds to marked insertion in the context of a V ' event. More precisely, l-ins-con-mark contains all strings obtained by inserting a C' event at a point in a string after which no conﬁdential events occur and which is immediately followed by a V ' event v; the mark symbol is also inserted after the event v.
Let C' ⊆ C and V ' ⊆ V .

l-ins-adm-con-markX
(L) :=

{αcvqβ | αvβ ∈ L, β TC= ϵ, there exists γc ∈ L, γ TX= α TX, c ∈
C', v ∈ V '}.
Operation l-ins-adm-con-markX corresponds to the marked insertion of admissible events in the context of a V ' event. This operation is similar to l-ins-con-mark but allows only the insertion of admissible C-symbols, where admissibility is deﬁned as for operation l-ins-admX.
Let N ' ⊆ N and V ' ⊆ V .
' ∗	'
erase-con-markN',V ' (L) := {αvqβ | αδvβ ∈ L, δ ∈ (N ) , v ∈ V }.
Operation erase-con-mark corresponds to the marked erasure of N '-events. More precisely, erase-con-markN' ,V ' (L) contains all strings obtained from a string in L by the erasure of a consecutive sequence of N' events which end before a V ' event v. The mark symbol is also inserted after the event v in the string.

Expressing BSP’s Language-Theoretically
We now express the basic security predicates (BSPs) of Mantel in terms of the language-theoretic operations just defined, and the usual subset relation.


In this work we use a notion of “equality upto corrections of a set Y”. For convenience, we thus introduce the following notations, where Y denotes Σ − Y .
α =Y β iff α TY = β TY¯ . String α is equal to β upto corrections on Y -events iff the projection of α on Y is equal to the projection of β on Y .
α ∈Y L iff there exists β ∈ L such that α =Y β. A string α belongs to L upto corrections on Y -events iff L contains a string β that equals α upto corrections on Y .
L ⊆Y M iff for all strings α ∈ L we have α ∈Y M. L is a subset of M upto corrections on Y iff every element of L belongs to M upto corrections on Y .
Recall, that we defined a partition of the set Σ into V, C and N .
Definition 3.1 (R) A language L satisﬁes property R (Removal of events) iff for all strings τ ∈ L there exists a string τ ' ∈ L such that τ ' does not contain any C-symbols and τ ' TV = τ TV .
Lemma 3.2 Property R is satisﬁed by a language L iff L TV ⊆N L.
Proof. ⇒: Let us assume that L satisfies property R. Consider any string τ in L TV . (Note, that all symbols in τ belong to set V .) By definition of the projection L TV , there must exist some string τ ' ∈ L such that τ ' TV = τ . Since property R is satisfied by language L, there must exist a string τ '' in L that does not contain any C-symbols and whose projection τ '' TV is equal to the projection τ ' TV . Thus string τ '' differs from τ with only N -symbols and τ belongs to language L modulo corrections of N (τ ∈N L). Hence L TV ⊆N L.
⇐: Let us assume that L TV ⊆N L. Consider any string τ ∈ L. Obviously, the projection τ TV belongs to L TV . Since L TV ⊆N L, there must exist a string τ ' ∈ L that is equivalent to the projection τTV upto corrections of N -symbols and, moreover, does not contain any C-symbols. Thus, τ ' TV = τ TV . Hence R is satisfied.	 
Definition 3.3 (D) Language L satisﬁes property D (Stepwise Deletion of events) iff for each string αcβ ∈ L, where c ∈ C and the projection β TC on C-events is empty, we have a string α'β' ∈ L such that α' TV ∪C= α TV ∪C and β' TV ∪C = β TV ∪C.
Lemma 3.4 Property D is satisﬁed by a language L iff l-del(L) ⊆N L.
Proof. ⇒: Let us assume that property P is satisfied by language L. Consider a string τ ∈ l-del(L). This string will be of the form αβ where by definition of l-del(L) β does not contain any C-symbols and the string αcβ belongs to L for some symbol c ∈ C. Since D is satisfied, there must exist a string α'β' ∈ L


such that α' TV ∪C= α TV ∪C and β' TV ∪C= β TV ∪C. Thus string τ (= αβ) belongs to L upto corrections of N -symbols. Hence l-del(L) ⊆N L.
⇐: Let us assume that l-del(L) ⊆N L. Consider a string τ ∈ L that is of the form αcβ where β does not contain any C-symbols. By the definition of the language l-del(L), the string αβ belongs to l-del(L). Since l-del(L) ⊆N L, there must exist a string τ ' ∈ L such that αβ and τ ' are equivalent upto corrections of N -symbols. Hence D is satisfied.	 
Definition 3.5 (I) Language L satisﬁes property I (Insertion of events) iff for all strings αβ ∈ L where β does not contain any C events and for all c ∈ C, we have α'cβ' ∈ L, for some string β' with β' TV ∪C= β TV ∪C, α' TV ∪C= α TV ∪C.
Lemma 3.6 Property I is satisﬁed by language L iff l-ins(L) ⊆N L.
Proof. ⇒: Let us assume that property I is satisfied. Consider a string τ in language l-ins(L). By definition of l-ins(L), the string τ will be of the form αcβ, where c belongs to set C, αβ belongs to L and β does not contain any
C-symbols. Since property I is satisfied by language L, there must exist a string α'cβ' in L such that α' TV ∪C= α TV ∪C and β' TV ∪C= β TV ∪C. Thus string τ (= αcβ) belongs to L upto corrections of N -symbols. Hence l-ins(L) ⊆N L.
⇐: Let us assume that l-ins(L) ⊆N L. Consider a string τ ∈ L of the form αβ, where β does not contain any C-events. By the definition of l-ins(L), there exists a string αcβ ∈ l-ins(L) for each c ∈ C. Since l-ins(L) ⊆N L, we have that αcβ ∈N L. This means that there must exist a string α'cβ' in L where α and α' as well as β and β' are equivalent upto corrections of N -symbols,
i.e. α' TV ∪C= α TV ∪C and β' TV ∪C= β TV ∪C. Hence I is satisfied.	 
Definition 3.7 (IAX) A language L satisﬁes the property IAX (Insertion of X-admissible events) iff for every string αβ ∈ L such that β does not contain any C-symbols and there exists a string γc ∈ L for some c ∈ C with γ TX= α TX, we have that αcβ ∈N L, i.e. αcβ belongs to L upto corrections on N- symbols.
Lemma 3.8 Property IAX is satisﬁed by language L iff l-ins-admX (L) ⊆N L.
Proof. ⇒: Let us assume that property IAX is satisfied by language L. Con- sider any string τ in l-ins-admX(L). By definition of l-ins-admX(L), this string τ will be of the form αcβ for some symbol c ∈ C such that the follow-
ing conditions hold: The string αβ belongs to L and for some string γ with γ TX= α TX, the string γc belongs to L as well. Since IAX is satisfied, we have that αcβ ∈N L, i.e. αcβ belongs to L upto corrections of N -symbols. Hence l-ins-admX(L) ⊆N L.
⇐: Let us assume that l-ins-admX(L) ⊆N L. Consider any string αβ ∈ L
that satisfies the following conditions: the substring β does not contain any


C-symbols and there exists a string γc ∈ L for some C-symbol such that γ TX= α TX. By definition of l-ins-admX(L) the string αcβ belongs to l-ins-admX(L). Since l-ins-admX(L) ⊆N L, we have that the string αcβ belongs to L upto corrections on N -symbols, i.e. αcβ ∈N L.Hence IAX is satisfied.	 
Definition 3.9 (BSD) L satisﬁes BSD (Backwards Strict Deletion) iff for every string αcβ ∈ L where c ∈ C and the substring β does not contain any C-events there exists a string αβ' ∈ L with β' TV ∪C= β TV ∪C.
Lemma 3.10 Property BSD is satisﬁed by language L iff l-del-mark(L) Tm⊆
N
mark(L) Tm.
Proof. ⇒: Let us assume that property BSD is satisfied by language L. Consider any string τ ∈ l-del-mark(L) Tm. This string will be of the form αqβ where β does not contain any N -symbol. By definition of marked projection,
there must exist a string αqβ' ∈ l-del-mark(L) with β' T= β T. By definition
N
of l-del-mark(L), there must exist a symbol c ∈ C such that αcβ' belongs to
L. Since the property BSD is satisfied, there also exists a string αβ'' ∈ L,
''	''
such that β TN = β T.  By definition of mark(L), we have that αqβ	∈
mark(L). Since β does not contain any N -symbols and β and β'' are equal upto corrections on N -symols, we have that β is equivalent to β'' with all

N -symbols deleted, which means, that αqβ belongs to mark(L) Tm
Hence

l-del-mark(L) Tm⊆ mark(L) Tm.
N	N
⇐: Let us assume that l-del-mark(L) Tm⊆ mark(L) Tm.  Consider any
N	N
string αcβ ∈ L, where c ∈ C and β does not contain any C-events. By the definition of l-del-mark(L), the marked string αqβ belongs to l-del-mark(L). By the definition of marked projection, there exists αqβ' ∈ l-del-mark(L) Tm
where β' is equal to β with N -symbols deleted. Since l-del-mark(L) Tm
N ⊆
mark(L) Tm, the marked string αqβ' belongs to mark(L) Tm as well. By the
N	N	''
definition of marked projection, there must exists a marked string αqβ	∈
mark(L) for some β'' with β'' T= β'. Note, that the substring β'' is equal
to β upto corrections of N -symbols. By the definition of mark(L), the string
αβ'' also belongs to L. Hence BSD is satisfied.	 
Definition 3.11 (BSI ) L satisﬁes BSI (Backwards Strict Insertion) iff for all strings αβ ∈ L where β does not contain any C-symbols and for all symbols c ∈ C, we have αcβ' ∈ L for some string β' with β' TV ∪C= β TV ∪C.
Lemma 3.12 Property BSI is satisﬁed by language L iff l-ins-mark(L) Tm⊆
N
mark(L) Tm.
Proof. ⇒: Let us assume that BSI is satisfied by language L. Consider any string τ ∈ l-ins-mark(L) Tm. This string will be of the form αcqβ where c ∈ C and β contains only V -symbols. By the definition of marked projection, there


must exist a string αcqβ' in l-ins-mark(L), such that β' does not contain any C-symbols and is equal to β on V -symbols. By the definition of l-ins-mark(L), the string αβ' must belong to language L. Since property BSI is satisfied by language L, for every symbol c ∈ C there must exist a string β'' with β'' TV ∪C β', such that αcβ'' belongs to L. According to the definition of mark(L), αqcβ belongs to mark(L). Since β'' is equal to β after deleting all N -symbols, we
have that αqcβ belongs to mark(L) Tm. Hence l-ins-mark(L) Tm⊆ mark(L) Tm.
N	N	N
⇐: Let us assume that l-ins-mark(L) Tm⊆ mark(L) Tm. Consider a string
N	N
τ ∈ L of the form αβ where β does not contain any C-symbols.  By the
definition of l-ins-mark(L), there string αcqβ belongs to l-ins-mark(L) for every c ∈ C. By the definition of marked projection, there exists αcqβ' ∈

l-ins-mark(L) Tm
where β' is equal to β with all N -symbols deleted. Since

l-ins-mark(L) Tm ⊆ mark(L) Tm, the string αcqβ' also belongs to mark(L) Tm.
N	N	'' N
By the definition of marked projection, there must exist a string αcqβ	∈
mark(L) for some β'' such that β'' T= β'. Note, that β'' is equivalent to β
upto corrections of N -symbols. By the definition of mark(L), the string αcβ''
belongs to L. Hence BSI is satisfied.	 
Definition 3.13 (BSIAX ) Language L satisﬁes property BSIAX (Backwards Strict Insertion of X-admissible events) iff for all strings αβ ∈ L where β does not contain any C-events and for which there exists a string γc ∈ L with c ∈ C and γ TX= α TX, we have αcβ' ∈ L for some β' with β' TV ∪C= β TV ∪C.
Lemma 3.14 Property BSIAX is satisﬁed by language L iff
l-ins-adm-markX (L) Tm⊆ mark(L) Tm .
N	N
Proof. ⇒:  Let us assume that property BSIAX is satisfied by language
L.  Consider any string τ ∈ l-ins-adm-markX (L) Tm.  This string τ will be of the form αcqβ, where c ∈ C and β contains only V -symbols. Ac- cording to the definition of marked projection, there must exist a string αcqβ' ∈ l-ins-adm-markX(L), such that β' does not contain any C-symbols and is equal to β on V -symbols. By definition of l-ins-adm-markX(L), the
string αβ belongs to L and there exists a string γc ∈ L with γ TX= α TX. Since BSIAX is satisfied, there exists a string αcβ'' ∈ L for some string β''
with β and β'' being equivalent upto corrections of N -symbols. By definition of mark(L), the string αcqβ'' belongs to mark(L). Since β'' is equal to β after deleting all N -symbols, we have that αqcβ belongs to mark(L) Tm. Hence
l-ins-adm-markX (L) Tm⊆ mark(L) Tm.
N	N
⇐: Let us assume that l-ins-adm-markX(L) Tm⊆ mark(L) Tm. Consider
N	N
any string αβ ∈ L where β does not contain any C-symbols and there exists a string γc ∈ L for some c ∈ C such that γ TX= α TX. By the definition of


l-ins-adm-markX (L), the string αcqβ belongs to l-ins-adm-markX(L). By defi- nition of marked projection, the string αcqβ' belongs to l-ins-adm-markX(L) Tm where β' is equal to β with N -symbols deleted. Since l-ins-adm-markX(L) Tm
⊆ mark(L) Tm, the string αcqβ' also belongs to mark(L) Tm.  Again by
N	N ''
the definiton of marked projection, there must exist a string β , such that
αcqβ'' ∈ mark(L) and β'' T= β'. Note, that β'' is equivalent to β upto cor-
rections of N -symbols. Thus, by the definition of mark(L), the string αcβ''
belongs to language L. Hence BSIAX is satisfied.	 

Definition 3.15 (FCD ) Language L satisﬁes property FCD (Forward Cor- rectable Deletion) iff for all strings αcvβ ∈ L where c ∈ C', v ∈ V ' and where β does not contain any C-symbols we have αδvβ' ∈ L with β' TV ∪C= β TV ∪C.
Lemma 3.16 Property FCD is satisﬁed by language L iff
l-del-con-markC',V ' (L) Tm  ⊆ erase-con-markN' ,V ' (L) Tm.
N	N
Proof. ⇒: Let us assume that property FCD is satisfied by language L. Consider a string τ in l-del-con-markC',V ' (L). τ can be expressed as αvqβ where αcvβ ∈ L, c ∈ C', v ∈ V ' with β TC= ϵ.	There exists αvqβ' ∈ l-del-con-markC',V ' (L) Tm, where β' is β with N -symbols deleted. Since FCD is

satisfied by L
αδvβ'' ∈ L where β'' and β are equivalent upto cor-

, there exists
' ∗

rections of N -symbols, with δ ∈ (N )
''
By definition of erase-con-markN',V ' (L),
''

there exists αvqβ  ∈ erase-con-markN',V ' (L). Deleting N -symbols from β
re-

sults in β'. So, αvqβ' ∈ erase-con-markN' ,V ' (L) Tm.
m	N	m
Hence l-del-con-markC' ,V ' (L) TN ⊆ erase-con-markN',V ' (L) TN .
⇐: Let’s assume that l-del-con-markC',V ' (L) Tm ⊆ erase-con-markN' ,V ' (L) Tm.
Consider any string αcvβ ∈ L, where c ∈ C', v ∈ N ' and where β does not c	N
on-
tain any C-symbols. By the definition of l-del-con-markC',N ' (L), there exists
αvqβ ∈ l-del-con-markC' ,N ' (L). By the definition of Marked Projection, there
exists αvqβ' ∈ l-del-con-markC' ,N ' (L) Tm with β' = β T. From the assumption
l-del-con-markC',V ' (L) Tm ⊆ erase-con-markN' ,V ' (L) Tm it follows that αvqβ' ∈
N	N
erase-con-markN',V ' (L) Tm. There exists αvqβ'' ∈ erase-con-markN',V ' (L) where
''	'	N	''
β TN = β . By the definition of erase-con-markN' ,V ' (L), there exists αδvβ ∈ L
with δ ∈ (N ')∗. Note, that the strings β and β'' are equivalent upto correction of N -symbols. This proves that FCD is satisfied.	 

Definition 3.17 (FCI ) A language L satisﬁes a property FCI (Forward Cor- rectable Insertion) iff for all αvβ ∈ L with v ∈ V ' and where β does not con- tain any C-symbols, we have αcδvβ' ∈ L, for every c ∈ C' with δ ∈ (N ')∗ and β' TV ∪C = β TV ∪C.

Lemma 3.18 Property FCI is satisﬁed by language L iff
l-ins-con-markC',V ' (L) Tm⊆ erase-con-markN' ,V ' (L) Tm .
N	N
Proof. ⇒: Let us assume that property FCI is satisfied by language L. Consider a string τ ∈ l-ins-con-markC' ,V ' (L). τ can be expressed as αcvqβ, c ∈ C', v ∈ V ' with αvβ ∈ L and β TC= ϵ.  If we let β' denote β with
N -symbols deleted, then there exists αcvqβ' ∈ l-ins-con-markC',V ' (L) Tm.

Since FCI is satisfied by L, there exists αcδvβ'' ∈ L with δ ∈ (N ')∗
N
and

β'' TV ∪C= β TV ∪C. There exists αcvqβ'' ∈ erase-con-markN',V ' (L). Deleting N -
symbols from β'' results in β'. So, αcvqβ' ∈ erase-con-markN',V ' (L) Tm. Hence
m	m	N
l-ins-con-markC',V ' (L) TN ⊆ erase-con-markN' ,V ' (L) TN .
⇐: Assume that l-ins-con-markC',V ' (L) Tm⊆ erase-con-markN' ,V ' (L) Tm.
Consider a string τ ∈ L of the form αvβ, vinV 'N	β T = ϵ	N

with	C
. By the definition
'

of l-ins-con-markC',V ' (L), there exists αcvqβ ∈ l-ins-con-markC' ,V ' (L),c ∈ C .
There exists αcvqβ' ∈ l-ins-con-markC' ,V ' (L) Tm with β' is β with N -symbols
m	N	m	'
deleted. Since l-ins-con-markC',V ' (L) TN ⊆ erase-con-markN',V ' (L) TN , αcvqβ  ∈
erase-con-markN',V ' (L) Tm.	There exists αcvqβ'' ∈ erase-con-markN',V ' (L)

where β'' T
= β'.  β''
N
and
β are equivalent upto corrections of N -symbols.
''

By the definition of erase-con-markN' ,V ' (L), there exists αcδvβ  ∈ L. Hence
FCI is satisfied.	 
q
Definition 3.19 (FCIAX) L satisﬁes FCIAX(Forward Correctable Insertion of X-admissible events) iff for all αvβ ∈ L, v ∈ V ' with β TC= ϵ and there exists γc ∈ L, c ∈ C' with γ TX= α TX, we have αcδvβ' ∈ L with δ ∈ (N ')∗ and β' TV ∪C= β TV ∪C.
Lemma 3.20 Property FCIAX is satisﬁed by language L iff
l-ins-adm-con-markX	(L) Tm⊆ erase-con-markN',V ' (L) Tm.
C',V '	N	N
Proof. ⇒: Assume that property FCIAX is satisfied by language L. Con-

sider a string τ ∈ l-ins-adm-con-markX
(L). τ can be expressed as αcvqβ,

c ∈ C', v ∈ V ' with αvβ ∈ L and β TC= ϵ such that there exists γc ∈ L
with γ TX= α TX. There exists αcvqβ' ∈ l-ins-adm-con-markX	(L) Tm where
β' is β with N -symbols deleted. Since FCIAX is satisfied by L, there ex- ists αcδvβ'' ∈ L with δ ∈ (N ')∗ and β'' TV ∪C= β TV ∪C.  By the definition
''
of erase-con-markN' ,V ' (L), αcvqβ	∈ erase-con-markN' ,V ' (L).	Deleting N -
symbols from β'' results in β'. So, αcvqβ' ∈ erase-con-markN',V ' (L) Tm. Hence
l-ins-adm-con-markX	(L) Tm⊆ erase-con-markN' ,V ' (L) Tm.
C',V '	N	N
⇐: Assume that l-ins-adm-con-markX	(L) Tm⊆ erase-con-markN' ,V ' (L) Tm.
C',V '	N	N
Consider a string τ ∈ L of the form αvβ, vinV ' with β TC= ϵ such that there ex-



ists γc ∈ L with γ TX= α TX. By the definition of l-ins-adm-con-markX
(L),

there exists αcvqβ ∈ l-ins-adm-con-markX	(L),c ∈ C'. There exists αcvqβ' ∈

l-ins-adm-con-markX
(L) Tm
with β' is β with N -symbols deleted.	Us-

ing l-ins-adm-con-markX	(L) Tm ⊆ erase-con-markN',V ' (L) Tm we conclude
C',V '	N	N
that αcvqβ' ∈ erase-con-markN',V ' (L) Tm.  If β'' T= β', then there exists

αcvqβ''
N''
∈ erase-con-markN' ,V ' (L). Then β
N
and β are equivalent upto correc-

tions of N -symbols. By the definition of erase-con-markN' ,V ' (L), there exists
αcδvβ'' ∈ L. Hence FCIAX is satisfied.	 
Definition 3.21 (SR) Language L satisﬁes property SR (Strict Removal) iff for all τ ∈ L we have τ TC ∈ L.
Lemma 3.22 Property SR is satisﬁed by language L iff L TC ⊆ L.
Proof. ⇒: Let us assume that property SR is satisfied by language L. Con-
'
sider any string τ in L TC . By the definition of projection, there exists τ in L
such that τ ' T= τ . Since SR is satisfied by L, τ = τ ' T∈ L. Hence L T⊆ L.
C
⇐: Let us assume that L TC ⊆ L. Consider any string τ in L. τ TC ∈ L TC . Since L TC ⊆ L, τ TC ∈ L. Hence SR is satisfied.	 
Definition 3.23 (SD ) Language L satisﬁes property SD (Strict Deletion) iff for all αcβ ∈ L, c ∈ C such that β TC= ϵ, we have αβ ∈ L.
Lemma 3.24 Property SD is satisﬁed by language L iff l-del(L) ⊆ L.
Proof. ⇒: Let us assume that property SD is satisfied by language L. Con- sider a string τ in l-del(L). τ can be expressed as αβ with β TC= ϵ and αcβ ∈ L for some c ∈ C. Since SD is satisfied by L, there exists αβ ∈ L. Hence l-del(L) ⊆ L.
⇐: Let us assume that l-del(L) ⊆ L. Consider a string τ of the form αcβ ∈ L, c ∈ C. By the definition of l-del(L), there exists αβ ∈ l-del(L). Since l-del(L) ⊆ L, αβ ∈ L. Hence SD is satisfied.	 
Definition 3.25 (SI ) Language L satisﬁes property SI (Strict Insertion) iff for all αβ ∈ L such that β TC= ϵ, we have αcβ ∈ L, for every c ∈ C.
Lemma 3.26 Property SI is satisﬁed by language L iff l-ins(L) ⊆ L.
Proof. ⇒: Let us assume that property SI is satisfied by language L. Con- sider a string τ ∈ L. τ can be expressed as αcβ, c ∈ C such that β TC= ϵ with αβ ∈ L. Since SI is satisfied by L, there exists αcβ ∈ L. Hence l-ins(L) ⊆ L.
⇐: Let us assume that l-ins(L) ⊆ L. Consider a string τ ∈ L of the form αβ such that β TC= ϵ. By the definition of l-ins(L), there exists αcβ ∈ l-ins(L) for any c ∈ C. Since l-ins(L) ⊆ L, αcβ ∈ L. Hence SI is satisfied.	 


Definition 3.27 (SIAX) Language L satisﬁes property SIAX (Strict Inser- tion of X-admissible events) iff for all αβ ∈ L such that β TC= ϵ and there exists γc ∈ L, c ∈ C with γ TX= α TX, we have αcβ ∈ L.
Lemma 3.28 Property SIAX is satisﬁed by language L iff l-ins-admX(L) ⊆
L.
Proof. ⇒: Let us assume that property SIAX is satisfied by language L. Consider a string τ ∈ l-ins-admX (L). τ can be expressed as αcβ with β TC= ϵ such that there exists γc ∈ L, c ∈ C with γ TX= α TX. Since SIAX is satisfied by L, there exists τ = αcβ ∈ L. Hence l-ins-admX(L) ⊆ L.
⇐: Let us assume that l-ins-admX(L) ⊆ L. Consider a string τ ∈ L of the form αβ with β TC= ϵ such that there exists γc ∈ L, c ∈ C with γ TX= α TX. By the definition of l-ins-admX(L), τ ∈ l-ins-admX(L). Since l-ins-admX(L) ⊆ L, αcβ ∈ L. Hence SIAX is satisfied.	 

Operations are Regularity Preserving
We now show how the language-theoretic characterisations of BSP’s lead to a decision procedure for checking whether a finite-state system satisfies a given BSP. We first introduce the necessary terminology, beginning with the required notions in finite state automata.
A (ﬁnite-state) transition system over an alphabet ∆ is a structure of the form T = (Q, s, −→), where Q is a finite set of states, s ∈ Q is the start state, and −→⊆ Q × ∆ × Q is the transition relation. We write p −a→ q to
stand for (p, a, q) ∈−→, and use p −α→∗q to denote the fact that we have a path labelled α from p to q in the underlying graph of the transition system
T . More precisely we define −α→∗ inductively by saying p −→є ∗p for all p ∈ Q,
and p −α→a ∗q whenever there exists r ∈ Q such that p −α→∗r and r −a→ q. The language accepted (or generated ) by the transition system T is defined to be L(T ) = {α ∈ ∆∗ | p −α→∗q for some q ∈ Q}.
A (ﬁnite state) automaton (FSA) over an alphabet ∆ is of the form A =
(Q, s, −→,F ) where (Q, s, −→) forms a transition system and F ⊆ Q is a set of final states. The language accepted by A is defined to be L(A) = {α ∈
∆∗ | s −α→∗q for some q ∈ F }.
A transition system can thus be thought of as an automaton in which all states are final.
It will be convenient to make use of automata with ϵ-transitions. Here
the automaton is also allowed transitions of the form p −→ q. The language accepted by automata with ϵ-transitions is defined similarly, except that the ϵ labels don’t contribute to the label of a path. ϵ-transitions don’t add the


to the expressive power of automata, as one can give a language equivalent automaton B for a given automaton with ϵ-transitions A by adding transitions
of the form p −a→ q whenever p −a→∗q in A, and then deleting the ϵ-transitions.
The class of languages accepted by FSA’s is termed the class of regular languages. Regular languages are effectively closed under intersection and complementation. Moreover their language emptiness problem – i.e. given an FSA A, is L(A) = ∅? – is efficiently decidable (by simply checking if there is a final state reachable from the initial state). It thus follows that the language inclusion problem (whether L(A) ⊆ L(B)?) is also decidable for automata, since we can check equivalently that L(A) ∩ (∆∗ − L(B)) = ∅.
Returning to our problem of verifying BSP’s, we say that a system mod- elled as a finite-state transition system T satisfies a given BSP P iff L(T ) satisfies P . In the previous section we showed that the question of whether a language L satisfies P boils down to checking whether L1 ⊆ L2, where L1 and L2 are obtained from L by successive applications of some language-theoretic operations. If L is a regular language to begin with, and if each language- theoretic operation op of section 2 is regularity preserving and effectively so (in the sense that if M is presented by an FSA then we can construct an FSA that accepts op(M)), then L1 and L2 are also regular languages and the question L1 ⊆ L2 can be effectively answered. To give a decision procedure for our BSP verification problem, it is thus sufficient to show that the language- theoretic operations are regularity preserving in the above sense. In the rest of this section we concentrate on showing this.
The language operations of section 2 are of the following kinds: they either take a language over Σ and return a language over Σ, or they take a language over Σ and return a marked language over Σ, or they take a marked language over Σ and return a marked language over Σ. In all cases we show that if they take a regular language, they return a regular language.
Projection wrt X. Let L be a language over Σ accepted by an FSA A, and let X ⊆ Σ. Then we can construct A' accepting L TX by simply replacing transitions of the form p −→ q, with a /∈ X, in A, by an ϵ-transition
p −→є	q.
l-del. Let L be a language over Σ, with L = L(A). We construct A' for l-del(L) as follows. We create two copies of A. The initial state of A' is the initial state of the first copy. In the first copy we add an ϵ-transition
from a state p in the first copy to state q in the second copy if p −→c	q
in A, with c ∈ C. The final states in the first copy are marked non-final and the the final states in the second copy are retained.
This construction can be described formally as follows. Let A = (Q, s, −→
,F ). Define A' = (Q', s', −→',F ') where Q' = Q ×{1, 2}, s' = (s, 1), −→'



is given by


a
(p, 1) −→'
є
(p, 1) −→'
a
(p, 2) −→'

(q, 1) if p −a→ q in A
(q, 2) if  p −→ q in A with c ∈ C
(q, 2) if p −a→ q and a /∈ C,

and F ' = F × {2}.

The construction is depicted in Fig. 1.
є
Fig. 1. l-del(L)
l-ins. Let L be a language over Σ with L = L(A). We construct A' for l-ins(L) as follows. We make two copies of A. The start state of A' is the start state of the first copy, and the final states are the final states of
the second copy. In the first copy for every transition p −→ q we add a c transition (for every c ∈ C) from p in the first copy to p in the second copy. The c-transitions for c ∈ C are deleted from the second copy. The construction is depicted in Fig 2.
c
Fig. 2. l-ins(L)

l-ins-admX. Let L be a language over Σ with L = L(A), and let X ⊆ Σ. We construct A' for l-ins-admX(L) as follows. We have two “copies” of
A. In the first copy, the states have two components: the first component keeps track of a state from A, while the second keeps track of a set of states of A that are reachable by words that are X-equivalent to the
current word being read. We have a transition labelled c, with c ∈ C, from a state (p, T ) in the first copy to p in the second copy, provided T contains a state t from which it is possible to do a c and reach a final state. Once in the second copy, we allow only non-C transitions and retain the original final states.


More formally, we can define A' as follows. Let A = (Q, s, −→,F ) and let B be the automaton obtained from A by replacing transitions of the
form p −a→ q by p −→є	q whenever a /∈ X. Then A' = (Q', s', −→',F ')
where Q' = (Q × 2Q) ∪ Q; s' = (s, S) where S = {q ∈ Q | s −→є ∗q in B};
−→' is given below:

a
(p, F ) −→'
a
(p, F ) −→'

c
(p, F ) −→'
(q, F ) if p −→ q and a /∈ X
(q, U ) if p −→ q, a ∈ X, and
U = {v | ∃t ∈ F, t −a→∗v in B}
if  ∃t ∈ F, q ∈ F : t −→c	q and c ∈ C;

a
p −→'
and F ' = F .
if a /∈ C.

c

Fig. 3. l-ins-admX (L)

l-del-mark. This construction is similar to l-del except that the label of the ϵ-transitions we add from the first copy to the second, is now q.
l-ins-mark. The construction is similar to l-ins. Here instead of inserting a transition labelled c from the first copy to the second, we need to insert a transition labelled cq from the first copy to the second. This can be carried out by having a third copy of A placed between the first and second. The third copy has all its transitions deleted, and all its states are neither initial nor final. A c transition from p in the first copy now goes to p in the third copy, and from p in the third copy we add a q transition to p in the second copy.
l-ins-adm-markX . The construction is similar to l-ins-admX . Instead of adding a c transition from the first copy to the second, we add one labelled cq (once again this can be achieved using a third copy of A).
mavk. Given A for L ⊆ Σ∗, we construct A' which accepts the marked language mavk(L). A is obtained from A as follows. We again use two copies of A. The initial state of A' is the initial state of the first copy, and the final states are only those of the second copy. From every state in the first copy we add a transition labelled q to the same state in the


second copy.
Marked projection. Given a marked language M, an FSA A accepting M, and X ⊆ Σ, we construct A' which accepts the marked language M Tm. Once again we use two copies of A. The initial state of the first copy is the initial state of A' and the final states of the second copy are the final
states of A'. From the first copy we delete transitions of the form p	q	q
and add a transition labelled q from p in the first copy to q in the second copy. In the second copy, we replace transition labels which are not in X by ϵ.
q
Fig. 4. M Tm
l-del-con-mark. Let L be a language over Σ and A be an FSA accepting
L. Let C' ⊆ C and V ' ⊆ V . We construct A' accepting the marked language l-del-con-markC',V ' (L) as follows. We have four copies of A.
The second and third copies have all transitions deleted from them, and the fourth copy has all C transitions deleted from it. The initial state of the first copy is the initial state of A' and the final states of the fourth
'	c'	'	'
copy are the final states of A . For every transition p −→ q with c ∈ C ,
we add an ϵ-transition from p in the first copy to q in the second copy. We add a v'-transition from a state v in the second copy to a state t in

'
the third copy iff v −→ t, with v'
∈ V ', is a transition in A. Finally, we

add a q-transition from each state u in the third copy to u in the fourth copy.
є
q
Fig. 5. l-del-con-markC' ,V ' (L)
l-ins-con-mark.
Let L be a language over Σ and A be an FSA accepting L.	Let
C' ⊆ C and V ' ⊆ V . We construct A' accepting the marked language

l-ins-con-markC' ,V ' (L) as follows. We have four copies of A. The second and third copies have all transitions deleted from them, and the fourth copy has all C transitions deleted from it. The initial state of the first copy is the initial state of A' and the final states of the fourth copy are
'	v'	'	'
the final states of A . For every transition p −→ q with v ∈ V , we add
a c'-transition (for every c' ∈ C') from p in the first copy to q in the second copy. We add a v'-transition from a state v in the second copy to

'
a state t in the third copy iff v −→ t, with v'
∈ V ', is a transition in A.

Finally, we add a q-transition from each state u in the third copy to u in the fourth copy.
c'
q
Fig. 6. l-ins-con-markC' ,V ' (L)

l-ins-adm-con-markX. Let L be a language over Σ with L = L(A), and let X ⊆ Σ.  Let C' ⊆ C and V ' ⊆ V .  We construct A' for l-ins-adm-markX (C')V 'L as follows. We use four “copies” of A. The first copy is exactly the same as in l-ins-admX(L), where the states have two components, the first component keeping track of a state from A, while the second keeps track of a set of states of A that are reachable by words that are X-equivalent to the current word being read. The
second and third copies of A have all transitions deleted from them, and the fourth copy has all C transitions deleted from it. The initial state of the first copy is the initial state of A' and the final states of the fourth copy are the final states of A'. We have a transition labelled c', with c' ∈ C', from a state (p, F ) in the first copy to p in the second copy, provided F contains a state t from which it is possible to do a c'. We add a v'-transition from a state v in the second copy to a state u in the third

'
copy iff v −→ u, with v'
∈ V ', is a transition in A. Finally, we add a

q-transition from each state w in the third copy to w in the fourth copy.
erase-con-mark. Let L ⊆ Σ∗ and let A be an FSA with L = L(A). Let

N ' ⊆ N and V '
⊆ V . We construct A'
accepting erase-con-markN',V ' (L)

as follows. We have four copies of A. The first and fourth copy have all their original transitions intact, the second has all transitions labeled with a /∈ N' deleted and transitions labelled n', with n' ∈ N ', replaced



c'
Fig. 7. l-ins-adm-con-markX	(L)
by ϵ-transitions; and the third has all its transitions deleted. We add an
ϵ-transition from every state p in the first copy to p in the second copy;
v'
For every state p in the second copy such that p −→ q in A, we add a
v'-transition from p in the second copy to q in the third copy. From every state p in the third copy we add a transition labelled q to p in the fourth copy. The initial states of A' are the initial states of the first copy and the final states those of the fourth copy.
є

v'	q
Fig. 8. erase-con-markN' ,V ' (L)

Conclusion
We have demonstrated in this paper a way to automatically verify trace based information flow properties of finite state systems. We give characterisations of the properties in terms of language-theoretic operations on the set of traces of a system, rather than in terms of the structure of the system which is a stronger notion. This perhaps explains why we are able to obtain complete characterisations unlike the previous techniques in the literature.
The running time of our procedure can be seen to be exponential in the number of states of the given finite state transition system, in the worst case. This is because the automata constructions for the language-theoretic opera- tions involve a blow-up in states of O(n) in most cases, and 2O(n) in the case of the BSP’s based on the admissibility clause (here n is the number of states in the given transition system). Furthermore, no operation used on the right hand side of the containment (recall that our characterisations are typically
of the form op1(L) ⊆ op2(L)) introduces an exponential blow-up.  Thus in


checking containment, we have to complement an automaton of size at most
O(n), and thus we have a bound of 2O(n) in the worst case.

References
Bossi, A., R. Focardi, C. Piazza and S. Rossi, Bisimulation and unwinding for verifying possibilistic security properties, in: VMCAI 2003: Proceedings of the 4th International Conference on Veriﬁcation, Model Checking, and Abstract Interpretation (2003), pp. 223–237.
Focardi, R. and R. Gorrieri, Automatic compositional veriﬁcation of some security properties, in: Tools and Algorithms for Construction and Analysis of Systems, 1996, pp. 167–186.
Focardi, R. and R. Gorrieri, The compositional security checker: A tool for the veriﬁcation of information flow security properties, Software Engineering 23 (1997), pp. 550–571.
Goguen, J. A. and J. Meseguer, Security policies and security models, in: Proc. IEEE Symp. on Security and Privacy, 1982, pp. 11–20.
Mantel, H., Possibilistic Deﬁnitions of Security – An Assembly Kit, in: Proceedings of the 13th IEEE Computer Security Foundations Workshop (2000), pp. 185–199.
Mantel, H., Unwinding Possibilistic Security Properties, in: F. Cuppens, Y. Deswarte,
D. Gollmann and M. Waidner, editors, European Symposium on Research in Computer Security (ESORICS), LNCS 1895 (2000), pp. 238–254.
Mantel, H., “A Uniform Framework for the Formal Specification and Verification of Information Flow Security,” Ph.D. thesis, Universit¨at des Saarlandes (2003).
McCullough, D., Speciﬁcations for multilevel security and a hookup property, in: Proc. 1987 IEEE Symp. Security and Privacy, 1987, pp. 161 – 166.
McLean, J., A general theory of composition for trace sets closed under selective interleaving functions, in: Proc. IEEE Symposium on Research in Security and Privacy (1994), pp. 79 – 93.
O’Halloran, C., A calculus of information flow, in: Proceedings of the European Symposium on Research in Computer Security, ESORICS 90 (1990), pp. 147 – 159.
Sutherland, D., A model of information, in: Proceedings of the 9th National Computer Security Conference, 1986.
Zakinthinos, A. and E. S. Lee, A general theory of security properties, in: SP ’97: Proceedings of the 1997 IEEE Symposium on Security and Privacy (1997), p. 94.
