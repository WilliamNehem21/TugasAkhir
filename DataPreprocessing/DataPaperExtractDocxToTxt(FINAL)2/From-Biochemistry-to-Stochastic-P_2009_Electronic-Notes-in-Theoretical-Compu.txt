

Electronic Notes in Theoretical Computer Science 253 (2009) 167–185
www.elsevier.com/locate/entcs
From Biochemistry to Stochastic Processes
Cosimo Laneve 1
Dipartimento di Scienze dell’Informazione, Universita` di Bologna
Sylvain Pradalier 2
Ecole Polytechnique, Paris
Gianluigi Zavattaro 3
Dipartimento di Scienze dell’Informazione, Universita` di Bologna

Abstract
The nanoκ calculus is a formalism that models biochemical systems by defining its set of reactions. We study the implementation of nanoκ into the Stochastic Pi Machine where biochemical systems are defined by regarding molecules as processes, and deriving the overall behaviour by means of communication rules. Our implementation complies with the stochastic behaviors of systems, thus allowing one to use nanoκ as an intelligible front-end for a process-oriented simulator. This study also permits to reuse, in nanoκ, the theories and tools already developed for process calculi.
Keywords: Stochastic process calculi, systems biology, encoding from reactive to process-oriented formalisms.

Introduction
Several stochastic formalisms emerged in the last few years as models for the repre- sentation of biological systems (see e.g. [5,12,2,7,9,8,4] just to mention a few). These formalisms usually follow either a reactive-oriented (as [5,2,12,9,4] in the list above) or a process-oriented approach (as [7,14,8]). According to the former approach – inspired by traditional chemical kinetics – a system is specified as a set of reac- tions; according to the latter – inspired by process calculi – a system is specified by defining each molecule as a process, and deriving the overall behaviour by means of communication rules.

1 Email:laneve@cs.unibo.it
2 Email:sylvain.pradalier@lix.polytechnique.fr
3 Email:zavattar@cs.unibo.it

1571-0661 © 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.10.011

Process-oriented descriptions depart from ordinary biochemical models because they define the sequences of actions once and for all and use syntaxes usually de- voted to computer science. Moreover the modelling of a molecule is a term of size proportional to the number of interactions addressing the molecule. As a conse- quence, such descriptions are less intelligible to biochemists than reaction-oriented approaches, whose syntax is closer to biochemistry and whose complexity is spread over the reactions. On the other hand, process-oriented calculi retain several sim- ulators and tools, which make them attractive for experiments in silico (see for instance [16,7,14]).
In this paper we bridge the gap between the two approaches by implementing the nanoκ calculus [10], a reactive-oriented formalism, into the Stochastic Pi Ma- chine [7], spim calculus in the following, a simulator for the stochastic π-calculus [19,7]. In nanoκ calculus a molecule is a term A[s1 + r2](1 + 2x) with fields s and r and sites 1 and 2. The fields define the internal state of the molecule – they model its shape or its hydrogen groups or phosphate groups: in the above case, the fields s and r are set to 1 and 2, respectively; the sites are the binding capabilities of the molecule: in the above case, A is bound to another molecule with site 2, the bond is called x, and is unbound on site 1. Note that only sites can be bound and that only fields can store a value. The nanoκ calculus retains a graphical representation
– the above molecule is rendered in Figure 1(a). The dynamics of a nanoκ calculus system is defined by reactions that describe how two reactants may evolve. For example, the reaction


ρ	A[s1](1), B [t0](1) λ
A[s0](1x), B [t1](1x)

illustrated in Figure 1(b), specifies that every molecule A with an internal state s




(a)	(b)
Fig. 1. Molecules and reactions in nanoκ calculus
equal 1 and a free site 1 may react with every B with internal state t equal 0 and free site 1. The result is a complex where A and B are connected by a bond, called x, and the two internal states have swapped values. This change in the internal state might represent for instance an exchange of electronical charge. The label λ of the reaction represents its rate. It is worth to notice that this reaction applies to the molecule A in Figure 1(a), as well as to every other A with a different value of r and/or with an unbound site 2.
In nanoκ molecules may react by means of three types of reactions – creations, destructions, and exchanges – and retain a stochastic semantics. The above reaction ρ1 is an example of creations. The reaction


1	x	0
x  λ'	0	1

ρ2	A[s ](1 ), B [t ](1
) d A[s ](1), B [t ](1)

defines a destruction that is opposite to the above creation. The rate λ' may be different from λ, thus yielding equilibria in accordance with them. The reaction

z	λ''	z
ρ3	A(2 ), C (1) d A(2), C (1 )
is an exchange rule defining a bond flipping from the site 2 of A to 1 of C. Bond flipping is of a peculiar interest to model nano-machines where links between com- ponents are dynamically rearranged [10]. Despite the simplicity of these reactions, their implementation in spim calculus is complex if the stochastic semantics must be preserved. Let us discuss the problems through a number of examples.
An implementation of nanoκ into spim should project the behaviour of each molecule out of the set of reactions and collect them into a process definition. For example, the spim process ^A of the molecule A in the above examples is

^A(s, t, a1, a2) = behaviour-of A in ρ1
+ behaviour-of A in ρ2
+ behaviour-of A in ρ3

That is, a molecule is implemented by a parametric process definition, where the pa- rameters s, t, a1, a2 define the values of fields and sites. The “behaviour-of A in ρ1” might be defined as


where
[a1 = ε, s = 1] ρ1 (x).^A(0, t, x, a2)

[a1 = ε, s = 1] means that such a behaviour may be triggered provided the site
a1 is unbound (has value ε) and the field s is equal 1;
in this case the channel ρ1 is used to output a fresh name (modelling the bond). We expect that B will perform a corresponding input when the field r is 1 and the site 1 is unbound. We also expect that the rate of the channel ρ1 has been declared to be λ;
then ^A will continue as the process ^A(0, t, x, a2).
However the analogy reaction-names as channels cannot be pushed forward to destruction. In facts, if the “behaviour-of A in ρ2” was modelled as
[a1 = ¬ε, s = 0] ρ2 ().^A(1, t, ε, a2)
then A might interact with the wrong B in the spim implementation (a1 = ¬ϵ means that a1 is bound). This difficulty may be circumvented by using the names encoding bonds – that are shared exactly by the two connected molecules – in order to send the disconnection signal. So the “behaviour-of A in ρ2” becomes
[a1 = ¬ε, s = 0] a1 ().^A(1, t, ε, a2)
and we are assuming that ^B will input on a1 and that the rate of this name is λ'.

Unfortunately, this solution is also defective. Consider the rule


ρ4	A(1x
+ 2z ), B (1x
'''
d A(1x
+ 2), B (1x
+ 2z )


with λ''' /=λ'. In this case, a bond may flip from A to B (with an exchange rule) provided they are connected through the site 1. A simple solution is to implement this rule with exactly one spim interaction by using the channel x for exchanging the bond z. But the mismatch between the rates λ' and λ''' makes this solution (stochastically) unfeasible. However, this last difficulty may be overcome by intro- ducing, at creation time, a tuple of channels, one for every use. So in case of a destruction, a channel of the tuple is used (and the whole tuple is destroyed), in case of exchange, another one is used, which retains a different rate. Said otherwise, a bond in nanoκ calculus corresponds to a tuple of channels in spim with possibly different rates.
In facts, the above one is the implementation we describe in this contribution. In an accurate solution, a bond in nanoκ should be represented in spim by a tu- ple whose length is the number of reactions that address that bond directly or indirectly through sequences of exchanges. Actually, for simplicity, our solution over-approximates the “precise” solution, by representing bonds with tuples whose length is the size of the set of reactions – the gangs, in our terminology.
The encoding of nanoκ into spim defined in this paper, let it be [·]], is such
that S 'λ−→nanok T if and only if [S]] 'λ−→spim [[T ] (the arrow is subscribed to ease
the reading). It follows that S and [S ] are strongly stochastic bisimilar [3]. This is
different from usual implementations that almost never preserve the granularity of transitions. Of course, this strong relationship may be weakened by defining suitable protocols, in the style of [13]. However such a solution might hardly preserve the stochastic semantics. In facts, the stochastic semantics defines an exponential law
controlling the waiting time before a transition can be fired (the sojourn time). In
turn, the match of one reaction with a sequence of transitions amounts to matching an exponential distribution with a sum of exponential distributions, which is not possible.

Related works.
In [20], it has been shown that systems of molecular interactions with explicit bonds might be represented and simulated using the stochastic π-calculus. Our encoding corroborates this result since the spim calculus is a subset of the stochastic π-calculus. We remark that the example provided in [20] and, we believe, the descriptions done in this approach, can easily be rewritten in spim calculus and even in a sub-calculus of it, since our encodings doesn’t use its full power.
In [6], Cardelli has encoded chemical systems into process algebra and back preserving both the stochastic and the ODE semantics. Our encoding extends these encodings because the CGF process algebra used in [6] is a subset of the spim calculus and because the nanoκ calculus extends the language of chemical reactions of [6] with explicit bonds between molecules and with internal states.  However,

our results are weaker than those in [6], since we only assert the correctness of the encoding with respect to the stochastic semantics.
Another stochastic process calculus that has been used also for the modeling of biochemical systems is PEPA [14]. For instance, in [4], PEPA has been exploited to examine the influence of the RAF Kinase Inhibitor Protein (RKIP) on the Ex- tracellular signal Regulated Kinase (ERK) signalling pathway. Also in that paper, as in the present one, a reagent-centric view and a pathway-centric (process-centric in our terminology) view are studied. Our analysis of the two approaches is dif- ferent for two main reasons. First of all, in the PEPA-based approach one process is used to represent the concentration of one species while we follow the Cardelli’s approach considering one process for each molecule. In fact, we have found this approach appropriate for a compositional model of discrete state systems (in which we count the number of molecules instead of considering their concentrations). The second difference is that in [4] only finitely many different species are considered, thus the translation form the reagent-centric to the pathway-centric views can be obtained using an intermediate matrix representation that quantifies the impact of each reaction on each reagent in a manner analogous to the stoichiometry matrix of the chemical reactions. We cannot exploit this approach as we do not impose any bound to the number of different complexes that can be produced in a nanoκ calculus system. More recently, the PEPA approach has been also extended with a reaction-centric model called Bio-PEPA [9]. Also in this case, one process is used to represent the concentration of one species.
Encodings from the full κ calculus to nanoκ calculus, or to π-calculus are pre- sented in [13] and [11]. Yet, they only preserve non-stochastic semantics. In facts, encodings preserving the stochastic semantics do not exist, due to the negative results of [17].

Structure of the article.
The rest of the article is organized as follows. First we recall the syntax of nanoκ and spim, and present their basic stochastic semantics. In part 3, we first introduce the gangs and then complete the definition of the encoding. Its correctness is asserted by theorem 3.2 and 3.4. In part 4 we present the collective stochastic semantics and state the correctness of the encoding with respect to the collective stochastic semantics in theorem 4.3.
The stochastic calculi
We shortly present the two stochastic calculi we analyze in this paper: a subcalculus of nanoκ calculus, where reactants share at most one bond, and a subcalculus of spim. Examples and additional details can be found in [10] and [7].

The nanoκ calculus
Terms, called solutions, are sequences of molecules.  Each molecule belongs to a
species and retain an internal state, which is determined by a tuple of ﬁelds, and

an interface, which is a tuple of sites that may be bound to other sites. Formally, a molecule will be written A[u](σ), where
A is the species. The molecules of a species retain the same set of fields and the same set of sites that are finitely many; fields and sites will be addressed by numbers 0, 1, 2, ··· ;
u – called the evaluation – is a total map from fields of A to ﬁnite sets (the internal states of molecules are always finitely many);
σ – called the interface – is a total map from sites of A to either bonds, which are names of a totally ordered countable set ranged over by x, y, z, ··· , or ε, a special value indicating that the site is not bound.
For example, A[1 '→0; 2 '→1](1 '→ε;2 '→x;3 '→ε) is a molecule with two fields 1 and 2 and three sites 1, 2, and 3. The fields 1 and 2 have values 0 and 1, respectively; the site 2 is the only one that is bound and the bond is x. In order to ease the reading, we write this molecule as A[10 + 21](1 + 2x + 3) (the value ε is always omitted). Let ∅ be the empty map. We write A(σ) instead of A[∅](σ), A[u] instead of A[u](∅), and simply A instead of A[∅](∅). We denote by ran(σ) the range of an interface σ deprived of ε and by bonds(S) the set of the bonds appearing in the solution S.
Definition 2.1 A solution is a term defined by the grammar

S	::= A[u](σ) | S,S
The operator “,” is assumed to be associative, so (S,T),R is equal to S,(T,R) (therefore parentheses are always omitted).
Bonds always occur at most twice in solutions. A solution is proper if every bond therein occurs exactly twice.

The nanoκ calculus semantics is defined by means of reaction rules. A few preliminary definitions are in order:
we write σ ≤ σ' if dom(σ) = dom(σ') and, for every i, if σ(i) /=ε then σ(i) = σ'(i)
(the two interfaces may differ on sites mapped to the empty value ε by σ: σ' may map such sites to bonds);
a pre-solution is a sequence of terms A[u](σ) where u and σ are partial functions (with an abuse of notation, we denote partial and total functions in the same way);
a pre-solution is proper when every bond therein occurs exactly twice.
In the following when we write u+u' and σ+σ' we assume that dom(u)∩dom(u') = ∅ and dom(σ) ∩ dom(σ') = ∅.
Definition 2.2 Reactions of nanoκ calculus are either creations, destructions, or
exchanges that are labelled by rates, which are positive real numbers or ∞. Cre-

ations have format
A[u](σ),B [v](ρ) λ A[u'](σ'),B [v'](ρ'),C [w ](η ), ··· ,C


[w ](η )

d	1	1	1
n	n	n


where σ ≤ σ', ρ ≤ ρ', dom(u) = dom(u'), dom(v) = dom(v'), and wi and ηi are total. Destructions have formats

A[u](σ),B [v](ρ)  λ
A[u'](σ'),B [v'](ρ')

A[u](σ),B [v](ρ)  λ
A[u'](σ')


where σ ≥ σ', dom(u) = dom(u'), and, in the first case, ρ ≥ ρ', dom(v) = dom(v') and, in the second case, ρ has to be total. Exchanges have one of the formats:


A[u](σ),B [v](ρ)  λ
A[u](ax + σ),B [v](b + ρ) λ
A[u'](σ),B [v'](ρ)
A[u'](a + σ),B [v'](bx + ρ)

where the pre-solutions A[u](σ),B [v](ρ) and A[u](a + σ),B [v](b + ρ) are proper and dom(u) = dom(u') and dom(v) = dom(v').
In the rest of the paper we assume that reactants share at most one bond,
i.e. ran(σ) ∩ ran(ρ) is either an empty set or a singleton.
Creations produce new bonds between two unbound sites and/or synthesize new molecules. Destructions behave in the other way around. Exchanges either leave the interfaces unchanged or move one bond from a reactant to the other (bond-flipping exchange).
It is worthwhile to remark that reactions do not address every field and site of the reactants (evaluations and interfaces are partial). The intended meaning is that two molecules reacts if they are instances of the left-hand side of a reaction. We
will formalize this notion later on in the section.

The spim calculus
The spim calculus uses two sets of identifiers: names, which is totally ordered and ranged over by x, y, u, ··· , agents, ranged over by A, B, ··· . Names have a rate that is a positive real number or ∞. This rate may be explicitly declared in the process or globally defined (for free names). The following syntactic categories are used in spim calculus:

M M	matches
u˜		x(u˜ : λ˜)	actions
|P	terms

Matches are sequences of equalities between values. Actions are either input x (u˜) on x of a tuple u˜, or output x u˜ on x of a tuple u˜, or bound output x (u˜ : λ˜) on

x of a tuple u with rates λ. Terms can be the inert 0 or a parallel composition of agent invocations. The parallel operator | is assumed to be associative. Agent declarations have the form:
A(x)  Σ Miαi.Pi
i∈I

Notation.
Whenever a match has the form [u = u], or a sum has only one branch we omit to

write them explicitly. For instance A(x)   Σ
i∈{1}
[x˜i = x˜i]α.P is written A(x˜)  α.P .

A process is a term (x : λ) P – the set of agent definitions is kept implicit – where λ are rates. The term x : λ has to be considered a set with the constraint that every two different elements have different names. Processes are ranged over by P, Q, ··· .
Scope restrictions bind names, that is in (x : λ) P the x free in P is bound by

: . Likewise, input  ( )  and bound output ( : )  bind  with scope  . The agent definition A(u)   Σi∈I Miαi.Pi binds u with scope to the right hand
side of the definition. Names that are not bound are called free and we write fn(T )
for the set of such names in T .
We assume that all terms meet the following well formed properties:
in (x : λ˜)P , x ⊆ fn(P ) (there is no garbage);
bound names in agent definitions never clash with free names (this allows us to avoid alpha-conversions).
The reductions of spim calculus are communications on a channel. Since they are fixed, they will not play any relevant role in the following Definition 2.4. (They will be embodied in the (init) item of the definition.) Therefore we omit the formal definition here.

Basic transition relations
Reactions only define the (biochemical) changes of the reactants. These descriptions are used to infer transitions of solutions consisting of several possible reactants. Such transition relations are given in two steps: a first one, called basic transition relation, that records the position of the reactants in the whole solution; a second one, called collective transition relation, that computes the rate of a transition by summing the rate of the basic transitions that produce the same solution (regardless the position of the molecules/agents). Below we define the basic transition relation for nanoκ and spim calculi. (The two definitions are very close, this is why they have been collected in this subsection.) Our result of correctness of the encoding of nanoκ in spim regards the basic transition relation It follows that this correctness also holds for the collective semantics, since it is derived in the same way from the basic transition relation (see theorem 4.3 in Section 4).
The definition of the basic transition relation of the nanoκ calculus requires few

notations. Let μ range over ρL and ρR and let ρL = ρR and ρR = ρL (notice that
μ = μ). The nanoκ reactions may be addressed by:


A[u](σ),B [v](ρ)  λ
A[u'](σ'),S


where S may also be empty (denoted by ). The special term  is considered a unit for the ”,” operator (the solutions ,S, S, and S are equal). With an abuse of notation we lift a renaming ı to a solution by applying it pointwise.


Definition 2.3 The basic transition relation of nanoκ, written either
−→l, is the least relation that satisfies the following rules:
ρ,ı
−→l,l'

(init) let ρ =	A[u](σ),B [v](φ) d A[u'](σ'),S.  Then both A[u + w](σ ◦ ı +

ρ ,ı
−→1
A[u' + w](σ' ◦ ı + ν) and B [v + w](φ ◦ ı + ν) ρR,ı
T, where T is either

B [v' + w](φ' ◦ ı + ν),ı(S) or ı(S), according to the shape of the right hand side,
and ı is an injective renaming with ran(ı) ∩ ran(ν) = ∅;
(lifts) if S μ,ı  S' and (bonds(S') \ bonds(S)) ∩ bonds(T) = ∅, then both S,T μ,ı
'	μ,ı	'	'
S ,T and T,S −→l'+l T,S , where T has l molecules;

(communications) if S μ,ı
S' and T μ,ı
' T' and ı is an order-preserving injection

ρ	'	'
that map bonds into the least ones not used in S,T then S,T −→l,l''+l' S ,T , where ρ is the rule of μ and S has l'' molecules.

The indexes of the basic transition relation identify the position of the reactants since solutions are sequences of molecules. In the case (init), the position is always 1 because the solution consists of one molecule. In the case of (lifts), the index is increased by the number of the molecules on the left, if any. The last case models a reaction: the solution is split into two parts S and T containing the reactants at positions l and l', respectively. In the composite solution S,T, the reactants are at position l and l'' + l', where l'' is the number of molecules of S. For example let kM

be M, ··· ,M and let ρ : H (1), H (1) λ
H (1u), H (1u) be the hydrogen gas reaction.

` k t˛im¸es x
Then the following three transitions are possible


ρ
−→1,2
ρ
−→1,3
ρ
−→2,3
2H  (1x),H  (1) H (1x),H (1),H (1x) H (1),2H (1x)


The basic transition relation is labelled by finite injective renamings. To clarify this point, consider the creation Q = Na(1x +2),Na(1x +2) 10 Na(1x +2y ),Na(1x + 2y ) (a bond is created between two sodium molecules provided they are already bound). Then take the solution Na[ion0](1z +2),Na[ion0](1v +2),Na[ion1](1z +2),

Na[ion0](1v + 2). We derive the expected transition

Na[ion0](1z + 2),Na[ion0](1v + 2),Na[ion1](1z + 2),Na[ion0](1v + 2)

−→1,3 Na[ion
0](1z
+ 2w ),Na[ion
0](1v
+ 2),Na[ion
1](1z
+ 2w ), Na[ion
0](1v
+ 2)


following a structured operational semantics approach [18]. Namely, we focus on the single reactants and lift the transitions to “,”-contexts. This is correct inasmuch as one records the instantiation of bonds in the left-hand sides of reactions with the actual names of the molecules: the two reactants must instantiate bonds in the same way. This is the reason why the first two molecules of the above solution
cannot react with Q. More precisely, Na[ion0](1z + 2) ęL,ı  Na[ion0](1z + 2w ), where
ı = [x '→z, y '→w], and Na[ion0](1v + 2) ęR,ı .
Our final remarks regard the rule (communications).  There are possibly in-

finitely many transitions S ρ,ı
T because there are infinitely many renamings ı

which satisfy the conditions of the (init) rule. However this nondeterminism is removed when the reaction occurs because the created bonds have to be the least names not occurring in S, and because the renaming has to be order-preserving.
Said otherwise, the relation −→l,l' , which models the evolution of a solution, is

finitely branching, while the auxiliary relation  μ
is not finitely branching. It is
μ

also worth to notice that there is no rule lifting a transition −→l,l' to a context “,”: we use the associativity of , to partition a solution S into S',S'' such that the reactants are in S' and S''.
The basic transition relation of the spim calculus requires few definitions:
M is true if M is a sequence of [x = x];
length(A1(u˜1) | · · ·| An(u˜n)) returns n;
x˜ : λ˜ + y˜ : λ˜' is the sequence z1 : λ1, ··· , zn : λn where z1, ··· , zn are pairwise different names, {z1, ··· , zn} = x˜ ∪ y˜, and zi : λi if either zi : λi ∈ y˜ : λ˜' or zi /y˜∈ and zi : λi ∈ x˜ : λ˜.
[(x : λ˜)P ]GC = (z : λ˜')P such that y : λ'' is in z : λ˜' if y ∈ fn(P ) and y : λ'' is in
x : λ˜.
with an abuse of notation we lift a renaming ı to a tuple of names or to a process by applying it pointwise.
Let bn(α) be u˜ if μ is either x (u˜) or x (u˜ : λ˜); it is ∅ if α = x u˜.
Definition 2.4 The basic transition relation of the spim calculus, written either
α	τλ	α
−→l.i,l'.j or −→l.i,l'.j or −→l.i, is the least one satisfying the following rules:
(init) let A(u˜) = Σi∈I Miαi.Pi and let Mj{ve/ue} be true. If αj{ve/ue} = x w˜ then

x we


A v	1.j Pj	αj	/ue	x w	λ	A v
x (ı(we))
x (ı(we):λe)
−→ 1.j ı Pj	αj{ve/ue}

x (w˜) then A(v˜) −→ 1.j ı(Pj), where ı is an injective order-preserving renaming;
(lifts) if P −α→l.i P' and bn(α) ∩ fn(Q) = ∅ and l' = length(Q), then both

α	'	α	'

P | Q −→l.i P
•
| Q and Q | P −→l'+l.i Q | P ;
''

x (ue)	'

(communications) let l
= length(P ), λ be the rate of x, and Q
−→l'.i' Q .

If P	x ve
P' then (z˜ :
λ˜')(P | Q)	τλ
'  ''
' [(z˜ :
λ˜')(P | Q{ve/ }]
; if

−→l.i
x (ve:λg'')	'

˜	˜'
−→l.i,l +l .i
˜ : ˜' + ˜ : ˜'')( ' |
ue
'{ve
GC
})]

where v are the least names not occurring in P | Q.  Symmetrically when P
performs an input and Q performs an output.

˜'	'
τλ''

As for nanoκ, there is always at most one (z˜ : λ )P such that (x˜ : λ)P −→l,i,l',i'
(z : λ')P ' because alpha-conversion is never considered in the basic transition rela- tion, because created names are the least possible ones and because the renamings are order-preserving.
Encoding the nanoκ calculus into the spim calculus
The definition of the encoding of nanoκ calculus into spim calculus is presented in two steps. The first one defines an internal translation of nanoκ calculus that expands every bond into tuples of bonds. The bonds in the tuple are an over- approximation of the reactions that use the bond. We call these tuples of newly generated names gangs. The second step defines a translation from nanoκ (with gangs) to the spim calculus.
An example illustrating the encoding is postponed to the appendix.

Gangs: a dedicated name for every reaction
In the following we use tuples that will be ordered as follows:  (x1,..., xm) ≤
(y1,..., ym) if and only if, for every i, xi ≤ yi. Let εm be a tuple of m elements ε.

Definition 3.1 Let R = {ρi

λi
Li d Ri
| i ∈ 1..n} be a set of nanoκ reaction rules

and let j be a bijective function that maps ε to εn and bonds to n-tuples of bonds such that if x ≤ y then j(x) ≤ j(y) (such a j exists because the set of names is countable).
The solution [S]]j is S where every z being either a bond or ε is replaced by j(z).

The set of reactions [R]]
is {ρ : [[L ]] λi [[R ]]
| i ∈ 1..n}.

j	i	i j d	i j
Namely [R]]j and [S]]j are such that
interfaces map sites to tuples of bonds of length n – a gang ;
two distinct tuples do not contain the same name;
tuples preserve the order of bonds in R and S.
We let [ı]]j = j◦ı◦j−1 and [μ]]j be either ρL, [[ı]]j or ρR, [[ı]]j, depending on wether μ is ρL,ı or ρR, ı. The correctness of the encoding of Definition 3.1 is stated in the following theorem.
μ	[[μ]]j	ρ
Theorem 3.2	(i) if S −→l T then [[S]]j −→l [[T]]j (similarly for S −→l,l' T);

if [[ ]]	μ
then there exists  ' and	' such that: [[ ']] =	,
μ	', and

S j −→l T
'
μ	S j
ρ
S −→l S

μ = [[μ ]]j (similarly for [[S]]j −→l,l' T).
μ	ρ
Proof. We first consider the transitions −→l and then we lift the results to −→l,l' .

We consider S	μ
T.  We prove that the first item holds by induction on

length(S). If l = 1, the transition has been obtained by the (init) rule of the nanoκ
calculus, and we remark that [S ] and [ı ] fit the requirements of the (init) rule of

the spim calculus thus [S]] [[μ]]
[[T]]. If l > 1, the transition has been obtained by

the (lift) rule of the nanoκ calculus and S = S1,S2
with either S
μ
1 −→l
T1 (and

T = T1,S2) or S2 −→l−length(S1) T2 (and T = S1,T2). By induction hypothesis we

have that either [S ]] [[μ]]
[[T ]] or [[S ]] [[μ]]
[[T ]]. By application of the

1  −→l	1	2  −→l−length(S1)	2

(lift) rule of the spim calculus we have that [S]] [[μ]]
[[T]].

The second item for the case [S]]  μ	T is proved similarly.
ρ
We now consider the first item for the case S −→l,l' T. This transition is obtained by application of the (communications) rule, thus S = S1,S2 where S1 and S2
performs two complementary transitions of the form	μ  .  As we have already
proved that the theorem holds for such transitions, we have that also [S1]] and [[S2]]
can perform complementary transitions. By application of the (communications) rule it is easy to see that also [S]] −→l,l' [[T]].
The second item for the case [S]] −→l,l' T is proved similarly.	 

From gangs to the spim calculus: agents as molecules
The second step of our translation encodes the nanoκ calculus with gangs of bonds into processes of spim. As discussed in the Introduction, we encode a species A by a parametric agent definition A(x) = P , whose parameters x represent the possible values of fields and sites of the molecules of that species. The body P is a choice with a branch for every reaction involving the species A. A molecule A[u](σ) is an invocation A({[u, σ]}).
We begin by defining {[u, σ]}. Let ε and ¬ε be two distinguished channels. Then
{[u, σ]} is equal to {[u]}0, {[σ]}1, {[σ]}2, where
{[u]}0 yields the tuple of the values of the fields in u;
{[σ]}1 yields the concatenation of the gangs in the range of σ;
{[σ]}2 yields a tuple of length equal to the size of dom(σ), whose i-th element is ϵ
if all the element of the tuple σ(i) are ε and ¬ϵ if not.
Then we continue with a sequence of definitions. We assume given a set of n
reactions R.
[x1, ··· , xm]u is the sequence of matches [xi = u(i)]i∈dom(u) (u is a partial map);
[x1, ··· , xm]σ is the sequence of matches (Mi)i∈dom(σ) where Mi = [xi = ϵ] if all the element of the tuple σ(i) are ε, and Mi = [xi = ¬ϵ] if not;

set(x, u) is the tuple where the i-th element is u(i) whenever i ∈ dom(u), it is the
i-th element of x, otherwise;
set1(x, σ) is the tuple where the element n ∗ (i − 1) + j is the j-th element of the tuple σ(i), when i ∈ dom(σ), and xn∗(i−1)+j otherwise;
set2(x, σ) is the tuple where the element n ∗ (i − 1) + j is ε if σ(i) = εn, it is ¬ε
if i ∈ dom(σ) and σ(i) /=εn, and it is xn∗(i−1)+j otherwise;
proj(x˜, a) is the tuple (xn∗(a−1)+i)i≤n and proj(x˜, a, i) is xn∗(a−1)+i;
if A[u](σ),B [v](φ) d A[u'](σ'),S ∈ R then both A[u](σ) λ A[u'](σ') ∈ R and
L

B [v](φ) λ
S ∈R R;

If ρ is a creation, CR(ρ, R) is a sequence (x1 : λ1, ··· , xm : λm) where every subsequence (xi×n : λi×n, xi×n+1 : λi×n+1, ··· , xi×n+n−1 : λi×n+n−1) corresponds to the i-th bond created by ρ and λi×n, ··· , λi×n+n−1 are the rates of the reactions in R.
Every preliminary notation is in place for the definition of the encoding from
nanoκ with gangs to spim.
Definition 3.3 Let R be a set of n reactions in nanoκ. The spim agent corre- sponding to the species A is:


^A(x˜, y˜, z˜) =	Σ


λ	'	'
[x˜]u [z˜]σ αρ,L . Pρ,L

+ Σ	λ
[x˜]u [z˜]σ αρ,R . Pρ,R

ρ:A[u](σ)dS ∈RR

where the length of x is the number of fields of A, and the lengths of y and z are the number of sites of A times n. In addition:
if ρ is a creation with an empty set of bonds in the left-hand side then αρ,L =
ρ (u˜: λ) and αρ,R = ρ (u˜) and (u˜: λ) = CR(ρ, R);

if ρ is a creation with a bond x in the left-hand side then αρ,L = proj(y˜, a, i) (u˜: λ) and αρ,R = proj(y˜, a, i) (u˜), where a is the site of A bound by x, i is the index of ρ in R and (u˜: λ) = CR(ρ, R);

if ρ is a destruction with a bond x in the left-hand side then αρ,L = proj(y, a, i)( ) and αρ,R = proj(y, a, i) ( ), where a is the site of A bound by x and i is the index of ρ in R;
if ρ is an exchange with an empty set of bonds in the left-hand side or with a bond occurring once and in A then αρ,L = ρ u and αρ,R = ρ (u), where u is either empty, if there is no bond in the left-hand side, or proj(y, A, a) if the site with the bond is a;
if ρ is an exchange with a bond x shared by the reactants then one defines αρ,L = proj(y˜, A, a, i) (u˜) and αρ,R = proj(y˜, A, a, i) (u˜), where a is the site of A bound by x, i is the index of ρ in R and u˜ is either empty, if there is no bond in the left-hand side apart x, or proj(y˜, A, a') if A has a further bond on the site a'.

As regards continuations, Pρ,L = ^A(set(x, u'), set1(y, σ'), set2(z, σ')) and Pρ,R is ei- ther 0, if S = , or ^A(set(x, u'), set1(y, σ'), set2(z, σ')),C^1({[u1]}1, {[φ1]}2, {[φ1]}3),
··· ,C^h({[uh]}1, {[φh]}2, {[φh]}3) if S = A[u'](σ'),C1 [v1](φ1), ··· ,Cn [vn](φn).


The encoding of a nanoκ calculus solution with gangs is:
{[A1 [u1](σ1), ··· ,Am [um](σm)]}  (δS)(A^1{[u1, σ1]}, ··· ,A^m{[um, σm]}) where δS is the minimal set that contains
(ρ : λ), if ρ has no bond between reactants and has rate λ,
(xn×(i−1) : λ1, ··· , xn×(i−1)+n−1 : λn), if there is an agent invocation A{[u1, σ1]} and {[σ1]}2 = (··· , xn×(i−1), ··· xn×(i−1)+n−1, ··· ), with xi /=ε and λ1, ··· , λn being the rates of the reactions in R.

To illustrate our encoding we chose a toy-modelling of the transcription of a gene. There are four species:
Gn models a gene. It has one field tr and two sites pr and rnap; tr is 1 when the gene is being transcripted by the RNA polymerase and 0 if not; pr and rnap are used to link to Pr and RNAp, respectively;
Pr models the various promoter-sequences of the gene. It has one field act and two sites rnap and gn. The activation of the promoters by the transcription- factors is represented by switching act from 0 to 1. The sites rnap and gn are used to link RNAp and Gn, respectively;
RNAp models the RNA polymerase. It has one field act that is set to 1 when the molecule is activated by the complexations with the promoters and the tran- scriptins factors, it is set to 0 otherwise. It has a site link that may be bound either to Pr or to Gn, according to the stage of the transcription;
The species mRNA models the RNA messenger corresponding to the gene. It has neither fields nor sites.
There are three reactions. The creation ρ1 models the binding of the RNA polymerase to the promoters (between sites rnap of Pr and link of RNAp) and their activation (update of the fields act of Pr and RNAp). The exchange ρ2 models the movement of the RNA-polymerase to the gene and the beginning of the transcription itself (update of the field tr of Gn to 1). The destruction ρ3 models the termination of the transcription.



ρ  : Pr [act0](rnap) , RNAp[act0](link) λ1 Pr [act1](rnapx) , RNAp[act1](linkx)

ρ2 : Pr [act1](rnapy + gnx) , Gn[tr0](prx + rnap)

λ2	0
x	1	x	y

d Pr [act ](rnap + gn ) , Gn[tr ](pr + rnap )

ρ3 : RNAp[act1](linkx) , Gn[tr1](rnapx)
λ3	0	0
d RNAp[act ](link) , Gn[tr ](rnap) , mRNA

The encoding of this nanoκ systems yields the following four recursive definitions in spim. We notice that, in the encoding of Gn, the parameters pρ1, pρ2, pρ3, ?p correspond to the gang of the site pr (the three former are yielded by {[.]}1 and the latter by {[.]}2), similarly the parameters rρ1, rρ2, rρ3, ?r correspond to the gang of the site rnap.

G^n(tr, pρ1, pρ2, pρ3, ?p, rρ1, rρ2, rρ3, ?r) 
[tr = 0, ?p = ¬ϵ, ?r = ϵ] pρ2 (r1, r2, r3) . G^n(1, pρ1, pρ2, pρ3, ?p, r1, r2, r3, ¬ϵ)
+ [tr = 1, ?r = ϵ] rρ3 () . G^n(1, pρ1, pρ2, pρ3, ?p, ϵ, ϵ, ϵ, ϵ)

In the encoding of Pr , the parameters rρ1, rρ2, rρ3, ?r correspond to the gang of the site rnap and the parameters gρ1, gρ2, gρ3, ?g correspond to the gang of the site gn.

P^r(act, rρ1, rρ2, rρ3, ?r, gρ1, gρ2, gρ3, ?g) 
[act = 0, ?r = ϵ] ρ1 (r1 : λ1, r2 : λ1, r3 : λ3) . P^r(1, r1, r2, r3, ¬ϵ, gρ1, gρ2, gρ3, ?g)
+ [act = 1, ?r = ¬ϵ, ?g = ¬ϵ] gρ2 (rρ1, rρ2, rρ3) . P^r(0, ϵ, ϵ, ϵ, ϵ, gρ1, gρ2, gρ3, ?g)

In the encoding of the species RNAp, the parameters lρ1, lρ2, lρ3, ?l correspond to the gang of the site link.

R^N Ap(act, lρ1, lρ2, lρ3, ?l) 
[act = 0, ?l = ϵ] ρ1 (r1, r2, r3)) . R^N Ap(1, r1, r2, r3, ¬ϵ)

+ [act = 1, ?l = ¬ϵ] lρ3 . (R^N Ap(0, ϵ, ϵ, ϵ, ϵ) | m^RN A)
Since the molecule mRNA is not involved in any reaction, the corresponding process is:
m^RN A()   0
Finally, the encoding of the solution Pr [act0](rnap+gnx), Gn[tr0](prevx+rnap),

RNAp[act](link) is the term

(ρ1 : λ1, pr1 : λ1, pr2 : λ2, pr3 : λ3)( P^r(0, ϵ, ϵ, ϵ, ϵ, pr1, pr2, pr3, ¬ϵ)
| G^n(0, pr1, pr2, pr3, ¬ϵ, ϵ, ϵ, ϵ, ϵ)
| R^N Ap(act, ϵ, ϵ, ϵ, ¬ϵ)
)

Remarkably, our encoding retains some interesting compositional properties. First of all, consider two solutions S and S' and their encodings (δS)P and (δS' )P ', respectively. The encoding of the parallel composition S|S' is (δS ∪ δS' )P|P' where (δS ∪ δS' ) is the union of the name declarations δS and δS' assuming that local names are disjoints (this assumption can be guaranteed exploiting α-conversion). Furthermore, if we add a new reaction rule to a system that we have already encoded, there are very few changes to be made. First, we need to expand the length of the gangs by one. After, we have to add one line to the definitions corresponding to the two species occurring in the left hand side of the new reaction, in order to describe this additional behaviour for the molecules belonging to these two species.
The next theorem states the correctness of {[.]}. If A is the l-th molecule in S and if ρ corresponds to the i-th branch of the choice in A, we let {[l]}ρ be the pair (l, i). We also let {[ρL, ı]} and {[ρR, ı]} to be respectively αρ,L and αρ,R as defined in Definition 3.3.
μ	{[μ]}	ρ
Theorem 3.4	(i) If S −→l T then {[S]} −→{[l]}ρ {[T]} (similarly for S −→l,l' T);
μ	ρ	'	'

(ii) if {[S]} −→l.i T (resp. {[S]} −→l.i,l'.j T) then there exist S and μ
such that:

'	μ'	'	'	ρ
{[S ]} = T, S −→l S , and μ = {[μ ]} (similarly for {[S]} −→l.i,l'.i' T).
Proof. The theorem is proven similarly to theorem 3.2 (this because we have called the three items of the definition 2.4 of the basic transition relation of the spim calcu- lus with the same names (init), (lifts), and (communications) of the corresponding definition 2.3 for the nanoκ calculus).	 

The stochastic collective semantics
The basic transition relation we considered keeps track of all the possible transitions that the molecules in a solution can perform. However, some of these transitions are somehow “equivalent” because, for instance, they have the same source and the targets are indistinguishable. This is the case when the solution contains several copies of a molecule and the reaction is an homeodimerization, i.e. two identical molecules get bound.
The following collective semantics merges “equivalent” transitions into one tran- sition with an associated rate obtained as the sum of the rates of the merged tran- sitions. It uses the structural equivalence to formalize the indistinguishability of solutions.

Definition 4.1 The structural equivalence of the nanoκ calculus, noted ≡, is the least equivalence satisfying the following rules (solutions are already identified by associativity of “,”):
S,T ≡ T,S;
S ≡ T if there exists an injective renaming ı on bonds such that S = ı(T).
The structural equivalence of the spim calculus, that, with an abuse of notation, we also note ≡, is the least equivalence satisfying the following rules:
P|Q ≡ Q|P
if P is α-equivalent to Q then P ≡ Q
In order to give a unique definition of the collective semantics, we introduce a few notations. The letters F, G are used to range over solutions or processes; we
assume that transitions of the basic transition systems have shape  ρ	, where ∂ is
a pair (we are considering evolutions of closed systems). Let also

next(F ) = {((ρ, ∂), G) | F	ρ
G};

next∞
(F ) = {((ρ, ∂), G) | F	ρ
G and rate(ρ) = ∞}

F has finite rates if and only if next∞(F ) = ∅
given a set F of pairs (X, T ), where T is a term, let [F]G, where G is a fixed term, be {(X, G') | (X, G') ∈F and G' ≡ G};
can(F) is defined over sets of pairs (X, G) (the second element is a term, the first one is left unspecified), such that the terms occurring as second element of the pairs are all structurally equivalent. It returns a term G' such that there is X with (X, G') ∈ S.
Definition 4.2 [Stochastic collective transition relation] The stochastic transition

relation '−→induced by a basic transition relation ρ
(∂ is a pair of indexes) and

structural equivalence ≡ on a language is the least relation satisfying the following rules:

if F	ρ
G and rate(ρ) = ∞ then F '∞−→can([next
∞(F )]G);

if F	ρ
G and F has finite rates then F 'λ−→can([next (F )]G
), where

λ =	Σ
((ρ,∂),G')∈[next (F )]G

rate(ρ)


The correctness result of the collective transition relation is stated below.
Theorem 4.3 S 'λ−→T in nanoκ if and only if there exists P such that {[ [[S]]j ]} 'λ−→
P and P ≡ {[ [[T]]j ]} in spim.
Our correctness notion corresponds to the subcase of the strong stochastic bisim- ulation [3] where the bisimulation relation is a bijection.

Future works
Our current interests are mainly about simulators and analysis tools for spim cal- culus. In fact, this contribution allows us to simulate nanoκ systems. However, the same encoding also makes it possible to model-check nanoκ formalizations in the PRISM platform [1], since it supports verifications of probabilistic and stochastic extensions of π-calculus [15]. More precisely, it should be possible to wire our en- coding from the nanoκ calculus to spim – a subset of stochastic π-calculus – with the implementation in [15]. This requires that reactions do not create molecules, otherwise the state space would be infinite, and PRISM cannot handle such systems.
There are two questions to bother with. Firstly, our encoding uses polyadic communications, which is still not considered in [15]. However this should be one of the next extensions of this work. The second issue is more problematic. A relevant constraint for the efficiency of the encoding in [15] is the absence of name creations within agent definition. This is not the case for our encoding, because agents may perform bounded outputs. Yet, in nanoκ subsystems where the creation of new molecules is finite, the number of names used at every stage of the computation is finite. So, a clever algorithm might compute this number statically (an over- approximation is k × h, where k is the maximal number of molecules and h is the maximal length of the arguments of an agent) and use a garbage-collection mechanism to recycle names. This should allow the static allocation of variables in the PRISM language to handle all the private names.

References
L.de Alfaro, M.Z.Kwiatkowska, G.Norman, D.Parker, and R.Segala. Symbolic model checking of probabilistic processes using mtbdds and the kronecker representation. In TACAS, pages 395–410, 2000.
R. Barbuti, A. Maggiolo-Schettini, P. Milazzo, and A. Troina. A calculus of looping sequences for modelling microbiological systems. Fundamenta Informaticae, 72(1-3):21–35, 2006.
M. Bernardo. A survey of markovian behavioral equivalences. In Proc. of International School on Formal Methods for the Design of Computer, Communication, and Software Systems 2007, volume 4486 of LNCS, pages 180–219, 2007.
M. Calder, S. Gilmore, and J. Hillston. Modelling the influence of rkip on the erk signalling pathway using the stochastic process algebra pepa. In Transactions on Computational Systems Biology VII, volume 4230 of Lecture Notes in Computer Science, pages 1–23, 2006.
L. Calzone, F. Fages, and S. Soliman. Biocham: an environment for modeling biological systems and formalizing experimental knowledge. Bioinformatics, 22(14):1805–1807, 2006.
L. Cardelli. On process rate semantics. Theoretical Computer Science, 391(3):190–215, 2008.
L. Cardelli and A. Phillips. A corret abstract machine for the stochastic pi-calculus. In Proc. of Workshop on Concurrent Models in Molecular Biology, 2004.
L. Cardelli and G. Zavattaro. On the computational power of biochemistry. In Proc. of Algebraic Biology 2008, volume to appear of LNCS, 2008.
F. Ciocchetta and J. Hillston. Bio-pepa: a framework for modelling and analysis of biological systems.
Theoretical Computer Science, to appear.
A. Credi, M. Garavelli, C. Laneve, S. Pradalier, S. Silvi, and G. Zavattaro. Modelization and simulation of nano devices in the nano-k calculus. In Proc. of Computational Methods in Systems Biology 2007, volume 4695 of LNCS, pages 168–183, 2007.

Pierre-Louis Curien, Vincent Danos, Jean Krivine, and Min Zhang. Computational self-assembly.
Theoretical Computer Science, 404(1-2):61–75, 2008.
V. Danos, J. Feret, W. Fontana, and J. Krivine. Scalable simulation of cellular signaling networks. In Proc. of Asian Symposium on Programming Languages and Systems 2007, volume 4807 of LNCS, pages 139–157, 2007.
V. Danos and C. Laneve. Formal molecular biology. Theoretical Computer Science, 325(1):69–110, 2004.
Stephen Gilmore and Jane Hillston. The pepa workbench: a tool to support a process algebra-based approach to performance modelling. In Proceedings of the 7th international conference on Computer performance evaluation : modelling techniques and tools, pages 353–368, Secaucus, NJ, USA, 1994. Springer-Verlag New York, Inc.
D.Parker G.Norman, C.Palamidessi and P.Wu. Model-checking probabilistic and stochastic extensions of the pi-calculus. In IEEE Transactions on Software engineering, 2007.
J.Heath, M.Z.Kwiatkowska, G.Norman, D.Parker, and O.Tymchyshyn. Probabilistic model checking of complex biological pathways. In CMSB, pages 32–47, 2006.
C. Laneve and A.Vitale. Expressivness in the κ-family. In Proc. of MFPS, ENTCS, 2008.
G. D. Plotkin. A Structural Approach to Operational Semantics. Technical Report DAIMI FN-19, University of Aarhus, 1981.
Corrado Priami. Stochastic pi-calculus. Computer Journal, 38(7):578–589, 1995.
Corrado Priami, Aviv Regev, Ehud Shapiro, and William Silverman. Application of a stochastic name-passing calculus to representation and simulation of molecular processes. Information Processing Letters, 80:25–31, 2001.
