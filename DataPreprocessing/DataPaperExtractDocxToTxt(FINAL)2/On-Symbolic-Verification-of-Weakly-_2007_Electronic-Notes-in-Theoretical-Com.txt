Electronic Notes in Theoretical Computer Science 175 (2007) 47–64	
www.elsevier.com/locate/entcs

On Symbolic Verification of Weakly Extended PAD
Ahmed Bouajjania,1 , Jan Strejˇcekb,2 and Tayssir Touilia,3
a LIAFA, CNRS and University of Paris 7, France
b Faculty of Informatics, Masaryk University, Brno, Czech Republic

Abstract
We consider the verification problem of a class of infinite-state systems called wPAD. These systems can be used to model programs with (possibly recursive) procedure calls and dynamic creation of parallel processes. They correspond to PAD models extended with an acyclic finite-state control unit, where PAD models can be seen as combinations of prefix rewrite systems (pushdown systems) with context-free multiset rewrite systems (synchronization-free Petri nets). Recently, we have presented symbolic reachability techniques for the class of PAD based on the use of a class of unranked tree automata. In this paper, we generalize our previous work to the class wPAD which is strictly larger than PAD. This generalization brings a positive answer to an open question on decidability of the model checking problem for wPAD against EF
logic. Moreover, we show how symbolic reachability analysis of wPAD can be used in (under) approximate
analysis of Synchronized PAD, a (Turing) powerful model for multithreaded programs (with unrestricted synchronization between parallel processes). This leads to a pragmatic approach for detecting the presence of erroneous behaviors in these models based on the bounded reachability paradigm where the notion of bound considered here is the number of synchronization actions.
Keywords: rewrite systems, infinite-state systems, symbolic reachability analysis, model checking


Introduction
Reasoning about software systems requires the consideration of powerful models which are in general infinite-state, i.e., they may have an infinite number of reach- able configurations. Sources of complexity, and of infinity of the state space, may be related to either data manipulation such as the use of variables over infinite data domains, dynamic and unbounded-size data structures, etc, or to complex control primitives such as procedures calls, (unbounded) dynamic creation of concurrent

1 Email: abou@liafa.jussieu.fr
2 Partly supported by the research centre Institute for Theoretical Computer Science (ITI), project No. 1M0545. The paper has been written during J. Strejˇcek’s postdoc stay in LaBRI, Univerist´e Bor- deaux 1. Email: strejcek@fi.muni.cz
3 Email: touili@liafa.jussieu.fr

1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2006.10.053

processes, etc. One popular approach to handle this complexity is to combine ab- straction methods with model-checking. Techniques such as predicate abstraction allows to deal with aspects such as data manipulation and to generate abstract models over finite data domains. Then, the so obtained abstract models can be analyzed automatically using model checking algorithms, provided that such algo- rithms exist for the considered class of abstract models. This is the case obviously when abstract models are finite-state. However, as said above, in order to take into account complex control primitives such as procedure calls and process cre- ation, finite state models are not expressive enough. For instance, in the case of sequential programs with recursive procedure calls, the needed abstract models are (unbounded-stack) pushdown systems, and for programs with dynamic creation of communicating finite-state processes, natural models are (unbounded) Petri nets. Fortunately, there exist several algorithmic techniques (e.g., reachability analysis, model-checking) which have been developed for the analysis and the verification of these infinite-state models.
In this paper, we consider the case of programs which may contain both (re- cursive) procedure calls and dynamic creation of processes (threads). One possible approach to model such systems is to combine pushdown systems with Petri nets. This corresponds to the use of Process Rewrite Systems (PRS) introduced in [17]. These models can be seen indeed as combinations of prefix rewrite systems and multiset rewrite systems. The relevance of PRS in program modeling have been discussed for instance in [8,9,7,1,2]. Subclasses of PRS which are of particular in- terest for program modeling are for instance the class of PA processes, and the larger class of PAD processes generalizing both PA and pushdown processes and corresponding to synchronization-free PRS (i.e., models where parallel composition is not allowed in the left-hand-side of the rewrite rules). Processes in these classes allow indeed to model systems with procedure calls and parbegin-parend blocks (i.e., launching a number of parallel threads, and wait for their termination before proceeding). PAD allow in addition return values from sequential procedure calls.
Richard Mayr has shown that the reachability problem (whether a given state is reachable from another given state) for PRS is decidable using a reduction to the reachability problem of Petri nets [17]. To get practical verification algorithms, symbolic reachability algorithms have been investigated for significant subclasses of PRS such as PA [16,9] and PAD [1,2]. These algorithms use (various kinds of) tree automata to represent (regular) infinite sets of configurations (i.e., process terms). In particular, we have provided in [2] a generic construction allowing to compute the set of (forward or backward) reachable configurations of any subclass of PRS built from the combination of prefix rewrite systems with an effectively semilinear class of multiset rewrite systems (i.e., a class of systems for which reachability sets are always semilinear and effectively computable). We have shown that this leads to a symbolic reachability analysis algorithm for PAD processes in a certain normal form.
The PRS formalism is not Turing powerful due to a subtle restriction on the way synchronization is done between parallel processes. Roughly speaking, the

semantics of PRS implies that synchronization can only be allowed between parallel processes with empty stacks.
In order to extend the modeling power of PRS, one approach is to add syn- chronization by rendez-vous (`a la CCS), which leads to a Turing powerful model called synchronized PRS [21]. Similarly, PAD can be extended to synchronized PAD (which is also a Turing powerful model). Approximate analysis algorithms for these models using abstraction techniques have been proposed in [21].
Another approach for enhancing the modeling power of PRS (and PAD) consists in adding global control states. The new models, called sePRS [11], can be seen as parallel product of a PRS with a finite-state automaton representing a global control. Obviously, sePRS are Turing powerful since they allow communication between recursive parallel processes through the global control state. However, if the structure of the control automaton is weak, which means that all its loops are self- loops, then it can be proved that the obtained models, called wPRS, have a decidable reachability problem [12] (the proof employs decidability of the reachability problem for Petri nets). Similarly, if we add control states to PAD processes, we obtain Turing powerful models, but the extension of PAD with weak control automata leads to models, called wPAD, having a decidable reachability problem, and interestingly, which can be proven to be strictly more powerful (w.r.t. strong bisimulation) than PAD [13].
In this paper we extend the results on symbolic reachability analysis presented in [2]. While [2] deals only with PAD processes in a certain normal form (now called canonic PAD ), here we show that the set of reachability states are com- putable and effectively representable even for (general) wPAD systems. To do this, we employ symbolic representations based on so-called commutative-hedge automata (CH-automata), allowing to define sets of process terms modulo the associativity of sequential composition, and the associativity-commutativity of the parallel com- position. We show that these representations are effectively closed under the com- putation of the post∗ and pre∗ images (i.e., computation of all successors and all predecessors) for wPAD, as well as under the post and pre images (i.e., computation of immediate successors and predecessors) for the whole class of wPRS.
Further, we solve the global model-checking problem of wPAD against the EF logic. We consider a variant of EF logic which generalizes the standard action-based EF logic by the use of atomic propositions corresponding to (potentially infinite) sets of configurations which are definable using CH-automata. We prove that for every formula in this logic, it is possible to construct a (CH-automata based) repre- sentation of the set of all configurations (in a given wPAD) satisfying this formula. This result closes an open problem formulated in [14] concerning the model-checking problem of wPAD. Notice that global model-checking is a more general problem than deciding whether a given configuration satisfies a given formula.
Finally, we show that our results concerning symbolic reachability analysis of wPAD can be used in the analysis of synchronized PAD (SPAD) with a bounded number of synchronizations. This leads to an approximate analysis procedure for SPAD based on computing under approximations of their reachability sets by con-

sidering only reachable configurations up to some fixed number of synchronizations. Such approximate analysis method for SPAD can be used in practice to establish the existence of erroneous behaviors, following the approach advocated in [18]. It constitutes a complementary approach to the abstract analysis (provided for SPAD in [21]), which is based on considering upper approximations of the set of possible behaviors and which is useful for establishing the absence of erroneous behaviors.

Preliminaries
Process terms
Let Const = {X,.. .} be a set of process constants. For every C ⊆ Const , the set TC of process terms over C is defined by the abstract syntax t ::= 0 | X | t ⊙ t | t  t, where 0 is the idle term, X ∈ C is a process constant; and ⊙ and  mean sequential and parallel compositions respectively.
We use ω to denote in a generic way ⊙ or  . We denote by ω the operator ⊙ (resp. ) if ω =  (resp. ω = ⊙). Process terms are considered modulo the following algebraic properties: associativity of ⊙, associativity and commutativity of , and neutrality of 0 w.r.t. both ⊙ and  , i.e. 0 ⊙ t = t ⊙ 0 = t  0 = t. Let  be the equivalence relation on T induced by these properties.
We distinguish four classes of process terms as:
1 – terms consisting of a single process constant only, in particular 0 /∈ 1, S – sequential terms - terms without parallel composition, e.g. X ⊙ Y ⊙ Z, P – parallel terms - terms without sequential composition, e.g. X  Y Z,
G – general terms - terms without any restrictions, e.g. (X ⊙ (Y Z))  W . Process terms in canonical form are terms t defined by:
t ::= 0 | s | p
s ::= X | p1 ⊙ p2 ⊙ ... ⊙ pn, n ≥ 2
p ::= X | s1  s2  ... sn, n ≥ 2
It can easily be seen that every term has an  -equivalent term in canonical form. In the following we work with terms in canonical form.
Term t is called seq-term if t = 0, or t = X for a constant X, or t = p1 ⊙ p2 ⊙ ... ⊙ pn where n ≥ 2. In the last case, the term is also called ⊙-rooted term. Further, t is called flat seq-term if t = X1 ⊙ X2 ⊙ ... ⊙ Xn for n ≥ 0 (the case n =0 corresponds to the term 0, and the case n = 1 corresponds to a process constant
X). By analogy we define par-terms, -rooted terms, and flat par-terms.
Process Rewrite Systems and weak extension
Let M = {o, p, q,.. .} be an ordered set of control states and Act = {a, b, c,.. .} be a set of actions. Let α, β ∈ {1, S, P, G} be classes of process terms such that α ⊆ β.
An (α, β)-wPRS (weakly extended process rewrite system) R is a finite set of rewrite
a
rules of the form (p, t1) ‹→ (q, t2), where t1 ∈ α, t1 /= 0, t2 ∈ β, p, q ∈ M , p ≤ q, and

a ∈ Act . By M (R), Const (R), and Act (R) we denote sets of control states, process constants, and actions occurring in rewrite rules of R.
An (α, β)-wPRS R induces a labelled transition system the states of which are pairs (p, t) such that p ∈ M (R) is a control state and t ∈ β is a process term over Const (R). The transition relation →R is the least relation satisfying the following inference rules:

a
((p, t1) ‹→ (q, t2)) ∈ R


a
(p, t1) →R (q, t2)
(p, t ) →a	(q, t )

a
(p, t1 t) →R (q, t2 t)
(p, t ) →a	(q, t )

a
(p, t1 ⊙ t) →R (q, t2 ⊙ t)

We extend the transition relation to finite words over Act in a standard way. The
∗
reflexive and transitive closure of →R is denoted by →R. To shorten our notation
we write pt in lieu of (p, t).
An (α, β)-wPRS where M (R) is a singleton is called (α, β)-PRS (process rewrite system). In such systems we omit the single control state from rules and states.
Instead of (S, G)-PRS, (S, G)-wPRS, (G, G)-PRS, and (G, G)-wPRS we use more readable names PAD, wPAD, PRS, and wPRS respectively. Let us note that the classes PAD and wPAD subsume widely known models of infinite-state systems as pushdown processes (PDA), basic parallel processes (BPP), and process algebras (PA). The classes PRS and wPRS subsume also Petri nets (PN). More information about expressiveness of (α, β)-wPRS and (α, β)-wPRS can be found in [13,12].
Given a state pt of a wPRS R, we define
Post R(pt) = {p't' | pt →a R p't' for some a}	Post ∗ (pt) = {p't' | pt →∗ R p't'}

' '	' ' a
∗	' '
' ' ∗

PreR(pt) = {p t
| p t
→R pt for some a}	PreR(pt) = {p t
| p t
→R pt}

The sets Post ∗ (pt) and Pre∗ (pt) are called (forward and backward) reachability
R	R
sets. The sets Post R(pt) and PreR(pt) are called 1-step (forward and backward)
reachability sets. These definitions and notations can be extended to sets of states in the obvious manner.
Canonic PRS
A canonic PRS R is a set of rewrite rules of the forms:
a
X1 ⊙ X2 ⊙ ... ⊙ Xn ‹→ Y1 ⊙ Y2 ⊙ ... ⊙ Ym	(1)
a
X1 X2 ... Xn ‹→ Y1 Y2 ... Ym	(2)
where n, m ≥ 0.  Rules of the form (1) and (2) are called ⊙-rules and  -rules
respectively. By Rω we denote the set of all ω-rules of R. Note that the sets R 
a
and R⊙ do not have to be disjoint as some rules (e.g. X ‹→ Y ) are of both types.
Let α, β ∈ {1, S, P, G} be classes of process terms. A canonic PRS is called canonic
a
(α, β)-PRS if every rule t1 ‹→ t2 of R satisfies t1 ∈ α and t2 ∈ β. Finally, canonic
PAD stands for canonic (S, G)-PRS.
Note that a canonic PRS does not have to be a PRS as we allow rules with 0 on

the left-hand side. Further, the definition of canonic (α, β)-PRS does not require that α ⊆ β. The meaning of Const (R), →R, Post R, Pre R,... remains the same.
Given a canonic (α, β)-PRS R, by R−1 we denote the canonic (β, α)-PRS with rules obtained by swapping the left-hand and right-hand sides of the rules of R. Notice that for every set of process terms L, PreR(L)= Post R−1 (L) and Pre∗ (L)= 
Post ∗ −1 (L).
The problem of computing reachability sets of PRS systems can be transformed into the same problem for canonic PRS using the following theorem. The proof of this theorem employs a variant of the standard construction given in [17]. However, our theorem differs from the one of [17] in several aspects. In particular, (1) we transform an (α, β)-PRS into a canonic (α, β)-PRS, which is not the case of Mayr’s transformation, and (2) in contrast to the original theorem in [17], our theorem states that the same transformation of R works for all terms over a given set of process constants.
A term substitution h is a function on process terms satisfying h(0) = 0 and h(t1 ω ... ω tn)= h(t1) ω ... ω h(tn) for all finite sequences t1,... , tn of terms and for both ω = ⊙, . In other words, a term substitution is fully specified by its values on process constants. We say that a term subsitution h is ﬁnite if the set
{X | h(X) /= X} of process constants is finite.
Theorem 2.1 For every (α, β)-PRS system R and every set of process constants C we can construct a canonic (α, β)-PRS system R' and a ﬁnite term substitution h, such that for every t1, t2 over C ∪ Const (R) and every a ∈ Act (R) we have:

a	'	'
'	'	'  a  '  '

t1 →R t2 iff there exists t1, t2 satisfying h(t1)= t1, h(t2)= t2, and t1 →R t2,

t1 →∗ R t2 iff there exists t' , t' satisfying h(t' )= t1, h(t' )= t2, and t'
→∗ R' t' .

1  2	1
a	'
2	1	2
'

Proof. Let size(t ‹→ t ) be the number of occurrences of ⊙ and  in terms t and t .
Given any PRS R, let ki be the number of rules r ∈ R that are neither ⊙-rules nor -rules and size(r)= i. Thus, R is canonic PRS iff ki =0 for every i. In this case, let n = 0. Otherwise, let n be the largest i such that ki /=0 (n exists as the set of rules is finite). We define norm(R) to be the pair (n, kn).
First we describe a procedure transforming an (α, β)-PRS R into an (α, β)-PRS R' and defining finite term substitution h such that norm(R') < norm(R) (with respect to the lexicographical ordering) and for every terms t1, t2 over C ∪ Const (R) and every a ∈ Act (R) the following equivalences hold:

a	'	'
'	'  a  '  '

t1 →R t2	⇐⇒	there exists t1, t2 satisfying h(ti)= ti and t1 →R t2
t1 →∗ R t2	⇐⇒	there exists t' , t' satisfying h(t')= ti and t' →∗ R' t'
1  2	i	1	2
In this proof we assume that ⊙ is left-associative. It means that the term X ⊙ Y ⊙ Z is seen as (X ⊙ Y ) ⊙ Z and so its subterms are X, Y , Z, and X ⊙ Y , but not Y ⊙ Z. Let us assume that R is not canonic PRS. Let τ /∈ Act (R) be a fresh action. We set h(X) = X for every X ∈ C ∪ Const (R) and R' = R. Let

r = (s1 ‹→ s2) be a rule of R'
size. There are three cases:
that is neither ⊙-rule nor -rule and has the maximal

s1 is ω-rooted and s2 is ω-rooted. In R'
a
τ
we replace the rule r by rules s1 ‹→ Z,

Z ‹→ s2, where Z /∈ C ∪Const (R) is a fresh process constant. We set h(Z)= s1.
Clearly, the considered equivalences holds.
s1, s2 are par-terms and at least one of them is not flat. Let t be an ⊙-rooted subterm of s1 or s2. We modify R' in two steps. First, in all left-hand and right-hand sides of all rules, we replace every occurrence of t by a fresh process
τ
constant Z /∈ C ∪ Const (R). Further, we add the rule Z ‹→ t and if t ∈ α then
τ
we add also the rule t ‹→ Z. We set h(Z)= t.
τ
We say that an occurrence of subterm t of term s is active, if a rule t ‹→ Z can
be applied on s such that the occurrence of t is replaced by Z. The occurrence is inactive otherwise. Note that an occurrence of t in s is inactive iff it is a subterm of the right component of some sequential composition.
Clearly, the first equivalence and the implication “⇐=” of the second equiv- alence hold. In order to prove the remaining implication, we show that every
a
transition l1 →R l2 (where l1, l2 are terms over C ∪ Const (R)) corresponds
' τ ∗ aτ ∗	'	'	'
to a transition sequence l1	→ R' l2, where l1, l2 are l1, l2 with all inactive
occurrences of t replaced by Z. Let us assume that the transition l1 →R l2 is
a	'
generated by a rule l ‹→ l . Each occurrence of t in l1 modified by the rule is
either active, or it is inactive (and thus replaced by Z in l' ) and completely contained in l (due to the left-associativity of ⊙). Hence, we can apply the
τ	'
rule t ‹→ Z to all occurrences of t in l1 which are going to be modified by the
rule of R' corresponding to l ‹→ l' (i.e. the same rule with all occurrences of t
replaced by Z). This corresponding rule is applied afterwards.
The situation with occurrences of t appearing in l2 after the application of the considered rule is similar. Each occurrence of t in l2 created by the rule is either active, or it is inactive and completely contained in l. Hence, after

application of the corresponding rule of R', we apply the rule Z
active occurrences of Z to reach l' .
τ
‹→ t to all

s1, s2 are seq-terms and at least one of them is not flat. This case is a direct analogy of the previous one.
Note that norm(R') < norm(R) and R' belongs to (α, β)-PRS class. After finitely many (say n) applications of this procedure, a given (α, β)-PRS R is transformed into a canonic (α, β)-PRS R'. Let hi be the finite term substitution defined in i-th application of the procedure. We set h = h1 ◦ h2 ◦ ... ◦ hn. It is now easy to see that this canonic PRS R' and finite term substitution h satisfy the equivalences formulated in the theorem.	 

Automata-based symbolic representations
In order to perform reachability analysis of PRS, we need representation structures for (infinite) sets of process terms. For this purpose, we use a class of tree-automata, called commutative hedge automata [2], which recognize sets of trees modulo asso-

ciativity / associativity-commutativity. These automata extend both (1) bottom-up tree automata over ranked alphabets [5], and (2) hedge automata recognizing sets of unbounded width trees [3].
Preliminaries
Presburger arithmetic is the first order logic of integers with addition and linear ordering. Given a formula ϕ, we denote by FV (ϕ) the set of its free variables. Let FV (ϕ) = {x1,... , xn}. Then, a vector u = (u1,... , un) ∈ Zn satisfies ϕ, written u |= ϕ, if ϕ(u) = ϕ[xi ← ui] is true. Each formula ϕ defines a set of integer vectors [ϕ]] = {u ∈ Zn | u |= ϕ}. Presburger formulas define semilinear sets of integer vectors, i.e., finite union of sets of the form {x ∈ Zn | ∃k1,... , kn ∈ Z, x = v0 + k1v1 ··· + knvm}, where vi ∈ Zn, for 1 ≤ i ≤ m (see [10]).
Given a word w over an alphabet Σ = {a1,... , an}, the Parikh image of w, de- noted Parikh(w), is the vector (|w|a1 ,... , |w|an ). This definition can be generalized to sets of words (languages) over Σ in the obvious manner.
As usual, a set of words is regular if it is definable by a finite-state automaton. The notion of regularity can be transfered straightforwardly to sets of flat seq-terms. Similarly, the notion of semilinearity can be transfered to sets of flat par-term by associating with a term X1  ··· Xn the vector Parikh(X1 ··· Xn).
In the sequel, we will represent by γ a constraint which is either a regular lan- guage or a Presburger formula. We say that a word w = a1a2 ... an satisﬁes the constraint γ if w ∈ γ (resp. Parikh(w) |= γ) when γ is a language (resp. a formula).
Commutative Hedge Automata
Let Σ = Σ' ∪ ΣA be a finite alphabet, where Σ' is a ranked alphabet, and ΣA is a finite set of associative operators. We assume that Σ' and ΣA are disjoint. For k ≥ 0, let Σk denote the set of elements of Σ' of rank k.
Σ-Terms:
Let X be a fixed countable set of variables {x1, x2,.. .}. The set TΣ[X ] of Σ-terms over X is the smallest set such that:
Σ0 ∪X ⊆ TΣ[X ],
for k ≥ 1, if f ∈ Σk and t1,... , tk ∈ TΣ[X ], then f (t1,... , tk) ∈ TΣ[X ],
if f ∈ ΣA, t1,... , tn ∈ TΣ[X ] for some n ≥ 1, and root(ti) /= f for every
1 ≤ i ≤ n, then f (t1,... , tn) ∈ TΣ[X ], where root(σ) = σ if σ ∈ Σ0 ∪ X , and root g(u1,... , um) = g.
Note that if f ∈ ΣA, we only consider terms of the form f (t1,... , tn) such that for every i, the root of ti is different from f .  Indeed, since f is associative, f t1,... , ti−1,f (u1,... , um), ti+1,... , tn  is equivalent to the term f (t1,... , ti−1, u1,... , um, ti+1,... , tn).
Terms without variables are called ground terms. Let TΣ be the set of ground terms of TΣ[X ]. A term t in TΣ[X ] is linear if each variable occurs at most once

in t. A context C is a linear term of TΣ[X ]. Let t1,... , tn be terms of TΣ, then C[t1,... , tn] denotes the term obtained by replacing in the context C the occurrence of the variable xi by the term ti, for each 1 ≤ i ≤ n.
Deﬁnition of CH-automata:

Let us consider that ΣA = Σ'	'	where Σ'
is a set of associative and commu-

tative operators. We assume that Σ'
and Σ'
are disjoint. Then, a CH-automaton

is a tuple A = (Q, Σ, F, Δ) where:
Q is a union of disjoint finite sets of states Q' ∪  f ∈Σ
F ⊆ Q is a set of final states,
Δ is a set of rules of the form:
a → q, where q ∈ Q',a ∈ Σ0,

Qf ,

f (q1,... , qk) → q, where f ∈ Σk,q ∈ Q', and qi ∈ Q,
q → q', where (q, q') ∈ Q' × Q' ∪  f ∈Σ Qf × Qf ,
f (Reg ) → q, where f ∈ Σ' , Reg ⊆ (Q \ Qf )∗ is a regular language given by a
finite-state automaton, and q ∈ Qf ,
f (ϕ) → q, where f ∈ Σ'	, q ∈ Qf , and ϕ is a Presburger formula such that
FV (ϕ)= {xq | q ∈ Q \ Qf }.
We define a move relation →Δ between ground terms in TΣ∪Q as follows: for every two terms t and t', we have t →Δ t' iff there exist a context C and a rule r ∈ Δ such that t = C[s], t' = C[s'], and:
r = a → q, with s = a and s' = q, or
r = q → q', with s = q and s' = q', or
r = f (q1,... , qk) → q, with s = f (q1,... , qk) and s' = q, or
r = f (Reg ) → q, with f ∈ Σ' , s = f (q1,... , qn), q1 ··· qn ∈ Reg , and s' = q, or
r = f (ϕ) → q, with f ∈ Σ'	, s = f (q1,... , qn), Parikh(q1 ··· qn) |= ϕ, and
s' = q.
Let →∗ Δ denote the reflexive-transitive closure of →Δ. A ground term t ∈ TΣ is accepted by a state q if t →∗ Δ q. Let Lq = {t ∈ TΣ | t →∗ Δ q}. A ground term t ∈ TΣ is accepted by the automaton A if it is accepted by some final state q ∈ F . The CH-language of A, denoted by L(A), is the set of all ground terms accepted by A.
We have the following fact [4,15,19,20,2]:
Theorem 3.1 The class of languages recognized by CH-automata is effectively closed under boolean operations, term substitutions and inverse of ﬁnite term sub- stitutions. Moreover, the emptiness problem of CH-automata is decidable.
CH-automata for PRS process terms
We consider process terms as trees and use CH-automata to represent sets of such trees. Indeed, for any finite set C ⊆ Const , the set TC of process terms can be seen

as the set of Σ-terms TΣ where Σ0 = {0}∪ C, Σ'
= {⊙}, and Σ'
= { }.

Sets of process terms are recognized by CH-automata A = (Q, Σ, F, Δ) such that (1) Q is the disjoint union Q = Q' ∪ Q⊙ ∪ Q  where Q' is itself the disjoint union Q' = Q0 ∪ Q−, and (2) the rules in Δ are of the form: (a) X → q, where q ∈ Q−, X ∈ Const, (b) 0 → q, where q ∈ Q0, (c) q → q', where (q, q') ∈ (Q0)2 ∪ (Q−)2 ∪ (Q⊙)2 ∪ (Q  )2, (d) ⊙(Reg ) → q, where Reg ⊆ Q \ (Q⊙ ∪ Q0) ∗ is a regular language and q ∈ Q⊙, and (e)  (ϕ) → q, where q ∈ Q  and ϕ is a Presburger formula such that FV (ϕ)= {xq | q ∈ Q \ (Q  ∪ Q0)}.
In other words, the states in Q⊙ (resp. Q  ) recognize trees whose root is ⊙ (resp. ). The states in Q− recognize constants in C, and the states in Q0 recognize 0.

Computing 1-step reachability sets for canonic PRS
Let us consider a canonic PRS R = R⊙ ∪ R  and let A = (Q, Σ, F, Δ) be a CH- automaton recognizing a set L of process terms. We show that the sets Post R(L) and PreR(L) are effectively representable and computable by CH-automata.
For a given canonic PRS R' and a given set of terms L1, we write R'(L1) as an abbreviation for Post R' (L1). In the following we use the fact that given a regular set L2 of flat seq-terms, the set R' (L2) is again regular and easily constructible. The same holds for any semilinear sets L3 of flat par-terms and R' (L3).
We construct a CH-automaton A' = (Q˜, Σ, F˜, Δ˜) which recognizes R(L), where
Q˜ is the set of states, F˜ is the set of final states, and Δ˜ is the set of rules. Let C
be a finite set of process constants such that C ⊇ Const (R) and L ⊆ TC.
The set of states
The set of states Q includes the set of states Q of A and contains new states qX, which are assumed to accept precisely the singletons {X} (i.e., LqX = {X}), for each X ∈ C. Let QR be the set of states QR = {qX | X ∈ C}. In addition, the set Q contains states which recognize the set R(Lq) of immediate successors of terms in Lq for each q ∈ Q ∪ QR. In order to ensure (during the construction) that the recognized trees are always in canonical form, we need to partition the sets of recognized trees according to their types (given by their root).
We associate with each q ∈ Q ∪ QR different states (q, −), (q, 0), (q, ⊙), and (q, ) recognizing immediate successors of terms in Lq which are respectively constants in C, null (equal to 0), ⊙-rooted terms, and -rooted terms.
Let Q = Q0 ∪ Q− ∪ Q⊙ ∪ Q  . We consider that the set Q is equal to the union of the following sets: (1) Q0 = Q0 ∪ {(q, 0) | q ∈ Q ∪ QR}, (2) Q− = Q− ∪ QR ∪ {(q, −) | q ∈ Q ∪ QR}, and (3) Q˜ω = Qω ∪ {(q, ω) | q ∈ Q ∪ QR}, for ω ∈ {⊙, }. Moreover, we consider that F˜ = {(q, −), (q, 0), (q, ⊙), (q, ) | q ∈ F }.
Rewrite system over the alphabet of states
Rules in CH-automata (of the forms ω(γ) → q) involve constraints on sequences of states, whereas the systems R⊙ and R  are defined over the alphabet of process constants. Therefore, we define the systems S⊙ = α(R⊙) and S = α(R ) where α

is the substitution such that α(X)= qX, for every X ∈ C (extended in the standard way to terms, rules, and sets of rules).

The set of transition rules
The set Δ is defined as the smallest set of transition rules which (1) contains Δ, (2) contains the set of rules X → qX for every X ∈ Const , and (3) is such that:
(β1) Closure rules: successors of process constants and 0:
If X →∗	q, then ω S (q ) → (q, ω) ∈ Δ,
If 0 →∗ Δ q, then ω Sω(0) → (q, ω) ∈ Δ.
The rule (a) says that if X is in Lq, then all its immediate ω-successors obtained by applying once the system Rω are also immediate successors of Lq. The rule
(b) says the same thing for successors of 0.
(β2) Closure rule:  successors of ω-rooted terms: If ω(γ) → p ∈ Δ, then ω Sω(σ(γ)) → (p, ω) ∈ Δ, where σ is the substitution such that ∀q ∈ Q ∪ QR, σ(q)= {q}∪ {qX | X →∗ Δ q}∪ {0 | 0 →∗ Δ q}.
This rule says that if ω(X1,... , Xn)	∈	Lp  and  ω(X' ,... ,X' )	∈
1	m
Rω ω(X1,... , Xn) , then ω(X ,... ,X  ) is a ω-successor of Lp.
(β3) Propagation rule: If ω(γ) → p ∈ Δ, then ω Eω(γ)  → (p, ω) ∈ Δ, where E
is a canonic PRS defined as E = {q ‹→ (q, −),q ‹→ (q, ⊙),q ‹→ (q, )}.

The rule says that if ⊙(t1,... , tn) ∈ Lp and t'
is a successor of t1, then

⊙(t' ,... , tn) is a successor of Lp. Moreover, if  (t1,... , tn) ∈ Lp and t' is
1	i
a successor of ti, then (t1,... , t' ,... , tn) is a successor of Lp.
Note that we need to distinguish between E  (γ) and E⊙(γ) to ensure that the preﬁx-rewrite strategy of the ⊙ is correctly taken into account.
(β4) Term flattening rules:

If ω(γ) → (q, ω) ∈ Δ˜ and q' ∈ γ, then q' → (q, −) ∈ Δ˜
if q' ∈ Q˜−, and

q' → (q, ω) ∈ Δ˜ if q' ∈ Q˜ω .
If ω(γ) → (q, ω) ∈ Δ and 0 ∈ γ, then 0 → (q, 0) ∈ Δ.
The rules say that if ω(t) is a successor of Lq, then t is also a successor of Lq.
Now we prove that the construction is correct.
Lemma 4.1 For every process term t, and every q ∈ Q ∪ QR we have:
t →∗ e (q, 0) iff t ∈ Post R(Lq) and t = 0,
t →∗ e (q, −) iff t ∈ Post R(Lq) and t ∈ C,
t →∗ e (q, ω) iff t ∈ Post R(Lq) and root(t)= ω, for ω ∈ {⊙, }.
Proof. We consider the (more complicated) left-to-right direction. The proof is by structural induction on t:
t = X →∗ e (q, −) (the case where t =0 →∗ e (q, 0) is similar). Note that the rules
Δ	Δ
∗	∗

of Δ˜
do not allow derivations of the form X →e (q, 0) or X →e (q, w).

Such a derivation has necessarily the following form:
X→e qX→e (q, −)
Δ	Δ
where the rule qX→e (q, −) is a β4-rule. There are three cases:
Δ
  
Δ, and qX ∈ Sω(σ(γ)). Suppose that ω = ⊙, the other case where ω = || is analogous. This means that there exists qX1 ··· qXn ∈ σ(γ) such that qX ∈ S⊙(qX1 ··· qXn ). This means that X ∈ R⊙ ⊙(X1,... , Xn) . Since qX1 ··· qXn ∈ σ(γ) and ⊙(γ) →Δ q, it follows that ⊙(X1,... , Xn) ∈ Lq. Therefore, X ∈
R⊙(Lq), i.e., X ∈ Post R(Lq).
There exists a constant Y such that Y →∗ Δ q, ω Sω(qY ) → (q, ω) is in Δ˜, and
qX ∈ Sω(qY ). Suppose here also that w = ⊙, the other case where w = || is
analogous. This means that qX ∈ S⊙(qY ), and that X ∈ R⊙(Y ). Since Y ∈ Lq, it follows that X ∈ R⊙(Lq), i.e., X ∈ Post R(Lq).
∗		˜
0 →Δ q, ω Sω(0) → (q, ω) is in Δ,and qX ∈ Sω(0). Suppose here also that
w = ⊙, the other case where w = || is analogous. This means that qX ∈ S⊙(0),
and that X ∈ R⊙(0). Since 0 ∈ Lq, it follows that X ∈ R⊙(Lq), i.e., X ∈
Post R(Lq).
t = ⊙(t1,... , tn) →∗ e (q, ⊙). The case where t = ||(t1,... , tn) →∗ e (q, ||) is similar.

Δ
There are three cases:
There exist n constants X1,... , Xn such that
t = ⊙(t1,... , tn) →∗ e ⊙(qX ,... , qX
Δ



)→e (q, ⊙).

Δ	1	n	Δ
In this case, every ti is necessarily equal to the constant Xi. Then, the Δ-rule
⊙(Reg ) → (q, ⊙), where qX1 ··· qXn ∈ Reg is either a β1 or a β2 rule. Let us consider the case where it is a β1-rule, the other case being similar. Let then X
be a constant such that X →∗ Δ q and Reg = S⊙(qX). Since qX ··· qX ∈ Reg ,
n
this means as previously that ⊙(X1,... , Xn) ∈ R⊙(X), i.e., since X ∈ Lq that
⊙(t1,... , tn)= ⊙(X1,... , Xn) ∈ Post R(Lq).
There exist k constants X1,... , Xk and n − k states qk+1,... , qn in Q such that
t = ⊙(t1,... , tn) →∗ e ⊙(qX ,... , qX , qk+1,... , qn)→e (q, ⊙).
Δ	1	k	Δ
In this case, for every i, 1 ≤ i ≤ k, ti is necessarily equal to the con-
stant Xi, and for every i, k + 1 ≤ i ≤ n, ti ∈ Lqi .	Then, the Δ˜-rule
⊙(Reg ) → (q, ⊙), where qX1 ··· qXk qk+1 ··· qn ∈ Reg is necessarily a β2 rule.
Let then ⊙(Reg ') → q be a rule in Δ such that Reg = S⊙(σ(Reg ')). Since
qX1 ··· qXk qk+1 ··· qn ∈ Reg , it follows that there exists qY1 ··· qYmqk+1 ··· qn ∈

σ(Reg ') such that qX1
··· qXk qk+1 ··· qn ∈ S⊙(qY1
··· qYm
qk+1 ··· qn), and there-

fore that qX1 ··· qXk  ∈ S⊙(qY1 ··· qYm ), and hence that ⊙(X1,... , Xk) ∈
R⊙  ⊙ (Y1,... , Ym) ,  and  that  ⊙(X1,... , Xk, tk+1,... , tn)	∈	R⊙  ⊙

Since	qY ··· qY  qk+1 ··· qn	∈	σ(Reg '),	we	get	that
⊙(Y1,... , Ym, tk+1,... , tn)  ∈  Lq, and since ⊙(X1,... , Xk, tk+1,... , tn)  ∈
R⊙ ⊙ (Y1,... , Ym, tk+1,... , tn) , it follows that ⊙(X1,... , Xk, tk+1,... , tn) ∈
Post R(Lq). Therefore
t = ⊙(t1,... , tn)= ⊙(X1,... , Xk, tk+1,... , tn) ∈ Post R(Lq)
There exist n states q1,... , qn where at least one qi is of the form (p, ||) or (p, −) where
t = ⊙(t1,... , tn) →∗ e ⊙(q1,... , qn) →e (q, ⊙)
Δ	Δ
In this case, the last rule that is applied during the derivation is necessarily a β3- rule. Then, β3 implies that for every i,2 ≤ i ≤ n, qi ∈ Q, and that it is the state q1 that is of the form (p1, ||) (the case where it is of the form (p1, −) is similar). More precisely, it implies that there exist a rule ⊙(Reg ) → q in Δ and a rule
⊙(Reg ') → (q, ⊙) in Δ˜ such that p1q2 ··· qn ∈ Reg and (p1, ||)q2 ··· qn ∈ Reg '.

By structural induction, it follows that t1 ∈ Post R(Lp1 ). Let then t'
∈ Lp1 be

1
'	'

such that t1 ∈ Post R(t1). It follows that ⊙(t1,... , tn) ∈ Post R
and since for i,2 ≤ i ≤ n, ti ∈ Lqi we have:
⊙(t' ,... , tn) →∗ Δ ⊙(p1, q2,... , qn)→Δq
It follows then that t = ⊙(t1,... , tn) ∈ Post R(Lq).
⊙ (t1,... , tn) ,


Therefore, we have:
Theorem 4.2 For every canonic PRS R and every CH-automaton A, we have Post R L(A) = L(A').
As PreR(L)= Post R−1 (L), the previous construction can also be used to com- pute 1-step backward reachability sets.

Computing reachability sets for PAD and wPAD
In this section, we solve the problem of computing both reachability sets and 1- step reachability sets for PAD and wPAD systems. Computing reachability sets is difficult for PRS in general. One of the reasons is that already the reachability sets of Petri nets are not semilinear. In [2] we show that the reachability sets of a given canonic PRS system R can be effectively computed provided the underlying multiset rewrite system R  is effectively semilinear. This is, for example, the case of canonic PAD systems due to the result of [6] concerning context-free multiset rewrite systems (BPP processes).
Theorem 5.1 ([2]) Let A be a CH-automaton recognizing a set of process terms and R be a canonic PAD. Then the sets Post ∗ (L(A)) and Pre∗ (L(A)) are com-
R	R
putable and effectively representable by CH-automata.

Using this theorem and the results of the previous section, we get the following.

Theorem 5.2 For every PAD R and every CH-automaton A,	the sets Post R(L(A)), PreR(L(A)), Post ∗ (L(A)), and Pre∗ (L(A)) are computable and ef-
R	R
fectively representable by CH-automata.
Proof. Theorem 2.1 implies that for every PAD R and every set of terms L, there exists a canonic PAD R' and a finite term substitution h such that Post ∗ (L) = h(Post ∗ ' (h−1(L))) and Post R(L)= h(Post R'' (h−1(L))), where R'' is the set R' re- stricted to rules labelled with actions of Act (R). Hence, CH-automata representing the sets Post ∗ (L(A)) and Post R(L(A)) are constructible due to closure proper- ties of CH-automata and Theorems 5.1 and 4.2. The proof for Pre∗ (L(A)) and PreR(L(A)) is analogous.	 
Now we show that the previous theorem holds for wPAD as well. Recall that states of wPAD are pairs pt of a control state p and a term t. The sets of such states can be represented by CHA-mappings.
Definition 5.3 Let R be a wPRS. A CHA-mapping Λ is a mapping assigning to each control state p ∈ M (R) a CH-automaton Λ(p). A CHA-mapping Λ represents the set of states L(Λ) = {pt | p ∈ M (R),t ∈ L(Λ(p))}.
Theorem 5.4 For every wPAD R and every CHA-mapping Λ, the sets Post R(L(Λ)), PreR(L(Λ)), Post ∗ (L(Λ)), and Pre∗ (L(Λ)) are computable and ef-
R	R
fectively representable by CHA-mappings.
Proof. Let R be a wPAD. For each pair of control states p, q ∈ M (R) we set
a	a
Rp,q = {t1 ‹→ t2 | pt1 ‹→ qt2 is a rule of R}. Note that each Rp,q is a PAD system.
CHA-mapping Λ1 representing Post R(L(Λ)) is defined as follows. For each q ∈
M (R), Λ1(q) is an CH-automaton satisfying

L(Λ1(q)) =	 
p∈M (R)
Post Rp,q L(Λ(p)) .

CHA-mapping Λ2 representing Post ∗ (L(Λ)) is defined inductively with respect to ordering < on set M (R) of control states.	For every minimal element r of
M (R), Λ2(r) is a CH-automaton satisfying L(Λ2(r)) = Post ∗	 L(Λ(r)) .  For
non-minimal element q of M (R), Λ2(q) is a CH-automaton satisfying

L(Λ2(q)) = Post ∗
 L(Λ(q)) ∪  Post Rp,q
p<q
 L(Λ2(p))  .

CHA-mappings Λ1, Λ2 are constructible due to Theorem 5.2 and the fact that CH- automata are closed under union. The proof for PreR(L(Λ)) and Pre∗ (L(Λ)) is analogous.	 
As mentioned in [2], the generic algorithm presented there can employ known algorithms computing semilinear overapproximations of reachability sets for Petri

nets in order to compute overapproximations of reachability sets for general canonic PRS systems. If we use this approximative algorithm for canonic PRS instead of exact algorithm for canonic PAD system in Theorems 5.2 and 5.4, we get an algo- rithm computing overapproximations of reachability sets for general wPRS systems. Note that 1-step reachability sets for wPRS systems can still be computed precisely as Theorems 5.2 and 5.4 hold even for (w)PRS if we restrict our attention only to 1-step reachability sets.

Model checking of wPAD against EF logic
This section presents a straightforward application of Theorem 5.4. We consider a variant of EF logic combining both action-based and state-based approaches. We show that the global model checking problem of wPAD systems against this logic is decidable.
Formulae of EF logic are defined as
ϕ ::= A | ¬ϕ | ϕ1 ∧ ϕ2 | ⟨a⟩ϕ | EFϕ,
where A ranges over set AP of atomic propositions and a ranges over Act . Here, formulae are interpreted over states of wPRS systems. For each atomic proposition A, let V (A) denotes its valuation, i.e. the set of states where A holds. We define when a state pt of a given wPRS system R satisﬁes a formula ϕ, written R, pt |= ϕ, by induction on the structure of ϕ.

Theorem 6.1 For every wPAD system R and every EF formula ϕ over atomic propositions with valuations given by CHA-mappings, the set of states of R satisfying ϕ is computable and effectively representable by a CHA-mapping.
Proof. The theorem follows directly from Theorem 5.4 and closure properties of CH-automata. Here we mention just the induction step corresponding to operator
⟨a⟩. Let ϕ = ⟨a⟩ψ and let CHA-mapping Λ recognizes all states satisfying ψ. We construct a CHA-mapping Λ', which recognizes all states where ϕ holds, to satisfy L(Λ')= PreRa  L(Λ) , where Ra is the set R restricted to rules with label a. Such a CHA-mapping Λ' is constructible due to Theorem 5.4.	 
This theorem gives a positive answer to open questions formulated in [14], namely whether model checking of wBPP, wPA, and wPAD systems against action- based EF logic is decidable. Our result is tight as model checking of state extended

PAD (defined as wPAD where rules may not respect the ordering on control states) against EF logic is already undecidable. In fact, the problem is undecidable even for the subclass of state extended PAD called multiset automata and EF formulae with the only atomic proposition true (this can be proved by the arguments of [6] showing that model checking of Petri nets against EF logic is undecidable).

Bounded reachability analysis of synchronized PAD
First we give a precise definition of synchronized (α, β)-PRS. Let Act be a disjoint union Async ∪Sync ∪{τ }. We assume that to each a ∈ Sync corresponds a co-action a˜ ∈ Sync such that a˜ = a. Intuitively, Sync is the set of all synchronization actions,
i.e. actions which must be performed simultaneously with their corresponding co- actions. A synchronized (α, β)-PRS R is defined as standard (α, β)-PRS. Instead of ’synchronized (α, β)-PRS’ we use shorter names like SPAD, SPRS, etc.
Let → be the least transition relation over terms satisfying the inference rules


b	b	b
a  '	a˜ '

(t1 ‹→ t2) ∈ R	 t1 → t2 		t1 → t2	
t1 → t1	t2 → t2

b
t1 → t2
b
t1 t → t2 t
b
t1 ⊙ t → t2 ⊙ t
t1  t2 → '  '

where a ranges over Sync and b ranges over Act . An transition step induced by the last rule is called synchronization. The transition relation →R is then defined as the restriction of → to transitions labelled with actions of Act z Sync.
Now we present a technique for computing underapproximations of these sets in style of [18]. Given a synchronized (α, β)-PRS R and n > 0, we construct an (α, β)-wPRS Rn which mimics (prefixes of) all behaviors of R with at most n synchronizations. The system Rn uses control states 0 < 1 < ... < 3n. For every
b
rewrite rule r = (t1 ‹→ t2) of R, let Zr /∈ Const (R) be a fresh process constant. If
b
b ∈ Async ∪ {τ } then we add to Rn the rule (3i)t1 ‹→ (3i)t2 for every 0 ≤ i ≤ n.
τ '	τ '
b = a ∈ Sync the we add to Rn rules (3i)t1 ‹→ (3i+1)Zr and (3i+2)Zr ‹→ (3i+3)t2
for every 0 ≤ i < n.
τ
b = a˜ ∈ Sync the we add to Rn rule (3i + 1)t1 ‹→ (3i + 2)t2 for every 0 ≤ i < n.
Intuitively, every synchronization via actions a, a˜ is replaced by a sequence of actions τ 'ττ '. The changes of control states prevents interleaving of this sequence with other actions. Moreover, use of fresh process constants ensures that the rules under a and a˜ are applied on different parts of the current term.
Let R be an SPAD and L be a set of states represented by a CH-automaton. Theorem 5.4 says that we can construct a CHA-mapping Λ such that L(Λ) =

Post ∗
({0}× L). Obviously, the set 
0≤i≤n
L(Λ(3i)) is an underapproximation of

Post ∗ (L). Further, with increasing n, we can compute better approximations of this set. Moreover, if for n and n + 1 the computed underapproximations are the same, we know that we have exactly the set Post ∗ (L).
The same technique can be employed to underapproximate the set Pre∗ (L). The

sets Post R(L) and PreR(L) can be computed precisely using a similar approach.

Conclusion
We have presented an automata-based symbolic reachability analysis algorithm for the class of wPAD systems. This algorithm is based on the use of a class of un- ranked tree automata (called CH-automata) which can recognize sets of configura- tions closed under the algebraic properties of the sequential and parallel composi- tion. We used the reachability analysis algorithm, together with one-step successor computation (and boolean operations on CH-automata), in order to define an al- gorithm for the global model checking of wPAD against the EF logic with regular atomic predicates. These results generalize those proved in [2] concerning the class of (canonic) PAD systems, which is a strict subclass of wPAD, pushing the known decidability limit of EF model checking further up in the (se/w)PRS hierarchy, and answering open questions left in [14].
We have also shown that the symbolic reachability algorithm for wPAD can be used to compute under approximations of the set of reachable configurations of syn- chronized PAD (SPAD), a (Turing) powerful model introduced in [21] for modeling multithreaded programs (with dynamic creation of communicating processes and procedure calls).

References
Bouajjani, A. and T. Touili, Reachability Analysis of Process Rewrite Systems, in: Proc. of FSTTCS 2003, LNCS 2914 (2003), pp. 74–87.
Bouajjani, A. and T. Touili, On computing reachability sets of process rewrite systems, in: Proceedings of RTA 2005, LNCS 3467 (2005), pp. 484–499.
Bruggemann-Klein, A., M. Murata and D. Wood, Regular tree and regular hedge languages over unranked alphabets, Research report (2001).
Colcombet, T., Rewriting in the partial algebra of typed terms modulo ac, in: Proceedings of INFINITY’02, ENTCS 68 (2002).
Comon, H., M. Dauchet, R. Gilleron, F. Jacquemard, D. Lugiez, S. Tison and M. Tommasi, Tree automata techniques and applications, Available on: http://www.grappa.univ-lille3.fr/tata (1997).
Esparza, J., Decidability of model checking for infinite-state concurrent systems, Acta Informatica 34
(1997), pp. 85–107.
Esparza, J., Grammars as processes, in: Formal and Natural Computing, LNCS 2300 (2002).
Esparza, J. and J. Knoop, An automata-theoretic approach to interprocedural dataflow analysis, in:
Proceedings of FOSSACS’99, LNCS 1578, 1999, pp. 14–30.
Esparza, J. and A. Podelski, Efficient algorithms for pre∗ and post∗ on interprocedural parallel flow graphs, in: Proceedings of the 27th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (POLP’00) (2000), pp. 1–11.
Harrison, M. A., “Introduction to Formal Language Theory,” Addison-Wesley, 1978.
Janˇcar, P., A. Kuˇcera and R. Mayr, Deciding bisimulation-like equivalences with finite-state processes, Theor. Comput. Sci. 258 (2001), pp. 409–433.
Kˇret´ınsky´, M., V. Rˇeha´k and J. Strejˇcek, Extended process rewrite systems: Expressiveness and reachability, in: Proceedings of CONCUR’04, LNCS 3170 (2004), pp. 355–370.

Kˇret´ınsky´, M., V. Rˇeha´k and J. Strejˇcek, On extensions of process rewrite systems: Rewrite systems with weak finite-state unit, in: Proceedings of INFINITY’03, ENTCS 98 (2004), pp. 75–88.
Kˇret´ınsky´, M., V. Rˇeha´k and J. Strejˇcek, Reachability of Hennessy-Milner properties for weakly extended PRS, in: Proceedings of FSTTCS 2005, LNCS 3821 (2005), pp. 213–224.
Lugiez, D., Counting and equality constraints for multitree automata, in: Proceedings of FoSSaCS 2003, LNCS 2620 (2003), pp. 328–342.
Lugiez, D. and P. Schnoebelen, The regular viewpoint on PA-processes, in: Proc. of CONCUR’98, LNCS
1466 (1998), pp. 50–66.
Mayr, R., Process rewrite systems, Information and Computation 156 (2000), pp. 264–286.
Qadeer, S. and J. Rehof, Context-bounded model checking of concurrent software, in: Proceedings of TACAS’2005, LNCS 3440 (2005), pp. 93–107.
Seidl, H., T. Schwentick and A. Muscholl, Numerical document queries, in: Proceedings of PODS’03
(2003), pp. 155–166.
Touili, T., “Analyse symbolique de syst`emes infinis bas´ee sur les automates: Application `a la v´erification de syst`emes param´etr´es et dynamiques,” Ph.D. thesis, University of Paris 7 (2003).
Touili, T., Dealing with communication for dynamic multithreaded recursive programs, in: Proceedings of VISSAS’05, 2005.
