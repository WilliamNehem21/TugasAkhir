

Electronic Notes in Theoretical Computer Science 255 (2009) 159–176
www.elsevier.com/locate/entcs

Analyzing Chor Specifications by Translation into FSP
Nima Roohi1
Department of Computer Science Sharif University of Technology Tehran, Iran
Gwen Salau¨n2
Department of Computer Science University of Malaga
M´alaga, Spain
Seyyed Hassan Mirian3
Department of Computer Science Sharif University of Technology Tehran, Iran

Abstract
A choreography specifies activities and interactions among a set of services from a global point of view. From this specification, local implementations or peers can be automatically generated. Generation of peers that precisely implement the choreography specification is not always possible: this problem is known as realizability. This paper presents an encoding of the Chor choreography calculus into the FSP process algebra. This encoding allows to: (i) validate and verify Chor specifications using the FSP toolbox (LTSA),
(ii) generate peer protocols from its choreography specified in Chor, (iii) test for realizability of the Chor specification, and (iv) generate Java code from FSP for rapid prototyping purposes. Our proposal is supported and completely automated by a prototype tool we have implemented.
Keywords: Choreography, WS-CDL, Chor, FSP


Introduction
Choreography description languages aim at specifying from a global point of view in- teractions among a set of services involved in a new application. Several formalisms

1 Email: roohi@ce.sharif.edu
2 Email: salaun@lcc.uma.es
3 Email: hmirian@sina.sharif.edu

1571-0661© 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.10.030

have already been proposed to specify choreographies: WS-CDL, collaboration dia- grams, BPMN, SRML, etc. From such specifications, local implementations, namely peers, can be automatically generated. However, generation of peers which exactly implement the choreography specification is not always possible: this problem is known as realizability.
Recent works on this topic [7,12,4,2] advocate techniques to check realizability of a choreography, or define well-formedness rules to be applied while writing the choreography specification in order to ensure its realizability. However, most of these approaches focus on theoretical aspects and lack of tool support. In addition, these works mainly focus on the realizability issue but do not allow to check choreographies (in order to verify that the overall goal of the composition is achieved) or generate code from such specifications.
In this paper, we use the Chor calculus [12] as choreography language because it is an abstract model of WS-CDL coming with a formal syntax and semantics (not the case of WS-CDL). We propose an encoding from Chor into the FSP process algebra [9]. We chose FSP because it relies on a simple language yet expressive enough to encode Chor operators. Moreover, FSP is equipped with the LTSA toolbox which provides efficient tools for state space exploration and verification. This encoding allows to: (i) validate and verify Chor specifications using the LTSA toolbox, (ii) generate peer protocols from its choreography specified in Chor, (iii) test for realizability of the Chor specification, and (iv) generate Java code from FSP for rapid prototyping purposes. Our proposal is supported and completely automated by a prototype tool we have implemented.
The rest of this paper is organized as follows: Section 2 introduces the Chor and FSP calculi. Section 3 presents the encoding of Chor into FSP. Section 4 extends the FSP encoding to take the peer generation into account, and focuses on the realizability issue. Section 5 sketches the prototype tool that supports our approach and the Java code generation. Section 6 compares our proposal to related works, and Section 7 ends the paper with some concluding remarks.
Preliminaries: Chor and FSP
Chor
Chor [12] is a simple process language, and a simplified model of WS-CDL, for describing peers from a global point of view. From this global specification, behav- ioral specifications of peers can be generated by projection. In this section, we will overview both the Chor language (global view) and the Peer language (local view) introduced in [12]. First of all, let us define the trace operators which are used throughout this paper.
Definition 2.1 Trace operators which are used in this paper are defined as follows (t, t1, and t2 are arbitrary traces, T , T1, and T2 are arbitrary sets of traces, S is a set of actions, R is a partial function 4 of type Action → Action, and domR stands

4 In general, R can be a partial relation, but we only use it when it is a partial one-to-one function.

for the domain of R):
#t : length of t
t0	: head of t (first action of t)
t'	: tail of t (trace obtained from t by removing its head)
t[i] : i-th element of t (0 ≤ i < #t)
s(t) : set of actions in t ({t[i]|∀0 ≤ i < #t})

t1 concatenated with t2
(trace with length #t1 + #t2):
t renamed by R:


[ ]	if
⎧⎪⎨ t 0	'
if t = ⟨⟩
0

1	2	^
t2[i − #t1] else
^ ⎪⎩
⟨R(t0)⟩ - t'/R else
∈/ domR

t1 interleaved with t2:	t1 synchronized with t2 on S:
{t1}	if t2 = ⟨⟩∧
s(t ) ∩ S = ∅

⎪ {t2}
1
t1 = ⟨⟩∧

⎧⎪ {t1}	if t2 = ⟨⟩
s(t2) ∩ S = ∅
⎪	S

⎨ {t2}	if t1 = ⟨⟩	S	⎨ t0 - (t' d|at' )	if t0 = t0

1	2 ^
t0 - (t'
⎩
da t2) ∪
else
1	2 ^ ⎪
∧t0 ∈ S

t0 - (t1 da t' )
⎪ 0	'	0	0

t	2	1	2

S
⎪ 0	(	' )
t0∈/ S ∨

⎪⎪⎩ 2
1	2	t0, t0∈/ S 



⎧⎨ t'

if t = ⟨⟩
0
⎧⎨ t'

if t = ⟨⟩
0

^ ⎩ ⟨t0⟩ - t' f S else	^ ⎩ ⟨t0⟩ - t'\S else

t(i)
⟨⟩	if i = 0 
^	t - t(i−1) else
T (i)
{⟨⟩}	if i = 0 
T - T (i−1) else

T renamed by R:	T restricted to S:	T filtered by S:
T/R	= {t/R|t ∈ T}	T f S = {t f S|t ∈ T}	T\S = {t\S|t ∈ T}
t1 concat^enated with T2:	Closure^ of t:	Closu^re of T :

t - T  =
{t1} - T2	t∗
^  i≥0 t(i)	T∗
^  i≥0 T (i)

T1 - T
= {t|∃t1 ∈ T1 ∧ ∃t2 ∈ T2
. t = t1 - t2}



T1 da T
= {t|∃t1
∈ T1
∧ ∃t2
∈ T2
. t ∈ t1
da t2}



T1d|aT2 = {t|∃t

1 ∈ T1 ∧ ∃t2 ∈ T2 . t ∈ t1d|at2}

Table 1 shows the syntax and semantics of Chor (C, C1 and C2 are arbitrary Chor specifications). It uses weak traces (τ actions are hidden) for specifying its

Therefore R−1 is also a partial function, and can be used in the defined operators.

semantics (where [C ] stands for the weak trace set of C). The reader interested in more details on the language may refer to [12].
Table 1
Syntax & Semantics of Chor

skip	means do nothing, its trace set is equal to {⟨⟩}
ai	is an arbitrary local activity performed by peer i, and its trace set is {⟨ai⟩}
c[i,j]	is a communication between two peers i (sender) and j (re-
ceiver) through channel c, its trace set is {⟨c[i,j]⟩} C1; C2	means first C1 and then C2, [[C1; C2]] = [[C1]] - [[C2]] C1 H C2 means either C1 or C2, [[C1 H C2]] = [[C1]] ∪ [[C2]]
C1  C2	means C1 and C2 run concurrently, [C1  C2]] = [[C1]] da [[C2]]
∗C	means execute C an arbitrary number of times, [∗C]] = [[C]]∗

The loop operator “∗” has the highest priority among the others. After that, priority of the sequential composition operator “;” is higher than the other operators, as an example, ∗C1HC2; C3 is not ambiguous. Priority of parallel “||” and choice “H” operators is equal, as an example, C1  ∗C2HC3 = (C1  (∗C2))HC3 (left associativity).
Chor is implemented by the coordination of a set of independent processes. The Peer language is a simple calculus for describing these processes. In this language, ϵ
is an empty process which means do nothing, and for an arbitrary trace t if P =⇒t  ϵ
we have t ∈ [[P ] (we use † to denote deadlock). Table 2 gives the syntax and semantics of the Peer language.
In Table 2, P , P1 and P2 are Peer specifications.  The Peer language mainly
differs from Chor by the description of interactions. Peer specifies them from a local point of view. Therefore, at the Peer level, an interaction activity is either an emission or a reception, and peers interact together by handshake communication (same channels, opposite directions).
Using rules defined in Table 2, trace sets of Peer processes are obtained as follows:

P −σ→ P'


P =σ⇒ P'
P −σ→ P'	P' =σ'
P σ=-σ' P ''
P ''

Last, operator / : Peer × Activity → Peer returns the process obtained af- ter executing the input activity, and function fst (abbreviation for ﬁrst) : Peer → P(Activity), in which P(Activity) is the power set of all possible activities, com- putes activities of a Peer process which can be executed first. Formal definitions of operator “/” and function fst are as follows (⊥ denotes an undefined process):
fst(ϵ) = fst(skip) = fst(P H P ) = fst(∗P )=∅	fst(α)={α}
1	2	^	^
fst(P ; P )=fst(P )	fst	)=fst(P ) ∪ fst(P )
^
skip/α=^ ⊥	α/α'=^ ϵ	if α = α'
(P ; P )/α=P /α; P	(P H P )/α = (∗P )/α=⊥
1   2	^ 1	 2	1	2	^
1	2	^	1	2	2

Table 2
Syntax & Semantics of Peer


Skip: skip −⟨→⟩
ϵ  Local: a ⟨a⟩ ϵ
P1 −σ→ P'	⟨⟩

Sequential:
σ	1	ϵ; P −→ P

P1; P2 −→ P1' ; P2
Choice:	P1 H P2 −⟨→⟩  P1	P1 H P2 −⟨→⟩  P2

Parallel:	ϵ  ϵ −⟨→⟩
P1 −σ→ P'
ϵ
c! ∈ fst(P1)	c? ∈ fst(P2)

P1  P2 −σ→ P'  P2 P2 −σ→ P'

1   2 −→ P1/c!  P2/c? c? ∈ fst(P1)	c! ∈ fst(P2)

P1  P2 −σ→ P1  P'
1  2 −→ P1/c?  P2/c!

Loop: ∗P −⟨→⟩
skip	∗P −⟨→⟩
P ; ∗P


Example 2.2 We will use throughout this paper a metal stock market as a running example. There are three peers in our example. First, peer Broker selects one of two metals, namely iron and steel, then look at the market as many times as needed until a sale on the selected metal becomes available. Broker sends his/her bid on the selected metal to the second peer (Market) of our example. After receiving a bid, Market performs the following two tasks concurrently: saving the bid in its own database, and checking to see if this bid is better than the best current one or not. Then, Market sends the result of this check and the name of the broker to the announcement Board (third peer of our example). If this bid is the best so far, Board will change the current winner and notifies the broker. Otherwise, Board does nothing (skip). In the Chor specification below, bk, mk, bd respectively stand for Broker, Market, and Board:

Stock = (ironbk H steelbk); lookbk; ∗lookbk; bid[bk,mk]; (savemk||checkmk);
result[mk,bd]; (changebd; notify[bd,bk] H skip)
FSP
FSP is a process calculus that takes inspiration in Milner’s Calculus of Communicat- ing Systems (1980) and in Hoare’s Communicating Sequential Processes (1985), as explained by Magee and Kramer in [9]. FSP was originally designed for distributed software architecture specification, and distinguishes sequential and composite pro- cesses. Table 3 introduces FSP operators which are used in the rest of this paper (x and y are actions, and P and Q are FSP processes).
In the following lemma we show how trace sets of the FSP operators presented in Table 3 can be computed (this lemma will be used later on in this paper). The

Table 3
FSP Operators and Informal Semantics

(x−>P )	describes a process that initially executes action x and then behaves as P .
(P ; Q)	describes a process that first behaves as P , and then (after
completion of P) behaves as Q.
(x−>P |y−>Q)	describes a process that either executes action x and then
P , or action y and then Q.
(P ||Q)	represents the concurrent execution of P and Q. This op- erator synchronizes shared actions of P and Q.
x : P	prefixes each label in the alphabet of P with x.

P/{new1/old1,
··· , newn/oldn}
renames action labels. Each old label in P is replaced by
the new one.

P\{x1, ··· , xn}  removes action names x1, ··· , xn from the alphabet of P
and makes these actions “silent”. These silent actions are labeled by τ . Silent actions in different processes are not shared.
P @{x1, ··· , xn}  hides all actions in the alphabet of P which do not belong
	to the set {x1, ·· · , xn}.	
formal semantics of these operators are defined using LTS and can be found in [9].
Lemma 2.3 (Trace Set of FSP) Traces for each FSP operator are obtained as follows, where P, P1, ··· , Pn are FSP process identiﬁers, αP stands for the alphabet of P, αPi···j stands for αPi ∪· · ·∪ αPj, and END is the simplest FSP process with no transition and one start and ﬁnal state:
[[EN D]]	= {⟨⟩}
[[P1; ··· ; Pn]]	= [[P1]] - ··· - [[Pn]]
[[ba1−>P1|··· |ban−>Pn]] = (ba1 - [[P1]]) ∪· · · ∪ (ban - [[Pn]]) [[p1 : P1 ···pn : Pn]] =
[[P1]]/{(x, p1.x)|x ∈ αP1} da ··· da [[Pn]]/{(x, pn.x)|x ∈ αPn}


αP1∩αP2···n 
αP2∩αP3···n 
αPn−1∩αPn

[[P1  ···Pn]]	= [[P1]]
[[(P ; END)/R]]	= [P ]]/R
[[(P ; END)\S]]	= [P ]]\S
[[(P ; END)@S]]	= [[P ]] f S
d|a
[[P2]]
d|a
··· 
d|a
[[Pn]]

Translating Chor into FSP
In this section we introduce our encoding of Chor into FSP, which allows to use existing tool support for FSP. Thus, the resulting FSP specification can be compiled into LTS (Labeled Transition System), and checked using LTSA (animation, LTL model-checking). This encoding, will also be used to generate peers and check for realizability (see Section 4).
First of all, activities skip are hidden in Chor traces, so we use τ for encoding
skip activities into FSP 5 . Each local or communication activity of Chor is encoded

5 It is possible to first remove skip activities from a Chor specification and then perform the encoding. It is also possible to prove that for every Chor specification C there exists Chor specifications C' and C'' in

using an FSP process with a single action corresponding to this activity.
The Chor sequential operator is encoded using the FSP sequential operator. As regards the choice operator, we prefix each operand by a τ action, therefore similarly to Chor and Peer languages, selecting a choice operand is performed non- deterministically. As an example, if the first action in one operand of a choice operator is c[i,j], it is also possible c[i,j] be in the alphabet of another FSP process. We will see in Section 4 that these FSP processes may be composed using the FSP parallel operator (without any renaming). Selection of a choice operand has to be performed in an independent way. Hence, deadlock can occur if one FSP process chooses to perform the operand with c[i,j] as action and the other does not.
As far as the parallel operator is concerned, the translation is more complicated. In FSP, actions which are in alphabets of both operands can only evolve through synchronizations, but the parallel operator of Chor does not synchronize activities of its operands (interleaving). Consequently, we first prefix operands of each par- allel operator with a unique value (e.g., p1:P1  p2:P2 instead of P1  P2), thus no synchronization occurs. Then, we use the renaming operator of FSP to replace these new action names with their original values. To perform this final renaming while encoding the parallel operator, we need to figure out all the non-skip basic activities for each operand. These activities are computed using Definition 3.1.
Definition 3.1 [Included Basic Activities] We define ac, a function of type Chor →
P(Activity), as follows:
ac(skip) = {} ac(ai) = {a } ac(c[i,j]) = {c[i,j]}
	^	^	i	^
1	n  ^	1	n
The loop operator (∗C) is specified in FSP using a non-deterministic choice between performing skip, or performing C and then a recursive call to the FSP process that encodes the loop operator.
Definition 3.2 [Chor into FSP] Encoding a Chor specification C into FSP is achieved using function c2f : Chor → FSPdescription, as follows:
c2f(skip) = SKIP = (skip−>EN D)\{skip}.
c2f(ai)	c2fpi(ai) = (a i−>EN D).
^
c2f(C1; C2^)	=c2f (C ; C ) = c2f (C ); SKIP ; c2f (C ); END.
c2f(C1 H C2) =c2fpi(C1 H C2) = (z−>c2fpi(C1); END|z−>c2fpi(C2); END)\{z}.
assuming z is neither in αc2fpi(C1) nor in αc2fpi(C2).

c2f(C1 
C2)
(C^
C ) = (p1 : c2f
(C ) p2 : c2f
(C )).

c2fpi(C1 C2) = T.c2fpi(C1  C2); SKIP ; END/
{ba1/p1.ba1|ba1 ∈ ac(C1)}∪ {ba2/p2.ba2|ba2 ∈ ac(C2)}.
c2f(∗C)	=
c2fpi(∗C) = (z−>SKIP ; END|z−>c2fpi(C); SKIP ; c2fpi(∗C))\{z}.
assuming z is not in αc2fpi(C).
We added SKIP between operands of each sequential composition because of

which [C]]= [[C' ] and C' = skip, C' = skip H C'', or C' = C'' (C'' has no skip in its specification).

the rule ϵ; P −⟨→⟩  P in Table 2. We also put z−>SKIP ; END instead of z−>EN D

for encoding the loop operator because of the rules ∗P −⟨→⟩
skip and skip −⟨→⟩
ϵ in

that table. Each of these rules has a −⟨→⟩
transition, and we encode it using the

additional SKIP process. These additional SKIP processes are useful to preserve the semantics of peers while encoding them into FSP (see Theorem 4.5).
FSP does not allow actions to have subscript or superscript. Therefore, we respectively translate ai and c[i,j] into a i and c i j.
c2fpi is a one-to-one function of type Chor ~ ProcessIdentifier generating fresh identifiers (the same ones for identical Chor specifications) as output, which obey naming rules 6 of FSP process identifiers. T.c2fpi returns a process identifier which is obtained by prefixing the result of c2fpi by T .
For all C and C' such that c2f(C) has a process identifier c2fpi(C') in its spec- ification, the result of c2f(C') must be included in the result of c2f(C), because whenever we use one FSP identifier in our specification, we must include the speci- fication of that process in our final specification.
In the following theorem we prove that the Chor semantics is preserved by the defined translation. Since the Chor semantics is defined using weak trace sets, we show that our encoding preserves the semantics of this language using Theorem 3.3.
Theorem 3.3 (Weak Trace Equivalence between Chor and FSP)
Given a Chor speciﬁcation C, and the corresponding FSP process c2fpi(C), two speciﬁcations are weak trace equivalent:
[[C]] = [[c2fpi(C)]]

Proof. We prove this theorem using Lemma 2.3 and induction on the structure of operators in C. Basis of the induction (C = skip, C = ai, or C = c[i,j]) holds vacuously. Also for the cases C is equal to C1; C2 and C1 H C2 one can check that [c2fpi(C)]] is equal to [C1]] - [[C2]] and [[C1]] ∪ [[C2]], respectively. When C =
C1  C2 then [T.c2fpi(C)]] = ([[c2fpi(C1)]]/R1) da ([[c2fpi(C2)]]/R2) and [c2fpi(C)]] =
[[T.c2fpi(C)]]/R, where R1, R2, and R are defined as follows:
R1 = {(x, p1.x)|x ∈ αc2fpi(C1)}
R2 = {(x, p2.x)|x ∈ αc2fpi(C2)}
R  = {(p1.ba1, ba1)|ba1 ∈ ac(C1)}∪ {(p2.ba2, ba2)|ba2 ∈ ac(C2)}
R renames each activity to its original value (when R1 or R2 has not been
applied). Since operator da does not impose any synchronization on traces of its
operands [c2fpi(C)]] = [[c2fpi(C1)]] da [[c2fpi(C2)]] = [[C1]] da [[C2]] = [[C]].
When C = ∗C', we have [c2fpi(C)]] = [[SKIP ]] ∪ [[c2fpi(C')]] - [[c2fpi(C)]] =
{⟨⟩} ∪ [[C']] - [[c2fpi(C)]].	One could see, ∀t ∈ [[c2fpi(C)]] . t ∈ [[C']] - ··· -
[[C']] = [[C']](i), for some i ≥ 0. Therefore, we have [c2fpi(C)]] ⊆ [[C']]∗. For the reverse direction, by induction on n, we prove that for all n ≥ 0, [c2fpi(C)]] =

0≤i≤n
[[C']](i) ∪ [[C']] - [[c2fpi(C)]]. Basis of induction is [c2fpi(C) ] = [C']](0) ∪



6 These rules are defined in Section 2 of Appendix B in [9].

[[C']] - [[c2fpi(C)]] = {⟨⟩} ∪ [[C']] - [[c2fpi(C)]], which is trivially true. Thus, as-

suming [c2fpi(C)]] = 
0≤i<n
[[C']](i) ∪ [[C']] - [[c2fpi(C)]], for all n > 0, we prove

[[c2fpi(C)]] = 
0≤i≤n
[[C']](i) ∪ [[C']] - [[c2fpi(C)]]. By substituting the right hand side

of the antecedent in the definition of [c2fpi(C)]], the consequent is proved. Hence, we have: [c2fpi(C)]] = [C']]∗ ∪ [[C']] - [[c2fpi(C)]] ⇒ [[C']]∗ ⊆ [[c2fpi(C)]]. Consequently, both [C']]∗ and [c2fpi(C)]] are subsets of each other, and hence equal.	 
Example 3.4 Let us illustrate our encoding with some of the FSP processes gen- erated for our example. In Table 4 we can see for instance how the choice operator is performed non-deterministically by prefixing the choice’s operands by z and then hiding this action. Figure 1 shows the minimized LTS, obtained by compilation with LTSA, of the generated FSP code (c2fpi(Stock)). First, Broker decides what metal (s)he wants, iron or steel. Then, (s)he looks at the market as many times as needed until a sale on the selected metal becomes available (there is a loop on state 2 in the LTS). After that, (s)he sends his/her bid to the market. Next, Market saves the price and checks it, concurrently (there are two different paths from state 4 to state 6 in the LTS). Then, Market sends the result of the performed check to the board. Finally, Board either does nothing (if the result says the bid was not good enough), or changes itself and notifies the broker (if the result says the bid was the best one so far). This LTS was run several times using LTSA animation techniques, and the system behaved as expected. Model-checking was not required here because we chose a simple example in this paper for the sake of comprehension.

Table 4
Some FSP Processes Generated for the Running Example

 Chor Specification	FSP Process Specification	
skip	SKIP = (skip−>END)\{skip}.
ironbk	Iron bk = (iron bk−>END).
lookbk	Look bk = (look bk−>END).
bid[bk,mk]	Bid bk mk = (bid bk mk−>END).
ironbk H steelbk	Ch = (z−>Iron bk; END|z−>Steel bk; END)\{z}.
∗lookbk	L = (z−>SKIP; END|z−>Look bk; SKIP; L)\{z}.
(ironbk H steelbk); lookbk S = Ch; SKIP; Look bk; END. savemk||checkmk	||TP = (p1 : Check mk||p2 : Save mk).
P = TP; SKIP; END/{check mk/p1.check mk,
save mk/p2.save mk}.


Fig. 1. Minimized LTS of the Stock Market Case Study

Peer Generation and Realizability
Peer Generation
Given a Chor specification, one can generate the specification of each Peer using natural projection. Natural projection 7 of a Chor specification to Peer P replaces each observable action with τ iff P does not perform that action.
Chor and Peer share parallel, sequential, choice, and loop operators. For these operators the natural projection first replaces each Chor operator by its equivalent in Peer, and then applies recursively to their operands. Projection of basic activities from a Chor specification C to a Peer specification P is achieved as follows:
each activity not performed by P is replaced by skip,
a local activity performed by P remains unchanged,
a communication activity involving P is replaced by a channel input activity (if P is the receiver) or a channel output activity (if P is the sender).
Generation of FSP processes for an arbitrary Chor specification is performed using function c2f, defined in Section 3. The behavior of each Peer P in the chore- ography C is generated by hiding in the corresponding FSP (c2fpi(C)) all actions to which P does not participate (Definition 4.1).
Definition 4.1 Given a Chor specification C and a Peer identifier p, the FSP process corresponding to nproj(C, p), the natural projection of the Chor specification C to the Peer p, is generated as follows (p2fpi is defined similarly to c2fpi):

p2f(C, P )=p2f
pi(C, p) = c2f
pi(C)@{b|b is an activity of p}.

As specified in [12] for projecting Chor to peers the name of each Peer is taken as a part of each activity name (for instance, here we add it as suffix). Therefore, local activities of different peers are pair-wise different, and peers use exclusive channels for communicating with each other. Thus, each channel synchronizes activities of exactly two peers. Hence, in p2fpi(C, 1)  ···p2fpi(C, n), only actions which represent communication activities are synchronized with each other, and each of these actions belongs to alphabets of exactly two FSP processes of the parallel operator’s operands.
Similarly to Section 3, to prove that our encoding method preserves the se- mantics of the Peer language, we need some preliminary definitions and a lemma. Instead of proving that our encoding method preserves trace semantics, we prove that the parallel composition of the encoded peers is strongly bisimilar to the paral- lel composition of the input peers, because it is a stronger result, yet easier to prove. The semantics of an FSP process F is defined using LTS (lts(F ) 8 ), therefore in the following definitions, lemma, and theorem we use LTS instead of FSP (for FSP specifications we do not have a definition for the transition relation (“−a→”), but

7 The reader may refer to [12] for the formal definition of natural projection.
8 The LTS semantics of FSP is defined in [9]. In this paper, we use LTSA to compute LTSs of different FSP specifications.

we need this relation in the bisimulation relation definition). A strong bisimulation relation between Peer and LTS is defined as follows:
Definition 4.2 [Strong bisimulation relation (∼) between Peer and LTS] We set ϵ ∼ lts(END), and † ∼ lts(STOP ) 9 . For any other Peer specification P and LTS L, we have P ∼ L if and only if the following two conditions hold 10 :

∀b . P −→
∀b . L −→
P' ⇒ ∃L' . L −→b
L' ⇒ ∃P ' . P −→b
L' ∧ P' ∼ L'
P' ∧ P' ∼ L'

Communication activities can occur in peers only when they are composed with their complementary activities in parallel. For example, there is no transition rela-
tion defined for c!, but if it is composed with c? in parallel, we will have c! c? −→c  ϵ ϵ.
Hence, in order to compare behaviors of an individual Peer specification with its corresponding FSP process, we need another definition.
Definition 4.3 [Similar Behavior (∼') between Peer and LTS] We define the similar behavior relation between Peer P and LTS L as ϵ ∼' lts(END), † ∼' lts(STOP ), and for all other peers which is neither ϵ nor † this relation is defined as follows:
∀P, L . P ∼' L ⇔
(∀c . c! ∈ fst(P ) ⇒ L −→c  L' ∧ P/c! ∼' L')∧
(∀c . c? ∈ fst(P ) ⇒ L −→c  L' ∧ P/c? ∼' L')∧
(∀c . L −→c  L' ⇒ (c! ∈ fst(P ) ∧ P/c! ∼ L') V (c? ∈ fst(P ) ∧ P/c? ∼' L'))∧
(∀P' . P −a→ P' ⇒ ∃L' . L −a→ L' ∧ P' ∼' L')∧
(∀L' . L −a→ L' ⇒ ∃P ' . P −a→ P' ∧ P' ∼' L')∧
(∀P' . P −τ→ P' ⇒ ∃L' . L −τ→ L' ∧ P' ∼' L')∧
(∀L' . L −τ→ L' ⇒ ∃P ' . P −τ→ P' ∧ P' ∼' L')
Lemma 4.4 For each Chor speciﬁcation C and Peer p, we have nproj(C, p) ∼'
lts(p2fpi(C, p)).
Proof. For the sake of comprehension, we only show that the behavior of Peer p can be represented by the corresponding LTS (proof for the reverse direction is similar and hence straightforward). We use induction on the operators of nproj(C, p). Basis of induction (cases where nproj(C, p) is equal to ϵ, †, ap, c[p,p'], or c[p',p]) holds vacuously. Next, we prove the following inductive step:
P = nproj(C, p) = P1; P2 ⇒
∃C1, C2 . C = C1; C2 ∧ nproj(C1, p) = P1 ∧ nproj(C2, p) = P2 ⇒
nproj(C1, p) ∼' lts(p2fpi(C1, p)) ∧ nproj(C2, p) ∼' lts(p2fpi(C2, p)) ⇒
lts(p2fpi(C, p)) = lts(p2fpi(C1, p)); lts(SKIP ); lts(p2fpi(C2, p))
If P1 = ϵ ⇒ P −τ→ P2 ∧ lts(p2f (C1, p)) ∼ lts(END) ⇒
pi
lts(p2fpi(C, p)) ∼ lts(SKIP ); lts(p2fpi(C2, p)) ∧

∃L' . lts(p2f
(C, p)) −τ→ L' ∧ L' ∼ lts(p2f
pi(C2, p)) ⇒ P' ∼' L'.



9 lts(STOP ) has one state which is initial but not final, and no transition.
10 Bisimulation relations between two peers or between two LTSs [9] are similar and straightforward, there- fore they are not presented here.

If P1 /= ϵ ⇒
P −a→ P' ⇒ P1 −a→ P' ⇒ ∃L' . lts(p2f

(C1, p)) −a→ L' ∧ L'

∼' P' ⇒

1	1	pi	1	1	1

∃L' . lts(p2f
a
pi(C1, p)); lts(SKIP ); lts(p2f (C2, p)) −→ L' ∧

L' ∼ L'1; lts(SKIP ); lts(p2fpi(C2, p)) ⇒ P' ∼' L'

Proofs for the cases c! ∈ fst(P ), c? ∈ fst(P ), or P
−τ→ P', and cases P = P1  P2,

P = P1 H P2, or P = ∗P1 are similar and omitted here.	 
Theorem 4.5 For each Chor C with n peers, PS = nproj(C, 1)  ···nproj(C, n) is strongly bisimilar (∼) with L = lts(Peers2), where
Peers2 = Peers; SKIP ; END. and Peers = (p2fpi(C, 1)  ···p2fpi(C, n)).
Proof. If PS = ϵ  ···ϵ then ∀1 ≤ i ≤ n . lts(p2fpi(C, i)) ∼ lts(END), thus one
τ	τ
can see lts(p2fpi(C, 1) ···p2f (C, n)) ∼ lts(END). Hence PS −→ ϵ and L −→
L' ∧ L' ∼ lts(END). For all the other cases in which PS /= ϵ  ···ϵ proof is as
follows:
For all PS' such that PS −→b  PS' (b stands for a local activity or τ )
∃1 ≤ i ≤ n . nproj(C, i) −→b nproj(C, i)' ⇒
lts(p2f (C, i)) −→b  lts(p2f (C, i))' ∧ nproj(C, i)' ∼' lts(p2f (C, i))' ∧
pi	pi

b = τ ∨ ∄j /= i . b ∈ αp2f
(C, j) ⇒ ∃L' . L −→b
L' ∧ PS' ∼ L' (induction)

For all PS' such that PS −→c
PS' (c stands for a communication activity)

∃1 ≤ i, j ≤ n.i /= j∧nproj(C, i)/c! = nproj(C, i)'∧nproj(C, j)/c? = nproj(C, j)' ⇒
lts(p2f (C, i)) −→c  lts(p2f (C, i))' ∧ nproj(C, i)' ∼' lts(p2f (C, i))' ∧
pi	pi

lts(p2f
(C, j)) −→c
lts(p2f
pi(C, j))' ∧ nproj(C, j)' ∼' lts(p2f
pi(C, j))' ∧

∄k /= i, j . c ∈ αp2f (C, k) ⇒ ∃L' . L −→c  L' ∧ PS' ∼ L' (induction)
Proof of the reverse direction is similar to the forward direction, and is omitted here.	 
Corollary 4.6 Bisimulation is a stronger relation than (weak) trace equivalence, thus for each Chor speciﬁcation C with n peers the following relation holds between Peer speciﬁcations and their corresponding FSP speciﬁcations:
[[nproj(C, 1)  ···nproj(C, n)]] = [[p2fpi(C, 1)  ···p2fpi(C, n)]]

Realizability
Definition 4.7 formalizes the notion of choreography realizability we use in this paper. We chose a strong realizability [2,7] for experimentation purposes, but weak notions could be used instead [7].
Definition 4.7 [Realizability of Chor under Natural Projection] For a Chor speci- fication C with n peers, we say C is realizable under natural projection, if and only if the following two conditions hold:
[C]] = [[nproj(C, 1)  ···nproj(C, n)]]
∄t . nproj(C, 1)  ···nproj(C, n) =⇒t  † 

Both Chor and Peer languages use trace semantics. Therefore, for checking the realizability of a Chor specification we need to compare the trace set of a Chor specification with the trace set of the parallel composition of all peers. We proved in Theorem 3.3 that the trace set of a Chor specification is equal to the trace set of its FSP encoding. We showed in Corollary 4.6 that our encoding also preserves the semantics of the Peer language. Thus, we have to check that FSP specifications for Chor and peers produce the same set of traces (in which τ actions are hidden) and terminate. Although the specification of Chor is deadlock-free, the specification of the final system made of interacting peers (generated using natural projection) may cause deadlock. In addition to check that both specifications have the same set of traces, the parallel composition of the different peers has also to be deadlock-free. This check is easily computed using the LTSA toolbox. Also, one can perform any kind of test that is provided by LTSA, such as checking temporal properties between different activities in the Chor and Peer specifications.
Magee and Kramer explained in [9] how some Java code can be generated from FSP. Therefore, in our approach, these guidelines can be followed for rapid proto- typing purposes to implement real peers from their FSP specifications, and deploy them in the context of a concrete system. In Section 5, we will show on our running example how Java code is automatically generated. Implementation of executable services from abstract descriptions could also be achieved in BPEL using Pi4SOA technologies [1] or following guidelines presented in [10].
Example 4.8 For each Peer P , all actions in c2fpi(Stock) in which P is not in- volved, are hidden. The three peers of our example are encoded by the following FSP specifications:
Broker =
c2fpi(Stock); END@{iron bk, steel bk, bid bk mk, look bk, notify bd bk}.
Market = c2fpi(Stock); END@{save mk, check mk, bid bk mk, result mk bd}.
Board = c2fpi(Stock); END@{result mk bd, notify bd bk, change bd}.
Figure 2 shows the minimized LTSs of these peers generated from the FSP processes presented above.

tau
1 steel_bk
look_bk
tau	E

Broker 0
tau tau


8 iron_bk

3 change_bd
2

tau
3 tau 4 bid_bk_mk
5

tau

notify_bd_bk
7

Board
0 result_mk_bd 1

tau

4
E notify_bd_bk

Fig. 2. Stock Market: Minimized LTSs of Peers

Finally, we run all these peers concurrently. The FSP process for the whole system is:  Peers = (Broker  Market  Board). As for the realizability test, first, we compute LTSs from FSP processes Stock and Peers, using LTSA. Next, we com- pare trace sets of these processes using ltscompare, one of the tools belonging to

the mCRL2 toolset [6], and find out they produce the same set of traces (first re- alizability condition, Definition 4.7). For a Chor specification to be realizable, it is also required to satisfy the second condition of Definition 4.7. LTSA helps us on validating this condition, and using the check safety test, we find that the following trace causes deadlock:
⟨iron bk, look bk, bid bk mk, check mk, save mk, result mk bd⟩
Indeed, after Broker sends his/her bid to the market, (s)he should decides if (s)he will be notified by the board or not. On the other hand, Board also makes this decision according to the result which is received from the market. So if peers Broker and Board make different decisions, a deadlock occurs. To make our specification realizable we slightly change it as follows: Whatever value is received from the market, Board always notifies the broker about the result. Thus, the specification of the system becomes as follows:

Stock = (ironbk H steelbk); lookbk; ∗lookbk; bid[bk,mk]; (savemk||checkmk);
result[mk,bd]; (changebd H skip); notify[bd,bk]
This new specification satisfies both realizability conditions.

Prototype Tool and Code Generation
All the steps of the approach we have presented in Sections 3 and 4 are automatically computed by a prototype tool we implemented (see Figure 3 for an overview) and tested on more than 300 examples of different sizes. Checking deadlock-freeness costs less than checking weak trace equivalence. Therefore, in our prototype we first check deadlock-freeness and then trace equivalence (if no deadlock was found).

Fig. 3. Prototype Tool Overview


Experimental Results
Table 5 shows experimental results on some of the examples of our database. Each row of this table shows results for one Chor specification, and respectively presents the number of: peers, activities used in the Chor specification, FSP processes re- sulting while encoding the Chor specification into FSP, states and transitions in the LTS corresponding to the Chor specification, states and transitions in the LTS

computed from the parallel composition of the Peer specifications, result of the deadlock-freeness check, result of the weak trace equivalence check, time and mem- ory used to verify realizability. Numbers of states and transitions have two parts, before and after minimization using LTSA. To compute the LTS of the parallel composition of peers we first compute the minimal LTS for each peer and then compose them using the parallel operator. We perform this minimization because there are lots of τ transitions in peer LTSs and it may cause state explosion if we compose them in parallel without applying minimization before. Each minimized LTS is weakly bisimilar to its original LTS [9].
Whenever a deadlock-freeness check fails, there is no need to check the weak trace equivalence (marked by “−” in Table 5). Note that we use LTSA to obtain the parallel composition of Peer LTSs, and this computation has to be completed before performing the deadlock-freeness check. In some cases, this computation can be very costly in time and memory as it can be observed in the last row of Table 5 (almost 10 minutes to obtain the Peer LTS).

Table 5 Experimental Results



Code Generation
As mentioned earlier, the final step is to produce some Java code following guide- lines presented in [9]. Like the other steps, this is completely automated by our tool. Figure 4 shows a simplified version of some classes produced for our running example. We define an interface Channel and implement it in a class ChannelImpl. For each channel in the specification, one instance of ChannelImpl is created in class ChannelServer and registered in a server. Also, for each peer we create one interface and one class. The interface contains methods for local and communication ac- tivities performed by the peer and must be implemented by the user, because the semantics of basic activities used in the specification is not defined. Code in the class file implements the peer behavior and should not be changed. The user only needs to implement interfaces of peers and distributes classes to different locations, as needed.
Let us comment in more details, for illustration purposes, method run in class
mkController.  We can notice that for each operand of the parallel operator we

created one separate thread, and used class CyclicBarrier (the Java utility class) to guarantee that the execution of both threads must be finished before the next activities are performed (cb1.wait() and cb2.wait()). Also, SynchronousQueue used in class ChannelImpl is another Java class which synchronizes its read/write operations, therefore our communication mechanism remains synchronous.



Fig. 4. Stock Market: Java Code


Related Works
Several works aimed at studying and defining the conformance and/or realizability problem for choreography. In [3], the authors define models for choreography and orchestration, and formalise a conformance relation between both models. These models are assumed given as input whereas we focus on the generation of one from the other (generation of peers from a global specification). In [14], the authors focus on Let’s dance models for choreographies, and define for them an algorithm that determines if a global model is locally enforceable, and another algorithm for generating local models from global ones. In [11], the authors show through a simple example how BPEL stubs can be derived from WS-CDL choreographies. However, due to the lack of semantics of both languages, correctness of the generation cannot be ensured.
Some works define several realizability notions, and classify them in a hierar- chy [7]. Bultan and Fu [2] tackle the realizability issue in the context of asyn- chronous communication, and recently defined some sufficient conditions to test re- alizability of choreographies specified with collaboration diagrams. In some recent

papers [12,8], formal languages to describe choreographies were proposed. Confor- mance with respect to an orchestration specification and implementability issues were studied from a formal point of view.
Other works [4,12] propose well-formedness rules to enforce the specification to be realizable. For example, in [4], the authors rely on a π-calculus-like language and session types to formally describe choreographies. Then, they identify three princi- ples for global description under which they define a sound and complete end-point projection, that is the generation of distributed processes from the choreography.
As regards tools automating the realizability test, WSAT [5] takes conversation protocols as input, and checks a set of realizability conditions on them. Another tool-supported approach was presented in [13] and showed on an example how realiz- ability can be checked using a LOTOS encoding. However, in [13] the choreography language, namely collaboration diagrams, was less expressive than Chor (no choice and a loop operator restricted to a single message), and the proposal focused only on abstract languages (no relationships with implementations or real code).
To sum up, first, most of these approaches focus on theoretical aspects. Our contribution is a tool-supported yet formal approach tackling the realizability is- sue for choreography, but considers a different choreography specification language compared to [5,13], and therefore deals with its own specificities. Second, the works presented in this section focus on the realizability issue but do not allow to check choreography specifications or generate code from such specifications, whereas our FSP encoding makes it possible.


Concluding Remarks
In this paper, we have presented an encoding of the choreography calculus Chor into the process algebra FSP. This encoding allows to generate a set of peers corre- sponding to the choreography, and in a second step to check that (i) they realize the original choreography, and (ii) they ensure some expected properties (by animation and model-checking with LTSA). If the choreography is not realizable or erroneous, the Chor specification can be corrected and the process started again. Our approach is completely automated by a prototype tool we implemented and applied to a large number of examples.
Our main perspective plans to extend our approach to consider asynchronous communication. In this paper, we have focused on synchronous communication, and it makes the realizability computation and model-checking easier. Dealing with asynchronous communication is a realistic assumption with respect to implemen- tation platforms, however it complicates the analysis and verification stage. Asyn- chronous communication can be specified using queues. In this context, realizability results depend on queue size, and some theoretical issues are still open problems such as the relationships of realizability results for queues of size one, queues of size k, and infinite queues.

Acknowledgement
This work has been partially supported by project TIN2008-05932 funded by the Spanish Ministry of Innovation and Science (MICINN), and project P06-TIC-02250 funded by the Junta de Andaluc´ıa.

References
Pi4SOA Project. www.pi4soa.org.
T. Bultan and X. Fu. Specification of Realizable Service Conversations using Collaboration Diagrams.
Service Oriented Computing and Applications, 2(1):27–39, 2008.
N. Busi, R. Gorrieri, C. Guidi, R. Lucchi, and G. Zavattaro. Choreography and Orchestration Conformance for System Design. In Proc. of Coordination’06, volume 4038 of LNCS, pages 63–81. Springer, 2006.
M. Carbone, K. Honda, and N. Yoshida. Structured Communication-Centred Programming for Web Services. In Proc. of ESOP’07, volume 4421 of LNCS, pages 2–17. Springer, 2007.
X. Fu, T. Bultan, and J. Su. WSAT: A Tool for Formal Analysis of Web Services. In Proc. of CAV’04, volume 3114 of LNCS, pages 510–514. Springer, 2004.
J. F. Groote, A. Mathijssen, M. Reniers, Y. Usenko, and M. van Weerdenburg. The Formal Specification Language mCRL2. In Proc. of MMOSS’07, Dagstuhl seminar, 2007.
R. Kazhamiakin and M. Pistore. Analysis of Realizability Conditions for Web Service Choreographies. In Proc. of FORTE’06, volume 4229 of LNCS, pages 61–76. Springer, 2006.
J. Li, H. Zhu, and G. Pu. Conformance Validation between Choreography and Orchestration. In Proc. of TASE’07, pages 473–482. IEEE Computer Society, 2007.
J. Magee and J. Kramer. Concurrency: State Models & Java Programs, 2nd edition. Wiley, 2006.
R. Mateescu, P. Poizat, and G. Salau¨n. Adaptation of Service Protocols using Process Algebra and On- the-Fly Reduction Techniques. In Proc. of ICSOC’08, volume 5364 of LNCS, pages 84–99. Springer, 2008.
J. Mendling and M. Hafner. From Inter-organizational Workflows to Process Execution: Generating BPEL from WS-CDL. In Proc. of OTM’05 Workshops, volume 3762 of LNCS, pages 506–515. Springer, 2005.
Z. Qiu, X. Zhao, C. Cai, and H. Yang. Towards the Theoretical Foundation of Choreography. In Proc. of WWW’07, pages 973–982. ACM Press, 2007.
G. Salau¨n and T. Bultan. Realizability of Choreographies using Process Algebra Encodings. In Proc. of IFM’09, LNCS, pages 167–182. Springer, 2009.
J. Maria Zaha, M. Dumas, A. H. M. ter Hofstede, A. P. Barros, and G. Decker. Service Interaction Modeling: Bridging Global and Local Views. In Proc. of EDOC’06, pages 45–55. IEEE Computer Society, 2006.
