Electronic Notes in Theoretical Computer Science 71 (2003)
URL: http://www.elsevier.nl/locate/entcs/volume71.html 21 pages



An Executable Speciﬁcation of Asynchronous Pi-Calculus Semantics and May Testing in Maude 2.0

Prasanna Thati a,1, Koushik Sen a,1, and Narciso Mart´ı-Oliet b,2
a Department of Computer Science, University of Illinois at Urbana-Champaign, USA.
b Dpto. de Sistemas Inform´aticos y Programaci´on, Universidad Complutense de Madrid, Spain.


Abstract
We describe an executable specification of the operational semantics of an asyn- chronous version of the π-calculus in Maude by means of conditional rewrite rules with rewrites in the conditions. We also present an executable specification of the may testing equivalence on non-recursive asynchronous π-calculus processes, using the Maude metalevel. Specifically, we describe our use of the metaSearch opera- tion to both calculate the set of all finite traces of a non-recursive process, and to compare the trace sets of two processes according to a preorder relation that char- acterizes may testing in asynchronous π-calculus. Thus, in both the specification of the operational semantics and the may testing, we make heavy use of new features introduced in version 2.0 of the Maude language and system.
Key words: π-calculus, asynchrony, may testing, traces, Maude


Introduction
Since its introduction in the seminal paper [11] byMilner, Parrow, and Walker, the π-calculus has become one of the most studied calculus for name-based mobilityof processes, where processes are able to exchange names over chan- nels so that the communication topologycan change during the computation. The operational semantics of the π-calculus has been defined for several differ- ent versions of the calculus following two main styles. The first is the labelled transition system style according to the SOS approach introduced by Plotkin [13]. The second is the reduction style, where first an equivalence is imposed

1 Email: {thati,ksen}@cs.uiuc.edu
2 Email: narciso@sip.ucm.es
◯c 2003 Published by Elsevier Science B. V. Open access under CC BY-NC-ND license.


on syntactic processes (typically to make syntax more abstract with respect to properties of associativity and/or commutativity of some operators), and then some reduction or rewrite rules express how the computation proceeds bycommunication between processes.
The first specification of the π-calculus operational semantics in rewriting logic was developed by Viry in [19], in a reduction style making use of de Bruijn indexes, explicit substitutions, and reduction strategies in Elan [6]. This presentation was later improved byStehr [14] bymaking use of a generic calculus for explicit substitutions, known as CINNI, which combines the best of the approaches based on standard variables and de Bruijn indices, and that has been implemented in Maude.
Our work took the work described above as a starting point, together with recent work byVerdejo and Mart´ı-Oliet [18] showing how to use the new features of Maude 2.0 in the implementation of a semantics in the labelled transition system style for CCS. This work makes essential use of conditional rewrite rules with rewrites in the conditions, so that an inference rule in the labelled transition system of the form
P1 → Q1	...	Pn → Qn P0 → Q0
becomes a conditional rewrite rule of the form
P0 −→ Q0  if	P1 −→ Q1 ∧ ... ∧ Pn −→ Qn,
where the condition includes rewrites. These rules are executable in version 2.0 of the Maude language and system [7]. However, this is not enough, because it is necessary to have some control on the application of rules. Typically, rewrite rules can be applied anywhere in a term, while the transitions in the operational semantics for CCS or the π-calculus in the SOS style only take place at the top. The new frozen attribute available in Maude 2.0 makes this possible, because the declaration of an operator as frozen forbids rewriting its arguments, thus providing another way of controlling the rewriting process. Rewrite conditions when applying conditional rules are solved by means of an implicit search process, which is also available to the user both at the command level and at the metalevel. The search command looks for all the rewrites of a given term that match a given pattern satisfying some condition. Search is reified at the metalevel as an operation metaSearch.
In this way, our first contribution is a fully executable specification of an operational semantics in the labelled transition system style for an asyn- chronous version of the π-calculus (the semantics for the synchronous case is obtained as a simple modification). This specification uses conditional rewrite rules with rewrites in conditions and the CINNI calculus [14] for managing names and bindings in the π-calculus. However, these two ingredients are not enough to obtain a fully executable specification. A central problem to over- come is that the transitions of a term can be inﬁnitely branching. For instance, the term x(y).P can evolve via an input action to one of an infinite familyof

terms depending on the name received in the input at channel x. Our solution is to define the transitions of a process relative to an execution environment. The environment is represented abstractlyas a set of free (global) names that the environment may use while interacting with the process, and transitions are modelled as rewrite rules over a pair consisting of a set of environment names together with a process.
Our next contribution is to implement the verification of the may-testing preorder [12,3,5] between finitary(non-recursive) asynchronous π-calculus pro- cesses, using again ideas from [18] to calculate the set of all finite traces of a process. May testing is a specific instance of the notion of behavioral equiv- alence on π-calculus processes; in may testing, two processes are said to be equivalent if they have the same success properties in all experiments. An experiment consists of an observing process that runs in parallel and interacts with the process being tested, and success is defined as the observer signalling a special event. Viewing the occurrence of an event as something bad hap- pening, maytesting can be used to reason about safetyproperties [4].
Since the definition of maytesting involves a universal quantification over all observers, it is difficult to establish process equivalences directly from the definition. As a solution, alternate characterizations of the equivalence that do not resort to quantification over observers have been found. It is known that the trace semantics is an alternate characterization of may testing in (synchronous) π-calculus [3], while a variant of the trace semantics has been shown to characterize maytesting in an asynchronous setting [5]. Specifically, in both these cases, comparing two processes according to the may-testing preorder amounts to comparing the set of all finite traces they exhibit. We have implemented for finite asynchronous processes, the comparison of trace sets proposed in [5]. We stress that our choice of specifying an asynchronous version rather than the synchronous π-calculus, is because the characterization of maytesting for the asynchronous case is more interesting and difficult. The synchronous version can be specified in an executable way using similar but simpler techniques.
Our first step in obtaining an executable specification of may testing is to obtain the set of all finite traces of a given process. This is done at the Maude metalevel by using the metaSearch operation to collect all results of rewriting a given term. The second step is to specify a preorder relation between traces that characterizes maytesting. We have represented the trace preorder relation as a rewriting relation, i.e. the rules of inference that define the trace preorder are again modeled as conditional rewrite rules. The final step is to check if two processes are related bythe maypreorder, i.e. whether a statement of the form P ± Q is true or not. This step involves computing the closure of a trace under the trace-preorder relation, again bymeans of the metaSearch operation. Thus, our work demonstrates the utility of the new metalevel facilities available in Maude 2.0.
The structure of the paper follows the steps in the description above. Sec-

tion 2 describes the syntax of the asynchronous version of the π-calculus that we consider, together with the corresponding CINNI operations we use. Sec- tion 3 describes the operational semantics specified by means of conditional rewrite rules. Sections 4 and 5 define traces and the preorder on traces, re- spectively. Finally, Section 6 contains the specification of the may testing on processes as described above. Section 7 concludes the paper along with a brief discussion of future work.
Although this paper includes some information on the π-calculus and may testing to make it as self contained as possible, we refer the reader to the papers [5,3,11] for complete details on these subjects. In the same way, the interested reader can find a detailed explanation about the new features of Maude 2.0 in [7], and about their use in the implementation of operational semantics in the companion paper [18].

Asynchronous π-Calculus Syntax
The following is a brief and informal review of a version of asynchronous π- calculus that is equipped with a conditional construct for matching names. An infinite set of channel names is assumed, and u, v, w, x, y, z, . . . are assumed to range over it. The set of processes, ranged over by P, Q, R, is defined by the following grammar:
P := xy | Σ αi.Pi | P1|P2 | (νx)P  | [x = y](P1, P2) | !P
i∈I
where α can be x(y) or τ .
The output term xy denotes an asynchronous message with target x and content y. The summation  i∈I αi.Pi non-deterministically chooses an αi, and if αi = τ it evolves internally to Pi, and if αi = x(y) it receives an arbitrary name z at channel x and then behaves like P{z/y}. The process P{z/y} is the result of the substitution of free occurrences of y in P by z, with the usual renaming of bound names to avoid accidental captures (thus substitution is defined onlymodulo α-equivalence). The argument y in x(y).P binds all free occurrences of y in P . The composition P1|P2 consists of P1 and P2 acting in parallel. The components can act independently, and also interact with each other. The restriction (νx)P behaves like P except that it can not exchange messages targeted to x, with its environment. The restriction binds free occurrences of x in P . The conditional [x = y](P1, P2) behaves like P1 if x and y are identical, and like P2 otherwise. The replication !P provides an infinite number of copies of P . The functions for free names fn(.), bound names bn(.) and names n(.), of a process, are defined as expected.
In the Maude specification for the π-calculus syntax that follows, the sort Chan is used to represent channel names and each of the non-constant syn- tax constructors is declared as frozen, so that the corresponding arguments

cannot be rewritten byrules; this will be justified at the end of Section 3.
sort Chan .
sorts Guard GuardedTrm SumTrm Trm . subsort GuardedTrm < SumTrm . subsort SumTrm < Trm .
op _(_) : Chan Qid -> Guard . op tau : -> Guard .
op nil : -> Trm .
op _<_> : Chan Chan -> Trm [frozen] .
op _._ : Guard Trm -> GuardedTrm [frozen] .
op _+_ : SumTrm SumTrm -> SumTrm [frozen assoc comm] . op _|_ : Trm Trm -> Trm [frozen assoc comm] .
op new[_]_ : Qid Trm -> Trm [frozen] .
op if_=_then_else_fi : Chan Chan Trm Trm -> Trm [frozen] . op !_ : Trm -> Trm [frozen] .
Note that the syntactic form Σi∈I αi.Pi has been split into three cases:
nil represents the case where I = ∅,
a term of sort GuardedTrm represents the case where I = {1}, and
a term of sort SumTrm represents the case where I = [1..n] for n > 1. Since the constructor + is associative and the sort GuardedTrm is a subsort of SumTrm, we can represent a finite sum  i∈I αi.Pi as (... (α1.P1 + α2.P2)+ 
··· αn.Pn).
To represent substitution on π-calculus processes (and traces, see Sec- tion 4) at the language level we use CINNI as a calculus for explicit substitu- tions [14]. This gives a first-order representation of terms with bindings and capture-free substitutions, instead of going to the metalevel to handle names and bindings. The main idea in such a representation is to keep the bound names inside the binders as it is, but to replace its use by the name followed byan index which is a count of the number of binders with the same name it jumps before it reaches the place of use. Following this idea, we define terms of sort Chan as indexed names as follows.
sort Chan .
op _{_} : Qid Nat -> Chan [prec 1] .
We introduce a sort of substitutions Subst together with the following operations:
op [_:=_] : Qid Chan -> Subst . op [shiftup_] : Qid -> Subst . op [shiftdown_] : Qid -> Subst .
op [lift  ] : Qid Subst -> Subst .
The first two substitutions are basic substitutions representing simple and shiftup substitutions; the third substitution is a special case of simple substi- tution; the last one represents complex substitution where a substitution can be lifted using the operator lift. The intuitive meaning of these operations



Table 1
The CINNI operations.

is described in Table 1 (see [14] for more details). Using these, explicit sub- stitutions for π-calculus processes are defined equationally. Some interesting equations are the following:
eq S (P + Q) = (S P) + (S Q) .
eq S (CX(Y) . P ) = (S CX)(Y) . ([lift Y S] P) .
eq S (new [X] P) = new [X] ([lift X S] P) .

Operational Semantics
A labelled transition system (see Table 2) is used to give an operational se- mantics for the calculus as in [5]. The transition system is defined modulo α-equivalence on processes in that α-equivalent processes have the same tran- sitions. The rules COM, CLOSE, and PAR have symmetric versions that are not shown in the table.
Transition labels, which are also called actions, can be of five forms: τ (a silent action), xy (free output of a message with target x and content y), x(y) (bound output), xy (free input of a message), and x(y) (bound input). The functions fn(.), bn(.) and n(.) are defined on actions as expected. The set of all visible (non-τ ) actions is denoted by L, and α is assumed to range over
L. As a uniform notation for free and bound actions the following notational convention is adopted: (∅)xy = xy, ({y})xy = x(y), and similarly for input actions. The variable zˆ is assumed to range over {∅, {z}}. The term (νzˆ)P is (νz)P if zˆ = {z}, and P otherwise.
We define the sort Action and the corresponding operations as follows:
sorts Action ActionType . ops i o : -> ActionType .
op f : ActionType Chan Chan -> Action . op b : ActionType Chan Qid -> Action . op tauAct : -> Action .
The operators f and b are used to construct free and bound actions re- spectively. Name substitution on actions is defined equationally as expected. The inference rules in Table 2 are modelled as conditional rewrite rules




















Table 2
A labelled transition system for asynchronous π-calculus.

with the premises as conditions of the rule. 3 Since rewrites do not have labels unlike the labelled transitions, we make the label a part of the resulting term; thus rewrites corresponding to transitions in the operational semantics are of the form P ⇒ {α}Q.
Because of the INP and OPEN rules, the transitions of a term can be infinitely branching. Specifically, in case of the INP rule there is one branch for everypossible name that can be received in the input. In case of the OPEN rule, there is one branch for every name that is chosen to denote the private channel that is being emitted (note that the transition rules are defined only modulo α-equivalence). To overcome this problem, we define transitions over pairs of the form [CS] P, where CS is a set of channel names containing all the names that the environment with which the process interacts, knows about. The set CS expands during bound input and output interactions when private names are exchanged between the process and its environment.
The infinite branching due to the INP rule is avoided byallowing onlythe names in the environment set CS to be received in free inputs. Since CS is assumed to contain all the free names in the environment, an input argument that is not in CS would be a private name of the environment. Now, since the identifier chosen to denote the fresh name is irrelevant, all bound input

3 The symmetric versions missing in the table need not be implemented because the process constructors + and | have been declared as commutative.


transitions can be identified to a single input. With these simplifications, the number of input transitions of a term become finite. Similarly, in the OPEN rule, since the identifier chosen to denote the private name emitted is irrelevant, instances of the rule that differ only in the chosen name are not distinguished.
We discuss in detail the implementation of onlya few of the inference rules; the reader is referred to the appendix for a complete list of all the rewrite rules for Table 2.
sorts EnvTrm TraceTrm . subsort EnvTrm < TraceTrm .
op [_]_ : Chanset Trm -> EnvTrm [frozen] .
op {_}_ : Action TraceTrm -> TraceTrm [frozen] .
Note that the two operators are also declared above with the frozen at- tribute, forbidding in this wayrewriting of their arguments, as justified at the end of this section.
The following non-conditional rule is for free inputs.
rl [Inp] : [CY CS] ((CX(X) . P) + SUM) =>
{f(i,CX,CY)} ([CY CS] ([X := CY] P)) .
The next rule we consider is the one for bound inputs. Since the identifier chosen to denote the bound argument is irrelevant, we use the constant ’U for all bound inputs, and thus ’U{0} denotes the fresh channel received. Note that in contrast to the BINP rule of Table 2, we do not check if ’U{0} is in the free names of the process performing the input, and instead we shift up the channel indices appropriately, in both the set of environment names CS and the process P in the righthand side and condition of the rule. This is justified because the transition target is within the scope of the bound name in the input action. Note also that the channel CX in the action is not shifted down because it is out of the scope of the bound argument. The set of environment names is expanded by adding the received channel ’U{0} to it. Finally, we use a special constant flag of sort Chan, to ensure termination. We add an instance of flag to the environment set of the rewrite in condition, so that the BINP rule is not fired again while evaluating the condition. Without this check, we will have a non-terminating execution in which the BINP rule is repeatedlyfired.
crl [BInp] : [CS] P => {b(i,CX,’U)} [’U{0} [shiftup ’U] CS] P1
if (not flag in CS) /\
CS1 := flag ’U{0} [shiftup ’U] CS /\
[CS1] [shiftup ’U] P => {f(i,CX,’U{0})} [CS1] P1 .
The following rule treats the case of bound outputs.
crl [Open] : [CS] (new [X] P) => {[shiftdown X] b(o,CY,X)} [X{0} CS1] P1 if CS1 := [shiftup X] CS /\
[CS1] P => {f(o,CY,X{0})} [CS1] P1 /\ X{0} =/= CY .
Like in the case of bound inputs, we identifyall bound outputs to a single

instance in which the identifier X that appears in the restriction is chosen as the bound argument name. Note that in both the righthand side of the rule and in the condition, the indices of the channels in CS are shifted up, because theyare effectivelymoved across the restriction. Similarly, the channel indices in the action in the righthand side of the rule are shifted down since the action is now moved out of the restriction. Note also that the exported name is added to the set of environment names, because the environment that receives this exported name can use it in subsequent interactions.
The PAR inference rule is implemented by two rewrite rules, one for the case where the performed action is free, and the other where the action is bound. The rewrite rule for the latter case is discussed next, while the one for the former case is simpler and appears in the appendix.
var  IO  :  ActionType crl [Par] : [CS] (P | Q) =>
{b(IO,CX,Y)} [Y{0} ([shiftup Y] CS)] (P1 | [shiftup Y] Q)
if [CS] P => {b(IO,CX,Y)} ([CS1] P1) .
Note that the side condition of the PAR rule in Table 2, which avoids confusion of the emitted bound name with free names in Q, is achieved by shifting up channel indices in Q. This is justified because the righthand side of the rule is under the scope of the bound output action. Similarly, the channel indices in the environment are also shifted up. Further, the set of environment names is expanded byadding the exported channel Y{0}.
Finally, we consider the rewrite rule for CLOSE. The process P emits a bound name Y, which is received by process Q. Since the scope of Y after the transition includes Q, the rewrite involving Q in the second condition of the rule is carried out within the scope of the bound name that is emitted. This is achieved by adding the channel Y{0} to the set of environment names and shifting up the channel indices in both CS and Q in the rewrite. Note that since the private name being exchanged is not emitted to the environment, we neither expand the set CS in the righthand side of the rule nor shift up the channel indices in it.
crl [Close] : [CS] (P | Q) => {tauAct} [CS] new [Y] (P1 | Q1) if [CS] P => {b(o,CX,Y)} [CS1] P1 /\
[Y{0} [shiftup Y] CS] [shiftup Y] Q =>
{f(i,CX,Y{0})} [CS2] Q1 .
We conclude this section with the following note. The operator { } is declared frozen because further rewrites of the process term encapsulated in a term of sort TraceTrm are useless. This is because all the conditions of the transition rules onlyinvolve one step rewrites (the righthand side of these rewrites can onlymatch a term of sort TraceTrm with a single action prefix). Further note that, to prevent rewrites of a term to a non well-formed term, all the constructors for π-calculus terms (Section 2) have been declared frozen; in the absence of this declaration we would have for instance rewrites of the form P | Q => {A}.P1 | Q to a non well-formed term.

Trace Semantics
The set L∗ is the set of traces. The functions fn(.), bn(.) and n(.) are extended to L∗ in the obvious way. The relation of α-equivalence on traces is defined as expected, and α-equivalent traces are not distinguished. The relation =⇒

denotes the reflexive transitive closure of −τ→
β
denotes =
β
=⇒.

'
For s = l.s', we inductively define P =⇒s	P ' as P =⇒l  =s	P '. We use P =⇒s
as an abbreviation for P =⇒s	P ' for some P '. The set of traces that a process
exhibits is then [|P |]= {s | P =⇒s  }.
In the implementation, we introduce a sort Trace as supersort of Action
to specifytraces.
subsort Action < Trace . op epsilon : -> Trace .
op _._ : Trace Trace -> Trace [assoc id: epsilon] . op [_] : Trace -> TTrace .
We define the operator [ ] to represent a complete trace. The motivation for doing so is to restrict the equations and rewrite rules defined over traces to operate onlyon a complete trace instead of a part of it. The following equation defines α-equivalence on traces. Note that in a trace TR1.b(IO,CX,Y).TR2 the action b(IO,CX,Y) binds the identifier Y in TR2.
ceq [TR1 . b(IO,CX,Y) . TR2] =
[TR1 . b(IO,CX,’U) . [Y := ’U{0}] [shiftup ’U] TR2]
if Y =/= ’U .
Because the operator op { } : Action TraceTrm -> TraceTrm is declared as frozen, a term of sort EnvTrm can rewrite onlyonce, and so we cannot ob- tain the set of finite traces of a process bysimplyrewriting it multiple times in all possible ways. The problem is solved as in [18], by specifying the trace se- mantics using rules that generate the transitive closure of one step transitions as follows:
sort TTrm .
op [_] : EnvTrm -> TTrm [frozen] . var TT : TraceTrm .
crl [reflx] : [ P ] => {A} Q if P => {A} Q . crl [trans] : [ P ] => {A} TT
if P => {A} Q /\ [ Q ] => TT /\ [ Q ] =/= TT .
We use the operator [ ] to prevent infinite loops while evaluating the conditions of the rules above. If this operator were not used, then the lefthand side of the rewrite in the condition would match the lefthand side of the rule itself, and so the rule itself could be used in order to solve its condition. This operator is also declared as frozen to prevent useless rewrites inside [ ].
We can now use the search command of Maude 2.0 to find all possible traces of a process. The traces appear as prefix of the one-step successors of a TTrm of the form [[CS] P]. For instance, the set of all traces exhibited

by [mt] new [’y] (’x0 < ’y0 > | ’x0(’u) . nil) (where mt denotes the emptychannel set), can be obtained byusing the following search command.
Maude> search [ [mt] new [’y] (’x{0} < ’y{0} > | ’x{0}(’u) . nil) ] =>! X:TraceTrm .
search in APITRACESET : [[mt]new[’y](’x{0} < ’y{0} > | ’x{0}(’u) . nil)] =>! X:TraceTrm .
Solution 1 (state 1)
states: 7 rewrites: 17344 in 110ms cpu (150ms real) (157672 rewrites/second) X:TraceTrm --> {b(i, ’x{0}, ’u)}[’u{0}]new[’y](nil | ’x{0} < ’y{0} >)
Solution 2 (state 2)
states: 7 rewrites: 17344 in 110ms cpu (170ms real) (157672 rewrites/second) X:TraceTrm --> {tauAct}[mt]new[’y](nil | nil)
Solution 3 (state 3)
states: 7 rewrites: 17344 in 110ms cpu (170ms real) (157672 rewrites/second) X:TraceTrm --> {b(o, ’x{0}, ’y)}[’y{0}]nil | ’x{0}(’u) . nil 
Solution 4 (state 4)
states: 7 rewrites: 17344 in 110ms cpu (170ms real) (157672 rewrites/second) X:TraceTrm --> {b(i, ’x{0}, ’u)}{b(o, ’x{0}, ’y)}[’y{0} ’u{0}]nil | nil 
Solution 5 (state 5)
states: 7 rewrites: 17344 in 110ms cpu (170ms real) (157672 rewrites/second) X:TraceTrm --> {b(o, ’x{0}, ’y)}{b(i, ’x{0}, ’u)}[’y{0} ’u{0}]nil | nil 
Solution 6 (state 6)
states: 7 rewrites: 17344 in 110ms cpu (170ms real) (157672 rewrites/second) X:TraceTrm --> {b(o, ’x{0}, ’y)}{f(i, ’x{0}, ’y{0})}[’y{0}]nil | nil 
No more solutions.
states: 7 rewrites: 17344 in 110ms cpu (170ms real) (157672 rewrites/second)
The command returns all TraceTrms that can be reached from the given TTrm, and that are terminating (the ‘!’ in =>! specifies that the target should be terminating). The required set of traces can be obtained bysimplyextract- ing from each solution {a1}...{an}TT the sequence a1...an and removing all tauActs in it. Thus, we have obtained an executable specification of the trace semantics of asynchronous π-calculus.

A Trace Based Characterization of May Testing
The may-testing framework [12] is instantiated on asynchronous π-calculus as follows. Observers are processes that can emit a special message µµ. We say
s¯.µµ
that an observer O accepts a trace s if O =⇒, where s¯ is the trace obtained by
complementing the actions in s, i.e. converting input actions to output actions and vice versa. The maypreorder ± over processes is defined as: P ± Q if for
µµ	µµ
every observer O, P|O =⇒ implies Q|O =⇒. We say that P and Q are may-



Table 3
A preorder relation on traces.
equivalent, i.e. P = Q, if P ± Q and Q ± P . The universal quantification on contexts in this definition makes it very hard to prove equalities directly from the definition, and makes mechanical checking impossible. To circumvent this problem, a trace based alternate characterization of the mayequivalence is proposed in [5]. We now summarize this characterization and discuss our implementation of it.
The preorder ≤ on traces is defined as the reflexive transitive closure of the laws shown in Table 3, where the notation (yˆ)· is extended to traces as follows.
 s	if yˆ = ∅ or y /∈ fn(s)
(yˆ)s =  s1.x(y).s2	if yˆ = {y} and there are s1, s2,x such that
s = s1.xy.s2 and y /∈ n(s1) ∪ {x}

 ⊥	otherwise
For sets of traces R and S, we define R - S, if for every s ∈ S there is an r ∈ R such that r ≤ s. The may preorder is then characterized in [5] as: P ± Q if and onlyif [|Q|] - [|P |].
The main intuition behind the preorder ≤ is that if an observer accepts a trace s, then it also accepts any trace r ≤ s. The first two laws state that an observer cannot force inputs on the process being tested. Since outputs are asynchronous, the actions following an output in a trace exhibited by the observer need not causallydepend on the output. Hence the observer’s output can be delayed until a causally dependent action, or dropped if there are no such actions. The annihilation law states that an observer can consume its own outputs unless there are subsequent actions that depend on the output. The reader is referred to [5] for further details on this characterization.
We encode the trace preorder as rewrite rules on terms of the sort TTrace
of complete traces; specifically, the relation r ≺ s if cond, is encoded as s
=> r if cond. The reason for this form of representation will be justified in Section 6. The function ({y})· on traces is defined equationally by the operation bind. The constant bot of sort Trace is used bythe bind operation to signal error.
op bind : Qid Trace -> Trace . op bot : -> Trace .
var TR : Trace .	var IO : ActionType.


ceq TR . bot = bot if t =/= epsilon . ceq bot . TR = bot if t =/= epsilon .
eq bind(X , epsilon) = epsilon .
eq bind(X , f(i,CX,CY) . TR ) = if CX =/= X{0} then
if CY == X{0} then ([shiftdown X] b(i, CX , X)) . TR else ([shiftdown X] f(i, CX , CY)) . bind(X , TR) fi
else bot fi .
eq bind(X , b(IO,CX,Y) . TR) = if CX =/= X{0} then
if X =/= Y then ([shiftdown X] b(i, CX , Y)) . bind(X , TR) else ([shiftdown X] b(IO, CX , Y)) . bind(X , swap(X,TR)) fi
else bot fi .
The equation for the case where the second argument to bind begins with a free output is not shown as it is similar. Note that the channel indices in actions until the first occurrence of X{0} as the argument of a free input are shifted down as these move out of the scope of the binder X. Further, when a bound action with X as the bound argument is encountered, the swap operation is applied to the remaining suffix of the trace. The swap operation simply changes the channel indices in the suffix so that the binding relation is unchanged even as the binder X is moved across the bound action. This is accomplished by simultaneously substituting X{0} with X{1}, and X{1} with X{0}. Finally, note that when X{0} is encountered as the argument of a free input, the input is converted to a bound input. If X{0} is first encountered at anyother place, an error is signalled byreturning the constant bot.
The encoding of the preorder relation on traces is now straightforward.
crl [Drop] : [ TR1 . b(i,CX,Y) . TR2 ] => [ TR1 . bind(Y , TR2) ]
if bind(Y , TR2) =/= bot .
rl [Delay] : [ ( TR1 . f(i,CX,CY) . b(IO,CU,V) . TR2 ) ] =>
[ ( TR1 . b(IO,CU,V) . ([shiftup V] f(i, CX , CY)) . TR2 ) ] .
crl [Delay] : [ ( TR1 . b(i,CX,Y) . f(IO,CU,CV) . TR2 ) ] =>
[ ( TR1 . bind(Y , f(IO,CU,CV) . f(i,CX,Y{0}) . TR2) ) ]
if bind(Y , f(IO,CU,CV) . f(i,CX,Y{0}) . TR2) =/= bot .
crl [Annihilate] : [ ( TR1 . b(i,CX,Y) . f(o,CX,Y{0}) . TR2 ) ] => [ TR1 . bind(Y , TR2) ]
if bind(Y , TR2) =/= bot .
Note that in the first Delay rule, the channel indices of the free input action are shifted up when it is delayed across a bound action, since it gets into the scope of the bound argument. Similarly, in the second Delay rule, when the bound input action is delayed across a free input/output action, the channel indices of the free action are shifted down bythe bind operation. The other two subcases of the Delay rule, namely, where a free input is to be delayed across a free input or output, and where a bound input is to be delayed across a bound input or output, are not shown as they are similar.

Similarly, for Annihilate, the case where a free input is to be annihilated with a free output is not shown.
Verifying the May Preorder between Finite Processes
We now describe our implementation of verification of the may preorder be- tween finite processes, i.e. processes without replication, by exploiting the trace-based characterization of maytesting discussed in Section 5. The finite- ness of a process P only implies that the length of traces in [|P |] is bounded, but the number of traces in [|P |] can be infinite (even modulo α-equivalence) because the INP rule is infinitely branching. To avoid the problem of having to compare infinite sets, we observe that
[|Q|] - [|P |]  if and onlyif  [|Q|]fn(P,Q) - [|P |]fn(P,Q),
where for a set of traces S and a set of names ρ we define Sρ = {s ∈ S | fn(s) ⊆ ρ}. Now, since the traces in [|P |] and [|Q|] are finite in length, it follows that the sets of traces [|P |]fn(P,Q) and [|Q|]fn(P,Q) are finite modulo α- equivalence. In fact, the set of traces generated for [[fn(P,Q)] P] by our implementation described in Section 3, contains exactly one representative from each α-equivalence class of [|P |]fn(P,Q).
Given processes P and Q, we generate the set of all traces (modulo α- equivalence) of [[fn(P,Q)] P] and [[fn(P,Q)] Q] using the metalevel fa- cilities of Maude 2.0. As mentioned in Section 4, these terms, which are of sort TTrm, can be rewritten only once. The term of sort TraceTrm ob- tained byrewriting contains a finite trace as a prefix. To create the set of all traces, we compute all possible one-step rewrites. This computation is done at the metalevel bythe function TTrmtoNormalTraceSet that uses two auxiliary functions TTrmtoTraceSet and TraceSettoNormalTraceSet.
op TTrmtoTraceSet : Term -> TermSet .
op TraceSettoNormalTraceSet : TermSet -> TermSet . op TTrmtoNormalTraceSet : Term -> TermSet .
eq TTrmtoNormalTraceSet(T) = TraceSettoNormalTraceSet(TTrmtoTraceSet(T)) .
The function TTrmTraceSet uses the function allOneStepAux(T,N) that returns the set of all one-step rewrites (according to the rules in Sections 3 and 4, which are defined in modules named APISEMANTICS and APITRACE, see Figure A.1 in appendix) of the term T which is the metarepresentation of a term of sort TTrm, skipping the first N solutions. In the following equations, the operator u stands for set union.
Notice the use of the operation metaSearch, which receives as arguments the metarepresented module to work in, the starting term for search, the pattern to search for, a side condition (emptyin this case), the kind of search (which maybe ’* for zero or more rewrites, ’+ for one or more rewrites, and ’! for only matching normal forms), the depth of search, and the required solution number. It returns the term matching the pattern, its type, and

the substitution produced by the match; to keep only the term, we use the projection getTerm.
op APITRACE-MOD : -> Module . eq APITRACE-MOD = [’APITRACE] .
var N : MachineInt .	vars T X : Term .
op allOneStepAux : Term MachineInt Term -> TermSet . op TraceTermToTrace : Term -> Term .
eq TTrmtoTraceSet(T) = allOneStepAux(T,0,’X:TraceTrm) . eq allOneStepAux(T,N,X) =
if metaSearch(APITRACE-MOD,T,X,nil,’+,1,N) == failure then ’epsilon.Trace
else TraceTermToTrace(getTerm(metaSearch(APITRACE-MOD,T,X,nil,’+,1,N))) u allOneStepAux(T,N + 1,X) fi .
The function TraceTrmToTrace (whose equations are not shown), used in allOneStepAux, extracts the trace a1.a2...an out of a metarepresenta- tion of a term of sort TraceTrm of the form {a1}{a2}...{an}TT. The function TraceSettoNormalTraceSet uses the metalevel operation metaReduce to con- vert each trace in a trace set to its α-normal form. The operation metaReduce takes as arguments a metarepresented module and a metarepresented term in that module, and returns the metarepresentation of the fullyreduced form of the given term using the equations in the given module, together with its corresponding sort or kind. Again, the projection getTerm leaves only the resulting term.
eq TraceSettoNormalTraceSet(mt) = mt . eq TraceSettoNormalTraceSet(T u TS) =
getTerm(metaReduce(TRACE-MOD,’‘[_‘] [ T ])) u TraceSettoNormalTraceSet(TS) .
We implement the relation - on sets defined in Section 5 as the predicate
<<. We check if P ± Q by computing this predicate on the metarepresented trace sets [|P |]fn(P,Q) and [|Q|]fn(P,Q) as follows. For each (metarepresented) trace T in [|P |]fn(P,Q), we compute the reflexive transitive closure of T with respect to the laws shown in Table 3. The laws are implemented as rewrite rules in the module TRACE-PREORDER. We then use the fact that [|Q|]fn(P,Q) - [|P |]fn(P,Q) if and only if for every trace T in [|P |]fn(P,Q) the closure of T and [|Q|]fn(P,Q) have a common element.
op TRACE-PREORDER-MOD : -> Module .
eq TRACE-PREORDER-MOD = [’TRACE-PREORDER] .
var N : MachineInt .	vars T T1 T2 X : Term . var TS TS1 TS2 : TermSet .
op _<<_ : TermSet TermSet -> Bool . op _<<<_ : TermSet Term -> Bool .
op TTraceClosure : Term -> TermSet .
op TTraceClosureAux : Term Term MachineInt -> TermSet . op _maypre_ : Term Term -> Bool .


eq TS2 << mt = true .
eq TS2 << (T1 u TS1) = TS2 <<< T1 and TS2 << TS1 .
eq TS2 <<< T1 = not disjoint?(TS2 , TTraceClosure(T1)) .
eq T1 maypre T2 = TTrmtoNormalTraceSet(T2) << TTrmtoNormalTraceSet(T1) .
The computation of the closure of T is done bythe function TTraceClosure. It uses TTraceClosureAux to compute all possible (multi-step) rewrites of the term T using the rules defined in the module TRACE-PREORDER, again bymeans of the metalevel operation metaSearch.
eq TTraceClosure(T) = TTraceClosureAux(T,’TT:TTrace,0) . eq TTraceClosureAux(T,X,N) =
if metaSearch(TRACE-PREORDER-MOD,T,X,nil,’*,maxMachineInt,N) == failure then mt
else getTerm(metaSearch(TRACE-PREORDER-MOD,T,X,nil,’*,maxMachineInt,N)) u TTraceClosureAux(T,X,N + 1) fi .
This computation is terminating as the number of traces to which a trace can rewrite using the trace preorder laws is finite modulo α-equivalence. This follows from the fact that the length of a trace is non-increasing across rewrites, and the free names in the target of a rewrite are also free names in the source. Since the closure of a trace is finite, metaSearch can be used to enumerate all the traces in the closure. Note that although the closure of a trace is finite, it is possible to have an infinite rewrite that loops within a subset of the closure. Further, since T is a metarepresentation of a trace, metaSearch can be applied directlyto T inside the function TTraceClosureAux(T,X,N).
We end this section with a small example, which checks for the may-testing preorder between the processes P = a(u).b(v).(νw)(wv|au)+b(u).a(v).(bu|bw) and Q = b(u).(bu|bw). We define constants TP and TQ of sort TTrm, along with the following equations:
eq TP = [[’a{0} ’b{0} ’w{0}]
’a{0}(’u) . ’b{0}(’v) . new[’w](’w{0} < ’v{0} > | ’a{0} < ’u{0} >)
+ ’b{0}(’u) . ’a{0}(’v) . (’b{0} < ’u{0} > | ’b{0} < ’w{0} >)]
eq TQ = [[’a{0} ’b{0} ’w{0}]
’b{0}(’u) . (’b{0} < ’u{0} > | ’b{0} < ’w{0} >)]
The metarepresentation of these TTrms can now be obtained by using ’TP.TTrm and ’TQ.TTrm, and we can then check for the may-testing preorder between the given processes as follows:
Maude> red ’TP.TTrm maypre ’TQ.TTrm .
reduce in APITRACESET : ’TP.TTrm maypre ’TQ.TTrm .
rewrites: 791690 in 2140ms cpu (2160ms real) (361422 rewrites/second) result Bool: true
Maude> red ’TQ.TTrm maypre ’TP.TTrm .
reduce in APITRACESET : ’TQ.TTrm maypre ’TP.TTrm .
rewrites: 664833 in 1620ms cpu (1640ms real) (410390 rewrites/second) result Bool: false
Thus, we have P ± Q, but Q ±/ P . The reader can check that indeed, [|Q|]fn(P,Q) - [|P |]fn(P,Q), but [|P |]fn(P,Q) -/ [|Q|]fn(P,Q).

Conclusions and Future Work
In this paper, we have described an executable specification in Maude of the operational semantics of an asynchronous version of the π-calculus using con- ditional rewrite rules with rewrites in the conditions as proposed by Verdejo and Mart´ı-Oliet in [18], and the CINNI calculus proposed by Stehr in [14] for managing names and their binding. In addition, we also implemented the may-testing preorder for π-calculus processes using the Maude metalevel, where we use the metaSearch operation to calculate the set of all traces for a process and then compare two sets of traces according to a preorder relation between traces. As emphasized throughout the paper, the new features intro- duced in Maude 2.0 have been essential for the development of this executable specification, including rewrites in conditions, the frozen attribute, and the metaSearch operation.
An interesting direction of further work is to extend our implementation to the various typed variants of π-calculus. Two specific typed asynchronous π-calculi for which the work is under way are the local π-calculus (Lπ) [10] and the Actor model [1,15]. Both of these formal systems have been used extensively in formal specification and analysis of concurrent object-oriented languages [2,8], and open distributed and mobile systems [9]. The alternate characterization of may testing for both of these typed calculi was recently published [16,17]. We are extending the work presented here to account for the type systems for these calculi, and modifications to the trace based char- acterization of maytesting. We are also looking for interesting concrete appli- cations to which this can be applied; such experiments mayrequire extending our implementation to extensions of π-calculus with higher level constructs, although these mayjust be syntactic sugar.
Acknowledgements
This research has been supported in part by the Defense Advanced Research Projects Agency(contract numbers F30602-00-2-0586 and F33615-01-C-1907), the ONR MURI Project A Logical Framework for Adaptive System Inter- operability, and the Spanish CICYT project Desarrollo Formal de Sistemas Basados en Agentes Mo´viles (TIC2000–0701–C02–01). This work was done while the last author was visiting the Department of Computer Science in the University of Illinois at Urbana-Champaign, for whose hospitality he is very grateful. We would like to thank Jos´e Meseguer for encouraging us to put together several complementary lines of work in order to get the results described in this paper.

References
G. Agha. Actors: A Model of Concurrent Computation in Distributed Systems. MIT Press, 1986.


G. Agha. Concurrent object-oriented programming. Communications of the ACM, 33(9):125–141, September 1990.
M. Boreale and R. De Nicola.	Testing equivalence for mobile processes.
Information and Computation, 120:279–303, 1995.
M. Boreale, R. De Nicola, and R. Pugliese. Proof techniques for cryptographic processes. In Proceedings 14th IEEE Symposium on Logic in Computer Science, LICS’99, Trento, Italy, July 2–5, 1999, pages 157–166. IEEE Computer Society Press, 1999.
M. Boreale, R. De Nicola, and R. Pugliese. Trace and testing equivalence on asynchronous processes. Information and Computation, 172(2):139–164, 2002.
P. Borovansky´, C. Kirchner, H. Kirchner, P.-E. Moreau, and M. Vittek. ELAN: A logical framework based on computational systems. In J. Meseguer, editor, Proceedings First International Workshop on Rewriting Logic and its Applications, WRLA’96, Asilomar, California, September 3–6, 1996, volume 4 of Electronic Notes in Theoretical Computer Science, pages 35–50. Elsevier, 1996. http://www.elsevier.nl/locate/entcs/volume4.html.
M. Clavel, F. Dura´n, S. Eker, P. Lincoln, N. Mart´ı-Oliet, J. Meseguer, and J.
F. Quesada. Towards Maude 2.0. In K. Futatsugi, editor, Proceedings Third International Workshop on Rewriting Logic and its Applications, WRLA 2000, Kanazawa, Japan, September 18–20, 2000, volume 36 of Electronic Notes in Theoretical Computer Science, pages 297–318. Elsevier, 2000. http://www. elsevier.nl/locate/entcs/volume36.html.
I. A. Mason and C. Talcott.	A semantically sound actor translation.	In
P. Degano, R. Gorrieri, and A. Marchetti-Spaccamela, editors, Automata, Languages and Programming, 24th International Colloquium, ICALP’97, Bologna, Italy, July 7–11, 1997, Proceedings, volume 1256 of Lecture Notes in Computer Science, pages 369–378. Springer-Verlag, 1997.
M. Merro, J. Kleist, and U. Nestmann. Local π-calculus at work: Mobile objects as mobile processes. In J. van Leeuwen et al., editors, Theoretical Computer Science: Exploring New Frontiers of Theoretical Informatics, International Conference IFIP TCS 2000 Sendai, Japan, August 17–19, 2000, Proceedings, volume 1872 of Lecture Notes in Computer Science, pages 390–408. Springer- Verlag, 2000.
M. Merro and D. Sangiorgi.	On asynchrony in name-passing calculi.	In
K. G. Larsen, S. Skyum, and G. Winskel, editors, Automata, Languages and Programming, 25th International Colloquium, ICALP’98, Aalborg, Denmark, July 13–17, 1998, Proceedings, volume 1443 of Lecture Notes in Computer Science, pages 856–867. Springer-Verlag, 1998.
R. Milner, J. Parrow, and D. Walker. A calculus of mobile processes (Parts I and II). Information and Computation, 100:1–77, 1992.
R. De Nicola and M. Hennessy. Testing equivalence for processes. Theoretical Computer Science, 34:83–133, 1984.


G. D. Plotkin. A structural approach to operational semantics. Technical Report DAIMI FN-19, Computer Science Dept., Aarhus University, September 1981.
M.-O. Stehr. CINNI — A generic calculus of explicit substitutions and its application to λ-, ς- and π-calculi. In K. Futatsugi, editor, Proceedings Third International Workshop on Rewriting Logic and its Applications, WRLA 2000, Kanazawa, Japan, September 18–20, 2000, volume 36 of Electronic Notes in Theoretical Computer Science, pages 71–92. Elsevier, 2000. http://www. elsevier.nl/locate/entcs/volume36.html.
C. Talcott. An actor rewriting theory. In J. Meseguer, editor, Proceedings First International Workshop on Rewriting Logic and its Applications, WRLA’96, Asilomar, California, September 3–6, 1996, volume 4 of Electronic Notes in Theoretical Computer Science, pages 360–383. Elsevier, 1996. http://www. elsevier.nl/locate/entcs/volume4.html.
P. Thati, R. Ziaei, and G. Agha. A theory of may testing for actors. In B. Jacobs and A. Rensink, editors, Proceedings IFIP TC6/WG6.1 Fifth International Conference on Formal Methods for Open Object-Based Distributed Systems (FMOODS 2002), March 20-22, 2002, Enschede, The Netherlands, pages 147–
162. Kluwer Academic Publishers, 2002.
P. Thati, R. Ziaei, and G. Agha. A theory of may testing for asynchronous calculi with locality and no name matching. In H. Kirchner and C. Ringeissen, editors, Algebraic Methodology and Software Technology, 9th International Conference, AMAST 2002, Saint-Gilles-les-Bains, Reunion Island, France, September 9-13, 2002, Proceedings, volume 2422 of Lecture Notes in Computer Science, pages 223–238. Springer-Verlag, 2002.
A. Verdejo and N. Mart´ı-Oliet. Implementing CCS in Maude 2. In F. Gadducci and U. Montanari, editors, Proceedings Fourth International Workshop on Rewriting Logic and its Applications, WRLA 2002, Pisa, Italy, September 19– 21, 2002, volume 71 of Electronic Notes in Theoretical Computer Science, pages 239–257. Elsevier, 2002. (This volume.) http://www.elsevier.nl/locate/ entcs/volume71.html.
P. Viry. Input/output for ELAN. In J. Meseguer, editor, Proceedings First International Workshop on Rewriting Logic and its Applications, WRLA’96, Asilomar, California, September 3–6, 1996, volume 4 of Electronic Notes in Theoretical Computer Science, pages 51–64. Elsevier, 1996. http://www. elsevier.nl/locate/entcs/volume4.html.

A  Appendix
The diagram in Figure A.1 illustrates the graph of module importation in our implementation that closelyfollows the structure of the paper. The complete code is available at http://osl.cs.uiuc.edu/~ksen/api/. Here we only show the module that contains the rewrite rules for the operational semantics



NAT CHAN
✏✏QID
✏✏✏✏

CINNI	STRING
✏✏✏✏



TRACzE z
zzzz
TRACE-PREORDER
◗
◗
◗
◗
◗
◗
CHANSET

APISYNTAX
APISEMANTICS	META-LEVEL APITRACE		TERMSET
✟✟✟

✟
APITRACESET
Fig. A.1. The graph of module importation in the implementation.

of asynchronous π-calculus (Table 2). The function genQid used in the condi- tion of the last Res rule generates an identifier that is fresh, i.e. an identifier not used to construct channel names in the set passed as the argument to the function.
mod APISEMANTICS is inc APISYNTAX . inc CHANSET .
inc TRACE .
sorts EnvTrm TraceTrm . subsort EnvTrm < TraceTrm .
op [_]_ : Chanset Trm -> EnvTrm [frozen] .
op {_}_ : Action TraceTrm -> TraceTrm [frozen] . op notinfn : Qid Trm -> Prop .
vars N : Nat .	vars X Y Z : Qid .
vars CX CY : Chan .	var CS CS1 CS2 : Chanset . vars A : Action .	vars P1 Q1 P Q : Trm .
var SUM : SumTrm .	var IO : ActionType .
eq notinfn(X,P) = not X{0} in freenames(P) . rl [Inp] : [CY CS] (CX(X) . P) =>
{f(i,CX,CY)} ([CY CS] ([X := CY] P)) .
rl [Inp] : [CY CS] ((CX(X) . P) + SUM) =>
{f(i,CX,CY)} ([CY CS] ([X := CY] P)) .
rl [Tau] : [CS] (tau . P) => { tauAct } ([CS] P) .
rl [Tau] : [CS] ((tau . P) + SUM) => { tauAct } ([CS] P) .



crl [BInp] : [CS] P => {b(i,CX,’u)} [’u{0} [shiftup ’u] CS] P1 if (not flag in CS) /\
CS1 := flag ’u{0} [shiftup ’u] CS /\
[CS1] [shiftup ’u] P => {f(i,CX,’u{0})} [CS1] P1 .
rl [Out] : [CS] CX < CY > => { f(o,CX,CY) } ([CS] nil) .
crl [Par] : [CS] (P | Q) => {f(IO,CX,CY)} ([CS] (P1 | Q)) if [CS] P => {f(IO,CX,CY)} ([CS] P1) .
crl [Par] : [CS] (P | Q) =>
{b(IO,CX,Y)} [Y{0} ([shiftup Y] CS)] (P1 | [shiftup Y] Q)
if [CS] P => {b(IO,CX,Y)} ([CS1] P1) .
crl [Com] : [CS] (P | Q) => {tauAct} ([CS] (P1 | Q1))
if [CS] P => {f(o,CX,CY)} ([CS] P1) /\
[CY CS] Q => {f(i,CX,CY)} ([CY CS] Q1) .
crl [Close] : [CS] (P | Q) => {tauAct} [CS] new [Y] (P1 | Q1) if [CS] P => {b(o,CX,Y)} [CS1] P1 /\
[Y{0} [shiftup Y] CS] [shiftup Y] Q =>
{f(i,CX,Y{0})} [CS2] Q1 .
crl [Res] : [CS] (new [X] P) =>
{[shiftdown X] f(IO,CX,CY)} [CS] (new [X] P1) if CS1 := [shiftup X] CS /\
[CS1] P => {f(IO,CX,CY)} [CS1] P1 /\ (not X{0} in (CX CY)) .
crl [Res] : [CS] (new [X] P) => {tauAct} [CS] (new [X] P1) if [CS] P => {tauAct} [CS] P1 .
crl [Res] : [CS] (new [X] P) =>
{[shiftdown X] b(o,CX,Z)} [Z{0} CS] new[X]([ Y := Z{0} ] P1)
if Z := genQid(X{0} CS freenames(P)) /\ [[shiftup X] CS] P => {b(o,CX,Y)} [CS1] P1 /\ X{0} =/= CX .
crl [Open] : [CS] (new[X] P) => {[shiftdown X] b(o,CY,X)} [X{0} CS1] P1 if CS1 := [shiftup X] CS /\
[CS1] P => {f(o,CY,X{0})} [CS1] P1 /\ X{0} =/= CY .
crl [If] : [CS1] (if CX = CX then P else Q fi) => {A} [CS2] P1 if [CS1] P => {A} [CS2] P1 .
crl [Else] : [CS1] (if CX = CY then P else Q fi) => {A} [CS2] Q1 if CX =/= CY /\ [CS1] Q => {A} [CS2] Q1 .
crl [Rep] : [CS1] (! P) => {A} [CS2] P1
if [CS1] (P | (! P)) => {A} [CS2] P1 .
endm
