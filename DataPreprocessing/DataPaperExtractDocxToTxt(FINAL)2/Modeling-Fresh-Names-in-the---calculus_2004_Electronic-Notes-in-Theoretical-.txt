Electronic Notes in Theoretical Computer Science 106 (2004) 25–41  
www.elsevier.com/locate/entcs


Modeling Fresh Names in the π-calculus Using Abstractions *
Roberto Bruni1
Dipartimento di Informatica, Universita` di Pisa, Via F. Buonarroti 2, 56127 Pisa, ITALY.
e-mail: bruni@di.unipi.it
Furio Honsell	Marina Lenisa	Marino Miculan
Dipartimento di Matematica e Informatica, Universit`a di Udine, Via delle Scienze 206, 33100 Udine, ITALY.
e-mail: honsell,lenisa,miculan@dimi.uniud.it

Abstract
In this paper, we model fresh names in the π-calculus using abstractions with respect to a new binding operator θ. Both the theory and the metatheory of the π-calculus benefit from this simple extension. The operational semantics of this new calculus is ﬁnitely branching. Bisimulation can be given without mentioning any constraint on names, thus allowing for a straightforward definition of a coalgebraic semantics, within a category of coalgebras over permutation algebras. Following previous work by Montanari and Pistore, we present also a ﬁnite representation for ﬁnitary processes and a finite state verification procedure for bisimilarity, based on the new notion of θ-automaton.
Keywords: π-calculus, binding operator, abstractions, bisimulation, colagebra.


Introduction
The π-calculus [13,18] is a process calculus which provides a conceptual frame- work for understanding mobility via name passing. Processes can communi- cate in a network whose topology can change dynamically by passing, possibly

  Research supported by the EU projects IST-2001-33477 DART, IST-2001-32747 Agile.
1 Partially supported by an Italian cnr fellowship for research on Information Sciences and
Technologies and by the CS Department of the University of Illinois at Urbana-Champaign.


1571-0661 © 2004 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2004.02.039


local, channel names. As for any other foundational calculus, we need strong mathematical tools for expressing mobile systems and reasoning about their behaviours. However, due to the peculiar behaviour of mobile processes and names, the well-known tools and techniques which have been successful for CCS-like languages cannot be straightforwardly extended to the π-calculus.
At the syntactic level, we have the problematic issue of binders and scope of local names. At the operational semantic level, we have the issue of ensuring freshness conditions for names. At the model-theoretic level, we have the issue of providing a coalgebraic (final) semantics. Finally, from the practical point of view, a finite representation for finitary processes is desirable [9,11,14].
All the above issues have been considered in many previous papers. Of- ten, reformulations of the same calculus are introduced, in order to cope with these problematic issues. The question is how to present “best” the calcu- lus, in order to achieve the mathematical structure we need for reasoning on its core computational aspects. The answer to this question depends on the metalogical formalism in which we define the calculus. Recently, for the π- calculus many reformulations, in different metalogics, have been presented. A first-order, de Bruijn-like approach is adopted in [14,3], where processes can be equipped with explicit permutations of names. A second-order approach, based on Higher-Order Abstract Syntax, is adopted in [9,10,12], where most issues about freshness of names are simplified, taking advantage of the meta- logic notion of capture-avoiding substitution. A somehow mid-way approach is in [6], where the reformulation is given in the logic of Frænkel-Mostowski models of first-order set theory (i.e., sets with atoms and permutations).
In this paper, we provide yet another formulation of the π-calculus with the aim of expressing generation of fresh names at every level (syntactic, semantic and implementative), and still keeping the metalogical overhead as low as possible. In fact, the calculus that we will present in Section 3, is just a conservative extension of the ordinary π-calculus with a new unary binding operator θ; for this reason, it is called the πθ-calculus. This extension is suggested by the higher order presentations of the π-calculus as in [9,10,12,5]. The operator θ allows to explain “fresh” names as “locally θ-bound” names.
A transition which needs a fresh name is rendered as a transition to a θ- abstracted process, i.e. where the fresh name is θ-bound. As we will see, many aspects of the treatment of the theory and metatheory of the π-calculus will benefit from this simple extension. Differently from the π-calculus, in the πθ- calculus also actions are taken up-to α-conversion, yielding a ﬁnitely branch- ing semantics w.r.t. fresh names (Of course, a process may be still infinitely branching due to recursion). For example, while the π-process (νy)x¯y.P can
x¯(z)
evolve via (νy)x¯y.P −→ P {z/y} for any fresh name z (and thus it is infinitely



branching), the πθ-process has just one move (νy)x¯y.P
(θy)x¯y
−→ (θy)P .

Bisimulation on the πθ-calculus can be given without any constraint on bound names in labels. This allows for a direct re-use of the techniques in [1,2,16] for defining a coalgebraic semantics. In particular, the semantics of a process is finitely branching without being parametrized by the set of names of possible partners, as was the case in [9]. Moreover, our semantics is ﬁnitary, in the sense that any ﬁnitary process, i.e. with a bound degree of parallelism, gives rise to a finite set of descendant processes, up-to vacuous bound names (i.e. abstracted names which do not appear in the body of the process) and ordinary structural congruence.
In Section 4 we define the coalgebraic semantics within a category Alg π of permutation algebras, following [14]. The algebra structure we consider is induced by a countable family of unary permutation operators {ρi}i∈ω. The fact that our coalgebraic semantics is an algebra homomorphism allows us to derive interesting properties on active names of processes in the final model. In order to get a truly finite representation for finitary processes, in Sec- tion 5 we introduce the notion of θ-automaton. This is the counterpart, in our second-order setting, of the notion of History Dependent Automaton of [14]. We associate to each πθ-process a θ-automaton which is finite in case the orig- inal process is finitary. States of θ-automata are given by collapsing the orbits of processes under the action of vacuous θ-operators. We introduce a notion of bisimulation on the states of θ-automata. Bisimilarity between π-calculus processes can be (finitely) verified by checking the bisimilarity relation on the
corresponding θ-automata.
Conclusions, related work, and directions for future work are in Section 6.

The π-calculus
In this section, we introduce briefly the π-calculus; see [13,15] for more details. In particular, we introduce the syntax of the language, the early operational semantics, and the equivalence relation of early bisimilarity.
In the π-calculus there are only two primitive entities: names and processes (or agents). Let N be an infinite set of names, ranged over by x, y. The set of processes P, ranged over by P , Q, are closed terms (w.r.t. process variables Z) defined by the abstract syntax:
P ::= 0 | x¯y.P | x(y).P | τ.P | (νx)P | Z | rec Z.P | P1|P2 | [x = y]P
where the bound process variable Z must be guarded in rec Z.P . The operators are listed in decreasing order of precedence. The input preﬁx operator x(y) and


the restriction operator (νy) bind the occurrences of y in x(y).P and (νy)P respectively. Thus, for each process P we can define the sets of its free names fn(P ), bound names bn(P ) and names n(P )  fn(P ) ∪ bn(P ). Processes are taken up-to α-equivalence, which is defined as expected. Capture-avoiding substitution of a single name y in place of x in P is denoted by P {y/x}.
We denote by PX , where X is a finite set of names, the subset of π-calculus processes whose free names are in X.
There is a plethora of slightly different labeled transition systems for the operational semantics of the π-calculus, see e.g. [13,15,18]. Here, we present
µ
the original one for early operational semantics [13]: the relation −→ is the
smallest relation over processes satisfying the rules in Figure 1. (The right versions of rules PAR, COM and CLOSE have been omitted.)
The early operational semantics exploits four actions, defined by the syntax (L e) µ ::= τ | xy | x¯y | x¯(z). Their intuitive meaning is the following:

silent action: P
−τ→ Q means that P can reduce itself to Q without inter-

acting with other processes;
x¯y
free output: P −→ Q means that P can reduce itself to Q emitting the
name y on the channel x;
xy
free input: P −→ Q means that P can receive from the channel x the name
y and then evolve into Q;
x(z)
bound output: P −→ Q means that P can evolve into Q emitting on the
channel x a name z, which is bound in P (but not in Q); only upon synchro- nization, z will be shared with the receiving agents and restricted again.
The functions fn(·) and bn(·) are extended to actions, by putting fn(x¯(z)) =
{x}, fn(xy) = fn(x¯y) = {x, y}, fn(τ ) = bn(τ ) = bn(xy) = bn(x¯y) = ∅,
bn(x¯(z)) = {z}. As usual, n(µ)  fn(µ) ∪ bn(µ).
The τ and free input and free output actions are called free, the remaining ones are called bound. Note that actions are not taken up-to α-equivalence.




Definition 2.1 [Early Bisimilarity] A symmetric relation R over π-calculus processes is an early bisimulation iff, for all processes P, Q, if P R Q then
for each P −µ→ P ' with bn(µ) ∩ fn(P, Q)= ∅ then there exists Q' such that
Q −→ Q' and P ' R Q'.
The early bisimilarity ∼ is the greatest early bisimulation.



—


xy
x(z).P −→ P {y/z}
(IN)
—
τ.P −τ→ P
(TAU)

P −→
P '  Q x(y) Q'

y /∈ fn(P ) (CLOSE )
—
xy
xy.P	P
(OUT)



P |Q −τ→ (νy)(P '|Q')
µ
−→ P
l	−→

P −→ P '

y /= x (OPEN)

(νy)P −µ→ (νy)P '
y /∈ n(µ)	(RES)
(νy)P x(y) P '

P −µ→ P '
P −→ P '
(MATCH)

P |Q  µ  P '|Q
bn(µ) ∩ fn(Q)= ∅	(PARl)
[x = x]P −µ→ P '

P {rec Z.P/Z} −→ P '


(UNFOLD)
P −→ P ' Q −x→y  Q'
τ
(COMl)

rec Z.P −µ→ P '
P |Q −→ P '|Q'

Fig. 1. Early Operational semantics of the π-calculus.
The πθ-calculus
In this section, we introduce the πθ-calculus, an extension of the π-calculus, where processes can be prefixed possibly by a finite sequence of the new bind- ing operator θ. This new operator can be used to take care of the allocation of fresh names; essentially, it allows to model a fresh name using a bound name.

Syntax
The sets of πθ-processes Pθ and πθ-actions Lθ are defined as follows:
Pθ  {(θx1) ... (θxn)P | P ∈ P, x1,... , xn ∈ N , n ≥ 0}
Lθ  {(θx1) ... (θxn)µ | µ ∈ Lf ∪ Lb, x1,..., xn ∈ N , n ≥ 0}
where P is the set of π-calculus processes, Lf is the set of free actions, i.e., τ , free input and free output, and Lb is the set of bound actions, i.e. bound input, x(y), and bound output, x¯(y), where x() and x¯( ) bind y. By abuse of notation, P, Q and µ will range also over Pθ and Lθ, respectively. We will use the abbreviations (θx)P and (θx)µ for the process (θx1) ... (θxn)P , and for the label (θx1) ... (θxn)µ, respectively, where P and µ are θ-free. The operator θ binds the occurrences of x1 ... xn in (θx)P and in (θx)µ. Both processes and labels are taken up-to α-equivalence; hence, without loss of generality, x1,... , xn in x can always be assumed to be all distinct (e.g., (θxx)P is the same as (θxy)P {y/x} and (θyx)P , for y not free in P ).
For X a finite set of names, we denote by Pθ and Lθ , the sets of πθ-
processes and πθ-labels whose free names are in X, respectively. The set of



—
(TAU)
P xy	U	P '

τ.P −→τ	P
	−→X {y}	
(OPEN)

X	x(y)
—	(νy)P −→X
(θy)P '

x(y).P −x→z
z ∈ X
P {z/y}
P {rec Z.P/Z	P '

X		} −→X	
(UNFOLD)

(IN)
rec Z.P −→
X P '

—	θ	P −→	P '

x(y)
(IN ) 	X	
(MATCH)

x(y).P −→X (θy)P
[x = x]P −→X P '

—


xy.P −→	P
(OUT)
µ
P −→X
µ
U{y} P '
y /∈ fn(µ), µ ∈ Lf (RES)

X
P	µ	P '
(νy)P −→X (νy)P '
µ

	−→X	
µ ∈L 
(PAR )	P −→X U{y} (θz)P '

µ	'	f
l		 y /∈ fn(µ)	(RESθ)

P |Q −→X P |Q
µ
(νy)P
(θz)(νy)P '

P −→	(θx)P '
−→X

	X		(PARθ)
x(y)
P
'	x¯(y)	'

µ
P |Q
(θx)P '|Q
l	 −→X (θy)P	Q −→X (θy)Q
(CLOSE )

−→X
xy
P

xy	'
P |Q −→τ
l
X (νy)P '|Q'

  −→X P	Q −→X Q
(COM )	P −→ U	Q

P |Q −→τ	P '|Q'
X
l	X  {x}

(θx)µ
(THETA)

(θx)P −→ X (θx)Q
Fig. 2. Early Operational semantics of the πθ-calculus.
closed πθ-processes is Pθ. The occurrence (θxi) in the process (θx1 ... xn)P
is vacuous if xi /∈ fn(P ).
The process (θx)P can be viewed as the representation of a process ab- straction obtained by instantiating P with a fresh name; the name which has to be fresh remains bound in P so that its freshness is guaranteed implicitly. In a sense, θ-abstractions resemble the λ-abstractions of the alternative pre- sentations of the π-calculus in, e.g., [15, §5.5]. However, our aims are different; in fact, we do not have a notion of “application” (i.e., concretion).

Operational Semantics
The operational semantics of the πθ-calculus is given by a family of relations. For X a finite set of names, the relation


−→X ⊆ Pθ
× Lθ
× Pθ

is defined as the smallest relation satisfying the rules in Figure 2. By definition,
(θy)µ
for any transition of the form (θx)P −→ X (θz)Q, we have fn((θy)µ, (θz)Q) ⊆
fn((θx)P ). Hence, if (θx)P is closed, then X can be set to ∅.
Note that there are two input rules, IN and INθ. In rule IN the bound


name is instantiated with a “previously known” name z in X. Rule INθ takes care of the instantiation with a fresh name, by creating a new θ-bound name
y. In this way, all π-calculus input transitions differing by the choice of the new name are collapsed (by α-rule) in a single transition, and the πθ-system becomes finitely branching. As in rule INθ, also in rule OPEN, the allocation of a fresh name is delegated to the constructor θ. The rules PAR and RES are duplicated, to take into account the case in which a θ-bound name appears in the target process. 2
We remark that (νx)P and (θx)P behave differently, in general. Namely, rules RES and OPEN do not allow for actions whose subject is exactly x, while the process (θx)P could make any transition under θ.
The following lemma clarifies the rˆole of θ, and it is the counterpart of [13, Lemma 3] for the πθ-calculus.
Lemma 3.1 For all X ﬁnite, for all (θx)P ∈ Pθ :
(θx)µ	µ

for all (θx)Q, (θx)µ:	(θx)P
−→ X (θx)Q	iff	P −→→X∪{x} Q;

(θx)µ	µ

for all (θxy)Q, (θx)µ:	(θx)P
−→→X (θxy)Q	iff	P −→→X∪{x} (θy)Q.

We can draw a precise correspondence between π- and πθ-derivations:
Proposition 3.2 For all X ﬁnite, for all z not in X, and P ∈ PX∪{z},
x, y ∈ N :

P −τ→ Q iff (θz)P (θz)τ
(θz)Q;

x¯y
P −→ Q iff (θz)P
(θz)x¯y
−→→ X (θz)Q;

⎛ if y ∈ X ∪ {z} then (θz)P (θz)xy	(θz)Q	⎞

P −→ Q iff ⎝
else (θz)P
(θz)x(y)
−→→
;
X (θzy)Q

x¯(y)
P −→ Q iff (θz)P
(θz)x¯(y)
−→→
X (θzy)Q.

The proof of Proposition 3.2 is straightforward by mutual induction on the structure of derivations. In particular, when z is empty:
Corollary 3.3 For all X ﬁnite, for all P ∈ PX, for all x, y ∈ N :
P −τ→ Q iff P −→τ→ Q;

P −x¯→y
Q iff P −→→X Q;

P −x→y

Q iff  if y ∈ X then P −x→→y
x(y)
Q else P −→→X
(θy)Q ;

2 Strictly speaking, the side conditions “z ∈ X” of rule IN and “y /∈ fn(µ)” of rules RES
and RESθ are redundant, because they are always ensured by the type of —→→X .


x¯(y)	x¯(y)
P −→ Q iff P −→→X (θy)Q.
The relations −→X can be seen as a family of coherent “approximations” of the usual early operational semantics. We can recover this semantics by taking the union of all approximations: for µ action of the πθ-calculus, we

µ
define −→
µ
X −→X
. In the following of the paper, we could safely drop

the X parameter and consider directly the union of all transition systems; the
consequence would be that the operational semantics would be not finitely branching any more. Indeed, each −→X is truly finitely branching (because the names which can be chosen in the rule IN must belong to X, which is finite), but since X ranges over all finite sets, in −→ a process x(y)P may have infinitely many successors, one for each name. Therefore, we prefer to keep the X parameter, in order to provide a sharper analysis of the system.

Bisimulation
We can now introduce a notion of bisimulation on πθ-processes, which provides an alternative characterization of early bisimilar processes.
Definition 3.4 [Early θ-bisimilarity] Let X be a finite set of names. A sym-

metric relation RX ⊆ Pθ
× Pθ
is an early θ-bisimulation at stage X iff, for

all P, Q ∈ Pθ processes, P RX Q implies:

if P −→µ
P ', then there exists Q' such that Q −→µ
X Q' and P ' RX Q'.

The early θ-bisimilarity at stage X, ≈X, is the greatest early θ-bisimulation at stage X. The early θ-bisimilarity ≈ is defined as ≈	X ≈X.
Notice that the notion of early θ-bisimilarity depends, for generic processes, on their free names. Again we could disregard X completely. Anyway, for θ- closed processes, any reference to names disappears altogether. What is more significant, however, is that for all (possibly open) processes, the side condi- tion on the freshness of names necessary for bound output in Definition 2.1 disappears, being implicit in the fact that the new name is bound by θ in P ', Q'. The price to pay is that each time a fresh name is needed, an extra (possibly vacuous) θ is generated, and the set of processes reached during the evolution of a finitary process is finite, only up-to vacuous θ’s.
Example 3.5 Let us consider the recursive process P = rec Z.(νy).x¯y.Z ∈ PX, where X = {x}. In the π-calculus, the process P can evolve into itself,
x¯(y)	x¯(y)
i.e. P −→ P −→ ... while, in the πθ-calculus, P can evolve as follows:


x¯(y0 )
P −→ X (θy0)P
(θy0)x¯(y1 )
−→ X (θy0y1)P
(θy0 y1)x¯(y2 )
−→	X (θy0y1y2)P −→X ... 


Notice that the states reached by P after a finite number of transition steps differ by a finite number of vacuous θ’s.
The following lemma can be viewed as the “higher order” version of [13, Lemma 6], and it is instrumental to prove Theorem 3.7 below.
Lemma 3.6 Let (θx)P, (θx)Q ∈ Pθ . Then (θx)P ≈X(θx)Q iff P ≈X∪{x}Q.
As a main correspondence result, θ-bisimilarity is a conservative extension of usual bisimilarity:
Theorem 3.7 Let P, Q ∈ P. Then P ∼ Q	iff	P ≈ Q.
Proof. Both directions are proved by coinduction, using Proposition 3.2. (⇒) We prove that the relation
R = {((θx1 ... xn)P, (θx1 ... xn)Q | n ≥ 0, x1,..., xn ∈N ∧ P ∼ Q}
is an early θ-bisimulation at stage X, for X ⊇ fn(P, Q).
(⇐) Using Lemma 3.6, we prove that the relation R = {(P, Q) | P ≈ Q} is an early bisimulation.	 
Remark 3.8 In the light of Lemma 3.6, one could wonder whether it is possi- ble to simplify our notion of early θ-bisimulation, by getting rid of redundant vacuous θ’s. This would allows us to overcome the problem highlighted by Example 3.5. But even if we restrict ourselves to processes whose occurrences of names are all active 3 , independent elimination of vacuous θ’s is not safe, as we can see from the counterexample below.
Example 3.9 Let P = (νx)w¯x.(νy)x¯y.u¯x.0, Q = (νx)w¯x.(νy)x¯y.u¯y.0. Then P and Q are not early bisimilar, because the last action of P consists in communicating the first extruded name, while Q communicates the second extruded name. But P and Q turn out to be erroneously equated if we elimi- nate vacuous θ’s. Namely, after two transition steps P reduces to (θxy)u¯x.0, and Q reduces to (θxy)u¯y.0, but, since θy is vacuous in the first process, while θx is vacuous in the latter, we reduce ourselves to considering the pair of processes (θx)u¯x and (θy)u¯y, which turn out to be α-equivalent and thus bisimilar.

Finitary Coalgebraic Semantics
In this section, we capitalize on the results of the previous sections, in or- der to give a coalgebraic description of early bisimilarity which is both not parametrized on sets of names as well as ﬁnitary (up-to structural congruence

3 An occurence of a name is active in P if it appears in an action in the evolution of P .


and vacuous bound names) for finitary processes. We focus on closed πθ- processes, since, by Lemma 3.6, bisimilarity of (possibly open) πθ-processes can always be reduced to bisimilarity of θ-closed processes.
Recall that a T -coalgebra on a category C (e.g. Set), where T is an end- ofunctor, is a pair (A, α), where A is an object of C and α : A → T (A) is an arrow of C. A T -coalgebra morphism h : (A, α) → (B, β) is an arrow h : A → B of C (e.g., a function when C = Set), such that β ◦ h = T (h) ◦ α. According to the final semantics approach [1,2,16], the operational seman- tics of a calculus is represented as a T -coalgebra for a suitable endofunctor T . If the functor is “well-behaved,” there exists a ﬁnal T -coalgebra, say Ω = (Ω, αΩ). Moreover, for any T -coalgebra (A, α), the unique arrow M : (A, α) → (Ω, αΩ) induces an equivalence on A which is the categorical counterpart of the ordi- nary notion of bisimulation: a T -bisimulation on (A, α) is a relation R⊆ A×A for which there exists an arrow γ : R→ T (R), such that the projections π1, π2
can be lifted to T -coalgebra morphisms from (R, γ) to (A, α).
In order to take advantage of the algebraic structure of θ-operators and be able to capture the number of active names in processes, we work in a category of structured coalgebras. We consider coalgebras over the category Algπ of permutation algebras [14], which we recall next.
Let us consider the permutations of the set of natural numbers {1, 2, 3 ... }. The kernel of a permutation π is the set ker(π) {i | π(i) /= i}. We denote by permfk  {π | ker(π) finite} the countable group of ﬁnite-kernel permutations.
Definition 4.1 [permutation signature and algebras] The signature Σπ is given by the set of finite-kernel permutations, together with the axioms schemata id(x)= x and π1(π2(x)) = (π1π2)(x).
A permutation algebra A = (A, {πA}) is an algebra for Σπ. A permutation
morphism σ : A→B is an algebra morphism, i.e., a function σ : A → B such that σ(πA(x)) = πB(σ(x)). Finally, Alg (Σπ) (shortened as Alg π ) denotes the category of permutation algebras and their morphisms.
The set Pθ of closed πθ-calculus processes can be endowed with a structure of a permutation algebra. For π ∈ permfk , and n ∈ ω, let us define maxn π max{π(i) | i = 1,... , n} (thus maxn π ≥ n). We define the name reindexing

operator ρπ : Pθ → Pθ as ρπ((θx)P )  (θx1 ... xmax
π)P [π], where P [π] de-

notes the process obtained by the application of π to the free names occurring in P . Let ρ be the countable set of unary operators ρ  {ρπ | π ∈ permfk }.
Proposition 4.2 The pair (Pθ, ρ) is a permutation algebra.
The operational semantics induces a structure of coalgebra on the permu- tation algebra of closed πθ-processes for a functor similar to that of CCS:


Definition 4.3 Let T : Alg π → Algπ be the functor defined by the canonical extension to arrows of the function:
T (A, ρA)   ℘ (Lθ × A), ρ℘f(Lθ ×A) = {ρ℘f(Lθ ×A) | π ∈ permfk } 
where, for any u ∈ ℘f(Lθ × A), π ∈ permfk ,


ρ℘f(Lθ ×A)(u) = {((θx
...x 
)µ[π],ρ a) | ((θx
... x
)µ, a) ∈ u}

π	1	maxn π	π	1	n
Proposition 4.4 Let α : (Pθ, ρ) → T (Pθ, ρ) be deﬁned as α(P )  {(µ, Q) |
∅	∅
P  µ	θ
−→→∅ Q}. Then, Cπθ  (P∅ , ρ, α) is a T -coalgebra.
Since T is the lifting of the corresponding polynomial functor Ts : Set → Set, by [4, Proposition 28] we can lift the adjuction F E V (where F : Set → Algπ is the free construction and V : Alg π → Set is the forgetful functor) to the categories of Ts-coalgebras and T -coalgebras, thus obtaining an adjunction
 FT  
Ts-Coalg¸⊥  T -Coalg. We have therefore the following:
VT

Proposition 4.5 The functor T : Alg π → Algπ has a ﬁnal coalgebra Ω = (Ω, ρΩ, αΩ), and moreover VT (Ω) is the ﬁnal Ts-coalgebra.
Proof. The final coalgebra is given by RT (1), where RT : Alg π → T -Coalg is the right adjoint of the forgetful functor.	 
Remark 4.6 One may wonder whether Proposition 4.4 still holds if we con- sider other constructors in the algebraic structure beside ρ’s. The point is that α has to be a morphism between permutation algebras, i.e. it has to respect the algebraic structures. This holds for ν, | (providing an alternative proof that bisimilarity is a congruence w.r.t. ν, |) but it does not hold in the case of input prefix. For example, let us consider the operator ιzx(·) = z(x).· acting on processes as follows: ιzx((θy)P ) (θyz)z(x).P . If P = (θyw)y¯w, then α(ιzx(P )) /= T (ιzx)(α(P )), whatever is the action of ιzx on labels.
Using Lemma 3.6 and Theorem 3.7, we can easily prove that:
Theorem 4.7 Let P, Q ∈P be such that (θx)P, (θx)Q ∈ Pθ. Then P ∼ Q iff there exists a T -bisimulation R on the coalgebra Cπθ such that (θx)P R (θx)Q.
The following proposition characterizes T -bisimilarity by finality and hence, by Theorem 4.7, also bisimilarity on π-calculus processes.
Proposition 4.8 The equivalence induced by the unique morphism M : Cπθ →
Ω coincides with the union of all T -bisimulations on the T -coalgebra Cπθ.


Finally, we can put to use the permutation algebraic structure of coalge- bras. In [14], the structure of coalgebras given by permutation algebras was used to show that the support of the interpretation of a π-calculus process in the final model amounts exactly to the active names of the process. In our setting we can obtain a similar result:
Proposition 4.9 For (θx)P ∈ Pθ and n = |x|, the family {ρΩ(M((θx)P )) |
∅	π
π ∈ permfk , π({1 ... n}) ⊆ {1 ... n}} has at most n!/k! distinct elements,
where k is the number of active names of P.
Proof. (Outline) The action of ρΩ commutes with the final semantics. By definition of active names, swapping non-active names in the process does not change its bisimilarity class. Therefore, the number of distinct elements in the family {ρΩ(M((θx)P )) | π ∈ permfk , π({1 ... n}) ⊆ {1 ... n}} is bounded by the number of different permutations of n objects, k of which are equal. 

θ-automata
In this section, drawing inspiration from [14], we introduce a notion of au- tomaton, called θ-automaton, for representing in a ﬁnite way the evolution of ﬁnitary πθ-processes. These are processes whose descendants have a bounded number of possible parallel actions (degree of parallelism):
Definition 5.1 [Finitary processes] The degree of parallelism deg(P ) of a πθ- process P is defined as follows (for π a generic action prefix):
deg(0) = deg(Z)  0	deg(π.P )  1	deg(P | Q)  deg(P )+ deg(Q) deg((νx)P )= deg((θx)P )= deg([x = y]P ) = deg(rec Z.P )  deg(P )


Let P ∈ Pθ ; the set of descendants of P is des(P )  {Q | P −→∗
Q}, where

X	X
−→∗ is the reflexive and transitive closure of −→X. A process P ∈ Pθ is
ﬁnitary if deg(P )  sup{deg(Q) | Q ∈ des(P )} < ∞.
Structurally congruent πθ-processes will be represented by the same state:
Definition 5.2 [Structural Congruence] The structural congruence ≡ on π- calculus processes is the smallest congruence that satisfies the following:
(par)	P | 0 ≡ P	P | Q ≡ Q | P	P | (Q | R) ≡ (P | Q) | R
(res)	(νx)0 ≡ 0	(νx)(P | Q) ≡ P | (νx)Q, if x /∈ fn(P )
(νx)(νy)P ≡ (νy)(νx)P	(νx)π.P ≡ π.(νx)P, if x /∈ fn(π)
(match) [x = x]P ≡ P	[x = y]0 ≡ 0	(unfold) rec Z.P ≡ P {rec Z.P/Z}


where π stands for a generic action/matching prefix.
The πθ-processes (θx)P , (θx)Q are structurally congruent (also denoted by ≡) if and only if P ≡ Q.
For each class S ⊆ Pθ of congruent processes, let us fix a representative process P such that |fn(P )| = min{|fn(Q)|| Q ∈ S}.
Moreover, since processes differing by vacuous θ’s will be collapsed in the same state of the θ-automaton, we need to introduce a canonical represen- tative for classes of congruent processes together with all processes differing by vacuous θ’s. For the sake of simplicity, but without loss of generality by Lemma 3.6, we introduce θ-automata only for closed πθ-processes.
Definition 5.3 [canonical terms, orbit] A πθ-process (θx1 ... xn)P ∈ Pθ is
canonical if it is the representative of a ≡-class and xi ∈ fn(P ), for all 1 ≤
i ≤ n. Let can(Pθ) denote the set of canonical πθ-processes.
For a canonical process (θx)P , we define its orbit as the set
orbit((θx)P )  {(θz0x1 ... zn−1xnzn)P ' ∈ Pθ | P ' ≡ P ∧
|z0|,... , |zn|≥ 0 ∧ ∀i, j.xj /∈ zi}.
We denote the normalization function by  ·  : Pθ → can(Pθ), defined by
∅	∅
 (θx1 ... xn)P   (θy1 ... ym)P ', where P ' is the representative of the equiva-
lence class of P , {y1,... , ym} = fn(P '), and x1 ... xn = z0y1z1 ... ymzm (where
|zi| ≥ 0). The reindexing of (θx1 ... xn)P is the partial strictly monotone function ξ((θx1 ... xn)P ) defined by ξ((θx1 ... xn)P )(i)= j ⇐⇒ xi = yj.
In the following, we denote by M(n, m) the set of partial strictly monotone functions from {1,... , n} to {1,... , m}.
Definition 5.4 [θ-automaton] Let P ∈ Pθ. The θ-automaton AP induced by
P is the triple (S, P  , '→), where:
S is the set of states. Each state is the orbit of the canonical process corresponding to a descendant of P , and it is denoted by the canonical representative itself.
 P  is the initial state.
'→⊆ S × Lθ ×S is the transition relation defined by:


P → P iff there exists P ' such that P −→
P ' and P '  = P .

1	2	2
1	∅	2	2	2

In order to prove the fundamental Theorem 5.7 below, which motivates the notion of θ-automaton, we first need the following technical definition.


Definition 5.5 Let P be a πθ-process (possibly with free process variables). The set of subprocesses of P is defined as sub(P )  {P }∪ sub '(P ), where:
sub'(0) = sub'(Z)   ∅	sub'(P |Q)  sub(P ) ∪ sub(Q)
sub'(π.P )= sub'([x = y]P )= sub'((νx)P )= sub'((θx)P )  sub(P )
sub'(rec Z.P )   {Q{rec Z.P/Z}| Q ∈ sub(P )}
Lemma 5.6 If P ∈ Pθ, then the set sub(P ) is ﬁnite, and for all Q ∈ sub(P ): sub(Q) ⊆ sub(P ).
Theorem 5.7 Let (θx)P ∈ Pθ be a ﬁnitary process. Then A(θx)P is ﬁnite.

Proof. Let n0 = deg(P ), and Q be any descendant of (θx)P . Then, by definition of ≡, either Q admits a canonical form Q ≡ (θz)(νy)(Q1| ... |Qn), where n ≤ n0, and Qi are sequential processes (i.e., non-null processes whose top operator is either an action prefix or a non-trivial matching) or Q ≡ (θz)0. Moreover, by the definition of the transition system, each component Qi is a subprocess of P , up-to-≡ and (possibly non injective) name substitution, i.e. Qi ≡ Piσ, for a name substitution σ, and Pi is a subprocess of P . Since the subprocesses of P are finite, then there are only finitely many possible Qi, up-to bijective name substitutions. Moreover, the number of free names in Qi is bounded by the number of (either free or bound) names in P , n(P ), and hence the number of non vacuous ν’s and θ’s in (θz)(νy)(Q1 | ... | Qn) is bounded by n0 × |n(P )|. Hence, the number of descendants Q of a finitary process is finite, up-to-≡ and vacuous θ’s.	 
One can easily check that the θ-automaton corresponding to (the θ-closure of) the recursive process of Example 3.5 is finite (actually it consists of exactly one state and one transition edge).
One could develop a complete theory of θ-automata, and recover classi- cal results, such as minimalization. But here we shall only investigate how to use θ-automata in order to devise an effective procedure for establishing bisimilarity of πθ-processes. Given two processes, in order to use the induced θ-automata to check bisimilarity, we need to keep track, at each step, of the correspondence between θ-bound names in the canonical processes (Exam- ple 3.9 shows that elimination of vacuous θ’s could otherwise compromise bisimilarity). To this aim, we use a finitary reindexing function, mapping the positions of variables which have to be identified in the two processes. Let us denote by M the set n,m∈ω M(n, m):
Definition 5.8 [Indexed Bisimilarity] Let us consider two θ-automata A = (S, P0, '→) and A' = (S', Q0, '→'). An indexed bisimulation R ⊆ S × M × S' is a relation such that, for (θx)P ∈ S, (θy)Q ∈ S', for f ∈ M(|x|, |y|), if

((θx)P, f, (θy)Q) ∈R then: let dom(f )= {i1,... , ik}, x = u0xi1 u1 ... xik uk,
y = v0yf(i1 )v1 ... yf(ik)vk, x ∩ y = ∅, z = u0v0xi1 u1v1 ... xik ukvk,

(θz)µ
if (θz)P −→ ∅
(θz)P ', then there exists (θz)Q' such that

(θz)Q{xi1
/yf (i1 )
,..., xik
(θz)µ
/yf (ik)} −→ ∅
(θz)Q'

· (  (θz)P '  ,f ', (θz)Q')   ∈R, where f ' = ξ((θz)Q') ◦ (ξ((θz)P '))−1.

(θz)µ
if (θz)P −→ ∅
(θzz')P ', then there exists (θzz')Q' such that

(θz)Q{xi1
/yf (i1 )
,..., xik
(θz)µ
/yf (ik)} −→ ∅
(θzz')Q'

(  (θzz')P '  ,f ', (θzz')Q')   ∈R), where f ' = f1 ∪ f2,
f1 = ξ((θzz')Q') ◦ (ξ((θzz')P '))−1 and
  {(max(dom(f1)) + 1, max(cod(f1)) + 1)}	if z' ∈ fn(P ') ∩ fn(Q')

((θy)Q, f −1, (θx)P ) ∈R .
The indexed bisimilarity, , is the greatest indexed bisimulation. We say that the automata A and A' are f-bisimilar if (P0, f, Q0) ∈ , for some f ∈ M(|x|, |y|).
Using Lemma 3.6, one can prove that:
Theorem 5.9 Let P, Q ∈ P{x1,...,xn}. Then, P ∼ Q iff A(θx)P and A(θx)Q are
f-bisimilar, for f = ξ((θx)Q) ◦ (ξ((θx)P ))−1.
If the sets of states S and S' of the automata are finite, then indexed bisimulations are finite objects.
Theorem 5.10 Let A(θx)P = (S, (θx)P  , '→), A(θx)Q = (S', (θx)Q  , '→'), for P, Q ∈ P{x1 ,...,xn} ﬁnitary. Then P ∼ Q iff there exists an indexed bisimu- lation R⊆S ×M(k, k) ×S', with k = max(deg(P ) ×|n(P )|, deg(Q) ×|n(Q)|), such that (  (θx)P  , f, (θx)Q  ) ∈ R, where f = ξ((θx)Q) ◦ (ξ((θx)P ))−1.
Notice that k is an upper bound of the domain of the reindexing functions between all descendents of P and Q. Thus, since M(k, k) is finite, there are only finitely many candidate relations to be indexed bisimulations. Hence, we have an algorithm for deciding bisimilarity of finitary processes.

Final Remarks and Directions for Future Work
In this paper, we have introduced the πθ-calculus, a conservative extension of the π-calculus, which allows to explain away the mechanism of name creation by means of a new unary binding operator. We have used the πθ-calculus to


give a coalgebraic description of early bisimilarity. This semantics is finitary, in the sense that it is finitely branching and moreover, for any finitary process, the set of descendants is finite, up-to vacuous θ’s and structural congruence. Furthermore, we have also introduced θ-automata which we use to get a truly finite representation for finitary processes, by equating in a single state a process together with all the processes differing from it by sequences of vacuous θ’s and structural congruence. We could push further the study of θ- automata, by introducing a general notion of θ-automaton, independent from the π-calculus. Standard results on automata such as minimalization could then be naturally recovered. Moreover, there should be a corresponding notion
of transition system, generalizing the transition system of the πθ-calculus.
In [14], an alternative finitary coalgebraic semantics for the π-calculus is proposed for early bisimilarity, and a corresponding notion of automaton, the History Dependent Automaton, is discussed. The problem of generating a fresh name in bound output transitions is solved by applying a suitable permutation on the names of the process, so as to guarantee that a special concrete name is always fresh in the permuted process. This latter name is the new name used in the bound output transition. In a loose sense, this can be viewed as a first-order approach, whereas the one using θ-closure operators of this paper is second-order. However, it is an interesting future work to investigate which is the precise connection between HD-automata and θ-automata, and to understand which class of automata provides a more convenient (i.e. more compact, easier to manipulate) representation of the behavior of a given pro- cess. Furthermore, in [7] both HD-automata and θ-automata are claimed to be instances of the more general concept of graph with binding, although the details still remain to be spelled out. Either reconciling all the three differ- ent approaches above or understanding and formalising their differences is a necessary task that we intend to investigate.
As in the case of [14], the final coalgebra we have considered has the structure of a permutation algebra. In [14], this allows to prove that e.g., the support of the interpretation of a π-calculus process in the final model consists exactly of the active names of the given process. In our development, the counterpart of this result is Proposition 4.9: in the permutation algebra of the final model, there are only finitely many different ρπ-closures of the interpretation of a closed process P , corresponding to the number of different permutations of the active names of P .
In this paper we have considered early bisimilarity, but similar techniques can be used to account for late and weak bisimilarities. Moreover, it would be interesting to explore also denotational (i.e. compositional) models for early/late congruences based on the πθ-calculus. We expect to get simpler

models than the ones based on functor categories.
Finally, due to the “symbolic” nature of our operational semantics, it would be interesting to compare it to other symbolic approaches that are at the basis of different π-calculus implementations and tools, e.g. [8,17].

References
P. Aczel. Non-well-founded sets. CSLI Lecture Notes 14, Stanford, 1988.
P. Aczel and N. Mendler. A final coalgebra theorem. In Proc. CTCS’89, LNCS 389, pages 357–365, 1989. Springer-Verlag.
M. G. Buscemi and U. Montanari. A first order coalgebraic model of π-calculus early observational equivalence. In Proc. CONCUR 2002, LNCS 2421, pages 449–465. Springer- Verlag, 2002.
A. Corradini, R. Heckel, and U. Montanari. Compositional SOS and beyond: A coalgebraic view of open systems. Theor. Comput. Sci. 280, 163–192, 2002.
J. Despeyroux. A higher-order specification of the pi-calculus. In Proc. of the IFIP TCS’2000, Sendai, Japan, 2000.
M. J. Gabbay. Theory and models of the π-calculus using Fraenkel-Mostowski generalized. Submitted, 2002.
M. J. Gabbay. Fresh graphs. Submitted, 2004.
M. Hennessy and H. Lin. Symbolic bisimulations. Theoretical Computer Science, 138:353–389, 1995.
F. Honsell, M. Lenisa, U. Montanari, and M. Pistore. Final semantics for the π-calculus. In
D. Gries, editor, Proc. PROCOMET’98. Chapman&Hall, 1998.
F. Honsell, M. Miculan, and I. Scagnetto. π-calculus in (co)inductive type theory. Theoretical Computer Science, 253(2):239–285, 2001.
M. Lenisa. Themes in Final Semantics. PhD thesis, Dipartimento di Informatica, Universit`a di Pisa, Italy, 1998.
D. Miller and C. Palmidessi. Foundational aspects of syntax. ACM Computing Surveys (CSUR), 31(3es):11, 1999.
R. Milner, J. Parrow, and D. Walker. A calculus of mobile processes. Inform. and Comput., 100(1):1–77, 1992.
U. Montanari and M. Pistore. π-calculus, structured coalgebras, and minimal HD-automata. In Proc. MFCS 2000, LNCS 1893, pages 569–578, 2000.
J. Parrow. An introduction to the π-calculus. In Handbook of Process Algebra, pages 479–543. Elsevier Science, 2001.
J. J. M. M. Rutten and D. Turi. On the foundations of final semantics: Non-standard sets, metric spaces, partial orders. In REX Conf. Proc., volume 666 of Lecture Notes in Computer Science, pages 477–530. Springer-Verlag, 1993.
D. Sangiorgi. A theory of bisimulation for the π-calculus. Acta Informatica, 33:69–97, 1996.
D. Sangiorgi and D. Walker. The π-calculus: a Theory of Mobile Processes. Cambridge Universtity Press, 2001.
