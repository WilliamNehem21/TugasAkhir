	Electronic Notes in Theoretical Computer Science 174 (2007) 95–108	
www.elsevier.com/locate/entcs

Probabilistic Configuration Theories
Alessandro Tiberi1
Department of Computer Science University of Rome, “La Sapienza” Rome, Italy

Abstract
We introduce a new framework for describing computations which are both concurrent and probabilistic. This framework is a natural extension of the Configuration Theories of [4], and allows to express properties about both the causal and the probabilistic aspect of concurrent computations. Computations are described in an axiomatic way, by using a probabilistic extensions of poset sequents. A scheme of structural rules on these sequents is introduced and shown to be sound, while completeness can be obtained by adding a rule which is not treated in the present work. We also introduce a new probabilistic extension of Configuration Structures, which we use as models for probabilistic sequents.
Keywords: probabilistic semantics, concurrency, configuration structures, sequent calculus


Introduction
In concurrent and distributed settings, randomization plays an important role. It is folklore knowledge that there are some problems which without a source of ran- dom bits can not be solved at all, while they become almost easy when there is a source of randomness at disposal (see for instance [6,10,3].) Beside providing an important tool for solving such problems, randomness appears to be quite useful for modeling various aspects of distributed systems. In fact many features typical of distributed systems such as hardware failures, message arrivals, requests of services can be naturally described using randomized models. Thus, it is not surprising that during the last years the concurrency community has showed an increasing interest in the probabilistic aspect of computation, producing works ranging from the ex- tension of classical process calculi (e.g. [9]), to works which adjoin probabilities to causal models of concurrent systems ([5,1,2]). We propose a novel way to axiomat- ize properties of concurrent and probabilistic processes, using an extension of the poset sequents of [4]. States of computation are described by sequents whose com- ponents are sequences of partially ordered sets of events. Sequents are decorated by

1 Email: tiberi@di.uniroma1.it

1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2006.11.041

a matrix of monomorphisms which describes how, any computation matching the left hand side of the sequent, must extend to a computation that matches at least one poset of the right hand side. These sequents are also equipped with a vector of probabilities, which associates a probability to each poset appearing in the right hand side of the sequent. Roughly speaking, this probability is a lower bound to the probability with which any state of the computation matching the l.h.s. of the sequent will eventually evolve in a state that matches also its r.h.s. We also pro- pose a novel probabilistic extension of Conﬁguration Structures [7], which we use as models for the theories generated by these sequents. These structures are essentially the monotone structures of [4] (called in that paper conservative), to which we add an underlaying ﬁnite Markov chain, which allows us to reason about the probability with which a configuration C eventually turns into another configuration D.
In section 2 we introduce the notion of probabilistic poset sequent, in section 3 we formulate our extension of configuration structures, defining precisely when a structure satisfies a sequent and providing some examples, both of sequents and of probabilistic configuration structures. In section 4 the rules given in [4] are suitably modified to take into account probabilities and they are shown to be sound. In the last section we briefly discuss some possible future work.

Probabilistic Poset Sequents
The notion of poset sequent is introduced in [4]. Speaking informally, a poset sequent is made of two sequences of posets tied together by a matrix of mono- morphisms. Intuitively, such a sequent describes some computational properties (given by the posets on the right hand side of the sequent) which must hold for any computation matching the left hand side of the sequent. We extend this notion to probabilistic computations by allowing the properties described by the sequents to hold with a certain probability. Before giving any formal definition and provid- ing some more intuition about the meaning of these new sequents, we introduce some notation which essentially follows [4]. We use Γ, Δ ... to denote sequences of posets, A,B ... for single posets and a, b... for their elements. Concatenation of sequences Γ and Δ is written Γ, Δ. Matrices of monos are denoted by ρ,σ ... . Given two matrices ρ and σ respectively of sizes m × n and r × n, we write ρ; σ
for the (m + r) × n matrix that is obtained by placing ρ above σ, while if σ is of
size m × r we write ρ, σ for the m × (n + r) matrix obtained by placing ρ before σ. For a formal definition of this constructions we refer the reader to [4]. Given two sequences of posets Γ = A1,... Am and Δ = B1,... Bn we write ρ :Γ → Δ to denote a m × n matrix of monos such that ρij : Ai → Bj. We also use δ to denote a vector of elements δi ∈ [0, 1]. Given two such vectors δ and δ', we write δ · δ' for the vector that is obtained by their concatenation. We can now define what is a probabilistic poset sequent.

Definition 2.1 A probabilistic poset sequent Γ ▶δ
Δ consists of two finite se-

quences of posets Γ and Δ, a matrix of monos ρ :Γ → Δ and a vector δ such that
if Δ = Δ1,... , Δn then δ = δ1 ... δn and δi ∈ [0, 1].

The reader will probably better understand this definition after the notion of interpretation and the model on which we interpret these sequents are given. How- ever, before proceeding further, we find it useful to build some intuition about the
meaning of these sequents. Given a sequent Γ ▶δ Δ, its left hand side Γ describes, in terms of causal relations between events a computational status. Events are ele- ments of the posets in Γ, and their causal relations are represented by partial orders. Each Γi should be thought of as a property of the computational status described
by Γ. Thus, each Γi is somehow in conjunction with the others. The sequence Δ instead describes properties that must eventually be satisfied by any computation C for which all the “properties” Γi holds. In particular we require that C will reach a status D that satisfies at least one Δi (thus each Δi should be thought of as being in disjunction with the others). We also require that the probability of reaching D from C is at least δi. This last constraint is essentially what makes the difference between a poset sequent and a probabilistic poset sequent. Concrete examples of sequents will be given in section 3.

Probabilistic Configuration Structures
In this section we introduce the model on which probabilistic sequents are inter- preted.
We start by recalling the definition of conﬁguration structure [7]:
Definition 3.1 A configuration structure is a pair (E, C) where E is a set, whose elements are called events, and C is a family of subsets of E, called conﬁgurations.
Given a configuration structure (E, C) and a configuration C ∈ C, we denote with Sub(C) the set of configurations of C which are contained in C. A partial order ≤C can be associated in a natural way to each configuration by defining ≤C
= {(a, b)|∀D ∈ Sub(C),b ∈ D =⇒ a ∈ D}. In [4] a special class of configuration structures, called monotone, is introduced. These structure are required to enjoy the following properties:
ﬁniteness: if an event belongs to a configuration in C, then it also belongs to a finite subconfiguration of C.
coincidence-freeness: if two distinct events a, b belong to a configuration C, then there exists D ∈ Sub(C ) containing exactly one event in {a, b}.
non-emptiness of C
downwards-closed bounded intersection: ∀C ∈ C, ∀D, F ∈ Sub(C) and for all
a ∈ D ∩ F if b ≤D a then b ∈ F .
As shown in [4] monotone structures preserve the partial orders induced by sub- configuration, that is if D ∈ Sub(C) and a ≤D b then a ≤C b and hence for these structures inclusion can be seen as a monomorphism between posets. In the rest of the paper we assume all structures to be monotone and we also require con-
nectedness: for all non-empty C ∈ C there exists a ∈ C such that C \ {a} ∈ C. Connectedness implies rootedness: the empty configuration belongs to C. If we also

require closure under bounded union (that is if C, D ⊆ D' then C ∪ D is a config- uration), then if we consider a configuration C and one of its subconfiguration D such that C \ D = {e1,... , en}, there is at least one sequence of events eπ(1) ... eπ(n) such that D ∪ i≤k {eπ(i)} is a configuration for all k ≤ n and π is a permutation on [n]. This last requirement is not strictly necessary for our theory, but it makes some definitions less technical, hence we enforce it. However, we underline that it is not essential.
Given a configuration structure C, we call an event e enabled at a configuration C ∈ C if e ∈/ C and ∃D ∈ C s.t. D = C ∪ {e}. We denote with E(C) the set contain- ing all the events enabled at C. Informally speaking, a Probabilistic Conﬁguration Structure is a Conﬁguration Structure enriched with a few components which allows to reason about the probability of reaching a configuration C starting from any of its subconfigurations. First we attach to all events a label, and we assume the set L of labels to be finite. Next we attach to each configuration a probability func- tion on E. Finally we associate to this structure a ﬁnite Markov Chain (see for instance [8]), which we see as a directed weighted graph whose edges are labeled with elements of L. Our structure is then mapped on this graph, so that the image of each configuration is a node and if S(C) is the node on which a configuration is mapped, the set E(C) is mapped on the outgoing edges of S(C). We require this mapping to preserve labels, probabilities and “transitions”. In other words we
enforce this mapping to be a kind of homomorphism between the structure seen as a (possibly infinite) graph whose nodes are configurations and edges enabled events, and the graph representing the associated Markov Chain. This is made precise in
the following definitions. We first define what is a ﬁnite labeled Markov chain. In the following we fix the set of labels to be L.
Definition 3.2 A finite labeled Markov chain M is a directed graph G = (S, A) together with a weight function w : A → [0, 1] and a labeling function LM : A → L. An edge from a node si to a node sj is denoted by sij, and the weight function is subject to the constraint that for all si ∈ S,

Σ
sij ∈A
w(sij)= 1.

We call the elements of S states.
Definition 3.3 A probabilistic configuration structure is a 6-tuple
(E, C, P, LC , M, h)
where
(E, C) is a configuration structure
P : C → (E → [0, 1]) is a function which assigns to each configuration C a function PC such that Σe∈E(C) PC (e)=1 
LC : E → L is a labeling function

a	b

a
Figure 1. A Markov chain associated to the structure of example 3.4. A configuration whose last event is labeled with an a is mapped on state A, all the others on state B.
M is a finite labeled Markov chain
h is a function that maps configurations of C on states of M and the disjoint union of the events enabled at each configuration on arcs of M . We write hC (e) to mean h(e) where e ∈ E(C). We also require that if h(C) = si then
∀ e ∈ E(C) s.t. PC(e) > 0 there exists an arc sij s.t. :
hC(e)= sij
w(sij)= PC (e)
LM (sij)= LC(e)
h(C ∪ {e})= sj
Example 3.4 Consider the structures whose events is the union of the two count- ably infinite set A = {a1, a2,... } and B = {b1, b2,... }, where events in A are labeled with a and events in B with b. Let the configurations of these structure be all the sets C (including the empty set) s.t. if |C| = n then C = {c1, c2,... , cn} where ci ∈ {ai, bi}. Moreover, for such a configuration let the set of enabled events to which a positive probability is attached, be {an+1, bn+1} and let PC (an+1)= 2/3 and PC (bn+1)= 1/3 if the last event in C is cn = an while PC (an+1)= PC(bn+1)= 1/2 otherwise. By mapping this structure in the obvious way on the Markov chain depicted in figure 1 we obtain a probabilistic configuration structure.
Once we have mapped a configuration structure on a Markov chain, we can define the probability of reaching a configuration D, starting from one of its sub- configuration C. We recall that a transition matrix P can be associated to any finite Markov chain. An entry pij of this matrix is the probability of reaching state sj from state si (the weight of the edge sij) in one step. We also recall that the probability of reaching state sj starting from state si in n steps is defined as the jth entry of the vector u(n), where
u(n) = uPn

u is a vector with all zero components except for the ith entry which is equal to 1 and Pn is the P raised to the n.
Definition 3.5 Let Cp = (E, C, P, LC , M, h) be a probabilistic configuration struc- ture, and let C, D be two configurations such that C ∈ Sub(D) and |D \ C| = n. If

h(C) = si and h(D) = sj, then the probability of reaching a configuration that is mapped on the same state sj of D starting from C is defined as
Pr (C → h(D)) = u(n)
where u(n) = uPn, P is the transition matrix of M and u is zero everywhere except for its ith entry which is equal to one.
Notice that by the above definition the probability Pr (C → C) is always equal to 1.
This definition considers somehow equivalent configurations mapped on the same state of the underlaying Markov chain. Actually, for the notion of satisfaction that we have in mind this is too abstract, since we want to compute precisely the probability of going from a configuration C to a configuration D. To this aim, we need to introduce few other definitions.
Definition 3.6 A path πC,D from a configuration C to a configuration D is a sequence of pairwise distinct events π = e1e2 ··· en such that ei ∈/ C, C ∪ i≤k ei = Dk ∈ C for k ∈ [n] and Dn = D. C is called the source of π and D the destination.
The set of all paths from C to D is written ΠC,D. We write πc,∗ to denote a path whose source is C and destination is not specified. We also write |π| to denote the length of π. We can then define the probability of a path πC,D = e1 ... ek as
Pr (πC,D)= w(hC (e1)) · Pr (πC∪{e1 },D) where πC∪{e1 },D = e2 ... ek.
We call dead a path πC,D if D is a configuration with no events enabled (and
hence in the Markov chain it is represented by a node with only one ingoing edge of weight 1). We can extend a dead path πC,D = e1 ... ek of length k, to a path π'
of length k + c by allowing D to perform c invisible events ϵ with probability one. Thus for all configurations D with no events enabled, if h(D)= si we extend hD so that hD(ϵ)= sii and PD(ϵ)= 1.
A Probabilistic Configuration Structure entails a probability function on the set of paths of any fixed length n which share the same source C, but only after we

extend the dead paths πC,D whose length is less than n to paths π'
of length n

by adding a suitable sequence of invisible events ϵ.
Remark 3.7 Let the set ΠC,k be defined as the set containing all paths of length k, whose source is C and all dead paths πC,∗ whose length is less than k extended to path of length k. It holds that:
∀π ∈ ΠC,k Pr(π) ≥ 0
∀π ∈ ΠC,k Pr(π) ≤ 1
Pr[ΠC,k]= Σπ∈ΠC,k Pr(π)=1 
We omit the proof since it is routine. The reader should notice that the probab- ility defined in 3.5, Pr(C → h(D)), is an upper bound to the probability Pr[ΠC,D].

This property can be useful for proving that a configuration structure does not satisfy a sequent by looking only at the Markov Chain, without considering paths. We can now define when a probabilistic configuration structure satisfies a prob- abilistic poset sequent. We call a n × 1 matrix of monos π :Γ → C an interpretation
of Γ in C. The following definition is similar to the one given in [4] but it also takes
into account probabilities.
Definition 3.8 A probabilistic configuration structure (E, C, P, LC , M, h) is said to satisfy a probabilistic sequent Γ ▶δ Δ when, for any C ∈ C and interpretation π :Γ → C, there exists D ∈ C, a component Δk and a mono q : Δk → D such that C ∈ Sub(D) and, for all i, the following diagram commutes and Pr[ΠC,D] ≥ δk

ρ
Γi −−−−→ Δk

πi ⏐ 
C	⊆
⏐ q


⊆
Note that since we assume our structure to be monotone, the inclusion −→ of
the above diagram is a monomorphism between posets. Both the notion of sequent
and of satisfaction can be extend to a setting in which events are labeled, just by enforcing the additional constraint that all monos preserve labels. In the following we will use labeled sequents. In the remaining of this section we develop a simple example to give the reader a taste of what these sequents can be used for.

Example
Consider a scenario in which there is a shared resource on which processes can make some computation, but only after they have acquired a lock on it. Sequents can be used to axiomatize the correctness of computation (e.g. exclusive access to the shared resource) and, as we shall see, also to enforce processes to be somewhat fair: in fact by using suitable sequents we can prescribe processes to release the resource with a certain probability after they have made some computation on the resource itself. For the following sequents three labels are used, L = {l, u, c}. They stand
for: lock, unlock, compute.
The first desirable property is that before a process can make any computation on a resource, it should acquire a lock on it. Since this is a property that essentially is about the past of a computation, we require it to hold with probability 1. The following sequent describes this requirement:
We also want to enforce the lock to be exclusive. Unfortunately, poset sequents are not very good at expressing such a property, but if we restrict ourself to a setting in which no configuration will be reached with probability one, the following sequent does the work:
This sequent expresses the required property as long as we forbid any configura- tion to evolve in some other configuration with probability 1, since in this case this sequent enforces the unlock action to happen before one of the two locks.


c
c	l

Figure 2. This sequent is made of two posets: the one of the l.h.s contains a single element labeled with c, the other contains two elements, b, d, labeled respectively with l and c, and b < d. The matrix ρ is made of a single mono, which maps a on d (depicted as the arc in the figure)

u l




Figure 3. This sequent contains three posets, one in the l.h.s and two (separated by a comma) in the r.h.s., this time ρ is a vector of two monos, one depicted in the upper part of the sequent and one in the lower. This sequent says that whenever the resource has been locked twice, one of the locks must have been released.
These two properties essentially make little use of probabilities. We now describe two other properties in which probability plays an important role. We want to enforce that when a process acquires a lock, then there is a positive probability (equal to 1/10) that it does some computation on the resource it has locked:
c

Figure 4. This sequent is similar to the first, but here we have put a probability equal to 1/10, thus any computation in which a lock has been acquired, will eventually extend to a computation in which the resource is used, with probability at least 1/10.

The last property we require is that once a process has acquired a lock, it does not hold it forever. In particular we ask that once it has used the resource at least once, there is a positive probability (namely 1/3) that it releases its lock. This is expressed by the following sequent:
c	c	u

l	l


Figure 5. As for the previous one, this sequent contains two posets and a matrix of just a single mono. In the poset of the right hand side there is an unlock action causally dependent on the lock that has enabled the computation.

Now we describe a probabilistic configuration structure whose configurations satisfy all these sequents. This structure is meant to describe a concurrent com- putation in which two processes share a resource. Let’s start with describing the events of this structure. We assume to have an infinite set of events E, which is partitioned in seven sets, Li, Ci, Ui with i = 1, 2 and a set I = {w1, w2 ··· } of idle
events. The set L1 = {l1, l1 ... } contains the lock event of the first process, L2 of
1  2
the second and similarly for the other sets. We fix the set of labels L = {l, u, c, w}
and associate label l to all events in the sets Li and similarly for the other sets. To
each lock action li we associate a set of computations Ci ⊂ Ci whose elements we

denote with ci
. For describing the configurations of our structure, we find it con-

venient to introduce a partial order on E: we assume that li < ci , li < ui < li
k	k,j	k	k	k+1

and ci
i k,j+1
for all k and i ∈ {1, 2} (notice that since we assume < to be a

partial order, it must be transitive.) A configuration C (containing only events in
E) is in our structure if and only if the relation ≤C agrees with the partial order on E and 0 ≤ |C ∩ (L1 ∪ L2)|− |C ∩ (U 1 ∪ U 2)| ≤ 1. This last condition guarantees

that in each configuration there is at most one lock action li
that is not matched

by the corresponding unlock action. The set of configurations defined in this way can be partitioned in three sets, one in which all configurations contain the same number of lock and unlock events (call it Cb), one whose configurations contain an

event li
not matched by the corresponding unlock and do

not contain the event ci	2 (call it Cl), and one set containing all the other config-
urations (call it Cc). We also enrich the configurations in Cb by allowing idle events to be sequentially (we also require wi < wi+1) added to them but we still keep the implicit constraint that the resulting structure is monotone and connected.
Now we have to define the probability function associated to each configuration. Consider a configuration C ∈ Cb, we assign a positive probability to a subset of its

enabled event: {l1
2
j+1
, wi+1}, where k, j, i are the greatest indices of events in

L1,L2 and I contained in C. We associate the following probabilities to this events:

PC (wi+1)= 0.1, PC (l1
)= PC(l2
)= 0.45. In a configuration C in Cl there are

several enabled events, however, if li
is the unique lock event that is not matched

by the corresponding unlock, we attach a positive probability only to the events ui

and ci  , in particular PC(ui )= PC(ci
)= 0.5. Similarly, if C is a configuration in

k,1	k	k,1

Cc, li
is as before and ci
is such that no events ci
with h > j is in C, we define

PC (ui )= 0.8 and PC(ci
)= 0.2.

k	k,j+1
We can now associate to this structure the Markov chain in figure 6.
How configurations are mapped on the states of this chain should be understand- able by looking at the labels given to the states: configurations in Cb are associated to the state with the same label, while configurations in Cl are associated either to state Cl1 or Cl2, depending on which process has performed the “last” lock action. Configurations in Cc are mapped on the remaining state. Let’s see now why this probabilistic structure satisfies, for instance, the sequent in figure 4. Consider a configuration C for which there exists an interpretation mapping the left hand side

2 hence neither any ci

c






w













Figure 6. A Markov chain associated with the structure of the example. Edges are labeled with the name of the events and with the associated probability.


[ true ]


▶δ ∅
[ iso ]


A ▶δ B
(φ is iso )

Γ ▶δ Δ	Γ ▶δ Δ
[ l-weak ] Γ, ∅ ▶δ	Δ	[ r-weak ] Γ ▶δ·δA Δ,A 

δ·δ' ·δ''	δ

Γ ▶ A
A Δ, A,A 
'	''
Γ, A,A ▶	Δ

[ r-contr ]
ρ,τ,τ
(δA = min {δA, δA})
[ l-contr ]
ρ;τ ;τ

Γ ▶δ·δA Δ,A	Γ,A ▶δ	Δ

Γ, A, B, Π ▶δ	Δ
Γ ▶δ·δA·δB ·δΠ Δ, A, B, Π

	ρ;τ ;φ;θ	
[ l-exc ] 
	ρ,τ,φ,θ	
[ r-exc ] 

Γ, B, A, Π ▶δ
Δ
Table 1 Structural Rules I
Γ ▶δ·δB ·δA·δΠ Δ, B, A, Π


of the sequent on C. Such a configuration must contain at least one lock event li on which the l event in the l.h.s of the sequent is mapped. We’ll show that regardless of what is the state h(C), there is a path of probability greater than 1/10 that C evolves to a configuration D (which makes the diagram of definition 3.8 commute). Suppose that h(C)= Cb, then with probability 0.45 we make an l action by means
of an event li	, thus moving in Cli. From Cli we can make a c action with probab-

ility 0.5 by means of an event ci
. Since li < li
< ci
the diagram commutes

k+c,1
k	k+c
k+c,1

by mapping the c event of the r.h.s. of the sequent on ci
, moreover the prob-

ability of the described path is equal to 9/40 which is greater than 1/10. If instead h(C) = Clj, we have two cases: either j = i and then we can perform a c action we probability 0.6 and we are done, or we may have to go back to a configuration in Cb, by performing an unlock action and then repeat the path described before. Again the probability of this path (9/80) is greater than the required one. We skip

the case in which h(C)= Cc since it is very similar to the previous one.

Probabilistic Configuration Theories
In [4] the notion of Conﬁguration Theories is introduced. In that work a config- uration theory is defined as a set of sequents closed under a certain rule scheme. Moreover, that rule scheme is shown to be sound and, by adding a rule and con- straining the sequents to be made of finite posets, also completeness is proven. Here we show that the same rule scheme can be naturally adapted for probabilistic poset sequents, preserving both soundness and completeness. Before explaining the rule scheme, we need to introduce some notation. Given two matrices ρ : Γ → A and
τ : A → Π we write with ρτ the matrix σ :Γ → Π whose entries are σij = ρ1i · τj1
where here · stands for function composition (written in diagrammatical order). Moreover, given a probabilistic poset sequent Γ ▶δ Δ, we denote the ith element of

the vector δ with δi, while given two vectors δ, δ' with δiδ'
we denote the product

of the ith element of δ with the jth element of δ', while with δ · δ' we denote the vector obtained by concatenating δ with δ'.
The rules are shown in table 1 and table 2. Following [4], we can define a
Probabilistic Conﬁguration Theory:
Definition 4.1 A probabilistic configuration theory is a set of probabilistic poset sequents, closed under the rule of table 1 and table 2.
We first give a intuitively explanation of the meaning of some rules, then in the next subsection we formally prove the soundness. Rule [ iso ], says that whenever a sequent is made of two posets which are isomorphic then this sequent is satisfied by any probabilistic configuration structure, regardless of the vector of probabilities this sequent is decorated with. This is because if a configuration interprets poset A, through an interpretation π, then by choosing the morphism q of definition 3.8 as q = φ−1π and D = C, we have that the diagram commutes and the probability that C remains in C by an empty path is of course 1. Rule [ r-weak ] says that whenever
a configuration satisfies Γ ▶δ Δ, it also satisfies the sequent obtained by adding to the r.h.s of the former a poset A, regardless of how Γ is mapped on A by τ and of the value of δA. The correctness of this rule easily follows from definition 3.8.

Soundness
We now show that the rules given in table 1 and table 2, are sound when interpreted in probabilistic configuration structures. That is every configuration structure that satisfies the premises of a rule, also satisfies its consequence.
Theorem 4.2 The rule of table 1 and table 2 when interpreted on probabilistic conﬁguration structures are sound.
Proof We need to prove that for each rule, if a configuration structure satisfies its premises then it also satisfies its consequence. For most of the rule in table 1 the

Π ▶δA A	Γ,A ▶δ	Δ	'

	τ	ρ;φ	
[ l-cut ]
(where δ
= δAδ1 · δAδ2 ·· · δAδn)

'
ρ;τφ Δ
Γ ▶δ·δA Δ,A	A ▶δΠ Π

ρ,φ
τ	(where δ' = δAδΠ · δAδΠ ·· · δAδΠ)

[ r-cut ]
Γ ▶δ·δ
Δ, Π
1	2	n

ρ,φτ
Table 2 Structural Rules II

argument is similar to the one informally carried out for the rule [ iso ], hence we skip the proof for these rules.
Let us consider rule [ l-cut ]. Consider a configuration C that satisfies both
Π ▶δA A and Γ,A ▶δ	Δ. Let v :Γ → C and π :Π → C, vA : A → C be arbitrary
τ	ρ;φ
interpretations. Notice that any interpretation ψ : Γ, Π → C can be obtained as
v, π by a suitable choice of π and v. Since C satisfies the first sequent, there must

be a configuration D, a mono r = C ⊆
D and a mono q : A → D such that the

diagram of definition 3.8 commutes, that is for all i, πir = τq. Note that if v is an
interpretation in C and C ⊆ D, then v is also an interpretation in D. Thus, fixed v,

there must be a configuration D', a mono r' = D ⊆
D' and a mono q' : Δk → D,

such that the corresponding diagram commutes for all components of the l.h.s. of the
poset, that is vir' = ρikq' and vAr' = φkq'. Pasting together these two diagrams, choosing vA = q and noticing (φτ )ik = φiτk, shows that for any interpretation π' : Γ, Π → C we can build the required commuting diagram. It remains to show
that Pr[ΠC,D' ] ≥ δAδk: we know that Pr[ΠC,D] ≥ δA and Pr[ΠD,D' ] ≥ δk. The

thesis follows by observing that Pr[ΠC,D' ] = Σπ∈Π

C,D
Pr(π) Pr[ΠD,D' ].  Consider

now rule [ r-cut ], and assume that its premises Γ ▶δ·δA
Δ,A and A ▶δΠ
Π, are

satisfied by a configuration C. Thus from the satisfaction of the first sequent we
know that there exists a configuration D containing C, and a mapping q which is either q : Δj → D for some component Δj of Δ, or q : A → D which makes the required diagram commute. In the first case the thesis follows immediately. For the
other case, notice that since C satisfies the second sequent, then also D must satisfy it, thus there is a configuration D' containing D and a mono q' : Πk → D' such that the diagram commutes even if we take as interpretation q. Pasting together the two diagrams, shows that we are able to build a commuting diagram for the
consequence of the rule. For the vector of probabilities that is associated to the consequence, exactly the same argument carried on for [ l-cut ] can be used. 
So far we have proven only the soundness of our rule scheme. Actually, this rule scheme is not complete: there are valid sequents which can not be derived. In [4] a new rule, called extend, is introduced to obtain the completeness at the cost of constraining sequents to be finite. It is not hard to import that rule in our setting and to show that in this way we obtain a complete calculus. However the rule itself is quite technical and needs the introduction of some machinery which is out of the scope of this work. We refer the interested reader to [4], being confident that the details of how the rule extend must be modified can be easily worked out.

Conclusions
We have introduced a new kind of sequents which are able to capture both the causal and the probabilistic aspects of concurrent computation, and we have interpreted these sequents in a new framework which suits these sequents in a quite natural way. We have also provided a scheme of rules which we have proven to be sound, and which can be easily extended to a be complete. However, this work is still at an initial stage, and we think that there are quite a number of things which need further investigation. Concerning our sequents, we think that the way we have adjoined probabilities is just one among the possible ones. We think that it would be interesting to explore a notion of satisfaction which takes into account the fact that in a probabilistic setting not all configurations are equal. In other words, a probabilistic configuration structure may fail satisfying a theory because of just a tiny portion of its configurations, which in a probabilistic scenario would make sense to ignore. Hence we could modify the notion of satisfaction requiring only that a “large set” (in a probabilistic sense) of the configurations satisfies the sequents. Moreover, interpreting our sequents on our probabilistic structure has not been hard, but these structures are particularly simple. We think we should explore the feasibility of using as models the probabilistic event structures of [5] which have both a causal and a probabilistic flavor. Another promising model into which we could interpret our sequent are the probabilistic safe Petri nets of [2] which shares several features with Markov chains, and thus should be not too hard to describe using our sequents.
Concerning probabilistic configuration structures, we are aware that while on one side they are quite simple and easy to handle, on the other side, they have one serious limitation: all choices are probabilistic. As noted in [11], this is probably a too strong assumption since many transition are better modeled using nondetermin- ism. Thus we think we should explore different settings in which probabilistic choice is combined with nondeterministic choice, maybe in a similar way to [11] where con- current Markov chains are introduced, using a scheduler to model nondeterminitics steps.

References
Abbes and Benveniste. Branching cells as local states for event structures and nets: Probabilistic applications. In FOSSACS: International Conference on Foundations of Software Science and Computation Structures. LNCS, 2005.
Samy Abbes. The (true) concurrent markov property and some applications to markov nets. In Gianfranco Ciardo and Philippe Darondeau, editors, ICATPN, volume 3536 of Lecture Notes in Computer Science, pages 70–89. Springer, 2005.
M. Ben-Or. Another advantage of free choice: completely asynchronous agreement protocols. In
PODC’83, pages 27–30, 1983.
Pietro Cenciarelli. Configuration theories. In CSL ’02: Proceedings of the 16th International Workshop and 11th Annual Conference of the EACSL on Computer Science Logic, pages 200–215, London, UK, 2002. Springer-Verlag.
Daniele Varacca. Probabilistic event structures and domains, July 08 2003.
Fischer, Lynch, and Paterson. Impossibility of distributed consensus with one faulty process. JACM: Journal of the ACM, 32, 1985.


R. Van Glabbeek and Gordon Plotkin. Configuration structures. In Tenth Annual Symposium on Logic in Computer Science, pages 199–209, San Diego, California, 1995. IEEE Computer Society.
Charles M. Grinstead and J. Laurie Snell. Introduction to Probability: Second Revised Edition. American Mathematical Society, 1997.
Oltea Mihaela Herescu and Catuscia Palamidessi.	Probabilistic asynchronous pi-calculus.	In
Foundations of Software Science and Computation Structure, pages 146–160, 2000.
D. Lehman and M. O. Rabin. On the advantage of free choice: A fully symmetric and fully distributed solution to the dining philosophers problem. In Proceedings of 10th ACM Symposium of Principles of Programming Languages, pages 133–138, Williamsburg, 1981.
M. Y. Vardi. Automatic verification of probabilistic concurrent finite-state programs. In FOCS’85, pages 327–338, 1985.
