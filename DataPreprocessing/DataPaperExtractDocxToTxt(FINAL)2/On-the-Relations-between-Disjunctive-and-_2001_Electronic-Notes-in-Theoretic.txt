Electronic Notes in Theoretical Computer Science 48 (2001)
URL: http://www.elsevier.nl/locate/entcs/volume48.html pp. 1 – 25


On the Relations between Disjunctive and Linear Logic Programming

Marco Bozzano 1 Giorgio Delzanno 2 Maurizio Martelli 3
Dipartimento di Informatica e scienze dell’Informazione Universit`a di Genova, Via Dodecaneso 35
16146 Genova, Italy


Abstract
In this paper we investigate the relationship between Disjunctive Logic Program- ming as defined in [13] and a subset of Linear Logic, namely the fragment of Lin- Log [2] which corresponds to Andreoli and Pareschi’s LO [3]. We analyze the two languages both from a top-down, operational perspective, and from a bottom-up, semantical one. From a proof-theoretical perspective, we show that, modulo a simple mapping between classical and linear connectives, LO can be viewed as a sub-structural fragment of DLP in which the rule of contraction is forbidden on the right-hand side of sequents. We also prove that LO is strictly more expressive than DLP in the propositional case. From a semantical perspective, after recalling the definition of a bottom-up fixpoint semantics for LO we have given in our previous work [5], we show that DLP fixpoint semantics can be viewed as an abstraction of the corresponding LO semantics, defined over a suitable abstract domain. We prove that the abstraction is correct and complete in the sense of [6,8]. Finally, we show that the previous property of the semantics is strictly related to proof-theoretical properties of the classical and linear logic fragments underlying DLP and LO.


Introduction
Disjunctive Logic Programming (DLP) [13] and Linear Logic Programming (LLP) [11] are among the more interesting extensions of the classical theory of Horn logic, underlying languages like Prolog. The motivations behind the introduction of these two paradigms look quite different. On the one hand, disjunctive logic programming has been introduced in order to represent uncer- tain beliefs. On the other hand, linear logic programming has been introduced in order to add state-based computations to pure Prolog programs. A closer

1 Email: bozzano@disi.unige.it
2 Email: giorgio@disi.unige.it
3 Email: martelli@disi.unige.it
◯c 2001 Published by Elsevier Science B. V. Open access under CC BY-NC-ND license.


look at their formal definition reveals however very interesting connections. Let us focus on the linear logic programming language LO [3] (Linear Ob- jects), a fragment of LinLog [2] which is perhaps the first proposal of ‘linear’ extension of Prolog [11]. Both DLP and LO programs extend Horn programs allowing clauses with multiple heads: in DLP, the head of a clause consists of a classical disjunction of atomic formulas, whereas, in LO, it consists of a multiplicative disjunction (see [9]) of atomic formulas. The differences be- tween the meaning of classical and linear connectives become clear by looking
at the operational semantics of the two languages. In DLP, a resolution step is extended so as to work over positive clauses (sets/disjunctions of atoms). Implicit contraction steps are applied over the selected clause. In contrast, being in a sub-structural logic in which contraction is forbidden, LO resolu- tion has the same effect as multiset rewriting (applied to collections of atomic formulas).
Based on this intuition, in this paper we will investigate the view of LO as a sub-structural formulation of DLP, to formally compare the strength and weakness of the two languages. As mathematical tools, we will use proof theory and abstract interpretation. Proof theory allows us to compare the top-down semantics of the two paradigms working in a uniform setting (i.e. provability in a sequent calculus with or without structural rules). Abstract interpretation allows us to extend the comparison to the bottom-up evaluation of programs. More specifically, by exhibiting a Galois connection between the
semantic domains of DLP and LO, we will describe the semantics of DLP programs as an abstraction of the semantics of LO programs. Furthermore, using the theory of abstract interpretation and the concept of completeness [6,8] we will discuss the quality of the resulting abstraction. This step is
based on a new fixpoint semantics for LO we have defined in our recent work [4,5]. Finally, we will discuss the relation between proof-theoretical properties (permutability of rules) and properties of the abstraction (completeness).
The view of DLP as an abstraction of LO is appealing for several reasons. First of all, it opens the possibility of using techniques developed for DLP for the analysis of LO programs. Furthermore, it shows that the paradigm of DLP could have unexpected applications as a framework to reason about properties of Petri Nets, a well-known formalism for concurrent computations [10], as discussed in [5].

Plan of the paper
After introducing some preliminaries in Section 2, in Section 3 we recall the main concepts of disjunctive logic programming, and we reformulate its oper- ational semantics in a sequent calculus context. In Section 4 we introduce the language LO, while in Section 5 we compare DLP and LO proof theories. In Section 6 we study the relations between DLP and LO via abstract interpre- tation, and we discuss the properties of the resulting abstraction. In Section


7, we discuss the connection between the notion of completeness in abstract interpretation and proof theory. Finally, in Section 8 we discuss conclusions and future work.

Preliminaries
In this paper we will extensively use operations on multisets. We will consider a fixed signature Σ, defining a finite set of object constants, function symbols and predicate symbols. The set of ground terms over Σ will be denoted TΣ,
while the set of atoms over TΣ will be denoted AΣ. Multisets over AΣ will be hereafter called facts, and symbolically noted as A, B, C,.. .. A multiset with (possibly duplicated) elements A1,..., An ∈ AΣ will be simply indicated as
{A1,..., An}, overloading the usual notation for sets.
A multiset A is uniquely determined by a map Occ : AΣ → N such that OccA(A) is the number of occurrences of A in A. Multisets are ordered ac- cording to the multiset inclusion relation “ defined as follows: A “ B if and only if OccA(A) ≤ OccB(A) for every A ∈ AΣ. The empty multiset is denoted ϵ and is such that Occє(A) = 0 for every A ∈ AΣ, and ϵ “ A for any A. The multiset union A, B (alternatively written A+B when ‘,’ is ambiguous) is such that OccA,B(A) = OccA(A) + OccB(A) for every A ∈ AΣ. We also define a special operation • to compute the least upper bound of two multisets with re- spect to “. Namely, A•B is such that OccA•B(A) = max(OccA(A), OccB(A)) for every A ∈ AΣ. Finally, we will use the notation An, where n is a natural number, to indicate A + ... + A (n times).
In the rest of the paper we will use ∆, Θ,... to denote multisets of possibly compound formulas. Given two multisets ∆ and Θ, ∆, Θ indicates multiset union, as before, and ∆, {G} is written simply ∆, G.
Finally, let T : I → I be an operator defined over a complete lattice
⟨I, ±⟩. We define T ↑0= ∅, where ∅ is the bottom element, T ↑k+1= T (T ↑k)
for all k ≥ 0, and T↑ω= .∞ T↑k, where . is the least upper bound wrt. ±.
Furthermore, we use lfp(T ) to denote the least ﬁxpoint of T .

Disjunctive Logic Programming
A disjunctive logic program as defined in [13] is a finite set of clauses
A1 ∨ ... ∨ An ← B1 ∧ ... ∧ Bm,
where n ≥ 1, m ≥ 0, and Ai and Bi are atomic formulas. A disjunctive goal
is of the form ← C1,..., Cn, where Ci is a positive clause (i.e. a disjunction of atomic formulas) for i : 1,..., n. To make the language symmetric, in this paper we will consider extended clauses of the form
A1 ∨ ... ∨ An ← C1 ∧ ... ∧ Cm


containing positive clauses in the body. Following [13], we will deal with first- order programs by considering the set of ground instances of program clauses. Given a program P , we will use the notation Gnd (P ) to indicate the set of ground instances of clauses in P . Moreover, we will identify positive clauses with sets of atoms.
In order to define the operational and denotational semantics of DLP, we need the following definitions.
Definition 3.1 (Disjunctive Herbrand Base) The disjunctive Herbrand base of a program P , for short DHBP , is the set of all positive clauses formed by an arbitrary number of distinct ground atoms.
Definition 3.2 (Disjunctive Interpretation) A subset I of the disjunctive Herbrand base DHBP is called a disjunctive Herbrand interpretation.
Definition 3.3 (Ground SLO-derivation) Let P be a DLP program. An SLO-derivation of a ground goal G from P consists of a sequence of goals G0 = G, G1,... such that for all i ≥ 0, Gi+1 is obtained from Gi =← (C1,..., Cm,..., Ck) as follows:
C ← D1 ∧ ... ∧ Dq is a ground instance of a clause in P such that C is contained in Cm (the selected clause);
Gi+1 is the goal ← (C1,..., Cm−1, D1 ∨ Cm,..., Dq ∨ Cm, Cm+1,..., Ck).
Notice that when the body of the program clause is empty, Gi+1 is equal to ← (C1,..., Cm−1, Cm+1,..., Ck).
Definition 3.4 (SLO-refutation) Let P be a DLP program. An SLO-refu- tation of a ground goal G from P is an SLO-derivation G0, G1,..., Gk s.t. Gk consists of the empty clause only.
As SLD-resolution for Horn programs, SLO-resolution gives us a proce- dural interpretation of DLP programs. The operational semantics is defined then as follows:
Odlp = {C | C ∈ DHBP , ← C has an SLO-refutation }.
As for Horn programs, it is possible to define a fixpoint semantics via the following operator.
Definition 3.5 (T dlp Operator) Given a DLP program P and I ⊆ DHBP ,

T dlp(I) = { C' ∪ C1 ∪ ... ∪ Cn | C' ← D1 ∧ ... ∧ Dn ∈ Gnd (P ),
Di ∪ Ci ∈ I, i : 1,...,n }

Note that in the previous definition we have implicitly considered positive clauses as sets ofatoms. The operator T dlp is monotonic and continuous on the lattice of interpretations ordered wrt. set inclusion. Based on this property,


the fixpoint semantics is defined as F dlp = lfp(T dlp) = T dlp ↑ω. As shown
P	P	P
in [13], the fixpoint semantics is complete with respect to the operational
semantics, i.e. for all C ∈ Odlp there exists C' ∈ F dlp s.t. C' implies C. Note
P	P
that for two ground clauses C and C', C implies C' if and only if C ⊆ C'.
This suggests that interpretations can also be ordered wrt. subset inclusion for their elements, i.e., I ± J if and only if for all A ∈ I there exists B ∈ J such that B ⊆ A (B implies A). In the rest of the paper we will consider the latter ordering.
Example 3.6 Consider the disjunctive program P = {r(a), p(X) ∨ q(X) ← r(X)} and the auxiliary predicate t. Then, DHBP = {r(a), p(a), q(a), t(a), p(a) ∨ r(a), p(a) ∨ q(a), p(a) ∨ q(a) ∨ r(a),.. .}. Furthermore, the goal G0 =←
(p(a) ∨q(a) ∨t(a)) has the refutation G0, G1 =← (p(a) ∨q(a) ∨t(a) ∨r(a)), G2
where G2 consists of the empty clause only. The fixpoint semantics of P is

dlp
P
= {{r(a)}, {p(a), q(a)}}. Note that {p(a), q(a)} is contained in {p(a),

q(a), t(a)} (i.e. p(a) ∨ q(a) implies p(a) ∨ q(a) ∨ t(a)).
The definition of the T dlp operator can be reformulated in such a way that its input and output domains contain multisets instead of sets of atoms (i.e. we can consider interpretations which are sets of multisets of atoms). In fact, we can always map a multiset to its underlying set, i.e. the set containing the elements with multiplicity greater than zero, and, vice versa, a set can be viewed as a multiset in which each element has multiplicity equal to one. A formulation based on multisets will make the comparison with the fixpoint
operator for LO (see Section 6) easier, as this latter is defined on that kind of domains. The disjunctive Herbrand base and T dlp operator definitions can be reformulated as follows (in the following we will always refer to these defini- tions).
Definition 3.7 (Disjunctive Herbrand Base) The disjunctive Herbrand base of a program P , for short DHBP , is the set of all multisets formed by an arbitrary number of ground atoms, each with multiplicity at most one.
Definition 3.8 (α mapping) Let α be the following function on multisets of atoms. Given a multiset A, α(A) is the multiset such that for every A ∈ AΣ, Occα(A)(A) = 0 if OccA(A) = 0, Occα(A)(A) = 1 otherwise (i.e. we abstract a multiset with the corresponding set).
We note in passing that α definition is related to the notion of smallest factor of a clause given in [13].
Definition 3.9 (T dlp Operator) Given a DLP program P and I ⊆ DHBP ,

T dlp(I) = { α(C^' + C1 + ... + Cn ) | C' ← D1 ∧ ... ∧ Dn ∈ Gnd (P ),
D^i + Ci ∈ I, i : 1,...,n }





P ⇒ tt, ∆

ttr
P ⇒ A1,..., An, ∆
∨r
P ⇒ A1 ∨ ... ∨ An, ∆


P ⇒ C1, H, A	...	P ⇒ Cm, H, A
bc
P ⇒ H^ , A
with the proviso that H ← C1 ∧ ... ∧ Cm ∈ Gnd (P ) Fig. 1. A proof system for DLP.
The notation · in the previous definition is used to formally map positive
clauses (i.e. ∨-disjunctions of atoms) to multisets of atoms (whereas in Defini- tion 3.5 the mapping from clauses to sets of atoms was left implicit). Without loss of generality, from now on we will make the further assumption that in
clauses like A1 ∨ ... ∨ An ← C1 ∧ ... ∧ Cm, the Ai’s are all distinct and each
Cj consist of distinct atoms. This will simplify the embedding of DLP clauses into linear logic (see Definition 5.1).

A Proof System for DLP
We will now give a proof-theoretical presentation, based on sequent calculus, for DLP. Its formulation is directly related to the definition of SLO-derivation
(see Definition 3.3). In order to simplify the comparison with LO, we introduce an explicit constant tt for true and we write unit clauses (i.e. with empty body) with the syntax A1 ∨ ... ∨ An ← tt. The definitions given in the previous section can be adapted in a straightforward manner. The resulting
language can be described by the following grammar:

H ::= A1 ∨ ... ∨ An
D ::= H ← G | D ∧ D
G ::= H1 ∧ ... ∧ Hn | tt
where Ai is an atomic formula. A DLP program P is a D-clause, whereas DLP goals are represented (modulo ‘←’) as G-formulas. A proof system for DLP
is presented in Figure 1 (again, we use the notation · to map ∨-disjunctions of atoms to multisets). Here, in a sequent P ⇒ ∆, it is understood that P is a DLP program and ∆ is a set of goals. Besides, A denotes a set of atomic formulas, while H denotes an H-formula.
Without loss ofgenerality, we have limited topmost goals to positive clauses only (the execution of a goal which is a conjunction of clauses can be simu- lated by introducing a fictitious atom and adding a clause to the program). The reader should convince himself/herself that the system in Figure 1 cor-






P ⇒ tt, ∆

ttr
P ⇒ A1,..., An, ∆
∨r
P ⇒ A1 ∨ ... ∨ An, ∆
P ⇒ A, A, A P ⇒ A, A

ctrr

P ⇒ C1, A	...	P ⇒ Cm, A
bc
P ⇒ H^ , A
with the proviso that H ← C1 ∧ ... ∧ Cm ∈ Gnd (P ) Fig. 2. Modified proof system for DLP.
rectly models SLO-provability. The state of a computation, which in DLP is
represented by a conjunctive goal ← C1,..., Ck, in the context of sequent cal- culus is represented by a derivation tree, whose frontier (open leaves) are the goals still to be proved (C1,..., Ck). Rule bc models a backchaining step, and corresponds to a step of SLO-derivation; it can be applied only if the current context consists of atomic formulas only (indicated by A). Rule ∨r formalizes the intuition that positive clauses are sets of atoms (i.e. it permits exchange on the right-hand side of sequents). Clauses having the form a1 ∨ ... ∨ an ← tt
play the same role as unit clauses in DLP, in fact a backchaining step over such a clause leads to success independently of the current context A, as shown in the following scheme:
ttr
P ⇒ tt, A
bc
P ⇒ A1,..., An, A
provided	A1 ∨ ... ∨ An ← tt ∈ Gnd (P )
This observation leads us to the following property, which states that the
weakening rule is admissible in DLP.
Proposition 3.10 (Admissibility of the weakening rule in DLP) Given a DLP program P and two sets of goals ∆ and ∆' such that ∆ ⊆ ∆', if P ⇒ ∆ then P ⇒ ∆'.
Proof. By simple induction on the structure of DLP proofs.	✷
In order to make a comparison between DLP and LO, we will now present a slight variation of the system in Figure 1. This new system can be proved equivalent to the previous one, and is directly related to the system for LO we will present in Section 5. Here, the right-hand side of sequents is a multiset of goals, and the structural rule of contraction is explicitly added. The system is presented in Figure 2. Adding the rule of contraction makes it possible a slight modification of the rule bc in which the atoms in the head of the relevant program clause are discharged in the upper sequents. The equivalence of the two systems can be proved by simple induction on the structure of derivations


in the systems. The proof entails showing that the contraction and weakening
rules are admissible in the first system. We have the following result.
Proposition 3.11 Given a DLP program P and a goal G, there exists an SLO-refutation of G from P if and only if P ⇒ G is provable in the system of Figure 1 if and only if P ⇒ G is provable in the system of Figure 2.
Proof. (sketch) For the sake of clarity, let us distinguish between provability in the systems in Figure 1 and 2 using the notation ⇒1 and ⇒2, respectively. We also use the notation bc1 and bc2 for the respective backchaining rules. The equivalence between SLO-refutations and ⇒1 provability is by definition (see Definitions 3.3 and 3.4). Note that the exchange rule (i.e. mapping between positive clauses and sets of atoms) is implicit in Definition 3.3. Also, rule ttr can be derived from Definition 3.3 in the special case of clauses with empty body (i.e. unit clauses). The equivalence between ⇒1 and ⇒2 can be proved by showing that ctrr and bc2 rules are admissible in the first system, and bc1 is admissible in the second one:
admissibility of ctrr in the first system follows from the fact that the set A, A, A is equal to A, A (in other words, contraction is implicit in the choice of sets in sequent representation);
bc2 admissible in the first system: suppose H ← C1 ∧ ... ∧ Cm ∈ Gnd (P ); if P ⇒1 C1, A,...,P ⇒1 Cm, A, then by Proposition 3.10 we get P ⇒1 C1, H^ , A,...,P ⇒1 Cm, H^ , A, therefore it follows that P ⇒1 H^ , A;
bc1 admissible in the second system: suppose H ← C1 ∧.. .∧Cm ∈ Gnd (P ); if P ⇒2 C1, H^ , A,...,P ⇒2 Cm, H^ , A, then P ⇒2 H^ , H^ , A; it follows that P ⇒2, H^ , A by applying ctrr to every element in H^ .
✷
As a corollary, given a positive clause C = A1 ∨ ... ∨ An we have that
P ⇒ C is provable if and only if there exists C' ∈ F dlp such that C' ⊆ C.

The Linear Logic Programming Language LO
Linear logic [9] can be viewed as a refinement of classical logic where the use of weakening and contraction is allowed only for formulas within the scope of special modalities (the exponentials ‘!’ and ‘?’). This way, formulas (without modalities) can be viewed as ‘resources’ that can be used only a limited number of times in a proof. Among the possible applications, linear logic turned out to be the natural foundation for extensions of logic programming with a notion of state (in this setting, a collection of bounded-use formulas) [11].
LO [3] is a logic programming language based on linear logic. Its math- ematical foundations lie on a proof-theoretical presentation of a fragment of linear logic called LinLog [2], and comprising the linear connectives ◦− (linear
......
implication), & (additive conjunction),	(multiplicative disjunction), and the
constant T (additive identity). In the propositional case LO consists of the



P ▶ G1, G2, ∆

.....
P ▶ G1, ∆	P ▶ G2, ∆

		...

Tr
P ▶ T, ∆
P ▶ G1
.......
..
...r
& r
P ▶ G1 & G2, ∆


P ▶ G, A
bc
P ▶ H^ , A

with the proviso that H ◦— G ∈ Gnd (P )

Fig. 3. A proof system for LO
following class of formulas:


D ::= A1
.....
..
... 
......
..
An ◦— G | D & D



G ::= G
......
..
G | G & G | A | T

Here A1,..., An and A range over propositional symbols from a fixed signa- ture Σ. G-formulas correspond to goals to be evaluated in a given program. D-formulas correspond to multiple-headed program clauses. An LO program is a D-formula. Let P be the program C1 & ... & Cn. The execution of a multiset of G-formulas G1,..., Gk in P corresponds to a goal-driven proof for
the two-sided LO sequent
P ▶ G1,..., Gk.
The LO sequent P ▶ G1,..., Gk is an abbreviation for the following two-sided linear logic sequent:
!C1,..., !Cn → G1,..., Gk.
The formula !F on the left-hand side of a sequent indicates that F can be used in a proof an arbitrary number of times. This implies that an LO Program can also be viewed as a set of reusable clauses. According to this view, the op- erational semantics of LO is given via the uniform (goal-driven) proof system
defined in Figure 3. In Figure 3, P is a set of implicational clauses, A denotes a multiset of atomic formulas, whereas ∆ denotes a multiset of G-formulas. A sequent is provable if all branches of its proof tree terminate with instances
of the Tr axiom. The proof system of Figure 3 is a specialization of more general uniform proof systems for linear logic like Andreoli’s focusing proofs
[2] and Forum [12]. The rule bc denotes a backchaining (resolution) step. Note
that we have overloaded the · notation (which in Definition 3.9 was used to
..
map V-disjunctions of atoms into multisets) to indicate the mapping of ....-.
disjunctions of atoms into multisets. Also note that bc can be executed only if the right-hand side of the current LO sequent consists of atomic formulas. Thus, LO clauses behave like multiset rewriting rules.

LO clauses having the form a1
......
..
... 
.....
..
an ◦— T play the same role as the

unit clauses of DLP programs. In fact, a backchaining step over such a clause


leads to success independently of the current context A, exactly as in DLP:
Tr
P ▶ T, A
bc
P ▶ A1,..., An, A


provided	A1
......
..
... 
.....
..
An ◦— T ∈ Gnd (P )


An analogous result to that ofProposition 3.10 holds. Thus, LO can be viewed as an aﬃne fragment of linear logic. Note that weakening and contraction are both admissible on the left-hand side (i.e. on the program part) of LO sequents.
Proposition 4.1 (Admissibility of the weakening rule in LO) Given an LO program P and two multisets of goals ∆ and ∆' such that ∆ “ ∆', if P ▶ ∆ then P ▶ ∆'.
Proof. By simple induction on the structure of LO proofs.	✷
Example 4.2 Let P be the LO program consisting of the clauses


a ◦— b
b ◦— (d
.....
.....
..
..
... e)& f

c
e
c
... d ◦— T
..
.. e ◦— b
..
... f ◦— T


......
..


and consider an initial goal e, e. A proof for this goal is shown in Figure 4, where we have denoted by bc(i) the application of the backchaining rule over clause number i of P . The proof proceeds as follows. Using clause 4., to prove

e, e we have to prove b
..
.. c, which, by LO
.
.	rule, reduces to prove b, c. At this
.....

point we can backchain over clause 2., and we get the new goal (d
......
.... e)& f, c.

By applying & r rule, we get two separate goals d
.....
... e, c and f, c. The first,

after a reduction via ...r rule, is provable by means of clause (axiom) 3., while
the latter is provable directly by clause (axiom) 5. Note that T succeeds in a non-empty context (i.e. containing e) in the left branch. A similar proof shows that the goal a is also provable from P .

A Proof-Theoretical Perspective: from DLP to LO
Let us now go back to disjunctive logic programming. In Section 3, we have shown that the operational (top-down) semantics of DLP can be presented in terms of a proof system with an explicit contraction rule. Furthermore, the weakening rule is admissible in DLP. A natural question arises: what happens






P ▶ e, T
Tr

bc(3)		 Tr

P ▶ d, e, c
......
P ▶T 

		. .		
(5)

P ▶ d
.....
...



.....
...r
P ▶ f, c  bc
& r

P ▶ (d ... e)& f, c




bc(2)

P ▶ b, c
......

		. .

P ▶ b
.....
...
...r
bc(4)

P ▶ e, e

Fig. 4. An LO proof for the goal e, e in the program of Example 4.2
if we forbid the use of the structural rules in DLP? Is the resulting language related to the extension of LP based on linear logic? We will answer these questions in two steps. We will first embed DLP into linear logic by means of the following mapping.
Definition 5.1 ([·| mapping) The mapping [·| from DLP formulas into linear logic (LO) formulas is defined by induction on the structure of DLP
......
formulas as follows: [F V G| = [F| ... [G|,  [F ∧ G| = [F| & [G|,  [F ← G| =
[F| ◦— [G|, [tt| = T.
Based on this mapping, the grammar for D- and G-formulas can be rewrit- ten as follows:

H ::= A1
......
..
... 
......
..	n

D ::= H ◦— G | D & D G ::= H1 & ... & Hn  | T
where Ai is an atomic formula. By definition of DLP program, the image of [·| returns a class of LO programs where both the head and the disjuncts in the body have no repeated occurrences of the same atom, Syntactically, the resulting language is a proper subset of the language LO [3] presented in
......
Section 4, where, in addition to the previous formulas, the connectives ... and
& can be arbitrarily nested within LO goals.
It remains to analyze the relation between the operational semantics of the two languages. The operational semantics of LO specialized to the fragment under consideration is given via the proof system defined in Figure 5, where
A denotes a multiset of atomic formulas, H denotes an H-formula, and the
right-hand side of sequents is a multiset of goals. The proof system of Figure 5 is a specialization of the proof system of Figure 3. As before, the bc rule can be executed only if the right-hand side of the current LO sequent consists of atomic formulas, and a sequent is provable if all branches of its proof tree



P ▶ A1,..., An, ∆

.....

		. ..

Tr
P ▶ T, ∆
P ▶ A1
.......
...
.......
..
...r


P ▶ C1, A	...	P ▶ Cm, A
bc
P ▶ H^ , A
with the proviso that H ◦— C1 & ... & Cm ∈ Gnd (P )

Fig. 5. A specialized proof system for a fragment of LO
terminate with instances of the Tr axiom.
The comparison between DLP and LO proof systems is now straightfor- ward. By looking at the system for DLP in Figure 2 and at the one for LO in Figure 5, we can see that, modulo a direct encoding of classical connectives into linear ones, DLP is obtained from LO by adding the structural rule of
contraction. Equivalently, LO can be viewed as a sub-structural logic of DLP
in which contraction is forbidden. We note that the weakening rule, on the contrary, is allowed both in DLP and in LO. By denoting with ▶c the prov- ability in the language LO augmented with a contraction rule analogous to that of Figure 2, and with ▶LL provability in linear logic, we can then state the following proposition. Note that the the exponentials ! and ? in the last sequent are needed to augment linear logic provability with both weakening and contraction (on both sides of the sequent).
Proposition 5.2 Given a DLP program P, P ⇒ G is provable in DLP if and only if [P| ▶c [G| is provable in LO, if and only if ![P| ▶LL?[G| is provable in LL.
A Comparison between Propositional DLP and LO
As a consequence of the proof-theoretical analysis carried out so far, we now present some simple results concerning the propositional fragments of DLP and LO. These results state that in the propositional case LO is strictly more expressive than DLP.
Proposition 5.3 There exists no translation |·| from the classes of proposi- tional LO programs and goals into those of propositional DLP, which preserves provability, i.e. such that for any P and G, P ▶ G is provable if and only if
|P |⇒|G| is provable.
Proof. (sketch) In the propositional case the set of logically distinct clauses is finite (i.e. a V a ≡ a etc.). So is the disjunctive Herbrand base. Let us

consider the infinite sequence of LO goals a, a
......
...
......
......
..
..
.. a, etc. From
......

the observation above, there exists n > m such that |a .... ... (n-times) ... 
......	......
... a|

is logically equivalent (in DLP) to | a ... ... (m-times) ... 
... a |. It remains to

exhibit a program P that distinguishes the two goals in LO. We define P as



..
a .. ... n-times ... 
..
.. a ← T. Clearly, the first goal is provable from P in LO,

while the latter is not. Whatever translation |P | of P we give we will obtain that either the translations (that coincide) of both goals are provable in DLP or they are both non-provable.	✷
On the other hand, the translation from DLP to LO is straightforward.
We have the following proposition.
Proposition 5.4 There exists a translation |·| from the classes of proposi- tional DLP programs and goals into those of propositional LO, which preserves provability, i.e. such that for any P and G, P ⇒ G is provable if and only if
|P |▶|G| is provable.
Proof. It is sufficient to take | G| = [G|, and | P | = [P|∪ Pctr, where [P|
is the program obtained by taking the [·| translation (see Definition 5.1) of
......
every clause in P , and Pctr is the finite set of clauses ai ◦— ai ... ai, one for every
propositional symbol ai in the language. These clauses give a direct encoding of contraction.	✷

A Semantic-based Comparison
In our recent work [4,5], we have shown that LO programs are amenable of a fixpoint semantics that characterizes the set of provable LO goals. As the corresponding semantics for Horn and disjunctive programs, in the proposi- tional case the fixpoint semantics for LO can be computed in a finite number of steps. The fixpoint semantics of LO allows us to investigate in more depth the relationship between LO and DLP. For this purpose, we can employ the mathematical tools provided by abstract interpretation [6], and in particular the notion of completeness that can be used to estimate the precision of an abstraction.
Informally, the comparison between LO and DLP fixpoint semantics is based on the abstraction that maps multisets into sets of atomic formulas (positive clauses). This abstraction induces a Galois connection between the semantic domains of DLP and LO. We prove that the fixpoint semantics of the translation of an LO program in DLP is a correct abstraction of the
fixpoint semantics of the original LO program. Furthermore, we show that this abstraction is not fully complete with respect to LO semantics. In a fully complete abstraction the result of interleaving the application of the abstract fixpoint operator with the abstraction α coincides with the abstraction of the concrete fixpoint operator. For a complete abstraction, a similar relation holds for fixpoints, i.e., the fixpoint of the abstract operator coincides with
the abstraction of the fixpoint of the concrete one. We will show that this weaker property of completeness holds for the abstraction for the entire class of LO programs, thus extending the result presented in [5], which was limited to the class of LO programs without conjunction in the body.


Let us start by giving some definitions used to introduce the fixpoint se- mantics for LO (a detailed presentation can be found in [5]).
Definition 6.1 (LO Herbrand base) The Herbrand base HBP of a propo- sitional LO program P over Σ is the set of all multisets of ground atoms over AΣ.
The previous definition is the same as Definition 3.7, the only difference being that elements are not required to have multiplicity at most one. Given a multiset A, we denote by [A ] the upward closure of A, i.e. {B | A “ B} (e.g. [[{a, b}]] = {{a, b}, {a, a, b}, {a, b, b}, {a, b, c},.. .}). The following definition formalizes the intuition that interpretations are always implicitly considered upward-closed sets. Interpretations whose upward closures are equal are there- fore considered equivalent. This is justified by Prop. 4.1 (admissibility of the weakening rule).
Definition 6.2 (LO Herbrand interpretation) The lattice ⟨I, ±⟩ of LO Herbrand interpretations is defined as follows:
I = P(HBP )/ ↑ where I ↑ J if and only if [[I]] = [[J]];
[I]' ± [J]' if and only if for all B∈ I there exists A∈ J such that A “ B;
the bottom element is the empty set ∅, the top element is the ↑-equivalence class of the singleton {ϵ} (ϵ=empty multiset, ϵ “ A for any A∈ HBP );
the least upper bound I H J is the ↑-equivalence class of I ∪ J.
The equivalence ↑ allows us to reason modulo redundancies. For instance, any A is redundant in {ϵ, A}, which, in fact, is equivalent to {ϵ}. For ease of notation, in the rest of the paper we will identify an interpretation I with its class [I]'. The definition for the fixpoint T lo operator, for the subclass of LO programs we are considering in this paper (i.e. without nesting ofconnectives), can be specialized as follows:
Definition 6.3 (T lo operator) Given an LO program P and an interpreta- tion I, the operator T lo is defined as follows:

T lo(I) = {H^ + (C1 • ... • Cn) | H ◦— D1 & ... & Dn ∈ Gnd (P ),
∀i : 1,..., n, D^i + Ci ∈ I}	∪	{H^ | H ◦— T ∈ P}

This definition is similar to Definition 3.9. Here, we have two differ- ent operations which are both modeled by multiset union in Definition 3.9: multiset union (+) and least upper bound of multisets (•).  For instance,
{a, b} + {b, c} = {a, b, b, c}, while {a, b} • {b, c} = {a, b, c}. Notice how- ever that the two operations are equivalent under α (see Definition 3.8), i.e. α(A + B) = α(A• B). Also note that the case for unit clauses is left implicit in Definition 3.9.
It can be proved that the operator T lo is monotonic and continuous over


the lattice of Herbrand interpretations (ordered wrt. ±). Thus, the fixpoint semantics of an LO program P can be defined as
F lo = . T lo↑i .
P	P
i=0
The relation between operational semantics and fixpoint semantics can be stated as follows.
Proposition 6.4 (Completeness [5]) Let P be an LO program and A ∈
HBP , then P ▶A is provable if and only if there exists A' ∈ F lo s.t. A' “ A.

Example 6.5 Consider the LO program P = {r(a) ◦— T, p(X)
..
... p(X)
......
..

q(X) ◦— r(X)} and the auxiliary predicate t. Then, the Herbrand base HBP is defined as follows {{r(a)}, {p(a)}, {q(a)}, {t(a)}, {p(a), r(a)}, {p(a), p(a), r(a)
}, . . . }. The LO sequent P ▶ p(a), p(a), q(a), t(a) is provable in LO. In fact, by applying a backchaining step we obtain the sequent P ▶ r(a), t(a). Now, we can apply the fact r(a) ◦— T and we obtain an instance of the axiom Tr.
The fixpoint semantics of P is as follows F lo = {{r(a)}, {p(a), p(a), q(a)}}.
Note that {p(a), p(a), q(a)} “ {p(a), p(a), q(a), t(a)}.
We note that, as proved in [5], the fixpoint semantics of a propositional LO program can be computed in finitely many steps. Though the Herbrand base is always infinite (it contains all possible multisets over AΣ, therefore it is
infinite even if AΣ is finite), this property is ensured by the well-quasi ordering
of the lattice of Herbrand interpretations [5].
In the following, we will use the previous semantics and the framework of abstract interpretation to give an alternative, bottom-up account, of the relation between DLP and LO. First of all, we will give a brief summary of some notions related to the theory of abstract interpretation.

Abstract Interpretation
Abstract Interpretation [6,7] is a classical framework for semantics approxima- tion which is used for the construction of semantics-based program analysis algorithms. Given a semantics and an abstraction ofthe language constructors and standard data, abstract interpretation determines an abstract represen- tation of the language which is, by construction, sound with respect to the standard semantics. This new representation enables the calculation of the abstract semantics in finite time, although it implies some loss of precision. We recall here some key concepts in abstract interpretation, which the reader can find in [6,7,8].
Given a concrete semantics ⟨C, TP ⟩, specified by a concrete domain (com- plete lattice) C and a (monotone) fixpoint operator TP : C → C, the abstract semantics can be specified by an abstract domain A and an abstract fixpoint operator T #. In this context, program semantics is given by lfp(TP ), and


its abstraction is lfp(T #). The concrete and abstract semantics S = ⟨C, TP ⟩ and S# = ⟨A, T #⟩ are related by a Galois connection ⟨α, C, A, γ⟩, where α : C → A and γ : A → C are called abstraction and concretization functions, respectively.
S# is called a sound abstraction of S if for all P , α(lfp(TP )) ≤A lfp(T #). This condition is implied by the strongest property of full soundness, which re- quires that α◦TP ≤A T #◦α. The notions of completeness and full completeness are dual with respect to those of soundness. Namely, S# is a (fully) complete abstraction of S if for all P , (T # ◦α ≤A α◦TP ) lfp(T #) ≤A α(lfp(TP )). Often,
P	P
the notion of completeness is assumed to include soundness (i.e. we impose
’=’ in the previous equations). It is well-known[7] that the abstract domain A induces a best correct approximation of TP , which is given by α ◦ TP ◦ γ, and that it is possible to define a (fully) complete abstract operator T # if and only if the best correct approximation is (fully) complete. It can be proved that for a fixed concrete semantics, (full) completeness of an abstract inter- pretation only depends on the choice of the abstract domain. The problem of achieving a (fully) complete abstract interpretation starting from a correct one, by either refining or simplifying the abstract domain, is studied in [8].
We conclude by observing that an equivalent presentation of abstract in- terpretation is based on closure operators[7], i.e. functions from a concrete do- main C to itselfwhich are monotone, idempotent and extensive. This approach provides independence from specific representations of abstract domain’s ob- jects (the abstract domain is given by the image, i.e. the set of fixpoints, of the closure operator).
We are now in the position of connecting the LO (concrete) semantics with the DLP (abstract) semantics.

DLP as an Abstraction of LO
We will define the abstract interpretation by resorting to closure operators. According to this view, we can define the abstract interpretation as a closure operator on the lattice I, the domain of LO interpretations of Definition 6.2. In fact, we can consider disjunctive interpretations as the subclass of I com- prising all sets in I (i.e. all multisets in I with element multiplicity at most one). In other words, the class of disjunctive interpretations is an abstract domain for I. We recall that in I the ordering of interpretations is defined as follows: I ± J if and only if for all B ∈ I there exists A ∈ J such that A is a submultiset of B (i.e., for disjunctive interpretations, A ⊆ B). We give the following definitions.
Definition 6.6 (Abstract Interpretation from LO to DLP) The ab- stract interpretation is defined by the closure operator α : I → I such that for every I ∈ I, α(I) = {α(A) | A ∈ I}.
Note that we have overloaded the operator α of Definition 3.8 to indicate


its extension to interpretations.
Definition 6.7 (Abstract semantics) The abstract fixpoint semantics is given by lfp(T #), where the abstract fixpoint operator T # is defined as (α ◦
P	P
T lo).
According to [7], α ◦ T lo is the best correct approximation of the concrete fixpoint operator T lo, for the fixed abstraction α. The abstraction α trans- forms multisets into sets by forgetting multiple occurrences of atoms. The T # operator is indeed the T dlp operator for disjunctive logic programs of Defini- tion 3.9 (we defined it over domains containing multisets for this purpose). In
other words, T dlp input domain corresponds to the abstract domain which is given by the set of fixpoints, i.e. the image, of the closure operator α. The operations • (least upper bound of multisets) and + (multiset union) used in
the definition of T lo are interchangeable, as already noted before, because of the subsequent application of the operator α, and both correspond to multiset union in the definition of T dlp. Also, the case for unit clauses is left implicit in the definition of T dlp. We have the following results.
Proposition 6.8 (DLP is an abstraction of LO) Given a DLP program

P and a disjunctive interpretation I, T dlp(I) = T #
(I).

P	[P|
Proof. By definitions.	✷
Proposition 6.9 (DLP is a sound abstraction of LO) For every LO program P, the abstract semantics is a fully sound abstraction of the concrete semantics, that is, for every interpretation I, α(Tlo(I)) ± T #(α(I)).
P	P
Proof. As T # = α◦Tlo and I ± α(I), the proposition follows by monotonicity
P	P
of T #.	✷
The previous result implies soundness, i.e. α(lfp(T lo)) ± lfp(T #). The
P	P
strong property of full completeness does not hold for the abstraction. To see
why, take as a counterexample the single clause a ◦— b and the interpretation I
with the single multiset {b, b}. Then, α(Tlo(I)) = {{a, b}}, T #(α(I)) = {{a}},
P	P
and T #(α(I)) /±α(T lo(I)).
P	P
In [5] we have proved a preliminary result, namely that the abstraction is complete for the subclass of LO programs whose clauses contain at most one conjunct in the body (i.e. conjunction is forbidden). This subclass is particularly interesting, as discussed in [5] and briefly mentioned in Section
7.2, because it can be used to encode Petri Nets. We address now the problem of proving completeness of the abstraction for the entire class of LO programs (we remind the reader that we are actually considering the subclass of LO programs corresponding to DLP programs as defined in [13], i.e. without nesting of connectives). We will give an indirect proof of this fact based on the connection between the notion of completeness and proof theory. The proof will be presented in Section 7.1.





P ⇒ tt, ∆
ttr
P ⇒ A, A, A P ⇒ A, A

ctrr


P ⇒ C1, A	...	P ⇒ Cm, A
bc
P ⇒ H^ , A
with the proviso that H ← C1 ∧ ... ∧ Cm ∈ Gnd (P ) Fig. 6. An equivalent proof system for DLP.
A Proof-Theoretical Account of Completeness
In this section we discuss the relations between the notion of completeness of the abstraction and the proof-theoretic notion of permutability of rules, thus creating a bridge between Sections 3.1 and 5, on the one hand, and Section 6.2, on the other hand.
First of all, let us reformulate the proof system for DLP presented in Figure 2. The new system is presented in Figure 6. Here, we have directly plugged the rule Vr inside the backchaining rule. The resulting system can be easily proved equivalent in the following sense: a disjunction of atoms
A1V.. .VAn is provable in the first system ifand only ifthe multiset A1,..., An
is provable in the second. This new proof system corresponds more directly to the formulation of the T lo operator. In particular, if we consider the system which comprises only rules ttr and bc in Figure 6 (i.e. without contraction) we get, modulo the usual mapping between classical and linear connectives, a proofsystem for LO. Moreover, the α step in the definition ofthe T dlp operator is the analogous of the contraction rule in the proof system in Figure 6 (to be precise, α corresponds to multiple applications of ctrr).
To complete the circle, let us now consider the property of completeness,
i.e. α(lfp(T lo)) = lfp(α ◦ T lo). The first expression, α(lfp(T lo)), represents the
P	P	P
abstraction of the set of goals which can be proved from the proof system for
LO (without contraction), i.e. the set of goals which can be proved using the rule of contraction only at the root of the proof tree. The second expression, lfp(α ◦ T lo), represents the set of goals which can be proved by freely using
the contraction rule (to be precise, an application of bc is followed by every possible application of ctrr). Thus, in this view, we have that completeness of the abstraction is equivalent to the following proof-theoretic property:
By restricting the set of proofs in the system in Figure 6 to those in which the contraction rule is applied only at the root of the proof tree, the set of theorems (provable multisets) of the system does not change.
In other words, completeness implies that ctrr and bc are permutable, in the sense that if an application of ctrr occurs above an application of bc, it is possible to find a different proof in which contraction is pushed down, below


the application of bc.


An indirect proof of completeness of the abstraction
We now present a proof of completeness of the abstraction based on the proof- theoretic property of rule permutability discussed above. In particular, we will show an effective algorithm which, given a proof for a multiset A in the system of Figure 6 as input, builds a proof of the same multiset in which the contraction rule is applied only at the root of the proof tree. For illustrative purposes, we will keep the discussion about the algorithm somewhat informal, but a completely formal presentation can be derived in a straightforward way from our description. First of all, let us consider a fixed program P and a generic proof for a multiset A in the system in Figure 6. Except for the leaves, which are instances of the axiom scheme ttr, the proof tree is built
using only bc and ctrr steps. The algorithm operates by recursively pushing
down applications ofthe contraction rule starting from the top and going down to the root. To be precise, the algorithm operates on bunches of contractions,
i.e. on groups of consecutive applications of the contraction rule. In particular,
given a proof, we can isolate an application of bc s.t.:
at least one of its departing branches contains an application of ctrr (oth- erwise, we have finished);
for every departing branch, either it does not contain any application of
ctrr, or it is of the form

α
.
.
P ⇒ ∆'


P ⇒ ∆



ctrr∗

where ctrr∗ represents a bunch of contractions and α does not contain any application of ctrr.
In other words, the algorithm selects for reduction an application of bc which has the form

α1
.
.
P ⇒ ∆'


ctr p1	.
αm
.
.
P ⇒ ∆'



ctr pm



P ⇒ ∆1
r	.
... 
r
P ⇒ ∆m
bc

P ⇒ ∆
where ctrrpi represents a bunch of pi contractions, all pi’s (but one) can be possibly null, and α1,... ,αm do not contain ctrr. The result of an application of a single step of the algorithm is to push down the bunches of contractions


in the above scheme, transforming that proof fragment in the following:






α'	α'
.1	.m
.	...	.
bc

P ⇒ ∆'


P ⇒ ∆
ctrrp






where the natural number p is related to p1,... ,pm, and α' ,... ,α'
do not

1	m
contain ctrr.
Now, before showing how the single step operates, let us clarify that this is sufficient in order to prove that all contractions can be pushed down to the root. In other words, we must show an inductive measure on proofs which guarantees that the recursive application of a reduction step is well founded. There is a very simple induction measure which can be used for this
purpose. Namely, given a proof α, let us call reducible the applications of bc
which are preceded in the proof tree by at least an application of ctrr (i.e. there is a path from a leaf to that application of bc which includes at least one application of ctrr) and reduced the remaining applications of bc. The
induction measure is simply given by the number of reducible applications of bc in the proof tree. After every step, this number decreases by one. In fact, it is clear that the bc application involved in the step was reducible (by
hypothesis) and it is reduced afterwards (for the hypothesis on α' ,... ,α' ).
1	m
Furthermore, it is also clear that the other applications of bc in the tree are
not affected (in particular, an application of bc which was reduced is still

reduced). Note that the proof fragments α' ,... ,α'
in general can be much

1	m
bigger than α1,... ,αm, but this is harmless because they do not contain any
ctrr application. The claim that all ctrr applications can be pushed down to the root then follows from the following facts: i) it is always possible to choose an occurrence of bc for reduction, satisfying the requirements described before, as soon as the proof tree contains reducible occurrences of bc; ii) after every
step, the number of reducible applications of bc decreases; iii) if the number of reducible applications of bc in a proof tree becomes 0, then all ctrr applications are grouped in a bunch at the root of the proof tree.
Let us now describe how a single step of the algorithm works. Let us consider a reducible application of bc satisfying the requirements described before, and let H ← C1 ∧ ... ∧ Cm ∈ Gnd (P ) be the relevant instance of program clause. The fragment of proof tree involved in the transformation



has the following form:
α1
.
.
P ⇒ ∆'




ctr p1	.


αm
.
.
P ⇒ ∆'




ctr pm


P ⇒ C^1, A
r	.
... 
r
P ⇒ C^m, A  bc

P ⇒ H^ , A
For simplicity of illustration, let us assume for the moment that all ctrr appli- cations in this fragment are performed over atoms in C1,... ,Cm. Contractions over the context A are much simpler to address, as we will describe later on. Now, we can safely assume that our proof fragment has the form

α1
.
.
n1
P ⇒ C1 , A



ctr p1	.
αm
.
.
nm
P ⇒ Cm	, A



ctr pm

P ⇒ C^1, A
r	.
... 
r
P ⇒ C^m, A  bc

P ⇒ H^ , A

where pi is given by ni — 1 times the cardinality of the multiset Ci. That is, we are assuming that ni — 1 applications of ctrr are performed over every element of C^i. This is possible because, if we take ni — 1 to be the maximum number of applications of ctrr which are performed over a single element in C^i, then the original ∆' will be a submultiset of C^ ni, A, and, thanks to Proposition 4.1, if
∆' is provable in LO than C^	, A is provable as well (note that LO corresponds
to the system in Figure 6 without contraction). Now, the transformed proof
will have the following form (we show only a small fragment):


.  bc
P ⇒ Cˆ12, H^ z−2, A	... 
.  bc
P ⇒ C^1, Cˆm, H^ z−2, A


.  bc

P ⇒ C^1, H^ z−1, A


P ⇒ H^ z, A

P ⇒ H^ , A
... 

ctrrq
P ⇒ Cm, Hz−1, A
bc

The idea is to perform q applications of ctrr below the relevant bc, where q
is given by z — 1 times the cardinality of H, and we choose z to be n1 + n2 +
... + nm — m + 1. The goal Hz, A contains z occurrences of H, therefore, after performing one step of backchaining, we will get m departing branches which contain z—1 occurrences of H. We can recursively apply backchaining (always using the original program clause) on each of the sub-branches, until all z


occurrences of H^ have been consumed. What we get is a (partial) proof tree
made only of bc applications; this proof tree has depth z and every node has exactly m children. Now, let us consider the leaves of this (partial) proof tree. One single leaf is on a path leading to P ⇒ Hz, A, and at every step one of the
occurrences of H is rewritten in one multiset taken from C1,... ,Cm. Therefore,
the leaf will contain a combination of z multisets taken from C1,. . . ,Cm. Now, if the leaf contains at least n1 occurrences of the multiset C1, we have finished.
n1

In fact, this means that
C^1
, A is a submultiset of the leaf, and, by the

hypothesis on α1 and Proposition 4.1, this implies that there exists a proof α'
for the leaf which does not contain contractions. If the leaf contains less than n1 occurrences of C1, then it will contain at least z — (n1 — 1) = n2 + ... + nm — m + 2 occurrences of multisets taken from C2,. . . ,Cm. We can repeat the same kind of reasoning (formally, the proof is by induction on m), and the last alternative will be that the leaf contains at least nm —m+m = nm occurrences of the multiset Cm, from which we can conclude. The same reasoning can be repeated for every leaf, thus we can complete the partial proof tree using only bc and ttr rules.
Finally, we note that contractions performed over the multiset A which is not directly involved in the backchaining step are even simpler to address. In fact, A is simply passed unchanged to every sub-branch, therefore we can transfer these contraction steps below the original bc application. It is suffi- cient to perform, for every element in A, as many ctrr steps as the maximum number of such steps performed over that element, where the maximum is taken among the original m bunches of contractions.
On the basis of the above discussion and of the connection between LO and DLP provability and the proof system in Figure 6, we can then state the following lemma.
Lemma 7.1 A multiset A is provable in DLP if and only if there exists a multiset A' s.t. A' is provable in LO and A = α(A').
The result of completeness of the abstraction then easily follows.
Proposition 7.2 (DLP is a complete abstraction of LO) Let P be an LO program. Then lfp(T #) ± α(lfp(T lo)).
P	P
Proof. Given A ∈ lfp(T #), by Lemma 7.1 there exists A' provable in LO
s.t. A = α(A'). As A' provable in LO, by Proposition 6.4 there exists A'' ∈
lfp(T lo) s.t. A'' “ A'. Then, α(A'') ∈ α(lfp(T lo)) and α(A'') “ α(A') = A. ✷
P	P
We conclude the section with a brief discussion about the application of LO and DLP to Petri Nets.
LO, Petri Nets, and DLP
As shown in [5], the class of propositional LO programs with one conjunct in the body is equivalent to Petri Nets. In fact, a multiset rewriting rule can be


used to describe the effect of firing a Petri Net transition. For instance, the

clause a
......
..
.....
..
b ◦— c
.....
..
c can be interpreted as the Petri Net transi-

tion that removes one token from place a, two tokens from place b, and adds two tokens to place c. As a consequence, a (possibly infinite) execution of a restricted LO program denotes an execution of the corresponding Petri Net. The initial goal can be viewed as the initial marking of the Petri Net, while the set of axioms can be used to implicitly give a description of the reachable states. As a consequence of the admissibility of weakening (Proposition 4.1), an axiom represents an infinite, upward-closed set of markings. As a conse-
quence, provability in LO can be used to axiomatize coverability problems of
Petri Nets. What does coverability mean? Let us first recall the following

notions. Given two markings m→
and →n, m→
covers →n if and only if, for every

place, the number of tokens in m→ is greater or equal than the number of to-
kens in →n. The coverability problem for a Petri Net N is formulated as follows:
given the initial marking m→0 and a marking →n, is there a marking m→ reachable
from m→0 that covers →n? Let P be the LO program that represents the Petri Net N , and let A0 and A the multisets that represent m→0 and →n, respectively. The coverability problem for N , m→0 and →n can be formulated as the following LO provability question: is there A' “ A0 such that A' is provable in the

program P enriched with the clause H ◦— T, where H = A1
..
.. ... 
..
... An for

A = {A1,..., An}? This problem can be solved via the bottom-up computa-
tion of all logical consequences of P ∪ {H ◦— T}. Coverability problems are strictly related to verification of safety properties of concurrent systems ex- pressed as Petri Nets (see e.g. [1]). In fact, in many practical examples unsafe states can be represented as upward-closed sets (e.g. the set of states where there are at least two processes in the critical section are the typical bad states
of a mutual exclusion algorithm). In all these situations, the verification of the corresponding safety property can thus be reduced to the dual of a coverability problem for the minimal violations. More specifically, this kind of problems can be solved by computing the set of predecessors Pre∗(U ) of the unsafe states, i.e., the set of logical consequences obtained by expressing U as an LO axiom. The results of Section 6.2 show that the fixpoint semantics of DLP can be used to approximate Pre∗(U ). Completeness implies that all proper- ties that are preserved by the abstraction can be checked equivalently over
the concrete and the abstract domain. In our setting the kind of properties that satisfy this requirement can be informally characterized as at-least-one properties (e.g. the set of markings which contain at least one token in a given place).

Conclusions and Future Work
In this paper we have used operational (proof-theoretical) and declarative (fix- point semantic) tools to compare the paradigm of DLP with the paradigm of linear logic programming (more specifically, the language LO). The compari-


son is based on the abstraction that maps multisets into sets ofatomic formulas (positive clauses). This abstraction induces a Galois connection between the semantic domains of DLP and LO. The abstraction is not fully complete. In a fully complete abstraction the result of interleaving the application of the abstract fixpoint operator with the abstraction α coincides with the abstrac- tion of the concrete fixpoint operator. For a complete abstraction, a similar relation holds for fixpoints, i.e., the fixpoint of the abstract operator coincides with the abstraction of the fixpoint of the concrete one. In proof-theoretical terms, the abstraction corresponds to allowing unlimited use of contraction in the proof system for LO. In this view, we have shown that the property of completeness implies that contraction steps permute with the other inference rules, in the sense that given a proof for a goal G it is always possible to find an alternative proof for G in which the contraction steps are performed only at the root of the proof tree.
We think that our study can help in getting a new insight into the relations between provability in fragments of classical and linear logic, on the one hand, and into the relations between top-down and bottom-up semantics, on the
other hand. We hope that our research will also give rise to new ideas for the analysis of LO programs. As an example, it could be interesting to study weak notions of negation for LO that are based on the negation of DLP. Also, we have mentioned another possible application of DLP operational and fixpoint semantics, namely Petri Nets analysis. Finally, there is still some on-going work concerning the relation between DLP and LO in the setting of abstract interpretation. In particular, we are studying a direct proof of completeness of the abstraction and its relationship with the indirect proof presented in this paper. Also, formally studying the complexity of the transformation between generic DLP proofs and restricted DLP proofs (as shown in the proof of completeness) could be worth in order to quantify the gain obtained by proving properties on the abstract domain rather than on the concrete one.

Acknowledgments
We would like to thank the anonymous referees of AGP 2000 for useful com- ments and suggestions that helped us to improve the paper.


References
Abdulla, P. A., K. Cera¯ns, B. Jonsson and Y.-K. Tsay, General Decidability Theorems for Inﬁnite-State Systems, in: Proc. 11th Annual IEEE Int. Symposium on Logic in Computer Science (LICS’96) (1996), pp. 313–321.

Andreoli, J.-M., Logic Programming with Focusing Proofs in Linear Logic, Journal of Logic and Computation 2 (1992), pp. 297–347.


Andreoli, J.-M. and R. Pareschi, Linear Objects: Logical Processes with Built-In Inheritance, New Generation Computing 9 (1991), pp. 445–473.
Bozzano, M., G. Delzanno and M. Martelli, A Bottom-up Semantics for Linear Logic Programs, in: M. Gabbrielli and F. Pfenning, editors, Proc. 2nd International Conference on Principles and Practice of Declarative Programming (PPDP’00) (2000), pp. 92–102.
Bozzano, M., G. Delzanno and M. Martelli, An Effective Fixpoint Semantics for Linear Logic Programs, Theory and Practice of Logic Programming (2001), To appear.
Cousot, P. and R. Cousot, Abstract Interpretation: A Uniﬁed Lattice Model for Static Analysis of Programs by Construction or Approximation of Fix-Points, in: Proc. 4th Symposium on Principles of Programming Languages (POPL’77) (1977), pp. 238–252.
Cousot, P. and R. Cousot, Systematic Design of Program Analysis Frameworks, in: Proc. 6th Symposium on Principles of Programming Languages (POPL’79) (1979), pp. 269–282.
Giacobazzi, R. and F. Ranzato, Completeness in Abstract Interpretation: A Domain Perspective, in: M. Johnson, editor, Proc. 6th International Conference on Algebraic Methodology and Software Technology (AMAST’97), Lecture Notes in Computer Science 1349 (1997), pp. 231–245.
Girard, J., Linear logic, Theoretical Computer Science 50:1 (1987), pp. 1–102.
Karp, R. M. and R. E. Miller, Parallel Program Schemata, Journal of Computer and System Sciences 3 (1969), pp. 147–195.
Miller, D., A Survey of Linear Logic Programming, Computational Logic: The Newsletter of the European Network of Excellence in Computational Logic 2 (1995), pp. 63–67.
Miller, D., Forum: A Multiple-Conclusion Speciﬁcation Logic, Theoretical Computer Science 165 (1996), pp. 201–232.
Minker, J., A. Rajasekar and J. Lobo, Theory of Disjunctive Logic Programs, in: J. Lassez and G. Plotkin, editors, Computational Logic. Essays in Honor of Alan Robinson, MIT Press, 1991 pp. 613–639.
