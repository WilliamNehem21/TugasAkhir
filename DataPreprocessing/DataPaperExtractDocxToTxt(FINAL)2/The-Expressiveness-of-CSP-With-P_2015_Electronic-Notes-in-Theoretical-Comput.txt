Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 319 (2015) 387–401
www.elsevier.com/locate/entcs
The Expressiveness of CSP With Priority
A.W. Roscoe1
Oxford University Department of Computer Science

Abstract
The author previously [16,15] defined CSP-like operational semantics whose main restrictions were the automatic promotion of most τ actions, no cloning of running processes, and no negative premises in operational semantic rules. He showed that every operator with such an operational semantics can be translated into CSP and therefore has a semantics in every model of CSP. In this paper we demonstrate that a similar result holds for CSP extended by the priority operator described in Chapter 20 of [15], with the restriction on negative premises removed.
Keywords: CSP, operational semantics, priority


Introduction
As well as its denotational semantics in models such as traces T and failures- divergences N , CSP [11] has a well-established operational semantics first described in SOS in [5,6], and congruence with that is perhaps the main criterion for the ac- ceptability of any new semantic model.
The author previously created a class of CSP-like operational semantic defini- tions that automatically have semantics over every CSP model. In addition to a number of other restrictions on the full generality of Structured Operational Se- mantic (SOS) definitions, CSP-like ones are not permitted any negative premises: thus there can be no rule in which some action can fire only if one of its arguments can not perform some (either one or more) action(s).
There have been a number of proposals for adding priority to CSP. A straight- forward one, because it does not involve building special semantic models or types of LTSs, was proposed in [15]. Pri≤(P ), for a partial order on the events that pro- cesses perform, permits P an event x only when no higher priority event is possible. With restrictions on how the invisible event τ fits into ≤, this adds very usefully to CSP, for example by permitting the accurate description of real-time systems.

1 Email: bill.roscoe@cs.ox.ac.uk

http://dx.doi.org/10.1016/j.entcs.2015.12.023
1571-0661/© 2015 The Author. Published by Elsevier B.V.
This is an open access article under the CC BY-NC-ND license (http://creativecommons.org/licenses/by-nc-nd/4.0/).

Pri≤(·) is not CSP-like since it requires negative premises. Indeed it does not have a semantics in most CSP models. This raises the question of whether we can capture a notion of Pri-CSP-like operational semantics which includes this operator, where all Pri-CSP-like operators can be expressed in terms of CSP plus Pri≤(·). Establishing such a notion is the job of the present paper.
In the next section, we remind ourselves about CSP and its operational seman- tics. We then recall CSP-like operational semantics and outline their expressiveness result. Finally we recall the definitions of Pri≤(·) in terms of operational semantics and over FL, the ﬁnite linear or ready traces model that can record an acceptance set before each event. In Section 3 we generalise the definition of CSP-like to achieve the goal set out above. The main result of this paper then follows, in which we show that any operator (or class of operators) with such Pri-CSP-like operational semantics can be simulated precisely in augmented CSP. The precision obtained by this simulation depends on whether or not the language involves the CSP concept of termination, represented C. However, for brevity this paper does not include the role of C in CSP semantics: it is fully covered in the extended version [18].
As with [16], the primary motivation of this paper is to characterise what opera- tors and languages can be translated into CSP (in this paper extended by Pri≤(·)) to identify which of these can be handled on the model checker FDR [9], which itself now supports this operator 2 . We give some examples of what is now representable in Section 5.

Background
The operational semantics of CSP
The SOS operational semantics [5,6] of CSP came along after its well-known deno- tational semantics. For CSP (without C and sequential composition), the action labels come from Σ ∪ {τ }, where Σ is the alphabet, the actions that are visible to and controllable by the external observer, and τ is an invisible and uncontrollable event such that whenever it is enabled and another event does not happen quickly, it will. Given the process P , αP means its own set of Σ actions, which is usually just the visible events it uses.
In SOS style [13] we need rules to infer every action that each process can perform. The conditions that enable actions can be of three sorts:
Positive: Some other process can perform a specific action. This other process is determined from the syntax of the process P whose transitions we are calculating. In our setting these other processes are, except in the case of recursion, arguments of the operator whose semantics we are defining.
Negative: The same except the other process cannot perform a given action.
Side conditions on the actions etc that appear.

2 FDR3 supports two priority operators: prioritisepo is directly equivalent to the one used in this paper, while prioritise is a restricted case that does not require the programmer to construct an explicit partial order.

A rule has a set of actions/alphabets etc parameters, and some positive and/or negative premises. A rule with free parameters other than processes is a rule schema denoting a separate formal rule for each permitted value of these.
CSP has a few constant processes, a number of operators which can be applied to argument processes, and recursive constructions. The operational semantics of constants simply describe their actions directly. STOP , which has no actions, has no operational rules. Other constants are RUNA, which performs any sequence of events from A ⊆ Σ and never refuses one, ChaosA, which is the most nondeter- ministic non-divergent process on the events A, 3 and div, which simply diverges: performs an infinite series of τ s.
There are two approaches to the operational semantics of recursion:
P [μ p.P/p] −x→ Q



μ p.P −τ→ P [μ p.P/p]
(A)
μ p.P −x→ Q
(B )

where p is a process identifier and P a process term where p may be free. Rule (A) introduces a τ every time a recursion is unwound, and Rule (B) does not. Thanks to the CSP principle that the process τ.P (in CCS notation: one that performs a τ before becoming P ) is equivalent in all but operational semantics to P , there is no observable difference between the results of these two rules, provided (B) is well defined. For a clean analysis of operational semantics, (A) is better as the τ guards eliminate problems caused by under-defined recursions (of which the simplest example is μ p.p), which become more severe in the presence of negative premises. Without such an undefined recursion (one where the first-step actions of a re- cursive body P [Q/p] are not independent of those of Q , or where the derivation of actions in an infinite mutual recursion is not well founded, as with the recursion Pi = Pi+1 2 a → STOP ), such problems do not arise and (B) gives a more efficient LTS (i.e. less states and transitions). In this paper, for simplicity (not only with negative premises) we generally assume approach (A) in any case where it cannot be determined simply that every recursive call is guarded by at least one action
(which can be τ ), and the more efficient (B) otherwise.

The transition rules of CSP operators
Communications are introduced via preﬁxing e → P . It has rule




e → P −a→ subs(a, e, P )
(a ∈ comms(e))

Here e may represent a range of possible communications and bind one or more identifiers in P , as in the examples ?x : A → P , c?x ?y → P and c?x !e → P . We assume the existence of functions

3 A formulation of ChaosA valid in all CSP models has τ transitions to ?x : B → ChaosA for every B ⊆ A. This can be simplified when only the most common semantic models are in use to have only two states: one which can do a τ to STOP (the other state) or any member of A to itself.

comms(e) is the set of communications described by e. For example, d.3 repre- sents {d.3} and c?x :A?y represents {c.a.b | a.b ∈ type(c), a ∈ A}.
If a ∈ comms(e), subs(a, e, P ) substitutes part of a for each identifier bound by
e. So subs(c.1.2, c?x ?y, d !x → P (x , y )) = d !1 → P (1, 2).
Nondeterministic choice picks an argument to act like:

P H Q −τ→ P	P H Q −τ→ Q
The initial actions of prefixing and P H Q do not depend on those of process arguments. All the other operators have rules that allow us to deduce what actions a process of the given form has from the actions of the sub-processes. Operators may have some arguments ‘active’ and some ‘inactive’. The former are those whose actions are immediately relevant, the latter the ones which are not needed to deduce the first actions of the combination.
Both arguments of external choice (2) are active. When an argument is active, it must be allowed to perform any τ action it is capable of, since the argument’s environment (in this case the operator) is incapable of stopping them. Such τ actions are invisible to the operator, so there are always rules like the following for active arguments:


P −τ→ Pj


P 2 Q −τ→ Pj 2 Q
Q −τ→ Qj


P 2 Q −τ→ P 2 Qj

which simply allow the τ to happen without otherwise affecting the process state. These promote the τ actions of the arguments to τ actions of the whole process. 2 can use visible actions, here resolving the choice.


P −a→ Pj
P 2 Q −a→ Pj (a /= τ )
Q −a→ Qj
P 2 Q −a→ Qj (a /= τ )

It is important that the argument P of e → P is inactive. If not, it would be allowed to perform τ s so a → P might diverge without performing a.
The rules for hiding and renaming both allow all the actions of the underlying process but change some of the names of the events. Renaming applies a relation to visible ones; hiding turns selected actions into τ s.


P −x→ Pj
P \ B −x→ Pj \ B	(x /∈ B )
P −τ→ Pj
P −a→ Pj
P \ B −τ→ Pj \ B	(a ∈ B )
P −a→ Pj

P [[R]] −τ→ Pj[[R]]
(aR b)
b	j

P [[R]] −→ P [[R]]
We give the semantics of just one parallel operator. Others can be deduced from

it: P 
X
Q synchronises P and Q on all actions in X , and lets them communicate

freely on other events. Both arguments are active
P −τ→ Pj	Q −τ→ Qj
X	X	X	X
There are three rules for visible events: two symmetric ones for a /∈ X




X
P −a→ Pj




X

(a ∈ Σ \ X )
Q −a→ Qj

X	X

(a ∈ Σ \ X )

and one to show a ∈ X requiring both participants to synchronize
P −a→ Pj	Q −a→ Qj



X	X
(a ∈ X )



Other forms of CSP parallel are interleaving P 9 Q , equivalent to P
 Q , and
$

alphabetised parallel P A  B Q , which forces P to communicate all events in A, and
Q in B . Provided that P and Q do not attempt to communicate outside A and B

respectively it is equivalent to P
	Q .
A∩B

CSP provides two ways of getting one process to take over from another without
the first one terminating: interrupt P Δ Q allows P to run, but at any time offers the initial events of Q . If one of the latter happens then Q takes over. Both arguments are initially active.

P −τ→ Pj


P Δ Q −τ→ Pj Δ Q
Q −τ→ Qj


P Δ Q −τ→ P Δ Qj

If P performs a ∈ Σ, then the result is interruptable, whereas if Q performs a ∈ Σ, then it takes over.

P −a→ Pj
P Δ Q −a→ Pj Δ Q (a ∈ Σ)
Q −a→ Qj
P Δ Q −a→ Qj (a ∈ Σ)

The other operator allows any event from P in the set A to close it down and hand over to Q : the throw operator P ΘA Q . P is active: it is allowed to perform τ or a /∈ A and carry on whereas a ∈ A hands control to Q :
P −x→ Pj	P −a→ Pj

P ΘA
Q −x→ Pj ΘA
(x /∈ A)
Q
P ΘA
a	(a ∈ A) Q −→ Q

The operational semantics of Pri≤(·) can be found in Section 2.4.
CSP-like operational semantics
All premises above are positive. The rules also have properties

If an argument process performs an action P −x→ Pj in the premises, and remains after the derived action then P has become Pj in the result.
If an argument process does not act in the premises, then if it remains after the action it stays in its initial state.
If P appears in any of the premises of the operator F (P,.. .) (i.e., the initial
actions of F (P,.. .) depend on those of P ), and P −τ→ Pj, then F (P,.. .) −τ→
F (Pj,.. .). There are no other rules with τ as a premise.
No argument process ever appears more than once in the result of any actions. This is the no cloning property. In fact CSP can clone inactive arguments via recursion, but never active ones.
In [16,15], the author codified all of the above conditions together, including the banning of negative premises, and described an operational semantics all of whose operators obey these principles as CSP-like. The clearest way of doing this was creating a new notation for operational semantics, so constrained that it can only express CSP-like operators.
CSP-like operational semantics bears close comparison with simply WB cool rules as defined in [10]. This is a restriction on SOS that ensures that operators respect weak bisimulation (hence WB). We adopt some of the nomenclature of [10], though this is different from that in [15,16]. This includes the terms active, and inactive otherwise. [15,16] termed these on and off respectively. The rules which simply promote a τ action are called patience rules.
In giving a combinator semantics for the operator F (P1,..., Pn ), the first thing we need to identify is which of the Pi are initially active: which of them appear in the premises of Fjs SOS operational rules. The notation we will use for an operator with active arguments P and inactive ones Q in defining its combinator semantics will take the form F Q(P), emphasising that the active ones are those immediately relevant. We allow an infinite number of components to Q. This case does arise in CSP, both thanks to taking the nondeterministic choice of an infinite number of processes and, in the case where the alphabet Σ is infinite, prefix constructs (such as c?x → · when the type of c is infinite). We only allow finitely many active arguments: not only does the infinite case not arise in CSP, but it is theoretically problematic.
As with SOS, a combinator operational semantics consists of rule schemas, with events, sets of events etc varying under side conditions to create sets of rules for individual operators. An individual rule takes the form of a triple, sometimes ab- breviated to a pair.
The first component is a tuple with one component for each active argument. The members of this m-tuple (x1,..., xm ) are taken from Σ ∪ {·}. The meaning of this tuple is that all active arguments whose component is not “·” perform the relevant action, in a synchronised fashion, for the rule to fire. (We will put quotes around · in text to help distinguish it.) Note that in some CSP operators m = 0, which simply says that all of the operator’s actions are unconditional on arguments’ actions. In these cases we write the now null premises as . Note

that τ is not permitted in these tuples: we will discuss this below.
The second component is an action y in Σ ∪ {τ} which represents the result action of the rule: the one that the operator performs when the active arguments perform the components of the first. Hiding gives a case where a visible action is turned into τ , hence the possibility of y being τ .
The third component represents the successor process after the action. There are two possibilities here:
The result of the action does not change the process’s shape: it is still the same operator applied to the same arguments, the only change being that those active arguments that have participated in the action have moved forward according to respective component actions. This is a common case, and applies to all actions of parallel, hiding and renaming operators, and combinations of these. The third component is then omitted, so the combinator becomes a pair. Such combinators are homogeneous.
In any other case we do need to record the state that the process moves into. This will always be a piece of syntax with place-holders for the active and inactive arguments. The form of this syntax has to be restricted so as to prevent either the cloning or suspension of the active arguments of the original operator. The syntax can, however, do what it likes with the inactive arguments, and discard any argument it wishes.
The way combinators build the syntax of successor processes can be defined by specifying that they must treat active arguments, if they are retained at all, in a way that keeps them active and follows the principles of distributivity, common to all non-recursive CSP operators. This is a piece of syntax T in which each argument (active and inactive) is represented by some standardised identifier. For us these are bold-face indices drawn from {1,..., m}∪ I , so 1 represents the first active argument, and so on. The result state is now T with the substitutions:

An index i ∈ {1,..., m} is replaced by Pi
on whether xi = · or xi ∈ Σ.
An index i ∈ I is replaced by Qi .
or Pj such that Pi
−x→i
Pj depending

To follow the principles above we have to impose conditions on T :
No active index i ∈ {1 ..., m} can appear more than once in T .
Such active indexes only appear at immediately distributive (ID) places in T (i.e., where the operational semantics we can derive for T makes a process argument placed here initially active). This is easy to define by structural recursion:
The appearance of i in the simple term i is ID.
If i appears ID in the term T , then it appears ID in L(..., T,.. .), where the place T is an active argument of the CSP-like operator L.
No other appearance of i, including any in a recursive definition, is ID.
The pieces of syntax T above can contain arbitrary closed CSP processes at any point without restriction
Hiding P \ X has rules (a, a)[a /∈ X ] and (a,τ )[a ∈ X ], using the convention that

for operators with a single active argument, we write a rather than (a) for the first component. The result of P \ X processing an action P −a→ Pj is always Pj \ X , so its combinators are homogeneous. On the other hand, the resolution of P 2 Q does change the process structure, so its rules are ((a, ·), a, 1) and ((·, a), a, 2): either side
can perform any action in Σ, resolving the choice. We do not write down patience rules since they always apply.
Definition 2.1
An operator (language) is CSP-like if and only if it (all its operators) can be given a combinator operational semantics.
Theorem 2.2 Every CSP-like operator F has a translation to CSP which we write FCSP such that, for any collection of arguments (P, Q), the operational semantics
of F Q(P) and F Q (P) are strongly bisimilar.
Therefore any CSP-like operator has a fully compositional semantics over any model of CSP.
The proof can be found in [16,15] 4 . and is indicated in that of the main theorem of this paper.
Priority
While there have been a number of versions of CSP with priority, for example [12,7], the one we use in this paper is that introduced in [15]. This is conceptually simple, as it does not require any re-interpretation of LTS’s or CSP models as entities where one action has priority over another. Instead Pri≤(·) inputs an ordinary LTS and the result is another ordinary one. ≤ is a partial order on events Σ ∪ {τ } which is subject to several conditions stated below. The SOS operational semantics are
P −x→ Pj ∧∀ y.y > x ⇒ ¬P	y
Pri≤(P ) −x→ Pri≤(Pj)
P performs actions that are not strictly lower under ≤ than another action that P can perform from the same state. In the above, x and y range over the whole of Σ ∪{τ}. In order to make this consistent with the tenets of CSP we need to respect the idea that τ is not controllable and that every process is equivalent to the one where a single τ precedes it:
τ is maximal in ≤: it is not dominated by any other event.
If a < b for any actions a and b, then a <τ 
Only the richest CSP models make Pri≤(·) compositional. Of those discussed in Chapters 10, 11 and 12 of [15], the only ones compositional for the full range of permitted ≤ are the FL class of models, recording traces extended by one of the following before each event and after the last:

4 Tom Gibson-Robinson [8] implemented the constructions of [16], thereby providing a translation of arbi- trary CSP-like operators into CSP for use on FDR [9].

• meaning that the state from which the next event happened, or at the end of the behaviour, has not been observed to be stable (i.e., a state where no τ is possible).
Where stability is observed, the exact set of events that the state offers.
Thus a typical behaviour looks like ⟨A0, a1, A1,..., An−1, bn , An ⟩ with the bi being drawn from Σ. and the Ai being drawn from {•} ∪ P(Σ)
The semantics of Pri≤(P ) over FL are as follows, quoted from [17].
{⟨A0, b1, A1,..., An−1, bn , An ⟩| ⟨Z0, b1, Z1,..., Zn−1, bn , Zn ⟩∈ P}
where for each i one of the following holds:
bi is maximal under ≤ and Ai−1 = • (so there is no condition on Zi−1 except that it exists).
bi is not maximal under ≤ and Ai−1 = • and Zi−1 is not • and neither does Zi−1
contain any c > bi .
Neither Ai nor Zi is •, and Ai = {a ∈ Zi | ¬ ∃ b ∈ Zi .b > a}.
In each case where Ai−1 /= •, bi ∈ Ai−1.
Priority is not CSP-like, so we name the extended language Pri-CSP.
What can we express in Pri-CSP?
Pri≤(·) has some of the qualities of CSP-like operators, for example it has the patience property, and never clones its argument. The only one it obviously fails is the ban on negative premises.
To grasp what can be expressed in Pri-CSP we change the expressive power of combinators. Recall that the first component of a combinator is a tuple of actions from the active processes. We can extend this by turning the components of this tuple into pairs. The first component is either an action in Σ that the corresponding process should perform or “·” if it does not perform one in the action. The second is a set of events, which if non-empty contains τ (if not written down it is assumed implicitly), that the process must not be able to perform if the rule is to fire. We annotate such negative premises with the negation symbol ¬. A negative premise can only be satisfied in a stable state of its argument.
We will be liberal with the way we write down such pairs: where one or other component is trivial (i.e., · or ∅ (rather than {τ})) we will just write the other, and if both are trivial we will just write “·”.
There is no difference in the second component of combinators. However, prob- lems discussed fully in [18] make us more restrictive in the syntax of the allowed third component syntax T . Specifically we restrict the third component to be any of
One of the argument processes by itself (a common case in CSP): this can be active or inactive in the original state.

Any constant CSP process (one that does not refer to any argument).
Any Pri-CSP operator application where each active argument of the original operator, if it appears at all, appears in exactly one place amongst the active arguments of the new operator.
We again assume a patience rule for each active argument. A homogeneous n- combinator is one where the third component is omitted because the result has the same structure as the initial process.
Any combinator with a negative premise is termed an n-combinator, and an n- combinator operational semantics is one in terms of these and ordinary combinators. A positive combinator semantics is one with only ordinary combinators.
Pri≤(·)’s operational semantics can itself be expressed in these extended combi- nators. It has the implicit patience rule and, for each a ∈ Σ maximal in ≤ the simple combinator (a, a). For non-maximal a it has the n-combinator ((a, ¬{x ∈ Σ ∪ {τ}| a < x}), a), where we note that the set of negative premises always includes τ due to the restrictions placed on ≤ in the definition of the priority operator.
Recall that the operator P ΘA Q starts Q whenever P communicates an element in A. We can think of this as P throwing an exception. With n-combinators we could build an operator P ΔΘQ in which any deadlock in P was caught and starts Q : with the active argument P it would simply need the combinators (a, a) for a ∈ αP plus the n-combinator (¬αP, τ, q), where q points to the inactive argument
Q . Once we have discussed the implementation of general negative premises later, we will show how to implement this.
Definition 3.1 An operator has Pri-CSP-like operational semantics if its opera- tional semantics can be given according to the above conventions in terms of com- binators and n-combinators.
Expressibility theorem
Theorem 4.1 Suppose the operator F Q(P) is Pri-CSP-like together with all other operators reachable (transitively) through the T third components of its combinators. Then for any arguments P and Q, F Q(P) is expressible in Pri-CSP in the sense that the simulation is strongly bisimilar to F Q(P).
This implies that such operators have a compositional semantics over FL.
As in [16,15], our proof is to construct the (Pri-)CSP implementation. This is even more complex than the one without negative premises. For the issues in common with the earlier result, the constructions we use have a lot in common, though we do find several simplifications.
First we consider the case of homogeneous combinators (no negative premises). Thus we consider operators whose combinators are all of the form (p, a), with p having no negative aspect.
Next we consider how to add similarly restricted n-combinators. This is the heart of the extension to the original construction.

The next step is to allow actions to throw away active arguments.
We then allow non-homogeneous combinators, but only ones that use the ex- isting active arguments rather than inactive ones.
The final stage is to show how to use inactive arguments.
In this version of the paper we concentrate on the first two stages. The rest are given in detail in the extended version. At each stage the simulation we build takes the form of the parallel composition of processes representing each argument that is active, plus additional parallel components to regulate behaviour, and “zombie” processes representing those that have been inactivated.

Homogeneous positive combinators
In this case (in a simplification from the construction in [16,15]), the simulation will take the form


(((
n  i =1
(Ai , Pi [[Ri ]])) ∪A  C RUNC )[[CR]]) \ {Tau}

where P1,..., Pn are the (all active) arguments of some operator F . Tau is a member of Σ we introduce to model a combinator generating a τ action. ∪A is the union of the Ai .
Let C be the set of combinators for F . We add C into the alphabet and can construct the renamings as follows.
Ri maps each event a of Pi to each combinator which requires the i th argument to perform a.
CR maps the combinator (p, a) to a if a ∈ Σ, and to Tau if a = τ .
Ai consists of all combinators c which have a proper premise (i.e., not “·”) in position i .
The RUN process provides a way in which combinators with no active arguments can happen. It is later replaced by more elaborate regulator processes.
Any Pi that can perform a τ can perform it in the simulation, with the simulation state progressing exactly as we require in the patience rule that F must have for its i th argument.
The event representing the combinator c can occur precisely when the premises of c are met (i.e., each non-“·” component performs the appropriate event). The renamed Pi can then synchronise to perform c, which CR and the hiding of Tau combine to turn into its own second component. Again the successor state (with just the Pi that contribute to c progressing) is exactly the one that simulates the state that the combinator semantics will have reached under the same action.
Every state reachable from F (P1,..., Pn ) in our restricted circumstances is of the form F (Pj ,..., Pj ) for Pj some state of Pi , and by the above observations this
1	n	i
state is strongly bisimilar – indeed isomorphic in the sense of transition systems –

to the following simulation state.


((	(A , Pj[[R ]]))
RUN
)[[CR]] \ {Tau}

i =1	i	i	i
∪A C	C

We have therefore completed the construction in this first case.

Adding negation
Suppose for the moment that no combinator has both positive and negative premises for the same argument. Then we can get the argument process if necessary to contribute one or other to the firing of the combinator. We know how to achieve this for positive ones. For negative premises we can use priority to deliver an event just when some set of actions is not possible.
For the S ⊆ Σ that might (each together with {τ}) be negative premises for ar- gument process P , let чS be a new event that will represent P ’s inability to perform any of them. Let the set of such чS for P (in the context it is placed) be negs(P ). Then Negate0(A, P )= Pri≤P (P 9 RUNnegs(P )) where чS <P a if and only if a ∈ S , can perform чS when P is in a stable state that cannot perform any member of
S . We can check a negative premise on P by getting Negate0(P ) to perform an event as part of a combinator synchronisation whenever that is appropriate. The first component of a combinator now becomes a tuple with components that are either a positive event a, a чS or the absence “·” of that process’s involvement. The renamings Ri on the components are extended so the чS is renamed to each combinator c that has чS as a component at the given process’s place.
There are cases with positive and negative premises on the same argument, such as the semantics of the priority operator itself: Pri≤(P ) can only perform non- maximal a if P itself can, but cannot perform any higher priority event. To handle this we use further events: (a, чS ) (with a /∈ S ) means that the process can perform a while in a stable state where no member of S can happen. The above definition is extended to Negate(P )= Pri≤P (P [[NegR]] 9 RUNNeg (P )) where NegR maps each event a in P ’s alphabet to both itself and the (a, чS ) we introduced above, and
≤P is extended so that (a, чS ) is given the same priority as чS . Thus (a, чS ) can happen just in those stable states where a can be performed by P but no member of S can be. To handle this the renaming Ri is extended so that (a, чS ) is mapped to every combinator c which has this particular pair of premises for its i th argument.

Further stages
The rest of this proof follows similar lines to the one in [16] without priority. This is set out in detail in the extended paper [18]. To handle processes being discarded (as can happen to either argument of P 2 Q and the first arguments of P Δ Q and P ΘA Q ) we place each Negate(Pi ) in a harness, where Pi can be switched off by ΘA whether or not Pi itself participates in the (necessarily non-homogeneous) combinator that causes this effect. A strong sense of how this is done is given by the deadlock-exception catching operator P ΔΘQ we described earlier: it can be

written ((Pri≤(P 9 δ → STOP )) Θδ Q ) \ {δ} for δ a new event, the only ordering by ≤ being to place δ below all others.
The other aspects of non-homogeneous combinators that need to be handled are
(i) allowing the sorts of continuation permitted by the third component syntax T and (ii) activating inactive arguments to participate in the operations of such T . The first is achieved by extending the alphabet to include labelled (n-)combinators for every form that the system might evolve to as the simulation progresses, together with a regulator process which understands what the present format of the system is and how the current active argument processes map onto the format’s active arguments.
There are two ways of handling the activation of inactive arguments: one each is described in [16] and [18]. The first dynamically generates new argument processes each time one is activated. The second is possible where the overall number of active arguments has an upper bound, and works by recycling them: letting the zombies created by turning arguments off be reborn in a new form.
All of this can be be done in such a way as to obtain strong bisimulation.
Examples
We have seen how to create an operator that allows deadlock in one process to cause a second process to start. The following transformation provides the basis for many similar constructions.
Suppose P has alphabet Σ0, and that we have added as follows to the overall alphabet: Σ1 = {чa | a ∈ Σ0} and Σ2 = {ччa | a ∈ Σ0} (all these new labelled events being different to each other and members of Σ0).
Now define two partial orders on Σ = Σ0 ∪ Σ1 ∪ Σ2: чa <1 a and ччa <2 чa for each a ∈ Σ0, with no other pairs ordered except for those required to make τ maximal. Let us now think through the behaviour of the process
Probe(P )= Pri≤2 (Pri≤1 (P 9 RUNΣ1∪Σ2 ))
The process inside the priority operators can perform any action of P , and also always perform any action in Σ1 ∪ Σ2 without changing state.
The result of the inner priority operator can still perform any action of P and any member of Σ2, but can now only perform чa ∈ Σ1 when P itself is in a stable state than cannot perform a.
Probe(P ) can perform the same members of Σ0 ∪ Σ1 as at stage 2, but can now only perform ччa ∈ Σ2 when P is in a stable state which can perform a. When this process performs either чa or ччa, its state does not change. This gives the observer, by viewing events alone, the ability to “probe” what events the current state of P can perform.
Building on this, we can for example create a stronger version of the angelic choice operator D of [15]: P DN Q behaves like P 2 Q except that when P and Q offer the same visible event a the choice between them is delayed rather than

forced when a occurs. The operational semantics of P DN Q can only perform a visible event a if either both P and Q perform it in parallel, or if one of them does perform it and the other one cannot. This is implemented by running Pˆ ΘΣ1 RUN Σ0
alongside Qˆ ΘΣ1 RUNΣ0 . Here, Pˆ is Probe(P ) without the ччa events, and in the
combination a ∈ Σ0 can synchronise with either itself or чa, in each case creating
the external event a. For full details see the the extended version.

Comparisons
The good comparator for CSP-like operational semantics is van Glabbeek’s [10] 5 concept of simply WB-cool operational semantics. This is more liberal than CSP- like because it permits cloning and because it explicitly allows arbitrary probing of
active arguments: it allows multiple premises of the form P −a→ Pj for different

as, and we can choose to use either the results Pj
or the original P in the result

term. Van Glabbeek also allows active arguments to become inactive under limited circumstances. The restrictions there are all expressed in the language of SOS. Van Glabbeek shows that such semantics ensure congruence under weak bisimulation.
[10] also introduces some variants on WB-cool which have congruence properties for different forms of bisimulation.
Both CSP-like and Pri-CSP-like operational semantics (like strictly WB cool and similar classes) come firmly within the GSOS class of operational semantics defined in [3]. This is well studied, and implies, for example [4], that the use of negative premises causes no problems with the well-definedness of operational semantics.
A very detailed survey of restrictions on SOS semantics which are intended to preserve various forms of congruence is provided in [2]. This identifies full probing – namely the ability to test the complete acceptance/ready set as a condition for actions – with the natural notion of operational semantics which coincides with the FL style of model, there termed ready-trace. The main construction in Section 5, elaborated on in the extended version of this paper, shows that the same can be done in Pri-CSP. Whereas CSP-like operators are a closed world in the sense that any composition of CSP-like operators is also describable in combinators, the same is not true of Pri-CSP-like and (n)-combinators, helping to explain why one can go beyond direct expressibility in terms of these by composing operators that are. This is why the continuation syntax T is more restricted when negative premises are allowed.

Conclusions
One of the most interesting features of this work is the great expressive power of
Pri≤(·) in conjunction with ordinary CSP.
A future paper by the author and others will show how refinement checking over a wide variety of CSP models can be reduced, using priority, to trace refinement.

5 Van Glabbeek’s work was itself closely related to work by Bloom and others [1].

It is reasonable to ask how crucial the choice of priority is for an extra operator to achieve the degree of expressiveness seen here. Clearly such an operator cannot be CSP-like, and must have the property that Pri≤(·) is expressible using it and the rest of CSP. It cannot have a semantics in any CSP model where Pri≤(·) does not, for it must be able to express priority. We pose this as a question for further work.
Acknowledgements
This work was done under funding from the DARPA HACMS program. It has benefited hugely from discussions with Rob van Glabbeek, Tom Gibson-Robinson, Augusto Sampaio and David Mestel.

References
B. Bloom. Structural operational semantics for weak bisimulations, TCS 146 pp 25-68i, 1995.
B. Bloom, W. Fokkink and R. van Glabbeek. Precongruence formats for decorated trace semantics, ACM Transactions on Computational Logic 5, 2004.
B. Bloom, S. Istrail, and A. Meyer. Bisimulation can’t be traced. JACM 42(1), 1995.
R. Bol and J.F. Groote. The meaning of negative premises in transition system specifications. JACM,
43, 863-914, 1996.
S.D. Brookes, A model for Communicating Sequential Processes, Oxford DPhil thesis, 1983.
S.D. Brookes, A.W. Roscoe and D.J. Walker, An operational semantics for CSP, Oxford University Technical Report, 1986.
C.J. Fidge, A formal definition of priority in CSP, ACM Transactions on Programming Languages and Systems, 15, 1993.
T. Gibson-Robinson, TYGER: a tool for automatically simulating CSP-like languages in CSP, Oxford University dissertation, 2010.
T. Gibson-Robinson, P. Armstrong, A.Boulgakov and A.W. Roscoe. FDR3 – A modern refinement checker for CSP. In Tools and Algorithms for the Construction and Analysis of Systems (pp. 187-201). Springer 2014.
R.J van Glabbeek, On cool congruence formats for weak bisimulations. In ICTAC 2005 (pp. 318-333). Springer.
C.A.R. Hoare, Communicating Sequential Processes, Prentice Hall, 1985.
G. Lowe, Probabilistic and prioritised models of Timed CSP, TCS 138, 1995.
G.D. Plotkin, A structural approach to operational semantics. 1981.
A.W. Roscoe, The theory and practice of concurrency, Prentice-Hall 1997.
A.W. Roscoe, Understanding concurrent systems, Springer 2010.
A.W. Roscoe, On the expressiveness of CSP,
https://www.cs.ox.ac.uk/files/1383/expressive.pdf,  2011.
A.W. Roscoe and P.J. Hopcroft, Slow abstraction through priority, Springer LNCS, 2013.
A.W. Roscoe, On the expressive power of CSP extended by priority. http://www.cs.ox.ac.uk/files/ 6757/prex.pdf Extended version of this paper.
