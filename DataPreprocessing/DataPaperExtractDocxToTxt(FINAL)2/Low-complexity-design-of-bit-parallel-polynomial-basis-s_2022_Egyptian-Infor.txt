Egyptian Informatics Journal 23 (2022) 105–112













Low complexity design of bit parallel polynomial basis systolic multiplier using irreducible polynomials
Sakshi Devi ⁎, Rita Mahajan, Deepak Bagai
Department of Electronics and Communication Engineering, Punjab Engineering College (Deemed to Be University), Chandigarh-160012, India



a r t i c l e  i n f o 

Article history:
Received 31 July 2020
Revised 29 May 2021
Accepted 9 July 2021
Available online 23 July 2021

Keywords:
Finite field Cryptography Polynomial basis Systolic architectures Nodes
a b s t r a c t 

Encryption schemes like AES require finite field modular multiplication. The encryption speed is highly dependent on the performance of the finite field multiplier. Several high-speed systolic bit parallel mul- tipliers with low area complexity have been proposed in the literature. In this paper, a modular multipli- cation algorithm is used to propose a bit parallel polynomial basis systolic multiplier which has achieved 89% less and 17% less area-delay product than the best existing multipliers. It has been observed that the area complexity of the proposed systolic multiplier for irreducible polynomials matches with the best- reported multiplier with 17% less time complexity. The results are further verified with the help of the FPGA implementation of the proposed multiplier for m = 8,163. Being generic, the proposed multiplier can be optimized further for trinomials and pentanomials.
© 2022 Published by Elsevier B.V. on behalf of Faculty of Computers and Information, Cairo University.
This is an open access article under the CC BY-NC-ND license (http://creativecommons.org/licenses/by-nc-
nd/4.0/).





Introduction

Galois field, also known as the finite field is named after famous French mathematician Evariste Galois. It forms the basis of various applications like cryptography, digital signal processing, pseudo- random number generation, switching theory, error-correcting codes, etc. Data can be effectively managed and manipulated if stored in Galois fields/finite fields. Finite fields are based on mod- ular arithmetic. Modular arithmetic is extensively used in Mathe- matics and forms the basic building block of number theory. It is used in numerous practical applications like in calculating check- sums and detecting errors for international standard book num- bers (ISBNs), in modern commerce which employs public-key cryptography systems and also in error detection systems for bank identifiers.

⁎ Corresponding author.
E-mail addresses: sakshidevi.phdece17@pec.edu.in (S. Devi), ritamahajan@pec. edu.in (R. Mahajan).
Peer review under responsibility of Faculty of Computers and Information, Cairo University.
Arithmetic operations like division, multiplication, addition, subtraction, and exponentiation can be computed on finite fields. Addition and subtraction are simply XOR operations. Division and exponentiation are performed using repeated multiply and square algorithms. However, multiplication is a very complex pro- cess and takes more time to do the computation. To perform the faster multiplication in finite fields, efficient multiplier architec- tures have to be designed [1]. There are three types of representa- tion of finite field elements: Dual basis, Polynomial basis or canonical basis or standard basis and Normal Basis. Among all these representations, the polynomial basis is preferred because it can be matched to any system without any external circuitry. Moreover, it has a very low complexity than normal and dual basis multiplier [2].
Polynomial basis representation is widely accepted since the organizations which set the boundaries and limits for cryptogra- phy adopt polynomial basis as the choice. Various architectures have been used to realize polynomial basis multipliers like bit par- allel, bit-serial, digit serial, semi-systolic, systolic, pipelined, and sequential. Although the bit-parallel multiplier consumes more area, it performs faster computation than other multipliers. Sys- tolic multiplier architecture has a complete network of identical symmetrical elements and is preferred to perform fast computa- tions [3]. These homogenous elements in systolic architecture are





https://doi.org/10.1016/j.eij.2021.07.003
1110-8665/© 2022 Published by Elsevier B.V. on behalf of Faculty of Computers and Information, Cairo University. This is an open access article under the CC BY-NC-ND license (http://creativecommons.org/licenses/by-nc-nd/4.0/).



known as cells or nodes. Each node performs highly complex operations.
Encryption schemes like AES, RSA, NTRU, Torus-based cryptog- raphy depend on finite field arithmetic High speed encryption is a must to ensure efficient data security. To accomplish fast computa- tions, a bit parallel systolic polynomial basis multiplier has been proposed in this paper. The use of cut-set retiming in the multiplier design can significantly improve the critical path delay of the bit parallel systolic multipliers. The proposed multiplier is efficient in terms of area and time complexity. It has got the best area- delay tradeoff and therefore, it can be extended to work for other specific polynomials like trinomials, pentanomials, etc.
The main contributions of the paper are as follows:

A modular multiplication algorithm based on the conven- tional modular multiplication and the modified interleaved modular multiplication algorithm is formulated to find the product: P*Q mod T.
A Signal Flow Graph (SFG) has been represented which makes use of various types of cells to find the bitwise pro- duct of two elements P and Q.
Cut-set retiming has been performed on the SFG to obtain the low critical path delay based systolic multiplier and a bit-parallel multiplier architecture has been derived from it which has improved area and time complexity.

The rest of the paper is organized as follows: Section 2 describes the literature of bit parallel polynomial basis systolic multipliers. Section 3 addresses the fundamentals of the theoretical bit parallel systolic polynomial multiplier. The algorithm for a bit-parallel sys- tolic multiplier of the polynomial basis is proposed in section 4 along with the description of multiplier architecture. The results and discussions of the proposed multiplier have been described under Complexity and Comparison in section 5. The FPGA imple- mentation results of the proposed multiplier are compared with the earlier best-reported bit parallel polynomial basis systolic mul- tipliers for m = 8 and m = 163 in sub-section 5.1. The conclusion is stated in section 6.


Related work

For modular multiplication in finite field arithmetic, a variety of multipliers have been suggested. Mastrovito multiplier performs parallel multiplication [5]. Multipliers based on the first LSB and MSB algorithms are used to perform the multiplication starting from the operand’s least significant and most significant bit respectively [6,7]. A digit serial multiplier with multiplier A(x), multiplicand B
(x) and the irreducible polynomial P(x) is partitioned in digits and iteratively processed to do modular multiplication [8]. Several serial-in serial-out and parallel-in parallel-out multipliers have been proposed [9–11]. Software implementation of the Montgomery mul- tiplier is given in [12]. An area and time-efficient Montgomery algo- rithm is given in [13] which is time-independent. Mastrovito multiplier-like matrix–vector product techniques have high space complexity [14]. Montgomery multiplier can be used to multiply shifted polynomial basis numbers [15].
To decrease the multipliers’ space complexity, numerous tech- niques are used like linear feedback shift register-based polyno- mial basis multiplier [16], multiplexer-based modular multiplier [17], etc. Using traditional multiplication and a folded method,
arbitrary GF(2m) fields are given in [19]. Irreducible pentanomial based bit parallel polynomial basis multiplier has less space and time complexity [20]. A bit-parallel and a bit-serial systolic array multiplier based on LSB first algorithms have been presented in [21]. More optimized architecture for Montgomery multiplication with reduced area and space complexity over [13] is proposed in [22]. The dual basis digit serial multiplication can be decomposed into sub-multiplication units to incorporate the parallel processing which will further reduce the latency of the multiplier [23]. The hardware accelerator can be made with high performance which can perform large-scale matrix multiplication [24]. Modified inter- leaved modular multiplication is employed to reduce the space and time complexity of all irreducible polynomials [25].
Karatsuba algorithm and Toeplitz matrix–vector can be employed to propose modular multipliers over irreducible trinomi- als [26,27]. The area-delay product can be improved in a Karatsuba multiplier by employing a reordered normal basis [28]. The authors in [29] have achieved the efficient area and low latency systolic multiplier. However, it is designed specifically for trinomi- als and gives good performance for even ‘m’ over GF(2m). The latency of the multiplier can be improved when implemented in digit serial form [30]. A low-cost n-term Karatsuba algorithm- based multiplier has been proposed in [31]. The reliability of the bit-parallel multipliers can be improved by the parity-based con- current error detection technique [32]. The linear feedback shift register can be used to reduce the area complexity in bit-serial polynomial basis multipliers [33]. A zero-suppressed binary deci- sion diagram [34] improves the speed of the GF multipliers. The synthesis tool for FPGA implementation of the multiplier can be provided with freedom for optimization to achieve low delay [35]. A bit parallel systolic polynomial basis multiplier with reduced critical path delay is proposed in this paper. So, the total delay of the multiplier gets reduced which increases the speed of operation of the multiplier and therefore, the best tradeoff between area and delay is obtained by the proposed multiplier according to the author’s knowledge. The results have been verified for m = 8 and
163.

Theory of the problem

A set of elements is called a finite field if it forms the additive group, multiplicative group and also holds the distributive law. The number of items in the set is called field order. Finite fields are divided into two types: Prime fields (GF(a), a is a prime num- ber) and Extension fields (GF(2m)). In the prime field, the addition and multiplication are done modulo ‘p’ whereas, in the case of extension fields, addition modulo 2 is simply bitwise XOR, and multiplication is done by dividing the product of two polynomials by irreducible polynomial and considering only the remainder [4].
Let T(x) be an m degree irreducible polynomial defined in the finite field over GF(2m) as follows:
T(x) = xm + tm—1xm—1 + ......t2x2 + t1x1 + t0	(1)
where {ti ∈ GF(2), for 0 ≤ i ≤ (m — 1)}.
The set {1,b, b2, b3,	bm—1}, where b is a root of T(x), is
known as the polynomial basis and is used to denote the elements
of the field. Let P and Q be two field elements defined in GF (2m). The representation of P and Q in polynomial form is done as follows:
P = Pm—1pi bi and Q = Pm—1qi biwhere pi and qi ∈ {1,0}, for

All these multipliers are designed to work only with fixed GF(2m) fields. To solve this problem, versatile architectures that support
Using finite field arithmetic, the multiplication of P and Q over GF (2m) is performed as follows:



m—1
R = P.QmodT(b) =	r bi = r
+ r b + r b2 +	+ r
bm—1 ⇒ R
The recursive computations of qjPj from Eq. (2) are performed

 mX—1	!	j	j
‘m-1' times and final output R  is calculated outside the loop to

= q
+ q b + q b2 +	+ q
bm—1 PmodT(b) 
m
save the resources.




⇒ R = q0 PmodT(b) + q1bPmodT(b) + q2 b2PmodT(b) 
+	+ qm—1bm—1PmodT(b) 
⇒ R = q0 P0 + q1P1 + q2 P2 + .... + qm—1Pm—1	(2)
where P0 = P mod T(b), P1 = bP mod T(b), P2 = b2P mod T(b),
Algorithm 1: Modular multiplicatin

Output: Rm = (P × Q) and T Input: P,Q,T (irreducible polynomial) 1:Intialize:R0 = [0000000]m
2:for j = 0 to m-2 do
3:  R  =R ⊕(P ·q )	//If q = 1, then R



=R ⊕ P else

Pm-1 = bm—1 P mod T(b)
j+1  j	j  j
Rj+1=Rj
j	j+1  j	j

and in general,
Pi = biPmodT(b)	(3)
In equation (3), the Pi gives the modular reduction value for an
ith iteration. This modular reduced value is multiplied with qi for ith iteration with the help of AND operation. This way is followed to obtain the product for all the iterations recursively and finally, these product terms are added together to produce R. The values of Pi s’ can be obtained as follows:
For i = 0,
5: Pj+1=P^j⊕(T·pj[m-1])		//If the msb of Pj is ‘1’, then 4: P^j=Pj < <1	//Pj is left-shifted by 1 bit to obtain P^j Pj+1=P^j⊕T, else Pj+1=P^j
6:end for
7:Rm=Rm-1⊕(Pm-1,qm-1)
In algorithm 1, Rj+1 stores the intermediate partial products of P .q , where P ’s are obtained using equation (3) and then, P ’s are

P0 = PmodT(b)=  p0 + p b + p b2 + ... + p
bm—1 
j  j	j	j

mod t0 + t1b + t2b2 + ... + tm—1bm—1 + bm)
(4)
the bit multiplication and field addition step. The left-shifted P val-

In Eq. (4), the degree of P is less than T and therefore, no mod- ular reduction is performed. Hence, P0 = P 
For i = 1,
P1 = bPmodT(b) = b p0 + p1b + p2 b2 + ... + pm 1bm—1
mod t0 + t1b + t2b2 + ... + tm—1bm—1 + bm)
2	3	m
—
mod t0 + t1b + t2b2 + ... + tm—1bm—1 + bm)
ues are added to the product piT as described in Eq. (5) for j = 1, which are calculated in steps 4–5 of algorithm 1. In other words, steps 4–5 of algorithm 1 are responsible for the modular reduction and perform the operation Pj+1 = Pj.b mod T. Algorithm 1 makes use of two logic gates: XOR gate and AND gate to perform the logic operations in the multiplier.
The recursive implementation of bit parallel systolic multiplier architecture is performed in three steps: modular reduction, bit multiplication and field addition. The signal flow graph (SFG) for this recursive multiplication is depicted in Fig. 1. SFG includes ‘m’ modular reduction cells, ‘m’ bit multiplication cells and ‘m’ field

⇒ P1 = pm—1t0 + (pm—1t1 + p0)b + (p
+ (pm 1tm—1 + p	)bm—1
and so on.
m—1
t2 + p1)b2 + ...
(5)
addition cells. The functions of the bit multiplication cell (W cell),
field addition cell (Y cell) and modular reduction cell (Z cell) are shown in Fig. 2. Each W cell performs the multiplication of a single bit of Q, starting from the LSB, with the reduced form of P as

All the multiplications like pm—1 t0,pm—1 t1, pm—1t2... and so on are performed using AND gate. Likewise, all the mod 2 additions such as (pm—1t1+p0 ), (pm—1 t2+p1)   and so on are performed using XOR
operation in Eq. (5) since, in finite field arithmetic, the modulo 2
addition is simple the XOR operation. When comparing Eqs. (4) and (5), it is observed that P is left-shifted (pm—2, pm—3 , ... 
p2 , p1 , p0) followed by the addition of this left-shifted P-value
depicted in Fig. 2(a). Y cell, shown in Fig. 2(b), is used to perform addition according to step 3 of the multiplication algorithm. Z cell is used to reduce the degree of P modularly by one and performing step 4-5 of algorithm 1 as shown in Fig. 2(c). For example, W(0) cell gives the product (P0 . q0), Y(0) cell gives field addition output R1 from inputs R0 and P0.q0 and Z(0) cell gives modular reduced out- put P1, in which firstly P0 is left-shifted by 1 bit(Pb0) and then, this


i	m—1 m—1	m—1 m—2
left shifted value Pb0 is XORed with the product (T. p0[m-1]). Simi-

pm—1 t2, pm—1t1, pm—1t0) to produce the final result R. This concept
forms the basis of finite field multiplication.

Bit parallel architecture of proposed polynomial basis systolic multiplier

According to the conventional modular multiplication process as described in section 3 and the modified interleaved modular multiplication algorithm mentioned in [25], the modular multipli- cation of two polynomials: P and Q , each with the degree (m-1) over GF(2m) can be computed as shown in algorithm 1.T is the irre- ducible polynomial with degree ‘m’ and Rm is the final output. R0 is initialized as [000   00]m bit. For the ‘m’ bit multiplier, the pro-
duct qjPj is calculated ‘m’ times.
larly, Rj+1 and Pj+1 are calculated for m = 0 to m-2.
In other words, W(j) cell gives a product (Pj.qj). Y(j) gives field addition output Rj+1 from inputs Rj and Pj.qj. Z(j) gives reduction output Pj+1. After the last iteration j = m-1, Pm is not calculated since it is not required further and only Rm is produced from step
7. In this way, all the iterations j = 0,1,2,3... (m-1) can be per-
formed and the final output Rm can be obtained.
To decrease the critical path delay, cut-set retiming is per- formed on SFG as depicted in Fig. 3(a). The critical path delay of the proposed systolic multiplier is max{TW + TY, TZ) where TW, TY, and TZ are the critical path delays of W, Y and Z cells respectively. Therefore, TA + TX is the critical path delay(obtained from TZ) of the proposed multiplier, where TA and TX are the propagation delays of AND and XOR gate respectively.




Fig. 1. SFG for the proposed multiplier.


Fig. 2. (a) Logic function of W(j) block, (b) Logic function of Y(j), (c) Logic function of Z(j) block.



Fig. 3. Cut-set retiming of the SFG (a) Cut-set formation, (b) Processing elements construction from SFG blocks.


It is clear that computation of R takes place ‘m’ times and hence, the complete multiplication process is divided into ‘m’ processing elements or nodes after performing cut-set retiming on SFG as shown in Fig. 4(a). Each processing node performs the bit multipli- cation, addition and modular reduction operations except the last
node, which performs only the multiplication and addition as shown in Fig. 4(b) and (c) respectively.
To make the multiplier more scalable and regular, these pro- cessing nodes are further divided into K cells to perform bit-wise
AND (.) and XOR (⊕) operations. The processing elements from 0




Fig. 4. Systolic multiplier using Nodes (a) systolic multiplier, (b) Regular nodes from 0 to [m-2], (c) Node (m-1).


to [m-2] are divided into ‘2m2-2m’ K cells which include (m2-m) cells for multiplication plus field addition and (m2-m) cells for modular reduction, whereas the last processing element [m-1] is divided into ‘m’ K cells which include multiplication only as shown in Fig. 5. The first group of ‘m2’ K cells from the upper block repre- sents the multiplication and addition operations and calculates Rj+1 of step 3 (or Rm of step 7) in algorithm 1. The group of ‘m2-m’ K cells in the lower block represents the modular reduction opera- tion and finds Pj+1 according to steps 4–5 of algorithm 1. Each K cell includes one AND gate and one XOR gate as represented in Fig. 6.
Due to the pipelining of registers in Fig. 5, the critical path delay is TA + TX, where TA and TX are the delays of an AND gate and an XOR gate. From Fig. 5, the utilization of the number of AND gates, XOR gates, and latches are (2m2-m), (2m2-m) and m2 respectively. It may be noted that 1-bit latches are required to store the inter- mediate Rj values. The advantage of the proposed multiplier is that it has low critical path delay and therefore, it is faster in operation. The final output is produced in each clock cycle taking m clock cycles initially. Being regular and modular, it can be scaled to high m valued multipliers. The proposed bit parallel multiplier architec- ture is important because of its systolic structure which makes it suitable for VLSI implementations. However, due to its high space complexity, it does not fit into low-area applications.

Complexity and Comparison

Results

The proposed K cell-based polynomial basis systolic multiplier is compared, in terms of the area and time complexity with the available systolic multipliers as shown in Table 1. NIST has recom- mended five irreducible polynomials that are m = 163,233,283,409
and 571. F(x) = x8 + x4 + x3 + x + 1 (for m = 8) and F(x)
=x163 + x7 + x6 + x3 + 1 (for m = 163) are used in Table 2 to compare the area and time complexity of systolic multipliers.
The proposed multiplier occupies ‘2m2-m’ 2-input AND gates, ‘2m2-m’ 2-input XOR gates and m2 1-bit latches.
To evaluate the space complexity as shown in Table 1, tradi- tional CMOS logic is employed which includes 4 transistors to make a 2-input XOR gate, 6 transistors each for 2-input AND gate and a 1-bit 2:1 multiplexer,8 transistors for a 1-bit latch,
8 transistors for 3-input XOR gate. ST microelectronics’ real- time existing circuits are used to find the delay in case of the proposed multiplier, where propagation delay of 2-input XOR gate (M74HC86) is 12 ns, 2-input AND gate(M74HC08) is
7 ns, 2:1 mux (M74HC257) is 11 ns, 4:1 MUX (M74HC153) is
16 ns and 3-input XOR gate is 24 ns since it is realized using two 2-input XOR gates (8 transistors). Table 2(for m = 8,163) depicts the area complexity of polynomial basis systolic multi- pliers as a function of the number of transistors and time com- plexity of polynomial basis systolic multipliers as a function of total delay which is equal to the product of latency and critical path delay. The 2:1 multiplexer in [25] is replaced by AND gate in the proposed multiplier to reduce the critical path delay which is the key factor for the reduction in the time complexity of the multiplier.
The proposed systolic bit parallel polynomial basis multiplier achieves the least time complexity as compared to the best reported systolic multipliers, for the same area complexity as observed from Table 2. To the best of our knowledge, our proposed multiplier has attained the least area-delay product due to a con- siderable decrease in the critical path delay, when compared with another bit parallel polynomial basis multipliers as presented in Fig. 7.
The proposed systolic multiplier and the multipliers available in [18,19] and [25] are modeled using HDL and implemented on the FPGA device Xilinx Virtex-7(XCV2000TFLG1925-2) using Xilinx Vivado 2019.1 verification tool. Table 3 lists the area occupied on the FPGA device in terms of the number of Logic cells, delay in ns, Power in W for m = 8,163. The area delay product is also com- pared for m = 8,163. It is evident from Table 3 that the multiplier shown in Fig. 5 takes less time to perform the computations as compared to the other multipliers with a slight decrease in the area while doing FPGA implementation.




Fig. 5. Systolic multiplier using K cells for irreducible polynomials over GF(2 m).





Fig. 6. Logic Diagram of K cell (a) For upper block, (b) For lower block.




Table 1
Area utilization and delay of polynomial basis systolic multipliers for irreducible polynomials over GF(2 m).

[18]a	m2	m2 + 2m	0	4m2 + 3m	3m	TA + TX [18]b	m2		m2	0		5m2	4m	TA + TX
[19]	m2-m + 1	m2-1	2m2 + m-3	2m2-m	2m	TA + Tx
[21]	2m2	2m2	2m2 + m-3	7m2	3m	TA + Tx
t: 3input XOR gate, r: 4:1 Mux.


Table 2
Comparison of area and time complexity of the proposed systolic multiplier with the available systolic multipliers for m = 8 and m = 163.

Design	#Transistors	#Clock cycles (Latency)	Critical Path Delay (ns)	Total Delay(ns)	Area Delay Product



Comparison of Area Delay Product for m=8,163
28
26
24
22
20
18
16
14
12
10
8
6
4
2
0
[16]	[17]	[18]a	[18]b	[19]	[21]	[25]	Fig.5
Work

 m=8  m=163
achieved the lowest time complexity and area-delay product. FPGA implementations of the proposed multiplier also show that the proposed multiplier is 90% delay efficient and 18% area efficient than [25] with a slight increase in the power consumption. Conse- quently, the area-delay product is the lowest as compared to the other multipliers.
The proposed bit parallel polynomial basis systolic multiplier has achieved the best area-delay tradeoff and therefore, it can be extended to other types of polynomial based multipliers like trino- mials, pentanomials, equally spaced polynomials, etc. It performs parallel computations and is faster in operation as compared to its bit-serial counterparts. However, the number of resources(area complexity) utilized in the bit parallel multipliers is very high. It is limited to applications that give supreme priority to the speed and applications where the area utilization is not a major concern.


Fig. 7. Comparison of Area Delay Product of proposed multiplier with the multipliers available for m = 8163.


Discussions

The efficiency of the proposed multiplier is supported by the number of reductions achieved in the area and time complexities as shown in Table 2 for m = 8,163. The proposed multiplier achieves 27% less area than [19] and 69% less area than [21] for m = 8. The area complexity of our multiplier matches with the [25]. The critical path delay has been improved to the sum of one 2-input AND and 2-input XOR gate delay only due to pipelining of K cell registers. The time complexity of the proposed multiplier is 50% less than [19], 66% less than [21] and 17% less than [25] for m = 8. The area-delay product obtained by the proposed multiplier is 63% less than [19], 89% less than [21] and 17% less than [25]. The reduction in area and time complexity achieved by the proposed multiplier for m = 163 is approximately equal to the reductions achieved in the case of m = 8. Therefore, our multiplier has

Conclusion

In this research work, the best tradeoff for the area and time complexity is obtained with the help of modification of the logic components of the processing elements of the polynomial basis systolic multiplier. It is observed that the proposed systolic polyno- mial basis multiplier over irreducible polynomials achieves 66% and 17% less time complexity due to low critical path delay for m = 8 and m = 163 when comparison analysis is made with the ear- lier best-reported multipliers available in the literature. The area complexity obtained by the proposed multiplier matches with the best results available. The area-delay product of the proposed multiplier is 89% and 17% less as compared to the existing multipli- ers. It is concurrent and therefore, it performs computations faster. Being regular, modular and scalar, it is better suited for VLSI imple- mentations. The proposed low critical path delay multiplier can be optimized further to work for trinomials and pentanomials as well.



Table 3
Comparison of FPGA Implementation Results for m = 8 and m = 163.




Declaration of Competing Interest

The authors declare that they have no known competing finan- cial interests or personal relationships that could have appeared to influence the work reported in this paper.


References

C. Paar and J. Pelzl, Understanding cryptography: a textbook for students and practitioners. Springer Science & Business Media, Nov 2009.
Hsu IS, Truong TK, Deutsch LJ, Reed IS. A comparison of VLSI architecture of finite field multipliers using dual, normal, or standard bases. IEEE Trans Comput 1988;37(6):735–9.
Kung HT. Why systolic architectures? IEEE Comput 1982;15(1):37–46.
W. Stallings, Cryptography and network security: principles and practice, Upper Saddle River: Pearson, pp. 92-95,2017.
Li Y, Ma X, Zhang Y, Qi C. Mastrovito form of non-recursive Karatsuba multiplier for all trinomials. IEEE Trans Comput 2017;66(9):1573–84.
Song L, Parhi KK. Low-energy digit-serial/parallel finite field multipliers. J VLSI Sig Proc 1998;19(2):149–66.
Jain SK, Song L, Parhi KK. Efficient semisystolic architectures for finite field arithmetic. IEEE Transactions on Very Large-Scale Integration (VLSI) Systems 1998;6(1):101–13.
Morales-Sandoval M, Díaz-Pérez A. Compact FPGA-Based Hardware Architectures for GF (2^ m) Multipliers. In: In 2013 Euromicro Conference on Digital System Design. p. 649–52.
Yeh CS, Reed IS, Truong TK. Systolic multipliers for finite fields GF (2m). IEEE Trans Comput 1984;33(4):357–60.
Wang CL, Lin JL. Systolic array implementation of multipliers for finite fields GF (2/sup m/). IEEE Trans Circ Syst 1991;38(7):796–800.
S.K. Jain and K.K. Parhi, ‘‘Low latency standard basis GF (2/sup m/) multiplier and squarer architectures,” International Conference on Acoustics, Speech, and Signal Processing, Detroit, MI, USA, pp. 2747-2750, May 1995.
Koc CK, Acar T. Montgomery multiplication in GF (2k), designs, codes and cryptography. Springer 1998;14(1):57–69.
Chiou CW, Lee CY, Deng AW, Lin JM. Efficient VLSI implementation for Montgomery multiplication in GF (2m). Tamkang J Sci Eng 2006;9(4):365–72.
Erdem SS, Yanık T, Koç ÇK. Polynomial basis multiplication over GF (2m). Acta Appl Mathemat Springer 2006;93(1-3):33–55.
Fan H, Hasan MA. Relationship between GF (2m) Montgomery and shifted polynomial basis multiplication algorithms. IEEE Trans Comput 2006;55 (9):1202–6.
Chiou CW, Lee CY, Lin JM. Finite field polynomial multiplier with a linear feedback shift register. Tamkang J Sci Eng 2007;10(3):253–64.
Lee C-Y. Multiplexer-based bit-parallel systolic multipliers over GF (2m). Comput Electr Eng Elsevier 2008;34(5):392–405.
Lee CY. Low complexity bit-parallel systolic multiplier over GF (2m) using irreducible trinomials. Integration VLSI J Elsevier 2008;41(1):106–12.
Fournaris AP, Koufopavlou O. Versatile multiplier architectures in GF (2k) fields using the Montgomery multiplication algorithm. Integration VLSI J Elsevier 2008;41(3):371–84.
Wu H. Bit-parallel polynomial basis multiplier for new classes of finite fields. IEEE Trans Comput 2008;57(8):1023–31.
Kwon S, Kim CH, Hong CP. More efficient systolic arrays for multiplication in GF (2m) using LSB first algorithm with irreducible polynomials and trinomials. Comput Electr Eng Elsevier 2009;35(1):159–67.
Kim K-W, Jeon J-C. Polynomial basis multiplier using cellular systolic architecture. IETE J Res 2014;60(2):194–9.
Chiou CW, Lee C-Y, Lin J-M, Yeh Y-C, Pan J-S. Low-latency digit-serial dual basis multiplier for lightweight cryptosystems. IET Inf Secur 2017;11(6):301–11.
Wei C, Song Y, Zhang D. A chain-multiplier for large scale matrix multiplication. In: In 2017 IEEE 12th International Conference on ASIC (ASICON). p. 792–5.
Mathe SE, Boppana L. Low-power and low-hardware bit-parallel polynomial basis systolic multiplier over gf (2m) for irreducible polynomials. ETRI J 2017;39(4):570–81.
Park SM, Chang KY, Hong D, Seo C. Low space complexity GF (2^ m) multiplier for trinomials using n-term karatsuba algorithm. IEEE Access 2019;7:27047–64.
Pan JS, Lee CY, Sghaier A, Zeghid M, Xie J. Novel systolization of subquadratic space complexity multipliers based on Toeplitz matrix-vector product approach. IEEE Trans Very Large Scale Integr VLSI Syst 2019;27(7):1614–22.
Xie J, Lee CY, Meher PK, Mao ZH. Novel Bit-parallel and digit-serial systolic finite field multipliers over $ GF (2^ m) $ based on reordered normal basis. IEEE Trans Very Large-Scale Integr (VLSI) Syst 2019;27(9):2119–30.
Pillutla SR, Bopanna L. Area-efficient low latency polynomial basis finite field GF(2m) systolic multiplier for a class of trinomials. Microelectron J 2020;97:1–8.
Ibrahim A. Unified and scalable digit-serial systolic array for multiplication and division over GF (2m). IEEE Trans Comput Aided Des Integr Circuits Syst 2020;39(7):1546–9.
Park S-M, Chang K-Y, Hong D, Seo C. Efficient bit-parallel multiplier for all trinomials based on n-term karatsuba algorithm. iEEE Access 2020;8:173491–507.
Fei C, Fang Z, Ning W, Fen G, Jin W, Peiyao Q. A scalable bit-parallel word-serial multiplier with fault detection on GF (2^ m). In: In 2020 IEEE 20th International Conference on Communication Technology (ICCT). p. 1660–4.
Imana JL. LFSR-based bit-serial $ GF (2^m) $ GF (2^m) multipliers using irreducible trinomials. IEEE Trans Comput 2020;70(1):156–62.
Ito A, Ueno R, Homma N. Efficient formal verification of galois-field arithmetic circuits using ZDD representation of boolean polynomials. IEEE Trans Comput Aided Des Integr Circuits Syst 2021.
J.L. Imana, ‘‘Low-Delay FPGA-Based Implementation of Finite Field Multipliers,” in IEEE Transactions on Circuits and Systems II: Express Briefs, 2021.
