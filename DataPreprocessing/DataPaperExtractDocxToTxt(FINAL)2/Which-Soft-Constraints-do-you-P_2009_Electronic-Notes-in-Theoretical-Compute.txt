

Electronic Notes in Theoretical Computer Science 238 (2009) 189–205
www.elsevier.com/locate/entcs
Which Soft Constraints do you Prefer?
Matthias H¨olzl, Max Meier, Martin Wirsing 1,2
Institut fu¨r Informatik Ludwig-Maximilians-Universita¨t
Mu¨nchen, Germany

Abstract
Soft constraints are gaining popularity in diverse areas such as orchestration of Web services or optimization of scheduling decisions. However, current approaches to soft constraints preclude them from modelling certain decision problems with multiple preference criteria. We propose a new approach to soft constraints which allows a natural expression of these problems, describe an implementation in the rewriting logic system Maude, and prove its correctness.
Keywords: Soft Constraints, Rewriting Logic


Introduction
Soft constraints are gaining popularity in diverse areas such as orchestration of Web services (see e.g. [13]) or optimization of scheduling decisions (see e.g. [18]). How- ever, current approaches to soft constraints preclude them from modelling certain decision problems with multiple preference criteria.
As an example for this phenomenon consider the meeting planning component of a university management system. There are both mandatory and optional par- ticipants, which are able to attend the meeting only on certain dates and places. In a real system, this information could be collected automatically from the persons’ calendars. To successfully schedule a meeting, all mandatory persons and a meeting room of the appropriate size have to be available. Among all the dates satisfying these conditions, the scheduling service has to choose one that optimizes certain other criteria, e.g. the number of optional participants. If possible, the meeting should not be scheduled on a weekend. Many more criteria are imaginable, for example each participant could give a personal rating on dates and places.

1 This work has been partially sponsored by the project SENSORIA, IST-2005-016004.
2 Email: firstname.lastname@ifi.lmu.de

1571-0661/© 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.05.020

We will argue that current formalisms for expressing soft-constraint problems, e.g., semiring-based soft constraint satisfaction problems (SCSPs) are not adequate to model the above situation under certain reasonable assumptions about the im- portance of the preferences. We propose a generalized soft-constraint formalism, Monoidal Soft Constraints, that can express these kinds of problems and describe an implementation (in the Maude rewriting logic) of a branch-and-bound algorithm to solve these generalized constraint problems. We have applied the formalism and solver to several application domains, e.g., to orchestration of service-oriented ar- chitectures [20] and to the optimization of software-defined radio networks (for an earlier approach see [21]). Our current implementation of the solver is based on a predecessor which was written in Maude and integrated into the Pagoda framework for modelling SDRs. Building on this foundation reduced our implementation effort and allows us to easily integrate the current solver into the Pagoda system.
The structure of the paper is as follows: In Section 2 we introduce the theory of Monoidal Soft Constraints. We describe the transformations that we perform on constraint systems before submitting them to the solver in Section 3. In Section 4 we describe the branch-and-bound algorithm and prove its correctness. The final two sections present related work and our conclusions.
Soft Constraints over Partially-Ordered Monoids
C-Systems of Monoids
A monoid M is an algebra (M, ⊗, 1) with carrier set M , a constant 1 ∈ M and an associative binary operation ⊗ with identity element 1. If ⊗ is commutative M is called a commutative monoid.
An ordered monoid M is an algebra (M, ⊗, ≤, 1) with carrier set M , a constant
1 ∈ M , a binary operation ⊗ and a binary relation ≤ such that (M, ⊗, 1) is a commutative monoid and ≤ is a partial order which is compatible with ⊗, i.e.,
∀x, y, z ∈ M.x ≤ y =⇒ x ⊗ z ≤ y ⊗ z.
Examples for ordered monoids are the natural numbers with addition or multi- plication and the usual comparison operation:
Natadd = (N, +, ≤, 0)
Natmult = (N, ·, ≤, 1).
Another frequently used ordered monoid is the monoid of natural numbers with
reverse order Nat ≥ . Its carrier is the set of non-negative integers extended with
an “infinite” element ∞, the multiplication operation is addition and the order relation is the ≥N relation on the natural numbers extended with ∞ ≥N n for all
n ∈ N:

≥
add
= N ∪ {∞}, +, ≥, 0 .

To express crisp constraints the ordered monoid of Boolean values is often useful: its carrier is the set consisting of the two values true and false, the multiplication operation corresponds to conjunction; the order relation is generated by the relation

false < true and coincides with implication:
Bool = ({true, false}, ∧, →, true).
Let M = (M, ⊗, 1) be a monoid and E a set. We write IdE for the identity mapping on E: IdE : E → E, x '→ x. A map p : M → (E → E) is called a (left) operation of M on E if p1 = IdE and pα⊗β = pα ◦ pβ. We often write αx for pα(x); the previous conditions can then be written as
1x = x	(1)
(α ⊗ β)x = α(βx).	(2)
Let E be an ordered set. Then we call p left-compatible (with the orders of M and E) if ∀α, β ∈ M, x ∈ E.α ≤ β  =⇒  αx ≤ βx. We call the operation p intensive if ∀α ∈ M, x ∈ E.αx ≤ x. It follows immediately from these two definitions and (1) that for an intensive left-compatible operation 1x is a maximal element of {βx | β ∈ M} for every x ∈ E.
We call p a c-operation of an ordered monoid M on an ordered set E if p is an left-compatible operation of M on E. In this case we also call M a c-monoid over
E. If p is an intensive c-operation we call it an ic-operation and M an ic-monoid
over E.
Note 1 The use of intensive c-operations enables many additional techniques for solving constraint problems but modelling with ic-monoids is often cumbersome for practical applications. In Section 4 we describe a branch-and-bound algorithm for in- tensive monoids. This algorithm can be modiﬁed to work for non-intensive problems by taking into account the possible improvements of partial solutions by constraints deﬁned over non-intensive monoids.
Let E = (E, ≤E) be an ordered set, I a set, (Mi)i∈I = (Mi, ⊗i, ≤i, 1i) i∈I a family of ordered monoids, and (pi)i∈I a family of c-operations, pi : Mi → (E → E).
If pi	and pj	commute (with respect to function composition) for all αi ∈ Mi,
αj ∈ Mj, i.e., if
∀i, j ∈ I, x ∈ E.∀αi ∈ Mi, αj ∈ Mj.αi(αjx) = αj(αix)
we call (  ); ( i);  a c-system of monoids (over  ). If all ( i) are ic-operations then we call  (Mi); (pi); E  an ic-system of monoids (over E).
We write inji for the injection into the i-th component and πi for the projection of the i-th component of a cartesian product. Let (Mi)i∈I be a family of monoids and E =  i Mi. We then define the canonical injective multiplication imulti as
imulti : Mi → (E → E)
α '→ (x '→ inji(α ⊗i πi(x)))
For example, let M1, M2 be ordered monoids, E = M1 × M2, let ≤× be the pointwise ordering on E and pi = imulti. Then (M1, M2); (p1, p2); (M1 × M2, ≤×) 

is a c-system of monoids. The same holds if we equip E with the lexicographic order
≤lex.
To summarize, a c-system of monoids is a triple  (Mi)i∈I, (pi)i∈I ; E  where (Mi) is a family of ordered monoids and each pi is an intensive left-compatible operation of (Mi) on E, i.e., the following properties hold:
1ix = x
(αi ⊗ βi)x = αi(βix)
αi ≤ βi =⇒ αix ≤ βix	(3)
αi(αjx) = αj(αix)	(4)

An ic-system of monoids satisfies the additional property
αix ≤ x	(5)

Soft Constraints
A soft constraint assigns grades to different valuations of a set of problem variables. In a soft-constraint problem the grades of all soft constraints are combined by a preference relation into the rank, which measures the quality of the result.
Let R (the set of ranks) be an ordered set, G (the set of grades) a c-monoid with carrier set G over R, D a finite problem domain, and Var the set of all problem variables. A valuation υ : Var → D is a partial map from Var to D which has a finite support. If a valuation is defined for all elements of a set V ⊆ V ar we call it a valuation over V and also regard it as a function V → D. Given a finite set V ⊆ Var
of variables, a soft constraint assigns a grade in G to each possible valuation over V ; more formally, a soft constraint over G is a triple ⟨V ; cst; G⟩ where the function cst : (V → D) → G maps valuations over V to elements of G. As V is finite, any
soft constraint has a finite domain of definition and can therefore be represented either in an explicit way by a finite set of pairs (υ '→ g) with υ ∈ (V → D) and g ∈ G, or in a more implicit way by particular constructors or function declarations in a programming language. In our framework we support both possibilities; here we present only the explicit form. For fixed V of size k, the type (V → D) → G is isomorphic to Dk → G and thus any constraint definition can be written as a map from Dk to G. For example, for a constraint with V = V1, V2 we write cst in the form (v1, v2) '→ v1 + v2 instead of υ '→ υ(V1) + υ(V2). For explicit constraints we sometimes write the mapping in the form of (domain values '→ grade) pairs, e.g., (Monday '→ 0)(Tuesday '→ 1) denotes the constraint mapping the domain value Monday to the grade 0 and the domain value Tuesday to the grade 1. If c is a
soft constraint of the form ⟨V ; cst; G⟩ we sometimes write c(x1,..., xn) instead of
cst(x1,..., xn).
In practice a soft constraint is often defined as a combination of several simpler soft constraints: given two soft constraints c1 = ⟨V1; cst1; G⟩ and c2 = ⟨V2; cst2; G⟩ over the same monoid of grades G, their combination c1 ⊗ c2 is the constraint
⟨V ; cst; G⟩ defined by V = V1 ∪ V2 and cst(t) = cst1(t ↓V ) ⊗ cst2(t ↓V ), where t ↓X
V1	V2	Y

denotes the tuple of values over the variables in Y , obtained by projecting tuple t
from X to Y .
In the example of the meeting scheduling service, the monoid of grades G1 is used to express the preferences of each key person for meeting dates and places. We limit the values for each person to an interval [0, max-pref ] so that preferences of different persons can be compared. By choosing the multiplicative monoid of natural numbers Natmult to evaluate the results we can ensure that the inability of a single key person to attend the meeting leads to an “unacceptably bad” grade 0 for the meeting. The combination of the constraints for all key persons measures the desirability of dates and places for scheduling the meeting.
key-personi = ⟨Date, Place; cstk; Natmult⟩
key-persons =	key-personi
i

Similarly, we define a constraint expressing preferences for certain days and places for each other person, again with 0 meaning the person is unavailable and higher number meaning preferred dates and places. However, here we do not want the unavailability of a non-key person to reduce the overall evaluation of a meeting opportunity to 0. Therefore we combine these constraints in the additive monoid of natural numbers:
opt-personi = ⟨Date, Place; csto; Natadd⟩
opt-persons =	opt-personi
i
Another constraint “not-on-weekend ” expresses that the meeting should not be scheduled on a weekend: not-on-weekend = ⟨Date; cstw; Bool⟩.

Soft-Constraint Problems
A monoidal soft-constraint problem combines the grades of several soft constraints into a single rank which measures the overall quality of a solution. We use a family of c-operations, called the preference relation to specify this combination process. While the grades represent the quality of individual constraints the preference re- lation expresses the importance we assign to the individual constraints.
Formally,  a  soft-constraint  problem  C  is  defined  as  a  quintuple
⟨(Gi)i∈I, (ci)i∈I, (pi)i∈I, R, I⟩, where (Gi) is a family of monoids, each ci is a soft constraint over Gi, I ∈ R is the initial value, and (Gi), (pi), R is a c-system of monoids. We call the family (pi) the preference relation.
For each valuation υ ∈ V ar → D the rank of the constraint problem C for υ is defined as the function composition of all pi applied to the initial value:
S(υ) = ◯i∈Ipi	 (I),	(6)


i.e., if I = {1,..., n} we have S(υ) = p1
1
2
c2(υ)
(··· (pn
n
(I)) ··· )). Properties

(2) and (4) together with the commutativity of the operations on Gi ensure that S
does not depend on the order in which the individual constraints are applied.
We define the set of maximal solutions of a constraint problem C in the following way:
maxSol(C) =  (υ '→ S(υ)) | S(υ) maximal in S[V ar → D] .
The scheduling example demonstrates the usefulness of the preference relation in the computation of the rank: a meeting may only be scheduled at times when all mandatory persons are available, or more generally, only times and places in which the availability of mandatory persons is maximal should be considered. The other constraints can only be used to influence the quality of these maximal solu- tions but even very high grades for the other constraints cannot offset the negative impact of a missing key person. This situation can be modelled, e.g., by defining R as a lexicographically ordered product, where the preference relation injects the grade for availability of key-persons into the first component and all other grades into the second component. Suppose that R = N≤ ×lex (N≤ × Bool≤) with the grade of key-persons in the first component, the grade of opt-persons in the second component and the grade of not-on-weekend in the third component. Then, if we have ranks (8, (1, false)), (7, (100, false)) and (7, (5, true)) the lexicographic order ensures that the first rank, (8, (1, false)), is the only maximum since the value of its first component, 8, dominates the value 7 of the other ranks. The second and third rank are not comparable: they both have the same value 7 for the first component, so the pairs of second and third component are used to decide the order. Since these pairs are compared by the pointwise order and 100 > 5 but false < true the pairs are not comparable.
We can therefore express the scheduling service with the soft-constraint problem
C = ⟨(Gi)i∈I, (ci)i∈I, (pi)i∈I, R, I⟩ with
(G1, G2, G3) = (Natmult, Natadd, Bool)
(c1, c2, c3) = (key-persons, opt-persons, not-on-weekend )
pi = imulti
R = N≤ ×lex (N≤ × Bool≤)
I = (1, 0, true)
N≤ denotes the set of natural numbers together with their usual order; Bool≤ de- notes the set of Boolean values {true, false} together with the order →, i.e., the order generated by false < true. This model satisfies the property that whenever there is a date and place where all key-persons can attend the meeting, no meeting dates and places where key people are missing will be considered as solution.
Suppose that we have three possible dates, d1, d2, d3, only one possible location
l, two key persons with the mappings
cstk = (d1,l '→ 2)(d2,l '→ 0)(d3,l '→ 4)
cstk = (d1,l '→ 1)(d2,l '→ 5)(d3,l '→ 0)

and 5 optional members, all with the same function
csto = (d1,l '→ 0)(d2,l '→ 5)(d3,l '→ 3)
and a function cstw = (d1, false)(d2, true)(d3, true). Then the ranks of the con- straint problem for the different valuations are
S((Date '→ d1)) = (2, (0, false))
S((Date '→ d2)) = (0, (25, true))
S((Date '→ d3)) = (0, (15, true))

(we ignore the constant assignment (Place '→ l) in the notation for the valuation). Hence, maxSol(C) = {(Date '→ d1) '→ (2, (0, false))}. Here the lexicographic order ensures that the date where both key persons can attend is chosen, even though this means that no optional member can attend the meeting, and the meeting takes place on a weekend.
The preceding model of the scheduling problem makes use of non-intensive op- erations. We show that the problem can be modelled using only ic-monoids as well. To achieve this we have to modify the key-personi and opt-personi constraints by defining them as penalties instead of preferences and modify R:
opt-person' = ⟨Date, Place; pcsto; Nat ≥ ⟩
i	i	add
R = N∞ ×lex (N∞ × Bool≤)
≥	≥

Here the function pcsto denotes the penalty for each date and location, not the
preference. It can be defined by pcsto(d, l) = max-pref − csto(d, l).
i	i
We can model the constraints for key persons in the same way, by assigning
penalties in the monoid Nat ≥	instead of preferences in Natmult. Dates and loca-
tions where a key person is not available receive the value ∞. In this model, as in all models based on ic-monoids, the initial value I is the greatest possible value, i.e., I = (0, 0, true).

Towards an Implementation
The soft-constraint theory described in the last section is very expressive and allows the modelling of many soft-constraint problems in a natural manner. However it is parametric in a variable number of monoids and makes extensive use of higher-order functions. Both factors complicate the implementation of the theory in a first-order rewriting logic framework. In many cases it is possible to transform soft-constraint problems into a form that is more amenable to an implementation in Maude: When the grades are totally ordered and the set of ranks R can be equipped with the structure of a commutative monoid that is compatible with the preference relation, we can precompute the composition of the constraints and the preference relation and thereby simplify the computation the constraint solver has to perform.

Let C = ⟨(Gi)i∈I, (ci)i∈I, (pi)i∈I, R,I⟩ be a soft-constraint problem with totally ordered grades Gi, and let R be equipped with the structure of a commutative monoid R = (R, ⊗R, 1). If R satisfies the relation
pi (x) = pi (1) ⊗R x	(7)
α	α
we say that ⊗R is compatible with the preference relation (pi)i∈I . In this case, we can define for every soft constraint ci = ⟨V ; cst; G⟩ the flattened constraint
c' = ⟨V ; (α '→ pi (1)) ◦ cst⟩.	(8)
i	α
The flattened constraint problem corresponding to C can then be defined as
⟨(c' )i∈I ; R; I⟩. In order to be able to distinguish between G and R we call R the
rank of c' and G the the original monoid or grade of c' .
i	i
Note that in general the algebra ⟨R; ⊗R; ≤; 1⟩ is not an ordered monoid since
multiplication is not monotone. For example, if R = Z × Z with the lexicographic order ≤lex and ⊗R the elementwise minimization, then we have
(2, 3) ≤lex (3, 1)
(2, 2) = (2, 3) ⊗R (2, 2) ≥lex (3, 1) ⊗R (2, 2) = (2, 1)
But for compatible relations there is a weaker monotonicity condition that is suffi- cient to establish the correctness of branch-and-bound search: Let
Bi = (α '→ pi (1))[Gi]

the image of pi under all possible valuations for the rank value 1. Then the following property, which we call semi-monotonicity, holds for all i ∈ I:
∀x, y ∈ Bi.∀z ∈ R.x ≤ y =⇒ x ⊗R z ≤ y ⊗R z.	(9)
Proof. Let x, y ∈ Bi with x < y. Then by the definition of Bi there exist α, β ∈ Gi with x = α1 and y = β1. We show that α < β. Suppose that α ≥ β. Then by (3) α1 ≥ β1; by definition of α and β we have x ≥ y, a contradiction.
Let z ∈ R.  From α < β and (3) we obtain αz ≤ βz, from (7) we then get
α1 ⊗R z ≤ β1 ⊗R z, hence x ⊗R z ≤ y ⊗R z.	 
The solution of the flattened problem for a valuation υ ∈ V ar → D is defined
by
S'(υ) =	c' (υ) ⊗R I
i
We define the set of maximal solutions of a flattened constraint problem C in the same way as for monoidal constraint problems:
maxSol(C') =  (υ '→ S'(υ)) | S'(υ) maximal in S'[V ar → D] .
Lemma 3.1 Let C be a monoidal constraint problem and let C' be the corresponding flattened constraint problem. Then

for any valuation υ: S(υ) = S'(υ)
maxSol(C) = maxSol(C').
Proof. The first statement follows from the definitions of S and S' and equations
(8) and (7). The second statement is an immediate consequence of the first and the definition of maxSol.	 
It is easy to see that for c-monoids G1 = (G1, ⊗1, ≤1, 1) and G2 = (G2, ⊗2, ≤2, 1) both
G1 ×cart G2 :=  G1 × G2, ⊗1 × ⊗2, ≤×, (1, 1) 


satisfy (7) for the functions
pi = imulti.
Both G1 ×cart G2 and G1 ×lex G2 are therefore semi-monotone for sets Bi = imulti[Gi](1) = inji[Gi] even though the order of G1 ×lex G2 is not compatible with its multiplication as the example above shows. More generally, products of arbi- trarily many factors are semi monotone relative to sets created by multi-injections B{i,...,k} = inj{i,...,k}[G] where


π (inj
(g)) =  g	if j ∈ {i,..., k}


if Gj = G for j ∈ {i... k} and the product is ordered by × and ×lex.
To return to the scheduling example: the important parts of the flattened prob- lem of the last (intensive) model are:


R = Nat ≥
×lex (Nat ≥
× Bool)

⊗ :	(r1, (r2, r3)) ⊗ (r' , (r' , r' )) '→ (r1 + r' , (r2 + r' , r3 ∧ r' ))
1	2  3	1	2	3
key-person' = ⟨Date, Place; (d, l) '→ (pcstk(d, l), (0, true))⟩
i	i
opt-person' = ⟨Date, Place; (d, l) '→ (0, (pcsto(d, l), true))⟩
i	i
not-on-weekend = ⟨Date; d '→ (0, (0, cstw(d)))⟩
Solving Soft Constraint Problems with Preferences
The Maude implementation of Monoidal Soft Constraints consists of a package of Maude theories and parameterized functional modules which can be integrated eas- ily in any other Maude application by instantiating the parameter theories with the particular settings of the application. The axiomatic theory of ordered monoids is
modelled as Maude functional theory; special ordered monoids such as Nat ≥	are
modelled as functional Maude modules; all other modules of the framework (such as implicit and explicit soft constraints as well as the constraint solving algorithms) are parameterized by the choice of the constraint domain and monoid. In order to

improve the efficiency of constraint solving, all recursive specifications are written in tail-recursive form. In the following we present shortly the implementation of the constraints for the meeting scheduling service and the branch-and-bound algorithm for solving soft constraints. The implementation is based on our earlier work for solv- ing soft constraints over constraint semirings [21]. The main changes are: solving soft constraints over partially ordered monoids instead of totally ordered constraint semirings, and a flexible approach for specifying preferences between constraints by dynamically constructing cartesian and lexicographic products of monoids instead of using a (possibly composite) fixed constraint semiring.

Implementing soft constraints with preferences
We formalize ordered monoids and the monoid structures with ordering relation of a flattened constraint problem as Maude theories in a straightforward way. E.g. the latter has the following form where the monoid structure with ordering ⟨R; ⊗R; ≤; 1⟩ is represented by the sort Rank, the operation *, the boolean operation <=, and the unit element one.
fth MONOIDwORDER is pr BOOL .
sort Rank.
op one  : -> Rank  .
op _*_ : Rank Rank -> Rank	[assoc comm id: one prec 31] . op _<=_ : Rank Rank -> Bool	[prec 37] .
vars X Y Z : Rank .
eq X <= X = true	[nonexec] . ceq X <= Z = true
if X <= Y = true /\ Y equiv Z = true [nonexec] . endfth
To implement the meeting schedule example this theory is instantiated by the ordered monoid structures for the grades of the ’key-person’, ’optional-person’ and
’not-on-weekend’ constraints, i.e. with Nat ≥	and Bool. These domains can be
composed to more complex rank domains by forming lexicographic and cartesian products:
*** cartesian product
op _x_ : Rank Rank -> Rank [ctor] .

*** lexicographic product
op _lex_ : Rank Rank -> Rank [ctor] .

The corresponding ordering relations are defined elementwise:
*** symmetric partial order
eq (R1 x R2) <= (R3 x R4) = (R1 <= R3) and (R2 <= R4) .

*** lexicographic order
eq (R1 lex R2) <= (R3 lex R4) = (R1 < R3) or (R1 == R3 and (R2 <= R4)) .
Then we model the lexicographic product of the example N≤ ×lex (N≤ × Bool≤) simply by NatInf lex (NatInf x Bool) where NatInf is the sort of natural num- bers extended with an infinite element.
The flattened constraints are expressed by injecting the grades of the three
types of individual constraints into the three components of the product domain. For example, one may have the following schedule constraints where the operation in denotes the canonical injection of natural numbers into NatInf.
*** A key person has preference 5 for meeting in Munich at 2008-02-22 [ Date Place | (2008-02-22 Munich |-> (in(5) lex (one x one)) ... ]
*** An optional person has preference 7 for meeting in Munich at 2008-02-22


[ Date Place | (2008-02-22 Munich |-> (one lex (in(7) x one)) ... ]
*** not-on-weekend constraint: 2008-02-22 is a weekday [ Date | (2008-02-22 |-> (one lex (one x true)) ... ]



Search
For computing the solutions of a soft-constraint problem we use a branch-and-bound depth-first search algorithm which is based on the following idea: we search in a depth-first manner a solution of a list of constraints cl by choosing in a consistent way a valuation of each of the constraints of cl and by multiplying these valuations in order to obtain a rank of the solution. The best ranks bl of the solutions obtained so far serve as threshold for the branch-and-bound procedure. During the computation we continue to construct a partial solution only if the rank q of the partial solution is not smaller than any of the elements b of the actual threshold bl. Only in this case it will be possible to obtain a solution with a rank which is not dominated by any other element of the threshold. This follows from the fact that ⊗ is intensive: if q < b then for any further multiplication of a with a rank—say p—we have q⊗p < b. The set of solutions of a soft-constraint problem is represented as a list of con- straints. The rank of any solution is not dominated by any other solution, but in case the domain of the ranks is only partially (and not totally) ordered here may
exist several solutions with incomparable ranks.
In order to restrict the search space, we also use two further optimisations where appropriate. If the grade of a constraint is totally ordered (as it is the case for all constraints of the meeting schedule example) then we can sort the valuations of each constraint according to the ranks of valuations in a descending order. Now consider the situation where we try to combine a valuation—say η of rank p—of a constraint c with the actual partial solution—of rank q say. Then in case of p ⊗ q < b it will not be possible to obtain a solution with a rank better or equal than the actual threshold b and therefore the valuation η can be discarded. Moreover, due to the descending ordering of the valuations of c any of the remaining valuations of c has a rank—pi say—with pi ≤ p. Since multiplication is semi-monotonic w.r.t. the set of the grades of each constraint, pi ⊗ q ≤ p ⊗ q < b holds and therefore also all remaining valuations of c can be discarded.
In some cases, it is also possible to use divide-and-conquer optimizations. If two lists of constraints cl1 and cl2 are combined lexicographically, it is possible to solve the first constraint independently and then process the second constraint for each solution of the first one. Cartesian products can also be computed independently if they do not share variables.
The implementation consists of the following two parameterized modules: a module SOLVECONSTRAINT for the search algorithms and a module CONTINUATION for storing the necessary backtracking information. A continuation ct(cl0, sc) consists of a partial solution sc and a list cl0 of unsolved constraints with the intended property that the combination sc ⊗  cl0 of sc with all constraints in cl0 forms again a set of possible solutions of the original constraint problem cl.
The module SOLVECONSTRAINT defines depth-first search algorithms for finding all

best solutions, for finding a first solution better than a certain threshold, and for finding all such solutions (see [3] for a similar approach). For any list cl , search(cl ) computes the set maxSol (cl ) of all best solutions. maxSol is im- plemented to take a list of constraints, not a constraint problem, to avoid the need to repeatedly embed and extract the list of constraints.  For constraints [al | (val1 '→ r1),..., (valm '→ rm)] in cl with a totally ordered rank domain it as- sumes that all ranks r1,..., rm are in descending order. search uses an auxiliary tail-recursive operation $search(cl, sc, cont, csol ) where cl denotes the list of con- straints to be solved, sc the actual partial solution, cont the continuation, and csol the constraint solutions obtained so far.
The  most  interesting  case  of  the  recursive  definition  is  cl   = [al | (vl '→ p)erest] rest and sc = [bl | (wl '→ q)] where vl has rank p, erest denotes the map consisting of the remaining assignments of the first constraint of cl , and rest denotes the tail of the list of constraints cl . (All other cases are simpler with erest , rest or cl being empty, or sc corresponding to noConstraint .) Here noConstraint denotes the empty constraint and plays the role of a unit element in the semiring of constraints (cf. [6]).
If the rank p⊗q of the new solution is different from zero and not smaller than the rank b of an existing solution and and if the first subconstraint c0 = [al | (vl '→ p)] of cl is consistent with sc then $search computes a new partial solution [al | (vl '→ p)]⊗ sc and saves the rest of the constraint in the continuation for later backtracking. Otherwise, if p⊗q is large enough but c0 not consistent with sc, the search continues with the remaining assignments erest of the first constraint. Finally, if p⊗q < b and the rank domain of the constraint is totally ordered (as in the case of our example), we can use the fact that every constraint is sorted in a descending order of ranks which implies that for all ranks r of the entries of erest we have r ⊗ q≤p ⊗ q < b and thus also r ⊗ q < b. Since ⊗ is intensive, further multiplication of p ⊗ q with grades h1,..., hk of the remaining other constraints preserves this property: we have h1 ⊗ ··· ⊗ hk ⊗ p ⊗ q≤p ⊗ q < b. Therefore the partial solution sc cannot be completed to a best solution and the algorithm backtracks with the continuation. By branch(P, ListResult) we denote an auxiliary operation which yields true iff P is smaller than some element of ListResult.
*** search all best solutions
op search : ListConstraint -> ListConstraint .

eq search(L) = $search(L, noConstraint, nil, noConstraint ) .


op $search : ListConstraint Constraint ListContinuation ListConstraint -> ListConstraint .

*** total solution found
eq $search(noConstraint, SC, Cont, ListResult) =
$backtrack(Cont, insert(SC, ListResult)) .

*** constraint cannot be combined with the current partial solution eq $search([AL | empty] Rest, SC, Cont, ListResult) =
$backtrack(Cont, ListResult) .

*** search for a partial solution
eq $search([AL | (VL |-> P) ERest] Rest, noConstraint, Cont, ListResult) =
if branch(P, ListResult) then


$search([AL | ERest] Rest, noConstraint, Cont, ListResult) else
$search(Rest, [AL | (VL |-> P)],
ct([AL | ERest] Rest, noConstraint) Cont, ListResult)
fi .

*** combine remaining constraints with an existing partial solution eq $search([AL | (VL |-> P) ERest] Rest,
[BL | (WL |-> Q)], Cont, ListResult) = if branch(P * Q, ListResult) then
*** stop searching this branch (descending order optimization)
$backtrack(Cont, ListResult)
else if (not consistent(AL, BL, VL, WL)) then
*** continue on this branch
$search([AL | ERest] Rest, [BL | (WL |-> Q)], Cont, ListResult) else
*** extend partial solution and store continuations
$search(Rest, [AL | (VL |-> P)] * [BL | (WL |-> Q)],
ct([AL | ERest] Rest, [BL | (WL |-> Q)]) Cont, ListResult)
fi fi .



Correctness of Search
It is easy to see that the search algorithm is terminating. The following lemma is the basis for the correctness proof of the search algorithm; it assumes semi-monotonicity of multiplication w.r.t. ≤ and the sets Bi of the soft constraints under consideration.
Lemma 4.1 (search invariant) Let M be an ordered monoid. Let cl = cl1 ... cln be a list of soft constraints such that for each cli, ⊗ is semi-monotone w.r.t < and the set of ranks of cli, and that the valuations of each cli are sorted in descending order according to their ranks. Let sc be a partial constraint, cont be a list of continuations of the form ct(contl1, scont1), . . . , ct(contlk, scontk), and scl be a list of m possible solutions with ranks b1 ... bm, i.e., scl is a list of simple constraints of the form scli = [xl | (wli '→ bi)].
Then the following holds:
$backtrack(cont, scl) = maxSol(  k	(scontj ⊗   contlj) ⊕  (scl));
$search(cl, sc, cont, scl) = maxSol(sc ⊗   cl ⊕  k	(scontj ⊗   contlj) ⊕
(scl)).
(We use ⊕ and	to denote list concatenation and iterated list concatenation.)
Proof. By simultaneous computational induction on both operations.	 
The correctness of the search operation follows directly from termination and the invariant lemma:
Theorem 4.2 (total correctness of search) Let C be a constraint problem and let C' be the corresponding flattened constraint problem. Let cl ' be the list of con- straints of C'. Then the following holds:
search(cl') = maxSol (C).

Proof. We have
search(cl') = $search(cl', noConstraint, nil, noConstraint )


Fig. 1. Average performance for randomly generated problems with 20 variables, 3 domain elements and 10 constraints for total preference relations. Times in seconds.

Fig. 2. Average performance for randomly generated problems with 20 variables, 3 domain elements and 6 constraints for total and partial preference relations. Branch and bound search, times in seconds.
= maxSol (noConstraint ⊗   cl ')
= maxSol (   cl '),

where the second equality uses Lemma 4.1 and the fact that the empty constraint does not contribute any constraint. The third equality follows from the unit property of noConstraint . Then the result follows from Lemma 3.1.	 

Benchmarks
To evaluate the performance of the solver we used several variations of randomly generated problems with preference relations mapping either into lexical or point- wise products of finite sets, corresponding to, respectively, preference or indifference between constraints. As expected the search complexity depends strongly on the size of the given problem and on details like the ordering of the constraints and variables.
A general observation is that the introduction of totally ordered preferences tends to speed up the search significantly whereas the introduction of indifferences (which lead to partial orders) slows down the search, often several orders of mag- nitude. The divide and conquer optimization separates the problem into several smaller ones which can be solved independently and thereby tends to reduce the time necessary to compute the solutions. However, there are certain problems where each of the preceding statements does not hold and the reverse effect can be ob- served.
We generated random problems with 20 domain variables, 3 different values in each domain and 10 constraints each having 3 variables in its domain. Without constraint orders the computation of all maximal solutions to these problems took between 20 and 30 seconds. Dividing the set of constraints into two preference classes reduced the time to between 7 and 20 seconds in most cases, but some

problems required nearly a minute of search time, depending on the placement of the individual constraints into the preference classes. Introducing a third hierarchy of levels clearly increased the performance of the search in all cases and led to times between 0,3 and 5 seconds, see Figure 1 for the average values. Adding the divide and conquer optimization reduced the average times significantly with an increase in performance roughly proportional to the number of preference classes. If no preferences between constraints are defined the divide and conquer optimization is not applicable and does not influence the execution time.
Indifferences between constraints which lead to partial orders heavily increase the time required to find the best solutions. Problems with 6 constraints generally take under 5 seconds to compute, but using only a single indifference increases this to more than 90 seconds. In this variation, total preference orders require only fractions of a second of execution time, see Figure 2.

Related Work
The most direct influence on our work was the elegant theory of semiring-based constraint satisfaction problems (SCSPs)(see e.g. [5,6,4]); the constraint solver pre- sented in this paper is an enhanced version of the solver for semiring-based con- straints presented in [21]. Semirings are not closed under lexicographic products, therefore SCSPs cannot be used to directly express the preference relations described in this paper. Other approaches to generalize SCSPs for preference relations are given in [8,7]. Our approach was also inspired by [1] where preferences are treated in an elegant algebraic way.
The separation into grades and ranks resembles the stratification of constraint problems in constraint hierarchies [10,9]. Constraint hierarchies describe a hierarchi- cal structure of crisp constraints where a comparator function computes values for the quality of solutions which are consistent with the hierarchy. There exist many algorithms for solving particular constraint hierarchies, and a number of constraint solvers for solving particular constraint hierarchies have been implemented [19,2,16]. It is an interesting problem to try to generalize some of these algorithms to work with our framework.
Other implementations of constraint solvers for soft constraints are described in [3,15,14,18]. The standard reference for decisions with multiple objectives is [17].

Conclusions and Further Work
We have presented a novel approach to soft constraints that is based on well-known mathematical structures [11,12] and allows users to express general preference rela- tions for decisions with multiple objectives in a straightforward manner, developed an implementation of a constraint solver in Maude, and proved its correctness.
The current implementation of the constraint solver is based on a branch-and- bound search. An interesting open problem is which other constraint satisfaction techniques can be applied to (specializations of) the soft constraint systems de-

scribed in this paper and how their performance will relate to the relatively simple branch-and-bound search mechanism.
Using Maude as the implementation language simplifies the correctness proof for the implementation and allows us to easily integrate the solver into the Pagoda system for software-defined radios. On the other hand, using the Maude system entails some inefficiencies which are not incurred when implementing the solver in a lower-level language. We are currently working on a C# implementation which we expect to be competitive with other soft-constraint solvers.
In the Maude implementation we flatten the constraint system and thereby re- move the separation between grades and ranks before trying to solve the constraints. While this simplifies the constraint solver this preprocessing removes information that might be used to improve the performance of the constraint solver. Further re- search is needed to find appropriate analysis methods that can exploit the two-level structure of the constraint problem to generate improved solvers.
Currently we restrict constraints to finite support. It is straightforward to gen- eralize the theory to constraints with infinite support and therefore to address prob- lems that go beyond constraint satisfaction problems. However, further research is needed to develop efficient methods to solve these generalized problems.

References
Hajnal Andr´eka, Mark Ryan, and Pierre-Yves Schobbens. Operators and laws for combining preference relations. J. Log. Comput., 12(1):13–53, 2002.
Greg J. Badros, Alan Borning, and Peter J. Stuckey. The cassowary linear arithmetic constraint solving algorithm. ACM Trans. Comput.-Hum. Interact., 8(4):267–306, 2001.
Stefano Bistarelli, Thom W. Fru¨hwirth, and Michael Marte. Soft constraint propagation and solving in chrs. In SAC, pages 1–5. ACM, 2002.
Stefano Bistarelli and Fabio Gadducci. Enhancing constraints manipulation in semiring-based formalisms. In G. Brewka, S. Coradeschi, A. Perini, and P. Traverso, editors, Proceedings of ECAI 2006, 17th European Conference on Artificial Intelligence, volume 141 of Frontiers in Artificial Intelligence and Applications, pages 63–67. IOS Press, 2006.
Stefano Bistarelli, Ugo Montanari, and Francesca Rossi. Semiring-based constraint satisfaction and optimization. J. ACM, 44(2):201–236, 1997.
Stefano Bistarelli, Ugo Montanari, and Francesca Rossi. Soft concurrent constraint programming. ACM Trans. Comput. Log., 7(3):563–589, 2006.
Stefano Bistarelli, Maria Silvia Pini, Francesca Rossi, and Kristen Brent Venable. Bipolar preference problems: Framework, properties and solving techniques. In Francisco Azevedo, Pedro Barahona, Fran¸cois Fages, and Francesca Rossi, editors, CSCLP, volume 4651 of Lecture Notes in Computer Science, pages 78–92. Springer, 2006.
Stefano Bistarelli, Maria Silvia Pini, Francesca Rossi, and Kristen Brent Venable. Uncertainty in bipolar preference problems. In Christian Bessiere, editor, CP, volume 4741 of Lecture Notes in Computer Science, pages 782–789. Springer, 2007.
Alan Borning, Bjørn N. Freeman-Benson, and Molly Wilson. Constraint hierarchies. Lisp and Symbolic Computation, 5(3):223–270, 1992.
Alan Borning, Bjørn N. Freeman-Benson, and Molly Wilson. Constraint hierarchies. In Michael Jampel, Eugene C. Freuder, and Michael J. Maher, editors, Over-Constrained Systems, volume 1106 of Lecture Notes in Computer Science, pages 23–62. Springer, 1995.
Nicolas Bourbaki. Algebra I, Chapters 1–3. E´lements de math´ematique. English. Springer, 1989.

Nicolas Bourbaki. Algebra II, Chapters 4–7. E´lements de math´ematique. English. Springer, 1990.
Rocco De Nicola, Gianluigi Ferrari, Ugo Montanari, Rosario Pugliese, and Emilio Tuosto. A Basic Calculus for Modelling Service Level Agreements. In Jean-Marie Jacquet and Gian Pietro Picco, editors, International Conference on Coordination Models and Languages, volume 3454 of LNCS, pages 33 – 48, Namur (Belgium), April 2005. Springer.
Alberto Delgado, Carlos Alberto Olarte, Jorge Andr´es P´erez, and Camilo Rueda. Implementing semiring-based constraints using mozart. In Peter Van Roy, editor, MOZ, volume 3389 of Lecture Notes in Computer Science, pages 224–236. Springer, 2004.
Yan Georget and Philippe Codognet. Compiling semiring-based constraints with clp (fd, s). In Michael J. Maher and Jean-Francois Puget, editors, CP, volume 1520 of Lecture Notes in Computer Science, pages 205–219. Springer, 1998.
Warwick Harvey, Peter J. Stuckey, and Alan Borning. Fourier elimination for compiling constraint hierarchies. Constraints, 7(2):199–219, 2002.
R.L. Keeney and H. Raiffa. Decisions with Multiple Objectives: Preferences and Value Trade-offs. Cambridge University Press, Cambridge, 1993.
Hana Rudov´a. Soft clp (fd). In Ingrid Russell and Susan M. Haller, editors, FLAIRS Conference, pages 202–207. AAAI Press, 2003.
Michael Sannella, John Maloney, Bjørn N. Freeman-Benson, and Alan Borning. Multi-way versus one- way constraints in user interfaces: Experience with the deltablue algorithm. Softw., Pract. Exper., 23(5):529–566, 1993.
Martin Wirsing, Allan Clark, Stephen Gilmore, Matthias H¨olzl, Alexander Knapp, Nora Koch, and Andreas Schroeder. Semantic-Based Development of Service-Oriented Systems. In E. Najn et al., editor, Proc. 26th IFIP WG 6.1 Internat. Conf. on Formal Methods for Networked and Distributed Systems (FORTE’06), Paris, France, volume 4229 of LNCS, pages 24–45. Springer, 2006.
Martin Wirsing, Grit Denker, Carolyn Talcott, Andy Poggio, and Linda Briesemeister. A rewriting logic framework for soft constraints. In WRLA 2006, 6th International Workshop on Rewriting Logic and its Applications, April 2006. To appear in ENTCS, 2006.
