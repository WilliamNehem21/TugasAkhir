

Electronic Notes in Theoretical Computer Science 218 (2008) 241–259
www.elsevier.com/locate/entcs

Global State Considered Helpful
Paul Blain Levy 1
University of Birmingham, Birmingham B15 2TT, U.K.

Abstract
Reynolds’ view of a storage cell as an expression-acceptor pair has been widely used by researchers. We present a different way of organizing semantics of state, and in particular game semantics, by adding to typing contexts a zone for global state. This has the following advantages.
Firstly, it causes the “good variable” equations for references to be validated, and also the noninterference equations between distinct references, as enumerated by Plotkin and Power.
Secondly, it gives a cleaner categorical structure based on the configurations (state + program) used to describe operational semantics.
Thirdly, it leads to a simpler proof that the game semantics is sound and adequate with respect to the operational semantics.
Keywords: game semantics, categorical semantics, good variables


Introduction
Languages with state often have special types for storage cells, such as ref types in ML, and var types in Algol-like languages. Some denotational models inter- pret these as a type of distinguishable names [9,14,22], but in other models that is unsuitable. Reynolds [20] suggested that a cell could be regarded as an “expression- acceptor pair”, i.e. a function that returns the current value, together with a pro- cedure that updates it. This suggestion was successfully adopted in both possible world [15] and game semantics [1,2,19].
It was noted, however, that a cell is not an arbitrary expression-acceptor pair, but enjoys some special properties. For example, writing to a cell and then read- ing it gives the value just written. These so-called “good variable” properties 2 were enumerated in [18] in order to axiomatize the computational effect of global state. Recent papers in game semantics have addressed the “good variable” issue by restricting strategies in various ways [12,13].

1 Email: pbl@cs.bham.ac.uk
2 The call-by-name nature of Idealized Algol obscures this issue, because a var type is a type not of cells but of state-dependent expressions that return a cell. Such expressions are not necessarily “good variables”.

1571-0661 © 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.10.015

In this paper, we propose a different approach that entirely avoids this problem. We do not have cell types at all. Instead, we have two-zone contexts Δ; Γ, where Γ is an ordinary context, and Δ (the “storage context”) is a list of cells. For example, a context n : bool, n' : bool, n'' : bool; f : nat → nat means that n, n', n'' are bound to distinct cells storing booleans, and f is bound to a function.
A two-zone context of this kind is hardly novel, as it has been used for the formulation of operational semantics in [4,5] and Chapter 5 of [21]. But in our formulation the new construct binds cells from the storage context Δ, which is less familiar, though it does appear in [17].
We shall look at the impact of this arrangement on game semantics of state. For illustration, let us consider the following call-by-value term M : nat in the above two-zone context:
n := true. n := false.
n'' := false. read n as { true. f(3)+ 4
false. f(7)+ 5
}
In the traditional game semantics in [2], M denotes a set of dialogues between Proponent (P) and Opponent (O) such as the following.
P: Set n to be true. O: OK.
P: Set n to be false.
O: OK.
P: Set n'' to be false.
O: OK.
P: What is n currently? O: True.
P: I call f with argument 3. O: Your call returns 2.
P: I return 6.
Note that this play involves unnecessary information (the first call to n) and an impossible response from Opponent (that n is true). The assignment and reading commands are seen as no different from function calls.
In the game semantics we shall present, here is an example dialogue of M pro- ceeding from the initial state n '→ true, n' '→ false, n'' '→ true.
P: I call f with argument 7, in state n '→ false, n' '→ false, n'' '→ false. O: Your call returns 14, in state n '→ false, n' '→ true, n'' '→ false.
P: I return 19, in state n '→ false, n' '→ true, n'' '→ false.

Now the entire global state must be described in each move, but no moves are required to read or assign to a cell. Note that Opponent assigns to n'—it is a global cell, so both players have access to it.
It is clear how to calculate the denotation of M ' d=ef new n'' := true. M from the denotation of M . The effect of new is to make n'' into a private cell that Opponent does not have access to. So we look at those dialogues in which n'' is initially true, and Opponent never changes n''—such as the dialogue we saw—and then erase all mention of n''
It is also clear how to weaken M by calculating its denotation in the bigger context n : bool, n' : bool, n'' : bool, n''' : nat; f : nat → nat. This time, we consider those plays where Proponent never changes the contents of n''' and erasing n''' yields a play on M .
These two operations, hiding and weakening, in combination with the tradi- tional strategy operations of composition and copycat, provide a simple categorical structure from which the semantics of the individual syntactic constructs is eas- ily obtained. Indeed the game semantics in this paper is not new—it is the same as [1]—it is only the organization which is different 3 . Moreover, the soundness of the model wrt operational semantics is immediate, and this had previously proved challenging, especially in the setting of higher-order store. And the method of [11] can easily be applied to give computational adequacy.
Structure of Paper First we look at a calculus without store, its categorical semantics and then game semantics. Then we do the same with store. Along the way, we shall need in Sect. 3.1 to develop the theory of expansions in order to formulate an injective renaming lemma.

Basic Language
Syntax
To make the game semantics as simple as possible, we work with a calculus JWA where functions are called (by value) but do not return. The types are given by
A ::=	¬A | Σ	Ai | 1 | A × A | X | rec X. A 
where I ranges over finite sets (or countable, for an infinitary variant). The type
¬A corresponds to A → 0 in call-by-value. There are two kinds of terms, values and nonreturning commands, indicated by the judgements Γ ▶v V : A and Γ ▶n M respectively. The types in Γ and A are all closed. The syntax is shown in Fig. 1.
A renaming Γ  θ  ' maps each identifier in Γ to one of the same type in Γ', whereas a substitution Γ  k  ' maps each identifier in Γ to a value. These induce operations θ† and k∗ on terms in the usual way. They are used in the operational
semantics (Fig. 2) and the equational theory (Fig. 3). We write xM to mean M
weakened by x.

3 Another recent categorical semantics for higher-order store is that of [8], but this has been applied to


Γ ▶v x : A (x : A) ∈ Γ
Γ ▶v V : A	Γ, x : A ▶n M


Γ ▶n let V be x. M 


Γ ▶v V : Aˆı
Γ ▶v V : Σ

Ai	Γ, xi : Ai ▶n Mi (∀i ∈ I)

Γ ▶v ⟨ˆı, V ⟩ :

i∈I
ˆı ∈ I
	i∈I	
Γ ▶n pm V as {⟨i, xi⟩.Mi}i∈I



Γ ▶v V : A	Γ ▶v V ' : A'


Γ ▶v ⟨V, V '⟩ : A × A'
Γ ▶v V : A × A'	Γ, x : A, y : A' ▶n M

Γ ▶n pm V as ⟨x, y⟩. M 



Γ, x : A ▶n M


Γ ▶v λx.M : ¬A
Γ ▶v V : ¬A	Γ ▶v W : A


Γ ▶n VW 



Γ ▶v V : A[rec X. A/X] Γ ▶v fold V : rec X. A 
Γ ▶v V : rec X. A	Γ, x : A[rec X. A/X] ▶n M


Γ ▶n pm V as fold x. M 

Fig. 1. Syntax of JWA with type recursion (the 1 type is omitted)


Transitions
let V be x. M	~ M [V /x]
pm ⟨ˆı, V ⟩ as {⟨i, x⟩.Mi}i∈I ~ Mˆı[V /x]
pm ⟨V, V '⟩ as ⟨x, y⟩. M	~ M [V /x,V '/y] pm fold V as fold x. M ~ M [V /x] (λx.M )V	~ M [V /x]
Terminal configurations


pm z as {⟨i, x⟩.Mi}i∈I pm z as ⟨x, y⟩. M pm z as fold x. M zV




Fig. 2. Operational semantics on commands in fixed context Γ
Remark 2.1 For recursive types, we have included only the most rudimentary equations—merely asserting an isomorphism rec X. A =∼ A[rec X. A/X].

Semantics of Types, Contexts, Renamings
We recall the “families” construction from [3]: if C is a category, then an object of
fam(C) is a family of C-objects. The homset from {Ai}i∈I to {Bj}j∈J is given by

i∈I
j∈J
G(Ai, Bj). This inherits finite products from C.

An arena is a countable forest; we write ▶ to mean “is a parent of”, and say
∗▶ r when r is a root. We write rt R for the roots of R, and R T r for the arena of

different kinds of games.

let V be x. M = M [V /x]
pm ⟨ˆı, V ⟩ as {⟨i, x⟩.Mi}i∈I = Mˆı[V /x]
pm ⟨V, V '⟩ as ⟨x, y⟩. M = M [V /x,V '/y]
pm fold V as fold x. M = M [V /x]
(λx.M )V = M [V /x]
M [V /z]= pm V as {⟨i, x⟩. xM [⟨i, x⟩/z]}i∈I M [V /z]= pm V as ⟨x, y⟩. x,yM [⟨x, y⟩/z] M [V /z]= pm V as fold x. xM [fold x/z]
V = λx. xV x
Fig. 3. Equational laws for JWA

proper descendants of r. We write  for disjoint union, and pti∈IRi for the arena with I roots and a copy of Ri placed below the ith root.
A closed type denotes an arena family 4 , in the following manner: 1 = {∅}⟨⟩∈1
{Ri}i∈I × {Sj }j∈J = {Ri  Sj }⟨i,j⟩∈I×J


i∈I
{Rij
}j∈Ji
= {Rij
def
}⟨i,j⟩∈I×J

¬{Ri}i∈I = {pti∈IRi}⟨⟩∈1
The semantics of (open types and) recursive types follows [3], giving an arena iso- morphism [rec X. A]] =∼ [[A[rec X. A/X]]]. A context Γ denotes an arena family using the 1 and × operations.
An arena renaming morphism is a function R   f   that maps each root b ∈ rt R to a root fb ∈ rt S and restricts to an arena isomorphism RT  fb  ST fb . These form a cocartesian category TokCh. Renamings between contexts are inter-
op	def	op

preted in B
where B = fam(TokCh
). The category B is a countably distributive

and equipped with an endofunctor ¬ on its isomorphism groupoid Isos B. Such a category is called a JWA base.

Categorical Structure
For a category C,a left C-module is a functor Cop  N  Se t . We think of N(R) asa homset—its elements are “morphisms from R” and written R  f  . We use them to interpret nonreturning commands.
Definition 2.2	(i) A ﬁrst-order JWA model on a base B consists of
a category C, with the same objects as B
a left C-module N
an identity-on-objects functor B  K  C 

4 Throughout this paper, “family” means countable family.

such that all the following functions are isomorphisms



C(A × Σ

i∈I
Bi,C) −→ 

i∈I
C(A × Bi,C)

N(A × Σ

i∈I
Bi) −→	 

i∈I
N(A × Bi)

f	'−→ λi.((A × ini); f ))
A JWA model on B is a first-order JWA model together with an isomorphism
N(A × B) =∼ C(A, ¬B) natural in A ∈ Cop ,B ∈ Isos B	(1) We write FOJWA(B) for the (large) category of first-order JWA models on base
B, and JWA(B) for the (large) category of JWA models on base B. Morphisms
are identity on objects.
op
We emphasize that, in the semantics of JWA, a renaming is interpreted in	,
op
whereas a substitution is interpreted in C .
Strategies
If S is a left G-module, then fam(S): {Ri}i∈I '→	S(Ri) isa left fam(C)-module. Using this construction, we will build a JWA model (C, N) = (fam(G), fam(S)) on
def	op
the base B = fam(TokCh ).
Definition 2.3 (NB Proponent begins) Let R be an arena. We define ∗ = −1.
A (finite) justiﬁed sequence on an arena R is a sequence m0,... , mn−1 where each mi = (pi, ri) consists of a pointer ∗ ≤ pi < i and an element ri ∈ R such that rpi ▶ ri, where r∗ = ∗.
A justified sequence is a play when i − pi is odd for every i < n. In a play, a move i < n is a Proponent move or an Opponent move according as i is even or odd. A play is prior or posterior according as its length is even or odd.
A strategy is a prefix-closed set σ of posterior plays that is deterministic: if
sm, sm' ∈ σ then m = m'. We write S(R) for the set of strategies on R.

We write SHO(R) for 

b∈rt R
S(Rb). This is (isomorphic to) the set of strategies

where (as in [7]) Opponent begins, and may not point to ∗ after the initial move.
Definition 2.4 Let R and S be arenas.
We define the Hyland-Ong exponential R →HO S = ptb∈rt S (R  Sb)
We define the homset

G(R, S)	=
SHO(R →HO S)
=∼	S(R  Sb)

For an arena renaming morphism S   f	  , we define the copycat R Kf 
in G. At b ∈ rt S, it is the set of posterior plays on R  Sb in which Proponent
begins with (∗,f (b)) and responds to (j, r) by pointing to j − 1 and playing
fb(r) or f −1(r) according as r ∈ Sb or r ∈ Rf (b).
Definition 2.5 Let R, S, T be arenas.
An interaction sequence on R, S, T is a justified sequence s on (R →HO S)  T
such that
the right inner thread s T S  T is a play
for each move m playing b ∈ rt S, the left inner thread s T m consisting of moves strictly descended from m is a play on R  Sb
the outer thread s T R T (with the pointer from each R root move changed to ∗) is a play.
It is outer-posterior when the outer thread is posterior.
Let σ ∈ G(R, S) and let τ ∈ S(S  T ). We define σ ÷ τ ∈ S(R  T ) to be the outer thread of each outer-posterior interaction sequence s on R, S, T whose inner threads (s T m) ∈ σr(m) and (s T S  T ) ∈ τ .
The composite of R   f	   g   is defined at c ∈ rt T by ÷, while the com-
S	T

posite of R   f	  g  i s given by ÷
R,S,∅
. The identity on R is given by KidR.

This gives all the required structure, and we recover f ÷ g as (f × T ); g. Moreover, pre- and post-composition with Kf is given by renaming of elements. Applying the families construction to (G, S) gives a JWA model (C, N) on base B as required.
Computational Adequacy
To model divergence in JWA, we require the following structure.
Definition 2.6 A JWA model (C, N) on base B is pointed when it is equipped with a distinguished element ⊥A ∈ N (A) for each object A, such that f ; ⊥B = ⊥A for each A   f   in C.
Clearly our game model is pointed: the ⊥ morphism from an arena family
{Ri}i∈I is given at i ∈ I by the empty strategy.
We shall say that a pointed JWA model (equipped with a B-isomorphism to interpret each recursive type) is adequate when M ~ω implies [M ]] = ⊥. Our aim is to show that our game model is adequate. We proceed as follows.
Definition 2.7 Let f be an endofunction on a set A.
A sequence (an)n∈N in A is a ﬁxed sequence of f when f (an+1) = an for all
n ∈ N.
A fixpoint a of f is sequentially unique when every fixed sequence of f is the constant sequence at a. (Clearly this implies uniqueness.)
Definition 2.8	(i) A JWA model (C, N) on base B is ticking when it is equipped with an endofunction CA on N(A) for each object A, such that

CA has a sequentially unique fixpoint Cω , for each object A
C(f ; g)= f ; C(g) for each A  f  g  i n C and N. (Clearly this implies f ; Cω = Cω for each A   f   in C.)
A tick-hiding from a ticking JWA model MJ = (CJ, N J) to a pointed JWA model M = (C, N) on the same base B is a morphism MJ  α  M in JWA(B) such that
α(C(f )) = αf for each A   f  i n N J
α(Cω )= ⊥A for each object A.
Proposition 2.9 Let M = (C, N) be a pointed JWA model on base B. If there exists a ticking JWA model MJ = (CJ, N J) on base B and a tick-hiding MJ  α  M , then M is adequate.
To apply Prop. 2.9 to our game semantics, we define
Definition 2.10 (i) A prior ticking play is a prior play where each Proponent- move has a number attached (representing the number of ticks output by Pro- ponent).
A posterior ticking play is either a posterior play where each Proponent-move has a number attached, or a prior ticking play followed by ω (representing infinitely many ticks).
A ticking strategy on an arena R is a prefix-closed set σ of posterior ticking plays that is deterministic: i.e. if sm, sm' ∈ σ then m = m'. We write SJ(R) for the set of ticking strategies on R.
The tick-hiding of a ticking strategy σ on an arena R is the strategy obtained by discarding all the numbers of ticks in each play, and discarding all the plays that end in ω (they become divergences).
We then define the rest of the ticking model just as in Sect. 2.4. For composition, some plays ending in ω arise as the outer thread of an infinite interaction sequence, as in [11]. We omit details.

Adding Storage
To add storage to JWA, we use contexts of the form Δ; Γ, where Δ is a list of distinct locations with associated type and Γ as before is a list of distinct identifiers with associated type. The syntax is given by Fig. 1 with Γ replaced by Δ; Γ, and also by Fig. 4.
Again a renaming Γ   θ  ' maps identifiers to identifiers, and a substitution Γ   k  '  maps each (x : A) ∈ Γ to a value Δ; Γ' ▶v k(x) : A. An injection
Δ  Γ
Δ   φ    ' maps each location in Δ injectively to one of the same type in Δ'. These induce operations θ†, k∗ and φ† on terms.
We write Δ; Γ ▶sn E to mean that E is a configuration that can arise during the execution of a command Δ; Γ ▶n M . It will consist of a list of local cells, a



Δ; Γ ▶v V : A	Δ; Γ ▶n M


Δ; Γ ▶n n := V. M

(n : A) ∈ Δ
Δ; Γ, x : A ▶n M
Δ; Γ ▶n read n as x. M (n : A) ∈ Δ



−−→
v −−−→
−−→	n

Δ, n : A; Γ ▶ V : A	Δ, n : A; Γ ▶ M

Δ; Γ ▶n
−−−−→
new n := V. M


Fig. 4. Syntax For State
−→	−→

A ; s; n := V. M	~
−→
A ; s; read n as x. M	~
A ;	s[n '→ V ];	M
−→
A ;	s;	M [s(n)/x]

−→	−−−−→
−→ −→'
−→n
−−−−→

A ; s; new n := V. M	~
A, A ;
s, n '→ V ; M


Fig. 5. Transitions For Storage
global state, a local state and a command, as follows.
−−→ −'−−→'	v −−−→ −−'−−→'	−−→ −'−−→'	n

n : A, n
: A ; Γ ▶
V : A, V : A
n : A, n
: A ; Γ ▶ M

−−→
sn −'−−→'
−−−−→
−−' −−−→'

n : A; Γ ▶
n : A ;
n '→ V, n
'→ V ; M

We define operational semantics for commands in a fixed context Δ; Γ. The transitions are those in Fig. 2 (leaving the store unchanged) and those in Fig. 5. The terminal configurations are as in Fig. 2, with any store. To execute a command Δ; Γ ▶n M in a given global state, mapping each (n : A) ∈ Δ to a value Δ; Γ ▶v
V : A, we begin with ε; s; M and follow the transitions.
For understanding the operational semantics, it is convenient to assume that, given a storage context Δ, each new cell is named in a canonical way.
But in fact, the choice does not matter, because within the configuration

−'−−→'
−−−−→ −−' −−−→'
−→'

n : A ;
n '→ V, n
'→ V
; M the identifiers n
are bound.

The equational theory of JWA with store is given by Fig. 3 together with Fig. 6.
We extend it to configurations by taking Fig. 5 and the “exchange” equation

−→	'
−→'
−−−−→
'	' −−' −−−→'

n , p, p , n ; s,
n '→ V, p '→ W, p
'→ W , n
'→ V
; M  =

−→	'
−→'
−−−−→	'	'
−−' −−−→'

n , p , p, n ; s,
n '→ V, p
'→ W , p '→ W, n
'→ V ; M


It is important to note the limitations on structural rules for terms and config- urations in context Δ; Γ.
We do not have semantically meaningful contraction in Δ. For example, the equation
n : bool, n' : bool; k : ¬1 ▶n n := true. n' := false. k⟨⟩
= n' := false. n := true. k⟨⟩

read n as x. n := x. xM = M
read n as x. read n as y. M = read n as z. M [z/x, z, y]
n := V. n := W. M = n := W. M
n := V. read n as x. M = n := V. M [V /x]
read n as x. read n' as y. M = read n' as y. read n as x. M	(n /= n') n := V. n' := W. M = n' := W. n := V. M	(n /= n')
n := V. read n' as x.M = read n' as x. n := xV. M	(n /= n')

−−−−→
'	' −'−−−→
−−−−→	'	'
−'−−−→

new n := V, p := W, p
−−−−→
= W , n
'
:= V. M = new n := V, p
−−−−→
:= W , p = W, n
:= V. M

new n := V, m := V . m := W. M = new n := V, m := W. M

−−−−→
new n := V, m := V
−−−−→
. read m as x. M = new n := V, m := V
'. M [V
'/x]

−−−−→
new n := V. m :=
−−−−→
−→n
−−−−→
W. M = m := W. new n := V .M
−−−−−x→

new n := V. read m as x. M = read m as x. new n := V. M

−−−−→
new n := V. 
−→n
M = M

−−−−→
−−−−→
−−−−−−→→
−−−−→

new n := V. new m := W. M = new n :=
mV, m := W. M


Fig. 6. Equations for storage (cf. [18])
is provable, but renaming both n and n' as n'' : bool makes the theory inconsistent.
For configurations, we also lack weakening in Δ. For example, there is a config- uration
; k : ¬1 ▶sn ε; ε; k⟨⟩
but no configuration in context n : 0; k : ¬1.

Modelling Injections
We want to model each syntactic category: types, contexts, storage contexts, val- ues, commands, configurations, renamings, substitutions and injections. Storage contexts are interpreted using the finite products in the base B, just like ordinary
op
contexts. Renamings are interpreted in B , but what about injections? An elegant
solution was provided by Oles and Reynolds [15].
Definition 3.1 Let A be a cartesian category.
An expansion A (r,∗)   consists of a “read” morphism B	r    and an
B	A
“update” morphism B × A   ∗   satisfying 5
∀b ∈ B, a ∈ A. r(b ∗ a)= a
∀b ∈ B. b ∗ r(b)= b
∀b ∈ B, a, a' ∈ A. (b ∗ a) ∗ a' = b ∗ a'

The composite of expansions
 (r,∗)   (r',∗')  is	(r'',∗'')  where

A	B	C	A	C

5 These equations represent commutative diagrams in the standard way. We write the binary operation ∗
in infix style.

r''(c) d=ef r(r'(c))
c ∗'' a d=ef c ∗' (r'(c) ∗ a)
and the identity expansion on A is (idA, π'	).
We write expan(A) for the category of objects of A and expansions. It is a coaffine category i.e. a symmetric monoidal category (under ×) whose unit is an initial object. Hence, by coaffine coherence [16], we can interpret injections in it.
Any isomorphism B  α  A × Q gives an expansion A   e  


read
B 	α	 A × Q 	π	 



update	B × A
 α×A  (A ×
Q) × A
⟨π',(π;π')⟩	 A × Q α−1 


We say that (Q, α) is a quotient of e. A morphism between quotients is Q  f	 such that α; (A × f )= β. (This guarantees that (Q, α) and (R, β) give the same expansion.) So any expansion has a category of quotients.
Definition 3.2 Let A be a cartesian category A with a strict initial object. We say A has nonsingular quotients when every expansion from a non-initial object has a quotient that is unique up to unique morphism (and hence, in the usual manner, unique up to isomorphism).
Proposition 3.3 Both  CSet  (the  category  of  countable  sets)  [15]  and
op
fam(TokCh  ) have nonsingular quotients.
A storage context denote an object of CSet in the case of ground store, and
op
fam(TokCh ) in the case of general store, and we shall see that Prop. 3.3 enables
us to define the requisite structure in terms of products, rather than in terms of

expansions.
In general, for an object D and object sequence
−→
A = A0,... , An−1, we write

e −→ for the expansion from D to the left-associated product D × A0 ··· × An−1
D: A
given by induction on n in the evident way. This is useful, because a storage context
−−→
Δ, n : A denotes the left-associated product [Δ ] × [[A0]] × ··· × [[An−1]].

Conﬁgurations and their categorical structure
By way of motivation for our categorical semantics, we note some pertinent facts.

−−→
Proposition 3.4 Let Δ = n : A. The map from commands Δ; Γ ▶n
M to con-

−−→
ﬁgurations Δ; Γ, x : A ▶sn
provable equality.
E that maps M to ε;
n−−→−→x;
−→x
M is a bijection up to

This suggests that configurations can be regarded as the primitive entity, and commands as a derived one. That is quite reasonable: whereas the behaviour of a

command is dependent on an initial state, a configuration has just one behaviour. We next consider some operations on configurations.
Any configuration Δ;  Γ	▶sn	E  can be converted into a configuration
−−→	−−→ sn	'

Δ, n : A; Γ, x : A ▶
by n−−→−→x.
E by injective renaming. The additional cells are initialized

−−→
Any configuration Δ, n : A; Γ ▶sn
E can be converted into a configuration

Δ; Γ ▶sn E' by hiding the global cells −→n i.e. making them local.
More generally, for any injection Δ  φ  ' , a configuration Δ'; Γ ▶sn E can be converted into a configuration Δ; Γ ▶sn E'. The order of hiding is immaterial, up to provable equality.
In the following definition, C homsets should be thought of as values (or substitu- tions), and E homsets should be thought of as configurations.
Definition 3.5 Let B be a base category with nonsingular quotients.
A JWA model with global state on B consists of
a first-order JWA model (CD, E D) functorial in D ∈ Isos B—more precisely: a functor
(C−,E− )

an isomorphism
Isos B
FOJWA(B)

E D(D × (A × B)) =∼ CD(A, ¬B)	natural in D, B ∈ Isos B, A ∈ (CD)op
functions

  D,P (A,B)	op
CD(A, B) 	v	 CD ×P (A, B)	natural in D, P ∈ Isos B,A ∈B ,B ∈B 


E D(A)
  D,P (A)	 D ×P
(A × P )	natural in D, P ∈ Isos B,A ∈B 



such that
	 D,P
C
preserves composition in the sense that
CD(A, B) × ED(B)
  × 
J 
CD×P (A, B) × ED×P (B × P )




;	 E D (A)

 

(−×P )×id
J 
CD×P (A × P, B × P ) × ED×P (B × P )

J 
;	 E D ×P (A × P )

acts monoidally in the sense that


E D(A)

E D(A)

  D,P (A)	 D ×P

(A × P )

 D,1(A)
∼=
JJ 

  D,P ×Q(A)
J 

  D×P,Q(A×P )
J 

E D×1(A × 1)
and likewise for 
E D×(P ×Q)(A × (P × Q))	∼
 E( D×P )×Q((A × P ) × Q)

respects singularity in the sense that E0(A)
 0,P (A) 
 E0 ×P (A × P ) and like-
E π−1 (π)

wise for  .
A JWA model with global ground state on B is defined similarly except that
D, P, Q range over Isos CSet instead of Isos B.
Given a JWA model with global state M = (C, E , , ) on B, we can now recover the “commands” from “configurations”. We define N D(A) d=ef E D(D × A), and define MD to be the JWA model (CD, N D). Just as for values, we can define
  D,P (A)
weakening maps N (A)	n	 N	(A) to be the composite
 	
E D(D × A)	 E D ×P ((D × A) × P )	=	 E D ×P ((D × P ) × A)
For an expansion D   e  ' , we define a JWA(B) morphism MD	e†   D'  by

the composites
D


 D,Q(A,B)
M

Cα−1 (A,B)

CD(A, B)   v	 CD ×Q(A, B)	 CD ' (A, B)


 D,Q(A)
Cα−1 (A)

N D(A) 	n	 N D×Q(A) 	 N D' (A, B)
where (Q, α) is any quotient of e. Note that this is independent of the particu- lar choice of quotient, by naturality and (in the case A is initial) the singularity respecting property. And so MD is functorial in D ∈ expan(B).
−−→
Now we can proceed to interpret terms. For a given storage context Δ = n : A,
we interpret JWA with global state in Δ within the JWA model M[[Δ]].
For Δ; Γ, x : Ai ▶n M , the command read ni as x. M denotes the composite in
E[[Δ]]
[[Δ]] × [[Γ]]	⟨π,⟨π',(π;πi)⟩⟩	 [[Δ ]] × ([[Γ ] × [[A ]])	[[M ]]	 
For Δ; Γ ▶v V : Ai and Δ; Γ ▶n M , the command ni := V. M denotes the composite in E[[Δ]]


[[Δ]] × [[Γ]]
⟨q,π'⟩
[[Δ]] × [[Γ]]
[[M ]]	 



where [Δ ] × [[Γ]]   q  [[Δ ]] has ith component of p is π'; [[V ]] and jth component
π; πj for each j /= i
We then interpret configurations Δ; Γ ▶sn E—without local cells—in E[[Δ]]([[Γ ]).
Definition 3.6 Let B be a base category with nonsingular quotients.
A JWA model with state on B consists of
a JWA model with global state (C, E ,  ,  )
functions


D×P

 D,P (A)   D	op

E
such that
(A)
E (A)	natural in D, P ∈ Isos B,A ∈B 

agrees with composition in the sense that
CD(A, B) × ED×P (B) id×  CD (A, B) × ED(B)
  ×id
J 
CD×P (A, B) × ED×P (B)	;
;
J	J 
E D×P (A)		 E D (A)

acts monoidally and respects singularity in the same sense as 
initializing some cells, then hiding them, has no effect:

D	 D,P (A)   D ×P

E  (A) ¸¸¸¸¸	E
¸¸¸¸¸¸
(A × P )
  D,P (A×P )

E D(π)
¸¸¸¸z˛J 
E D(A × P )

initialization and hiding commute on distinct cells:


E D×P
(A)
 E( D×P )×Q
(A × Q)
	∼=	 E( D×Q)×P
(A × Q)

  D,P (A)
J 

  D×Q,P (A×Q)
J 

E D(A)	 

D,Q(A)
 E D ×Q(A × Q)

A JWA model with ground state is defined similarly except that D, P, Q range over Isos CSet instead of Isos B.
Just as with global state, there is additional structure that can be derived from a JWA model with state M = (C, E ,  ,  ,  ) on B. For any expansion D   e  '
v	D

D'	e‡(A)  D 

object A, we define E
(A)
E  (A) to be the composite



D'	E α(A)	 D ×Q

 D,Q(A)   D 

E	(A)
E	(A)
E (A)

where (Q, α) is any quotient of e—again, the choice of quotient does not affect the definition. And so E D(A) is functorial in D ∈ expan(B op and A ∈ Bop .

−−→
We can now complete our semantics of terms. Given terms Δ, n : A; Γ ▶
−−−→
V : A

−−→
and Δ, n : A; Γ ▶n
composite
−−−−→
M , the denotation [new n := V. M ] is obtained by forming the

⟨⟨ −−'−−→	'

	π:π ;[[V ]]⟩,π ⟩	  −−→
[[Δ, n : A]] × [[Γ]]
[[M ]]	 




−−→
over [Δ, n : A ], then applying e

−→‡

to obtain a morphism over [Δ]].

[[Δ]]:[[A]]
That completes our semantics of terms. A substitution Γ   k  '  denotes a
Δ  Γ
C-morphism [[Γ']]  [[k]]  [Γ ]] in the usual way.
[[Δ]]
Proposition 3.7 Let P be a term (command or value) in context Δ; Γ.
(Substitution) For any substitution Γ   k  ' , we have [[k∗P ]] = [[k]]; [[P ]] in
Δ  Γ
M[[Δ]].
(Injective renaming) For any injection Δ	φ  ' we have [[φ†P ]] = [[φ]]†[[P ]].
−−→
We proceed to semantics of configurations. If Δ = n : A and we have values

−'−−→'
v −−−→ −−'−−→'
−'−−→'	n

Δ, n
: A ; Γ ▶ V : A, V
: A and a command Δ, n
: A ; Γ ▶
M then the denota-

−'−−→' −−−−→ −−' −−−→'

tion [n : A ; n '→ V, n
'→ V
; M ] is obtained by first forming the composite



	⟨⟨−−→ −−→'
[[Δ, A ]] × [[Γ]]
[[M ]]	 




−−→
over [Δ, n : A ], then applying e

−→‡

to obtain a morphism over [Δ]].

[[Δ]]:[[A]]
Proposition 3.8 In any JWA model with state, the interpretation of values, com- mands and conﬁgurations validates the equational theory.
Game Semantics Of State
op
In this section, we define a JWA model with state on base fam(TokCh ). First we
fix an arena family D = {Ul}l∈L in order to define (CD, E D). We modify Def. 2.3:
Definition 3.9 Let R be an arena.
A (finite) justiﬁed sequence on an arena R in store context D is a sequence
m0,... , mn−1 where each mi = (pi, li, ri) consists of a pointer ∗ ≤ pi < i, a 

state element li ∈ L and an element ri ∈ ( 

l∈L
Ul)  R such that either

r	▶ r , where r d=ef ∗, or
pi /= ∗ and ri ∈ rt Ulp .
Plays and strategies are unchanged, and SD(R) is the set of strategies on R in

store context D. We write SD (R) for 

l∈L,b∈rt R
S(Ul  Rb).


For arenas R and S, we define the homset


GD(R, S)  d=ef
SD (R →HO S)  =∼

l∈L,b∈rt S
SD(Ul
  R  Sb)


Copycat is defined as above, except that Proponent must also copy the state element, and must copy any moves that explore D. Composition is as before, except that each thread includes root moves in D pointing to its moves, and all their descendants. We now define
CD d=ef fam(GD) E D d=ef fam(SD)
Our next task is to define the weakening operation.

Definition 3.10 Let D = {Tk}k∈K and P = {Ul}l∈L be arena families.
Let R be an arena, let lˆ∈ L be given, and let s be a play on R Uˆl in storage context D × P . We say s is weakened (wrt D, P, ˆl) when for each Proponent move m with state element ⟨k, l⟩
l = ˆl if m = 0, otherwise l is the L component of the state element of m − 1
if either m =0 or move m − 1 plays an element of R ∪ D (i.e. not an element of P ), then so does move m
any Opponent-move n pointing to m and playing b ∈ rt Ul and state element
⟨k', l'⟩ is followed by a Proponent-move n + 1 pointing to m −1 (or ∗ if m = 0) and playing b with state element ⟨k', l'⟩; and any Opponent-move p pointing to a descendant q +1 of n or n +1 and playing c (necessarily in D or P ) with state element ⟨k'', l''⟩ is followed by a Proponent-move p + 1 pointing to q and playing c with state element ⟨k'', l''⟩.
If s is weakened, its outer thread is the play on R in storage context D given by all the moves of s that are in R and D, with only the K-component of each state element. (This is a posterior play if s is.)
Let	R	be	an	arena	and	let	ˆl	∈	L	be	given.	We	define
 D,P	 D ×P

SDR
S	(R  Uˆl) to map σ to the strategy consisting of every

weakened (wrt D, P, ˆl) posterior play whose outer thread is in σ.

From  we derive maps
SD R 	 SD ×P R
HO	HO

GD(R, S) 	 GD ×P (R, S)


 D,P
C (A, B)	v	 C	(A, B)	where C	= fam(G )


E D(A)
  D,P (A)	 D ×P
(A × P )	where E D
= fam(SD)

in the evident way.
Finally we have to define hiding.
Definition 3.11 Let D = {Tk}k∈K and P = {Ul}l∈L be arena families.
Let s be a play on an arena R in storage context D × P . We say that s is
hideable when for every Opponent move m +1 with state element ⟨k, l⟩
l is the L-component of the state element of move m
if m plays an element of R ∪ D, then so does m +1 
any Proponent move n pointing to m +1 and playing b ∈ rt Ul with state element ⟨k', l'⟩ is followed by an Opponent move n + 1 pointing to m and playing b with state element ⟨k', l'⟩; and any Proponent move pointing to a descendant q +1 of n or n +1 and playing c (necessarily in D or P ) with state element ⟨k'', l''⟩ is followed by an Opponent move pointing to q and playing c with state element ⟨k'', l''⟩.
If s is hideable, its outer thread is the play on R in storage context D given by all moves of s that are in R and D, with only the K-component of each state element. (This is a posterior play iff s is.)

D×P
 D,P (R)    D 

For any arena R we define a map S
(R)
S  (R) mapping σ to

the set consisting of the outer thread of every hideable posterior play in σ.

D×P
 D,P (A)   D 

We define E
(A)
E  (A) from
using the families construction.

Proposition 3.12 The game model (C, E ,  ,  ,  ) is a JWA model with state, on
op	v
base fam(TokCh ).

Computational Adequacy
Let B be a base category with nonsingular quotients.
Definition 3.13 A JWA model with state (C, E ,  v,  ,  ) on base B is pointed
when it is equipped with a distinguished element ⊥A ∈ N (A) for each object A,

Clearly our game model is pointed: the ⊥ morphism from an arena family
{Ri}i∈I is given at i ∈ I by the empty strategy.
We shall say that a pointed JWA model (equipped with a B-isomorphism to interpret each recursive type) is adequate when E ~ω implies [E]] = ⊥. Our aim is to show that our game model is adequate. We proceed as follows.
Definition 3.14  (i) We write JWAS(B) for the category of JWA models with state on base B. Morphisms are identity-on-objects and preserve all structure on the nose.
A JWA model with state (C, E ,  ,  ,  ) on base B is ticking when it is equipped with an endofunction CA on N(A) for each object A, such that
CA has a sequentially unique fixpoint Cω , for each object A
A
CA is preserved by precomposition with a C-morphism, by	and by	.
A	tick-hiding	from	a	ticking	JWA	model	with	state	MJ	=
(CJ, E J, J  J  J	M	=
v ,	,	)  to	a  pointed	JWA model	with  state
(C, E ,  v,  ,  ) on the same base B is a morphism	MJ   α	 M  in
JWAS(B) such that
α(C(f )) = αf for each A   f	 i n N J
α(tickω )= ⊥A for each object A.
Proposition 3.15 Let M = (C, E ,  ,  ,  ) be a pointed JWA model on base B.
v J	J	J  J  J  J
If there exists a ticking JWA model M	= (C , E ,	v ,	,	on base B and a
tick-hiding MJ  α  M , then M is adequate.
We apply Prop. 3.15 to prove the adequacy of the game model just as in Sect. 2.5.

Further Work
We have now constructed a model of state and proved adequacy. Some remaining tasks are as follows.
To construct a model for a direct style calculus; this simply follows the con- struction in [10]. The treatment of storage is just as in this paper.
To show that for every storage context Δ and context Γ using finite sums, every computable element of N [[Δ]]( [Γ ]) is definable by a command Δ; Γ ▶n M . Even in [], where Δ was empty, this was an open problem.
To show that the observational preorder corresponds to inclusion of complete traces.
To extend the model to include ref types, so as to reorganize the model of [9].

References
Abramsky, S., K. Honda and G. McCusker, A fully abstract game semantics for general references, in:
Proceedings, 13th Annual IEEE Symposium on Logic in Computer Science, 1998, pp. 334–344.


Abramsky, S. and G. McCusker, Linearity, sharing and state: a fully abstract game semantics for Idealized Algol with active expressions, in: P. W. O’Hearn and R. D. Tennent, editors, Algol-like languages (1997).
Abramsky, S. and G. McCusker, Call-by-value games, in: M. Nielsen and W. Thomas, editors, Computer Science Logic: 11th International Workshop Proceedings, LNCS (1998), pp. 1–17.
Benton, N. and B. Leperchey, Relational reasoning in a nominal semantics for storage., in: Typed Lambda Calculi and Applications, 7th International Conference, TLCA 2005, Nara, Japan, April 21- 23, 2005, Proceedings, Lecture Notes in Computer Science 3461 (2005), pp. 86–101.
Bohr, N. and L. Birkedal, Relational reasoning for recursive types and references, in: N. Kobayashi, editor, APLAS, Lecture Notes in Computer Science 4279 (2006), pp. 79–96.
URL http://dx.doi.org/10.1007/11924661 5

de Lataillade, J., “Quantification du second ordre en smantique des jeux - Application aux isomorphismes de types,” Ph.D. thesis, Universit´e Paris Diderot (Paris 7) (2007).
Hyland, J. M. E. and C.-H. L. Ong, On full abstraction for PCF: I, II, and III, Information and Computation 163 (2000).
Laird, J., A categorical semantics of higher-order store, in: Proc., 9th Conference on Category Theory and Computer Science, Ottawa, 2002, Electronic Notes in Theoretical Computer Science 69, 2003.
Laird, J., A fully abstract trace semantics for general references, in: L. Arge, C. Cachin, T. Jurdzinski and A. Tarlecki, editors, ICALP, Lecture Notes in Computer Science 4596 (2007), pp. 667–679.
URL http://dx.doi.org/10.1007/978-3-540-73420-8 58
Levy, P. B., Adjunction models for call-by-push-value with stacks, Theory and Applications of Categories
14 (2005), pp. 75–110.
Levy, P. B., Infinite trace equivalence, Annals of Pure & Applied Logic 151 (2008).
McCusker, G., On the semantics of the bad-variable constructor in Algol-like languages, in: Proceedings, MFPS 2003, ENTCS 83, 2003.
Murawski, A. S., Bad variables under control, in: J. Duparc and T. A. Henzinger, editors, CSL, Lecture Notes in Computer Science 4646 (2007), pp. 558–572.
URL http://dx.doi.org/10.1007/978-3-540-74915-8 41
O’Hearn, P. W. and R. D. Tennent, Parametricity and local variables, Journal of the ACM 42 (1995),
pp. 658–709.
Oles, F. J., Functor categories and store shapes, in: P. W. O’Hearn and R. D. Tennent, editors, Algol-like languages, Birkhau¨ser, 1997 .
Petric, Z., Coherence in substructural categories, Studia Logica 70 (2002), pp. 271–296.
Pitts, A. M. and I. D. B. Stark, Observable properties of higher order functions that dynamically create local names, or: What’s new?, in: Mathematical Foundations of Computer Science, Proc. 18th Intl. Symp., Gdan´sk, 1993, LNCS 711 (1993), pp. 122–141.
Plotkin, G. and J. Power, Notions of computation determine monads, in: Proceedings, Foundations of Software Science and Computation Structures, 2002, LNCS 2303 (2002), pp. 342–356.
Reddy, U. S., Global state considered unnecessary: An introduction to object-based semantics, Lisp and Symbolic Computation 9 (1996), pp. 7–76.
Reynolds, J. C., The essence of Algol, in: J. W. de Bakker and J. C. van Vliet, editors, Algorithmic Languages (1981), pp. 345–372.
Stark, I. D. B., “Names and Higher-Order Functions,” Ph.D. thesis, University of Cambridge (1994).
Tzevelekos, N., Full abstraction for nominal general references, in: LICS (2007), pp. 399–410.
