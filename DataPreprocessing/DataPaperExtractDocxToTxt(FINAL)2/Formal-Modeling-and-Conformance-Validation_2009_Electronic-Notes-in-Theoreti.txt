

Electronic Notes in Theoretical Computer Science 229 (2009) 155–174
www.elsevier.com/locate/entcs

Formal Modeling and Conformance Validation for WS-CDL using Reo and CASM
Samira Tasharofia,b,1 Marjan Sirjania,b,2
a Department of Electrical and Computer Engineering, University of Tehran, Tehran, Iran
b School of Computer Science, Institute for Studies in Theoretical Physics and Mathematics (IPM), Niavaran Square, Tehran, Iran

Abstract
WS-CDL is a choreography language that describes peer-to-peer collaborations of participants by defin- ing their common and complementary observable behaviors from a global viewpoint. The main use of a choreography description is to precisely define the sequence of interactions between a set of cooperating web services in order to promote a common understanding between participants and to make it easy to automatically validate conformance and ensure interoperability. To this purpose, WS-CDL must be based on or related to a formal language that provides these validation capabilities. In this paper, we benefit from Reo and Constraint Automata with State Memory (CASM) to address this problem by providing a unified formalism for choreography and orchestration. Furthermore, we show how to exploit this formalism for conformance validation by giving proper definitions for end-point projection and conformance problem.
Keywords: Web services, Choreography, Orchestration, WS-CDL, Conformance, Reo, Constraint Automata with State Memory


Introduction
Service-Oriented Computing (SOC) is an emerging paradigm for distributed com- puting and e-business processing. The aim of web service composition is to provide the mechanism to fulfill the complexity of the execution of business processes. Two different but overlapping viewpoints for the composition of web services are un- der investigation, namely orchestration and choreography. The former focuses on a single service, describing its interactions with other services as well as its internal actions. The latter is a multi-party contract that describes the external observable behavior across multiple participants from a global view [24,25]. Following the sec- ond approach, the overall activity is achieved by the composition of peer-to-peer

1 Email: stasharofi@ut.ac.ir
2 Email: msirjani@ut.ac.ir

1571-0661 © 2009 Published by Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.06.034

interactions among the collaborating services. Therefore, choreography is a spec- ification protocol defining a global picture of the way services interact with each other.
While several proposals exist for orchestration languages (e.g. BPML [1] and BPEL [22]), choreography languages are still in a preliminary stage of definition. The first proposed language, WS-CDL [3], was issued by the World Wide Web Con- sortium (W3C). The main use of a choreography description is to precisely define the sequence of interactions between a set of cooperating web services in order to promote a common understanding between participants and to make it easy to pro- mote a common understanding between participants (web services), automatically validate conformance, ensure interoperability, and increase robustness [2]. WS-CDL is neither an executable business process description language nor an implementa- tion language [3]. As mentioned in [10], one of the goals of WS-CDL is using it in conjunction with BPEL for building service oriented systems in a complementary fashion. In this way, the conformance problem, which examines whether the behav- ior of an orchestration conforms to the protocol specification, is an important issue to be resolved for achieving this goal.
In this paper, we use Reo and Constraint Automata with State Memory (CASM) for modeling choreographies and conformance validation. Reo [5] is an exogenous coordination model wherein complex coordinators, called connectors, are compo- sitionally built out of simpler ones. Constraint automata [8] and its variations, e.g., CASM [6], are proposed as operational semantics for Reo. The advantage of Reo is that Reo circuits can be used for modeling both communication and coor- dination of web services [18,27,28]. In [28] we proposed a mapping from BPEL to Reo and CA (simple form of CASM). Regarding to this merit of Reo and our previous work [28], in this paper our goal is to build up a unified formalism for both choreography and orchestration, and use it for automatic analysis of confor- mance in choreography and orchestration. We present a slightly modified version
of CASM, CASMch customized to accommodate WS-CDL concepts for modeling choreographies. By translating each WS-CDL component to Reo and its correspond-
ing CASMch, the operational semantics of the choreography is obtained in terms of
CASMchcompositionally. Then, we define end-point projection on CASMch which results in the behavior of a given party in a choreography in the form of CASM. Then we present the simulation relation in CASM and use it for conformance analysis of choreography and orchestration.
The structure of this paper is as follows: Section 2 contains a brief description of Reo and CASM. An overview of WS-CDL and our proposed model for WS- CDL components are provided in Section 3. The theory of addressing the end- point projection and the conformance problems are presented in Section 4, while its practical example appears in Section 5. Finally, the previous related works and our conclusions can be found in Sections 6 and 7, respectively.

Overview of Reo and Constraint Automata with State Memory
Reo is an exogenous coordination language based on a calculus of channels [5]. Components in Reo are connected via connectors which coordinate their activities. Primitive connectors are channels which have two ends. There are two types of chan- nel ends: source and sink. A source channel end accepts data into its channel, and a sink channel end dispenses data out of its channel. The channel can be defined by users which allows an open-ended set of different channel types, each with its own policy for synchronization, buffering, ordering, computation, data retention/loss, etc. However, some basic types of channels, used in this paper are: Synchronous Channel (Sync), Synchronous Drain (SyncDrain), and Lossy Synchronous Channel (LossySync). Complex connectors are constructed through composition of simpler ones by applying join operation. Whereas, the internal behavior of complex con- nectors can be abstracted away by applying the hide operation. A component can write a data items to a source node that it is connected to. The write operation succeeds only if all source channel ends coincident on the node accept the data item, in which case the data item is written to every source end coincident on the node. A source node, thus, acts as a replicator. A component can obtain data items, by an input operation, from a sink node that it is connected to. A take operation succeeds only if at least one of the sink channel ends coincident on the node offers a data item; if more than one coincident channel end offers data items, one is se- lected nondeterministically. A mixed node nondeterministically selects and takes a suitable data item offered by one of its coincident sink channel ends and replicates it into all of its coincident source channel ends. A sink or mixed node, thus, acts as a nondeterministic merger.
Constraint automata (CA) [8] are proposed as compositional semantics for Reo, based on timed data streams [7]. Each element of a timed data stream is a pair of time and a data item, where the time indicates when the data item is being input or output. A transition fires if it observes data item in a port of the component and according to the observed data, the automaton may change its state. There- fore, the automata-states stand for the possible configurations, while the automata- transitions represent the possible data flow and its effect on these configurations.
Definition 2.1 (Constraint Automata). A constraint automaton is a tuple A = (Q, N ames, −→, Q0) where [8]:
Q is a finite set of states, N ames is a finite set of names (e.g. I/O ports of a component), −→ is a finite subset of Q × 2Names × DC × Q, called the transition relation of A, and Q0 ⊆ Q is the set of initial states. DC is data constraint that plays the role of guard for transition. For example, d A = d B is a data constraint that imposes the observed data on ports A and B must be equal.
The join operator in Reo, is implemented by the product operation in CA and defined as following:
Definition 2.2 (Product Automaton).  The product-automaton of the two con-




Fig. 1. Some basic Reo channels, merger node, X-Router-2 Reo connector, and their corresponding CA
straint automata A1 = (Q1, N ames1, −→1, Q0,1) and A2 = (Q2, N ames2, −→2
, Q0,2), is [8]:
A1 da A2 = (Q1 × Q2, N ames1 ∪N ames2, −→, Q0,1 × Q0,2) where −→ is defined by the following rules:


q N1,g1
N2,g2
N,g

1 −→ 1p1,  q2 −→ 2p2,  N1∩Names2=N2∩Names1

and q1−→1p1,  N∩Names2=∅

N1∪N2,g1∧g2
⟨q ,q
N,g
p ,q ⟩

⟨q1,q2⟩−−−−−−−−−→⟨p1,p2⟩
and latter’s symmetric rule. 
1 2⟩−→⟨ 1 2

Fig. 1 shows the the Reo channels which we used in this paper, a merger node, and a Reo connector which selects one of its two active outputs non-deterministically and thus, is called X-Router-2 as well as their corresponding constraint automata. Another operation in CA, the hide operation [8], which corresponds to the hide operation in Reo, enables us to abstract away from internal nodes of a Reo circuit.
Ordinary CA are suitable for modeling only data-abstract coordination mecha- nisms. In many applications, the data-abstract view is too coarse and we need to reason about the values hold in each component in its different states. Constraint Automata with State Memory (CASM) are variant form of CA which enable us to model different states of each component along with the value of the states. The CASM used in this paper are a slightly simplified form of the CASM presented in [6].
Definition 2.3 (Constraint Automata with State Memory (CASM)). A constraint automaton with state memory is a tuple A = (Q, N ames, −→, Q0, M, V0) where:
Q, N ames, −→, and Q0 are defined the same as ordinary CA.
M is a set of memory cells partitioned into (not necessarily disjoint) memory cells Mq, for all q ∈ Q. For m ∈ M, q.m is used to uniquely identify the memory cells of the state q ∈ Q.
For every q ∈ Q the value function Vq : Mq → Data is defined when the automa- ton is in state q. The set V0 consists of the initial value function Vq0 , each of which gives the initial values of its corresponding initial state q0 ∈ Q0.

The data constraint language is extended to include relativized memory cell names
s.m and t.m, for m ∈M as well as the usual d n for node names n ∈ N ames such

that for each transition q N,g
p the free variables of g are in the set {s.m|m ∈

Mq}∪ {t.m|m ∈ Mp}∪ {d n|n ∈ N ames}. The special symbols s and t refer to the source and target states of a transition respectively.
Given the data assignment δN : N → Data and the value function Vq : Mq →
Data, a transition q −→ p is possible if there exists a value function Vp : Mp → Data such that g[q/s, p/t] is true under the mappings δN , Vp, and Vq. Traversing the transition, makes Vp the value function for memory cells Mp of state p.
The product of two CASM that does not share common memory cells is defined similar to the product of two ordinary CA with two additional points as:
For each state ⟨q1, q2⟩ resulted from the product, M⟨q1,q2⟩ = Mq1 ∪ Mq2 for all
q1 ∈ Q1 and q2 ∈ Q2.
The set V0 consists of the value function V⟨q1,q2⟩ : M⟨q1,q2⟩ → Data, for q1 ∈ Q0,1
and q2 ∈ Q0,2, defined using Vq1 ∈ Vq0,1 and Vq2 ∈ Vq0,2 as:
V⟨q1,q2⟩(m) is Vq1 (m) if m ∈ M1, and if m ∈ M2 it will be Vq2 (m).
Overview and Formal Modeling of WS-CDL
The primary goal of the WS-CDL specification is to specify a declarative, XML- based language that defines from a global viewpoint the common and complemen- tary observable behavior of participants, specifically the information exchanges that occur and the jointly agreed ordering rules that need to be satisfied. WS-CDL de- scribes interoperable, peer-to-peer collaborations between participants without as- suming single point of control. As mentioned before, WS-CDL is a description and not an executable language. Each participant, adhering to a WS-CDL collaboration representation, could be implemented using completely different mechanisms such as executable business process languages, e.g. BPEL, programming languages, e.g. C#, or human controlled software agents. In order to use WS-CDL for design time or static validation and verification of choreographies and conformance validation it must be based on or related to a formal language. In this section, first we define
CASMch, a variant form of CASM customized for modeling choreographies, and afterwards we go through modeling each constituent part of WS-CDL by Reo and
CASMch.

Constraint Automata with State Memory for Choreography
A choreography can be recognized as a container for a collection of activities that may be performed by the participants. In our model, each participant is considered as a Reo component. In order to make the CASM proper for modeling activities, we impose a convention on its name set to include two parts: component name and port name instead of just one part, port name. On the other hand, in WS-CDL, variables which are used for holding information and values of states are uniquely identified

by the participants they belong to. As we model variables by a Reo component with one memory cell for holding its value, the name of the memory cells and the variable component are specified by two parts: component name and variable name in which the component name stands for the participant name the variable belongs to. Each part is separated from the other parts by ”.”.
Definition 3.1 (Constraint Automata with State Memory for Choreography (CASMch)).  A CASMch is a tuple Ach = (Qch, N amesch, →ch, Qch, Mch, Vch)
0	0
in which:
Qch, Qch, →ch, and Vch are defined the same as states, initial states, transition
0	0
relation, and initial value function in ordinary CASM.
Each n ∈ N amesch, is a tuple (component name, port name).
Each m ∈ Mch is a tuple (component name, variable name).
The definition for the product of two CASMch is the same as for ordinary CASM by taking into account that during product stages two names or memory cells will match iff all of their constituent parts are equal.
Formalizing WS-CDL
Formally, a complete WS-CDL model is described by a set of choreographies. A WS-CDL choreography description is essentially a container for a collection of ac- tivities that may be performed by one or more of the participants and consists of three parts: choreography life-line, choreography exception blocks and chore- ography finalizer blocks. The choreography life-line expresses the progression of a collaboration through enabled activities and enclosed choreographies. Activities describe the actions performed within a choreography. The basic building block of a choreography is the interaction activity which results in an exchange of informa- tion between participants while the control-flow among activities is described by ordering structures activities.
We model each WS-CDL model as a Reo circuit. In our model, the WS-CDL participants are represented as Reo black-box components in the Reo circuit of WS- CDL. Instead of having a ”process view” to the choreography, we extract and visual- ize the communication (interaction activities) and coordination (ordering structures activities) among the participants. All the data (variables) used for control decisions are extracted and shown in the coordination Reo circuit in between the participants. This Reo circuit can now be considered to be exogenously coordinating the partic-
ipants. Each part of WS-CDL which is modeled by a Reo component obeys from a consistent pattern that contains input port Start and output ports Ex (for ex- ception throwing) and End. In the following, we present our modeling of WS-CDL
with more details.

RoleType, relationshipType and participantType
Within WS-CDL, a participantType groups together those parts of the observable behavior of a participant that must be implemented by the same logical entity

or abstract organization. A roleType enumerates potential observable behavior a participantType can exhibit in order to interact. A relationshipType identifies the mutual commitments that must be made for collaborations to be successful. In our model, participantTypes can be considered as components in a Reo circuit, a roleType is a group of ports which implements its observable behaviors (each behavior can be implemented by a port in components) and the relationship type will be the connections in Reo circuit which determine which components can interact with each other.

InformationType and variable
A variable contains information about commonly observable objects in a collabo- ration, such as the information exchanged or the observable information of the ro- leTypes involved which have informationTypes that define the type of information the variable contains. In our mapping, variables are modeled as a Reo component
with one memory cell in its CASMch which is shown in Fig. A.1.a of Appendix.

Choreography
A choreography defines collaborations between interacting participantTypes. The choreography life-line expresses the progression of a collaboration. An exception block specifies what additional actions should occur when a choreography behaves in an abnormal way. A ﬁnalizer block specifies additional actions that should occur to modify the effect of an earlier successfully completed choreography, for example to confirm or undo the effect. In our model, the behavior of the Reo circuit as a whole describes the choreography. The ports Start, End and Ex are derived for the whole choreography life-line from each activity within it. As shown in Fig. A.1.b of Appendix the End and Ex output ports are connected to the Start input port of finalizer and exception blocks respectively to enable them.

ChannelType
A channel realizes a point of collaboration between participantTypes by specifying where and how information is exchanged. Within WS-CDL, channels are abstractly modeled as channelTypes. As channels in WS-CDL may be one-way or two-way, and in Reo each channel can only have two ends, we modeled each WS-CDL one-way channel by a Sync channel in Reo and the WS-CDL two-way channel is modeled by combining two one-way channels.

Activities and ordering structures
Activities describe the actions performed within a choreography. Ordering struc- tures combine activities with other ordering structures in a nested structure to ex- press the ordering rules of actions performed within a choreography. In our model, each basic activity is modeled by a component whose behavior is specified by a CASMch. The ordering structures of activities (control flow activities) are mod- eled and visualized by Reo circuits coordinating the activities.

Basic Activities
Interaction activity is the basic building block of a choreography. It results in an exchange of information between participants and possible synchronization of their observable information changes. Each interaction is composed of: (i) the participant roles involved; (ii) the information exchange type and the cor- responding direction(s) which is described by the channels; (iii) the observable information changes. Like channel type, an interaction can be one-way (request or response) or two-way (request-response). The WS-CDL code of an example of one-way interaction in which through channel ”ch” role X sends its request whose content is in variable ”a” to the role Y and Y saves the received request message in its variable ”b” is presented in the following:
<interaction name="sendRequest" channelVariable="ch"> <participate ...
"fromRoleTypeRef="X" toRoleTypeRef="Y"/>
<exchange name="Request_a" ... action="request">
<send variable="cdl:getVariable(’a’,’’,’’)"/>
<receive variable="cdl:getVariable(’b’,’’,’’)"/>
</exchange>
</interaction>

Its corresponding Reo is illustrated in Fig. A.1.c of Appendix. It must be noted that in a Reo component that is representative of a WS-CDL participant, each port must be uniquely identified by the information exchanged and the WS-CDL channel name through which the information is exchanged. This convention is
used in the CASMch shown in Fig. A.1.c of Appendix, e.g. X.send(a)ch. For two-way interaction via channel ”ch”, as shown in Fig. A.1.d of Appendix, two one-way channels are composed and the resulted Reo circuit is identified by ”ch” as its name. In this figure, we abstracted away from the variables in each role and the internal view of each one-way interaction (shown as components). The
resulted circuit as a whole is a component whose behavior is shown by CASMch in the Fig. A.1.d of Appendix. The Start, End and Ex ports are constructed from the two one-way components similar to the manner constructed from the two variables in the Fig. A.1.c of Appendix (in these figures, In1 and In2 stand for one-way and two-way interaction Reo components respectively).
Assign activity assigns the value of one variable or expression to another variable within one roleType. For example, the assignment of variable a to variable a' of role X is depicted in Fig. A.1.e of Appendix.
Workunit describes the conditional and, possibly, repeated execution of an ac- tivity. Syntactically, a Workunit activity has several parts, including a reference to the enclosed activity, a guard (G ), a block condition (block ), and a repetition condition (!R). While G and !R conditions direct the repetition of the execution, the block condition determines whether to wait for G to become true or not. The modeling of non-blocking workunit (block = ”false”) is shown in Fig. A.1.f of Appendix. For the blocking workunit the model is similar.

Ordering Structures
Ordering structures combine activities with other ordering structures in a nested structure to express the ordering rules of actions performed within a choreography. There are three types of ordering structures: Sequence, Parallel, and Choice. As illustrated in Fig. A.2 of Appendix, the Sequence is modeled by a Reo circuit, Sequencer-n, which enables its n connected components sequentially, the parallel execution of activities is handled by replicator node in Reo, and X-Router-n which is a Reo circuit that selects one active component among n connected components non-deterministically, is used for Choice.

End-Point Projection and Conformance Test
In order to investigate the conformance of a given party or orchestration to a chore- ography, end-point projection must be performed. In this operation, the desired behavior of a party (end-point process) is extracted from a choreography (global description). In our approach, each choreography can be modeled by a Reo circuit. In order to extract the behavioral interface of a choreography with respect to a certain participant, we shall hide all the nodes in the Reo circuit except the nodes of the desired component. Accordingly, the external behavior of a component can be extracted from the CA of a Reo circuit by applying the hide operation defined for CA. Therefore, as an advantage of our approach, we can use the already defined operator in our formal model, the hide operator, for end-point projection. After end-point projection, the conformance problem is reduced to comparison of the behavior of the given party (implementation) with the specification extracted by end-point projection. Again, the simulation relation defined for CA can be a satis- factory definition in this regard. Although, in comparison to CA, some changes in
the definition of simulation relation and hide operator in CASM and CASMch are needed.

End-point projection
In our approach, the behavior of each choreography is obtained in the form of CASMch compositionally and the end-point projection can be implemented by the hide operation. So, we inspire from the hide operation for ordinary CA in [8] and
define a new hide operation which is proper for CASMch. Before end-point projec- tion, we assume that the examined choreography models are locally implementable according to the criteria mentioned in [25] which can be summarized as: 1) in a sequence, initiators (the participants which initiate the global activity) of the fol- lowing activity must act as terminators (the participants which conclude the global activity) of the preceding activity, 2) in non-deterministic or conditional choice, each selective branch should have an identical initiator, and 3) in a workunit which has b as its loop condition each initiator of the enclosed activity has a corresponding loop condition embedded in b.

Definition 4.1 End-point Projection.  The end-point projection is a function π : CASMch × Participant → CASM where if A = (Q, N ames, →, Q0, M, V0) is a CASMch and P is the component name part of at least one n ∈ N ames, then the end-point projection of A on participant P is defined as π(A,P ) = (Qπ(P ), N amesπ(P ), →π(P ), Q0,π(P ), Mπ(P ), V0,π(P )) where:
N amesπ(P ) and Mπ(P ) stand for the projection of name set and memory cells on P . In other words, they consist of the set of names and memory cells whose component name part is P and the component name part are removed from their representations.
Qπ(P ) is equal to the set of states Q, except that the value function of each q ∈ Qπ(P ) is defined as Vq,π(P ) : Mq,π(P ) → Data in which Mq,π(P ) stands for the projection of memory cells Mq on participant P .
For definition of the initial state, let →∗ be a transition relation such that p →∗ q
iff there exists a finite path (∼ P denotes the names whose component name part

are not P ) p ∼P,g1 q
∼P,g2 q ... ∼P,gn q
Where q
= q, g ,g , ..., g
are satisfiable,

−→	1 −→	2
−→	n
n	1	2	n

and the component name part of the memory cells used in each (m, d) ∈ Vqi, i ∈
{1, .., n} is not P , then the set of initial states will be:
Q0,π(P ) = {pπ(P )|p ∈ Q, q0 →∗ p for some q0 ∈ Q0}
The transition relation →π(P ) is given by:


p →∗ q, q N,g
r, Nπ(P )
/= φ ∨ Vr,π(P )
/= φ

pπ(P )
Nπ(P ),gπ(P )
−−−−−−−→π(P )
rπ(P )

in which gπ(P ) is the projection of data constraint g on P which is obtained by removing the data constraints whose component name parts are other than P and replacing them with true or false.

Conformance analysis
According to [28] each orchestration described by BPEL can be specified by a Reo circuit and its corresponding CA. In our Reo circuit extracted from a BPEL code, we can also hide the internal behavior and only keep the observable behavior (abstract BPEL process). Since each CA can be considered as a special case of CASM, we can have the behavior of each orchestration in the form of a CASM. Thanks to this unified formalism, after end-point projection, the conformance problem is reduced to the examination of the CASM obtained by end-point projection and the CASM of the orchestration.
Intuitively, conformance is the capability of a web service to interact with the other peers according to a choreography. A web service will be conformant to a choreography if it complies to the choreography in all possible interactions [17]. This intuitive definition is not directly usable for automatic verification as there is no unique formal definition for conformance. Therefore, the relationships between choreography and behavioral interface (called abstract process in WS-BPEL) of

web services may be non-trivial, and there are currently no precise notions of con- formance between WS-CDL choreographies and WS-BPEL abstract processes [10]. Understanding these relations is considered as an open problem in [10]. Different works assume different criteria for the conformance and formalize it according to their domain of usage. These criteria are generated by focusing on different aspects of behaviors of web services. Most of the works consider inclusion or equivalence re- lation between the set of possible actions of an orchestration and what is desired by the choreography, some works distinguish between incoming and outgoing messages, and some take into account the termination patterns and/or causal relationship be- tween messages.
The work in [9] uses automata for modeling choreographies and formalizes the conformance regarding to three criteria: first, it guarantees that the service, at any point of its conversations, can only send messages which are legal w.r.t. the global interaction protocol. Moreover it guarantees that the service will be able to handle any incoming message, foreseen by the protocol, and finally, it guarantees that the service will always send at least one of the messages foreseen by the protocol, although it is not necessary that its policy envisions all the possible alternatives (e.g. the designer can restrict the set of the possible answers). In [24] the conformance is defined by process refinement. A process P is a refinement of process Q, if P cannot perform an infinite sequence of internal actions and also whichever observable action that process P can do is prescribed by process Q, whereas the internal actions do not count. Given a locally implementable choreography A and an orchestration P which acts as a participant ρ, it assumes P is conformant to A if and only if P is a process refinement of the process resulted by end-point projection of A on ρ. In [11] the criteria for checking the conformance of web service contracts and business processes are defined as: 1) all incoming messages specified in contract must be handled by the business process and vice versa, 2) the business process must handle all outgoing messages specified in its contract and the service contract must handle all outgoing events in business process, 3) the causal relationships between incoming and outgoing messages must be maintained when generating business process from service contract and vice versa, and 4) the service contract must reflect all acceptable termination states of a business process and vice versa. Similarly, the termination patterns in both business processes and service contracts must match. The authors in [17] assume a web service is compliant if all the interactions it can possibly generate belong to the choreography specification. Similar definition can be seen in [13] in which it is assumed that it is not necessary for an implementation to include all possible conversations admitted by a choreography but all possible conversations in an implementation must be admitted by the choreography.
In CA, the input and output actions and also termination and deadlock states are not distinguished. On the other hand, as mentioned before, we abstract away from internal actions of a web service by hide operation and use abstract BPEL processes. After hiding, we have no information about the internal actions of web services and the casual relationship between messages. In our conformance definition, we assume a web service conforms to a choreography if every action allowed by the web service is

also allowed by the behavioral interfaces extracted from choreography by end-point projection, i.e. an orchestration that performs actions which are not foreseen and desired by the choreography, may disturb the communication of web services. Hence, there should be no action in the web service that is not foreseen by the choreography. This is obtained when in each state all possible actions of the web service (all possible transitions in the CASM that can be traversed) are a subset of the possible actions desired by the choreography. In other words, conformance is obtained when the satisfaction of the data constraints in each transition in each state of the web service implies the satisfaction of the data constraint of the corresponding transition in the CASM of the behavioral interface. This examination can be implemented by utilizing the predefined concept in ordinary CA [8], the simulation relation. But here, we need to customize the simulation definition of ordinary CA with respect to the notions in CASM. In the following, we define the simulation relation in CASM and show how to exploit that for conformance validation.



Definition 4.2 Simulation Relation in CASM. Given two CASM A1 = (Q1, N ames, →1, Q0,1, M1, V0,1) and A2 = (Q2, N ames, →2, Q0,2, M2, V0,2):
The binary relation R ⊆ Q1 × Q2 is a simulation between A1 and A2 if and only if for all q1 ∈ Q1 and q2 ∈ Q2, if (q1, q2) ∈ R, then the following conditions hold:
Vq2 ⊆ Vq1 .
for each pair of states (q1, p1) ∈→1 and every n ⊆ N ames, there exists a pair (q2, p2) ∈→2 such that: dc(q1, n, p1) ≤ dc(q2, n, p2) and (p1, p2) ∈ R.
Where dc(q, n, p) denotes the data constraint of a transition from state q to state p with the name set n as defined in [8] and the ≤ relation means that satisfaction of the left hand side constraint implies the satisfaction of the right hand side constraint. It must be noted that if there is no transition
from state q to state p with the name set n, then dc(q, n, p) = false. A state q1 is simulated by another state q2 (i.e., q2 simulates q1), denoted as q1 ≤ q2, iff there exists a simulation R with (q1, q2) ∈ R.
We say that A2 simulates A1 (denoted as A1 ≤ A2), iff M2 ⊆ M1 and every initial state of A1 is simulated by an initial state of A2.
Similar to the simulation relation in ordinary CA, we rely on the same set of names for both automata which corresponds to the I/O ports of Reo components. This is desirable for us, because existence of extra ports for the orchestration may disturb the interoperability of participants.


Definition 4.3 Conformance. An orchestration whose external behavior is defined by a CASM Aorch, is conformant to a choreography with CASMchAch, for playing the role of participant P , if the π(Ach,P ) simulates Aorch or Aorch ≤ π(Ach,P ).

Case Study: The Bartering Protocol
Now as an example, we consider bartering protocol used in [4,25] with some changes. In this system, the buyer repeatedly asks for a quote from seller until he agrees with the quote and places an order. For this purpose, a workunit is used in which there is a condition that governs the repetition, namely barteringDone = false and accept = false. For the sake of simplicity, instead of its WS-CDL code, its pseudo-code is shown in the following (a@R means variable a of Role R [4]):
Boolean barteringDone@Seller = false Boolean accept@Buyer = false
Elicit a quote from the seller
while (barteringDone@Seller == false and accept@Buyer == false) do
{
choice
{

{



}
{
}
}
} done
Accept the quote accept@Buyer = true Place the order
barteringDone@Seller = true

Reject the quote and ask for a new quote

The Reo circuit and CASMch of this system is shown in Fig. 2. In this figure, we abstract away from exception signals as there is no exception thrown in the example. The name of each component in the Reo circuit is the representative of the interaction performed within it. In addition, in each one of them some proper
variable assignments are also performed as shown in the CASMch. That is the advantage of Reo that enables us to encapsulate multiple activities in a component during visualization, while the details can be remained in its operational semantics
for accurate analysis. In this CASMch, B and S stand for ”Buyer” and ”Seller” participants respectively. The additional point is that as we abstract away from variables, for the sake of simplicity, the input port G of the workunit is not shown as its values come from the variables in the participants (note that we don’t have
!R condition in the workunit).
In order to show the applicability of our proposed end-point projection and con- formance analysis, consider a web service (orchestration) whose behavior is shown in Fig. 3. Our goal is to investigate whether it conforms to the bartering protocol for playing the role of participant ”Buyer” or not.
The first step is to achieve the desired behavior of the ”Buyer” by end-point projection which is shown in Fig. 4. The next step is the examination of confor- mance. As shown in Fig. 3, the automaton of the orchestration is similar to the automaton of Fig. 4; the only difference can be observed in states 5 and 5’ where the decision for acceptance or rejection of the quote in the orchestration depends on the quote value (quote < 100 or quote ≥ 100) instead of non-deterministic se- lection. In these states, we have dc(5', accept.Write, 6') ≤ dc(5, accept.Write, 6),
dc(5', send.(qupd)cu, 7') ≤ dc(5, send(qupd)cu, 7), and V5 ⊆ V5' . In addition, we
have {(6', 6), (7', 7)} ⊂ R. Therefore, according to Definition 4.2, the orchestra-




Fig. 2. The Reo circuit and CASMch of the bartering protocol


Fig. 3. The CASM of the ”Buyer” web service


tion conforms to the protocol as its initial state is simulated by the initial state of the automaton resulted from end-point projection, using the simulation relation R = {(1', 1), (2', 2), (3', 3), (4', 4), (5', 5), (6', 6), (7', 7), (8', 8), (9', 9)}.




Fig. 4. The end-point projection of the bartering protocol on the ”Buyer” participant

Related Work
The works on formal specifications of choreographies and specially WS-CDL, aims towards addressing some important challenges as: (1) design time or static vali- dation and verification of choreographies; (2) automatic generation of local imple- mentations from a given global model (interaction protocol); (3) verification of the conformance of a given process behavior to a general interaction protocol
Busi et al [15] design a simple choreography language CL whose main concepts are based on WS-CDL. This language covers a few constructs, nevertheless it offers a starting point for the design and analysis of choreography. Gorrieri and others [21] give a deep analysis of interaction patterns in the WS-CDL specification by taking into account the alignment property, whose meaning is related to the possibility to control when the interaction completes. The work in [29] proposes a small language, CDL, and its operational semantics as a formal model of simplified WS-CDL. Veri- fication of some properties are also presented in a choreography sample using SPIN model-checker. A more complete work on formal specification of WS-CDL can be found in [24] in which the semantics of WS-CDL is presented in terms of process algebra CSP.
Among the works on projection and conformance analysis, Busi et al. [14,16] for- malize choreography and orchestration using process algebra, where conformance takes the form of a bisimulation-like relation. By means of automaton, the work in
[9] defines a conformance notion which tests whether interoperability is guaranteed. In [20] a conversation protocol is specified by a realizable Bu¨chi automaton, and the peer implementations are synthesized from the protocol via projection. Zhao et al. [30] propose a small language as a formal model of the simplified WS-CDL and projected a given choreography to orchestration views. In [19] the authors use Petri nets for describing orchestration, choreography and service interface behavior focusing on the relationship between a single orchestrator with respect to a given choreography. The work in [25] introduces two languages for describing choreogra- phy and orchestration and based on them gives a definition of endpoint projection. The interesting point with this paper is formalizing three conditions that need to be satisfied so that a global model can be locally implementable. The authors in [27] use Reo and CA to investigate the issues of description, orchestration, and choreog-

raphy of web services at a unifying abstract level. In this work, only limited notions of WS-CDL are studied and modeled. Moreover, the conformance and projection issues are not addressed.
The advantages of our work to these works are integrating the following issues:
(1) taking into account a specific choreography language which makes our work more useful in practice; (2) covering almost all of the important notions in WS-CDL such as activities, channels, exception handling, finalizer blocks, etc.; (3) using Reo for visualizing models in different abstract levels and also hierarchical composition. As Reo is proposed as a coordination language for coordination of concurrent compo- nents, its computational model inherently fits for coordination and communication of web services as self contained components. Furthermore, in comparison to other formal languages, e.g. process algebra, which are just represented by mathematical relation, visual modeling of data flow among components in Reo makes the compre- hension of component interaction more intuitive. On the other hand, thanks to hide operation and consequently hierarchical composition in Reo, the connectors can be specified in any abstract level and so the modeling can be more comprehensive and better matched with its real configuration; (4) formalizing end-point projection and conformance issues. In other words, this work which is a complement of our previous work [28], in which we modeled BPEL language by Reo and CA, gives us a unified formalism which facilitates verification and validation of web service specification, implementation and conformance in a consistent manner.

Conclusion and Future Work
In this work, we formalize the choreography description language, WS-CDL, using Reo and CASM. By presenting a slightly modified version of CASM, CASMch, and translating each component of WS-CDL to its corresponding Reo and CASMch, the behavior of a choreography will be obtained in the form of CASMch. We define
the end-point projection operator on CASMch whose outcome is in the form of CASM. Regarding to our previous work in which the BPEL orchestration language is modeled by Reo and CA (the simplified form of CASM), both of the orchestration and end-point projected choreography can be presented with a unified formalism through which conformance problem is resolved by defining the simulation relation. The practical application of our work is illustrated in a bartering protocol.
In future, we are intended to work on the different aspects of conformance prob- lem such as situations that make a choreography, specified in terms of Reo and
CASMch, locally implementable. In our proposed model for WS-CDL, all of the decisions that control the flow of events are extracted and visualized by the Reo cir- cuit in between participants, i.e., the coordination is performed exogenously. This can facilitate discovering the choreographies that are not locally implementable. Additionally, developing a tool which automates the translation from WS-CDL to
Reo and CASMchand conformance analysis constitutes our future plans. This tool must be integrated with the tools that translate WS-BPEL to Reo [26], Reo to CA, and CA verification tool [23]. Our work can also be extended to analyze the power

and weakness of WS-CDL as a choreography description language and, if needed, adding proper concepts to WS-CDL, Reo, and CASMch to make them more suit-
able for choreography description and modeling. This can be done in conjunction with property specification and analysis of choreographies.

References
Business Process Modeling Language BPML (2002), http://www.bpmi.org.
Web services choreography requirements, W3C Working Draft (2004).
Web services choreography description language version 1.0, W3C Candidate Recommendation (2005),
http://www.w3.org/TR/ws-cdl-10/.
Web services choreography description language: Primer, W3C Working Draft (2006).
Arbab, F., Reo: A channel-based coordination model for component composition, Mathematical Structures in Computer Science 14 (2004), pp. 329–366.
Arbab, F., Constraint automata with state memory, Unpublished notes (2007), CWI.
Arbab, F. and J. Rutten, A coinductive calculus of component connectors, in: M. Wirsing, D. Pattinson and R. Hennicker, editors, Recent Trends in Algebraic Development Techniques, Proceedings of 16th International Workshop on Algebraic Development Techniques (WADT 2002), Lecture Notes in Computer Science 2755, 2003, pp. 35–56, http://www.cwi.nl/ftp/CWIreports/SEN/SEN-R0216.pdf.
Baier, C., M. Sirjani, F. Arbab and J. Rutten, Modeling component connectors in Reo by constraint automata, Science of Computer Programming 61 (2006), pp. 75–113.
Baldoni, M., C. Baroglio, A. Martelli, V. Patti and C. Schifanella, Verifying the conformance of web services to global interaction protocols: A first step, in: Bravetti et al. [12], pp. 257–271.
Barros, A., M. Dumas and P. Oaks, A critical overview of web service choreography description language(WS-CDL) (2005), BPTrends.
Bhuiyan, J., S. Nepal and J. Zic, Checking conformance between business processes and web service contract in service oriented applications, in: ASWEC ’06: Proceedings of the Australian Software Engineering Conference (2006), pp. 80–89.
Bravetti, M., L. Kloul and G. Zavattaro, editors, “Formal Techniques for Computer Systems and Business Processes, European Performance Engineering Workshop, EPEW 2005 and International Workshop on Web Services and Formal Methods, WS-FM 2005, Versailles, France, September 1-3, 2005, Proceedings,” Lecture Notes in Computer Science 3670, Springer, 2005.
Bravetti, M. and G. Zavattaro, Towards a unifying theory for choreography conformance and contract compliance, in: Proceeding of Software Composition 2007, LNCS 4829 (2007), pp. 34–50.
Busi, N., R. Gorrieri, C. Guidi, R. Lucchi and G. Zavattaro, Choreography and orchestration: A synergic approach for system design, in: B. Benatallah, F. Casati and P. Traverso, editors, ICSOC, Lecture Notes in Computer Science 3826 (2005), pp. 228–240.
Busi, N., R. Gorrieri, C. Guidi, R. Lucchi and G. Zavattaro, Towards a formal framework for choreography, in: WETICE ’05: Proceedings of the 14th IEEE International Workshops on Enabling Technologies: Infrastructure for Collaborative Enterprise (2005), pp. 107–112.
Busi, N., R. Gorrieri, C. Guidi, R. Lucchi and G. Zavattaro, Choreography and orchestration conformance for system design, in: P. Ciancarini and H. Wiklicky, editors, COORDINATION, Lecture Notes in Computer Science 4038 (2006), pp. 63–81.
Chesani, F., P. Mello, M. Montali, M. Alberti, M. Gavanelli, E. Lamma and S. Storari, Abduction for specifying and verifying web service and choreographies, in: 4th International Workshop on AI for Service Composition, Trento, Italy, 2006.
Diakov, N. and F. Arbab, Compositional construction of web services using Reo, in: Proceedings of International Workshop on Web Services: Modeling, Architecture and Infrastructure, 2004, pp. 49–58.
Dijkman, R. and M. Dumas, Service-oriented design: A multi-viewpoint approach, International Journal of Cooperative Information Systems 13 (2004), pp. 337–378.

Fu, X., T. Bultan and J. Su, Conversation protocols: a formalism for specification and verification of reactive electronic services, Theor. Comput. Sci. 328 (2004), pp. 19–37.
Gorrieri, R., C. Guidi and R. Lucchi, Reasoning about interaction patterns in choreography, in: Bravetti et al. [12], pp. 333–348.
Jordan, D. and J. Evdemon, Web Services Business Process Execution Language Version 2.0 (2006).
Klu¨ppelholz, S. and C. Baier, Symbolic model checking for channel-based component connectors, in:
FOCLASA’06, 2006.
Li, J., J. He, H. Zhu and G. Pu, Modeling and verifying web services choreography using process algebra, in: Software Engineering Workshop, 2007. SEW 2007. 31st IEEE, 2007, pp. 256–268.
Li, J., H. Zhu and G. Pu, Conformance validation between choreography and orchestration, in: TASE ’07: Proceedings of the First Joint IEEE/IFIP Symposium on Theoretical Aspects of Software Engineering (2007), pp. 473–482.
Mahdikhani, F., BPEL to Reo tool (2007), http://ece.ut.ac.ir/msirjani/B2ReoTool/B2R.jar.
Meng, S. and F. Arbab, Web services choreography and orchestration in Reo and constraint automata, in: Proceedings of 22nd Annual ACM Symposium on Applied Computing(SAC’07), 2007.
Tasharofi, S., M. Vakilian, R. Zilouchian and M. Sirjani, Modeling web service interactions using the coordination language Reo, in: Proceeding of 4th International Workshop on Web Services and Formal Methods (WS-FM 2007), LNCS 4937 (2008), pp. 108–123.
Yang, H., X. Zhao, Z. Qiu, G. Pu and S. Wang, A formal model for web service choreography description language (ws-cdl), in: ICWS ’06: Proceedings of the IEEE International Conference on Web Services (2006), pp. 893–894.
Zhao, X., H. Yang and Z. Qiu, Towards the formal model and verification of web service choreography description language, in: M. Bravetti, M. Nu´n˜ez and G. Zavattaro, editors, WS-FM, Lecture Notes in Computer Science 4184 (2006), pp. 273–287.

A	Modeling of WS-CDL components by Reo and
CASMch

Fig. A.1. Modeling of variable, choreography, and basic activities













Fig. A.2. Modeling of ordering structures
