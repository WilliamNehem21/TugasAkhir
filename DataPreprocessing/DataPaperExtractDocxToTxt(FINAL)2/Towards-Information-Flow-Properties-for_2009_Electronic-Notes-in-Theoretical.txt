

Electronic Notes in Theoretical Computer Science 236 (2009) 65–84
www.elsevier.com/locate/entcs

Towards Information Flow Properties for Distributed Systems 
Roberto Gorrieria,1 Fabio Martinellib,2 Ilaria Matteuccib,c,3
a Universit`a di Bologna, Bologna, Italy
b Istituto di Informatica e Telematica - C.N.R., Pisa, Italy
c CREATE-NET, Trento, Italy

Abstract
In this paper we present a framework for the specification of information flow properties for distributed sys- tems. We consider partially specified distributed systems in which there are several unspecified components located in different places. As a case study, in this paper we consider the notion of Non Deducibility on Composition, NDC for short, originally proposed for nondeterministic systems and based on trace semantics. We study how this information flow property can be extended in order to deal also with distributed par- tially specified systems. In particular, we adapt the NDC property to distributed systems by distinguishing between two different approaches. The first one we call centralized NDC, according to which there is just one unspecified global component that has complete control of the n distributed locations where interaction occurs between the system and the unspecified component. The second one is called distributed NDC, according to which there is one unspecified component for each distributed location, and the n unspecified components are completely independent, i.e., they cannot coordinate or cooperate each other. Surprisingly enough, we prove that centralized NDC is as discriminating as decentralized NDC. However, when we move to Bisimulation-based Non-Deducibility on Composition, BNDC for short, the situation is completely dif- ferent. Indeed, we prove that centralized BNDC is strictly finer than decentralized BNDC, hence proving the quite expected fact that a system that can resist to coordinated attacks is also able to resist to simpler attacks performed by independent entities.
Keywords: information flow properties, nondeducibility, distributed systems, bisimulation, contexts


Introduction
Information flow analysis is considered one of the main techniques for studying confidentiality in computer systems. Information flow properties aim at defining the way the information may flow among different entities of a compound system. For instance, these properties may define constraints on the kind of information flow

٨ Work partially supported by CNR project “Trusted e-services for dynamic coalitions” and by EU-funded project “Software Engineering for Service-Oriented Overlay Computers” (SENSORIA) and by EU-funded project “CONSEQUENCE”.
1 Email: gorrieri@cs.unibo.it
2 Email: fabio.Martinelli@iit.cnr.it
3 Email: ilaria.matteucci@iit.cnr.it

1571-0661/© 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.03.015

that can be set among different groups of entities with different security levels (e.g., high and low). Usually, the goal is to prevent any possible flow from the confidential (high) level to the public (low ) one.
Several formalizations have been proposed in the literature to capture the intu- itive idea of flow of information. Most of them originate from the basic idea of Non Interference, NI for short, proposed in [12] on deterministic machines: Basically one wants that low output variables do not depend on high inputs. This intuitive notion has been then extended to trace based models. Assume there are two groups of users, G and G', and, given any input sequence of actions γ, let γ' be its subse- quence obtained by deleting all the actions of users in G. G is non interfering with G' if and only if for every input sequence γ, users in G' obtain the same outputs after the execution of γ and γ'.
This basic notion has been also adapted and generalized to the richer setting of nondeterministic and concurrent machines. Among the many definitions derived from NI (see e.g., [4,6,14,20]), here we consider the Non Deducibility on Composi- tion property (NDC, see [4]). Intuitively, a system is NDC if, by interacting with every possible high level user, it always appears the same to low level users, so that no information at all can be deduced by low level users. The above idea can be instantiated in a lot of ways, by choosing a particular way of interacting between systems and various criteria of equivalence. First we consider trace equivalence: A system E is NDC if E \ H (i.e., E where all high level actions are prevented) is trace equivalent to E in parallel with any high level process Π where all the high actions in H are restricted (hence cooperation on high actions is forced). In other words, the low view of the behavior of system E is not modified by the presence of process Π, that can be considered as an intruder that tries to break the system. Observe that this definition is given by considering at most one possible intruder (high user).
We can obtain a bisimulation based NDC by simply substituting the trace equiv- alence with bisimulation equivalence. We consider the notion of Bisimulation Non Deducibility on Compositions, BNDC for short, was proposed in [4,6]. Also in this case the definition is given by considering at most one possible high user.
The goal of this work is to extend the idea of NDC and BNDC also to dis- tributed systems, where the possible intruders can be more than one and may also coordinate their efforts. A distributed system is modelled as a transducer [13], i.e., a context which can receive in input, say, n actions in different locations and which may produce a tuple of outputs. Intuitively, a context of the form C(X1,..., Xn) can be seen as a distributed partially speciﬁed system [15,16,17,8], i.e., a system C with holes, where the components X1 ... Xn are not specified. These unspecified components are meant to be the potential intruders of the system.
We want to study whether such contexts respect information flow properties, in particular those based on NDC and BNDC, whatever the possible intruders are. In both cases, we proceed by following two different approaches: A centralized approach and a decentralized one.
We first consider the NDC property. Given the context C(X1,..., Xn), where

each Xi denotes a hole in the system, we may define decentralized NDC (DNDC for short) as the NDC property where the n intruders act independently, without communicating or coordinating their activities. A system satisfying decentralided NDC should resist to distributed attacks conducted by n independent intruders. Then, we introduce the concept of centralized NDC (CNDC for short) in which the n intruders are centrally controlled and thus considered as a unique context which performs a vector of n actions, a˜ = (a1,..., an). A system satisfying CNDC should resist to distributed attacks conducted by n cooperating intruders (or by one single intruder that has complete control of the n locations in which interaction with the system is possible).
Interestingly enough we prove the quite surprising result that CNDC (i.e., trace- based Non-Deducibility on Composition) is as discriminating as DNDC.
For that reason we consider the BNDC property. Indeed, when trace semantics is replaced by the more discriminating bisimulation semantics, the results above are completely different.
As expected, centralized BNDC is proved to be finer than decentralized BNDC.
Still, the weaker notion is meaningful because, as a matter of fact, a system that is centralized BNDC is able to resist also to strongly coordinated attacks that, in a real-life distributed environment, might not be possible.  We provide a simple
counterexample showing that the reverse implication does not hold, i.e., a context which is decentralized BNDC, but not centralized BNDC.
This paper is organized as follows. Section 2 recalls some notions about context theory and introduces some idea behind the use of context for modelling distributed systems. Section 3 presents our framework for the specification of information flow properties in a distributed system. Section 4 shows a comparison with related work. In Section 5 we report the conclusion of the paper. Finally, in Appendix we report the proves of the main theorems.
Background
In this section we recall some preliminary notions about contexts theory from [13].

Context
First of all, we recall the definition of context.
Definition 2.1 A context system C is a structure C = (⟨Cm⟩n,m, Act, ⟨→n,m⟩n,m) where Cm is a set of n-to-m contexts; Act is a set of actions; Act0 = Act ∪ {0}
where 0 /∈ Act is a distinguished no-action symbol, Actk is a tuple of k actions
∈ Act0, and →n,m⊆ Cm × (Actn × Actm) × Cm is the transduction-relation for the
n	0	0	n
n-to-m contexts satisfying (C, a˜, ˜0, D) ∈→n,m if and only if C = D and a˜ = ˜0 for all contexts C, D ∈ Cm.
˜b
For (C, a˜, ˜b, C') ∈→n,m we usually write C −→ C', leaving the indices of → to be
determined by the context, and we interpret this as:




Inaction:
Prefix: Restriction:

˜0
C ˜0 C for all C

a
a∗ −→


Choice:
a
L a \L	a /∈ L
a	a

(1) + −−−→	1
−−−→	2


Projection:
(a, 0) Π2	(2) + (0, a) Π2 for a ∈ Act

a

Πi −−→	i


Identity:
n i(a) Πn

a˜
In −→


Parallel:
a˜ In

τ	a	a

(1)
−−−→
(a, a¯)
−−−→
(a, 0)
−−−→
(0, a)

where i(a) ∈ Actn with the ith component being a and all the others being 0.

Table 1
Semantics of CCS context system.

Consuming actions a˜, context C can produce actions ˜b and change into C'.
˜b
In a transduction C −→ C', certain components in a˜ and/or ˜b can be 0 indicating
that the corresponding internal process and/or external observer is not involved in the transduction. In particular the last condition of →n,m means that a context can always and only produce nothing without consuming anything.
In order to give some example of contexts, we present here how it is possible to see process algebra operators as contexts.
Example 2.2 CCS process algebra (see [19]) can be seen as a context system with
the following contexts: preﬁx a∗ ∈ C1 for a ∈ Act, restriction \L ∈ C1 where
L ⊆ Act. Choice and parallel context +,  ∈ C1; inactive N˜il ∈ Cm for any n and
2	n
m. There are also the identity context In ∈ Cn and the projection Πi ∈ C1. The
n	n	n
semantics definition of CCS context is in Table 1.

Operations between contexts
Several operations are allowed between contexts.

Composition of contexts
Definition 2.3 Let C = (⟨Cm⟩n,m, Act, ⟨→n,m⟩n,m) be a context system. A com- position on C is a dyadic operation ◦ on contexts such that whenever C ∈ Cm and

D ∈ Cr then D ◦ C ∈ Cr. Furthermore, the transductions for a context D ◦ C with
C ∈ Cm and D ∈ Cr are fully characterized by the following rule:
n	m

˜	c˜
−→	−→
a˜	b D
c˜
D ◦ C −→ D' ◦ C'
where a˜ = (a1,..., an), ˜b = (b1,..., bn) and c˜ = (c1,..., cn) are vectors of actions. We usually write C(P ) to denote a composed context; the combined process
C(P ) is nothing but the composition C ◦ P as follows form the context composition.

Example 2.4 In order to explain how the composition between contexts works, we recall an example given in [13].
Let a.b.Nil be a standard CCS term. It can be composed from the constructs as a∗ ◦ b∗ ◦ Nil. Using the inference rule for composition, we can infer the following
transitions:
  − 		−	
a	∗	0  ∗

C	a∗→−
b ◦Nil−→b ◦Nil


and
a∗ ◦ b∗ ◦ Nil −a→ I1 ◦ b∗ ◦ Nil

  − 
b
 − 	b 0 I1
b	∗
	−	
0
Nil−→Nil
b

C	I1→−
b ◦Nil−→I1◦Nil

I1 ◦ b∗ ◦ Nil −→b
I1 ◦ I1 ◦ Nil

Obviously, a composed context of the form Im ◦ C has the same behavior as C.

Product of contexts
In order to represent a system with n holes, we use a n-to-1 context C ∈ C1. If C
is combined with a context D ∈ Cn , we obtain C ◦D ∈ C1 . If m = 0 then we obtain
m	m
a process. The context D, in this case, provides a simultaneous expansion of the n
holes in C. To allow the expansion of the n holes to be carried out independently, it is
defined an independent combination of n contexts as D1 ×...×Dn, where Di ∈ C1 ,
i = 1,...,n and Di is intended as an expansion of the i’th hole of C in such a way
that m = Σ mi. This motivates the following construct of (independent) products
of contexts.
Definition 2.5 Let C = (⟨Cm⟩n,m, Act, ⟨→n,m⟩n,m) be a context system. A product
on C is a dyadic operation × on contexts, s.t. whenever C ∈ Cm and D ∈ Cs then
n	r
C × D ∈ Cm+s.  Furthermore the transduction for a context C × D are fully
characterized by the following rule:

˜b	d˜
−→	−→
a˜	c˜
˜bd˜
C × D −→ C' × D'

where juxtaposition of vectors a˜ = (a1,..., an) and c˜ = (c1,..., cr) is the vector a˜c˜ = (a1,..., an, c1,..., cr) and juxtaposition of vectors ˜b = (b1,..., bn) and d˜ = (d1,..., dr) is the vector ˜bd˜= (b1,..., bn, d1,..., dr).
We usually write the combined process C(P1,..., Pn) as a shorthand for C ◦ (P1 × ... × Pn). Since we consider asynchronous contexts, it is not required that all the components P1,..., Pn contribute in a transition of the combined process C(P1,..., Pn), i.e., some of the Pi could perform a 0 action.
Example 2.6 Also in this case, since in the rest of the paper composition and product operation are the most useful for our purposes, we recall an example already presented in [13].
Let a.Nil + b.Nil be a standard CCS term. It can be composed from the constructs as + ◦ (a∗ ◦ Nil × b∗ ◦ Nil). Using the inference rule for composition and product, we can infer the following transitions:


  − 
a
a∗→−0 I1
	−	
0
Nil−→Nil		−	

C	∗	a
∗	0 ∗

	−			a ◦Nil−→I1◦Nil	b ◦Nil−→b ◦Nil
a	(a,0)

+−−−→ 1
a∗◦Nil×b∗◦Nil −→ I ◦Nil×b∗◦Nil

C	(a,0)Π2	1
+ ◦ (a∗ ◦ Nil × b∗ ◦ Nil) −a→ Π1 ◦ (I1 ◦ Nil × b∗ ◦ Nil)
where the behavior of Π1 ◦(I1 ◦ Nil × b∗ ◦ Nil) is behavioral equivalent to Nil since,
2	a
in accordance with the standard CCS transition relation, a.Nil + b.Nil −→ Nil.

Feed-back on context
In order to deal with recursion, a construction of feed-back on contexts is defined,
s.t. whenever C ∈ Cn then C† ∈ Cn and C† is equivalent to C ◦ C†. Formally, we
n	0
have the following definition.
Definition 2.7 ([13]) Let C = (⟨Cm⟩n,m, Act, ⟨→n,m⟩n,m) be a context system. A feed-back on C is a unary operation †, on contexts of C s.t., whenever C ∈ Cn,n then C† ∈ Cn. Furthermore, the transduction for a context C† with C ∈ Cn is fully

0
characterized by the rule:
n

¯b
−→	−a¯→ D

¯
−→ C' ◦ D
In order to understand the meaning of this operator we recall the following example (see [13]).
Example 2.8 Let us consider the CCS process defined as X = a.X. It can be realized as the context (a∗)†. Indeed, using the inference rule of the feed-back, we obtain the following transition:

  − 		−	
a	∗ † 0	∗ †

F a∗→−
(a ) −→(a )

(a∗)† −a→ I1 ◦ (a∗)†

and in fact this is the only transition for (a∗)†.

Open systems as transducers
According to [13], the theory of contexts is useful to model and analyze distributed partially speciﬁed systems, i.e., systems in which more than one component is un- specified. As a matter of fact, a partially specified system can be formalized by contexts as a system of the form C(X1,..., Xn), where C denotes the known part of the system and X1,..., Xn denote components still remaining unknown. In process algebra, the partial implementation C(X1,..., Xn) can be described as an expression with X1,..., Xn as free variables that may be replaced by closed expres- sion P1,..., Pn. By syntactically replacing each Xi by the corresponding Pi, we get the closed expression C(P1,..., Pn).
In this way we have a general framework that permits us to consider a complex and general scenario. Indeed, whether we consider a partially specified system, several scenarios can be considered in order to obtain a closed system. In the easiest case, the number of the unspecified components is one. In this case there is a unique hole that a process can fill in.  On the other hand, if we consider a system in which there are several holes, we may distinguish from two different approaches for the analysis of such systems: By considering all n holes as a unique hole of cardinality n (in this case we put a central process that performs a vector of n actions), or by considering several independent unary processes whose product closes the expression.
Example 2.9 Let C1 = h∗ ◦ l∗ ◦ h∗ ◦ Nil and C2 = h∗ ◦ l∗ ◦ Nil be two contexts. Let
1	1	1	2	2
us consider a context C ∈ C1 built as a composition of several contexts as follows:

C =  ◦ (\{h1,h2,h¯1,h¯2} ◦ (C1 × X1)) × (\{h1,h2,h¯1,h¯2} ◦ (C2 × X2))

Here we have explicitly denoted by X1 and X2, in C1, the free variables in C1 of
0	0
the contexts in order to make the context readable. Being  ∈ C1, C1 and C2 in C1
2	0
it is not difficult to see that C is effectively in C1. X1 and X2 represent respectively the first and the second component of the context C ∈ C1.
Informally, this context allows for the synchronization on actions h1, h2. This permits us, as we will see after, to control sequences of executions of low actions, such as l1 and l2.
In order to obtain a closed expression we have to combine C with a context in C2. Such context could be a binary contexts such as, for instance, P = (h¯1, 0)∗ ◦ (h¯1, 0)∗ ◦ (0, h¯2)∗ ◦ N˜il. Or the product of a couple of contexts in C1, for instance

P1 = h¯1∗
h¯1∗
Nil and P2 = h¯2∗
0
Nil. As a matter of fact, the product P1 × P2

is a context in C2 as required. In this case the closed expression is C ◦ (P1 × P2).
Referring to Definition 2.3, the context C ◦ P behaves according to the following rule:

τ
−−−−→
C(h¯1, 0)C
(h¯1,0)
P −→ P'

(1)


C(P ) −τ→ C'(P')

where P' = (h¯1, 0)∗ ◦ (0, h¯2)∗ ◦ N˜il and C' =  ◦ (\{h ,h h¯ ,h¯ } ◦  (C'
× X1) ×

1  2 1  2	1
\{h ,h ,h¯ ,h¯ } ◦  (C2 × X2)) where C' = l∗ ◦ h∗ ◦ Nil. Obviously this is the first

1  2  1  2
1	1	1

transition. The rest of the transduction is omitted, but it is possible to calculate the following steps by applying the composition rule. At the end we obtain that
C(P ) has the same behavior as τ∗ ◦ l∗ ◦ τ∗ ◦ τ∗ ◦ l∗ ◦ Nil. This is the only maximal
1	2
sequence of actions allowed for this composition of contexts. As a matter of fact, informally, if C2 pretends to perform the first action, it is forbidden by the restriction
\{h1,h2,h¯1,h¯2}. Hence the first  takes the first action from the first component producing the transition showed in Equation (1). A similar reasoning is made for the second and third steps of the computation, so the context performs l∗ ◦ τ . At this point the first component is reduced to Nil so we have a synchronization on the second component and then the action l2 is unblocked.
Let us now consider the distributed case. Referring to how the contexts are built, we have the following first transition:


	−	
h¯
	−		−→
	−	
0
P2−→P2

τ
−−−−→ '
(h¯ ,0) '

 C(h¯1 ,0)C	P1×P2 −→ P1×P2 
C(P1, P2) −τ→ C'(P', P2)
It is possible to note that, in this case, the first step is similar because the first action is performed by P1. There is a difference between the behavior of C(P ) and C(P1, P2) if the first action is performed by P2, or the difference appears at the second steps of transaction. As a matter of fact, in the first case, we have to follow the behavior of P' and C' , on the contrary, in the second case the first (or second) step could be performed by P2 and C2. This crucial difference will be used in the following to prove a central result of this paper.

Behavioral Equivalences
In order to have a method to compare behaviors of contexts, we recall some defi- nitions of behavioral equivalences. We start with the definition of trace equivalence for contexts.
Let us start by giving some notations used in the following.
Let us consider τ˜ as a tuple of actions in which there are no actions different from τ or 0. Let a˜ = (a1,..., an) be a vector of actions in Actn. Then aˇ˜ = a˜ when ai /= τ for all i = 1,..., n, or aˇ˜ = a˜[0\τ ] where all the occurrences of the τ actions in the vector are replaced by the no action 0. In particular τˇ˜ = τ˜, i.e., if the vector is composed only by τ or 0 actions, the substitution is not performed.

Then, notation C
=τ⇒˜
C' denotes that C and C' belongs to the reflexive and

transitive closure of −τ→˜
. Also, C =aˇ˜
C'' if C =τ˜
aˇ˜
=τ⇒˜
C''.

Let γ = a˜1 ... a˜n ∈ Actn\{τ˜} be a sequence of vectors of actions, i.e., a trace, where Actn\{τ˜} is the set of vectors of actions of length n without the n-tuple τ˜.
Let γˇ = aˇ˜1 ... aˇ˜n be a sequence of vectors of actions in which each occurrences

of τ actions in each vector has been replaced by 0. C =γˇ
C' if C =a⇒ˇ˜1
... =a⇒ˇ˜n  C'

Let C ∈ Cn be a context, then the set of traces of C is Tr(C) = {γˇ|∃C' C =γˇ
0	⇒
C'}.
Definition 2.10 Let C, D ∈ Cn be two contexts. We define the relation of trace inclusion, denoted by ≤T as follows:

C ≤T D iff Tr(C) ⊆ Tr(D)
Moreover, C and D are trace equivalent, denoted by ≈T , iff Tr(C) = Tr(D).
Other behavioral equivalences are defined for contexts. We just recall the def- initions of simulation and bisimulation equivalences (see [19]) by distinguishing between a strong version and a weak one.
Definition 2.11 Let C = (⟨Cm⟩n,m, Act, ⟨→n,m⟩n,m) be a context system. Then an n-to-m strong simulation R is a binary relation on Cm s.t., whenever (C, D) ∈ R 
and a˜ ∈ Actn, ˜b ∈ Actm, then the following holds:
0	0
˜b	˜b
if C −→ C', then D −→ D' for some D' with (C', D') ∈ R 
We write C ≺ D in case (C, D) ∈ R for some n-to-m simulation R.
A strong bisimulation is a relation R s.t. both R and R−1 are simulations. We represent with ∼ the union of all the strong bisimulations.
Now we are able to give the definition of weak bisimulation by considering that, in the rest of the paper, we use it w.r.t. contexts in Cn. Hence we consider a definition that is an extension of the definition of weak bisimulation given by Milner in [19] for processes, that, as we have already said, can be seen as contexts in C1.
Definition 2.12 Let C = (⟨Cn⟩0,n, Act, ⟨→0,n⟩0,n) be a context system. Then a 0-to-n weak simulation R is a binary relation on Cn s.t., whenever (C, D) ∈ R and
a˜ ∈ Actn, then the following holds:

if C −a˜→ C', then D =a⇒ˇ˜
D' for some D' with (C', D') ∈ R.

We write C ≤ D in case (C, D) ∈ R for some 0-to-n simulation R.
A weak bisimulation is a relation R s.t. both R and R−1 are simulations. We represent with ≈ the union of all the weak bisimulations.
Theorem 2.13 ([13]) ∼ is preserved by composition, product and feed-back of con- texts.
Some information flow properties
Information flow properties are a particular class of security properties which aim at controlling the way information may flow among different entities. They have been first proposed as a means to ensure confidentiality, in particular to verify if access control policies are sufficient to guarantee the secrecy of (possibly classified)

information. Indeed, even if access control is a well studied technique for system security, it is not trivial to find an access control policy which guarantees that no information leak is possible.
In the literature, there are many different security definitions reminiscent of the information flow idea, each based on some system model (see [4,6,14,20]). The central property is the Non Deducibility on composition (NDC, see [4]). Intuitively,
a system is NDC if, by interacting with every possible high level user, it always
appears the same to low level users, so that no information at all can be deduced by low level users.
Exploiting the relation of bisimulation, we obtain the notion of Bisimulation Non Deducibility on Compositions, BNDC for short, proposed in [4,6] as generalization of the classical idea of Non-Interference (see [12]) to nondeterministic systems.
In the following we recall the definition of a non interference properties, NDC
and BNDC properties proposed in [3,4,5,6].

NDC and BNDC properties
To describe information flow property, we can consider two users, High and Low interacting with the same computer system. We wonder if there is any flow of information from High to Low.
In [3,4,5,6] a family of information flow security properties called Non Deducibil- ity on Compositions (NDC, for short) was proposed. Intuitively, a system is NDC if, by interacting with every possible high level user, it always appears the same to low level users, so that no information at all can be deduced by low level users. The above idea can be instantiated in a lot of ways, by choosing a particular way of interacting between systems and various criteria of equivalence. First we consider the trace equivalence, thus the NDC is described in terms of CCS process algebra (see [19]) as follows:
E is NDC iff ∀ Π ∈ High users , (E  Π)\H ≈T E\H
where H is a set of high actions. NDC requires that high level processes Π are not able to change the low level behavior of the system represented by \H(E). If it is equivalent to \H(  (E × Π)) this clearly means that Π is not able to modify in any way the execution of E. It is possible to give the definition of NDC by using contexts as follows:
E is NDC iff ∀ Π ∈ High users , \H(  (E × Π)) ≈T \H(E)
We can obtain a bisimulation based NDC by simply substituting ≈T with ≈. In particular, in [5,6], the authors argue that BNDC is the right choice. Hence they give a formulation of BNDC in terms of CCS parallel operator (see [19]). Also in this case we give the definition of BNDC by exploiting the semantics of contexts as follows.
Definition 2.14 Let Sort(Π) be the set of actions that occurs in Π and let H be
the set of high actions. Let C1	= {Π | Sort(Π) ⊆ H ∪ {τ }} be the set of High
users. E ∈ C1 is BNDC if and only if ∀Π ∈ C1	we have \H(  (E × Π)) ≈ \H(E).
0	0,H

Proposition 2.15 ([5,6]) Let C ∈ C1 be a context.
C ∈ BNDC =⇒ C ∈ NDC

The viceversa does not hold, as the following example shows.
Example 2.16 ([5,6]) Let E = +((τ∗ ◦ l∗ ◦ Nil) × (τ∗ ◦ h∗ ◦ l∗ ◦ Nil)) be a context in C1.  According to [5,6], E ∈ NDC.  However E /∈ BNDC: let us consider Π = h¯∗ ◦ Nil, then \H(  (E × Π)) = +((τ∗ ◦ l∗ ◦ Nil) × (τ∗ ◦ τ∗ ◦ l∗ ◦ Nil)) while
\H(E) = +((τ∗ ◦ l∗ ◦ Nil) × (τ∗ ◦ Nil)).

Specification of Information Flow Properties for Dis- tributed Systems
In this paper we want to extend the definition of NDC and BNDC properties given for processes in order to deal also with distributed systems. In particular, we con- sider a partially specified system in which several components are unspecified. We describe it as a context. Then we wonder if the context is NDC and/or BNDC.
Example 3.1 In order to make this example readable we use the infix notation that is more suitable than the prefix one of the context theory.
Let us consider a system specified as follows:
C = ((h∗ ◦ l∗)†  X0)\	¯ ((h∗ ◦ l∗)†  X1)\	¯
0	0	{h0,h0}	1	1	{h1,h1}
Let us interpret l0 and l1 as bit 0 and 1 respectively. According to how we choose X0 and X1 it is possible to generate sequences of 0 and 1 obtaining (possible infinite) that represent information that (indirectly) flows from high to low. As a matter of fact, the high level user is able to generate a string of 0s and 1s that represents a message that a low level user receives.

Speciﬁcation of NDC in distributed systems
According to the definition of NDC (see [3,4,5,6]), there is an universal quantification on all possible high users. Hence it is possible to specify the NDC property as an open system S = \H(  (E × )), where there is a hole in which we have to consider a high user. The system S has to satisfy the NDC property whatever the behavior of a high user is.
The scenario we want to analyze here consists in a system in which more than one high user acts on the system. A natural extension of this reasoning to a sys- tem in which there are more than one unspecified component, is considering these components as high users, i.e., if C ∈ C1 there are n high processes in C1.
n	0
In this section we present how the specification of the NDC property can be
extended to consider systems with more than one high level user. We consider two different approaches: The centralized approach, CNDC, and the decentralized one, DNDC.

First we give the following notational definition.
Definition 3.2 Let H ⊆ Act be the set of high actions and let Hn ⊆ Actn be the set of n-tuples of high actions. The context \Hn ∈ Cn is defined by the following

rule:


\Hn

a˜
−→ \Hn

a˜ /∈ Hn

where N˜il is the n-ary context that does not perform any action and a˜ /∈ Hn means that, being a˜ = (a1,..., an) there does not exists any ai ∈ H for i = 1,..., n.
Let us start with the centralized one.
Definition 3.3 Let C ∈ Cm a generic context. C ∈ CNDC iff

∀X ∈ Cn
\Hm C(X) ≈T \Hm C(N˜il)

As before we have a universal quantification into the specification that results difficult to manage. Referring to the theory developed in [9], we want to give a static characterization of CNDC by using a particular context Topn ∈ Cn that is a a feed-back context on all possible n-tuples of high actions semantically defined as follows:
Topn† −a˜→ Topn†
for any a˜ ∈ Hn. This context allows for all possible n-tuples of high actions.
The following result holds, whose proof is postponed to the Appendix.
Proposition 3.4 Let C ∈ Cm be a generic context.

(∀X ∈ Cn
\Hm C(X) ≈T \Hm C(N˜il)) ⇔ \Hm C(Topn) ≈T \Hm C(N˜il)

This means that the NDC property is statically characterized by the Topn con- text. In this way the universal quantification on all possible high users is embedded into the context Topn.
Now, let us consider the decentralized approach.
Definition 3.5 Let C ∈ Cm a generic context. C ∈ DNDC iff
∀X1,..., Xn ∈ C1	\Hm C(X1,..., Xn) ≈T \Hm C(Nil, ...,Nil)
Also in this case, by exploiting the context Top1 we prove (see the Appendix) the following result.
Proposition 3.6 Let C ∈ Cm a generic context.


(∀X1,..., Xn ∈ C1
\Hm C(X1,..., Xn) ≈T \Hm C(Nil, ...,Nil))
🅘

\Hm C(Top1,...Top1) ≈T \Hm C(Nil, . . . Nil)

Hence, also in the decentralized case, it is possible to statically characterize
DNDC.
In order to study the relation that exists between CNDC and DNDC we give the following proposition (proof in the Appendix).
Proposition 3.7 Let C ∈ Cm a generic context.
\Hm C(Topn) ≈T \Hm C(N˜il) ⇔ \Hm C(Top1,...Top1) ≈T \Hm C(Nil, . . . Nil)

Hence there is no difference between the two approaches if we consider the trace equivalence as behavioral relation between contexts in the analysis of the information flow properties. This means that there is no differences if the system is attacked by n independent malicious agents with no knowledge each other or by n attackers that manage to violate a system in a collaborative way.
In the next subsection, we will show that this is no longer the case if bisimulation is used in place of trace semantics. Hence, according to what Focardi and Gorrieri have already concluded about the analysis of open system with only one high user
([5,6]), also in presence of several high components, the BNDC property turns out
to be more interesting and appropriated than NDC.

Speciﬁcation of BNDC in distributed systems
According to [7,15,16,17,8], the BNDC property can be analyzed by using the open system paradigm (see [15,16,17,8]).
As we have already done in the previous section for the NDC property, we extend the specification of BNDC property to distributed systems by considering that more than one high level user interacts with the system. Also in this case, we consider these high level users as unspecified components of a distributed system modelled by a context, e.g., if C ∈ C1 there are n high processes.
We distinguish between a centralized notion of BNDC (CBNDC) and a decen- tralized one (DBNDC).
First we specify the CBNDC, in which we consider the unspecified part of the system as a context that can perform a vector of actions.
Definition 3.8 Let C ∈ Cm be a context and let Cn	be the set of n-ary High

n
context. C is CBNDC if and only if:
0,H



∀X ∈ Cn
\Hm (C(X)) ≈ \Hm (C(N˜il))


where N˜il is the n-ary context that does not perform any action.
Second, we take into account, a decentralized notion of BNDC, called DBNDC, in which we consider the unspecified part of the system as made of several independent contexts composed by product.

Definition 3.9 Let C ∈ Cm be a context and let C1	be the set of unary High

n
context. C is DBNDC if and only if:
0,H

∀X1,..., Xn ∈ C1	\Hm (C ◦ (X1 × ... × Xn)) ≈ \Hm (C ◦ (Nil × ... × Nil))
where, according to the rule of the product operation, the product X1 × ... × Xn
in a context in Cn
In order to compare Definition 3.8 and Definition 3.9 we give the following result.

Proposition 3.10 Let C be a context in Cm. If C is CBNDC, then C is also

DBNDC.
Proof [Sketch] It is enough to observe that for any D ∈ C1

× ... × C1

(for n

times), there exists D' ∈ Cn	such that D and D' are strong bisimilar.	 
However the vice-versa of the Proposition 3.10 does not hold as the following example shows.
Example 3.11 Let us consider now a context D ∈ C1 s.t. D = τ∗ ◦ l∗ ◦ Nil + τ∗ ◦
2	1
l∗ ◦ Nil +(τ∗ ◦ l∗ ◦ Nil  τ∗ ◦ l∗ ◦ Nil)+ C where C is the same context of Example 2.9.
2	1	2
In order to make this example readable we use the infix notation that is more suitable than the prefix one in order to point out why the two approaches differ.
As in Example 2.9, first we consider to combine D with another context P = (h¯1, 0)∗ ◦(h¯1, 0)∗ ◦(0, h¯2) ∈ C2. Here we show that D is not CBNDC. As a matter of
fact by calculating D◦N˜il we obtain τ∗◦l∗◦Nil+τ∗◦l∗◦Nil+(τ∗◦l∗◦Nil  τ∗◦l∗◦Nil).
1	2	1	2
On the contrary, by considering P = (h¯1, 0)∗ ◦(h¯1, 0)∗ ◦(0, h¯2), we obtain that D ◦ P
is τ∗ ◦ l∗ ◦ Nil + τ∗ ◦ l∗ ◦ Nil + (τ∗ ◦ l∗ ◦ Nil  τ∗ ◦ l∗ ◦ Nil)+ τ∗ ◦ l∗ ◦ τ∗ ◦ τ∗ ◦ l∗ that
1	2	˜ 1	2	1	2
it is not weakly bisimilar to D ◦ Nil.
Now, we want to prove that D is DBNDC. It is not difficult to note that the
possible contexts that can interact with D and make an attack are P1 = h¯1∗ ◦
h¯1∗ ◦ Nil and P' = h¯1∗ ◦ Nil, for the first component and P2 = h¯2∗ ◦ Nil for the second one. It is possible to prove that both \H(D(P1, P2)) ≈ \H(D(Nil, Nil)) and
\H(D(P', P2)) ≈ \H(D(Nil, Nil)). Hence C is DBNDC 4 .
First of all we calculate:

\H(D(Nil, Nil)) = τ∗ ◦ l∗ ◦ Nil + τ∗ ◦ l∗ ◦ Nil + (τ∗ ◦ l∗ ◦ Nil  τ∗ ◦ l∗ ◦ Nil)
1	2	1	2
In the first case, by calculating D ◦ (P1 × P2) we obtain:
τ∗ ◦ l∗ ◦ Nil + τ∗ ◦ l∗ ◦ Nil + (τ ∗ ◦ l∗ ◦ Nil  τ∗ ◦ l∗ ◦ Nil)+(τ∗ ◦ l∗ ◦ τ∗ ◦ Nil  τ∗ ◦ l∗ ◦ Nil)
1	2	1	2	1	2
that it is weakly bisimilar to τ∗ ◦ l∗ ◦ Nil + τ∗ ◦ l∗ ◦ Nil + (τ∗ ◦ l∗ ◦ Nil  τ∗ ◦ l∗ ◦ Nil)
1	2	1	2

4 To be complete we have also to prove that \H (D(Nil, P2)) ≈ \H (D(Nil, Nil)), \H (D(P1,Nil)) ≈
\H (D(Nil, Nil)) and \H (D(P ',Nil)) ≈ \H (D(Nil, Nil)). These follow obviously, so we decide to show
the two more difficult cases.

In the second case, by calculating D ◦ (P ' × P2) we obtain:

τ∗ ◦ l∗ ◦ Nil + τ∗ ◦ l∗ ◦ Nil + (τ∗ ◦ l∗ ◦ Nil  τ∗ ◦ l∗ ◦ Nil)+ (τ∗ ◦ l∗ ◦ Nil  τ∗ ◦ l∗ ◦ Nil)
1	2	1	2	1	2
that it is weakly bisimilar to τ∗ ◦ l∗ ◦ Nil + τ∗ ◦ l∗ ◦ Nil + (τ∗ ◦ l∗ ◦ Nil  τ∗ ◦ l∗ ◦ Nil).
1	2	1	2
It is interesting to note that the context P ∈ C2 is an example of a process
that can not be written as product of two unary contexts, i.e., there do not exist P1, P2 ∈ C1 such that P1 × P2 is weakly bisimilar to P . Hence the main difference between the CBNDC and DBNDC is that, in the centralized case, the universal
quantification is made on contexts in Cn ⊃ C1 × ... × C1.
0	0	0
`	˛¸	x
To sum up, if we consider the trace equivalence as behavioral equivalence among contexts, we do not have any difference between the centralized and decentralized approaches for information flow specification, i.e., there are no differences between CNDC and DNDC. On the other hand, if we consider bisimulation equivalence, the two approaches are different. This depends on the fact that it is not possible to give a static characterization of BNDC in terms of a finite context (see [9]). Since the BNDC property is a particular case of both CBNDC and DBNDC, we can conclude that there is no finite context playing the same role as Topn for the trace case for statically characterize neither CBNDC or DBNDC.

Related Work
Some work has been done in the study of information flow properties also in dis- tributed systems.
In [10] the authors have studied the information flow properties in a mobile agents setting. They have considered a distributed system with several unspecified locations and have studied when the system satisfies the information flow properties considering that an agent performs a different action in each different location. They
refer to this property as mobile BNDC, M BNDC for short. In our framework we
have several agents and we also consider the possibility that they interact each other and with the environment. This is not the case of M BNDC in which a single process passes from a location to another by performing a set of actions in each
location, sequentially. There is not reference to NDC property in dynamic contexts
since they directly consider the bisimulation relation.
In [1] the authors have studied which could be the effect of the environment on the information flow security in a multilevel system by referring to context, even if they do not referred to the context theory developed in [13]. Indeed, they introduce the notion of secure contexts for a class of processes as a parametric notion w.r.t. both the observation equivalence and the operation to characterize the low level views of a process. In particular they also show that BNDC and NDC, are just special instances of the general notion. Our work can be considered an extension of this one in which we consider more then one high user.
In [21] the authors pointed out that in general BNDC is not compositional w.r.t.

all process algebras operators. This result is an extension of the one given in [17], in which the author proved that BNDC is not compositional w.r.t. parallel operator. Moreover, in [21], the author has defined several properties, stronger than BNDC, in order to have properties that are compositional w.r.t. process algebra operators. In this work we have proposed a different specification of the problem that takes into account the environment of the system.
BNDC has been also studied in the distributed model of elementary net sys- tems in [2], where, however, one unique intruder is considered, in the same line of centralized BNDC.
Another framework for the specification of distributed systems has been given in [11]. The authors propose the tile logic as a new formalism, equipped with features for supporting an easy specification of concurrent and distributed systems. Each rule in tile logic aims at describing the possible behavior of an open system. It recalls sequent calculus. Security aspects are not treated there.

Conclusion and Future Work
In this paper we presented a possible extension of the specification of information flow properties also to a framework in which more than one high level user is active. Then we have extended the approach, based on the open system paradigm used to specify information flow properties such as NDC and BNDC with one high level user, to deal with such a more complex scenario.
We aim to extend this research by considering also the verification problem. We are working on a method to verify both centralized and distributed BNDC. Moreover we will also investigate what could happen if some unspecified components of the analyzed partially specified system can perform low actions. In particular we could consider that the unspecified components of the system are not only possible malicious agents but could also be generic processes that can perform high actions as well as low ones.
Moreover we intend to deal with enforcement mechanisms for monitoring infor- mation flow properties in distributed system. In particular, we would like to extend the work in [18] to define and synthesize controller operators also for the properties defined in this work.
Acknowledgement
We would like to thank the anonymous reviewers for their helpful comments.

References
Bossi, A., D. Macedonio, C. Piazza and S. Rossi, Information flow in secure contexts, J. Comput. Secur.
13 (2005), pp. 391–422.
Busi, N. and R. Gorrieri, Positive Non-interference in Elementary and Trace Nets, in: J. Cortadella and W. Reisig, editors, ICATPN’04: Proceedings of the 25th International Conference on Applications and Theory of Petri Nets, Lecture Notes in Computer Science 3099 (2004), pp. 1–16.

Focardi, R., “Analysis and Automatic Detection of Information Flows in Systems and Networks,” Ph.D. thesis, Department of Computer Science, University of Bologna (1998).
Focardi, R. and R. Gorrieri, A Classification of Security Properties for Process Algebras, Journal of Computer Security 3 (1994/1995), pp. 5–33.
Focardi, R. and R. Gorrieri, The Compositional Security Checker: A Tool for the Verification of Information Flow Security Properties, IEEE Transactions on Software Engineering 27 (1997), pp. 550– 571.
Focardi, R. and R. Gorrieri, Classification of Security Properties (Part I: Information Flow), in:
R. Focardi and R. Gorrieri, editors, FOSAD’00: Revised versions of lectures given during the IFIP WG 1.7 International School on Foundations of Security Analysis and Design on Foundations of Security Analysis and Design, Lecture Notes in Computer Science 2171 (2001), pp. 331–396.

Focardi, R., R. Gorrieri and F. Martinelli, Classification of Security Properties - Part II: Network Security, in: R. Focardi and R. Gorrieri, editors, Foundations of Security Analysis and Design II, FOSAD 2001/2002 Tutorial Lectures, Lecture Notes in Computer Science 2946 (2002), pp. 139–185.
Focardi, R., R. Gorrieri and F. Martinelli, Real-time Information Flow Analysis, IEEE JSAC (2003),
pp. 18–32.
Focardi, R. and F. Martinelli, A Uniform Approach for the Definition of Security Properties, in: FM’99: Proceedings of the Wold Congress on Formal Methods in the Development of Computing Systems- Volume I, Lecture Notes in Computer Science 1708 (1999), pp. 794–813.
Focardi, R. and S. Rossi, Information Flow Security in Dynamic Contexts, in: CSFW’02: Proceedings of the 15th IEEE workshop on Computer Security Foundations (2002), p. 307.
Gadducci, F. and U. Montanari, The Tile Model, in: Proof, Language and Interaction: Essays in Honour of Robin Milner (2000), pp. 133–166.
Goguen, J. A. and J. Meseguer, Security policy and security models, in: Proc. of the 1982 Symposium on Security and Privacy (1982), pp. 11–20.
Larsen, K. G. and L. Xinxin, Compositionality through an operational semantics of contexts, Journal of Logic and Computation 1 (1991), pp. 761–795.
Lowe, G., Semantic models for information flow, Theor. Comput. Sci. 315 (2004), pp. 209–256.
Martinelli, F., “Formal Methods for the Analysis of Open Systems with Applications to Security Properties,” Ph.D. thesis, University of Siena (1998).
Martinelli, F., Partial Model Checking and Theorem Proving for Ensuring Security Properties, in:
CSFW’98: Proceedings of the 11th IEEE workshop on Computer Security Foundations (1998), p. 44.
Martinelli, F., Analysis of security protocols as open systems, Theoretical Computer Science 290 (2003),
pp. 1057–1106.
Martinelli, F. and I. Matteucci, Synthesis of Local Controller Programs for Enforcing Global Security Properties, in: ARES’08: Proceedings of the the 3rd International Conference on Availability, Reliability and Security (2008), pp. 1120–1127.
Milner, R., “Communication and Concurrency,” Prentice Hall, London, 1989.
Ryan, P. Y. A. and S. A. Schneider, Process algebra and non-interference, in: CSFW’99: Proceedings of the 1999 IEEE Computer Security Foundations Workshop (1999), p. 214.
Tini, S., Rule formats for compositional non-interference properties, J. Log. Algebr. Program. 60-61
(2004), pp. 353–400.

A	Technical Proofs
Before the proof of Proposition 3.4 and 3.6 we give the following lemmata.
Lemma A.1 ∀X ∈ Cn	X ≺ Topn

Proof Let S be the binary relation defined as follows:

S = {(C, Topn)|C ∈ Cn}

The thesis follows immediately if relation S is a strong simulation. But this derives trivially from the definition of Topn, as it can perform any vector of high actions. Indeed, if C −a˜→ C', then Topn −a˜→ Topn with (C',Topn) ∈ S. Hence we have the thesis.	 

Lemma A.2 Let C, D ∈ Cn be two contexts. The following hold:
C ≺ D ⇒ C ≤T D
C ∼ D ⇒ C ≈T D


Proof
If C ≺ D then, if C

−a˜→ C', there exists D' s.t.  D

−a˜→ D' with C' ≺ D'.

This means that computations of length one performed by C are matched by corresponding computations of length one performed by D. Inductively, one can

prove that if C −a˜→1
C1 −a˜→2
C2 ... −a˜→n
Cn, then D −a˜→1
D1 −a˜→2
D2 ... −a˜→n
Dn with

Cn ≺ Dn. This ensures that any trace of C, that can be obtained by abstracting on the sequence a˜1a˜2 ... a˜n, is also a trace of D.
For the definition of bisimulation, C ∼ D implies that C ≺ D and D ≺ C. Hence, for the previous point of this lemma, we have that Tr(C) ⊆ Tr(D) and Tr(D) ⊆ Tr(C). This implies that C ≈T D.


Proposition 3.4 Let C ∈ Cm a generic context.


(∀X ∈ Cn
\Hm C(X) ≈T \Hm C(N˜il)) ⇔ \Hm C(Topn) ≈T \Hm C(N˜il)


Proof The proof is divided into two parts:
⇒ Since ∀X ∈ Cn	\Hm C(X) ≈T \Hm C(N˜il), it holds obviously also for Topn.
Hence \Hm C(Topn) ≈T \Hm C(N˜il).
⇐ We prove that \Hm C(N˜il) ≤T \Hm C(X) ≤T \Hm C(Topn).
For Lemma A.1, X ≺ Topn. Since ≺ is a pre-congruence for context, i.e., it is a congruence and a pre-order, we have that \Hm C(X) ≺ \Hm C(Topn). Hence, for Lemma A.2, \Hm C(X) ≤T \Hm C(Topn).
A similar reasoning is done by noticing that N˜il ≺ X. Hence, by applying the previous lemmata, we have that \Hm C(N˜il) ≤T \Hm C(X).
To sum up \Hm C(N˜il) ≤T \Hm C(X) ≤T \Hm C(Topn) ≈T \Hm C(N˜il). Hence
\Hm C(X) ≈T \Hm C(N˜il).
 

Proposition 3.6 Let C ∈ Cm be a generic context.


(∀X1,..., Xn ∈ C1
\Hm C(X1,..., Xn) ≈T \Hm C(Nil, ...,Nil))
🅘

\Hm C(Top1,...Top1) ≈T \Hm C(Nil, . . . Nil)
Proof The proof is divided into two parts:
⇓ Since ∀X1,..., Xn ∈ C1	\Hm C(X1,..., Xn) ≈T \Hm C(Nil, ...,Nil), it holds
obviously also for Top1. Hence \Hm C(Top1,...,Top1) ≈T \Hm C(Nil, ...,Nil).
⇑ We prove \Hm C(Nil, ...,Nil) ≤T \Hm C(X1,..., Xn) ≤T \Hm C(Top1,...,Top1). For Lemma A.1, each Xi for i = 1,...,n Xi ≺ Top1. Since ≺ is a pre- congruence for the operation of context, i.e., it is a congruence and a pre-order,
we have that
\Hm C(X1,..., Xn) ≺ \Hm C(Top1,...,Top1).
Hence, for Lemma A.2, \Hm C(X1,..., Xn) ≤T \Hm C(Top1,...,Top1).
A similar reasoning is done by noticing that Nil ≺ Xi for all i = 1,..., n. Hence, applying the previous lemmas, we have that \Hm C(Nil, ...,Nil) ≤T
\Hm C(X1,..., Xn).
Summing up we thus have \Hm C(Nil, ...,Nil) ≤T \Hm C(X1,..., Xn) ≤T
\Hm C(Top1,...,Top1) ≈T \Hm C(Nil, ...,Nil).  Hence \Hm C(X1,..., Xn) ≈T
\Hm C(Nil, ...,Nil).

Proposition 3.7 Let C ∈ Cm be a generic context.
\Hm C(Topn) ≈T \Hm C(N˜il) ⇔ \Hm C(Top1,...Top1) ≈T \Hm C(Nil, . . . Nil)


Proof We prove that the two contexts Topn and Top1 × ... × Top1
`	˛¸	x
are strong


bisimilar. Then for Lemma A.2, we conclude that they are also trace equivalent. Hence the two static characterizations coincide.
Hence, let R be a binary relation defined as follows:
R = {(Topn,Top1 × ... × Top1)}
`	˛¸	x
that we want to prove to be a bisimulation. Initially, (Topn,Top1 × ... × Top1) ∈ R 
`	˛¸	x
obviously.
If Topn −a˜→ Topn, where −a˜→=(a1,...,an), we have to prove that there exists C s.t.
Top1 × ... × Top1 −a˜→ C and (Topn, C) ∈ R.
`	˛n¸	x
For the semantics definition of Top1, we consider that the first component of the product performs a1, the second one a2, and so on. Hence, from the semantic

definition of Top1, we have that Top1 ai
Top1 for i = 1, .., n. Hence, the context C

we are looking for is Top1 × ... × Top1. Hence, the condition (Topn, C) ∈ R holds
`	˛¸	x
trivially.
If Top1 × ... × Top1 −a˜→ D we want to prove there exists Topn' s.t. Topn' −a˜→
`	˛¸	x
Topn and (D, Topn') ∈ R.	Since D, for the same reasoning made before, is
Top1 × ... × Top1 and Topn performs all the possible n-tuples of high action and
`	˛¸	x
goes into itself, the thesis follows directly from the definition of Topn.

Hence, being Topn and Top1 × ... × Top1
`	˛¸	x
bisimilar, since the bisimulation is


a congruence for contexts (see Theorem 2.13), we obtain that \Hm C(Topn) ∼
\Hm (C(Top1,...Top1)). Consequently, by Lemma A.2, we have \Hm (C(Topn)) ≈T
\Hm (C(Top1,...Top1)). Since \Hm (C(N˜il)) ≈T \Hm C(Nil, . . . Nil) trivially, we have the thesis.	 
