Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 319 (2015) 165–181
www.elsevier.com/locate/entcs

Bifibrational Functorial Semantics of Parametric Polymorphism
Neil Ghania, Patricia Johannb, Fredrik Nordvall Forsberga,
Federico Orsanigoa and Tim Revella
a University of Strathclyde, UK
b Appalachian State University, USA

Abstract
Reynolds’ theory of parametric polymorphism captures the invariance of polymorphically typed programs under change of data representation. Semantically, reflexive graph categories and fibrations are both known to give a categorical understanding of parametric polymorphism. This paper contributes further to this categorical perspective by showing the relevance of bifibrations. We develop a bifibrational framework for models of System F that are parametric, in that they verify the Identity Extension Lemma and Reynolds’ Abstraction Theorem. We also prove that our models satisfy expected properties, such as the existence of initial algebras and final coalgebras, and that parametricity implies dinaturality.
Keywords: Parametricity, logical relations, System F, fibred category theory.

Introduction
Strachey [30] called a polymorphic function parametric if its behaviour is uniform across all of its type instantiations. Reynolds [25] made this mathematically precise by formulating the notion of relational parametricity, in which the uniformity of parametric polymorphic functions is captured by requiring them to preserve all logical relations between instantiated types. Relational parametricity has proven to be a key technique for formally establishing properties of software systems, such as representation independence [1,6], equivalences between programs [15], and useful (“free”) theorems about programs from their types alone [31]. In this paper, we treat relational parametricity for the polymorphic λ-calculus System F [10], which forms the core of many modern programming languages and verification systems. Hermida, Reddy, and Robinson [14] give a good introduction to relational parametricity.
Since category theory underpins and informs many of the key ideas underlying modern programming languages, it is natural to ask whether it can provide a useful perspective on parametricity as well. Ma and Reynolds [19] developed the first

http://dx.doi.org/10.1016/j.entcs.2015.12.011
1571-0661/© 2015 The Authors. Published by Elsevier B.V.
This is an open access article under the CC BY-NC-ND license (http://creativecommons.org/licenses/by-nc-nd/4.0/).

categorical formulation of relational parametricity, but their models were complicated and challenging to understand. Moreover, Birkedal and Rosolini discovered that not all expected consequences of parametricity necessarily hold in their models (see [4]). Another line of work, begun by O’Hearn and Tennent [21] and Robinson and Rosolini [28], and later refined by Dunphy and Reddy [7], uses reflexive graphs to model relations and functors between reflexive graph categories to model types. This is the state of the art for functorial semantics for parametric polymorphism. Interpreting types as functors is conceptually elegant and Dunphy and Reddy show that this framework is powerful enough to prove expected results, such as the existence of initial algebras for strictly positive type expressions [5]. However, since reflexive graph categories are relatively unknown mathematical structures, much of this development has had to be carried out from scratch. We propose to instead take the more established fibrational view of logic from the outset, and thus to analyse
parametricity through the powerful lens of categorical type theory [16].
In doing so, we follow an extensive line of work by Hermida [12,13] and Birkedal and Møgelberg [4], who use fibrations to construct sophisticated categorical models not only of parametricity, but also of its logical structure in terms of Abadi-Plotkin logic [24]. Abadi-Plotkin logic is a formal logic for parametric polymorphism that includes predicate logic and a polymorphic lambda calculus, and thus requires significant machinery to handle. Using this machinery, Birkedal and Møgelberg are able to go beyond Dunphy and Reddy’s results and, for instance, prove that all positive type expressions — not just the strictly positive ones as for Dunphy and Reddy — have initial algebras. However, these impressive results come at the price of the complexity of the notions involved. Our aim is to achieve the same results in a simpler setting 1 , closer to Dunphy and Reddy’s functorial semantics. We end up with a notion of model in which each type is interpreted as an equality preserving fibred functor and each term is interpreted as a fibred natural transformation. This is quite similar to the models produced by the parametric completion process of Robinson and Rosolini [28] (see also Birkedal and Møgelberg [4, Section 8]) and to Mitchell and Scedrov’s relator model [20], but with a more general notion of relation given by a fibration. We thus combine the generality of Birkedal and Møgelberg’s fibrational models with the simplicity of Dunphy and Reddy’s functorial semantics.
Our central innovation is the use of biﬁbrations to achieve this “sweet spot” in the study of parametricity. This is not necessary for the deﬁnition of our framework, for which Lawvere equality [17] (i.e., opreindexing along diagonals only) suffices, but it helps considerably with both the concrete interpretation of ∀-types [9] and the handling of graph relations. At a technical level, our strongest result is to use our simpler framework to recover all the expected consequences of parametricity that Birkedal and Møgelberg [4] prove using Abadi-Plotkin logic. In particular, we go beyond Dunphy and Reddy’s result by deriving, this time with a functorial semantics, initial algebras for all positive type expressions, rather than just for strictly positive ones. Nevertheless, this paper is in no way intended as the final word on fibrational

1 We stress again that we are not trying to model all of Abadi-Plotkin logic, but rather only type systems involving parametric polymorphism. Indeed, with respect to Abadi-Plotkin logic, we could not hope to improve upon the results of Birkedal and Møgelberg [4], who give a sound and complete semantics.

parametricity. Instead, we hope the simple re-conceptualization of parametricity we offer here — replacing the usual categorical interpretations of types as functors and terms as natural transformations with their fibred counterparts — will open the way to the study of parametricity in richer settings, e.g., proof-relevant ones.
Structure of the paper: In Section 2 we give a short introduction to bifi- brations. We recall Reynolds’ relational interpretation of System F, the Identity Extension Lemma and the Abstraction Theorem in Section 3. We then extract bifibrational generalisations of these in Section 4, and construct our parametric models. In Section 5 we show that our models behave as expected by deriving initial algebras for all definable functors and proving that parametricity implies (di)naturality. Finally, we instantiate our framework to derive both “standard” and new models of relational parametricity in Section 6. Section 7 concludes and discusses future work.
A Fibrational Toolbox for Relational Parametricity
We give a brief introduction to fibrations; more details can be found in, e.g., [16].
Definition 2.1 Let U : E → B be a functor. A morphism g : Q → P in E is cartesian over f : X → Y in B if Ug = f and, for every gj : Qj → P in E with Ugj = f ◦ v for some v : UQj → X, there exists a unique h : Qj → Q with Uh = v and gj = g ◦ h. A morphism g : P → Q in E is opcartesian over f : X → Y in B if Ug = f and, for every gj : P → Qj in E with Ugj = v ◦ f for some v : Y → U Qj, there exists a unique h : Q → Qj with Uh = v and gj = h ◦ g.

We write f§
for the cartesian morphism over f with codomain P , and f P
for the

opcartesian morphism over f with domain P . Such morphisms are unique up to

isomorphism. If P is an object of E then we write f∗P for the domain of f§
and

Σf P for the codomain of f P .
Definition 2.2 A functor U : E → B is a ﬁbration if for every object P of E and every morphism f : X → UP in B, there is a cartesian morphism f§ : Q → P in E over f. Similarly, U is an opﬁbration if for every object P of E and every morphism

f : UP → Y in B, there is an opcartesian morphism f P
: P → Q in E over f . A

functor U is a biﬁbration if it is both a fibration and an opfibration.
If U : E → B is a fibration, opfibration, or bifibration, then E is its total category and B is its base category. An object P in E is over its image UP and similarly for morphisms. A morphism is vertical if it is over id. We write EX for the ﬁbre over an object X in B, i.e., the subcategory of E of objects over X and morphisms over idX . For f : X → Y in B, the function mapping each object P of E to f∗P extends to a functor f∗ : EY → EX mapping each morphism k : P → Pj in EY to the morphism
f∗k with kf§ = f§ f∗k. The universal property of f§ ensures the existence and
P	P′	P′
uniqueness of f∗k. We call f∗ the reindexing functor along f . A similar situation
holds for opfibrations; the functor Σf : EX → EY extending the function mapping each object P of E to Σf P is the opreindexing functor along f .

We write |C| for the discrete category of C. If U : E → B is a functor, then the discrete functor |U| : |E| → |B| is induced by the restriction of U to |E|. If n ∈ N, then En denotes the n-fold product of E in Cat. The n-fold product of U , denoted Un : En → Bn, is the functor defined by Un(X1, ..., Xn)= (UX1, ..., UXn).
Lemma 2.3 If U : E → B is a functor then |U| : |E| → |B| is a biﬁbration. If U is a (bi)ﬁbration then so is Un : En → Bn for any natural number n.	2
To formulate Reynolds’ relational parametricity categorically, we define the category
Rel of relations over Set and the relations fibration on Set [16].
Definition 2.4 The category Rel has triples (A, B, R) as objects, where A, B, and R are sets and R ⊆ A × B. A morphism (A, B, R) → (Aj, Bj, Rj) is a pair (f, g), where f : A → Aj and g : B → Bj, such that if (a, b) ∈ R then (fa, gb) ∈ Rj.
We write (A, B, R) as just R when A and B are immaterial or clear from context. Note that Rel is not the category whose objects are sets and whose morphisms are relations, which also sometimes appears in the literature. Each set A has an associated equality relation defined by Eq A = {(a, a) | a ∈ A}.
Example 2.5 The functor U : Rel → Set × Set sending (A, B, R) to (A, B) is called the relations ﬁbration on Set. To see that U is indeed a fibration, let (f, g): (X1, X2) → (Y1, Y2) be a morphism in Set × Set with UR = (Y1, Y2) for some R in Rel. If we define (f, g)∗R ⊆ X1 × X2 by (x1, x2) ∈ (f, g)∗R iff (fx1, gx2) ∈ R, then (f, g) is a cartesian morphism from (f, g)∗R to R over (f, g). It is also easy to see that U is an opfibration, with opreindexing given by forward image. Thus, U is a bifibration. We denote the fibre over (A, B) in the relations fibration on Set by Rel(A, B).
Definition 2.6 Let U : E → B and Uj : Ej → Bj be fibrations. A ﬁbred functor F : U → Uj comprises two functors F0 : B → Bj and F1 : E → Ej such that Uj F1 = F0 U and cartesian morphisms are preserved, i.e., if f is cartesian in E over g in B then F1f is cartesian in Ej over F0g in Bj. If Fj : U → Uj is another fibred functor, then a ﬁbred natural transformation η : F → Fj comprises two natural transformations η0 : F0 → Fj and η1 : F1 → Fj such that Uj η1 = η0 U .
0	1
In this paper we use fibred functors and fibred transformations to interpret System F types and terms, and show that under mild conditions this gives parametric models.

Reynolds’ Model of Relational Parametricity
We now describe Reynolds’ set-theoretic model of relational parametricity: first concretely, and then in terms of the relations fibration Rel → Set × Set. As Reynolds discovered, there are in fact no set-theoretic models if the meta-theory is classical logic [26], but the following makes sense in the (intuitionistic) internal language of a topos [22], or in the Calculus of Constructions with impredicative Set. Throughout, we assume a standard syntax for System F.

Semantics of Types
Reynolds presents two “parallel” semantics for System F: a standard set-based semantics [ ]]o, and a relational semantics [ ]]r. Given Γ ▶ T type, where the type context Γ contains |Γ| = n type variables, Reynolds defines interpretations [[T ]]o : |Set|n → Set and [T ]]r : |Rel|n(A, B) → Rel([[T ]]oA, [[T ]]oB) by structural induction on type judgements as follows:
Type variables: [Xi]]oA = Ai and [Xi]]rR = Ri
Arrow types:
[[T1 → T2]]oA = [[T1]]oA → [[T2]]oA
[[T1 → T2]]rR = {(f, g) | (a, b) ∈ [[T1]]rR ⇒ (fa, gb) ∈ [[T2]]rR}
Forall types:
[[∀X.T ]]oA = {f : Y [[T ]]o(A, S) | ∀Rj ∈ Rel(Aj, Bj) . (f Aj,f Bj) ∈ [[T ]]r(Eq A, Rj)}
S:Set
[[∀X.T ]]rR = {(f, g) | ∀Rj ∈ Rel(Aj, Bj) . (f Aj, gBj) ∈ [[T ]]r(R, Rj)}

The definitions of [[∀X.T ]]o and [∀X.T ]]r depend crucially on one another. Thus, we do not really have two semantics — one based on Set and one based on Rel — but rather a single semantics based on the relations fibration U : Rel → Set × Set. In other words, Reynolds’ definitions of [−]]o and [−]]r entail the following theorem:
Theorem 3.1 (Fibrational Semantics of Types) Let U be the relations ﬁbra- tion on Set. Every judgement Γ ▶ T induces a ﬁbred functor [[T ]] : |U||Γ| → U.
|Rel||Γ| 	[[T ]]r	/Re¸l
|U||Γ|	U
  
|Set||Γ| × |Set||Γ| 	/Se¸t × Set
[[T ]]o×[[T ]]o
2
Since the domain of [T ]]r is a discrete category, requiring that [T ] is a fibred functor amounts simply to requiring that the above diagram commutes. In particular, no preservation of cartesian morphisms by [T ]]r is needed. Reynolds does not give a functorial action of types on morphisms. This is reflected in the appearance of discrete categories in Theorem 3.1. As a result, Reynolds’ pointwise interpretation of function spaces is the exponential in the functor category |U||Γ| → U [27]. How parametricity treats the action on morphisms will become clear in Section 5.1; instead of acting on morphisms, the interpretation of types act on graph relations induced by morphisms. For now, we simply note that the use of discrete domains does not take us out of the fibrational framework; Lemma 2.3 ensures that [T ]] is a functor between fibrations. The Identity Extension Lemma (IEL) is key for many

applications of parametricity. It says that every relational interpretation preserves equality relations 2 :
Lemma 3.2 (IEL) If Γ ▶ T then [[T ]]r ◦ |Eq||Γ| = Eq ◦ [[T ]]o.	2

Semantics of Terms
Reynolds’ main result is his Abstraction Theorem, stating that all terms send related environments to related values. Reynolds first gives set-valued and relational interpretations of term contexts Δ = x1 : T1,..., xn : Tn by defining [[Δ]]o = [[T1]]o ×· · · × [[Tn]]o and [[Δ]]r = [[T1]]r ×· · · × [[Tn]]r. This defines a fibred functor [[Δ ] : |U||Γ| → U . Reynolds’ then interprets each judgement Γ; Δ ▶ t : T as a family of functions [t]]o : [[Δ ]oS → [[T ]]oS for each environment S ∈ |Set||Γ|. We omit the standard definition of [t]]o here. Finally, Reynolds proves:
Theorem 3.3 (Abstraction Theorem) Let A, B ∈ Set|Γ|, R ∈ Rel|Γ|(A, B), a ∈ [[Δ ]oA, and b ∈ [[Δ ]oB. For every term Γ; Δ ▶ t : T , if (a, b) ∈ [[Δ ]rR, then ([[t]]o A a, [[t]]o B b) ∈ [[T ]]rR. Or, more concisely, ﬁbrationally: every judgement Γ; Δ ▶ t : T is interpreted as a ﬁbred natural transformation ([[t]]o, [[t]]r): [[Δ ] → [[T ]].


|Rel||Γ|

|U||Γ|
[[Δ]]r


[[T ]]r

z˛Re l

U

[[Δ]]o×[[Δ]]o	z 

|Set||Γ| × |Set||Γ|
 [[tz]]o×[[t]]o  ˛Se t × Set
[[T ]]o×[[T ]]o
2

It is worthwhile to unpack the fibrational statement of the theorem: Since the domains of the functors [[Δ]]o and [T ]]o are discrete, the interpretation [t]]o actually defines a (vacuously natural) transformation [t]]o : [[Δ ]o → [[T ]]o. By the definition of morphisms in the category Rel, the existence of the (again, vacuously natural) transformation [t]]r over [t]]o × [[t]]o is exactly the statement that if (a, b) ∈ [[Δ]]rR, then ([[t]]o A a, [[t]]o B b) ∈ [[T ]]rR — the verbose conclusion of the theorem.
Reynolds’ original formulation of the Abstraction Theorem makes it seem at first glance as though it asserts a property of [t]]o. Surprisingly, however, our fibrational version makes it clear that the Abstraction Theorem actually states the existence of additional algebraic structure given by [t]]r and, more generally, the interpretation of terms as fibred natural transformations. Taking this point of view and exposing this heretofore hidden stucture opens the way to our bifibrational generalisation of Reynolds’ model.

2 Reynolds’ approach also handles “identity relations” that are not equality relations, such as the information order on domains. In this paper, like many others [2,4,13,24], we only treat equality relations. In future work, we hope to give an axiomatic account of “identity relations” similar to that of Dunphy and Reddy [7].

Bifibrational Relational Parametricity
Thus far we have only shown how to view Reynolds’ notion of parametricity in terms of the specific fibration U : Rel → Set × Set. We now generalise this to other fibrations. This requires that we generalise [−]]o and [−]]r in such a way that the IEL and the Abstraction Theorem hold, which in turn requires that we define equality functors for these other fibrations. The construction of equality functors is standard in any fibration with the necessary infrastructure [16], but we briefly describe it here for completeness. The first step is to note that the relations fibration from Example 2.5 arises from the subobject fibration over Set by so-called change of base (or pullback), and to generalise that construction.
Definition 4.1 Let U : E → B be a fibration and suppose B has products. The fibration Rel(U ): Rel(E ) →B × B is defined by the following change of base:
Rel(E )  q	/E ¸
Rel(U )	U
  
B× B ×	/B¸
We call Rel(U ) the relations ﬁbration for U , and call the objects of Rel(E ) relations on B, to emphasise that this construction generalises the relations fibration on Set. We say that a fibration U : E → B has ﬁbred terminal objects if each fibre EX of E has a terminal object, and if reindexing preserves these terminal objects. The map sending each object X of B to the terminal object in EX extends to a functor K : B → E called the truth functor for U . We can construct an equality functor for Rel(U ) from the truth functor for U as follows:
Definition 4.2 Let U : E → B be a bifibration with fibred terminal objects. If B has products, then the map X '→ ΣδX KX, where δX is the diagonal morphism δX : X → X × X, extends to the equality functor Eq : B → Rel(E ) for Rel(U ).
For this definition, it is enough to ask for opreindexing along diagonals δX only (this is what Birkedal and Møgelberg [4] do to model equality). When dealing with graph relations in Section 5.1, though, we will use all of the opfibrational structure to opreindex along arbitrary morphisms. Our definition specialises to the equality relation Eq A when instantiated to the relations fibration on Set. The equality functor is faithful, but not always full; a counterexample is the equality functor for the identity bifibration Id : Set → Set, which gives a model with ad hoc, rather than parametric, polymorphic functions. We thus assume in the rest of this paper that equality functors are full. This is reminiscent of Birkedal and Møgelberg’s [4] assumption that the fibration has very strong equality, i.e., that internal equality implies external equality, in the following sense: fullness says that if (f, g, α): 1 → Eq Y (i.e., α shows that f = g internally), then, since 1 = Eq 1B, (f, g, α)= (h, h, Eq h) for some h : 1B → Y (i.e., f = g externally). We use fullness of Eq at several places in Section 5 below.

We now show how to interpret arrow types and forall types as fibred functors with discrete domains. We then show that a particular class of such functors forms a λ2-fibration and thus a model of System F which is, in fact, parametric.
Interpreting Arrow Types
The definition of [T → U ]]o and [T → U ]]r in Section 3.1 is derived from the cartesian closed structure of Set and Rel, respectively. Moreover, the fibration U : Rel → Set × Set preserves the cartesian closed structure, so that [t]]r is over [[t]]o × [[t]]o as required by the Abstraction Theorem. Generalising from this fibration, we can model arrow types “parametrically” — i.e., in a way satisfying the Abstraction Theorem — in any fibration U : E → B in which E and B are cartesian closed categories (CCCs) and U preserves cartesian closedness.
Definition 4.3 A fibration U : E → B is an arrow ﬁbration if both E and B are CCCs, and U preserves the cartesian closed structure. A relations fibration Rel(U ) is an equality preserving arrow ﬁbration if it is an arrow fibration and Eq : B → Rel(E ) preserves exponentials.
One advantage of working with well-studied mathematical structures such as fibrations is that many of their properties can be found in the literature. This helps in determining when a relations fibration is an equality preserving arrow fibration:
Lemma 4.4 Let U : E → B be a biﬁbration with ﬁbred terminal objects and B be a CCC.
If Eq : B → Rel(E ) has a left adjoint Q, then Eq preserves exponentials iff Q satisﬁes the Frobenius property. Such a Q exists if U : E → B has full comprehension, Eq : B → Rel(E ) is full and B has pushouts.
If U : E → B is a ﬁbred CCC and has simple products (i.e., if, for every

projection πB : A × B → A in B, the reindexing functor π∗
has a right adjoint

and the Beck-Chevalley condition holds), then E is a CCC and U preserves the cartesian closed structure.	2
Change of base preserves simple products and fibred structure, so Rel(U ) is a fibred CCC with simple products if U is. Moreover, B× B is a CCC if B is. Lemma 4.4 thus derives structure in Rel(U ) from structure in U .
Interpreting Forall Types
We must generalise Reynolds’ definitions of [−]]o and [−]]r for forall types to relations fibrations in such a way that the Abstraction Theorem and IEL hold. The rules for type abstraction and type application suggest that we should interpret ∀ as right adjoint to weakening by a type variable. We may first try to look for such an adjoint on the base category, then another on the total category, and then try to link these adjoints. But this is the wrong idea; for the relations fibration of Example 2.5, this gives all polymorphic functions, not just the parametrically polymorphic ones. Instead, we require an adjoint for the combined fibred semantics.

Let |Rel(U )|n →Eq Rel(U ) be the category whose objects are equality preserving fibred functors from |Rel(U )|n to Rel(U ) and whose morphisms are fibred natural transformations between them. Then:
Definition 4.5 Rel(U ) is a ∀-ﬁbration if, for every projection πn : |Rel(U )|n+1 →
|Rel(U )|n, the functor ◦ πn : (|Rel(U )|n →Eq Rel(U )) → (|Rel(U )|n+1 →Eq Rel(U )) has a right adjoint ∀n and this family of adjunctions is natural in n.
We write ∀ for ∀n when n can be inferred. This definition follows, e.g., Dunphy and Reddy [7] by “baking the Identity Extension Lemma into” the definition of forall types — in the sense that the very existence of ∀ requires that if F is equality preserving then so is ∀F — rather than relegating it to a result to be proved post facto. If U is faithful, then Definition 4.5 can be reformulated in terms of more basic concepts using its opfibrational structure. The IEL then becomes a consequence of the definition, rather than an intrinsic part of it [9]. For the purposes of this paper, this abstract specification is enough.
Fibred functors with discrete domains form a parametric model
A λ2-fibration, i.e., a fibration p : G → S with fibred finite products, finite products in S, fibred exponents, a generic object Ω, and simple Ω-products, is a categorical model of System F. Seely [29] gives a sound interpretation of the calculus in such fibrations. We conclude this section with the following theorem:
Theorem 4.6 If Rel(U ) is an equality preserving arrow ﬁbration and a ∀-ﬁbration, then there is a λ2-ﬁbration in which types Γ ▶ T are interpreted as equality preserving ﬁbred functors [[T ]] : |Rel(U )||Γ| →Eq Rel(U ) and terms Γ; Δ ▶ t : T are interpreted as ﬁbred natural transformations [[t]]: [[Δ ] → [[T ]].	2
Note that Lemma 4.4 gives conditions for Rel(U ) to be an arrow fibration, and our other paper [9] similarly gives conditions for Rel(U ) to be a ∀-fibration. Unwinding the interpretation of System F in λ2-fibrations [29], we see that we get the following for every fibration U : E → B satisfying the hypotheses of the theorem: for every System F type Γ ▶ T and term Γ; Δ ▶ t : T , we get
a standard interpretation of Γ ▶ T as a functor [T ]]o : |B||Γ| → B;
a relational interpretation of Γ ▶ T as a functor [T ]]r : |Rel(E )||Γ| → Rel(E );
a proof of the Identity Extension Lemma in the form of Lemma 3.2, i.e., a proof that [T ] is equality preserving;
a standard interpretation of Γ; Δ ▶ t : T as a natural transformation [t]]o : [[Δ ]o → [[T ]]o; and
a proof of the Abstraction Theorem in the form of Theorem 3.3, i.e., a proof that Γ; Δ ▶ t : T has a relational interpretation as a natural transformation [[t]]r : [[Δ ]r → [[T ]]r over [t]]o × [[t]]o.
Theorem 4.6 also gives a powerful internal language [16], where base types in type context Γ are given by fibred functors |Rel(U )||Γ| →Eq Rel(U ), and base term

constants in term context Δ are given by fibred natural transformations [[Δ]] → [[T ]]. Thus, we can use this language to reason about our models using System F. This will be used in the proofs of Theorems 5.7 and 5.11 below.
Consequences of parametricity
We use our new framework to derive expected consequences of parametricity. This serves as a “sanity check” for our new bifibrational conceptualisation, and shows that our framework is powerful enough to derive the same results as, e.g., Birkedal and Møgelberg [4]. At a high-level, our proof strategies are often similar to the ones found in the literature, while the proofs of individual facts are necessarily specific to our setting, and often fibrational in nature.
Graph Relations
In the fibration U : Rel → Set × Set every function f : X → Y defines a graph relation ⟨f⟩ = {(x, y) | fx = y}⊆ X × Y . This generalises to the fibrational setting, where the graph of f : A → B is obtained by reindexing the equality relation on B.
Definition 5.1 Let U : E → B be a fibration with fibred terminal objects and products in B. The graph of h : X → Y in B is ⟨h⟩ = (h, idY )∗(Eq Y ) in Rel(E ).
The definition of ⟨h⟩ agrees with the set-theoretic one for the relations fibration on Set. Since reindexing preserves identities, ⟨idA⟩ = (idA, idA)∗(Eq A)= Eq A for any object A of B. In a bifibration, we can also define the graph of f : A → B in another, isomorphic way by using opfibrational structure to opreindex equality on A:
Lemma 5.2 (Lawvere [17]) If U : E → B is a biﬁbration with ﬁbred terminal objects that satisﬁes the Beck-Chevalley condition [16, Section 1.8.11], and if B has products, then the graph of h : X → Y can also be described by ⟨h⟩ = Σ(idX,h)(Eq X).2
Being able to describe graph relations in terms of either reindexing or opreindexing in any bifibration lets us use the universal properties of both when proving theorems about them. Graph relations are the key structures that turn morphisms in B into objects in Rel(E ) and, more generally, mediate the standard and relational semantics. The graph functor for Rel(U ): Rel(E ) →B × B is the functor ⟨ ⟩ : B→ → Rel(E ) mapping f : X → Y in B to ⟨f⟩ in Rel(E ). To see how ⟨ ⟩ acts on morphisms, recall that if f : X → Y and fj : Xj → Y j are objects of B→, then a morphism from f to fj is a pair of morphisms g : X → Xj and h : Y → Y j such that fj ◦ g = h ◦ f . The universal property of reindexing in Rel(U ) guarantees the existence of a unique morphism ⟨g, h⟩ : ⟨f⟩→ ⟨fj⟩ over (g, h) such that the following diagram commutes:
⟨f⟩  (f,id)§ /Eq¸Y

E !⟨g,h⟩
Eq h
  

⟨fj⟩
/Eq¸Y j
(f′,id)§

Lemma 5.3 If the underlying biﬁbration satisﬁes the Beck-Chevalley condition, then ⟨ ⟩ : B→ → Rel(E ) is full and faithful if Eq : B → Rel(E ) is.	2
The proof uses the opfibrational characterisation of the graph functor from Lemma 5.2. The main tool for deriving consequences of parametricity is the Graph Lemma, which relates the graph of the action of a functor on a morphism with its relational action on the graph of the morphism. Interestingly, although our setting is possibly proof-relevant (i.e., there can be multiple proofs that two elements are related), the following “logical equivalence” version of the Graph Lemma is strong enough for our applications. If U : E → B and Uj : Ej → Bj are fibrations, we write (Fo, Fr): Rel(U ) →Eq Rel(Uj) to indicate that functors (not necessarily fibred) Fo : B → Bj and Fr : Rel(E ) → Rel(Ej) are such that Rel(Uj) ◦Fr = (Fo ×Fo) ◦ Rel(U ), and (Fo, Fr) is equality preserving, i.e., Fr ◦ Eq = Eq ◦ Fo.
Theorem 5.4 (Graph Lemma) Assume the underlying biﬁbration satisﬁes the Beck-Chevalley condition, and let (Fo, Fr): Rel(U ) →Eq Rel(U ). For any h : X → Y in B, there are vertical morphisms φh : ⟨Foh⟩ → Fr⟨h⟩ and ψh : Fr⟨h⟩ → ⟨Foh⟩ in Rel(E ).	2
Our proof of the Graph Lemma is completely independent of the specific functor (Fo, Fr), and so in particular does not proceed by induction on the structure of types. This is a key reason why we can go beyond Dunphy and Reddy [7] and prove the existence of initial algebras of positive, rather than just strictly positive, type expressions.

Existence of Initial Algebras
Let F : C → C be an endofunctor. An F-algebra is a pair (A, kA) with A an object of C and kA : FA → A a morphism. We call A the carrier of the F -algebra and kA its structure map. A morphism h : A → B in C is an F-algebra homomorphism h : (A, kA) → (B, kB) if kB ◦ (Fh)= h ◦ kA. An F -algebra (Z, in) is weakly initial if, for any F -algebra (A, kA), there exists a mediating F -algebra homomorphism fold [A, kA]: (Z, in) → (A, kA). It is an initial F-algebra if fold [A, kA] is unique.
The literature contains other proofs that initial algebras exist in parametric models (e.g., [4,24]). Closest to our setting is Dunphy and Reddy [7], who show that strictly positive types have initial algebras. Under assumptions no stronger than theirs, we sharpen this result to all positive types, or, more generally, all functors on our parametric models that are strong (see below) and equality preserving.
Let F = (Fo, Fr) : Rel(U ) →Eq Rel(U ) be a functor (note that the domain of F is not discrete and that F need not preserve cartesian morphisms) with a strength t = (to, tr), i.e., a family of morphisms (to)A,B : A ⇒ B → FoA ⇒ FoB and (tr)R,S : R ⇒ S → FrR ⇒ FrS with (tr)R,S over ((to)A,B, (to)C,D) if R is over (A, B) and S is over (C, D), such that t preserves identity and composition. A functor with a strength is said to be strong. Because of the discrete domains, t is a natural transformation from ⇒ to F ⇒ F in |Rel(U )|2 →Eq Rel(U ), and thus α, β; · ▶ t : (α → β) → (F [α] → F [β]) represents the action of F on morphisms in

the internal language. All type expressions with one free type variable occurring only positively give rise to strong functors, but there are further examples of such functors, for instance if the model contains non-System F type constructions with natural functorial (and relational) interpretations — for example, those of dependent types in Set. We will show that an initial Fo-algebra exists. For this, we first construct a weak initial Fo-algebra, which can be done in any λ2-fibration. Using the internal language, we define Z by (Zo, Zr)= [[∀X.(F X → X) → X]].
Lemma 5.5 Zo is the carrier of a weak initial Fo-algebra (Zo, ino) with mediating morphism foldo[A, k] and Zr is the carrier of a weak initial Fr-algebra (Zr, inr) with mediating morphism foldr [A, k].	2
To show that foldo is unique, we use the graph relations from Section 5.1. Recall that a category with a terminal object 1 is well-pointed if, for any f, g : A → B, we have f = g iff f ◦ e = g ◦ e for all e : 1 → A. Like Dunphy and Reddy [7], we only consider well-pointed base categories; well-pointedness is used to convert internal language reasoning in non-empty contexts to closed contexts, so that we can apply semantic techniques such as Theorem 5.4.
Lemma 5.6 Assume that the underlying biﬁbration satisﬁes the Beck-Chevalley condition, and that Eq is full.
If B is well-pointed, then foldo[Zo, ino]= idZ.
For every Fo-algebra homomorphism h : (Zo, ino) → (A, kA), we have that
h ◦ foldo[Zo, ino]= foldo[A, kA].	2
The proofs of the two parts of Lemma 5.6 are similar: both use the graph functor to map commuting diagrams in B to morphisms in Rel(E ), and then use the Graph Lemma to see that these morphisms are Fr-algebras. Lemma 5.5 and Lemma 5.6 together now immediately imply the main result.
Theorem 5.7 If the underlying biﬁbration satisﬁes the Beck-Chevalley condition,
Eq is full, and B is well-pointed, then (Zo, ino) is an initial Fo-algebra.	2
We show in Section 6 that these hypothesis cannot be weakened. One may wonder if the above result can be strengthened to get not only an initial Fo-algebra, but also an initial Fr-algebra. Certainly this is possible for the relations fibration Rel → Set × Set, since relations in Rel are proof irrelevant: maps either preserve relatedness or not. This translates in the axiomatic bifibrational setting to requiring the fibration Rel(E ) →B × B to be faithful. When it is, the weak initial Fr-algebra is, in fact, initial: faithfulness implies the required uniqueness.
Existence of ﬁnal coalgebras
We can also dualise the proof from the previous section to show the existence of final coalgebras in the usual manner [11]. As usual, this requires us to first encode products and existential types in System F. We encode products as A × B =
∀Y.(A → B → Y ) → Y . This supports the usual pairing and projection operations,

as well as surjective pairing using parametricity. We encode existential types by
∃X.T = ∀Y.(∀X.(T → Y )) → Y . We can support introduction and elimination rules

Γ ▶ A type	Γ; Δ ▶ u : T [A/X] Γ; Δ ▶ ⟨A, u⟩ : ∃X.T (X)
Γ; Δ ▶ t : ∃X.T	Γ, Z; Δ,y : T [Z/X] ▶ s : S
Γ; Δ ▶ (open t as ⟨Z, y⟩ in s): S

with the conversion open ⟨A, t⟩ as ⟨Z, y⟩ in s = s[X/A, y/t] by defining ⟨A, t⟩ = ΛY.λf.f A t and open t as ⟨Z, y⟩ in s = tV (ΛZ.λy.s). Using parametricity we can prove the following commutation property and η-rule for existential types:
Lemma 5.8 Assume the underlying biﬁbration satisﬁes the Beck-Chevalley condi- tion, and that Eq is full.
Let Γ; Δ ▶ t : ∃X.T, let Γ, Z; Δ,u : T [Z/X] ▶ s : S and let Γ; Δ ▶ f : S → Sj
for a closed type Sj. Then [[f (open t as ⟨Z, u⟩ in s)]]o = [[open t as ⟨Z, u⟩ in f (s)]]o.
If Δ; Γ ▶ t : ∃X.T, then [[open t as ⟨Z, u⟩ in ⟨Z, u⟩]]o = [[t]]o.	2
If F : C → C is an endofunctor, an F-coalgebra is a pair (A, kA) with A an object of C and kA : A → FA a morphism. We call A the carrier of the F -coalgebra and kA its structure map. A morphism h : A → B in C is an F-coalgebra homomorphism h : (A, kA) → (B, kB) if kB ◦ h = Fh ◦ kA. An F -coalgebra (W, out ) is weakly ﬁnal if, for any F -coalgebra (A, kA), there exists a mediating F -coalgebra homomorphism unfold [A, kA]: (A, kA) → (W, out ). It is a ﬁnal F-coalgebra if unfold [A, kA] is unique. Let F = (Fo, Fr) : Rel(U ) →Eq Rel(U ) be a functor with a strength t. We show that the final Fo-coalgebra exists. Again, we first construct a weakly final coalgebra
by defining W = (Wo, Wr)= [[∃X.(X → F (X)) × X]].
Lemma 5.9 Wo is the carrier of a weakly ﬁnal Fo-coalgebra (Wo, outo) with medi- ating morphism unfoldo[A, k] and Wr is the carrier of a weakly ﬁnal Fr-coalgebra (Wr, outr) with mediating morphism unfoldr [A, k].	2
We proceed similarly to Lemma 5.6. This time, we use the opfibrational part of the Graph Lemma to construct Fr-coalgebras.
Lemma 5.10 Assume the underlying biﬁbration satisﬁes the Beck-Chevalley condi- tion, and that Eq is full.
For every Fo-coalgebra morphism h : (A, kA) → (B, kB) we have unfoldo[B, kB]◦
h = unfoldo[A, kA].
unfoldo[Wo, outo]= idWo .	2
Putting things together, we have constructed a final coalgebra.
Theorem 5.11 If the underlying biﬁbration satisﬁes the Beck-Chevalley condition, and if Eq is full, then (Wo, outo) is a ﬁnal Fo-coalgebra.	2
Parametricity Implies Dinaturality
We show that our axiomatic foundations can be used to prove that dinaturality can be deduced from parametricity. This is well-known in other settings (see, e.g., [4,

Section 5.1]), but we do it because i) it shows our foundation passes this test; and ii) it highlights again the use of bifibrations to give two definitions of the graph of a function both of which are used in the proof. First, the definition of dinaturality:
Definition 5.12 If F, G : Bop ×B → B are mixed variant functors, then a dinatural transformation t : F → G is a collection of morphisms tX : FXX → GXX indexed by objects X of B such that, for every g : X → Y of B, the following commutes:
F X,X  tX	/G¸X X


F Y X
F (idY ,g)	z 	/
 
G X,Y
G(g,idY )

F Y Y	tY	G¸Y Y
We note that our proof applies to all mixed variant functors with equality preserving liftings, not just strong such functors.
Theorem 5.13 Let (Fo, Fr), (Go, Gr): Rel(U )op × Rel(U ) →Eq Rel(U ). Further, let
0 : FoAA → GoAA be a family indexed by objects A of B, and t1 : FrRR → GrRR
be a family indexed by objects R of Rel(E ) such that if R is over (A, B), then t1 is
over (t0A, t0B). Then t0 is a dinatural transformation from Fo to Go.	2
Theorem 5.13 applies in particular to the interpretation of terms t : ∀X.FXX → GXX where F and G are given by type expressions with two free type variables, one occuring positively and one negatively. As is well known, dinaturality reduces to naturality when F and G are covariant.
Examples
The construction of examples remains delicate — for instance, there are no set- theoretic models with a classical meta-theory. We give five models: Examples 6.1, 6.3, 6.4 and 6.5 are to be regarded as being internal to the Calculus of Constructions with impredicative Set (with ¬¬-stable equality for Example 6.3), while Example 6.2 is internal to the category of ω-sets.
Before doing so, we take a moment to emphasise the generality of our framework. Considering different fibrations, we can derive parametric models with very different flavours. For example, changing the base category of the fibration corresponds to changing the ‘standard’ model in which we interpret types and terms. Changing the total category and the fibration (i.e., the functor itself) corresponds to changing the relevant notion of relational logic. We take advantage of the possibility of non-standard relations in Examples 6.2, 6.3 and Non-example 6.5.
Example 6.1 Reynolds’ set-theoretic model is an instance of our framework via the relations fibration on Set. The equality functor is full and faithful in this bifibration, and Set is well-pointed. Hence Theorems 5.7 and 5.13 ensure that initial algebras exist, and that all terms are interpreted as dinatural transformations.

Example 6.2 The PER model of Bainbridge et al. [2] is an instance of our frame- work, if bifibrations are understood as internal to the category of ω-sets, so that natural transformations are uniformly realised (see also Longo and Moggi [18] for a detailed construction of a model using a category of PERs internal to ω-sets). An object of the category PERN is a symmetric, transitive relation R ⊆ N × N. A morphism from R to S is a function f : N/R → N/S that is tracked by some partial recursive function φk : N ~ N, i.e., such that f ([n]R) = [φk(n)]S for all [n]R ∈ N/R. The appropriate notion of predicate with respect to a PER R is that of a saturated subset, i.e., a subset P ⊆ N such that P (x) and R(x, xj) implies P (xj). Saturated subsets form a bifibration over PERs with a full and faithful equality functor EqA = A. The CCC structure of PERN and SatRel is standard; a bijective pairing function ⟨ , ⟩ : N × N → N gives the product and recursion theory (the s-m-n Theorem) gives the exponential. The interesting case is that of forall types, which are interpreted as (cut-down, to ensure equality preservingness) intersections of PERs:
[[6X.F ]]oR¯ = {(n, k) ∈ R′:PER [[F ]]o(R¯, Rj)| for all Q : SatRel(S, T ).(n, n), (k, k)

∈ [[F ]]
(Eq ¯
¯	[[F ]]
(P¯, Q). Since PER
is also

well-pointed, Theorems 5.7 and 5.13 again apply.
Example 6.3 The previous models are well-known, but our framework also suggests new ones. A relation R ⊆ X × Y can be understood classically as a function from X × Y to Bool. (Constructively, this only covers decidable relations.) Here, Bool can be replaced with any constructively completely distributive [8] non-trivial lattice u of “truth values”, leading to “multi-valued parametricity”. For instance, the collection Ð(L) of all down-closed subsets of a complete lattice L is constructively completely distributive, and classically, we recover Bool as Ð(1). The category Fam(u) has objects (A, p), where A is a set and p : A → u is thought of as a u-valued predicate. The families fibration π : Fam(u) → Set is a bifibration with Σf (Q)(y)= supfx=y Q(x), fibred terminal objects (X, λ . T), where T is the greatest element of u, and comprehension given by {(A, p)} = p—1(T). Since u is complete, it is a Heyting algebra, so that π : Fam(u) → Set is a fibred CCC. Also, π has simple products given by Ππ(A × B, p)(a)= infx∈B p(a, b). By Lemma 4.4, Rel(π) is thus
an equality preserving arrow fibration. Finally, the interpretation of forall types is given by [6X.F ]]oA¯ = {f :  S:Set[[F ]]o(A¯, S) | infP :X×Y →U [[F ]]r(EqA¯, P ) = T} and [6X.F ]]rP¯ = infQ:X×Y →U [[F ]]r(P¯, Q). Distributivity is used to show that this
functor is equality preserving. Fullness of Eq is obvious by чч-stable equality.
The extra conditions we impose in Section 5 really are necessary: the following are examples of 6- and arrow-fibrations where Theorems 5.7 and 5.13 fail.
Non-example 6.4 Let G be a fixed (non-trivial) group, and consider the category of G-sets, i.e., the category with objects (X, ·X ), where X is a set and ·X : G×X → X is a group action. Morphisms are functions between the carrier sets that respect the group action. Together with equivariant (i.e., group action respecting) relations, this forms a bifibration that is a model of System F in the sense of Theorem 4.6. However, the category is not well-pointed, and we can see that this makes Theorem 5.7 fail in our setting: the interpretation of 6X . X → X is not the singleton G-set 1 as

expected, but instead contains all the elements of the group G. We conjecture that this non-example also extends to a constructive treatment of the category of nominal sets [23].
Non-example 6.5 The identity fibration Id : Set → Set models ad hoc polymor- phism: it is a 6- and arrow-fibration, but the equality functor Eq X = X × X is not full. This explains why Theorem 5.13 fails: [6X.T ]]o includes ad hoc polymorphic functions, so that e.g. [6X.X → X]]o contains non-natural transformations such as η, where ηBool(x)= чx and ηX (x)= x for X /= Bool.
Conclusions and future work
Our interpretation of types and terms as fibred functors and fibred natural transfor- mations shows that parametricity entails replacing the usual categorical semantics involving categories, functors, and transformations with one based on fibrations, fibred functors, and fibred transformations. The results in Section 5 show that our new approach based on biﬁbrations hits the sweet spot of a light structure that still suffices to prove key results. Work is ongoing in using the bifibrational framework to develop new notions such as proof-relevant parametricity, and higher order parametricity with interesting links to cubical sets that also appear in the semantics of Homotopy Type Theory [3].
Acknowledgement
We thank the reviewers of this and previous versions of the paper for their comments and suggestions. We especially thank Uday Reddy for extremely valuable advice and encouragement. Research supported by EPSRC grants EP/K023837/1 (NG, FNF), EP/M016951/1 (NG), NSF award 1420175 (PJ), and SICSA (FO).

References
Ahmed, A., D. Dreyer and A. Rossberg, State-dependent representation independence, in: POPL, 2009,
pp. 340–353.
Bainbridge, E. S., P. J. Freyd, A. Scedrov and P. Scott, Functorial polymorphism, Theoretical Computer Science 70(1) (1990), pp. 35–64.
	Bezem, M., T. Coquand and S. Huber, A model of type theory in cubical sets, in: Types for Proofs and Programs (TYPES 2013), Leibniz International Proceedings in Informatics 26 (2014), pp. 107–128.
Birkedal, L. and R. E. Møgelberg, Categorical models for Abadi and Plotkin’s logic for parametricity, Mathematical Structures in Computer Science 15 (2005), pp. 709 – 772.
Bo¨hm, C. and A. Berarducci, Automatic synthesis of typed lambda-programs on term algebras, Theoretical Computer Science 39 (1985), pp. 135–154.
	Dreyer, D., G. Neis and L. Birkedal, The impact of higher-order state and control effects on local relational reasoning, Journal of Functional Programming 22 (2012), pp. 477 – 28.
Dunphy, B. and U. Reddy, Parametric limits, in: LICS, 2004, pp. 242 – 251.
Fawcett, B. and R. J. Wood, Constructive complete distributivity I, Mathematical Proceedings of the Cambridge Philosophical Society 107 (1990), pp. 81–89.

Ghani, N., F. Nordvall Forsberg and F. Orsanigo, Parametric polymorphism — universally, in: WoLLIC, LNCS 9160 (2015).
Girard, J.-Y., P. Taylor and Y. Lafont, “Proofs and Types,” Cambridge University Press, 1989.
Hasegawa, R., Categorical data types in parametric polymorphism, Mathematical Structures in Computer Science 4 (1994), pp. 71–109.
	Hermida, C., “Fibrations, logical predicates and indeterminates,” Ph.D. thesis, University of Edinburgh (1993).
Hermida, C., Fibrational relational polymorphism (2006), draft. Available at http://maggie.cs.queensu. ca/chermida/papers/FibRelPoly.pdf.
Hermida, C., U. Reddy and E. Robinson, Logical relations and parametricity — a Reynolds programme for category theory and programming languages, ENTCS 303 (2014), pp. 149–180.
	Hur, C.-K. and D. Dreyer, A Kripke logical relation between ML and assembly, in: POPL, 2011, pp. 133–146.
Jacobs, B., “Categorical Logic and Type Theory,” Elsevier, 1999.
	Lawvere, F. W., Equality in hyperdoctrines and comprehension schema as an adjoint functor, Applications of Categorical Algebra 17 (1970), pp. 1–14.
Longo, G. and E. Moggi, Constructive natural deduction and its “omega-set” interpretation, Mathematical Structures in Computer Science 1 (1991), pp. 215–254.
Ma, Q. and J. C. Reynolds, Types, abstractions, and parametric polymorphism, part 2, in: MFPS, 1992,
pp. 1–40.
Mitchell, J. C. and A. Scedrov, Notes on sconing and relators, in: CSL, 1993 pp. 352–378.
O’Hearn, P. W. and R. D. Tennent, Parametricity and local variables, Journal of the ACM 42 (1995),
pp. 658 – 709.
Pitts, A., Polymorphism is set theoretic, constructively, in: CTCS, 1987 pp. 12 – 39.
Pitts, A., “Nominal Sets: Names and Symmetry in Computer Science,” Cambridge Tracts in Theoretical Computer Science 57, Cambridge University Press, 2013.
Plotkin, G. and M. Abadi, A logic for parametric polymorphism, in: TLCA, 1993 pp. 361 – 375.
Reynolds, J., Types, abstraction and parametric polymorphism, Information Processing (1983).
Reynolds, J., Polymorphism is not set-theoretic, in: Semantics of Data Types, 1984 pp. 145 – 156.
Robinson, E., Parametricity as isomorphism, Theoretical Computer Science 136 (1994), pp. 163–181.
	Robinson, E. and G. Rosolini, Reflexive graphs and parametric polymorphism, in: LICS, 1994, pp. 364 – 371.
Seely, R. A., Categorical semantics for higher order polymorphic lambda calculus, Journal of Symbolic Logic (1987), pp. 969 – 989.
Strachey, C., Fundamental concepts in programming languages, Higher Order Symbolic Computation
13 (2000), pp. 11–49.
Wadler, P., Theorems for free!, in: FPCA, 1989, pp. 347–359.
