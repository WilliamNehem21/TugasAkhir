	Electronic Notes in Theoretical Computer Science 203 (2008) 125–140	
www.elsevier.com/locate/entcs
Modifying Contracts with Larissa Aspects
David Stauch
Verimag, Centre ´equation - 2, avenue de Vignate, 38610 GIE`RES — France

Abstract
This paper combines two successful techniques from software engineering, aspect-oriented programming and design-by-contract, and applies them in the context of reactive systems. For the aspect language Larissa and contracts expressed with synchronous observers, we show how to apply an aspect asp to a contract C and derive a new contract C', such that for any program P which fulfills C, P with asp fulfills C'. We validate the approach on a medium-sized example.
Keywords:  Aspect-oriented programming, Design-by-contract, synchronous languages

Introduction
Synchronous Languages and Aspect-Oriented Programming
Aspect-oriented programming (AOP) offers facilities to a base language which aim at encapsulating crosscutting concerns. These are concerns that cannot be properly captured into a module by the decomposition offered by the base language. AOP languages express crosscutting concerns in aspects, and weave (i.e. compile) them in the program with an aspect weaver.
All the aspect extensions of existing languages (like AspectJ [7]) share two no- tions: pointcuts and advice. A pointcut describes, with a general property, the program points (called join points) where the aspect should intervene (e.g., all the methods of the class X, all the methods whose name contains visit, etc.). The advice specifies what has to be done at each join point (execute a piece of code before the normal code of the method, for instance).
Most existing aspect languages cannot be used in the context of reactive systems, because they lack the semantic properties needed for formal verification, and the programming languages used for reactive systems are often different from general- purpose programming languages. Therefore, we developed the aspect language La- rissa [1] as an extension to the synchronous programming language Argos. Argos is a hierarchical automata language, based on Mealy machines. It seems a good can- didate as a base language, as it is the simplest language with the parallel structure

1571-0661 © 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.05.015


true/err
a

Error
b	b/err


a.b	b


a.b
a.b
a.b	b
b

a/err
true/err
b	b/err
true/err
b
b/err

Error	b
b
Error
Error
b/err

: aMFF


: gMFF


Fig. 1. The contract for the MFF. Notations: in each automaton, the initial state is denoted with a little arrow; the label on transitions are expressed by “triggering condition / outputs”, e.g. a transition labelled by “a/b” is triggered when a is true and emits b. Negation is expressed with an overbar, and conjunction with a dot. The observers accept all traces that do not lead to state Error.
which we want to crosscut, and which is typical for synchronous languages. Larissa has strong semantic properties, like the preservation of equivalence between pro- grams. The approach presented in this paper strongly depends on these properties.
Synchronous Languages and Design-by-Contract
Design-by-Contract [14] is a design principle, originally introduced for object-orient- ed systems, where a method is specified by a contract. A contract is a specification in form of an implication between an assumption clause and a guarantee clause. A method fulfills its contract if after its execution, the guarantee holds if the assump- tion was true when the program was called.
Contracts have been adapted to reactive systems by [12]. Reactive systems constantly receive inputs from their environment, and emit outputs to it. Therefore, it seems natural to let assumptions restrict the inputs, and let guarantees ensure properties on the outputs. Additionally, what a program is allowed to do often depends to a large extent on previous occurrences of signals. A convenient way to express such temporal properties over input and output traces are observers. An observer [6] is a program that observes the inputs and the outputs of the program, without modifying its behavior, and computes a safety property (in the sense of safety/liveness properties as defined in [8]). Observers have a single output err, which is emitted to show that a trace is not accepted. They can be expressed in the same language as the program.
As an example, consider the following contract for a mono-stable flip-flop (MFF) with one input a and one output b. The contract is composed of an assumption, shown in Figure 1(a), which states that a’s always occur in pairs, and a guarantee consisting of two automata, shown in Figures 1(b) and (c), which are composed in parallel. The automaton in Figure 1(b) guarantees that a single b is never emitted, and the automaton in Figure 1(c) guarantees that when a occurs while no b is emitted, b is emitted in the next instant. The product of Figure 1(b) and Figure 1(c) is shown in Figure 1(d).
Combining Contracts and Aspects
AOP and design-by-contract can hardly be used concurrently. Obviously, the con- tract of a program is invalidated when an aspect is applied to it.  Consider the


1	class  c {
2	/∗ @assume i < 10 ∗/
3	/∗ @guarantee \result < 10 ∗/
4	int m( int  i ) { ... }
5	}
6
7	pointcut	pcm( int  i )  :  call ( int  c .m( int )) && args ( i ) ;
8
9	int around ( int  i )  :  pcm( i ) {
10	return  1 + proceed ( i + 1 );
11	}

Fig. 2. Example of a contract in presence of an AspectJ aspect.


AspectJ example in Figure 2. The pointcut (line 7) intercepts calls to method m (line 4), and the around advice (lines 9–11) modifies the intercepted calls by adding 1 to the argument, then calling m through the proceed statement, and adding 1 to the result. This modifies both the initial assumption (line 2) and guarantee (line 3) of m. However, we can give a new contract for m in this case. To ensure that m is called according to its initial specification, the assumption must be changed to i < 9. On the other hand, the value returned by m may be higher than specified by the original guarantee in the presence of the aspect: we can only guarantee that
\result < 11, provided m does not call itself recursively.
Deriving such new contracts appears to be an interesting approach to combine AOP and contracts. However, this seems very difficult for contracts for Java pro- grams and AspectJ, and it is not clear if meaningful contracts could be derived. In this paper, we present a way to derive new contracts for Argos programs and Larissa aspects. The idea is to apply an aspect asp to a contract C and obtain a new contract C', such that if P fulfills C, then Pa asp fulfills C'.
The remainder of the paper is structured as follows: Section 2 defines Argos and Larissa; Section 3 describes how to derive a new contract from a contract and an aspect; Section 4 validates the approach on a larger example; Section 5 describes related work; and Section 6 concludes. An extended version of this paper can be found at [15].


Argos and Larissa
This section presents a restriction of the Argos language [13], and the Larissa ex- tension [1]. Argos is defined as a set of operators on complete and deterministic input/output automata communicating via Boolean signals. The semantics of an Argos program is given as a trace semantics that is common to a wide variety of reactive languages.

Traces and Trace Semantics
Definition 2.1 [Traces] Let I, O be sets of Boolean input and output variables representing signals from and to the environment. An input trace, it, is a function: it : N −→ [I −→ {true, false}]. An output trace, ot, is a function: ot : N −→ [O −→ {true, false}]. We denote by InputTraces (resp. OutputTraces) the set of all input (resp. output) traces. A pair (it, ot) of input and output traces (i/o-traces for short) provides the valuations of every input and output at each instant n ∈ N . We denote by it(n)[i] (resp. ot(n)[o]) the value of the input i ∈I (resp. the output o ∈ O) at the instant n ∈ N .
A set of pairs of i/o-traces S = {(it, ot) | it ∈ InputTraces ∧ ot ∈ OutputTra- ces} is deterministic iff ∀(it, ot), (it', ot') ∈ S . (it = it') =⇒ (ot = ot'), and it is complete iff  ∀it ∈ InputTraces . ∃ot ∈ OutputTraces . (it, ot) ∈ S.
A set of traces is a way to define the semantics of an Argos program P , given its inputs and outputs. From the above definitions, a program P is deterministic if from the same sequence of inputs it always computes the same sequence of outputs. It is complete whenever it allows every sequence of every eligible valuations of inputs to be computed.

Argos
The core of Argos is made of input/output automata, the synchronous product, and the encapsulation. The synchronous product allows to put automata in parallel which synchronize on their common inputs. The encapsulation is the operator that expresses the communication between automata with the synchronous broadcast: if two automata are put in parallel, they can communicate via a signal s. The semantics of an automaton is defined by a set of traces, and the semantics of the operators is given by translating expressions into flat automata.
Definition 2.2 [Automaton] An automaton A is a tuple A = (Q, sinit, I, O, T ) where Q is the set of states, sinit ∈ Q is the initial state, I and O are the sets of Boolean input and output variables respectively, T ⊆ Q × Bool(I) × 2O ×Q is the set of transitions. Bool(I) denotes the set of Boolean formulas with variables in I. For t = (s, l, O, s') ∈ T , s, s' ∈ Q are the source and target states, l ∈ Bool(I) is the triggering condition of the transition, and O ⊆O is the set of outputs emitted whenever the transition is triggered. Without loss of generality, we consider that automata only have complete monomials as input part of the transition labels.
The semantics of an automaton A = (Q, sinit, I, O, T ) is given in terms of a set of pairs of i/o-traces. This set is built using the following functions:

S stepA : Q× InputTraces × N −→ Q
O stepA : Q× InputTraces × N \ {0} −→ 2O

S step(s, it, n) is the state reached from state s after performing n steps with the

input trace it; O step(s, it, n) are the outputs emitted at step n:

n = 0 : S stepA(s, it, n) = s
n > 0 : S stepA(s, it, n) = s'	O stepA(s, it, n) = O where ∃(S stepA(s, it, n − 1), l, O, s') ∈T 
∧ l has value true for it(n − 1) .

We note Traces(A) the set of all traces built following this scheme: Traces(A) defines the semantics of A. The automaton A is said to be deterministic (resp. complete) iff its set of traces Traces(A) is deterministic (resp. complete) (see Definition 2.1). Two automata A1, A2 are trace-equivalent, noted A1 ∼ A2, iff Traces(A1) = Traces(A2).
Definition 2.3 [Synchronous Product] Let A1 = (Q1,sinit1, I1, O1, T1) and A2 = (Q2, sinit2, I2, O2, T2) be automata. The synchronous product of A1 and A2 is the automaton A1  A2 = (Q1 × Q2, (sinit1, sinit2), I1 ∪ I2, O1 ∪O2, T ) where T is defined by:

(s1, l1, O1, s' ) ∈ T1 ∧ (s2, l2, O2, s' ) ∈ T2 ⇐⇒ (s1s2, l1 ∧ l2, O1 ∪ O2, s' s' ) ∈T .
1	2	1 2

The synchronous product of automata is both commutative and associative, and it is easy to show that it preserves both determinism and completeness.
Definition 2.4 [Encapsulation] Let A = (Q, sinit, I, O, T ) be an automaton and Γ ⊆I ∪ O be a set of inputs and outputs of A. The encapsulation of A w.r.t. Γ is the automaton A\ Γ = (Q, sinit, I\ Γ, O\ Γ, T ') where T ' is defined by:

(s, l, O, s') ∈T ∧ l+ ∩ Γ ⊆ O ∧ l− ∩ Γ ∩ O = ∅ ⇐⇒ (s, ∃Γ . l, O \ Γ, s') ∈T '

l+ is the set of variables that appear as positive elements in the monomial l (i.e. l+ = {x ∈ I | (x ∧ l) = l}). l− is the set of variables that appear as negative elements in the monomial l (i.e. l− = {x ∈I | (x ∧ l) = l}).

Intuitively, a transition (s, l, O, s') ∈T is still present in the result of the encap- sulation operation if its label satisfies a local criterion made of two parts: l+ ∩Γ ⊆ O means that a local variable which needs to be true has to be emitted by the same transition; l− ∩ Γ ∩ O = ∅ means that a local variable that needs to be false should not be emitted in the transition.
If the label of a transition satisfies this criterion, then the names of the encap- sulated variables are hidden, both in the input part and in the output part. This is expressed by ∃Γ . l for the input part, and by O \ Γ for the output part.
In general, the encapsulation operation does not preserve determinism nor com- pleteness. This is related to the so-called “causality” problem intrinsic to syn- chronous languages (see, for instance [2]).

Contracts for Argos
An observer is an automaton which specifies a class of programms fulfilling a certain safety property. It is formally defined as follows.
Definition 2.5 [Observer] An observer is an automaton (Q∪ {Error}, q0, I ∪ O,
{err},T ) which observes an automaton that has inputs I and outputs O. When an observer emits err, it will go to state Error and also emit err in the next instant. A program P is said to obey an observer obs (noted P |= obs) iff P obs \O produces
no trace which emits err.
Transitions leading to the Error state are called Error transitions.
A contract specifies a class of programs with two observers, an assumption and a guarantee. Definition 2.6 is an auxiliary definition, used to formally define contracts in Definition 2.7. ϵ denotes the empty trace.
Definition 2.6 [Trace Combination] Let it : N −→ [I −→ {true, false}] and ot : N −→ [O −→ {true, false}] be traces, with I ∩ O = ∅. Then, it.ot : N −→ [I∪ O −→ {true, false}] is a trace s.t. ∀i ∈I . it.ot (n)(i) = it (n)(i) ∧ ∀o ∈O . it. ot (n)(o) = ot (n)(o).
Definition 2.7 [Contract] A contract over inputs I and outputs O is a tuple (A,G) of two observers over I∪ O, where A is the assumption and G is the guarantee. A program P fulfills a contract (A,G), written P |= (A,G), iff
(it .ot , ϵ) ∈ Traces(A) ∧ (it, ot ) ∈ Traces(P ) ⇒ (it .ot , ϵ) ∈ Traces(G) .

Intuitively, a guarantee G should only restrict the outputs of a program and an assumption A should only restrict the inputs. We do not require this formally, but contracts which do not respect this constraint are of little use. Indeed, if G restricts the inputs more than A, it follows from Definition 2.7 that there exists no program P s.t. P |=(A,G). Conversely, a program is usually placed in an environment E, s.t. E |=A. If A restricts the outputs, no such E exists, as the outputs are controlled by P .

Larissa
Argos operators are already powerful. However, there are cases in which they are not sufficient to modularize all concerns of a program: a small modifications of the global program’s behavior may require that we modify all parallel components, in a way that is not expressible with the existing operators.
The goal of aspects being precisely to specify such cross-cutting modifications of a program, we proposed an aspect-oriented extension for Argos [1], which allows the modularization of a number of recurrent problems in reactive programs, like the reinitialization. This leads to the definition of a new operator (the aspect weaving operator), which preserves determinism and completeness of programs, as well as semantic equivalence between programs.





base program


b/c
c/JP

pointcut

Fig. 3. Example pointcut.

Similar to aspects in other languages, a Larissa aspect consists of a pointcut, which selects a set of join points, and an advice, which modifies these join points.

Join Point Selection
To preserver semantical equivalence, pointcuts in Larissa are not expressed in terms of the internal structure of the base program (as for instance state names), but refer to the observable behavior of the program only, i.e., its inputs and outputs.
Therefore, observers are well suited to express pointcuts. A pointcut is thus an observer which selects a set of join point transitions by emitting a single output JP, the join point signal. A transition T in a program P is selected as a join point transition when in the concurrent execution of P and the pointcut, JP is emitted
when T is taken.
Technically, we perform a parallel product between the program and the point- cut and select those transitions in the product which emit JP. However, if we simply put a program P and an observer PC in parallel, P ’s outputs O will become synchronization signals between them, as they are also inputs of PC. They will be encapsulated, and are thus no longer emitted by the product. We avoid this problem by introducing a new output o' for each output o of P : o' will be used for the synchronization with PC, and o will still be visible as an output. First, we transform P into P' and PC into PC', where ∀o ∈ O, o is replaced by o'. Second, we duplicate each output of P by putting P in parallel with one single-state automa- ton per output o defined by: duplo = ({q}, q, {o'}, {o}, {(q, o', o, q)}). The complete product, where O is noted {o1, ..., on}, is given by:
P(P, PC) = (P '  PC'  duplo  ...  duplo ) \ {o' , ..., o' }
1	n	1	n
The join point transitions are those transitions of P(P, PC) that emit JP.
Figure 3 illustrates the pointcut mechanism. The pointcut (b) specifies any transition which emits c: in base program (a), the loop transition in state B is selected as a join point transition.

Specifying the Advice
In aspect oriented languages, the advice expresses the modification applied to the base program. In Larissa, we define two types of advice: in the first type, an advice replaces the join point transitions with advice transitions pointing to an existing target states; in the second type, an advice introduces a Argos program between the source state of the join point transition and an existing target state. In both cases, target states have to be specified without referring explicitly to state names.
An advice adv has two ways of specifying the target state T among the existing



l2/Oins
toInit aspect	(b) toCurrent aspect
Fig. 4. Schematic toInit and toCurrent aspects. Advice transitions are in bold, join point transitions are dotted.

states of the base program P. T is the state of P that would be reached by executing a finite input trace from either the initial state of P, adv is then called toInit advice, or from the source state of the join point transition, adv is then called toCurrent advice. As the base program is deterministic and complete, executing an input trace from any of its states defines exactly one state.
The advice weaving operator a adv weaves a piece of advice adv in a program. Definition 3.2 in the following section gives a formal definition for toInit advice. The remainder of this section describes the different kinds of advice informally.

Advice Transitions
The first type of advice consists in replacing each join point transition with an advice transition.  Once the target state is specified by a finite input trace σ = σ1 ... σn, the only missing information is the label of these new transitions. We do not change the input part of the label, so as to keep the woven automaton deterministic and complete, but we replace the output part by some advice outputs Oad. These are the same for every advice transition, and are thus specified in the aspect. Advice transitions are illustrated in Figure 4.


Advice Programs
It is sometimes not sufficient to modify single transitions, i.e. to jump to another location in the automaton in only one step. It may be necessary to execute arbitrary code when an aspect is activated. In these cases, we can insert an automaton between the join point and the target state.
Therefore, we use an inserted automaton Ains that terminates. Since Argos has
no built-in notion of termination, the programmer of the aspect has to identify a final state F (denoted by filled black circles in the figures).
We first specify a target state T as explained above. Then, for every T, a copy of the automaton Ains is inserted, which means: 1) replace every join point transition J with target state T by a transition to the initial state I of this instance of Ains. As for advice transitions, the input part of the label is unchanged and the output
part is replaced by the advice outputs Oad; 2) connect the transitions that went to
the final state F in Ains to T. Advice programs are illustrated in Figure 5.




...
(a) inserted automaton Ains	(b) woven program
Fig. 5. Inserting an advice automaton.


a

true/b


true/b



a/b
a
a/b
a/b a/b

(a)	(b)
Fig. 6. A possible implementation of the MFF (a), with the retriggerable aspect applied to it (b).
Fully Specifying an Aspect
An aspect is given by the specification of its pointcut and its advice: asp = (PC, adv), where PC is the pointcut and adv is the advice. adv is a tuple which con- tains 1) the advice outputs Oad; 2) the type of the target state specification (toInit or toCurrent); 3) the finite trace σ over the inputs of the program; and optionally,
4) Padv, the advice program. Thus, advice can be a tuple < Oad,type, σ >, or, with
an advice program, a tuple < Oad,type,σ, Padv >, with type ∈ {toCurrent, toInit}. An aspect is woven into a program by first determining the join point transitions and then weaving the advice.
Definition 2.8 [Aspect weaving] Let P be a program and asp = (PC, adv) an aspect for P . The weaving of asp on P is defined by
Pa asp = P(P, PC)a adv .

Example
Consider the MFF example from Section 1.2. We now want to make the MFF re-triggerable, meaning that if an a is emitted during several following instants, the MFF continues emitting b.  We do this by applying the aspect ret= (PC,
< b, toInit, (a) >) to the MFF, where PC =({S},S,{a,b},{JP}, {(S,a.b,JP,S)}) is
a pointcut which selects all occurrences of a.b as join points. Figure 6(a) shows a sample implementation of the MFF, and Figure 6(b) shows the result of applying ret to it.

Weaving Aspects in Contracts
We want to apply an aspect asp not to a specific program, but to a class of programs defined by a contract C, and obtain a new class of programs, defined by a contract C', such that P |= C ⇒ P a asp |= C'.  To construct C', we simulate the effect

that the aspect has on a program as far as possible on the assumption and the guarantee observers of C. However, an aspect cannot be applied directly to an observer, because the aspect has been written for a program with inputs I and outputs O, whereas for the observer, O are also inputs.
Therefore, we transform the observers of the contract first into non-determinis- tic automata (NDA), which produce exactly those traces that the observer accepts. We then weave the aspects into the NDA, with a modified definition of the weaving operator. The woven NDA are then transformed back into observers. The obtained observers may still be non-deterministic, and are thus determinized.
Except for the aspect weaving, all of these steps are different for the assumption and the guarantee, as far as the Error transitions are concerned. This is because the assumption and the guarantee have different functions in a contract: the assumption states which part of the program is defined by the contract, and the guarantee gives properties that are always true for this part. Indeed, a contract (A,G) can be rewritten as (true,A ⇒G). Thus, the assumption can be considered as a negated guarantee.
After weaving an aspect, the assumption must exclude the undefined part of any program which fulfills the contract. Therefore, it must reject a trace (by emitting err) as soon as there exists a program for which it cannot predict the behavior. The guarantee, on the other hand, emits err only for traces which cannot be emitted by any program which fulfills the contract. Therefore, after weaving an aspect, the new guarantee may only emit err if it is sure that there exists no program that produces the trace.

Formal Deﬁnitions
This paragraph describes the weaving of aspects into contracts in detail, and illus- trates it on our running example. First, Definition 3.1 defines the transformation of an observer into a NDA through two functions, one for guarantee observers and one for assumption observers.
Definition 3.1 [Observer to NDA transformation] Let obs = (Q∪ {Error}, q0, I∪ O, {err},T ) be an observer with an error state Error over inputs I and outputs O, with I ∩ O = ∅. NDG(obs) = (Q, q0, I, O, TNDG ) defines a NDA, where TNDG
is defined by (s, lI ∧ lO, ∅, s') ∈ T ⇒ (s, lI, l+, s') ∈ TND . NDA(obs) = (Q∪ 

{Error}, q0, I, O, TNDA
O
) defines a NDA, where TNDA
G
is defined by (s, lI ∧lO, o, s') ∈

T ⇒ (s, lI, l+ ∪ o, s') ∈ TND .
O	G
Note that the transitions in obs which emit err (i.e. the Error transitions) have no corresponding transitions in NDG(obs). In the guarantee, these transitions correspond to input/output combinations which are never produced by the program and must not be considered by the aspect. As an example, consider the guarantee of the MFF (Figure 1(d)). Its transformation into a NDA is shown in Figure 7(a).
In the assumption, on the other hand, the Error transition correspond to inputs from the environment to which the program may react arbitrarily. If the aspect replaces these transitions in the assumption, they are also replaced in the program,

a
a
true/b
a, a/b a, a/b

a/b
a.b
b/err
a

a
true/b
true/b
a

a/b
a/b a/b
a/b
a/b
a.b

a.b

a.b
a.b
a.b
a.b
Error

b/err

true/b
(a)	(b)	(c)

Fig. 7. a: NDG(gMFF), b: NDG(gMFF)a ret, c: OBSG(NDG(gMFF)a ret).

a/b,err,
a/b,

a/b,err,	a.b a/err


a, a/b
a/err Error a, a/b

a, a/b
a/err Error a

a	a.b
Error


a, a/b	a, a/b	a
(a)	(b)	(c)
Fig. 8. a: NDA(aMFF), b: NDA(aMFF)a ret, c: OBSA(NDA(aMFF)a ret).

and can thus be accepted from the environment by the woven program. Thus, error transitions are not removed in NDA(obs), so that the aspect weaving can modify them. The transformation of the assumption of the MFF (Figure 1(a)) is shown in Figure 8(a).
We can now apply an aspect to a NDA. However, a trace may lead to several states. Thus, for each join point transition, several advice transitions must be created, one for each target state. We only give a definition for toInit advice, but the extension to toCurrent advice and advice programs is straightforward.
Definition 3.2 [toInit weaving for NDA] Let A = (Q, sinit, I, O, T ) be an automa- ton and adv = (Oadv, toInit, σ) a piece of toInit advice, with σ : [0, ..., lσ] −→ [I −→ {true, false}] a finite input trace of length lσ + 1. Let TARG = {s|s = S stepA(sinit, σ, lσ)} be the set of all states reachable with σ. The advice weaving operator a, weaves adv into A and returns the automaton Aa adv = (Q, sinit, I, O∪ Oadv, T '), where T ' is defined as follows:
 (s, l, O, s') ∈T ∧ JP ∈/ O  =⇒ (s, l, O, s') ∈T '	(1)
 (s, l, O, s') ∈T ∧ JP ∈ O =⇒ ∀targ ∈ TARG . (s, l, Oadv, targ) ∈T '	(2)

Transitions (1) are not join point transitions and are left unchanged. Transitions
(2) are the join point transitions, their final state targ is specified by the finite input trace σ. S stepA (which has been naturally extended to finite input traces) executes the trace during lσ steps, from the initial state of A. Figure 7(b) and Figure 8(b) show the NDAs from our example with the retriggerable aspect from Section 2.4.4 woven into them. For both NDAs, the trace leads to a single state, thus only one advice transition is introduced per join point transition.
Transforming a NDA back into an observer is different for assumptions and guarantees. In the assumption, we do not add additional error transitions, but only

leave those already there. In the guarantee, we add transitions to the error state from every state where the automaton is not complete. This is correct, as these transitions correspond to traces that are never produced by any program.
Definition 3.3 [NDA to guarantee transformation] Let nd = (Q, q0, I, O, T ) be a NDA. OBSG(nd) = (Q∪ {Error}, q0, I ∪ O, {err},T' ∪ T '') defines an observer, where T ' and T '' are defined by
(s, l, o, s') ∈ T ⇒ (s, l ∧ lo ∧ l	, ∅, s') ∈ T '	(3)

(s, l, ∅, s') ∈/ T ' ∧ s ∈Q ∧ l is a complete monomial over I∪ O
⇒ (s, l, {err}, Error) ∈ T ''
where lO =  o∈O o and lO =  o∈O o for a set O of variables.

(4)

Definition 3.4 [NDA to assumption transformation] Let nd = (Q, q0, I, O∪{err}, T ) be a NDA. OBSA(nd) = (Q, q0, I∪ O, {err},T') defines an observer, where T ' is defined by
(s, l, o ∪ e, s') ∈ T ∧ o ⊆O ∧ e ⊆ {err}⇒ (s, l ∧ lo ∧ lO\o, e, s') ∈ T '
Figure 7(c) and Figure 8(c) show the NDAs from our example transformed back into observers. As expected, the obtained guarantee in Figure 7(c) tells us that whenever the program receives an a, it emits b’s the two following instants. The assumption, however, requires that if an a is emitted, it continues to be emitted until there is no b.
The resulting observer may not be deterministic. However, it can be made deterministic, as observers are acceptor automata. Determinization for guarantees and assumptions is different: a guarantee must only emit err for a trace σ if all programs fulfilling the contract never emit σ, and an assumption must emit err if there exists a program fulfilling the contract which is not defined for σ.
Existing determinization algorithms can be easily adapted to fulfill these re- quirements. We do not detail such algorithms here, but instead give conditions the determinization for assumptions and guarantees must fulfill. The new assumption and the new guarantee in the example are already deterministic, thus there is no need to determinize them.
Definition 3.5 [Assumption Determinization] Let M be a NDA with outputs {err}.
Det A(M ) is a deterministic automaton such that
(it, ot ) ∈ Traces(Det A(M )) ⇔
(it, ot ) ∈ Traces(M ) ∧ ∄ot ' . ot '(n)[err] = true ∧ ot (n)[err] = false .
Definition 3.6 [Guarantee Determinization] Let M be a NDA with outputs {err}.
Det G(M ) is a deterministic automaton such that
(it, ot ) ∈ Traces(Det G(M )) ⇔
(it, ot ) ∈ Traces(M ) ∧ ∄ot ' . ot '(n)[err] = false ∧ ot (n)[err] = true .

Controller Inputs:	Controller Outputs:
Gangway Inputs:	Gangway Outputs:
Helper Signals Outputs:
Fig. 9. The interfaces of the controller and the gangway, and the helper signals.

We can now state the following theorem. See [15] for a proof.
Theorem 3.7 Let P be a program and let (A, G) be a contract. Then,

P |= (A, G)
⇒ Pa asp |= (Det A(OBSA(NDA(A)a asp)), Det G(OBSG(NDG(G)a asp)))

Example: The Tramway Door Controller
We implement and verify a larger example, taken from the Lustre tutorial [11], a controller of the door of a tramway. The door controller is responsible for opening the door when the tram stops and a passenger wants to leave the tram, and for closing the door when the tram wants to leave the station. Doors may also include a gateway, which can be extended to allow passengers in wheelchairs enter and leave the tram.
We implement the controller as an Argos program. We first develop a controller for a door without the gangway, and then add the gangway part with aspects. Figure 9 gives the in- and outputs of the controller with their specifications, and also the in- and outputs which are added by the gangway. The controller uses additional inputs, called Helper Signals, which are also shown in Figure 9. They are calculated from the original inputs, by a program given in [15].
It is important for the safety of the passengers that the doors are never open outside a station. We give a contract for the door controller, which focuses on this property. The guarantee of the contract is shown in Figure 10, it ensures that the controller emits doorOK only if the doors are closed, and openDoor only if the tram is in a station. The contract has also an assumption, which requires that the door behaves correctly (e.g., the door only opens if openDoor has been emitted). It is given in [15], along with an implementation of the controller.
To formally verify that a tram door is always closed outside a station, we develop

doorOK.(doorClosed∨openDoor)
Error
openDoor
openDoor

inStation.openDoor
In
inStation.openDoor
Out	Dep

doorClosed.doorOK.openDoor
Fig. 10. The guarantee of the contract of the controller.

gwOut


gwOut/extendGW
: Iext
: Iret

Fig. 11. Inserted automata for the extension (a) and the retraction (b) aspect.

a model that describes the possible behavior of the physical environment of the controller, i.e. the door and the tramway. These models are expressed as Argos observers, and are given in [15]. We then prove that the controller satisfies the contract, and that the contract in the environment never violates the safety property.

Adding The Gangway
Two aspects are used to add support for the gangway: one aspect that extends the gangway before the door is opened if a passenger has asked for it, and one aspect that retracts the gangway when the tram is about to leave, if it is extended.
The pointcut PCext of the extension aspect selects all transitions where open- Door.doorReq.doorClosed.gwOut is true, and the pointcut PCret of the retraction
aspect selects all transitions where doorOK.gwIn is true.
Both aspects insert an automaton and return then to the initial state of the join point transitions. The inserted automata for the aspects are shown in Figure 11. The extension aspect is specified by (PCext,< {}, toCurrent, (), Iext >), and the retraction aspect by (PCret,< {retractGW }, toCurrent, (), Iret >).
We want to check that the new controller still verifies the safety property from above, and also verifies two new safety properties, which require that the gangway is always fully retracted while the tram is out of station, and that the gangway is never moved when the door is not closed. Therefore, we weave the aspects into the contract, and thus obtain a new contract that holds for controller with the aspects. Finally, we check then that the environment, to which we added a model of the gangway, satisfies the new assumption, and that the new guarantee satisfies the safety requirements in the environment.
An alternative to this modular approach is to verify directly that the sample controller with the aspects does not violate the given safety properties. One dis- advantage of the alternative approach is that the woven controller may be much bigger than the woven contract. To illustrate this problem, we verified the safety properties using our implementation [9]. The source code of the door controller

example is available at [10]. Verifying the woven program takes 11.0 seconds 1 . On the other hand, weaving the aspects into the guarantee of the controller contract and verifying against the environment takes 3.7 seconds 1 , and verifying that the sample controller verifies the contract and verifying that the environment fulfills the assumption with the aspects takes < 0.5 seconds 1 . Thus, using this modular approach to verify the safety properties of the controller is significantly faster than verifying the complete program. Although the size of the woven controller is not prohibitive in this example, this indicates that larger programs can be verified using the modular approach.

Related Work
Goldman and Katz [5] modularly verify aspect-oriented programs using a LTL tableau representation of programs and aspects. As opposed to ours, their sys- tem can verify AspectJ aspects, as tools like Bandera [4] can extract suitable input models from Java programs. It is, however, limited to so-called weakly invasive aspects, which only return to states already reachable in the base program.
Clifton and Leavens [3] noted before us that aspects invalidate the specification of modules, and propose that either an aspect should not modify a program’s contract, or that modules should explicitly state which aspects may be applied to them.

Conclusion
We proposed a way to show exactly how a Larissa aspect modifies the contract of a component to which it is applied. This allows us to calculate the effect of an aspect on a specification instead of only on a concrete program. This approach has several advantages. First, aspects can be checked against contracts even if the final implementation is not yet available during development. Furthermore, if the base program is changed, the woven program must not be re-verified, as long as the new base program still fulfills the contract. Finally, woven programs can be verified modularly, which may allow for larger program to be verified, as indicates the example in Section 4.
We believe that the approach is exact in that it gives no more possible behaviors for the woven program than necessary. I.e., for a contract C and a trace t ∈ Traces(Ca asp), there exists a program P s.t. P |= C and t ∈ Traces(Pa asp). This remains however to be proven. A more interesting direction for future work would be to derive contracts the other way round. Given a contract C and an aspect asp, can we automatically derive a contract C' such that C' a asp |= C? Finally, the proposed approach works only because we have restricted Argos and Larissa to Boolean signals. It would be interesting to see if this approach can be extended to programs with valued signals or variables.

1 Experiments were conducted on an Intel Pentium 4 with 2.4GHz and 1 Gigabyte RAM.

References
K. Altisen, F. Maraninchi, and D. Stauch.  Aspect-oriented programming for reactive systems: a proposal in the synchronous framework. Science of Computer Programming, Special Issue on Foundations of Aspect-Oriented Programming, 63(3):297–320, 2006.
G. Berry and G. Gonthier. The Esterel synchronous programming language: Design, semantics, implementation. Sci. Comput. Programming, 19(2):87–152, 1992.
C. Clifton and G. T. Leavens. Obliviousness, modular reasoning, and the behavioral subtyping analogy. Technical Report 03-15, Iowa State University, Department of Computer Science, Dec. 2003.
J. C. Corbett, M. B. Dwyer, J. Hatcliff, S. Laubach, C. S. Pasareanu, Robby, and H. Zheng. Bandera: Extracting finite-state models from Java source code. In 22nd International Conference on Software Engineering, pages 439–448, June 2000.
M. Goldman and S. Katz. Modular generic verification of LTL properties for aspects. In Foundations of Aspect-Oriented Languages (FOAL), Mar. 2006.
N. Halbwachs, F. Lagnier, and P. Raymond. Synchronous observers and the verification of reactive systems. In M. Nivat, C. Rattray, T. Rus, and G. Scollo, editors, Algebraic Methodology and Software Technology, AMAST’93, June 1993.
G. Kiczales, E. Hilsdale, J. Hugunin, M. Kersten, J. Palm, and W. G. Griswold. An overview of AspectJ.
LNCS, 2072:327–353, 2001.
L. Lamport. Proving the correctness of multiprocess programs. ACM Trans. Prog. Lang. Syst., SE- 3(2):125–143, 1977.
Compiler for Larissa. http://www-verimag.imag.fr/∼stauch/ArgosCompiler/.
Argos source code for the tram example. http://www-verimag.imag.fr/∼stauch/ArgosCompiler/ contracts.html.
The Lustre tutorial. http://www-verimag.imag.fr/∼raymond/edu/tp.ps.gz.
F. Maraninchi and L. Morel. Logical-time contracts for reactive embedded components. In 30th EUROMICRO Conference on Component-Based Software Engineering Track, ECBSE’04, Rennes, France, Aug. 2004.
F. Maraninchi and Y. R´emond. Argos: an automaton-based synchronous language. Computer Languages, 27(1/3):61–92, 2001.
B. Meyer. Applying ”Design by Contract”. Computer, 25(10):40–51, 1992.
D. Stauch. Modifying contracts with Larissa aspects. Technical Report TR-2006-10, Verimag, Dec. 2006.
