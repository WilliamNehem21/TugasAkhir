Electronic Notes in Theoretical Computer Science 190 (2007) 3–25	
www.elsevier.com/locate/entcs

PEPA Queues: Capturing Customer Behaviour in Queueing Networks
Ashok Argent-Katwala	Jeremy T. Bradley1
Department of Computing Imperial College London London, United Kingdom

Abstract
Queueing network formalisms are very good at describing the spatial movement of customers, but typically poor at describing how customers change as they move through the network. We present the PEPA Queues formalism, which uses the popular stochastic process algebra PEPA to represent the individual state and behaviour of customers and servers. We offer a formal semantics for PEPA Queues, plus a direct translation to PEPA, allowing access to the existing tools for analysing PEPA models. Finally, we use the ipc/DNAmaca tool-chain to provide passage-time analysis of a dual Web server example.
Keywords: Stochastic process algebra, PEPA, Queueing networks


Introduction

Queueing theory is a well-established discipline, good at describing and analysing quantitatively many complex systems. There are well-known classes of queueing networks which have tractable solutions and many modellers find them a natural modelling formalism to capture resource contention and buffering.
However, while queueing networks are very good at representing the broad structure of a system, they are typically weak at describing the evolution of the individual customers within the network. Indeed, it is quite common to treat all customers as opaque, indistinguishable entities. These customers have no individual internal behaviour but may be segregated into a small set of static classes, when needed.
PEPA Queues [2] augment ordinary queueing networks by allowing customers to have individual behaviour. In this formalism, we use a stochastic process algebra,

1 Email: {ashok,jb}@doc.ic.ac.uk

1571-0661 © 2007 Published by Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2007.07.002

PEPA, to represent the local behaviour of the customers, the service centres and how they interact. Simple mechanisms from queueing theory describe the migration of customers between queues.
The PEPA Queues formalism is presented with an automatic translation directly into PEPA, giving access to the broad spectrum of existing tools available to analyse systems modelled in PEPA [9,6,12,3].
In Sect. 2 we introduce PEPA and PEPA nets. Sect. 3 gives an overview of what PEPA Queues can do, and how we can model some common mechanisms from queueing theory. Sect. 4 defines the syntax and behaviour of PEPA Queues, with a short example followed by the formal semantics. In Sect. 5, we show how we convert a system of PEPA Queues into an equivalent PEPA model. We show the benefit of maintaining spatial separation and local behaviour using PEPA Queues by modelling a dual Web server on an intranet in Sect. 6. We discuss future work and conclude in Sect. 7.

Background
PEPA
PEPA [11] is a parsimonious stochastic process algebra that can describe compo- sitional stochastic models. As in all process algebras, systems are represented in PEPA as the composition of components which undertake actions. In PEPA the actions are assumed to have a duration, or delay. Thus the expression (α, r).P denotes a component which can undertake an α action at rate r to evolve into a
component P . Here α ∈ A where A is the set of action types and P ∈ C where C is the set of component types. The rate r represents the parameter of an exponential distribution, and the duration is assumed to be a random variable.
PEPA has a small set of combinators, allowing system descriptions to be built up as the concurrent execution and interaction of simple sequential components. The syntax of the type of PEPA model considered in this paper may be formally specified using the following grammar:
S ::= (α, r).S | S + S | CS P ::= P D P | P/L | C
L
where S denotes a sequential component and P denotes a model component which executes in parallel. C stands for a constant which denotes either a sequential com- ponent or a model component as introduced by a definition. CS stands for constants which denote sequential components. The effect of this syntactic separation between these types of constants is to constrain legal PEPA components to be cooperations of sequential processes.
More information including the structured operational semantics for PEPA can be

found in [11]. A brief discussion of the basic PEPA operators is given below:
Prefix The basic mechanism for describing the behaviour of a system with a PEPA model is to give a component a designated first action using the prefix combinator, denoted by a full stop. As explained above, (α, r).P carries out an α action with rate r, and it subsequently behaves as P .
Choice The component P +Q represents a system which may behave either as P or as Q. The activities of both P and Q are enabled. The first activity to complete distinguishes one of them: the other is discarded. The system will behave as the derivative resulting from the evolution of the chosen component.
Constant It is convenient to be able to assign names to patterns of behaviour associated with components. Constants are components whose meaning is given by a defining equation. The notation for this is X = E. The name X is in scope in the expression on the right hand side meaning that, for example, X = (α, r).X performs α at rate r forever.
Hiding The possibility to abstract away some aspects of a component’s behaviour is provided by the hiding operator, denoted P/L. Here, the set L identifies those activities which are to be considered internal or private to the component and which will appear as the distinguished unknown type τ .
Cooperation We write P D  Q to denote cooperation between P and Q over L.
L
The set which is used as the subscript to the cooperation symbol, the cooper-
ation set L, determines those activities on which the components are forced to synchronise. The set L cannot contain the unknown type τ . For action types not in L, the components proceed independently and concurrently with their enabled
activities. We write P	Q as an abbreviation for P D  Q when L is empty.
L

In process cooperation, if a component enables an activity whose action type is in the cooperation set it will not be able to proceed with that activity until the other component also enables an activity of that type. The two components then proceed together to complete the shared activity with an appropriate rate. The capacity of a component P to perform an action α is denoted rα(P ), and is termed the apparent rate. PEPA respects the definition of bounded capacity : that is, a component cannot be made to perform an activity faster by cooperation, so the apparent rate of a shared activity in a cooperation is the minimum of the apparent rates of the activity in the cooperating components.

PEPA nets
A PEPA net [10] embeds PEPA components within a Petri net, allowing components to cooperate only when they are together on the net. This allows a clear description of systems where different pieces are mobile and move, for example, in and out of an area with network connectivity.
PEPA nets are essentially coloured stochastic Petri nets [1], where the colour of a

token is the state of a PEPA component. This state can change as the system evolves either independently, or in cooperation with their neighbouring components. The places on the net are typed with a component name; they may only be occupied by components that are derivatives of that type. Net-level transitions have associated action-types and rates. Components move in the net when a mobile component performs a net-level transition action, in cooperation with the net itself, to move into an appropriately typed empty slot.
PEPA nets are a good example of a higher level formalism. As well as having their own explicit semantics, they may also be compiled into PEPA, and so analysed with the existing array of PEPA tools. This inspires our approach for PEPA Queues, where we embed PEPA components in a queueing network, rather than a Petri net.
Just as PEPA nets bring the spatial advantages of Petri nets to stochastic modelling, so PEPA Queues offer similar advantages for queueing modellers. Both formalisms allow the expression of greater behavioural control over the tokens or customers.

Overview
When building a customer-oriented model of a queueing system in PEPA, it is often tempting to muddle the queueing behaviour with the descriptions of the individual agents. Where we have complex, migrant customers the elegance of the simple cooperations can be obscured by the scaffolding of where each customer is at present.
PEPA Queues encourage the modeller to keep local behaviour and movement sep- arate by representing the system as a network of queues, each of which has a local component, cooperating with the component at the head of the queue.
Note that the state of a PEPA Queue is given by the current state of each of the components waiting in the queue, in order, and the state of the local component. This cannot typically be represented by a vector of buffer occupancies, as would be the case with typical, opaque customers. It is instead akin to having a multi-class queueing network where the class does not influence the queueing discipline.
For example, consider the single PEPA Queue in Fig. 1. It has four places in its input buffer, the local component is Q and it cooperates with the head of the queue over the set of actions L. The state of the queue can be given as [P, P ', P,P ''], where P '' is at the head of the queue. For the moment, we are not concerned with the precise definitions of P , P ', P '' and Q, they are ordinary PEPA components. On service, the next customer in the buffer is promoted to replace the served customer.
 Q
L
Fig. 1. A single PEPA Queue

For simplicity, we restrict ourselves to closed networks of single-server queues using first-come first-served discipline. The queues all have fixed-size, finite buffers and the

network therefore has a fixed and finite population of customers. There are no losses when destination queues are full; queue services that lead to full queues are blocked. Handling open networks, unbounded buffers, triggers and negative customers is desirable, but the translation into PEPA of these entities is less straightforward. Here we focus on a simple core, which we can build upon in the future.
There are three distinct layers to a PEPA Queues model:
Customers PEPA components represent each individual customer. A customer may evolve internally, or in cooperation with the queue component when it is in service. It may not perform actions in the queue’s cooperation set unless it is in service.
Queues Each queue has a local server component which cooperates with the cus- tomer in service, over a declared set of actions. By performing routing actions, it determines when customers are despatched and to which queue they are sent. It may also cooperate with the local components at other queues, based on the cooperations defined in the queueing system equation.
Network routing We use PEPA cooperation to decide where components go after being served. Customers may only move to a particular destination queue if there is an open slot in that queue’s buffer, and the cooperation of the queue and the customer it is serving offer that routing action.

(redo,T)

(repeat,T)
Fig. 2. A small dairy shop, modelled with two PEPA Queues. Queue A comprises the four slot buffer and Sserve and queue B the two slot buffer and Still.

The formal syntax for a network of PEPA Queues is given in Sect. 4.1, and the structural operational semantics follow in Sect. 4.3. First, however, we look at a short example.

Example:	Dairy shop
A system with two queues, A and B, as depicted in Fig. 2. Pmilk and Peggs are customers who wish to buy milk and eggs respectively. Sserve and Still are the server components that hand out goods and take payment. The dashes represent empty slots in B’s buffer.
First, we examine the PEPA components that inhabit the network. The Pmilk and Peggs components are customers who begin waiting in queue A; each is trying to

purchase a different product and pay. The customers can do both actions all the time, and the proper sequence is ensured by how they proceed around the network.
Peggs d=ef (eggs, T).Peggs + (pay , T).Peggs
Pmilk d=ef (milk , T).Pmilk + (pay , T).Pmilk
The server components determine the routing of customers in the system. In the first queue the server may be out of stock of the lead customer’s item, in which case all the customers must wait for it to become available. This illustrates the interaction of having local state in the server and customer components.
Seggs d=ef (eggs, T).Snoeggs + (expire, eeggs).Snoeggs Snoeggs d=ef (restockeggs , reggs ).Seggs

S	d=ef (milk , T).S	+ (expire, e	).S Snomilk d=ef (restockmilk , rmilk ).Smilk
Swait d=ef (eggs, T).Ssending + (milk , T).Ssending

Ssending
d=ef (send , 9r ).S
10
wait
r
+ (redo, 10
).S
wait

Sserve def

eggs
|| Smilk)
D 
{milk,eggs}

Swait

S	d=ef (pay , T).(process , p).(repeat , s ).S
It is only when these components perform the queue routing actions (send, redo and repeat) that customers move between queues. These actions may be blocked in three circumstances:
there are no customers in the queue;
the routing action is in the queue’s cooperation set and the customer in service is not currently offering that action;
there is no space in the queue the routing action would lead to. Where the same action out of a queue leads to more than one queue, only the ones with space to move into are enabled, and PEPA’s competitive choice will select which route we take.
Now, we turn to the queueing network itself. While the picture is useful, we also want a clear, textual form capturing all of the information in the diagram. We need to define both the routing within the network and the state of the individual queues with their buffers. In order to refer to the queues, we give them names. Queue names are prefixed with “Q :”, which prevents a clash with any valid PEPA

names, since colons are not permitted in those. The pseudo-component prefixed with “QNet :” is the queueing system, describing the initial state of each queue, their local cooperation set and the system-level cooperation.
Fig. 2 can be fully described by:
Q: A d=ef (redo, T) → Q: A + (send , T) → Q: B Q: B d=ef (repeat , T) → Q: A

def
QNet: Sys = (Q : A[Pmilk, Peggs, Peggs, Pmilk]
D 
{eggs,milk ,pay }
Sserve)

|| (Q : B[—, —]	D 
{eggs,milk ,pay }
This syntax is defined in Sect. 4.1.
Still)

The first two lines of the specification define the destinations for customers when they are served. Services take place when the server component – possibly in coop- eration with the customer – performs any of these routing actions. In this example, all the action names are distinct but a modeller may use competitive choice to choose the destination instead.
We choose to use routing actions which are passive here, and have the server pro- cesses, Sserve and Still, determine the rates. This is just a modelling choice, and you could have the queueing network determine the rate, or use active-active synchroni- sation if that better fits the situation being modelled. If a routing action is included in a queue’s cooperation set, then the customer in service also influences its routing – the components may only perform the action together, just as with any PEPA cooperation. If they are not in the cooperation, any routing actions the customer performs are purely internal, and do not change the position of the customer within the queueing network.
Note that a properly formed network of PEPA Queues will not have any unresolved passive actions, where a component offers an action passively, but without cooper- ating over that action. This is the same restriction as in PEPA, but the modeller must also consider that customers move to places where the cooperation set may be different.
The last line of the specification is the queueing system equation. The square brackets contain the state of each queue’s buffer, with PEPA component names for customers or a dash representing an empty slot.
If a queue was simply a sink, it would be referred to in other queue routing equations, but not have one of its own, since it has no outbound transitions. There should perhaps be a more elegant way to represent this in the syntax.
For brevity in these descriptions, we also allow P ∗ n and —∗ n in the queue state description, to represent n copies of P and n spaces respectively. For mechanical simplicity later on, we allow the degenerate constructs of P ∗ 0 and — ∗ 0, which occupy no space in the queue’s buffer.

So, the queueing system equation above could be restated as:


QNet : Sys d=ef (Q : A[P	, P	∗ 2, P	]	D 
{eggs ,milk,pay }
Sserve)

|| (Q : B[—∗ 2]	D 
{eggs,milk ,pay }
Still)

Although we allow cooperations at the network level, they should be used with care. The intention is to use the queueing network to separate local behaviour from spatial migration. Allowing network-level interactions breaks this separation, but can be put to good use for inherently global actions like closing down the whole system, and a variety of forms of reset. Typically we would have, as in the example above, a straight parallel synchronisation between the queues.

Modelling features

PEPA Queues allow a succinct expression for many queueing mechanisms. For example, we could model breakdown and repair in a network of PEPA Queues as follows, allowing individual servers to fail and be repaired, or with a global reset if all the servers have failed. We omit the definition of the customers, P , for brevity.

S1 d=ef (reprocess , s1 ).S1 + (continue, s2 ).S1 + (break , rdown ).S'
S' d=ef (repair , rup ).S1 + (allrepair , rreset ).S1
S2 d=ef (route , s ).S' + (break , s	).S'
2	down	2
S' d=ef (repair , sup ).S2 + (allrepair , rreset ).S2
S3 d=ef (route , s ).S' + (break , sdown ).S'
3	3
S' d=ef (repair , sup ).S3 + (allrepair , rreset ).S3

Q: Pri d=ef (reprocess , T) '→ Q: Pri + (continue, T) '→ Q: Sec Q: Sec d=ef (route , T) '→ Q: Ter
Q: Ter d=ef (route , T) '→ Q: Pri

def
QNet: Sys = (Q: Pri[P, P]
D  S )
∅

D 
{allrepair }
D 
{allrepair }
(Q : Sec[—, —, —] D S )
∅
(Q : Ter[—, —, —] D S )
∅

Defining PEPA Queues
Syntax
The syntax for PEPA Queues is in two parts: routing between queues and a queueing-system description of the initial state of each queue. All of the components for customers and queue servers are specified in PEPA.
Each queue in a system is given a distinct name, which may be used only once in the final queueing system definition. Queue level routing is defined using an arrow combinator, addressing names of the queues, which all have a “Q:” prefix.
QName ::= Q: Name
QRoute ::= QName = QTransList QTransList ::= QTrans | QTrans + QTransList
QTrans ::= (α, r) —→ QName
Our queueing system description uses those Q: X names to define the initial position of the customers in each queue, the cooperation set they have with that queue and the cooperation set amongst the queues:
QSys	::= QNet : Name = QList
QList	::= QDef | QDef CoopSet QList
QDef	::= Q : Name [QCustNameList] CoopSet Name CustNameList ::= CustName | CustName , CustNameList
CustName	::= Name | — | Name ∗ Num | — ∗ Num

CoopSet	::=	D 
ActNameList
| ||

ActNameList ::= Name | Name , ActNameList

Behaviour of PEPA Queues
Before defining the formal semantics of PEPA Queues, and describing their mechan- ical conversion to PEPA, it is illuminating to consider how a network of PEPA Queues may evolve directly.
In any network of PEPA Queues, there are three sorts of transitions that can occur:
Local Any of the server or customer components may evolve independently, pro- vided the action is not in the cooperation set for that queue.
In-service cooperation The customer in service at a queue cooperates with the

stationary component at that queue. If this is a routing action, we treat it as below, otherwise it is treated as a local evolution of both components, at the appropriate combined rate.
Network-level A server transition can cause a customer to move in the network. This happens whenever a stationary component at a queue performs a service action. We move the customer that has been served to the first open slot in the target queue – that is the empty position that is closest to service. This ensures we never leave any blank spaces in a queue’s buffer.
Our aim with PEPA Queues is to give the modeller the expressive convenience of queueing models, while retaining much of the simplicity and all of the well- foundedness of PEPA.
We do this by converting PEPA Queues into PEPA. Every PEPA Queue model can be mechanically rewritten as a PEPA model with no change in its behaviour. Some of the structure of the original may be obscured in the compiled PEPA model, so tools will typically prefer to work with the PEPA Queues directly.
Translating to PEPA allows us to use a wide range of tools that already exist, as well as giving toolmakers and modellers who may want to work directly with PEPA Queues a precise definition of exactly how they behave.
Translating to PEPA is not the only way to analyse PEPA Queues. In future, we hope to also offer a translation directly into PEPA nets, preserving much of the spatial structure, which will allow smart PEPA nets tools to exploit spatial features in their analysis. If we create tools that handle PEPA Queues while retaining their structure, then a translation in the other direction – from PEPA nets to PEPA Queues – should be of use too. Further, tools that apply known queueing network results directly, in terms of the PEPA Queues structure, will allow much faster solution of many problems. This is a rich source of future work.

Semantics of PEPA Queues

Definition 4.1 The relation —→, operating over the set of component names. P —→ P means that P performs the action a at rate r and evolves into P . This is as defined in PEPA [11].
Definition 4.2 The relation '—→, operating over the set of named queues. Q: A '—→ Q: B means there is a queue routing action a at rate r leading from queue A to queue B.
Definition 4.3 The relation '—→, operating over the set of named queues. Q: A '—→
(a,r )
is equivalent to Q: B[Q: A '—→ Q: B], that is  is not a routing action for Q: A.
Definition 4.4 rα(P ) is the apparent rate function, as defined in [11].

Definition 4.5 r' (A) is a secondary apparent rate function, for queue routing actions. α must be a routing action for Q: A and r' (A) is the sum of the rates of all the enabled α-activities for Q: A in the present state.

Now we can specify individually all the legal ways a network of PEPA Queues can evolve. Throughout, each ellipsis signifies a (possibly empty) list of components that remains unchanged after the transition. IN denotes the positive integers, so
—∗ n below means that there is at least one empty slot in the queue’s buffer.
Customer alone
This rule governs a customer evolving independently, anywhere in the queue. Note that this only allows actions that are not in the queue’s cooperation set. Customers that are not in service may not perform those actions, and customers that are in service perform them via rule Local cooperation.
(α,λ) '

	P −→ P	
α∈/L

Q:A[...,P,...] D 
(α,λ)
'	D  S

S −→ Q:A[...,P ,...]
L	L
Server alone
The server process may perform actions not in the queue cooperation set indepen- dently, no matter the state of the buffer.
(α,λ) '

	S −→ S	
α∈/L

Q:A[...] D 
L
(α,λ)
S −→ Q:A[...]
D  S'
L

Local cooperation
Only the head of the queue may cooperate with the server process for actions in L, and they must perform them together.

P D 
(α,λ)
S −→ P
' D  S'

α
Q:A'−→/

	L	L	
α∈L

Q:A[...,P ] D 
(α,λ)
' D  S'

S −→ Q:A[...,P ]
L	L
Server routing 1
Declares that in order for a customer to move between queues, the server component at the first queue must perform a routing action, leading to a queue which has at least one space. The moved customer moves to the first empty slot. Where n is the largest such n to describe the blank spaces in Q : B. Routing actions may not appear in the inter-queue cooperation set, LQ.


(α,λ) '

(α,λq )

SA −→ SA	Q:A '−→ Q:B
α∈/L
, α∈/L
, n>0, R as below

(Q:A[...,P ]
D  SA)
LA
D  (Q:B[−∗n,...]
LQ
(α,R)	A	Q
SB ) −→
LB

(Q:A[−,...] D  S' ) D  (Q:B[−∗(n−1),P,...] D  S  )

LA  A  LQ
LB  B

Server routing 2
As Server routing 1 but where the routing action leads to the same queue. Note that we still need an empty slot, to avoid unduly prioritising local routing. Otherwise,

a customer could be allowed to move to the back of the queue it has just left when arrivals from other queues are disallowed.

(α,λ) '

(α,λq )

SA −→ SA	Q:A '−→ Q:A
α∈/L
, n>0, R as below

D	(α,R)
D  '	A

(Q:A[−∗n,...,P ]
LA
SA) −→	(Q:A[−∗n,P,...]
LA
SA )

Coop routing 1
For a routing action that is also in the queue’s cooperation set, the action must occur in cooperation between the lead customer and the queue’s server. Again, routing actions may not appear in the inter-queue cooperation set, LQ.

P D 

(α,λ)
' D  '

(α,λq )

SA −→ P
L	L
SA	Q:A '−→ Q:B


(Q:A[...,P ]
D  SA)
LA
D  (Q:B[−∗n,...]
LQ
(α,R)
SB) −→
LB
α∈LA, α∈/LQ, n>0, R as below

(Q:A[−,...] D  S' ) D  (Q:B[−∗(n−1),P ',...] D  S  )

LA  A  LQ
LB  B

Coop routing 2
Just as for Coop routing 1, but routing to the same queue. As with Server routing 2 we require an empty slot in the queue.

P D 

(α,λ)
' D  '

(α,λq )

SA −→ P
L	L
SA	Q:A '−→ Q:A

	A	A	
α∈LA, α∈LQ, n>0, R as below

Q:A[−∗n,...,P ] D  S
(α,R)
'	D  S'

A −→ Q:A[−∗n,P ,...]
LA	LA
For the last four rules:


	λ	λq 
R = r (S ) r' (A) min(rα
(SA
), r' (A)))



where R represents the rate of active cooperation between the service component and the queueing network. As in PEPA, it reflects the rate of the slower component in the cooperation.
Note that we do not allow cooperation between the queues for routing actions. If we did then we would be including a potentially interesting class of synchronised, coupled queues but at the expense of a substantially more complex translation. With our present translation, we use the names of the routing actions, decorated with where they are occurring to provide us with global, unique names for each of the routing actions. If we allowed cooperation at this level, we would need some other mechanism for migrating components. It may be possible to extend still further the information we carry in the expanded action names, but needing to represent which pair of processes is cooperating in the action name would lead to a large explosion in the number of names used. We could conceivably use a synchronous immediate action to achieve these coupled queues, but we would first need to define that concretely.

Translation to PEPA

We use a similar approach to that used to translate PEPA nets to PEPA, when translating PEPA Queues to PEPA. We encode the spatial portion of the model by having dormant versions of every component that may occupy a given location, and simply activate them when, in the higher level model, that component arrives in that particular location.
This is somewhat troublesome, since it leads to a large explosion in the number of components in the system, and we typically create both a huge model, textually, and a very large state space. However, it does mean that we can put to work existing tools for handling PEPA models, many of which can handle very large state spaces, with limits that are constantly improving.
Since the slots in our buffers are not typed in any way, we need a definition for each component that may occur, in every position it may occupy.

Translation detail
Any translation from PEPA Queues to PEPA will in general increase the number of component definitions by a factor of n(m + 1), in a system which has n queueing positions and m customer states. We need to distinguish between each of the n queueing slots being empty or having any one of the m customer components in.
With a clever encoding, we may be able to avoid representing unreachable states: for example where a particular customer could never reach part of the network. However, the cost of exploring the reachability, conditioned on the actions it may perform as it traverses the network, will be too high for non-trivial networks.
The basic structure of the translated model is as follows:
Each customer type is represented by many component definitions, one for each spatial state and derivative customer component that the customer could reach. There is one spatial state for each of the queueing positions.
The queueing transitions are split into a number of distinguishable action names, each leading to a particular slot in a queue. We replace each rout- ing action with a choice of several different, new actions which encode the destination. All the new actions happen at the same rate as the original and we then ensure that only one of them is active at once. When the same action is used to route to different destinations, each is expanded in this manner, and we use PEPA’s competitive choice to determine which route is used.
There is a population tracker component for each queue which tracks the num- ber of customers at that queue. The tracker component for a queue X with n slots would have n +1 states, QXpop0 to QXpopn . In each state it enables just the queue routing actions to ensure that customers are delivered to the first

available slot, and that no customers may join a full queue. To handle different queueing disciplines we would alter the actions these components enabled.
Note that to be allowed to move, the destination slot must be empty. This means that in the example from Sect. 3.1, when all four customers are in queue A, the redo action is disabled. Even though there would be a free slot after the lead customer moves, there is not one until then. If we allowed this form of movement it would give preferential treatment to customers coming from the same queue. That is, a customer would still be able to move to the back of its own queue, while arrivals from other queues were blocked.
The subscripts Xn on the routing actions indicate the current queue length at queue X, including any customer in service. So, on being served by this action, a customer would be placed in slot n +1 of queue X.
The full source of the translation of the dairy shop example can be found in Appendix A. It can be obtained by applying the following transformation.
Let Rin(X) be the set of routing actions in to queue X; Rout(X) be the routing actions out of queue X and Capacity(A) be the number of places in the buffer at queue A. QueueNames is the set of names of all the queues in the system.
The population trackers for a queue, A, are as follows. The index indicates the number of customers at the queue.



QApop0 =
Σ

a∈Rin(A)
(aA0 , T).QApop1

QApopi
def
Σ

a∈Rin(A)
(aAi
, T).QApopi +1
for 0 < i < Capacity(A)

+ Σ
(d,r)
A '−→ B
Capacity(B)−1

k=0

(dBk , T).QApopi −1


QApopCapacity (A)

def
Σ

(d,r)
A '−→ B
Capacity(B)−1 k=0

(dBk

, T).QApopCapacity (A)−1

The server components are altered to account for the expanded names of routing actions and to ensure that the local cooperation actions are distinct for each queue. So, for a server component, S, residing at queue A, we make a new component SA. The local cooperation set at A is LA. For each action-type, a, that S performs, there are three cases:
a ∈/ Rout(A) Λ a ∈/ LA
a ∈/ Rout(A) Λ a ∈ LA
a ∈ Rout(A)

For case 1, we do not need to modify the action at all. For case 2, we add the queue name to the action name, to ensure this action cannot occur when a customer is at a different queue. For case 3, we replace each occurrence of a with a choice of new action-types representing all the destination slots the action could lead to. We denote these four sets of action names L1, L2, L3 respectively.



def
A
Σ

(a,r )
S −→ S ∧a∈L1
+	Σ
(a,r ) '
(a, r ).S'

(aA, r ).S'

S −→ S ∧a∈L2
+	Σ
(a,r )
Capacity(B)−1

a	k=0

(aBk , r ).S'

S −→ S'∧a∈L3 A'−→B

We repeat the above translation for all the derivative states of S.
For each customer component, P, we make a version of that component in each queueing position of each queue. PA0 represents the customer, P, in service at queue A; PAi , for 1 ≤ i ≤ Capacity(A) is customer P waiting in position i of A. When in service, the translated component has all the behaviour of P, but routing
actions now lead to the next appropriate queueing position.
We partition the actions a customer performs into three sets at each queue, A:
A : Actions that are not in the local cooperation set and are not outbound routing
actions. a ∈/ LA Λ a ∈/ Rout(A).
A : Actions that are in the local cooperation set, but are not outbound routing
actions. a ∈ LA Λ a ∈/ Rout(A).
A : Actions that are outbound routing actions. a ∈ Rout(A).
The customer at the front gets to actually perform the actions, and change state.

For actions in LA
, waiting customers also perform the actions in a straightforward

manner. For actions in LA
waiting customers cannot perform them, but must

passively witness any of the local cooperation actions for any queue. Actions in
A	are the most complicated. Waiting customers must passively witness these
actions, then move forward to the place in front, but without changing their own local state, irrespective of the original definition of the customer component.



PA0

def
Σ

(a,r ) '
(a, r ).P'
A

P −→ P ∧a∈LC1
+	Σ

(aA, r ).P'

(a,r ) '	A
P −→ P ∧a∈LC2

Capacity(B)−1
+

(aBk , r ).P'

(a,r ) '	A	a
k=0

P −→ P ∧a∈LC3 ∧A'−→B

PAi
def
Σ

(a,r ) '
(a, r ).P'
A
for 1 ≤ i ≤ Capacity(A)

P −→ P ∧a∈LC1
+	Σ
Σ (aX , T).PAi

X∈QueueNames a∈LX
+	Σ

Capacity(B)−1

(aBk , T).PAi−1

(a,T) '	A	a
k=0

P −→ P ∧a∈LC3 ∧A'−→B
We use two different cooperation sets: LR, with just the routing actions; and
LSys with both the routing actions, and the local cooperating actions for each queue:

LR =	 
{cXi}

X∈QueueNames c∈Rin(X) 0≤i<Capacity(X)

LSys = LR ∪	 
{aX }

X∈QueueNames a∈LX
We build the final system equation from three major components, representing the state of the queues (QState), the migrant customers (Customers) and the stationary server components (Servers), respecting the initial states of each. Each represents the initial state of the system as described by the queueing network system equation.
Suppose that the queues are named A, B,... , Z, that the initial populations at each are a, b,... ,z and that our initial customers are a P at queue X at position i', through to a P' at queue Y at position j'. The cooperation set between all the queues is LQ .
QState d=ef QApopa D QBpopb ... D QZpopz


def
LR	LR
D	'

Customers = PXi'
LR
... PYj '

def
Servers = SA
LQ
B
till

Finally, we can write our system equation for the transformed model:
Sys d=ef QState D Customers D Servers
LSys	LSys
Worked Example
Consider a very simple model of a small intranet, with separate Web servers serving two clients, as depicted in Fig. 3. Each customer fetches a page from the first server with a getpage action, then goes to the second server for some related resources (the getimages action), before returning to the first server.

The server Spage doles out pages and the server Simages serves images. After Spage has issued a getpage, it releases the client from the first queue, A, with the send action, which routes the client on to the next queue, B (only if there is room in the downstream buffer for that client). The Simages server, after sending images to the client, then does some internal processing before issuing a repeat action which routes the client back to the first buffer again.
Clearly there is contention for the second buffer which can fill up and block client movement from the first buffer. In the quantitative analysis below, where we gener- ate passage-time distributions for the time from a getpage action to a repeat action, we will see that increasing the rate of the getpage action only has a limited effect on the overall passage.

(repeat,T)
Fig. 3. Two Web servers with two clients. The cooperation set, L = {getpage, getimages}


P d=ef (getpage , rgetpage ).P
P	d=ef (getimages, rgetimages ).P
Spage d=ef (getpage , T).(send , rsend ).Spage
Simages d=ef (getimages, T).(process , rproc ).(repeat , rrep).Simages
Q: A d=ef (send , T) → Q: B Q: B d=ef (repeat , T) → Q: A
QNet: Sys d=ef (Q : A[P, P] D  Spage) || (Q : B[—] D  Simages)
L	L
where L = {getpage, getimages}.




1.2


0.4


0.35

1
0.3


0.8	0.25




0.6


0.2


0.15

0.4
0.1


0.2	0.05




0
0	1	2	3	4	5	6	7	8	9	10
Time, t


0
0	1	2	3	4	5	6
Time, t


Fig. 4. Passage-time cumulative distribution func- tions from the first getpage action to the repeat action: for rgetpage = 0.01,0.5,1.0
Fig. 5. Passage-time density functions from the first getpage action to the repeat action: for rgetpage = 0.01,1.0, 100

In Fig. 4, we measure the cumulative distribution function of the passage from a getpage action until the next repeat using the ipc/DNAmaca toolset [3]. In increasing the rate of the getpage action, we see some benefit at first, rgetpage = 0.01 to 1.0. However, when plotting the density function of the same passage, we see that the time for the passage to complete also depends on the other rates and structures in the system. To move from queue A to B a customer must wait for an empty slot at queue B, then a send action to route it there. The next repeat action will only occur once the customer has performed the getimages action and can then perform a repeat to return to the first server. Hence in Fig. 5, we see that in looking at the passage for rgetpage = 100, we see that we don’t get a monotone improvement in probability of early passage completion as we see from rgetpage = 0.01 to 1.0, but instead the extra contention caused serves to worsen the overall passage metric.

Conclusions and Future Work

In this paper, we have introduced PEPA Queues, a formalism for expressing indi- vidual customer behaviour and routing in queueing networks. Queueing customers are described in PEPA, as are individual servers in the network, with interactions between customers and servers deciding the exact routing pathway for a customer. This synergy of a behavioural description and a spatial formalism is similar to PEPA nets but is obviously tailored to situations where queueing models would be a more appropriate spatial formalism.
We further presented an operational semantics for PEPA Queues in terms of an underlying PEPA model and presented a worked example of a simple web server system. We finished by demonstrating passage-time analysis across the worked example.
As described, PEPA Queues are restricted to closed networks of bounded queues, in keeping with PEPA’s handling of finite state spaces. It would also be desirable to handle unbounded queues, which will require further work to describe the semantics of the extended system.
The most appealing next step would be to exploit known queueing network prop- erties directly, for certain classes of PEPA Queue. By operating on a network of PEPA Queues directly, rather than in terms of their translation into PEPA, we could exploit known results – for example, separability in queueing networks. This is one of the appealing aspects of queueing networks, which can let us escape the typical state space explosion we have with Markovian modelling in general. There are also popular queueing network features which deserve further investigation:
Unbounded buffers and open networks Handling open networks with unbounded buffers could allow us to apply many known theoretical queueing results to our models. For the translation we would need to use a formalism that allows infinite, regular state spaces, for which there are existing extensions to

PEPA [2,4].
Sources and sinks In a sense, these are just queues with unbounded buffers. How- ever, if all our infinite queues have either no inputs or no outputs, then there is still a straightforward translation to PEPA which would follow the style of customer-centric models [5].
Inter-customer cooperation In some real-world systems, the customers may cooperate with one another in the queue. This may be a reasonable way to represent negative customers [8]. These cooperations could be just between neigh- bours or amongst all the customers awaiting service. Zero-automatic queues [7], for example, allow neighbouring customers of a shared group of classes to interact and coalesce into a single customer.
It would also be useful to offer translations into other formalisms where we can retain more of the inherent structure. We are investigating a translation into PEPA nets, to be followed by other suitable target systems.
We have introduced a basic syntax for defining networks of queues with embedded PEPA, together with a description of how to rewrite those models into PEPA.



References

Ajmone Marsan, M., G. Conte and G. Balbo, A class of generalized stochastic Petri nets for the performance evaluation of multiprocessor systems, ACM Transactions on Computer Systems 2 (1984),
pp. 93–122.
Argent-Katwala, A., “A compositional, collaborative performance pipeline,” Ph.D. thesis, Imperial College, London, United Kingdom (2006).
Bradley, J. T., N. J. Dingle, S. T. Gilmore and W. J. Knottenbelt, Derivation of passage-time densities in PEPA models using ipc: the Imperial PEPA Compiler, in: G. Kotsis, editor, MASCOTS’03, Proceedings of the 11th IEEE/ACM International Symposium on Modeling, Analysis and Simulation of Computer and Telecommunications Systems (2003), pp. 344–351.
Clark, G., “Techniques for the Construction and Analysis of Algebraic Performance Models,” Ph.D. thesis, Department of Computer Science, University of Edinburgh, Edinburgh EH9 3JZ, UK (1994).
Clark, G. and J. Hillston, Product form solution for an insensitive stochastic process algebra structure, Performance Evaluation 50 (2002), pp. 129–151.
Clark, G. and W. Sanders, Implementing a stochastic process algebra within the Mo¨bius modeling framework, in: L. de Alfaro and S. Gilmore, editors, Proc. of the 1st joint PAPM-PROBMIV Workshop, Lecture Notes in Computer Science 2165 (2001), pp. 200–215.
Dao-Thi, T.-H. and J. Mairesse, Zero-automatic queues, in: M. Bravetti, L. Kloul and G. Zavattaro, editors, EPEW/WS-FM, Lecture Notes in Computer Science 3670 (2005), pp. 64–78.
E. Gelenbe, E., Queuing networks with negative and positive customers, Journal of Applied Probability
28 (1991), pp. 656–663.
Gilmore, S. and J. Hillston, The PEPA workbench: A tool to support a process algebra-based approach to performance modelling, in: G. Haring and G. Kotsis, editors, Proceedings of the 7th International Conference on Modelling Techniques and Tools for Computer Performance Evaluation, Lecture Notes in Computer Science 794 (1994), pp. 353–368.


Gilmore, S., J. Hillston and M. Ribaudo, PEPA nets: A structured performance modelling formalism, in: A. Field et al., editor, Proceedings of the 12th International Conference on Modelling Tools and Techniques for Computer and Communication System Performance Evaluation, number 2324 in Lecture Notes in Computer Science (2002), pp. 111–130.
Hillston, J., “A Compositional Approach to Performance Modelling,” Distinguished Dissertations in Computer Science 12, Cambridge University Press, 1996.
Kwiatkowska, M. Z., G. Norman and D. Parker, Prism: Probabilistic symbolic model checker, in:
A. Field et al., editor, TOOLS’02, Proceedings of Computer Performance Evaluation: Modelling Techniques and Tools, Lecture Notes in Computer Science 2324 (2002).


A	Translation of example model
The original system from Sect. 3.1 in PEPA Queues: Peggs d=ef (eggs, T).Peggs + (pay , T).Peggs
P	d=ef (milk , T).P	+ (pay , T).P
Seggs d=ef (eggs, T).Snoeggs + (expire, eeggs).Snoeggs Snoeggs d=ef (restockeggs , reggs ).Seggs
Smilk d=ef (milk , T).Snomilk + (expire, emilk ).Snomilk Snomilk d=ef (restockmilk , rmilk ).Smilk
Swait d=ef (eggs, T).S	+ (milk , T).S

Ssending
d=ef (send , 9r ).S
10
wait
r
+ (redo, 10
).S
wait

Sserve d=ef (Seggs || Smilk)	D 
Swait

S	d=ef (pay , T).(process , p).(repeat , s ).S
Q: A d=ef (redo, T) → Q: A + (send , T) → Q: B Q: B d=ef (repeat , T) → Q: A

def
QNet: Sys = (Q : A[Pmilk, Peggs, Peggs, Pmilk]
D 
{eggs,milk ,pay }
Sserve)

|| (Q : B[—, —]	D 
{eggs,milk ,pay }
Still)

Our flat PEPA model uses two cooperation sets:
LR = {repeatA0 , repeatA1 , repeatA2 , redoA0 , redoA1 , redoA2 , sendB0 , sendB1 }
LSys = LR ∪ {eggsA, milkA, payA, eggsB , milkB , payB }
The population trackers for the two queues:
QApop0 = (repeatA0 , T).QApop1
QApop1 = (repeatA1 , T).QApop2 + (redoA1 , T).QApop1
+(sendB0 , T).QApop0 + (sendB1 , T).QApop0

QApop2 = (repeatA2 , T).QApop3 + (redoA2 , T).QApop2
+(sendB0 , T).QApop1 + (sendB1 , T).QApop1
QApop3 = (repeatA3 , T).QApop4 + (redoA3 , T).QApop3
+(sendB0 , T).QApop2 + (sendB1 , T).QApop2
QApop4 = (sendB0 , T).QApop3 + (sendB1 , T).QApop3
QBpop0 = (sendB0 , T).QBpop1
QBpop1 = (sendB1 , T).QBpop2
+(repeatA0 , T).QBpop0 + (repeatA1 , T).QBpop0
+(repeatA2 , T).QBpop0 + (repeatA3 , T).QBpop0
QBpop2 = (repeatA0 , T).QBpop1 + (repeatA1 , T).QBpop1
+(repeatA2 , T).QBpop1 + (repeatA3 , T).QBpop1
The server components:


A
eggs
d=ef (eggsA, T).SA
+ (expire, eeggs ).SA

A
noeggs
d=ef (restockeggs , reggs ).SA



A
milk
A
nomilk
d=ef (milkA, T).SA d=ef (restockmilk , r
+ (expire, emilk ).SA
A
milk



A
wait
d=ef (eggsA, T).SA
+ (milkA, T).SA

SA	d=ef (send
, 9r ).SA
+ (send
, 9r ).SA

sending
B0
+(redoA0
+(redoA2
10
r
, 10
r
, 10
wait
A
wait
A
wait
B1
+ (redoA1
+ (redoA3
10
r
, 10
r
, 10
wait
A
wait
A
wait

SA	def	A	A
D	A

serve = (Seggs || Smilk) {milk
,eggsA
} Swait



B
till
B
till0
B
till1
d=ef (payB , T).SB d=ef (process , p).SB d=ef (repeatA0 , s ).SB
(repeatA2 , s ).SB


+ (repeatA1 , s ).SB +
+ (repeatA3 , s ).SB

So the initial state, from the queueing network system equation, is: QState d=ef QApop3 D QBpop0
LR

def  A	B
Servers = Sserve || Still

Note that each occurrence of a routing action is expanded into a choice of all the variants of that action, and that we have named the anonymous sub-components of Still to facilitate this.
The customer components:


A1
eggs
d=ef (eggsA, re ).PA1
+ (payA, pe ).PA1
+ (sendB0 , T).PB1

+(redoA1 , T).PA2
+ (redoA2 , T).PA3
+ (redoA3 , T).PA4

A2
eggs
d=ef (eggsA, re ).PA2
+ (payA, pe ).PA2
+ (sendB0 , T).PB1

+(redoA1 , T).PA2
+ (redoA2 , T).PA3
+ (redoA3 , T).PA4

A3
eggs
d=ef (eggsA, re ).PA3
+ (payA, pe ).PA3
+ (sendB0 , T).PB1

+(redoA1 , T).PA2
+ (redoA2 , T).PA3
+ (redoA3 , T).PA4

A4
eggs
d=ef (eggsA, re ).PA4
+ (payA, pe ).PA4
+ (sendB0 , T).PB1 +

(redoA1 , T).PA2
+ (redoA2 , T).PA3
+ (redoA3 , T).PA4

B1
eggs
d=ef (eggsB , re ).PB1
+ (payB , pe ).PB1
+ (repeatA0 , T).PA1

+(repeatA1 , T).PA2
+ (repeatA2 , T).PA3
+ (repeatA3 , T).PA4

B2
eggs
d=ef (eggsB , re ).PB2
+ (payB , pe ).PB2
+ (repeatA0 , T).PA1

+(repeatA1 , T).PA2
+ (repeatA2 , T).PA3
+ (repeatA3 , T).PA4

A1
milk
d=ef (milkA, rm ).PA1
+ (payA, pm ).PA1
+ (sendB0 , T).PB1

+(redoA1 , T).PA2
+ (redoA2 , T).PA3
+ (redoA3 , T).PA4

A2
milk
d=ef (milkA, rm ).PA2
+ (payA, pm ).PA2
+ (sendB0 , T).PB1

+(redoA1 , T).PA2
+ (redoA2 , T).PA3
+ (redoA3 , T).PA4

A3
milk
d=ef (milkA, rm ).PA3
+ (payA, pm ).PA3
+ (sendB0 , T).PB1

+(redoA1 , T).PA2
+ (redoA2 , T).PA3
+ (redoA3 , T).PA4

A4
milk
d=ef (milkA, rm ).PA4
+ (payA, pm ).PA4
+ (sendB0 , T).PB1

+(redoA1 , T).PA2
+ (redoA2 , T).PA3
+ (redoA3 , T).PA4

B1
milk
d=ef (milkA, rm ).PB1
+ (payA, pm ).PB1
+ (repeatA0 , T).PA1

+(repeatA1 , T).PA2
+ (repeatA2 , T).PA3
+ (repeatA3 , T).PA4

B2
milk
d=ef (milkA, rm ).PB2
+ (payA, pm ).PB2
+ (repeatA0 , T).PA1

+(repeatA1 , T).PA2
+ (repeatA2 , T).PA3
+ (repeatA3 , T).PA4


Again, using we derive the initial state of the customers from the system equation of the PEPA Queues model:

def
A4  D 
A3  D 
A2  D  A1

Customers = Pmilk L

Sys
Peggs L

Sys
Peggs L

Sys
Pmilk

So the system equation for the transformed model is:

def
Sys = QState
D 
LSys
Customers
D 
LSys
Servers
