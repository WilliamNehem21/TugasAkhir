

Electronic Notes in Theoretical Computer Science 229 (2009) 85–106
www.elsevier.com/locate/entcs

Structural Operational Semantics with First-Order Logic
Muck van Weerdenburg1 Michel A. Reniers2
Computer Science
Eindhoven University of Technology (TU/e) Eindhoven, The Netherlands

Abstract
We define a formalism for Structural Operational Semantics (SOS) with first-order-logic formulas as premises. It is shown that in most uses (including all practical uses) this formalism has the same expres- sivity as SOS without first-order logic. Furthermore, we give a congruence format for (strong) bisimilarity. The latter is shown to be strongly related to the ntyft/ntyxt format.
Keywords: SOS, First-Order Logic, Expressiveness, Congruence.


Introduction
The use of Structural Operational Semantics (SOS) [17] to define semantics is widespread. In particular their effectiveness to define Transition-System Specifica- tions (TSSs) [9] has played a role in this. Various flavours of SOS have been defined, including meta-theories on these specific flavours. The latter have given us formats that, if adhered to, guarantee well-definedness or congruence of equivalences, for example. In [1,14] overviews are given of the existing meta-theory involving SOS.
Recently, in [13], an attempt was made to extend TSSs with quantification over the variables that appear in a deduction rule and to define a congruence format for bisimilarity of such TSSs. The authors’ motivation is mainly theoretical although they also refer to some specific examples in the literature [2,3,15,18] that make use of such TSSs. One of the two examples that is explicitly considered in [13] is the
weak termination predicate of [2], which is defined by the following rules. (The other
example is but a minimal variation on this.)

1 Email: M.J.van.Weerdenburg@tue.nl
2 Email: M.A.Reniers@tue.nl

1571-0661 © 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.07.075





p C ⇔
⎧⎨ (i)	p ~τ
⎩ (ii)	p →τ

and pC, or
and, for each q, p →τ



q implies q C.

In traditional uses of SOS “predicates” of the form x →τ  and x ~τ
in the premises

of rules are typically treated as abbreviations. The predicate x →τ  represents the
statement “there is a y such that x →τ y” and can be represented in traditional SOS
by means of x →τ y with y a fresh variable w.r.t. the rule under consideration. The
predicate x ~τ  represents the statement “for all y, it is not the case that x →τ y”.
The later statement can not be expressed in a concise way. Definitions of such predicates in traditional SOS are often rather ad hoc. The presence of either one of these forms might already be sufficient reason to desire quantifications.
There are, however, some peculiarities in the approach of [13]. One of the most significant is that their rules are of a very restricted form. Every rule must adhere to the following format.


∃z0 ∀z1 ∃z2
ϕ

t →l u

Here z0, z1 and z2 are sets of variables and ϕ is a formula built using the following
syntax (where t is a (process) term, l a label and I a possibly infinite set of indices).


ϕ ::= t →l

t | t ~l

t |   ϕi |   ϕi

i∈I	i∈I
The limited number of alternations of quantifications is motivated by the fact that this is sufficient for the currently available applications, which is to some extent reasonable. However, the authors of [13] do note that “the ultimate goal would be to have a general [first-order] language and allow for all sorts of nested quantifiers.” More problematic is that the rules as given in the example do not have a very direct translation to this formalism. One has to write their rules in this restricted – and somewhat unnatural – form. The above example would have to be written as follows.
x ~τ y ∧ xC	x →τ y' ∧ (x ~τ y ∨ y C)
∀y	∃y' ∀y
x C	x C
Note that the quantifications have been “pushed” outward and that the implication has been translated to an or (and that the and and or are sugar).  We know of no standard result that states that in general a formula can be translated to
this restricted format. This is mainly due to the possibility of infinite index sets in conjunctions and disjunctions, implying an infinitary logic (for which there typically is no prenex-like normal form).
Also w.r.t. traditional TSSs, the notation of [13] is somewhat deviant in the fact that unbound variables may only occur in the source of the conclusion of a rule. It should be noted that in examples of traditional SOS, where the sets of premises usually only consists of a small number of transitions, the set notations are usually omitted. We will not do so, for the sake of comparison. Where one would previously

write 3

{x →a x'} x + y →a x'



one must now write	∃x'


x →a x'

x + y →a x'

to bind the occurrence of x' explicitly. There is an implicit binding of the variables from the source of the conclusion. As we will show in this paper, this needlessly increases the gap between traditional TSSs and those of [13]. In the syntax of the type of SOS specifications as introduced in this paper, named FOL-SOS (SOS with First-Order Logic), w.r.t. deduction rules without negative premises, the only difference with the traditional rule is that the set of premises are combined into a single formula by connecting them by means of conjunction. So the traditional rules 4

{x →a x'}
{x →a x', y →b
y'}



x + y →a x'


γ(a,b) '	'

x	y → x	y
are represented as follows in the notations introduced in this paper

  {x →a x'}



  {x →a x',y →b

y'}
.

x + y →a x'
γ(a,b) '	'

x	y → x	y
Another significant peculiarity is the confusing non-standard use of quantifiers. Take, for example, the rule for alternative composition given above. Most people would read the traditional rule as this “for all x, y and x', if x →a x', then also x + y →a x'.” It is then rather confusing to find an existential quantification for the variable x' in the syntax of [13]. The origin of this confusion is clear from the introduction of [13] where the authors say: “The semantics of a TSS [...] comes with an implicit existential quantiﬁcation of valuations of variables used in the rule: if there exists a substitution on variables (appearing in the rule) such that the premises of the rule are satisfied, then the conclusion (with the same substitution applied to it) follows.” Although the latter part of the sentence is correct – if a substitution satisfies the premise of a rule then the substitution also satisfies the conclusion – it does not imply an existential quantification. The reason for this is that for every substitution it holds that if it satisfies the premise it also satisfies the conclusion. So there is actually an universal quantification.

Next, the use of the previously mentioned abbreviations t →a
and t ~a
in tra-

ditional TSS are not easily represented in the syntax of [13]. The reason is that the quantifiers need to be grouped in front of the deduction rule (and in limited alternations). As a consequence the rules are less readable. On the other hand, in the syntax of FOL-SOS these abbreviations are captured in a very intuitive way:
x →a  can be replaced syntactically by ∃y (t →a y) (for y free w.r.t. t) and t ~a  is
syntactically replaced by ∀y (¬ t →a y)(again, for y free w.r.t. t).

3 The function symbol + represents alternative composition or nondeterministic choice as it occurs in many process algebras (e.g., [4]).
4 The function symbol  represents parallel composition as it occurs in many process algebras (e.g., [4]).

Finally, the format of [13] allows “universally” quantified variables (i.e. univer- sally quantified in the sense of [13]) to occur in the targets of conclusions of rules. For example, the following rule is allowed.
x →a x

∃x ∀y


x →b y

The meaning of such rules is in no sense intuitive. One might expect, taking into account the meaning of quantifiers in the setting of [13], that the rule means some-

thing like “for all x such that x →a x there is a y such that x →b
y.”  The actual

meaning is “for all x such that x →a x we have that x →b
y for all y.”

Besides the fact that there appears to be no intuition behind these semantics, we believe that existentially quantified variables in targets are of little (if any) use. One might be able to express that there is some term t such that P (t), but in specifying a transition relation (which is the purpose of a TSS) this does not help one bit (since it is not clear which term t makes P (t) true).
In this paper we give a formalism that allows arbitrary first-order logic in the premise (and only in the premise) and implicitly quantifies all free variables of both the premise and conclusion (as is standard). To illustrate, the weak termination predicate of [2] can be straightforwardly described in our formalism as follows (using the previously described abbreviations):

x ~τ
∧ xC x C
x →τ
∧ ∀y (x →τ
x C
y ⇒ y C)

In Section 3.3 we give elegant rules, in FOL-SOS, that capture the previously mentioned examples of the use of quantification in SOS (i.e. those from [2,3,15,18]). We show that allowing for the use of first-order logic formulas in premises does not increase expressiveness for well-defined TSSs (i.e. it only increases conciseness).
Furthermore, we give a format for establishing congruence of (strong) bisimilarity [16,12] in the line of the ntyft/ntyxt format of [6].
Preliminaries
Terms, Predicates and Formulas
A signature Σ is a tuple of a set of function symbols F and a set of predicate symbols
P. Terms of a signature Σ = ⟨F, P⟩ and a set of variables V, denoted by T (Σ, V) are variables from V or functions symbols from F applied to zero or more terms. We write Tc(Σ) (or just Tc if it is clear which Σ is used) for the set of closed terms (i.e. terms without variables) and var(t) for the set of variables occurring in term
t. Predicates of Σ, denoted by P (Σ, V), are predicate symbols from P applied to
terms from T (Σ, V). Mostly, variables will not be explicitly mentioned any further in our notations. We also refer to predicates as atoms. The set of variables that occur syntactically in atom a is denoted var(a).

Formulas ϕ, ψ,... over a signature Σ = ⟨F, P⟩ and variables V are of the form (with a ∈ P (Σ, V) and x ∈ V):

ϕ ::= a |¬ ϕ |  {ϕ, . . .}| ∀x ϕ

For a formula ϕ, FV(ϕ) denotes the set of unbound (or free) variables that occur in ϕ. This function is defined inductively as follows: FV(a) = var(a), FV(¬ ϕ) = FV(ϕ), FV(	Φ) =	ϕ∈Φ FV(ϕ), and FV(∀x ϕ) = FV(ϕ) \ {x}.
We assume the other standard logic operators are sugar in the usual way. That
is, true =	∅, false = ¬ true, ϕ ∧ ψ =	{ϕ, ψ}, ϕ ∨ ψ = ¬ (¬ ϕ ∧ ¬ ψ), ϕ ⇒ ψ = ¬ ϕ ∨ ψ,  Φ = ¬  {¬ ϕ : ϕ ∈ Φ} and ∃x ϕ = ¬ ∀x ¬ ϕ. We often
s∈S
We write a, b, c, . . . for atoms and l, m, n, . . . for literals. Literals are atoms or negations of atoms. That is, for each literal there is an atom a such that l = a or l = ¬ a. We call the former positive literals and the latter negative literals. The set of all literals is denoted by L. For sets L of literals, we write L+ for the set of positive literals in L and L− for the set of negative literals in L.
We use formulas as premises for SOS rules, but we still need to consider the set of literals used in such a formula. Therefore we introduce the following function. Note that when introducing a function f on formulas, we often also introduce an auxiliary function f for functions in a negative context.
Definition 2.1 We define the set of literals from a formula ϕ, notation Lit(ϕ), as follows.


Lit(a)	= {a}

Lit(¬ ϕ)  = Lit(ϕ)
Lit(  Φ) =  ϕ∈Φ Lit(ϕ)
Lit(∀x ϕ) =  t∈Tc(Σ) Lit(ϕ[t/x])


Lit(a)	= {¬ a}

Lit(¬ ϕ)  = Lit(ϕ)

Lit(  Φ) =  ϕ∈Φ Lit(ϕ)

Lit(∀x ϕ) =  t∈Tc(Σ) Lit(ϕ[t/x])

For simplicity we often refer to the positive and negative literals of Lit(ϕ) as the positive, respectively negative literals of ϕ.

Transition-System Speciﬁcations
In traditional TSSs [8] typically one only considers transition relations and unary predicates. In general, there is no reason to limit the use of TSSs to only unary and binary predicates. However, the equivalences and congruence formats defined on TSSs typically only deal with these specific predicates. Note that we actually do not explicitly consider unary predicates here either. These can be easily coded as binary predicates (see [5]).
In traditional TSSs positive and negative transitions are used in the premises. Positive transitions are the same as our atoms. Negative transitions are of the form
t ~α , and have the intuitive meaning of ∀x (¬ t →α x) (for x free w.r.t. t). We write

t, u, v, . . . for transitions. For sets T of transitions, we write T+ for the set of positive transitions in T and T− for the set of negative transitions in T .
A traditional rule (for signature Σ) is of the form P where P is a set of transitions and a is an atom. A traditional Transition-System Speciﬁcation (traditional TSS) is a tuple ⟨Σ, R⟩ where Σ is a signature and R is a set of traditional rules. We typically assume a signature and only refer to a TSS by the set of rules R. We say a rule is closed when it contains no variables. Similarly we say that a TSS is closed when all its rules are closed. A TSS R induces a closed TSS R' where R' consists of all rules of R instantiated with all closing substitutions.
We adopt the least three-valued stable model as the semantics of a traditional TSS (see [6] for definitions), because it is possible to write TSSs that contradict themselves in two-valued models (e.g.  a ~  ). In a three-valued model, closed tran- sitions are partitioned into those that certainly hold, those that may hold, and those that certainly don’t hold. Usually, however, we are only interested in TSS that have a well-defined two-valued model (i.e., for each closed transition it is clear that it either holds or does not hold). Such TSSs are called well-defined or complete [8,6]
The extension of traditional TSSs of [13] is described in some detail in the introduction. For the rather complex semantics we refer to that paper.
TSS with First-Order Logic
In this section, we introduce First-Order Logic Transition-System Speciﬁcations (FOL-TSSs). A FOL-rule is of the form ϕ where ϕ is a formula and a is an atom. A FOL-TSS is a tuple ⟨Σ, R⟩ where Σ is a signature and R a set of FOL-rules. Again, we usually refer to such a FOL-TSS just by R. The semantics of FOL-TSSs is given in two parts. First we consider the semantics of the formulas and then the semantics of FOL-TSSs. We say a rule is closed when it contains no unbound variables. Similarly we say that a FOL-TSS is closed when all its rules are closed. A FOL-TSS R induces a closed FOL-TSS R' where R' consists of all rules of R instantiated with all closing substitutions.
The use of unary predicates in FOL-SOS poses no additional problems to the use of transition relations. In fact, unary predicates can easily be encoded as transitions, in a way similar to that of [5], as follows: (1) occurrences of P (y) in premises of deduction rules can be replaced with the formula ∃x t →P x for x /∈ var(t), and
(2) occurrences of P (t) as a conclusion of a deduction rule can be replaced with the formula t →P x where x is fresh w.r.t. the original deduction rule. In this coding we assumed that →P is a fresh transition relation.

Inﬁnitary First-Order Kleene Logic
To be able to establish whether or not the premise of a rule is satisfied, we must first define when a formula ϕ is true (or false). As we define the semantics of FOL-TSSs by means of least three-valued stable models (similar to the definition of traditional TSSs in Section 2), we also need a three-valued logic. We base our logic on Kleene’s (strong) three-valued logic [10]. Here there is an additional value unknown besides

the classical true and false. This definition is very similar to that of [11].
Definition 3.1 Let L be a set of closed literals. We define when a closed formula
ϕ is true for L, notation L ▶ ϕ, or not true (i.e. false) for L, notation L /▶ ϕ.


L ▶ a	iff a ∈ L L ▶ ч ϕ  iff L /▶ ϕ
L ▶  Ψ iff L ▶ ψ for all ψ ∈ Ψ
L ▶ 6x ψ iff L ▶ ψ[t/x] for all t ∈ Tc
L /▶ a	iff ч a ∈ L L /▶ ч ϕ iff L ▶ ϕ
L /▶  Ψ iff L /▶ ψ for some ψ ∈ Ψ
L /▶ 6x ψ iff L /▶ ψ[t/x] for some t ∈ Tc


Semantics of Transition-System Speciﬁcations with First-Order Logic
First the semantics of FOL-TSSs is defined. The definitions resemble those for traditional TSSs.
Definition 3.2 Let R be a closed FOL-TSS, L be a set of closed literals and a a closed atom. We can derive a from the set L in R, notation L ▶R a, when there exists a well-founded upwardly branching tree with literals as nodes and of which
the root is labelled by a;
if a node is labelled by literal l and the nodes above it form the set L', then one of the following two cases hold:
l ∈ L and L' = ∅;
l is a positive literal and there is a rule ϕ ∈ R such that L' ▶ ϕ and such that
L' is minimal w.r.t. ϕ 5 .
We say L is minimal for ϕ if L ▶ ϕ and there is no L' ⊂ L with L' ▶ ϕ. Similarly, we say L is minimal if there is no L' ⊂ L such that L' ▶R t.
Definition 3.3 A pair ⟨C, U⟩ of sets of closed atoms (where C stands for Certainly true and U for Unknown; the third set, certainly false is determined by the atoms not in C∪U ) is called a three-valued stable model for a FOL-TSS R when C∩U = ∅ and for all atoms a the following holds.
a ∈ C if, and only if, there is a set of closed negative literals N such that N ▶R a
and C ∪ U ▶ N .
a ∈ C ∪ U if, and only if, there is a set of closed negative literals N such that
N ▶R a and C ▶ N .
Definition 3.4 The semantics of a FOL-TSS R is given by the information-least three-valued stable model ⟨C, U⟩ of the closed FOL-TSS induced by R.
In general, we are only interested in complete models; we want that every atom is certainly true or false.

5 Note that minimality is not a necessary requirement. It only facilitates the proofs.

Definition 3.5 A FOL-TSS is called complete if, and only if, its information-least three-valued stable model is ⟨C, ∅⟩ for some set of closed atoms C.
To establish whether the least three-valued stable model of a (FOL-)TSS is complete one can calculate this model and check that the set of unknowns is empty. This can, however, be quite some task with complicated TSSs. As in [6], we can easily define a notion of stratification for FOL-TSSs by considering the literals of the premise of a rule that implies that the least three-valued stable model is complete.

Examples
In this section we present rules for the examples found in literature (see [2,3,15,18]) mentioned in the introduction. As is customary in giving SOS for concrete examples

we sometimes use the standard abbreviations: t →a
represents 6x (ч t →a x) (where x is free w.r.t. t).
represents ∃x (t →a x) and t ~a

Example 3.6 In [3] a definition of an “is in a deadlock” predicate is given. Roughly translated (from Dutch):
“We say that a process is in a deadlock [. . . ] if it cannot do any action. That is, if p is such a process, we have that p ~a q and p ~a C for every a, q; [... ].”
Let us write δ(p) for “p is in a deadlock.” Then the definition of δ in FOL-TSS is as follows.

a∈A
(6x' (ч x → x ∧ч x → C))



δ(x)
Note that universal quantification (and existential quantification for that matter) are only used for variables over process terms. The universal quantification over the actions is therefore represented by means of an infinitary conjunction.
Example 3.7 In [2], the following definition of the weak termination predicate C
is given.


p C ⇔
⎧⎨ (i)	p ~τ
⎩ (ii)	p →τ
and pC, or
and, for each q, p →τ


q implies q C.

This is trivially translated to the following FOL-TSS.


6y (ч x →τ
y) ∧ xC
∃y (x →τ
y) ∧ 6y (x →τ
y ⇒ y C)


	
x C	x C
Note that due to the previously mentioned implicit existential quantification of unbound variables that are introduced in a premise, the existential quantification in the above rule can be omitted. Also using the abbreviations mentioned above, this gives the following alternative for the rules:

x ~τ
∧ xC x C
x →τ
∧ 6y (x →τ
x C
y ⇒ y C)

Note the close correspondence with the original informal statement of the weak termination predicate.
Example 3.8 In [2], also a definition of semantical convergence ⇓ is given by means of the following.


p ↓ and (for each q, p →τ
q implies q ⇓) imply p ⇓


Its translation to a FOL-TSS results in the following rule.


x ↓ ∧6y (x →τ
y ⇒ y ⇓)



x ⇓
Example 3.9 In [18] traditional TSSs were extended with universal quantification of negative transitions. That is, there negative literals are written as 6−→x. t ~ u
where the variables from −→x are only allowed to occur in u. This can straightfor-
−→
wardly be transformed to our setting as 6x0 ... 6xn (ч t→u), with x = x0,..., xn
for some n. The semantics given in [18] corresponds to our semantics.

Expressiveness
First we discuss the expressiveness of FOL-TSS w.r.t. the TSS of [13]. Both types of TSS are capable of expressing every three-valued stable model. Therefore these frameworks are equally expressive. It remains to be seen if a translation between the settings can be given that preserves at least some of the structure of the TSSs. Next, we discuss expressiveness of FOL-TSSs w.r.t. traditional TSSs. We show that traditional TSSs can straightforwardly be expressed as FOL-TSSs. We basi-
cally replace each negative transition t ~α by a formula 6x (ч t →α x) (with x fresh
w.r.t. t) and put a	around the premise. Note that this requires that there is a large enough supply of variables.
Definition 4.1 Let ⟨Σ, R⟩ be a traditional TSS. The translation of ⟨Σ, R⟩ to a FOL-TSS is ⟨Σ, R'⟩, where



R' =
⎧⎨  P+ ∪ {6
⎩

x(t)
(ч t →α x(t)) : t ~α a

∈ P−}
:
P ∈ R⎫⎬ , a	⎭

where x is a mapping that associates with a term t ∈ T (Σ) a variable that does not occur free in t, i.e., x(t) /∈ var(t).
Note that using the abbreviations this amounts to putting an infinitary conjunc- tion around the set of premises from the traditional TSS.
Theorem 4.2 The three-valued stable models of a traditional TSS and its transla- tion to a FOL-TSS are identical.

Proof. A proof of this theorem is given in Appendix A.	 
As this means that both TSSs have the same three-valued stable models it follows trivially that they have the same least three-valued stable model.
Corollary 4.3 The least three-valued stable model of a traditional TSS and the least three-valued stable model of its translation to a FOL-TSS are identical.
The above theorem states that for every traditional TSS there is an equivalent FOL-TSS. The converse is also true for complete FOL-TSSs.
Theorem 4.4 For every complete FOL-TSS there is a traditional TSS with the same least three-valued stable model.
Proof. Let R be a complete FOL-TSS and let ⟨C, U⟩ be the least three-valued stable model of R. As R is complete we have that U = ∅. Then the traditional
TSS with rules  a  : a ∈ C} is trivially equivalent to R.	 
For FOL-TSSs that are not complete it is not the case that there is always an equivalent traditional TSS (under the assumption that the signature has to remain untouched). This is demonstrated by the following example. Since any FOL-TSS without negative literals is complete the example necessarily uses negative literals.
Example 4.5 Let Σ = ⟨∅, {a, b}, {→ }⟩ and let R consist of the following rules:

⟨{a →a, b →b}, {a →b, b →a}⟩.  For (traditional) TSSs with least three-valued stable model ⟨C, U⟩, the only way to get an atom c in the set of unknowns U is to
have a derivation N where N is not empty and C ▶ N but not C ∪ U ▶ N . As N
can only contain negative transitions, it must contain a ~ or b ~ . However, we have that neither C ▶ a ~ or C ▶ b ~ are true. Thus there cannot be a traditional TSS with model ⟨C, U⟩.
As we are usually only interested in complete TSSs, we can reasonably say that FOL-TSSs are effectively as expressive as traditional TSSs.
Congruence Format
We define a congruence format for (strong) bisimilarity on the syntax of TSSs. Most of the requirements for this format are straightforward extensions of the ntyft/ntyxt format (see [6] for the definitions and the congruence theorem).
However, as we have formulas instead of sets of literals, these requirements appear a bit more complex. The following definitions give the functions that are to be used in the definition of the congruence format. For each definition we also give some (hopefully enlightening) examples of its use. Note that in these examples we use the sugar defined in Section 2 and implicitly work through it.

In traditional TSS, the ntyft/ntyxt format restricts the premises such that the right-hand sides of all positive transitions among the premises (in traditional TSS only positive transitions have a right-hand side) are variables and need to be dif- ferent. Here we need a similar restriction, though, due to the presence of the full generality of first-order logic formulas as premises, establishing this is more involved. First, we define a function dv (for distinct variables) to determine whether or not all right-hand sides of literals are variables and whether the unbound ones are unique or not. The function ubrhs (for unbound in right-hand side), also defined below, returns the unbound (or free) variables that occur in right-hand sides of
literals of a given formula.
Definition 5.1 The functions dv and ubrhs are defined as follows. dv(t →α u) = u ∈ V
dv(ч ψ)	= dv(ψ)
dv( Ψ) = 6ψ∈Ψ dv(ψ) ∧ 6ψ,ψ'∈Ψ (ψ /= ψ' ⇒ ubrhs(ψ) ∩ ubrhs(ψ') = ∅) dv(6x ψ) = dv(ψ)

ubrhs(t →α u) = var(u)

ubrhs(  Ψ) = 

ψ∈Ψ
ubrhs(ψ)

ubrhs(ч ψ)	= ubrhs(ψ)	ubrhs(6x ψ) = ubrhs(ψ) \ {x}
Example 5.2 We consider the formula  {6x (f (x) → y), ч c → y}:

dv(  {6x (f (x) → y), ч c → y})
= dv(6x (f (x) → y)) ∧ dv(ч c → y)
∧ (ubrhs(6x (f (x) → y)) ∩ ubrhs(ч c → y) = ∅)
= dv(f (x) → y) ∧ dv(c → y) ∧ ((ubrhs(f (x) → y) \ {x}) ∩ ubrhs(c → y) = ∅)
= true ∧ true ∧ (({y}) \ {x}) ∩ {y} = ∅)
= false

In [13], for the purpose of the congruence theorem, the authors require that the right-hand sides of positive literals are existentially bound variables and those of negative literals are universally bound variables and show that this restriction is necessary (in the sense that omitting the restriction ruins the congruence result). As we are in a comparable setting here, we also need such a restriction. The func- tion ext, defined below, checks only the former, but by supplying the negation of a formula – thus interchanging existential and universal quantifications and posi- tive and negative literals – the latter can also be established. Note that positive (negative) literals that occur in the left-hand side of an implication, as in Example
3.7 and Example 3.8, are considered negative (positive) literals and thus need to be universally (existentially) bound.

The function ext determines whether the right-hand sides of the positive literals (of the formula it is applied to) are existentially bound. It is parameterised by a set of variables that keeps track of those variables that are existentially bound in the current scope.
Definition 5.3 The function extS is defined as follows.


extS(t →α u) = u ∈ S

extS(ч ψ)	= extS(ψ)
extS( Ψ) = 6ψ∈Ψ extS(ψ) extS(6x ψ) = extS\{x}(ψ)
extS(t →α u) = true extS(ч ψ)	= extS(ψ)

	
extS(  Ψ)  = 6ψ∈Ψ extS(ψ)

extS(6x ψ) = extS∪{x}(ψ)

Example 5.4 We consider the formula ∃x (t→x∧ 6x (ч u →x∧ v →x)). First we check whether all positive literals have an existentially bound right-hand side.

ext∅(∃x (t→x ∧ 6x (ч u →x ∧ v →x)))
= ext{x}(t→x ∧ 6x (ч u →x ∧ v →x))
= ext{x}(t→x) ∧ ext{x}(6x (ч u →x ∧ v →x))
= true ∧ ext∅(ч u →x ∧ v →x)
= ext∅(ч u →x) ∧ ext∅(v →x)

= ext∅(u →x) ∧ false = true ∧ false
= false
Next we check that all negative literals have a universally bound right-hand side. ext∅(ч ∃x (t→x ∧ 6x (ч u →x ∧ v →x)))

= ext∅(∃x (t→x ∧ 6x (ч u →x ∧ v →x)))

= ext∅(t→x ∧ 6x (ч u →x ∧ v →x))

= ext∅(t→x) ∧ ext∅(6x (ч u →x ∧ v →x))

= true ∧ ext{x}(ч u →x ∧ v →x)

= ext{x}(ч u →x) ∧ ext{x}(v →x)
= ext{x}(u →x) ∧ true
= true

Similar to the format of [13] we cannot allow existentially bound variables x to depend on universally bound variables or variables that depend on universally bound variables that are bound within the scope of x. The function that specifies

this looks rather complex, but it basically checks for each existential quantification binding a variable x that there is no variable y on which x depends that is bound by a later universal quantification (or existential quantification following a later universal quantification).
Thereto the function h collects successive existentially quantified variables and, when it encounters a universally quantified variable, checks – with function k – whether these existentially bound variables do not depend on variables bound by other quantifications in their scope. The superscript S of h, a set of variables, keeps track of successive existentially quantified variables and subscript T of k, also a set of variables, keeps track of the quantified variables following those in superscript S.

Definition 5.5 The functions hS, hS , and kS are defined as follows.


hS(t →α u) = true
hS(ч ϕ)  = hS (ϕ)
hS (t →α u) = true
hS (ч ϕ)  = hS(ϕ)

hS(  Φ) = 6ϕ∈Φ
hS(ϕ)
hS (  Φ) = 6


h (ϕ)

hS(6x
ϕ) = h∅(ϕ) ∧ kS
(ϕ)


h (6x
S∪{x}
ϕ	h	ϕ


kS (t →α u)= u ∈ S \ T ⇒ var(t) ∩ T = ∅
kS (ч ϕ)  = kS (ϕ)
T	T
kS (  Φ)  = 6ϕ∈Φ kS (ϕ)
T	T
kS (6x ϕ) = kS	(ϕ)
T	T∪{x}
Example 5.6 We consider the formula ∃x (t→x ∧ ∃y (6x (x→y))).

h∅(∃x (t→x ∧ ∃y (6x (x→y))))
= h{x}(t→x ∧ ∃y (6x (x→y)))
= h{x}(t→u) ∧ h{x}(∃y (6x (x→y)))
= true ∧ h{x,y}(6x (x→y))
= h∅(x→y) ∧ k{x,y}(x→y)
= true ∧ ((y ∈ {x, y}\ {x}) ⇒ ({x}∩ {x} = ∅))
= true ⇒ false
= false

Using the previously defined functions we arrive at the following definition of the congruence format.
Definition 5.7 Let V be a set of variables. A formula ϕ is in the FOL-ty format
w.r.t. V if the following holds.

The right-hand sides of literals are distinct variables different from V ; that is, dv(ϕ) and ubrhs(ϕ) ∩ V = ∅.
The right-hand side of a positive literal is existentially bound; that is, extFV(ϕ)\V (ϕ).
The right-hand side of a negative literal is universally bound; that is, ext∅(ч ϕ).
The variable in the right-hand side of a positive literal is bound inside the scope of the variables in the left-hand side of that literal; that is, hFV(ϕ)\V (ϕ).
A FOL-rule r is in the FOL-tyft format if it is of the form
ϕ
,
f (x1,..., xn) →α t
for distinct variables x1,..., xn, and ϕ is in the FOL-ty format w.r.t. {x1,..., xn}.
A FOL-rule r is in the FOL-tyxt format if it is of the form
ϕ x →α t
and ϕ is in the FOL-ty format w.r.t. {x}.
A FOL-TSS is in the FOL-tyft format if all its rules are in the FOL-tyft format. A FOL-TSS is in the FOL-tyxt format if all its rules are in the FOL-tyxt format. A FOL-TSS is in the FOL-tyft/tyxt format if all its rules are either in the FOL-tyft format or the FOL-tyxt format.
The rules of Example 3.6, Example 3.7 and Example 3.8 all satisfy the FOL- tyft/tyxt format. (The rules of Example 3.9 do not, but there the notion of bisimi- larity is not relevant, as this is essentially meant to be a term rewriting system.)
Definition 5.8 Let T be a complete TSS with least three-valued stable model
⟨C, U⟩. A symmetric relation R is a bisimulation relation if for all (closed) terms p
and q such that pR q we have that
if p →α p' ∈ C for some →α  and (closed) term p', then there is a (closed) term q'
such that q →α q' ∈ C and p' R q'.
Two terms p and q are bisimilar, notation ↔, if there is a bisimulation relation R
with pR q.
As is custom in proofs for congruence formats, we assume that rules do not contain circular variable dependencies. A variable x depends on a variable y if there is a literal t →α u in ϕ such that x occurs in u and y occurs in t. For ntyft/ntyxt it has been shown in [7] that this requirement is not necessary. This is possibly also the case for our format.
Definition 5.9 A formula ϕ is well-founded if there is an α-equivalent ϕ' such that the variable-dependency graph of the right-hand sides of positive literals in ϕ'
is well-founded. That is, {(x, y) : t →α u ∈ Lit(ϕ') ∧ x ∈ var(t) ∧ y ∈ var(u)} is a well-founded order.

A FOL-rule is well-founded if its premise is well-founded. A TSS is well-founded if all of its rules are well-founded.
Theorem 5.10 Let T be a complete and well-founded FOL-TSS that is in the FOL- tyft/tyxt format. Bisimilarity on T is a congruence for all operators of T.
Proof. A proof of this theorem is given in Appendix B.	 
With respect to the use of unary predicates in deduction rules it should be noted that with the encoding by means of transitions as described before, the requirements are precisely those of the use of predicates in ntyft/ntyxt.
We compare our format with ntyft/ntyxt. We have already shown that tradi- tional TSSs can easily be translated to our setting (Section 4).
Theorem 5.11 Let ⟨Σ, R⟩ be a traditional TSS and let ⟨Σ, R'⟩ be the translation of ⟨Σ, R⟩ to a FOL-TSS (as given by Deﬁnition 4.1). If ⟨Σ, R⟩ is in the ntyft/ntyxt format, then ⟨Σ, R'⟩ is in the FOL-tyft/tyxt format.
Proof. A proof of this theorem is given in Appendix C.	 

Conclusion
We have introduced SOS with the full power of first-order logic in the premises and given an intuitive semantics that is strongly related to traditional semantics. Furthermore we have given a conservative extension of the ntyft/ntyxt congruence format and the format for congruence in the setting of [13]. We show that our format is strictly more expressive than the ntyft/ntyxt format. In order to also give a (partial) comparison of our format with the UNTyft/UNTyxt format of [13], we first need to have a (partial) translation from the TSSs of [13] to FOL-TSSs that preserves at least some of the logical structure of the deduction rules.

Acknowledgement
The authors would like to thank MohammadReza Mousavi for his valuable input.

References
Aceto, L., W. J. Fokkink and C. Verhoef, Structural operational semantics, in: J. A. Bergstra, A. Ponse and S. A. Smolka, editors, Handbook of Process Algebra, Chapter 3 (2001), pp. 197–292.
Aceto, L. and M. Hennessy, Termination, deadlock, and divergence, Journal of the ACM 39 (1992),
pp. 147–187.
Baeten, J. and J. Bergstra, Processen en procesexpressies, Informatie 30 (1988), pp. 214–222.
Baeten, J. and W. Weijland, “Process Algebra,” Cambridge Tracts in Theoretical Computer Science
18, Cambridge University Press, 1990.
Baeten, J. C. M. and C. Verhoef, A congruence theorem for structured operational semantics with predicates, in: E. Best, editor, Proceedings of the 4th International Conference on Concurrency Theory (CONCUR ’93), Lecture Notes in Computer Science 715 (1993), pp. 477–492.

Bol, R. N. and J. F. Groote, The meaning of negative premises in transition system specifications, Journal of the ACM 43 (1996), pp. 863–914.
Fokkink, W. and R. J. van Glabbeek, Ntyft/ntyxt rules reduce to ntree rules, Information and Computation 126 (1996), pp. 1–10.
Groote, J. F., Transition system specifications with negative premises, Theoretical Computer Science
118 (1993), pp. 263–299.
Groote, J. F. and F. W. Vaandrager, Structured operational semantics and bisimulation as a congruence, Information and Computation 100 (1992), pp. 202–260.
Kleene, S. C., On notation for ordinal numbers, Journal of Symbolic Logic 3 (1938), pp. 150–155.
Langholm, T., “Partiality, Truth and Persistence,” CSLI Publications, 1988.
Milner, R., “A Calculus of Communicating Systems,” Lecture Notes in Computer Science 92, Springer Verlag, 1980.
Mousavi, M. R. and M. A. Reniers, A congruence rule format with universal quantification, Electronic Notes in Theoretical Computer Science 192 (2007), pp. 109–124.
Mousavi, M. R., M. A. Reniers and J. F. Groote, SOS formats and meta-theory: 20 years after, Theoretical Computer Science 373 (2007), pp. 238–272.
Mousavi, M. R., M. Sirjani and F. Arbab, Formal semantics and analysis of component connectors in reo, Electronic Notes in Theoretical Computer Science 154 (2006), pp. 83–99.
Park, D., Concurrency and automata on infinite sequences, in: P. Deussen, editor, Proceedings 5th GI Conference, Lecture Notes in Computer Science 104 (1981), pp. 167–183.
Plotkin, G. D., The origins of structural operational semantics, Journal of Logic and Algebraic Programming 60–61 (2004), pp. 3–15.
van de Pol, J., Operational semantics of rewriting with priorities, Theoretical Computer Science 200
(1998), pp. 289–312.
A	Proof of Theorem 4.2
First we relate the derivation trees of traditional TSSs and FOL-TSSs.
Lemma A.1 Let ⟨Σ, R⟩ be a closed traditional TSS and let ⟨Σ, R'⟩ be its translation to a closed FOL-TSS.

For all sets P of transitions and atoms a we have that ▶R P
if, and only if, P+ ∪ {¬ t →α u : t ~α  ∈

P− ∧ u ∈ Tc(Σ)} ▶R' a.
Proof. Let P be a set of transitions. Assume that we have ▶R P and that tree Υ is a witness of this. We

show that Υ is a FOL-tree witnessing P+ ∪ {¬ t →α u : t ~α
depth of Υ.
∈ P− ∧ u ∈ Tc(Σ)} ▶R' a by induction on the

Υ consists of only one node, viz. transition u; by definition we have that u = a and either a ∈ P or

∅ ∈ R. If a ∈ P , then trivially a ∈ P+ and therefore also P+ ∪{¬ t →α u : t ~α
∈ P− ∧u ∈ Tc(Σ)} ▶R' a.

If ∅ ∈ R, then we also have true ∈ R'. As ∅ ▶ true trivially holds (and ∅ is obviously minimal w.r.t.
a	a

true), we have that Υ is a FOL-tree witnessing P+ ∪ {¬ t →α u : t ~α
∈ P− ∧ u ∈ Tc(Σ)} ▶R' a.

Υ consists of more than one node; by definition we have that the root of Υ is a. Let K be the set of (direct) subtrees of the root. By definition we have that every tree k ∈ K is a witness for ▶R P , where b
is the root of k. Then by induction we have that such a k is also a witness for P+ ∪ {¬ t →α u : t ~α ∈

P− ∧ u ∈ Tc(Σ)} ▶R' b. From this is follows that to show that Υ is a tree witnessing P+
α
∪ {¬ t → u :

t ~α ∈ P− ∧ u ∈ Tc(Σ)} ▶ ' a, we only need to show that the node-condition (for FOL-trees) holds
R
for the root of Υ. Let P' be the set of transitions that are a root of a tree in K. We know that
either a ∈ P and P' = ∅ or there is a rule P ' ∈ R. In the first case we are done. The second

V P ' + ∪{∀x	' α
' α	' −}	'

case means that we have
(¬ t → x): t ~ ∈P
a
∈ R . But then also we trivially have that

P'+ ∪ {¬ t' →α u  : t' ~α  ∈ P'− ∧ u ∈ Tc(Σ)} ▶ V P'+ ∪ {∀x (¬ t' →α x) : t' ~α  ∈ P'−} and that

P'+ ∪ {¬ t' →α u : t' ~α ∈ P'− ∧ u ∈ Tc(Σ)} is minimal w.r.t. V P'+ ∪ {∀x (¬ t' →α x) : t' ~α
∈ P'−}.

Assume that we have a set P of transitions such that P+ ∪ {¬ t →α u : t ~α

∈ P−} ▶R' a and that FOL-tree

Υ is a witness of this. The proof that Υ is also a tree witnessing ▶R P can easily be given in a similar way as the converse.	 
Lemma A.2 Let ⟨Σ, R⟩ be a closed traditional TSS and let ⟨Σ, R'⟩ be its translation to a closed FOL-TSS. If P ▶R' a for some minimal set P of literals and atom a, then there is a set P' of positive and negative
transitions such that P = P'+ ∪ {¬ t →α u : t ~α ∈ P'−}.
Proof. We prove this by induction on the tree witnessing P ▶R' a. In the base case we have that root node a is the only node in the tree. We either have that a ∈ P or that there is a rule ϕ ∈ R' such that
∅ ▶ ϕ. If a ∈ P then, due to minimality, P = {a}, and hence we take P' = P . Otherwise we have that
P = ∅ as P is minimal and thus we take P' = ∅ as well.
Now let root node a have a non-empty set of children Q. For every b ∈ Q+ we trivially have that
P ▶R b and thus that there is a minimal Pb ⊆ P with Pb ▶R b. Note that due to the minimality we have

that P = S

b∈Q+
Pb ∪ Q−. By induction we have P' such that Pb
β
'  ∪ {¬ t →α u : t ~α	'
'

For every b = ¬ t → u ∈ Q− we know that this b is necessary support for ϕ. Also, as ⟨Σ,R ⟩ is the
translation of a traditional TSS, we have that ϕ = V S+ ∪ {∀x (¬ t' →α x) : t' ~α ∈ S−} for some set
S of transitions. Clearly, negative literal b is not required for the elements in S+. Thus there must be a

' β	' β
'	'	β  '

t ~ ∈ S− such that b supports ∀x (¬ t → x). The we have that t
= t and, for all u , that ¬ t → u
must

also be in Q−. Therefore, if Q' is the set of negative transitions supported by a b ∈ Q−, then we have that
Q− = {¬ t →α u : t ~α ∈ Q'}.

We now have that P = S
P ∪ Q− = S
(P'
∪ {¬ t →α u  : t ~α
∈ P'	α

b∈Q+  b
b∈Q+  b +
b−}) ∪ {¬ t → u  :

t ~α
S
∈ Q'} = S
P'
+S b +
∪ {¬ t →α u : t ~α

b∈Q+
'  ∪ Q'} and we therefore take P' = S
'
b∈Q+  b +

b∈Q+
' ∪ Q' =
b∈Q+
P' ∪ Q'.	 

We show that every three-valued stable model of ⟨Σ, R⟩ is also a three-valued stable model of ⟨Σ, R'⟩
and vice versa.
Let ⟨C, U⟩ be a three-valued stable model of ⟨Σ, R⟩. Let a ∈ C. Then we have that ▶R N for some
set N of negative transitions such that C ∪ U ▶ N . By Lemma A.1 we then also have that {¬ t →α u :

t ~α
∈ N ∧ u ∈ Tc(Σ)} ▶ ' a. As C ∪ U ▶ N means that for all t ~α
∈ N and closed terms u it holds that

t →α u /∈ C ∪ U . This trivially means that {¬ t →α u : t ~α ∈ N ∧ u ∈ Tc(Σ)} ▶ ' a. A similar reasoning can
R
be given for all a ∈ U . Thus ⟨C, U⟩ is a three-valued stable model for ⟨Σ, R'⟩.
Let ⟨C, U⟩ be a three-valued stable model of ⟨Σ, R'⟩. Let a ∈ C. Then we have that N ▶R' a for some
set N of negative literals such that C ∪ U ▶ N . By Lemma A.2 we know that N = N'+ ∪ {¬ t →α u : t ~α ∈
N'− ∧ u ∈ Tc(Σ)} for some set N' of positive and negative transitions. Then, by Lemma A.1 and the fact
that N'+ = ∅ as N only contains negative literals, we also have that ▶R N . We also trivially have that from C ∪ U ▶ N it follows that C ∪ U ▶ N'. Again, a similar reasoning can be given for all a ∈ U . Thus
⟨C, U⟩ is a three-valued stable model for ⟨Σ, R⟩. This concludes the proof of Theorem 4.2.
B  Proof of Theorem 5.10
In the proof of Theorem 5.10 we need to show that, given that ϕσ holds for some formula ϕ and substitution σ, there is a specific substitution τ such that ϕτ also holds. Essential in showing this are the values that are chosen for the bound variables in ϕ. To be able to talk about these bound variables we make the structure of Definition 3.1 more explicit by introducing (dis)proof trees.
As one bound variable may be assigned different values depending on the values of other variables (e.g.
∀x (∃y (x = y))), we also use labels to differentiate between such assignments. Each node of a tree is labelled with a sequence indicatingVthe choices that have bVeen made on the path from the root to this node.
For instance, in the proof tree for  {ϕ, ψ} with ψ = ∀x ( {x → y, ¬ t → x}), the subtree for t → x where x
is “assigned” the value u will have label ψ.u.(¬ t → x). Also, in that subtree x will be replaced with xψ.u, which makes it easy to determine where x is bound and which value x is supposed to have.
Definition B.1 We define what a proof tree and disproof tree are for a formula ϕ. A proof tree with label
λ for ϕ is built inductively on ϕ as follows:

α	α
t → u: leaf t → u.
¬ ψ: let T be the disproof tree with label λ for ψ; node ¬ with subtree T .
V Ψ: let Tψ be the proof trees with label λ.ψ for ψ ∈ Ψ; node V with subtrees Tψ for all ψ ∈ Ψ.

∀x ψ: let Tt be the proof tree with label λ.t for ψ[xλ.t/x] for all t ∈ T (Σ); node ∀x with subtrees Tt for all t ∈ T (Σ).


	ϵ




∃x  ϵ.ϕ




∃x  ϵ.ψ

ϕ = ∃x(t → x)
ψ = b → x ∧ 6y(чx → y ∧ ∃yc → y) ψj = 6y(чxϵ.ψ.∃ → y ∧ ∃yc → y)



ϵ.ϕ.∃ c → xϵ.ϕ.∃
ϵ.ψ.∃.(b → xϵ.ψ.∃)
b → xϵ.ψ.∃ ϵ.ψ.∃.ψj.t
ϵ.ψ.∃


6y




ϵ.ψ.∃.ψj

ϵ.ψ.∃.ψ'.t.(чxє.ψ.E → yє.ψ.E.ψ'.t)	ϵ.ψ.∃.ψ'.t.(∃ c → y)
y

ч	∃y

ϵ.ψ.∃.ψ'.t.(∃yc → y).∃

a copy of left subtree for every closed term t



xϵ.ψ.∃ → yϵ.ψ.∃.ψ′.t  c → yϵ.ψ.∃.ψ′.t.(∃yc→y).∃
ϵ.ψ.∃.ψ'.t.(чxє.ψ.E → yє.ψ.E.ψ'.t)

Fig. B.1. Proof tree

A disproof tree with label λ for ϕ is built inductively on ϕ as follows:

α	α
t → u: leaf t → u.
ч ψ: let T be the proof tree with label λ for ψ; node ч with subtree T .
V Ψ: let Tψ be the disproof trees with label λ.ψ for ψ ∈ Ψ; node V with subtree Tψ for some ψ ∈ Ψ.
6x ψ: let T be the disproof tree with label λ.E for ψ[xλ.∃/x]; node 6x with subtree T .
We often interpret the leaves of a (dis)proof tree as literals (i.e. a proof-tree leaf is a positive literal and a disproof-tree leaf is a negative literal).
Proposition B.2 If Υ is a proof tree for ϕ and σ is a substitution such that for all universally quantified variables x in Υ, t ∈ T (Σ) and labels λ, σ(xλ.t)= t, then, with L the leaves of Υ, it holds that Lσ ▶ ϕ.
Example B.3 The proof tree for the formula Ex (a → x) Λ Ex (b → x Λ 6y (ч x → y Λ Ey c → y)) is given in Figure B.1.
Lemma B.4 If ϕ is in the FOL-ty format w.r.t. V and Υ isa proof tree for ϕ, then we have the following properties on the leaves L of Υ.


Let u → v be a positive literal from L. Then v is an existentially bound variable xλ
for some x /∈ V

'	'	' α
and some label λ and there is no u with u /= u such that u → v ∈ L.

α
Let ч u → v be a negative literal from L. Then v is an universally bound variable x /∈ V .
If ϕ is well-founded, then so is L.
Proof.
This follows from dv(ϕ), ubrhs(ϕ) ∩ V = ∅, extFV(ϕ)\V (ϕ) and hFV(ϕ)\V (ϕ). The latter makes sure that there is no problem in duplicating positive literals (which occur only once in ϕ) in the proof
α  λ
tree. This is the case because for each positive literal u → x  ∈ L we have that the variables in u are
bound outside the scope of x and are thus uniquely labelled with labels that are a prefix of λ.
This follows from dv(ϕ), ubrhs(ϕ) ∩ V = ∅ and ext∅ (ч ϕ).


We transform ϕ to ϕ' by subscripting all variables with the set of labels they have gotten in the proof tree Υ. That is, for a universally bound variable x in ϕ we have the following. The 6x occurs at several places as root of a subtree in the proof tree. Each subtree has a label λ and in those subtrees
the variable x is “instantiated” with xλ.u for all closed terms u. We replace this variable x within its scope in ϕ by xΛ, where Λ = {λ.u : “there is a subtree of Υ with label λ and u ∈ Tc(Σ)”}.
For existentially quantified variables x in ϕ we do the same. That is, we replace it with xΛ, where Λ= {λ.E : “there is a subtree of Υ with label λ”}.
It is straightforward to prove that ϕ' is α-equivalent to ϕ.
As ϕ is well-founded, we get a well-founded order < on the variables of ϕ'. Let <L be the dependency order on the variables of L. We have that for each xλ and yμ such that xλ <L yμ there is a literal
in L with atom u → yμ and xλ ∈ var(u). But this means that there is a similar literal u → yM in ϕ'
such that μ ∈ M and there is a xΛ ∈ var(u) with λ ∈ Λ. But then also xΛ < yM .
Now, assume that <L is not well-founded. That means that there is a xλ with xλ < yμ1 < ... < yμn < xλ. By the previous considerations we then also have Λ and Mi for 1 ≤ i ≤ n such that
xΛ < yM1 < ... < yMn < xΛ. However, this contradicts that < is well-founded and therefore we
1	n
may conclude that <L is also well-founded.

We must show that ↔ is a congruence relation. That is, for all operators f and assuming p1,..., pn and q1,..., qn (with n the arity of f ) such that pi ↔ qi for all 1 ≤ i ≤ n, we must show that f (p1,..., pn) ↔ f (q1,..., qn).
Let R be the smallest congruence containing ↔. That is, let R be the smallest relation such that:
p R q, if p ↔ q;
f (p1,..., pn) R f (q1,..., qn) for all function symbols f (with arity n), if pi R qi for all i with 1 ≤ i ≤ n.
By showing that R is a bisimulation relation we trivially get that ↔ is a congruence. That R satisfies the transfer conditions for the pairs ⟨p, q⟩ with p ↔ q is trivial. We therefore only consider terms p = f (p1,..., pn) and q = f (q1,..., qn) with pi R qi for all i with 1 ≤ i ≤ n.
γ  '
We use induction on the “length” of the derivation p → p ∈ C. This is firstly done by induction on
approximations of the least three-valued stable model of T and within this induction on the depth of the
γ  '
tree witnessing p → p .
We define approximations ⟨Cα, Uα⟩, for ordinals α, of the least three-valued stable model ⟨C, U⟩ of T
as follows.
Cα = {a : Eβ<α (EN (N ▶T a Λ Cβ ∪ Uβ ▶ N ))}
Uα = {a : 6β<α (EN (N ▶T a Λ Cβ ▶ N ))}\ Cα
We clearly have that C0 = ∅ and U0 = L and Cα ⊆ Cβ and Uα ⊇ Uβ . The latter, with the KnaSster-Tarski
theoremT(and the identity function), means that there are ordinals λ1 and λ2 such that Cλ1 = α Cα and
Uλ2 = α Uα. Thus for all ordinals μ1 and μ2 with λ1 ≤ μ1, λ2 ≤ μ1 and μ1 ≤ μ2 we trivially have that
Cμ1 = Cμ2 and Uμ1 = Uμ2 . Specifically, we have that C = Cλ1 and U = Uλ2 .
We now (simultaneously) prove the following statements with induction on α. If pRq, then


if p
p ∈ Cα for some p , then there exists a q
such that q → q
∈ C and p R 



if p
p ∈ C for some p
exists a q	'

The first statement is the logical adaption of the transfer condition of bisimilarity and the second is needed in the proof of the first (and vice versa).
Let p = f (p1,..., pn) and q = f (q1,..., qn) with pi R qi for all i with 1 ≤ i ≤ n. We prove the first statement. The proof of the second statement is very similar to this proof (and therefore omitted).
γ  '	'
Assume p → p ∈ Cα for some closed process p . Then by definition we have that there is a set N of

negative literals such that N ▶	'
▶ N for some β < α. Let χ be the tree witnessing

N ▶	γ  '
T p → p and Cβ ∪ Uβ
γ  '

T p → p and L the set of predecessors of the root p → p of χ. By definition we then have a rule
ρ = 	ϕ	 and substitution σ such that σ(xi)= pi for all i with 1 ≤ i ≤ n, uσ = p' and L ▶ ϕσ.
f (x1 ,...,xn ) → u

We show that there is a q'
such that q → q'
∈ C and p'
R q' by induction on the length of χ. We

observe that the subtrees of χ are witnesses for the statements N ▶T l for all l ∈ L. As these subtrees are obviously smaller than χ itself, we can apply the induction hypothesis to the elements of L.

We construct a substitution τ such that we can derive that there is an N' with N' ▶
γ
T f (q1,..., qn) → uτ .

To do this we want to use the proof for ϕσ to prove ϕτ . For this we need to be able to mimic every element
l of L. If l is a positive literal, this will follow from the bisimulation relation. If it is a negative literal, then


there are two cases: either we can mimic l or we can not. If we can, we are satisfied. Otherwise we will show that there is another proof that does not depend on this negative literal.
Let Υ be a proof tree of ϕ with leaves L' and substitution σ' such that ϕσ' = ϕσ,

γ	'	γ
' '	'

(f (x1,..., xn) → u)σ
= (f (x1,..., xn) → u)σ and L = L σ . That is, Υσ
δ
is a witness for L ▶ ϕσ. We
'

say that a negative literal ч t → y is not required (w.r.t. Υ) if there is a process r such that σ (y)Rr and
' δ	δ
tσ → r ∈ Cβ ∪ Uβ . That is, a negative literal ч t → y is not required if there are (one or more) terms that
are related to σ'(y) (the value that y has in the actual proof of ϕσ) by R that are “reachable” from t (i.e.
δ
t → r). Note that this requirement comes from the negation of the transfer condition of the bisimulation
relation; we can only deduce that a term u related to t (i.e. uRt) cannot reach σ'(y) if t cannot reach any term of the equivalence class of σ'(y) (induced by R). We remove all not-required negative literals from the proof as these literals (and only these) might not be possible to mimic. We do this from the outermost 6s of ϕ inwards.
We use a recursive procedure to eliminate all not-required negative literals from Υ. The result will be a tree Υ'. In every step of the procedure we remove all negative literals from the outermost relevant 6 (i.e. a 6 that binds a variable x that occurs as the right-hand side of a not-required negative literal). While doing this, we derive a σ'' from σ' such that for all positive literals l ∈ L' we have that Cα ▶ lσ'', for all negative literals l ∈ L' we have that Cβ ∪ Uβ ▶ lσ'', and for all universally quantified variables x from ϕ we have that σ''(xλ.t)Rt for all t. We start with σ'' = σ'.
δ	'	δ'	'

Now, let ч t → y ∈ L be a literal that is not required such that there is no literal ч s → z ∈ L
where y

is bound within the scope of z and such that this negative literal is also not required. By definition we then

have a process r such that σ''
(y)Rr and tσ
δ
→ r ∈ Cβ ∪ Uβ . As y is universally bound, we know that there

is a 6x
in Υ' such that y = xλ.σ'' (y)
δ
, for some label λ, and that ч t → y is a leaf of the subtree corresponding

to σ''(y) of this 6x. We replace this subtree by the subtree corresponding to r where each variable zλ.r.μ
is substituted by zλ.σ'' (y).μ (such that the resulting tree is correctly labelled). Finally we change σ'' such
that σ''(zλ.σ'' (y).μ) becomes σ''(zλ.r.μ) for all variables z and labels μ. That is, we also make sure that the values assigned to the variables in the new subtree get the values form the subtree corresponding to r. It is trivial to see that σ'' satisfies the requirements for this new tree.
We now construct a substitution τ that, together with proof tree Υ' for ϕ, gives a q' such that q → q' ∈ C. We define τ (xi) = qi for all 1 ≤ i ≤ n and take τ (xλ.t) = t for all variables x, terms t and labels λ (as is required for τ for be a witness for ϕτ ). Also, for all variables xλ bound existentially in Υ' that do not
occur in the right-hand sides of leaves of Υ' we set τ (xλ) = σ''(xλ). Note that we have that τ (x)Rσ''(x) for all variables x for which we have defined τ . When defining the rest of τ we will maintain this property.
Let S be the set of (existential) variables that occur in the right-hand sides of leaves of Υ' (for which τ is not yet defined). Also, let < be the well-founded order on S. With induction on the size of S we complete the definition of τ . If S is empty, then we are obviously finished. Let x be a smallest element of S and

t → x ∈ L''
where L''
consists of the leaves of Υ'. By definition we have that tτ is well-defined and thus

' δ  '	''	δ
that tσ → σ (x)Rtτ . As we have that tσ  ∈ Cα, we get by induction that there is a r such that tτ → r ∈ C
and σ''(x)Rr. We take τ (x)= r.
This completes the definition of τ . This means we have an application of ρ that gives a q' such that
γ  '	γ  '
q → q . To show that this q → q is in C, we must show that there are proofs for the positive literals in L and
that the negative literals form L are not in C. The former follows trivially form the induction. For negative
δ	''	'

literals ч t → y ∈ L we have the following. By construction of Υ
we have that there is no r such that

'	' δ	δ
σ (y)Rr and tσ → r ∈ Cβ ∪ Uβ . By induction we then have that there is also no r such that tτ → r ∈ C.
Thus C ▶ ч tτ →δ τ (y).
This concludes the proof.

C  Proof of Theorem 5.11
Let ⟨Σ, R⟩ be a traditional TSS and let ⟨Σ, R'⟩ be the translation of ⟨Σ, R⟩ to a FOL-TSS. Assume that
⟨Σ, R⟩ is in the ntyft/ntyxt format. We show that each deduction rule of ⟨Σ, R'⟩ is either in the FOL-tyft format or in the FOL-tyxt format. Each deduction rule from R' originates from a deduction rule from R. Consider such a deduction rule. Since ⟨Σ, R⟩ is in the ntyft/ntyxt format, the deduction rule it is of the form


{ti
a
→ yi
a'
| i ∈ I}∪ {t' ~j
| j ∈ J}
{ti
a
→ yi
a'
| i ∈ I}∪ {t' ~j
| j ∈ J}

f (x , ··· ,x ) →a t'	or
x →a t'

1	n

where the variables in the right-hand sides of the premises and the source of the conclusion are all different. Let us consider the case that the deduction rule is of the first form. The deduction rule from R' that

corresponds to this traditional deduction rule is


'
ai	'  j	'
{ti →yi | i ∈ I}∪ {6x(t' ) (ч tj →x(tj )) | j ∈ J}
f (x1, ··· , xn) →a t'

where x is a mapping that associates with a term t a variable that does not occur free in t, i.e., x(t) /∈ var(t). Next, we will show that this deduction rule is in the FOL-tyft format. We use the following no-
V	a	a'	a


N = {6  '
i	i
'
' j	'
x(t ) (ч tj → x(tj )) | j ∈ J}, P+	i	i

x(t ) (ч tj → x(tj )) | j ∈ J}.

dv(φ) = 6ψ∈P+ ∪N dv(ψ) Λ 6ψ,ψ' ∈P+ ∪N (ψ /= ψ' ⇒ ubrhs(ψ) ∩ ubrhs(ψ')= ∅)
= 6ψ∈P+ dv(ψ) Λ 6ψ∈N dv(ψ)
Λ 6ψ,ψ' ∈P+ ∪N (ψ /= ψ' ⇒ ubrhs(ψ) ∩ ubrhs(ψ')= ∅)

ai
= 6	dv(t → y ) Λ6 
dv(6 '
'
' j	'

i∈I
i	i	j∈J
x(t ) (ч tj → x(tj )))

Λ 6ψ,ψ' ∈P+ (ψ /= ψ' ⇒ ubrhs(ψ) ∩ ubrhs(ψ')= ∅)
Λ 6ψ∈P+ ,ψ' ∈∪N (ψ /= ψ' ⇒ ubrhs(ψ) ∩ ubrhs(ψ')= ∅) Λ 6ψ∈N,ψ' ∈P+ (ψ /= ψ' ⇒ ubrhs(ψ) ∩ ubrhs(ψ')= ∅) Λ 6ψ,ψ' ∈N (ψ /= ψ' ⇒ ubrhs(ψ) ∩ ubrhs(ψ')= ∅)
a'

= true Λ6 
' j	'

j∈J dv(ч tj → x(tj ))

Λ 6	ai
ai'
ai	ai'

i,i' ∈I (ti → yi /= ti' → yi' ⇒ ubrhs(ti → yi) ∩ ubrhs(ti' → yi' )= ∅)
Λ 6ψ∈P+ ,ψ' ∈∪N (ψ /= ψ' ⇒ ubrhs(ψ) ∩ ubrhs(ψ')= ∅) Λ 6ψ∈N,ψ' ∈P+ (ψ /= ψ' ⇒ ubrhs(ψ) ∩ ubrhs(ψ')= ∅) Λ 6ψ,ψ' ∈N (ψ /= ψ' ⇒ ubrhs(ψ) ∩ ubrhs(ψ')= ∅)
= 6i,i' ∈I (i /= i' ⇒ {yi}∩ {yi' } = ∅)
Λ 6ψ∈P+ ,ψ' ∈∪N (ψ /= ψ' ⇒ ubrhs(ψ) ∩ ubrhs(ψ')= ∅) Λ 6ψ∈N,ψ' ∈P+ (ψ /= ψ' ⇒ ubrhs(ψ) ∩ ubrhs(ψ')= ∅) Λ 6ψ,ψ' ∈N (ψ /= ψ' ⇒ ubrhs(ψ) ∩ ubrhs(ψ')= ∅)
= 6i,i' ∈I (i /= i' ⇒ yi /= yi' )
Note that the last step is due to the fact that for any n ∈ N , ubrhs(n)= ∅.

ubrhs(φ) = ubrhs(V P+ ∪ N )

= Sψ∈P+ ∪N
ubrhs(ψ)

= Sψ∈P+
S
ubrhs(ψ) ∪ S
a

ψ∈N
S
ubrhs(ψ)
a'

i∈I
S
i	i	j∈J
S
x(t ) (ч tj → x(tj )))
a'

i∈I
i	j∈J (ubrhs(ч tj → x(tj )) \ {x(tj )})
S	a'

i	j∈J (ubrhs(tj → x(tj )) \ {x(tj )})
= {yi | i ∈ I}∪ S	(var(x(t' )) \ {x(t' )})

= {yi | i ∈ I}
j∈J	j	j


The requirement ubrhs(φ) ∩ {x1, ··· , xn} = ∅ thus reduces to {yi | i ∈ I}∩ {x1, ··· , xn} = ∅.
Clearly these requirements are implied by the restrictions of the ntyft format on the original deduction rule that the right-hand sides of the premises and the variables in the source of the conclusion are all different.

Let S = FV (φ) \ {x1, ··· , xn}. Then,


extS (φ) = extS (V P+ ∪ N )
= 6ψ∈P+ ∪N extS (ψ)
= 6ψ∈P+ extS (ψ) Λ 6ψ∈N extS (ψ)
a	a'

= 6	ext
(t →i y ) Λ6 
ext (6  '
' j	'

i∈I	S  i	i
j∈J
S  x(t ) (ч tj → x(tj )))

= 6	y
∈ S Λ6 
ext	'
'
' j	'

i∈I i
j∈J	S\{x(t )}(ч tj → x(tj ))
a'

= 6	ext
'	j	'

j∈J
= true
S\{x(t )}(tj → x(tj ))


ext∅

(ч φ)= ext∅

(φ)= ext∅
a'
(V P+

∪ N )= 6


ψ∈P+

ext∅

(ψ) Λ 6ψ∈N
a'

ext∅

(ψ)= 6


ai

i∈I ext∅ (ti → yi) Λ
a'

6	ext∅ (6 '
' j	'
ext	'
' j	'
ext	'
' j	'

j∈J
x(t ) (ч tj → x(tj ))) = 6j∈J
{x(t )}(ч tj → x(tj )) = 6j∈J
{x(t )}(tj → x(tj )) =

6j∈J x(t' ) ∈ {x(t' )} = true
j	j
Let S = FV (φ) \ {x1, ··· , xn}. Then,
hS (φ) = hS (V P+ ∪ N )
a	a'

= 6	hS (t →i y ) Λ6 
hS (6  '
' j	'

i∈I
i	i	j∈J a'
x(t ) (ч tj → x(tj )))
a'

= 6	∅
' j	'	S
' j	'

j∈J (h
(ч tj → x(tj )) Λ k{x(t' )}(ч tj → x(tj )))

'
= 6	∅  ' j	'	S
'
' j	'

j∈J (h
(tj → x(tj )) Λ k{x(t' )}(tj → x(tj )))

= 6j∈J (x(t' ) ∈ S \ {x(t' )} ⇒ var(t' ) ∩ {x(t' )} = ∅)

j
= true
j	j	j


The case where the deduction rule is in the ntyxt format is similar and therefore omitted.
