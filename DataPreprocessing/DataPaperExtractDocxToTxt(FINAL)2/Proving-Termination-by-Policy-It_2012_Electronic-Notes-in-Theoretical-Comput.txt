Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 287 (2012) 77–88
www.elsevier.com/locate/entcs
Proving Termination by Policy Iteration
Damien Mass´e1
Lab-Sticc, UMR 6285
UBO - Universit´e Europ´eenne de Bretagne Brest, France

Abstract
In this paper, we explore the adaptation of policy iteration techniques to compute greatest fixpoint ap- proximations, in order to find sufficient conditions for program termination. Restricting ourselves to affine programs and the abstract domain of template constraint matrices, we show that the abstract greatest fixpoint can be computed exactly using linear programming, and that strategies are related to the tem- plate constraint matrix used. We also present a first result on the relationships between this approach and methods which use ranking functions.
Keywords: Abstract interpretation, policy iteration, template constraint matrices, termination analysis.


Introduction
Abstract interpretation [5] is a powerful framework to develop program analyses. Most analyses require the computation of approximation of fixpoints on an ab- stract domain, either least fixpoints (lfp) or greatest fixpoints (gfp). The traditional method to compute approximations of fixpoints uses widening and narrowing op- erators. Widening operators are designed to get beyond the fixpoint, which makes them useful to compute overapproximations of lfp, or (dually) underapproximations of gfp [6]. However, used on state abstractions, these approximations can only be used to check safety properties. Liveness properties (and especially termination) can be proved by computing underapproximations of lfp or overapproximations of gfp.
More recently, other approaches have been developed to compute abstract fix- points: abstract acceleration [12] and policy iteration [3,9]. Both methods are designed in order to compute the exact abstract fixpoint for specific transfer func- tions. They have been used to compute reachability analyses (which involves the computation of an lfp), and since the abstract domains used were overapproximating

1 Email: damien.masse@univ-brest.fr


1571-0661 © 2012 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2012.09.008

domains, they were applied to prove safety properties, providing a greater precision than widenings. Using these approaches to compute greatest fixpoints would enable the discovery of sufficient conditions for program termination, and as a particular case proving termination for all inputs.
This paper describes the use of policy iteration techniques to discover sufficient termination conditions. As a first work in this direction, we restrict ourselves to affine programs and to the template constraint matrices abstract domain [14], a sub-domain of polyhedra. Policy iteration techniques were already used in this framework to approximate the set of reachable states [10], hence we need to adapt these results to greatest fixpoint computations.
We first present the relationships between approximating fixpoints and proving termination. Then we give an overview of the policy iteration approach. In section 4, we explore the extension of these approaches to the computation of an abstract backward semantics designed to prove termination properties. Finally we give a first result on the relationships between our approach and ranking function synthesis, showing that programs admitting a linear ranking function can be treated with our approach.
Program termination and fixpoint approximation
In this section, we recall a few results on the relationships between termination and fixpoint approximation. A program P is defined as a transition system (Σ,τ ), Σ being an (infinite) set of states and τ ⊆ Σ × Σ a transition relation. Furthermore, we consider S0 as the set of initial states.
The trace semantics of a program P is the set of finite and infinite execution traces of P . The program is said to (definitely) terminate from S0 if any execution trace starting from s0 ∈ S0 is finite. Broadly, three approaches can be used to show this property.
Variant abstraction analysis. Many methods use a kind of variant abstraction anal- ysis [7], where one finds a mapping r from the set of reachable states (from S0) toa well-founded set (O, <), such that for any transition ⟨σ, σj⟩∈ τ we have r(σj) < r(σ). Once the class of variant functions (or the variant abstraction) is fixed, the analysis can be expressed as a safety analysis.
Least ﬁxpoint underapproximation. An alternative approach is to prove that S0 is included in the set of states which could only terminate, that is:
(1)	S0 ⊆ lfp λX.p˜re(X)
where pre(X)= {y ∈ Σ | ∀x ∈ Σ, ⟨y, x⟩∈ τ ⇒ x ∈ X}.
This property requires to underapproximate the least fixpoint. As noted in [7], underapproximations are not much used in practice (most abstract domains, in particular numerical abstract domains, are designed to handle overapproximations). Furthermore, one cannot use a the “classical” fixpoint induction techniques (with widenings) to underapproximate least fixpoint.
Greatest ﬁxpoint overapproximation. Similarly, we can show that S0 is disjoint from

the set of states that are potentially non-terminating, i.e.:
(2)	S0 ∩ gfp λX.pre(X)= ∅
where pre(X)= {y ∈ Σ | ∃x ∈ X,⟨y, x⟩∈ τ}.
Proving this property can be done by overapproximating the greatest fixpoint. Compared to the (formally equivalent) previous approach, using overapproximations has the advantage of being compatible with most abstract domains. However, we still cannot use widenings to approximate the fixpoint.
The three approaches are related: with a ranking function, one can prove for- mulas (1) and (2). Reciprocally, proving formula (1) or (2) proves that a ranking function exists. In fact, some lower fixpoint induction methods (e.g. in [4, Sect. 11]) directly use some kind of ranking function. However, if the approximation is proved with other methods, it may be difficult to make the ranking function ex- plicit. Hence, techniques which compute directly a fixpoint appear as interesting alternatives to infer termination properties.

Precise fixpoint approximation with policy iterations
The use of policy iterations (also called strategy iterations) to compute the least fixpoint of a self-map f in static analysis was first introduced in [3]. The principle of this techniques is to describe f as the minimum (or the maximum) of a set S of simpler maps. A strategy (or a policy ) is a selection of an element of S. The least fixpoint of this element is computed. If this fixpoint is a fixpoint of f , the algorithm terminates, otherwise a new strategy is selected during the strategy improvement step, and the algorithm iterates.
Two different approaches have been proposed to compute least fixpoints: the first one [3,8,1] uses min-strategy iteration, approaches the least fixpoint from above, and does not guarantee to return it in the general case 2 . The second one [9,10,11] uses max-strategy iteration, approaches the least fixpoint from below, and guarantees to return the least (abstract) fixpoint.
Since our goal is to overapproximate greatest fixpoints, it seems more natural to approach them from above, hence to use a dual version of the second approach. In this paper, we mainly follow the method presented in [10] and restrict ourselves to affine programs and template constraint matrix domains. Before summarizing the method, we introduce a few notations.

Notations
In the following, X = {x1,..., xk} denotes a tuple of variables. An assignment ρ on X is defined as a mapping from X to R = R ∪ {−∞, +∞}. When there is no ambiguity, ρ may be represented as an element of Rk. The order relation ≤ (and its strict version <) on R is extended component-wise to Rk. We denote by ∨ and ∧

2 However, it does return the least fixpoint in the case of nonexpansive self-maps.



the minimum and maximum operators on R (and their component-wise extension to Rk). Hence Rk has a complete lattice structure.
If ρ is an assignment on X, we denote by [ρ]f (resp. [ρ]∞, [ρ]—∞) the set of x in
X such that ρ(x) is finite (resp. equal to +∞, −∞).
If m is a function from X → R to R, dom(m) represents the set of assignments ρ such that m(ρ) is finite, and fdom(m)= dom(m) ∩ RX . The function m is said to be order-convex (resp. order-concave) iff fdom(m) is convex 3 and for all comparable ρ, ρj in fdom(m) and λ ∈ [0, 1], λm(ρ)+ (1 − λ)m(ρj) ≥ m(λρ + (1 − λ)ρj) (resp. λm(ρ)+ (1 − λ)m(ρj) ≤ m(λρ + (1 − λ)ρj).
Let D be a monotonic function from X → R to X → R. A preﬁxpoint (resp. postﬁxpoint ) of D is an assignment ρ such that D(ρ) ≥ ρ (resp. D(ρ) ≤ ρ). If ρ is a prefixpoint (resp. postfixpoint) of D, we denote by lfp≥ρD (resp. gfp≤ρD) the least (resp. greatest) fixpoint of D greater than (resp. lower than) ρ.
Finally, an equation system E on X is a k-tuple of equations (x1 := e1,..., xk := ek) where ei are expressions using the variables X. If J·) represents the semantics of expressions (such that Jei) ∈ (X → R) → R), the semantics of E is defined as:
JE ) : (X → R) → (X → R)
JE ) ρ : xi ⊆→ Jei) ρ
A solution (resp. postsolution, presolution) of E is a fixpoint (resp. postfixpoint, prefixpoint) of JE ).

Computing the least solution of a system of equations
We consider an equation system E on X where the expressions are defined by the grammar:
e ::= a | xi | e + e | b · e | e ∨ e | e ∧ e

where a ∈ R, b ∈ R>0, ∨ is the max operator and ∧ is the min operator. The semantics of e is straightforward:
Ja) ρ = a	Je1 + e2) ρ = Je1) ρ + Je2) ρ	Jb · e) ρ = b Je) ρ
Jxi) ρ = ρ(xi)	Je1 ∨ e2) ρ = Je1) ρ ∨ Je2) ρ	Je1 ∧ e2) ρ = Je1) ρ ∧ Je2) ρ
The least solution of E can be computed using max strategy iteration [10]:
a max-strategy π is a function mapping every expression e1 ∨e2 to a subexpression e1 or e2; applying π to E gives a system of conjunctive equations (without the ∨ operator) Eπ;
the least solution μπ greater than a current presolution of Eπ is computed by solving two linear programs extracted from the system in linear time;
the computation terminates if μπ is a solution E , otherwise a new strategy πj is selected (such that JE ) (μπ)= JEπ′ ) (μπ)), and the computation loops.

3 For all ρ, ρ′ in fdom(m) and λ ∈ [0, 1], λρ + (1 — λ)ρ ∈ fdom(m).

In [10] and [11], the notions of consistent presolution and feasible presolution are defined to ensure the validity and the termination of this approach. In section 4, the dual notions will be used to compute greatest fixpoints.

Systems of rational equations with linear programs
Equations with linear programs (LPs) are defined by adding LPA,b(e,..., e) in the grammar of expressions, with A ∈ Rm×n and b ∈ Rn. The semantics of LPA,b is defined as:
JLPA,b(e1,..., em)) ρ =  {bT x | x ∈ Rn, Ax ≤ (Je1) ρ,..., Jem) ρ)}
Rational equations with linear programs are used to express the abstract semantics of affine programs in the template constraint matrix domain [14].
In [10], Gawlitza and Seidl show that LP subexpressions can be handled during the resolution of the system of conjunctive equations by adding new variables and inequations. In [11], this result is generalized to order-concave equations, using the fact that the operator ∧ and LP expressions are order-concave. Since the backward semantics of programs also use LP expressions, this result cannot be applied directly to compute overapproximations of greatest fixpoints: one would need order-convex expressions.

Computation of the backward semantics
Backward semantics of the program
We consider affine programs as a triple (N, E, st) where N is a finite set of program points, E ⊆ N × Stmt × N is a finite set of transitions labeled by statements, and st is the start program point. A statement is a pair (g; a) where g is an affine guard Ax + b ≥ 0 on the set of program (real) variables x = (x1,..., xn) and a is an affine assignment x := Ax + b.
The backward collecting semantics of a statement s = (Ax ≤ b; x := Cx + d) is defined as:
Js) : ℘ (Rn) → ℘ (Rn)
Js) (X)= {x ∈ Rn | Ax + b ≥ 0 ∧ Cx + d ∈ X}
The backward transformer pre on N  → ℘ (Rn) is defined as pre(X)(u) = (u,s,v)∈E Js) (v). Our goal is to overapproximate B = gfp pre. We use the frame- work of abstract interpretation, and our approach is closely related to the abstract
domain used (we want to compute exactly the abstract fixpoint).
The abstract domain (first introduced in [14]) is relative to a template constraint matrix T ∈ Rm×n. Each row of T represents a linear combination of program

variables. The matrix T defines an abstraction from Rn to TT
Galois connection Rn →−γ−T−− T :
T
= Rm with the

γT (ρ)= {x ∈ Rn | Tx ≤ ρ}	αT (X)= ∨{ρ|γT (ρ) ⊆ X}

The functions γT and αT are extended component-wise to N → Rn and N → TT .
m
An element of γT (R ) is said to be canonical. The best abstract backward semantics
of a statement s in this domain is defined as Js) = αT ○ Js) ○ γT .
Lemma 4.1 Let s = (Ax + b ≥ 0; x := Cx + d) be a statement, and T a non-empty template matrix. Let ρ be an abstract value on the domain TT .
Let Aj, bj and ρj be deﬁned as:
j	⎛ −A ⎞	j	⎛ −b ⎞	j	⎛ 0 ⎞

(3)
A =	b =	ρ =
TC	Td	ρ
Then Js) satisﬁes:

⎧⎨ −∞	if {x | Ajx + bj − ρj ≤ 0} = ∅

Js)i (e)= 
⎩
 {(ρj − bj)T λ | λ ≥ 0 ∧ AjT λ = Ti} otherwise

Remark 4.2 If {x | Ajx + bj − ρj ≤ 0} /= ∅ and {λ | λ ≥ 0 ∧ AjT λ = Ti} = ∅, then Js) (ρ)= ∞. Furthermore, {x | Ajx + bj − ρj ≤ 0} /= ∅ implies min{(ρj − bj)T λ | λ ≥ 0 ∧ AjT λ = Ti} > −∞ (but the converse is not true).
Example 4.3 With only one variable x1,  s  =  (0  ≥  0; x1  =  0) and
T =	1 ⎞, we have  {(ρj − bj)T λ | λ ≥ 0 ∧ AjT λ = T } = ∞ for all i and all
⎝ −1 ⎠	i
ρ = (ρ1, ρ2). However, if ρ1 < 0 or ρ2 < 0, then {x | Ajx + bj − ρj ≤ 0} = ∅. Thus,

by defining (ρj , ρj )= Js) (ρ1, ρ2), we have ρj = ρj
= −∞ if ρ1 < 0 or ρ2 < 0, and

1	2	1	2

j = ρj
= ∞ otherwise.

The abstract domain for a program (N, E, st) is N → TT 4 . With X ∈ N → TT , the abstract backward transformer pre = αT ○ pre ○ γT is given by:

(pre (X)(u))i =	 
(u,s,v)∈E
Js) (X(v))

Lemma 4.4 The abstract semantics gfp pre satisﬁes γT (gfp pre ) ⊇ B.
To compute the greatest fixpoint of pre , we describe the function as a system of semantic equations of the form xi = pre (x) when pre appears as the maximum of
i	i
(one or) several Js) . Following lemma 4.1, Js) can be expressed as the minimum
i	i
of two expressions φs (independent of i) and ψi :
⎧ ∞	if {x | Ajx + bj − ρj ≤ 0} /= ∅
φs(ρ)=	.
⎩ −∞	if {x | Ajx + bj − ρj ≤ 0} = ∅
ψi (ρ)=  {(ρj − bj)T λ | λ ≥ 0 ∧ AjT λ = Ti}

4 For the sake of simplicity, we consider only one global template constraint matrix.

φ = alltrue({Cx + C−x ≥ 0, Cy + C−y ≥ 0, Cx+y + C−x−y ≥ 0, Cx−y + C−x+y ≥ 0, Cx + Cy + C−x−y ≥ 0, C−x + C−y + Cx+y ≥ 0, Cx + C−y + C−x+y ≥ 0, C−x + Cy + Cx−y ≥ 0, 2Cx + C−x−y + C−x+y ≥ 0, 2C−x + Cx+y + Cx−y ≥ 0, 2Cy + C−x−y + Cx−y ≥ 0,
2C−y +Cx+y +C−x+y ≥ 0, 2C−y +C−x +26 ≥ 0, Cx +C−x−y +26 ≥ 0, 3C−x +2Cx−y +
26 ≥ 0, C−y + C−x−y + 26 ≥ 0, 3C−y + 2C−x+y + 26 ≥ 0, C−x−y + Cx−y + 52 ≥ 0}).
Cx := φ ∧ 10 + Cx/2 ∧ 23 + C−x−y ∧ (17 + 2C−x+y)/3
∧ Cy — 3 ∧ Cx+y + C−x — 3 ∧ C−x+y + Cx — 3
C−x := φ ∧ C−y +3 ∧ C−x−y + Cx +3 ∧ Cx−y + C−x +3 
Cy := φ ∧ C−x/2 ∧ (C−x−y + Cy)/2 ∧ (C−x+y + C−y)/2
C−y := φ ∧ Cx/2 ∧ (Cx+y + C−y)/2 ∧ (Cx−y + Cy)/2 ∧ 13 + C−y ∧ (13 + Cx−y)/3 Cx+y := φ ∧ C−x/2+ Cy — 3 ∧ 3C−x/2+ Cx+y — 3 ∧ (3Cy + C−x−y)/2 — 3
∧ (Cy + C−x+y)/2 — 3 ∧ (Cx+y + 3C−x+y)/4 — 3 ∧ 10 + C−x ∧ 36 + 2C−x−y
∧ (4 + 2C−x+y)/3
C−x−y := φ ∧ Cx/2+ C−y +3 ∧ 3Cx/2+ C−x−y +3 ∧ (3C−y + Cx+y)/2+3 
∧ (C−y + Cx−y)/2+3 ∧ (C−x−y + 3Cx−y)/4+3 ∧ 16 + 2C−y
Cx−y := φ ∧ 10 ∧ Cx/2+ Cy — 3 ∧ 3Cx/2+ C−x+y — 3 ∧ C−x/2+ Cx+y +3 
∧ (Cy + Cx+y)/2 — 3 ∧ (3Cy + Cx−y)/2 — 3
C−x+y := φ ∧ C−x/2+ C−y +3 ∧ 3C−x/2+ Cx−y +3 ∧ C−x/2+ Cx+y +3 
∧ (C−y + C−x−y)/2+3 ∧ (3C−y + C−x+y)/2+3 

Fig. 1. Backward semantics of the transition s = (x — y ≤ 10; {x := —2y, y := x + 3}) in the octagon domain, described as a system of equations. Each variable Cexp represents the maximum of exp in the abstract element. We denote by alltrue the function which maps a set of constraints to ∞ if all constraints are satisfiable, and —∞ otherwise.
One can see that φs is monotonic, order-concave and order-convex (since fdom(φs) = ∅). Using the vertex principle of linear programming, we can express ψi as the minimum of a finite number of linear expressions:
Lemma 4.5 There exists a ﬁnite (possibly empty) number of tuples (λ1,..., λk)
such that λj ≥ 0 and AjT λj = Ti for all j and, for all ρ > −∞:
k
i	j	j
s
j=1
This equality is also satisfied when some components of ρ are equal to +∞. In this case, the matching component of λ must be equal to 0.
The number of linear expressions can be exponential in the number of variables. Rather than computing all of them, we plan to lazily compute only the relevant expressions during the selection of the strategy (see remark 4.9).
Example 4.6 With two variables x and y, s = (x−y ≤ 10; {x := −2y, y := x + 3}) and the octagon template matrix [13], Js) is represented Figure 1. This example shows that the number of ∧ operators is related to the template domain, both in order to deal with the potential non-canonicity of e and to ensure the canonicity of Js) (e). For example, if the initial assignment is canonical, we have directly C—y ≤ C—x—y + Cx and C—y ≤ Cx—y + C—x, hence the equation of C—x is equivalent to C—x := φ ∧ C—y + 3.
From the previous lemma, we deduce:
Proposition 4.7 The backward abstract semantics of an affine program (N, E, st)
in a template matrix domain can be expressed as the greatest ﬁxpoint of a system of

equations of the form:
x := U1 ∨ U2 ∨ ... ∨ Uk	with Ui := φi ∧ u1 ∧ ... ∧ ul
i	i
where φi is a monotonic function whose image is included in {−∞, +∞} and uj
are linear expressions.
Remark 4.8 If an overapproximation of the reachable states has been computed, it can be included in the system of equations (if the abstract forward analysis returns x = a, the equation becomes x := a ∧ (U1 ∨ ... ∨ Uk)). This combination increases the precision of the backward analysis [6].
Remark 4.9 Since the explicit computation of the system is too costly, we express each Ui as φi ∧ ψi where ψi is a linear program. During the strategy selection phase, an optimal uj is constructed by solving the linear program with the current affectation ρ: if there is an optimal solution λ, then λ(ρj − bj) is used (if it is an improvement compared with the current strategy), otherwise the strategy returns
+∞. The number of basic feasible solutions may be high, but most are related to the canonicity of the abstract elements, so we can expect the number of selected strategies to remain acceptable.
Similarly, we do not expect to compute explicitly φi as a set of constraints on ρ.
Rather, we check the feasibility of the domain at each strategy iteration.
Solving the system of equations
Following the policy iteration principle, we consider a strategy associating each expression φi ∧ u1 ∧ ... ∧ ul (or rather φi ∧ ψi) to either φi or a linear expression
i	i
uk. If ρ is the current assignment, the strategy πρ must satisfy:
(4)	πρ(φi ∧ u1 ∧ ... ∧ ul)= min(φi(ρ), u1(ρ),..., ul(ρ))
i	i	i	i
Since the image of φi is included in {−∞, +∞}, we can ensure that πρ(φi ∧.. .)= φi only when φi(ρ)= −∞. Furthermore, since φi is monotonic and we compute a decreasing sequence, once φi(ρ)= −∞ the whole expression can be replaced by −∞. Thus, the application of πρ gives a system of equations of the form (x := u1∨.. .∨uk) where each ui is either −∞ (which can be ignored) or a linear expression. This system is a system of disjunctive equations.
Given a postsolution ρ of a disjunctive system E , we want to compute gfp≤ρ JE ). Since our approach is exactly the dual of the method proposed in [10], we just give a definition of consistency and the final theorem here.
Definition 4.10 Given a disjunctive system E , a finite solution ν of E is said to be feasible iff there exists ρ > ν such that JE ) (ρ) < ρ. A finite postsolution ρ is feasible iff gfp≤ρ JE ) is finite and feasible. A disjunctive system is feasible iff it admits a feasible solution.
Definition 4.11 Given a disjunctive system E , a postsolution ρ is said to be con- sistent iff the following conditions are satisfied:
Jexp) ρ = ∞ implies exp = ∞ for every expression exp occurring in E ;

with ν = [gfp≤ρ JE )]f , the system Ej on νf defined by replacing in the equations of E any variable x ∈ ν∞ by ∞ and x ∈ ν—∞ by −∞ is feasible, and ρ|νf is a feasible postsolution of Ej.
Theorem 4.12 ([10, Thm 3, dual]) Given a consistent postsolution ρ of a dis- junctive system E, gfp≤ρ JE ) can be computed by solving two LPs extractable from E in linear time.

Strategy improvement
We still need to prove that the strategy improvement operator preserves consistency. First we rewrite all equations x := U as x := +∞∧ U . The initial strategy π∞ associates each equation to +∞. In the associated system, (xi ⊆→ +∞) is consistent. Consistency is preserved under three conditions:
Lemma 4.13 Let π be a strategy, ρ an assignment and πj an improved strategy satisfying:
for each maximum of order-convex expressions ∧U, if π(∧U )(ρ)= πj(∧U )(ρ), then π(U )= πj(U );
if π(∧U ) /= πj(∧U ), then πj(∧U )(ρ) < π(∧U )(ρ);
if πj(∧U )(ρ) < ∞, then for all ρj ≥ ρ with [ρj]f = [ρ]f , πj(∧U )(ρ) < ∞. Then any consistent solution of π(E ) is a consistent postsolution of πj(E ).
Conditions (i) and (ii) are consequences of the principle of strategy improvement. The third one is satisfied because we use linear expressions. The termination of the computation is guaranteed by the finite number of strategies. As mentioned in remark 4.9, we expect the number of iterations to remain low, but more experiments are needed to validate this hypothesis.
Finally, we can state the general result on whole programs:
Theorem 4.14 Given an affine program (N, E, st) and a template matrix T, the algorithm terminates and returns the abstract semantics gfp pre .
Example 4.15 We consider a program (N, E, i) with only one program point N =
{i} and E = {(i, s, i)} with s defined as in example 4.6. Figure 2 gives the sequences of strategies (as systems of equations) and the fixpoints (as constraints on x and y). The set of non-terminating states is included in each fixpoint (in this example, the last fixpoint is exactly the set of non-terminating states). Thus, from any initial state except (x = −2; y = 1), the program terminates.

Relationships with variant analysis
To compare our method with variant analysis, we search a correspondence between the provability of termination with policy iteration and the kind of ranking functions which can be used to prove the termination of the program.


Fig. 2.  Computation of the abstract semantics for a single state program with one transition (x — y ≤ 10; {x := —2y, y := x + 3}) in the octagon domain. The initial strategy (+∞) is omitted.

When the program is given, the result of the policy iteration-based analysis depends only on the abstract domain, since it computes exactly gfp pre where pre = α ○ pre ○ γ. First, we can see that a ranking function can be constructed from the iteration sequence of pre .
Lemma 5.1 Let Σ = N → ℘ (Rn) be the set of states of the program, and τ the transition relation between elements of Σ. Let (Wi) be the iteration sequence of pre starting from (x ⊆→ +∞) and O an ordinal such that WO—1 = gfp pre . Then the function v deﬁned from Z =Σ \ γT (gfp pre ) to O as:
v(σ)= min{i | σ ∈/ γT (Wi)}
is a ranking function on (Z, τ ).
Furthermore, for all n ∈ O, v—1({nj ∈ O | nj ≥ n}) ∪ γT (gfp pre ) is canonical. This property can be reversed to deduce a condition on gfp pre from the existence of a ranking function:
Proposition 5.2 Let Z ⊆ Σ and Y =Σ \ Z. Then γT (gfp pre ) ⊆ Y if and only if there exists a function v from Z to an ordinal O such that:
∀s ∈ Z, ∀sj ∈ Σ, ⟨s, sj⟩∈ τ ⇒ (sj ∈ Z ∧ v(s) > v(sj))
∀n ∈ O, v—1({nj | nj ≥ n}) ∪ Y ∈ γT (N → TT )
Hence, the abstract semantics would prove the termination for all inputs (i.e. Z = Σ) if there exists a ranking function v for which the successive preimages v—1(O), v—1(O \ {0}), v—1(O \ {0, 1}), ... for every program point are of the form TX ≤ B.
Corollary 5.3 If an affine program can be proved to terminate with a linear ranking function X ⊆→ RX, our method proves the termination of the program if −R is a row of T .

However, the program given in example 4.15 does not admit a linear ranking function. Thus our method is not limited to linear ranking functions, and a global characterization of the ranking functions remains to be stated.
Conclusion and future work
This paper is intended to show how policy iteration techniques can be applied to termination analysis. We performed only a few experiments, and more comparisons with related work needs to be done. Recently, Bozga et al. [2] presented several results on the decision of conditional termination. Their framework is more restric- tive (as they restrict themselves to integer variables), but may give more precise results as it is not limited by the precision of the abstract domain.
To improve the analysis, we can extend previous work on policy iterations for other abstract domains (e.g. quadratic zones [11]). Although we dealt only with affine programs, we can also add linearization and non-determinism to extend the framework. Finally, an interesting feature of greatest fixpoint overapproximation, compared with least fixpoint overapproximation, is that the abstract domain can be refined during the computation. To refine the precision of the analysis, we can add new template constraints at any time, using for example decreasing iterations on the domain of polyhedra.
Acknowledgments. I wish to thank David Monniaux, as well a the anonymous referees, for their comments and suggestions.

References
Adj´e, A., S. Gaubert and E. Goubault, Coupling policy iteration with semi-definite relaxation to compute accurate numerical invariants in static analysis, in: A. D. Gordon, editor, ESOP, Lecture Notes in Computer Science 6012 (2010), pp. 23–42.
Bozga, M., R. Iosif and F. Konecny´, Deciding conditional termination, in: Tools and Algorithms for the Construction and Analysis of Systems - 18th International Conference, TACAS 2012, Held as Part of the European Joint Conferences on Theory and Practice of Software, ETAPS, Lecture Notes in Computer Science 7214 (2012), pp. 252–266.
Costan, A., S. Gaubert, E. Goubault, M. Martel and S. Putot, A policy iteration algorithm for computing fixed points in static analysis of programs, in: K. Etessami and S. K. Rajamani, editors, CAV, Lecture Notes in Computer Science 3576 (2005), pp. 462–475.
Cousot, P., Constructive design of a hierarchy of semantics of a transition system by abstract interpretation, Theoretical Computer Science 277 (2002), pp. 47–103.
Cousot, P. and R. Cousot, Abstract interpretation: a unified lattice model for static analysis of programs by construction or approximation of fixpoints, in: Conference Record of the Fourth Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (1977), pp. 238–252.
Cousot, P. and R. Cousot, Abstract interpretation frameworks, Journal of Logic and Computation 2
(1992), pp. 511–547.
Cousot, P. and R. Cousot, An abstract interpretation framework for termination, in: Conference Record of the 39th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages
(2012), pp. 245–258.
De Nicola, R., editor, “Programming Languages and Systems, 16th European Symposium on Programming, ESOP 2007, Held as Part of the Joint European Conferences on Theory and Practice of Software, ETAPS 2007, Braga, Portugal, March 24 - April 1, 2007, Proceedings,” Lecture Notes in Computer Science 4421, Springer, 2007.

Gawlitza, T. and H. Seidl, Precise fixpoint computation through strategy iteration, in: De Nicola [8],
pp. 300–315.
Gawlitza, T. and H. Seidl, Precise relational invariants through strategy iteration, in: J. Duparc and
T. A. Henzinger, editors, CSL, Lecture Notes in Computer Science 4646 (2007), pp. 23–40.
Gawlitza, T. and H. Seidl, Computing relaxed abstract semantics w.r.t. quadratic zones precisely, in:
R. Cousot and M. Martel, editors, SAS, Lecture Notes in Computer Science 6337 (2010), pp. 271–286.
Gonnord, L. and N. Halbwachs, Combining widening and acceleration in linear relation analysis, in:
13th International Static Analysis Symposium, SAS’06, Seoul, Korea, 2006.
Min´e, A., The octagon abstract domain, Higher-Order and Symbolic Computation 19 (2006), pp. 31– 100, http://www.di.ens.fr/~mine/publi/article-mine-HOSC06.pdf.
Sankaranarayanan, S., H. B. Sipma and Z. Manna, Scalable analysis of linear systems using mathematical programming, in: R. Cousot, editor, VMCAI, Lecture Notes in Computer Science 3385 (2005), pp. 25–41.
