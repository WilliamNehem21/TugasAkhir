Electronic Notes in Theoretical Computer Science 199 (2008) 67–87	
www.elsevier.com/locate/entcs

Specifying Properties of Concurrent Computations in CLF 

Kevin Watkinsa,1 Iliano Cervesatob,2 Frank Pfenninga,3 David Walkerc,4
a Department of Computer Science, Carnegie Mellon University, Pittsburgh, PA
b Carnegie Mellon University – Qatar Campus, Doha, Qatar
c Department of Computer Science, Princeton University, Princeton, NJ

Abstract
CLF (the Concurrent Logical Framework) is a language for specifying and reasoning about concurrent systems. Its most significant feature is the first-class representation of concurrent executions as monadic expressions. We illustrate the representation techniques available within CLF by applying them to an asynchronous pi-calculus with correspondence assertions, including its dynamic semantics, safety criterion, and a type system with latent effects due to Gordon and Jeffrey.
Keywords: logical frameworks, type theory, linear logic, concurrency


Introduction
This paper cannot describe the clf framework in detail; a complete description is available in other work [19,18,3], and the syntax and typing rules of the framework are summarized in Appendix B. Nevertheless, in this introduction, we briefly discuss the lineage of frameworks on which clf is based, and the basic design of clf.
A logical framework is a meta-language for the specification and implementation of deductive systems, which are used pervasively in logic and the theory of program- ming languages. A logical framework should be as simple and uniform as possible, yet provide intrinsic means for representing common concepts and operations in its

٨ This research was sponsored in part by the NSF under grants CCR-9988281, CCR-0208601, CCR-0238328, and CCR-0306313, and by NRL under grant N00173-00-C-2086.
1 Email: kw@cs.cmu.edu
2 Email: iliano@cmu.edu
3 Email: fp@cs.cmu.edu
4 Email: dpw@cs.princeton.edu

1571-0661 © 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2007.11.013

application domain. A logical framework is characterized by an underlying meta- logic or type theory and a representation methodology.
The principal starting point for our work is the lf logical framework [7], which is based on a minimal type theory λΠ with only the dependent function type construc- tor Π. lf directly supports concise expression of variable renaming and capture-
avoiding substitution at the level of syntax, and parametric and hypothetical judg- ments in deductions, following the judgments-as-types principle. Proofs are reified as objects, which allows properties of and relations between proofs to be expressed within the framework.
Representations of systems involving state remained cumbersome until the de- sign of the linear logical framework llf [2] and its close relative rlf [10]. llf is a conservative extension of lf with the linear function type A—◦B, the additive prod- uct type A & B, and the additive unit type ⟨T⟩. The main additional representation of llf is that of state-as-linear-hypotheses. Imperative computations consequently become linear objects in the framework. They can serve as index objects, which means we can express properties of stateful systems at a high level of abstraction.
While llf solves many problems associated with stateful computation, the en- coding of concurrent computations remained unsatisfactory for several reasons. One of the problems is that llf formulations of concurrent systems inherently sequen- tialize the computation steps.
In this paper we are concerned with clf, a conservative extension of llf with intrinsic support for concurrency. Concurrent computations are encapsulated in a monad [15], which permits a simple definitional equality and guarantees conserva- tivity over lf and llf. The definitional equality on monadic expressions identifies different interleavings of independent steps, thereby expressing true concurrency. Dependent types then allow us to specify properties of concurrent computations, as long as they do not rely on the order of independent steps.
We illustrate the framework’s expressive power and representation techniques through a sample encoding of the asynchronous π-calculus with correspondence assertions, following Gordon and Jeffrey [6]. Further examples, such as encodings of Petri-nets, Concurrent ML, and the security protocol specification framework msr can be found in another technical report [3].
The remainder of the paper is organized as follows: Section 2 introduces the π-calculus with which we are concerned and its syntax; Section 3 describes the original static semantics of Gordon et al. and its clf representation; Section 4 describes the operational semantics of the language and its clf representation; Section 5 introduces the syntax of traces and describes the abstraction judgment relating computations and traces, and briefly discusses the safety criterion; Section 6 briefly describes related work; and Section 7 concludes. Appendices summarize the π-calculus encoding and the syntax and judgments of the framework.

pr : type. nm : type. tp : type. label : type.
stop : pr.	 stop’ = stop
par : pr → pr → pr.	 P | Q’ = par P ’ Q’
repeat : pr → pr.	 repeat P ’ = repeat P ’
new : tp → (nm → pr) → pr.   new(x : τ ); P ’ = new τ ’ (λx. P ’)
choose : pr → pr → pr.	 choose P Q’ = choose P ’ Q’
out : nm → nm → pr.	 out x⟨y⟩’ = out x y 
inp : nm → tp →	 inp x(y : τ ); P ’ = inp x τ ’ (λy. P ’) (nm → pr) → pr.
begin : label → pr → pr.	 begin L; P ’ = begin L’ P ’
end : label → pr → pr.	 end L; P ’ = end L’ P ’
Fig. 1. Process syntax represented in clf
The asynchronous π-calculus with correspondence as- sertions
Our asynchronous π-calculus with correspondence assertions follows Gordon and Jeffrey’s presentation [6]. Correspondence assertions, originally developed by Woo and Lam [20], come in two varieties, begin L and end L, where L is a label that carries information about the state of a communication protocol. Gordon and Jef- frey have shown that a variety of important correctness properties of cryptographic protocols can be stated in terms of matching pairs of these begin and end assertions.
To illustrate the basic ideas, we will examine a simple handshake protocol taken directly from Gordon and Jeffrey’s work. This protocol is intended to ensure that if a sender named a receives an acknowledgment message then the receiver named b has actually received the message. In the asynchronous π-calculus with correspondence assertions, we specify the protocol as follows.
Send(a, b, c) = new(msg ); new(ack );
(out c⟨msg, ack⟩
| inp ack (); end (a, b, msg )) Rcv(a, b, c) = inp c(x, y); begin (a, b, x); out y⟨⟩
The standard π-calculus process constructors used here are parallel composition (P | Q), generation of a new name x to be used in a process P (new(x); P where x is bound in P ), asynchronous output on channel c (out c⟨msg, ack⟩), and input on channel c (inp c(x1,..., xn); P where variables x1 through xn are bound in P ). In the protocol, the sending process generates a new message and a new acknowledgment channel. The sender uses the asynchronous output command to send the pair of message and acknowledgment channel on c and waits for a response on ack . Once the sender receives the acknowledgment, it executes an end assertion which specifies that the sender (named a) requires that the receiver (named b) has already received

the input message (msg ). The receiver cooperates with the sender by waiting for pairs of message and acknowledgment on channel c. After receiving on c, the begin assertion declares that the receiver b has received the input message. After this declaration, the receiver sends an acknowledgment to the sender. We hope that in all executions of senders in parallel with receivers, begin assertions match up with end assertions. If they do, sender a can be sure that receiver b received the message msg .
Now, consider combining a single sender in parallel with a single receiver: new(c); (Send(a, b, c) | Rcv(a, b, c)). This configuration is safe since in every possible execution, every end (a, b, msg ) assertion is preceded in that execution by a distinct corresponding begin (a, b, msg ) assertion. On the other hand, placing multiple dif- ferent senders in parallel with a single copy of a receiver is unsafe:

Send(a, b, c) | Send(a', b, c) | Rcv(a, b, c)
This configuration is unsafe because there exists an execution in which an end L assertion is executed but there has been no prior matching begin L. More specif- ically, the second sender a' may create a message and send it to the receiver. The receiver, thinking it is communicating with a, receives the message, executes begin (a, b, msg ), and returns the acknowledgment. Finally, the second sender ex- ecutes end (a', b, msg ). In this protocol, since the identity of the sender (either a or a') was not included in the message, there has been confusion over who the receiver was communicating with. This is a very simple example, but Gordon and Jeffrey have demonstrated that these assertions can be used to identify serious flaws in much more complicated and important protocols.

Syntax
The syntax of the π-calculus processes P with correspondence assertions is pre- sented below. We have simplified Gordon and Jeffrey’s calculus in a couple of ways, replacing polyadic input and output processes with monadic versions, dropping any data structures other than channels x, y, z and replacing deterministic if statements with non-deterministic choice (choose P Q). Two process forms that did not show up in the informal example above are the process stop, which does nothing, and the replicated process repeat P , which acts as an unbounded number of copies of itself. The static semantics makes use of types τ , which are discussed in the next section; these do not affect the operational semantics of a program.
P, Q ::= stop | (P | Q) | repeat P | new(x : τ ); P
| choose P Q | out x⟨y⟩| inp x(y : τ ); P
| begin L; P | end L; P
The representation of process syntax follows standard lf methodology. The signature, shown in Figure 1, represents process syntax via clf types pr (processes), nm (names), tp (types), and label (assertion labels). The representation function mapping processes to clf objects is shown at the right.

name : tp.	 Name’ = name
chan : tp → (nm → eff) → tp.	 Ch(x : τ )e’ = chan τ ’ (λx. e’)
Fig. 2. Type syntax represented in clf



has : nm → tp → type. good : pr → type.
consume : eff → type. assume : eff → pr → type.
gd stop : good stop ◦— T.
gd par : good (par P Q) ◦— good P ◦— good Q.
gd repeat : good (repeat P ) ◦— T ← good P.
gd new : good (new τ (λx. P x)) ← wftp τ
◦—(Πx : nm. has x τ → good (P x)).
gd choose : good (choose P Q) ◦— (good P & good Q).
gd out : good (out X Y ) ← has X (chan τ (λy. E y)) ← has Y τ
◦—consume (E Y ).
gd inp : good (inp X τ (λy. P y)) ← has X (chan τ (λy. E y))
← (Πy : nm. has y τ → assume (E y) (P y)).
gd begin : good (begin L P ) ◦— (effect L —◦ good P ).
gd end : good (end L P ) ◦— effect L ◦— good P.
con eps : consume {1} ◦— T.
con join : consume {let {1} = latent L in let {1} = E in 1}
◦—effect L ◦— consume E.
ass eps : assume {1} P ◦— good P.
ass join : assume {let {1} = latent L in let {1} = E in 1}
◦—(effect L —◦ assume E P ).
Fig. 3. Static semantics represented in clf



A few comments: The type nm of names does not contain any closed terms; it classifies bound variables within a process expression. The type tp is discussed in Section 3. Channels are a special case of names. We do not specify any particular syntax for assertion labels, but it is assumed that they might mention names bound by new or inp. As is common in lf representations, we use higher-order abstract syn- tax, which allows us to model π-calculus bound variables using framework variables and to implement π-calculus substitution using the framework’s substitution.
The most important property of this representation is adequacy : every process in the original language has its own representative as a clf object of type pr, and every object in pr is such a representation. The canonical forms property for clf renders proofs of such results almost trivial.

The static semantics
Gordon and Jeffrey present a static semantics with types and effects for their lan- guage. The goal of the static semantics is to ensure that the correspondence property for assertions is not violated: for each end L assertion reached in an execution, a distinct begin L assertion for L must have been reached in the past. The static semantics associates an effect e (a multiset of labels) with each program point, such that it is safe to execute end L for each label L in the multiset. (Of course, not all safe programs will necessarily have a valid typing.)
Since clf includes llf as a sublanguage, we will be able to represent the static “state” of the effect system as a multiset of linear hypotheses in llf style [2]. The basic idea is to record a multiset of begins already reached at the current program point as linear hypotheses of the typing judgment. 5 Then each occurrence of begin L contributes a linear hypothesis of type effect L for the checking of its continuation, and each end L consumes such a hypothesis.
This accounts for trivial instances of correct programs in which an end is found directly within the continuation of its matching begin. Of course, in actual use, one is more interested in cases in which the end and its matching begin occur in different processes executing concurrently (as in the example of Section 2).
Gordon et al. introduce latent effects to treat many such cases. The idea is that each value transmitted across a channel may carry with it a multiset of latent effects, the effects being debited from the process sending the value and credited to the process receiving it. Since communication synchronizes the sending and receiving processes, it is certain that the begins introducing the debited effects in the sending process will occur before any ends making use of the credited effects in the receiving process. 6
These considerations lead to a simple type syntax. Each name in the static semantics has a type τ : either Name (really nonsense; i.e., just a nonce) or Ch(x : τ )e, representing a channel transmitting names of type τ and a latent effect e. These types (“π-types,” for short) are represented by clf type tp, the constructors of which are shown in Figure 2. Latent effects e are themselves multisets of labels, and are represented in clf by a type eff discussed below.
Although a latent effect is again a multiset of labels, the llf strategy of repre- senting multisets by linear hypotheses does not apply, because latent effects must be first-class values. An lf strategy using explicit list constructors (cons and nil) would represent the latent effects as first-class values, but the lf equality on such lists would be too restrictive: [L1, L2] and [L2, L1] are equal as multisets, but cons L1 (cons L2 nil) and cons L2 (cons L1 nil) are not necessarily equal as lf objects.
In clf, we have a new alternative: expressions are first-class objects, and clf’s

5 Really these are affine hypotheses, since the invariant is that the multiset be merely a lower bound: it is perfectly safe to “forget” that a begin was reached at some point in the past. Careful use of the additives T and & will allow us to simulate affine hypotheses with linear ones.
6 Of course, this implicitly relies on the unicast nature of communication in the language. If multicast or broadcast were allowed, more than one process could be credited, violating the non-duplicable nature of effect hypotheses.

concurrent equality on them can model multiset equality precisely. Briefly, the concurrent equality operates on monadic expressions which have the syntax
E::= let {p} = R in E | M

where R is term of monadic type {S} representing a single atomic step of a compu- tation, p is a pattern binding the results from the step R whose shape is determined by the type {S}, and M is a canonical term of some type S' signaling the end of the computation. If we have two successive steps as in
let {p1} = R1 in let {p2} = R2 in E2
where no variable bound in p1 appears in R2 (and no variable in p2 appears in R1, which can always achieved by renaming) then the two steps are causally independent and the definitional equality of the framework will identify the expression above with
let {p2} = R2 in let {p1} = R1 in E2.
The fact that they are deﬁnitionally equal means that there is no encoding and no property of an expression which could depend on the order of these two steps, just as property in LF can depend on the name of a bound variable. We refer to the congruence generated by such equations as concurrent equality because under this equality monadic expressions become graphs were edges represent causal dependencies visible from variable occurrences. 7
Here we exploit concurrent equality to represent multisets. Each label multiset [L1,..., Ln] will be represented by an expression
{let {1} = latent L1 in ... let {1} = latent Ln in 1}.

The equality on the representation then naturally models equality of multisets. We take eff to be a notational abbreviation for the type {1} of such expressions, and add the following declaration to the signature.
latent : label → {1}.

In addition, we must axiomatize the objects of type {1} that correspond to such multisets; this is the judgment wfeff presented in Appendix A.
Next we represent the π-calculus typing judgment itself as a clf type family good, defined in Figure 3. We use A ◦— B and A ← B, which associate to the left, as alternate forms of B —◦ A and B → A, giving the signature the shape of a logic program. The type A in Πu : A. B has been omitted where it is determined by context. We often omit outermost Π quantifiers; in such cases the corresponding arguments to the constant in question are also omitted (implicit). We have also

7 In reality, the situation is more complex due to the presence of T which can “hide” variables occurrences; see [18] for further elaboration.

η-contracted some subterms in order to conserve space; these should be read as abbreviations for their η-long (canonical) forms.
Since not every declared effect must actually occur (that is, there is implicitly a weakening principle for effects), we must use the additive unit T to consume any leftover effects at the leaves of a derivation (instances of the gd stop or con eps
rules).
We consider some sample rules from the static semantics.

gd par : good (par P Q) ◦— good P ◦— good Q.

This rule checks that in a process P | Q, both P and Q are well-typed. The subgoals are handled multiplicatively, which means that the linear assumptions representing the begins which have not yet been consumed by an end must be split between the two process expressions.
We contrast this with

gd choose : good (choose P Q) ◦— (good P & good Q).

where the additive nature of & distributes the linear assumptions to both P and
Q. This is the correct rule for non-determinstic choice, since exactly one of P and
Q will execute, so whichever one is chosen must be passed all the resources.
A somewhat subtle observation regarding the affine nature of resources is nec- essary to understand the gd repeat rule.

gd repeat : good (repeat P ) ◦— T ← good P.

The second subgoal, good P , may not use any linear resources at all, because it may be executed an unbounded number of times. This is encoded by writing
← good P where ← is the unrestricted implication, which is equivalent in linear logic to ◦—!good P . However, Gordon and Jeffries judgment is affine, so we must
be able to consume the linear resources somewhere, which is accomplished by the first subgoal T.
The type family wftp, not shown in the figure (see Appendix A), represents the judgment that a π-type is well formed, reducing more or less to the judgment wfeff for any latent effects mentioned in the π-type. The type family has contains no closed objects, but in the course of a derivation of good P , hypotheses has x τ will be introduced for each name bound by new or inp in P . Similarly, the family effect has no closed objects, but in the course of a typing derivation, linear hypotheses effect L can be introduced by begin and consumed by end.
The task of assume and consume is to introduce and consume linear hypotheses for the whole multiset of effects contained in a latent effect. Latent effects are consumed by out, which has no continuation, and produced by inp, which does. Accordingly, assume takes the continuation as an argument, and invokes good to check it once the multiset of effects has been introduced into the linear context.

It can be shown by extensions of the standard techniques developed for the llf fragment of clf that this representation is adequate: a process P is well-typed in the original system just when there is an object of type good P in clf.

The operational semantics
Thus far we have seen the connectives clf inherits from earlier frameworks. It is time now to introduce the syntax for concurrent computations that is the raison d’ˆetre of the framework. The principal challenge lies in the need to retain conser- vativity over llf: because the structure of a computation will not necessarily be determined by its type, there is the danger that the strong canonical forms property that llf enjoys could be lost. 8
Fortunately, the term language of judgmental lax logic [16] provides a ready- made solution. In addition to the normal judgment N ⇐ A, which may be thought of as expressing the truth of A, it has a second judgment E ← S, where E is a new syntactic class of expressions, and S is a new class of synchronous types representing the output of a computation. In computational terms, the new judg- ment distinguishes effectful computations from the effect-free values of the original judgment N ⇐ A. (Here we think of the inherent non-determinism of concurrent computations as an effect.)
The separation into two judgment makes for a very clean proof theory, for ex- ample, without commuting conversions except for the concurrent equality. In a logical framework where we would like to establish bijections between proof terms and computations, this is a crucial simplification.
Since “possibly effectful” is weaker than “effect-free,” there is an inclusion of the normal objects N into the expressions E and of the asynchronous types A into the
synchronous types S. Although there is no reverse inclusion, the notion of “possibly effectful” is internalized by a new monadic type constructor {·}, so called because it satisfies the axioms of a monad.
Next, what synchronous types S should be available? In other words, what kind of results can a computation have? We treat three related phenomena: fresh name generation, the creation of new unrestricted hypotheses, and the creation of multiple related linear hypotheses. Each of these corresponds to a synchronous connective of intuitionistic linear logic, in Andreoli’s terminology [1].
Concerning fresh name generation, we model a computation generating a name x of type A by an existential type: ∃u : A. B. However, we must be careful: the elimination rule for ∃ would destroy the strong canonical forms property enjoyed by llf. Fortunately, for our purposes we only need an elimination rule in the lax (monadic) judgment, since ∃ is only to be used in computations. The other possible results of a computation are modeled by the multiplicative conjunction ⊗ and unit 1, and the unrestricted modality !. The final syntax resulting from these

8 See our technical report [18] for more discussion of this subtle point. Also, though it is not treated here, the planned logic programming interpretation of clf relies on the uniform proofs property, which is connected to the strong canonical forms property.

considerations can be found in Appendix B.
Gordon and Jeffrey’s operational semantics [6] is based on a traced transition
system P —→s  P', where s is a trace: a sequence of begin and end actions, internal
actions τ , and gen actions binding freshly generated names (corresponding to the execution of new).  Although we have not specified the language of labels, it is
assumed that they may mention such names. Then P —→s  P' when P can evolve
to P' while performing the actions in trace s. The traced transition system itself depends on the usual notion of structural congruence P ≡ P' found in the π-calculus literature.
The clf representation has a somewhat different structure. Since clf has a
first-class notation for concurrent computations, we can factor the traced transition system into two judgments: first, that a process P has a concurrent execution E (which is represented by a clf expression); and second, that an execution E has a (serialized) trace s. This section is concerned with the first judgment, while the
next section treats traces.
Computations in this semantics are represented by clf expressions

x1 : nm,..., xm : nm, r1 : run P1,..., ri : run Pi; ri+1∧:run Pi+1,..., rn∧:run Pn ▶ E ←T 

in a context having unrestricted hypotheses of type nm for each generated name, unrestricted hypotheses r1 ... ri of type run P for each process P that is executing and available unrestrictedly, and linear hypotheses ri+1 ... rn of type run P for each process P that is available linearly, where run : pr → type. 9 The final result of the computation is taken as the additive unit T, which means that computation can stop at any time, with any leftover resources (linear hypotheses) consumed by ⟨⟩, its introduction form.
Then each of the structural process constructors stop, par, repeat, and new can be represented by a corresponding synchronous clf connective:

ev stop : run stop —◦ {1}.
ev par : run (par P Q) —◦ {run P ⊗ run Q}.
ev repeat : run (repeat P ) —◦ {!run P}.
ev new : run (new τ (λu. P u)) —◦ {∃u : nm. run (P u)}.

The remaining constructors are interpreted according to their semantics:

ev choosei : run (choose P1 P2) —◦ {run Pi}.
ev sync : run (out X Y ) —◦ run (inp X τ (λy. P y))
—◦{run (P Y )}.
ev begin : ΠL : label. run (begin L P ) —◦ {run P}.
ev end : ΠL : label. run (end L P ) —◦ {run P}.

9 Here ← denotes the lax typing judgment, not reverse implication.

We depart from the usual practice of leaving outermost Π quantifiers implicit for reasons that will become clear in Section 5.
One interesting feature of the clf encoding is that many of the structural equiva-
lences of the original presentation of the π-calculus appear automatically (shallowly) as consequences of the principles of exchange, weakening (since T is present) and so forth satisfied by clf hypotheses. In the clf setting the rest of the structural equivalences are captured within a general notion of simulation, discussed briefly in
Section 5.
In this representation, each concurrent computation starting from a process P

corresponds to a clf object of type run P —◦ {T}; that is, a term ∧
where E is

a monadic expression of type T in a context containing a single linear hypothesis r
representing the process P . 10 Because clf’s notion of equality identifies monadic expressions differing only in the order of execution of independent computation steps, each such object (modulo equality) represents the dependence graph of a possible computation. Thus judgments (represented by clf types) concerning such objects, such as the abstraction judgment to be introduced in the next section, are predicates on depedence graphs, not on serialized computations.

There is no simple adequacy result at this stage, since the judgment P
—→s  P'

of Gordon et al. refers to the trace s, which is not directly available in the clf
operational semantics. (Moreover, the process P' to which P evolves is only available in clf implicitly as the set of leftover hypotheses consumed by the T introduction at the end of the clf expression representing a computation.) Once traces and the abstraction judgment relating a computation to its traces are introduced, it will be possible to state a precise adequacy result.


Traces and abstraction
The syntax of the traces s mentioned in the judgment P —→s


P' of Gordon et al. can

be represented straightforwardly by lf techniques. Though we have left the label
syntax unspecified, it is assumed that labels might depend on names introduced in the course of the computation, so the actions gen representing the generation of fresh names in the execution of a new process must bind a variable in the style of
higher-order abstract syntax.
The representation of traces is as follows:













∧
10 We use
tr : type.
tnil : tr.	 ε’ = tnil
tint : tr → tr.	 τ, s’ = tint s’
tbegin : label → tr → tr.	 begin L, s’ = tbegin L’ s’ tend : label → tr → tr.		 end L, s’ = tend L’ s’ tgen : (nm → tr) → tr.	 gen ⟨x⟩, s’ = tgen (λx. s’)

∧

λx. in general to denote an abstraction over a linear variable x, and R
of a linear function R to an argument.
M to denote an application

abst : {T} → tr → type. abst nil : abst E tnil.
abst stop : abst {let {1} = ev stop∧R in let { } = E in ⟨⟩} s ← abst E s.
abst par : abst {let {r1 ⊗ r2} = ev par∧R in let { } = E∧r1∧r2 in ⟨⟩} s
← (Πr1. Πr2. abst (E∧r1∧r2) s).
abst repeat : abst {let {!r} = ev repeat∧R in let { } = E r in ⟨⟩} s
← (Πr. abst (E r) s).
abst new : abst {let {[x, r]} = ev new∧R in let { } = E x∧r in ⟨⟩}
(tgen (λx. s x))
← (Πx. Πr. abst (E x∧r) (s x)).
abst choosei : abst {let {r} = ev choosei∧R in let { } = E∧r in ⟨⟩} (tint s)
← (Πr. abst (E r) s).
abst sync : abst {let {r} = ev sync∧R1∧R2 in let { } = E∧r in ⟨⟩} (tint s)
← (Πr. abst (E∧r) s).
abst begin : abst {let {r} = ev begin L∧R in let { } = E∧r in ⟨⟩} (tbegin L s)
← (Πr. abst (E∧r) s).
abst end : abst {let {r} = ev end L∧R in let { } = E∧r in ⟨⟩} (tend L s)
← (Πr. abst (E∧r) s).
Fig. 4. The abstraction judgment as a clf program
Now we are equipped with enough tools to write the abstraction judgment re- lating a computation to its traces, as a clf type family abst : {T} → tr → type, the logic program for which is shown in Figure 4. The first argument of this rela- tion is the clf object representing the dependence graph of the computation, while the second argument is an associated trace. The mode (in the sense of logic pro- gramming) is input for the first argument and output for the second. However, the relation is not a function, because from a single execution (as dependence graph) many possible (serial) abstractions as a trace might be extracted. Nevertheless, each execution has at least one abstraction as a trace.
The trace has type {T} because traces always end in the additive unit ⟨⟩. If we look at the first arguments of abst we see that they have the form {let {... } = ev x∧R in ... }. This is the form of a computation whose first step is ev x. The actions performed by these computation steps is explained in the preceding section where these constants are declared with their types. For example, in
abst par : abst {let {r1 ⊗ r2} = ev par∧R in let { } = E∧r1∧r2 in ⟨⟩} s
← (Πr1. Πr2. abst (E∧r1∧r2) s).
a process R ∧: run (par P Q) is decomposed into r1 ∧: run P and r2 ∧: run Q, which is exactly what the type of
ev par : run (par P Q) —◦ {run P ⊗ run Q}.
tells us. E (which may depend linearly on r1 and r2) represents the remaining computation after this decomposition. The abstracted trace s obtained from the

computation E is the same as is returned for the overall computation, because from a π-calculus perspective the decomposition corresponds merely to a structural equivalence.
It is also noteworthy that the context in which the abst judgment executes uses unrestricted hypotheses r : run P for each executing process P , whether or not the corresponding process was represented by a linear hypothesis in the original execution. This is a common phenomenon when writing higher-level judgments in llf style.
This judgment, taken together with clf’s equality admitting concurrency equa- tions, defines for each concurrent computation the set of possible serializations of that computation as a trace. The traces need not describe the whole computation; the rule abst nil allows abstraction to stop after computing the trace of any prefix of the computation. This suffices because we are interested only in safety properties, which are violated whenever they are violated on a prefix of the computation.
We would like to show that each traced transition P —→s  P' of Gordon and
Jeffrey’s system corresponds to an object ∧	: run P —◦ {T} as in Section 4
together with an abstraction abst E s yielding the same trace.  As it turns out,
this is not quite the case, because the structural equivalences considered in that paper induce certain rearrangements of tgen with respect to other actions that are not possible in the clf variant. However, defining an appropriate notion of “similarity” on traces admitting rearrangement of tgen steps (which, moreover, can be characterized by another clf judgment), we find that each traced transition is in correspondence with a clf expression and abstraction yielding a “similar” trace.
The proof technique is illustrative but is not presented here in detail. In brief, one considers the notion of simulation P1 ≤ P2 induced by the clf operational semantics of Section 4, abstraction, and “similarity” of traces: whenever P1 and some context consisting of other processes and names yields a given trace, P2 yields a similar trace in the same context. Then all the structural equivalences of the traced transition system are simulations in this sense, and it follows easily that each traced transition has its clf counterpart. The converse is simple, because each rule of the clf operational semantics is immediately available as a step of the traced transition system (or a structural equivalence). So we have:
Proposition 1 (Adequacy of operational semantics) The traced transition
system proves P —→s  P' for some P' just when there exist E : run P ’ —◦ {T}
and A : (Πr. abst (E∧r) s') (in a context binding the free names of P and P'), and
s is similar to s'.
Finally, we can define the safety criterion for processes. In a constructive setting, it is easiest to characterize violations of safety because it is witnessed by finitary evidence. A process is unsafe precisely when it has an execution admitting some abstraction as a trace that violates the correspondence property (see Section 2). It turns out to be easy to write a clf judgment characterizing those traces that violate the correspondence property (see Appendix A). Thus, each step of the criterion is modeled by a clf judgment, and we can write an overall judgment unsafe P , which,

as a clf type, contains all the proofs that P is unsafe. This turns out to be the same, mutatis mutandis, as Gordon and Jeffrey’s definition.




Related work
Right from its inception, linear logic [5] has been advocated as a logic with an in- trinsic notion of state and concurrency. In the literature, many connections between concurrent calculi and linear logic have been observed. Due to space constraints we cannot survey this relatively large literature here. In a logical framework, we remove ourselves by one degree from the actual semantics; we represent rather than embed calculi. Thereby, clf provides another point of view on many of the prior investigations.
Most closely related to our work is Miller’s logical framework Forum [13], which is based on a sequent calculus for classical linear logic and focusing proofs [1]. As shown by Miller and elaborated by Chirimar [4], Forum can also represent concur- rency. Our work extends Forum in several directions. Most importantly, it is a type theory based on natural deduction and therefore offers an internal notion of proof object that is not available in Forum. Among other things, this means we can explicitly represent relations on deductions and therefore on concurrent computa- tions. In Forum these could only be represented “externally”, as λ-terms without typing capturing their validity. Moreover, these terms lack concurrent equality and therefore do not have a notion of causal dependence.
There have been several formalizations of versions of the π-calculus in a variety of reasoning systems, such as hol [11], Coq [8,9], Isabelle/HOL [17] or Linc [14]. A
distinguishing feature of our sample encoding in this paper is the simultaneous use of higher-order abstract syntax, linearity, modality, and the intrinsic notion of concur- rent computations. Also, we are not aware of a formal treatment of correspondence assertions or dependent effect typing for the π-calculus.
Systems based on rewriting logic, such as Maude [12], natively support concur- rent specifications (and have been used to model Petri nets, ccs, the π-calculus, etc). However, lacking operators comparable to clf’s dependent types and proof- terms, Maude users must code concurrent computations independently from the concurrent systems that originate them.
As already mentioned above, clf is a conservative extension of llf with the asynchronous connectives ⊗, 1, !, and ∃, encapsulated in a monad. The idea of monadic encapsulation goes back to Moggi’s monadic meta-language [15] and is used heavily in functional programming. Our formulation follows the judgmental presentation of Pfenning and Davies [16] that completely avoids the need for com- muting conversions, but treats neither linearity nor the existence of normal forms. This permits us to reintroduce some equations to model true concurrency in a com- pletely orthogonal fashion.

Conclusions
The goal of this work has been to extend the elegant and logically motivated rep- resentation strategies for syntax, judgments, and state available in lf and llf to the concurrent world. We have shown how the availability of a notation for con- current executions, admitting a proper truly concurrent equality, enables powerful strategies for specifying properties of such executions.
Ultimately, it should become as simple and natural to manipulate the objects representing concurrent executions as it is to manipulate lf objects. If higher-order abstract syntax means never having to code up α-conversion or capture-avoiding substitution ever again, we hope that in the same way, the techniques explored here can make it unnecessary to code up multiset equality or concurrent equality ever again, so that intellectual effort can be focused on reasoning about deeper properties of concurrent systems.

References
Andreoli, J.-M., Logic programming with focusing proofs in linear logic, Journal of Logic and Computation 2 (1992), pp. 197–347.
Cervesato, I. and F. Pfenning, A linear logical framework, Information & Computation 179 (2002),
pp. 19–75.
Cervesato, I., F. Pfenning, D. Walker and K. Watkins, A concurrent logical framework II: Examples and applications, Technical Report CMU-CS-02-102, Department of Computer Science, Carnegie Mellon University (2002), revised May 2003.
Chirimar, J. L., “Proof Theoretic Approach to Specification Languages,” Ph.D. thesis, University of Pennsylvania (1995).
Girard, J.-Y., Linear logic, Theoretical Computer Science 50 (1987), pp. 1–102.
Gordon, A. D. and A. Jeffrey, Typing correspondence assertions for communication protocols, Theoretical Computer Science 300 (2003), pp. 379–409.
Harper, R., F. Honsell and G. Plotkin, A framework for defining logics, Journal of the Association for Computing Machinery 40 (1993), pp. 143–184.
Hirschkoff, D., A full formalisation of pi-calculus theory in the Calculus of Constructions, in: E. Gunter and A. Felty, editors, Proceedings of the 10th International Conference on Theorem Proving in Higher- Order Logics (TPHOLs’97) (1997), pp. 153–169.
Honsell, F., M. Miculan and I. Scagnetto, Pi-calculus in (co)inductive type theories, Theoretical Computer Science 253 (2001), pp. 239–285.
Ishtiaq, S. and D. Pym, A relevant analysis of natural deduction, Journal of Logic and Computation 8
(1998), pp. 809–838.
Melham, T., A mechanized theory of the pi-calculus in HOL, Nordic Journal of Computing 1 (1995),
pp. 50–76.
Meseguer, J., Software specification and verification in rewriting logic, Lecture notes for the Marktoberdorf International Summer School, Germany (2002).
Miller, D., A multiple-conclusion meta-logic, in: S. Abramsky, editor, Ninth Annual Symposium on Logic in Computer Science (1994), pp. 272–281.
Miller, D. and A. Tiu, A proof theory for generic judgments, in: P. Kolaitis, editor, Proceedings of the 18th Annual Symposium on Logic in Computer Science (LICS’03) (2003), pp. 118–127.
Moggi, E., Notions of computation and monads, Information and Computation 93 (1991), pp. 55–92.

Pfenning, F. and R. Davies, A judgmental reconstruction of modal logic, Mathematical Structures in Computer Science 11 (2001), pp. 511–540, notes to an invited talk at the Workshop on Intuitionistic Modal Logics and Applications (IMLA’99), Trento, Italy, July 1999.


R¨ockl, C., D. Hirschkoff and S. Berghofer, Higher-order abstract syntax with induction in Isabelle/HOL: Formalizing the pi-calculus and mechanizing the theory of contexts, in: F. Honsell and M. Miculan, editors, Proceedings of the 4th International Conference on Foundations of Software Science and Computation Structures (FOSSACS’01) (2001), pp. 364–378.


Watkins, K., I. Cervesato, F. Pfenning and D. Walker, A concurrent logical framework I: Judgments and properties, Technical Report CMU-CS-02-101, Department of Computer Science, Carnegie Mellon University (2002), revised May 2003.


Watkins, K., I. Cervesato, F. Pfenning and D. Walker, A concurrent logical framework: The propositional fragment, in: Types for Proofs and Programs, Springer-Verlag LNCS, 2004 Selected papers from the Third International Workshop Torino, Italy, April 2003. To appear.

Woo, T. and S. Lam, A semantic model for authentication protocols, in: Proceedings of the 1993 IEEE Computer Society Symposium on Research in Security and Privacy (1993), pp. 178–194.


π-calculus encoding summarized
Syntax.

eff = {1} : type.
latent : label → eff.	 [L1,..., Ln]’ =
{let {1} = latent L1’ in ... 
let {1} = latent Ln’ in 1}
name : tp.	 Name’ = name
chan : tp → (nm → eff) → tp.	 Ch(x : τ )e’ = chan τ ’ (λx. e’)
stop : pr.	 stop’ = stop
par : pr → pr → pr.	 P | Q’ = par P ’ Q’
repeat : pr → pr.	 repeat P ’ = repeat P ’
new : tp → (nm → pr) → pr.	 new(x : τ ); P ’ = new τ ’ (λx. P ’)
choose : pr → pr → pr.	 choose P Q’ = choose P ’ Q’
out : nm → nm → pr.	 out x⟨y⟩’ = out x y 
inp : nm → tp →	 inp x(y : τ ); P ’ = inp x τ ’ (λy. P ’) (nm → pr) → pr.
begin : label → pr → pr.	 begin L; P ’ = begin L’ P ’
end : label → pr → pr.	 end L; P ’ = end L’ P ’
tnil : tr.	 ε’ = tnil
tint : tr → tr.	 τ, s’ = tint s’
tbegin : label → tr → tr.	 begin L, s’ = tbegin L’ s’
tend : label → tr → tr.	 end L, s’ = tend L’ s’
tgen : (nm → tr) → tr.	 gen ⟨x⟩, s’ = tgen (λx. s’)

Dynamic semantics.
ev stop : run stop —◦ {1}.
ev par : run (par P Q) —◦ {run P ⊗ run Q}.
ev repeat : run (repeat P ) —◦ {!run P}.
ev new : run (new τ (λu. P u)) —◦ {∃u : nm. run (P u)}.
ev choosei : run (choose P1 P2) —◦ {run Pi}.
ev sync : run (out X Y ) —◦ run (inp X τ (λy. P y)) —◦ {run (P Y )}.
ev begin : ΠL : label. run (begin L P ) —◦ {run P}.
ev end : ΠL : label. run (end L P ) —◦ {run P}.
Static semantics.
wflab : label → type. wfeff : eff → type.
wff eps : wfeff {1}.
wff lat : wfeff {let {1} = latent L in let {1} = E in 1}← wflab L ← wfeff E.
wftp : tp → type. wf name : wftp name.
wf chan : wftp (chan τ (λx. E x)) ← wftp τ ← (Πx. has x τ → wfeff (E x)).
consume : eff → type. assume : eff → pr → type.
con eps : consume {1} ◦— T.
con join : consume {let {1} = latent L in let {1} = E in 1}
◦—effect L ◦— consume E.
ass eps : assume {1} P ◦— good P.
ass join : assume {let {1} = latent L in let {1} = E in 1}
◦—(effect L —◦ assume E P ).
has : nm → tp → type. good : pr → type.
gd stop : good stop ◦— T.
gd par : good (par P Q) ◦— good P ◦— good Q.
gd repeat : good (repeat P ) ◦— T ← good P.
gd new : good (new τ (λx. P x)) ← wftp τ
◦—(Πx : nm. has x τ → good (P x)).
gd choose : good (choose P Q) ◦— (good P & good Q).
gd out : good (out X Y ) ← has X (chan τ (λy. E y)) ← has Y τ
◦—consume (E Y ).
gd inp : good (inp X τ (λy. P y)) ← has X (chan τ (λy. E y))
← (Πy : nm. has y τ → assume (E y) (P y)).
gd begin : good (begin L P ) ◦— (effect L —◦ good P ).
gd end : good (end L P ) ◦— effect L ◦— good P.

Abstraction.
abst : {T} → tr → type. abst nil : abst E tnil.
abst stop : abst {let {1} = ev stop∧R in let { } = E in ⟨⟩} s ← abst E s.
abst par : abst {let {r1 ⊗ r2} = ev alt∧R in let { } = E∧r1∧r2 in ⟨⟩} s
← (Πr1. Πr2. abst (E∧r1∧r2) s).
abst repeat : abst {let {!r} = ev repeat∧R in let { } = E r in ⟨⟩} s
← (Πr. abst (E r) s).
abst new : abst {let {[x, r]} = ev new∧R in let { } = E x∧r in ⟨⟩}
(tgen (λx. s x))
← (Πx. Πr. abst (E x∧r) (s x)).
abst choosei : abst {let {r} = ev choosei∧R in let { } = E∧r in ⟨⟩} (tint s)
← (Πr. abst (E r) s).
abst sync : abst {let {r} = ev sync∧R1∧R2 in let { } = E∧r in ⟨⟩} (tint s)
← (Πr. abst (E∧r) s).
abst begin : abst {let {r} = ev begin L∧R in let { } = E∧r in ⟨⟩} (tbegin L s)
← (Πr. abst (E∧r) s).
abst end : abst {let {r} = ev end L∧R in let { } = E∧r in ⟨⟩} (tend L s)
← (Πr. abst (E∧r) s).

Safety.

invalid : tr → type.
remove : label → tr → tr → type.
/= : label → label → type.
inval end : invalid (tend	).
inval int : invalid (tint s) ← invalid s.
inval gen : invalid (tgen (λx. s x)) ← (Πx. invalid (s x)).
inval begin : invalid (tbegin L s) ← remove L s s' ← invalid s'.
rem match : remove L (tend L s) s.
rem nil : remove L tnil tnil.
rem int : remove L (tint s) (tint s') ← remove L s s'.
rem gen : remove L (tgen (λx. s x)) (tgen (λx. s x))
← (Πx. remove L (s x) (s' x)).
rem begin : remove L (tbegin L' s) (tbegin L' s') ← remove L s s'.
rem end : remove L (tend L' s) (tend L' s') ← L /= L' ← remove s s'.
invalid : tr → type. unsafe : pr → type.
show unsafe : ΠE :(run P —◦ {T}). unsafe P ← (Πr. abst (E∧r) s) ← invalid s.

CLF type theory summarized
See the technical report [18] for further details.

Syntax.


K, L ::= type | Πu : A. K
A, B, C ::= A —◦ B | Πu : A. B | A & B
|T| {S}| P P ::= a | P N 
N ::= λx. N | λu. N | ⟨N1, N2⟩
| ⟨⟩| {E}| R
R ::= c | u | x | R∧N | R N | π1R | π2R E ::= let {p} = R in E | M

S ::= ∃u : A. S | S1 ⊗ S2 | 1 | !A | A M ::= [N, M ] | M1 ⊗ M2 | 1 | !N | N

Γ ::= ·| Γ,u : A
Δ ::= ·| Δ, x∧:A
Σ ::= ·| Σ,a : K | Σ,c : A
p ::= [u, p] | p1 ⊗ p2 | 1 | !u | x
Ψ ::= p∧:S, Ψ |· 



Typing.

Judgments.

Γ ▶Σ K ⇐ kind
Γ ▶  A ⇐ type



Γ; Δ ▶Σ N ⇐ A
Γ; Δ ▶Σ R ⇒ A





▶ Σ ok
▶  Γ ok

Σ
Γ ▶Σ
Γ ▶Σ
P ⇒ K S ⇐ type
Γ; Δ ▶Σ Γ; Δ; Ψ ▶Σ Γ; Δ ▶Σ
E ← S E ← S M ⇐ S
Σ
Γ ▶Σ
Γ ▶Σ
Δ ok
Ψ ok





Rules.
inst kA(u. K, N ) = K'
inst aA(u. B, N ) = B'
inst sA(u. S, N ) = S'



▶· ok
▶ Σ ok	· ▶Σ K ⇐ kind
▶ Σ,a : K ok
▶ Σ ok	· ▶Σ A ⇐ type
▶ Σ,c : A ok



▶Σ · ok

Γ ▶Σ · ok

Γ ▶Σ · ok
▶Σ Γ ok	Γ ▶Σ A ⇐ type
▶Σ Γ,u : A ok
Γ ▶Σ Δ ok	Γ ▶Σ A ⇐ type

Γ ▶Σ Δ, x∧:A ok
Γ ▶Σ S ⇐ type	Γ ▶Σ Ψ ok

Γ ▶Σ p∧:S, Ψ ok

Henceforth, it will be assumed that all judgments are considered relative to a

particular fixed signature Σ, and the signature indexing each of the other typing judgments will be suppressed.


Γ ▶ type ⇐ kind typeKF
Γ ▶ A ⇐ type	Γ,u : A ▶ K ⇐ kind


Γ ▶ Πu : A. K ⇐ kind



Γ ▶ A ⇐ type	Γ ▶ B ⇐ type
Γ ▶ A —◦ B ⇐ type	—◦F
Γ ▶ A ⇐ type	Γ,u : A ▶ B ⇐ type
Γ ▶ Πu : A. B ⇐ type

Γ ▶ A ⇐ type	Γ ▶ B ⇐ type
Γ ▶ A & B ⇐ type
Γ ▶ S ⇐ type
Γ ▶T⇐ type TF
Γ ▶ P ⇒ type

Γ ▶ {S}⇐ type {}F	Γ ▶ P ⇐ type ⇒type⇐


Γ ▶ P ⇒ Πu : A. K	Γ; ·▶ N ⇐ A

Γ ▶ a ⇒ Σ(a) a
Γ ▶ P N ⇒ inst kA(u. K, N )	ΠKE


Γ ▶ S1 ⇐ type	Γ ▶ S2 ⇐ type

Γ ▶ S1 ⊗ S2 ⇐ type	⊗F	Γ ▶ 1 ⇐ type 1F

Γ ▶ A ⇐ type	Γ,u : A ▶ S ⇐ type

Γ ▶ ∃u : A. S ⇐ type	∃F
Γ ▶ A ⇐ type


Γ ▶ !A ⇐ type



Γ; Δ, x∧:A ▶ N ⇐ B
Γ,u : A;Δ ▶ N ⇐ B

Γ; Δ
∧
▶ λx. N ⇐ A —◦ B
—◦I		
Γ; Δ ▶ λu. N ⇐ Πu : A. B

Γ; Δ ▶ N1 ⇐ A	Γ; Δ ▶ N2 ⇐ B
Γ; Δ ▶ ⟨N1, N2⟩⇐ A & B	&I

Γ; Δ ▶ ⟨⟩⇐T TI

Γ; Δ ▶ E ← S
Γ; Δ ▶ {E}⇐ {S} {}I
Γ; Δ ▶ R ⇒ P'	P' ≡ P
Γ; Δ ▶ R ⇐ P	⇒⇐


Γ; ·▶ c ⇒ Σ(c) c	Γ; ·▶ u ⇒ Γ(u) u	Γ; x∧:A ▶ x ⇒ A x

Γ; Δ1 ▶ R ⇒ A —◦ B	Γ; Δ2 ▶ N ⇐ A
Γ; Δ ▶ R ⇒ A & B

—◦E
Γ; Δ1, Δ2 ▶ R∧N ⇒ B
Γ; Δ ▶ π1R ⇒ A	&E1

Γ; Δ ▶ R ⇒ Πu : A. B	Γ; ·▶ N ⇐ A ΠE	Γ; Δ ▶ R ⇒ A & B &E
Γ; Δ ▶ R N ⇒ inst aA(u. B, N )	Γ; Δ ▶ π2R ⇒ B	2

Γ; Δ1 ▶ R ⇒ {S0}	Γ; Δ2; p∧:S0 ▶ E ← S
Γ; Δ ▶ M ⇐ S

Γ; Δ1, Δ2 ▶ (let {p} = R in E) ← S	{}E
Γ; Δ ▶ M ← S ⇐←

Γ; Δ; p1∧:S1, p2∧:S2, Ψ ▶ E ← S	Γ; Δ; Ψ ▶ E ← S
⊗L	1L
Γ; Δ; p1 ⊗ p2∧:S1 ⊗ S2, Ψ ▶ E ← S	Γ; Δ; 1∧:1, Ψ ▶ E ← S

Γ,u : A; Δ; p∧:S0, Ψ ▶ E ← S

Γ; Δ; [u, p]∧:∃u : A. S , Ψ ▶ E ← S ∃L
Γ,u : A; Δ;Ψ ▶ E ← S !L
Γ; Δ; !u∧:!A, Ψ ▶ E ← S

Γ; Δ ▶ E ← S  ←←
Γ; Δ; ·▶ E ← S
Γ; Δ, x∧:A;Ψ ▶ E ← S

Γ; Δ; x∧:A, Ψ ▶ E ← S AL


Γ; Δ1 ▶ M1 ⇐ S1	Γ; Δ2 ▶ M2 ⇐ S2

Γ; Δ1, Δ2 ▶ M1 ⊗ M2 ⇐ S1 ⊗ S2	⊗I	Γ; ·▶ 1 ⇐ 1 1I

Γ; ·▶ N ⇐ A	Γ; Δ ▶ M ⇐ inst sA(u. S, N )
Γ; Δ ▶ [N, M ] ⇐ ∃u : A. S	∃I
Γ; ·▶ N ⇐ A


Γ; ·▶ !N ⇐ !A
