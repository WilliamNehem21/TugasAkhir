Electronic Notes in Theoretical Computer Science 133 (2005) 41–60  
www.elsevier.com/locate/entcs


Analysis of Real-Time Systems with CTL Model Checkers
Mustapha Bourahla1
Computer Science Department, University of Biskra, Algeria
Mohamed Benmohamed2
Computer Science Department, University of Constantine, Algeria

Abstract
This paper presents a new method for model checking dense real-time systems. The dense real- time system is modeled by a timed automaton and the property is specified with the temporal logic TCTL. Specification of the TCTL property is reduced to CTL and its temporal constraints are captured in a new timed automaton. This timed automaton will be composed with the original timed automaton specifying the real-time system under analysis. Then, the product timed au- tomaton will be abstracted using partition refinement of state space based on strong bi-simulation. The result is an untimed automaton modulo the TCTL property which represents an equivalent finite state system to be model checked using existing CTL model checking tools.
Keywords: Real-Time Systems, Model Checking, Timed Automaton, Strong Bi-simulation, Partition Refinement.


Introduction
Many formal frameworks that have been proposed to reason about real-time systems are based on timed automata [2]. These automata are equipped with clocks, variables used to measure time, ranging over the non negative real numbers (R+). Consequently, the state space is infinite and cannot be explic- itly represented by enumerating all states. Among the different description

1 Email: mbourahla@hotmail.com
2 Email: ibnm@yahoo.fr



1571-0661 © 2005 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2004.08.057


languages for specifying real-time requirements, we are particularly interested in the temporal logic TCTL [1,10]. Because of the introduction of dense time, which makes quantitative reasoning more complicated, real-time model- checking tools are less successful than CTL model-checking tools. Most pub- lished real-time model checking algorithms are based on backward/forward reachability analysis [4,12] which is implemented in several successful verifi- cation tools. Other algorithms are based on compositional techniques [11] where components of the real-time systems are gradually moved during the verification into the specification. Real-time model checking techniques based on partition refinement [17,19] build a symbolic state space that is as coarse as possible. Starting from some (implicit) initial partition, the partition is iteratively refined until the verification problem can be decided.
In this paper we propose a reduction technique from TCTL model-checking to CTL model-checking without changing the classic CTL model checking algorithm. Thus, the generated model can be translated to a language of one of the existing CTL model checkers to be checked directly. Given a timed automaton A and a TCTL formula ψ, we construct an equivalent CTL formula ϕ and a new timed automaton A+ augmented with behavior and specification clocks which are extracted from the formula ψ. We prove that A satisfies ψ if and only if A+ satisfies ϕ.
The transition system modeling the behavior of the constructed timed au- tomaton A+ comprises two kinds of transitions, namely timeless actions rep- resenting the discrete evolutions of the system, and time lapses corresponding to the passage of time. Due to density of time, there are infinitely many time transitions. A finite model can be obtained by defining an appropriate equiv- alence relation inducing a finite number of equivalence classes. The main idea behind these relations is that they abstract away from the exact amount of time elapsed. An important problem consists in constructing the quotient of a labeled transition system (representing a timed automaton) with respect to an equivalence relation.
In this paper we have defined an equivalence relation based on strong bi- simulation [13], which is used by our algorithm to generate the quotient graph. Each edge in the timed automaton represents a discrete transition which has information concerning the source and target states, the enabling condition and the set of clocks to be reset after making this transition. Initially, the timed automaton represents the states of timed system as blocks (zones) of states (called also, symbolic states). We call this the initial partition of states. We refine any source block of states if there is an outgoing edge with an enabling condition (which is a constraint) formula different from true, using the invariant of the block of states and the enabling condition of this transition.


The produced sub-blocs represent classes of equivalent states where each sub- block has new invariant that either satisfies or does not satisfy the enabling condition. The refinement process will terminate if there is no block of states to be refined. The produced finite graph abstracting temporal constraints can be too large. It is possible to reduce this finite graph using one approach of the equivalence based reductions [5,19].

Related work
A similar work can be found in [6], where the model checking is based on-the-fly exploration of a simulation graph. The simulation graph is the graph reachable, generated from the region graph [1] and from an initial re- gion. Thus, because the nodes in the simulation graph are region sets and only discrete transitions are explicit, while time passes implicitly inside the nodes, the simulation graph is much smaller than the region graph. The simulation graph is used to solve the model checking problem for a proposed automata- based branching-time temporal logic (TECT L∗). The on-the-fly model check- ing procedure consists in solving the emptiness problem, that is, in checking whether an automaton (the automaton product of the system automaton and the property automaton) has an infinite execution sequence that satisfies a given acceptance condition. In our work, the property automaton capturing the temporal constraints, is automatically generated from the TCTL specifi- cation. Our quotient graph is produced directly from the initial automaton of timed system specification, which resembles the simulation graph, without passing by the region graph. The quotient graph is coarser than the initial automaton but finer, and therefore bigger, than the initial graph. Another algorithm that also combines the on-the-fly and the symbolic approaches has been proposed in [16]. In that work, a symbolic graph is dynamically con- structed by the verification procedure, according to the formula (specified in an extended temporal logic of µ-Calculus) to be checked.
A similar reduction for a derivate of dense time TCTL (TCTL with freeze quantifiers [3]) is given in [9]. This approach augments the region graph used in [1] by a new atomic proposition and new transitions to handle the reset quantifier. Another related work can be found in [8], where verification is performed by translating TCTL (interpreted over discrete time) into CTL by adding an additional specification clock to the model. So, to model-check the augmented model, the CTL logic is extended, and thus the model-checker, too. The closest work to ours for the time abstraction based on equivalence can be found in [18]. Where the algorithm in [5] for minimal-model generation (which is an enhancement of the algorithm of Paige and Tarjan [15] to avoid refining unreachable classes) is adapted to infinite state space of timed automaton.


This new algorithm uses decision procedures for computing intersection, set difference and predecessors of classes, and testing whether a class is empty. Also, the TCTL specification is reduced to CTL logic extended with new atomic propositions to deal with the specification constraints. Then, a TCTL model checker has been developed based on techniques of the classic CTL model-checker. Other techniques are based on abstraction of the constraints specified in the system and in the property, using the framework of predicate abstractions as abstract interpretation [7,14].
The rest of the paper is organized as follows. In Section 2, we present the formalism of timed automata used to specify timed systems. The logic TCTL and our approach of transformation of the TCTL specifications to CTL specifications are presented in Section 3. Also, the proof of the transformation correctness is presented in this section. In Section 4, we present our algorithm for generating finite bi-similar graphs of the timed systems. Section 5 explains the method of using these graphs for CTL model checking and how the results can be projected back to original timed systems. At the end, a conclusion is given.

System Specification with Timed Automata
We model real-time systems by timed automata [2] which extend the automata formalism by adding clocks. Clocks are real-valued variables increasing uni- formly with time. Several independent clocks may be defined for the same timed automaton. A timed automaton A is a tuple ⟨Q, X , E , L, I, ⟩, where:
Q is a finite set of locations. We denote by q0 ∈Q the initial location.
X is a finite set of clocks. A valuation v is a function that assigns a non negative real-value v(x) ∈ R+ to each clock x ∈ X . The valuation v[X := δ] assigns the value δ to all clocks in the set X. The set of valuations is denoted VX . For δ ∈ R+, v + δ denotes the valuation v' such that v'(x)= v(x)+ δ for all x ∈ X .
E is a finite set of edges. Each edge e ∈E is a tuple ⟨q, θ, X, q'⟩ where
q, q' ∈ Q are the source and the target locations respectively,
θ ∈ Θ is an associated clock constraint which governs the triggering of the transition. It is called its enabling condition or its guard. We denote the set of constraints over X by Θ. A constraint is defined as a conjunction of atoms of the form x ∼ c, where x ∈ X , ∼∈ {<, ≤, >, ≥, =} and c is a natural constant.
X ⊆X is the set of clocks to be reset after making this transition.
L : Q → 2AP is a function that associates to each location a set of atomic

propositions from the set AP .
I is a function that associates a condition I(q) ∈ Θ to every location q ∈Q 
called the invariant of q.






true, {x}


∅
q0 true


x = 1, {x}






x ≥ 2, ∅
{p}
q1
x ≤ 1	x = 1, ∅




{r}
q2 true

Fig. 1. Timed Automaton
Figure 1 shows an example of a timed automaton where AP = {p, r} and
Q = {q0, q1, q2}. A state of A is a pair ⟨q, v⟩ ∈ Q × VX such that v satisfies
I(q). The initial state is the pair ⟨q0, v0⟩ such that v0(x) = 0 for all x ∈ X . Let S denote the set of states of A. We will refer to L(s) by L(q), for all s ∈ S, where s = ⟨q, v⟩. The set S can be partitioned to zones (symbolic states). A zone z = (q, Vz) is a set of states from S which are associated with the same discrete state q ∈ Q and a convex set of valuations Vz = {v | ∃⟨q, v⟩ ∈ S}. The state of a timed system can be changed through an edge that changes the location and resets some of the clocks (discrete transition), or by letting time pass without changing the location (time transition).
Let e = ⟨q, θ, X, q'⟩ ∈ E be an edge. The state ⟨q, v⟩ has a discrete tran-
sition to ⟨q', v'⟩, denoted ⟨q, v⟩ −→e  ⟨q', v'⟩, if v satisfies θ and v' = v[X := 0]
(we should note that the set of valuations respecting θ is always in the set of
valuations respecting I(q)). Let δ ∈ R+. The state ⟨q, v⟩ has a time transition
to ⟨q, v + δ⟩, denoted ⟨q, v⟩ −→τ  ⟨q, v + δ⟩, if for all δ' ≤ δ, v + δ' satisfies the
invariant I(q). We note M = (S, ⇒, s0) the transition system of A, where ⇒
is either a discrete transition or a time transition and s0 is the initial state. A
run r of M is an infinite sequence s0 ⇒ s1 ⇒ ··· of statΣes and transitions. We

denote R the set of runs of M. A run is divergent if
∞
i=0
δi (the sum of all

delays δi on this run) diverges. We denote R∞ the set of divergent runs of M. In the following, we will consider timed automata with only divergent runs (if the automaton has non-divergent runs, called also zeno runs, it is possible to restrict the behavior to divergent runs [10]).
From the theoretical point of view, we represent the timed model as a labeled transition system (LTS), where each discrete transition has a label a (action). If the transition is taken, the action resets the set of clocks indicated by this transition. The time transitions have a particular label named τ de- noting time elapse which is considered as an internal or hidden action. Let A be the set of actions and Aτ = A ∪ {τ }. Given a labeled transition system


LT S = (S, Aτ , T , s0), S is the set of reachable states from s0 with respect to T . T ⊆ S × Aτ ×S the (discrete or time) transition relation and s0 the initial state. For each label a and each state s, we consider the image set Ta(s) = {s' ∈ S | (s, a, s') ∈ T }. We extend this notation for sets of states: Ta(B)= ∪{Ta(s) | s ∈ B}. T −1 denotes the inverse relation.

Reduction of TCTL Specifications
Many important properties of timed systems find a natural expression in the real-time temporal logic TCTL, which extends the branching time logic CTL [1,3]. This extension either augments temporal operators with time bounds, or uses reset quantifiers. We use a version of TCTL with time bounds. The formulas ψ of the timed computation tree logic TCTL are defined inductively by the grammar
ψ ::= true | p | ¬ψ | ψ ∧ ψ | ψ∃U∼cψ | ψ∀U∼cψ.
where p ∈ AP is an atomic proposition, for simplicity, ∼ is restricted to be in the set {≤, ≥} and c ∈ N (N is the set of natural numbers). The temporal operators ∃ ∼cψ and ∀ ∼cψ stand for true∃U∼cψ and ¬∃ ∼c¬ψ, respec- tively, and the temporal operators ∀ ∼cψ and ∃ ∼cψ stand for true∀U∼cψ and ¬∀ ∼c¬ψ, respectively.
The formulas of TCTL are interpreted over the set of states of a timed automaton represented by a transition system M. Let ⟨q, v⟩ ∈ S be a state reachable in M and let a TCTL-formula ψ. The satisfaction relation, denoted by ⟨q, v⟩ |=M ψ, is defined inductively on the syntax of ψ:
⟨q, v⟩ |=M true
⟨q, v⟩ |=M p iff p ∈ L(q)
⟨q, v⟩ |=M ¬ψ iff ⟨q, v⟩ |=M ψ
⟨q, v⟩ |=M ψ' ∧ ψ'' iff ⟨q, v⟩ |=M ψ' ∧ ⟨q, v⟩ |=M ψ''
⟨q, v⟩ |=M ψ'∃U∼cψ'' iff ∃r ∈ R∞ and r(0) = ⟨q, v⟩, ∃i.Σj≤iδj ∼ c and
r(i) |= ψ'' and ∀j < i.r(j) |=M ψ'
⟨q, v⟩ |=M ψ'∀U∼cψ'' iff ∀r ∈ R∞ and r(0) = ⟨q, v⟩, ∃i.Σj≤iδj ∼ c and
r(i) |= ψ'' and ∀j < i.r(j) |=M ψ'
Reduction Algorithm
Our objective is to reduce a TCTL formula ψ to a CTL formula ϕ. Any TCTL formula ψ will introduce a new set of specification clocks Xψ. This set of specification clocks do not control the behavior of any system under


consideration. The algorithm defined below reduces the TCTL formula ψ recursively by decomposing ψ. At the end, it generates an equivalent CTL formula ϕ and a timed automaton Aψ, capturing the timed behavior specified in the TCTL formula ψ. If the formula does not contain temporal constraint (it is already a CTL formula), the algorithm returns this formula and an empty timed automaton.
On the other hand if the TCTL formula contains temporal constraints, these can be of one of the following two forms: ψ'∃U≤cψ'' (same thing for the operator ∀U ). The second form is ψ'∃U≥cψ''. The constructed timed automaton Aψ, is the same for the two forms which has a set of one clock
variable Xψ = {z}, two discrete states Qψ = {qψ, qψ} with invariants z ≤ c
0	1
and true respectively (these two discrete states are not labeled), and one edge
Eψ = {(qψ,z = c, ∅, qψ)}. This timed automaton will be composed with the
0	1
product of the two timed automata Aψ' and Aψ'' constructed by the recursive
call to the function U ntime(ψ') and U ntime(ψ'') respectively.

The produced CTL formula is of the form U ntime(ψ')∃U (qψ
∈ Loc) ∧

U ntime(ψ'') for the first form of ψ, or U ntime(ψ')∃U (qψ ∈ Loc)∧U ntime(ψ'') for the second form. Loc :→ Q is an operator defined to return the current discrete state of a timed system. Thus, if a timed system is composed of n components (automata), a call to Loc will return as a system current state a set of the components (composing the timed system) states {q1, q2, ··· , qn} (q = q1 × q2 × ··· × qn, where q ∈Q and qi ∈ Qi).
Algorithm 1 {T imedAutomaton, CT L} U ntime(TCTL ψ)
{
T imedAutomaton Aψ' , Aψ'' ;
CTL ϕ', ϕ'';
TCT Lψ', ψ'';
switch(ψ) {
case true : return {∅, true}; case p : return {∅, p};
case ¬ψ' : {Aψ' , ϕ'}← U ntime(ψ'); return {Aψ' , ¬ϕ'};
case ψ' ∧ ψ'' : {Aψ' , ϕ'}← U ntime(ψ'); {Aψ'' , ϕ''}← U ntime(ψ''); return {Aψ' ⊕ Aψ'' , ϕ' ∧ ϕ''};
case ψ'∃U≤c(or ≥c) (or ∀U≤c(or ≥c)ψ'' :
{Aψ' , ϕ'}← U ntime(ψ'); {Aψ'' , ϕ''}← U ntime(ψ'');
Let z be the speciﬁcation clock associated to this TCTL formula
return {(Aψ' ⊕ Aψ'' ) ⊕ {{qψ, qψ}, {z}, {qψ,z = c, ∅, qψ},
0	1	0	1
{L(qψ)= L(qψ)= ∅}, {I(qψ)= z ≤ c, I(qψ)= true}},
0	1	0	1


ϕ'∃Uqψ ∈ Loc (or qψ ∈ Loc) ∧ ϕ''
0	1
(or ϕ'∀Uqψ ∈ Loc (or qψ ∈ Loc) ∧ ϕ'')}
0	1
}
}
Example 3.1 For the TCTL formula ψ = ∀ ≥2r (which is equivalent to true∀U≥2r), this algorithm generates the equivalent CTL formula ϕ and the timed automaton Aψ shown in Figure 2.

∅	∅
qψ	z = 2, ∅	qψ

true, {z}
0		
z ≤ 2
1
true
ϕ = true∀U (qψ ∈ Loc) ∧ r

Fig. 2. Generated Timed Automaton A with CTL formula ϕ

The constructed timed automaton Aψ will be composed with the original timed automaton A (A⊗Aψ). The parallel composition of two timed automata (⊗) is defined as follows. Let Ai be ⟨Qi, Xi, Ei, Li, Ii⟩, for i = 1, 2. We assume that Q1 ∩ Q2 = ∅ and X1 ∩ X2 = ∅. The product timed automaton A = A1 ⊗ A2 = ⟨Q, X , E , L, I⟩ is such that: Q = Q1 × Q2, X = X1 ∪ X2, I(⟨q1, q2⟩) = I1(q1) ∧ I2(q2), L(⟨q1, q2⟩) = L1(q1) ∪ L2(q2), and the set E of edges is obtained as follows. Let ei ∈ Ei of the form ⟨qi, θi, Xi, q'⟩, for
i = 1, 2. Then e ∈ E can be either e = ⟨(q1, q2), θ1 ∧ θ2, X1 ∪ X2, (q' , q' )⟩,
1  2
e = ⟨(q1, q2), θ1, X1, (q' , q2)⟩, or e = ⟨(q1, q2), θ2, X2, (q1, q' )⟩.
1	2
The algorithm U ntime is using the operator ⊕ to realize a parallel com-
position of two timed automata which is a particular case of the parallel com- position ⊗. It is defined to compose the constructed timed automata Aψ' and Aψ'' , where ψ' and ψ'' are sub-formulas of ψ, to get only one timed au- tomaton Aψ with one clock variable z. Its difference from the operator ⊗ is in the construction of the set of edges E, which is obtained as follows. Let ei ∈ Ei of the form ⟨qi, zi = ci, ∅, q'⟩, for i = 1, 2. Then, if c1 < c2, we add e = ⟨(q1, q2),z = c1, ∅, (q' , q2)⟩ to E, where I(⟨q1, q2⟩) = z ≤ c1. We replace e2 in E2 by ⟨q2, z2 = c2 − c1, ∅, q' ⟩ and we remove e1 from E1. Else, if c2 < c1, we add e = ⟨(q1, q2),z = c2, ∅, (q1, q' )⟩ to E, where I(⟨q1, q2⟩) = z ≤ c2. We replace e1 in E1 by ⟨q1, z1 = c1 − c2, ∅, q' ⟩ and we remove e2 from E2. Else,
e = ⟨(q1, q2),z = c1, ∅, (q' , q' )⟩, where I(⟨q1, q2⟩) = z ≤ c1 and we remove e1
1  2
from E1, e2 from E2.
This process will continue until Ei = ∅, for i = 1, 2 or one of the following two cases is satisfied. In the case where E1 = ∅ and E2 = {⟨q2, z2 = c2, ∅, q' ⟩}, we assume that q1 ∈ Q1 is the discrete state without outgoing edge. Then, we add the edge e = ⟨(q1, q2),z = c2, ∅, (q1, q' )⟩ to E, where I(⟨q1, q2⟩)= z ≤ c2. In the other case where E2 = ∅ and E1 = {⟨q1, z1 = c1, ∅, q' ⟩}, we assume that


q2 ∈ Q2 is the discrete state without outgoing edge. Then, we add the edge e = ⟨(q1, q2),z = c1, ∅, (q' , q2)⟩ to E, where I(⟨q1, q2⟩) = z ≤ c1. At the end, if there are discrete states in the produced timed automaton, without ingoing and outgoing edges, they will be removed from the set of discrete states Q.
⊗-Property 1: A⊗∅ = ∅⊗ A = A, ∅ (empty automaton is an automaton with no states and no transitions) is the identity. We note that ∅ is also an identity for ⊕
⊗-Property 2: If the valuation functions v1 and v2 are defined as follows: v1 : X1 → R+ and v2 : X2 → R+, respectively. Then the valuation function v : X → R+, where X = X1 ∪ X2, is defined as follows. If x ∈ X1 then v(x)= v1(x) else v(x)= v2(x).
⊗-Property 3: If a TCTL-formula ψ is satisfied in a model M of the timed automaton A, it is still satisfied in a model M+ of the timed automaton A+ which is the composition of A with any other timed automaton A' respecting the conditions mentioned above.
Proof. The proof proceeds by induction on the structure of ψ. The basis cases where ψ is of the form true or p are immediate. For example, if ψ = p, this formula is satisfied in the state ⟨q, v⟩ if and only if p ∈ L(q). By composition with a new timed automaton A', the state will have the form ⟨(q, q'), v⟩, where q' is one of the locations in A' and the set of atomic propositions marking this state is L(q) ∪ L'(q') which contains p.
For ψ = ¬ψ'. By the semantics of TCTL, ⟨q, v⟩ |=M ¬ψ' if and only if not(⟨q, v⟩ |=M ψ'). The induction hypothesis is ⟨q, v⟩ |=M ψ' ⇒ ⟨(q, q'), v⟩ |=M+ ψ'. Then, ⟨q, v⟩ |=M ψ' ⇒ not(⟨(q, q'), v⟩ |=M+ ¬ψ'). By the semantics of TCTL ⟨(q, q'), v⟩ |=M+ ¬ψ').
For ψ = ψ' ∧ ψ''. By the semantics of TCTL, ⟨q, v⟩ |=M ψ' ∧ ψ'' if and only if ⟨q, v⟩ |=M ψ' and ⟨q, v⟩ |=M ψ''. The induction hypothesis is ⟨q, v⟩ |=M ψ' ⇒ ⟨(q, q'), v⟩ |=M+ ψ' and ⟨q, v⟩ |=M ψ'' ⇒ ⟨(q, q'), v⟩ |=M+ ψ''. By the semantics of TCTL ⟨(q, q'), v⟩ |=M+ ψ' ∧ ψ''.
For ψ = ψ'∃U∼cψ''. By the semantics of TCTL, ∃r ∈ R∞ where r =
⟨q0, v0⟩, ⟨q1, v1⟩, ··· , ⟨qj, vj⟩, ··· , ⟨qi, vi⟩, ··· , such that Σj≤iδj ∼ c and
⟨qi, vi⟩ |=M ψ'' and ∀j < i.⟨qj, vj⟩ |=M ψ'. By composition with other timed automaton, the run r will be r' = ⟨(q0, q' ), v0⟩, ··· , ⟨(q1, q' ), v1⟩, ··· ,
0	k
⟨(qj, q' ), vj⟩, ··· , ⟨(qi, q' ), vi⟩, ··· . The induction hypothesis is ⟨qi, vi⟩ |=M
m	p
ψ'' ⇒ ⟨(qi, q' ), vi⟩ |=M+ ψ'' and ⟨qj, vj⟩ |=M ψ' ⇒ ⟨(qj, q' ), vj⟩ |=M+ ψ'. By
p	m
the semantics of TCTL, ⟨(q0, q' ), v0⟩ |=M+ ψ.
By the same way, we prove the case ψ = ψ'∀U∼cψ''. Every run r =
⟨q0, v0⟩, ··· , ⟨qj, vj⟩, ··· , ⟨qi, vi⟩, ··· ∈ R∞, after composition with a new

timed automaton, will have the form r' = ⟨(q0, q' ), v0⟩, ··· , ⟨(q0, q' ), vk⟩, ··· ,
0	k
⟨(qj, q' ), vm⟩, ··· , ⟨(qj, q' ), vj⟩, ··· , ⟨(qi, q' ), vn⟩, ··· , ⟨(qi, q'), vi⟩, ··· . The
0	p	m	l
induction hypothesis is ⟨qi, vi⟩ |=M ψ'' ⇒ ⟨(qi, q'), vi⟩ |=M+ ψ'' and ⟨qj, vj⟩ |=M
ψ' ⇒ ⟨(qj, q' ), vj⟩ |=M+ ψ'. By the semantics of TCTL, ⟨(q0, q' ), v0⟩ |=M+
p	0
ψ'∀U∼cψ''.	 
Example 3.2 The product timed automaton of the two timed automata shown in Figure 1 and Figure 2 is presented in Figure 3.
x ≥ 2, ∅





true, {z}
∅
⟨q0 ,qψ ⟩
z ≤ 2

x = 1, {x}
{p}
⟨q1 ,qψ ⟩
x ≤ 1 ∧ z ≤ 2

x = 1, ∅
{r}
⟨q2, qψ ⟩
z ≤ 2




z = 2, ∅
∅
⟨q0 ,qψ ⟩
true

x =1 ∧ z = 2, {x}

x = 1, {x}

z = 2, ∅
{p}
⟨q1 ,qψ ⟩
x ≤ 1
x ≥ 2, ∅
x =1 ∧ z = 2, ∅
x ≥ 2 ∧ z = 2, ∅

x = 1, ∅

z = 2, ∅
{r}
⟨q2, qψ ⟩
true

Fig. 3. The product timed automaton


Correctness
By the reduction algorithm U ntime, we produce a CTL formula ϕ and a timed automaton Aψ from a TCTL formula ψ. Let M be the transition system of the timed automaton A modeling a real-time system. Along the proof, we use ⟨q, v⟩ |=M ψ to indicate that the state ⟨q, v⟩ satisfies the TCTL formula ψ. We use ⟨q, v⟩ |=M+ ϕ to indicate that the state ⟨q, v⟩ satisfies the CTL formula ϕ (M+ is the transition system of A+ = A⊗ Aψ).
Theorem 3.3 ⟨q, v⟩ |=M ψ ⇔ ⟨q, v⟩ |=M+ ϕ
Proof. The proof proceeds by induction on the structure of ψ. The basis cases where ψ is of the form true or p are immediate. In these basis cases A = ∅; and ψ = ϕ, using ⊗-Property 1, this means ⟨q, v⟩ |=M ψ ⇔ ⟨q, v⟩ |=M+ ϕ.
For ψ = ¬ψ', we prove ⟨q, v⟩ |=M ψ ⇔ ⟨q, v⟩ |=M+ ϕ, where M+ and ϕ are constructed by the call to U ntime(ψ). The induction hypothesis is ⟨q, v⟩ |=M
'	'	+	'	'

ψ  ⇔ ⟨q, v⟩ |= +
ψ'
ϕ , where Mψ'  and ϕ
are constructed by U ntime(ψ ).

According to the algorithm U ntime, ϕ = ¬ϕ' and M+ = M+ . By the semantics of TCTL, ⟨q, v⟩ |=M ¬ψ' if and only if not (⟨q, v⟩ |=M ψ'). By

the induction hypothesis, ⟨q, v⟩ |=M ¬ψ' if and only if not (⟨q, v⟩ |=M+
ψ
ϕ').

Now, by the TCTL semantics, we can conclude ⟨q, v⟩ |=M ¬ψ' if and only if

⟨q, v⟩ |= +
ψ'
¬ϕ'. This means that ⟨q, v⟩ |=M ψ if and only if ⟨q, v⟩ |=M+ ϕ.

For ψ = ψ' ∧ ψ''. First we prove ⟨q, v⟩ |=M ψ ⇒ ⟨q, v⟩ |=M+ ϕ. By the semantics of TCTL, ⟨q, v⟩ |=M ψ' ∧ ψ'' if and only if ⟨q, v⟩ |=M ψ' and
⟨q, v⟩ |=M ψ''. The induction hypothesis is ⟨q, v⟩ |=M ψ' ⇔ ⟨q, v⟩ |=M+ ϕ'
ψ

and ⟨q, v⟩ |=	ψ'' ⇔ ⟨q, v⟩ |= +
ψ''
ϕ'', where ϕ' (with Aψ' ) and ϕ'' (with Aψ'' )

are the CTL formulas (timed automata) constructed from the TCTL sub-

formulas ψ' and ψ'' respectively, M+
and M+
are the transition systems of

A⊗Aψ' and A⊗Aψ'' , respectively. By ⊗-Property 3 of automata composition,
we have ⟨q, v⟩ |=M+ ϕ' and ⟨q, v⟩ |=M+ ϕ''. Then, we can conclude by using the semantics of TCTL ⟨q, v⟩ |=M+ ϕ' ∧ ϕ'' (M+ is the transition system of A⊗ Aψ' ⊗ Aψ'' ).
Now, we proof ⟨q, v⟩ |=M+ ϕ ⇒ ⟨q, v⟩ |=M ψ. We know that ϕ is constructed from ψ and as ψ is of the form ψ' ∧ ψ'', then according to the algorithm U ntime, ϕ is of the form ϕ' ∧ ϕ''. The sub-formula ϕ' and the automaton Aψ' are both constructed from the sub-formula ψ' (the same for ϕ'' and Aψ''  are constructed from ψ'').  By the induction hypothesis

(⟨q, v⟩ |= +
ψ'
ϕ' ⇔ ⟨q, v⟩ |=	ψ' and ⟨q, v⟩ |= +
ψ''
ϕ'' ⇔ ⟨q, v⟩ |=M ψ''),

using the composition property ⊗-Property 3 and the semantics of TCTL, we
can conclude that ⟨q, v⟩ |=M+ ϕ' ∧ ϕ'' ⇒ ⟨q, v⟩ |=M ψ' ∧ ψ''.
For ψ = ψ'∃U≤cψ''. Consider a state ⟨q, v⟩ in M. Assume that ⟨q, v⟩ |=M
ψ. Then, by the semantics of TCTL, there is a run r = ⟨q0, v0⟩, ⟨q1, v1⟩, ··· ,

⟨qi, vi⟩, ··· ∈ R∞ with ⟨q0, v0⟩ = ⟨q, v⟩, where i ≥ 0 such that Σi
δk ≤ c and

⟨qi, vi⟩ |=M ψ'', and for all 0 ≤ j < i we have ⟨qj, vj⟩ |=M ψ'. By the induction

hypothesis, ⟨q ,v ⟩ |=
ψ'' ⇔ ⟨(q ,q '' ),v ⟩ |= +
ϕ'' (M+
is the model of

i	i	M
i  ψ	i
Mψ''
ψ''

A⊗ A
'' ) and ⟨q ,v ⟩ |=
ψ' ⇔ ⟨(q ,q ' ),v ⟩ |=
+ ϕ' (M+
is the model

ψ	j	j	M
j	ψ	j
Mψ'	ψ

of A⊗ Aψ' ). It is clear from the composition property ⊗-Property 3 that

⟨(q ,q ' ,q '' ),v ⟩ |= +
ϕ'' and ⟨(q ,q ' ,q '' ),v ⟩ |= +
ϕ', where M+	is

ψ	ψ
M ' ''
ψ ψ
ψ	ψ
M ' ''
ψ ψ
ψ'ψ''

the model of A⊗ (Aψ' ⊕ Aψ'' ). If we add a specification clock z to the set of
clocks and if we compose the automaton A⊗(Aψ' ⊕Aψ'' ) with a new automaton
Aψ composed of two states {qψ, qψ} with I(qψ)= z ≤ c and edge eψ = (qψ,z =
0	1	0	0
c, ∅, qψ). It is clear that vi(z) ≤ c and ⟨(qi, qψ' , qψ'' , qψ), vi⟩ |=M+ ϕ'' and for
1	0
all 0 ≤ j < i we have ⟨(qj, qψ' , qψ'' , qψ), vj⟩ |=M+ ϕ', where M+ is the model of A⊗ (Aψ' ⊕ Aψ'' ⊕ Aψ). Thus, vi(z) ≤ c and ⟨(qi, qψ' , qψ'' , qψ), vi⟩ |=M+ ϕ''
if and only if ⟨qi, vi⟩ |=M+ ϕ'' ∧ qψ ∈ Loc. By the semantics of TCTL, we
'	''	ψ
have ⟨q, v⟩ |=M+ ϕ ∃Uϕ ∧ q0  ∈ Loc.  We proceed by the same way for
ψ = ψ'∀U≤cψ''.
By the same way we can prove the case ψ = ψ'∃U≥cψ'', where ⟨(qj, qψ' , qψ'', qψ),


vj⟩ |=M+ ϕ'. Thus, vi(z) ≥ c and ⟨(qi, qψ' , qψ'' , qψ), vi⟩ |=M+ ϕ'' if and only if
⟨qi, vi⟩ |=M+ ϕ'' ∧ q1 ∈ Loc. By the semantics of TCTL, we have ⟨q, v⟩ |=M+
ϕ'∃Uϕ'' ∧ qψ ∈ Loc. We proceed by the same way for ψ = ψ'∀U≥cψ''. 
We denote the size of a timed automaton A = ⟨Q, X , E , L, I⟩ by the pair (|Q|, |E|), where |Q| is the number of discrete states and |E| is the number of edges. For a TCTL formula ψ with n temporal constraints, the algorithm U ntime generates a timed automaton Aψ with one clock variable, |Qψ|≤ n+1 and |Eψ|≤ n. The size of A⊗Aψ is at most (|Q|×|Qψ|, |E|×|Eψ|+|E|+|Eψ|−1).

Generating Bi-similar Finite System
The model of a timed automaton is an infinite transition-state system due to dense time. Then, it is not possible to perform a model checking. In this section we present our algorithm that generates a strongly bi-similar finite system based on a defined equivalence where exact delays are abstracted away while information on the discrete changes of the system is retained.

Strong Bi-simulation
For a labeled transition system M = (S, Aτ , T , s0), a partition ℘ (or equiva- lence relation on S) of the elements of S is a set of disjoint blocks {Bi | i ∈ N } such that ∪i∈N Bi = S. Let ℘ and ℘' be partitions of S. ℘' is a refinement of
℘ (℘' ⊆ ℘) if and only if ∀B' ∈ ℘' : ∃B ∈ ℘ : (B' ⊆ B). Intuitively, two states

s1 and s2 are bi-similar if for each state s'
reachable from s1 by execution

of an action a ∈ Aτ (see Section 2) there is a state s' , reachable from s2 by

execution of the action a such that s'
and s'
are bi-similar.

Definition 4.1 Given a labeled transition system M = (S, Aτ , T , s0), a bi- nary relation ℘ ⊆ S × S is a strong bi-simulation if and only if the following conditions hold ∀(s1, s2) ∈ ℘ and ∀a ∈ Aτ :
L(s1)= L(s2),
∀s3(s3 = Ta(s1) ⇒ ∃s4(s4 = Ta(s2) ∧ (s3, s4) ∈ ℘)) and
∀s4(s4 = Ta(s2) ⇒ ∃s3(s3 = Ta(s1) ∧ (s3, s4) ∈ ℘)).
The set of bi-simulations on S, ordered by inclusion has a minimal element which is the identity relation denoted by ℘0 and it has a maximal element denoted by ℘max which is an equivalence relation on (or a partition of) S. We will be interested in the maximal element which induces the smallest number of equivalence classes in terms of relation inclusion. ℘max (which is unique) may be obtained as the limit of a decreasing sequence of relations ℘i.


Most algorithms used to solve the bi-simulation problem are based on some form of partition refinement, i.e. they perform successive iterations in which blocks of the current partition are split into smaller blocks, until no block can be split anymore. While splitting a block, states that cannot be distinguished are kept in the same block. Two states can be distinguished if one of the states allows a transition with a certain label to a state in a certain block and the other state does not have a transition with the same label to a state in the same block.
Let ℘ be a partition of S. ℘ is compatible with T (it is called also stable) if and only if the following property P holds:
P (℘)= ∀a ∈ Aτ : ∀B, B' ∈ ℘ : (B' ⊆T −1(B) ∨ B' ∩ T −1(B)= ∅).
a	a
Correctness of a partition refinement algorithm follows from two facts. First, a stable partition is a bi-simulation relation (states are equivalent if they are in the same block). Second, each computed partition by the refinement of the previous one, respects the property P.
Definition 4.2 Let M = (S, Aτ , T , s0) be a labeled transition system and
℘ an equivalence relation which is a strong bi-simulation, the quotient la- beled transition system denoted by M/℘ is defined as follows: M/℘ = (S/℘, Aτ , T /℘, s0) where:
S/℘ is the set of equivalence classes noted C, C = {B ⊆ S | ∀s1, s2 ∈ B : (s1, s2) ∈ ℘)
((B = Ta(B')) ∈T /℘) if and only if T −1(B) ∩ B' /= ∅
C0 = [s0] is the equivalence class of s0.
M/℘max is the normal form of M with respect to ℘max. We present below a partition-refinement algorithm based on strong bi-simulation. We start from an initial partition of the state space in zones. Each time a zone Z is to be refined, it is split with respect to all its discrete successors by some edge e. We can prove that if all successors are zones, then the result of the split is also a set of zones, that is, convexity is preserved by the split operation.
Partition-Reﬁnement Algorithm
Consider a timed automaton A = ⟨Q, X , E , L, I⟩ and let e ∈ E be an edge such that its guard is θ different from true. We will refine the block of source states (q, v) of e represented as a convex zone Z = (q, VZ). The objective of refinement is to abstract the quantitative aspect of time needed to measure the constraint θ. So, this block of states (zone) is refined into sub-zones. The invariant of one of these sub-zones satisfies the constraint θ. But, the


invariants of the other sub-zones don’t satisfy this constraint. This process of refinement will continue until there are no blocks to refine. The operators over temporal constraints, used in the algorithm of partition refinement are defined as follows.
V ar(θ) is the set of clock variables in the formula θ.
θ♩x is the constraint θ reduced to a constraint defined only on the clock variable x (e.g. x =1 ∧ y < 2 ∧ z ≤ 3♩x ≡ x = 1)
θ|x is the constraint θ reduced to a constraint defined without the clock variable x (e.g. x =1 ∧ y < 2 ∧ z ≤ 3|x ≡ y < 2 ∧ z ≤ 3)
∩ is the intersection operator (e.g. x ≤ 2 ∩ x ≥ 2 ≡ x = 2). θ1 ∩ θ2 = ∅
if V ar(θ1) ∩ V ar(θ2)= ∅.
\ is the set difference operator (e.g. x ≤ 2 \ x =1 ≡ x < 1 ∨ (x > 1 ∧ x ≤
2), it is not convex).
[θ♩ if θ is convex then this operator will return θ itself else it returns the constraint representing the lower convex valuations. The constraint θ is defined on one clock variable (e.g [x < 1 ∨ (x > 1 ∧ x ≤ 2)♩≡ x < 1).
[θ| if θ is convex then this operator will return ∅ else it returns the constraint representing the upper convex valuations. The constraint θ is defined on one clock variable (e.g [x < 1 ∨(x > 1 ∧ x ≤ 2)|≡ x > 1 ∧ x ≤ 2).
The algorithm below refines a zone that is a source of an edge e =⟨q, θ, X, q'⟩, taken arbitrarily from the set E of the current partition, where θ /= true. The refinement is based on a clock variable x taken also arbitrarily from the set of clock variables in the constraint θ. The zone is split into at most three sub- zones. These sub-zones have the same location q, but with different invariants. Their union equals to I(q). Because their invariants are different and for al- gorithm simplicity, we will denote their location q differently to distinguish them, this will not have any effect on the algorithm results.
The first sub-zone (with discrete state qx) has the invariant I(qx)= θ♩x ∧ I(q)|x and an outgoing edge ⟨qx, θ|x, ∅, q'⟩.
If [I(q)♩x \ θ♩x♩ /= ∅, we have a second sub-zone with a discrete state ql with an invariant I(ql) = [I(q)♩x \ θ♩x♩∧ I(q)|x. This sub-zone has an outgoing edge ⟨ql, true, ∅, qx⟩. If [I(q)♩x \ θ♩x| /= ∅ then, we have a third sub-zone with a discrete state qu and an invariant
I(qu) = [I(q)♩x \ θ♩x| ∧ I(q)|x.  This sub-zone has an ingoing edge
⟨qx, true, ∅, qu⟩. The three new sub-zones will be marked by the same set of atomic propositions L(q).


At the end of this iteration, the edge e and the zone Z will be removed and replaced by the new edges and the new sub-zones. The other outgoing and incoming edges from and to the zone Z will be updated according to the new partition, see the algorithm for more details. The non-zenoness of the timed automaton and the convexity of its constraints guarantee that the produced partition has zones preserving the convexity and the non-zenoness. Moreover, the algorithm terminates.
Algorithm 2  partition-reﬁnement(A = ⟨Q, X , E , L, I⟩)
{
if (∃e ∈E | e = ⟨q, θ, X, q ⟩∧ θ /= true) {
Let x be a clock variable in the constraint θ.
EOld ← {e};
Cq ← qx with I(qx )= θ♩x ∧ I(q) x and L(qx)= L(q);
'
ENew ← {⟨q , θ x, ∅, q ⟩};
if ([I(q)♩x \ θ♩x♩ /= ∅) {
Cq ← Cq ∪ {ql} with I(ql)= [I(q)♩x \ θ♩x♩∧ I(q) x and L(ql)= L(q);
ENew ← ENew ∪ {⟨ql, true, ∅, qx ⟩}
}
if ()I(q)♩x \ θ♩x /= ∅) {
Cq ← Cq ∪ {qu } with I(qu )= )I(q)♩x \ θ♩x ∧ I(q) x and L(qu)= L(q);
ENew ← ENew ∪ {⟨qx, true, ∅, qu⟩}
}
for each edge e' = ⟨q, θ',X', q'⟩∈ E do //Outgoing edges

EOld
← EOld
∪ {e'}
'
'	'  '

if ([I(q)♩x \ θ♩x♩ /= ∅∧ θ ∩ I(ql) /= ∅) ENew ← ENew ∪ {⟨ql,θ ∩ I(ql),X ,q ⟩}
'	'	'  '
if (θ ∩ I(qx ) /= ∅) ENew ← ENew ∪ {⟨qx,θ ∩ I(qx),X ,q ⟩}
'	'	'  '
if ()I(q)♩x \ θ♩x /= ∅∧ θ ∩ I(qu) /= ∅) ENew ← ENew ∪ {⟨qu,θ ∩ I(qu),X ,q ⟩}
end for
for each edge e'' = ⟨q'', θ'',X'', q⟩∈ E do //Incoming edges

EOld
← EOld
∪ {e''}
''	''

if ([I(q)♩x \ θ♩x♩ /= ∅∧ (I(ql) ∩ θ /= ∅∨ V ar(I(ql)) ∩ V ar(X
) /= ∅))

''  ''	''
ENew ← ENew ∪ {⟨q , θ ,X ,q ⟩}

else
if ()I(q)♩
\ θ♩  = ∅∨ θ'' ∩ I(q ) /= ∅∨ V ar(I(q )) ∩ V ar(X'') /= ∅)

x	x	'' ''
'' x	x

ENew ← ENew ∪ {⟨q ,θ ,X , qx⟩}
else
''  ''	''
ENew ← ENew ∪ {⟨q , θ ,X ,q ⟩}
end for
return partition-reﬁnement(⟨Q \ {q}∪ Cq, X , (E \ EOld) ∪ ENew, L, I⟩)
} else {
for each q ∈Q | I(q) is bounded only from below or / ∃e = ⟨q, true, ∅, q'⟩ E ← E ∪ {⟨q, true, ∅, q⟩}
return ⟨Q, X , E , L, I⟩
}
}


Quotient Graph
The partition-refinement algorithm generates a stable partition ℘max which is the coarsest. Each block in this partition is characterized by an invariant and a unique discrete state. These blocks are reachable and their invariants are convex. The edges of this partition, are of the form ⟨q, true, ∅, q'⟩. This partition can be easily represented by a graph, we call it the quotient graph


G℘max . The set C of nodes of G℘max is the set of the partition blocks. Thus, a node corresponding to block Bi is denoted Ci. The edges of G℘max are the edges in the partition ℘max between the different blocks in addition to edges of the form ⟨q, true, ∅, q⟩ if the invariant I(q) is bounded only from below. We redefine the function L over C as follows. If the effective discrete state (it is the discrete state of the partitioned original block in the initial partition) of block Bi is q then, L(Ci) = L(q). Then, different nodes of this graph can refer to one location from Q. It is necessary to keep this trace for verification purpose by using the operator Loc defined in Section 3. For example, if the current state of the transition system is the node C1 and C1 has inherited the effective discrete state q1, then Loc = {q1}. The strong bi-simulation quotient graph (G℘max ) generated by the algorithm of partition refinement and as it is defined, has the following properties:
G℘max -Property 1: G℘max is stable which means that ∀C1, C2 ∈ G℘max , then
τ
by definition, if C1 −→ C2 then ∀s1 ∈ C1 there exists s2 ∈ C2, such that

s −→δ  s , for some δ ∈ R+ and if C
2	1
−→e
C2, for some edge e, then ∀s1
∈ C1

there exists s2
∈ C2, such that s1
−→e
s2.

G℘max -Property 2: Given a path ρ = C1 ⇒ C2 ⇒ ··· of G℘max and a run
r = s1 ⇒ s2 ⇒ ··· , we say that r is inscribed in ρ if for all i ≥ 1: si ∈ Ci and,
τ	δ	e
if Ci −→ Ci+1 then there exists δ > 0 such that si −→ si+1, if Ci −→ Ci+1 then

s −→e
si+1
. It is easy to conclude that every run r is inscribed in a unique path

ρ in G℘max . And inversely, if ρ = C1 ⇒ C2 ⇒ ··· is a path in G℘max then for
all s1 ∈ C1 there exists a run r starting from s1 and inscribed in ρ.
G℘max -Property 3: Any time transition traverses a unique (finite) set of

classes. Also, if (s, s') ∈ ℘max
then for any time transition s −→
s + δ, there

exists a time transition s
'
−→ s'
+ δ'
such that (s + δ, s'
+ δ') ∈ ℘max and the

two transitions traverse the same classes.
The size of the quotient graph G℘max is defined by the pair of the number of its nodes and number of its edges, which are at most (3 × |E|, |Q| +3 × |E|).
Example 4.3 The strong bi-simulation quotient graph of the system de- scribed in Example 2 is shown in Figure 4, whose nodes are the symbolic states (zones) shown on the right with detailed information.

CTL Model-Checking
In this section we show that the strong bi-simulation ℘max preserves the CTL properties. The timed automaton model-checking can be reduced to model-


⟨0, q0 × qψ,x < 1 ∧ z < 2, ∅⟩
⟨1, q0 × qψ,x < 1 ∧ z = 2, ∅⟩
⟨2, q0 × qψ,x =1 ∧ z < 2, ∅⟩
⟨3, q0 × qψ,x =1 ∧ z = 2, ∅⟩
⟨4, q0 × qψ, 1 < x < 2 ∧ z < 2, ∅⟩
⟨5, q0 × qψ, 1 < x < 2 ∧ z = 2, ∅⟩
⟨6, q0 × qψ,x ≥ 2 ∧ z < 2, ∅⟩
⟨7, q0 × qψ,x ≥ 2 ∧ z = 2, ∅⟩
⟨8, q0 × qψ,x < 1, ∅⟩
⟨9, q0 × qψ,x = 1, ∅⟩
⟨10, q0 × qψ, 1 < x < 2, ∅⟩
⟨11, q0 × qψ,x ≥ 2, ∅⟩
⟨12, q1 × qψ,x < 1 ∧ z < 2, {p}⟩
⟨13, q1 × qψ,x < 1 ∧ z = 2, {p}⟩
⟨14, q1 × qψ,x =1 ∧ z < 2, {p}⟩
⟨15, q1 × qψ,x =1 ∧ z = 2, {p}⟩
⟨16, q1 × qψ,x < 1, {p}⟩
⟨17, q1 × qψ,x = 1, {p}⟩
⟨18, q2 × qψ,z < 2, {r}⟩
⟨19, q2 × qψ,z = 2, {r}⟩
⟨20, q2 × qψ, true, {r}⟩
Fig. 4. Quotient Graph
checking a finite graph, the strong bi-simulation quotient graph (Gmax) gen- erated by the algorithm of partition refinement.
Consider a transition system M = (S, ⇒, s0) modeling a strongly non- zeno timed automaton A and a CTL formula ϕ. We want to check whether M satisfies ϕ. Let ℘max be a strong bi-simulation on M. From G℘max -Property 3 of G℘max , we can conclude that for any CTL formula ϕ and any pair of states (s, s') ∈ ℘max, s |=M ϕ if and only if s' |=M ϕ.
A formula is said to hold in a node C of G℘max if it is satisfied in some state of C (this implies that the formula is satisfied in any state of C). Now, the problem of verifying if a state s ∈S satisfies the CTL formula ϕ (s |=M ϕ) is reduced to checking if the node C ∈ C containing the state s satisfies the formula ϕ (C |= ϕ). The following lemma gives the correctness of the model checking.
Lemma 5.1 Let M = (S, ⇒, s0) be a transition system modeling a strongly non-zeno automaton, L is a labeling function associating to each discrete state a set of atomic propositions from AP . Let ℘max be a strong bi-simulation on M and G℘max is its quotient graph with the set of nodes C. Let C be in C and ϕ a CTL formula. C |= ϕ if and only if ∀s ∈ C, s |=M ϕ.
Proof. The proof is by induction on the syntax of ϕ. The basis (ϕ is an atomic proposition) comes from the fact that ℘max respects L. The case for ϕ1 ∧ ϕ2 is trivial.
Consider the case where ϕ is of the form ϕ1∃Uϕ2. Assume that C' |= ϕ2


and C |= ϕ1. If C |= ϕ, by the semantics of CTL, there is a path ρ = C ⇒
··· ⇒ C'. By G℘  -Property 2 of G℘  , from any state s ∈ C there is a run inscribed in the path ρ which satisfies the formula ϕ. This means that
∀s ∈ C, s |=M ϕ.
If ∀s ∈ C, s |=M ϕ. By the semantics of CTL, there is a run r = s ⇒
··· ⇒ s', where s |=M ϕ1 and s' |=M ϕ2. We know by G℘  -Property 2 that from any state s there is a run inscribed in a unique path from C (ρ = C ⇒ ··· ⇒ C'). Then s' ∈ C'. By induction hypothesis, C |= ϕ1 and C' |= ϕ2. By the semantics of CTL, this means C |= ϕ1∃Uϕ2.
The case where ϕ is of the form ϕ1∀Uϕ2 can be proved by the fact that if C |= ϕ, we can extract a run r which falsifies ϕ, from the path ρ starting from the node C using the property G℘max -Property 2.	 
Example 5.2 The TCTL model checking of the problem ⟨q0,x = 0⟩ |= ∀ ≥2r on the model of the timed automaton of Figure 1, is then reduced to CTL model checking of C0 |= true∀U (qψ ∈ Loc) ∧ r on the model represented by the graph in Figure 4. Where C0 = [⟨q0,x = 0⟩]. This CTL formula is not satisfied and the model checking returns a trace t = C0 → C1 → C8 → C9 → C10 → C11 → ··· as a counterexample. By mapping to the concrete timed automaton, the discrete states of the nodes (classes) C0, C1, C8, C9, C10, C11

are q . Thus, the concrete trace is ⟨q ,x = 0⟩ −δ→0
⟨q ,x = δ ⟩ −δ→1
⟨q0,x =

δ + δ ⟩ −δ→2
··· .


Conclusion
In this paper, we have presented a technique for model checking dense real- time systems. This method is based on the reduction of TCTL specifications to CTL. The timed behavior of the TCTL specification is captured and rep- resented as a timed automaton. This timed automaton is composed with the original timed automaton modeling the timed system. Then, a time ab- straction technique based on strong bi-simulation, is used to generate a finite graph modulo the TCTL specification. A number of branching-time verifi- cation tools can be used for performing CTL model-checking on this graph. The advantage of this technique is that there is no need to extend the logic CTL or its model-checking algorithm. Our algorithm of time abstraction is very simple where complicated operations on sets are avoided. Thus, it can be implemented easily.
Effectively, we have implemented a preliminary version of a tool to test this technique for model checking dense real-time systems. During the im- plementation, we tried to avoid the generation of large quotient graphs by


model checking the TCTL formula gradually. Based on the structure of the TCTL formula, we decompose it into sub-formulas and each sub-formula will be checked separately. The overall result is the combination of the partial results.

References
Alur R., Courcoubetis C., and Dill D. L., Model checking in dense real time, Information and Computation, 104(1) (1993), 2–34.
Alur R., and Dill D., Automaton for modeling real-time systems, In 17th ICALP, number 443 in Lecture Notes in Computer Science, Springer-Verlag, 1990.
Alur R., and Henzinger T. A., Logics and models of real time: a survey, In Real Time: Theory in Practice, number 600 in Lecture Notes in Computer Science, 74–106, Springer-Verlag, 1992.
Alur R., Henzinger T. A., and Ho P. H., Automatic symbolic veriﬁcation of embedded systems, IEEE Transactions on Software Engineering, 22 (1996), 181–201.
Bouajjani A., Fernandez J. C., Halbwachs N., Raymond P., and Ratel C., Minimal state graph generation, Science of Computer Programming, 18 (1992), 247–269.
Bouajjani A., Tripakis S., and Yovine S., On-the-fly symbolic model-checking for real-time systems, IEEE RTSS’97, IEEE Computer Society Press, 1997.
Bourahla M., and Benmohamed M., Veriﬁcation of real-time systems by abstraction of time constraints, In IPDPS(FMPPTA), IEEE Computer Society, 2003.
Brockmeyer U., and Wittich G., Real-time veriﬁcation of statemate designs, In Computer Aided Verification, number 1427 in Lecture Notes in Computer Science, 537–541, Springer-Verlag, 1998.
Henzinger T. A., and Kupferman O., From quantity to quality, In Workshop on Hybrid and Real-Time Systems (HART97), number 1201 in Lecture Notes in Computer Science, 48–62, Springer-Verlag, 1997.
Henzinger T. A., Nicollin X., Sifakis J., and Yovine S., Symbolic model checking for real-time systems, Information and Computation, 111(2) (1994), 193–244.
Larsen K. G., Petterson P., and Yi W., Compositional and symbolic model checking of real-time systems, In IEEE Real-Time Systems Symposium, 1995.
Larsen K. G., Petterson P., and Yi W., Model checking for real-time systems, In Fundamentals of Computation Theory, number 965 in Lecture Notes in Computer Science, 62–88, Springer- Verlag, 1995.
Milner R., A calculus of communicating systems, number 92 in Lecture Notes in Computer Science, Springer-Verlag, 1980.
Moller M. O., Rueb H., and Sorea M., Predicate abstraction for dense real-time systems, Electronic Notes in Theoretical Computer Science, 65 (2002).
Paige R., and Tarjan R., Three partition reﬁnement algorithms, SIAM Journal on Computing,
16(6) (1987).
Sokolsky O., and Smolka S. A., Local Model Checking for Real-Time Systems, In CAV’95, number 939 in LNCS, Springer-Verlag, 1995.
Spelberg R., Toetenel H., and Ammerlaan M., Partition reﬁnement in real-time model checking, In Formal Techniques in Real-Time and Fault-Tolerant Systems, number 1486 in Lecture Notes in Computer Science, Springer-Verlag, 1998.


Tripakis S., and Yovine S., Analysis of timed systems using time-abstracting bi-simulations, Formal Methods in System Design, 18 (2001) 25–68.
Yannakakis M., and Lee D., An efficient algorithm for minimizing real-time transition systems, In Computer Aided Verification, number 697 in Lecture Notes in Computer Science, 210–224, Springer-Verlag, 1993.
