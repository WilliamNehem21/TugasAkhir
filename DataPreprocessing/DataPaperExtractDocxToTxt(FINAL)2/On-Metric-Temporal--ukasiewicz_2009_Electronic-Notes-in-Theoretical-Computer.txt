

Electronic Notes in Theoretical Computer Science 246 (2009) 71–85
www.elsevier.com/locate/entcs

On Metric Temporal L~ ukasiewicz Logic

Tommaso Flaminio1 Elisa B. P. Tiezzi2
Department of Mathematics and Computer Science University of Siena
Siena, Italy


Abstract
In this paper we present a logical framework to cope with temporal reasoning under vagueness. The calculus is obtained by extending that of bounded metric temporal logic over a dense time domain, by truth-values from the rational unit interval [0, 1] ∩ Q, connectives and rules of the infinite-valued L- ukasiewicz logic. We show that the calculus is complete with respect to rational-valued Kripke frames, and as a consequence, we also show that the cut-rule is redundant.
Keywords: Metric temporal logic, L- ukasiewicz logic, sequent calculus, logical model.


Foreword
It is well known that (classical) mathematical logic was introduced as an attempt to develop axiomatic frameworks for various fields of mathematics.
More than a formal setting for the foundation of mathematics, a deduction system for mathematical logic provides an attempt to understand which are the
logical steps which must be followed to prove theorems 3 .
In this sense, the Gentzen style calculus for classical mathematical logic (i.e., a sound and complete set of logical rules, by which one can derive all the logical theo- rems) is the main ingredient for automated reasoning, and classical theorem proving. There are several important properties which a calculus should enjoy: among oth- ers we recall, completeness with respect to a suited semantics, cut-elimiation and (of course) a Curry-Howard style isomorphism. The latter, in particular, actually is the main requirement to translate proofs into objects of a well-formed (typed or

1 Email: flaminio@unisi.it
2 Email: tiezzie@unisi.it
3 We invite the reader to think about the usual interpretation of the cut-rule: firstly we prove a lemma, then we use that lemma to derive a new conclusion (theorem).

1571-0661 © 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.07.016

untyped) λ-style calculus. Needless to say that some of the above ideas (Church’s λ- calculus in particular), had a profound impact on the development of programming languages.
Let us now move from mathematics to the study of physical systems (like bio- logical eco-systems for instance), the question we may ask is the following: which are the logical rules which an expert (a biologist for instance) uses in order to either decide, or predict, if a given statement about the environment is (or will ever be) true? Before trying to give an answer, let us analyze the following situation: assume that the eco-system we are studying is a lagoon, and the problem we are interest in, is the growth of a particular seaweed during springtime. We want to predict how fast the growth will be, knowing that: (a) the last has been a warm winter,
(b) during last weeks it has been very rainy, and (c) a huge amount of fishes, which feed on seaweed, have died because of the the lack of oxygen in the lagoon.
Of course biologists are not interested in providing a precise answer, they might be satisfied in answering “the growth will be very slow” or even “probably there will be a slow growth”. Therefore, a logic able to handle vagueness must be one of the main ingredients to our purpose: as a matter of fact, we are not interested in defining a mathematical model for the lagoon, rather we are interested in providing a logical model for experts. In other words, we would know if there exists a logical framework in which a statement like “the growth will be very slow” is logically feasible (or even provable).
We can strengthen the above argumentation by observing that in physical sys- tems the temporal evolution plays a central role. This is highlighted by the fact that the violation of a constraint may bring the system to bad effects, which reflect to the environment where the system acts. This is the reason why the study of real-time systems, i.e. systems whose behavior depends on real-time constraints, has been strongly developed. In these systems it is necessary to describe the qualitative and the quantitative temporal constraints.
Summing up, in problems which involve physical systems we are sometimes asked to handle a kind of information which is vague, imprecise, and which involves a quantitative and qualitative evaluation of time. For this reason we must use a logical formalism which, in contrast to classical logic, is able to treat vagueness and temporal evolution: in other words we are interested in merging together fuzzy and real-time logic.
As an evidence of the fact that fuzzy logic is a powerful tool to handle vagueness, we want to recall the work carried out by Tron and Margaliot (cf. [13]) where the authors introduce a very elegant and faithful fuzzy model (no temporal evolution was involved) describing the territorial behavior of sticklebacks. The importance of the results described in [13] lies in the fact that the introduced model was formalized just by translating K. Lorenz’s linguistic description (and hence the linguistic predicates) of the phenomenon into a logical language able to handle vagueness. In this way the authors show how fuzzy modeling can be use to transform an expert’s linguistically stated observations and insights into a form amenable to mathematical analysis.
The aim of this paper is providing a logical calculus which could enable us to

answer the following question: referring to the previous example, which logical rules can be used to faithfully describe the deductions an expert performs in order to infer a statement of the form “during the next three weeks, the growth of seaweeds will be slow”?
In this paper we extend the Gentzen calculus for the real-time logic MTL∗ (cf. [11]) by truth-values from the unit interval [0, 1] ∩ Q, and rules describing the standard interpretation of the connectives of the infinite-values L- ukasiewicz logic (cf. [7], see also the footnote 4). The so extended calculus is able to capture the temporal evolution of vague phenomena which are expressed by formulas of L- u- kasiewicz logic. We show that the calculus is complete with respect to a class of Kripke-style models with a dense set of possible words. We show that the cut-rule is redundant for the calculus, whence our calculus is suitable to automated proof search.

More about the present paper
As we disclosed in the previous section, in this paper we shall introduce a Gentzen
style calculus for a logic obtained by extending the real-time logic MTL∗ with truth
constants from [0, 1] ∩ Q, and connectives of the infinite-valued L- ukasiewicz logic (L- in symbols). A complete discussion about L- ukasiewicz logic is out of the scope of

this paper, anyway we retain useful to explain why L- purposes.
is a suited framework for our

The language of L- ukasiewicz logic is made of a countable set of propositional variables {p1, p2,.. .}, the binary connective & for conjunction, the unary connective
~ for negation, and the truth constant ⊥ for falsity. Formulas are defined as usual. We refer the reader to [7] for a complete discussion about the axiomatization of the calculus. We also refer to [1,4] for a Gentzen calculus for L- . Many proof-methods have been introduced for theorem proving in L- ukasiewicz logic (we refer to [10] for a survey), and its connectives have been used as basis for fuzzy logic programming (cf. [8])
In the terminology of fuzzy logics (or t-norm based logics), L- is the logic capturing
all the tautologies of L- ukasiewicz t-norm. This means that if ϕ is an L- -formula, then
ϕ is a theorem of L- iff ϕ is evaluated into 1 by any valuation v which maps the
propositional variables pi into a real number in [0, 1], and connectives are interpreted by the stipulations:
v(ψ1&ψ2) = max{0, v(ψ1)+ v(ψ2) − 1}, and v(∼ψ) = 1 − v(ψ) 4 .
Notice that, if ϕ is any L- -formula, then the truth-table of ϕ is a function fϕ from the hypercube [0, 1]k into [0, 1] (k being the number of propositional variables occurring in ϕ). In other words, any formula of L- ukasiewicz language, defined by k variables, induces a fuzzy subset of the hypercube [0, 1]k (in Section 2.2 we shall better explain

4 These are the L- ukasiewicz t-norm and the L- ukasiewicz negation: & : [0, 1] × [0, 1] → [0, 1] is such that for all x, y ∈ [0, 1], &(x, y) = max{0,x + y − 1} (i.e. the standard interpretation of L- ukasiewicz conjunction), and ∼: [0, 1] → [0, 1] is such that for all x ∈ [0, 1], ∼ (x) = 1 − x (i.e. the standard interpretation of L- ukasiewicz negation).

this construction). Now, if P is a vague predicate (like “worm”, for instance), then, expressing P in a formal language, is equivalent to formally describe the fuzzy set f representing P , which in turn is equivalent to write a formula ϕ having f as a truth-table.
Finally, in order to handle time constraints, we shall use the modalities of MTL∗ applied to formulas of L- ukasiewicz logic. The language we shall introduce in the next section, contains a modality  ≤q for any rational number q. The language also contains a special symbol (H) which allow to label the modal formulas by time-points, and rational truth values: if r, s and q are rationals (and in particular s ∈ [0, 1] ∩ Q), and ϕ is a L- ukasiewicz formula, the intended meaning of the labeled formula (r, s) H  ≤qϕ is “in all the time-points between r and r + q, the truth-value of ϕ is at least s”. Therefore, our language suffices our purposes.
As a final remark notice that each modality  ≤q behaves as a quantifier acting on all the points of an interval of length q. The rules of our calculus will be written mixing syntax and semantics together.

The calculus and the canonical model
In this section we introduce the syntax and the semantics for our calculus. Let us start by introducing the syntax, then we consider semantics with a special attention to the class of canonical models.

The syntax
The language we need in order to treat our logical system contains:
The language of first order theory of ordered groups.  In particular we have a countable set of individual variables {x1, x2,.. .}, the unary function symbols
{Fq | q ∈ Q+}, representing the unary operation “adding q” (we shall occasionally
write x + q instead of Fq(x)) and the binary relational symbol ≤.
The language of L- ukasiewicz logic.
Countably many symbols for constants q1, q2,..., r1, r2,... representing the ele- ments of Q+.
For each q ∈ Q+, the unary modality  ≤q.
Auxiliary symbols: (, ), H.
The objects of our language are defined by means of the following clauses:
Metaterms are individual variables, symbols for the rationals, and if t is a metaterm, then Fq(t) is a metaterm for every q ∈ Q+. In other words:

⟨metaterm⟩ ::= xi | qi | ri | Fqi (⟨metaterm⟩).

Metaformulas are the formulas of the first order predicate logic in the language

{≤, q1,..., qn,..., Fq1 ,..., Fqn ,.. .}.

⟨metaformula⟩ ::= ⟨metaterm⟩| ⟨metaterm⟩≤ ⟨metaterm⟩| 
|	⟨metaformula⟩∧ ⟨metaformula⟩| 
|	¬⟨metaformula⟩| ∀xi⟨metaformula⟩
|	∃xi⟨metaformula⟩.

Any formula built up over the language {{p1, p2,.. .}, &, ∼, ⊥, { ≤q | q ∈ Q+}} is a formula.
⟨formula⟩ ::= ⊥| pi | ⟨formula⟩&⟨formula⟩| 
|	∼ ⟨formula⟩|  ≤qi ⟨formula⟩.
For any formula ϕ, and any pair of metaterms (t, s), (t, s) H ϕ is a labeled formula. The class of labeled formulas is then closed under & and ∼.
⟨labeled formula⟩ ::= (⟨metaterm⟩, ⟨metaterm⟩) H ⟨formula⟩| 
|	⟨labeled formula⟩&⟨labeled formula⟩| 
|	∼ ⟨labeled formula⟩.

We shall occasionally write (t, s) /H ϕ as an abbreviation for ∼ ((t, s) H ϕ).
Remark 2.1 We have distinguished between formulas and metaformulas to point out the difference between the formulas of the MTL language (these are the formu- las), and those needed to introduce the calculus (the metaformulas). The intuition which lies under this notation is the following: recall that the metaformulas are first order formulas in the language of ordered groups. These allow us to compare the time points (which in turn are expressed by metatems), and by them one can express the structure of the time involved (the following axioms (Q1) − (Q13) are metaformulas). Formulas are the formulas of L- ukasiewicz logic, and their modal extensions. These express the fact that a given property (namely a formula of L- u- kasiewicz logic), might be true for a time interval of a given length which is in turn expressed by the rational q appearing in  ≤q.
Our calculus is made of the following axioms and rules. The axioms reflect the structure of non-negative rational numbers (with abbreviations: x = y is (x ≤ y) ∧ (y ≤ x), and x < y is (x ≤ y) ∧ ¬(x = y)):
(Q1) p ≤ q for each pair of symbols (p, q) representing rationals p, q with p ≤Q q, where
≤Q denotes the usual order relation between rationals
(Q2) ¬(r ≤ s) for each pair of symbols (r, s) representing the rationals r, s with s < r 
(Q3) ∀x(Fq(Fr(x))) = Fq+r(x), for q, r ∈ Q+
(Q4) ∀x∀y(x = y → (((x, s) H p) → ((y, s) H p))), p being any propositional variable, and s being any metaterm.

(Q5) ∀x∀y(Fq(x) ≤ Fq(y) ↔ x ≤ y), for q ∈ Q+
(Q6) ∀x(Fq(x) ≤ Fr(x)), for q, r ∈ Q+, and q ≤Q r (Q7) ∀x(¬(Fq(x) ≤ Fr(x))), for q, r ∈ Q+, and q >Q r (Q8) ∀x(x ≤ x)
(Q9) ∀x∀y∀z((x ≤ y ∧ y ≤ z) → x ≤ z) (Q10) ∀x(0 ≤ x)
(Q11) F0(x) = x
(Q12) ∀x∀y(x ≤ y ∨ y ≤ x)
(Q13) ∀x∀y(x < y → ∃z((x < z) ∧ (z < y)))
Definition 2.2 (1) Q− denotes the theory whose language has the symbols {q | q ∈ Q+}∪ {Fq | q ∈ Q+}∪ {≤, P1,..., Pn,.. .}, where the Pi’s are unary function symbols, and whose axioms are (Q1) − (Q12).
(2) Q denotes the theory Q− plus the axiom (Q13)
A sequent is an expression of the form Γ ⇒ Δ, where Γ and Δ are sequences of
labeled formulas and metaformulas.
The calculus is defined by the axiom scheme Q and the following rules:
Identity Axiom:
ϕ ⇒ ϕ
ϕ being a metaformula or a labeled formula.
Rules on connectives and quantiﬁers: Conjunction:





Disjunction:
Γ ⇒ ϕ, Δ	Γ ⇒ ψ, Δ Γ ⇒ ϕ∧ψ, Δ
 Γ, ϕ ⇒ Δ  Γ, ϕ∧ψ ⇒ Δ
 Γ, ψ ⇒ Δ  Γ, ϕ∧ψ ⇒ Δ






Negation:
Γ, ϕ ⇒ Δ	Γ, ψ ⇒ Δ Γ, ϕ∨ψ ⇒ Δ
 Γ ⇒ ϕ, Δ  Γ ⇒ ϕ∨ψ, Δ
 Γ ⇒ ψ, Δ  Γ ⇒ ϕ∨ψ, Δ



Implication:
 Γ, ϕ ⇒ Δ  Γ ⇒ ¬ϕ, Δ
 Γ ⇒ ϕ, Δ  Γ, ¬ϕ ⇒ Δ



Quantifiers:
 Γ, ϕ ⇒ ψ, Δ Γ ⇒ ϕ→ψ, Δ
Γ ⇒ ψ, Δ	Γ, ϕ ⇒ Δ Γ, ϕ→ψ ⇒ Δ

Γ ⇒ ψ(y), Δ Γ ⇒ ∀xψ(x), Δ
Γ, ψ(t) ⇒ Δ Γ, ∀xψ(x) ⇒ Δ



Γ ⇒ ψ(t), Δ Γ ⇒ Exψ(x), Δ
Γ, ψ(x) ⇒ Δ Γ, Exψ(x) ⇒ Δ

Where y is a variable which does not occur free in the lower sequent, and t is a term free for x in ψ.
Structural Rules
Weakening:



Exchange:


Contraction:


Cut:
 Γ ⇒ Δ  Γ ⇒ ϕ, Δ

Γ ⇒ Δj, ϕ, ψ, Δjj Γ ⇒ Δj, ψ, ϕ, Δjj

Γ, ϕ, ϕ ⇒ Δ Γ, ϕ ⇒ Δ
 Γ ⇒ Δ  Γ, ϕ ⇒ Δ

Γj, ϕ, ψ, Γjj ⇒ Δ Γj, ψ, ϕ, Γjj ⇒ Δ

Γ ⇒ ϕ, ϕ, Δ Γ ⇒ ϕ, Δ

Γ ⇒ ϕ, Δ	Γ,ϕ ⇒ Δ Γ ⇒ Δ
Rules on L- ukasiewicz connectives
Strong Conjunction:
Γ ⇒ r ≤ t1 + t2 — 1, Δ Γ ⇒ (q, t1) H ϕ, Δ Γ ⇒ (q, t2) H ψ, Δ Γ ⇒ (q, r) H ϕ&ψ, Δ




Negation:





Modal rules





We call L- MTL∗
Γ,r ≤ y1 + y2 — 1, (q, y1) H ϕ, (q, y2) H ψ ⇒ Δ Γ, (q, r) H ϕ&ψ ⇒ Δ

Γ,s > 1 — r ⇒ (q, s) /H ϕ, Δ Γ ⇒ (q, r) H ~ϕ, Δ
Γ ⇒ s > 1 — r, Δ Γ, (q, s) /H ϕ ⇒ Δ Γ, (q, r) H ~ϕ ⇒ Δ

Γ,q ≤ x, x ≤ q + t ⇒ (x, r) H ϕ, Δ Γ ⇒ (q, r) H ≤tϕ, Δ
Γ ⇒ q ≤ a, Δ Γ ⇒ a ≤ q + t, Δ Γ, (a, r) H ϕ ⇒ Δ Γ, (q, r) H ≤tϕ ⇒ Δ
the calculus obtained by the above axioms and rules.

The definition of derivation tree is the usual one: a tree, where the vertices are sequents and, whenever a node k has children k1,..., kr, there is an instance of a rule with k1,..., kr as premises and k as conclusion. The leafs of the tree are initial sequents, that is, sequents of the form ϕ ⇒ ϕ.

Definition 2.3 A sequent Γ ⇒ Δ of modal formulas Γ = {γ0,..., γn} and Δ =
{δ0,..., δm} is provable in L- MTL∗ iff there exists a derivation tree for the sequent
{γ0,..., γn, ψ1,..., ψl}⇒ {δ0,..., δm},
where ψ1,..., ψl are axioms of Q−.
Following the above definition, a sequent Γ ⇒ Δ is provable iff there is a deriva- tion tree for Γ ⇒ Δ which only uses the axioms (Q1) — (Q12) and never uses (Q13). As a consequence of soundness theorem (Theorem 3.1), we shall prove that it is not a limitation.

Semantics
The canonical model for our calculus, is a pair (Q+, v) where v is an evaluation
associating, to each variable xi, an element of Q+, and to each propositional variable
pj a fuzzy subset of Q+ (i.e. a function fp : Q+ → [0, 1]), and mapping ⊥ into
the constantly zero function f⊥. The evaluation of propositional formulas can be extended to all formulas by the following stipulations:
v(ϕ&ψ) = max{0, v(ϕ) + v(ψ) — 1}. This means that v associates to ϕ&ψ the function fϕ&ψ, mapping every rational number r ∈ Q+ into max{0, fϕ(r)+fψ(r)— 1}.
v(~ϕ) = 1 — v(ϕ). Therefore, v(~ϕ) is the function f∼ϕ : r ∈ Q+ '→ 1 — fϕ(r) ∈
[0, 1].
v(  ≤qϕ) is
r+q
f ≤qϕ : r ∈ Q '→	fϕ(s),
s=r
where fϕ is v(ϕ).
Clearly each evaluation v can be extended to an evaluation from metaterms into
Q+, by the stipulations:
v(q) = q, for each q ∈ Q+,
v(Fq(t)) = q + v(t) (t being any metaterm).
If ϕ is a metaformula, then the definition of (Q+, v) |= ϕ is the Tarskian one 5 .
As for labeled formulas, we have the following inductive definition: let ψ be a
formula, and let (t, s) be a pair of metaterms. Then:
(Q+, v) |= (t, s) H pi iff fp (v(t)) ≥ s,
(Q+, v) |= (t, s) H (ϕ&ψ) iff max{0, fϕ(v(t)) + fψ(v(t)) — 1}≥ s,
(Q+, v) |= (t, s) H (~ψ) iff 1 — fϕ(v(t)) ≥ s,

5 Every metaformula is a first order formula in the predicate language of ordered groups. Therefore, (Q+, v) |= ϕ has the classical inductive meaning: if ϕ is a variable (say x), then (Q+, v) |= ϕ iff v(x) = 1), if ϕ = ψ ∧ γ, then (Q+, v) |= ϕ iff (Q+, v) |= ψ and (Q+, v) |= γ, if ϕ = ¬ψ, then (Q+, v) |= ϕ iff (Q+, v) |= ψ. Finally if ϕ = (∀x)ψ(x), then (Q+, v) |= ϕ iff (Q+, v) |= ψ', ψ' being any instance of ψ.

(Q+, v) |= (t, s) H ( ≤qϕ) iff f  ϕ(t) ≥ s. That is, if and only if


v(Fq (t))

r=v(t)

fϕ(v(r)) ≥ s.

Definition 2.4 Let (Q+, v) be a canonical model, and let Γ ⇒ Δ be a sequent. Then Γ ⇒ Δ is said to be valid in (Q+, v) iff v(γi) = 1 for every γi ∈ Γ, and v(δj) = 1 for at least a δj ∈ Δ. A sequent Γ ⇒ Δ is said to be valid if it is valid in every model (Q+, v).

Soundness and completeness
In [11] the authors prove that MTL∗ is sound and complete with respect to in-
terpretations in the canonical model (Q+, v). Thus in order to show that also our
calculus is sound and complete, we can just take care of the rules on L- ukasiewicz connectives, and the modal rules (which actually are slightly different from those in [11]).
As an example for soundness, let us show that the rule
Γ ⇒ r ≤ t1 + t2 — 1, Δ Γ ⇒ (q, t1) H ϕ, Δ Γ ⇒ (q, t2) H ψ, Δ Γ ⇒ (q, r) H ϕ&ψ, Δ
preserves the truth from top to bottom. Let us hence assume the following:
For every valuation v such that (Q+, v) |= Γ, then either v(r) ≤ v(t1)+ v(t2) — 1, or (Q+, v) |= τ (for some τ ∈ Δ).
For every valuation v such that (Q+, v) |= Γ, then either fϕ(v(q)) ≥ v(t1), or (Q+, v) |= τ (for some τ ∈ Δ).
For every valuation v such that (Q+, v) |= Γ, then either fψ(v(q)) ≥ v(t2), or (Q+, v) |= τ (for some τ ∈ Δ).
Let us now assume that v is an evaluation satisfying all the metaformulas and all the labeled formulas in Γ. Of course, if v satisfies a τ ∈ Δ, the claim trivially follows. Let us assume that no τ ∈ Δ is satisfied by v. Therefore, given that (Q+, v) |= Γ, from (i), (ii), and (iii) we know there are t1, t2 such that
r ≤ v(t1)+ v(t2) — 1, fϕ(v(q)) ≥ v(t1), and fψ(v(q)) ≥ v(t2)
respectively. Therefore, fϕ(v(q)) + fψ(v(q)) — 1 ≥ v(t1) + v(t2) — 1 ≥ r. Thus (Q+, v) |= (q, r) H ϕ&ψ as desired.
A similar argument can be used to show that all the rules of our calculus are sound. Thus the following holds:

Theorem 3.1 The calculus
L- MTL∗
is sound with respect to canonical models.

That is, if a sequent Γ ⇒ Δ is provable, then Γ ⇒ Δ is valid.
Before proving the completeness of L- MTL∗ , let us show what we claimed at the end of Section 2.1. We are going to show that we can do without the axiom (Q13).

Definition 3.2 By ◦ we denote the interpretation of L- MTL∗ into Q− defined by
the following steps:
For every propositional variable pi, (pi)◦ = Pi(w),
◦ commutes with classical connectives,
(ϕ&ψ)◦ := Ey1, y2((v ≤ y1 + y2 — 1) ∧ (ϕ◦(w) ≥ y1) ∧ (ψ◦(w) ≥ y2))
(~ϕ)◦ := Ey((y > 1 — v) → (ϕ◦(w) < y)),
( ≤qϕ)◦ := ∀x(w ≤ x ≤ Fq(w) → (ϕ◦(w) ≥ v))
For labeled formulas, ((t, s) H ϕ)◦ := ϕ◦(w/t, v/s).
If Γ ⇒ Δ is a sequent, we define Γ◦ ⇒ Δ◦ as that sequent obtained by replacing all labeled formulas (q, s) H ϕ by ((q, s) H ϕ)◦

Lemma 3.3 Let Φ be a modal formula. If Q /▶ Φ◦(0), then Q− /▶ Φ◦(0).

Proof. See [11, Lemma 1].	 

Theorem 3.4 Let Γ ⇒ Δ be a sequent. If Γ ⇒ Δ is valid, then Γ ⇒ Δ is provable

Proof. (Sketch): The strategy of the proof is similar to the one of [11, Theorem 6]. We recall the main steps, and point out the differences.
Let Γ ⇒ Δ be a sequent, and let Γ◦ ⇒ Δ◦ be as in Definition 3.2. We define the reduction tree of Γ◦ ⇒ Δ◦ as follows:
0: At step 0, Γ◦ ⇒ Δ◦ is the root and the (unique) leaf of the tree.
n + 1: At step n + 1 consider all the leafs of the tree built up to step n (call this the n-tree) and:
If all the leafs Γi ⇒ Δi of the n-tree are such that Γi ∩ Δi /= ∅, then Γ ⇒ Δ is provable.
If otherwise, consider all the leafs Γi ⇒ Δi such that Γi ∩ Δi = ∅.
If there are leafs Γi ⇒ Δi as in (b), our reduction of Γi ⇒ Δi consists in labeling the formulas belonging to Γi (if the step n + 1 is even) and those of Δi (if the step n + 1 is odd), by the following stipulation: let ψ1, ψ2,... be a enumeration of the instances of the axioms of Q−. Then we firstly add to Γi the axiom ψj, j being the smallest index such that ψj /∈ Γi. Now, if n + 1 is even, then we consider the first not-labeled compound formula of Γi (where “first” means with respect to the order defined reading the set Γi from left to right. Also notice that, Γi contains at least ψj as compound formula). If n + 1 is odd, then we consider the first not- labeled compound formula of Δi (where again “first” means with respect to the order left-to-right).
Now the reduction on the chosen formula works as in the case of classical pred- icate logic noticing that the rules on L- ukasiewicz connectives and the modal rules can be rewritten as in Definition 3.2. In particular, whenever we act on a formula of the form ((q, s) H  ≤tϕ)◦ in Γi ⇒ Δi, and Γi = Γ', ((q, s) H  ≤tϕ)◦, then we

extend the tree by:

Γi ⇒ Δi,q ≤ a	Γi ⇒ Δi,a ≤ q + t	Γ, (a, s) H ϕ◦ ⇒ Δi Γi ⇒ Δi
where a is the first term in lexicographic order such that either q ≤ a /∈ Δi, or
a ≤ q + t /∈ Δi, or (a, s) H ϕ◦ /∈ Γi.
If otherwise Δi is Δ', ((q, s) H  ≤tϕ)◦, we extend the tree by:

Γi,q ≤ x, x ≤ q + t ⇒ Δi, (x, s) H ϕ◦
Γi ⇒ Δi
where x is a fresh variable.
If we meet a labeled formula ((q, s) H (ϕ&ψ))◦ in Γi (that is if Γi ⇒ Δi is Γ', ((q, s) H (ϕ&ψ))◦ ⇒ Δi) or in Δi, then we extend the reduction tree just by recalling that ((q, s) H ϕ&ψ)◦ stands for Ey1, y2((s ≤ y1 + y2 — 1) Λ ((q, y1) H ϕ◦) Λ (q, y2) H ψ◦).
Analogously whenever me meet a labeled formula like ((q, s) H ~ϕ)◦ (either in the left side or in the right side of the sequent), the we extend the reduction tree by recalling that ((q, s) H ~ϕ)◦ stands for Ey((y > 1 — r) → (q, y) /H ϕ◦).
As in the case of classical predicate logic, if for each leaf Γi ⇒ Δi one has Γi ∩ Δi /= ∅ at some step, then we can easily obtain a cut-free proof of Γ◦ ⇒ Δ◦ by replacing each ((q, s) H Φ)◦ by (q, s) H Φ.
Otherwise the reduction tree is infinite (and hence the sequent Γ ⇒ Δ is not provable). By Ko¨nig Lemma, the tree contains an infinite path.
Let Γ ⇒ Δ be not provable, and let π = Γ◦ ⇒ Δ◦, Γ1 ⇒ Δ2,... an infinite path
along its reduction tree. Put
Γ∗ = Γ◦ ∪  i∈N Γi , and Δ∗ = Δ◦ ∪  i∈N Δi .
Now define ł = (M, ≤M , v) as follows:
M is the quotient of the set of all closed terms, modulo the equivalence relation
R so defined:
R(r, s) iff t = s ∈ Γ∗
We define ≤M on ł by stipulating that
ł |= [t]R ≤ [s]R iff t ≤ s ∈ Γ∗.
For every variable xi, v(xi) is an element of M , and for every propositional variable pj, v(pj) is the function f M : M → [0, 1]. Moreover v(⊥) = f M : m ∈
pj	⊥
ł '→ 0 ∈ [0, 1].
ł is a countermodel to Q− ∪ Γ◦(0) ⇒ Δ◦(0). Therefore, ł |= Q− and ł |=
  Γ◦ →  Δ◦.  By Lemma 3.3 we can assume without loss of generality, that
ł |= Q.
As done in [11], one can show that (M, ≤M ) is isomorphic to (Q+, ≤) via a map
f . Thus (Q+, ≤,f ◦ v) is a canonical coutermodel of Γ ⇒ Δ.	 

A direct consequence of the previous proof is the following:
Corollary 3.5 The cut rule is redundant in L- MTL∗ .

Doing without first order
Our calculus L- MTL∗ , more than the usual logical and structural rules of classical predicate logic, is made of the axiom schemata (Q1) — (Q12), and the rules for the modalities and L- ukasiewicz connectives. The latter ones have been easily obtained by a previous translation of the labeled formula in the language of Q−, and then by applying the classical rules on quantifiers. This means that predicate logic only occurs in introducing the axioms of Q−. Now all the axioms of Q− are universal, that is they are all of the form ∀→xϕ(→x) and ϕ(→x) is quantifier-free.
By instantiated axiom we mean the formula ϕ(→a), where ∀→xϕ(→x) is an axiom, and →a are terms.
Definition 4.1 L- MTL∗ − denotes the calculus obtained by omitting the rules for

quantifiers, and considering instantiated axioms.
As in [11], and given that the calculus L- MTL∗

enjoys cut-elimination, if Q− ▶ Φ

(Φ being a modal formula), there is a Γ ⊆ Q− such that the sequent Γ ⇒ Φ
is provable. In a cut-free proof of Γ ⇒ Φ either occur quantifier-free formulas, or universal formulas. In particular, the latter ones occur only on the left side. Therefore, all the formulas occurring in the initial sequents are quantifier-free (in fact if a universal formula appears in a initial sequent, it should also appear on the right side!). In modal rules, and in the rules for L- ukasiewicz connectives, universal formulas do not appear as main formula, and hence they do not play any role in deducing Φ. Therefore, if we ignore the rules of left-weakening, and left-∀, we easily obtain a proof of Φ from instantiated axioms, and without using rules on quantifiers. Then the following holds:
Lemma 4.2 If the sequent Γ ⇒ Δ is provable in L- MTL∗ , then there is a deduction tree (and hence a proof) in L- MTL∗ − of a sequent Γ ∪ Γ− ⇒ Δ, where Γ' is a ﬁnite sequence of instances of axioms of Q−.
In [11] the authors show that MTL∗ is equivalent to a calculus defined without
the apparatus of first order logic. The idea is to replace every axiom of Q− by one
or two rules in natural deduction. These are:

(R1) Γ,p ≤ q ⇒ Δ with p ≤
Γ ⇒ p ≤ q, Δ
q,	(R2)	with p >  q.


	
Γ ⇒ Δ	Q	Γ ⇒ Δ	Q



(R3) Γ, Fq(Fr(t)) ≤ Fq+r(t) ⇒ Δ
Γ ⇒ Δ
(R3') Γ, Fq(Fr(t)) ≥ Fq+r(t) ⇒ Δ
Γ ⇒ Δ


(R4) Γ1 ⇒ t ≤ s, Δ1	Γ2 ⇒ s ≤ t, Δ2	Γ3 ⇒ (t, r) H p, Δ3	Γ4, (s, r) H p ⇒ Δ4
Γ1, Γ2, Γ3, Γ4 ⇒ Δ1, Δ2, Δ3, Δ4
for every propositional variable p, and any metaterm r.
(R5) Γ, t ≤ s ⇒ Δ	Γ1 ⇒ Fq(t) ≤ Fq(s), Δ1
Γ, Γ1 ⇒ Δ, Δ1
(R6) Γ ⇒ t ≤ s, Δ	Γ1, Fq(t) ≤ Fq(s) ⇒ Δ1
Γ, Γ1 ⇒ Δ, Δ1


(R6) Γ, Fq(t) ≤ Fr(t) ⇒ Δ with q ≤
Γ ⇒ Fq(t) ≤ Fr(t), Δ
r	R	r <  q.

Γ ⇒ Δ
Q	Γ ⇒ Δ	Q



(R8) Γ,t ≤ t ⇒ Δ
Γ ⇒ Δ
(R9) Γ ⇒ t ≤ s, Δ	Γ1 ⇒ s ≤ r, Δ1	Γ2,t ≤ r ⇒ Δ2
Γ, Γ1, Γ2 ⇒ Δ, Δ1, Δ2



(R10) Γ, 0 ≤ t ⇒ Δ
Γ ⇒ Δ
(R11) Γ, F0(t) ≤ t ⇒ Δ
Γ ⇒ Δ

(R11') Γ, t ≤ F0(t) ⇒ Δ
Γ ⇒ Δ
(R12) Γ, t ≤ s ⇒ Δ	Γ1, s ≤ t ⇒ Δ1 .
Γ, Γ1 ⇒ Δ, Δ1

Clearly the rule (Ri) corresponds to the axiom (Qi).
Call L- MTL∗ 2 the proof system whose rules are those of L- MTL∗

for quantifier-

Q	Q
free formulas, the rules on modalities and L- ukasiewicz connectives of L- MTL∗ , and
the rules (R1) — (R12).
Theorem 4.3 Let Γ ⇒ Δ be a provable sequent in L- MTL∗ − and let Γ' ⊆ Γ such that every Φ ∈ Γ\Γ' is an instantiated axiom. Then Γ' ⇒ Δ is provable in L- MTL∗ 2.
Proof. With respect to the proof given in [11], the only necessary modification regards axiom (Q4) and rule (R4). The proof is done by induction on the size n of Γ \ Γ'.
Assume that r is any metaterm, Φ is t = s → ((t, r) H p → (s, r) H p), p being a propositional variable, and t = s → ((t, r) H p → (s, r) H p) /∈ Γ'. Since Γ ⇒ Δ is provable in L- MTL∗ −, then Γ'' ⇒ Δ,t ≤ s, Γ'' ⇒ s ≤ t, Δ, Γ'' ⇒ (s, r) H p, and Γ'', (t, r) H p ⇒ Δ are provable by Γ ⇒ Δ. For instance:
(s, r) H p ⇒ (s, r) H p is an instance of the identity axiom,
(t, r) H p, (s, r) H p ⇒ (s, r) H p is obtained by (1) and left-weakening,
(s, r) H p ⇒ (t, r) H p → (s, r) H p is the obtained by applying the rule of left-implication,
t = s, (s, r) H p ⇒ (t, r) H p → (s, r) H p derives by left-weakening,

(s, r) H p ⇒ (t = s) → ((t, r) H p → (s, r) H p) is obtained by applying the rule of left-weakening. Finally
Γ'', (s, r) H p ⇒ Δ is obtained by an application of the cut rule between (5) and Γ'', (t = s) → ((t, r) H p → (s, r) H p) ⇒ Δ.
All the sequents Γ'' ⇒ Δ,t ≤ s, Γ'' ⇒ s ≤ t, Δ, Γ'' ⇒ (s, r) H p, and Γ'', (t, r) H p ⇒ Δ satisfy the inductive hypothesis. Then they are provable in L- MTL∗ 2. We hence get the claim just applying the rule (R4).	 
Corollary 4.4 The proof systems L- MTL∗ and L- MTL∗ 2 are equivalent.

Future development and applications
In the last years many authors have studied the application of fuzzy logic and metric temporal logic to logic programming. We refer the reader to [5,10] for fuzzy logic programming, and to [2,3] for metric temporal logic programming.
In our future work we plan to make a step further in the direction of introducing a logic programming able to capture vagueness and temporal evolution. This idea is not new, and it has been applied in interesting cases (see [6]) showing that the two formalisms can be successfully merged together, but, as far as we know, no logical calculus has been given yet.
Clearly the biological setting still remains our main inspiration, and we believe it could be approached in different interesting ways:
Fuzzy Timed Automata Theory: these are models which can be easily applied to the description and verification of systems (as biological ones, for instance): if we have to check if a system is correct (or even which is the degree of correctness of the system) with respect to a desired behavior, then we should ask up to which degree the automata (intended to model such a system) satisfies a formula describing that behavior (where of course vagueness and time are involved).
It would be also interesting to apply our logic L- MTL∗ to model biological systems
by using Rewriting Logic and Petri nets, as it has been already done by Talcott et al (cf. [12]).
We also plan to improve the present calculus by adding probabilistic evaluations of vague sentences, and vagueness of time. The main goal in this direction is to define a logical calculus where probabilistic evaluation of vague time of vague properties can be treated as for instance “probably, all the seaweeds will grow fast in a few days”).


Acknowledgement
The authors feel deeply indebted to Franco Montagna for his precious suggestions and the stimulating discussions about the topic treated in this paper.

References
Aguzzoli S., Ciabattoni A., Finiteness in Infinite-Valued L- ukasiewicz Logic, Journal of Logic, Language and Information,9, pp. 5–29, 2000
Brzoska C., Temporal logic programming with metric and past operators. Lecture Notes in Computer Science, Executable Modal and Temporal Logics, 897, pp. 21–39, 1995.
Brzoska C., Programming in metric temporal logic. Theoretical Computer Science, 202, issue 1-2, pp. 55–125, 1998.
Ciabattoni A., Fermu¨ller C. G., Metcalfe G, Uniform Rules and Dialogue Games for Fuzzy Logics. In Proceedings of Logic for Programming, Artificial Intelligence, and Reasoning, 11th International Conference, LPAR 2004 pp. 496–510, 2004.
Ebrahim R., Fuzzy logic programming, Fuzzy Sets and Systems, 117, pp. 215–230, 2001.
Haag M., Theilmann W., Sch¨afer K., Nagel H. H., Integration of image sequence evaluation and fuzzy Metric Temporal Logic programming. Lecture Notes in Computer Science, Annual German Conference on Artificial Intelligence, 1303, pp. 301–312, 1997.
H´ajek P., Metamathematic of Fuzzy Logics, Kluwer, 1998.
Klawonn F., Kruse R., A L- ukasiewicz logic based Prolog. Mathware & Soft Computing, 1, pp. 5–29, 1994.
Koymans, R., Vytopil J., De Roever W. P., Real-time programming and asynchronous message passing.
In Proceedings of the 2nd Annual Symposium on Principles of Distributed Computing, ACM Press, New York 1983, pp. 187–198.
Metcalfe G. Olivetti N, Gabbay D., L- ukasiewicz Logic: From Proof Systems To Logic Programming. Logic Journal of IGPL, 13, pp. 561–585, 2005.
Montagna F., Pinna G. M., Tiezzi E. B. P. A Cut-free Proof System for Bounded Metric Temporal Logic over a Dense Time Domain. Math. Log. Quart. 46, 2, pp. 171–182, 2000.
Talcott L. C., Dill D. L., Multiple Representations of Biological Processes. Lecture Notes in Computer Science, Transactions on Computational Systems Biology VI, 4220, pp. 221–245, 2006.
Tron E., Margaliot M., Mathematical modeling of observed natural behavior: a fuzzy logical approach. Fuzzy Sets and Systems, 146, pp. 437–450, 2004.
