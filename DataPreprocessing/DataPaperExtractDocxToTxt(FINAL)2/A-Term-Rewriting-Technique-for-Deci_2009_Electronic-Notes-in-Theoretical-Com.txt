

Electronic Notes in Theoretical Computer Science 253 (2009) 39–54
www.elsevier.com/locate/entcs

A Term Rewriting Technique for Decision Graphs
Bahareh Badban1
Department of Software Engineering University of Konstanz
Germany

Abstract
We provide an automatic verification for a fragment of FOL quantifier-free logic with zero, successor and equality. We use BDD representation of such formulas and to verify them, we first introduce a (complete) term rewrite system to generate an equivalent Ordered (0, S, =)-BDD from any given (0, S, =)-BDD. Having the ordered representation of the BDDs, one can verify the original formula in constant time. Then, to have this transformation automatically, we provide an algorithm which will do the whole process.
Keywords: Term Rewrite System; First-Order Logic; Decision Procedure; Verification


Introduction
In this article we consider the satisfiability and tautology problem for boolean com- binations over the equational theory of zero and successor in the natural numbers. The atoms are equations between terms built from variables, zero (0) and succes- sor (S). Formulas are built from atoms by means of negation (¬) and conjunction (∧). The formulas are quantifier-free, except for the implicit outermost quantifier (∀ when considering tautology checking, and ∃ when considering satisfiability).
In general, the decision problem for plain equational theories is unsolvable al- ready, so we must restrict to particular theories. The decision problem for boolean combinations over equational theories can be approached in several ways. Binary Decision Diagrams (BDDs) represent boolean functions as directed acyclic graphs [5]. They are of value for validating formulas in propositional logic. In [5] OB- DDs (Ordered BDDs) are reduced BDDs which accept some ordering on boolean variables. A boolean function is satisfiable if and only if its unique OBDD repre- sentation does not correspond to 0. In the BDD-method, a formula is transformed

1 Email: badban@inf.uni-konstanz.de

1571-0661© 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.10.016

to a propositionally equivalent Ordered Binary Decision Diagram (OBDD) which can be seen as a large if-then-else (ITE) tree with shared subterms (see Section 2). Although in principle also OBDD representations are exponentially big, it appears that in practice many formulas have a succinct OBDD-representation. Further- more, boolean operations, such as negation and conjunction, can be computed on OBDDs very cheaply. Together with the fact that (due to sharing) many practical boolean functions have a small OBDD representation, OBDDs are very popular in verification of hardware design, and play a major role in symbolic model checking. In order to solve the satisfiability or tautology problem, each path in the OBDD has to be checked for consistency, with respect to the underlying equational theory. A path represents a conjunction of (negated) equations, on which the aforemen- tioned decision procedures can be applied. All inconsistent paths can be removed, resulting in an OBDD with only consistent paths. However, due to sharing sub- terms, an OBDD can have exponentially many paths, so still there is a compu- tational bottleneck. In the Encoding method these steps are reversed. First the formula is transformed to a purely propositional formula. In this translation, facts from the equational theory (e.g. congruence of functions, transitivity of equality and orderings) are encoded into the formula. Then a ﬁnite model property is used to obtain a finite upperbound on the cardinality of the model. Finally, variables that range over a set of size n are encoded by log(n) propositional variables. The result- ing formula can be checked for satisfiability with any existing SAT-technique, for instance based on resolution [7] or on BDDs [5]. An early example is Ackermann’s reduction [1], by which second order variables can be eliminated. More optimal
versions are in [10,17,6].
To date, several methods have been proposed to reduce different logics into propositional logic, which captures boolean functions. Goel et al. [10] and Bryant et al. [6]. present methods to transform the logic of Equality with Uninterpreted Functions (EUF) into propositional logic. In [18] the theory of separation predi- cates is reduced to propositional logic. In [16] the EUF extended with constrained lambda expressions, ordering, and successor and predecessor functions, is translated to propositional logic. The idea of extending the theory of BDDs was recognized earlier by Groote and van de Pol [11], who presented an algorithm to transform EQ-BDDs to EQ-OBDDs, where EQ-BDDs represent the extension of BDDs with equalities. We extend the method for EQ-BDDs from [11] to a fragment of quanti- fier free logic FOL. We make a terminating set of rewrite rules on (0, S, =)-BDDs, resulting in a (0, S, =)-R-OBDD, such that all paths in the (0, S, =)-R-OBDD are satisfiable. This property enables us to check tautology, contradiction and satisfia- bility on (0, S, =)-R-OBDDs in constant time. At the end we present an algorithm through which any formula of the logic above is translated to an (0, S, =)-R-OBDD.

We define the set of terms as the closure of V¯
= V ∪ {0} (union of the sets

of variables and zero) under successor. To be able to have an ordering on BDDs, we will need to define an ordering on terms of the logic. What is the appropriate ordering on terms? The answer, unfortunately, is not obvious. In [2] Chapter 3, two orderings which resulted in failed attempts are explained. One of them does



Figure 1. ITE (p, T, ITE (q, T, ⊥)). Solid lines denote the left branch of the ITE (when their corresponding guard holds) and dashed lines represents their counterpart.
not provide termination, and the other does not omit all unsatisfiable paths.
The approach introduced here is in a sence a variant of [3], though our new ordering yields some simpler representation of the terms in the proof settings. Be- sides, it provides an alternative technique for the OBDD transformation. This, as a result can offer a different method for possible extensions of the background logic (notice that as mentioned above, finding the right order is not easy, and this prob- lem would remain for bigger theories as well). In the current work, substitution rules are certainly different than those of the previous work. In addition, we also introduce an automatic way for transforming any formula (in our FOL fragment) into some Ordered BDD. We do this by means of a so called sort algorithm.
Road map. In Section 2, we describe BDDs, and give a formal syntax and semantics of (0, S, =)-BDDs. In Section 3 our transformation is presented, leading to the set of (0, S, =)-R-OBDDs. First a total and well-founded order on variables is assumed, and extended to a total well-founded order on equalities. Then the rewrite system is presented. Finally, we prove termination and satisfiability over all paths. Section 4 presents an algorithm with the same result as the given term rewrite system. Finally, Section 5 concludes with some remarks on implementation and possible applications.

Binary Decision Diagrams
A binary decision diagram [5] (BDD) represents a boolean function as a finite, rooted, binary, ordered, directed acyclic graph. The leaves of this graph are labeled
⊥ and T, and all internal nodes are labeled with boolean variables. A node with label p, left child L and right child R, written ITE(p, L, R), represents the formula if p then L else R.
Given a fixed total order on the propositional variables, a BDD can be trans- formed to an Ordered binary decision diagram (OBDD), in which the propositions along all paths occur in increasing order, redundant tests (ITE (p, x, x)) don’t oc- cur, and the graph is maximally shared. For a fixed order, each boolean function is represented by a unique reduced OBDD (in the sequel we simply use OBDD to denote a reduced OBDD). For more information on that, one can see [5].
Example 2.1 Figure 1 illustrates a BDD representation of the following formula:
ITE (p, T, ITE (q, T, ⊥)) where p and q are propositional variables.

BDDs with Equality, Zero and Successor
In this section we introduce some basic notations and definitions. We also provide the syntax and semantics of BDDs extended with zero, successor and equality. For our purpose, the sharing information present in the graph is immaterial, so we formalize BDDs by terms (i.e. trees). We show that every formula is representable as a BDD.

We assume V is a set of variables, and define V¯
formulas, guards and BDDs are defined below:
= V ∪ {0}. Sets of terms,

Definition 2.2 Terms t ∈ W , formulas ϕ ∈ Φ, guards g ∈ G and (0, S, =)-BDDs
T ∈ B are defined by the following grammar (with x ∈ V ):
t ::= 0 | x | S(t)
ϕ ::= ⊥ | T | t = t | чϕ | ϕ Λ ϕ | ITE (ϕ, ϕ, ϕ) g ::= ⊥ | T | t = t
T ::= ⊥ | T | ITE (g, T, T )
A guard is trivial if it is ⊥ or T, and otherwise it is non-trivial. Here are some notations that we will use in this paper: In order to avoid confusion with the =- symbol in guards, we use ≡ to identify syntactic equality between terms or formulas. Symbols x, y, z, u,... denote variables; r, s, t,... range over W ; ϕ, ψ,... range over Φ; f, g,... range over guards. Var(t) represents the variable occurring in term t. Furthermore, we will write x /= y instead of ч(x = y) and Sm(t) for the m-fold application of S to t, so S0(t) ≡ t and Sm+1(t) ≡ S(Sm(t)). Note that each t ∈ W
is of the form Sm(u), for some m ∈ N and u ∈ V¯ .
We will use some fixed interpretation for the above formulas: Terms are inter- preted over the natural numbers (N) and for formulas we use the classical interpre- tation over {0, 1}. Given a valuation v : V → N, we extend v homomorphically to terms and formulas as:
v(0) = 0
v(S(t)) = 1 + v(t)
v(⊥) = 0 
v(T) = 1 
v(s = t) = 1, if v(s)= v(t), 0, otherwise.
v(чϕ) = 1 — v(ϕ)
v(ϕ Λ ψ) = min(v(ϕ), v(ψ))
v(ITE (ϕ, ψ, χ)) = v(ψ) if v(ϕ)= 1, v(χ) otherwise.
It is trivial that the value of a formula under any valuation function is either 0 or

1.
Given a formula ϕ, we say it is satisﬁable if there exists a valuation v : V → N
such that v(ϕ) = 1; it is a contradiction otherwise. If for all v : V → N, v(ϕ)= 1, then ϕ is a tautology. Finally, if v(ϕ) = v(ψ) for all valuations v : V → N, then ϕ and ψ are called equivalent. v satisfies ϕ (or equivalently ϕ holds under v) is denoted as: v |= ϕ.
Lemma 2.3 Every formula in Φ is equivalent to at least one (0, S, =)-BDD.

Representant-Ordered (0, S, =)-BDDs
The first step to make a BDD ordered, is to simplify all its guards, in isolation. Here, simplification on guards will be done by Definition 3.2. In Section 3.1 we present a new order on terms. In Definition 3.8 we define an ordering on guards. Notice that these definitions are different from those of [3]. Thereafter, we will introduce a term rewrite system. Using this system we simplify BDDs to their most reduced form, denoted as (0, S, =)-R-OBDD.
Deﬁnition of (0, S, =)-R-OBDDs
We consider a fixed total and well-founded ordering on V . Below we assume that the variables x, y and z are ordered as x ≺ y ≺ z.
Definition 3.1 [ordering definition] We extend ≺ to a total order on W :
0 ≺ u for each element u of V
Sm(x) ≺ Sn(y) if and only if x ≺ y or (x ≡ y and m < n)  for each two elements
x, y ∈ V¯
As of now, we may use the term OBDD instead of (0, S, =)-R-OBDD, for simplicity.
Definition 3.2 Suppose g is a guard.  By g ↓ we mean the normal form of g
obtained after applying the following rewrite rules on it:
x = x → T 
S(x)= S(y) → x = y
0= S(x) → ⊥ 
x = Sm+1(x) → ⊥	for all m ∈ N
t = r → r = t for all r, t ∈ W such that r ≺ t.
We call g simplified if it cannot be further simplified, i.e. g ≡ g ↓. A (0, S, =)-BDD
T is called simplified if all guards in it are simplified.
Lemma 3.3 If g ∈ G is simpliﬁed to g' using Deﬁnition 3.2, then g and g' are equivalent.

Next lemma shows possible shapes of a simplified guard. In contrast to [3] the smaller term sits on the left.
Lemma 3.4 If g is a simpliﬁed guard, then it has one of the following shapes:
Sm(0) = x	for some x ∈ V
Sm(x)= Sn(y)	for some x, y ∈ V, x ≺ y, m =0 or n =0 
T or ⊥
It is worth mentioning that as a result each guard has only one simplified form.
In order to be able to substitute one term by another, we may often need to up- raise the atom which includes the term by applying some few additional successors, and then to do the replacement. Below, we explain our strategy for doing this:
Definition 3.5 Let m ∈ N. For terms r, t ∈ W , a variable y ∈ V and a guard
g ∈ G we define:
(r = t)↑m:= Sm(r)= Sm(t)	(lifting)
Definition 3.6 Suppose g is a simplified non-trivial guard, y ∈ V and t, r ∈ W . We define:


g|r=Sm(y) :=
(g↑m [Sm(y) := r]) ↓	if y occurs in g g	otherwise


g|t/=r
:=	⊥	if g ≡ (t = r) ↓
g	otherwise

The following lemma shows the soundness of the operations above:
Lemma 3.7 For any guard g and a positive natural number m, g ↑m and g are equivalent terms. Moreover, for a guard f, if v |= f for some valuation v then v(g)= v(g|f ).
To have ordered BDDs, we need to impose some order on simplified guards. Below is what we use as the ultimate order on such guards:
Definition 3.8 [order] We define a total order ≺ on simplified guards as:
⊥≺T≺ g, for all simplified guards g different from T, ⊥.
(Sp(x)= Sq(y)) ≺ (Sm(u)= Sn(v)) iff:
x ≺ u or
x ≡ u, p < m or
x ≡ u, p ≡ m , y ≺ v or
x ≡ u, p ≡ m, y ≡ v, q < n
According to this definition (r1 = t1) ≺ (r2 = t2) iff (r1, t1) ≺lex (r2, t2), in which ≺lex is a lexicographic order on quadruples of the total, well-founded orders (V¯ , ≺) × (N, <) × (V¯ , ≺) × (N, <), and therefore it is well-founded and total. This

way without getting into the structures of the involved terms, only by knowing the order between them, one could determine the order of the guards.
Now we can build the term rewrite system, which will be applied on (0, S, =)- BDDs and will generate an ordered version of them.
Definition 3.9 [(0, S, =)-R-OBDD] An (0, S, =)-R-OBDD (Representant-Ordered (0, S, =)-BDD) is a simplified (0, S, =)-BDD (i.e. all its guards are simplified) which is a normal form with respect to the following term rewrite system:
ITE(T, T1, T2) → T1
ITE(⊥, T1, T2) → T2
ITE(g, T, T ) → T
ITE(g, ITE(g, T1, T2), T3) → ITE(g, T1, T3)
ITE(g, T1,ITE(g, T2, T3)) → ITE(g, T1, T3)
ITE(g1,ITE(g2, T1, T2), T3) → ITE(g2,ITE(g1, T1, T3),ITE(g1, T2, T3)) if g1 >
g2
ITE(g1, T1,ITE(g2, T2, T3)) → ITE(g2,ITE(g1, T1, T2),ITE(g1, T1, T3)) if g1 >
g2
for every simpliﬁed (0, S, =)-BDD C, if y occurs in g and Sn(x)= Sm(y) < g
then:
ITE(Sn(x)= Sm(y), C[g],T ) → ITE(Sn(x)= Sm(y), C[ g|Sn(x)=Sm(y)],T )
In the viiith rule, one of m or n must be 0, since according to the assumption
Sn(x)= Sm(y) is a simplified guard (Lemma 3.4).
Obviously the result of applying any rule (of Definition 3.9) on a simplified BDD is a simplified BDD. The BDD which can no longer be simplified is called of normal form. In the sequel we show that each BDD has a normal form. The next lemma in immediate from this definition:
Lemma 3.10 Suppose T ∈ B is a (0, S, =)-BDD which becomes T ' after applying any arbitrary rule of Deﬁnition 3.9 on it. Then T and T ' are equivalent. As a result each (0, S, =)-BDD is equivalent with any of its normal forms.
Example 3.11 Let x < y < z. Below we present our simplification technique over
ITE(S(y)= z, ITE(x = S2(y), T, ⊥), ⊥) (Figure 2).
ITE(S(y)= z, ITE(x = S2(y), T, ⊥), ⊥)
→6	ITE(x = S2(y),ITE(S(y)= z, T, ⊥),ITE(S(y)= z, ⊥, ⊥))
3	2
→	ITE(x = S (y),ITE(S(y)= z, T, ⊥), ⊥)

→	ITE(x = S
2(y),ITE({S3
(y) = S
2(z)[S2
:= x]} ↓, T, ⊥), ⊥)

substitution
≡	ITE(x = S
2(y),ITE({S(x)= S
2(z)} ↓, T, ⊥), ⊥)

≡	ITE(x = S2(y),ITE(x = S(z), T, ⊥), ⊥)




6	3	8

m =2 
G(y) ≡ S(y)=z








x=S2 (y)



S3 (y)=S2 (z)[S2 (y):=x] ↓	=	=






T	⊥
Figure 2. Derivation in Example 3.11
Termination
To show that our system is terminating we first prove some properties on <.
Lemma 3.12 Let f ≡ Sn(x) = Sm(y) and g ≡ Sk(v) = Sl(w). If f < g and
f ≡ f ↓ and g ≡ g ↓ and y ∈ {v, w}, then g|f < g.
Definition 3.13 [recursive path order for BDDs] Let S and T be simplified BDDs.
Then S ≡ f (S1, S2) >rpo g(T1, T2) ≡ T if and only if
S1 ≥rpo T or S2 ≥rpo T ; or
f > g and S >rpo T1, T2; or
f ≡ g and S >rpo T1, T2 and either S1 >rpo T1, or (S1 ≡ T1 and S2 >rpo T2). Here x ≥rpo y means that x >rpo y or x ≡ y, and S >rpo T1, T2 is shorthand for
S >rpo T1 and S >rpo T2.
This definition forces an order on BDDs, as shown in [4] Chapter 6.
Lemma 3.14 Let f, g be two simpliﬁed guards, such that f < g, and C is a
(0, S, =)-BDD. If g occurs at least once in C, then C[g] >rpo C[f ].
Proof This holds because of the monotonical behaviour of >rpo ([4] Chapter 6). Next lemma shows that if a sub-tree of a BDD is replaced by a smaller tree,
then the whole tree will become smaller.
Lemma 3.15 If T is a simpliﬁed BDD, and S a sub BDD of it, and S' is another simpliﬁed BDD where S >rpo S', then if we replace S by S' in T and derive T ', we will have T >rpo T '
Proof It is easy by induction on the structure of T and Definition 3.13(III). 

Applying any rewrite rule on a BDD results in a smaller BDD with respect to the
>rpo order:
Lemma 3.16 Each rewrite rule is contained in >rpo.
Proof The only non straightforward case is rule 8, wherefore we use Lemmas 3.12 and 3.14.	 
Now, we can prove that our term rewrite system (Definition 3.9) always terminates:
Theorem 3.17 (Termination) The rewrite system deﬁned in Deﬁnition 3.9 is terminating on simpliﬁed (0, S, =)-BDDs.
Proof According to the previous lemma all rewrite rules are contained in >rpo. This implies termination, because >rpo is a reduction order, i.e. well-founded, and closed under substitutions and contexts [4] Chapter 6.	 
As an immediate result of termination, each BDD has a normal form:
Corollary 3.18 Every (0, S, =)-BDD is equivalent to at least one (0, S, =)-R-OBDD.

Satisﬁability of paths in (0, S, =)-R-OBDDs
We consider α, β, γ to represent finite sequences of (possibly negated) guards. Let us denote the empty sequence by ε and the concatenation of sequences α and β by α.β.
Definition 3.19 We define the set of Paths in a (0, S, =)-BDD by:
Pat(T)= Pat(⊥)= ε
Pat(ITE (g, T1, T2)) = {g.α | α ∈ Pat(T1)}∪ {чg.β | β ∈ Pat(T2)}
α is an ordered path if it occurs in some (0, S, =)-OBDD. We are going to prove that al paths in an OBDD are satisfiable.
The next two lemmas give syntactical properties on OBDDs, which can be used for proving satisfiability of each path in an OBDD.
Lemma 3.20 Let T ≡ ITE(Sm(x)= Sn(z), T1, T2) be a (0, S, =)-R-OBDD. Let α
be a path in T2 and H = {Sji (x)= ri | 1 ≤ i ≤ k} be the set of all positive guards on α which have x as their left-hand side variable. Then for each positive guard on α with a variable which occurs in an atom in H, we can conclude that the guard belongs to H.
The next lemma says that in an OBDD, the left-most variable of each guard will not occur at the right-hand side of any guard underneath it.
Lemma 3.21 Let T ≡ ITE(Sm(x) = r, T1, T2) be a (0, S, =)-R-OBDD. Then for all guards s = t occurring in T1 or T2 we have x /≡ Var(t) (i.e. t /≡ Sk(x) for any k).

Now we prove the second main theorem, which is satisfiability of each path in an OBDD.
Theorem 3.22 (Paths are satisfiable) Each path in a (0, S, =)-R-OBDD is sat- isﬁable.
Satisfiability of paths in OBDDs results in:
Corollary 3.23
T is the only tautological (0, S, =)-R-OBDD.
⊥ is the only contradictory (0, S, =)-R-OBDD.
Every other (0, S, =)-R-OBDD is satisﬁable.
Proof Each path in a tautological OBDD should end in a T. Because if T is a tautological OBDD, containing a path α which ends in a ⊥, then according to Theorem 3.22, there is a valuation v which satisfies α. But then v(T ) = 0, which is impossible since T is a tautology. Therefore, if T has more than one leaf, rule 3 of Definition 3.9 is applicable on a tautological OBDD which is not T, and this contradicts the orderedness. So T ≡ T. Similarly for a contradictory one. 

The Transformer Algorithm
In this section we present an algorithm to transform any formula in our logic into an equivalent OBDD. One could consider an algorithm which applies the rules of our term rewrite system one by one, on the given formula, until it reaches an OBDD. Although this is possible, it is not efficient, since in the process a lot of unnecessary cases will be checked on the formula, until it can reach a normal form. We instead extend the algorithm in [12], which is based in Shannon’s expansion with the smallest equation x = y:
ϕ ⇐⇒ (x = y Λ ϕ|x=y) V (x /= y Λ ϕ|x/=y).

Since the set of BDDs is a subset of the set of formulas,so in this section we may use BDDs wherever we work with set of formulas. In order to simplify formulas, we extend the reducing method in Definition 3.6 over all formulas:
Definition 4.1 For any formula ϕ and any simplified literal (guard) l, we define:
(чϕ)|l := ч(ϕ|l)
(ϕ Λ ψ)|l := (ϕ|l) Λ (ψ|l)
ITE(ϕ1, ϕ2, ϕ3)|l := ITE((ϕ1)|l, (ϕ2)|l, (ϕ3)|l)
As a result the corresponding lemma (i.e. Lemma 3.7) is extendible to all formulas, as well:
Lemma 4.2 If v |= l for a literal l and a valuation v, then v(ϕ) ≡ v(ϕ|l).

Proof By induction on the structure of ϕ and using Lemma 3.7, it is straightfor- ward.	 
Applying an |l operation on a BDD will not increase the size of the BDD.
Lemma 4.3 Let T be a simpliﬁed BDD. Suppose l is a simpliﬁed guard possibly occurring on T. If l is no bigger than the guards occurring on T then T ≥rpo T |l.
Proof According to Lemma 3.12 and Definition 3.6, the guards do not get bigger. Now, by using induction over the structure of T and Definitions 4.1, the proof is trivial.	 
Intuitively, the operation |l replaces the rightmost variable occurring in the (pos- itive) literal l with the left most term sitting in l. So, one would expect that the rightmost variable would not appear in the formula after this operation is applied:
Lemma 4.4 Let l be a simpliﬁed guard of the form r = Sm(y) in which y ∈ V . Then y /∈ T |l.
Proof It is trivial by Definitions 4.1 and 3.6.	 
In the next definition we generalize the simplification method over guards in Def- inition 3.2 to all formulas, because in practice we also need to make the guards, occurring inside BDDs and formulas, smaller if possible:
Definition 4.5 We extend the simplification rules of Definition 3.2 to all formulas below:
g —→ g ↓	(if g is not simpliﬁed)

ϕ ↓ represents a most simplified version of ϕ. Similar to the Lemma 3.3, it can be proved that:
Lemma 4.6 If ϕ is simpliﬁed to ϕ' using Deﬁnition 4.5, then ϕ and ϕ' are equiv- alent.
Lemmas 4.2 and 4.6 together will lead to:
Lemma 4.7 If v |= l for a literal l and a valuation v, then v(ϕ) ≡ v((ϕ|l) ↓).
Theorem 4.8 Let T be a simpliﬁed BDD. If g is the smallest guard occurring in
T, then T >rpo (T |l) ↓ for l ∈ {g, чg}.

Proof According to the last case of Definition 4.1, in order to calculate T |l we could apply the operation |l to its sub-trees. Let us consider a case distinction over l:
l ≡ g. g occurs in T . Hence there is a sub-tree of T of the form ITE(g, T1, T2). Let T ' be one of these. Therefore:
(T '|g) ↓≡ ITE(g|g, T1|g, T2|g) ↓	(Definition 4.1)
≡ (T1|g) ↓	(Definition 4.5)
≤rpo T1|g	(using Lemma 3.16 for Definition 4.5)
≤rpo T1	(Lemma 4.3)
<rpo T '	(Lemma 3.13(I))
Above, A ≤rpo B means B ≥rpo A. Now according to Lemma 3.15, our original tree is bigger. Meaning that T >rpo (T |l) ↓. In this last conclusion we also used Lemma 3.16 and Lemma 4.3 implicitly.
l ≡ чg. Similar.	 
The following function, called sort, is introduced to take the smallest guard oc- curring in a formula and bring it to the topmost place, and sort and simplify the formula afterwards.
Definition 4.9 We define a function sort on simplified formulas, which sorts and simplifies the formulas with respect to their smallest guard.
sort(⊥) ≡⊥ 
sort(T) ≡T 
Let g be the smallest guard occurring (positively or negatively) in ϕ. Then
sort(ϕ) ≡  sort(ϕ|g ↓)	if sort(ϕ|g ↓) ≡ sort(ϕ|¬g ↓)
ITE(g, sort(ϕ|g ↓), sort(ϕ|¬g ↓))	otherwise
Since each BDD is a formula, therefore the function sort can be recursively used. The following lemmas are immediately derived from this definition.
Theorem 4.10 sort(ϕ) is terminating over any formula ϕ.
Proof Using induction over the structure of ϕ.	 
Lemma 4.11 The set of all variables in sort(ϕ) is a subset of the set of all vari- ables in ϕ.
Lemma 4.12 sort(ϕ) is a BDD for any formula ϕ. Moreover ϕ is equivalent to
sort(ϕ), i.e. v(ϕ) ≡ v(sort(ϕ)) for any valuation v.
One application of sort does not always yield an OBDD:

Example 4.13 Let ϕ ≡ ITE(x = S(z),ITE(y = z, T, ⊥), ⊥); we show how the
OBDD algorithm finds an equivalent OBDD for this ϕ.
ϕ is simpliﬁed already, so that ψ = ϕ ↓ = ϕ. Now ψ /= ⊥, hence we must enter the while-loop: we ﬁrst need to calculate sort(ϕ). x = S(z) is the smallest guard. sort(ψ|x=S(z)) ≡ ITE(x = S(y), T, ⊥) and sort(ψ|x/=S(z)) ≡ ⊥. Hence

sort(ψ) = ITE(x = S(z), sort(ψ|x=S(z)), sort(ψ|x/=S(z)))
= ITE(x = S(z),  ITE(x = S(y), T, ⊥), ⊥)	(above)

Now ψ /= sort(ψ), hence we must repeat the while-loop: x = S(y) is the smallest guard. sort(ψ|x=S(y)) ≡ ITE(x = S(z), T, ⊥) and sort(ψ|x/=S(y)) ≡ ⊥.
Hence
sort(ψ) = ITE(x = S(y), sort(ψ|x=S(y)), sort(ψ|x/=S(y)))
= ITE(x = S(y), ITE(x = S(z), T, ⊥), ⊥)	(above)

Again ψ /= sort(ψ), hence we must repeat the while-loop: x = S(y) is the smallest guard. sort(ψ|x=S(y)) ≡ ITE(x = S(z), T, ⊥) and sort(ψ|x/=S(y)) ≡ ⊥.
Hence
sort(ψ) = ITE(x = S(y), sort(ψ|x=S(y)), sort(ψ|x/=S(y)))
= ITE(x = S(y), ITE(x = S(z), T, ⊥), ⊥)	(above)
This time ψ = sort(ψ), hence we must leave the while-loop, and stop with ψ =
ITE(x = S(y), ITE(x = S(z), T, ⊥), ⊥) as the outcome.


As a result, we need to have some algorithm that can recursively apply sort
until a fixed point is reached. This is what we look for with the next algorithm:
Definition 4.14 The following algorithm, generates a (0, S, =)-R-OBDD for any formula:
OBDD(ϕ)
ψ:= ϕ↓ ;
ϕ:= ⊥ ;
while ϕ /= ψ do
ϕ:= ψ ;
ψ:= sort(ψ); 
od return ψ

Later, in Theorem 4.17, we will prove that this algorithm always returns an OBDD. The following two lemmas describe some properties of the sort function which will be used to prove termination of the OBDD algorithm.
Lemma 4.15 Let T be any simpliﬁed BDD. Then:
sort(T ) ↓ ≡ sort(T ).
T ≥rpo sort(T ).
One can easily check that the OBDD algorithm (i.e. Definition 4.14) terminates as soon as T ≡ sort(T ). Below, we claim that such a T is ordered.
Theorem 4.16 If T is a simpliﬁed BDD for which T ≡ sort(T ), then T is an ordered BDD.
Now we can prove the main theorem which is termination of the algorithm:
Theorem 4.17 (Termination of the algorithm) The algorithm given in Deﬁ- nition 4.14 is terminating, and OBDD(ϕ) is a (0, S, =)-R-OBDD equivalent to ϕ, for any given formula ϕ.
Proof According to the Lemma 4.12 sort(ϕ) will be a BDD equivalent to ϕ. The
≥rpo ordering is well-founded, therefore using Lemma 4.15(ii) we know that after finitely many steps we will reach a fixed point of sort(ψ) ≡ ψ, for some ψ. Now, using Theorem 4.16, this ψ is an ordered BDD, which on the other-hand is the outcome of the OBDD(ϕ) (by definition), and is equivalent to ϕ (by Lemma 4.12). 
Below we show, on a simple example, how the OBDD algorithm operates of for- mulas.
Example 4.18 We consider the formula of Example 3.11:
ϕ ≡ ITE(S(y)= z, ITE(x = S2(y), T, ⊥), ⊥).
ϕ is simplified already, therefore ϕ ↓ ≡ ϕ and ψ := ϕ. We enter the loop since
⊥ /= ϕ. Here, sort(ψ) is:
ITE(x = S2(y), sort(ϕ|x=S2 (y)), sort(ϕ|x/=S2 (y)).
The innermost formulas are to be computed here. We will have:
sort(ϕ|x=S2 (y)) ≡ ITE(x = S(z), T, ⊥) and sort(ϕ|x/=S2 (y)) ≡ ⊥.
Substituting these two in the formula, we obtain
sort(ψ) ≡ ITE(x = S2(y),ITE(x = S(z), T, ⊥), ⊥).
Once more applying the sort function over this formula will result in sort(sort(ψ)) ≡ sort(ψ). This is a fixed point, therefore OBDD(ϕ) is ITE(x = S2(y),ITE(x = S(z), T, ⊥), ⊥). This is an OBDD for the original formula ITE(S(y)= z, ITE(x = S2(y), T, ⊥), ⊥).

Conclusion
In this paper we provided another sound and complete method for verification of a fragment of quantifier-free FOL. This fragment contains equality with zero and successors. We introduced an algorithm which transforms each formula into (one of) its equivalent ordered BDD (s). In an Ordered BDD all paths are satisfiable so a formula is a tautology (contradictory) if and only if the derived OBDD is q T (⊥), and is satisfiable otherwise.
Although the logic that we tackled is rather small, many verification problems can be expressed in this logic. A lot of research has directed towards model checking techniques for verification of large systems, with huge state spaces. In this plot, BDDs have also been of use [8,9]. Among these, symbolic model checking [15,14] have been of much interest. The idea is to use OBDDs for reducing the size of the representive state space. Although propositional logic have been much into considerations, our technique has the ability to provide a more expressive logic. This would prevent necessary obligations for finding proper transformation functions from bigger languages into propositional logic [13]. SMT solvers or also UPPAAL which is a tool used for verification of real time systems, seem closer to our purpose. UPPAAL uses separation logic for modeling real time systems. Formulas are sets of constraints over expressions like x > y, x ≤ 6+ z or 2 < x ≤ 6, etc.
Another line of research could be extension of BDD-method (current results) to other algebras. Some interesting extensions are incorporation of addition (+), or an investigation of other free algebras (such as LISP-list structures based on null and cons).

Acknowledgement
I would like to thank Jaco van de Pol for his support and good comments on the paper.

References
W. Ackermann. Solvable Cases of the Decision Problem. Studies in Logic and the Foundations of Mathematics. North-Holland, 1954.
B. Badban. Verification Techniques for Extensions of Equality Logic. PhD thesis, Amsterdam Vrij University, 2006.
B. Badban and J.C. van de Pol. Zero, successor and equality in binary decision diagrams. Annals of Pure and Applied Logic, 133(1-3):101–123, 2005.
M.A. Bezem, J.W. Klop, and R.C. de Vrijer, editors. Term Rewriting Systems. Cambridge University Press, 2003.
R.E. Bryant. Symbolic boolean manipulation with ordered binary-decision diagrams. ACM Computing Surveys, 24(3):293–318, 1992.
R.E. Bryant, S. German, and M.N. Velev. Processor verification using efficient reductions of the logic of uninterpreted functions to propositional logic. ACM Transactions on Computational Logic, 2001.
M. Davis and H. Putnam. A computing procedure for quantification theory. Journal of the ACM, 7(3):201–215, 1960.

Stefan Edelkamp. Heuristic search planning with bdds. In PuK, 2000.
Stefan Edelkamp and Peter Kissmann. Limits and Possibilities of BDDs in State Space Search. In
AAAI, pages 1452–1453, 2008.
A. Goel, K. Sajid, H. Zhou, and A. Aziz. BDD based procedures for a theory of equality with uninterpreted functions. In Proc. CAV, 1998.
J.F. Groote and J.C. van de Pol. Equational binary decision diagrams. In Proc. of LPAR 2000, pages 161–178, 2000.
J.F. Groote and J.C. van de Pol. Equational binary decision diagrams. In Proc. Conference on Logic for Programming and Automated Reasoning, 2000.
Shuvendu K. Lahiri, Randal E. Bryant, and Byron Cook. A symbolic approach to predicate abstraction. In CAV, pages 141–153, 2003.
S.K. Lahiri, T. Ball, and B. Cook. Predicate abstraction via symbolic decision procedures. CoRR’06, abs/cs/0612003.
K.L. McMillan. Symbolic Model Checking: An Approach to the State Explosion Problem. PhD thesis, 1992.
G. Nelson and D.C. Oppen. Fast decision procedures based on congruence closure. Journal of the ACM, 27(2):356–364, 1980.
A. Pnueli, Y. Rodeh, O. Shtrichman, and M. Siegel. Deciding equality formulas by small domains instantiations. In Proc. CAV, pages 455–469, 1999.
O. Strichman, S.A. Seshia, and R.E. Bryant. Deciding separation formulas with SAT. In Proc. CAV, pages 209–222, 2002.
