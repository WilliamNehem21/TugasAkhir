 Electronic Notes in Theoretical Computer Science 96 (2004) 129–152 
www.elsevier.com/locate/entcs




A Hierarchy of Failures-Based Models
Christie Bolton, Gavin Lowe1 ,2
Oxford University Computing Laboratory Wolfson Building, Parks Road Oxford OX1 3QD, England

Abstract
In this paper we identify the failures class, a class of semantic models for describing concurrent systems. Each such model records all possible sequences of interaction, and gives some information about subsequent availability. Each model is associated with a predicate that determines how much availability information is recorded.
The general contribution of the paper is three-fold: we identify the relative strengths of models in terms of their defining predicates; we identify the maximal subset of the language over which each model induces a congruence; and we show how refinement in each model can be automatically tested.
More concretely, we apply these general results to specific instances of the class. In particular we construct a spectrum showing the relative strengths of four established models and three interesting new models, and we prove that only Roscoe’s stable failures and traces models define congruences over the whole language.
Keywords: CSP, process algebra, failures model, refinement


Introduction
A variety of languages and semantic models, from process algebras such as CSP [10] and CCS [11,12] through modal logics [15,4,8] to Petri nets [14], have been proposed for describing and reasoning about the properties of con- current systems. No one model is “better” than all the others: the choice and suitability of any given model depends on the requirements of the user.
We may impose an ordering on these models in terms of the number of identifications each makes: one model is coarser than another if whenever

1 Email: christie@comlab.ox.ac.uk
2 Email: gavinl@comlab.ox.ac.uk


1571-0661 © 2004 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2004.04.025


bisimulation semantics 2−nested simulation semantics

possible−futures semantics
ready simulation semantics possible world semantics ready trace semantics



simulation semantics

readiness semantics	failure trace semantics







Fig. 1. Linear time – branching time spectrum of van Glabbeek [19], illustrating the positioning of the failures class of semantic models.

the second identifies two processes then so too does the first; in this case, we say that the second model is ﬁner than the first. In [19], van Glabbeek considers various semantic equivalences for modelling finitely branching, con- crete, sequential, non-deterministic processes. He presents them in a language- independent style, reducing them to eleven distinct models as illustrated in his linear time – branching time sprectrum: see Figure 1.
In this paper we put the bottom section of van Glabbeek’s spectrum under the microscope for further scrutiny. We identify the failures class, a particular class of semantic models of concurrent systems. Each such model records possible sequences of interaction, along with refusal sets, sets which contain information about the subsequent availability of operations. They do not explicitly model divergence, the possible occurrence of an infinite se- quence of hidden or internal actions. We use the process algebra Communi- cating Sequential Processes (CSP) [10,18] to present a generalised description of elements within this class.
Each semantic model from the failures class is associated with a predicate on refusal sets; this predicate determines how much availability information is recorded. We use our generalised model: to explore the relative strengths of models of this class; to identify the maximal subset of the language for which each model defines a congruence; to consider for which such models is automatic refinement-checking possible; and to identify and consider the properties of models—both established and new—within this class.
The paper begins with a brief introduction to the syntax of CSP, in- troducing the standard operators along with processes that we will refer to throughout the rest of the paper; we follow this with a discussion of the stable failures model [18].

In Section 3 we formally identify the class of failures models central to the paper. Each such model is generated by a predicate that determines those refusal sets to be recorded; we identify the predicates associated with four established models: the stable failures model [18]; the traces model [18]; the singleton failures model [1]; and the completed trace model [19]. Furthermore we identify non-standard models within the class and discuss their potential applications. We show that the failures class of semantic models forms a complete lattice, and in particular that the stable failures model is the top element and the traces model the bottom element.
In Section 4 we explore which models are congruences with respect to which operators, and apply these general results to the particular models already identified. In particular we prove that the traces model and the stable failures model are the only members of the class that are congruences over the entire language. In Section 5 we consider the problem of automatic refinement checking, using existing tools. We demonstrate simple techniques that can be used within all the specific models considered in this paper, and also more complicated techniques that can be used for arbitrary models within the class.
We conclude in Section 6 with a discussion of related work. Throughout the paper we include in the main body of the text those proofs that shed light on the results they are establishing. The remaining proofs are left to the appendix.

Overview of CSP
In this section we give a brief overview of the CSP syntax that we will be using, and of the stable failures model for CSP [18].
Syntax
In CSP a process is a pattern of communication that describes the behaviour of a system. Examples of systems that might be modelled in this language are individual machines, networks and protocols. Moreover simple components may be combined to create a composite process. Whatever the system, the behaviour is described in terms of events or synchronous atomic communica- tions, marking points in the evolution of the system.
The simplest process is Stop, the deadlocked process that will not perform any events and marks the end of a pattern of communication. The process div represents a divergent process, which performs unboundedly many internal events.
For any event a and process P , the process a → P is willing to communi- cate event a and, if that event occurs, will subsequently behave as P . If A is a

set of events, then ?a : A → Pa represents the process that is willing to com- municate any of the events from A, and if event a is performed, subsequently behaves as Pa . For later convenience we define Offer (A) =?a : A → div, the process that offers the events from A, and then diverges.
CSP has two choice operators: P  Q represents the external choice and P H Q the internal (or non-deterministic) choice between processes P and Q ; the process H i : I | p(i ) • Pi represents an indexed internal choice between the processes Pi where i ranges over those members of I such that p(i ) holds. The process P Δ Q represents a process that initially acts like P , but at any point, P can be interrupted and control passed to Q .
Given processes P and Q and sets of events A and B (their respective interfaces), the process P A  B Q denotes the parallel combination of P and
Q . In such a parallel combination, a process can perform only those events that are in its interface and its cooperation is required if such an event is to occur; hence the processes synchronise on events in the intersection of their interfaces. By contrast, P ||| Q represents an interleaving of P and Q , i.e. a parallel composition with no synchronisation.
If P is a process and A a set of events, then the process P \ A behaves as P except that events from A are hidden (or made internal) so cannot be observed and do not require the cooperation of any other process.







The stable failures model

The stable failures model represents each process P by a pair in which the first component is a set of traces and the second a set of failures. A trace is an element of the type Σ , where Σ is the set of all events, and corresponds to a possible sequence of interaction. A failure is an element of the type Σ × P Σ; the first component is a trace and the second a refusal set, or set of events that might collectively be refused from a stable state (i.e. where no internal activity is possible) reached after the given trace.
The semantics of a process P is given by the pair (traces(P ), failures(P )). Furthermore, the functions traces and failures must satisfy the following health-

iness conditions:
⟨⟩ ∈ traces(P ),	(T1)
tr - tr ' ∈ traces(P ) ⇒ tr ∈ traces(P ),	(T2)
(tr , X ) ∈ failures(P ) ⇒ tr ∈ traces(P ),	(F1)
(tr , X ∪ Y ) ∈ failures(P ) ⇒ (tr , X ) ∈ failures(P ),	(F2) (tr , Y ) ∈ failures(P ) ∧ ∀ x ∈ X • tr - ⟨x ⟩ ∈/ traces(P ) ⇒
(F3)
(tr , X ∪ Y ) ∈ failures(P ).
The first condition (T1) states that the empty trace is a possible trace of every process and the second (T2) states that the set of traces of any process is prefix-closed. The third condition (F1) ensures consistency between failure and trace information. The fourth condition (F2) states that the set of refusal sets for every possible trace is subset closed. Finally, condition (F3) states that events that cannot be performed in a particular state may be added to a corresponding refusal set. Observe that the absence of the pair (tr , ∅) from the set failures(P ) for some tr ∈ traces(P ) indicates divergence. Semantic equations for the functions traces and failures can be found in Appendix A.
Equivalence and refinement in the stable failures model can be defined as follows:
P ≡F Q ⇔ traces(P )= traces(Q ) ∧ failures(P )= failures(Q ),
P ±F Q ⇔ traces(Q ) ⊆ traces(P ) ∧ failures(Q ) ⊆ failures(P ).
The coarser traces model models a process only in terms of its traces. Equiv- alence and refinement in this model is defined by:
P ≡T Q ⇔ traces(P )= traces(Q ),
P ±T Q ⇔ traces(Q ) ⊆ traces(P ).

The hierarchy of models
All the models we consider in this paper represent processes by a pair com- prising their traces and a subset of their failures. The subset of failures for any given model will be determined by a predicate p over refusal sets asso- ciated with that model; more precisely, a model associated with predicate p will include only those failures (tr , X ) such that p(X ) holds. We define:
failuresp(P ) =^ {(tr , X ) ∈ failures(P ) | p(X )},

to be those failures included in the model of predicate p. We then define the model Mp to be the model that represents the process P by
Mp [[P ]] =^ (traces(P ), failuresp(P )).
We can define equivalence and refinement in the model Mp by:
P ≡p Q ⇔ traces(P )= traces(Q ) ∧ failuresp(P )= failuresp(Q ),
P ±p Q ⇔ traces(Q ) ⊆ traces(P ) ∧ failuresp(Q ) ⊆ failuresp(P ). The following four established models are all instances of this class:
Stable failures model
Roscoe’s stable failures model (F) [18] records full trace and failure informa- tion. Two processes are equivalent within this model if they share the same traces and the same failures. Hence the predicate that generates the stable failures model is p(X ) =^ true: equivalently, F = Mλ X • true .
The stable failures model may be used for reasoning about both safety and liveness properties for divergence-free processes. De Nicola [5] proves that for processes in which no internal events may occur (thereby precluding the use of the hiding operator) the stable failures semantic model is equivalent to his testing equivalences model [6].
Traces model
The traces model (T ) [10,18] records no refusal information. Irrespective of their failures, two processes are equivalent within this model precisely when they share the same traces. Hence the predicate that generates the traces model is p(X ) = false: equivalently, T = Mλ X • false . The traces model may be used for reasoning about safety properties.
Singleton failures model
The singleton failures model (S) [1,2,19] records all trace information, and failures where the cardinality of the refusal set is at most one. Two processes are equivalent within this model if they share the same traces and if, after every such trace, they can refuse the same events individually. Hence the predicate that generates the singleton failures model is p(X ) = #X ≤ 1: equivalently, S = Mλ X • #X ≤1 .  This model was defined to coincide with the relational
semantics of data types [7]: the refinement of data types is equivalent to the
singleton failures refinement of their corresponding processes.
Completed trace model
As well as recording all trace information, the completed trace model (CT )
[19] records all completed traces, that is traces after which no events can be

performed. Two processes are equivalent within this model if firstly they share the same traces, and secondly if one can deadlock after a given trace then so can the other. Hence p(X ) = X =Σ is the predicate that generates the completed trace model: equivalently, CT = Mλ X • X =Σ . The completed trace model may be used for reasoning about safety and deadlocking properties.
We have identified four established semantic models that are members of the failures class. Obviously there are many more members of this class— as many as there are predicates on refusal sets—and below we identify three predicates that yield potentially interesting or useful models.
Stable traces model
The model generated by the predicate p(X ) = X ={}, which we will refer to as the stable traces model (ST = Mλ X • X ={}), merits attention. The traces component records all possible traces whereas the failures component records only stable traces, traces after which the empty set can be refused. Hence this model, like Olderog and Hoare’s divergence model [13] and Reed’s untimed
stability model [16], does not record the unavailability of events, but does distinguish between deadlock and divergence:
ST [[Stop]] = {{⟨⟩}, {(⟨⟩, {})}} ,	ST [[ div ]] = {{⟨⟩}, {}} .
This model differs from the divergence and untimed stability models by the nondeterministic choice not being strict with respect to div.
Bounded refusals model for N
Another interesting model is that generated by the predicate p(X ) = #X ≤ N for any integer N such that 0 ≤ N ≤ #Σ. We will refer to this as the bounded refusals model for N (BRN = Mλ X • #X ≤N ).  Such a model identifies two processes with the same traces if they agree upon refusal sets of cardinality at most N . For N = 0, N = 1 and (assuming finiteness of Σ) N = #Σ,
this yields respectively the stable traces, the singleton failures, and the stable failures models. A potential application for the bounded refusals model is for determining whether N processors within a distributed system of M > N processors could fail.
Restricted refusals model for A
A final potentially useful model within the failures class is that generated by the predicate p(X ) = X ⊆ A for any A such that {} ⊆ A ⊆ Σ. We will refer to this as the restricted refusals model for A (RRA = Mλ X • X ⊆A). Such a model identifies two processes with the same traces if they agree upon refusals with events only from A. For A = {} and A = Σ this yields respectively the

stable traces and the stable failures models. Such a model might be useful for situations in which we are concerned only about the availability of a particular subset of events.

The following two results consider the relative expressiveness of the mod- els in our class.
Theorem 3.1 The failures class of semantic models forms a complete lattice, ordered according to implication of the corresponding predicates, with top ele- ment the stable failures model (J = łλ X • true), and bottom element the traces model (7 = łλ X • false).
Proof sketch  If predicate p is stronger than predicate q then semantic model
łq is ﬁner than semantic model łp.
Theorem 3.2 If predicate q is not at least as strong as predicate p, i.e. ч (6 X • q (X ) ⇒ p(X )), then semantic model łq distinguishes processes identiﬁed by model łp.
Proof sketch Since ч(6 X • q (X ) ⇒ p(X )) there must be some set of events Xpq such that q (Xpq ) л ч p(Xpq ). We identify processes Ppq and Qpq such that traces(Ppq ) = traces(Qpq ) and failures(Ppq ) = failures(Qpq ) ∪ {(⟨⟩, Xpq)} so that Ppq ≡p Qpq but Ppq /≡q Qpq . In the case where Xpq is non-empty this is true of
Ppq =^ Offer (Σ) H Offer (Σ — Xpq ),
Qpq =^ Offer (Σ) H ( H Y : P Σ | Y ⊂ Xpq • Offer (Σ — Y )).
Where Xpq = ∅, it is true of Ppq =^ Offer (Σ) and Qpq =^ Offer (Σ)  div.
It follows directly from Theorems 3.1 and 3.2 that for processes with finite alphabet Σ, the relative strengths of the models identified in this section are as illustrated in Figure 2. Observe that the restricted refusals models,
{ҮҮA | A ∈ P Σ}, form a complete sub-lattice, with the stable failures model (J = ҮҮΣ) as top element, and the stable traces model (£7 = ҮҮ{}) as bottom element.

For which operators is łp a congruence?
In this section we consider which models in our class are congruences with respect to which operators, identifing the maximal subset of the language for which each model induces a conguence and hence for which its semantics is compositional. A semantic model ł is a congruence with respect to unary operator F if we may express ł [[F (P )]] in terms of ł [[P ]]; and it is a

Key:
J
// \ 

	) “is finer than”	/
\	УҮ

/
/	/›
\
r v \f
#Σ−1

/	ҮҮ Σ\{a' }
ҮҮ Σ\{a}
УҮ 2

/ /
C7
v(sub-lattice) v	£

ҮҮ {a}
zz
ҮҮ {a'}	/
	/

zz	a	/ /
 
zzz’’ £7
/
/
/ /
7
Fig. 2. Hierarchy of models (where a, a' ∈ Σ and a /= a').
congruence with respect to binary operator ⊕ if we may express ł [[P ⊕ Q ]] in terms of ł [[P ]] and ł [[Q ]].
All the models associate the same traces with a given process, and the semantic equations for traces in Appendix A show that the traces of a compos- ite process can always be expressed in terms of the traces of the components. Hence we need consider only failures below.
All the models within the failures class are congruences with respect to the operators →, H, , Δ and |||.
Lemma 4.1 For every predicate p, the model łp deﬁnes a congruence on the subset of the language containing the operators →, H, , Δ and |||.
However, as we will illustrate below, this result does not extend to subsets of the language containing either the parallel operator or the hiding operator.
Hiding
In this section we show that the model łp is a congruence with respect to hiding of set A if and only if p(X ) ⇒ p(X ∪ A) for all sets X . We begin by proving in Lemma 4.2 the “only if” result for which we include the proof. The simpler proof for Lemma 4.3 is included in Appendix B.
Lemma 4.2 Semantic model łp deﬁnes a congruence with respect to hiding of set A only if p(X ) ⇒ p(X ∪ A) for all sets X .
Proof Suppose p(X ) and ч p(X ∪ A). We exhibit processes P and Q such that P ≡p Q but P \ A /≡p Q \ A. Let
P =^ H Y : P Σ | Y ⊆ X ∪ A • Offer (Σ — Y ),
Q =^ H Y : P Σ | Y ⊂ X ∪ A • Offer (Σ — Y ).



Fig. 3. X ∩ (A − B ) ⊆ Y ⊆ X ∩ A
Then
traces(P )= traces(Q )= {⟨⟩} ∪ {⟨a⟩| a ∈ Σ}, failures(P )= {(⟨⟩, Y ) | Y ⊆ X ∪ A}, failures(Q )= {(⟨⟩, Y ) | Y ⊂ X ∪ A}.
Hence P ≡p Q: the only difference between P and Q is the failure (⟨⟩, X ∪ A) of P, but X ∪ A does not satisfy p. However (⟨⟩, X ) ∈ failures(P \ A) — failures(Q \ A), so P \ A /≡p Q \ A, as required.
We now prove the converse result.
Lemma 4.3 If p(X ) ⇒ p(X ∪ A) for all sets X , then for all processes P, the set failuresp(P \ A) is expressible in terms of failuresp(P ).
Corollary 4.4 Model łp deﬁnes a congruence with respect to hiding of ar- bitrary sets precisely when predicate p is upwards closed.
Parallel composition
In this section we show that model łp is a congruence with respect to the parallel composition  A  B  if and only if
6 X , Y : P Σ | X ∩ (A — B ) ⊆ Y ⊆ X ∩ A • p(X ) ⇒ p(Y ),
6 X , Z : P Σ | X ∩ (B — A) ⊆ Z ⊆ X ∩ B • p(X ) ⇒ p(Z ).
The relationship X ∩ (A — B ) ⊆ Y ⊆ X ∩ A is illustrated in Figure 3. We begin by proving in Lemma 4.5 the “only if” result for which we include the proof. The simpler proof for Lemma 4.6 is included in the appendix.
If X is a refusal of P A  B Q then the corresponding refusals Y of P and Z of Q , as well as satisfying the predicate Y ∪ Z = X ∩ (A ∪ B ), will satisfy X ∩ (A — B ) ⊆ Y ⊆ X ∩ A and X ∩ (B — A) ⊆ Z ⊆ X ∩ B , respectively; conditions (1) and (2) say that if X satisfies p then so do Y and Z .
Lemma 4.5 Semantic model łp deﬁnes a congruence on a subset of the language containing the parallel operator A  B  only if conditions (1) and (2) hold.
Proof By symmetry, it is enough to consider just the case where condition (1) does not hold. So suppose X ∩ (A — B ) ⊆ Y ⊆ X ∩ A л p(X ) л ч p(Y ).


KEY
 Can be refused by P
 Outside alphabets of both P and Q  Blocked by Q


Fig. 4. Process P A  B Q can initially refuse the whole of X .
We construct processes P, P ' and Q such that P ≡p P ' but P A  B Q /≡p
P ' A  B Q as follows:
P =^ H Z : P Σ | Z ⊆ Y • Offer (Σ — Z ), P ' =^ H Z : P Σ | Z ⊂ Y • Offer (Σ — Z ), Q =^ Offer (B ∩ Y ).
Then
traces(P )= traces(P ')= {⟨⟩} ∪ {⟨a⟩| a ∈ Σ},
failures(P )= {(⟨⟩, Z ) | Z ⊆ Y },
failures(P ')= {(⟨⟩, Z ) | Z ⊂ Y },
failures(Q )= {(⟨⟩, Z ) | Z ∩ (B ∩ Y )= {}} .
Hence P ≡p P ', because they differ only in the failure (⟨⟩, Y ) and Y does not satisfy p.
Observe that, as illustrated in Figure 4, the process P A  B Q can initially refuse the whole of set X : any element in X —(A∪B ) lies outside the alphabets of both processes; any element in X ∩ (B — Y ) will be blocked by Q; and the remainder of X , i.e. the set Y , can be refused by P. However, since the process P ' cannot refuse the whole of Y , we conclude that P ' A  B Q cannot
initially refuse the whole of X . We see that
(⟨⟩, X ) ∈ failures(P A  B Q ) — failures(P ' A  B Q ).
Hence, since p(X ) is true, we conclude, as required, that PA  B Q /≡p P 'A  B Q. 
We now prove the converse result.
Lemma 4.6 If conditions (1) and (2) hold, then for all processes P and Q, the set failuresp(P A  B Q ) is expressible in terms of the sets failuresp(P ) and failuresp(Q ).
Corollary 4.7 Model łp deﬁnes a congruence with respect to parallel com- position with arbitrary interface sets precisely when predicate p is downwards closed, i.e.:
6 X , Y : P Σ | Y ⊆ X • p(X ) ⇒ p(Y ).

Summary
In Theorem 4.8 below we apply the results establised in Lemma 4.1, and Corol- laries 4.4 and 4.7 to identify for each subset of the language the constraints on predicate p that ensure model łp is a congruence. Theorems 4.9 and 4.10, in which we consider specific models, follow directly from Theorem 4.8.
Theorem 4.8 Model łp deﬁned on a language with operators
Ops ⊆ { →, , H, Δ,  , |||, \} 
is a congruence precisely when the following two predicates hold:
•	 ∈ Ops  ⇒  ( 6 X , Y ∈ P Σ • p(X ∪ Y ) ⇒ p(X ) ),
•  \ ∈ Ops  ⇒  ( 6 X , Y ∈ P Σ • p(X ) ⇒ p(X ∪ Y ) ).
Theorem 4.9 Both 7 and J deﬁne a congruence upon the whole language introduced in this paper. Moreover they are the only models within the class that satisfy this property.
Theorem 4.10 Of the other speciﬁc models we have considered:
The Singleton Failures Model, the Stable Traces Model, and the Bounded Refusals Models are congruences with respect to all the operators except for hiding.
The Restricted Refusals Model for A (ҮҮA) is a congruence with respect to all the operators except for hiding of B for B /⊆ A.
The Completed Traces Model is a congruence with respect to all the operators except for parallel composition.

Automatic analysis
FDR [17,9] is a powerful analysis tool for CSP, which can be used to automat- ically check refinement of finite-state CSP processes in the traces and stable failures models. In this section we consider whether it can also be used to check for refinement in other models of our class, by encoding refinement in such models as failures and/or traces refinement checks.
We show first that such an encoding is possible for all models associated with predicates that are either upwards or downwards closed, as is the case with all the specific models we have considered in this paper. Then, in Sec- tion 5.3 we prove a corresponding result for the general case and discuss the practicalities of our rule. The proofs are included in the appendix.

Downwards closed predicates
To prove, for any predicate p that is downwards closed, that refinement within model łp may be expressed in terms of refinement within 7 and J, we introduce the process Rp that can initially refuse any set Y such that p(Y ) is true, and that diverges after any event is performed:
Rp =^ H Y : P Σ | p(Y ) • Offer (Σ — Y ).
We observe that
traces(Rp)
= {⟨⟩} ∪ {⟨a⟩| ∃ Y • p(Y ) л a ∈ Σ — Y }	[def n of Rp]
= {⟨⟩} ∪ {⟨a⟩| a ∈ Σ} [p downwards closed and not identically false]
failures(Rp)
= {(⟨⟩, X ) | ∃ Y • p(Y ) л X ⊆ Y }	[def n of Rp]
= {(⟨⟩, X ) | p(X )} .	[p is downwards closed]
The interleaving of process Rp with any process P then yields a process whose stable failures are equal to failuresp(P ).
Theorem 5.1 Suppose predicate p is downwards closed, and p /= λ X • false. Then
P ±p Q ⇔ P ±T Q л P ||| Rp ±F Q ||| Rp.
where Rp is as deﬁned above.

Upwards closed predicates
To prove, for any predicate p that is upwards closed, that refinement within model łp may be expressed in terms of refinement within 7 and J, we introduce the process Sp that can initially refuse any set Y such that p(Y ) is false, and that diverges after any event is performed:
Sp =^ H Y : P Σ |ч p(Y ) • Offer (Σ — Y ).
We observe that
traces(Sp)
= {⟨⟩} ∪ {⟨a⟩| ∃ Y •ч p(Y ) л a ∈ Σ — Y }	[def n of Sp]

= {⟨⟩} ∪ {⟨a⟩| a ∈ Σ} [p is upwards closed and not identically true]
failures(Sp)
= {(⟨⟩, X ) | E Y •ч p(Y ) Λ X ⊆ Y }	[def n of Sp]
= {(⟨⟩, X ) |ч p(X )} .	[p is upwards closed]
For convenience, we define a new syntactic operator, the non-deterministic interrupt operator: P ~ S = P H (P Δ S ). Process S non-deterministically may or may not be able to interrupt process P . Note that
traces(P ~ S )= traces(P ) ∪ {tr - tr ' | tr ∈ traces(P ) Λ tr ' ∈ traces(S )},
failures(P ~ S )= failures(P ) ∪
{(tr - tr ', X ) | tr ∈ traces(P ) Λ (tr ', X ) ∈ failures(S )}. The effect of non-deterministically interrupting any process P with the process Sp is to augment the failures set with trace refusal pairs (tr , X ) such that tr
is a trace of P and p(X ) is false.
Theorem 5.2 Suppose predicate p is upwards closed, and p /= λ X • true. Then
P ±p Q e P ~ Sp ±F Q ~ Sp where Sp is as deﬁned above.
General predicates
In this section we identify, for arbitrary predicate p, a rule for expressing refinement within model łp in terms of refinement within 7 and J. We begin by considering refinement within a model concerned only with one fixed refusal set A: łλ X •X =A. If A is the empty set then p is downwards closed
and we may apply the results from Section 5.1. Hence we consider only the
cases where A /= ∅.
We use techniques similar to those applied in Sections 5.1 and 5.2: we interleave with the process Offer (Σ — A) to remove all failures in which the refusal set is not a subset of A, and then non-deterministically interrupt with the process H Y | Y ⊂ A • Offer (Σ — Y ) thereby adding failures in which the refusal set is a strict subset of A.
Lemma 5.3 Given any processes P and Q and any set of events A /= ∅, P ±λ X •X =A Q e P ±T Q Λ ((P ||| TA) ~ UA) ±F ((Q ||| TA) ~ UA)

where TA = Offer (Σ — A) and UA = H Y : P Σ | Y ⊂ A • Offer (Σ — Y ).
We now prove that checkability is closed under disjunctions over corre- sponding predicates: if ±p and ±q are checkable then so is ±p∨q .
Lemma 5.4 Given any processes P and Q and predicates p and q, P ±p∨q Q e P ±p Q Λ P ±q Q .
It follows immediately from the previous two results, and the associativity of Λ and V that ±p is checkable for any predicate p.
Theorem 5.5 For any predicate p over a ﬁnite alphabet Σ we may express reﬁnement within model łp in terms of reﬁnement within 7 and J . In particular,
P ±p Q
e P ±T Q Λ
X ∈P Σ|p(X )
(P ||| Offer (Σ — Xi )) ~ (H Y | Y ⊂ Xi • Offer (Σ — Y ))
±F
(Q ||| Offer (Σ — Xi )) ~(H Y | Y ⊂ Xi • Offer (Σ — Y )).
In Sections 5.1 and 5.2 we showed that verification of refinement in model łp for upwards or downwards closed predicate p is relatively straightforward requiring only one refinement check in each of 7 and J. However, we observe from Theorem 5.5 above, that such a refinement is not so straightforward in general. Indeed, in the worst case—when there are no subsets of {X ∈ P Σ | p(X )} that are either upwards or downwards closed over Σ—verifying refinement in model łp will require O (#{X ∈ P Σ | p(X )}) refinement checks.

Discussion
In this paper we have identified the failures class, a particular family of se- mantic models for describing concurrent systems, each model recording all trace information and possibly some information about subsequent availabil- ity of events. The amount of availability—or rather possibility of refusal— information recorded by each model is determined by the predicate on sets of events with which it is associated.

We discussed in detail four established models that are members of this class: Roscoe’s traces and stable failures model [18]; Bolton’s singleton failures model [1,2]; and van Glabbeek’s completed trace model [19]. We examined also three non-established models within this family. Having proved that the failures class forms a complete lattice we identified the position within the lattice of each of these models, thereby exposing their relative strengths.
For each model we identified the maximal sublanguage over which the model induces a congruence, verifying that only the traces and the stable failures semantics are fully compositional. Finally, by expressing such a re- finement in terms of refinement within the traces and stable failures models, we presented techniques for using the model-checker FDR [17,9] to verify re- finement within any model in this class.
To put this work in a wider context, we have put under the micro- scope a small section of van Glabbeek’s linear time – branching time spec- trum [19], presenting an entire sub-lattice. The top and bottom elements of our sub-lattice are Roscoe’s stable failures and traces models—identified re- spectively as “failures semantics” and “trace semantics” within van Glabbeek’s spectrum—the other model they share being the completed trace model.
A related paper [3] extends and explores practical applications of the work described here. Non-standard measures of consistency are identified and motivated. Verification of consistency within each such measure can be seen as a refinement in one of the models of the current paper and hence can be performed automatically using existing tools.

References
C. Bolton. On the Reﬁnement of State-Based and Event-Based Models. D.Phil., University of Oxford, 2002.
C. Bolton and J. Davies. A singleton failures semantics for communicating sequential processes, 2001. Submitted to Formal Aspects of Computing.
C. Bolton and G. Lowe. On the automatic verification of non-standard measures of consistency. In J.M. Morris, editor, Proceedings of the International Workshop on Formal Methods, Electronic Workshops in Computing (eWiC), 2003.
E. M. Clarke and E. A. Emerson. Design and synthesis of synchronisation skeletons using branching-time temporal logic. In Proceedings of the International Workshop on Logic of Programs, volume 131 of Lecture Notes in Computer Science, pages 52–71, 1981.
R. de Nicola. Extensional equivalences for transition systems. Acta Informatica, 24, 1987.
R. de Nicola and M. Hennessy. Testing equivalences for processes. Theoretical Computer Science, 34, 1984.
W.-P. de Roever and K. Engelhardt. Data reﬁnment: model-oriented proof methods and their comparison. Cambridge Tracts in Theoretical Computer Science, 1998.


E. A. Emerson and J. Y. Halpern. Sometimes and not never revisited: On branching versus linear time. Journal of the ACM, 33(1):151–178, 1986.
Formal Systems (Europe) Ltd. Failures-Divergence Reﬁnement—FDR 2 User Manual, 1999. Available via URL http://www.fsel.com/fdr2_manual.html.
C. A. R. Hoare. Communicating Sequential Processes. Prentice Hall, 1985.
R. Milner. A Calculus of Communicating Systems, volume 92 of Lecture Notes in Computer Science. Springer-Verlag, 1980.
R. Milner. Communications and concurrency. Prentice Hall, 1989.
E.-R. Olderog and C. A. R. Hoare. Specification-oriented semantics for communicating processes. Acta Informatica, 23, 1986.
J. L. Peterson. Petri Net Theory and the Modeling of Systems. Prentice-Hall International, 1981.
A. Pnueli. The temporal logic of programs. In Proceedings of the 18th International Smposium on Foundations of Computer Science, pages 46–57, 1977.
G. M. Reed. A uniform mathematical theory for real-time distributed computing. PhD thesis, University of Oxford, 1988.
A. W. Roscoe. Model-checking CSP. In A Classical Mind, Essays in Honour of C. A. R. Hoare. Prentice-Hall, 1994.
A. W. Roscoe. The Theory and Practice of Concurrency. Prentice Hall, 1997.
R. J. van Glabbeek. The linear time – branching time spectrum I: the semantics of concrete, sequential processes. In J.A. Bergstra, A. Ponse, and S.A. Smolka, editors, Handbook of Process Algebra. Elsevier, 2001.

Semantic equations
The functions traces and failures satisfy the following equations 3 :
traces(Stop)= {⟨⟩},
failures(Stop)= {(⟨⟩, X ) | X ∈ P Σ},
traces(div)= {⟨⟩},
failures(div)= {},
traces(a → P )= {⟨⟩ } ∪ { ⟨a⟩ - tr | tr ∈ traces(P ) },
failures(a → P )= {(⟨⟩, X ) | X ∈ P Σ ∧ a ∈/ X } ∪ 
{(⟨a⟩ - tr , X ) | (tr , X ) ∈ failures(P )},
traces(?a : A → Pa )= {⟨⟩} ∪ {⟨a⟩ - tr | a ∈ A ∧ tr ∈ traces(Pa )},
failures(?a : A → Pa )= {(⟨⟩, X ) | X ∈ P Σ ∧ A ∩ X = {}} ∪
{(⟨a⟩-tr , X ) | a ∈ A ∧ (tr , X ) ∈ failures(Pa )},
traces(Offer (A)) = {⟨⟩} ∪ {⟨a⟩| a ∈ A}, failures(Offer (A)) = {(⟨⟩, X ) | X ∈ P Σ ∧ A ∩ X = {}},

3 Note in particular that div has no stable failures, because it never reaches a stable state; and P Δ Q has no failures corresponding to P , because in such states it can be interrupted at any point, so never stabilises.

traces(P  Q )= traces(P ) ∪ traces(Q ),
failures(P  Q )= {(⟨⟩, X ) ∈ failures(P ) ∩ failures(Q )}∪ 
{(tr , X ) ∈ failures(P ) ∪ failures(Q ) | tr /= ⟨⟩},
traces(P H Q )= traces(P ) ∪ traces(Q ),
failures(P H Q )= failures(P ) ∪ failures(Q ),
traces(H i : I | p(i ) • Pi )= [{traces(Pi ) | i ∈ I ∧ p(i )},
failures(H i : I | p(i ) • Pi )
= [{failures(Pi ) | i ∈ I ∧ p(i )},
traces(P Δ Q )= {tr - tr ' | tr ∈ traces(P ) ∧ tr ' ∈ traces(Q )},
failures(P Δ Q )= {(tr - tr ', X ) | tr ∈ traces(P ) ∧
(tr ', X ) ∈ failures(Q )},

∗
traces(P A  B Q )= {tr ∈ (A ∪ B )
| tr T A ∈ traces(P ) ∧
tr T B ∈ traces(Q )},

failures(P A  B Q )= {(tr , X ) ∈ (A ∪ B ) × P Σ |
∃ Y ∈ P A; Z ∈ P B ; W ∈ P(Σ − A − B ) •
(tr T A, Y ) ∈ failures(P ) ∧ (tr T B , Z ) ∈ failures(Q ) ∧ X = Y ∪ Z ∪ W },
traces(P ||| Q )= {tr |∃ trP ∈ traces(P ), trQ ∈ traces(Q ) •
tr ∈ trP ||| trQ },
failures(P ||| Q )= {(tr , X ) | ∃ trP , trQ • (trP , X ) ∈ failures(P ) ∧
(trQ , X ) ∈ failures(Q ) ∧
tr ∈ trP ||| trQ },
traces(P \ A)= { tr \ A | tr ∈ traces(P ) },
failures(P \ A)= {(tr \ A, X ) | (tr , A ∪ X ) ∈ failures(P )}.
In the equations for P ||| Q , the notation trP ||| trQ represents all ways of interleaving the traces trP
and trQ ; see [18].

Proofs
Proof of Lemma 4.1
For any predicate p the following all hold:
failuresp (a → P )= { (⟨⟩, X ) | p(X ) ∧ a ∈/ X }∪ 
{ (⟨a⟩ - tr , X ) | (tr , X ) ∈ failuresp (P ) },
failuresp (?a : A → Pa )= { (⟨⟩, X ) | p(X ) ∧ A ∩ X = {} } ∪
{ (⟨a⟩ - tr , X ) | a ∈ A ∧ (tr , X ) ∈ failuresp (Pa ) },
failuresp (P H Q )= failuresp (P ) ∪ failuresp (Q ),

failuresp (P  Q )= { (⟨⟩, X ) ∈ failuresp (P ) ∩ failuresp (Q ) }
∪
{ (tr , X ) ∈ failuresp (P ) ∪ failuresp (Q ) | tr /= ⟨⟩ },
failuresp (P Δ Q )= {(tr - tr ', X ) | tr ∈ traces(P ) ∧
(tr ', X ) ∈ failuresp (Q )},
failuresp (P ||| Q )= {(tr , X ) | ∃ trP , trQ • (trP , X ) ∈ failuresp (P ) ∧
(trQ , X ) ∈ failuresp (Q ) ∧
tr ∈ trP ||| trQ }.
Consider first the case of the external choice operator:


failuresp (P  Q )
=
{ (⟨⟩, X ) ∈ failures(P ) ∩ failures(Q ) | p(X ) }
∪
{ (tr , X ) ∈ failures(P ) ∪ failures(Q ) | tr /= ⟨⟩ ∧ p(X ) }


[def n of failuresp and failures]

=
{ (⟨⟩, X ) ∈ failures(P ) | p(X ) } ∩ { (⟨⟩, X ) ∈ failures(Q ) | p(X ) }
∪
{ (tr , X ) ∈ failures(P ) | tr /= ⟨⟩ ∧ p(X ) }
∪
{ (tr , X ) ∈ failures(Q ) | tr /= ⟨⟩ ∧ p(X ) }
=
{ (⟨⟩, X ) ∈ failuresp (P ) ∩ failuresp (Q ) }
∪
{ (tr , X ) ∈ failuresp (P ) ∪ failuresp (Q ) | tr /= ⟨⟩ }.
[set theory]





[def n of failuresp ]

The proofs of the other results follow similar lines.

Proof of Lemma 4.3
Suppose p(X ) ⇒ p(X ∪ A) for all sets X . We reason as follows:
failuresp (P \ A)

= { (tr , X ) ∈ failures(P \ A) | p(X ) }	[def n of failuresp ]
= { (tr \ A, X ) | (tr , A ∪ X ) ∈ failures(P ) ∧ p(X ) }	[def n of failures]


=
{ (tr \ A, X ) | (tr , A ∪ X ) ∈ failures(P ) ∧ p(A ∪ X ) ∧ p(X ) }
[p(X ) ⇒ p(A ∪ X )]


= { (tr \ A, X ) | (tr , A ∪ X ) ∈ failuresp (P ) ∧ p(X ) }.	[def n of failuresp ]

Proof of Lemma 4.6
We reason as follows:
failuresp (P A  B Q )

= { (tr , X ) ∈ failures(P A  B Q ) | p(X ) }	[def n of failuresp ]


= { (tr , X ) ∈ (A ∪ B ) × P Σ | p(X ) ∧
∃ Y ∈ P A; Z ∈ P B ; W ∈ P(Σ − A − B ) •
X = Y ∪ Z ∪ W ∧
(tr T A, Y ) ∈ failures(P ) ∧ (tr T B , Z ) ∈ failures(Q ) }
[def n of failures]



= { (tr , X ) ∈ (A ∪ B ) × P Σ | p(X ) ∧
∃ Y ∈ P A; Z ∈ P B ; W ∈ P(Σ − A − B ) •
X = Y ∪ Z ∪ W ∧
X ∩ (A − B ) ⊆ Y ⊆ X ∩ A ∧
X ∩ (B − A) ⊆ Z ⊆ X ∩ B ∧
(tr T A, Y ) ∈ failures(P ) ∧ (tr T B , Z ) ∈ failures(Q ) }
[set theory]



= { (tr , X ) ∈ (A ∪ B ) × P Σ | p(X ) ∧
∃ Y ∈ P A; Z ∈ P B ; W ∈ P(Σ − A − B ) •
X = Y ∪ Z ∪ W ∧
p(Y ) ∧ p(Z ) ∧
[conditions (1) and (2)]

(tr T A, Y ) ∈ failures(P ) ∧ (tr T B , Z ) ∈ failures(Q ) }


= { (tr , X ) ∈ (A ∪ B ) × P Σ | p(X ) ∧
∃ Y ∈ P A; Z ∈ P B ; W ∈ P(Σ − A − B ) •
X = Y ∪ Z ∪ W ∧
(tr T A, Y ) ∈ failuresp (P ) ∧
(tr T B , Z ) ∈ failuresp (Q ) }.
[def n of failuresp ]


Proof of Corollary 4.7
We must show the above condition (3) is equivalent to the conjunctions of conditions (1) and (2) for all A and B . Firstly, taking A = B = Σ in condition (1) gives condition (3). Conversely, assume condition (3) and suppose X ∩ (A − B ) ⊆ Y ⊆ X ∩ A; then Y ⊆ X , so p(X ) ⇒ p(Y ).


Proof of Theorem 4.9
Theorem 4.8 tells us that model Mp is a congruence upon the whole language precisely when the following predicate holds:
∀ X , Y ∈ P Σ • (p(X ) ⇒ p(X ∪ Y )) ∧ (p(X ∪ Y ) ⇒ p(X )) .
Equivalently, if p is ever true it must be true for the whole of P Σ. This occurs precisely when p is identically true or identically false. Hence F (or Mλ X • true) and T (or Mλ X • false) are the only models that are congruences upon the whole language.

Proof of Theorem 5.1
Note that for process Rp with traces and failures as identified in Section 5.1:
traces(P ||| Rp )= {tr |∃ tr ' ∈ traces(P ), a ∈ Σ • tr ∈ tr ' ||| ⟨a⟩},
and similarly for Q ||| Rp ; in particular
traces(Q ) ⊆ traces(P ) ⇒ traces(Q ||| Rp ) ⊆ traces(P ||| Rp ).
Further
failures(P ||| Rp )
= {(tr , X ) | (tr , X ) ∈ failures(P ) ∧ (⟨⟩, X ) ∈ failures(Rp )}
= {(tr , X ) | (tr , X ) ∈ failures(P ) ∧ p(X )}
= failuresp (P ),
and similarly for Q ||| Rp . Hence
P ±T Q ∧ P ||| Rp ±F Q ||| Rp

⇔ traces(Q ) ⊆ traces(P ) ∧
traces(Q ||| Rp ) ⊆ traces(P ||| Rp ) ∧
failures(Q ||| Rp ) ⊆ failures(P ||| Rp )
[def n of ±T and ±F ]

⇔ traces(Q ) ⊆ traces(P ) ∧ failuresp (Q ) ⊆ failuresp (P )	[above results]
⇔ P ±p Q .	[def n of ±p ]


Proof of Theorem 5.2
Note that for process Sp with traces and failures as identified in Section 5.2:
(B.1) traces(Q ) ⊆ traces(P ) ⇒ traces(Q ~ Sp ) ⊆ traces(P ~ Sp ). Further:
failures(P ~ Sp )
= failures(P ) ∪ {(tr - tr ', X ) | tr ∈ traces(P ) ∧ (tr ', X ) ∈ failures(Sp )}
= failures(P ) ∪ {(tr , X ) | tr ∈ traces(P ) ∧¬ p(X )}, and similarly for Q ~ Sp . Hence
P ~ Sp ±F Q ~ Sp
⇔ traces(Q ~ Sp ) ⊆ traces(P ~ Sp ) ∧
failures(Q ~ Sp ) ⊆ failures(P ~ Sp )











[def n of ±F ]



⇔ traces(Q ~ Sp ) ⊆ traces(P ~ Sp ) ∧
failures(Q ) ∪ {(tr , X ) | tr ∈ traces(Q ) ∧¬ p(X )}⊆ 
failures(P ) ∪ {(tr , X ) | tr ∈ traces(P ) ∧¬ p(X )}
⇔ traces(Q ~ Sp ) ⊆ traces(P ~ Sp ) ∧
{(tr , X ) ∈ failures(Q ) | p(X )}∪ 
{(tr , X ) ∈ failures(Q ) |¬ p(X )}∪ 
{(tr , X ) | tr ∈ traces(Q ) ∧¬ p(X )}
[above result]


[for all X , p(X ) or ¬ p(X )]

⊆
{(tr , X ) ∈ failures(P ) | p(X )}∪ 
{(tr , X ) ∈ failures(P ) |¬ p(X )}∪ 
{(tr , X ) | tr ∈ traces(P ) ∧¬ p(X )}



⇔
traces(Q ~ Sp ) ⊆ traces(P ~ Sp ) ∧
failuresp (Q ) ⊆ failuresp (P ) ∧
{(tr , X ) | tr ∈ traces(Q ) ∧¬ p(X )}⊆ 
{(tr , X ) | tr ∈ traces(P ) ∧¬ p(X )}
[def n of failuresp ; condition (F1)]



⇔ traces(Q ~ Sp ) ⊆ traces(P ~ Sp ) ∧ failuresp (Q ) ⊆ failuresp (P ) ∧ traces(Q ) ⊆ traces(P ) ∧
[p is not identically true]


⇔ failuresp (Q ) ⊆ failuresp (P ) ∧ traces(Q ) ⊆ traces(P )	[equation (B.1)]

⇔ P ±p Q .	[def n of ±p ]

Proof of Lemma 5.3
Observe that since A /= ∅,
failures(UA)= {(⟨⟩, X ) | X ⊂ A},
failures(TA)= {(⟨⟩, X ) | X ⊆ A},


(B.2)
failures(P ||| TA)= {(tr , X ) | (tr , X ) ∈ failures(P ) ∧ (⟨⟩, X ∈ failures(TA)}
= {(tr , X ) ∈ failures(P ) | X ⊆ A},

and similarly for failures(Q ||| TA).
In the reasoning below, we make use of the well-known result that all the CSP operators are monotonic with respect to inclusion of traces [18]. Given processes P and Q and set of events A /= ∅, we reason as follows:

P ±T Q ∧ (P ||| TA) ~ UA ±F (Q ||| TA ) ~ UA


⇔
traces(Q ) ⊆ traces(P ) ∧
traces((Q ||| TA) ~ UA) ⊆ traces((P ||| TA ) ~ UA) ∧
failures((Q ||| TA) ~ UA) ⊆ failures((P ||| TA) ~ UA)
[def n s of ±T and ±F ]



⇔
traces(Q ) ⊆ traces(P ) ∧
failures((Q ||| TA) ~ UA) ⊆ failures((P ||| TA) ~ UA)
[monotonicity]



⇔
traces(Q ) ⊆ traces(P ) ∧
failures(Q ||| TA) ∪
{(tr - tr ', X ) | tr ∈ traces(Q ||| TA) ∧ (tr ', X ) ∈ failures(UA) }
[def n of ~]

⊆
failures(P ||| TA) ∪
{(tr - tr ', X ) | tr ∈ traces(P ||| TA) ∧ (tr ', X ) ∈ failures(UA) }



⇔
traces(Q ) ⊆ traces(P ) ∧
[one point rule and def n of UA]

failures(Q ||| TA) ∪ {(tr , X ) | tr ∈ traces(Q ||| TA) ∧ X ⊂ A}
⊆ failures(P ||| TA) ∪ {(tr , X ) | tr ∈ traces(P ||| TA) ∧ X ⊂ A}


⇔
traces(Q ) ⊆ traces(P ) ∧
{(tr , X ) ∈ failures(Q ||| TA) | X /⊂ A}
⊆ {(tr , X ) ∈ failures(P ||| TA) | X /⊂ A} ∧ 
{(tr , X ) | tr ∈ traces(Q ||| TA) ∧ X ⊂ A}
⊆ {(tr , X ) | tr ∈ traces(P ||| TA) ∧ X ⊂ A}
[set theory and condition F1]



⇔
traces(Q ) ⊆ traces(P ) ∧
{(tr , X ) ∈ failures(Q ||| TA) | X /⊂ A}
⊆ {(tr , X ) ∈ failures(P ||| TA) | X /⊂ A}
[set theory and monotonicity]



⇔
traces(Q ) ⊆ traces(P ) ∧
{(tr , X ) ∈ failures(Q ) | X ⊆ A ∧ X /⊂ A}
⊆ {(tr , X ) ∈ failures(P ) | X ⊆ A ∧ X /⊂ A}
[equation (B.2)]



⇔
traces(Q ) ⊆ traces(P ) ∧
[predicate calculus and set theory]

{(tr , X ) ∈ failures(Q ) | X = A}⊆ {(tr , X ) ∈ failures(P ) | X = A}


⇔
P ±λ X •X =A Q .
[def n of ±p ]



Proof of Lemma 5.4
P ±p Q ∧ P ±q Q
⇔ traces(P ) ⊇ traces(Q ) ∧
{(tr , X ) ∈ failures(P ) | p(X )}⊇ {(tr , X ) ∈ failures(Q ) | p(X )}∧ 
{(tr , X ) ∈ failures(P ) | q (X )}⊇ {(tr , X ) ∈ failures(Q ) | q (X )}
⇔ traces(P ) ⊇ traces(Q ) ∧
{(tr , X ) ∈ failures(P ) | p(X ) ∨ q (X )}⊇ 
{(tr , X ) ∈ failures(Q ) | p(X ) ∨ q (X )}


[def n of refinement]


[set theory]

⇔ P ±p∨q Q .	[def n of refinement]
Proof of Theorem 5.5
Given processes P and Q and predicate p we reason as follows:
P ±p Q
⇔ VXi ∈P Σ|p(Xi ) P ±λ X •X =Xi Q	[Lemma 5.4 and associativity]

⇔ VXi ∈P Σ|p(Xi )
P ±T Q ∧
(P ||| Offer (Σ − Xi )) ~ (H Y | Y ⊂ Xi • Offer (Σ − Y ))
±F
(Q ||| Offer (Σ − Xi )) ~ (H Y | Y ⊂ Xi • Offer (Σ − Y ))
[Lemma 5.3]



⇔ P ±T Q ∧
VXi ∈P Σ|p(Xi )
(P ||| Offer (Σ − Xi )) ~ (H Y | Y ⊂ Xi • Offer (Σ − Y ))
±F
(Q ||| Offer (Σ − Xi )) ~ (H Y | Y ⊂ Xi • Offer (Σ − Y )).
[distributivity]
