Electronic Notes in Theoretical Computer Science 45 (2001)
URL: http://www.elsevier.nl/locate/entcs/volume45.html 23 pages


Model-Checking View-Based Partial Specifications

Michael Huth 1
Department of Computing
Imperial College of Science, Technology and Medicine London, United Kingdom

Shekhar Pradhan 2
Department of Computer Science University of Maryland
College Park, USA
Department of English & Philosophy Central Missourri State University Warrensburg, USA



Abstract
We develop foundations for the view-based specification of software artifacts in first-order logic. Standard notions of models and semantics of first-order logic are generalized to partial models that do not have access to the entire global signa- ture. At the model-theoretic level, this is achieved via the Smyth powerdomain over the semantic universe of elements. At the logical level, we accomplish this via the Smyth powerdomain over the standard two-valued booleans. A refinement notion is developed and its soundness is proved for a fixed set of semantic elements. Standard models and semantics of first-order logic are subsumed by our framework as models in which all signature information is present (“complete models”). We decompose our semantics into a consensus (the union of the Smyth powerdomain) of an optimistic and a pessimistic semantics. That way, we may compute this se- mantics as a standard model check in first-order logic over a model lifted by the Smyth powerdomain.




1 Email: M.Huth@doc.ic.ac.uk
2 Email: pradhan@cs.umd.edu
◯c 2001 Published by Elsevier Science B. V. Open access under CC BY-NC-ND license.

Introduction

The work presented in this paper makes a first step at laying the semantic and algorithmic foundations for property verification over multiple and potentially conflicting models — be they specification descriptions or other abstractions of software artifacts. We mention two important applications for such foun- dations. In requirement engineering, different stake holders formulate their individual view of the requirements that a software artifact should meet. The requirement elicitation process can therefore be greatly improved if (i) incon- sistencies between these views can be detected and if (ii) specified properties can be “verified” at this early stage in the software life cycle [25,24]. These kinds of analyses are also needed in the evaluation of software artifacts in a very late stage of design, implementation, or maintenance. For example, xlinkit [23] is a tool that generates rule-based smart links and then analyzes a collection of XML files for their consistency according to a set of rules.
These practical problems provide the context of our theoretical work. This work can be broken down into two steps. In the first step, semantic and algorithmic machinery needs to be developed for verifying in a partial view global properties expressed using predicate and function symbols that the partial view may have no knowledge of. In the second step, semantic and algorithmic machinery needs to be developed to enable reasoning over multiple viewpoints. Although global property verification is done at each partial view, various forms of communication between some of the partial views should provide the means for a more integrated global check of system properties. In this paper we undertake the first step only; the second step will be tackled in future work.
We model views as conventional finite 3 models of first-order logic,except that individual views may not have access to the global signature of all views involved. The question is then how to define a semantics of first-order logic in these views. We use part of the machinery of domain theory [1], notably the Smyth powerdomain,to lift the standard first-order-logic semantics to this par- tial setting. The Smyth powerdomain turns classical two-valued propositional logic into Kleene’s strong interpretation of three-valued logic [19]. Inspired by
[2], this three-valued semantics is decomposed into two semantics whose con- sensus (the union of the Smyth powerdomain) recovers the original semantics. This consensus, together with a translation of formulas into negation normal form,is used to reduce our three-valued semantics to two standard semantics of first-order logic. Thus, three-valued model checking of global properties in a partial model can be reduced to two-valued model checking of standard models of first-order logic.



3 Our results generalize to infinite models by moving from finite partial orders to dcpos.


Outline of paper
In Section 2, we define partial models that have only limited access to a global signature. Section 3 uses these models to interpret global terms and formulas. This is done from first principles by applying the Smyth power- domain to the set of semantic elements (for terms) and to the discrete set of ordinary truth values {T, F} (for formulas). A refinement preorder of par- tial models is proposed in Section 4 and proved to be sound, provided that the set of semantic elements remains the same. In Section 5, we decompose our semantics into two semantics whose consensus (the union of the Smyth powerdomain) recovers the original semantics. Section 6 uses this consensus, together with a translation of formulas into negation normal form, to reduce our three-valued semantics to two standard semantics of first-order logic. In Section 7,we describe related work and Section 8 concludes.

Models of views
First-order logic signature and syntax
We consider a first-order logic with terms t and formulas φ defined by the grammar
t ::= x | f (t, t,..., t)
φ ::= T | P (t, t,..., t) | ¬φ | φ ∧ φ | ∃x φ,
where x, f , and P range over sets of variables X , function symbols F, and predicate symbols P (respectively),resulting in the signature
def
Σ = (X , F, P).
In this paper,we write “n” as a generic name for the arities ar(f ) and ar(P ), the number of arguments required for f and P (respectively). To simplify our exposition, we omit sorts, types, and other structuring mechanisms. As customary, we write φ1 ∨ φ2 for ¬(¬φ1 ∧ ¬φ2), φ1 → φ2 for ¬(φ1 ∧ ¬φ2), and
∀xφ for ¬∃x ¬φ.
Partial models
Fixing a nonempty,finite set of elements U — the semantic universe for all functions and predicates of signature Σ — we define models that are partial in that they have access to a part of Σ and U only.
Definition 2.1 [Partial models] A partial model Mv for (Σ, U) consists of
a signature Σv = (Xv, Fv, Pv) such that Xv ⊆ X , Fv ⊆ F,and Pv ⊆ P;
a nonempty set of elements Uv with Uv ⊆ U;
for all f ∈ Xv,a (total) function fv: U n → Uv; and
for all P ∈ Pv,a relation Pv ⊆ U n.
The parameter v in Mv indicates that this model is a particular “view” of models of sort Σ. Such views may be partial, for some of the inclusions for

sorts (e.g. Xv ⊆ X ) can be strict. We point out that different views may well have the same signature, making inconsistencies a definite possibility. Also observe that Uv may be a strict subset of U , e.g. the set of all even natural numbers below 100,where U is the set of all natural numbers below 100.

Semantics of views
Smyth powerdomain
We define a semantics of partial models that conservatively extends the usual semantics for first-order logic. In doing so,we employ the Smyth power domain [1], thereby rediscovering Kleene’s strong three-valued interpretation of (propositional) logic [19].
Definition 3.1 [Smyth powerdomain functor [28,1]]
For a finite partial order (P, ≤ ), the Smyth powerdomain of P , Ps(P ), is the collection of all nonempty upper sets 4 of P , ordered by reverse inclusion:
(3)	U1 ± U2 in Ps(P )	iff	U2 ⊆ U1.
For a monotone function f : P → Q between finite partial orders, we define the (total) function Ps(f ): Ps(P ) → Ps(Q) as
P (f )(U ) d=ef {q ∈ Q | for some u ∈ U , f (u) ≤ q}.
Remark 3.2 [Universal property of Ps(·)] Ps(·) is a functor on the category of finite partial orders and monotone functions. For any finite partial order P , the finite partial order Ps(P ) is universal in the following sense: Let Q be any finite partial order, f : P → Q any monotone function,and ϵP : P → Ps(P )
def
defined by ϵP (p) = {p' ∈ P | p ≤ p'}. Then there exists a unique monotone
function f¯: Ps(P ) → Q such that
f = f¯ ◦ ϵP and f¯(U1 ∪ U2)= f¯(U1) ∪ f¯(U2) for all U1, U2 ∈ Ps(P ).

In particular, Ps(f ) equals ϵQ ◦ f .
Example 3.3	(i) For the discrete partial order B d=ef {F, T},the Smyth power domain Ps(B) has three elements
{F, T}, {F}, and {T},
where the first one is the least element and the other two are maximal elements. Note that Ps(B) is isomorphic to Ps(Ps(B)).
For a finite set Uv,the Smyth power domain Ps(Uv) consists of all nonempty subsets of Uv ordered under reverse inclusion. In particular,the least ele- ment of Ps(Uv) is Uv,and its maximal elements are all singleton sets {u} (u ∈ Uv).

4 An upper set of P is a subset U of P such that x ∈ U and x ≤ y imply y ∈ U .

If the function =B: B × B → B encodes classical equality of truth values, then P (=B) is a conservative extension of =B from B to P (B) which
s	s
returns U iff at least one of its arguments equals U.
Definition 3.4 [Propositional logic on P (B)] Let ¬B, ∧B, and B be the standard interpretations of negation,conjunction,and nary disjunction on B. We define the monotone functions 5
s	B


¬s d=ef P (¬B)	∧s d=ef P (∧B)
  d=ef P (  )

as our interpretation of propositional logic on Ps(B).
This categorical semantics turns out to be Kleene’s strong interpretation of three-valued propositional logic [19].	We write U (“unknown”) for the set
{F, T} and identify T with {T} and F with {F} whenever this causes no confu- sion.
Proposition 3.5 (Characterization of propositional logic in Ps(B))	(i)
The function ¬s maps T to F, F to T, and U to U.
The function x∧s y returns F if x or y equals F; otherwise, if x or y equals
U, it returns U; otherwise, it returns T.
The expression  s xj returns T if xj equals T for some j with 1 ≤ j ≤ n;
otherwise, it returns U if xj' equals U for some j' with 1 ≤ j' ≤ n; otherwise, it returns F.
Proof. Most of this follows from the universal property of the Smyth power- domain. We show some cases for sake of illustration.
The set ¬s({F, T}) equals all the elements in B that are greater than or equal to ¬B(F) or ¬B(T). Thus,this set is {F, T}.
The set {F, T} ∧s {T} equals {F ∧B T, T ∧B T},which is {F, T}.
Let xi0 = {F, T} and xi /= {T} for all i /= i0. Then  xi equals {F, T}: we
s
obtain F by choosing F from each xi,including xi0 ; we get T by choosing
T from xi0 .
✷



Semantics of global terms
For a partial model Mv as in Definition 2.1, we define a semantics [| t |]v as an element of Ps(Uv) for terms t of the global signature Σ, where ρ is a local environment — a partial function from Xv to Uv that binds variables to

5 These functions are well defined since any function on the discrete set B is monotone.

concrete elements. For variables x ∈ X ,we define 6



[| x |]v d=ef  {ρ(x)} if x ∈ Xv

Uv   otherwise.
Thus, we model the fact that the name x is not known in this view by eval- uating it to “possibly any element in this view”. For function symbols, we proceed similarly:




[| f (t ,...,t ) |]v d=ef
 {fv(u1,..., un) | ui ∈ [| ti |]v} if f ∈ Fv

1	n	ρ
 Uv	otherwise.

If f ∈ Fv, then the semantics of f (t1,..., tn) in (9) is obtained by applying Ps(·) to the interpretation fv of type U n → Uv in the partial model. Otherwise, we interpret f as a constant function whose image is the least element of Ps(Uv).
Example 3.6 Let Uv be the set of even natural numbers below 100,including zero. Suppose that +v and ∗v denote the usual operations of addition and multiplication (respectively), except that they are executed “modulo 100” (e.g. ∗v(46, 78) = 24 and ∗v(78, 0) = 0). Let x /∈ Xv. Then [| +(6, x) |]v equals
{6+ u (mod 100) | u ∈ Uv},which is Uv; whereas [| ∗(0, x) |]v equals {0}.

Semantics of global formulas
The meaning of a global formula is an element of the Smyth power domain Ps(B) of B: it is T,if the formula is definitely true; F if the formula is definitely false; and U if the truth value of the formula cannot be determined,due to the partiality of the model. Clearly,
[| T |]v d=ef T.
Since the meaning of a partial term is a nonempty subset of the local universe of semantic elements, we need to lift the relations that interpret predicate symbols to subsets:
 T if P ∈ Pv & [  i [| ti |]v ⊆ Pv]


[| P (t ,...,t ) |]v d=ef
F if P ∈ P  & [  [| t |]v ∩ Pv = ∅]

1	n	ρ
v
 U otherwise.
i	i  ρ


rem provers, e.g. SVC or PVS, if the sets [| ti |]v and Pv can be expressed as
quantifier-free formulas of first-order logic. In particular, such checks may
allow the evaluation of properties over infinite partial models. If P ∈ Pv,

6 In computing [| t |]v and [| φ |]v , we make the standard assumption that ρ is defined for all
ρ	ρ
free variables of t and φ that are contained in Xv.

then (11) computes Ps(Pv), where we identify the relation P v with its char-
acteristic function of type U n → B.	The interpretation of the remaining
connectives uses our propositional logic on Ps(B):


[| ¬φ |]v
def
¬s[| φ |]v

[| φ1 ∧ φ2 |]v
def
[| φ1
s
|]v ∧s [| φ2 |]v

[| ∃xφ |]v

def


u ∈Uv

ρ[x'→u],

where ρ[x '→ u] contains the same bindings as ρ, except that it binds x to u. In (14),it does not matter whether x is in Xv since ∃x binds the name x and thereby makes it “locally known” by extending the current environment ρ.
Example 3.7 Revisiting Example 3.6,let >v be the standard interpretation “strictly greater than” of > on Uv. The formula (6 + x) > 4 evaluates to U and the formula (0 ∗ x) > 2 evaluates to F. The reason for the former is that in (11) some instances of Pv(u1,..., un) hold (e.g. (6 + 0) >v 4), but not all of them (e.g. not (6 + 98) >v 4).
We show that our semantics for partial models coincides with the standard semantics of first-order logic for all “complete” partial models, which are un- derstood to be those partial models Mv, where Σv equals Σ. That is, these are just the ordinary models of first-order logic for the signature Σ.
Proposition 3.8 (Conservative extension of first-order logic) Let Mv   be a partial model for (Σ, U) such that Σv = Σ. For all φ and ρ, the set [| φ |]v is a singleton {d}, where d ∈ {T, F}. Moreover, the truth value d coincides with the usual first-order logic semantics of φ in the model Mv. 7
Proof.
Since Σv = Σ,a structural induction on t shows that [| t |]v is a singleton and that its sole element is the standard denotation of term t in environment ρ of model Mv.
Since all sets [| t |]v are singletons,(11) entails that [| P (t1,..., tn) |]v cannot
ρ	ρ
be U. From (11) and the fact that the truth value it contains matches the
standard first-order semantics,this match holds for all atomic formulas.
Finally,the functions ¬s, ∧s,and  s all restrict to the set

of maximal elements of Ps(B); on that set they coincide with the standard semantics of negation, conjunction, and nary disjunction: ¬B, ∧B, and B (respectively).
✷

7 I.e. d = T iff Mv |= φ holds for the standard satisfaction relation |= of first-order logic.

Refinement of views
One partial view can be a refinement of another partial view. Intuitively,this means that the refining view encodes more precise knowledge of a software system without contradicting the knowledge of the refined view. We say that a semantics of partial views is sound with respect to refinement if it supports this property of the refinement relation. In Definition 4.1 we formalize the idea that the refining view encodes more precise knowledge of the software system in question. In Proposition 4.5 below we show that the refining view does not contradict the knowledge of the refined view if the domains of se- mantic elements of the two views are the same and, thus, establish that our semantics is sound with respect to the refinement relation under the specified circumstances.
Definition 4.1 [Refinement of partial models] Let Mv1 and Mv2  be two partial models for (Σ, U) with signatures Σv1 = (Xv1 , Fv1 , Pv1 ) and Σv2 = (Xv2 , Fv2 , Pv2 ) (respectively). Then Mv1 refines Mv2 , denoted by Mv1 ±
Mv2 ,iff
the signature and universe of Mv1 extend those of Mv2 : Xv2 ⊆ Xv1 ,
Fv2 ⊆ Fv1 , Pv2 ⊆ Pv1 ,and Uv2 ⊆ Uv1 ; and
Mv1 conservatively extends the semantics of functions and predicates that are in the signature of Mv2 :
f ∈ Fv , ui ∈ Uv ⇒ fv2 (u1,..., un)= fv1 (u1,..., un)
P ∈ Pv , ui ∈ Uv ⇒ (u1,..., un) ∈ Pv2 iff (u1,..., un) ∈ Pv1 .
Example 4.2 The partial model Mv from Example 3.6 is refined by the par- tial model Mv' , where Σv' equals Σv, Uv' is the set of all natural numbers below 100, and +v' and ∗v' are the interpretations of addition and multipli- cation “modulo 100” (respectively). We can further refine Mv' to Mv'' by making x an element of Xv'' .
Lemma 4.3 The relation ± is a preorder on the set of all partial models for
Σ.
Proof. For sake of illustration, we only show the transitivity of condition
(16). Let Mv1 ± Mv2 and Mv2 ± Mv3 . Given f ∈ Fv3 and ui ∈ Uv3 , we
infer (i) ui ∈ Uv ,(ii) f ∈ Fv ,and (iii) fv3 (u1,..., un)= fv2 (u1,..., un) from
2	2

Mv2
± Mv3 . But then Mv1
± Mv2
and (i)–(iii) imply fv2 (u1,..., un) =

fv1 (u1,..., un),and so fv3 (u1,..., un)= fv1 (u1,..., un) follows.	✷
Example 4.4 [Unsound semantics] Our semantics is not sound in the sense

that Mv1
± Mv2
does not imply [| φ |]v2
± [| φ |]v1
for all φ. The latter is a

way of expressing the requirement that v1 has more precise knowledge of the
software system than v2,but that this knowledge is consistent with that of v2.

In Example 4.2,we saw that łv is refined by the model łv'' . The formula 8
Ex (98 < x)
evaluates to F in łv since 98 is the maximal element of Cv, but it evaluates to T in the refining model łv'' since it has 99 as a witness. Note that this could only happen because łv had a somewhat limited view of the natural numbers contained in the interval [0, 99].
Naturally, this unsoundness is a good thing as it allows us to detect incon- sistencies between these views even without having any policies regarding the priorities of these views. However,one can prove the soundness of our seman-

tics if all views share the same set of elements C. Then the sets [| t |]v
and

[| φ |]v computed by a partial model łv are sound approximations (supersets) of the corresponding sets computed by partial models that refine łv.
Proposition 4.5 (Soundness of semantics) Let łvi be partial models for (Σ, C) with signatures Σvi (i = 1, 2) such that łv1 ± łv2 and Cv1 = Cv2 . Let ρ be an environment for łv2 .
For all terms t over Σ, [| t |]v2 ± [| t |]v1 in Ps(Cv ).
ρ	ρ	2

For all formulas φ over Σ, [| φ |]v2 ± [| φ |]v1
in Ps(B).

ρ	ρ
Proof. Since Xv2 ⊆ Xv1 and Cv2 ⊆ Cv1 ,we conclude that ρ can be cast to an environment for łv1 as well.
We consider variables x:

If x /∈ Xv1 ,then x /∈ Xv2
as well,and so [| x |]v2 = Cv
= [| x |]v1 .

If x ∈ Xv , then [| x |]v1 equals {ρ(x)} which is contained in Cv . But
1	ρ	2
[| x |]v2 can only equal {ρ(x)} or Cv .

ρ
As for general terms t:
If f /∈ Jv1 , then f /∈ Jv2
[| f (t1,..., tn) |]v1 ,since Cv
2

as well, and so [| f (t1,..., tn |]v2
= Cv .

= Cv2 =

ρ	1	2
If f ∈ Jv1 ,we have two cases. First,if f ∈ Jv2 ,then (16) and Cv1 = Cv2
imply that the functions fv1 and fv1 are identical. Thus,
[| f (t1,..., tn) |]v2 = {fv2 (u1,..., un) | ui ∈ [| ti |]v2 }

ρ	ρ
≥ {f v2 (u1,..., un) | ui ∈ [| ti |]v1 }	by ind.
= {fv1 (u1,..., un) | ui ∈ [| ti |]v1 }	as łv

± łv

ρ	1	2
(19)	= [| f (t1,.	, tn) |]v1 .

Second, if f /∈ Jv , then [| f (t1,..., tn) |]v2 = Cv
is the least element of

2	ρ	2
Ps(Cv2 ),so there is nothing to show.
For formulas,the statement is clear for T.
Consider P (t1,..., tn).
8 As customary, we identify natural numbers with their corresponding constants in the logic.



If P /∈ Pv1 , then P /∈ Pv2
[| P (t1,..., tn) |]v1 .
as well, and so [| P (t1,..., tn |]v2
= U =

If P ∈ Pv1 ,we have two cases.
If P ∈ Pv2 , then (17) and Cv1
= Cv2
imply that the relations Pv1

and Pv1 are identical. Assume that [| P (t1,..., tn) |]v2
= T. Inspect-

ing (11) and noting that the [| ti |]v2 are supersets of [| ti |]v1 ,this implies
ρ	ρ
[| P (t1,..., tn) |]v1 = T as well. Similarly,from these inclusions and (11)
we infer that [| P (t1,..., tn) |]v2 equals F whenever [| P (t1,..., tn) |]v2 =
ρ	ρ
F. Finally,if [| P (t1,..., tn) |]v2 = U,there is nothing to show.
If P /∈ Pv ,then [| P (t1,..., tn) |]v2 = U,so there is nothing to show.
2	ρ
(v) For the remaining connectives ¬, ∧, and Ex we use induction and the fact that the corresponding operations ¬s, ∧s, and s are monotone on Ps(B).
✷

View semantics as consensus
As the semantics [| φ |]v is three-valued it might seem as if it cannot be com- puted using the techniques of standard first-order logic. However, we show

below how the semantics [| φ |]v
can be computed in such a standard man-

ner. This is accomplished by splitting this semantics into two two-valued
ones whose consensus recovers the original semantics. This method has al- ready been applied successfully by Bruns & Godefroid in [2] for partial Kripke structures and in [8] for modal transition systems in the context of model checking partial state spaces. 9 Specifically,we define two functions Opts and Pesss of type Ps(B) → Ps(B) by
B	B
Pesss(x) d=ef  x	Opts(x) d=ef  x.
Note that these functions leave T and F fixed,but promote U to a proper truth value:
Pesss(U)= F	Opts(U)= T.
These functions are used to cast U values,arising from the evaluation of atomic formulas P (t1,..., tn),to proper truth values; their duality is expressed in the equations
Pesss = ¬s ◦ Opts ◦ ¬s	Opts = ¬s ◦ Pesss ◦ ¬s.
Thus, we arrive at two semantics defined in Figure 1. Following Kelb [18], the treatment of negation switches the mode of evaluation from o(v) to p(v)
or vice versa. We now show that [| · |]v can be reconstructed from [| · |]o(v) and
ρ	ρ
[| · |]p(v) with set-theoretic union as a “consensus operator”.

9 Our results can be redeveloped for a first-order logic extended with a transitive-closure operator, a crucial extension of first-order logic to a realistic specification language.


[| P (t ,...,t ) |]o(v) d=ef Optv([| P (t ,...,t ) |]v)
1	n	ρ	1	n	ρ
[| ¬φ |]o(v) d=ef ¬s[| φ |]p(v)

[| φ1
∧ φ2
ρ
|]o(v) d=ef [| φ
s
ρ
|]o(v) ∧s [| φ2
|]o(v)

o(v) def
ρ
u∈ U
o(v)
ρ[x'→u]

[| P (t ,...,t ) |]p(v) d=ef Pessv([| P (t ,...,t ) |]v)
1	n	ρ	1	n	ρ
[| ¬φ |]p(v) d=ef ¬s[| φ |]o(v)

[| φ1
∧ φ2
ρ
|]p(v) d=ef [| φ
s
ρ
|]p(v) ∧s [| φ2
|]p(v)

p(v) def
ρ
u∈ U
p(v)
ρ[x'→u]

Fig. 1. Optimistic and pessimistic denotational semantics for first-order logic for- mulas in environment ρ and partial model Mv.

Proposition 5.1 (Kleene’s alignment operator [19]) Kleene’s alignment operation may be defined as a function of type Ps(B) × Ps(B) → Ps(B): for an input pair (x, y) it returns x in case that x equals y; otherwise, it returns U. This function is simply the binary union operator
∪ : Ps(B) × Ps(B) → Ps(B).
Proof. We have {T} ∪ {T} = {T} and {F} ∪ {F} = {F}. But x ∪ y equals
{F, T} whenever the set x is different from the set y in Ps(B).	✷
The reconstruction of [| · |]v as a consensus of [| · |]p(v) and [| · |]o(v) requires that
ρ	ρ	ρ
we prove the consistency of [| · |]p(v). The optimistic semantics [| · |]o(v), how-
ρ	ρ
ever,cannot offer such a consistency for a partial model łv in general,since
[| · |]o(v) records what kind of properties may hold for complete models that
refine łv: it is often the case that there exist such refining models łv' and

o(v')
o(v'')
o(v)	10

łv'' ,where [| φ |]ρ	= T and [| ¬φ |]ρ	= T,resulting in [| φ ∧ ¬φ |]ρ	= T.
In this context,it is useful to think of [| φ |]p(v) = T as an under approximation of “φ holds in all complete models that refine łv, but retain Cv”, whereas
[| φ |]o(v) = T is an over approximation of “φ holds in some complete models

that refines łv,but retains Cv”.
Theorem 5.2 (Consistency of [| · |]p(v)) Let łv
global formula, and ρ a local environment. Then

be a partial model, φ a

[| φ ∧ ¬φ |]p(v) = F.

10 This is the price we pay for defining the meaning of ∧ (∨) via ∧s (∨s) for p(v) (o(v)). One could conceivably use the ideas of [3] to improve on this.

Proof. By structural induction on φ. By definition, it suffices to show that

[| φ |]p(v) ∧s ¬s[| φ |]o(v) = F. Throughout the proof, we use that [| φ |]p(v)
and

ρ	ρ	ρ
[| φ |]o(v) always compute a value in B.
We compute [| T |]p(v) ∧s ¬s[| T |]o(v) = T ∧s ¬sT = F.
ρ	ρ
For atomic formulas, [| P (t ,...,t ) |]p(v) ∧s ¬s[| P (t ,...,t ) |]o(v) equals
1	n	ρ	1	n	ρ
Pesss(x) ∧s ¬sOpts(x)
where x equals [| P (t1,..., tn) |]v. But the conjunction in (25) cannot return U since its arguments are different from U. This conjunction can also not evaluate to T, for then both conjuncts evaluate to T, forcing x to be T and F at the same time.
For negated formulas,we compute
[| ¬φ' |]p(v) ∧s ¬s[| ¬φ' |]o(v) = ¬s[| ¬φ' |]o(v) ∧s [| ¬φ' |]p(v)	∧s comm.
ρ	ρ	ρ	ρ
= ¬s¬s[| φ' |]p(v) ∧s ¬s[| φ' |]o(v)	sem. of ¬
ρ	ρ
= [| φ' |]p(v) ∧s ¬s[| φ' |]o(v)	¬s idemp.
ρ	ρ
(26)	= F	by ind.
For conjunctions,the expression
[| φ1 ∧ φ2 |]p(v) ∧s ¬s[| φ1 ∧ φ2 |]o(v)
ρ	ρ
cannot be U. Assuming that it is T, we infer that both conjuncts are T.

Thus [| φi
|]p(v)
= T for i = 1, 2 and [| φ1
∧ φ2
|]o(v)
= F. Without loss of

generality, [| φ2
|]o(v) = F follows, and so [| ¬φ2
|]p(v) = T. Thus, we arrive at

[| φ2
∧ ¬φ2
|]p(v) = T,contradicting the induction hypothesis.

For existential formulas,the expression
[| Exφ |]p(v) ∧s ¬s[| Exφ |]o(v)
ρ	ρ
cannot be U. Assuming that it is T, we infer that both conjuncts are T. Thus




s


u∈Uv




u ∈Uv
p(v)
ρ[x'→u]

o(v)
ρ[x'→u]
= T


= F.

From the first equation we infer [| φ |]p(v)	= T for some u' ∈ Cv. From the
second equation,we conclude that [| φ |]o(v)	= F,rendering [| ¬φ |]p(v)	=

T, and so [| φ ∧ ¬φ |]p(v)
= T, contradicting the induction hypothesis

(which is quantified over all local environments).
✷
Corollary 5.3 (Consistency in entailment form) For all partial models
łv, global formulas φ, and local environments ρ, we have
[| φ |]p(v) = T	⇒	[| φ |]o(v) = T.
ρ	ρ


Proof. Proof by contradiction: If [| φ |]p(v) = T and [| φ |]o(v) = F,then чs[| φ |]o(v)
ρ	ρ	ρ

equals T, i.e. [| чφ |]p(v)
= T, and so [| φ Λ чφ |]p(v)
= T follows, contradicting

Theorem 5.2.	✷
It is rather obvious that Corollary 5.3 also implies Theorem 5.2, so these assertions are equivalent.
Theorem 5.4 (Semantics of consensus) Let łv be a partial model. For all global formulas φ and local environments ρ we have
[| φ |]v = [| φ |]p(v) ∪ [| φ |]o(v).
ρ	ρ	ρ
The proof of (32) requires several lemmas.
Lemma 5.5 (Distributivity of negation) For all x, y ∈ Ps(B), we have
чs(x ∪ y)= чsx ∪ чsy.
Proof. Since чs is a bijection, we have x /= y iff чsx /= чsy, so the LHS of (33) equals U iff its RHS equals U. Otherwise,both sides evaluate to чsx.✷
Lemma 5.6 (Consistent distributivity of conjunction) Let a, b, x, y ∈
Ps(B) \ {U}. If a = T implies b = T and if x = T implies y = T, then


Proof.
(a ∪ b) Λs (x ∪ y)= (a Λs x) ∪ (b Λs y).

Assume that the LHS of (34) is F. Then a ∪ b or x ∪ y evaluate to F.
If a ∪ b evaluates to F,then a and b equal F,and so a Λs x and b Λs y
evaluate to F. Therefore,the RHS of (34) evaluates to F as well.
If x ∪ y evaluates to F,we reason symmetrically.
Assume that the LHS is T. Then a ∪ b and x ∪ y evaluate to T. Thus, a, b, x, and y all evaluate to T. Therefore, the RHS of (34) evaluates to T as well.
Assume that the LHS evaluates to U. Then a ∪ b or x ∪ y evaluates to U.
If the RHS computes to F,we derive a contradiction:
First, if a ∪ b evaluates to U, then a /= b and x ∪ y /= F; the latter because the LHS equals U. But a /= b implies a /= T by assumption of the lemma. Thus, a equals F and so b equals T. Since the RHS equals F, we infer y = F from b = T. By assumption of the lemma, y = F implies x = F,contradicting x ∪ y /= F.
Second,if x ∪ y evaluates to U,we argue symmetrically.
If the RHS computes to T, then a Λs x and b Λs y evaluate to T. But then a, b, x, and y evaluate to T. Thus, the LHS computes to T, a contradiction.
✷
Lemma 5.7 (Consistent distributivity of disjunction) Given two fam- ilies (xi)i∈I and (yi)i∈I in Ps(B) \ {U} such that xi = T implies yi = T for all



i ∈ I, we have



  (xi ∪ yi)= 

s
xi


s
yi	.


Proof.
If the LHS of (35) is T,then xi0 ∪ yi0 = T for some i0 ∈ I,so xi0 = yi0 = T. The former implies  s xi = T, the latter implies  s yi = T. Therefore, the RHS of (35) computes to T as well.
If the LHS of (35) is F, then xi ∪ yi = F for all i ∈ I, so xi = yi = F for all i ∈ I. The former implies s xi = F, the latter implies s yi = F. Therefore,the RHS of (35) computes to F as well.
If the LHS of (35) is U, then there is some i0 ∈ I with xi0 ∪ yi0 = U, and for all i ∈ I,we have xi ∪ yi /= T.
Assume that the RHS of (34) equals F. Then  s xi and  s yi equals
F,meaning that all xi and yi are F,contradicting xi0 ∪ yi0 = U.
Assume that the RHS of (34) equals T. Then s xi and s yi equals T, meaning that there exist i1, i2 ∈ I with xi1 = T and yi2 = T. But xi1 = T implies yi1 = T, and so xi1 ∪ yi1 = T implies that the LHS equals T,a contradiction.
✷

Proof of Theorem 5.4
By structural induction on φ:
We have [| T |]v = {T} = {T}∪ {T} = [| T |]p(v) ∪ [| T |]o(v).
ρ	ρ	ρ
For atomic formulas,we compute [| P (t ,...,t ) |]p(v) ∪[| P (t ,...,t ) |]o(v) =
1	n	ρ	1	n	ρ
Pesss(x) ∪ Opts(x),where x equals [| P (t1,..., tn) |]v. But in Ps(B),we have

the equation

Pesss(x) ∪ Opts(x)= x.

For negated formulas,we use induction,Lemma 5.5,and the commutativity of ∪.
For conjunctions,we use induction,Corollary 5.3,and Lemma 5.6.
For existential formulas,we use induction,Corollary 5.3,and Lemma 5.7.

As remarked earlier [| · |]p(v) is consistent, whereas this is not true for [| · |]o(v)
ρ	ρ
in general. For complete models, however, it turns out that these semantics agree.
Proposition 5.8 (Semantics of complete models) Let łv be a partial
model for (Σ, C) with Σ = Σ. Then [| φ |]p(v) = [| φ |]o(v) for all global formulas
v	ρ	ρ
φ and local environments ρ.



Proof. We already remarked that [| φ |]v
∈ Ps(B) \ {U} holds for complete

models. But then Theorem 5.4 implies that [| φ |]p(v) is equal to [| φ |]o(v).	✷
ρ	ρ

Model-checking [| · |]v
We now show that the computation of [| · |]v, [| · |]p(v), and [| · |]o(v) can be re-
ρ	ρ	ρ
duced to the usual model-checking of models of first-order logic. One may
then approximate such standard checks with the techniques of abstract inter- pretation [5].

Expressive power of [| · |]p(v) and [| · |]o(v)
ρ	ρ
The results shown in previous sections entail that we may compute [| φ |]v via [| · |]p(v) or [| · |]o(v) only. Thus,it suffices to implement a model checker for any
ρ	ρ
of these semantics.
Theorem 6.1 (A first reduction of [| · |]v) Let łv be a partial model for
(Σ, C), φ a global formula, and ρ a local environment. Then
[| φ |]v = [| φ |]p(v) ∪ чs[| чφ |]p(v)
ρ	ρ	ρ
[| φ |]v = [| φ |]o(v) ∪ чs[| чφ |]o(v).
ρ	ρ	ρ
Proof. Because of the semantics of ч and the idempotency of чs,these equa- tions are equivalent. For the same reasons the first equation follows from (32).
✷

Negation normal forms for model checks
We decomposed the semantics of [| φ |]v into the consensus of a pessimistic and an optimistic semantics in order to avoid having to deploy a three-valued model checker. Our goal is to (re)use conventional first-order model checkers to the extent possible to verify arbitrary first-order formulas over partial views. How- ever, the treatment of negation makes the pessimistic and optimistic model checkers mutually dependent, preventing the use of standard tools for first- order-logic model checking. We can avoid this limitation by transforming φ to its negation normal form. Similarly to [2,8], this then moves the optimistic and pessimistic interpretations into the phase of model construction.
In presenting first-order logic, we assumed that ∨, →, and ∀x are derived syntactic notions. This assumption was intuitively justified by the familiar semantic DeMorgan laws for first-order logic. For each signature Σ and each φ of our logic,we now use these laws to compute the standard negation normal form T (φ),an element generated by the grammar
L ::= P (t, t, . . . , t) | чP (t, t, . . . , t)	// Literals
φ ::= ⊥ | T | L | φ Λ φ | φ ∨ φ | Exφ | ∀x φ.


We specify this translation φ → T (φ),where the domain of this translation is all expressions of (1) and the range is all expressions of (39),via (contextual) rewrite rules:
T ❀ T	P (t,..., t) ❀ P (t, . . . , t)
φ Λ φ ❀ φ Λ φ	Exφ ❀ Exφ 
чT ❀ ⊥	чP (t,..., t) ❀ чP (t, . . . , t)
ччφ ❀ φ	ч(φ Λ φ) ❀ чφ V чφ чExφ ❀ 6x чφ.
Example 6.2 For φ being ч[Ey (ч(y = 0) Λ ч(Ex [x < y + 1]))], we compute
T (φ) to be
6y [(y = 0) V Ex (x < y + 1)].
The denotational semantics for formulas T (φ) is given in Figure 2. The func- tion Vs is the binary version of	s. The semantics for 6x, the function	s,

	d=ef чs ◦  ◦  чs.
Notice that the semantics [| · |]n(v) always computes over P (B) \ {U} only, ex-
ρ	s
cept for the evaluation of [| P (t1,..., tn) |]v in the clauses for P (t1,..., tn) and
чP (t1,..., tn); such values get immediately lifted to proper truth values by
means of Pesss and чs Opts (respectively).	11 Observe that if [| φ |]v = U

then [| чφ |]v
should also evaluate to U, which is guaranteed by defining it as

чs[| φ |]v = чsU = U. So what we want in the definition of [| P (t ,...,t ) |]n(v)and

ρ
[| чP (t ,...,t ) |]n(v) is that when [| φ |]v = U,
1	n	ρ

1	n	ρ
ρ
[| P (t ,...,t ) |]n(v) = [| чP (t ,...,t ) |]n(v)

1	n	ρ	1	n	ρ
This requires us to define [| чP (t ,...,t ) |]n(v) in the manner given in Fig. 2.
1	n	ρ
We can show the adequacy of this semantics.
Theorem 6.3 (A second reduction of [| · |]v) Let łv be a partial model for Σ, φ a global formula, and ρ a local environment. Then
[| φ |]p(v) = [| T (φ) |]n(v).
ρ	ρ
Proof. By structural induction on φ. The cases where φ is not of the form чφ' follow directly by induction,given the rewrite rules for such formulas. Let φ be чφ'.
If φ' equals T,then [| чT |]p(v) = чsT = F = [| ⊥ |]n(v) = [| T (чT) |]n(v).
ρ	ρ	ρ

11 Also notice that [| ¬P (t ,...,t ) |]n(v) is not defined as ¬s[| P (t ,...,t ) |]n(v), in contrast
1	n	ρ	1	n	ρ
to [| ¬φ |]v which is defined as ¬s[| φ |]v .
ρ	ρ


[| ⊥ |]n(v) d=ef F
[| T |]n(v) d=ef T
[| P (t ,...,t ) |]n(v) d=ef Pesss([| P (t ,...,t ) |]v)
1	n	ρ	1	n	ρ
[| чP (t ,...,t ) |]n(v) d=ef чsOpts([| P (t ,...,t ) |]v)

1
[| φ1
[| φ1
n
Λ φ2 V φ2
ρ
|]n(v) d=ef [| φ
|]n(v) d=ef [| φ
s
1
|]n(v) Λs [| φ2
|]n(v) Vs [| φ2
n	ρ
|]n(v)
|]n(v)

[| Exφ |]n(v) d=ef

[| 6xφ |]n(v) d=ef


u ∈ Uv




u ∈ Uv
n(v)
ρ[x'→u]

n(v)
ρ[x'→u]

Fig. 2. Denotational semantics for first-order logic formulas in negation normal form, evaluated in environment ρ and partial model Mv.

If φ' equals P (t1,..., tn),then
[| чP (t1,..., Pn) |]p(v) = чs[| P (t1,..., tn) |]o(v)

ρ




If φ' equals φ1 Λ φ2,then
ρ
= чsOpts([| P (t1,..., tn) |]v)
= [| T (чP (t1,..., tn)) |]n(v).

[| ч(φ1 Λ φ2) |]p(v) = чs[| φ1 Λ φ2 |]o(v)
ρ	ρ
= чs([| φ1 |]o(v) Λs [| φ2 |]o(v))
ρ	ρ

= чs[| φ1 |]o(v) Vs чs[| φ2 |]o(v)
sem. law

ρ	ρ
= [| чφ1 |]p(v) Vs [| чφ2 |]p(v)
ρ	ρ

= [| T (чφ1) |]n(v) Vs [| T (чφ2) |]n(v)
by ind.


ρ
= [| T (ч(φ1 Λ φ2)) |]n(v)
ρ
rewrite rule.

Finally,if φ' is of the form Exφ'',then [| чEx φ'' |]p(v) = чs[| Ex φ'' |]o(v)

ρ

= чs

= чs

s
s


u∈Uv




u ∈Uv
ρ

''  o(v)
ρ[x'→u]

s  s	''  o(v)
ρ[x'→u]



чs idemp.

=
u∈Uv
s	''  o(v)
ρ[x'→u]
def. of  s



s
=
u∈Uv


=
u∈Uv

''  p(v)
ρ[x'→u]

[| T (чφ'') |]n(v)



by ind.



= [| 6xT (чφ'')) |]n(v)
= [| T (чЕx φ'') |]n(v)

rewrite rule.
✷



Model construction
We emphasize the significance of Theorem 6.3. In order to compute [| φ |]p(v)
over a partial model łv for Σ, we may instead performa conventional model

check for a standard model łn
of first-order logic. This model is obtained

from the partial model łv by (i) extending its signature Σ with complemen- tary predicate symbols P for each P ∈ Pv; and by (ii) letting the interpreta-

tions Pv
v
and P
be nary relations over P (C ). For u ,...,u 
∈ P (C ), we

n	n
set
s	v	1
n	s	v

Pv d=ef {(u ,...,u ) ∈  P (C ) | Pesss([| P (u ,...,u ) |]v)= T}
Pv d=ef {(u ,...,u ) ∈   P (C ) | чsOpts([| P (u ,...,u ) |]v)= T}.
In (45) and (46),we extended the definition of [| · |]v to elements of Ps(Cv) by

setting [| u |]v d=ef u. The sets Pv and Pv
are well defined since the expressions

ρ	n	n
[| P (u1,..., un) |]v evaluate to the same truth value,independent of the choice
of ρ. Observe that the consistency of this model is represented by the fact that
Pv ∩ Pv = ∅	(P ∈ P).
n	n
This is guaranteed since Pesss(x)= T and Opts(x)= T imply x = T and x = F
(respectively). However,
Pv ∪ Pv = {(u ,...,u ) ∈  P (C ) | [| P (u ,...,u ) |]v /= U}
is different from  Ps(Cv) in general. Having constructed the model łn in
this manner, the semantics in Figure 2 can now be seen as a specification
of a conventional first-order-logic model checker for [| · |]p(v). In summary, we have reduced our three-valued model-checking problem to two two-valued model-checking problems of ordinary first-order logic by adding complemen- tary atomic predicates and by lifting their interpretations from the domain of the original partial model to its Smyth powerdomain. The latter domain can then be approximated with the techniques of abstract interpretation [5].

Related work
In [2], G. Bruns and P. Godefroid develop a three-valued version of model- checking models of computation tree logic (CTL). The models are similar to conventional Kripke structures,except that state propositions can take on val- ues T, F,or U. They have a notion of refinement and show that their temporal logic semantics is sound and complete with respect to this refinement. With each three-valued model they associate two Kripke structures, an optimistic and a pessimistic one, allowing them to implement their three-valued model- checking problem as two two-valued model-checking problems for CTL (over Kripke structures). In [3], this work is being extended to generalized model checking (GMC), improving the precision (and increasing the complexity) of their initial semantics,and implementing GMC via (finite-state) automata on infinite words. 12
In [11,8], the contributions of [2] are redeveloped for (Kripke) modal tran- sition systems (MTSs). In MTSs transitions may take on any value T, F, or U — meaning that such transitions are guaranteed, impossible, and possible (respectively) [21,20].
In [12], partial state-machines are modeled as MTSs and a multiple-view semantics and its model checker are derived from the property semantics of MTSs in [11].
In [6], Cousot & Cousot use two abstraction functions α∀ and α∃ for the same concretization function of an abstract interpretation to systematically derive a branching-time semantics from a linear trace semantics. Similar to Pesss and Opts,the abstraction functions α∀ and α∃ are dual with respect to complementation.
In program analysis,three-valued models of first-order logic have been used for the safe abstraction of “shape invariants” [27] and the verification of safety properties of Java programs [29].
Our views łv can be partial in that they may not have interpretations for certain function or predicate symbols, but apart from that we assumed that views have the same representation of a specification. As D. Jackson points out,this may not always be appropriate [13].
The tool xlinkit analyzes distributed XML documents for possible in- consistencies, based on rules written in first-order logic [23]. Our semantic framework could possibly be used as a foundation for such a tool.
D. Jackson wrote the object modelling language Alloy [14] as a lightweight tool for specifying relational models of software artifacts. Primitive types are interpreted as finite sets without any algebraic structure. Models written in Alloy can be automatically analyzed with the Alloy Constraint Analyzer (for- merly known as “Alcoa” [15]) in two modes. First,one can check inconsistency

12 The precision of our semantics can be improved in the same manner as carried out in [3], and it would be of interest to see whether such a semantics of first-order logic could be implemented with suitable (finite-state) automata.


(= overspecification) of multiple specification components and their interac- tion through the checking of invariants. Second,one can refute properties (= underspecification) by computing a counterexample to an assert statement. Since the full language (first-order relational logic with a transitive closure operator) is undecidable, both modes run in a user-specified scope, the max- imal size of primitive types. This approach is partial in that the inability of generating a counterexample within a given scope means that the status of inconsistency and property refutation is unknown (respectively).
S. Guerra [10] develops a framework for specifications of software artifacts, where such specifications have defaults and allow for exceptions stemming from the reuse or evolution of system demands. This framework is cast in the machinery of institutions [9]. Specifications are written in linear-time temporal logic [26] and a non-monotonic semantics for this logic is defined based on default institutions. A distance between interpretation morphisms induces a preferential preorder between models that is used to define that semantics. The signature is split into observable actions (where the distance enforces consistency across models) and attributes (where the distance checks for consistency across models).
M. Chechik and S. Easterbrook [7] merge multiple viewpoints of a software system expressed as partial state-machines.	Different viewpoints need not recognize the same vocabulary of observables. Their models are multi-valued Kripke structure over a quasi-boolean lattice. Their semantics for the temporal logic CTL evaluates a state and a formula to an element of the merged lattice. VDM [16] is a model-based specification language for software systems. Unlike specification languages such as Z, VDM allow for the specification of partial functions and its semantics is essentially Kleene’s strong interpretation of propositional logic. Note that our framework assumes that functions are total and that the only source of partiality resides in the “lack of knowledge”
of how to interpret certain function or predicate symbols.
In [22], J. M. Morris and A. Bunkenburg use a strong three-valued inter- pretation of equality which — unlike P (=B) from Example 3.3 — returns U only if both its arguments are U. They combine this equational theory 13 with a typed logic of partial functions (LPF [17]) to obtain a system for equational reasoning in the presence of partial functions — the specifications of programs. In [4] powerdomains are used to systematically derive the relational se-
mantics of the standard staple of database operations.

Conclusions
We generalized the standard notions of models and semantics of first-order logic to partial models that may not have any information about certain func- tion symbols and predicate symbols at their disposal. At the model-theoretic

13 As they note, its semantics is not monotone over Ps(B).


level,this is achieved via the Smyth powerdomain over the semantic universe of elements. At the logical level,we accomplish this via the Smyth powerdomain over the standard two-valued booleans. A refinement notion is developed and its soundness is proved for a fixed set of semantic elements. Standard models and semantics of first-order logic are subsumed by our framework as “com- plete” models, where all information is present. We decompose our seman- tics into a consensus (the union of the Smyth powerdomain) of an optimistic and a pessimistic semantics. That way, one can compute this semantics as a standard model check in first-order logic over a model lifted by the Smyth powerdomain,where the signature is extended with a complementary symbol for each predicate symbol in the original signature.

Acknowledgments
We wish to thank G. Bruns, P. Godefroid, R. Jagadeesan, and D. Schmidt. Their contributions to the semantics of partial models for temporal logics en- abled us to carry out the technical work presented in this paper. We thank M. Mislove for his invitation to give a talk at the special session “Model checking” at MFPS’01 and for organizing such a stimulating meeting. S. Guerra made helpful comments on drafts of this paper.

References

S. Abramsky and A. Jung. Domain theory. In S. Abramsky, D. M. Gabbay, and
T. S. E. Maibaum, editors, Handbook of Logic in Computer Science, volume 3, pages 1–168. Oxford Univ. Press, 1994.
G. Bruns and P. Godefroid. Model Checking Partial State Spaces with 3-Valued Temporal Logics. In Proceedings of the 11th Conference on Computer Aided Verification, volume 1633 of Lecture Notes in Computer Science, pages 274–287. Springer Verlag, July 1999.
G. Bruns and P. Godefroid. Generalized Model Checking: Reasoning about Partial State Spaces. In Proceedings of CONCUR’2000 (11th International Conference on Concurrency Theory), volume 1877 of Lecture Notes in Computer Science, pages 168–182. Springer Verlag, August 2000.
P. Buneman, A. Jung, and A. Ohori. Using powerdomains to generalize relational databases. Theoretical Computer Science, 91(1):23–55, 1991.
P. Cousot and R. Cousot. Abstract interpretation: a unified lattice model for static analysis of programs. In Proc. 4th ACM Symp. on Principles of Programming Languages, pages 238–252. ACM Press, 1977.
P. Cousot and R. Cousot. Temporal abstract interpretation. In Conference Record of the 27th Annual ACM SIGPLAN-SIGACT Symposium on Principles


of Programming Languages, pages 12–25, Boston, Mass., January 2000. ACM Press, New York, NY.
S. M. Easterbrook and M. Chechik. A Framework for Multi-Valued Reasoning over Inconsistent Viewpoints. In Proceedings, 23rd International Conference on Software Engineering (ICSE-01), Toronto, Canada, May 12-19 2001. IEEE Computer Society Press. To appear.
P. Godefroid, M. Huth, and R. Jagadeesan. Abstraction-based Model Checking using Modal Transition Systems. In Proceedings of the International Conference on Theory and Practice of Concurrency, Lecture Notes in Computer Science. Springer Verlag, August 2001. To appear.
J. A. Goguen and R. M. Burstall. Institutions: Abstract model theory for specification and programming. Journal of the ACM, 39(1):95–146, January 1992.
S. Guerra. Distance Functions for Defaults in Reactive Systems. In T. Rus, editor, Proc. of the 8th Int. Conf. on Algebraic Methodology and Software Technology (AMAST 2000), volume 1816 of Lecture Notes in Computer Science, pages 26–40, Iowa City, Iowa, May 2000. Springer Verlag.
M. Huth, R. Jagadeesan, and D. Schmidt. Modal transition systems: a foundation for three-valued program analysis. In D. Sands, editor, Proceedings of the European Symposium on Programming (ESOP’2001), volume 2028 of LNCS, pages 155–169, Genova, Italy, April 2001. Springer Verlag.
M. Huth and S. Pradhan. Aspect-driven Property Verification of Inconsistent System Descriptions. Technical Report KSU-CIS-TR-2001-1, Computing & Information Sciences, Kansas State University, Manhattan, Kansas, May 2001. Extended 12-page abstract sunmitted to FSTTCS 2001.
D. Jackson. Structuring Z Specifications With Views. ACM Trans. on Software Engineering and Methodology, 4(4):365–389, October 1995.
D. Jackson. Alloy: A Lightweight Object Modelling Language. Technical Report TR-797, Laboratory of Computer Science, Massachusetts Institute of Technology, 28 July 2000.
D. Jackson, I. Schechter, and I. Shlyahter. Alcoa: The Alloy Constraint Analyzer. In Proc. Int’l Conf. on Software Engineering 2000 (ICSE 2000), pages 730–733. IEEE Computer Society Press, 2000.
C. B. Jones. Systematic Software Development Using VDM. Prentice-Hall, Upper Saddle River, NJ 07458, USA, 1990.
C. B. Jones and C. A. Middelburg. A typed logic of partial functions reconstructed classically. Acta Informatica, 31:399–430, 1994.
P. Kelb. Model checking and abstraction: a framework preserving both truth and failure information. Technical Report OFFIS, University of Oldenburg, Germany, 1994.


S. C. Kleene. Introduction to Metamathematics. Van Nostrand, 1952.
K. G. Larsen. Modal Specifications. In J. Sifakis, editor, Automatic Verification Methods for Finite State Systems, number 407 in Lecture Notes in Computer Science, pages 232–246. Springer Verlag, June 12–14 1989. International Workshop, Grenoble, France.
K. G. Larsen and B. Thomsen. A Modal Process Logic. In Third Annual Symposium on Logic in Computer Science, pages 203–210. IEEE Computer Society Press, 1988.
J. M. Morris and A. Bunkenburg. E3: A Logic for Reasoning Equationally in the Presence of Partiality. Science of Computer Programming, 34(2):144–158, 1999.
C. Nentwich, W. Emmerich, and A. Finkelstein. xlinkit: links that make sense. Technical report, Department of Computer Science, University College of London, 2001.
B. Nuseibeh and S. M. Easterbrook. The Process of Inconsistency Management: A framework for understanding. In Proceedings of the First International Workshop on the Requirements Engineering Process (REP’99), 2-3 September 1999.
B. Nuseibeh, J. Kramer, and A. Finkelstein. A Framework for Expressing the Relationships Between Multiple Views in Requirements Specification. IEEE Transactions on Software Engineering, 20(10):760–773, October 1994.
A. Pnueli. The temporal logic of programs. In Proc. of the 18th IEEE Symposium on the Foundations of Computer Science, pages 46–57, 1977.
M. Sagiv, T. Reps, and R. Wilhelm. Parametric Shape Analysis via 3- Valued Logic. In Proceedings of the 26th ACM SIGPLAN-SIGACT Symposium on Principles of programming languages, pages 105–118, January 20-22, San Antonio, Texas 1999.
M. Smyth. Powerdomains. Journal of Computer and Systems Science, 16:23– 36, 1977.
Eran Yahav. Verifying safety properties of concurrent Java programs using 3-valued logic. ACM SIGPLAN Notices, 36(3):27–40, March 2001.
