Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 308 (2014) 87–107
www.elsevier.com/locate/entcs
Strategies as Concurrent Processes
Simon Castellana Jonathan Haymana Marc Lassonb Glynn Winskela
a Computer Laboratory, University of Cambridge, UK
b INRIA Paris-Rocquencourt, PiR2, Univ Paris Diderot, Sorbonne Paris Cit´e F-78153, Le Chesnay, France

Abstract
Concurrent strategies are shown to support operations yielding an economic yet rich higher-order con- current process language, which shares features both with process calculi and nondeterministic dataflow. Its operational semantics and ‘may and must’ equivalence require that we take internal (neutral) moves seriously, leading to the introduction of ‘partial strategies’ which may contain neutral moves. Through partial strategies, we can present a transition semantics for a language of strategies and can formulate their ‘may and must’ behaviour. While partial strategies compose, in a way extending that of strategies, in general composition introduces extra neutral moves; in particular, copy-cat is no longer strictly an identity
w.r.t. composition. However, a simple extension of concurrent strategies (with stopping configurations) maintains the fact that they form a bicategory while still capturing ‘may and must’ behaviour.
Keywords: Concurrent game, event structures, bicategory

Introduction
There are several reasons for extending games and strategies, with behaviour based on trees, to concurrent games and strategies, based on event structures — the con- current analogue of trees. One reason is to provide a foundation for a generalized domain theory, in which concurrent games and strategies take over the roles of do- mains and continuous functions. The motivation is to repair the divide between denotational and operational semantics and tackle anomalies like nondeterministic dataflow, which are beyond traditional domain theory. Another is that strategies are as potentially fundamental as relations and functions. It is surely because of our limited mental capacity, and not because of its unimportance, that the mathe- matical concept of strategy has been uncovered relatively late. It is hard to think about the successive contingencies involved in playing a game in the same way that is hard to think about interacting processes. Developing strategies in the extra generality demanded by concurrency reveals more clearly their essential nature and enables us to harness computer-science expertise in structure and concurrency in
http://dx.doi.org/10.1016/j.entcs.2014.10.006
1571-0661/© 2014 Elsevier B.V. All rights reserved.

their understanding and formalization.
The extra generality of concurrency reveals new structure and a mathematical robustness to the concept of strategy, in particular showing strategies are essentially special profunctors [19]. Profunctors themselves provide a rich framework in which to generalize domain theory, in a way that is arguably closer to that initiated by Dana Scott than game semantics [9,2]. However, the mathematical abstraction of profunctors comes at a price: it can be hard to give an operational reading to denotations as profunctors. There are examples of semantics of higher-order process languages and “strong correspondence” where elements of profunctor denotations correspond to derivations in an operational semantics [11,15]. But in general it is hard to extract operational semantics from the profunctor denotations alone because they have abstracted too far.
Connections between forms of strategy and process models have been the sub- ject of a large body of prior research — see e.g. [8,6,7]. In this paper, we begin a study of concurrent strategies from the perspective of concurrent processes, con- sidering how concurrent games and strategies are objects which we can program. They are shown to support operations yielding an economic yet rich higher-order concurrent process language, which shares features both with process calculi and nondeterministic dataflow. The operations allow recursion to be interpreted using a trace and novel duplication operation.
Indeed, seen from a concurrent-process perspective, in some respects concurrent strategies have abstracted too far. Both in obtaining a transition semantics for the language of strategies and in analysing its behaviour w.r.t. ‘may and must’ testing, we need to take internal (neutral) moves, introduced in the composition of strategies, seriously. Through the more refined model of partial concurrent strategies we obtain a correspondence between events of a strategy and derivations of atomic steps in a transition semantics. Via partial strategies we can justify a simple extension of concurrent strategies (with stopping configurations) which maintains the fact that they form a bicategory, while still capturing ‘may and must’ behaviour.
Event structures and their maps
An event structure comprises (E, Con, ≤), a set E of events which are partially ordered by ≤, the causal dependency relation, and a nonempty consistency relation Con consisting of finite subsets of E, which satisfy
{e′ ∣ e′ ≤ e} is finite for all e ∈ E	{e}∈ Con for all e ∈ E
Y ⊆ X ∈ Con =⇒ Y ∈ Con	X ∈ Con & e ≤ e′ ∈ X =⇒ X ∪ {e}∈ Con.

The conﬁgurations, C∞(E), of an event structure E consist of those subsets x ⊆ E which satisfy ∀X ⊆ x. X is finite ⇒ X ∈ Con (consistency ) and ∀e, e′. e′ ≤ e ∈ x =⇒ e′ ∈ x. (down-closure). Often we shall be concerned with just the finite configurations of an event structure. We write C(E) for the ﬁnite configurations of an event structure E.

We say an event structure is elementary when the consistency relation consists of all finite subsets of events. Two events which are both consistent and incomparable
w.r.t. causal dependency in an event structure are regarded as concurrent. In games the relation of immediate dependency e d e′, meaning e and e′ are distinct with e ≤ e′ and no event in between, will play a very important role. For X ⊆ E we write [X] for {e ∈ E ∣ ∃e′ ∈ X. e ≤ e′}, the down-closure of X; note if X ∈ Con, then [X] ∈ Con. We write [a] for [{a}] where a ∈ E. For configurations x, y, we use
e
x−⊂y to mean y covers x, i.e. x ⊂ y with nothing in between, and x−—⊂ y to mean
e
x ∪ {e} = y for an event e ∉ x. We sometimes use x−—⊂ , expressing that event e is
e
enabled at configuration x, when x−—⊂ y for some configuration y.
Certain ‘structural’ maps of event structures, which have a long history [14], play a key role in the development of nondeterministic concurrent strategies. A map of event structures f ∶ E → E′ is a partial function f ∶ E ⇀ E′ such that fx ∈ C∞(E′) for all x ∈ C∞(E), and for all e1, e2 ∈ x

f (e1)= f (e2) & f (e1),f (e1) both defined =⇒ e1 = e2 .

Above, it is sufficient to restrict to finite configurations. Note that, when f is total, it restricts to a bijection x ≅ fx for any x ∈ C∞(E). A total map is rigid when it preserves causal dependency.
A map f ∶ E → E′ of event structures has partial-total factorization as a com-
p	t	′
position E—→E ↓ V —→E where V =def {e ∈ E ∣ f (e) is defined} is the domain of
definition of f ; the event structure E↓V =def (V, ≤V , ConV ), where v ≤V v′ iff v ≤ v′ & v, v′ ∈ V and X ∈ ConV iff X ∈ Con & X ⊆ V ; the partial map p ∶ E → E ↓ V acts as identity on V and is undefined otherwise; and the total map t ∶ E ↓ V → E′, called the deﬁned part of f , acts as f . The event structure E↓V is the projection of E to V .
It shall be convenient to construct event structures using rigid families.
Proposition 2.1 Let Q be a non-empty family of ﬁnite partial orders closed under rigid inclusions, i.e. if q ∈ Q and q′ ↪ q is a rigid inclusion (regarded as a map of elementary event structures) then q′ ∈ Q. The family Q determines an event structure Pr(Q) =def (P, ≤, Con) as follows:
the events P are primes, i.e. ﬁnite partial orders in Q with a top element;
the causal dependency relation p′ ≤ p holds precisely when there is a rigid inclusion from p′ ↪ p;
a ﬁnite subset X ⊆ P is consistent, X ∈ Con, iff there is q ∈Q and rigid inclusions
p ↪ q for all p ∈ X.
If x ∈ C(P ) then ⋃ x, the union of the partial orders in x, is in Q. The function x ↦ ⋃ x is an order-isomorphism from C(P ), ordered by inclusion, to Q, ordered by rigid inclusions.
Pullbacks of total maps Maps f ∶ A → C and g ∶ B → C have pullbacks in the category of event structures, and are simple to describe in the case where f and

g are total. We give a pullback object P along with projections π1 and π2 as shown.

z
A	B
f zz~gs
C
In this situation, finite configurations of P correspond to the composite bijections
θ ∶ x ≅ fx = gy ≅ y

between configurations x ∈ C(A) and y ∈ C(B) s.t. fx = gy for which the transitive relation generated on θ by (a, b)≤ (a′, b′) if a ≤A a′ or b ≤B b′ is a partial order; the correspondence taking z ∈ C(P ) to the composite bijection π1z ≅ fπ1z = gπ2z ≅ π2z respects inclusion.

Affine maps
In considering the dynamics of processes we shall need to relate a process to a process it may become. For this we generalize the earlier structural maps of event structures to affine maps, in which we need no longer preserve the empty configuration [16].
Definition 2.2 Let A be an event structure. Let x ∈ C∞(A). Write A/x for the event structure which remains after the occurrence of x. Precisely, A/x comprises
events, {a ∈ A ∖ x ∣ x ∪ [a]A ∈ C∞(A)} ,
consistency relation, X ∈ Con iff X ⊆fin A/x & x ∪ [X]A ∈ C∞(A), and
causal dependency, the restriction of that on A.
We extend the notation to configurations regarding them as elementary event structures. If y ∈ C∞(A) with x ⊆ y then by y/x we mean the configuration y ∖ x ∈ C∞(A/x). In the case of a singleton configuration {a} of A — when a is an initial event of A — we shall often write A/a and x/a instead of A/{a} and x/{a}.
An affine map of event structures f from A to B comprises a pair (f0, f1) where f0 ∈C(B) and f1 is a map of event structures f1 ∶ A → B/f0. It determines a function from C(A) to C(B) given by fx = f0 ∪ f1x for x ∈ C(A). The allied f0 and f1 can be recovered from the action of f on configurations: f0 = f ∅ and f1 is that unique map of event structures f1 ∶ A → B/f ∅ which on configurations x ∈ C(A) returns fx/f ∅. It is simplest to describe the composition gf of affine maps f = (f0, f1) from A to B and g = (g0, g1) from B to C in terms of its action on configurations: the composition takes a configuration x ∈C(A) to g(f x). Alternatively, the composition gf can be described as comprising (g0 ∪g1f0, h) where h is that unique map of event structures h ∶ A → C/(g0 ∪ g1f0) which sends x ∈ C(A) to g1(f0 ∪ f1x)/g1f0. Note that traditional maps can be identified with those special affine maps (f0, f1) in which f0 = ∅. We reserve the term ‘map’ for the traditional structural maps of event structure and shall say explicitly when a map is affine.

Concurrent games and strategies
A game is represented by an event structure A in which an event a ∈ A carries a polarity pol (a), + for Player and − for Opponent. Maps and affine maps of event structures extend to event structures with polarity: their underlying partial functions on events are required, where defined, to preserve polarity. A number of constructions on games will play an important role in the coming semantics: Dual A⊥, of an event structure with polarity A is a copy of the event structure A with a reversal of polarities.
Simple parallel composition A  B , by juxtaposition. Its unit is the empty game
∅. More generally, we can define,  i∈IAi, the simple parallel composition of a indexed family of games, in which the set of events comprises the disjoint union
⋃1≤i≤m {i}× Ai.
Sums and recursive definitions Sums Σi∈IAi of an indexed family of games, which coincide with coproducts in the categories of event structures, are obtained in a similar way to simple parallel compositions, but now with events from dis- tinct components being inconsistent (i.e. no set in the consistency relation contains elements from distinct components). We shall not make explicit use of recursively- defined games, but they are dealt with in exactly the same way as recursively-defined event structures [14].




A bicategory of games and strategies

A (nondeterministic concurrent) strategy in a game A is represented by a total map of event structures σ ∶ S → A which preserves polarities and is
a	s
Receptive: if σx−—⊂ & pol A(a)=− then there is unique s ∈ S s.t. x−—⊂ & σ(s)= a;
Innocent: if s dS s′ & (pol (s)=+ or pol (s′)= −) then σ(s) dA σ(s′).
Receptivity expresses that Player cannot hinder moves of Opponent, while in- nocence says a strategy should only adjoin immediate causal dependencies of the form ⊖ d ⊕. A map between strategies from σ ∶ S → A to σ′ ∶ S′ → A is a total map f ∶ S → S′ of event structures with polarity such that σ = σ′f . Accordingly, the strategies are isomorphic iff f is an isomorphism of event structures.
The conditions of receptivity and innocence are necessary and sufficient to ensure that the copy-cat strategy behaves as identity w.r.t. composition [12], which we now proceed to define.
We follow Conway and Joyal, and define a strategy from a game A to a game B, written σ ∶ A + B ,¸as a strategy σ in the game A⊥  B.
Let σ ∶ S → A⊥  B, τ ∶ T → B⊥  C be strategies. Their composition is defined via the pullback drawn below. Ignoring polarities, the composite partial map has defined part T ⊙S, which yields the composition of strategies τ ⊙σ ∶ T ⊙S → A⊥  C

once polarities are reinstated.


π A ,T	A τ
v˛
P	A  B  C


  A¸C

π1 z	σ C
S  C

Let A be a game. The copy-cat strategy from A to A is a total map γA ∶ CCA → A⊥  A, based on the idea that Player moves, of +ve polarity, always copy previous corresponding moves of Opponent, of −ve polarity. For c ∈ A⊥  A we use c to mean the corresponding copy of c, of opposite polarity, in the alternative component. Define CCA to comprise the event structure with polarity A⊥  A together with extra causal dependencies c ≤CCA c for all events c with pol A⊥ A(c)= +. A finite subset of CCA is consistent if its down-closure is consistent in A⊥ A.
The characterisation of configurations of CCA reveals an important partial order on configurations of A. Let x and y be configurations of an event structure with polarity. Write x ⊆− y to mean x ⊆ y and pol (y ∖ x) ⊆ {−}, i.e. the configuration y extends the configuration x solely by events of −ve polarity. Similarly, x ⊆+ y means x ⊆ y and pol (y ∖ x) ⊆ {+}. Use ⊇− to denote the converse order to ⊆−. Define the Scott order on configurations by x ⊑ y iff x ⊇− ⋅ ⊆+ ⋅ ⊇− ⋯ ⊇− ⋅ ⊆+ y. Then, ⊑ is a partial order and part of a factorization system: if x ⊑ y then ∃!z. x ⊇− z ⊆+ y.
Proposition 3.1 [19] Let A be a game. Then, x ∈ C(CCA)  iff x2 ⊑A x1 , where
x1 ∈ C(A⊥) and x2 ∈ C(A) are the projections of x ∈ C(A⊥  A) to its components.
Theorem 3.2 [19] Strategies σ ∶ S → A correspond to discrete ﬁbrations denoted
σ“ ∶ (C(S), ⊑S)→ (C(A), ⊑A) , preserving ⊇−, ⊆+ and ∅.
The theorem says we can view strategies in a game as (certain) discrete fibra- tions, so equivalently as presheaves over finite configurations with the Scott order. In particular, a strategy from a game A to a game B corresponds to a presheaf over (C(A⊥  B), ⊑A⊥  B )≅ (C(A), ⊑A)op × (C(B), ⊑B), so to a profunctor from (C(A), ⊑A) to (C(B), ⊑B). This correspondence yields a lax functor from strategies to profunc- tors. The view of strategies as (special) profunctors — explained further in [19] — will guide our later work.
We obtain a bicategory of concurrent games and strategies in which the ob- jects are event structures with polarity — the games, the arrows from A to B are strategies σ ∶ A + B  ¸and the 2-cells are maps of strategies. The vertical composi- tion of 2-cells is the usual composition of maps. Horizontal composition is given by the composition of strategies ⊙ (which extends to a functor on 2-cells via the universality of pullback).
A strategy in the game A⊥  B corresponds to a strategy in the game (B⊥)⊥  A⊥. Hence a strategy A + B  ¸corresponds to a dual strategy B⊥ + A  ⊥¸. The bicategory is rich in structure, in particular, it is compact-closed (so has a trace, a feedback operation).

Operations on strategies and duplication
Beyond composition there are many other useful operations on strategies. Several of these have appeared previously in, for example, establishing determinacy [3] or the value theorem for games with pay-off [4] where proofs often hinge on constructing appropriate strategies.
We can form the sum of strategies []i∈I σi of a family of strategies σi ∶ Si → A, i ∈ I, in a common game A [4]. This is formed as the sum of the event structures Si but where the initial −ve events are identified to maintain receptivity. A sum of strategies only commits to a particular component strategy once a Player move is made there. The empty sum ı essentially comprises the initial segment of the game A consisting of all the initial −ve events of A.
S′ 	 S¸

The pullback of a strategy σ across a (possibly partial)
map f of event structures is itself a strategy f ∗σ [18]:


f ∗σ J 
Jσ 

A	 B¸. 
f
This operation can adjoin extra events and causal links to the original strategy; it subsumes, for example, operations on strategies in which we prefix an initial event.
We shall also use a previously unnoticed strategy δA that exists from a game A to A  A, and expresses a form of duplication. Like copy-cat it introduces extra ‘causal wiring’ but its definition is much more subtle, though is easy to describe in special cases. For example if the game A comprises a single Player move ⊕ the

strategy δA ∶ A + A  ¸A takes the form
⊖
, ⊕˛ . ,A similar construction applies in the
s ⊕z 

case where all the moves of a game are that of Player. If the game A comprises
a single Opponent move ⊖ then δA ∶ A + A  ¸A takes the form ⊕¸ ⊖7, where the
⊕¸  ⊖7
wiggly line indicates the inconsistency between the two Player moves.
Duplication The definition of δA ∶ A + A  ¸A in general is via rigid families. For each triple (x, y1, y2), where x ∈ C(A⊥) and y1, y2 ∈ C(A), which is balanced, i.e.
∀a ∈ y1 ∪ y2. pol A(a)=+ =⇒ a ∈ x and ∀a ∈ x. pol A⊥ (a)=+ =⇒ a ∈ y1 or a ∈ y2,
and choice function χ ∶ x+ → {1, 2} , from the positive events of x denoted by x+, such that χ(a) = 1 =⇒ a ∈ y1 and χ(a) = 2 =⇒ a ∈ y2, the order q(x, y1, y2; χ) is defined to have underlying set {0}× x ∪ {1}× y1 ∪ {2}× y2 with order generated by that inherited from A⊥  A  A together with
{((0, a), (1, a)) ∣ a ∈ y1}	∪	{((0, a), (2, a)) ∣ a ∈ y2}	∪
{((χ(a), a), (0, a)) ∣ a ∈ x & pol A⊥ (a)= +} .
The rigid family Q consists of all such q(x, y1, y2; χ) for balanced (x, y1, y2) and choice functions χ. From Q we obtain the event structure Pr(Q) in which events are prime orders, i.e. with a top element; events of Pr(Q) inherit the polarity of their top elements to obtain an event structure with polarity. We define the strategy δA ∶ A + A  ¸A to be the map Pr(Q) → A⊥  A  A sending a prime to its top

element. We remark that the meaning of a triple of configurations x, y1, y2 of C being balanced is almost y1 ∪ y2 ⊑C x but is not this in general as y1 ∪ y2 need not itself be a configuration of C.
The operation δA forms a comonoid with counit ı∶ A + ∅ .¸

A language for strategies
We describe, somewhat schematically, a language for describing strategies based on the constructions above. In fact, it is based on an earlier language for profunc- tors [15], taking advantage of the view of strategies as special profunctors.

Types
Types are games A, B, C, ⋯. We have type operations corresponding to the opera- tions on games of forming the dual A⊥, simple parallel composition A  B, sum Σi∈IAi as well as recursively-defined types μX.A(X), although we shall largely ignore the latter as it rests on well-established techniques [14].
One way to relate types is through the affine maps between them. There will be operations for shifting between types related by affine maps (described by con- figuration expressions), enabling us to shift strategies either forwards or backwards across affine maps.
A type environment is a finite partial function from variables to types, for con- venience written typically as Γ ≡ x1 ∶ A1, ⋯, xm ∶ Am, in which the (configuration) variables x1, ⋯, xm are distinct. It denotes a (simple) parallel composition  xi Ai. In describing the semantics we shall sometimes write Γ for the parallel composition it denotes.

Conﬁguration expressions
Configuration expressions denote finite configurations of games in an environment. A typing judgement Γ ⊢ p ∶ B for a configuration expression p in a type environment Γ denotes an affine map from Γ to B. In particular, the judgement Γ,x ∶ A ⊢ x ∶ A denotes the partial map of event structures projecting to the single component A. The special case x ∶ A ⊢ x ∶ A denotes the identity map.
We shall allow configuration expressions to be built from affine maps f = (f0, f1)∶ A →a B in the judgement Γ,x ∶ A ⊢ fx ∶ B and the equivalent judgement Γ,x ∶ A ⊢ f0 ∪ f1x ∶ B. In particular, f1 may be completely undefined, allowing conﬁguration expressions to be built from constant configurations, as e.g. in the judgement for the empty configuration Γ ⊢ ∅ ∶ A or a singleton configuration Γ ⊢ {a} ∶ A when a is an initial event of A. The expression {a}∪ x′ associated with the judgement
Γ, x′ ∶ A/a ⊢ {a}∪ x′ ∶ A, 
where a is an initial event of A, is used later in the transition semantics.

The three inductive rules for configuration expressions are as follows, where Γ⊥ is x1 ∶ A⊥, ⋯, xm ∶ A⊥ :

1	m
  Γ ⊢ p ∶ Aj	
Γ ⊢ jp ∶ Σi∈IAi

Γ ⊢ p ∶ A	Δ ⊢ q ∶ B
j ∈ I

Γ ⊢ p ∶ B

Γ⊥ ⊢ p ∶ B⊥

For a sum Σi∈IAi, the left-hand rule gives configuration expressions jp where j ∈ I and p is a configuration expression of type Aj: In the central rule for simple parallel composition we exploit the fact that configurations of simple parallel compositions are essentially pairsof configurations of the components. Finally, in the right-hand rule configurations of B⊥ can be taken to be the same as configurations of B.

Terms for strategies
Terms denoting strategies have typing judgements:
x1 ∶ A1, ⋯, xm ∶ Am ⊢ t ⊣ y1 ∶ B1, ⋯, yn ∶ Bn ,
where all the variables are distinct, interpreted as a strategy from the game x1 ∶
A1, ⋯, xm ∶ Am denotes to the game y1 ∶ B1, ⋯, yn ∶ Bn denotes.
We can think of the term t as a box with input and output wires for the typed variables:
B)1


Duality The duality of input and output is caught by the rules:


Γ,x ∶ A ⊢ t ⊣ Δ Γ ⊢ t ⊣ x ∶ A⊥, Δ
Γ ⊢ t ⊣ x ∶ A, Δ Γ,x ∶ A⊥ ⊢ t ⊣ Δ

Composition The composition of strategies is described in the rule
Γ ⊢ t ⊣ Δ	Δ ⊢ u ⊣ H
which, in the picture of strategies as boxes, joins the output wires of one strategy to input wires of the other. Note that the simple parallel composition of strategies arises as a special case when Δ is empty.
Nondeterministic sum We can form the nondeterministic sum of strategies of the same type:
Γ ⊢ ti ⊣ Δ	i ∈ I
Γ ⊢ []i∈I ti ⊣ Δ
We shall use ı for the empty nondeterministic sum, when the rule above specialises to Γ ⊢ı⊣ Δ . The term ı denotes the minimum strategy in the game Γ⊥  Δ.

Pullback We can form the pullback of two strategies of the same type:
Γ ⊢ t1 ⊣ Δ	Γ ⊢ t2 ⊣ Δ Γ ⊢ t1 ∧ t2 ⊣ Δ
In the case where t1 and t2 denote the respective strategies σ1 ∶ S1 → Γ⊥  Δ and σ1 ∶ S1 → Γ⊥  Δ, the strategy t1 ∧ t2 denotes the pullback of σ1 and σ2. Informally, such a strategy acts as the two component strategies agree to act.
Hom-set The hom-set rule is a powerful way to lift affine maps or relations ex- pressed in terms of cospans of affine maps to strategies. Write p[∅] for the substi- tution of the empty configuration ∅ for all configuration variables appearing in a configuration expression p. The hom-set rule
Γ ⊢ p′ ∶ C	Δ ⊢ p ∶ C	′

Γ ⊢ p ⊑C
p′ ⊣ Δ	p[∅] ⊑C p [∅]

introduces a term standing for the hom-set (C(C), ⊑C)(p, p′). It relies on config- uration expressions p, p′ and their typings. If Δ ⊢ p ∶ C denotes the affine map g = (g0, g1) and Γ ⊢ p′ ∶ C denotes the affine map f = (f0, f1), the side condition of the rule ensures that g0 ⊑C f0. A term for copy-cat arises as a special case of the hom-set rule:  x ∶ A ⊢ y ⊑A x ⊣ y ∶ A.
The hom-set rule is very expressive — see Section 4.4. The precise definition of the strategy which the hom-set rule yields is given in the next section.
Duplication Duplication terms are described by the rule
Γ ⊢ p ∶ C	Δ1 ⊢ q1 ∶ C	Δ2 ⊢ q2 ∶ C
Γ ⊢ δC(p, q1, q2)⊣ Δ1, Δ2
provided p[∅], q1[∅], q2[∅] is balanced in the sense of Section 3.2. The term for the duplication strategy is, in particular, x ∶ A ⊢ δA(x, y1, y2)⊣ y1 ∶ A, y2 ∶ A. 

Hom-set terms: semantics
The definition of the strategy which Γ ⊢ p ⊑C p′ ⊣ Δ denotes is quite involved. We first simplify notation. W.l.o.g. assume Δ ⊢ p ∶ C and Γ ⊢ p′ ∶ C — using duality we can always rearrange the environment to achieve this. Write A for the denotation of the environment Γ and B for the denotation of Δ. Let Δ ⊢ p ∶ C and Γ ⊢ p′ ∶ C denote respectively the affine maps g = (g0, g1) ∶ B →a C and f = (f0, f1) ∶ A →a C. Note that we have that g0 ⊑C f0 from the typing of p ⊑C p′. We build the strategy out of a rigid family Q with elements as follows. First, define a pre-element to be a finite preorder comprising a set {1}× x ∪ {2}× y, for which x ∈ C(A⊥) & y ∈ C(B) & gy ⊑c fx, with order that induced by ≤A⊥ on x, ≤B on y, with additional causal dependencies
(1, a)≤ (2, b) if f1(a)= g1(b) & b is +ve, and
(2, b)≤ (1, a) if f1(a)= g1(b) & b is −ve.

As elements of the rigid family Q we take those pre-elements for which the order
≤ is a partial order (i.e. is antisymmetric). The elements of Q are closed under rigid inclusions, so Q forms a rigid family. We now take S =def Pr(Q); the events of S (those elements of Q with a top event) map to their top events in A⊥  B from where they inherit polarities. This map can be checked to be a strategy: innocence follows directly from the construction, while receptivity follows from the constraint that gy ⊑c fx.
It is quite easy to choose an example where antisymmetry fails in a pre-element, in other words, in which the preorder is not a partial order. However, when either p or p′ is just a variable, no nontrivial causal loops are introduced and all pre-elements are elements. More generally, if one of p or p′ is associated with a partial rigid map (i.e. a map which preserves causal dependency when defined), then no nontrivial causal loops are introduced and all pre-elements are elements.
Duplication terms: semantics
Consider now the semantics of a term Γ ⊢ δC(p, q1, q2)⊣ Δ . W.l.o.g. we may assume that the environment is arranged so Δ ≡ Δ1, Δ2 with judgements Γ ⊢ p ∶ C, Δ1 ⊢ q1 ∶ C and Δ2 ⊢ q2 ∶ C. To simplify notation assume the latter judgements for configuration expressions denote the respective affine maps f = (f 0,f 1) ∶ A →a C, g1 = (g0, g11) ∶ B1 → C and g2 = (g0, g21) ∶ B2 → C. From the typing of δC(p, q1, q2)
1	2
we have that (f 0, g0, g0) forms a balanced triple in C. We build the strategy out of a
1	2
rigid family Q with elements as follows. We construct pre-elements from x ∈ C(A⊥), y1 ∈ C(B1) and y2 ∈ C(B2) where (fx, g1y1, g2y2) is a balanced triple in C with a choice function χ. There are three kinds of elements of x:
x− = {a ∈ x ∣ pol A⊥ (a)= −} ,

x+ = {a ∈ x ∣ pol A⊥ (a)=+ & f 1(a)∈ g0  1
} and

0	χ(f (a))

x+ = {a ∈ x ∣ pol A⊥ (a)=+ & f 1(a)∈ g1  1
yχ(f 1(a))}

1	χ(f (a))
We define a typical pre-element to be a finite preorder on the set
{0}× (x− ∪ x+ ∪ {(χ(f 1(a)), a) ∣ a ∈ x+}) ∪ {1}× y1 ∪ {2}× y2 ,
1	0
with order that induced by that of the game A⊥  B1  B2 with additional causal dependencies
(0, a)≤ (1, b) if f 1(a)= g1(b) & b is +ve in B1,
(0, a)≤ (2, b) if f 1(a)= g1(b) & b is +ve in B2, and

(χ(f 1(a)), b)≤ (0, a) if a ∈ x+ & f 1(a)= g1 1
(b) ,

1	χ(f (a))
for b −ve in Bχ(f 1(a)). As elements of the rigid family Q we take those pre-elements for which the order ≤ is a partial order (i.e. is antisymmetric). Once Q is checked to be a rigid family, we can take S =def Pr(Q); the events of S map to the events in the game A⊥  B1  B2 associated with their top events, from where they inherit polarities. This map defines the strategy denoting the original duplication term.

Expressivity
The terms for strategies are surprisingly expressive and potentally rich in laws, able to support a form of equational reasoning, that we can only touch on here. For example the Frobenius algebra associated with duplication immediately yields laws. Other laws capture basic facts about the Scott order. For instance, assuming z ⊆ x, y in C(A), we have y ⊑A x iff y/z ⊑A/z x/z.
As we shall see, we can derive the laws expected of a recursion operator provided the recursion involves a homorphism w.r.t. the duplication comonad, and this fact too we could hope to derive. Some of the reasoning can be made diagrammatic, using the techniques of string diagrams.
Hom-set terms provide many basic strategies. The denotation of x ∶ A ⊢ ∅ ⊑A
∅ ⊣ y ∶ B is the strategy in the game A⊥  B given by the identity map idA⊥  B ∶ A⊥  B → A⊥  B. The denotation of ⊢ y ⊑A ∅⊣ y ∶ A is ıA, the minimum strategy in the game A comprising just the initial −ve events of A.
The judgement x ∶ Aj ⊢ y ⊑Σi∈IAi jx ⊣ y ∶ Σi∈IAi denotes the injection strategy: its application to a strategy in Aj fills out the strategy according to the demands of receptivity to a strategy in Σi∈IAi. Its converse x ∶ Σi∈IAi ⊢ jy ⊑Σi∈IAi x ⊣ y ∶ Aj applied to a strategy of Σi∈IAi projects the strategy to a strategy in Aj.
More is obtained by combining hom-set with other operations such as compo- sition. Assume ⊢ t ⊣ y ∶ B. When f ∶ A → B is a map of event structures with polarity, the composition ⊢ ∃y ∶ B. [ t  fx ⊑B y ] ⊣ x ∶ A denotes the pullback f ∗σ of the strategy σ denoted by t across the map f ∶ A → B. In the case where a map of event structures with polarity f ∶ A → B is innocent, the composition
⊢ ∃x ∶ A. [ y ⊑B fx  t ] ⊣ y ∶ B denotes the ‘relabelling’ f!σ of the strategy σ
denoted by t.
A great deal is achieved through basic manipulation of the input and output “wiring” afforded by the hom-set rules and input-output duality. For instance, to achieve the effect of lambda abstraction: via the hom-set rule we obtain
x ∶ A⊥,y ∶ B ⊢ z ⊑A  B (x, y) ⊣ z ∶ A⊥  B , 
which joins two inputs to a common output, whence:
 Γ,x ∶ A ⊢ t ⊣ y ∶ B 	⋮	



A trace, or feedback, operation is another consequence of such “wiring.” Given a

Γ
strategy Γ,x ∶ A ⊢ t ⊣ y ∶ A, Δ represented by the diagram	t
Δ
we obtain

A	A
Γ, Δ⊥ ⊢ t ⊣ x ∶ A⊥,y ∶ A, which, post-composed with the term x ∶ A⊥,y ∶ A ⊢ x ⊑A y ⊣ denoting the copy-cat strategy γA⊥ , yields Γ ⊢ ∃x ∶ A⊥,y ∶ A. [ t  x ⊑A y ] ⊣ Δ , representing its trace:



A
The composition introduces causal links from the +ve events of y ∶ A to the −ve events of x ∶ A, and from the +ve events of x ∶ A to the −ve events of y ∶ A — these are the usual links of copy-cat γA⊥ as seen from the left of the turnstyle. This trace coincides with the feedback operation which has been used in the semantics of nondeterministic dataflow (where only games comprising solely Player moves are needed) [13].
Recursive deﬁnitions can be achieved from trace with the help of duplication. For those strategies which respect δ, i.e.δA⊙σ ≅ (σ  σ)⊙δΓ A, and in particular for strategies which are homomorphisms between δ-comonoids, the recursive defi- nition does unfold in the way expected, in the sense that the recursive definition is isomorphic to its unfolding:

A
≅


This follows as a general fact from the properties of trace monoidal categories and the string-diagram reasoning they support. However, not all strategies are homo- morphisms between δ-comonoids, characterised in the following theorem.
Theorem 4.1 A strategy σ ∶ S → A⊥ ∣∣ B respects δ iff
components σ1 ∶ S → A⊥ and σ2 ∶ S → B preserve causal dependency when deﬁned,
σ1 reflects conﬁgurations of A⊥, i.e. if x ⊆ S is such that σ1x ∈ C(A⊥) then
x ∈ C(S), and
for every +ve event s ∈ S such that σ(s) ∈ A⊥ we have the number of −ve events of σ2[s] equals the number of +ve events of σ1[s].
In this case, σ also respects counits, i.e. ıB⊙σ ≅ ıA.
A process perspective
The operations on strategies have much in common with the operations of process algebra and can be seen as forming the basis of a higher-order process language. However, from the perspective of concurrent processes, we must address several issues: its operational semantics, a suitable form of equivalence and expressivity. These require we examine the effects of synchronization and the internal, neutral events it produces, more carefully. Composition of strategies can introduce deadlock which is presently hidden. This, for example, affects the reliability of winning strategies; presently a strategy may be deemed winning and yet possibly deadlock before reaching a winning configuration. The next example illustrates how hidden deadlocks may be created in a composition of strategies.

Example 5.1 (i) Deadlock may arise in a composition τ ⊙σ through σ ∶ A + B ¸ and τ ∶ B + C  ¸imposing incompatible causal dependencies between events in B. For instance B may contain two concurrent events of opposite polarities b1 = ⊖ and b2 = ⊕. The strategy σ may impose the causal dependency s1 d s2 between occurrences of b1 and b2 respectively. From the point of view of strategy τ , the game
B has changed polarity to B⊥ and τ may impose the reverse causal dependency
s2 d s1 between occurrences of b2 and b1 respectively.
(ii) Composition of strategies may hide computation which is stuck. For games B = ⊕  ⊕ and C = ⊕, assume strategy σ1 ∶ ∅ + B  ¸nondeterministically chooses the right or left move in B, strategy σ2 ∶ ∅ + B  ¸chooses just the right move in B, while strategy τ ∶ B + C  ¸yields output in C if it gets the right event of B as input. The two strategy compositions τ ⊙σ1 and τ ⊙σ2 are indistinguishable.	◻


Partial strategies
To treat such phenomena explicitly and in order to obtain a transition semantics, we extend strategies with neutral events. Extend event structures with polarity to include a neutral polarity 0; as before, maps preserve polarities when defined. How- ever within games we shall still assume that all events have +ve or −ve polarity.
Definition 5.2 A partial strategy from a game A to a game B comprises a total map σ ∶ S → A⊥  N  B of event structures with polarity (in which S may also have neutral events) where
N is an event structure consisting solely of neutral events;
c	s
σ is receptive, i.e. if σx−—⊂ in C(S) with c −ve, then x−—⊂ and σ(s) = c, for
some unique s ∈ S;
in the partial-total factorization of the composition of σ with the projection
A⊥  N  B → A⊥  B, drawn below, the defined part σ0 is a strategy.

S 	 S0¸
σ J	σ 
A⊥  N  B 	 A¸⊥  B

Partial strategies in a game A correspond to partial strategies from the empty game to A. Strategies between games correspond to those partial strategies in which the neutral events N form the empty event structure.
It may seem odd that partial strategies are total maps. Why have we not taken a partial strategy to be undefined on events which are sent to N ? Because such partial maps do not behave well under pullback, and this would complicate the definition of composition and spoil later results such as that the pullback of a partial strategy is a partial strategy. With our choice of definition we are able to localise neutral events to the games over which they occur; with the alternative definition, different forms of undefined would become conflated.

Operations on partial strategies
The operations on strategies extend and give an interpretation of the language of Section 4 in terms of partial strategies. The defined parts of the operations on partial strategies coincide with the operations on the defined parts.
We can compose two partial strategies σ ∶ S → A⊥  NS  B and τ ∶ T → B⊥  NT C by pullback. Ignoring polarities temporarily, and padding with identity maps, we obtain τ ⊛ σ via the pullback



S  NT C
T ⊛ S
τ ⊛σ

z_
A  NS  T

σ  NT C	z_
  j_cA NS  τ

A NS B NT C. 
once we reinstate polarities and make the events of B neutral.  Receptivity of τ ⊛ σ follows directly from that of σ and τ . That the defined part of τ ⊛ σ is a strategy follows once it is shown that the defined part of the composite T ⊛
τ ⊛σ	⊥	⊥

S —→ A  (NS  B  NT )C—→A
 C is isomorphic to τ0⊙σ0 , the composition of the

defined parts of σ and τ .
With partial strategies we no longer generally have that composition with copy- cat yields the same strategy up to isomorphism: there will generally be extra neutral events introduced through synchronizations. However, as demonstrated in Section 6, a bicategory may be recovered through the use of may/must equivalence.
Let σi ∶ Si → A⊥  Ni  B, where i ∈ I, be a family of partial strategies. Their sum is the partial strategy []i∈I σi ∶ S → A⊥  (i∈I Ni)B. Its events are obtained as the disjoint union of the Si but where the initial −ve events are identified to maintain receptivity; they map under []i∈I σi as directed by the component maps σi. Causal dependency is inherited from the components Si with a finite subset of events consistent iff its down-closure contains +ve events from at most one Si. As such, the nondeterministic sum only commits to a component through the occur- rence of a positive event: from the perspective of tracking potential deadlocks, it is not necessary to view neutral events as committing to a particular component since, in isolation, a neutral event cannot introduce deadlock when composed with a counterstrategy due to receptivity.
The pullback of partial strategies σ1 ∶ S1 → A⊥  N1  B and σ2 ∶ S2 → A⊥  N2  B is obtained as follows:



S1  N2
S1 ∧ S2
σ1∧σ2

z˛
S2  N1 .

σ1 N2A
z˛J   cσ  N
N1 N2 B


Transition semantics
We now turn to the transition semantics for partial strategies, which is presented in Figure 1. For brevity, the rules presented require the left-hand environment in the

triple denoting a strategy to be empty; this can always be achieved using the rules for duality. In the transition rules, we write t ⊣ Δ instead of ∅⊢ t ⊣ Δ. Transitions are associated with two kinds of actions, either an action o associated with a hidden
neutral action t ⊣ Δ ————→ t′ ⊣ Δ or an initial event located in the environment

x∶ a ∶x′
t ⊣ x ∶ A, Δ ————→ t
⊣ x′
∶ A/a, Δ. Notice that a neutral action leaves the types

unchanged but may affect the term. An action x ∶ a ∶ x′ is associated with an initial event ev (x ∶ a ∶ x′) =def x ∶ a at the x-component of the environment. On its occurrence, the component of the environment x ∶ A is updated to x′ ∶ A/a in which x′, a fresh resumption variable, stands for the configuration remaining in the remaining game A/a. Say an action x ∶ a ∶ x′ is +ve/−ve according as a is +ve/−ve. In the ruless for composition, we use α for o or an action of the form x ∶ a ∶ x′ where x is in the domain of Γ and use β for o or an action of the form y ∶ b ∶ y′ where y is in the domain of H.
In typed judgements of δC(p, q1, q2), a variable can appear free in at most one of the configuration expressions p, q1 and q2. Write, for example, y ∈ fv(p) for y is free in p, and q1(y ∶ b) ∈ p[∅] to mean the image of b under the map q1 denotes is in the configuration denoted by p[∅].
We now establish the correspondence of the operational semantics with our view of terms as denoting strategies. Given a strategy σ ∶ S → Δ and an initial event s of S, we write σ/s ∶ S/e → Δ/σ(s) for the strategy obtained by restricting σ to S/s.
Theorem 5.3 Assume certain primitive strategies ∅ ⊢ σ0 ⊣ Δ, so as a map, σ0 ∶
S → Δ, for which we assume rules,
s is initial in S & σ0(s)= ev (ϵ).
′	′
σ0 ⊣ Δ ————→ σ0 ⊣ Δ
Then, derivations in the operational semantics
⋮
є	′	′
t ⊣ Δ ————→ t ⊣ Δ ,
up to α-equivalence, in which t denotes the partial strategy σ ∶ S → Δ, are in 1-1 correspondence with initial events s in S such that σ(s) = ev (ϵ) when ev (ϵ) ≠ o or s is neutral when ev (ϵ) = o. Furthermore, letting t′ denote the partial strategy σ′ ∶ S′ → Δ′, the strategies σ/s and σ′ are isomorphic.

6	May and Must equivalence
We now study ‘may’ and ‘must’ equivalence and how it may be used to recover bicategorical structure on strategies equipped with stopping conﬁgurations.
Consider three partial strategies in a game comprising a single +ve event. For this discussion it will be sufficient to consider just the event structures of the partial strategies:
S1	⊕	S2	⊚  ⊕z	S3	⊚  ⊚  ⊕z 

Composition:


y∶ b ∶y′
t ‹ y ∶ B, Δ, Γ ————→ t′


‹ y′


∶ B/b, Δ, Γ

u ‹ y ∶ B
⊥, Δ⊥
y∶ b ∶y′
, H ————→ u′
‹ y′
∶ B⊥
/b, Δ⊥, H

Ey ∶ B, Δ. [ t  u ]‹ Γ, H —→ Ey′
∶ B/b, Δ. [ t′
 u′ ]‹ Γ, H



t ‹ Γ, Δ ————→ t′
α
‹ Γ′, Δ
′	′
u ‹ H, Δ
————→ u′
β
‹ H′, Δ⊥
′	′

EΔ. [ t	u ]‹ Γ ————→ EΔ. [ t
u ]‹ Γ
EΔ. [ t  u ]‹ H ————→ EΔ. [ t  u ]‹ H

Hom-sets:	Assuming a is an initial event of A for which p[(a}/x][φ] cC
p′[(a}/x][φ],


′	x∶ a ∶x′
′	′	′	′

p cC p
‹ x ∶ A, Δ ————→ p[(a}u x /x] cC p [(a}u x /x]‹ x
∶ A/a, Δ

Above, the variable x will only appear in one of p and p′.
Sum of partial strategies:


є	′	′
є	′	′

tj ‹ Δ ————→ tj ‹ Δ
j ‹ I & ϵ is +ve	ti ‹ Δ ————→ ti ‹ Δ
6i ‹ I
ϵ is –ve

[]	є	′	′	є	′
i∈I ti ‹ Δ ————→ tj ‹ Δ	[]i∈I ti ‹ Δ ————→ []i∈I ti ‹ Δ
o	′	′

tj ‹ Δ ————→ tj ‹ Δ
j ‹ I, where t′ = t
if i m j

o
[]i∈I ti ‹ Δ ————→ []i∈I
t′ ‹ Δ	i	i

Pullback:
′	o	′
t1 ‹ Δ ————→ t1 ‹ Δ	t2 ‹ Δ ————→ t2 ‹ Δ
	
′	o	′

t1 ( t2 ‹ Δ ————→ t1 ( t2 ‹ Δ
z∶ c ∶z′	′
t1 ( t2 ‹ Δ ————→ t1 ( t2 ‹ Δ

′

ti ‹ Δ ————→ ti ‹ Δ
z∶ c ∶z′
6i ‹ (1, 2}
′	′

t1 ( t2 ‹ Δ ————→ t1 ( t2 ‹ Δ
Duplication:

x∶ a ∶x′	′	′
δC(p, q1, q2)‹ x ∶ A, Δ ————→ δC(p, q1, q2)[(a}u x /x]‹ x ∶ A/a, Δ
if either a is an initial –ve event of A, or a is an initial +ve event of A and there exists i ‹ (1, 2} s.t. either
x ‹ fv(qi) and qi(x ∶ a)‹ p[φ] or
x ‹ fv(p) and p(x ∶ a)‹ qi[φ].
Fig. 1. Transition semantics

Neutral events are drawn as ⊚. Conflict between pairs of events (meaning that there is no set in the consistency relation containing them both) is drawn as  . All three partial strategies have the same strategy as their defined parts. However, from the point of view of observing the move in the game, the first two partial strategies differ from the third. In a maximal play both S1 and S2 will result in the observation of the single move of the game. However, in S3 one maximal play is that in which the leftmost neutral event has occurred, in conflict with observing the single move of the game.
We follow [5] in making these ideas precise. For configurations x, y of an event structure with polarity which may have neutral events write x ⊆p y to mean x ⊆ y and all events of y ∖ x have polarity + or 0. We write ⊆0 to mean the inclusion involves only neutral events
Definition 6.1 Let σ be a partial strategy in a game A. Let τ ∶ T → A⊥  ⊕ be a ‘test’ strategy from A to a the game consisting of a single Player move ✓.
Say σ may pass τ iff there exists x ‹ C∞(T ⊛ S) with image (τ ⊛ σ)x containing
✓.
Say σ must pass τ iff all x ‹ C∞(T ⊛S) which are ⊆p-maximal have image (τ ⊛σ)x
containing ✓.
Say two partial strategies are ‘may’ (‘must’) equivalent iff the tests they may (respectively, must) pass are the same.
Two partial strategies with the same strategy as their defined part are ‘may’ equivalent but need not be ‘must’ equivalent. ‘Must’ inequivalence is lost in moving from partial strategies to strategies. Moreover, as we have seen, partial strategies lack identities w.r.t. composition, so they do not even form a bicategory. Fortu- nately, for ‘may’ and ‘must’ equivalence it is not necessary to use partial strategies; it is sufficient to carry with a strategy the extra structure of ‘stopping’ configura- tions (= images of p-maximal configurations in a partial strategy). Composition and copy-cat on strategies extend to composition and copy-cat on strategies with stopping configurations, while maintaining a bicategory, in the following way.
First, to deal with races, we are forced to introduce a refinement of the Scott order. We write x ◁∗ y for the transitive closure of the relation ◁⊆ C∞(S)× C∞(S) defined as
x ◁ y ⇐⇒ x c y and y  x is +-maximal in CCS.
On race-free games, ◁ is the identity relation on C∞(S).
Let σ ∶ S → A⊥  N  B be a partial strategy from a game A to a game B. Recall its associated partial-total factorization has defined part a strategy σ0 ∶ S0 → A⊥  B. Define the (possibly) stopping configurations in C∞(S0) to be
Stop(σ) =def ↓ (dx ∣ x ‹ C∞(S) is p-maximal} ,
where d ∶ S → S0 is the partial map that is undefined where σ is undefined and ↓ S
is the down-closure of S for the order ◁∗. Note that Stop(σ) will include all the
+-maximal configurations of S0: any +-maximal configuration y of S0 is the image under p of its down-closure [y] in S, and by Zorn’s lemma this extends (necessarily

by neutral events) to a maximal configuration x of S with image y under d; by
s
maximality, if x–—⊂ then s cannot be neutral, nor can it be +ve as this would
violate the +-maximality of y.
The operation St ∶ σ ↦ (σ0, Stop(σ)) above, from partial strategies to strategies with stopping configurations, motivates the following definitions.
A strategy with stopping conﬁgurations in a game A comprises a strategy S → A together with a subset MS ⊆ C∞(S) which is the down-closure with respect to ◁∗ of a set of +-maximal configurations. As usual, a strategy with stopping conﬁgurations from a game A to game B is a strategy with stopping configurations in the game A⊥  B. We can define ‘may’ and ‘must’ testing of strategies with stopping configurations analogously to above.
Given two strategies with stopping configurations σ ∶ S → A⊥  B, MS and τ ∶ T → B⊥  C, MT we define their composition by (τ, MT )⊙(σ, MS) =def (τ ⊙σ, MT ⊙MS) where x ‹ MT ⊙MS iff
Ez ‹ C∞(T ⊛ S). [x]T ⊛S ⊆0 z & Π1z ‹ MS & Π2z ‹ MT .

The stopping configurations of copy-cat are obtained as for any other strategy, and
∞	∗
in particular MCCA = (y	x ∣ x, y ‹ C  (A) & x ◁ y}.
Proposition 6.2 γA, MCCA is an identity w.r.t. the composition on strategies with stopping conﬁgurations.
Proposition 6.3 Let σ be a partial strategy from A to B and τ a partial strategy from B to C. Then
Stop(τ ⊛ σ)= Stop(τ )⊙Stop(σ) .
Corollary 6.4 A partial strategy σ ‘may’ (respectively ‘must’) pass a test τ iff St(σ) ‘may’ (‘must’) pass τ. The operation St preserves ‘may’ and ‘must’ equivalence.
Example 6.5 It is tempting to think of neutral events as behaving like the internal “tau” events of CCS [10]. However, in the context of strategies they behave rather differently. Consider three partial strategies, over a game comprising of just two concurrent +ve events, say a and b. The partial strategies have the following event structures in which we have named events by the moves they correspond to in the game:

S1	a
b
S2	⊚  az 
⊚  bz 
S3	⊚  az 
b

All three become isomorphic under St so are ‘may’ and ‘must’ equivalent to each other.	◻
Strategies with stopping configurations inherit the structure of a bicategory from strategies. We can interpret the metalanguage directly in terms of strategies with stopping configurations in such a way that the denotation of a term as a strategy with stopping configurations is the image under St of its denotation as a partial strategy. To achieve this, we specify the stopping configurations of both the sum

and pullback of strategies.
For the sum of strategies []i∈I σi with stopping configurations σi, a configuration of the sum is stopping iff it is the image of a stopping configuration under the injection from a component.
Consider strategies σ ∶ S → A and τ ∶ T → A with stopping configurations MS and MT respectively. Let their pullback be denoted by σ (τ ∶ P → A with projection morphisms π1 ∶ P → S and π2 ∶ P → T . A configuration of P is defined to be stopping iff there exist x1, x2 such that π1x ⊆+ x1 and π2x ⊆+ x2 and x1 ‹ MS and x2 ‹ MT , and furthermore there exists a partition x+ = Y1 u Y2 satisfying xi ∩ Yi = φ. The set of stopping configurations of P coincides with the stopping configurations obtained via St from the pullback of partial strategies.
The treatment of winning strategies of [3] generalises straightforwardly, with the role of +-maximal configurations replaced by that of stopping configurations.
7	Extensions & concluding remarks
We have seen a range of constructions on concurrent strategies that support a rich higher-order language for them, with a corresponding operational semantics. For the latter a central part has been the introduction of partial strategies. Though composition of a partial strategy with copy-cat does not in general yield the same strategy, we have seen how a bicategory can be obtained that respects the may/must behaviour of partial strategies by using stopping conﬁgurations.
The bicategorical structure of strategies is largely undisturbed by extensions to
probabilistic and quantum games [18], imperfect information [17] and symmetry [1]
— though compact-closure becomes ∗-autonomy under extensions by winning condi- tions [3] and pay-off [4]. The language of strategies is applicable in these extensions, with minor modifications. The constraints of linearity can be alleviated in games with symmetry which support (co)monads for copying [1]. The constructions of the language extend fairly directly to games with symmetry, though to exploit sym- metry fully the language needs to be extended to accommodate (co)monads up to symmetry.

References
Castellan, S., P. Clairambault and G. Winskel, Symmetry in concurrent games, in: LICS 2014 (2014).
Cattani, G. L. and G. Winskel, Profunctors, open maps and bisimulation, Mathematical Structures in Computer Science 15 (2005), pp. 553–614.
Clairambault, P., J. Gutierrez and G. Winskel, The winning ways of concurrent games, in: LICS ’12
(2012).
Clairambault, P. and G. Winskel, On concurrent games with payoff, in: MFPS ’13, number 298 in ENTCS (2013).
De Nicola, R. and M. Hennessy, Testing equivalences for processes, Theoretical Computer Science 34
(1984).
Faggian, C. and M. Piccolo, Partial orders, event structures and linear strategies, in: TLCA ’09, LNCS
5608, 2009.

Hirschowitz, T., Full abstraction for fair testing in ccs, in: CALCO ’13, LNCS 8089, 2013 .
Honda, K., Processes and games, ENTCS 71 (2004), {WRLA} 2002, Rewriting Logic and Its Applications.
URL http://www.sciencedirect.com/science/article/pii/S1571066105825289

Hyland, M., Some reasons for generalising domain theory, Mathematical Structures in Computer Science 20 (2010), pp. 239–265.
Milner, R., “Communication and concurrency,” Prentice Hall, 1989.
Nygaard, M. and G. Winskel, Linearity in process languages, in: LICS ’02 (2002).
Rideau, S. and G. Winskel, Concurrent strategies, in: LICS 2011 (2011).
Saunders-Evans, L. and G. Winskel, Event structure spans for nondeterministic dataflow, ENTCS 175
(2007).
Winskel, G., Event structure semantics for CCS and related languages, in: ICALP’82, LNCS 140
(1982).
Winskel, G., Relations in concurrency, in: LICS ’05 (2005).
Winskel, G., Event structures with symmetry, Electr. Notes Theor. Comput. Sci. 172: 611-652 (2007).
Winskel, G., Winning, losing and drawing in concurrent games with perfect or imperfect information, in: Festschrift for Dexter Kozen, LNCS 7230 (2012).
Winskel, G., Distributed probabilistic and quantum strategies, in: MFPS ’13, number 298 in ENTCS (2013).
Winskel, G., Strategies as profunctors, in: FOSSACS ’13, LNCS (2013).
