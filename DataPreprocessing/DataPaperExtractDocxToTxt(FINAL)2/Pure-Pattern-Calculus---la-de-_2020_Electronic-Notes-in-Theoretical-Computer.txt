Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 351 (2020) 95–113
www.elsevier.com/locate/entcs
Pure Pattern Calculus `a la de Bruijn 1
Alexis Mart´ın
Universidad de Buenos Aires, Argentina
Alejandro R´ıos
Universidad de Buenos Aires, Argentina
Andr´es Viso
Universidad de Buenos Aires, Argentina Universidad Nacional de Quilmes, Argentina

Abstract
It is well-known in the field of programming languages that dealing with variable names and binders may lead to conflicts such as undesired captures when implementing interpreters or compilers. This situation has been overcome by resorting to de Bruijn indices for calculi where binders capture only one variable name, like the λ-calculus. The advantage of this approach relies on the fact that so-called α-equivalence becomes syntactical equality when working with indices.
In recent years pattern calculi have gained considerable attention given their expressiveness. They turn out to be notoriously convenient to study the foundations of modern functional programming languages modeling features like pattern matching, path polymorphism, pattern polymorphism, etc. However, the literature falls short when it comes to dealing with α-conversion and binders capturing simultaneously several variable names. Such is the case of the Pure Pattern Calculus (PPC): a natural extension of λ-calculus that allows to abstract virtually any term.
This paper extends de Bruijn’s ideas to properly overcome the multi-binding problem by introducing a novel presentation of PPC with bidimensional indices, in an effort to implement a prototype for a typed functional programming language based on PPC that captures path polymorphism.
Keywords: de Bruijn indices, pattern calculi, pattern matching, α-equivalence.

Introduction
The foundations of functional programming languages like LISP, Miranda, Haskell or the ones in the ML family (Caml, SML, OCaml, etc.) rely strongly on the study of the λ-calculus [2] and its many variants introduced over the years. Among them there are the pattern calculi [23,7,16,6,14,12,18], whose key feature can be identified as pattern-matching. Pattern-matching has been extensively used in programming

1 This work was partially supported by LIA INFINIS, and the ECOS-Sud program PA17C01.

https://doi.org/10.1016/j.entcs.2020.08.006
1571-0661/© 2020 The Author(s). Published by Elsevier B.V.
This is an open access article under the CC BY license (http://creativecommons.org/licenses/by/4.0/).

languages as a means for writing succinct and elegant programs. It stands for the possibility of defining functions by cases, analysing the shape of their arguments, while providing a syntactic tool to decompose such arguments in their parts when applying the function.
In the standard λ-calculus, functions are represented by expressions of the form λx.t, where x is the formal parameter and t the body of the function. Such a function may be applied to any term, regardless of its form, as dictated by the β- reduction rule: (λx.t) u 'β→{x \ u}t, where {x \ u}t stands for the result of replacing all free occurrences of x in t by u. Note that no requirement on the shape of u is placed. Pattern calculi, on the contrary, provide generalisations of the β-reduction rule in which abstractions λx.t are replaced by more general terms like λp.t where p is called a pattern. For example, consider the function λ⟨x, y⟩.x that projects the first component of a pair. Here the pattern is the pair ⟨x, y⟩ and the expression (λ⟨x, y⟩.x) u will only be able to reduce if u is indeed of the form ⟨u1, u2⟩. Otherwise, reduction will be blocked.
We are particularly interested in studying the Pure Pattern Calculus (PPC) [15] and the novel features it introduced in the field of pattern calculi, namely path poly- morphism and pattern polymorphism. The former refers to the possibility of defining functions that uniformly traverse arbitrary data structures, while the latter allows to consider patterns as parameters that may be dynamically generated in run-time. Developing such a calculus implies numerous technical challenges to guarantee well- behaved operational semantics in the untyped framework. Recently, a static type system has been introduced for a restriction of PPC called Calculus of Applicative Patterns (CAP) [28], which is able to capture the path polymorphic aspect of PPC. Moreover, type-checking algorithms for such a formalism has also been studied [10], as a first step towards an implementation of a prototype for a typed functional pro- gramming language capturing such features. Following this line of research, studies on the definition of normalising strategies for PPC have been done as well [3,4]. Such results are ported to CAP by means of a simple embedding [27] where the static typing discipline gives further guarantees on the well-behaved semantics of terms.
Within this framework, the present work aims to throw some light on the implementation aspects of these formalisms. In particular, working modulo α- conversion [2] implies dealing with variable renaming during the implementation. Such an approach is known to be error-prone and computationally expensive. One way of getting rid of this problem in the λ-calculus setting is adopting de Bruijn notation [8,9], a technique that simply avoids working modulo α-conversion. To the best of our knowledge, no dynamic pattern calculi in the likes of PPC with de Bruijn indices has been formalised in the literature. However, there are some references worth mentioning. In [24] an alternative presentation of PPC is given in the framework of Higher-Order Pattern Rewriting System (HRS) [22,20], together with translations between the two systems. On the other hand, in [5] de Bruijn ideas had been extended to Expression Reduction Systems (ERS) [11] also pro- viding formal translations from systems with names to systems with indices, and

vice-versa. Moreover, the correspondence between HRS and ERS has already been established [25]. The composition of such translations might derive a higher order system `a la de Bruijn capturing the features of PPC. However, this would result in a rather indirect solution to our problem where many technicalities still need to be sorted out.
We aim to formalise an intuitive variant of PPC with de Bruijn indices where known results for the original calculus, such as the existence of normalising strate- gies, may easily be ported and reused.
Contributions
This paper extends de Bruijn’s ideas to handle binders that capture multiple sym- bols at once, by means of what we call bidimensional indices. These ideas are illustrated by introducing a novel presentation of PPC, without variable/matchable names, called PPCdB. Moreover, binders in the new proposed calculus are capable of handling two kinds of indices, namely variable and matchable indices, as required by the PPC operational semantics.
Proper translations from PPC to PPCdB and back are introduced. This functions preserve the matching operation and, hence, the operational semantics of both calculi. Moreover, they turn out to be the inverse of each other. This leads to a crucial strong bisimulation result between the two calculi, which allows to import many known properties of PPC into PPCdB, for instance confluence and the existence of normalising strategies.
Structure of the paper
We start by briefly introducing PPC and reminding the mechanism of de Bruijn indices for the λ-calculus in Sec. 2. The novel PPCdB is formalised in Sec. 3, followed by the introduction of the translations in Sec. 4. The strong bisimulation result is presented in Sec. 5 together with a discussion of different properties of PPCdB that follow from it. We conclude in Sec. 6 and discuss possible lines of future work. Some technical details and proofs are relegated to the extended report available online [19].
Preliminaries
This section introduces preliminary concepts that guide our development and will help the reader follow the new ideas presented in this work.
The Pure Pattern Calculus
We start by briefly introducing the Pure Pattern Calculus (PPC) [15], an extension of the λ-calculus where virtually any term can be abstracted. This gives place to two versatile forms of polymorphism that set the foundations for adding novel features to future functional programming languages: namely path polymorphism and pattern polymorphism. This work, however, focuses on implementation related

aspects of PPC and will not delve deeper into these new forms of polymorphism. We refer the reader to [15,13] for an in-depth study of them.
Given an infinitely countable set of symbols V (x, y, z,.. .), the sets of terms TPPC
and contexts are given by the following grammar:
Contexts C ::= 2 | C t | t C | λ C.t | λ t.C
Terms t ::= x | x^ | tt | λθt.t	θ	θ
where θ is a list of symbols that are bound by the abstraction. A symbol x appearing
in a term is dubbed a variable symbol while x is called a matchable symbol. In particular, given λθp.t, θ binds variable symbols in the body t and matchable symbols in the pattern p. Thus, the set of free variables and free matchables of a term t, written fv(t) and fm(t) respectively, are inductively defined as:


fv(x) , {x}
, ∅
fv(t u) , fv(t) ∪ fv(u)
fv(λθp.t) , fv(p) ∪ (fv(t) \ θ)
fm(x) , ∅
, {x}
fm(t u) , fm(t) ∪ fm(u)
fm(λθp.t) , (fm(p) \ θ) ∪ fm(t)

A term is said to be closed if it has no free variables. Note that free matchables are allowed, and should be understood as constants or constructors for data structures. The pattern p of an abstraction λθp.t is linear if every symbol x ∈ θ occurs at most once in p.
To illustrate how variables and matchables are bound, con-

sider the function elim defined as λ
[x]x^.(λ
[y]
x y^.y). The inner
λ	)

abstraction binds the only occurrence of the matchable y in
ever, the occurrence of x in x y is not bound by the inner abstraction, as it is excluded from [y], acting as a place-holder in that pattern. It is the outermost abstraction that binds both x in the inner pattern and x in the outermost pattern. This is graphically depicted above.
A substitution (σ, ρ, . . .) is a partial function from variables to terms. The sub- stitution σ = {xi \ ui}i∈I , where I is a set of indices, maps the variable xi into the term ui (i.e. σ(xi) , ui) for each i ∈ I. Thus, its domain and image are defined as dom(σ) , {xi}i∈I and img(σ) , {ui}i∈I respectively. For convenience, a sub- stitution σ is usually turned into a total function by defining σ(x) , x for every x ∈/ dom(σ). Then, the identity substitution is denoted {} or simply id .
A match (μ, ν, .. .) may be successful (yielding a substitution), it may fail (re- turning a special symbol fail) or be undetermined (denoted by a special symbol wait). The cases of success and failure are called decided matches. All concepts and notation relative to substitutions are extended to matches so that, for exam- ple, the domain of fail is empty while that of wait is undefined. The sets of free variable and free matchable symbols of σ are defined as the union of fv(σx)

and fm(σx) for every x ∈ dom(σ) respectively, while fv(fail) = fm(fail) = ∅ and they are undefined for wait. The set of symbols of a substitution is defined as sym(σ) , dom(σ) ∪ fv(σ) ∪ fm(σ). The predicate x avoids σ states that x ∈/ sym(σ). It is extended to sets and matches as expected. In particular, θ avoids μ implies that μ must be decided.
The result of applying a substitution σ to a term t, denoted σt, is inductively defined as:

σx , σ(x)
, x
σ(t u) , σt σu
σλ p.t , λ σp.σt	if θ avoids σ

σx^	^	θ	θ
The restriction in the case of the abstraction is required to avoid undesired captures
of variables/matchables. However, it can always be satisfied by resorting to α- conversion.
The result of applying a match μ to a term t, denoted μ t, is defined as: (i) if

μ = σ a substitution, then μt , σt; (ii) if μ = fail, then μt , λ
x.x (i.e. the

identity function); or (iii) if μ = wait, then μt is undefined.
[x] ^

The composition σ◦σj of substitutions is defined as usual, i.e. (σ ◦ σj)x , σ(σjx),
and the notion is extended to matches by defining μ ◦ μj , fail if any of the two matches is fail. Otherwise, if at least one of the two is wait, then μ ◦ μj , wait. In particular, fail ◦ wait = fail. The disjoint union μ μj of matches is defined as follows: (i) if μ = fail or μj = fail, then μ μj , fail; else (ii) if μ = wait or μj = wait, then μ μj , wait; otherwise (iii) both μ and μj are substitutions and if dom(μ) ∩ dom(μj) /= ∅, then μ  μj , fail, else:


(μ  μj)x ,
μjx	if x ∈ dom(μj)
⎪⎩x	otherwise

Disjoint union is used to guarantee that the matching operation is deterministic.
Before introducing the matching operation it is necessary to motivate the con- cept of matchable form. The pattern x y allows, at first, to decompose arbitrary applications, which may lead to the loss of confluence. For instance:

(λ[x,y]x y.y) ((λ[w]w.z0 z1) z0) → (λ[x,y]x y.y) (z0 z1) → z1
(λ[x,y]x y.y) ((λ[w]w.z0 z1) z0) → z0
This issue arises when allowing to match the pattern x y with an application that may still be reduced, like the argument (λ[w]w.z0 z1) z0 of the outermost redex in the example above. To avoid this situation it is required for the match to be decided only if the argument is sufficiently evaluated. An analogous issue occurs if the pattern is reducible. Thus, both the pattern and the argument must be in matchable form for the match to be decided. The set of data structures DPPC and matchable forms

MPPC are given by the following grammar:
Data structures d ::= x | dt	Matchable forms m ::= d | λθt.t

The matching operation {p \θ u } of a pattern p against a term u relative to a list of symbols θ is defined as the application, in order, of the following equations:
{x \θ u } , {x \ u}	if x ∈ θ
{p q^\θ t u } , {p \θ t }  {q \θ u }	if t u,pq ∈ MPPC
{p \θ u } , fail	if u, p ∈ MPPC
{p \θ u } , wait	otherwise
An additional check is imposed, namely dom( {p \θ u })= θ. Otherwise, {p \θ u } , fail. This last condition is necessary to prevent bound symbols from going out of scope when reducing. It can be easily guaranteed though by requesting, for each abstraction λθp.t, that θ ⊆ fm(p). For instance, consider the term (λ[x,y]x.y) u. Without this final check, matching the argument u against the pattern x would yield a substitution {x \ u} and no term would be assigned to the variable y in the body of the abstraction.
Finally, the reduction relation →PPC of PPC is given by the closure by contexts of the rewriting rule:
(λθp.s) u '→PPC {p \θ u } s
whenever {p \θ u } is a decided match. To illustrate the operational semantics of PPC consider the term elim introduced above, applied to the function λ[z]z.cz n where the free matchables c and n can be seen as constructors for lists cons and nil respectively:
(λ[x]x.(λ[y]x y.y)) (λ[z]z.cz n)	→PPC	λ[y](λ[z]z.cz n) y.y	→PPC	λ[y]c y n.y
In the first step, λ[z]z.cz n is substituted for x into the pattern x y. In the second step, the resulting application, which resides in the pattern, is reduced. The result- ing term, when applied to an argument, will yield a successful matching only if this argument is a compound data of the form ct n.
This relation is shown to be confluent (CR) based on the matching operation introduced above.
Theorem 2.1 ([15]) The reduction relation →PPC is confluent (CR).
de Bruijn indices
We introduce next de Bruijn indices for the λ-calculus. Among the many pre- sentations of de Bruijn indices in the literature, we will follow that of [17] as our

development builds upon their ideas. In particular, we choose to work with the pre- sentation where indices are partially updated as the term is being traversed by the substitution operation (details below). We refer the reader to [17] for the equivalent version where the update is performed once at the end of the substitution process. We introduce now the λ-calculus with de Bruijn indices (λdB for short).
The sets of terms TλdB and contexts are given by the following grammar:
Terms t ::= i | tt | λt	Contexts C ::= 2 | C t | t C | λC

where i ∈ N≥1 is called an index. Indices are place-holders indicating the distance to the binding abstraction. In the context of the λdB-calculus, indices are also called variables. Thus, the free variables of a term are inductively defined as: fv(i) , {i}; fv(t u) , fv(t) ∪ fv(u); and fv(λt) , fv(t) − 1, where X − k stands for subtracting k from each element of the set X, removing those that result in a non-positive index.
In order to define β-reduction `a la de Bruijn, the substitution of an index i for a term u in a term t must be defined. Therefore, it is necessary to identify among the indices of the term t, those corresponding to i. Furthermore, the indices of u should be updated in order to preserve the correct bindings after the replacement of the variable by u. To that end, the increment at depth k for variables in a term t, written ↑k(t), is inductively defined as follows:

↑ (i) ,	i + 1	if i > k 
k	i	if i ≤ k

↑k(t u) , ↑k(t) ↑k(u)
↑ (λt) , λ↑	(t)

k	k+1
Then, the substitution at level i of a term u in a term t, denoted {i \ u}t, is de- fined as a partial function mapping free variables at level i to terms, performing the appropriate updates as it traverses the substituted term, to avoid undesired captures.



{i \ u}ij ,
ij − 1	if ij > i u	if ij = i
⎪⎩ij	if ij < i 
{i \ u}(t s) , {i \ u}t {i \ u}s
{i \ u}λt , λ{i + 1 \ ↑0(u)}t

It is worth noticing that this substitution should be interpreted in the context of a redex, where a binder is removed and its bound index substituted. This forces to update the free indices, that might be captured by an outermost abstraction, as done by the first case of the substitution over a variable ij . Hence, preserving the correct bindings.
Finally, the reduction relation →dB of the λdB-calculus is given by the closure by contexts of the rewriting rule:
(λs) u '→dB {1 \ u}s
Also, embeddings between the λ-calculus and λdB are defined: J ) : Tλ → TλdB

and Q ¢ : TλdB → Tλ, in such a way that they are the inverse of each other and, they allow to simulate one calculus into the other:
Theorem 2.2 ([17]) Let t ∈ Tλ and s ∈ TλdB . Then,
If t →β tj, then Jt) →dB Jtj).
If s →dB sj, then Qs¢ →β Qsj¢.

This shows that both formalisms (λ-calculus and λdB) have exactly the same operational semantics.
As an example to illustrate both reduction in the λdB-calculus and its equivalence with the λ-calculus, consider the following terms: (λz.λy.z) (λx.x) (λx.x x) and (λλ2) (λ1) (λ1 1). The reader can verify that both expressions encode the same function in its respective calculus. As expected, their operational semantics coincide

(λz.λy.z) (λx.x) (λx.x x)	→β	(λy.λx.x) (λx.x x)	→β	λx.x
(λλ2) (λ1) (λ1 1)	→dB	(λλ1) (λ1 1)	→dB	λ1



The Pure Pattern Calculus with de Bruijn indices
This section introduces the novel Pure Pattern Calculus with de Bruijn indices (PPCdB). It represents a natural extension of de Bruijn ideas to a framework where a binder may capture more than one symbol. In the particular case of PPC there are two kinds of captured symbols, namely variables and matchables. This distinction is preserved in PPCdB while extending indices to pairs (a.k.a. bidimensional indices) to distinguish the binder that captures the symbol and the individual symbol among all those captured by the same binder.
The sets of terms TPPCdB , contexts, data structures DPPCdB and matchable forms
MPPCdB of PPCdB are given by the following grammar:


Terms t ::= ij | ij | tt | λnt.t
Contexts C ::= 2 | C t | t C | λnC.t | λnt.C
Data structures d ::= ij | dt 
Matchable forms m ::= d | λnt.t


where ij is dubbed a bidimensional index and denotes an ordered pair in N≥1 × N≥1 with primary index i and secondary index j. The sub-index n ∈ N in an abstraction represents the amount of indices (pairs) being captured by it. The primary index of a pair is used to determine if the pair is bound by an abstraction, while the secondary index identifies the pair among those (possibly many) bound ones. As for PPC, an index of the form ij is called a variable index while ij is dubbed a matchable index. The free variables and free matchables of a term are thus defined

as follows:


fv(ij) , {ij}
fv(ij) , ∅
fv(t u) , fv(t) ∪ fv(u)
fv(λnp.t) , fv(p) ∪ (fv(t) − 1)
fm(ij) , ∅
fm(ij) , {ij}
fm(t u) , fm(t) ∪ fm(u)
fm(λnp.t) , (fm(p) − 1) ∪ fm(t)


where X −k stands for subtracting k from the primary index of each element of the set X, removing those that result in a non-positive index.
Let us illustrate these concepts with a similar exam- ple as that given for PPC, namely the function elim = λ[x]x.(λ[y]x y.y). An equivalent term in the PPCdB framework would be λ111.(λ111 11.11). Note that variable indices in the
context of a pattern are not bound by the respective abstraction, in the same way that matchable indices in the body of the abstraction are not captured either. Thus, the first occurrence of 11 is actually bound by the outermost abstraction, together with the first occurrence of the matchable index 11. The rest of the indices in the term are bound by the inner abstraction as depicted in the figure to the right. As a further (more interesting) example, consider the term λ[x,y]x y.λ[]x.y from PPC, whose counter-part in PPCdB would look like λ211 12.λ011.22. This example illus- trates the use of secondary indices to identify symbols bound by the same abstrac- tion. It also shows how the primary index of a variable is increased when occurring within the body of an internal abstraction, while this is not the case for occurrences in a pattern position. Thus, both 11 and 22 are bound by the outermost abstraction, as well as 11 and 12. Note how the inner abstraction does not bind any index at all. A term t is said to be well-formed if all the free bidimensional indices (variables and matchables) of t have their secondary index equal to 1, and for every sub-term of the form λnp.s (written λnp.s ⊆ t) all the pairs captured by the abstraction have
their secondary index within the range [1, n]. Formally, {ij | ij ∈ fm(t) ∪ fv(t),j > 1}∪ ( λnp.s⊆t {1j | 1j ∈ fm(p) ∪ fv(s),j > n})= ∅.
Before introducing a proper notion of substitution for PPCdB it is necessary to have a mechanism to update indices at a certain depth within the term. The increment at depth k for variable and matchable indices in a term t, written ↑k(t) and ⇑k(t) respectively, are inductively defined as follows

↑ (i ) , (i + 1)j	if i > k 

⇑k(ij) , ij

k	ij
if i ≤ k
 (^i + 1)j	if i > k 

↑ (^i ) , ^i
⇑k(^ij) ,	^i
if i ≤ k

↑k(t u) , ↑k(t) ↑k(u)
↑k(λnp.t) , λn↑k(p).↑k+1(t)
⇑k(t u) , ⇑k(t) ⇑k(u)
⇑k(λnp.t) , λn⇑k+1(p).⇑k(t)

Similarly, the decrement at depth k for variables (↓k( )) and matchables (⇓k( )) are defined by subtracting one from the primary index above k in the term. Most of the times these functions are used with k = 0, thus the subindex will be omitted when it is clear from context. In particular, the decrement function for variables will allow us to generalise the idea of substitution at level i with respect to the original one presented in Sec. 2.2, which only holds in the context of a β-reduction, by making the necessary adjustments to the indices at the moment of the redution instead of hard-coding them into the substitution meta-operation.
A substitution at level i is a partial function from variable indices to terms. It maps free variable indices at level i to terms, performing the appropriate updates as it traverses the substituted term, to avoid undesired captures.

j	 uk	if ij = i, k ∈ J

{ij \ uj}j∈J i k ,

j
ijk
j
if ij =/ i
{ij \ uj}j∈J (t s) , {ij \ uj}j∈Jt {ij \ uj}j∈Js
{ij \ uj}j∈Jλnp.t , λn{ij \⇑(uj )}j∈Jp.{(i + 1)j \↑(uj )}j∈J

{ij \ uj}j∈J i^ k , i^ k
It is worth noticing that the base case for variable indices is undefined if ij = i and
k ∈/ J . Such case will render the result of the substitution undefined as well. In the operational semantics of PPCdB, the matching operation presented below will be responsible for avoiding this undesired situation, as we will see later. The domain of a substitution at level i is given by dom({ij \ uj}j∈J ) , {ij}j∈J . The identity substitution (i.e. with empty domain) is denoted {} or id .
As in PPC, a match (μ, ν, .. .) may succeed, fail (fail) or be undetermined (wait). For PPCdB, a successful match will yield a substitution at level 1, as given by the following matching operation, where the rules are applied in order as in PPC:

{1j \n u } , {1j \ u}
^
{pq \n t u } , {p \n t }  {q \n u }	if t u,pq ∈ MPPC
{p \n u } , fail	if u, p ∈ MPPC
{p \n u } , wait	otherwise
where disjoint union of matching is adapted to PPCdB from PPC in a straightforward way. The first two rules in the matching operation for PPCdB are worth a comment. As the matching operation should be understood in the context of a redex, the matchable symbols bound in the pattern are those with primary index equal to
1. Thus, PPCdB’s counter-part of the membership check x ∈ θ from PPC’s match- ing operation is a simple syntactic check on the primary index. Similarly, x ∈/ θ corresponds to the primary index being greater than 1, as checked by the second rule of the definition. However, a primary index i^+  1 within the pattern should match primary index i from the argument, since the former is affected by an extra

free and corresponds to 11 in the argument, while 11 from the pattern is bound by the abstraction. Its counter-part in PPC would be α-equivalent to (λ[x]y x.x) (y t).
As for PPC, an additional post-condition is checked over {p \n u } to prevent indices from going out of scope. It requires dom( {p \n u }) = {11,..., 1n}, which essentially implies that all the bound indices are assigned a value by the resulting substitution. This condition can be guaranteed by requesting {11,..., 1n}⊆ fm(p), for each abstraction λnp.t within a well-formed term. To illustrate the need of such a check, consider the term (λ211.12) uj (i.e. the PPCdB counter-part of (λ[x,y]x.y) u, given in Sec. 2.1). If the matching {11 \2 uj } = {11 \ uj} is considered correct, then no replacement for the variable index 12 in the body of the abstraction is set, resulting in an ill-behaved operational semantics.
The reduction relation →dB of PPCdB is given by the closure by contexts of the rewriting rule:
(λnp.s) u '→dB ↓( {p \n ↑(u) } s)
whenever {p\n↑(u) } is a decided match. The decrement function for variable indices is applied to the reduct to compensate for the loss of a binder over s. However, the variable indices of u are not affected by such binder in the redex. Hence the need of incrementing them prior to the (eventual) substitution.
Following the reduction example given above for PPC, consider these codifica- tions of elim = λ[x]x.(λ[y]x y.y) and λ[z]z.cz n respectively: λ111.(λ111 11.11) and λ111.11 11 21. Note how the first occurrence of 11 is actually bound by the outer- most abstraction, since abstractions do not bind variable indices in their pattern. Similarly, the matchable index 11 in the body of λ111.11 11 21 turns out to be free as well as 21. Then, as expected, we have the following sequence:
(λ111.(λ111 11.11)) (λ111.11 11 21) →dB  λ1(λ111.21 11 31) 11.11 →dB  λ121 11 31.11

In the first step, λ111.11 11 21 is substituted for 11 into the pattern 11 11. The fact that the substitution takes place within the context of a pattern forces the application of ⇑( ), thus updating the matchable indices and obtaining λ111.21 11 31. Note that the increment and decrement added by the reduccion rule take no effect as there are no free variable indices in the term. In the second step, the resulting application is reduced, giving place to a term whose counter-part in PPC would be equivalent to λ[y]c y n.y (cf. the reduction example in Sec. 2.1).
In the following sections PPCdB is shown to be equivalent to PPC in terms of expressive power and operational semantics. The main advantage of this new pre- sentation is that it gets rid of α-conversion, since there is no possible collision between free and bound variables/matchables. However, there is one minor draw- back with respect to the use of de Bruijn indices for the standard λ-calculus. As mentioned above, when working with de Bruijn indices in the standard λ-calculus, α-equivalence becomes syntactical equality.
Unfortunately, this is not the case when working with bidimensional indices. For

instance, consider the terms λ211 12.11 and λ212 11.12. Both represent the function that decomposes an application and projects its first component. But they differ in the way the secondary indices are assigned. Moreover, one may be tempted to impose an order for the way the secondary indices are assigned within the pattern to avoid this situation (recall that the post-condition of the matching operation forces all bound symbols to appear in the pattern). Given the dynamic nature of patterns in the PPC framework, this enforcement would not solve the problem since patterns may reduce and such an order is not closed under reduction. For example, consider λ2(λ211 12.12 11) (11 12).11 →dB λ212 11.11.
Fortunately enough, this does not represent a problem from the implementation point of view, since the ambiguity is local to a binder and does not imply the need for “renaming” variables/matchables while reducing a term, i.e. no possible undesired capture can happen because of it. It is important to note though, that in the sequel, when refering to equality over terms of PPCdB, it is not syntactical equality but equality modulo these assignments for secondary indices that we are using.
Translation
This section introduces translations between PPC and PPCdB (back and forth). The goal is to show that these interpretations are suitable to simulate one calculus into the other. Moreover, the proposed translations turn out to be the inverse of each other (modulo α-conversion) and, as we will see in Sec. 5, they allow to formalise a strong bisimulation between the two calculi.
We start with the translation from PPC to PPCdB. It takes the term to be translated together with two lists of lists of symbols that dictate how the variables and matchables of the terms should be interpreted respectively. We use lists of lists since the first dimension indicates the distance to the binder, while the second identifies the symbol among the multiple bound ones.
Given the lists of lists X and Y , we denote by XY their concatenation. To improve readability, when it is clear from context, we also write θX with θ a list of symbols to denote [θ]X where [ ] denotes the list constructor. We use set oper- ations like union and intersection over lists to denote the union/intersection of its underlying sets.
Definition 4.1 Given a term t ∈ TPPC and lists of lists of symbols V and M such that fv(t) ⊆  V ′∈V V j and fm(t) ⊆  M′∈M Mj, the translation of t relative to V and M , written Jt)M , is inductively defined as follows:
Jx)M , ij	where i = min{ij | x ∈ Vi′ } and j = min{jj | x = Vij′ }
Jx)M , ij	where i = min{ij | x ∈ Mi′ } and j = min{jj | x = Mij′ }
Jt u)M , Jt)M Ju)M
V	V	V
Jλθp.t)M , λ|θ|Jp)θM .Jt)M

Let x1, x2,... be an enumeration of V. Then, the translation of t to PPCdB, written
simply Jt), is defined as Jt)X where X = [[x1],..., [xn]] such that fv(t) ∪ fm(t) ⊆

{x1,..., xn}.
For example, consider the term s

0 = (λ[x]y x.x) (y sj ) with fv(sj ) = {y} and

0	0 [[y]]	1 ^ [[y]]	^ [[y]]	[[x],[y]]	^ [[y]]	0 [[y]]
(λ121 11.11) (11 Jsj )[[y]]). Note that the inicialisation of V and M with singleton
elements implies that each free variable/matchable in the term will be assigned a distinct primary index (when interpreted at the same depth), following de Bruijn’s

original ideas: let s1 = (λ
[x]
y^ x^.x) (y^ z), then Js1)[[y],[z]] = (λ1^21 ^11.11) (^11 21).

Our main goal is to prove that PPCdB simulates PPC via this embedding. For this
purpose we need to state first some auxiliary lemmas that prove how the translation behaves with respect to the substitution and the matching operation. We start with a technical result concerning the increment functions for variable and matchable indices. Notation ↑n(t) stands for n consecutive applications of ↑ ( ) over t (similarly
k	k
for ⇑n(t)).
Lemma 4.2 Let t ∈ TPPC, k ≥ 0, i ≥ 1 and n ≥ k+i such that Xl∩(fv(t)∪fm(t)) =
∅ for all l ∈ [k + 1,k + i − 1]. Then,

Jt)M
= ↑i—1(Jt)M	).

X1...Xn	k	X1...Xk Xk+i...Xn
Jt)X1...Xn = ⇑i—1(Jt)X1...Xk Xk+i...Xn ).
V	k	V
The translation of a substitution σ requires an enumeration θ such that dom(σ) ⊆
θ to be provided. It is then defined as Jσ, θ)M , {1j \ Jσxj)M }x ∈dom(σ). Note how
V	V	j
substitutions from PPC are mapped into substitutions at level 1 in the PPCdB frame-
work. This suffices since substitutions are only meant to be created in the context of a redex. When acting at arbitrary depth on a term, substitutions are shown to behave properly.
Lemma 4.3 Let s ∈ TPPC, σ be a substitution, θ be an enumeration such that
dom(σ ) ⊆ θ and Y be a list of i − 1 lists of symbols such that ( Y ′∈Y Y j) ∩ θ = ∅
  
 		  
In the case of a match, its translation is given by J {p \θ u })M , {Jp)θM \|θ|Ju)M }.
V	V	V
Note how θ is pushed into the matchable symbol list of the pattern, in accordance
with the translation of an abstraction. This is crucial for the following result of preservation of the matching output.
Lemma 4.4 Let p, u ∈ TPPC.
If {p \θ u } = σ, then J {p \θ u })M = Jσ, θ)M .
V	V
If {p \θ u } = fail, then J {p \θ u })M = fail.
If {p \θ u } = wait, then J {p \θ u })M = wait.

These previous results will allow to prove the simulation of PPC into PPCdB via the translation J ). We postpone this result to Sec. 5 (cf. Thm. 5.1).
Now we focus on the converse side of the embedding, i.e. translation of PPCdB terms into PPC terms. As before, this mapping requires two lists of lists of symbols from which names of the free indices of the term will be selected: one for variable indices and the other for matchable indices.
Definition 4.5 Given a term t ∈ TPPCdB and lists of lists of distinct symbols V and M such that Vij is defined for every ij ∈ fv(t) and Mij is defined for every ij ∈ fm(t), the translation of t relative to V and M , written Qt¢M , is inductively
defined as follows:
Qij¢M , Vij
M V
Qt u¢M , Qt¢M Qu¢M
V	V	V

Qλnp.t¢M , λθQp¢θM .Qt¢M
θ = [x1,..., xn] fresh symbols

V	V	θV
Let x1, x2,... be the same enumeration of V as in Def. 4.1. Then, the translation of t to PPC, written simply Qt¢, is defined as Qt¢X where X = [[x1],..., [xn]] such that fv(t) ∪ fm(t) ⊆ {11,..., n1}. Note that well-formedness of terms guarantees that X satisfies the conditions above.
To illustrate the translation, consider the term t1 = (λ121 11.11) (11 21) where
fv(t1)= {21} and fm(t1)= {11}. Then,

Qt1¢[[y],[z]]
= (λ
Q^21 ^11¢[[x],[y],[z]].Q11¢[[y],[z]]
) Q^11  21¢[[y],[z]]
= (λ
y^ x^.x) (y^ z).	Note

that t1 = Js1) from the example after Def. 4.1 and, with a proper initialisation
of the lists V and M , we get Qt1¢ = s1.
Once again, we start with some technical lemmas for substitutions and the matching operations with respect to the embedding Q ¢. In this case, the increment functions for variable and matchable indices behave as follows:
Lemma 4.6 Let t ∈ TPPCdB , k ≥ 0, i ≥ 1 and n ≥ k + i such that fv(t) ∪ fm(t) ⊆
{ijj | ij ≤ n − (i − 1),j ≤ |Xi′ |}. Then,
Q↑i—1(t)¢M	=α Qt¢M	.
k	X1...Xn	X1...Xk Xk+i...Xn

Q⇑i—1(t)¢X1...Xn =
Qt¢X1...Xk Xk+i...Xn .

k	V	α	V
As for the converse, the translation is only defined for substitution at level 1 and requires to be provided a list of symbols θ such that |θ| ≥ max{j | 1j ∈ dom(σ)}.
Then, Qσ, θ¢M , {θj \ Qσ1j¢M }1 ∈dom(σ). The application of a substitution at an
V	V	j
arbitrary level i is shown to translate properly.
Lemma 4.7 Let s ∈ TPPCdB , σ be a substitution at level i, θ be a list of fresh symbols such that |θ|≥ max{j | ij ∈ dom(σ)} and Y be a list of i− 1 lists of symbols. Then,

Q↓	({ij \↑ 
(σij)}i ∈dom(σ)s)¢M
=α {θj \ Qσij¢M
}i ∈dom(σ)Qs¢M  .

i—1
i—1	j	Y X 
Y X	j
Y θX

Similarly to the substitution case, the translation of a match {p \n u } requires to be supplied with a list of n fresh symbols θ. Then, it is defined as Q {p \n u }, θ¢M ,
{Qp¢θM \θ Qu¢M }. The newly provided list of symbols is used both as the parameter
V	V
of the resulting match and to properly translate the pattern, obtaining the following
expected result.
Lemma 4.8 Let p, u ∈ TPPCdB .
If {p \n u } = σ, then Q {p \n u }, θ¢M = Qσ, θ¢M .
V	V
If {p \n u } = fail, then Q {p \n u }, θ¢M = fail.
If {p \n u } = wait, then Q {p \n u }, θ¢M = wait.
Now we are in conditions to prove the simulation of PPCdB into PPC via the translation provided in Def. 4.5.
Before proceeding to the next section, one final result concerns the translations. It turns out that each translation is the inverse of the other, as shown in Thm. 4.9. In case of PPC terms we should work modulo α-conversion, while for PPCdB terms we may use equality (modulo secondary indices permutations, cf. last paragraph in Sec. 3). This constitutes the main result of this section and is the key to extend our individual simulation results (cf. Thm. 5.1 and 5.2 resp.) into a strong bisimulation between the two calculi, as shown in Sec. 5.
Theorem 4.9 (Invertibility) Let t ∈ TPPCdB and s ∈ TPPC. Then, (i) JQt¢) = t; and (ii) QJs)¢ =α s.
Proof By straightforward induction on t and s respectively. Details in [19].  2

Strong bisimulation
In this section we prove the simulation of one calculus by the other via the proper translation and, most importantly, the strong bisimulation that follows after the invertibility result (cf. Thm. 4.9). This strong bisimulation result will allow to port many important properties already known for PPC into PPCdB, as we will discuss later.
We start by simulating PPC by PPCdB. The key step here is the preservation of the matching operation shown for J ) in Lem. 4.4. It guarantees that every redex in PPC turns into a redex in PPCdB too. Then, the appropiate definition of the operational semantics given for PPCdB in Sec. 3 allows us to conclude.
Theorem 5.1 Let t ∈ TPPC. If t →PPC tj, then Jt) →dB Jtj).
Proof By induction on t →PPC tj using Lem. 4.2, 4.3 and 4.4. Details in [19].  2
Regarding the converse simulation, i.e. PPCdB into PPC, we resort here to the fact that the embedding Q ¢ also preserves the matching operation (cf. Lem. 4.8). Then, every redex in PPCdB is translated into a redex in PPC as well.

Theorem 5.2 Let t ∈ TPPC . If t →dB tj, then Qt¢ →PPC Qtj¢.
Proof By induction on t →dB tj using Lem. 4.6, 4.7 and 4.8. Details in [19].	2
As already commented, these previous results may be combined to obtain a strong bisimulation between the two calculi. The invertibility result allows to define a relation between terms in PPC and PPCdB. Given t ∈ TPPCdB and s ∈ TPPC, let us write t e⇒s whenever Qt¢ =α s and, therefore, Js) = t by Thm. 4.9. Then, the strong bisimulation result states that whenever t e⇒s and t →dB tj, there exists a term sj such that tj e⇒sj and s →PPC sj, and the other way around. Graphically:


t	e⇒s
dB	PPC

and
t	e⇒s
dB	PPC

tj	e⇒sj	tj	e⇒sj
Theorem 5.3 (Strong bisimulation) The relation e⇒is a strong bisimulation with respect to the reduction relations →PPC and →dB respectively.
Proof The proof follows immediately from Thm. 5.1 and 5.2 above, and the in- vertibility result (Thm. 4.9) given in Sec. 4.	2
The importance of this result resides in the fact that it guarantees that PPC and PPCdB have exactly the same operational semantics. An immediate consequence of this is the confluence of →dB.
Theorem 5.4 (Confluence) The reduction relation →dB is confluent (CR).
Proof The result follows directly from Thm. 2.1 and the strong bisimulation:
t


t1


sj
tj
2
Another result of relevance to our line of research, is the existence of normalising reduction strategies for PPC, as it is shown in [4]. This result is particularly chal- lenging since reduction in PPC is shown to be non-sequential due to the nature of its matching operation. This implies that the notion of needed redexes (a key con- cept for defining normalising strategies) must be generalised to necessary sets [26] of redexes. Moreover, the notion of gripping [21] is also captured by PPC, repre- senting a further obstacle in the definition of such a normalising strategy. All in all,

in [4] the authors introduce a reduction strategy S that is shown to be normalising, overcoming all the aforementioned issues. Thanks to the strong bisimulation result presented above, this strategy S can also be guaranteed to normalise for PPCdB.




Conclusion
In this paper we introduced a novel presentation of the Pure Pattern Calculus (PPC) [15] in de Bruijn’s style. This required extending de Bruijn ideas for a setting where each binder may capture more than one variable at once. To this purpose we defined bidimensional indices of the form ij where i is dubbed the primary index and j the secondary index, so that the primary index determines the binding abstraction and the secondary index identifies the variable among those (possibly many) bound ones. Moreover, given the nature of PPC semantics, our extension actually deals with two kinds of bidimensional indices, namely variable indices and matchable indices. This newly introduced calculus is simply called Pure Pattern Calculus with de Bruijn indices (PPCdB).
Our main result consists of showing that the relation between PPC and PPCdB is a strong bisimulation with respect to their respective redution relations, i.e. they have exactly the same operational semantics. For that reason, proper translations between the two calculi were defined, J ) : TPPC → TPPCdB and Q ¢ : TPPCdB → TPPC, in such a way that J ) is the inverse of Q ¢ and vice-versa (modulo α-conversion). Most notably, these embeddings are shown to preserve the matching operation of their respective domain calculus.
The strong bisimulation result allows to port into PPCdB many already known results for PPC. Of particular interest for our line of research are the confluence and the existence of normalising reduction strategies for PPC [4], a rather complex result that requires dealing with notions of gripping [21] and necessary sets [26] of redexes. The result introduced on this paper may allow for a direct implementation of such strategies without the inconveniences of working modulo α-conversion.
As commented before, the ultimate goal of our research is the implementa- tion of a prototype for a typed functional programming language capturing path polymorphism. This development is based on the Calculus of Applicative Patterns (CAP) [1], for which a static type system has already been introduced, guaran- teeing well-behaved operational semantics, together with its corresponding efficient type-checking algorithm. CAP is essentially the static fragment of PPC, where the abstraction is generalised into an alternative (i.e. abstracting multiple branches at once). These two calculi are shown to be equivalent. Thus, future lines of work fol- lowing the results presented in this paper involve porting CAP to the bidimensional indices setting and formalising the ideas of [4] into such framework. This will lead to a first functional version of the sought-after prototype.

References
Ayala-Rinco´n, M., E. Bonelli, J. Edi and A. Viso, Typed path polymorphism, Theor. Comput. Sci. 781
(2019), pp. 111–130.
URL https://doi.org/10.1016/j.tcs.2019.02.018

Barendregt, H. P., “The lambda calculus - its syntax and semantics,” Studies in logic and the foundations of mathematics 103, North-Holland, 1985.
Bonelli, E., D. Kesner, C. Lombardi and A. R´ıos, Normalisation for dynamic pattern calculi, in:
A. Tiwari, editor, 23rd International Conference on Rewriting Techniques and Applications (RTA’12)
, RTA 2012, May 28 - June 2, 2012, Nagoya, Japan, LIPIcs 15 (2012), pp. 117–132.
URL https://doi.org/10.4230/LIPIcs.RTA.2012.117

Bonelli, E., D. Kesner, C. Lombardi and A. R´ıos, On abstract normalisation beyond neededness, Theor. Comput. Sci. 672 (2017), pp. 36–63.
URL https://doi.org/10.1016/j.tcs.2017.01.025
Bonelli, E., D. Kesner and A. R´ıos, de Bruijn indices for metaterms, J. Log. Comput. 15 (2005),
pp. 855–899.
URL https://doi.org/10.1093/logcom/exi051
Cerrito, S. and D. Kesner, Pattern matching as cut elimination, Theor. Comput. Sci. 323 (2004),
pp. 71–127.
URL https://doi.org/10.1016/j.tcs.2004.03.032
Cirstea, H. and C. Kirchner, ρ-calculus. Its Syntax and Basic Properties, in: CCL, 1998, pp. 66–85.
de Bruijn, N. G., Lambda calculus notation with nameless dummies, a tool for automatic formula manipulation, with application to the church-rosser theorem, Indagationes Mathematicae 75 (1972),
pp. 381–392.
de Bruijn, N. G., “A namefree lambda calculus with facilities for internal definition of expressions and segments,” EUT report. WSK, Dept. of Mathematics and Computing Science, Technische Hogeschool Eindhoven, 1978.
Edi, J., A. Viso and E. Bonelli, Efficient type checking for path polymorphism, in: T. Uustalu, editor, 21st International Conference on Types for Proofs and Programs, TYPES 2015, May 18-21, 2015, Tallinn, Estonia, LIPIcs 69 (2015), pp. 6:1–6:23.
URL https://doi.org/10.4230/LIPIcs.TYPES.2015.6

Glauert, J. R. W., D. Kesner and Z. Khasidashvili, Expression reduction systems and extensions: An overview, in: A. Middeldorp, V. van Oostrom, F. van Raamsdonk and R. C. de Vrijer, editors, Processes, Terms and Cycles: Steps on the Road to Infinity, Essays Dedicated to Jan Willem Klop, on the Occasion of His 60th Birthday, Lecture Notes in Computer Science 3838 (2005), pp. 496–553.
URL https://doi.org/10.1007/11601548_22
Jay, B., The pattern calculus, ACM Trans. Program. Lang. Syst. 26 (2004), pp. 911–937.
URL https://doi.org/10.1145/1034774.1034775
Jay, B., “Pattern Calculus - Computing with Functions and Structures,” Springer, 2009.
URL  https://doi.org/10.1007/978-3-540-89185-7

Jay, B. and D. Kesner, Pure pattern calculus, in: P. Sestoft, editor, Programming Languages and Systems, 15th European Symposium on Programming, ESOP 2006, Held as Part of the Joint European Conferences on Theory and Practice of Software, ETAPS 2006, Vienna, Austria, March 27-28, 2006, Proceedings, Lecture Notes in Computer Science 3924 (2006), pp. 100–114.
URL https://doi.org/10.1007/11693024_8
Jay, B. and D. Kesner, First-class patterns, J. Funct. Program. 19 (2009), pp. 191–225.
URL https://doi.org/10.1017/S0956796808007144
Kahl, W., Basic pattern matching calculi: Syntax, reduction, confluence, and normalisation (2003).
Kamareddine, F. and A. R´ıos, A lambda-calculus a` la de Bruijn with explicit substitutions, in: M. V. Hermenegildo and S. D. Swierstra, editors, Programming Languages: Implementations, Logics and Programs, 7th International Symposium, PLILP’95, Utrecht, The Netherlands, September 20-22, 1995, Proceedings, Lecture Notes in Computer Science 982 (1995), pp. 45–62.
URL https://doi.org/10.1007/BFb0026813
Klop, J. W., V. van Oostrom and R. C. de Vrijer, Lambda calculus with patterns, Theor. Comput. Sci.
398 (2008), pp. 16–31.
Mart´ın, A., A. R´ıos and A. Viso, Pure pattern calculus `a la de Bruijn, Extended report (2020), https:
//arxiv.org/abs/2006.07674.

Mayr, R. and T. Nipkow, Higher-order rewrite systems and their confluence, Theor. Comput. Sci. 192
(1998), pp. 3–29.
URL  https://doi.org/10.1016/S0304-3975(97)00143-6

Melli`es, P.-A., “Description Abstraite des Syst`emes de R´e´ecriture,” Ph.D. thesis, Universit´e Paris VII (1996).
Nipkow, T., Higher-order critical pairs, in: Proceedings of the Sixth Annual Symposium on Logic in Computer Science (LICS ’91), Amsterdam, The Netherlands, July 15-18, 1991 (1991), pp. 342–349.
URL https://doi.org/10.1109/LICS.1991.151658

van Oostrom, V., Lambda calculus with patterns, Technical Report IR-228, Vrije Universiteit, Amsterdam (1990).
van Oostrom, V. and F. van Raamsdonk, The dynamic pattern calculus as a higher-order pattern rewriting system, in: 7th International Workshop on Higher-Order Rewriting, HOR 2014, Held as Vienna Summer of Logic, VSL 2014, Vienna, Austria, July 9-24, 2014. Proceedings, 2014.
van Raamsdonk, F., “Confluence and Normalization for Higher-Order Rewriting,” Ph.D. thesis, Amsterdam University (1996).
van Raamsdonk, F., Outermost-fair rewriting, in: P. de Groote, editor, Typed Lambda Calculi and Applications, Third International Conference on Typed Lambda Calculi and Applications, TLCA ’97, Nancy, France, April 2-4, 1997, Proceedings, Lecture Notes in Computer Science 1210 (1997), pp. 284–299.
URL  https://doi.org/10.1007/3-540-62688-3_42

Viso, A., “Un estudio sem´antico sobre extensiones avanzadas del λ-c´alculo: patrones y operadores de control,” Ph.D. thesis, Universidad de Buenos Aires (2020).
Viso, A., E. Bonelli and M. Ayala-Rinco´n, Type soundness for path polymorphism, in: M. R. F. Benevides and R. Thiemann, editors, Proceedings of the Tenth Workshop on Logical and Semantic Frameworks, with Applications, LSFA 2015, Natal, Brazil, August 31 - September 1, 2015, Electronic Notes in Theoretical Computer Science 323 (2015), pp. 235–251.
URL https://doi.org/10.1016/j.entcs.2016.06.015
