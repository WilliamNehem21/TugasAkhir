Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 344 (2019) 189–208
www.elsevier.com/locate/entcs

On Distinguishing Sets of Structures by First-Order Sentences of Minimal Quantifier Rank
Thiago Alves Rocha1
Department of Computing Federal Institute of Cear´a Maracanau´, Brazil
Ana Teresa Martins2,4
Department of Computing Federal University of Cear´a Fortaleza, Brazil
Francicleber Martins Ferreira3
Department of Computing Federal University of Cear´a Quixad´a, Brazil

Abstract
We investigate the distinguishability of sets of relational structures concerning a class of structures in the following sense: for a fixed class of structures, given two sets of structures in this class, find a first-order formula of minimal quantifier rank that distinguishes one set from the other. We consider the following classes of structures: monadic structures, equivalence structures, and disjoint unions of linear orders. We use results of the Ehrenfeucht–Fra¨ıss´e game on these classes of structures in order to design an algorithm to find such a sentence. For these classes of structures, the problem of determining if the Duplicator has a winning strategy in an Ehrenfeucht–Fra¨ıss´e game is solved in polynomial time. We also introduce the distinguishability sentences which are sentences that distinguish between two given structures. We define the distinguishability sentences based on necessary and sufficient conditions for a winning strategy in an Ehrenfeucht–Fra¨ıss´e game. Our algorithm returns a boolean combination of such sentences. We also show that any first-order sentence is equivalent to a boolean combination of distinguishability sentences. Finally, we also show that our algorithm’s running time is polynomial in the size of the input.
Keywords: Distinguishability, Ehrenfeucht–Fra¨ıss´e Games, Finite Model Theory.


1 Email: thiago.alves@ifce.edu.br
2 Email: ana@dc.ufc.br
3 Email: francicleber@dc.ufc.br
4 This author was partially supported by the Brazilian National Council for Scientific and Technological Development (CNPq) under the grant number 424188/2016-3.

https://doi.org/10.1016/j.entcs.2019.07.012
1571-0661/© 2019 The Author(s). Published by Elsevier B.V.
This is an open access article under the CC BY license (http://creativecommons.org/licenses/by/4.0/).

Introduction

Ehrenfeucht–Fra¨ıss´e games (EF games, for short) [6] is a fundamental technique of finite model theory [4,17,8] in proving the inexpressibility of certain properties in first-order logic (FO). The EF game is played on two structures by two players, the Spoiler and the Duplicator. If the Spoiler has a winning strategy for r rounds of such a game, it means that the structures can be distinguished by a first-order sentence ϕ whose quantifier rank is at most r, i.e., ϕ holds in exactly one of these structures. Besides providing a tool to measure the expressive power of a logic, EF games allow one to investigate the similarity between structures [19]. In a game played on structures A and B, the EF-similarity between A and B is the minimum number of rounds such that the Spoiler has a winning strategy. Necessary and sufficient conditions characterizing the winning strategies for both players are needed in order to explore EF-similarity.
Explicit conditions characterizing winning strategies for the players on some standard classes of finite structures are provided in [15]. Examples of such classes are monadic structures (MS) and equivalence structures (ES). Besides, it is well known necessary and sufficient conditions characterizing the winning strategies on linear orders (LO) [17]. Using these results, the EF-similarity can be computed in polynomial time in the size of the structures.

Given a structure A and a natural number r, an r-Hintikka formula ϕr
is a

formula that describes the properties of A on EF games with r rounds [4]. An

r-Hintikka formula ϕr
holds exactly on all structures B such that the Duplicator

has a winning strategy for the EF game with r rounds on A and B. Also, ϕr
has

size exponential in the size of A. Besides, any first-order formula is equivalent to a disjunction of Hintikka formulas.
An algorithm to deal with the problem of finding a formula of minimal quan- tifier rank that distinguishes two sets of structures over an arbitrary vocabulary is presented in [14]. An important part of this algorithm is the use of Hintikka formulas. As this algorithm works for arbitrary finite relational structures, it runs in exponential time. A general system for learning formulas defining board game rules uses this algorithm. These results are also used in reduction finding [13]. In [23], the authors define a variation of the problem in [14] which considers samples of classified strings.
In this work, we study a variation of the problem introduced in [14] when the class of structures is fixed. For a fixed class of structures C, a sample S = (P, N ) consists of two finite sets P, N ⊆C such that for each A∈ P , B ∈ N , A and B are not isomorphic. For a fixed class of structures C, given a sample S of structures in C, the task is to find a first-order sentence ϕS of minimal quantifier rank that is consistent with S, i.e., it holds in all structures in P and does not hold in any structure in N . The size of the sample is the sum of the lengths of all structures in the sample. We call this problem the distinguishability problem.
We define an algorithm for the distinguishability problem on the following classes of structures: MS, ES, and disjoint unions of linear orders (DULO). We consider

MS and ES because necessary and sufficient conditions for a winning strategy of the players in an EF game on these classes are provided in the literature [15]. For DULO, we show our result on a characterization of the winning strategies for both players. We use these characterization results on EF games in order to design an algorithm to find a sentence of minimal quantifier rank which is consistent with the sample. Also, for MS, ES, and DULO, the EF-similarity can be computed in polynomial time in the size of the structures. Using these results, we show that our algorithm runs in polynomial time in the size of the sample. Therefore, this result improves the one in [14] for MS, ES, and DULO. We expect that our results can be adapted to other classes such as trees and strings with a built-in linear order relation.
In Artificial Intelligence, automated planning is the process of automatically constructing a sequence of actions that achieve a goal given some initial state [7]. In the elementary blocks world planning, states consist of a set of cubic blocks, with the same size and color, sitting on a table. A robot can pick up a block and moves it to another position, either onto the table or on the top of some other block [11]. Therefore, disjoint unions of linear orders are compelling because we may model a state of the elementary blocks world by using them [2]. We think that our results can be useful when it is required to compute sentences defining initial and goal states from positive and negative examples. For instance, one can use our results to obtain the formula ¬∃x1∃x2(x1 < x2) which expresses that all blocks are on the table.
As the size of a Hintikka formula is exponential in the size of a given structure, our algorithm does not use Hintikka formulas. In our case, we define what we call the distinguishability sentences. They are defined based on conditions characteriz- ing the winning strategies for the Spoiler. In this way, given two structures A, B and a natural number r, we show that the distinguishability sentences hold in A, do not hold in B, and they have quantifier rank at most r. This result is essen- tial for the definition of our algorithm and to guarantee its correctness. We define distinguishability sentences for each particular class of structures we are consider- ing. Then, distinguishability sentences are easy to interpret because they express properties specific to the class. We also define distinguishability sentences in a way such that they have polynomial size. This result is essential in ensuring that our algorithm runs in polynomial time in the size of the sample. We also show that any first-order formula is equivalent to a boolean combination of distinguishability sentences.
A new logical framework to find a formula given a sample, also with a model- theoretic approach, can be found in [10,9]. In this framework, the input is only one structure, and its elements are classified as positive or negative. The problem is to find a hypothesis consistent with the classified elements where this hypothesis is a first-order formula in [10] and a monadic second-order formula in [9]. Also, [9] only considers strings as the input structure. The first main difference is that, in our approach, a sample consists of many structures classified as positive or negative. Second, the algorithm in [10] assumes that the quantifier rank is fixed while we

obtain a sentence of minimal quantifier rank.
Another logical framework for a similar problem is Inductive Logic Programming (ILP) [20,21,3]. ILP uses logic programming as a uniform representation for the sample and hypotheses. Therefore, due to the fundamental difference between the framework of ILP and our approach, there is no direct relationship between ILP and our work. Then, techniques used in the framework of ILP cannot easily be applied in our approach.
We organize this paper as follows: in Section 2, we give the basic definitions and results on Ehrenfeucht–Fra¨ıss´e games and Hintikka formulas. Moreover, in this section, we also give results on EF games and EF-similarity for monadic structures and equivalence structures. In Section 3, we show conditions characterizing the winning strategies for both players on disjoint union of linear orders. In Section 4, for each class of structures we are considering, we introduce the distinguishability sentences and provide some useful properties. In Section 5, we propose our algorithm for the distinguishability problem, we give an example of how it works, and we also show that the algorithm is correct. Finally, we conclude and show some future directions in Section 6.
Ehrenfeucht–Fra¨ıss´e Games
In this section, we present the basic notions about Ehrenfeucht–Fra¨ıss´e Games. We assume some background from first-order logic. For details, see [4,5]. In what follows, we are concerned with relational structures. The size of a first-order formula ϕ is the number of symbols occurring in ϕ. The quantifier rank qr(ϕ) of a formula ϕ is the depth of nesting of quantifiers in ϕ as in the following:
Definition 2.1 [Quantifier Rank] Let ϕ be a first-order formula. The quantifier rank of ϕ, written qr(ϕ), is defined as
⎧

qr(ϕ) := ⎪⎨ max(qr(ϕ1), qr(ϕ2)), if ϕ = ϕ1 ϕ2 such that  ∈ {∧, ∨, →}
qr(ψ),	if ϕ = ¬ψ
⎪⎩ qr(ψ)+ 1,	if ϕ = Qxψ such that Q ∈ {∃, ∀}

Given a first-order sentence ϕ, the class of structures defined by ϕ is simply MOD(ϕ) := {A | A |= ϕ}. Now, we can formally define the distinguishability problem with respect to a class of structures. Let C be a class of structures. A sam- ple S = (P, N ) consists of two finite sets P, N ⊆C such that for each A∈ P , B∈ N , A and B are not isomorphic. Intuitively, P contains positively classified structures and N contains negatively classified structures. A sentence ϕ is consistent with a sample S = (P, N ) if P ⊆ MOD(ϕ) and N ∩ MOD(ϕ) = ∅. In what follows, we formally define the distinguishability problem.
Definition 2.2 [Distinguishability Problem] Let C be a fixed class of structures.

Given a sample S, the problem consists of finding a first-order sentence ϕ of minimal quantifier rank that is consistent with S.
It is well known that every finite relational structure can be characterized in first- order logic up to isomorphism, i.e., for every finite structure A, there is a first-order sentence ϕA such that for all structures B we have B |= ϕA if and only if A and B are isomorphic (Proposition 2.1.1 from [4]). Since we are considering a fixed vocabulary and samples are finite sets of finite relational structures, one can easily build in polynomial-time a first-order sentence consistent with a given sample. For example, let τ = {P, R} be a fixed vocabulary such that P has arity one, and R has arity two. Clearly, the size of ϕA is O(n2). Also, it takes polynomial time to check whether A |= ψ when ψ is atomic. Therefore, we build ϕA in polynomial time. Unfortunately, the quantifier rank of ϕA is the number of elements in the domain of A plus one. Therefore, we can not use these formulas in a solution to the distinguishability problem. Now, we focus on Ehrenfeucht–Fra¨ıss´e games and its importance in order to solve the problem we are considering in this work.
Definition 2.3 [EF Game] Let r be an integer such that r ≥ 0, τ a vocabulary, A and B two τ -structures. The Ehrenfeucht–Fra¨ıss´e game (EF game, for short) Gr(A, B) is played by two players called the Spoiler and the Duplicator. Each play of the game has r rounds and, in each round, the Spoiler plays first and picks an element from the domain A of A, or from the domain B of B. Then, the Duplicator responds by picking an element from the domain of the other structure. Let ai ∈ A and bi ∈ B be the two elements picked by the Spoiler and the Duplicator in the ith round. The Duplicator wins the play if the mapping (a1, b1), ..., (ar, br) is an isomorphism between the substructures induced by a1, ..., ar and b1, ..., br, respectively. Otherwise, Spoiler wins this play. We say that a player has a winning strategy in Gr(A, B) if it is possible for him to win each play whatever choices are made by the opponent.
In this work, we always assume that A and B are not isomorphic. Observe that, for a structure A such that |A|≤ r, a structure B is isomorphic to A if and only if the Duplicator has a winning strategy in Gr+1(A, B). Then, we can consider that the number of rounds r is bounded by the sizes of A and B. Now, for a structure A and a natural number r, we define formulas describing the properties of A in any EF game with r rounds.
Definition 2.4 [r-Hintikka Formula] Let A be a structure, a = a1...as ∈ As, and
v = v1, ..., vs a tuple of variables.

0
A,a¯
(v¯) :=  {ϕ(v¯) | ϕ is atomic or negated atomic and A |= ϕ[a¯]},


and for r > 0, ϕr

(v¯) :=  ∃vs+1ϕr−1 (v¯, vs+1) ∧ ∀vs+1(  ϕr−1 (v¯, vs+1)).

A,a¯
a∈A
A,a¯a

a∈A
A,a¯a

The Hintikka formula ϕr
describes the isomorphism type of the substructure gen-

erated by a in A. We write ϕr
whenever s = 0. Given a structure A and a natural

number r, the size of ϕr is O(2r|A|r). Therefore, since r is bounded by |A|, the

size of ϕr
is exponential in the size of A. The following theorems are important to

prove some of our results. These theorems are presented in [4].
Theorem 2.5 (Ehrenfeucht’s Theorem) Let A and B be structures, and r be a natural number. The Duplicator has a winning strategy in Gr(A, B) iff B |= ϕr . The Duplicator has a winning strategy in Gr(A, B) iff A and B satisfy the same sentences of quantiﬁer rank at most r.
Theorem 2.6 Let ϕ be a sentence of quantiﬁer rank at most r. Then, there exist structures A1, ..., Ak such that
|= ϕ ↔ (ϕr ∨ ... ∨ ϕr ).

EF games provide information about the similarity between structures. If two structures A and B are not isomorphic, then there is an r such that the Spoiler has a winning strategy in Gr(A, B). The notion of EF-similarity below represents this information about similarity.
Definition 2.7 [EF-similarity] The EF-similarity between two structures A and B, denoted by EFsim(A, B), is the minimum number of rounds r such that Spoiler has a winning strategy in Gr(A, B). If Duplicator has a winning strategy in Gr(A, B) for all r, then EFsim(A, B)= ∞.
EF games are important in our framework because if the Spoiler has a winning strategy in a game on A and B with r rounds, then there exists a first-order sentence ϕ of quantifier rank at most r that holds in A and does not hold in B. Also, in this

case, the sentence ϕr
is an example of such a sentence. However, over arbitrary

vocabularies, the problem of determining whether the Spoiler has a winning strategy in Gr(A, B) is PSP ACE-complete [22]. Fortunately, it is possible to do better for EF games on MS, LO, and ES. In what follows, we show the case for EF games on MS and ES. For details of the results on these classes see [15].
A monadic structure is a structure M = ⟨M, PM, ..., PM⟩ such that each Pi is
1	k
monadic and PM, ..., PM are pairwise disjoint. In what follows, we give a result
1	k
on EF games on MS and we show how to compute the EF-similarity between two
structures in MS.
Theorem 2.8 (EF Games on MS) [15] For a structure M in MS, we set
PM	=  (PM ∪ ... ∪ PM).	Let  M1  and  M2  be  structures  in  MS.  The  Spoiler
k+1	1	k
has a winning strategy in Gr(M1, M2) iff there exists i ∈ {1, ..., k + 1} such that
(|PM1 | < r or |PM2 | < r) and |PM1 | /= |PM2 |.
i	i	i	i
The EF-similarity between two structures in MS can be computed in polynomial time in the size of the structures in the following way.
EFsim(M1, M2)= min{min(|PM1 |, |PM2 |) | |PM1 | /= |PM2 |, 1 ≤ i ≤ k + 1} + 1.
i	i	i	i
An equivalence structure is a structure of the form E = ⟨A, EE ⟩ such that EE is

an equivalence relation on A. Let q£
be the number of equivalence classes in E of

size t. Let q£
be the number of equivalence classes in E of size at least t.

Theorem 2.9 (EF Games on ES) [15] Let r be a natural number, and E1, E2 be equivalence structures. The Spoiler has a winning strategy in Gr(E1, E2) iff (there exists a t < r such that q£1 /= q£2 and r ≥ min{q£1 , q£2 } + t + 1) or (there exists a
t	t	t	t
t ≤ r such that q£1 /= q£2 and r ≥ min{q£1 , q£2 } + t).
≥t	≥t	≥t  ≥t
By Theorem 2.9, the EF-similarity between equivalence structures E1 and E2 can be computed in the following way. Note that computing EF-similarity takes polynomial time in the size of the equivalence structures.
EF sim(£1, £2)= min(min{min(qE1 , qE2 )+ t | qE1 /= qE2 } + 1, min{min(qE1 , qE2 )+ t | qE1 /= qE2 }).

t	t	t	t
≥t  ≥t
≥t	≥t

Besides the importance of EF games on a specific class of structures to our frame- work, we also use Theorem 2.8, Theorem 3.1, and Theorem 2.9 to define the distin- guishability sentences. These sentences are defined based on the conditions charac- terizing the winning strategies for the Spoiler on MS, ES, and DULO.
Our algorithm’s first step is to compute the quantifier rank necessary to dis- tinguish between any two structures A ∈ P and B ∈ N . Then, the fact that EFsim(A, B) can be computed in polynomial time is essential to show that our algorithm runs in polynomial time as well.
It is easy to build a first-order sentence of minimal quantifier rank that consists of a disjunction of Hintikka formulas, and that is consistent with a given sample. For example, let P = {M1}, N = {M2, M3}, r = max{EFsim(M1, M2), EFsim(M1, M3)}, and S = (P, N ).  The sentence ϕr
is a first-order sentence of minimal quantifier rank that is consistent with S. Unfor-

tunately, the size of ϕr
1
is exponential in the size of S. Therefore, ϕr
1
can not be

built in polynomial time in the size of the sample. This motivates the introduction
of the distinguishability sentences in Section 4.

EF Games on Disjoint Unions of Linear Orders
In this section, we show conditions characterizing the winning strategies for both players on disjoint unions of linear orders. We also determine the EF-similarity in this context. First, we turn to linear orders. A linear order is a structure L = ⟨L, <L⟩ such that <L is a linear order on L. In what follows, for a linear order L, let qL be the number of elements in the domain of L. For an element a, we define L>a (L<a) as a substructure of L such that {b ∈ L | b > a} ({b ∈ L | b < a}) is the domain of L>a (L<a). The following result is well known in the literature [17]. In this result, the Spoiler’s winning strategy consists of choosing, in her first round, an element from the linear order with more elements.
Theorem 3.1 (EF Games on LO) Let r be a natural number, L1 and L2 be lin- ear orders. The Spoiler has a winning strategy in Gr(L1, L2) if and only if qL1 /= qL2 and (qL1 < 2r − 1 or qL2 < 2r − 1).

Now, we define disjoint unions of linear orders. Assume that L1 and L2 are linear orders such that L1 ∩ L2 = ∅. Then, L1 L2, the disjoint union of L1 and L2, is the structure with domain L1 ∪ L2 and <L1 L2 =<L1 ∪ <L2 . We represent a disjoint unions of linear orders W by disjoint unions (...(L1  L2)   Ll).
Equivalence structures also can be seen as disjoint unions of structures. Our results on DULO are inspired by the case of EF games on equivalence structures. In what follows, for a disjoint unions of linear orders W, let qW be the number of linear orders L in W such that qL = t. Also, let qW be the number of linear orders L in W such that qL ≥ t. Given an element a in W1, L(a) denotes the linear order in W1 such that a is in the domain of L(a). Given a disjoint unions of linear orders W, let W(a1, ..., ak) be the disjoint unions of linear orders obtained by removing L(a1),  , L(ak) from W.
Definition 3.2 [Disparity] Let r be a natural number, W1 and W2 be disjoint unions of linear orders. We say that
Gr(W1, W2) has a small disparity if there exists t such that 1 ≤ t < 2r − 2,
qW1 /= qW2 , and r ≥ min{qW1 , qW2 } + [log([ t+1 |)♩ + 2.
t	t	t	t	2
Gr(W1, W2) has a large disparity if there exists t such that 1 ≤ t ≤ 2r − 1,
qW1 /= qW2 , and r ≥ min{qW1 , qW2 } + [log(t)♩ + 1.
≥t	≥t	≥t	≥t
Lemma 3.3 Let r be a natural number, W1 and W2 be two disjoint unions of linear orders. If Gr(W1, W2) has a small or large disparity, then the Spoiler has a winning strategy.
Proof. Suppose that qW1 > qW2 , and r ≥ qW2 + [log([ t+1 |)♩ + 2. The Spoiler has
t	t	t	2

the following winning strategy: first, she chooses elements a1, a2, ..., a W2
t
from dis-

tinct linear orders of size t in W1. The Duplicator must choose elements b1, ..., b W2
t
in W2 from distinct linear orders of size t. Next, the Spoiler chooses an element
>a
a from a distinct linear order L(a) of size t in W1 such that qL(a)	< 2r−1 − 1
and qL(a)<a < 2r−1 − 1. Then, the Duplicator must select an element b from a linear order L(b) such that qL(b) /= t. Then, the Spoiler has a winning strategy in G[log([ t+1 |)♩+1(L(a)<a, L(b)<b) by Theorem 3.1. Furthermore, the Spoiler has a winning strategy in G[log([ t+1 |)♩+2(L(a), L(b)). Therefore, the Spoiler has a winning
strategy in Gr(W1, W2).
Now, suppose that qW1 > qW2 , and r ≥ qW2 + [log(t)♩ + 1. The Spoiler has
≥t	≥t	≥t

the following winning strategy: first, she chooses elements a1, a2, ..., a W2
≥t
from dis-

tinct linear orders of size at least t in W1. The Duplicator must choose elements

b1, ..., b W2
≥t
in W2 from distinct linear orders of size at least t. Next, by Theo-

rem 3.1, the Spoiler uses her winning strategy in G[log(t)♩+1(L1, L2) such that L is
a linear order in W1, qL1 ≥ t, qL2 < t. Then, the Spoiler has a winning strategy in
Gr(W1, W2).	2
In the above result, different from the proof of Theorem 3.1, the Spoiler has a winning strategy which consists of choosing an element from a linear order with

fewer elements. Then, first, we need the following lemma in order to guarantee a winning strategy for the Duplicator.
Lemma 3.4 Let r be a natural number, L1 and L2 be linear orders.
If qL1 ≥ 2r − 1 and the Spoiler chooses an element from L1 in her ﬁrst round, then the Duplicator has a winning strategy in Gr(L1, L2) if qL2 ≥ 2r − 1.
If qL1 = 2r − 2 and the Spoiler chooses an element from L1 in her ﬁrst round, then the Duplicator has a winning strategy in Gr(L1, L2) if qL2 ≥ 2r − 2.
If qL1 < 2r − 2 and the Spoiler chooses an element from L1 in her ﬁrst round, then the Duplicator has a winning strategy in Gr(L1, L2) if qL2 = qL1 .
Proof. For the first and third part of the lemma, the Duplicator has a winning strategy as in Theorem 3.1. To prove the second part of the lemma, assume that
>a
qL2 ≥ 2r−2. Let a ∈ L1 be the element chosen by the Spoiler. Then, qL	≥ 2r—1−1
or L<a ≥ 2r—1 − 1. Assume that qL>a ≥ 2r—1 − 1. The Duplicator chooses an

element b ∈ L
such that qL>b ≥ 2r—1 − 1 and qL<b = qL<a . Then, the Duplicator

2	2	2	2
has a winning strategy in Gr—1(L>a, L>b). Therefore, the Duplicator has a winning
1	2
strategy in r rounds.	2
Theorem 3.5 (EF Games on DULO) Let r be a natural number, W1 and W2 be disjoint unions of linear orders. The Spoiler has a winning strategy in Gr(W1, W2) iff Gr(W1, W2) has a small or large disparity.
Proof. One direction is Lemma 3.3. Conversely, assume that Gr(W1, W2) has nei- ther small nor large disparity. Let (a1, b1),  , (ak, bk) be such that ai ∈ W1, bi ∈ W2
for i ∈ {1, ..., k}, and if the Spoiler has chosen ai (bi), then the Duplicator has selected bi (ai). We show that the Duplicator has a winning strategy by induction

on k. Let Wj
= W1(a1, ..., ak) and Wj
= W2(b1, ..., bk).  The following are our

inductive hypotheses:
For all i, j ≤ k, ai < aj iff bi < bj.
For all i ≤ k, qL(ai) ≥ 2r—i − 1, then qL(bi) ≥ 2r—i − 1.
For all i ≤ k, qL(ai) = 2r—i − 2, then qL(bi) ≥ 2r—i − 2.
For all i ≤ k, qL(ai) < 2r—i − 2, then qL(bi) = qL(ai).
Gr—k(Wj , Wj ) has neither small nor large disparity.
1	2
If the Spoiler chooses an element ak+1 ∈ W1 such that ai < ak+1, then the Duplicator responds by bk+1 such that bi < bk+1. The case where ak+1 < ai is analogous. Note that, by inductive hypotheses (ii), (iii), (iv), the Duplicator can select such an element. Now, assume ak+1 ∈ W1 is in a linear order L(ak+1) different from L(ai), for i ≤ k. Suppose qL(ak+1) ≥ 2r—k − 1. By contradiction, assume that
any linear order L in Wj is such that |L| < 2r—k − 1. Then, Gr—k(Wj , Wj ) would
2	1	2
have a large disparity as witnessed by t = 2r—k − 1. Therefore, the Duplicator can choose bk+1 in W2 such that L(bk+1) is different from L(bi), for i ≤ k, and qL(bk+1) ≥ 2r—k − 1. Now, assume that qL(ak+1) = 2r—k − 2. We assume, by absurd, that any
linear order L in Wj is such that |L| < 2r—k − 2. Then, Gr—k(Wj , Wj ) would have a
2	1	2

large disparity as witnessed by t = 2r—k − 2. Therefore, there exists bk+1 in W2 such that L(bk+1) is different from L(bi), for i ≤ k, and qL(bk+1) ≥ 2r—k − 2. Duplicator chooses bk+1. Finally, suppose that qL(ak+1) < 2r—k − 2. Then, bk+1 must exist in W2 such that L(bk+1) is different from L(bi), for i ≤ k, and qL(bk+1) = qL(ak+1). Otherwise Gr—k(Wj , Wj ) would have a small disparity as witnessed by t = qL(ak+1).
1	2
Then, the Duplicator chooses bk+1. The cases where the Spoiler chooses an element
from W2 are analogous.
Now,  we check that each of the inductive hypotheses hold on (a1, b1), ..., (ak+1, bk+1). Clearly, inductive hypothesis (i) holds. Now, assume that qL(ak+1) ≥ 2r—k—1 − 1. If qL(ak+1) ≥ 2r—k − 1, then the strategy we describe ensures that qL(bk+1) ≥ 2r—k − 1. If qL(ak+1) = 2r—k − 2, then the strategy ensures that qL(bk+1) ≥ 2r—k − 2. Finally, if qL(ak+1) < 2r—k − 2, then qL(bk+1) = qL(ak+1). Clearly, in all cases qL(bk+1) ≥ 2r—k—1 − 1. Now, assume that qL(ak+1) = 2r—k—1 − 2. Obviously, qL(ak+1) < 2r—k − 2. Then, qL(bk+1) = qL(ak+1), and qL(bk+1) ≥ 2r—k—1 − 2. At last, assume qL(ak+1) < 2r—k—1 − 2. Then, qL(ak+1) < 2r—k − 2 and qL(bk+1) = qL(ak+1). Therefore, qL(bk+1) < 2r—k—1 − 2.
Now, it remains to prove that (v) holds.	Consider Wjj = W1(a1, ..., ak+1)
and Wjj = W2(b1, ..., bk+1).  By contradiction, assume that Gr—k—1(Wjj, Wjj) has
2	1	2
a small disparity. Assume t < 2r—k—1 − 2 such that qУ′′	У′′ and r − k − 1 ≥
t 1 > qt 2
min{qУ′′	У′′ } + [log([ t+1 |)♩ + 2. Then, t < 2r—k − 2. If qУ′  = qУ′ , then
t 1 , qt 2	t 1	t 2
qL(b ) = t and, as t < 2r—k − 2, qL(a ) = t. Therefore, qУ′ /= qУ′ . Thus, there
2
k	k	t	t
exists t < 2r—k such that qУ′ /= qУ′ , and r − k ≥ min{qУ′	У′ }[log([ t+1 |)♩ +2 

1	2
t	t	t
1 , qt 2

because min{qУ′	У′ }≤ min{qУ′′	У′′ } + 1. Then, G
(Wjj, Wjj) do not have

t 1 , qt 2
t 1 , qt 2
r—k—1	1	2

a small disparity. By an analogous way, Gr—k—1(Wjj, Wjj) do not have a large dis-
1	2
parity. Finally, the Duplicator has a winning strategy because (i) holds at each
round.	2
Therefore, EF-similarity between disjoint unions of linear orders W1 and W2 can be computed as follows in polynomial time in the size of W1 and W2.
EFsim(W1, W2)= min(min{min(qУ1 , qУ2 )+ [log([ t+1 |)♩ +2 | q£1 /= q£2 },
t	t	2	t	t
min{min(q£1 , q£2 )+ [log(t)♩ +1 | q£1 /= q£2 }).
≥t  ≥t	≥t	≥t
Distinguishability Sentences
In this section, we define the distinguishability sentences for structures A, B in a class of structures C, and a natural number r. The distinguishability sentences hold in A, do not hold in B, and they have quantifier rank at most r. We define the set

of distinguishability sentences Φr
in a way such that the Spoiler has a winning

strategy in Gr(A, B) if and only if there exists ϕ ∈ Φr
. This result follows from

Theorem 2.5. The first step is to show that the conditions characterizing winning strategies for the Spoiler can be expressed by first-order sentences of size polynomial in the size of the structures. This result is important in order to guarantee that our

algorithm runs in polynomial time in the size of the sample. These formulas are also important to help the explanation, and they improve readability of sentences returned by our algorithm.

Monadic Structures
First, we define |Pi| ≥ n, for i ∈ {1, ..., k + 1}, as a sentence describing that the number of elements in Pi is at least n:
n	n
|Pi|≥ n := ∃x1...∃xn(  xl /= xj ∧  Pi(xl)).
l/=j	l=1
Clearly, qr(|Pi| ≥ n) = n, the size of |Pi| ≥ n is O(n2), and A |= |Pi| ≥ n iff
|PA| ≥ n. We also define abbreviations |Pi| ≤ n := ¬|Pi| ≥ n + 1 and |Pi| = n :=
|Pi|≥ n∧ |Pi|≤ n. Now, we can define the distinguishability sentences for monadic structures.
Definition 4.1 [Distinguishability Sentences for MS] Let M1, M2 be monadic structures. Let r be a natural number.
{|Pi| < m | 1 ≤ i ≤ k + 1, |Pn1 | < |Pn2 |, |Pn1 | +1 ≤ m ≤ min(r, |Pn2 |)}∪

Φr	:=
i	i	i	i

n1,n2
{|P |≥ m | 1 ≤ i ≤ k + 1, |Pn1 | > |Pn2 |, |Pn2 | +1 ≤ m ≤ min(r, |Pn1 |)}.

i	i	i	i	i

Given M1, M2, and r, the size of a sentence ϕ ∈ Φr	is O((|M1| + |M2|)2),

and |Φr
1	2
| is O(k(|M1| + |M2|)). Now, we give an example of the distinguisha-

bility sentences for MS. Then, we show results ensuring adequate properties of the
distinguishability sentences.
Example 4.2 Let M1 = ⟨M1,Pn1 ⟩ and M2 = ⟨M2,Pn2 ⟩ such that |Pn1 | = 2,
1	1	1
|Pn1 | = 3, |Pn2 | = 2, |Pn1 | = 2, and r = 4.  Then, |P2| ≥ 3 ∈ Φr
2	1	2	n1,n2
because |Pn1 | > |Pn2 | and, for m = 3, |Pn2 | +1 ≤ m ≤ min(r, |Pn1 |). Also,
2	2	2	2
observe that |P2| ≥ 4 /∈ Φr	since, for m = 4, m > min(r, |Pn1 |). Finally,
|P1|≥ 2 /∈ Φr	because |Pn1 | = |Pn2 |.
n1,n2	1	1
Lemma 4.3 Let M1, M2 be structures in MS, and r be a natural number. Let

r
n1,n2
. Then, M1 |= ϕ and M2 /|= ϕ.

Proof. Suppose ϕ = |Pi| < m.  Then, |Pn1 | < |Pn2 | and |Pn1 | +1 ≤ m ≤
i	i	i
min(r, |Pn2 |). Therefore, M1 |= ϕ because |Pn1 | < m. Clearly, m ≤ |Pn2 |.
i	i	i
Then, M1 /|= ϕ. The case in which ϕ = |Pi|≥ m is similar.	2
Lemma 4.4 Let M1, M2 be structures in MS, and r be a natural number. Let

r
n1,n2
. Then, qr(ϕ) ≤ r.

Proof. Let ϕ = |Pi| Ð m where Ð ∈ {<, ≥}. Hence, qr(ϕ)= m. As m ≤ r, then
qr(ϕ) ≤ r.	2

Now, we show that, over MS, any first-order sentence is equivalent to a boolean combination of distinguishability sentences. First, we define formulas equivalent to Hintikka formulas over MS.
Lemma 4.5 |= ϕr ↔  k+1 ϕr,i such that
n	i=1	У
⎧⎨ |Pi| = |Pn|,  if |Pn| < r 
⎩ |Pi|≥ r,	otherwise.
Proof. Let Mj |= ϕr . Then, the Duplicator has a winning strategy in Gr(M, Mj).
n	′	′
Then, for all i, |Pn| = |Pn | or (|Pn| ≥ r and |Pn | ≥ r). Let i such that

n	i n	in′	i
i
j	r,i	n

|Pi  | < r. Then, |Pi  | = |Pi	|. Therefore, M |= ϕn. Let i such that |Pi  |≥ r.
Then, |Pn′ | ≥ r. Therefore, Mj |= ϕr,i . Finally, Mj |=  k+1 ϕr,i . Conversely,
let Mj |=  k+1 ϕr,i . Then, Mj |= ϕr,i , for all i. If ϕr,i = (|Pi| = |Pn|), then
|Pn| = |Pn′ |. If ϕr,i = |P |≥ r, then (|Pn|≥ r and |Pn′ |≥ r). Then, for all i,
i	i	n	i	i	i
|Pn| = |Pn′ | or (|Pn|≥ r and |Pn′ |≥ r). Therefore, Mj |= ϕr  .	2
i	i	i	i	n
Now, we need the following lemmas.
Lemma 4.6 Let r be a natural number and M be a structure in MS. There exists a set of monadic structures Vi such that ϕr,i is equivalent to a boolean combination
n
r
Proof. If ϕr,i = |P |≥ r, then |Pn|≥ r. Let V = {Mj} such that |Pn′ | = r − 1.
n	i	i	i	i
Then, |P |≥ r ∈ Φr	because |Pn| > |Pn′ | and m = r. If ϕr,i = (|P | = |Pn|),
i	n,n′	i	i	n	i	i
then |Pn| < r. Let Vi = {M1, M2} such that |Pn1 | = |Pn|− 1 and |Pn2 | =
i	i	i	i
|Pn| + 1. Then, |Pi| ≥ |Pn| ∈ Φr	because |Pn| > |Pn1 | and m = |Pn|.
i	i	n,n1	i	i	i
Also, |Pi| < |Pn| +1 ∈ Φr	because |Pn| < |Pn2 | and m = |Pn| + 1.
i	n,n2	i	i	i
Therefore, ϕr,i is equivalent to |Pi|≥ |Pn|∧ |Pi| < |Pn| + 1.	2
n	i	i
Lemma 4.7 Let r be a natural number and M be a structure in MS. There exists

a set of monadic structures V such that ϕr
is a boolean combination of sentences

in  n′∈V Φr	′ .

Proof. By Lemma 4.5, |= ϕr
↔  k+1 ϕr,i. Let V =  k+1 Vi such that Vi is as in

Lemma 4.6. It follows that, ϕr  is equivalent to a boolean combination of sentences
in  n′∈V Φr	′ .	2
By Theorem 2.6, any first-order sentence is a disjunction of Hintikka formulas. Thus, the following result states that, over MS, any first-order sentence is equivalent to a boolean combination of distinguishability sentences.
Theorem 4.8 Let ϕ be a ﬁrst-order sentence over MS. Then, there exists two sets
U , V of monadic structures such that ϕ is equivalent to a boolean combination of
sentences in  n∈U,n′∈V Φr	′ .

Proof. Let r such that qr(ϕ)= r. From Theorem 2.6 it follows that |= ϕ ↔ ϕr	∨
1

...ϕr
s
. Let U = {M1, ..., Ms}. In accord to Lemma 4.7, let Vj be such that ϕr	is

equivalent to a boolean combination of sentences in  n′∈Vj
r
nj ,n
′ . Therefore, ϕ

is equivalent to a boolean combination of sentences in  s
( n′∈Vj
r
nj ,n
′ ) and

 s	(  ′	Φr
′ ) ⊆ 
′	Φr
′ .	2


Equivalence Structures
In this subsection, we deal with the distinguishability sentences for equivalence structures. First, we define the following formulas:

p	t	t
ϕq≥t≥p = ∃x1...∃xp(  ¬E(xl, xj)∧  ∃y2...∃yt(  yj /= xk∧  yl /= yj∧  E(yj, xk))).





ϕq ≥p :=
l/=j

∃x1...∃xp( l<j
k=1

¬E(xl, xj) ∧  p
j=2

∃y2...∃yt( t
l<j

yj /= xk ∧ 
j=2

l/=j yl /= yj ∧

t	 t
E(y ,x ) ∧ ∀z(E(z, x ) → (z = x
∨  t
z = y )))).

Sentences of the form ϕq≥t≥p hold on equivalence structures such that the number of equivalence classes of size at least t is at least p. Each variable xk represents an element in a distinct equivalence class. Variables yi guarantee that a class has at least t elements. Formulas ϕqt≥p are true when the number of equivalence classes of size t is at least p. Variable z forces that any element from an equivalence class represented by an element xk is xk or one of yi for i ∈ {2, ..., t}. We also define ϕqt<p := ¬ϕqt≥p and ϕq≥t<p := ¬ϕq≥t≥p.  Clearly, qr(ϕq≥t≥p) = t + p − 1 and
3
qr(ϕqt≥p)= t + p. Also, the size of ϕq≥t≥p and ϕq ≥p is O((p + t) ). Next, we define
the distinguishability sentences for equivalence structures.
Definition 4.9 [Distinguishability Sentences for ES] Let E1, E2 be equivalence structures and r be a natural number.
{ϕq <m | 1 ≤ t ≤ r, q£1 < q£2 , q£1 +1 ≤ m ≤ min(r − t, q£2 )}∪
t	t	t	t	t
{ϕq ≥m | 1 ≤ t ≤ r, q£1 > q£2 , q£2 +1 ≤ m ≤ min(r − t, q£1 )}∪

Φr	:=	t
t	t	t	t

£1,£2
{ϕ
| 1 ≤ t ≤ r, q£1 < q£2 , q£1 +1 ≤ m ≤ min(r − t + 1, q£2 )}∪

q≥t<m
≥t	≥t  ≥t	≥t

{ϕ≥q ≥m | 1 ≤ t ≤ r, q£1 > q£2 , q£2 +1 ≤ m ≤ min(r − t + 1, q£1 )}.
t	≥t	≥t  ≥t	≥t
For equivalence structures E1, E2, and a natural number r, the size of a sentence

r
£1,£2
is O((|E1| + |E2|)3). Furthermore, |Φr
| is O((|E1| + |E2|)2).  In

what follows, we give examples of the distinguishability sentences for equivalence
structures.

Example 4.10 Let E1 and E2 be equivalence structures such that q£1
= 3 and

q£2 = 2, and r = 5. Then, ϕq ≥3 ∈ Φr
because q£1 > q£2
and, for m = 3,

2	2
q£2 +1 ≤ m ≤ min(r − 2, q£1 ).
£1,£2	2	2

2	2

Now, we show results ensuring that the distinguishability sentences for equivalence structures hold in the adequate equivalence structures and have quantifier rank at most r.
Lemma 4.11 Let E1, E2 be equivalence structures, and r be a natural number. Let

r
£1,£1
. Then, E1 |= ϕ and E2 /|= ϕ.

Proof. Suppose ϕ = ϕq <m. Then, q£1 < q£2 and q£1 +1 ≤ m ≤ min(r − t, q£2 ).
t	t	t	t	t
Then, E1 |= ϕ because q£1 < m. Also, as m ≤ q£2 , E2 /|= ϕ. The other cases are
t	t
analogous.	2
Lemma 4.12 Let E1, E2 be equivalence structures, and r be a natural number. Let

r
£1,£2
. Then, qr(ϕ) ≤ r.

Proof. If ϕ = ϕqtdm where d ∈ {<, ≥}, then qr(ϕ) = t + m. As m ≤ r − t, then qr(ϕ) ≤ t + r − t = r. If ϕ = ϕq≥tdm, then qr(ϕ) = t + m − 1. Therefore, as m ≤ r − t + 1, qr(ϕ) ≤ t + r − t +1 − 1= r.	2
Now, we show that, over ES, any first-order sentence is equivalent to a boolean combination of distinguishability sentences. First, we need the following lemmas.

Lemma 4.13 |= ϕr ↔ ( r
ϕr,qt ∧  r
ϕr,q≥t ) such that

⎧⎨ ϕ
E ,	if q£ + t +1 ≤ r

⎩ ϕqt>r—t—1,  otherwise.

r,q
⎧⎨ ϕq
=qE
,  if q£
+ t ≤ r

⎩ ϕq≥t>r—t,  otherwise.
Proof. Let Ej |= ϕr . Then, the Duplicator has a winning strategy in Gr(E, Ej).

£
£	£′
£	£′
£	£′

Then, for all t, qt = qt  or r < min{qt , qt } + t + 1, and for all t, q≥t = q≥t or
r < min{q£ , q£′ } + t. First, let t such that r < q£ + t + 1. Then, r < q£′ + t +1 
≥t  ≥t	t	t

because q£ = q£′ or r < min{q£ , q£′ } + t + 1. Besides, ϕr,qt = ϕ
. Therefore,

t	t	t	t
£	qt>r—t—1

Ej |= ϕr,qt . If r ≥ £
£	£′
Ej |= ϕ
. The case

£	qt + t + 1, then qt  = qt . Therefore,
qt=qE

for q£
is analogous. Then, Ej |= ( r
r,qt
£
r
t=1
r,q≥t
£
t
). Conversely, suppose

that Ej |= ( r
ϕr,qt ∧  r
ϕr,q≥t ). Let t such that ϕr,qt = ϕ
. Then,

r < q£ + t + 1 and r < q£′ + t + 1. Therefore, r < min{q£ , q£′ } + t + 1. Let

t
t such that ϕr,qt = ϕ
t
. Clearly, q£	£′
t	t
r,q≥t
is analogous.

£	qt=qE
t = qt . The case for ϕ£

Then, for all t, q£ = q£′ or r < min{q£ , q£′ } + t + 1, and for all t, q£  = q£′ or
t	t	t	t	≥t	≥t
r < min{q£ , q£′ } + t. Therefore, Ej |= ϕr .	2
≥t  ≥t	£
Lemma 4.14 Let r be a natural number, and E be an equivalence structure. There
exists sets of equivalence structures V , V	such that ϕr,qt , ϕr,q≥t are equivalent to
t	≥t	£	£

a boolean combination of sentences in  £′∈Vt
r
£ ,£
′ and  £′∈V≥t
r
£ ,£
′ , respectively.

Proof. If ϕr,qt = ϕ
, then q£ ≥ r−t. Let V
= {Ej} such that q£′ = r−t− 1.

£	qt>r—t—1	t	t	t
Then, ϕq ≥r—t ∈ Φr  ′ because r−t−1+1 ≤ r−t ≤ min(r−t, q£ ). If ϕr,qt = ϕ	E ,

t	£ ,£
t	£	qt=qt

then q£ < r − t. Vt = {E1, E2} such that q£1 = q£ − 1 and q£2 = q£ + 1. Then,
t	t	t	t	t
ϕ	E ∈ Φr	because, for m = q£ , q£1 ≤ m ≤ min(r − t, q£ ) and q£ < r − t. Also,
qt≥qt	£ ,£1	t	t	t	t
ϕ	∈ Φr	as long as q£ +1 ≤ min(r − t, q5) and q£ +1 ≥ r − t. For ϕr,q≥t ,
qt<qE +1	£ ,£2	t	t	t	£
we define V≥t in an analogous way.	2
Lemma 4.15 Let r be a natural number, and E be an equivalence structure. There

exists a set of equivalence structures V such that ϕr
is a boolean combination of

sentences in  £′∈V Φr ′ .
Proof. This proof can be directly adapted from Lemma 4.7.	2
The following result states that, over equivalence structures, any first-order sentence is equivalent to a boolean combination of distinguishability sentences.
Theorem 4.16 Let ϕ be a ﬁrst-order sentence over ES. Then, there exists a natural number r, and two sets U, V of equivalence structures such that ϕ is equivalent to
a boolean combination of sentences in £∈U,£ ′∈V Φr ′ .
Proof. This proof can be directly adapted from Theorem 4.8.	2

Disjoint Unions of Linear Orders
Now, we define the distinguishability sentences for disjoint unions of linear orders. First, we define the following formulas:
⎧ ∃z(z = z),	se n =0 
ϕ<x,>y =	∃z(z < x ∧ y < z),	se n =1 

⎪⎩ ∃z(z < x ∧ y < z ∧ ϕ<z,>y

∧ ϕ<x,>z),  c.c.
2

⎧ ∃y(y = y),	se n =0 
ϕ<x =	∃y(y < x),	se n =1 

⎪⎩ ∃y(y < x ∧ ϕ<y
∧ ϕ<x,>y),  c.c.
2

⎧ ∃y(y = y),	se n =0 
ϕ>x =	∃y(x < y),	se n =1 

⎪⎩ ∃y(y > x ∧ ϕ>y
∧ ϕ<y,>x),  c.c.
2
p

ϕq ≥p := ∃x1...∃xp( (xl /= xj ∧ ¬(xl < xj) ∧ ¬(xl > xj)) ∧  (ϕ<xk
∧ ϕ>xk
)).

t
l/=j
k=1 p
=[ t−1 ♩
=[ t ♩

ϕq≥t
≥p = ∃x1...∃xp( (xl /= xj ∧ ¬(xl < xj) ∧ ¬(xl > xj)) ∧  (ϕ<xk
∧ ϕ>xk
2
)).

l/=j	k=1

Formulas of the form ϕ٨x
such that   ∈ {<, >} and ϕ<x,>y
are used in

the definition of ϕqt≥p and ϕq≥t
≥p. We also define abbreviations ϕ∗x
:= ¬ϕ∗x ,

∗x	∗x
≤n	≥n+1
, and ϕ∗x
:= ϕ≥n ∧ ϕ≤n, for ∗ ∈ {<, >}. These formulas are

defined recursively in order to obtain the adequate quantifier rank. The recur-
sive definitions can all be simplified to direct definitions with higher quantifier ranks but, in this case, we can not guarantee that the quantifier rank is mini- mum. Note that qr(ϕ∗x ) = [log2(n)♩ + 1. Sentences of the form ϕq ≥p express
≥n	t
that the number qt of linear orders of size t is at least p. Each variable xk rep-
resents an element in a linear order. Analogously, ϕq≥t≥p holds in disjoint unions of linear orders such that the number q≥t of linear orders of size at least t is at least p. We also define ϕqt<p := ¬ϕqt≥p, ϕq≥t<p := ¬ϕq≥t≥p. Finally, regarding the
quantifier rank, qr(ϕq ≥p) = p + [log2([ t + 1♩)♩ +1 = p + [log2([ t+1 |)♩ + 1, and
t	2	2

qr(ϕq≥t
2
≥p)= p + [log2(t)♩. Furthermore, the size of ϕqt≥p and ϕq≥t≥p is O((p + n) ).

Now, we define the distinguishability sentences for disjoint unions of linear orders.
Definition 4.17 [Distinguishability Sentences for DULO] Let W1, W2 be disjoint unions of linear orders and r be a natural number.
{ϕq <p | t < 2r — 2, qW1 < qW2 , qW1 +1 ≤ p ≤ min(qW2 ,r — [log2([ t+1 |)♩— 1)}∪
t	t	t	t	t	2
{ϕq ≥p | t < 2r — 2, qW2 < qW1 , qW2 +1 ≤ p ≤ min(qW1 ,r — [log2([ t+1 |)♩— 1)}∪

Φr	:=	t
t	t	t	t	2
W	W	W	W

W1 ,W2
{ϕq
<p | t ≤ 2r — 1,q  1 < q  2 , qt 1 +1 ≤ p ≤ min(qt 2 ,r — [log2(t)♩)}∪

≥t	≥t	≥t

{ϕq
≥p | t ≤ 2r — 1, qW2 < qW1 , qW2 +1 ≤ p ≤ min(qW1 ,r — [log2(t)♩)}.

≥t	≥t	≥t	t	t
Given W1, W2, and r, the size of a sentence ϕ ∈ Φr	is O((|W1| + |W2|)2). Since
t, p ≤ |W1| + |W2|, |Φr	| is O((|W1| + |W2|)2). Now, we show results ensuring
adequate properties of the distinguishability sentences for disjoint unions of linear orders. These results can be directly adapted from Lemma 4.11 and Lemma 4.12.

Lemma 4.18 Let ϕ ∈ Φr
1	2
Lemma 4.19 Let ϕ ∈ Φr
1	2
. Then, W1 |= ϕ and W2 /|= ϕ.
. Then, qr(ϕ) ≤ r.

Now we show that, over DULO, any first-order sentence is equivalent to a boolean combination of distinguishability sentences. The following results can be directly adapted from Lemma 4.13, Lemma 4.14, Lemma 4.15, and Theorem 4.16.
Lemma 4.20 |= ϕr ↔ ( 2r—3 ϕr,qt ∧  2r—1 ϕr,q≥t ) such that

⎧⎨ ϕ

W ,	if qУ +♩log2([ t+1 |)♩ +2 ≤ r

⎩ ϕqt>r—♩log2([ t+1 |)♩—2,  otherwise.



r,q
⎧⎨ ϕq

=qW ,	if qУ + [log(t)♩ +1 ≤ r

⎩ ϕq≥t>r—[log(t)♩—1,  otherwise.
Theorem 4.21 Let ϕ be a ﬁrst-order sentence over disjoint unions of linear or- ders. Then, there exists sets V, U of disjoint unions of linear orders such that ϕ is
equivalent to a boolean combination of sentences in  У∈V,У′∈U Φr	′ .


Algorithm 1.
Input: Sample S = (P, N )
r → max{EFsim(A, B) |A∈ P, B∈ N}
ϕS →  A∈P  5∈N choose ϕ ∈ Φr
return ϕS
The Algorithm for the Distinguishability Problem
In this section, we define an algorithm for finding a first-order sentence ϕS from a sample of structures S. Subformulas of ϕS are distinguishability sentences from sets

of the form Φr
such that A∈ P and B∈ N . We also give an example of how the

algorithm works. We guarantee that our algorithm runs in polynomial time in the size of the input sample S. The size of the sample S is the sum of the sizes of all the structures it includes. We also show that ϕS returned by our algorithm is consistent with S. Furthermore, we also prove that ϕS is a sentence of minimal quantifier rank consistent with S. The pseudocode of our algorithm is in Algorithm 1.
First, the algorithm finds the minimum value r such that there exists a sentence of quantifier rank r that is consistent with the input sample S. After that, the
algorithm builds ϕS. For each pair of structures A∈ P , B∈ N , it chooses ϕ ∈ Φr	.

Any choice of a sentence in Φr
leads to a formula consistent with S. In what

follows, we show an example of how this algorithm works on a simple instance.

Example 5.1 Let P = {W1}, and N = {W2, W3} such that qУ1
= 0, qУ1
= 0,

У1  = 1, qУ1
= 0, qУ2
= 3, qУ2
= 0, qУ3
= 1, qУ3
= 1, qУ3
= 0.

Then, EFsim(W1, W2) = 2 as witnessed by t = 2, qУ1
= 1, qУ2
= 0, and

min(qУ1 , qУ2 )+ [log2(t)♩ +1 = 2.  Furthermore, EFsim(W1, W3) = 2 as wit-
≥t	≥t
nessed by t = 1, qУ1 = 0, qУ3 = 1, and min(qУ1 , qУ3 )+ [log2([ t+1 |)♩ +2 = 2.
t	t	t	t	2

Therefore, max{EFsim(W, Wj) | W ∈ P, Wj ∈ N} = 2. Then, ϕq
2
У1,У2

because qУ1 > qУ2 and, for p = 1, 1 ≤ p ≤ min(1, 1). Besides, ϕq  <2 ∈ Φ2
≥2	≥2	≥1	У1,У3
since qУ1 < qУ3 , and qУ1 +1 ≤ 2 ≤ min(qУ3 , 2). Therefore, Algorithm 1 returns
≥1	≥1	≥1	≥1
ϕS = ϕq≥2≥1 ∧ ϕq≥1<2.
In the following, we prove some properties of our algorithm. First, we show that it returns a sentence that is consistent with the sample. After that, we show that it returns a sentence of minimal quantifier rank. Then, we prove that the running time of our algorithm is polynomial in the size of the input sample.
Theorem 5.2 Let S be a sample and ϕS returned by Algorithm 1. Then, ϕS is consistent with S.
Proof. Let ϕS =  A∈P  5∈N ϕr	such that r = max{EFsim(A, B) |A∈ P, B∈ 

N}, and ϕr	is the sentence chosen from Φr
. Let Aj ∈ P . In this way, Aj |=

  5∈N ϕr ′
, and then Aj |= ϕS. Now, let Bj ∈ N and assume that Bj |= ϕS, i.e,

Bj |
 A ,5	r
Aj ∈
Bj |	r

because, from Lemma 4.18, it follows that Bj /|= ϕr ′
′ .	2

Theorem 5.3 The sentence ϕS returned by Algorithm 1 is a ﬁrst-order sentence of minimal quantiﬁer rank that is consistent with S.
Proof. Suppose a first-order sentence ψ consistent with S such that qr(ψ) < qr(ϕS) = max{EFsim(A, B) | A ∈ P, B ∈ N}. Let Aj ∈ P and Bj ∈ N such that EFsim(Aj, Bj) = max{EFsim(A, B) | A ∈ P, B ∈ N}.  Then, Aj and Bj are satisfied by the same first-order sentences of quantifier rank q such that q < EFsim(Aj, Bj). Then, Aj |= ψ iff Bj |= ψ. Therefore, ψ is not consistent with
S. This is a contradiction.	2
Theorem 5.4 Given a sample S, Algorithm 1 returns ϕS in polynomial time in the size of S.
Proof. First, the algorithm computes max{EFsim(A, B) |A∈ P, B∈ N} in order to use a suitable quantifier rank. This takes polynomial time because, for a given A ∈ P, B ∈ N , to compute EFsim(A, B) takes polynomial time in the classes of structures we are considering in this work. Then, our algorithm loops over structures

in the sample and, in each loop, it chooses a formula ϕ ∈ Φr
. As the size of each

r
A,5
is polynomial in the size of A and B, and |Φr
| is polynomial in the size

of S, the overall complexity of Algorithm 1 is polynomial time in the size of S. 2

Conclusions and Future Work
We introduced an algorithm that returns, in polynomial time, a first-order sentence of minimal quantifier rank that is consistent with a given sample of structures. Our algorithm works with monadic structures, equivalence structures, and disjoint unions of linear orders. Our work is motivated by the algorithm defined in [14] that runs in exponential time for these classes of structures. Therefore, our approach is an improvement over the work in [14], for the particular problem on MS, ES, and DULO. Also, we think that our algorithm can be useful when it is desirable to compute sentences defining a class of structures from positive and negative struc- tures. For example, as we have outlined in the introduction, disjoint unions of linear orders may represent states of the elementary blocks world planning. Therefore, for disjoint unions of linear orders, our algorithm can be used to define initial and final states of this problem. In the elementary blocks world planning, given initial and final states, the goal is to find a sequence of actions capable of transforming the initial state into a final state.
The algorithm defined in [14] uses Hintikka formulas which have size exponential in the size of a given structure. Then, we also introduced the distinguishability sen- tences which are defined based on the conditions characterizing winning strategies for the Spoiler on MS, ES, and DULO. Given two structures A, B and a natural number r, the distinguishability sentences hold in A, do not hold in B, and have quantifier rank at most r. Besides, the size of a distinguishability sentence is poly- nomial in the size of these structures. Furthermore, given A, B and r, the number of distinguishability formulas is also polynomial in the size of A and B. Finally, we also show that any first-order sentence is equivalent to a boolean combination of

distinguishability sentences. This result suggests that our approach is likely to find any first-order sentence given a suitable sample of strings.
As future work, we intend to investigate algorithms for the distinguishability problem on other classes of structures. For example, equivalence structures with colors, embedded equivalence structures, and trees with level predicates [15]. For these classes of structures, the problem of determining if the Spoiler has a winning strategy is solved in exponential time. Besides, we intend to consider the class of strings with a built-in linear order [18]. These classes are interesting because first- order logic over strings with a built-in linear order captures star-free languages [24]. An algorithm for the distinguishability problem over strings can be used to derive a recognizer of a star-free language from a sample of strings. This result is significant because strings may be used to model text data, traces of program executions, DNA sequences, and sequences of symbolic data in general.
Finally, we plan to extend our approach to other logics such as monadic second- order logic. Regular languages are exactly the languages definable in monadic second-order logic over strings [1,16]. An algorithm which returns monadic second- order sentences consistent with a given sample of strings can be used in the problem of finding a model of a regular language consistent with a given sample of strings [12,25].

References
Richard J. Bu¨chi. Weak second-order arithmetic and finite automata. Zeitschrift fu¨r Mathematische Logik und Grundlagen der Mathematik, 6(1-6):66–92, 1960.
Stephen A. Cook and Yongmei Liu. A complete axiomatization for blocks world. Journal of Logic and Computation, 13(4):581–594, 2003.
Luc De Raedt. Logical and Relational Learning. Springer, 2008.
Heinz-Dieter Ebbinghaus and Jo¨rg Flum. Finite Model Theory. Springer, 1995.
Heinz-Dieter Ebbinghaus, J¨org Flum, and Wolfgang Thomas. Mathematical Logic. Springer, 1994.
Andrzej Ehrenfeucht. An application of games to the completeness problem for formalized theories.
Fundamenta Mathematicae, 49(2):129–141, 1961.
Malik Ghallab, Dana Nau, and Paolo Traverso. Automated Planning: Theory and Practice. Elsevier, 2004.
Erich Gr¨adel, P. G. Kolaitis, L. Libkin, M. Marx, J. Spencer, Moshe Y. Vardi, Y. Venema, and Scott Weinstein. Finite Model Theory and Its Applications. Springer, 2005.
Martin Grohe, Christof L¨oding, and Martin Ritzert. Learning MSO-definable hypotheses on strings. In International Conference on Algorithmic Learning Theory, pages 434–451. PMLR, 2017.
Martin Grohe and Martin Ritzert. Learning first-order definable concepts over structures of small degree. In 2017 32nd Annual ACM/IEEE Symposium on Logic in Computer Science (LICS), pages 1–12. IEEE, 2017.
Naresh Gupta and Dana S. Nau. On the complexity of blocks-world planning. Artificial Intelligence, 56(2-3):223–254, 1992.
Marijn Heule and Sicco Verwer. Exact DFA identification using SAT solvers. In International Colloquium on Grammatical Inference, pages 66–79. Springer, 2010.
Charles Jordan and L- ukasz Kaiser. Experiments with reduction finding. In International Conference on Theory and Applications of Satisfiability Testing, pages 192–207. Springer, 2013.


L- ukasz Kaiser. Learning games from videos guided by descriptive complexity. In Proceedings of the Twenty-Sixth AAAI Conference on Artificial Intelligence, pages 963–969. AAAI Press, 2012.
Bakhadyr Khoussainov and Jiamou Liu. On complexity of Ehrenfeucht-Fra¨ıss´e games. Annals of Pure and Applied Logic, 161(3):404 – 415, 2009.
Richard E. Ladner. Application of model theoretic games to discrete linear orders and finite automata.
Information and Control, 33(4):281 – 303, 1977.
Leonid Libkin. Elements Of Finite Model Theory. Springer, 2004.
Elisabetta De Maria, Angelo Montanari, and Nicola Vitacolonna. Games on strings with a limited order relation. In International Symposium on Logical Foundations of Computer Science, pages 164–
179. Springer, 2009.
Angelo Montanari, Alberto Policriti, and Nicola Vitacolonna. An algorithmic account of Ehrenfeucht games on labeled successor structures. In Logic for Programming, Artificial Intelligence, and Reasoning, pages 139–153. Springer, 2005.
Stephen Muggleton. Inductive logic programming. New Generation Computing, 8(4):295–318, 1991.
Stephen Muggleton and Luc De Raedt. Inductive logic programming: Theory and methods. The Journal of Logic Programming, 19:629–679, 1994.
Elena Pezzoli. Computational complexity of Ehrenfeucht-Fra¨ıss´e games on finite structures. In
Computer Science Logic, pages 159–170. Springer, 1999.
Thiago Alves Rocha, Ana Teresa Martins, and Francicleber Martins Ferreira. On finding a first-order sentence consistent with a sample of strings. In International Symposium on Games, Automata, Logics, and Formal Verification, pages 220–234. Open Publishing Association, 2018.
Wolfgang Thomas. Classifying regular events in symbolic logic. Journal of Computer and System Sciences, 25(3):360–376, 1982.
Ilya Zakirzyanov, Anatoly Shalyto, and Vladimir Ulyantsev. Finding all minimum-size DFA consistent with given examples: SAT-based approach. In International Conference on Software Engineering and Formal Methods, pages 117–131. Springer, 2017.
