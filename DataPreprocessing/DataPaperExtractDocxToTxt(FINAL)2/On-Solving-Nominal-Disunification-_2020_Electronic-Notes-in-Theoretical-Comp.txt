Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 348 (2020) 3–22
www.elsevier.com/locate/entcs

On Solving Nominal Disunification Constraints 1
Mauricio Ayala-Rinc´on†,‡, Maribel Ferna´ndez∗, Daniele Nantes-Sobrinho† and Deivid Vale†2
†Departamentos de Matem´atica e ‡Ciˆencia da Computa¸c˜ao Universidade de Bras´ılia, Bras´ılia-DF, Brazil
∗Department of Informatics, King’s College London, London, UK

Abstract
This paper proposes an extension of first-order disunification problems by taking into account binding operators according to the nominal approach. In this approach, bindings are implemented through atom abstraction, and renaming of atoms is implemented via atom permutations. In the nominal setting, unification
problems consist of equational questions (s ≈α? t) considered under freshness constraints (a#?t) that restrict solutions by forbidding free occurrences of atoms in the instantiation of variables. In addition to equational and freshness constraints, nominal disunification problems include also nominal disunification constraints
(s /≈α? t), and their solutions consist of a substitution and additional freshness constraints such that under these constraints the instantiation of the equations, disequations and freshness constraints with the substitution hold. By re-using nominal unification techniques, this paper shows how to decide whether two nominal terms can be made different modulo α-equivalence. This is done by extending previous results on first-order disunification, and defining the notion of solutions with exceptions in the nominal syntax. A discussion on the semantics of disunification constraints is also given.
Keywords: Nominal Logic, Nominal Semantics, Unification, Disunification


Introduction
Nominal techniques can be used to reason about systems with binders. The binding structure of these systems always requires a method to deal with α-equivalence between objects in the system, i.e., objects (usually parse tree representation of the concrete syntax) are considered equal if they differ only by the name of bound variables. For instance, in the syntax of λ-calculus, terms like λx.x y and λz.z y should be considered equivalent, despite their syntactical differences.
It is common in the literature to consider the α-equivalence relation as part of the syntactical structure of terms of the language. One often says “terms are

1 Work partially funded by CNPq
2 Email: deividvale@mat.unb.br, {dnantes,ayala}@unb.br, maribel.fernandez@kcl.ac.uk

https://doi.org/10.1016/j.entcs.2020.02.002
1571-0661/© 2020 The Author(s). Published by Elsevier B.V.
This is an open access article under the CC BY license (http://creativecommons.org/licenses/by/4.0/).

considered syntactically identical if they are α-convertible”. This means that one considers the quotient of the set of terms by the α-equivalence relation. So one has the problem of which representative of α-equivalence classes should be chosen. One of the most popular strategies to solve this problem is called the “Barendregt Variable Convention”: choose representatives for which the bound variables are mutually distinct and distinct from any free variable in the current context. This strategy solves the problem for handwritten proofs and calculations, but not for implementations. Another treatment of α-equivalence is to get rid of equivalence classes by considering de Bruijn indices instead of variable names. Using de Bruijn indices, free and bound variables are indexed as naturals and thus all objects have unique representations so that one does not need to worry about representatives of equivalence classes. This approach facilitates the implementation of systems with binders but at the cost of readability.
The nominal approach diverges from those above in two important ways: first, one can reason about α-equivalence in a readable way, very close to informal practice, while still remaining fully formal since α-renaming is embedded in the nominal syntax; second, nominal α-equivalence is easy to implement in computer systems.
Nominal terms have atoms (a, b, c.. .) used to represent object-level variables, and variables, or unknowns (X, Y, . . .) used to express variables on the meta-level. Atoms can be abstracted by a binder operator but cannot be instantiated by a substitution, whereas variables cannot be abstracted but can be instantiated by a substitution. For instance, the nominal term [a] t represents the abstraction of atom a in t. To rename an atom a to another atom b we make use of an atom permutation. Permutations are built as lists of atom swappings of the form (a b). The action of π = (a b) over [a] t, denoted by π · t gives as result the term [b] tj where tj is obtained by the replacement of all occurrences of a by b and all occurrences of b by a in t. The action of an atom permutation π over a meta-variable X will be ‘suspended’ in X, written as π · X, and will be ‘executed’ only when X is instantiated. The α-equivalence relation over nominal terms is built using permutations and a freshness relation between atoms and terms, written as a#t, which means that a cannot occur free in t.
Nominal techniques have been widely explored and investigated for the last years [12,3,17]. Nominal unification has also been developed [19,8], and more recently, works on unification modulo equational theories [1,2,4] have also been developed. Unification is the problem of finding a substitution σ that makes two terms ‘equal’ i.e., sσ ≈α tσ. In the nominal setting, α-equality comes with freshness conditions for atoms, which should be taken into account when dealing with nominal unification problems. For instance, the problem of unifying λ [a] X and λ [b] Y reduces to the problem of unifying X ≈α? (b a) · Y under the condition that a#Y . Therefore, a solution to a nominal unification problem will be a pair ⟨Γ, σ⟩ consisting of a set of freshness constraints Γ, and a substitution over variables σ. Several applications of nominal unification exist, for instance, in logic programming, automatic deduction, theorem proving, among others.
This work is about nominal disuniﬁcation, that is, the problem of solving nominal

unification questions enriched with disequations, i.e., constraints of the form s /≈α? t. For example, consider the unification problem λ [a] X ≈α? λ [b] Y as above, but imposing the condition that solutions can neither map X to the atom a nor Y to the atom b. This condition may be given as a set of disequations, and solutions should be computed in such a way that they (and therefore, their instances) satisfy the imposed restriction. The nominal disuniﬁcation constraint is then represented as:
Dλ [a] X ≈α? λ [b] Y  || X /≈α? a, Y /≈α? bE

Imposing such conditions has some side-effects that need to be addressed in order to be able to formally state a definition of solution. In a more general view, a nominal disunification problem is given as P = ⟨Δ ▶ s1 ≈α? t1,..., sn ≈α? tn |∇▶ u1 /≈α? v1,..., um /≈α? vm⟩, and a solution to such problem is a pair ⟨Γ, σ⟩ of a context Γ and a substitution σ, such that σ makes terms of each equation equal, but leaves those of the disequations different, while satisfying the freshness constraints Δ and
∇.
The strategy proposed by Buntine and Bu¨rckert [6] to solve systems containing first-order equations and disequations is followed in the current work. But its extension to the nominal setting is not straightforward since the notions of equality and disequality are different and the freshness side conditions add extra constraints to the problem. The standard nominal unification algorithm [19] can be reused to provide solutions to nominal unification problems, and following Buntine and Bu¨rckert’s approach, we show that nominal disequations can be treated in a nominal term-algebra.
The main contributions of this paper can be summarized as follows.
We extend first-order disunification problems to the nominal framework intro- ducing nominal constraint problems.
	From the semantics point of view, we show that Birkhoff’s HSP Theorem (Theorem 2.14), as in the first-order case, does not hold for nominal disequations (Example 2.16).
	We extend the notion of substitution with exceptions to solution pairs that consist of a freshness context and a substitution, with exceptions (Definition 3.5). In addition, a version of the Consistency Test Algorithm (Algorithm 1) to deal with pairs with exceptions is proposed.
We propose a sound, complete, and terminating (provided nominal unification is finitary) procedure (Algorithm 2) to solve nominal disunification constraints that reuses the nominal unification algorithm.
We prove that the Representation Theorem holds in the nominal approach to disunification (Theorem 4.3).

Outline of the paper
Section 2 establishes the main required notions on nominal syntax and semantics, equality and unification. Section 3 introduces the nominal constraint problems as well

as a generalized notion of instantiation and proves some results on the consistency of pairs with exceptions. Section 4 shows how to solve nominal constraint problems by reusing the nominal unification algorithm. Section 5 describes related work and Section 6 concludes the paper.

Preliminaries
We assume the reader is familiar with nominal syntax and sets and recall the main concepts and notations that are needed in the paper; for more details we refer the reader to [12,17].

Nominal Syntax
Fix countable disjoint sets of variables X  = {X, Y, Z, ... } and atoms A  =
{a, b, c, d, ··· }. Variables represent meta-level unknowns and atoms object level variable symbols. Atoms are identified by their name, so it will be redundant to say two atoms a and b are different. A signature Σ is a set of term-formers such that each f ∈ Σ is assigned a unique non-negative integer n, called the arity of f , written as f : n.
A permutation π is a bijection A → A with finite domain, i.e., the set supp(π) :=
{a ∈ A | π(a) /= a} is finite. Write id for the identity permutation. The composition of two permutations π and πj will be denoted as π ◦ πj.
Definition 2.1 [Nominal Terms] Let Σ be a signature disjoint from A and X. The set T (Σ, A, X) of nominal terms is inductively generated by the following grammar:
s, t, u, v ::= a | π · X | [a] t | f (t1,..., tn)
where a is an atom term, π · X is a moderated variable (or suspension), [a] t denotes the abstraction of the atom a in the term t, and f (t1,..., tn), for f : n in Σ, is a function application.
Example 2.2 Let Σλ := {lam : 1, app : 2} be the signature for the λ-calculus (for a complete axiomatization of the λ-calculus within the nominal syntax the reader is referred to [14]). If one consider λ-variables as atoms λ-terms can be inductively generated by the grammar:
e ::= a | lam([a] e) | app(e, e)
To simplify notation, write app(s, t) as st and lam([a] s) as λ [a] s. The following are examples of nominal terms:
(λ [a] a) X	(λ [a] (λ [b] b a) c) d
Definition 2.3 [Action of permutations] The object-level action of a permutation

π on a term t is defined by induction on the structure of t, as follows:
π · a ≡ π(a)	π · (γ · X) ≡ (π ◦ γ) · X	π · [a] t ≡ [π · a] (π · t) π · f (t1,..., tn) ≡ f (π · t1,...,π · tn)
As usual, substitutions are defined as maps from variables to nominal terms with finite domain. We inductively extend the action of a substitution from variables to terms, in the following way:
Definition 2.4 [Action of substitutions] The action of a substitution σ on a term
t, denoted as tσ, is inductively defined by:
aσ ≡ a	(π · X)σ ≡ π · (Xσ)	([a] t)σ ≡ [a] (tσ)	f (t1,..., tn)σ ≡ f (t1σ,..., tnσ) Substitutions are written in postfix notation: t(σγ) ≡ (tσ)γ.
Equality and Derivability
Equality in nominal terms corresponds in fact to α-equality and relies on the notion of “fresh variable”. Two fundamental predicates are freshness, #, and alpha-equality,
≈α:
a#t means that the atom a cannot occur free in t;	• s ≈α t means that s is α-equivalent to t.
Constraints are generated by the grammar
P, Q, C := a#t | s ≈α t
The first constraint a#t is called a freshness constraint whereas s ≈α t is called an α-equality constraint. A freshness constraint of the form a#X or a#a is called primitive. Validity of freshness and equality constraints is specified via the natural deduction rules in Figures 1 and 2.



(#ab)
π−1(a)#X		 (#a)
a#t

a#b
a#π · X
(#X)
a# [a] t
a# [b] t
(#b)

 a#t1 ··· a#tn  (#f )
a#f (t1,..., tn)

Fig. 1. Derivation rules for freshness
To define ≈α we use the difference set of two permutations
ds(π, γ) := {a ∈ A | π(a) /= γ(a)}.
In the rules defining ≈α below, ds(π, γ)#X denotes the set of constraints {a#X |
a ∈ ds(π, γ)}.
A finite set of primitive freshness constraints is called a freshness context. Write Δ, Γ and ∇ for freshness contexts. We say a context Δ is consistent if it has no occurrence of a#a, for any atom a.





a ≈α a
(#ab)
ds(π, γ)#X
π · X ≈α γ · X (Ds)

	t1 ≈α u1 ··· tn ≈α un	 (F)
f (t1,..., tn) ≈α f (u1,..., un)

	t ≈α u	 (Abs-a)
[a] t ≈α [a] u
 (b a) · t ≈α u	b#t 
(Abs-b)
[a] t ≈α [b] u



Fig. 2. Derivation rules for α-equivalence
Definition 2.5 [Nominal judgment] Nominal algebra has two judgment forms:
A freshness judgment form Δ ▶ a#t is a pair with a context Δ and a freshness constraint a#t.
An α-equality judgment form Δ ▶ s ≈α t is a pair of a context Δ and an
α-equality constraint s ≈α t.
The judgment Δ ▶ a#t (resp. Δ ▶ s ≈α t) means that there exists a proof for a#t (resp. a ≈α t) using the rules of Figure 1 (resp. Figure 2) and the constraints of Δ as assumptions. We say that Δ entails a#t (resp. s ≈α t) or that the constraint is derivable from Δ. As usual, Δ /▶ C denotes that the constraint C cannot be derived from Δ. The notion of derivability can be extended to sets of constraints as expected.
Simpliﬁcation rules for nominal uniﬁcation
Nominal unification is the problem of making two nominal terms, say s and t, α-equivalent, denoted as s ≈α? t. Deciding this may require to decide whether an atom a is fresh for a term t, denoted as a#?t. Since t may contain variables, a freshness context Δ is necessary. The content of this section is taken from [12].
Definition 2.6 [Nominal Unification Problem] A nominal uniﬁcation problem Pr is a pair ⟨Δ,P⟩ consisting of a freshness context Δ and a finite set P of freshness and α-equality constraints of the form a#?t and s ≈α? t, respectively.
A sound and complete procedure for nominal unification was proposed in [19] and consists of applying the Simplification Rules of Figure 3. For freshness contexts ∇ and ∇j and a substitution σ, the instance ∇σ denotes the set {a#Xσ | a#X ∈ ∇} and ∇▶ ∇jσ denotes ∇▶ a#Xσ, for all a#X ∈ ∇j.
Definition 2.7 A solution for a nominal unification problem Pr = ⟨∇,P⟩ is a pair of the form ⟨Γ, σ⟩ where Γ is a consistent context and σ a substitution such that the following conditions hold:
Γ ▶ ∇σ;
Γ ▶ a#tσ, for all a#?t ∈ Pr;
Γ ▶ tσ ≈α sσ, for all s ≈α? t ∈ Pr;
Xσ ≡ Xσσ.

If there is no such ⟨Γ, σ⟩ we say that Pr is unsolvable.
Let Pr be a unification problem as above. We write U (Pr) to denote the set of all solutions of Pr. Solutions in U (Pr) are compared by the following partial order, called instantiation ordering.
Definition 2.8 Let Γ1, Γ2 be consistent contexts, and σ1, σ2 substitutions. Then
⟨Γ1, σ1⟩≤ ⟨Γ2, σ2⟩ when there exists a substitution δ such that
for all X ∈ X, Γ2 ▶ Xσ1δ ≈α Xσ2  and  Γ2 ▶ Γ1δ In this case we say ⟨Γ2, σ2⟩ is an instance of the pair ⟨Γ1, σ1⟩ on X.
Definition 2.9 A principal (or most general) solution to a problem Pr is a least
element of U (Pr).

a#?b, Pr =⇒ Pr 
a#?π · X, Pr =⇒ π—1(a)#?X, Pr	π /= id
a#? [a] t, Pr =⇒ Pr 
a#? [b] t, Pr =⇒ a#?t, Pr
a#?f (t1, ··· , fn),Pr =⇒ a#?t1, ··· , a#?tn,Pr
a ≈α? a, Pr =⇒ Pr 
π · X ≈α? γ · X, Pr =⇒ ds(π, γ)#X, Pr
f (s1, ··· , sn) ≈α? f (t1, ··· , tn),Pr =⇒ s1 ≈α? t1, ··· , sn ≈α? tn,Pr
t ≈α? [a] u, Pr =⇒ t ≈α? u, Pr
l ≈α? [a] r, Pr =⇒ (a b) · l ≈α? r, a#l, Pr

π · X ≈α? t, Pr
?
[X/π−1·t]
=⇒	Pr[X/π
[X/π−1·t]	1
· t], if X ∈/ vars(t)

t ≈α  π · X, Pr
=⇒	Pr[X/π
· t], if X ∈/ vars(t)



Fig. 3. Simplification rules for unification problems

The rules from Fig. 3 induce a reduction relation on problems by “running the derivation rules in reverse”, in no particular order. Write Pr =⇒ Prj when Prj is obtained from Pr by the application of a simplification rule from Fig. 3, and =∗⇒ for the transitive and reflexive closure of =⇒.
The nominal unification algorithm, called unify in the next sections, consists of applying the simplification rules to a problem Pr = ⟨Δ,P⟩ until no more rules can be applied.
Lemma 2.10 ([12]) The relation =⇒ is strong normalizing and preserves solutions of problems, that is, Pr =⇒ Prj implies U (Pr)= U (Prj).

We say that an equality problem t ≈α? u is reduced when one of the following holds:
t := a and u := b are distinct atoms
	Precisely one of t and u is a moderated variable and the other mentions that variable.
t and u have different term constructors at the root and neither is a variable.
t and u are applications with different term-formers.
We call a reduced equation, as above, inconsistent. Also, a freshness problem a#?t is reduced if it is of the form a#?X or a#?a. The former is called consistent and the latter inconsistent.
Normal forms are unique modulo renaming of variables, as in standard first-order unification. The normal form of a unification problem Pr by =⇒ is defined as expected and denoted by ⟨Pr⟩nf. It consists of a set of equations and freshness constraints in reduced form. Pr has a solution iff ⟨Pr⟩nf contains only consistent reduced freshness constraints, i.e., freshness constraints of the form a#X.
Example 2.11 Consider the signature of lambda-calculus as in Example 2.2 and the problem below. We apply the simplification rules from Fig. 3 to get:
{(λ [a] X)Z ≈α? (λ [b] Y )b} =⇒ {λ [a] X ≈α? λ [b] Y, Z ≈α? b}

[Z/b]
=⇒ {λ [a] X ≈α
λ [b] Y }

=⇒ {(b a) · X ≈α? Y, b#?X}
[Y/(b a)·X]	?
=⇒	{b# X}
Solution: ⟨b#X, [Z/b, Y/(b a) · X]⟩

Semantic Notions
The semantics of solving equations is given by the nominal (universal) algebra. In [13], Gabbay gives an interpretation for nominal equational theories in nominal sets, constructs the initial ground algebra 3 F(T, D) for a nominal theory T = (Σ, Ax) consisting of a signature Σ, a set of axioms Ax of the form Δ ▶ s = t and a set of term-forms D disjoint from Σ, and proves a version of the HSP (Homomorphism, Subalgebra, Product) theorem for nominal algebras. Roughly speaking, the (HSP) theorem states that nominal equational varieties are closed under homomorphic images, subalgebras, products and atom abstraction. Basic definitions such as nominal sets, support, equivariance, and so on, are assumed and can be found in [17]. Below we give some semantic definitions and results taken from [15].
To start, derivations in a theory T = (Σ, Ax) are defined by the rules in Figures 1 and 4. We say Π is a valid derivation in T when the following two conditions are satisfied:

3 F(T, D) is called free algebra in [13]

Π mentions only terms in the signature Σ.
Π mentions only instances of (axΔ∗▶t=u) such that (Δj ▶ t = u) ∈ Ax.



Δ ▶ t = t
(refl)
 Δ ▶ t = u (symm) Δ ▶ u = t
 Δ ▶ t = u	Δ ▶ u = v  (trans) Δ ▶ t = v

Δ ▶ π(a)#π · Xσ for every a#X ∈ Δj Δ ▶ π · tσ = π · uσ

(axΔ∗▶t=u)

		Δ ▶ t = u	 (cong[]) Δ ▶ [a]t = [a]u
Δ, a#X ▶ t = u (a ∈/ t, u)
Δ ▶ t = u	(fr)
		Δ ▶ t = u	 (congf ) Δ ▶ f (..., t,.. .)= f (...u.. .)
Δ ▶ a#t	Δ ▶ b#t	(perm) Δ ▶ (a b) · t = t



Fig. 4. Derivation rules for equality
To obtain the correctness of nominal equational logic, a relation between the syntax and semantics (as in Birkhoff’s Theorem) will be established. For more details, we address the reader to [13], some extra concepts are included in the Appendix A.
For any nominal sets X and Y call a function f ∈ X → Y equivariant when
π · f (x)= f (π · x), for any x ∈ X and π ∈ P.
Definition 2.12 [Σ-algebra] A Σ-algebra A consists of:
A domain nominal set A = (AS, ·), i.e., AS is a set equipped with a P-group action
· such that each x ∈ A has finite support.
An equivariant map atom : A → AS to interpret atoms; we write the interpretation
atom(a) as aA ∈ A.
An equivariant map abs : A×AS → AS such that a#abs(a, x) always, to interpret abstraction.
An equivariant map f A : An → AS for each term-former f : n ∈ Σ to interpret
term-formers.
Σ-algebras are usually denoted by A, B.
As expected, a valuation ς in a Σ-algebra A maps unknowns X to elements
ς(X) ∈ AS. Below we define a equivariant function J·)ς to interpret nominal terms
w.r.t. a valuation ς.
Definition 2.13 Let A be a nominal algebra. Suppose that t ∈ T (Σ, A, X) and

consider a valuation ς in A. The interpretation Jt)A, or just Jt)
if A is understood,

ς	ς
is defined inductively by:
Ja)ς = aA	Jπ · X)ς = π · ς(X)	J[a] t)ς = abs(a, Jt)ς )
Jf (t1,..., tn))ς = f A(Jt1)ς ,..., Jtn)ς )
We say a context interpretation JΔ)A is valid when a#ς(X) for each a#X ∈ Δ. In the same way, JΔ ▶ a#t)A is valid when JΔ)A implies a# Jt)A and JΔ ▶ t = u)A
ς	ς	ς	ς

when JΔ)A implies Jt)A = Ju)A.
ς	ς	ς
A model of T is a Σ-algebra A such that JΔ ▶ t = u)ς is valid for every axiom Δ ▶ t = u in Ax and every valuation ς. If there is a derivation ending with Δ ▶ t = u
that uses the axioms of T and the derivation rules from Fig. 4 we write Δ ▶T t = u. To obtain models for a nominal equational theory T , the initial ground algebra, F(T, D) is built. As in [13], let D be a set of term-formers disjoint from Σ, they are called ‘extra term-formers’. Then the set of ground nominal terms is generated by
the grammar:
g ::= a | [a] g | f (g1,..., gn) | d(a1,..., am)
Here f : n ranges over elements of Σ and d : m ranges over elements of D (more details can be found in the Appendix).
Note that the initial ground (nominal) algebra is the analogous in the nominal setting to the initial first-order ground algebra T (Σ)/E, where E is a set of equational axioms. The main difference here is that we add some new fresh term-formers from D to provide “enough ground terms” with non-empty support. A nominal algebra variety V for a signature Σ is a collection of Σ-algebras closed under homomorphic images, subalgebras, countable products, and atom-abstractions. We say a collection V of Σ-algebras is equational when there is some theory T = (Σ, Ax) such that V is the collection of all models of T .
Theorem 2.14 (HSP Theorem, Theorem 9.3 in [13]) A collection of Σ- algebras V is equational if, and only if, it is a variety.
We also consider the term-algebra T (Σ, A, X), as in the first-order case, this term-algebra is generic (see [6]) for solving existentially closed equations.
Corollary 2.15 Let φ be the existentially closed equational judgment:

φ ::= ∃X(Δ ▶ s =T t).
Then Δ ▶F(T,Q) φ if, and only if, Δ ▶f (Σ,A,X) φ.
Example 2.16 Corollary 2.15 does not hold for disequations, to see this consider the theory T = (Σ, Ax) where Σ = {f ( )} and Ax = {▶ f (X)= a, ▶ [a] f (X)= a}. In T (Σ, A, X) one can derive ▶ f (b)= a and ▶ f (b)= b:

▶ id · f (X)σ = aσ

         
▶ f (b)= a
(axΔ∗▶f (X)=a)

▶ a = b
▶ (a b) · f (X)σj = (a b) · aσj
▶ f (b)= b
(trans)
(axΔ∗▶f (X)=a)

by taking σ = {X/b} in the left branch and σj = {X/a} in the right branch. The dashed lines in the derivation above represent the result obtained after the application of substitutions σ and σj, and the swapping of names in the axiom ▶ f (X) = a. Therefore, every atom is in the same equivalence class modulo T .
Also, from the axioms of T one can derive ▶ f (t)= a and ▶ [b] f (u)= a for any pair of terms t and u. Hence it is possible to derive ▶ tj = uj for any non-variable terms tj and uj. The other equivalence classes are for variables X, Y, Z . . . .

It follows that ▶f (Σ,F,X) EX.X =/
a. However, F(T, Ð) (with Ð = ∅) has only

one equivalence class, i.e., the class of all ground terms and atoms, therefore,

bF(T,Q) EX.X =/
class modulo T .
a since every ground term and atom are in the same equivalence

Nominal Constraint Problems
In this section, we follow the approach proposed by Buntine and Bu¨rckert [6] for solving a system of equations and disequations. Our approach, as in the first-order case, depends on the unification type of a (nominal) theory T . Fix the nominal algebra f (Σ, F, X) with the empty set of axioms, that is, terms are considered up to the built-in α-equivalence. This theory is called CORE [15], and its deduction rules are given in Fig. 2. The results in this section can be extended to any theory T provided unification is decidable and finitary for this theory; CORE has been chosen to make examples and proofs easier to follow.
Definition 3.1 A (nominal disuniﬁcation) constraint problem P is an ordered pair P = ⟨E || D⟩ where E is a nonempty set of nominal equations-in-context Δ ▶ s ≈α t and D is a (possible empty) set of nominal disequations-in-context ∇▶ p /≈α q, as follows:
E = {Δ1 ▶ s1 ≈α? t1, ··· , Δn ▶ sn ≈α? tn} D = {∇1 ▶ p1 /≈α? q1, ··· , ∇m ▶ pm /≈α? qm}
The sets Δ1,..., Δn, ∇1,..., ∇m are consistent contexts. We call them the initial freshness conditions that are imposed on equations (disequations) in the problem P.
In the case any of the Δi or ∇j of a problem is empty we may write an equation(disequation)-in-context just as si ≈α? ti (pj /≈α? qj) instead of ∅▶ s ≈α? t. We also may consider the equations and disequations of the problems under the same context, Δ := ∪Δi and ∇ := ∪∇j.
Remark 3.2 A constraint problem is equivalent to an existentially closed formula:

P := EX    Δi ▶ si ≈α ti Λ   ∇j ▶ pj /≈α qj  .
We solve these formulas in the nominal term-algebra f (Σ, F, X) (see [13,15]), this is the logical task of finding witnesses/solutions for the variables in P, that is, a pair ⟨Γ, σ⟩ where σ is a substitution for the variables of the formula such that under some (possible empty) consistent context Γ we have Γ ▶ Pσ.
To give some intuition on the construction of solution pairs, consider the constraint problem below:
P = D(b a) · X ≈α? Y || [a] X /≈α? [b] Y E	(1)
The intended effect of a solution ⟨Γ, σ⟩ of P is that it needs to solve the equation (b a) · X ≈α? Y and the disequation [a] X /≈α? [b] Y where solving this disequation

means Γ b [a] Xσ ≈α [b] Y σ, i.e., ⟨Γ, σ⟩ is not a solution of the equation [a] X ≈α?
[b] Y which will be called the associated equation to the problem [a] X /≈α? [b] Y . Notice that,
⟨Γ, σ⟩ = ⟨∅, [Y/(b a) · X]⟩	(2)
solves the constraint problem P above. The main goal of this section is show how to construct these solutions.
In general, instantiation plays an important role in unification theory. It is by instances of more general unifiers (instantiation closure) that one produces a finite representation of all other solutions of a unification problem. Therefore, it is helpful to have the property of instantiation closure to solutions of constraints problems as well. Unfortunately, this is not the case since we are solving constraints in the nominal term-algebra f (Σ, F, X). For an example, let Q be the constraint problem:
Q = DX ≈α? Y || X /≈α? aE

The pair ⟨Γ, σ⟩ = ⟨∅, [X '→ (a b) · Z, Y '→ (a b) · Z]⟩ solves Q. However, if we instantiate this solution with δ = [Z '→ b] the instance ⟨∅, [X/a, Y/a]⟩ is not a solution of Q.
Example 3.3 Let ⟨Γ, σ⟩ = ⟨∅, [Y/(b a) · X]⟩, as in (2). Consider the pair ⟨Γj, σ⟩ =
⟨b#X, [Y/(b a)·X]⟩. Notice that ⟨Γ, σ⟩≤ ⟨Γj, σ⟩, therefore ⟨Γj, σ⟩ solves (b a)·X ≈α?
Y . In addition, ⟨Γj, σ⟩ is a solution of the equation [a] X ≈α? [b] Y associated to
[a] X /≈α? [b] Y . It can not solve (1) since it solves the equations and the associated equation [a] X ≈α? [b] Y .
The reader may wonder if such an anomaly is caused by the context assumptions added on the initial problem or, reasonable enough, even the α-equivalence embedded in the theory of nominal terms. Certainly, context assumptions seem to cause some difficulties. Firstly, because that the notion of instantiation may introduce new freshness constraints, as in Example 3.3. Secondly, freshness conditions on the equational part of a constraint problem can interact with solutions and, as showed in the example below, even change the solvability of a problem.
Example 3.4 Consider the following modification of the original problem (1):
Pj = Db#X ▶ (b a) · X ≈α? Y || [a] X /≈α? [b] Y E

Notice that Pj does not have a solution: every time we solve b#X ▶ (b a) · X ≈α? Y
we always solve the equation [a] X ≈α? [b] Y associated to [a] X /≈α? [b] Y .
We will work on this type of issues in the remaining of this paper. First, we define precisely what we mean by a solution of nominal constraint problems. Keep in mind that our goal is the development of a nominal generalization for the already established notion of instantiation of solutions (Definition 2.8), but this needs to be done in such a way that instantiation closure still holds.

Generalized instantiation
In this subsection, some notions initially established in [6] will be extended into the nominal framework. The main difference is the lifting of the notion of substitution with exceptions to pairs of the form ⟨Γ, σ⟩ consisting of a consistent freshness context and a substitution, in addition of course, to the fact that α-equality is axiomatized in nominal terms which adds some complexity when compared to syntactic equality. Besides, we have adapted the Consistency Test Algorithm (Algorithm 1) to deal with pairs with exceptions.
Definition 3.5 A pair with exceptions, denoted as ⟨Γ, σ⟩− Ψ, consists of a pair
⟨Γ, σ⟩ and an indexed family of the form Ψ = {⟨∇l, ψl⟩| l ∈ I}.
Pairs with exceptions will be used as a representation of solutions of a constraint problem that has restrictions on how they can be instantiated. For instance, in the problem Q above, solutions of the equation X ≈α Y can be instantiated in any way except for the instances where X is mapped to a.
Definition 3.6 [Pair instances]
A pair ⟨Γ, σ⟩ is said to be an instance of a family Ψ= {⟨∇l, ψl⟩| l ∈ I}, denoted by Ψ ≤ ⟨Γ, σ⟩, if and only if each instance of ⟨Γ, σ⟩ is an instance of some ⟨∇l, ψl⟩ in Ψ.
A pair ⟨Δ, λ⟩ is an instance of a pair with exceptions ⟨Γ, σ⟩−Ψ, written ⟨Γ, σ⟩−Ψ ≤
⟨Δ, λ⟩, if and only if ⟨Δ, λ⟩ is an instance of ⟨Γ, σ⟩ but not of Ψ.
Definition 3.7 A pair with exceptions ⟨Γ, σ⟩− Ψ is consistent if and only if it has at least one instance.
For example, the pair with exceptions ⟨b#X, [Y/(b a)·X]⟩−{(b#X, [Y/(b a)·X])} from Example 3.4 is inconsistent. The following lemma is a useful characterization of consistency for pair with exceptions.
Lemma 3.8 (Inconsistency Lemma) A pair with exceptions ⟨Γ, σ⟩− Ψ is incon- sistent if and only if ⟨Γ, σ⟩ is an instance of Ψ.
Proof. (⇒) If ⟨Γ, σ⟩ is an instance of Ψ then all instances ⟨Δ, γ⟩ ≤ ⟨Γ, σ⟩ is an instance of some ⟨∇i, ψi⟩ in Ψ, so by Definition 3.6 ⟨Γ, σ⟩− Ψ has no instances hence it is inconsistent.
(⇐) Conversely, suppose ⟨Γ, σ⟩− Ψ is consistent and ⟨Γ, σ⟩ is an instance of Ψ. Then there exists an instance ⟨Δ, λ⟩ of ⟨Γ, σ⟩− Ψ. Hence ⟨Γ, σ⟩ ≤ ⟨Δ, λ⟩. Since
⟨Γ, σ⟩ is an instance of Ψ we have ⟨∇i, ψi⟩≤ ⟨Γ, σ⟩, by transitivity
⟨∇i, ψi⟩≤ ⟨Γ, σ⟩≤ ⟨Δ, λ⟩
a contradiction with Definition 3.6.	2
Recalling Definition 2.13, we say that a pair with exceptions ⟨Γ, σ⟩ − ψ is inconsistent on a Σ-algebra A iff instances(⟨Γ, σ⟩ − Ψ) = ∅ in A, where instances(⟨∇, ρ⟩)= {⟨∇, ρ⟩ς | for all valuation ς}.

Corollary 3.9 If ⟨Γ, σ⟩− ψ is inconsistent on f (Σ, F, X) then it is inconsistent on the ground algebra F(CORE, Ð).
Proof. If ⟨Γ, σ⟩−ψ is inconsistent on f (Σ, F, X) then each instance ⟨Γj, σj⟩ of ⟨Γ, σ⟩ is in turn an instance of some ⟨Δl, ψl⟩ ∈ Ψ, i.e., in terms of Definition 2.8, there exists δ such that
for all X ∈ X,	Γj ▶f (Σ,F,X) Xσj = Xψlδ	and	Γj ▶ Δlδ.
The result follows from Corollary 2.15. Notice that the converse is not true in general. For instance, consider the theory T as in Example 2.16, all pair with exceptions are inconsistent on F(T, Ð) since it has only one equivalence class but this not happens in f (Σ, F, X).	2
Corollary 3.10 Let ⟨Γ, σ⟩− Ψ be a pair with exceptions. If there is some ⟨∇l, ψl⟩∈ 
Ψ such that there exists a substitution δ satisfying
Γ ▶ Xσ ≈α Xψlδ, for all X ∈ vars(P).
Then ⟨Γ, σ⟩− Ψ is inconsistent if and only if Γ ⊇ ⟨∇lδ⟩nf.
Proof. Consider the pair with exceptions ⟨Γ, σ⟩− Ψ as above. From assumption, σ is an instance of ψl over the context Γ. By the inconsistency lemma this pair with exceptions is inconsistent iff ⟨Γ, σ⟩ is an instance of Ψ. The result follows from the fact that Γ ▶ ∇lδ iff Γ ⊇ ⟨∇lδ⟩nf.	2
The above corollary enables us to algorithmically test if some pair with exceptions is consistent provided that we have already solved the matching-in-context problem (Γ ▶ Xσ) ≈? (Γ ▶ Xψ) (for all variables X appearing in the constraint problem) where Xσ is the pattern (see [12, Definition 45]). That is, for each ψl we solve the unification problem
Γ ▶ X1σ ≈α? X1ψl, ··· , Xnσ ≈α? Xnψl
without instantiating variables of Xiσ, for all 1 ≤ i ≤ n. The solution of this matching problem (if it exists) will be denoted by δ. In [7], the authors give an efficient implementation for the matching problem.
Solving nominal constraints
Finally, we give the formal definition of a solution of a nominal constraint problem and also construct a finite representation for the solution set.
Definition 4.1 Let P = Δ ▶ s1 ≈α?t1, ··· , sn ≈α?tn || ∇ ▶ p1 /≈α?q1, ··· , pm /≈α? qm be a nominal disunification constraint problem. A solution of P is a pair ⟨Γ, σ⟩ of a consistent context Γ and a substitution σ satisfying the following conditions:
⟨Γ, σ⟩ is a solution of the equational part E of P.



Algorithm 1 Consistency Test
input: ⟨Γ, σ⟩− ψ a ﬁnite pair with exceptions.
output: true if the input is consistent false otherwise.
for each ⟨∇l, ψl⟩∈ Ψ do
if matching(Γ, X1σ ≈? X1ψl, ··· , Xnσ ≈? Xnψl)= δ then if Γ ⊇ ⟨∇lδ⟩nf then
return false and stop
end end
end
return true

⟨Γ, σ⟩ satisfies the disequations in the disequational part D of P, that is:
Γ b ∇σ, or
Γ b pσ ≈α qσ, for all p /≈α? q in D.

Algorithm 2 Construction of a complete representation of solutions of constraint problems
input: A disuniﬁcation problem P = ⟨E || D⟩.
output: A ﬁnite set S of pairs with exceptions (possibly empty).
let ⟨Γ, σ⟩ := unify(E)

let Ψ :=
pi/≈α?qi∈D
{⟨∇i, ψi⟩ = unify(∇i, pi ≈α? qi)}

if consistent(⟨Γ, σ⟩− Ψ) then
return ⟨Γ, σ⟩− Ψ
else
return ∅
end

Definition 4.2 We call a set S of pairs with exceptions a complete representation
of the solutions of the constraint problem P iff S satisfies the following conditions:
If ⟨Γ, σ⟩− Ψ ≤ (Δ, λ) for some ⟨Γ, σ⟩− Ψ in S then ⟨Δ, λ⟩ solves P.
If ⟨Δ, λ⟩ solves P then it is an instance of some ⟨Γ, σ⟩− Ψ in S.
⟨Γ, σ⟩− Ψ is consistent for all ⟨Γ, σ⟩− Ψ ∈ S.
Similar to nominal unification problems, we are interested in generating a com- plete finite representation for the set of solutions to a constraint problem P. We use Algorithm 2 to compute such a representation in the form of a pair with ex- ceptions ⟨Γ, σ⟩− Ψ where ⟨Γ, σ⟩ is a solution for the equations in P and the family Ψ= {⟨Δl, ψl⟩} is formed by taking each pair ⟨Δl, ψl⟩ as the solution of the associated equations Δ ▶ pl ≈α? ql, 1 ≤ l ≤ m. Termination of Algorithm 2 follows from the termination of unify, and correctness (soundness and completeness) follows from the Representation Theorem below.

Theorem 4.3 (Representation Theorem) Let
P = DΔ ▶ s1 ≈α? t1, ··· , sn ≈α? tn || ∇ ▶ p1 /≈α? q1, ··· , pm /≈α? qmE

be a nominal constraint problem. Deﬁne the family

Ψ :=	 
p/≈α?q∈D

U  ∇,p ≈α? q  .

Then the set S = {⟨Γ, σ⟩− Ψ | ⟨Γ, σ⟩ ∈ U (E) and Ψ /≤ ⟨Γ, σ⟩} is a complete representation of solutions for the constraint problem P.
Proof.
Take ⟨Λ, λ⟩ an instance of some ⟨Γ, σ⟩− Ψ in S. Then ⟨Γ, σ⟩≤ ⟨Λ, λ⟩ and it is not an instance of Ψ. Since unification problems are closed by instantiation it follows that ⟨Λ, λ⟩ solves the equational part of P. It remains to show that ⟨Λ, λ⟩ solves the disequational part of P. Suppose by contradiction that ⟨Λ, λ⟩ satisfies
∇ ▶ pl ≈α ql for some ∇ ▶ pl /≈α ql in D. Therefore, ⟨Λ, λ⟩ is an instance of ⟨∇l, ψl⟩ (a solution of the associated unification problem ∇ ▶ pl ≈α? ql in D) and every instance of ⟨Λ, λ⟩ is an instance of ⟨∇l, ψl⟩ then Ψ ≤ ⟨Λ, λ⟩, a contradiction.
Suppose ⟨Λ, λ⟩ solves P. Then, ⟨Λ, λ⟩ solves the equational (disequational) part of P. Consider ⟨Γ, σ⟩ ∈ U (E) a solution of E, then we conclude that
⟨Γ, σ⟩≤ ⟨Λ, λ⟩. In addition, ⟨Λ, λ⟩ solves the disequational part of P as well, that is;
Λ b ∇λ	or	Λ b pλ ≈α qλ,	for all p /≈α? q ∈ D	(3)
Assume ⟨Λ, λ⟩ is an instance of Ψ. Then all instances of ⟨Λ, λ⟩ is an instance of some ⟨∇l, ψl⟩ in Ψ. Hence, there is some ⟨∇l, ψl⟩ in Ψ such that
⟨∇l, ψl⟩≤ ⟨Λ, λ⟩.
A contradiction with (3). Therefore, ⟨Λ, λ⟩ can not be an instance of Ψ and, we conclude that ⟨Λ, λ⟩ is an instance of ⟨Γ, σ⟩− Ψ, as required.
2
Remark 4.4
Note that any ground instance of a pair with exception representing a solution of a constraint problem P is also a solution of P. We can restrict solutions to ground instances, but this does not mean that if a problem is solvable in the term-algebra f (Σ, F, X) it is also solvable in the ground algebra F(CORE, Ð), as discussed earlier in Example 2.16.
If one wants to solve a disunification problem in the initial ground algebra, by Lemma 3.8, one needs to test if all ground instances of the solutions to

the equational part E are an instance of the exceptions ψ. For some nominal theories this is not an easy task.
We have a restricted instantiation closure, it is not transitive. In fact, ⟨∅, [X/Z]⟩ is an instance of the pair with exception ⟨∅, [X/Y ]⟩− ⟨∅, [X/a]⟩. Note that
⟨∅, [X/Z]⟩≤ ⟨∅, [X/a]⟩ but the latter is not an instance of ⟨∅, [X/Y ]⟩−⟨∅, [X/a]⟩.
Example 4.5 Consider the constraint problem P below:
P = Dλ [a] X ≈α? λ [b] Y || X /≈α? Y, X /≈α? aE .

First apply unif to the equational part of the problem obtaining as result:
⟨Γ, σ⟩ = ⟨b#X, [Y/(b a) · X]⟩	(4)
Then solve the associated equations of the disequational part to combine them as a family of pairs with exception:
Ψ= {⟨∅, [X/Y ]⟩, ⟨∅, [X/a]⟩}	(5)
Finally form the pair with exception ⟨Γ, σ⟩− Ψ by the combination of (4) and (5). We can check consistency of ⟨Γ, σ⟩− Ψ using Algorithm (1).
Related Work
Disunification problems have been studied extensively in the first-order frame- work [9,10,6,11,5,18] and also in the higher-order one [16].
Buntine and Bu¨rckert [6] solve systems of equations and disequations in equational theories with a finitary unification type; they investigate E-disunification problems with two main applications in mind: the first application is to give a generalization for logic programming to include negation clauses in such a way that solution to queries can be expressed as substitutions other than the limited form of negation, called negation as failure.
The second applications is related with the use of E-disunification as a mecha- nism to drastically reduce the solution space of the unification algorithm for some equational theories. For instance, they showed that associative-commutative uni- fication problems (a.k.a. AC-unification problems) are in fact a kind of so called AC1-disunification problems (associative-commutative functions with a unity 1) that have a solution space considerably smaller than the solution space of standard AC- problems. Differently, Comon and Lescanne [10,9] consider more general problems, called equational problems, which include universally and existentially quantified variables in the algebra of rational trees or in the quotient term-algebra T (F, X) bya congruence =E. They propose a set of transformation rules on equational problems of the form Ew∀y : P1 Λ ... Λ Pn, where Pi, for i = 1..n, is a called a system, that is, an equation of the form s = t or T, or a disequation s /= t or ⊥, or a disjunction Pi1 ∨ ... ∨ Pini of systems. Their strategy consists of applying transformation rules

to the equational problem until a kind of solved form is reached. These problems have applications in sufficient completeness for algebraic specifications defined by sets of rewriting rules.
In [11], Ferna´ndez shows that E-disunification is semi-decidable when the theory E is presented by a ground convergent rewrite system, and gives a sound and complete E-disunification procedure based on narrowing. Baader and Schulz [5] show that solvability of disunification problems in the free algebra of the combined theory E1 ∪ ... ∪ En is decidable if solvability of disunification problems with linear constant restrictions in the free algebras of the theories Ei(1 ≤ i ≤ n) is decidable. Lugiez [16] introduces higher-order disunification problems and gives some decidable cases for which equational problems can be extended to higher-order systems.
Conclusions and Future Work
In this work, we have provided a method to deal with nominal equations constrained by equality constraints in the form of nominal disequations. The approach adapts Buntine and Bu¨rckert’s first-order method to solve disequations taking into account the particularities of nominal syntax and semantics. To the best of our knowledge, this is the first work that deals with disequations in the nominal setting. The main result, Theorem 4.3, establishes the soundness and completeness of the proposed approach.
As future work, we intend to investigate more specific applications of nominal constraint problems; inspired from Buntine and Bu¨rkert’s work we could seek some direct extensions to nominal logic programming with negated equations and apply our results to more general unification theories (for instance, AC and AC1-nominal unification problems). Also, the more general approach to disunification followed by Comon and Lescane [10] using quantified variables will be investigated.

References
Ayala-Rinco´n, M., W. de Carvalho Segundo, M. Ferna´ndez and D. Nantes-Sobrinho, On solving nominal fixpoint equations, in: Proc. 11th International Symposium on Frontiers of Combining Systems, FroCoS, Lecture Notes in Computer Science 10483 (2017), pp. 209–226.
URL  https://doi.org/10.1007/978-3-319-66167-4_12

	Ayala-Rinc´on, M., W. de Carvalho Segundo, M. Fern´andez and D. Nantes-Sobrinho, Nominal c- unification, in: 27th International Symposium on Logic-Based Program Synthesis and Transformation, LOPSTR 2017, Revised Selected Papers, Lecture Notes in Computer Science 10855 (2018), pp. 235–251.
URL  https://doi.org/10.1007/978-3-319-94460-9_14

Ayala-Rinc´on, M., M. Fern´andez and D. Nantes-Sobrinho, Nominal narrowing, in: D. Kesner and
B. Pientka, editors, 1st International Conference on Formal Structures for Computation and Deduction, FSCD 2016, June 22-26, 2016, Porto, Portugal, LIPIcs 52 (2016), pp. 11:1–11:17.
URL https://doi.org/10.4230/LIPIcs.FSCD.2016.11

	Ayala-Rinco´n, M., M. Ferna´ndez and D. Nantes-Sobrinho, Fixed-point constraints for nominal equational unification, in: H. Kirchner, editor, 3rd International Conference on Formal Structures for Computation and Deduction, FSCD 2018, July 9-12, 2018, Oxford, UK, LIPIcs 108 (2018), pp. 7:1–7:16.
URL https://doi.org/10.4230/LIPIcs.FSCD.2018.7

Baader, F. and K. U. Schulz, Combination techniques and decision problems for disunification, Theor. Comput. Sci. 142 (1995), pp. 229–255.
URL  https://doi.org/10.1016/0304-3975(94)00277-0


Buntine, W. L. and H.-J. Bu¨rckert, On solving equations and disequations, J. ACM 41 (1994), pp. 591– 629.
URL http://doi.acm.org/10.1145/179812.179813

Calv`es, C. and M. Fern´andez, Matching and alpha-equivalence check for nominal terms, Journal of Computer and System Sciences 76 (2010), pp. 283 – 301.
URL https://doi.org/10.1016/j.jcss.2009.10.003
Cheney, J., Equivariant unification, Journal of Automated Reasoning 45 (2010), pp. 267–300.
URL  https://doi.org/10.1007/s10817-009-9164-3

	Comon, H., Disunification: a Survey, in: J.-L. Lassez and G. Plotkin, editors, Computational Logic: Essays in Honor of Alan Robinson, MIT Press, 1991 pp. 322–359.
Comon, H. and P. Lescanne, Equational problems and disunification, Journal of Symbolic Computation
7 (1989), pp. 371 – 425, unification: Part 1.
URL http://www.sciencedirect.com/science/article/pii/S0747717189800173

Ferna´ndez, M., Narrowing based procedures for equational disunification, Appl. Algebra Eng. Commun. Comput. 3 (1992), pp. 1–26.
URL https://doi.org/10.1007/BF01189020

	Ferna´ndez, M. and M. J. Gabbay, Nominal rewriting, Information and Computation 205 (2007), pp. 917 – 965.
URL https://doi.org/10.1016/j.ic.2006.12.002
Gabbay, M. J., Nominal Algebra and the HSP Theorem, Journal of Logic and Computation 19 (2008),
pp. 341–367.
URL https://doi.org/10.1093/logcom/exn055
Gabbay, M. J. and A. Mathijssen, The lambda-calculus is nominal algebraic, in: C. Benzmu¨ller, C. Brown,
J. Siekmann and R. Statman, editors, Reasoning in simple type theory: Festschrift in Honour of Peter
B. Andrews on his 70th Birthday, Studies in Logic and the Foundations of Mathematics 17, College Publications, 2008 pp. 271–302.
URL http://www.gabbay.org.uk/papers/lamcna.pdf
Gabbay, M. J. and A. Mathijssen, Nominal (Universal) algebra: equational logic with names and binding
19 (2009), pp. 1455–1508.
URL https://doi.org/10.1093/logcom/exp033

	Lugiez, D., Higher order disunification: Some decidable cases, in: First International Conference on Constraints in Computational Logics, CCL, Lecture Notes in Computer Science 845 (1994), pp. 121–135.
URL https://doi.org/10.1007/BFb0016848

Pitts, A. M., “Nominal Sets: Names and Symmetry in Computer Science,” Cambridge University Press, New York, NY, USA, 2013.
Ravishankar, V., K. A. Gero and P. Narendran, Asymmetric unification and disunification, CoRR
abs/1706.05066 (2017).
URL http://arxiv.org/abs/1706.05066

	Urban, C., A. M. Pitts and M. Gabbay, Nominal unification, Theor. Comput. Sci. 323 (2004), pp. 473– 497.
URL https://doi.org/10.1016/j.tcs.2004.06.016

A	More on Nominal Semantics
As in [13], let Ð be a set of term-formers disjoint from Σ, they are called ‘extra term-formers’. Then the set of ground nominal terms is generated by the grammar:
g ::= a | [a] g | f (g1,..., gn) | d(a1,..., am)
Here f : n range over elements of Σ and d : m ranges over elements of Ð (More details can be found in the Appendix).
Definition A.1 If g ∈ F(Σ, Ð) write [g]T for the set of gj ∈ F(Σ, Ð) such that there exists a derivation ▶T g = gj. Write F(T, Ð) for the nominal set such that:

F(T, Ð)S = {[g]T | g ∈ F(Σ, Ð)} is the underlying set.
π · [g]T = [π · g]T .
Definition A.2 Let T = (Σ, Ax) and suppose Ð is a set of term-formers disjoint from Σ. The initial ground algebra of T over Ð, denoted by F(T, Ð), is the Σ-algebra with:
Underlying nominal set F(T, Ð)S, as defined in Definition A.1.
Interpretation of atoms defined as aA = [a]T
Interpretation of abstraction abs(a, x)= [[a] g]T for some g ∈ x.
f A(x1,..., xn) = [f (g1,..., gn)]T for some g1 ∈ x1,..., gn ∈ xn, for each term- former f : n ∈ Σ.
For Σ-algebras A and B, a Σ-algebra homomorphism from A to B is an equivariant function AS → BS that preserves the interpretation for atoms, abstraction, and function symbols. If φ : A→B is a surjective homomorphism onto B then we say B is a homomorphic image of A.
Theorem A.3 For any nominal equational theory T , F(T, Ð) is a Σ-algebra and
F(T, Ð) is a model of T .
Theorems A.4 and A.5 are technical and used in the proof of the HSP theorem. The first states that every element of a variety V is a homomorphic image of some sufficiently large initial ground algebra. The second states that given a collection V of Σ-algebras, the theory T generated by V induces an injective Σ- algebra homomorphism θ : F(T, Ð) → ΠAi∈V Ai, into the product algebra ΠAi∈V Ai.

Theorem A.4 Fix a signature Σ, a nominal theory T, and V, the variety of T. If A∈V then the exists some (sufficiently large) set of term-formers Ð such that there exists a Σ-algebra homomorphism θ from F(T, Ð) to A such that θ is surjective.
Theorem A.5 Suppose V is a collection of Σ-algebras. Let T be the theory generated by V. Suppose Ð is any set of term-formers, so (Σ ∩ Ð) = ∅. Then there exists some indexing set I and algebras Ai ∈V for i ∈ I such that there exists a Σ-algebra homomorphism θ from F(T, Ð) to Πi∈IAi such that θ is injective.
