	Electronic Notes in Theoretical Computer Science 203 (2008) 243–262	
www.elsevier.com/locate/entcs
Coequational Logic for Finitary Functors
Daniel Schwencke 1,2
Department of Theoretical Computer Science Institute of Technology, Braunschweig, Germany

Abstract
Coequations, which are subsets of a cofree coalgebra, can be viewed as properties of systems. In case of a polynomial functor, a logic of coequations was formulated by J. Ad´amek. However, the logic is more complicated for other functors than polynomial ones, and simple deduction rules can no longer be formulated. A simpler coequational logic for finitely branching labelled transition systems was later presented by the author. The current paper carries that research further: it yields a simple coequational logic for finitary functors that preserve preimages. Furthermore we prove a statement for semantical consequences of sets of coequations in the case of accessible functors.
Keywords: cofree coalgebra, coequation, logic, finitary functor, preimage

Introduction
Several authors studied logics that formalise properties of systems described as coalgebras over a set functor.  On the one hand, modal logics were investigated
e. g. by Lawrence Moss [8] or Dirk Pattinson [9]. On the other hand, dualizing equational presentations of algebras, Jan Rutten [10] introduced coequations as subsets of cofree coalgebras. These coequations can also be used to establish logics of system properties, see e. g. the work of Jesse Hughes [7]. Our paper deals with a coequational logical topic different to the one of Hughes. In [1] Jiri Ada´mek formulated a logic of coequations and proved it to be sound and complete. Since the elements of a cofree coalgebra for a fixed functor can be viewed as “behaviour patterns” of coalgebras for this functor, coequations describe certain properties of such coalgebras. Thus with a logic of coequations we are able to obtain properties of a coalgebra automatically from other properties of this coalgebra.
Coequational logic provides a deduction system to derive coequations from a given set of assumed coequations. It is particularly simple in case of polynomial

1 The grant of DFG is gratefully acknowledged.
2 Email: schwencke@iti.cs.tu-bs.de

1571-0661 © 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.05.028

functors: the cofree coalgebra consists of coloured trees, and the deduction system has only two rules, the subtree rule and the recolouring rule. The logic for accessible functors is more complicated.
In this paper we focus on finitary functors, a subclass of accessible functors. Our prime example is the finite power-set functor Pf (A × −): the corresponding systems are the finitely branching labelled transition systems (LTS), and our paper is a generalisation of the logic for LTS presented in the thesis [11]. That logic for LTS is based on the presentation of the cofree Pf (A × −)-coalgebra as the set of all “strongly extensional” trees, which were indroduced by James Worrell in [12]. Coming back to an abstract finitary functor H, we show how to obtain a presentation of its cofree coalgebra as a set of trees. Using that presentation, under the relatively weak assumption that H preserves preimages we formulate a coequational logic which is nearly as simple as the one for polynomial functors and prove it to be sound and complete. This way we provide a simple coequational logic for a wide range of relevant non-polynomial functors.
A little section at the end shows a result about semantical consequences of arbitrary subsets of cofree coalgebras of accessible functors, whereas coequations are special subsets of cofree coalgebras.

Coequational logic
Preliminaries
Since we are working with coalgebras (sometimes also referred to as “systems”) as structured sets all functors considered will be endofunctors of Set in the category Set of sets and functions. We already mentioned some special cases in the previous section:
A polynomial functor for a given signature Σ is a functor of the shape
Σ(−)nσ ,
σ∈Σ
where nσ is the arity of the operation σ ∈ Σ. The signature is called k-ary if
nσ < k for all σ ∈ Σ, where k is some infinite regular cardinal.
A ﬁnitary functor H is a functor preserving filtered colimits, or equivalently, it is a quotient of some polynomial functor HΣ for a finitary signature Σ. This means there exists a natural transformation ϵ : HΣ → H having surjective com- ponents, where the arities nσ of all operations σ ∈ Σ are finite. For equivalent characterisations of finitary functors see [5].
An accessible functor is a functor preserving k-filtered colimits for some infinite regular cardinal k, or equivalently, it is quotient of some polynomial functor HΣ for a k-ary signature Σ. Each finitary functor is accessible (k = ω). For equivalent characterisations of accessible functors see [4].

For a polynomial functor HΣ we shall denote the terminal coalgebra and the cofree coalgebra on some fixed countable infinite set C of colours by TΣ and QΣ respectively. Their structure maps are denoted by αTΣ : TΣ → HΣTΣ and αQΣ : QΣ → HΣQΣ, the couniversal colouring arrow of QΣ by γΣ : QΣ → C. Analogously,
for a finitary functor H we shall write T and Q, αT , αQ and γ.
All trees considered in the paper are rooted, ordered trees that arise from a signature Σ, i. e. every node is labelled with an operation symbol σ ∈ Σ and has exactly nσ children, where nσ is the arity of σ. These trees are called Σ-trees. We always consider trees up to isomorphism, e. g. if we the take the set of all subtrees of a tree it is meant to contain no duplicates rooted at different positions.
For a polynomial functor HΣ it is well-known that TΣ consists of all Σ-trees and that αTΣ sends a Σ-tree to its root label (the operation symbol) and the list of its subtrees, see e. g. [4]. Similar, the cofree HΣ-coalgebra QΣ consists of all coloured Σ-trees; that is, every node carries two labels: an operation symbol from Σ and a colour from C. The map αQΣ sends a coloured Σ-tree to its root operation symbol and the list of its coloured subtrees; γΣ maps every coloured Σ-tree to its root colour.
For a finitary signature Σ (i. e. the Σ-trees from TΣ are finitely branching) it holds that if Σ is linearly ordered, so is TΣ in the following sense: we compare two trees from TΣ by breadth-first search. Starting at the roots (depth n = 0), as long as we find only equal operation symbols at the nodes of depth n, it is always assured that we can compare the nodes of depth n + 1 from left to right. As soon as we find two nodes with different operation symbols, the order of the trees is given by the order of these operations. It is easy to verify that this way we obtain a linear order of all trees from TΣ: the transitivity is easy to see and the completeness follows from the facts that two different trees (even those of infinite depth) have to differ within finite depth and that these trees are finitely branching, thus every finite depth can be reached by breadth-first search. Therefore, if Σ × C is linearly ordered, so is QΣ in the same sense.

Coequations
Definition 2.1 Given a cofree coalgebra Q, a coequation is a coatomic subset Q \
{q} for some q ∈ Q. Since it is completely described by the element q, we shall denote it by ☒q (read: avoid q).
These coatomic sets are called coequations because they are the coalgebraic dual to equations in universal algebra: while the latter determine quotients of free algebras, the former determine quotients of cofree coalgebras.
Definition 2.2 Let (Q, αQ, γ) be the cofree H-coalgebra on C. An H-coalgebra (S, αS) is said to satisfy a coequation ☒q if for all colourings f : S → C and for all states s ∈ S we have f∗(s) /= q for the unique homomorphism f∗ : S → Q with f = γ ◦ f∗. More generally, (S, αS) is said to satisfy a subset U ⊆ Q of the cofree coalgebra if for all colourings f : S → C we have f∗[S] ⊆ U .

Remark 2.3 The coequations introduced by Jan Rutten are defined more generally as subsets U ⊆ Q. As we see from the above Definition 2.2, for every coalgebra to satisfy a subset U ⊆ Q is equivalent to satisfying all coequations ☒q where q ∈ Q\U ,
i. e. U can be expressed via coequations by U = q∈Q\U ☒q. This means that when investigating subsets of cofree coalgebras, we can restrict ourselves to coequations, a fact that was first observed by Peter Gumm [6].
Since the elements of the cofree H-coalgebra can be viewed as “behaviour pat- terns” of H-coalgebras and the pattern q is forbidden by the corresponding coequa- tion ☒q, coequations can be regarded as certain “system properties”. Coequations stand for exactly these system properties preserved by coproducts, homomorphic images and subsystems. This follows from the Co-Birkhoff Theorem proven by Jan Rutten [10].
Definition 2.4 A coequation ☒q is said to be a semantical consequence of a co- equation ☒q' if every H-coalgebra that satisfies ☒q' also satisfies ☒q. We shall denote this by ☒q' |= ☒q. More generally, a subset U ⊆ Q is said to be a semantical consequence of a subset U' ⊆ Q if every H-coalgebra that satisfies U' also satisfies U , notation U' |= U .

A logic of coequations
When presenting a logic of coequations, we first define what proofs in that logic will be and then state some soundness and completeness results.
Definition 2.5 Let P be a set of coequations (the premise). A proof in a coequa- tional logic of a coequation ☒q is a list of coequations ☒ci, i ≤ l of lenght l + 1, where l is some ordinal, where ☒cl = ☒q and where for every i ≤ l it holds that
☒ci ∈ P or F |= ☒ci, where F ⊆ {☒cj|j < i}.
Let us consider systems of polynomial functors HΣ. We call two nodes v, w of a tree t ∈ QΣ equivalent, if the coloured subtrees tv and tw of t rooted at v and w, respectively, are isomorphic.
Definition 2.6 Given a cofree coalgebra QΣ of a polynomial functor, a recolouring of a tree t ∈ QΣ is a tree r ∈ QΣ for which there exists a homomorphism h : QΣ → QΣ such that h(t) = r.

Remark 2.7 As shown in [1], this is equivalent to the following: t and r have the same shape and for any two equivalent nodes in t the corresponding nodes in r are equivalent again.
Example 2.8 Let HΣ = (−)2 + 1, i. e. Σ contains a binary operation σ and a constant c. Then QΣ consists of all coloured binary trees. Consider the following two trees from QΣ:


	
The right-hand tree is a recolouring of the left-hand one: both trees have the same shape and the black leaves of the left-hand one (which are the only equivalent nodes in this tree) are equivalent in the right-hand one. Note that the converse is not true since in the right-hand tree all leaves are equivalent nodes but this is not so in the left-hand one.
Before we restate the main result for coequational logic of polynomial functors, we introduce a relation on QΣ as follows: for two trees t, r ∈ QΣ we write r ± t, if r is a recolouring of a subtree of t.
Theorem 2.9 ([1]) For a polynomial functor HΣ a coequation ☒t is semantical consequence of the coequations ☒ri, i ∈ I, if and only if there is some ri that is a recolouring of some subtree of t, shortly
  ☒ri |= ☒t	⇐⇒	∃i ∈ I : ri ± t.
i∈I
Corollary 2.10 ([1]) For systems of a polynomial functor deduction of coequations with the following rules is sound and complete:
child rule


recolouring rule
☒tv
☒t
☒r

☒t
where v is a child of the root of t

where r is a recolouring of t

Now we can go one step further and consider systems as coalgebras of an ac- cessible functor H. These are quotients of polynomial functors HΣ, i. e. there is a natural transformation ϵ : HΣ → H with surjective components. From this one can derive that the cofree H-coalgebra Q on C is quotient of the cofree HΣ-coalgebra QΣ on C, see [1]. Thus Q consists of equivalence classes of coloured Σ-trees, which we call ϵ-classes. Given a cofree H-coalgebra Q, we denote by [t] ∈ Q the ϵ-class of a Σ-tree t ∈ QΣ from the corresponding cofree HΣ-coalgebra QΣ.
Theorem 2.11 ([1]) For an accessible functor H a coequation ☒q is a semantical consequence of the coequations ☒qi, i ∈ I, if and only if for every tree t ∈ QΣ with [t] = q there is some tree r ∈ QΣ with [r] = qi for some i ∈ I, so that r is recolouring of some subtree of t, shortly
  ☒qi |= ☒q	⇐⇒	∀t.[t] = q ∃i ∈ I ∃r.[r] = qi : r ± t.
i∈I

This logic clearly is more complicated than the one from Theorem 2.9 because one has to consider all trees from an ϵ-class instead of just one tree. As a consequence of this, one can no longer give simple deduction rules for this logic. Nevertheless, for the (non-polynomial) functor Pf (A× −) of finitely branching labelled transition systems in [11] we found a logic similar to and nearly as simple as the one for polynomial functors. We do not state it at this time because it is a special case of the results of section 4 of this paper.

Cofree coalgebras of finitary functors
Throughout this section H denotes a finitary functor with a fixed presentation as a quotient ϵ : HΣ → H, see section 2.1.
Example 3.1 As an example of such a functor consider the LTS-functor Pf (A×−). It has a presentation as a quotient of the polynomial functor
Σ(A × −)n = 1+ (A × −)+ (A × −)2 + ... 
n∈N

whose signature contains |An| operations with arity n for each n ∈ N. The functions
ϵX : Σn∈N(A × X)n → Pf (A × X) that map, for a given set X, every list of pairs
(a, x) ∈ A×X to the set of these pairs are easily proven to form a surjective natural transformation ϵ.
Definition 3.2 Let X be a set (of variables). For two operations σ (n-ary) and τ
(k-ary) from Σ an expression of the form

σ(x1,..., xn) = τ (y1,..., yk)	where xi and yj in X	(3.1)

is called an ϵ-equation in case ϵX : HΣX → HX merges the two sides, i. e. they are equal under ϵX . In that expression both sides are elements of HΣX, so-called flat terms in variables from X.
As already mentioned, TΣ is the set of all Σ-trees. One can apply the ϵ-equation (3.1) to such a tree at a node v from left to right, whenever v is labelled by σ and for two variables that are equal (xi = xi' ) the corresponding child nodes of v are equivalent: the tree is rearranged by relabelling v by τ and choosing arbitrary Σ-trees for variables yj that are not found on the left-hand side. If a Σ-tree t' can be obtained from a Σ-tree t by an application of finitely many ϵ-equations, we shall denote this by t ∼ t'.
Example 3.3 Let Σ = {c, σ, τ} contain a constant c, a binary operation σ and a ternary operation τ . We consider the ϵ-equation σ(x, y) = τ (y, x, x) and give an example of its application to Σ-trees.




=⇒	=⇒




Each arrow =⇒ indicates one application of the ϵ-equation: first it is applied from left to right to the center child of the left-hand tree’s root, second it is applied from right to left to the root of the center tree. Looking at that second application note that not only the root label has changed from τ to σ, but also how the child trees of the root are rearranged according to the variables of the ϵ-equation. Also note that the first application is necessary to do the second one—an application to the root is not allowed in the left-hand tree.
Definition 3.4 Given a Σ-tree t, we denote by ∂kt (read: the cutting of t at level k) the tree we obtain by cutting t at level k ∈ N and then labelling every leaf of depth k with the constant symbol ⊥.
Definition 3.5 ([3]) Given two Σ-trees t, t', we say that t' can be obtained from t
by (possibly infinitely many) applications of ϵ-equations provided that
∂kt ∼ ∂kt' for every k ∈ N.
Theorem 3.6 ([3]) The terminal H-coalgebra of a ﬁnitary functor is the quotient of the terminal HΣ-coalgebra TΣ modulo the congruence of applications of ϵ-equations.
Example 3.7 Coming back to the above presentation of the LTS-functor Pf (A×−) from Example 3.1, the terminal coalgebra of the polynomial functor Σn∈N(A×−)n
is the set of all finitely branching trees whose edges are labelled with elements from
A. The ϵ-equations that determine the terminal Pf (A × −)-coalgebra as a quotient of that set can be derived from the surjective natural transformation ϵ described above (see [3]): these are all ϵ-equations
σ(x1,..., xn) = τ (y1,..., ym)
for which we have {(a1, x1),..., (an, xn)} =  {(b1, y1),..., (bm, ym)}, where a1,..., an and b1,..., bm are the lists of edge labels from A associated with the operations σ and τ respectively. As ϵ does by mapping two lists to the same set, they equate two list of pairs from A ×− whenever the sets of these pairs are equal. Finally, the terminal Pf (A × −)-coalgebra consists of equivalence classes of finitely branching edge-labelled trees that can be obtained from each other by applications of these ϵ-equations. Since the ϵ-equations allow arbitrary reordering, duplication of child trees and elimination of such duplicates (always together with the associated edge labels), we get a picture of how these equivalence classes look like.
Analogously to Theorem 3.6, the cofree H-coalgebra Q can be described in

terms of application of equations. We denote the corresponding quotient map by
ц∗ : QΣ → Q. It is the unique H-homomorphism satisfying цΣ = ц ◦ ц∗ , where QΣ
Σ	Σ
is viewed as an H-coalgebra using ϵQΣ : HΣQΣ → HQΣ, see [1].
We can view QΣ and Q as terminal coalgebras of HΣ ×C and H ×C respectively and from ϵ we get a surjective natural transformation ϵ × id : HΣ × C → H × C. This way we see that Q is a congruence of QΣ modulo the application of (ϵ × id)-
equations, which we will call ϵ-equations, too. The terms forming these ϵ-equations consist of a colour from C and an operation from Σ on variables from QΣ. Since the congruence fulfills цΣ = ц ◦ ц∗ , the colours must be the same on both sides of any ϵ-equation. The ϵ-equations describing Q as a congruence of QΣ are the same as the ones describing T as a the congruence of TΣ, except that the variables now stand for coloured trees from QΣ and the ϵ-equations can be applied whatever the
colour of the node is, but they have to preserve it.
Corollary 3.8 Two coloured trees from QΣ belong to the same ϵ-class from Q if and only if they can be obtained from each other by an application of ϵ-equations.
Definition 3.9 An ϵ-equation is called regular provided the sets of variables used on both sides are equal. A presentation of a functor via a polynomial functor together with ϵ-equations is called regular if all ϵ-equations are regular.
Remark 3.10 As proven by Ada´mek, Lu¨cke and Milius ([2]), for finitary functors to have a regular presentation is equivalent to preserving preimages.
Again coming back to LTS we see that in the above presentation all ϵ-equations are regular: this follows from the equality of the sets of pairs as seen in Example
3.7. Thus the functor Pf (A × −) has a regular presentation. And indeed it does preserve preimages.

A simpler logic
In the present section we establish a simplification of the coequational logic of Theorem 2.11. This section is a generalisation of our approach for finitely branching labelled transition systems (LTS) in [11]. More concretely, we will show that all finitary functors that are represented by regular ϵ-equations allow a simple logic similar to the one we found for the LTS-functor Pf (A × −). In this section we assume H to be a finitary functor that preserves preimages and to be a quotient of the polynomial functor HΣ via regular ϵ-equations.

ϵ-classes and subtrees
Let us consider trees t, t' ∈ QΣ where t' arises from t by application of one regular ϵ-equation at the node v (the corresponding node in t' is called v'). It is easy to prove that the set of ϵ-classes of subtrees of t' is the same as the set of ϵ-classes of subtrees of t: one can do that by case distinction between subtrees that are rooted
on the path from the root of t to v / on the path from the root of t' to v'

somewhere below v / somewhere below v', where “below” means that v or v'
are inner nodes of the path from the root to the node
somewhere else.
The equality of the sets of ϵ-classes of the subtrees is proven by Corollary 3.8 for (i), by regularity of the ϵ-equation for (ii) and for (iii) there is nothing to prove. By transitivity of equality of sets, the statement proven this way is still valid if t' arises from t by application of finitely many regular ϵ-equations.
We do not know how to use this result in order to prove that the statement is still valid in the case where infinitely many applications are made (which nevertheless is true, as we will see): an induction proof on the depth of the trees seems to be impossible because an infinite sequence of ϵ-equations might contain infinitely many applications of ϵ-equations at greater depths which are necessary for a following application in lesser depth to be executed. The problem can be worked around by restricting t to have special properties (to be a “first representative tree”, which is explained in section 4.2), and under this assumption an induction proof can be given. Since this restriction is unnecessary, we give a different proof for the infinite case.
Proposition 4.1 Given a regular presentation, for trees t, t' ∈ QΣ of the same ϵ- class the ϵ-classes of their subtrees are also the same, shortly (where v and w are nodes of t and t' respectively)
[t] = [t']	=⇒	∀v ∃w : [tv] = [t' ].
Proof. Since ц∗ : QΣ → Q is an H-homomorphism, we have the following com-
mutative diagram on the left-hand side which can be completed to the one on the right-hand side since цΣ = ц ◦ ц∗ :


∗
QΣ	Σ	 Q 
αQΣ
J 
∗
QΣ	Σ	 Q 
⟨αQΣ ,γΣ⟩
J 

HΣQΣ
єQΣ
J 
HQΣ
αQ


J 
∗  H Q
HΣQΣ × C
єQΣ ×idC
J 
HQΣ × C ∗
⟨αQ,γ⟩

J 
 H Q × C

HγΣ	HγΣ ×idC
We know by Lambek’s Lemma that ⟨αQΣ , цΣ⟩ and ⟨αQ, ц⟩ are isomorphisms since these are the structure maps of the terminal coalgebras of the functors HΣ × C and H×C respectively. Thus ц∗ merges two trees from QΣ if and only if the composition
of the two surjective maps ϵQΣ ×idC and Hц ×idC merges their presentations from
∗
HΣQΣ × C. Recall that a tree r ∈ QΣ is presented in HΣQΣ × C by ⟨αQΣ , цΣ⟩ in terms of its root operation symbol σ and the list of its child trees, which form an element σ(rv1 ,..., rvn ), and its root colour.
Let us consider the first surjective map ϵQΣ × idC. From Definition 3.2 we know that ϵQΣ × idC merges two such tree presentations if and only if there is

a corresponding ϵ-equation, i. e. one tree can be obtained from the other one via an application of this ϵ-equation at the root. Since we assumed the equational presentation of H to be regular, ϵQΣ only merges presentations for which the sets of all child trees are the same. This particularly means that for a pair of trees from ker((ϵQΣ × idC) ◦ ⟨αQΣ , цΣ⟩) the ϵ-classes of the child trees are the same.
Now let us consider the second surjective map Hц∗ × idC. Since ⟨αQ , цΣ⟩ is an
isomorphism and ϵQΣ × idC is surjective, its domain HQΣ × C is isomorphic to the quotient set of QΣ modulo the equivalence ker((ϵQΣ × idC) ◦ ⟨αQΣ , цΣ⟩). And since Hц∗ × idC again is surjective, HQ is isomorphic to the quotient set of HQΣ × C
modulo the equivalence ker(Hц∗ × idC). Taken together HQ (or equivalently, Q) is isomorphic to the quotient set of QΣ modulo some equivalence R.
If we can prove that R only contains pairs of trees whose child trees have the same ϵ-classes, we easily get our proposition: since [t] = [t'], we have ц∗ (t) = ц∗ (t'). We conclude from the above commutative diagram that the composition
of (ϵQΣ × idC) ◦ ⟨αQΣ , цΣ⟩ and ⟨αQ, ц⟩	◦ (Hц  × idC) merges t and t . This is
−1	∗	'
equivalent for t and t' to form a pair in R, which implies that the child trees of t and t' have the same ϵ-classes. By structural induction on the trees this is also true for arbitrary subtrees of t and t'.
In order to prove the desired property of R, we claim that
R = (ker((ϵQ  × idC) ◦ ⟨αQ , цΣ⟩) ∪ M )∗,
where

M := {(r, s)|αQΣ (r) = σ(rv1 ,..., rvn ), αQΣ (s) = σ(sv1 ,..., svn ),
[rvi ] = [svi ] for i = 1 ...n and цΣ(r) = цΣ(s)}.
The star operation is the reflexive transitive closure and the set M contains all pairs (r, s) of trees where the root labels (operation symbol and colour) of r and s are equal and all their child trees at the same positions have the same ϵ-classes. We
prove our claim by showing the quotient set of QΣ modulo P := (ker((ϵQΣ × idC) ◦
⟨αQΣ , цΣ⟩) ∪ M ) to be isomorphic to the codomain Q of ц .
∗	∗
We first prove that all pairs of trees merged by ц∗ are contained in P : to be
merged by ц∗ means that the trees can be obtained from each other by an appli-
cation of ϵ-equations. But each sequence of applications of ϵ-equations is covered by the construction of P : after applications of ϵ-equations at the root the pair is contained in ker((ϵQΣ × idC) ◦ ⟨αQΣ , цΣ⟩) ⊆ P .  After (possibly infinitely many)
applications of ϵ-equations at depths ≥ 1 in a tree the corresponding pair of trees
lies in P because it is contained in M . And an arbitrary combination of both is possible due to the reflexive and transitive closure, thus the pair of the original tree and the resulting tree will always lie in P .
Conversely, assume a pair of trees to lie in P : this means that the pair arose by transitivity from some pairs from ker((ϵQΣ × idC) ◦ ⟨αQΣ , цΣ⟩) and from M . But for these pairs we know that ц∗ merges the trees, and by transitivity of “having the
same ϵ-class” we conclude that ц∗ always merges the trees from a pair in P .

Finally it is an easy observation that R only contains pairs of trees whose child trees have the same ϵ-classes: we already stated that for ker((ϵQΣ ×idC)◦⟨αQΣ , цΣ⟩) and by definition it is also true for M and consequently for the union of both. Finally
the reflexive and transitive closure only adds pairs with the desired property because “having the same set of child tree ϵ-classes” is transitive.	 

ϵ-classes and recolourings
Now we consider recolourings of trees. Unfortunately it is not true that for two trees of the same ϵ-class the sets of all their recolourings are equal. To see this, we give the following
Example 4.2 Let H be the finitary functor that is given as a quotient of HΣ = (−)2 + 1 modulo the ϵ-equation σ(x, y) = σ(y, x) (Σ = {σ, c}, where σ is binary and c nullary). Since this equation is regular, H preserves preimages. Let C contain the colours white and black. We consider the following coloured trees t and t' from QΣ:




t :=	t' :=




They obviously have the same ϵ-class [t] = [t']. We obtain a recolouring r of t by colouring the left-hand child of the root of t black. But now it is clear that there is no recolouring of t' that lies in the ϵ-class of r: in every recolouring of t' both children of the root must have the same colour because they are equivalent nodes in t'. But in every tree of the ϵ-class of r they have different colours, namely black and white, because ϵ-equations preserve the colours of the nodes they are applied to and the colourings of all subtrees of that node.
Nevertheless we can state a similar proposition for recolourings as we had for subtrees (Proposition 4.1) if we restrict t to be a “first representative tree”, as we shall see.
Definition 4.3 Given a finitary functor H as a quotient of the polynomial functor HΣ and a linear order on Σ ×C, we have a linear order (QΣ, ≤) as mentioned in sec- tion 2.1. Then for every ϵ-class q ∈ Q we denote by tq ∈ QΣ the ﬁrst representative tree of q. It is defined by [tq] = q and [t] = q ⇒ tq ≤ t for all t ∈ QΣ.
Remark 4.4 Given a linear order on Σ × C, the subset R ⊆ QΣ of first repre- sentative trees contains exactly one tree from each ϵ-class, which is clear from the definition. Additionally, R is closed under subtrees: we easily see that indeed every subtree of such a first representative tree is a first representative tree of an ϵ-class again. If there were some ϵ-equations that could be applied to a subtree such that

the result was a previous tree in the order, these applications of ϵ-equations had shifted the whole tree to a previous position in the order.
For the rest of the paper when working with first representative trees we assume Σ × C to be linearly ordered.
Example 4.5 In the case of LTS we have the presentation from Example 3.1 via the polynomial functor Σn∈N(A × −)n. We can find a linear order where (σn, k) <
(σm, k) for every colour k and every two operations with arities n < m. The first
representative trees we obtain are the strongly extensional trees as studied by James Worrell [12].
Now let us come back to the above Example 4.2. The reason that there is no recolouring of t' in the ϵ-class of r is that the recolouring makes two subtrees of t of the same ϵ-class become subtrees of r of different ϵ-classes. We can avoid this by choosing a linear order on Σ × C and restricting t to be the first representative tree tq of its ϵ-class q. In this case it follows from being the first representative tree (cf. Remark 4.4) that for any two subtrees of tq of the same ϵ-class their root nodes are equivalent. Since recolouring a tree preserves equivalent nodes, recolourings of first representative trees have the special property that any two subtrees of the same ϵ-class in the original tree become subtrees of the same ϵ-class in the recolouring again. But note that recolourings of first representative trees in general are no longer first representative trees.
Proposition 4.6 Given some q ∈ Q, for every tree t' ∈ QΣ such that [t'] = q and every recolouring r of tq there is a recolouring r' of t' such that [r] = [r'].
Proof. Given q and a recolouring r of tq, we will prove that
a homomorphism ƒ∗ : QΣ → QΣ can be defined such that r = ƒ∗(tq) and
[ƒ∗(tq)] = [ƒ∗(t')] for all t' with [t'] = q.
Definition of ƒ∗. The given recolouring r of tq yields a colour from C for every subtree of tq, namely the colour r assigns to its root. Since tq is the first representative tree, all of its subtrees are first representative trees again. Thus there is at most one subtree of tq from a given ϵ-class, namely the first representative tree of that ϵ-class. Furthermore, for possibly existing isomorphic subtrees the assignment always yields the same colour, see Remark 2.7. Then the colours of the subtrees of tq given by r can be assigned to the ϵ-classes of these subtrees of tq in a unique way. More formally, let Stq ⊆ Q be the set of all ϵ-classes of subtrees of tq. Then r uniquely determines a C-colouring ƒ '' : Stq → C of Stq .
Choosing arbitrary colours for the remaining ϵ-classes, we can extend ƒ '' to a
C-colouring ƒ' : Q → C of Q. Using the map ц∗ : QΣ → Q that assigns to every
tree its ϵ-class, we extend ƒ' to a C-colouring ƒ : QΣ → C by defining ƒ := ƒ' ◦ ц∗ . We obtain the homomorphism ƒ∗ : QΣ → QΣ as the unique colour-compatible homomorphism (цΣ ◦ ƒ∗ = ƒ ) into the cofree HΣ-coalgebra on C. We obviously have ƒ∗(tq) = r because for every subtree s of tq we have s ∈ ц∗ −1(Stq ) and the root of ƒ∗(s) is coloured with the colour ƒ '' assigns to the ϵ-class of s.

Proof of [ƒ∗(tq)] = [ƒ∗(t')]. We consider a tree t' with [t'] = q = [tq]. Recall from Theorem 3.6 that this is equivalent to ∂ktq ∼ ∂kt' for all k ∈ N. We want to show by induction on the depth k of the cutting that ∂k(ƒ∗(tq)) ∼ ∂k(ƒ∗(t')). Unfortunately we do not know how to prove that directly—what we actually do is to prove by induction on k that for all k ∈ N there is a tree tk for which the following five statements hold.
∂k(tk) = ∂k(t')
tk is obtained from tq by finitely many applications of ϵ-equations at depths
< k 
all subtrees of tk rooted at depths ≤ k have the same ϵ-classes as the corre- sponding subtrees of t'
ƒ∗(tk) is obtained from ƒ∗(tq) by application of the same ϵ-equations as the ones used in (ii)
∂k(ƒ∗(tk)) = ∂k(ƒ∗(t'))
Then for every k we obtain ∂k(ƒ∗(tq)) ∼ ∂k(ƒ∗(t')) from (iv) and (v) as follows:
implies ƒ∗(tq) ∼ ƒ∗(tk).  Since the ϵ-equations were only applied at depths
< k and cutting at depth k preserves equivalent subtrees of depths < k, the same ϵ- equations witness ∂k(ƒ∗(tq)) ∼ ∂k(ƒ∗(tk)). Together with (v) we obtain ∂k(ƒ∗(tq)) ∼
∂k(ƒ∗(t')). Thus [ƒ∗(t')] = [ƒ∗(tq)], and ƒ∗(t') is the required recolouring r' of t'. Furthermore the induction proof is applicable to every tree t' such that [t'] = [tq], and we finally obtain the proposition.
Now we prove by induction on k that for all k ∈ N there is a tree tk for which the statements (i) to (v) hold.
Base clause. For k = 0 we define t0 := tq. Then (ii) is directly clear from the
definition (zero applications of ϵ-equations). We have (i) ∂0(t0) = ∂0(t'), because these are the root nodes of the trees tq and t' respectively, which are labelled by the same constant ⊥ and moreover have the same colour: by assumption they can be obtained from each other by finitely many applications of (colour preserving) ϵ- equations. For (iii), there is nothing to prove. (iv) again is clear from the definition of t0 (again zero applications of ϵ-equations). We prove (v) ∂0(ƒ∗(t0)) = ∂0(ƒ∗(t')). Since ∂0 takes the root nodes of the trees and labels them with the constant ⊥, we only have to show that the root colours of ƒ∗(t0) and ƒ∗(t') are equal. But because of [t0] = [tq] = [t'], according to its definition ƒ∗ colours both roots with the same colour.
Induction step from k to k + 1. We assume that there is a tree tk such that the statements (i)k to (v)k hold. We then prove that these statements also hold for k + 1 instead of k, referred to as (i)k+1 to (v)k+1.
We claim that we can obtain a tree tk+1 which fulfills (i)k+1 and (iii)k+1 by application of (finitely many) ϵ-equations to tk at depth k. Then from (ii)k we directly get (ii)k+1. In fact one can obtain such a tree tk+1 that way:
From (i)k and (iii)k we know that we can obtain t' by applications of (possibly infinitely many) ϵ-equations to tk at depths ≥ k. Additionally we know that, in

order to do so, we can first apply the (finitely many) ϵ-equations at depth k (without applying equations in greater depths first) because any two nodes of tk at depth k+1 that could be made equivalent (by application of ϵ-equations in greater depths), already are equivalent—this is so because tq as a first representative tree has only first representative trees as subtrees and the application of regular ϵ-equations at depths < k does not change subtrees rooted at depths ≥ k. After the application of all the ϵ-equations at depth k we can be sure that the subtrees of tk+1 rooted at depth k + 1 have the same ϵ-classes as the corresponding subtrees of t': ϵ-equations that were possibly applied at depths ≥ k + 1 before an ϵ-equation was applied at depth k in the original chain of ϵ-equations did not change the ϵ-classes of subtrees rooted at depth k + 1, so looking only at the ϵ-classes, the ϵ-equation applied at depth k rearranges subtrees at depth k + 1 in exactly the same way no matter if applied first or later. This proves (iii)k+1. This also ensures that the nodes of tk+1 at depth k + 1 have the same colours as the corresponding nodes of t', because trees of the same ϵ-class always have the same root colour. And since the resulting operation symbols at depth k are independent of when the ϵ-equations at depth k are applied, we have (i)k+1.
Next we prove (iv)k+1. It is sufficient to prove the commutativity of the following diagram, then together with (iv)k we obtain (iv)k+1.
tk	є-equations	 tk +1
f∗	f∗
J	J 
ƒ∗(tk)	 ƒ ∗ (tk+1)
To do so, we first have to assert that the ϵ-equations used to obtain tk+1 from tk are still applicable to the recolouring ƒ∗(tk). This is indeed the case because a recolouring does not change the tree shape and equivalent nodes of tk become equivalent nodes in the recoloured tree again. Second, both paths in the diagram result in trees of the same shape: this is true because the ϵ-equations reshape tk and ƒ∗(tk) the same way and the recolouring ƒ∗ has no impact on the shape. Finally, both paths in the diagram lead to the same colouring (and thus the same tree): let us look at the nodes of depth k. The application of ϵ-equations to tk at depth k preserves the ϵ-classes of the trees that are rooted at this depth and by its definition ƒ∗ consequently colours their roots the same way. Since the application of the same ϵ-equations to ƒ∗(tk) at depth k preserves colours at this depth, at depth k we get the same colours. The same argument can be used for nodes at depths < k. The remaining nodes are these of depths > k, i. e. these of the subtrees rooted at depth k + 1. To them it does not matter whether they are rearranged by applications of regular ϵ-equations at depth k first and then recoloured by ƒ∗ or recoloured by ƒ∗ first and then rearranged in the same way.
Item (v)k+1 remains to be proven. By (i)k+1 we know that tk+1 and t' have the same shape down to depth k + 1 and by (iii)k+1 we know that all the ϵ-classes of subtrees rooted at depth ≤ k + 1 are the same for corresponding nodes of tk+1 and
t'. Thus down to depth k + 1 corresponding nodes are recoloured by ƒ∗ with the

same colour and we obtain ∂k+1(ƒ∗(tk+1)) = ∂k+1(ƒ∗(t')).	 

A simple coequational logic
Theorem 4.7 Let H be a ﬁnitary functor preserving preimages. For every linear order on Σ × C the coequational logic of H has the following form: a coequation ☒q is semantical consequence of the coequations ☒qi, i ∈ I, if and only if there is some tree r¯ with [r¯] = qi for some i ∈ I, so that r¯ is a recolouring of some subtree of tq, shortly
  ☒qi |= ☒q	⇐⇒	∃i ∈ I ∃r¯.[r¯] = qi : r¯ ± tq.	(4.1)
i∈I
Proof. Since every finitary functor is accessible, from Theorem 2.11 we know that the left-hand side of (4.1) is equivalent to
∀t.[t] = q ∃i ∈ I ∃r.[r] = qi : r ± t.	(4.2) We prove (4.2) to be equivalent to the right-hand side of (4.1).
⇒ Since [tq] = q we can look at (4.2) in the special case of t = tq. It yields the
existence of a tree r such that [r] = qi for some i ∈ I and r ± tq. Renaming r to r¯, this already is the right-hand side of (4.1).
⇐ From the right-hand side of (4.1) we have a tree r¯ such that [r¯] = qi for some i ∈ I and r¯ ± tq. The latter means that r¯ is a recolouring of some subtree s¯ of tq. Proposition 4.1 yields for every tree t ∈ QΣ with [t] = q = [tq] the existence of a
subtree s of t with [s] = [s¯]. Since s¯ as a subtree of a first representative tree is again a first representative tree, we obtain from Proposition 4.6 a recolouring r of s with [r] = [r¯]. Altogether this means r ± t and [r] = qi, which is exactly (4.2). 
Since for a semantical consequence of coequations the logic of Theorem 4.7 only requires the existence of one tree r¯ with some properties, it is much simpler than the logic for accessible functors of Theorem 2.11, which for each tree from a whole ϵ-class (such a class may contain infinitely many trees) requires the existence of a tree r with these properties. Because of this (and using the fact that a subtree of a first representative tree always is a first representative tree again) we are able to formulate two simple deduction rules similar to the case of polynomial functors.
Corollary 4.8 For systems of ﬁnitary functors that preserve preimages deduction of coequations with the following rules is sound and complete:
child rule


recolouring rule
☒q'

☒q
where tq' is a child tree of tq



☒q'
where [¯] = 
' for some recolouring ¯ of q

☒q	r	q	r	t

For an example of a logic given by Theorem 4.7, one may instantiate it with the LTS-functor Pf (A × −) and an order as given in Example 4.5.

Finitary functors not preserving preimages
The first direction of Theorem 4.7 (completeness) was easily proven: nothing else but the existence of first representative trees was needed, which is guaranteed for every finitary functor. But for the other way round (soundness) we needed some more effort, especially in Propositions 4.1 and 4.6, which are the core of the simpler logic: they guarantee that the simplification of section 4.3 works. In these propositions we needed the assumption that the functor preserves preimages. We will now prove the necessity of this assumption for Theorem 4.7.
Theorem 5.1 A ﬁnitary functor H with |T | > 1 preserves preimages if and only if for every linear order on Σ × C and any coequations ☒q and ☒qi, i ∈ I, we have:
  ☒qi |= ☒q	⇐⇒	∃i ∈ I ∃r¯.[r¯] = qi : r¯ ± tq.	(5.1)
i∈I

Proof. In Theorem 4.7 for finitary functors preserving preimages it was shown that for every linear order on Σ × C and any coequations (5.1) is true. Now we assume a finitary functor H with |T | > 1 not to preserve preimages and find an order on Σ ×C and coequations, for which (5.1) is not true. For this we do not need different colours, so in the following assume all trees to be coloured completely with the same colour (or equivalently, think of uncoloured trees).
Since H does not preserve preimages, in every presentation of H there is an
ϵ-equation which is not regular, i. e. of the form
σ(x1,..., xn) = τ (y1,..., ym)	(5.2)

where we have a non-empty set

Y := {yi | i ≤ m ∧ yi /= xj ∀j ≤ n}
of variables that do not appear on the left hand side. Moreover, we choose (5.2) such that these new variables yi ∈ Y appear as soon as possible when reading the τ -term from left to right. More precisely, we compare the τ -terms in their variables from left to right asking whether the variables are contained in {x1,..., xn}. As soon as a difference occurs, we choose the term that has the variable not contained in that set. Note that σ and τ may be the same operation symbol.
Now we denote by t the tree whose nodes are all labelled by σ, thus it has the property that all its subtrees are isomorphic to t itself. If the arity n ≥ 1 then t is a tree where every path is infinite, if n = 0 (σ is a constant) then t is a singleton tree. In the ϵ-class [t] we can find all trees whose nodes are only labelled by the operations σ and τ —this is because of (5.2): we can apply it to t, starting at the root and continuing until an arbitrary depth, exactly where we want a node to be labelled

by τ and we do not apply any ϵ-equation, where we want to keep the σ-labels. For every application of (5.2) we choose t for the variables from Y and ensure this way that in greater depths we will always meet nodes labelled by σ.
Since the terminal coalgebra was assumed to have at least two elements, there is a tree from an ϵ-class different from [t] (and this is not due to different colours). Consequently this tree has a node labelled by an operation ρ different from σ and τ . This operation ρ cannot be obtained at a node labelled with σ or τ applying ϵ-equations (in particular there are no ϵ-equations that equate ρ- and σ- or ρ- and τ -terms): if we could obtain ρ from σ or τ via (possibly many) ϵ-equations, we could state that directly in one ϵ-equation ρ(... ) = σ(... ) or ρ(... ) = τ (... ) because of the transitivity of ϵ-equations. But from this we derive analogously to the above situation for the ϵ-equation (5.2) that all trees with node labels from {ρ, τ, σ} belong to the same ϵ-class [t]. But then our assumption of an ϵ-class different from [t] would yield the existence of another operation different from ρ, τ and σ and so on; that process only stops if we find an operation that cannot be obtained from one of the former operations by application of ϵ-equations.
Now we consider a linear order of the operations in Σ such that the first ones are ρ < τ ≤ σ < . . . (which is turned into the beginning of an order of Σ × C by adding the single colour we are using in this proof). We consider the tree r¯ whose
nodes are all labelled by ρ. r¯ is the first representative tree of its ϵ-class because
ρ is the first operation in the order. For its ϵ-class we have [r¯] /= [t] because there are no ϵ-equations that could change ρ into σ. Now we evaluate (5.1) in the case q := [t] and q0 := [r¯] (I = {0}).
We first show that the right-hand side of (5.1) is true: we find the tree tq from the ϵ-class q that is obtained from t by (in case n ≥ 1 infinitely many, but at every level finitely many) applications of (5.2) from left to right, starting at the root of t and proceeding level by level applying it at every node that is root of a tree isomorphic to t. For variables from Y we use the tree r¯, and since Y is non-empty, r¯ is subtree of tq of class q0. We show that tq is the first representative tree of q: as mentioned there are no ϵ-equations whose application could replace τ by ρ and as a consequence of the above assumption on (5.2) it is impossible to obtain a permutation of a node’s children such that ρ-labelled nodes shift to the left. These both facts together with the chosen order of the operations ensures tq to be the first representative tree.
Second, we show that the left-hand side of (5.1) is not true: we just consider the tree t from the ϵ-class q, whose nodes are all labelled by σ. It only has subtrees isomorphic to t which have the ϵ-class q /= q0; and recolourings of these subtrees would have a different root colour than the single one we are using all the time and which is the root colour of all the trees from the ϵ-class q0. This means there is no recolouring of a subtree of t from the ϵ-class q0.	 


Discussion
The intuition of the simpler logic is that the formation of ϵ-classes by ц∗


is com-

patible with subtrees and recolourings. We had to deal with both items in sections

4.1 and 4.2 respectively.
Let us first recall from Proposition 4.1 what compatibility of ϵ-classes and sub- trees means: whenever two Σ-trees are merged in one ϵ-class, their direct subtrees are merged in ϵ-classes again, and recursively for all their subtrees. The consequence of this is that with knowing one tree of an ϵ-class one already knows the ϵ-classes of the subtrees of all other trees of this class, what is captured by the quantifiers (exists / for all) in the above formulas. Finitary functors H that preserve preimages
ensure that compatibility of ϵ-classes and subtrees by their homomorphisms (ц∗ is
an H-homomorphism); all other finitary functors do not: as seen in the proof of Theorem 5.1 trees can be merged in one ϵ-class without their subtrees having the same ϵ-classes.
Now let us have a look at compatibility of ϵ-classes and recolourings. These concepts just are not compatible: having ϵ-classes means having different trees in these ϵ-classes. But as long as subtrees of a tree are not isomorphic, what would be respected by recolourings, arbitrary recolourings can be applied to them taking them to different ϵ-classes. And since we surely have some trees with and some trees without isomorphic subtrees, more or less recolourings can be applied and more or less ϵ-classes can be obtained as seen in Example 4.2. To solve these problems we hid the complexity of ϵ-classes by their first representative trees. In these first representative trees “as much subtrees as possible” are isomorphic and this way the recolourings of a first representative tree form a “minimal” set of ϵ-classes. Under the additional assumption of a preimage preserving functor it turns out in Proposition 4.6 that for every tree of the ϵ-class of a given first representative tree the recolourings form a superset of this set. And this is enough compatibility of ϵ-classes and recolourings to state our simple logic, now working with first representative trees.

Deduction of Sets
For semantical consequences of arbitrary subsets of the cofree coalgebra of a poly- nomial functor there is the following statement.
Theorem 6.1 ([1]) Let U, U' ⊆ QΣ be arbitrary subsets of the cofree HΣ-coalgebra of a polynomial functor HΣ. The following holds: U is semantical consequence of U', if and only if every t ∈ QΣ, for which all recolourings of all subtrees lie in U', is contained in U, shortly
U' |= U	⇐⇒	∀t ∈ QΣ : (∀r.r ± t : r ∈ U') ⇒ t ∈ U.

Analogously to that statement we can prove one for the case of accessible functors although this was not expected by [1].
Theorem 6.2 Let U',U ⊆ Q be arbitrary subsets of the cofree H-coalgebra of an accessible functor H. The following holds: U is semantical consequence of U', if and only if every ϵ-class q ∈ Q, in which there exists a tree t ∈ QΣ, for which the

ϵ-classes of all recolourings of subtrees of t lie in U', lies in U, shortly
U' |= U	⇐⇒	∀q ∈ Q : (∃t.[t] = q ∀r.r ± t : [r] ∈ U') ⇒ q ∈ U.
Proof. We give a proof analogously to the one of [1] for Theorem 6.1. First we reduce semantical consequences of sets to semantical consequences of coequations proving
U' |= U  ⇐⇒  ∀q ∈ Q : (U |= ☒q) ⇒ (U' |= ☒q).
To do so, recall from section 2.2 that U ⊆ Q is logically equivalent to a set of coequations ☒qi, i ∈ I where  i∈I qi is the complement of U . From U' |= U and U |= ☒q we immediately have U' |= U |= ☒q and consequently U' |= ☒q due to transitivity of |=. On the other hand, if we assume (U |= ☒q) ⇒ (U' |= ☒q) for all q ∈ Q, in particular we have (U |= ☒qi) ⇒ (U' |= ☒qi) for all i ∈ I. Since U |= ☒qi is always true for all i ∈ I, it holds that U' |= ☒qi for all i ∈ I. But this just means U' |= U .
Now we can apply Theorem 2.11 in order to get an expression for semantical consequences of sets in terms of the relation ±. Afterwards we use the logical equivalence a ⇒ b ≡ ¬b ⇒ ¬a to rewrite that expression:
(U |= ☒q) ⇒ (U' |= ☒q)
⇐⇒	(∀t∃r∃qi ∈ Q \ U : [t] = q ⇒ [r] = qi ∧ r ± t)
⇒ (∀t∃r∃qi ∈ Q \ U' : [t] = q ⇒ [r] = qi ∧ r ± t)
⇐⇒	(∃t∀r∀qi ∈ Q \ U' : [t] = q ∧ ([r] /= qi ∨ r /± t))
⇒ (∃t∀r∀qi ∈ Q \ U : [t] = q ∧ ([r] /= qi ∨ r /± t))

By slightly rewriting the premise of the latter formula (line before last) we see that it is exactly the premise in the theorem because ∀qi ∈ Q \ U' : [r] /= qi just means
[r] ∈ U'. But the conclusion of the formula (last line) is the conclusion in the theorem, too: in the special case r = t we get ∃t∀qi ∈ Q \ U : [t] = q ∧ [t] /= qi, what means q ∈ U . On the other hand, we cannot conclude anything else from the formula but q' ∈ U for some ϵ-class q'; this is covered by the for all quantifier for q in the theorem.	 

Conclusion and future work
In the present paper we formulated a simple coequational logic for preimage pre- serving finitary functors and proved it to be sound and complete. We also proved that in general we cannot obtain this simple coequational logic for finitary functors that do not preserve preimages. Finally we proved a theorem for accessible func- tors that makes explicit what are semantical consequences of arbitrary subsets of a cofree coalgebra.
It would be of interest to look at infinitary accessible functors. In this case functors may preserve preimages but have no regular presentation, and the question arises which of both is the property needed to establish a simple logic (if this is

still possible at all). We conjecture that the regular presentation is the important property since in our paper we never needed to consider a preimage.

References
Ad´amek, J., A logic of coequations, in: L. Ong, editor, Computer Science Logic – Proceedings of the 19th International Workshop, LNCS 3634 (2005), pp. 70–86.
Ad´amek, J., D. Lu¨cke and S. Milius, Recursive coalgebras of finitary functors, Theoretical Informatics and Applications (2007).
Ad´amek, J. and S. Milius, Terminal coalgebras and free iterative theories, Information and Computation
204 (2006), pp. 1139–1172.
Ad´amek, J. and H.-E. Porst, On tree coalgebras and coalgebra presentations, Theoretical Computer Science 311 (2004), pp. 257–283.
Ad´amek, J. and V. Trnkov´a, “Automata and Algebras in Categories,” Kluwer Academic Publishers, 1990.
Gumm, H. P., Elements of the general theory of coalgebras, LUATCS ’99, Rand Afrikaans University, Johannesburg, South Africa (1999).
Hughes, J., Modal operators for coequations, in: Coalgebraic Methods in Computer Science (CMCS’01), Electronical Notes in Theoretical Computer Science 44.1, 2001, pp. 204–225.
Moss, L. S., Coalgebraic logic, Annals of Pure and Applied Logic 96 (1999), pp. 177–317.
Pattinson, D., Coalgebraic modal logic: soundness, completeness and decidability, Theoretical Computer Science 309 (2003), pp. 177–193.
Rutten, J. J. R. R., Universal coalgebra: a theory of systems, Theoretical Computer Science 249 (2000),
pp. 3–80.
Schwencke, D., “Coalgebraische Logik von markierten Transitionssystemen,” Master’s thesis, Technical University, Braunschweig (2007), unpublished.
Worrell, J., On the final sequence of a finitary set functor, Theoretical Computer Science 338 (2005),
pp. 184–199.
