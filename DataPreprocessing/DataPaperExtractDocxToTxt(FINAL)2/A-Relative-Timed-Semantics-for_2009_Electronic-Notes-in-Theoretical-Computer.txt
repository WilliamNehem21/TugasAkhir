

Electronic Notes in Theoretical Computer Science 229 (2009) 59–75
www.elsevier.com/locate/entcs
A Relative Timed Semantics for BPMN
Peter Y. H. Wong 1 and Jeremy Gibbons 2
Computing Laboratory, University of Oxford, United Kingdom

Abstract
We describe a relative-timed semantic model for Business Process Modelling Notation (BPMN). We define the semantics in the language of Communicating Sequential Processes (CSP). This model augments our untimed model by introducing the notion of relative time in the form of delays chosen non-deterministically from a range. We illustrate the application by an example. We also show some properties relating the timed
semantics and BPMN’s untimed process semantics by exploiting CSP refinement. Our timed semantics allows behavioural properties of BPMN diagrams to be mechanically verified via automatic model-checking as provided by the FDR tool.
Keywords: business process, CSP, refinement, timed semantics, verification, workflow


Introduction
Modelling of business processes and workflows is an important area in software engineering. Business Process Modelling Notation (BPMN) allows developers to take a process-oriented approach to modelling of systems. In our previous work [16] we have given an abstract syntax using Z [20] and an untimed process semantics in the language of CSP [14] to a subset of BPMN [12]. However, due to the lack of a notion of time, this semantics is not able to precisely model activities running concurrently when temporality becomes a factor;
For example, Figure 1 shows a simplified breast cancer clinical trial adapted from the Neo-tango trial protocol [4]. This BPMN representation of clinical trial is based on a new observation workflow model and its corresponding transformation to BPMN [18]. Note the clinical trial specification used throughout this paper is by no means not an accurate representation of real trial. In a clinical study it is important that interventions are carried out safely and effectively, and often interventions must satisfy a set of oncological safety principles [7]. In this example we will focus on

1 Email: peter.wong@comlab.ox.ac.uk
2 Email: jeremy.gibbons@comlab.ox.ac.uk

1571-0661 © 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.06.029




Fig. 1. A simplified clinical trial
the set of interventions A2 denoted as a BPMN subprocess state in Figure 1. An expanded version of A2 is shown in Figure 2 and below we show the schedule of

Fig. 2. A set of clinical interventions

each drug administration, we have omitted dosage for simplicity.
ECC - Cyclophosphamide, every 14 days to 20 days
ECE - Epirubicin, every 18 days to 21 days
TG - Paclitaxel, every 5 days to 10 days followed by Gemcitabine, upto 10 days
One of the safety principles is Sequencing and it ensures each intervention “order(s) (essential) actions temporally for good effect and least harm”. Here we are interested in the following particular instance of this principle for interventions A2.
No more than one dosage of gemcitabine (TGG) may be given after the admin- istration of cyclophosphamide (ECC) and before epirubicin (ECE).
It is these types of properties that we would like to verify the BPMN representation against, while careful calculation could reveal whether or not this trial specification does indeed satisfy the property and hence is “safe”, we are going to show how the semantic model introduced in this paper allows us to mechanically verify the trial specification via automatic model-checking as provided by the FDR tool.
The rest of this paper is structured as follows. Section 2 gives an introduction to BPMN; an introduction to CSP [14] and Z [20], which are used throughout this paper, is given in the Appendix. In Section 3 gives an overview of our syntactic description of BPMN. Section 4 describes briefly our relative timed semantics. In Section 5 we show some properties relating the timed and untimed models based on CSP refinements, and revisit the example to show how the relative-timed model

may be used to verify against the sequencing rule. We conclude this paper with a comparison with related work. The complete formal definition of the timed model may be found in our longer paper [17].

BPMN
States in our subset of BPMN, shown in Figure 3, can either be pools, tasks, sub- processes, multiple instances or control gateways, each linked by a normal sequence, an exception sequence flow, or a message flow. A normal sequence flow can be ei- ther incoming to or outgoing from a state and have associated guards; an exception sequence flow, depicted by the states labelled task*, bpmn*, task** and bpmn**, represents an occurrence of error within the state. While sequence flows represent control flows within individual local diagrams, message flows represent unidirec- tional communication between states in different local diagrams. A global diagram hence is a collection of local diagrams connected via message flows.

Fig. 3. States of BPMN diagram

In Figure 3, there are two types of start state, start and stime. A start state models the start of the business process in the current scope by initiating its out- going transition; it has no incoming transition and only one outgoing transition. The stime state is a variant start state; it initiates its outgoing transition when a specified duration has elapsed. There are also two types of intermediate state, itime and imessage. An itime state is a delay event; after its incoming transition is trig- gered, the delay event waits for the specified duration before initiating its outgoing transition. An imessage state is a message event; after its incoming transition is triggered, the message event waits until a specified message has arrived before initi- ating its outgoing transition. Both types of state have a maximum of one incoming transition and one outgoing transition.
There are two types of end state, end and abort. An end state models the successful termination of an instance of the business process in the current scope by initialisation of its incoming transition; it has only one incoming transition with no

outgoing transition. The abort state is a variant end state; it models an unsuccessful termination, usually an error of an instance of the business process in the current scope.
Our subset of BPMN contains two types of decision state, xgate and agate. Each
of them has one or more incoming sequence flows and one or more outgoing sequence flows. An xgate state is an exclusive gateway, accepting one of its incoming flows and taking one of its outgoing flows; the semantics of this gateway type can be
described as an exclusive choice and a simple merge. An agate state is a parallel
gateway, which waits for all of its incoming flows before initialising all of its outgoing flows.
A task state describes an atomic activity, and has exactly one incoming and
one outgoing transition. It takes a unique name for identifying the activity. In the environment of the timed semantic model, each atomic task must take a positive amount of time to complete. A bpmn state describes a subprocess state. It is a
business process by itself and so it models a flow of BPMN states. In this paper, we assume all our subprocess states are expanded [12]; this means we model the internal behaviours of the subprocesses. The state labelled bpmn in Figure 3 depicts
a collapsed subprocess state where all internal details are hidden; this state has exactly one incoming and one outgoing transition.
Also in Figure 3 there are graphical notations labelled task*, bpmn*, task**, bpmn**, task*** and bpmn***, which depict a task state and a subprocess state
with an exception sequence flow. There are three types of exception associated with task and subprocess states in our subset of BPMN states. Both states task* and bpmn* are examples of states with an ierror exception flow that models an inter- ruption due to an error within the task or subprocess state; the states task** and bpmn** are examples of states with a timed exception flow, and model an inter- ruption due to an elapse of the specified duration; the states task*** and bpmn***
are examples of states with a message exception flow, and model an interruption upon receiving the specified message. Each task and subprocess state can have a maximum of one timed exception flow, although it may have multiple error and message exception flows.
Each task and subprocess may also be defined as multiple instances. There are two types of multiple instances in BPMN: the miseq state type represents serial multiple instances, where the specified task is repeated in sequence; in the mipar state type the specified task is repeated in parallel. The types miseqs and mipars
are their subprocess counterparts.
The graphical notation pool in Figure 3 forms the outermost container for each local diagram, representing a single business process; only one execution instance is allowed at any one time. Each local diagram contained in a pool can also be a participant within a business collaboration (global diagram) involving multiple busi- ness processes. While sequence flows are restricted to an individual pool, message flows represent communications between pools.

Abstract Syntax
In this section we describe the abstract syntax of BPMN using Z notation [20]. For reasons of space, this section provides partial definitions of BPMN’s abstract syntax; readers may refer to our longer paper [17] for full definitions.
We first introduce some maximal sets of values to represent constructs such as
lines, task and subprocess name, defined as Z basic types:
[PName, Task, Line, Channel, Guard, Msg ]
where PName is the set of diagram’s names. In this paper we will only consider the semantics of BPMN timed events describing time cycles (duration) and not absolute time stamps. We define schema type Time to record each duration; this schema models a strictly positive subset of the six-dimensional space of the XML schema data type duration [21, Section 3.2.6].
Time =^ [year, month, day, hour, minute, second : N]
Each type of state shown in Figure 3 is defined using the free type Type where each of its constructors describes a particular type of state. For example, the type of an atomic task state is defined by task t where t is a unique name that identifies that task state. Below is the partial definition.
Type ::= start | stime⟨⟨Time⟩⟩ | end ⟨⟨N⟩⟩ | abort ⟨⟨N⟩⟩ | task ⟨⟨Task ⟩⟩ |
xgate | bpmn⟨⟨BName⟩⟩ | miseq⟨⟨Task × N⟩⟩
According to the BPMN specification [12], each state type has other associated attributes describing its properties; our syntactic definition has included only some of these attributes. For example, the number of loops of a sequence multiple instance state type is recorded by the natural number in the constructor function miseq . In this paper we call both sequence flows and exception flows ‘transitions’; states are linked by transition lines representing flows of control, which may have associated guards. We give the type of a sequence flow or an exception flow, and a message flow by the following schema definitions.

Trans =^ [guard : Guard ; line : Line] Mgeflow =^ [msg : Msg ; chn : Channel ]
Each atomic task state specifies a delay range, min .. max , of type Range, denoting a non-deterministic choice of a delay within those bounds. Each task resolves its choice internally when it is being enacted.
Range =^ [min, max : Time | min ≤T max ]
We record the type, transitions and messageflows of each state by the schema State. Here we show a partial definition of the schema State, omitting the inclusion of

schema components for message flows for reasons of space.
State =^ [type : Type; in, out, error : P Trans; loop : N; ran : Range]
Here we provide the syntactic definition of the task state EC E from the example in Figure 2.
⟨| type ~ task EC E, in ~ t 1, out ~ t 2, error ~ ∅, loop ~ 0,
ran ~ ⟨| min ~ ⟨|year , month, hour, minute, second ~ 0, day ~ 18 |⟩,
max ~ ⟨|year , month, hour, minute, second ~ 0, day ~ 21 |⟩ |⟩ |⟩
Each BPMN diagram encapsulated by a pool is a local diagram and represents an individual business participant in a collaboration, built up from a well-configured finite set of well-formed states [17]. While we associate each local diagram with a unique name, a global diagram, representing a business collaboration, is built up from a finite set of names, each associated with its local diagram; we also associate each global diagram with a unique name.
Timed Semantics
We define a timed semantic function which takes a syntactic description of a global diagram, describing a collaboration, and returns the CSP process that models the timed behaviour of that diagram. That is, the function takes one or more pool states, each encapsulating a local diagram representing an individual participant within a business collaboration, and returns a parallel composition of processes each corresponding to the timed behaviour of one of the individual participants.
For each local diagram, the relative-timed semantics is the partial interleaving of two processes defined by an enactment and a coordination function. The en- actment function returns the parallel composition of processes, each corresponding to the untimed aspect of a state of the local diagram; this is essentially our un- timed semantics of local diagrams [16]. The coordination function returns a single process for coordinating that diagram’s timed behaviour; it essentially implements a variant of the two-phase functioning approach adopted by real-time systems and timed coordination languages [10]. Our timed model permits automatic translation, requiring no user interaction. We will now give a brief overview of the coordination function; again for reasons of space we only present function types accompanied with informal descriptions. The complete formal definition of both the enactment and coordination functions may be found in our longer paper [17].
Informally the coordination process carries out the following steps: branch out and enact all untimed events and gateways until the BPMN process has reached
time stability, that is when all active BPMN states are timed; order all immediate active states in some sequence ⟨t1 .. tn ⟩ according to their shortest delay; enact
all the time-ready states according to their timing information; then remove the
enacted states from the sequence. The process implements these steps repeatedly until the enactment terminates.

We define the function clock to implement the coordination, where TimeState is set of timed BPMN states, function allstates recursively returns a set of states con- tained in a local diagram, including those contained within the diagram’s subprocess states, and begin returns the set of start states of a local diagram.


clock : PName →'
Local →'
Process

This function takes the name of the diagram of type PName and its specification environment (a mapping between diagram/subprocess names and their set of states) of type Local , and returns a process, which first triggers the outgoing transition of one of the start states, determined by the enactment. The process then behaves as defined by the function stable.


stable : (P State →'
P State →'
Process) →'
P State →'
PName →'
Process
Local →'

The function stable is a higher order function; it takes some function f (for example, constructed from the function timer below) and a set of active states, and returns a process, which recursively enacts all untimed active states until the local diagram is time-stable [17] i.e. when all active states of a local diagram are timed. Going back to the example in Figure 2, states EC C , EC E , TGT and TGG are timed and when the function stable is applied to the syntax of the diagram initially, the process it returns will enact all states according to the sequence flows until the set
of active states are { EC C , EC E, TGT }, that is the diagram being time-stable. After which the function behaves as defined by the function f ; in the definition of clock , f is the function timer applied with its first four arguments where the third
and forth arguments are initially empty.


timer : PName →'
Local →'
P State →'
P State →'
P State →'
Process

Generally the function timer takes the diagram’s name and specification envi- ronment, a set of timed states that are active before the previous time stability (initially empty), a set of timed states that have delayed their enactment non- determinisistically (initially empty), and a set of timed states that are active during the current time stability. It orders the set of currently active timed states accord- ing to their timing information. Informally the ordering process carries out the following two steps:
creates a subset of active timed states that has the shortest delay, we denote these states as time-ready [17], in our example after the first time being time-stable, the only time-ready state is state TGT , which has the minimum delay of 5 days;
subtracts the shortest delay from the delay of all timed states that are not time- ready to represent that at least that amount of time has passed, in our example, as TGT is the time-ready, other active timed states EC C and EC E will have delays 9 to 15 days and 13 to 16 days respectively.

The function then behaves as defined by the function trun over the set of time- ready states and the set of active but not time-ready states.


trun : PName →' trun' : PName →' record : PName →'
Local →' Local →' Local →'
P State →' P State →' P State →'
P State →' Process P State →'
Process
P State →'


Process

The function trun returns a process that recursively enacts a subset of the currently active timed states within a given BPMN process that are time-ready. Coordinat- ing time-ready states is achieved by partially interleaving the execution process returned by the function trun' with the recording process returned by the record- ing function record . The function trun' takes the diagram’s name, specification environment and its set of time-ready states, and returns a process that interleaves the enactment of a set of processes, corresponding to its set of time-ready state. These processes terminate if either their corresponding states terminate, are can- celled, or are delayed. For each of these situations, the process will communicate a corresponding coordination event to the recording process After all the interleaved processes terminate, the function trun' terminates and behaves like the process
run(A) =  a : A • a → run(A), over the same set of coordination events, so that if any subsequent coordination contains the same time-ready states due to cycle,
this process will not cause blocking. Below we show trun' applied to the time- ready state TGT , where the event starts.TGT represents the enactment of state TGT (administration of Paclitaxel), init.TGG represents the control flow from state TGT to TGG , and ﬁnish.TGT and delayed.TGT are terminated and delayed events of TGT .
starts.TGT → init.TGG → ﬁnish.TGT → Skip
H delayed.TGT → run({ ﬁnish.TGT, delayed.TGT })
The function record takes the diagram’s name, specification environment, its set of time-ready states and set of active timed states, and returns a process that repeatedly waits for coordination events from the execution process and recalcu- lates the set of active states accordingly. The following rules describe the function informally:
if all time-ready states have delayed their enactments and there are no other currently active states, record re-calculates these states so that the states, of which the delay range has the shortest upper bound, are to be enacted;
if all time-ready states have either been enacted or delayed, then this completes a cycle of timed coordination, and the process then behaves as defined by stable and proceeds with the next cycle;
if there exist time-ready states that have not been enacted or delayed, record
waits for coordination events from the execution process.
In our example when the time-ready state TGT is applied to record , the process it returns either waits for TGT to be enacted or delayed. If TGT is enacted,

it behaves as stable over a empty set of untimed states and the set of timed states
{ EC C , EC E, TGG } since the immediately succeeding state of TGT is TGG , which is a timed state (rule ii). Otherwise it will also behave as stable since the
set of currently active states are not empty (rule ii). The coordination terminates after it enacts an end state of the top level diagram, for a complete definition of the semantic function, it may be found in our longer paper [17].

Analysis
We have implemented the semantics described in this paper as a prototype tool us- ing the functional programming language Haskell. Readers may find a copy of the implementation from our web site 3 . The tool inputs a XML serialised representa- tion of BPMN diagram from the JViews BPMN Modeler [9], enriched with timing information as custom properties, and translates it into an ASCII file containing CSP processes representing its behaviours expressed in machine-readable CSP [14].
The following are some results of the timed model. We say a diagram is timed if it contains timing information and untimed otherwise; every timed diagram is a timed variant of another untimed diagram, i.e. an untimed diagram augmented with timing information. Below is an intuitive property about timed variation.
Proposition 5.1 Untimed Invariance. For any untimed local diagram, there exists an (inﬁnite) set of timed variant diagrams such that all of the diagrams in the set are failures-equivalent under the untimed semantics.
The CSP behaviour models traces (7 ), stable failures (J ) and failures-divergences (U ) admit refinement orderings based upon reverse containment [14]. A behavioural specification R can be expressed by constructing the “least” – that is, the most non-deterministic – process satisfying it, called the characteristic process PR. Any process Q that satisfies specification R has to refine PR, denoted by PR ± Q . One common behavioural property for any process might be deadlock freedom. We de- fine the process DF to specify a deadlock freedom specification for local diagrams
where events ﬁn.n and aborts.n denote successful execution and interruption re- spectively [17].
DF = (H i : Σ \ {|ﬁn, aborts|} • i → DF )
H (Hn : N • ﬁn.n → Skip) H (Hn : N • aborts.n → Stop)
Definition 5.2 A local diagram is deadlock free iff the process corresponding to the diagram’s behaviour failures-refines DF .
One of the results of using a common semantic domain for both timed and untimed models is that we can transfer certain behavioural properties from the untimed to the timed world. We achieve this by showing for any timed variation of any local diagram, the timed coordination process is a responsive plug-in [13] to the enactment process. Informally process Q is a responsive plug-in to P if Q is

3  http://www.comlab.ox.ac.uk/peter.wong/observation/

prepared to cooperate with the pattern set out by P for their shared interface. We now formally present Reed et al.’s definition of the binary relation RespondsTo over CSP processes using the stable failures model.
Definition 5.3 For any processes P and Q where there exists a set J of shared events, Q RespondsTo P iff for all traces s ∈ seq(αP ∪ αQ ) and event sets X
(s T αP, X ) ∈ failures(P ) ∧ (initials(P/s) ∩ JJ) \ X /= ∅
⇒ (s T αQ, (initials(P/s) ∩ JJ) \ X ) ∈/ failures(Q )
where initials(P/s) is the set of possible events for P after trace s and AJ is a set of events A ∪{ C }; C denotes successful termination in CSP.
Proposition 5.4 Responsiveness. For any local diagram p under the relative timed model where its enactment and coordination are modelled by processes E and T respectively, T RespondsTo E.
Proof. (Sketch.) We proceed by considering each of the functions which define the coordination process, and show that for any local diagram p, if there is a set of states which may be performed by p’s enactment after some process instance, then the coordination of p must cooperate in at least one of those states. We do this by showing that if the process defined by each function cooperates with p’s enactment, then the sequential composition of them also cooperates with p’s enactment. 
A direct consequence of Proposition 5.4 is that deadlock freedom is preserved from the untimed to the timed setting.
Proposition 5.5 Deadlock Freedom Preservation. For any process P, mod- elling the behaviour of an untimed local diagram, and for any process Q modelling the behaviour of a timed variant of that diagram,
DF ±F P ⇒ DF ±F Q
We say a behavioural property is time-independent if the following holds.
Definition 5.6 Time Independence. A behavioural specification process S is time-independent with respect to some untimed local diagram whose behaviour is given by process P iff for any process Q modelling the behaviour of a timed variant of that diagram,
S ±F P ⇒ S ±F Q
As a consequence of Propositions 5.4 and 5.5 and refinements over 7 , we can generalise time-independent specifications by the following result.
Proposition 5.7 A speciﬁcation process S is time-independent with respect to some untimed local diagram whose behaviour is given by the process P iff
S ±F P ⇔ traces(S ) ⊇ traces(P ) ∧ deadlocks(S ) ⊇ deadlocks(P )

where traces(P ) is the set of possible traces of process P and deadlocks(P ) is the set of traces on which P can deadlock.
Now we revisit the example given in Figure 2. For reasons of space, both XML representation of the diagram in figure and its corresponding generated CSP script may also be found from our web site. In this section we assume the process A2 to be the relative-timed behaviour of the diagram in the figure. Here we use the CSP
events starts.N where N is a value over the datatype Node to denote administration
of the respective drug.
Node ::= TGT | TGG | EC C | EC E
The CSP events ﬁn.i where i ranging over N are special events denoting the suc- cessful termination of subprocesses and diagrams, in our example we use the event ﬁn.0 to denote the successful termination of the diagram.
To verify the set of clinical intervention against the sequencing rule in Section 1, we exploit CSP’s stable failures semantics, that is we turn the question of property verification into a question of refinement.  The following process S is the most
non-deterministic CSP process satisfying the sequencing rule,
S = starts.TGG → S H starts.EC E → S
H starts.EC C → T H ﬁn.0 → Skip
T = starts.EC E → S H starts.EC C → T
and here is the corresponding failures refinement assertion.
S ±F A2 \ { ﬁn.1, ﬁn.2, ﬁn.3, starts.TGT }
We have abstracted the behaviour of the diagram by hiding part of A2’s al- phabet because the property we are interested in only covers the set of events
{ starts.TGG, starts.EC E, starts.EC C , ﬁn.0 }, i.e. the alphabet of the process
S . When we ask FDR to check this assertion the following counterexample in terms of trace is given ⟨starts.EC C , starts.TGG⟩. This tells us that the event starts.TGG , denoting a dosage of gemcitabine can be given after a dosage cy- clophosphamide is given, this trace is sufficient to disprove the correctness of our
example against the sequence rule since a dosage of epirubicin must be after gemc- itabine according to the syntactic structure of the diagram.
A more detailed analysis reveals that while cyclophosphamide may be adminis- tered after 14 days and epirubicin may only be administered after 18 days, paclitaxel may be delayed for as long as 10 days before being administered, and since gem- citabine is allowed to be administered within the 10 days, it may be given after 5 days, that is before epirubicin and after cyclophosphamide. A possible solution to this is by either restricting the duration in which cyclophosphamide and epirubicin may be administered, or delay the administration of gemcitabine. We have chosen
the latter as it minimises the change of the overall clinical interventions. We achieve this by including a delay event, an itime state, in between states TGT and TGG for a delay of 16 days.

As well as describing individual business processes, BPMN may also be used to specify business collaboration where more than one business processes (participants) communicate via message flows, informally we say a participant is compatible with respect to a collaboration if it cooperates on the pattern of message flow communi- cations. Similar to the notion of compatibility defined over untimed model [19], we formalise time-compatibility using CSP’s responsiveness.
Definition 5.8 Time-Compatibility. Given some collaboration described by the CSP process,
C = (  i : { 1 .. n }• αTi ◦ Ti ) \ M
where n ranges over N and M is the set of events corresponding to the message flows between its participants, whose timed behaviour are modelled by the processes Ti , participant Ti is time-compatible with respect to the collaboration C iff
∀ j : { 1 .. n }\{ i }• Ti RespondsTo Tj
One result of formalising compatibility under our timed semantics is that, since responsiveness is reﬁnement-closed under J [13], time-compatibility is also refinement- closed.
Proposition 5.9 Given that the participants Pi , where i ranges over some index set, are time-compatible in some collaboration C , their reﬁnements under J are also time-compatible in C .
However, refinement closure does not capture all possible compatible partici- pants within a collaboration. Specifically, for each participant in a collaboration there exists a time-compatible class of participants of which any member may re- place it and preserve time-compatibility. This class may be formalised via the stable failures equivalence. This notion augments our earlier definitions in the untimed setting [16].
Definition 5.10 Time-Compatible Class. Given some local diagram name p and its specification l , we define its time-compatible class of participants cfT (p, l ) axiomatically as a set of pairs where each pair specifies a BPMN diagram by its
environment and the name which identifies it.


cfT : (PName × Local ) →'
∀ p : PName; l : Local •
cfT (p, l ) = 
P(PName × Local )

{ p' : PName; l ' : Local |
(((tsem p l ) \ (αprocess pl \ mg p l ))
±F ((tsem p' l ') \ (αprocess p' l ' \ mg p' l ')))
∨ (tsem p' l ' \ (αprocess p' l ' \ mg p' l '))
±F (tsem p l \ (αprocess pl \ mg p l )) }

where the function mg takes a description of a local diagram and returns a set of CSP events corresponding to the message flows of that diagram.
This naturally leads to the definition of the characteristic or the most abstract time-compatible participant with respect to a collaboration.
Definition 5.11 Characteristic Participant. Given the time-compatible class cp of some participant p, specified in some environment l , for some collaboration c, the characteristic participant of cp, specified by a pair of name and the environment, is given by the function charT applied to cp.
charT : P(PName × Local ) →' (PName × Local )
charT = (λ ps : P(PName × Local ) •
(μ(p', l ') : (PName × Local ) |
mg p' l ' = αprocess p' l ' ∧ (∀(p, l ) : ps •
(tsem p' l ' ±F (tsem p l (αprocess p' l ' \ mg p' l '))))))


The following result is a direct consequence of Proposition 5.9, and Defini- tions 5.10 and 5.11.
Proposition 5.12 If a characteristic participant p of a time-compatible class cp, speciﬁed in some environment l , is time-compatible with respect to some collabora- tion c, then all participants in cp are also time-compatible with respect to c.
Related Work and Conclusion
In this paper we introduced a relative-timed semantics for BPMN in CSP to model and reason about collaborations described in BPMN. We have adopted a variant of the two-phase functioning approach widely used in real-time systems and timed coordination languages [10]. We showed properties relating the untimed and timed models of BPMN for both local and global diagrams by using CSP’s notion of responsiveness, and presented an example to demonstrate the application of the semantic model. We have subsequently implemented a prototype of the semantic function in Haskell.
To the best of our knowledge, this paper describes the first relative-timed model for a collaborative graphical notation like BPMN. Some attempts have been made to provide timed models for similar notations such as UML activity diagrams [6,8] and Workflow nets [11]. Both Guelifi et al. [6] and Eshuis [8] have defined their discrete timed semantic models in Clocked Transition System of which behavioural specifications are expressed as temporal logic formulae and verification are carried out via model checking; in Ling et al.’s work, they defined a formal semantics for a timed extension of van der Aalst’s Workflow nets [15] in terms of timed Petri nets. Nevertheless, their semantics do not provide the level of abstraction required to model time explicitly in that they model discrete units of times which we believe may

not be directly applicable to the business process developers whereas our definition captures the six-dimensional space defined by W3C standards [21, Section 3.2.6]. Also unlike BPMN, their target graphical notations and hence their semantic models are not designed for analyses of collaborations where more than one diagram is under consideration. Furthermore, our semantic model has been defined in correspondence to our earlier untimed model [16] so that timed-independent behavioural properties may be preserved across both models.
As in the untimed settings, there exists many approaches in which new process calculi have been introduced to capture the notion of compatibility in collabora- tions and choreographies. Notable works include Carbone et al.’s End-Point and Glocal Calculi for formalising WS-CDL [2] and Bravetti et al.’s choreography calcu- lus capturing the notion of choreography conformance [1]. Both these works tackled the problem of ill-formed choreographies, a class of choreographies of which correct projection is impossible. While the notion of ill-formed choreographies is similar to our definition of compatibility and the notion of contract refinement defined by Bravetti et al. [1] bears similarity to our definition of compatible class, they have defined their choreographies solely in terms of process calculi with no obvious graphical specification notation that could be more accessible to domain specialists.
Future work will include characterising the class of timed-independent behavioural properties suitable for BPMN; applying Dwyer et al’s property specification pat- terns [3] to assist domain specialists to specify behavioural properties for BPMN processes; and applying the timed model to reason about empirical studies such as clinical trials against safety properties [18].
The authors are grateful to Bill Roscoe for his insightful advice on responsiveness during this work.The authors would also like to thank anonymous referees for useful suggestions and comments. The work is funded by Microsoft Research.

References
Mario Bravetti and Gianluigi Zavattaro. Towards a Unifying Theory for Choreography Conformance and Contract Compliance. In Proc. of 6th International Symposium on Software Composition (SC’07), 2007.
Marco Carbone, Kohei Honda, Nobuko Yoshida, Robin Milner, Gary Brown, and Steve Ross-Talbot. A Theoretical Basis of Communication-Centred Concurrent Programming. Technical report, W3C, 2006.
Matthew B. Dwyer, George S. Avrunin, and James C. Corbett. Patterns in property specifications for finite-state verification. In ICSE ’99: Proceedings of the 21st international conference on Software engineering, pages 411–420. IEEE Computer Society Press, 1999.
Helena Earl, Carlos Caldas, Helen Howard, Janet Dunn, and Chris Poole. Neo-tAnGo A neoadjuvant study of sequential epirubicin + cyclophosphamide and paclitaxel +/- gemcitabine in the treatment of high risk early breast cancer with molecular profiling, proteomics and candidate gene analysis, 2004.
Formal Systems (Europe) Ltd. Failures-Divergences Refinement, FDR2 User Manual, 1998. www.fsel. com.
Nicolas Guelfi and Amel Mammar. A Formal Semantics of Timed Activity Diagrams and its PROMELA Translation. In APSEC05, pages 283–290, 2005.
Peter Hammand, Marek J. Sergot, and Jeremy C Wyatt. Formalisation of Safety Reasoning in Protocols and Hazard Regulations. In 19th Annual Symposium on Computer Applications in Medical Care, October 1995.
Hendrik Eshuis. Semantics and Verification of UML Activity Diagrams for Workflow Modelling. PhD thesis, University of Twente, 2002.


ILOG JViews BPMN Modeler. Available at http://www.ilog.com/products/jviews/diagrammer/ bpmnmodeler/.
I. Linden, J.-M. Jacquet, K. De Bosschere, and A. Brogi. On the expressiveness of timed coordination models. Sci. Comput. Program., 61(2):152–187, 2006.
Sea Ling and H. Schmidt. Time petri nets for workflow modelling and analysis. In Proceedings of 2000 IEEE International Conference on Systems, Man, and Cybernetics, pages 3039–3044, 2000.
OMG. Business Process Modeling Notation (BPMN) Specification, February 2006. www.bpmn.org.
J. N. Reed, J. E. Sinclair, and A. W. Roscoe. Responsiveness of interoperating components. Form. Asp. Comput., 16(4):394–411, 2004.
A. W. Roscoe. The Theory and Practice of Concurrency. Prentice-Hall, 1998.
W. M. P. van der Aalst. Verification of Workflow Nets. In ICATPN ’97: Proceedings of the 18th International Conference on Application and Theory of Petri Nets, pages 407–426, 1997.
Peter Y. H. Wong and Jeremy Gibbons. A Process Semantics for BPMN. In Proceedings of the 10th International Conference on Formal Engineering Methods, October 2008. To appear. Extended version available at http://web.comlab.ox.ac.uk/oucl/work/peter.wong/pub/bpmnsem.pdf.
Peter Y. H. Wong and Jeremy Gibbons. A Relative-Timed Semantics for BPMN (extended version), 2008. http://web.comlab.ox.ac.uk/oucl/work/peter.wong/pub/bpmntime.pdf.
Peter Y. H. Wong and Jeremy Gibbons. On Specifying and Visualising Long-Running Empirical Studies. In Proceedings of 1st International Conference on Model Transformation, volume 5063 of LNCS, July 2008. Extended version available at http://web.comlab.ox.ac.uk/oucl/work/peter. wong/pub/transext.pdf.
Peter Y. H. Wong and Jeremy Gibbons. Verifying Business Process Compatibility. In Proceedings of 8th International Conference on Quality Software. IEEE Computer Society Press, August 2008. To appear.
J. C. P. Woodcock and J. Davies. Using Z: Specification, Proof and Refinement. Prentice Hall International Series in Computer Science, 1996.
XML Schema Part 2: Datatypes Second Edition, October 2004. http://www.w3.org/TR/2004/ REC-xmlschema-2-20041028/.

Appendix
CSP
In CSP [14], a process is a pattern of behaviour; a behaviour consists of events, which are atomic and synchronous between the environment and the process. The environment in this case can be another process. Events can be compound, con- structed using the dot operator ‘.’; often these compound events behave as channels communicating data objects synchronously between the process and the environ- ment. For reasons of space we only describe a subset of the syntax of the language of CSP that is used throughout this paper.
P, Q ::= P |[ A ]| Q | P |[ A | B ]| Q | P \ A |
P  Q | P H Q | e → P | Skip | Stop
e	::= x | x .e
Process P |[ A ]| Q denotes the partial interleaving of processes P and Q sharing events in set A. Process P |[ A | B ]| Q denotes parallel composition, in which P and Q can evolve independently but must synchronise on every event in the set A ∩ B ;

the set A is the alphabet of P and the set B is the alphabet of Q , and no event in
A and B can occur without the cooperation of P and Q respectively.
Process P \ A is obtained by hiding all occurrences of events in set A from the environment of P . Process P  Q denotes the external choice between processes P and Q ; the process is ready to behave as either P or Q . Process P H Q denotes the internal choice between processes P or Q , ready to behave as at least one of P and Q but not necessarily offer either of them. An internal choice over a set of indexed processes is written Hi : I • P (i ).
Process e → P denotes a process capable of performing event e, after which it will behave like process P . The process Stop is a deadlocked process and the process Skip is a successful termination.
CSP has three denotational semantics: traces (7 ), stable failures (J) and failures-divergences (U ) models, in order of increasing precision. In this paper our process definitions are divergence-free, so we will concentrate on the stable fail- ures model. The traces model is insufficient for our purposes, because it does not record the availability of events and hence only models what a process can do and not what it must do [14]. Notable is the semantic equivalence of processes P  Q and P H Q under the traces model. In order to distinguish these processes, it is necessary to record not only what a process can do, but also what it can refuse to do. This information is preserved in refusal sets, sets of events from which a process in a stable state can refuse to communicate no matter how long it is offered.
The set refusals(P ) is P ’s initial refusals. A failure therefore is a pair (s, X ) where s ∈ traces(P ) is a trace of P leading to a stable state and X ∈ refusals(P/s) where P/s represents process P after the trace s. We write traces(P ) and failures(P ) as the set of all P ’s traces and failures respectively.
We write Σ to denote the set of all event names, and CSP to denote the syntactic domain of process terms. We define the semantic function J to return the set of all traces and the set of all failures of a given process, whereas the semantic function
returns solely the set of traces of the given process.
J : CSP → (P seq Σ × P(seq Σ × P Σ))
7 : CSP → P seq Σ
These models admit refinement orderings based upon reverse containment; for ex- ample, for the stable failures model we have
 ±F  : CSP — CSP
6 P, Q : CSP •
P ±F Q e traces(P ) ≥ traces(Q ) Λ failures(P ) ≥ failures(Q )
While traces only carry information about safety conditions, refinement under the stable failures model allows one to make assertions about a system’s safety and availability properties. These assertions can be automatically proved using a model checker such as FDR [5], exhaustively exploring the state space of a system, either returning one or more counterexamples to a stated property, guaranteeing that no

counterexample exists, or until running out of resources.

Z notation
The Z notation [20] has been widely used for state-based specification. It is based on typed set theory coupled with a structuring mechanism: the schema. A schema is essentially a pattern of declaration and constraint. Schemas may be named using the following syntax:
Name =^ [declaration | constraint ]

The mathematical language within Z provides a syntax for set expressions, pred- icates and definitions. Types can either be basic types ([Type]), maximal sets within the specification, each defined by simply declaring its name, or be free types
(Type ::= element1 | ... | elementn ), introduced by identifying each of the distinct
members, introducing each element by name. By using an axiomatic definition we can introduce a new symbol x , an element of S , satisfying predicate p.

