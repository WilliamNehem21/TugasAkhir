Electronic Notes in Theoretical Computer Science 176 (2007) 65–84	
www.elsevier.com/locate/entcs

Modeling Pointer Redirection as Cyclic Term-graph Rewriting 1
Dominique Duval2	Rachid Echahed3	Fr´ed´eric Prost 4

Abstract
We tackle the problem of data-structure rewriting including global and local pointer redirections. Each basic rewrite step may perform three kinds of actions: (i) Local redirection, the aim of which is to redirect specific pointers determined by means of a pattern ; (ii) Replacement, that may add new information to data-structures ; (iii) Global redirection, which is aimed at redirecting all pointers targeting a node towards another one. We define a new framework, following the double-pushout approach, where graph rewrite rules may mix these three kinds of actions in a row. We define first the category of graphs we consider and then we define rewrite rules as pairs of graph homomorphisms of the form L ← K → R. In our setting, graph K is not arbitrary, it is used to encode pointer redirection. Furthermore, pushouts do not always exist and complement pushouts, when they exist, are not unique. Despite these concerns, our definition of rewriting
steps is such that a rewrite rule can always be fired, once a matching is found.
Keywords: Graph rewriting, category theory, double pushout, pointer redirection.


Introduction
Pointers are programming tools which allow one to design efficient implementa- tions of algorithms. Their manipulation is well-known to be error-prone, due to their flexibility and power. And so, programs which handle pointers are more diffi- cult to write and to maintain. Formal techniques, to write and validate programs manipulating pointers, are thus crucial to enhance the quality of software. For- mally, data-structures constructed by means of pointers are particular graphs where pointers are represented by edges. In the literature, general frameworks of graph transformation are now well established, see e.g. [30,18,19]. Furthermore, rewriting techniques have been shown to be very useful to establish formal bases of very high level programming languages as well as theorem provers. These techniques have

1 This work has been partly funded by the project ARROWS of the French Agence Nationale de la Recherche.
2 Dominique.Duval@imag.fr ; Laboratoire LMC ; Grenoble, France
3 Rachid.Echahed@imag.fr ; Laboratoire Leibniz ; Grenoble, France
4 Frederic.Prost@imag.fr ; Laboratoire Leibniz ; Grenoble, France


1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2006.10.027

been widely investigated for strings [11], trees or terms [4] as well as term graphs (or dags) [27,9].
In this paper we follow the double pushout approach [13,24] of graph trans- formation and propose a new class of graph rewrite systems aiming at rewriting (cyclic) data-structures with pointers such as circular lists, doubly-linked lists etc. In general, such data-structures may be subject of four main operations, namely: (i) addition of new records and pointers (ii) redirection of existing pointers (iii) redefi- nition of existing records and (iv) deallocation of some records in order to be swept by a garbage collector. Our proposal focuses on the two first operations. The third operation can be achieved via compilation techniques, as objects are defined up to isomorphisms in categorical approaches. However, we do not tackle the fourth oper- ation in this paper. We dedicate a particular study of garbage collection, following a categorical approach, and apply it to graph rewriting in [16].
In the proposed class of rewrite systems, a special care has been dedicated to define redirection of pointers. We distinguish two kinds of pointer redirections: local redirection and global redirection. Informally speaking, a local redirection redefines the target of a specific pointer, which is determined by a pattern. This is the kind of redirection one may find in imperative languages. A global redirection of pointers consists, instead, in redirecting all pointers targeting a node toward another one. This kind of global redirection are often implicit in declarative languages based on rewriting techniques. It happens when a rooted structure is replaced by another one. In such situation, all pointers targeting the old root should be redirected to point the new root. One may also use such redirections in order to easily update databases when, for instance, old data are to be replaced by new ones. Notice that global redirection can be simulated by means of a series of local redirections, but this is done in general via some cumbersome encoding.
Graph rewriting offers the possibility to define global and local redirection ac- tions in a very high level. We highlight these two possibilities in our proposal and thus depart from existing ones such as [8,26,17,12](see related work section below for further discussion). A rewrite rule is defined as a pair of graph (data-structure) homomorphisms L ← K → R. The graph K plays a key role in pointer rewriting. The application of such a rule to rewrite an actual graph G into another graph H consists to find a homomorphism m : L → G, and to construct graph H such that the two squares depicted in Fig. 1 are pushouts.
Hereafter, we illustrate our approach through an example. Let us modify a particular circular list by replacing its head, B, by a new cell, E, and changing the head, B, of the circular list by the cell A. These two actions require both local (addition of the new cell) and global (modification of the head of the list) redirections. In Fig. 2 is schematised one single rule implementing these operations. An application of this rule is given in Fig. 3, where graph G1 is rewritten into H1. H1 is obtained from G1 by (i) adding new cell E, (ii) redirecting the pointer outgoing cell A to point E (to incorporate the new cell) and finally, (iii) redirecting all pointers, but the one considered in the previous step (ii), targeting cell B (previous head of the circular list) to point to cell A (the new head of the list). To achieve

such transformation, the left-hand side L of the considered rewrite rule consists of three linked cells A, B and C. The role of the considered rewrite rule consists in:
Adding the new cell E
Redirecting the pointer outgoing A to point to the new cell E. Such (local) redirection of pointer is achieved by disconnecting the considered pointer (out- going A) in graph K, and making it point to a new (variable) unlabeled node A[1] such that l(A[1]) = B and r(A[1]) = E.
Redirecting all pointers targeting cell B, but the pointer outgoing A (because this pointer is alredy locally redirected), to point to cell A. To perform such (global) redirection of pointers, we add a new (variable) unlabeled node, B[0], in graph K such that l(B[0]) = B and r(B[0]) = A. B[0] can be isolated in graph K, i.e. B[0] is not necessarily target of any pointer in K. The role of B[0] can be better explained when one considers the double-pushouts that define a rewrite step as in Fig 1. Indeed, rewriting a graph such as G1 by using the considered rule, consists, in particular, to disconnect, in graph D1 (Fig. 4), all pointers targeting cell B, but the one outgoing cell A, in G1 and redirect them to B[0] in D1. The pointer outgoing A, which is locally redirected, points the new variable node A[1] in D1. Details of this construction are given in section 4.
In general, one may perform several local and global pointer redirections in one step. For each redirection, new (variable) unlabeled node should be added with the right definitions of morphisms l and r.
L ¸, l	 K 	r	 R 

m	d	m'
J¸ , l'	J  r'	 J 
G	D	H

Fig. 1. Double pushout: a rewrite step (G → H)
The considered homomorphisms of a rewrite rule (l, r, m in Fig. 1) are not neces- sarily injective in our setting, unlike classical assumptions as in the recent proposals dedicated to graph programs [28,25], and complement pushouts (graph D in Fig. 1) are not unique.
Global redirection is very often used in the implementation of functional pro- gramming languages, for instance when changing roots of term graphs. As for local

A ,  ,B ,	A	B
, ,	,

J	J	J	J	J	J

,J ,
J  ,J ,
,J ,  ,J ,

¸l(B,[0])=B
l(A[1])=B
A[1]•
 r(B[0])=A     E
r(A[1])=E
J	J

•J 
B[0]•	•J 
•J 

Fig. 2. Rewrite rule example

G1 =	Γ
 	z ˛
A	 B	E

 ,,J  ¸ J	c , J
c

J 	
F ¸, C

   H1 =	Γ
ccc

B


z	r	J
	˛A 
 ,,

tJz 
F ¸, C


Fig. 3. Rewrite step example
z	r	J

¸, 	,
, ,	,

B[0]• ¸   Γ
	J	J

ccc
cc	,
,,
,  ,J ,

  jc
A[1]•	F
¸, C

z	r	J

Fig. 4. Rewrite step example (D1 Graph)
redirection, it is useful to express classical imperative algorithms.
Related Work
Term graph rewriting [8,27,9] has been mainly motivated by implementation is- sues of functional programming languages. These motivations impact clearly their definition.
In [23,14] jungles, a representation of acyclic term graphs by means of hyper- graphs, have been investigated. We share with these proposals the use of the double- pushout approach of rewriting. However, we are rather interested in cyclic graphs. In [8,26,17] cyclic term graph rewriting is considered using the algorithmic way.
Pointer redirection is limited to global redirection of all edges pointing to the root of a redex by redirecting them to point to the root of the instance of the right-hand side. In [7], Banach, inspired by features found in implementations of declarative languages, proposed rewrite systems close to ours. We share the same graphs and global redirection of pointers. However, Banach did not discuss local redirections of pointers. We differ also in the way to express rewriting. Rewriting steps in [7] are defined by using the notion of an opfibration of a category while our approach is based on double-pushouts.
[12] is a work combining a categorical approach and cyclic term graphs. It de- parts from our work in the fact that the explicit manipulation of edges is not han- dled. Actually there is an edge manipulation during the redirection phase which corresponds to our notion of global redirection. But it is limited to the root and cannot be handled by the programmer. In [15] cyclic graphs are also studied using addressed term rewriting systems. In this case too the direct manipulation of point- ers is not addressed. The same remark can be done for [10] that is an extension of ρ-calculus able to deal with cyclic structures. It is not possible in these systems

to express the update of a shared data. The work of [2] considers an equational framework for cyclic graph rewriting, it also cannot handle explicitly pointers.
The difference between our proposal to generalize term graph rewriting and previous works comes from the motivation. Our aim is not the implementation of declarative programming languages. It is rather the investigation of the elementary transformation rules of data-structures as occur in classical algorithms. In such structures pointers play a key role that we tried to take into account by proposing for instance redirections of specific edges within rewrite rules.
In [25], Habel and Plump proposed a kernel language for graph transformation. This language has been improved recently in [28]. Basic rules in this framework are of the form L ← K → R satisfying some conditions such as the inclusion K ⊆ L. Unfortunately, our rewrite rules do not fulfill such condition ; particularly when performing local edge redirections. Furthermore, complement pushouts are not unique in our setting which is not the case in [25,28].
Recently, in [6,5] the authors are also interested in classical data-structures built by using pointers. Their work is complementary to ours; they proposed Graph reduction speciﬁcations as a framework to recognize data-structure shapes in order to check the type safety of pointer algorithms.
Last, but not least, there are some programming languages which provide graph transformation features (see, e.g. [31,20,22,29]). Our purpose in this paper is to focus on formal definition of basic data-structure transformation steps rather than building an entire programming language with suitable visual syntax and appropri- ate evaluation strategies.
The rest of the paper is organised as follows. The next section introduces the cat- egory of graphs we consider. Section 3 states some technical results that help defin- ing rewrite steps. Section 4 introduces data-structure rewriting (including global and local redirection of pointers) through a double-pushout approach. Conclud- ing remarks are given in section 5. Proofs may be found in the appendix. We assume some familiarity with basic notions of category theory (see e.g. [3] for an introduction).

Graphs
In this section we introduce the category of graphs we consider in the paper. These graphs are supposed to represent data-structures and are the ones introduced in [8]. We define below such graphs in a mono-sorted setting. Lifting our results to the many-sorted case is straightforward.
Definition 2.1 (Signature) A signature Ω is a set of operation symbols such that each operation symbol in Ω, say ƒ, is provided with a natural number, n, representing its arity. We write ar(ƒ )= n.
In the sequel, we use the following notations. Let A be a set. We note A∗ the set of strings made of elements in A. Let ƒ : A → B be a function. We note ƒ ∗ : A∗ → B∗ the unique extension of ƒ over strings defined by ƒ ∗(ϵ)= ϵ where ϵ is

the empty string and ƒ ∗(a1 ... an)= ƒ (a1) ... ƒ (an).
We assume that Ω is fixed throughout the rest of the paper.
Definition 2.2 (Graph) A graph G is made of:
a set of nodes NG,
a subset of labeled nodes N Ω ⊆ NG,
a labeling function LG : N Ω → Ω,
a successor function SG : N Ω → N ∗ ,
G	G
such that for each labeled node n, the length of the string SG(n) is the arity of the operation LG(n),
We can remark the following fact: the arity of a node n is defined as the arity of its label, the i-th successor of a node n is denoted succG(n, i), the edges of a graph G are the pairs (n, i) where n ∈ N Ω and i ∈ {1,... , ar(n)}, the source of an edge (n, i) is the node n, and its target is the node succG(n, i), ƒ = LG(n) is written as
n : ƒ , the set of unlabeled nodes of G is denoted N X , so that: NG = N Ω + 5 N X .
G	G	G
Example 2.3 Let G be the graph defined by NG = {m; n; o; p; q; r; s; t}, N Ω =
X	G
{m; o; p; s; t}, NG = {n; q; r}, LG is defined by: [m '→ ƒ ; o '→ g; p '→ h; s '→ i; t '→ j],
SG is defined by: [m '→ no; o '→ np; p '→ qrm; s '→ m; t '→ tsn].
Graphically we represent this graph as:
s : i  m : ƒ 
sss
n : •,¸c,so : g 	 p : h
,,	ss
q : •s,cr :J• 
We use • to denote lack of label. Informally, one may think of • as anonymous variables.
Definition 2.4 (Graph homomorphism) A graph homomorphism ϕ : G → H is a map ϕ : NG → NH such that for each labeled node n, LH(ϕ(n)) = LG(n) and SH (ϕ(n)) = ϕ∗(SG(n)).
The image ϕ(n, i) of an edge (n, i) of G is defined as the edge (ϕ(n), i) of H.
Example 2.5 Consider the following graph H:
¸v :,i  a : ƒ
    
b : ,¸s, J 

,•,
c : g
J 
d : •
e : •

Let ϕ : NH → NG, where G is the graph defined in Example 2.3, be defined as:

5 + stands for disjoint union.

[a '→ m; b '→ n; c '→ o; d '→ p; e '→ p; v '→ s; t '→ t]. Map ϕ is a graph homomorphism from H to G. Notice that the nodes without labels act as placeholders for any graph.
It is easy to check that the graphs (as objects) together with the graph homo- morphisms (as arrows) form a category, which is called the category of graphs and noted Gr .
Disconnections
This section is dedicated to some technical definitions, in order to simplify the definition of rewrite rules in the next section.
First, we define a disconnection of a graph L, it is made of a graph K and a graph homomorphism l : K → L; roughly speaking, the graph K is obtained by redirecting some edges of L towards new, unlabeled targets, and the homomorphism l reconnects all the disconnected nodes.
Definition 3.1 (Disconnection of a graph) A disconnection of a graph L is

made of a graph K and a graph homomorphism: L ¸, l	 K
surjective on the nodes and bijective on the labeled nodes.
The next result builds some kinds of disconnections of graphs.
such that l is

Proposition 3.2 Let L be a graph, E a set of edges and N a set of nodes of L. Let K be the graph deﬁned by:
NK = NL + NE + NN , where NE is made of one new node n[i] for each edge
(n, i) ∈ E and NN is made of one new node n[0] for each node n ∈ N,
N Ω = N Ω,
K	L
for each n ∈ N Ω: LK(n)= LL(n),
for each n ∈ N Ω and i ∈ {1,... , ar(n)}:
if (n, i) /∈ E then succK (n, i)= succL(n, i),
if (n, i) ∈ E then succK (n, i)= n[i],
Let l : K → L be the graph homomorphism deﬁned by: l(n) = n if n ∈ NL ,
l(n[i]) = succL(n, i) if n[i] ∈ NE, l(n[0]) = n if n[0] ∈ NN . Then, l : K → L is a disconnection of L.
Definition 3.3 The disconnection deﬁned in proposition 3.2 is called the discon- nection of L with respect to E and N.
An example of the definition above is given in Example 3.9. Now, the notion of disconnection is extended, from a graph L to a graph homomorphism m : L → G.
Definition 3.4 (Disconnection of a graph homomorphism) A disconnection
of a graph homomorphism m : L → G is a commutative square:
L ¸, l	 K
m	d
J¸ , l'	J 
G	D

where l and l' are disconnections.
The next result builds some kinds of disconnections of graph homomorphisms.
Proposition 3.5 Let L be a graph, E a set of edges and N a set of nodes of L, and l : K → L the disconnection of L with respect to E and N. Let m : L → G be
a graph homomorphism such that the restriction of m to (N Ω ∪ N ) is injective. Let

E' = m(E) and N '
L
= m(N ). Let D be the graph deﬁned by:

ND = NG + NE' + NN' , where NE' is made of one new node p[i] for each edge
(p, i) ∈ E' and NN' is made of one new node p[0] for each node p ∈ N ,
N Ω = N Ω,
D	G
for each p ∈ N Ω: LD(p)= LG(p),
for each p ∈ N Ω and i ∈ {1,... , ar(p)}:
if p ∈ m(N Ω) and (p, i) /∈ E' then succD(p, i)= succG(p, i),
if p ∈ m(N Ω) and (p, i) ∈ E' then succD(p, i)= p[i],
if p /∈ m(N Ω) and succG(p, i) /∈ N ' then succD(p, i)= succG(p, i),
if p /∈ m(N Ω) and succG(p, i) ∈ N ' then succD(p, i)= succG(p, i)[0],
Let l' : D → G be the graph homomorphism deﬁned by: l'(p) = p if p ∈ NG,
'	'
l (p[i]) = succG(p, i) if p[i] ∈ NE' , l (p[0]) = p if p[0] ∈ NN' .
Let d : K → D be the graph homomorphism deﬁned by: d(n) = m(n) if n ∈ NL,
d(n[i]) = m(n)[i] if n[i] ∈ NE, d(n[0]) = m(n)[0] if n[0] ∈ NN . Then, we get a disconnection of m : L → G.
Proof. The fact that l' is a disconnection is easy to check. For the commutativity, let n be a node of K, then:
if n ∈ NL then l'(d(n)) = l'(m(n)) = m(n)= m(l(n)),
if n[i] ∈ NE then l'(d(n)) = l'(m(n)[i]) = succG(m(n), i) = m(succL(n, i)) =
m(l(n[i])),
if n[0] ∈ NN then l'(d(n[0])) = l'(m(n)[0]) = m(n)= m(l(n[0])), so that l' ◦ d = m ◦ l, as required.
Definition 3.6 The disconnection deﬁned in proposition 3.5 is called the discon- nection of m with respect to E and N, or the disconnection of m extending l.
Remark 3.7 With above notations, the map d : NK → ND can be described as the sum of three maps: d = dL + dE + dN with: dL = m : NL → NG, dE : NE → NE' such that n[i] '→ m(n)[i], dN : NN → NN' such that n[0] '→ m(n)[0]. If, in addition, the restriction of m to (N Ω ∪ N ) is injective, then both dE and dN are bijections.
Theorem 3.8 (A pushout square) Let m : L → G be a graph homomorphism, E a set of edges and N a set of nodes of L, such that the restriction of m to (N Ω∪N ) is injective. Then, the disconnection of m with respect to E and N is a pushout in the category of graphs.
Proof. This result is an easy corollary of Theorem A.3 (see the appendix).

Example 3.9 Consider the graph H of Example 2.5. Then the disconnected graph,
Hd, associated to H and the set of edges {(a, 2); (c, 1)} is the following graph:


v :,i, a : ƒ ¸¸¸
c : g¸¸¸
 d : •

J  ¸¸z	¸¸z 

˛t :¸j
 b : •	a[2] : •	e : •	c[1] : •

Now if we consider the graph homomorphism ϕ : H → G defined in Exam- ple 2.5, the disconnection of a graph homomorphism leads to the following homo- morphism : Dϕ : Hd → Gd, where Gd is the disconnection of G relatively to edges
{(ϕ(a), 2); (ϕ(c), 1)}, is the mapping [a '→ m; b '→ n; c '→ o; d '→ p; e '→ p; a[2] '→
m[2]; c[1] '→ o[1]; v '→ s; t '→ t]

Data-structure rewriting
A rewrite step is defined from a rewrite rule and a matching. A rewrite rule is a kind of span of graphs (a span is a pair of homomorphisms with a common source):
L ¸,l  K  r  R . A matching is a kind of morphism of graphs: L  m  G . The role of a rewrite step consists in:
adding to G an instance of the right-hand side R,
performing some local redirections of edges in G: some edges, in the image of the matching, are redirected to other target nodes,
performing some global redirections of edges in G: all incoming edges of some nodes, except those in the image of the matching, are redirected to other target nodes,
We use the double-pushout approach to define a rewrite step. We do not deal with deletion of items in this paper ; this could easily be performed by means of the notion of rooted graphs and the use of garbage collection. A categorical approach of garbage collection and its application to graph rewriting may be found in [16].
Definition 4.1 (Rewrite rule) A rewrite rule, or production, is a span of graph homomorphisms of the form: L ¸, l	 K  r  R where l : K → L is the disconnection of L with respect to a set of edges E and a set of nodes N of L and
where the restriction of r to N X is injective and has its values in N X . The locally
redirected edges of p are the edges in E, and its globally redirected nodes are the nodes in N.
The reader may notice that the rewrite rules we consider are different from disconnected productions of [21]. Actually, we do not use the same notion of discon- nected graphs. In general, disconnected graphs according to our definition do not fulfill the disconnection conditions given in [21].
We now give two toy examples to illustrate this definition. We start by the local redirection mechanism.
Example 4.2 Let us observe on the following double pushout how local redirection

  
u : f	 v : •
, 	 v : •
¸¸z 
  
u : f	 v : •
¸¸¸

w :J• 
 
w : •	u[1] : •
 
w : •
 
z 
x : b



,   v  
,	,	v
,,	v  	,

Gr ¸¸¸ u : f	 v : c
Gr ¸¸¸ u : f ¸¸¸ v : c
Gr ¸¸¸ u : f¸¸¸ v : c

¸¸zJ	(
J
¸¸	¸¸z 
w : a	u[1] : •

¸¸	¸¸
w : a	x : b
J


Fig. 5. Local Redirection

works. Consider the double pushout given in Fig. 5. We would like to redirect the first argument (pointer) of the function ƒ to a new one, say x : b. This is done by the introduction in K of an unlabeled node u[1]. This node is mapped to the actual argument in L (w) and to the new target x : b (with b some 0-ary operator) in R by morphisms. Notice also that edges coming from other parts of the graph (symbolized by Gr) are not modified by this (local) redirection.
Example 4.3 In this example we show how global redirection works. A Global redirection is intended to redirect in a row, all pointers in the environment, but those in the left-hand side, which point a particular node, to point to a new node. In the example given in figure 6, we want to redirect all edges with target n, but (n, 1), towards o. For this purpose, we define a rewrite rule (i.e. a span) . We introduce a node n[0] in K. n[0] is associated by morphisms to n in L and to o in R.

  
m : f	 o : •
n :J• 
 
 	
m : f	 o : •
(	
n :J•  n[0] : •
J	 
  
m : f	 o : •
n :J• 
J		J

,	v	, ,	v	,	, 	 v	,

p : h ¸¸ m : f   o : a
p : h	 m : f 	 o : a
p : h	 m : f   _zo : a

¸¸¸¸¸ ¸¸¸¸
¸¸¸¸	¸¸¸
,,,¸,¸,¸,

J	¸¸¸¸¸zz_ 
J   ¸z	¸¸z 	)
J, ,,,,	¸¸z 

q : g	 n : b
	J
q : g	 n[0 ] : •	n : b
	J
q : g
 
n : b



Fig. 6. Global Redirection


Definition 4.4 (Matching) Let p be a rewrite rule L ¸,l   K   r  R . A match- ing with respect to p is a graph homomorphism m : L → G such that the restriction of m to (N Ω ∪ N ) is injective, where N is the set of globally redirected nodes of p.
Definition 4.5 (Rewrite step) Let p be the rewrite rule L ¸,l  K  r  R and

m : L → G a matching with respect to p. Let:
L ¸, l	 K
m	d
J¸ , l'	J 
G	D
be the disconnection of m extending l. Then G rewrites to H using rule p if there are graph homomorphisms m' : R → H and r' : D → H such that the following square is a pushout in the category of graphs:
K 	r	 R 
d	m'
J   r'	 J 
D	H
According to theorem 3.8 and to the definition of a matching, the disconnection of m extending l is a pushout. So, a rewrite step corresponds to a double pushout in the category of graphs. However, the reader can easily verify that, in general, double pushouts do not always exist whenever the matching m is non injective on (N Ω ∪ N ) (see Definition 4.4) and graph D is not unique :
L ¸, l	 K 	r	 R 

m	d	m'
J¸ , l'	J  r'	 J 
G	D	H
Theorem 4.6 (Rewrite step is feasible) Let p be a rewrite rule and m : L → G a matching with respect to p. Then G can be rewritten using rule p. More precisely, the required pushout can be built as follows, with the notations from deﬁnition 4.5:
the set of nodes of H is NH = (NR + ND)/ ∼, where ∼ is the equivalence relation generated by d(n) ∼ r(n) for each node n of K,
the maps m' and r', on the sets of nodes, are the inclusions of NR and ND in
NR + ND, respectively, followed by the quotient map with respect to ∼,
N Ω is made of the classes modulo ∼ which contain at least one labeled node (let
ρ : N Ω → N Ω + N Ω be a section of the quotient map, which means that the class
H	R	D
of ρ(n) is n, for each n ∈ N Ω),
for each n ∈ N Ω, the label of n is the label of ρ(n),
for each n ∈ N Ω, the successors of n are the classes of the successors of ρ(n), Moreover, the resulting pushout does not depend on the choice of the section ρ.
Corollary 4.7 (A description of the nodes) With the notations and assump- tions of Theorem 4.6, the representatives of the equivalence classes of nodes of NR + ND can be chosen in such a way that:
N Ω = (N Ω − m(N Ω)) + N Ω and N X = N X + (N X − r(N X )) .
H	G	L	R	H	G	R	L

Proof. Both Theorem 4.6 and Corollary 4.7 are derived from Theorem A.5, their proofs are given at the end of the appendix.

Conclusion
We proposed a new framework for cyclic data-structure rewriting, where data- structures were represented by means of cyclic term-graphs [8]. Rewrite steps were defined following the well-known double-pushout approach [13,24]. However, in the considered category of graphs, pushouts do not always exist and complement pushouts are not unique, when they exist. Nevertheless, we have shown in Theo- rem4.6 that a rewrite rule can always be performed as soon as a matching homomor- phism is found. The main feature of the proposed rules is the possibility to handle pointers explicitly through local and global redirection of edges. This advantage has a price that one pays when analysing the induced rewrite relation. Indeed, insuring confluence or termination become trickier than in classical term rewrite systems or even graph rewrite systems with injective morphisms.
Several problems related to the proposed class of rewrite systems deserve to be investigated. The confluence property is certainly one of the most crucial. This problem is also related to the design of data-structure rewrite strategies, which re- main to be studied too. Sometimes, the rewrite process generates graphs containing nodes which are considered as garbage. Such nodes ought to be removed. The re- moval of these nodes is often performed by garbage collectors. A categorical view of garbage collection and its application to graph rewriting may be found in [16]. Another work related to our proposal consists in lifting rewrite relation to narrow- ing [32,1]. Such effort contributes to reach logic programming features (e.g. goal solving) starting from a rewrite system. Hence, another natural continuation of our work is the definition of narrowing strategies in order to, not only compute normal forms, but also to solve goals over arbitrary data-structures.

References
S. Antoy, R. Echahed, and M. Hanus. A needed narrowing strategy. J. ACM, 47(4):776–822, 2000.
Z. M. Ariola and J. W. Klop.	Equational term graph rewriting.	Fundamentae Informaticae, 26(3/4):207–240, 1996.
A. Asperti and G. Longo. Categories, Types and Structures. An introduction to Category Theory for the working computer scientist. M.I.T. Press, 1991. http://www.di.ens.fr/users/longo/download.html.
F. Baader and T. Nipkow. Term rewriting and all that. Cambridge University Press, 1998.
A. Bakewell, D. Plump, and C. Runciman. Checking the shape safety of pointer manipulations. In
RelMiCS, pages 48–61, 2003.
A. Bakewell, D. Plump, and C. Runciman. Specifying pointer structures by graph reduction. In
AGTIVE, pages 30–44, 2003.
R. Banach. Term graph rewriting and garbage collection using opfibrations. Theoretical Computer Science, 131:29–94, 1994.
H. Barendregt, M. van Eekelen, J. Glauert, R. Kenneway, M. J. Plasmeijer, and M. Sleep. Term graph rewriting. In PARLE’87, pages 141–158. LNCS 259, 1987.

E. Barendsen and S. Smetsers. Graph rewriting aspects of functional programming. In H. Ehrig,
G. Engels, H. J. Kreowski, and G. Rozenberg, editors, Handbook of Graph Grammars and Computing by Graph Transformation, volume 2, pages 63–102. World Scientific, 1999.
C. Bertolissi, P. Baldan, H. Cirstea, and C. Kirchner. A rewriting calculus for cyclic higher-order term graphs. Electr. Notes Theor. Comput. Sci., 127(5):21–41, 2005.
R. V. Book and F. Otto. String-rewriting systems. Springer-Verlag, 1993.
A. Corradini and F. Gadducci. Rewriting on cyclic structures: Equivalence between the operational and the categorical description. ITA, 33(4/5):467–493, 1999.
A. Corradini, U. Montanari, F. Rossi, H. Ehrig, R. Heckel, and M. L¨owe. Algebraic approaches to graph transformation - part I: Basic concepts and double pushout approach. In Handbook of Graph Grammars, pages 163–246, 1997.
A. Corradini and F. Rossi. Hyperedge replacement jungle rewriting for term-rewriting systems and programming. Theor. Comput. Sci., 109(1&2):7–48, 1993.
D. J. Dougherty, P. Lescanne, L. Liquori, and F. Lang. Addressed term rewriting systems: Syntax, semantics, and pragmatics: Extended abstract. Electr. Notes Theor. Comput. Sci., 127(5):57–82, 2005.
D. Duval, R. Echahed, and F. Prost. Adjunction for garbage collection with application to graph rewriting, 2006. Submitted.
R. Echahed and J. C. Janodet. Admissible graph rewriting and narrowing. In Proc. of Joint International Conference and Symposium on Logic Programming (JICSLP’98), pages 325–340. MIT Press, June 1998.
H. Ehrig, G. Engels, H.-J. Kreowski, and G. Rozenberg, editors. Handbook of Graph Grammars and Computing by Graph Transformations, Volume 2: Applications, Languages and Tools. World Scientific, 1999.
H. Ehrig, H.-J. Kreowski, U. Montanari, and G. Rozenberg, editors. Handbook of Graph Grammars and Computing by Graph Transformations, Volume 3: Concurrency, Parallelism and Distribution. World Scientific, 1999.
C. Ermel, M. Rudolf, and G. Taentzer. The AGG approach: language and environment. In Handbook of graph grammars and computing by graph transformation: vol. 2: applications, languages, and tools, pages 551–603. World Scientific Publishing Co., Inc., 1999.
F. Gadducci, R. Heckel, and M. Llabr´es. A bi-categorical axiomatisation of concurent graph rewriting.
Electronic Notes in Theoretical Computer Science, 29, 1999.
J. R. W. Glauert, R. Kennaway, and M. R. Sleep. Dactl: An experimental graph rewriting language. In Graph-Grammars and Their Application to Computer Science, LNCS 532, pages 378–395, 1990.
A. Habel, H. J. Kreowski, and D. Plump. Jungle evaluation. Fundamenta Informaticae, 15(1):37–60, 1991.
A. Habel, J. Muller, and D. Plump. Double-pushout graph transformation revisited. Mathematical Structures in Computer Science, 11, 2001.
A. Habel and D. Plump. Computational completeness of programming languages based on graph transformation. In FoSSaCS LNCS 2030, pages 230–245, 2001.
J. R. Kennaway, J. K. Klop, M. R. Sleep, and F. J. D. Vries. On the adequacy of graph rewriting for simulating term rewriting. ACM Transactions on Programming Languages and Systems, 16(3):493– 523, 1994.
D. Plump. Term graph rewriting. In H. Ehrig, G. Engels, H. J. Kreowski, and G. Rozenberg, editors, Handbook of Graph Grammars and Computing by Graph Transformation, volume 2, pages 3–61. World Scientific, 1999.
D. Plump and S. Steinert. Towards graph programs for graph algorithms. In ICGT, LNCS 3256, pages 128–143, 2004.
P. Rodgers. A Graph Rewriting Programming Language for Graph Drawing. In Proceedings of the 14th IEEE Symposium on Visual Languages. IEEE, IEEE Computer Society Press, September 1998.
G. Rozenberg, editor. Handbook of Graph Grammars and Computing by Graph Transformations, Volume 1: Foundations. World Scientific, 1997.
A. Schu¨rr, A. J. Winter, and A. Zu¨ndorf. The PROGRES approach: language and environment. In Handbook of graph grammars and computing by graph transformation: vol. 2: applications, languages, and tools, pages 487–550. World Scientific Publishing Co., Inc., 1999.
J. R. Slagle. Automated theorem-proving for theories with simplifiers, commutativity, and associativity.
Journal of the ACM, 21(4):622–642, 1974.

A  Pushouts of graphs
Let Gr denote the category of graphs and Set the category of sets. The node functor N : Gr → Set maps each graph G to its set of nodes NG, and each graph homomorphism ϕ : G → H to its underlying map on nodes ϕ : NG → NH. As in the rest of the paper, this map is simply denoted ϕ, and this is not ambiguous: indeed, if two graph homomorphisms ϕ, ψ : G → H are such that their underlying maps are equal ϕ = ψ : NG → NH, then it follows directly from the definition of graph homomorphisms that ϕ = ψ : G → H. In categorical terms [3], this is expressed by the following result.
Proposition A.1 (Faithfulness) The functor N : Gr → Set is faithful.
It is worth noting that this property does not hold for the “usual” directed multigraphs, where the set of successors of a node is unordered.
It is well-known that the category Set has pushouts, which can be built as follows. For each span of sets:

ϕ1  N0 ¸¸ϕ2

  
,s 
¸¸z 

N1	N2

let ∼ denote the equivalence relation on the disjoint union N1 + N2 generated by:
ϕ1(n0) ∼ ϕ2(n0) for all n0 ∈ N0 ,

let N3 be the quotient N3 = (N1 + N2)/ ∼, and ψ : N1 + N2 → N3 the quotient map. Two nodes n, n' in N1 + N2 are called equivalent if n ∼ n'. For i ∈ {1, 2}, let ψi : Ni → N3 be made of the inclusion of Ni in N1 + N2 followed by ψ. Then, it is well-known that the following square of sets is a pushout, which will be called canonical :
ϕ1  N0 ¸¸ϕ2

  
,s
N1 ¸¸¸
¸¸z 
N2
   

ψ1  z ,ψs2 
N3
The next lemma will be used in the proofs of Theorem 4.6 and Corollary 4.7.
Lemma A.2 Let us consider a canonical pushout of sets:

ϕ1  N0 ¸¸ϕ2

  
,s
N1 ¸¸¸
¸¸z 
N2
   

ψ1  z ,ψs2 
N3

Let n, n' ∈ N1 + N2 be distinct equivalent nodes. From the deﬁnition of the equiva-

lence relation ∼, there is a chain of relations:


 ,p1 ,,
¸p2 , ...	... 
,pk c¸¸

,,	eee
,,,
¸¸¸z 

n = n,s 
z zje
1
nzz...  n
 ,s
k  1	nk = n

with length 2k for some k ≥ 1, where each pi is in N0, each ni in N1 + N2, and the mappings are either φ1 or φ2. Let us assume that this chain has minimal length, among similar chains from n to n'. Then:
all the pi’s are distinct;
two consecutive ni’s cannot be both in N1, nor both in N2, so that ni = φj(i)(pi)= 
φj(i)(pi+1) for each i, where j(i) is alternatively 1 and 2;
˜	˜
if N is a subset of N0 such that the restriction of φj(i) to N is injective, then pi

and pi+1
Proof.
˜
cannot be both in N.

If pi = pj for some i < j, the part of the chain between pi and pj can be dropped, giving rise to a shorter chain from n to n': hence all the pi’s are distinct. If ni−1 and ni are both in the same Nj (for j = 1 or 2), then ni−1 = φj(pi)= ni, and the part of the chain between ni−1 and ni can be dropped, giving rise to a shorter chain from n
to n': hence ni−1 and ni cannot be both in Nj. If ni = φ	(pi)= φ	(p	) with
j(i)  i+1

both pi and pi+1	˜
˜
j(i)
i	i+1,

in N and the restriction of ψ
in contradiction with the first point.
to N is injective, then p = p

In contrast with Set, the category Gr does not have pushouts. For instance, let us consider a span of graphs:

ϕ1  G0 ¸¸ϕ2
	¸¸z 
G1	G2
where G0, G1 and G2 are made of only one node: n0 in G0 is unlabeled, n1 : a1 in G1 and n2 : a2 in G2, where a1 and a2 are distinct constants. This span has no pushout, because there cannot be any commutative square of graphs based on it.
Theorem A.3 below states a sufficient condition for a commutative square of graphs to be a pushout, and Theorem A.5 states a sufficient condition for a span of graphs to have a pushout, together with a construction of this pushout.
In the following, when Gi occurs as an index, it is replaced by i.
Theorem A.3 (Pushout of graphs from pushout of sets) If a square Γ of the following form in the category of graphs:

ϕ1  G0 ¸¸ϕ2

  
,s
G1 ¸¸¸
¸¸z 
G2
   

ψ1  z ,ψs2 
G3

is such that:
Γ is a commutative square in Gr,
N (Γ) is a pushout in Set,
and each n ∈ N Ω is in ψi(N Ω) for i =1 or i = 2,
3	i
then Γ is a pushout in Gr.
Point (2) implies that each n ∈ N3 is the image of at least a node in G1 or in G2, and point (3) adds that, if n is labeled, then it is the image of at least a labeled node in G1 or in G2.
Proof. Let us consider a commutative square Γ' in Gr of the form:
ϕ1  G0 ¸¸ϕ2

 
,s 
G1 ¸¸¸
¸¸z 
G2
   

θ1  z ,θs2 
G4
Then N (Γ') is a commutative square in Set, and since N (Γ) is a pushout in Set, there is a unique map θ : N3 → N4 such that θ ◦ ψi = θi, for i = 1, 2.
ϕ1,,,,, N0 ¸¸¸¸¸ϕ¸2

,,,,
1 ¸¸¸¸θ¸1 ¸
¸¸¸¸z˛
ψ,2,,,, N2

¸¸¸	¸¸¸¸¸,¸,,,,,
ψ1 z _,,.,, ¸¸¸ z ,θs2 
θ
Let us now prove that θ actually is a graph homomorphism. According to Defini- tion 2.4, we have to prove that, for each labeled node n of G3, its image n' = θ(n) is a labeled node of G4, and that L4(n')= L3(n) and S4(n')= θ∗(S3(n)).
So, let n ∈ N Ω, and let n' = θ(n) ∈ N4. From our third assumption, without loss of generality, n = ψ1(n1) for some n1 ∈ N Ω. It follows that θ1(n1)= θ(ψ1(n1)) =

θ(n)= n':
1
'
n = ψ1(n1) and n

= θ1(n1) .

Since n1 is labeled and θ1 is a graph homomorphism, the node n' is labeled. Since ψ1 and θ1 are graph homomorphisms, L3(n) = L1(n1) and L4(n') =
L1(n1), thus L3(n)= L4(n'), as required for labels.
Since ψ1 and θ1 are graph homomorphisms, S3(n) = ψ∗(S1(n1)) and S4(n') = 

∗	∗	∗	∗
∗	1	'

θ1 (S1(n1)). So, θ (S3(n)) = θ (ψ1 (S1(n1))) = θ1 (S1(n1)= S4(n ), as required for
successors.
This proves that θ : G3 → G4 is a graph homomorphism. Then, from the faithfulness of the functor N (Proposition A.1), for i ∈ {1, 2}, the equality of the underlying maps θ ◦ ψi = θi : Ni → N4 is an equality of graph homomorphisms: θ ◦ ψi = θi : Gi → G4.
Now, let θ' : G3 → G4 be a graph homomorphism such that θ' ◦ ψi = θi for
i ∈ {1, 2}. Since N (Γ) is a pushout in Set, the underlying maps are equal: θ = θ' :

N3 → N4. Then, it follows from the faithfulness of the functor N that the graph homomorphisms are equal: θ = θ' : G3 → G4.
Definition A.4 (Strongly labeled span of graphs) Let us consider a span of graphs Σ:
ϕ1  G0 ¸¸ϕ2
	¸¸z 
G1	G2
and the canonical pushout of sets:

ϕ1  N0 ¸¸ϕ2

 
,s 
N1 ¸¸¸
¸¸z 
N2
   

ψ1  z ,ψs2 
N3
Then Σ is strongly labeled if for each n3 ∈ N3, i.e., each n3 ∈ (N1 + N2)/ ∼:
all the labeled nodes in the class n3 have the same label,
and all the labeled nodes in the class n3 have equivalent successors.
Theorem A.5 (Pushout of a strongly labeled span of graphs) A strongly la- beled span of graphs has a pushout:

ϕ	G0 ¸¸ϕ

1
 , s
G1 ¸¸¸
2
¸z 
G2
   

ψ1  z ,ψs2 
G3
which can be built as follows:
the underlying pushout of sets is the canonical pushout, so that N3 = (N1 +
N2)/ ∼,
Ω is made of the classes of N1 + N2 (modulo ∼) which contain at least one
labeled node,
for each n3 ∈ N Ω, the label of n3 is the label of any labeled node in the class n3,
for each n3 ∈ N Ω, the successors of n3 are the classes of the successors of any labeled node in the class n3.
Proof. It follows easily from Theorem A.3 that this square is a pushout of graphs.
Proof. [Theorem 4.6] Let us prove that the following span of graphs is strongly labeled:
K ¸¸

d 
,s 
¸r¸z%

D	R
Then, Theorem 4.6 derives easily from Theorem A.5.

Let n, n' ∈ N Ω + N Ω be distinct equivalent nodes. We have to prove that n
'	R	D
and n have the same label and that their successors are pairwise equivalent. Let

us consider a chain of relations:
 ,p1 ,,

¸p2 , ...	... 


,pk c¸¸

,,	eee
,,,
¸¸¸z 

n = n,s 
z zje
1
nzz...  n
,s 
k  1	nk = n

of minimal length 2k, with each pi in NK, each ni in ND or in NR, and mappings either d or r, so that lemma A.2 can be applied to this chain. In particular, since d = m + dE + dN with m : NL → NG, dE : NE → NE' , dN : NN → NN' , and dE, dN are bijections, and since pi /= pi+1, we get:
(A.1)	If i < k, it cannot happen that pi ∈ NE + NN and ni = d(pi).
If all the nodes in this chain are labeled, then, since d and r are graph homo- morphisms, all nodes in the chain have the same label and have pairwise equivalent successors, so that the result follows: n and n' have the same label.
We now prove that all the nodes in the chain are labeled, by contradiction. Let us assume that at least one node in the chain is unlabeled. Since r and d are graph homomorphisms, the first unlabeled node (starting from n) is some pi. Let us focus on such a situation, where ni−1 is labeled and pi is unlabeled:
 ,pic¸¸¸
n	, &	¸z 


So, pi ∈ N X = N X + NE + NN .
i−1	ni

K	L
(R.) Let ni−1 be a node of R, i.e., ni−1 ∈ N Ω. Then ni−1 = r(pi) and ni = d(pi).
X	X	R	Ω
If pi ∈ NL  then ni−1 ∈ NR , a contradiction to ni−1 ∈ NR . If pi ∈ NE + NN then
ni = d(pi) is unlabeled, so that i < k; from remark (A.1), this situation cannot occur.
(D.) Let ni−1 be a node of D, i.e., ni−1 ∈ N Ω, or equivalently ni−1 ∈ N Ω. Then
D	G
ni−1 = d(pi) and ni = r(pi). If pi ∈ NE + NN then ni−1 = d(pi) is unlabeled, a

contradiction to our assumption. If pi ∈ N X
then ni = r(pi) is unlabeled, so that
X

i < k; then pi+1 is an unlabeled node of D, which means that pi+1 ∈ NL +NE +NN .
If pi+1 ∈ N X , since the restriction of r to N X is injective, a contradiction follows
L	L
from lemma A.2. If pi+1 ∈ NE + NN then ni+1 = d(pi+1) is unlabeled, so that
i +1 < k; from remark (A.1), this situation cannot occur.
Finally, it has been proved that all the nodes in this chain are labeled, which concludes the proof.
Proof. [Corollary 4.7] Let n ∈ NH, we have to choose a representative ρ(n) of n. We know that there is either a node nD ∈ ND such that n = r'(nD), or a node nR ∈ NR such that n = m'(nR), or both. We use the notations from theorem 4.6 and its proof.
(Ω.) First, in order to prove that N Ω = (N Ω − m(N Ω)) + N Ω, let n ∈ N Ω.
H	G	L	R	H

(Ω, R.) If there is a node nR ∈ N Ω such that n = m'(nR), let us prove that it is

'	Ω	R
'	'	'

unique. Let nR ∈ NR be another node such that n = m (nR), then nR ∼ nR. Let
us consider a chain with minimal length 2k from nR to n' ; we know from the proof of theorem 4.6 that all the nodes in this chain are labeled. From lemma A.2, n0 and
n1 cannot be both in NR, so that n1 ∈ N Ω, subsequently k ≥ 2 and p1, p2 ∈ N Ω
L
with n1 = m(p1) = m(p2). Since m is injective on N Ω, from lemma A.2 this
cannot occur. So, we have proved that m'Ω : N Ω → N Ω is injective, and we define
R	H
ρ(n)= nR.
(Ω, G.) If there is no node nR ∈ N Ω such that n = m'(nR), then there is a node
nD ∈ N Ω (i.e., nD ∈ N Ω ) such that n = r'(nD). Let us prove that it is unique. Let
'	D	G

n	∈ N Ω be another node such that n = r'(n' ), then nD ∼ n'
. Let us consider a

D	G	'	D	D
chain with minimal length from nD to nD; we know from the proof of theorem 4.6
that all the nodes in this chain are labeled. From lemma A.2, n0 and n1 cannot
be both in ND, so that n1 ∈ N Ω, which contradicts our assumption: there is no
R	˜
node nR ∈ N Ω such that n = m'(nR). Let N Ω denote the subset of N Ω made of
R	G	G
the nodes which are not equivalent to any node in N Ω. We have proved that the
restriction of r'Ω : N Ω → N Ω to ˜Ω is injective, and we define ρ(n)= n .
D	H	NG	D
(Ω, L.) We still have to prove that ˜Ω = N Ω − m(N Ω), i.e., that a node
NG	G	L
nG ∈ N Ω is equivalent to a node nR ∈ N Ω if and only if there is node p ∈ N Ω
R	L
such that nG = m(p). Clearly, if p ∈ N Ω and nG = m(p), then nG ∼ r(p) with
r(p) ∈ N Ω. Now, let nG ∼ nR for some nG ∈ N Ω and nR ∈ N Ω. Let us consider
R	G	R
a chain with minimal length 2k from nR to nG; we know that all the nodes in this
chain are labeled. If k > 1 then n1 = d(p1) = d(p2) with p1, p2 ∈ N Ω; since the restriction of d to N Ω is injective, a contradiction follows from lemma A.2. Hence k = 1, which means the node p1 ∈ N Ω is such that nR = r(p1) and nG = m(p1).
This concludes the proof that N Ω = (N Ω − m(N Ω)) + N Ω.
G	L	R
(X .) Now, in order to prove that N X = N X + (N X − r(N X )), let n ∈ N X .
G	R	L	H
(X , G.) If there is a node nD ∈ ND such that n = r'(nD), then nD is unlabeled, i.e., nD ∈ NG + NE' + NN' .
– If nD ∈ N X , let us prove that it is unique. Let n'	∈ N X be another node

G	'	'
'	D	G

such that n = r (nD), then nD ∼ nD. Let us consider a chain with minimal
length 2k from nD to n' , with k ≥ 2 since both nD and n'	are in D. Then
X	D	X	X	X	D
p1 ∈ NL , and n1 = r(p1) ∈ NR  because r maps NL  to NR , and n1 = r(p2) with
p2 ∈ N X = N X + NE + NN . If p2 ∈ N X , since r is injective on N X , a contradiction
K	L	L	L
follows from lemma A.2. If p2 ∈ NE +NN then n2 = d(p2) ∈ NE' +NN' , it is different
'	X
from nD since NG is disjoint from NE' + NN' . So, 2 < k, and from remark (A.1)
this is impossible. So, we have proved that the restriction of r' : ND → NH to N X
is injective, and we define ρ(n)= nD.
X
– If nD ∈ NE' + NN' , let us prove that there is a node nR ∈ NR  such that
n = m'(nR). Let p ∈ NE + NN be such that nD = d(p), and nR ∈ NR such that
nR = r(p). Then n = r'(d(p)) = m'(r(p)). Since n is unlabeled, nR ∈ N X , as
required. This case is considered below.

(X , R.) It has been proved above that, for every n ∈ N X , if there is no node
X	'	H	X
nD ∈ NG such that n = r (nG), then there is a node nR ∈ NR such that n =
m'(nR).
Such a node nR cannot be in r(NL): otherwise, let p ∈ NL be such that nR = r(p), then n = m'(r(p)) = r'(d(p)) = r'(nG) where nG = d(p) ∈ N X . So, nR ∈ (N X −
R
r(nX )).
Let us prove that such a node nR is unique. Let n' ∈ (N X − r(N X )) be another

'	'	'
R	R	L

node such that n = m (nR), then nR ∼ nR. Let us consider a chain with minimal
length 2k from nR to n' , with k ≥ 2 since both nR and n' are in R. Then

R
nR = r(p1) with p1 ∈ N X
= N X + NE + NN . If p1 ∈ N X
R	X
then nR ∈ r(N  ), in

K	L	L	L
contradiction with our assumption. If p1 ∈ NE + NN then n1 = d(p1) and 1 < k,
which is impossible from remark (A.1).
So, we have proved that the restriction of m' : NR → NH to N X − r(N X ) is
R	L
injective, and we define ρ(n)= nR.
This concludes the proof that N X = N X + (N X − r(N X )).
G	R	L
