Electronic Notes in Theoretical Computer Science 182 (2007) 17–32	
www.elsevier.com/locate/entcs

Dependency Management in Software Component Deployment
Meriem Belguidoum1 and Fabien Dagnat2
Department of Computer Sciences ENST Bretagne, Technopole Brest-Iroise Brest, France

Abstract
Component-based distributed systems are hard to deploy for two main reasons: the complexity of their struc- ture and the complexity of the deployment tasks. Current tools do not manage these complexities properly because the descriptions that they allow lack of expressiveness. The absence of proper descriptions of system and component requirements makes it impossible to ensure safe installation and deinstallation. The goal of this paper is to present a formalization of deployment dependencies. These dependencies expressed in a logical language are associated with a deployment engine that allows installation and deinstallation of components in a system to be proved.
Keywords: Component deployment, Deployment dependencies, Safe deployment.


Introduction
The component approach to building systems is gaining audience because of the in- teresting properties of components. We can imagine that software will soon be very large collections of components and that the reuse and sharing of components will be common practice. However, components are often developed by different groups and their dependencies are not clearly specified. Hence installing (or deinstalling) a component is often a gamble since all the dependencies are difficult to find. Using current approaches, installation may not achieve success [15] (an installed compo- nent does not work) and installation or deinstallation may not be safe and disrupt the system. To face the evolution towards component based systems, our aim is to build a tool with formal foundations ensuring the success and safety of deployment.
In this paper, we present the formalization of a static deployment system that ensures the success and safety of installation and deinstallation. What is meant by

1 Email: meriem.belguidoum@enst-bretagne.fr
2 Email: fabien.dagnat@enst-bretagne.fr

1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2006.09.029

static is that we do not address the dynamic reconfiguration of the interconnection in the system yet. The work presented here does not take into account the concrete realization of the deployment operations. We only present a reasoning framework to authorize or forbid deployment. Furthermore, our work is based on the fact that components come with an exact 3 description of their requirements and effect on the system.
The central concept is the notion of dependency that abstracts the link between component and hardware requirements. Dependencies are used during installation to ensure the requirements are fulfilled and during deinstallation to guarantee that they still be fulfilled. This paper defines dependencies, how they are specified and describes how to properly manage them during installation and deinstallation.
This paper is organized as follows. First, section 2 introduces the concept of component deployment and illustrates deployment dependencies using the example of a mail server. Next, section 3 presents our description of dependency deployment and section 4 the description of environmental constraints. Then, in section 5 and section 6 we present a formalization of the installation and deinstallation of components and the management of their effect on the target system respectively. Finally, we discuss related work in section 7 and conclude this article by presenting some future work in section 8.

Component deployment
In this paper, we use a basic abstract notion of component. A component pro- vides services that require services. Components and services are identified by their names. A required service is specified giving its name (and possibly the name of its provider). This work can be applied to any component model supporting named services and components and the notions of required and provided services.
Notice that using names to specify requirements would require to have some component and service dictionnary. In an open setting this requirement can be a limitation but is already used in practice by the packaging systems of Linux. To overcome this limitation, work is needed to enable the use of other form of identity for services and components (such as, for example, interface types for services).
A component software is a set of interconnected components. This intercon- nection is the software architecture and is often designed using an Architecture Description Language (ADL) such as Fractal ADL [3] or xADL [10]. Fig. 1 illus- trates such an architecture for a mail server on a Linux system. It is composed
of four components: Postﬁx, an SMTP server playing the role of a Mail Transport
Agent (MTA), Fetchmail that allows to recover mail by an electronic mail transport protocol (e.g., Pop) from a distant host (the messages are redirected to the local transport), Procmail, a Mail Deliver Agent (MDA) that manages received mails and allows, for example, the filtering of a mail. Finally, Sylpheed, a mail manager for reading and composing mail called a Mail User Agent (MUA).

3 This means that the component does not hide requirements or effects.


MTA	MDA	MUA	AV	AntiSpam
Fig. 1. Assembly of the components relating to the mail server


The installation/deinstallation of a component in/from a system corresponds to its addition/removal to/from the system. The success of these actions requires that:
The system provides the resources and the services required by the component (being installed).
The component (being installed) or one of its services do not conflict with already installed services.
The services provided by the component (being deinstalled) are not used by other components in the system.
To answer these questions, we need (1) the resources of the target system (2) its architecture and (3) the component description.
The resources are here abstracted by a set of environment variables. We suppose
that a standard choice of names and valuations for the resource description (for example the Management Information Format [5]) is made. The values are obtained by sensors and therefore will not be modified by our rules.
The architecture of the system memorizes the interconnection between all com-
ponents in the system. Such a complete explicit architecture (if it exists) would be unmanageable because of its size. Furthermore, constructing it can be very difficult as dependencies are often partly hidden. Therefore, rather than supervising all the
installation and deinstallation scripts, we advocate the use of an approximation of the inter-dependencies between components. This approximation is discussed in greater detail in section 4.
The description of a component must be sufficiently precise to express the links of a provided service to its requirements. This gray-box description specifies intra- dependencies which are parametrized contracts [17], that is, outputs (provided ser- vices) are linked to the entries (required services) they depend on. The form of these links is defined in the next section.

Dependency specification
In this section, we present the precise definition of the relation between a required and a provided service (either of the same component or of two components). Such a relation is called a dependency. The mail server example already introduced illustrates dependencies in Fig. 1 4 . There is three main forms of dependencies, a dependency is either mandatory, optional or negative:
a mandatory dependency (represented by a solid line) is a firm requirement. If it is not fulfilled installation is not possible. For example, the mail server needs a terminal with a specific CPU or specific libraries, etc.
an optional dependency (represented by a dotted line) specifies that the compo- nent may provide optional services. Such services may not be provided (if their requirements are not fulfilled) without preventing the installation. For example, postfix may provide a service for scanning messages against viruses if the service Amavis is available. Otherwise postfix can be installed and provides the MTA service, but the service AV is not provided.
a negative dependency (expressed by a negation) specifies a conflict forbidding installation. The conflict may hold with a service or a component. For example, postfix cannot be installed if another MTA is already installed (such as sendmail for example).
The (intra-)dependency description language 5 uses the concepts of dependency and predicate defined by the following grammar where s represents the name of a service and c the name of a component:
D ::= P ⇒ s | D • D | D # D | ? D	P ::= true | P ∧ P | Q
Q ::= Q ∨ Q | R        R ::= [v O val ] | ¬ s | ¬ c | c.s | s        O ::=> |≥| < |≤| = | =/

The precise semantics of these operators will be defined by the installability and installation rules (resp. Fig. 4 and Fig. 6). Intuitively, a dependency may be the conjunction • or the disjunction  of two dependencies, an optional dependency
? or a simple dependency P ⇒ s specifying the requirements P of a service s. The requirements are expressed in a first order predicate language in conjunctive normal form to simplify the installation rules. The five raw conditions (R) express
a comparison on the value of an environment variable [v O val ], a conflict with a
service ¬ s or a component ¬ c or the requirement of a service provided by a precise component c.s or any component s. Examples of such predicates appear in Fig. 1 on the required interfaces (left hand side).
It is important to notice that a component may forbid a service it provides. This feature can be used by a component providing s to forbid the (future) installation of any other component providing s (¬ s ⇒ s).

4 The dependencies are simplified compared to the real case.
5 A more human friendly language exists but is not in the scope of this paper.


AMAVIS.amavis


POSTFIX.av	SANITIZER.sanitizer  PROCMAIL.av


SPAM.spamassassin


PROCMAIL.spamassassin




C1.lib

FETCHMAIL.popclient

SYLPHEED.MUA

SYLPHEED.Corrector



POSTFIX.MTA



PROCMAIL.MDA


C2.lib

C3.lib	C4.lib

SPELL.spelldictionnary


Fig. 2. Dependency graph of the mail server of Fig. 1
Context description
The resources and the architecture of the target system are modeled by the notion of context. Ideally, it could be the union of the dependencies of all components (part of the system). But, the calculation (and the manipulation) of this union is not realistic. Thus, a safe approximation (of this union) is needed. To ensure safe installation, we have to know the available services (with their providers) and installed components to check services’ requirements and conflicts. We also need the values of the environment variables. For safe deinstallation, we need to keep all potential dependencies between services.
In this paper, the Context is composed of (1) an environment E storing the val- ues of variables, (2) a set C of four-tuples (c, Ps, Fs, Fc) storing for each installed component c its provided services Ps, forbidden services Fs and forbidden compo- nents Fc and (3) a dependency graph G storing the dependencies. A node of G is an available service and its provider (c.s) and an edge is a pair of nodes n1 −→ n2
meaning that n2 requires n1. Each edge is labeled (above the arrow) by the kind of dependency, either mandatory M or optional O. Fig. 2 presents the dependency graph of the mail server of Fig. 1. A dependency graph is defined by the set of its
labeled edges. It is built during installation and used during deinstallation. This means that an edge n1 −→ n2 in G denotes that n2 is available and requires n1. It implies that n1 was available before n2, that is the graph does not contain cycles. In practice this can be a limitation because two components may be mutually de- pendent. We think that such circularity should be solved 6 by building composite components that hides this circularity to the system. This composition operation is not yet available and left for future work.
To simplify the presentation of our rules, let us define available / forbidden services and components 7 :
⎧⎪ AS (Ctx) =  {Ps | (−, Ps, −, −) ∈ Ctx.C}
⎪⎨ AC (Ctx) = {c | (c, −, −, −) ∈ Ctx.C}
FS (Ctx) =  {Fs | (−, −, Fs, −) ∈ Ctx.C}
⎪⎩ FC (Ctx) =  {Fc | (−, −, −, Fc) ∈ Ctx.C}

6 Indeed, it introduces a high coupling forbidding the separate installation or deinstallation.
7 A dotted notation is adopted in this paper to access a specific member of a tuple directly and − is used as a joker matching anything.






Effect







Fig. 3. Installation phases

Safe installation
In our approach, abstract installation is carried out in two stages (see Fig. 3). First we check whether installation is possible (installability ) by evaluating the component dependency in the current context. Then if installation is possible, we calculate its effect on the context. This effect is used to update the abstract context once the concrete installation has been carried out.


Installability
Before authorizing the installation of a component, we have to ensure (1) it is not forbidden, (2) the services it requires are available in the context and (3) it does not provide forbidden services. More formally:
Definition 5.1 (Installability) A component c with a dependency D is installable within a context Ctx (Ctx ▶ c : D) iff the component is not forbidden and D is verified by the checking rules of Fig. 4:



CComp:
Ctx ▶C D	c ∈/ FC (Ctx)


Ctx ▶ c : D


The checking rules of Fig. 4 ensure that mandatory dependencies of the com- ponent are verified. For a simple dependency P ⇒ s, this means that P evaluates to true and s is not forbidden (CTriv). The evaluation of a predicate P in the con- text Ctx follows classical logic and is presented in the first part of the figure (rules Ctx ▶P P ). During this stage, optional dependencies are ignored (COpt) because such dependencies may be unavailable without preventing component installation. The conjunction of dependencies is resolved when the two dependencies are valid (CAnd) and their disjunction when one of the two dependencies is valid (COrL and
COrR).

Predicates:
Ctx ▶P Q1	Ctx ▶P Q2




POrL:
PTrue: Ctx ▶P true
Ctx ▶P R1





POrR:
PAnd:

Ctx ▶P R2
Ctx ▶P Q1 ∧ Q2
Ctx.E (v) O V 
PVar:


Ctx ▶P R1 ∨ R2
s ∈/ AS (Ctx)
PNotS:
Ctx ▶P ¬ s
Ctx ▶P R1 ∨ R2
c ∈/ AC (Ctx)
PNotC:
Ctx ▶P ¬ c




PServ:
Ctx ▶P [v O V ]
s ∈ AS (Ctx)


Ctx ▶P s




PComp:
(c, Ps, −, −) ∈ Ctx.C	s ∈ Ps


Ctx ▶P c.s

Dependencies:




CTriv:
Ctx ▶P P	s ∈/ FS (Ctx)


Ctx ▶C P ⇒ s

CAnd:
Ctx ▶C D1	Ctx ▶C D2 Ctx ▶C D1 • D2




COpt: Ctx ▶C ? D

COrL:
Ctx ▶C D1


Ctx ▶C D1 # D2

COrR:
Ctx ▶C D2


Ctx ▶C D1 # D2




Installation
Fig. 4. Installability rules

Once the component is proved to be installable, we need to calculate the effect of its installation on the system. This effect consists of new available services, new forbidden services, new forbidden components and a new dependencies (represented by a dependency graph). Before giving the installation rules, we will show how this effect is calculated by defining two operations: CalcF that determines forbidden services and components and the dependency graph calculation.
First, the services and components forbidden by a component are calculated by collecting negatives of the predicates of its dependency. This is done by the function CalcF defined below.
The only case that deserve discussion is the disjunction. Indeed, several sub- terms of a disjunction may forbid services (or components). For example, in the dependency expression ¬a ∨ ¬b ⇒ S, a or b could be forbidden. To keep track of this possibilities a complex system can be built that will record which negatives are (really) needed. Here if a is available (resp. b) we could keep ¬ b (resp. ¬ a) and while none of them is available we keep the disjunction. We have chosen to present here a simpler system because we think that the benefit in terms of precision is not worth its cost. That is all services and components with negative predicates in a disjunction are forbidden (the set of forbidden services in the case of disjunction are the same as in that of conjunction).


GTrue: Ctx, c, s ▶G true ⇒ ∅



GAnd:
Ctx, c, s ▶G Q1 ⇒ G1	Ctx, c, s ▶G Q2 ⇒ G2


Ctx, c, s ▶G Q1 ∧ Q2 ⇒ G1 ∪ G2




GOr:
Ctx, c, s ▶G R1 ⇒ G1	Ctx, c, s ▶G R2 ⇒ G2


Ctx, c, s ▶G R1 ∨ R2 ⇒ G1 ∪ G2



GVar: Ctx, c, s ▶G [v O V ] ⇒ ∅

GServC:
GNotS: Ctx, c, s ▶G ¬ s' ⇒ ∅

(c', Ps, −, −) ∈ Ctx.C	s' ∈ Ps



GNotC: Ctx, c, s ▶G ¬ c' ⇒ ∅
'  '	'  ' M
G




GServ:
s' ∈ AS (Ctx)

'	'  ' M	'	'

Ctx, c, s ▶G s ⇒ {c .s −→ c.s | (c , Ps, −, −) ∈ Ctx.C∧ s
∈ Ps}



Fig. 5. Graph calculation rules
Definition 5.2 (CalcF) The function CalcF calculates the set of forbidden ser- vices and the set of forbidden components from a predicate:
⎧⎪ CalcF (true) = ∅, ∅

s	s	c	c	s	c
⎪
⎪⎨ CalcF (R1 ∨ R2) = F1 ∪ F2, F1 ∪ F2 where CalcF (Ri) = Fi, Fi
⎪ CalcF (s) = CalcF (c.s) = CalcF ([v O V ]) = ∅, ∅
⎪⎪⎩ CalcF (¬ c) = ∅, {c}

The dependency graph is built during the installation phase using the context and the service provided by the component being installed. For this, the dependency graph collects all dependencies added by the component.
Definition 5.3 (Graph calculation) The dependency graph G introduced by a component c when providing a service s in the context Ctx is calculated from its predicate P (Ctx, c, s ▶G P ⇒ G) by the rules of Fig. 5.
The only rules causing new dependencies are those specifying service require- ments. The rule GServ adds a dependency between each potential provider of a service and the service requiring it. The rule GServC ensures that c' provides s' and produces the corresponding dependency.
Lastly, the installation is defined by:




ITriv:
Ctx, c, s ▶G P ⇒G	s ∈/ FS (Ctx)	CalcF (P ) = Fs, Fc


Ctx, c ▶I (P ⇒ s) ⇒ {s}, Fs, Fc, G




INot1:
Ctx ▶P  P


Ctx, c ▶I (P ⇒ s) ⇒⊥ 

INot2:
s ∈ FS (Ctx)


Ctx, c ▶I (P ⇒ s) ⇒⊥ 




IOpt1:
Ctx, c ▶I D ⇒⊥ 


Ctx, c ▶I ? D ⇒ ∅, ∅, ∅, ∅


Ctx, c ▶I D ⇒ Ps, Fs, Fc, G

IOpt2:
D ⇒ P , F , F , {s −→ s' | s −−→ s'
∈ G}




IAnd1:
Ctx, c ▶I D1 ⇒⊥ 


Ctx, c ▶I D1 • D2 ⇒⊥ 

IAnd2:
Ctx, c ▶I D2 ⇒⊥ 


Ctx, c ▶I D1 • D2 ⇒⊥ 

Ctx, c ▶I D1 ⇒ P1, F1, F1, G1	Ctx, c ▶I D2 ⇒ P2, F2, F2, G2
s	s	c	s	s	c

IAnd3:
Ctx, c ▶
D  • D  ⇒ P1 ∪ P2, F1 ∪ F2, F1 ∪ F2, G ∪G 

I	1	2
s	s	s	s	c
c	1	2

IOrL:
Ctx, c ▶I D1 ⇒ Ps, Fs, Fc, G
Ctx, c ▶I D1 # D2 ⇒ Ps, Fc, Fs, G

IOrR:
Ctx, c ▶I D1 ⇒⊥	Ctx, c ▶I D2 ⇒ Ps, Fs, Fc, G


Ctx, c ▶I D1 # D2 ⇒ Ps, Fs, Fc, G

Fig. 6. Installation rules

Definition 5.4 (Installation) The installation of a component c with a depen- dency D in a context Ctx has four effects: provided services Ps, forbidden services Fs, forbidden components Fc and dependencies (graph G). These effects are ob- tained by the rules of Fig. 6.



IComp:
Ctx, c ▶I D ⇒ Ps, Fs, Fc, G


Ctx ▶I c : D ⇒ Ps, Fs, Fc, G


The effect of P ⇒ s is undefined if either P is false (INot1) or s is forbidden (INot2). Otherwise, s is available, forbidden services and components are calculated by CalcF and the graph by the rules of Fig. 5 (ITriv). An optional dependency ? D has almost the same effect as D if it is defined (IOpt1), and the dependencies of D are converted to optional. Otherwise it has no effect (IOpt2). In a conjunction D1 • D2, D1 and D2 must be valid and then the effect is the union of their effects (IAnd3).
Otherwise it is undefined (IAnd1 and IAnd2).  Lastly, the effect of a disjunction
D1 # D2 is that of D1 (IOrL) if D1 is verified, or that of D2 (IOrR) in the opposite

case. Notice that the disjunction has the semantics of an if, the second dependency is used only if the first is not verified.
In this paper, we consider that our formal reasoning engine does not take care of updating environment variables. A concrete deployment engine updates the physical context and sensors bring it to the formal engine.

An example of installation
Let’s illustrate the installation of the component postfix whose dependency is ([FDS ≥ 1380] ∧ ¬CSM ∧ Slib ⇒ SMT A) • ?(SAmavis ⇒ SAV ) in a system having the description {(FDS = 500000)}, {(C1, Slib, ∅, ∅), (C2, SAmavis, ∅, ∅)}, ∅.
The installability of postfix is deduced by the proof presented in the first part of Fig. 7. This proof ensures that libraries are present, sendmail is not present, the free disk size (FDS) is bigger than the required one and the provided service SMT A is not forbidden. Note that as the requirement for SAmavis is optional, it is not explored.
As postfix is installable, the installation stage follows and calculates the effect of installing postfix (CPX ) by the proof in the second part of Fig. 7 (the require-
ment predicate of SMT A is denoted P ). During this phase, the optional dependency is checked to determine whether it provides services (here it contributes the SAV ser- vice). After the installation of postfix, the MTA service (SMT A) and the anti-virus (SAV ) are provided and the component sendmail (CSM ) becomes forbidden. The dependency graph G corresponds to the union of the dependency graphs deduced

from the two sub-dependencies, that is G = {C2.SAmavis  O
PX .SAV , C1.Slib  M

CPX .SMT A}. Therefore, after the installation of postfix the context becomes:
⎧
⎪⎨ {(C1, Slib, ∅, ∅), (C2, SAmavis, ∅, ∅), (CPX , {SMT A, SAV }, ∅, {CSM })},
⎪⎪⎩ {C2.SAmavis O	PX .SAV , C1.Slib M	PX .SMTA}

Safe deinstallation
Deinstallation of a component c is also carried out in two stages. First, we check its feasibility by ensuring (using the dependency graph) that no service provided by c is required by another component. Then, we calculate the effect of deinstallation, that is, the removal of c from the context and of edges relating to the services that c provides in the dependency graph.
To manage deinstallation, we use the dependency graph built during installa- tion. A component can be removed, if none of its provided services are used by other components. Therefore, for each provided service, we have to check that no (mandatory) service of another component requires it. Thus, a service can be re- moved if either it is not used (i.e., it is a leaf of the dependency graph) or it is only

Installability:
500000 ≥ 1380


Ctx ▶P FDS ≥ 1380


CSM ∈/ {C1, C2}


Ctx ▶P ¬CSM



Slib ∈ {Slib, SAmavis} Ctx ▶P Slib


Ctx ▶P [FDS ≥ 1380] ∧ ¬CSM ∧ Slib SMT A ∈/ ∅
Ctx ▶C [FDS ≥ 1380] ∧ ¬CSM ∧ Slib ⇒ SMT A
Ctx ▶C ?(SAmavis ⇒ SAV )
Ctx ▶C ([FDS ≥ 1380] ∧ ¬CSM ∧ Slib ⇒ SMT A) • ?(SAmavis ⇒ SAV )
Installation:


Slib ∈ {Slib, SAmavis} Ctx, CPX , SMTA ▶G Slib ⇒ {C1.Slib M


PX .SMTA}

Ctx, CPX , SMT A ▶G ¬CSM ⇒ ∅	Ctx, CPX , SMT A ▶G [FDS ≥ 1380] ⇒ ∅

Ctx, CPX , SMT A ▶G P ⇒ {C1.Slib M
PX .SMTA}

SMT A ∈/ ∅	CalcF (P ) = ∅, {CSM }
Ctx, CPX ▶I (P ⇒ SMT A) ⇒ {SMT A}, ∅, {CSM }, {C1.Slib M


PX .SMTA}



SAmavis ∈ {Slib, SAmavis}
Ctx, CPX , SAV ▶G SAmavis ⇒ {C2.SAmavis M


PX .SAV }

SAV
∈/ ∅	CalcF (SAmavis) = ∅, ∅

Ctx, CPX ▶I (SAmavis ⇒ SAV ) ⇒ {SAV }, ∅, ∅, {C2.SAmavis M
Ctx, CPX ▶I ?(SAmavis ⇒ SAV ) ⇒ {SAV }, ∅, ∅, {C2.SAmavis O
PX .SAV }
PX .SAV }

−→ C
Ctx, CPX ▶I (P ⇒ SMT A) • ?(SAmavis ⇒ SAV ) ⇒ {SMT A, SAV }, ∅, {CSM }, G

Fig. 7. Installability and Installation proofs of postfix

required (directly or indirectly) by optional services (in the graph, all paths coming from it must be composed of green arcs).
Definition 6.1 (Mandatory dependencies (MD)) The set of mandatory de- pendencies (MD) of a service s provided by a component c in a dependency graph is defined as follows:

MD (G, c.s) =  {{c'.s'}∪ MD (G, c'.s')

M	'  '

Definition 6.2 (Deinstallability) A component c can be removed from a context
Ctx iff all its provided services has no mandatory dependencies:

(c, Ps, −, −) ∈ Ctx.C	  {MD (G, c.s) | s ∈ Ps} = ∅

Check-DI:
Ctx ▶D c

LDAP
Fig. 8. An example of a dependency graph

The effect of the deinstallation of a component c on a context Ctx involves the set of nodes that must be removed from the dependency graph. This set of nodes contains all provided services of c and all (optional) services depending on them. Once the concrete deinstallation is carried out, Ctx will be updated by removing c (and its provided services, forbidden services and forbidden components) from C and removing 8 from G all nodes of the effect.
Definition 6.3 (Optional dependencies (OD)) The set of optional dependen- cies (OD) of a service s provided by a component c in a dependency graph is defined as follows:

OD (G, c.s) =  {{c'.s'}∪ OD (G, c'.s')

O	'  '

Definition 6.4 (Deinstallation) The deinstallation of a component c has the following effect:



Effect:

Ctx ▶E c ⇒
(c, Ps, −, −) ∈ Ctx.C
  {{c.s}∪ OD (Ctx.G, c.s) | s ∈ Ps}


Let us illustrate the deinstallation of components having optional dependencies via an example. Suppose we want to have a subversion server SVN using LDAP authentication through Apache and Perl. The component LDAP-Perl allows the authentication of the user, based on the attributes of the component LDAP. These components must be installed in a precise order (see Fig. 8). First, LDAP and Perl are installed to enable the installation of the component LDAP-Perl. This component provides the service SLDAP−Perl optionally used by APACHE to provide an authentication service SWebAuthLDAP . Finally, SVN can use this service to provide its own authentication service SSVNAuthLDAP .
Let us examine the deinstallation of the component LDAP-Perl and thus the removal of the service SLDAP−Perl . According to the deinstallability definition 6.2, we need to determine MD .  On the left hand side of Fig. 9, we can see that in

8	−	−
G \ N = {n1 −−→ n2 | n1 −−→ n2 ∈ G ∧ n1 ∈/ N ∧ n2 ∈/ N}



G



PERL.perl	PERL.perl

Fig. 9. Before and after removing LDAP-Perl

the dependency graph, all paths depending on this service have optional arcs. In- deed, this service is only used (optionally) by APACHE and then SVN. So, MD is empty and Perl-LDAP can be deinstalled. According to definition 6.4, to remove SLDAP−Perl , we must remove all nodes depending on it. The calculus of OD gives
{SWebAuthLDAP , SSVNAuthLDAP }. Thus, these services are removed while the compo- nents APACHE and SVN remain installed. The resulting dependency graph is shown on the right hand side of Fig 9).

Related work
A lot of research focuses on the description and the management of component-based systems. Deployment tools such as COACH [9] and deployment specifications such as of the OMG [13] do not support the description of deployment dependency. The constraint one may express in those framework is limited to constraints on the target environment.
In architecture description languages (ADL) [12,6], descriptions focus on the structural view and concentrate on a high level logical view of components without taking into account the physical view (real effect on physical environment). Behav- ioral ADL exists such as π-ADL [14] but do not address the problem of deployment. To our knowledge, [8] is the only work extending an ADL to specify deployment con- straints. Their approach is to describe constraints on the location of components. These constraints enable to describe requirements on hardware, simple software de- pendencies and co-location. However, ignoring the problem of deinstallation they do not have to handle software dependencies. Our work aims to encompass both the logical and physical views in descriptions offering of an expressive language for the deployment constraints specifications. For this, we follow [17] using parametrized conditions to specify dependencies (i.e., the provided services differ according to available services). In Reussner paper, this approach is limited to the specification of quality attributes.
In [11] an architecture for the representation and the management of depen- dencies in component systems is proposed. This representation is used for compo- nent implementation, which are configured and adapted automatically to dynamic changes in the environment. In this work, dependency descriptions are assumed to be already present and consistent, while in our approach, we aim to prove the consistency of the specifications.

Lastly, little work examine safety of deployment. The EDOS project aims to manage dependencies among large collections of software packages. They build a formal system [16] to check installability. In their context, installability is a lot harder than our, because if the system does not allow a component to be installed they try to determine which minimal set of packages is necessary to enable the installation. They prove that this problem is NP-complete but show that this is not a problem in practice. Another work presented in [18] deals with the problem of software configuration management. It formalizes the package system of Debian by defining a rule-based formal language for representation of configuration knowledge. Each rule (expressing a requirement) is translated to a logic program using the stable model semantics [7]. This work focuses on this particular form of semantics rather than the management of complex dependencies.
The two last works are related to the management of software packages of the Debian linux distribution. The main difference between packages and components is the fact that a package only provide one service 9 . Furthermore a component may provide a variable number of services depending on the context. A much richer dependency language is required to take into account these two differences. This paper introduces such a language with rules to ensure the safety of installation and deinstallation.

Conclusion and future work
In this paper, a formalization of installation and deinstallation of components has been presented. It aims at providing a safe deployment framework that guarantee the success of installation and deinstallation. The key concept to offer this safety is the notion of dependency. A dependency abstract a components connection, it is mandatory or optional, positive (required) or negative (forbidden). The descrip- tion and the management of these dependencies encompass our previous work [2,1] by extending the syntax of requirements (allowing the provider specification) and introducing the notion of dependency graph. All potential dependencies are ap- proximated by this dependency graph (built during installation) in order to ensure safe deinstallation. A simple prototype associated to a prover has been developed in OCaml. This proof of concept prototype is currently used to test our approach on the deployment of Fractal components [4].
We are working on two main directions. First, our objective is to ensure the guarantee of the deployment. For this, a formalization of the properties a deployment system should respect (success, safety, . . . ) is needed. The goal is then to prove that our system ensure these properties. The second direction is to extends our system to overcome its current limitations. The two main limitations are:
the deployment operations offered, a replace and an assembly operation are needed. The replace operation is needed to allow the upgrade of a component. Indeed as our system does not allow to deinstall a component providing ser-

9 The notion of virtual package has not the same expressive power as real services.

vices used by other components, upgrading a component is not equivalent to a deinstallation and then an installation. The assembly operation is needed to cal- culate the dependency of a composite component using the dependencies of its sub-components.
the component and the service identities, in our current approach names hold a central position that they should not have. The identity of a service must be extended to include interface type and version information. This means to change from name equality to a form of subtyping when determining dependencies between services.

References
Belguidoum, M. and F. Dagnat, Analysis of deployment dependencies in software components, in: SAC ’06: Proceedings of the 2006 ACM symposium on Applied computing (2006).
Belguidoum, M., F. Dagnat and A. Beugnard, Analyse des d´ependances pour le d´eploiement automatique de composants, in: Journ´ees Composants 2005, Le Croisic, France, 2005, pp. 57–68.
Bruneton, E., Developing with Fractal, France Telecom R&D (2004).
URL fractal.objectweb.org/

Bruneton., E., T. Coupaye and J. Stefani, Fractal Component Model Draft 2.0-2, France Telecom R&D INRIA (2003).
URL fractal.objectweb.org/

Distributed Management Task Force, Common Information Model (CIM), CIM Infrastructure Specification, DMTF (2005).
URL www.dmtf.org/standards/cim

Garlan, D., R. T. Monroe and D. Wile, Acme: Architectural description of component-based systems, in: G. T. Leavens and M. Sitaraman, editors, Foundations of Component-Based Systems, Cambridge University Press, New York, 2000 pp. 47–67.
Gelfond, M. and V. Lifschitz, The stable model semantics for logic programming, in: Proceedings of the 5th International Conference on Logic Programming (1988), pp. 1070–1080.
URL homepages.inf.ed.ac.uk/dcspaul/publications/ggf12.pdf

Hoareau, D. and Y. Mah o, Constraint-Based Deployment of Distributed Components in a Dynamic Network, in: Architecture of Computing Systems (ARCS 2006), LNCS (2006).
Hoffmann A. et al., Specification of the deployment and configuration, Deliverable D2.4, IST COACH Project (2003).
Khare, R., M. Guntersdorfer, P. Oreizy, N. Medvidovic and R. Taylor, xADL: Enabling Architecture- Centric Tool Integration with XML, in: Proc. of the 34th Hawaii International Conference on System Sciences, Volume 9 (2001), p. 9053.
Kon, F., “Automatic Configuration of Component-Based Distributed Systems,” Phd thesis, Department of Computer Science, University of Illinois at Urbana-Champaign (2000).
Medvidovic, N. and R. N. Taylor, A classification and comparison framework for software architecture description languages, Software Engineering 26 (2000), pp. 70–93.
URL citeseer.ist.psu.edu/medvidovic97classification.html

OMG, Deployment and Configuration of Component-based Distributed Applications, Specification version 4, OMG (2006).
URL  www.omg.org/cgi-bin/doc?formal/06-04-02

Oquendo, F., π-ADL: an architecture description language based on the higher-order typed π-calculus for specifying dynamic and mobile software architectures, SIGSOFT Softw. Eng. Notes 29 (2004),
pp. 1–14.
Parrish, A. S., B. Dixon and D. Cordes, A conceptual foundation for component-based software deployment., Journal of Systems and Software 57 (2001), pp. 193–200.

R. Di Cosmo, Report on Formal Management of Software Dependencies, Delivrable WP2-D2.2, EDOS Project (2006).
Reussner, R., I. Poernomo and H. Schmidt, Contracts and quality attributes for software components, in: W. Weck, J. Bosch and C. Szyperski, editors, Proc. 8th Int’l Workshop on Component-Oriented Programming (WCOP’03), 2003.
URL citeseer.ist.psu.edu/703313.html

Syrj¨anen, T., A rule-based formal model for software configuration, Research Report A55, Helsinki University of Technology, Laboratory for Theoretical Computer Science, Espoo, Finland (1999).
