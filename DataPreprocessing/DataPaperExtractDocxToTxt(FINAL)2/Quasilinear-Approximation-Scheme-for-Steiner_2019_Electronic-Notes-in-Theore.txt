Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 346 (2019) 589–601
www.elsevier.com/locate/entcs

Quasilinear Approximation Scheme for Steiner Multi Cycle in the Euclidean plane 1,2
Carla N. Lintzmayer
Center for Mathematics, Computing and Cognition. Federal University of ABC. Santo Andr´e, S˜ao Paulo, Brazil
Fl´avio K. Miyazawa Phablo F. S. Moura3 Eduardo C. Xavier
Institute of Computing. University of Campinas. Campinas, S˜ao Paulo, Brazil

Abstract
We propose a randomized approximation scheme for the Euclidean Steiner Multi Cycle problem which runs
in quasilinear time. In this problem, we are given a set of n pairs of points (terminals) T = ,{ti, t′ },n	in
the Euclidean plane, and the objective is to find a collection of cycles of minimum cost such that ti and t′
belong to a same cycle, for each i ∈ {1,..., n}. This problem extends the Steiner Cycle problem in the same way the Steiner Forest extends the Steiner Tree problem. Additionally, it has applications on routing problems with pickup and delivery locations.
Keywords: Euclidean plane, geometry, Steiner, approximation algorithm, quasilinear.

Introduction
The Steiner Multi Cycle Problem was proposed by Pereira et al., in the context of a routing problem with pickup and delivery locations, as a natural generaliza- tion of the Steiner Cycle problem [4]. In this problem we are given a complete weighted graph G which respects the triangle inequality and a collection of termi- nal sets {T1,..., Tk} such that Ti ⊆ V (G) for every i ∈ [k] := {1,..., k}, and these terminal sets are pairwise disjoint. The problem is to find a set of vertex disjoint

1 The authors thank the S˜ao Paulo Research Foundation, FAPESP, (grants #2015/11937-9, #2016/01860- 1, #2016/23552-7, #2017/22611-2, and #2016/21250-3), the Brazilian National Council for Scientific and Technological Development, CNPq, (grants #314366/2018-0, #425340/2016-3, and #304856/2017-7). This research was partially financed by Coordena¸c˜ao de Aperfeic¸oamento de Pessoal de N´ıvel Superior, Brasil (CAPES), Finance Code 001.
2 Emails: carla.negri@ufabc.edu.br, fkm@ic.unicamp.br, phablo@ic.unicamp.br, eduardo@ic.unicamp.br
3 Corresponding author.

https://doi.org/10.1016/j.entcs.2019.08.052
1571-0661/© 2019 The Author(s). Published by Elsevier B.V.
This is an open access article under the CC BY-NC-ND license (http://creativecommons.org/licenses/by-nc-nd/4.0/).

cycles of minimum cost such that, for each i ∈ [k], all vertices of Ti belong to a same cycle. One may show that this reduces to the problem where each terminal set contains exactly two terminals. In this paper, we address the problem restricted to the Euclidean plane.
The Euclidean distance of a line segment l = xy between points x and y is denoted length(l). We say that l is a line segment with endpoints x and y. If L is a multiset of line segments, then we define ν(L) as the set of all endpoints of line segments in L, and δL(x) as the number of line segments in L with endpoint at x. Additionally, the length of L, denoted by length(L), is  l∈L length(l).
Problem 1.1 Euclidean Steiner Multi Cycle Problem (ESMC)

Instance: A set T = {{ti, tj}}n
of n pairs of points (a.k.a. terminals) in R2 with

Euclidean distances.
i	i=1

Find: A multiset L of line segments such that δL(x) is even for every x ∈ ν(L),
every terminal t is an endpoint of some line in L, and the pair of terminals ti and tj
are connected by some cycle in L, for every i ∈ [n].
Goal: Minimize length(L).
The Steiner Multi Cycle Problem (SMCP) is a generalization of the Steiner Cycle Problem (SCP) in the same way that the Steiner Forest generalizes the Steiner Tree problem. The SCP was introduced by Salazar-Gonz´alez who proposed a polyhedral study of integer linear programming formulations of the problem [5]. Steinov´a proved that the general problem in directed graphs does not admit an approximation algorithm with polynomial ratio in the input size, unless P = NP [6]. She also presented a (3/2)-approximation algorithm for the case in which the input graph is undirected and metric. Pereira et al. addressed the metric version of the SMCP [4]. They designed a 4-approximation algorithm and several heuristics for it.
In this work, we propose a randomized approximation scheme to ESMC which runs in O(n logκ n) time, where n denotes the number of pairs of terminals of the input and κ is a constant. To the best of our knowledge, this is the first polynomial- time approximation scheme designed for a variant of the Steiner Cycle Problem. Our algorithm combines some techniques introduced for the Euclidean TSP by Arora [1] and for the Euclidean Steiner Forest by Borradaile et al. [3]. Despite the similarity between ESMC and the Euclidean Steneir Forest problem, many additional complications arise when dealing with cycles instead of trees. In the proposed algorithm, we introduce new ideas and make several adaptations in the strategy presented by Borradaile et al. [3]. In the dynamic programming table, we use a different description of feasible solutions by incorporating an order in which portals are visited by the cycle. We also ensure that points in the solution being constructed have even degree so that cycles covering the points can be constructed. The remainder of this paper is organized as follows. Section 2 presents some initial and important definitions which will be needed throughout the text. It also gives an overview of how our algorithm works. Section 3 specifies some changes we have to perform on the input instance. Section 4 is dedicated to prove the existence of an ε-approximate solution for ESMC which has low complexity, where ε is a

constant in the open interval (0, 1). Section 5 shows the details of an algorithm for computing such a solution.

Preliminaries and an overview
As the algorithms of Arora [1] and Borradaile et al. [3], ours also depends on recur- sively partitioning the space enclosing terminals with lines. The proposed algorithm is a dynamic programming which finds an optimal solution that crosses each of such lines a constant amount of times and only at specified points called portals. This partition, called dissection, works as follows.
Initially, we have a root dissection square, which is a bounding box containing all points of the input instance. The length of the side of this root dissection square is L, which is a power of two and it is at least twice the length of the side of the smallest square enclosing all terminals of the input. We assume this root square is initially positioned with its bottom left corner at position (0, 0) in the plane. Hence, every terminal is in a position inside the square defined by points (0, 0) and (L/2, L/2).
Then we randomly translate the root square, moving its bottom left corner to position (−a, −b), where a and b are chosen uniformly at random from the range [0, L/2). This is called a random shift. The root square and the lines around it are considered to be at depth zero. We start the dissection of this root square by partitioning it into four squares of same area, which is done with a horizontal and a vertical dissection lines that cut the root square. These lines and the four squares created by them are thus at depth one. For each of the dissection squares created, this process of partition is repeated until there is only one terminal in each dissection square (or multiple terminals, but all with the same coordinates).
We say that the four squares created by dissecting a given square R are children of R and that R is their parent. If a dissection square R encloses another dissection square Rj, then Rj is a descendant of R. Note that the depth of any square is one plus the depth of its parent. This nested structure of squares forms the quadtree. The depth of a dissection line l, denoted by depth(l), is defined as the lowest depth of dissection squares that l separates. Observe that the squares that are leaves of the quadtree have depth at most O(log L).
Consider an integer grid of granularity one in the Euclidean plane, that is, a grid that divides the plane into cells of side length one and whose lines cross at integer points. Let l be a grid line. Since there are L/2 values for the vertical shift and L/2 values for the horizontal shift and 2i—1 of these will make depth(l)= i, we have that P[depth(l)= i]= 2i/L.
Borradaile et al. [3] mentioned that, for the Steiner Forest problem, it was neces- sary to further subdivide each dissection square in order to obtain a polynomial-size memoization table in the dynamic programming algorithm. Instead of pairing ter- minals to portals, which would require exponential time, the dynamic programming pairs cells to portals, where a cell can contain more than one terminal. As we face the same problem here, each dissection square is further subdivided into a regular

grid with B × B cells, where B = O(ε—1) (to be precisely defined later on) is an integer power of two and ε ∈ (0, 1) is a constant.
The solution constructed by our algorithm crosses the border of each dissection square only at designated points of the dissection lines that are called portals, which is also a strategy to reduce the complexity of the dynamic programming. The dynamic program starts building solutions for the leaves of the quadtree. In a bottom-up fashion, the solutions of the four children dissection squares are combined to build a solution of their parent square. Thus, the amount of time required by the algorithm depends on the depth of the tree, which is O(log L). However, the size of the smallest square enclosing all terminals of the input may be arbitrarily larger than the value of an optimal solution, which implies arbitrarily larger than n. Another important concern is not to have terminals lying on the dissection lines, where the portals are.
To overcome these issues, we transform the original input T , by first producing a partition {Ti}i∈[k] of T such that each Ti has a bounding box of length that depends on |Ti|. We also show that the optimal solution for T can be built from a simple union of optimal solutions for each Ti. Then we discretize the instance by scaling it and rounding the coordinates of the terminals to centers of a grid over the plane. Details of this transformation are given on Section 3. Let us denote by T jj = {T jj}i∈[k] the transformed input.
Our algorithm builds up a table MR for each dissection square R. The table is indexed by the valid conﬁgurations of R, which encodes subpartitions of cells and portals of R. We describe this concept in Section 5.
Let π be a valid configuration of R. The algorithm keeps in MR[π] the cost of a minimum-length solution which is compatible (to be defined in Section 5) with configuration π and which conforms (to be defined in Section 4) to square R. A configuration π is compatible with a solution L if the line segments in L match the partition of cells and portals described by π. The conformance definition is the one needed to keep a solution feasible and simple (i.e. low complexity): the line segments form cycles, connect pairs of terminals, and they only cross the border of the square at (a constant amount of) portals.
To write in an entry MR[π], the algorithm acesses the tables already built for the children dissection squares of R. Among all possible configurations of the four children, it considers only some of them, which are what we called consistent with π. Essentially, the consistency guarantees that conforming solutions which are compatible with these children configurations can be combined to build up a feasible conforming solution for R which is compatible with π.
Finally, we prove several results to show that our algorithm indeed builds a feasible solution for T jj and is a (1 + ε)-approximation for ESMC. One of the main results is that this dynamic programming indeed finds the value of the optimal solution for T jj which is conforming to the root dissection square (Theorem 5.3). The other main result is that there exists a solution for T jj which is conforming to the root square and whose total length is not so distant (at most a factor of ε) from an optimal solution for T (Theorem 4.3).

Restricted problem
Let R denote the set of all dissection squares. Let CR, TR, and PR be the sets of cells, terminals, and portals, respectively, of the dissection square R, for each R ∈ R. To simplify notation, we prefer to write C٨, T٨, and P٨ when we refer to the sets of cells, terminals, and portals of a dissection square R٨. Let OPT(T ) denote an optimal solution and, as an abuse of notation, the cost of an optimal solution for instance T .
The first step is to transform the instance into one that gives usa guarantee on the size of the root dissection square. We now describe such transformation and then we show that it is possible to build back a solution for the original instance with a small extra cost. Our algorithm will thus work on such transformed instance. Let T denote an instance of ESMC. For every subset S ⊆T of pairs of terminals,
let μ(S)= {ti, tj : {ti, tj}∈ S} be the set of underlying terminals, and let diam(S)
be the maximum Euclidean distance between any pair of points in S, that is, the
diameter of S. Let G(T ) denote the graph with vertex set μ(T ) and edge set T . Let dist(T )= max{diam(V (H)): H is a component of G(T )}, that is, the max-
imum distance between any pair of terminals that must be connected. Observe that every feasible solution must connect the terminals belonging to a same component of G(T ). On the other hand, one may easily construct a feasible solution by con- necting each pair of terminals {t, tj} ∈ T with two copies of the line segment ttj. Note that every line segment in this solution has length at most dist(T ). Hence, it follows that
dist(T ) ≤ OPT(T ) ≤ 2|T | dist(T ) .	(1)
The first step of the transformation is to partition the set T of terminals, which is performed by Partition, given in Algorithm 1. Proposition 3.1 shows that the union of optimal solutions for each element of such a partition gives an optimal solution for the whole instance T . This partition allows us to bound the diameter of each part of the partition considering the number of pairs of terminals it con- tains and the maximum distance between such terminals. This bound is shown in Proposition 3.2.
Proposition 3.1 The optimal solution for T is the union of optimal solutions for each element in the partition produced by Algorithm 1 on input (T ,T ), where T is a minimum-length spanning tree of μ(T ).
Proposition 3.2 Algorithm 1 produces a partition {Ti}i∈[k] of T such that, for each i ∈ [k], diam(μ(Ti)) ≤ 4|Ti|2 dist(Ti). Moreover, it runs in O(n log n) time, where n = |T |.
Proof. Sketch. The stop condition in line 2 guarantees that, for each i ∈ [k], the points in μ(Ti) admit a spanning tree in which every line segment has length at most 2|Ti| dist(Ti). This means that there exists a path of length at most 4|Ti|2 dist(Ti) between any pair of points in μ(Ti). We show that the partition procedure described in Algorithm 1 can be implemented in O(n log n) time, where n = |T |.	2



Algorithm 1: Partition
Input: Set T of pairs of terminals and a minimum-length spanning tree T
of the set of points μ(T )
Output: Partition of T
1 Let e be a longest edge of T
2 if length(e) > 2|T | dist(T ) then
3	Let T1 and T2 be the components of T − e
4	Let Ti be the subset of pairs of terminals in Ti for i ∈ {1, 2}
/* {T1, T2} is indeed a partition of T	*/
5	P → Partition(T1, T1) ∪ Partition(T2, T2)
6 else
7	 P → {T }
8 return P

Now that we have a partition {Ti}i∈[k] of the instance T , the idea is that our algorithm finds approximate solutions to each subset Ti and then compute the union of the solutions. Since each element of the partition is not particularly different from any other element, we shall assume from now on that we are dealing with one of such subsets. For the sake of simplicity, we keep using T as the input instance (it represents one of the elements of the partition). Remark that by Proposition 3.2 we have
diam(μ(T )) ≤ 4n2 dist(T ) .	(2)
The second step to transform the instance is the discretization. Herein, we consider that there is an integer grid of granularity one in the Euclidean plane, that is, a grid that divides the plane into cells of side length one and whose lines cross at integer points. The idea is to move the terminals, which can have any coordinates in the original instance, into centers of grid cells.
First we scale the input instance by a factor of (80n√2)/(ε dist(T )) obtaining
T j, which is called scaled instance. By the same argument given in Equation (1) and considering the factor above, we now have

OPT(T j)= OPT(T )
80n√2
ε dist(T )
80n√2
≥	ε

.	(3)

Furthermore, using the inequality from Equation (2) we have


diam(μ(T j)) = diam(μ(T ))
80n√2
ε dist(T )

≤ 4n dist(T )
80n√2
ε dist(T )
320n3√2
=
ε

.	(4)

The discretization ends with a rounding on the position of each terminal to the nearest center of a grid cell. Let T jj be the instance obtained after rounding the terminals’ positions of instance T j. We call T jj the transformed instance, which is generated after scaling and rounding the points in μ(T ). Since our algorithm works on the transformed instance, Lemma 3.3 guarantees that we can construct a

solution to the original instance from the transformed one with a minor additional cost.
Lemma 3.3 There exists a solution to T j derived from any solution for T jj with additional cost of at most (ε/40) OPT(T j).
As mentioned before, our algorithm works on the transformed instance. The goal is to find a near-optimal solution Ljj for T jj such that the number of times that Ljj intersects the grid lines is bounded by the length of Ljj itself, which is in turn bounded by a constant times the value of an optimal solution for T j.
Lemma 3.4 There exists a solution Ljj to T jj such that
length(Ljj) ≤ 1+  ε  OPT(T j)	and	Σ Σ |e ∩ l|≤ 3 OPT(T j) ,
40	e∈L′′ l∈G
where G is the set of lines in the integer grid of granularity one over the Euclidean plane.
Our algorithm will actually find an approximation for the solution mentioned in Lemma 3.4.
Recall that L denotes the length of the side of the root dissection square. We next give an upper bound for the value of L in terms of n. First note that a square of side length diam(μ(T j)) is the smallest that encloses all terminals of T j. Thus,
we define L as the smallest integer power of √two which is at least 2 diam(μ(T )). It
follows from Equation (4) that L ≤ (1280n3 2)/ε.
Let A be the smallest integer power of two which is at least 30ε—1 log L. For each horizontal (resp. vertical) dissection line l, the portals on l are exactly the points in l with x-coordinates (y-coordinates) which are integer multiples of L/(A2depth(l)). Recall that every square of depth i is bounded by two dissection lines of depth i and two dissection lines of depth smaller than i. Moreover, the side of a dissection square R of depth i has length L/2i. Since portals are placed at integer multiples of L/(A2i) in a dissection line of depth i, there is at most A portals on each side of A. Therefore, it holds that every dissection square has at most 4A portals on its boundary. One may also prove that, for every dissection square R, all corners of R
are portals, except for the points which are corners of the root dissection square.

Approximate conforming solutions
Let R be a dissection square where ∂R denotes its border and let L be a finite multiset of line segments in R. Let us denote by ν(L) the set of all endpoints of line segments in L. For each point x ∈ ν(L), δL(x) denotes the number of line segments in L that contain x. Additionally, let D = O(1/ε) be a constant (to be defined in Theorem 4.1).
We say that L connects two points x, xj of R if x and xj belong to the same connected component of L. Moreover, L conforms to R if

L∩ ∂R contains at most 4(D + 1) connected components;
every connected component of L∩ ∂R contains a portal of R;
for every cell x ∈ CR, there exists at most one component of L that intersects x
and also intersects the boundary of R;
for every portal p ∈ PR, we have δL(p) ≤ 2;
for every point s ∈ ν(L) that is not a portal of R, δL(s) is even; and
if a terminal t in the square R is not connected to its mate by L, then t is connected to the boundary of R by L.
An example of a conforming multiset of line segments is depicted in Figure (1a).
We say that L recursively conforms to R if it conforms to R and to all dissection squares that are descendant of R. If L recursively conforms to the root dissection square, then L is said to be conforming.
In what follows, we prove the existence of a conforming solution for ESMC of cost at most (1 + ε) OPT(T ). We start from a feasible solution ensured by Lemma 3.4, then we transform it to satisfy all properties of a conforming solution. In expectation over the random shifts of the dissection lines, the transformations made on the initial solution increase its length only by a small constant factor of the optimal length.
Theorem 4.1 Let T jj be a transformed instance of the original instance T of the
Euclidean Steiner Multi Cycle problem. There exists a feasible solution L
for T jj that has length at most (1 + 99ε/120) OPT(T ), in expectation over the ran- dom shift of the bounding box, and such that L satisﬁes the following properties for each dissection square R:
for each side S of R,	S has at most D noncorner components where
D = 60ε—1;
every connected component of L∩ ∂R contains a portal of R;
for every cell x ∈ CR, there exists at most one component of L that intersects
x and also intersects the boundary of R; and
if a terminal t in R is not connected to its mate by L∩ R, then t is connected to the boundary of R by L.
Proof. Sketch. Let Ljj be the feasible solution for T jj given by Lemma 3.4. Note that Ljj trivially satisfies property (iv) since it is a feasible solution for T jj. We can show how to transform Ljj into a feasible solution L which satisfies properties (i), (ii), and (iii). In all these transformations, we only augment already existing components of Ljj by adding sets of line segments that form a cycle. Thus, one may easily verify that property (iv) is preserved in L and δL(s) is even, for every point s ∈ ν(L). Therefore, L is a solution for T jj which satisfies properties (i)–(iv).
As a consequence of the small augment on the length of the solution (details omitted), we have length(L) − length(Ljj) ≤ (3ε/5) OPT(T ). By combining the last inequality with the bound given in Lemma 3.4, we obtain length(L) ≤ (1 +

ε/40) OPT(T )+ (3ε/5) OPT(T ) ≤ (1 + 25ε/40) OPT(T ).	2
Corollary 4.2 Let T jj be a transformed instance of the original instance T of the Euclidean Steiner Multi Cycle problem. There exists a conforming solution for T jj that has length at most (1 + 99ε/120) OPT(T ), in expectation over the ran- dom shift of the bounding box.
Proof. Let L be the solution given in Theorem 4.1. Note that portals of the dissection squares may be visited multiple times by L. Following the same ideas of shortcut solution described by Arora in [1], we can obtain from L a conforming solution to T jj which has length at most length(L) ≤ (1 + 99ε/120) OPT(T ).  2
Theorem 4.3 Let T be an instance of the Euclidean Steiner Multi Cycle.
There exists a conforming solution for T with length at most (1 + ε) OPT(T ), in expectation over the random shift of the bounding box.
Proof. Let L be the solution to the transformed version T jj guaranteed by Corol- lary 4.2. By Lemma 3.3, we obtain from L a solution Lj to T such that length(Lj) ≤ length(L)+ (ε/40) OPT(T ) ≤ (1 + 102ε/120) OPT(T ).	2

The algorithm
Let S be a set and let ℘(S) denote the power set of S, that is, the set of all subsets of S. A set π is said to be a subpartition of S if π  ℘(S), and the elements in π
are pairwise disjoint. Let π and πj be two subpartitions of S. We say that πj is a coarsening of π if, for every Pj ∈ πj, there exists S ⊆ π such that Pj = P ∈E P . Finally, for every element s ∈ S, π(s) denotes the element in π which contains s if there is one, or ∅ otherwise.
Consider now a dissection square R. Let CR : TR → CR be a function such that CR(t) is the cell of R that contains t. To simplify, we use C٨ when referring to the function associated with dissection square R٨.
A conﬁguration of R is a tuple (πin, πout, θ) that satisfies
πin and πout are subpartitions of PR ∪ CR;
πout is a coarsening of πin;
each element of πin contains at least one portal and at least one cell of R; and
for each Q ∈ πin,
θ(Q)= p1 ... pÆ : {pi}Æ	⊆ Q and the portals in {pi}Æ−1 are pairwise different if l > 1 ,
that is, a set of sequences of portals in Q. Note that, if l > 1, then p1 and pl
may be the same portal.
A configuration (πin, πout, θ) of R is said to be valid if the following holds.
|πin|≤ 4(D + 1), and πin contains at most 8(D + 1) portals;
for every Q ∈ πin and portal p ∈ Q, there is a single sequence in θ(Q) which contains p;

for every pair of mated terminals {t, tj} such that t ∈ TR and tj ∈/ TR, there is a single Q ∈ πin such that CR(t) ∈ Q. For every pair of mated terminals {t, tj} such that t, tj ∈ TR, either there is Q ∈ πout such that {CR(t), CR(tj)} ⊆ Q, or {CR(t), CR(tj)}∩ Q = ∅ for all Q ∈ πin.
See Figure (1b) for an example of valid configuration.
Every dissection square has 4A portals and B2 cells, so we can bound the amount of valid configurations.
Corollary 5.1 There exist at most (ε—2 log n)&(ε−2) valid conﬁgurations.
Let R and Rj be different squares. Let (πin, πout, θ) and (πj , πj	, θj) be valid
in	out
configurations of R and Rj, respectively. We denote by G(πin, πj ) the intersec-
tion graph of πin and πj	constructed as follows.  The vertex set of G(πin, πj )
is πin ∪ πj	and its edge set is {{u, v} : u ∩ v /= ∅}.	Notice that only por-
tals may be in the intersection of u ∈ πin and v ∈ πj . We define πin  πj	=
,in	in
  


partitions {πi}t
t	i
i=1  in
1	 πt
is naturally defined.

Furthermore, we denote by G(θ) the portal graph, which has vertex set PR
and edge set {{u, v} : ∃Q ∈ πin s.t. uv is a subsequence of some sequence in θ(Q)}. Note that each element of θ(Q) defines a (closed or open) path in G(θ), for all Q ∈ πin.
Consider a dissection square R0 and its child dissection squares R1, R2, R3, and
R4.	For each i ∈ {0,..., 4}, let (πi , πi	, θi) be a valid configuration for Ri.
Moreover, let λ =  4	i  and let G =  4	G(θi). The set of configurations
{(πi , πi	, θi)}4	is said to be consistent if it satisfies all the following properties.
π0 is identical to the set obtained from λ by the following procedure. For
each P ∈ λ, remove from P all portals in ( 4	Pi) \ P0, and replace each
cell in P by the corresponding parent cell of R0. Finally, remove from λ all elements that do not contain any portal of R0.
For each Q ∈ λ such that Q∩ P0 = ∅, each component of G[Q∩ (  4	Pi)] has

an Eulerian cycle.
For each Q ∈ λ such that Q∩ P0 /= ∅, each component of G[Q∩ ( 4

Pi)] has

an Eulerian path with both endpoints in P0.
For every i ∈ {1, 2, 3, 4} and every x, y ∈ Pi ∪ Ci, πi

= πi

if and

only if either λ(x) = λ(y), or there are portals p and q of R0 such that

0
out
= π0
, λ(x)= λ(p) and λ(y)= λ(q).

For every pair of mated terminals {t, tj} such that t ∈ Ti and tj ∈ Tj with i, j ∈
{1, 2, 3, 4}, we have either λ(Ci(t)) = λ(Cj(tj)), or π0	(Ci(t)) = π0	(Cj(tj)).
For every portal p ∈ ( 4	Pi) \ P0, dG(p) is even, where dG(p) is the degree
of p in G.
For every portal p ∈ P0, d0(p)= dG(p).
There exists a partition of E(G) into a set X of edge-disjoint paths with the


	
(a)	(b)
Fig. 1. A dissection square R with terminals ti and portals pj . Cells are illustrated by dotted lines. Figure (1a) shows a multiset of line segments which conforms to R. Thicker lines represent two copies of the same line segments (e.g. between t1 and p1). Figure (1b) shows a valid configuration (πin, πout, θ) for R. The terminals and portals of R are {t1, t2, t3, t4, t′ } and {p1, p2, p3, p4, p5}, respectively. πin = {Q1, Q2, Q3}, πout = {Q1 ∪ Q2, Q3}, θ(Q1)= {p2p5}, θ(Q2)= {p1}, and θ(Q3)= {p3p4}.
following property. K is a component of G(θ0) if and only if there is a path P ∈ X such that K is identical to the graph obtained from P by lifting all edges incident to vertices in V (P ) \ P0 and removing all vertices in V (P ) \ P0.
A pseudocode of our algorithm is given in Algorithm 2. It finds the cost of an optimal conforming solution for the transformed instance. Proposition 5.2 and Theorem 5.3 are used to prove this claim.
Let L and (πin, πout, θ) be a conforming solution and a valid configuration of R, respectively. Let Γ(L) denote the set of all possible paths formed by line segments in L. We define Lj as the set of line segments in L which belong to components that contain some portal of R. We say that the portal graph G(θ) and L are coherent if and only if there exists an injective function f : E(G(θ)) → Γ(Lj) such that (i) for each edge uv in G(θ), f (uv) is a path of line segments with endpoints at the portals u and v, and (ii) for each l ∈ Lj, there exists a single e ∈ E(G(θ)) such that f (e) contains l.
Recall that every component of G(θ) is a (open or closed) path. Hence, if L and G(θ) are coherent, then the set of all components of G(θ) induces a partition of Lj into paths of line segments that link portals of R.
We say that L and (πin, πout, θ) are compatible if and only if
for every component K of L that intersects the boundary of R, there exists a single part Q ∈ πin such that Q consists exactly of the cells and portals intersected by K in R; and
G(θ) and L are coherent.
Proposition 5.2 For every conforming solution L to R, there exists a valid con- ﬁguration (πin, πout, θ) of R which is compatible with L.
Theorem 5.3 Let R be a dissection square. Algorithm 2 (i.e., Solve-ESMC)
ﬁlls in a table MR such that, for every valid conﬁguration (πin, πout, θ) of R, MR[(πin, πout, θ)] is the minimum length of a multiset of lines that is compatible with (πin, πout, θ) and recursively conforms to R.



Algorithm 2: Solve-ESMC
Input: Dissection square R and fR
1 if R contains at most one terminal then
2	foreach valid conﬁguration (πin, πout, θ) of R do
3	MR[(πin, πout, θ)] → 0
4	foreach part Q ∈ πin do
5	if the cells in Q are connected and these cells contain the portals of Q then
6	Let LQ be a minimum-length multiset of lines contained in the cells of Q such that LQ is coherent with G(θ), contains the terminal (if any) in Q, and each cell in Q is crossed by at most one component of LQ that intersects the boundary of R. If there is no such a set, then
define length(LQ)= +∞.
7	MR[(πin, πout, θ)] → MR[(πin, πout, θ)]+ length(LQ)
8	else
9	 MR[(πin, πout, θ)] → +∞
10 else
11	Let R1, R2, R3 and R4 be the four child dissection squares of R
12	Solve-ESMC(Ri) for every i ∈ {1, 2, 3, 4}
13	foreach valid conﬁguration (πin, πout, θ) of R do
14	 MR[(πin, πout, θ)] → +∞
15	forall conﬁg. (πin, πout, θ) of R and {(πi , πi	, θi)}4	of {Ri}4	do
16	if {(πin, πout, θ)}∪ {(πi , πi	, θi)}4	is consistent then

in	out
17	MR[(πin, πout, θ)] →
i=1

min MR[(πin, πout, θ)],  Σ4
Mi[(πi , πi
, θi)],




Proposition 5.4 Let f be an instance of ESMC with n pairs of terminals, and let R be a root dissection square enclosing the terminals of f . Algorithm 2 (Solve- ESMC) on input (R, f ) runs in &(n logκ n) time, where κ ∈ &(ε—2).

Conclusion and further research
Let us denote by f be an instance of ESMC which contains n pairs of terminals, and let ε ∈ (0, 1). We proved in Theorem 5.3 that the proposed algorithm finds a minimum-length solution of f that is conforming with a given bounding box. In Proposition 5.4, we argued that such a solution can be found in &(n logκ n) time, where κ is a constant which only depends on ε. In Theorem 4.3, we showed the existence of a conforming solution for f of length at most (1 + ε) OPT(f ) in expectation over the random shift of the bounding box. From the mentioned results and by Markov’s inequality, we conclude that the solution computed for f

has length at most (1 + ε) OPT(f ) with probability at least one half. Therefore, the proposed algorithm is a randomized approximation scheme for ESMC which runs in quasilinear time.
In 2011, Bateni et al. devised a polynomial-time approximation scheme (PTAS) for the Steiner Forest Problem in planar graphs [2]. Therefore, a natural direction for further research is to investigate the existence of a PTAS for the Steiner Multi Cycle Problem on planar graphs.

References
Arora, S., Polynomial time approximation schemes for Euclidean traveling salesman and other geometric problems, Journal of the ACM 45 (1998), pp. 753–782.
Bateni, M., M. Hajiaghayi and D. Marx, Approximation schemes for Steiner forest on planar graphs and graphs of bounded treewidth, Journal of the ACM 58 (2011), pp. 21:1–21:37.
Borradaile, G., P. N. Klein and C. Mathieu, A polynomial-time approximation scheme for Euclidean Steiner forest, ACM Transactions on Algorithms 11 (2015), pp. 19:1–19:20.
Pereira, V. N. G., M. C. S. Felice, P. H. D. B. Hokama and E. C. Xavier, The Steiner multi cycle problem with applications to a collaborative truckload problem, in: 17th International Symposium on Experimental Algorithms, (SEA’2018), 2018, pp. 26:1–26:13.
Salazar-Gonzalez, J.-J., The Steiner cycle polytope, European Journal of Operational Research 147
(2003), pp. 671–679.
Steinov´a, M., Approximability of the minimum Steiner cycle problem, Computing and Informatics 29
(2012), pp. 1349–1357.
