Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 300 (2014) 71–87
www.elsevier.com/locate/entcs

J-Calc: A Typed Lambda Calculus for Intuitionistic Justification Logic
Konstantinos Pouliasis1,2,5
Department of Computer Science
The Graduate Center at City University of New York, NY, USA
Giuseppe Primiero3,4,5
Department of Computer Science Middlesex University
United Kingdom

Abstract
In this paper we offer a system J-Calc that can be regarded as a typed λ-calculus for the {→, ⊥} fragment of Intuitionistic Justification Logic. We offer different interpretations of J-Calc, in particular, as a two phase proof system in which we proof check the validity of deductions of a theory T based on deductions from a stronger theory T ′ and computationally as a type system for separate compilations. We establish some first metatheoretic results.
Keywords: Typed λ-calculus, Justification Logic, Modular Programming.


Introduction
A plausible reading of G¨odel’s incompleteness results ([18]) is that the notion of “va- lidity” diverges from that of “truth within a specific theory”: given a theory that includes enough arithmetic, there are statements whose validity can only be estab- lished in a theory of larger proof-strength. This phenomenon can be shown even

1 This research is part of Konstantinos Pouliasis’ Phd study as a Enhanced Chancellor Fellow at the Graduate Center of the City University of New York under the supervision of Prof. Sergei Artemov. He is indebted to Prof. Sergei Artemov’s advisement and guidance during his academic journey.
2 Email: Kpouliasis@gc.cuny.edu
3 This research was conducted while Giuseppe Primiero was a Post-Doctoral Fellow of the Research Foun- dation Flanders (FWO) at the Centre for Logic and Philosophy of Science, Ghent University Belgium. He gratefully acknowledges the financial support.
4 Email: G.Primiero@mdx.ac.uk
5 Both authors are indebted to the constructive comments of the anonymous referees of the Intuitionistic Modal Logic and Applications Workshop, 2013.

1571-0661 © 2013 Elsevier B.V. Open access under CC BY-NC-ND license.
http://dx.doi.org/10.1016/j.entcs.2013.12.012

with non-G¨odelian arguments in the relation e.g. between IΔ0 and IΣ1 arithmetic [27], IΣ1 and PA, PA and ZF, etc. [29,15]. The very same issues arise in automated theorem proving. A good example is given by type systems and interactive theorem provers (e.g. Coq, Agda) of the typed functional paradigm. In such systems, when termination of functions has to be secured, one might need to invoke stronger proof principles. The need for reasoning about two kinds of proof objects within a type system is apparent most of all when one wants to establish non-admissibility results for a theory T that can, in contrast, be proved in some stronger T j. The type sys- tem, then, has to reconcile the existence of a proof object of some type φ in some T j and a proof object of type ¬∃s.ProvT (s, φ) that witnesses the non-provability of φ (in T ).
In this work, we argue that the explicit modality of Justification Logic [7] can be used to axiomatize relations between objects of two different calculi such as those mentioned above. It is well known that the provability predicate can be ax- iomatized using a modality [14], [9]. The Logic of Proofs LP [3] goes further and provides explicit proof terms (proof polynomials) to inhabit judgments on validity. By translating reasoning in Intuitionistic Propositional Calculus (IPC) to classical proofs, LP obtains a classical semantics for IPC through a modality (inducing a BHK semantics). In this paper we axiomatize the relation between the two kinds of proof objects explicitly, by creating a modal type theory that reasons about bindings or linking of objects from two calculi: a lower-level theory T , formulated as IPC with Church-style λ-terms representing intuitionistic proof objects; and a higher-level, possibly stronger and classical (co-)theory T j fixed as foundational, with justiﬁca- tions expressing its proof objects. The axiomatization of such a (co-)theory follows directly the proof system of Justification Logic (here restricted to its applicative K-fragment) and is used to interpret classically (meaning truth-functionally ) the constructions of the intuitionistic natural deduction. The underlying principle of our linking system is as follows:
constructive necessity = admissible validity = truth (in T )+ validity (in T j)
Necessity of a true (in T ) proposition P is, thus, sensitive to the existence of a proof (witnessed by a justification) of its intended interpretation within T j. We assume an interpretation function on types Just that maps the type universe of T into the type universe of T j. We employ judgments of the kind M : P (read as “M is a proof of type P in T ”) that represent truths in T and judgments of the kind j : Just P (to be read as ”j is a justification of the interpretation of P in T j”) that represent truth in T j (validity). Incorporating them, the principle can be rewritten in a judgmental fashion:
M : P + j : Just P ⇒ 2jP true

Notice that the 2-types are indexed by justifications (2jP ) being sensitive to the interpretation (T j) chosen. To complete the picture we need canonical elements of 2j-types. Naturally, witnesses of this kind are links between proof objects from T

and T j with corresponding types (P and Just P). For that reason we introduce a linking witness constructor Link. This is how necessity is introduced: by proof- checking deductions of T with deductions of T j, we reason constructively about admissibility of valid (via T j) statements in T . The principle thus becomes:
M : P + j : Just P ⇒ Link(M, j): 2jP We show how this principle is admissible in our system.
A possible application of the presented type theory can be a refined type sys- tem for programming languages with modular programming constructs or external function calls as we show in section 5. In these kinds of languages (e.g. of the ML family) a program or module can call for external definitions that are implemented elsewhere (in another module or, even in another language) 6 . We can read functions within 2-types indexed by justifications as linking processes for such languages that perform the mapping of well–typed constructs importing and using module signa- tures into their residual programs. By residual programs we mean programs where all instances of module types and function calls are replaced by (i.e. linked to) their actual implementations, which remain hidden in the module. We show with a real example how, with slight modifications, our type system can find a natural application in this setting. Here we focus on the type system itself and not on its operational semantics.
The backbone of this work is the idea of representing the proof theoretic seman- tics for IPC through modality that stems from [5],[6]. An operational approach to modality related to this work can be found in [4]. The modularity of LP, i.e. its ability to realize other kinds of modal reasoning with proper changes in the axiom- atization of proof polynomials, was shown with the development of the family of Justification Logics [7]. This ability is easily seen to be preserved here. Our work incorporates the rich type system and modularity of Justification Logic within the proofs-as-programs doctrine. For that reason, we obtain an extension of the Curry- Howard correspondence ([30], [17]) and adopt the judgmental approach of Intuition- istic Type Theory ([21], [22], [23], [25], [11]). Our system borrows from other modal calculi developed within the judgmental approach (e.g. [28], [19],[1] and especially [13] for the modal logic K). A main difference of our system with those systems, as well as with previous λ-calculi for LP ([2], [10]) is that our type system hosts a two-kinded typing relation for proof objects of corresponding formulae. It can be viewed as an attempt to add proof terms for validity judgments as presented in [28]. The resulting type system adopts dependent typing ([12], [26]) to relate the two kinds of proof objects with modality. The construction of the type universe as well as of justificational terms draws a lot from ideas in [8] and from [16]. Extending typed modal calculi with additional (contextual) terms of dependent typing can be also found in [24].


6 See [20].

A road map for the type system
The present system can be viewed as a calculus of reasoning in three interleav- ing phases. Firstly, reasoning about proof objects in the implicational fragment of an intuitionistic theory T in absence of any metatheoretic assumptions of valid- ity, introduced in Section 3. This calculus is formalized by the turnstile Γ ▶IPC 7 where Γ contains assumptions on proofs of sentences in T . The underlying logic is intuitionistic, the system corresponding to the implicational fragment of simply typed lambda calculus. Secondly, reasoning with justifications, corresponding to reasoning about proof objects in some fixed foundational system: the (co-)theory T j, introduced in Section 4. We suppose that T j provides the intended semantics for the intuitionistic system T . The corresponding turnstile is Δ ▶J. Abstracting from any specific metatheory, all that matters from a purely logical point of view is that the theory of the interpretation should – at least – include as much logic as the implicational fragment of T and it should satisfy some minimal conditions for the provability predicate of T . Finally, reasoning about existence of links between proof objects in the implicational fragment of both axiomatic systems, introduced in Section 6. This mode of reasoning is axiomatized within the full turnstile Δ; Γ ▶JC. The core of this system is the 2-Introduction rule, which allows to express construc- tive reasoning on linking existence. The idea is – ignoring contextual reasoning for simplicity – that linking a construction in T with a justification of its corresponding type in T j we obtain a proof of a constructive (or, admissible in T ) validity. The rule in full (i.e. including contexts) corresponds to the construction of a link for a compound term based on existing link on its subterms. The full turnstile Γ; Δ ▶ is, hence, a modal logic that “zips” mutual reasoning between the two calculi. Within this framework we obtain a computational reading for justification logic restricted to K modal reasoning. Before presenting this mutual reasoning at any arbitrary level of nesting (i.e. arbitrary modal types), we first introduce JCalc1 which is a restriction of the type universe up to 1 level of 2-nesting.
We fix a countable universe of propositions (Pi) that corresponds to sentences of T . The elements of this universe can be inhabited either by constructions or justifications. We will need, accordingly, two kinds of inhabitation relations for each proposition. We will be writing M : φ for a construction M of type φ in T . We will be writing j : Just φ to express the fact that j is a justification (proof in T j) of the proposition φ. When there is no confusion we will be abbreviating this by j :: φ. A construction in M : φ in T does not entail its necessity: to this aim, a corresponding justification j : Just φ from T j has to be obtained. Vice versa, the justification (j) of φ in T j alone entails its validity but not its admissibility in T (constructive necessity ). This is expressed by the proposition – type 2jφ. A construction of 2jφ can be obtained only when the (weaker) theory T actually “responds” with a construction M of the type φ to the valid fact φ known from T j by deducing j. Hence, once (and only if) we have j :: φ then 2jφ can be regarded

7 One could alternatively use an additional constant symbol null and write null;Γ ▶IPC to denote reasoning purely in T and, thus, in absence of any metatheoretic environment.

as a well formed proposition. The stronger theory might be able to judge about 2jφ (given j :: φ) and prove e.g, u :: 2jφ. In that case T j “knows” that φ is admissible in T . In other words, when reasoning with justifications, the universe of types is contextual. To speak about an admissible (or, constructive) necessity of a proposition we require the existence of a corresponding proof object j in T j that establishes its validity.
Reasoning without foundational assumptions: IPC
Reasoning about the implicational fragment of the constructive theory (T ), without formulating provability statements, is done within the implicational fragment of the simply typed lambda calculus. We start by giving the grammar for the metavariable φ used in the rules.
φ := Pi|φ → φ
The calculus is presented by introducing: the universe of types Prop0; rules for constructing well-formed contexts of simple propositional assumptions Γ0; the rules governing ▶IPC.




Pi ∈ Prop0

Atom0
φ1 ∈ Prop0	φ2 ∈ Prop0

φ1 → φ2 ∈ Prop0

Impl0






nil ▶IPC wf

Nil0
Γ0 ▶IPC wf	φ ∈ Prop0


Γ0,x : φ ▶IPC wf

Γ0-Exp




Γ0 ▶IPC wf	x : Pi ∈ Γ0 Γ0 ▶IPC x : Pi

Γ-Refl



Γ0,x : φ1 ▶IPC M : φ2
Γ0 ▶IPC M : φ1 → φ2	Γ0 ▶IPC Mj : φ1

Γ0 ▶
IPC
λx : φ1. M : φ1
→I
→ φ2
Γ0 ▶
IPC
→E
(MM ): φ2

Reasoning in the Presence of Foundations: A calculus of Justifications J
Reasoning in the presence of minimal foundations corresponds to reasoning on the existence of proof objects in the foundational theory T j. The minimal foundational assumptions from the logical point of view is that T j “knows” at least as much logic as T does. The more non-logical axioms in T , the more the specifications T j should satisfy (one needs stronger foundations to justify stronger theories). Abstracting

from any particular T and T j, and assuming only that T incorporates minimal logic, the specifications about existence of proofs in T j are:
to have “enough” types to provide – at least – an intended interpretation of every type φ of T to a unique type Just φ. In other words a subset of the types of T j should serve as interpretations of types in T ;
to have – at least – proof objects for all the instances of the axiomatic charac- terization of the IPC fragment described above; 8
to include some modus ponens rule which translates as: the existence of proof objects of types Just (φ → ψ) and of type Just φ in T j should imply the existence of a proof object of the type Just φ.

Minimal Justiﬁcation Logic J-Calc1
Under these minimal requirements, we develop a minimal justification logic that is able to realize modal reasoning as reasoning on the existence of links between proofs of T and T j. We first realize modal reasoning restricted to formulae of degree (i.e. level of 2-nesting) 1. Such a calculus will be used as a base to build a full modal calculus with justifications for formulae of arbitrary degree. Here is the grammar for the metavariables appearing below:

φ :=Pi|2jφ|φ1 → φ2 j :=si|C|j1 ∗ j2
t :=xi|λxi : φ.t|Js :: φ.t
C :=K[φ1, φ2]|S[φ1, φ2, φ3]|C1 ∗ C2
π :=Πs :: φ1. φ2|Πs :: φ1. π 
T :=φ|Just φ|π s :=si
x :=xi



Reasoning on minimal foundations J0
Reasoning about such a minimal metatheory is axiomatized in its own turnstile (▶J ). 9 Henceforth, judgments on the justificational type universe of J0 (corre- sponding to formualae in the (co-)theory T j) together with wf predicate for Δ0 contexts go as follows:


8 If we extend our fragment we should extend our specifications accordingly but this can be easily done directly as in full justification logic. We choose to remain within this fragment for economy of presentation.
9 This is the part of the calculus that corresponds directly to the algebra of justifications restricted to the applicative fragment.







nil ▶J0 wf

Nil
Δ0 ▶J0 wf	Δ0 ▶J0 φ ∈ Prop0
Δ0 ▶J0 Just φ ∈ jtype0

Simple



Δ0 ▶J0 Just φ ∈ jtype0	s /∈ Δ0 Δ0,s :: φ ▶J0 wf

δ0-App
Δ0 ▶J0 wf	s :: φ ∈ Δ Δ0 ▶J0 s :: φ

δ0-Refl


We add logical constants to satisfy the requirement that J0 includes an axiomatic characterization of – at least – a fragment of IPC. Following justification logic, we define a signature of polymorphic constructors including K, S from combinatory logic. The values of those constructors are axiomatic constants that witness exis- tence of proofs in T j of all instances of the corresponding logical validities. This axiomatic characterization of intuitionistic logic in J0 together with rule scheme Times (applicativity of justiﬁcations) satisfy the minimal requirement for T j to rea- son logically.


Δ0 ▶J0 Just φ1 → φ2 → φ1 ∈ jtype0
K
Δ0 ▶J0 K[φ1, φ2] :: φ1 → φ2 → φ1
Δ0 ▶J0 Just (φ1 → φ2 → φ3) → (φ1 → φ2) → (φ1 → φ3) ∈ jtype0
S
Δ0 ▶J0 S[φ1, φ2, φ3] :: (φ1 → φ2 → φ3) → (φ1 → φ2) → (φ1 → φ3)




Δ0 ▶J0 j2 :: φ1 → φ2	Δ0 ▶J0 j1 :: φ1

Δ0 ▶J0 j2 ∗ j1 :: φ2

Times



Zipping: J-Calc1 = IPC + J0 + 2−Intro
In this section we introduce J-Calc1 for reasoning on the existence of links i.e. con- structions that witness the existence of proofs both in IPC (T ) and J0 (T j). By constructing a link we have a proof of a constructive necessity of a formula, showing that it is true and valid. Links have types of the form 2jφ where j is a justification of the appropriate type. J-Calc1 realizes modal logic theoremhood in K up to degree 1 (i.e. formulae where its subformula includes up to 1 level of 2).
We start by importing well-formedness judgments for contexts and justificational types (Δ0Wf, JustWf respectively), and for the Prop1 universe and its contexts:




Δ0 ▶J0 wf

Δ0; nil ▶JC1 wf

δ0Wf
Δ0; Γ1 ▶JC1 wf	Δ0 ▶J0 j :: φ

Δ0; Γ1 ▶JC1 j :: φ

Just0Wf

φ ∈ Prop0	Δ0; Γ1 ▶JC1 j :: φ

Δ ;Γ ▶	2jφ ∈ Prop
Prop1-Intro

0	1  JC1	1

Δ0; Γ1 ▶JC1 φ ∈ {Prop0, Prop1}	x /∈ Γ1 Δ0; Γ1,x : φ ▶JC1 wf
Γ1-App

From justifications of formulas in Prop0, we can reason about their admissibility in T . Hence, Γ1 might include assumptions from the sorts Prop0 and Prop1. For the inhabitation of Prop0, Prop1, we first accumulate intuitionistic reasoning extended to the new type universe (Prop1), adapting the rules from Section 3:

Δ0; Γ1 ▶JC1 wf	x : φ ∈ Γ1 Δ0; Γ1 ▶JC1 x : φ






Γ1-Refl



Δ0; Γ1,x : φ1 ▶JC1 M : φ2
→I
Δ0; Γ1 ▶JC1 λx : φ1. M : φ1 → φ2



Δ0; Γ1 ▶JC1
M : φ1 → φ2	Δ0; Γ1 ▶JC1
Mj : φ1

Δ0;Γ ▶
JC1
→E
(MM ): φ2


For relating the two calculi, a lifting rule is formulated for turning strictly Prop0 judgments to judgments on proof links (Prop1). In the rule, the ]-operator ensures that context list ] Γ includes assumptions strictly in Prop0. The operator ] can be viewed as the opposite of lift operation applied on context lists erasing one level of boxed assumptions at the top level as described below.
] Γ := match Γ with
nil ⇒ nil
| Γj, xj : 2jφi ⇒ ] Γj, xi : φi
|Γj,  ⇒ ] Γj

A corresponding iterative let-binding construct (let∗) is introduced simultaneously with the context lifting. The purpose of the iterative let binding is to extract the target(s) (T j terms) of existing links on subterms (x1 ... xn) of some composite term M in T and compose them to the target of the whole term M creating its residual. We show the operation of this construct in the example from section 5.



let∗ Γ :=
match Γ with
nil ⇒ let () = ()
| Γj, xj : 2jφi ⇒ (let∗ Γj) in let link(xi, ji)= xj
i	i
|Γj,  ⇒ let∗ Γj The 2-Introduction rule goes as follows:
; ] Γ1 ▶JC1 M : φ	Δ0; Γ1 ▶JC1 j :: φ
2-Intro
Δ ;Γ ▶	(let∗ Γ) in link (M, j): 2jφ
0	1  JC1

Finally, under empty Γ1, we are permitting abstraction from a non-empty Δ0. The resulting abstractions (J−terms), as we will see, are the inhabitants of modal types and correspond to linking processes. Their typing is, naturally, of Π-kind since the typing of a link is sensitive to its target code. We introduce Π-formation and inhabitation rules:



Δ0,s :: φ1; ▶JC1 φ2 ∈ {Prop0, Prop1}
Δ0; ▶JC1 Πs :: φ1.φ2 ∈ Π

Π type0
Δ0,s :: φ1; ▶JC1 π ∈ Π Δ0; ▶JC1 Πs :: φ1.π ∈ Π

Π type1



Δ0,s :: φ; ▶JC1 t : T

Δ0; ▶JC1 Js :: φ. t : Πs :: φ.T

Π-Intro



Δ0; ▶JC1 t : Πs :: φ.T	Δ0; ▶JC1 j :: φ
Δ0; ▶JC1  (t j): T[s := j]

Π-Elim


Computational Motivation: A type system for sepa- rate compilation
In this section, we show how J-Calc can be viewed as a type system for program generation in typed languages that support separate compilation (modular program- ming or external function calls). These languages follow the client/ sever approach to programming: client code, can refer to code definitions implemented by the server elsewhere; the server can be some module or even another language providing the required function calls, but it needs not know the details of the implementation (encapsulation). A challenge in such a system is to provide a mechanism of sepa- rate compilation such that the client (or, source) code is compiled independently of changes in the implementation of the server. In what follows we present J-Calc as

a type system for linking processes in such a setting. Following our language: the constructs of T represent here client (or source) expressions and constructs of T j represent target (or server) code expressions. Our linking by way of the 2-Intro rule linking processes generators that consume different implementations from the server and link them with constructs of the source. We show, following a textbook exam- ple for modules, that our type system provides the abstraction required for such a language so that client code needs to be compiled once and only, independently of the different implementations that the server module might provide.

Producing generic code
As an example, we will use ML-like module definitions. We start with a definition of a module’s public signature (i.e. the operations provided by the server to the client). Here we provide the signature for a stack of integers.

module type INTSTACK =
sig
type intstack
val Empty: intstack
val push : int->intstack->intstack val pop: int->intstack->intstack
end;;


This signature can be implemented in various ways but our goal is to produce generic code from compiling source code only once. We take for example the source code expression ▶ (push 2 Empty): intstack and show step-by-step the construc- tion of generic code following our calculus. First we factorize the usage of the signature by rewriting the term:

] Γ= x1 : int → intstack → intstack, x2 : intstack ▶ (x1 2 x2): intstack

Secondly, we assume implementations of “missing” code in the validity context,
i.e.
Δ= s1 :: int → intstack → intstack, s2 :: intstack ▶ s1 ∗ 2 ∗ s2 :: intstack

Using the 2-Intro rule we obtain:


Δ; Γ = xj
: 2s1 (int → intstack → intstack), xj
: 2s2 intstack ▶

let link(x1, s1)= xj in let link(x2, s2)= xj in
link(x1 2 x2, s1 ∗ 2 ∗ s2): 2s1∗2∗s2 intstack

Finally, abstracting we get a linking process generator of typing that is sensitive to the different implementations provided by the server:
▶ Js1.Js2. λxj .λxj . let∗ Γ in link(x1 2 x2, s1 ∗ 2 ∗ s2)
1	2
of type:
Πs1.Πs2.2s1 (int → intstack → intstack) → 2s2 intstack → 2s1∗2∗s2 intstack


where
let∗ Γ =deflet link(x1, s1)= xj


in let link(x2, s2)= xj



5.2  Providing implementations
The server might provide different implementations of the instack module signa- ture. The two textbook approaches use lists or arrays of integers. Given different implementations, the initial source code has different computational value since the links that it induces change. Schematically:


link
push −−−→
link
Empty −−−→
Cons: 2Cons(int → intstack → intstack) []: 2[]intstack

link
push 2 Empty −−−→
Cons 2 []: 2Cons*2*[]intstack



link
push −−−→
link
Empty −−−→
Addarr: 2Addarr(int → intstack → intstack) create(): 2create()intstack

link
push 2 Empty −−−→
Addarray 2 create(): 2Addarr*2*create()intstack

Both cases are captured by the generic code we produced giving us the ability of
separate compilation of source and implementation. In the first case we have:
Just[intstack]=List, Just[push]= Cons, Just[Empty]=[]
From which we obtain using 2−Intro the following:
▶ link(Empty, []): 2[]intstack
▶ link(push, Cons): 2Cons(int → intstack → intstack)
Finally, using linking process generator obtained in the previous section and under standard operational semantics for application (β-reduction) and let-binding evalu- ation we link the source code to its residual program using the list implementation:
▶ link(push 2 Empty, Cons*2*[]): 2Cons*2*[]intstack




Analogously, using the exact same code generator, closing Δ with implementa- tions
Just[intstack]= Array Just[push]= addarr Just[Empty]= create() We obtain the links:
▶ link(push, addarr): 2addarr(int → intstack → intstack)
▶ link(Empty, create()): 2create()intstack
And from the previous generic judgment under standard operational semantics for application (β-reduction) and let-binding evaluation we link the source code to its residual program using the Array implementation:
▶ link(push 2 Empty, addarr * 2 * create()): 2addarr*2* create()intstack
Note that the client code does not need to recompile. Our generic code construc- tion provides the expressive means to evaluate source contextually given different implementations of the module signature.
The Full Calculus: J-Calc
J-Calc1 motivates the generalization to modal reasoning of arbitrary nesting: J-Calc. To allow such generalization, we need justifications of types of the form Just 2jφ. Let us revise: If φ is a proposition (or, a sentence in the language of T ), then Just φ corresponds to the intended interpetation of φ in some (co-)theory T j. In J-Calc1 we could reason logically about the constructive admissibility of (valid according to T j) facts of T . The existence of a link of a proof in T with an existing proof of the same type in T j would lead to constructions of a type of the form 2jφ with φ a simple type. To get modal theoremhood of degree 2 or more we have to assume that T j can express the existence of such links in itself. That is to say that T j can express the provability predicates both of T and of itself. Hence, supposing that j :: φ, we can read a justification term of type Just 2jφ as a witness of a proof in T j of the fact ∃x.ProofT (x, φ) ∧ ∃x.ProofT ′ (x, Just φ) expressed in T j. We will specify which of those types T j is expected to capture by introducing additional appropriate constants. Having this kind of justifications we can obtain Propi for any finite i as slices of a type universe in a mutual inductive construction. Schematically: Prop0 ⇒ Just Prop0 ⇒ Prop1 ⇒ Just Prop1 and so on. This way we obtain full minimal justification logic. As different kinds of judgments are kept separated by the different typing relations, we do not need to provide distinct calculi as we did for J-Calc1 but we provide one “zipped” calculus directly. 10

10 In fact, adjoining Γ contexts when reasoning within justifications is pure weakening so we could have kept those judgments separated in a single–context ▶ relation. We gain something though: we can squeeze two

Justiﬁcational (Validity) Judgments
The justificational type system has to include: judgments on the wellformedness of contexts (wf); 11 judgments on what T j can reason about (jtype) under the require- ment that it is a metatheory of T ; judgments on the construction of the justifica- tional type universe (jtype) and minimal requirements about its inhabitation (i.e, a minimal signature of logical constants). The grammar of terms is the same as in section 4.1, the difference now is that the restrictions on the Prop universe are dropped.
We introduce progressively: formation rules for Prop; the formation rule for jtype; rules to build well-formed contexts of propositions and justifications (where we will be abbreviating using the following equational rule: nil, s1 :: φ1, s2 :: φ2,... =def s1 :: φ1, s2 :: φ2,... ).




nil; nil ▶JC wf

NIL
Δ; Γ ▶JC wf


Δ; Γ ▶JC Pi ∈ Prop

Atom

Δ; Γ ▶JC φ1 ∈ Prop	Δ; Γ ▶JC φ2 ∈ Prop	Δ; Γ ▶JC j :: φ

Δ; Γ ▶JC φ1
→ φ2
∈ Prop
Impl
Δ; Γ ▶JC
2jφ ∈ Prop Box



Δ; Γ ▶JC φ ∈ Prop

Δ; Γ ▶JC Just φ ∈ jtype

Jtype
Δ; Γ ▶JC Just φ ∈ jtype	s /∈ Δ Δ,s :: φ;Γ ▶JC wf

δ-App



Δ; Γ ▶JC φ ∈ Prop	x /∈ Γ Δ0; Γ,x : φ ▶ wf

Γ-App


Prop Inhabitation
Here is the first part of logical propositional reasoning of the system.


Δ; Γ ▶JC wf	x : φ ∈ Γ Δ; Γ ▶JC x : φ

Γ-Refl


Δ; Γ,x : φ1 ▶JC M : φ2
→I
Δ; Γ ▶JC λx : φ1. M : φ1 → φ2
Δ; Γ ▶JC M : φ1 → φ2	Δ; Γ ▶JC Mj : φ1

Δ; Γ ▶JC
→E
(MM ): φ2




premises (δ ▶ j :: φ, δ; Γ ▶ wf) to a single one (δ; Γ ▶ j :: φ).
11 Analogous treatments of judgments on the validity of contexts can be found e.g. in [26].

jtype Inhabitation
Now we move to the core of the system. In the judgments below we provide the constructions of canonical elements of justificational types (jtype). The judgments reflect the minimal requirements for T j to be a metatheory of some T as presented in Section 4.1.1 together with specifications on internalizing proof links reasoning in itself. More specifically, we demand that T j can capture reasoning on links (between proof objects of T and itself) within itself and also, internalize modus ponens of T . To capture these provability conditions we add the constant constructors ! (bang ) and Kappa. Although introduction of links is axiomatized in the next section, the judgments concerning the ! and Kappa constructors should be viewed in conjunction with 2 − Intro. They witness the fact that T j internalizes modus ponens (of T ) and linking existence (again of T ).


Δ; Γ ▶JC Just φ1 → φ2 → φ1 ∈ jtype
K
Δ; Γ ▶JC K[φ1, φ2] :: φ1 → φ2 → φ1
Δ; Γ ▶JC Just (φ1 → φ2 → φ3) → (φ1 → φ2) → (φ1 → φ3) ∈ jtype
S
Δ; Γ ▶JC S[φ1, φ2, φ3] :: (φ1 → φ2 → φ3) → (φ1 → φ2) → (φ1 → φ3)


Δ; Γ ▶JC j2 :: φ1 → φ2	Δ; Γ ▶JC j1 :: φ1
Δ; nil ▶JC M : 2Cφ

Δ ▶J j2 ∗ j1 :: φ2
Times
Bang
Δ; Γ ▶JC !C :: 2Cφ



Δ; Γ ▶JC
Just
2j′
φ1 ∈
jtype	Δ; Γ ▶JC
Just 2j(φ1
→ φ2) ∈ jtype

Δ; Γ ▶
Kappa	j	j
j′	j∗j′ φ
Kappa

JC	[j, j , φ1, φ2] :: 2 (φ1 → φ2) → 2 φ1 → 2	2




Proof Links
Our next task is to formulate the main rule for the K modality as a lifting rule for going from reasoning about constructions to reasoning about admissibility of validities via proof linking. To reflect the modal axiom K in Natural Deduction we have to obtain a rule that reflects the following provability principle:



φ1 true,..., φn true ▶ φ true	φ1 valid,..., φn valid ▶ φ valid


2φ1 true,..., 2φn true,... ▶ 2φ true

2-Intro


We proceed with giving inhabitants analogously to what was explained in Section

4.1.2: 12
Δ; ] Γ ▶JC M : φ	Δ; Γ ▶JC j :: φ
2-Intro
Δ; Γ ▶JC (let∗ Γ) in link (M, j): 2jφ
Finally, abstraction from Δ contexts over empty Γ contexts applies in the ex- tended type universe:


Δ,s :: φ; ▶JC t : T

Δ; ▶JC Js :: φ. t : Πs :: φ.T

π-Intro
Δ; ▶JC t : Πs :: φ.T	Δ0; ▶JC j :: φ


Δ; ▶JC (t j): T[s := j]

π-Elim


Further Results and Conclusions
Standard meta-theoretical results can be proven for J-Calc. We just mention here that the iterative let operator satisfies standard commutativity with the substitution rule for justifications and that structural rules can be proven. We will be skipping the index in ▶JC.
Theorem 7.1 (Weakening) J-Calc satisﬁes Weakening in both modes of reason- ing:
If Δ; nil ▶ j :: φ, and Δ; Γ ▶ wf then, Δ; Γ ▶ j :: φ.
If Δ; Γ ▶ j :: φ, then Δ,s :: φj;Γ ▶ j :: φ, with s fresh.
If Δ; Γ ▶ M : φ, then Δ; Γ,x : φj ▶ M : φ, with x fresh.
Proof. For all items by structural induction on the derivation trees of the two kinds of constructions. The proof of the first is vacuous since Γ contexts are irrelevant in justification formation. As a result, its inverse can also be shown.	2
Theorem 7.2 (Contraction) J-Calc satisﬁes Contraction:
If Δ,s :: φ, t :: φ; nil ▶ j :: φj, then Δ,u :: φ; nil ▶ j[s ≡ t/u] :: φj.
If Δ,s :: φ, t :: φ;Γ ▶ wf, then, Δ,u :: φ; Γ[s ≡ t/u] ▶ wf.
If Δ,s :: φ, t :: φ;Γ ▶ M : φj, then, Δ,u :: φ; Γ[s ≡ t/u] ▶ M [s ≡ t/u]: φj[s ≡
t/u].
If Δ; Γ,x : φ, y : φ ▶ M : φj, then Δ; Γ,z : φ ▶ M [x ≡ y/z]: φj.
Proof. First item by structural induction on the derivation trees of justifications (validity judgments). Note, as mentioned in the previous theorem, that it can be

12 We prefer this to the mouthful but equivalent:
δ; x1 : φ1,..., xi : φi as Γ ▶ M : φ
6φi ∈ Γ. δ′; nil ▶ ji :: φi	δ′; nil ▶ j :: φ	δ′; x1 : 2j1 φi,..., 2ji φi ▶ wf
2-Intro
δ′; x1 : 2j1 φi,..., 2ji φi ▶ JBox j : 2jφ

shown for arbitrary Γ. For the second, nested induction on the structure of context Γ (treated as list) and the complexity of formulas. Vacuously in the nil case. For the non-empty case: case analysis on the complexity of the head formula using the inductive hypothesis on the tail. Cases of interest are with 2sφ or 2tφ as subformulae. Use the previous item and judgments for wf contexts. For the third and the fourth, again by structural induction on the derivation.	2
In a similar fashion we can show the more general:
Theorem 7.3 (Preservations of Types under Substitution) J-Calc preserves types under substitution and simultaneous substitution:
If Δ; Γ,x : φ ▶ t : T, and Δ; Γ ▶ M : φ then Δ; Γ ▶ t[x/M ]: T
If Δ,s :: φ, Δj;Γ ▶ t : T, and Δ; ▶ j :: φ then Δ, Δj[s/j]; Γ[s/j] ▶ t[s/j]: T[s/j]
We additionally mention that the calculus satisfies permutation for both contexts Δ and Γ with the restriction that the permutations in Δ should not break the chain of dependencies. Lastly, we mention here that under standard let-binding evaluation and application as β-reduction within a dependently typed framework, a small step operational semantics has been developed and progress and preservation can be shown.
For future work, we plan to extend the computational relevance of the full cal- culus (JCalc) by establishing its connection with higher-order module systems (e.g. where module signatures can refer to other module signatures which, in turn, are implemented by a third module). Linking processes in such systems would utilize our type system in full. Cut-elimination results are currently under development.

References
Zine El abidine Benaissa, Eugenio Moggi, Walid Taha, and Tim Sheard. Logical modalities and multi- stage programming.
Jesse Alt and Sergei Artemov. Reflective λ-calculus. Technical Report CFIS 2000-06, Cornell University, 2000.
Sergei N. Artemov. Logic of proofs. Annals of Pure and Applied Logic, 67(1–3):29–59, May 1994.
Sergei N. Artemov. Operational modal logic. Technical Report MSI 95–29, Cornell University, December 1995.
Sergei N. Artemov. Explicit provability and constructive semantics. Bulletin of Symbolic Logic, 7(1):1– 36, March 2001.

Sergei N. Artemov. Unified semantics for modality and λ-terms via proof polynomials. In Kees Vermeulen and Ann Copestake, editors, Algebras, Diagrams and Decisions in Language, Logic and Computation, volume 144 of CSLI Lecture Notes, pages 89–118. CSLI Publications, Stanford, 2002.
Sergei N. Artemov. Justification logic. In JELIA, pages 1–4, 2008.
Sergei N. Artemov. The ontology of justifications in the logical setting. Stud. Log., 100(1-2):17–30, April 2012.

Sergei N. Artemov and Lev D. Beklemishev. Provability logic. In D. M. Gabbay and F. Guenthner, editors, Handbook of Philosophical Logic, 2nd Edition, volume 13, pages 189–360. Springer, 2005.
Sergei N. Artemov and Eduardo Bonelli. The intensional lambda calculus. In Sergei N. Artemov and Anil Nerode, editors, Logical Foundations of Computer Science, International Symposium, LFCS 2007, New York, NY, USA, June 4–7, 2007, Proceedings, volume 4514 of Lecture Notes in Computer Science, pages 12–25. Springer, 2007.


Steven Awodey and Florian Rabe. Kripke Semantics for Martin-Lo¨f’s Extensional Type Theory. In
TLCA’09, pages 249–263, 2009.
Gilles Barthe and Thierry Coquand. An Introduction to Dependent Type Theory. Lecture Notes in Computer Science, pages 1–41.

Gianluigi Bellin, Valeria de Paiva, and Eike Ritter. Extended curry-howard correspondence for a basic constructive modal logic. In Proceedings of Methods for Modalities, 2001.
George S. Boolos. The Logic of Provability.

Samuel R. Buss. Chapter ii first-order proof theory of arithmetic. In Samuel R. Buss, editor, Handbook of Proof Theory, volume 137 of Studies in Logic and the Foundations of Mathematics, pages 79 – 147. Elsevier, 1998.
Melvin Fitting. The logic of proofs, semantically. Annals of Pure and Applied Logic, vol. 132(1), pp. 1-25, 2005.
Jean Y. Girard, Paul Taylor, and Yves Lafont. Proofs and types. Cambridge University Press, New York, NY, USA, 1989.
Kurt G¨odel. On Formally Undecidable Propositions of Principia Mathematica and Related Systems. Dover Publications, April 1992.
Jean Goubault-Larrecq. On computational interpretations of the modal logic S4. Technical report, Institut fur Logik, Komplexit¨at und Deduktionssysteme, Universitat, 1996.
Robert Harper. Programming in Standard ML. 1998.

Per Martin-Lof. Constructive Mathematics and Computer Programming. In 6-th International Congress for Logic, Methodology and Philosophy of Science, 1979, pages 153–175. North–Holland, 1982.
Per Martin-Lo¨f. Intuitionistic Type Theory. Bibliopolis, Naples, 1984.
Per Martin-Lof. On the Meanings of the Logical Constants and the Justifications of the Logical Laws.
Nordic Journal of Philosophical Logic, 1(1):11–60, May 1996.
Aleksandar Nanevski, Frank Pfenning, and Brigitte Pientka. Contextual modal type theory. ACM Trans. Comput. Logic, 9(3):23:1–23:49, June 2008.

Bengt Nordstrom, Kent Petersson, and Jan M. Smith. Programming in Martin-L¨of ’s Type Theory: An Introduction. Oxford University Press, USA, July 1990.
Ulf Norell. Dependently typed programming in Agda. In Lecture Notes from the Summer School in Advanced Functional Programming, 2008.
Rohit Parikh. Existence and feasibility in arithmetic. J. Symb. Log., pages 494–508, 1971.
Frank Pfenning and Rowan Davies. A judgmental reconstruction of modal logic. Mathematical. Structures in Comp. Sci., 11(04):511–540, August 2001.
Peter Smith. An introduction to G¨odel’s theorems, Cambridge University Press, 2007.

Morten Heine B. Sørensen and Pawel Urzyczyn. Lectures on the Curry-Howard Isomorphism, volume 149 of Studies in Logic and the Foundations of Mathematics. Elsevier, 2006.
