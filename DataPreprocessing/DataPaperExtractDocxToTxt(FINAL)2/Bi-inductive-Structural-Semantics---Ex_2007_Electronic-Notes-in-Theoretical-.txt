Electronic Notes in Theoretical Computer Science 192 (2007) 29–44	
www.elsevier.com/locate/entcs


Bi-inductive Structural Semantics
(Extended Abstract)

Patrick Cousot1
D´epartement d’informatique, E´cole normale sup´erieure, 45 rue d’Ulm, 75230 Paris cedex 05, France
Radhia Cousot2
CNRS & E´cole polytechnique, 91128 Palaiseau cedex, France

Abstract
We propose a simple order-theoretic generalization of set-theoretic inductive definitions. This generalization covers inductive, co-inductive and bi-inductive definitions and is preserved by abstraction. This allows the structural operational semantics to describe simultaneously the finite/terminating and infinite/diverging be- haviors of programs. This is illustrated on the structural bifinitary small/big-step trace/relational/operational semantics of the call-by-value λ-calculus.
Keywords: fixpoint definition, inductive definition, co-inductive definition, bi-inductive definition, structural operational semantics, SOS, trace semantics, relational semantics, small-step semantics, big-step semantics, divergence semantics, abstraction.


Introduction
The connection between the use of fixpoints in denotational semantics [17] and the use of rule-based inductive definitions in axiomatic semantics [10] and structural operational semantics (SOS) [19,20,21] can be made by a generalization of inductive definitions [1] to include co-inductive definitions [8]. It is then
possible to generalize natural semantics describing finite input/output behaviors
[12] so as to also include infinite behaviors [7]. This is necessary since the definition of the infinite behaviors cannot be derived from the finite big-step SOS behaviors.

1 Patrick.Cousot@ens.fr, www.di.ens.fr/˜cousot/
2 Radhia.Cousot@polytechnique.fr, www.polytechnique.edu/Radhia.Cousot/

1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2007.08.015

Example 1.1 Let us consider the choice operator E1 | E2 where the evaluation of E1 either terminates (returning the value a, written E1 =⇒ a) or does not terminate (written E1 =⇒ ⊥). Similarly, the big-step semantics of E2 is E2 =⇒ b for a terminating evaluation returning b or E2 =⇒ ⊥ for non-termination. Let us consider several possible semantics for the choice operator:
Nondeterministic: an internal choice is made initially to evaluate E1 or to evaluate
E2;
Parallel: evaluate E1 and E2 concurrently, with an unspecified scheduling, and return the first available result a or b;
Mixed left-to-right: evaluate E1 and then either return its result a or evaluate E2
and return its result b;
Mixed right-to-left: evaluate E2 and then either return its result b or evaluate E1
and return its result a;
Eager: evaluate both E1 and E2 and return either results if both terminate.
The corresponding finite big-step behaviors, as described in natural semantics [12], are all defined as follows:
a | b =⇒ a	a | b =⇒ b	.
But for the case ⊥ | ⊥ =⇒ ⊥, the infinite behaviors are all different:

Since the natural semantics defines the finite behaviors but not the diverging behav- iors, an interpretation of the big-step evaluation rules as Horn clauses implemented in Prolog [2,9] will have its diverging behaviors determined by the implementation (e.g. Prolog interpreter with left-to-right evaluation).	 
The paper develops and illustrates the use of ”bi-inductive” definitions in opera- tional semantics which enable both finitary and infinitary behaviors to be described simultaneously [7,8].
The general methodology consists in extending Hilbert proof systems [1] by replacing the powerset ⟨℘(U ), ⊆⟩ of the universe U by a partial order ⟨D, ±⟩. Beyond the classical inductive definitions ⟨℘(U ), ⊆⟩, this extension includes the co-inductive definitions ⟨℘(U ), ⊇⟩ and bi-inductive definitions mixing inductive and co-inductive definitions [7,8]. This extension also copes with compositional structural definitions as found in denotational semantics or SOS. This is illustrated

by definitions of the semantics of the call-by-value λ-calculus.
We introduce an original big-step trace semantics that gives operational mean- ing to both convergent and divergent behaviors of programs. The compositional structural definition mixes induction for finite behaviors and co-induction for infinite behaviors while avoiding duplication of rules between the two cases. This big-step trace semantics excludes erroneous behaviors that go wrong. The other semantics are then systematically derived by abstraction.
The big-step trace semantics is first abstracted to a relational semantics and then to the standard big-step or natural semantics. These abstraction are sound and complete in that the big-step trace and relational semantics describe the same converging or diverging behaviors while the big-step trace and natural semantics describe the same finite behaviors. The big-step trace semantics is then abstracted into a small-step semantics, by collecting transitions along traces. This abstraction is sound but incomplete in that the traces generated by the small-step semantics describes convergent, divergent, but also erroneous behaviors of programs. This shows that trace-based operational semantics can be much more informative that small-step operational semantics.

Bi-inductive structural definitions and their abstrac- tion
Structural order-theoretic inductive deﬁnitions
We introduce different forms of structural order-theoretic inductive definitions and prove their equivalence.
We formalize the syntax of a language L as a binary relation ≺ on L to be understood as the “strict syntactic subcomponent” relation on L. ⟨L, ≺⟩ is therefore a well-founded set, ≺ is irreflexive (inducing the reflexive “), and ≺ has finite left images ∀l ∈ L : |{l' ∈ L | l' ≺ l}| ∈ N (|S| is the cardinality of set S, N is the set of
natural numbers). Hence we can write l ::= l1,..., ln for the tuple of elements

  l'≺l l' = l1,..., ln such that {l1,..., ln} = {l' ∈ L | l' ≺ l}.
For example, fo.r the language L of lambda terms a, b, ... ::= x | λ x
. a | a b, we

can define a ≺ λ x a, a ≺ a b and b ≺ a b so a b ::= a, b. In case no structural i.e.
syntax-directed reasoning is needed, L can be chosen as a singleton and ≺ as false. For each “syntactic component” l ∈ L, we consider a semantic domain ⟨Dl, ±l,
⊥l, Hl⟩ which is assumed to be a directed complete partial order (dcpo).
For each “syntactic component” l ∈ L, we consider variables Xl, Yl, . . . ranging over the semantic domain Dl. We drop the subscript l when the corresponding semantic domain is clear from the context (e.g. the semantic domain is the same for all “syntactic components” i.e. ∀l ∈ L : Dl = D).
For each “syntactic component” l ∈ L, we let Δl be indexed sequences (totally ordered sets). We write  i∈ΔÆ xi when considering the sequence ⟨xi, i ∈ Δl⟩ ∈ Δl '→ S of elements of a set S as a vector of  i∈ΔÆ S.
For each element i ∈ Δl of the sequence, we consider transformers F i ∈ Dl ×

Dl1 .. .×Dln '−→ Dl where n = |{l ∈ L | l ≺ l}| and {l1,..., ln} = {l ∈ L | l ≺ l}.
'	'	'	'
When n = 0, we have F i ∈ Dl '−→ Dl.
The transformers are assumed to be ±l-monotone in their first parameter, that is ∀i ∈ Δl, l1,..., ln ≺ l, X, Y ∈ Dl, X1 ∈ Dl1 ,..., Xn ∈ Dln : X ±l Y =⇒ F i(X, X1,..., Xn) ±l F i(Y, X1,..., Xn).

l	l
For each “syntactic component” l ∈ L, the join Y
∈ (Δl '−→ Dl) '−→ Dl is

assumed to be componentwise ±l-monotone (∀⟨Xi, i ∈ Δl⟩ : ∀⟨Yi, i ∈ Δl⟩ : (∀i ∈
Δl : Xi ±l Yi) =⇒ jl (  Xi) ±l jl (  Yi)). The join operator is used to gather
i∈ΔÆ	i∈ΔÆ

alternatives in formal definitions. For brevity, we write YÆ (  Xi)= jl
Xi, leaving

i∈ΔÆ	i∈ΔÆ
implicit the fact that the Xi should be considered in the total order given by the sequence Δl.
Most often, the order of presentation of these alternatives in the formal definition is not significant. In this case, Δl is just a set and the join may often be defined in term of a binary join Y ∈ (Dl × Dl) '−→ Dl, which is assumed to be associative,

commutative, and
Æ
±l-monotone, as Y
( 
i∈ΔÆ
Xi)
l i∈ΔÆ
Xi. The binary join may be

different form the least upper bound (lub) Hl of the semantic domain Dl.
A ﬁxpoint deﬁnition has the form

∀l ∈ L : S
JlK = lfp±Æ λ X . j F i(X,  S
Jl'K)

ƒ	l	l
i∈ΔÆ
ƒ
l'≺l

where lfp± is the partially defined ±-least fixpoint operator on a poset ⟨P, ±⟩. To emphasize structural composition, we also let {l1,..., ln} = {l' ∈ L | l' ≺ l} and write

∀l ∈ L : S
Jl ::= l1,...,l K = lfp±Æ λ X . j F i(X, S Jl1K,..., S Jl
K) .

ƒ	n	l	l	ƒ	ƒ  n
i∈ΔÆ

Lemma 2.1 ∀l ∈ L : Sƒ JlK is well deﬁned.
as Djefinitions needing no fixpoint or join can wjithal be encompassed as fixpoints such
F i(S Jl1K,..., S Jl K) = lfp±Æ λ X .	F i(S Jl1K,..., S Jl K) or without

l	l	ƒ	ƒ  n
i∈ΔÆ
l	l	ƒ	ƒ  n
i∈ΔÆ

join F i(S Jl1K,..., S Jl
K) = lfp±Æ λ X . j F i' (S Jl1K,..., S Jl
K).

l	ƒ	ƒ  n
l	l	ƒ	ƒ  n
i'∈{i}

An equational deﬁnition has the form:
⟨Se l , l ∈ L⟩ is the componentwise ±l-least ⟨Xl, l ∈ L⟩ satisfying the system of equations
⎧⎪ Xl = j F i(Xl,  '	Xl' )
⎪⎩ l ∈ L	.

A constraint-based deﬁnition has the form:
⟨Se l , l ∈ L⟩ is the componentwise ±l-least ⟨Xl, l ∈ L⟩ satisfying the system of constraints (inequations)

⎧⎪ j
F i(Xl,  '
Xl' ) ±l Xl

⎪⎩ l ∈ L	.
A rule-based deﬁnition is a sequence of rules of the form


Xl
F i(Xl,   SrJl'K)
±Æ	l ∈ L,i ∈ Δl

l'≺l

where the premise and conclusion are elements of the ⟨Dl, ±l⟩ cpo. When under- standing the rule in logical form (where the premise is a statement that is assumed to be true and from which a conclusion can be drawn), the following form might be preferred.


	Xl ±l SrJlK	
F i(Xl,  SrJl'K) ±l SrJlK

l ∈ L, Xl

∈ Dl,i ∈ Δl

l'≺l

If F i does not depend upon the premise Xl, it is an axiom. In such presentations,
the join Y of the alternatives is left implicit 3 . To make it explicit, we rewrite such definitions in the form

	Xl ±l SrJlK	

(1)


l i∈ΔÆ

F i(Xl,
 

l'≺l

SrJl'K) ±l SrJlK
±Æ	l ∈ L, Xl ∈ Dl .

The formal definition of the join makes explicit whether the order of presentation of the rules does matter, or not. When it doesn’t, the join can be defined using a binary associative and commutative join. This binary join can even be left implicit and, by associativity and commutativity, the rules can be given in any order. This will be the case for our examples.
A D ∈ Dl is provable if and only if it has a proof that is a transfinite sequence 4


±l	l
F i(.
Dβ,   SrJl'K).

i∈ΔÆ
β<δ
l'≺l

The meaning of a rule-based definition (1) is

3 This is the case in classical Hilbert’s formal systems.
4 In the classical case [1], the fixpoint operator is continuous whence proofs are finite.


SrJlK  .l{D ∈ Dl | D is provable} .
The above order-theoretic inductive definitions are all equivalent:
Theorem 2.2 ∀l ∈ L : SJlK  Sƒ JlK = SeJlK = ScJlK = SrJlK.
This generalization of [1] could also include a game-theoretic version. The closure-condition version [1] is also easy to adapt.
Example 2.3 The classical inductive definition [1] of the subset S of a universe U by rules  Pi  i ∈ I, where Pi ⊆ U and ci ∈ U , i ∈ I can be written 	X ⊆ S	 ⊆,
i ∈ I or Pi ⊆ X,  X ⊆ S ⊆, i ∈ I that is Pi ⊆ S ⊆, i ∈ I for short. So ⟨L, “⟩  ⟨•, =⟩,
ci ∈ S	ci ∈ S 
⟨D•, ±•, ⊥•, H•⟩  ⟨℘(𝐶), ⊆, ∅, ∪⟩, Δ•  I, F i ∈ ℘(U ) '→ ℘(U ) is F i(X)  {ci |

Pi ⊆ X} and
j• 
•
thus defining S = lfp⊆ λ X
•
{ci | i ∈ I ∧ Pi ⊆ X}.	 


Bi-semantic domains
To account for terminating/finite and diverging/infinite program behaviors, we consider bi-semantic domains consisting, for each l ∈ L, of a finitary semantic domain
(of finite program behaviors) ⟨D+, ±+, ⊥+, .+⟩ and a infinitary semantic codomain
(of infinite program behaviors) ⟨D−, ±−, ⊥−, .−⟩ which are assumed to be dcpos
[17] (respectively complete lattices). They are combined into a bi-semantic domain (of bifinite program behaviors) Dl thanks to a projection π+ ∈ Dl '→ D+, a coprojection
l	l
π− ∈ Dl '→ D−, and a constructor πl ∈ D+ × D− '→ Dl satisfying ∀x ∈ D+,y ∈
l	l	l	l	l
D− : π+(πl(x, y)) = x and π−(πl(x, y)) = y while ∀X ∈ D : πl(π+(X), π−(X)) = X.
l	l	l	l	l
Examples are the Cartesian product, disjoint union or union of disjoint sets. The bi-semantic domain ⟨Dl, ±l, ⊥l, Hl⟩ is then a dcpo (respectively a complete lattice) by defining X+   π+(X), X−   π−(X), X ±l Y   (X+ ±+ Y +) ∧ (X− ±− Y −),
and . Xi  πl(.+ X+, .− X−).

l i∈I

Abstraction
l i∈I
i		l	i i∈I

We consider a simple form of abstraction based on a continuous abstraction function
α [6], which includes the particular case of a Galois connection [5] (denoted ⟨P,
g	g
“⟩ −←−−−−→− ⟨Q, ±⟩, or ⟨P, “⟩ −←−−−−→−→− ⟨Q, ±⟩ when α is onto, where ⟨P, “⟩ and ⟨Q, ±⟩
are poαsets, and ∀x ∈ P : ∀y ∈α : α(x) ± y ⇐⇒ x “ γ(y)).
Q

For all l ∈ L, we let ⟨D , ± , ⊥ , H ⟩ be dcpos, i
'−→ D
	


l	l	l	l
F l ∈ Dl × Dl1 ... × Dln	l



i ∈ Δl be monotone in their first parameter, and define the abstract semantics Sƒ l
in one of the equivalent forms of Th. 2.2.
If αl ∈ Dl '−→ Dl, we say that the abstract semantics ⟨S l , l ∈ L⟩ is sound with respect to the concrete semantics ⟨S l , l ∈ L⟩ if and only if ∀l ∈ L : αl(S l ) ±l S l . If is complete whenever ∀l ∈ L : SJlK ±l αl(SJlK).

Structural order-theoretic inductive definitions of the semantics of the call-by-value λ-calculus
The syntax of the λ-calculus with constants is

x, y, z,...  ∈  X	variables
c ∈ C	constants (X ∩ C = ∅)
c ::= 0 | 1 | ... 
v ∈ V	values
v ::= c | λ x . a
e ∈ E	errors
e ::= c a | e a 
a, a', a1,..., b,,... ∈ T	terms
a ::= x | v | a a'

We write a[x ← b] for the capture-avoiding substitution of b for all free occurrences of x within a. We let FV(a) be the free variables of a. We define the call-by-value
semantics of closed terms.(without free variables).T  {a ∈ T | FV(a)= ∅}.
The application (λ x a v) of a function λ x a to a value v is evaluated by
substitution a[x ← v] of the actual parameter v for the formal parameter x in the
function body a. This cannot be understood as induction on the pro.gram syntax
since a[x ← v] is not in general a strict syntactic subcomponent of (λ x a v). Hence
the various semantics below cannot be defined by structural induction of the syntax of λ-expressions. So the framework of Sect. 2.1 is instantiated with L = {•} and ≺ is defined to be false on L which prevents the use of structural induction on program syntax. For brevity we omit the void syntactic component • writing e.g. F for F • , D for D•, Δ for Δ•, etc.
We introduce a maximal trace semantics describing terminating and diverging computations. The trace semantics is then abstracted into a relational [20] and then an operational semantics [15]. Each semantics can be defined using small steps or big steps of computation. Each semantics can be defined in fixpoint or rule-based form.
Semantics	Fixpoint definition	Rule-based definition
big-step	small-step	big-step	small-step

Trace	→S	lfp± F→
lfp± f→
Z=⇒	Z ⇒

Relational	ñ	lfp± ñ
Operational	S
lfp± ñ
lfp⊆ f = gfp⊆ f
=⇒	⇒
−A .

Big-step maximal trace semantics of the call-by-value
λ-calculus
We let T٨ (resp. T+, Tω, T𝖺 and T∞) be the set of finite (resp. nonempty finite, infinite, finite or infinite, and nonempty finite or infinite) sequences of terms where ϵ is the empty sequence ϵ • σ = σ • ϵ = σ. We let |σ| ∈ N ∪ {ω} be the length of σ ∈ T𝖺.
|ϵ| = 0. If σ ∈ T+ then |σ| > 0 and σ = σ0 • σ1 • ... • σ|σ|−1. If σ ∈ Tω then |σ| = ω
and σ = σ0 • ... • σn • .. .. Given S, T ∈ ℘(T∞), we define S+  S ∩ T+, Sω  S ∩ Tω and S ± T  S+ ⊆ T + ∧ Sω ⊇ T ω, so that the trace domain ⟨℘(T∞), ±, Tω, T+, H, H⟩ is a complete lattice. For a ∈ T and σ ∈ T∞, we define a@σ to be σ' ∈ T∞ such that ∀i < |σ| : σ' = a σi and similarly σ@a is σ' such that ∀i < |σ| : σ' = σi a.
i	i

Fixpoint big-step maximal trace semantics

The bifinitary trace semantics →S ∈ ℘(T∞) of the closed call-by-value λ-calculus T
can be specified in fixpoint form
→S  lfp± F→


where the set of traces transformer F→ computation

	
∈ ℘(T∞) '→ ℘(T∞) describes big steps of



F→ (S)  {v ∈ T∞ | v ∈ V}∪	(a)
{(λ x . a) v • a[x ← v] • σ | v ∈ V ∧ a[x ← v] • σ ∈ S}∪	(b)
{σ@b | σ ∈ Sω}∪	(c)
{(σ@b) • (v b) • σ' | σ /= ϵ ∧ σ • v ∈ S+ ∧ v ∈ V ∧ (v b) • σ' ∈ S}∪	(d)
{a@σ | a ∈ V ∧ σ ∈ Sω}∪	(e)
{(a@σ) • (a v) • σ' | a, v ∈ V ∧ σ /= ϵ ∧ σ • v ∈ S+ ∧ (a v) • σ' ∈ S} .	(f)
The definition of F→ has (a) for termination, (b) for call-by-value β-reduction, (c)
and (d) for left reduction under applications and (e) and (f) for right reduction under applications, corresponding to left-to-right evaluation. (b), (d) and (f) cope both with terminating and diverging traces. In the framework of Sect. 2.1, we have Δ•  {a, b, c, d, e, f } where F→ i(S), i ∈ Δ• is defined by equation (i). The join operator is chosen in binary form as Y•  ∪.
We observe that (S+  S ∩ T+, Sω  S ∩ Tω so S+ ∩ Sω = ∅)


(2)
⎪⎨ →S+ = F→ (→S+) = lfp⊆ F→ +	where

F→ +(S)  F→ (S+)

⎪⎩ →Sω = (F→ (→S+ ∪ →Sω))ω = gfp⊆ F→ ω	where
F→ ω(S)  (F→ (→S+ ∪ Sω))ω .


The bifinitary trace semantics →S is suffix-closed in that


∀σ ∈ T∞ : a • σ ∈ →S =⇒ σ ∈ →S .

The bifinitary trace semantics →S is total in that it excludes intermediate or result errors

∀a ∈ T :/ 𝖤σ, σ' ∈ T𝖺, e ∈ E : a • σ • e • σ' ∈ →S .
The finite maximal traces are blocking in that the result of a finite computation is always a final value


∀σ ∈ T∞ ∪ {ϵ} : σ • b ∈ →S+ =⇒ b ∈ V .

Rule-based big-step maximal trace semantics
The maximal trace semantics →S can also be defined as follows
a[x ← v] • σ ∈ →S
v ∈ →S,	v ∈ V
(λ x  a) v • a[x ← v] • σ ∈ →S







±,	v ∈ V

σ ∈ →Sω σ@b ∈ →S σ ∈ →Sω a@σ ∈ →S



±





±,	a ∈ V
σ • v ∈ →S+, (v b) • σ' ∈ →S
(σ@b) • (v b) • σ' ∈ →S
σ • v ∈ →S+, (a v) • σ' ∈ →S
(a@σ) • (a v) • σ' ∈ →S

±,	v ∈ V


±,	v, a ∈ V .

Defining →S a  {a • σ | a • σ ∈ →S}, →S+ a  {a • σ | a • σ ∈ →S+}, and →Sω a  {a • σ |
a • σ ∈ →Sω}, we can also write for brevity



v ∈ →SJvK,	v ∈ V

σ ∈ →SωJaK
σ ∈ →SJa[x ← v]K
(λ x . a) v • σ ∈ →SJ(λ x . a) vK
σ • v ∈ →S+JaK, σ' ∈ →SJv bK

±,	v ∈ V


σ@b ∈ →SJa bK σ ∈ →SωJbK a@σ ∈ →SJa bK
±





±,	a ∈ V

(σ@b) • σ' ∈ →SJa bK
σ • v ∈ →S+JbK, σ' ∈ →SJa vK
(a@σ) • σ' ∈ →SJa bK
±,	v ∈ V


±,	a, v ∈ V .

Observe that the inductive definition of →SJaK shou.ld neither be understood as a
structural induction on a (since a[x ← v] /≺ (λ x a) v) nor as action induction
[16] (because of infinite traces). The definition could be split in inductive rules for

termination and co-inductive rules for divergence, as shown in (2), but the above bi-inductive definition avoids the duplication of common rules. Defining a =⇒ σ σ ∈ →SJaK, we can also write
	a[x ← v] Z=⇒ σ	

v Z=⇒ v,	v ∈ V
(λ x . a) v Z=⇒ (λ x . a) v • σ
±,	v ∈ V

	a Z=⇒ σ	
a b Z=⇒ σ@b
	b Z=⇒ σ	
a b Z=⇒ a@σ

±,	σ ∈ T ω


±,	a ∈ V,σ ∈ T ω
a Z=⇒ σ • v,	v b Z=⇒ σ' a b Z=⇒ (σ@b) • σ'
b Z=⇒ σ • v,	a v Z=⇒ σ' a b Z=⇒ (a@σ) • σ'

±,	v ∈ V,σ ∈ T


±, a, v ∈ V,σ ∈ T	.

Abstraction of the big-step trace semantics into the big-step relational semantics of the call-by-value λ- calculus
The relational abstraction of sets of traces is
(3)	α ∈ ℘(T∞) '→ ℘(T × (T ∪ {⊥}))
α(S)  {⟨σ0, σn−1⟩ | σ ∈ S ∧ |σ| = n}∪ {⟨σ0, ⊥⟩ | σ ∈ S ∧ |σ| = ω}
γ ∈ ℘(T × (T ∪ {⊥})) '→ ℘(T∞)
γ(T )  {σ ∈ T∞ | (|σ| = n ∧ ⟨σ0, σn−1⟩ ∈ T ) 𝖵 (|σ| = ω ∧ ⟨σ0, ⊥⟩ ∈ T )}

so that


⟨℘(T∞



g
, ⊆⟩ ←−−−− ⟨℘	×	∪ {⊥}  , ⊆⟩ .
α


The biﬁnitary relational semantics ñ α(→S) ∈ ℘(T × (T ∪ {⊥})) is the relational abstraction of the trace semantics mapping an expression to its final value or ⊥ in case of divergence.
Fixpoint big-step biﬁnitary relational semantics
The bifinitary relational semantics ñ  α(→S)= α(lfp± F→ ) can be defined in fixpoint
form as lfp± ñ where the big-step transformer ñ	(T × (T ∪ {⊥})) '→ ℘(T × (T ∪

F
{⊥})) is
F ∈ ℘

F (T )  {⟨v, v⟩ | v ∈ V}∪ 
{⟨(λ x . a) v, r⟩ | v ∈ V ∧ ⟨a[x ← v], r⟩ ∈ T }∪ 
{⟨(a b), ⊥⟩ | ⟨a, ⊥⟩ ∈ T }∪ 

{⟨(a b), r⟩ | ⟨a, v⟩ ∈ T + ∧ v ∈ V ∧ ⟨(v b), r⟩ ∈ T }∪ 
{⟨(a b), ⊥⟩ | a ∈ V ∧ ⟨b, ⊥⟩ ∈ T }∪ 
{⟨(a b), r⟩ | a, v ∈ V ∧ ⟨b, v⟩ ∈ T + ∧ ⟨(a v), r⟩ ∈ T } .



Theorem 5.1 We have α(F→ (S)) = ñ (α(S)) and so ñ
  α(→S) = α(lfp± F→ ) =

F	S
lfp± ñ .

Rule-based big-step biﬁnitary relational semantics
The big-step bifinitary relational semantics =⇒ is defined as a =⇒ r  ⟨a, r⟩ ∈ α(→S a ) where a ∈ T and r ∈ T ∪ {⊥}. It is

a[x ← v] =⇒ r

v =⇒ v,	v ∈ V

(λ x
. a)	v =⇒ r
±,	v ∈ V, r ∈ V ∪ {⊥}

a =⇒ ⊥ a b =⇒ ⊥ b =⇒ ⊥ a b =⇒ ⊥ 



±





±,	a ∈ V
a =⇒ v,	v b =⇒ r a b =⇒ r
b =⇒ v,	a v =⇒ r a b =⇒ r

±,	v ∈ V, r ∈ V ∪ {⊥}


±,	a ∈ V, v ∈ V, r ∈ V ∪ {⊥} .

Agai.n this should neither be understood as a structural induction (since a[x ← v] /≺
(λ x a) v) nor as action induction (because of infinite behaviors). The abstraction
α(T )  T ∩ (T × T) yields the classical natural semantics [12] (where all rules with ⊥ are eliminated and ± becomes ⊆ in the remaining ones). The abstraction α(T )  T ∩ (T × {⊥}) yields the divergence semantics (keeping only the rules with
⊥, ± is ⊇, and a =⇒ ⊥ is written a =∞⇒ in [15]).
Observe that both the maximal trace semantics of Sec. 4.1 and the above bifinitary relational semantics of Sec. 5 define the semantics of a term that “goes wrong” as empty.
The above big-step bifinitary relational semantics =⇒ is equivalent but not identical to the standard big-step semantics which bifinitary generalization would be


v =⇒ v,	v ∈ V

a =⇒ ⊥ 
±
a b =⇒ ⊥ 
a =⇒ λ x . c,	b =⇒ v',	c[x ← v'] =⇒ r
a b =⇒ r a =⇒ v,	b =⇒ ⊥ 
±,	v ∈ V
a b =⇒ ⊥ 

±,	v, v' ∈ V,
r ∈ V ∪ {⊥}

We have chosen to break evaluations of applications in smaller chunks instead so as to enforce evaluation of the function before that of the arguments and to make explicit the reduction step in the trace semantics.
Abstraction of the big-step trace semantics into the small-step operational semantics of the call-by-value λ-calculus
The one-step reduction semantics abstracts the trace semantics by collecting all transitions along any trace.
The small-step abstraction of traces is
αs ∈ ℘(T∞) '→ ℘(T × T)
αs(S)  {⟨σi, σi+1⟩ | σ ∈ S ∧ 0 ≤ i ∧ i +1 < |σ|} .
Since the bifinitary trace semantics is suffix-closed, we can also use
α ∈ ℘(T∞) '→ ℘(T × T)
α(S)  {⟨σ0, σ1⟩ | σ ∈ S ∧ |σ| > 1}
so that we have αs(S)= α(S) whenever S is suffix-closed. By defining ℘(T∞) to be the set of suffix-closed and blocking subsets of T∞ and γ(τ ) to be the set of maximal traces generated by the transition relation τ ∈ ℘(T × T) that is
γ+(τ )  {σ ∈ T+ | ∀i < |σ| : ⟨σi, σi+1⟩ ∈ τ ∧ ∀a ∈ T : ⟨σ<|σ|−1, a⟩ /∈ τ }
γω(τ )   {σ ∈ Tω | ∀i ∈ N : ⟨σi, σi+1⟩ ∈ τ }
γ(τ )   γ+(τ ) ∪ γω(τ ) ,
we have

⟨℘(T∞
g
, ⊆⟩ ←−−−− ⟨℘	\	×	, ⊆⟩ .
α

Small-step operational semantics
The small-step operational semantics or transition semantics S is defined by α- overapproximation αs(→S) = α(→S) of the bifinitary trace semantics →S.


(4)
S  lfp f
f (τ )  {⟨(λ x . a) v, a[x ← v]⟩}∪ {⟨a0 b, a1 b⟩ | ⟨a0, a1⟩ ∈ τ }∪ 
{⟨v b0, v b1⟩ | ⟨b0, b1⟩ ∈ τ } .

The rule-based presentation of (4) has a call-by-value β-reduction axiom plus two context rules for reducing under applications, corresponding to left-to-right evaluation [20]. a −A b stands for ⟨a, b⟩ ∈ S.




((λ x
. a) v) −A a[x ← v]
a0 −A a1
⊆
a0 b −A a1 b
b0 −A b1
⊆ .
v b0 −A v b1


The inductive definition of S can also be understood as co-inductive since lfp⊆ f =
gfp⊆ f .
We have α ◦ F→ ◦ γ ⊆˙ f . Indeed α ◦ F→ ◦ γ ˙ f since a single transition
cannot anticipate whether the future computation can “go wrong”. For example
((λ x . x 0) 0) −A	(0 0) ∈ f ◦ f (∅) while ((λ x . x 0) 0) −A	(0 0) /∈ α ◦ F→ ◦ γ ◦
α ◦ F→ ◦ γ(∅) since there is no trace of the form σ • ((λ x . x 0) 0) • (0 0) • σ' in
F→ ◦ γ ◦ α ◦ F→ ◦ γ(∅). It follows that the small-step operational semantics or
transition semantics S is sound but incomplete in that the set γ(S) of maximal traces generated by the transition relation S includes the bifinitary trace semantics
→S plus spurious traces for computations that can “go wrong” that is terminate with a runtime error e ∈ E.

	Small-step maximal trace semantics of the call-by- value λ-calculus
The small-step maximal trace semantics −∞A  of a transition relation −A  is defined as
−nA	  {σ ∈ T+ | |σ| = n > 0 ∧ ∀i :0 ≤ i < n − 1: σi −A  σi+1}	partial traces
−nA	  {σ ∈ −nA  | σn−1 ∈ V}	maximal execution traces of length n
−+A	   −nA	maximal finite execution traces
n>0
−ωA	  {σ ∈ Tω | ∀i ∈ N : σi −A σi+1}	infinite execution traces
−∞A	  −+A ∪ −ωA	maximal finite and diverging execution traces.

Fixpoint small-step maximal trace semantics
To express the small-step maximal trace semantics −∞A in fixpoint form, let us define the junction ; of set of traces as
S ; T   Sω ∪ {σ0 • ... • σ|σ|−2 • σ' | σ ∈ S+ ∧ σ|σ|−1 = σ' ∧ σ' ∈ T } ,
and the small-step set of traces transformer f→ ∈ ℘(T∞) '→ ℘(T∞)


(5)
f→(T )  {v ∈ T∞ | v ∈ V
2
}∪ −X

describing small steps of computation. We have



−∞A	= lfp± f→ . 
The big-step and small-step trace semantics are the same
→S = −∞A  .

Rule-based small-step maximal trace semantics
The maximal trace semantics →S = −∞A = lfp± f→ where f→ is defined by (5) can be defined inductively with small-steps as



v ∈ →S,	v ∈ V
a −A b,	b • σ ∈ →S
±
a • b • σ ∈ →S


that is, writing a Z ⇒ σ for σ ∈ →S and σ0 = a

 a −A b,	b  ⇒ σ 
Z ⇒ ,	∈ V	a	a
Z ⇒	• σ

Small-step bifinitary relational semantics of the call- by-value λ-calculus
The bifinitary relational semantics was defined as ñ  α(→S) (where α is the relational abstraction of sets of traces (3)) and given in big-step form in Sec. 5. It can be given in small-step form by abstraction of the small-step bifinitary maximal trace semantics of Sec. 7.1.

Fixpoint small-step biﬁnitary relational semantics
The bifinitary relational semantics ñ  α(→S)= α(lfp± f→) can be defined in fixpoint
form as lfp± ñ where the small-step transformer ñ	(T × (T ∪ {⊥})) '→ ℘(T ×

f
(T ∪ {⊥})) is
f ∈ ℘


f (R)  {⟨v, v⟩ | v ∈ V}∪ 
{⟨(λ x . a) v, r⟩ | v ∈ V ∧ ⟨a[x ← v], r⟩ ∈ R}∪ 
{⟨a0 b, r⟩ | a0 −A  a1 ∧ ⟨a1 b, r⟩ ∈ R}∪ 
{⟨v b0, r⟩ | b0 −A  b1 ∧ ⟨v b1, r⟩ ∈ R} .

Rule-based small-step biﬁnitary relational semantics
The bifinitary rule-base form is (a ⇒ b stands for ⟨a, b

— and r ∈ V ∪ {⊥})




Conclusion


v ⇒ v,	v ∈ V
⟩ ∈ S

a −A b,	b ⇒ r
±
a ⇒ r

Divergence/nonterminating behaviors are needed in static program analysis [18] or typing [3,15]. Such divergence information is part of the classical order-theoretic fixpoint denotational semantics [17] but not explicit in small-step/abstract-machine- based operational semantics [19,20,21] and absent of big-step/natural operational semantics [12]. A standard approach is therefore to generate an execution trace semantics from a (labelled) transition system/small-step operational semantics, using either an order-theoretic [4] or metric [23] fixpoint definition or else a categorical definition as a final coalgebra for a behaviour functor (modeling the transition relation) up to a weak bisimulation [11,14,22] or using an equational definition for re- cursion in an order-enriched category [13]. However, execution traces are not always at an appropriate level of abstraction. Finite and infinite behaviors can be both handled by SOS when extended to bi-inductive structural bifinitary small/big-step trace/relational/operational semantics. Sound (and sometimes complete) abstrac- tions are essential to establish this hierarchy of semantics [4]. This should satisfy the need for formal finite and infinite semantics, at various levels of abstraction and using various equivalent presentations (fixpoints, equational, constraints and inference rules) needed in static program analysis.
Acknowledgement
We thank the anonymous referees for their helpful comments and suggestions.

References
	P. Aczel. An introduction to inductive definitions. In J. Barwise, editor, Handbook of Mathematical Logic, volume 90 of Studies in Logic and the Foundations of Mathematics, pages 739–782. Elsevier, 1977.
I. Attali, J. Chazarain, and S. Gilette. Incremental evaluation of natural semantics specifications. In M. Bruynooghe and M. Wirsing, editors, Proc. 4th Int. Symp. PLILP ’92, Leuven, BE, 26–28 Aug. 1992, LNCS 631, pages 87–99. Springer, 1992.
	P. Cousot. Types as abstract interpretations, invited paper. In 24th POPL, pages 316–331, Paris, FR, Jan. 1997. ACM Press.
P. Cousot. Constructive design of a hierarchy of semantics of a transition system by abstract interpretation. Theoret. Comput. Sci., 277(1—2):47–103, 2002.

	P. Cousot and R. Cousot. Systematic design of program analysis frameworks. In 6th POPL, pages 269–282, San Antonio, TX, 1979. ACM Press.


	P. Cousot and R. Cousot. Abstract interpretation frameworks. J. Logic and Comp., 2(4):511–547, Aug. 1992.
P. Cousot and R. Cousot. Inductive definitions, semantics and abstract interpretation. In 19th POPL, pages 83–94, Albuquerque, NM, US, 1992. ACM Press.
	P. Cousot and R. Cousot. Compositional and inductive semantic definitions in fixpoint, equational, constraint, closure-condition, rule-based and game-theoretic form, invited paper. In P. Wolper, editor, Proc. 7th Int. Conf. CAV ’95, Li`ege, BE, LNCS 939, pages 293–308. Springer, 3–5 Jul. 1995.
Th. Despeyroux. TYPOL: a formalism to implement natural semantics. Tech. rep. RT-0094, INRIA Sophia Antipolis, Mar. 1988.
	C.A.R. Hoare. An axiomatic basis for computer programming. Comm. ACM, 12(10):576–580, Oct. 1969.
	B. Jacobs and J. Rutten. A tutorial on (co)algebras and (co)induction. EATCS Bulletin, 62:222–269, 1997.
	G. Kahn. Natural semantics. In K. Fuchi and M. Nivat, editors, Programming of Future Generation Computers, pages 237–258. Elsevier, 1988.
	B. Klin. Adding recursive constructs to bialgebraic semantics. J. Logic and Alg. Prog., 60-61:259–286, Jul.–Dec. 2004.
B. Klin. Bialgebraic methods in structural operational semantics. ENTCS, 175(1):33–43, May 2007.
	X. Leroy. Coinductive big-step operational semantics. In P. Sestoft, editor, Proc. 15th ESOP ’2006, Vienna, AT, LNCS 3924, pages 54–68. Springer, 27–28 Mar. 2006.
	R. Milner. Operational and algebraic semantics of concurrent processes. In J. van Leeuwen, editor, Formal Models and Semantics, volume B of Handbook of Theoretical Computer Science, chapter 19, pages 1201–1242. Elsevier, 1990.
	P.D. Mosses. Denotational semantics. In J. van Leeuwen, editor, Formal Models and Semantics, volume B of Handbook of Theoretical Computer Science, chapter 11, pages 575–631. Elsevier, 1990.
A. Mycroft. The theory and practice of transforming call-by-need into call-by-value. In B. Robinet,
editor, Proc. 4th Int. Symp. on Programming, Paris, FR, 22–24 Apr. 1980, LNCS 83, pages 270–281. Springer, 1980.
G.D. Plotkin. A structural approach to operational semantics. Technical Report DAIMI FN-19, Aarhus University, DK, Sep. 1981.
	G.D. Plotkin. The origins of structural operational semantics. J. Logic and Alg. Prog., 60–61:3–15, Jul.–Dec. 2004.
	G.D. Plotkin. A structural approach to operational semantics. J. Logic and Alg. Prog., 60–61:17–139, Jul.–Dec. 2004.
D. Turi and G.D. Plotkin. Towards a mathematical operational semantics. In Proc. 12th LICS ’1997, pages 280–291, Warsaw, PL, 29 June – 2 Jul. 1997. IEEE Comp. Soc. Press.
F. van Breugel. An introduction to metric semantics: operational and denotational models for programming and specification languages. Theoret. Comput. Sci., 258:1–98, 2001.
