

Electronic Notes in Theoretical Computer Science 248 (2009) 3–17
www.elsevier.com/locate/entcs

Using Context-Sensitive Rewriting for Proving Innermost Termination of Rewriting
Beatriz Alarc´on and Salvador Lucas 1,2
Departamento de Sistemas Informa´ticos y Computacio´n Universidad Polit´ecnica de Valencia
Valencia, Spain

Abstract
Computational systems based on reducing expressions usually have a predefined reduction strategy to break down the nondeterminism which is inherent to reduction relations. The innermost strategy corresponds to call by value or eager computation, that is, the computational mechanism of several programming lan- guages like Maude, OBJ, etc. where the arguments of a function call are always evaluated before calling the function. This strategy usually fails to terminate when nonterminating computations are possible in the programs and many eager programming languages also admit the explicit specification of a particular class of strategy annotations to (try to) avoid them. Context-Sensitive Rewriting provides an abstract model to describe and analyze the operational behavior of such programs. This paper aims at contributing to the development of appropriate techniques and tools for the verification of program termination in the afore- mentioned programming languages, so we focus on termination of innermost (context-sensitive) rewriting. We adapt the notion of usable argument introduced by Fern´andez to prove innermost termination by prov- ing termination of context-sensitive rewriting. Thanks to our recent developments for proving termination of (innermost) context-sensitive rewriting using dependency pairs, now we can also relax monotonicity re-
quirements for proving innermost termination of (context-sensitive) rewriting. We have implemented these new improvements in the termination tool mu-term and evaluated the results with some benchmarks.
Keywords: Dependency pairs, innermost rewriting, context-sensitive rewriting program analysis, termination.


Introduction
Most computational systems whose operational principle is based on reducing ex- pressions (e.g., functional, algebraic, and equational programming languages as well as theorem provers based on rewriting techniques) incorporate a predefined reduc- tion strategy which is used to break down the nondeterminism which is inherent to reduction relations. Thus, every program will be executed according to that strategy. One of the most commonly used is the innermost strategy, in which only

1 This work has been partially supported by the EU (FEDER) and the Spanish MICINN, under grant TIN2007-68093-C02-02 and HA 2006-2007, the Generalitat Valenciana under grant GVPRE/2008/113. Also it was partially supported by the Spanish MICINN under FPU grant AP2005-3399.
2 Email: {balarcon,slucas}@dsic.upv.es

1571-0661 © 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.07.055

innermost redexes are reduced. Here, by an innermost redex we mean a redex con- taining no other redex. The innermost strategy corresponds to call by value or eager computation, that is, the computational mechanism of several programming languages where the arguments of a function are always evaluated before the ap- plication of the function which use them. It is well-known, however, that programs written in eager programming languages frequently run into a nonterminating be- havior if the programs have not carefully been written to avoid such problems. For this reason, the designers of such eager programming languages have also devel- oped some features and language constructs aimed at giving the user more flexible control of the program execution. For instance, syntactic annotations (which are associated to the arguments of the function symbols) have been used in eager pro- gramming languages such as Maude [7], OBJ2 [11], OBJ3 [16], and CafeOBJ [12] to introduce replacement restrictions which are able to (hopefully) avoid nonter- mination. Such languages admit the explicit specification of a particular class of strategy annotations, which (basically) are lists of integers associated to function symbols which specify the ordering in which the arguments are (eventually) evalu- ated in function calls. This very simple strategy language provides quite a powerful way to control the program execution. Due to its simplicity, such strategy anno- tations also provide a simple interface for understanding and eventually modifying the execution of programs. Context-sensitive rewriting (CSR [18,21]) provides an abstract model to describe and analyze the operational behavior of such programs, thus providing an appropriate basis for the development of program verification tools [8,19,20]. In CSR, a replacement map (i.e., a mapping μ : F → P(N) sat- isfying μ(f ) ⊆ {1,..., k}, for each k-ary symbol f of a signature F) associates a subset of its argument indices to each function symbol. We use a replacement map to indicate the argument positions on which rewriting steps are allowed. In this way, we can achieve a terminating behavior by pruning (all) infinite rewrite sequences. A Term Rewriting System (TRS) R together with a replacement map μ is often called a CS-TRS (written (R, μ)). The research in this paper aims at contributing to the development of appropriate techniques and tools for the verifi- cation of program termination in the aforementioned programming languages. Our focus is on termination of innermost context-sensitive rewriting (i.e., the variant of CSR where only the deepest μ-replacing redexes are contracted). Techniques for proving termination of innermost CSR were first investigated in [13,19]. These pa- pers, though, only consider transformational techniques, where the original CS-TRS (R, μ) is transformed into a TRS Rμ (where Θ represents the transformation which has been used) whose innermost termination implies the innermost termination of CSR for (R, μ). In [5], we have extended the context-sensitive dependency pairs approach in [2,3] for proving termination of innermost CSR. Roughly speaking the (context-sensitive) dependency pairs associated to a (CS-)TRS are of a set of rewrite rules which are used together with the original ones to obtain an often easier proof of termination due to the possibility of applying a number of new auxiliary techniques, see, e.g., [15,17] for recent state-of-the-art accounts. As shown in [3], proofs of termination using context-sensitive dependency pairs (CS-DPs) are much more powerful and faster than any other technique for proving termination of CSR.

Dealing with innermost CSR, we have a similar situation, see [5].
The main topic we are going to develop in this work is the analysis and extension of Ferna´ndez’s work [9]. In her paper, she noticed that, when dealing with proofs of innermost termination, requiring monotonicity of the orderings w.r.t. all arguments of function symbols is not always necessary. According to this, she showed that innermost termination of rewriting can be rephrased as a context-sensitive rewriting termination problem. She introduced the notion of usable arguments, which can be thought of as the argument positions on which innermost reductions take place. Then, Ferna´ndez showed that innermost termination of a TRS R can be proved by proving termination of the CS-TRS (R, μ) which is obtained when μ(f ) collects the usable arguments of f for each symbol f in the signature. We have implemented her techniques for the first time, and then we have investigated the practical use of her results. We have adapted Ferna´ndez ideas to deal with proofs of innermost termination of CSR; this was left as an open problem in [9].
After some preliminaries in Section 2, in Section 3 we summarize the last de- velopments concerning context-sensitive rewriting and innermost context-sensitive rewriting using dependency pairs. In Section 4 we show how to adapt Fern´andez’s criterion to relax monotonicity requirements when proving innermost termination of CSR. In Section 5 we apply this criterion to be used with dependency pairs in proofs of termination of innermost (context-sensitive) rewriting. Section 6 provides an experimental evaluation of our techniques for proving innermost termination of (context-sensitive) rewriting automatically. Finally, we conclude and comment on some future work.

Preliminaries
Relations.
A (strict) partial ordering > is an irreflexive and transitive relation. We say that
> is well-founded if there is no infinite decreasing sequence with >. A quasi-ordering
  is a transitive and reflexive relation.

Terms.
Throughout the paper, X denotes a countable set of variables and F denotes a signature, i.e., a set of function symbols {f, g,.. .}, each having a fixed arity given by a mapping ar : F → N. The set of terms built from F and X is T (F, X ). Positions p, q, ... are represented by chains of positive natural numbers used to address subterms of t. Given positions p, q, we denote their concatenation as p.q. Positions are ordered by the standard prefix ordering ≤. If p is a position, and Q is a set of positions, then p.Q = {p.q | q ∈ Q}. We denote the topmost position by Λ. The set of positions of a term t is Pos(t). Positions of nonvariable symbols in t are denoted as PosF (t) while PosX (t) are the positions of variables. The subterm at position p of t is denoted as t|p and t[s]p is the term t with the subterm at position p replaced by s. The symbol labelling the root of t is denoted as root(t).

Term rewriting.
A rewrite rule is an ordered pair (l, r), written l → r, with l, r ∈T (F, X ), l /∈X and Var(r) ⊆ Var(l). The left-hand side (lhs) of the rule is l and r is the right-hand side (rhs). A rule is collapsing if r ∈ X . An instance σ of a left-hand side of a rewrite rule l → r, written σ(l), is a redex (reducible expresion). A TRS is a pair R = (F, R) where R is a set of rewrite rules. Given R = (F, R), we consider F as the disjoint union F = C D of symbols c ∈ C, called constructors and symbols f ∈ D, called deﬁned functions, where D = {root(l) | l → r ∈ R} and C = F − D.
Innermost rewriting.
A term is a normal form if it contains no redex. A substitution σ is normalized if σ(x) is a normal form for all x ∈ Dom(σ). A term f (t1,..., tk) is argument nor- malized if ti is a normal form for all 1 ≤ i ≤ n. An innermost redex is an argument normalized redex. A term s rewrites innermost to t, written s →i t, if s → t at position p and s|p is an innermost redex. Let R be a TRS. For any symbol f let Rules(R,f ) be the set of rules l → r defining f and such that the left-hand sides l are argument normalized. For any term t the set of usable rules U(R, t) is as follows:


U(R, x)	= ∅
U(R,f (t1,..., tn)) = Rules(R,f ) ∪	 
1≤i≤ar(f )

U(R', ti) ∪	 
l→r∈Rules(R,f )

U(R', r)

where R'= R− Rules(R,f ).
Context-sensitive rewriting.
A mapping μ : F → P(N) is a replacement map (or F-map) if ∀f ∈ F, μ(f ) ⊆
{1,..., ar(f )} [18].  Let MF be the set of all F-maps (or MR for the F-maps of a TRS (F, R)).  A binary relation R on terms is μ-monotonic if t R s im- plies f (t1,..., ti−1, t,..., tk) R f (t1,..., ti−1, s,..., tk) for all f ∈ F, i ∈ μ(f ) and
t, s, t1,..., tk ∈T (F, X ). The set of μ-replacing positions Posμ(t) of t ∈T (F, X ) is:

Posμ(t) = {Λ}, if t ∈X and Posμ(t) = {Λ}∪ 

i∈μ(root(t))
i.Posμ(t|i), if t /∈ X . The

set of μ-replacing variables of t is Varμ(t) = {x ∈ Var(t) | ∃p ∈ Posμ(t), t|p = x}. A 
rule l → r is μ-conservative if Varμ(r) ⊆ Varμ(l). The μ-replacing subterm relation oμ is given by t oμ s if there is p ∈ Posμ(t) such that s = t|p. We write t Dμ s if t oμ s and t /= s and say that s is a strict μ-replacing subterm of t. We write t Dμ/ s to denote that s is a non-μ-replacing (hence strict) subterm of t: t Dμ/ s if
there is p ∈ Pos(t) −Posμ(t) such that s = t|p. In context-sensitive rewriting (CSR
[18]), we (only) contract μ-replacing redexes: s μ-rewrites to t, written s ‹→μ t (or
s ‹→R,μ t and even s ‹→ t, if R and μ are clear from the context), if s →R t and p ∈ Posμ(s). A TRS R is μ-terminating if ‹→μ is terminating. Termination of CSR is fully captured by the so-called μ-reduction orderings, i.e., well-founded, stable orderings N which are μ-monotonic. A term t is μ-terminating if there is no infinite μ-rewrite sequence t = t1 ‹→μ t2 ‹→μ ··· ‹→μ tn ‹→μ ··· starting from t. A term t μ-narrows to a term s (written t ~R,μ,θ s), if there is a nonvariable μ-replacing position p ∈ Posμ (t) and a rule l → r in R (sharing no variable with t) such that t|p and l unify with most general unifier θ and s = θ(t[r]p). Then, we say that

t is μ-narrowable. A μ-normal form is a term which cannot be μ-rewritten. Let
NFμ(R) (or just NFμ if no confusion arises) be the set of μ-normal forms of a TRS
R. A substitution σ is μ-normalized if σ(x) is a μ-normal form for all x ∈ Dom(σ). A term t = f (t1,..., tk) is argument μ-normalized if ti is a μ-normal form for all i ∈ μ(f ). A μ-innermost redex is an argument μ-normalized redex.

A term s innermost μ-rewrites to t, written s ‹→i
t, if s →R
t, p ∈ Posμ(s),

and s|p is a μ-innermost redex.  A TRS R is innermost μ-terminating if ‹→μ,i is

terminating. We write s ‹→!
t if s ‹→∗
t and t ∈ NFμ. A pair (R, μ) where R

is a TRS and μ ∈ MR is often called a CS-TRS.
Dependency pairs.
Given a TRS R = (F, R) = (C  D, R) a new TRS DP(R) = (F , D(R)) of
dependency pairs for R is given as follows: if f (t1,..., tm) → r ∈ R and r = C[g(s1,..., sn)] for some defined symbol g ∈ D and s1,..., sn ∈ T (F, X ), then f (t1,..., tm) → g (s1,..., sn) ∈ D(R), where f and g are new fresh symbols (called tuple symbols) associated to defined symbols f and g respectively [6]. Let D be the set of tuple symbols associated to symbols in D and F = F∪D . As usual, for t = f (t1,..., tk) ∈T (F, X ), we write t to denote the marked term f (t1,..., tk). Given T ⊆ T (F, X ), T denotes {t | t ∈ T}. For the sake of readability, capital letters denote marked symbols in examples.
Reduction pairs.
Given a signature F, a reduction pair (≥, N) for terms in T (F, X ) consists of a stable and monotonic quasi-ordering ≥ on terms, and a stable and well-founded ordering N satisfying either ≥◦ N ⊆ N or N ◦≥ ⊆ N. Note that monotonicity is not required for N. A μ-reduction pair is a reduction pair (≥, N) where the quasi-ordering ≥ is μ-monotonic (instead of monotonic).

Context-sensitive dependency pairs
In the following, we write Narrμ(t) to indicate that t is μ-narrowable (w.r.t. the intended TRS R). We consider a function Renμ which independently renames all occurrences of μ-replacing variables within a term t by using new fresh variables which are not in Var(t):
Renμ(x) = y if x is a variable, where y is intended to be a fresh new variable which has not yet been used (we could think of y as the ‘next’ variable in an infinite list of variables); and
Renμ(f (t1,..., tk)) = f ([t1]f ,..., [tk]f ) for evey k-ary symbol f , where given a
1	k
term s ∈T (F, X ), [s]f = Renμ(s) if i ∈ μ(f ) and [s]f = s if i /∈ μ(f ).
i	i
Let R = (F, R) = (C  D, R) be a TRS and μ ∈ MF . We define iDP(R, μ) = iDPF (R, μ) ∪ iDPX (R, μ) to be the set of innermost context-sensitive dependency pairs (ICS-DPs) where:
iDPF (R, μ) = {l → s | l → r ∈ R, l ∈ NFμ(R),r Ḇμ s, root(s) ∈ D,l / Qμ s, Narrμ(Renμ(s))}
iDPX (R, μ) = {l → x | l → r ∈ R, l ∈ NFμ(R),x ∈ Varμ(r) − Varμ(l)}

We extend μ ∈ MF into μ ∈ MF∪D  by μ (f ) = μ(f ) if f ∈ F, and μ (f ) = μ(f ) if f ∈ D. Let R = (F, R) be a TRS and μ ∈ MF . We say that t ∈T (F, X ) −X is a hidden term if there is a rule l → r ∈ R such that r Dμ/ t. Let HT (R, μ) (or just HT ,
if R and μ are clear for the context) be the set of all hidden terms in (R, μ). We
use DHT = {t ∈ HT | root(t) ∈ D} for the set of hidden terms which are rooted by a deﬁned symbol. We also let NHT (R, μ) = {t ∈ DHT | Narrμ(Renμ(t))} be the set of hidden terms which are rooted by a deﬁned symbol, and that, after applying
Renμ, become μ-narrowable (see [4] for further motivation and explanations about these definitions).
Let R = (F, R) and P = (G,P ) be TRSs and μ ∈ MF∪G .  An innermost (P, R, μ)-chain is a finite or infinite sequence of pairs ui → vi ∈ P, together with a substitution σ satisfying that, for all i ≥ 1, σ(ui) ∈ NFμ(R) and :
if vi /∈ Var(ui) − Varμ(ui), then σ(vi) ‹→!	σ(ui+1), and
if vi ∈ Var(ui) − Varμ(ui), then there is si ∈ T (F, X ) such that σ(vi) oμ si
and s ‹→!	σ(ui+1).
i	R,μ,i
As usual, we assume that different occurrences of dependency pairs do not share any variable (renaming substitutions are used if necessary). An innermost (P, R, μ)- chain is called minimal if for all i ≥ 1,
if vi /∈ Var(ui) − Varμ(ui), then σ(vi) is innermost (R, μ)-terminating, and
if vi ∈ Var(ui) − Varμ(ui), then s is innermost (R, μ)-terminating and ∃s¯i ∈
NHT (R, μ) such that si = σ(s¯i).
This more abstract notion of chain can be particularized to be used with ICS-DPs, by just taking P = iDP(R, μ). In the following, the pairs in a CS-TRS (P, μ), where P = (G,P ), are partitioned according to its role in the previous Definition as follows:

PX = {u → v ∈ P | v ∈ Var(u) − Varμ(u)} and PG = P − PX



Innermost Context-Sensitive Dependency Graph.
Let R be a TRS and μ ∈ MR. The innermost context-sensitive dependency graph consists of the set iDP(R, μ) of innermost context-sensitive dependency pairs and arcs which connect them as follows:
There is an arc from u → v ∈ PG to u' → v' ∈ P if there are substitutions θ
and θ' such that θ(v) ‹→!	θ'(u') and θ(u), θ'(u') ∈ NFμ(R).
There is an arc from u → v ∈ PX to u' → v' ∈ P if there is t ∈ NHT (R, μ)
and substitutions θ and θ' such that θ(t ) ‹→!	θ'(u') and θ'(u') ∈ NFμ(R)
In order to approximate the ICS-DG, we have also adapted functions Ren and Cap (used in standard rewriting) to the innermost context-sensitive setting (see [4,5] for details).

Basic usable CS-rules.
Let R be a TRS and μ ∈ MR. For any symbol f , let Rules(R, μ,f ) be the set of rules l → r defining f and such that the left-hand sides l are argument μ-normalized: Rules(R, μ,f ) = {f (l1,..., lk) → r ∈R| ∀i ∈ μ(f ), li ∈ NFμ(R)}. For any term t, the set of basic usable CS-rules U0(R, μ, t) is as follows:



U0(R, μ, x)	= ∅
U0(R, μ,f (t1,..., tn)) = Rules(R, μ,f ) ∪  S
i∈μ(f )
U0(R', μ, ti) ∪	S
l→r∈Rules(R,μ,f )

U0(R', μ, r)



where R'= R− Rules(R, μ,f ).
If P is a TRS, then U0(R, μ, P) =	 
l→r∈P


U0(R, μ, r).


Simplifying monotonicity requirements for innermost
μ-termination
In the innermost setting, matching substitutions are always normalized. For this
reason, in an innermost sequence t  p1  t  p2	pn  t	starting at root position

1 →i
2 →i ··· →i
n+1

(i.e., p1 = Λ), every redex tj|pj for j > 1 comes from a defined symbol introduced
after applying a rule lk → rk in a previous step k < j. Hence the set of arguments which are reduced can be handled by looking for defined symbols in right-hand sides of the involved rules l → r.
In [6], Arts and Giesl already noticed that in the treatment of innermost chains, monotonicity requirements for the reduction pairs can be weaker. In [9] Fern´andez defines the notion of usable arguments for a function symbol when proving innermost
termination. The idea is that, in innermost sequences, some arguments are not relevant for proving termination.
Example 4.1 Consider the following TRS R:

f(s(0), s(0)) → f(x, g(x))	g(s(x)) → g(x)

No innermost sequence starting at root position takes into account the first argu- ment of f nor the argument of g. The reason is that (instances of) innermost redexes are argument normalized. That means that all variables (e.g. x) introduced by the applied rule are normalized and cannot be reduced. Only the second argument g(x) of f in the right-hand side of the first rule could be innermost reduced after applying it.
Roughly speaking, the usable arguments of a symbol f with respect to a TRS R are those arguments with a subterm rooted by a defined symbol in some right-hand side of a dependency pair or usable rule.

Definition 4.2 [Usable arguments] [9, Definition 3] Let R = (F, R)= (C  D, R) be a TRS and P a set of pairs of terms s.t. for all u → v ∈ P, u is argument normalized with respect to R. The set of usable arguments for a function symbol f ∈ F with respect to R and P is defined as UA(f, R, P) = {1 ≤ k ≤ ar(f ) |
∃u → v ∈P ∪ U(R, P), ∃p, p' ∈ Pos(v) s.t. root(v|p' ) = f , root(v|p) ∈D , p'.k ≤ p, u ф v|p}.

Considering those usable arguments could be helpful in proofs of innermost termi- nation since they impose weaker monotonicity requirements.
As Fern´andez noticed, the set of usable arguments can be seen as a replace- ment map which specifies the arguments to be reduced. According to her re- sults, the μ-termination of a TRS R implies the innermost termination of R if μ(f )=UA(f, R, R) for all f ∈F where R only contains rules such that all left-hand sides are argument normalized.
Corollary 4.3 [9, Corollary 11] Let R be a TRS and μ(f ) = UA(f, R, R') for every f ∈ F where R' ⊆ R contains all rules l → r ∈ R such that l is argument normalized. If R is μ-terminating, then R is innermost terminating.
This observation is very useful since now, all techniques for proving termina- tion of CSR can be used for proving innermost termination. Several methods and techniques for proving termination of CSR have been developed so far [2,3,14,23].

Usable arguments for CSR
Following Ferna´ndez’s ideas, in the innermost context-sensitive setting (for a given replacement map μ) we could relax monotonicity requirements by taking into ac- count that reductions only take place on μ-replacing positions of the right-hand sides of the rules which are rooted by a defined symbol. We adapt Ferna´ndez’s ideas to CSR. In sharp contrast to the unrestricted case, we need to take into account that in innermost CSR a redex does not need to be argument normalized. Only argument μ-normalization can be assumed. Thus, non-μ-replacing subterms may contain redexes that can be reduced later on if they come to a replacing position.
Proposition 4.4 A CS-TRS (R, μ) is innermost μ-terminating iff R' is innermost μ-terminating, where R' ⊆R contains all rules l → r ∈R such that l is argument μ-normalized.
Proof. Trivial since the only rules that can be applied in innermost μ-reductions are those whose left-hand sides are argument μ-normalized.	 
In the following, we assume that all rules in any CS-TRS (R, μ) are argument μ- normalized, i.e., for all rules l → r in R, l is argument μ-normalized. Proposition 4.4 ensures that this entails no lack of generality regarding our research on innermost termination of CSR. The straightforward adaptation of Fernandez’s criterion to CSR yields the following definition.

Definition 4.5 [Basic usable CS-arguments] Let (R, μ) = ((C D, R), μ) be a CS- TRS and P be a set of pairs of terms s.t. for all u → v ∈ P, u is argument μ-normalized. The basic usable CS-arguments for a function symbol f ∈F (w.r.t. R and P) are defined as UAμ(f, R, P) = {i ∈ μ(f ) | ∃u → v ∈ P ∪ U0(R, μ, P),
∃p, p' ∈ Posμ(v) s.t. root(v|p' ) = f , root(v|p) ∈D , p'.i ≤ p, u фμ v|p}.
Note that the replacement map given by μ'(f ) = UAμ(f, R, P) for all f ∈F is more restrictive than μ, i.e., for all symbols f ∈ F, μ'(f ) ⊆ μ(f ).
The following proposition is the context-sensitive version of [9, Lemma 5].
Proposition 4.6 Let (R, μ) be a CS-TRS and P be a set of pairs of terms s.t. for all u → v ∈ P, u is argument μ-normalized and P ∪ U0(R, μ, P) is μ-conservative.

Let innermost μ-rewriting below the root be
>Λ
>Λ
‹−→i
>Λ
‹→ ∩
‹→i). Let l → r ∈

P∪ U0(R, μ, P) be such that σ(r) ‹−→∗	t for some term t and substitution
σ s.t. σ(l) is argument μ-normalized . If t|p is an innermost μ-redex, then for all
p'.k ≤ p, we have that k ∈ UAμ(root(t|p' ), R, P).
Proof. By induction on the length n of the rewriting sequence. If n = 0, then σ(r) = t. Then, since σ(l) is argument μ-normalized, it follows that for all x ∈ Varμ(l), σ(x) ∈ NFμ(R). Since the rule l → r is μ-conservative (that is Varμ(r) ⊆ Varμ(l)), we have that for all x ∈ Varμ(r), σ(x) ∈ NFμ(R). It follows that p is a nonvariable (μ-replacing) position of r, i.e. p ∈ Posμ (r). Thus, root(r|p) ∈ D and

the result follows by Definition 4.5.
If n > 0, then there is a term s such that σ(r) ‹ >Λ ∗ s and s ‹ >Λ

t at some

−→i
−→i

μ-replacing position q. By the induction hypothesis, every μ-replacing position of the term t above, which equal or disjoint to q satisfies the result and we only have to prove it for innermost redexes t|p s.t. q < p, it is say, we have to prove that
'	>Λ	'  '
k ∈ UAμ(root(t|p' ), R, P), for all q < p .k ≤ p. If s ‹−→i t, then s|q = σ (l ) and
t|q = σ'(r'), for some rule l' → r' ∈ U0(R, μ, P) and substitution σ' s.t. σ'(l') is argument μ-normalized. This implies that every innermost redex of t|q occurs at a position p'' ∈ Posμ(r') s.t. root(r'|p'' ) ∈ D (since the rule l' → r' is conservative we have that for all x ∈ Varμ(r'), σ(x) ∈ NFμ(R)) and l' фμ r'|p'' (otherwise, σ'(l') would not be an innermost redex of s. By definition, when p'' > Λ, p'.k ≤ p'', k
∈ UAμ(root(t|q.p' ), R, P) which is equivalent to what we needed to prove ( k ∈
UAμ(root(t|p' ), R, P), for all q < p'.k ≤ p).	 
Corollary 4.3 suggests that innermost μ-termination of a TRS R = (F, R) could be proved as μ'-termination for μ' given by μ'(f ) = UAμ(f, R, R) for all f ∈ F. This is true for μ-conservative CS-TRSs, as the following theorem shows.
Theorem 4.7 A μ-conservative CS-TRS (R, μ) is innermost μ-terminating if R
is μ'-terminating, where for all symbols f ∈ F, μ'(f ) = UAμ(f, R, R).
Proof. By contradiction. Assume that R is not innermost μ-terminating. By the argument of size minimality, there is a infinite innermost μ-rewrite sequence with the first step at position Λ: s1 ‹→i s2 ‹→i s3 ‹→i ··· (without loss of generality).

By Proposition 4.6 (where we let P = R), every step sj
>Λ
‹−→i

sj+1
at position p

satisfies that p'.k ≤ p, k ∈ UAμ(root(sj|p' ), R, P). Therefore, there is an infinite μ'-rewrite sequence of terms s1 ‹→μ' s2 ‹→μ' ··· ‹→μ' sn ‹→μ' ··· which contradicts the μ'-termination of R.

Example 4.8 Consider the TRS R :
f(a, b, x) → f(x, x, x)
c → a c → b
together with μ(f) = {1, 3}. Note that R is μ-conservative. The set of ICS-DPs consists of the pair F(a, b, x) → F(x, x, x). By using μ'(f ) = UAμ(f, R, P) for every f ∈ F we obtain μ'(f) = ∅. The CS-TRS (R, μ') has no ICS-DP now. Thus we easily conclude the μ'-termination of R and, by Theorem 4.7, the innermost μ-termination of R.
This fact is important since now, all techniques for proving termination of CSR can be used to prove termination of innermost CSR for μ-conservative systems. The following example shows that μ-conservativeness cannot be dropped in Theorem 4.7.
Example 4.9 Consider again the TRS R in Example 4.8 but now together with μ(f) = {1, 2}. If we try to apply Theorem 4.7 to prove innermost μ-termination of R, we obtain μ'(f) = ∅ and (as discussed in Example 4.8) we would conclude the innermost μ-termination of R. However, R is not innermost μ-terminating:
f(a,b,c) ‹→i f(c,c,c) ‹→i f(a,c,c) ‹→i f(a,b,c) ‹→i ··· 

Note that the first rule of R is not μ-conservative now.
Relaxing monotonicity with CS-DPs
Fern´andez’s criterion was also adapted to deal with proofs of termination of rewrit- ing using dependency pairs. We have recently investigated how to prove innermost termination of CSR by using (context-sensitive) dependency pairs [5]. Now, we can adapt the use of CS-usable arguments to be applied in proofs of innermost μ- termination with CS-dependency pairs. To give a further step, we do it directly by considering the cycles of the ICS-DG.
Theorem 5.1 Let R = (F, R) and P = (G,P ) be TRSs, μ ∈ MF∪G and P is μ- conservative be such that U0(R, μ, P) is μ-conservative, and μ'(f ) = UAμ(f, R, C) for all f ∈ F. If there is a μ'-reduction pair (  , N) such that U0(R, μ, P) ⊆  , P ⊆  ∪ N, and P∩ N /= ∅, then there is no minimal innermost (R, P, μ)-chain.
Proof. We proceed again by contradiction. Assume that there is a minimal inner- most (R, P, μ)-chain:



>Λ
σ(u1) ‹→P,μ σ(v1)‹−→∗
>Λ
σ(u2) ‹→P,μ σ(v2)‹−→∗

σ(u3) ‹→ ··· 



where all pairs are infinitely often used, and, for all j ≥ 1, all uj → vj ∈ P are μ- conservative and there is a substitution σ such that σ(uj) is argument μ-normalized and σ(vj) is innermost (R, μ)-terminating. By Proposition 4.6, every innermost step
>Λ
in the sequence σ(vj) ‹−→∗ σ(uj+1) is performed at a μ'-replacing position by means
of a rule in U0(R, μ, P). Since by assumption U0(R, μ, P) ⊆  , and  is stable and μ'-monotonic, σ(vj)  σ(uj+1) holds for all j > 0. On the other hand, since P ⊆  ∪ N and P∩ N /= ∅, the sequence σ(u1)  ∪ N σ(v1)  σ(u2) ··· contains an infinite number of N steps. By compatibility of and N, this contradicts the well-foundedness of N.	 
Theorem 4.7 can be generalized to (certain) non-μ-conservative CS-TRSs thanks to Theorem 5.1 and the results for proving innermost termination of CSR in [5]. Now, for a given CS-TRS (R, μ) that satisfies the conditions of Theorem 5.1, we can prove its innermost μ-termination by relaxing μ-monotonicity requirements for each cycle.

Implementation and Experiments
We have implemented the techniques described in the previous sections as part of the termination tool mu-term [1,22]. In order to evaluate the techniques which are reported in this paper we have made some benchmarks. We have considered the examples in the 2007 Termination Problem Data Base (TPDB, version 4.0) available through the URL:
http://www.lri.fr/~marche/tpdb
We are going to comment on the results obtained with each improvement.

Proving innermost termination of rewriting as termination of CSR
We have implemented the use of Corollary 4.3 for proving innermost termination of rewriting as termination of CSR (this was one of the main results in Ferna´ndez’s paper). The relevance of this result in practice had not been tested yet. In or- der to evaluate it we have considered the examples used in the innermost category of the 2006 termination Competition 3 , which are part of the TPDB (in 2007 the category was not run). There are 69 examples, 66 of them are known to be inner- most terminating. With Ferna´ndez’s criterion (Corollary 4.3) mu-term succeeds in 32 examples (success rate of 48.5%). This is acceptable if we think that (except for AProVE, which succeeds in the 100% of the examples) the success rate for all

3  http://www.lri.fr/~marche/termination-competition/2006


Table 1
Summary of benchmarks for innermost termination of rewriting


Table 2
Summary of benchmarks for innermost termination of rewriting (based on cycles)



other participants in this category is around 20%. However, we have also imple- mented the use of (standard) dependency pairs for proving innermost termination (according to [6, Theorem 37]) together with the narrowing refinement (we call this tool mu-term iDPs) and we are able to prove 39 examples, including all examples solved with Ferna´ndez’s criterion. Moreover, we have included Ferna´ndez’s crite- rion as a technique to be applied when trying to solve a cycle in the innermost termination proof (see [9], Theorem 9). There are two news approximations: when mu-term has to solve a cycle, the first version uses Fern´andez’s criterion and if it fails then it tries to solve it in the usual way, that is, without any replacement map (mu-term Fern´andez cycle-based). The second one tries to force mu-term to solve the cycle with Fern´andez’s criterion, there is no other option (mu-term Fern´andez cycle-based only). In both cases the results obtained are similar. With the previous implementation of mu-term (mu-term iDPs) we solve 39 examples and with these two configurations we obtain better results than with Corollary 4.3; however, they do not improve the performance of mu-term iDPs. The results are summarized in Tables 1 and 2.
Therefore, it seems that using Corollary 4.3 to prove innermost termination of rewriting is not as good idea (at least with the considered set of examples) since we lose some examples due to a too restrictive new replacement map, and the average time is the same. Regarding the application of these ideas to cycles, we obtain better results but no essential improvement since we also lose some examples.
Full details for the benchmarks summarized in Table 1 can be found here:
http://www.dsic.upv.es/~balarcon/prole08/benchmarks/FerInnermost.htm
In the following URL:
http://www.dsic.upv.es/~balarcon/prole08/Innermost/benchmarks.html
more information can be found regarding the benchmarks summarized in Table 2. All this shows that we do not obtain any real improvement over the basic tech- nique of dependency pairs for proving innermost termination at least for the set of considered examples.

Proving innermost termination of CSR
Although there is no special TPDB category for innermost termination of CSR, we have used the TRSs in the CSR termination subcategory to test our techniques for proving termination of innermost CSR (Theorems 4.7 and 5.1). It contains 90 CS-TRSs.
Since Theorem 4.7 only applies to conservative systems, we restrict the attention to the 27 conservative examples. We solve all of them with an average time of 0.025 seconds (mu-termFern´andez). Further details can be found here:
http://www.dsic.upv.es/~balarcon/prole08/benchmarks/FerICSR.html
On the other hand, we have also implemented the use of Theorem 5.1 to deal with nonconservative systems. We have compared the same configurations ex- plained above: the first one (mu-term Fern´andez cycle-based) tries to solve each μ- conservative cycle (with associated μ-conservative usable rules) by using CS-usable arguments as the new replacement map. If it fails, then the normal configuration of mu-term (mu-term iCSDPs) is used. The second one only applies CS-usable arguments on cycles when searching for a compatible μ-reduction pair (mu-term Fern´andez cycle-based only). All these versions of mu-term succeed over the same 70 examples, the same number of examples that we had already solved using the innermost version of the context-sensitive dependency pairs [5]. The time average rates has no exhibit substantial differences. Further details can be found here:
http://www.dsic.upv.es/~balarcon/prole08/iCSR/benchmarks.html

Conclusions and future work
In this work we have shown how to relax monotonicity requirements for proving innermost termination of context-sensitive rewriting. Ferna´ndez defined the notion of usable arguments to indicate those arguments that can be eventually reduced in innermost computations. This notion is totally equivalent to fix a replacement map where only those arguments are μ-replacing, thus transforming an innermost termination problem into a context-sensitive termination problem. We have adapted Fern´andez’s approach [9] to be used for proving innermost termination of context- sensitive rewriting (Theorem 4.7). Moreover, since we have recently adapted the use of context-sensitive dependency pairs to deal with innermost termination of CSR [5], we have also investigated how to take advantage of it to adapt the result over dependency pairs and reduction pairs of [9] to the context-sensitive setting (Theorem 5.1). We have implemented both, the innermost and the innermost context-sensitive
approaches in mu-term since the original results had not been implemented or
tested before in any termination tool. We have performed some benchmarks that show no real improvement over previous (standard) approaches for proving either innermost termination [6] or innermost termination of CSR [5].
One of our main motivations to analyze and continue Ferna´ndez’s work was the strong connection that she found between CSR and innermost rewriting, specifi- cally the possibility of using CSR for proving innermost termination of rewriting

that she showed in her paper. Since in 2005 there was no really powerful tech- nique for automatically proving termination of CSR, her work could not be tested, although it is interesting from a theoretical point of view. The recent definition of a context-sensitive version of the dependency pairs approach, though, suggested that some practical benefits could be obtained from her work. After achieving great results in proofs of termination of CSR we also developed the innermost version of CS-DPs [5]. The results obtained with this approach were also much better than the existing transformational methods for proving innermost termination of CSR [13]. This lead us to think about combining the new CS-DP approach with Fern´andez’s ideas to obtain a good result for proving innermost termination as she stated in her paper. Moreover, she left open the problem of adapting the notion of usable argument to the context-sensitive setting for proving innermost termination of CSR which was a nontrivial issue due to the peculiarities of context-sensitive reductions as she already noticed. Therefore we have tackled the problem in all its open issues: we have implemented her results in the termination tool mu-term and we have also investigated and implemented the extension of her results to CSR (even the treat- ment over cycles that she mentioned). Unfortunately, our practical experience has been very different to what we expected: viewing an innermost termination problem as a context-sensitive termination problem, even with the possibility of using CS- DPs to achieve a proof, does not improve the performance of classical techniques for proving innermost termination of rewriting (dependency pairs, narrowing, etc [6]). On the other hand, trying to prove innermost termination of CS-TRSs by using a more restrictive replacement map do not offer any improvement over the results obtained by using innermost CS-DPs with the original replacement map [5]. Thus, we can only conclude that, nowadays, apart from the theoretical interest of the approach that combines two different strategies, it does not provide a better approach over the existing techniques for proving innermost termination [6] and innermost termination of CSR [5]. The other motivation for Ferna´ndez’s work is that relaxing monotonicity requirements allows the use of non-monotonic orderings for direct proofs (see e.g., [10]). However, as far as we know, there is no tool imple- menting these orderings in automatic proofs of termination. Some approximations for proving innermost termination using speciﬁc orderings are presented in [10] but they does not consider the argument positions of function symbols. More research in this field could hopefully clarify whether usable arguments can actually improve the existing methods for proving innermost termination of (context-sensitive) rewriting in some way.

References
Alarc´on, B., R. Guti´errez, J. Iborra and S. Lucas. Proving Termination of Context-Sensitive Rewriting with MU-TERM. Electronic Notes in Theoretical Computer Science, volume 188, pages 105–115, 2007.
Alarc´on, B., R. Guti´errez, and S. Lucas. Context-Sensitive Dependency Pairs. In S. Arun-Kumar and
N. Garg, editors, Proc. of the 26th Conference on Foundations of Software Technology and Theoretical Computer Science, FSTTCS’06, LNCS 4337:297-308, Springer-Verlag, Berlin, 2006.
Alarc´on, B., R. Guti´errez, and S. Lucas. Improving the Context-Sensitive Dependency Graph. Electronic Notes in Theoretical Computer Science, 188:91–103, 2007.


B. Alarc´on, R. Guti´errez, and S. Lucas. Context-Sensitive Dependency Pairs. Technical Report DSIC II/10/08 (72 pages). Departamento de Sistemas Inform´aticos y Computaci´on, Universidad Polit´ecnica de Valencia, Spain, July 2008.
Alarc´on, B., and S. Lucas. Termination of Innermost Context-Sensitive Rewriting Using Dependency Pairs. In B. Konev and F. Wolter, editors, Proc. of 6th International Symposium on Frontiers of Combining Systems, FroCoS’07, LNAI 4720: 73–87, Springer-Verlag, Berlin, 2007.
Arts, T., and J. Giesl. Termination of Term Rewriting Using Dependency Pairs Theoretical Computer Science, 236:133-178, 2000.
Clavel, M., F. Dur´an, S. Eker, P. Lincoln, N. Mart´ı-Oliet, J. Meseguer, and C. Talcott. All About Maude – A High-Performance Logical Framework. LNCS 4350, 2007.
Dur´an, F., S. Lucas, J. Meseguer, C. March´e, and X. Urbain. Proving Operational Termination of Membership Equational Programs. Higher-Order and Symbolic Computation, 21(1-2):59-88, 2008.
Fern´andez, M. L. Relaxing monotonicity for innermost termination. Information Processing Letters 93(3):117-123, 2005.
Fern´andez, M. L., G. Godoy, A. Rubio. Orderings Innermost Termination. In J. Giesl, editor, Proc. 16th Int. Conf. on Rewriting Techniques and Applications Proc. of RTA’05, LNCS 3467:17-31, Springer- Verlag, Berlin, 2005.
Futatsugi,K., J. Goguen, J.-P. Jouannaud, and J. Meseguer. Principles of OBJ2. In Conference Record of the 12th Annual ACM Symposium on Principles of Programming Languages, POPL’85, pages 52-66, ACM Press, 1985.
Futatsugi, K., and A. Nakagawa. An Overview of CAFE Specification Environment – An algebraic approach for creating, verifying, and maintaining formal specification over networks –. In Proc. of 1st International Conference on Formal Engineering Methods, 1997.
Giesl, J., and A. Middeldorp. Innermost termination of context-sensitive rewriting. In M. Ito and M. Toyama, editors, Proc. of 6th International Conference on Developments in Language Theory, DLT’02, LNCS 2450:231-244, Springer-Verlag, Berlin, 2003.
Giesl, J., and A. Middeldorp. Transformation techniques for context-sensitive rewrite systems. Journal of Functional Programming, 14(4): 379-427, 2004.
Giesl, J., R. Thiemann, P. Schneider-Kamp, and S. Falke Mechanizing and Improving Dependency Pairs Journal of Automated Reasoning, 37(3): 155-203. Springer-Verlag, 2006.
Goguen, J.A., T. Winkler, J. Meseguer, K. Futatsugi, and J.-P. Jouannaud. Introducing OBJ. In
J. Goguen and G. Malcolm, editors, Software Engineering with OBJ: algebraic specification in action, Kluwer, 2000.
Hirokawa, N., and A. Middeldorp. Automating the dependency pair method. Information and Computation, 199:172-199, 2005.
Lucas, S. Context-sensitive computations in functional and functional logic programs. Journal of Functional and Logic Programming 1998(1):1-61, 1998.
Lucas, S. Termination of Rewriting With Strategy Annotations. In R. Nieuwenhuis and A. Voronkov, editors, Proc. of 8th International Conference on Logic for Programming, Artificial Intelligence and Reasoning, LPAR’01, LNAI 2250:669-684, Springer-Verlag, Berlin, 2001.
Lucas, S. Termination of on-demand rewriting and termination of OBJ programs. In Proc. of 3rd International Conference on Principles and Practice of Declarative Programming, Proc. of PPDP’01, pages 82-93, ACM Press, 2001.
Lucas, S. Context-sensitive rewriting strategies. Information and Computation, 178(1):293-343, 2002.
Lucas, S. MU-TERM: A Tool for Proving Termination of Context-Sensitive Rewriting. In V. van Oostrom, editor, Proc. of 15h International Conference on Rewriting Techniques and Applications, RTA’04, LNCS 3091:200-209, Springer-Verlag, Berlin, 2004. Available at http://www.dsic.upv.es/
~slucas/csr/termination/muterm.
Lucas, S. Proving termination of context-sensitive rewriting by transformation. Information and Computation, 204(12):1782-1846, 2006.
