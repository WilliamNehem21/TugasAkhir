Egyptian Informatics Journal 24 (2023) 100408








Two different parallel approaches for a hybrid fractional order Coronavirus	 model
N.H. Sweilam a,âˆ—, S. Ahmed a, Monika Heiner b
a Mathematics Department, Faculty of Science, Cairo University, Giza, Egypt
b Brandenburg Technical University (BTU), Cottbus, Germany


A R T I C L E	I N F O	A B S T R A C T

	

Keywords:
HPC
Parallel computing MPI
GPU CUDA
Julia
Coronavirus mathematical model Fractional predictorâ€“corrector method
In this paper, two different parallel approaches for a hybrid fractional order Coronavirus (2019-nCov) mathematical model are presented. Both parallel approaches are implemented using Julia high level language. Parallel algorithm implementations are developed for the HPC cluster using Message Passing Interface (MPI) technology and general-purpose computing on GPUs (GPGPU) using Compute Unified Device Architecture (CUDA) based on hardware environments. The algorithm implementation are used to solve the real-world problem of the hybrid fractional order Coronavirus (2019-nCov) mathematical model and to study the parallel eï¬ƒciency. The introduced hybrid fractional order derivative is defined as a linear combination of the integral of Riemann-Liouville and the fractional order Caputo derivative. A parallel algorithm is designed based on the predictor-corrector method with the discretization of the Caputo proportional constant fractional hybrid operator for solving the model problem numerically. Simulation results show that, both the new parallel approaches achieve significant eï¬ƒciency.






Introduction

Fractional order derivatives are non-local in nature as the non- integer order operators in mathematical models help us comprehend things better. Models with fractional order derivatives are also bet- ter at capturing fading memory and crossover behaviour, as well as providing a higher accuracy level. It provides more information about predicting diseases under investigation ([1], [2], [3], [4], [5], [6], [19], [20], [21]). The operator of hybrid fractional can be defined as a linear combination of the Riemann-Liouville fractional integral and Caputo derivative. It is one of the most effective and dependable operators. It is more general than the Caputo fractional operator [13]. In addition, the hybrid fractional operator is a better fit for describing biological processes than the Caputo operator [15]. Moreover, optimal control theory has successful applications in biological and medical problems. Furthermore, fractional optimal control problems are a subclass of op- timal control whose dynamics are described by fractional differential equations. We can minimize the impact of the COVID-19 pandemic by minimizing the number of detected asymptomatic infected people who acquire life-threatening symptoms and the threatened percentage
of populations that become extinct. There are very interesting refer- ences in this field, for example, see ([15], [22â€“25]).
In literature, the growing demand for powerful computing tech- nology has counted on increasing the number of cores rather than increasing the performance of a single unit. As a result, parallel comput- ing has risen to prominence as a study topic capable of fulfilling time constraints. Both oï¬„ine and simulations are possible. Despite the in- creasing coding diï¬ƒculty due to the significant rise of computational scale, parallel programming has become increasingly popular [9].
The de facto C/C++/Fortran programming languages paired with MPI, OpenMP, pthread, Cilk, OpenCL, or CUDA are used as a stan- dard for programming large-scale machines on distributed memory HPC Cluster, shared memory and heterogeneous hardware. Julia language is an interesting point on this spectrum due to it was designed by domain experts with scientific and technical computing. Julia is a high-level programming language with a focus on performance and productiv- ity that was created for parallelism and scientific computing, making it a rival choice for developing HPC codes [17]. Since a lightweight API is provided by Julia to call C routines, Utilising C/C++ high- performance libraries has very little overhead and offers productive



* Corresponding author.
E-mail addresses: nsweilam@sci.cu.edu.eg (N.H. Sweilam), sameh@sci.cu.edu.eg (S. Ahmed), monika.heiner@b-tu.de (M. Heiner).

https://doi.org/10.1016/j.eij.2023.100408
Received 11 July 2023; Received in revised form 16 September 2023; Accepted 28 September 2023
Available online 12 October 2023
1110-8665/Â© 2023 THE AUTHORS. Published by Elsevier BV on behalf of Faculty of Computers and Artificial Intelligence, Cairo University. This is an open access article under the CC BY-NC-ND license (http://creativecommons.org/licenses/by-nc-nd/4.0/).



development in a high-level language that uses a lot less code to accom- plish the similar results as C. [18]. At every parallelism level Julia pro- vides built-in primitives for parallel computing by support features like dynamic types, meta-programming features, multiple dispatch, light- weight user threads, support for native code invocation, and packages for distributed, parallel computing.
Julia is Just-in-time (JIT) compiled language and uses LLVM com- piler framework. Juliaâ€™s JIT compiler converting high-level languages, on the fly at run time, into machine language that directly executed on the CPU for eï¬ƒcient subsequent execution by storing optimized code of a function was called. LLVM used as shared intermediate represen-
tation (IR) between different compiler optimization passes before being
ing the parallel algorithms. A comparison of the designs and algorithm approaches described in Section 4 is offered. The Section 5 conclusions.

Notations & preliminaries

In this section, we will review several key definitions of fractional calculus that will be utilised throughout the rest of this article.

of order ğ›¼ for a continuous function ğ‘“ (ğ‘¡) defined as follows [7] Definition 2.1. The left and right sides Riemann-Liouville derivatives
ğ‘¡

ğ›¼	1
ğ‘‘ğ‘›
  ğ‘“ (ğ‘ )	

compiled to machine code. Julia executes native code and offers native ways to call functions of C or FORTRAN shared libraries. Additionally, it has native GPU support and offers a variety of libraries for using the GPU at various levels of abstraction.
Julia has set of libraries and packages that support parallel and dis- tributed computing via Threads.jl, Distributed.jl and MPI.jl. Also, it has
ğ‘ğ·ğ‘¡ ğ‘“ (ğ‘¡)= Î“(ğ‘› âˆ’ ğ›¼) ğ‘‘ğ‘¡ğ‘› âˆ«
ğ‘
ğ‘
ğ‘¡ğ·ğ‘ ğ‘“ (ğ‘¡)= Î“(ğ‘› âˆ’ ğ›¼) ğ‘‘ğ‘¡ğ‘› âˆ«
ğ‘¡
(ğ‘¡ âˆ’ ğ‘ )1âˆ’ğ‘›+ğ›¼ ğ‘‘ğ‘ , ğ‘¡ > ğ‘,	(1)
  ğ‘“ (ğ‘ )	
(ğ‘  âˆ’ ğ‘¡)1âˆ’ğ‘›+ğ›¼ ğ‘‘ğ‘ , ğ‘¡ < ğ‘.	(2)

several packages for GPUs programming, CUDA.jl for NVIDIA GPUs, oneAPI.jl for Intel GPUs and AMDGPU.jl for AMD GPUs. Juliaâ€™s JIT compiler integrate with these libraries to compile Julia code directly to CPU/GPU which make Julia powerful for programming on the GPU. Julia provides basic ahead-of-time compilation tools like PackageCom- piler.jl which allows you to create a system image (serialized Julia
where âˆ’âˆ < ğ‘< ğ‘< +âˆ, Î© = [ğ‘, ğ‘], ğ›¼ âˆˆ â„‚, â„œ(ğ›¼) > 0, ğ‘› = [â„œ(ğ›¼)] + 1.

tegral of order ğ›¼ for a continuous function ğ‘“ (ğ‘¡) are defined as follows Definition 2.2. The left and right sides of the Riemann-Liouvilleâ€™s in-
[7]

sessions) to reduce needed compile times in every session and even en- ables you to create reproducible executable app used in a HPC cluster.
In work [8], the parallel computing algorithm was constructed based on linear tridiagonal equations for solving nonlinear time-space frac-
tional partial differential equations. In [16], a parallel Crankâ€“Nicolson
ğ‘¡
ğ‘ğ¼ğ‘¡ ğ‘“ (ğ‘¡)=  âˆ« (ğ‘¡ âˆ’ ğ‘ )
ğ‘
ğ‘
ğ›¼	ğ›¼âˆ’1
ğ‘“ (ğ‘ )ğ‘‘ğ‘ ]  1  , ğ‘¡ > ğ‘,	(3)
]  1 

finite-difference algorithm on a distributed system is presented for solv- ing time-fractional parabolic equation. A parallel numerical algorithm for fractional-order systems of the Caputo-type derivatives was dis-
ğ‘¡ğ¼ğ‘ ğ‘“ (ğ‘¡)= 
âˆ« (ğ‘¡ âˆ’ ğ‘ )
ğ‘¡
ğ‘“ (ğ‘ )ğ‘‘ğ‘ 
Î“(ğ›¼) , ğ‘¡ < ğ‘.	(4)

cussed in [10,11].
In this work, we construct parallel computing algorithm to solve the hybrid fractional order mathematical model of the Coronavirus (2019- nCov) based on predictorâ€“corrector method (PCM). The discretization in this case of the Caputo proportional constant fractional hybrid oper-
where âˆ’âˆ < ğ‘< ğ‘< +âˆ, Î© = [ğ‘, ğ‘], ğ›¼ âˆˆ â„‚, â„œ(ğ›¼) > 0.

Definition 2.3. The left and right sides of Caputoâ€™s derivatives of order
ğ›¼ for a function, ğ‘“ (ğ‘¡), ğ‘“ âˆˆ ğ´ğ¶ğ‘›[ğ‘, ğ‘] [7] defined as follows
ğ‘¡

ator (CPC-PCM) used for solving the model problem numerically. One
(ğ¶  ğ›¼
ğ¶  ğ›¼
  1		ğ‘“ (ğ‘›)(ğ‘ )

of the advantages of the predictor-corrector method is the ease of its programming, and therefore it is considered one of the good methods for solving biological systems that are described in the form of nonlin- ear differential equations, but they usually take a large time to operate
ğ·ğ‘+ğ‘“ )(ğ‘¡)= (ğ‘ ğ·ğ‘¡ ğ‘“ )(ğ‘¡)= Î“(ğ‘› âˆ’ ğ›¼) âˆ«
ğ‘
ğ‘
ğ‘›
ğ·  ğ‘“ )(ğ‘¥)= ( ğ· ğ‘“ )(ğ‘¡)= 
(ğ‘¡ âˆ’ ğœ‰)1âˆ’ğ‘›+ğ›¼ ğ‘‘ğ‘ , ğ‘¡ > ğ‘,	(5)
  ğ‘“ (ğ‘› ğ‘ 
ğ‘‘ğ‘ ,  ğ‘¡ < ğ‘.	(6)

if we increase the number of points in order to obtain solutions that are accurate enough and to solve such a problem. In this paper, we
ğ‘âˆ’
ğ‘¡  ğ‘
Î“(ğ‘› âˆ’ ğ›¼) âˆ«
ğ‘¡
(ğ‘  âˆ’ ğ‘¡)1âˆ’ğ‘›+ğ›¼

presented one of the ways to improve the performance of this method. Julia high level language used to implement the parallel algorithm for the HPC cluster using Message Passing Interface (MPI) technology and general-purpose computing on GPUs (GPGPU) using Compute Unified Device Architecture (CUDA). The key objectives are:
where âˆ’âˆ < ğ‘< ğ‘< +âˆ, Î© = [ğ‘, ğ‘], ğ›¼ âˆˆ â„‚, ğ‘› = [â„œ(ğ›¼)] + 1, â„œ(ğ›¼) âˆ‰ â„•0.

Definition 2.4. [13] We define the hybrid Caputo proportional frac- tional operator (CP) as follows:

ğ‘¡
0	ğ‘¡	âˆ«
  1	
Î“(1 âˆ’ ğ›¼)

To Construct a parallel computing algorithm to solve the hybrid
fractional order mathematical model of the Coronavirus (2019-
ğ¶ğ‘ƒ ğ·ğ›¼ğ‘¦(ğ‘¡)=	(âˆ’ğ‘  + ğ‘¡)âˆ’ğ›¼ (ğ‘¦â€²(ğ‘ )ğ¾0(ğ‘ , ğ›¼)+ ğ‘¦(ğ‘ )ğ¾1(ğ‘ , ğ›¼))ğ‘‘ğ‘ 	,
0

nCov) using the predictor-corrector method.
=(  (
) ( )+	(
) â€²( ))(  ğ‘¡âˆ’ğ›¼	)

To implement the algorithm using Julia high-level language us- ing Message Passing Interface (MPI) technology to enable parallel
ğ¾1 ğ‘¡, ğ›¼ ğ‘¦ ğ‘¡
ğ¾0 ğ‘¡, ğ›¼ ğ‘¦ ğ‘¡
Î“(1 âˆ’ ğ›¼)
,	(7)

computing on an HPC cluster and Employ general-purpose comput- ing on GPUs (GPGPU) using Compute Unified Device Architecture (CUDA) to enhance performance.
Address the challenge of increased computational time when in- creasing the number of points for accurate solutions.
where, ğ¾0(ğ‘¡, ğ›¼) = ğ›¼ğ‘¡(1âˆ’ğ›¼), ğ¾1(ğ‘¡, ğ›¼) = (1âˆ’ğ›¼) 0 < ğ›¼ < 1.

Alternatively, the hybrid Caputo proportional constant fractional op- erator (CPC) can be used [13]:

ğ‘¡
0	ğ‘¡	âˆ«

The structure of this paper is as follows. After introducing the issue in Section 1, Section 2 presents illustrations of the hybrid fractional- order derivative and the COVID-19 Model. In Section 3, a numerical
ğ¶ğ‘ƒ ğ¶ ğ·ğ›¼ğ‘¦(ğ‘¡) = (Î“(1 âˆ’ ğ›¼))âˆ’1	(ğ‘¡ âˆ’ ğ‘ )âˆ’ğ›¼(ğ‘¡)(ğ‘¦â€²(ğ‘ )ğ¾0(ğ›¼)+ ğ¾1(ğ›¼)ğ‘¦(ğ‘ ))ğ‘‘ğ‘ 
0
= ğ¾0(ğ›¼)ğ¶ ğ·ğ›¼ğ‘¦(ğ‘¡)+ ğ¾1(ğ›¼)ğ‘…ğ¿ğ¼ 1âˆ’ğ›¼ğ‘¦(ğ‘¡),	(8)

approach to the CPC fractional-order problem is described, along with
0  ğ‘¡
0	ğ‘¡

a thorough explanation, pseudo-code, and mechanism for implement-
and, (1 âˆ’ ğ›¼)ğ‘„ğ›¼ = ğ¾1(ğ›¼), ğ›¼ğ‘„(1âˆ’ğ›¼) = ğ¾0(ğ›¼), ğ‘„ is a constant.



Table 1
System (9) variables [12].
variables	Description
Consider the general form of fractional differential equation with CPC operator is as follows:
ğ¶ğ‘ƒ ğ¶ ğ·ğ›¼ğ‘¦(ğ‘¡)= ğœ‰(ğ‘¡, ğ‘¦(ğ‘¡)),  0 < ğ›¼ â‰¤ 1,  ğ‘¦(0) = ğ‘¦ .	(10)

ğ¹	The category of fatality.
ğ»	The hospitalized category.
ğ¸	The exposed category.
0	ğ‘¡	0
By using (8) and GL-approximation to approximate Caputoâ€™s fractional derivatives:

ğ¼	The category of infectious and category.
ğ‘…	The category of recovery.
ğ‘†	The category of susceptible.
ğ´	The category of infectious but asymptomatic.
ğ›¼	1+ğ‘›
ğœğ›¼âˆ’1Î“(2 âˆ’ ğ›¼) ğ‘–=0
ğ‘¦ğ‘›âˆ’ğ‘–+1
[(1 + ğ‘–)(âˆ’ğ›¼+1)
â€“ (ğ‘–)(âˆ’ğ›¼+1)]

 ğ‘ƒ	The super-spreaders category.	
+ ğ›¼ğ‘„(âˆ’ğ›¼+1)
ğœğ›¼
ğ‘¦ğ‘›+1 âˆ’
ğ‘›+1
ğ‘–=1
ğœ‡ğ‘–(ğ›¼)ğ‘¦ğ‘›+1âˆ’ğ‘– âˆ’ ğ‘ğ‘›+1ğ‘¦0)
= ğœ‰(ğ‘¡ğ‘–, ğ‘¦(ğ‘¡ğ‘–)),	(11)

COVID-19 model
and,
ğ›¼
ğ‘„(ğ›¼âˆ’1)
= ğ¾0(ğ›¼), ğ¾1(ğ›¼) = (1âˆ’ğ›¼) , and we can put

In this part, we apply a newly proposed hybrid fractional order derivative to the Coronavirus spreading model from [12]. Eight non- linear differential equations make up this model. The dimension of the
ğ‘„ğ›¼(1 âˆ’ ğ›¼)
ğ‘Ÿ1	ğœğ›¼âˆ’1Î“(2 âˆ’ ğ›¼) ,	ğ‘Ÿ2
ğ‘‡ğ‘“
ğ‘„(1âˆ’ğ›¼)
ğœğ›¼  .

ğ‘–âˆ’1( ğ›¼ )



âˆ’1 ğ›¼

left side would be (ğ‘¡ğ‘–ğ‘šğ‘’)âˆ’ğ›¼ , if we switched the equationsâ€™ order to ğ‘ğ‘™ğ‘â„ğ‘.
We should adjust the parametersâ€™ dimensions to fit the dimensions. Ad-
ditionally, the fractional order system is converted to a classical one
when ğ›¼ â†’ 1. Let us assume that ğ›¿ğ›¼ = ğ›¿ğ›¼ = ğ›¿ğ›¼ = 0. All variables and pa-
Also, ğœ =	, ğ‘ğ‘› âˆˆ â„•. ğœ‡ğ‘–(ğ›¼) = (âˆ’1)
ğ‘›
ğ‘– = 1, 2, ..., ğ‘› + 1. Also, ([14]):
0 < ğœ‡ğ‘–+1 < ğœ‡ğ‘– < ... < ğœ‡1 = ğ›¼< 1,
ğ‘–  , ğœ‡1 = ğ›¼, ğ‘ğ‘– = (Î“(1 âˆ’ ğ›¼))  ğ‘–

ğ‘–	ğ‘	â„

rameter descriptions are provided in Tables 1 and 2. After that, the modified model is given as follows:
ğ¶ğ‘ƒ ğ¶ ğ·ğ›¼ğ‘† =âˆ’ ğ›½ğ›¼ ğ¼ğ‘† âˆ’ ğ‘™ğ›½ğ›¼ ğ»ğ‘† âˆ’ ğ›½â€² ğ›¼ ğ‘ƒ ğ‘† ,
0 < ğ‘	< ğ‘ < ... < ğ‘ =   1	 .
Î“(1 âˆ’ ğ›¼)
We can rewrite (11) as Predictorâ€“corrector method as follows:

0	ğ‘¡
ğ‘
ğ¼ğ‘†
ğ‘
ğ»ğ‘†
ğ‘
ğ‘ƒ ğ‘†
â§ (	)âˆ’ ğ‘Ÿ
âˆ‘ğ‘›+1 ğ‘¦
[(1 + ğ‘–)(âˆ’ğ›¼+1) âˆ’ (ğ‘–)(âˆ’ğ›¼+1)] â«

ğ¶ğ‘ƒ ğ¶ ğ·ğ›¼ğ¸ =ğ›½ğ›¼
+ ğ‘™ğ›½ğ›¼
+ ğ›½â€² ğ›¼
â€“ ğ¾ğ›¼ğ¸,
â¨âª ğœ‰ ğ‘¡ğ‘›, ğ‘¦ğ‘›
1  ğ‘–=1
ğ‘›âˆ’ğ‘–+1	âªâ¬

0	ğ‘¡	ğ‘
ğ¶ğ‘ƒ ğ¶  ğ›¼	ğ›¼
ğ‘	ğ‘
ğ›¼	ğ›¼	ğ›¼
âªâ© +ğ‘Ÿ2 âˆ‘ğ‘›+1 ğ‘ğ‘›+1ğ‘¦0 + ğœ‡ğ‘–ğ‘¦ğ‘›+1âˆ’ğ‘–	âªâ­



0	ğ‘¡
ğ‘	ğ‘–	ğ‘
Predictor

ğ¶ğ‘ƒ ğ¶ ğ·ğ›¼ğ´ =ğ¾ğ›¼(1 âˆ’ ğœŒ1 âˆ’ ğœŒ2)ğ¸,
â§	[	] â«

0	ğ‘¡
ğ¶ğ‘ƒ ğ¶  ğ›¼	ğ›¼
ğ›¼	ğ›¼
âª ğœ‰ ğ‘¡ğ‘›+1, ğ‘¦
)âˆ’ ğ‘Ÿ1 âˆ‘ğ‘›+1 ğ‘¦ğ‘›âˆ’ğ‘–+1
(1 + ğ‘–)(âˆ’ğ›¼+1) âˆ’ (ğ‘–)(âˆ’ğ›¼+1)

ğ¶ğ‘ƒ ğ¶ ğ·ğ›¼ğ‘… =ğ›¾ğ›¼(ğ¼ + ğ‘ƒ )+ ğ›¾ğ›¼ğ», 
â¨âªâ© +ğ‘Ÿ2 âˆ‘ğ‘›+1 ğœ‡ğ‘–(ğ›¼)ğ‘¦ğ‘›+1âˆ’ğ‘– + ğ‘ğ‘›+1ğ‘¦0
â¬âªâ­

0	ğ‘¡	ğ‘–	ğ‘	â„
(Corrector)

Parallel algorithm of hybrid fractional order

In this section, first, we use the predictor-corrector method to nu- merically solve the hybrid fractional order derivatives of COVID-19 Model (Equation (9)). Second, we show the description of our proposed parallel algorithm.

Now, we can put
[(1 + ğ‘–)(âˆ’ğ›¼+1) âˆ’ (ğ‘–)(âˆ’ğ›¼+1)] = ğ‘ƒğ‘–(ğ›¼),
ğ‘›+1
ğ¼	= ğ‘Ÿ	ğ‘¦	ğ‘ƒ (ğ›¼),	ğ·


ğ‘›+1
= ğ‘Ÿ	ğ‘¦ ğ‘


+ ğœ‡ (ğ›¼)ğ‘¦	+ .

Numerical method for the CPC fractional-order equation

In this subsection, the predictor-corrector Scheme is used to study

Then we can write the hybrid Scheme with Predictorâ€“corrector as fol- lows:

numerically the hybrid fractional order derivatives of COVID-19 Model (Equation (9)).
âˆ—
ğ‘›+1
= ğœ‰(ğ‘¡ğ‘›, ğ‘¦ğ‘›)âˆ’ ğ¼ğ‘…ğ‘€ + ğ·ğ¶ğ´ğ‘ƒ .	(14)
ğ‘Ÿ1 + ğ‘Ÿ2

Table 2
The Coronavirus modelâ€™s parameter values [12].








ğ‘
ğ‘–
ğ‘Ÿ
ğ‘–
ğ‘ â„



Fig. 1. General flow chart of the parallel algorithm for hybrid fractional order.



Predictor
ğœ‰(ğ‘¡ğ‘›+1, ğ‘¦âˆ—
)âˆ’ ğ¼ğ‘…ğ‘€ + ğ·ğ¶ğ´ğ‘ƒ
Algorithm 1 Parallel algorithm for hybrid fractional order.
1: Input data: end of time ğ‘‡ , Number of points ğ‘ , Number of process ğ‘ and Current

ğ‘¦ğ‘›+1
= 	ğ‘›+1	 .	(15)
ğ‘Ÿ1 + ğ‘Ÿ2
process ğ‘ğ‘ƒ
2: ğ‘¦0 â† initial condition of system

(Corrector)

method  if  we  put  in  (11),  ğ¾0(ğ›¼) = 1,  ğ¾1(ğ›¼) = 0. Remark 1. We can claim the Caputoâ€™s discrete with Predictorâ€“corrector

Parallel algorithm for hybrid fractional order

In this subsection, the description of the proposed parallel hybrid fractional order (PHFO) algorithm is presented in Algorithm 1, and a general flow chart diagram is presented in Fig. 1.
ğ‘ƒ (ğ›¼), ğœ‡(ğ›¼) and ğ‘ are computed in the initializing stage lines 3-6 to
reduce computation time. At each time step ğ‘› problem was decomposed according to number of available processes ğ‘ to sub tasks lines 9-10. Each available process will compute local ğ¼ğ‘…ğ‘€ and local ğ·ğ¶ğ´ğ‘ƒ lines
13-16. In order to obtain load balancing, all processes will act as master
node so local ğ¼  and local ğ·   will reduced to all available process
3: for ğ‘– = 1 : ğ‘ do	âŠ³ Calculate ğ‘ƒğ‘– (ğ›¼), ğœ‡ğ‘– (ğ›¼)ğ‘ğ‘›ğ‘‘ğ‘ğ‘–
4:	ğ‘ƒğ‘– (ğ›¼) â† (1 + ğ‘–)(âˆ’ğ›¼+1) âˆ’ (ğ‘–)(âˆ’ğ›¼+1)
ğ‘–âˆ’1  ğ›¼
ğ‘–
6:	ğ‘ â†  ğ‘–ğ›¼ 
Î“(1âˆ’ğ›¼)
7: end for
8: for Every time step ğ‘› < ğ‘ do
9:	ğ‘›ğ‘ ğ‘¡ğ‘ğ‘Ÿğ‘¡ â† ğ‘›âˆ•ğ‘ ğ‘ğ‘
10:	ğ‘›ğ‘’ğ‘›ğ‘‘ â† ğ‘›	ğ‘
11:	ğ¼ğ‘…ğ‘€ â† 0
12:	ğ·ğ¶ğ´ğ‘ƒ â† 0
13:	for ğ‘˜ = ğ‘›ğ‘ ğ‘¡ğ‘ğ‘Ÿğ‘¡ âˆ¶ ğ‘›ğ‘’ğ‘›ğ‘‘ do
14:	ğ¼ğ‘…ğ‘€ â† ğ¼ğ‘…ğ‘€ + ğ‘¦ğ‘˜âˆ’ğ‘–+1 ğ‘ƒğ‘˜ (ğ›¼)	âŠ³ compute local ğ¼ğ‘…ğ‘€ at ğ‘ğ‘ƒ
15:	ğ·ğ¶ğ´ğ‘ƒ â† ğ·ğ¶ğ´ğ‘ƒ + ğœ‡ğ‘˜ (ğ›¼) + ğ‘¦ğ‘˜âˆ’ğ‘–+1 âˆ’ ğ‘ğ‘˜+1 ğ‘¦0	âŠ³ compute local ğ·ğ¶ğ´ğ‘ƒ at ğ‘ğ‘ƒ
16:	end for
17:	ğ¼ğ‘…ğ‘€ â† ğ‘€ğ‘ƒ ğ¼ .ğ´ğ¿ğ¿ğ‘Ÿğ‘’ğ‘‘ğ‘¢ğ‘ğ‘’(ğ¼ğ‘…ğ‘€ )	âŠ³ compute global ğ¼ğ‘…ğ‘€ and broadcast to all
process
18:	ğ·ğ¶ğ´ğ‘ƒ â† ğ‘€ğ‘ƒ ğ¼ .ğ´ğ¿ğ¿ğ‘Ÿğ‘’ğ‘‘ğ‘¢ğ‘ğ‘’(ğ·ğ¶ğ´ğ‘ƒ )  âŠ³ compute global ğ·ğ¶ğ´ğ‘ƒ and broadcast to all
process
19:	ğ‘¦âˆ— â† ğ‘“ (ğ‘¡ğ‘› , ğ‘¦ğ‘› ) âˆ’ ğ‘Ÿ1 ğ¼ğ‘…ğ‘€ + ğ‘Ÿ2 ğ·ğ¶ğ´ğ‘ƒ âˆ•(ğ‘Ÿ1 + ğ‘Ÿ2 )	âŠ³ compute the predictor

ğ‘…ğ‘€
ğ¶ğ´ğ‘ƒ
20:	ğ‘¦ğ‘›+1 â† ğ‘“ (ğ‘¡ğ‘›+1 , ğ‘¦âˆ—
) âˆ’ ğ‘Ÿ1 ğ¼ğ‘…ğ‘€ + ğ‘Ÿ2 ğ·ğ¶ğ´ğ‘ƒ âˆ•(ğ‘Ÿ1 + ğ‘Ÿ2 )	âŠ³ compute the corrector

by using ğ‘€ğ‘ƒ ğ¼ .ğ´ğ¿ğ¿ğ‘Ÿğ‘’ğ‘‘ğ‘¢ğ‘ğ‘’() function and each process will compute global ğ¼ğ‘…ğ‘€ and global ğ·ğ¶ğ´ğ‘ƒ lines 17-18 which will be used to update
system local at each process using predictor-corrector method line 19-
21: end for
ğ‘›+1

20. In case ğ‘› less than the number of processes ğ‘, the rest of processes
will be idle.
The graphics processing unit (GPU) is massively parallel processors. GPU is comprised of a set of Streaming Multi-Processors (SM), which form a grid of threads organized into blocks. Several concurrent thread blocks can be running in each SM. To fully utilise all of these threads, multiple thread blocks must be used to run the CUDA programme code under the single instruction multiple data (SIMD) paradigm. The adap- tive CUDA approach code consists of following steps:
Transferring ğ‘¦0, ğ‘ƒ (ğ›¼), ğœ‡(ğ›¼) and ğ‘ data to the global GPU memory.
For every time step iteration running the CUDA kernel core.
Compute local ğ¼ğ‘…ğ‘€ and ğ·ğ¶ğ´ğ‘ƒ
Reducing ğ¼ğ‘…ğ‘€ and ğ·ğ¶ğ´ğ‘ƒ
Update next ğ‘¦ğ‘› on GPU memory
Transferring the final results from the GPU to the CPU memory.

Computational and experimental results

This section presents the implementation results for the paralleliza-
Model (9) at ğ›¼ = 0.9 using the parameters in Table 2. The initial condi- tion method for solving hybrid fractional order derivatives of COVID-19 tions given as follows ğ¸(0) = 0, ğ‘…(0) = 0, ğ‘†(0) = ğ‘ âˆ’6, ğ¹ (0) = 0, ğ‘ƒ (0) = 5,
ğ¼ (0) = 1, ğ» (0) = 0, ğ´(0) = 0. The parallel execution times Tp of the proposed algorithm implementation with different ğ‘ problem sizes us- ing different ğ‘ numbers of processes are presented. The parallelization
speedup (Sp) and the eï¬ƒciency of parallelization (E) are used to exam- ine the varying effectiveness of parallel execution time. The speedup


	



Fig. 2. Execution time for PHFO algorithm.

(Sp) is determined as the ratio of the time it takes for a programme to run on one node (T1) to the execution time on P processes (Tp). The ef- ficiency of the parallelization is calculated as the speedup (Sp) divided by the number of processes (P).
Julia has two popular distribution modes: MPI.jl and Distributed.jl. Message Passing Interface (MPI) is a standard Julia wrapper built on the single-program multiple-data (SPMD) paradigm. It is the most ideal choice for large-scale distributed parallel computing. It is very flexi- ble and easy to use it from Julia and get similar C performance. Dis- tributed.jl is the method to spawn new processes in separate memory spaces. Supports distributed array operations for distributed memory machines, its master-slave distributed architecture makes it good for many-core and multi-processor systems. Julia supports native GPU, we will use CUDA.jl the basic programming interface essential to using NVIDIA CUDA GPUs in Julia. CUDA.jl provides a lower-level approach for writing kernels for fine-grained control and user-friendly high-level abstractions.
The MPI- and CUDA-based environments have been used for compu- tational analysis. Proposed algorithm simulation was implemented and compiled using Julia programming language version 1.7.2 using MPI.jl and CUDA.jl packages. The serial performance results were obtained on a single core.

MPI-based environments

MPI-based environments simulations were run on the HPC system provided by faculty of nanotechnology Cairo university Cluster. Each node has two sockets, each with an Intel(R) Xeon(R) Gold 6130 @
2.10 GHz with 96 GiB of memory.
Fig. 2 present the parallel execution time of run time results (in seconds) using various time step sizes (number of global points). As we can see in Figs. 2 execution times decreases with increasing number of processes.
Fig. 3 presents experimental speedup curves for various time step sizes using increasing number of processes. As we can see, that the ef-
length. Fig. 4 show resulting an eï¬ƒciency about 80% using 16 pro- fectiveness of the parallelization increases with increasing considered
cesses.
The results in Figs. 2, 3, 4 and 5 demonstrate the Execution time, speedup and eï¬ƒciency of our parallel MPI implementation for solving hybrid fractional-order systems in Julia. Our implementation provides a significant speedup over a serial implementation and maintains high eï¬ƒciency values for a range of numbers of processes. This makes it a
Fig. 3. Speedup for PHFO algorithm.


Fig. 4. Eï¬ƒciency for PHFO algorithm.


Fig. 5. The speedup (blue dashed) and the eï¬ƒciency (red dots) of the paral- lelization depending on the number of processes (P) for the PHFO algorithm at
N =220 ; the maximum possible speedup is indicated by a green solid line.



Table 3
GPU time in seconds for the solution of the model (9).

Number of steps (N)	CUDA running time	CUDA last step running time



valuable tool for solving fractional-order systems in parallel and can be particularly useful for large systems or systems that require high computational resources.

CUDA-based environments

CUDA-based environments simulations was run on the HPC system provided by SRTA CITY Cluster Gpu machine PowerEdge Dell 740XD (2Ã— Intel Xeon Gold 6248) with Tesla V100 GPU (5120 CUDA cores, 32 GB RAM).
Table 3 present the CUDA execution time results (in seconds) and
problem size N = 216 , 217 , 218 , 219 and 220 (Fig. 6). At N= 220 CUDA execution time for last time step iterations at a different number of implementation obtains speedup S â‰ˆ 16. Fig. 7 presents comparing ex-
ecution time for CUDA approach and MPI with 16 processes approach implementations.


Fig. 6. Execution times of last step for different problem sizes N.
Numerical results and analysis

We used CPC-PCM to solve the hybrid fractional-order system (9) in order to execute the numerical simulations in the following section. We use the values of parameters in Table 2, with the initial conditions
ğ¸(0) = 0, ğ‘…(0) = 0, ğ‘†(0) = ğ‘ âˆ’ 6, ğ¹ (0) = 0, ğ‘ƒ (0) = 5, ğ¼ (0) = 1, ğ» (0) = 0,
ğ´(0) = 0. Wuhan has a population of approximately 11 million people.
The individual movement was restricted in the city during the COVID-
19 outbreak because of quarantine. As a result, a restriction on the
model, and ğ‘ = 11000000 [12] and 0 < ğ›¼ 1 and 0 < ğ‘„ 1. Fig. 8, illus- disease spread was provided. We examine the whole population in our
different values of ğ›¼ and ğ›¿ğ¼ = ğ›¿ğ‘ = ğ›¿â„ = 0. This figure describes how so- trates the numerical answers for the suggested modelâ€™s (9) behaviour at lutionsâ€™ behaviour alters when we use different values ğ›¼. The fractional
model gave us more details about spreading the disease. Moreover, this model is more general than the classical model of integer order.

Conclusions

Two parallel approaches for solving the mathematical model of the hybrid fractional order Coronavirus (2019-nCov) are constructed. The parallel approaches are implemented on a distributed system us- ing a message-passing interface (MPI) and A GPU-CUDA Framework. The advantages and comparison of the parallel approaches over the sequential are discussed. CPC derivative is defined as a linear combi-


Fig. 7. Execution times of CUDA and MPI 16 processes for different problem sizes N.




Fig. 8. The behaviour numerical solutions for the model (9).



nation of the integral of Riemann-Liouville and the fractional order Ca- puto derivative. Two parallel approaches are constructed based on the predictor-corrector method with the Caputo proportional constant frac- tional hybrid operatorâ€™s discretization for solving the modelâ€™s problem numerically. Numerical experiments using a different number of nodes of the Intel(R) Xeon(R) Gold 6130 Linux PC Cluster and Tesla V100 GPU (5120 CUDA cores, 32 GB RAM) were used to test the eï¬ƒciency of the developed parallel algorithms, which delivered a considerable performance boost in terms of execution times.

CRediT authorship contribution statement

N.H. Sweilam: Methodology, Supervision, Validation, Writing â€“ re- view & editing. S. Ahmed: Conceptualization, Data curation, Methodol- ogy, Software, Writing â€“ original draft. Monika Heiner: Investigation, Visualization, Writing â€“ review & editing.

Declaration of competing interest

There is no competing interest.

References

Agarwal P, Ramadan MA, Rageh AAM, Hadhoud AR. A fractional-order mathemat- ical model for analyzing the pandemic trend of COVID-19. Math Methods Appl Sci 2021. https://doi.org/10.1002/mma.8057.
Atangana A, Araz SI. A novel Covid-19 model with fractional differential operators with singular and non-singular kernels: analysis and numerical scheme based on Newton polynomial. Alex Eng J 2021;60(4):3781â€“806. https://doi.org/10.1016/j. aej.2021.02.016.
Pinto CMA, Tenreiro Machado JA, Burgos-SimÃ³n C. Modified SIQR model for the COVID-19 outbreak in several countries. Math Methods Appl Sci 2022. https://doi. org/10.1002/mma.8082.
Yadav S, Kumar D, Singh J, Baleanu D. Analysis and dynamics of fractional order Covid-19 model with memory effect. Results Phys 2021;24:104017.
Zhang L, Rahman MU, Ahmad S, Riaz MB, Jarad F. Dynamics of fractional order delay model of coronavirus disease. AIMS Math 2021;7(3):4211â€“32.
Sweilam NH, AL Mekhlafi SM, Almutairi A, Baleanu D. A hybrid fractional COVID- 19 model with general population mask use: numerical treatments. Alex Eng J 2021;60(30):1â€“14. https://doi.org/10.1016/j.aej.2021.01.057.
Podlubny I. Fractional differential equations. New York: Academic Press; 1999.
Biala TA, Khaliq AQM. Parallel algorithms for nonlinear time-space fractional parabolic PDEs. J Comput Phys 2018;375:135â€“54.
Pacheco P. An introduction to parallel programming. Burlington, NJ, USA: Morgan Kaufmann; 2011.
Bonchis C, Kaslik E, Rosu F. HPC optimal parallel communication algorithm for the simulation of fractional-order systems. J Supercomput 2019;75:1014â€“25.
Wang Q, Liu J, Gong C, Tang X, Fu G, Xing Z. An eï¬ƒcient parallel algorithm for Caputo fractional reaction-diffusion equation with implicit finite-difference method. Adv Differ Equ 2016;207.
NdÃ¤rou F, Area I, Nieto JJ, Torres DFM. Mathematical modeling of COVID-19 trans- mission dynamics with a case study of Wuhan. Chaos Solitons Fractals 2020. https:// doi.org/10.1016/j.chaos.2020.109846.
Baleanu D, Fernandez A, AkgÃ¼l A. On a fractional operator combining propor- tional and classical differintegrals. Mathematics 2020;8(3). https://doi.org/10. 3390/math8030360.
Scherer R, Kalla S, Tang Y, Huang J. The GrÃ¼nwald-Letnikov method for fractional differential equations. Comput Math Appl 2011;62:902â€“17.
Sweilam NH, Al-Mekhlafi SM. A survey on numerical studies for fractional bio- logical models and their optimal control. In: Radwan Ahmad G, Khanday Farooq A, Said Lobna A, editors. Fractional order systems; an overview of mathematics, design, and applications for engineers. Academic Press. ISBN 978-0-12-824293-3, 2022. Chapter 1.
Sweilam NH, Moharram H, Moniem NKA, Ahmed S. A parallel Crankâ€“Nicolson finite difference method for time-fractional parabolic equation. J Numer Math 2014;22(4):363â€“82. De Gruyter.
Bezanson J, Edelman A, Karpinski S, Shah VB. Julia: a fresh approach to numerical computing. SIAM Rev 2017;59(1):65â€“98.
Hunold Sascha, Steiner Sebastian. Benchmarking Juliaâ€™s communication perfor- mance: is Julia HPC ready or full HPC. In: 2020 IEEE/ACM performance modeling, benchmarking and simulation of high performance computer systems (PMBS); 2020.
p. 20â€“5.
Kumar P, Rangaig NA, Abboubakar H, Kumar A, Manickam A. Prediction studies of the epidemic peak of coronavirus disease in Japan: from Caputo derivatives to Atangana-Baleanu derivatives. Int J Model Simul Sci Comput 2022;13(1):2250012.
Abboubakar H, Fandio R, Sofack BS, Ekobena Fouda HP. Fractional dynam- ics of measles epidemic model. Axioms 2022;11(8):363. https://doi.org/10.3390/ axioms11080363.
Kumar P, Erturk VS, Govindaraj V, Inc M, Abboubakar H, Nisar KS. Dynamics of COVID-19 epidemic via two different fractional derivatives. Int J Model Simul Sci Comput 2023;14(3):2350007.
Marzban HR. Optimal control of nonlinear fractional order delay systems governed by Fredholm integral equations based on a new fractional derivative operator. ISA Trans 2023;133:233â€“47.
Marzban HR, Nezami A. Analysis of nonlinear fractional optimal control systems de- scribed by delay Volterra-Fredholm integral equations via a new spectral collocation method. Chaos Solitons Fractals 2022;162:112499.
Sabermahani S, Ordokhani Y, Rahimkhani P. Application of generalized Lucas wavelet method for solving nonlinear fractal-fractional optimal control problems. Chaos Solitons Fractals 2023;170:113348.
Dehestani H, Ordokhani Y. An eï¬ƒcient approach based on Legendre-Gauss-Lobatto quadrature and discrete shifted Hahn polynomials for solving Caputo-Fabrizio fractional Volterra partial integro-differential equations. J Comput Appl Math 2022;403:11385.
