Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 286 (2012) 103–116
www.elsevier.com/locate/entcs
Nominal SOS
Matteo Ciminia MohamamdReza Mousavib Michel A. Reniersc Murdoch J. Gabbayd
a Department of Computer Science, Reykjav´ık University, Reykjav´ık, Iceland
b Department of Computer Science, TU/e, Eindhoven, The Netherlands
c Department of Mechanical Engineering, TU/e, Eindhoven, The Netherlands
d Computer Science Department, Heriot-Watt University, Edinburgh, United Kingdom

Abstract
Plotkin’s style of Structural Operational Semantics (SOS) has become a de facto standard in giving op- erational semantics to formalisms and process calculi. In many such formalisms and calculi, the concepts of names, variables and binders are essential ingredients. In this paper, we propose a formal framework for dealing with names in SOS. The framework is based on the Nominal Logic of Gabbay and Pitts and hence is called Nominal SOS. We define nominal bisimilarity, an adaptation of the notion of bisimilarity that is aware of binding. We provide evidence of the expressiveness of the framework by formulating the early π-calculus and Abramsky’s lazy λ-calculus within Nominal SOS. For both calculi we establish the operational correspondence with the original calculi. Moreover, in the context of the π-calculus, we prove that nominal bisimilarity coincides with Sangiorgi’s open bisimilarity and in the context of the λ-calculus we prove that nominal bisimilarity coincides with Abramsky’s applicative bisimilarity.
Keywords: SOS, Nominal SOS, Nominal calculi, λ-calculus, π-calculus.

Introduction
The development of a formal semantics for programming and specification languages is a necessary first step towards rigorous reasoning about them. For instance, a formal semantics allows one to prove the correctness of language implementations, and is a prerequisite for proving the validity of program optimizations. Operational semantics is a widely-used methodology to define formal semantics for computer
languages, which represents the execution of programs as step-by-step development of an abstract machine. Structural Operational Semantics (SOS) was introduced by Gordon Plotkin in [24], reprinted in [25], as a logical and structural approach to
defining operational semantics. The logical structure of SOS specifications supports a variety of reasoning principles that can be used to prove properties of programs whose semantics is given using SOS. Moreover, SOS language specifications can

1571-0661 © 2012 Published by Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2012.08.008

be used for rapid prototyping of language designs and to provide experimental implementations of computer languages.
SOS has become the de facto standard for defining operational semantics, and a wealth of programming and executable specification languages have been given formal semantics using it. In recent years much work on the underlying theory as well as on the practice of SOS has been carried out—see, e.g., [3,21] and [6,13,20], respectively. Many programming and specification languages make use of the con- cepts of names and binders. For example, in the π-calculus [18,19,29], names are first-class objects and the whole language is built on the idea that concurrent agents communicate by exchanging names.  Incorporating nominal notions within SOS has received some attention in recent years, but nevertheless the meta-theory of SOS is not sufficiently adapted for these new frameworks. In this paper we propose a formal framework for the handling of names in SOS, called Nominal SOS, which is based on the nominal techniques of Gabbay, Pitts, and Urban [11,31].
The most important notion of equivalence of programs in the context of SOS is bisimilarity [22]. We argue that this notion, taken as it is, is not satisfactory and we adapt bisimilarity in order to better suit our context with binders. We call this equivalence nominal bisimilarity.
Basic notions such as α-conversion and substitution are essential parts of most nominal calculi. We show that these notions can be naturally captured in the Nominal SOS framework. Moreover, we give evidence of the expressiveness of our framework by modeling two of the most prominent examples of nominal calculi, namely the lazy λ-calculus and the early π-calculus. For both we show that our specifications coincide operationally with the original definitions of [2] and [29], respectively. We moreover prove that in the case of the π-calculus our notion of nominal bisimilarity coincides with the well-known open bisimilarity of Sangiorgi [29,28]. Finally, we show that nominal bisimilarity in the context of our formulation of the lazy λ-calculus coincides with the applicative bisimilarity of Abramsky [2].
Proofs are omitted in the main text and the reader can find them, together with a fully elaborated account of Nominal SOS, in [8]. This document extends the last chapter of Cimini’s Ph.D. thesis [7].
Structure of the paper. The rest of the paper is organized as follows. In Section 2 we define nominal terms and in Section 3 we define the framework of Nominal SOS. We show in Section 4 how α-conversion and different types of substitution can be accommodated in Nominal SOS. Section 5.1 is devoted to our formulation of the π-calculus and Section 5.2 addresses the lazy λ-calculus. In Section 6 we discuss related work and Section 7 concludes the paper.
Nominal terms
The following definitions of sorts and nominal signature are familiar from [31].
Definition 2.1 (Sorts) Sorts are deﬁned inductively by the following grammar:
σ ::= 1 | δ | A | [A]σ | σ × σ,

where 1 is the unit sort, δ is a base sort, A is an atom sort, [A]σ denotes an abstraction sort, and × denotes pairing.
Intuitively, [A]σ is a sort whose elements are functions from objects of sort A to objects of sort σ. As is standard, pair sorts will associate to the left, so that σ1 × σ2 × σ3 stands for (σ1 × σ2) × σ3.
Definition 2.2 (Nominal signature) A  nominal  signature  Σ  is  a  triple
(Δ, A,F ), where
Δ is a set of base sorts ranged over by δ,
A is a set of atom sorts ranged over by A, and
F is a set of operators f(σ1×...×σn)→δ, denoting a function symbol f with arity (σ1 × ... × σn) → δ, where n ≥ 0.
For each atom sort A, we fix a countably infinite set of atoms aA, bA, cA, dA
..., and for each sort σ, we assume a countably infinite set Vσ of variable symbols
xσ, yσ, zσ	We sometimes write just f , a, b, c, d, n, m, and x, y, z, leaving arities and sorts implicit (but still present). We assume that all these sets of symbols are pairwise disjoint.
Definition 2.3 (Nominal terms) Given a signature Σ = (Δ, A,F ), the set of nominal terms over the signature Σ is denoted by T(Σ) and it is deﬁned as follows, where we write tσ for a term t of sort σ:
t ::= xσ | aA | ([aA]tσ)[A]σ | (f(σ1×...×σn)→δ (tσ1 ,.	, tσn ))δ
where A ∈ A, aA ∈ A, xσ ∈ Vσ and f ∈ F with arity (σ1 ×  × σn) → δ.
The subscripts of nominal terms control sorting and we tend to omit them when they are clear from the context or immaterial. We call [a]t an abstraction. We have not introduced any means to introduce pairs of terms, as we only use product sorts to give a sort to transition relations (see Section 3).
For a nominal term t, the following definitions will be useful in the remainder of the paper. In what follows, f and g are a unary and a binary function symbol.
A(t) stands for the set of atoms that occur in t. For example, A(f ([a]g(a, b))) =
{a, b}.
ba(t) is the set of atoms a for which there exists a subterm [a]tj in t, i.e., the set of abstracted atoms in t. For example, ba(f ([a]g(a, b))) = {a}.
fa(t) is the set of atoms a in A(t) that have an occurrence in t that is not within the scope of an abstraction [a]tj, for some term tj. We call fa(t) the set of free atoms of t. For example, fa(f ([a]g(a, b))) = {b} and also fa(g(f ([a]a), a)= {a}.
An atom a is fresh in t whenever a /∈ fa(t). We also say that a term t is binding- closed if fa(t)= ∅, i.e., the term t does not contain free atoms. 1

1 Binding-closed terms corresponds to those that in literature are usually called closed. For instance, in the context of the λ-calculus the λ-term λa.λb.(a b) is closed, as it does not contain free variables, see [2,4]. We adopt a different nomenclature in order to avoid confusion with the standard concept of closed term of

We say that a nominal term is closed if it contains no variables. It is called open otherwise. For example, a and [a]f (b) are closed terms, but x and [a]y are open terms. Note that neither a nor [a]f (b) is binding-closed.

Nominal SOS
Suppose a is an atom and t is a term of some sort. We call a formula a#t a freshness assertion. In what follows we give a derivation system in order to derive freshness assertions.
Definition 3.1 (Freshness derivation rules) Let Σ be a nominal signature, and let the atom a and the term t be over the signature Σ. We say that a#t is derivable when it may be derived using the following rules, where a and b are distinct atoms.




a#b
a#t1,..., a#tn		

a#f (t1,..., tn)	a#[a]t
a#t a#[b]t

These derivation rules are familiar from existing work [31,9].
We are now ready to define the notion of nominal transition system speciﬁcation
whose rules employ the freshness assertions defined above.
Definition 3.2 (Nominal Transition System Specification) A nominal tran- sition system specification ( NTSS) is a triple (Σ, R, D) consisting of:
A nominal signature Σ;
A set of (transition) relation symbols R. To each r ∈ R we associate a (tran- sition relation) arity which is a sort of the form σ×σl ×σj. We may call: σ the ‘sort of the source of the transition’, σj the ‘sort of the target of the transition’, and σl the ‘sort of the label of the transition’.
A set of derivation rules D (see below).
Given an NTSS T , we denote with A(T ) the set of atoms of the signature of T . For a relation r ∈ R with arity σ × σl × σj, if σl is the unit sort 1 then we say that r has no label. If σj is also the unit sort, then r is a predicate symbol. We may silently drop σl (and σj) if they are the unit sort.
For a relation r ∈ R with arity σ×σl ×σj,a positive transition formula is written t →l r tj, where t is a possibly open term of sort σ (we call it the source term), l is a possibly open term of sort σl (we call it the label ), and tj is a possibly open term of sort σj (we call it the target term).

For the same relation r, we write t
~l r for a negative transition formula, where

t is of sort σ and l is of sort σl. A transition formula is a positive or negative transition formula.

SOS, i.e., a term that contains no variables.

Definition 3.3 (Derivation rule) A derivation rule is of the form


{t →li	tj | i ∈ I}	{
lj
| j ∈ J}	{a #t
| k ∈ K}

i	ri i
tj ~rj	k	k
t →l r tj


where
I, J and K are indexing sets,

{ti
li
ri
j | i ∈ I} is a set of positive transition formulae, called the positive

premises of the rule,
lj
{tj ~rj  | j ∈ J} is a set of negative transition formulae, called the negative
premises of the rule,
{ak#tk | k ∈ K} is a set of freshness assertions, called the freshness premises of the rule, and
t →l r tj is a positive transition formula, called the conclusion of the rule.
We call t, l, and tj the source, the label and the target of the rule, respectively.
We call a derivation rule an axiom if I, J and K are empty. A derivation rule is positive when the index set J is empty. An NTSS is positive when all its deduction rules are positive. Positive NTSS’s come with a natural notion of semantics, i.e., the set of provable closed transitions formulae; the same notion is adopted for the semantics of freshness formulae by means of the derivation rules given in Definition
In this paper we restrict ourselves to positive NTSS’s; the semantics of full Nominal SOS can be found in [7, Section 5.3.1].
The most important notion of equivalence between programs defined in SOS is bisimilarity [17,22]. Unfortunately, this equivalence turns out not to be satisfactory in a context with binders. This point is carefully explained, in the context of the π- calculus, on pages 64-65 of [29], where it is shown that the two processes P = νz.xz
x(y)
and Q = νz.(xz || νw.wy) are distinguished since P can perform a transition →
x(y)
while Q is not able to perform any → transitions; the reason is that Q is not able
to change its bound variable to y since y is not fresh in Q.
Nominal bisimilarity is thus introduced below as an adaptation of the ordinary bisimilarity that is aware of binding. What happens in the theory of the π-calculus
x(z)
is that bisimilarity is adjusted and transitions of the form → are matched only
for those bound variables that are fresh in both terms. Our notion of bisimilarity revisits the ordinary bisimilarity in such a manner. In the remainder of the paper we will relate nominal bisimilarity to important notions of equivalence in the literature.
Definition 3.4 (Nominal bisimilarity) Let T be an NTSS. Nominal bisimilarity
↔––T is the largest symmetric binary relation ∼ over closed terms of T such that for all closed terms P and Q and labels l such that P ∼ Q and a#P and a#Q for all

a ∈ ba(l), it holds that if P →l
Pj then there exists Qj such that Q →l
Qj and Pj ∼ Qj.

Substitution and α-conversion
Substitution transitions
Substitution and α-equivalence play a key role in the definition of the semantics of calculi with binders. We will now show how those notions can be accommodated in a uniform fashion within the framework of Nominal SOS.
Term-for-atom substitutions are typically employed by higher-order calculi, such as the λ-calculus, the Calculus of Higher Order Communicating Systems (CHOCS)
[30] and the Higher-Order π-calculus [26], just to mention a few. Given a nominal signature, we proceed to generate the following types of deduction rules with the
Ta  t2
goal of proving transitions of the form t1 −→ t3 for some atom a and terms t1, t2
and t3. This type of transition should be read as the term t2 replaces the atom a in the term t1 leading to the term t3. For all atoms a and function symbols f , we have the following rules.



T
a −a→→z z (a1Ts)
a#x
T

(a2Ts)
T
y'→z
x −→ x
a#z	a#y
T

(abs1Ts)

a −x→→z a
y'→z
[a]x




T
y'→z  j
−→ [a]x
)


T
[a]x −a→→z [a]x (abs2Ts)
xi −→ xi | 0 < i ≤ n


T
f (x ,x ,...,x ) y'→z f (xj , xj ,..., xj )
(fTs)

1	2	n  −→	1	2	n
The reader can infer the sort of the variables used in the rules by their usage. In
the rules above we use variables of atom sort whenever possible with the exception of rule (a1Ts) that would appear less readable. The reader may be more familiar with the syntactic substitution operation, defined below, where M and N are closed terms and a and b are distinct atoms.
a[N/a]= N	a[N/b]= a	([a]M )[N/a]= [a]M
([a]M )[N/b]= [a](M [N/b]) if a is fresh in N
f (M1, M2,..., Mn)[N/a]= f (M1[N/a], M2[N/a],..., Mn[N/a])
The following theorem states that the two notions (substitution transitions and syntactic substitutions) correspond 2 .
Theorem 4.1 (Correctness of Substitution Transitions) Let T be an NTSS.
T
Let M and N be closed terms, and a be an atom. Then, it holds that M a−→→N
Mj if and only if Mj = M [N/a].
Atom-for-atom substitution is used in calculi such as the π-calculus [29,19] and its variants. The same set of rules provided for the term-for-atom substitution are

2 Theorem 4.1 is stated as Theorem 2 in Section 4.1 of [8] and proved in Section 13 of that paper.


A
able to model the atom-for-atom substitution. These transitions are denoted −x→→z and the first and second argument of this label range over atoms.
A syntactic atom-for-atom substitution over nominal terms, together with its corresponding correctness theorem, can be provided. It turns out to be just a straightforward adaptation of Theorem 4.1.

α-conversion Transitions
The notion of α-conversion is a natural equivalence guaranteeing that the exact atom chosen in binders is not important and can be indeed replaced by any other atom (while avoiding capture). Thanks to freshness assertions, we can accommodate α-conversion in our framework as an ordinary transition relation. Given a nominal signature, the following deduction rules define →α . For all atoms a and b and function symbols f , we have the following rules. 3



x →α x (idα)
A
x −a→→b y	b#x

[a]x →α [b]y

(abs1α)
x →α y


[a]x →α [a]y

(abs2α)



j
i


f (x1, x2,..., xn) →α f (xj , xj ,..., xj )
(fα)
x →α y	y →α z


x →α z

(α · upToα)

1	2	n
The reader will notice that α-conversion transitions rely on those for the atom- for-atom substitution (rule (abs1α)). Throughout the paper, whenever we say that the rules above for α-conversion transitions are present in an NTSS, this implies that also the rules for atom-for-atom substitutions are present.
The reader is perhaps familiar with the syntactic version of α-conversion, defined below.
Definition 4.2 (α-conversion over nominal terms) Let T be an NTSS. The relation =α is the least congruence on nominal terms over the signature of T, such that, for all closed term M and an atom b, if b is fresh in M then [a]M =α [b]M [b/a].
The set of rules for α-conversion transitions generated above actually behaves ac- cording to the syntactic α-conversion, as stated in the following theorem 4 .
Theorem 4.3 (Correctness of α-conversion transitions) Let T be an NTSS. For all closed terms M and N over the signature of T , it holds that M →α N if and only if M =α N.
Calculi with binders usually consider a term as a representative of the equiva- lence class of all the terms that are α-convertible to it. In Nominal SOS, it is possible to achieve this by augmenting the NTSS with a deduction rule, given below.

3 In the nominal world, the standard definition of α-equivalence is based on permutations, see [11] for instance. However, we preferred to model the standard definition of α-equivalence.
4 Theorem 4.3 is stated as Theorem 3 in Section 4.2 of [8] and proved in Section 14 of that paper.

Definition 4.4 (Transitions up to α-equivalence) Let T be an NTSS and l be

a label of the signature of T . The transition relation →l
is up to α-equivalence

whenever the deduction rules of T contain the rules for α-conversion transitions, as deﬁned above, the rules for atom-for-atom substitution transitions, as deﬁned in Section 4.1, and the deduction rule:
x →α y	y →z
(l · upToα).
x →l z
Depending on the peculiarities of the calculus at hand, the modeller might want to consider defining some of the transition relations to be up to α-equivalence.
Examples
In this section we provide some evidence of the expressiveness, and perhaps natural- ness, of Nominal SOS by formulating in our framework two classical calculi, namely the early π-calculus [29,19] and the lazy λ-calculus [2].
The early π-calculus and open bisimilarity
The signature Σπ of our π-calculus is modelled by a base sort P and atom sort C
(for processes and channels, respectively) and the following function symbols.
0 :→ P for inaction (deadlock),
τ. : P → P for τ -prefix,
out( , , ): (C × C × P ) → P for output prefix,
in( , ): (C × [C]P ) → P for input prefix,
ν( ): [C]P → P for restriction,
|| : (P × P ) → P for parallel composition,
(vii)	+ : (P × P ) → P for nondeterministic choice,
(viii) ! : P → P for parallel replication.
The syntax employed for input and output prefixes differs slightly from the standard notation used in the π-calculus. In particular, our term out(a, b, P ) corre- sponds to the process ab.P of the π-calculus, and in(a, [b]P ) corresponds to a(b).P . The same choice is adopted for the labels.
Below, we specify the semantics of the early π-calculus in Nominal SOS. Since in our framework labels are open terms, we display an input transition label as in(a, b), assuming a different operator in accepting two atoms as arguments. For presenta- tional purposes, we use the same names to stipulate the meaning of the transitions. For the same reasons, we model an output transition label as out(a, b) and a bound output transition label as bout(a, [b]0), abbreviated as bout(a, [b]) throughout the text. The set of rules of the signature Σπ contains the following rules, we use α to range over labels and a, b and c to range over atoms.




τ.x →τ

(τ )
x

out(a, b, x)

out(a,b)
→	x
(out)
A
x −b→→c y
in(a,c)

(in)

in(a, [b]x) →  y

x1 →α y1
(sum1)

α /∈ {bout(a, [b]) | a, b ∈ C}
x1 →α y1

(par1)

x1 + x2 →α y1
x1 || x2 →α y1 || x2

bout(a,[b])
x1	→	y1	b#x2
(parRes1)
out(a,b)
x1	→	y1	x2
in(a,b)
→  y2

x1 || x2
bout(a,[b])
→	y1 || x2
x1 || x2 →τ
y1 || y2
(com1)

bout(a,[b])
x1	→	y1	x2
in(a,b)
→  y2	b#x2
(close1)
x →α y

(repl)

x1 || x2 →τ
ν([b](y1
|| y2))
!x →α y ||!x

out(z,a)
x	→	y	a /= z


bout(z,[a])
ν([a]x)	→	y

(open)

c /∈ ba(α)
x →α y	c#α ν([c]x) →α ν([c]y)

(res)

For the sake of brevity, we omit the symmetric versions of rules (sum1), (par1),

(parRes1), (com1) and (close1).	Moreover, for each label l, →l
is up to α-

equivalence. Following the recipe of Definition 4.4 we add to our NTSS the set of rules for α-conversion transitions and the rules for atom-for-atom substitution transitions. We set the atom-for-atom transition relations to be up to α-equivalence, too.
The reader must notice that the complicated side-conditions of the ordinary formulation of π-calculus are here replaced by rather simpler freshness conditions, see rules (parRes1) and (close1).
We denote by Π the set of π-terms of [29]. The encoding J·)π is a map from Π into terms of our nominal π-calculus. The mapping is straightforward and its definition is omitted here; it can however be found in [8]. 5 The following theorem establishes that our formulation of the early π-calculus is operationally correct with respect to its original formulation 6 .
Theorem 5.1 (Operational Correspondence: early π-calculus) For   all
α	π Jα)π	π

P, Q ∈ Π, P →Q ⇔ JP )	→ JQ)
, where α ranges over the labels of the form τ,

ab, ab and a(b) from the original early π-calculus.
The reader may wonder what is the equivalence over π-calculus terms that cor- responds to nominal bisimilarity. The next theorem provides us with an answer: nominal bisimilarity in our formulation of the early π-calculus coincides with San- giorgi’s open bisimilarity, see [29, Section 4.2] and [28].

5 The encoding can be found in Section 5.2 of [8]. By way of example the reader can consider that
Jνz.x(z)||z(a).0)π = ν([z](bout(x, z)||in(z, [a]0))).
6 Theorem 5.1 is stated as Theorem 5 in Section 5.2 of [8] and proved in Section 16 of that paper.

Definition 5.2 (Open bisimilarity) Open bisimilarity ↔o is the largest symmet- ric relation ∼ on Π such that whenever P ∼ Q, and σ is a substitution (see Deﬁni- tion 1.1.3 on page 14 of [29]), if Pσ →α Pj, then there exists Qj, such that Qσ →α Qj and Pj ∼ Qj.
The reader should notice that this definition is the very basic formulation of open bisimilarity, which does not involve distinctions, see [29] and [28]. In Definition 5.2, it is important to note that the ranging over all the substitutions is performed at each step of the bisimulation game.
Theorem 5.3 (Open bisimilarity and Bisimilarity coincide) For all P, Q ∈
Π, P ↔o Q if, and only if, JP )π ↔–– JQ)π.
Theorem 5.3 essentially holds because in our nominal formulation of the π- calculus, nominal bisimilarity also takes into account the substitutions transitions 7 . In [7, Section 5.21], it is shown that if nominal bisimilarity is adapted not to match the substitution transitions it would coincide with the ordinary bisimilarity over the π-calculus.

The lazy λ-Calculus and applicative bisimilarity
The signature Σλ of the lazy λ-calculus is constructed using a base sort L for λ-terms and an atom sort A. The signature also contains the following function symbols.
( ): A → L: A unary function symbol for creating terms from atoms;
λ( ): [A]L → L: A unary function symbol for abstractions;
: (L × L) → L: A binary function symbol for application.
The semantics includes a reduction transition → , here displayed with no label

to remain in line with the standard notation from [2], transitions →P
for terms P

of sort L, and the rules for term-for-atom substitution transitions as generated in Section 4.1, but where rules (a1Ts) and (a2Ts) are modified to deal with embedding
T
of atoms. For instance, rule (a1Ts) becomes (a) −a→→z z.
The set of rules of the signature Σλ contains the following derivation rules, which define the operational semantics of our version of the lazy λ-calculus, for all atoms a.




λ([a]x) →λ([a]x)
(abs1AP)
T
a'→y
x0 −→ x1	∀b.(b#y)

y
λ([a]x0) →x1

(abs2AP)

x0 →y0	y0 →x1 y1	y1 →y2


(x0 x1) →y2

(app1AP)
(x0 x1) →y1	y1 →x2 y2


(x0 x1) →x2 y2

(app2AP)



7 Theorem 5.3 is stated as Theorem 7 in Section 6 of [8] and proved in Section 22 of that paper.

Moreover, the transition relations → , →P
for any binding-closed term P 8 , and

the term-for-atom substitution transitions are up to α-equivalence. Recall that, by Definition 4.4, this means that the set of rules of Σλ contains also the rules for α-conversion transitions and the rules for atom-for-atom substitution transitions. Rules (a1Ts) and (a2Ts) are modified as before also for atom-for-atom substitution transitions and these transitions are set to be up to α-equivalence.
We denote by Λ the set of λ-terms of [2,4], and by Λ0 the set of those that do not contain free variables. The encoding J·)λ is a map from Λ into terms of our nominal λ-calculus. The mapping is straightforward and not presented here; it can however be found in [8]. 9 The following theorem establishes the operational correctness of our formulation of the lazy λ-calculus with respect to its original formulation for λ-terms in Λ0 10 .
Theorem 5.4 (Operational Correspondence: lazy λ-calculus) For    all
M, N ∈ Λ0, M →N ⇔ JM )λ → JN )λ.
The reader should notice that if we ruled out the premises ∀b.(b#y) from rule (abs2AP) the operational correspondence of Theorem 5.4 would hold for the set of all λ-terms. The reason we restrict the parameter passing to binding-closed terms only is that it ties up directly with the study that follows.
In the context of the lazy λ-calculus, one of the most interesting notions of bisimilarity is the applicative bisimilarity due to Samson Abramsky [2]. Below we recall the definition of this equivalence.
Definition 5.5 (Applicative bisimilarity in the λ-calculus) Applicative bisimilarity is the largest symmetric relation  on Λ0 such that whenever M  N, if M →λa.Mj for some variable a and Mj ∈ Λ, then there exist some variable b and Nj ∈ Λ such that
N →λb.Nj, and
Mj[P/a]  Nj[P/b], for all P ∈ Λ0.
It is important to remark that the applicative bisimilarity of the λ-calculus is defined over closed λ-terms. Indeed, this equivalence is very unsatisfactory over terms that contain free variables. For instance, for all variables a, b and c, it holds that a  b and λa.b  λa.c.
The following theorem states that applicative bisimilarity in the lazy λ-calculus coincides with nominal bisimilarity in the nominal formulation of the lazy λ-calculus given above 11 .
Theorem 5.6 (Applicative and Nominal Bisimilarity coincide) For   all
M, N ∈ Λ0, M  N if, and only if, JM )λ ↔–– JN )λ.

8 The premises 6b.(b#y) of rule (abs2AP) ensure that the parameter passing is performed with binding- closed terms only. This characterization already appeared in [9, Section 9.2].
9 The encoding can be found in Section 5.1 of [8]. By way of example the reader can consider that
Jλx.λy.(x y))λ = λ([x](λ([y](x y)))).
10 Theorem 5.4 is stated and proved as Theorem 18 in Section 25 of [8].
11 Theorem 5.6 is stated as Theorem 13 in Section 7.1 of [8] and proved in Section 25 of that paper.

Related Work
We are aware of a number of existing approaches that accommodate names and binders inside the SOS framework. The frameworks that are most relevant to the work presented in this paper are by Miller and Tiu in [16] (FOλΔ∇), by Lakin and Pitts in [15] (MLSOS) and in [14] (αML) and by Gacek, Miller and Nadathur in
[12] (Abella).
As a first difference, Nominal SOS is the only approach that directly extends the formal framework of SOS. We identify some benefits supporting this choice. First, users that are familiar with the SOS framework will find Nominal SOS easy to use. Secondly, although a meta-theory of SOS for calculi with binders can be carried out with the frameworks mentioned above, Nominal SOS seems to be close enough to ordinary SOS. In this respect, a meta-theory for binders can follow by and large the same lines of the meta-theory of ordinary SOS, which has been successfully developed for over 20 years, see [21]. We also expect that already existing results from the meta-theory of SOS would lift to Nominal SOS with relatively little effort. Some technical differences between Nominal SOS and the systems mentioned above are worth a mention. For instance in MLSOS and α-ML, only restricted op- erations are allowed on atoms and programs do not depend upon concrete atoms. 12 In Nominal SOS, languages can instead be defined in a way that a particular atom may affect the computation. FOλΔ∇ and Abella are based on the so-called λ-tree approach to syntax where a logic that has its roots in the λ-calculus takes care of the binding management. In Nominal SOS, the management of binders is not delegated to an underlying layer and users need to specify the treatment of binders completely. As another difference, in the mentioned approaches α-conversion is built-in and guaranteed on the meta-level. In Nominal SOS α-conversion is not built-in but it can be automatically generated from the signature. The user can replace it and experiment with alternative notions at will. Moreover, we prefer to model α-equivalence as a transition like any other, so that it can be the subject of
meta-theorems based on the shape of rules that may be developed in the future.
We refer the reader to Section 5.8 of [7], where related works are considered in much more detail.
Conclusions and Future Work
In this paper, we have introduced a framework, called Nominal SOS, for mod- elling the operational semantics of nominal calculi. The framework comes equipped with the basic features used in defining such calculi, namely, substitution and α- conversion.  We used the framework to specify the semantics of the early π-calculus and lazy λ-calculus and showed that our formulations of the semantics coincide with the original ones. A notion of nominal bisimilarity arises naturally from our frame- work. Moreover, we showed that the notion of nominal bisimilarity in our semantics of the early π-calculus coincides with open bisimilarity in the original semantics.

12 This property is known in the nominal world as the equivariance property, see [11] and especially [23].

We also proved that nominal bisimilarity coincides with Abramsky’s applicative bisimilarity in the context of the lazy λ-calculus.
The main goals of our future work are to provide further evidence that Nominal SOS is expressive enough to capture the original semantics of nominal calculi, such as variants of the π-calculus and its higher-order version [27], the psi-calculi [5] and the object calculi [1]. Also, we plan to address different notions of equivalence betweens terms. To begin with, we plan to adapt nominal bisimilarity in order for it to coincide with open bisimilarity with distinctions [29,28], when applied to π- calculus terms. Our main goal is however to develop the meta-theory of Nominal SOS. By way of example, it would be worth providing congruence formats for behavioural semantics, possibly generalizing those proposed in [32] and [10], for instance.

References
Mart´ın Abadi and Luca Cardelli. A Theory of Objects. Monographs in Computer Science. Springer- Verlag, New York, 1996.
Samson Abramsky. The lazy lambda calculus. In D.A. Turner, editor, Research Topics in Functional Programming, pages 65–116. Addison Wesley, Reading, Mass., 1990.
Luca Aceto, Wan Fokkink, and Chris Verhoef. Structural operational semantics. In Handbook of Process Algebra, pages 197–292. Elsevier, 1999.
Henk P. Barendregt. The Lambda Calculus: Its Syntax and Semantics, Revised edition. North Holland, 1984.
Jesper Bengtson, Magnus Johansson, Joachim Parrow, and Bjo¨rn Victor. Psi-calculi: Mobile processes, nominal data, and logic. In Proceedings of the 24th Annual IEEE Symposium on Logic In Computer Science, pages 39–48, Washington, DC, USA, 2009. IEEE Computer Society.
Christiano de O. Braga, Edward H. Haeusler, Jos´e Meseguer, and Peter D. Mosses. Mapping modular sos to rewriting logic. In Proceedings of the 12th international conference on Logic based program synthesis and transformation, LOPSTR’02, pages 262–277, Berlin, Heidelberg, 2003. Springer-Verlag.
Matteo Cimini. Contributions to the Meta-Theory of Structural Operational Semantics. Ph.D. in Computer science, School of Computer Science, Reykjavik University, 2012. available at http://cimini.info.
Matteo Cimini, Mohammadreza Mousavi, Michel A. Reniers, and Murdoch J. Gabbay. Nominal SOS
- Online Resource. available at: http://cimini.info/publications/publications.html.
Maribel Fernandez and Murdoch J. Gabbay. Nominal rewriting. Information and Computation, 205(6):917–965, 2007.
Marcelo Fiore and Sam Staton. A congruence rule format for name-passing process calculi from mathematical structural operational semantics. In Proceedings of the 21st Annual IEEE Symposium on Logic in Computer Science, pages 49–58, Washington, DC, USA, 2006. IEEE Computer Society.
Murdoch J. Gabbay and Andrew M. Pitts. A new approach to abstract syntax involving binders. In 14th Annual Symposium on Logic in Computer Science, pages 214–224. IEEE Computer Society Press, Washington, 1999.
Andrew Gacek, Dale Miller, and Gopalan Nadathur. Reasoning in Abella about structural operational semantics specifications. In A. Abel and C. Urban, editors, International Workshop on Logical Frameworks and Meta-Languages: Theory and Practice (LFMTP 2008), number 228 in Electronic Notes in Theoretical Computer Science, pages 85–100, 2008.
Pieter H. Hartel. Letos - a lightweight execution tool for operational semantics. Software - Practice and Experience, 29:1379–1416, December 1999.
Matthew R. Lakin. An executable meta-language for inductive definitions with binders. PhD thesis, University of Cambridge, 2010.
Matthew R. Lakin and Andrew M. Pitts. A metalanguage for structural operational semantics. In
Symposium on Trends in Functional Programming, pages 1–16, 2007.


Dale Miller and Alwen Tiu. A proof theory for generic judgments. ACM Transactions on Computational Logic, 6:749–783, October 2005.
Robin Milner. Communication and Concurrency. Prentice-Hall, Inc., Upper Saddle River, NJ, USA, 1989.
Robin Milner, Joachim Parrow, and David Walker. A calculus of mobile processes, part i. Information and Computation, 100, 1989.
Robin Milner, Joachim Parrow, and David Walker. A calculus of mobile processes, ii. Information and Computation, 100:41–77, September 1992.
Mohammad Reza Mousavi and Michel A. Reniers. Prototyping sos meta-theory in maude. Electronic Notes in Theoretical Computer Science, 156:135–150, May 2006.
Mohammad Reza Mousavi, Michel A. Reniers, and Jan F. Groote. Sos formats and meta-theory: 20 years after. Theoretical Computer Science, 373(3):238–272, 2007.
David Park. Concurrency and automata on infinite sequences. In Proceedings of the 5th GI-Conference on Theoretical Computer Science, volume 104 of Lecture Notes in Computer Science, pages 167–183, London, UK, 1981. Springer-Verlag.
Andrew M. Pitts. Nominal logic, a first order theory of names and binding. Information and Computation, 186:2003, 2002.
Gordon D. Plotkin. A Structural Approach to Operational Semantics. Technical Report DAIMI FN-19, University of Aarhus, 1981.
Gordon D. Plotkin. A structural approach to operational semantics. Journal of Logic and Algebraic Programming, 60-61:17–139, 2004.
Davide Sangiorgi. Bisimulation for higher-order process calculi. Information and Computation, 131(2):141–178, 1996.
Davide Sangiorgi. pi-calculus, internal mobility, and agent-passing calculi. In Selected papers from the 6th international joint conference on Theory and practice of software development, TAPSOFT ’95, pages 235–274, Amsterdam, The Netherlands, The Netherlands, 1996. Elsevier Science Publishers B. V.
Davide Sangiorgi. A theory of bisimulation for the π-calculus. Acta Informatica, 33(1):69–97, 1996.
Davide Sangiorgi and David Walker. The π-calculus: a Theory of Mobile Processes. Cambridge Univ. Press, 2001.
Bent Thomsen. A theory of higher order communicating systems. Information and Computation, 116(1):38–57, 1995.
Christian Urban, Andrew M. Pitts, and Murdoch J. Gabbay. Nominal unification. Theoretical Computer Science, 323:473–497, 2004.
Axelle Ziegler, Dale Miller, and Dale Palamidessi. A congruence format for name-passing calculi. In Proceedings of the 2nd Workshop on Structural Operational Semantics (SOS’05), volume 156 of Electronic Notes in Theoretical Computer Science, pages 169–189, Lisbon, Portugal, 2005. Elsevier Science B.V.
