	Electronic Notes in Theoretical Computer Science 212 (2008) 269–284	
www.elsevier.com/locate/entcs

Tree Process Calculus
Mingren Chai	Nan Qu	Ying Jiang1 ,2
State Key Laboratory of Computer Science Institute of Software, Chinese Academy of Sciences Beijing 100190, P.R.China

Abstract
We extend Robin Milner’s sequential process calculus to tree process calculus in a way similar to that tree automata extend word automata. By this way, we establish a sound and complete inference system which describes the equivalence via bisimulation over tree processes. As a corollary, we obtain a new equivalence relation between tree automata, which is strictly finer than the classical equivalence over tree automata, and is strictly coarser than the equivalence relation via bisimulation defined in [1].
Keywords: Tree process calculus, sequential process calculus, tree automata, bisimulation.


Introduction
Classical (word) automata theory was introduced for analyzing relations between automata from the view of language equivalence [6]. Since then it has been devel- oped in several directions, one of which is Robin Milner’s nondeterministic sequential process calculus (NSPC for short) [7], invented for analyzing properties of sequential processes by observing the behavior of processes. In the last two decades, a series of correlated theories were developed rapidly, noticeably, CCS [9], π-calculus [10].
Sequential process calculus deals with relations between automata from the view of behavior. It considers the matters as when two different automata may be re- garded as having the same behavior, and how automata can be classified in terms of this behavior [7]. Also an operational semantic known as labelled transition sys- tem (LTS) was offered for sequential process calculus. A LTS can be thought of as an automaton without a start state or accepting states [10]. On the other hand, tree automata [2,4] can be considered as a kind of extension of (word) automata, which provides among others a mathematical model for reactive system as operating

1 Corresponding author
2 Email: {chaimr, qunan, jy}@ios.ac.cn

1571-0661 © 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.04.067

systems or banking systems and get successful applications in concurrent program verification, automated theorem proving and XML schema languages.
The goal of this paper is to extend NSPC to tree process calculus (see Section 3 for the formal definition) in a way similar to that tree automata extend word au- tomata in order to analyze properties of tree processes and the relationship between tree process calculus and tree automata. First, we establish an inference system. Secondly we provide the calculus an operational semantic called tree labelled tran- sition system (TLTS), and define a notion of bisimulation between tree processes and the equivalence relation derived from it. Finally we prove the soundness and completeness of the calculus with respect to the equivalence via bisimulation. As a corollary, we obtain a new equivalence relation over tree automata, which is strictly finer than the equivalence via language equality of tree automata, and is strictly coarser than the equivalence via bisimulation defined by Parosh Aziz Abdulla et al. in [1]. This equivalence relation may give smaller automata during minimiza- tion. However, it is not considered how costly checking the new equivalence will be compared to [1].
The rest of the paper is structured along the line of background knowledge, tree process calculus, bisimulation, the theory of bisimulation, application and conclu- sion. Because of size limit, the details of some proofs are omitted.

Preliminaries
Leaving the rudimentary sequential process calculus and tree automata to [2,4,7,8,9,10], we begin with a description of labelled transition system. Let A be a set of actions, sometimes called an alphabet. A labelled transition system (LTS) over A is a triple (Q, A, Δ) consisting of (1) a set Q of states; (2) a set A of actions;
(3) a ternary relation Δ ⊆ Q ×F × Q, known as a transition relation. We denote
(q, α, q') ∈ Δ by q →α q' and call q the source and q' the target of the transition. In
α1	α2	αn
general, qn is said to be a derivative of q under α1α2 ··· αn if q → q1 → q2 ··· → qn.
Let A be a set of of atomic actions, V be a denumerable set of variables, X ∈ V and α ∈ A. The set Pseq of sequential process expressions is the smallest class defined inductively as follows:

Pseq ::= 0	(inaction)
| α.P	(prefix)
| X	(variables)
| P1 + P2 (summation)
| μX.P	(recursion)
The labelled transition system of sequential processes over A is defined to be the LTS (Pseq, A, Δ) where the transitions are exactly those which can be inferred from the rules below, together with α-conversion:

TRANSITION RULES
α
Prefix α.P −→ P, provided α ∈ A 
P1 −α→ P	P2 −α→ P

Sum1


α
P1 + P2 −→ P
Sum2


α
P1 + P2 −→ P



Rec
P {μX.P/X} −α→ P '

μX.P −α→ P '

Now we switch to the notions concerning tree automata.
Let N be the set of positive integers. A ranked alphabet is a couple (F, Arity) where F is a finite set and Arity is a mapping from F into N . We denote by Arity(f ) the arity of a symbol f ∈ F and Fp the set of symbols of arity p. Symbols of arity 0, 1,... ,p are called constants, unary, ... and p-ary symbols, respectively. We assume that F contains at least one constant.
The set T (F) of terms over the ranked alphabet F is the smallest set defined
by:
F0 ⊆ T (F);
if p ≥ 1, f ∈ Fp and t1,... , tp ∈ T (F), then f (t1,... , tp) ∈ T (F). A subset of T (F) is called a tree language.
A non-deterministic top-down ﬁnite tree automata (top-down NFTA) over F
is a tuple A = (Q, F, QI , Δ) where Q is a finite set of states, F a set of ranked alphabet, QI (⊆ Q) is a set of initial states, Δ is a finite set of transition rules q → f (q1,... , qn) with f ∈ Fn and q1,... , qn,q ∈ Q for some n ∈ N . Obviously, Δ determines a function Δ∗ : Q → P(T (F)) by (the least fixpoint equation)

Δ∗(q)= {t | t = f (t1,... , tk),q → f (q1,... , qk) ∈ Δ, ti ∈ Δ∗(qi),i ∈ {1,... , k}}

The tree language recognized by A is the set L(A)= {t | t ∈ Δ∗(q),q ∈ QI}.
Notice that the expressive power of top-down NFTA and bottom-up NFTA is the same [2]. More precisely, the class of languages accepted by top-down NFTAs is exactly the class of languages accepted by bottom-up NFTAs. In this paper, we only consider the set of top-down NFTAs.


Tree Process Calculus
This section introduces a process calculus which will be called tree process calculus (TPC for short). The essential difference between TPC and R. Milner’s sequential process calculus is that the actions of sequential process calculus are all unaries while those of tree process calculus have different arities.

Tree Labelled Transition System
A tree labelled transition system is, roughly speaking, a labelled transition system given in Section 2, but the labels have different arities, the source of each transition rule is a state and the target of the transition is a vector of states.
Definition 3.1 [Tree labelled transition system] Let F be a set of ranked symbols as the set of actions. A tree labelled transition system (TLTS) over F is a triple (Q, F, Δ) consisting of: (i) a set Q of states; (ii) a set F of ranked symbols; (iii) a
ternary relation (called a transition relation) Δ ⊆ Q ×F × Q∗, where Q0 = {ε}, ε
denotes the 0-dimension vector, Qn = Q × Q × ··· × Q, for n ≥ 1 and Q∗ =   Qn.

`	˛¸	x
n∈N

Note that (q, f, −→q ) ∈ Δ means q ∈ Q, f ∈ Fi and −→q ∈ Qi, for some i ≥ 0.
Informally, a TLTS can be thought of as a tree automata without initial states or final states. In fact each different selection of a set of initial states defines a different top-down tree automaton, based upon the same TLTS.

Tree Process Expressions and TLTS of Tree Process
This section focus on the syntax of TPC.
Definition 3.2 [Tree process expressions] Let F be a set of ranked symbols as the set of actions. Let V be a set of process variables, and X range over V. The class P of tree process expressions over F is the smallest class inductively defined as follows:
P ::= f.(P1,... , Pn) (prefix) | X (variables) | P1+P2 (summation) | μX.P (recursion) where f ∈ Fn and (P1,... , Pn) is an n-dimension vector of expressions.
The meaning of the combinators is similar to the ones of sequential case, the
one and only difference is that here (P1, P2,... Pn) is not a process expression but a vector consists of process expressions. Recall that ε denotes the vector of 0- dimension.
For legibility, we adopt the convention that the combinators defined above have the following precedence: prefix, recursion and summation.
Example 3.3 a.ε f.(a.ε) g.(b.ε, c.ε + P1) h.(P1, P2, P3, P4) are all tree process expressions, where P1, P2, P3, P4 ∈ P, a, b, c ∈ F0, f ∈ F1, g ∈ F2 and h ∈ F4.
Definition 3.4 [Free variables and guarded variables] X is free in a tree process expression P if P contains an occurrence of X not contained in subexpressions μX.P '. X is guarded in an expression P if every free occurrence of X in P is
−→
contained in a subexpression f.P . When X is not guarded in P , we write P D X.
Example 3.5 X is guarded in f.(X, X), μX.X and Y +Z; but not in X, f.(X, Y )+
X or μY.(Y + X), where f ∈ F2.

In the following, P {P1,... , Pn/X1,... , Xn} will denote the result of simultane- ously substituting Pi for each free occurrence of Xi in P (1 ≤ i ≤ n), renaming bound variables if necessary.
In giving meaning to our basic language, we define
Definition 3.6 [The TLTS of tree process] Let F be a set of ranked symbols. Let P be the class of tree process expressions over F. A TLTS of tree process is the triple (Q, F, Δ), where Q ⊂fin P and the transition relation Δ is exactly those which can be inferred from the rules below, together with α-conversion:
TRANSITION RULES
f
Prefix f.(P1,... , Pn) −→ (P1,... , Pn), provided f ∈ Fn
f  −→	f  −→
Sum1	  P1 −→ P		Sum2	  P2 −→ P	

f  −→
P1 + P2 −→ P
f  −→
P1 + P2 −→ P


f  −→
Rec	P {μX.P/X} −→ P
f  −→
μX.P −→ P

Again, the rules are similar to the ones in the sequential case, the one and only
−→
difference is that here P does not denote a state but a vector consists of states.
The following proposition will be useful later.
f
Proposition 3.7 Let f ∈ Fn (n ≥ 0). If P {Q/X} −→ (P1,... , Pn), then:
f	'	'	'
If X is guarded in P, then P −→ (P1 ,... , Pn) and Pi ≡ Pi {Q/X} (1 ≤ i ≤ n);
f	'	'	'
If X is not guarded in P, then P −→ (P1,... , Pn) and Pi ≡ Pi {Q/X} for any
f
i ∈ {1,... , n}, or Q −→ (P1,... , Pn);
where ≡ denotes the syntax equality.
Proof. Both statements are proved by induction on the depth of the inference to get P {Q/X} −f→ (P ,... ,P ). The detail is argued by cases on the form of P .	 
1	n
Multi-processes and Multi-step Transitions
In the previous section, we defined one-step transition rules from a process to a process vector. In this section, we will present multi-step transitions.
Definition 3.8 [Multi-processes] The class MP of multi-processes is the least class inductively defined as follows:
ε ∈ MP;
if P ∈ P, then P ∈ MP;
if Pˆ1,... , Pˆn ∈ MP and n ≥ 1, then (Pˆ1,... , Pˆn) ∈ MP.

When a multi-process Pˆ is constructed only from ε, we call it an ε-multi-process. The examples of ε-multi-processes are ε, (ε), (ε, (ε, ε), (ε, (ε))).
In Section 2, we introduced the set T (F) of terms over the ranked alphabet
To express multi-step transitions, we introduce moreover a particular set K of constants to indicate the positions in trees (terms) constructed over actions, where substitutions take place. These new constants are denoted by  1, 2,.. .. We consider trees constructed on F ∪ K.
We use →∗ to express multi-step transitions from a process to a multi-process, the transitions are exactly those which can be inferred from the rules below, together with α-conversion:


f
P −→ (P1,... , Pn)	
f ( 1,..., n)
provided f ∈ Fn

P	−→∗	(P1,... , Pn)


t	ˆ	g( i1,..., im)
P −→∗ P {Pi/X}	Pi	−→∗	(Pi1,... , Pim)

t{g( i1,..., im)/ i}
P	−→∗
Pˆ{(Pi1,... , Pim)/X}

provided g ∈ Fm, t ∈ T (F ∪ K),  i occurs in t.
Notice that the assumption of rule (1) is defined in Definition 3.6 and, the basic idea of rule (2) is that i and X have the same position respectively in t and Pˆ.
Let t ∈ T (F ∪ K). We call t a path from P to Pˆ, if P −→t ∗ Pˆ.
Example 3.9 Consider three processes P1 = f.(P2, P3)+ g.(P2), P2 = g.(P3)+ a.ε and P3 = b.ε, where f ∈ F2, g ∈ F1, a, b ∈ F0.  By rules Sum1 and Prefix,

we get P1
f
−→ (P2, P3). By rule (1) above, we get P1
g( 21)
f ( 1, 2)
−→∗	(P2, P3).  By rule
f (g( 21), 2)

(1) again, we have P2
−→∗ (P3). By rule (2), we get P1
−→∗	((P3), P3).

Moreover, P3 = b.ε, then P3
b
−→ ε, and so P3
b
−→∗ ε.  Applying rule (2) on

f (g( 21), 2)
P
b	f (g(b), 2)

1	−→∗	((P3), P3) and P3 −→∗ ε, we get P1	−→∗	((ε), P3). Apply rule (2)
f (g(b),b)
once more, we get P1 −→∗ ((ε), ε). So f (g(b), b) is a path from P1 to ((ε), ε).
Bisimulation
Similar to R. Milner’s approach [9], we set up a notion of equivalence between tree processes by using the notion of bisimulation described as follows.
Definition 4.1 [Bisimulation] A binary relation S ⊆ P × P over tree processes is a
bisimulation if (P, Q) ∈ S implies, for all f ∈ Fn (n ∈ N ) and all X ∈ V,
f	f
Whenever P → (P1,... , Pn), then for some Q1,... , Qn, Q → (Q1,... , Qn) and
(Pi, Qi) ∈ S (i = 1,... , n);
f	f
Whenever Q → (Q1,... , Qn), then for some P1,... , Pn, P → (P1,... , Pn) and

(Pi, Qi) ∈ S (i = 1,... , n).
P D X iff Q D X.
Proposition 4.2 The following relations are bisimulations:
IdP;
S−1, where S−1 = {(y, x) | (x, y) ∈ S}, provided S is a bisimulation;
S1S2, where S1S2 = {(x, z) | for some y, (x, y) ∈ S1 and (y, z) ∈ S2}, provided
S1, S2 are bisimulations;
i∈I Si, where I is a set of indices, provided each Si is a bisimulation.
Proof. By the definition of bisimulation.	 
We are now ready to define the equivalence.
Definition 4.3 P and Q are called bisimilar, written P ∼ Q, if (P, Q) ∈ S for some bisimulation S. This may be equivalently expressed as follow:
∼ =  {S | S is a bisimulation} It follows straightforward from Proposition 4.2 that
Proposition 4.4
∼ is the largest bisimulation.
∼ is an equivalence relation.
Proof. It follows straightforward from Proposition 4.2.	 
Now let us prove the main result of this section.
Proposition 4.5 P ∼ Q if and only if, for every f ∈ Fn (n ∈ N ) and every
X ∈ V,

Whenever P
f	f
→ (P1,... , Pn), then for some Q1,... , Qn, we have Q →

(Q1,... , Qn) and Pi ∼ Qi (i = 1,... , n);
f	f
Whenever Q  →  (Q1,... , Qn), then for some P1,... , Pn, we have P  →
(P1,... , Pn) and Pi ∼ Qi (i = 1,... , n);
P D X iff Q D X.
To show this proposition, we define a new relation ∼' in terms of ∼ as follows:
Definition 4.6 P ∼' Q if and only if, for every f ∈ Fn (n ∈ N ) and every X ∈ V,

Whenever P
f	f
→ (P1,... , Pn), then for some Q1,... , Qn, we have Q →

(Q1,... , Qn) and Pi ∼ Qi (i = 1,... , n);
f	f
Whenever Q  →  (Q1,... , Qn), then for some P1,... , Pn, we have P  →
(P1,... , Pn) and Pi ∼ Qi (i = 1,... , n);
P D X iff Q D X.

Proposition 4.4(1) ensures that ∼ is a bisimulation. By Definitions 4.3 and 4.6, we have
P ∼ Q implies P ∼' Q	(∗)
It remains to show that P ∼' Q implies P ∼ Q, which follows from the lemma below
Lemma 4.7 The relation ∼' is a bisimulation.

The Theory of Bisimulation
First we complete the syntax in Section 3.2 by establishing an inference system. Then we prove the soundness and completeness of the system w.r.t. the equivalent relation ∼.

TPC: An Inference System for Tree Process
TPC is formed by two sets of rules: the basic rules and the rules for recursion.
Basic Rules A
A1 P + Q = Q + P
A2 P + (Q + R)= (P + Q)+ R A3 P + P = P
A4 if P = P ' and Q = Q', then Q{P/X} = Q'{P '/X}
Rules for Recursion R
R1 μX.P = P {μX.P/X}
R2 If Q = P {Q/X} then Q = μX.P , provided that X is guarded in P
R3 μX.(P + X)= μX.P
R4 If P = Q then μX.P = μX.Q
−→
Notice that we need no explicit rules for prefix f. P . In particular, the distribu-
−→	−→	−→	−→
tive law f.( P + Q )= f. P + f. Q is not valid.
Notations. We write ▶ P = Q, if P = Q can be deduced by the rules of A and R; and write A ▶ P = Q, if P = Q can be deduced by the rules of A.

Soundness and Completeness
The main result of the section is that the ”truth” and ”derivability” coincide. To be precise, for any tree processes P, Q, we have ▶ P = Q if and only if P ∼ Q.
Notation. Let S be a binary relation. PSQ denotes (P, Q) ∈ S; and P ∼ S ∼ Q
denotes that, for some P ' and Q', we have P ∼ P ', P 'SQ' and Q' ∼ Q, where
S ∼ denotes the composition of binary relations under consideration.

Definition 5.1 [Bisimulation up to ∼] Let S be a binary relation. S is said to be a bisimulation up to ∼ if PSQ implies that, for every f ∈ Fn (n ∈ N ) and every X ∈ V,

Whenever P
f
→ (P1,... , Pn), then for some Q1,... , Qn, one has Q →

(Q1,... , Qn) and Pi ∼ S ∼ Qi, for any i ∈ {1,... , n};
f	f
Whenever Q  →  (Q1,... , Qn), then for some P1,... , Pn, one has P  →
(P1,... , Pn) and Pi ∼ S ∼ Qi , for any i ∈ {1,... , n};
P D X iff Q D X.
This notion is used to show that two processes are bisimilar. More precisely, to prove P ∼ Q, it suffices to find a bisimulation up to ∼ which contains (P, Q). This result stats in Proposition 5.3, which is in turn a short step from the following lemma.
Lemma 5.2 If S is a bisimulation up to ∼, then ∼ S ∼ is a bisimulation. Proof. By the definition of bisimulation and that of bisimulation up to ∼.	 Proposition 5.3 If S is a bisimulation up to ∼ then S ⊆ ∼.
Proof. By Lemma 5.2, ∼ S ∼ is a bisimulation. Then it follows from the definition of ∼ that ∼ S ∼ ⊆ ∼. On the other hand, IdP ⊆ ∼, so S ⊆ ∼ S ∼, and we are done.	 
Proposition 5.3 and Lemma 5.4 below are useful in the proof of Propositions 5.5 and 5.6, which in turn server to show the soundness of the system.
Lemma 5.4 If P ∼ Q and X is free in P and Q, then P {H/X} ∼ Q{H/X}.
Proof. Notice first that P ∼ Q ensures either X is guarded in both P and Q or in none of them. Now let S = {(P {H/X}, Q{H/X}) | P ∼ Q}. It suffices to show that S is a bisimulation, which is proved inductively by using the definition of bisimulation and Proposition 3.7.	 
Proposition 5.5 If P ∼ Q and Pi ∼ Qi (i = 1,... , n), then the followings hold:
f.(P1,... , Pn) ∼ f.(Q1,... .Qn), for any f ∈ Fn (n ∈ N );
P1 + ··· + Pn ∼ Q1 + ··· + Qn;
μX.P ∼ μX.Q.
Proof. 1.  For any fixed i  ∈  {1,... , n}, since Pi  ∼  Qi, there exists
 n
some bisimulation Si, such that PiSiQi.	It is easy to show that	Si ∪
i=1
{(f.(P1,... , Pn), f.(Q1,... .Qn))} is still a bisimulation, and hence f.(P1,... , Pn) ∼
f.(Q1,.	Qn).
A similar proof as in Case 1 shows the desired result.
Let S = {(H{μX.P/X},H{μX.Q/X}) | H ∈ P}. When H ≡ X, we obtain (μX.P, μX.Q) ∈ S. So it suffices to show that S is a bisimulation. By Proposition

, we only need to show that S is a bisimulation up to ∼, that is, we need to show
f
For any f ∈ Fm (m ∈ N ), whenever H{μX.P/X} → (P1,... , Pm), there exist
f
some Q1,... , Qm, such that H{μX.Q/X} → (Q1,... , Qm) and that Pi ∼ S ∼ Qi
for any i ∈ {1,... , m}.
Conversely.
For any Y ∈ V, P D Y iff Q D Y .
We consider only the first case. the result is proved by induction on the depth of
f
the inference to get H{μX.P/X} → (P1,... , Pm). The details are argued by cases
on the form of H.	 
Proposition 5.6
μX.P ∼ P {μX.P/X}.
If Q ∼ P {Q/X}, then Q ∼ μX.P, provided that X is guarded in P.
μX.(P + X) ∼ μX.P.
Proof. 1. By definition of ∼, we need to consider the cases below:
f  −→	f  −→
if μX.P → P , then we have P {μX.P/X} → P (only REC refers to μX.P );
f  −→	f  −→
if P {μX.P/X} → P , then by REC we have μX.P → P ;
for any Y ∈ V, μX.P D Y iff P {μX.P/X} D Y . So μX.P ∼ P {μX.P/X}, as desired.
Let S = {(H{Q/X},H{μX.P/X}) | H ∈ P}. We need to show that S a
bisimulation up to ∼. This is done by a similar proof as that for Proposition 5.5(3).
Let S = {(H{μX.(P +X)/X},H{μX.P/X}) | H ∈ P}. We need to show that S is a bisimulation up to ∼. This is done by a similar proof as that for Proposition 5.5(3).	 
Theorem 5.7 (Soundness) If ▶ P = Q, then P ∼ Q.
Proof. It is shown by induction on the depth of the inference. If the last rule used is one of A1 − A3, we apply bisimulation definition. If it is A4, we apply Proposition
5.5. If it is one of R1 − R4, we apply Proposition 5.6 and Proposition 5.5(3).	 
Now let us switch to the proof of completeness. The lemma below will be useful to show the unique solution of equations.
Lemma 5.8 Let P, Q, R ∈ P and X, Y ∈ V. We have
If X is not free in P, then ▶ P {Q/X} = P.
If X and Y are distinct and there is no free occurrences of X in R, then
▶ P {Q/X}{R/Y } = P {Q{R/Y }/X, R/Y }
Proof. By induction on the structure of P .	 

Proposition 5.9 (Unique solution of equations) Let Xi, Yj (1 ≤ i ≤ m, 1 ≤ j ≤ n) be distinct variables, and X˜ = {X1,... , Xm}, Y˜ = {Y1,... , Yn}. Let Qi (i = 1,... , m) are process expressions with free variables in X˜ ∪ Y˜ , in which each Xi

is guarded. Then there exists a set of expressions P˜
= {P1,... , Pm} with free

variables in Y˜ such that ▶ Pi = Qi{P˜/X˜} (i = 1,... , m). Moreover, if there is
P˜' = {P ',... ,P ' } with free variables in Y˜ s.t. ▶ P ' = Qi{P˜'/X˜} (i = 1,... , m),
m	i
then ▶ P ' = Pi(i = 1,... , m).
Proof. It is proved by induction on m and using Lemma 5.8.	 
The next proposition states that every expression provably satisfies a set of equations.
Proposition 5.10 (Equational characterization) For every tree process ex-

pression P with free variables in Y˜
= {Y1,... , Yn}, there exist tree process expres-

sions P1,... , Pp (p ≥ 1) with free variables in Y˜ , satisfying the following equations


▶ P = P1
m(i)

n(i)

▶ Pi =
Σ
j=1
−→
fij. P ij
+ Σ Y
k=1
g(i,k)
(i = 1,... , p)



where m(i), n(i), g(i, k) ∈ N, n(i), g(i, k) ≤ n, fij ∈ F and each expression-vector whose components are in {P1,... , Pp}.
−→
P ij is an

Proof. By induction on the structure of P .	 
Theorem 5.11 (Completeness) If P ∼ P ', then ▶ P = P '.
Proof. Suppose P and P ' have free variables in {Y1,... , Yn}. By Proposition 5.10, there are provable equations ▶ P = P1, ▶ P ' = P ' and


▶ Pi
m(i)
=
j=1
−→
fij. P ij
n(i)
+	Y
k=1

g(i,k)
(i = 1,... , p)

▶ P ' =
m'(i) j=1
' −→'
fij.P ij +
n'(i)
Yg'(i,k) (i = 1,... , p').
k=1

For any fixed i, j, we may suppose without loss of generality that
−→
P ij = (Ph(i,j,1),... , Ph(i,j,l))
−→'	'	'
P ij = (Ph' (i,j,1),... , Ph' (i,j,l'))

where l = Arity(fij), l' = Arity(f ' ) are as defined in Preliminaries.
Let I = {⟨i, i'⟩ | P ∼ P ' }. By ▶ P = P , ▶ P ' = P ' and Theorem 5.7, we have
i	i'	1	1
⟨1, 1⟩ ∈ I. Moreover, for each ⟨i, i'⟩ ∈ I, we have Pi	' and hence

There exists a total surjective relation Jii'  between {1,... , m(i)} and
{1,... , m'(i')}:
Jii' = {⟨j, j'⟩ | fij = f '	and ⟨h(i, j, k), h'(i', j', k')⟩ ∈ I}


where k ∈ {1,... , Arity(fij
)} and k' ∈ {1,... , Arity(f '
)};

n(i)
▶	Yg(i,j) =
j=1
n'(i') j=1

Yg'(i' ,j).

Now let us consider the formal equations, one for each ⟨i, i'⟩ ∈ I:


Xii' =	Σ
⟨j,j'⟩∈J  '
−→
n(i)
−→
fij.Xij +	Y
j=1

g(i,j)

where Xij = (Xh(i,j,1)h'(i' ,j',1),... , Xh(i,j,Arity(fij ))h' (i',j',Arity(fij ))), and the Xii' are not in {Y1,... , Yn}.
First notice that they are provably satisfied when each Xii' is instantiated to Pi.
This is because the typical equation becomes


Pi =	Σ
⟨j,j'⟩∈J  '
−→
fij. P ij
n(i)
+	Y
j=1

g(i,j)

and is provable since its right-hand side differs at most by repeated summands from that of the already proved equation for Pi, the latter depends on the totality of Jii' . Second, the formal equations are provably satisfied when each Xii' is instantiated
to P ' . This follows from the surjectivity of J ' . Finally, notice that each X '
i'	ii	ii
is guarded in the right-hand sides of the formal equations. Therefore it follows
straightforward from Proposition 5.9 that ▶ Pi	' for each ⟨i, i'⟩ ∈ I, and hence
▶ P = P '.	 

Application
In this section, we will provide a method to decide the equivalence via bisimulation over tree processes. As a corollary, we obtain a new equivalence relation between tree automata, which is strictly coarser than the equivalence relation via bisimulation defined in [1], and is strictly finer than the classical equivalence over tree automata, that is the equivalence via language equality of tree automata.

TLTS with Initial States
In Section 3.1 we have mentioned that a TLTS can be thought of as a tree automaton without initial states or final states. Now we study TLTSs with initial states and their languages.
In the following, we denote the tree processes by lowercase p, q,.. ..

Definition 6.1 [TLTS with initial states] Let F be a set of ranked symbols. A TLTS with initial states (TLTSI) over F is a quartuple A = (Q, F, QI , Δ), where (Q, F, Δ) is a TLTS, QI (⊆ Q ⊂fin P) is a set of initial states. The language of a TLTSI A is
t
L(A)= {t | p −→∗ pˆ, p ∈ QI,t ∈ T (F)}
where pˆ is a ϵ-mult-process and −→∗ is a multi-step transition determined by Δ.

TLTSIs vs. Top-down Tree Automata
Given a TLTSI A = (Q, F, QI , Δ), we will build a top-down tree automaton which recognizes L(A). Actually, we define an automata A' = (Q', F, Q' , Δ') by choosing

(1) Q'
= Q; (2) Q' = QI ; (3) q → f (q1,... , qn) ∈ Δ'
f
iff q −→ (q1,... , qn) ∈ Δ

where f ∈ Fn, q, q1,... , qn ∈ Q.
A standard proof by induction on derivation length yields L(A')= L(A). Thus,
L(A) is recognized by the top-down tree automaton A'.
Conversely, suppose L is the tree language recognized by a top-down tree au- tomaton A' = (Q', F, Q' , Δ'), that is, L = L(A').	We define a TLTSI A =
(Q, F, QI , Δ) by
'	'	f	'
(1) Q = Q ; (2) QI = QI ; (3) q −→ (q1,... , qn) ∈ Δ iff q → f (q1,... , qn) ∈ Δ
where f ∈ Fn, q, q1,... , qn ∈ Q.
A standard proof by induction on derivation length yields L(A)= L(A'). Com- bining this with what we have proved above, we get the following theorem:
Theorem 6.2 A tree language is recognized by a top-down tree automata if and only if it is a language of TLTSI.

A Deciding Method
In the previous section, we have shown that for a given top-down tree automaton
A' = (Q', F, Q' , Δ'), there exists a TLTSI A = (Q, F, QI , Δ) such that Q = Q',
QI = Q' and L(A)= L(A'). Such a A will be called the generated TLTSI of A'.
Definition 6.3 Let Ai = (Qi, F, QIi, Δi) (i = 1, 2) be TLTSIs. A1 and A2 are said
.
to be equivalent (written A1 = A2), if the following conditions hold:
for any q1 ∈ QI1, there exists some q2 ∈ QI2 such that q2 ∼ q1,
for any q2 ∈ QI2, there exists some q1 ∈ QI1 such that q1 ∼ q2, where ∼ is the equivalence relation defined in Definition 4.3.
.
Clearly, the relation = defined above is an equivalence relation .
Lemma 6.4 Let A1 = (Q1, F, QI1, Δ1) and A2 = (Q2, F, QI2, Δ2) be TLTSIs. If
.
= A , then L(A )= L(A ).
Based on this Lemma 6.4, we get immediately the following theorem:

Theorem 6.5 Let A' = (Q' , F, Q' , Δ') (i = 1, 2) be two top-down tree automata.
i	i	Ii	i
Let Ai = (Qi, F, QIi, Δi) (i = 1, 2) are their generated TLTSIs respectively. If
.	'	'
A1 = A2, then L(A1)= L(A2).
This theorem provides a method of deciding equivalence on tree automata (in the classical sense) based on bisimulation between processes of tree process calculus. But the example below shows that the converse does not hold.
Example 6.6 Let F  = {f, g, a}, f  ∈ F2, g ∈ F1, a ∈ F0.	Let A' =
(Q' , F, Q' , Δ' ), B' = (Q' , F, Q' , Δ' ) be two tree automata, where
1	I1	1	2	I2	2
Q' = {q, qg, qf }, Q' = {qf }, Q' = {q', q' , q' , q' }, Q'  = {q' },
I1	2	g	f	m	I2	f
' = {q → a, q → g(q), qg → g(q), qf → g(qg), q → f (q, q)},

Δ' = {q' → a, q' → g(q'), q' → g(q'), q' → g(q' ), q' → f (q', q'), q' → g(q'
)}.

g	f	g  .	f	m
Clearly L(A')= L(B'). We show now (A', B') ∈/ =:
Let A = (Q1, F, QI1, Δ1), B = (Q2, F, QI2, Δ2) be the generated TLTSIs of A'
and B', respectively. We have
Q1 = {q, qg, qf }, QI1 = {qf }, Q2 = {q', q' , q' , q' }, QI2 = {q' },

a	g	g
g	f	m	f
g	f

Δ1 = {q → ε, q → q, qg → q, qf → qg, q → (q, q)},

' a	' g	'	'  g	'	'  g	'	' f	'	'
'  g	'

Δ2 = {q
→ ε, q → q , qg → q , qf → qg , q
→ (q ,q ), qf → qm}.

So q = a.ε + g.(q)+ f.(q, q), qg = g.(q), qf = g.(qg) and q' = a.ε + g.(q')+ f.(q', q'),
q' = g.(q'), q' = g.(q' )+ g.(q' ). Obviously, qf  q' , then (A', B') ∈/ =. .
f	g	m	f

Three Equivalences on Tree Automata
In the following, we denote by NTA the set of non-deterministic finite tree au- tomata.
Definition 6.7 Two automata A1 and A2 are said to be equivalent (written as
.
= A  by abuse of language), if their generated TLTSIs are equivalent.
Now there are actually three equivalence relations defined on NTA: one is the bisimulation equivalent introduced by Parosh Aziz Abdulla et al. in [1]; one is given in Definition 6.7; and one is the language equivalent in the sense of automata theory. In this section, we will study the relation between these equivalences.
The definition of bisimulation equivalence [1] determined by a notion of bisimu- lation on bottom-up tree automata. We translate it to the counterpart on top-down tree automata:
Definition 6.8 [Bisimulation	equivalence	on	tree	automata]	Let	A'	=
(Q' , F, Q' , Δ' ) and A' = (Q' , F, Q' , Δ' ) be both top-down tree automata. A
1	I1	1	2	2	I2	2
relation ⊆ Q' × Q' is said to be a bisimulation relation if the following two condi-
1	2

tions hold for all states q ∈ Q'
and q' ∈ Q'
such that q  q'. (1) q ∈ Q'
if and only

if q' ∈ Q' ; (2) the fact that qk → f (q1,... , qi−1, q, qi+1,... , qk−1) ∈ Δ' , where i ≤

k, f ∈ Fk−1, implies that there exists a rule q' → f (q' ,... , q'
, q', q'
,... , q'	) ∈

k	1	i−1
i+1
k−1

Δ' , such that qj  q'
for all j ∈ {1,... , k}, and vice versa.

j

States q and q' as above are said to be bisimular (with respect to  ). We consider
' and A' to be bisimulation equivalent if there is a bisimulation relation such that
every state in Q' is bisimilar to a state in Q' , and vice versa.
Let us display explicitly the three equivalence relations defined on NTA:
≈ = {(A, B) ∈ NTA × NTA | A and B are bisimulation equivalent};
.	.
= = {(A, B) ∈ NTA × NTA | A = B};
∼= = {(A, B) ∈ NTA × NTA | L(A)= L(B)}.
.	∼
By Theorem 6.5 and Example 6.6, we get immediately that = ⊂ =. To study the
.	'
relation between ≈ and =, we introduce a new relation ≈ ⊆ NTA×NTA as follows.
Definition 6.9 Let A', B' be top-down tree automata and their generated TLTSIs be A = (Q1, F, QI1, Δ1) and B = (Q2, F, QI2, Δ2), respectively. A' ≈' B' if the following conditions hold:
for any q1 ∈ QI1, there exists some q2 ∈ QI2 such that q2 ∼ q1;
for any q2 ∈ QI2, there exists some q1 ∈ QI1 such that q1 ∼ q2;
for any q1 ∈ Q1, there exists some q2 ∈ Q2 such that q2 ∼ q1;
for any q2 ∈ Q2, there exists some q1 ∈ Q1 such that q1 ∼ q2.


By Definitions 6.3, 6.7, 6.8 and 6.9, we can prove easily that ≈ ⊆ ≈' and ≈'
.
⊆ =.

.	'	.	'	.	.
So ≈⊆ =. However the example below shows ≈ /= =. So ≈ ⊂ =, and hence ≈ ⊂ =.
Example 6.10 Let F = {f, g, h, a, }, f ∈ F2, g, h ∈ F1 and a ∈ F0. Let A' =
(Q' , F, Q' , Δ' ), B' = (Q' , F, Q' , Δ' ) be two tree automata, where
1	I1	1	2	I2	2
Q' = {q, qg, qf }, Q' = {qf }, Q' = {q', q' , q' , q' }, Q'  = {q' },
I1	2	g	f	m	I2	f
' = {q → a, q → g(q), qg → g(q), qf → g(qg), q → f (q, q)},

Δ' = {q' → a, q' → g(q'), q' → g(q'), q' → g(q' ), q' → f (q', q'), q'
→ h(q')}.

g	f	g	m

Clearly (A', B') ∈/ ≈', because there is no such state qm in Q'
which satisfies qm 

'
m	.
We show now (A , B ) ∈ =. Let A = (Q1, F, QI1, Δ1), B = (Q2, F, QI2, Δ2) be
the generated TLTSIs respectively of A' and B'. Hence
Q1 = {q, qg, qf }, QI1 = {qf }, Q2 = {q', q' , q' , q' }, QI2 = {q' },

a	g	g
g	f	m	f
g	f

Δ1 = {q → ε, q → q, qg → q, qf → qg, q → (q, q)},

' a	' g	'	'  g	'	'  g	'	' f	'	'
'	h	'

Δ2 = {q
→ ε, q → q , qg → q , qf → qg , q
→ (q ,q ), qm → q }.

So q = a.ε + g.(q)+ f.(q, q), qg = g.(q), qf = g.(qg) and q' = a.ε + g.(q')+ f.(q', q'),

q' = g.(q'), q' = g.(q' ), q'	'
'	'	'	.
f

g	f	g
m = h.(q ). Obviously, q
~ qf , then (A ,B ) ∈ =.

We get now the main result of the section.
.	∼
Theorem 6.11 ≈ ⊂ = ⊂ =.

Conclusion
We have provided a generalization of Milner’s NSPC from the context of word au- tomata to that of tree automata. By this way, we established a sound and complete inference system TPC which describes the equivalence via bisimulation of tree pro- cesses. As a by-product, we obtained a new equivalence relation on tree automata, which is strictly finer than the language equivalence, and is strictly coarser than the bisimulation equivalence defined in [1]. This equivalence relation may give smaller automata during minimization. TPC seems providing a new approach for modeling broadcast-based communication, but it needs more exploration through examples, as well as the comparison with broadcast-based calculi like CBS [12,5], MBS [13], HOBS [11] and πb calculus [3]. Another extension of TPC, which is an ongoing work, is to consider communication between tree processes.

Acknowledgement
This work is partially supported by NSFC 60673045, NSFC major research program 60496321 and NSFC 60721061.

References
Abdulla P.-A., L. Kaati, and J, H¨ogberg,Bisimulation Minimization of Tree Automata, CIAA(2006), 171-185.
Comon H., M. Dauchet, R. Gilleron, F. Jacquemard, D. Lugiez, S. Tison, and M. Tommasi, “Tree Automata: Techniques and Applications,” 1997.
Ene C. and T. Muntean, A broadcast-based calculus for communicating systems, IPDPS(2001), 149pp.
G´ecseg F. and M. Steinby, “Tree Automata,” Akad´emiai kiad´o, Budapest , 1984.
Hennnessy M. and J. Rathke, Bisimulations for a calculus of broadcasting systems , TCS 200(1- 2)(1998), 225-260.
Hopcroft J.-E., R. Motwani, and J.-D. Ullman, “Introduction to Automata Theory, Languages, and Computation,” Addison-Wesley, New York, 2nd Edition, 2001.
Milner R., A Complete Inference System for a Class of Regular Behaviours, JCSS 28(3)(1984), 439- 466.
Milner R., A Complete Axiomatisation for Observational Congruence of Finite-State Behaviours, I&C
81(2)(1989), 227-247.
Milner R., “Communication and Concurrency,” Prentice-Hall, 1989.
Milner R., “Communicating and Mobile Systems: the π-Calculus,” Cambridge University Press, 1999.
Ostrovsky K. , K.V.S. Prasad, and W. Taha, Towards a primitive higher order calculus of broadcasting systems, PPDP(2002), 2-13.
Prasad K.V.S., A calculus of broadcasting systems, SCP 25(2)(1995), 285-327.
Prasad K.V.S., A prospectus for mobile broadcasting systems, ENTCS 162 (2006), 295-300.
