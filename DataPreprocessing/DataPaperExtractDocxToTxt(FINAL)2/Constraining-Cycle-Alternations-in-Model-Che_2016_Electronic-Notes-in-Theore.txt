Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 322 (2016) 211–226
www.elsevier.com/locate/entcs

Constraining Cycle Alternations in Model Checking for Interval Temporal Logic
Alberto Molinaria,1 Angelo Montanaria,2 Adriano Peronb,3
a Department of Mathematics and Computer Science, University of Udine
b Department of Electrical Engineering and Information Technology, University of Napoli Federico II

Abstract
Model checking is one of the most successful techniques in system verification. While a variety of methods and tools exist to check properties expressed in point-based temporal logics, like LTL and CTL, model checking for interval temporal logic has entered the research agenda only very recently. In previous work, we devised a non-elementary model checking procedure for Halpern and Shoham’s modal logic of time intervals, interpreted over finite Kripke structures, and an EXPSPACE algorithm for two meaningful fragments of it. In this paper, we show that the latter algorithm can be suitably tailored in order to check a subset of the computations of a system, that satisfy a given bound on the number of cycle alternations, by making use of a polynomial (instead of exponential) working space. We also prove that such a revised algorithm turns out to be complete for Kripke structures whose strongly connected components are simple cycles.
Keywords: Interval Temporal Logic, Model Checking, Computational Complexity


Introduction
Model checking is one of the most effective techniques in system verification, that allows one to verify a formal specification of the desired properties of a system against a model of its behavior. It has been widely and systematically investigated in the context of classical, point-based temporal logics, whereas it is still almost unexplored in the interval logic setting. In [4,12], the authors propose interval tem- poral logic (ITL) as a natural and expressive formalism for temporal representation and reasoning. On the one hand, thanks to its high expressiveness (compared to that of standard point-based logic), ITL is well suited for a number of computer science applications, ranging from computational linguistics to formal verification,

1 Email: molinari.alberto@gmail.com
2 Email: angelo.montanari@uniud.it
3 Email: adrperon@unina.it

http://dx.doi.org/10.1016/j.entcs.2016.03.015
1571-0661/© 2016 The Authors. Published by Elsevier B.V.
This is an open access article under the CC BY-NC-ND license (http://creativecommons.org/licenses/by-nc-nd/4.0/).

from constraint reasoning to planning [10,11]. On the other hand, undecidability of the satisfiability problem for ITLs is the rule and decidability the exception.
Halpern and Shoham’s modal logic of time intervals (HS, for short) is probably the most famous logic among ITLs [4]. It features one modality for each of the 13 possible ordering relations between pairs of intervals (the so-called Allen’s rela- tions [1]), apart from the equality relation. The satisfiability problem for HS, inter- preted over all relevant (classes of) linear orders, is highly undecidable. Moreover, undecidability rules also over HS fragments; luckily, meaningful exceptions exist, including the interval logic of temporal neighbourhood and the temporal logic of sub-intervals [3].
In this paper, we focus our attention on the model checking problem for HS and its fragments [5,6,7,8,9], for which little work has been done, if compared to LTL or CTL model checking. In the classical formulation of model checking, systems are modelled as (finite) labelled state-transition graphs (Kripke structures), and point-based temporal logics are used to analyse, for each path in the graph, how proposition letters labelling the states change from one state to the next one along the path. In HS model checking, to verify interval properties of computations, we interpret each finite path of a Kripke structure (track) as an interval, whose labeling is defined on the basis of that of the states composing it.
In [5,6], Lomuscio and Michaliszyn address the model checking problem for some HS fragments, extended with epistemic operators. In [5], they focus their attention on the fragment HS[B, E, D] of Allen’s relations started-by, ﬁnished-by, and con- tains extended with epistemic modalities. They consider a restricted form of model checking, that verifies a specification against a single (finite) initial computation, and prove that it is a PSPACE-complete problem. In addition, they show that the problem for the purely temporal fragment of the logic is in PTIME. In [6], they prove that the model checking problem for the fragment HS[A, B, L] of Allen’s re- lations meets, starts, and before, extended with epistemic modalities, is decidable in non-elementary time. The radically different complexity of the two fragments is not surprising, as the latter allows one to access infinitely many intervals.
In [7,9], Montanari et al. characterize the model checking problem for full HS, interpreted over finite Kripke structures. As in [5,6], formulas of HS are evaluated over finite paths/tracks obtained from the unravelling of a finite Kripke structure. However, in [7,9] a proposition letter holds over an interval (track) if and only if it holds over all its states (homogeneity principle), while in [5,6] truth of proposition letters is defined over pairs of states (the endpoints of tracks/intervals). This makes it difficult to compare the two research contributions. In [9], the authors introduce the basic elements of the picture, namely, the interpretation of HS formulas over (ab- stract) interval models, the mapping of finite Kripke structures into (abstract) inter- val models, the notion of track descriptor, and a small model theorem proving (with a non-elementary procedure) the decidability of the model checking problem for full HS against finite Kripke structures. In [7], Molinari et al. work out such a proposal in all its technical details, and they prove that the problem is EXPSPACE-hard. In [8], we consider two large HS fragments, namely, HS[A, A, B, B, E] of Allen’s


	 
relations meets, met-by, started-by, starts, and ﬁnishes, and HS[A, A, E, B, E] of Allen’s relations meets, met-by, ﬁnished-by, starts, and ﬁnishes, and we prove that the model checking problem for them is in EXPSPACE. Moreover, we show that it is NEXP-hard, provided that a succinct encoding of formulas is used (otherwise, we can only give an NP-hardness result).
In this paper, we show how to suitably tailor the algorithm given in [8] to check a meaningful subset of the computations of a system by using polynomial (instead of exponential) working space. The rationale is closed to that of bounded model checking (BMC) [2]. In BMC, one searches for a counterexample to a relevant property in computations whose length is bounded by a given integer k. Either a bug is found, and the procedure ends, or one can increase k and repeat. BMC is in general incomplete (if the bound is not high enough), and thus it can only be exploited for falsiﬁcation, that is, to find counterexamples, rather than to check the validity of a formula. Unlike BMC, our approach does not set a constraint on the maximum length of the considered computations. What is bounded is the alternation of different cycles of a Kripke structure in tracks: the proposed algorithm tries to falsify HS formulas by restricting its attention to a subset of (representatives of) possible system computations (tracks), which do not alternate too many times among different cycles of the considered Kripke structure. As a byproduct, we show that the algorithm is complete for Kripke structures whose strongly connected components are simple cycles.
The paper is organized as follows. In Section 2 we provide some background knowledge. In Section 3 we introduce the notion of descriptor sequence for a track of a finite Kripke structure, and we exploit it to define an indistinguishability (equiv- alence) relation over tracks. In Section 4, following [8], we show how it is possible to select a track representative of bounded length from each equivalence class, and we outline a model checking procedure for HS[A, A, B, B, E]. In Section 5, we de- scribe the aforementioned PSPACE algorithm that constrains the number of cycle alternations. Conclusions provide a short assessment of the work done.
Background Knowledge
The interval temporal logic HS
An interval algebra to reason about intervals and their relative order was first pro- posed by Allen [1]; then, a systematic logical study of ITLs was done by Halpern and Shoham, who introduced the logic HS featuring one modality for each Allen’s interval relation [4], except for equality. Table 1 depicts 6 of the 13 Allen’s relations together with the corresponding HS (existential) modalities. The remaining 7 are equality and the inverse relations (given a binary relation R , the inverse relation R is such that bR a if and only if aR b).
The language of HS features a set of proposition letters AP , the Boolean con- nectives ¬ and ∧, and a temporal modality for each of the (non trivial) Allen’s relations, namely, ⟨A⟩, ⟨L⟩, ⟨B⟩, ⟨E⟩, ⟨D⟩, ⟨O⟩, ⟨A⟩, ⟨L⟩, ⟨B⟩, ⟨E⟩, ⟨D⟩ and ⟨O⟩. HS formulas are defined as follows: ψ ::= p | ¬ψ | ψ ∧ ψ | ⟨X⟩ψ | ⟨X⟩ψ, with

p ∈ AP and X ∈ {A, L, B, E, D, O}. We will use the standard abbreviations of propositional logic. Moreover, for all X, dual universal modalities [X]ψ and [X]ψ are respectively defined as ¬⟨X⟩¬ψ and ¬⟨X⟩¬ψ. We will assume the strict se- mantics of HS: only intervals made of at least two points are allowed 4 . All HS modalities can be expressed in terms of modalities ⟨A⟩, ⟨B⟩, and ⟨E⟩, and the trans- posed modalities ⟨A⟩, ⟨B⟩, and ⟨E⟩, as follows: ⟨L⟩ ψ ≡ ⟨A⟩ ⟨A⟩ ψ, ⟨L⟩ ψ ≡ ⟨A⟩ ⟨A⟩ ψ,
⟨D⟩ ψ ≡ ⟨B⟩ ⟨E⟩ ψ, ⟨O⟩ ψ ≡ ⟨E⟩ ⟨B⟩ ψ, ⟨D⟩ ψ ≡ ⟨B⟩ ⟨E⟩ ψ, and ⟨O⟩ ψ ≡ ⟨B⟩ ⟨E⟩ ψ. Given any subset of Allen’s relations {X1, ··· , Xn}, we denote by HS[X1, ··· , Xn] the fragment of HS that features modalities X1, ··· , Xn only.
HS can be viewed as a multi-modal logic with the 6 primitive modalities
⟨A⟩, ⟨B⟩, ⟨E⟩, ⟨A⟩, ⟨B⟩, and ⟨E⟩ and its semantics can be defined over a multi-modal Kripke structure, here called abstract interval model, in which (strict) intervals are treated as atomic objects and Allen’s relations as simple binary relations between pairs of them.
Definition 2.1 [7] An abstract interval model is a tuple A = (AP , I, AI, BI, EI, σ), where AP is a finite set of proposition letters, I is a possibly infinite set of atomic objects (worlds), AI, BI, EI are three binary relations over I, and σ : I '→ 2AP is a (total) labeling function, which assigns a set of proposition letters to each world.
In the interval setting, I is a set of intervals, AI, BI, and EI are interpreted as Allen’s interval relations A (meets), B (started-by ), and E (ﬁnished-by ), resp., and σ assigns to each interval the set of proposition letters that hold over it.
Given an abstract interval model A = (AP , I, AI, BI, EI, σ) and an interval I ∈ I, the truth of an HS formula over I is defined by structural induction on the formula:
A,I |= p iff p ∈ σ(I), for any proposition letter p ∈ AP ;
A,I |= ¬ψ iff A,I |= ψ;
A,I |= ψ ∧ φ iff A,I |= ψ and A,I |= φ;
A,I |= ⟨X⟩ψ, for X ∈ {A, B, E}, iff there is J ∈ I such that I XI J and A,J |= ψ;
A,I |= ⟨X⟩ψ, for X ∈ {A, B, E}, iff there is J ∈ I such that J XI I and A,J |= ψ.

Kripke structures and abstract interval models
In this section, we define a mapping from Kripke structures to abstract interval models that allows one to specify system properties by means of HS formulas.

4 Strict semantics can be easily “relaxed” to include point intervals, and all results we are going to prove hold for non-strict semantics as well.
Table 1
Allen’s interval relations and corresponding HS modalities.

Allen’s relation	HS	Definition w.r.t. interval structures	Example


Definition 2.2 A finite Kripke structure K is a tuple (AP , W, δ, μ, w0), where AP is a set of proposition letters, W is a finite set of states, δ ⊆ W × W is a left-total relation between pairs of states, μ : W '→ 2AP is a total labelling function, and w0 ∈ W is the initial state.
For all w ∈ W , μ(w) is the set of proposition letters that hold at that state, while δ is the transition relation that constrains the evolution of the system over time.
Definition 2.3 A track ρ of a finite Kripke structure K =(AP , W, δ, μ, w0) isa ﬁnite sequence of states v0 ··· vn, with n ≥ 1, such that (vi, vi+1) ∈ δ for all 0 ≤ i < n.
Let TrkK be the (infinite) set of all tracks over a finite Kripke structure K . For any track ρ = v0 ··· vn ∈ TrkK , we define: |ρ| = n + 1, ρ(i) = vi, states(ρ) =
{v0, ··· , vn} ⊆ W , intstates(ρ)= {v1, ··· , vn—1} ⊆ W , fst(ρ)= v0 and lst(ρ)= vn. Moreover, ρ(i, j) = vi ··· vj is a subtrack of ρ, for 0 ≤ i < j < |ρ|, and Pref(ρ) = 
{ρ(0, i) | 1 ≤ i ≤ |ρ|− 2} (resp., Suff(ρ)= {ρ(i, |ρ|− 1) | 1 ≤ i ≤ |ρ|− 2}) is the set of all proper prefixes (resp., suffixes) of ρ. Notice that the length of tracks, prefixes, and suffixes is greater than 1, as they will be mapped into strict intervals. We say that ρ is an initial track if fst(ρ)= w0, Finally, we denote by ρ· ρj the concatenation of the tracks ρ and ρj, and by ρn the track obtained by concatenating n copies of ρ.
An abstract interval model can be associated with a finite Kripke structure by interpreting every track as an interval bounded by its first and last states.
Definition 2.4 [7] The abstract interval model induced by K = (AP , W, δ, μ, w0) is AK = (AP , I, AI, BI, EI, σ), where I = TrkK , AI = {(ρ, ρj) ∈ I × I | lst(ρ)= fst(ρj)}, BI = {(ρ, ρj) ∈ I × I | ρj ∈ Pref(ρ)}, EI  = {(ρ, ρj) ∈ I × I | ρj ∈ Suff(ρ)}, and
σ : I '→ 2AP is such that σ(ρ)= Tw∈states(ρ) μ(w) for all ρ ∈ I.
In Definition 2.4, relations AI, BI, and EI are interpreted as Allen’s relations A, B, and E, respectively. Moreover, according to the definition of σ, a proposition letter p ∈ AP holds over ρ = v0 ··· vn iff it holds over all the states v0,..., vn of ρ. This conforms to the homogeneity principle, according to which a proposition letter holds over an interval if and only if it holds over all of its subintervals.
Satisﬁability of an HS formula over a finite Kripke structure can be given in terms of induced abstract interval models.
Definition 2.5 Let K be a finite Kripke structure, ρ be a track in TrkK , and ψ be an HS formula. We say that the pair (K , ρ) satisfies ψ, denoted by K ,ρ |= ψ, iff AK ,ρ |= ψ.
The model checking problem for HS over finite Kripke structures is the problem of deciding whether K |= ψ.
Definition 2.6 Let K be a finite Kripke structure and ψ be an HS formula. We say that K models ψ, denoted by K |= ψ, iff K ,ρ |= ψ, for all initial tracks ρ ∈ TrkK .

The notion of Bk-descriptor
For any finite Kripke structure K , one can find a corresponding induced abstract interval model AK , featuring one interval for each track of K . Since K has loops (each state must have at least one successor), the number of its tracks, and thus the number of intervals of AK , is infinite. In [7], given a finite Kripke structure and an HS formula ϕ, the authors show how to obtain a ﬁnite representation for each (possibly infinite) set of tracks which are equivalent with respect to satisfiability of HS formulas having the same structural complexity (i.e., nesting depth of B modality) as ϕ. Using this representation, they prove that the model checking problem for (full) HS is decidable (with a non-elementary upper bound) and it is EXPSPACE-hard if a suitable encoding of HS formulas is exploited [7]. In this paper, we restrict our attention to the model checking problem for the fragment HS[A, A, B, B, E] (and the symmetric fragment HS[A, A, E, B, E]).
We start with the definition of some basic notions.

Definition 2.7 Let ψ be an HS[A, A, B, B, E] formula. The B-nesting depth of ψ, denoted by NestB(ψ), is defined by induction on the complexity of the formula:
NestB(p) = 0, for any proposition letter p ∈ AP ;
NestB(¬ψ)= NestB(ψ);
NestB(ψ ∧ φ)= max{NestB(ψ), NestB(φ)};
NestB(⟨B⟩ ψ) = 1 + NestB(ψ);

NestB(⟨X⟩ ψ)= NestB(ψ), for X ∈ {A, A, B, E}.
Using Definition 2.7, we can introduce a relation of k-equivalence over tracks.
Definition 2.8 Let K be a finite Kripke structure and ρ and ρj be two tracks in TrkK . We say that ρ and ρj are k-equivalent if and only if, for every HS[A, A, B, B, E] formula ψ, with NestB(ψ)= k, K ,ρ |= ψ if and only if K , ρj |= ψ.
It can be easily proved that k-equivalence propagates downwards [7].
Proposition 2.9 Let K be a ﬁnite Kripke structure and ρ and ρj be two tracks in
TrkK . If ρ and ρj are k-equivalent, then they are h-equivalent, for all 0 ≤ h ≤ k.
We now define the key notion of descriptor for a track of a Kripke structure [7].
Definition 2.10 Let K = (AP , W, δ, μ, v0) be a finite Kripke structure, ρ ∈ TrkK , and k ∈ N. The Bk-descriptor for ρ is a labelled tree D = (V, E, λ) of depth k, where
V is a finite set of vertices, E ⊆ V × V is a set of edges, and λ : V '→ W × 2W × W
is a node labelling function, inductively defined as follows:
for k = 0, the Bk-descriptor for ρ is the tree D  = (root(D), ∅, λ), where
λ(root(D)) = (fst(ρ), intstates(ρ), lst(ρ));
for k > 0, the Bk-descriptor for ρ is the tree D = (V, E, λ), where λ(root(D)) = (fst(ρ), intstates(ρ), lst(ρ)), which satisfies the following conditions:
for each prefix ρj of ρ, there exists v ∈ V such that (root(D), v) ∈ E and the subtree rooted in v is the Bk—1-descriptor for ρj;

for each vertex v ∈ V such that (root(D), v) ∈ E, there exists a prefix ρj of ρ
such that the subtree rooted in v is the Bk—1-descriptor for ρj;
for all pairs of edges (root(D), vj), (root(D), vjj) ∈ E, if the subtree rooted in vj is isomorphic to the subtree rooted in vjj, then vj = vjj (here and in the following, we write subtree for maximal subtree).
Condition (iii) of Def. 2.10 simply states that no two subtrees, whose roots are siblings, can be isomorphic. A B0-descriptor D for a track consists of its root only, denoted by root(D). A label of a node will be referred to as a descriptor element.
Basically, for any k ≥ 0, the label of the root of the Bk-descriptor D for ρ is the triple (fst(ρ), intstates(ρ), lst(ρ)). Each prefix ρj of ρ is associated with some subtree, whose root is labelled with (fst(ρj), intstates(ρj), lst(ρj)) and it is a child of the root of D. Such a construction is then recursively applied to the children of the root until either depth k is reached or a track of length 2 is being considered on a node. Hereafter, two descriptors will be considered equal up to isomorphism.
In Fig. 1, we show an example of B2-descriptor.





Fig. 1. The figure shows the B2-descriptor for the track ρ = v0v1v0v0v0v0v1 of the Kripke structure K = ({p, q}, {v0, v1}, {(v0, v0), (v0, v1), (v1, v0), (v1, v1)}, μ, v0). It is worth noticing that there exist two distinct prefixes of ρ, that is, the tracks ρ′ = v0v1v0v0v0v0 and ρ′′ = v0v1v0v0v0, which have the same B1-descriptor. Since, according to Definition 2.10, no tree can occur more than once as a subtree of the same node (in this example, the root), in the B2-descriptor for ρ prefixes ρ′ and ρ′′ are represented by the same tree (the first subtree of the root on the left). In general, it holds that the root of a descriptor for a track with h proper prefixes does not necessarily have h children.

In general, B-descriptors do not convey enough information to determine which track they were built from, but information is enough to decide which HS[A, A, B, B, E] formulas are satisfied by the originating track. In [7], the authors prove that, for a finite Kripke structure K , there is a ﬁnite number (non-elementary with respect to |W| and k) of possible Bk-descriptors; moreover the number of nodes of a descriptor has a non-elementary upper bound, as well. Since the number of tracks of K is infinite and, for any k ∈ N, the set of Bk-descriptors for its tracks is finite, at least one Bk-descriptor must be the Bk-descriptor of inﬁnitely many tracks. Thus, Bk-descriptors naturally induce an equivalence relation of finite index over the set of tracks of a finite Kripke structure: the k-descriptor equivalence [8].
Definition 2.11 Let K be a finite Kripke structure, ρ, ρj ∈ TrkK , and k ∈ N. We say that ρ and ρj are k-descriptor equivalent (denoted by ρ ∼k ρj) iff the Bk- descriptors for ρ and ρj are isomorphic.
The next theorem proves that, for any pair of tracks ρ, ρj ∈ TrkK , if ρ ∼k ρj, then ρ and ρj are k-equivalent (see Definition 2.8) [8].



Fig. 2. An example of finite Kripke structure.
Theorem 2.12 Let K be a ﬁnite Kripke structure, ρ and ρj be two tracks in TrkK , AK be the abstract interval model induced by K , and ψ be a formula of HS[A, A, B, B, E] with NestB(ψ)= k. If ρ ∼k ρj, then AK ,ρ |= ψ ⇐⇒ AK , ρj |= ψ.
Clusters and descriptor element indistinguishability
A Bk-descriptor provides a finite encoding for a possibly infinite set of tracks (the tracks associated with that descriptor). Unfortunately, the representation of Bk- descriptors as trees labelled over descriptor elements is highly redundant: this pre- vents their direct use in model checking algorithms, and makes it difficult to deter- mine the intrinsic complexity of Bk-descriptors. In this section, we devise a more compact representation of Bk-descriptors. Each class of the k-descriptor equiva- lence relation is a set of k-equivalent tracks. For every such class, we select (at least) a track representative whose length is (exponentially) bounded in both the size of W (the set of states of the Kripke structure) and k. In order to set such a bound, we consider suitable ordered sequences (possibly with repetitions) of de- scriptor elements of a Bk-descriptor. Let us define the descriptor sequence for a track as the ordered sequence of descriptor elements associated with its prefixes. In a descriptor sequence, descriptor elements can obviously be repeated: we devise a criterion to avoid such repetitions whenever they cannot be distinguished by any HS[A, A, B, B, E] formula of B-nesting depth up to k.
Definition 3.1 Let ρ = v0v1 ··· vn be a track of a Kripke structure. The descriptor sequence ρds for ρ is d0 ··· dn—1, where di = ρds(i)= (v0, intstates(v0 ··· vi+1), vi+1), for 0 ≤ i < n. DElm(ρds) denotes the set of descriptor elements occurring in ρds.
As an example, let us consider the finite Kripke structure of Fig. 2 and the track
ρ = v0v0v0v1v2v1v2v3v3v2v2. The descriptor sequence for ρ is:

ρds = (v0, ∅, v0)	(v0, {v0}, v1) (v0, [v1], v2)
(v0, [v2], v3)	,  (*)

where [vi] = {v0, ··· , vi} and DElm(ρds) = {(v0, ∅, v0), (v0, {v0}, v0), (v0, {v0}, v1),
(v0, [v1], v2), (v0, [v2], v1), (v0, [v2], v2), (v0, [v2], v3), (v0, [v3], v2), (v0, [v3], v3)}.
To express the relationships between descriptor elements occurring in a descrip- tor sequence, we introduce a binary relation Rt. Intuitively, given two descriptor elements dj and djj of a descriptor sequence, it holds that dj Rt djj if dj and djj are the descriptor elements of two tracks ρj and ρjj, resp., and ρj is a prefix of ρjj [8].

Definition 3.2 Let ρds be the descriptor sequence for a track ρ and let dj =

(vin, Sj, vj
) and djj = (vin, Sjj, vjj
) be two descriptor elements in ρds.  Then,

dj Rt djj iff Sj ∪ {vj	}⊆ Sjj.
The relation Rt is transitive, but it is neither reflexive nor symmetric, nor anti- symmetric. It can be easily shown that Rt pairs descriptor elements of increasing prefixes of a track: if ρ = v0v1 ··· vn, then ρds(i) Rt ρds(j) for all 0 ≤ i < j < n.
We now introduce a distinction between two types of descriptor elements: a descriptor element (vin, S, vfin) is a Type-1 descriptor element if vfin ∈/ S, while it is a Type-2 descriptor element if vfin ∈ S. A descriptor element d = (vin, S, vfin) is Type-1 if and only if Rt is not reflexive in d: (i) if d /Rt d, then S ∪ {vfin} /⊆ S,

and thus vfin ∈/
S, and (ii) if vfin ∈/
S, then d /Rt d. It follows that a Type-1

descriptor element cannot occur more than once in a descriptor sequence. On the other hand, Type-2 descriptor elements may occur multiple times in a descriptor sequence, and if a descriptor element occurs more than once, then it is necessarily of Type-2. Finally, it can easily be proved that if both dj Rt djj and djj Rt dj, for

dj = (vin, Sj, vj
) and djj = (vin, Sjj, vjj
), then vj
∈ Sj, vjj
∈ Sjj and Sj = Sjj,

and thus both dj and djj are Type-2 descriptor elements.
We are now ready to give a general characterization of the descriptor sequence ρds for a track ρ: ρds is composed of some (maximal) subsequences, consisting of occurrences of Type-2 descriptor elements on which Rt is symmetric, separated by occurrences of Type-1 descriptor elements. This can be formalized by means of the notion of cluster: a cluster C of (Type-2) descriptor elements is a maximal set of descriptor elements {d1,..., ds}⊆ DElm(ρds) such that di Rt dj and dj Rt di for all i, j ∈ {1,..., s}. Due to maximality, clusters are pairwise disjoint: if C and C j are distinct clusters, d ∈ C and dj ∈ C j, either d Rt dj and dj /Rt d, or dj Rt d and d /Rt dj. It is straightforward to check that the descriptor elements of a cluster C are contiguous in ρds (they form a subsequence of ρds), that is, occurrences of descriptor
elements of C are never shuffled with occurrences of descriptor elements not in C .
Definition 3.3 Let ρds be a descriptor sequence and C be one of its clusters. The subsequence of ρds associated with C is the subsequence ρds(i, j), with i ≤ j < |ρds|, including all and only the occurrences of the descriptor elements in C .
As we already pointed out, two subsequences associated with two distinct clusters C and C j in a descriptor sequence must be separated by at least one occurrence of a Type-1 descriptor element. As an example, in the descriptor sequence (*) for the track ρ = v0v0v0v1v2v1v2v3v3v2v2 of the Kripke structure in Fig. 2, the subsequences associated with clusters are enclosed in boxes.
While Rt allows us to order any pair of Type-1 descriptor elements, as well as any Type-1 descriptor element with respect to a Type-2 descriptor element, it does not give any means to order Type-2 descriptor elements belonging to the same cluster. Moreover, Type-2 elements may have multiple occurrences in a descriptor sequence. Thus, to give a bound on the length of track representatives of Bk-descriptors, we need to somehow limit the number of occurrences of Type-2 elements. To this end, we introduce an equivalence relation that allows us to put together indistinguishable



×
×	1
2	3	3

a	b
b
b		b

×	1	2	3	×
1	1	2	3	3

Fig. 3.  Let us consider the track ρ = v0v1v2v3v3v2v3v3v2v3v2v3v3v2v3v2v1v3v2v3v2v1v2v1v3v2v2v3v2 of the finite Kripke structure depicted in Fig. 2. Such a track generates the descriptor sequence ρds = (v0, ∅, v1)(v0, {v1}, v2)(v0, {v1, v2}, v3)abaababaababcababcbcabbab, where a, b, and c stand for (v0,
{v1, v2, v3}, v3), (v0, {v1, v2, v3}, v2), and (v0, {v1, v2, v3}, v1), respectively. Here we show the subsequence ρds(3, |ρds|—1) associated with the cluster C = {a, b, c}. Pairs of k-indistinguishable consecutive occurrences of descriptor elements are connected by a rounded edge labelled by k. Edges labelled by × link occurrences which are not 1-indistinguishable. The values of all missing edges can be derived thanks to the properties established by Proposition 3.5.

occurrences of the same descriptor element in a descriptor sequence, that is, to detect those occurrences which are associated with prefixes of the track with the same Bk- descriptor. The idea is that a track representative for a Bk-descriptor should not include indistinguishable occurrences of the same descriptor element [8].
Definition 3.4 Let ρds be a descriptor sequence and k ≥ 1. We say that two occurrences ρds(i) and ρds(j), with 0 ≤ i < j < |ρds|, of the same descriptor element d are k-indistinguishable iff: (i) if k = 1: DElm(ρds(0, i−1)) = DElm(ρds(0,j−1));
(ii) if k ≥ 2: for all i ≤ l ≤ j − 1, there exists 0 ≤ lj ≤ i − 1 such that ρds(l) and
ρds(lj) are (k − 1)-indistinguishable.
From Definition 3.4, it follows that two indistinguishable occurrences ρds(i) and ρds(j) of the same descriptor element belong to the same subsequence of ρds as- sociated with a cluster. The following properties of k-indistinguishability hold [8].

Proposition 3.5 Let ρds(i) and ρds(j), with 0 ≤ i < j < |ρds|, be two occurrences of the same descriptor element in a descriptor sequence ρds. It holds that: (i) if ρds(i) and ρds(j) are k-indistinguishable, for k ≥ 2, then they are also (k − 1)- indistinguishable; (ii) if ρds(i) and ρds(j) are k-indistinguishable and ρds(m) = ρds(j), for some i < m < j, then ρds(m) and ρds(j) are k-indistinguishable; (iii) if ρds(m) = ρds(j), for some i < m < j, and both the pair ρds(i) and ρds(m) and the pair ρds(m) and ρds(j) are k-indistinguishable, then ρds(i) and ρds(j) are k-indistinguishable.
The fundamental connection between k-indistinguishability of descriptor ele- ments and k-descriptor equivalence of tracks is stated by the next theorem [8].
Theorem 3.6 Let ρds be the descriptor sequence for a track ρ. Two occurrences ρds(i) and ρds(j), with 0 ≤ i < j < |ρds|, of the same descriptor element are k-indistinguishable if and only if ρ(0,i + 1) ∼k ρ(0,j + 1).
In Fig. 3, we give some examples of k-indistinguishability relations for k ∈ {1, 2, 3}. Notice that k-indistinguishability between occurrences of descriptor elements is defined only for pairs of preﬁxes of the same track, while the relation of k-descriptor
equivalence can be applied to pairs of any tracks of a Kripke structure.

Model checking based on track representatives
In this section, we will exploit the k-indistinguishability relation between descriptor elements in a descriptor sequence ρds for a track ρ to possibly replace ρ by a k- descriptor equivalent, shorter track ρj of bounded length. This allows us to find, for each Bk-descriptor DBk (witnessed by a track of the considered finite Kripke structure K ), a track representative ρ˜ in K , such that (i) DBk is the Bk-descriptor for ρ˜ and (ii) the length of ρ˜ is bounded. Thanks to property (ii), we can check all the track representatives of a finite Kripke structure by simply visiting its unravelling up to a bounded depth.
The notion of track representative can be explained as follows. Let ρds be the descriptor sequence for a track ρ. If there are two occurrences of the same descriptor element ρds(i) and ρds(j), with i < j, which are k-indistinguishable (we let ρ = ρ(0,j + 1) · ρ, with ρ = ρ(j + 2, |ρ|− 1)), then we can replace ρ by the k-descriptor equivalent, shorter track ρ(0,i + 1) · ρ. Indeed, by Theorem 3.6, ρ(0, i+1) and ρ(0,j +1) have the same Bk-descriptor, and it is possible to show that, whenever two tracks ρj and ρjj have the same Bk-descriptor and ρ˜ is a track such that (lst(ρj), fst(ρ˜)) is an edge of the Kripke structure, then ρj · ρ˜ and ρjj · ρ˜ have the same Bk-descriptor [8]. It immediately follows that ρ = ρ(0,j +1)·ρ and ρ(0, i+1)·ρ have the same Bk-descriptor. Moreover, since ρds(i) and ρds(j) are occurrences of the same descriptor element, we have that ρ(i + 1) = ρ(j + 1), and thus the track ρ(0,i + 1) · ρ is witnessed in the Kripke structure. By iteratively applying such a contraction method, we can find a track, which is k-descriptor equivalent to ρ, whose descriptor sequence is devoid of k-indistinguishable occurrences of descriptor elements. A track representative is a track that fulfils this property.
The next Proposition 4.1 and Theorem 4.2 provide an upper bound to the length of track representatives (their proofs heavily rest on the contraction method) [8].
Proposition 4.1 Let ρ be a track of K = (AP , W, δ, μ, w0), which is associated with a descriptor element d. Then, there is a track representative ρj ∈ TrkK , which is associated with d, such that |ρj|≤ 2+ |W|2.
Proposition 4.1 will be used in the unravelling Algorithm 1 as a termination criterion, referred to as 0-termination criterion: to get a track representative for every descriptor element with initial state v, witnessed in a ﬁnite Kripke structure with set of states W, we can avoid considering tracks longer than 2+ |W|2 while exploring the unravelling of the Kripke structure from v.
Theorem 4.2 Let ρ be a track of K = (AP , W, δ, μ, w0) and τ (|W|, k)= min 1+ (1+|W|)2k+4+|W|, 1+(k+3)|W |2+1 +|W|}. Then, there exists a track representative
ρj ∈ TrkK , associated with the same Bk-descriptor as ρ, such that |ρj|≤ τ (|W|, k).
Theorem 4.2 allows us to define a termination criterion to bound the depth of the unravelling of a finite Kripke structure ((k ≥ 1)-termination criterion), while searching for track representatives for witnessed Bk-descriptors: for any k ≥ 1, to get a track representative for every Bk-descriptor with initial state v and witnessed in



Algorithm 1 Unrav(K , v, k, direction)
if direction = forw then
Unravel K starting from v according to   d  is an arbitrary order of states For every new node of the unravelling met during the visit, return the track ρ
from v to the current node only if:
if k = 0 then
Apply the 0-termination criterion
else
if The last descriptor element d of (the descriptor sequence of) the current track ρ is k-indistinguishable from a previous occurrence of d then
do not return ρ and backtrack to ρ(0, |ρ|− 2) · v, where v is the minimum state (w.r.t.   ) greater than ρ(|ρ| − 1) such that (ρ(|ρ| − 2), v) is an edge of K .
else if direction = backw then
Unravel K starting from v according to	d K is K with transposed edges For every new node of the unravelling met during the visit, consider the track ρ from the current node to v, and recalculate descriptor element indistinguishability
from scratch (left to right); return the track only if:
if k = 0 then
Apply the 0-termination criterion
else
if There exist two k-indistinguishable occurrences of a descriptor element d
in (the descriptor sequence of) the current track ρ then do not return ρ
Do not visit tracks of length greater than τ (|W |, k)

a ﬁnite Kripke structure with set of states W, we can avoid taking into consideration tracks longer than τ (|W|, k) while exploring the unravelling of the structure from v. Algorithm 1 (the unravelling algorithm) explores the unravelling of the input Kripke structure K to find the track representatives for all witnessed Bk-descriptors. More precisely, in forward mode (backward is analogous), for a given v ∈ W and for every track ρ of K such that fst(ρ) = v and |ρ| ≥ 2, the unravelling algorithm returns a track representative ρj, with fst(ρj)= v, such that ρ and ρj have the same
Bk-descriptor and |ρj|≤ τ (|W|, k). Soundness and completeness are proved in [8].
In the forward mode (used to deal with ⟨A⟩ and ⟨B⟩ modalities), the direction of track exploration and that of indistinguishability checking are the same, so we can stop extending a track as soon as the first pair of k-indistinguishable occurrences of a descriptor element is found in the descriptor sequence, suggesting an easy termination criterion for stopping the unravelling of tracks. In the backward mode (exploited in the case of ⟨A⟩ and ⟨E⟩ modalities), such a straightforward criterion cannot be adopted, because tracks are explored right to left (the opposite direction with respect to the edges of the Kripke structure), while the indistinguishability relation over descriptor elements is computed left to right. In general, changing the prefix of a considered track requires recomputing from scratch the descriptor sequence and the indistinguishability relation over descriptor elements. However, the upper bound τ (|W|, k) on the maximum depth of the unravelling ensures the termination of the algorithm in this mode.
Building on Algorithm 1, we can easily define the model checking procedure ModCheck(K , ψ), whose pseudocode is reported in Algorithm 2. ModCheck(K , ψ) exploits the procedure Check(K , k, ψ, ρ˜), which checks a formula ψ of B-nesting depth k against a track ρ˜ of the Kripke structure K (Check(K , k, ψ, ρ˜) basically



Algorithm 2 ModCheck(K , ψ)
k → NestB(ψ)
u → New (Unrav(K , w0, k, forw))
while u.hasMoreTracks() do
ρ˜ → u.getNextTrack()
if Check(K , k, ψ, ρ˜) = 0 then return 0: “K , ρ˜ |= ψ”
return 1: “K |= ψ”
calls itself recursively on the subformulas of ψ, and it uses Algorithm 1 to deal with
		
⟨A⟩, ⟨A⟩, ⟨B⟩, and ⟨E⟩ modalities).
The model checking algorithm ModCheck requires exponential working space, as it uses an instance of the unravelling algorithm and some additional space for a track ρ˜. Analogously, every recursive call to Check needs an instance of the unravelling algorithm and space for a track. There are at most |ψ| simultaneously active calls to Check, so the total space needed is (|ψ| + 1) O(|W| + NestB(ψ))τ (|W|, NestB(ψ)) bits overall, where τ (|W|, NestB(ψ)) is the maximum length of track representatives and O(|W| +NestB(ψ)) bits are used to represent a state of K , a descriptor element, and a counter for k-indistinguishability.

Model checking with bounded cycle alternations
In this section, we show how the introduction of a bound to the number of cycle al- ternations in tracks makes it possible to check formulas of HS[A, A, B, B, E] by using polynomial working space. To some extent, the proposed approach resembles that of bounded model checking (BMC), where one establishes a bound on the maximum length of considered computations. However, what we bound here is the alternation of different cycles in computations, which is responsible for the exponential length of track representatives. This means that there is not an a priori bound on the length of the tracks (indirectly) checked by the bounded version of the algorithm, the only condition being that their representatives satisfy a suitable constraint on the number of cyclic subtracks (which is formally defined in the following). In such a way, we can lower the working space needed by the algorithm—from exponential to polynomial one—at the expense of completeness.
As a warm-up, we focus our attention on a simplified scenario, where ev- ery strongly connected component (SCC) of the Kripke structure consists of a (simple) cycle only. Intuitively, in these structures, a track can traverse a cycle many times in a row, but once the cycle (and thus the SCC) is left, it cannot be visited again afterwards by the track. As an example, let us consider a track ρ = v0v1v2v3v1v2v3v1v2v3v1v2v3v1v4v5v4v5v6v7v7v7 of a Kripke structure K that sat- isfies the above constraint. In this case, K has (at least) 3 SCCs, that respectively consist of the sets of states {v1, v2, v3}, {v4, v5}, and {v7}. The descriptor sequence
for ρ is ρds = (v0, ∅, v1)(v0, {v1}, v2)(v0, [v2], v3)	(v0, [v3], v4)(v0, [v4], v5)
(v0, [v5], v6)(v0, [v6], v7) (v0, [v7], v7) (v0, [v7], v7) , where

[vi] = {v1,..., vi}, for all i, and a = (v0, [v3], v1), b = (v0, [v3], v2), c = (v0, [v3], v3). The subsequences associated with a cluster are boxed.
A cluster is originated whenever a state of a cycle is visited (at least) twice. Moreover, Type-2 descriptor elements occur in a strictly periodic manner in each subsequence associated with a cluster, due to the constraints of the Kripke structure, admitting only simple cycles as its SCCs. As a consequence, the second and the third occurrences of a descriptor element d in a subsequence associated with a cluster are 1-indistinguishable, the third and the fourth are 2-indistinguishable, and so on. Hence, when a track visits a state in a loop for the (t + 3)-th time, with t ≥ 1, the corresponding occurrence of the descriptor element (the (t + 2)-th one) in the descriptor sequence for that track is t-indistinguishable from the previous occurrence of the same descriptor element (the (t + 1)-th one) 5 . As a consequence, when we consider indistinguishability up to k, any track representative ρ˜ cannot be longer than 1 + (k + 2) · |W|. The first state occurring in ρ˜ contributes the first addend, and it can be followed by at most (k + 2) · |W| state occurrences, because, otherwise, there would be at least k + 3 occurrences of the same state in ρ˜, thus originating a pair of k-indistinguishable occurrences of a descriptor element in ρ˜ds. If we modify Algorithm 1 in such a way that, while visiting the unravelling of K ,
it halts (at the latest) at depth 1+(k + 2)·|W |, it immediately follows that the model checking Algorithm 2 uses (|ψ| + 1) · O(|W| + NestB(ψ)) · O ((NestB(ψ)+ 2) · |W|) bits overall (polynomial working space), where ψ is the input formula.
We can now lift such a polynomial space checking procedure from the above special case to the general one, trading completeness for efficiency. In the following, we describe a PSPACE model checking algorithm for the fragment HS[A, A, B, B, E] over unrestricted finite Kripke structures.
Definition 5.1 Let K be a finite Kripke structure and ρ ∈ TrkK . An occurrence of a simple cycle in ρ is a subtrack ρ(i, j) of ρ, for some 0 ≤ i < j < |ρ|, such that for all i ≤ l < m ≤ j, we have that ρ(l)= ρ(m) if and only if l = i and m = j.
If we exclude the starting and ending state occurrences, an occurrence of a simple cycle in a track ρ has no repeated occurrences of the same state of K .
As an example, the track ρ = [v0v2(v1v3v0]v4⟨v5v1)v2{v5⟩v5} shows that occur- rences of simple cycles in ρ (each of them is delimited by corresponding brackets) may be overlapping, but, by definition, no occurrence can include another one. Moreover, the track ρj = v1v2v3(v4v4)v1v2v3[v5{v5]v5}v1v2v3 shows that not all state occurrences necessarily belong to an occurrence of a simple cycle.
We now show how to generalize the notion of occurrence of a simple cycle to allow the cycle to be arbitrarily iterated and followed by a prefix of itself.
Definition 5.2 Let K be a finite Kripke structure and ρ ∈ TrkK . A cyclic subtrack is a maximal subtrack ρ(i, j) of ρ, for some 0 ≤ i < j < |ρ|, of the form ρ(i, j) = ρ(i, ij)s · ρ(i, jj), for some i ≤ jj ≤ ij < j, s ∈ N+, and ρ(i, ij + 1) is an occurrence of

5 Recall that ρds(i) = d, for 0 ≤ i < |ρds|, is the occurrence of the descriptor element d corresponding to
ρ(i + 1).

a simple cycle. We denote the number of cyclic subtracks of ρ by nc(ρ).
We introduce a bound in the model checking algorithm by constraining the number of cyclic subtracks: by setting a bound on nc( ), we can limit the number of alternations of simple cycles in the considered track representatives (up to iterations of each simple cycle). It is worth noticing that, in such a way, we are not imposing a bound on the maximum length of tracks to be taken into consideration by the algorithm (via their representatives), as even a representative ρ˜ with a small value of nc(ρ˜) may represent tracks of unbounded length. As an example, ρ˜ = v0(v1v2v3)4, where nc(ρ˜) = 1, is the representative, with respect to 2-indistinguishability, for all the tracks v0(v1v2v3)s, s ≥ 4.
For any given l ∈ N, the next theorem gives us a bound on the length of track representatives ρ˜ such that nc(ρ˜) ≤ l.
Theorem 5.3 Let K = (AP , W, δ, μ, w0) be a ﬁnite Kripke structure. Any track representative ρ˜ for some tracks of K (with respect to k-indistinguishability), with nc(ρ˜) ≤ l, is no longer than 1+ l · 1+ (k + 2) · |W| + |W| + |W|.
Proof. By reasoning as in the case of finite Kripke structures featuring only simple cycles as their SCCs, if a state occurs k + 3 times or more in a cyclic subtrack (k ≥ 1), then the corresponding occurrence of the descriptor element in the de- scriptor sequence is (at least) k-indistinguishable from the preceding one. Thus, if a track features a cyclic subtrack longer than 1 + (k + 2) · |W|, then it is not a representative. Furthermore, at most |W| consecutive occurrences of states not belonging to any occurrence of a simple cycle may occur; otherwise, at least one state repeats, originating an occurrence of a simple cycle.	2
Let l = O(|W|c) for some constant c ∈ N+. By modifying Algorithm 1 in such a way that it stops visiting the unravelling of the Kripke structure at the latest at depth 1 + l · 1 + (k + 2) · |W| + |W| + |W|, Algorithm 2 needs (|ψ| + 1) · O(|W| +
This algorithm is in general incomplete because the representatives for some tracks of the Kripke structure may be disregarded (if their nc( ) exceeds the chosen bound). However, the higher c is, the higher number of representatives is taken into account. Obviously, there exists a completeness threshold, that is, a high enough value of the constant c which makes the algorithm complete: when the value we choose for l makes the maximum length of the representatives the algorithm con- siders no lower than τ (|W|, NestB(ψ)), all the possible behaviors of the system are analyzed. However, even small values of l should be enough to find counterexam- ples to typical properties of transition systems we are interested in, e.g., mutual exclusion of processes, reachability of states, non-starvation, liveness, and so on.
Conclusion and future work
In this paper, we outlined a PSPACE model checking algorithm for the HS frag- ments HS[A, A, B, B, E] and HS[A, A, E, B, E]. As in bounded model checking, the

algorithm is in general incomplete: it aims not at analyzing all the behaviors of a system, but at finding counterexamples to relevant properties. The idea is to con- sider only some representatives of computations, for which a bound on the number of their cyclic subtracks holds. At the expense of completeness, we have decreased of an exponential the (spatial) complexity of the algorithm given in [8]. We expect that this new algorithm can be easily implemented and used for practical purposes.

References
Allen, J. F., Maintaining knowledge about temporal intervals, Communications of the ACM 26 (1983),
pp. 832–843.
Biere, A., A. Cimatti, E. M. Clarke, M. Fujita and Y. Zhu, Symbolic model checking using SAT procedures instead of BDDs, in: ACM/IEEE Design Automation Conference, 1999, pp. 317–320.
Della Monica, D., V. Goranko, A. Montanari and G. Sciavicco, Interval temporal logics: a journey, Bull. of the EATCS 105 (2011), pp. 73–99.
Halpern, J. Y. and Y. Shoham, A propositional modal logic of time intervals, Journal of the ACM 38
(1991), pp. 935–962.
Lomuscio, A. and J. Michaliszyn, An epistemic Halpern-Shoham logic, in: IJCAI, 2013, pp. 1010–1016.
Lomuscio, A. R. and J. Michaliszyn, Decidability of model checking multi-agent systems against a class of EHS specifications, in: ECAI, 2014, pp. 543–548.
Molinari, A., A. Montanari, A. Murano, G. Perelli and A. Peron, Checking Interval Properties of Computations, Technical Report 2015/01, Dept. of Math. and CS, University of Udine (2015), https:
//www.dimi.uniud.it/assets/preprints/1-2015-montanari.pdf.
Molinari, A., A. Montanari and A. Peron, A Model Checking Procedure for Interval Temporal Logics based on Track Representatives, in: CSL, 2015.
Montanari, A., A. Murano, G. Perelli and A. Peron., Checking interval properties of computations, in:
TIME, 2014, pp. 59–68.
Moszkowski, B., “Reasoning About Digital Circuits,” Ph.D. thesis, Dept. of Computer Science, Stanford University, Stanford, CA (1983).
Pratt-Hartmann, I., Temporal prepositions and their logic, Artificial Intelligence 166 (2005), pp. 1–36.
Venema, Y., Expressiveness and completeness of an interval tense logic, Notre Dame Journal of Formal Logic 31 (1990), pp. 529–547.
