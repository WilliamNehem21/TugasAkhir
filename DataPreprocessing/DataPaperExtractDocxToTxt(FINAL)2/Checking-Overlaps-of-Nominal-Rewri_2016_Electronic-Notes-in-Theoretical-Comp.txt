Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 323 (2016) 39–56
www.elsevier.com/locate/entcs

Checking Overlaps of Nominal Rewriting Rules
Mauricio Ayala-Rinc´on a,2 Maribel Fern´andez b,3
Murdoch James Gabbayc,4 Ana Cristina Rocha-Oliveiraa,1
a Departamentos de Matem´atica e Ciˆencia da Computa¸c˜ao Universidade de Bras´ılia, Bras´ılia D.F., Brasil
b Department of Informatics King’s College London, London, UK
c School of Mathematics and Computer Sciences Heriot-Watt University, Einburgh, UK

Abstract
Nominal rewriting generalises first-order rewriting by providing support for the specification of binding operators. In this paper, we give sufficient conditions for (local) confluence of closed nominal rewriting theories, based on the analysis of rule overlaps. More precisely, we show that closed nominal rewriting rules where all proper critical pairs are joinable are locally confluent. We also show how to refine the notion of rule overlap to derive confluence of the closed rewriting relation. The conditions that we define are easy to check using a nominal unification algorithm.
Keywords: nominal syntax, rewriting, confluence, binding


Introduction
Two key properties of rewrite theories are termination (‘the computation is finite’) and confluence (‘it is deterministic’). Termination and confluence are undecidable in general, but decidable criteria do exist that are sufficient, and so can be used to check that a rewrite theory satisfies these properties.
Criteria for guaranteeing confluence of rewriting theories were first investigated in the context of the λ-calculus and abstract rewrite theories in works such as [15], in which the famous Newman’s Lemma was stated: confluence and local confluence

1 Email: anacrismarie@gmail.com. Author supported by a Ph.D. scholarship from CAPES Brazil.
2 Email: ayala@unb.br. Work partially supported by grant CNPq UNIVERSAL 476952/2013-1.
3 Email: maribel.fernandez@kcl.ac.uk. Work partially supported by grant CsF PVE CAPES 146/2012.
4 Web: gabbay.org.uk

http://dx.doi.org/10.1016/j.entcs.2016.06.004
1571-0661/© 2016 The Author(s). Published by Elsevier B.V.
This is an open access article under the CC BY-NC-ND license (http://creativecommons.org/licenses/by-nc-nd/4.0/).

coincide for terminating rewrite theories. Nowadays this is seen as a combinatorial property of abstract rewrite theories that strictly depends on Noetherianity, that is, well-foundedness of the rewrite relation [11].
Without termination, the Critical Pair Lemma, which is the kernel of the famous Knuth-Bendix completion procedure, guarantees local confluence of term rewriting theories [13]. The most famous sufficient condition for confluence without termina- tion, giving also rise to a programming discipline, is orthogonality. Orthogonality essentially avoids ambiguity through two easily verifiable syntactic constraints on the rewriting rules: left-linearity, that constrains each variable occurring in the left-hand side of each rule to appear only once, and non-ambiguity, that constrains left-hand sides of rules to have no overlaps (except for trivial ones, at variable positions or between a rule and its copy at the root position). With these syntactic restrictions confluence of orthogonal rewriting theories is guaranteed [17].
Nominal rewriting generalises first-order rewriting by providing support for the specification of languages with binding operators. In nominal syntax, there are two kinds of variables: atoms, which are used to represent object-level variables and can be abstracted but not be substituted, and meta-variables, called simply variables or unknowns, which can be substituted but cannot be abstracted. Substitution of a variable by a term can capture atoms (unlike higher-order theories, where substitution is non-capturing). The nominal rewriting relation is defined using equivariant nominal matching, that is, matching modulo α-equivalence and atom permutations. If rules are closed, then nominal matching is sufficient to generate the rewrite relation. Nominal matching is matching modulo α-equivalence only, and it is efficient (it can be solved in linear time [3]).
For nominal rewriting theories, the Critical Pair Lemma and confluence of orthogonal theories were first investigated in [7], where it was shown that the above- mentioned results extend to the class of uniform nominal rewriting theories, that is, theories where rules do not generate new atoms. More precisely, in [7] it is shown that for the class of uniform theories, if all the non-trivial critical pairs are joinable then the theory is locally confluent, and therefore confluent if it is also terminating (by Newman’s Lemma). Another sufficient condition for confluence of uniform theories is orthogonality: if the rules are left-linear and have no non-trivial critical pairs then the theory is confluent [7]. Trivial critical pairs are defined by overlaps at variable positions, or overlaps at the root between a rule and its copy (as for first-order rewrite theories). However, overlaps at the root between a rule and a permuted variant are not trivial. Both of these criteria rely on checking all non-trivial critical pairs. It is important to check also the overlaps at the root between a rule and its permuted variants, because if we miss those overlaps the theory might not be confluent (see Example 4.3).
In [19], the orthogonality condition given in [7] was relaxed, to permit overlaps at the root between a rule and its permuted copies, but only for uniform rules that satisfy an additional condition, called α-stability.
In this paper we give new criteria for (local) confluence of nominal rewriting. We show that also the conditions in the Critical Pair Lemma can be relaxed if rules

are uniform and α-stable: if all the non-trivial critical pairs, except possibly those caused by overlaps at the root between a rule and its permuted variants, are joinable, then the theory is locally confluent. Moreover, we give a new sufficient condition for α-stability, which is easy to check as it relies simply on nominal matching.
In addition, we give new improved criteria for closed nominal rewriting: it is sufficient to check the overlaps generated using just one variant of each rule.
Summarising, the main contributions of this paper are:
We relax the conditions in the Critical Pair Lemma for uniform rules that are α-stable: it is not necessary to consider critical pairs generated by overlaps at the root between a rule and a permuted variant. See Subsection 4.1. 5
We show that closedness is a sufficient condition for α-stability. Since closedness is easy to check (by simply solving a nominal matching problem), we get an easy to check condition for α-stability. See Subsection 4.2.
We show that for closed rewriting, the criteria can be relaxed even more: it is sufficient to check overlaps by using one freshened version of each rule; overlaps between permuted variants of rules (at the root or otherwise) do not need to be considered at all. See Section 5.

Related work
First-order rewriting systems and the λ-calculus provide two useful notions of terms and reduction. However, both have limitations, which motivated extensions such as higher-order rewriting systems (see, e.g., [12,14]). Nominal rewriting systems are at an intermediate level between higher-order rewriting systems and their explicit substitution versions, which implement in a first-order setting the capture-avoiding substitution operation together with α-conversion. For the latter, indices and rewrite rules are used to deal with the management of bound variables (see, e.g., [18]). Using nominal rewriting, we can specify capture-avoiding substitutions without the need to manage indices, since names and α-equivalence are primitive notions.
Two notions of ‘orthogonality’ exist in previous work for nominal rewriting: In [7], orthogonality was left-linearity plus no non-trivial critical pairs. This was proved a sufficient condition for confluence of uniform rewrite rules. The notion of orthogonality was relaxed in [19] to allow overlaps at the root between permuted variants of rules. This weaker notion does not ensure confluence of uniform rules. If we also have α-stability then confluence is guaranteed [19].
A sufficient condition for α-stability was given in [19], called “abstract skeleton preserving” (ASP). This is a strong restriction: it only allows identity permutations to be suspended on variables, and it requires the use of different atoms in nested abstractions. Here we show that closedness, which does not impose such restrictions and can be checked simply by solving a nominal matching problem, is a sufficient condition for α-stability. In addition, for closed rewriting the criteria for confluence

5 This result was independently obtained by T. Suzuki, K. Kikuchi, T. Aoto and Y. Toyama, “On confluence of nominal rewriting systems”, 16th JSSST Workshop on Programming and Programming Languages, 2014, in Japanese.

can be simplified, by checking only overlaps of freshened rules. Closedness and the ASP criterion are complementary in the sense that none of them implies the other.
Syntax
We fix disjoint countably infinite collections of atoms, unknowns (or variables), and term-formers (or function symbols). We write A for the set of atoms; a, b, c, . . . will range over distinct atoms. X, Y, Z, ... will range over distinct unknowns. f, g,... will range over distinct term-formers. We assume that to each f is associated an arity n ≥ 0. A signature Σ is a set of term-formers with their arities.
Definition 2.1 A permutation π is a bijection on atoms such that nontriv (π)= 
{a | π(a) /= a} is finite. We write (a b) for the swapping permutation that maps a to b, b to a and all other c to themselves, and id for the identity permutation, so id (a)= a. The notation π ◦ πj is used for functional composition of permutations, so (π ◦ πj)(a)= π(πj(a)), and π—1 for inverse, so π(a)= b if and only if a = π—1(b).
Permutations are represented by lists of swappings; thus, composition is list concatenation, and the inverse is obtained simply by reversing the list.
Definition 2.2 Define (nominal) terms inductively by:
s, t, l, r, u	::=	a | π · X | [a]t | f(t1,..., tn)
Call π · X a (suspended) variable and [a]t an (atom-)abstraction; it represents ‘x.e’ or ‘x.φ’ in expressions like ‘λx.e’ or ‘∀x.φ’. We write ≡ for syntactic identity.
Definition 2.3 Define π · t a permutation action by:
π · a ≡ π(a)	π · (πj·X) ≡ (π ◦ πj) · X
π · [a]t ≡ [π(a)](π · t)	π · f(t1,..., tn) ≡ f(π · t1,...,π · tn)
A substitution (on unknowns), ranged over by θ, σ, .. ., is a partial function from unknowns to terms with finite domain. We write id for the substitution with dom(id )= ∅ (it will always be clear whether we mean ‘id the identity substitution’ or ‘id the identity permutation’). If X /∈ dom(σ) then σ(X) denotes id · X.
Define tσ a(n unknowns) substitution action by:

If σ and θ are substitutions, σ ◦ θ maps each X to (Xσ)θ.
Definition 2.4 The set Pos(t) of positions of a term t is defined below. Note that
ϵ is the only position in atoms and variables.


(pє)
ϵ ∈ Pos(t)
p ∈ Pos(t)
1 · p ∈ Pos([a]t) (p[a])
p ∈ Pos(ti)	(1 ≤ i ≤ n)
(pf)
i · p ∈ Pos(f(t ,...,t ,...,t ))

1	i	n

Call t|p a subterm of t at position p when
t|є = t	[a]t|1·p = t|p	f(t1,..., ti,..., tn)|i·p = ti|p (1 ≤ i ≤ n) If p ∈ Pos(s), then s[p→t] denotes the replacement of s|p by t in s.
Definition 2.5 A freshness (constraint) is a pair a#t of an atom a and a term
t. We call a freshness of the form a#X primitive, and a finite set of primitive freshnesses a freshness context. Δ, Γ and ∇ will range over freshness contexts.
We denote by ∇σ the set {a#σ(X)| a#X ∈ ∇} of freshness constraints.
A freshness judgement is a tuple Δ ▶ a#t of a freshness context and a freshness constraint. An α-equivalence judgement is a tuple Δ ▶ s ≈α t of a freshness context and two terms. The derivable freshness and α-equivalence judgements are defined by the rules in Figure 1, where ds(π, πj)= {a ∈ A | π(a) /= πj(a)}. We call ds(π, πj) the difference set of permutations π and πj.

Figure 1: Freshness and α-equality

Definition 2.6 The functions atms(t) and unkn(t) will be used to compute the set of atoms and unknowns in a term, respectively. They are defined by:
atms(a) = {a}	atms(π · X) = nontriv (π)
atms([a]t) = atms(t) ∪ {a}	atms(f(t1,..., tn)) = Si atms(ti)
unkn(a) = ∅	unkn(π · X) = {X}
unkn([a]t) = unkn(t)	unkn(f(t1,..., tn)) = Si unkn(ti)
Nominal Rewriting
This section introduces the main concepts related with nominal rewriting, including the nominal rewriting relation itself, confluence, closedness of terms in context and rules and the closed rewriting relation.

Definition 3.1 A rewrite judgement is a tuple ∇▶ l → r of a freshness context and two terms. We may write ‘∅ ▶’ as ‘▶’.
A rewrite theory R = (Σ, Rw ) is a pair of a signature Σ and a possibly infinite set of rewrite judgements Rw in that signature; we call these rewrite rules.
A rewrite rule ∇▶ l → r is left-linear if each unknown occurs at most once in l.
Definition 3.2 Define tπ the meta-action of π on t by:
aπ = π(a)	(ρ· X)π = ρπ · X	([a]t)π = [aπ]tπ	f(t1,..., tn)π = f(tπ,..., tπ),
1	n
where idπ = id and ((a b) ◦ ρ)π = (π(a) π(b)) ◦ ρπ.
Extend the meta-action to contexts by ∇π = {π(a)#X| a#X ∈ ∇}.
The meta-action of permutations affects only atoms in terms (it does not suspend on variables, in contrast with the permutation action of Definition 2.3). We use it to define the equivariant closure of a set of rules, needed to generate the rewrite relation (Definition 3.4; see [7,8] for more details).
Definition 3.3 The equivariant closure of a set Rw of rewrite rules is the closure of Rw by the meta-action of permutations, that is, it is the set of all the permutative variants of rules in Rw. We write eq-closure(Rw ) for the equivariant closure of Rw .
Below we write Δ ▶ (φ1,..., φn) for the judgements Δ ▶ φ1, ..., Δ ▶ φn.
Definition 3.4 Nominal rewriting: Let R = (Σ, Rw ) be a rewrite theory. The

one-step rewrite relation Δ ▶ s →R
t is the least relation such that for every

(∇▶ l → r) ∈ Rw , position p, permutation π, and substitution θ,
Δ ▶ ∇πθ,	s|p ≈α lπθ,	s[p→rπθ] ≈α t 

Δ ▶ s →R t
(Rew∇▶l→r)

The notation Δ ▶ s →⟨R,p,π,θ⟩ t highlights the fact that the rewrite step from s to t occurs with some specific rule R, position p, permutation π and substitution θ, under the freshness context Δ.
The rewrite relation Δ ▶R s → t is the reflexive transitive closure of the one-step rewrite relation, that is, the least relation that includes the one-step rewrite relation and such that:
for all Δ and s: Δ ▶ s ≈α sj implies Δ ▶R s → sj; and
for all Δ, s, t, u: Δ ▶R s → t and Δ ▶R t → u implies Δ ▶R s → u.
If Δ ▶R s → t holds, we say that s rewrites to t in the context Δ.
The rewrite relation is defined in a freshness context since it takes into account
α-equivalence, which depends on freshness information for the term unknowns.
Example 3.5 The following rewrite theory, using a signature containing term- formers λ of arity 1, and app and subst of arity 2, defines β-reduction for the λ- calculus. Below, application is denoted by juxtaposition and subst([a]X, Y ) is written

X[a '→ Y ] as usual (syntactic sugar). In this theory, we can derive ▶R (λ[a]a)Y → Y
and also a#Z ▶R (λ[a]Z)Y → Z.
(Beta)	▶ (λ[a]X)Y	→ X[a '→ Y ]
(σapp)	▶ (XXj)[a '→ Y ] → X[a '→ Y ]Xj[a '→ Y ] (σvar)	▶ a[a '→ X]	→ X
(σlam) b#Y ▶ (λ[b]X)[a '→ Y ] → λ[b](X[a '→ Y ]) (σє) a#X ▶ X[a '→ Y ]	→ X
Definition 3.6 A rewrite theory R is terminating if there are no infinite rewriting sequences, .e., there is no term in context from which infinite rewriting steps can

be performed. It is locally confluent if Δ ▶ s →R
u and Δ ▶ s →R
v implies that

there exists w such that Δ ▶R u → w and Δ ▶R v → w. It is confluent when, if

Δ ▶R
s → t and Δ ▶R
s → tj, then u exists such that Δ ▶
t → u and Δ ▶R
tj → u.

We call the situation Δ ▶ s →R
u and Δ ▶ s →R
v a peak.

Remark 3.7 Since the definition of the rewriting relation generated by a rewrite theory R = (Σ, Rw ) takes into account permuted variants of rules (via the use of the permutation π in the one-step rewrite relation, see Definition 3.4), it is not necessary to include permuted variants of rules in Rw . For convenience, in the rest of the paper we assume that for any R ∈ Rw , if R and Rπ are both in Rw then π = id ; in other words, Rw does not contain permuted variants of the same rule.
According to Definition 3.4, to generate a rewrite step we need to solve an equiv- ariant matching problem, that is, we need to find a permutation and a substitution such that Δ ▶ s|p ≈α lπθ. This problem is decidable, but exponential over the number of different atoms of the terms in context [4]. However, for closed rules [7], a simpler matching problem of the form Δ ▶ s|p ≈α lθ, called nominal match- ing [20], suffices to generate the rewrite relation. Nominal matching is decidable and unitary [20] and efficient (it can be solved in linear time [3,2]).
Closed rules roughly correspond to rules without free atoms, where rewriting cannot change the binding status of an atom. They are the counterpart of rules in standard higher-order rewriting formats (see [6]). Below we first recall the definition of nominal matching and then give a structural definition and an operational characterisation of closed terms.
Definition 3.8 A term-in-context is a pair Δ ▶ s of a freshness context and a term. A nominal matching problem is a pair of terms-in-context
(∇▶ l) ?≈ (Δ ▶ s)	where unkn(∇▶ l) ∩ unkn(Δ ▶ s)= ∅.
A solution to this problem is a substitution σ such that Δ ▶ ∇σ,Δ ▶ lσ ≈α s, and
dom(σ) ⊆ unkn(∇▶ l).
The following structural definition of closedness follows [6,5].
Definition 3.9 Call a term-in-context Δ ▶ t closed when

every occurrence of an atom subterm a in t is under an abstraction of a;
if π · X occurs under an abstraction of π · a then any occurrence of πj · X occurs under an abstraction of πj · a or a#X ∈ Δ;
for any pair π1 · X, π2 · X occurring in t, and a ∈ ds(π1, π2), if neither π1 · X nor π2 · X occurs in the scope of an abstraction of π1 · a or π2 · a, respectively, then a#X ∈ Δ.
Call R = (∇▶ l → r) closed when ∇▶ (l, r) is closed. 6
It is easy to check whether a term is closed, using nominal matching and a freshened variant of the term [7] (see Proposition 3.11 below).
Definition 3.10 A freshened variant t of a nominal term t is a term with the same structure as t, except that the atoms and unknowns are replaced by ‘fresh’ atoms and unknowns (so they are not in atms(t) and unkn(t), and perhaps are also fresh with respect to some atoms and unknowns from other syntax, which we will always specify). We omit an inductive definition.
Similarly, if ∇ is a freshness context then ∇ denotes a freshened variant of ∇ (so if a#X ∈∇ then a #X ∈∇ , where a and X are chosen fresh for the atoms and unknowns appearing in ∇).
We may extend this to other syntax, like equality and rewrite judgements.
Note that if ∇ ▶ l → r is a freshened variant of ∇ ▶ l → r then unkn(∇ ▶
l → r ) ∩ unkn(∇▶ l → r)= ∅.
Proposition 3.11 A term-in-context ∇ ▶ l is closed if and only if there exists a solution for the matching problem
(∇ ▶ l )	?≈	(∇, atms(∇ ,l )#unkn(∇, l) ▶ l).	(1)
Due to the link between closedness of terms-in-context and solvability of a nominal matching problem, made explicit by the proposition above, the definition of closed rewriting (Definition 3.12) is based on nominal matching instead of using equivariant matching as in Definition 3.4.
Definition 3.12 Given a rewrite rule R = (∇ ▶ l → r) and a term-in-context Δ ▶ s, write Δ ▶ s →R c t when there is some R a freshened variant of R (so, fresh for R, Δ, s, and t), position p and substitution θ such that
Δ, atms(R )# unkn(Δ, s, t) ▶ (∇ θ, s|p≈αl θ, s[p→r θ]≈αt).	(2) We call this (one-step) closed rewriting.
The closed rewrite relation Δ ▶R s →c t is the reflexive transitive closure of
the one-step closed rewrite relation (as in Definition 3.4, but notice the extended freshness context).

6 Here we use pair as a term former and apply the definition above.

Example 3.13 Any rule with free atoms, such as ▶ f(a, a) → a, is not closed (it is impossible to match it with a freshened variant). The rule R = ▶ [a]f(a, X) → 0 is closed, since taking a freshened version R = ▶ [b]f(b, Y ) → 0, it is possible to solve the matching problem ( ▶ ([b]f(b, Y ), 0)) ?≈ (b#X ▶ ([a]f(a, X), 0)) with the substitution σ = [Y '→ (a b) · X]. Notice that b#X ▶ [b]f(b, (a b) · X) ≈α [a]f(a, X).
We refer to [7,8] for more examples and properties of closed rewriting.
To compute overlaps of rules, we use a nominal unification algorithm [20].
Definition 3.14 A nominal unification problem is a set of freshness constraints and pairs of terms, written {a1#t1,..., ak#tk, s1 ?≈? u1,..., sm ?≈? um}. It is unifiable if there exists a solution ⟨Γ, θ⟩ (freshness context and substitution) such that Γ ▶ (a1#t1θ, ..., ak#tkθ, s1θ ≈α u1θ, ..., smθ ≈α umθ). In this case, ⟨Γ, θ⟩ is said to be a unifier for the problem.
Nominal unification is decidable and unitary, that is, if there is a solution for a nominal unification problem there exists a most general one.

Confluence of Nominal Rewriting
In this section we consider two well-known criteria for confluence of first-order rewriting based on the notion of overlapping rewrite steps [1]. They can be extended to nominal rewrite theories, but it is necessary to add some conditions.

Critical Pair Criterion and Orthogonality
The notion of overlap has been extended from the first-order setting to the nominal rewriting setting [7]. In the first-order case, overlaps are computed by unification of a left-hand side of a rule R1 with a non-variable subterm of the left-hand side of a rule R2 (which could be a copy of R1 with renamed variables, in which case the subterm must be strict, that is, overlaps at the root between a left-hand side and its copy are not considered). With nominal rules the nominal rewrite relation is generated by the equivariant closure of a set of rules (see Definitions 3.3 and 3.4) so we must consider permuted variants of rules, and use nominal unification instead of first-order unification. This is Definition 4.1, which follows [7]:
Definition 4.1 (Overlaps and CPs) Let Ri = ∇i ▶ li → ri (i = 1, 2) be copies of rewrite rules in eq-closure(Rw ) (so R1 and R2 could be copies of the same rule), where unkn(R1) ∩ unkn(R2) = ∅, as usual. If the nominal unification problem
∇1 ∪ ∇2 ∪ {l2 ?≈? l1|p} has a most general solution ⟨Γ, θ⟩ for some position p, then we say that R1 overlaps with R2, and we call the pair of terms-in-context Γ ▶ (r1θ, l1θ[p→r2θ]) a critical pair. If p is a variable position, or if R1 and R2 are identical modulo renaming of variables and p = ϵ, then we call the overlap and critical pair trivial, otherwise we call it non-trivial.
The critical pair Γ ▶ (r1θ, l1θ[p→r2θ]) is joinable if there is a term u such that Γ ▶R r1θ → u and Γ ▶R (l1θ[p→r2θ]) → u.

We distinguish between different kinds of overlaps and critical pairs:
Definition 4.2 (Permutative Overlaps and CPs) Let Ri = ∇i ▶ li → ri (i = 1, 2) be copies of rewrite rules in eq-closure(Rw ), such that there is an overlap. If R2 is a copy of Rπ, we say that the overlap is permutative. We call a permutative overlap at the root position root-permutative. We call an overlap that is not trivial and not root-permutative proper. We use the same terminology to classify critical pairs; e.g. we call a critical pair generated by a permutative overlap permutative.
A permutative overlap indicates that there is a critical pair generated by a rule and one of its permuted variants.
Note that only the root-permutative overlaps where π is id are trivial. While overlaps at the root between variable-renamed versions of first-order rules can be discarded (they generate equal terms), in nominal rewriting we must also consider overlaps at the root between permuted variants of rules. Indeed, they do not necessarily produce the same result, as the following example shows (see also [19]).
Example 4.3 Consider R = ( ▶ f (X) → f ([a]X)). There is an overlap at the root between this rule and its variant R(a b) = ( ▶ f (X) → f ([b]X)), i.e., a root-permutative overlap, which is not trivial. It generates the critical pair ▶ (f ([a]X),f ([b]X)). Note that the terms f ([a]X) and f ([b]X) are not α-equivalent. This theory is not confluent; we have for instance:
f (a)
⟨R,є,id,[X'→a]⟩	⟨R,є,(a b),[X'→a]⟩
¸r	r¸
f ([a]a)	/≈α	f ([b]a)
Definition 4.4 introduces uniformity. In [7] a Critical Pair Lemma was proved for uniform nominal rewrite theories, that joinability of non-trivial critical pairs implies local confluence; confluence follows by Newman’s Lemma if the theory is terminating. Uniformity features in this paper in Theorem 4.6. Intuitively, uniformity means that if a is not free in s and s rewrites to t then a is not free in t.
Definition 4.4 (Uniformity) We call a nominal rewrite theory R = (Σ, Rw ) uni- form [7] when if Δ ▶R s → t and Δ, Δj ▶ a#s for some Δj, then Δ, Δj ▶ a#t.
Note that in the Critical Pair Lemma of [7], joinability is assumed for all non- trivial critical pairs. Joinability of proper critical pairs is insufficient for local confluence, even for a uniform theory: the rule in Example 4.3 is uniform. However, an additional condition allows us to prove that uniform rewrite theories with joinable proper critical pairs are locally confluent. Recall the notion of α-stability from [19]:
Definition 4.5 (α-stability) Call a rewrite rule R = ∇ ▶ l → r α-stable when, for all Δ, π, σ, σj, Δ ▶ ∇σ, ∇πσj, lσ ≈α lπσj implies Δ ▶ rσ ≈α rπσj.
A rewrite theory R = (Σ, Rw ) is α-stable if every rule in Rw is α-stable.
α-stability is hard to check in general because of the quantification over all σ
and σj. α-stability is related to closedness (Definition 3.9): we show in Section 4.2



Figure 2: Critical Pair Lemma - case of overlap at a variable position
that closed rules are α-stable. The reverse implication does not hold: for example
▶ f (a) → a is α-stable but not closed.
Theorem 4.6 (Critical Pair Lemma for uniform α-stable theories) Let
R = (Σ, Rw ) be a uniform rewrite theory where all the rewrite rules in Rw are
α-stable. If every proper critical pair is joinable, then R is locally confluent.
Proof We consider cases. There are four kinds of peaks:
If the rewrite steps occur at disjoint positions, then the peak is trivially joinable by applying the same rules, permutations and substitutions.
If the peak is an instance of a proper critical pair (joinable by assumption) then it is joinable since rewriting is compatible with instantiation [7, Theorem 49].
If the peak is generated by an overlap at a variable position, without loss of generality assume ∇▶ s ≈α lπ1 σ1 and s occurs inside lπ2 σ2 under an instance of
1	2
an unknown (ππ2 · X)σ2 (see Figure 2). Then we can change the action of σ2 over
X, replacing s by t, such that ∇▶ t ≈α rπ1 σ1, as it is done in the first-order case. Here we rely on uniformity to ensure that no free atoms are introduced by the rewrite step, so freshness constraints are preserved when replacing s by t.
If there is a root-permutative overlap then joinability follows by α-stability.
2

Definition 4.7 Call a rewrite theory R = (Σ, Rw ) orthogonal when all the rules in Rw are left-linear and there are no non-trivial critical pairs.
Call R = (Σ, Rw ) quasi-orthogonal when all rules are left-linear and there are

no proper overlaps.
So orthogonal theories are left-linear and can have trivial overlaps only, whereas quasi-orthogonal theories are left-linear and can have trivial overlaps and root- permutative overlaps (Definition 4.2).
Orthogonal theories were defined in [7]. Quasi-orthogonal theories were defined in [19] and called orthogonal (we changed the name here to avoid confusion).
For uniform nominal rewrite theories, orthogonality implies confluence [7]. Quasi-orthogonality is insufficient for confluence of uniform theories; see Exam-
ple 4.3. If a theory is uniform, quasi-orthogonal, and α-stable, then it is confluent [19].

Criterion for α-stability
This section presents closedness as a sufficient condition for α-stability. Closedness is easy to check using a nominal matching algorithm (see Proposition 3.11).
An easy technical lemma will be useful, that substitutions that coincide modulo α on the unknowns in a term yield α-equivalent instances, and vice-versa (i.e., if the instances are α-equivalent, the substitutions must coincide modulo α on the unknowns of the term):
Lemma 4.8 Δ ▶ tσ ≈α tθ ⇔ ∀X ∈ unkn(t).Δ ▶ Xσ ≈α Xθ.
Lemma 4.9 If R is a closed rule, then R is α-stable.
Proof It is sufficient to prove the following property: R = ∇ ▶ l → r closed and Δ ▶ s ≈α lσ → rσ and Δ ▶ s ≈α lπσj → rπσj implies Δ ▶ rσ ≈α rπσj.
The matching problems (∇ ▶ (l ,r )) ?≈ (∇, atms(R )#unkn(R) ▶ (l, r)) and (∇ ▶ (l ,r )) ?≈ (∇π, atms(R )#unkn(R) ▶ (lπ, rπ)) are solvable with solutions θ and θπ, respectively, insofar as R is closed. Hence, we can infer:
∇, atms(R )#unkn(R) ▶∇ θ, (l θ, r θ) ≈α (l, r)
∇π, atms(R )#unkn(R) ▶∇ θπ, (l θπ,r θπ) ≈α (lπ, rπ)
Δ ▶ ∇σ, ∇πσj, lσ ≈α lπσj =⇒ Δ, atms(R )#unkn(Rσ) ▶ l θσ ≈α l θπσj
From Lemma 4.8 (⇒), it follows that ∀X ∈ unkn(l ): Δ, atms(R )#unkn(Rσ) ▶
Xθσ ≈α Xθπσj.
Since unkn(r ) ⊆ unkn(l ), Lemma 4.8 (⇐) can be used to demonstrate the equivalences

Δ, atms(R )#unkn(Rσ) ▶ r θσ ≈α rσ, r θπσj ≈α rπσj,r θσ ≈α r θπσj
and, finally, Δ, atms(R )#unkn(Rσ) ▶ rσ ≈α rπσj is obtained by transitivity. Notice that atoms in atms(R ) do not appear in rσ, rπσj, so that the previous judgement can be strengthened taking only Δ as context.	2

Better Criteria for Confluence of Closed Rewriting
In this section we study confluence of closed rewriting (Definition 3.12). Closed rewriting uses freshened versions of rules and nominal matching, instead of the computationally more expensive equivariant matching used in Definition 3.4. Closed rewriting is complete for equational reasoning if the axioms are closed [8].
The following three lemmas state properties of closed rules and closed rewriting, and will be useful for Theorems 5.6 and 5.8. The first two state that if a rule has no free atoms then its freshness context can be extended to obtain a closed rule, and closed rewriting with either rule is equivalent. The third lemma states that a rule with free atoms generates an empty closed rewriting relation.
Lemma 5.1 Let R = ∇ ▶ l → r be a rule such that every occurrence of an atom subterm a in l or r is under the scope of an abstraction of a (i.e., no atom occurs free as a subterm in R). Then there exists a minimal context Δ ⊆ atms(R)#unkn(R) such that Δ, ∇▶ l → r is closed.
Proof By definition of closed term (see Definition 3.9), we must check:
Every occurrence of an atom subterm a is under an abstraction of a.
If π · X occurs under an abstraction of π · a, then any occurrence of πj · X is in the scope of an abstraction of πj · a or a#X ∈∇ ∪ Δ.
For any pair π1 · X, π2 · X occurring in R and a ∈ ds(π1, π2), if π1 · a and π1 · a
are not abstracted over the respective occurrences of X, then a#X ∈∇ ∪ Δ . 
The first point holds by assumption. For the second and third points, if a#X /∈∇ 
it is sufficient to include a#X in Δ.	2
Lemma 5.2 Suppose R = ∇ ▶ l → r and Rj = Δ, ∇ ▶ l → r are rules such that
R has no free atom-subterms and Δ ⊆ atms(R)#unkn(R) is the minimal set of
′
freshness constraints that makes Rj closed. Then, Γ ▶ s →R c t ⇔ Γ ▶ s R	t.
Proof The left-to-right direction.	If Γ ▶ s →R c t, then Γ, atms(R )#unkn(Γ, s, t) ▶

s →R
t, i.e., there is θ such that

Γ, atms(R )#unkn(Γ, s, t) ▶ s|p ≈α l θ, t ≈α s[p→r θ], ∇ θ.
Since atms(R)= atms(Rj), it suffices to show that Γ, atms(R )#unkn(Γ, s, t) ▶ Δ θ

to obtain Γ, atms(R )#unkn(Γ, s, t) ▶ s R′
t as required.

To prove Γ, atms(R )#unkn(Γ, s, t) ▶ Δ θ, observe that a #X is in Δ if π1 · X
and π2 · X occur in (l ,r ) and at least one of the following holds:
π1 · a is abstracted over π1 · X and π2 · a is not abstracted over π2 · X . We know Γ, atms(R )#unkn(Γ, s, t) ▶ π2 · a #(s|p, t|p), (s|p, t|p) ≈α (l θ, r θ).
Then, since π2 · a is not abstracted over π2 · X , the same freshness context allows us to derive π2 · a #π2 · X θ and, consequently, a #X θ.

a is in ds(π1, π2) and neither π1 · a nor π2 · a are abstracted over the respective occurrences of X . The same argument is valid in this case.

The right-to-left direction.	If Γ ▶ s R′
t, then Γ, atms(R )#unkn(Γ, s, t) ▶

′
→ t, i.e., there is θ such that
Γ, atms(Rj )#unkn(Γ, s, t) ▶ s|p ≈α l θ, t ≈α s[p→r θ], ∇ θ, Δ θ.

So atms(R)= atms(Rj). It follows that Γ, atms(R )#unkn(Γ, s, t) ▶ s →R




t.	2

Lemma 5.3 Suppose R = ∇▶ l → r is a nominal rule and there exist Δ, s,t and a closed-rewriting step Δ ▶ s →R c t. Then every occurrence of an atom subterm a in l or r is under an abstraction of a (i.e., no atom occurs free as a subterm in R).
Proof By contradiction. Assume R has a free atom subterm a; without loss of generality, we assume l|q = a (if it occurs in r we reason in the same way). By definition of closed-rewriting, there exists R , a fresh variant of R, such that Δ, atms(R )#unkn(Δ, s, t) ▶ s|p ≈α l θ, t ≈α s[p→r θ], ∇ θ. But l |q = a is free, and a does not occur in s, contradicting Δ, atms(R )#unkn(Δ, s, t) ▶ s|p ≈α l θ.2
The following definitions of fresh overlap and fresh critical pair will be used to derive sufficient conditions for confluence of closed rewriting.
Definition 5.4 (Fresh Overlaps and CPs) Let Ri = ∇i ▶ li → ri (i = 1, 2) be freshened versions of rewrite rules in Rw (R1 and R2 could be two freshened versions of the same rule), where unkn(R1) ∩unkn(R2)= ∅, as usual. If the nominal unification problem ∇1 ∪ ∇2 ∪ {l2 ?≈? l1|p} has a most general solution ⟨Γ, θ⟩ for some position p, then we say that R1 fresh overlaps with R2, and we call the pair of terms-in-context Γ ▶ (r1θ, l1θ[p→r2θ]) a fresh critical pair.
If p is a variable position, or if R1 and R2 are equal modulo renaming of variables and p = ϵ, then we call the overlap and critical pair trivial.
If R1 and R2 are freshened versions of the same rule and p = ϵ, then we call the overlap and critical pair fresh root-permutative.
A fresh overlap (resp. fresh critical pair) that is not trivial and not root- permutative is proper.
The fresh critical pair Γ ▶ (r1θ, l1θ[p→r2θ]) is joinable if there is a term u such that Γ ▶R r1θ →c u and Γ ▶R (l1θ[p→r2θ]) →c u.
Definition 5.5 Call a rewrite theory R = (Σ, Rw ) fresh quasi-orthogonal when all rules are left-linear and there are no proper fresh critical pairs.
Theorem 5.6 (Critical Pair Lemma for Closed Rewriting)
Let R = (Σ, Rw) be a rewrite theory where every proper fresh critical pair is joinable. Then the closed rewriting relation generated by R is locally confluent.
Proof Since rules with free atom-subterms do not generate closed rewriting steps (Lemma 5.3), without loss of generality we can assume that the rules in Rw do not have free atom-subterms. Consider Rj = (Σ, Rwj) the closed rewrite theory obtained

by extending the freshness contexts of rules in Rw, as described in Lemma 5.1. Then, by Lemma 5.2, the closed rewriting relation generated by R is equivalent to the one generated by Rj. Thus, joinability of proper fresh critical pairs in R implies joinability of proper fresh critical pairs in Rj and it suffices to prove local confluence for the closed rewriting relation generated by Rj. Also note that since all rules in Rwj are closed, they are uniform and α-stable (Lemma 4.9).
We consider the kinds of peaks that may arise:
If the rewrite steps deﬁning the peak occur at disjoint positions then the peak is trivially joinable by applying the same rules and substitutions.
If the peak is generated by an overlap at a variable position then consider R1 =
∇1 ▶ l1 → r1 and R2 = ∇2 ▶ l2 → r2 freshened versions of two rules (see Figure 2, but here we do not need permuted versions for the rules are already freshened). Let Δ be the context used to rewrite l2σ2 with R1 and R2. Without loss of generality, we assume Δ, atms(R1)#unkn(Δ, s) ▶ ∇1σ1,s ≈α l1σ1,t ≈α r1σ1 and s occurs inside l2σ2 under an instance of an unknown (π · X )σ2. Then we can change the action of σ2 over X , replacing s by t, such that ∇1 ▶ t ≈α rπ1 σ1, as it is done in the first-order case. Here we rely on the assumption of uniformity, which ensures that no free atoms are introduced by the rewrite step, therefore no freshness constraint will be violated when replacing s by t.
	If there are freshened rules R1 = ∇1 ▶ l1 → r1 and R2 = ∇2 ▶ l2 → r2 and a term-in-context Δ ▶ s, such that there is a rewrite step at position p1 in s using R1 and at position p2 using R2 then Δ, Γ1 ▶ ∇1σ, l1σ ≈α s|p1 and Δ, Γ2 ▶
∇ σj,l σj ≈α s|p . Without loss of generality we assume that p2 = p1q. Since
2	2	2
the sets of variables in the freshened rules are disjoint, without loss of generality
we can assume dom(σ) ∩ dom(σj) = ∅, and define the substitution μ = σ ◦ σj such that dom(μ)= dom(σ) ∪ dom(σj). Then, Δ, Γ1, Γ2 ▶ ∇1μ, ∇2μ, l1|qμ ≈α l2μ. Therefore the unification problem ∇1, ∇2, l1|q ?≈? l2 has a solution. Hence, by Definition 5.4, there is a fresh critical pair between R1 and R2. Observe that, if q = ϵ and R1 is a permuted copy of R2 (equal or not), then the terms of divergence t1 and t2 are α-equivalent by triviality or α-stability. If the critical pair is proper it is joinable by assumption. Therefore the peak is joinable since the rewriting relation is compatible with instantiation [7, Theorem 49].
2


Since it is sufficient to consider just one freshened version of each rule when computing overlaps of closed rules, the number of fresh critical pairs for a rewrite theory with a finite number of rules is finite. Thus, Theorem 5.6 provides an effective criterion for local confluence, similar to the criterion for first-order systems.
We can deduce from Theorem 5.6 that the closed rewriting relation for the closed theory defining explicit substitution in Example 3.5 (i.e., all the rules except Beta) is locally confluent: every proper fresh critical pair is joinable. If we consider also the rule (Beta) then the system is not locally confluent. This does not contradict the previous theorem, because there is a proper fresh critical pair between (Beta)

and (σapp), obtained from ∅ ▶ ((λ[a]X)Y )[b '→ Z], which is not joinable:
∅ ▶ (((λ[a]X)[b '→ Z])(Y [b '→ Z]), (X[a '→ Y ])[b '→ Z]).

Next we consider criteria for confluence based on (quasi-) orthogonality. The following lemma is used in the proof of confluence.
Lemma 5.7 Let R = (Σ, Rw ) be a closed rewrite theory.
Δ ▶R	s  →c	t if, and only if, there exist R1,..., Rn	∈  Rw such that
Δ, atms(R1,..., Rn)#unkn(Δ, s) ▶R s → t.
Proof In both directions, the proof is by induction on the number of steps in Δ ▶R s →c t and Δ, atms(R1,..., Rn)#unkn(Δ, s) ▶R s → t, respectively. From left to right, the result follows by definition of closed rewriting. In the other direction, it is necessary to consider closedness of rules. Any version of R ∈

Rw can be used in one step Δ, atms(R ,...,R )#unkn(Δ, s) ▶ s →R
v. So, the

1	n
version R freshened with respect to Δ, atms(R1,..., Rn) and all the terms in the
rewrite sequence could be taken in this step. Weakening the freshness context,

Δ, atms(R ,...,R ,R )#unkn(Δ, s) ▶ s →R
v is obtained. Since the atoms of

1	n
R1,..., Rn do not occur in Δ,R and in the terms of the rewrite sequence, the

freshness context can be strengthened into Δ, atms(R )#unkn(Δ, s) ▶ s →R
v. Thus,

Δ ▶ s →R c v is reached.	2
Theorem 5.8 If R is a fresh-quasi-orthogonal rewrite theory, then the closed rewrit- ing relation generated by R is confluent.
Proof As in the previous theorem, we prove confluence for the closed rewriting relation generated by Rj = (Σ, Rwj), where Rwj is obtained by extending the freshness contexts to close the rules of Rw which do not have free atom-subterms (see Lemmas 5.3, 5.1 and 5.2). Since all rules in Rwj are closed, they are also uniform and α-stable.
Now we can proceed in the usual way (see, e.g., [1,16,7]), by proving the diamond property for a parallel closed-rewriting relation (simultaneous closed rewriting steps at disjoint positions). The proof proceeds by analysis of peaks: When overlaps occur under instances of variables, we use uniformity to ensure that when we change the substitution, the rewrite step is still possible. Joinability of root-permutative overlaps is a consequence of α-stability for the rules are closed.
Alternatively, we can prove confluence by reducing to a previous result for standard nominal rewriting, using the previous lemma: Consider a peak Δ ▶R′  s →c t and Δ ▶R′  s →c v.  By Lemma 5.7 (⇒), there exist R1,..., Rn ∈ Rwj such that Δ, atms(R1,..., Rn)#unkn(Δ, s) ▶ ′  s → t and Δ, atms(R1,..., Rn)#unkn(Δ, s) ▶R′ s → v. Theorem 28 of [19] guarantees conflu- ence with the context Δ, atms(R1,.  , Rn)#unkn(Δ, s), since for closed theories
our notion of fresh-quasi-orthogonality coincides with the notion of orthogonality
defined in [19] (in this case, it does not matter which permuted version is used

to obtain a proper critical pair). Using Lemma 5.7(⇐), we obtain confluence of
R′
Δ ▶  →c .	2
Example 5.9 Consider a signature for first-order logic, with term-formers ¬, ∀ and
∃ of arity 1, and ∧, ∨ of arity 2 (as usual we write them infix). The following closed rules can be used to simplify formulas:
▶ ¬(X ∧ Y ) → ¬(X) ∨ ¬(Y )	and	b#X ▶ ¬(∀[a]X) → ∃[b]¬((b a) · X).
Why write ∃[b]¬((b a)·X) on the right-hand side above, instead of the α-equivalent
∃[a]¬(X)? We could: these are equivalent—in a nominal context. The version above directly translates the corresponding CRS rule (see [6]) which, following Barendregt’s convention, must use different names for bound variables in a rule. Theorem 5.8 tells us that the closed rewriting relation generated by the theory in Example 5.9 is confluent. This theory is closed, but forbidden by ASP restrictions because of the permutation (b a) on the right-hand side.
The criteria for local confluence given in Theorem 5.6 and for confluence given in Theorem 5.8 for closed rewriting are easy to check using a nominal unification algorithm: just compute overlaps for the set of rules obtained by taking one freshened copy of each given rule. For comparison, the criteria given in [7] and [19] require the computation of critical pairs for permutative variants of rules, which needs equivariant unification (exponential). Theorems 5.6 and 5.8 apply even if the rules are not closed, as long as we use closed rewriting. Consider the uniform rules
▶ f (a) → 0 and ▶ g(f (b)) → 0. These rules have no non-trivial fresh overlap, and closed rewriting is confluent, but the standard rewriting relation is not confluent, since the term g(f (a)) rewrites to both g(0) and 0. Using closed rewriting, the term g(f (a)) is a normal form.
Conclusion
We have presented easy-to-check criteria for confluence of nominal rewriting theories (Theorem 4.6 and Lemma 4.9, and Theorems 5.6 and 5.8), improving previous criteria [7,19]. The Critical Pair Lemma for closed rewriting yields a completion algorithm for closed rewrite rules [9]. We intend to enlarge the PVS library on term rewriting systems [10] to formalise the results of this paper.

References
F. Baader and T. Nipkow. Term rewriting and all that. Cambridge UP, 1998.
C. Calv`es. Complexity and implementation of nominal algorithms, 2010. PhD thesis, King’s College London.
	C. Calv`es and M. Fern´andez. Matching and alpha-equivalence check for nominal terms. J. Comput. Syst. Sci., 76(5):283–301, 2010.
	J. Cheney. The complexity of equivariant unification. In Automata, Languages and Programming: 31st Int. Colloquium, ICALP 2004, volume 3142 of LNCS, pages 332–344. Springer, 2004.


R. A. Clouston. Closed terms (unpublished notes). Available from http://cs.au.dk/~ranald/ closedterms.pdf, 2007.
	J. Dom´ınguez and M. Fern´andez. Relating nominal and higher-order rewriting. In Mathematical Foundations of Computer Science 2014 - 39th Int. Symposium, MFCS 2014. Proc., Part I, volume 8634 of LNCS, pages 244–255. Springer, 2014.
	M. Fern´andez and M. J. Gabbay. Nominal rewriting. Information and Computation, 205(6):917–965, June 2007.
	M. Ferna´ndez and M.J. Gabbay. Closed nominal rewriting and efficiently computable nominal algebra equality. In Proc. 5th Int. Workshop on Logical Frameworks and Meta-languages: Theory and Practice, LFMTP 2010, pages 37–51, 2010.
	M. Fern´andez and A. Rubio. Nominal Completion for Rewrite Systems with Binders. In Automata, Languages, and Programming, volume 7392 of LNCS, pages 201–213. Springer, 2012.
A.L. Galdino and M. Ayala-Rinco´n. A Formalization of the Knuth-Bendix(-Huet) Critical Pair Theorem.
J. Autom. Reasoning, 45(3):301–325, 2010.
	G. P. Huet. Confluent reductions: Abstract properties and applications to term rewriting systems: Abstract properties and applications to term rewriting systems. J. of the ACM, 27(4):797–821, October 1980.
J.-W. Klop, V. van Oostrom, and F. van Raamsdonk. Combinatory reduction systems, introduction and survey. Theoretical Computer Science, 121:279–308, 1993.
	D. Knuth and P. Bendix. Simple word problems in universal algebras. In Computational Problems in Abstract Algebra. Pergamon Press, Oxford, 1970.
	R. Mayr and T. Nipkow. Higher-order rewrite systems and their confluence. Theoretical Computer Science, 192:3–29, 1998.
	M. H. A. Newman. On Theories with a Combinatorial Definition of “Equivalence”. The Annals of Mathematics, 43(2):pp. 223–243, 1942.
	A. C. Rocha-Oliveira and M. Ayala-Rinco´n. Formalizing the confluence of orthogonal rewriting systems. In Proc. 7th Workshop on Logical and Semantic Frameworks, with Applications, LSFA 2012, pages 145–152, 2012.
	B. K. Rosen. Tree-manipulating systems and Church-Rosser theorems. J. of the ACM, 20(1):160–187, January 1973.
M.-O. Stehr. CINNI - A Generic Calculus of Explicit Substitutions and its Application to λ- ς- and π-Calculi. Electronic Notes in Theoretical Computer Science, 36:70–92, 2000. The 3rd Int. Workshop on Rewriting Logic and its Applications.
	T. Suzuki, K. Kikuchi, T. Aoto, and Y. Toyama. Confluence of Orthogonal Nominal Rewriting Systems Revisited. In 26th Int. Conf. on Rewriting Techniques and Applications (RTA 2015), volume 36 of LIPIcs, pages 301–317, 2015.
	C. Urban, A. M. Pitts, and M. Gabbay. Nominal Unification. Theoretical Computer Science, 323(1- 3):473–497, 2004.
