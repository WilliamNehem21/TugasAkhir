Electronic Notes in Theoretical Computer Science 43 (2001)
URL: http://www.elsevier.nl/locate/entcs/volume43.html 16 pages


Puzzles for Learning Model Checking, Model Checking for Programming Puzzles, Puzzles for Testing Model Checkers

N. V. Shilov 1,2,4 and K. Yi 1,3
Research On Program Analysis System (ROPAS) Department of Computer Science
Korean Advanced Institute of Science and Technology (KAIST) Kusong-dong Yusong-gu 373-1
Taejon 305-701, Republic of Korea



Abstract
Paper discusses some issues related to an utility of finite games for early formal methods teaching and for validation of automatic tools which implement formal methods. In particular, some experience with (1) undergraduate teaching model checking via finite games, (2) solving game-based constraints via model checking,
(3) testing model checkers against game test suits is presented. Basic ideas are illustrated by a model checking based solution for a complicated puzzle how to identify a unique false coin among given ones balancing them limited times.


Introduction
The role of formal methods in the development of computer hard- and software increases since systems become more complex and require more efforts for their specification, design, implementation and validation. At the same time, formal methods become more complicated since they have to capture real properties of real systems for sound reasoning. A survey of formal methods is out of the scope of this paper. The best way to get opinion about scope and range of formal methods research and their industrial-strength applications is to

1 This work is supported by Creative Research Initiatives of the Korean Ministry of Science and Technology
2 Email: shilov@ropas.kaist.ac.kr Homepage: http://ropas.kaist.ac.kr/~shilov
3 Email: kwang@ropas.kaist.ac.kr Homepage: http://ropas.kaist.ac.kr/~kwang
4 While on leave from A.P. Ershov Institute of Informatics Systems of Siberian Division of
Russian Academy of Science, Novosibirsk, Russia
◯c 2001 Published by Elsevier Science B. V. Open access under CC BY-NC-ND license.


visit special sites http://archive.comlab.ox.ac.uk/formal-methods.html in Oxford or http://shemesh.larc.nasa.gov/fm/ in NASA.
Nevertheless we would like to remark that specification languages which are in use in formal methods range from propositional to high-order level while a proving technique is either semantical (model-checking) or syntactic (deduction) reasoning. In particular, program logics are modal logics used in hard- and software verification and specification. A special place in a diversity of propositional program logics belongs to the propositional µ-Calculus (µC) of D. Kozen [17] due to its expressiveness. In brief µC can be defined as a polymodal variant of basic modal logic K with fixpoints. A model checking problem for µC is a very important research topic [9,1,10,12,2,24,25,6,7,23,11]. Close relations between model checking the µ-Calculus and special bisimula- tion games have been studied in papers [24,25,23]. In particular, [24] has de- fined infinite model checking games for µC, [25] has defined finite fixed point games and characterized indistinguishability of processes (states) by means of µC formulae in terms of winning strategies, [23] has exploited model-checking games for practical efficient local model checking. We would like to discuss three other issues related to a role of games for the µ-Calculus, namely:
finite games for early teaching of model checking (sections 2, 3),
model checking for programming winning strategies (sections 4, 5),
validation of model checkers via finite game test-suits (section 6).

Learning µ-Calculus via games
In spite of the importance of the formal approach for development of a reli- able hard- and software this research domain is not well acquainted to non- professionals. In particular, many undergraduate students of departments which are closely related to further progress of computer hard- and software (i.e. pure/applied mathematics and electric/electronic engineering) consider formal methods in general to be out of scope of their interests, since they (formal methods) are
either too poor for their pure mathematics,
either too pure for their poor mathematics.
We are especially concerned by this disappointing not well motivated attitude and suppose that a deficit of popular lectures, tutorials and papers on this topic is the main reason for this ignorance. But an attitude of researchers en- gaged with formal methods to popularization of their research domain seems not to be very much better then an attitude of students to formal methods, while popular presentation of research is a good opportunity for better com- puter science education and will support the transfer of scientific research to industrial practice. Really, in a comparison with an attitude of mathemati- cians to popularization of their researches a corresponding activity of com-

puter scientists seem non-impressive. There are several popular world-wide known journals on mathematics for students as well as for researchers (ex., The American Mathematical Monthly ). Moreover, mathematicians become more concerned by popularity of the applied mathematics among students. In particular, Society for Industrial and Applied Mathematics (SIAM) recently launched a special section on education in the SIAM Review (SIREV). As is stated in the Guidelines for SIREV Authors,
In the large majority of cases, articles should be written for students, not to faculty... Articles should provide descriptions, illustrations and sights re- garding established or recent knowledge, as opposed to new research results.
In contrast it is very hard to point out a journal in computer science which regularly publishes popular and expository papers for students.
The above arguments can mislead to a conclusion that an attitude to pop- ularization of formal methods theory is negative. This conclusion is invalid of course. Really, let us just to remind International Summer Schools in Markto- berdorf and European Summer Schools in Logic, Language and Information. But let us also to remark that an auditory of these school is comparatively small (a couple of hundreds per year) and consists of graduate or postgraduate students, junior scientists or professors.
Earlier and better teaching formal methods via popular (but sound) pre- sentation of mathematical foundations of formal methods can be based on games and game-based puzzles. An educational role of games and game- based puzzles is well acknowledged in the literature on logics of knowledge in computer science. For example, in [13] a knowledge-based analysis of muddy children puzzle, synchronous attack and Byzantine agreement motivate and illustrate basic theoretical ideas and concepts. May be the main lesson which educators/researchers should learn from [13] is: for being attractive mathe- matical foundations of formal methods should be illustrated by challenging game-based examples.
We would like to sketch below how a program logics tributary creek of a powerful stream called formal methods was presented in a popular (but mathe- matically sound) form to undergraduate students of Mathematics, Physics and Technical Departments of Novosibirsk State University during preparation for The ACM Collegiate Programming Contest . We hope that this example can be interesting for model checking community not only from a pedagogical viewpoint, since it assists to understand and develop some further results.
The first author of this paper was a member of the program committee for a regional middle school contest on mathematics. Several years ago the following puzzle was suggested by the committee to pupils on the contest:
A set of coins consists of 14 valid and 1 false coin. All valid coins have equal weights while the false coin has a another weight. One of the valid coins is marked while all other coins (including the false one) are unmarked. Is it possible to identify the false coin balancing coins 3 times at most?

Both authors were trainers of teams of undergraduates for ACM Regional programming contests. So a question how to put the puzzle for programming arose naturally. Finally a corresponding programming problem was designed and suggested to undergraduate students on training sessions. A brief form of the problem follows:
Write a program ALPHA with 3 inputs
-a number N of coins under question,
-a number M of marked valid coins,
- a limit K of balancing
which outputs either impossible or another interactive program BETA (in the same language) which implements a K-times (at most) balancing strat- egy for identification of a single false coin among N coins with aid of M marked valid coins. Each session with BETA should begin from user’s choice of a number for a single false coin and weather it is lighter or heavier. Then a session consists of a series of rounds and general amount of rounds can not exceed K. On each round the program outputs two disjoint subsets of numbers of coins to be placed on pans of a balance. The user in his/her turn replies in accordance with the initial choice. The session finishes with the the final output of BETA – the number of the false coin.
Since the problem is to write a program which produce another program then we would like to refer the first program as the metaprogram and the problem as the metaprogram problem respectively.
For tackle the metaprogram problem let us give a game interpretation:
Let M and N be non-negative integer parameters and let (N +M ) coins be enumerated by numbers [1..(N + M )]. Coins with numbers [1..M ] are valid while there is a single false among coins with a number in [(M +1)..(M +N )]. The GAME(N, M ) of two players user and prog consists of a series of rounds. On each round a move of the prog is a pair of disjoint subsets (with equal cardinalities) of [1..(M + N )]. A possible move of the user is either
<, = or >, but a move must be consistent with all constraints induced in previous rounds. Prog wins the GAME(N, M ) as soon asa unique number in [1..(M + N )] meets all constraints induced during the game.
In these settings the metaprogram problem can be reformulated as follows:
Write a program which for all N ≥ 1, K ≥ 0 and M ≥ 0 generates (iff possible) a K-rounds at most wining strategy for prog in the GAME(N, M ).
Then another question arises: What is a proper formalism for the metapro- gram problem in this new setting? A hint is a formalism should have explicit fixpoints. Really, the following informal statement is very natural: If a player prog is in a position where he/she has a winning strategy then he/she has a move prior to and after which the game is not lost, but after which every move of another player user leads to a position where the game is lost or prog has a winning strategy. In other words: a set of positions where prog has a winning

strategy is a fixpoint of a special operation on sets of position.
A functional paradigm is a well known paradigm with explicit fixpoints. But, in accordance with regulations of ACM Collegiate Programming Con- tests, programs should be written in an imperative language like PASCAL. So another paradigm would be better in this case then the functional one. It should be a paradigm which captures imperative style and fixpoints simulta- neously. This is a program logics paradigm in general, and the formalism of the propositional µ-Calculus in particular. But this formalism is not very sim- ple since in the most comprehensive form it relies upon transfinite induction: it is not easy to make the µ-Calculus easy for the undergraduate students! Another hint is an incremental approach to the introduction of the µ-Calculus and a concentration on model checking of the µ-Calculus in finite models only. See [21] for full story with a solution for the metaprogram problem and details of background theory while a brief summary is presented in sections 3, 4, 5.
Program Logics via Games
Let {true, false} be boolean constants, Prp and Act be disjoint finite alpha- bets of propositional and action variable respectively. The syntax of the clas- sical propositional logic consists of formulae and is constructed from propo- sitional variables and boolean connectives ¬ (negation), ∧ (conjunction) and
∨ (disjunction) in accordance to standard rules. Elementary Propositional Dynamic Logic (EPDL)[15] has additional features for constructing formu- lae — modalities which are associated with action variables: if a is an action variable and φ is a formula then ([a]φ) and (⟨a⟩φ) are formulae 5 . The se- mantics of EPDL is defined in models, which are called Transition Systems or Kripke Structures. A model M is a pair (DM , IM ) where the domain DM is a nonempty set, while the interpretation IM is a pair of special mappings (PM , RM ). Elements of the domain DM are called states. The interpretation maps propositional variables into sets of states and action variables into binary relations on states:
PM : Prp → P(DM ) ,  RM : Act → P(DM × DM )
where P is a power-set operation. We write IM (p) and IM (a) instead of PM (p) and RM (a) whenever it is implicit that p and a are propositional and action variables. Models can be considered as labeled graphs with nodes and edges marked by sets of propositional and action variables respectively. For every model M = (DM , IM )a validity relation |=M between states and formulae can be defined inductively with respect to the structure of formulae. For boolean constants, propositional variables and propositional connectives semantics is defined in a standard way while we have
s |=M (⟨a⟩φ) iff (s, s') ∈ IM (a) and s' |=M φ for some state s',

5 which are read as “box/diamond a φ” or “after a always/sometimes φ” respectively

s |=M ([a]φ) iff (s, s') ∈ IM (a) implies s' |=M φ for every state s'.
So, an experienced mathematician can remark that EPDL is just a polymodal variant the basic propositional modal logic K [3].
Finite games can illustrate all EPDL-related notions. A finite game of two plays A and B is a tuple (P, MA, MB, F ) where
P is a nonempty finite set of positions,
MA, MB ⊆ P × P are (possible) moves of A and B,
F ⊆ P is a set of final positions.
A session of the game is a sequence of positions s0, ...sn, ... where all even pairs are moves of one player (ex., all (s2i, s2i+1) ∈ MA) while all odd pairs are moves of another player (ex., all (s2i+1, s2i+2) ∈ MB). A pair of consequentive moves of two players in a session comprises three consequentive positions (ex., (s2i,s2i+1,s2(i+1)) is called a round. A player loses a session iff after a move of the player the session enters a final position for the first time. A player wins a session iff another player loses the session. A strategy of a player is a subset of the player’s possible moves. A winning strategy for a player is a strategy of the player which always leads to the player’s win: the player wins every session which he/she begins and in which he/she implements this strategy instead of all possible moves. Every finite games (P, MA, MB,F ) of the above kind can be presented as a finite Kripke structure G(P,MA,MB,F ) in a natural way:
states are positions P ,
action variables moveA and moveB are interpreted as MA and MB,
a propositional variable fail is interpreted as F .
Proposition 3.1 Let (P, MA, MB,F ) be a finite game of two players, let
WIN0 be a formula false, and for every i ≥ 1 let WINi+1 be a formula
¬fail ∧ ⟨moveA⟩(¬fail ∧ [moveB](fail ∨ WINi)).
For every i ≥ 0 the formula WINi is valid in those states of G(P,MA,MB,F )
where a player A has a wining strategy with i-rounds at most.
For every i > 0 a first step of every i-rounds at most wining strategy for a player A consists in a move to a position where ¬fail ∧ [moveB](fail ∨ WINi−1) is valid.
Let an infinite disjunction  i≥0 WINi with semantics  i≥1{s : s |=M WINi}
in a model M be a special extension of EPDL.
An infinite disjunction  i≥0 WINi is valid in those states of G(P,MA,MB,F )
where a player A has a wining strategy.
An infinite disjunction i≥0 WINi is illegal formula of EPDL and is not equivalent to any formula of EPDL.
The proposition 3.1 leads to the following suggestion naturally. Let us define
the propositional µ-Calculus as an extension of EPDL by two new features:

if p is a propositional variable and φ is a formula then (µp.φ) and (νp.φ) are formulae 6 . We would like also to impose the following context-sensitive restriction: No bounded instance of a propositional variable can be negative.
Informally speaking µp.φ is an “abbreviation” for an infinite disjunction
false ∨ φp(false) ∨ φp(φp(false)) ∨ φp(φp(φp(false))) ∨ ... =   φi (false)
i≥0
while νp.φ is an “abbreviation” for another infinite conjunction
true ∧ φp(true) ∧ φp(φp(true)) ∧ φp(φp(φp(true))) ∧ ... =   φi (true),
i≥0
where φp(ψ) is a result of substitution of ψ instead of p in φ, φ0(ψ) is ψ, and φi+1(ψ) is φp(φi (ψ)) for i ≥ 0.	In spite of informal character of the
p	p
above semantics basically the formal one in finite models is just the same. For
every finite model M = (DM , IM ) the validity relation |=M between states and formulae of EPDL can be extended on formulae of µC as follows:
s |=M (µp.φ) iff s |=M φi (false) for some i ≥ 0;
s |=M (νp.φ) iff s |=M φi (true) for every i ≥ 0. In particular, if φ is a formula
¬fail ∧ ⟨moveA⟩(¬fail ∧ [moveB](fail ∨ win))
where win is a propositional variable, then the formula WIN0 is just false ≡

0
win
(false), while WINi+1 (i ≥ 0) is



φi+1(false) ≡  ¬fail ∧ ⟨moveA⟩(¬fail ∧ [moveB](fail ∨ φi
(false))).

win	win
Thus in terms of µC the proposition 3.1 can be reformulated as follows:
Proposition 3.2 Let (P, MA, MB,F ) be a finite game of two players and let
WIN be a formula µ win. ¬fail ∧ ⟨moveA⟩(¬fail ∧ [moveB](fail ∨ win)) .

For every i ≥ 0 the formula WINi
(false) is valid in those states of

G(P,MA,MB,F ) where a player A has a wining strategy with i-rounds at most.
For every i > 0 a first step of every i-rounds at most wining strategy for a player A consists in a move to a position where ¬fail ∧ [moveB](fail ∨ WINi−1(false)) is valid.
A formula WIN is valid in those states of G(P,MA,MB,F ) where a player A
has a wining strategy
A formula WIN is not equivalent to any formula of EPDL.

6 which are read as “mu/nu p φ” or “the least/greatest ﬁxpoint p of φ” respectively

Towards Metaprogram via Model Checking
Now we are ready to formalize a parameterized game GAME(N, M ).
Positions in this game are tuples (U, L, H, V, Q) where
U is a set of coin numbers in [(M + 1)..(M + N )] which are currently under question but which were not tested against other coins;
L is a set of coin numbers in [(M + 1)..(M + N )] which are currently under question but which were tested against other coins and turned to be lighter ;
H is a set of coin numbers in [(M + 1)..(M + N )] which are currently under question but which were tested against other coins and turned to be heavier ;
V is a set of coin numbers in [1..(N + M )] which are currently known to be
valid ;
Q is a current balancing query, i.e. a pair of disjoint subsets of [1..(N + M )] of equal cardinality.
Positions should meet some natural constraints listed below:
U ∪ L ∪ H /= ∅, since there is a false coin,
U , L, H and V form a disjoint cover of [1..(N + M )],
U /= ∅ iff L ∪ H = ∅, since
a false is among untested coins iff all previous balancings gave equal weights,
if Q = (S1, S2) then either S1 ∩ V = ∅ either S2 ∩ V = ∅, since
it is not reasonable to add extra valid coins on both pans of a balance.
A final position is a position (U, L, H, V, (∅, ∅)) with |U| +|L| +|H| = 1. A possible move of a player prog is a query for balancing two sets of coins,
i.e. pair of positions

prog
(U, L, H, V, (∅, ∅)) −→ (U, L, H, V, (S1, S2))

where S1 and S2 are disjoint subsets of [1..(N + M )] with equal cardinalities.
A possible move of a player user is a reply <, = or > for a query which causes position change

(U, L, H, V, (S ,S )) −us→er (U', L', H',V ', (∅, ∅))
1	2

in accordance with the query and a reply <, = or >. We would not like to present a complete (while concise) definition for −us→er . In contrast we would like to give some intuition behind it. For it let us represent S1 as U1 ∪L1 ∪H1 ∪V1 and S2 as U2 ∪ L2 ∪ H2 ∪ V2 respectively, where U1,2 ⊆ U , L1,2 ⊆ L, H1,2 ⊆ H, V1,2 ⊆ V . Since U /= ∅ iff L ∪ H = ∅, then there are two disjoint cases: U = ∅ XOR L∪ H = ∅. Let us consider the first one only since the second is similar.

In this case U1 = U2 = U' = ∅ and



either in L1

and is lighter either it is in H2
and is heavier;

L' =
 (L \ (L1 ∪ L2)) if the reply is = , since in this case a false coin is

neither in L1 or L2 neither it is in H1 or H2;


	either in L2 and is lighter either it is in H1 and is heavier;



either in L1

and is lighter either it is in H2
and is heavier;

H' =
 (H \ (H1 ∪ H2)) if the reply is = , since in this case a false coin is

neither in L1 or L2 neither it is in H1 or H2;


	either in L2 and is lighter either it is in H1 and is heavier.
Here a game and a corresponding concrete model are done.
Model checking [8] is a testing a model against a formula. Models for logics which are under consideration in the paper are Transitions Systems or Kripke Structures where states of a system are presented as nodes of a graph but transitions between states are presented as labeled edges. The global (model) checking problem consists in a calculation of the set of all states of an input model where an input formula is valid, while the local (model) checking consists in testing the validity of an input formula in an input state of an input model. We are especially interested in model checking problem for finite models. For these models both model checking problems are polynomially equivalent so we would not like to distinguish them for finite models. More important topic are parameters used for measuring complexity. If M = (DM , (RM , PM )) is a finite model then let dM , rM and mM be amount of states in DM , amount of edges in RM and (dM + rM ) respectively. If a model M is implicit then we would like to use these parameters without subscripts, i.e. just d, r and m. If φ is a formula then let fφ be a size of φ as a string. If a formula φ is implicit then we would like to use this parameter fφ without subscript, i.e. just f . Best known model checking algorithms for the µ-Calculus and finite models are exponential. For example,
O(m × f ) × m × f a−1
is a time bound of Faster Model Checking Algorithm (FMC-algorithm) [10], where an alternating depth a of a formula is a maximal amount of alternations

in nesting µ and ν with respect to the syntactical dependences and formally is defined by induction. We would like to point out that the alternating depth is always less then or equal to the nesting depth of fixpoints for every formula. In particular, the a complexity of model checking a fixed input formula WIN in an input model is linear in a size of the model.
In terms of model checking a preliminary high-level design for the metapro- gram problem is quite simple:
(a) input integers N , M and K;
set player A be prog and player B be user;

check formula WINK
in GAME(N, M );

if ([(M + 1)..(M + N )], ∅, ∅, [1.. M ], (∅, ∅)) |=GAME(N,M) WINK	,
then go to (ii), else - output an impossibility of a strategy and halt;
output a program, which first check formulae ¬fail ∧ [moveB](fail ∨

i win
(false)) for i ∈ [0..(K − 1)] in GAME(N, M ) and then has the

following loop for i ∈ [1..K] downwards: output a move to a position
where a formula ¬fail ∧ [moveB](fail ∨ WINi−1(false)) holds, input <,
= or > and define a next position in accordance with it.
In accordance with proposition 3.2 this design is correct. Concrete models are quite good from pure mathematical viewpoint and an idea to implement, plug and play the above preliminary design seems to be natural. Sorry, concrete models are too large from viewpoint of computer science since amounts of possible positions and possible moves are exponential functions of N .

Towards Metaprogram via Abstraction
Now we are ready to discuss a new abstract model game(N,M) for a parame- terized GAME(N, M ). A hint how to solve the metaprogram problem is quite easy: consider amounts of coins instead of coin numbers. This idea is natu- ral: when somebody is solving puzzles he/she operates in terms of amounts of coins of different kinds not in terms of their numbers!
Positions in game(N, M ) are tuples (u, l, h, v, q) where
u is an amount of coins in [1..N ] which are currently under question but which were not tested against other coins;
l is an amount of coins in [1..N ] which are currently under question but which were tested against other coins and turned to be lighter ;
h is an amount of coins in [1..N ] which are currently under question but which were tested against other coins and turned to be heavier ;
v is an amount of coins in [1..(N + M )] which are currently known to be
valid ;
q is a balancing query, i.e. a pair of quadruples ((u1, l1, h1, v1), (u2, l2, h2, v2)) of numbers of [1..(N + M )].

Five constraints are closely relate to constraints for the GAME(N, M ): (1)u+
l + h ≤ N , (2)u + l + h + v = N + M , (3)u + l + h ≥ 1, (4)u /=0 iff l + h = 0,
(5)v1 = 0 or v2 = 0. Additional but natural constraints should be imposed for queries (since we can borrow coins for weighing from available untested, lighter, heavier and valid ones): (6)u1 + u2 ≤ u, (7)l1 + l2 ≤ l, (8)h1 + h2 ≤ h,
(9)v1 + v2 ≤ v, (10)u1 + l1 + h1 + v1 = u2 + l2 + h2 + v2.
A final position is a position (u, l, h, v, ((0, .., 0), (0, .., 0))) with u+l+h = 1. A possible move of a player prog is a query for balancing two sets of coins,
i.e. pair of positions
prog
(u, l, h, v, ((0, 0, 0, 0), (0, 0, 0, 0))) −→ (u, l, h, v, ((u1, l1, h1, v1), (u2, l2, h2, v2))).
A possible move of a player user is a reply <,= or > for a query which causes position change
(u, l, h, v, ((u ,l ,h ,v ), (u ,l ,h ,v ))) −us→er

1  1	1	1
2  2	2
2
−us→er (u', l', h', v', ((0, 0, 0, 0), (0, 0, 0, 0)))

in accordance with the query and a reply:



u' =
 (u − (u1 + u2)) if the reply is = ,

 0 if the reply is > ,



l' =
 (l − (l1 + l2)) if the reply is = ,

 (l2 + u2) if the reply is > ,

h'  =  (h − (h + h )) if the reply is = ,
1	2
 (h1 + u1) if the reply is > ,
v' = ((N + M ) − (u' + l' + h')).
Thus a new game and a corresponding abstract model are done. An overall amount of possible position moves in game(N, M ) is less than (N+1)6 .
What is an utility of abstraction? In general, let Φ be a set of formulae, M1 = (D1, I1) and M2 = (D2, I2) be two models, and g : D1 → D2 be a mapping. The model M2 is called an abstraction of the model M1 with respect to formulae Φ iff 7 for every formula φ ∈ Φ and every state s ∈ D1 the following holds: s |=1 φ ⇔ g(s) |=2 φ. In particular, let us consider

7 g is called an abstraction mapping in this case.

models Game(N, M ) and game(N, M ) (N ≥ 1, M ≥ 0) and define a counting
mapping count : DGAME(N,M) → Dgame(N,M) as follows:
count : (U, L, H, V, (S1, S2)) '→(|U |, |L|, |H|, q)
where q is
((|S1 ∩ U|, |S1 ∩ L|, |S1 ∩ H|, |S1 ∩ V |), (|S2 ∩ U|, |S2 ∩ L|, |S2 ∩ H|, |S2 ∩ V |)).
This counting mapping can be component-withe extended on pairs of posi- tions. It is straightforward that the counting mapping is a homomorphism of a labeled graph GAME(N, M ) onto another labeled graph game(N, M ) with the following property for every position POS in the GAME(N, M ): count maps all moves of a player which starts/finishes in the position onto moves of the same player in the game(N, M ) which starts/finishes in count(POS). It immediately implies that a model game(N, M ) is an abstraction of another model GAME(N, M ) with respect to formulae of the µ-Calculus written with use of the unique free propositional variable fail and two action variables moveuser and moveprog only.
Now we are ready to revise a preliminary high-level design and present an abstraction-based version of a final high-level design for the metaprogram:
(a) input integers N , M and K;
set player A be prog and player B be user;

check formula WINK
in game(N, M );

if (N, 0, 0, M, ((0, .., 0), (0, .., 0)) |=game(N,M) WINK	,
then go to (ii), else - output an impossibility of a strategy and halt;
output a program, which first check formulae ¬fail ∧ [moveB](fail ∨

i win
(false)) for i ∈ [0..(K − 1)] in game(N, M ) and then has the

following loop for i ∈ [1..K] downwards: output a move to a posi-
tion POS such that count(POS) |=game(N,M) ¬fail ∧ [moveB](fail ∨ WINi−1(false)), input <, = or > and define a next position in accor- dance with it.
Correctness of the final high-level design follows from the proposition 3.2, since
game(N, M ) is an abstraction of GAME(N, M ). – Implement, plug and play!
Testing model checkers via games
An importance of teaching program logics and model checking discussed above in section 2 is based on importance of model checking applications. The main area of a model-checking applications is automatic verification of hard- and software presented as finite state systems [8]. New application domains include verification of high-level software specifications [4] automatic test generation [14], etc. We suppose that in all cases a high-level reliability of model checkers is of extreme importance due to an automatic character of model checking.

But in spite of importance of reliability issues of verification tools there are weak moves only in the formal verification community. Let us discus some of reasons of this situation with reliability. First, in automated deduction a reliability problem can most likely be solved by coupling a prover with a proof checker so that the prover will be required to make proofs that can be checked by the proof checker. This approach seems reasonable due to its simplicity and since proofs are relatively short in a comparison with the size of a system to be verified, while proof checking has a linear complexity. Next, the most popular model checkers SMV [5] and SPIN [16] are model checkers for temporal logics, i.e., they use fixpoints on a metalevel only and so that all inner fixpoints are independent of outer ones. In this case model checking algorithms are quite simple and transparent [8].
Unfortunately, both above reasons are invalid for model checkers of the µ- Calculus in finite models. An approach “a la” theorem proving is impossible due to an exponential complexity of model checking “proofs”. Simultaneously, a natural transparency of model checking for temporal logics is lost due to a complicated interaction of alternating nesting fixpoints. So we foresee only three reasonable approaches to reliable model checking for the µ-Calculus in finite models:
simultaneous polyvariant model checking,
preliminary extensive testing of model checkers,
formal verification of model checkers.
Due to complexity reasons mentioned above, a polyvariant approach to reliable model checking is time, space and cost expensive. The second approach seems to be problematic also since test-generation is a non-trivial problem itself. This problem is discussed in brief in the next paragraph. As far as a formal verification is concerned, then let us point out on a recent paper [22], where an automatically generated from a proof model checker is reported. To the best of our knowledge it is the first and unique paper on formally verified model checkers. This verified model checker is an implementation on Caml of a model checking algorithm from [26], it is generated by an interactive logic framework Coq from a formally presented proof of correctness of the algorithm.
Why an extensive testing of model checkers for the µ-Calculus in finite models is a non-trivial problem? Because overall test suits for a model checker must be transparent, must have predictable results and simultaneously should exploit a non-trivial combinations of fixpoints. But these two claims are mu- tually exclusive. May be the most appropriate solution for an overall testing of model checkers is to test them against a formally verified model checker on automatically generated test suits.
A problem domain of finite games seems to be the best choice for manual overall testing of model checkers, since it comprises understandability of for- mulae and verifiability of results. A correctness in this case can be checked manually or by means of implementing program robots for players simulation.

Below we present 3 examples of parameterized finite games which were in use for manual testing of model checkers for the µ-Calculus and finite models in a specification and verification project REAL [18,19,20]. We used parameter- ized games for tracking how model checkers react on model size.
The first example is called “Game in Numbers”.
The game is played between two player, Spoiler and Duplicator. Positions are integers between 1 and N or the fault(≥ N ). Duplicator starts by picking an initial position. Then Spoiler and Duplicator by turns make moves in accordance to the following rule: from a position i a next position can be i or i + 10. Duplicate wins as soon as Spoiler moves to the fault position, Spoiler wins as soon as Duplicator moves to the fault position. Problem: Define all initial positions with a winning strategy for Duplicator.
Another example is called “Millennium Game”.
On the eve of New Year 19NM (N, M ∈ [0..9]) Alice and Bob played the millennium game. Positions in the game were dates of 19NM-2000 years. The initial position was a random date from this interval. Then Alice and Bob made moves in their turn: Alice, Bob, Alice, Bob, etc. Available moves were one and the same for both Alice and Bob: if a current position is a date then the next calendar date and the same day of the next month are possible next positions. A player won the game iff his/her counterpart was the first who launched the year 2000. Problem: Define all initial positions with a winning strategy for Alice.
The third example is a metaprogram problem described in the section 2. We would like to remark here that all above examples deal with formulae
WIN and WINi	(false) for i ≥ 0.


Conclusion
The paper presents some non-standard experience with model checking and discusses how regular teaching, training for programming contests and im- plementation of verification tools can go hand-in-hand with each-other, with model checking and game theory. Simultaneously it is an expression of a strong belief of authors that
there exists a deficit of popular lectures, tutorials and papers on the topics related to foundations of formal methods;
challenging programming problems are a good chance for better education and popularization of foundations of formal methods;
computer science journals and magazines should promote popularization of formal methods foundations.

References
Bradfield J.C., and S. Stirling Local Model Checking for Inﬁnite State Spaces, Theoretical Computer Science, 96 (1992), 157-174.
Berezine S.A., and N.V. Shilov An approach to effective model-checking of real- time ﬁnite-state machines in Mu-Calculus, Lecture Notes in Computer Science, 813 (1994), 47-55.
Bull R.A., and K. Segerberg Basic Modal Logic, in “Handbook of Philosophical Logic”, v.II, Kluwer Academic Publishers, 1994 (2-nd ed.), 1-88.
Bultan T., R. Gerber, and W. Pugh Model-Checking Concurrent Systems with Unbounded Integer Variables: Symbolic Representation, Approximation, and Experimental Results, ACM Trans. on Prog. Lang. and Syst., 21 (1999), 747- 789.
Burch J.R., E.M. Clarke, K.L. McMillan, D.L. Dill, and L.J. Hwang Symbolic Model Checking: 1020 states and beyond, Information and Computation, 98 (1992), 142-170.
Burkart O. “Automatic Verification of Sequential Infinite-State Processes”, Lecture Notes in Computer Science 1354, Springer-Verlag, 1997.
Burkart O., and B. Steffen Model-Checking the Full Modal Mu-Calculus for Inﬁnite Sequential Processes, Lecture Notes in Computer Science, 1256 (1997), 419-429.
Clarke E.M., O. Grumberg, and D. Peled “Model Checking”, MIT Press, 1999.
Cleaveland R. Tableaux-based model checking in the propositional Mu-Calculus, Acta Informatica, 27 (1990), 725-747.
Cleaveland R., M. Klain, and B. Steffen Faster Model-Checking for Mu-Calculus, Lecture Notes in Computer Science, 663 (1993), 410-422.
Dam M., L. Fredlund, and D. Gurov Toward Parametric Veriﬁcation of Distributed Systems, Lecture Notes in Computer Science, 1536 (1998), 150- 185.
Emerson E.A., C.S. Jutla, and A.P. Sistla On model-checking for fragments of Mu-Calculus, Lecture Notes in Computer Science, 697 (1993), 385-396.
Fagin R., J.Y. Halpern, Y. Moses, and M.Y. Vardi “Reasoning about Knowledge”, MIT Press, 1995.
Gargantini A., and G. Heitmeyer Using Model Checking to Generate Tests from Requirements Speciﬁcations, ACM SIGSOFT Software Engineering Notes, 24 1999, 146-162
Harel D. “First-Order Dynamic Logic”, Lecture Notes in Computer Science,
68, Springer-Verlag, 1979.


Holzmann G.J., and D. Peled The state of spin, Lecture Notes in Computer Science, 1102 (1996), 385-389.
Kozen D. Results on the Propositional Mu-Calculus, Theoretical Computer Science, 27 (1983), 333-354.
Nepomniaschy V.A., and N.V. Shilov Real92: A combined speciﬁcation language for systems and properties of real-time communicating processes, Lecture Notes in Computer Science, 735 (1993), 377-393.
Nepomniaschy V.A., N.V. Shilov, and E.V. Bodin A new language Basic-REAL for speciﬁcation and veriﬁcation of distributed system models, A.P. Ershov’s Institute of Informatics Systems, preprint 65, Novosibirsk, 1999 (also available at URL: http://www.iis.nsk.su/bre/bre99/bre99 ps.zip).
Nepomniaschy V.A., N.V. Shilov, and E.V. Bodin Speciﬁcation and Veriﬁcation of Distributed System by means of Elementary-REAL language, Programming and Computer Software, 25 (1999), 222-232.
N.V. Shilov and K. Yi, Program Logics Made Easy, Korea Advanced Institute of Science & Technology, ROPAS Technical Memo No. 2000-7, URL: http://ropas.kaist.ac.kr/lib/doc/ShYi00.ps.gz.
Sprenger C. A veriﬁed Model Checker for the Modal mu-Calculus in Coq, Lecture Notes in Computer Science, 1384 (1998) 167-183.
Steven P., and C. Stirling Practical Model Checking Using Games, Lecture Notes in Computer Science, 1384 (1998), 85-101.
Stirling C. Local Model Checking Games, Lecture Notes in Computer Science,
962 (1995), 1-11.
Stirling C. Games and Modal Mu-Calculus, Lecture Notes in Computer Science,
1055 (1996), 298-312.
Winskel G. A note on model checking the modal µ-calculus, Theoretical Computer Science, 83 (1991), 157-167.
