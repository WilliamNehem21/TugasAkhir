Electronic Notes in Theoretical Computer Science 120 (2005) 17–30  
www.elsevier.com/locate/entcs


Hyperbolic Julia Sets are Poly-Time Computable

Mark Braverman1 ,2
Dept. of Computer Science University of Toronto Toronto, ON, Canada


Abstract
In this paper we prove that hyperbolic Julia sets are locally computable in polynomial time. Namely, for each complex hyperbolic polynomial p(z), there is a Turing machine Mp(z) that can “draw”
the set with the precision 2−n, such that it takes time polynomial in n to decide whether to draw each pixel. In formal terms, it takes time polynomial in n to decide for a point x whether d(x, Jp(z)) < 2−n (in which case we draw a pixel with center x), or d(x, Jp(z)) > 2·2−n (in which case we don’t draw this pixel). In the case 2−n ≤ d(x, Jp(x)) ≤ 2 · 2−n either answer will be acceptable. This definition of complexity for sets is equivalent to the definition introduced in Weihrauch’s book
[16] and used by Rettinger and Weihrauch in [13].
Although the hyperbolic Julia sets were shown to be recursive, complexity bounds were proven only for a restricted case in [13]. Our paper is a significant generalization of [13], in which polynomial time computability was shown for a special kind of hyperbolic polynomials, namely, polynomials of the form p(z)= z2 + c with |c| < 1/4.
We show that the machine drawing the Julia set can be made independent of the hyperbolic polyno-
mial p, and provide some evidence suggesting that one cannot expect a much better computability result for Julia sets.
We also introduce an alternative real set computability definition due to Ko, and show an interesting connection between this definition and the main definition.
Keywords: computable analysis, Julia sets, computational complexity, complex dynamics.



1 Research is partially supported by the Natural Sciences and Engineering Research Council of Canada.
2 Email: mbraverm@cs.toronto.edu


1571-0661 © 2005 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2004.06.031

Introduction

Nowadays, computers are being increasingly applied to represent mathemat- ical objects. Computer-generated images are being extensively used in the analysis and simulations of real-life processes and their mathematical models. Our goal is to investigate a formal framework which allows us to define the computational complexity of real sets, measuring the complexity of drawing the set on a computer. Within this framework, we obtain a new result on the computability of Julia sets.
We mainly use the definition of real set complexity introduced by Weihrauch in [16] and used in [13] as the measure of complexity of some Julia sets (see also [2]).
In sections 2 and 3 we present two different definitions of computability of real sets that have been proposed, and show that they are equivalent if and only if P=NP, a result of independent interest. Theorem 3.3 can be used to prove computability of many sets for which a direct proof of computability would be hard.
Julia sets are some of the best known illustrations of a highly complicated chaotic system generated by a very simple mathematical process. These sets have been deeply studied in the framework of complex dynamics during the last century. Julia sets are not only an intriguing mathematical object, but also a major source of amazing images. Many computer programs, some of which are freely available on the web, have been written to generate these images. Algorithms for computing Julia sets have been presented and discussed in [11] and [14], for example.
It appears, however, that none of the algorithms or their implementations cope well with zooming in. With the computer using fixed-precision numbers, rounding errors significantly affect the computation when we try to zoom in. These programs also seem to work poorly near some “pathological” polyno- mials, for example, with p(z) = z2 + 1/4+ ε, 0 < ε  1. We will return to this example in section 8.
We give the first polynomial bound on the complexity of an arbitrary hyperbolic Julia set. The class of hyperbolic polynomials is very rich. For example, in the case p(z) = z2 + c, p(z) is hyperbolic for all c’s outside the Mandelbrot set. It is conjectured that it is also hyperbolic for all c’s in the interior of the Mandelbrot set (but not on the boundary), see [9] for more information. The algorithm is outlined in sections 6 and 7. The details of the construction are mathematically involved, and many of them had to be omitted due to space constraints.
The algorithm that we present is not uniform in p(z). That is, the Turing



Fig. 1. The Mandelbrot set with the point c = 1/4 highlighted.
Machine computing Jp(z) depends on p(z). However, in section 8 we will show that no uniform Turing Machine computing Jp(z) exists. Our algorithm can be modified to be uniform in the hyperbolic p(z)’s, and such a modification will remain polynomial in the precision of the computation, but might be arbitrarily hard in the polynomial p(z). Explicitly, we obtain a bound of K(p) · nM (n) on the running time, where K(p) is a coefficient depending on the polynomial, 2−n is the required precision and M (n) is the complexity of multiplying two n-bit numbers.
It should be noted that the model of computation we are using is very different from the BCSS model presented in [1]. It has been shown that most Julia sets are not computable in that model (see [1] for more details).
The results of the paper can be easily generalized from hyperbolic poly- nomials to hyperbolic rational functions, and are very similar to the results obtained independently in [12].

Computability and Complexity of Bounded Subsets of R2
Several different computability notions for subsets of the real numbers have been proposed. It has been shown, for example, that non-trivial Julia sets are not computable in the real-RAM model (see [1]). We will use a different model introduced by Klaus Weihrauch in [16] and described in [13]. This is a very natural model when one is concerned with the complexity of “drawing” a set on the computer.
Intuitively, the definition says that the computational complexity of a set S is t(n) if we can decide whether to draw a pixel of size 2−n in the picture of S in time t(n). To make this notion precise, we have to decide what are our expectations from a picture of S. First of all, we expect a good picture of S to cover the whole set S. On the other hand, we expect every point of the picture to be close to some point of S, otherwise the picture would have no descriptive power about S. Mathematically, we write these requirements as follows:

Definition 2.1 A set T is said to be a 2−n-picture of a bounded set S if
S ⊂ T , and (ii) T ⊂ B(S, 2−n)= {x ∈ R2 : |x − s| < 2−n for some s ∈

S}.

Requirement (ii) can be also written as dH(S, T ) ≤ 2−n, where dH is the

Hausdorff distance, defined by
dH(S, T ) := inf{r : S ⊂ B(T, r) and T ⊂ B(S, r)}.
Suppose we are trying to generate a 2−n-picture of a set S using a union of round pixels of radius 2−n−2 with centers at all the points of the form
 i ,  j  , with i and j integers. In order to draw the picture, we have to
2n+2  2n+2		 
or not. We want to draw the pixel if it intersects S and to omit it if some neighborhood of the pixel does not intersect S. Formally, we want to compute a function
 1,	B((i/2n+2, j/2n+2), 2−n−2) ∩ S /= ∅
fS (n, i/2n+2, j/2n+2)=  0,	B((i/2n+2, j/2n+2), 2 · 2−n−2) ∩ S = ∅	(∗)
 0  or  1,	in all other cases

Fig. 2. Sample values of f . The radius of the inner circle is 2−n−2.
Lemma 2.2 The picture drawn according to fS(n, •) is a 2−n-picture of S.
Here • stands for the different values of the parameters (i/2n+2, j/2n+2). The lemma illustrates the tight connection between the complexity of “draw- ing” the set S and the complexity of computing f . In order to reflect this connection we define the time complexity of S as follows.
Definition 2.3 A bounded set S is said to be computable in time t(n) if there is a function f (n, •) satisfying (∗) which runs in time t(n). We say that S is


poly-time computable if there is a polynomial p, such that S is computable in time p(n).
This definition is easily seen to be equivalent to the definition introduced in [16] and used in [13]. We will show that hyperbolic Julia sets are poly-time computable under this definition.

An Alternative Computability Definition – Ko P- Computability
We present an alternative definition of poly-time computability for sets in R2, which was introduced by Arthur W. Chou and Ker-I Ko in [4] (see also [8]). While it is not equivalent, and is generally weaker than the definition we are using, it is still very useful due to a connection with our definition we present below.
In the model below we give x as an oracle to the machine which tries to decide whether x ∈ S. By an oracle we mean a “black box” function φ that on input n outputs a binary approximation φ(n) ∈ D2 with |φ(n) − x| < 2−n. Here D denotes the set of the dyadic numbers D = {k/2l : k ∈ Z,l ∈ N}. Querying the oracle takes one time unit. A set is said to be strongly P - recognizable if there is an oracle Turing Machine, that on input x outputs 1 if x ∈ S and 0 if x is 2−n-far from S, i.e. the machine is allowed to make small one-sided errors. The definition was presented in [4] under the name of strong P-recognizability, we call it Ko P-computability to avoid confusion due to the fact that this definition is actually weaker than the other definition of computability that we are using. We summarize,
Definition 3.1 A set S is said to be Ko P-computable if there is an oracle TM Mφ(n) which runs in time polynomial in n, and outputs: (i) 1, if φ represents a point x ∈ S, (ii) 0, if φ represents a point x ∈/ B(S, 2−n), (iii) 0 or 1, otherwise.
We can prove the following result, giving a simple complexity-theoretical connection between Ko P-computability and poly-time computability. See [3] for the proof.
Theorem 3.2 Every poly-time computable set S is Ko P-computable. The converse statement (i.e. “every Ko P-computable set S is poly-time com- putable”) holds if and only if P = NP.
The following theorem makes the notion of Ko P-computability useful in the context of computing sets, in particular Julia sets. It states that Ko P-computable sets are exponential-time computable.


Theorem 3.3 Suppose that a set S is Ko P-computable by a machine Mφ(n) running in time p(n). Moreover, suppose that on input n, Mφ uses at most l(n) ﬁrst bits of x from the oracle. Then S is computable in time t(n)= p(n)· 2O(l).
To prove this theorem one combines the proof of the ‘if’ direction in the- orem 3.2 with the brute force algorithm for NP-problems, which leads to an exponential upper bound on the computation time.

Julia Sets and Hyperbolic Julia Sets
We will give one of the equivalent definitions of the hyperbolic Julia set. More detailed information, as well as proofs and further references can be found in
[9] and [10]. [10] gives a particularly good exposition of the hyperbolic Julia sets.
For the rest of the paper we fix our polynomial to be p(z). Note that p(z) is a polynomial with complex coefficients. Let pk(z) denote the k-th iteration of p(z), i.e. p1(z)= p(z) and pk+1(z)= p(pk(z)). By a convention, p0(z)= z. We define the orbit of z as the sequence (z, p(z), p2(z),.. .). A point z is called periodic if pk(z)= z for some k ≥ 1. The minimal such k is called the period of z. A periodic point z with period k and its (finite in this case) orbit (z, p(z),... , pk−1(z)) are said to be attracting if |(pk)'(z)| < 1 and repelling if |(pk)'(z)| > 1. Intuitively, if we iterate a point in the neighborhood of an attracting periodic point, then we will approach the attracting orbit, while if we iterate a point in the neighborhood of a repelling periodic point, we will escape the neighborhood. We say that a point c is a critical point of p(z) if p'(c) = 0. We are now ready to state one of the equivalent definitions of a hyperbolic polynomial.
Definition 4.1 A polynomial p(z) of degree ≥ 2 is said to be hyperbolic if every critical point of p(z) converges to an attracting periodic orbit of p(z) or to ∞.
Here we include ∞ as a special case to simplify matters, but in fact, by considering the Riemann sphere instead of the complex plane, we can regard
∞ as an attracting periodic point of p(z), since we have p(∞) = ∞ and limn→∞ |pn(z)| = ∞ for |z| large enough.
We can now give a simple definition of the Julia set in the hyperbolic case. See [10] for a proof that in the hyperbolic case this definition is equivalent to the general definition of the Julia set.
Definition 4.2 The Julia set Jp of a hyperbolic polynomial p(z) is the set of all points w, such that the orbit of w does not converge to an attracting

periodic orbit of p(z) or to ∞. The complement of the Julia set is denoted
Kp = Jc and is called the Fatou set of the polynomial p(z).
As we have mentioned above, the class of the hyperbolic polynomials is extremely robust. In particular, z2 + c is hyperbolic for all c’s outside the Mandelbrot set M , and is believed to be hyperbolic for all the c’s in the interior of M (see fig. 1). We summarize the most important facts about hyperbolic Julia sets we will be using in the following lemma. See [10] for details and proofs.
Lemma 4.3 For a hyperbolic polynomial p(z) the following facts hold:
The interior of Jp is empty.
Jp = p(Jp)= p−1(Jp).
p(z) has at most deg(p) − 1 attracting periodic orbits (regarding an orbit as a set).
The definition itself gives a very naive “algorithm” for computing Jp. Namely, set a threshold T . To determine whether a point w is in Jp com- pute the first T elements of the orbit of w, p(w), p2(w),... , pT (w). If the orbit gets close to one of the attracting orbits, say that w ∈/ Jp, otherwise say that w ∈ Jp. In fact, many of the computer programs that draw Julia sets use this method. The problem, of course, is how to choose a good T and how to define “close”. If T is not chosen properly, we might reject w’s which are very close to Jp or accept w’s which are far away from Jp. We will have to develop more theory in order to choose T which makes the method above work properly. The tool which we will use to control the distance between w and Jp is one of the fundamental tools in complex dynamics, called the Poincar´e metric.

The Poincar´e Metric
The Poincar´e metric, known also as the hyperbolic metric, is a metric which naturally arises on hyperbolic Riemann surfaces. It is beyond the scope of this paper to discuss the metric in full generality, so we will restrict our attention to subsets of the complex plane C. See [10] for a more comprehensive exposition. It is known that any connected open subset S ⊂ C of the complex plane which omits at least 2 points is a hyperbolic Riemann surface and has a unique (up to a multiplication by a constant) Poincar´e metric dS. We call these subsets of C hyperbolic sets.
To define the Poincar´e metric, we first need to describe another funda- mental mathematical concept – the notion of a covering map. While covering maps are defined in many different topological settings, we will define it for our case: the hyperbolic subsets of C. A map f : X → Y between two hy-


perbolic subsets of C is said to be a covering map, if for each y ∈ Y there is a neighborhood N (y) of y such that for each connected component N ' of f −1(N (y)), the map f : N ' → N (y) is a conformal (locally shape preserving) isomorphism.
In general, covering maps allow us to analyze the structure of Y using the structure of X. In particular, it is used in the definition of the Poincar´e metric. We skip the details and present only the final result we use in our case. This result can be viewed as the defining property of yhr Poincar´e metric. We refer the interested reader to [10].
Theorem 5.1 (Theorem of Pick) There is one, and up to a multiplication by a constant, only one family of metrics deﬁned on hyperbolic subsets of C such that for any hyperbolic subsets S and T of C the following holds. If f : S → T is a holomorphic map, then exactly one of the following three statements is valid:
f is a conformal isomorphism from S onto T , and maps S with its Poincar´e metric isometrically to T with its Poincar´e metric.
f is a covering map but is not one-to-one. In this case, it is locally but not globally a Poincar´e isometry. Every smooth path P : [0, 1] → S of arclength l in S maps to a smooth path f ◦ P of the same length l in T .
In all other cases, f strictly decreases all non-zero distances (in the Poincar´e metric).
For every hyperbolic set S the Poincar´e metric dS has a weight function pS : S → R+ such that pS(x) measures the ratio between dS and the Euclidean metric near the point x. Formally, the lenght of an arc γ : [0, 1] → S in dS is given by


ldS
1
(γ)= 
0
pS(γ(t))|γ'(t)|dt.

We now have the basic complex-analytic background required for the con- struction, and we are ready to prove that the hyperbolic Julia sets are poly- time computable. Note that we can view Jp as a subset of R2 using the trivial identification of C with R2.

Hyperbolic Julia Sets are Ko P-Computable
As noted above, we will present an algorithm that uses some nonuniform information, i.e. information which depends on the polynomial p(z) but not on the precision parameter n. The polynomial p(z) itself is given to the algorithm as an oracle that outputs its coefficients with any required precision. Denote


the polynomial p(z) = cmzm + cm−1zm−1 + ... + c1z + c0. We can query each ci with precision 2−r with time cost r. As per the definition of Ko P- recognizability, the input x to the algorithm is also given as an oracle. We want to decide whether x ∈ Jp.
We will now list the nonuniform information used by the algorithm. This information can be computed from the initial data (i.e. the coefficients of p(z)) as will be noted later, see theorem 8.4. We still list it as nonuniform to spare overcomplicated technical details from the reader.

Nonuniform constants information:
We summarize the nonuniform information used by the algorithms in the following lemma.
Lemma 6.1 There is an explicitly presented open set U˜ and numbers d˜ > 0,
R' > 0, d > 0, D ≥ 1, rc > 0 and an integer q, such that the following hold.
denote V˜ = p−1(U˜), then V˜ ⊂ U˜ and d(U˜c, V˜ ) ≥ d˜ ,
for any critical point yi of p, whenever |y − yi| < rc we have pq(y) ∈/ U˜,
Jp ⊂ U˜ ⊂ B(0, R'),

d is a lower bound such that |p'(z)| > d whenever |z − yi| > rc
for all

critical points yi of p,
D is an upper bound such that |p'(p(y))| < D and |p'(y)| < D/2 whenever
|y| < R'.
U˜ can be thought of a huge disk with small holes poked in it around the

attracting orbits. The orbit of each critical point eventually leaves U˜
by the

definition of hyperbolic Julia sets and this happens after at most q steps. In general, the orbit of any point outside Jp converges to one of the attracting periodic orbits, and hence eventually leaves U˜.
Denote U = p−q−1(U˜), V = p−q−1(V˜ ). Then by the definition of rc and
q, B(yi, rc) ∩ U = ∅ for any critical point yi. Lemma 4.3 implies that Jp =
p−q−2(Jp) ⊂ p−q−2(U˜)= V .
As a corollary of V˜ ⊂ U˜, we conclude that V ⊂ U , and furthermore we
can compute a lower bound dl on the distance between V and Uc.

Lemma 6.2 d(Uc,V ) ≥ dl
 d˜ 
Dq+1

U and V are obviously hyperbolic sets, and hence the Poincar´e metric is defined on them. Denote the weight function of the Poincar´e metric on U by pU and the weight function of the Poincar´e metric on V by pV . Denote the Poincar´e metrics themselves by dU and dV , respectively. We have the following simple lemma bounding the metric pU . This lemma is a simple consequence


of Pick’s theorem (theorem 5.1). We refer the interested reader to [3] for the proof of this and other technical lemmas.

Lemma 6.3 pU (z) >  2
for all z ∈ U, and pU
(z) <  2
l
for all z ∈ V .

The reason that we would like to bound V from the boundary of U is that

it would allow us to bound the ratio pV (z)
U
on V from below and bound the

diameter of V in dU from above.
We will skip the details, and only state the final results.
Lemma 6.4 pV (z) ≥ c · pU (z) > pU (z) for all z ∈ V , where c > 1 is some constant computable from dl and R' (see appendix for details and an explicit calculation of c).
The existence of c > 1 as above has been known and can be easily proven using a compactness argument. Our contribution is in constructively comput- ing such a c, which is much harder. This is particularly important for theorem 8.4, where we make the construction uniform.
Lemma 6.5 For x, y in the same connected component of V , dU (x, y) <
M	= 128R'2 .
l
Observe that by our construction V does not contain critical points of p, hence the map p : V → U is an m-fold covering map. Hence by Pick’s theorem (theorem 5.1) it is a local Poincar´e isometry. Formally, we obtain
Lemma 6.6 pV (x)= |p'(z)|· pU (p(x)) for all x ∈ V .
We see that lemmas 6.4 and 6.6 imply together that p(z) locally increases the metric pU on V . As a consequence of lemmas 6.4, 6.6 and 4.3 we obtain the following key lemma.
Lemma 6.7 Let dU (Jp, z) denote the distance between the point z and the Julia set Jp in the Poincar´e metric dU . Then dU (Jp, z) is well deﬁned for all z ∈ U and dU (Jp, p(x)) ≥ c · dU (Jp, x) for all x ∈ V , where c > 1 is a computable constant.
Lemma 6.7 gives us a tool to estimate the speed at which a point x ∈/ Jp runs away from Jp in the Poincar´e metric. If initially the Euclidean distance d(Jp, x) > ε, then by lemma 6.3, dU (Jp, x) > 2ε , and assuming that the orbit of x stays in V in s steps we have by lemma 6.7 that dU (Jp, ps(x)) > 2ε · cs. But then by lemma 6.5 we have s ≤ logc MW ' . If ε = 2−n the estimate on s is linear in n. This allows us to obtain a poly-time algorithm to Ko P-compute Jp:


Algorithm 1
Input: The non-uniform input as described above,
the input x, c0, c1,... , cm given on an oracle tape and m, n.
Output: 0 if d(Jp, x) > 2−n, 1 if x ∈ Jp, either 0 or 1 otherwise.
Compute c described above.
Compute a natural number N = O(n) such that
N ≥ 2+ logc (MW · R' · 2n−1)+ q.
Compute pN (x) within an error of d˜ .
If pN (x) ∈/ U˜, output 0,
If pN (x) ∈ V˜ , output 1,
Otherwise, output 0 or 1.
Note that given U˜, and making computations with precision d˜l/4 we can unambiguously decide if one of the possibilities 3.1 or 3.2 holds. Observe that N = O(n), so we perform linearly many operations on x, hence we require linearly many bits of x in order to achieve the required (fixed) precision level at the end of the computation. Hence by theorem 3.3 we know that Jp is computable in time poly(n) · 2O(n) = 2O(n). Algorithm 1 does not compute Jp in our definition, since it might reject points x ∈/ Jp which are very close to Jp (closer than 2−n−1). In the next section we will be referring to the exponential time algorithm computing Jp in our sense as Algorithm 1.

Jp is Poly-Time Computable
We are now ready to outline the proof of the poly-time computability of the Julia set Jp. We use the result from the previous section combined with a technique very similar to the technique used in [13] to pass from an exponential to a polynomial time algorithm. Algorithm 1 does not compute Jp because it might output 0 for points x which are not in Jp, but within a very small distance of it, while the definition of computability requires output 1 in this case. To avoid this problem we need to estimate the distance from x to Jp both from above and below. We employ techniques similar to the ones used in [13].
Lemma 7.1 There are positive constants α, β > 0 computable from the initial data such that for any z ∈ B(0, R') and 0 < ε < α satisfying d(Jp, z) ≤ ε, we have (|p'(z)|− βε)d(Jp, z) ≤ d(Jp, p(z)) ≤ (|p'(z)| + βε)d(Jp, z).
The lemma says that the change in the distance from z to Jp is locally controlled by the expansion factor |p'(z)| up to some small relative error. This enables Algorithm 2 to iterate the orbit of x keeping track of the ratio


between the distance d(Jp, pl(x)) and d(Jp, x) as long as d(Jp, pl(x)) is not too big (O(1/n)). When d(Jp, pl(x)) becomes big, we apply Algorithm 1 to estimate it. Algorithm 1 runs fast here because it needs to give an estimate with precision factor O(1/n)= O(1/2log n), so its running time is exponential in log n. Knowing an estimate of the ratio d(Jp, pl(x))/d(Jp, x) we are able to give a good estimate on d(Jp, x).
We then plug in Algorithm 2 into itself instead of Algorithm 1, to obtain Algorithm 3 which computes Jp and runs in time O(n · M (n)), where M (n) is the time complexity of multiplying two n-bit numbers. See appendix for a full exposition and pseudocode for Algorithm 2. Using the best known estimate of O(n log n log log n) on M (n) (see [7] p. 311 and [15]) we obtain
Theorem 7.2 For every ﬁxed hyperbolic polynomial p(z), the Julia set Jp is poly-time computable in time O(nM (n)) ⊂ O(n2 log n log log n).

Can the Result be Improved?
In this section we will try to address the question of whether the result of this paper can be improved, and by how much. The first question one might ask is whether there is a uniform algorithm computing Jp for an arbitrary p given as an oracle. The answer is negative. In fact, there is no such algorithm even for p of degree 2. We use the following lemma, which is very typical to computable analysis (cf. [16], p. 108, Thm 4.3.1). See section 2 for the definition of the Hausdorff metric.
Lemma 8.1 If a function f : Rm → Kn, where Kn is the set of compact sets in Rn, is computable by an oracle machine Mφ, then f is continuous in the Hausdorff metric.
We use the following lemma which follows from [5], section 11, theorem 11.3:
Lemma 8.2 The function J : c '→ Jz2+c is not continuous at c = 0.25 in the Hausdorff metric.
Lemmas 8.1 and 8.2 imply together that
Theorem 8.3 No oracle machine Mφ, where φ represents the number c, can compute the Julia set Jz2+c.
In fact, most of the programs written to draw Julia sets perform poorly for the polynomial p(z)= z2 + 0.25 + ε for small positive values of ε.
On the other hand, our construction can be made uniform over all hyper- bolic polynomials p(z). All the nonuniform information used in our construc-


tion can be extracted from the coefficients of p(z). This, however, might take indefinitely long, depending on the hyperbolic polynomial p. Hence there is an algorithm, polynomial in the precision n for computing Jp, which is uniform given that p(z) is hyperbolic. We will not prove it here. See [3] for a discussion of the main ideas of the proof.
Theorem 8.4 The Julia set Jp, where the coeﬃcients of a hyperbolic p(z) are given as oracles, can be locally computed with precision 2−n in time O(nM (n)), where the constant factor in the O(•) depends on p(z) but not on n. In other words the time complexity of locally computing Jp is bounded by K(p) · nM (n) for some K(p). Here, again, M (n) ∈ O(n log n log log n) is the complexity of multiplying two n-bit numbers.
This theorem does not contradict theorem 8.3, because it only works for hyperbolic polynomials, while the polynomial p(z)= z2 + 0.25 around which the discontinuity occurs in lemma 8.2 is parabolic and not hyperbolic. The uniform algorithm would never terminate on this input. Note that the point c = 0.25 lies on the boundary of the Mandelbrot set (see figure 1).
Further research in the area of computability of Julia sets might address the following two problems.
Problem 8.5 Are there poly-time algorithms for other types of Julia sets? In particular, are parabolic Julia sets poly-time computable?
Problem 8.6 We have seen in theorem 8.3 that the problem of computing the Julia set for a general polynomial is not computable. Is there a particular polynomial p(z) for which Jp is not computable? Is there such a polynomial p(z) with computable coeﬃcients?


Acknowledgement
I would like to thank my graduate supervisor, Prof. Stephen Cook, for his insights and support during the preparation of this paper and for the many hours we spent discussing the computability of real sets.
I would like to thank Prof. Michael Yampolsky from the Department of Mathematics in the University of Toronto for helping me to learn the complex analytic background I needed for this research, suggesting that the Poincar´e metric is a useful tool for tackling the problem and for the theoretical help he has provided during the preparation of this paper.

References
Blum, L., F. Cucker, M. Schub, S. Smale, “Complexity and Real Computation”, Springer, New York, 1998.
Brattka, V., K. Weihrauch, Computability of Subsets of Euclidean Space I: Closed and Compact Subsets, Theoretical Computer Science, 219 (1999), pp 65-93.
Braverman M., “Computational Complexity of Euclidean Sets: Hyperbolic Julia Sets are Poly- Time Computable”, Thesis, University of Toronto, 2004 (to appear).
Chou, A., K. Ko, Computational complexity of two-dimensional regions, SIAM J. Comput. 24
(1995), pp 923-947.
Douady, A., Does a Julia set depend continuously on the polynomial? Proc. Symposia in Applied Math.: Complex Dynamical Systems: The Mathematics Behind the Mandelbrot Set and Julia Sets, vol 49 (1994), ed R. Devaney (Providence, RI: American Mathematical Society) pp 91-138.
Jost, J., “Compact Riemann Surfaces”, Second edition, Springer, 2002.
Knuth, D., “The Art of Computing Programming, v. 2: Seminumerical Algorithms”, 3rd ed., Addison-Wesley, 1997.
Ko, K., Polynomial-time computability in analysis, in ”Handbook of Recursive Mathematics”, Volume 2 (1998), Recursive Algebra, Analysis and Combinatorics, Yu. L. Ershov et al. (Editors), pp 1271-1317.
McMullen, C., “Complex Dynamics and Renormalization”, Princeton University Press, Princeton, New Jersey, 1994.
Milnor, J., “Dynamics in One Complex Variable - Introductory Lectures”, second edition, Vieweg, 2000.
Pickover, C. A. (ed.), “Chaos and Fractals – Computer Graphical Journey, Ten Year Compilation of Advanced Research.” Elsevier, 1998.
Rettinger, R., A Fast Algorithm for Julia Sets of Hyperbolic Rational Functions, in CCA’04, Aug 16-20, 2004, Lutherstadt Wittenberg, Germany.
Rettinger, R., K. Weihrauch, The Computational Complexity of Some Julia Sets, in STOC’03, June 9-11, 2003, San Diego, California, USA.
Saupe, D., Efficient Computation of Julia Sets and Their Fractal Dimension. Physica D, 28
(1987), pp 358–370.
Sch¨onhage, A., V. Strassen, Schnelle Multiplikation grosser Zahlen, Computing 7 (1971), pp 281–292.
Weihrauch, K., “Computable Analysis”, Springer, Berlin, 2000.
Zhong N., Recursively enumerable subsets of Rq in two computable models: Blum-Schub-Smale machine and Turing machine. Theoretical Computer Science, 197 (1998), pp 79-94.
