	Electronic Notes in Theoretical Computer Science 175 (2007) 109–129	
www.elsevier.com/locate/entcs

Event Structure Spans
for Nondeterministic Dataflow
Lucy Saunders-Evans 1
University of Cambridge Computer Laboratory, England
Glynn Winskel 2
University of Cambridge Computer Laboratory, England

Abstract
A compositional semantics for nondeterministic dataflow processes is described using spans of event struc- tures; such a span describes a computation between datatypes, themselves represented by event structures, as itself an event structure. The spans of event structures represent certain profunctors (a generalisation of relations) used previously in a compositional semantics of nondeterministic dataflow and in the semantics of higher-order processes. Deterministic spans of event structures are shown to correspond to stable continuous functions and their semantics of dataflow to reduce to the usual least fixed-point semantics of Kahn.
Keywords: Event Structures, Spans, Nondeterministic Dataflow, Stable functions.


Introduction
A dataflow process is built as a network of more basic processes connected by channels. In particular processes may be connected to allow feedback loops from output to input.
In [6], Kahn demonstrated that a denotational semantics could be given to a dataflow network of deterministic processes as a least fixed point solution of a set of equations describing the components.
Brock and Ackerman showed in [2] that giving a semantics to nondeterministic dataflow processes was far from easy. In particular, input-output relations between sequences of values on input and output channels carry too little information about the behaviour of networks to support a compositional semantics. The following

1 Email: ls275@cam.ac.uk
2 Email: gw104@cam.ac.uk

1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2006.10.055

example is essentially that presented in [11]. Let A1 be the nondeterministic process that either outputs a token and stops, or outputs a token, waits for a token on input and then outputs another token. Let A2 be the process that either outputs a token and stops, or waits for a token on input and then outputs two tokens. The input- output relations between strings of tokens of both A1 and A2 are the same:
{(ε, t), (t, t), (t, tt)} ,
where ε represents the empty string of tokens and the presence of a token is rep- resented by the symbol t. Let F be the process that copies every input to two outputs through which the output of the process Ai is fed back to the input chan- nel. Observe that the process A1 placed in this context produces a process which can output two tokens whereas the process A2 results in a process that can only output a single token.

C[Ai]=	) Ai
)	,


 	 J
This confirms that there is no denotational semantics of nondeterministic dataflow in terms of traditional input-output relations. For similar reasons traditional uses of powerdomains also fall short.
Although traditional relations are insufficient, it was however shown in [4,5] that a compositional form of relational semantics is possible, but at the cost of moving to generalised relations called profunctors. Here we provide a representation of the stable port profunctors used in [4,5] as spans of event structures. The intention is to fit nondeterministic dataflow within a versatile theory of processes and types based on a general theory of spans of event structures [14,12].
In more recent years feedback of the kind found in dataflow has reappeared in a variety of new contexts, which are condensed in a more abstract and general formulation of the properties a feedback operation, called trace, should satisfy. Let C be a category with a symmetric monoidal structure, ⊗. A trace operation for C

is defined to be a family of operations, TrC
: C(A ⊗ C, B ⊗ C) → C(A, B). The

intuition behind this operation is illustrated in the following diagram:
A	)		)B	A	)		)B

C	)
	)C
...).......
.
.
.
.
Tr(P)
..........
.
.
.
.

.
.	
A trace operation must obey a number of axioms to ensure it behaves correctly. The reader is referred to [4,5], which this paper supplements, for the detailed axioms and fuller set of references to this rich area.

Spans of Event Structures
Event structures model a process as a set of event occurrences with relations to ex- press how events causally depend on others, or exclude other events from occurring.

Definition 2.1 An event structure is a tuple, (E, ≤, #), where:
E is a set of events;
≤ is a partial order on E. Define [e] to be {e' | e' ≤ e}. It must be the case that the set [e] is finite for all e ∈ E;
# is a binary, irreflexive, symmetric relation such that e1#e2 and e2 ≤ e3 implies that e1#e3.
A conﬁguration of an event structure is a downwards closed subset of events in which no two events are in conflict. Define C(E) to be the set of configurations of
E.	 
The set of configurations of an event structure when ordered by inclusion form a prime algebraic domain [8]; the complete primes have the form [e] for an event e.
Definition 2.2 A set of configurations X of an event structure E is compatible, written X↑, iff there is a configuration y such that ∀x ∈ X. x ⊆ y; then X is itself a configuration. In the case where X = {w, z} we usually write w ↑ z instead of X↑.	 
Since their introduction in [8] it has been recognised that event structures can represent both processes and domains. At the time, in [8], this was remarked on as creating a ‘curious mismatch’; in traditional denotational semantics, a process denotes only an element of a domain. The ambiguous double role of event structures can be resolved by working with spans of event structures. A span
in  E ¸¸¸out
, s  ¸z 
B
represents a process computing from a type, represented by event structure A, to the type B, another event structure, as again itself an event structure E. The morphisms in and out specify how the event structure E inspects input and delivers output. There are many possible variations on spans as the morphisms in and out can have different natures. A systematic way to explore the range of possibilities via monads and distributive laws was suggested in [14] and is the subject of ongoing research [12]. For the purposes of this paper however we can restrict to very specific spans in which in is a ‘demand’ morphism and out is ‘rigid.’ Such spans first arose unexpectedly as representations of the profunctors used in a denotational semantics of higher-order processes [9].
A rigid morphism, f : E1 → E2, between event structures E1 and E2 consists of a function between the respective sets of events such that
[f (e)] = f [e], for all events e in E1, and
if f (e)= f (e') or f (e)#f (e'), then e = e' or e#e', for all e and e' in E1.
Rigid morphisms compose as functions. In proofs we will use an alternative charac-

terisation of rigid morphisms, and properties based on their effect on configurations.

Proposition 2.3 Let E1 and E2 be event structures. A function f from the set of events E1 to the set of events E2 is a rigid morphism f : E1 → E2 iff it
preserves causal dependency,
∀e, e' ∈ E1. e ≤ e' ⇒ f (e) ≤ f (e') , and
preserves conﬁgurations,
∀x ∈ C(E1). fx ∈ C(E2) & ∀e, e' ∈ x. f (e)= f (e') ⇒ e = e' .
A rigid morphism f : E1 → E2 determines a stable function on conﬁgurations [1]:
∀x, y ∈ C(E1). x ↑ y ⇒ f (x ∩ y)= (f x) ∩ (f y) .
A demand morphism d : E1 → E2 is a function from the set of events E1 to the finite configurations of E2. It must obey the following conditions:
e ≤ e' implies d(e) ⊆ d(e'), for all events e, e' ∈ E1;
d(e)/↑ d(e') implies e#e', for all events e, e' ∈ E1.
A demand morphism can be extended to act on configurations as well as events. Let d : E1 → E2 be a demand morphism between E1 and E2. We can extend this to a function d† : C(E1) → C(E2) by
†	def

d (x) =

e∈x
d(e)

for x ∈ C(E1). The fact that d†(x) is a configuration follows directly from x being a configuration and that d(e1) /↑ d(e2) implies that e1#e2. Clearly, if x is a finite configuration, then so is d†(x), and the extension d† sends finite configurations to finite configurations. The composition of two demand morphisms d2 ◦ d1 is achieved by the composition of functions d† ◦ d1.
For this paper, we restrict attention to spans of a special kind:

Definition 2.4 A span of event structures comprises A d
out
→ B where E, A and

are event structures, d is a demand morphism and out is a rigid morphism.

(Where there is no confusion, we refer to a span by its vertex, i.e., A ←d
E o→ut B

will be referred to as E.)	 
We can compose spans sequentially.	Given two spans A d1 E out1 B and


B d2
out2

d	out
←	1 →

← E2 → C, their composition is the span A ← E3 → C where E3 comprises
the event structure with
Events {(x, e) ∈ C(E1) × E2 | out1x = d2(e)};
Causal dependency (x, e) ≤ (x' e') iff x ⊆ x' and e ≤ e';

Conflict (x, e)#(x', e') iff x /† x' or e#e'.
The demand and output morphisms of the composition d and out are given by

def	†
def

d(x, e)
= d1(x) and out(x, e)
= out2(e) .

Because rigid morphisms can be identified with (certain kinds of) demand mor- phisms, this construction can be viewed as a pullback construction in the category of event structures with demand morphisms. (The spans here form a bicategory in the usual manner of spans [7].)
There is also a parallel composition of spans (which forms the symmetric monoidal structure, ⊗, referred to in Section 1).
Definition 2.5 Given two event structures, (E1, ≤1, #1) and (E2, ≤2, #2), their
parallel composition (E1, ≤1, #1) ⊗ (E2, ≤2, #2) is the event structure with:
Events E1  E2, the disjoint union of events, ({1}× E1) ∪ ({2}× E2),
Causal dependency (i, e1) ≤ (j, e2) iff i = j and e1 ≤i e2, and
Conflict (i, e1)#(j, e2) iff i = j and e1#ie2.

Once the event structures are made disjoint their parallel composition is given by the union of their events and relations of causality and conflict.

The parallel composition of A d1 E
out1 B and C d2 E
out2 D is

←	1 →	←	2 →
E1 ⊗ E¸2¸

d1 ⊗d2.....
 s.
¸¸o¸u¸t1⊗out2
¸¸z 


def
A ⊗ C	B ⊗ D
def

where (d1 ⊗d2)(i, e) = {i}×di(e) and (out1 ⊗out2)(i, e) = (i, outi(e)) for i = 1, 2.
From these constructions, it is possible to give a semantics to nondeterministic dataflow.

Stable Families
It is sometimes difficult to define constructions on event structures directly and it is often simpler to first define them in terms of stable families, from which an event structure can then be obtained from the prime configurations. Stable families will be used to define the trace construction.
Definition 3.1 A stable family, J, is a set of sets with the following properties.
Coherence 6X ⊆ J. (6x, y ∈ X. x † y) ⇒  X ∈ J.
Stability X † ⇒  X ∈ J for all non-empty X ⊆ J.
Coincidence-freeness
6x ∈ J, e1, e2 ∈ x. e1 /= e2 ⇒
Ey ∈ J. y ⊆ x & ((e1 ∈ y) & (e2 /∈ y)) or ((e2 ∈ y)& (e1 /∈ y)).

Finiteness 6x ∈ J,e ∈ x Ey ∈ J. y ⊆ x & e ∈ y & |y| < ∞.

It can be deduced that a stable family, ordered by inclusion, forms a prime algebraic domain [8,13]. If x is a member of a stable family J and e ∈ x let

[e]x
def
=
  {y ∈ J|e ∈ y & y ⊆ x}.

Then [e]x ∈ J and is called a prime conﬁguration of J. (It is a complete prime of
def
(J, ⊆) in the sense of [8].) Because of coincidence-freeness, taking max([e]x) = e
is well-defined.


Trace for Event Structures
This section is devoted to defining a trace operation TrC A ⊗ C to B ⊗ C to a span from A to B. Consider a span
d  E ¸¸¸¸o¸ut


which takes a span from

, s	¸z 
A ⊗ C	B ⊗ C . 
We first build a stable family out of those configurations of E which are secure. Roughly a configuration x is secure if the demand of each event e ∈ x is either met by the input in A, or by previous output to C, which we imagine is fed back as input. This idea is formalised below.
In defining the trace it is convenient to assume that both pairs of sets A, C, and B, C are disjoint, so that we can treat the parallel compositions A ⊗ C and B ⊗ C as given by union. We can now, for example, write y ∩ C for the ‘projection’ of a configuration y ∈ C(A ⊗ C) to its component in the event structure C.
Definition 4.1 Let x be a configuration of E. A securing sequence in x consists of a sequence of events e1, ··· , en in x such that
{e1, ··· , ei} ∈ C(E) & d(ei) ∩ C ⊆ out{e1, ··· , ei−1}

for all i ≤ n. An event e is secured in x iff there is a securing sequence e1, ··· , en in x with en = e. Finally, the configuration x is secure if each of its events is secured in x.	 
The subset of C(E), consisting of all the secure configurations will be shown to be a stable family, from which we then obtain an event structure. Our proofs will make use of a relation ≺x expressing the extra causal dependency on a configuration x of E which is introduced through feedback.
Definition 4.2 Let x be a configuration of E. For all events e1 and e2 in x, define
e1 →x e2 iff out(e1) ∈ d(e2) ∩ C, and
e1 ≺x e2 iff e1 < e2 or e1 →x e2.

We define {e}x to be the set {e' | e' ≺x٨ e} for all e ∈ x. (Note that because {e}x must be a downwards closed subset of x with respect to causal dependency it is necessarily a configuration.)	 


Lemma 4.3 An event e is secured in conﬁguration x iff
≺x is well-founded on {e}x, and
(d†({e}x)) ∩ C ⊆ out x.


Proof. if : Assume (i ) and (ii ). To prove that event e is secured in x, we require a securing sequence for e. First note that the set {e}x is finite as ≺x is well-founded and the set of ≺x-predecessors of an event is also finite. Thus tentatively we may take the securing sequence to be a choice of order {e1, ··· , en} of the set {e}x which respects ≺x, i.e., for 0 < i, j ≤ n,
(ei ≺x ej ⇒ i < j) and en = e . 

We now check that the chosen sequence is indeed securing. Observe that the set {e1, ··· , ei}, with i ≤ n, is a configuration of E because it is a downwards closed subset of x—this follows immediately from the definition of ≺x. It re- mains to confirm that d(ei) ∩ C ⊆ out{e1, ··· , ei−1}, for all i ≤ n. Consider an event c ∈ d(ei) ∩ C for some i ≤ n. As d†({e}x) ∩ C ⊆ out x, we have that c = out(e') for some e' ∈ x. By definition, e' →x ei, so e' ≺x ei. Thus e' ∈ {e}x and, as the sequence respects ≺x, we see that e' = ej for some j < i. This confirms that c ∈ out{e1, ··· , ei−1}. Hence {e1, ··· , en} is a securing sequence.
only if : Assume that e1, ··· , en = e is a securing sequence in x.
We first show that for i ≤ n


(†)
e' ≺x ei ⇒ e' ∈ {e1, ··· , ei−1}

and therefore that e' = ej for some j < i.
By definition if e' ≺x ei then either e' < ei or e' →x ei. As {e1, ··· , ei} is a configuration and therefore downwards closed with respect to <, if e' < ei then e' ∈ {e1, ··· , ei−1}. If e' →x ei then out(e') ∈ d(ei) ∩ C. But d(ei) ∩ C ⊆ out{e1, ··· , ei−1} by the property of a securing sequence. So out(e') = out(ej) where ej ∈ {e1, ··· , ei−1}. As both e', ej ∈ x and out is a rigid morphism e' = ej so e' ∈ {e1, ··· , ei−1}.
Now we can show (i) and (ii).
By (†)a ≺x-descending chain in {e}x induces a strictly descending chain of finite sets under inclusion—which is certainly well-founded. Hence ≺x is well-founded on
{e}x.

It follows from (†) that {e}x ⊆ {e1, ··· , en}, so d†({e}x) ⊆ d†({e1, ··· , en}).
Thus
(d†({e}x)) ∩ C ⊆ (d†({e1, ··· , en}) ∩ C
⊆ (  d(ei)) ∩ C
i≤n
⊆  (d(ei) ∩ C)
i≤n
⊆   out{e1, ··· , ei−1}	as e1,. . . ,en is a securing sequence,
i≤n
⊆ out x .


Corollary 4.4 A conﬁguration x is secure iff
≺x is well-founded on x, and
d†(x) ∩ C ⊆ out x.
Proof. if: Assume that a configuration x satisfies (i) and (ii) above. Let e ∈ x. Then certainly ≺x is well-founded on {e}x and (d†({e}x)) ∩ C ⊆ d†(x) ∩ C ⊆ out x. Thus e is secured in x by Lemma 4.3. But e was an arbitrary event in x. Hence x is secure.
only if: Assume the configuration x is secure. By Lemma 4.3, ≺x is well-founded on x, i.e. (i) . To show (ii):
d†(x) ∩ C = (   d†({e}x)) ∩ C
e∈x
=	(d†({e}x) ∩ C) ⊆ out x ,	by Lemma 4.3.
e∈x


In proving that the family of secure configurations forms a stable family, we will make use of the following lemma.
Lemma 4.5 Suppose x and y are secure conﬁgurations of E with x † y. Let e ∈
x ∩ y. Then,
e' ≺x e iff e' ≺y e, for all events e', and
{e}x = {e}y.
If x is a secure conﬁguration and e ∈ x, then {e}x is the least secure sub- conﬁguration of x containing e.
Proof. (i) Assume e ∈ x ∩ y where x † y. Suppose e' ≺x e. Then either e' < e or e' →x e. In the former case, e ∈ y and e' ≺y e. In the latter case, out(e') ∈ d(e) ∩ C with e' ∈ x. As y is secure,
d(e) ∩ C ⊆ (d†(y)) ∩ C ⊆ out y .

Thus out(e') = out(e'') with e' ∈ x and some e'' ∈ y. But x † y and out is a rigid morphism, so e' = e'' making e' ∈ y. It follows that e' →y e, and e' ≺y e. In either case, e' ≺x e implies e' ≺y e. The same argument proves the converse implication, establishing (i).
(ii) Obvious from (i).
Assume e ∈ x where x is a secure configuration. From Corollary 4.4, to establish that {e}x is secure it suffices to check (i) that ≺{e}x is well-founded on {e}x and (ii) that (d†({e}x)) ∩ C ⊆ out {e}x. Now (i) follows directly because ≺x, which includes
≺{e}x , is well-founded on {e}x by Lemma 4.3. We now concentrate on showing
(ii). By Lemma 4.3, as x is secure, we have that (d†({e}x)) ∩ C ⊆ out x. Thus any event of (d†({e}x)) ∩ C takes the form out(e') for some e' ∈ x. But supposing out(e') ∈ (d†({e}x)) ∩ C, then out(e') ∈ (d(e'')) ∩ C, i.e.  e' →x e'', for some
e'' ∈ {e}x. Consequently, e' ∈ {e}x. Hence (d†({e}x)) ∩ C ⊆ out {e}x.
Suppose e ∈ y ⊆ x where y is a secure configuration. Then certainly x † y, so
{e}x = {e}y ⊆ y. Thus, {e}x is the least secure sub-configuration of x containing
e.	 
Theorem 4.6 The family consisting of all secure conﬁgurations of E is a stable family. For any e ∈ x, a secure conﬁguration, [e]x = {e}x.
Proof. Let S = {x ∈ C(E) | x is secure}. We show S is a stable family.

Coherence: 6X ⊆ S. (6x, y ∈ X. x † y) ⇒  X ∈ S.
Assume X is a pairwise compatible subset of S. It is clear that

X is a config-

uration of E. If e ∈  X then e ∈ x for some x in X. As e is secured in x and
x ⊆  X, there is a securing sequence for e in  X.
Stability: 6X ⊆ S. X † ⇒   X ∈ S.
Suppose X ⊆ S and X †. Then, 6x ∈ X. x ⊆ y for some secure configuration y. Consider the set

def
Y = {{e}y | e ∈
X } .

It consists of secure configurations which are certainly pairwise compatible, with upper bound y. By coherence,  Y is a secure configuration. Clearly,  X ⊆  Y as each e ∈   X is a member of {e}y.  For any e ∈   X and x ∈ X, then
{e}y = {e}x ⊆ x, by Lemma 4.5. So we also have the reverse inclusion  Y ⊆  X
ensuring the equality  X =  Y , and that  X is a secure configuration.
Finiteness: 6x ∈ S6e ∈ xEy ∈ S. y ⊆ x & e ∈ y & |y| < ∞.
If x is secure then each event e in x must have a securing sequence. This determines a finite secure configuration in S which contains e.
Coincidence-freeness: 6x ∈ S, e1, e2 ∈ x. e1 /= e2 ⇒
Ey ∈ S. y ⊆ x & ((e1 ∈ y) & (e2 /∈ y)) or ((e2 ∈ y) and (e1 /∈ y)).

Assume e1, e2 ∈ x ∈ S and e1 /= e2. Consider the secure configurations {e1}x and
{e2}x. If e2 is a member of {e1}x then e2 ≺+ e1. As x is secure, it cannot be the

case that e1 ≺+
e2—otherwise we would contradict the well-foundedness of ≺x.

Therefore e1 /∈ {e2}x if e2 ∈ {e1}x and vice versa.
Finally, let e ∈ x, a secure configuration. Both [e]x (by definition) and {e}x (by Lemma 4.5) are the smallest secure sub-configurations of x which contain e, and hence equal.	 
We can now define the trace operation.

d	out
d'	out'

Definition 4.7 Define Tr(A ⊗ C ← E → B ⊗ C) to be A ← P
the event structure comprising
→ B where P is

Events, the prime configurations p of S for which out(max(p)) ∈ B, with
Causal dependency, p1 ≤ p2 iff p1 ⊆ p2, and
Conflict, p1#p2 iff p1 /† p2 in S,

and where, for p ∈
'	def	†
A and out (p) = out(max(p)). 

We should check that the definition of trace does indeed yield a span. In order to show that out' is rigid we observe the following.
Lemma 4.8 For e1 and e2 in x ∈ C(E), if e1≺x٨e2 and e1 /≤ e2 then out(e1) ∈ C.
Proof. By a simple induction on the length of chain e1 ≺x ··· ≺x e2.
Basis:	Suppose that e1 ≺x e2. In this case e1 /≤ e2 implies that e1 →x e2, so
out(e1) ∈ C.
Induction step: Suppose that the property holds for all chains of length less than or equal to k, i.e., assume that if e1≺xke2 and e1 /≤ e2 then out(e1) ∈ C. Suppose e1≺xk+1e2 and e1 /≤ e2. Then there exists an e' with e1≺xke' and e' ≺x e2. If e1 /≤ e' then, by the induction hypothesis, out(e1) ∈ C. If e1 ≤ e' then, as e1 /≤ e2, we have e' /≤ e2 and so out(e') ∈ C. But then out(e1) ∈ C as out is a rigid morphism. 
Lemma 4.9 The map out' is a rigid morphism:
Proof. We first show that out' preserves causal dependency. Suppose p' ≤ p in
P . Write max(p') = e' and max(p) = e. Then, e' ≺p e as [e]p = {e}p. Now, by Lemma 4.8, e' ≤ e as out(e') ∈ B. Thus out(e') ≤ out(e), as out is rigid, which directly yields out'(p') ≤ out'(p).
Now let X be a configuration of P . First observe that
out' X = B ∩ out  X . 
Clearly we have the inclusion out' X ⊆ B ∩ out  X. To show the reverse inclusion,
suppose e ∈  X and out(e) ∈ B. Then, e ∈ p for some p ∈ X. Write p def [e] .
=	p
Because p' ≤ p and X is downwards closed, p' ∈ X, with out'(p') = out(e)—as required.

It follows from the observation that out' X is a configuration of B: because X is a set of pairwise compatible configurations of E so is their union X, and therefore so is the image under the morphism out and ‘projection’ to B.
Suppose p, p' ∈ X and out'(p) = out'(p'). The union X is a secure configu- ration, compatible with both p and p'. Thus p = [e]S X and p' = [e']S X for some e, e' ∈  X. From the definition of out' it follows that out(e) = out(e'). Because out is a rigid morphism sending both e, e' ∈  X to common event we must have e = e'. Hence p = p'.	 
Theorem 4.10 The trace Tr(A ⊗ C ←d E o→ut B ⊗ C) is a span.
d'	out'
Proof. In the definition of the trace Tr(E) as the span A ← P → B it is easily
seen that P is an event structure. Lemma 4.9 confirms that out' is indeed a rigid morphism. That d' is a demand morphism follows directly from its definition. 
Relying on previous work [4,5], we can show that the operation Tr obeys the trace axioms up to isomorphism—see Appendix. In [4,5], a trace operation was given for stable port profunctors. Spans of event structures represent such profunctors. The representation respects both sequential and parallel composition as well as the trace operation.

Deterministic Dataflow
To connect with Kahn’s classic treatment of deterministic dataflow we define the notion of a deterministic span. Such spans represent stable functions between do- mains of configurations, and can be used to model deterministic dataflow. The trace construction on event structures is shown to correspond to the least fixed point construction detailed in [6].
Definition 5.1 A span
d  E ¸¸¸out
, s  ¸z 
A	B
is deterministic iff d(e1) † d(e2) ⇒ ¬(e1#e2).	 
The extra requirement of the demand morphism ensures that no two conflicting events of E can require consistent configurations of A. Such spans represent stable functions [1] between domains of configurations.
Definition 5.2 Let A d E out B be a deterministic span. Define ∼: C(A) → C(B)
←	→	E
by
~	def
E (y) = out{e ∈ E | d(e) ⊆ y} , for all y ∈ C(A).

~
Theorem 5.3 The function E: C(A) → C(B) is continuous, and stable, for all
deterministic spans E. Moreover, any stable function from C(A) to C(B) can be represented in this way.

Proof. As the demand of an event is a finite configuration it follows straightfor-
∼	∼
wardly that E is continuous. To see it is stable we observe that E factors into the
composition out ◦ F where
F (y)= {e ∈ E | d(e) ⊆ y} , for y ∈ C(A) .
The function F : C(A) → C(E) preserves all intersections, so certainly stable, while
out is a rigid morphism so a stable function on configurations, from C(E) to C(B).
~
Their composition E is therefore stable.
To see that any stable function f : C(A) → C(B) can be represented by a deterministic span, define a corresponding event structure E as follows. Its events E are pairs (y, b) where y is a finite configuration of A and b is an event of B for which y a minimal configuration such that b ∈ f (y)—in other words b ∈ f (y) and for no configuration y' ⊂ y do we have b ∈ f (y'). (Because f is stable, if b ∈ f (w) then there is a unique, minimum y ⊆ w with (y, b) ∈ E.) Define
(y, b) ≤ (y', b') iff y ⊆ y' & b ≤ b' , and
(y, b)#(y', b') iff y /† y' or b#b' .
Define d(y, b)= y and out(y, b)= b. It is routine to check that this defines an event structure E, a demand morphism d : E → A and rigid morphism out : E → B, which together form a deterministic span such that E= f .	 
Theorem 5.3 and its proof provide two operations, one from deterministic spans to stable functions, and an inverse operation from stable functions to deterministic spans. These operations are part of an equivalence between the bicategory of de- terministic spans and the order-enriched category of stable functions on coherent prime algebraic domains.
Proposition 5.4 The composition of two deterministic spans is deterministic.
Proof. Let A d1 E  out1 B and B d2 E  out2 C be deterministic spans with compo-
←	1 →	←	2 →
sition A ←d E o→ut C, which we check is deterministic.
Let (x1, e2) and (x' , e' ) be events in E3 and assume d(x1, e2) † d(x' , e' ). This
1	2	1	2
is true iff d1†(x1) † d1†(x' ). As the span E1 is deterministic, x1 † x' . Consequently,
1	1
d2(e2) † d2(e' ), because by the definition of composition d2(e2) = out1 x1 and
d2(e' ) = out1 x' and out1 preserves compatibility. This implies that ¬(e2#e' ),
2	1	2
as the span E2 is deterministic.	As x1 † x'  and ¬(e2#e' ) it follows that
¬((x1, e2)#(x' , e' )).	 
1	2
For the remainder of this section, let


A ⊗ C d
out
→ B ⊗ C

be a deterministic span. We explore the properties of its trace. For notational sim- plicity we assume that A ∩ C = ∅ and B ∩ C = ∅ and take the parallel compositions A ⊗ C and B ⊗ C to be unions.

Lemma 5.5 Let y ∈ C(A). For s ⊆ E deﬁne
ϕ(s)= {e ∈ E | d(e) ⊆ y ∪ (C ∩ out s)} .
This determines a continuous function ϕ : C(E) → C(E) such that Sec(y) μs.ϕ(s), the least ﬁxed point of ϕ, is a secure conﬁguration of E.
Moreover, Sec(y) is the maximum secure conﬁguration x of E such that
d†(x) ∩ A ⊆ y . 




def
=

Proof. That ϕ is a function between configurations follows from determinism, while continuity follows from finiteness of demands, as in the proof of Theorem 5.3.
Then μs.ϕ(s)=  i∈ω si, a union of an ⊆-increasing chain of configurations of E
given inductively by
s0 = ∅
si+1 = ϕ(si).
Observe that, as ϕ is a function from configuration to configuration, si ∈ C(E) for all i ∈ ω.
We show by induction that si secure for all i ∈ ω.
Base case: The property trivially holds for s0.
Inductive step: Assume that sk is secure. Each event in sk is secured and therefore has a securing sequence within sk. Any additional events e in sk+1 have d(e) ∩ C ⊆ out sk. We can therefore give a securing sequence for e by combining the securing sequences of the events upon which it depends according to ≺sk+1 . Therefore sk+1 is secure. This shows that Sec(y) is secure for all y ∈ C and it is clear that d†(Sec(y))∩ A ⊆ y.
Suppose x ∈ C(E) is secure and d†(x) ∩ A ⊆ y. By Corollary 4.4, ≺x is well- founded. We show by well-founded induction on ≺x that
6e ∈ x. e ∈ Sec(y) .
Suppose e' ∈ Sec(y) for all e' ≺x e. Then d(e) ∩ C ⊆ out Sec(y) as x is secure and by assumption d(e) ∩ A ⊆ y ; because x is secure d(e) ∩ C ⊆ out x (Corollary 4.4) and if out(e') ∈ d(e) ∩ C then e' →x e, so e' ∈ Sec(y) inductively. Hence d(e) ⊆ y ∪ (C ∩ out Sec(y)) and therefore e ∈ ϕ(Sec(y)) = Sec(y).	 
Corollary 5.6 The trace Tr(E), of the (arbitrary) deterministic span E, is deter- ministic.
Proof. Suppose p1, p2 ∈ Tr(E) have compatible demands d'(p1) and d'(p2), i.e.,
there is a configuration y of A such that
d†(p1) ∩ A ⊆ y and d†(p2) ∩ A ⊆ y . 
But Sec(y) is the maximum secure configuration x of E such that
d†(x) ∩ A ⊆ y

—Lemma 5.5. Both p1 and p2 are secure configurations. Hence both p1 ⊆ Sec(y) and p2 ⊆ Sec(y), so p1 and p2 are compatible as secure configurations, and hence not in conflict as events of the trace.	 
Lemma 5.7 For all y ∈ C(A),
~
Tr(E) (y)= B ∩ (out Sec(y)) .
Proof. By definition
~
Tr(E) (y)= out'{p ∈ Tr(E) | d†(p) ∩ A ⊆ y} ,
where out'(p)= out(max(p)) ∈ B for p ∈ Tr(E). If d†(p) ∩ A ⊆ y with p ∈ Tr(E) then p is secure, so p ⊆ Sec(y) by the maximum property of Sec(y)—Lemma 5.5.
~
It follows that Tr(E) (y) ⊆ B ∩ (out Sec(y)). To see the reverse inclusion, note that for any e ∈ Sec(y) with out(e) ∈ B we have [e]Sec(y) ∈ Tr(E).	 
In conclusion we can understand the trace of the deterministic span in terms of the least fixed point of its associated function; the trace of deterministic event structures reduces to the trace known to Kahn [6].
Theorem 5.8 For all w ∈ C(A),
∼	∼
Tr(E) (w)= B ∩ μz ∈ C(B ⊗ C). E (w ∪ (C ∩ out z)) .
Proof. By Lemma 5.7,
~
Tr(E) (w)= B ∩ out(μx. ϕ(x))
where ϕ : C(E) → C(E) is the continuous function given by
ϕ(x)= {e ∈ E | d(e) ⊆ w ∪ (C ∩ out x)}
for x ∈ C(E).
Define the continuous function ψ : C(B ⊗ C) → C(B ⊗ C) by taking
~
ψ(u) =E (w ∪ (C ∩ u))
for u ∈ C(B ⊗ C).
It is easy to see that out : C(E) → C(B ⊗ C) induces a strict continuous function between the domains of configurations. Directly from their definition we see that
out ϕ(x)= ψ(out x) for x ∈ C(E); both expressions equal
out{e ∈ E | d(e) ⊆ w ∪ (C ∩ out x)} .

By a well-known property of least fixed points we now know that μu. ψ(u) =
out(μx. ϕ(x)), which gives the result directly.	 

Concluding Remarks
Spans of event structures provide an intuitive semantics for both deterministic and nondeterministic dataflow. The semantics provides a good example of the way in which event structures can be used to represent both types and processes acting between types.
The spans of event structures used here were first discovered in joint work with Mikkel Nygaard [9]. There they provided an informative, more operational repre- sentation of the profunctors which appeared as denotations of affine-HOPLA—an affine language for higher-order processes. (There is a function space construction for spans to accompany the parallel composition ⊗.) It was realised later that the same spans also represented the profunctors used in an earlier ‘relational’ model of nondeterministic dataflow [4,5].
Such spans are part of a much more general picture, the beginnings of which are sketched in [14,12]. But we hope that our treatment of nondeterministic dataflow can stand alone, and in itself make a convincing case for the usefulness of spans of event structures.

References
G. Berry. Mod`eles complement ad´equats et stables des λ-calculs typ´es, Th`ese de Doctorat d’Etat. PhD thesis, Universit. Paris VII, 1979.
J. Brock and W. Ackerman. Scenarios: A model of non-determinate computation. Formalization of programming concepts, 107, 1981.
Gian Luca Cattani and Glynn Winskel. Profunctors, open maps and bisimulation. As yet unpublished, February 2004.
T. Hildebrandt, P. Panangaden, and G. Winskel. Relational semantics of nondeterministic dataflow, 1998.
T. T. Hildebrandt, P. Panangaden, and G. Winskel. A relational model of nondeterministic dataflow.
MSCS, 2003.
G. Kahn. The semantics of a simple language for parallel programming. Information Processing, 74:471–475, 1974.
S. MacLane. Categories for the Working Mathematician, volume 5 of Graduate Texts in Mathematics. Springer, second edition, 1998.
M. Nielson, G. D. Plotkin, and G. Winskel. Petri nets, event structures and domains. Theoretical Computer Science, 13(1):85–108, 1981.
M. Nygaard. Domain Theory for Concurrency. PhD thesis, University of Aarhus, July 2003.
A. Rabinovich and B. A. Trakhtenbrot. Communication among relations. In M.S. Paterson, editor,
Proceedings of the 6th ICALP, volume 443 of LNCS, pages 294–307. Springer, 1990.
James R. Russell. Full abstraction for nondeterministic dataflow networks. In FOCS, pages 170–175, 1989.
G. Winskel. Event structures with symmetry. To appear in the Festschrift for Gordon Plotkin, ENTCS, 2007.
G. Winskel. Event structure semantics for CCS and related languages. In ICALP ’82, 1982.
G. Winskel. Relations in concurrency (invited talk). LICS’05, 2005. Full version available at
www.cl.cam.ac.uk/users/gw104/ .

A  Appendix: spans and rooted profunctors
We show how spans of event structures correspond to certain profunctors and that the trace we have defined on spans coincides with the trace defined on stable pro- functors in [4,5]. The profunctors are between partial orders of finite configurations (regarded as categories). We shall write Co(E) for the partial order of finite config- urations of an event structure E under inclusion.
In describing the profunctor determined by a span it is helpful to have a further characterisation of rigid morphisms between event structures:
Proposition A.1 Let E1 and E2 be event structures. A function f from the set of events E1 to the set of events E2 is a rigid morphism f : E1 → E2 iff it
6x ∈ C(E1). fx ∈ C(E2) & 6e, e' ∈ x. f (e)= f (e') ⇒ e = e' , and

6x' ∈ C(E1),y ∈ C(E2). y ⊆ f x' ⇒ Ex ∈ C(E1). x ⊆ x' & fx = y . 
(x is necessarily unique and given by x = {e ∈ x' | out(e) ∈ y}.)


Consider a span A d
out
→ B between a event structures A and B. Let y be a

finite configuration of A and z a finite configuration of B—so y is some particular finite input and z some particular finite output. Define the set

E(y, z)= {x ∈ Co(E) | d†(x) ⊆ y & out x = z} .

The set E(y, z) consists of all the configurations of E, necessarily finite, which for input y yield output z. The set E(y, z) is functorial in y ∈ Co(A) and z ∈ Co(B)op; it respects the inclusion order on configurations covariantly for input and contravariantly for output. Suppose y ⊆ y' in Co(A). Then, E(y, z) ⊆ E(y', z) — simply because any configuration x of E with demand d†(x) ⊆ y will make d†(x) ⊆ y'. So, an inclusion i : y ⊆ y' in Co(A) determines an inclusion map

E(i, z): E(y, z) ‹→ E(y', z) .
An inclusion j : z ⊆ z' in Co(B) determines a map

E(y, j): E(y, z') → E(y, z) .
It takes x', for which out x' = z', to the unique sub-configuration x ⊆ x' of E for which out x = z; this exists because out is a rigid map of event structures— Proposition A.1. It is easy to see that these associations of maps with inclusions respect identities and composition, so we have a functor to the category of sets

E : Co(A) × Co(B)op → Set ,
i.e., a profunctor from Co(A) to Co(B).

By the properties of rigid maps it is easy to see that E(y, ∅)= {∅}, so a singleton, for any y ∈ Co(A)—the profunctor is rooted . Via ‘currying’ the profunctor corre- sponds to a functor from Co(A) to the functor category [Co(B)op, Set] of presheaves over Co(B). It can be shown that the functor so obtained preserves pullbacks. Consequently, the profunctor E is stable in the sense of [4,5]. It follows that the composition of spans is sent to the composition of (stable) profunctors. In addition,

d	out
d'	' out'

a morphism between two spans A ← E → B and A ← E → B is a rigid morphism
of event structures f : E → E' such that the two triangles commute in
E
ııı f ,,
ııı J ,,,
dıı	E' ¸  ,,out

ıı 
ı  '
 ,rsı
¸¸¸ ,,,
out' ¸¸¸,z,t z

A	B
—recall we regard rigid morphisms and demand morphisms as maps on configu- rations in making sense of their composition. Such a morphism of spans induce cartesian natural transformations between the associated functors from Co(A) to the functor category [Co(B)op, Set].
The paper [4,5] studies a trace construction on rooted profunctors for nondeter- ministic dataflow. In loc. cit. the tensor operation is also given by simple parallel composition. We now sketch why the trace construction there coincides with that on event structures, that


for any span A ⊗ C ←d


Tr(E) ∼= Tr(E)
E o→ut B ⊗ C. In particular, we inherit the properties of the

trace proved in the earlier work.
The definition of trace on stable profunctors (Definition 18 in [4]) is based on the usual coend operation on profunctors (see e.g., [3]) but restricted to elements which are secure—where an element being secure is expressed without the benefit of concepts from event structures. We can as well give the definitions with respect

to E for a particular span of event structures A ⊗ C d
out
→ B ⊗ C, assumed from

now on. As usual, we will assume that the event structures A and C, and the event structures are disjoint so that the parallel compositions A ⊗ C and B ⊗ C are given by unions. By definition, an element of the profunctor E consists of a triple (y, z; x) where x ∈ E(y, z). Elements of E can be thought of as states in the computation between A and B. The definition of trace on stable profunctors hinges on three basic relations between elements of the profunctor.

Definition A.2 Let (y, z; x) and (y', z'; x') be elements of E. Define


(y, z; x) A
(y, z; x) B
(y', z'; x') iff z = z' & x = x' & Ea ∈ A. y ∪ {a} = y' , and
(y', z'; x') iff y = y' & Eb ∈ B. z ∪ {b} = z' & x = {e ∈ x' | out(e) ∈ z} .

Define (y, z; x) ~ (y', z'; x') iff (y, z'; x') is an element with
y ⊆ y' & z ⊆ z' &
y ∩ A = y' ∩ A & z ∩ B = z' ∩ B & y ∩ C = z ∩ C & y' ∩ C = z' ∩ C & x = {e ∈ x' | out(e) ∈ z} .



The relation →A
concerns the change of element associated with input in A, the

relation →A
with output in B. The relation ~ concerns input in C which is matched

by prior output on C and plays a key role in those elements allowed in the definition of trace of a stable profunctor.
We use the following fact several times.
Proposition A.3 A ﬁnite conﬁguration of E is secure iff there is a securing se- quence e1, ··· , en such that x = {e1, ··· , en}.
Proof. If : Directly from the definition of securing sequence. Only if : Assuming that x is a secure configuration, the relation ≺x is well-founded and d†(x) ∩ C ⊆ out x. When x is finite we can order its events, say as e1, ··· , en, in a way that respects ≺x, i.e. so ei ≺x ej implies i < j. This yields a securing sequence such that x = {e1, ··· , en}.	 
The notion of secure element of a stable profunctor derived from these relations (and used in [4,5]) corresponds to that of secure configuration:

Lemma A.4 Let (y, z; x) be an element of E. Then, (∅, ∅; ∅)(→A
∪ →B
∪ ~)٨(y, z; x)

(i.e., the element is secure [4,5]) iff the conﬁguration x is secure.
Proof. Only if : Consider the following property of an element (y, z; x) of E:


Q(y, z; x) iff x is secure and y ∩ C ⊆ out x .

Clearly Q(∅, ∅; ∅).	It suffices to show in the cases (i) (y, z; x) →A


(y', z'; x'),

(ii) (y, z; x) →B
Q(y', z'; x').
If (y, z; x) →A
(y', z'; x') or (iii) (y, z; x) ~ (y', z'; x'), that if Q(y, z; x) then

(y', z'; x'), then x' = x and y' ∩ C = y ∩ C. So clearly Q(y, z; x)

implies Q(y', z'; x').
Suppose (y, z; x) B

(y', z'; x') and that x is secure and y ∩ C ⊆ out x. Then y' =

y and x' = x ∪ {e'} for some e' ∈/ x with out(e') ∈ B. Because x is finite and secure we can construct a securing sequence e1, ··· , en such that x = {e1, ··· , en}. The extended sequence e1, ··· , en, e' is also a securing sequence; the extra requirement that d(e') ∩ C ⊆ out {e1, ··· , en} follows by
d(e') ∩ C ⊆ d†(x') ∩ C ⊆ y' ∩ C = y ∩ C ⊆ out x .

Hence x' is secure, and clearly y' ∩ C ⊆ out x'.
Suppose (y, z; x) ~ (y', z'; x') and that x is secure and y ∩C ⊆ out x. As in (ii), take a securing sequence e1, ··· , en such that x = {e1, ··· , en}. Because x ⊆ x', with

x' a finite configuration, we can choose a sequence of events e' , ··· , e'
such that

1	m
x ∪ {e' , ··· , e'} is a configuration of E for all 0 < i ≤ m with x' = x ∪ {e' , ··· , e' }.
1	i	1	m
We claim that the concatenated sequence
e1, ··· , en, e' , ··· , e'
1	m
is a securing sequence: from the definition of ~ it follows that d†(x') ⊆ y, and hence that
d(e' ) ∩ C ⊆ y ∩ C ⊆ out x ⊆ {e1, ··· , en, e' , ··· , e'	} ,
i	1	i−1
the extra condition required to be securing. Thus x' is secure. From the definition of ~, we have y' ∩ C = z' ∩ C, and z' ∩ C = (out x') ∩ C as (y', z'; x') is an element of E. So certainly y' ∩ C ⊆ out x'.

If : Write x e
x' = x ∪ {e}.
x' iff x and x' are secure configurations of E such that e ∈/ x and

We first show: if x →e
x' and (y, z; x) is an element of E with z ∩ C ⊆ y, then

(y, z; x)(→A
∪ →B
∪ ~)٨(y', z'; x') for some element (y', z'; x') with z' ∩ C ⊆ y'.

Assume x e
x' and (y, z; x) is an element with z ∩ C ⊆ y. First note that as

x' is secure, d(e) ∩ C ⊆ out x; for a securing sequence e1, ··· , en = e for e in x' we must have d(e) ∩ C ⊆ {e1, ··· , en−1} ⊆ x. There are two cases, when out(e) ∈ B and out(e) ∈ C.
Suppose out(e) ∈ B. Then

(y, z; x) A ∗ (y ∪ d(e), z; x) B
(y ∪ d(e),z ∪ {out(e)}; x') ,

where we have made use of the fact that d(e) \ y ⊆ A. This follows because
d(e) ∩ C ⊆ (out x) ∩ C = z ∩ C ⊆ y . 
Also,
(z ∪ {out(e)}) ∩ C = z ∩ C ⊆ y ⊆ y ∪ d(e) .
Suppose out(e) ∈ C. Then
(y, z; x) A ∗ (y ∪ d(e), z; x) ~ (y ∪ d(e) ∪ {out(e)},z ∪ {out(e)}; x') .
Again we have used the fact that d(e) \ y ⊆ A. Also,
(z ∪ {out(e)}) ∩ C = (z ∩ C) ∪ {out(e)} ⊆ y ∪ d(e) ∪ {out(e)} .
Now, assume x is a finite, secure configuration of E. We can choose a securing sequence e1, ··· , en such that {e1, ··· , en} = x. Write xi = {e1, ··· , ei}, where 0 ≤ i ≤ n. Then each xi is secure and

∅ = x

e1 x  e2	en x
= x . 

0 → 1 → ··· → n

By the above we can inductively, left-to-right, produce a chain
(∅, ∅; ∅)( A	B	~)٨(y, z; x)
→ ∪ → ∪ 

to an element (y, z; x) of E.	 

Now we define the trace of the stable profunctor E from [4,5]. For those familiar with coends, the definition mimics the construction of a coend in the category of sets, but in this case restricted to secured elements. It rests on an equivalence rela- tion ∼ between secured elements (the relation coincides with the usual equivalence associated with the coend in sets).

Definition A.5 The relation ∼, between secure elements of E, is defined to be the symmetric, transitive closure of ~.
Following [4,5], the trace of E is defined to be the (stable) profunctor

Tr(E): Co(A) × Co(B)op → Set ,
given as follows. For y0 ∈ Co(A) and z0 ∈ Co(B),

Tr(E)(y0, z0)= {{y, z; x}∼ | (y, z; x) is a secure element & y ∩ A = y0 & z ∩ B = z0} .
An inclusion i : y0 ⊆ y' in Co(A) determines a map

Tr(E)(i, z0): Tr(E)(y0, z0) → Tr(E)(y' , z0) ,

which takes {y, z; x}∼
mines a map
to {y ∪ y' , z; x}∼
. An inclusion j : z0 ⊆ z'
in Co(B) deter-

Tr(E)(y0, j): Tr(E)(y0, z' ) → Tr(E)(y0, z0); 
it takes {y', z'; x'}∼ to {y', z' ∩ z0; {e ∈ x' | out(e) ∈ z' ∩ z0}}∼. (It follows from the functoriality of E that the functions Tr(E)(i, z0) and Tr(E)(y0, j) are well-defined, as does the functoriality of Tr(E).)	 
Definition A.6 Let x be a secure configuration of E. Define
def 

(Because the secure configuration of E form a stable family, min(x) is the minimum secure sub-configuration of x that outputs the same B events as x.)	 
Lemma A.7 For secure elements, (y, z; x) ∼ (y', z'; x') iff
y ∩ A = y' ∩ A & z ∩ B = z' ∩ B & min(x)= min(x') .
Proof. If : Assume y ∩A = y' ∩A and z ∩B = z' ∩B and min(x)= min(x'). Define x0 = min(x), y0 = d†(x0)∪(y∩A) and z0 = out x0. Then (y0, z0; x0) ~ (y, z; x) from the definition of ~. Similarly, (y0, z0; x0) ~ (y', z'; x'). Hence (y, z; x) ∼ (y', z'; x'). Only if : Assume (y, z; x) ~ (y', z'; x'). Then, y ∩ A = y' ∩ A and z ∩ B = z' ∩ B directly from the definition of ~. Clearly, x ⊆ x'. From its definition, min(x) is

the least, secure configuration s ⊆ x such that (out s) ∩ B = z ∩ B. Hence it is also the least, secure configuration s ⊆ x' such that (out s) ∩ B = z' ∩ B, so equal to min(x').	 
Theorem A.8 There is a natural isomorphism

θ : Tr(E) ∼= Tr(E)

with components θy ,z
: Tr(E)(y0, z0) → Tr(E)(y0, z0), for y0 ∈ Co(A) and z0 ∈

0 0

Co(B), given by θy ,z ({y, z; x}
)= {p ∈ Tr(E) | p ⊆ x}.

Proof. Observe that for a secure configuration x of E that
min(x)=  {p ∈ Tr(E) | p ⊆ x} .

In particular, θy0,z0 is a well-defined function because θy0,z0 ({y, z; x}∼) consists of those p ∈ Tr(E) for which p ⊆ min(x). Tentatively, define an inverse to θy0,z0 ,

ϕy0 ,z0 : Tr(E)(y0, z0) → Tr(E)(y0, z0)
by taking ϕy0 ,z0 (X) = {y, z; x}∼ where x =  X, y = d†(x) ∪ y0 and z = out x. Then,
ϕy0 ,z0 θy0,z0 ({y, z; x}∼)= ϕy0 ,z0 ({p ∈ Tr(E) | p ⊆ x})
= {d†(min(x)) ∪ y0, out min(x); min(x)}∼ = {y, z; x}∼ ,
by the observation, and
θy0,z0 ϕy0 ,z0 (X)= {p ∈ Tr(E) | p ⊆  X} = X , 
from the properties of primes as X is downwards closed. We omit the fairly routine verification of naturality.	 
