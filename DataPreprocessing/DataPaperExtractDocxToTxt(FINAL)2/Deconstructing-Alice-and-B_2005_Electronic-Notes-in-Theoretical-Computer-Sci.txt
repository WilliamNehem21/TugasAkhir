Electronic Notes in Theoretical Computer Science 135 (2005) 3–22	
www.elsevier.com/locate/entcs


Deconstructing Alice and Bob

Carlos Caleiro1
CLC, Department of Mathematics, IST, Lisbon, Portugal
Luca Vigan`o2	David Basin3
Department of Computer Science, ETH Zurich, Switzerland

Abstract
Alice&Bob–notation is a simple notation for describing security protocols as sequences of message exchanges. We show that, despite the fact that Alice&Bob–notation does not include explicit con- trol flow constructs, it is possible to make some of these aspects explicit when producing formal protocol models without having to resort to more expressive protocol description languages. We introduce a notion of incremental symbolic run to formally handle message forwarding and con- ditional abortion. In incremental symbolic runs, we use variables to represent messages that the principals cannot read, and we characterize each of the execution steps in order to build a collec- tion of symbolic subruns of increasing lengths, reflecting the data possessed by the principals up to that point in the execution. We contrast this with the simpler (more standard) approach based on formalizing the behavior of principals by directly interpreting message exchanges as sequences of atomic actions. In particular, we provide a complete characterization of the situations where this simpler approach is adequate and prove that incremental symbolic runs are more expressive in general.
Keywords: Security protocols, protocol models, Alice and Bob notation, control flow, message forwarding, protocol abortion.



1 Email: ccal@math.ist.utl.pt
2 Email: vigano@inf.ethz.ch
3 Email: basin@inf.ethz.ch
This work was supported by FCT and EU FEDER through POCTI (via the Project Quant- Log POCTI/MAT/55796/2004 of CLC) and by the FET Open Project IST-2001-39252 and BBW Project 02.0431, “AVISPA: Automated Validation of Internet Security Protocols and Applications”.


1571-0661 © 2005 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2005.06.007

The so-called Alice&Bob–notation is commonly used to describe security pro- tocols as sequences of message exchange steps of the form
A → B : M . 

While this notation is intuitive and compact, it is informal and making it more precise requires defining the sequence of actions taken by each honest principal participating in the protocol. This can be achieved by directly interpreting (i.e. “compiling”) each message exchange as a sequence of actions, e.g. actions for sending and receiving messages and for applying cryptographic operations such as encryption and decryption, generation of fresh data, application of hash functions, and the like.
This approach, which we call the direct-compilation approach, can be used to formalize the behavior of the different protocol participants for a large subclass of protocols, namely those protocols that consist of a linear sequence of message exchange steps, without control flow constructs (such as loops or if- then-elses). In such protocols, there is only a weak form of implicit branching: each step either succeeds or aborts due to a failed operation, e.g. when a message received does not comply to the protocol specification.
For non-linear protocols with explicit control flow, however, alternative notation must be used, based on richer specification languages that make explicit what is left implicit (or even unspecified) in Alice&Bob–notation. A number of such languages have been proposed, e.g. based on automata, process calculi, or even temporal logic, such as the high-level protocol specification language HLPSL of the AVISPA project [5].
We show that, despite the fact that the Alice&Bob–notation does not in- clude explicit control flow constructs, it is possible to make some of these aspects explicit when producing formal protocol models without having to re- sort to more expressive protocol description languages. The approach that we present here focuses on handling protocols that require message forwarding and conditional abortion. To illustrate these two problems, observe that in some protocols, the principals receive submessages that are opaque (or “un- readable”) to them — in the sense that these principals cannot decompose these submessages — which they should simply forward to other principals in subsequent protocol steps. For example, a protocol might state that a prin- cipal A should receive and immediately forward a message {M }K encrypted with a symmetric key K that A does not yet have. It is possible that such an encrypted message can be analyzed sometime later, as the participants accu- mulate data incrementally during each protocol run. Hence, when new data


is received, a principal may only then be able to determine that some previ- ously received message does not have the required structure and thus abort the protocol. That is, in some later step A may receive the key K (or receive enough information to compose it herself) and can thus decrypt {M }K. In this case, A should abort the protocol run whenever M does not conform to the protocol description (for example, if it does not contain a nonce that A generated and sent to some other principal earlier in the protocol run).
Our main contribution in this paper is to introduce a notion of incremental symbolic run to formally handle message forwarding and conditional abortion. In incremental symbolic runs, we use variables to represent opaque submes- sages, and we characterize each of the execution steps in order to build a collection of symbolic subruns of increasing lengths, where the structure of messages reflects the growth of the relevant data during protocol execution. Said another way, the structure of messages in these subruns reflects the data possessed by the principals up to that point in the execution. We can thus define the sequences of symbolic runs of growing length that adequately model the behavior of each of the protocol participants. We then discuss the relation- ship between incremental symbolic runs and the runs that one obtains from the direct-compilation approach. We provide a complete characterization of the situations when the direct-compilation approach works, and show that in other situations the more expressive incremental symbolic runs are required.
The approach that we propose is general and independent of the details of the particular formalism chosen for modeling the protocols (e.g. multiset rewriting, distributed temporal logic, strand spaces, process algebras, trace- based models, and so on) and of the details of the intruder model (which could be the standard Dolev-Yao model or the model of an intruder with different capabilities). Therefore, our results can be used to provide a formal footing for using Alice&Bob-notation in security protocol analysis tools even for protocols that explicitly rely on message forwarding and conditional abortion. Moreover, although we do not explore this possibility here, our work provides a good basis for generating protocol implementations from Alice&Bob-style descriptions that explicitly carry out necessary executability and abortion tests.
We proceed as follows. In §2 we illustrate the problems with message forwarding and conditional abortion by means of concrete examples, and in
§3 we show how incremental symbolic runs provide a formal solution to these problems. In §4 we draw conclusions. Due to lack of space, we will often only give informal justifications of the technical results; details can be found in [3].

Message forwarding and conditional abortion
To illustrate the problems with message forwarding and conditional abortion, we first introduce an algebra of messages and define the actions that can be performed by the principals participating in a protocol run.

Messages and actions
Let a set Pr of principal identiﬁers and a set Num of “numbers” be given. The elements of Num model random data, like nonces or keys. We will use upper-case letters like A, B, C,... to denote principals and N to denote num- bers. We also use lower-case letters like a, b, c,... for variables that range over principals, n to range over numbers, and m to range over messages. All of these variables may be annotated with subscripts.
Definition 2.1 Messages are built inductively from atomic messages (iden- tiﬁers, numbers, and variables) by pairing, encryption, and hashing. We write these operations as M1; M2, {M1}M2 (the encryption of M1 by M2), and H(M1), for M1 and M2 messages and H a hash function. The set sub(M ) of submessages of a message M is deﬁned inductively by
⎧⎨{M }	if M is atomic,
⎩{H(M1 )}∪ sub(M1 )	if M = H(M1 ).
If S is a set of messages, then we will also write sub(S) to denote the set of all submessages of messages in S, i.e. sub(S)=  M ∈S sub(M ).
We follow the perfect cryptography assumption and the free-algebra as-
sumption, where syntactically different terms denote different messages. For readability, we will often write K to denote messages intended to be used as encryption keys. We also assume that every message K has an inverse K−1 that must be used for decrypting messages encrypted with K. We further assume that (K−1)−1 = K and that it is not possible to compute K−1 from
K. If K−1 = K then we speak of symmetric encryption, and of asymmetric encryption otherwise. As notation, we will write KA to denote a public key of the principal A, whose inverse is A’s private key K−1, and we will write KAB to denote a symmetric key that is shared by the principals A and B.
Definition 2.2 The actions that can be performed by a principal participating in a protocol are:
s(M, A) — sending the message M to the principal A,
r(M ) — receiving the message M, and

(nspk1)	a → b	:	(n1). {n1; a}Kb
(nspk2)	b → a	:	(n2). {n1; n2}Ka
(nspk3)	a → b	:	{n2}Kb
Fig. 1. The simplified Needham-Schroeder Public-Key Protocol (NSPK).

i nit-run : ⟨f(n1).s({n1; a}Kb, b) . r({n1; n2}Ka ) . s({n2}Kb, b)⟩
r esp-run : ⟨r({n1; a}Kb ) . f(n2) . s({n1; n2}Ka, a) . r({n2}Kb )⟩
Fig. 2. The initiator and responder runs of NSPK.
f(N ) — generating the fresh number N.
Communication is assumed to be asynchronous and to take place over a hostile network. Hence, principals specify the intended recipients of the messages they send, but the receiving action does not explicitly name the message’s sender. In fact, we can assume, as is standard, that the network is controlled by, and can be identified with, a Dolev-Yao intruder [8] who can compose, send, and intercept messages at will, but cannot break cryp- tography. Note, however, that our results are independent of the particular capabilities of the intruder. Note, too, that in this paper we consider the ac- tions of principals from a fairly high level of abstraction, and we only model the communication actions s(M, A) and r(M ), and one internal action f(N ). Other internal actions, e.g. corresponding to the application of cryptographic operations (such as explicit encryption and decryption, application of a hash function, test for equality, etc.) can be modeled similarly and our results extended straightforwardly.
Action sequences and protocol runs
Given an algebra of messages and a set of actions, there are many approaches available for formally specifying and analyzing protocols, for example, using formalisms based on multiset rewriting, distributed temporal logic, strand spaces, process algebras, trace-based models, among others (see, for exam- ple, [4,11,12,13]). The approach that we propose is general and independent of the details of the particular formalism chosen. Rather than focusing on any concrete approach, we thus consider a step that is common to all ap- proaches: formally defining the precise sequences of actions that should be executed by each of the protocol participants, given a description of a proto- col in Alice&Bob–notation. By protocol participants we mean those principals who send or receive messages in some step of the protocol. Hence, our task


amounts to extracting (or “compiling”) a sequence of precise actions for each participant from a higher-level notation and, in doing so, giving that notation a precise semantics in terms of the actions of the individual participants.
As a first concrete example, consider the simplified Needham-Schroeder Public-Key Protocol (NSPK) [6]. Fig. 1 shows the usual Alice&Bob–style de- scription of NSPK, where a and b are variables ranging over principals that identify the roles played in one run of the protocol. The arrows represent communication from the sender to the receiver, where the parenthesized vari- ables prefixing the first two messages signify that these nonces must be freshly generated before the message is composed and sent.
Let us write w = ⟨w1.w2.w3 ... ⟩ to denote a (possibly infinite) sequence w
composed of the elements w1, w2, w3,... . Let |w| denotes its length, where
|⟨⟩| = 0 for the empty sequence ⟨⟩ and |w| = ∞ whenever w is infinite. We also write w . w' to denote the concatenation of the two sequences, provided that the first sequence is finite, and we write w|i to denote the prefix of w of length i, i.e. w|i = ⟨w1 ... wi⟩, provided that 0 ≤ i ≤ |w|.
Formalizing protocols requires defining the sequences of actions (s, r, and f) taken by each principal running the protocol. In the concrete case of the NSPK protocol, there are two participants playing in two roles, an initiator and a responder, represented respectively by a and b. Their roles correspond to the execution of the two sequences of actions shown in Fig. 2: i nit-run, by the principal named a, and r esp-run, by the principal named b. We say that these runs are symbolic as they contain variables which can be instantiated to generate sequences of concrete message exchanges, i.e. concrete protocol runs. Looking at these two sequences, it is immediately apparent that they prop- erly represent the behavior of the protocol participants playing in the respec- tive roles. In particular, given the available information at each step: (i) the content of each of the received messages can be decomposed and checked, and
(ii) each of the sent messages can be constructed.
Message forwarding
Things are generally not as simple as in the NSPK protocol. In fact, in Alice&Bob–style protocol descriptions, it is left implicit that certain messages should be analyzed after they are received, and their contents checked, while other messages must be synthesized before they are sent. Clearly, a participant in NSPK must analyze the content of every message he receives in order to be able to send his next message. However, this may not always be the case, as we illustrate by means of another concrete example: in Fig. 3 we present the Otway-Rees Authentication/Key-Exchange Protocol (OR) [6], where an initiator a and a responder b attempt to mutually authenticate each other


Fig. 3. The Otway-Rees Authentication/Key-Exchange Protocol (OR).

and exchange a shared key Kab with the help of a server s, with whom they respectively share the keys Kas and Kbs (i is a run identifier, contained in all of the four messages). A direct transcription of messages into actions, as done with NSPK, yields the sequence of actions r esp-run shown on the left of Fig. 4. Note that, in contrast to the NSPK example, this sequence does not properly represent the expected behavior of the responder. The problem is with b’s first action in the run, where he receives i; a; b; {n1; i; a; b}Kas . Because he does not possess the key Kas, he cannot check that the fourth part of this message is of the form {n1; i; a; b}Kas , i.e. the concatenation of the plaintext i; a; b with some nonce n1 generated by a.
In this protocol, we must interpret the submessage {n1; i; a; b}Kas differ- ently. For b, this submessage is opaque: it represents a chunk of information that he cannot decompose. In this protocol, he should simply forward this chunk to s in the second step just as he must later forward to a the sub- message {n1; Kab}Kas that he receives from s. The proper way of formally representing such situations is to replace these chunks by new message vari- ables in b’s actions, as shown in the symbolic run r esp-possrun on the right of Fig. 4 using the new message variables m1 and m2. 4
The use of message variables allows us to represent message forwarding when translating Alice&Bob–style protocol descriptions into formal models. The symbolic run r esp-possrun allows m1 and m2 to be instantiated with

4 We proceed similarly in the case of asymmetric encryption. For instance, in
a → b : (n1, n2). {a; n1; c}Kb ; {a; b; n1; n2}Kc
b → c :	a; b; n1; {a; b; n1; n2}Kc

b is not supposed to check the contents of {a; b; n1; n2}Kc in the message that he receives. Not only is b not supposed to have K−1 to decrypt the message, but he also cannot re- produce the message (i.e. compose it himself) since he should not possess n2. Indeed, for b, this could just be any message that he later forwards to c. If we introduce a new variable m to represent that message, then the possible runs of b should start with the more general r({a; n1; c}Kb ; m) followed by s(a; b; n1; m, c) instead of the two actions r({a; n1; c}Kb ; {a; b; n1; n2}Kc ) and s(a; b; n1; {a; b; n1; n2}Kc , c).

r esp-run :	r esp-possrun :
⟨r(i; a; b; {n1; i; a; b}Kas ) .	⟨r(i; a; b; m1) .
f(n2) .	f(n2) .
s(i; a; b; {n1; i; a; b}Kas ; {n2; i; a; b}Kbs , s) .	s(i; a; b; m1; {n2; i; a; b}Kbs , s) .
r(i; {n1; Kab}Kas ; {n2; Kab}Kbs ) .	r(i; m2; {n2; Kab}Kbs ) .
s(i; {n1; Kab}Kas, a)⟩	s(i; m2, a)⟩

Fig. 4. The responder runs of OR.

messages that do not conform to the prescribed structure — the symmetric encryption of a nonce concatenated with the plaintext submessage at the be- ginning of the message — as the principal playing the responder role cannot tell the difference. We will show how to obtain, in general, the correct sequence of actions, i.e. the correct symbolic run, in a rigorous way.
Conditional abortion
In general, we will require that principals proceed eagerly and always check the contents of an encrypted or hashed message as soon as this is possible (if it is ever possible at all). For example, an encrypted message {M }K shall thus only be treated as such if the principal has the key to decrypt it, K−1, or the ability to build it from M and K. Note that it is possible that such an encrypted message can only be analyzed sometime later. If that is the case, we assume that the principal will carry out this analysis, and abort the protocol run if the contents were not as expected.
For concreteness, observe that participants accumulate data incrementally during each protocol run. Hence, when new data is received, a principal may only then be able to determine that some previously received message does not have the required structure and hence abort the protocol. Consider, for instance, a situation where a principal A receives a message containing a submessage {M }K encrypted with a symmetric key K that A does not possess. Furthermore, suppose that, in some later step, A is sent K (or receives enough information to compose it herself) and can thus decrypt {M }K. In this case, A should abort the execution of the protocol whenever M does not conform to the protocol description (for example, it is not a nonce that A generated and sent to some other agents earlier in the protocol run). 5

5 As an example involving asymmetric encryption, consider the following extension of the


(asw1)	a → b	:	(n1). {Ka; Kb; t; H(n1)}K−1
(asw2)	b → a	:	(n2). {{Ka; Kb; t; H(n1)}K−1 ; H(n2)}K−1
a	b
(asw3)	a → b	:	n1
(asw4)	b → a	:	n2
Fig. 5. The Exchange Subprotocol of the ASW Protocol, simplified.
To give an example of where a similar situation occurs with message hashes, consider the ASW Protocol, an optimistic fair-exchange protocol for contract signing proposed by Asokan, Shoup and Waidner in [2]. Fig. 5 displays (a slightly simplified version of) the Exchange Subprotocol of ASW. The idea is that if two honest participants execute this subprotocol, and there are neither network failures nor intruder intervention, then afterwards both will possess a valid contract. We write t to denote the contract text, and write {M }K−1 to denote the digital signature of message M by principal a, whose public key for signature verification is Ka. The principals a and b generate nonces N1 and N2, which are called their respective secret commitments to the contract. Given these, they compute their public commitments by hashing these values, yielding H(N1) and H(N2), respectively. The protocol then proceeds in two rounds: in the first, each principal expresses his public commitment to the agreed-upon contract but does not disclose his secret commitment. In the second round, they then exchange their respective secret commitments. Each principal can then hash the secrecy commitment received and verify that it indeed corresponds to the public commitment from the first round. At the end of this exchange, each principal possesses a valid standard contract of the
form {Ka; Kb; t; H(n1)}K−1 ; {{Ka; Kb; t; H(n1)}K−1 ; H(n2)}K−1 ; n1; n2.
a	a	b
Fig. 6 displays the responder run r esp-run (written horizontally for the
sake of readability). As with the OR protocol, this sequence does not properly represent the expected behavior of the responder. The problem is that before carrying out the action r(n1), the principal b cannot check the structure of the submessage H(n1), even though he knows the hash function H. Therefore, until n1 is received, the submessage H(n1) is again just an opaque chunk of

message exchanges of Footnote 4:
a → b : (n1, n2). {a; n1; c}Kb ; {a; b; n1; n2}Kc
b → c :	a; b; n1; {a; b; n1; n2}Kc
c → b :	{n2}Kb

After b receives the message from c, he can check that the m that he previously received and forwarded to c has indeed the required format. In this case, b’s checking of the message can take place not because b has possession of K−1, but rather because he now has n2 and thus he can construct the message {a; b; n1; n2}Kc and compare it with m.

r esp-run :
⟨r({Ka; Kb; t; H(n1)}K−1 ) .  f(n2) .s({{Ka; Kb; t; H(n1)}K−1 ;  H(n2)}K−1 , a) .r(n1) .  s(n2, a)⟩
a	a	b
r esp-possrun :
⟨r({Ka; Kb; t; m1}K−1 )⟩
⟨r({Ka; Kb; t; m1}K−1 ) .	f(n2)⟩
⟨r({Ka; Kb; t; m1}K−1 ) .	f(n2) .s({{Ka; Kb; t; m1}K−1 ;	H(n2)}K−1 , a)⟩
a	a	b
⟨r({Ka; Kb; t; H(n1)}K−1 ) .  f(n2) .s({{Ka; Kb; t; H(n1)}K−1 ;  H(n2)}K−1 , a) .r(n1)⟩
a	a	b
⟨r({Ka; Kb; t; H(n1)}K−1 ) .  f(n2) .s({{Ka; Kb; t; H(n1)}K−1 ;  H(n2)}K−1 , a) .r(n1) .  s(n2, a)⟩
a	a	b
Fig. 6. The responder runs of ASW.
information to be stored. However, when receiving n1, b should hash it and abort the protocol execution if it does not coincide with the opaque submessage previously stored. In this case, he should not even execute the last sending action of the run. This kind of problem is standard for protocols involving commitments to values by principals.
We propose to tackle this conditional abortion problem, as well as the mes- sage forwarding problem we described in the previous subsection, by introduc- ing incremental symbolic runs. In these runs, we use variables to represent opaque submessages (as explained before), and we characterize each of the execution steps in order to build a collection of symbolic subruns of increasing lengths, where the structure of messages reflects the growth of the relevant data during protocol execution. Said another way, the structure of messages in each subrun reflects the data possessed by the principals up to that point in the execution. To illustrate this, the proper way of formally representing the responder run of the ASW protocol is, instead of r esp-run, the sequence r esp-possrun of subruns (a sequence of sequences, of growing length) shown in Fig. 6.
We will now formalize these intuitive explanations and notions.

Incremental symbolic runs
The direct-compilation approach
In general, a protocol description in Alice&Bob–notation involves j princi- pal variables a1,... , aj, corresponding to j distinct protocol participants, each playing a role, and k number variables n1,... , nk. We write Part =
{a1,... , aj} to denote the set of all protocol participants. A protocol descrip- tion consists of a sequence ⟨step1 ... stepm⟩ of message exchange steps, each of the form
(stepq )	xs → xr : (nq1 ,... , nqt ). M ,


where xs /= xr and M includes at least all of nq1 ,... , nqt but can also involve any of the number variables generated in previous steps, as well as any of the principal variables identifying the protocol participants. The variables nq1 ,... , nqt are supposed to represent values that must be freshly generated by xs just before the message M is sent to xr. We will assume that these values are fresh, i.e. that they do not occur in any message of the preceding steps of the protocol description, nor in the inverse of any of its submessages. This means that the new numbers have not appeared before and cannot be used to generate the inverse of any key already used.
These steps are meant to prescribe a sequence of actions to be executed by each of the participants in a run of the protocol. Let us assumed fixed a protocol description in the following definition and in the remainder of the paper, so that, for example, we simply speak of “the participants” meaning the participants of the given protocol.
Definition 3.1 Let x ∈ Part. The sequence of actions corresponding to the execution of x’s role in the protocol is x-run = stepx .···. stepx , where stepx

is deﬁned by
1	m	q


stepx =
⎧⟨f(nq1 ) ... f(nqt ) . s(M, xr)⟩	if x = xs,
⟨r(M )⟩	if x = xr,
⎪⎩⟨⟩	otherwise.

We call this the direct-compilation approach as x-run directly formalizes the sequence of actions to be executed by the protocol role, as described in the Alice&Bob–style protocol description (cf. the x-runs in Fig. 2, Fig. 4, and Fig. 6). However, as we remarked in the previous sections, a symbolic run such as x-run may not be enough, not only because it does not take message forwarding and conditional abortion into account, but also because it may happen that the correct partial executions of a run cannot be modeled simply by considering prefixes of x-run.
The knowledge of principals
The construction should therefore be guided by the role-relevant data that each principal collects during his run of the protocol. In general, messages are analyzed (decomposed) and synthesized (composed) by following simple rules.
Definition 3.2 Let S be a set of messages. The set analyz(S) is the least superset of S closed under the rules

M1; M2 , M1
M1; M2 , M2
{M }K	K−1
,
M


and the set synth(S) is the least superset of S closed under the rules
 M1	M2 	M	K	M
,	,	.

M1; M2
{M }K
H(M )

The least superset of S closed under the analysis and synthesis rules is denoted by close(S).
It is quite straightforward to show that if one does not allow encryption using composed messages as keys, i.e. if one considers only atomic keys, then close(S) = synth(analyz(S)). Below, we will also identify another situa- tion where this is true. In general, however, synth(analyz(S)) close(S), that is, the inclusion is proper. For instance, if S contains just the mes-
sage M1; {M }(M1 ;M1)−1 then M ∈ close(S) but M ∈/ synth(analyz(S)). If
S = close(S) then we shall say that S is a closed set of messages.
For a given x ∈ Part, assume now that x-run = ⟨a1,... , as⟩. For 1 ≤ i ≤ s, we want to define x-possruni as the view that x has of his run up to the ith action, as explained above. Of course, we must rely on the data that x collects during the actions he took up to that point in the run, assuming that he knows some initial protocol-relevant data. If we call this data Di , then we can visualize the evolution of data sets during x-run = ⟨a1,... , as⟩ as follows:


  a1	
D0	 D 1
a2	 D 2

a3	 . . . 
as−1

 D s−1
as	 D s	.


x	x	x	x	x
Obviously, Di ⊆ Di+1 and D0 should consist of only the protocol-relevant
x	x	x
data that the principal x holds before he starts his role of the protocol, e.g. the
identities of the participants, their public keys, and x’s own private and shared

keys. Then Di+1 constitutes the extension of Di
by the new information that

x	x
x gets by executing the action ai+1. It should be clear that nothing new is
obtained by sending a message.
Definition 3.3 The data collected by a principal executing an action a is the set g ets(a) deﬁned by:
⎧⎪⎨∅	if a = s(M, y),
⎪⎩{n}	if a = f(n).
The data sets can now be defined as follows:
Definition 3.4 The sets Di , for 0 ≤ i ≤ s, are inductively deﬁned by:
D0 = close(Part ∪ {Ky | y ∈ Part}∪ {K−1}∪ {Kxy | y ∈ Part}), and
x	x


Di = close(Di−1 ∪ g ets(ai)) if i > 0.
x	x


Clearly, for every i > 0, we have that
⎧⎪Di−1


if ai = s(M, y),

Di =
close(Di−1 ∪ {M })	if ai = r(M ),
⎪⎩close(Di−1 ∪ {n})	if ai = f(n).


Executability
The construction of the sets Di completely neglects the messages that x sends during his run. This is justified: x does not learn anything by sending a message, as reflected in Definition 3.3. However, it must be the case that x can build the messages that he sends using the data currently available to him. This assumption, which is often left implicit in protocol analysis approaches, can be formalized in the present setting.
Definition 3.5 The role of x is executable provided that, for every 1 ≤ i ≤ t, if ai = s(M, y) then M ∈ Di−1. The protocol is itself executable if all of its
roles are.
Although executability is somewhat orthogonal to the problem we are dis- cussing here, we will make use of it later on. From now on, in any case, we will assume that the protocol specifications that we work with are executable.

Opacity and transparency
From now on, let us also suppose that the data collected by a principal x up to a given point in the execution of his role is the closed set D. We can now define when the precise form of a message can be understood by a principal. Indeed, as we have seen in previous examples, it may be that the actual form of some messages cannot be understood given the available data. To provide an adequate symbolic treatment of messages, we introduce new message variables mM for each encrypted or hashed submessage, respectively M = {M '}K or M = H(M '). These are precisely the (sub)messages that are opaque to a principal, in the sense that the currently available data does not allow him to “read through” (i.e. decompose) these (sub)messages, thereby recognizing their precise form and extracting their content.
Definition 3.6 The view vD(M ) that a principal has of a message M is

deﬁned inductively by
⎧⎪M	if M is atomic,
⎪⎨vD(M1); vD(M2)	if M = M1; M2,
H(vD(M1))	if M = H(M1) and M1 ∈ D,
⎪⎩mM	otherwise.
It is clear that if a message variable mM occurs in vD(M ') then M must be an opaque submessage of M '. Note that the converse is false because an opaque submessage need not be outermost. For instance, v∅(H(H(M ))) = mH(H(M)), where of course mH(M) does not occur. This happens, despite the fact that H(M ) is a submessage of H(H(M )), because H(M ) appears only inside H(H(M )) which is itself opaque.
We now define what it means for a message to be transparent or opaque, given D.
Definition 3.7 A message M is D-transparent if vD(M )= M and D-opaque
if vD(M )= mM .
We will also say that a set of messages S is D-opaque, or D-transparent, provided that all the messages in S are. In case D is itself D-transparent, we will simply refer to D as transparent. Note that it follows from Definition 3.6 that M is D-opaque precisely when M = {M1}K, K−1 ∈/ D and {M1, K} ¢ D,
or else if M = H(M1) and M1 ∈/ D. Obviously, given the definitions, D-
transparency is related to the absence of D-opaque submessages. By induction on the structure of messages, we can prove:
Proposition 3.8 A message M is D-transparent if and only if sub(M ) does not contain D-opaque elements.
To better understand how the view that a principal has of a message may evolve, we also prove:
Proposition 3.9 Let D ⊆ D', with D' closed. Given a message M ' the following are equivalent:
vD(M ')= vD' (M '),
if mM occurs in vD(M ') then it also occurs in vD' (M '),
if mM occurs in vD(M ') then M is D'-opaque.
The implications from (i) to (ii) and (ii) to (iii) are straightforward. A simple induction on the structure of M ' establishes the implication from (iii) to (i).


Note that if D ⊆ D' then it is immediate that D'-opaque messages are also D-opaque. Hence, as a corollary of the previous proposition, if D'' is also closed and D ⊆ D' ⊆ D'' then vD(M ') = vD'' (M ') implies that vD(M ') = vD' (M ')= vD'' (M ').
The following proposition tells us that if an opaque message does not appear as a submessage of any message in a set S, then it cannot appear as a submessage of any message in close(S).
Proposition 3.10 Let M be a D-opaque message and let S ⊆ D. Then,
M ∈ sub(close(S)) if and only if M ∈ sub(S).
The direct implication follows by induction on the closure rules; it suffices to show that all the rules preserve the absence of M as a submessage of the messages involved. The converse implication is trivial due to the monotonicity of sub and the reflexivity of close.
Proposition 3.10 has the next two propositions as immediate corollaries.
Proposition 3.11 If S is a set of atomic messages then close(S) is transpar- ent.
Note that, by definition, atomic messages are always transparent. Hence, if S is a set of atomic messages then sub(S) = S does not contain opaque elements. Therefore, Proposition 3.10 implies that also sub(close(S)) does not contain opaque elements. Finally, Proposition 3.8 guarantees that close(S) is transparent.
Proposition 3.12 Let M ' be a message and D' = close(D ∪ {M '}). If D is transparent then, D' is transparent if and only if M ' is D'-transparent.
By induction on the structure of messages, we can obtain a result similar to the one in Proposition 3.10 that explains how message variables appear during protocol execution:
Proposition 3.13 Let S be a set of messages and D' = close(D ∪ S). If

M ' ∈ D', M
vD' (S).
∈/ sub(D), and mM occurs in vD' (M ') then mM also occurs in

To conclude this sequence of technical results, we consider what happens to the notion of opacity when D is augmented, not by an arbitrary message, but by a fresh number. (Recall that freshness means that the value does not occur in any previous message, nor in the inverse of a submessage of any previous message.)
Proposition 3.14	Let n be a number variable such that n ∈/ sub(D ∪
sub(D)−1), and D' = close(D ∪ {n}). If M ∈ sub(D) and M is D-opaque,

then M is also D'-opaque.
Incremental runs
Our aim now is to define the sequence of symbolic runs of growing length that adequately models the execution of each role of the protocol. For each participant x, we need to pick each prefix of x-run and apply to it the view that results from the data x possesses up to that point in the execution. For this purpose, we extend the definition of the view v to actions and sequences of actions in the natural way.
Definition 3.15 Let x ∈ Part. If s = |x-run|, then the sequences of actions corresponding to the (possibly partial) execution of x’s role of the protocol are x-possrun1,... , x-possruns, where x-possruni = vDi (x-run|i) for 1 ≤ i ≤ s.
In general, x-run can be understood as a perfect description of a complete run of the protocol for participant x, which complies to the protocol descrip- tion in a full, although maybe not realizable, way. In contrast, x-possruns can be understood as the possible, though maybe imperfect, complete run, in the sense that it correctly models the execution of each role of the protocol taking into account the available data and the way messages can be manipulated.
Still, in some cases, the direct approach of just considering x-run (and its prefixes) “works fine”, in the sense that, for each role, the perfect complete run is representative of all possible partial runs. More precisely, x-run is representative if x-possruni = x-run|i for every 1 ≤ i ≤ s. This certainly holds true in the case of NSPK, but the same cannot be said about OR and ASW. Below, we provide a complete characterization of the situations when the direct-compilation approach works.
Proposition 3.16 The sequence x-run is representative if and only if every received message is transparent when it is received, i.e. if ai = r(M ), then M is Di -transparent.
The direct implication is straightforward, and the converse follows by in- duction on the sequence of actions in the execution of each role, by exploiting Propositions 3.11 and 3.12.
Cases such as that of the OR protocol, however, still maintain some of the regularity of the simplest cases, namely the absence of abortion conditions. Indeed, the complete possible run x-possruns is still representative of all the others, that is, x-possruni = x-possruns|i for every 1 ≤ i ≤ s. The next proposition gives us a precise characterization of these situations.
Proposition 3.17 The sequence x-possruns is representative if and only if every received message preserves the message variables that occur in the views


of previously received messages, i.e. if 1 ≤ j < i ≤ s, aj and ai are receiving actions, and mM occurs in vDi−1 (aj), then mM also occurs in vDi (aj).
Proposition 3.9 plays an essential role in the proof of this result. The direct implication follows easily. The converse implication follows by a careful inspection of the sequence of actions in the execution of each role, by exploiting Propositions 3.10, 3.13, and 3.14.
Note that in this case only message forwarding may be necessary. The precise meaning of forwarding can also be clarified with the help of Proposi- tions 3.9, 3.10, and 3.13, as explained in the proof of Proposition 3.17: if a sent message contains an opaque submessage M then M must also occur, and be opaque, in some previously received message.
Of the examples we have considered, ASW is the most complex one because the growth of the data available to the principal executing the role may turn opaque elements into non-opaque ones. When that happens, namely if ai is a receiving action, mM occurs in vDi−1 (aj) for some j < i but mM does not occur in vDi (aj), we claim that the protocol participant x should abort the execution of his role of the protocol whenever the actual values of mM and vDi (M ) do not coincide. This is what we call conditional abortion.

Modeling security protocols
We can now conclude our investigation of the “correct” way of modeling secu- rity protocols specified using Alice&Bob–notation. As we have shown above, making the usual assumption that the sequence x-run and its prefixes repre- sent the behavior of a principal executing the role may lead one to considering models that do not comply with all the possibilities allowed by the proto- col. Instead, we claim that all the incremental sequences x-possrun must be considered.
We now explain how to concretize the symbolic information contained in these sequences. A protocol instantiation is a variable substitution σ that assigns to each variable a ground message (that is, without variables) of the same type. Namely, σ assigns a principal identifier to each principal variable, a number to each number variable, and a message to each message variable. Moreover, σ should be injective on the protocol participants, that is, if a1 and a2 are two principal variables then σ(a1) /= σ(a2). We extend σ to messages, actions, and sequences in the natural way.
In general, if we denote the set of all protocol instantiations by Inst, the set of all possible concrete protocol runs of a principal A, in any of the j roles,
is given by Runs  =  j	 |ai-run|{σ(a -possrunl) | σ ∈ Inst, σ(a )= A}.
Denotational protocol models, for instance, should then be built by choos-


ing, for each principal A, a set of (prefixes of) concrete sequences in RunsA. For example, in strand spaces, each of these sequences should correspond to a strand.
In operational protocol models, on the other hand, the abortion conditions
come into play in a meaningful way. In this case, it suffices to execute, step- wise, the sequence σ(⟨vD1 (a1),... , vDs (as)⟩), and to guard the execution of
x	x
each action with a condition whose failure should lead to abortion. For in-
stance, σ(vDi (ai)) can occur, after the sequence σ(⟨vD1 (a1),... , vDi−1 (ai−1)⟩)
is complete, but only if σ(mM ) = σ(vDi (M )) for each message variable mM
that has appeared so far. A full-fledged formalization of this process would require a more accurate representation of the principals’ activity by employing additional internal actions. We leave this for future work.

Concluding remarks
We have shown that, despite the fact that the Alice&Bob–notation does not include explicit control flow constructs, it is possible to make aspects such as message forwarding and conditional abortion explicit when producing formal protocol models without having to resort to more expressive protocol descrip- tion languages. In particular, we have shown that, when considering such aspects, the direct-compilation approach does not correctly formalize all the possible behaviors of the principals, for which incremental symbolic runs are required.
Several expressive protocol specification languages have been proposed to make explicit what is left implicit (or even unspecified) in Alice&Bob–style descriptions. Some of the problems that we have investigated here have also been considered for other specification languages. For instance, the syntax of Casper [10] includes a “%”-notation for representing unreadable messages by means of variables. The introduction of this notation requires an explicit extension of the standard Alice&Bob–notation and direct assistance by the user in writing protocol descriptions. In contrast, we have shown how to automatically handle opacity without changing the notation or involving the user by instead changing the interpretation of the terms used in Alice&Bob– notation.
The way we define the view that a principal can have of a message given his current knowledge is similar to the message patterns considered by Abadi and Rogaway in [1], albeit for a rather different purpose (reconciling cryp- tographic and formal methods protocol analysis approaches). The main dif- ference is that we distinguish between distinct opaque elements by means of distinct variables, whereas Abadi and Rogaway use only one variable (their


“box” symbol). This difference reflects the different objectives: Abadi and Ro- gaway aim to define a notion of equivalence between messages up to opaque submessages, while we are interested in describing precisely all the possible concrete instances of messages that match the pattern. In this sense, different variables can be given different values, which cannot be done if we use the same variable. Moreover, even if two messages are opaque, one can certainly still compare them and check if they are equal.
In §3.6, we have also briefly hinted at how our work could be integrated with the strand space protocol analysis approach. Capturing the non-determi- nism that results from message forwarding and conditional abortion would not require an enrichment of the strand space approach itself; rather, one could just enlarge the number of strands in the space that models the protocol under consideration. However, in the general case, i.e. for protocols with explicit control flow, the extension of strand spaces with a notion of conflict as suggested in [7,9] seems to be the only option.
As we have previously remarked, we have only focused in this paper on sending and receiving messages and generating fresh numbers. However, other internal actions (e.g. corresponding to the application of cryptographic oper- ations) can be modeled similarly and our results extended straightforwardly. Such an extension would allow us to fully formalize the process of compiling messages to sequences of actions and thus extend the ideas described in §3.6 to directly build analysis tools based on them. We also believe that incremental symbolic runs will provide a good basis for generating protocol implemen- tations from Alice&Bob-style descriptions that explicitly carry out necessary executability and abortion tests.

References
M. Abadi and P. Rogaway. Reconciling two views of cryptography (the computational soundness of formal encryption). Journal of Cryptology, 15(2):103–127, 2002.
N. Asokan, V. Shoup, and M. Waidner. Asynchronous protocols for optimistic fair exchange. In Proc. IEEE Symposium on Research in Security and Privacy, pages 86–99, 1998.
C. Caleiro, L. Vigan`o, and D. Basin. Deconstructing Alice and Bob (extended version). Technical Report 486, Department of Computer Science, ETH Zurich, 2005.
C. Caleiro, L. Vigan`o, and D. Basin. Metareasoning about Security Protocols using Distributed Temporal Logic. In Proc. IJCAR’04 Workshop on Automated Reasoning for Security Protocol Analysis (ARSPA’04), pages 67–89. ENTCS 125(1), 2005.
Y. Chevalier, L. Compagna, J. Cuellar, P. Hankes Drielsma, J. Mantovani, S. M¨odersheim, and
L. Vigneron. A High Level Protocol Specification Language for Industrial Security-Sensitive Protocols. In Proc. SAPS’04. Austrian Computer Society, 2004.
J. Clark and J. Jacob.	A Survey of Authentication Protocol Literature: Version 1.0,
17. November 1997. URL: www.cs.york.ac.uk/∼jac/papers/ drareview.ps.gz.


F. Crazzolara and G. Winskel. Composing strand spaces. In Proc. FST TCS 2002, LNCS 2556, pages 97–108. Springer-Verlag, 2002.
D. Dolev and A. Yao. On the security of public key protocols. IEEE Transactions on Information Theory, 29(2):198–208, 1983.
J. Y. Halpern and R. Pucella. On the relationship between strand spaces and multi-agent systems. ACM Trans. Info. and System Security, 6(1):43–70, 2003.
G. Lowe. Casper: a Compiler for the Analysis of Security Protocols. Journal of Computer Security, 6(1):53–84, 1998.
L. Paulson. The inductive approach to verifying cryptographic protocols. Journal of Computer Security, 6:85–128, 1998.
P. Ryan, S. Schneider, M. Goldsmith, G. Lowe, and B. Roscoe. Modelling and Analysis of Security Protocols. Addison Wesley, 2000.
F. J. Thayer F´abrega, J. C. Herzog, and J. D. Guttman. Strand spaces: Proving security protocols correct. Journal of Computer Security, 7:191–230, 1999.
