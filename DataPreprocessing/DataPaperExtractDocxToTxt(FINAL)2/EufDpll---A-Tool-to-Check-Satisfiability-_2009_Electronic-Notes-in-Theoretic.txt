

Electronic Notes in Theoretical Computer Science 225 (2009) 405–420
www.elsevier.com/locate/entcs

EufDpll - A Tool to Check Satisfiability of Equality Logic Formulas
Olga Tveretina 1
Institute for Computing and Information Sciences, Radboud University,
Nijmegen, The Netherlands
Wieger Wesselink 2
Department of Computer Science TU Eindhoven
Eindhoven, The Netherlands

Abstract
Decision procedures for subsets of First-Order Logic form the core of many verification tools. Applications include hardware and software verification. The logic of Equality with Uninterpreted Functions (EUF) is a decidable subset of First-Order Logic. The EUF logic and its extensions have been applied for proving equivalence between systems. We present a branch and bound decision procedure for EUF logic based on the generalisation of the Davis-Putnam-Loveland-Logemann procedure (EUF-DPLL). EufDpll is a tool to check satisfiability of EUF formulas based on this procedure.
Keywords: equality logic with uninterpreted functions, satisfiability, DPLL procedure.


Introduction
Equality logic with uninterpreted functions (EUF) is a major decidable theory used in verification of infinite-state systems [9]. The functions are termed “uninterpreted” because the only thing we know about them is that two applications of a function to the same arguments will produce the same value. An EUF formula is a boolean formula over atoms that are equalities between terms. In this logic, formulas have truth values while terms have values from some domain. For example, the formula: f (x) /≈f (z) Λ x ≈ y Λ y ≈ z is unsatisfiable.

1 Email: o.tveretina@cs.ru.nl
2 Email: j.w.wesselink@tue.nl

1571-0661/© 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.12.089

The GDPLL procedure [2] is a generalisation of the well-known DPLL proce- dure [6] which was introduced in the early 60s as a proof procedure for first-order logic. The GDPLL procedure is defined in terms of four basic operations (REDUCE, Eligible, SatCriterion and Filter), that have to be filled in for a particular logic. An original DPLL procedure is an instance of GDPLL in case of propositional logic.
The satisfiability problem for EUF logic naturally fits into the GDPLL frame- work. In this paper we provide an algorithm for this logic which is an instance of GDPLL. Since the algorithm is an instance of GDPLL, we have to check its soundness and completeness by verifying the conditions mentioned in Section 3.
EufDpll is a tool to check satisfiability of formulas in the logic of equality with uninterpreted functions. It is based on the presented theoretical framework. As the programming language was used C + + and the ATerm library. The ATerm imple- mentation is based on maximal subterm sharing and automatic garbage collection. Therefore, syntactical identity of terms can be checked in constant time.
Applications
Testing and verification are the bottleneck of development of complex systems. This applies, in particular, to hardware and software systems. Recently theorem provers were used to verify a pipelined microprocessor. The method proposed by Burch and Dill [5] greatly enhanced verification techniques. The state of a register at any point in the computation can be represented by a symbolic term. Uninterpreted functions can be used to abstract blocks of combinational logic, for example ALU, as black boxes. Uninterpreted functions without arguments are considered as term variable and can be used to abstract constant values that have special semantic meaning,
e.g. the data value 0. So the logic of equality with uninterpreted functions provides a means of abstracting the manipulation of data by a processor when verifying the correctness of its control logic.
The behaviour of software is much more complex than that of hardware due to the potentially enormous state space of a program. The development of powerful and complex software systems requires more sophisticated methods than traditional techniques to ensure functional correctness of the code. Software systems grow in scale and functionality. As a result of increasing complexity, the likelihood of errors is much greater. Hence, formal verification has become an increasingly important technique to establish the correctness of designs. Reasoning precisely about program operators is in general undecidable. A common practice is to model n−ary operators
as an uninterpreted function under the theory of equality. EUF-logic was used
for translation validation [13,12,14,15], i.e checking the correctness of a compiler’s translation by verifying the equivalence between the source and target codes.
In general, this type of logic is mainly used for proving the equivalence between systems. The method has two phases: the first phase consists of the construction of a logical formula which is valid if and only if the implementation is correct with respect to the specification. While verifying the equivalence between two formulas, it is possible to replace all functions, except the equality sign and propositional op- erators, with uninterpreted functions. During the second phase a decision procedure

checks validity of the formula. The validity problem for this logic is decidable.

Related work
In the past years, various procedures for checking the satisfiability of such formulas have been suggested. Barrett et al. [3] proposed a decision procedure based on computing the congruence closure in combination with case splitting.
In [1] Ackermann showed that the problem of deciding the validity of an EUF formula can be reduced to checking the satisfiability of an equality formula. Many current approaches [7,4] use a transformation of an EUF formula into the equality logic formula. Then the equality logic formula can be transformed into a propo- sitional one and a standard satisfiability checker can be applied. Goel et al. [7] and Bryant et al. [4] reduced an equality formula to a propositional one by adding transitivity constraints. In this approach it is analyzed which transitivity properties may be relevant.
A different approach is called range allocation [13,15]. In this approach a formula structure is analyzed to define a small domain for each variable. Then a standard BDD-based tool is used to check satisfiability of the formula under the domain.
Another approach is given in [8]. This approach is based on BDD computation, with some extra rules for dealing with transitivity. Unfortunately, the unicity of the reduced BDDs is lost.
An approach based on the DPLL procedure for EUF is introduced in [10,11]. The proposed DPLL procedure calls the congruence closure module for positive equations.

Basic definitions and preliminaries
Syntax
EUF formulas can be seen as propositional combinations of equalities between terms. The terms are defined recursively as following.
Definition 2.1 (Terms, subterms)
Given a signature Σ = (Fun, ar), the set Term(Σ) of terms, or for simplicity Term, over Σ is defined recursively: for n ≥ 0, f (t1,... , tn) is a term if t1,... , tn are terms, f ∈ Fun, and ar(f )= n.
We use the lower case letters s, t, and u to denote terms.
For each term f (t1,... , tn) ∈ Term, n ≥ 0, the set SubTerm(f (t1,... , tn)) of
subterms of f (t1,... , tn) is defined recursively:

n
SubTerm(f (t1,... , tn)) = {f (t1,... , tn)}∪	SubTerm(ti).
i=1
Formulas are defined recursively as follows.

Definition 2.2 An EUF formula is defined as follows:
formula:= formula ∨ formula | ¬ formula | atom atom:= term≈term
term:= variable | function (list of terms),
where variables are defined over some (possibly infinite) domain.
In the following by an EUF-CNF we mean an EUF formula in conjunctive nor- mal form. The set of all EUF-CNFs is denoted by EUF-Cnf. An EUF-CNF is a conjuction of clauses, where each clause is a disjunction of literals. We will rep- resent these conjunctions and disjunctions using set notation. In the remainder literals s ≈ t and s /≈t are considered to be unordered, meaning that they are
equivalent to t ≈ s and t /≈s respectively.
Semantics
Let At be a set of atoms.
We define an interpretation as a function
I : At → {true, false}.
A literal l is true in I iff either l is an atom a and I(a) = true or l is a negated atom ¬a and I(a)= false. We write I |= l, if a literal l is true in I.
We define an E-interpretation as one satisfying the following conditions.
I |= t ≈ t;
if I |= s ≈ t then I |= t ≈ s;
if I |= s ≈ u and I |= u ≈ t then I |= s ≈ t;
if I |= si ≈ ti for all i ∈ {1,... , n} then I |= f (s1,... , sn) ≈ f (t1,... , tn).
We write I |= φ if a formula φ is true in I.
Definition 2.3 A formula φ is called satisfiable if I |= φ for some E-interpretation I. Otherwise φ is called unsatisfiable. By definition the empty clause ⊥ is unsatisfiable.
We will use throughout the paper the following notations. Let t /S∈ubTerm(s). Then φ[t := s] denotes a formula φ that is obtained from φ by substituting recur- sively occurrences of the term t by the term s till no occurrences of t are left.
Example 2.4 Let us consider φ = {{f (f (x)) ≈ y}, {x ≈ g(y)}}.
Then φ[f (x) := x]= {{x ≈ y}, {x ≈ g(y)}}.
We define φ|l = {C − {¬l}| C ∈ φ, l /C∈}.
Example 2.5 Let us consider φ = {{x ≈ f (y),z ≈ g(z)}, {x /≈f (y),y ≈ g(z)}}.
Then φ|x≈f(y) = {{y ≈ g(z)}}.
In the following by Lit(φ) and by Term(φ) we mean, correspondingly the set of literals contained in φ and the set of terms in φ.

Generalization of DPLL
The DPLL procedure, due to Davis, Putnam, Logemann, and Loveland, is the basis of some of the most successful propositional satisfiability solvers. The original DPLL procedure was developed as a proof-procedure for first-order logic. It has been used so far almost exclusively for propositional logic because of its highly inefficient treatment of quantifiers. In this chapter we sketch the basic ideas of GDPLL, the general version of the DPLL procedure. For a full description the reader is referred to [2].
The DPLL algorithm is a complete, backtracking-based algorithm for deciding the satisfiability of propositional logic formulas in conjunctive normal form. It consists of the following three rules: the unit clause rule, the splitting rule, and the pure literal rule. These rules reduce a formula according to some criteria. Therefore, a function REDUCE which performs all rules for formula reduction is assumed. Like DPLL, GDPLL has a splitting rule, which carries out a case analysis with respect to an atom a.
As it is defined in [2], we assume a function REDUCE : Cnf → Cnf where Cnf
denotes the set of formulas in Conjunctive Normal Form. We define the set R =
{ϕ ∈ REDUCE(Cnf) | ⊥ /ϕ∈}.
In the following we also assume functions
Eligible : R → At,
SatCriterion : R → {true, false},
Filter, where Filter(ϕ, a) is defined for ϕ ∈ R and a ∈ Eligible(ϕ).
In [2] the following requirements on the above functions are introduced: for all ψ ∈ Cnf, for all ϕ ∈ R, and for all a ∈ Eligible(ϕ) the functions should satisfy the following properties.
REDUCE(ψ) is satisfiable iff ψ is satisfiable,
ϕ is satisfiable iff at least one of Filter(ϕ, a) or Filter(ϕ, чa) is satisfiable,
REDUCE(Filter(ϕ, a)) < ϕ and REDUCE(Filter(ϕ, чa)) < ϕ, for some well- founded strict order < on REDUCE(Cnf).
if SatCriterion(ϕ)= true then ϕ is satisfiable,
if SatCriterion(ϕ)= false then Eligible(ϕ) /=∅.
The algorithm is represented in Figure 1. The procedure takes as an input ϕ ∈ Cnf. GDPLL proceeds until either the function SatCriterion has returned true for at least one branch, or the empty clause has been derived for all branches. Respectively, either SAT or UNSAT is returned.

The reduction rules
The function REDUCE is defined by means of a set of reduction rules, that can be applied in any order. In this section we define reduction rules for EUF-CNFs.



GDPLL(ϕ): {SAT, UNSAT} =
begin
ϕ := REDUCE(ϕ);
if (⊥ ∈ ϕ) then return UNSAT;
if (SatCriterion(ϕ)) then return SAT;
choose a ∈ Eligible(ϕ);
if GDPLL(Filter(ϕ, a)) = SAT then return SAT;
if GDPLL(Filter(ϕ, чa)) = SAT then return SAT; return UNSAT;
end;

Fig. 1. The GDPLL procedure
Starting with an arbitrary CNF, we can simplify all clauses contained in it.
Definition 4.1 (Simplified clauses)
Suppose C is a clause. By C ↓ we mean the normal form obtained from C after applying the following simplification rule.
C → C\{t /≈t} if for some term t, (t /≈t) ∈ C.
A clause C is called simplified if C = C ↓.
Given a CNF, we can simplify it by repeatedly applying the following simplifi- cation rules.
Definition 4.2 (Simplified CNFs)
Suppose ϕ is a CNF. By ϕ ↓ we mean the normal form of ϕ after applying the following rules.
C → C ↓ for some clause C ∈ ϕ.
ϕ → ϕ\{C} for a clause C ∈ ϕ if for some term t, (t ≈ t) ∈ C.
A CNF ϕ is called simplified if ϕ = ϕ ↓.
Now we can define a system of reduction rules. Starting with an arbitrary CNF, we can transform it by repeatedly applying the reduction rules.
We will use the notation  for disjoint union, i.e. when we write ϕ  ψ we are referring to the union ϕ ∪ ψ assuming that ϕ ∩ ψ = ∅.
Definition 4.3 (Reduction rules on CNFs) We define a reduction system for EUF-CNFs EUF-REDUCE as follows.
{{s ≈ t}} ϕ → {{s ≈ t}}  ϕ[s := t] if s, t ∈ SubTerm(ϕ) and s /S∈ubTerm(t).
ϕ → ϕ ↓.
Rule i of the reduction system EUF-REDUCE allows to substitute equals for equals. Recall that we consider literals to be unordered, so this rule applies to t ≈ s as well. Rule ii simplifies a CNF by removing all equalities of the form t ≈ t from a formula. The transformation by the reduction rules yields a logically equivalent CNF.

Definition 4.4 (Reduced EUF-CNFs) We define a reduced EUF-CNF to be a normal form with respect to the reduction system EUF-REDUCE.
By the following corollary we show which shape a reduced EUF-CNF may have.
Proposition 4.5 If ϕ is a reduced formula then the following holds.
If ϕ = {{s ≈ t}} ϕ' then either s /S∈ubTerm(ϕ') or t /S∈ubTerm(ϕ').
ϕ does not contain equalities of the form t ≈ t.
Proof. If ϕ does not satisfy i then Rule i of the reduction system EUF-REDUCE can be applied. If ϕ does not satisfy ii then Rule ii of the reduction system EUF-REDUCE can be applied.	 
We prove in Section 4.1 that the set of reduction rules is terminating, so at least one normal form exists. Unfortunately, the rules are not confluent as it is shown by the following example. So the normal form is not unique.
Example 4.6 Consider ϕ = {{x ≈ f (y)}, {x ≈ g(z)}, {f (y) ≈ h(x, z)}}.
Applying Rule i of the reduction system EUF-REDUCE on x ≈ f (y), we can replace x with f (y). Therefore, the reduced formula is
ϕ' = {{x ≈ f (y)}, {f (y) ≈ g(z)}, {f (y) ≈ h(f (y), z)}}.
We can also replace f (y) with x. The result is the reduced formula
ϕ'' = {{x ≈ f (y)}, {x ≈ g(z)}, {x ≈ h(x, z)}}.
Termination
Now we prove termination of the reduction system and of the corresponding GDPLL
procedure.
In the following we use a definition of non-propagated unit clauses, i.e. unit clauses to which Rule i of the reduction system can be applied.
Definition 4.7 (Non-propagated unit clauses)
A unit clause {s ≈ t} is called non-propagated in a CNF ϕ if
· {s ≈ t} ∈ ϕ,
· s, t ∈ SubTerm(ϕ\{{s ≈ t}}).
The set of all non-propagated unit clauses in ϕ is denoted by NPCls(ϕ).
In Definition 4.3(i) the s ≈ t is non-propagated in {{s ≈ t}} ∪ ϕ, whereas the
s ≈ t is propagated in {{s ≈ t}} ∪ ϕ[s := t]. Note that s /S∈ubTerm(ϕ[s := t]).
We start with a technical lemma which is used in Lemma 4.9 and in Theorem
4.11. Lemma 4.9 is also a technical lemma.
Lemma 4.8 Suppose s, t ∈ Term, where s /S∈ubTerm(t), and T is a set of terms. Then
|T ∪ {s, t}| ≥ |T [s := t] ∪ {s, t}|.

Proof. We can observe that for an arbitrary set of terms T ' and arbitrary terms
s', t' the following holds.
|T '| = |T '[s' := t']| if for all distinct u, v ∈ T ', u[s' := t'] /=v[s' := t'],
|T '| > |T '[s' := t]'| if there are distinct u, v ∈ T such that u[s' := t']= v[s' := t']. Hence,
|T ∪ {s, t}| = |(T \{s, t}) ∪ {s, t}|
≥ |(T \{s, t})[s := t] ∪ {s, t}|
= |T [s := t] ∪ {s, t}|	 
Lemma 4.9 Suppose ϕ, ϕ',ψ ∈ Cnf and ϕ = {{s ≈ t}} ϕ', where s, t ∈ SubTerm(ϕ') and s /∈SubTerm(t), and ψ = {{s ≈ t}} ∪ ϕ'[s := t]. Then one of the following holds.
|SubTerm(ψ)| < |SubTerm(ϕ)| or
|SubTerm(ψ)| ≤ |SubTerm(ϕ)| and |NPCls(ψ)| < |NPCls(ϕ)|.
Proof. By Lemma 4.8, |SubTerm(ψ)| ≤ |SubTerm(ϕ)|. Hence, it is sufficient to show that from |NPCls(ψ)| ≥ |NPCls(ϕ)| it follows that |SubTerm(ψ)| < |SubTerm(ϕ)|.
Suppose |NPCls(ψ)| ≥ |NPCls(ϕ)|. Then there is some C ∈ ϕ such that C /∈
NPCls(ϕ) and C[s := t] ∈ NPCls(ψ).
Suppose C has n literals, with n ≥ 2. These literals must contain at least n +1 different atoms in order for them to be different. The substitution [s := t] maps these n + 1 atoms to the 2 atoms of C[s := t]. Therefore at least two different atoms of C are mapped to the same atom of C[s := t]. From this we can conclude that
|SubTerm(ϕ)| > |SubTerm(ψ)|.
What is left is the case that C has only one literal. Suppose C = {u ≈ v}, where u, v are terms. Without loss of generality we can assume that u ∈/ SubTerm(ϕ\{C}). Since C[s := t] ∈ NPCls(ψ) there must be a clause C' ∈ ψ, C' /=C[s := t] that contains u[s := t]. Let C'' ∈ ϕ, C'' /=C be the clause of ϕ that is mapped to C' and let w be the subterm in clause C'' that is mapped to u[s := t]. Again we have found two different terms u, w ∈ SubTerm(ϕ) that are mapped to the same term u[s := t] ∈ SubTerm(ψ). Hence we can conclude that |SubTerm(ϕ)| > |SubTerm(ψ)|.
 
Definition 4.10 To each ϕ ∈ EUF-Cnf we relate a pair of numbers, using norm(ϕ) as below:
norm(ϕ)= (|SubTerm(ϕ)| + |Lit(ϕ)|, |NPCls(ϕ)|).
Theorem 4.11 The reduction system EUF-REDUCE is terminating.
Proof. We prove termination of the reduction system EUF-REDUCE by showing that after applying each step of the reduction system on a formula, norm(ϕ) de- creases with respect to the lexicographic order <lex on pairs. Suppose ϕ → ψ, with ϕ /=ψ.

Suppose ϕ = {{s ≈ t}}  ϕ', where s, t ∈ SubTerm(ϕ') and s /∈SubTerm(t), and ψ = {{s ≈ t}}  ϕ'[s := t].
Taking into account Lemma 4.8, we conclude
|Lit(ψ)| = |Lit(ϕ'[s := t] ∪ {{s ≈ t}})|
≤ |Lit(ϕ' ∪ {{s ≈ t}})|
= |Lit(ϕ)|
By Lemma 4.9, either |SubTerm(ψ)| < |SubTerm(ϕ)| or |SubTerm(ψ)| = |SubTerm(ϕ)|
and |NPCls(ψ)| < |NPCls(ϕ)|.
We obtain, that either |SubTerm(ψ)| + |Lit(ψ)| < |SubTerm(ϕ)| + |Lit(ϕ)| or
|SubTerm(ψ)|+|Lit(ψ)| = |SubTerm(ϕ)|+|Lit(ϕ)| and |NPCls(ψ)| < |NPCls(ϕ)|.
Suppose ψ = ϕ ↓. Then
|Lit(ψ)|≤ |Lit(ϕ)|− |{t ≈ t | (t ≈ t) ∈ Lit(ϕ)}| − |{t /≈t | (t /≈t) ∈ Lit(ϕ)}|
< |Lit(ϕ)|
Obviously, |SubTerm(ψ)| ≤ |SubTerm(ϕ)|. We conclude, |SubTerm(ψ)|+|Lit(ψ)| <
|SubTerm(ϕ)| + |Lit(ϕ)|.
Hence, ψ <lex ϕ.	 
We have proved that the reduction system EUF-REDUCE is terminating.

Satisfiability criterion
In this section we will consider conditions under which an EUF-CNF is satisfiable. These conditions will form a basis for the function SatCriterion.
Definition 5.1 (The core of a EUF-CNF) Let ϕ ∈ Cnf. Then the set of positive clauses (i.e. clauses consisting entirely of positive literals s ≈ t) of length at least two contained in ϕ is called the core of ϕ and denoted by Core(ϕ).
Let ϕ be a reduced EUF-CNF not containing the empty clause, such that Core(ϕ)= ∅. We will give a proof that such a EUF-CNF ϕ is satisfiable. Without loss of generality we can restrict ourselves to the case when a EUF-CNF contains only unit clauses. It follows from the fact that if there is an assignment satisfying
one literal in each clause of a CNF φ then φ is satisfiable.
The set of EUF-CNFs containing only unit clauses is denoted by UCnf.
At first we introduce two binary relations on the set of terms contained in ϕ.
Definition 5.2 Let ϕ ∈ UCnf. The binary relation ∼ϕ is the smallest relation over
Term(ϕ) × Term(ϕ) such that:
s ∼ϕ t, if {s ≈ t} ∈ ϕ.
∼ϕ is reflexive, symmetric, and transitive.
Definition 5.3 The binary relation ∼=ϕ is the smallest relation over SubTerm(ϕ) ×
SubTerm(ϕ) such that:

s ∼=ϕ t, if {s ≈ t} ∈ ϕ.
f (s1,... , sn) ∼=ϕ f (t1,... , tn), if si ∼=ϕ ti, 1 ≤ i ≤ n, and f (s1,... , sn), f (t1,... , tn) ∈ SubTerm(ϕ).
∼=ϕ is reflexive, symmetric, and transitive.
We will prove a lemma stating that for reduced CNFs the introduced binary relations are equivalent.
Lemma 5.4 Let ϕ ∈ UCnf be reduced. Then for each s, t ∈ Term
s ∼ϕ t if and only if s ∼=ϕ t.
Proof.
(⇒) Suppose s ∼ϕ t. Then by Definitions 5.2 and 5.3, we obtain s ∼=ϕ t. (⇐) Suppose s ∼=ϕ t. We give a proof by contradiction.
Assume that
s /ϕ∼t.
It means that Condition (ii) of Definition 5.3 was applied at least one time.
Without loss of generality we can assume that we applied the condition one time. Then there are
f (s1,... , sn),f (t1,... , tn) ∈ SubTerm(ϕ)
such that
si ∼ϕ ti, 1 ≤ i ≤ n.
In this case there are u0,... , un ∈ Term(ϕ) such that
{si = (u0 ≈ u1)}, {u1 ≈ u2},... , {(un−1 ≈ un)= tn} ∈ ϕ,
where i ∈ {1,... , n}.
In this case Rule i of the reduction system EUF-REDUCE would be applicable. This contradicts that ϕ is reduced. We obtain that s ∼ϕ t.	 
Lemma 5.5 Suppose ϕ ∈ UCnf, ϕ is reduced and {s /≈t} ∈ ϕ for some s, t ∈ Term. Then s ∼=/ϕ t.
Proof. At first we prove by contradiction that s /ϕ∼t. Assume that s ∼ϕ t. Then one of the following holds.
s = t. Then {s /≈s} ∈ ϕ. In this case Rule ii can be applied. This contradicts that ϕ is reduced.
There are u0,... , un ∈ Term(ϕ) such that
{s = u0 ≈ u1}, {u1 ≈ u2},... , {un−1 ≈ un = t} ∈ ϕ.
Then Rule i can be applied. This contradicts that ϕ is reduced.
We can conclude that s /ϕ∼t.
By Lemma 5.4 we obtain that s ∼=/ϕ t.	 

Theorem 5.6 ϕ ∈ UCnf is unsatisﬁable if and only if there exist s, t ∈ Term(ϕ)
such that
{s /≈t} ∈ ϕ and s ∼=ϕ t.
Proof. See [16].	 
Theorem 5.7 (Satisfiability criterion) Suppose ϕ is a reduced CNF, ⊥ /∈ϕ, and Core(ϕ)= ∅. Then ϕ is satisﬁable.
Proof. From the assumption of the theorem we conclude that every clause of length more than one contains at least one negative literal. Let ψ ∈ Cnf be obtained from ϕ by removing from all clauses all literals except one negative literal. Hence, ψ is
reduced by construction. By Lemma 5.5 and Theorem 5.6 ψ is satisfiable. We can conclude that ϕ is satisfiable also.	 

The GDPLL building blocks for the EUF-logic
We now come to the definition of the building blocks for the GDPLL procedure.
The procedure GDPLL for the EUF-logic invokes the following functions.
We define the function REDUCE(ϕ) to be any normal form of ϕ with respect to the reduction system EUF-REDUCE.
For each ϕ ∈ R, the function SatCriterion() is defined as follows:
SatCriterion(ϕ)=	true	if Core(ϕ)= ∅,
false	otherwise.
For each ϕ ∈ R, the function Eligible() is defined as below:
Eligible(ϕ)= Lit(Core(ϕ)).
For each ϕ ∈ R and for each a ∈ Eligible(ϕ), the function Filter() is defined as
Filter(ϕ, a)= {{a}} ∪ ϕ|a and Filter(ϕ, чa)= {{чa}} ∪ ϕ|¬a.
Example 6.1 As an example we consider the formula originating from the veri- fication of translators (compilers, code generators) [13], where concrete functions have been replaced by uninterpreted function symbols.
ϕ0 = {{u1 ≈ f (x1, y1)}, {u2 ≈ f (x2, y2)}, {z ≈ g(u1, u2)},
{z /≈g(f (x1, y1),f (x2, y2))}}.
After applying Rule i, we obtain
ϕ1 = {{u1 ≈ f (x1, y1)}, {u2 ≈ f (x2, y2)}, {z ≈ g(u1, u2)}, {z /≈g(u1,f (x2, y2))}},
ϕ2 = {{u1 ≈ f (x1, y1)}, {u2 ≈ f (x2, y2)}, {z ≈ g(u1, u2)}, {z /≈g(u1, u2)}},

(a)	ϕ0	(b)	ϕ0
	

f (x) ≈ f (z)f (x) /≈f (z)
ϕ0	ϕ1
x ≈ y	x /≈y
ϕ2	ϕ3



f (x) ≈ f (z) f (x) /≈f (z)
ϕ0	ϕ1



Fig. 2. a) An example of a non-terminating derivation ϕ0 = {{x ≈ y, y ≈ z}, {f (x) ≈ f (z)}}. b) An example of a terminating derivation ϕ0 = {{x ≈ y, y ≈ z}, {f (x) ≈ f (z)}}

ϕ3 = {{u1 ≈ f (x1, y1)}, {u2 ≈ f (x2, y2)}, {z ≈ g(u1, u2)}, {z /≈z}}.
After applying Rule ii, we obtain
ϕ4 = {{u1 ≈ f (x1, y1)}, {u2 ≈ f (x2, y2)}, {z ≈ g(u1, u2)}, ⊥}.

Since ⊥ ∈ ϕ4, ϕ4 is unsatisfiable and therefore ϕ0 is unsatisfiable.
Therefore, the function REDUCE() is defined by means of reduction rules, that can be applied in any order. The reduction rules allow to replace equals for equals,
and simplifying a formula by removing all equalities of the form t ≈ t. So, all work specific for the EUF-logic is done by the function REDUCE.
The function Eligible() allows us to choose literals from the purely positive clauses of length more than one, i.e. from the core of a formula. Hence, we may terminate with SAT as soon as the core of a reduced formula is empty and the formula does not contain the empty clause.
In Example 6.2 we show that choosing to split on an arbitrary positive literal can lead to a non-terminating derivation.
Example 6.2 The figure 2(a) shows sample derivations from a CNF ϕ0 = {{x ≈ y, y ≈ z}, {f (x) ≈ f (z)}} in tree notation. Splitting on a literal f (x) ≈ f (z) can lead to a non-terminating derivation since for a positive branch ϕ0 is derived. For a negative branch the CNF ϕ1 ≡ {{x ≈ y}, {y ≈ z}} is derived.
Splitting on a literal contained in Core(ϕ) leads to a terminating derivation. For
the given CNF ϕ0, Core(ϕ0)= {x ≈ y, y ≈ z}. A terminating derivation is depicted in Figure 2(b). After splitting on a literal x ≈ y, for a positive branch a reduced CNF ϕ2 ≡ {{x ≈ y}, {f (x) ≈ f (z)}} is derived and for a negative branch a reduced CNF ϕ3 ≡ {{y = z}, {f (x) ≈ f (z)}} is derived. Both ϕ2 and ϕ3 are satisfiable according Theorem 5.7.

Soundness and completeness
In this section we prove that the GDPLL procedure for the EUF-logic is sound and complete. One can see that the rules of the reduction system EUF-REDUCE preserve (un)satisfiability of a formula.
Lemma 7.1 Let ϕ ∈ Cnf. Then ϕ is satisﬁable if and only if REDUCE(ϕ) is satis- ﬁable.
Proof. We show that every reduction step preserves (un)satisfiability. So, let ϕ →
ψ.
(⇒) Suppose ϕ is satisfiable. Let I be an arbitrary E-interpretation such that
I |= ϕ.
Suppose ϕ ≡ {{s ≈ t}} ϕ', where s, t ∈ SubTerm(ϕ') and s /∈SubTerm(t), and ψ ≡ {{s ≈ t}}  ϕ'[s := t].
Taking into account I |= s ≈ t, we obtain I |= ϕ'[s := t]. Hence, I |= ψ.
Let ψ ≡ ϕ ↓.
Hence, ψ = {C ↓ | (C ∈ ϕ) Λ (∀t ∈ Term : (t ≈ t) /∈C)}. Then for each C ∈ ϕ, I |= C. Since for each t ∈ Term, I /= |t /≈t, we obtain that I |= C ↓. Therefore, I |= ψ.
(⇐) Suppose ψ is satisfiable. Let I be an arbitrary E-interpretation such that
I |= ψ.
Suppose ϕ ≡ {{s ≈ t}}  ϕ', where s, t ∈ SubTerm(ϕ') and s /∈SubTerm(t), and ψ ≡ {{s ≈ t}}  ϕ'[s := t].
Taking into account I |= s ≈ t, we obtain I |= ϕ'. Hence, I |= ϕ.
Assume ψ ≡ ϕ ↓. Then for each C ∈ ϕ one of the following holds.
C ⊆ D, where D ∈ ψ. Since I |= ψ then I |= D. Hence, I |= C.
(t ≈ t) ∈ C, where t ∈ Term. Since for each t ∈ Term, I |= t ≈ t then I |= C. Since for each C ∈ ϕ, I |= C, we conclude that I |= ϕ.	 
Lemma 7.2 Let ϕ ∈ Cnf, and s, t ∈ Term. Then ϕ is unsatisﬁable iff both {{s ≈
t}} ∪ ϕ|s≈t and {{s /≈t}} ∪ ϕ|s/≈t are unsatisﬁable.
Proof. (⇒) Let I be an arbitrary E-interpretation such that I /= |ϕ. Hence, I /= |
{{s ≈ t}} ∪ ϕ and I /= |{{s /≈t}} ∪ ϕ.
Without loss of generality we can consider the case when I |= s ≈ t. In this case
I /= |{{s /≈t}} ∪ ϕ|s/≈t.
Consider {{s ≈ t}} ∪ ϕ|s≈t. Since I |= s ≈ t, there is some C ∈ ϕ such that
I /= |C\{s /≈t}. Hence, I /= |{{s ≈ t}} ∪ ϕ|s≈t.
(⇐) Let I be an arbitrary E-interpretation. Since both {{s ≈ t}} ∪ ϕ|s≈t and
{{s /≈t}} ∪ ϕ|s/≈t are unsatisfiable, I /= |{{s ≈ t}} ∪ ϕ|s≈t and I /= |{{s ≈ t}} ∪ ϕ|s≈t. By definition, either I |= s ≈ t or I |= s /≈t. Without loss of generality we can assume that I |= s ≈ t. Therefore, I /= |ϕ, and ϕ is unsatisfiable.	 

Theorem 7.3 (Soundness and Completeness) A CNF ϕ is unsatisﬁable if and only if the GDPLL(ϕ) returns “unsatisﬁable”.
Proof. In order to apply Theorem 5, we have to check the following properties.
Properties i and ii have been proved in Lemma 7.1 and in Lemma 7.2. Properties iv and Property v have been proved in Theorem 5.7.
To prove Property iii we define a well-founded order < as follows. For all ϕ, ψ ∈
REDUCE(Cnf) ψ1 < ψ2 if	C∈Core(ψ1 ) |C| <	C∈Core(ψ2 ) |C|. By definition of the function Filter(), for all l ∈ Eligible(ϕ)
Core(Filter(ϕ, l)) ≡ {C ∈ Core(ϕ)| l /C∈}.
By definition of the function Eligible(), there is some C ∈ Core(ϕ) such that l ∈ C. Hence, for every l ∈ Eligible(ϕ), Filter(ϕ, l) < ϕ.
Consider Filter(ϕ, чl). By definition of the function Filter(), for all l ∈ Eligible(ϕ)
Core(Filter(ϕ, чl)) ≡ {C\{l}| C ∈ Core(ϕ)}
Since there is some C ∈ Core(ϕ) such that l ∈ C, we conclude that for every
l ∈ Eligible(ϕ), Filter(ϕ, чl) < ϕ.	 
Implementation
The algorithm was implemented in C++. The ATerm Library [17] was used to represent the literals. Operations that occur frequently on the literals in the al- gorithm are equivalence checking of terms, and substitution of subterms. These operations can be implemented efficiently using ATerms. The ATerm implementa- tion uses maximal subterm sharing, which makes checking the syntactic equivalence of terms a constant time operation (pointer equality). For efficiency reasons, the subsumption step during simplification was made optional.
We have experimented with a formula related to the pigeon hole formula in proposition calculus


Φn =



1≤i <j≤n

xi /=xj Λ



j =1
⎛⎝i∈{x1,	,xn},i/=j
xi = y⎞⎠

and a formula, which is a generation of a formula in [13],


Ψm,n =

  n




1≤i <j≤m
 
n k=1

xik /=xjk

V fi = fj	Λ
n i=1
ui /=fi

V g1 = g2	Λ

In both cases simple meta arguments can be used to show that these formulas are unsatisfiable. Our algorithm was able to solve Φn for values up to n = 100 and Ψm,n for values m = 50,n = 100 within a couple of seconds.

Furthermore we have experimented with random formulas. Starting with a set random clauses, a number of random substitutions were applied (like x := f (x)), to ensure that reduction could be applied. The problem size was about 1000 clauses and 10 different symbols. The EufDpll algorithm was able to solve all these problems. However, the BarcelogicTools program (winner of the SMT-COMP 2005 competition) [11] could do the same and was significantly faster in determining the solution.

Conclusions and future work
In the paper we presented the algorithm to solve satisfiability problem for EUF logic which is based on the generalized DPLL procedure. Our approach is implemented in the EufDpll tool.
DPLL-based systems are really efficient only in combination with good opti- mization strategies. The procedure can incorporate some optimization techniques developed by the SAT community for the DPLL method. Not all approaches suit- able for propositional logic work automatically for the EUF logic. Some techniques might become incorrect, and others being still correct, may lose their efficiency. A ‘full-strength’ version of EufDpll would include heuristics for good branching strate- gies. EufDpll is a prototype implementation. We have tested it on a diverse set of benchmarks, including the benchmarks from SMT-COMP’05. It is too early for serious comparison to other provers since some trimming to better performance should be done. Nevertheless, our approach looks very promising. It can also be easily extended to compute an interpretation as a model of a set of clauses. Another direction for future research can be extending to a non-clausal procedure.

References
Ackermann, W. Solvable cases of the decision problem. Studies in Logic and the Foundations of Mathematics. North-Holland, Amsterdam, 1954.
Badban, R., de Pol, J., Tveretina O., and Zantema, H. Generalizing DPLL and Satisfiability for Equalities. Information and Computation, vol. 205, issue 8, (August 2007), pp. 1188-1211.
Barrett, C. W., Dill, D., and Levitt, J. Validity checking for combinations of theories with equality. In Formal Methods in Computer-Aided Design (FMCAD’96) (November 1996), M. Srivas and
A. Camilleri, Eds., vol. 1166 of LNCS, Springer-Verlag, pp. 187–201.
Bryant, R., and Velev, M. Boolean satisfiability with transitivity constraints. ACM Transactions on Computational Logic 3, 4 (October 2002), pp. 604–627.
Burch, J.R. and Dill, D. L. Automatic verification of pipelined microprocessor control. in Computer Aided Verification, Lecture Notes in Computer Science, Vol. 18, Springer-Verlag, Berlin, 1994.
Davis, M., Logemann, G., and Loveland, D. A machine program for theorem proving. Communications of the Association for Computing Machinery 7 (July 1962), pp. 394–397.
Goel, A., Sajid, K., Zhou, H., Aziz, A., and Singhal, V. BDD based procedures for a theory of equality with uninterpreted functions. In Computer-Aided Verification (CAV’98) (1998), A. J. Hu and M. Y. Vardi, Eds., vol. 1427 of LNCS, Springer-Verlag, pp. 244–255.
Groote, J., and van de Pol, J. Equational binary decision diagrams. In Logic for Programming and Reasoning (LPAR’2000) (2000), M. Parigot and A. Voronkov, Eds., vol. 1955 of LNAI, pp. 161–178.

Meir, O., and Strichman, O. Yet another decision procedure for equality logic proceedings. In 17th International Conference on Computer Aided Verification (CAV 2005) (2005), vol. 3576 of LNCS,
pp. 307–320.
Nieuwenhuis, R., and Oliveras, A. Congruence closure with integer offsets. In 10h Int. Conf. Logic for Programming, Artif. Intell. and Reasoning (LPAR) (2003), M. Vardi and A. Voronkov, Eds., LNAI 2850, pp. 78–90.
Nieuwenhuis, R. and Oliveras, A. Decision Procedures for SAT, SAT Modulo Theories and Beyond. The BarcelogicTools. In Proc. of 12th Int. Conf. Logic for Programming, Artificial Intelligecne and Reasoning (LPAR), LNAI, pp. 23-46, 2005.
Pnueli, A., Rodeh, Y., and Shtrichman, O. Range allocation for equivalence logic. In Foundations of Software Technology and Theoretical Computer Science (FSTTCS’01) (December 2001), R. Hariharan,
M. Mukund, and V. Vinay, Eds., vol. 2245 of LNCS, Springer-Verlag, pp. 317–333.
Pnueli, A., Rodeh, Y., Shtrichman, O., and Siegel, M. Deciding equality formulas by small domains instantiations. In Computer-Aided Verification (CAV’99) (1999), LNCS, Springer-Verlag.
Pnueli, A., Rodeh, Y., Shtrichman, O., and Siegel, M. The small model property: how small can it be?
Information and Computation 178, 1 (October 2002), 279 – 293.
Rodeh, Y., and Shtrichman, O. Finite instantiations in equivalence logic with uninterpreted functions. In Computer Aided Verification (CAV’01) (July 2001), vol. 2102 of LNCS, Springer-Verlag, pp. 144– 154.
Shostak, R. An algorithm for reasoning about equality. Communications of the ACM 21 (July 1978), 583–585.
M.G.J. van den Brand and H.A. de Jong and P. Klint and P.A. Olivier Efficient Annotated Terms. in
Software, Practise and Experience, vol. 30(3), pp. 259-291, 2000.
