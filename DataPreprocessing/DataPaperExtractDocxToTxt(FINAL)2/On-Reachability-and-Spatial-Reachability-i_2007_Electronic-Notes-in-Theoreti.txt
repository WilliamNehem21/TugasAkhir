Electronic Notes in Theoretical Computer Science 171 (2007) 69–79	
www.elsevier.com/locate/entcs

On Reachability and Spatial Reachability in Fragments of BioAmbients
Giorgio Delzanno and Roberto Montagna
Dipartimento di Informatica e Scienze dell’Informazione Universita` di Genova, Italy

Abstract
BioAmbients is a powerful model for representing various aspects of living cells. The model provides a rich set of operations for the movement and interaction of molecules. The richness of the language motivates the study of dialects of the full model and the comparison with other computational models. In this paper we investigate the limit between decidability and undecidability of two decision problems, namely reacha- bility and spatial reachability, for semantic and syntactic fragments of BioAmbients providing movement capabilities and merge. Our results illustrate the power of merge with respect to the other movement oper- ations of BA for properties like reachability. Furthermore, they establish an interesting connection between BioAmbients and other computational models like associative-commutative term rewriting and Petri nets with transfer arcs.
Keywords: Biological Systems, Term Rewriting, Reachability

Introduction
BioAmbients (BA for short) [9] is a model for biological systems inspired by the Mobile Ambients (MA) of Cardelli and Gordon [4] Ambients are used to build hi- erarchically structured biological processes. The BA language provides a rich set of capabilities for the movement of molecules between compartments and for modeling molecular interaction. Every capability comes with a corresponding co-capability. Furthermore, BA is equipped with a special operation for merging compartments, called merge. Given the richness of the language, it is important to the study the properties of dialects of the full model and to compare them with other computa- tional models.
In this paper we focus our attention on the reachability and spatial reachability decision problems for pure public BA with a weak reduction semantics for repli- cation (pBAw). Pure public BA (pBA) is a fragment of BA with only movement capabilities and merge. Differently from the standard semantics, with the weak re- duction of replication proposed in [1] the process !P can only generate copies of P . The reachability problem consists in checking if a process P0 can be reduced to a

1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2007.05.008

process P1. The spatial reachability problem consists in checking if a process P0 can be reduced to a process P3 with the same ambient structure as P1 and such that each ambient in P3 has at least the same collection of local agents as the corresponding ambient in P1. Spatial reachability has been introduced for Mobile Ambients in [2]. Our goal is to explore the limit between decidability and undecidability for these two decision problems by taking different assumptions on the syntax of pBAw.
Concerning other computational models, we investigate here the connection be- tween pBA and associative-commutative term rewriting. Specifically, we isolate a class of term rewriting, called TUCM , in which terms represent unordered trees and rewriting rules have variables ranging over multisets of trees (multiset-variables). In this setting we define notions equivalent to reachability and spatial reachabil- ity and present an encoding from pBA to TUCM that preserves their satisfiability. Furthermore, we show that spatial reachability is decidable in a particular frag- ment of TUCM , called structure preserving, in which rewriting rules preserve the spatial structure of trees (i.e. when applied to a tree they cannot remove internal nodes). To obtain the decidability of reachability, we need an additional restric- tion on the merge-degree of a rewrite rule, i.e., on the number of occurrences of multiset-variables as siblings of internal nodes in a rewrite rule. Reachability turns out to be decidable for structure preserving rules with merge-degree equal to one and undecidable when the merge-degree is greater than one. The link between pBA and TUCM can be used to transfer decidability results to BioAmbients.
Specifically, we first prove that reachability and spatial reachability are decid- able in pBAw without merge (pBA−m). This fragment has the peculiarity that the number of ambients never decreases under applications of a reduction step. The proof exploits the encoding of pBA−m into TUCM . Reachability and spatial reach- ability become undecidable in pBAw. The proof is based on an encoding of two counter machines in pBAw. In the encoding we use nested ambients to simulate counters and the merge operation to implement the operations on counters. This negative result still holds for the ambient preserving fragment of PBAw (pBAa ). In this fragment a syntactic restriction on the use of merge ensures that the number of ambients never decreases when applying a reduction step. Interestingly, this is the property needed to prove decidability of reachability in pBA−m. The undecidability

of pBAa
reachability follows from a weak simulation of two counter machines. The

merge operation plays again a central role in the implementation of the operations on counters. Finally, we show that, perhaps surprisingly, spatial reachability is

decidable in pBAa . This results follows from an encoding of pBAa
spatial reach-

w	w
ability into spatial reachability in structure preserving TUCM . Consistently with
the undecidability of reachability, for the encoding we need rules of merge-degree equal to two.
Related Work Reachability and Spatial Reachability have been studied for open- free fragments of Mobile Ambients with weak reduction and guarded replication in [1,2,3]. We are not aware of decidability results for the same properties in frag- ments of BioAmbients with merge. TUCM is a generalization of the fragment of term rewriting we introduced in [5], called TUC, for studying reachability prob-

lems of Mobile Ambients. More precisely, TUC corresponds to the the subclass of TUCM rules with merge-degree equal to one. The decidability of reachability for structure preserving with merge-degree equal to one has been proved in [5] by means of a reduction to Petri nets reachability. As a novel result with respect to [5], in the present paper we show that spatial reachability is decidable for structure preserving rules with any merge-degree and that reachability is undecidable for structure pre- serving TUCM with merge-degree equal to two. Our decidability result is obtained via the encoding of TUCM spatial reachability into coverability of Petri nets with transfer arcs. The latter problem has been proved to be decidable in [7].
Plan of the Paper In Section 2 we define pure public BA. In Section 3 we define TUCM and the decidability result for spatial reachability. In Section 4 we define an encoding of reachability in pBA in TUCM . In Section 5 we present decidabil- ity and undecidability results for fragments of pBA. In Section 6 we address some conclusions.

pBA: Pure Public BioAmbients
Processes in the pure (without communication) public (without name restriction) fragment of BA comply with the following grammar:

P ::= 0	|	[P ]	|	M.P	|	P |P	|	!P
M ::= enter n | accept n | exit n | expel n | merge+ n | merge− n

where n ranges over a denumerable set L of labels. [P ] denotes an ambient. The process M.P denotes action prefixing, while P |Q denotes the parallel composition of P and Q. The replication !P denotes an arbitrary number of parallel copies of P . Finally, 0 denotes the null process. A local agent is a process of type M.P , !P or 0. The operational semantics is defined by means of a structural congruence ≡ and of a reduction relation ‹→. The structural congruence ≡ is the smallest one satisfying
P | Q ≡ Q | P	P | (Q | R) ≡ (P | Q) | R	P | 0 ≡ P	!P ≡!P | P
The reduction relation ‹→ is defined in Fig. 1 (notice that ! is not a context for reduction steps). We use ‹→∗ to denote the reflexive and transitive closure of the relation ‹→. Given processes P and Q, the reachability problem consists in deciding if P ‹→∗ Q. In order to define spatial reachability we introduce the following ordering between processes.
For processes P and P ', P “ P ' if there exist local agents Pi, Qi for i : 1,... , n, Ri for i : 1,... , r, and processes Ai, Bi for i : 1,... , r, m, n, r ≥ 0, such that following conditions are all satisfied:
P  =[ A1 ] | ... | [ Ar ] | P1 | ... | Pn
Q' =[ B1 ] | ... | [ Br ] | Q1 | ... | Qn | R1 | ... | Rm
Pi ≡ Qi for i : 1,... ,n and Ai “ Bi for i : 1,... , r.

[merge+ n.P | Q] | [merge− n.R | S] ‹→ [P | Q | R | S] [enter n.P | Q] | [accept n.R | S] ‹→ [[P | Q] | R | S ] [[exit n.P | Q] | expel n.R | S] ‹→ [P | Q] | [R | S]

P ‹→ Q


P | R ‹→ P | R
P ‹→ Q n[P ] ‹→ n[Q]
P ' ≡ P P ‹→ Q Q ≡ Q' P ' ‹→ Q'


Fig. 1. Reduction semantics for public MA.
For instance,
[merge+ n.0| [enter n.exit a.0] ] “
[merge+ n.0|merge− a.0| [enter n.exit a.0 | exit a.0] ].

Given P1 and P2, the spatial reachability problem consists in deciding if there exists
P3 such that P2 “ P3 and P1 ‹→∗ P3.
Fragments of pBA We focus our attention on the following fragments.
pBAw: The fragment with weak reduction semantics pBAw is obtained from pBA by transforming the congruence !P ≡!P |P into the oriented reduction rule (copy) defined as !P ‹→!P |P . In other words we forbid the absorb capability of replication.
pBA−m: The merge-free fragment of pBA−m is obtained from pBAw by forbid-
w	w
ding the use of merge+ and merge−.

pBAa : The ambient preserving fragment pBAa
is obtained from pBAw by re-

w	w
stricting the syntax in the following way. Every occurrence of merge+ must have
the following form: merge + n.([Q] | R), for some label n ∈ N and some pro- cesses Q and R. This syntactic restriction ensures that the number of ambients never decreases when a reduction step is executed (the merging of two ambients is compensated by the creation of at least a new ambient).

TUCM : A Fragment of AC Term Rewriting
In order to define the TUCM we need some preliminary definitions.
Ground Terms Given two ﬁnite sets of constants N and Q with N ∩Q = ∅, we use a constructor n⟨.. .⟩ to represent an ambient (internal node) with label n ∈ N , an AC constructor | to build multisets of trees (e.g. the sons of an internal node), ϵ to rep- resent the empty multiset, and the finite set of constants in Q to represent processes (leaves). E.g., given N = {n, m} and Q = {a, b} the term n⟨a | a | n⟨ϵ⟩ | m⟨a | b⟩⟩ can be viewed as an abstract representation of an ambient n with two subprocesses of type a and two subambients. Since ambients can be dynamically populated, we keep terms like n⟨ϵ⟩ (the empty ambient) distinguished from leaves in Q.

Formally, the set TR of ground tree terms and the set MS of multisets of ground tree terms are defined as follows: Q ⊆ TR, ϵ ∈ MS, if t1,... , tn ∈ TR then t1| ... |tn ∈ MS for n ≥ 1, if m ∈ MS and n ∈ N , then n⟨m⟩∈ TR.
Notice that, with a little bit of overloading, we use the same notation for a term t and the singleton multiset containing t. The multiset constructor | is associa- tive and commutative, i.e., m1|(m2|m3) = (m1|m2)|m3, and m1|m2 = m2|m1 for m1, m2, m3 ∈ MS. Furthermore, m | ϵ = m for any m ∈ MS.
We use the special symbol tuc (not in N ) to represent a forest t1| ... |tn as a single tree term tuc⟨t1| ... |tn⟩. tuc never occurs in terms t1,... , tn.
Restricted Terms with Multiset-Variables We consider here a restricted class of rewriting rules whose definition is based on two classes of terms called RTL and RTR. Given a denumerable set of multiset-variables V = {X, Y,.. .},
RTL is the least set of terms of TR satisfying: Q⊆ RTL; if t1,... , tn ∈ RTL, and
X ∈ V, then n⟨t1 | ... | tn | X⟩∈ RTL for n, m ≥ 0.
RTR is the least set of terms satisfying: Q ⊆ RTR; if t1,... , tn ∈ RTR, and
X1,... , Xr ∈ V, then n⟨t1 | ... | tn | X1 | ... | Xr⟩∈ RTR for n, m, r ≥ 0.
We often use the abbreviated notation n⟨t1,... , tn|X1,... , Xm⟩ to denote the term n⟨t1| ... |tn|X1| ... |Xm⟩ where Xi is a variable for i : 1,... ,m and ti is a tree term for i : 1,... , n.
Rewrite Rules A TUCM rewrite rule l → r is such that
l = t1 | ... | tn, and ti ∈ RTL for i : 1,... , n,

r = t'
| ... | t'
and t' ∈ RTR for i : 1,... , m;

l and r have the same set V of variables;
each variable in V occurs once in l and once in r;
Notice that TUCM forbids the use of rules like R1 = n⟨a⟩ | n⟨X⟩ → n⟨a | X⟩,
R2 = n⟨X | Y ⟩→ n⟨X⟩ | n⟨Y ⟩, R3 = n⟨X⟩→ n⟨X | X⟩.
A rule l → r is structure preserving if IntNds(l) ≤ IntNds(r), where IntNds(t) denote the number of occurrences of labels in N in a term t.
Formally, IntNds(t) is defined by induction on t as follows:
IntNds(ϵ)= IntNds(X)= IntNds(q)= 0


for X ∈V and q ∈ Q, IntNds(t1| ... |tk)= IntNds(t1| ... |tk| X)= Σk
IntNds(ti),

and IntNds(n⟨s⟩)= IntNds(s)+ 1.
The merge-degree −→ of a rule l → r is defined as the largest number of multiset- variables occurring as sibling of internal nodes in r.
For instance the rule n⟨a | a | X⟩ | m⟨a | b | Y ⟩ → n⟨m⟨X | Y ⟩⟩ is structure pre- serving with merge-degree equal to two. Notice that this rule is is not monotonic
w.r.t. the size of terms (it removes some leaves).
The rule n⟨X⟩ | m⟨a | b | Y ⟩ | p⟨Z⟩→ n⟨a | X | Y | Z⟩ is not structure preserving since it removes an internal node. Its merge-degree is three.

In the following we will call structure preserving TUCM with merge-degree k, the fragment of TUCM in which rules are structure preserving and have merge-degree less or equal than k.
Rewriting Relation We use the syntax t[ ] to indicate a tree term with one occurrence of the constant ◦, and t[s] to indicate the term obtained by replacing the constant
in t[] with s. Finally, we will use var(t) to denote the set of variables in t. Given two ground TR terms t1 = tuc⟨m1⟩ and t2 = tuc⟨m2⟩ t1 ⇒R t2 if and only if there exists a context t[ ], two multisets of ground TR-terms m and m', a rule l → r in R, and a mapping σ : var(l) → MS such that t1 ≡ t[σ(l)] and t2 ≡ t[σ(r)]. We will

use ⇒∗
to indicate the reflexive and transitive closure of the relation ⇒R.

Given two ground terms t1 = tuc⟨m1⟩ and t2 = tuc⟨m2⟩, the reachability problem
consists in deciding if t1 ⇒∗ t2.
In order to define spatial reachability we introduce the following ordering between trees. Given terms t and t', t ± t' iff there exist terms ti, t' /∈Q for i : 1,... , r, and constants qi ∈ Q for i : 1,... ,n and pi ∈ Q for i : 1,... , m, m, n, r ≥ 0 such that the following conditions are all satisfied:
t = n⟨q1,... , qn, t1,... , tr⟩,
t' = n⟨q1,... , qn, p1,... , pm, t' ,... , t' ⟩,
1	r
ti ± t' for i : 1,... , r,
Given two ground terms t1 = tuc⟨m1⟩ and t2 = tuc⟨m2⟩, the spatial reachability problem consists in deciding if there exists a ground term t3 such that t2 ± t3 and

t1 ⇒∗
t3.

In [5] we have proved that reachability and spatial reachability are decidable for TUCM -theories with structure preserving rules of merge-degree equal to one (i.e. with no merging of multiset variables). The following property holds for rules with any merge degree.
Theorem 3.1 Spatial reachability is decidable for TUCM -theories with structure preserving rules of arbitrary merge-degree.
Sketch of the proof. The proof is based on a reduction to the coverability problem for Petri nets with transfer arcs. For lack of space, we only give the intuition behind the construction. Given the initial term t0 and the target term t1, the construction of the Petri net is based on the following key ideas. The spatial structure of t1 gives us an upper bound, namely IntNds(t1) on the number of internal nodes of terms occurring in a derivation t0 ⇒∗ t2 such that t1 ± t2. The Petri net has two types of places: places labeled by tree structures with at most IntNds(t1) internal nodes, and places labeled by leaves. Leaves are associated to internal nodes by means of special position labels. From every rewrite rule it is possible to extract a set of Petri net transitions that update the place encoding a tree structure, and rearrange the leaves according to the structure of the left- and right-hand side of the rule. Transfer arcs are used to encode rules with merge-degree greater than one. 
Furthermore, we have the following negative result.

Theorem 3.2 Reachability is undecidable for TUCM -theories with structure pre- serving rules and merge-degree equal to two.
Proof. We exhibit an encoding of reachability for two counter machines (2CM). The instruction set of a 2CM with control states s1,... , sn and counters c1 and c2 consists of the intructions INCi(k, l) and DECi(k, l, m) with the following seman- tics. When executed in state sk, INCi(k, l) increments counter ci and then move to state sk, while DECi(k, l, m) decrements ci and then move to sl if ci > 0, and move to state sm if ci = 0. For simplicity, we consider a non-deterministic version of 2CM with separate operations for the test for zero and test for non-zero of a counter, and for the increment and decrement operations (the if-then-else instruction for decre- ment is non-deterministically simulated by two instructions defined on the same control location which uses the two tests). A counter ci with value n is encoded as a term ci⟨t⟩ where t is a multiset with n occurrences of the leaf q. We encode a two counter machine M by using the following mapping from instructions to rules. The increment operation INCi(k, l) is encoded by the rule sk|ci⟨X⟩ → sl|ci⟨q|X⟩, the decrement operation for ci > 0 is encoded by the rule sk|ci⟨q|X⟩ → sl|ci⟨X⟩, and for ci = 0 by the rule sk|ci⟨X⟩|g⟨Y ⟩ → sm|ci⟨ϵ⟩|g⟨X|Y ⟩. The term g⟨.. .⟩ is used to collect the content of a counter each time the test for zero is executed. If the test is executed when the counter is zero nothing is moved into the ambient g, otherwise we leave some garbage that we can use to distinguish bad simulations from good ones. Indeed, we have that the term sf |c1⟨ϵ⟩|c2⟨ϵ⟩|g⟨ϵ⟩ is reachable from s0|c1⟨ϵ⟩|c2⟨ϵ⟩|g⟨ϵ⟩ iff ⟨sf , c1 = 0, c2 = 0⟩ is reachable from ⟨s0, c1 = 0, c2 = 0⟩ in M . 

Encoding pBAw (Spatial) Reachability in TUCM
In this section we will show how to reduce the reachability problem for pBAw to reachability in TUCM . For this encoding, it is enough to use a very limited frag- ment of TUCM . For instance, we will only consider trees with internal nodes all labelled by the same constant a. Before going into the details of the reduction, let us make some preliminary considerations on the semantics of BA. Let us first notice that we can work with a congruence relation applied only to context different from
!P (as for the reduction semantics). Let us now reformulate the axiom P | 0 ≡ P as the two reduction rules P ‹→ P | 0 and P | 0 ‹→ P . Several computation steps of the modified semantics may correspond to one computation or congruence step in the original semantics. Reachability is preserved by the modified semantics: If Q is reachable from P0 in the standard semantics, then there exists Q' reachable from P0 in the modified semantics such that Q' is equivalent modulo the congruences for 0 to Q, and Q' is obtained by replacing every occurrences of a process !R in Q with an equivalent process !R' occurring in P0.
Given a process term P , let us now define the set of replicated or sequential processes Sub(P ) (modulo associativity and commutativity of parallel) that may become ac- tive during a computation.
Formally, Sub(0)= {0}, Sub([P ]) = Sub(P ), Sub(!P )= {!P }∪Sub(P ), Sub(P | Q)= 
Sub(P ) ∪ Sub(Q), Sub(M.P )= {M.P }∪ Sub(P ).

(merge) a⟨qmerge+ n.Q | X⟩ | a⟨qmerge− n.R | Y ⟩ → a⟨T (Q) | T (R) | X | Y ⟩ (enter) a⟨qenter n.Q | Y ⟩ | a⟨qaccept n.R | Z⟩ → a⟨a⟨T (Q) | Y ⟩ | T (R) | Z⟩ (accept) a⟨a⟨qexit n.Q | Y ⟩ | qexpel n.R | Z⟩ → a⟨T (Q) | Y ⟩ | a⟨q0 | T (R) | Z⟩ (copyt) q!Q → q!Q | T (Q)
(zero)	q → q | q0	a⟨X⟩→ a⟨X⟩ | q0	q | q0 → q	a⟨X⟩ | q0 → a⟨X⟩
Fig. 2. TUCM -rules encoding pBAw for qM.Q, q!Q ∈ Q.
It is easy to check that Sub(P ) is a finite set. Furthermore, if P ‹→∗ Q using the modified reduction semantics, then Sub(Q) ⊆ Sub(P ) ∪ {0}.
Let us now consider the reachability problem P0 ‹→∗ P1. To encode this prob- lem in TUCM , we use terms in which leaves range over the finite set of constants Q = {qR | R ∈ Sub(P0)}∪ {q0}.
The encoding of BA is built in a natural way by a mapping local P agents to a leaf qP and an ambients [Q] to the tree term a⟨T (Q)⟩ where a is a special label used to denote membranes, and T (Q) inductively defines the encoding of Q in TUCM . Formally, given a process Q derived from P0, we define the ground term T (Q) by induction on Q as follows: T (Q)= qQ if Q ∈ {0, M.Q1, !Q1}, T ([Q1]) = a⟨T (Q1)⟩, and T (Q1|Q2)= T (Q1)|T (Q2).
The following properties then hold.
Proposition 4.1 P0 ‹→∗ P1 if and only if tuc⟨T (P0)⟩ ⇒∗ tuc⟨T (P1)⟩.
Proposition 4.2 There exists P2 such that P1 “ P2 and P0 ‹→∗ P2 iff tuc⟨T (P0)⟩ ⇒∗
tuc⟨T (P2)⟩ and tuc⟨T (P1)⟩± tuc⟨T (P2)⟩.
Reachability and Spatial Reachability in pBAw
In this section we study the decidability of (spatial) reachability for the fragments

pBA−m, pBAw, and pBAa
of pBA. The first property is as follows.

w	w
Theorem 5.1 Reachability nd spatial reachability are decidable in pBA−m.
Proof. We first notice that the TUCM -theory that encodes a reachability problem for pBA−m consists of a finite set of structure preserving rules with merge-degree equal to one (all rules but merge in Fig. 2). Thus, the result follows by applying Prop. 4.1, Prop. 4.2 and the decidability of reachability in this fragment of term rewriting proved in [5].	 
Theorem 5.2 Reachability and spatial reachability are undecidable in pBAw.
Proof. We exhibit an encoding of two counter machines. Given the set of control location Loc = {L1,... , Lk}, the encoding of a 2CM with instruction I1,... , In and initial configuration C0 = ⟨L, c1 = 0, c2 = 0⟩ is defined as follows
P0 = Prog | Loc | [[c1 = 0 ] | [[c2 = 0 ],

where Prog = [![[I1]]| ... |![[In]]], and Loc = [[L]] = [merge− L.0]. The encoding is de- fined using the set of labels L = Loc∪{a, b, z1, z2, c1, c2}. To represent ci = 0, we use the following ambient [ci = 0 ] ::= [!exit zi.0 | !merge− zi.0] for i : 1, 2. To repre- sent ci = k with k > 0, we use the ambient [ci = k ] ::= [merge− ci.0 | [[ci = k − 1]]] for i : 1, 2. The encoding of the instructions is defined as follows.
I = DECi(L, M ), ci = 1: [I]] = merge + L.(A1 | expel a.0), where A1 = [exit a.merge+ ci.expel zi.merge− M.0]. The Loc ambient is first merged with the Prog ambient using the synchronization label L. This action creates the ambient A1 that is expelled by the merged ambients immediately after. A1 is merged with the ambient ci. The resulting ambient expels the zi ambient (ci = 1) and then becomes a new ambient encoding the new location [M ]].
I = DECi(L, M ), ci > 1: [I]] = merge + L.(A1 | expel a.0), where A1 = [exit a.merge+ci.(A2 | expel a.merge−M.0)], A2 = [merge+ci.exit a.merge−ci.0]. As in the previous case the Loc ambient is first merged with the Prog ambient using the synchronization label L (the current location). This action creates the ambient A1 which is expelled immediately after. A1 is merged with the ambient ci. A new ambient A2 is created inside the resulting merged ambient say A1 + ci. A2 is merged with the ci ambient at the same level and the resulting ambient is moved at the top level (it represents ci − 1) while A1 + ci becomes the ambient [M ]].
I = INCi(L, M ), ci = 0: then [[I]] = merge + L.(A1 | B1 | expel a.expel a.0), where A1 = ([exit a.merge+ zi.enter a.A2] | expel b.0),
B1 = [exit a.accept a.expel a.merge− ci.0],
and A2 = [exit b.exit a.merge− M.0]. As for DEC the Loc ambient is first merged with the Prog via L (the current location). This action creates the ambients A1 and B1 that are expelled immediately after. A1 is merged with the ambient zi and then enters inside B1 where it releases an ambient A2. A2 is expelled by the two nested ambients and, thus, moved at the top level as the new location [M ]]. In the meantime B1 creates a local agent merge− ci.0 to become [ci = 1 ].
I = INCi(L, M ), ci > 1: then [I]] = merge + L.(A1 | B1 | expel a.expel a.0), where A1 = ([exit a.merge+ ci.enter a.(A2 | merge − ci.0)] | expel b.0), A2 = [exit b.exit a.merge− M.0], B1 = [exit a.accept a.expel a.merge− ci.0]. The tests ci = 0 and ci > 0 are simulated by using merge steps either with label zi or with label ci.
I = TSTZi(L, M ): then [I]] = merge+ L.(A1 | expel a.0), where
A1 = [exit a.merge+ zi.(A2 | expel a.0)], A2 = [exit a.merge− M.0].
I = TSTNZi(L, M ): then [I]] = merge + L.(A1 | accept a.0), where A1 = [exit a.merge+ ci.(merge− ci.0 | A2 | accept a.0)], A2 = [exit a.merge− M.0]. The 2CM reachability problem from C0 to C0 (a variation of the general reacha- bility problem that it is still undecidable) can be reduced then, to the reachability problem P0 ‹→∗ P0. Furthermore, since the only garbage introduced by the en- coding is due to possible duplication of banged local agents, we have that that P0 →∗ P1 ± P0 if and only if P0 →∗ P0. Since 2CM reachability is undecidable, we have that reachability and spatial reachability are both undecidable.	 


The second negative results concerns reachability in the fragment pBAa
in which

merge is allowed only if it does not reduce the total number of ambients.
Theorem 5.3 Reachability is undecidable in pBAa .
Proof. We exhibit a weak encoding of 2CMs. Let M be a 2CM with list of in- structions I1,... , In. The current configuration is encoded using 5 ambients that we will label as Prog, Loc, C1, C2, and G: Prog contains the encoding of the instructions, Loc keeps track of the current control location, C1, C2 keep track of the current values of the counters, G has a subambient H needed to collect (and keep separated from the other ambients) all local agents representing “units” when the zero-test is weakly simulated. Specifically, the encoding of a 2CM with instruction I1,... , In and initial configuration C0 = ⟨L, c1 = 0, c2 = 0⟩ is defined as P0 = Prog | Loc | [[c1 = 0 ] | [[c2 = 0 ] | G, where Prog = [![[I1]]| ... |![[In]]],
Loc = [L]] = [merge − L.0], G = [!accept g.0 | H], and H = [!merge − h.0]. To represent ci = k we define the ambient [ci = k]] = [merge− zi.0 | Pk], where Pk
is a parallel with k occurrences of the local agent merge− ci.0 for i : 1, 2. The encoding of the instructions is defined as follows.
If I = [[DECi(L, M )]], then [I ] is defined as merge + L.(A1 | expel a.0), where A1 = [exit a.merge+ ci.(A2 | expel a.0)] and A2 = [exit a.merge− M.0]. The intuition of the previous definition is as follows. The Loc ambient is first merged with the Prog ambient using the synchronization label L (the current location). This action creates the ambient A1 that is expelled by the merged ambients imme- diately after. A1 is merged with the ambient ci (thus consuming a “unit”, i.e., a local agent merge− ci.0). The ambient A2 is created inside the resulting merged ambients and expelled to become [M ]].
If I = INCi(L, M ), then [I ] is defined as merge+ L.(A1 | expel a.0), where
A1 = [exit a.merge + ci.(A2 | expel a.0 | merge − ci.0 |  merge − ci.0)], and A2 = [exit a.merge− M.0]. Again the Loc ambient is first merged with the Prog ambient via L. This action creates the ambient A1 that is expelled by the merged ambients immediately after. A1 is merged with the ambient ci (thus consuming a “unit”, i.e., a local agent merge− ci.0). The ambient A2 is created inside the resulting ambient, say A1 + ci, and expelled to become [M ]. In the meantime two new “units” are release inside A1 + ci (one to compensate the unit consumed to execute the merge, and one for the increment).
The encoding of the zero test is more tricky, since it exploits the ambient we called
G (garbage) at the begininning of the proof.
If I = TSTZi(L, M ), then [I]] = merge+ L.(A1 | expel a.0), where
A1 = [exit a.merge+ zi.(A2 | enter g.P | expel b.expel d.0)],
P = merge+ h.(A3 | expel a.expel c.0), A2 = [exit a.exit b.merge− zi.0], and A3 = [exit c.exit d.merge− M.0]. The intuition is as follows. The Loc ambient is first merged with the Prog ambient via L. This action creates the ambient A1 that is expelled by the merged ambients immediately after. A1 is merged with the ambient ci via the label zi (used only for the zero-test). A2 (that will become [[ci = 0]]) is released inside the resulting ambient, we will refer to as A1 + ci. At this stage, A1 + ci enters G while creating another internal ambient A3 (that will

become [M ]), and the merges with H. As a last step, A2 and A3 are moved at the top level in sequence. If the counter ci was not zero, then the local agents inside ci remain blocked inside the subambient H of G. This way they cannot interact with the other ambients at the top level.
Finally, if I = TSTNZi(L, M ), then [I ] is defined as merge+ L.(A1 | accept a.0), where A1 = [exit a.merge + zi.(A2 | merge − ci.0 | expel a.0)], and A2 = [exit a.merge − M.0].
By means of the previous encoding, we can show that the 2CM reachability problem from C0 to C0 can be reduced then, to the reachability problem P0 ‹→∗ P0. 

While reachability in pBAa
is undecidable, we can prove that spatial reachability

remains decidable even in presence of the merge rule.
Theorem 5.4 Spatial reachability is decidable for pBAa .
Proof. The TUCM -rules that encode a reachability problem for pBAa



consists of

a finite set of structure preserving rules with merge-degree two. Thus, the result follows by applying Prop. 4.2 and Theorem 3.1.	 

Conclusions
In this paper we have investigated in the decidability/undecidability of reachability and spatial reachability for public fragments of BioAmbients with weak reduction for replication. Our results illustrate the power of the merge operation. Its presence can turn a minimal fragment of public BioAmbients into a Turing equivalent model. Furthermore, they establish an interesting connection between BioAmbients and other computational models like associative and commutative term rewriting and Petri nets with transfer arcs. This connection can be used to define executable specifications of biological systems by means of tools like Elan and Maude (see e.g. [10]). We plan to investigate this direction in our future research.

References
I. Boneva and J.-M. Talbot. When ambients cannot be opened! TCS 333(1-2): 127-169, 2005.
N. Busi and G. Zavattaro. Deciding reachability in Mobile Ambients. ESOP ’05: 248-262.
N. Busi and G. Zavattaro. Deciding Reachability in Boxed Ambients. ICTCS ’05: 143-159.
L. Cardelli and A. D. Gordon. Mobile ambients. TCS 240(1): 177-213, 2000.
G. Delzanno and R. Montagna. Reachability analysis of Mobile Ambients in fragments of AC term rewriting. Technical Report DISI-05-16, Universit`a di Genova, 2006.
M. Dauchet, S. Tison. The Theory of ground rewrite systems is decidable. LICS 1990: 242-248.
J. Esparza, A. Finkel, and R. Mayr. On the verification of broadcast protocols. LICS 1999: 352-359.
R. Mayr and M. Rusinowitch. Reachability is decidable for ground AC rewrite systems. INFINITY’98.
A. Regev, E. M. Panina, W. Silverman, L. Cardelli, E. Y. Shapiro. BioAmbients: an abstraction for biological compartments. TCS 325(1): 141-167, 2004.
F. Rosa Velardo, C. Segura, A. Verdejo. Typed Mobile Ambients in Maude. ENTCS 147(1): 135-161, 2006.
