	Electronic Notes in Theoretical Computer Science 91 (2004) 4–20	
www.elsevier.com/locate/entcs




Checking Strong Open Congruence in
χ-Calculus 1
Taolue Chen 2
State Key Laboratory of Novel Software Technology Nanjing University, Nanjing, P.R.China

Jingyang Zhou 3
State Key Laboratory of Novel Software Technology Nanjing University, Nanjing, P.R.China

Tingting Han 4
State Key Laboratory of Novel Software Technology Nanjing University, Nanjing, P.R.China

Jian Lu5
State Key Laboratory of Novel Software Technology Nanjing University, Nanjing, P.R.China


Abstract
The χ-calculus is an important evolution for mobile process calculi. Open congruence is widely studied in χ-calculus. However, there still lacks an algorithm for checking this bisimulation relation. In this paper, the symbolic technique is applied to the research of χ-calculus and an efficient characterization for strong open congruence which does not involve quantification over substitutions is given. Based on it, an algorithm, which instantiates bound names ’on-the-fly’, is developed to check strong open congruence for finite control processes.
Keywords: Mobile processes, Chi-calculus, Open congruence, Symbolic bisimulation, Algorithm.



1571-0661 © 2004 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2003.12.003

For more than ten years, various calculi of mobile processes, notably the π- calculus [13], have been the focus of research in concurrency theory. These calculi are distinguished from the traditional process calculi like CCS [12] in that they allow processes to exchange specific values-channel names, thus are capable of dealing with processes whose communication structures can change during their evolution. The ability of dynamic creation of communication links lies at the heart of mobility.
Recently, several publications have focused on many variants of the π- calculus, such as asynchronous π-calculus [8], the πI-calculus [17]. Apart from the π-calculus more than any of the above variants, the χ-calculus [2] in- troduced by Fu, is an important evolution for mobile process calculi. The χ-calculus is introduced with two motivations in mind [2]. One is to remove the ad hoc nature of prefix operation in π-calculus by having a uniform treat- ment of names, thus arriving at a conceptually simpler language. The other is to materialize a communication-as-cut-elimination viewpoint, therefore taking up a proof theoretical approach to concurrency theory, an approach that has been proved very fruitful in the functional world. The difference between π- calculus and χ-calculus lies mainly in the way communications happen. The former adopts the familiar value-passing mechanism whereas the latter takes an information exchange or information update viewpoint.
In the research of algebra theory for mobile process, many studies focus on the bisimulation equivalence between processes, which is the most influential one in process algebra. To carry out a systematic study of bisimilarities for χ- calculus, Fu introduces the notion of L-bisimilarity [3], and shows that the set of L-bisimilarities forms a four-element lattice. It can also be shown that the well-known bisimilarity, that is, the open bisimilarity and barbed bisimilarity are respectively the bottom and the top element of the bisimulaiton lattice. We refer reader elsewhere [3] for more details. In [3], all of these congruences are investigated in weak case. However, in strong case, all of the four congruence coincide, i.e. the strong version bisimulation lattice collapses to only one element, in this sense, the open congruence is the only sensible congruence in the research of χ-calculus when we only deal with strong case.
For process algebra, the algorithm which is used to check one process is

1 Supported  by  NNSFC  (60273034,	60233010),	863  Program  (2001AA113110,
2002AA116010), 973 Program of China (2002CB312002), JSFC (BK2002203, BK2002409)
2 Email: ctl@ics.nju.edu.cn
3 Email: jingyang@nju.edu.cn
4 Email: hantt@ics.nju.edu.cn
5 Email: lj@nju.edu.cn


bisimular to another is important, which is key to make one prototypical pro- cess description language be used in practice. In CCS and π-calculus, people have designed all sorts of such algorithms. Generally speaking, all available algorithms can be classified into two types. One is partition refinement al- gorithm [1][16], the main advantage of this kind of algorithm is that it can be used to obtain a minimal realization of a process P , i.e. a process which has the minimum number of states and transitions among all those bisimilar with P , however, it involves the computation of finite transition graph, which is a rather complex task and is inefficient in space; the other is ’on the fly’ algorithm [19][10], in which the state spaces of processes being compared are created at the same time as the candidate bisimulation relation, so in general, it has a low space complexity, although it can not be used to give the minimal realization of process.
Since χ-calculus is an important mobile process calculi, it is necessary to study bisimulation verification problem for it. However, to the author’s knowledge, this aspect of work has not been reported. The main work of this paper is to present an algorithm for the verification of open congruence in χ-calculus. Since it is well known that the full π-calculus is not decidable and it is easy to show this result also valid in χ-calculus, in this paper, we focus on the so called finite control [1] χ-calculus, that is, the process expression disallows parallel composition | to appear in the bodies of recursive defini- tions. By confining the process expression to ﬁnite control processes, which is the syntactic counterpart of CCS finite state processes, we get a decidable equivalence problem. To get our destination, we first introduce an alternative characterization of the the open congruence in symbolic framework [7][18], thus we can avoid the universal quantification over substitution in the original definition which may represent a rather heavy requirement in practice. Based on it, an efficient algorithm is presented since it is enough to instantiate the bound name of the action with a single fresh name. Note that in this paper, the mismatch operator is not included and as usual, we only focus on strong open congruence.
The rest of the paper is organized as follows: The χ-calculus is reviewed in the following section. In Section 3, the symbolic characterization for open congruence is introduced with a proof to show that it captures (concrete) open congruence. The ’on the fly’ algorithm is presented in Section 4. The paper is concluded with Section 5 where related work is also discussed.

χ-calculus and Open congruence
In this section, we will review some background material for χ-calculus, we refer the reader elsewhere [4] for more details. We will write C for the set of χ-processes defined by the following grammar:
P := 0 | αx.P | P |P | (x)P | [x = y]P | P + P | A(y1,... , yn)
where α ∈ N ∪ N¯ . Here N is the set of names ranged over by small case letters. The set {x¯|x ∈ N } of co-names is denoted by N¯ . The name x in (x)P is bound. A name is free in P if it is not bound in P . The free names, the bound names and names of P , as well as the notations fn(P),bn(P) and
n(P), are used in their standard meanings. In sequel we will use the functions fn(-),bn(-) and n(-) without explanation. We write α¯ for a¯ if α = a and for a if α = a¯. Bound names induce the notion of α-equivalence as usual. In the sequel we will identify processes or actions which differ only on the bound names, therefore the symbol ≡ means syntactical equality and α-equivalence. Furthermore whenever we introduce a binary relation on terms we will always assume it is closed w.r.t. ≡.
The operational semantics is defined by the following labelled transition system:
Sequentialization:


Composition:
αx.P →αx P
Sqn

P → P ' bn(µ) ∩ f n(Q)= ∅
y/x	'
P → P

µ
P |Q
Cmp0,
P '|Q
y/x	'
Cmp1

→
Communication:
P |Q → P |Q{y/x}

α(x)
P
α¯y	'
α(x)	'
α¯(x)	'

→ P	Q → Q
P → P
Q → Q

P |Q →τ
Cmm0,
P '{y/x}|Q'
P |Q →τ
Cmm1
(x)(P '|Q')

P →αx P ' Q →α¯y Q' x /= y	P →αx P '  Q →α¯x Q'

y/x
Cmm2,
τ	'	'
Cmm3

P |Q → P '{y/x}|Q'{y/x}
Restriction:
P |Q → (P |Q )

P →λ
P '	x ∈/ n(λ)
P →αx P '	x ∈/ {α, α¯}
y/x
→ P

(x)P →λ (x)P
Condition:
Loc0,
'
(x)P
α(x)
→ P
Loc1,


(x)P →τ P
Loc2,
'

P →λ P '
M atch

[x = x]P →λ P '



Summation:

P →λ P '


Sum


Identity :
P + Q →λ P '

P {y , ··· ,y /x , ··· ,x } →λ P '

def

1	n	1	n
A(x
··· x
) = P

1	n
A(y , ··· ,y ) → P '
1	n
We have omitted all the symmetric rules. In the above rules the letter µ ranges over the set {α(x), αx|α ∈ N ∪ N¯ , x ∈ N } ∪ {τ } of non-update actions and the letter λ over the set {α(x), αx, y/x|α ∈ N ∪ N¯ , x ∈ N } ∪ {τ } of all actions. In αx and y/x all names are free. In α(x), the name x is bounded whereas the other name is free.
The process P {y/x} in the above labelled transitional system is obtained by substituting y for x throughout P . A substitution {y1/x1, ··· yn/xn} is a function from N to N that maps xi onto yi for i ∈ {1, ··· , n} and x onto itself for x ∈/ {x1, ··· , xn}. Substitutions are usually denoted by σ, ρ, etc. The empty substitution, that is the identity function on N , is written as {}. The result of applying σ to P is denoted by Pσ. In the below, by α-conversion it is assumed that a substitution σ acts as an identity on the bound names of the process and keeps the separation between bound and free names. We follow this convention in the below and will use it implicitly in the proof.
The following technical lemma [4] states the properties of (concrete) la- belled transitions.
Lemma 2.1 The following properties hold:

If P →
P ' then Pσ →µ
P 'σ.

If P y/x P ' and xσ /= yσ then Pσ yσ/xσ P 'σ{yσ/xσ}.

If P y/x P ' and xσ = yσ then Pσ →τ
P 'σ.

As done previously [18], we shall use M, N, L to stand for finite (and possibly empty) match sequences. A match sequence defines an equivalence relation on names. Given a match sequence M and the equivalence relation RM associated to it, we denote by σM a special substitution which selects a representative out of each equivalence class of RM and maps all names in the same class to their representative. We write M ⇒ N if M implies N ,
i.e. whenever the tests in M are true, then also the tests in N are true. Similarly, we write M ⇔ N if both M ⇒ N and N ⇒ M hold. We say that a substitution σ satisfies a match sequence M if for each x, y, it holds that M ⇒ [x = y] implies σ(x) = σ(y), that is, the condition Mσ is true.

We extend the notation M ⇒ N to σ ⇒ ρ if σ equates more than ρ, i.e.
ρ(x)= ρ(y) implies σ(x)= σ(y).
The relations between match sequence and substitution are revealed by the following lemma [18].
Lemma 2.2 The following properties hold:
If M ⇒ N, then Mσ ⇒ Nσ.
If M ⇒ N, then σM ⇒ σN .
If σ ⇒ σ', then ρ exists s.t. σ = σ'ρ.
In what follows, some notations need be fixed. Let fa denote the set
{αx|α, x ∈ N ∪ N¯ } of free actions, ba the set {α(x)|α, x ∈ N ∪ N¯ } of bound actions and u the set {y/x|x, y ∈ N ∪ N¯ } of updates and we let δ, λ range over the set {α(x), αx, y/x|α ∈ N ∪ N¯ , x,y ∈ N } ∪ {τ }.
The strong open congruence, given in this section, is the strong version of open congruence studied earlier [3][4], which adapts Sangiorgi’s definition for π-calculus [18] to χ-calculus.
Definition 2.3 Let R be a symmetric relation on C, The relation R is called an open congruence relation if whenever P RQ, then for any substitution σ, it

holds that if Pσ →δ
P ', then some Q' exists, such that Qσ →δ
Q' and P 'RQ'.

The open bisimilarity ∼ is the largest open congruence.
It is easy to show that ∼ is indeed a congruence relation. Note that this definition can be rehearsed as follows:
Definition 2.4 Let R be a symmetric relation on C, The relation R is called an open congruence if it is closed under substitution and whenever P RQ and

P →δ
P ', then Q' exists s.t. Q →δ
Q' and P 'RQ'.

The form of this definition has been considered elsewhere [18] and will be used in the proof of Section 3.

Symbolic Characterization
As we state in Section 1, one immediate difficulty to check open congruence is that the definition of Section 2 involves quantification over substitutions. In this section, we show a more efficient method to check process bisimilaries, which is based on the well known symbolic transition system. A symbolic transition is of the form P M,δ P ', where, M is a match sequence and δ is an action. Intuitively, M represents the environments under which the action δ can actually be fired from P . Comparing with it, the transitions defined in

Section 2 are concrete in the sense that they can always be fired regardless of the context in which terms are placed. Base on it, we define a symbolic open congruence following Sangiorgi [18].
The symbolic transitional semantics of the χ-calculus is given as follows. For notational convenience we write MN for the union of M and N . Also the symmetric rules for Sum and Par have been omitted.
Sequentialization:



Composition:
P '→ P '

αx.P

bn(µ) ∩ f n(Q)= ∅

∅,αx
'→ P
Sqn






y/x
P '→ P

Cmp0,
'
y/x
Cmp1

P |Q '→ P |Q
Communication:
P M,a(x) P ' Q N,¯by Q'


P |Q '→ P '{y/x}|Q'
P M,a(x) P ' Q N,¯b(x) Q'


P |Q '→ (x)(P '|Q')
P |Q '→ P '|Q{y/x}
 MN [a = b]	if a /= b
 MN	if a = b
 MN [a = b]	if a /= b
 MN	if a = b



P M→,ax P ' Q N,¯by Q' x /= y
L =
P |Q L,y/x P '{y/x}|Q'{y/x}	
MN [a = b]	if a /= b MN	if a = b

Cmm2

P M,ax P ' Q N,¯bx Q' P |Q '→ P '|Q'
Restriction:
 MN [a = b]	if a /= b
 MN	if a = b

P M→,λ P '	x ∈/ n(M, λ)

M,λ

Loc0,
P M→,αx P '	x ∈/ n(M ) ∪ {α, α¯}


M,α(x)
Loc1

(x)P
'→ (x)P '
M,y/x
P	'→ P
(x)P
x ∈/ n(M )
'→	P '



Condition:
(x)P
M→,τ P '
Loc2,

P M→,λ P '
L =
[x = y]P L,λ P '	
M [x = y]	if x /= y M	if x = y

M atch



Summation:


Identity :

P M→,λ P '


P + Q M→,λ P '


Sum

P {y , ··· ,y /x , ··· ,x } M→,λ P '

1	n	1	n
A(x
··· x
def
P

A(y , ··· , y ) M→,λ P '
1	n) =

The following technical lemma shows some properties of symbolic transi- tion.
Lemma 3.1 The following properties hold:
M,δ

If P
If P
'→ Q, then n(M ) ∪ f n(δ) ⊆ f n(P ).
M,δ
Q, then the following properties holds:
M σ,δσ

If δ ∈/ u, then Pσ  '→  Qσ.

M σ,τ

If δ = y/x and yσ = xσ, then Pσ 
If δ = y/x and yσ /= xσ, then Pσ 
'→ Qσ.
M σ,yσ/xσ
'→	Qσ{yσ/xσ}.

M ',δ'	'
If Pσ '→ Q , then the following properties holds:
If δ' ∈ ba ∪ f a, then P M→,δ Q with M ' ⇔ Mσ,δ' ≡ δσ and Q' ≡ Qσ.
If δ' = τ, then one of the following properties holds:
P M→,τ Q s.t. M ' ⇔ Mσ and Q' ≡ Qσ.

M,y/x
P	'→  Q s.t. M
⇔ Mσ,xσ = yσ and Q'
≡ Qσ.

if δ' = y'/x', then P M,y/x
Q with M ' ⇔ Mσ,y' = yσ, x' = xσ and

Q' ≡ Qσ{y'/x'}.
Proof. By transition induction.	 
The following two technical lemmas relate concrete and symbolic transi- tions.
Lemma 3.2 If P σM → P '', then the following properties holds:
If δ = τ, then one of the following properties holds:
P N,y/x P ' with M ⇒ N [x = y] and P '' = P 'σ .
'→	M
P N,τ P ' with M ⇒ N and P '' = P 'σ .
'→	M
if δ /= τ, then P N→,λ P ' with M ⇒ N, δ = λσ and P '' = P 'σ .
Proof. By transition induction. We only check some typical cases.

(P |P )σ
→τ (P ''|P '') is derived from P σ
→az
P '' and P σ
→a¯z
P ''. By

1	2	M	1	2
M	1
M	2

the inductive assumption, we get


with
P N→1 ,bx P '
P N→2,c¯y P '

M ⇒ N1, az ≡ (bx)σM ,P '' ≡ P 'σM
1	1
M ⇒ N2, az ≡ (cy)σM ,P '' ≡ P 'σM
2	2
Now, we can infer(suppose b /= c, the converse case is similar)

P |P
N1N2 [b=c],y/x P ' |P '

1	2	'→	1	2
with (P '|P ')σM ≡ P ''|P '' and M ⇒ N1N2[b = c][x = y] since xσM = yσM .
1	2	1	2
((x)P )σ	→τ  P '' is derived from Pσ	y/x P ''(Note that by the convention of
M	M →
Section 2, ((x)P )σM = (x)P σM and x ∈/ n(σ))). By inductive assumption,

we get P N,z/x P ', with M ⇒ N , zσ	= y and P '' ≡ P 'σ
. Now, we infer

'→	M	M
(x)P N,τ P ', since by Lemma 3.1(i), x ∈/ n(N ).

(P |P )σ
y/x (P ''{y/x}|P ''{y/x}) is derived from P σ
→ax P '' and P σ
a¯y

1	2	M →	1	2
1 M	1
2 M →

P ''. By the inductive assumption, we get
N1,bx'	'	N2,c¯y'	'

with
P1 '→  P1	P2 '→  P2

M ⇒ N1, ax ≡ (bx')σM ,P '' ≡ P 'σM
1	1
M ⇒ N2, ay ≡ (cy')σM ,P '' ≡ P 'σM
2	2
Now, we can infer(suppose b /= c, the converse case is similar)

N1N2 [b=c],y'/x'
'	'	'
'	'	'

with
P1|P2
'→	P1{y /x }|P2{y /x }

(P '{y'/x'}|P '{y'/x'})σM ≡ (P 'σM {σM (y')/σM (x')}|P '{σM (y')/σM (x')})
1	2	1	2
≡ P ''{y/x}|P ''{y/x}
1	2
and M ⇒ N1N2[b = c].
The other cases are similar, due to space restriction, we omit the details.	 
Lemma 3.3 If P M,δ P ', then the following properties hold:
If δ = y/x and M ⇒ x = y, then P σM → P 'σM .

If δ ∈/ u or δ = y/x and xσM
/= yσM
, then P σM
δ→σM P 'σ .

Proof. By transition induction. We only check some typical cases.
Suppose a /= b and (P |P ) M1M 2[a=b],y/x (P '{y/x}|P '{y/x}) is derived from
1	2	'→	1	2

P M→1,ax P ' and P M→2 ,a¯y P '. We can decompose σ
as σ
and

1	1	2	2
M1 M 2[a=b]
M1 ρ1

σM2 ρ2 for some ρ1,ρ2 by Lemma 2.2. From the inductive assumption, we get

(ax)σM1	'
(¯by)σM2	'

P1σM1
→	P1σM1  P2σM1
→	P2σM2

and moreover it can be inferred that

(ax)σM1 ρ1	'
(¯by)σM2 ρ2	'

P1σM1 ρ1
→	P1σM1 ρ1  P2σM2 ρ2
→	P2σM2 ρ2

(P |P )σ
→τ (P '|P ')σ

1	2	M1 M2[a=b]
1	2	M1 M2 [a=b]

since by M1M2[a = b] ⇒ x = y and Lemma 2.2, xσM1 ρ1 σM2 ρ2 = yσM1ρ1 σM2ρ2
and substitution {y/x} is subsumed by σM1 ρ1 σM2 ρ2
[x = y]P M→,δ P ' is derived from P N→,δ P ', we suppose x /= y and δ ∈/ u, then
M = N [x = y]. By Lemma 2.2, we can decompose σM as σN ρ for some ρ. By

inductive assumption, we get P σN
δ→σN P 'σ
, hence ([x = y]P )σM
δ→σM P 'σ .

The other cases are similar and can be proved without difficulty.

Now, we give the symbolic characterization for open congruence, which is called symbolic open congruence.
Definition 3.4 Let R be a symmetric relation on C, The relation R is called a symbolic open congruence if P RQ implies:
If δ ∈ fa ∪ ba and P M→,δ P ', then N, λ, Q' exists,s.t. Q N→,λ Q', with M ⇒ N ,
δσM = λσM and P 'σM RQ'σM .
If P M,τ P ', then one of the following properties holds:
N, Q' exists s.t. Q N,τ Q' with M ⇒ N and P 'σ  RQ'σ  .
'→	M	M

N, y/x, Q' exists s.t. Q N,y/x Q' with M ⇒ N [x = y] and P 'σ
RQ'σ  .

'→
If P M,y/x P ', then one of the following properties holds:
N, Q' exists s.t. Q N,τ Q' with M ⇒ N [x = y] and P 'σ
M	M


RQ'σ  .


'	'	'
'→	M	M
N,y'/x'	'	'	'

N, y /x ,Q 
exists s.t. Q	'→	Q with M ⇒ N , (y/x)σM = (y /x )σM

and P 'σM RQ'σM .
N, y'/x', Q' exists s.t. Q P 'σM RQ'σM .

N,y' /x'
'→	Q' with M ⇒ N [x = y][x' = y'] and

The symbolic open bisimilarity = is the largest symbolic open congruence.
Now, we embark into the proof that ∼ and = coincide.
Lemma 3.5 = implies ∼.
Proof. Let
R = {(P, Q)|P = Q}

first, we prove that R is closed under substitution. Let S = {(P σ, Qσ)|P = Q,σ arbitrary}, we show S is a symbolic open congruence. Consider the action δ that Pσ can take, we have following cases:
δ ∈ fa ∪ ba, then by Lemma 3.1, the transition can be written as Pσ M→σ,δσ
P 'σ for some M, δ and P ' s.t. P M,δ P '. Since P = Q, we have Q N,λ Q' with
M ⇒ N , δσM ≡ λσM and P 'σM = Q'σM . By Lemma 2.2, we have Mσ ⇒ Nσ, and following Sangiorgi’s proof [18], it is not difficult to verify that σσMσ ⇒ σM , so we have δσσMσ ≡ λσσMσ and similarly, P 'σσMσSQ'σσMσ,
hence Qσ N→σ,λσ Q'σ gives the counterpart to the transition of Pσ by Lemma
and Definition 3.4. In this case, the proposition is correct.
δ = τ , then the transition can be written as one of two subcases as follows:

M σ,τ
Pσ 
P 'σ for some M and P ' s.t. P M→,τ
P '. By the definition of =,

there are two cases to verify. However, using the same argument as the first case, the two cases are easily to be checked.

M σ,τ
· Pσ	'→
P 'σ
for some M and P '
s.t. P
M,y/x
'→	P
and xσ = yσ.  By

the definition of =, there are three cases need to be verified.  Here we
N,τ
only check one as example, the other two are similar. Take Q '→ Q

with M ⇒ N [x = y] and P 'σ	= Q'σ  , then Qσ N→σ,τ
Q'σ.  Since

xσ = yσ, we have Mσ ⇒ Nσ and use the same argument in the first case,
P 'σσMσSQ'σσMσ, hence, the transition of Pσ can be matched.
M σ,y' /x'
δ ∈ u, then the transition can be written as Pσ	'→	P 'σ{y'/x'} for some
M and P ' s.t. P M,y/x P ' and xσ = x', yσ = y'. By the definition of =, there are also three cases need to be verified, here we chose the most difficult one.

N,y'' /x''	'
''	''	'	'

Take Q
'→	Q
with M ⇒ N [x = y][x  = y ] and P σM = Q σM . Now,

we have two subcases.
· x''σ = y''σ, then Qσ N→σ,τ
Q'σ.	Note that Mσ ⇒ N [x' = y'] and

P 'σ{y'/x'}σMσ ≡ P 'σσMσ, and by the same argument in the first case
P 'σσMσSQ'σσMσ;

· x''σ /= y''σ, then Qσ
N σ,y'' σ/x'' σ
'→	Q'σ{y''σ/x''σ}, and we have Mσ ⇒

Nσ[x' = y'][x''σ = y''σ] and P 'σ{y'/x'}σMσSQ'σ{y'/x'}σMσ.
Now we check naked transition match in Definition 2.4, which is rather easy.
Suppose P →δ P ', then by Lemma 3.2, P ∅,δ P '. Since P = Q, by Definition

∅,δ
3.4, the only possible case for Q to match such transition is that Q '→
Q',

and P ' = Q'. By Lemma 3.3, Q →δ
Q'. Due to Definition 2.4, the proof is

completed.	 
Lemma 3.6 ∼ implies =.

Proof. Let
R = {(P, Q)|P ∼ Q}
We show that R is a symbolic congruence. Suppose P M,δ P '. We check the

following cases:
δ = y/x and M ⇒ x = y, then by Lemma 3.3, P σM →


P 'σM

. By P ∼ Q,

we have QσM →
Q'' with P 'σM
~ Q''. By Lemma 3.2, there are two
N,y'/x'

subcases, we only chose the more difficult one to verify. Q
'→	Q' with

M ⇒ N [x' = y'] and Q'' = Q'σM , then we have M ⇒ N [x = y][x' = y'] and
P 'σM RQ'σM .
y' /x'	'	'

δ = y/x and xσM /= yσM , then P σM
y'/x'
→  Q σM , where y
= yσM and

x' = xσM . By P ∼ Q, we have QσM
N,y'' /x''
→ Q'' with P 'σM ∼ Q''. By Lemma

, N , Q' exists s.t. Q	'→	Q', with M ⇒ N , y'/x' = (y''/x'')σM and
Q'' ≡ Q'σM , thus (y/x)σM = (y''/x'')σM and P 'σM RQ'σM .

δ = τ , then P σM →
P 'σ, by P ∼ Q, we have QσM →
Q'' with P 'σM
~ Q''.

By Lemma 3.2, there are two subcases, here we also check one of them.

N,y/x
Q
''	'	'

'→ Q
with M ⇒ N [x = y] and P
= P σM , then P σM RQ σM .

The other cases are easier.	 
Combining the above two lemmas gives the main result of this section:
Theorem 3.7 P ∼ Q iff P = Q.
Proof. By Lemma 3.5 and Lemma 3.6.	 

On-the-fly Algorithm
The definition of symbolic open congruence does not involve the requirement for considering a universal quantification over substitution, thus paving the way for an efficient bisimulation checking algorithm.
The algorithm present in Fig.1 and Fig.2 is adapted from the ’on-the-fly’ algorithm for value-passing processes [10] and π-calculus [11]. It combines the well-known on-the-fly bisimulation algorithm for standard labelled transition systems with the strategy of instantiating bound name with a single fresh name. As done previous [11], it assumes a countably infinite subset SN ⊂ N which is totally ordered. The function nextSN (P, Q) returns the smallest name in SN that does not appear in the set of free names at states P and Q.
The function bisim(P, Q) starts with the initial pair (P, Q), and calls the core function, match, which tries to find the smallest bisimulation containing




Fig. 1. The on-the-fly Algorithm (PartI)



Fig. 2. The on-the-fly Algorithm (PartII)

the pair if two processes in question(P and Q) are open congruent otherwise returns empty set by matching transitions from them.
The core function, match, performs a depth-first travel on the product of the two transition graphs which are never fully created, instead, they are gen- erated together during the construction of the candidate bisimulation relation which equates them. The parameter visited is used to store pairs that are en- countered before. If two states fail to match each other’s transitions then they are not bisimilar and the pair is inserted into NotBisim, which is introduced to improve the efficiency of algorithm. Thus given two processes P and Q and a relation visited, function match first checks if (P, Q) has been already in the relation. If so, return the relation, otherwise if (P, Q) is in NotBisim, then return ∅, in converse, we produce the outgoing transitions and the next states set. Note that for bound action, a single fresh name is used to instantiate the bound name. Then the function close is called to match each other’s deriva-

tives by the definition of symbolic open congruence which involves recursive calling of function match when applying the substitution σM to the derivatives and using the extended visited relations.
The pseudo code of the algorithm is described in more detail in Fig.1 and Fig.2. The correctness of the algorithm is not difficult to justify. First, we give the following lemma to ensure the termination of the algorithm.
Lemma 4.1 For ﬁnite control process P, Q, bisim(P,Q) always terminates.
Proof. Since we only consider the finite control process, that is, the process expression disallows parallel composition — to appear in the bodies of recur- sive definitions, and indeed it is built up by parallel composition of processes that do not contain parallel composition. So it is easy to see that the pro- cess space searched is finite and by parameter visited, the algorithm stores and checks if the current processes in question have been checked for each recursion. Thus the algorithm always terminates.	 
The partial correctness can be get by the following lemmas.
Lemma 4.2 If 6(P, Q) ∈ visited, P = Q and R = match(P, Q, visited) /= ∅, then for 6(P, Q) ∈ R, P = Q holds.
Proof. By induction on the number of recursions of function match, n.
Initial case: for n = 0, trivial.
Induction step. if R = match(P, Q, visited) does not return immediately, then all derivatives of P have been matched by Q for open congruence, and each of the derivatives is by induction open congruent. So R is built up by the ’for’ loop when matching the derivatives. By the definition of symbolic open congruence, provided visited is a set satisfied the condition, then for 6(P, Q) ∈ R, P = Q also holds.

By the above lemma, Let visited = ∅, then we can get: if R = match(P, Q, ∅) /=
∅, for 6(P, Q) ∈ R, P = Q.
The following lemma is easy to show when examining the code in Fig.1 and Fig.2.
Lemma 4.3 If R = match(P, Q, ∅)= ∅, then P /= Q.
Now, we have the following theorem:
Theorem 4.4 For ﬁnite control process P and Q,R = bisim(P, Q, ∅) always terminate and R /= ∅ if and only if P = Q.

To see the complexity of the algorithm, since it is well known that the problem of deciding bisimulaition equivalence of data-independent processes in value-passing CCS is NP-hard in the size of processes [9], the decision problem for the mobile process algebra, such as π-calculus and χ-calculus, is at least NP-hard.

Conclusion
In this section, we summarize our work. Our contribution lies in that: (1) We give a symbolic characterization for strong open congruence in χ-calculus. Symbolic technique, introduced by Hennessy and Lin [7] is widely used in the research of process algebra, especially for axiomatizing observation equiva- lence and bisimulation checking related problem. In this paper, the symbolic transition system and the definition for symbolic open congruence are given and the relation to the concrete ones is discussed. The main result is that the concrete and symbolic open congruence coincide. To our knowledge, this is the first time to apply the symbolic technique to the research of χ-calculus; (2) We present an algorithm to check strong open congruence for finite control processes. Our algorithm falls into the on-the-fly category. Since in strong case, the open barbed congruence coincide with the open congruence, as a byproduct, the algorithm can also be used to check open barbed congruence. It is worth pointing out that although we only deal with χ-calculus in this paper, our results can be easily adapted to update calculus [14] and fusion calculus [15] without mismatch, which are the asymmetric and polyadic ver- sion of χ-calculus.
The present work relies heavily on the symbolic technique, which is widely used in π-calculus. The characterization for open congruence in this paper follows the Sangiorgi’s approach [18], in which open style bisimulation is first introduced a symbolic characterization is also given. However, due to the na- ture of χ-calculus, the symbolic definition in this paper is more involved. There is a sea of publication on checking bisimulation relations in process algebra. For π-calculus, checking open congruence has also been tackled. The Mobility Workbench [19] implements an ’on-the-fly’ algorithm for open congruence and Pistore and Sangiorgi [16] present a partition refinement algorithm. As we know, similar problems for χ-calculus is not considered in the literature.
There are several directions for further research. The weak version con- gruence has not been investigated. Although we don’t find any difficulty to adapt the definition and method in this paper to weak open congruence, the details need to be verified; and more, in weak case, barbed congruence is dif- ferent from open congruence, checking this bisimulation relation is also very

interesting. The χ-calculus studied in this paper does not include mismatch operator, and it is interesting to consider bisimulation checking problem in χ/=-calculus which has been provided and studied elsewhere [5][6].

References
Dam, M., On the decidability of process equivalence for the π-calculus. Theoretical Computer Science, 1997, 163:214-228.
Fu, Y., A Proof Theoretical Approach to Communications. ICALP’97, Lecture Notes in Computer Science, Vol 1256, Springer,Berlin, 1997, pp.325-335.
Fu, Y., Bisimulation lattice of Chi calculus, ASIAN’98, Lecture Notes in Computer Science 1256, Springer 1998.
Fu, Y., Bisimulation Congruence of Chi Calculus. To appear in Information and Computation.
Fu, Y. and Z.Yang. Chi calculus with mismatch, CONCUR 2000, Lecture Notes in Computer Science, Vol 1877, Springer,Berlin, 2000, pp.385-396.
Fu, Y. and Z.Yang. Understanding the Mismatch Combinator in Chi Calculus. Theoretical Computer Science, 290, 779-830, 2003.
Hennessy, M. and H. Lin, Symbolic bisimulations. Theoretical Computer Science, 138(2): 353-389, 1995.
Honda, K. and M. Tokoro, On asychronous communication semantics, object-based concurrent computing, Lecture Notes in Computer Science, Vol.612, Springer, Berlin, 1991, pp.21-51.
Jonsson, B. and J.Parrow, Deciding bisimulation equivalences for a class of non-finite-state programs. Journal of Information and Computation, 107(2):272-302, 11,1993.
Lin, H., ’On-the-fly instantiation’ of value-passing processes. In FORTE/PSTV’98, pp 215-
230. Kluwer Academic Publishers, 1998.
Lin, H., Computing bisimulation for finite-control π-calculus, Journal of Computer Science and Technology, Vol.15, No. 1, 2000.
Milner, R., Communication and Concurrency, Prentice Hall, 1989.
Milner, R., J.Parrow and D.Walker, A Calculus of Mobile Process, part I/II. Journal of Information and Computation, 100:1-77, Sept.1992.
Parrow, J. and B. Victor, The update calculus, AMAST’97, Lecture Notes in Computer Science, Vol 1119, Springer,Berlin, 1997, pp.389-405.
Parrow, J. and B. Victor, The fusion calculus: expressiveness and symmetry in mobile processes, Logics in Computer Science’98, IEEE Computer Society Press, Silver Spring, MD, 1998, pp.176-185.
Pistore, M. and D. Sangiorgi, A partition refinement algorithm for the π-calculus, In Proc. CAV’96, Lecture Notes in Computer Science 1102, Springer Verlag.
Sangiorgi, D., π-calculus, internal mobility and agent-passing calculi, Theoret.Comput.Sci. 167(1996), 235-274.
Sangiorgi, D., A theory of bisimulation for π-calculus, Acta Informatica 3 (1996) 69-97.
Victor, B. and F.Moller, The mobility workbench-a tool for the π-calculus. In Proc. CAV’94, Lecture Notes in Computer Science, pp 428-440. Springer-Verlag, 1994.
