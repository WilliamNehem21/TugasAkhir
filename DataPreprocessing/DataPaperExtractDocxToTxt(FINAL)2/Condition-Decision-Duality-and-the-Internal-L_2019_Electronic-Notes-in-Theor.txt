Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 347 (2019) 179–202
www.elsevier.com/locate/entcs

Condition/Decision Duality and the Internal Logic of Extensive Restriction Categories
Robin Kaarsgaard 1,2
DIKU, Department of Computer Science University of Copenhagen

Abstract
In flowchart languages, predicates play an interesting double role. In the textual representation, they are often presented as conditions, i.e., expressions which are easily combined with other conditions (often via Boolean combinators) to form new conditions, though they only play a supporting role in aiding branching statements choose a branch to follow. On the other hand, in the graphical representation they are typi- cally presented as decisions, intrinsically capable of directing control flow yet mostly oblivious to Boolean
combination.
While categorical treatments of flowchart languages are abundant, none of them provide a treatment of this dual nature of predicates. In the present paper, we argue that extensive restriction categories are precisely categories that capture such a condition/decision duality, by means of morphisms which, coincidentally, are also called decisions. Further, we show that having these categorical decisions amounts to having an internal logic: Analogous to how subobjects of an object in a topos form a Heyting algebra, we show that decisions on an object in an extensive restriction category form a De Morgan quasilattice, the algebraic structure associated with the (three-valued) weak Kleene logic Kw. Full classical propositional logic can be
recovered by restricting to total decisions, yielding extensive categories in the usual sense, and confirming (from a different direction) a result from effectus theory that predicates on objects in extensive categories form Boolean algebras.
As an application, since (categorical) decisions are partial isomorphisms, this approach provides naturally reversible models of classical propositional logic and weak Kleene logic.
Keywords: categorical logic, flowchart languages, restriction categories, extensivity, weak Kleene logic


Introduction
Flowchart languages are a particular class of imperative programming languages which permit a pleasant and intuitive graphical representation of the control flow of programs. While conceptually very simple, flowchart languages form the foun- dation for modern imperative programming languages, and have been used for this

1 Email: robin@di.ku.dk
2 The author would like to thank Robert Glu¨ck for discussions relating to this paper, and to acknowledge the support given by COST Action IC1405 Reversible computation: Extending horizons of computing. The string diagrams and flowcharts in this paper were produced using TikZiT .

https://doi.org/10.1016/j.entcs.2019.09.010
1571-0661/© 2019 The Author(s). Published by Elsevier B.V.
This is an open access article under the CC BY-NC-ND license (http://creativecommons.org/licenses/by-nc-nd/4.0/).

reason as vehicles for program analysis (e.g., to measure coverage in white-box testing [1]), program transformations (e.g., partial evaluation, see [17]), and to ex- press fundamental properties of imperative programming, such as the equivalence of expressivity in structured and unstructured programming in the B¨ohm-Jacopini theorem [4] (see also [3, 28]). Figure 1 shows the (textual and graphical) flowchart structures used by structured flowchart languages.
An interesting feature in flowchart languages is the dual presentation of pred- icates as conditions and decisions, depending on the context. On the one hand, the textual if p then c1 else c2 seems to favor the view of p as a condition, i.e., a predicate which has inherently nothing to do with control flow, but which may easily be combined with other conditions to other conditions to form new ones. In other words, the textual representation considers the branching behaviour to be given by the semantics of if ... then ... else ... rather than by the semantics of p. This view is also emphasized by the usual (big-step) operational semantics of conditionals: Here, predicates are treated as expressions that may be evaluated in a state to yield a Boolean value, which the conditional may then branch on, as in
⟨p, σ⟩→ true	⟨c1, σ⟩→ σj	⟨p, σ⟩→ false	⟨c2, σ⟩→ σj
and	.
⟨if p then c1 else c , σ⟩→ σj	⟨if p then c1 else c , σ⟩→ σj
On the other hand, the graphical representation of conditionals in Figure 1(c) seems to rather prefer the view of p as a decision, i.e., a kind of flowchart operation intrinsically capable of directing control flow. That is to say, that this is a structured flowchart (corresponding to a conditional) is purely coincidental; for unstructured flowcharts to make sense, p must be able to direct control flow on its own. However, where conditions are most naturally composed via the Boolean combinators, the only natural way of composing decisions seems to be in sequence (though this leads to additional output branches).
While categorical models of structured flowchart languages have been widely studied (see, e.g., [2, 10, 11, 24, 26, 27]), none provide a treatment of this dual view of predicates. In this paper, we argue that extensive restriction categories are precisely categories that make clear this dual view on predicates as conditions and decisions, offering both the ease of combination of conditions and the control flow behaviour of decisions. Restriction categories (introduced in [7–9]) are categories of partial maps, in which each morphism is equipped with a restriction idempotent that, in a certain sense, gauges how partial that morphism is. Since models of flowchart languages most provide a notion of partiality (due to possible nontermination), restriction categories provide an ideal setting for such models. Coincidentally, the defining feature of extensive restriction categories 3 is the presence of certain morphisms called decisions, which play a similar role as the decision view on predicates in flowchart languages.
In this setting, we show that the correspondence between conditions and deci- sions is exhibited precisely as a natural isomorphism between the predicate ﬁbration

3 Note that while extensive restriction categories are strongly connected to extensive categories, they are confusingly not extensive in the usual sense of extensive categories [5].


			
Atomic operations, f . Sequential composition, c1 ; c2 . Conditionals, if p then c1 else c2 . While loops, while p do c.

Fig. 1. The four flowchart structures.

Fig. 2. Extensive categories, extensive restriction categories, and effecti: their relationships and associated logics.

Hom(X, 1 + 1) of predicates and predicate transformers (see also [6, 16]), and the decision ﬁbration Dec(X) of decisions (certain morphisms X → X +X) and decision transformers. We then go on to explore the structure of Dec(X) (or equivalently, Hom(X, 1 + 1)), showing that this extends to a fibration over the category of De Morgan quasilattices and homomorphisms, which give algebraic semantics [12] to

Kleene’s weak logic Kw
[21]. Intuitively, Kw
can be seen as a partial version of

classical (Boolean) logic. We make this statement precise in this setting by showing that if we restrict ourselves to total decisions and decision transformations, classical logic can be recovered. Since the subcategory of objects and total morphisms of a (split) extensive restriction category is an extensive category in the usual sense (see, e.g., [5]), we can use this to provide an alternative proof of a statement from Effectus theory [6, 16] that predicates over each extensive category forms a fibred Boolean algebra via the predicate fibration [6, Prop. 61, Prop. 88]. This yields a relation- ship diagram of effecti, extensive categories, and extensive restriction categories and their corresponding logics as shown in Figure 2.
This paper is structured as follows: Section 2 gives a brief introduction to exten- sive restriction categories. Section 3 demonstrates the condition/decision duality of extensive restriction categories by showing that the decision and predicate fibrations are naturally isomorphic; and, as a consequence, that decisions are a property of the predicates. Then, in Section 4, we show that the decisions on an object form models of Kw, with decision transformers as homomorphisms. By restricting to only total decisions, we show that these restrict to models of classical logic. Finally, 5 offers some concluding remarks.

Extensive restriction categories
This section gives an introduction to extensive restriction categories as it will be applied in the sections that follow. The experienced reader may safely skip this

section on a first reading, and instead refer back to it as necessary.
Restriction categories are categories equipped with notions of partiality and totality of morphisms. This is done by means of a restriction combinator, assigning
f	f
to each morphism X −→ Y its restriction idempotent X −→ X (subject to certain
laws) which may intuitively be thought of as a partial identity defined precisely where f is defined. In this way, restriction categories provide an axiomatic (and relatively light-weight) approach to partiality of morphisms in categories. Formally, restriction categories are defined in the following way:
Definition 2.1 A restriction structure on a category consists of a combinator map- ping each morphism f to its restriction idempotent f , i.e.





subject to the restriction laws:
f
X −→ Y


f
X −→ X



f
(R1) ff = f for all X −→ Y ,
f
(R3) fg = fg for all X
g
X −→ Z, and
f
−→ Y and

(R2) fg = gf for all X
g
X −→ Z,
−→ Y and
f
(R4) gf = fgf for all X −→ Y and
g

Y −→ Z.
A category equipped with a restriction structure is called a restriction category.
As the name suggests, a restriction structure is a structure on a category rather than a property of it; in particular, a category can be equipped with several different restriction structures. For this reason, we must in principle specify which restric- tion structure we are using when speaking of a particular category as a restriction category, though this is often omitted when the restriction structure is implicitly given to be a canonical one.
Given that restriction categories are built on a foundation of idempotents, one would expect it to be occasionally useful when all such restriction idempotents split, and indeed this is the case. Say that restriction structure is split when all restriction idempotents split, and let Split(C ) denote the category arising from the usual idempotent splitting (i.e., the Karoubi envelope) of all restriction idempotents in C . That Split(C ) is a restriction category when C is follows by [7, Prop. 2.26]
As a canonical example, the category Pfn of sets and partial functions is a
f	f
restriction category, with the restriction idempotent X −→ X for X −→ Y given by
f (x)= ⎧⎨ x	if f is defined at x
⎩ undefined otherwise

f

In a restriction category, say that a morphism X −→ Y is total if f = idX , and that

it is a partial isomorphism if there exists Y

f†
−→ X such that f
†f = f and ff†


= f†.

Partial isomorphisms thus generalize ordinary isomorphisms, as an isomorphism is

then a partial isomorphism X −→ Y such that both f and f†
are total.

Since total morphisms are closed under composition and include all identities, they form an important subcategory Total(C ) of any restriction category C . Like- wise, partial isomorphisms are closed under composition and include all identities, so all objects and partial isomorphisms of C form the subcategory Inv(C ). As the notation suggests, this category Inv(C ) is not just a restriction category but an inverse category (indeed, it is the cofree such [18]) in the usual sense (see [7, 20]).
A useful property of restriction categories is that they come with a natural partial order on homsets (which extends to enrichment in Poset) given by f ≤ g iff gf = f . Intuitively, this can be thought of as an information order ; f ≤ g if g can do everything f can do, and possibly more.
Like any other categorical structure, when working in restriction categories we require everything in sight to cooperate with the restriction structure. One of the simplest examples of cooperation with restriction structure is given in the definition of a restriction terminal object: This is simply a terminal object 1 in the usual sense, which further satisfies that the unique map X → 1 is total for all objects
X. For coproducts, this means that we not only require the restriction category to have all finite coproducts in the usual sense, but also that the coproduct injections

κ
X −→ X + Y and Y
κ
−→ X + Y are total. In this case, we say that the restriction

category has restriction coproducts. There is also a similar notion of a restriction zero object 0: a zero object in the usual sense which additionally satisfies that
0X,X
each zero endomorphism X −−−→ X is its own restriction idempotent, i.e., that
0X,X = 0X,X (or equivalently, that 0X,Y = 0X,X for all zero morphisms 0X,Y ). When zero morphisms exist, they serve as least element in their homset with respect to the natural ordering, and when a category has restriction coproducts and a restriction zero object, the restriction zero object serves as unit for the restriction coproduct. When this is the case, restriction coproduct injections are further partial

κ
isomorphisms (e.g., the partial inverse to X −→ X + Y is X + Y
[id,0]
−−−→ X).

Extensivity for restriction categories means that the restriction coproducts are particularly well-behaved, in the sense that they admit a calculus of matrices [9].
f
Concretely, this means that each morphism X −→ Y + Z is associated with a unique
⟨f⟩
morphism X −−→ X + X, its decision, which, intuitively, makes the same branching
choices as f does, but doesn’t do any actual work. Extensive restriction categories are defined as follows.
Definition 2.2 A restriction category with restriction coproducts and a restriction zero is said to be an extensive restriction category if each morphism f has a unique decision ⟨f⟩, i.e.
f
X −→ Y + Z
⟨f⟩
X −−→ X + X
satisfying the decision laws



(D1) ∇⟨f⟩ = f	(D2) (f + f )⟨f⟩ = (κ1 + κ2)f
where X + X −∇→ X is the natural codiagonal [id, id].
Note that extensive restriction categories are not extensive in the usual sense – rather, extensive restriction categories are the “partial” version of extensive cat- egories. This connection is made precise by the following proposition due to [9].

Proposition 2.3 Whenever C is an extensive restriction category, Total(Split(C ))
is an extensive category.
A straightforward example of an extensive restriction category is Pfn. Here, the
⟨f⟩	f
decision X −−→ X + X of a partial function X −→ Y + Z is given by
⎧ κ1(x)	if f (x)= κ1(y) for some y ∈ Y
⟨f⟩(x)=	κ2(x)	if f (x)= κ2(z) for some z ∈ Z
⎪⎪⎩ undefined if f undefined at x
For further examples and details on extensive restriction categories, see [9].
Condition/decision duality
Categorical models of flowcharts are categories with a notion of partiality (due to possible nontermination) and coproducts (corresponding to the control flows of the flowchart). As such, restriction categories with restriction coproducts serve as a good starting point for these. We show in this section that the additional requirement of extensivity of the restriction coproduct allows the category to exhibit a condition/decision duality, analogous to the flowchart languages. This manifests in the category as a natural isomorphism between the decisions and predicates over an object (with their corresponding transformations).
We start with a few technical lemmas regarding the partial order on morphisms in a restriction category as well as properties of decisions in extensive restriction categories.
Lemma 3.1 It is the case that



	
g ≤ gj implies gf ≤ gjf,
gf ≤ f,
f ≤ g implies hf ≤ hg and f hj ≤
ghj,
f ≤ fj and g ≤ gj iff f + g ≤
fj + gj.
f ≤ g implies f = f.

f
Lemma 3.2 Let X −→ Y + Z and X
g
−→ X be arbitrary morphisms of an extensive

restriction category, and X −→e
any restriction idempotent. It is the case that

⟨⟨f ⟩⟩ = ⟨f⟩
⟨f⟩ is a partial isomorphism and

 
⟨f⟩† =  κ†f, κ†f
⟨⟨f ⟩g⟩ = ⟨fg⟩
(e + e)⟨f⟩ = (e + e)⟨f⟩e
⟨f⟩e is a decision and ⟨f⟩e = (e +

1	2
e)⟨f⟩
⟨f⟩† = κ†f + κ†f
1	2	(ix) ⟨f⟩e = ⟨fe⟩
⟨f⟩ = f	†	†

γ⟨f⟩ = ⟨γf⟩
κi ⟨f⟩ = κi f
⟨g⟩f = (f + f )⟨gf⟩


A few of these identities were shown already in [9]; the rest are mostly straight- forward to derive. Note that a direct consequence of (i) is that (⟨f⟩ + ⟨f⟩)⟨f⟩ = (κ1 + κ2)⟨f⟩; we will make heavy use of this fact in Section 4. Another particularly useful identity is the following, stating intuitively that anything that behaves as a decision in each component is, in fact, a decision.

Lemma 3.3 If κ†p = κ†f and κ†p = κ†f then p = ⟨f⟩.
1	1	2	2

Proof. By Lemma 3.2(ii) ⟨f⟩† =  κ†f, κ†f . Since κ†p = κ†f and κ†p = κ†f it

follows that κ†f = (κ†f )† = (κ†p)† = p†κ1 and κ†f = (κ†f )† = (κ†p)† = p†κ2 so it

1	1	1
2	2	2
   	   	  

		

⟨f⟩†, and finally p = ⟨f⟩ by unicity of partial inverses.	2
As a corollary, p is a decision if κ†p and κ†p are both restriction idempotents
1	2
(i.e., if κ†p = κ†p and κ†p = κ†p) since all decisions decide themselves (i.e., since
1	1	2	2
⟨⟨p⟩⟩ = ⟨p⟩).

Theorem 3.4 There is a functor C op −D−e→c
Set given by mapping objects to their

decisions, and morphisms to decision transformers.
Proof. Define this functor by Dec(X) = {⟨p⟩ | p ∈ Hom(X, X + X)} on objects, and by Dec(f : Y → X)(⟨p⟩) = ⟨⟨p⟩f ⟩ on morphisms. This is contravariantly functorial since Dec(idX )(⟨p⟩) = ⟨⟨p⟩ idX⟩ = ⟨⟨p⟩⟩ = ⟨p⟩ by Lemma 3.2(i), and Dec(gf )(⟨p⟩) = ⟨⟨p⟩gf ⟩ = ⟨⟨⟨p⟩g⟩f ⟩ = Dec(f )(Dec(g)(⟨p⟩)) by Lemma 3.2(vi) and definition of Dec(f ), as desired.	2

From now on, we will use the notation Dec(Y ) transformation Dec(f ).
fo
−→ Dec(X) for the decision

This is an example of a fibred category, which have historically been important in categorical presentations of logic, e.g., in topoi (see [15] for a thorough treatment of indexed and fibred categories in categorical logic). In Section 4, we will see that this indexed category extends beyond Set toa model of Kw. For now, it is sufficient to show the equivalence between conditions (morphisms X → 1 + 1) and decisions (morphisms X → X + X satisfying the decision laws of Definition 2.2).

Theorem 3.5 (Condition/decision duality) Decisions and predicates are nat- urally isomorphic in any extensive restriction category with a restriction terminal object: Dec(−) ∼= Hom(−, 1+ 1) .
Proof. Let C be an extensive restriction category with a restriction terminal object, and X some object of C ; we begin by showing that the mappings


⟨f⟩
X
⟨f⟩
!+!
p	⟨p⟩

−−→ X+X	'→	X −−→ X+X −−→ 1+1	and	X −→ 1+1	'→	X −−→ X+X

between Dec(X) and Hom(X, 1 + 1) yields a bijection. In other words, we must show that ⟨(!+!)⟨f ⟩⟩ = ⟨f⟩ and p = (!+!)⟨p⟩. To show ⟨(!+!)⟨f ⟩⟩ = ⟨f⟩, we show that
⟨f⟩ decides (!+!)⟨f⟩ by ∇⟨f⟩ = f = ⟨f⟩ = (!+!)⟨f⟩ using the fact that the unique

map X −→!
1 is total by 1 restriction terminal, and by (((!+!)⟨f⟩) + ((!+!)⟨f⟩))⟨f⟩ =

((!+!) + (!+!))(⟨f⟩ + ⟨f⟩)⟨f⟩ = ((!+!) + (!+!))(⟨f⟩ + ⟨f⟩)⟨⟨f ⟩⟩ = ((!+!) + (!+!))(κ1 +
κ2)⟨f⟩ = (κ1 + κ2)(!+!)⟨f⟩. Thus ⟨(!+!)⟨f ⟩⟩ = ⟨f⟩, as desired.
p
To show that p = (!+!)⟨p⟩ for X −→ 1 + 1 we show something slightly more
f
general, namely that (!+!)f = (!+!)⟨f⟩ for any X −→ Y + Z. That p = (!+!)⟨p⟩ then
follows as a special case since id1+1 = (!+!) by 1 terminal, so p = id1+1 p = (!+!)p. This slightly more general statement follows by commutativity of the diagram below.
⟨f⟩
X  X + X


f	(i)
f + f

(iii)

!+!

Y + Z

κ1 + κ2
(Y + Z)+ (Y + Z)

!+!

(ii)
1+1 

!+!
Here, (i) commutes by the second axiom of decisions, while (ii) and (iii) both commute by 1 terminal.
To see that this bijection extends to a natural isomorphism, we must fix some
f

−→ X and chase the diagram
∼=
Dec(X)

Hom(X, 1+ 1)



fo

Dec(Y )	∼=
f∗

Hom(Y, 1+ 1)

where we use fo to denote the functorial action Dec(f ), Dec(f )(⟨p⟩) = ⟨⟨p⟩f ⟩. Picking some ⟨g⟩ ∈ Dec(X) we must have (!+!)⟨⟨g⟩f ⟩ = (!+!)⟨g⟩f , which indeed follows by the statement above. On the other hand, picking some p ∈ Hom(X, 1+1), chasing yields that we must have ⟨⟨p⟩f ⟩ = ⟨pf⟩, which follows directly by Lemma 3.2
(vi).	2

A consequence of this equivalence in extensive restriction categories is that de- cisions are a property of the predicates rather than a property of arbitrary maps, as it is commonly presented. This is shown in the following corollary to Theorem 3.5.
Corollary 3.6 A restriction category with restriction coproducts, a restriction zero, and a restriction terminal object has all decisions ( i.e., is extensive as a restriction category) iff it has all decisions of predicates.
Proof. It follows directly that having decisions for all morphisms implies having decisions for all predicates. On the other hand, suppose that the category only has
f
decisions for predicates, and let X −→ Y + Z be an arbitrary morphism. But then,
f	!+!
by the proof of Theorem 3.5, the decision for the predicate X −→ Y + Z −−→ 1+1 
f
decides X −→ Y + Z (by ⟨(!+!)f⟩ = ⟨(!+!)⟨f ⟩⟩ = ⟨f⟩), and we are done.	2
The internal logic of extensive restriction categories
Having established the natural isomorphism of decisions and predicates (with their respective transformers) which forms the condition/decision duality at the categor- ical level, we now turn to their structure. The main result of this section, Theo- rem 4.7, shows that the decisions Dec(X) on an object X form a model of Kw, and
fo
that decision transformers Dec(Y ) −→ Dec(X) are homomorphisms of these mod-
els. We first recall Kleene’s three valued logics, in particular Kw and its algebraic
counterpart of De Morgan quasilattices.

Kleene’s three valued logics and De Morgan quasilattices
Kleene’s three valued logics of K3 (strong Kleene logic) and Kw (weak Kleene logic), both introduced in [21], are logics based on partial predicates with a computational interpretation: Predicates are conceived of as programs which may not terminate, but if they do, they terminate with a Boolean truth value as output. In this way, both K3 and Kw can be thought of as partial versions of classical logic. Here, pos- sible nontermination is handled analogously to how it is handled in domain theory, i.e., by the introduction of a third truth value in addition to truth t and falsehood f , denoted u in Kleene’s presentation [21], which should be read as “undefined”.
The difference between K3 and Kw lies in how they cope with undefined truth

values. In Kw
(see Figure 3), undefinedness is “contagious”: if any part of an

expression is undefined, the truth value of the entire expression is undefined as well 4 . This fits well into a computation paradigm with possible nontermination and only sequential composition available. In contrast, the semantics of K3 is to try to recover definite truth values whenever possible, even if part of the computation fails to terminate. For example, in K3 (and unlike Kw), p ∧ q is considered false if

4 This contagious behaviour has also been used to explain other phenomena. In philosophy, Kw is better known as B3 or Bochvar’s nonsense logic (see, e.g., [12]), and the third truth value read as “meaningless”
or “nonsensical” rather than “undefined”. The central idea is that nonsense is contagious: e.g., “2 + 2 = 5 and gobbledygook” is nonsensical even if part of it can be assigned meaning.





Weak conjunction.

Weak disjunction.
Fig. 3. The three-valued semantics of Kw.
Negation.

one of p and q is false, even if the other is undefined. While this allows for some recovery in the face of nontermination, computationally it seems to require parallel processing capabilities.
Like classical logic takes its algebraic semantics in Boolean algebras, the cor-

responding algebraic structure for Kw
is that of De Morgan quasilattices (see,

e.g., [12]). As is sometimes done, we assume these to be distributive; i.e., what we call De Morgan quasilattices are sometimes called distributive De Morgan quasi- lattices or even (distributive) De Morgan bisemilattices (see, e.g., [23]). Note that we generally do not require these to be bounded, i.e., for top and bottom elements T and ⊥ to exist.
Definition 4.1 A De Morgan quasilattice (in its algebraic formulation) is a quadru- ple A = (|A|, ч, Λ, V) satisfying the following equations, for all p, q, r ∈ |A|:


p Λ p = p,
p V p = p,
p Λ q = q Λ p,
p V q = q V p,
p Λ (q Λ r)= (p Λ q) Λ r,
p V (q V r)= (p V q) V r,
p Λ (q V r)= (p Λ q) V (p Λ r),
p V (q Λ r)= (p V q) Λ (p V r),
ччp = p,
ч(p Λ q)= чp V чq,
ч(p V q)= чp Λ чq,

Further, a De Morgan quasilattice A is said to be bounded if there exist elements
⊥, T∈ |A| such that the following are satisfied (for all p ∈ |A|):
p ΛT = p, and	(xiii) p V⊥ = p.


A homomorphism A —→h
B of De Morgan quasilattices is a function |A| → |B|

which preserves ч, Λ, and V. A homomorphism of bounded De Morgan quasilattices is one which additionally preserves T and ⊥.
Being a De Morgan quasilattice is a strictly weaker property than being a Boolean algebra. In particular, a Boolean algebra is a bounded De Morgan quasi- lattice which further satisfies the absorption laws p = p Λ (p V q) and p = p V (p Λ q), and the laws of contradiction and tertium non datur, p Λ чp = ⊥ and p V чp = T. De Morgan quasilattices and their homomorphisms form a category which we call DMQLat. As for Boolean algebras, one can derive a partial order on De Morgan quasilattices by p “ q iff p Λ q = p, and another one by p ± q iff p V q = q.

Unlike as for Boolean algebras, however, these do not coincide, though they are anti-isomorphic, as it follows from the De Morgan laws that p “ q iff чq ± чp. We will return to these in Section 4 and argue why · “ · is the one more suitable as the entailment relation for Kw.

The internal logic
With Kw and De Morgan quasilattices introduced, we return to the construction of the internal logic. To aid in its presentation (and subsequent proofs), we start by introducing a graphical language of extensive restriction categories, based on the one for cocartesian categories (see, e.g., [25]). Then, we show how the constants and connectives of Kw can be interpreted (Definition 4.2) as decisions on an object (Lemma 4.3). Finally, we show that decisions on an object form a model of Kw (Lemma 4.5), and that decision transformations are homomorphisms of these models (Lemma 4.6), concluding this construction. We go on to explore an important corollary to this construction, namely that if we restrict ourselves from ordinary decisions to total decisions and total decision transformations, we obtain a fibration over Boolean algebras instead (Corollary 4.10 Theorem 4.11). The latter is a well- known property of extensive categories first shown in [6], though this proof uses entirely different machinery.
Figure 4 shows the graphical language of extensive restriction categories, which has the restriction coproduct as its monoidal tensor. The first five gadgets are from cocartesian categories (γX,Y is here the twist map, [κ2, κ1]). We add gadgets

⟨f⟩
⟨f⟩†

corresponding to decisions X ——→ X + X, inverses to decisions X + X ——→ X (as all
decisions are partial isomorphisms, see Lemma 3.2(ii)), and restriction idempotents
f
X —→ X. The gadget for inverses to decisions was inspired by assertions in reversible
flowcharts (see [29]). Useful derived gadgets include

X	X

Y

X Y

X

Y 

X
X	Y
Y	Y 

κ1	κ†
κ2	κ†
0X,Y

Just as the graphical language of cocartesian categories, isomorphism or isotopy of diagrams is not enough for coherence – equations only hold in the graphical language up to diagrammatic manipulations corresponding to the decision laws, as well as the diagrammatic manipulations for coproducts (e.g., the commutative monoid axioms and naturality for the codiagonal, the zero morphism laws, etc.). For more on the latter, see [25]. For example, graphically, the decision laws are

=

As in the example above, when the signature is clear from the context, we omit the object annotations (e.g., X, Y, Z in Figure 4).
With the graphical language in place, we proceed to give the definition of the


 X 	 Y 


 X' 	 Y '

 X 


 X' 

X	Y
X	X


X f X

f + g	[f, g]	γX,Y	00,X  0X,0	⟨f⟩	⟨f⟩†	f

Fig. 4. An overview of the gadgets that make up the graphical language of extensive restriction categories.
internal logic of decisions in an extensive restriction category, i.e., the entailment relation and construction of constants and propositional connectives.
Definition 4.2 In an extensive restriction category, propositional constants and connectives are defined for decisions as follows, using the graphical language:

T	=	⊥	= 		ч	=
q


Λ
=
V	=



Entailment is defined by ⟨p⟩ ▶ ⟨q⟩ iff ⟨p⟩ “ ⟨q⟩ (explicitly, iff ⟨p⟩Λ ⟨q⟩ = ⟨p⟩).
For those more textually inclined, this defines T = κ1, ⊥ = κ2, ч⟨p⟩ = γ⟨p⟩,
⟨p⟩V ⟨q⟩ = (⟨p⟩† + id)α(⟨q⟩ + ⟨q⟩)⟨p⟩, and ⟨p⟩Λ ⟨q⟩ = (id +⟨p⟩†)α(⟨q⟩ + ⟨q⟩)⟨p⟩.
Intuitively, we think of decisions as representing partial predicates by separating values into witnesses and counterexamples of that partial predicate (see also [19]). The definitions of T and ⊥ express the convention that the first component carries witnesses, while the second component carries counterexamples. Negation of partial predicates then amounts to swapping witnesses for counterexamples and vice versa, i.e., by composing with the symmetry. The intuition behind conjunction (and, dually, disjunction) is less obvious: Using the intuition of decisions as morphisms that tag inputs with a branch but doesn’t change it otherwise, we see that a witness of ⟨p⟩Λ ⟨q⟩ has to be a witness of both ⟨p⟩ and ⟨q⟩, while a counterexample of
⟨p⟩Λ⟨q⟩ is either a counterexample of ⟨p⟩ which is further defined for ⟨q⟩ (necessary to ensure commutativity), or a witness of ⟨p⟩ which is a counterexample of ⟨q⟩. The case for disjunctions is dual.
Before we move on to show that this actually has the logical structure we’re after, we first obliged to show that these connectives and constants actually define well-formed decisions. This fact is expressed in the following lemma.
Lemma 4.3 The constants and connectives of Deﬁnition 4.2 are decisions.
Proof. See appendix.	2
Before we can proceed, we need a small technical lemma.

Lemma 4.4 Let
and
be decisions. It is the case that


(i)

=	(ii)
q	q
=	(iii)	=


Proof. See appendix.	2
The first part of this lemma can be seen as a form of commutativity for decisions – and, indeed, it performs most of the heavy lifting in showing commutativity of conjunction and disjunction. On the other hand, parts (ii) and (iii) shows that we could have defined conjunction and disjunction more simply in Definition 4.2. The reason why we chose the current definition is that it yields entirely reversible models (see also [19]), i.e., involving only partial isomorphisms. We will discuss this property further in Section 5. For now, we continue with the internal logic.
Lemma 4.5 Dec(X) is a bounded De Morgan quasilattice for any object X.
Proof. We show only a few of the cases here using the graphical language. See the appendix for the rest. Idempotence of conjunction, i.e., ⟨p⟩Λ ⟨p⟩ = ⟨p⟩, follows by

=	=	=	=	=

and similarly for disjunction. That ⟨p⟩ΛT = ⟨p⟩ is shown simply by
=	=

and again, the unit law for disjunction has an analogous proof. The first De Morgan law, that ч⟨p⟩Λ ч⟨q⟩ = ч(⟨p⟩V ⟨q⟩)




q  		
q
=	= p	=
q
q  	  	q	q

=	=	=
and the proof of the second De Morgan law follows similarly.	2
As such, we have that each collection of decisions on an object form a local model of Kw, giving us the first part of the fibration. For the second, we need to show that decision transformers preserve entailment and the propositional connectives (though not necessarily the constants). This is shown in the following lemma.
f	fo
Lemma 4.6 Let X —→ Y . Then Dec(Y ) —→ Dec(X) is a homomorphism of De
Morgan quasilattices, i.e.,

⟨p⟩	▶	⟨q⟩ implies fo(⟨p⟩)	▶
fo(⟨q⟩)
fo(ч⟨p⟩)= чfo(⟨p⟩)
fo(⟨p⟩Λ ⟨q⟩)= fo(⟨p⟩) Λ fo(⟨q⟩)
fo(⟨p⟩V ⟨q⟩)= fo(⟨p⟩) V fo(⟨q⟩)

In addition, if f is total then fo is a homomorphism of bounded De Morgan quasilattice; i.e., we also have fo(T)= T and fo(⊥)= ⊥.
Proof. (i) follows by (iii) since ⟨p⟩ ▶ ⟨q⟩ iff ⟨p⟩ “ ⟨q⟩ iff ⟨p⟩Λ ⟨q⟩ = ⟨q⟩, which in turn implies that fo(⟨p⟩) Λ fo(⟨q⟩) = fo(⟨p⟩Λ ⟨q⟩) = fo(⟨p⟩), so fo(⟨p⟩) “ fo(⟨q⟩) as well, i.e., fo(⟨p⟩) ▶ fo(⟨q⟩).
For (ii), we compute fo(ч⟨p⟩) = fo(γ⟨p⟩) = fo(⟨γp⟩) = ⟨⟨γp⟩f ⟩ = ⟨γpf⟩ =
γ⟨pf⟩ = γ⟨⟨p⟩f ⟩ = чfo(⟨p⟩) (using Lemma 3.2).
follows by lengthy but straightforward computation(see appendix).
is analogous to the previous case.	2
Notice the final part regarding preservation of units. Generally, fo(T)= ⟨Tf⟩ =
⟨κ1f⟩, so fo(T)= ⟨κ1f⟩ = κ1f = κ1f = f , so if f is not total, ⟨κ1f⟩ /= κ1 (instead
⟨κ1f⟩ = κ1f ).
Putting the two lemmas together gives us the main result:
Theorem 4.7 In every extensive restriction category C , decisions over C form a ﬁbred De Morgan quasilattice via the decision ﬁbration.
Proof. By Lemmas 4.5 and 4.6.	2
We previously claimed that the conjunction order was the more suitable one for entailment in extensive restriction categories. We are finally ready to state why:
Lemma 4.8 Entailment is upwards directed in truth and deﬁnedness: ⟨p⟩ ▶ ⟨q⟩ iff
κ†⟨p⟩≤ κ†⟨q⟩ and ⟨p⟩≤ ⟨q⟩.
1	1
Proof. See appendix.	2
In other words, ⟨p⟩ entails ⟨q⟩ iff ⟨q⟩ is both at least as true and at least as deﬁned as ⟨p⟩ is. That is, entailment preserves not only truth (as we expect all entailments to) but also information (as we expect of orders on partial maps). Compare this to the disjunction partial order for which ⟨p⟩± ⟨q⟩ instead states that ⟨q⟩ is less false and less deﬁned than ⟨p⟩: In other words, it prefers for information to be forgotten rather than preserved.
We move on now to an important special case of the situation above, which is when only total decisions are considered rather than arbitrary ones. For this, we need a small lemma regarding the restriction idempotents of decisions when composed using the propositional connectives.
Lemma 4.9 We state some facts about restriction idempotents of decisions:


	
ч⟨p⟩ = ⟨p⟩,
⟨p⟩Λ ⟨q⟩ = ⟨p⟩ ⟨q⟩,
	
⟨p⟩V ⟨q⟩ = ⟨p⟩ ⟨q⟩,

		
⟨p⟩Λ ⟨q⟩ ≤ ⟨p⟩ and ⟨p⟩Λ ⟨q⟩ ≤
⟨q⟩,

⟨p⟩V ⟨q⟩ ≤ ⟨p⟩ and ⟨p⟩V ⟨q⟩ ≤
⟨q⟩.

Proof. See appendix.	2
We can now show that total decisions form a fibred Boolean algebra.
Corollary 4.10 TDec(X) is a Boolean algebra for any object X, and f Δ :
f
TDec(Y ) → TDec(X) is homomorphism of Boolean algebras for any total X —→ Y .
Proof. Since Dec(X) is a De Morgan quasilattice (Lemma 4.5), since total decisions are specifically decisions, and since the constants are total and the connectives preserve totality (Lemma 4.9), it suffices to show that when ⟨p⟩ and ⟨q⟩ are total they satisfy the absorption laws ⟨p⟩ = ⟨p⟩Λ (⟨p⟩V⟨q⟩ and ⟨p⟩ = ⟨p⟩V (⟨p⟩Λ⟨q⟩), and the laws of contradiction and tertium non datur, ⟨p⟩Λч⟨p⟩ = ⊥ and ⟨p⟩Vч⟨p⟩ = T. The first absorption law follows by
q			q	q	q p	p	p

p	q	=
 p ∨ q  p q
p	q
 p ∨ q  q
=	=	=

q

=	=	=

and the other follows analogously. Likewise, the law of contradiction can be shown as
=	=	=	=	=

=	= p  = 	

and similarly for tertium non datur.	2
Using the previous corollary, it follows (see [6] for the original proofs from effectus theory) that predicates over an extensive category form a fibred Boolean algebra.
Theorem 4.11 Predicates (or, equivalently, decisions) over an extensive category is a ﬁbred Boolean algebra via the predicate ﬁbration (or, equivalently, the decision ﬁbration).
Proof. Since total decisions on objects form Boolean algebras by Corollary 4.10, it suffices to show that every extensive category arises as the subcategory of total morphisms of an extensive restriction category.

Let C be an extensive category, and M denote the collection of all coproduct injections of C . As remarked in [7], this is a stable system of monics, and by Example
4.17 of [8], Par(C , M) is a classified restriction category under the +1 monad. Since C has coproducts and Par(C , M) is classified, it follows by Proposition 2.3 of [9] that Par(C , M) has restriction coproducts. That 0 is a restriction zero in

Par(C
!X	!Y

, M) follows straightforwardly, with the span X →—› 0 —→ Y as the unique
0X,Y
zero morphism X ———→ Y . As such, it suffices to show that decisions can be

constructed in Par(C
, M). Let X
m
→—› X
f
—→ Y + Z be an arbitrary morphism

of Par(C , M). Since C is extensive it has pullbacks of coproduct injections along arbitrary morphisms, so the two squares

m1
1
f1
Y	κ1
Xj	m2	X
f	f2
Y + Z	κ2	Z

are pullbacks, and so the top row is a coproduct diagram (i.e., X1 + X2 ∼= Xj). But then it readily follows that

~= X1 + X2
m1+m2

m  X′	X′ + X′
m+m

X	X + X
m	j f
is a decision for X →—› X —→ Y + Z in Par(C , M), and we are done.	2

Conclusion and future work
Motivated by an observation from flowchart languages that predicates serve a dual role as both condition and decision, we have given an account of extensive restriction categories (due to [7–9]) as categories with an internal logic (namely Kw) that internalize this duality, in the form of a natural isomorphism between the predicate fibration and the decision fibration.
We have also extended the graphical language of cocartesian categories to one for extensive restriction categories, and used our results to give an alternative proof of the fact that extensive categories, too, are categories with an internal logic – classical logic. While the graphical language has proven itself useful in proving theorems, it does have its shortcomings. For example, the only way to express restriction
gf
idempotents of compositions, such as gf , is, awkwardly, as  . That is, we
would want only one representation of composition as placing gadgets in sequence, but since gf cannot generally be expressed as a composite involving only smaller things (e.g., f and g), we are forced in this case to let the textual representation (i.e., juxtaposition) bleed into the graphical language. The graphical notation for decisions has similar issues.
An application of the developed theory is in reversible models of logics, which was also the motivation for defining the connectives in slightly more involved fash-

ion, using partial inverses to decisions rather than the codiagonal. Indeed, the inspiration for using decisions as predicates came from the study of the categorical semantics of reversible flowchart languages (see [13,19]). Since a decision in C is still a decision in Inv(C ) (see [19]), Dec(X) is still a De Morgan quasilattice in Inv(C ), though the homomorphisms between fibres differ (i.e., only decision transformers that are partial isomorphisms occur in the decision fibration on Inv(C )).
We have only considered the weak Kleene logic Kw here, as it can be constructed by purely sequential means. However, we conjecture that the strong Kleene logic K3 can be modelled as well in extensive restriction categories if additionally a parallel composition operator such as finite joins (see [14]) is available. Finally, just the propositional fragment of Kw and classical logic has been considered in this paper. Though decisions on an object yields a fibred category with a logical structure, we have not explored extensions to models of first-order logics, e.g., by investigating the feasibility of adjoints to substitution, as in the standard trick due to Lawvere [22] (see also [15]).

References
P. Ammann and J. Offutt. Introduction to Software Testing. Cambridge University Press, 1st edition, 2008.
M. A. Arbib and E. G. Manes. Partially additive categories and flow-diagram semantics. Journal of Algebra, 62(1):203 – 227, 1980.
E. Ashcroft and Z. Manna. The translation of ’go to’ programs into ’while’ programs. In C. V. Freiman,
J. E. Griffith, and J. L. Rosenfeld, editors, Proceedings of IFIP Congress 71, volume 1, pages 250–255. North-Holland, 1972.
C. B¨ohm and G. Jacopini. Flow diagrams, Turing machines and languages with only two formation rules. Communications of the ACM, 9(5):366–371, 1966.
A. Carboni, S. Lack, and R. Walters. Introduction to extensive and distributive categories. Journal of Pure and Applied Algebra, 84(2):145–158, 1993.
K. Cho, B. Jacobs, B. Westerbaan, and A. Westerbaan. An introduction to effectus theory. See
http://arxiv.org/abs/1512.05813, 2015.
J. R. B. Cockett and S. Lack. Restriction categories I: Categories of partial maps. Theoretical Computer Science, 270(1–2):223–259, 2002.
J. R. B. Cockett and S. Lack. Restriction categories II: Partial map classification. Theoretical Computer Science, 294(1–2):61–102, 2003.
R. Cockett and S. Lack. Restriction categories III: Colimits, partial limits and extensivity. Mathematical Structures in Computer Science, 17(4):775–817, 2007.
C. C. Elgot. Monadic computation and iterative algebraic theories. In H. E. Rose and J. C. Shepherdson, editors, Logic Colloquium, pages 175–230. North Holland, 1975.
C. C. Elgot. Structured programming with and without GO TO statements. IEEE Transactions on Software Engineering, SE-2:41–53, 1976.
V. K. Finn and R. Grigolia. Nonsense logics and their algebraic properties. Theoria, 59(1–3):207–273, 1993.
R. Glu¨ck and R. Kaarsgaard. A categorical foundation for structured reversible flowchart languages. In A. Silva, editor, The Thirty-third Conference on the Mathematical Foundations of Programming Semantics (MFPS XXXIII), volume 336 of Electronic Notes in Theoretical Computer Science. Elsevier, 2017.
X. Guo. Products, Joins, Meets, and Ranges in Restriction Categories. PhD thesis, University of Calgary, 2012.


B. Jacobs. Categorical Logic and Type Theory, volume 141 of Studies in Logic and the Foundations of Mathematics. Elsevier, first edition, 1999.
B. Jacobs. New directions in categorical logic, for classical, probabilistic and quantum logic. Logical Methods in Computer Science, 11(3), 2015.
N. D. Jones, C. K. Gomard, and P. Sestoft. Partial Evaluation and Automatic Program Generation. Prentice Hall International, 1993.
R. Kaarsgaard, H. B. Axelsen, and R. Glu¨ck. Join inverse categories and reversible recursion. Journal of Logical and Algebraic Methods in Programming, 87:33–50, 2017.
R. Kaarsgaard and R. Glu¨ck. A categorical foundation for structured reversible flowchart languages: Soundness and adequacy. Logical Methods in Computer Science, 14(3):1–38, 2018.
J. Kastl. Inverse categories. In H.-J. Hoehnke, editor, Algebraische Modelle, Kategorien und Gruppoide, volume 7 of Studien zur Algebra und ihre Anwendungen, pages 51–60. Akademie-Verlag, 1979.
S. C. Kleene. Introduction to metamathematics. North Holland, 1st edition, 1952.
F. W. Lawvere. Adjointness in foundations. Dialectica, 23:281–296, 1969.
A. Ledda. Stone-type representations and dualities for varieties of bisemilattices. Studia Logica, 106(2):417–448, 2018.
E. G. Manes and M. A. Arbib. Algebraic approaches to program semantics. Springer, 1986.
P. Selinger. A survey of graphical languages for monoidal categories. In B. Coecke, editor, New Structures for Physics, pages 289–355. Springer, 2011.
G. S¸tefa˘nescu. An algebraic theory of flowchart schemes. In P. Franchi-Zannettacci, editor, CAAP ’86, volume 214 of Lecture Notes in Computer Science, pages 60–73. Springer, 1986.
G. S¸tefa˘nescu. On flowchart theories part I: The deterministic case. Journal of Computer and System Sciences, 35(2):163 – 191, 1987.
M. Williams and H. Ossher. Conversion of unstructured flow diagrams into structured form. The Computer Journal, 21(2):161–167, 1978.
T. Yokoyama, H. B. Axelsen, and R. Glu¨ck. Fundamentals of reversible flowchart languages. Theoretical Computer Science, 611:87–115, 2016.

A	Omitted proofs
Proof. [Proof of Lemma 3.2] For (i) and (ii), see [9]. (iii) follows by (ii) since

⟨f⟩† = [κ†f, κ†f ]= κ†f + κ†f = κ†f + κ†f. 
1	2	1	2	1	2

For (iv), ⟨f⟩ = ⟨f⟩ = ∇⟨f⟩ = ∇⟨f⟩ = f = f . To show (v) we show that γ⟨f⟩
decides γf , since ∇γ⟨f⟩ = ∇⟨f⟩ = f = f = γf = γf and
((γf )+ (γf ))γ⟨f⟩ = γ((γf )+ (γf ))⟨f⟩ = γ(γ + γ)(f + f )⟨f⟩ = γ(γ + γ)(κ1 + κ2)p
= γ((γκ1)+ (γκ2))p = γ(κ2 + κ1)p = (κ1 + κ2)γp
which was what we wanted. We show (vi) analogously by showing that ⟨⟨f ⟩g⟩
decides ⟨fg⟩ since ∇⟨⟨f ⟩g⟩ = ⟨f⟩g = ∇⟨f⟩g = ∇⟨f⟩g = fg = fg and
((fg)+ (fg))⟨⟨f ⟩g⟩ = ((ffg)+ (ffg))⟨⟨f ⟩g⟩ = ((f∇⟨f⟩g)+ (f∇⟨f⟩g))⟨⟨f ⟩g⟩
= ((f∇)+ (f∇))((⟨f⟩g)+ (⟨f⟩g))⟨⟨f ⟩g⟩
= ((f∇)+ (f∇))(κ1 + κ2)⟨f⟩g = ((f∇κ1)+ (f∇κ2))⟨f⟩g
= (f + f )⟨f⟩g = (κ1 + κ2)fg .

For (vii), we observe that (e + e)⟨f⟩ = ∇(e + e)⟨f⟩ = e∇⟨f⟩ = ef = ef = fe = ⟨f⟩e so (e + e)⟨f⟩ = (e + e)⟨f⟩(e + e)⟨f⟩ = (e + e)⟨f⟩⟨f⟩e = (e + e)⟨f⟩e. To show (viii), we show that the two morphism decide one another. We see that ⟨f⟩e decides (e+e)⟨f⟩ since ∇⟨f⟩e = fe = ⟨f⟩e = (e + e)⟨f⟩ (see (vii) above) and

(((e + e)⟨f⟩)+ ((e + e)⟨f⟩))⟨f⟩e = ((e + e)+ (e + e))(⟨f⟩ + ⟨f⟩)⟨f⟩e
= ((e + e)+ (e + e))(⟨f⟩ + ⟨f⟩)⟨⟨f ⟩⟩e = ((e + e)+ (e + e))(κ1 + κ2)⟨f⟩e
= (κ1 + κ2)(e + e)⟨f⟩e = (κ1 + κ2)(e + e)⟨f⟩


where (e+e)⟨f⟩ = (e+e)⟨f ⟩e by (vii); thus ⟨f⟩e decides (e+e)⟨f⟩, i.e., ⟨(e+e)⟨f ⟩⟩ =
⟨f⟩e = ⟨⟨f ⟩e⟩ (the latter by (i)). In the other direction, ∇(e + e)⟨f⟩ = e∇⟨f⟩ =
ef = fe = ⟨f⟩e and it is the case that

((⟨f⟩e)+ (⟨f⟩e))(e + e)⟨f⟩ = ((⟨f⟩e)+ (⟨f⟩e))(e + e)⟨f⟩e
= ((⟨f⟩ee)+ (⟨f⟩ee))⟨f⟩e = ((⟨f⟩e)+ (⟨f⟩e))⟨f⟩e
= ((⟨f⟩e)+ (⟨f⟩e))⟨⟨f ⟩e⟩ = (κ1 + κ2)⟨f⟩e


For (ix) we have that ⟨f⟩e = ⟨⟨f ⟩e⟩ by (viii) and get ⟨f⟩e = ⟨⟨f ⟩e⟩ = ⟨fe⟩ by (vi).
For (x), by (ii) ⟨f⟩†	=	 κ†f, κ†f  so κ†⟨f⟩	=	κ†  κ†f, κ†f †	=


 
  κ†f, κ†f  κ  †
1	2	i
† †	†
i	1	2

For (xi), we compute
⟨g⟩f = (κ† + κ†)(κ1 + κ2)⟨g⟩f = (κ† + κ†)((⟨g⟩f )+ (⟨g⟩f ))⟨⟨g⟩f ⟩
1	2	1	2
= (κ† + κ†)((⟨g⟩f )+ (⟨g⟩f ))⟨gf⟩ = (κ† + κ†)(⟨g⟩ + ⟨g⟩)(f + f )⟨gf⟩
1	2	1	2
= ((κ†⟨g⟩)+ (κ†⟨g⟩))(f + f )⟨gf⟩ = (κ†g + κ†g)(f + f )⟨gf⟩
1	2	1	2
= (f + f )(κ†gf + κ†gf )⟨gf⟩ = (f + f )[κ†gf, κ†gf ]⟨gf⟩ = (f + f )⟨gf⟩†⟨gf⟩
1	2	1	2
= (f + f )⟨gf⟩
where we use that κ†⟨g⟩ = κ†g by (xi), and ⟨gf⟩† = [κ†gf, κ†gf ] by (ii).	2
i	i	1	2
Proof. [Proof of Lemma 4.3] That T = κ1 and ⊥ = κ2 are decisions is shown in [9]. That ч⟨p⟩ = γ⟨p⟩ is a decision follows by γ⟨p⟩ = ⟨γp⟩ by Lemma 3.2(v). To see that ⟨p⟩Λ ⟨q⟩ is a decision, it suffices by Lemma 3.3 to show that κ†(⟨p⟩Λ ⟨q⟩) = 


	
κ†(⟨p⟩Λ ⟨q⟩) and κ†(⟨p⟩Λ ⟨q⟩)= κ†(⟨p⟩Λ ⟨q⟩). We compute
1	2	2

κ†(⟨p⟩Λ ⟨q⟩)= κ†(id +⟨p⟩†)α(⟨q⟩ + ⟨q⟩)⟨p⟩
1	1
= id κ†α(⟨q⟩ + ⟨q⟩)⟨p⟩

= κ†α(⟨q⟩ + ⟨q⟩)⟨p⟩
= κ†κ†(⟨q⟩ + ⟨q⟩)⟨p⟩
1 1
= κ†⟨q⟩κ†⟨p⟩
1	1
= κ†q κ†p
1	1

so κ†(⟨p⟩Λ ⟨q⟩)= κ†q κ†p = κ†q κ†p = κ†(⟨p⟩Λ ⟨q⟩). Further
1	1	1	1	1	1
κ†(⟨p⟩Λ ⟨q⟩)= κ†(id +⟨p⟩†)α(⟨q⟩ + ⟨q⟩)⟨p⟩
2	2
= ⟨p⟩†κ†α(⟨q⟩ + ⟨q⟩)⟨p⟩

= ⟨p⟩†(κ† + id)(⟨q⟩ + ⟨q⟩)⟨p⟩
= ⟨p⟩†((κ†⟨q⟩)+ ⟨q⟩))⟨p⟩

= ⟨p⟩†(κ†q + q))⟨p⟩
≤ ⟨p⟩†(q + q))⟨p⟩
= ⟨p⟩†⟨p⟩q
= ⟨p⟩q
= p q

so since κ†(⟨p⟩Λ⟨q⟩) ≤ p q it follows that κ†(⟨p⟩Λ⟨q⟩)= κ†(⟨p⟩Λ ⟨q⟩), and so finally
2	2	2
⟨p⟩Λ ⟨q⟩ is a decision by Lemma 3.3. The case for ⟨p⟩V ⟨q⟩ is entirely analogous.2
Proof. [Proof of Lemma 4.6(iii)] By Lemma 3.3 it suffices to show that κ†fo(⟨p⟩Λ 
⟨q⟩) = κ†(fo(⟨p⟩) Λ fo(⟨q⟩)) and κ†fo(⟨p⟩Λ ⟨q⟩) = κ†(fo(⟨p⟩) Λ fo(⟨q⟩)), Firstly
1	2	2
we expand fo(⟨p⟩Λ ⟨q⟩) = ⟨(⟨p⟩Λ ⟨q⟩)f⟩ and fo(⟨p⟩) Λ fo(⟨q⟩) = ⟨⟨p⟩f ⟩Λ ⟨⟨q⟩f ⟩ =
⟨pf⟩Λ ⟨qf⟩. Then we compute

κ†(fo(⟨p⟩) Λ fo(⟨q⟩)= κ†⟨(⟨p⟩Λ ⟨q⟩)f⟩ = κ†(⟨p⟩Λ ⟨q⟩)f
1	1	1
= κ†(id +⟨p⟩†)α(⟨q⟩ + ⟨q⟩)⟨p⟩f = id κ†α(⟨q⟩ + ⟨q⟩)⟨p⟩f
1	1
= κ†α(⟨q⟩ + ⟨q⟩)⟨p⟩f = κ†⟨q⟩κ†⟨p⟩f
1	1	1
= κ†⟨q⟩ κ†⟨p⟩f = κ†⟨q⟩fκ†⟨p⟩f
1	1	1	1
= fκ†⟨q⟩f κ†⟨p⟩f = f κ†⟨q⟩f κ†⟨p⟩f
1	1	1	1
= f κ†⟨q⟩f κ†⟨p⟩f = κ†⟨q⟩ff κ†⟨p⟩f
1	1	1	1
= κ†⟨q⟩ff κ†⟨p⟩f = κ†⟨q⟩f κ†⟨p⟩f
1	1	1	1

and

κ†(fo(⟨p⟩Λ fo(⟨q⟩)) = κ†⟨pf⟩Λ ⟨qf⟩ = κ†(⟨pf⟩Λ ⟨qf⟩)
1	1	1
= κ†(id +⟨pf⟩)α(⟨qf⟩ + ⟨qf⟩)⟨pf⟩ = id κ†α(⟨qf⟩ + ⟨qf⟩)⟨pf⟩
1	1
= κ†α(⟨qf⟩ + ⟨qf⟩)⟨pf⟩ = κ†κ†(⟨qf⟩ + ⟨qf⟩)⟨pf⟩
1	1 1
= κ†⟨qf⟩κ†⟨pf⟩ = κ†⟨qf⟩ κ†⟨pf⟩
1	1	1	1
= κ†⟨qf⟩ κ†⟨pf⟩
1	1

so κ†(fo(⟨p⟩) Λ fo(⟨q⟩)) = κ†(fo(⟨p⟩) Λ fo(⟨q⟩)). For the second part,
1	1

κ†fo(⟨p⟩Λ ⟨q⟩)= κ†⟨(⟨p⟩Λ ⟨q⟩)f⟩ = κ†(⟨p⟩Λ ⟨q⟩)f
2	2	2
= κ†(id +⟨p⟩†)α(⟨q⟩ + ⟨q⟩)⟨p⟩f = ⟨p⟩†κ†α(⟨q⟩ + ⟨q⟩)⟨p⟩f
2	2
= ⟨p⟩†(κ† + id)(⟨q⟩ + ⟨q⟩)⟨p⟩f = ⟨p⟩†((κ†⟨q⟩)+ ⟨q⟩)⟨p⟩f
2	2
= ⟨p⟩†(κ†⟨q⟩ + ⟨q⟩)⟨p⟩f = (κ†⟨q⟩ + ⟨q⟩)⟨p⟩†⟨p⟩f
2	2

= (κ†⟨q⟩ + ⟨q⟩)⟨p⟩f = ((κ†⟨q⟩)+ ⟨q⟩)⟨p⟩f
2	2
= ((κ†⟨q⟩)+ ⟨q⟩)⟨p⟩⟨p⟩f = ((κ†⟨q⟩⟨p⟩)+ (⟨q⟩⟨p⟩))⟨p⟩f
2	2
= ((κ†⟨q⟩⟨p⟩f )+ (⟨q⟩⟨p⟩f ))⟨pf⟩


and

κ†(fo(⟨p⟩) Λ fo(⟨q⟩)) = κ†(⟨pf⟩Λ ⟨qf⟩)= κ†(⟨pf⟩Λ ⟨qf⟩)
2	2	2
= κ†(id +⟨pf⟩†)α(⟨qf⟩ + ⟨qf⟩)⟨pf⟩ = ⟨pf⟩†κ†α(⟨qf⟩ + ⟨qf⟩)⟨pf⟩
2	2
= ⟨pf⟩†(κ† + id)(⟨qf⟩ + ⟨qf⟩)⟨pf⟩ = ⟨pf⟩†((κ†⟨qf⟩)+ ⟨qf⟩)⟨pf⟩
2	2
= ⟨pf⟩†(κ†⟨qf⟩ + ⟨qf⟩)⟨pf⟩ = (κ†⟨qf⟩ + ⟨qf⟩)⟨pf⟩†⟨pf⟩
2	2
= (κ†⟨qf⟩ + ⟨qf⟩)⟨pf⟩ = (κ†⟨q⟩f + ⟨q⟩f )⟨pf⟩
2	2
= ((κ†⟨q⟩f )+ (⟨q⟩f ))⟨pf⟩ = ((κ†⟨q⟩f )+ (⟨q⟩f ))⟨pf⟩⟨pf⟩
2	2
= ((κ†⟨q⟩f )+ (⟨q⟩f ))⟨pf⟩⟨p⟩f = ((κ†⟨q⟩f⟨p⟩f )+ (⟨q⟩f⟨p⟩f ))⟨pf⟩
2	2
= ((κ†⟨q⟩⟨p⟩f )+ (⟨q⟩⟨p⟩f ))⟨pf⟩

so also κ†fo(⟨p⟩Λ ⟨q⟩)= κ†(fo(⟨p⟩) Λ fo(⟨q⟩)), which finally gives us fo(⟨p⟩Λ ⟨q⟩)= 
2	2
fo(⟨p⟩) Λ fo(⟨q⟩).	2
Proof. [Proof of 4.9] (i) ч⟨p⟩ = γ⟨p⟩ = γ⟨p⟩ = id⟨p⟩ = ⟨p⟩.

We have

⟨p⟩Λ ⟨q⟩ = (id +⟨p⟩†)α(⟨q⟩ + ⟨q⟩)⟨p⟩

= (id +∇)α(⟨q⟩ + ⟨q⟩)⟨p⟩
= (id +∇)α(⟨q⟩ + ⟨q⟩)⟨p⟩

= id(⟨q⟩ + ⟨q⟩)⟨p⟩
= (⟨q⟩ + ⟨q⟩)⟨p⟩

= (⟨q⟩ + ⟨q⟩)⟨p⟩
= ⟨p⟩⟨q⟩
= ⟨p⟩ ⟨q⟩
follows by analogous reasoning to (ii). We have (iv) immediately by (ii) since
⟨p⟩Λ ⟨q⟩ = ⟨p⟩ ⟨q⟩≤ ⟨p⟩ directly, and likewise ⟨p⟩Λ ⟨q⟩ = ⟨p⟩ ⟨q⟩≤ ⟨q⟩. (v) follows analogously.	2
Proof. [Proof of Lemma 4.8] Assume κ†⟨p⟩≤ κ†⟨q⟩ and ⟨p⟩≤ ⟨q⟩. By Lemma 3.3,
1	1
to show ⟨p⟩Λ ⟨q⟩ = ⟨p⟩ (i.e., ⟨p⟩ ▶ ⟨q⟩) it suffices to show that κ†(⟨p⟩Λ ⟨q⟩)= κ†⟨p⟩
1	1
and κ†(⟨p⟩Λ ⟨q⟩)= κ†⟨p⟩.
2	2
Since						
κ†(⟨p⟩Λ ⟨q⟩)= κ†p κ†q = κ†⟨p⟩ κ†⟨q⟩ = κ†⟨p⟩ = κ†⟨p⟩
1	1	1	1	1	1	1
by the proof of Lemma 4.3, κ†⟨p⟩ ≤ κ†⟨q⟩, and Lemma 3.2, proving the first part.
1	1
For the second part,
κ†(⟨p⟩Λ ⟨q⟩)= κ†(⟨p⟩Λ ⟨q⟩)= ⟨p⟩†(κ†⟨q⟩ + ⟨q⟩)⟨p⟩
2	2	2
= ⟨p⟩†(κ†⟨q⟩ + ⟨q⟩)⟨p⟩ = (κ†⟨p⟩ + κ†⟨p⟩)(κ†⟨q⟩ + ⟨q⟩)⟨p⟩
2	1	2	2
= ((κ†⟨p⟩ κ†⟨q⟩)+ (κ†⟨p⟩ ⟨q⟩))⟨p⟩ = ((κ†⟨p⟩ κ†⟨q⟩ κ†⟨q⟩)+ (κ†⟨p⟩ ⟨q⟩))⟨p⟩
1	2	2	1	1	2	2
= ((κ†⟨p⟩ 0) + (κ†⟨p⟩ ⟨q⟩))⟨p⟩ = (0 + (κ†⟨p⟩ ⟨q⟩))⟨p⟩
1	2	2
= (0 + (κ†⟨p⟩⟨q⟩))⟨p⟩ = (0 + (κ†⟨p⟩⟨p⟩ ⟨q⟩))⟨p⟩
2	2
= (0 + (κ†⟨p⟩⟨p⟩))⟨p⟩ = (0 + (κ†⟨p⟩))⟨p⟩
2	2
= ((0 κ†⟨p⟩)+ (κ†⟨p⟩))⟨p⟩ = (0 + id)(κ†⟨p⟩ + κ†⟨p⟩)⟨p⟩
1	2	1	2
= (0 + id)⟨p⟩†⟨p⟩ = (0 + id)⟨p⟩ = κ†⟨p⟩ = κ†⟨p⟩ = κ†⟨p⟩
2	2	2
In the other direction, suppose that ⟨p⟩ ▶ ⟨q⟩, i.e., ⟨p⟩Λ ⟨q⟩ = ⟨p⟩. Then κ†(⟨p⟩Λ 
⟨q⟩) = κ†⟨p⟩ = κ†⟨p⟩, but since we also know that κ†(⟨p⟩Λ ⟨q⟩) = κ†⟨p⟩ κ†⟨q⟩ (see
1	1	1	1	1
above), it follows that
κ†⟨q⟩κ†⟨p⟩ = κ†⟨q⟩ κ†⟨p⟩ = κ†⟨p⟩ κ†⟨q⟩ = κ†⟨p⟩ = κ†⟨p⟩
1	1	1	1	1	1	1	1

that is, κ†⟨p⟩ ≤ κ†⟨q⟩. That ⟨p⟩ ≤ ⟨q⟩ follows by Lemma 4.9, as we thus have
		1		 1
⟨p⟩ = ⟨p⟩Λ ⟨q⟩≤ ⟨q⟩.	2
Proof. [Proof of Lemma 4.4] To prove (i), it suffices to show that their partial inverses are equal, since partial inverses are unique. We show this as follows:
=	=	=	=

=
=
=	=




=

follows by

=




follows by analogous argument to (ii).	2



Proof. [Proof of Lemma 4.5] Commutativity of conjunction follows by

=	=	=	=


=	=	=	=

and commutativity of disjunction analogously.	Associativity of conjunction is demonstrated by


		

and associativity of disjunction can be shown similarly. For distributivity of con- junction over disjunction,
p V r	p V r















and the dual distributive law follows symmetrically. Finally, the double negation law then follows simply by
=
which concludes the proof.	2
