	Electronic Notes in Theoretical Computer Science 197 (2008) 121–129	
www.elsevier.com/locate/entcs

Analyzing Security Scenarios Using Defence Trees and Answer Set Programming
Stefano Bistarellia,b,1	Pamela Perettia,2	Irina Trubitsynac,3
a Dipartimento di Scienze, Universita` degli Studi “G. D’Annunzio”, Pescara, Italy
b Istituto di Informatica e Telematica, CNR Pisa, Italy
c DEIS, Universit`a della Calabria, Rende, Italy

Abstract
Defence trees are used to represent attack and defence strategies in security scenarios; the aim in such scenarios is to select the best set of countermeasures that are able to stop all the vulnerabilities.
In order to represent preferences among possible countermeasures of a given attack, defence trees are enriched with conditional preferences, obtaining a new structure called CP-defence tree. In this paper we transform a CP-defence tree with preferences among attacks and countermeasures in an Answer Set Optimization (ASO) program. The ASO program, representing the overall scenario, is a special composition of the programs associated to each branch of a CP-defence tree. We describe an implementation that select the best set of countermeasure able to mitigate all the vulnerabilities by computing the optimal answer set of the corresponding ASO program.
Keywords: Defence tree, Answer Set Programming, CR-Prolog.


Introduction
Security has become today a fundamental part of the enterprise investment. In fact, more and more cases are reported showing the importance of assuring an adequate level of protection to the enterprise’s assets. Defence trees, DT [2], an extension of attack tree [9], have been introduced as a methodology for the analysis of attack/defence security scenarios. A DT is an and-or tree, where leaves node represent the vulnerabilities and the set of countermeasures available for their mit- igation, and nodes represent attacks composed by a set of actions that have to be performed as a whole to damage the system, or nodes represent attacks composed by a set of alternative actions that lead to damage the system.

1 Email: bista@sci.unich.it
2 Email: peretti@sci.unich.it
3 Email: irina@deis.unical.it

1571-0661© 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2007.12.021

The preference among countermeasures and the dependency between attacks and countermeasures are modelled by an answer set optimization (ASO) [5] program. The and and or composition of the branch is then obtained by a syntactic com- position of the ASO programs, whose semantics completely respects the intended meaning given in [3]. The semantics of the obtained ASO program provides a set of ordered answer sets representing the ordered sets of countermeasure to be adopted. In order to deal with ordered attacks (from the more to the less dangerous), the model is extended by introducing a corresponding rank (meta-preferences) among the preference rules of an ASO program. The use of ranked ASO programs avoids the problem of cycle; in fact, the introduction of meta-preferences gives precedence to the adoption of countermeasures covering the more dangerous of the attacks (and removing in this way the possibility to obtain a cycle).
This paper extends a short version [4], providing an algorithm transforming the CP-defence tree in a corresponding ASO program and describing its implementation.

Answer Set Optimization
An answer set optimization program (ASO) is a pair ⟨P, Φ⟩, where P is an answer set program [7], while Φ consists of a finite set of preference rules of the form Q : C1 > ··· > Ck ← body, where body is a conjunction of literals, i.e. atoms or negation of atoms, and Cis are (combinations) of literals. A preference rule Q ∈ Φ introduces a preference order between C1, ..., Ck: Ci is preferred to Cj, for i < j and i, j ∈ [1..k]. Intuitively, the answer sets of P are the (inclusion) minimal sets of atoms satisfying rules in P and describe the possible solutions of the program, while Φ determines a preference ordering on them.
Let Φ = {Q1, ..., Qn} be a preference program and S be an answer set, then S
induces a satisfaction vector VS = (vS(Q1), ..., vS (Qn)) where:
vS(Qj)= I, if Qj is Irrelevant to S, i.e. (a) the body of Qj is not satisfied in S
or (b) the body of Qj is satisfied, but none of the Cis is satisfied in S.
vS(Qj) = min{i : S |= Ci}, otherwise. The satisfaction vectors are used to compare the answer sets.
Let S1 and S2 be two answer sets, then (i) S1 ≥ S2 if VS1 ≤ VS2 , i.e. if vS1 (Qi) ≤ vS2 (Qi) for every i ∈ [1..n]; (ii) S1 > S2 if VS1 < VS2 , i.e. if VS1 ≤ VS2 and for some i ∈ [1..n] vS1 (Qi) < vS2 (Qi).
A set of literals S is an optimal answer set of an ASO program ⟨P, Φ⟩ if S is an answer set of P and there is no answer set S' of P such then S' > S.
The ASO strategy is further extended by introducing meta-preferences among preference rules: a ranked ASO program is a sequence ⟨P, Φ1, ..., Φn⟩ consisting of a logic program P and a sequence of pairwise disjoint preference programs Φi. The rank of a rule r ∈ Φ1 ∪ ··· ∪ Φn, denoted rank(r), is the unique integer i for which r ∈ Φi. Intuitively, the rank of the preference rule determines its importance: preference rules with lower rank are preferred over preference rules with higher rank. The optimal answer sets can be obtained in the following way: firstly, all answer







C1


C2


C3

C12



C13



Fig. 1. An example of defence tree.
sets optimal w.r.t. Φ1 have to be selected; then, have to be selected the ones optimal
w.r.t. Φ2; and so on. More formally, S1 ≥rank S2 if for every preference rule r' such that vS1 (r') ≤ vS2 (r') does not hold, there is a rule r'' such that rank(r'') < rank(r') and vS1 (r'') < vS2 (r'').

CP-defence trees
Defence trees [2] are used to represent attack strategies that can be used as mitiga- tion factor. The root of the tree is associated with an asset of the IT system under consideration and represents the attacker’s goal. Leaf nodes represent simple sub- goals which lead the attacker to (partially) damage the asset by exploiting a single vulnerability. Non-leaf nodes (including the tree root) can be of two different types: or-nodes and and-nodes. Subgoals associated with or-nodes are completed as soon as any of its child nodes is achieved, while and-nodes represent subgoals which re- quire all of its child nodes to be completed (in the following we draw an horizontal line between the arcs connecting an and-node to its children to distinguish it from an or-node). Every leaf node has a set of countermeasures. Each countermeasure associated with a leaf node represents a possible way of mitigating risk in an attack scenario where that specific vulnerability is used.
Notice that in order to mitigate the risks deriving from an or-attack, the system administrator has to introduce into the system a countermeasure for each possible action of the branch. To mitigate the risks associated with an and-attack, instead, it is enough to introduce a countermeasure for one of the attack actions in the and-attack to stop the entire attack.
Example 3.1 An enterprise’s server is used to store information about customers. In order to steal these data an attacker can follow different attack strategies: (i) obtain the privileges on the server, by stealing a root user credentials (a1) or by corrupting a root user (a2); (ii) attack the system with a remote login, by exploiting an on-line vulnerability (a3) or by exploiting a web server vulnerability (a4); (iii) steal the server itself and go out unobserved (a5 and a6).  For each attack strategy the system administrator can use different countermeasures: (i) to reduce the risk of credentials theft he can introduce security policies like a frequent change of password



Fig. 2. A CP-defence tree.
(c1) or the use of an identification token (c3); (ii) to reduce the risk of a remote attack he can update the system periodically (c6), use an anti-virus software (c8), control the email traffic and separate the content on different servers (c7); (iii) to reduce the risk of the theft of the server itself the system administrator can protect the server’s room using a security door or a safety look (c10 and c11), install a video surveillance equipment (c12) or employ a security guard (c13).
Figure 1 shows the attack/defence scenario: rounded-box nodes denote the at- tack strategies and the different actions the attacker needs to perform, while square box denote the different countermeasures the system administrator can adopt. Δ
CP-defence tree [3,4] is an extension of DT able to represent preferences among countermeasures and actions. An example is described in Figure 2. The dotted arrows depicted into the figure describe the preference order of protecting from each attack ai ∈ A: for instance the system administrator prefers to protect the action a2 to the action a1 because action a2 id more dangerous than action a2. The solid arrows, instead, represent the preferences among the countermeasures, that protect each action: for example consider the attack action a1, in this case the countermeasure c1 is preferred to c2 that is preferred to c3 (for instance, because c1 cost less than c2 that cost less than c3). Notice that the arrows are directed from the less preferred to the more preferred outcome.

and /or composition of attacks
The protection from the and-attack consists in the protection from one of the actions composing the and-attack. Given the and-attack, composed by two attack actions u and v, where u is more dangerous than v (u > v), and given the sets of countermeasures Du and Dv, protecting from u and v respectively, and two par- tial order (Du, >u) and (Dv, >v) describing the preferences among countermeasures covering u and v respectively, the and-composition of preferences is a new partial order (Du ∪ Dv, >v∧v), where a countermeasure c is preferred to a countermeasure c' if (i) it is preferred in at least one of the partial orders (Du, >u), (Dv, >v), i.e. c >u c' or c >v c', otherwise (ii) c is the worst countermeasure in (Du, >u), while c' is the best countermeasure in (Dv, >v), i.e ∀x ∈ Du, x />u c and ∀y ∈ Dv, c' />v y. As an example consider the and-attack w, composed by two actions x and y, where y > x, presented in Figure 3(a). The order obtained by and-composition is











(a)





(b)





(c)
P : r1 : w ← .
r2 : x ∨ y ← w.
r3 : a ∨ b ∨ c ← x. r4 : a ∨ c ← y.

Φy : c > a ← y.
Φx : a > b > c ← x.

Fig. 3. An example of and attacks (with cycles) and the corresponding ASO program.

depicted in Figure 3(b). In this case a cycle is obtained. Since the countermeasure of the worst attacks have to be considered as preferred, the cycle can be broken by removing one of the preference among the countermeasure of the less dangerous attack x. More precisely, the preference relations, described in (Dy, >y) has to be considered as more important, and the relation b >x c, generating (transitively) the conflict, has to be omitted. Graphically, this correspond to removing the arc as showed in Figure 3(c). Let us now to consider how to model this by using ASO programs.
Example 3.2 Consider the and-attack depicted in Figure 3(a): the attack action x and the preference order over the corresponding countermeasures a, b, and c generate the ASO program ⟨Px, Φx⟩, where Px = {rx1 : x ← . rx2 : a∨b∨c ← x.}, Φx = {Qx1 : a > b > c ← x.}, where the rules rx1 introduces the action and the rule rx2 introduces the possible countermeasures, while Qx1 represents the preference order among them. For the attack action y, the ASO program is ⟨Py, Φy⟩, where Py = {ry1 : y ← . ry2 : a ∨ c ← y.}, Φy = {Qy1 : c > a ← y.}. In order to model the and-node presented in Figure 3, a new program ⟨P, Φy, Φx⟩ is generated combining the rules in ⟨Px, Φx⟩ and ⟨Py, Φy⟩ (see Figure 3). P introduces two new rules: r1 represents the root action w, while r2 combines the action x and y in such way that only one of them should be stopped. The others rules are a simple added without any change.
The answer sets of P are M1 = {w, x, a}, M2 = {w, x, b}, M3 = {w, x, c}, M4 =
{w, y, c} and M5 = {w, y, a}. In order to establish the optimal answer set, the ASO semantics firstly constructs the satisfaction vectors VM1 = [∞, 1] 4 , VM2 = [∞, 2], VM3 = [∞, 3], VM4 = [1, ∞] and VM5 = [2, ∞], reporting the satisfaction degree of each preference rule in the answer sets. Considering both the rules the order among the answer set is M4 > M5 > M1 > M2 > M3 5 . Concluding, the new order among the countermeasures is c > a > b.	Δ
The protection from or-attack consists in the protection from all the actions composing the or-attack. Given the or-attack X, composed by k actions u1,... , uk, the sets of countermeasures Du1 ,... , Duk protecting u1,... , uk respectively, and the orders among countermeasure (Dui , >ui ) for i = {1,... , k}, then the or-composition

4 In this application the irrelevance corresponds to the worst case.
5 Notice that both the answer set M1 and M5 contain countermeasure a. However, we collect the coun- termeasure to be applied starting from the best model, so from M4 we collect c from M5 we collect a, and from M2 we collect b.

P : r1 : w ← .	Φ1 : ę1 : c > a ← y.
r2 : x ← w.	Φ2 : ę2 : a > b > c ← x. r3 : y ← w.		ę3 : a > b ← z.
r4 : z ← w.
r5 : a ∨ b ∨ c ← x. r6 : a ∨ c ← y.
r7 : a ∨ b ← z

Fig. 4. An example of or attacks and the corresponding ASO program.
is a new order (DX , >X). The order is defined over the set DX , whose elements C1, ..., Cn are the sets of countermeasures covering all the attacks u1, ...uk, and >X is defined as follows: the set C is preferred to the set C' if there is a permutation
π such that for all i ∈ [1,... , k], ci is not worst than c'	, i.e. for k = k', ∃π s.t.

ci /≺ c'
. Notice also that when the same countermeasure is selected two times (to

cover two different attacks), we consider its presence only one time.
Example 3.3 Consider, for instance, the or-attack w presented in Figure 4. The corresponding ASO program is generated as follows: ⟨Px, Φx⟩, ⟨Py, Φy⟩ and ⟨Pz, Φz⟩ represent, respectively, the program associated to the attack action x, y and z, and the corresponding preferences over the countermeasures a, b and c.
Then they are combined in the ranked ASO program ⟨P, Φ1, Φ2⟩, where Φ1 = Φy, Φ2 = Φx ∪ Φz (see Figure 4). A new rule r1, introduced in P, represents the root of the or-attack w, while the rules r2, r3 and r4 model the or-attack, i.e. that all the three action must be stopped to stop the w. The answer sets of P are M1 = {w, x, y, z, a} and M2 = {w, x, y, z, b, c} 6 and describes the application of two alternative sets of countermeasures {a}, {b, c}, protecting from the or-attack
w. In order to establish the optimal answer set, the ASO semantics firstly construct the satisfaction vectors VM1 = [2, 1, 1] and VM2 = [1, 2, 2]. Then it compares these vectors, by considering Q1 ∈ Φ1, obtaining that VM2 < VM1 . Concluding, M2 is the optimal answer set and {b, c} is the preferred set of countermeasures.

From CP-defence trees to ASO programs
Given an IT system root and the corresponding CP-defence tree T , the selection of the preferred defence strategy can be modelled by means of the corresponding logic program with preferences. In particular, a ranked ASO program L(T ) =
⟨P, Φ1, ..., Φk⟩ can be constructed, where P describes the possible defence strategies designed in T , while Φ1, ..Φk model preferences among the attacks, highlighted in T , and establish the preference order among the attacks following the preference orderings among the countermeasures for each single attack. The application of

6 We reminded that the ASO semantics [7] only collect minimal answer sets, so among the set M1 =
{w, x, y, z, a}, M ' = {w, x, y, z, a, b}, M '' = {w, x, y, z, a, c}, M ''' = {w, x, y, z, a, b, c} only M1 is considered.
1	1	1
Moreover, among the sets M2 = {w, x, y, z, b, c}, M ' = {w, x, y, z, b} and M '' = {w, x, y, z, c} only M2 is
2	2
considered because M ' and M '' do not satisfy respectively rules r6 and r7.
2	2

the ASO semantics on L(T ) produces the best defence strategies w.r.t T , thus the optimal solutions of L(T ) can be used in order to find the best countermeasure selection.
Given a CP-defence tree with n leaf attack actions a ranked ASO program L(T )= ⟨P, Φ1, ..., Φk⟩, k ≤ n, can be defined, where P is logic program consisting in the following rules r:
root ←,  stating that the root of the tree must be protected;
Y1 ∨ ... ∨ Yn ← X, for each and-node X having n child nodes Y1,... , Yn, meaning that at least one attack from Y1,... , Yn must be protect to protect X;
Yi ← X, i = [1..n], for each or-node X having n child nodes Y1,... , Yn, stating that each attack represented by Y1,... , Yn must be protect to protect X;
C1 ∨ ... ∨ Cn ← X, for each leaf node X decorated with n countermeasures C1,... , Cn, stating that at least one countermeasure C1,... , Cn is able to pro- tect X.
Each action in the defence tree induced a preference rule in the ASO program. Moreover, if the attack actions are ordered as A1 > ··· > Ak, where each Ai is a set of actions {a1..., ahi }, a set of preference programs Φ1,... , Φk, where Φi = {Qa1 ,... , Qah }, i = [1,... , k], is constructed. For each attack action X the preference rule QX is defined as follows:
C1 > ... > Cn ← X, for each leaf node X decorated with n countermeasures C1,... , Cn, where there is a solid arrow from Ci to Ci−1, i = [2,... , n]. This preference rule states that to protect the attack X the countermeasure C1 is preferred to C2, . . . , Cn−1 is preferred to Cn.
The optimal answer set obtained by computing the semantics of the generated program will collect the best countermeasure. The following Example show the result of the above procedure when applied to the CP-defence tree of Figure 2.
Example 4.1 In this example we present an application of the ASO semantics for analyzing the attack/defence scenario of an enterprise’s server used to store in- formation about customers as we described in Example 3.1. Figure 2 shows the CP-defence tree associated to this scenario. It can be modeled by using the priori- tizing program ⟨P, Φ⟩:

where P describes the attack actions that compose the different attack strategies and the countermeasures that compose the defence strategies, while Φ establishes the preference order among them. The answer sets of P are ninety, M1 is an example of them: M1 = {root, a1,2, a3,4, a5,6, a1, a2, a3, a4, a5, c1, c4, c6, c8, c10}. Considering



<P, ©1, ...,
n©> PCM














(a)	(b)
Fig. 5. The CPdt-Solver.

the preference order among attacks, as depicted in Figure 2, we can specify the importance of preference rules: Q2 is more important than Q1 because express the preferences in the selection of countermeasures for the attack a2 that is preferred to a1, Q1 is more important than Q6 because a2 is preferred to a6 and so on. In this way we obtain the following ranked ASO program ⟨P, Φ1, Φ2, Φ3, Φ4, Φ5, Φ6⟩, where Φ1 = {Q2}, Φ2 = {Q1}, Φ3 = {Q6}, Φ4 = {Q5}, Φ5 = {Q3} and Φ6 = {Q4}, whereas
the logic program is the same. By applying the ASO semantics we obtain that M = {root, a1,2, a3,4, a5,6, a1, a2, a3, a4, a6, c1, c5, c6, c8, c13} is the optimal answer set, intuitively, M is the preferred answer set as it contains a6 which is preferred
w.r.t. a5 and the best options for each preference rule Q1 ... Q4 and Q6. Concluding,
{c1, c5, c6, c8, c13} is the preferred set of countermeasures.	Δ

Implementation
CP-defence tree can be solved by coding it in an ASO program (see Section 4) and then our ASO program solver can be used to automatically obtain the set of the best countermeasure. We use for our security scenario analysis the CPdt-Solver (see Figure 5(b)), an application-oriented version of CHOPPER[6], realizing ASO semantics over the ranked answer set optimization program, under the assumption that I ≡ ∞. The overall architecture of the CPdt-Solver prototype is reported in Figure 5(a).
The system can be used by means of a User Interface, UI, which allows to specify the ranked ASO program ⟨P, Φ1, ..., Φn⟩, describing the CP-defence tree, and to visualize the obtained set of preferred countermeasures PCM.
The Analyzer Block is constituted by two different modules: the P− solver and the Φ − parser. The Φ-parser takes in input the textual file, provided by UI, and extracts the set of preference rules identifying the rank of each rule. In the case of non ranked ASO program rank(Q) = 1 for each preference rule Q. The P-solver receives in input the program P and invokes the DLV prover [8] in order to obtain the answer sets (stable models) of the program P, SM(P).

The Evaluator Block is responsible for optimal answer set discovering, and is constituted by the V-constructor and the Examiner. The V-constructor receives in input SM(P) and the set of all preference rules, Φ, and constructs the satisfaction vector VM for each answer set M ∈ SM(P). Once the satisfaction vectors have been created, their comparison is performed by means of the Examiner module by taken into account the rank of each preference rule. As a result, the set of optimal answer sets is established and the corresponding sets of countermeasures, PCM, are individuated. Finally, the Examiner module interacts with UI, which is in charge of memorizing the obtained result in the textual file and/or visualizing it.

Conclusion
This paper discusses the use of ASO programs to represent CP-defense trees, and to reason about them. The ASO approach uses preference rules in order to express the preference relations among the combinations of atoms and introduces the preference order among these rules. The ASO semantics gives simple and an intuitive way for modelling a CP-defence tree and is expressive enough to formulate preferences over countermeasures w.r.t. attacks. Moreover, it resolves cycles owing to the conflicting partial orderings in complex CP-nets, which the earlier approach using CP-nets could not easily handle [3]. The methodology proposed is tested with a small but real example and implemented using the CPdt-Solver.
An alternative way consists in the use of CR-Prolog [1], a knowledge represen- tation language based on the answer set semantic enriched with the introduction of consistency-restoring rules (cr-rules). CR-Prolog and ASO implementation are si- milar, both can be used for our goal. We prefer the latter one because in CR-Prolog we can specify a preference order among cr-rules but not among atoms.

References
M. Balduccini and M. Gelfond. Logic programs with consistency-restoring rules. In Int. Symp. on Logical Formalization of Commonsense Reasoning, 2003.
S. Bistarelli, F. Fioravanti, and P. Peretti. Defense tree for economic evaluations of security investment. In 1st Int. Conf. on Availability, Reliability and Security (ARES’06), pages 416–423, 2006.
S. Bistarelli, F. Fioravanti, and P. Peretti. Using cp-nets as a guide for countermeasure selection. In
ACM Symposium on Applied Computing, pages 300–304, 2007.
S. Bistarelli, P. Peretti, and I. Trubitsyna. Analyzing security scenarios using defence tree and answer sets. In 13th Int. Conf. on Principles and Practice of Constraint Programming, 2007. Short paper.
G. Brewka, I. Niemela, and M. Truszczynski. Answer set optimization. In 18th Int. Joint Conf. on Artificial Intelligence, pages 867–872, 2003.
L. Caroprese, I. Trubitsyna, and E. Zumpano. Implementing prioritized reasoning in logic programming. In Proc. of the ICEIS, 2007.
M. Gelfond and V. Lifschitz. Classical negation in logic programs and disjunctive databasesg. New Generation Computing, 9:365–385, 1991.
N. Leone, G. Pfeifer, W. Faber, F. Calimeri, T. Dell’Armi, T. Eiter, G. Gottlob, G. Ianni, G. Ielpa,
K. Koch, S. Perri, and A. Polleres. The dlv system. In Eur. Conf. JELIA’02, pages 537–540, 2002.
B. Schneier. Attack trees: Modeling security threats. Dr. Dobb’s Journal, 1999.
