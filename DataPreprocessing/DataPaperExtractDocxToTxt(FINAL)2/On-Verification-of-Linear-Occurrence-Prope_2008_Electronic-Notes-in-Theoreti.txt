	Electronic Notes in Theoretical Computer Science 207 (2008) 107–120	
www.elsevier.com/locate/entcs

On Verification of Linear Occurrence Properties of Real-Time Systems
Choe Changil and Dang Van Hung
International Institute for Software Technology United Nations University
Macau, China

Abstract
Duration Calculus of Weakly Monotonic Time (WDC) is an extension of DC to allow description of discrete processes where several steps of computation can occur at the same time point. In this paper, we introduce Linear Occurrence Invariants (LOI) using WDC and give an algorithm to check real-time automata for LOI by solving integer programming problems. LOI can be used effectively to specify system requirements in some cases including when the system is considered under the true synchrony assumption. We also extend WDC probabilistically to express dependability requirements of real-time systems and develop a technique to check deterministic probabilistic real-time automata for a class of probabilistic WDC formulas.
Keywords: linear occurrence invariants, real-time automata, duration calculus of weakly monotonic time, deterministic probabilistic real-time automata. probabilistic duration calculus.


Introduction
Duration Calculus (DC) was introduced in [1] as a logic for specification of real- time systems. It is then developed further in many other works that have been summarized in the monograph published recently [8]. Linear Duration Invariants (LDI) [4] is a decidable subclass of DC formulas, and many works were devoted to the verification of the requirements of real-time systems specified as a LDI, as well as to find out effective algorithms checking various models of real-time systems for LDI [4], [10], [11], [12], [12], [13].
The original DC was intended to specify the requirements of real-time systems. The externally observable behaviors of the system are specified in DC and the internal behaviors of the system may be hidden. However, the system can pass through a number of states within zero time when the behaviors of system are considered under the true synchrony assumption. To deal with such behaviors,

1 Email: {cci,dvh}@iist.unu.edu

1571-0661 © 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.03.088

a kind of logical extension of DC, called Duration Calculus of Weakly Monotonic Time (WDC) was suggested and a novel semantics of Timed CSP assuming that the communication and computation take no time was formulated using it [7]. WDC includes new formulas which can be used effectively to describe low level behaviors of system, as well as conserving DC formulas.
In this paper, we introduce Linear Occurrence Invariants (LOI) using WDC and give an algorithm to check real-time automata for LOI by solving integer program-
ming problems. An LOI has the form cmin ≤ l ≤ cmax ⇒ Σn	ki · Σ Pi ≤ M
where   Pi is the number of occurrences of Pi in the observation time inter-
val. As an example of LOI specification, a property for the communication sys- tems ”for any observation interval, the failure rate of transmission should not be more than 10 percent of the number of transmissions” can be represented as l ≥ 0 ⇒ 90 ·  f ailure − 10 ·  success ≤ 0. It is obvious that LDI having the semantics based on the state duration can not specify this kind of properties for the system model in which several states can occur at the same time point. We believe LOI could be used in like as successfully as LDI in many cases where the systems are considered under the true synchrony assumption.
We also extend WDC to a logic named Probabilistic Duration Calculus of Weakly Monotonic Time (PWDC) to express dependability requirements of real-time sys- tems, such as ”with probability 0.7, sender transmits data frames without fail- ure in any observation interval”. The way of extension follows the recent work of Kwiatkowska et al [9] to extend CTL to a probabilistic timed CTL. In [9], au- thors proposed a variant of probabilistic timed automata that allows probabilistic choice only at discrete transitions and used the concept of adversary to resolve the nondeterminism between the passage of time and discrete transitions.
We consider deterministic probabilistic real-time automata model of real-time systems, having nondeterministic choice only for times, which is a subclass of prob- abilistic real-time automata. The extended logic PWDC consists of formulas repre- senting the constraints for the probability of the satisfaction of a WDC formula by a set of adversaries of the underlying model of a deterministic probabilistic real-time automaton for an observation interval. We then develop techniques to check deter- ministic probabilistic real-time automata for some subclass of PWDC formulas.


Linear Occurrence Invariants and Checking Real- Time Automata against Linear Occurrence Invariants
In this section, we introduce linear occurrence invariants (LOI) and describe an algorithm to check a real-time automaton for a LOI using integer programming. We use WDC [7] to define LOI. We will recall WDC when we introduce the probabilistic WDC in the next section, but for now, we consider WDC formulas as DC formulas with the extension that we allow a term to be the number of occurrences of a state variable as well, and assume that several state changes can happen at the same time.

Definition 2.1 A formula of the form
Θ =^ cmin ≤ l ≤ cmax ⇒ Σn	ki · Σ Pi ≤ M
is called a linear occurrence invariant (LOI), where cmin and cmax are nonnegative real numbers, cmax could be ∞, ki (1 ≤ i ≤ n) and M are integer numbers, and Pi (1 ≤ i ≤ n) are atomic propositions,  Pi denotes the number of occurrences of state Pi in the reference interval.
The meanings of an LOI is that if the length of the observation interval is in between cmin and cmax, the numbers of occurrences of states in the observation
interval satisfy the linear constraint Σn	ki · Σ Pi ≤ M . The difference between
LOI and LDI is that the former has time-dependent premise and time-independent consequence, but both of premise and consequence of the latter are time-dependent. LOI is not a DC formula. It isa formula of WDC which is considered in Section 4. In continuous time DC, a state duration in an observation interval is defined as the integration of times in which state occurs. LDI which is a linear constraint on the state durations can not distinguish state changes occurring at the same time point when we consider systems under the true synchrony assumption. As we explained in Section 1, LOI will be especially useful for the system models in which the system passes through a number of states within zero time.
Now we describe an algorithm based on the integer programming to check real- time automata for linear occurrence invariants. Let I = { [a, b] ∈ R×(R∪{∞}) | a ≤ b } where R is the set of nonnegative real numbers. We consider [a, b] as a closed interval on R if b ∈ R, and semi-infinite interval on R otherwise. Let AP be the set of atomic propositions. Real-time automata is a subclass of timed automata of [2], where each automaton has one clock which is reset after every transition.
Definition 2.2 A real-time automaton V is a tuple (S, T, L) consisting of
a finite set S of states,
a transition relation T ⊆ S ×I × S.
a function L : S → 2AP assigning to each state s ∈ S the set of atomic propositions which are true in s.
In [4], authors had to assume b > 0 for the time constraints of the form [0, b] for a transition, when they develop an algorithm to check real-time automata for linear duration invariants using linear programming. We don’t have this assumption for real-time automata in this section. We also consider that every state of a real-time automaton is both an initial state and an accepting state.
For a transition ρ = (s, [a, b], s'), the notations ←−ρ = s and −→ρ = s' are used. Seq = ρ1ρ2...ρm is called a sequence and TSeq = (ρ1, t1)(ρ2, t2)...(ρm, tm) is called a time-stamped sequence, in which ρi = (si, [ai, bi], s' ) and ti ∈ [ai, bi] for all
i (1 ≤ i ≤ m). If a sequence ρ1ρ2...ρm satisfies −→ρi = ←−ρ i+1 for all i (1 ≤ i < m),
it is called a behavior and denoted by Beh = ρ1ρ2...ρm.  If a time-stamped se-
quence (ρ1, t1)(ρ2, t2)...(ρm, tm) satisfies −→ρi = ←−ρ i+1 for all i (1 ≤ i < m), it is
called a time-stamped behavior and denoted by TBeh = (ρ1, t1)(ρ2, t2)...(ρm, tm).

The set of behaviors LV of a real-time automaton V is a regular language over
the alphabet T . Let LF = Σn	ki · Σ Pi. For a Seq = ρ1ρ2 ... ρm of V, we de-

i=1
Σn	Σ
Σ	Σm
,⎨ 1	←−ρ j = Pi ,⎬

fine Seq(LF )= 
i=1 ki · Seq(
Pi) where Seq (
Pi)= 
j=1
.
, 0	otherwise ,

For a time-stamped sequence TSeq = (ρ1, t1)(ρ2, t2)...(ρm, tm) of V, we define
TSeq(LF )= Seq(LF ) where Seq = ρ1ρ2 ... ρm, and TSeq(l)= Σm  ti.
Definition 2.3 (Satisfaction of Linear Occurrence Invariants) Let Θ be an LOI of
the form cmin ≤ l ≤ cmax ⇒ Σn	ki · Σ Pi ≤ M .
Θ is satisfied by a time-stamped sequence TSeq iff cmin ≤ TSeq(l) ≤ cmax
implies Seq(LF ) ≤ M . Otherwise, we say that Θ is violated by TSeq.
	Θ is satisfied by a sequence Seq, denoted by Seq |= Θ, iff it is satisfied by every time-stamped sequence obtained from Seq. Otherwise, we say that Θ is violated by Seq.
Θ is satisfied by a language L ⊆ T ∗, denoted by L |= Θ, iff Seq |= Θ for every
Seq ∈ L. Otherwise, we say that Θ is violated by L.
	Θ is satisfied by a real-time automaton V iff LV |= Θ. Otherwise, we say that Θ is violated by V.
In the rest of this section we describe an algorithm to decide LV |= Θ using integer programming. Given two languages L1 and L2 over T. L1 and L2 are equivalent with respect to Θ (or simply equivalent), denoted by L1 ≡ L2, iff L1 |= Θ ⇔ L2 |= Θ. The theorem which is similar to Lemma 2.4 below was formalized and proved in [4]. Lemma 2.4 can be proved in the same way and its proof is omitted.
Lemma 2.4 For languages L1, L2 ⊆ T ∗,
(L1L2) ≡ (L2L1).
(L1 ∪ L2)∗ ≡ (L∗L∗).
1 2
(L1(L2)∗)∗ ≡ ({ϵ}∪ (L1(L1)∗(L2)∗)) where ϵ is the empty sequence.
In the following, we identify a regular expression with the language it denotes. Like in [4], we can transform the regular language LV into an equivalent finite
union of regular languages of the form ρ1 ... ρmSeq∗ ... Seq∗, using Lemma 2.4, the
1	h
distribution law (L1 ∪ L2)L = (L1L∪ L2L) and the idempotent law (L∗)∗ = L∗. The
readers are referred to [4] or [8] for the transformation procedure. Thus, to decide
LV |= Θ, it’s enough to develop a technique to decide whether a regular language of the form ρ1 ... ρmSeq∗ ... Seq∗ satisfies Θ.
1	h
Given a time-stamped sequence TSeq = (ρ1, t1)...(ρm, tm) of V. For a LDI
D = cmin ≤ l ≤ cmax ⇒ Σn	ci · ∫ Pi ≤ M , the linear function Σn	ci · ∫ Pi
does not change its value when the new tuples of the form (ρ', 0) are concatenated to TSeq. Noticing this property, in [4] authors equivalently transformed regular

language ρ1 ... ρmSeq∗ ... Seq∗
further into another regular language L, so called

1	h
normal form, which is simpler than former and L |= D is decidable using lin-
ear programming. For a LOI Θ = cmin ≤ l ≤ cmax ⇒ Σn	ki · Σ Pi ≤ M ,

the function Σn	ki · Σ Pi changes its value generally when the new tuples of
the form (ρ', 0) are concatenated to TSeq.  Therefore, we cannot use the same
technique in [4] for our case. However, Σn	ki · Σ Pi has the same value for all
time-stamped sequences which are obtained from a sequence. Using this prop- erty, we can develop an algorithm to decide L |= Θ by solving integer program-
ming problems, where L is a regular language of the form ρ1 ... ρmSeq∗ ... Seq∗.
1	h
For a sequence Seq = ρ1 ... ρm, we define the function lSeq : T → R, where

T = {(t1,... , tm) | (ρ1, t1) ... (ρm, tm) ∈ TSeq}, as lSeq(t1,... , tm) = Σm
ti. lSeq

is a continuous function. We denote the minimal value of lSeq by lmin
and the

maximal value by lmax. The minimal value always exists, but the maximal value
may not exist in some cases. lmax < ∞ denotes that the maximal value of lSeq
exists and lmax = ∞ denotes that the maximal value of lSeq does not exist.
Theorem 2.5 The problem L |=Θ is decidable using integer programming, where
L = ρ1 ... ρmSeq∗ ... Seq∗ and Θ= cmin ≤ l ≤ cmax ⇒ Σn	ki · Σ Pi ≤ M.
Proof. Let ai = Seqi(LF ) (1 ≤ i ≤ h) and bj = ρj(LF ) (1 ≤ j ≤ m). We first prove theorem in case that cmax < ∞, lmax < ∞ for all i(1 ≤ i ≤ h) and lmax < ∞
Seqi	ρj
for all j(1 ≤ j ≤ m). Consider the following integer programming problem:
k1 ≥ 0,... , kh ≥ 0.
lmin × k1 + ... + lmin × kh + lmin + ... + lmin ≤ cmax.

Seq1
Seqh	ρ1	ρm

lmax × k1 + ... + lmax × kh + lmax + ... + lmax ≥ cmin.

Seq1
Seqh	ρ1	ρm

a1k1 + ... + ahkh + b1 + ... + bm → max.
It is obvious that L |= Θ if the maximal value of the objective function is less than or equal to M . We prove that L |= Θ if the maximal value of the objective function is greater than M . From the assumption, there exist nonnegative integers

k' ,... , k'
satisfying lmin ≤ c
, lmax ≥ c
and Seq '(LF ) > M for Seq ' =

1	h	Seq '
k'	k'
max
min
Seq '
min
min
'

min

'	min

min

ρ1 ... ρmSeq 1 ... Seq h . Here, l
' = l
× k + ...+ l
× k + l	+ ...+ l	,

1	h	Seq
Seq1	1
Seqh
h	ρ1	ρm

lmax = lmax × k' + ... + lmax × k' + lmax + ... + lmax and Seq '(LF )= a k' + ... +

Seq '
Seq1	1
Seqh	h	ρ1	ρm	1 1

a k' + b
+ ... + b
. Therefore, [ c	, c
]  [ lmin , lmax ] /= ∅ and there exists

a nonnegative real number c satisfying cmin
≤ c ≤ cmax
min Seq '
≤ c ≤ lmax . From

the continuity of the function lSeq ' there exists a time-stamped sequence T 'Seq '
satisfying T 'Seq '(l)= c. This means that for T 'Seq ', cmin ≤ T 'Seq '(l) ≤ cmax but T 'Seq '(LF ) > M . That is, L |= Θ. For the proof of the other cases, we introduce the following convention.
0 ·∞ = 0,  n ·∞ = ∞,  n + ∞ = ∞,  n ≤ ∞  for all n.
Using this convention, the general case is proved in the same way as above, but the integer programming problem for the general case in which there is an occurrence of ∞ can generate several integer programming problems with no occurrences of ∞.
For example, in case that cmax = ∞, lmin × k1 + ...+ lmin × kh + lmin + ...+ lmin ≤

Seq1
Seqh	ρ1	ρm

cmax is true for all k1 ≥ 0,... , kh ≥ 0. Thus, we can decide L |= Θ by solving the

following integer programming problem
k1 ≥ 0,... , kh ≥ 0.
lmax × k1 + ... + lmax × kh + lmax + ... + lmax ≥ cmin.

Seq1
Seqh	ρ1	ρm

a1k1 + ... + ahkh + b1 + ... + bm → max.

Deterministic Probabilistic Real-Time Automata
In this section, we consider a subclass of probabilistic real-time automata, named deterministic probabilistic real-time automata in this paper, where each automaton has nondeterministic choice only for times. The probabilistic timed structures are used as the underlying model of deterministic probabilistic real-time automata. A discrete probability distribution over a set X is a mapping p : X → [0, 1] such that the set {x | x ∈ X and p(x) > 0} is finite and  x∈X p(x)= 1. Dist(X) denotes the set of discrete probability distributions over X.
Definition 3.1 A deterministic probabilistic real-time automaton Q is a tuple (Q, prob, L) consisting of
a finite set Q of states,
a function prob : Q → I × Dist(Q) assigning to each state q ∈ Q a pair of the form ([a, b], p), where [a, b] ∈ I and p ∈ Dist(Q),
a function L : Q → 2AP assigning to each state q ∈ Q the set of atomic proposi- tions that are true in that state.
Example 3.2 The Bounded Retransmission Protocol (BRP) is an extended version of the Alternating Bit Protocol (ABP) retransmitting corrupted messages. When the sender of ABP sends a message, it sends the message repeatedly until it receives an acknowledgement indicating successful delivery. When that happens, it starts transmitting the next message. There is no constraint on the number of retrans- mission of a message. Unlike ABP, BRP allows bounded number of retransmission of a message. Fig.1 shows a deterministic probabilistic real-time automaton model for the sender of BRP, having the maximal number of retransmission 2.
The system starts in state q0 and waits for a message delivery request from environment. If a request is received, the system moves to state q1 and delivers message immediately. After delivering message, there are two probabilistic choices in state q1. The first choice is that with probability 0.9, the acknowledgement arrives from receiver between one and two time units, and the system moves to state q2. The second choice is that with probability 0.1, the system fails to receive acknowledgement and moves to state q3. In state q3, the system delivers message again and moves to the next state in the same way of q1. If a message delivery is successful, the system moves to state q0 and sends the next message. In state q4, the system delays one time unit for the proper reaction of receiver to the failure, and moves to state q0. In every transition, the system clock is reset to zero.



Fig. 1. Sender of Bounded Retransmission Protocol

Definition 3.3 A probabilistic timed structure is a tuple ł = (Q, Step, L) con- sisting of
a set Q of states,
a function Step : Q → 2R×Dist(Q) assigning to each state q ∈ Q a set Step(q) of pairs of the form (t, p), where t ∈ R and p ∈ Dist(Q),
a function L : Q → 2AP assigning to each state q ∈ Q the set of atomic proposi- tions that are true in that state.
t0,p0
A path of ł is a nonempty finite or infinite sequence of the form ω = q0 —→

t1,p1
t2,p2
t3,p3

q1 —→ q2 —→ q3 —→ ... where qi ∈ Q, (ti, pi) ∈ Step(qi), and pi(qi+1) > 0. We use
the following notations for a path ω. The first state of ω is denoted by f irst(ω), and if ω is finite then the last state of ω is denoted by last(ω). |ω| denotes the length of ω and is defined as the number of transition occurrences in ω, which is
∞ if ω is infinite. For k ≤ |ω|, ω(k) denotes the kth state of ω, and step(ω, k) denotes the label of the kth transition in ω. ω(i) denotes the ith prefix of ω and ωω' denotes the concatenation of two paths ω and ω' when last(ω) = f irst(ω'). A position of ω is a pair (i, t), where i ∈ N and t ∈ R such that t = 0 if ti = 0, otherwise 0 ≤ t < ti. Here and below, N is the set of nonnegative integer numbers. Pos(ω) denotes the set of positions of ω. The state at position (i, t) is denoted by
stateω(i, t). For a path ω, we define Ðω(i, t), the elapsed time until the position (i, t),


as Ð
(i, t)= ,⎨ Ðω(i)	t =0 

where Ð
(i) = ,⎨ 0	i =0 

is the

, Ðω
(i) + t t /= 0.
, Ðω
(i) = Σi−1 tj
i /=0 

elapsed time until the ith transition. From the definition of Ðω(i, t) it is possible that the two different positions have the same elapsed time until that positions. This occurs when a system passes through a number of states within zero time.
Pathfin denotes the set of finite paths of ł and Pathinf denotes the set of infinite paths of ł. Pathfin(q) denotes the set of finite paths starting from state q and Pathinf (q) denotes the set of infinite paths starting from state q. Adversaries of a probabilistic timed structure resolve all the nondeterministic choices of the model.
Definition 3.4 An adversary of a probabilistic timed structure ł = (Q, Step, L)

is a function A mapping every finite path ω of ł to a pair (t, p) such that A(ω) ∈
Step(last(ω)).
The set of adversaries is denoted by A. For an adversary A, we define

PathA PathA
= {ω ∈ Pathfin | A(ω(i))= step(ω, i) for 0 ≤ i < |ω|},
= {ω ∈ Pathinf | A(ω(i))= step(ω, i) for 0 ≤ i}.

Let PathA
(q) = PathA
∩ Pathfin(q) and PathA
(q) = PathA
∩ Pathinf (q).

For each state q ∈ Q, a probability measure ProbA over PathA (q) is defined in the
q	inf
following way. A sequential Markov chain MCA = (P athA , PA) is associated with
,⎨ p(q) if A(ω)= (t, p) and ω' = ω t,p q,
—→
an adversary A, where PA(ω, ω')= 
, 0	otherwise.

A
P ath
(q) be the smallest σ-algebra on PathA
(q) which for all ω' ∈ PathA
(q)

contains the sets {ω | ω ∈ PathA (q) and ω' is a prefix of ω}.	Let ProbA	:

PathA
(q) → [0, 1] be the mapping defined inductively on the length of paths

in PathA
(q) as follows. If |ω| = 0 then ProbA
(ω) = 1. If ω' = ω  t,p
q for

some ω ∈ PathA
(q), then we let ProbA
(ω')= ProbA
(ω)PA(ω, ω'). The proba-

bility measure ProbA on FA	(q) is the unique measure such that ProbA({ω | ω ∈
q	P ath	q

PathA
(q) and ω' is a prefix of ω})= ProbA (ω'). In this paper, we only consider

divergent adversaries. That is, for any infinite paths under our consideration the number of state changes occurring at finite time intervals are always finite.
Definition 3.5 Underlying model of a deterministic probabilistic real-time au- tomaton Q = (Q, prob, L) is the probabilistic timed structure łQ = (Q, Step, L) in which Step(q)= {(t, p) | t ∈ [a, b] and ([a, b], p) ∈ prob(q)}

Probabilistic Duration Calculus of Weakly Mono- tonic Time
In this section, we conservatively extend WDC to a logic that allows to specify dependability properties for real-time systems, such as the constraints for the prob- ability of satisfaction of a WDC formula by the set of adversaries of system model. We call N × R the macro -micro time plane, and each (k, t) ∈ N × R a macro -micro time point. θ is used to denote the original point of this plane, i.e., θ = (0, 0), and τ is used to range over N × R. A partial order ≤ on N × R is defined as τ1 ≤ τ2 iff k1 ≤ k2 and t1 ≤ t2 where τ1 = (k1, t1) and τ2 = (k2, t2). We define weakly monotonic time frames on N × R in the following way.
Definition 4.1 A weakly monotonic time frame WT on N × R is a subset of N × R
satisfying the following conditions:
WT is a linearly ordered subset of N × R with respect to ≤.
π1(WT )= N or π2(WT )= R where π1(WT )= {k | (k, t) ∈ WT } and π2(WT )= 

{t | (k, t) ∈ WT }.
If k ∈ π1(WT ) and k' < k, then k' ∈ π1(WT ). Similarly, if t ∈ π2(WT ) and t' < t, then t' ∈ π2(WT ).
If t1 < t2, (k1, t1) ∈ WT and (k2, t2) ∈ WT , then k1 ≤ k2.
For each infinite path ω of a probabilistic timed structure ł, the set W Tω =
{ (k, t) | (i, t') ∈ Pos(ω), k = i and t = Ðω(i, t') } is a weakly monotonic time frame. Given an infinite path ω and an atomic proposition P ∈ AP . We define a
{0, 1}-valued function Pω : W Tω → {0, 1} as
, 1 stateω(k, t')= q and P ∈ L(q) Pω(k, t)= 
, 0 otherwise,
where t' is such that t = Ðω(i, t'). We also define a function P 1 : π1(W Tω) → {0, 1} as P 1(k)= Pω(k, 0) and a partial function P 2 : π2(W Tω) → {0, 1} as
ω	ω
P 2(t)= ,⎨ Pω(k, t) { k | (k, t) ∈ W Tω} is singleton
, ⊥	otherwise.
For a macro -micro time point τ = (k', t'), let Rτ = { (k, t) | 0 ≤ k ≤ k' and 0 ≤ t ≤ t'}. We define the restriction of a weakly monotonic time frame W Tω to Rτ as WTω ] Rτ = W Tω Rτ . WTω ] Rτ is a linear order subset of W Tω and has the maximal element which is denoted by τω.
Definition 4.2 The syntax of PWDC is defined as:
Φ ::= ∀[Ψ]op λ | ∃[Ψ]op λ | ¬Φ | Φ ∧ Φ,
Ψ ::= [P |0 | [P | | F op c | ¬Ψ | Ψ ∧ Ψ | Ψ-Ψ,

F ::= η | Σn
ki · Σ Pi | l | Σn
ci · ∫ Pi,

where op ∈ {=, ≤, ≥}, λ ∈ [0, 1], ki ∈ Z and ci ∈ R. Here, c takes integer number
when F is η or Σn	ki · Σ Pi, and real number otherwise.
Φ is called a PWDC formula, Ψ is called a WDC formula, and F is called a measurement term. The reason of restriction to linear terms is for simplicity. The set of intervals over WTω is defined as Intv(W Tω)= {[τ1, τ2] ∈ W Tω × W Tω | τ1 ≤ τ2}. η, ΣP , l, P are called atomic measurement terms. The interpretation of an atomic measurement term on Intv(W Tω) is defined as Iω([τ1, τ2]) = π1(τ2)— π1(τ1),
IPω	([τ ,τ ]) = Σπ1(τ2 )	P 1(i), Iω([τ ,τ ]) = π (τ ) — π (τ ) and IRω ([τ ,τ ]) =
∫ π2(τ2 ) P 2dt. The interpretation Iω ([τ ,τ ]) of non-atomic measurement terms F on
Intv(W Tω) is defined in the standard way and omitted here. Given a probabilistic timed structure ł and a WDC formula Ψ. Let q be a state of ł and [τ1, τ2] be a weakly monotonic time interval [τ1, τ2] of ω ∈ Pathinf (q).
Definition 4.3 (Semantics of WDC Formulas)

The satisfaction relation (q, ω, [τ1, τ2]) |= Ψ is defined inductively as follows: (q, ω, [τ1, τ2]) |= [P |0 iff τ1 = τ2 and Pω(τ1)=1 
(q, ω, [τ1, τ2]) |= [P | iff τ1 < τ2 and Pω(τ ) = 1 for all τ : τ1 < τ < τ2
(q, ω, [τ1, τ2]) |= F op c iff Iω ([τ1, τ2]) op c
For an infinite path ω and a nonnegative real number t, let τt = (k, t) where k = min{ k' | (k', t) ∈ W Tω}. For a nonnegative integer k, let τk = (k, 0). We define the semantics of PWDC formulas in three different ways. Given a probabilistic timed structure ł,a state q of ł, and a PWDC formula Φ.
Definition 4.4 (Macro-micro/Macro/Micro Time Semantics of PWDC Formulas) Let τ ((t, k)) be a macro-micro (macro or micro respectively) time point. The satisfaction relation (A, q,τ (t, k)) |= Φ is defined inductively as follows:

(A, q,τ (t, k)) |= ∀[Ψ]op λ iff ProbA({ω | ω ∈ PathA
(q) and

q	inf
(q, ω, [θ, τω(t, k)]) |= Ψ}) op λ for all A ∈ A 

(A, q,τ (t, k)) |= ∃[Ψ]op λ iff ProbA({ω | ω ∈ PathA
(q) and

q	inf
(q, ω, [θ, τω(t, k)]) |= Ψ}) op λ for some A ∈ A 
Macro time semantics and Micro time semantics are natural adaptations to probabilistic domain of the ways to define semantics in the original DC and its variant logics. But, macro-micro time semantics is a combination of macro time semantics and micro time semantics. The problem (A, q, t) |= ∀[Ψ]op λ can be decided by deciding (A, q, (k', t)) |= ∀[Ψ]op λ for some k' and the problem (A, q, k) |=
∀[Ψ]op λ can be decided by deciding (A, q, (k, t')) |= ∀[Ψ]op λ for some t'. For this reason, we concentrate on the development of model checking algorithms relating to Macro-micro time semantics.

Checking Deterministic Probabilistic Real-Time Au- tomata for PWDC formulas
In this section, we consider the problem to check deterministic probabilistic real- time automata for some subclass of PWDC formulas. We give two algorithms. The first algorithm is to decide (A, q,τ ) |= ∀[Θ]op λ using linear programming, where Θ is a linear occurrence invariant, and the second algorithm is to decide
(A, q,τ ) |= ∀[ Θ]op λ for all τ by solving the system of linear equations, where Θ is a linear occurrence invariant of the form cmin ≤ l ≤ cmax ⇒ Σ P = 0.

t0
Let ω = q0 —→
t1
q1 —→
t2
q2 —→
... be a path of a deterministic probabilistic

real-time automaton.  Here, we dropped the scripts denoting probability values

from the path for simplicity. Let t = t0 + t1 + t'
where t'
< t2 and τ = (2, t).

Then for any linear occurrence invariant Θ, (q0, ω, [θ, τ ]) |= Θ if and only if (ρ0, t0)(ρ1, t1)(ρ2, t' ) |= Θ. For this reason, we consider paths as time-stamped behaviors in this section for the development of checking algorithm.

Now we describe the first algorithm. We explain the main ideas of our al- gorithm using an example and formalize it later.  Let Q = (Q, prob, L) be the
deterministic probabilistic real-time automaton given in Fig.1, q0 be the start-
ing state of Q, τ = (7, 9), and Θ =^ 0 ≤ l ⇒ Σ f ailure ≤ 0.	The problem
(A, q0,τ ) |= ∀ [ Θ] ≥ 0.9 is decided using linear programming as follows. Let T =
{ρ01, ρ12, ρ13, ρ20, ρ32, ρ34, ρ40} where ρ01 = (q0, [0, ∞), q1), ρ12 = (q1, [1, 2 ], q2),
ρ13 = (q1, [1, 2 ], q3), ρ20 = (q2, [0, 0 ], q0), ρ32 = (q3, [1, 2 ], q2), ρ34 = (q3, [1, 2 ], q4)
and ρ40 = (q4, [1, 1 ], q0). Then V = (Q, T, L) becomes a real-time automaton. We designate q0 as the starting state of V. For a sequence Seq = ρi1j1 ρi2j2 ... ρimjm of V, we define P (Seq) = p1(qj1 ) × p2(qj2 ) × ... × pm(qjm ) where pk (k = 1,... , m) satisfies prob(qik )= ([ak, bk], pk) in Q. From Fig.1, we can easily see that



LV = R∗ ∪ (R∗ · ρ01) ∪ (R∗ · ρ01ρ12) ∪ (R∗ · ρ01ρ13) ∪ (R∗ · ρ01ρ13ρ32) ∪
(R∗ · ρ01ρ13ρ34),




where R = R1 ∪ R2 ∪ R3, R1 = ρ01ρ12ρ20, R2 = ρ01ρ13ρ32ρ20 and R3 = ρ01ρ13ρ34ρ40. From LV , we can pick out sequences having length smaller than or equal to 7(= π2(τ )) and not satisfying	f ailure ≤ 0 by solving linear equations. Let us consider R∗. The linear equation 3k1 + 4k2 + 4k3 = 7 on the nonnegative integer numbers has two solutions (1, 1, 0) and (1, 0, 1), where 3 is the length of R1 and 4 is the length of R2 and R3. The solution (1, 1, 0) means that R1R2 and R2R1 are the sequences of length 7 in R∗. The solution (1, 0, 1) means that R1R3 and R3R1 are another sequences of length 7 in R∗. For the sequence R1R3, the prefix (R R )(7) do not satisfy	f ailure ≤ 0. Also for the sequence R R , the pre- fixes (R3R1)(4), (R3R1)(5), (R3R1)(6) and (R3R1)(7) do not satisfy	f ailure ≤
0.	We denote these prefixes respectively by E1 = {(R1R3)(7)} and E2 =
{(R3R1)(4), (R3R1)(5), (R3R1)(6), (R3R1)(7)}. Applying the same procedure to R∗·ρ01, R∗·ρ01ρ12, R∗·ρ01ρ13, R∗ ·ρ01ρ13ρ32, R∗·ρ01ρ13ρ34, we can pick out two more sets E3 = {(R3 ·ρ01ρ13ρ32)(4), (R3 ·ρ01ρ13ρ32)(5), (R3 ·ρ01ρ13ρ32)(6), (R3 ·ρ01ρ13ρ32)(7)} and E4 = {(R3 ·ρ01ρ13ρ34)(4), (R3 ·ρ01ρ13ρ34)(5), (R3 ·ρ01ρ13ρ34)(6), (R3 ·ρ01ρ13ρ34)(7)}
from R∗ · ρ01ρ13ρ32 and R∗ · ρ01ρ13ρ34 respectively, in which every sequence does not satisfy Σ f ailure ≤ 0.
We make tuples by taking at most one element from each Ei (i = 1, 2, 3, 4) with- out considering order. For example, the tuple Σmin = ((R1R3)(7), (R3R1)(4), (R3 · ρ01ρ13ρ32)(4), (R3 · ρ01ρ13ρ34)(4)) is a tuple consisting of first element of each Ei. The remaining procedure is to generate linear constraints over the nonnegative real numbers for each tuple and do probability calculation if it is feasible. We use an example to demonstrate the procedure. The following is the linear constraints over

the nonnegative real numbers generated from Σmin and π2(τ )= 9.

,⎪ t1
+ t2
+ t3
+ t4
+ t5
+ t6
+ t7
= 9,

01	12
⎪
20	01	13
34	40

3
⎪ 0 ≤ t   ,  1 ≤ t	≤ 2,  0 ≤ t
≤ 0, 0 ≤ t4 ,

01	12
1 ≤ t5 ≤ 2, 1 ≤ t6
20	01
≤ 2, 0 ≤ t7 ≤ 1,

⎪ t1
+ t2
+ t3
+ t4
= 9,

01	13
⎪

34	40


The first line is generated from the first sequence of Σmin by changing ρij to tk where k denotes the position of ρij, and changing concatenation operation to plus operation. The second line and third line are time constraints for the transitions occurring in the first element of Σmin, given in the definition of V. The fourth line and fifth line are generated from the second sequence of Σmin in the same way. The third sequence and fourth sequence of Σmin are equal with the second sequence of Σmin and we don’t consider it.
Using linear programming, we can decide that the linear constraints above is fea- sible. We calculate P (Σmin)= 1 — (P (ρ01ρ12ρ20ρ01ρ13ρ34ρ40)+ P (ρ01ρ13ρ34ρ40)) = 1 — ((1 × 0.9 × 1 × 1 × 0.1 × 0.1 × 1) + (1 × 0.1 × 0.1 × 1)) = 1 — (0.009 + 0.01) = 0.981.
From the definition of satisfaction for PWDC formulas, the above procedure applied to Σmin and the resulting value 0.981 mean that for some adversary A

of łQ, ProbA ({ω | ω ∈ PathA
(q0) and (q, ω, [θ, τω]) |= Θ}) = 0.981. We apply

q0	inf
the above procedure to every tuple Σ and calculate P (Σ) if the generated linear
constraints from Σ is feasible. The minimum of these values is not less than 0.9 and we can conclude (A, q0,τ ) |= ∀ [ Θ] ≥ 0.9.

Remark 5.1 In fact, we can directly conclude (A, q0,τ ) |= ∀ [ Θ] ≥ 0.9 only with value P (Σmin) = 0.981. This is because the value 0.981 which is calculated from the tuple Σmin consisting of first element of each Ei is the minimum of the values calculated from each feasible tuple, i.e., the tuple generating feasible linear con- straints. In this paper, we don’t consider technical details relating to the complexity of algorithm.
Given a deterministic probabilistic real-time automaton Q = (Q, prob, L) and a state q. We define T = { (q', [a, b], q'') | q' ∈ Q, q'' ∈ Q, prob(q')= ([a, b], p), p(q'') > 0 }. Then, (Q, T, L) becomes a real-time automaton. We designate q as starting state of (Q, T, L) and denote this real-time automaton by Qq. LQq denotes the set of behaviors of Qq and H(LQq ) denotes the star-height of LQq .
Theorem 5.2 Let us assume that H(LQq ) ≤ 1 . The problem (A, q,τ ) |= ∀[Θ]op λ
is decidable using linear programming, where Θ is a linear occurrence invariants.
The details of the proof is in [14]. Now we describe second algorithm. Given a deterministic real-time automaton Q and its state q.
Theorem 5.3 The problem (A, q,τ ) |= ∀[ Θ]op λ for all τ, where Θ= (cmin ≤ l ≤

cmax ⇒ Σ P = 0), is decidable by solving the system of linear equations.
Proof. Note that from the assumption for Θ, it simply says that the probability p
that P never occurs in a run satisfies popλ. For each adversary A of łQ we define

Path¬P (q)= {ω | ω ∈ PathA
(q) and L(ω(k)) /e P for all k},

Pr¬P (q)= {ProbA(Path¬P (q))}.
Pr¬P (q) has the same value for all adversaries because of the determinism for dis- crete transitions, and (A, q,τ ) |= 6[ Θ]op λ for all τ if and only if P r¬P (q) op λ. Note that the premise cmin ≤ l ≤ cmax of Θ and τ need not be considered in our case. Thus, it’s enough to develop a technique to calculate P r¬P (q). Let q1, q2,... , qm be the states of Q satisfying L(qi) /e P and p(qi) > 0 for all i (1 ≤ i ≤ m). Here, p is the probability distribution satisfying prob(q)= ([a, b], p). We have the following set constraint

Path
(q) = m
(q ti,p q ) · Path
(q )

relating to the states q, q1, q2,... , qm. From this set relation, we also have the following linear equation

P r¬P (q)= Σm
p(qi) · Pr¬P (qi).

Applying this procedure to all states of Q, we have the system of linear equations. Solving this system of linear equations we can obtain the value of P r¬P (q). 
Example 5.4 Let us consider the sender of BRP and a PWDC formula 6[ Θ]≥ 0.6, where Θ= (cmin ≤ l ≤ cmax ⇒  f ailure = 0). Applying the procedure given in the proof of theorem, we have the following system of linear equations.
,, P r¬failure(q0)= P r¬failure(q1),
,⎨ Pr¬failure(q1)= 0.9 · P r¬failure(q2)+ 0.1 · Pr¬failure(q3), Pr¬failure(q2)= P r¬failure(q0),
,,, Pr¬failure(q3)= 0.9 · P r¬failure(q2).
Solving this system of linear equation, we have Pr¬failure(q0) = 0. This means that the problem (A, q0,τ ) |= 6[Θ]≥ 0.6 for some τ .

Conclusion and Future Work
We have studied a subclass of WDC (Duration Calculus of Weakly Monotonic Time) called LOI (Linear Occurrence Invariants) and and presented an algorithm to check real-time automata for LOI using integer programming techniques. We have also introduced PWDC (Probabilistic Duration Calculus of Weakly Monotonic Time) to specify dependability requirements of real-time system and presented some tech- niques to check deterministic probabilistic real-time automata for PWDC formulas. Though these algorithms work only for simple class of PWDC formulas, we believe

that they can be impvoved for a large class of PWDC formulas, and this will be presented in our future work.

References
Zhou Chaochen, C.A.R. Hoare and Anders P.Ravn. A calculus of durations. Information Processing Letters, 40(5): 269-276, 1991.
R. Alur and D.L Dill. A Theory of Timed Automata. Theoretical Computer Science, pages 183-235, 1994.
P.D’Argenio, J.-P.Katoen, T.Ruys, and J.Tretmans. Modeling and verifying a bounded retransmission protocol. Proc. of COST 247 International Workshop on Applied Formal Methods in System Design,
Maribor, Slovenia, Technical Report. University of Maribor, 1996
Zhou Chaochen, Zhang Jingzhong, Yang Lu and Li Xiaoshan. Linear Duration Invariants. Research Report 11, UNU-IIST, P.O.Box 3058, Macau, 1993. Published in: Formal Techniques in Real-time and Fault-tolerant systems, LNCS 863, 1994.
Paritosh. K.Pandya, Shankara Narayanan Krishna and Kuntal Loya. On Sampling Abstraction of Continuous Time Logic with Durations. Technical Report TIFR-PKP-GM-2006/1. Tata Institute of Fundamental Research, India
Dang Van Hung and Zhang Miaomiao. On Verification of Probabilistic Timed Automata against Probabilistic Duration Properties. Proceedings of the 13th IEEE International Conference on Embedded and Real-Time Computing Systems and Applications RTCSA 2007, Daegu, Korea, August 21-24, 2007. IEEE Computer Society Press, Los Alamitos, California, pp. 165 – 172.
Paritosh. K. Pandya and Dang Van Hung. Duration Calculus of Weakly Monotonic Time. Proceedings of FTRTFT98, LNCS 1486, pp 55-64, Springer-Verlag, 1998.
Zhou Chaochen and Michael R Hansen. Duration Calculus: A Formal Approach to Real-Time Systems. Springer-Verlag, 2004.
Marta Kwiatkowska, Gethin Norman, Roberto Segala and Jeremy Sproston. Automatic verification of real-time systems with discrete probability distributions. Theoretical Computer Science, 282(1):101-150, 2002.
Y. Kesten, A. Pnueli, J Sifakis and S. Yovine. Integration Graphics: A Class of Decidable Hybrid Systems. LNCS 736, pages 179-208, Springer-Verlag, 1994.
Victor A. Braberman and Dang Van Hung. On Checking Timed Automata for Linear Duration Invariants. Technical Report 135, UNU/IIST, P.O.Box 3058, Macau, February 1998. Proceedings of the 19th Real-Time Systems Symposium RTSS’98, December 2-4, 1998, Madrid, Spain, IEEE Computer Society Press 1998, pp.264-273.
Li Xuandong and Dang Van Hung. Checking Linear Duration Invariants by Linear Programming. Research Report 70, UNU-IIST, P.O.Box 3058, Macau, 1996. Published in LNCS 1179, Springer-Verlag,
1996, 321-332.
Pham Hong Thai and Dang Van Hung. Verifying Linear Duration Constraints of Timed Automata. Technical Report 306, UNU-IIST, P.O.Box, 3058, Macau, 2004. Presented at and Published in the ICTAC’04, 2004.
Choe Changil and Dang Van Hung. On Verification of Linear Occurrence Invariants of Real-Time Systems. Technical Report 375, UNU-IIST, P.O.Box, 3058, Macau, 2007.
