

Electronic Notes in Theoretical Computer Science 272 (2011) 43–56
www.elsevier.com/locate/entcs

Abstract Interpretation of Dynamics of Biological Regulatory Networks
Lo¨ıc Paulev´e1 Morgan Magnin2 Olivier Roux3
IRCCyN, UMR CNRS 6597, E´cole Centrale de Nantes, France

Abstract
Analysing dynamics of large biological regulatory networks (BRNs) calls for innovative methods to cope with the state space explosion. Static analysis and abstract interpretation techniques seem promising approaches. In this paper, we address the Process Hitting framework, that has been shown of interest to model dynamics of BRNs with discrete values. We propose to take profit from the particular structures of Process Hitting to build efficient static analyses. We introduce a novel and original method to decide the reachability of the state of a component within a BRN modelled in Process Hitting. The decision is achieved by abstract interpretation and static analysis of Process Hittings. The scalability of our approach is illustrated by its application to the analysis of a BRN with 40 components.
Keywords: biological regulatory networks, model checking, abstract interpretation, static analysis.

Introduction
Biological regulatory networks (BRNs) are a common way to model regulations between biological components (RNA, proteins, etc.). These regulations are often represented as interaction graphs, where nodes are components of the system, and edges state the regulation between them, either positive (activation) or negative (inhibition). To each node is also assigned a numerical value representing the state (e.g. the concentration) of the component of the network, at a given time. Then, this value evolves in response to the various regulations the component is subject to. In 1973, the biologist Ren´e Thomas proposed a formalisation of BRNs where the value of components are boolean [11]. This formalisation uses an interaction graph and Ren´e Thomas’ parameters (or equivalently, boolean functions between nodes inputs) to describe dynamics of a BRN. The full formalisation of BRNs with discrete values for components can be found in [2].

1 Email: loic.pauleve@irccyn.ec-nantes.fr
2 Email: morgan.magnin@irccyn.ec-nantes.fr
3 Email: olivier.roux@irccyn.ec-nantes.fr

1571-0661 © 2011 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2011.04.004

The derivation of dynamical properties from the interaction graph of BRNs has been the motivation of various mathematical works. Twenty years ago, Ren´e Thomas conjectured that the presence of positive circuits within the interaction graph is a necessary condition to achieve systems with multi-stationnarity. The conjecture has been proven in several frameworks, notably in discrete dynamical systems [9]. By using more elaborated interaction graph analyses, the maximum number of fixed points within boolean networks has been characterised [1]. Similarly, the presence of negative circuits in interaction graphs has been proved necessary for sustained oscillations in the dynamics [8].
To produce more precise analyses of BRNs dynamics, it is then required to take into account the boolean functions specified together with the interaction graph (as in [3], for instance). The majority of current techniques use standard model- checking methods [10], that are based on state space explorations of the model. However, such methods suffer from the state space explosion, and are intractable on large regulatory networks.
The Process Hitting [7] is a recently introduced framework suitable to model BRNs with discrete values. Basically, each discrete component value is modelled as a process; at any time, one and only one process of each component (referred to as sort ) is present; this process stands for the current state of the component. A component changes of process on the hit of at most one other process. Static analyses have already been developed in the Process Hitting framework, notably for obtaining all the fixed points of dynamics of a Process Hitting [7].
We present a novel abstract interpretation method on Process Hittings to de- cide the reachability of a process, i.e. the level of a component within a BRN. This decision may be inconclusive, however. Our approach, illustrated in Fig. 1, builds an over-approximation of the reachability decision, allowing to quickly detect neg- ative cases. Then, concretions of this approximation are derived. Under specific conditions, the concretions are proved to be correct under-approximations of the reachability decision, leading to a positive decision. This reasoning prevents the explicit expression of the state space.
This original approach takes advantage of the particular structure of Process Hitting models. Its scalability is shown by its application to the decision of reacha- bility of gene expression levels within a BRN of 40 components.
This paper is structured as follows. The Process Hitting framework is formally defined in Sect. 2. The abstract interpretation of process reachability is detailed in Sect. 3. The application of the presented method to the analysis of a large BRN is done in Sect. 4. We discuss our contribution in Sect. 5.


The Process Hitting Framework
This section presents the Process Hitting framework on which the methods presented in this paper apply. More detailed definitions can be found in [7].



Figure 1. The space of Process Hittings. The polygon is the set of Process Hittings that can reach the given process from a given initial state. An over-approximation of this set (marked “ˆ“) is first built using an abstraction operation. Based on this abstraction, concretions are constructed (here, D1, D2 and D3). If a concretion satisfies the condition presented in Sect. 3.4, it lies within the polygon (here, D3, greyed).

Process Hitting Deﬁnition
The Process Hitting gathers a finite number of concurrent processes grouped into a finite set of sorts. A process belongs to one and only one sort and is noted ai where a is the sort and i the identifier of the process within the sort a. At any time, one and only one process of each sort is present, forming a state of the Process Hitting. The concurrent interactions between processes are defined by a set of actions. Actions describe the replacement of a process by another of the same sort conditioned by the presence of at most one other process in the current state of the Process Hitting. An action is denoted by ai → bj F bk where ai, bj, bk are processes of sorts a and b. It is required that bj /= bk and that if a = b, then ai = bj. An action α = ai → bj F bk is read as “ai hits bj to make it bounce to bk”, and ai, bj, bk are called respectively hitter, target and bounce of the action, and can be referred to as hitter(α), target(α), bounce(α) where hitter(ai→bj F bk)= ai, target(ai→bj F bk)= bj and bounce(ai→bj F bk)= bk.
Definition 2.1 [Process Hitting] A Process Hitting PH is a triple (Σ, L, H):
Σ= {a, b, . . . } is the finite countable set of sorts,
L = a∈Σ La is the set of states for PH, with La = {a0 ... ala } the finite and countable set of processes of sort a ∈ Σ and la a positive integer, a /= b ⇒ ai /= bj ∀(ai, bj) ∈ La × Lb,
H = {ai→ bj F bk, ··· | (a, b) ∈ Σ2, (ai, bj, bk) ∈ La × Lb × Lb, bj /= bk,a = b ⇒
ai = bj}, is the finite set of actions.
Given a state s ∈ L, the process of sort a ∈ Σ present in s is denoted by sa, that is the a-coordinate of the state s. The sort of a process ai is referred to as Σ(ai) and the set of sorts present in an action α = ai→bj F bk as Σ(ai→bj F bk)= {Σ(ai), Σ(bj)}.
An action α = ai→ bj F bk ∈ H is playable in s ∈ L if and only if sa = ai and sb = bj. In such a case, (s · α) stands for the state resulting from the play of the action α in s, that is (s · α)b = bk and ∀c ∈ Σ,c /= b, (s · α)c = sc. For the sake of clarity, ((s · α) · β) is abbreviated as (s · α · β).






1

0






0	1
Figure 2. A toy Process Hitting. Sorts are represented by labeled boxes, and processes by circles (ticks are the identifiers of the processes within the sort, for instance, a0 is the process ticked 0 in the box a). An action (for instance b1→ a0 F a1) is represented by a directed hyperedge, having the hit part (b1 to a0) in plain line and the bounce part (a0 to a1) in dotted line. The reachability of the process d2 (double circled) is studied in next sections. The current state is represented by the grey processes, i.e. ⟨a0, b1, c0, d0⟩.


Fig. 2 represents a Process Hitting (Σ, L, H) where Σ = {a, b, c, d}, L = {a0, a1}×
{b0, b1, b2}× {c0, c1}× {d0, d1, d2} and H = {a0→c0 F c1, a1→b1 F b0, c1→b0 F b1, b1→ a0 F a1, b0→ d0 F d1, b1→ d1 F d2, d1→ b0 F b2, c1→ d1 F d0, b2→ d0 F d2}. Playing the action b1→a0 F a1 in the state ⟨a0, b1, c0, d0⟩ results in the state ⟨a1, b1, c0, d0⟩.


Scenarios and Bounce Sequences
This subsection defines two specific compositions of actions: scenarios and bounce sequences. Both are sequences of actions, i.e. an ordered list of actions. Briefly, a scenario is a sequence of actions that are successively playable in some states of the Process Hitting. A bounce sequence is a sequence of actions that permits to make a process bounce to another of the same sort.

Definition 2.2 [Sequence of Actions] Given a Process Hitting (Σ, L, H), a sequence of actions is a series A = α1,..., αx, where ∀y, 1 ≤ y ≤ x, αy ∈ H. |A| denotes the length of the sequence (i.e. |A| = x). By notation, Ay = αy, 1 ≤ y ≤ |A|. An empty sequence is referred to as ε.

Ai..j is the subsequence of actions Ai,..., Aj. The set of sorts present in a
sequence A is denoted by Σ(A) =  |A| Σ(Ay). A process ai is said to be present
in the sequence A, noted ai ∈ A, if and only if there exists an action in A where ai is either the hitter or the target or the bounce. Given a sequence of actions A, prevy(A) denotes the latter process of sort a that is either a bounce or a hitter of

an action Au,u < y, formally defined below.
∅	if a ∈/ Σ(A1..y−1),
bounce(A )	if u = max{v | a ∈ Σ(A ) Λ 1 ≤ v < y}
{v | a ∈ Σ(A ) Λ 1 ≤ v < y} ΛΣ(bounce(Au)) /= a.
A scenario δ is a sequence of actions where the hitter (resp. the target) ai of the yth action is either occurring for the first time (prevy(δ)= ∅), or is the latter process of sort a occurring in preceding actions (prevy(δ)= a ).
a	i
Definition 2.3 [Scenario] A scenario δ is a sequence of actions such that for all y,

1 ≤ y ≤ |δ|, a
= hitter(δ ) (resp. target(δ )) ⇒ prevy(δ) ∈ {∅,a }.

i	y	y	a	i
A scenario δ is said to be playable in a state s ∈ L, if and only if δ1 is playable in s and for all y, 1 ≤ y < |δ|, δy+1 is playable in the state (s · δ1 · ... · δy). The state resulting from the sequential play of the scenario in s is denoted by s · δ. The definition of the reachability of a process from a given state can be formalised using scenarios:
Definition 2.4 [Process Reachability] Given a state s ∈ L, sz /= zl, s can reach the process zl if and only if there exists a scenario δ playable in s such that (s · δ)z = zl.
Bounce sequences result from a local reasoning on a single sort a. Bouncing from ai to aj may require the play of several actions on processes of sort a, that form a bounce sequence. By notation, ai and aj are called respectively the target and the bounce of the objective ai F∗ aj; the sort of the objective is Σ(ai F∗ aj)= a. The set of all objectives within any sort is denoted by &bj.
Definition 2.5 [Objective; Bounce Sequence] The reach of process aj from ai is called an objective, noted ai F∗ aj. A bounce sequence ζ is a sequence of actions such that for all y, 1 ≤ y < |ζ|, bounce(ζy)= target(ζy+1). It resolves an objective ai F∗ aj if and only if target(ζ1)= ai and bounce(ζ|ζ|)= aj.
In a bounce sequence ζ, target and bounces of all actions share the same sort Σ(ζ). In the scope of this paper, bounce sequences do not contain cycles between targets and bounces of actions. In that way, the maximum length of a bounce sequence for a sort a is the number of processes of sort a.
Definition 2.6 [¥£] ¥£(ai F∗ aj) denotes the set of all bounce sequences resolving the objective ai F∗ aj. Because bounce sequences do not admit cycles, this set is finite. Obviously, ¥£(ai F∗ ai)= {ε}; and ¥£(ai F∗ aj)= ∅ if there is no possibility to reach aj from ai.
Remark 2.7 Bounce sequences are not necessarily scenarios (e.g. bi→ai F aj, bj→ aj F ak is a bounce sequence but not a scenario if bi /= bj).

For the Process Hitting example in Fig. 2, ζ = a1 → b1 F b0, d1 → b0 F b2 is the only bounce sequence resolving the objective b1 F∗ b2 (i.e. ¥£(b1 F∗ b2) = {ζ}). δ = a0→c0 F c1, b1→a0 F a1, a1→b1 F b0, b0→d0 F d1, c1→b0 F b1 is a scenario playable in the state s = ⟨a0, b1, c0, d0⟩, and s · δ = ⟨a1, b1, c1, d1⟩.

Abstract Interpretation of Process Reachability
The Process Reachability problem consists in deciding, within a Process Hitting, if there exists a scenario playable in a given state leading to a state containing a given process (Def. 2.4). This section assumes a Process Hitting (Σ, L, H), a state s ∈ L and a process zl ∈ Lz,z ∈ Σ for which the reachability from s has to be decided.
We propose an abstract interpretation that aims at replying quickly the process reachability problem. Based on an abstraction of bounce sequences, we first build an over-approximation of the decision (responding either by the negative or inconclu- sive); then, concretions are derived from the abstraction and, if satisfying a certain property, are shown to be valid under-approximations of the decision, allowing then to potentially give a positive answer.

Abstraction of Bounce Sequences
A bounce sequence ζ resolving an objective P is abstracted into the set of hitters of its actions having a different sort than that of P . This abstraction is noted ζˆ and is given by (1). The abstraction ¥£ˆ(P ), P being an objective, is then the set of its abstracted sequences (2). For the sake of efficiency, only minimal abstracted sequences are kept.
ζˆ= {hitter(ζy) | 1 ≤ y ≤ |ζ|, Σ(hitter(ζy)) /= Σ(P )} ,	(1)
¥£ˆ(P )= {ζˆ | ζ ∈ ¥£(P ), ∄ζj ∈ ¥£(P ),ζjˆ Ç ζˆ} .	(2)
It is worth noticing that ¥£ˆ(P ) can be computed directly (without computing
¥£(P )), providing still a computation exponential in the number of processes in the sort of P , but yet more efficient because only minimal sets are kept.

Over-Approximation of Process Reachability
The proposed over-approximation defines the satisfiability of a bounce sequence ζ as the (independent) reachability from the initial state s of the involved hitters (i.e. processes in ζˆ). The set of objectives from the initial state to each of these hitters is denoted by objs(ζˆ):
objs(ζˆ) = {sa F∗ aj | aj ∈ ζˆ} .	(3)
Hence, objs(ζˆ) is said to be satisﬁable if for each of its objectives P ∈ objs(ζˆ), the abstraction of bounce sequences ¥£ˆ(P ) is satisfiable. In a natural way, ¥£ˆ(P ) is said to be satisﬁable if and only if there exists an abstracted bounce sequence


d1 F∗ d1






c0 F∗ c1	a1 F∗ a0
Figure 3. Graph of relations between BSˆ(P ) and objs(ζˆ) sets that are connected to BSˆ(d1 F∗ d2) for the Process Hitting example of Fig. 2 in the state ⟨a1, b0, c0, d1⟩. Boxed nodes represents the abstracted sequences ζˆ resolving the parent objective. In this case, BSˆ(d1 F∗ d2) ≡ ⊥ so d2 is not reachable from
⟨a1, b0, c0, d1⟩.
ζˆ ∈ ¥£ˆ(P ) such that objs(ζˆ) is satisfiable. The non-satisfiability of ¥£ˆ(P ) is noted ¥£ˆ(P ) ≡⊥ and is formally defined by the equations below.
¥£ˆ(P ) ≡⊥ ⇐⇒ ∀ζˆ ∈ ¥£ˆ(P ), objs(ζˆ) ≡⊥	(4)
objs(ζˆ) ≡⊥ ⇐⇒ ∃P ∈ objs(ζˆ), ¥£ˆ(P ) ≡⊥	(5)
It is an over-approximation since it requires the reachability of an unordered set of hitters which is necessary but not sufficient to resolve the objective.
Lemma 3.1 ¥£ˆ(sz F∗ zl) ≡⊥ =⇒ zl is not reachable from s.
Proof ∃ scenario δ, (s · δ)z = zl ⇒ ¥£ˆ(sz F∗ zl) /≡ ⊥, by induction on δ (see Appendix A.1). 
Testing if ¥£ˆ(sz F∗ zl) ≡ ⊥ is done by simply traversing the graph of relations between ¥£ˆ(P ) and objs(ζˆ) sets that are connected to ¥£ˆ(sz F∗ zl).
Fig. 3 illustrates this lemma on the Process Hitting example of Fig. 2.
Concretions of Abstraction of Bounce Sequences
This subsection presents a concretion D of the abstraction ¥£ˆ previously defined. The concretion D is a partial order relation between objectives, and its construction may lead to several solutions. Once the satisfiability of D is defined, the question of the link between this satifiability and process reachability is tackled in the next subsection.
The concretion D of ¥£ˆ. The concretion is first done by fixing for each objective P one bounce sequence ζ to execute, i.e. by reducing every ¥£ˆ to one element. Finally, each objective Q ∈ objs(ζˆ) is put in relation with P in D ⊂ &bj × &bj. It is worth noticing that relation cycles can be prohibited, as it is discussed in the satisfaction of D. In that way, D has the structure of a partial order between objectives, with sz F∗ zl as minimal element. The set of objectives that are in relation by transitivity with the objective P is noted C(P ). The following steps illustrate the concretion of ¥£ˆ into D:
for each ¥£ˆ(P ) /= ∅, choose ζˆ ∈ ¥£ˆ(P ), and add (P, Q) to D for each
Q ∈ objs(ζˆ);
remove from D any (P, Q) such that P ∈/ C(sz F∗ zl);


P

	
ak F∗ ai	ak F∗ aj


P

ai F∗ aj

ak F∗ al


ai F∗ aj


	

ak F∗ ai
ak F∗ aj
ak F∗ al


Figure 4. Sketch of the saturation procedure. There is an edge from P to Q if P depends on Q. (left) Concurrent objectives: objectives ensuring a cycle between bounces are added as dependencies. (right) Target redirection: objective from the bounce of the dependence to the bounce of the root is added as a dependency.
ignore solution if there exists a relation cycle.
Computing a concretion Ð is linear in the number of objectives connected to sz F∗ zl. The number of possible concretions is finite and is exponential in the cardinalities of ¥£ˆ sets. If (P, Q) ∈ Ð, P is said to depend on Q (and Q is a dependency of P ).
Ð satisfiability. The concretion Ð of an objective P is said to be satisfiable if and only if, either the empty bounce sequence resolves P (¥£ˆ(P )= {ε}), i.e. P does not depend on any other objective; or each objective Q that is a dependence of P is satisfiable. This is denoted Ð(P ) /≡ ⊥:
Ð(P ) /≡⊥ ⇐⇒ ¥£ˆ(P )= {ε} or 6Q, (P, Q) ∈ Ð, Ð(Q) /≡⊥ .	(6) Hence, it is obvious that if Ð contains a cycle, Ð(sz F∗ zl) ≡ ⊥.
Under-Approximation of Process Reachability
If two different objectives having a same sort are in relation with sz F∗ zl in Ð, resolving one of both may result in a state in which the resolution of the other may be impossible. This is basically an issue of objective resolutions interleaving. This subsection proposes a construction of a relation Ð upon Ð that is satisfiable when the order of objective resolutions does not influence the process reachability.
The main principle, illustrated in Fig. 4, is to saturate the relation Ð in order to ensure that every possible scheduling of objective resolution is satisfiable. For instance, if ak F∗ ai and ak F∗ aj have to be concurrently resolved, the saturation procedure requires that both ai F∗ aj and aj F∗ ai are satisfiable, i.e. there is a cycle between the presence of ai and aj. Besides, if resolving ai F∗ aj implies the prior resolution of ak F∗ al, the saturation procedure requires al F∗ aj to be satisfiable too. First, let us denote by TOPa(P ) the first objectives in Ð of sort a in relation with
P . It is defined by the following equation where Succ(P )= {Q ∈ &bj | (P, Q) ∈ Ð}:

TOP (P )=  {P}	if Σ(P )= a;

(7)

a
Q∈Succ(P )
TOPa(Q)	otherwise.

properties are verified by Ð˜(P ):

For all sorts a, 6Q, R ∈ Succ(P ) where Q and R have a different sort than P and TOPa(Q) and TOPa(R) are not empty, then, there exist ai F∗ aj, aj∗ F∗ ai∗ ∈ Succ(P ) where ai and ai∗ (resp. aj and aj∗ ) are bounces in TOPa(Q) (resp. TOPa(R)).
If a is the sort of P , 6Q ∈ Succ(P ), Σ(Q) /= a, if there is at least one ak F∗ al ∈
TOPa(Q), then al F∗ bounce(P ) ∈ Succ(P ).
The saturation procedure works by recursive saturation of dependencies of sz F∗ zl, by using the rules sketched in Fig. 4 to satisfy the properties established above. As the maximum number of objectives is the sum of the square of the number of processes for each sort, the complexity of the saturation procedure is polynomial with the number of processes.
Lemma 3.2 Ð˜(sz F∗ zl) /≡⊥ =⇒ zl is reachable from s.
Proof By induction on the partial order Ð (see Appendix A.2). 
Testing the satisfiability of a concretion is done linearly with the number of objectives in relation in the concretion (6). In this way, performing the analysis by applying the Lemma 3.2 is very efficient.
The saturation procedure fails as soon as a needed objective Q has no solving bounce sequences (¥£(Q) = ∅). This failure uncovers a partial order constraint upon the occurrence of processes: if ¥£(ai F∗ aj) = ∅, the process aj is always present before ai. A future work may make use of this knowledge to refine the static decision.
To illustrate this scheduling analysis, let us consider the reachability of the process d2 in the Process Hitting in Fig. 2. Considering first ⟨a1, b1, c1, d0⟩ as initial state, a satisfiable saturated concretion is obtained, as shown in Fig. 5(left), so d2 is reachable from this state. However, when considering the initial state ⟨a0, b1, c1, d0⟩, the saturation of concretions is not satisfiable because of the empty ¥£(a1 F∗ a0) (Fig. 5(right)), uncovering a partial order (a0 can not be reached after a1).
Application to a Large BRN
From BRNs to Process Hittings. We first sketch how to model a discrete BRN in the Process Hitting framework. Basically, to each component corresponds a sort, and to each state of components corresponds a process. If a component a at state i activates a component b at state j, an action ai → bj F bk is added, where bk is the state of b after activation. The inhibition is modelled similarly. The realisation of boolean functions between nodes are modelled using a dedicated sort, and is illustrated in Fig. 6. The full formalisation of this translation can be found in [7].
T-Cell Receptor Signalling Pathway. Introduced in [4], this biological system models the T-Cell Receptor (TCR) signalling pathway, the behaviours of which


d0 F∗ d2	d0 F∗ d2
	

b1 F∗ b1
b1 F∗ b0
F∗ b0
 a1 F∗ a0
⊥



a1 F∗ a1
 c1 F∗ c1
F∗ a1
 c0 F∗ c1



b1 F∗ b1
 a0 F∗ a0
Figure 5. Saturated concretions obtained when testing the reachability of d2 in the Process Hitting in Fig. 2. Nodes added by the saturation procedure are greyed. (left) Concretion computed from ⟨a1, b1, c1, d0⟩ that is satisfiable (appearing as D3 in Fig. 1). (right) Concretion computed from ⟨a0, b1, c0, d0⟩ that is not satisfiable (appearing as D1 or D2 in Fig. 1).



1	1

0	0
(1)

(2)


c = ¬a ∧ b






Figure 6. Examples of Process Hittings (right) from BRNs, having interaction graphs at left. (1) simple inhibition of c by a. (2) boolean function between a (inhibitor) and b (activator) on c ab reflects the state of sorts a and b. In this case, ab3 reflects the state ⟨a0, b1⟩ (and, ab0 the state ⟨a1, b0⟩, ab1 the state ⟨a1, b1⟩, ab2 the state ⟨a0, b0⟩).
reveal an activation of transcription factors controlling the cell’s fate, e.g. whether it proliferates or not. The interaction graph (reproduced in Appendix B.1), together with logical rules can be found in [6], which studies the feedbacks circuits and stable states of this network.
The Process Hitting model 4 of this system is composed of 416 actions between 176 processes split in 53 sorts (the largest sort has 32 processes). The total number

4 Model	and	implementation	available	at	http://www.irccyn.ec-nantes.fr/~pauleve/ sasb10-ProcessHitting.tar.bz2

of states of this model is 273 (≈ 1022).
Reachability decisions have been experimented from all possible inputs combi- nations (components CD45, CD8, TCRlig) to each output (components CRE, AP1, NFkB, NFAT). All result in conclusive decisions. The response times are around the second on a 3GHz processor with 2GB of RAM. To give a comparison, we did the same experiments with a model-checking method using state-space compression: the libddd framework [5], known for its good performances. For many reachability decisions, the program run out of memory, for others, response times range from some seconds to hours. This shows the remarkable efficiency of our method, based on abstract interpretation.
Discussion
The Process Hitting is a recently proposed framework suitable for modelling dynam- ics of BRNs with discrete values. In Process Hitting, components are represented as sorts, and their levels as processes; at any time, one and only one process of each sort is present. The successive states of a component within the system are enclosed in a so-called sort. The replacement of a process by another of the same sort (i.e. level change of a component), is conditioned by the presence of at most one other process, of any sort.
Thanks to the particular structure of Process Hittings models, a powerful static analysis and abstract interpretation method has been developed to decide the reach- ability of a process, hence of a component level in the scope of BRNs modelling. The computation is done by over- and under-approximation of the decision, and may re- veal to be inconclusive. Further improvements of our procedure are currently being done to limit the number of inconclusive cases (Sect. 3.4).
This new and original approach has been applied to the analysis of a large BRN (40 components). Response times are really fast (around the second on a desktop computer), showing the scalability of our method. Application to ever much larger networks (100 components) are expected shortly.
Our next research direction is the incorporation of quantitative aspects within the presented decision of process reachability, such as the probability of reaching a given process in a given time interval.

References
Aracena, J., Maximum number of fixed points in regulatory boolean networks, Bulletin of Mathematical Biology 70 (2008), pp. 1398–1409.
Bernot, G., F. Cassez, J.-P. Comet, F. Delaplace, C. Mu¨ller and O. Roux, Semantics of biological regulatory networks, Electronic Notes in Theoretical Computer Science 180 (2007), pp. 3 – 14.
Bernot, G., J.-P. Comet and Z. Khalis, Gene regulatory networks with multiplexes, in: European Simulation and Modelling Conference Proceedings, 2008, pp. 423–432.
Klamt, S., J. Saez-Rodriguez, J. Lindquist, L. Simeoni and E. Gilles, A methodology for the structural and functional analysis of signaling and regulatory networks, BMC Bioinformatics 7 (2006), p. 56.
LIP6/Move, the libDDD environment (2007), http://ddd.lip6.fr.


Naldi, A., D. Thieffry and C. Chaouiya, “Computational Methods in Systems Biology,” 2007 pp. 233– 247.
Paulev´e, L., M. Magnin and O. Roux, Refining Dynamics of Gene Regulatory Networks in a Stochastic π-Calculus Framework, Transactions in Computational Systems Biology To appear (2010), preprint: http://www.irccyn.ec-nantes.fr/~pauleve/refining-revised.pdf.
Remy, E´., P. Ruet and D. Thieffry, Graphic requirements for multistability and attractive cycles in a boolean dynamical framework, Advances in Applied Mathematics 41 (2008), pp. 335 – 350.
Richard, A. and J.-P. Comet, Necessary conditions for multistationarity in discrete dynamical systems, Discrete Applied Mathematics 155 (2007), pp. 2403 – 2413.
Richard, A., J.-P. Comet and G. Bernot, “Modern Formal Methods and Applications,” 2006 pp. 83–122.
Thomas, R., Boolean formalization of genetic control circuits, Journal of Theoretical Biology 42 (1973),
pp. 563 – 585.

Proofs
Proofs assume zl as the process to which the reachability from an initial state s has to be decided.

Lemma 3.1
Let us assume that zl is reachable from s using the scenario δ.
If |δ| =0 then sz = zl and ε ∈ &bj(sz F∗ zl), therefore ¥£ˆ(sz F∗ zl) /≡ ⊥.
If |δ| > 0 then there exists a bounce sequence ζ resolving sz F∗ zl such that to each i, 1 ≤ i ≤ |ζ| corresponds a xi, 1 ≤ xi ≤ |δ| where ζi = δxi and xi < xj, 6i < j. Moreover, 6i, 1 ≤ i ≤ |ζ|, hitter(ζi) is reachable from s using the scenario δj = δ1,..., δx —1 (induction with sz = hitter(ζi) and δ = δj, where |δj| < |δ|). 

Lemma 3.2
Let EXECUTE be the following recursive function building a scenario to reach the bounce of an objective ai F∗ aj from a given state s:
function EXECUTE(s, ai F∗ aj)
ζ → bounce sequence matching the selected ζˆ ∈ ¥£ˆ(ai F∗ aj)
for x → 1 to |ζ| do
b → Σ(hitter(ζx))
if sb /= hitter(ζx) then
s → EXECUTE(s, sb F∗ hitter(ζx))
if sa /= target(ζx) then	/sa has changed /
return EXECUTE(s, sa F∗ aj)
end if end if
sa → bounce(ζx)	/play of action ζx/
end for return s
end function

By construction of Ð(sz F∗ zl), every objectives of recursive calls to EXECUTE are in relation with sz F∗ zl in Ð(sz F∗ zl). As Ð(sz F∗ zl) is a partial order, no looping recursive calls are possible, so the function always terminates. Moreover, if Ð(sz F∗ zl) /≡ ⊥, ζ is always defined. Therefore, by induction on the partial order Ð(sz F∗ zl), it is then proved that EXECUTE(s, sz F∗ zl) returns a state where zl is present. 



Figure B.1. Interaction graph for the TCR signalisation pathway [6].
