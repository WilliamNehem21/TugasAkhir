Electronic Notes in Theoretical Computer Science 125 (2005) 137–148 
www.elsevier.com/locate/entcs


G¨odel-Dummett Counter-models through Matrix Computation
Dominique Larchey-Wendling1
LORIA – CNRS
Vandœuvre-l`es-Nancy, France

Abstract
We present a new method for deciding G¨odel-Dummett logic. Starting from a formula, it proceeds in three steps. First build a conditional graph based on the decomposition tree of the formula. Then try to remove some cycles in this graph by instantiating these boolean conditions. In case this is possible, extract a counter-model from such an instance graph. Otherwise the initial formula is provable. We emphasize on cycle removal through matrix computation, boolean constraint solving and counter-model extraction.
Keywords: Counter-models, conditional graphs and matrices.


Introduction
G¨odel-Dummett logic LC is the intermediate logic (between classical logic and intuitionistic logic) characterized by linear Kripke models. It was introduced by G¨odel in [10] and later axiomatized by Dummett in [6]. It is now one of the most studied intermediate logics for several reasons: among those, it is one of the simplest “many-valued” logics, whose semantics is captured by truth functions over the unit interval. It is one of the candidates (under the name “Go¨del” logic) for use as a fuzzy logic [11]. With respect to decision procedures for intermediate logics, it witnesses some advantages of sequent calculi over hyper-sequent systems.

1 Email: larchey@loria.fr



1571-0661 © 2005 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2004.07.022


Proof-search in LC has benefited from the development of proof-search in intuitionistic logic IL with two important seeds: the contraction-free calculus of Dyckhoff [1,7,8] and the hyper-sequent calculus of Avron [2,14]. Two of the most recent contributions propose a similar approach based on a set of local and strongly invertible proof rules (for either sequent [12] or hyper-sequent [2] calculus,) and a semantic criterion to decide irreducible (hyper)-sequents and eventually build a counter-model.
We have recently proposed a combination of proof-search in sequent cal- culus and counter-model construction to provide a decision procedure for LC which is based on a new principle: we are able to gather all the useful in- formation arising from all the proof-search branches into a semantic graph and then we use an efficient counter-model search algorithm based on cycle detection. We have reduced the decision problem in LC to a combination of boolean constraint solving and cycle detection. These results are presented in [13], and the present paper comes as a complement to it. We will briefly recall the theoretical results, but we want to focus mainly on the description of the decision procedure with an emphasis on the counter-model generation algorithm.
Given a formula D of LC, the procedure proceeds in three steps at the end of which one obtains a counter-model (in case D is not provable. 2 ) The first step which is described in full details in section 3 consists in building a particular bi-colored graph GD based on the decomposition tree of D. The arrows of this graph may be indexed with boolean conditions. The second step consists in searching for an instantiation of the boolean conditions on arrows so that the instance graph has no remaining r-cycle. 3 This step is first described informally in section 3.3; then we provide a decision algorithm for this problem based on conditional matrix computation in section 4. For the third step, described in section 5, given a particular instance Gv with no r- cycle, we can extract a counter-model of D from this instance Gv by computing a bi-height for it.

The syntax and semantics of G¨odel-Dummett logic
The set of propositional formulae, denoted Form is defined inductively, starting from a set of propositional variables denoted by Var and using the connectives
∧, ∨ and ⊃. 4 IL will denote the set of formulae that are provable in any in-

2 As a decision procedure, it can also certify the validity of D in case it has a proof.
3 A kind of cycle described later in section 6.
4 We do not integrate the bottom ⊥ constant. A specific treatment for ⊥ is detailed in [12].
It can be easily integrated in the procedure described here.


tuitionistic propositional calculus (see [7]) and CL will denote the classically valid formulae. As usual an intermediate propositional logic [1] is a set of formulae L satisfying IL ⊆ L ⊆ CL and closed under the rule of modus po- nens and under arbitrary substitution. LC is the smallest intermediate logic satisfying the axiom (X ⊃ Y ) ∨ (Y ⊃ X).
On the semantic side, LC is characterized by linear Kripke models. In this paper, we will use the algebraic semantics characterization of LC [2] rather than Kripke semantics. The algebraic model is the set of natural numbers with its natural order ≤, augmented with a greatest element ∞. An inter- pretation of propositional variables [·]] : Var → N is inductively extended to formulae: the conjunction ∧ is interpreted by the minimum function denoted
∧, the disjunction ∨ by the maximum function ∨ and the implication ⊃ by the operator d defined by a d b = if a ≤ b then ∞ else b. A formula D is valid for the interpretation [· ] if the equality [D]] = ∞ holds. This interpretation is complete for LC. A counter-model of a formula D is an interpretation [·]] such that [D]] < ∞.

A decision procedure for LC
In [13], we have described a procedure to decide the formulae of LC and to build a counter-model when a formula is not valid. The first step of this procedure is to build a graph with two kinds of arrows. Then the decision problem is reduced to the detection of particular cycles in this graph.

Conditional bi-colored graph construction
We introduce the exact notion of graph we use and then show how to build such a graph given a formula of LC.
Definition 3.1 A bi-colored graph is a (finite) directed graph with two kinds of arrows: green arrows denoted by → and red arrows denoted by ⇒.
Definition 3.2 A conditional bi-colored graph is a bi-colored graph where arrows may be indexed with (propositional) boolean expressions.
We point out that we consider these boolean expressions up to classical equivalence, i.e. we consider them as representatives for boolean functions over atomic propositional variables. These variables can be instantiated by
{0, 1} with a valuation v and a boolean expression e gets a value ev ∈ {0, 1} computed in the obvious way. We thus obtain an instance graph: an arrow indexed with a boolean expression e belongs to this instance if and only if ev = 1. The case of an unconditional (i.e. not indexed) arrow can be treated



∧−
x  x
A−	B−
∧+

 
A+	B+
V
∨−

 
A−	B−
∨+
x  x
A+	B+
♦


A+
⊃+



Fig. 1. Counter-model search system for LC
by considering that it has an implicit boolean conditional which is a tautology (and then always values 1) and non-existing arrows have an implicit boolean condition that always values 0.
Definition 3.3 Given a conditional bi-colored graph G and a valuation v of boolean variables in {0, 1}, we define the instance graph Gv as the bi-colored graph that one obtains when one evaluates boolean expressions indexing ar- rows and keeping exactly those whose valuation equals 1.
Given a LC formula D, we build a conditional bi-colored graph GD by the following process. First, the nodes of GD are obtained by considering the set of nodes of the decomposition tree of D, or equivalently, the set of occurrences of subformulae.
If F is an occurrence of a subformula of D, we denote by XF the correspond- ing node. Nodes are signed starting from − at the root D− and propagating signs as usual. 5 We may write X + or X− to emphasize the sign.
F	F
To this set of nodes, we add a node denoted V for each propositional variable
V occurring in D. Hence, multiple occurrences of V only generate one node
V but generate several X + or X− nodes.
V	V
We add one new node denoted by ♦.
Then, the edges of GD are obtained as follows: we describe the set of green and red arrows linking those nodes together and the boolean expressions indexing those arrows. We begin by unconditional arrows (i.e. arrows implicitly indexed with the tautology 1) introduced independently of the internal structure of the formula D:
We add the (unconditional) red arrow X− ⇒♦ from the root node to ♦.
For a negative occurrence V of a variable, we add the green arrow V →X−.
For a positive occurrence V of a variable, we add the green arrow X + → V . These three rules are summarized on the left part of figure 1. Now we consider

5 The connectives ∧ and ∨ preserve signs and ⊃ preserves the sign on the right subformula and inverses the sign of the left subformula.


arrow introduction rules for internal nodes. First, the unconditional cases:
For a positive occurrence C ≡ A ∧ B of a subformula, we add the two following green arrows X + →X + and X + →X +.
C	A	C	B
For a negative occurrence C ≡ A ∨ B of a subformula, we add the two following green arrows X− →X− and X− →X−.
A	C	B	C
We continue with conditional arrows. These arrows are indexed with selectors,
i.e. boolean expressions of the form x or x where x is a boolean propositional variable. For each occurrence of subformula, we introduce a new boolean variable. 6
For a negative occurrence C ≡ A ∧ B of a subformula, given a new boolean variable x, we introduce the two conditional green arrows X− →x X− and
A	C
X− →x X−.
B	C
For a positive occurrence C ≡ A ∨ B of a subformula, given a new boolean variable x, we introduce the two conditional green arrows X + →x X + and
C	A
X + →x X +.
C	B
For a negative occurrence C ≡ A ⊃ B of a subformula, given a new boolean

variable x, we introduce the two following green arrows X− →x X−
and

B	C
→x X− and the two following red arrows X− ⇒x X + and X− ⇒x ♦.
C	B	A	B
For a positive occurrence C ≡ A ⊃ B of a subformula, given a new boolean

variable x, we introduce the two following green arrows X + →x X +
and

C	B
X− →x X +.
A	B
All the rules introducing (un)conditional arrows for internal nodes (corre- sponding to subformulae of D that are not atomic) are summarized on the right part of figure 1.
Given this procedure, it should be clear that the construction of the graph GD from a formula D takes linear time as at most four arrows are introduced for each instance of a subformula of D. The validity of D is related to the existence of some particular cycles in instances of GD.
Definition 3.4 A r-cycle in a bi-colored graph is a cycle composed of either green (→) or red (⇒) arrows, containing at least one red arrow. Equivalently, it is a chain of the form l (→ + ⇒)٨⇒ l.
Theorem 3.5 Let D be a formula of LC and G be its associated conditional bi-colored graph, built from the previously described procedure. Then D is provable in LC if and only if every instance graph Gv of G contains at least one r-cycle.

6 Indexing these variables with the subformula occurrence is a way to ensure uniqueness.


This result is proved in [13]. So in order to refute D, we have to find an instance graph Gv which does not contain any r-cycle. Let us proceed with an example.

Graph construction example
We consider the case of the classically valid Peirce’s formula ((A⊃B)⊃A)⊃A. It is not provable in any intermediate logic but classical logic, so in particular, it should have a counter-model in LC.
We index this formula as follows:
5	3	6	1	4	0	2
its associated conditional graph:
We add the arrow ⊃− ⇒ ♦.
We have two variables A and B for 4 oc- currences, so we add A → A−, A+ → A,
2	4
+	−
A5 → A and B → B6 .
For the internal node ⊃−, we choose a new boolean variable x and add the four conditional arrows A− →x ⊃−, ♦ →x ⊃−,
2	0	0
A− ⇒x ⊃+ and A− ⇒x ♦.
2	1	2
For the internal node ⊃+, we choose a new boolean variable y and add the two conditional arrows ⊃+ →y A+ and ⊃− →y A+.
1	4	3	4
For the last internal node ⊃−, we choose a new boolean variable z and add the four conditional arrows B− →z ⊃−, ♦ →z ⊃−, B− ⇒z A+ and B− ⇒z ♦.
6	3	3	6	5	6
Naive elimination of r-cycles
We now have to find a valuation vx, vy and vz in {0, 1} such that the corre- sponding instance graph has no r-cycle. For this we identify all the r-cycles and we try to find a valuation that simultaneously breaks each of the r-cycles. We consider only basic r-cycles that do not repeat nodes because any r-cycle contains at least a basic one. We find four of them:
⊃− ⇒♦ →x ⊃−

0	0
⊃− ⇒♦ →z ⊃− →y A+ → A → A− →x ⊃−
	
0	3	4	2	0
A− ⇒x ♦ →z ⊃− →y A+ → A → A−
	
2	3	4	2
A− ⇒x ⊃+ →y A+ → A → A−
2	1	4	2



	

Fig. 2. The conditional matrices for Peirce’s formula.
The first r-cycle is broken if and only if the condition x = 0 is satisfied, which is equivalent to satisfy x. The second r-cycle is broken if and only if the condition z + y + x is satisfied. 7 The third r-cycle is broken just in case x + z + y is satisfied and the last r-cycle is broken when x + y is satisfied.
In order to break these four r-cycles in one valuation, we look for a valuation v which satisfies x · (z + y + x) · (x + z + y) · (x + y). This gives us a unique solution: vx = 1, vy = 0, vz = 1. Then, the reader could verify that the instance graph Gv obtained from this valuation has no r-cycle. See section 5 for a representation of this graph and the associated counter-model of the Peirce’s formula.
The naive procedure we have described for computing a valuation with no r-cycles consists of searching all the possible r-cycles (without repeating nodes) and solving a boolean constraint system associated with these cycles. Unfor- tunately, such a procedure would be highly inefficient because there might be exponentially many r-cycles for a given formula. 8 This problem has also been addressed in [13]. In the next section, we give a description of one possible solution to the elimination of r-cycles.

Removing r-cycles in conditional bi-colored graphs
In section 3.1, we have introduced the notion of conditional bi-colored graph. A natural way to represent a directed graph is by considering the matrix of

7 We denote by + the boolean disjunction and by · the boolean conjunction.
8 For instance, ((X1 ∨ X1) ∧ (X1 ⊃ (X2 ∨ X2)) ∧· · ·∧ (Xn−1 ⊃ (Xn ∨ Xn))) ⊃ Xn has an associated conditional bi-colored graph containing 2n+1 − 1 (basic) r-cycles.


the underlying incidence relation. Usually, these matrices take there values in the boolean algebra {0, 1} and a 1 in the cell (i, j) means that there is an arrow from the node i to the node j.

Conditional matrices
To represent conditional bi-colored graphs, we use conditional matrices: the cells of these matrices take their values from the set of boolean functions. These functions are represented by boolean expressions built from the boolean selectors introduced during the conditional graph construction.
Definition 4.1 A conditional matrix on set S of size k is a k × k-array with values in the free boolean algebra over the set of selectors.
There are two incidence relations for a bi-colored graph corresponding to the green (→) and red (⇒) arrows. So a conditional bi-colored graph is represented by a pair of conditional matrices. We use the same denotation for the (conditional) incidence relation and for its corresponding matrix. So GD is represented by a pair (→, ⇒) of conditional matrices. Figure 2 presents the two matrices corresponding to the graph GD when D is the Peirce formula of section 3.2. We only write the cells whose values are different from 0: the matrices are sparse because the number of non-zero cells is linear whereas the total number of cell is quadratic.

R-cycle removal as a trace computation
The boolean operator of conjunction (or multiplication) · and disjunction (or sum) + extend naturally to conditional matrices. So we may consider the sum → + ⇒, product → · ⇒ of conditional matrices and the reflexive and transitive Σclosure →٨ =  i≥0 →i. We also introduce the trace of a matrix:
tr(M ) =	x Mx,x. When boolean selectors are instantiated inside a condi-
tional matrix, we get a matrix with values in {0, 1} which is the incidence ma-
trix of the corresponding instance graph. Moreover, instantiation commutes with algebraic operations on matrices. This leads to the following result:
Theorem 4.2 Let G = (→, ⇒) be a conditional bi-colored graph represented by a pair of condition al matrices. There exists a r-cycle in every instance Gv
Moreover, when the boolean function tr (→ + ⇒)٨⇒ is not a tautology, there exists a valuation v on selectors in {0, 1} such that this trace has value 0: tr (→v + ⇒v)٨⇒v = 0. Then, the corresponding instance graph Gv has no r-cycle.


Now, the problem is to compute this trace efficiently. Let us fix a size k > 0 of matrices. Let I denote the identity k × k matrix (Ix,x = 1 and Ix,y = 0 otherwise.) Let M be any conditional k × k matrix. Then M٨ = (I + M )k (because any path of size k + 1 contains a sub-path of size k.) Moreover, as I ≤ I + M (cell-wise), I, I + M, (I + M )2 ... is a (point-wise) increasing sequence of conditional matrices which stabilizes in at most k steps.
In order to evaluate (→ + ⇒)٨⇒, we compute α = I + → + ⇒ and β = ⇒ and then the increasing sequence β, αβ, α2β, α3β,... until it stabilizes to α٨β. This can be done column by column on β. Let βi denote the column i of β then α٨βi is the column i of α٨β. The computation of the column 1 for Peirce’s formula is the following:




β1  αβ1 α2β1α3β1 α4β1 α٨β1
x.y.z


x	x	x

x x
x	x
x.y x x.y x x x.z x
x.y x x.y x x x.z x x.z
x.y x x.y x x x.z x x.z

x.y.z x.y.z




Most of the columns of β contain only 0 in which case there is no need for computation: the fixpoint is this zero column. In the Peirce example, only column 1, 5 and ♦ contain values which are different from zero.
When evaluating the trace, it is possible to share computation between the columns of β. Let T be the column matrix composed of 1 on each cells.
We consider the following sequence: t0 = 0 and ti = α٨(ti−1T + βi) for
i = 1,..., k. Then tk = tr(α٨β). For example, in the case of Peirce’s formula, we get t0 = 0 and then t1 = x.y. Columns β2, β 3 and β4 are em pty (i.e. contain
only 0) so t2 = t3 = t4 = t1 = x.y. Then t5 = α٨(x.y.T + β5)	and we obtain
5
t5 = x.y. Then columns β6, βA and βB are empty and t6 = tA = tB = t5 = x.y.

Finally we compute t♦ =  α٨(x.y.T + β♦)  . Let γ = x.y.T + β♦:


γ
1
x.y x x.y
x.y
x.y
αγ
1
x.y x x.y
x.y
x.y
α2γ
1
x.y x x.y x x
α3γ
1
x.y x x x x
α٨γ
1
x.y x x x x

x.y + z x.y + z
x.y + z
x.y + z
x.y + z

x.y
x.y
x.y
x
x.y + z x + x.y
x
x.y + z x + x.y
x
x.y + z x + x.y
x
x.y + z
x + x.y + x.z


and we obtain t♦ = x + x.y + x.z. This the trace of α٨β = (→ + ⇒)٨⇒ and it is not a tautology. The only valuation that falsifies this trace is vx = 1, vy = 0, vz = 1. This is of course the same valuation we obtained by hand (by looking up for r-cycles) in section 3.3.

Counter-model extraction
Now we explain how to extract a counter-model from the corresponding in- stance bi-colored graph Gv. The reader can easily check that it can be repre- sented by:

In this graph, red arrows are always strictly climbing up and green arrows never go down so no r-cycle could exist. The counter-model is very easy to compute: give the variable A and B their height in this graph. So [A]] = 1 and [B ] = 0 is a counter-model to the Peirce’s formula which can be checked by [((A⊃ B) ⊃ A) ⊃ A]] = ((1 d 0) d 1) d 1= (0 d 1) d 1= ∞ d 1=1 < ∞
Now we explain how to extract a counter-model out of an instance graph lacking r-cycles in the general case. We give a characterization of the lack of r-cycles based on the notion of bi-height :


Definition 5.1 Let G be a bi-colored graph. A bi-height is a function h : G → N such that for any x, y ∈ G, if x → y ∈ G then h(x) ≤ h(y) and if x ⇒ y ∈ G then h(x) < h(y).
It is clear that the preceding graph has a bi-height given by h(B) =
h(B−) = h(⊃−) = h(A+) = 0, h(A+) = h(A) = h(A−) = h(⊃+) = 1 and
6	3	4	5	2	0
h(♦)= h(⊃+)= 2. In [13], you will find a constructive proof of the following result which states the existence of a bi-height whenever no r-cycle exist:
Theorem 5.2 Let D be a formula of LC, G the corresponding conditional bi-colored graph and v a valuation such that the instance graph Gv does not contains any r-cycle. Then it is possible to compute a bi-height h for Gv in linear time. 9 Moreover, if we deﬁne [[·]] : Var → N by [[V ]] = h(V ) for V variable of D then [[·]] is a counter-model of D, i.e. [[D]] < ∞.

Implementation remarks and conclusion
The procedure described throughout this paper has been implemented com- pletely in the Objective Caml language and is accessible at
http://www.loria.fr/~larchey/LC
The reader interested in the proofs of the results presented here can also find them there.
For the prototype implementation, we have chosen to represent conditional matrices by sparse arrays. The boolean functions which compose them are rep- resented by the nodes of a shared BDD [5] for efficient boolean computations and extraction of boolean counter-models. The algorithm for the computation of bi-heights is a slightly modified version of a depth first search procedure.
Furthermore, the implementation also includes another matrix algorithm designed for the finitary versions LCn of LC, see [12]. This algorithm is able to compute minimal counter-models of a given formula.
In further work, we will deeper investigate the relationships between the notion of r-cycle and the G-cycles of [3] and analyze if our conditional graphs also fit in the hyper-sequent setting. We will also investigate the relationships between our parallel counter-model search and other approaches based for example on parallel dialogue games [4,9].

9 Linearity is measured with respect to either the size of D or the number of nodes and arrows of Gv.

References
Alessendro Avellone, Mauro Ferrari, and Pierangelo Miglioli. Duplication-Free Tableau Calculi and Related Cut-Free Sequent Calculi for the Interpolable Propositional Intermediate Logics. Logic Journal of the IGPL, 7(4):447–480, 1999.
Arnon Avron. A Tableau System for G¨odel-Dummett Logic Based on a Hypersequent Calculus. In TABLEAUX 2000, volume 1847 of LNAI, pages 98–111, 2000.
Arnon Avron and Beata Konikowska. Decomposition Proof Systems for G¨odel-Dummett Logics. Studia Logica, 69(2):197–219, 2001.
Matthias Baaz and Christian Fermu¨ller.	Analytic Calculi for Projective Logics.	In
TABLEAUX’99, volume 1617 of LNCS, pages 36–50, 1999.
Randal E. Bryant. Graph-based algorithms for Boolean function manipulation. IEEE Transactions on Computers, C-35(8):677–691, 1986.
Michael Dummett. A Propositional Calculus with a Denumerable matrix. Journal of Symbolic Logic, 24:96–107, 1959.
Roy Dyckhoff. Contraction-free Sequent Calculi for Intuitionistic Logic. Journal of Symbolic Logic, 57(3):795–807, 1992.
Roy Dyckhoff. A Deterministic Terminating Sequent Calculus for Go¨del-Dummett logic.
Logical Journal of the IGPL, 7:319–326, 1999.
Christian Fermu¨ller. Parallel Dialogue Games and Hypersequents for Intermediate Logics. In
TABLEAUX 2003, volume 2796 of LNAI, pages 48–64, 2003.
Kurt G¨odel. Zum intuitionistischen Aussagenkalku¨l. In Anzeiger Akademie des Wissenschaften Wien, volume 69, pages 65–66. 1932.
Petr Hajek. Metamathematics of Fuzzy Logic. Kluwer Academic Publishers, 1998.
Dominique Larchey-Wendling. Combining Proof-Search and Counter-Model Construction for Deciding G¨odel-Dummett Logic. In CADE-18, volume 2392 of LNAI, pages 94–110, 2002.
Dominique Larchey-Wendling. Counter-model search in G¨odel-Dummett logics. In IJCAR 2004, volume 3097 of LNAI, pages 274–288, 2004.
George Metcalfe, Nicolas Olivetti, and Dov Gabbay. Goal-Directed Calculi for G¨odel-Dummett Logics. In CSL, volume 2803 of LNCS, pages 413–426, 2003.
