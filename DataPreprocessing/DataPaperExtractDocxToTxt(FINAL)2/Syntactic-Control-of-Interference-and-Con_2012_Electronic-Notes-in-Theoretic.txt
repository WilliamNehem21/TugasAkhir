Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 286 (2012) 87–102
www.elsevier.com/locate/entcs

Syntactic Control of Interference and Concurrent Separation Logic
Stephen Brookes
Department of Computer Science Carnegie Mellon University Pittsburgh, USA

Abstract
At last year’s MFPS conference we introduced a revised version of Concurrent Separation Logic in which assertions are tagged with a “rely set” of variables assumed to be unmodified by other processes. We showed that this logic is compositional and sound with respect to an action trace semantics. The revision was motivated by a subtle issue concerning soundness of the original version of the logic, discovered by Ian Wehrman and Josh Berdine. The revised logic fixes this problem and also relaxes the Owicki-Gries constraints on variables, allowing shared variables to be protected by multiple resources rather than a single one, but requiring that a process writing to a shared variable must acquire all resources that protect it, while a process reading a shared variable need only acquire one such resource. This generalization brings concurrent separation logic closer in spirit to permission-based logics, although our formulation makes no explicit mention of permissions. At the same conference, Uday Reddy introduced a concurrent separation logic with static permissions for variables, generalizing John Reynolds’s ideas on syntactic control of interference to a concurrent setting. Here we show that there is an extremely close relationship between these two logics. Essentially, every provable assertion in Reddy’s logic corresponds to a provable assertion in CSL with the same semantic content; and every provable assertion in CSL corresponds to a multitude of assertions in Reddy’s logic, differing only in the choice of specific permission values. We show that every derivation in Reddy’s logic can be transformed into a derivation in CSL, by abstracting away from permission details while retaining the relevant information about protection of variables by resources. And we show how to construct, for a given CSL derivation, a family of corresponding derivations in Reddy’s logic that differ only in inessential permission choices. These results also imply that one can establish soundness of Reddy’s logic by appealing to soundness of CSL, leading to a simpler soundness proof than the one given in Reddy’s original paper, which used an augmented form of action trace semantics.
Keywords: concurrency, shared memory, resources, separation logic, permissions

Introduction
Concurrent Separation Logic is a logic for fault-free partial correctness of shared- memory concurrent programs, combining separation logic [10] with Owicki-Gries inference rules for pointer-free shared-memory programs [8], as proposed by Peter O’Hearn [7]. The original Owicki-Gries and O’Hearn logics apply only to programs with rigid parallel structure, because of a constraint that “no other process modifies” certain variables, imposed as a side condition in the rule for conditional critical regions.

1571-0661 © 2012 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2012.08.007

In prior work we formulated a more general concurrent separation logic [3], using resource contexts in an attempt to avoid these limitations. We gave a semantic for- malization of O’Hearn’s notion of “ownership transfer” based on resource invariants, and of O’Hearn’s principle that provable processes “mind their own business” [7]. Subsequently, Ian Wehrman and Josh Berdine [12] discovered that the soundness analysis in [3] contains a hidden assumption tantamount to “no other process mod- ifies”, so this logic was also only sound for rigid programs.
In response, at last year’s MFPS [5] we introduced a revised version of this logic in which assertions are augmented with a “rely set” representing a set of variables deemed to be left unmodified by “other” processes. By making this set an integral part of assertions, we avoid the need for a non-compositional side condition. The revised logic, which we call CSL, deals with these no-modifies assumptions in a syntax-directed and modular manner, without forcing the prover to know the rest of the program in advance. In addition the revised logic relaxes the Owicki-Gries constraints on use of critical variables, allowing such variables to be protected by several resources instead of a single one, thus embodying a more general protection discipline. A process writing a shared variable must acquire all resources that protect it, whereas reading a shared variable merely requires acquisition of some resource that protects it. We proved soundness of the revised CSL, this time without the hidden assumption and without requiring rigid program structure [5].
At the same MFPS Uday Reddy presented a permission-based version of con- current separation logic, in which variables (but not heap cells) are given statically controlled permissions. This material appeared later as a joint paper with John Reynolds [9], including an algorithm (due to Reynolds) for inferring permission assignments. This work was motivated by a desire to generalize earlier ideas of Reynolds on syntactic control of interference to the concurrent setting. Reddy’s assertions deal elegantly with statically scoped permission contexts, and his formu- lation elides some of the syntactic side conditions that govern CSL rules dealing with variables, instead replacing them with implicit well-formedness constraints on the syntax of judgements. In this logic, writing to a shared variable requires ac- quisition of “total” permission for that variable, while reading is allowed with any permission. Static permissions, used this way, enforce syntactic control of interfer- ence: every provable program is free of race conditions involving variables (because of permission constraints), and free of races involving heap cells (by judicious use of separate conjunction).
Reddy commented [9] that there seems to be a close relationship between CSL and static permissions, and we made a similar observation at the time [5]. Indeed we deliberately used similar terminology to describe the disciplines for shared vari- able usage in the two frameworks: total permission surely seems “equivalent” to possession of all protecting resources, since both preclude any other process from interfering. CSL keeps track of the set of resources owned by processes, whereas Reddy’s logic maintains book-keeping information on the amount of permission for variables gathered by processes as they acquire and release resources.
In this paper we make a precise and rigorous connection between the two logics,

confirming these intuitions. Informally, each provable assertion in Reddy’s logic cor- responds to a provable assertion in CSL; and a provable CSL assertion corresponds to a (non-empty) set of provable assertions in Reddy’s logic, differing only in essen- tially irrelevant details concerning specific choices of permission values. To establish these claims formally we first summarize some of the key concepts and definitions from the two logics. We make a careful analysis of the way proof derivations work in the two logics. We will also make clear what we mean by irrelevant permission decisions.
We assume familiarity with separation logic, as defined by Reynolds [10]. The reader can consult [5] for semantic foundations. To make this paper self-contained we recapitulate some material from [5] and [9].

Syntax
The syntax of commands (or processes) is given by the following abstract grammar:

C ::= skip | i:=e | i:=[e] | [e]:=ej | i:=cons E | dispose e
|  C1; C2 | if b then C1 else C2 | while b do C
|  with r when b do C | resource r in C | C1  C2

where e ranges over integer expressions, b over boolean expressions, and E over list expressions of form [e1,..., en]. Expressions are pure, i.e. independent of the heap. Further, i ranges over identifiers (or program variables) and r over resource names; resources behave like binary semaphores. We use the standard abbreviation with r do C for with r when true do C.
Let free(C) ⊆ Ide be the set of identifiers with a free occurrence in C. Let mod (C) be the set of identifiers with a free write occurrence in C, defined as usual, by structural induction:

mod (skip)= {}
mod (i:=e)= mod (i:=cons E)= mod (i:=[e]) = {i}
mod ([e]:=ej)= mod (dispose e)= {}
mod (C1; C2)= mod (C1  C2)= mod (C1) ∪ mod (C2) mod (if b then C1 else C2)= mod (C1) ∪ mod (C2) mod (while b do C)= mod (C)
mod (with r when b do C)= mod (C)
mod (resource r in C)= mod (C)

Concurrent Separation Logic
As in Owicki-Gries [8], we associate to each resource name r a set X ⊆ Ide of “protected variables” and a “resource invariant” R [6], which is required to be a precise separation logic formula as in [7]. A separation logic formula R is precise iff, for all stores s and heaps h, there is at most one sub-heap hj ⊆ h such that (s, hj) |= R. Instead of assuming a statically fixed association of resource invariants and protection sets to resource names, we extend the syntax of partial correctness assertions to include a resource context, as in [3]. We also relax the variable usage constraints from the earlier logics by not insisting that protection sets be pairwise disjoint.
Definition 3.1 A well-formed resource context has the form
r1(X1): R1,..., rn(Xn): Rn
where r1,..., rn are distinct resource names, X1,..., Xn are sets of identifiers, each
Ri is precise, and free(Ri) ⊆ Xi for each i.
We let Γ range over the set of well-formed resource contexts. We say that r
protects x in Γ when r(X) : R is in Γ and x ∈ X. Let owned (Γ) = Sn	Xi, and
inv (Γ) = R1 ∗ · · · ∗ Rn. Let dom(Γ) be {r1,..., rn}. We let Γ, r(X) : R be the context that combines Γ with r(X): R, when well-formed.
Definition 3.2 A well-formed CSL assertion has form
Γ ▶A {P}C{Q},
where A is a (finite) set of identifiers, Γ is a well-formed resource context, free(P, Q) ⊆
A, and free(C) ⊆ owned (Γ) ∪ A.
In an assertion Γ ▶A {P}C{Q} we refer to A as the rely set, P as the pre- condition, and Q as the post-condition. The constraints allow P and Q to mention identifiers owned by resources in Γ, but only if they belong to the rely set; the command C may use variables owned by resources or belonging to the rely set. The rules use rely sets to keep track of variables used (outside of critical regions, so without protection): for soundness and the avoidance of race conditions such vari- ables must not be modified by any other process, and this requirement is enforced as a side condition in the CSL parallel rule. The CSL inference rules will constrain where C is allowed to read and write protected variables: every write in C to a protected variable must be inside (nested) critical regions naming all resources that protect it; and every read occurrence in C of a protected variable must be inside a critical region naming some resource that protects it. In the special case where the protection sets are pairwise disjoint, this coincides with the usual Owicki-Gries discipline.
Definition 3.3 The assertion Γ ▶A {P}C{Q} is valid iff every finite interactive computation of C, from a state (with values for all variables in Γ, A) satisfying

P ∗ inv (Γ), in an environment that respects Γ and does not write to variables in A, is fault-free, respects Γ, and ends in a state satisfying Q ∗ inv (Γ).
Respect for Γ means obedience to the protection regime and preservation of each resource invariant (separately). Fault-freedom means no runtime errors such as dangling pointers, and no race conditions involving concurrent writes to shared variables or heap cells.
Validity of Γ ▶A {P}C{Q} also implies fault-free partial correctness: every terminating execution of C in isolation, from a state satisfying P ∗ inv (Γ), is fault- free and ends in a final state satisfying Q ∗ inv (Γ). This is because the empty environment vacuously respects Γ and does not write to any variable.
The CSL rules for assignment, parallel composition, critical regions, and local resource blocks are summarized below, together with the Frame rule and the Rule of Consequence, which allows weakening of post-conditions and strengthening of pre-conditions as usual and allows expansion of a rely set.
Only well-formed instances of these rules are allowed.

Assignment
if i ∈/
Γ ▶A {[e/i]P}i:=e{P}


owned (Γ), free(P, e) ⊆ A



Parallel
Γ ▶A1 {P1}C1{Q1}	Γ ▶A2 {P2}C2{Q2}


if mod (C1) ∩ free(C2) ⊆ owned (Γ), mod (C2) ∩ free(C1) ⊆ owned (Γ), mod (C1) ∩ A2 = {} and mod (C2) ∩ A1 = {}.
Region


Resource

Frame
Γ ▶A∪X {(P ∗ R) ∧ b}C{Q ∗ R}
Γ, r(X): R ▶A {P}with r when b do C{Q}
Γ, r(X): R ▶A {P}C{Q}
Γ ▶A∪X {P ∗ R}resource r in C{Q ∗ R}



	Γ ▶A {P}C{Q}	
Γ ▶A∪free(R) {P ∗ R}C{Q ∗ R}
if mod (C) ∩ free(R)= {}



Consequence

 Γ ▶A {P}C{Q} 
Γ ▶A′ {Pj}C{Qj}


if A ⊆ Aj, Pj ⇒ P, Q ⇒ Qj

In Assignment note that well-formedness implies that i ∈ A.
In Parallel, the side condition ensures that neither process modifies any iden- tifiers in the other process’s rely set.

In Region the premiss relies on A ∪ X because mutual exclusion for r implies that the identifiers in X cannot be modified by other processes while the current process is inside the critical region.
In Resource the conclusion relies on A ∪ X, which ensures well-formedness of the conclusion whenever the premiss is well-formed, because free(R) ⊆ X.
In Frame, as usual, C must not write to any identifier occurring free in R. There is no need to insist, as was done in [3], that free(R) ∩owned (Γ) = {}; instead we add the variables occurring free in R to the rely set, reflecting the assumption that no concurrent processes modify these variables.
Example
Here is an example that facilitates the coming comparison with Reddy’s logic.
The following assertion is provable in CSL. Note the rely set {x}.

▶{x} {42 '→ }
resource r1 in resource r2 in
(with r1 do (with r2 do x:=1); [42]:=1)  (with r2 do (with r1 do x:=2); [42]:=2)
{42 '→ }

Validity of this assertion implies that this program, when executed from a state in which x has a value and 42 is a heap cell, is error-free, provided no other process modifies x; in particular, there is no race condition involving x, and no race condition involving the heap cell. Of course, the rely assumption is needed: if the code is run concurrently with a process that modifies x there could be a race condition. Let C1 and C2 be:
C1 :: with r1 do ((with r2 do x:=1); [42]:=1)
C2 :: with r2 do ((with r1 do x:=2); [42]:=2).
Let R1 and R2 be the assertions
R1 :: (x =1 ∧ 42 '→ 1) ∨ (x =2 ∧ emp)
R2 :: (x =1 ∧ emp) ∨ (x =2 ∧ 42 '→ 2). As shown in [5] the following assertions are derivable in CSL:
r1(x): R1, r2(x): R2 ▶{} {emp}C1{emp}
r1(x): R1, r2(x): R2 ▶{} {emp}C2{emp}.

By Parallel we can then get
r1(x): R1, r2(x): R2 ▶{} {emp}C1  C2{emp}
and finally, by Resource,
▶{x} {R1 ∗ R2}resource r1 in resource r2 in (C1  C2){R1 ∗ R2}.
This derivation employs a resource context r1(x) : R1.r2(x) : R2 in which the protection lists are not disjoint.

Reddy’s logic
Reddy’s version of Concurrent Separation Logic uses static permissions to ensure proper usage of shared variables.
Following [1], a permission algebra (P, ⊕, T) is a partial commutative, cancella- tive semi-group such that

∀p1, p2 ∈ P. p1 ⊕ p2 /= p2	(non-zero)
∀p ∈ P. p ⊕T is undefined	(top)
∀p ∈ P.∃p1, p2 ∈ P. p = p1 ⊕ p2	(divisibility)
A permission context Σ has the form xp1 ,..., xpn and is well-formed if and only if
1	n
whenever x occurs multiple times in Σ, with permissions pi1 ,..., pik , then pi1 ⊕· · ·⊕ 
pik is defined. We write Σ1,..., Σn for the obvious composite context combining the permission entries of the Σi, when this is well-formed.
Let dom(Σ) = {x ∈ Ide | ∃p. xp ∈ Σ} and, for x ∈ dom(Σ), let Σ(x) be the sum of all permissions occurring for x in the entries of Σ. Let |Σ| = {(x, Σ(x)) | x ∈ dom(Σ)}. Permission contexts Σ1 and Σ2 are equivalent iff they give the same permissions to all identifiers, i.e. when |Σ1| = |Σ2|.
Reddy introduces syntactic judgements, defined with structural inference rules, with the following forms:
Σ ▶ i Var
Σ ▶ e Exp
Σ ▶ P Assert
In each case Σ is required to be a well-formed permission context. Using validity here to mean derivability from Reddy’s inference rules, the following key facts are easy to establish:
If Σ ▶ i Var is valid, then i ∈ dom(Σ) and Σ(i)= T.
If Σ ▶ e Exp is valid, then free(e) ⊆ dom(Σ).
If Σ ▶ P Assert is valid, then free(P ) ⊆ dom(Σ).

Although Reddy’s paper does not provide a full set of inference rules for these judgements, it seems reasonable to assume that the converse implications also hold, since the purpose of these syntactic judgements is to formalize the indicated static constraints on variables and permissions.
Reddy also introduces permissive resource contexts, of the form
r1(Σ1): R1,..., rn(Σn): Rn
where r1,..., rn are distinct resource names, Σ1,..., Σn is a well-formed permission context, each Ri is precise, and for each i, Σi ▶ Ri Assert is valid. We will use Δ to range over (well-formed) permissive resource contexts 1 .
Reddy’s proof system uses assertions of the form
Σ | r1(Σ1): R1,..., rn(Σn): Rn ▶ {P }C{Q},
subject to the constraint that Σ, Σ1 ..., Σn is a well-formed permission context, r1,..., rn are distinct resource names, each Ri is precise, and Σi ▶ Ri Assert is valid, for each i. Note that this implies that for each i, free(Ri) ⊆ dom(Σi).
The Reddy rules for assignment, parallel composition, critical regions, and local resource blocks are listed below, together with the Frame Rule. There are also rules for the other program constructs and a Rule of Consequence. We use the same labels as for the corresponding CSL rules. Only well-formed instances are allowed.
Assignment
Σ ▶ i Var	Σ ▶ e Exp	Σ ▶ P Assert
Σ | Δ ▶ {[e/i]P }i:=e{P}
Parallel
Σ1 | Δ ▶ {P1}C1{Q1}	Σ2 | Δ ▶ {P2}C2{Q2}


Region

Resource
Σ ▶ P, Q Assert	Σ, Σ0 | Δ ▶ {(P ∗ R) ∧ b}C{Q ∗ R}
Σ | Δ, r(Σ0): R ▶ {P }with r when b do C{Q}






Frame
Σ0 ▶ R Assert	Σ | Δ, r(Σ0): R ▶ {P }C{Q}
Σ, Σ0 | Δ ▶ {P ∗ R}resource r(Σ0) in C{Q ∗ R}

Σ | Δ ▶ {P }C{Q}	Σj ▶ R Assert Σ, Σj | Δ ▶ {P ∗ R}C{Q ∗ R}

The implicit well-formedness constraints on these rules codify many of the static side conditions that occur in the corresponding CSL rules. For example, in Frame the premiss Σj ▶ R Assert implies that free(R) ⊆ dom(Σj), and whenΣ | Δ ▶ {P }C{Q} is provable and Σ, Σj is well-formed this implies mod (C) ∩ free(R) = {}, the side condition imposed in the CSL Frame rule.

1 Reddy uses Γ for permissive contexts, but we prefer Δ to avoid confusion with CSL.

We should point out a subtle issue that differentiates Reddy’s set-up from ours. Although this may seem to be only a minor difference, it has significant consequences. In Reddy’s framework we must attach permission contexts to lo- cal resource names. This is evident in the Resource rule: unless |Σ0| = |Σ1|, the decorated programs resource r(Σ0) in C and resource r(Σ1) in C are log- ically distinguishable, since they are usable in different proof contexts. To prove Σj | Δ ▶ {P j}resource r(Σ0) in C{Qj} it must be possible to “slice out” Σ0 from Σj, whereas it may not be possible to slice out Σ1 instead. Each of these judgements concerns a decorated version of the same original program, and in establishing con- nections between the two logics we should distinguish between commands (in the original programming language) and decorated commands that arise in this manner. We will use Cj, Cjj to range over decorated commands, C over commands; and we say that Cj is a decoration of C if C is obtained from Cj by erasing permission con- texts. The rules of Reddy’s logic presented above should really employ Cj rather than C as meta-variable, since the judgements involve decorated commands rather than commands, although we refrain from re-stating them in amended form.
Obviously we can characterize the decoration relationship by structural induc- tion. In particular, if C contains no local resource blocks then the only decoration of C is C itself; Cjj is a decoration of resource r in C if and only if Cjj has form

resource r(Σ) in Cj, where Cj is a decoration of C. Similarly Cj ; Cj
is a deco-

1	2

ration of C1; C2 if and only if Cj
is a decoration of C1 and Cj
is a decoration of

C2; and Cj   j is a decoration of C1  C2 if and only if Cj is a decoration of C1
and Cj is a decoration of C2. It is obvious that when Cj is a decoration of C,
mod (Cj)= mod (C) and free(Cj)= free(C).




Example
Let P = (0, 1] be fractional permissions, with p1 ⊕ p2 = p1 + p2 iff p1 + p2 ≤ 1, and T = 1, as in [2]. One can derive the following assertion in Reddy’s logic, as shown in [9]:

▶ {42 '→ }
resource r1(x1/2) in resource r2(x1/2) in
(with r1 do (with r2 do x:=1); [42]:=1)  (with r2 do (with r1 do x:=2); [42]:=2)
{42 '→ }

But equally well for each pair (p, q) such that 0 < p, q < 1 and p + q = 1 one can derive
▶ {42 '→ }
resource r1(xp) in resource r2(xq) in
(with r1 do (with r2 do x:=1); [42]:=1)  (with r2 do (with r1 do x:=2); [42]:=2)
{42 '→ }
and in each case the derivations are essentially the same, up to minor details con- cerning fractions.
The results of the next section will establish that all of these derivations corre- spond in a precise manner to the single CSL derivation shown earlier as an example.

Connecting the logics
We first show that every provable judgement in Reddy’s logic corresponds to an assertion provable in CSL. To start, we note without proof following general prop- erties, which are echoed in Reddy’s development.
Theorem 7.1
If Σ | r1(Σ1): R1,..., rn(Σn): Rn ▶ {P }Cj{Q} is provable, and x ∈ free(Cj), then x ∈ dom(Σ, Σ1,..., Σn).
If Σ | r1(Σ1): R1,..., rn(Σn): Rn ▶ {P }Cj{Q} is provable,
and x ∈ mod (Cj), then (Σ, Σ1,..., Σn)(x)= T.
When (Σ, Σ1,..., Σn) is a tuple of permission contexts we can construct a rely set and a tuple of protection lists by applying dom to each component and rearranging, to get (dom(Σ), (dom(Σ1),..., dom(Σn)). Similarly, given a (well-formed) Reddy context Δ we can construct a (well-formed) CSL resource context by applying dom inside each term of Δ, leaving resource names and invariants unchanged. When Δ has the form r1(Σ1) : R1,..., rn(Σn) : Rn this produces the resource context Γ of form r1(dom Σ1) : R1,..., rn(dom Σn) : Rn. Let us write Γ = map dom Δ when this relationship holds.
Theorem 7.2
If Σ | Δ ▶ {P }Cj{Q} is provable in Reddy’s logic, Cj is a decoration of C, Γ = 
map dom Δ and A = dom(Σ), then Γ ▶A {P}C{Q} is provable in CSL.
Proof: by induction on the proof height of the derivation. We show that for each (well-formed instance of an) inference rule in Reddy logic, if the relevant side conditions hold and the premisses are provable in Reddy’s logic, then the CSL assertion corresponding to the rule’s conclusion is provable from the CSL assertions representing the rule’s premisses. We sketch the details for the rules listed above.

We make use of Theorem 7.1 in various places.
Every well-formed instance of the Reddy Assignment rule has the form
Σ ▶ i Var	Σ ▶ e Exp	Σ ▶ P Assert Σ | Δ ▶ {[e/i]P }i:=e{P}
Since we assume that the premisses are provable, we have |Σ|(i)= T, free(e) ⊆ dom(Σ), and free(P ) ⊆ dom(Σ). Let A = dom(Σ) and let Γ = map dom Δ be the CSL resource context determined by Δ. By well-formedness of Σ, Δ it follows
that i ∈/ owned (Γ). So the side conditions for the appropriate instance of the CSL
Assignment rule hold, and the CSL assertion Γ ▶A {[e/i]P}i:=e{P} is provable.
Consider a well-formed instance of Parallel, where Cj	j is a decoration of

C1  C2:
Σ1 | Δ ▶ {P1}Cj {Q1}	Σ2 | Δ ▶ {P2}Cj {Q2}

1	2
Let A1 = dom(Σ1), A2 = dom(Σ2), Γ = map dom Δ. The CSL assertions cor- responding to the premisses of this rule are then Γ ▶A1 {P1}C1{Q1} and Γ ▶A2
{P1}C2{Q2}. By Theorem 7.1 and well-formedness it follows that mod (C2)∩A1 =
{}, mod (C1)∩A2 = {}, mod (C1)∩free(C2) ⊆ owned (Γ), and mod (C1)∩free(C1) ⊆
owned (Γ). So by the CSL Parallel rule we get Γ ▶A1∪A2 {P1 ∗ P2}C1 C2{Q1 ∗
Q2}. This is the CSL assertion corresponding to Σ1, Σ2 | Δ ▶ {P1∗P2}Cj Cj {Q1∗
Q2}.
Consider a well-formed instance of Region in which Cj is a decoration of C:
Σ ▶ P, Q Assert	Σ, Σ0 | Δ ▶ {(P ∗ R) ∧ b}Cj{Q ∗ R}
Σ ▶ Δ, r(Σ0): R ▶ {P }with r when b do Cj{Q}
Let A = dom(Σ), X = dom(Σ0), and Γ = map dom Δ. The CSL assertion corresponding to the (second) premiss is Γ ▶A∪X {(P ∗ R) ∧ b}C{Q ∗ R}. Using the CSL Region rule we can deduce
Γ, r(X): R ▶A {P}with r when b do C{Q}.
This is the CSL assertion corresponding to the conclusion of the Reddy rule, and is well-formed; the first premiss implies free(P, Q) ⊆ A.
Consider a well-formed instance Resource in which Cj decorates C:
Σ0 ▶ R Assert	Σ | Δ, r(Σ0): R ▶ {P }Cj{Q}
Σ, Σ0 | Δ ▶ {P ∗ R}resource r(Σ0) in Cj{Q ∗ R}
Assume that the premisses are provable. Let A = dom(Σ), X = dom(Σ0), Γ = map dom Δ. Then free(R) ⊆ X, because Σ0 ▶ R Assert is provable. The CSL assertion determined by the second premiss is
Γ, r(X): R ▶A {P}C{Q}.

Using the CSL Resource rule we can deduce from this the assertion Γ ▶A∪X {P ∗ R}resource r in C{Q ∗ R},
which corresponds to the conclusion in the Reddy rule.
For the Frame rule suppose that Σ | Δ ▶ {P }Cj{Q} and Σj ▶ R Assert are provable in Reddy’s logic, so that Σ, Σj | Δ ▶ {P ∗ R}Cj{Q ∗ R} is provable from the Frame rule. Let Cj decorate C. Then free(R) ⊆ dom(Σj) and mod (Cj) ∩ dom(Σj)= {}, using Theorem 7.1 again. Let A = dom(Σ) and Γ = map dom Δ. The CSL version of the premiss is Γ ▶A {P}C{Q}. From the above, we have mod (C) ∩ free(R)= {}. So we can use the CSL Frame rule to derive Γ ▶A∪free(R)
{P ∗ R}C{Q ∗ R}. Using Consequence we can then deduce Γ ▶A∪dom(Σ′) {P ∗
R}C{Q ∗ R}, which corresponds as required to Σ, Σj | Δ ▶ {P ∗ R}Cj{Q ∗ R}.
(End of Proof ) To establish a converse connection between the logics we argue as follows.
For a tuple of identifier sets (A, X1,..., Xn) and a subset Y ⊆ A ∪ Sn	Xi, the
set of permission contexts Σ, Σ1,..., Σn such that dom(Σ) = A, dom(Σi)= Xi for
each i, and (Σ, Σ1,..., Σn)(x) = T for all x ∈ Y , is non-empty. We use this fact to guide the choices of permission contexts when constructing a Reddy judgement Σ | Δ ▶ {P }Cj{Q} to match a CSL assertion Γ ▶A {P}C{Q}.
When Δ is r1(Σ1): R1,..., rn(Σn): Rn and Σ is a permission context we may use the abbreviation Σ, Δ for the permission context Σ, Σ1,..., Σn. We will also say that the combination Σ, Δ is well-formed when this permission context is well- formed and Δ is a well-formed permissive resource context.
Theorem 7.3
Let Γ ▶A {P}C{Q} be a provable assertion in CSL. Let Σ, Δ be well-formed and suppose that dom(Σ) = A, map dom Δ= Γ, and for all x ∈ mod (C), (Σ, Δ)(x)= T. Then there is a decoration Cj of C such that the judgement Σ | Δ ▶ {P }Cj{Q} is provable in Reddy’s logic.
Proof: For simplicity we will assume that P is the fractional permissions algebra, although it is easy to adjust the proof details to encompass a general permissions algebra; in the general proof divisibility plays a crucial rˆole, and with fractional permissions we can get by with division by 2.
The proof is by induction on proof height. We show that for each CSL infer- ence rule, if the premisses have this property and the side conditions hold, then the conclusion has this property. We give the details for assignment, for parallel composition (where division is needed), regions, and local resource blocks (where we must choose an appropriate decoration); the other rules are simpler and can be handled in similar manner.
Assignment: Consider a well-formed instance of the CSL assignment rule:

Γ ▶A {[e/i]P}i:=e{P}

where free(i:=e) ⊆ owned (Γ) ∪ A, i ∈/  owned (Γ), and free(P, e) ⊆ A. Then i ∈ A.
We can pick any combination of Σ and Δ such that dom(Σ) = A, |Σ|(i) = T, and map dom Δ = Γ. (The set of such combinations is non-empty.) Then we have Σ ▶ i Var, Σ ▶ e Exp, and Σ ▶ P Assert. So the premisses of the relevant instance of Reddy’s assignment rule are valid, hence provable, and
Σ | Δ ▶ {[e/i]P }i:=e{P}
is provable.
Parallel: Consider a well-formed instance of the CSL parallel rule:
Γ ▶A1 {P1}C1{Q1}	Γ ▶A2 {P2}C2{Q2}

with mod (C1) ∩ A2 = mod (C2) ∩ A1 = {}, mod (C1) ∩ free(C2) ⊆ owned (Γ) and mod (C2) ∩ free(C2) ⊆ owned (Γ). We can choose Σ and Δ such that dom(Σ) = A1 ∪ A2, map dom Δ = Γ, and ∀x ∈ mod (C1  C2), (Σ, Δ)(x)= T. Define permis- sion contexts Σ1 and Σ2 as follows:
Σ1 = {xp ∈ Σ | x ∈ A1 − A2}∪ {xp/2 | xp ∈ Σ,x ∈ A1 ∩ A2}
Σ2 = {xp ∈ Σ | x ∈ A2 − A1}∪ {xp/2 | xp ∈ Σ,x ∈ A1 ∩ A2}.
Then |Σ| = |Σ1, Σ2|, and dom(Σ1)= A1, dom(Σ2)= A2. By assumption mod( C1) ∩
A2 = mod (C2)∩A1 = {}, so ∀x ∈ mod (C1). (Σ1, Δ)(x) = T and ∀x∈ mod (C2). (Σ2, Δ)(x)= 
T. It follows by the induction hypothesis that there are decorations Cj of C1
and Cj of C2 such that the judgements Σ1 | Δ ▶ {P1}Cj {Q1} and Σ2 | Δ ▶
{P2}Cj {Q2} are provable. So by the Reddy Parallel rule we can deduce
Σ1, Σ2 | Δ ▶ {P1 ∗ P2}Cj  Cj {Q1 ∗ Q2},


and hence Σ | Δ ▶ {P1 ∗ P2}Cj  Cj {Q1 ∗ Q2}. Finally, note that Cj  Cj
is a

1	2	1	2
decoration of C1  C2, so the result holds as required.
For Region, consider a well-formed instance
Γ ▶ A ∪ X{(P ∗ R) ∧ b}C{Q ∗ R}
Γ, r(X): R ▶A {P}with r when b do C{Q}
Let Σ, Σ0, Δ be well-formed and dom(Σ) = A, dom(Σ0) = X, map dom Δ = Γ, and ∀x ∈ mod (C). (Σ, Σ0, Δ)(x)= T. Then dom(Σ, Σ0)= A∪X. So by induction hypothesis there is a decoration Cj of C such that
Σ, Σ0 | Δ ▶ {(P ∗ R) ∧ b}Cj{Q ∗ R}
is provable. By well-formedness we have free(P, Q) ⊆ A, so Σ ▶ P, Q Assert is valid. Hence
Σ | Δ, r(Σ0): R ▶ {P }with r when b do Cj{Q}

is provable by the Reddy region rule. This judgement corresponds to the conclu- sion of the CSL rule.
For Resource, consider a well-formed instance
Γ, r(X): R ▶A {P}C{Q}
Γ ▶A∪X {P ∗ R}resource r in C{Q ∗ R}.
By well-formedness we have free(R) ⊆ X, and mod (C) ⊆ A ∪ X ∪ owned (Γ). We can choose Σj and Δ such that dom(Σj) = A ∪ X, map dom Δ = Γ, and (Σj, Δ)(x)= T for all x in mod (C). We can then split Σj as Σ, Σ0 with dom(Σ0)= X, dom(Σ) = A. Then by the induction hypothesis there is a decoration Cj of C such that such that Σ | Δ, r(Σ0): R ▶ {P}Cj{Q} is provable and matches the CSL assertion Γ, r(X) : R ▶A {P}C{Q}. Using the Reddy Resource rule we can deduce
Σ | Δ ▶ {P ∗ R}resource r(Σ0) in Cj{Q ∗ R},
and since resource r(Σ0) in Cj is a decoration of resource r in C, that completes the proof.
(End of Proof ) The choices of Σ0 and so on in the above proof details are arbitrary up to some explicit constraints on their domains (i.e. on which variables are given a permission)
and the insistence that certain variables get total permission, collectively.
Conclusions
CSL, using rely sets, relaxes the rather stringent syntactic constraints on shared variable usage from Owicki-Gries [8,7]. This logic can handle programs in which shared variables are protected by multiple resources; the inference rules require that a process must acquire all protecting resources before writing a shared variable, and must acquire some protecting resource before reading a shared variable. In Owicki- Gries logic each shared variable was protected by a single resource. The use of rely sets allows us to avoid the need for non-compositional side conditions dealing with “no other process modifies” constraints.
We have demonstrated a strong connection between CSL and Reddy’s logic based on static permissions for variables: each provable judgement in Reddy’s logic corresponds to a provable assertion in CSL, and vice versa. The relationship is asym- metric: in general many Reddy judgements correspond to the same CSL assertion, the differences arising because of arbitrary choices of permission or different dis- tributions of permission among the permission contexts appearing in a judgement. Arguably this abundance of derivations is unattractive: a single proof, without book-keeping concerning arbitrary choices, is preferable to a plethora. This connec- tion also shows that CSL provides a form of syntactic control of interference in the same sense as Reddy’s logic does.
Our analysis, in the proof details that establish the above connection, indicates a systematic strategy for choosing permission contexts to match a given resource

context and rely set while ensuring that all variables written by a program get total permission, starting from a proof for that program in CSL. In contrast the algo- rithm in [9] infers which resources need to protect which identifiers (i.e. discovers a suitable resource context) while looking for permission assignments that ensure that each variable occurrence in the program gets “enough” permission, starting from a putative judgement for that program. Our strategy starts with more information, a proven program rather than a potentially provable program, so solves a simpler problem. It would be interesting to explore the Reynolds algorithm further in the light of our results.
Although Reddy’s logic was originally formulated in [9] with inference rules that deal with decorated commands, our results show that it is possible to dispense entirely with decorations and use Reddy-style rules for undecorated commands, relying instead implicitly on the structure of a derivation to keep track of permission choices. Essentially, the only place where this makes a difference is in the resource rule, which we can replace by
Σ0 ▶ R Assert  Σ | Δ, r(Σ0): R ▶ {P }C{Q}
Σ, Σ0 | Δ ▶ {P ∗ R}resource r in C{Q ∗ R}
The choice of Σ0 to “decorate” the local resource name r in the original Reddy rule does not need to be made explicit here; instead we can infer Σ0 from the premisses. Of course, the cost of doing this would be that the undecorated command is less informative by itself. With this reformulation of Reddy’s logic we would again obtain an analogous connection with CSL: there is a many-one relationship between Reddy derivations and CSL derivations for the same command. This version of Reddy’s logic has the advantage of involving only conventional commands, not decorated commands; consequently we can use conventional semantic models, such as action traces, to establish soundness. In fact it is straightforward, having done this, to combine action trace semantics with permissions [4] and thereby obtain a soundness proof for Reddy’s logic, adjusting the notion of local enabling to manage permissions appropriately. One can also deduce soundness by appealing to the inter-derivability of the two logics, and our existing soundness proof of CSL [5]. Either approach seems simpler than the method of [9], which deals with decorated commands and seeks to generalize action traces by introducing pre-actions, pre-traces, busy markers, and “extended” contexts. We believe it is more natural to work with a semantic model in which logical concepts such as permissions, invariants, protection lists, and decorated commands play no rˆole.
References
R. Bornat, C. Calcagno, P. W. O’Hearn, and M. Parkinson. Permission accounting in separation logic. POPL 2005, SIGPLAN Notices, 40(1), 259-270.
J. Boyland. Checking interference with fractional permissions. Proc. 10th Symposium on Static Analysis, R. Cousot, editor. Springer LNCS vol. 2694, pp. 55-72, 2003.
S. Brookes. A semantics for concurrent separation logic. Invited paper, CONCUR 2004, London. Springer LNCS 3170, August 2004. Journal version in: Theoretical Computer Science, 375(1-3), May 2007.


S. Brookes. Variables as Resource for Shared-Memory Programs: Semantics and Soundness. MFPS 2006, Genova, Italy. ENTCS, Volume 158, 123-150. May 2006
S. Brookes. A Revisionist History of Concurrent Separation Logic. MFPS 2011, Pittsburgh, USA. ENTCS, 2011.
C.A.R. Hoare, Towards a Theory of Parallel Programming. In Operating Systems Techniques, C.
A. R. Hoare and R. H. Perrott, editors, pp. 61-71, Academic Press, 1972.
P. W. O’Hearn. Resources, Concurrency, and Local Reasoning. Invited paper, CONCUR 2004, London. Springer LNCS 3170, pp. 49-67, August 2004. Journal version in: Theoretical Computer Science, 375(1- 3), 271-307, May 2007.
S. Owicki and D. Gries, Verifying properties of parallel programs: An axiomatic approach, Comm. ACM. 19(5):279-285, May 1976.
U. Reddy and J. C. Reynolds. Syntactic Control of Interference for Separation Logic. POPL 2012. January, 2012.
J.C. Reynolds, Separation logic: a logic for shared mutable data structures, Invited paper. Proc. 17th IEEE Conference on Logic in Computer Science, LICS 2002, pp. 55-74. IEEE Computer Society, 2002.
J, C. Reynolds. Invited Talk, MFPS 2011. Pittsburgh, USA, May 2011.
I. Wehrman and J. Berdine. Private communication. January 2011.
