Electronic Notes in Theoretical Computer Science 122 (2005) 105–126 
www.elsevier.com/locate/entcs


Reflection Into Models of Finite Decidable FP-sketches in an Arithmetic Universe
Maria Emilia Maietti
Dipartimento di Matematica Pura ed Applicata University of Padova
via Belzoni n.7, 35100 Padova, Italy
maietti@math.unipd.it

Abstract
We consider finite decidable FP-sketches within an arithmetic universe. By an FP-sketch we mean a sketch with terminal and binary product cones. By an arithmetic universe we mean a list- arithmetic pretopos, which is the general categorical definition we give to the concept of arithmetic universe introduced by Andr`e Joyal to prove G¨odel incompleteness theorems.
Then, for finite decidable FP-sketches we prove a constructive version of Ehresmann-Kennison’s theorem stating that the category of models of finite decidable FP-sketches in an arithmetic universe is reflective in the corresponding category of graph morphisms.
The proof is done by employing the internal dependent type theory of an arithmetic universe.
Keywords: Dependent type theory, categorical logic, pretoposes, sketches, sketch models.

Introduction
In category theory the notion of sketch is the categorical counterpart of the notion of formal deductive system in terms of commented graph. There exist also the corresponding notions of “theory” and “model” in terms of categories and sketch morphisms (see for example [1,5]).
In this paper we consider finite decidable FP-sketches internal to an arith- metic universe. By a FP-sketch we mean a sketch with terminal and binary product cones. By an arithmetic universe we mean a list-arithmetic preto- pos. Indeed, in [9] we proposed the notion of list-arithmetic pretopos as the general categorical definition for the construction of arithmetic universe per- formed by Andr`e Joyal to provide a categorical proof of Go¨del incompleteness


1571-0661 © 2005 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2004.06.054


theorems. This definition is justified in [9] by the fact that Joyal’s universes are in particular list-arithmetic pretoposes and an initial list-arithmetic preto- pos is equivalent to an initial Joyal’s arithmetic universe and also by the fact that in any list-arithmetic pretopos we can build free internal categories and diagrams as in Joyal’s universes (see [10]).
Here we carry on with testing the expressiveness of list-arithmetic preto- poses by proving a constructive version of Ehresmann-Kennison’s theorem for finite decidable FP-sketches, as conjectured by S. Vickers and others working in the field.
Ehresmann-Kennison’s theorem (see [1] page 146) states that the category of models of small sketches, with values in the category Set of ZFC sets, is reflective in the corresponding category of graph morphisms.
Here, we build a reflection of graph morphisms on finite decidable FP- sketches with values in an arithmetic universe into the corresponding category of models.
To define a finite decidable FP-sketch internal to an arithmetic universe and to perform the proof of the reflection we employ an internal language for list-arithmetic pretoposes formulated as a dependent type theory in the style of Martin-L¨of’s type theory (see [8]). This means that we can treat any arithmetic universe as a syntactic category built out of its internal language. For the finite case, the proof we give turns out to be a constructive and predicative formulation of the classical proof regarding models of a small sketch
in Set.
Indeed, the proof in [1] employs Freyd’s adjoint functor theorem and quan- tification over all models, while our proof for finite decidable FP-sketches must use only predicative coherent logic - which does not have implication and universal quantification - together with lists and quotients, namely the only logical and set-theoretic constructors of the internal type theory of an arithmetic universe. The key point in our proof is to perform some inductive definitions to build trees on the arrows of the considered sketch and values of the graph-morphism which must be turned into a model.
The theorem proved here can be extended also to finite decidable lex- sketches by building more complicated trees and can be applied to build the- ories of such sketches as in [1] but considering an arithmetic universe as our set-theoretic universe in place of the category of Sets.
Our ultimate hope is that these results, possibly extended to finite de- cidable lex-sketches with also coproducts, could be useful for applications to database modelling as presented in [6]. The reason is that working within an intuitionistic predicative universe as our set-theoretic universe forces us to perform more effective constructions based on more elementary properties

than working within the category of Sets.

Sketches and models within an arithmetic universe
We recall the definition of arithmetic universe from [9].
Definition 2.1 An arithmetic universe 1 is a list-arithmetic pretopos, that is a pretopos (see also [14], [4]) with parameterized list objects (see also [2]).
In [8] we proved that the dependent typed calculus Au formulated in the style of Martin-L¨of’s type theory (see the appendix) provides an internal lan- guage for list-arithmetic pretoposes, that is for arithmetic universes.
In few words this internal language for arithmetic universes corresponds to predicative coherent logic equipped with the set-theoretic constructions of lists and quotients. With respect to intuitionistic logic, predicative coherent logic lacks of implication and universal quantification, namely it has only conjunction, falsum, disjunction and existential quantification.
From [10] we recall that an arithmetic universe has also coequalizers:
Proposition 2.2 In any list-arithmetic pretopos U there exists the coequalizer of any two given morphisms.
From the type-theoretic or logical point of view this proposition says that in the dependent typed calculus Au for arithmetic universes we can define the quotient type on any relation that is not necessarily an equivalence relation. We will make use of this property quite often in the constructions performed in this paper.
Given an arithmetic universe U we will introduce the notion of finite decid- able FP-sketch internally to U by using the typed calculus Au of the appendix. A generic sketch is a graph with a set of identities, of diagrams, of cones and of cocones (for a general account on sketches and their models we refer
to [1,5].)
The notion of sketch is the categorical counterpart of the notion of formal deductive system in terms of commented graph. By means of sketches we can specify algebraic structures like monoids, groups, rings in a categorical way.
Here, we restrict our attentions to finite sketches with terminal and binary product cones and no cocones, called finite FP-sketches. Actually we use the same terminology as for sketches with finite product cones, not necessarily only binaries, since we can always define a finite product cone through binary ones. Since by a finite set we mean a set in a bijective correspondence with the set

1 Note that in [18] an apparently weaker general categorical definition of arithmetic universe is used.


of natural numbers minor to a given natural number, our notion of finiteness within an arithmetic universe implies the decidability of the equality of the elements of our finite set and this is why we add the adjective “decidable”.
Before starting to give the needed definitions about sketches, we make the following remarks.
Remark 2.3 By means of the internal language Au, we identify an object A of an arithmetic universe U with a type A and a morphism f : A → B in U with a term f (x) ∈ B [x ∈ A]. Conversely, any closed type built out of the rules of Au in the appendix denotes an object of U and any term of the form f (x) ∈ B [x ∈ A], with A, B closed types, denotes a morphism of U. For a more precise correspondence between categories and type theories see [8].
Remark 2.4 By means of the internal language we can prove that a mor- phism f : A → B of U is monic if and only if we can derive a proof of the type
x =A y [x ∈ A, y ∈ A, z ∈ f (x) =B f (y)]
where x =A y [x ∈ A, y ∈ A] stands for the equality type Eq(A, x, y) in the appendix.
Definition 2.5 We say that two types A, B in the internal language of U are isomorphic, indicated with A  B, if there exist two terms f (x) ∈ B [x ∈ A] and g(y) ∈ A [y ∈ B] such that we can derive a proof of g(f (x)) =A x [x ∈ A] and a proof of f (g(y)) =A y [y ∈ A]
Definition 2.6 A finite decidable FP-sketch S ≡ (G, Diag, ConFP ) in- ternal to the arithmetic universe U is given with following data:
a graph G ≡ (G0, G1, δo, δ1) in U, that is G0 and G1 are two objects of U, denoting respectively the set of objects and of arrows, with δo and δ1 morphisms of U, denoting respectively the domain and codomain maps

  δo  
G1 	 G0 
δ1

such that there exists two natural numbers n0, n1 for which we can prove that the graph is finite (and hence decidable) in the sense that
G0  Σx∈N x ≤ n0	G1  Σx∈N x ≤ n1

a monic unit map sending any object into its unit arrow
id(−) : G0   G1 
a set of diagrams given by a mono
Diag : D 0   Σz ∈Cat(G)1×Cat(G)1 δb0 (π1(z)) =G0 δb0 (π2(z)) × δb1 (π1(z)) =G0 δb1 (π2(z))


where Cat(G) is the free category generated from the graph G defined as

in [10] with δ^ , δ^ : Cat(G) → Cat(G)
the domain and codomain maps;

a set of terminal and product cones described by ConFP ≡ (V, ν, conFP ) where V is the set of vertexes of the product and terminal cones and ν is a morphism
ν : V 	 G0 
mapping the cone vertexes into objects of the graph and the cones on any v ∈ V are described by
conFP (v) ∈ ( Σf1 ∈G1 Σf2 ∈G1  δ0 (f1) =G0 ν(v) × δ0 (f2) =G0 ν(v)) ⊕ T 
Remark 2.7 In the following, for simplicity, we suppose that V ≡ T ⊕ P
with
conFP (inl(∗)) ≡ inr(∗)	conFP (inr(p)) ≡ inl(< πa(p),< πb(p),< eq, eq >>)
with a(p) = δ1(πa(p)) and b(p) = δ1(πb(p)). We will also use the following abbreviations: vt ≡ inl(∗) and vp ≡ inr(p).
We can consider graph-morphisms (see [1,5]) from the internal sketch S to the underlying sketch of the arithmetic universe U itself by means of internal diagrams on the graph of S:
Definition 2.8 A graph morphism on a finite decidable FP-sketch S ≡ (G, Diag, ConFP ) in U, indicated with F : S → U , is an internal diagram on the internal graph G in U (for a categorical definition see for example [10]), that is in the internal language of U we can derive a dependent type F0(x) [x ∈ G0] and a typed term
F1 (f )(z) ∈ F0(y)
[f ∈ G1 , x ∈ G0 , z ∈ F0(x), y ∈ G0, z' ∈ x =G0 δ0 (f ), z'' ∈ y =G0 δ1 (f )]
describing a graph-morphism from the underlying graph of the sketch to that of the arithmetic universe sending objects to objects, arrows to arrows in a way as to preserve their domain and codomain.
Definition 2.9 Given a finite decidable FP-sketch S ≡ (G, Diag, ConFP ) in U, a natural transformation α : F → H from the graph morphism F : S → U to the graph morphism H : S → U in U is given by a term
αx(z) ∈ H0(x) [x ∈ G0,z ∈ F0(x)] such that we can prove that
H1(f )(αx(z)) =H0 (y) αy(F1(f )(z))
[x ∈ G0 , y ∈ G0 , f ∈ G1 , z ∈ F0(x), z' ∈ x =G0 δ0 (f ), z'' ∈ y =G0 δ1 (f )]
Now, we introduce the concept of a model for a FP-sketch in the arithmetic universe U.


Definition 2.10 A model for a FP-sketch S ≡ (G, Diag, ConFP ) in the arithmetic universe U is a graph-morphism M : S → U in U represented by M0(x) [x ∈ G0] and a typed term M1(f )(z) ∈ M0(y) [f ∈ G1,x ∈ G0,z ∈ M0(x),y ∈ G0, z' ∈ x =G δ0(f ), z'' ∈ y =G δ1(f )] such that
unit maps of S are sent to the corresponding unit maps of U, that is we can derive a proof of
M1(idx)(z) =M0(x) z [x ∈ G0,z ∈ M0(x)]
diagrams of S are sent to commutative diagrams in U, that is we can derive a proof of
Mf1(π1(Diag(d))) =M0 (δc1 (π1(Diag(d)))) Mf1 (π2(Diag(d))) [d ∈ D0]


where M˜ is the free internal categorical diagram 2 generated from M on the free internal category Cat(S) generated from the sketch graph G (for the construction of the free internal categorical diagram M˜ see [10]);
cones of S are sent to cone limits in U, that is , if V ≡ T ⊕ P as in remark 2.7, then M0(ν(vt))) is isomorphic to the terminal object T and for every p ∈ P then M0(ν(vp)) is isomorphic to M0(a(p)) × M0(b(p)) and if f (z) ∈ M0(ν(vp)) [z ∈ M0(a(p)) × M0(b(p))] is the isomorphism then we derive a proof of
M1(πa(p))(f (z)) =M0 (a(p)) π1(z) [p ∈ P, z ∈ M0(a(p)) × M0(b(p))]
and a proof of
M1(πb(p))(f (z)) =M0 (b(p)) π2(z) [p ∈ P, z ∈ M0(a(p)) × M0(b(p))]
that is projections are sent to projections.
Now we give the definitions of the category of graph-morphisms and of models
into an arithmetic universe. For what follows we assume that S ≡ (G, Diag, ConFP ) is a finite decidable FP-sketch in U.
Definition 2.11 US is the category of graph morphisms F : S → U as objects and natural transformations as morphisms with the obvious composition and units.
Then we define the category of graph morphisms preserving the diagrams:

2 For the definition of internal categorical diagrams on an internal category see, for example, page 242 of [12], where they are simply called internal diagrams. Here, we add the adjective “categorical” to distinguish internal categorical diagrams on a category preserving units and its internal composition from internal diagrams on the underlying graph.


Definition 2.12 D(S, U) is the full subcategory of the category US with graph morphisms sending diagrams of the sketch into commutative diagrams of U and units to units as in point (i) and (ii) of definition 2.10.
Definition 2.13 Mod(S, U) is the full subcategory of the category US with models for the decidable finite FP-sketch S in the arithmetic universe U.
At this point note that working with graph morphisms on an internal graph is not much different than working with the corresponding internal categorical diagrams on the free category generated from the graph sending units to units and preserving the internal composition. Indeed, thanks to the fact (shown in [10]) that any graph morphism on a internal graph G gives rise to a free internal categorical diagram on the category Cat(G), we can easily prove that:

Proposition 2.14 The category of graph morphisms U S is equivalent to the category of internal categorical diagrams on Cat(S) in U .

The reflection
Here, we will introduce all the constructions necessary to prove our main theorem, namely that given a finite decidable FP-sketch S, there exists a reflection of US into Mod(S, U).
This result will be reached in three steps:
first we observe that D(S, U) is reflective into US;
then we prove that Mod(S, U) is reflective into D(S, U), which is the hard part 3 ;
finally, we compose the two reflections to obtained the claimed reflection of US into Mod(S, U).
Here is the first step.
Proposition 3.1 Given a FP-sketch S, the inclusion functor
I : D(S, U) → US
has got a left adjoint.
Proof. The construction of the left adjoint is done by mimicking the usual set-theoretic construction. To each graph morphism F we associate the graph

3 This reflection corresponds to Ehresmann-Kennison’s theorem in [1] for sketches in Set, since in [1] graph morphisms are supposed to preserve also the specific diagrams of the considered sketch and their units. Here, we prefer to call graph morphisms those diagrams that just preserve the graph structure as in def. 2.8.


morphism F˜ defined on each object x ∈ G0 by coequalizing the morphisms obtained by applying F to all the pairs of composable sequences of morphisms in the sketch diagrams or in the unit diagrams possibly extended by composing them with a sequence of morphisms with codomain x. Such an object F˜(x) can be built thanks to prop 2.2.	 
In order to perform the second step, namely to prove the reflection of D(S, U) into Mod(S, U) we need to build some inductive types inside U, which are partly based on sequences of composable arrows of S quotiented under the diagrams.
Therefore, we will work with the smallest category making the diagrams of S commute. This is obtained by quotienting the morphisms Cat(S)1 of the free category Cat(S) generated by the sketch graph G (described in [10]) under the diagrams of S, which is possible thanks to prop 2.2.
Proposition 3.2 In U we can deﬁne the quotient category
D1 ≡ (Cat(S)1/Diag∗)	and	D0 ≡ G0
where Diag∗ is deﬁned as the union of the sketch diagrams indexed by Diag with the diagrams identifying the identities in Cat(S) with the sketch identi- ties. We denote with [−]: S → Cat(S)/Diag∗ the graph morphism projecting the sketch into the category.
Warning on notation. Note that in the following, in order to make the formulas more readable, we will use the abbreviations: for a, b ∈ G0
D1 (a, b) ≡ Σx∈D1 δ0(x) =G0 a × δ1(x) =G0 b
and given f ∈ G1 we will simply write
f ∈ D1 (a, b)	instead of	< [f ],< eq, eq >>∈ D1 (a, b)



The construction of trees
In this section we describe the construction of trees that we will use to build a model for a finite decidable FP-sketch starting from a graph morphism on the considered sketch. The trees are made up of the following ingredients:
composable sequences of morphisms of the given finite decidable FP- sketch S internal to U;
values of a graph morphism F : S → U in D(S, U) applied to a sketch object.
In the following we will often use the notation F (x) on an object x ∈ G0
or F (f ) on an arrow f ∈ G1 instead of writing F0(x) or F1(f ).

The idea
The basic idea is to be able to build a model F^ out of a graph morphism F : S → U. Let us start by considering to have a sketch with only a terminal cone with vertex ν(vt) ∈ G0. Therefore we expect to define a unit η : F → F^.

Since we know that
F^(ν(vt)) must be a terminal object, for simplicity we

suppose F^(ν(vt)) ≡ T. Then, the unit naturality diagram for an arrow ending in the terminal vertex trivially commutes. Instead, if we consider an arrow like g : ν(vt) → a in G1, then from the commutativity of the following diagram


F (ν(vt)) η
 T 

F (g)
ν(vt )
J 
JFb( g)

F (a)	ηa	 Fb( a)

we get that F^(a) must be something like the push-out of the diagram, that is
F^(a) ≡ (F (a) ⊕ D1(ν(vt), a))/Rel

where Rel must include that F (g)(y) for y ∈ F (ν(vt)) is in relation with g. In this case we put F^(g)(∗) ≡ [inr(g)] and ηa(x) ≡ [inl(x)] for x ∈ F (a) (where inr and inl are the injections in the sum type in the appendix).
Then, consider a sketch with a product cone of vertex c × d and an arrow g : c × d → a and suppose for simplicity that F^(c × d) = F^(c) × F^(d) and that ην(c×d) ≡ ηc × ηd· < F (πc),F (πd) >. Then, from the commutativity of the diagram
F (c×d) η	 Fb( c)×Fb(d)

F (g) J 
ν(c×d)
JFb( g)

F (a)	ηa	 Fb( a)
recalling that F^(c) must include F (c) ⊕ D1(ν(vt), c))/Rel and F^(d) must in- clude F (d) ⊕ D1(ν(vt), d))/Rel, we conclude that F^(a) must include all the combinations of the product of each member of F^(c) with each member of
F^(d). Hence, F^(a) must include not only F (a) but, for example, also ele-
ments < (x, y),g > with x ∈ F (c) and y ∈ F (d). In this case, in order to make the diagram commute, the element < (F (πa(p))(z),F (πb(p))(z)),g > has to be put in relation with any F (g)(z) for z ∈ F (c × d). Moreover, F^(a) must include < (x, f2),g > with x ∈ F (a(p)) and f2 : ν(vt) → d, or < (f1, y),g > with y ∈ F (b(p)) and f1 : ν(vt) → c, or < (f1, f2),g > with f1 : ν(vt) → c and f2 : ν(vt) → d. These observations inspired us to define F^(a) by means of trees made up of sketch arrows and values of the graph morphism F on a sketch object. The trees are inductively generated as follows. An element ∗


of the terminal object T is a base tree of vertex v ≡ vt
(∗)
and also a couple
(x, y)
with x ∈ F (a(p)) and y ∈ F (b(p)) is a base tree with vertex v ≡ vp. Then, we may extend a tree w with vertex v with an arrow f : v → a(p) to form a left branch of a new tree, whose right branch may be simply some y ∈ F (b(p)), like
w,,zz
g	y
or we may extend the tree w with vertex v with an arrow f : v → a(p) to form a left branch of a new tree, whose right branch is another tree w' with vertex v' extended with an arrow g : v' → b(p), like
w	w'
f v ,gzs
or we may extend the given tree w with vertex v with an arrow g : v → b(p) to form a right branch of a new tree, whose left branch may be simply some x ∈ F (b(p)), like
w
x  cgjc
One of the resulting trees may be



∗
,	x3
(x2,y2 )
2
 c jc

f1 ,t, \fs 
¸¸¸z 
h	y
In the case F ≡ M is already a model, then this tree with vertex p corresponds to the point of M(p)
< M(h)(z1),y >
where z1 =< M(f1)(∗),M(f3)(z2) > - with ∗ the unique element in the ter- minal object M(ν(vt)) - and z2 =< x3,M(f2)(< x2, y2 >) >. In practice with such trees we keep trace of points and arrows which could be applied properly to get a point if the given graph morphism F were a model.
Trees and related relations
Here, we show how to build the needed trees internally to an arithmetic uni- verse. Although we do not have types of well-founded trees [15] in the calculus


Au for arithmetic universes, by making an essential use of lists we can define some useful inductive types, as shown in the following proposition, to meet our purpose. Recall that N type is the type of natural numbers.
Proposition 3.3 In the internal type theory of the arithmetic universe U we can deﬁne a type
Σn∈N R(n, s) type [s ∈ S]
provided that R(0, s) type [s ∈ S] is derivable in the calculus and that
R(n + 1, s) ≡ Σs'∈S R(n, s ) & H(s , s)
for s ∈ S, n ∈ N where H(s', s) type [s ∈, s' ∈ S] is derivable in the calculus.
Moreover, we can argue by induction on the type according to the following elimination and conversion rules:
C(s, z) type	[s ∈ S, z ∈ Σn∈N R(n, s)]
co(s, d) ∈ C(s, < 0,d >)	[s ∈ S, d ∈ R(0, s)]
c1 (s, s', z', h, u) ∈ C(s, < n + 1,< s',< z', h >>>)
[s ∈ S, s' ∈ S, n ∈ N, z' ∈ R(n, s'),h ∈ H(s', s),u ∈ C(s',< n,z' >)]
E)
El(c0 , c1 , s, z) ∈ C(s, z)	[s ∈ S, z ∈ Σn∈N R(n, s)]

El(c0 , c1 , s,< 0,d >) = c0 (s, d) ∈ C(s, < 0,d >)

El(c0 , c1 , s,< n + 1,< s',< z', h >>>) = c1 (s, s', z', h, El(c0, c1, s',< n,z' >))
∈ C(s, < n + 1,< s',< z', h >>>)

Proof. The candidate type is
R(0, s) ⊕  ( Σw∈List∗(Σx∈S Σy∈S H(x,y))	R(0, π˜1(p1(w)) ) & π˜2(plh(w)(w)) =S s
&	π1(front(w)) =List(Σx∈S Σy∈S H(x,y)) π2(back(w)) )
where in general List∗(A) denotes the type of non-empty lists of A, pn(w) is the projection of the n-th element of the list w, lh(w) is the length of the
list w, π1 is the lifting on lists of the first projection π˜1(z) ≡ π1(z) ∈ S
for z ∈ Σx∈S Σy∈S H(x, y), π2 is the lifting on lists of the second projection π˜2(z) ≡ π1(π2(z)) ∈ S for z ∈ Σx∈S Σy∈S H(x, y) and front(w) takes out the first element from the list w by leaving the front of the list, while back(w) takes out the last element from the list w by leaving the remaining tail. 
Thanks to prop. 3.3 we can prove:
Lemma 3.4 (Trees) In the internal type theory of U we can deﬁne a type
Tree(F, v) [v ∈ V ]


with the following introduction rules to form its terms:
(∗) ∈ Tree(F, vt)

p ∈ P	x ∈ F0(a(p))	y ∈ F0(b(p))
(x, y) ∈ Tree(F, vp)
v ∈ V	p ∈ P  x ∈ F0(a(p)) w ∈ Tree(F, v) f ∈ D1 (ν(v), b(p)) (x, w/f ) ∈ Tree(F, vp )
v ∈ V	p ∈ P  w ∈ Tree(F, v) f ∈ D1 (ν(v), a(p)) y ∈ F0 (b(p)) (w/f, y) ∈ Tree(F, vp)
v1 ∈ V	v2 ∈ V	p ∈ P  w1 ∈ Tree(F, v1 ) w2 ∈ Tree(F, v2 ) f1 ∈ D1 (ν(v1), a(p))	f2 ∈ D1 (ν(v2 ), b(p))

(w1/f1 , w2 /f2 ) ∈ Tree(F, vp)
Moreover, on this type we can argue by induction thanks to the corresponding elimination and conversion rules formulated according to the style of Martin- Lof ’s type theory [15] as in prop. 3.3.
Then, always thanks to prop. 3.3, we can define a type containing branches of the defined trees possibly extended with arrows ending on any object of the sketch or simply values of F on a sketch object.
Lemma 3.5 (Extended branches) In the internal type theory of U we can deﬁne a type
Bran(F, x) [x ∈ G0]
with the following introduction rules to form its terms:
x ∈ G0  u ∈ F0(x)
/u ∈ Bran(F, x)
x ∈ G0 v ∈ V	w ∈ Tree(F, v) f ∈ D1(ν(v), x) w/f ∈ Bran(F, x)
Moreover, on this type we can argue by induction thanks to the corresponding elimination and conversion rules formulated in the style of Martin-L¨of ’s type theory [15] as in prop. 3.3.
In addition we can define an operation composing a left branch with an appropriate right branch to form a tree:
Lemma 3.6 In the internal type theory of U we can deﬁne an operation
(z1, z2) ∈ Tree(F, vp ) [p ∈ P, z1 ∈ Bran(F, a(p)), z2 ∈ Bran(F, b(p))]
such that for any p ∈ P and any tree w ∈ Tree(F, vp) we can derive a proof of
Σz1 ∈Bran(F,a(p)) Σz2 ∈Bran(F,b(p)) (z1, z2) =Tree(F,vp) w
Then, always thanks to prop. 3.3, we define a relation on branches which will help to properly define the reflector:


Lemma 3.7 (Branches relation) In the internal type theory of U we can deﬁne the inductive type
z1  Bran(F ) z2 [x ∈ G0, z1 ∈ Bran(F, x), z2 ∈ Bran(F, x)]
whose formation rules are the following:


Ter
	y ∈ F0(ν(vt))	

1	(∗)/id
ν(vt)
Bran(F ) y


v ∈ V	w ∈ Tree(F, v)  f1 ∈ D1 (ν(v),ν(vt))

Ter2
w/f1
Bran(F )
(∗)/id
ν(vt)



Prod1
p ∈ P	bl ∈ Bran(F, a(p))	br ∈ Bran(F, b(p)) (bl, br)/πa(p) Bran(F ) bl



Prod2
p ∈ P	bl ∈ Bran(F, a(p))	br ∈ Bran(F, b(p)) (bl, br)/πb(p) Bran(F ) br


p ∈ P	u ∈ F0(ν(vp))

Prod3
(F1 (π

a(p)
)(u), F1 (π

b(p)
)(u))/id
ν(vp)
Bran(F ) u



Prod4
v ∈ V	w ∈ Tree(F, v)	p ∈ P	g ∈ D1 (ν(v),ν(vp)) ( w/(πa(p) · g) , w/(πb(p) · g) )/idν(vp) Bran(F ) w/g



p ∈ P	bl ∈ Bran(F, a(p))		bl' ∈ Bran(F, a(p))	br ∈ Bran(F, b(p)) x ∈ G0		f ∈ D1(ν(vp), x)	bl Bran(F ) bl'

Prod5
(bl, br)/f 

Bran(F )
(bl', br)/f




p ∈ P	bl ∈ Bran(F, a(p))		br ∈ Bran(F, b(p))	br' ∈ Bran(F, b(p)) x ∈ G0		f ∈ D1(ν(vp), x)	br Bran(F ) br'

Prod6
(bl, br)/f 

Bran(F )
(bl, br')/f



v ∈ V	w ∈ Tree(F, v)	x ∈ G0		x' ∈ G0	u ∈ F0 (x') f ∈ D1(ν(v), x')	h ∈ D1(x', x)	w/f Bran(F ) u

Comp1
w/h · f 

Bran(F )
F1(h)(u)



v1 ∈ V	w1 ∈ Tree(F, v1 )	v2 ∈ V	w2 ∈ Tree(F, v2 )	x' ∈ G0	x ∈ G0 f1 ∈ D1(ν(v1), x')	f2 ∈ D1(ν(v2), x')	 h ∈ D1(x', x)	w1/f1  Bran(F ) w2/f2

Comp2
w /h · f
w /h · f

1	1  Bran(F )  2	2
Moreover, on this type we can argue by induction thanks to the corresponding elimination and conversion rules formulated in the style of prop. 3.3.


Now, to define the object part of the reflector, we use the type T (F )(x) of extended trees on any x ∈ G0 defined as the coproduct of trees extended with a sketch arrow with a copy of F0(x):
T (F )(x) ≡ F0(x) ⊕ Σv∈V Tree(F, v) × D1 (ν(v), x)
Note that in the following we will use this abbreviation: for x ∈ G0, v ∈
V, w ∈ Tree(F, v), f ∈ D1(ν(v), x)
< v, w,f >≡< v, < w, f >>∈ Σv∈V Tree(F, v) × D1 (ν(v), x)


Then, on the extended trees we define a relation based on the branches rela- tion:
Definition 3.8 [Extended trees relation] In the internal language of U we define the type
z	z' [x ∈ G0 ,z ∈ T (F )(x),z' ∈ T (F )(x)]
as follows: for x ∈ G0,z ∈ T (F )(x), z' ∈ T (F )(x)
z  T (F ) z' ≡	( Σu∈F (x) z =T (F )(x) [inl(u)]

&  Σv∈V Σw∈Tree(F,v) Σf ∈D (ν(v),x)  z' =T (F )(x) [inr(< v, w,f >)]

&  w/f  Bran(F ) u )
⊕

( Σv1 ∈V Σv2 ∈V Σw1 ∈Tree(F,v1) Σw2 ∈Tree(F,v2) Σf1 ∈D1(ν(v1 ),x) Σf2∈D1(ν(v2 ),x)

z =T (F )(x) [inr(< v1, w1, f1 >)]  &  z' =T (F )(x) [inr(< v2, w2, f2 >)] &	w1 /f1 Bran(F ) w2 /f2 )
The reflector
The definition of the reflector functor (ˆ−) : D(S, U) → Mod(S, U) is the following. For any graph morphism F : S → U in D(S, U) we put:
Definition 3.9 [F^ on objects] For every x ∈ G0 we define


Fb0 (x) ≡
F0(x) ⊕ Σv∈V Tree(F, v) × D1 (ν(v), x)

 

T (F )
Definition 3.10 [F^ on morphisms] For any g ∈ G1 such that δ0(g)= x ∈ G0
and δ1(g)= y ∈ G0 we define
F^ (g): F^ (x) −→ F^ (y)
1	0	0


by the elimination rule on the quotient type F^ (x): for every z ∈ T (F )(x)
8[inl(F1 (g)(y))]	if z = inl(y) for y ∈ F0 (x)
Fb1 (g)([z]) ≡  [inr(< v, w,g · f >)]  if z = inr(< v, w,f >) for v ∈ V
>:	w ∈ Tree(F, v) and f ∈ D1 (ν(v), x)
Definition 3.11 [(ˆ−) on natural transformations] Given a natural transfor- mation α : F −→ H in D(S, U) we define a natural transformation
α^ : F^ −→ H^
in Mod(S, U) by making use of the following term
α˜(w) ∈ Tree(H, v) [v ∈ V, w ∈ Tree(F, v)] defined by induction on the tree w as follows:


>  a(p)	b(p)	0	0
(α	(x),α	(y))	if w = (x, y) for x ∈ F (a(p)), y ∈ F (b(p)) and p ∈ P


α(w) ≡ ><
>
w' ∈ Tree(F, v) and h ∈ D1 (ν(v), b(p))
'

>(αe(w )/h, αb(p)(y))	if w = (w /h, y) for y ∈ F0(b(p)) and v ∈ V and p ∈ P
w' ∈ Tree(F, v) and h ∈ D1 (ν(v), a(p))
>

>	1	1	1	2
1  1	2  2	1	2

>(αe(w )/h , αe(w )/h )	if w = (w /h ,w /h ) and v ∈ V , v ∈ V and p ∈ P
w1 ∈ Tree(F, v1 ) and h1 ∈ D1 (ν(v1), a(p))
:	w2 ∈ Tree(F, v2 ) and h2 ∈ D1 (ν(v2), b(p))
Then we are ready to define α^ whose component on x ∈ G0 is
(α^)x : F^ (x) −→ H^ (x)


defined by the elimination rule on the quotient type
T (F )(x)
F^(x): for every z ∈

8><[inl(αx(y))]	if z = inl(y) for y ∈ F0(x)
>:	w ∈ Tree(F, v) and f ∈ D1(ν(v), x)

Lemma 3.12
F^ is a model for the ﬁnite decidable FP-sketch S in U .

Proof. To show our statement is crucial to use the relation  Bran(F ) defined in lemma 3.7 on which the relation  T (F ) used in the definition of the object part of F^ is based.

Just note that F^ is a well defined graph morphism thanks to Comp1, Comp2
of  Bran(F ) in lemma 3.7, that F^ (ν(v )) is a product for p ∈ P and that

F^ (π	) and F^ (π	) are projections thanks to Prod
for i = 1, .., 6 and

1	a(p)	1	b(p)	i
Compi for i = 1, 2 of  Bran(F ) in lemma 3.7, and that F^ (ν(vt)) is isomorphic to T thanks to Ter1, Ter2 of  Bran(F ) in lemma 3.7.	 

Finally, we define the candidate to be the unit of the reflection as follows:


Definition 3.13 [Unit] Given a graph morphism F : S → U in D(S, U), we define a natural transformation

ηF : F −→ F^

whose component (ηF )x : F0(x) −→ F^ (x) on x ∈ G0 is defined as follows: for
every z ∈ F0(x)

(ηF )x(z) ≡ [inl(z)]


Then we define the candidate to be the counit of the adjunction.

Definition 3.14 [Counit] Given a model M ∈ Mod(S, U) we define the counit as a natural transformation

εM : M^ −→ M

by making use of the term


Ap(M )(w) ∈ M0 (ν(v)) [v ∈ V, w ∈ Tree(M, v)]



defined by induction on the tree w as follows:



⎧⎪∗M	if w = (∗)

with x ∈ M0(a(p)) and y ∈ M0(b(p))
⎪	for p ∈ P
⎪







Ap(M )(w) ≡
⎪
⎪
⎪⎪⎨
with x ∈ M0(a(p)) and w′ ∈ T ree(M, v) and h ∈ D1(ν(v), b(p))
for v ∈ V , p ∈ P

with y ∈ M0(b(p)) and w′ ∈ T ree(M, v)
and h ∈ D1(ν(v), a(p))
⎪	for v ∈ V , p ∈ P
⎪

1  1	1	1  2	2
⎪
1	1	2	2

with w1 ∈ T ree(M, v1)
and h1 ∈ D1(ν(v1), a(p)) and w2 ∈ T ree(M, v2) and h2 ∈ D1(ν(v2), b(p))
⎩	for v1 ∈ V , v2 ∈ V , p ∈ P
where ∗M is the unique element in M0(ν(vt)), which must be a terminal object in U.
For every x ∈ G0 we define
(εM )x : M^ (x) −→ M (x)
by the elimination rule on the quotient type M^ (x): for every z ∈ T (M)(x)
8y	if z = inl(y) for y ∈ M (x)
(εM )x([z]) ≡ <M (f )(Ap(M )(w))  if z = inr(< v, w,f >)
>:	for v ∈ V , w ∈ Tree(M, v) and f ∈ D1 (ν(v), x)
With all these definitions we conclude
Theorem 3.15 Given a ﬁnite decidable FP-sketch S, the inclusion functor
J : Mod(S, U) → D(S, U) has got the functor
(ˆ−): D(S, U) → Mod(S, U)

as left adjoint.
Proof. Note that to prove the triangular identity (εFb)x · (η^F )x = idFb0(x) for any F graph-morphism in D(S, U) and x ∈ G0, we need to derive for x ∈ G0,v ∈ V, w ∈ Tree(F, v),f ∈ D1(ν(v), x)
Fb1 (f ) · Ap(Fb)(ηfF (w)) =Fb0 (x) [inr < v, w, f >]
To derive a proof of this type we make use of the decidable finiteness of the sketch to be able to perform an induction on the tree w by including the quantification of all the suitable arrows of G1. The induction on the tree w ∈ Tree(F, v) is performed with respect to the type

C(w) ≡ Σl∈List(B) (π1 (l) =List(G1 ) g0 g1...gn1 )
where
B ≡ Σf∈G1 ( (δ0(f ) = ν(v) & Fb1(f ) · Ap(Fb)(ηfF (w)) =Fb0 (x) [inr < v, w, f >]) ⊕ δ0(f ) /= ν(v)) 
and π1 is the lifting of the first projection on lists, and g0g1...gn1 is the list of all the arrows in G1, and δ0(f ) /= ν(v) is defined thanks to the decidability of the sketch.	 
Finally as a corollary we get our main theorem:
Corollary 3.16 Given a ﬁnite decidable FP-sketch S, the inclusion functor
I : Mod(S, U) → US
has got a left adjoint.
Proof. We consider
Mod(S, U)	,˛I   D(S, U)	,˛J   US
and by prop 3.1 and theorem 3.15 the functor I = J ·I has got a left adjoint. 

Conclusions
An analogous reflection can be proved also for finite decidable lex-sketches internal to an arithmetic universe by building more complicated trees. Cer- tainly, we can investigate the existence of the reflection for a wider class of finite product sketches within an arithmetic universe or variations of it. We think that within a locally closed arithmetic universe the reflection should hold for generic internal finite product sketches, since in this paper the property of decidable finiteness of the sketch was essentially used just to quantify over a subset of sketch arrows.


These reflections could be used to build theories of the considered sketches as in [1] but considering an arithmetic universe as our set-theoretic universe in place of the category of Sets. On this point, we also want to explore the applicability of the techniques developed in [7].
In the future we hope to get similar results for finite decidable lex sketches with also coproduct cocones, always by taking, as our set-theoretic universe, an arithmetic universe or some other predicative variations of it. Indeed, we ultimately hope that this kind of results for finite decidable sketches could be useful for applications to database modelling as presented in [6], because work- ing within an intuitionistic predicative universe forces us to perform more ef- fective constructions based on more elementary properties than working within the category of Sets.

Acknowledgement
My acknowledgements go first to Martin Hyland, who proposed me the topic treated here and helped me with many fruitful discussions during my staying in Cambridge. Many thanks also to Steve Vickers, for providing me Gavin Wraith’s unpublished notes with the masterthesis of his student [13] to work at his conjecture and to Peter Johnstone for some helpful discussions. Finally, I wish to thank Pino Rosolini and Silvio Valentini for their constant generous promptness in discussing my research work.

References
M. Barr and C. Wells. Toposes, triples and theories., volume 278 of A Series of Comprehensive Studies in Mathematics. Springer Verlag, Berlin, 1985.
J.R.B. Cockett. List-arithmetic distributive categories: locoi. Journal of Pure and Applied Algebra, 66:1–29, 1990.
N.G. de Bruijn. Telescopic mapping in typed lambda calculus. Information and Computation, 91:189–204, 1991.
A. Joyal and I. Moerdijk. Algebraic set theory, volume 220 of Lecture Note Series. Cambridge University Press, 1995.
P. T. Johnstone. Sketches of an elephant: a topos theory compendium. Vol. 2., volume 43 of
Oxford Logic Guides. The Clarendon Press, Oxford University Press, New York,, 2002.
M. Johnson, R. Rosebrugh, and R. Wood. Entity relationship attribute designs and sketches.
Theory and Application of Categories, 10:94–112, 2002.
Y. Kinoshita, J. Power, and M. Takeyama. Sketches. J. Pure Appl. Algebra, 143:275–291, 1999. Special volume on the occasion of the 60th birthday of Professor Michael Barr (Montreal, QC, 1997).

M.E. Maietti. Modular correspondence between dependent type theories and categorical universes. Mittag-Leﬄer Preprint Series, 44, 2001.



M.E. Maietti. Joyal’s arithmetic universes via type theory. In Category Theory in Computer Science, 2002, volume 69 of Elettronic Notes in Theoretical Computer Science. Elsevier, 2002.
M.E. Maietti. Joyal’s arithmetic universe as list-arithmetic pretopos. See
http://www.math.unipd.it/~maietti/pubb.html , 2004.
P. Martin-Lo¨f. Intuitionistic Type Theory, notes by G. Sambin of a series of lectures given in Padua, June 1980. Bibliopolis, Naples, 1984.
S. MacLane and I. Moerdijk. Sheaves in Geometry and Logic. A ﬁrst introduction to Topos theory. Springer Verlag, 1992.
A. Morrison. Reasoning in arithmetic universes. Master’s thesis, University of London - Imperial College of Science, Technology and Medicine, Advisor: S. Vickers, September 1996.
M. Makkai and G. Reyes. First order categorical logic., volume 611 of Lecture Notes in Mathematics. Springer Verlag, 1977.
B. Nordstr¨om, K. Petersson, and J. Smith.  Programming in Martin Lo¨f ’s Type Theory.
Clarendon Press, Oxford, 1990.
A.M. Pitts. Categorical logic. In Oxford University Press, editor, Handbook of Logic in Computer Science, volume 5, pages 39–128, 2000.
Th. Streicher. Semantics of type theory. Birkha¨user, 1991.
P. Taylor. Inside every model of Abstract Stone Duality lies an Arithmetic Universe. In this volume. 2004.


A	The internal dependent type theory of arithmetic universes
Here, we recall the description of the typed calculus Au which provides the internal languages for arithmetic universes, that is list-arithmetic pretoposes, as proved in [8]. The calculus is equipped with types, which should be thought of as sets or data types, and with typed terms which represent proofs of the types to which they belong.
In the style of Martin-Lo¨f’s type theory [15], we have four kinds of judgements:
A type [Γ]	A = B [Γ]	a ∈ A [Γ]	a = b ∈ A [Γ]
that is the type judgement, the equality between types, the term judgement and the equality between terms of the same type. The contexts Γ of these judgements are telescopic [3], since types are allowed to depend on variables of other types. The contexts are generated by the following rules
1C)  $  cont	2C)  Γ  cont	A type [Γ] (x ∈ A /∈ Γ)
Γ,x ∈ A  cont
plus the rules of equality between contexts [17], [16]. In the following, we present the inference rules to construct type judgements and term judgements with their equality judgements by recursion. One should also add all the infer- ence rules that express reflexivity, symmetry and transitivity of the equality


between types and terms together with the following set equality rule and assumption of typed variables

a ∈ A [Γ]  A = B [Γ]
set rule)	a ∈ B [Γ]

Γ,x ∈ A, ∆ cont var) x ∈ A [Γ,x ∈ A, ∆]

We can derive then the structural rules of weakening and of a suitable ex- change. In the following we give the formation rules for types specific to Au with the corresponding introduction, elimination and conversion rules of their terms. We omit the equality rules of all the type and term constructors that are necessary to derive the substitution rules. We adopt the usual definitions of bound and free occurrences of variables and we identify two terms under α-conversion. Note that the context common to all judgements involved in a rule will be omitted. The typed variable appearing in a context is meant to be added to the implicit context as the last one. The rules to generate Au’s types and terms are all present in the extensional version of Martin-Lo¨f’s type theory [11] except for the disjointness axiom, the rules about quotients types restricted to mono equivalence relations and the effectiveness axiom. A type is called mono if it is inhabitated by at most one proof.
Supposing A type and R(x, y) type [x, y ∈ A], we will write Equiv(R) to mean the following three judgements:  refl(x) ∈ R(x, x) [x ∈ A], sym(x, y, z) ∈ R(y, x) [x ∈
A, y ∈ A, z ∈ R(x, y)], trans(x, y, z, u, v) ∈ R(x, z) [x ∈ A, y ∈ A, z ∈ A, u ∈ R(x, y),v ∈ R(y, z)].
Moreover, we will write Mono(R) to mean
z = w ∈ R(x, y) [x ∈ A, y ∈ A, z ∈ R(x, y),w ∈ R(x, y)]




Terminal type


False type


Indexed Sum type
The Au dependent typed calculus
Tr) T type	I-Tr)  ∈T	C-Tr)	t ∈T 
t =  ∈T 

Fs) ⊥ type	E-Fs) a ∈⊥ A type
ro(a) ∈ A

Σ) C(x) type [x ∈ B] Σx∈BC(x) type
I-Σ)	b ∈ B c ∈ C(b)
< b, c >∈ Σx∈BC(x)







Equality type
E-Σ)  d ∈ Σx∈BC(x)  m(x, y) ∈ M (< x, y >) [x ∈ B, y ∈ C(x)]
El Σ(d, m) ∈ M (d)
C-Σ)  b ∈ B  c ∈ C(b)  m(x, y) ∈ M (< x, y >) [x ∈ B, y ∈ C(x)]
El Σ(< b, c >, m) = m(b, c) ∈ M (< b, c >)

Eq) C type  c ∈ C  d ∈ C
Eq(C, c, d) type
I-Eq)	c ∈ C
eqC(c) ∈ Eq(C, c, c)



E-Eq) p ∈ Eq(C, c, d)
c = d ∈ C
C-Eq)	p ∈ Eq(C, c, d)
p = eqC(c) ∈ Eq(C, c, d)

Disjoint Sum type

+) C type  B type


I -+)	c ∈ C


I -+)	b ∈ B

C + B type
1	inl(c) ∈ C + B
2	inr(b) ∈ C + B


E-+)  w ∈ C + B  aC (x) ∈ A(inl(x)) [x ∈ C]	aB (y) ∈ A(inr(y)) [y ∈ B]
El +(w, aC, aB ) ∈ A(w)
C -+)  c ∈ C  aC (x) ∈ A(inl(x)) [x ∈ C]	aB (y) ∈ A(inr(y)) [y ∈ B]
1	El (inl(c),a ,a ) = a (c) ∈ A(inl(c))
+	C  B	C
C -+)  b ∈ B  aC (x) ∈ A(inl(x)) [x ∈ C]	aB (y) ∈ A(inr(y)) [y ∈ B]
2	El (inr(b),a ,a ) = a (b) ∈ A(inr(b))


Disjointness
+	C  B	B



Quotient type
c ∈ C  b ∈ B  inl(c) = inr(b) ∈ C + B
dsj(c, b) ∈⊥ 

Q)  R(x, y) type [x ∈ A, y ∈ A]  Mono(R)  Equiv(R)
A/R type

a ∈ A A/R type

I-Q)	[a] ∈ A/R
a ∈ A  b ∈ A  d ∈ R(a, b) A/R type

eq-Q)	[a] = [b] ∈ A/R

p ∈ A/R  l(x) ∈ L([x]) [x ∈ A]  l(x) = l(y) ∈ L([x]) [x ∈ A, y ∈ A, d ∈ R(x, y)]

E-Q)
El Q(l, p) ∈ L(p)

a ∈ A  l(x) ∈ L([x]) [x ∈ A]  l(x) = l(y) ∈ L([x]) [x ∈ A, y ∈ A, d ∈ R(x, y)]

C-Q)

Effectiveness
El Q(l, [a]) = l(a) ∈ L([a])



List type

list)	C type
a ∈ A b ∈ A [a] = [b] ∈ A/R
eff(a, b) ∈ R(a, b)


I -list) g ∈ List(C)	I -list)  s ∈ List(C)  c ∈ C

List(C) type	1	2	cons(s, c) ∈ List(C)

E-list) s ∈ List(C)  a ∈ L(g)  l(x, y, z) ∈ L(cons(x, y)) [x ∈ List(C),y ∈ C, z ∈ L(x)]
El List(a, l, s) ∈ L(s)
C -list) s ∈ List(C)  a ∈ L(g)  l(x, y, z) ∈ L(cons(x, y)) [x ∈ List(C),y ∈ C, z ∈ L(x)]
1	El	(a, l, g) = a ∈ L(g)
List
C -list)  s ∈ List(C)  c ∈ C  a ∈ L(g)  l(x, y, z) ∈ L(cons(x, y)) [x ∈ List(C),y ∈ C, z ∈ L(x)]
2	El	(a, l, cons(s, c)) = l(s, c, El	(a, l, s)) ∈ L(cons(s, c))
List	List
Note that List(T) corresponds to the type of natural numbers represented as lists on a singleton. Hence, we put N ≡ List(T) with 0 ≡ ϵ and s(n) ≡ cons(n, ∗) for n ∈ List(T).
