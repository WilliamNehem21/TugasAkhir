

Electronic Notes in Theoretical Computer Science 269 (2011) 55–69
www.elsevier.com/locate/entcs

A Theoretical Framework for the Higher-Order Cooperation of Numeric Constraint Domains
Rafael del Vado V´ırseda
Dpto. de Sistemas Inform´aticos y Computaci´on Universidad Complutense de Madrid
Madrid, Spain
rdelvado@sip.ucm.es


Abstract
This paper presents a theoretical framework for the integration of the cooperative constraint solving of numeric constraint domains into higher-order functional and logic programming on λ-abstractions, using an instance of a generic Constraint Functional Logic Programming (CFLP ) scheme over a so-called higher- order coordination domain. We provide this framework as a powerful computational model for the higher- order cooperation of algebraic constraint domains over real numbers and integers, which has been useful in practical applications involving the hybrid combination of its components, so that more declarative and efficient solutions can be promoted. Our proposal of computational model has been proved sound and complete with respect to the declarative semantics provided by the CFLP scheme, and enriched with new mechanisms for modeling the intended cooperation among the numeric domains and a novel higher-order constraint domain equipped with a sound and complete constraint solver for solving higher-order equations. We argue the applicability of our approach describing a prototype implementation on top of the constraint functional logic system T OY.
Keywords: higher-order cooperation, constraint domains, functional and logic programming

Introduction
The effort to identify suitable theoretical frameworks for higher-order functional logic programming has grown in recent years [2,9,13,14,16]. The high number of approaches in this area and their different scopes and objectives indicate the high potential of such a paradigm in modeling complex real-world problems [13]. Func- tional logic programming is the result of integrating two of the most successful declarative programming styles, namely functional and logic programming, in a way that captures the main advantages of both [3]. Whereas higher-order program- ming is standard in functional programming, logic programming is in large part still tied to the first-order world. Only a few higher-order logic programming lan-
guages, most notably λ-Prolog [10], use higher-order logic for logic programming
and have shown its practical utility, although the definition of evaluable functions is

1571-0661 © 2011 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2011.03.005

not supported. Moreover, higher-order constructs such as function variables and λ- abstractions of the form λx. e (the syntax stands for an anonymous function which, when given any actual parameter in place of the formal parameter x, will return the value resulting from the evaluation of the body expression e) are widely used in functional programming and higher-order logic programming languages, where λ- terms are used as data structures to obtain more of the expressivity of higher-order functional programming.
Within this research area, we have proposed in [15,16] a complete theoretical framework for higher-order functional logic programming as an extension to the setting of the simply typed lambda calculus of a first-order rewriting logic, where
programs are presented by Conditional Pattern Rewrite Systems (CPRS for short)
on lambda abstractions. For a first impression of our higher-order programming
framework, the following CPRS illustrates the syntax of patterns on lambda ab- stractions to define a classical higher-order function map for the application of a given function to a list of elements.
map (λu. F (u), [ ])	=  [] 
map (λu. F (u), [ X | Xs ])  =  [ F (X) | map (λu. F (u), Xs)] 
The first aim of this paper is to present a theoretical framework for the integration of higher-order functional logic programming with constraint solving, extending our programming language with the capacity of solving constraints over a given alge- braic constraint domain. The term constraint is intuitively defined as a relationship required to hold among certain entities as variables and values (e.g., X + Y ≤ 0).
We can take for instance the set of integers or the set of real numbers with addition, multiplication, equality, and perhaps other functions and predicates. Among the formalisms for the integration of constraints in functional logic programming we
use in this work the Constraint Functional Logic Programming scheme CFLP (D)
[7] which supports a powerful combination of functional and constraint logic pro-
gramming over D and can be instantiated by any constraint domain D given as parameter which provides specific data values, constraints based on specific prim- itive operations, and a dedicated constraint solver. There are different instances
of the scheme for various choices of D, providing a declarative framework for any chosen domain D. Useful constraint domains include the Herbrand domain H which supplies equality and disequality constraints over symbolic terms, the algebraic do-
main R which supplies arithmetic constraints over real numbers, and the algebraic domain FD which supplies arithmetic and finite domain constraints over integers. As a concrete example of a CPRS integrating higher-order functional logic pro- gramming with algebraic constraints in R, we can consider the following variant of a classical higher-order function diff to compute the differential of a function f at some numeric value X under some arithmetic constraints over real numbers in the conditional part of program rules.
diff :: (real → real ) → real → real


In contrast to first-order programming, we can easily formalize functions to be differentiated, or to compute the inverse operation of the differentiation (integration) by means of narrowing [15] as a suitable operational semantics, a transformation rule
which combines the basic execution mechanism of functional and logic languages, namely rewriting with unification. For instance, we can compute by narrowing the substitution {F '→ λu. sin (u)} as a solution of the goal λx. diff (λu.ln (F (u)), x)
== λx. cos (x)/sin (x) because the constraint λx. (π/4 ≤ x ≤ π/2 → sin (x) /= 0) is evaluated to true by an R-constraint solver.
Practical applications in higher-order functional logic programming, however, often involve more than one “pure” domain (i.e., H, R, FD, etc.), and sometimes problem solutions have to be artificially adapted to fit a particular choice of do- main and solver. The cooperative combination of constraint domains and solvers has evolved during the last decade as a relevant research issue that is raising an increasing interest in the constraint programming community. An important idea emerging from the research in this area is that of “hybrid” constraint domain (e.g., H ⊕ R ⊕ FD [1]), built as a combination of simpler “pure” domains and designed to support the cooperation of its components, so that more declarative and efficient solutions for practical problems can be promoted.


Higher-Order Algebraic Constraint Cooperation
The second contribution of this work is to present a formal framework for the coope- ration of the algebraic constraints domains FD and R in an improved version of the CFLP (D) scheme [7], now useful for higher-order functional and logic programming on lambda abstractions. As a result, we provide a powerful theoretical framework for higher-order constraint functional logic programming with lambda abstractions and decidable higher-order unification in a new higher-order constraint domain 7, which leads to greater expressivity. As a motivation for the rest of the paper, we present in this section a couple of examples of CPRS -programs involving the cooperation of the algebraic constraint domains FD and R to illustrate the different cooperation mechanisms that are supported by our theoretical framework, as well as the benefits resulting from the cooperation in the higher-order functional logic programming setting.
As a first simple example, we consider the following CPRS (adapted from [1] to the higher-order setting on λ-abstractions) to solve the problem of searching for a two-dimensional point lying in the intersection of a discrete grid and a continuous region.
bothIn :: (real → real → real ) → int → int → bool

bothIn (λu, v.F (u, v), X,Y )	=	true	⇐	X  RX , Y  RY ,
F (RX , RY ) ≤ 0,
domain [X, Y ] 0 N , labeling [] [X, Y ]
The higher-order function bothIn is intended to check if a given discrete point (X, Y ) belongs to the intersection of the continuous region given by the R-constraint F (RX , RY ) ≤ 0 and the discrete grid given by the FD-constraints domain [X, Y ] 0 N , labeling [] [X, Y ], ensuring that the variables X and Y are bound to in- teger values in the interval [0..N ]. In order to model the intended cooperation
and communication between the constraint domains FD and R we use a special kind of hybrid constraints  called bridges, as a key tool for communicating con- straints between different algebraic constraint domains. More precisely, the two
communicating constraints X  RX and Y  RY ensure that the discrete point (X, Y ) and the continuous point (RX , RY ) are equivalent. Different goals can be posed and solved using the small program just described. For instance, the goal bothIn (λu, v. v − 4 ∗ u + u2, X,Y ) == true with N = 4 asks for points in the in- tersection of the square grid with the inner side of the parabola Y = 4 ∗ X − X2. We can compute by narrowing 15 solutions (see Fig.  1): {X '→ 2, Y '→ 3},
{X '→ 1, Y '→ 2}, {X '→ 2, Y '→ 2}, {X '→ 3, Y '→ 2}, etc. In this process, cooperation between the R-constraint solver and the FD-solver is crucial for the efficiency of the computation. Initially, we reduce the problem of solving the goal to the problem of solving the hybrid constraint system { X  RX , Y  RY , RY − 4 ∗ RX + RX 2 ≤ 0, domain [X, Y ] 0 4, labeling [] [X, Y ] }. When the com- munication constraints are disabled, the last FD-constraints force the enumeration of all possible values for X and Y within their domains, eventually finding all the solutions after O(N 2) steps. When the communication constraints are enabled, we can use both constraints to project the R-constraint RY − 4 ∗ RX + RX 2 ≤ 0 into equivalent integer FD-constraints (X = 0) ∧ (Y = 0), (X = 1) ∧ (0 ≤ Y ≤ 3),
(X = 2) ∧ (0 ≤ Y ≤ 4), (X = 3) ∧ (0 ≤ Y ≤ 3), (X = 4) ∧ (Y = 0). Now, using this
new information the FD-solver can prune the domains of X and Y, and solving the labeling constraint leads to the solutions with minor effort. The expected speedup in execution time corresponds to the improvement from O(N 2) to O(N ) or O(1) steps according to the lambda abstraction encoded in the goal and the possibilities offered by the constraint solver.
We present now a second example, intended to illustrate new possibilities and mechanisms of our higher-order cooperative constraint model. In engineering, a common problem is the approximation of a complicated continuous function by a simple discrete function (e.g., the approximation of GPS satellite coordinates). Suppose we know a real function (given by a lambda abstraction λu. F (u)) but it is too complex to evaluate efficiently. Then we could pick a few approximated (integer) data points from the complicated function, and try to interpolate those data points to construct a simpler function, for example, a polynomial λu. P (u). Of course, when using this polynomial function to calculate new (real) data points we usually do not receive the same result as when using the original function, but depending on the problem domain and the interpolation method used the gain in

4	4

3	3

2	2

1	1


。
0	1	2	3	4
。
0	1	2	3	4

Fig. 1. Cooperation and interpolation of a parabolic region in a discrete square grid.

simplicity might offset the error.
disc :: (real → real ) → (int → int )
disc (λu. F (u))	=	λu. P (u)	⇐	domain [X] 0 N , labeling [ff ] [X],
X  RX , Y  RY ,
| F (RX ) − RY | < 1,
collection [X, Y ] C, interpolation [lg ] C P 
Therefore, the aim of this example is to approximate a continuous function repre- sented by a lambda abstraction λu. F (u) over real numbers by a discrete polynomial function λu. P (u) over integer numbers. In this case, we use the FD-constraints domain [X] 0 N , labeling [ff ] [X] to generate each value of the discrete interval
[0..N ], according to a first-fail (or ff) labeling option [7]. The first bridge constraint
X   RX maps each integer value of X into an equivalent real value in RX . By
applying the higher-order functional variable F to RX we obtain the R-constraint
| F (RX ) − RY | < 1. From this constraint, the R-solver computes (infinite) real values for RY . However, because of the second bridge constraint Y  RY , each real value assigned to RY by the constraint solving process causes the variable Y to be bound only to an equivalent integer value. By means of the primitive constraint collection [X, Y ] C we can collect all the pairs (X, Y ) generated by the labeling- solving process into a set C. Finally, interpolation [lg ] C P finds a polynomial which
goes exactly through the points collected in C by means of the Lagrange Interpola- tion (lg) method. For instance, we can consider the following goal disc (λu. 4∗u−u2)
== λu. P (u) involving the continuous function F as λu. 4 ∗ u − u2 with N = 4. We
obtain the set of integer pairs (xi, yi) in C = {(0, 0), (1, 3), (2, 4), (3, 3), (4, 0)} (see again Fig. 1). For this particular case, it is easy to check that this computed answer is simply {P '→ λu. 4 ∗ u − u2}.
As we have commented before, the generic scheme CFLP (D) presented in [7] serves in this work as a logical and semantic framework for lazy Constraint Func- tional Logic Programming over a parametrically given constraint domain D. In order to model the coordination of algebraic constraint domains in our higher-order functional logic programming framework [15,16], we propose the construction of a
higher-order coordination domain C, as a special kind of hybrid domain tailored to
the cooperation of the algebraic domains R and FD with a new higher-order cons-
traint domain 7 which supplies lambda abstractions as data values and equalities

over lambda terms as constraints. Following the methodology of [1], we obtain a suitable theoretical framework for the cooperation of algebraic constraint domains with their respective solvers in higher-order functional and logic programming us- ing instances CFLP (C). Moreover, thanks to this fact, we can describe a prototype implementation following the techniques summarized in our previous work [1] in
the T OY system [6], which is in turn implemented on top of SICStus Prolog. The
former system is extended, including special stores for bridges and lambda ab-
stractions, and implementing mechanism for computing bridges, projections, and interpolations according to the new CFLP (C) computation model.
To finish this introduction and motivation to the work, we summarize the orga- nization of the rest of the paper. In Section 3 we give a mathematical formalization of the higher-order constraint domain 7 and a solver to solve higher-order strict equations tailored to the needs of the CFLP (D) generic scheme. Followed by a brief presentation of the algebraic constraint domains R and FD, in Section 4 we discuss bridge constraints and the construction of the coordination domain C tai- lored to the cooperation of the algebraic constraint domains R and FD with 7. In Section 5 we present our proposal of a sound and complete computational model for cooperative higher-order declarative programming in CFLP (C), and we sketch the implementation on top of the T OY system. Finally, Section 6 summarizes some conclusions and presents a brief outline of related and planned future work.

A Higher-Order Constraint Domain
Taking the generic scheme CFLP (D) as a formal basis for foundational and practical issues concerning the cooperation of algebraic constraint domains, in this section we focus on the formalization of a higher-order constraint domain 7 which supplies λ-
abstractions and equality constraints over λ-terms in the instance CFLP (7). First,
we introduce the basic preliminary notions of our higher-order theoretical framework to formalize the constraint domain 7 along with a suitable 7-constraint solver based on an approach similar to the Hu`et’s procedure of higher-order pre-unification [9,13].
Preliminary notions
We assume the reader is familiar with the notions and notations pertaining to λ- calculus (see, e.g., [5,13] for more examples and motivations). The set of types for simply typed λ-terms is generated by a set B of base types (as e.g., bool , real ,
int ) and the function type constructor “→”. Simply typed λ-terms are generated in the usual way from a signature F of function symbols and a countably infinite set V of variables by successive operations of abstraction and application. We also consider the enhanced signature F⊥ = F ∪ Bot, where Bot = {⊥b | b ∈ B} is a set of distinguished B-typed constants. The constant ⊥b is intended to denote an undeﬁned value of type b. We employ ⊥ as a generic notation for a constant from Bot. A sequence of syntactic objects o1,..., on, where n ≥ 0, is abbreviated by on. For instance, the simply typed λ-term λx1,..., λxk. (··· (a t1) ··· tn) is abbreviated by λxk. a(tn). Substitutions γ ∈ Subst (F⊥, V) are finite type-preserving mappings

from variables to λ-terms, denoted by {Xn '→ tn}, and extended homomorphically to λ-terms. By convention, we write {} for the identity substitution, tγ instead of γ(t), and γγj for the function composition γj ◦ γ. The long βη-normal form of a λ-term t, denoted by t‡η , is the η-expanded form of the β-normal form of

t. It is well-known that s =αβη t if s‡η
=α t‡η
[5]. Since βη-normal forms are

always defined, we will in general assume that λ-terms are in long βη-normal form and are identified modulo α-conversion. For brevity, we may write variables and constants from F in η-normal form, e.g., X instead of λxk.X(xk). We assume that the transformation into long βη-normal form is an implicit operation, e.g., when applying a substitution to a λ-term. With these conventions, every λ-term t has an unique long βη-normal form λxk. a(tn), where a ∈ F⊥ ∪V and a() coincides with
a. The symbol a is called the root of t and is denoted by hd (t). We distinguish between the set T (F⊥, V) of partial λ-terms and the set T (F, V) of total λ-terms. The set T (F⊥, V) is a poset with respect to the approximation ordering ±, defined as the least partial ordering such that:
  s1 ± t1 ·· · sn ± tn	
λx . ⊥± λx .t	t ± t
k	k	λxk. a(sn) ± λxk. a(tn)

A pattern [9] is a λ-term t for which all subterms t|p = X(tn), with X ∈ FV(t) a free variable of t and p ∈ MPos(t) a maximal position in t, satisfy the condition that t1↓η,..., tn↓η is a sequence of distinct elements of the set BV(t, p) of bound variables abstracted on the path to position p in t. Moreover, if all such subterms of t satisfy the additional condition BV(t, p) \ {t1↓η,..., tn↓η} = ∅, then the pattern
t is fully extended. It is well known that unification of patterns is decidable and unitary [9]. Therefore, for every t ∈ T (F⊥, V) and pattern π, there exists at most one matcher matcher (t, π) between t and π.

The higher-order constraint domain 7
Intuitively, a constraint domain D provides data values and constraints oriented to some particular application domain. In our higher-order setting, we need to formalize a special higher-order constraint domain 7 to support computations with symbolic equality over λ-terms of any type. Formally, it is defined as follows:
Definition 3.1 [7-constraint domain] The higher-order domain 7 is a structure
⟨D7, ==7⟩ such that the carrier set D7 coincides with the set of ground patterns
(i.e., patterns without free variables) over any type, and the function symbol == is interpreted as strict equality over D7, so that for all t1, t2,t ∈ D7, one has ==7
⊆ D2 × D7, where t1 ==7 t2 → t (i.e., (t1, t2, t) ∈ ==7) iff some of the following
three cases hold:
t1 and t2 are one and the same total λ-term in D7, and true ± t.
t1 and t2 have no common upper bound in D7 with respect to the approximation ordering ±, and false ± t.
t = ⊥.
From this definition, it is easy to check that the equality function ==7 satisfies the

conditions required to a constraint domain D for the CFLP (D) scheme:
Polarity: t1 ==7 t2 → t behaves monotonically with respect to the arguments t1 and t2, and antimonotonically with respect to the result t. Formally, for all t1, tj , t2, tj , t, tj ∈ D7 such that t1 ==7 t2 → t, t1 ± tj , t2 ± tj , and t ± tj,
1	2	1	2

j ==7 tj
→ tj also holds.

Radicality: As soon as the arguments given to ==7 have enough information to return a result, the same arguments suffice already for returning a total result. Formally, for all t1, t2,t ∈ D7, if t1 ==7 t2 → t then t = ⊥ or else there is some total tj ∈ D7 such that t1 ==7 t2 → tj and tj ± t.
An equality constraint (or simply, 7-constraint) isa multiset {s, t }, written s == t, where s, t ∈ T (F⊥, V) are λ-terms of the same type. The set of solutions of an equality constraint s == t is defined as follows: Soln(s == t)= {γ ∈ Subst (F⊥, V) |
tγ ==7 sγ → true}. Any set E of strict equations is interpreted as conjunction,

and therefore Soln(E) = T

(s == t) ∈ E
Soln(s == t).

The 7-constraint solver
Solving equality constraints in first-order term algebras (which is also known as unification) is the most famous symbolic constraint solving problem. In the higher- order case, higher-order unification is a powerful method for solving equality 7- constraints between λ-terms and is currently used in theorem provers [11,12]. Other applications of higher-order unification include program synthesis and machine learning [13]. However, one of the major obstacles for reasoning in the higher-order case is that unification is undecidable. However, in this subsection we examine a
decidable higher-order unification case of patterns by means of the development of a 7-constraint solver for the higher-order constraint domain 7, now supporting an improved treatment of the strict equality == as a built-in primitive function symbol, rather than a defined function [3].
Definition 3.2 [States] The constraint solver Solver 7 for the higher-order domain
7 acts on states of the form P ≡ ⟨E | K⟩, where E is a set of strict equality constraints s == t between λ-terms s, t, and K is a set of patterns intended to represent and store computed values in the sense of [15,16] during the constraint solving process. The meaning of a state P ≡ ⟨E | K⟩ is as follows: [⟨E | K⟩]] =
{γ ∈ Soln(E) | Kγ is a set of values }. We note that [[⟨E | K⟩]] = ∅ whenever K is not a set of values. In the sequel, we denote this state by fail and call it failure state.
Solving a set of strict equality 7-constraints amounts to computing 7-derivations, i.e., sequences of transformation steps.
Definition 3.3 [Derivations] A 7-derivation of a set E of strict equality 7- constraints is a maximal finite sequence of transformation steps: P0 ≡ ⟨E | ∅⟩ ≡
⟨E0 | K0⟩ ⇒σ1 P1 ≡ ⟨E1 | K1⟩ ⇒σ2 ··· ⇒σm Pm ≡ ⟨Em | Km⟩, between states P0, P1,
.. ., Pm, such that Pm /= fail is a final state, i.e., a non failure state which can not be transformed anymore.

Definition 3.4 [λ-constraint solver]
Each transformation step ina 7-derivation Π corresponds to an instance of some transformation rule of the 7-constraint solver Solver 7 described below. We ab- breviate Π by P0 ⇒∗ Pm, where σ = σ1 ... σm.
Given such a set E of strict equality 7-constraints, the set of computed answers produced by the 7-constraint solver Solver 7 is A(E)= { σγ TFV(E) | ⟨E | ∅⟩ ⇒∗ P is a 7-derivation and γ ∈ [[P ]] }, where FV(E) is the set of free variables of E.
In the sequel, we will describe the transformation rules of the 7-constraint solver and analyze its main properties.
(an) annotation
⟨{{s == t, E}}| K⟩ ⇒{} ⟨{{s ==H t, E}}|K ∪ {H}⟩
where H is a fresh variable of a suitable type.
(sg ) strict guess
⟨{{λxk.a(sn) ==H t, E}}| K⟩ ⇒σ ⟨{{λxk.a(sn) ==Hσ t, E}}| Kσ⟩
where a ∈F ∪ {xk}, and σ = {H '→ λxk.a(Hn(xk))}.
(d ) decomposition
⟨{{λxk.a(sn) ==u λxk.a(tn),E}}| K⟩ ⇒σ ⟨{{λxk.sn ==Hn λxk.tn,E}}| Kσ⟩
where a ∈F ∪ {xk}, and either
. u ≡ H and σ = {H '→ λxk.a(Hn(xk))}, or
. u ≡ λxk.a(Hn(xk)) and σ = {}.
(i ) imitation
⟨{{λxk.X(sp) ==u λxk.f (tn),E}}| K⟩ ⇒σ ⟨{{λxk.Xn(sp) ==Hn λxk.tn,E }σ | (K∪ {X})σ⟩
where X ∈ V, and either
. u ≡ H and σ = {X '→ λyp.f (Xn(yp)),H '→ λxk.f (Hn(xk))}, or
. u ≡ λxk.f (Hn(xk)) and σ = {X '→ λyp.f (Xn(yp))}.
(p) projection
⟨{{λxk.X(sp) ==u t, E}}| K⟩ ⇒σ ⟨{{λxk.X(sp) ==u t, E }σ | (K∪ {X})σ⟩
where X ∈ V, t is not flex, and σ = {X '→ λyp.yi(Xn(yp))}. (fs) flex same

		
⟨{{λxk.X(yp) ==H λxk.X(y′ ),E}}| K⟩ ⇒σ ⟨{{E }σ | (K∪ {X})σ⟩
where X ∈ V, λxk.X(yp) and λxk.X(y′ ) are patterns, σ = {X '→ λyp.Z(zq), H '→ λxk.Z(zq)} with
{zq} = {yi | yi = y′, 1 ≤ i ≤ n}.
(fd ) flex different
⟨{{λxk.X(yp) ==H λxk.Y (y′ ),E}}| K⟩ ⇒σ ⟨{{E }σ | (K∪ {X, Y })σ⟩
where X, Y  ∈ V , λxk.X(yp) and λxk.Y (y′ ) are patterns, X /= Y , σ = {X '→ λyp.Z(zr),Y  '→
λy′ .Z(zr),H '→ λxk.Z(zr)} with {zr} = {yp}∩ {y′ }.
q	q
(cf ) clash failure
⟨{{λxk.a(sn) ==u λxk.a′(tm),E}}| K⟩ ⇒{} fail
if a, a′ ∈ Fc ∪ {xk} (where the notation Fc will be explained in Section 5), and either (i) a /= a′ or (ii)
hd (u) /∈V ∪ {a, a′}.
(oc) occur check
⟨{{λxk.s ==u λxk.X(yn),E}}| K⟩ ⇒{} fail

if X ∈V, λxk.X(yn) is a flex pattern, hd (λxk.s) /= X and (λxk.s)|p = X(zn), where zn is a sequence of distinct bound variables and p is a maximal safe position of λxk.s (i.e., hd ((λxk.s)|q) ∈ BV (λxk.s, q) ∪ Fc for all q ≤ p).
In order to illustrate the overall behavior of our constraint solver Solver 7, we consi- der the following 7-derivation involving the function symbols given in the signature of the diff -example presented in Section 1: ⟨{{λx. sin(F (x)) == λx. sin(cos(x))}} | 

(an),(d),(i)
{F '→ λx. cos(x)}
⟨∅ | {λx. sin(cos(x)), λx. cos(x)}⟩. Therefore, we have computed

the substitution {F  '→ λx. cos(x)} as the only answer in A(λx. sin(F (x)) ==

Equalities between


Collection
+
Interpolation
	›
 (	λ-terms
7
´	’
Functional variable
+
M	Application
\	



FD-constraints
FD	(
 (
)
Bridges
+
R	ˆ
R-constraints

Projections
Fig. 2. The higher-order coordination domain C = M ⊕ 7 ⊕ FD ⊕ R.

λx. sin(cos(x))).
The main properties of the 7-constraint solver, soundness and completeness, relate the solutions of a set of strict equality 7-constraints to the answers computed by our system of transformation rules for higher-order unification.
Theorem 3.5 (Properties of the 7-constraint solver)
Soundness: Let ⟨E | ∅⟩ ⇒∗ P be a 7-derivation. Then, σγ ∈ Soln(E) whenever
γ ∈ [[P ]].
Completeness: Let E be a set of 7-constraints. Then, A(E) = {γTFV(E) |
γ ∈ Soln(E)}.
Higher-Order Coordination of Algebraic Domains
The higher-order domain 7 supports computations with symbolic equality 7-cons- traints over λ-abstractions involving values of arbitrary user-defined datatypes. However, from a programmer’s viewpoint we also need to work with extended al- gebraic constraint domains supporting computations with arithmetic and equality 7-constraints over λ-terms involving numerical values. For this reason, in the con- text of our higher-order CFLP framework, we need to introduce extensions of both the classical domain R, which supplies arithmetic constraints over real numbers, and the finite domain FD, which supplies arithmetic and finite domain constraints over integers, to deal now with λ-abstractions defined over real numbers and integers.
A convenient formal definition of the algebraic constraint domain R is as follows: R is a structure ⟨DR, {pR}⟩, where the set of base values includes just one base type real whose values represent real numbers, the carrier set DR coincides with the set of ground patterns over real numbers, and the usual interpretations pR include as primitive function symbols the strict equality operator ==, defined as for the 7-domain, the arithmetical operators +, −, ∗, / :: real → real → real , and the inequality operator ≤ :: real → real → bool . Concerning the solver solver R, we expect that it is able to deal with R-derivations of R-specific constraints sets consisting of primitive constraints of the following two kinds: proper R-constraints

involving an arithmetic operator, and specific higher-order R-constraints having the form t1 == t2, where t1 and t2 are λ-terms over real constant values or variables whose type is known to be real prior to the solver invocation. We assume that
Solver R is implemented as a black-box solver on top of SICStus Prolog, and solves
R-specific higher-order constraints in a way compatible with the behavior of the
7-solver described in the previous section.
Analogously, FD is a structure ⟨DFD, {pFD}⟩, where the set of base values includes just one base type int whose values represent integer numbers, the carrier set DFD coincides with the set of ground patterns over integer numbers, and the usual in- terpretations pFD include as primitive function symbols the strict equality operator
==, the arithmetical operators +, −, ∗, / :: int → int → int , the inequality opera- tor ≤ :: int → int → bool , and the following primitive function symbols (see [7] for more details):
domain :: [int ] → int → int → bool , to fix that a non-empty list of integer variables belongs to an interval of values.
labeling :: [labelType] → [int ] → bool , to select an integer variable of the list with a non-empty, non-singleton domain, selecting a value of this domain and assigning the value to the variable, where labelType is an enumerated datatype used to
represent labeling strategies [7].
Concerning the solver solver FD, we also assume that is implemented as a black-box solver on SICStus Prolog, and we expect that it is able to deal with FD-derivations of proper FD-constraints involving arithmetic FD-operators and higher-order alge-
braic constraints t1 == t2, where t1 and t2 are λ-terms over integer constant values or variables whose type is known to be int prior to the solver invocation.
A coordination domain C is a kind of “hybrid” constraint domain built from various component domains (as e.g., H, 7, R, FD,.. .) intended to cooperate. The construction of coordination domains involves a so-called mediatorial domain M, whose purpose is to supply mechanisms for communication among the component
domains via bridges, projections, functional variable applications, interpolations, and some more ad hoc operations (see Fig. 2). In this work, the component domains will be chosen as the pure domains 7, R, and FD, equipped with constraint solvers, in such a way that the communication provided by the mediatorial domain will also benefit the solvers. In the remaining of this section we briefly explain the
construction of this higher-order coordination domain C, represented as the sum
C = M⊕ 7 ⊕FD ⊕ R.
Mathematically, the construction of the coordination domain C relies on a com- bined algebraic constraint domain FD ⊕ R, which represents the amalgamated sum of the two joinable algebraic domains FD and R. In this case, the joinabil- ity condition asserts that the only primitive function symbol allowed to belong to FD and R is the strict equality ==, where the interpretation of this operator will
behave as defined for each algebraic constraint domain and 7. As a consequence, the amalgamated sum 7 ⊕FD ⊕ R is always possible, and gives rise to compound a higher-order algebraic domain that can profit from the higher-order 7-constraint solver. However, in order to construct a more interesting sum for higher-order al-

gebraic cooperation tailored to the communication among pure domains 7, R, and
FD, mediatorial domains are needed.
The higher-order mediatorial domain M serves as a basis for useful cooperation facilities among 7, FD, and R, including the projection of R-constraints to the
FD-solver (and vice versa) using bridges, the specialization of 7-constraints to become R- or FD-constraints, the definition of algebraic constraints in R and FD from the application of higher-order functional variables in the domain 7, and the gathering of numeric data values to construct a λ-abstraction in 7 which closely fits the data points by means of interpolation.
More precisely, bridge constraints X  RX , with  :: int → real → bool , can be used either for binding or projection purposes. Binding in solver M simply instantiates a variable occurring at one end of a bridge whenever the other end
of the bridge becomes a numeric value. Projection is a more complex operation which infers constraints to be placed in R’s store from the constraints available in FD’s store (and vice versa) and the relevant bridges available in M. This enables each solver to take advantage of the computations performed by other solvers. We postulate a projection function proj FD→R such that for any set CFD of FD-constraints and any finite set M of bridge constraints, proj FD→R(CFD,M ) returns a finite disjunction CR of equivalent R-constraints (similarly, proj R→FD). In order to maximize the opportunities for projection, we postulate a function bridgesFD→R such that bridgesFD→R(CFD,M ) returns a finite set of new bridge constraints Mj from the new variables in CFD (similarly, bridgesR→FD).
Interpolation is the process of defining a function that takes on specified values at specified points. We use this technique in our higher-order setting to support the cooperation and communication between an algebraic constraint domain (R or FD) and 7. We try to construct a function, represented by a λ-abstraction,
which must go through the data points. In order to apply this technique, our cooperative computation model keeps a store C by means of the execution of an algebraic constraint collect [.. .] C (similar to the setof predicate in Prolog)
from a finite list of real or integer variables. Then, we assume an interpolation
function interpolation, interpreted with respect to a mapping interpR→7 (sim- ilarly, interpFD→7), such that the higher-order constraint interpolation [.. .] C F returns in the functional variable F a λ-abstraction λu. F (u) according to a 
predefined list of interpolation methods (implemented in C++ and called from
Prolog), so that the following interpolation condition holds: F (x)= y for all (x, y)
∈ C. For communicating information between the higher-order domain 7 and an
algebraic constraint domain D (R or FD) we can assume a mapping apply 7→D, defined by means of the application of the functional variable F associated to a λ-abstraction λu. F (u) to a type appropriate finite number of arguments x in order to compound algebraic constraints from F (x) (Fig. 3 illustrates this coope- ration of the algebraic domains FD and R with 7 for the motivating examples presented in Section 2).



λu, v.F (u, v)
λu. F (u)	λu. P (u)






F (RX , RY )
7	7

F (RX )

` collect . [X, Y ] C
interp. [lg] C P 

M
  ›
X RX
R
(X, Y )


) FD 
M
	›
X RX
R


) FD 

ˆ	Y  RY	ˆ
ˆ	Y  RY	ˆ

F (RX , RY ) ≤ 0	domain [X, Y ]0 N
labeling [] [X, Y ]
domain [X]0 N 	
|F (RX ) − RY | < 1	labeling [ff ] [X]


Fig. 3. Examples of higher-order programming with algebraic constraint cooperation.




Higher-Order Cooperative Programming in CFLP (C)
We are now ready to present our computation framework for higher-order functional and logic programming with cooperation of algebraic constraint domains within the CFLP (C) instance of the CFLP scheme. We sketch a prototype implementation of the CFLP (C) computational model on top of the T OY system [6]. Fig. 4 shows the architectural components of the higher-order cooperation schema in this system. The higher-order constraint domain 7 and the algebraic domains R and FD with a mediatorial domain M to yield the coordination domain C = M ⊕ 7
⊕ FD ⊕ R are supported by this implementation. The main novelty here is that compilation proceeds by performing a translation from higher-order programs on the domain 7 to typed higher-order applicative programs in the Herbrand domain
H. Following [16], the idea consists in introducing an explicit application operation apply , replacing λ-abstractions (and similar constructs in our higher-order setting, such as partial applications) by means of new data constructors, and providing rewrite rules to define the proper behavior of the application operation when meeting terms where these new data constructors appear. Proper FD and R constraints, as well as 7 and H constraints specific to FD and R are posted to the respective
stores and handled by the respective SICStus Prolog solvers. On the other hand,
the stores and solvers for the domains 7, H, and M are built into the code of the T OY implementation, rather than being provided by the underlying SICStus Prolog system. Moreover, the implementation of the fundamental mechanisms for algebraic
domain cooperation: bridges, projections, and the collection and interpolation of data values among the higher-order domain 7 and the algebraic domains R and FD are tackled by glue code integrating Prolog services with C++ and using a so-called
mixed store which keeps a representation of the mediatorial constraint store as one
single Prolog structure.











v



Fig. 4. Architectural components of the higher-order cooperation in T OY.
Conclusions
In this work we have presented an efficient use of cooperative algebraic constraint domains and solvers in a higher-order functional and logic programming frame- work on λ-abstractions. We have investigated foundational and practical issues concerning a sound and complete computational framework for the cooperation of algebraic constraint domains. We have designed an improved higher-order instance CFLP (C) of an already existing generic scheme CFLP (D) for constraint functional logic programming over a higher-order coordination domain C, as well as a prototype implementation in the T OY system which supports the cooperation via bridges, projections, application of functional variables, and polynomial interpolations on λ-abstractions.
In addition to already mentioned works, an important related work in this area is the CFLP scheme developed by Mircea Marin in his PhD Thesis [8]. This work introduces CFLP (D, S, L), a family of languages parameterized by a constraint domain D, a strategy S which defines the cooperation of several constraint solvers over D, and a constraint lazy narrowing calculus L for solving constraints involving functions defined by user given constrained rewrite rules. The main difference with respect to our approach is the lack of declarative (model-theoretic and fixpoint) semantics provided by the rewriting logic underlying our CFLP (C) instance (see [16] for more details). Another difference with respect to our approach is the intended application domain. The instance of CFLP developed by Marin combines four solvers over a constraint domain for algebraic symbolic computation.
In the future, we would like to improve some of the limitations of our current approach to higher-order algebraic domain cooperation, concerning both the formal foundations and the implemented system. For instance, the computational model should be generalized to allow for an arbitrary higher-order coordination domain C in place of the concrete choice M⊕ 7 ⊕R⊕ FD, and the implemented prototype
should be properly developed, maintained and improved in various ways. In partic- ular, the experimentation with benchmarks and application cases should be further

developed.

References
S. Est´evez, T. Hortal´a, M. Rodr´ıguez, R. del Vado et al. On the cooperation of the constraint domains H, R, and FD in CFLP . Journal of Theory and Practice of Logic Programming, vol. 9, pp. 415–527, 2009.
J.C. Gonz´alez, M.T. Hortal´a, and M. Rodr´ıguez. A higher-order rewriting logic for functional logic programming. In Proc. ICLP’97, pp. 153–167, 1997.
M. Hanus. The Integration of Functions into Logic Programming: From Theory to Practice. Journal of
Logic Programming 19&20, pp. 583–628, 1994.
M. Hanus and C. Prehofer. Higher-order narrowing with definitional trees. Journal of Functional Programming, vol. 9, pp. 33–75, 1999.
J.R. Hindley and J.P. Seldin. Introduction to Combinatorics and λ-Calculus. Cambridge University Press, 1986.
F.J. L´opez and J. S´anchez. T OY: A Multiparadigm Declarative System. In Proc. RTA’99, Springer LNCS 1631, pp 244–247, 1999. System and documentation available at http://toy.sourceforge.net.
F.J. L´opez, M. Rodr´ıguez, and R. del Vado. A New Generic Scheme for Functional Logic Programming with Constraints. Journal of Higher-Order and Symbolic Computation, vol. 20 (1/2), pp. 73–122, 2007.
M. Marin. Functional Logic Programming with Distributed Constraint Solving. PhD. Thesis, Johannes Kepler Universit¨at Linz, 2000.
D. Miller. A logic programming language with λ-abstraction, function variables, and simple unification. Journal of Logic and Computation, 1(4):497–536, 1991.
G. Nadathur and D. Miller. An overview of λ-Prolog. In Proc. Int. Conf. on Logic Programming (ICLP’88), The MIT Press, pp. 810–827, 1988.
T. Nipkow, L. Paulson, and M. Wenzel. Isabelle/HOL - A Proof Assistant for Higher-Order Logic. Springer LNCS, vol. 2283, 2002.
L.C. Paulson. Isabelle: A Generic Theorem Prover. Springer LNCS, vol. 828, 1994.
C. Prehofer. Solving Higher-Order Equations. From Logic to Programming. Foundations of Computing. Birkauser Boston, 1998.
T. Suzuki, K. Nakagawa, and T. Ida. Higher-Order Lazy Narrowing Calculus: A Computation Model for a Higher-Order Functional Logic Language. In Proc. of ALP’97, vol. 1298 of LNCS, pp. 99–113, 1997.
R. del Vado. A Higher-Order Demand-Driven Narrowing Calculus with Definitional Trees. In Proc.
ICTAC’07, Springer LNCS, vol. 4711, pp. 169–184, 2007.
R. del Vado. A Higher-Order Logical Framework for the Algorithmic Debugging and Verification of Declarative Programs. In PPDP’09, ACM, pp. 49–60, 2009.
