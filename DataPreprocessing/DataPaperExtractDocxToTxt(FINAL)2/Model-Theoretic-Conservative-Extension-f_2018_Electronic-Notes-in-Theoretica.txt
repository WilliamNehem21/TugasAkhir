Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 338 (2018) 133–145
www.elsevier.com/locate/entcs


Model-Theoretic Conservative Extension for Definitional Theories
Arve Gengelbacha,1  Tjark Webera,2
a Department of Information Technology Uppsala University
Uppsala, Sweden

Abstract
Many logical frameworks allow extensions, i. e. the introduction of new symbols, by definitions. Different from asserting arbitrary non-logical axioms, extensions by definitions are expected to be conservative: they should entail no new theorems in the original language. The popular theorem prover Isabelle implements a variant of higher-order logic that allows ad hoc overloading of constants. In 2015, Kunčar and Popescu introduced deﬁnitional theories, which impose a non-circularity condition on constant and type definitions in this logic, and showed that this condition is suﬃcient for definitional extensions to preserve consistency. We strengthen and generalize this result by showing that extensions of definitional theories are model-theoretic conservative, i. e. every model of the original theory can be expanded to a model of the extended theory.
Keywords: classical higher-order logic, conservative theory extension, model-theoretic conservativity, definitional theories, ground semantics, Isabelle


Introduction
Among the many different mechanisms for extending theories by definitions, par- ticularly constant and type definitions [3,12], the one used by the theorem prover Isabelle [9] had flaws. Isabelle implements polymorphic higher-order logic with ad hoc overloading. Users extend a theory incrementally by defining constants and types (or in the case of overloaded constants, by defining constant instances for previously defined types). A key strength of overloading is the separation of the declaration of a constant from its instance definitions. However, by combining type definitions with ad hoc overloading of constants, it was possible to introduce an inconsistent extension of a theory [6]. For a simple example, consider a theory that declares a polymorphic constant cα. Define a type τ by τ ≡ {True, cbool}. Next,

define the constant instance cbool by cbool
.
τ	τ	τ
τ . (We use .
rather



1 Email: arve.gengelbach@it.uu.se
2 Email: tjark.weber@it.uu.se

https://doi.org/10.1016/j.entcs.2018.10.009
1571-0661/© 2018 The Author(s). Published by Elsevier B.V.
This is an open access article under the CC BY license (http://creativecommons.org/licenses/by/4.0/).

than = to avoid confusion with equality in our meta language.) It follows that
c	.	.
bool = True iff τ is a singleton iff cbool = False, a contradiction.
To address this issue, Kunčar and Popescu [6] in 2015 introduced definitional theories for Isabelle. In the previous example, τ (through its definition) depends on cbool, and cbool depends on τ . Well-formed definitional theories disallow circular dependencies between constant and type definitions. Using a novel semantics for higher-order logic that interprets polymorphic types as macros for families of ground types, Kunčar and Popescu showed that well-formed definitional theories preserve consistency, i. e. every well-formed definitional theory has a model. Their acyclicity check has since been integrated into Isabelle [5].
As pointed out in [6], consistency is “a crucial, but rather weak property.” It merely ensures that well-formed definitional theories do not prove False. Extensions by definitions are generally expected to satisfy a much stronger property known as conservativity [1,13]. Conservativity comes in a proof-theoretic (syntactic) and in a model-theoretic (semantic) flavour. In this paper, we are primarily concerned with the latter. Roughly, an extension Dj of a theory D is model-theoretic conservative if every model M of D can be expanded to a model Mj of Dj. (We give a more pre- cise definition in Section 3.) Note that model-theoretic conservativity immediately implies consistency: if D has a model, then so does Dj.
We observe that extensions of definitional theories are not model-theoretic con- servative if we require that the expanded model leaves the interpretation of all constants that are defined in the original theory D unchanged. For a simple counterexample, assume constants cbool and dbool, let D := {cbool ≡ dbool} and Dj := D ∪ {dbool ≡ True}. Then any model of D that interprets cbool as false cannot be expanded (in the above sense) to a model of Dj. The issue here is again that definitions may be provided separately from declarations: cbool depends on dbool, but the definition of dbool is only provided in Dj. In general, an extension by definitions in this logic does not imply an extension of the signature, i. e. the introduction of new symbols.
This example motivates a modified (more permissive) definition of model expan- sion. Our main contributions in this paper are:
We define a notion of model expansion that is suitable for definitional theories, where definitions may be provided separately from declarations; and
we show that extensions of well-formed definitional theories are model-theoretic conservative with respect to this notion of model expansion.
This strengthens and generalizes the consistency result previously obtained by Kunčar and Popescu [6].
The rest of the paper is structured as follows. We introduce the language of polymorphic higher-order logic and definitional theories in Section 2. Our main results, including a suitable notion of model expansion and a proof of model-theoretic conservativity, are presented in Section 3. We give an overview of related work in Section 4 and conclude with a discussion of future work, in particular with regard to proof-theoretic conservativity, in Section 5.

Background
This section introduces the language of polymorphic higher-order logic (HOL), def- initional theories and their semantics. We follow the notation and naming conven- tions of [6], to which we refer the reader for additional motivation and examples. We do not describe the deductive system of HOL [10], since it is not relevant in the context of this paper.

The Language of Polymorphic HOL
The syntax of polymorphic HOL is that of the simply-typed lambda calculus, en- riched with a first-order language of types. We fix an infinite set TVar of type variables, ranged over by α, β, and an infinite set Var of (term) variables, ranged over by x, y.
A signature is a four-tuple (K, arOf, Const, tpOf), where K is a countable set of symbols called type constructors, and Const is a countable set of symbols called constants. These sets are assumed to be disjoint. Each type constructor has an associated arity that is given by the function arOf: K → N. Each constant has an associated type that is given by the function tpOf: Const → Type, where the set Type, ranged over by σ, τ , is defined inductively as the smallest set such that
TVar ⊆ Type, and
(σ1,..., σn)k ∈ Type whenever k ∈ K, arOf(k)= n and σ1, ..., σn ∈ Type. When arOf(k)=0 we write k for the type ()k.
For the remainder of this paper, we will assume a fixed signature. Moreover, we
assume that K contains the following built-in type constructors:
bool of arity 0,
ind of arity 0,
⇒ a right-associative type constructor of arity 2.
We also assume that Const contains the following built-in constants:
→ of type bool ⇒ bool ⇒ bool,
= of type α ⇒ α ⇒ bool,
some of type (α ⇒ bool) ⇒ α,
zero of type ind,
succ of type ind ⇒ ind.
We say that a type σ is built-in if either σ = bool or σ = ind or if there exist types σ1, σ2 ∈ Type such that σ = σ1 ⇒ σ2.
A type substitution is a function ρ : TVar → Type that replaces type variables by types. We denote the set of type substitutions by TSubst. Generally we extend a type substitution ρ to a function on Type by defining, for each type constructor k ∈ K,
ρ (σ1,..., σarOf(k))k := ρ(σ1),..., ρ(σarOf(k)) k

Let σ, σj be two types. If there exists a type substitution ρ ∈ TSubst such that
ρ(σ)= σj we write σj ≤ σ and say that σj is an instance of σ.
The set of constant instances CInst is a subset of the cartesian product Const × Type, where (c, σ) ∈ CInst if and only if σ is an instance of tpOf(c). We use cσ as shorthand notation for the tuple (c, σ). We extend this notation to other terms,
e. g. typed variables, defined below. We say that cσ is an instance of c. A constant instance is built-in if it is an instance of a built-in constant.
The terms of our language are given by the following grammar, for x ∈ Var,
σ, σj ∈ Type, and cσ ∈ CInst:
t	::=	xσ	|	cσ	|	(tσ′⇒σ tσ′ )σ	|	(λxσ′ .tσ)σ′⇒σ
We may write t for tσ when there is no risk of ambiguity. We require all terms to be well-typed, i. e. in t tj the type of tj has to be the same as the argument type of t. Equality of terms is considered modulo α-equivalence. The set of all terms is denoted by Term. We say that a term is closed if it does not contain any free (term) variables. We extend tpOf to terms by defining tpOf(tσ) := σ.
For u ∈ Term ∪ Type, we write TV(u) for the set of type variables that occur syntactically in u. We can apply a type substitution ρ to a term t, written ρ(t), by applying ρ to all type variables that occur in t.
For a set S of types, constants or constant instances, we define S• to mean the subset of all items that are not built-in. For instance, Type• is the set of all types that are not built-in, and CInst• is the set of all constant instances that are not built-in., i. e. that are not an instance of a built-in constant.
We define a function types• : Term ∪ Type → P(Type•) to collect all non-built-in types that occur in a given term or type. For k not a built-in type constructor, we define types•((σ1,..., σn)k) := {(σ1,..., σn)k}, i. e. types• does not recurse into the argument types of non-built-in type constructors. For instance, if K contains a type constructor list of arity 1 (written in postfix notation), types•(α list ⇒ bool)= 
{α list}. Likewise, we define a function consts• : Term → P(CInst•) to collect all non-built-in constant instances that occur in a given term.
We say thata type is ground if it contains no type variables. The set of ground types is denoted by GType. We denote the set of type substitutions that map type variables to ground types only by GTSubst. A constant instance cσ ∈ CInst is ground if its type σ is ground. We denote the set of ground constant instances by GCInst.
Definitional Theories
Definitional theories are theories that consist of definitions u ≡ t, with the constant instance or type u that is being defined on the left-hand side, and the defining term t on the right-hand side. Constant instances are defined by a term, and types are defined by a predicate.
Definition 2.1 [Definitional Theory]
A constant instance definition is of the form cσ ≡ t with cσ ∈ CInst•, t ∈ Term a

closed term of type σ, and TV(t) ⊆ TV(σ).
A type definition is of the form τ ≡ t with τ ∈ Type• \ TVar, t ∈ Term a closed term of type σ ⇒ bool (for some σ ∈ Type), and TV(t) ⊆ TV(τ ).
A definitional theory is a finite set of (constant instance or type) definitions.
The semantics of ≡ is described further below.
First introduced in [6], certain definitional theories guarantee consistency, i. e. the existence of a model. These are the so-called well-formed definitional theories. Well-formedness requires orthogonality of definitions, which we define next.
Definition 2.2 [Orthogonality] We say two types σ and τ are orthogonal, writ- ten σ # τ , if they have no common instance.
We extend this notion to constant instances by defining cσ # dτ to mean c /= d
or σ # τ .
We say a definitional theory D is orthogonal if for all distinct elements u ≡ t, uj ≡ tj ∈ D either one is a type definition and the other is a constant instance definition, or both are of the same kind and u and uj are orthogonal.
Moreover, as motivated by the example in Section 1, well-formedness requires that there are no circular dependencies between definitions. We introduce a binary relation, written ~, on non-built-in types and non-built-in constant instances, to record the types and constant instances on which a definition depends, i. e. the types and constant instances that occur within the right-hand side of a definition.
Definition 2.3 [Dependency Relation] Let D be a definitional theory. For u, v ∈ CInst• ∪ Type• non-built-in constant instances or types, we define u ~D v if one of the following two conditions holds:
∃t ∈ Term,u ≡ t ∈ D such that v ∈ types•(t) ∪ consts•(t), or
∃c ∈ Const• such that u = ctpOf(c) and v ∈ types•(tpOf(c)). In this case, we say that u depends on v.
The relation ~D is determined by the definitional theory D, which we may omit when it is clear from the context. We give simple examples for the dependency relation: trivially ctpOf(c) ~ tpOf(c) holds for any constant c whose type is not built- in. (Note that all built-in constants have a built-in type.) Assume a theory that defines a constant map(α⇒β)⇒α list⇒β list in terms of another constant foldσ. Both map ~ α list and map ~ foldσ hold.
Definition 2.4 [Type-Substitutive Closure] When R is a binary relation on CInst• ∪ Type•, we write R↓ for the type-substitutive closure of R, defined as follows: for sj, tj ∈ CInst• ∪ Type•,
(sj, tj) ∈ R↓	if	∃ρ ∈ TSubst, (s, t) ∈ R : sj = ρ(s) and tj = ρ(t)
Thus, the type-substitutive closure extends R to its image under arbitrary type substitutions.

We say that a binary relation R is terminating if there exists no infinite se- quence (ai)i∈N such that ai R ai+1 for all i ∈ N.
The previous definitions allow us to introduce well-formed definitional theories.
Definition 2.5 [Well-formed Definitional Theory] A definitional theory D is well- formed if it is orthogonal and the type-substitutive closure of its dependency rela- tion ~D is terminating.
A main result of [6] is that each well-formed definitional theory has a model.
Models of Definitional Theories
We now define the semantics of constant instance and type definitions, as well as a semantics of polymorphic HOL (called ground, fragment-localized semantics in [6]) that interprets ground types as sets, and ground terms as elements of these sets.
A formula is a term of type bool. We let Fmla, ranged over by ϕ, denote the set of formulas. We assume that the usual formula connectives and quantifiers are present in the signature, and that they are defined in the standard way (cf. [10,
§2.4.2]), starting from the built-in constants implication and equality.
Definition 2.6 [Semantics of ≡]
A constant instance definition cσ ≡ t stands for the formula σ . .

A type definition τ ≡ t stands for the formula
c = t

(∃xσ. t x) →
∃repτ ⇒σ. ∃absσ⇒τ .
.	.
(∀yτ . t (rep y)) ∧ (∀yτ . abs (rep y) = y) ∧ (∀xσ. t x → rep (abs x) = x).
As expected, a constant instance definition equates the constant instance with the defining term. A type definition asserts the existence of an isomorphism between the type τ and the subset of σ that is given by the predicate t, provided this subset is non-empty.
For a set of types T ⊆ Type let Cl(T ) denote the built-in closure of T , defined inductively as the smallest set such that
T ∪ {bool, ind}⊆ Cl(T ), and
σ1 ⇒ σ2 ∈ Cl(T ) whenever σ1, σ2 ∈ Cl(T ).
Thus, Cl(T ) contains those types that can be constructed from T by repeated ap- plication of built-in type constructors.
Recall that GType• is the set of ground non-built-in types, and GCInst• is the set of ground non-built-in constant instances. We first interpret (fragments of) these sets, before extending the semantics to built-in types and terms as well as polymorphic (i. e. non-ground) formulas.
Definition 2.7 [Signature Fragment] A (signature) fragment is a pair (T, C), with
T ⊆ GType• and C ⊆ GCInst•, such that σ ∈ Cl(T ) for all cσ ∈ C.

When F = (T, C) is a fragment, we write TypeF := Cl(T ) for the types generated by this fragment, TermF := {t ∈ Term | types•(t) ⊆ T ∧ consts•(t) ⊆ C} for the terms that fall within this fragment, and FmlaF := Fmla ∩ TermF for its formulas.
The significance of fragments lies in the fact that TermF is closed under taking subterms, and that tpOf(t) ∈ TypeF for each t ∈ TermF . These properties allow us to define semantic interpretations for fragments, independent of the interpretation of terms or types outside the fragment.
We fix a two-element set B := {true, false}, and we assume a global choice func- tion, choice, such that choice(A) ∈ A for each non-empty set A. (We will use these to define the semantics of the built-in type bool and the built-in constant some, respectively.) We also fix a singleton set { }.
Definition 2.8 [Fragment Interpretation] Let F = (T, C) be a fragment. We define an F-interpretation as a pair of families I = (([τ ])τ∈T , ([cσ])cσ∈C ) that satisfy two conditions:
For all τ ∈ T , the set [τ ] is non-empty.
We extend the family ([τ ])τ∈T to a family ([τ ])τ∈Cl(T ) by interpreting the built-in type constructors as expected: [bool] := B, [ind] := N, 3 and [σ ⇒ τ ] := [σ] → [τ ], i. e. the set of functions from [σ] to [τ ].
For all cσ ∈ C, we have [cσ] ∈ [σ].
Let GBIF denote the set of ground built-in constant instances whose type is

in TypeF . We extend the family ([cσ])c ∈C to a family ([cσ])
cσ∈C∪GBI
F by interpreting

the built-in constants as expected (cf. [6, §4.4]): e. g. [→bool⇒bool⇒bool] as logical

implication,
.
[=τ⇒τ⇒bool
] as the equality relation on [τ ], etc.

In other words, by interpreting the built-in type constructors and constants as expected, each F -interpretation I = (([τ ])τ∈T , ([cσ])cσ∈C ) gives rise to a pair of
([τ ]	), ([c ])	F	[τ ]I	[τ ]F,I
σ
similarly for constant instances) to indicate the interpretation I and the fragment F .
Given an F -interpretation I, we call a function ξ : Var × TypeF →  σ∈TypeF [σ]I a valuation for I if each variable is mapped to a value of its type, i. e. if ξ(xσ) ∈ [σ]I for each xσ ∈ Var × TypeF . Let ValI denote the set of valuations for I.
With this setup we can interpret the terms in TermF according to an F - interpretation I. Let t ∈ TermF be a term that falls within the fragment. We recursively define the function [t]: ValI → [tpOf(t)] in the expected way over the structure of terms:
[xσ](ξ) := ξ(xσ)
[cσ](ξ) := [cσ]
[t1 t2](ξ) := [t1](ξ)([t2](ξ))
[λxσ. t](ξ): [σ] → [tpOf(t)],a '→ [t](ξ(xσ → a))

3 As noted in [6], any infinite set would do here.

In the last clause, ξ(xσ → a) denotes a function that takes the value a at xσ and otherwise agrees with ξ. Kunčar and Popescu motivate the correctness of this recursive definition [6, Lemma 8.(5)].
For closed terms t, the interpretation does not depend on the particular valuation: the function [t] is constant. We now restrict our attention to closed formulas.
For ϕ ∈ FmlaF a ground formula, we say that I is a model of ϕ, written I |= ϕ, if [ϕ]£ = true. We call the fragment T := (GType•, GCInst•) the total fragment. If I is a T-interpretation and ϕ is a polymorphic formula, we say that I is a model of ϕ, also written I |= ϕ, if I |= ρ(ϕ) for all ground type substitutions ρ ∈ GTSubst. We extend this notion to sets of formulas, by defining I |= S as I |= ϕ for all ϕ ∈ S.

Results
A main result of Kunčar and Popescu is that each well-formed definitional the- ory has a model; more precisely, each well-formed definitional theory D has a T- interpretation I such that I |= D [6, Theorem 11]. Consequently, each such theory is consistent [6, Theorem 6]. We strengthen and generalize these results.

Model-theoretic Conservativity
To establish model-theoretic conservativity for definitional theories, we need to show that whenever a well-formed definitional theory D is extended to another well-formed definitional theory Dj := D ∪· {u ≡ t}, then any model M of D can be expanded to a model Mj of Dj.
Note that we assume D and Dj to be theories over the same signature. Therefore, a priori it is not entirely clear what it means here to expand M. In particular, M already interprets u and t. Unless M |= u ≡ t, the model Mj will need to interpret at least some type or constant instance differently.
Moreover, the counterexample given in Section 1 demonstrates that it is in gen- eral not sufficient to alter the interpretation of u in Mj. There may be other types or constant instances that depend on u (or on one of its type instances), and their interpretations may need to be adjusted as well. Our main result is that these are the only types and constant instances whose interpretation may need to change.
When R is a binary relation, we write R∗ for the reflexive-transitive closure of R.
Lemma 3.1 Let D be a definitional theory, and let u ∈ CInst• ∪ Type•. We write Vu for the pre-image of type instances of u under the reflexive-transitive, type- substitutive closure of the dependency relation ~D, i. e.
Vu :=  v ∈ CInst• ∪ Type• | ∃ρ ∈ TSubst. v (~↓)∗ ρ(u), .
Then Fu := (GType• \ Vu, GCInst• \ Vu) is a fragment.
Proof. Let cσ ∈ GCInst• \ Vu be a ground constant instance of type σ. Assume that σ ∈/ Cl(GType• \Vu). Then there must be a type τ ∈ types•(σ) such that τ ∈ Vu.

But then cσ
~↓ τ (cf. [6, Lemma 4.(2)]) and
τ (~↓)∗
ρ(u)
for some ρ ∈ TSubst.

Hence cσ
(~ ) ρ(u), contradicting cσ
∈/ Vu.	2

Definition 3.2 [Independent Fragment] In the situation of the preceding Lemma 3.1 we call Fu the u-independent fragment.
Theorem 3.3 (Model-theoretic Conservativity) Let M be a model of a well- formed definitional theory D, i. e. M |= D. Moreover, let Dj := D ∪· {u ≡ t} be a well-formed extension of D. There exists a model Mj of the extended theory Dj with the following property: the models M and Mj agree on the interpretation of all types and terms in TypeFu ∪ TermFu .
In other words, M and Mj, as obtained from Theorem 3.3, agree on the interpre- tation of all (ground) types and terms that fall within the u-independent fragment.
Proof. Since all models interpret the built-in type constructors and constants in the same way, it suffices to construct a model Mj of Dj that agrees with M on the inter- pretation of (non-built-in, ground) types and constant instances in the fragment Fu.

As before, let V
:= v ∈ CInst• ∪ Type• | ∃ρ ∈ TSubst
↓ ∗	,.

Hence for v ∈ (GType• \ V ) ∪ (GCInst• \ V ), we define [v]n′ := [v]n. This yields an interpretation for the fragment Fu where Mj agrees with M by definition.
It remains to define [v]n′ for v ∈ (GType• ∪ GCInst•) ∩ V . We proceed by
well-founded recursion over (~↓)+, the transitive closure of ~↓, restricted to the

set (GType• ∪ GCInst•) ∩ Vu
. (Note that (~↓)+ is a terminating relation because

the theory is well-formed.) This is analogous to the model construction in [6]. Assume the interpretation [w]n′ has been defined for all w ∈ GType• ∪ GCInst• with v (~↓)+ w.
We consider two cases. We say a definition (s ≡ r) ∈ Dj matches v if there is a type substitution ρ ∈ TSubst such that v = ρ(s), meaning v is a type instance of s. In this case, we note that the matching definition is uniquely determined (due to orthogonality), and that [ρ(r)]n′ is defined by recursion. (Strictly speaking, only [ρ(r)]F,I is defined, where F is a sufficiently large fragment with ρ(r) ∈ TermF , and I is the restriction of Mj to F . However, the two values coincide [6, Lemma 9].) Following the model construction in [6], we define [v]n′ such that Mj |= v ≡ ρ(r).
On the other hand, if there is no matching definition for v in Dj, then v ∈ Vu implies that v must be a constant instance, i. e. v = cσ for some cσ ∈ GCInst•. (Note that undefined types do not depend on other types or constant instances.) Again following the model construction in [6], we define [v]n′ := choice([σ]n′ ).
Since M is a T-interpretation, it is immediate that Mj is a T-interpretation. It remains to show that Mj |= Dj. Let (s ≡ r) ∈ Dj, and let ρ ∈ GTSubst be a ground type substitution. Clearly s ≡ r is a (and due to orthogonality, the unique) matching definition for ρ(s). Hence if ρ(s) ∈ Vu, then by the first case above, [ρ(s)]n′ is defined such that Mj |= ρ(s) ≡ ρ(r). On the other hand,
if ρ(s) ∈/ Vu, then types•(ρ(r)) ⊆ GType• \ Vu and consts•(ρ(r)) ⊆ GCInst• \ Vu,
hence ρ(r) ∈ TermFu . Therefore [ρ(s)]n′ = [ρ(s)]n and [ρ(r)]n′ = [ρ(r)]n. More-

over, ρ(s) ∈/ Vu implies s /= u. Hence (s ≡ r) ∈ D in this case, and Mj |= ρ(s) ≡ ρ(r)
follows from M |= D.	2
Our approach expands any existing model M of a well-formed definitional the- ory D to a model of the well-formed theory extension Dj. A model of the ex- tended theory is constructed by recursion over part of the ~↓ relation, based on the model M. In contrast, the model construction in [6] obtains a model from the ground up, by recursion over the entire ~↓ relation, without reference to any previous interpretation.
As a consequence of the previous theorem we obtain the result [6, Theorem 11]:
Corollary 3.4 Any well-formed definitional theory has a model.
Proof. Let D be a well-formed definitional theory. Clearly, the empty theory has a model. (This can be obtained, e. g. by interpreting non-built-in types as { }, and non-built-in constant instances using choice, cf. the model construction given in [6].) Moreover, every subset of D is a well-formed definitional theory. The corollary immediately follows by induction over |D|, which is finite.	2
Since the deduction rules of polymorphic HOL are sound w. r. t. our semantics [6, Theorem 10], the existence of a model immediately implies the (syntactic) consis- tency of well-formed definitional theories [6, Theorem 6].
Corollary 3.5 Any well-formed definitional theory is consistent.
Related Work
Extensions by definitions have a long history. In 1967, Shoenfield [12, §4.6] discussed two definitional mechanisms for extensions of theories in (untyped) first-order logic by predicate and function symbols. A new symbol is defined by an equivalence or equality whose right-hand side must not contain the new symbol. For function symbols, the definition must be accompanied by a proof that this equality describes a function in the mathematical sense. Both mechanisms are shown to be proof- theoretic conservative. Moreover, each model of the original theory has a unique expansion that is a model of the extended theory; this immediately implies model- theoretic conservativity.
In 1997, Wenzel [13] discussed the theoretical foundation for overloaded defini- tions and type classes in higher-order logic. He “consider[s] syntactic conservativity as a minimum requirement for well-behaved extension mechanisms within purely deductive logical frameworks.” Additionally Wenzel introduces realisability, which formalises the intuition that constant definitions can be unfolded, and shows that overloaded constant definitions are both conservative and realisable. However, he assumes that all instances of an overloaded constant are defined at once, and he does not consider the interplay of overloading with type definitions (cf. the example in Section 1).
In 2006, Obua [11] noted that to avoid inconsistencies, the process of unfolding definitions must terminate. He shows that for overloaded definitions that recurse

through types, termination is not semi-decidable in general. Obua considers both type and constant definitions and gives a proof sketch that overloading in Isabelle is conservative, but he misses that dependencies through types may introduce incon- sistencies.
Most closely related is the already mentioned work by Kunčar and Popescu [6], who in 2015 introduced definitional theories for Isabelle and show that they pre- serve consistency, i. e. every well-formed definitional theory has a model. In [7], the same authors prove syntactic consistency (i. e. False is not derivable) of definitional theories by a proof-theoretic argument. They introduce a richer logic, HOL with comprehension types (HOLC), into which they encode formulas of HOL by unfolding type and constant definitions. This encoding preserves derivability. The consistency of definitional theories then follows from the consistency of HOLC.
In a recent work [8], Kunčar and Popescu show a much stronger result: using a different unfolding approach that relativises formulas involving defined types to a predicate on the host type (and thus stays within the language of HOL), they es- tablish proof-theoretic conservativity of definitional theories over minimal HOL, i. e. relative to an empty theory that contains no axioms. In contrast, the present paper proves model-theoretic conservativity relative to arbitrary (well-formed) definitional theories.
Other theorem provers for higher-order logic, e. g. HOL4 [10, §2.5.2], implement a more general mechanism for constant specification. This mechanism, which in its current form was suggested by Arthan [2], allows implicit definitions. It takes as
input a theorem of the form 1 .  1	n .  n	(where the vi are variables) and
introduces new constants c1, ..., cn with P [c1/v1,..., cn/vn] as their defining axiom.
Conventional constant definitions c ≡ t are recovered as a special case when P is of

the form
.
v = t
. Constant specification is proof- and model-theoretic conservative [3],

and has been formalised and verified using HOL4 by Kumar et al. [4]. However, in contrast to Isabelle, which supports ad hoc overloading natively in its logic, other theorem provers for higher-order logic offer support for overloading only as syntactic sugar, through extensions of parsing and pretty-printing.

Conclusion
We defined a notion of model expansion that is suitable for definitional theories, and we showed that extensions of definitional theories are model-theoretic conservative with respect to this notion. This strengthens and generalizes an earlier consistency result for definitional theories [6]. We have thereby established an important prop- erty of the definitional mechanisms that are implemented in the theorem prover Isabelle.
Model-theoretic conservativity has a proof-theoretic (syntactic) counterpart. Roughly, an extension is proof-theoretic conservative if it entails no new theorems in the original language. In other words, every formula of the original language that is a theorem in the extension is already provable in the original theory. Adapting this notion to definitional theories, we conjecture that if Dj is an extension of D such

that Dj ≡ ϕ, where ϕ is a formula that does not contain any constant instance or type that depends on definitions in Dj \ D, then D ≡ ϕ.
For logics that have a sound and complete deductive system, model-theoretic conservativity implies proof-theoretic conservativity: suppose Dj ≡ ϕ. By complete- ness it suffices to show that ϕ holds in all models of D. Let M be a model of D. By model-theoretic conservativity, M can be expanded to a model Mj of Dj that agrees with M on the interpretation of ϕ. Since Dj ≡ ϕ, soundness implies that Mj is a model of ϕ. Hence M is a model of ϕ.
Unfortunately, this argument does not immediately apply to higher-order logic, which is not complete with respect to its standard semantics [10, §2.4.5]. However, higher-order logic is complete with respect to non-standard (Henkin) semantics [1,
§55]. By adapting the completeness proof to the variant of higher-order logic im- plemented in Isabelle and to the novel (ground, fragment-localized) semantics of polymorphic types suggested in [6], it may be possible to derive proof-theoretic conservativity for extensions of definitional theories from their model-theoretic con- servativity. It would also be interesting to study the connection between the ground, fragment-localized semantics and the traditional set-theoretic semantics of higher- order logic in more detail. We leave this to future work.

References
Andrews, P. B., “An Introduction to Mathematical Logic and Type Theory: To Truth through Proof,” Number 27 in Applied logic series, Kluwer Academic Publishers, Dordrecht ; Boston, 2002, 2nd ed edition.
Arthan, R., HOL Constant Deﬁnition Done Right, in: Interactive Theorem Proving (2014), pp. 531– 536.
URL  http://dx.doi.org/10.1007/978-3-319-08970-6_34
Arthan, R., On Deﬁnitions of Constants and Types in HOL, Journal of Automated Reasoning 56
(2016), pp. 205–219.
URL  http://dx.doi.org/10.1007/s10817-016-9366-4
Kumar, R., R. Arthan, M. O. Myreen and S. Owens, HOL with Deﬁnitions: Semantics, Soundness, and a Veriﬁed Implementation, in: Interactive Theorem Proving (2014), pp. 308–324.
URL  http://dx.doi.org/10.1007/978-3-319-08970-6_20
Kunčar, O., Correctness of Isabelle’s Cyclicity Checker: Implementability of Overloading in Proof Assistants, in: Proceedings of the 2015 Conference on Certiﬁed Programs and Proofs, CPP ’15 (2015),
pp. 85–94.
URL http://doi.acm.org/10.1145/2676724.2693175

Kunčar, O. and A. Popescu, A Consistent Foundation for Isabelle/HOL, in: C. Urban and X. Zhang, editors, Interactive Theorem Proving, number 9236 in Lecture Notes in Computer Science, Springer International Publishing, 2015 pp. 234–252.
URL  http://dx.doi.org/10.1007/978-3-319-22102-1_16

Kunčar, O. and A. Popescu, Comprehending Isabelle/HOL’s Consistency, in: H. Yang, editor, Programming Languages and Systems - 26th European Symposium on Programming, ESOP 2017, Held as Part of the European Joint Conferences on Theory and Practice of Software, ETAPS 2017, Uppsala, Sweden, April 22-29, 2017, Proceedings, Lecture Notes in Computer Science 10201 (2017),
pp. 724–749.
URL  https://doi.org/10.1007/978-3-662-54434-1_27

Kunčar, O. and A. Popescu, Safety and Conservativity of Deﬁnitions in HOL and Isabelle/HOL, Proc. ACM Program. Lang. 2 (2017), pp. 24:1–24:26.
URL http://doi.acm.org/10.1145/3158112

Nipkow, T., L. C. Paulson and M. Wenzel, “Isabelle/HOL - A Proof Assistant for Higher-Order Logic,” Number 2283 in Lecture Notes in Computer Science, Springer, 2002.
URL  https://doi.org/10.1007/3-540-45949-9


Norrish, M. and K. Slind, The HOL System LOGIC (2014).
URL   http://downloads.sourceforge.net/project/hol/hol/kananaskis-10/kananaskis-10-logic.
pdf

Obua, S., Checking Conservativity of Overloaded Deﬁnitions in Higher-Order Logic, in: Term Rewriting and Applications (2006), pp. 212–226.
URL http://dx.doi.org/10.1007/11805618_16
Shoenfield, J. R., “Mathematical Logic,” A.K. Peters, Natick, Mass, 1967.
Wenzel, M., Type classes and overloading in higher-order logic, in: E. L. Gunter and A. Felty, editors, Theorem Proving in Higher Order Logics, number 1275 in Lecture Notes in Computer Science, Springer Berlin Heidelberg, 1997 pp. 307–322.
URL http://dx.doi.org/10.1007/BFb0028402
