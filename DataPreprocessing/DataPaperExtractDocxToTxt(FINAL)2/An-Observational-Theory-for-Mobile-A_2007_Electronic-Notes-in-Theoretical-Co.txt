

Electronic Notes in Theoretical Computer Science 173 (2007) 275–293
www.elsevier.com/locate/entcs

An Observational Theory for Mobile Ad Hoc Networks
Massimo Merro1
Department of Computer Science University of Verona
Verona, Italy

Abstract
We propose a process calculus to study the observational theory of Mobile Ad Hoc Networks. The operational semantics of our calculus is given both in terms of a Reduction Semantics and in terms of a Labelled Transition Semantics. We prove that the two semantics coincide. The labelled transition system is then used to derive the notions of simulation and bisimulation for ad hoc networks. As a main result, we prove that the (weak) labelled bisimilarity completely characterises (weak) reduction barbed congruence, a
standard, branching-time, contextually-defined program equivalence. We then use our (bi)simulation proof methods to formally prove a number of non-trivial properties of ad hoc networks.
Keywords: Ad hoc networks, process calculi, structural operational semantics, bisimulation.


Introduction
Wireless technology has exploded in popularity in the last years. Its applications span from user applications such as personal area networks, ambient intelligence, and wireless local area networks, to real-time applications, such as cellular and ad hoc networks.
Ad hoc networking is a new area in wireless communications that is attract- ing the attention of many researchers, for its potential to provide ubiquitous con- nectivity without the assistance of any fixed infrastructure. A Mobile Ad Hoc Net- work (MANET) is an autonomous system composed of both stationary and mobile devices communicating with each other via radio transceivers. Mobile devices are free to move randomly and organise themselves arbitrarily; thus, the network’s wireless topology may change rapidly and unpredictably. Stationary devices cannot move i.e. their physical location does not vary with time. The network may operate in a standalone fashion, or may be connected to the larger Internet. MANETs can

1 Email: Massimo.Merro@univr.it



1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2007.02.039

be used wherever a wired backbone is infeasible and/or economically inconvenient, for example, to provide communications during emergencies, special events (expos, concerts, etc.), or in hostile environments.
Wireless devices use radio frequency channels to broadcast messages to the other devices. However, this form of broadcast is quite different from the more conven- tional wired-based broadcast that we find in networks with Ethernet and that, from a semantic point of view, is well-understood [19,20,6]. First, in Ethernet-like systems broadcasting is global, i.e., the messages transmitted reach all nodes of the system. By contrast, in wireless system broadcasting is local, i.e., a transmission spans over a limited area, called cell, and therefore reaches only a -possibly empty- subset of the devices in the system. Actually, even the devices within a cell might not be reachable due to environmental conditions such as walls, obstacles, etc. Second, in wireless systems channels are half-duplex : on a given channel, a device can either transmit or receive, but cannot do both at the same time. Hence, an interference between two transmissions is only possibly detected by receivers located in the in- tersection of the cells of the two transmitters. Interference is thus a delicate aspect of wireless systems that is handled by means of specific protocols (e.g., CSMA/CA). In mobile ad hoc networks there is a further catch: the set of nodes that lie within the cell of a node can change unpredictably due to node movement or node
failure, thereby altering the set of nodes that can receive a transmitted message.
Contribution
We present the Calculus of Mobile Ad Hoc Networks (CMN), a process calculus to study the observational theory of mobile ad hoc networks. In CMN, a network is modelled as a collection of nodes (which represent devices), running in parallel, and using channels to broadcast messages. Channels can be either public or private to

a set of nodes. We write n[P ]μ
to denote a node with network address n, located

at the physical location l, with transmission radius r, mobility tag μ, and executing the sequential process P . The location l and the transmission radius r define the cell over which a node can broadcast values using channels; by no means a node is capable to derive its current physical location l or its transmission radius r. The mobility tag μ serves to distinguish between mobile nodes and stationary nodes.
We assume the presence of appropriate protocols to avoid transmission collisions. The operational semantics of our calculus is given both in terms of a Reduction Semantics and in terms of a Labelled Transition Semantics, in the SOS style of Plotkin [18]. We prove that the two semantics coincide. Our Labelled Transition System (LTS) captures all the possible interactions of a term with its environment without using any auxiliary discard relation. We then define an appropriate notion of simulation and hence of bisimulation for MANETs. The concepts of simulation and bisimulation are widely used in the literature for verification purposes: they
represent the basis of many verification tools.
The main goal of the paper is to establish when two networks have the same observable behaviour, that is, they are indistinguishable in any context. In this paper, we focus on reduction barbed congruence [7], a slight variant of Milner and


Names:	a, b,... , k, l, m, n,... ∈ N
Networks:
M, N ::= 0	empty network
	M1 | M2	parallel composition
	(νc)M	channel restriction


Processes:
	n[P ]l,r
node (or device)

P, Q, R ::= 0	inactive process
	c(x).P	input
	c⟨w⟩.P	output
	[w1 = w2]P, Q	matching
	A⟨v˜⟩	recursion
Mobility tags:
μ ::= m	mobile
	s	stationary

Table 1 The Syntax

Sangiorgi’s barbed congruence [13], a branching-time congruence that preserves the observables of the language. The definition of reduction barbed congruence is simple and intuitive. In practise, however, it is difficult to use: the quantification on all contexts is a heavy proof obligation. Simpler proof techniques are based on labelled bisimilarities [16,11]. As a main result, we prove that our (weak) labelled bisimilarity completely characterises reduction barbed congruence. We then use our observational theory to prove a number of non-trivial properties of MANETs.
Proofs are sketched or omitted. Full proofs can be found in [8].

The Calculus
In Table 1, we define the syntax of CMN in a two-level structure, a lower one for
processes and an upper one for networks.
We use letters m and n for nodes/devices; c and d for channels; k and l for (physical) locations; x, y, z for variables. Closed values contain the previous entities except for channels and variables. Values include also variables. We use u and v for closed values and w for (open) values. We write a˜ to denote a tuple a1,... , ak

of names.
Networks are collections of nodes (which represent devices), running in parallel, using channels to broadcast messages. The symbol 0 denotes the empty network. M1 | M2 represents the parallel composition of two networks. In (νc)M the channel c is private to the network M . Unlike other name-passing calculi, such as the π- calculus [12], the restriction operator (νc)M models only channel restriction but not channel creation. This is because the number of available channels in a wireless system is standardised by frequency throughout the world (13 for Europe, 11 for North America, and 14 for Japan).
Processes are sequential and live within the nodes. Process 0 denotes the inactive processes. The input process c(x).P can receive any (closed) value v via channel c and continue as P , with v substituted for x. The output process c⟨v⟩.P can send the (closed) value v via channel c and continue as P . Process [v1 = v2]P, Q is the standard “if then else”: it behaves as P if v1 = v2, and as Q otherwise. We write
A⟨v˜⟩ to denote a process defined via a (possibly recursive) definition A(x˜) d=ef P ,
with | x˜ |=| v˜ |, where x˜ contains all channels and variables that appear free in P .
Each node has a location and a transmission radius. Nodes cannot be created

or destroyed. We write n[P ]μ
for a node named n, located at l, with transmission

radius r, mobility tag μ, and executing process P . The node identifier n represents a logical location –the device network address. By contrast, l represents a physical location and, together with the radius r, is employed for deriving information about the network connectivity. The mobility tag μ can be m for mobile nodes, and s for stationary nodes, i.e. nodes that never change their physical location.
We do not indicate how locations should be specified; for instance, they could be given by means of a coordinate system. In the definition of the operational semantics, we assume the possibility of comparing locations so to determine whether a node lies or not within the transmission cell of another node. We do so by means of a function d(·, ·) which takes two locations and returns their distance. In Section 5, we also assume some intuitive meta-operators on locations.
In the process c⟨w⟩.P value w appears in output position; the function op(·) returns the set of values appearing in output position in a process. In the process c(x).P variable x is bound in P , giving rise to the standard notions of α-conversion and free and bound variables, denoted with fv(·) and bv(·), respectively. Similarly, in a network of the form (νc)M the channel name c is bound in M and the notions of α-conversion and free and bound channels, fc(·) and bc(·), are defined accordingly. We write {v/x}P for the capture avoiding substitution of x for v in P . We will identify processes and networks up to α-conversion. More formally, we will view terms as representatives of their equivalence class with respect to ≡α, and these representatives will always be chosen so that bound names are distinct from free names.
A (monadic) context C[·] is a network term with a hole, denoted by [·]. Contexts are generated by the following grammar:

C[·] ::= [·]		[·] | M		M | [·]		(νc)[·] .



def
μ	v˜	μ

A(x˜) = P ∧ | x˜ | = | v˜ | implies n[A⟨v˜⟩]l,r ≡ n[{ /x˜}P ]l,r	(Struct Proc)
M | N ≡ N | M	(Struct Par Comm)
(M | N ) | M ' ≡ M | (N | M ')	(Struct Par Assoc)
M | 0 ≡ M	(Struct Zero Par)
(νc)0 ≡ 0	(Struct Zero Res)
(νc)(νd)M ≡ (νd)(νc)M	(Struct Res Res)
c /∈ fc(M ) implies (νc)(M | N ) ≡ M | (νc)N	(Struct Res Par)
[w = w]P, Q ≡ P	(Struct Then)
[w1 = w2]P, Q ≡ Q	if w1 /= w2	(Struct Else)
M ≡ M	(Struct Refl)
M ≡ N implies N ≡ M	(Struct Symm)
M ≡ N ∧ N ≡ O implies M ≡ O	(Struct Trans)
M ≡ N implies M | M ' ≡ N | M ', for all M '	(Struct Cxt Par)
M ≡ N  implies (νc)M ≡ (νc)N, for all c	(Struct Cxt Res)

Table 2 Structural Congruence

We use a number of notational conventions. Parallel composition of networks has lower precedence with respect to restriction. i∈I Mi means the parallel com- position of all networks Mi, for i ∈ I. We write (νc˜)M as an abbreviation for (νc1) ... (νck)M . We write c⟨w⟩ for c⟨w⟩.0, and 0 for n[0]μ . Finally, we write
[w1 = w2]P for [w1 = w2]P, 0.
We assume that there are no free variables in a network (in contrast, there can be free channels). The absence of free variables is trivially maintained as the network evolves. Moreover, as node identifiers denote device network addresses we assume that in any network each node identifier is unique.

Reduction Semantics
The dynamics of the calculus is specified by the reduction relation over networks, d, described in Table 3. As usual in process calculi, the reduction semantics relies on an auxiliary relation, called structural congruence, ≡, defined in Table 2. Ba- sically, structural congruence brings the participants of a potential interaction into contiguous positions.
Rule (R-Bcast) models the broadcast of a message v using a channel c. Commu- nication is one-to-many and transmission proceeds even if there is no other process


	∀i ∈ I. d(l, li) ≤ r	

(R-Bcast)
n[c⟨v⟩.P ]μ	|	n [c(x ).P ]μi	d n[P ]μ	|	n [{v/x }P ]μi




(R-Move)

n[P ]m
—
d n[P ]m
l,r

(R-Par)
M d M '
M | N d M ' | N




(R-Struct)
M ≡ N	N d N '	N ' ≡ M '
M d M '	(R-Res)
M d M '
(νc)M d (νc)M '


Table 3 Reduction Semantics

listening for a message: transmission is a non-blocking action. Moreover, as with most process calculi, this communication is deemed to occur instantaneously. Note that when a transmission occurs, some receivers within the range of the transmitter might not receive the message. This may be due to several reasons such as the presence of obstacles or the asynchrony of nodes. In particular, when I=∅ the rule models message loss. In terms of observation this corresponds to a local activity on the network which an observer is not party to. Movement is assumed to be an atomic action: while moving a node cannot do anything else. Rule (R-Move) mod- els arbitrary and unpredictable movements of mobile nodes; notice that stationary nodes cannot move. The remaining rules are standard in process calculi.
The symbol d∗ denotes the reflexive and transitive closure of d.
Behavioural Semantics
In operational semantics two terms are deemed equivalent if they have the same observable behaviour in all possible contexts. So, the question is: What are the “right” observables in our calculus? As in CCS [11] and in π-calculus [12], we have both transmission and reception of messages. However, unlike those calculi, only the transmission of messages (over unrestricted channels) can be observed. In fact, in a broadcasting calculus an observer cannot see whether a given process actually

receive a particular broadcasted value. In particular, if the node n[c⟨v⟩.P ]μ
evolves

into n[P ]μ
we cannot be sure that some recipient received message v at channel c.

On the other hand, if a node n[c(x).P ]μ  evolves into n[{v/x}P ]μ , then n can be
sure that some node has transmitted message v on channel c: the network never invents messages!
So, in our calculus the notion of observability is represented by the transmission of messages that can be detected by a pervasive observer i.e. an observer that can listen anywhere, at any channel.
Definition 2.1 We write M ↓c@k if M ≡ (νd˜)(n[c⟨v⟩.P ]μ | M '), with c /∈ d˜ and
d(l, k) ≤ r. We write M ⇓c@k if M d∗ M ' ↓c@k.
In the following, we use R to denote an arbitrary binary relation over networks.




(Input)
—
cv
c(x).P	v
—
(Output) 	cv

−−→−
η
P
{ /x}P

'
c⟨v⟩.P
η
−−→− P

'

(Then)
−−→ P
η
[v = v]P, Q
(Else)
'
Q −−→ Q
v1 /= v2
η	'

−−→ P
{v˜/x˜}P	η

P '	A(x˜) d=ef
[v1 = v2]P, Q

P
−−→ Q

(Rec)
A⟨v˜⟩
−−→ P '

Table 4
Labelled Transition System - Processes

We write R= to denote the symmetric closure of R.
Definition 2.2 A relation R is barb preserving if M R N and M ↓c@k implies
N ⇓c@k.
Definition 2.3 A relation R is reduction closed if M R N and M d M ' imply the existence of some N ' such that N d∗ N ' and M ' R N '.
Definition 2.4 A relation R is contextual if M R N implies C[M ] R C[N ] for all contexts C[−] . 
Finally, everything is in place to define reduction barbed congruence.
Definition 2.5 Reduction barbed congruence, written ∼=, is the largest symmetric relation over networks, which is reduction closed, barb preserving, and contextual.

A Labelled Transition Semantics
Reflecting the language syntax, the Labelled Transition System has two sets of rules: one for processes and one for networks.

η
Table 4 presents the LTS for processes. Transitions are of the form P −−→
P ',

where η ranges over input and output actions. More precisely, cv and cv denote, respectively, input and output of a closed value v at channel c. The rules in Table 4 are self-explanatory.

λ
Table 5 contains the LTS for networks. Transitions are of the form M −−→
M ',

where the grammar for λ is:
λ  ::= c?v@l		c!v[l, r]		c!v@K		τ .

Rule (Rcv) models the reception at l of message v via channel c. Rule (Snd) models the broadcast, with transmission radius r, of message v via channel c, from a node located at l. Rule (Bcast) models the propagation of broadcast. The requirement d(l, l') ≤ r guarantees that only nodes within the transmission cell of the transmitter may hear the communication. Rule (Obs) models the fact that every action c!v[l, r] can be detected (and hence observed ) by any node located in the transmission cell




(Rcv)

n[P ]μ
cv
P −−→− P
c?v@l	' μ

(Snd)
cv
P −−→− P
c	c!v[l,r]	' c

l,r
−−−−→− n[P ]l,r
c!v[l,r]	'


c?v@l'
n[P ]l,r −−−−−→−

'	'
n[P ]l,r

M −−−−−→− M
N −−−−−→ N
d(l, l ) ≤ r

(Bcast)
c!v[l,r]
M | N −−−−−→−
c!v[l,r]
N | M −−−−−→−
M ' | N '
N ' | M '

c!v[l,r]
M −−−−−→− M
KÇ{k : d(l, k)≤r}	K/=∅

(Obs)

c!v[l,r]
M −−−−−→− M
c!v@K
M −−−−−→− M

—

(Lose)
(Move)
'
n[P ]m	τ	m

M −−→ M
k,r
−−→ n[P ]l,r



M −−→ M '

M	λ	'

(Par)
λ
M | N
M ' | N
(Res)
	−−→ M	c /∈ fc(λ)

−−→
λ
N | M −−→

N | M '
(νc)M	λ	(νc)M '

Table 5
Labelled Transition System - Networks

at l with radius r. The action c!v@K represents the transmission of message v via channel c to a set of recipients whose locations are contained in K. This is an observable action: one can imagine a distributed observer listening on channel c and seated at any location of K. Rule (Lose) models both message loss and a local activity on the network which an observer is not party to. We use τ -actions, as usual in name-passing calculi, to denote non-observable actions, i.e. actions that are not detected by the observer. Rule (Move) models the migration of a mobile node from a location k to a new location l. Rule (Par) and (Res) are standard in name-passing calculi. Note that since we do not transmit channels there is no scope extrusion.
We end this section showing that the LTS-based semantics coincides with the reduction semantics given in the previous section in Table 3.
Theorem 3.1 (Harmony Theorem)

τ
If M −−→
M ' then M d M '.

If M d M ' then M	τ
M '.


Bi-simulation Proof Methods
In this section, we use our LTS to define an appropriate notion of simula- tion/bisimulation for ad hoc networks.
For commodity, we use the metavariable α to range over those actions that will

be used in the definition of (bi)simulation. Formally,
α  ::= c?v@l		c!v@K		τ .

Since we are interested in weak behavioural equivalences, that abstract over τ - actions, we introduce the notion of weak action. The definition is not completely standard:
•  =⇒ denotes the reflexive and transitive closure of	τ  ;

====⇒=
c?v@l
denotes =⇒ −−−−→−
=⇒;

•  ==c!=v=@=K⇒=
denotes =
c!v@K1
=⇒ ... =
c!v@Kn
=⇒, for  n
K = K;


αˆ
⇒ −−−−−−→
α
⇒ −−−−−−→
i=1	i

==⇒ denotes =⇒ if α = τ and ==⇒ otherwise.

c!v@K

Notice that the definition of the weak observable action
=====⇒=
may contain

several (strong) observable actions of the form	c!v@Ki
. This is because a distrib-

uted observer that receives in several computation steps an instance of message v at each location in K cannot assume that those messages belong to the same multicast send.
Definition 4.1 A binary relation R over networks is a simulation if M R N im- plies:

If M	'
'	αˆ	'	'	'

c?v@l
−−−−−→ M
then there is N '
such that:

· either N
c?v@l
=====
N ' and M '
R N '

· or N =⇒ N ' and M ' R N '.
We say that N simulates M if there is some simulation R such that M R N . A relation R is called bisimulation if both R and its converse are simulations. We say that M and N are bisimilar, written M ≈ N , if there is some bisimulation R such that M R N .
Notice that, since reception of messages cannot be directly detected, the clause for message reception imposes weaker requirements, allowing to match input actions with τ -actions.
It is easy to show that our labelled bisimilarity is an equivalence relation. How- ever, our bisimilarity enjoys a much more important property: the closure under contexts.
Lemma 4.2 (≈ is contextual) Let M and N be two networks such that M ≈ N. Then,
M | O ≈ N | O, for all networks O;
(νc)M ≈ (νc)N, for all channels c.
Proof (Sketch) We only prove that ≈ is preserved by parallel composition. We

demonstrate that the relation

def
=
{ M | O, N | O  for all O such that M ≈ N }



α
is a bisimulation. We do a case analysis on the transition M | O −−→
Mˆ . The

interesting cases are when the transition is due to an interaction between M and
O, i.e. when rule (Bcast) is used.

c!v@K
Let M | O −−−−−→−
c!v[l,r]
M because M | O −−−−−→−
Mˆ for some l and r, with

d(l, k) ≤ r, for all k ∈ K due to an application of rule (Bcast). There are two possibilities:

c!v[l,r]	ˆ
c!v[l,r]	'
c?v@l'	'	'

M | O −−−−−→− M because M
ˆ	'	'
−−−−−→− M and O −−−−−→ O , with d(l, l ) ≤ r
c!v@K'

and M = M
| O . In this case, by an application of rule (Obs) we have M
−−−−−−→

M ', with K'
= K ∪ {l'}. As M ≈ N there is N '
such that N
c!v@K'
=====⇒=
N ' with

M ' ≈ N '. By applying rule (Obs) backward there must be K1,... , Kn such that

c!v@K1
N  =
c!v@Kn
... 
=⇒ N ' with  n
K  = K' and l' ∈ K , for some

1≤j≤n. This implies that


c!v@K1
N =
c!v[lj,rj]
c!v@Kn	'

⇒ −−−−−−→ ... =⇒ −−−−−−→− =⇒ ... −−−−−−→ =⇒ N
with d(lj, k) ≤ rj, for all k ∈ Kj. Hence by an application of rule (Bcast):


N | O =
c!v@K1
... =
c!v[lj,rj]
=⇒ ...	c!v@Kn
=⇒ N ' | O' .



Finally, by applying rule (Obs) we can turn the transition
c!v[lj,rj]
−−−−−−→−
c!v@Kj
in −−−−−−→.

This implies N | O
==c!=v=@=K⇒=
N ' | O' with  M ' | O' , N ' | O' ∈ S, as required.

c!v[l,r]	ˆ
c?v@l'	'
c!v[l,r]	'	'

M | O
−−−−−→− M because M
−−−−−→ M
and O
−−−−−→− O , with d(l, l ) ≤ r

and Mˆ = M ' | O'. As M ≈ N there is N ' such that:
c?v@l'	'	'	'

· either N
=====⇒ N , with M ≈ N ; in this case



N | O =
c!v[l,r]
=

and, by rule (Obs), also N | O
required.
==c!=v=@=K⇒=
N ' | O', with  M ' | O' , N ' | O' ∈ S, as

· or N  =⇒ N ', with M ' ≈ N '; in this case, by applying rule (Par) we obtain

N | O =
c!v[l,r]
=
c!v@K	'	'

with M ' | O' , N ' | O' ∈ S, as required.

Let M | O −−→ Mˆ
c!v[l,r]
because M | O −−−−−→−
Mˆ . We reason as in the previous

case.
The remaining cases, when there is no interaction between M and O, are easy to deal with.
 

In the following lemma we point out a close relationship between the observation predicate ↓c@k and a specific action.
Lemma 4.3

c!v@K
If M −−−−−→−
M ' then M ↓c@k
, for all k ∈ K;

if M ↓c@k then there is a value v and a set of locations K, with k ∈ K, such

c!v@K
that M −−−−−→−
M '.

We can now prove that our bisimilarity is a proof method for reduction barbed congruence, i.e. that ≈ is contained in ∼=.
Theorem 4.4 (Soundness) Let M and N be two arbitrary networks such that
M ≈ N, then M ∼= N.
Proof We recall that ∼= is the least symmetric relation which is reduction closed, barb-preserving, and contextual. In fact, the bisimilarity is reduction closed (using Theorem 3.1), barb-preserving (by Lemma 4.3), and contextual (by Lemma 4.2). Thus, ≈⊆ ∼=.	 
As a main result, we prove that the labelled bisimilarity is more than a proof technique. Actually, it represents a complete characterisation of reduction barbed congruence.
When proving the completeness result, i.e. that reduction barbed congruence is contained in the labelled bisimilarity, we implicitly use a standard property of reduction barbed congruence.
Proposition 4.5 If M ∼= N then
M ⇓c@k iff N ⇓c@k
M =⇒ M ' implies there is N ' such that N =⇒ N ' and M ' ∼= N '.
Lemma 4.6 (Completeness) Reduction barbed congruence is contained in the bisimilarity.
Proof (Sketch) We prove that the relation R = {(M, N ) | M ∼= N } is a bisimu- lation. The result will then follow by co-induction. In this sketch we only consider output actions.

c!v@K
Suppose that M R N and M  −−−−−→−
M ', with K = {k1
,... , kn}.	As the

action c!v@K can only be generated by an application of rule (Obs), it follows

c!v[l,r]
that M −−−−−→−
M ' for some l and r such that d(l, k) ≤ r, for all k ∈ K.

Let us build up a context which mimics the effect of the action c!v@K, and also allows us to subsequently compare the residuals of the two systems under consideration. Our context has the form:


C[·]	def


[·] |   m [c(x).[x = v]f ⟨x⟩ s

| n [f (x).ok ⟨x⟩ s

=	i
i=1
i	]ki,ri	i i
i	]ki,ri

with names mi, ni, for 1≤i≤n, and channel names fi and oki, for 1≤i≤n, fresh. Intuitively, the existence of the barbs on the fresh channels fi indicates that the action has not yet happened, whereas the presence of the barbs on channels oki, together with the absence of the barbs on fi, ensures that the action has been performed.
As ∼= is preserved by network contexts, M ∼= N implies C[M ] ∼= C[N ]. As

c!v[l,r]
M −−−−−→−
M ', it follows that





C[M ]	=⇒  M ' |    m [0]s	| n [ok ⟨v⟩]s
  = Mˆ

i	ki,ri	i	i
i=1
ki,ri



with Mˆ
/⇓fi@ki and Mˆ
⇓oki@ki , for 1≤i≤n.

The reduction sequence above must be matched by a corresponding reduction

sequence C[N ] =⇒ Nˆ
with Mˆ
∼= Nˆ, Nˆ /⇓fi@ki and Nˆ ⇓oki@ki , for 1≤i≤n.

The constrains on the barbs allow us to deduce the structure of the above
reduction sequence. That is:




C[N ]	=⇒  N ' |    m [0]s	| n [ok ⟨v⟩]s

  ∼=
Nˆ .

i	ki,ri	i	i
i=1
ki,ri



This implies that N
=c=!v=@=L=⇒ N ', with K ⊆ L. More precisely, the derivative N '

might be reached performing several outputs of message v along the same channel
c. However, as all nodes mi are reached by a transmission along channel c coming

from N , we can be sure that K ⊆
L. It is then easy to show that N
c!v@K
======
N ' by

considering in the composition of the weak action only on those outputs addressed to the locations in K, and turning the others in τ -actions using rule (Lose).

As Mˆ
have
∼= Nˆ
and reduction barbed congruence is preserved by restriction, we

(ν˜f, o˜k)Mˆ ∼= (ν˜f, o˜k)Nˆ .
As channels fi and oki, for 1≤i≤n, are fresh we have
· (ν˜f, o˜k)Mˆ	≡ M ' | (ν˜f, o˜k)  n	m [0]s	| n [ok ⟨v⟩]s
· (ν˜f, o˜k)Nˆ	≡ N ' | (ν˜f, o˜k)  n	m [0]s	| n [ok ⟨v⟩]s	 .
Using our labelled bisimilarity and Theorem 4.4 is easy to prove that


(ν˜f, o˜k)  m [0]s	| n [ok ⟨v⟩]s

  ∼= 0 .

i	ki,ri	i	i
i=1
ki,ri

As a consequence, it follows that M ' ∼= N ', as required.

An easy consequence of Theorem 4.4 and Lemma 4.6 is the following.
Theorem 4.7 (Characterisation) Bisimilarity and reduction barbed congruence coincide.

Properties and examples
In this section, we prove a number of properties using our observational theory.
We start proving an interesting feature of mobile nodes.
Theorem 5.1 (Ubiquity of mobile nodes) For any process P, physical loca- tions k and l, and transmission radius r, it holds that
n[P ]m	≈ n[P ]m	.

Proof We show that the relation

def
=
{ n[P ]m

, n[P ]m

 : ∀ k, l ∀P }= ∪I 

is a bisimulation, where I is the identity relation.	 
The next result shows that silent nodes cannot be detected (or observed). A node is said silent if it never transmit messages.
Theorem 5.2 (Silent nodes cannot be observed) If process P does not con- tain output constructs, then


for any l and r.
n[P ]μ	≈  0

Proof It follows from our definition of bisimilarity in which it is possible to match both τ -actions and input actions with weak τ -actions. We recall that =⇒ is the
τ
reflexive and transitive closure of −−→.	 
Now, we show how syntactically different infinite output sequences may be se- mantically indistinguishable, because of message loss.
Theorem 5.3 (Mixing up infinite output sequences)
def 	
Let ALT(a, b) = c⟨a⟩.c⟨b⟩.ALT⟨a, b⟩. Then, for any l, n, r, u, and v it holds that:

n[ ALT⟨u, v⟩]s
n[ ALT⟨u, v⟩]m
≈ n[ ALT⟨v, u⟩]s
≈ n[ ALT⟨v, u⟩]m	.

Proof We only prove the second statement. We show that the relation

R d=ef
{ n[ ALT⟨u, v⟩]m

, n[ ALT⟨v, u⟩]m

 : for all k, l}= ∪ I 

where I is the identity relation, is a bisimulation up to ≡.	 
This result can be generalised replacing u and v with an arbitrary finite set
V = {v1,... , vn} of messages. More generally, if two nodes contain only an infinite sequence of output constructs transmitting values belonging to some finite set V , such that for each v ∈ V the output c⟨v⟩ appears an infinite number of times, then the two nodes are equivalent.

In the next result, we show that devices transmitting messages “ad infinitum” may obfuscate the transmission activity of nodes which are transmitting the same messages within the same transmission cell. We recall that the function fc(·) returns the set of free channels contained in one or more processes, while op(·) returns the set of values appearing in output position in one or more processes.
Theorem 5.4 (Obfuscating message transmission) Let P and Q be two pro- cesses such that fc(P, Q) ⊆ {c}, for some channel c, and op(P, Q) ⊆ {u, v}, for

some values u and v. Let ALT(a, b) d=ef
c⟨a⟩.c⟨b⟩. ALT⟨a, b⟩. Then,

n[P ]s
n[P ]m
| m[ ALT⟨u, v⟩]s
| m[ ALT⟨u, v⟩]m
≈  n[Q]s	| m[ ALT⟨u, v⟩]s
≈  n[Q]m'	| m[ ALT⟨u, v⟩]m	.

k,r
l,r
k ,r
l',r

Proof We only prove the first statement. By transitivity of ≈, it suffices to prove that

n[P ]s
| m[ ALT⟨u, v⟩]s
≈ m[ ALT⟨u, v⟩]s

for all l and r, and for all P such that fc(P ) ⊆ {c} and op(P ) ⊆ {u, v}. At this purpose, we show that the binary relation


{ n[P ]s | m[ ALT⟨u, v⟩]s

, m[ ALT⟨u, v⟩]s  : ∀P. fc(P )⊆{c}∧ op(P )⊆{u,v} }=
 



{ n[P ]s | m[c⟨v⟩. ALT⟨u, v⟩]s
, m[c⟨v⟩. ALT⟨u, v⟩]s

 : ∀P. fc(P )⊆{c}∧ op(P )⊆{u,v}}=

is a bisimulation.	 
Also this result can be generalised taking an arbitrary finite set V of messages. The next results are about range repeaters (or range extender), and make par- ticularly sense for stationary nodes, like access points. In general, a repeater simply regenerates a network signal in order to extend the range of the existing network infrastructure. In a wireless networks a range repeater does not physically connect by wire to any part of the network. Instead, it receives radio signals from an ac- cess point, end user device, or another repeater and retransmits the frames. This makes it possible for a repeater located in between an access point and a distant stationary user to act as a relay for frames travelling back and forth between the user and the access point. In this manner, using a range repeater, a distant user
can get connected to the network.

In our calculus, a range repeater can be modelled as a node rr[c ‹→ c]s
, where

the process c ‹→ c is a forwarder process whose general recursive definition is


a ‹→ b
def
= a(x).b
⟨x⟩.a ‹→ b


This process receives values at channel a and retransmits them on channel b; in c ‹→ c the same channel c is used for reception and transmission. We will use the definition of forwarder process in several examples.

Now, suppose we want to extend the range of an access point n[P ]s
. In par-

ticular, suppose we want to cover the cell located at l with radius r'. In this case, if d(k, l) ≤ r and d(k, l) ≤ r' we could add a range repeater at l that simply re- peats the signal back and forth with transmission radius r'. In such a scenario, if node n is single-channel, i.e. it uses only one channel, then the introduction of the range repeater allows us to simulate the presence of the access point n at l with
transmission radius r', i.e. n[P ]s ' .
Theorem 5.5 (Range repeaters) Let P be a process such that fc(P ) ⊆ {c}, for some channel c. Let k, l be physical locations, and r, r' be transmission radii such that d(k, l) ≤ r and d(k, l) ≤ r'. Then, the system



simulates the node n[P ]s '  .
n[P ]s
  rr[c ‹→ c]l,r'

Proof We prove that the relation

l,r' 
{ n[P ]s ' , n[P ]s	 rr[c ‹→ c]	: ∀k, l. d(k, l)≤r ∧ d(k, l)≤r', ∀P. fc(P )⊆{c}}
is a simulation.	 
A well-known downside of range repeaters, though, is that they reduce the throughput of the network. A range repeater must receive and retransmit each frame on the same radio frequency channel, which effectively doubles the number of frames that are sent. In particular, accordingly with the protocol CSMA/CA, whenever the range repeater transmits on channel c the node n must remain silent to avoid collisions. A way to avoid this inconvenient could be that of using more sophisticated range repeaters working on two different channels: for example, chan- nel c for communicating with the access point n, and a different channel, say d, to interact with the local stationary users.
Theorem 5.6 (Range repeaters with two channels) Let P be a process such that fc(P ) ⊆ {c}, for some channel c. Let k, l be physical locations, and r, s be transmission radii, such that d(k, l) ≤ r and d(k, l) ≤ r'. Then, for any channel d, the system

n[P ]s
simulates the node n[{d/c}P ]s
s
l,r
'  .
'  in[d ‹→ c]l,r'

l,r
Proof We prove that the relation


S d=ef
{ n[{d/c}P ]s ' , n[P ]s	 out[c ‹→ d]
l,r

'  in[d ‹→ c]l,r

'  :

∀ k, l. d(k, l)≤r ∧ d(k, l)≤r'
∀ P. fc(P ) ⊆ {c}
}

is a simulation.	 
As already pointed out, the previous results on range repeaters make particular sense when dealing with stationary nodes. In fact, when dealing with mobile nodes those devices are basically superfluous, as exemplified below.
Theorem 5.7 Let k, l be physical locations and r, r' be transmission radii such that
r ≥ r'. Then,

n[P ]m
Proof We show that the relation
simulates n[P ]m '  .

def
=
{ n[P ]m

' , n[P ]m

 : ∀k, l ∀P }

is a simulation.	 
Finally, we provide a result concerning with energy consumption. It is well- know [23] that the power pk required by a node located at k to correctly transmit data to a node located at l must satisfy the inequality  pk α ≥ β, where α ≥ 2 is the distance-power gradient and β ≥ 1 is the transmission quality parameter. 2
While the value of β is usually set to 1, the value of α depends on environmental conditions. In the ideal case, we have α = 2; however α is typically 4 in realistic situations. For instance, for r = 10 the power pk of the transmitter must be at least 10000.
However, if we introduce a repeater node between transmitter and receiver, say in the middle, we can drastically reduce the whole transmission power. More precisely, to cover the distance of 5 is enough a transmission power of 625. Thus, the transmission power we need for both the transmitter and the repeater is 1250 instead of 10000!
The following result shows that the introduction of a repeater between a first (stationary) node located at some l1, and a second (stationary) node located at some l2, using a private channel to propagate the signal, does not change the behaviour of the original system. Notice that for d(l1, l2)= r, we write l1+r/2 to denote the location placed in the middle, between l1 and l2.
Theorem 5.8 (Saving antenna power) Let P be a process such that fc(P ) =
{d}, for some channel d. Let l1, l2 be physical locations, and r1, r2 be transmission radii such that d(l1, l2)= r, r ≤ r1, and r ≤ r2. Then, the system

(νd) m[P ]s

 rr [d ‹→ d]l1+r/2,r/2
  n[Q]l2 ,r2



simulates the system
(νd) m[P ]s

 n[Q]l2 ,r2  .



2 This inequality holds for free-space environments with non-obstructed line of sight, and it does not consider the possible occurrence of reflections, scattering, and diffraction caused by buildings, terrain, and so on. Nevertheless, it is widely accepted in the ad hoc network community.

Proof The two systems basically differ for the presence of the range repeater op- erating on the private channel d. Formally, we prove that the relation


{ (νd)(m[P ]s	 n[Q]
l2,r2

) , (νd)(m[P ]s


 rr [d ‹→ d]l1+r/2,r/2

 n[Q]l2,r2

) :

∀ Q ∀ P. fc(P )={d}
}

is a simulation.	 

Related and Future Work
Broadcast for Ethernet-like communications has been first analysed by Prasad [19,20,15] in his Calculus of Broadcasting Systems (CBS), in which all processes receive a broadcast message at once. In [21] the same author proposed a LTS and a (both strong and weak) labelled bisimilarity relying on the notion of “discard relation”, a special transition that any process can perform to discard a poten- tial message. Technically speaking, the discard relation is a mechanism to fit the semantics of broadcast with that of parallel composition.
Hennessy and Rathke [6] proved that the above (weak) bisimilarity, renamed noisy bisimilarity, coincides with barbed congruence. Modulo the presence of the discard relation, our bisimilarity is very close to noisy bisimilarity.
The bπ-calculus [2] of Ene and Muntean equips the π-calculus with a broadcast paradigm such that only nodes listening on the right channel can receive a broad- cast. While this seems to come closer to a notion of local broadcast, it remains complicated to change a once established connectivity. The authors proposed an LTS (relying on the discard relation) and a labelled bisimilarity which is proved to coincide with barbed equivalence. They also proved that the closure under substi- tution of their labelled bisimilarity corresponds to the barbed congruence.
Nanz and Hankin [14] have introduced a calculus for Mobile Wireless Networks (CBS#) where the recipients of a transmission are determined using a graph rep- resentation of node localities. While this approach is more flexible, ours (based on location and radius that define transmission cells and distance) allows a more compact representation of connectivity. The authors proposed a LTS which is very close to that of [21,6] and again relies on the discard relation. This LTS is then used to define a behavioural equivalence, called mediated equivalence that identifies processes only with respect to their capability to store items. The final goal of Nanz and Hankin is to use their calculus as the basis of a framework for specification and security analysis of communication protocols for MANETs.
Prasad’s more recent calculus of Mobile Broadcasting Systems, (MBS) [22] aims at providing a communication model which implements the “globally asynchron- ous, locally synchronous” communication mechanism which is proper of wireless communication communication systems. Channels are employed as sealed rooms, preventing a message sent within a room to being captured by processes in other

rooms.
Singh, Ramakrishnan, and Smolka [24] have proposed the ω-calculus, a con- servative extension of the π-calculus specifically tailored for modelling MANETs’ protocols. The key feature of the ω-calculus is the separation of a node’s communic- ation and computational behaviour from the description of its physical transmission range. The latter is modelled annotating processes with the set of group names to which the process belongs. The authors have proposed a labelled transition se- mantics that, unlike the previous ones, does not use the discard relation but instead contains a rule, similar to our (Lose), to model the non-blocking nature of multicast send. A bisimulation in “open” style is provided. The ω-calculus is then used for developing a model of the AODV protocol [17], a routing protocol for MANETs.
Finally, notice that all the previous calculi abstract from interferences. Mezzetti and Sangiorgi [9] have instead proposed a lower level calculus in which a node can detect interferences when located in the intersection of the transmission range of two different nodes. While our syntax is inspired by that of [9], the reduction semantics and the corresponding LTS is quite different; this is because in our model we assume the absence of interferences.

Future Work
A number of developments are possible. For instance, we could enrich the calculus with operators to model the concept of store as in [14]. We could try to extend the behavioural theory to deal with node failure. At this regards, the developments in [3,4] for wired networks could be a good starting point. Moreover, wireless systems have also features of synchrony that remind us of synchronous languages (e.g. Esterel [1], Statecharts [5], SCCS [10]). Indeed, in a single time unit of a wireless system multiple events can happen. It is our intention to investigate these aspects taking inspiration from [22]. Finally, as pointed out in [14], security is, of course, another important issue in MANETs that we would like to investigate.
Acknowledgements Many thanks to Davide Sangiorgi for insightful comments on a early draft. I also thank Davide Quaglia for useful discussions on MANETs.

References
G. Berry and G. Gonthier.	The esterel synchronous programming language: Design, semantics, implementation. Science of Computer Programming, 19(2):87–152, 1992.
C. Ene and T. Muntean. A Broadcast based Calculus for Communicating Systems. In IPDPS, page 149, 2001.
A. Francalanza and M. Hennessy. A theory of system behaviour in the presence of node and link failures. In CONCUR, volume 3653 of Lecture Notes in Computer Science. Springer, 2005.
A. Francalanza and M. Hennessy. A theory for observational fault tolerance. In FoSSaCS, volume 3921 of Lecture Notes in Computer Science, pages 16–31. Springer, 2006.
D. Harel. Statecharts: A visual formulation for complex systems. Science of Computer Programming, 8(3):231–274, 1987.


M. Hennessy and J. Rathke. Bisimulations for a Calculus of Broadcasting Systems. Theoretical Computer Science, 200:225–260, 1998.
K. Honda and N. Yoshida. On reduction-based process semantics. Theoretical Computer Science, 152(2):437–486, 1995.
M. Merro. An Observational Theory for Mobile Ad Hoc Networks. Technical Report 44/2006, Dipartimento di Informatica – Universit`a degli studi di Verona, Italy, December 2006. Available at http://www.di.univr.it/report .
N. Mezzetti and D. Sangiorgi. Towards a Calculus For Wireless Systems. Electronic Notes in Theoretical Computer Science, 158:331–353, 2006.
R. Milner. Calculi for synchrony and asynchrony. Theoretical Computer Science, 25:267–310, 1983.
R. Milner. Communication and Concurrency. Prentice Hall, 1989.
R. Milner, J. Parrow, and D. Walker. A calculus of mobile processes, (Parts I and II). Information and Computation, 100:1–77, 1992.
R. Milner and D. Sangiorgi. Barbed bisimulation. In ICALP, volume 623 of LNCS, pages 685–695. Springer Verlag, 1992.
S. Nanz and C. Hankin. A Framework for Security Analysis of Mobile Wireless Networks. Theoretical Computer Science, 2006. To appear.
K. Ostrovsky, K. V. S. Prasad, and W. Taha. Towards a primitive higher order calculus of broadcasting systems. In PPDP, pages 2–13. ACM, 2002.
D.M. Park. Concurrency on automata and infinite sequences. In P. Deussen, editor, Conf. on Theoretical Computer Science, volume 104 of LNCS. Springer Verlag, 1981.
C.E. Perkins and E.M. Belding-Royer. Ad-hoc on-demand distance vector routing. In 2nd Workshop on Mobile Computing Systems and Applications (WMCSA ’99), pages 90–100. IEEE Computer Society, 1999.
G.D. Plotkin. A structural approach to operational semantics. Technical Report DAIMI-FN-19, Computer Science Department, Aarhus University, 1981.
K. V. S. Prasad. A Calculus of Broadcasting Systems. SCIPROG: Science of Computer Programming, 25(2-3), 1995.
K. V. S. Prasad. Broadcasting in Time. In COORDINATION, volume 1061. LNCS, 1996.
K.V.S. Prasad. A calculus of value broadcasts. In PARLE: Parallel Architectures and Languages Europe. LNCS, 1993.
K.V.S. Prasad. A prospectus for mobile broadcasting systems. In Proc. of the Workshop on Algebraic Process Calculi: The First Twenty Five Years and Beyond, (PA’05). BRICS Press, 2005.
T. Rappaport. Wireless Communications: Principles and Practice. Monographs in Computer Science. 2nd Ed. Prentice Hall, 2002.
A. Singh, C. R. Ramakrishnan, and S. A. Smolka. A Process Calculus for Mobile Ad Hoc Networks, 2006. Available at http://www.lmc.cs.sunysb.edu/∼ cram/Papers/SRS OmegaCalc2006/.
