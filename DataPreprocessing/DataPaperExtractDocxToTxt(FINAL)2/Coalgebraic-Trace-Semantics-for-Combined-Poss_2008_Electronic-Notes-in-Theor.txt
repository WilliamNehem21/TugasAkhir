	Electronic Notes in Theoretical Computer Science 203 (2008) 131–152	
www.elsevier.com/locate/entcs

Coalgebraic Trace Semantics for Combined Possibilitistic and Probabilistic Systems
Bart Jacobs
Institute for Computing and Information Sciences, Radboud University of Nijmegen
P.O. Box 9010, 6500 GL Nijmegen, The Netherlands Email: bart@cs.ru.nl URL: http://www.cs.ru.nl/~bart


Abstract
Non-deterministic (also known as possibilistic) and probabilistic state based systems (or automata) have been studied for quite some time. Separately, they are reasonably well-understood. The combination however is difficult, both for conceptual and technical reasons. Here we study the combination from a coalgebraic perspective and identify a monad CM that captures the combination—following work of Varacca. We use this monad to apply the coalgebraic framework for (finite) trace semantics in this setting. It yields a smooth, but not entirely trivial, description of traces.
Keywords: coalgebra, probabilistic nondeterminism, probabilistic nondeterminism

Introduction
The combination of non-determinism and probability is an important but difficult topic of research, which has received much attention. There is a wide variety of possible combinations. We shall not try to give an overview or a historical account and refer to [3] for such an overview and a classification, in coalgebraic terms.
Within this coalgebraic setting an abstract description of trace semantics has emerged [10,9] that exploits finality within a Kleisli category of a monad. This works well for non-determinism—via the powerset monad P—and also for probability— for the distribution monad D, but so far only when P and D are considered sepa- rately. The combination of P and D has defied integration attempts. The technical
reason is that there is no distributive law DP ⇒ PD, see e.g. [21], describing a
(counter)argument due to Plotkin.
Varacca in his thesis [20] (see also [21]) proposes two solutions, namely to either replace the distribution monad by a new monad of “indexed valuations” (for which there is indeed a distributive law with powerset) or to use one monad of convex subsets (which acts on a different category) for the whole combination. Here we

1571-0661 © 2008 Published by Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.05.023

shall follow the latter approach. What we contribute is first of all a reformulation of this second approach in terms of semimodules [7]. In algebra, a module (see e.g. [15]) is like a vector space, but with a ring of scalars, instead of a field. A semimodule is even weaker, and has only a semiring of scalars. Such a semiring is in fact a combination of two monoids, with one distributing over the other. There are natural examples of semirings in this setting, namely the sets of non-negative natural, rational, or real numbers, possibly extended with infinity ∞.
Our first step is to describe the (more or less standard) construction of free semimodules over sets, via a multiset functor that counts elements with values in a semiring. These multisets can be described as formal sums  a x with multiplicity ai for element xi. We do not impose the requirement i ai = 1, which is typical of probability distributions. The more general formulation of multisets not only gives a nicer mathematical theory (with free semimodules) but also allows more general interpretations of the ai than probabilities, for instance involving cost or time or resource consumption.
In a next step the notion of convex subset can be defined naturally over a semimodule, namely as a subset that is closed under linear combinations (with scalars adding up to 1). Our first aim is to reformulate the setting of Varacca in terms of free constructions of semimodules. In doing so we slightly extend his work, by formulating it with a semiring as parameter, and with non-finitely generated convex subsets. The latter are needed since a trace is generally not a finite (or finitely generated) set.
Our second contribution is to show that the monad CM that is obtained from the free construction of semimodules over (affine) complete lattices is indeed suitable for coalgebraic trace semantics. This is shown in two steps, namely by verifying that CM satisfies almost all the technical conditions of [10] for trace semantics— in particular that its Kleisli category is enriched over directed complete partial orders—and by calculating traces in a concrete example, following this coalgebraic approach. There is actually one condition from [10] that is not satisfied, namely the presence of a bottom element in Kleisli homsets. We do however have a zero element, which is enough, after some manipulation. For expository reasons we will start with the example and subsequently develop the required mathematics.
This paper makes a modest step itself, but hopefully forms the starting point for an integration of research lines in the area of possibilistic and probabilistic systems. We conjecture, for instance, that the approach to traces based on schedulers (see
e.g. [17,21,5]) gives the same outcome as the coalgebraic approach that is developed
here. This will be elaborated in a next version of this paper.

Example
We shall consider a concrete state-based system with combined possibilistic and probabilistic behaviour in order to illustrate the calculation of traces of states. This is meant as a sketch of what this paper achieves. Later sections will elaborate the underlying technical details. Hence, possibly, not everything is clear at this stage.

In particular, some notions and notations (like for convex closure) will be used that are explained later on. Hopefully, the intuition of what is happening is helpful.
Our example system has state space X = {p, q, r} and set of labels A =
{a, b, c, d, e} with the following picture, in which the symbol C is used to indicate termination.


(1)	. ◦   1/2	◦
a .
.....

p ...
b	  1/2	 1 

¸¸¸¸¸	◦ ¸¸¸¸¸
,,,,
 ◦ 
 C 

¸¸	1/2
¸¸,¸,, 1/3

c ¸¸¸¸¸
,,,,, ¸¸¸¸¸

z◦ , ,	¸z r ˛ 
2/3


There are two kinds of arrows in this picture. The arrows ending in circles ◦ describe non-deterministic (labeled) transitions. Their targets are not states, but distributions (actually multisets) of states: they have outgoing arrows to states, with probabilities as labels, indicating how likely that transition is.
This system may be described as a coalgebra of the form γ: X → CM(A+A×X), namely as:




γ(p) = {0, 1 a, 1 ⟨b, q⟩ + 1 ⟨b, r⟩, 1 ⟨c, q⟩ + 2 ⟨c, r⟩}
2	2	2	3	3
γ(q) = {0, 1 ⟨d, q⟩, 1e}
γ(r) = {0}.




At this stage we only describe CM informally as containing convex subsets of dis- tributions. The overlining describes convex closure. Hopefully the match between these equations and the picture is sufficiently convincing. The zero elements are included for technical reasons, but are not written in the picture. They could be

written as arrows x −→l
things clearer.
for every state x and label l, but doing so does not make

A crucial point is that CM is a “monad”, so that we can use what is called “Kleisli” composition. This allows us to compose the coalgebra γ with itself, and obtain iterates γn: X → CM(A≤n), where A≤n is the set of sequences of elements from A with length at most n. The first step is given by γ0(x) = {0}—where 0 is

the “null” distribution—and the subsequent ones by:
γn+1(p)

=  ⎧⎨ 0,,  1 a,,  Σ
1 ψ(σ)(bσ) ψ ∈ γn(q),,  Σ
1 ψ(σ)(cσ) ψ ∈ γn(q),⎫⎬

γn+1(q⎩)
σ∈A+
σ∈A+	⎭

=  ⎧⎨ 0,, 1e,,  Σ
1 ψ(σ)(dσ) ψ ∈ γn(q),⎫⎬

γn+1(r⎩)
= {0}.
σ∈A+	⎭

These formulas will be justified later on. For now we shall compute some these sets. To start with:




γ1(q) =	 {0}, {1e}, = {0, 1e}.
In a next step we get:




γ2(q) =   {0}, {1e}, { 1 de}, = {0, 1e, 1 de}.
The multisets appearing here, like 1 be in γ2(p) correspond to a 2-step path, from p
to C, with multiplication of probabilities that occur on the way.
We make one more step:




									
γ3(q) =   {0}, {1e}, { 1 de, 1 dde}, = {0, 1e, 1 de, 1 dde}.
By continuing in this way we get the trace as supremum:




1  n

5n

Such trace descriptions will be justified in the remainder of this paper.
Monoids, semirings and semimodules
We start with an abstract description to arrive at the notion of a semimodule in a category. One can also use the more concrete description, given by operations and

equations as in (2) below.
Standard “universes” in this paper are the category Sets of sets and functions and the category ACL of “affine” complete lattices (posets with joins of all non- empty subsets) and non-empty join preserving functions between them (see [12]). An affine complete lattice is thus different from an ordinary complete lattice because it need not have a bottom element ⊥—as join of the empty subset. The category Sets has finite products (1, ×) in the usual way; ACL has a monoidal structure (I, ⊗), where a homomorphism X ⊗ Y → Z corresponds to a function X × Y → Z that preserves non-empty joins in both arguments separately (is “bilinear”). This follows work of Kock on tensors in categories of Eilenberg-Moore algebras, see [12] again for a concise description.
Let C be an arbitrary category with a symmetric monoidal structure (I, ⊗)— which may informally be understood as products without projections or diagonals. In such a setting one can define the notion of commutative monoid.  It consists

of a “carrier” object M ∈ C with two maps I
−0→ M
←+− M ⊗ M making obvi-

ous diagrams commute, expressing that (0, +) satisfy the standard requirements for commutative monoids. These structures may be organised in a category cMon(C) in which homomorphisms are maps in C between the carriers that commute appro-
priately with the monoid structures.
In this way one obtains for instance the category cMon(Sets) of “ordinary” commutative monoids or cMon(ACL) of (commutative, unital and “affine”) quan- tales [16]. In the latter case the carrier is an affine complete lattice and addition preserves non-empty joins, in both arguments.
Given a monoid M ∈ cMon(C) there is a notion of “M -action”. It consists of an object X ∈ C with a map σ: M ⊗ X → X satisfying:



I ⊗ X0 ⊗ id M ⊗ X
¸¸¸¸
M ⊗ (M ⊗ X)
id ⊗ σ
J 
∼=  (M  ⊗ M ) ⊗ X
+ ⊗ id
J 

¸¸	σ	M ⊗ X¸	M ⊗ X

∼= ¸¸¸¸ J 
¸¸¸¸¸	.....

zX 
σ ¸¸z .,..cσ X


A homomorphism (X, σ) → (Y, τ ) of actions is a map f : X → Y in C with f ◦ σ = τ ◦ id ⊗ f . This yields a category Act M (C), with forgetful functor Act M (C) → C, see [14, Ch. VII.4]. It has a left adjoint, given by X '→ M ⊗ X.
Often these categories cMon(C) also have a monoidal structure (I, ⊗) them- selves. In that case one can consider the category cMon(cMon(C)) of “double” monoids. These are commonly called semirings. They are objects S ∈ C for which one has an additive structure (0, +) and a multiplicative structure (1, ·) where mul- tiplication is a homomorphism wrt. the additive structure, in both arguments. This amounts to the familiar distributivity laws:

(x + y) · z = x · z + y · z	and	0 · z = 0.

Notice that in this setting a semiring has a multiplicative unit 1 and is commuta- tive, both additivily and multiplicatively. We shall abbreviate cMon(cMon(C)) as SRng (C), assuming that appropriate tensors exist.
For a semiring S in a category C we can perform the above action construction wrt. the category cMon(C) of commutative monoids in C. This yields a category Act S(cMon(C)) which we shall write as SMod S(C). It is the category of semimod- ules in C, see e.g. [7]. An object of SMod S(C) is a commutative monoid M with an action S ⊗ M → M , which we shall typically write as •. In usual notation the following equations hold.
1 • x = x	(a + b) • x = a • x + b • x
(2)	(a · b) • x = a • (b • x)	a • 0 = 0 
0 • x = 0	a • (x + y) = a • x + a • y.
We shall be especially interested in the categories SMod S(Sets) and SMod S(ACL), for semirings S like N ∪ {∞} or [0, ∞] = {a ∈ R | a ≥ 0} ∪ {∞} of extended non- negative (natural and real) numbers. Notice that these two semirings are complete lattices, with the semiring operations + and · preserving joins. The unit interval [0, 1] of real numbers is a semiring (in complete lattices) with (0, max) as additive and (1, ·) as multiplicative structure. This is a “semifield”, in which the non-zero elements form a multiplicative group, see [7].

Free semimodules
For a semiring S ∈ SRng (Sets) we shall write MS: Sets → Sets for the finite “multiset” functor that counts in S. It is defined as:

MS(X) = {ϕ: X → S | supp(ϕ) = {x ∈ X | ϕ(x) /= 0} is finite}.

For a function f : X → Y , a “multiset” ϕ ∈ MS(X) , and an element y ∈ Y , we write:

MS(f )(ϕ)(y) = 
x∈f −1(y)
ϕ(x) = 
x∈f −1(y)∩supp(ϕ)
ϕ(x).

This makes MS a functor.
These sets MS(X) form commutative monoids via pointwise operations. Ele- ments ϕ ∈ MS(X) will often be written as formal sum x ϕ(x)x or as i aixi if supp(ϕ) = {x1,..., xn} and ϕ(xi) = ai. The element ai ∈ S describes the “multi- plicity” of the element xi in the finite “multiset” ϕ. These monoids MS(X) also carry an S-action, namely:

a • ϕ = λx. a · ϕ(x).

It is not hard to see that this makes MS(X) a semimodule. In fact, it is the free one on the set X.

Proposition 4.1 The MS(−) construction yields free semimodules: it forms a left adjoint to the forgetful functor SMod S(Sets) → Sets. In fact, SMod S(Sets) is the category of (Eilenberg-Moore) algebras of the induced monad MS: Sets → Sets.
Proof For a function f : X → M , where M is a semimodule over S, one obtains a unique extension f : MS(X) → M by f (ϕ) =	x ϕ(x) • f (x). Then f ◦ η = f , where η(x) = 1x. This f is the unique semimodule homomorphism with this property because each multiset ϕ ∈ MS(X) can be written as finite sum ϕ = x ϕ(x) • η(x).		 
The following diagram is an adaptation of [21]. It describes the structure of what follows in the remainder of this section.
C

(3)
SMod
S(Sets) ¸,	⊥	
z 
SMod S(
ACL)

,,,
,,,
z˛ , s
Sets
The straight arrows are forgetful functors, and the bent ones are their left adjoints. The upper adjoint C involves “convex” subsets in a semimodule. This notion is introduced first.
For a semimodule M ∈ SMod (Sets) and an arbitrary U ⊆ M one defines the
convex closure U ⊆ M of U as:
U = {a1 • x1 + ··· + an • xn | xi ∈ U, ai ∈ S, Σi ai = 1}.

It is not hard to see that U ⊆ U , U = U and U ⊆ V ⇒ U ⊆ V —making · indeed a closure operation.
One calls the subset U convex if U = U . Now we put:
C(M ) = {U ⊆ M | U is non-empty and convex}.
It is essential that C(M ) contains non-empty subsets, and not all subsets, for in- stance in the proof of Lemma 4.2 below—to show 0 • U = 0—and in order to get CM(0) = 1 later on in this paper. A consequence of using non-empty subsets is that we have no bottom element, and thus an affine lattice.
For a map f : M → N in SMod S(Sets) we obtain C(f ): C(M ) → C(N ) simply as
image:
C(f )(U ) = {f (x) | x ∈ U}.
It is easy to see that this image is indeed convex. The set C(M ), ordered by inclusion, is an affine complete lattice, with joins over non-empty index sets I given by:

i∈I Ui =	i∈I Ui.

Next we define monoid operations on subsets of M .
(4)	0 = {0}	and	U + V = {x + y | x ∈ U, y ∈ V }.


		
where U, V ⊆ M are arbitrary subsets. It is not hard to see that U + V = U + V , making + a well-defined operation on C(M ). The direction (⊇) is obvious and for (⊆) it suffices to prove U + V ⊆ U + V . This is done as follows. Assume x + y ∈ U + V , say x =   a • x with x ∈ U and   a = 1. Then y = 1 • y = (  j aj) • y =  j aj • y so that x + y =  j aj • (xj + y), where xj + y ∈ U + V . Then x + y ∈ U + V .
These 0, + make C(M ) a commutative monoid. There is also an action, given

as: (5)

a • U = {a • x | x ∈ U}.


	
We have a • U = a • U , since	j aj • (a • xj) =	j(a · aj) • xj = a • (	j aj • xj). Hence also the action on C(M ) is well-defined.
The singleton map {−}: M → C(M ) is clearly a map of semimodules.
The essence of the next series of results can be traced back to [19,21]. For completeness and convenience we include many aspects of the proofs.
Lemma 4.2 Taking convex subsets yields a functor C: SMod S(Sets) → SMod S(ACL)
when S ∈ SRng (ACL) is a semiﬁeld which is “zerosumfree”, i.e. satisﬁes a + b = 0 ⇒ a = b = 0.
From now on we shall assume that S ∈ SRng (ACL) is such a zerosumfree semifield.
Proof Clearly 0, + from (4) form a commutative monoid on C(M ) and • from (5) an action. We have to check that the action preserves the monoid structure:

a • {0} = {a • 0}
= {0}
a • (U + V ) = {a • (x + y) | x ∈ U, y ∈ V }
= {a • x + a • y | x ∈ U, y ∈ V }
= a • U + a • V
0 • U = {0 • x | x ∈ U}
= {0}	since U is non-empty (a + b) • U = {(a + b) • x | x ∈ U}
= {a • x + b • x | x ∈ U}
(=∗) {a • x + b • y | x, y ∈ U}
= a • U + b • U.

The marked equation (=∗) requires some care. The direction (⊆) is obvious, but (⊇) requires convexity of U and division in S. Suppose we have x, y ∈ U . We may assume a + b /= 0, because otherwise a + b = 0 yields a = b = 0 so that the equation obviously holds. Take z =  a  • x +  b  • y, which is in U because U is convex,
a+b	a+b

and also:

a • z + b • z = a2

x +  ab  • y +  ba  • x + b2 • y


a+b
a+b
a+b
a+b

= a2+ab • x + b2+ab • y
	
a+b	a+b
= a • x + b • y.
Next we need to prove that joins are preserved.

(	i Ui)+ V = ( i Ui)+ V
	
= ( i Ui)+ V
= (	i Ui)+ V	as shown after (4)




a • (  i Ui) = a • (  i Ui)

=  i(a • Ui)
	

Finally we need to check that if f is a map of semimodules, then so is C(f ). This is easy. Additionally, C(f ) must preserve joins. This follows from the fact that · commutes with images: C(f )(U ) = C(f )(U ).	 
The following lemma is typical for semimodules over lattices: it combines the sum, action and join. It is a mild generalisation of [21, Prop. 5.5].
Lemma 4.3 In a semimodule M ∈ SMod S(ACL) one has:
Σ (ai • xi) ≤  Σ ai  •    xi .

Proof By induction on n.  The case n = 0 involves summation over 1 and is obvious. Further:


(	i≤n+1 ai) • (	i≤n+1 xi)
= (b + an+1) • (y ∨ xn+1)	where b =
= b • (y ∨ xn+1)+ an+1 • (y ∨ xn+1)

Σi≤n ai and y =


i≤n xi

= (b • y ∨ b • xn+1)+ (an+1 • y ∨ an+1 • xn+1)
= (b • y + an+1 • y) ∨ (b • y + an+1 • xn+1) ∨
(b • xn+1 + an+1 • y) ∨ (b • xn+1 + an+1 • xn+1)
= (b + an+1) • y ∨ (b • y + an+1 • xn+1) ∨
(b • xn+1 + an+1 • y) ∨ (b + an+1) • xn+1
= (b + an+1) • (y ∨ xn+1) ∨ (b • y + an+1 • xn+1) ∨ (b • xn+1 + an+1 • y).

Now we are almost done:


=	Σi≤n (ai • xi)

+ an+1 • xn+1

≤ (	i≤n ai) • (	i≤n xi)+ an+1 • xn+1	by induction hypothesis
= b • y + an+1 • xn+1	with b, y as before
≤ (b + an+1) • (y ∨ xn+1) ∨ (b • y + an+1 • xn+1) ∨ (b • xn+1 + an+1 • y) since in general u ≤ v ∨ u ∨ w
= (	i≤n+1 ai) • (	i≤n+1 xi)	as shown above.	 
Proposition 4.4 The functor C: SMod S(Sets) → SMod S(ACL) is left adjoint to the forgetful functor.
Proof For M ∈ SMod S(Sets) and N ∈ SMod S(ACL) the extension of a module morphism f : M → N to f : C(M ) → N is given by f (U ) = {f (x) | x ∈ U}. Obviously, f ◦ {−} = f . In order to prove that f is a homomorphism we first need that for arbitrary U ⊆ M
(6)	f (U ) = f (U ).
The direction (≥) is obvious, and for^ (≤) we^need to show that f (y) ≤ f (U ) for
y ∈ U . So let y = Σi ai • yi with yi ∈ U . Then:
f (y) = f (Σi ai • yi) = Σi ai • f (yi) ≤  Σi ai  •   i f (yi)	by Lemma 4.3

=	i f (yi)



Then, for non-empty joins:
≤	{f (x) | x ∈ U} = f^(U ).




= f^( i Ui)	by (6)
=  {f (x) | x ∈  i Ui}


=	i f^(Ui).

Uniqueness of f follows from the fact that each U ∈ C(M ) can be written as non- empty join U = U =	x∈U {x} =	x∈U {x}.	 
This adjunction is related to a more elementary one between sets and affine

complete lattices, as in:


C  r


	C	 

SMod S(Sets) ¸, V
SMod S(ACL)

U	P+	U
J ¸,	z J 

Set,s ¸	V
P+  
ACL

where the category ACL is the category of algebras of this non-empty powerset monad P+, see [12]. There is a map of adjunctions from the upper adjunction to the lower one, given by natural transformations UC ⇒ P+U and UV ⇒ V U . The first one is given by inclusions C(M ) ⊆ P+(M ) and the second one by identities.
As a result there is a map of monads between the induced monads, on SMod S(Sets) and on Sets, as described on the left in the above diagram.
The monad for both nondeterminism and probability
In this section we combine Propositions 4.1 and 4.4, about diagram (3), to obtain a monad CM on Sets that combines both possibilistic and probabilistic aspects. Recall that we often leave the (zerosumfree) semifield S over which we work implicit.
Proposition 5.1 By composition of adjoints, the functor CM = C ◦ M yields free semimodules in the situation:
SMod (ACL)
 ,
CM E
J 
Sets
We shall write CM: Sets → Sets for the induced monad. An element U ∈ CM(X)
is then a non-empty convex set of multisets of elements from X.
Given a semimodule M ∈ SMod S(ACL) and a set X, the associated extension of a function f : X → M in Sets to a map f : CM(X) → M in SMod S(ACL) is given by:
f (U ) =	ϕ∈U	x∈supp(ϕ) ϕ(x) • f (x).	 
The unit η: X → CM(X) and multiplication μ: CM2(X) → CM(X) of the in- duced monad CM: Sets → Sets are:
η(x) = {1x}
μ(P ) =	Φ∈P	U ∈supp(Φ) Φ(U ) • U =	Φ∈P	U {Φ(U ) • ϕ | ϕ ∈ U}.
It is not hard to see that there is a map of monads CM ⇒ P, given by U '→
ϕ∈U supp(ϕ).
A standard construction for a monad T on Sets is the associated strength oper- ation st: A× T (X) → T (A× X), given by st(a, u) = T (λx. ⟨a, x⟩)(u). This strength

map commutes appropriately with the monad’s unit and multiplication. There is an associated map st': T (X) × A → T (X × A), obtained by twisting (twice). The monad T is called commutative if the two resulting maps T (X) ×T (Y ) ⇒ T (X ×Y ) are the same.
Lemma 5.2 The monad CM: Sets → Sets has strength map st: A × CM(X) → CM(A × X) given by:

st(a, U ) = CM(λx. ⟨a, x⟩)(U )
= {M(λx.⟨a, x⟩)(ϕ) | ϕ ∈ U}
= {stM(a, ϕ) | ϕ ∈ U}
= {	x ϕ(x)⟨a, x⟩| ϕ ∈ U}.
This monad is commutative, with associated “double strength” map dst: CM(X) × CM(Y ) → CM(X × Y ) given by:

dst(U, V ) = {ϕ · ψ | ϕ ∈ U, ψ ∈ U},
where ϕ · ψ ∈ M(X × Y ) is deﬁned by multiplication: (ϕ · ψ)(x, y) = ϕ(x) · ψ(y).
Proof By straightforward calculation.	 
Remark 5.3 Actions on complete lattices have been used before, for instance in [1]. There, the context is completely different. The starting point are quantales, which are monoids in the category of complete lattices. The free quantale on a set A, for instance, is the lattice P(A٨) of languages over A. What is observed (and exploited) in [1] is that a non-deterministic A-labelled transition system X → P(A × X) is the same as an action (or module) P(A٨) ⊗ P(X) → P(X), via the following correspondences.
X 	 P (A × X) ∼= (P(X))A
==============================
A	 P (X × X) = (P(X)   P(X))
==============================
P(A٨)	 (P (X)  P(X))
==============================
P(A٨) ⊗ P(X)	 P (X)

Here we have written ⊗ for the tensor of complete lattices and  for the associ- ated function space of linear maps. The middle correspondence arises by freeness, because P(X)  P(X) is both a complete lattice and a monoid (via composition). Such actions are used in [1] to capture various kinds of process equivalences, for labelled transition systems.
This setting is quite different from ours, not only because we deal with different transition systems—with monad CM instead of P—but also because we consider actions wrt. a semiring like [0, ∞], i.e. a “double” monoid, in ACL and not just a “single” monoid P(A٨).

The terminology may lead to confusion: the actions of a monoid used in [1] are called modules, like in [13], whereas a (semi)module for us is an action of a semiring (following [7] and standard use of the term ‘module’ in algebra, see e.g. [15]).

The Kleisli category
Now that we have seen the monad CM we can investigate its Kleisli category Kl(CM) whose morphisms capture computations X → CM(Y ) mapping elements of X to a (convex) subset of multisets (or distributions) on Y . We shall be especially in- terested in the order enrichment of this category, to make sure that it satisfies the requirements needed for “coalgebraic trace semantics”, as formulated in [10, Thm. 3.3].
We start with composition in Kl(CM)—also known as Kleisli composition. It involves the extension operation · from Proposition 5.1 (or multiplication μ) in the following way. For f : X → CM(Y ) and g: Y → CM(Z) we have their composite g ◦ f : X → CM(Z) given as:
(g ◦ f )(x) = g(f (x))


(7)
= ^ ϕ∈f(x)	y∈supp(ϕ) ϕ(y) • g(y)
=	ϕ∈f(x)	y∈supp(ϕ){ϕ(y) • ψ | ψ ∈ g(y)}.
Each homset Kl(CM)(X, Y ) of functions f : X → CM(Y ) is ordered pointwise:

f ± g iff ∀x ∈ X. f (x) ⊆ g(x). This forms an affine complete lattice, with point- wise joins. In order to obtain an enriched category we need to check that Kleisli composition preserves these joins. Here it turns out that we need to restrict to di- rected joins ↑, because of the property that a function in two arguments preserves directed joins in each argument separately if and only if it preserves directed joins.
We shall apply this in the form ( ↑	xi)+ (  ↑	yi) =  ↑  (xi + yi). Recall that a
directed set is by definition non-empty, so that a directed join is a special form of non-empty join.
Kleisli composition preserves non-empty joins in the second component, and directed joins in the first one:

 g ◦ (  i fi) (x) = g(  i fi(x))

=	 i(g ◦ fi) (x).

=	Σ (  ↑ ϕ(y) • gi(y))


=  ↑ 
ϕ∈f(x) Σy
ϕ(y) • gi(y)

↑
i
↑
i

As a result, the Kleisli category Kl(CM) is enriched over the category directed complete partial orders.
Each Kleisli homset has a special zero element 0Y,Z = λy ∈ Y. {0}: Y → CM(Z).
Composition is strict wrt. this zero in both arguments.

(0Y,Z ◦ f )(x) =  ϕ∈f(x) Σy ϕ(y) • {0}
= {0}
= 0X,Z(x)
(g ◦ 0X,Y )(x) =	ϕ∈{0}	y ϕ(y) • g(y)
= {0}
= 0X,Z(x).


As shown in [10, Lemma 3.5] the first of these equations (“left strictness” 0 ◦ f = 0) means that the initial (empty) set 0 is both initial and final in Kl(CM), because CM(0) = 1. We shall use this fact later.
We summarise what we have found in this section.

Proposition 6.1 The Kleisli category Kl(CM) of the monad CM from Proposi- tion 5.1 is enriched over the category of “pointed” directed complete orders. 

Our setting differs from [10] in the sense that our point 0 in homsets need not be a bottom element.


The transition type functor
The category SMod (Sets) of semimodules is algebraic over Sets, via the monad M. Hence it is cocomplete, see for instance [2, §3.4, Theorem 1 and §9.3, Proposition 4] or [4, Volume 2, §4.3]. Finite colimits are special. For instance, the coproduct of two semimodules M, N ∈ SMod (Sets) is the product M × N : it is a “biproduct”. Similarly, the copower A· M , for a (finite) set A, is given by the function space M A. The coprojections κa: M → M A are given by κa(x)(b) = if a = b then x else 0. Since elements of this copower A · M are of the form κa(x) for a ∈ A and x ∈ M we shall also write a copower A · M informally in set-theoretic notation as A × M with tuples ⟨a, x⟩ = κa(x).
The generic trace theory from [10] works for coalgebras of the form X → T (F (X)) where T is a suitable monad and F is a “transition type” functor. Here we shall use F = A + (A × −), for a fixed set A. Its initial algebra is of course the

set A+ of non-empty (finite) sequences of elements of A. Then we can write:
CM(F (X)) = C(M(A + A × X))
∼= C(M(A × (1 + X)))
(8)	∼= C(M(A · (1 + X)))	where · is copower in Sets
∼= C(A · M(1 + X))	since M preserves colimits, as left adjoint
= C(A × M(1 + X))	using the above convention.
Coalgebras X → CM(F (X)) thus correspond to “Segala-style” systems [17], with first a possibilistic choice (via C) followed by a probabilistic one (via M). This last formulation C(A × M(1 + X)) is useful in pictures of systems, like in Section 2.
Because the monad CM is commutative (see Lemma 5.2) and the functor F is “shapely” (built out of coproducts and (finite) products), there is by [10, Lemma 2.3] a distributive law λ: F CM⇒ CMF with components:

(9)
given by:
A + A × CM(X) 	λX	 CM  (A + A × X)

λX = [CM(κ1) ◦ η, CM(κ2) ◦ st],

where st: A × CM(X) → CM(A × X) is the strength operator. Thus:
λ(κ1a) = {1(κ1a)}	and	λ(κ2⟨a, U⟩) = {Σx ϕ(x)κ2⟨a, x⟩| ϕ ∈ U}.

As a result there is a “lifting” to a functor F : Kl(CM) → Kl(CM) given by:

X '−→ FX 
f	Ff	λY


More concretely, we have F (f ): A + A × X → CM(A + A × Y ) given by:
F (f )(κ1a) = {1(κ1a)}	and	F (f )(κ2⟨a, x⟩) = {Σy ϕ(y)κ2⟨a, y⟩| ϕ ∈ f (x)}.

It is obvious that F is locally monotone, i.e. satisfies f ± g ⇒ F (f ) ± F (g). In fact, it is also locally continuous.
At this stage we have almost established sufficiently many properties about the monad CM and the functor F to apply the main result [10, Thm. 3.3] for trace
semantics, stating that the initial algebra F (A+)  ∼=	+ yields a final coalgebra

+ ∼= 	+
−→ A

A  −→ F (A ) in the Kleisli category Kl(CM). This trace semantics, for a coalge-
bra γ: X → CM(F (X)), is constructed via an ascending sequence of Kleisli maps
γn: X → CM(F n(0)), for n ∈ N.


(10)
γ0 = 0 : X −→ 1 = CM(0) = CM(F 0(0))

γn+1 = F (γn) ◦ γ : X −→ F (X) −→ F n+1(0)	in Kl(CM).

From now on we shall assume that our coalgebra γ satisfies 0 ∈ γ(x) for each state x. This can always be enforced by adding 0’s, if needed. It means that after each non- deterministic transition the system/coalgebra can choose to do nothing. Adding such 0’s does not have influence on the trace behaviour. But adding 0’s means that the following two systems become the same.



  a   0	
,,a,,,˛◦ 0	 

·	 ◦ 
    · ¸¸¸¸¸z◦ 	 

b	0
With the assumption 0 ∈ γ(x) we get γ0(x) ⊆ γ1(x), and more generally γn ±
γn+1 so that we have an ascending sequence.
The initial algebra A+ is standardly constructed as colimit of the ω-chain F n(0) = A + A2 + ··· + An = A≤n. In order to be precise we shall write the (colimit) co- projections as κn: F n(0) → A+. The trace map tr: X → CM(A+) is then defined as directed join in the Kleisli homset:
(11)	tr =  ↑ CM(κn) ◦ γn = λx ∈ X.  ↑ CM(κn)(γn(x)).
The following result says that trace semantics for combined possibilistic and probabilistic systems can be obtained via finality in a Kleisli category.
Theorem 7.1 This map tr: X → CM(A+) forms the unique coalgebra homomor- phism to the ﬁnal coalgebra A+ in the Kleisli category Kl(CM), as in:

	(tr)	
FX	 F (A )
,,	,,
γ	∼=
X 	tr	 A +
(where we assume 0 ∈ γ(x), for all x ∈ X).
Very little in this result actually depends on the particular shape of the transition type functor F = A + A × (−). But at this stage we are not interested in full generality.
The proof of the trace theorem in [10] proceeds via the Smyth-Plotkin coinci- dence of limits and colimits [18]. Here it does not work because we do not have bottom elements (but zero elements) in the Kleisli homsets of the monad CM. The proof that is given below—and continued in the appendix—proceeds along the lines of [9].
Proof For clarity let’s write J: Sets → Kl(CM) for the standard functor, given by J(X) = X and J(f ) = η ◦ f and ⊙ for composition in the Kleisli category. We need to show that tr is the unique map satisfying f = J(α) ⊙ F (f ) ⊙ γ, where
α: F (A+) −=→ A+ is the initial algebra.  By construction as colimit, it satisfies
α ◦ F (κn) = κn+1.

We first compute:

J(α) ⊙ F (CM(κn) ◦ γn) ⊙ γ = μ ◦ CM(η ◦ α) ◦ F (CM(κn) ◦ γn) ⊙ γ
= CM(α) ◦ μ ◦ CM(λ ◦ F (CM(κn) ◦ γn)) ◦ γ
(12)	= CM(α) ◦ μ ◦ CM2(F κn) ◦ CM(λ ◦ F (γn)) ◦ γ

= CM(α ◦ F κn) ◦ F (γn) ⊙ γ
= CM(κn+1) ◦ γn+1.

Thus, using that F is locally continuous,

ϕ ∈ J(α) ⊙ F (tr) ⊙ γ (x) ⇐⇒ ϕ ∈ J(α) ⊙ F (  ↑ CM(κ ) ◦ γ ) ⊙ γ (x)

⇐⇒ ϕ ∈  n  J(α) ⊙ F (CM(κn) ◦ γn) ⊙ γ (x)

⇐⇒ ϕ ∈ tr(x) − {0}.

Since 0 ∈ γ(x) and thus 0 ∈ (J(α) ⊙ F (tr) ⊙ γ)(x) we obtain that the restriction ‘−{0}’ can be removed from the last line, and thus that the diagram in the theorem commutes.
In order to prove uniqueness, assume we have a coalgebra homomorphism f : X → CM(A+). Then f = J(α) ⊙ F (f ) ⊙ γ. We need to prove f = tr. The direction (±) is easy: since 0 ∈ γ(x) we have 0 ∈ (J(α) ⊙ F (f ) ⊙ γ)(x) = f (x), so that CM(κ0) ◦ γ0 ± f . This forms the basis for induction:

CM(κn+1) ◦ γn+1 = J(α) ⊙ F (CM(κn) ◦ γn) ⊙ γ by (12)

± J(α) ⊙ F (f ) ⊙ γ	by induction
= f.

↑
n
The proof of the reverse direction is non-trivial, and postponed to the appendix.
 
Example, revisited
Now that we have a sufficiently strong theoretical basis we shall reconsider the example from Section 2. First of all, the system as pictured in (1) may be described as a coalgebra of the form γ: X → C(A × M(1 + X)), where 1 = {C}.
γ(p) = {⟨a, 1 C⟩, ⟨b, 1 q + 1 r⟩, ⟨c, 1 q + 2 r⟩}∪ {⟨l, 0⟩| l ∈ A}
2	2	2	3	3
γ(q) = {⟨d, 1 q⟩, ⟨e, 1C⟩}∪ {⟨l, 0⟩| l ∈ A}
γ(r) = {⟨l, 0⟩| l ∈ A}.

This representation closely follows the picture, except for the zero-steps {⟨l, 0⟩| l ∈

A} which are not written in (1). The convex combination captures non-determinism. For instance, for the semiring [0, ∞], the above set γ(q) may be described explicitly as all convex combinations:
α⟨d, 1 q⟩ + (1 − α)⟨e, 1C⟩,   for α ∈ [0, 1].
The parameter α captures that no choice is made explicitly. Hence non-determinism is represented as an unknown distribution. By combining these “non-deterministic” parameters with the actual “probabilistic” ones iteratively, one obtains traces.
Using the isomorphisms in (8) we can also write the system as a coalgebra γ: X → CM(F (X)) = CM(A + A × X). In doing so we shall omit coprojections κi and simply write l ∈ A + A × X for κ1l and ⟨l, x⟩ ∈ A + A × X for κ2⟨l, x⟩,
assuming that no confusion arises. We then have:
γ(p) = {0, 1 ⟨a, C⟩, 1 ⟨b, q⟩ + 1 ⟨b, r⟩, 1 ⟨c, q⟩ + 2 ⟨c, r⟩}
2	2	2	3	3
γ(q) = {0, 1 ⟨d, q⟩, 1⟨e, C⟩}
γ(r) = {0}.
as described in Section 2. If we elaborate the formula for γn+1 from (10) we get:
γn+1(x) = 
  ⎧⎨ Σ ϕ(⟨l, C⟩)l, +	Σ	  Σ ϕ(⟨l, y⟩)ψ(σ)(lσ) ψ ∈ γn(y), ϕ ∈ γn(x)⎫⎬

⎩	l∈A
l∈A,y∈X
σ∈A+	⎭

where l ∈ A+ is a singleton sequence and lσ ∈ A+ is the sequence cons(l, σ). It is not hard to see that γn(r) = {0} for all n ∈ N. For x = p, q we have:
γn+1(p)

=  ⎧⎨ 0,,  1 a,,  Σ
1 ψ(σ)(bσ) ψ ∈ γn(q), +  Σ 1 ψ(σ)(bσ) ψ ∈ γn(r),,

⎩	σ∈A+
σ∈A+

  σΣ∈A+
⎧



1
3
σ∈A+


2 ψ(σ)(cσ) ψ ∈ γn(r),⎬
⎫



γn+1(q⎩)
	
σ∈A+
σ∈A+	⎭

=  ⎧⎨ 0,, 1e,,  Σ
1 ψ(σ)(dσ) ψ ∈ γn(q),⎫⎬

⎩	σ∈A+	⎭
These formulas can then be used to calculated traces, as already illustrated in Section 2.

Conclusion and further work
Now that the combination of possibilistic and probabilistic computation fits within the coalgebraic framework, many follow-up questions arise. We mention a few.
What is the appropriate coalgebraic modal logic (see e.g. [6] for a recent reference) for the functor CM? One expects modal operators  r, for r ∈ [0, 1] ∩ Q, acting on a subset P ⊆ X of the state space of a coalgebra γ: X → CM(X) as:

 r(P ) = {x ∈ X | ∀ϕ ∈ γ(x).	y∈P ϕ(y) ≥ r}.
What about simulations [8] in this setting?
Is this coalgebraic trace semantics really the same as scheduler semantics?
Is this trace semantics compositional wrt. standard process combinators like par- allel composition, see [11] and also [5])?
Now that the Smyth-Plotkin setting of [10] turns out to be too restrictive for the CM-coalgebras used here—because it assumes bottom elements—the question arises: what is the most general setting for trace semantics?
Acknowledgement
Thanks to Ana Sokolova, Ichiro Hasuo and Chris Heunen for helpful discussion and feedback.

References
S. Abramsky and S.J. Vickers. Quantales, observational logic and process semantics. Math. Struct. in Comp. Sci., 3:161–227, 1993.
M. Barr and Ch. Wells. Toposes, Triples and Theories. Springer, Berlin, 1985. Revised and corrected version available from URL:
www.cwru.edu/artsci/math/wells/pub/ttt.html.
F. Bartels, A. Sokolova, and E. de Vink. A hierarchy of probabilistic system types. Theor. Comp. Sci., 327(1-2):3–22, 2004.
F. Borceux. Handbook of Categorical Algebra, volume 50, 51 and 52 of Encyclopedia of Mathematics. Cambridge Univ. Press, 1994.
L. Cheung. Reconciling Nondeterministic and Probabilistic Choices. PhD thesis, Univ. Nijmegen, 2006.
C. C¨ırstea and D. Pattinson. Modular proof systems for coalgebraic logics. Theor. Comp. Sci., 388:83– 108, 2007.
J. S. Golan. Semirings and their Applications. Kluwer Academic Publishers, 1999.
I. Hasuo. Generic forward and backward simulations. In C. Baier and H. Hermanns, editors, International Conference on Concurrency Theory (CONCUR 2006), number 4137 in Lect. Notes Comp. Sci., pages 406–420. Springer, Berlin, 2006.
I. Hasuo and B. Jacobs. Context-free languages via coalgebraic trace semantics. In J.L. Fiadeiro,
N. Harman, M. Roggenbach, and J. Rutten, editors, Algebra and Coalgebra in Computer Science (CALCO’05), number 3629 in Lect. Notes Comp. Sci., pages 213–231. Springer, Berlin, 2005.
I. Hasuo, B. Jacobs, and A. Sokolova. Generic trace theory. Logical Methods in Comp. Sci., 3(4:11), 2007.

I. Hasuo, B. Jacobs, and A. Sokolova. The microcosm principle and concurrency in coalgebra. In
Foundations of Software Science and Computation Structures, LNCS. Springer, Berlin, 2008.
B. Jacobs. Semantics of weakening and contraction. Ann. Pure & Appl. Logic, 69(1):73–106, 1994.

A. Joyal and M. Tierney. An extension of the Galois theory of Grothendieck. Memoirs of the AMS, 51(309-4), 1984.
S. Mac Lane. Categories for the Working Mathematician. Springer, Berlin, 1971.
S. Lang. Algebra. Addison-Wesley, 2nd rev. edition, 1984.

K.I. Rosenthal. Quantales and their applications. Number 234 in Pitman Research Notes in Math. Longman Scientific & Technical, 1990.

R. Segala. A compositional trace-based semantics for probabilistic automata. In I. Lee and S.A. Molka, editors, Concur’95: Concurrency Theory, number 962 in Lect. Notes Comp. Sci., pages 234–
248. Springer, Berlin, 1995.

M.B. Smyth and G.D. Plotkin. The category theoretic solution of recursive domain equations. SIAM Journ. Comput., 11:761–783, 1982.

R. Tix, K. Keimel, and G. Plotkin.	Semantic Domains for Combining Probability and Non- Determinism. Number 129 in Elect. Notes in Theor. Comp. Sci. Elsevier, Amsterdam, 2005.

D. Varacca. Probability, Nondeterminism and Concurrency: Two Denotational Models for Probabilistic Computation. PhD thesis, Univ. Aarhus, 2003. BRICS Dissertation Series, DS-03-14.

D. Varacca and G. Winskel. Distributing probability over non-determinism. Math. Struct. in Comp. Sci., 16:87–113, 2006.

A  Appendix
We shall write an injection between sets as X > Y and use Inj as the subcategory Inj ‹→ Sets of sets and injective functions between them. This restriction will be used in the next few lemmas.
Lemma A.1 There is a functor M◦: Injop → SMod S(Sets) which is M on objects and on a morphism m: X > Y given as follows. For a multiset ψ ∈ M(Y ),

M◦(m)(ψ) = ψ ◦ m: X −→ Y −→ S.

Then: M◦(m) ◦ M(m) = id.
And if supp(ψ) ⊆ Im(m), then also M(m)(M◦(m)(ψ)) = ψ.
Proof Notice that the support of M◦(ψ) is finite because m is an injection. The mapping M◦ is obviously functorial, and M◦(m) preserves the semimodule struc- ture. For ϕ ∈ M(X) we have:

M◦(m)(M(m)(ϕ)) = λx. M(m)(ϕ)(m(x))
= λx.	x'∈m−1(m(x)) ϕ(x')
= λx. ϕ(x)
= ϕ.

Now assume supp(ψ) ⊆ Im(m). Then:

M(m)(M◦(m)(ψ))(y) =	M◦(m)(ψ)(x)
=	ψ(m(x)) if there is a (unique) x with m(x) = y
0	otherwise
= ψ(y).	 
Lemma A.2 There is also a functor CM◦: Injop → SMod S(ACL) which is CM on objects and on a morphism m: X > Y and multiset V ∈ CM(Y ),
CM◦(V ) = {M◦(m)(ψ) | ψ ∈ V }.
Then: CM◦(m) ◦ CM(m) = id.
Proof We only check the last equation:

CM◦(m)(CM(m)(U )) = {M◦(m)(ψ) | ψ ∈ CM(m)(U )}
= {M◦(m)(M(m)(ϕ)) | ϕ ∈ U}
= {ϕ | ϕ ∈ U}	by the previous result
= U.	 
Next we describe how CM◦ interacts with the Kleisli category. For clarity we shall (again) write ⊙ for Kleisli composition, as described in (7).
Lemma A.3 For an injection m,
CM◦(m) ◦ (g ⊙ f ) = (CM◦(m) ◦ g) ⊙ f.

CM◦(F m) ◦ F (f ) = F (CM◦(m) ◦ f ).
Proof For the first point we use that CM◦(m) is a map in SMod S(ACL), in:
 CM◦(m) ◦ (g ⊙ f ) (x) = CM◦(m)   ϕ∈f(x) Σy∈supp(ϕ) ϕ(y) • g(y) 

=	ϕ∈f(x)	y∈supp(ϕ) CM◦(m) ϕ(y) • g(y)
=	ϕ∈f(x)	y∈supp(ϕ) ϕ(y) • CM◦(m)(g(y))
=	ϕ∈f(x)	y∈supp(ϕ) ϕ(y) • (CM◦(m) ◦ g)(y)
= (CM◦(m) ◦ g) ⊙ f.

For the second point we calculate:

CM◦(F m) ◦ F (f ) = CM◦(F m) ◦ λ ◦ F (f )	with λ from (9)
(=∗) λ ◦ F (CM◦(m)) ◦ F (f )

= F (CM◦(m) ◦ f )

For the marked equation (=∗) we have to check that the distributive law λ: F CM ⇒ CMF from (9) is also a natural transformation λ: F CM◦ ⇒ CM◦F , i.e. that for m: X > Y one has:

λX ◦ (id + id × CM◦(m)) = CM◦(id + id × m) ◦ λY .

This follows by an easy calculation.	 
Now we can fill in the missing step in the proof of Theorem 7.1, namely to show that f ± tr for a coalgebra homomorphism f : X → CM(A+).
Assume therefore ϕ ∈ f (x), where ϕ ∈ M(A+) is a finite multiset of sequences. By finiteness there is an n ∈ N such that ϕ is a multiset over sequences of length at most n, i.e. ϕ ∈ M(A≤n) = M(F n0).
More precisely, we have found an n ∈ N such that supp(ϕ) ⊆ Im(κn), so that we have ϕ = M(κn)(ψ) where ψ = M◦(κn)(ϕ) ∈ CM◦(κn)(f (x)) by Proposition A.1. Now it suffices to prove:
(A.1)	CM◦(κn) ◦ f = γn : X −→ CM(F n(0))
because then we are done: we have ψ ∈ CM◦(κn)(f (x)) = γn(x) and thus ϕ =
M(κn)(ψ) ∈ CM(κn)(γn(x)) ⊆ tr(x).
We prove (A.1) by induction. The case n = 0 is easy because both sides are maps to the terminal object CM(F 0(0)) = CM(0) = 1. The induction step goes much like earlier in the proof, but this time with CM◦ instead of CM, and using Lemma A.3.

CM◦(κn+1) ◦ f = CM◦(κn) ◦ J(α) ⊙ F (f ) ⊙ γ
= CM◦(κn+1) ◦ CM(α) ◦ F (f ) ⊙ γ

= CM◦(κn+1) ◦ CM◦(α−1) ◦ F (f ) ⊙ γ
= CM◦(α−1 ◦ κn+1) ◦ F (f ) ⊙ γ

= CM◦(Fκn) ◦ F (f ) ⊙ γ

= (CM◦(Fκn) ◦ F (f )) ⊙ γ

= F (CM◦(κn) ◦ f ) ⊙ γ
(I=H) F (γn) ⊙ γ
= γn+1.
