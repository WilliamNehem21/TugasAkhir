Electronic Notes in Theoretical Computer Science 138 (2005) 3–22	
www.elsevier.com/locate/entcs

Typechecking Safe Process Synchronization
Eduardo Bonelli1,3
Stevens Institute of Technology and LIFIA 6
Adriana Compagnoni1,4
Stevens Institute of Technology
Elsa Gunter1,2,5
University of Illinois at Urbana - Champaign

Abstract
Session types describe the interactions between two parties within multi-party communications. They constitute a communication protocol in the sense that the order and type of interactions between two parties are specified. For their part, correspondence assertions provide a mechanism for synchronization. When session types and correspondence assertions are combined, they are able to describe synchronization across different communication sessions, yielding a rich language for imposing expressive interaction patterns in multi-party communications.
This paper studies the typechecking problem for Iris, a typed π-calculus that combines session types and correspondence assertions. We define a typechecking algorithm and prove that it is sound and complete with respect to the typing rules. Furthermore, we show that the typing system satisfies the minimum effects property. Although session types have been extensively studied in the past few years, to our knowledge this is the first proof of decidability of typechecking for a type system with session types.
Keywords: Concurrency, π-calculus, type systems, typechecking.


1 Supported in part by NSF Grant No. CCR-0220286 ITR:Secure Electronic Transactions.
2 Supported in part by the ARO under Award No. DAAD-19-01-1-0473.
3 Email:ebonelli@cs.stevens-tech.edu
4 Email:abc@cs.stevens-tech.edu
5 Email:egunter@cs.uiuc.edu
6 Faculty of Informatics, University of La Plata, La Plata, Argentina



1571-0661 © 2005 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2005.05.002

Introduction

Increasingly in our society we are coming to depend upon processors for mon- itoring and controlling devices in almost all aspects of our lives. In many instances the behavior of these processors is governed by communication with other processors, which may be other components of the same system or may be remotely located. Examples where such communication is critical can be found in space exploration, air traffic control, medical devices, banking, and electronic commerce. It is of great importance to have high assurance that the software governing these communications and resulting decisions is correct.
The approach presented in this work applies to any situation where there is communication between multiple parties that can be factored into one-to- one communications. Session types [17,18] allow one to describe the exchange of information between two parties. They describe the information being exchanged, in which order it is exchanged, what party sends it, what party receives it, and the type of the information. However, session types alone fall short in restricting process interaction. For example, a small system involving processes Client, ATM and Bank is developed in [1,4]. It illustrates situations which cannot be captured by session types, including:
When Client requests a deposit operation from ATM, ATM may redirect some of the funds to a different account without violating the session-type based protocol description.
ATM may forward an amount which does not coincide with the one it read in from Client.
ATM may receive a deposit from Client and never contact Bank.
Combining session types with correspondence assertions [23,12,14] increases considerably the expressiveness of the interaction patterns that may be im- posed on processes. Examples of properties that may now be addressed are [1,4]:
the balance that Client receives always comes from Bank, and the amount to be deposited received by Bank always comes from Client.
ATM should behave as a forwarder that does not alter the data received from Bank or Client.
we can detect that ATM is attempting a deposit not instructed by Client or tries to deposit a smaller amount than the one specified by Client.
Iris, a statically typed language based on the π-calculus that extends [18] with correspondence assertions [11,14], was first introduced in [1]. There it was shown that the type system allows us to detect irregularities in concurrent

communications such as the unauthorized modification of data, missing or avoided communications, and extra unintended communications. In this paper we continue the study of Iris by showing that typechecking is decidable.
Related work. Regarding session types, they have attracted considerable attention in the past decade motivated by the benefits that such type systems provide for the analysis of protocols. The initial proposal for session types was by K. Honda et al. [17]. Natural extensions of this work that have been studied include subtypes [8] and bounded polymorphism [16]. They have also been studied in the context of component-based software development [22] and reformulated in the λ-calculus with input/output operations [9]. Regarding type-checking and inference, in [7] a sort inference algorithm for the polyadic π-calculus is given. B. Pierce and D. Turner define a type checking and type inference algorithm for PICT, a concurrent programming language based on a polymorphic version of the π-calculus. The Cryptic Project, a joint project be- tween A. Gordon and A. Jeffrey, includes an implementation of a type-checker for the language they developed in [12,11,14,13] that includes correspondence assertions and public and private data. Regarding the processes as models paradigm introduced by Chaki et al. in [6] there is also an implementation of a type-checker (called Piper) for their language. Typechecking for the common part of the generic type system in [19,20] is discussed in that paper. Recently, a type-inference system called TyPiCal has been developed by N. Kobayashi that permits lock-freedom analysis, deadlock-freedom analysis, useless-code elimination, and information flow analysis [21].

The Iris-Calculus
Syntax
We assume given a set of names x, y, z,... We distinguish two distinct kinds of names: expression names, written a, b, c, . . . (which range over sessions and in- tegers); and channel names, written k, h, k',... We also have integer constants
..., −1, 0, 1,... and (branching) labels l, l',... A value is an expression name or an integer constant and is denoted with letters v, v',... Assertion labels, written L, L',.. ., are tuples of values and are written ⟨v1,..., vn⟩. Process expressions, denoted with P, Q, . . ., are defined as follows 7


7 In our technical report [3] we a)lso deal with a process declar)ation construct def D in P where D takes the form X1[a1 : T1] = P1 and ... and Xn[an : Tn] = Pn and a process call construct X[→v]. These have been omitted due to space restrictions.

P ::= request a(k) in P | accept a(k) in P | k?(x) in P | k![v]; P | throw k[k']; P | catch k(k') in P | (νa : T )P | (νk : ⊥{α,α})P | k ¢ l; P | k ¢ {l1 : P1	 ln : Pn} | stop | P | Q |
begin L; P | end L; P
Remark 2.1 Parentheses are binding constructs. Two process expressions which differ only in the names of their bound names are called α-equivalent and shall be considered equal. We use the notation P {a ← v} for the result of substituting all free occurrences of a in P by v, and similarly for P {k ← k'}. The set of free names of a process expression, written fn(P ), and that of an assertion label, likewise written fn(e), are defined in the standard manner (see [2] for details).
The request primitive requests a session on name a. When this session is established, the fresh private channel k shall be used for message interchange. The accept receives a request on the same name a and generates a new pri- vate channel for message interchange to be used once the session is established. The request and accept constructs each bind all free occurrences of the im- mediately following channel variable, k, in the subsequent process, P . The synchronous sending and receiving of messages is achieved with k![v]; Q and k?(x) in P respectively, although, as in [18], a translation to an asynchronous calculus with branching is possible. Controlled side-stepping of linearity con- straints on channel usage is achieved by means of the channel delegation con- structs throw k[k']; P and catch k(k') in Q. Mechanisms for selection of a label and branching are available as k  l; P and k D {l1 : P1	  ln : Pn}.
The notation P | Q stands for the concurrent execution of P and Q; we also use stop for inaction. We write (νa : T )P or (νk : ⊥{α,α})P for the usual constructs for name hiding, where the former is for expression names and the latter for channel names. T denotes a type expression (Def. 2.2) and ⊥{α,α} is the “complete” channel type with communication protocol given by the chan- nel type α. Note that ⊥{α,α} = ⊥{α,α}. The begin and end assertions shall be used as type directives in the type system for Iris (Sect. 2.2.1): begin L; P simply asserts begin L and then behaves as P ; likewise end L; P asserts end L and then behaves as P . The operational semantics of Iris in the form of a re- duction relation on processes is given in Fig. 1. As usual, it relies on the notion of structural congruence whose definition in Iris is standard.
The Type Discipline
Session types and effects
The type system assigns an effect to a process under a given set of type assumptions.	The effect of a process reflects its pending obligations.	An

(accept a(k) in P1)| (request a(k) in P2) −→ (νk : ⊥{α,α})(P1| P2) Trans Link (k![v]; P1)| (k?(a) in P2) −→ P1| P2{a ← v}	Trans Comm (k ¢ li; P )| (k ¢ {l1 : P1 ... ln : Pn}) −→ P| Pi, if i ∈ 1..n	Trans Brnch (throw k[k']; P1)| (catch k(k'') in P2) −→ P1| P2{k'' ← k'}	Trans Catch begin L; P −→ P	Trans Begin
end L; P −→ P	Trans End
P −→ P' ⇒ (νx : U )P −→ (νx : U )P'	Trans Res
P −→ P' ⇒ P| Q −→ P'| Q	Trans Par
P ≡ P',P' −→ Q', Q' ≡ Q ⇒ P −→ Q	Trans ≡
Fig. 1. Unlabelled Reduction Semantics for Iris
assertion of the form begin L reduces these obligations by withdrawing the assertion label L from the current effect; likewise end L augments the current effect with L. Thus effects determine lower-bounds of the number of begin assertions that must be present. If the process has an empty effect, then all end assertions correspond to a matching begin assertion.
As explained above, effects also have to be attached to channel types in order for two or more processes to share information on their pending or latent effects. Effects added to channels are thus called latent effects.
Definition 2.2 [Types with Effects] Assertion labels, effects and types are given by the following grammar:
Plain Type	T	::= Int | σ(α)
Channel Type	α, β  ::= ↓ [a : T ]e; α | ↑ [a : T ]e; α | ↓ [α]e; β
| ↑ [α]e; β |  &{l1 : α1,..., ln : αn}e
| ⊕{l1 : α1,..., ln : αn}e | 1 | ⊥{α,α}
Effect	e, e' ::= (| L1,..., Ln |)
Assertion Label L, Li ::= ⟨v1,..., vn⟩
A type is either a plain type or a channel type; we use U, Ui to range over types. The set of free names of a type U , written fn(U ), is defined as usual (see [2]). The base type Int is the type of integer constants. Session types are represented as σ(α) and may informally be seen to denote a pair consisting of a channel type α and its dual α:



↓ [a : T ]e; α
↓ [α]e; β


&{li : αi}e
def


= ↑ [a : T ]e; α	↑ [a : T ]e; α
def	
= ↑ [α]e; β	↑ [α]e; β
def


= ⊕{li : αi}e	⊕{li : αi}e
def


= ↓ [a : T ]e; α	1
def	
= ↓ [α]e; β
def


= &{li : αi}e
def
= 1

The types α and α shall be assigned to the two endpoints of a commu- nication session. Note that ⊥{α,α} is not defined. A channel type consists of a sequence of input/output types of values or channels, or branch/selection types; the sequence is assumed to terminate with the channel type terminator
1. Each of these is accompanied by a latent effect. An effect is a multi-set of assertion labels; we use (| ... |) for the multi-set constructor. Multiset subtrac-

tion is defined as e \ e', the smallest multiset e'' such that e ≤ e' + e'', where “+” is multiset union. Multiset join is defined as e ∨ e', the smallest multiset e'' such that e ≤ e'' and e' ≤ e''. The special channel type ⊥{α,α} models a channel that has not yet been opened and shared between two subprocesses of the current process.

Typing Rules
An environment Γ is a set of type assumptions x1 : U1 · ... · xn : Un where x1,..., xn are distinct names. We use letters Γ, Δ,... for environments. The domain of Γ, written dom(Γ), is the set {x1,..., xn}, and the range of Γ, written ran(Γ), is the set {U1,..., Un}. Also, we write domCh(Γ) for the subset of names to which Γ assigns channel types and domPl(Γ) for the subset of names to which Γ assigns plain types. The free names of Γ, written fn(Γ), is the set of names occurring either in the domain of Γ, or free in a type in the range of Γ,
i.e. fn(Γ) = dom(Γ) ∪ U∈ran(Γ) fn(U ). In an assumption x : U , x is called the subject; if the type assigned to the subject is a plain type then the assumption is said to be a plain assumption, otherwise it is a channel assumption. We write Γ · x : U for the environment resulting from extending Γ with the type
assumption x : U for x ∈/ dom(Γ). The notation Γ \ x : U stands for the
environment resulting from dropping the assumption x : U from Γ, assuming
it exists. Since there is a unique U such that x : U ∈ Γ for any x ∈ dom(Γ), we may sometimes abbreviate Γ \ x : U by Γ \ x. For any x ∈ dom(Γ), we will use Γ(x) for the unique type such that (x : Γ(x)) ∈ Γ.
Definition 2.3 [Depends on] xi : Ui depends directly on xj : Uj in Γ (written (xj : Uj) ‹→d (xi : Ui)), if xj ∈ fn(Ui). We say xi : Ui depends on xj : Uj in Γ if xi : Ui ‹→ xj : Uj, where ‹→ denotes the transitive closure of ‹→d.
An environment is well-formed if it satisfies the following three conditions:
C1. For each x ∈ domPl(Γ), x is an expression name, and for each y ∈
domCh(Γ), y is a channel name.
C2. For each i ∈ 1..n, fn(Ui) ⊆ dom(Γ) \ {xi}.
C3. The relation ‹→ is irreflexive, that is, xi : Ui /‹→ xi : Ui for all xi : Ui ∈ Γ.
The first condition, C1, requires that only channel types be assigned to channel names, and only plain types be assigned to expression names. Condi- tion C2 requires that all free names in types assigned by Γ must be declared within Γ. Note that since channel names may not appear in assertion labels, and hence not in fn(Ui), types may only depend on names which are assigned plain types. Since interaction through channel names is restricted by linearity conditions in the sense of linear logic [10] (see explanation of Type Par rule

below), this restriction states that we do not allow types depending on linear assumptions; we do however allow types depending on shared assumptions, that is, those of plain types. The intended application of our type discipline is not disturbed by such a restriction, and it is not clear whether the technical complications of the meta-theory resulting from lifting it outweigh its benefits. In fact this restriction already appears in other settings in which linear and intuitionistic assumptions coexist, such as the linear logical framework of [5]. The last condition, C3, requires that Γ have no cyclic dependencies. This is usually guaranteed by the representation of environments as sequences of type assumptions, in which an assumption x : U depends only on those appearing to its left. Such a representation seems unfit in a setting where channel types are present, since basic results on admissibility of structural rules fail [3].
The Iris type system consists of the following judgements:
Γ ▶ ⬦	well-formed environment Γ Γ ▶ v : T	well-typed value v of type T
Γ ▶ P : e	well-typed process P with effect e
The typing rules of Iris are presented in Fig. 2. The rules Type Acpt and Type Requ introduce a new channel name in the environment, thus guaran- teeing that a private channel is being used for the session. Note that dual channel types are used for the requesting and accepting parties. Type Bgn and Type End affect process effects by eliminating or adding a new assertion label. The rules Type Snd and Type Rcv allow the typing of the communica- tion primitives for sending and receiving data. Note that data is sent and received over channels only. Also, note that the type of k in the upper right- hand judgement of Type Snd is α{a ← v}, reflecting the fact that the “rest” of the channel type, namely α, may depend on the output value v. In the Type Snd rule, the latent effect associated to the ouput type of k becomes a credit. In other words, it becomes a “payment” obligation that must be met by some prior begin assertion or some prior receive operation. Similar com- ments apply to the Type Rcv rule. Note, however, that this time the latent effect of the type of the parameter of the input (i.e. “b”) becomes a debit or payment. Type Brnch and Type Sel type the branching and selection primi- tives, respectively; if pending effects are seen as credits, then it is clear that the effects of each branch in Type Brnch must be joined. Channel delegation is achieved by means of the throw and catch primitives, which are typed by means of Type Thr and Type Cat. The rule Type Thr is subject to the restric- tion that β /= 1; this restricts delegation of channels to those through which

communication is possible, i.e. no “dead” channels 8 . Channel and name re- striction (for non-channel names) are typed as expected. Type Stop types the inaction stop; it requires all communication through channel names to have been completed. The Type Subs rule allows increasing the required assertion obligations of a process term.
The Type Par rule types the parallel execution of two processes. A channel may be used by one of the two processes P or Q. The only exception to this rule is when both P and Q use a channel k of dual types. Since channel usage must be restricted in order to guarantee such linear usage, the environments Γ and Γ' are required to be compatible (Fig. 4). Note that the notion of compatibility makes sense for two sets of assumptions that do not necessarily constitute well-formed environments. Once this notion of compatibility is in place we may define how two environments are combined through environment composition (Fig. 4). The subscript of ⊥{α,α} in the second clause of the definition of composition of environments (Fig. 4) records the dual channel types from which it arises, and hence the name dependencies of those dual channel types.

Typechecking
We define a typechecking function Ch(Γ,P ), where Γ is an environment and P is a process. The function Ch(Γ,P ) is defined by recursion over the length of P , and will either return fail or the minimum possible effect for P . We use two auxiliary functions:
ChEnv(Γ), which checks the well-formation of contexts returning true if and only if Γ ▶ ⬦,
ChTy(Γ, v,T ) which checks the types of values returning true if and only if Γ ▶ v : T .
ChEnv(Γ) checks that the environment Γ is well-formed. This requires checking conditions C1, C2, and C3. To check C3, we construct the directed graph with edges pointing from names in domain of the environment to each of the free names in the type the environment associates with it. (In the process, we can easily check conditions C1 and C2.) Once we have constructed the graph, we apply any standard algorithm to check that it is cycle free. If v is a numerical constant, ChTy(Γ, v,T ) checks if T = Int; otherwise it checks if v : T is in the environment Γ, and then calls ChEnv(Γ).

8 Technically, this allows us to correct a problem present in [18], namely the failure of Subject Congruence.



Γ · a : σ(α) · k′ : α ▶ P {k ← k′} : e  k′ /∈ dom(Γ) Γ · a : σ(α) ▶ accept a(k) in P : e


Γ · a : σ(α) · k′ : α ▶ P {k ← k′} : e  k′ /∈ dom(Γ)

Γ · a : σ(α) ▶ request a(k) in P : e

Type Acpt

Type Requ

Γ ▶ P : e fn(L) ⊆ dom(Γ) Γ ▶ begin L; P : e \ (| L |)

Type Bgn
Γ ▶ P : e fn(L) ⊆ dom(Γ) Γ ▶ end L; P : e + (| L |)

Type End

Γ ▶ v : T	fn(e′) \ {a} ⊆ dom(Γ)  Γ · k : α{a ← v} ▶ P : e

Γ · k :↑ [a : T ]e′; α ▶ k![v]; P : e + e′{a ← v}
Type Snd



Γ · c : T · k : α{a ← c} ▶ P {b ← c} : e
fn(e′) \ {a} ⊆ dom(Γ)	c /∈ fn(e \ e′{a ← c}) ∪ fn(Γ)


Γ · k :↓ [a : T ]e′; α ▶ k?(b) in P : e \ e′{a ← c}
Γ · k : α1 ▶ P1 : e1 ... Γ · k : αn ▶ Pn : en	fn(e′) ⊆ dom(Γ)


Type Rcv

Γ · k
: &{l1
: α1,..., ln
: αn}e′
▶ k D {l1
: P1,..., ln
n
: Pn}
: ( 
ei)
Type Brnch
\ e′

Γ · k : αj ▶ P : e  (1 ≤ j ≤ n)  fn(e′) ∪   fn(α) ⊆ dom(Γ)
	i=1	 Type Sel
Γ · k : ⊕{l1 : α1,..., ln : αn}e′ ▶ k  lj; P : e + e′
Γ · k : α ▶ P : e  fn(β) ∪ fn(e′) ⊆ dom(Γ)  β /= 1

Γ · k′ : β · k :↑ [β]e′; α ▶ throw k[k′]; P : e + e′
Type Thr

Γ · k′′ : β · k : α ▶ P {k′ ← k′′} : e  fn(e′) ∈ dom(Γ)  k′′ /∈ dom(Γ) Γ · k :↓ [β]e′; α ▶ catch k(k′) in P : e \ e′
Γ · k′ : ⊥{α,α} ▶ P {k ← k′} : e  k′ /∈ dom(Γ)

Type Cat

Γ ▶ (νk : ⊥{α,α})P : e
Γ · b : T ▶ P {a ← b} : e b /∈ fn(Γ) ∪ fn(e) Γ ▶ (νa : T )P : e
Type CRes

Type NRes

Γ ▶ ⬦  ranCh(Γ) ⊆ {1, ⊥{α,α}}

Γ ▶ stop : (||)
Γ ▶ P : e  e ≤ e′	fn(e′) ⊆ dom(Γ)
Type Stop		 Type Subs
Γ ▶ P : e′

Γ ▶ P : e Γ′ ▶ Q : e′	Γ = Γ′ Γ ◦ Γ′ ▶ P | Q : e + e′

Type Par

Fig. 2. Well-typed process expressions



Γ · a : T ▶ ⬦ 


Γ · a : T ▶ a : T

Wf Val EName
Γ ▶ ⬦  n ∈ Z

Γ ▶ n : Int

Wf Val Int






∅ = ∅ 
Γ = Γ′ implies
Γ · a : T = Γ′ · a : T
Γ · k : α = Γ′ · k : α
Fig. 3. Well-typed values
∅◦∅ = ∅
(Γ · a : T ) ◦ (Γ′ · a : T ) = (Γ ◦ Γ′) · a : T
(Γ · k : α) ◦ (Γ′ · k : α) = (Γ ◦ Γ′) · k : ⊥




{α,α}

Γ · k : α = Γ′, if k ∈/ dom(Γ′)
Γ = Γ′ · k : α, if k ∈/ dom(Γ)
(Γ · k : α) ◦ (Γ′) = (Γ ◦ Γ′) · k : α, if k ∈/ dom(Γ′)
Γ ◦ (Γ′ · k : α) = (Γ ◦ Γ′) · k : α, if k ∈/ dom(Γ)



Fig. 4. Compatible environments and composition of environments
When defining the clause of Ch for parallel composition, it will be useful to have a few special-purpose definitions.
Definition 3.1 Extended environments extend plain environments by allow- ing channel names to be associated with plain types of the form σ(α) (session types). Given an extended environment Γ, let:
domChoice(Γ) = {k ∈ domCh(Γ) | Γ(k)= σ(α) for some channel type α}.
We will call a regular environment Γ' a specialization of an extended envi- ronment Γ if dom(Γ') = dom(Γ), and for all x ∈ dom(Γ) \ domChoice(Γ) we have Γ'(x)= Γ(x), and for all k ∈ domChoice(Γ), if Γ(k)= σ(α), then either Γ'(k)= α or Γ'(k)= α. Let:
Σ(Γi)= {Γ' | Γ' is a specialization of Γi}.
i	i
Definition 3.2 Let P and Q be processes and Γ be an environment. We define the split of Γ with respect to P and Q by:
If fn(P ) ∪ fn(Q) /⊆ dom(Γ), then split(Γ, P, Q)= fail.
If there exists k ∈ fn(P ) ∩ fn(Q) such that Γ(k) /= ⊥{α,α} for any α, then
split(Γ, P, Q)= fail.
Otherwise, split(Γ, P, Q)= (Γ1, Γ2) where Γ1 and Γ2 are extended environ- ments defined by the following:
dom(Γ1) ⊆ dom(Γ) and dom(Γ2) ⊆ dom(Γ).
For all a ∈ domPl(Γ), a ∈ dom(Γ1) ∩ dom(Γ2) and Γ1(a)= Γ2(a)= Γ(a).
For k ∈ fn(P ) ∩ fn(Q) and Γ(k)= ⊥{α,α}, Γ1(k)= Γ2(k)= σ(α).
For all k ∈ fn(P ) but k /∈ fn(Q), k /∈ dom(Γ2) and Γ1(k)= Γ(k).
For all k ∈ fn(Q) but k /∈ fn(P ), k /∈ dom(Γ1) and Γ2(k)= Γ(k).
For all k ∈ dom(Γ) \ (fn(P ) ∪ fn(Q)), we will (arbitrarily) assign Γ1(k)= Γ(k), and have k /∈ dom(Γ2).

These definitions are used in the clause defining Ch(Γ,P | Q). The function
split is used to divide the environment Γ into two extended environments, Γ1

and Γ2, such that for appropriate Γ'
∈ Σ(Γ1) and Γ'
∈ Σ(Γ2), Γ = Γ'
Γ' .

The difficulty is that when Γ(k)= ⊥{α,α}, we may need to send k : α to one
side and k : α to the other, but we do not know which side is going to get which. The sets Σ(Γ1) and Σ(Γ2), where (Γ1, Γ2)= split(Γ, P, Q), allow us to
enumerate a sufficient set of possibilities for Γ' and Γ' .
There were several arbitrary choices made in the definition of split. First, we could have sent k : Γ(k) to Γ2 for any or all of the k ∈ dom(Γ) \ (fn(P ) ∪ fn(Q)). Secondly, if Γ(k) = ⊥{1,1}, then we had an additional option of assigning k :1 to each of Γ1 and Γ2. The use of these arbitrary choices in the definition of Γ is justified by the fact that they do not alter the result of the type checking function Ch (see [3] for a proof of this fact).

Deﬁning the Typechecking Function Ch
We define Ch(Γ,P ) by induction on the length of P . To ensure well-definedness, we assume that all classes of names are totally ordered and that when choosing a fresh name we choose the least fresh name.
If fn(P ) /⊆ dom(Γ), then Ch(Γ,P ) is defined to return fail. In all subse- quent cases we will assume that fn(P ) ⊆ dom(Γ). In most cases the def- inition of Ch can be read-off from the type rules. For example, if P is request a(k) in Q, then we let k' be a fresh channel variable not present in dom(Γ) and define Ch(Γ, request a(k) in P ) as:
Ch(Γ · k' : α, P {k ← k'}) if Γ(a)= σ(α), and
fail, otherwise.
The exception is the case of parallel composition, which requires further attention. If split(Γ, P, Q) returns fail, then Ch(Γ,P | Q) is defined to return fail too. Otherwise, if split(Γ, P, Q) /= fail, let (Γ1, Γ2)= split(Γ, P, Q). Notice that domChoice(Γ1)= domChoice(Γ2) for the extended environments Γ1 and Γ2 defined above. Also notice that the number of regular environments that are a specialization of a given extended environment Γi is 2|domChoice(Γi)| ≤ 2|domCh(Γi)|. We define Ch(Γ,P | Q) as:

Ch(Γ' ,P )+ Ch(Γ' , Q), if there exists Γ' ∈ Σ(Γ1) and Γ'
∈ Σ(Γ2) such that

1	2	1	2
Ch(Γ' ,P ) /= fail and Ch(Γ' , Q) /= fail and for all k ∈ domChoice(Γ1) = 
1	2
domChoice(Γ2), Γ' (k)= Γ' (k), and
1	2
fail, otherwise.
Note that there is at most one specialization Γ' ∈ Σ(Γ1) and at most one
specialization Γ' ∈ Σ(Γ2) such that Ch(Γ' ,P ) /= fail and Ch(Γ' , Q) /= fail.
2	1	2

Properties of Ch
There are several points in the definition of Ch where one of two kinds of choices are made: The first is the choice of fresh names and the second appears in the case of parallel composition Q| R, where we “split” our environment Γ into two extended environments Γ1 and Γ2, and then choose specializations
Γ' and Γ' respectively, such that Ch(Γ' , Q) /= fail and Ch(Γ' , R) /= fail.
1	2	1	2
Nonetheless, the following result holds.
Proposition 3.3 (Well-definedness of Ch) Ch is a total function.
Proof. This relies on two main lemmas. The first one states the choice of fresh name does not affect the output of Ch. The second one states that if the

aforementioned specializations Γ'
and Γ'
exist, then they are unique. Finally,

it is noted that the size of the third argument (process P ) decreases in every recursive call.	 
For the proof of completeness we may assume that the type derivation of Γ ▶ P : e does not include applications of Type Subs. This follows from the observation that if Γ ▶ P : e, then for some e' ≤ e, Γ ▶ P : e' is derivable without using Type Subs.
Proposition 3.4 (Completeness) If Γ ▶ P : e, then Ch(Γ,P ) /= fail and
Ch(Γ,P ) ≤ e.
Proof. By induction on the derivation of Γ ▶ P : e. All cases follow from standard lemmas except for the parallel composition case. This case requires the following result whose proof is simple but tedious.
Lemma 3.5 Let Γ1 and Γ2 be environments such that Γ1 = Γ2, and let Γ = Γ1 ◦ Γ2. Suppose that Ch(Γ1,P ) /= fail and Ch(Γ2, q) /= fail and split(Γ, P, Q) /= fail for some processes P and Q. Let (Π1, Π2)= split(Γ, P, Q).
Then there exist Γ' ∈ Σ(Π1) and Γ' ∈ Σ(Π2) such that Γ' = Γ' and Γ= Γ' ◦Γ'
1	2	1	2	1	2
and Ch(Γ' ,P )= Ch(Γ1,P ) and Ch(Γ' , Q)= Ch(Γ2, Q).
1	2
The proof of the parallel composition case proceeds as follows: Suppose Type Par was the last rule to be applied. Then P = Q| R and there exist environments Γ1 and Γ2 and effects e1 and e2 such that Γ1 ▶ Q : e1 and Γ2 ▶ R : e2 and Γ1 = Γ2 and Γ = Γ1 ◦ Γ2 and e = e1 + e2. By the inductive hypothesis, we have that Ch(Γ1, Q) /= fail, Ch(Γ1, Q) ≤ e1, Ch(Γ2, R) /= fail, and Ch(Γ2, R) ≤ e2.
Since Ch(Γ1, Q) /= fail and Ch(Γ2, R) /= fail, we have fn(Q) ⊆ dom(Γ1) and fn(R) ⊆ dom(Γ2). Also, since Γ = Γ1 ◦ Γ2, we have that fn(Q) ∪ fn(R) ⊆ dom(Γ) and for each k ∈ fn(Q) ∩ fn(R) there exists an α such that

Γ(k)= ⊥{α,α}. Therefore split(Γ, Q, R) is defined and we may take (Π1, Π2)= 

split(Γ, Q, R). By Lemma 3.5 there exist Γ'
∈ Σ(Π1) and Γ'
∈ Σ(Π2) such

that Γ' = Γ' and Ch(Γ' , Q)= Ch(Γ1, Q) and Ch(Γ' , R)= Ch(Γ2, R). Since
1	2	1	2
Γ' = Γ' , we have that Γ' (k) = Γ' (k) for all k ∈ domChoice(Γ1). Therefore,
1	2	1	2
by the definition of Ch we have that Ch(Γ, Q| R) /= fail and
Ch(Γ, Q| R)= Ch(Γ' , Q)+ Ch(Γ' , R)= Ch(Γ1, Q)+ Ch(Γ2, R) ≤ e1 + e2 = e
1	2

Proposition 3.6 (Soundness) If Ch(Γ,P ) /= fail, then Γ ▶ P : Ch(Γ,P ).
Proof. By induction on the definition of Ch(Γ,P ). We show two sample cases.
accept a(k) in P : By the definition of Ch, Ch(Γ, accept a(k) in P ) = Ch(Γ · k' : α, P {k ← k'}), where k' /∈ dom(Γ) and Γ(a) = σ(α). By the induction hypothesis, Γ · k' : α ▶ P {k ← k'} : Ch(Γ · k' : α, P {k ← k'}).	By the definition of Ch, and applying Type Acpt, Γ · a : σ(α) ▶ accept a(k) in P : Ch(Γ, accept a(k) in P ).
P | Q : By the definition of Ch, Ch(Γ,P | Q) = Ch(Γ' ,P ) + Ch(Γ' , Q), for
1	2
some Γ' and Γ' . By construction of Γ' and Γ' , it follows that Γ' = Γ'
1	2	1	2	1	2
and Γ = Γ' ◦ Γ' , and by the induction hypothesis, Γ' ▶ P : Ch(Γ' ,P ) and
1	2	1	1
' ▶ Q : Ch(Γ' , Q). Finally, by the rule Type Par, the result follows.

Corollary 3.7 (Minimum Effects) If Γ ▶ P : e, then Γ ▶ P : Ch(Γ,P )
and Ch(Γ,P ) ≤ e.
Proof. The result holds immediately from Soundness (Proposition 3.6) and Completeness (Proposition 3.4).	 
We can now state our main result.
Corollary 3.8 (Decidability of Typechecking) Given Γ, Θ, P and e it is decidable whether Γ ▶ P : e.
Proof. We first call Ch(Γ,P ) that always terminates, by Proposition 3.3. If Ch(Γ,P )= fail, by Completeness (Proposition 3.4), Γ ▶ P : e is not derivable. If Ch(Γ,P ) /= fail, we check the multiset inclusion Ch(Γ,P ) ≤ e which is also decidable. If Ch(Γ,P ) ≤ e holds, then by Soundness (Proposition 3.6) and Type Subs, Γ ▶ P : e. If Ch(Γ,P ) /≤ e, by Completeness (Proposition 3.4), Γ ▶ P : e is not derivable.	 

Conclusions and Future Work


A session type describes the interactions between two parties within multi- party communications. It is a communication protocol describing the order and type of interactions between two parties. Iris is a typed π-calculus re- sulting from a combination of session types with correspondence assertions that takes session types a step further. Iris allows the description of the ex- change protocol, and also the synchronization between parties that may not participate in the same session.
This paper studies the typechecking problem for Iris. We define a type- checking algorithm Ch(Γ,P ) that checks whether process P is typable under the typing assumptions in Γ. If P is typable under Γ, it returns the least effect for P , and otherwise it returns fail. Although session types have been extensively studied in the past few years, to our knowledge this is the first proof of decidability of typechecking for a type system with session types. A related open problem that we are currently investigating is the decidability of type inference, where type unification has to be considered in the presence of equations such as those defining the dual of a channel type.
Iris allows us to express the relationship between the information being sent at its origin and the information being received at the intended destination. If we stay within a decidable fragment, such as linear arithmetic, we can capture a considerable family of communication and data exchange patterns: in a large percentage of the cases where data is transferred, we are interested in seeing the exact same data at both ends, and many other cases involve very simple linear arithmetic transformations. For example, frequently an ATM is allowed to charge a processing fee for a transaction, and then the relation between the amount entered by the Client and that received by the Bank will not be identical, but will satisfy a simple linear arithmetic equation. To address this issue we are considering the extension of Iris with arithmetic.
If we allow general arithmetic, which is not decidable, we can expect to define a sound semi-decision procedure: An algorithm without false positives or false negatives. If the algorithm says yes, then all information can be traced back to its sources. If the algorithm says no, the algorithm will exhibit a path showing that the data is not coming from the intended origin. If the algorithm fails to terminate, then we cannot deduce any information.
Future work also includes developing the formal theory of this calculus in HOL [15] and using the development to encode and reason about security and networking protocols.

Acknowledgement
We are grateful to the LSS group at Stevens for interesting discussions. We also thank Georgi Babayan, Pablo Garralda, Healfdene Goguen and Ricardo Medel for comments and suggestions.

References
Bonelli, E., A. Compagnoni and E. Gunter, Correspondence assertions for process synchronization in concurrent communications, in: A. Brogi, J.-M. Jacquet and E. Pimentel, editors, FOCLASA 2003. 2nd International Workshop on Foundations of Coordination Languages and Software Architectures, Electronic Notes in Theoretical Computer Science 97 (2003), pp. 175–195.
Bonelli, E., A. Compagnoni and E. Gunter, Correspondence assertions for process synchronization in concurrent communications, Technical Report 2003-8, Department of Computer Science, Stevens Institute of Technology (2003).
Bonelli, E., A. Compagnoni and E. Gunter, Typechecking safe process synchronization, Technical Report 2004-3, Department of Computer Science, Stevens Institute of Technology (2004).
Bonelli, E., A. Compagnoni and E. Gunter, Correspondence assertions for process synchronization in concurrent communications, Journal of Functional Programming, Special issue on Language-Based Security 15 (2005).
Cervesato, I. and F. Pfenning, A linear logical framework, Information and Computation 179
(2002), pp. 19–75.
Chaki, S., S. Rajamani and J. Rehof, Types as models: Model checking message-passing programs, in: Proceedings of the 29th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (2002), pp. 45–57.
Gay, S., A sort inference algorithm for the polyadic pi-calculus, in: Proc. of the 20th ACM SIGACT/SIGPLAN Symposium on Principles of Programming Languages (1993), pp. 429– 438.
Gay, S. and M. Hole, Types and subtypes for client-server interactions, in: Proceedings of the European Symposium on Programming Languages and Systems, number 1576 in LNCS (1999),
pp. 74–90.
Gay, S., V. Vasconcelos and A. Ravara, Session types for inter-process communication, Technical Report TR-2003-133, Department of Computing Science, University of Glasgow (2003).
Girard, J.-Y., Linear Logic, Theoretical Computer Science (1987), pp. 1–102.
Gordon, A. and A. Jeffrey, Authenticity by typing for security protocols, in: 14th IEEE Computer Security Foundations Workshop (2001), pp. 145–159.
Gordon, A. and A. Jeffrey, Typing correspondence assertions for communication protocols, in: Seventeenth Conference on the Mathematical Foundations of Programming Semantics (MFPS 2001), number 45 in ENTCS (2001).
Gordon, A. and A. Jeffrey, Authenticity by typing for security protocols, Journal of Computer Security 11 (2003), pp. 451–521.
Gordon, A. and A. Jeffrey, Typing correspondence assertions for communication protocols, Theoretical Computer Science 300 (2003), pp. 379–409.


Gordon, M. J. and T. F. Melham, “Introduction to HOL: A theorem proving environment for higher-order logic,” CUP, Cambridge, 1993.
Hole, M. and S. Gay, Bounded polymorphism in session types, Technical Report TR-2003-132, Department of Computing Science, University of Glasgow (2003).
Honda, K., M. Kubo and K. Takeuchi, An interaction-based language and its typing system, in: Proceedings of PARLE’94, number 817 in LNCS (1994), pp. 398–413.
Honda, K., V. Vasconcelos and M. Kubo, Language primitives and type discipline for structured communication-based programming, in: Proceedings of ESOP’98, LNCS (1998), pp. 122–138.
Igarashi, A. and N. Kobayashi, A generic type system for the pi-calculus, in: Proceedings of the 28th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (2001),
pp. pp.128–141.
Igarashi, A. and N. Kobayashi, A generic type system for the pi-calculus, Theoretical Computer Science 311 (2004), pp. 121–163.
Kobayashi, N., Type-based analyzer for the pi-calculus, posted on MOCA mailing list (23 of July, 2004).
Vallecillo, A., V. Vasconcelos and A. Ravara, Typing the behavior of objects and component using session types, Electronic Notes in Theoretical Computer Science 68 (2003).
Woo, T. and S. Lam, A semantic model for authentication protocols, in: Proceedings of the IEEE Symposium on Security and Privacy, 1993, pp. 178–194.

A  An Example in Iris
The example in this section (Fig. A.1) models a simplified electronic auction system in Iris. The three main principals of the system are: Auctioneer, Seller and Buyer. In a normal processing cycle Seller contacts Auctioneer informing of the product and initial bidding price desired. Auctioneer then waits to receive biddings from interested buyers. After some fixed amount of time, Auctioneer determines that the bidding process is over and assigns the product to the highest bidder.
Two additional processes participate in the system: SellerManager and BuyerManager. Once Auctioneer has received notification of a seller, including product and price information, she delegates all further interaction with it to the SellerManager process. Thus she becomes free to receive requests from buyers or new sellers. Likewise, once Auctioneer receives notification from a buyer, including product of interest and bid, she delegates all further interac- tion with the buyer to the BuyerManager. Auctioneer thus becomes available for interaction with other buyers and sellers.
In order to keep the example simple we assume that Auctioneer can handle at most one seller at a time and that at least one buyer shall make a bid. For the same reason, we do not take into account error capture and recovery, such as when a bidder attempts to make a bid for an item which has not been placed for selling. In order to begin operating we assume that an initial seller and buyer have been placed, namely dummySeller and dummyBuyer . For this

example we use a version of Iris extended with booleans and if-then-else, such extensions being straightforward to accomodate.
In what follows we describe the full set of principals:
Auctioneer. Auctioneer waits to receive requests for one of three operations:
sell: This is invoked by a seller. It reads the seller’s product and initial base price together with a session name sSELL to be used for further contact with the seller. Since the auctioneer can handle at most one seller, it lets the seller manager know that it must cancel the previous seller – in turn the seller manager shall contact this seller to let her/him know. It also passes on sSELL to the SellerManager. After that, it informs the BuyerManager that a new product and base price is in effect.
bid: This is invoked by a buyer. Auctioneer reads in product, bid and contact information from the buyer. Then it informs the buyer manager BuyerManager that a new bidder has arrived and passes on the bidder and the other data that was input to this manager.
timeout: This operation is invoked when no further bidding time is left and hence the current highest bidder has successfully acquired the item sold. It informs the seller manager SellerManager and the buyer manager BuyerManager of this situation.
SellerManager. The seller manager acts as an accumulator which holds a session name to interact with the current seller that Auctioneer is dealing with. Auctioneer instructs it to do two possible things:
sold: tell the seller that her item has been sold, or
cancel: tell the seller that the auction has been canceled due to the arrival of a new seller and read in the new seller.
BuyerManager. The buyer manager acts as an accumulator which holds a session name to interact with the current buyer that has placed the highest bid. It waits to receive one of the following selections:
newProduct: this is selected by Auctioneer and informs that a new seller has arrived and passes on the product and base price of this product.
newBidder: selected by Auctioneer when a new bidder has arrived. Buyer- Manager reads in the bid and compares it to its current highest bid: if the former is greater than the latter then it informs the current highest bidder (i.e. currBuyer ) that it has been outbidded and recursively calls itself with the new bidder as a parameter; otherwise the new bidder is informed that her bid is too low and BuyerManager recursively calls itself with the current highest bidder as the highest bidder for the call.
bought. selected by Auctioneer to inform the buyer manager that the current highest bidder has successfully acquired the product.

Auctioneer(sAuc, sBM , sSM ) = 
accept sAuc(k) in
k ¢ {sell: k?(prod, basePrice, sSELL) in request sSM (h)in h¢ cancel; h!(sSELL); request sBM (h) in h¢ newProduct;
h!(prod, basePrice); Auctioneer[sAuc, sBM , sSM ],
 bid: k?(prod, bid, sBUY ) in request sBM (h)in h¢ newBidder; h!(prod, bid, sBUY ); Auctioneer[sAuc, sBM , sSM ],
  timeout: request sSM (h)in h¢ sold; request sBM (h) in h¢ bought;
Auctioneer[sAuc, sBM , sSM ] }
SellerManager(sSM , currSeller) = 
accept sSM (h) in
h ¢ {sold: request currSeller (k )in k¢ sold;
SellerManager[sSM , dummySeller ],
  cancel: request currSeller (k )in k¢ cancel; h?(newSeller ) in
SellerManager[sSM , newSeller ] }
BuyerManager(sBM , prod, currBid, currBuyer) = 
accept sBM (h) in
h ¢ {newProduct: h?(prod,baseP rice);
BuyerManager[sBM , prod, basePrice, dummyBuyer],
 newBidder: h?(prod, bid, newBuyer) in if bid > currBid
then request currBuyer (k )in k¢ outBidded;
BuyerManager[sBM , prod, bid, newBuyer]
else request newBuyer (k )in k¢ tooLow;
BuyerManager[sBM , prod, currBid, currBuyer]
  bought: request currBuyer (k )in k¢ bought;
BuyerManager[sBM , dummyProd, 0, dummyBuyer ] }
Seller(sAuc, sSell , prod, price) = request sAuc(k) in k¢ sell; k![prod , price, sSell ];
accept sSell (k ) in k ¢ {sold: stop,
  cancel: stop}
Buyer(sAuc, sBuy, prod, price) = request sAuc(k) in k¢ bid; k![prod , price, sBuy ];
accept sBuy (k ) in k ¢ {outBidded: stop,
bought: stop, tooLow: stop}

Fig. A.1. Full code for the auction example.
Seller. This process defines the behavior of a seller. She requests a session with Auctioneer and lets her know that she is willing to sell a product prod at price price. Also, she lets Auctioneer know how she may be reached for further interaction. She then waits to be informed whether her product was sold or the auction was canceled due to the arrival of some new seller.
Buyer. The buyer requests a session with Auctioneer and selects a bidding operation. She then sends the product she is interested in and the price she is willing to pay. Also, coordinates for further interaction are provided to Auctioneer. She then awaits one of three possible replies:
outBidded: In some later cycle a new bidder has outbidded her.
bought: She has successfully bought the product.
tooLow: Her initial bid was too low and thus rejected.
The full system is depicted as follows

Auctioneer[sAuc, sBM , sSM ]| BuyerManager[sBM , 0 , 0 , dummyBuyer ] |
SellerManager[sSM , dummySeller ] | Buyer[sAuc, sBuy, prod, bid]| Seller[sAuc, sSell , prod, price]
and is well-typed in the pure theory of session types [18] under the following type assumptions:
Γ	=	sAuc : σ(α), sBM : σ(β), sSM : σ(γ),
dummyBuyer : σ(⊕{outBidded : 1, bought : 1, tooLow : 1}),

dummySeller : σ(⊕{sold:1,cancel:1}),
sBuy : σ(&{outBidded : 1, bought : 1, tooLow : 1}),
sSell : σ(&{sold : 1, cancel : 1}),	prod : Int, bid : Int, price : Int
channel types α, β and γ are:
α = &{sell :↓ [Int, Int, σ(&{sold : 1, cancel : 1})]; 1,
bid :↓ [Int, Int, σ(&{outBidded : 1, bought : 1, tooLow : 1})]; 1,
timeout : 1}
β = &{newProduct :↓ [Int, Int]; 1,
where the

newBidder :↓ [Int, Int, σ(⊕{outBidded : 1, bought : 1, tooLow : 1})]; 1,
bought : 1}
γ = &{sold : 1, cancel :↓ [σ(⊕{sold : 1, cancel : 1})]; 1}
Note that the auction example is also typable in the type system introduced in Section 2 if we assume that all effects are empty (||).
We provide an informal explanation of the type assigned to the session name sAuc. This session name is used by Auctioneer. The type σ(α) is a session type and is an abstraction of a pair of dual channel types, namely α and α. One endpoint of the communication is assumed to abide to the interaction pattern specified by α, while the other endpoint is assumed to abide to that specified by its dual. The “&” type constructor indicates that Auctioneer must accept three operations: sell, bid and timeout. If the first of these operations is invoked, then Auctioneer must read in a triple consisting of an integer, another integer and a session name of type σ(&{sold : 1, cancel : 1}). Similar comments apply to the bid operation. In the case of the timeout operation, no further interaction is expected on this channel.
Session types such as those of sAuc, sBM and sSM express how these long term communication abstractions behave independently of each other, even though they all belong to a common specification, namely that of the protocol specifying how Auctioneer, SellerManager, and the other parties should interact in order to carry out a specific operation (such as placing a bid). This fact may be witnessed as follows. Consider replacing the code for the bid operation of Auctioneer by:
Example A.1 [Changing bids]
bid: k?(prod, bid, sBUY ) in
request sBM (h)in h  newBidder;

h!(prod, bid − 10 , sBUY ); Auctioneer[sAuc, sBM , sSM ],
This version of the bid operation places a smaller bid than the one orig- inally communicated to the auctioneer by the bidder. Unfortunately, the resulting electronic auction system is declared typable by the pure theory of session types, under the same typing assumptions as the original system. Other examples of the lack of expressiveness of the pure theory of session types are described in [1].
The type system for Iris detects such badly behaved variants of the honest auctioneer by introducing correspondence assertions and applying the type- checking algorithm described in this article. Indeed, in [1] a notion of safe process is P introduced following [12,11,14,13]. Informally, it states that all end L assertions are corresponded by a begin L assertion, in every possible execution of P . Also, it is shown [1] that all processes which are typable with the empty effect (||) are safe. Example A.1 may thus be addressed by the insertion of appropriate effects and then showing that the resulting code does not typecheck with the empty effect. Briefly, this is achieved by first inserting a begin assertion with label ⟨prod, price, sBuy ⟩ in Buyer just before its data on k is sent. Then, an end assertion with label ⟨prod, bid, newBuyer ⟩ is placed in the newBidder operation of the BuyerManager, just after these names are read in. Finally, we augment the channel types α and β with appropriate effects:
α = &{sell :↓ [Int, Int, σ(&{sold : 1, cancel : 1})]; 1,
bid :↓ [x : Int,y : Int,z : σ(&{outBidded : 1, bought : 1, tooLow : 1})](| ⟨x, y, z⟩ |); 1,
timeout : 1}
β = &{newProduct :↓ [Int, Int]; 1,
newBidder :↓ [x : Int,y : Int,z : σ(⊕{outBidded : 1, bought : 1, tooLow : 1})](| ⟨x, y, z⟩ |); 1,
bought : 1}
