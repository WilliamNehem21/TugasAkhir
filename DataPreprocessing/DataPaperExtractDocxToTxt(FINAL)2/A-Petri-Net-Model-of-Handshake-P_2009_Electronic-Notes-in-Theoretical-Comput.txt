

Electronic Notes in Theoretical Computer Science 229 (2009) 59–76
www.elsevier.com/locate/entcs

A Petri Net Model of Handshake Protocols

Luca Fossati
Dipartimento di Informatica - Univ. di Torino, Italia PPS - CNRS & Univ. Paris Diderot, France

Daniele Varacca
PPS - CNRS & Univ. Paris Diderot, France

Abstract
We propose a Petri net model of handshake protocols. These are asynchronous communication protocols which enforce several properties such as absence of transmission interference and insensitivity from delays of propagation on wires. We introduce the notion of handshake Petri net, a Petri net with a specific external interface. We show that the set of observable quiescent traces generated by such a net captures the properties defining a handshake protocol. Conversely we show that for any handshake protocol we can construct a corresponding net. We also study different subclasses of the model. Many examples are provided.
Keywords: Handshake protocol, Petri nets, asynchronous communications, delay-insensitivity, transmission interference.

Introduction
The asynchronous style of computation is characterized by several subunits acting locally, independently of each other, as opposed to the synchronous style, where a central clock disciplines everything. Working with asynchronous systems, there are a few situations one would like to avoid. One is transmission interference which may occur when two consecutive messages are sent over the same channel, with the risk of clashing into one another [14]. Another one is computation interference, where a message is delivered to an unready receiver [9,16].
One way to rule out such situations is by adopting communication protocols to enforce the desired behavior. For instance, delay-insensitive protocols guaran- tee that a system’s behavior is independent of propagation delays over wires and of computational speeds of single units, thus preventing computation interference. Among those, we focus on the handshake protocol which requires that each message sent is followed by an acknowledge, thus preventing transmission interference.

1571-0661 © 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.06.039

Thanks to its simplicity and efficiency, the handshake protocol has gained the interest of enterprises like Sun and Philips [1]. However, little research has been put forward on foundational aspects. For quite a few years the foundational research on handshake circuits, circuits obeying the handshake protocol, has relied on the model introduced by Kees Van Berkel in his PhD thesis [15]. While Van Berkel’s model will continue to be a reference for many aspects, it contains a serious shortcoming: the process composition it defines is not associative, as proved by the first author [4]. To solve this problem the first author [4] proposed a game semantics for hand- shake circuits which describes their composition correctly for the first time. Tech- nically, the result was accomplished by representing handshake “behaviors” as sums of deterministic handshake strategies. The price to pay is that there are behaviors which do not fit in this representation. The crucial example is the mixer component,
MIX, which will be described in Section 3.3.
This led us to look for other kinds of models. A graphical representation is probably the most natural choice for dealing with asynchronous circuits: in graphs as in circuits, composition is easy when everything else works properly. Several works have taken a similar perspective ([2],[8],... ). In particular Dan Ghica developed a language for asynchronous hardware design by taking inspiration from the Geometry of Interaction and handshake circuits [6]. However his goal was to improve previous hardware design languages [15,3] and not to capture all handshake behaviors.
The model we present in this paper is based on Petri nets [11]. Petri nets are widely used as models of asynchrony, and are close to the context in which the handshake communication protocol originated [12]. However, the properties of delay- insensitivity and absence of transmission interference had not yet been formalized under a graphical representation. We call our model handshake Petri nets. We show that handshake Petri nets capture precisely the handshake protocol, in the sense that the behavior of every net is a handshake language and that every handshake language is the behavior of some net.

Plan of the paper
In Section 2 we define the notion of handshake language as set of traces (taking inspiration from [15] and [4]). In Section 3 we introduce handshake Petri nets and some of their subclasses. We put a special emphasis on deterministic behaviors, as well as on those nondeterministic behaviors which cannot be expressed as sums of deterministic components. Finally, in Section 4 we provide an interpretation of handshake Petri nets into handshake languages and we prove the correctness and completeness of this interpretation. Completeness of deterministic handshake Petri nets with respect to deterministic handshake languages will follow as a corollary.

The Handshake Protocol
In this section we characterize the handshake protocol in terms of languages obeying its communication discipline. We do not exactly give another trace model as, for instance, we do not define composition. We just need a yardstick against which to

measure the correctness of our model. Moreover, we are only interested in the com- munication discipline, so we assume circuits have nonput ports (no data is exchanged in a communication). We leave the more general case for further work.
Definition 2.1 A handshake structure is a pair ⟨P, d⟩, where P is a finite set of ports and the function d : P → {act, pas} determines a direction for each port, active or passive.
As we shall see, active ports are allowed to start a communication, while passive ports are initially waiting.
For the rest of this section let ⟨P, d⟩ be a handshake structure and let ∪p∈P {p, p¯} be the alphabet of messages on ⟨P, d⟩. In particular, p and p¯ are both messages on some port p 1 . Two messages are independent when they are not on the same port. The function λP is defined on ∪p∈P {p, p¯} so that λP (p) = − (input message) and λP (p¯)= + (output message), for all p ∈ P . We may write λ instead of λP when P is redundant or clear from the context.
Let t be a trace on the alphabet of messages ∪p∈P {p, p¯}. t is a handshake trace
on ⟨P, d⟩ if for all p ∈ P :
t T{p, p¯} = p¯pp¯p ... when d(p)= act;
t T{p, p¯} = pp¯pp¯... when d(p)= pas;
We call thread each such restriction and we call request (acknowledge) the message appearing in the odd (even) positions in each thread of p.
Threads induce an equivalence on traces, the homotopy relation ∼P . Given two handshake traces s and t, we say that s ∼P t when they have the same set of threads. As usual, we denote by [s]∼ the equivalence class of trace s with respect to ∼, we call [s]∼ the position of s.
Given a set of traces σ we write σ≤ for its prefix-closure. Let σ be a set of handshake traces, s ∈ σ≤ is passive in σ if and only if there is no message σ can output after s:
∀s · m ∈ σ≤, λ(m)= −.
We write Pas(σ) for the set of passive traces in σ≤.
We define rP as the smallest binary relation which is closed by reflexivity, tran- sitivity and concatenation, and such that for any distinct ports p, q ∈ P :
pq¯ rP q¯p;
p¯¯q rP q¯¯;p
pq rP qp
We say that s reorders t in P if s rP t. Note that the relation rP is not symmetric.
Let s be a handshake trace and p ∈ P . We write p xP s if sp is still a handshake trace. We are now ready for the definition of handshake language.

1 One may object that the same name p is used for both the message and the port. However the context will always make clear which p we are referring to.

Definition 2.2 A (handshake) language σ on ⟨P, d⟩ is a non-empty set of finite handshake traces on ⟨P, d⟩ such that:
Pas(σ) ⊆ σ (closed under passive prefixes);
(t ∈ σ ∧ s rP t) ⇒ s ∈ σ (reorder closed);
(s ∈ σ≤ ∧ p xP s) ⇒ s · p ∈ σ≤ (receptive).
Note that the traces of a handshake language are finite, but the language itself may contain an infinite number of traces.
Definition 2.3 Let σ be a handshake language. We say that σ is positional if, for finite s, s' ∈ σ≤, with s ∼P s', we have:
(i) s · t ∈ σ≤ ⇒ s' · t ∈ σ≤;
(ii) s ∈ σ ⇒ s' ∈ σ;
We say that σ is deterministic if for any distinct p, q ∈ P :
s · p¯ ∈ σ≤ ⇒ s ∈/ σ (progress);
s · p¯ ∈ σ≤ ∧ s · q¯ ∈ σ≤ ⇒ s · p¯ · q¯ ∈ σ≤ (absence of conflict).
Positionality means that the only thing relevant in a choice is the position we are at and not the way we reached it. As for determinism: when a deterministic language σ is able to produce an output, waiting is not an option; when there is a choice of two outputs, one choice must not exclude the other. It is not difficult to prove the following fact.
Proposition 2.4 A deterministic language is positional.

Examples
Consider the handshake structures P = ⟨{p}, {p '→ pas}⟩ and A = ⟨{p}, {p '→ act}⟩, corresponding respectively to a passive and to an active port. Then, pp¯pp¯pp¯ is a handshake trace on P but not on A. The set
{pp¯, pp¯pp¯, pp¯pp¯pp¯,.. .}
is not closed under passive prefixes as it does not contain the empty string, then it is not a handshake language. Whereas both sets
RUNp = {p¯, p¯pp¯, p¯pp¯pp¯,.. .}	and	{ε, p¯, p¯pp¯, p¯pp¯pp¯,.. .}
are handshake languages on A. In particular RUNp is deterministic, the other is not. The set
{p¯, p¯pp¯, p¯pp¯pp¯}
is not a handshake language on A, because it is not receptive: after the last trace the environment is still supposed to send an acknowledge, but the language is not ready to receive it. Even the receptive RUNp becomes not receptive if we extend

its structure with a passive port, as in B = ⟨{p, q}, {p '→ act, q '→ pas}⟩. A process which is receptive with respect to B is the following:
REPp,q = {ε, qp¯, qp¯pp¯, qp¯pp¯pp¯,.. .}
this process is also called repeater since, after reception of a request on its passive port it “handshakes” indefinitely on the active. Now look at the following sets on B:
{ε, qq¯p¯, qq¯p¯q, qq¯p¯qp}
{ε, qq¯p¯, qp¯q¯, qq¯p¯q, qp¯q¯q, qq¯p¯p, qp¯q¯p, qq¯p¯qp, qq¯p¯pq, qp¯q¯pq, qp¯q¯qp}
Neither of them is reorder-closed, then neither of them is a handshake language. For example, qq¯qp¯ r qq¯p¯q but qq¯p¯q is in the prefix-closure of both of the above sets, while qq¯qp¯ is in the prefix-closure of none. We leave it to the reader to figure out the reorder-closures of the above two sets and to show that the second’s is a handshake language while the first’s is not.
Finally, consider yet another set on B:
{ε, qp¯, qq¯, qp¯pq¯, qq¯qp¯, qp¯pq¯q, qq¯qp¯pp¯, qq¯qp¯pp¯p}
The reader can verify that it satisfies all the properties of a handshake language, we show that it does not satisfy those of positionality. Note that qp¯pq¯q and qq¯qp¯p are two traces with the same position and that both are in the prefix-closure of the above set. However, while the first is actually an element of the set, the second is not and, conversely, while the second can be extended with p¯, the first cannot. The language is not deterministic either since after the initial q there is a mutually exclusive choice between p¯ and q¯.

Handshake Petri Nets
We assume some basic knowledge on Petri Nets, which we will use in their standard graphical representation [11]. Throughout the paper we will consider Petri nets in their unsafe version, where places are allowed to contain several tokens at the same time. This is not just for convenience. Unsafe nets are necessary to carry out our construction. We also stress that the nets we consider are in general not finite, in the sense that they may have infinitely many places and/or transitions.
Handshake Petri nets are characterized by a special “external interface” which reflects the structure of handshake ports. Let I and O be disjoint finite subsets of the set of transitions of a Petri net G. We call the triple ⟨G, I, O⟩ an interacting Petri net (ipn), where the transitions in I are its input transitions and those in O are its output transitions. A transition is external if it is an input or an output transition, internal otherwise.

An ipn ⟨G, I, O⟩ t-reduces to ⟨G',I, O⟩,
t	'	, when the tran-

⟨G, I, O⟩ −→ ⟨G ,I, O⟩
sition t can fire in G and the result of the firing is G'. We call execution of ⟨G, I, O⟩
any sequence of transition firings starting from ⟨G, I, O⟩.

Definition 3.1 An ipn ⟨G, I, O⟩ is a handshake Petri net (hpn) when:
I and O have the same cardinality;
input (output) transitions have exactly one incoming (outgoing) arc;
each input transition is paired with an output transition by means of the following structure:
,,,,,, ¸
  ,¸,¸¸ .

,r¸~ ~c, c
.
,r¸~ ~, z¸z 

,, ¸ c,  c 
¸¸¸¸.¸
where the input transition is denoted by two parallel bars and the output transition by one thick bar. Such a structure represents a port ;
at any time, each port contains exactly one token. In particular, when the to- ken enables the input transition the port is passive, when it enables the output transition it is active.
Two hpns may be composed by linking a set of ports of the first net with a set of ports of the second net. Each “link” must be between a passive and an active port and is done by adding two new places (and four new arcs) between them, as follows:


¸¸¸¸¸¸z˛
,,,,,, ¸
¸¸¸¸¸¸
,,,,, ¸

.	¸    ¸	.
.	z˛¸ r,~¸~ ,  ¸,  .

. ...c ,,,	c ,,,¸¸¸.
.....c¸,,,	c¸,,,¸¸¸.

...,r¸~ ~c, 	,r¸~z ~,  z ,r¸~ ~c, 	,r¸~z ~,  z¸¸z 
.. ,r¸~ ~c,	r,~¸z~ , z r,~¸~ c ,	,r¸~z ~, z¸¸z 

,¸¸¸•¸,,, ¸	•,,, ¸	..	⇒
,¸¸¸•¸,¸,	•,,¸	..

¸¸¸  c  c
 c.. . c
¸¸¸,
 c rc	,  c..r. c

.	,	¸, ¸,
. ¸¸s¸.
. ,,
¸,r,~¸~ ,¸, ¸¸s¸..

.
 ,  ,
¸¸¸¸.¸
.
 ,s,
¸¸¸¸.¸

On the left we represent the two ports before the link is done, where the new arcs and places are not there yet: we draw them dashed to indicate this. On the right we represent the situation after the link, note that we use a different graphical notation for the ports’ transitions as, after composition, they become internal. In fact, the new net will have as external transitions all and only those external transitions of the two original nets that have not been linked during the composition, and each of these inherited external transition will keep its status: inputs will stay inputs and outputs will stay outputs. It is easy to see that the composition of two hpns is still an hpn, moreover composition of hpns is trivially associative.
In the rest of this section we will show several examples of standard handshake components represented as handshake Petri nets. We will present each example within a specific subclass of the general model.

Handshake Marked Graphs
In the first stage we focus on marked graphs [10], which are Petri nets where each place has at most one incoming and at most one outgoing arc.

Marked graphs are significant as they allow to identify places with communi- cation channels and in turn to represent all and only circuits which can be built out of channel, synchronization and fork operations. Moreover they have a special historical importance for the handshake protocol [13]. We call handshake marked graph a handshake Petri net which is also a marked graph.

Examples
Marked graphs represent the core of determinism. In particular they allow the representation of most deterministic handshake components: STOP , RUN , CON , SEQ, P AR, P AS, JOIN (in the notation of [15]). Two of these components are represented below 2 .


er,~¸ ~ , ,

 ,,
e,r¸~ ~, ,

 ,,

eee	,r¸~• ~e, e
,zz
eee	r,~¸•~ e ,e
,zz

eee

r, ~¸~ , , 
,,¸ r,~¸~ ,
  je
eee
,,¸ ,r¸~ ~, 
  je

e ,,,
,, ee
e ,,,	e

,r¸~• ~e, 	,r¸~z ~,  z
,e,
,r¸~• ~e, 	r,~¸z~  , z   r,~¸~   ,   je

,, ¸e,e
,
, ¸,
eee ,,zz
e ,,,
,¸,
  je
,, ¸,
,,zz
e ,,,

,,,
,r¸~• ~e, 	r,~¸z~  , z
,,,,
r,~¸•~ e ,	,r¸~z ~, z

,,r,~¸~ ,
,, ¸e,e

,,r¸~ ~, 
,, ¸e,e



P AR (left) waits for a request on its passive port and then starts two handshakes in parallel on its active ports. Only after successful termination of both it acknowledges to the first request. SEQ (right) also waits for a request on its passive component, but then it starts its active ports in sequence, before finally acknowledging to the initial request.
The examples show that handshake marked graphs (or marked graphs in general) always react in the same way to a given stimulus. For example, SEQ always sends a request on its first active port after the reception of a request on its passive port. It can be shown that handshake marked graphs embed a particular subclass of handshake languages where each pair stimulus/response can be seen as a couple of brackets in the language and each trace becomes well-bracketed with respect to any of these couples, after a fixed number of closing brackets.

Deterministic Extensions
Marked graphs express only deterministic behaviors but not all deterministic behav- iors are captured by marked graphs. As far as we know, no structural characteriza- tion of determinism in Petri nets exists in the literature. We propose a definition that completely characterizes determinism in the context of handshake nets.

2 Although handshake Petri nets are formalized here for the first time, a similar representation for both components had already been given as far back as [12]. Actually, those pictures were an inspiration for this work.

Definition 3.2 A handshake deterministic-branching net (a handshake DB net, or just a DB net, for short) is a handshake Petri net in which every place p with several outgoing arcs is such that:
Each post-transition t of p has a “guard”, a place whose only post-transition is t;
Exactly one of the guards of p’s post-transitions initially contains a token, so that at most one post-transition may initially be enabled;
Each of p’s post-transitions has exactly one outgoing arc to some guard of a post- transition of p, so that each time one post-transition has fired one post-transition may be enabled;
Each guard of a post-transition of p may have incoming arcs only from p’s post- transitions, so that no more than one post-transition may ever be enabled.

Examples
As an example, consider COUNTN which, after reception of a request on its passive port, handshakes N times on its active port. Then it acknowledges to the first request and returns to wait for an activation. In this case, the circuit needs to decide (deterministically, of course) when to acknowledge to a passive request (after N handshakes on the active port). Here is the circuit COUNT2, also known as DUP :

,,,,,r!¸~ ~, ¸	   ¸ ¸

,,,,,,,,
¸¸¸¸¸
,r ¸~ ~, 		r, z~¸~ , 

  ¸

,¸¸¸¸¸	,¸ ¸¸¸

,r¸~• ~,  ¸
¸¸,rz¸~ ~,   	,r¸~ ~, ¸,    ¸¸¸,¸,r¸~¸~  , ,	,r¸~• ~,       ¸	¸¸r,z~¸~  ,  

,¸
¸¸¸¸
   
, 
,J,,
¸¸ 
	¸¸¸¸
,¸
¸¸¸¸

¸$s 
, ,
¸,r¸~ ~, ¸,  
,s 

,,,,,,,,,,,,
,J ¸,(,r,~¸•~ ,

A DB structure allows us to select each firing of a given transition and associate it to a brand new dedicated transition, as shown below:


,r¸~• ~,, ,
 ¸,
¸ ,r¸~• ~, 
¸¸¸zz z

.	.	,

J˜	(,,( ¸¸¸z*
	,,,\ `\J,

   ,r ¸~ ~, ¸ ¸ ,r¸~ ~,, 
, ¸,
 ¸¸¸,r¸~ ~,, ((,,r¸~ , ~, ,,   

¸¸¸ ,,
¸¸ ,,	eee

¸¸zt z  .	.	¸¸zte z
,\¸¸¸.	.	,\,

,¸	,¸,,.,
¸¸¸z0
   ,¸,,.c,  ,

 	  
We call the above input (left) and output (right) occurrence selecters.

General nets
In this subsection we present two examples of nondeterministic nets, the OR (below left) and the MIX (below right) handshake components:

 r, ~¸~ ,  

ııı,.
,
r,~¸•~ c ,c ,,,r¸~z ~, z
,
r,~¸•~ c ,c ,,,r¸~z ~, z

	,r ¸~ ~ıı, 
,¸,
   c
,¸,
  r,~¸c~ J , , 

ı¸,,,,
,,,tz	ı
,,  ¸, ı¸,,,,

,r¸~• ~ı, ı ¸r,¸~t ~, z
  r, ~¸~ , ııı 
 , ¸,
,,,
,r¸~• ~ı, ı ¸r,¸~t ~, z

,,	4ıı 4ı
ııı ıı¸,,,,
ıı¸,,,, ,,
,,	4ıı 4ı

¸,	r,~¸~ ı4 , r,~¸•4~ ı ,
,r¸~t ~, z
r,~¸•~ ı ,
,r¸~t ~, zr,~¸~ ,¸,

,¸,,,, ¸ı 4ı	,,,, ¸ı 4ı
¸,

OR has a passive and two active ports. When a request on the passive port arrives a request on either active port is sent. Acknowledge to this last request enables an acknowledge to the first one. As the picture shows, this example can be modeled by a free choice net (transitions with a shared precondition do not have any preconditions other than that).
Conversely, MIX has two passive and one active port. Each time an environment request arrives (on either passive port) MIX handshakes on its active port and after completion it acknowledges to the first request. If by the time the handshake on the active port completes the environment had sent a request on the other port, MIX chooses nondeterministically which request to acknowledge first.
This situation could not be described with a free-choice net since the choice of which request to acknowledge may not be a choice at all if the environment only sent one request.

Soundness and Completeness
Consider an hpn H = ⟨G, I, O⟩, name its ports and let PH be the set of these names. Now take dH : PH → {act, pas}, the function which maps each port name p to the appropriate label, act if port p is active in H, pas if it is passive. This allows us to define the handshake structure HS(H)= ⟨PH , dH ⟩.
Then for any port p, name p (p¯) its input (output) transition, and name τ any internal transition. An execution t of H is quiescent when for no p ∈ PH it can be
t  (τ )∗ p¯
extended as H −→−→−→. We define HL(H) as the set of strings consisting of the
external restriction of each quiescent execution of H.
The main results of this paper, the soundness and completeness of the Petri nets model, can be respectively formalized by the following theorems.
Theorem 4.1 Let H be a handshake Petri net, then HL(H) is a handshake lan- guage on the handshake structure HS(H).

Theorem 4.2 Let σ be a handshake language on a handshake structure ⟨P, d⟩. Then there is an hpn Hσ such that HS(Hσ)= ⟨P, d⟩ and HL(Hσ)= σ.
The proof of soundness is a rather straightforward verification of the properties defining a handshake language. In the remaining of this section, we try to hint the proof of completeness (theorem 4.2). We must warn that the construction of Hσ we propose may lead to an infinite net, but let us also point out that an infinite representation is in general unavoidable. An example of language with no finite representation is the one which contains an infinite chain of (finite) traces where outputs are chosen according to a non recursive function.
Let us focus first on positional handshake languages. These languages make their choices according to the reached position, regardless of the particular interleaving followed in the execution. In the following we write pi (q¯i) for the ith occurrence of input p (output q¯). Then we can represent a choice as a pair made of a position [s]∼ and an output occurrence or a special symbol ∗, where ⟨[s]∼, q¯i⟩ expresses the choice of “playing” q¯i at [s]∼ and ⟨[s]∼, ∗⟩ the choice of doing nothing at [s]∼.
Let σ be a handshake language and c a choice in σ. Let t ∈ σ≤, we say that t
allows c in σ (t →σ c) when [t]∼ = fst(c) and:
t ∈ σ if snd(c)= ∗;
t · snd(c) ∈ σ≤ otherwise.
We say that t prevents c in σ (t ~σ c) when it does not allow it.
If we consider positional strategies we see immediately that positions, rather than traces, allow choices. Moreover, since we only consider data-less communications and since outputs do not affect choices (by reordering), a position can be represented by a set of occurrences of distinct input messages, taking the last input occurrence of each thread.
Starting from the above observations and systematically using the selecter struc- tures introduced in Section 3.2 to select occurrences of input and output messages we are able to construct a handshake Petri net which corresponds to the given positional handshake language.
Proposition 4.3 Let σ be a positional handshake language on ⟨P, d⟩. Then there is an hpn Hσ such that HS(Hσ)= ⟨P, d⟩ and HL(Hσ)= σ.
Since the construction associates single occurrences to transitions and since a move may occur infinitely many times, the constructed graph Hσ is in general infi- nite.
In the non-positional case, reshuﬄing the threads of a trace may affect a choice. We first define an atomic reshufling of a trace t(= t' · m · n · t'') as a trace of the form t' · n · m · t'', for m and n independent messages.
Definition 4.4 Let S be a set of pairs of the form ⟨pi, q¯j⟩. S is critical for a choice
c in a handshake language σ just when, for all t ∈ σ≤ such that [t]∼ = fst(c),
∀⟨pi, q¯j⟩ ∈ S, t = t' · q¯j · t'' · pi · t''' ⇒ t ~σ c.

We write critσ(c) for the set of minimal critical sets for c in σ.
A similar notion is that of critical pair (the above being critical set of pairs) for c in σ: a pair ⟨pi, q¯j⟩ for which there is s ∈ σ such that s = s' · q¯j · pi · s'' ~σ c while s' · pi · q¯j · s'' →σ c. If ⟨pi, q¯j⟩ is a critical pair for c in σ, we say that it is inverted in t if and only if t = t' · q¯j · t'' · pi · t'''.
Lemma 4.5 Let c be a choice in a handshake language σ. Let t ∈ σ≤, [t]∼ = fst(c): t ~σ c ⇐⇒ ∃S ∈ critσ(c), ∀⟨pi, q¯j⟩ ∈ S, t = t' · q¯j · t'' · pi · t'''
Proof (Sketch) The direction right-to-left is almost immediate. For the other direction, S is made of all the critical pairs which are inverted in t. Then we can take any trace s with the same threads as t and in which all the pairs of S are inverted and prove that s ~σ c by induction on the number of atomic reshuﬄing needed to change s into t. Note in particular that if an atomic reshuﬄing affects a choice, then it must consist of a critical pair which is inverted, as all the others are reorderings. So S is critical, if it is not minimal we can take the minimal critical set contained in S and we are done.	□
The construction of the net is a modification of the one for positional handshake languages, as we briefly sketch here. For any minimal critical set S for c in σ and for all ⟨pi, q¯j⟩ ∈ S we connect transitions pi, q¯j and c as follows:



 pi   ,r ¸~ ~, ¸ 
\
zJ¸* ,,

¸¸¸¸¸¸zJ˛,

.  ,r ¸~ ~, ¸
  c  

.
  

Suppose that the jth firing of q¯ occurs before the ith firing of p, and similarly for all the other pairs in S (represented in the picture by the other incoming arcs in the precondition of transition c). Then c is clearly prevented. Note that this scheme works for both a choice to output and a choice not to, as each choice corresponds to a transition in the graph.
The completeness theorem, specializes to several classes of nets and languages.
For instance to the deterministic case.
Theorem 4.6 Let H be a handshake DB net, then HL(H) is a deterministic hand- shake language on the handshake structure HS(H). Conversely, if σ is a determin- istic handshake language on ⟨P, d⟩, there is a DB net Hσ such that HS(Hσ)= ⟨P, d⟩ and HL(Hσ)= σ.
As we mentioned, marked graphs correspond to a particular class of languages too, the well-bracketed ones. In this case there is even a construction yielding finite

graphs. We still do not know any independent characterization of the nets that correspond to positional languages.


Conclusions
In this paper we presented a version of Petri nets, featuring a particular structure on external connections, that models the handshake protocol of communication. We showed that this model embeds the model of handshake games and strategies [4], but is more expressive.
Graphical representations as Petri nets are very close to the reality of circuits and are useful in explaining the circuits’ dynamics. Compared to trace models like games and strategies they go one level deeper: channels are unidirectional (as it usually happens in circuits) and bidirectionality can be obtained by pairing.
This higher level of intensionality brings us to reconsider the model of handshake Petri nets, which can be seen not only as a semantic model for handshake circuits, but also as their syntax. Carrying on this track we could attempt to provide a normal form for handshake Petri nets since, as we have seen, two different nets may have the same behavior.
Also, the graphical representation may drive the definition of a more standard notion of syntax in the form of a process calculus. Van Berkel already proposed the handshake process calculus [15] (see also [7]). However their goal was not to cap- ture all possible handshake behaviors and a complete process calculus of handshake circuits is still wanted.
In a recent proposal [5] we define what we call the calculus of handshake config- urations and we show that it is complete with respect to handshake languages as defined in Definition 2.2.
Further directions include a deeper analysis of data-exchange, as in this paper we focused especially on data-less communications. It would also be interesting to exploit those subclasses which allow finite representations of a given subset of handshake languages, as we tried to hint in Section 3.1.
Note finally that in recent times the foundational research on the field is starting to awake again: besides [4], other efforts have been made to apply game semantics to the synthesis of HDLs for handshake circuits [6]. This strengthens our belief on the importance of the communication protocol inside the universe of asynchrony, the idea that the current model is just the core of a larger representation.

Acknowledgments
The first author would like to thank Simona Ronchi della Rocca, Felice Cardone, Pierre-Louis Curien for interesting discussions and for their support. Thanks to Gianfranco Balbo, Marco Beccuti, Gianfranco Ciardo and Lucia Pomello for their advice on Petri nets.

References
http://www.handshakesolutions.com/.
S. Abramsky, S. Gay, and R. Nagarajan. Interaction categories and the foundations of types concurrent programming. In M. Broy, editor, Proceedings of the 1994 Marktoberdorf Summer School on Deductive Program Design, pages 35–113. Springer-Verlag, 1996.
A. Bardsley. Balsa: an Asynchronous Circuit Synthesis System. master’s thesis. Department of Computer Science, University of Manchester, 1998.
L. Fossati. Handshake games. In I. Mackie, editor, Proceedings of DCM’06, volume 171-3, pages 21–41. ENTCS, Elsevier, 2007.
L. Fossati and D. Varacca. A Calculus for Handshake Protocols. submitted for publication, 2008.
Dan R. Ghica. Geometry of Synthesis: a Structured Approach to VLSI Design. In Proceedings of the 34th POPL. ACM Press, 2007.
M.B. Josephs, J.T. Udding, and Y. Yantchev. Handshake algebra. Technical Report SBU-CISM-93-1, School of Computing, Information Systems and Mathematics, South Bank University, London, 1993.
Ian Mackie. The geometry of interaction machine. In Proceedings of the 22nd POPL, pages 198–208. ACM Press, 1995.
C.E. Molnar, T.-P. Fang, and F.U. Rosenberg. Synthesis of delay-insensitive modules. Proc. of 1985 Chapel Hill Conference on Very Large Scale Integration, pp 67–86. Computer Science Press, 1985.
James Lyle Peterson. Petri Net Theory and the Modeling of Systems. Prentice Hall PTR, 1981.
Wolfgang Reisig. Petri Nets: An Introduction, volume 4 of Monographs in Theoretical Computer Science. An EATCS Series. Springer Verlag, 1985.
The Computation Structures Group. Progress report 1969-70. Technical Report MIT-MAC-memo-53, Massachussets Institute of Technology, January 1972.
The Computation Structures Group. Progress report 1970-71. Technical Report MIT-MAC-memo-64, Massachussets Institute of Technology, January 1972.
J.T. Udding. Classiﬁcation and Composition of Delay-Insensitive Circuits. PhD thesis, Department of Math. and C.S., Eindhoven University of Technology, 1984.
K. Van Berkel. Handshake circuits: an Asynchronous architecture for VLSI design, volume 5 of
Cambridge International Series on Parallel Computation. Cambridge University Press, 1993.
T. Verhoeff. Characterizations of Delay-Insensitive Communication Protocols. Computing Science Notes ’89/6, Department of Math. and C. S., Eindhoven University of Technology, May 1989.

A  Appendix
We state two definitions which will be useful in the proofs which follow.
Definition A.1 Let s and t be two handshake traces on a given handshake struc- ture, such that s ∼ t. We define d∼ (s, t), the homotopy distance between s and t as follows:
d∼ (s, t)=0 ⇐⇒ s = t
d∼ (s, t) = 1 ⇐⇒ (s = s' · m · n · s'') ∧ (t = s' · n · m · s''), for two messages m
and n;
In general d∼ (s, t)= k > 0 if and only if s /= t and there is a sequence of k +1 (and no less) traces s0, s1,... sk such that s = s0, sk = t and for all 0 ≤ i < k, d∼ (si, si+1)= 1.
The second definition is less significant, but still useful. Let H be an hpn and t and t' two distinct external transitions of H. We call t' the complement of t, and viceversa, when t and t' belong to the same port.
Proof of Proposition 2.4 Let σ be a deterministic handshake language and let s, t ∈ σ≤, such that s ∼ t. Suppose that s · s¯ ∈ σ≤. We show that t · s¯ ∈ σ≤ by induction on d = d∼(s, t):
d = 0. s = t, then t · s¯ ∈ σ≤;
d = l + 1. There is a sequence s = t0,... tl+1 = t such that d∼(ti, ti+1)= 1 and ti · s¯ ∈ σ≤, ∀0 ≤ i ≤ l. Let tl = t' · m · n · t'' and tl+1 = t' · n · m · t''. If m is an output or n an input, tl+1 · s¯ r tl · s¯, which implies tl+1 · s¯ ∈ σ≤. Let m be an input and n an output, then we prove tl+1 · s¯ ∈ σ≤ by induction on the length of s¯.
· s¯ = ε. Then tl+1 · ε = tl+1 ∈ σ≤ by hypothesis;
· s¯ = s¯'a. tl+1 · s¯' ∈ σ≤ by hypothesis. If a is an input, tl+1 · s¯' · a ∈ σ≤ by receptivity. Then let a be an output and let a1,... ak be all the outputs that σ can send at tl+1 · s¯'. Then determinism implies tl+1 · s¯' · a1 ... ak ∈ σ≤. Note also that if an output was possible at tl+1 · s¯' · a1 ... ak, it would also be possible at tl+1 · s¯', by reordering. Then tl+1 · s¯' · a1 ... ak is passive in σ. Then also tl · s¯' · a1 ... ak ∈ σ, as it reorders tl+1 · s¯' · a1 ... ak. Then a ∈ {a1,... ak}, as a is an output and tl · s¯' · a ∈ σ≤. Then tl+1 · s¯' · a ∈ σ≤.
The proof that s ∈ σ ⇒ t ∈ σ is even simpler, as the outer induction alone will do.□

Proof of Theorem 4.1 We proceed by successive steps:
HL(H) is a set of finite handshake traces on HS(H). The structure of handshake ports implies that all observable threads alternate inputs and outputs, starting with an input on passive ports and with an output on active ports. Moreover, executions are finite sequences of firings, then their external restrictions are also finite.

HL(H) is non-empty. By definition an execution is a sequence of firings, then the empty sequence is also an execution and its external restriction is an external trace. If the empty sequence is not quiescent in H it is the prefix of a quiescent execution (as we will show in the next point).
HL(H) is closed with respect to passive prefixes. HL(H) is the set of external traces of all the quiescent executions of H. By contradiction, suppose there is s ∈ Pas(HL(H)) which does not come from a quiescent execution of H. Then there is an extension of this execution which, after a sequence of internal firings, lets an output transition o¯ fire. If this is still not quiescent we can do the same thing over again. Note however that H only contains a finite number of external ports and could not continue to output indefinitely, eventually it shall stop and wait for an input, thus reaching a quiescent execution. Then s · o¯ ∈ HL(H)≤ and s is not passive (contradiction).
HL(H) is reorder-closed. Reorder-closedness comes as a consequence of the fact that no output transition may block any other transition but its complement and no input transition may block another input transition. (We say that t blocks t' in H just when H contains a path from t to t', where each place has at most one incoming arc.)
HL(H) is receptive. Handshake DB nets are unsafe, that means that places may contain an unlimited number of tokens. So, every time an input transition is enabled to fire it can. Note also that the enabling of an input transition depends only on the alternation with its complement output transition. Then HL(H) is receptive.
□


Proof of Proposition 4.3 We set up Hσ’s external structure by providing both an input and an output transition for each port p ∈ P and by pairing them together by means of a port structure, as showed in definition 3.1. In particular, the choice of an active or of a passive port structure is taken according to the label d(p). Then we can already state HS(Hσ) = ⟨P, d⟩. Note also that we have a specific external transition for each message in the alphabet.
Now the internal structure. The occurrence selecters defined in Section 3.2 allow us to associate a new (internal) transition to each occurrence of message: we use specific selecters for inputs as for outputs. The next step is to associate a transition to each position. Recall that a position can be represented as a set containing the last input occurrence of each thread. Then we take a new transition and we link each transition associated to any of these input occurrences into it: the link is a direct arc-place-arc one. We also add a transition for each choice c allowed at a given position [s]∼. In particular, if c does not stand for the choice to do nothing, we link [s]∼’s transition to c’s transition, again by a direct arc-place-arc link. Note however that c might be in mutual exclusion with another choice c' at [s]∼, then we need a shared precondition before the corresponding transitions. But the choice of which one to fire should be made once and for all, then this same precondition should be

used in any position where the two choices are allowed and mutually exclusive(we draw several outgoing arcs from each choice to mean this):


,,
,r¸~ ~, 
,,
     

.	...	.

sss
.
,r¸~ ~, 
,	.
	 , 

sss eeee
,	(((((c

,,	sss eee
     ,r ¸~ ~, ( 

,,, sseee
eee ,

. zezr,~¸•~ e ,

. e p ,,,,
,,,

eeee
,,,,,, ,z z 

,,, ,,	,, ,r ¸~ ~, ¸ ¸
,, ,,,z\ ,,,	¸¸¸¸c'

,,,	z
,,,
,,,
,t\
J,
,	z  < 
\	.
.
   J,

A special treatment is reserved for the do-nothing choice. In this case we add a transition with no outgoing arcs and put it in mutual exclusion directly with p’s transition:

...c  ,
cc,r¸~ ~, ,
     

r,~¸•~ ,..
¸
ccc
cc

z ,>, 	.	.
J p ,,,
..	,,,
 ,	,
,r¸~z ~,  z	    
When the choice to do nothing is taken, Hσ has to wait for another input (thus moving to a new position) before doing anything else.
Let us now move to the output side, where each output occurrence p¯i might be enabled in several positions. Then we make the arcs coming from the choice of p¯i at each of these positions converge into a unique place, which will have an outgoing arc towards p¯i’s transition. One might object that so doing the same output occurrence might fire twice. But this is prevented by the selecter structure (Section 3.2) which ensures that each transition associated to an occurrence of p¯ may fire at most once.
The construction is finally complete, now we prove by induction that s ∈ σ≤ if and only if s ∈ HL(Hσ)≤.
s = ε. Trivial since both σ and HL(Hσ) are handshake languages.
s = s' · a. Let a be an input. Both σ and HL(Hσ) are handshake languages on the same handshake structure ⟨P, d⟩. Then any direction we look, s'a must

be a handshake trace on ⟨P, d⟩. Since s' is a prefix of both languages, s'a is too (receptivity). Now let a be the ith occurrence of output p¯. sp¯ ∈ σ≤ means that p¯i is allowed by the position [s]∼ in σ and that no mutually exclusive choice has been chosen yet. Then in Hσ, [s]∼’s transition enables the transition associated to the choice of p¯i at [s]∼. Plus, if ever there was a shared precondition among the choice of p¯i and another choice at [s]∼, we may assume that it still contains a mark since the other choice has not produced any effect so far. Then p¯i’s transition may fire because it has not yet fired and because all the transitions associated to previous occurrences of p¯ have already fired in s. Then sp¯ ∈ HL(Hσ)≤. On the other hand, sp¯ ∈ HL(Hσ)≤ implies that the transition associated to the choice of p¯i at position [s]∼ is enabled by the transition associated to [s]∼ in Hσ. Then [s]∼ allows p¯i in σ, by definition of Hσ. Moreover, if there was another choice excluding p¯i at [s]∼ in σ, this was not chosen inside s. Then sp¯ ∈ σ≤.
Now, s is passive in σ if and only if the transition [s]∼ does not have any outgoing arcs in Hσ, that is if and only if s is passive in HL(Hσ). s is a non-passive trace in σ if and only if the transition [s]∼ has a shared precondition with a transition which has no outgoing arcs in Hσ, that is if and only if s is a non-passive trace in HL(Hσ).	□

Proof of Theorem 4.6 The proof of the completeness part of the theorem is a simplification of the proof of Proposition 4.3 3 . As for the the soundness part, the only properties left to prove are determinism’s two, given that we already proved the preliminary properties for Theorem 4.1. For both of them, the proof is based on the following simple observation. In a DB net, even if a place may have several outgoing arcs, only one of its post-transitions is actually enabled at any given time: each one has a guard and only one guard contains a mark in the initial state; successively, the firing of the enabled post-transition takes away a mark from its guard and puts it into another guard. This prevents any situation of confusion, so that once a transition is enabled it will stay enabled until it fires.
Also, given two executions ex' and ex'', we can define an execution ex which completes ex' with those firings which occur in ex'' and not in ex' itself. We show how to do this by providing a constructive algorithm which gradually deletes the two original strings ex' and ex'' while writing ex. We initially set ex to the empty string. If at a given time ex'' = a · u'' and ex' = u' · a · v', where a does not appear in u', we append a to ex while removing it from the two original strings. So that ex' becomes u'v' and ex'' becomes u''. If a does not appear in ex' we remove it from ex'' and we append it at the end of ex'. If ex'' = ε, we append what is left of ex' at the end of ex. Eventually, ex will consist of all the firings of ex' (possibly in a different order) followed by the firings of ex'' that were not there in ex'. About the order of the firings, note that if ex' and ex'' had the same external trace, ex would still have that external trace.
Now, let sp¯ ∈ HL(H)≤. Recall that sp¯ is the prefix of an external trace of a

3 Recall also that all deterministic handshake languages are positional (Prop. 2.4).

quiescent execution of H. Then sp¯ is also the external trace of a prefix of a quiescent execution, then the external trace of an execution of H. For the first property we need to prove that there is no quiescent execution of H whose external trace is s. Since s · p¯ ∈ HL(H)≤, there is an execution ex of H whose external trace is s and which can be extended by p¯. Then any execution ex' of H whose external trace is s can be completed with those firings which occur in ex · p¯ and not in ex'. Note that the external trace of the execution we obtain is s · p¯. Then no execution of H whose external trace is s is quiescent. For the second property, let sp¯, sq¯ ∈ HL(H)≤. Let also ex'p¯ be an execution whose external trace is sp¯ and ex''q¯ be an execution whose external trace is sq¯. Just as above we can interleave ex'p¯ and ex''q¯, so to obtain execution ex whose external trace is sp¯q¯ ∈ HL(H)≤.	□

Proof of Lemma 4.5 The direction right-to-left is almost immediate: if there exists such a critical set, by definition t ~σ c. Then suppose that t ~σ c. Let S be the set of all critical pairs for c in σ which are inverted in t and let s be a handshake trace with the same threads as t 4 and in which all pairs of S are inverted. We prove by induction on d = d∼(s, t) that s ~σ c:
d = 0. s = t, then s ~σ c;
d = l + 1. There is a sequence t = t0,... tl+1 = s such that d∼(ti, ti+1)= 1 and
ti ~σ c, ∀0 ≤ i ≤ l. By contradiction assume tl+1 →σ c. Let tl = t' · m · n · t'' and tl+1 = t' · n · m · t''. If m is an input or n an output, tl r tl+1. Then since tl+1 →σ c, also tl →σ c. Contradiction. Then m is an output, say the jth occurrence of ¯b, and n is an input, say the ith occurrence of a. By definition ⟨ai, ¯bj⟩ is a critical pair and since the sequence t0,... tl+1 is minimal by definition of d∼, ⟨ai, ¯bj⟩ ∈ S.
But ⟨ai, ¯bj⟩ is not inverted in s: contradiction!
Then S is critical for c in σ. If S is not minimal we just need to take the minimal critical set contained in S and we are done.	□

Proof of Theorem 4.2 We already described the general construction of Hσ for σ positional (proof of proposition 4.3) as well as its extension to the non-positional case (end of section 4). Lemma 4.5 justifies this extended construction by telling us that an “exception” to positionality has all the pairs of a critical set inverted and, viceversa, if a trace has all the pairs of a critical set inverted, then it is an exception to positionality. Then the proofs that s ∈ σ≤ ⇐⇒ s ∈ HL(Hσ)≤ and s ∈ σ ⇐⇒ s ∈ HL(Hσ) are just adaptations of the corresponding proofs that we gave for proposition 4.3.	□




4 To be more precise we should take s from a larger set, where the number of input occurrences in each thread of s is equal to the number of input occurrences in the corresponding thread of t. This allows a thread of s to differ from the corresponding thread of t by an output occurrence. However reorder-closedness implies that outputs do not affect choices, so that we can assume s and t have exactly the same threads.
