Electronic Notes in Theoretical Computer Science 108 (2004) 39–51  
www.elsevier.com/locate/entcs


A Software Architecture-Based Approach for Formalising Middleware Behaviour
Nelson Souto Rosa1 and Paulo Roberto Freire Cunha2
Centro de Inform´atica Universidade Federal de Pernambuco 50732-970 Recife, Pernambuco - Brazil

Abstract
The number of open specifications of middleware systems and middleware services is increasing. Despite their complexity, they are traditionally described through APIs (the operation signatures) and informal prose (the behaviour). This fact often leads to ambiguities and makes difficult a better understanding of what is really described. In this paper, we adopt software architecture principles for structuring middleware together the LOTOS language for formalising their behaviour. The adoption of software architecture principles makes explicit structural aspects of the middleware. Meanwhile, the formalisation enables us to check behavioural properties of the middleware. In order to illustrate our approach, we present a LOTOS specification of the well-known object-oriented middleware CORBA and its transaction service.
Keywords: Middleware, Software Architecture, Behaviour, Middleware.


Introduction
The number of open specifications of middleware systems and middleware services is increasing. Those specifications include open standards such as DCE (Distributed Computing Environment) [17], RM-ODP (Reference Model
- Open Distributed Processing) [10], EJB (Enterprise Java Beans) [12] and CORBA (Common Object Request Broker Architecture) [16]. The open spec- ifications of middleware services have also been popular through the JTS (Java Transaction Service) and JMS (Java Message Service).

1 Email: nsr@cin.ufpe.br
2 Email: prfc@cin.ufpe.br



1571-0661 © 2004 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2004.01.011


Middleware specifications are not trivial to be understood, as the middle- ware itself is usually very complex [8]. Firstly, middleware systems have to hide the complexity of underlying network mechanisms from the application. Secondly, the number of services provided by the middleware is increasing, e.g., the CORBA specification contains fourteen services. Finally, in addi- tion to hide communication mechanisms, the middleware also have to hide fails, mobility, changes in the network traffic conditions and so on. On the point of view of application developers, they very often do not know how the middleware really works. On the point of view of middleware developers, the complexity places many challenges that include how to integrate services in a single product [18] or how to satisfy new requirements of emerging applications [7].
The aforementioned specifications are usually described through APIs. Es- sentially, the service’s operations signatures are described in IDL (Interface Definition Language) and the behaviour of individual operations is described by informal prose. For example, the operations of CORBA common object services (COS), such as security, transaction and naming, are described in IDL CORBA and informal text [15]. In practical terms, developers who want to implement those services have a hard task to produce a final product by interpreting what the specifications describe.
In this context, we present an approach that uses software architecture principles for structuring middleware systems. In the meantime, we propose the adoption of LOTOS [1] for specifying the behaviour of those software architectures. Initially, the middleware architecture is defined in terms of software architecture elements such as components and connectors. Next, the LOTOS language is used as an ADL (Architecture Description Language) [14], in which the middleware behaviour is formally described. It is worth observing that we are not interested in any particular middleware product or middleware model.
On one hand, the adoption of software architecture principles is interest- ing as it treats with the system complexity by explicitly separating commu- nication and computation aspects. Additionally, the software architecture enables us to have a better structural view of the middleware. On the other hand, the use of LOTOS allows the checking of particular behavioural prop- erties of middleware systems, e.g., deadlock, livelock and execution sequences. Additionally, the language allows to automatically generate tests and check the behavioural equivalence (e.g., strong equivalence, branching equivalence, weak equivalence) between different middleware models and different middle- ware service compositions. For example, if one desires to replace a message- oriented middleware by a procedural middleware, it is possible to check if their


behaviours are equivalent. Finally, a formal specification eliminates ambigu- ities in the middleware specification and provides a better understanding of what is actually described.
Formal description techniques have been used together middleware in the RM-ODP, in which the trader service is formally specified in LOTOS. Most recently, the Z notation and high level Petri nets have been adopted for spec- ifying CORBA services [4], the Naming service [11], the Event service [5] and the Security service [3]. All those works, however, do not adopt software archi- tecture principles for structuring the service descriptions. In terms of software architecture, a few ADLs include the possibility of describing behaviour, like Wright [2]. However, there are not tools that enables us to check behaviour properties. Medvidovic [13] has observed the convergence of middleware and software architecture principles. However, he does adopt a formal approach. Finally, it is possible to note that the software architecture principles are widely adopted to build distributed applications (client and servers), but its benefits are rarely applied to middleware that connect them.
This paper is organised as following: Section 2 presents how the middle- ware architecture is defined in terms of software architecture elements. Next, Section 3 presents the use of LOTOS for describing the middleware software architecture. In Section 4, we adopt our approach for specifying CORBA. Fi- nally, the last section presents the conclusions and some directions for future work.

Middleware Software Architecture
Prior to describe our approach on how to define middleware software architec- tures, we present the notion of middleware, middleware services and software architecture.

Middleware
The middleware layer is placed between the application and the operating system in order to hide the complexity of underlying network mechanisms [6]. This fact enormously facilitates the task of distributed application develop- ers. For middleware developers, the middleware is viewed as a collection of distributed services (or middleware services) that takes the primary responsi- bility of communicating distributed applications. The middleware often also provides additional services such as security, transaction, naming and events, which ”aggregate” value to the communication between distributed applica- tions.

Middleware Services
A middleware service is defined as a black box where it is known what is provided at the interface but not how it is actually implemented. The middle- ware service is specified by a set of interfaces (APIs) and protocols it supports. The APIs are usually defined through IDLs, whilst the service’s behaviour is informally described by prose. In terms of implementation, a middleware ser- vice is distributed and includes entities (e.g., objects, components) that make up a client part, which supports the service’s API running in the application’s address space, and a server part that actually implements the service.

Software Architecture
The definition of software architectures involves the use of three basic ab- stractions: components, connectors and configurations. A component is a unit of computation or a data store. Components represent a wide range of different elements, from a simple procedure to an entire application, and have an interface used to communicate the component with the external environ- ment. A connector is an architectural building block used to model inter- actions among components and rules that govern those interactions. Some examples of connectors include client-server protocols, variables, buffers, se- quence of procedure call and so on. A connector has an interface that contains interactions points between the connector and the component and other con- nectors attached to it. Finally, the configuration describes how components and connectors are wired together [14].


Fig. 1. Different Views of the Middleware Software Architecture


Using the aforementioned basic elements, the middleware software archi- tecture is defined according to the following principles:
The middleware is viewed at three different levels of abstractions: a sin- gle connector (Fig. 1 (a)), the middleware abstract software architecture (Fig. 1 (b)) and the middleware concrete software architecture (Fig. 1 (c)). The middleware viewed as a connector is usually used/understood by application developers who are interested in the basic function of the middleware and not in details on how the middleware actually works, i.e., the middleware as a black-box communication element. The middleware abstract software architecture is typically adopted in open specifications, which provide details of the services that made up the middleware (op- eration signatures), but do not define how to actually implement those services. The middleware concrete software architecture is essential for middleware developers;
The communication service, whatever the middleware model or product, is the only mandatory service. Thus, it is explicitly defined in the ab- stract middleware software architecture. Whether the middleware has additional services or not, it depends on the middleware specification;
Each service provided by the middleware (e.g., security, event) defines a component in the abstract software architecture, except the communica- tion service, which is modelled as a connector. Meanwhile, according to software architecture principles, a connector must always exist between any two components (service);
The services in the middleware concrete software architecture are defined through two parts, namely client (or sender) and server (or receiver) parts. Additionally, each service may be defined as a composition of fine-grained components. For example, the CORBA security service is made up of a principal authenticator and a component responsible for the cryptography;
The underlying communication layers (e.g., transport and network layers) are defined as a connector in the software architecture; and
The dashed line connector is a virtual connector [Medvidovic 02] that models protocols between the client/sender and server/receiver parts of the service. For example, the two-phase commit protocol commonly used in the transaction service.
By observing those guidelines, some points have to be taken in account. Firstly, since middleware systems do not perform any application-specific com- putation, they are naturally modelled as connectors. Secondly, the middleware provides further services in addition to the communication one. Hence, the


middleware may not be only considered as a simple connector. In the software architecture discipline, however, only components (no connectors) are tradi- tionally decomposed into smaller elements. Finally, it is worth observing that the communication service enables other services (components) and applica- tions to interact. Hence, it is also naturally differentiated from other services and modelled as a connector.
Next, we present how those guidelines are followed in the definition of the middleware software architecture behaviour.
Middleware Software Architecture in LOTOS
A LOTOS specification describes a system through a hierarchy of active com- ponents, or processes. A process is an entity able to realize non-observable internal actions, and also interact with others processes through externally observable actions. The unit of atomic interaction among processes is called an event. Events correspond to a synchronous communication that may occur among processes able to interact with one another. Events are atomic, in the sense that they happen instantaneously and are not time consuming. The point of an event interaction occurs is known as a port. Such event may or may not actually involve the exchange of values. A non-observable action is referred to as an internal action or internal event. A process has a finite set of ports that can be shared.
In order to specify the middleware software architecture (defined according to Section 2) in LOTOS, we adopt the following guiding principles:
The basic architectural elements, namely components and connectors, are modelled through the basic LOTOS abstraction, namely process;
The top-level specification defines the software architecture configuration;
Any two LOTOS processes that model components must be in a parallel composition with a LOTOS process defined as a connector (see guideline
(iii) in Section 2);
The service specification consists of the temporal ordering of events exe- cuted at the service’s interface. Each service specification S at the mid- dleware software architecture is in monolithic style defined as S =  ai; Ai | i ∈ I for some finite index set I where each Ai is either a process identifier or an expression in action prefix form; and
Following the RM-ODP terminology, we call to invocation (inv) those actions to activate the service and termination (ter) to the action of return a result.
Following those principles, next sections present the LOTOS specification

of the middleware software architecture.
Middleware as a Connector
As mentioned in Section 2, the simplest architectural view of the middleware is one that considers the middleware as a connector (Fig. 1 (a)). In this particular case, the middleware is viewed as a black-box connector that has the role of the communication service.
The LOTOS specification at the top-level of Fig. 1 (a) is a parallel com- position (parallel operator ||) of the process Client (component client), the process Server (component server) and the process Middleware (connector middleware). The Client (4) communicates with the Server (8) through the Middleware (6) as shown in the following:
specification Client Server [invClt,terClt,invSrv,terSrv] : noexit
library RESULT, SERVICES endlib
behaviour
Client [invClt, terClt]
|[invClt, terClt]|
Middleware [invClt, terClt, invSrv, terSrv]
|[invSrv, terSrv]|
Server [invSrv, terSrv]
where
...
endspec
Having the role of the communication service, the middleware behaviour is defined through the temporal ordering of invocation operations in the mid- dleware interface. The middleware interface is made up of four ports: invClt to invocations from Client, terClt to returns to Client, invSrv to invocations from Server and terSrv to return to Server.
process Middleware Connector[invClt, terClt, invSrv, terSrv] : noexit : = 
invClt ? s : SERVICE ? op : OPER;
invSrv ! s ! op;
terSrv ! s ? r : RESULT;
terClt ! s ! r;
Middleware [invClt, terClt, invSrv, terSrv]
endproc
In this case, the middleware receives an invocation from the server (2) that contains both the name of the requested service and the operation being re- quested on the server (invClt ? s : SERVICE ? op : OPER;). The middleware passes both of them to the server (3) and waits for the reply (4). Finally, the middleware passes the reply containing the result to the client (5).
The behaviour of those components and connectors together is shown in the following trace obtained by simulation in the CADP Toolbox.
<initial state>
”i” (BIND TO SERVER [16]) /* the client binds to the server */
”INVCLT ! ‘Service’ ! ‘op1’” /* the client passes the request to the middleware */
”INVSRV ! ‘Service’ ! ‘op1’” /* the middleware passes the request to the server */


”i” (PROCESSOP1 [35]) /* the server processes the request */
”i” (SA [24]) /* the server updates it internal state */
”TERSRV ! ‘Service1’ ! ‘ok’” /* the server passes the reply to the middleware */
”TERCLT ! ‘Service1’ ! ‘ok’” /* the middleware passes the reply to the client */
<goal state>
Next, we present the middleware abstract software architecture.
Middleware Abstract Software Architecture
According to guidelines presented in Section 2, the middleware abstract software architecture is defined as a collection of services. Fig. 2 (a)(b) depicts the components and connectors involved in a communication through the middleware abstract software architecture. It is worth observing that both the number of available middleware services and the way they are composed depends on the particular middleware being considered.


Fig. 2. Middleware Abstract Software Architecture
In order to specify the middleware abstract software architecture, we assume the configuration depicted in Fig. 2 (a) that is composed by three components (Service1, Service2 and Service3) and a single connector (Communication Service). The LOTOS specification at the top-level of this software architecture is a parallel composition (parallel operator ||) of the set of basic services (parallel composition - operator ||| - of the independent processes Service1, Service2 and Service3) and the process CommunicationService (7).
process Middleware Abstract [invClt, terClt, invSrv, terSrv] : noexit :=
hide inv, ter in
((Service1[inv, ter] ||| Service2[inv, ter] ||| Service3[inv, ter])
||
ServiceOrdering [inv, ter])
|[inv, ter]|
CommunicationService [inv, ter, invClt, terClt, invSrv, terSrv]
where
...
endproc
An important point of this specification is the ordering of composition of the middleware services (5). We adopt the LOTOS constraint-oriented specification style by defining the process ServiceOrdering that constrains the way the services are composed. As a consequence, this LOTOS process is not part of the software architecture itself, but a modelling element. In this particular case, according to the constraints imposed by ServiceOrdering, after the request gets in the mid- dleware, it is passed to Service1 (2-3) followed by Service2 (4-5) and Service3 (6-7). Then, the request is sent to Server where it is processed and sent back to Client.
process ServiceOrdering [inv, ter] : noexit :=
inv ! Service1 ? op : OPER;
ter ! Service1 ? r : RESULT;
inv ! Service2 ? op : OPER;
ter ! Service2 ? r : RESULT;
inv ! Service3 ? op : OPER;
ter ! Service3 ? r : RESULT;
ServiceOrdering [inv, ter]


endproc
Middleware Concrete Software Architecture
According to Section 2, the definition of the middleware concrete software architecture consists of explicitly decomposing the middleware services into the client and server parts. The client part is the middleware service interface (remotely accessible), whilst the server part is the implementation of the service itself. As mentioned in Section 3.1, unlike other services, the communication service is a connector and it is not designed using this client/server approach. Hence, the same commu- nication services run in both sides of the architecture. The LOTOS specification of the concrete software architecture at top-level is shown in the following:
specification Middleware Concrete [reqClt, repClt, reqSrv, repSrv] : noexit
library OPER, RESULT endlib
behaviour
hide reqCN, repCN, reqSN, repSN in
(Client [reqClt, repClt]
|[reqClt, repClt]|
MiddlewareClient [reqClt, repClt, reqCN, repCN])
|[reqCN, repCN]|
Network [reqCN, repCN, reqSN, repSN]
|[reqSN, repSN]|
(MiddlewareServer [reqSrv, repSrv, reqSN, repSN]
|[reqSrv, repSrv]|
Server [reqSrv, repSrv])
where
...
endspec
The middleware in the server side (MiddlewareServer) and the middleware in the client side (MiddlewareClient) are not the same. This is an interesting point to be observed as middleware products are different in both sides. This fact has a direct impact on how the middleware services are composed. Additionally, a service (or some of its components) may be present in the server and absent in the client. For example, the authentication component in the CORBA security service is not present in the client. Hence, the ServiceOrdering process and the set of services in both sides are different. For lack of space, we do not show the concrete middleware behaviour, but it is composed by 48 actions when the client request an operation followed by a reply.
Case Study: The CORBA Software Architecture
In order to illustrate our approach, we present how it may be applied to the middleware CORBA. Three main reasons have motivated the adoption of CORBA: the number of middleware services available in CORBA is larger than any other midddleware; the CORBA services are well detailed through API, which enables us a better understanding on how the service actually works; and CORBA has an explicit communication element (the ORB) that naturally acts as a connector.
Object-oriented middleware (OOM), such as RMI (Remote Method Invocation), EJB and CORBA, provides the abstraction of an object that is remote yet whose methods can be invoked just like those of an object in the same address space as the caller. Two services are usually mandatory in the OOM, namely the naming service and the communication service. The naming service (known as ”yellow pages”) takes responsibility of registering business services provided by the servers. Clients that desire to make request to those services contact the naming service, which gives direction on how to find the server previously registered that provides the required service.
CORBA [16] is a standard that has been widely adopted for implementing middleware prod- ucts. According to the CORBA specification, in addition to the communication service known as ORB, fourteen distributed services should be provided by the middleware: persistence, external- isation, events, transactions, properties, concurrency, relationships, time, licensing, trader, query, collections, lifecycle and security [15]. All these services are not usually implemented in a single product, but at least the naming, life cycle and communication services are available in CORBA complaint products.
Fig. 3 presents the CORBA software architecture at 3 different abstraction levels, according to the guidelines presented in Section 2. Each CORBA Service, known as COS (Common Object Services), is modelled as a component in the CORBA software architecture. Additionally, the ORB (communication service) is defined as a connector.





Fig. 3. Object-oriented Middleware Model

Two points must be observed in the CORBA software architecture. Firstly, the CORBA standard defines that the COS services may be either inside or outside the ORB. In this particular architecture, we adopt the second approach. Secondly, the stubs, skeletons and POA (Portable Object Adapter) have been incorporated by the ORB and are no explicit elements in abstract software architecture (application developers view). However, they are present in the concrete software architecture (middleware developers view). After being defined the software architecture, next sections present how the principles described in sections 3.1, 3.2 and 3.3 are adopted to CORBA.

CORBA as a Connector
The behaviour of the CORBA as a connector is very similar to one shown in Section 3.1. In this case, the CORBA receives a request from the server and sends it to client. After being processed, the reply is sent back to the client via the middleware. At this abstraction level, the software architecture does not present details on how this task is actually performed. The behaviour of the connector CORBA is specified as the temporal ordering of events executed in the CORBA interface. The CORBA interface is made up of several other interfaces such as dynamic invocation, stub, ORB, static skeleton, dynamic skeleton and POA interfaces.
In the following specification, the operations defined in each of the aforementioned interfaces are passed to the middleware through the event ”invClt ? s : Service ? op : OPER;”, where s is the name of service being request and op the operation.
process CORBA [invClt, terClt, invSrv, terSrv] : noexit := invClt ? s : Service ? op : OPER;
invSrv ! s ! op;
terSrv ! s ? r : RESULT; terClt ! s ! r;
CORBA [invClt, terClt, invSrv, terSrv]
endproc
Next, we present the CORBA abstract software architecture that provides a more detailed view of CORBA.

CORBA Abstract Software Architecture
The CORBA abstract software architecture is defined as a collection of services as mentioned before. The top specification is a parallel composition of fourteen different services (components) and the ORB (connector) as shown in the following:
process CORBA [invClt, terClt, invSrv, terSrv] : noexit :=


hide inv, ter in
(( Naming [inv, ter] ||| Event [inv, ter] ||| Persistent [inv, ter] |||
LifeCycle [inv, ter] ||| Concurrency [inv, ter] ||| Externalization [inv, ter] ||| Relationship [inv, ter] ||| Transaction [inv, ter] ||| Query [inv, ter] ||| Licensing [inv, ter] ||| Property [inv, ter] ||| Time [inv, ter] |||
Security [inv, ter] ||| Trading [inv, ter] )
||
ServiceOrdering [inv, ter] )
|[inv, ter]|
ORB [inv, ter, invClt, terClt, invSrv, terSrv] (0)
where
...
endspec
As defined in Section 3.2, the LOTOS process ServiceOrdering is not an architectural compo- nent, but it is defined in order to constrain the way the services interact. In this particular case, the most important ordering constraint is one related to the naming service (process Naming). As widely known, every distributed service must be registered in the naming before be used by clients
(2). Additionally, the client must obtain an interface reference to the service to use it (3).
process ServiceOrdering [inv, ter] : noexit :=
inv ! COSnaming ! register;
ter ! COSnaming ? r : RESULT;
inv ! COSnaming ! lookup;
ter ! COSnaming ? r : RESULT;
ServiceOrdering [inv, ter]
endproc
Next, we show the trace generated by the simulation of all those elements together. This trace reveals the constraint imposed by ServiceOrdering as the client and server make requests to the naming service (2-11) before use the Service1 provided by the server (12-18).
<initial state>
”INVSRV ! ‘COSnaming’ ! ‘register’” /* the server registers the service */
”i” (INV [68])
”i” (OPREGISTER [106])
”i” (TER [68])
”TERSRV ! ‘COSnaming’ ! ‘ok’”
”INVCLT ! ‘COSnaming’ ! ‘lookup’” /* the client looks for the service */
”i” (INV [68])
”i” (OPLOOKUP [106])
”i” (TER [68])
”TERCLT ! ‘COSnaming’ ! ‘ok’”
”INVCLT ! ‘Service1’ ! ‘op1’” /* the client makes a request to the server */
”INVSRV ! ‘Service1’ ! ‘op1’”
”i” (SA [28])
”i” (PROCESSOP1 [43])
”TERSRV ! ‘Service1’ ! ‘ok’”
”TERCLT ! ‘Service1’ ! ‘ok’”
”INVCLT ! ‘Service1’ ! ‘op1’”
<goal state>

CORBA Concrete Software Architecture
According to the COS Transaction specification [15], the transaction service is specified through 6 interfaces, namely Current, TransactionFactory, Terminator, Coordinator, RecoveryCoordinator and Resource. These interfaces allow multiple, distributed objects to cooperate to provide atomic- ity, consistency, isolation and durability properties. Each interface is modelled by a component in the software architecture.
For lack of space, we only present the concrete software architecture of the CORBA transac- tion service. The top specification is very similar to one shown in Section 3.3 that is a parallel composition of ServiceInterface and StateProc. The process ServiceInterface models the interfaces of the transaction service, which is made up of is 6 other interface as mentioned before: Current, TransactionFactory, Terminator, Coordinator, RecoveryCoordinator and Resource.


process Transaction Service [inv, ter] : noexit :=
hide sa in
ServiceInterface [inv, ter, sa] |[sa]| StateProc [sa]
where
process ServiceInterface [inv, ter, sa] : noexit :=
Current [inv, ter, sa] ||| TransactionFactory [inv, ter, sa] |||
Control [inv, ter, sa] ||| Terminator [inv, ter, sa] |||
Coordinator [inv, ter, sa] ||| RecoveryCoordinator [inv, ter, sa] |||
Resource [inv, ter, sa]
where
...
endproc
The whole specification of the transaction service has approximately 1200 lines and it is not completely terminated.
Conclusions and Future Work
This paper has illustrated how to adopt LOTOS to describe the behaviour of middleware software architectures. The specification has been structured according to software architecture principles, i.e., all middleware model elements are viewed as components, connectors and configuration. This approach facilitates the understanding of the general structures of different middleware specification as it separates computation and communication elements.
The adoption of LOTOS for describing the middleware enables us to check behaviour prop- erties (we have used the CADP Toolbox) of each individual middleware and middleware service specification. This is not possible in the case an ADL is adopted instead LOTOS. We know that LOTOS has not been originally designed to be used like an ADL. Its main limitations include lack of proper abstractions to model component, connector and interface, and the language does not allow to define architectural styles. However, its limitations are compensated by its powerful ability for describing behaviour and availability of tools.
The presented LOTOS specifications serve as basis for very interesting future work. We are now interested on the performance and reliability analysis of middleware models [9]. For this par- ticular purpose, we are currently using the CADP Toolbox to generate Petri Nets. The Petri Nets specifications of the middleware models are more adequate to be analysed in terms of performance and reliability. Additionally, the proposed formalisation also opens a new track on how to compose middleware services, which is a basic task of adaptive middleware systems.

References
ISO 15437. Enhancements to LOTOS. ISO/IEC JTC1/SC21/WG7, January 2001.
Robert J. Allen. A Formal Approach to Software Architecture. PhD thesis, School of Computer Science, Carnegie Mellon University, Pittsburgh, PA, USA, May 1997. CMU-CS-97-144.
David Basin, Frank Rittinger, and Luca Vigan´o. A Formal Analysis of the CORBA Security Service. In Lecture Notes in Computer Science, number 2772, pages 330–349, 2002.
R˜emi Bastide, Philippe Palanque, Ousmane Sy, and David Navarre. Formal Specification of CORBA Services: Experiences and Lesson Learned. In OOPSLA 00, pages 105–117, 2000.
R˜emi Bastide, Ousmane Sy, David Navarre, and Philippe Palanque. Formal Specification of CORBA Services: Experiences and Lesson Learned. In Formal Methods for Open Object-Based Distributed Systems (FMOODS), pages 371–396, September 2000.
Philip A. Bernstein. Middleware: A Model for Distributed System Services. Communications of the ACM, 39(2):87–98, February 1996.
Gordon Blair, G. Coulson, R. Philippe, and M. Papathomas. An Architecture for Next Generation Middleware. In Middleware 98, pages 191–206, 1998.
Andrew T. Campbell, Geoff Coulson, and Michael E. Kounavis. Managing Complexity: Middleware Explained. IT Professional, 1(5):22–27, 1999.


Wolfgang Emmerich. Software Engineering and Middleware: A Roadmap. In Second International Workshop on Software Engineering and Middleware, pages 119–129, Limerick. Ireland, June 2000.
ISO.	Reference   model   of   open   distributed processing Part 1 - overview. ISO/IEC/JTC1/SC21/WG7, ISO 10746-1, Helsink, Finland, July 1995.
D. Kreuz. Formal Specification of CORBA Services Using Object-Z. In Second IEEE International Conference on Formal Engineering, pages 180–189, December 1998.
Vlada Matena and Mark Hapner. Enterprise JavabeansTM . Sun Microsystems, March 1998.
Nenad Medvidovic. On the Role of Middleware in Architecture-Based Software Development. In 14th International Conference on Software Engineering and Knowledge Engineering (SEKE), pages 299–306, 2002.
Nenad Medvidovic and Richard N. Taylor. A Classification and Comparison Framework for Software Architecture Description Languages. IEEE Transactions on Software Engineering, 26(1):70–93, January 2000.
OMG. CORBAServices: Common Object Services Speciﬁcation, December 1998.
OMG. Common Object Request Broker Architecture: Core Speciﬁcation (CORBA 3.0), December 2002.
W. Rosenberry, D. Kenney, and G. Fisher. Understanding DCE. O’Reilly & Associates,Inc., 1993.
Nalini Venkatasubramanian. Safe Composability of Middleware Services. Communications of the ACM, 45(6):49–52, June 2002.
