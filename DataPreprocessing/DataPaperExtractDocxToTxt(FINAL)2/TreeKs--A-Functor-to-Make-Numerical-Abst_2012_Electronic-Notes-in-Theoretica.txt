Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 287 (2012) 41–52
www.elsevier.com/locate/entcs
TreeKs: A Functor to Make Numerical Abstract Domains Scalable
Mehdi Bouaziz1
DI - École Normale Supérieure 45 rue d’Ulm
75230 Paris Cedex 05 - France

Abstract
Relational numerical abstract domains do not scale up. To ensure a linear cost of abstract domains, abstract interpretation-based tools analyzing large programs generally split the set of variables into independent smaller sets, sometimes sharing some non-relational information. We present a way to gain precision by keeping fully expressive relations between the subsets of variables, whilst retaining a linear complexity ensuring scalability.
Keywords: Abstract interpretation, abstract numerical domains, weakly relational domains.


Motivation
Abstract interpretation [4] is a theory of sound approximation of semantics of pro- gramming languages, mainly used in static analysis and verification of programs. A crucial point when designing an abstract interpretation-based analyzer is the choice of suitable abstract domains.
The domain of intervals was presented as one of the first abstract domains [3]. Although, even when the properties of interest are expressible with intervals, rela- tional properties may be needed to compute them precisely. Shortly after, some of the limitations of intervals were overcome thanks to the domain of polyhedra [6]. While very precise, polyhedra are too costly and cannot be reasonably used to an- alyze programs with more than a few variables. Since then, numerous numerical abstract domains were designed to capture various properties, among them linear inequalities. Weakly relational domains restrict the shape of representable relations to achieve better computation times than polyhedra.

1 Email: mehdi.bouaziz@ens.fr


1571-0661 © 2012 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2012.09.005

Between intervals and polyhedra, one can now find: pentagons [11], zones (or DBM) [12], weighted hexagons [8], octagons [13], logahedra [9], TVPI [16], octahe-
dra [2], and templates [14].
Even the operations of the pentagon domain have a quadratic cost 2 , which does not scale up [1,5]. Only a cost close to linear is acceptable when it comes to analyzing large programs.
Instead of looking for other shapes of relations, an orthogonal axis of research to the everlasting cost-precision trade-off is to modify the constraint graph (Def. 3.3), i.e., to restrain the set of variables between which there can be relations.
This idea has already been applied in Astree [1,5] and in C Global Surveyor [17], both analyzing large avionic and aerospace C programs. The set of variables is divided into several subsets called packs on which operators of the octagon domain are applied independently. However only non-relational information (i.e., intervals) are shared between packs.
The paper makes the following contributions:
Several existing numerical domains are grouped together and generalized into a theoretical framework of linear inequality domains (Sect. 2).
A domain functor (TreeKs, Sect. 3) is defined. It can be applied to any linear inequality domain to make a new scalable domain. The set of relations expressible in the new domain is a subset of those expressible in the underlying domain. The restriction is not made on the shape of the relations but on the variables between which the relations are defined.
Taking advantage of the specific shape of the relation graph, an efficient comple- tion algorithm (Sect. 4) for TreeKs domains is presented, along with its correctness proof. If packs are kept bounded, the cost of the domain remains linear.
Finally, efficient algorithms (Sect. 5) are given for other operations required by abstraction interpretation.

Linear Inequality Domains
In this section we present theoretical properties of linear inequality domains, on which we will be able to apply our functor in the next section. This generalizes the work of Simon, King, and Howe on TVPI [16]
Let V d=ef {X1,..., XN } be a finite set of variables over Q. Let Q٨ d=ef Q \ {0}

denote non-zero and Q٨
d=ef {x ∈ Q | x > 0} positive rational numbers.

Let S{n} denote the set of n-tuples made of members of S. If S is a set of tuples, let Q٨S d=ef {⟨qx1,..., qx ⟩| ⟨x1,...,x ⟩∈ S, q ∈ Q٨} denote the scalar multiplica-
k	k
tion of all members of S by a scalar of Q٨.
Definition 2.1 A base set D of a linear inequality domain is a subset of	i≥1(Q٨){i}
closed by subset and closed by multiplication by a positive scalar of Q٨ . It is said

2 The cost of a domain is the amortized complexity, in the number of variables, of its operations. For weakly relational domain, this cost is dominated by the cost of the completion.

to be k-relational if it is a subset of Sk
(Q٨){i}.

Base sets of known linear inequality domains are the following:
Intervals d=ef (Q٨){1}
Zones d=ef (Q٨){1} ∪ Q٨ {⟨1, −1⟩}
Octagons d=ef (Q٨){1} ∪ Q٨ {⟨1, −1⟩ , ⟨1, 1⟩}
LogahedraB = (Q٨){1} ∪ Q٨  ±1, ±2k  −B ≤ k ≤ B, with B ∈ N ∪ {+∞}
def
TVPI d=ef (Q٨){1} ∪ (Q٨){2}
Octahedra d=ef	Q٨ {−1, 1}{k}
k≥1
Polyhedra d=ef	(Q٨){k}
k≥1
Definition 2.2 The set of inequalities (or relations, or constraints) of a domain
based on D over the set of variables V is defined:


D d=ef {True, False}∪ 
   Σk

a x ≤ d

⟨a ,...,a ⟩∈ D,x ∈ V,d ∈ Q

V
k≥1
i  i	1	k	i
i=1

with True d=ef 0 ≤ 1 and False d=ef 0 ≤ −1.
Definition 2.3 The set of values of a domain based on D over the set of variables
V is defined by DV d=ef Pf (DV ), the finite sets of constraints of DV .
Definition 2.4 If c = Σn	aixi ≤ d, and if c /≡ True and c /≡ False, then the
concretization of c is a half-space of QN , the set of values satisfying the constraint
c:
〚c〛 d=ef  (U ,...,U ) ∈ QN Σ a u ≤ d, x = X ⇒ u = U

1	N	i i
i=1
j	i	j	i

〚∅〛 = 〚{True}〛 = 〚True〛 d=ef QN	〚False〛 d=ef ∅
The concretization of a value C = {c1,..., cn} is the intersection of the con-
cretization of its members 〚C〛 d=ef n	〚ci〛.

Definition 2.5 The set of values DV is ordered by entailment : C1 ▶ C2 ⇐d⇒ef
〚C1〛 ⊆

〚C2〛. Equivalence is defined as C1 ≡ C2 ⇐d⇒ef
C1 ▶ C2 and C2 ▶ C1.

Definition 2.6 The variables of a linear inequality is the set of variables for which the coefficient is not zero.	If c = a0X0 + ... + aN XN  ≤ d, then vars(c) d=ef

{Xi ∈V | ai /= 0}. For a set of linear inequalities, vars(C) d=ef S

c∈C
vars(c).

Definition 2.7 Let X ⊆ V be a set of variables, the restriction of a value to this set of variables is defined: πX (C) d=ef {c ∈ C | vars(c) ⊆ X}.

Definition 2.8 A forget operator (or projection operator ) of ÐV is a mapping E :
P(u) —→ ÐV DV such that 6 C1 ∈ ÐV , 6F = {Xi ,..., Xi }⊆ u, we have EX (C1)= 
C2 such that vars(C2) ⊆u \ F and
〚C2〛 = {(u1,..., ui1−1, a1, ui1+1,..., uin−1, an, uin+1,..., uN )
| a1,..., an ∈ Q, (u1,..., uN ) ∈ 〚C1〛}
Definition 2.9 A domain ÐV is stable by elimination of variables if 6 c1, c2 ∈ ÐV
such that c1 = ΣN aiXi ≤ d1, c2 = ΣN biXi ≤ d2 and if E j such that 1 ≤ j ≤ N ,
aj < 0 and bj > 0, we have (bjc1 + ajc2) ∈ ÐV .
The domains Intervals, Zones, &ctagons, Logahedra∞, f VPI as well as
Polyhedra are stable by elimination of variables.
If |u| ≥ 3 then the domains &ctahedra and LogahedraB with 1 ≤ B < ∞ are not stable by elimination of variables 3 4 .
If ÐV is stable by elimination of variables then Fourier-Motzkin elimination is a forget operator.

Abstraction
There is no best abstraction on Q (e.g., for X × X ≤ 2). We will call α¯ the partial abstraction defined, when it makes sense, by the topological closure of the convex hull.
Definition 2.10 The intersection between values of ÐV is exact and is defined by the union of the inequalities set: C1 HDV C2 d=ef C1 ∪ C2.
The union between values is defined as the best abstraction: C1 HDV C2 d=ef
α¯(〚C1〛 ∪ 〚C2〛) 5 .
The set (ÐV / ≡, ▶, HDV , HDV , False, True) is a lattice.

The Domain Functor
In this section we build a new numerical abstract domain 6 based on an existing relational numerical domain, such as zones, octagons, logahedra, TVPI, octahedra, or polyhedra. Note that our construction will also work for other numerical domains that fall within the framework of the previous section.
Underlying Domain Properties
Suppose that the underlying domain is a numerical abstract domain over Q, that is, it provides the following mathematical objects:

3 Indeed X1 + X2 ≤ 0 and −X1 + X2 + X3 ≤ 0 are in Octahedra but their sum 2X2 + X3 ≤ 0 is not.
4 Indeed X1 − 2BX2 ≤ 0 and X2 − 2X3 ≤ 0 are in LogahedraB but their normalized sum X1 − 2B+1X3 ≤ 0
is in LogahedraB+1 but not in LogahedraB .
5 Note that α¯ is always defined for such an input since the union of a finite number of polyhedra has a finite number of vertices and generators.
6 Our domain is called TreeKs since, for a 2-relational underlying domain, the relation graph (Def. 3.3) is a tree of complete graphs (generally denoted by K).

a base set D e ⟨1, —1⟩, i.e., the domain contains zones, in particular equalities are representable,
its associated domain ÐV , with a computer representation D of its members,
an effective algorithm to compare abstract values,
effective algorithms to compute: exact variable elimination EDV and intersection
HDV , sound abstraction of union HDV , widening oDV and possibly narrowing ΔDV .
Packs and Graphs
In order to ensure scalability to large variable sets, we want to restrain the domain
Ð to some chosen relations instead of all relations expressible in the domain.
Definition 3.1 A pack set P = {P1,..., Pm | Pi ⊆ u} is a set of subsets of variables
of u, such that Sm Pi = u, and for all i /= j, we have Pi ¢ Pj.
Definition 3.2 The pack graph is defined by GP d=ef (P, F ) where (Pi, Pj) ∈ F if and only if i /= j and Pi ∩ Pj /= ∅. We will call any non-empty set Pi ∩ Pj a frontier.
Moreover we demand that the graph pack is a tree, i.e., there exists exactly one path from a pack to another pack in this graph.
This implies that a variable only appears in at most two packs. To make a variable appear in three packs P1, P2, P3 (in the pack graph P1—P2—P3), we can make a copy of it in P2 and keep an equality constraint between these two instances. We will use the following variables: m d=ef |P| ≤ N the number of packs; p d=ef max1≤i≤m |Pi|≤ N the size of the largest pack; f d=ef max1≤i<j≤m |Pi ∩ Pj|≤ p the
size of the largest frontier; and d ≤ m the diameter of the pack tree.
The Functor
Given a underlying domain D and a pack set P , inequalities and values of our new domain are respectively defined:
TreeKsD d=ef {c ∈ DV |E i, vars(c) ⊆ Pi}	freeKsD d=ef Pf (TreeKsD )
P	P	P
The set (freeKsD/ ≡, ▶, HTreeKsD , HDV , False, True) is a lattice.
P	P
Definition 3.3 The constraint hypergraph of a value C of freeKsD is representa- tion with constraints stored in edges. It is defined by HP (C) d=ef (u, E, l) where
non-oriented hyperedges are E d=ef Sm {F ⊆ Pi |E c ∈ ÐV , vars(c)= F} and l is a
labelling of the hyperedges l(e) d=ef {c ∈ C | vars(c)= e}.
The Representation Functor
Representing values as constraint hypergraphs could be well suited if the operations of the underlying domain are working on a dense graph representation, e.g., TVPI. However, for octagons, it is preferable to keep the original representation [13] where

each variable uses two vertices and constraints are stored in a half adjacency matrix. In order to make our functor independant of the underlying domain, we will keep the value representation of the underlying domain, associating an abstract value to each pack.
Thus, relations will appear twice at frontiers, our representation will be redun- dant but more efficient to use in algorithms.
We define this new domain representation as the cartesian product of the repre- sentation D of the underlying domain, restricted to subsets of variables corresponding to the packs of P , where all ⊥ are merged into a single one:
DP d=ef (DP \ {⊥DP1 }) × ... × (DP \ {⊥DPm }) ∪ {⊥D }
The set (DP / ≡DP , ±DP , HDP , HDP , ⊥DP , TDP ) is a lattice.

v ±DP w v ≡DP w
⇐d⇒ef
⇐d⇒ef
6i, vi ±D	wi	(TD )i d=ef TD
v ±DP w ±DP v	⊥DP ±DP x

(v HD w)i d=ef vi HD	wi	⊥D HD x d=ef x HD ⊥D d=ef x
(v HD w)i d=ef vi HD	wi	⊥D HD x d=ef x HD ⊥D d=ef ⊥D
Definition 3.4 Since this representation is redundant, we will say that a value v = ⟨v1,..., vm⟩ is coherent if and only if constraints coincide at frontiers, i.e., for all i, j, we have πPi∩Pj (vi) ≡ πPi∩Pj (vj).
If EQ and ∩Q are exact then for any value v, a coherent value coh(v) can be
built such that v ≡ coh(v). Indeed, simply do for all i, j, vi → vi ∩Q πP ∩P (vj).
i	j


Completion
The completion operation aims at making explicit the implicit relations. For weakly relational domains, it is needed for most of the other operations, that is why its cost dominates the efficiency of the domain.
In our case, completion has an extra goal: to transfer information between the different packs.
Definition 4.1 A value C of PolyhedraU is said to be D -complete if for all c ∈ DU ,
C ▶ c implies πvars(c)(C) ▶ c.
Definition 4.2 A domain Ð is said to be completable if for all value C of ÐU , there exists Cj ∈ ÐU such that Cj ≡ C and Cj is D -complete.
If Ð is completable, let Ðj denote the set of its D -complete values. If Ð owns a completion operation, let complete denote this function. Otherwise, let Ðj equal Ð and complete be the identity function.
An easy way to complete a value V = ⟨C1,..., Cm⟩∈ DP is to use the completion

of ÐU . Let V ٨ = completeQV (C1 ∪...∪Cm). Then V j = ⟨πP (V ٨),..., πP
(V ٨)⟩∈ 

j and V j ≡ V . While this completion is correct, it is more expensive than the

completion of the underlying domain so there would be no point in restricting to a subgraph of relations.
However a pointwise completion is not sufficient: suppose that ⟨C1, C2⟩ ∈ Zones{P1,P2}, P1 = {x, y, z} , P2 = {y, z, t} , C1 = {x ≤ y, z ≤ x} and C2 = {y ≤ t}. complete(C1) = {x ≤ y, z ≤ x, z ≤ y} and complete(C2) = {y ≤ t}. Whereas complete(C1 ∪ C2) = {x ≤ y, y ≤ t, z ≤ x, z ≤ y, z ≤ t}. Completion over P1 pro- vides information that must be injected into C2 and vice versa.
Theorem 4.4, whose proof is based on Farkas’ lemma, shows that nevertheless exchanges between packs can be kept limited.
Lemma 4.3 (Generalized Farkas’ Lemma)
Let E be a finite-dimensional affine space on a field K. Let f1,..., fk and g be affine functionals on E, such that {x ∈ E | f1(x) ≥ 0,..., fk(x) ≥ 0} is non empty.
Then {x ∈ E | f1(x) ≥ 0,..., fk(x) ≥ 0}⊆ {x ∈ E | g(x) ≥ 0} if and only if there
exists α1,..., αk,β ≥ 0 such that g = Σk	αifi + β.
A proof can be found in standard references [15].
Theorem 4.4 Let C ∈ Ðj .
Let F ⊆ u.
Let C+ ∈ ÐF such that (πF (C) ∪ C+) ∈ Ðj .
Let C∪ = C ∪ C+.
Let Cj ∈ Ðj such that Cj ≡ C∪, e.g., Cj = complete(C∪).
Then for all Y ⊆ F, πY (Cj) ≡ πY (C∪).
Proof On one side, we have Cj ▶ C∪, in particular Cj ▶ πY (C∪).  But Cj is
D -complete and πY (C∪) ∈ ÐU , hence πY (Cj) ▶ πY (C∪) (from Def. 4.1).
On the other side, the case C∪ ≡∅ is trivial, so let suppose that C∪ /≡ ∅. Let CF = πF (C∪)= πF (C) ∪ C+ and C— = C∪ \ C∪ ⊆ C.
Let c ∈ DY such that πY (Cj) ▶ c. In particular Cj ▶ c and C∪ ▶ c.
From Lemma 4.3, there exists α0,..., αn, β1,..., βm ∈ Q+, cF ,..., cF ∈ CF ,
1	n
and c—,..., c— ∈ C— such that c = cF + c— with cF = Σn	αicF , cF = True, and

We successively have C— ▶ c—, C ▶ c—, πF (C) ▶ c— (from Def. 4.1, since C is D -complete and vars(c—) ⊆ vars(c) ∪ vars(cF ) ⊆ Y ∪ F = F ), and finally CF ▶ c—. Moreover CF ▶ cF ; summing gives CF ▶ c, and πY (CF ) ▶ c because CF is D -complete. Thus for all c ∈ DY , πY (Cj) ▶ c implies πY (C∪) ▶ c.
And we get πY (C∪) ▶ πY (Cj) from:


〚πY (C∪)〛 ⊆
c∈DY
πY (C∪)▶c
〚c〛 ⊆
c∈DY
πY (C′)▶c
〚c〛 ⊆
c∈DY c∈πY (C′)
〚c〛 = 〚πY (Cj)〛


2

This theorem means that if we add new constraints C+ to a complete value C, such that the result is complete on a subset of variables F , and the result C∪ is

completed again, giving Cj, then contraints on F cannot be improved. The following algorithm uses this theorem to build completions efficiently.

Completion Algorithm
Let us choose arbitrarily a root in the pack tree and direct this tree such that arcs are directed from the root to the leaves. Suppose that the root is P1 and that if there is an arc from Pi to Pj then i < j. Let father(i) denote the pack father of Pi in this directed tree (undefined for P1).

Function completeDP (⟨C1,..., Cm⟩)

for i → m to 2 do	{from the leaves to the root}
Ci → completeQPi (Ci)
if Ci = ⊥QPi then return ⊥DP
Cfather(i) → Cfather(i) ∪ πPfather(i) (Ci)
C1 → completeQP1 (C1)
if C1 = ⊥QP1 then return ⊥DP
for i → 2 to m do	{from the root to the leaves}
Ci → Ci ∪ πPi (Cfather(i))
Ci → completeQPi (Ci)
if Ci = ⊥QPi then return ⊥DP
return ⟨C1,..., Cm⟩

Correctness
On one hand, Theorem 4.4 shows that completing packs back and forth only once is enough to ensure saturation. Any further completeQPi on a pack will have no effect. This is why we chose a tree-shaped relation graph.
On the other hand, for all C ∈ DP , completeDP (C) ≡ C. This holds at every step of the algorithm: this is obvious for completeQPi steps; union steps do not change the concretization of a value since the union is made with constraints already present in the value; and checks for ⊥ only make implicit ⊥ explicit.

Complexity
Let Ap denote the cost of completing a pack of size ≤ p and Bp,f denote the cost of the projection and union of a pack of size ≤ p on a pack of size ≤ p, with a frontier of size ≤ f .
The cost Cp,f of the completion algorithm is bounded by:
m	m
A|P1| +2 Σ A|Pi| +2 Σ Bmax(|Pi|,|Pfather(i)|),|Pi∩Pfather(i)| ≤ 2m(Ap + Bp,f )
For a bounded pack size, our completion algorithm has a linear complexity in the number of variables, whatever the underlying domain is. If the underlying domain owns an incremental completion [10], it can be used to replace the global

completion in the second loop. The algorithm will be faster but its complexity remains unchanged.

Abstract Operators
In this section we provide domain operations needed by abstract interpretation. Generally, operators on DP will be easily defined from operators on Ð. However, for operators on Ð, each time a completion is needed, our completion will actually have to be used.

Operators on sets
In this section, operator arguments will be considered completed.
Inclusion and equality tests are pointwise on complete arguments. If they are exact on Ð then they are exact on DP too.
Intersection being exact (it is a constraint union), it is extented pointwisely on each pack and remains exact.
If HQ is the best abstraction of union in Ð then HDP , pointwise extension of HQ
on each pack of P , is the best abstraction of union in DP .
The forget operator is a projection on a space not containing some given variables.
From a complete value, just remove all constraints involving these variables.

Widenings, Narrowings
Widenings of the underlying domain can be applied to each pack independently. Convergence of increasing chains in finite time is immediately ensured. However so formed values can be uncoherent or incomplete. But trying to make them coherent or complete can jeopardize converge [13]. Indeed widening relaxes constraints towards
+∞ whereas completion has an opposite goal, the same applies to coherence because
it is obtained by intersection.
Similarily, narrowings of the underlying domain can be applied to each pack independently.

Constraint Extraction and Addition
We also provide two operations that are useful to build abstract interpretation-based analysis tools and that cannot be pointwisely extended from the underlying domain.

Constraint Extraction
Let ⟨C1,..., Cm⟩ denote a complete value. Suppose that we want to extract the set of constraints existing between variables from a set F ⊆ u, 1 ≤ |F| ≤ N . If all these variables are in the same pack (e.g., |F | = 1 for interval extraction) then a simple projection is sufficient. Otherwise, things are more complicated. For each

pack Pi, let F	d=ef F ∩ Pi, and suppose that F	/= ∅.

Function extractDP (⟨C1,..., Cm⟩ , F )

V1..m →∅ 
D1..m →∅ 
for i → m to 2 do
Vi → Vi ∪ F(i)
if Vi /= ∅ then
Vfather(i) → Vfather(i) ∪ Vi
Dfather(i) → Dfather(i) ∪ πV ∪(P ∩P	)(completeQ(Pi∪Vi) (Ci ∪ Di))
return πF (completeQ(P1∪X ) (C1 ∪ D1))
This function has a cost bounded by Dp,f = m(Ap+|F| + B(p+|F|),(f+|F|)). For a bounded pack size and a bounded number of variables of interest, this function has a linear complexity in the total number of variables. If |F | = 2, its cost can even
be bounded by Dj	= d(Ap+2 + B(p+2),(f+2)), which is linear in the diameter of the
pack tree.


Adding Constraints
Given a complete value ⟨C1,..., Cm⟩, suppose that we want to add new con- straints C+. If all the variables of the constraints to add are in a single pack then we can add the constraints to this pack only. Otherwise, we need to extract from C+ other constraints that can be independently added to the packs, precisely all constraints that we can get from C+ expressible in freeKsQ. We keep the same notations, but now F = vars(C+).

Function addDP (⟨C1,..., Cm⟩ , C+) V1..m →∅ 
D1..m →∅ 
for i → m to 2 do
Vi → Vi ∪ F(i)
if Vi /= ∅ then
Vi → Vi ∪ (Pi ∩ Pfather(i)) Vfather(i) → Vfather(i) ∪ Vi
Dfather(i) → Dfather(i) ∪ πV (completeQ(Pi∪Vi) (Ci ∪ Di)) D0 → πV (completeQ(P1∪V1) (C1 ∪ D1 ∪ C+))
for i → 1 to m do
if Vi /= ∅ then Ci → Ci ∪ πPi (D0)
return ⟨C1,..., Cm⟩
This function has a worst-case cost bounded by Ep,f = m(AN′ + BN′,N ′ ) where
Nj = min(N, mf + p + |F |). If |F | = 2 then this cost is generally linear in the
diameter of the graph and is bounded by Ej	= d(Adf+p + Bdf+p).  Therefore,
adding constraints between distant variables should be avoided as much as possible.

Conclusion and Future Work
This paper has introduced TreeKs, a functor to make numerical abstract domain scalable, by restraining the relation graph to a specific shape allowing efficient algo- rithms for completion and abstract operations.
Like related work [1,17,5], it relies on packs of variables. Whereas they did not share relational information in previous work, it is made possible with TreeKs whilst retaining scalable.
Implementations are warmly welcome and comparisons with existing domains would be interesting. Theoretically, the domain obtained by applying TreeKs lies, for both precision and cost, between packs with only non-relational sharing and the underlying domain itself.
This paper does not describe how to generate packs. Astree [1,5] uses a syn-
tactic criterion whereas C Global Surveyor [17] build them dynamically. Different software systems may require different packing strategies and coming to a decision will demand experimental comparisons.
Extensions for domains like pentagons and weighted hexagons, or generally any convex domain (e.g., ellipsoids [7]), seem conceivable with a more general framework. However it is unclear how TreeKs could efficiently be applied to non-convex domains.

References
B. Blanchet, P. Cousot, R. Cousot, J. Feret, L. Mauborgne, A. Miné, D. Monniaux, and X. Rival. A static analyzer for large safety-critical software. In PLDI’03, pages 196–207. ACM Press, June 2003.
R. Clarisó and J. Cortadella. The octahedron abstract domain. Science of Computer Programming, 64(1):115–139, 2007.
P. Cousot and R. Cousot. Static determination of dynamic properties of programs. In Proc. 2nd Int. Symp. on Programming, pages 106–130, Paris, 1976. Dunod.
P. Cousot and R. Cousot. Abstract interpretation: a unified lattice model for static analysis of programs
by construction or approximation of fixpoints. In 4th POPL, pages 238–252, Los Angeles, 1977. ACM Press, New York.
P. Cousot, R. Cousot, J. Feret, L. Mauborgne, A. Miné, and X. Rival. Why does Astrée scale up?
Formal Methods in System Design, 35(3):229–264, 2009.
P. Cousot and N. Halbwachs. Automatic discovery of linear restraints among variables of a program. In 5th POPL, pages 84–97, Tucson, 1978. ACM Press, NY.
J. Feret. Numerical abstract domains for digital filters. In International workshop on Numerical & Symbolic Abstract Domains, 2005.
J. Fulara, K. Durnoga, K. Jakubczyk, and A. Schubert. Relational abstract domain of weighted hexagons. Electronic Notes in Theoretical Computer Science, 267(1):59–72, 2010.
J. Howe and A. King. Logahedra: A new weakly relational domain. Automated Technology for Veriﬁcation and Analysis, pages 306–320, 2009.
J.M. Howe and A. King. Closure Algorithms for Domains with Two Variables per Inequality. Technical report, School of Informatics, City University London, 2009.
F. Logozzo and M. Fähndrich. Pentagons: A weakly relational abstract domain for the eﬃcient validation of array accesses. In Proceedings of the 2008 ACM symposium on Applied computing, pages 184–188, 2008.
A. Miné. A new numerical abstract domain based on difference-bound matrices. In Proc. of the PADO II, LNCS vol. 2053, pages 155–172, Aarhus, 2001. Springer.

A. Miné. The octagon abstract domain. Higher-Order and Symbolic Computation, 19(1):31–100, 2006.
S. Sankaranarayanan, H.B. Sipma, and Z. Manna.	Scalable analysis of linear systems using mathematical programming. In VMCAI, pages 25–41. Springer, 2005.
A. Schrijver. Theory of linear and integer programming. John Wiley & Sons Inc, 1998.
A. Simon, A. King, and J. Howe. Two variables per linear inequality as an abstract domain. LOPSTR, pages 955–955, 2003.
A. Venet and G. Brat. Precise and eﬃcient static array bound checking for large embedded C programs. In PLDI’04, pages 231–242, Washington, 2004. ACM Press.
