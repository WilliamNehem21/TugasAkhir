 Electronic Notes in Theoretical Computer Science 96 (2004) 91–112  
www.elsevier.com/locate/entcs




Expressive Power of Hybrid Systems with Variables, Parameters and Arrays
Ruggero Lanotte 1 ,2
Dipartimento di Informatica, Universita` di Pisa, via Buonarroti 2, 56127, Pisa, Italy

Abstract
A hybrid system consists of a finite number of locations, variables and transitions. Different classes are considered in the literature. In this paper we study the different expressive power of these classes.
Keywords: Hybrid systems, Expressiveness, Arrays, Parameters, Real and Integer variables


Introduction
Often the systems one wants to model are control systems embedded in an environment from which stimuli may come with different laws. As an example, sensors controlling temperature or water level may have a non-linear evolution law. Hybrid Systems have been introduced to describe similar situations (see [1] and [2]). A hybrid system consists of a finite number of locations, variables and transitions. In each location variables change their value as a function of the time elapsed, and satisfy, at each instant, a formula called the invariant. The system can take a transition to evolve from a location to another location. The transition is labeled with a formula that gives the values of variables triggering the transition and their new values after the transition has been performed. Different variants of this model have been considered. Classes are

1 Research partially supported by MIUR Progetto Cofinanziato MEFISTO.
2 Email: lanotte@di.unipi.it


1571-0661 © 2004 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2004.04.023

usually distinguished by the mathematical logic which is used to model the system.
We consider the extension of the formalism proposed in [8] and [9] by introducing integers and arrays with infinite elements (which permits to model data structures with fixed, infinite and parametrized length).
Firstly, we recall the classes of Linear Real Hybrid Systems (see [10]), Polynomial Real Hybrid Systems (see [6]), Linear Mixed Hybrid Systems (see [9]), Parametric Real Hybrid Systems (see [8]), D-Hybrid Systems (see [9]) and S-Hybrid Systems (see [9]).
For the classical classes of Linear Real Hybrid Systems and Polynomial Real Hybrid Systems there exists an algorithm based on predicate transfor- mation which permits to have a symbolic model checking, and to have semide- cidability of reachability (which is implied by the decidability of satisfiability of the formulae used).
In [8] and [9] it is proved that the same result holds also for the non clas- sical classes. Now the question we answer in this paper is whether the classes introduced in [8] and [9] are effectively an extension of the classical ones, namely we prove expressiveness results. We show that the class of Parametric Real Hybrid Systems is a subset of the class of Polynomial Real Hybrid Sys- tems, but it extends the class of Linear Real Hybrid Systems. We prove that the class of Polynomial Real Hybrid Systems is the most expressive among the classical classes, but the class of D-Hybrid Systems extends it. Moreover, the classes of S-Hybrid Systems and Linear Mixed Hybrid Systems extend the classical class of Linear Real Hybrid Systems and include cases which can- not be described by D-Hybrid Systems and hence by Polynomial Real Hybrid Systems.

The formalism
In this section we recall the formalism of Hybrid Systems with identifiers.

Vectors of identiﬁers and valuations
Let A be a set; a vector −→s over A is a tuple (s1,... , sn) with s1,... , sn ∈ A. We say that s is in −→s , written s ∈ −→s , iff s = si for some 1 ≤ i ≤ n.
Let s1 = (s1,... , s1 ) and −→s2 = (s2,... , s2 ) be two vectors; with −→s1  −→s2
we denote the vector (s1,... , s1 , s2,... , s2 ).
1	n	1	m
In the following, names for parameters, real variables, integer variables
and arrays are referred to as identiﬁers. A parameter is a real variable that does not change its value during the execution. An array is a function from

integers to reals. This definition permits to avoid “index out of bounds” errors and to have arrays with parametric length. Given identifiers id1,... , idn,
−→id = (id1,... , idn) is a vector of identiﬁers, provided that id1,... , idn are
pairwise different, and a valuation over −→id is a vector −→v = (v1,... , vn) where,
for each 1 ≤ i ≤ n:
if idi is either a real variable or a parameter, then vi ∈ R
if idi is an integer variable then vi ∈ Z
if idi is an array then vi : Z → R is a function from integers to reals. The set of valuations over −→id is denoted with V (−→id).
We shall use x, y,... to denote real variables, h, k,... to denote integer variables, a, b,... to denote arrays and m, n,... to denote parameters.
With −→id' = (id'1,... , id'n) we denote the vector of identifiers marked by ·',
where id'i represents the new value that idi can take, for instance, due to an assignment.




Quantiﬁed formulae
Let −→id be a vector of identifiers; we define the set	(−→id ) of polynomial terms
over −→id as follows:

τ ::= c | c · id | c · a[τ1] | τ1 + τ2 | τ1 · τ2

where τ, τ1, τ2 ∈ P(−→id ), c ∈ Q, id ∈ −→id is not an array and a ∈ −→id is an array. A polynomial term is a linear term if it is constructed without operation τ1 · τ2. As an example, if x and y are real variables, a is an array and k is an integer variable, (9 + k · y · x) · ( 2 · y)+ a[k]2 · y is a polynomial term in the set P((x, y, a, k)). The polynomial term 9 + 2 · k + a[k + 3] is also a linear term. A polynomial term τ is an integer term iff each constant c in τ is an integer
and each identifier id in −→id is an integer variable. As an example, the term
h2 k + 10 is an integer term over the vector of integer variables (h, k). In the following we suppose that for each a[τ ] appearing in a term, τ is an integer term. We shall show that this choice does not cause loss of generality.

A valuation −→v = (v1,... , vn) over −→id extends to P(−→id ) as follows:

−→v (c) = c
−→v (c · id) = c · vi, if id = idi
−→v (c · a[τ ]) = c · vi(−→v (τ )), if a = idi
−→v (τ1 + τ2) = −→v (τ1)+ −→v (τ2)
−→v (τ1 · τ2) = −→v (τ1) · −→v (τ2).


Let −→id be a vector of identifiers; we define the set Φ(−→id ) of quantiﬁed formulae over −→id as follows:

φ ::= τ ∼ 0 | ∃id . φ' | ¬φ1 | φ1 ∨ φ2 | φ1 ∧ φ2

where φ, φ1, φ2 range over Φ(−→id ), τ is in P(−→id ), ∼∈ {<, ≤, =, ≥, >}, id /∈ −→id , and φ'	Φ( id	(id)). Notice that the identifier id that can appear in the
scope of quantifier	is not in −→id . Notice also that Φ(−→id ) is a subset of High
Order Logic, since the arrays (which are functions) can be quantified.
A formula in Φ(−→id ) is linear iff all terms τ ∈ P(−→id ) appearing in φ are linear. Sometimes we will write ∃−→id.φ for ∃id1 ... ∃idn . φ, where −→id = (id1,... , idn), and ∀id.φ for ¬∃id.¬φ.
To express a term a[τ ] with τ a non integer term, we can introduce an integer variable k and force k = τ . As an example, a[x · y] = 5 can be expressed by ∃k. a[k] = 5 ∧ k = x · y. The following example shows some
properties over arrays that can be expressed in Φ(id ).

Example 2.1 The following properties over arrays can be expressed in Φ(−→id ):
Equality of arrays: ∀h ∈ [1, size]. a[h]= b[h]
Membership of a value x: ∃k. a[k]= x
k is the index of the minimum: ∀h ∈ [1, size]. a[h] ≥ a[k]
Binary array: ∀h. a[h]=0 ∨ a[h]= 1
Ordering: ∀h ∈ [1, size − 1]. a[h] ≤ a[h + 1].

Let φ ∈ Φ(−→id ) and −→v ∈ V (−→id); we say that −→v satisﬁes φ, written −→v |= φ, iff
−→v |= τ ∼ 0	iff −→v (τ ) ∼ 0
−→v |= ∃id.φ'	iff there is some v' ∈ V (id) such that −→v  (v') |= φ'
−→v |= ¬φ1	iff −→v /|= φ1
−→v |= φ1 ∨ φ2 iff either −→v |= φ1 or −→v |= φ2
−→v |= φ1 ∧ φ2 iff both −→v |= φ1 and −→v |= φ2.
Let τ1, τ2 ∈ P(−→id ) and φ ∈ Φ(−→id ); with φ[τ1 := τ2] we denote the formula obtained by replacing each occurrence in φ (also in subterms) of τ1 with τ2. Let a, b be arrays; φ[a := b] denotes the substitution φ[a[τ1] := b[τ1]] ... [a[τn] := b[τn]], where the array a occurs in φ with the terms a[τ1],... , a[τn].
Let φ be a formula in Φ(−→id ), and k be an integer variable; then k is depen-
dent in φ iff there exist φ1,... , φn ∈ Φ(−→id ) such that φ =  n	φi and for any
i  [1, n] there exists φ' such that φi  (k = τ ) φ', where τ is an integer term
and h does not appear in τ . These dependent variables are important in pro- gramming. In fact, if we have the assignment k := τ , with τ an integer term, then k is dependent. As an example, the assignment k := k2 + 1 is translated into the formula k' = k2+1. The term k2+1 is an integer term, and hence k' 9is dependent in k' = k2 +1. Moreover, h is dependent in the formula h ∈ [10, 20].
The satisfiability of a formula in Φ(−→id ) is, in general, undecidable. In [11], [8], [11], [12], [8] and [8], respectively, the satisfiability has been proved to be decidable for the following classes of Φ(−→id ):
The set ΦP (−→id) of polynomial real formulae, i.e. the set of the formulae using only real variables.
The set ΦP ar(−→id ) of parametric formulae linear on real variable, i.e. the set
of the formulae using only parameters and real variables, and terms of the form τ1 · x1 +·· ·+τn · xn +τn+1, where τi is a polynomial term on parameters.
The set ΦL(−→id) of linear real formulae, i.e. the set of linear formulae using
only real variables.
The set ΦMix(−→id ) of mixed linear formulae, i.e. the set of the linear formulae using only real and integer variables.
The set Φk (−→id ) of D-formulae free on k, with k	−→id an integer variable,
i.e. the set of the formulae φ such that k is not quantified in φ, and, for

each integer variable h /= k, it holds that if h ∈ −→id, then h is dependent in φ, and if h /∈ −→id , then for each subformula ∃h.φ' of φ it holds that h is dependent .
The set ΦS(−→id ) of S-formulae, i.e. the set of formulae obtained by repeated
applications of disjunction and conjunction of formulae of the form
∃i−→d1. φ1 ∧ ∀h.∃−→id 2.φ2 

such that h is an integer variable, φ1 and φ2 are linear formulae without any quantifier and, for each a[τ ] appearing in φ2, either τ = h or no identifiers in h  −→id2 appears in τ .
The set Φk (−→id) permits to express formulae in which integer variables (with the exception of at most the non-quantified integer variable k) are either dependent or bounded. The set ΦS(−→id) permits to express formulae that define constraints on identifiers and some kind of invariants for arrays.
Example 2.2 ∃z. 6 y2x + 3y · z > 0 is in ΦP ((x, y)), ∃k.3h + 4k + 5 y = x is in
ΦMix((y, h, x)), l. l	[1, 10]	h = k2 +1	l > x is a quantified formula in Φk (h, k, x), and in Example 2.1 only the ordering formula is not an S-Formula.

Hybrid systems with identiﬁers
A Hybrid System with Identiﬁers is a tuple H = Σ, →−id, Loc,T r, Act,Init,F , where:
Σ is a finite set of action symbols.
−→id is a vector of identiﬁers.
Loc is a finite set of locations. A state is a pair (l, −→v ) where l is a location and −→v is a valuation in V (−→id ).
Tr is a finite set of transitions. Each transition is a tuple ⟨l, a, φ, l'⟩, where l ∈ Loc is the source location, l' ∈ Loc is the target location, a ∈ Σ, and φ  Φ( id  id'), where id represents the value of the identifiers when the
transition fires and −→id ' represents the new values that are assigned to the
identifiers as effect of the transition firing.
Act : Loc  Φ(−→id (t) −→id') is the activity function that assigns to each location a formula, called activity, which expresses the relationship between the values of identifiers −→id when the location is entered and the new values
−→id ' taken by the identifiers after t units of time have elapsed.

Init = (l0, φ0), where l0	Loc is the initial location and φ0	Φ(−→id ) is the
initial condition that must be satisfied by the system at the beginning.
F ⊆ Loc is the set of final locations.
The set of Hybrid Systems with Identifiers is denoted Hid.
Example 2.3 In Fig. 1 we model a cache of a browser. A request rc to the cache to obtain a file f of a web page has either a positive answer ac, if the file is in the cache, or a negative answer nc, otherwise. In this last case, when the file f is downloaded from the network by the browser, it is cached together with the date d of his download (action sc). The file in the cache that is replaced by f is the eldest. The real variable d represents the date, the real variable x is used to quantify the answer time of the cache to a request. The real variable f represents the information on the file (name, location and contents). The array f ile represents the files f ile[1],... ,file[size] in the cache. The array date represents the date date[1],... , date[size] of the last requests to f ile[1],...,f ile[size]. The initial location W ait represents waiting for a request. The initial condition says that the date d is positive, x is equal to zero, and dates and file information are positive reals. After a request rc, the real variable f ' carries the information on the requested file, and the cache enters location Check. For readability, in each formula, we have omitted the subformula that expresses that each identifier that does not appear in the formula is not changed. As an example in the formula f '  0 we have omitted condition d' = d  x' = x  h  [1, size].f ile'[h] = f ile[h]  date'[h] = date[h]. Now, in location Check the cache looks for the file f . If f is cached (f ile[k]= f ), then the cache gives a positive answer ac in a time enclosed in [2, 5], updates the date (date'[k] = d), and returns to location W ait. If the file is not cached ( h  [1, size] .file[h] = f ), a negative answer nc is given in a time enclosed in [2, 5], and the cache enters location W rite, where it is ready to cache the file. When the page is downloaded (action sc), the file f is cached (f ile'[k]= f ) in the position k of the eldest referred file.
Let us explain now the semantics of  id. Let H be a system in  id, and let (l, −→v ) be a state. The system can evolve from (l, −→v ) to another state by performing either an activity step or a transition step, as defined below:
an activity step describes the evolution of H due to being in location l and passing of time. In t units of time, the activity Act(l) takes H to a new valuation −→v ':
t ≥ 0 −→v  (t) −→v ' |= Act(l) (l, −→v ) →t (l, −→v ')
a transition step describes the evolution of H due to the firing of a transition.


d ≥ 0 ∧ x =0 ∧ ∀h ∈ [1, size] . date[h] ≥ 0 ∧ file[h] ≥ 0
,v
Wait
'
d = d + t
 <J
rc
sc	f ' ≥ 0	ac

∃k ∈ [1, size] .x ∈ [2, 5]
'
file [k]= f ∧
'dat [k]= d∧
∀h ∈ [1, size] . date[h] ≥ date[k]
,v
Check
'
d = d + t
'x = x + t
 x ∈ [2, 5] ∧ x = 0∧
∃k ∈ [1, size] .
'file[k]= f ∧ dat [k]= d

 nc J
'
x ∈ [2, 5] ∧ x = 0∧
,v∀h ∈ [1, size] .file[h] /= f Write
'
d = d + t
 J

Fig. 1. The cache of a browser
The formula φ of the transition must be satisfied by the valuation −→v , and the transition takes H to the target location l' of the transition and to a new valuation −→v ' according to φ. More precisely:
e = ⟨l, a, φ, l'⟩∈ Tr  −→v  −→v ' |= φ
(l, →−v ) →e (l', −→v ')
A run r of H is a sequence of steps

(l0, −→v 1) →t
(l0, −→v 2) →e
(l1, −→v 1) →t
(l1, −→v 2) ... (ln−1, −→v 2
) →e
(ln, −→v 1 )

where l0 is the initial location and ln is a final location, −→v 1 satisfies the initial condition φ0, and, for all 0 ≤ i ≤ n, ti is a time and ei = ⟨li, ai, φi, li+1⟩ is a transition. With tw(r) we denote the sequence (t0, a0)(t1, a1) ... (tn, an). The language accepted by H (denoted by L(H)) is the set {tw(r) | r is a run of H}.

Subclasses
Let us consider now several subclasses of Hid. Let H = ⟨Σ, −→id, Loc, T r, Act, Init⟩.
H is in the class P (resp. P ar, L and Mix) of Polynomial Real Hybrid Systems (resp. Parametric Real Hybrid Systems, Linear Real Hybrid Sys- tems and Linear Mixed Hybrid Systems) if all formulae in H are polynomial real formulae (resp. parametric linear formulae on real variables, linear real formulae and mixed linear formulae).

H is in the class Hk
of D-Hybrid Systems Free on k if the formula in Init

, , 
input

l1
x = 1 


true	
l2
t ∈ [4, 5]
mul, y' = y + n ∧ y' ≤ x2


h = 0∧
 J J
mul

∀l ∈ [0, 127].
a[l]=1 ∨ a[l]= 0
'	2
x = x
— y ∧ y + n > x2

,	, 

l3
t ∈ [4, 5]
	)
eq1, a[h]=1 
l4
t ∈ [4, 5]

 J	 Jmul,	'

eq0
,va[h] = 0
'
y = y + n ∧ y ≤ x · m

l5
t ∈ [4, 5]
mul,x = x · m − y ∧ y + n > x · m

 succJ
'
h = h +1 
check ,v	, 

h ≤ 127
l6
t ∈ [4, 5]
	)
output
l7 true

 J	 J
Fig. 2. RSA algorithm
is a D-formula free on k and all other formulae in H are D-formulae free on
k'.
H is in the class HS of S-Hybrid Systems if all formulae in H are S-Formulae. The class HMix permits to use both integer and real variables, provided that
the formulae are linear. The classes Hk and HS permit to use also arrays.
Example 2.4 In Fig. 2 we model with a system in Hn  the cryptographic
algorithm RSA for smart cards (see [3]). The array a represents the 128 bits of a key. The real variables x and y and the integer variable h are auxiliary variables. The encryption of a message m with both a public key n and a secret key k consists in computing mkmod n. The algorithm is the following:
x=1
for h = 0 to 127
{x = (x*x) mod n
If a[h] = 1 then x = (x*m) mod n} Return x
We assume Montgomery multiplication is used, for which a time in [4, 5] that does not depend on input is spent. The system computes x = (x ∗ x) mod n in location l2 and x = (x ∗ m) mod n in location l4. Moreover, the system checks whether a[h] = 1 or a[h] = 0 in location l3 and whether h ≤ 127 in location l6.

Example 2.5 The system of Example 2.3 is in HS.
Properties
In the previous section we have recalled the classes described in [6], [1], [8] and [9]. In this section we recall the properties of these classes described in the same papers. More precisely, for each subclass of id considered it is possible to define a notion of symbolic representation and therefore it holds that reachability is semidecidable. Another interesting result of closure binds the classes of HP ar and HL.
The set of states and steps of a system H	id is infinite. Therefore, we need a symbolic finite representation to enumerate all reachable states, so that the problem of reachability of states becomes semidecidable.
A region of H is a pair (l, φ), where l is a location and φ is in Φ(−→id ). The
region represents the set of all states (l, →−v ) such that −→v = φ.
For a region (l, φ), we define the successor formulae over identifiers [φ]† and posteφ, which hold after any activity step and after a transition step through transition e = ⟨l, a, φ', l'⟩ is performed. Formally:
[φ]† ≡  ∃−→id . ∃ t ≥ 0 .(φ ∧ Act(l)) [−→id' := −→id ]
posteφ ≡  ∃−→id . (φ ∧ φ')  [−→id' := −→id ].
The following proposition is proved in [9] and states the correctness of the operators [ ]† and poste
Proposition 2.6 Let (l, φ) be a region, −→v ' be a valuation and e be the tran- sition ⟨l, a, φ', l'⟩. Then the following facts hold:
−→v ' |= [φ]† iff there are a valuation −→v with v |= φ and some c ∈ R≥0 such that (l, −→v ) →c (l, →−v ')
−→v ' = posteφ iff there is a valuation −→v with −→v = φ such that (l, −→v )	e
(l', v ').
Let us recall now the form of the regions of the subclasses of Hid.
If H is in L (resp.  P ar, P and Mix) then a linear real region (resp. linear real region, parametric real region, polynomial real region and linear mixed region) is a pair (l, φ), where l is a location and φ is in ΦL(−→id ) (resp. ΦP ar(−→id), ΦP (−→id) and ΦMix(−→id)).
If H is in Hk then a D-region free on k is a pair (l, φ), where l is a location
and φ is in Φk (−→id ).

If H is in	then a S-region is a pair (l, φ), where l is a location and φ is in ΦS(−→id ).
A class of regions R is closed w.r.t. the successor formulae iff, given any region (l, φ) in R and any transition e = ⟨l, a, φ', l'⟩, it holds that also (l, [φ]†)
and (l', posteφ) are in R.
The closure of regions w.r.t. successor formulae for the classes	P and	L
has been proved in [6] and [1], respectively. The closure of regions w.r.t.
successor formulae for the classes HP ar, HMix, Hk  and HS is proved in [8]
and [9].
Since the satisfiability of the different classes of formulae used is decidable it is obvious that the reachability problem is semidecidable.
An interesting result proved in [8] is that if a region (l, φ) is reachable by an H  P ar with parameters in −→m, and −→u is a rational instance in V (−→m), then, if we instantiate the parameters in −→m  with the values in −→u in both H and (l, φ), we have that (l, φ[−→m := −→u ]) is a reachable region for the Linear Real Hybrid System H[−→m := −→u ].
Therefore, in the class of  P ar it is allowed to use parameters as rates of
real variables or coefficients of linear formulae. This is not allowed in the class of  L. By the result proved in [8], if one wants to calculate for which rates or coefficients a Linear Real Hybrid System satisfies a given property, it is sufficient to calculate the set of rational instances for which the Parametric Real Hybrid System which satisfies it.

Expressiveness
In the previous section we have recalled some interesting subclasses of id and we have shown how the new classes introduced in [8] and [9] are suitable to model real-life systems while preserving the same properties of the classical ones.
Now, we address the question whether these new classes really extend the classical ones. Therefore, in this section we will study the expressive power of Hybrid Systems with respect to the language accepted.
First of all, in the following proposition, we summarize containments which are trivial.
Proposition 3.1 The following relations hold:
L(Hid) ⊇ L(H'), where H' is one of the subclasses mentioned above;
L(H  ) ⊇ L(HP ) ⊇ L(HP ar) ⊇ L(HL);
L(HS) ⊇ L(HMix) ⊇ L(HL).

To prove expressiveness results we use the following languages:
L1 = {(a, c1)(a, c2) | c1, c2 ∈ N}
L2 = {(a, t) | t is an odd natural}
L3 = {(a, t)(b, t') | t' = t2 and t ∈ R≥0}
L4 = ∪n∈N{(a, t1)(b, t'1) ... (a, tn)(b, t'n) | ti ∈ R≥0 and t'i = t2,
for any 1 ≤ i ≤ n, }
L5 = ∪n∈N{(a, t1)(a, t2) ... (a, tn)(b, t'1) ... (b, t'n) | ti ∈ R≥0 and ti = t'i,
for any 1 ≤ i ≤ n}
L6 = ∪n∈N{(a, t1)(a, t2) ... (a, tn)(b, t'1) ... (b, t'n) | ti ∈ R≥0 and t'i = (ti)2, for any 1 ≤ i ≤ n}
L7 = ∪n∈N{(a, t1)(a, t2) ... (a, tn)(b, t'1) ... (b, t'n) | t'i = ti and ti ∈ N,
for any 1 ≤ i ≤ n}
L8 = ∪n∈N{(a, t)(b, t2)(c, t1) ... (c, tn) | t ∈ R≥0 and t1,... , tn ∈ N}.
Why we gain power by using integer variables? The idea is that with a step we cannot simulate an infinite set of natural numbers. In the following proposition we prove that integer variables give more expressiveness to HMix
with respect to HL.  Moreover, since Hk  may have only one free integer
variable, which is not sufficient to model two or more integer variables, we prove that there exists a language recognized by an S-Hybrid System and not by a D-Hybrid system.
Proposition 3.2 The language L1 is in L(HMix) and L(HS) but is neither in L(Hk ) nor in L(HL).
Moreover, in the following proposition, we prove that the intersection of (  Mix) and	( D) is a set greater than	(  L). It means that	L is not
able to simulate one integer variable.
Proposition 3.3 The language L2 is in L(HMix) ∩ L(Hk ) but is not in
L(HL). Therefore L(HMix) ∩ L(HD) ⊃ L(HL).
We consider now the expressive power of polynomial formulae. In the fol- lowing proposition we prove that polynomial formulae give more expressive- ness to Hybrid Systems. So, parameters of HP ar permit to express languages not accepted by Hybrid Systems in HL. But, since parameters do not change their value, there exists a language recognized by HP and not by HP ar.
Proposition 3.4 The language L3 is in L(HP ar) and is neither in L(HMix)
nor in L(HS). Moreover, the language L4 is in L(HP ) but i not in L(HP ar).
The previous proposition implies that polynomial formulae used in Hk

cannot be simulated by linear formulae of HS.
Corollary 3.5 L3 is in L(Hk ) but is not in L(HS).
Finally, we consider the power gained with arrays. In the following propo- sition we prove that arrays give memory to Hybrid Systems, which therefore gain in expressive power. This gain of expressivity is obvious since we have considered arrays with infinite length, but, in the proposition, we prove that to gain expressive power it is sufficient to have arrays with finite parametric length.
Therefore the class of HS is more expressive than the class of HMix. More- over, if we consider the intersection of	( S) with	(	) the power of arrays permits to prove that there exists a language in the intersection but not in ( Mix). As an example, the length of the cache of Example 1 is not fixed and is expressed with a generic value for the integer variable size. This defi- nition means that the cache is finite but we do not make any assumption on the value of its length. This cannot be simulated without arrays with infinite
length.
Proposition 3.6 The language L5 is in L(Hk )∩L(HS) but is not in L(HP )∪
L(HMix).
In the following proposition we prove that the polynomial formulae on
arrays of the class Hk  permit to express languages not recognized by both
HP and HS. Moreover, the formulae with integer variables and arrays of HS
permit to show that there exists a language accepted by HS but not accepted
by both Hk and HMix.
Proposition 3.7 The language L6 is in L(Hk ) but is not in L(HP ) ∪L(HS). Moreover, the language L7 is in L(HS) but is not in L(HMix) ∪ L(Hk ).
Finally we prove that the class of Hid is the most expressive of those considered. In fact we show that there exists a language recognized by Hid
and not recognized by both Hk and HS.
Proposition 3.8 the language L8 is in L(Hid) but is not in L(Hk ) ∪ L(HS).
The previous results imply the following theorem.
Theorem 3.9 The classiﬁcation of expressiveness of languages and the Hy- brid Systems memberships described in ﬁgure 3 hold.


L8	L5	L1
L4
,

L(Hid )

,
L(Hk )

,
 
,	L (HS )

D,	 
, ,

L(HP )  L(HPar )
  
L(HL)
  J

JJL(HMix)

	J   J
	J

J


L3
L6	L2	L7
Fig. 3. The classes.
Conclusions and future works
In [8] and [9] the symbolic model checking for linear and polynomial hybrid systems is extended for classes which consider arrays, integer variables and polynomial formulae.
Therefore, in this paper we have studied expressiveness results for hybrid systems so extended. We have shown that arrays, integer variables and poly- nomial formulae build an hierarchical expressivity in the framework of hybrid systems. We have proved that the class of HP is the most expressive among
the known classes. But the new class of Hk  extends it. Moreover, the new
classes of HS and HMix extend the classical class of HL and consider cases
which cannot be recognized by Hk and so by HP .
As a future work we consider to tackle the problem of succinctness of the different classes.

References
R. Alur, C. Courcoubetis, N. Halbwachs, T.A˜. Henzinger, P.H˜. Ho, X. Nicollin, A. Olivero,
J. Sifakis, and S. Yovine. The algorithmic analysis of hybrid systems. Theoretical Computer Science, 138:3–34, 1995.
R. Alur, T.A˜. Henzinger, and P.H˜. Ho. Automatic symbolic verification of embedded systems.
IEEE Transactions on Software Engineering, 22:181–201, 1996.
CASCADE.	Chip architecture for smart cards and portable intellident devices. http://www.dice.ucl.ac.be/crypto/cascade.

L. N. Childs. A Concrete Introduction to Higher Algebra. Springer, 1979.
K. Ferrante and C. Rackoff. A decision procedure for first-order theory of real addition with order. SIAM Journal on Computing, 4:69–76, 1975.
M. Fra¨nzle. Analysis of hybrid systems: An ounce of realism can save an infinity of states. In Computer Science Logic, number 1683 in Lecture Notes in Computer Science, pages 126–140, Berlin, 1999. Springer.
B.E. Herbert. Mathematical Introduction to Logic. Academic Press, 1972.
R. Lanotte. An Automaton-Theoretic Approach to Safety and Security in Real-Time Systems. PhD thesis, University of Pisa, Pisa, Italy, 2002.
R. Lanotte, A. Maggiolo-Schettini, and S. Tini. Information flow in hybrid systems. Submitted, 2003.
A. Pnueli and J. Sifakis. Special issue on hybrid systems. Theoretical Computer Science, 138, 1995.
A. Tarski. A decision method for elementary algebra and geometry. Technical report, University of California, Berkeley, California, 1951.
V. Weispfenning. Mixed real-integer linear quantifier elimination. In ACM International Symposium on Symbolic and Algebraic Computation, pages 129–136. ACM Press, 1999.

, a,
' , a,
' , 

l1
)
x =0	'
∃h.x = h ∧ x =0 
l2
	) '
∃h.x = h ∧ x =0 
l3
	) '

x = x + t
 J
x = x + t
 J
x = x + t
 J

Fig. 4. The Hybrid System H1.
Appendix
Quantifier elimination
Before proving the propositions we give the notion of quantifier elimination and the related results. Let ∃id.φ be a formula such that in φ there is no quantified identifiers. With Del(id, ∃id.φ) we denote the formula without quantified identifier equivalent to ∃id.φ.
We enumerate some properties of Del proved in [11], [5] [12] and [8]. If
φ is a formula without quantifiers, then:
If φ is in ΦL(−→id ) (resp. ΦP ar(−→id), ΦP (−→id) and Φk (−→id)) and x is a real variable, then Del(x, ∃x.φ) is in ΦL(−→id ) (resp. ΦP ar(−→id), ΦP (−→id ) and
D
If φ is in Φk (−→id ) (resp. ΦS(−→id )) and a is an array, then Del(a, ∃a.φ) is
D
If φ is in Φk (−→id ) and h is either a bounded or a dependent integer variable, then Del(h, ∃h.φ) is in Φ (−→id).
Proof of Proposition 3.1
The only non-immediate containment is L(HS) ⊇ L(HMix). But, by results in [12], we can transform a formula in ΦMix(id ) into a formula without quantifiers and which uses the relation n and the operator [τ ]. We can delete these by using the following equivalences
¬(τ ≡n 0) is equal to  n−1 τ + i ≡n 0 (see [7]);
τ ≡n 0 is equivalent to ∃k.τ = n · k;
τ1 + c · [τ2] ∼ 0 is equivalent to ∃k.τ1 + c · k ∼ 0 ∧ k ∈ (τ2 − 1, τ2]. Therefore, each formula in ΦMix(−→id) is equivalent to a formula of the form
−→k .φ', where −→k is a vector of integers and φ' is formula without quantifiers.
But this formula is also an S-Formula.	 

Proof of Proposition 3.2
Let H1 be the Hybrid System in figure 4 with l3 as final location. The system
H1 is both in HMix and HS. The language L(H1) is equal to L1. We prove

,	, 

l1
x =0 ) '
a,x = 2h +1	l2
		'

x = x + t
 J
x = x + t
 J

Fig. 5. The Hybrid System H2.

that L1 is not accepted by any HL and Hk . Let us suppose, by contradiction,
that there exists a H1' in HL such that L(H1' )= L1. Let (l1' , φ0) be its initial
condition. So, for each (a, c1)(a, c2) ∈ L1 there exists a run (l1' , −→v 1) →c1
(l1' , −→v 2) →e1 (l2' , →−v 3) →c2 (l2' , −→v 4) →e2 (l3' , →−v 5).
The times c1 and values −→v 2 of real variables which are admissible after the first activity step is the valuation that satisfies the formula −→x .φ0 Act(l' ), where −→x is the vector of identifiers of H1' (see proposition 2.6). By using Del we have an equivalent linear real formula φ' without quantifiers such that,
by renaming the real variables −→x ' with −→x , we have that φ'[−→x ' := −→x ] ∈

Φ((t)  −→x ).
Now, the times c1 and values
−→v 3 of real variables which are admissible after

the transition step is the valuation which satisfies the formula ∃−→x .φ'[−→x ' :=
−→x ] ∧ φ, where φ is the formula which labels the transition taken to perform
the first transition step.
Therefore the set of the first admissible times is the set of valuations which satisfy −→x '. −→x .φ'[−→x ' := −→x ] φ (see proposition 2.6). By using Del we have an equivalent linear real formula on t without quantifiers. So admissible times c1 are in a finite union of intervals on reals. It is obvious that with a finite set of intervals on reals we cannot express the set of naturals. So we have proved
that L(HMix) /⊆ L(HL).
Now we must prove that L1 is not recognized by any Hk . This proof can be done by contradiction. By mimicking the proof done for HL and by using Del on arrays and on integer and real variables, we have that the times t1 and
t2 of the two activity steps which can be taken by a Hk  are the valuations
which satisfy a formula φ of the form ∃k.φ', where φ' is a D-formula free on k
without quantifiers with real variables in (t1, t2, k).
Now φ) is equal to the set N	N. The set  k. t2.φ') gives the times taken in the first activity step. By using Del we have an equivalent formula

∃k.φ''.
The set ∃k.φ'') is equal to
 n∈N φ''[k := n]). By using Sturm’s algorithm

(see [4]), we can transform φ''[k := n] into a finite union of intervals on reals.
Let p1 be the maximum degree of t1 in φ'' and p2 be the size of φ''. Sturm’s algorithm transforms φ''[k := n] into a number of intervals less or equal to pp2 . In fact each τ  0 becomes an union of at most p1 intervals. The union and the intersection of p1 repeated p2 times generate at most pp2 intervals.

Let p1 = pp2 ; since the times must be naturals it means that the integers expressed by the formula φ''[k := n] are less or equal to p1. But p1 does not depend on n, and so we can conclude that for each n the integers expressed by the formula φ''[k := n] are less or equal to p1. We call I1 the set of intervals expressed by φ''[k := n]. It is obvious that for each n the set I1 has at most
p1 elements.
Let k. t1.φ' be the formula which expresses the times of the second ac- tivity step. In the same manner we can find p2 such that the times expressed by ∃t1.φ'[k := n] are less or equal than p2, for any n. Moreover we call I2 the set of intervals expressed by ∃t1.φ'[k := n]. It is obvious that for each n the
n
Now let An = I1 × I2. Since I1 and I2 have naturals as elements then
n	n	n	n
n∈N An is contained in N × N. Moreover, it is obvious that the pair of times
contained in  φ'[k := n]) are contained in I1 × I2. In fact I1 is the set of times
of the first activity step and I2 is the set of times of the second activity step expressed by φ'[k := n]. Therefore it holds that
 ∃k.φ') =    φ'[k := n]) ⊆   An ⊆ N × N.
n∈N	n∈N
Since ∃k.φ') is equal to N × N, it holds that
 ∃k.φ') =   An.
n∈N

Moreover, for each n it holds that An has at most p1 · p2 elements.
Let p = p1 · p2; we can construct a function f1 : N × [0,p − 1] → N × N
such that for any n ∈ N it holds that
{f1(n, 0),... , f1(n, p − 1)} = An.
Since it holds that  n∈N An = ∃k.φ') = N × N, the function f1 is surjective. Let f2 : N → N × [0,p − 1] be a function such that, for any natural n, it holds that f2(n)= (q, r) if and only if n = q · p + r. By the theorem of division the function f2 is well defined. Moreover the function f2 is surjective. In fact,
for each (q, r), it holds that f2(q · p + r)= (q, r).
Let f : N → N × N be the composition of functions f1 and f2. Since f1 and f2 are surjective also f is surjective. So we have proved that there exists a function f : N → N × N which is surjective, but this is impossible.
 


, a,  '
,  , 

l1
)
x =0	'
x = m ∧ x =0 
l2
	) '
2	l3
b,x = m
		'

x = x + t
 J
x = x + t
 J
x = x + t
 J

Fig. 6. The Hybrid System H3.
, '	a,       '	, 
l1	x = x ∧ y = 0	l2
'	'

) x = x + t
x = x

x =0 
'	'
y = y + t	y = y + t

  Jb, '	 J
y = x ∧ x =0 
Fig. 7. The Hybrid System H4.

Proof of Proposition 3.3
It is obvious that	( Mix)	( k )	( L). This is verified directly by considering the syntax of the three classes. Now, we must prove that there
exists a language recognized by a HMix and Hk and not by a HL.
Let H2 be the Hybrid System of figure 5 with l2 as final location. The system H2 is both a HMix and a Hk . The language L(H2) is equal to L2. We prove by contradiction that there is no Hybrid System in HL accepting L2. Similarly to the proof of proposition 3.2, the times expressible by an HL is a finite set of intervals, and so we cannot express the set {t | ∃h.t = 2h+1}. 

Proof of Proposition 3.4
Let H3 be the Hybrid System of figure 6 with l3 as final location. The system
H3 is both HP ar and Hk . The language L(H3) is equal to L3.
We prove, by contradiction, that there exists no HMix, and therefore no
HS, which recognizes L3.
As done in the proof of proposition 3.2, the admissible times of a run com- posed by two activity steps and two transition steps are the valuations which satisfy a linear mixed formula without quantifiers in ΦMix((t1, t2)), where t1 represents the time of the first activity step and t2 the time of the sec- ond activity step. It means that there exists a linear formula φ such that
 φ) = {(c, c2) | c ∈ R}.  But this is impossible.  In fact, by the proof of
proposition 3.1, we can suppose that φ is of the form  k .φ', where φ' is a linear mixed formula without quantifiers. Therefore,  φ) can be written as →−v ∈V (→−k ){(c, c') | (c, c')  −→v |= φ'}. Now, (c, c')  −→v |= φ' if and only if (c, c') |= φ'[−→k := −→v ]. But φ'[−→k := −→v ] is a linear mixed formula without quantifiers on (t1, t2) with rational coefficients and constants. So the formula describes a finite union of convex spaces. More precisely, if φ' = φ1 ∨ ··· ∨ φl,
with φi is a conjunction √on inequalities, for 1 ≤ i ≤ l, then φi[ k := −→v ] is a 
convex space. The pair ( 2, 2) is a valuation which satisfies φ. We note that

√2 /∈ Q. So there e√xists i and —→v such that the convex space S = φi[—→k := —→v ]
contains the pair ( 2, 2).
If S = {(√2, 2)} then it means that S can be written as t1 = √2 and t2 = 2,
√but this contradicts the fact that coefficients and constants are rational, in fact

2 /∈ Q.
If S э {(
√2, 2)} then it means that S has infinite solutions. Let (c, c2) in

S such that c /= √2; then since S is a convex the pair ( √2+c , 2+c2 ), which is
2	2
2
in the middle of (c, c ) and ( 2, 2), is in S, and so it is also in  φ).
But this means that the square of √2+c is equal to 2+c2 . This holds if and
	
√	2	2	2	2
only√if (  2+ c) = 2(2 + c ). But the only c which satisfies the equation is
c =	2, which contradicts the hypothesis. So we have proved that L(7P ar) /⊆
L(7Mix) and L(7D) /⊆ L(7S).
Now, we must prove that L(7P ) /⊆ L(7P ar). Let H4 be the Hybrid System of figure 7 with l2 as final location. The language L(H4) is equal to L4.
We prove, by contradiction, that there not exists a 7P ar which recog- nizes  4. If  P ar exists with l parameters which recognizes  (H4), then the admissible times of a run composed by 2 n activity steps and 2 n transition steps, with n > l, are given a formula without quantifiers φ in ΦP ar((t1, t'1,... , tn, t'n, m1,... , ml)). Now, we want to express the fact that t'i = (ti)2, but we have proved that is impossible with linear real formulae. Therefore we must use parameters. Since in Act(l) only the time of the actual activity step appears, it means that in φ, to have that t'i = (ti)2, we must use a parameter mj and a formula t'i = (mj)2 ti = mj. Since parameters cannot change their values, we need n parameters. But this contradicts the hypothesis l < n.	 

Proof of Proposition 3.6
Let H5 be the Hybrid System in figure 8 with l3 as final location.
The language L(H5) is equal to L5. The system H5 is in 7k and 7S. We
prove, by contradiction, that there not exists a 7Mix and 7P which recognize
5. If a Mix or P exists, with l real variables as done in proposition 3.4, then the admissible times of a run with 2 n activity steps and 2 n transitions steps, with n > l, are given by a formula in which we must use a real variable id to express ti = id id = t'i. It means that we need n real variables, but this contradicts the hypothesis n > l.	 

Proof of Proposition 3.7
Let H6 be the Hybrid System in figure 9 with l3 as final location; H6 is in 7k
and L(H6) is equal to L6.



a,
k < size∧
'a [k]= x∧
'
b,
k < size∧ x = a[k]∧
'

,sx =0	,sx =0	, 

size ≥ 0	l1
l2	l3

x =0 
k =0 
'		)
x = x + t
a,
'		)
x = x + t
b,

'
x = x + t

  Jk = size∧
'
a [k]= x∧
  Jk = size∧	 J
x = a[k]

'	'
x =0 ∧ k =0 
Fig. 8. The Hybrid System H5.


a,
k < size∧
'
a [k]= x∧
'
b,
k < size∧
2
x = (a[k]) ∧
'

,sx =0	,sx =0	, 
size ≥ 0	l1	l2	l3

x =0 
k =0 
'		)
x = x + t
a,
'		)
x = x + t
b,

'
x = x + t

k = size∧
'
a [k]= x∧
k = size∧
2
x = (a[k])

'	'
x =0 ∧ k =0 
Fig. 9. The Hybrid System H6.


a,
k < size∧
'a [k]= x∧
'
b,
k < size∧
x = a[k] ∧ ∃h.x = h∧
'

,sx =0	,sx =0	, 

size ≥ 0	l1
l2	l3

x =0 
k =0 
'		)
x = x + t
a,
'		)
x = x + t
b,

'
x = x + t

k = size∧
'a [k]= x∧
k = size∧
x = a[k] ∧ ∃h.x = h

'	'
x =0 ∧ k =0 
Fig. 10. The Hybrid System H7.

x =0 
,v


 a,  '


, b,  '

c,
,s∃ h.x = h

x = m ∧ x =0 
l1	l2
2
x = m
∧ x =0 
l3

'		)
x = x + t
'		)
x = x + t

'
x = x + t

 J  J  J
Fig. 11. The Hybrid System H8.
We prove, by contradiction, that there are no 7P and 7S which recognize L6. If there exists a 7P which recognizes L6, then this contradicts the proof of proposition 3.6. Furthermore, if there exists a S which recognizes 6, then this contradicts the proof of proposition 3.4. So we have proved that L(7D) /⊆ L(7P ) ∪ L(7S).
Now we prove that 7S /⊆ 7Mix ∪ 7k . Let H7 be the Hybrid System in figure 10 with l3 as final location. The language L(H7) is equal to L7.
The system H7 is in 7S, and we prove, by contradiction, that there are no

Mix and	D which recognize	7. If there exists a	Mix which recognizes	7,
then this contradicts the proof of proposition 3.6. Furthermore, if there exists
a 7k which recognizes L7, then this contradicts the proof of proposition 3.2. 

Proof of Proposition 3.8
Let H8 be the Hybrid System in figure 11 with l4 as final location. The language L(H8) is equal to L8.
We prove, by contradiction, that there is no 7S and 7k which recognize
L8. If there exists a 7S which recognizes L8, then this contradicts the proof
of proposition 3.4. Moreover, if there exists a 7k  which recognizes L8, then
this contradicts the proof of proposition 3.2.	 
