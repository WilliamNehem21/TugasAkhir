

Electronic Notes in Theoretical Computer Science 223 (2008) 103–117
www.elsevier.com/locate/entcs

The Compositional Method and Regular Reachability
Ingo Felscher1
Chair of Computer Science 7 – Logic and Theory of Discrete Systems RWTH Aachen University
Aachen, Germany

Abstract
The compositional method, introduced by Feferman and Vaught in 1959, allows to reduce the model-checking problem for a product structure to the model-checking problem for its factors. It applies to first-order logic, and limitations for its use have recently been revealed by Rabinovich (2007). We sharpen the results of Rabinovich by showing that the composition method is applicable to the asynchronous product (and the finitely synchronized product) for an extended modal logic in which the reachability modality is enhanced by a (semi-linear) condition on path lengths. We show that a slight extension leads to the failure of the composition theorem. We add comments on extensions of the result and open questions.
Keywords: Feferman-Vaught theorem, compositional method, modal logic, regular reachability, asynchronous product, synchronized product


Introduction
In verification a central question is how to decide properties of products of systems using knowledge about the components (factors).
In the area of model theory Feferman and Vaught developed in [4] a composi- tional method which allows to do this. They proved that the first-order (FO) theory of a generalized product of structures is reducible to the first-order theory of the component structures and the monadic theory of the index structure (over which the product is formed). Many variants have been regarded since the original result of Feferman and Vaught; a good overview can be found in [10]. Further references are [6,9,13,15].
In computer science, one can use the method in infinite-state model-checking: When the composition method works, e. g. for a finite product of structures (so that

1 Email:felscher@automata.rwth-aachen.de

1571-0661 © 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.12.034

the monadic theory of the index set is decidable), then one can transfer decidability of the model-checking problem from the factor structures to the product structure. In this context, three aspects are characteristic. First, the focus is on special kinds of relational structures, in particular labeled transition systems (i. e. directed graphs with labels on the edges and the vertices). Second, the product constructions are different from the classical work where direct, reduced, and ultraproducts [1] were the focus – in verification various versions of synchronized products are of interest. Third, first-order logic is replaced by logical systems in which (at least
certain) reachability properties are definable.
In this framework a few composition results have been obtained, but also quite severe limitations of the compositional method have been shown. An obvious exam- ple is the MSO-theory [3,16] of the successor structure S = (N, Succ) of the natural numbers (proved decidable by Bu¨chi); the asynchronous product of two copies of S with itself is the infinite grid which has an undecidable MSO-theory [14]. So the composition method fails (at least in an effective way). It is also known that the method fails for computation tree logic (CTL).
In the present paper we start from the fact that for modal logic (ML) over tran- sition systems, a Feferman-Vaught theorem holds (Rabinovich [11,12]), even for certain “generalized products”. This result also holds for asynchronous products when modal logic is extended by the reachability quantifier “EF” of CTL (which gives us ML(R)-logic, “R” for “reachability”). As also shown in [11], the compo- sitional method already fails for direct products and the logic ML(R). It also fails for asynchronous products and the extension of ML by one of the CTL quantifiers “EU” or “EG”.
In this paper we study another borderline of the compositional method, which also illustrates the step from “EF” and “EG”. We consider (first) asynchronous products and the extension of modal logic by a reachability operator that involves regular expressions for describing path properties (through the labels of edges). For
instance, the operator	∗ expresses the existence of a path whose sequence of
(ab)
edge labels is in the language (ab)∗. We call this the extension of ML by regu- lar reachability and denote it by ML(RegR). (The logic ML(RegR) is expressively equivalent to propositional dynamic logic (PDL) without tests [7].) Our main result states that a composition theorem holds for the logic ML(Reg1R), i.e. for the case of one-letter alphabets in the regular reachability operators. This amounts to the presence of counting for lengths of paths by means of semi-linear sets of natural numbers. We then show (following a construction of [11]) that already for a two letter alphabet the composition theorem fails.
We also consider several variants of the main result. First, instead of asyn- chronous products we consider finitely synchronized products (in which synchroniza- tion can only happen via finitely many transitions): Extending a result of Wo¨hrle and Thomas [17] on the logic ML(R) over finitely synchronized products, we show that compositionality also holds for ML(Reg1R). It is known that for direct (i. e. fully synchronized) products the composition theorem fails. We also give brief com- ments on cases that work similarly but are quite technical and will not be developed

in detail here, in particular on the case of infinite products.
The paper is structured as follows: In the subsequent section, we introduce the structures, logics, and product constructions considered in this paper. Section 3 gives an outline of the composition technique in the form needed here. In Section 4 we show the main result. Section 5 addresses related results which are not given in detail in this paper and also open questions.

Technical Preliminaries
The structures in this paper are labeled graphs; we speak of “transition systems”.
Definition 2.1 A transition system is a structure K = (S, {Ra | a ∈ Σ}, {Pv | v ∈ V }), where S is a set of states, Ra is the transition relation for the letter a ∈ Σ and Pv is a unary predicate for every symbol v ∈ V .
In the subsequent sections we will first define the logics we use and afterwards present the product structures, namely the asynchronous product and the (finitely) synchronized product.

Logics
The logic ML(RegR) is defined as an extension to modal logic with reachability via a path that is labeled according to a regular expression.
Definition 2.2 Let K be a transition system. For every predicate Pv, pv is a ML formula. Let ϕ, ψ be ML formulas, then ¬ϕ, ϕ ∨ ψ, ϕ ∧ ψ, aϕ and aϕ are ML formulas. aϕ (a ∈ Σ) means there exists an a-labeled transition to a state, where ϕ holds and aϕ means the same for all a-labeled transitions.
The logic ML(RegR) additionally contains the formulas  αϕ and  αϕ with α ∈ Reg(Σ) expressing the property “there exists a path π to a state where ϕ holds, such that the label lab(π) of the path is a word in the language of the regular expression α”, respectively the same statement for all paths. Formally we write for
 αϕ: ∃π : lab(π) ∈ L(α) ∧ (K, π[l]) ▶ ϕ where l is the length of the path. The logic ML(Reg1R) is defined analogously with the exception that the regular expression is built only over an one-element alphabet.
We now define the same extension to first-order (FO) logic.
Definition 2.3 Let x, y be variables. For every predicate Pv (v ∈ V ) and every transition relation Ra (a ∈ Σ), Pv(x) and Ra(x, y) are FO formulas. Let ϕ, ψ be FO formulas, then ¬ϕ, ϕ ∨ ψ, ϕ ∧ ψ, ∃xϕ and ∀xϕ are FO formulas.
Fora regular expression α ∈ Reg(Σ) the logic FO(RegR) contains the additional atomic formula Reachα(x, y) with the meaning “from x the state y is reachable via a path that is labeled by a word in the language of the regular expression α”. As above, for the logic FO(Reg1R) we consider only regular expressions over an one-element alphabet.

Product structures
We look at different products of transition systems, namely the asynchronous and the synchronized product. The synchronized product is defined mainly according to [17], except the fact that we use the same labels for the local transitions in all components. The abbreviation [n] is used for the set {1,... , n}.
Definition 2.4 Let K1,... , Kn (n ∈ N) be transition systems with Ki = (Si, {Ri |

a ∈ Σl} ∪ {Ri | c ∈ Σi }, {Pi
| v ∈ V }) (i ∈ [n]), where Σl is an alphabet for

c	s	v

local transitions with asynchronous behavior in the product and Σi
are alphabets

which are used to define synchronized transitions in the product. Let Σs be the set
Σi , and let all Σi and Σl be pairwise disjoint.
transitions are going to be synchronized. A vector c = (c1,... , cn) ∈ C means that a c-transition exists in the product, if for every i ∈ [n] with ci /= ϵ a ci-transition exists in the component Ki.
The synchronized product of K1,... , Kn is the transition system K = (S, {Ra |
a ∈ Σl}∪ {Rc | c ∈ C}, {Pi | v ∈ V }) with
S :=  n	Si,
Ra := {((s1,... , sn), (s' ,... , s' )) | ∃i : (si, s') ∈ Ri ∧ ∀j /= i : si = s'} for a ∈ Σl,
1	n	i	a	i
Rc := {((s1,... , sn), (s' ,... , s' )) | ∀i : (si, s') ∈ Ri , if ci /= ϵ and si = s' if
1	n	i	ci	i
ci = ϵ} for c = (c1,... , cn) ∈ C and
Pi := {(s1,... , sn) | si ∈ Pi}.
v	v
A synchronized product is called ﬁnitely synchronized if the set of transitions Rc is finite for every symbol c ∈ C.
An asynchronous product is a synchronized product with Σi = ∅ and C = ∅.
Remark 2.5 We will refer to a variant of the asynchronous product which is dis- cussed in [11]: the n-ary asynchronous product, in which one distinguishes between the a-transitions of the different components: instead of Ra, the n-ary asynchronous
product contains the relations Ri (i ∈ [n]) defined as {((s1,... , sn), (s' ,... , s' )) |
a	1	n
(si, s' ) ∈ Ri ∧ ∀j /= i : sj = s' }.
i	a	j

Composition Method
In the proof of the composition theorem (Theorem 3.3) we will – for any sentence
ϕ to be interpreted in a product of transition systems – inductively compute a set
of formulas ϕi (k ∈ [j],i ∈ [n]) for j ∈ N which are interpreted in the components.

The composition theorem holds for ϕ and these ϕi
if the following equivalence is

true: The sentence ϕ holds in the product iff for some k ∈ [j] in every component

Ki the formula ϕi
is satisfied. Let us make this precise:

Definition 3.1 Given a product K of components K1,... , Kn with Ki = (Si, ... ),

a formula ϕ which is interpreted in the product, and formulas ϕi
(k ∈ [j],i ∈ [n]) for

j ∈ N which are interpreted in the components. Let s = (s1,... , sn) ∈ S1 ×···× Sn
and D := {ϕ1,... , ϕj } with ϕk := {ϕ1,... , ϕn}.
k	k

We say that ϕk is satisﬁed at s iff for all i ∈ [n] (Ki, si) ▶ ϕi
and that D is satisfied

at s iff for one k ∈ [j] ϕk is satisfied.
We say that satisfaction of ϕ in (K, s) is reducible to the factor structures, if a set
D exists, such that D is satisfied iff (K, s) ▶ ϕ, and write Dϕ to indicate this.
Notice that Dϕ can be seen as a set representation of a “disjunctive normal form of formulas, interpreted in the components K1,... , Kn”. We will call Dϕ the component DNF for the formula ϕ. Analogously, we will use the term Kϕ with
Kϕ := {ϕ¯1,... , ϕ¯j} and ϕ¯k := {ϕ¯1,... , ϕ¯n} iff for all k ∈ [j] there exists an i ∈ [n],
k	k
such that (Ki, si) ▶ ϕi . Kϕ will be called component KNF.
A conversion between component KNF and component DNF is necessary for handling negation. It works like the normal conversion between KNF and DNF. However afterwards, one has to separate the formulas in the different components and potentially add formulas with the logical value “true” or “false” for some com- ponents, such that the format of a component DNF/KNF can be obtained. This is done as follows:
Theorem 3.2 For every formula ϕ the component DNF Dϕ can be converted into an equivalent component KNF Kϕ and vice versa.
Proof. Given the component DNF Dϕ = {ϕ1,... , ϕj } with ϕk := {ϕ1,... , ϕn}, we
k	k
consider αϕ := (ϕ1 ∧ ··· ∧ ϕn) ∨ ··· ∨ (ϕ1 ∧ ··· ∧ ϕn). With N := [n] the conjunctive
1	1	j	j
normal form 2 of αϕ is	(ϕk1 ∨ ϕk2 ∨ ··· ∨  kj

one tuple (k1,... , kj ) and let Zi be the set {z ∈ [j] | h(k)= (k1,... , kj ) ∧ kz = i}.
We can then define αψ by αψ = ψ1 ∧ ··· ∧ ψnj with ψk = ψ1 ∨ ··· ∨ ψn for k ∈ [nj]

where ψi
is defined by:


ψi :=




kx
x∈Zk  x
k	k



if Zk /= ∅

k	ffi	otherwise 3 .


The formula ψi
combines all formulas that are interpreted in the i-th component.

The component KNF is then Kϕ = {ψ1,... , ψnj } with ψk = {ψ1,... , ψn}. The
k	k
conversion of Kϕ to Dϕ is analogous.	 
These preliminaries are used in the proof of the (known) composition theorem for modal logic and synchronized products.
Theorem 3.3 (Composition theorem for synchronized products and ML)



2 if we see the ϕi
as predicates

3 The formulas tti and ffi stand for statements that are interpreted in the component Ki and are always evaluated to true respectively to false.



Given the synchronized product K = (S, {Ra | a ∈ Σl}∪ {Rc | c ∈ C}, {Pi | v ∈ V })
of transition systems K1,... , Kn with Ki = (Si, {Ri | a ∈ Σl}∪{Ri | c ∈ Σi }, {Pi |

a
v ∈ V }) and the initial state s = (s1,... , sn).
c	s	v

For each sentence ϕ of ML which is interpreted in the product, there exists an
(effectively computable) set of auxiliary formulas ϕi (k ∈ [j],i ∈ [n] for a j ∈ N)
which are interpreted in the components, such that
(K, s) ▶ ϕ ⇔ ∃k ∈ [j] ∀i ∈ [n]: (Ki, si) ▶ ϕi .

Proof. The proof of this theorem is an extended version of the proof in [11] for
n-ary asynchronous products; it is done by structural induction. For any atomic

formula pi
one uses the formulas ϕl (l ∈ [n]) with ϕi = pi
and ϕj = ttj for j /= i.

For the induction step, we assume that component DNFs for the subformulas ψ and θ are given and we construct the component DNF for ϕ for the cases 4 ¬ψ, ψ ∨ θ and aψ (a ∈ Σl ∪ C):
ϕ = ¬ψ: Let Dψ = {ψ1,... , ψj} with ψk = {ψ1,... , ψn} be the given compo-
k	k
nent DNF for ψ. We immediately get the component KNF Kϕ = {ϕ1,... , ϕj}
with ϕk = {¬ψ1,... , ¬ψn} which can be converted 5 into a component DNF as
k	k
mentioned above.
ϕ = ψ ∨ θ: Let Dψ and Dθ be the component DNFs for ψ and θ. We get Dψ ∪ Dθ
for Dϕ.
ϕ =  aψ (a ∈ Σl): Given the component DNF Dψ = {ψ1,... , ψj } with ψk =
{ψ1,... , ψn} we will compute the component DNF for ϕ using the auxiliary sets

k	k
i	i	1
i−1	i  i

Dϕ for i ∈ [n]. Dϕ is defined as {ϕ1;i,... , ϕj;i} with ϕk;i = {ψ ,... ,ψ	,  ψ ,
k	k	a  k

ψi+1,... , ψn} for k ∈ [j]. Di
expresses that in the i-th component of the product

k	k	ϕ
there exists an a-labeled transition to a state where ψ holds. Dϕ is the disjunction

over all these possibilities, so it can be defined as Dϕ = 
i∈[n]
Di . 6

ϕ =  cψ (c = (c1,... , cn) ∈ C): Let Dψ = {ψ1,... , ψj} with ψk = {ψ1,... , ψn}
k	k
be the given component DNF for ψ, then the resulting component DNF for ϕ

is Dϕ = {ϕ1,... , ϕj} with ϕk = {ϕ1,... , ϕn} where ϕi
=  c ψi
if ci /= ϵ and

i = ψi
if ci = ϵ.
k	k	k	i  k

Main Result
In this section we study the composition theorem for the extension of modal logic by regular reachability. We treat the cases of asynchronous products, respectively

4 We have to consider only these cases, because ψ ∧ θ = ¬(¬ψ ∨ ¬θ) and aψ = ¬( a¬ψ). Note that for complexity reasons it is better for the formula ψ ∧ θ to use the mechanism to multiply out the formulas with are represented by the according component DNFs.
5 Note that the conversion between component KNF and DNF exponentially increases the size of the component DNF because of the underlying conversion between DNF and KNF.
6 This construction uses the fact that  aψ in the asynchronous product can be seen as 1 ψ ∨ ··· ∨ nψ
a	a
in the n-ary asynchronous product.

finitely synchronized products in subsections 4.1 and 4.2. Finally, we conclude with a generalization to FO-logic with regular reachability.
Asynchronous product
We prove that the composition theorem can be used for asynchronous products and the logic ML(Reg1R). Moreover, we show that it fails if the extension of modal logic is considered, where we allow reachability via a regular path property (according to a regular expression over an alphabet with two symbols).
Theorem 4.1 (Composition theorem for asynchronous products and the logic ML(Reg1R))
Given the asynchronous product K = (S, {Ra | a ∈ Σl}, {Pi | v ∈ V }) of transition
systems K1,... , Kn with Ki = (Si, {Ri | a ∈ Σi}, {Pi | v ∈ V }) and the initial

state s = (s1,... , sn).
a	l	v

For each sentence ϕ of ML(Reg1R) which is interpreted in the product, there exists
an (effectively computable) set of auxiliary formulas ϕi (k ∈ [j],i ∈ [n] for a j ∈ N)
of ML(Reg1R) which are interpreted in the components, such that
(K, s) ▶ ϕ ⇔ ∃k ∈ [j] ∀i ∈ [n]: (Ki, si) ▶ ϕi .
For the proof of Theorem 4.1 we need a possibility to reduce a formula  αϕ with α ∈ Reg({a}) to formulas in the components. Therefore, we will first show that it is sufficient to handle only the case of regular expressions α = β∗ for β = ak with k ∈ N by using semi-linear sets. In the second step we will reduce a formula
 (ak )∗ ϕ – which means that the length of the path is divisible by k – to formulas in the components.
Lemma 4.2 For every regular expression α ∈ Reg({a}) there exists an equivalent regular expression α¯, such that for all parts β of α¯ of the form β = γ∗ it holds that γ = ak for a k ∈ N.
Proof. We identify the word ak with the number k. As is well-known [8, chap. 6.9] the language L defined by α is semi-linear, i. e. of the form ψ(L)= i∈[m] Mi for a m ∈ N where Mi = {ki0 + ni1ki1 + ··· + nirikiri | nij ≥ 0 for 1 ≤ j ≤ ri} with fixed kij ∈ N. Thus α is equivalent to the regular expression α¯ = α1 + ··· + αm where αi = aki0 (aki1 )∗ ··· (akiri )∗.	 
Remark 4.3 We can use the following algorithm to translate α to t(α) with the requirements of α¯ from lemma 4.2.
α = ϵ: t[α] := ϵ
α = ak (k ≥ 1): t[α] := ak
α = α1 + α2 (α1, α2 /= ϵ): t(α) := t[α1]+ t[α2]
α = α1 · α2 (α1, α2 /= ϵ): t(α) := t[α1] · t[α2]
α = (α1 · α2 ··· αj)∗ (j ≥ 1)
· ∀i ∈ [j] αi = aki ⇒ t[α] := (ak1 +···+kj )∗

· ∃i ∈ [j] αi = β∗ (β /= ϵ) ⇒ t[α] := t[(α1 ··· αi−1 · αi+1 ··· αj)∗] · t[β∗] 7
· ∃i ∈ [j] αi = (β1 + β2) (β1, β2 /= ϵ) ⇒ t[α] := t[(α1 ··· αi−1 · β1 · αi+1 ··· αj)∗] ·
t[(α1 ··· αi−1 · β2 · αi+1 ··· αj)∗]
It remains to check formulas of the type  k ∗ ϕ, meaning that the path length is divisible by k. Intuitively, if we have e. g. two components K1, K2, the reason why the path length in the product is divisible by 3 can be that in both components the parts of the path are divisible by 3 without remainders or that the parts are divisible by 3 with remainders (1, 2) or (2, 1) in the components (K1, K2).
With these preparations we can now prove Theorem 4.1.
Proof. The atomic cases and the cases ¬ψ, ψ ∨ θ and  aψ are treated like in the proof of Theorem 3.3; for the case ϕ = (ak )∗ ψ note that ϕ expresses that there exists a path π to a state s' where ψ holds, such that the length of π is l with l = 0 (mod k) and l ≥ 0. The label of this path is al. For these l a-
labeled transitions exist different distributions over the components; let li denote the number of a-transitions chosen in the component Ki.
F orthe  existence of this path Σn	li = 0 (mod k) must hold for any distribution
(l1,... , ln) of a-transitions over the components K1,... , Kn.  li is representable
as li = li + ti ∗ k with li ∈ {0,... ,k − 1} and ti ∈ N. With this we also get

n i=1
li =0 (mod k).

We can now express for fixed values of the li the distribution (l1 + t1 ∗ k,... ,
ln + tn ∗ k) by the tuple of regular expressions (al1 (ak)∗,... , aln (ak)∗). Because of li ∈ {0,... ,k − 1}, there exist kn of such tuples.
Let Dψ = {ψ1,... , ψj} with ψk = {ψ1,... , ψn}. With the observation above we

get Dϕ =  
k
Dϕ;k with Dϕ;k = {{  l1
Σ
k
k ∗ ψ1,... ,  aln (ak )∗ ψn} | ∀i ∈ [n] :


The same proof covers the case that the reachability modality is used with a semi-linear constraint on the length of paths. Formally, this case is captured in the
following way: For Σ' ⊆ Σ we introduce a new label b such that s −→b  s', if there
exists an a ∈ Σ' such that s −→a s'.
From Theorem 4.1 we immediately obtain the following corollary on the decid- ability of the model checking problem in the product.
Corollary 4.4 If the ML(Reg1R) model checking problem is decidable for each of
the transition graphs Ki = (Si, {Ri | a ∈ Σl}, {Pi  | v ∈ V }) then it is decidable for
the asynchronous product K = (S, {Ra | a ∈ Σl}, {Pi | v ∈ V }).
For each of the composition theorems shown below, a corresponding corollary on decidability of model-checking over products can be inferred. We do not state these counterparts to Corollary 4.4 explicitly.
Let us now verify that the result cannot be strengthened to cover 2-letter alpha- bets. Therefore we first present a schema – developed in [11] – that can be used

7 This is possible by the commutativity of regular expressions over the one-element alphabet and L((β∗)∗)= 
L(β∗).

to prove that the composition theorem fails for a logic which can express a specific formula. It will be used afterwards to show that the composition theorem fails for the logic ML(RegR) and asynchronous products.
Lemma 4.5 Given a formula ψ  and two inﬁnite sets of transition systems
{Ck| k ∈ N} and {Dl| l ∈ N} with state sets SC and SD, a common state s ∈ SC ∩SD
k	l	k	l
and a product speciﬁcation for Ck × Dl for all k, l ∈ N. The composition the- orem fails if the following properties hold: ∀k ∈ N : (Ck × Dk, (s, s)) ▶ ψ and
∀k, l ∈ N,k /= l : (Ck × Dl, (s, s)) $ ψ.
Proof. (essentially [11]) The proof is done by contradiction. Let k, l ∈ N. We assume that the composition theorem holds for a logic which can express ψ. Ac- cording to the composition theorem, for every sentence ϕ which is interpreted in the
product Ck × Dl there exists a j ∈ N and formulas ϕ1, ϕ2,... , ϕ1, ϕ2, interpreted in

the components, such that
1	1	j	j

(Ck × Dl, (s, s)) ▶ ϕ ⇔ ∃m ∈ [j]: (Ck, s) ▶ ϕ1 ∧ (Dl, s) ▶ ϕ2
We define an equivalence relation ∼ on {Ck | k ∈ N} which expresses that two

transition systems are equivalent, if they satisfy the same formulas of {ϕ1
| m ∈ [j]}.

Ck ∼ Cl ⇔ (∀m ∈ [j]: (Ck, s) ▶ ϕ1 ⇔ (Cl, s) ▶ ϕ1 )


The set {ϕ1
| m ∈ [j]} is finite, so we get a partition of {Ck | k ∈ N} into

finitely many equivalence classes. There must be at least one equivalence class which contains at least two (in fact infinitely many) transition systems, because
{Ck | k ∈ N} is infinite. We now call these two classes Ck and Cl.
By the precondition (Cl × Dl, (s, s)) ▶ ψ holds and by the definition of the

equivalence relation (Ck, s) ▶ ϕ1
⇔ (Cl, s) ▶ ϕ1
holds, from which we get

(Ck × Dl, (s, s)) ▶ ψ which is a contradiction to the assumption.	 
Theorem 4.6
The composition theorem (Theorem 4.1) fails for the logic ML(RegR).
We will prove that the composition theorem already fails for a formula which expresses that there exists a path which is labeled alternatively with a and b: we use the formula (ab)∗ ϕ.
Proof. Given two sets of transition systems {Ck | k ≥ 2} and {Dl | l ≥ 2} where Ck is defined as (Sk, Ra, Rb, Q) with Sk := [k], Ra = ∅, Rb the successor relation, and Q = {k}. The transition system Dl has the same format with Ra and Rb switched. Let ϕ be the formula q1 ∧ q2 which holds only at the “last” state (k, l) of the asynchronous product Ck × Dl which is indicated by the filled states in figure 1.

For k = l the path (1, 1) −→a
(1, 2) −→b
(2, 2) −→a
(2, 3) −→b
··· −→a
(k − 1, k) −→b
(k, k)

exists, whose label is in the language L((ab)∗), so (Ck × Dk, (1, 1)) ▶	∗ ϕ holds.
(ab)
For k = 4 this situation is shown on the left side of the figure 1. For the case k < l
the only path starting at (1, 1) which is labeled alternating with a and b can only be


	
Fig. 1. The products C4 × D4, C4 × D6

extended by a’s from the state (k, k) onwards, so (Ck × Dl, (1, 1)) $  (ab)∗ ϕ. This is shown in the figure 1 for k =4 and l = 6. The case k > l is analogous.
So we meet the requirements for the lemma 4.5. As consequence the composition theorem fails for asynchronous products and the logic ML(RegR).	 

Finitely synchronized product
We now show that Theorem 4.1 extends from asynchronous to finitely synchronized products (in the sense of [17]). Afterwards, we prove that the composition theorem also works for the logic FO(Reg1R), again for finitely synchronized products.
Theorem 4.7 (Composition theorem for ﬁnitely synchronized products and the logic ML(Reg1R))
Given the ﬁnitely synchronized product K of transition systems K1,... , Kn from the deﬁnition 2.4 and the initial state s = (s1,... , sn).
For each sentence ϕ of ML(Reg1R) which is interpreted in the product, there exists
an (effectively computable) set of auxiliary formulas ϕi (k ∈ [j],i ∈ [n] for a j ∈ N)
of ML(Reg1R) which are interpreted in the components, such that
(K, s) ▶ ϕ ⇔ ∃k ∈ [j] ∀i ∈ [n]: (Ki, si) ▶ ϕi .

Proof. As the local and synchronized transitions are disjoint we only have the two cases α ∈ Reg({a}) for a ∈ Σl respectively a ∈ C.
For a ∈ Σl we can restrict the transition structure of the product to the asyn- chronous transitions and treat the formula  αψ like above.
For a ∈ C we restrict the transition structure to the synchronized transitions. Since there are only finitely many transitions there are only finitely many reach- able states. For every regular expression βi, let S(βi, s) be the set of reach- able states from the state s. For every β there exists a k ∈ N, such that S(βk, s)= S(βk+1, s), so β∗ is equivalent to β0 ∨ β1 ∨ β2 ∨ ··· ∨ βk.

We can strengthen Theorem 4.7 to the more interesting case that the counting extends over a full path, including the local and the synchronized transitions.

Theorem 4.8 The composition theorem (Theorem 4.7) holds for ﬁnitely synchro- nized products and modal logic which is extended by reachability via paths where the length of the path is required to be a semi-linear set L.

Proof. First we treat the typical case where the path length is required to be divisible by k with remainder r.
Let c∈C Rc = {r1,... , rp} be the set of synchronized edges. The theorem will be proven in three steps:
We will inductively construct semi-linear sets which describe all paths using the synchronized edges r1,... , rm(m ≤ p). This decomposition follows the pattern of Kleene’s Theorem.
We show that for the calculation of the path lengths modulo a number k it is sufficient to use every synchronized edge only at most k times.
We use the idea of (i) together with the limitation (ii) to construct sets for each component and describe the distribution of the asynchronous and synchronized transitions over the components such that the length of the path in the product is divisible by k with a remainder r.
Let sm and tm be the states of the edge sm −r−m→ tm for m ∈ [p], let z be the initial state and zf be a dummy state, which will only be used for notational ease.
We inductively construct sets Lm for i, j ∈ {s1, t1,... , sp, tp, z0, zf } which express
“from i there exists a path to the state j using at most the synchronized transitions
r ,... ,r	such that the path is in the semi-linear set Lm ”. Finally we get Lp

1	m	i,j
z0,zf

which uses at most all synchronized transitions.
a	'	a'	'	'

Let a be a new symbol such that s −→ s , if s −→ s
regular expression over the alphabet {a}. Induction start (m = 0):
for an a
∈ Σl and let αi,j be a

0
i,j
0
i,i
= αi,j for i /= j
= ϵ

Ls,t = c for s −→c
t for c ∈ C

Induction step (m − 1 → m):

Lm = Lm−1 ∪ Lm−1 · Ls  ,t
· (Lm−1
· Ls ,t
)∗ · Lm−1

i,j
i,j
i,sm
m m	tm,sm	m m
tm,j

For m = 1 the second part of the semi-linear set Lm
describes the path

i ~ sm → tm(~ sm → tm)∗ → j, where the arrow ~ indicates reachability

by asynchronous transitions. Note that Lm
is semi-linear, because the union

L1 ∪ L2, the concatenation L1 · L2 and the Kleene star L∗ of semi-linear images
L1, L2 are semi-linear [8].
Note that it is sufficient to pass through each synchronized transition a finite number of times: For each synchronized transition we get all possible path lengths modulo k after passing through the transition at most k times. The worst case occurs if k is a prime number, we want to get a path length divisible by k with
remainder 0 and for the synchronized transition s −→c  t there exists only one path

from t back to s, which has the length k. Then we will have to use this path
including the transition s −→c t k-times to get a path length divisible by k. So we

can replace the star in Lm
by a disjunction of the repetitions up to k-times.

To build statements in the components, we use the following ideas:
We guarantee that the corresponding parts (c1,... , cn) of the synchronized tran- sition c are used in the same sequence in all components.
We allow everywhere in between asynchronous transitions.
We check that the number of the asynchronous transitions used in all compo- nents together with the number of synchronized transitions is divisible by k with remainder r.
Therefore we inductively define for each component Kh (h ∈ [n]) a function Mi,j(J, X(h)) where X(h) = (Xs1 ,t1 (h),... , Xz0 ,zf (h)) is a tuple of variables and J = (j1,... , jm) with 0 ≤ jg ≤ k (g ∈ [m]) a tuple of indices for the repetitions of the loops of the synchronized transitions r1,... , rm (m ≤ p). The sets Mi,j(J, X(h)) are defined analogously to the sets Lm .
Induction start:

Mi,j(X(h), ∅)= Xi,j(h) for i /= j
Mi,i(X(h), ∅)= ϵ
Ms,t(h)= c  for s −→c  t for c = (c ,... ,c ,... ,c ) ∈ C
h	1	h	n
Induction step (m − 1 → m):
Let J = (j1,... , jm) and J' = (j1,... , jm−1)
⎧⎪⎨Mi,j(X(h),J'), if jm =0 

⎪⎩	Mtm

 


,j(X(h),J'), if 1 ≤ jm ≤ k

Now we can build a disjunction over all possible tuples (Y1,... , Yn) with Yh = Mz0 ,zf (J, X(h)) (h ∈ [n]) where J = (j1,... , jp) with 0 ≤ jg ≤ k (g ∈ [p]) and all solutions for X(h) of the form Xi,j(h) = ali,j,h (ak)∗ (0 ≤ li,j,h < k) such that h∈[n] Mz0,zf (J, X(h)) = r (mod k) where |M | denotes the length modulo k of the paths described by M . Note that for a fixed J there are only finitely many of
such solutions and there are only finitely many J.
The general case where the length of the path shall be in a semi-linear set can be treated in the following way: Let L be a semi-linear set over an one-element alphabet. Then the semi-linear image ψ(L) has the form i∈[u] Mi for a u ∈ N where Mi = {ki0 + ni1ki1 + ··· + nitikiti | nij ≥ 0 for 1 ≤ j ≤ ti} with fixed kij ∈ N. For each of these sets Mi we define “modmin {ki1,... , kiti }” by: x = r (modmin {ki1,... , kiti }) :⇔ x = min{rs | x = rs (mod ks), ks ∈ {ki1,... , kiti }}. Note that modmin {ki1,... , kiti } calculates the value of ki0. The general case can now be solved for one Mi if we replace everywhere in the proof above “mod k” by “modmin {k1,... , kti }”.	 

Before we generalize the result to FO-logic with regular reachability over an one-element alphabet, let us mention that W¨ohrle and Thomas already treated in [17] the cases of asynchronous and finitely synchronized products for the logics FO(R) and FO(RegR) – in the first case, compositionality holds, in the second it fails. For reachability they used an extension of FO-logic by new atomic formulas ReachΣ' (x, y) meaning that there is a path from x to y, carrying any letters of the alphabet Σ' ⊆ Σ.
We now adapt the proof of Theorem 4.8 to the logic FO(Reg1R), respectively FO-logic extended by reachability via paths where the length of the path is required to be a semi-linear set L. Here we admit atomic formulas of the form Reachα(x, y)
where α is a regular expression over {b} and b is a new edge label such that s −→b t
a
if there exists an a ∈ Σ' ⊆ Σl ∪ C with s −→ t. We obtain:
Theorem 4.9 (Composition theorem for ﬁnitely synchronized products and the logic FO(Reg1R))
Given the ﬁnitely synchronized product K of transition systems K1,... , Kn from the deﬁnition 2.4.
For each sentence ϕ of FO(Reg1R) which is interpreted in the product, there exists
an (effectively computable) set of auxiliary formulas ϕi (k ∈ [j],i ∈ [n] for a j ∈ N)
of FO(Reg1R) which are interpreted in the components, such that
K ▶ ϕ ⇔ ∃k ∈ [j] ∀i ∈ [n]: Ki ▶ ϕi .
The analogous statement holds for ﬁnitely synchronized products and FO-logic which is extended by reachability via paths where the length of the path is required to be a semi-linear set L.
Proof. The (inductive) proof is analogous to the corresponding proofs for finitely synchronized products. The atomic cases of predicates and transition relations and the cases of the induction step (the existential quantifier, the negation, and the disjunction) are treated in the standard way. Let x¯ = (x1,... , xn), y¯ = (y1,... , yn) be variables which are interpreted in the product, let a ∈ Σl and c = (c1,... , cn) ∈ C be transition labels of an asynchronous respectively a synchronized transition of the product, then the corresponding sets Dϕ for the formulas ϕ are built as follows:
ϕ = (x¯ = y¯): The set Dϕ is constructed as {{ϕ1,... , ϕn}} with ϕi = (xi = yi) for i ∈ [n].
ϕ = Pk(x¯): The set Dϕ is constructed as {{ϕ1,... , ϕn}} with ϕk = Pk(xk) and
v	v
ϕi = tti for i ∈ [n]\{k}.
ϕ = Ra(x¯, y¯): We construct Dϕ = {ϕ1,... , ϕn} with ϕj = {ϕ1,... , ϕn} for j ∈ [n]
j	j
where ϕj = Ra(xj, yj) and ϕi = (xi = yi) for i ∈ [n]\{j}.
j	j
ϕ = Rc(x¯, y¯): The set Dϕ is constructed as {{ϕ1,... , ϕn}} with ϕi = Rc (xi, yi)
if ci /= ϵ and ϕi = (xi = yi) otherwise.
ϕ = ¬ψ, ϕ = ψ ∨ θ: These cases are the same as in the composition theorem (Theorem 3.3).

ϕ = ∃x¯ ψ(x¯1,... , x¯l, x¯): Given Dψ = {ψ1,... , ψm} with ψj = {ψ1,... , ψn} for j ∈
j	j
[m], the set Dϕ is constructed as {ϕ1,... , ϕm} with ϕj = {∃x1 ψ1,... , ∃xn ψn}
j	j
for j ∈ [m].
Apart from that we have the additional atomic case that one state is reachable by another via a path that is labeled with a word of a regular expression α over the one-element alphabet {b}. By lemma 4.2 we can assume α = (bk)∗.
ϕ = Reachα(x¯, y¯): For the asynchronous product the set Dϕ is constructed as
{{Reachbl1 (bk )∗ (x1, y1),... , Reachbln (bk )∗ (xn, yn)} | ∀i ∈ [n]: li ∈ {0,... ,k − 1}∧ 

n i=1
li = 0 (mod k)} analogously to the proof of Theorem 4.1. For the finitely

synchronized product we use reachability formulas for the tuples (Y1,... , Yn)
computed in the proof of Theorem 4.8 above. The proof is analogously extendable to semi-linear sets.

5	Further Results and Conclusion
We have shown results that exhibit new cases where the composition technique (or Feferman-Vaught technique) can be applied in infinite-state model-checking. We showed that the composition theorem holds for an extension of modal logic by reachability together with regular constraints on path lengths – i. e., semi-linear properties of path lengths can be built into the reachability operator as an adden- dum to modal logic. Already the step to two-letter alphabets leads to a failure of the composition theorem. We generalized the results to FO-logic with regular reachability.
We add some remarks on further results and state some open questions. First, the complexity of the model-checking problem for a product structure is quite pro- hibitive. In [2] for FO a non-elementary lower bound was proven for the number of the auxiliary formulas. An open question is, if this also holds for the case of ML. In [5] we showed for which operators of the formulas the number of auxiliary formulas increases exponentially and that it depends not only on the alternation depth of - and -quantifiers, but also partly on the ∧-/∨-operators, depending on which is the next outer  - and  -quantifier.
Second, we mention that a more ambitious generalization of the present results which deals with the case of infinite products (with index set N) is possible. Here the analogous statements to Theorems 4.1 on ML(Reg1R) and 4.6 on ML(RegR) hold, but for ML(Reg1R) involve quite more technical work. First, the “decomposition” of formulas can no more be done on the propositional level (as in our sets Dϕ in Section 3) but on the level of MSO-logic over N. The essential fact we use is the expressibility of semi-linear properties of natural numbers in the MSO-theory of (N, Succ), and that this theory is decidable.
An open question is whether other interesting fragments of the regular languages (beyond the case of one-letter alphabets) exist where a compositional approach to model checking is possible.

As another open problem we mention whether for ML the rather disappointing upper complexity bounds can be improved by more refined algorithms.

Acknowledgement
I wish to thank Wolfgang Thomas for many important suggestions and corrections. Thanks are also due to an anonymous referee for pointing out connections to PDL.

References
Chang, C. C. and H. J. Keisler, Model Theory, “Studies in Logic And The Foundations Of Mathematics”
73 (1990), third edition, North Holland, Amsterdam
Dawar, Anuj, Martin Grohe, Stephan Kreutzer and Nicole Schweikardt, Model theory makes formulas large, ICALP’07: 34th International Colloquium on Automata, Languages and Programming 2007, pages 913–924, Springer-Verlag
Ebbinghaus, H.-D., J. Flum and W. Thomas “Einfu¨hrung in die mathematische Logik” (1996), fourth edition, Spektrum Akademischer Verlag, Heidelberg
Feferman, S. and R. Vaught, The first-order properties of products of algebraic systems, Fundamenta Mathematicae 47 (1959), pages 57–103
Felscher, Ingo, Model-Checking u¨ber Produktstrukturen, diploma thesis (2007), RWTH Aachen
Gabbay, D.M. and V.B. Shehtman, Products of modal logics, part 1, Logic Journal of IGPL 6/1 (1998), pages 73–146
Harel, David, Dexter Kozen and Jerzy Tiuryn, “Dynamic Logic” (2002), MIT Press
Harrison, Michael A., Introduction to Formal Language Theory, Series in Computer Science (1978),
Addison-Wesley
Hodges, Wilfrid, Model theory, “Encyclopedia of Mathematics and its Applications” 42 (1993),
Cambridge University Press
Mostowski, Andrzej, On Direct Products of Theories, The Journal of Symbolic Logic 17/1 (1952), pages 1–31
Rabinovich, Alexander, On compositionality and its limitations, ACM Transactions on Computational Logic 8/1 (2007)
Rabinovich, Alexander, Selection and uniformization in generalized product, Logic J. of IGPL 12/2 (2004), pages 125–134
Shelah, Saharon, The Monadic Theory of Order, The Annals of Mathematics 102/3/2 (1975), pages 379–419
Thomas, Wolfgang, Automata on Infinite Objects, In Jan van Leeuwen, editor, “Handbook of Theoretical Computer Science volume B: Formal Models and Semantics” (1990), pages 133–192
Thomas, Wolfgang, Ehrenfeucht Games, the Composition Method, and the Monadic Theory of Ordinal Words, In Jan Mycielski and Grzegorz Rozenberg and Arto Salomaa, editors, “Structures in Logic and Computer Science, A Selection of Essays in Honor of A. Ehrenfeucht”, Lecture Notes in Computer Science 1261 (1997), pages 118–143, Springer-Verlag
Thomas, Wolfgang, Languages, automata and logic, In G. Rozenberg and A. Salomaa, editors, “Handbook of formal languages” 3 (1997), pages 389–455, Springer-Verlag
W¨ohrle, Stefan and Wolfgang Thomas, Model checking synchronized products of infinite transition systems, Proceedings of the 19th Annual IEEE Symposium on Logic in Computer Science (2004), pages 2–11, Washington, DC, USA, IEEE Computer Society
