Electronic Notes in Theoretical Computer Science 88 (2004) 21–37	
www.elsevier.com/locate/entcs


A–maze–ing Esterel
Joaquin Aguado and Michael Mendler1 ,2
Fakult¨at fu¨r Wirtschaftsinformatik und Angewandte Informatik, Universit¨at Bamberg, Germany
Gerald Lu¨ttgen3
Department of Computer Science, The University of York, U.K.

Abstract
This paper shows that the kernel fragment of Esterel corresponding to combinational circuits admits a natural game–theoretic interpretation. Technically, combinational Esterel programs are mapped into finite two–player games in such a way that the standard must – and cannot –analysis of signal statuses is reflected in the computation of winning strategies. The novel game–theoretic approach complements the existing behavioral, operational, circuit–based, and model–theoretic accounts of Esterel’s semantics and offers a new didactic perspective for familiarizing students and engineers with this intricate constructive semantics.
Keywords: Synchronous languages, Esterel, constructive semantics, causality cycle, game theory


Introduction
The classical theory of games, originally developed in descriptive set theory, has recently emerged as a surprisingly versatile mathematical tool in the se- mantics of programming languages [1]. The power of the games model rests on its ability to handle combinatorially complex situations, such as the alter- nate nesting of quantifiers, in a natural and intuitive fashion [8]. Perhaps the most prominent recent example of successful application is the game–theoretic

1 Email: joaquin.aguado@wiai.uni-bamberg.de.
2 Email: michael.mendler@wiai.uni-bamberg.de.
3 Email: luettgen@cs.york.ac.uk. Research supported by EPSRC grant GR/M99637.


1571-0661 © 2004 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2003.05.006


solution of the full–abstraction problem for the functional language PCF [5], which had been open for a long time. This has led to new approaches in the field of control–flow analysis [7], integrating imperative, object–oriented, higher–order functional, and concurrent features.
Games are a convincing metaphor not only in functional programming but also in the field of reactive–systems modeling. This is because the interaction between a reactive system and its environment has a strong analogy in the moves between a player and his or her opponent in a simple two–player maze game. This interaction problem is then solved by providing a winning strategy that in turn may be understood as a system reaction. In this paper we report on a novel application of this metaphor to the specific interaction problem that arises in synchronous programming under the synchrony hypothesis, namely the characterization of present and absent signals within a system’s reaction under a given environment. Using Berry’s language Esterel [3] as an example, we prove that the underlying intricate constructive semantics of reactions can be captured in a very natural game–theoretic manner.
Consider a two–player maze game, where the board consists of one–way corridors that connect rooms and the game figure is just a single token. Cor- ridors can be of two types: visible and secret. Placing the token in some arbitrary room, the starting player, say Jaakko, may move the token from one room to the next through arbitrarily many secret corridors; however, as soon as Jaakko moves through a visible corridor, his turn ends. Control passes on to the opponent, say Leon, who may continue in a similar fashion from the current position of the token on the board. 4 If the token gets stuck in a dungeon, i.e., a room with no outgoing corridors, the current player loses and the opponent wins. Hence, the objective of the game is to drive the opponent into a dungeon. Obviously, a game board can be modeled as a finite directed graph, such as the one depicted in Fig. 1, where nodes are rooms, solid edges represent visible corridors, and dashed edges represent secret corridors.
Given a game board and choosing an initial room for the token, this room may now be classified according to whether the starting player Jaakko (i) has the possibility always to win (if he plays cleverly), (ii) must always lose (no matter how cleverly he plays), or (iii) can at best reach a draw by ensuring that Leon can never force him into a dungeon. For instance, using the board Mex illustrated in Fig. 1 and initially placing the token in room t5, Jaakko can move the token to room t6 through a visible corridor, thereby handing over control to Leon. Now Leon can only move the token into dungeon t0, again through a

4 The players are named after the logicians Jaakko Hintikka, who pioneered the field of semantic games for logic, and Leon Henkin, who first introduced game–theoretic interpre- tations of quantifiers.



Fig. 1. Example game board Mex .

visible corridor, such that control passes back to Jaakko who instantaneously loses. This implies that room t5 is a losing position (for the starting player Jaakko). However, if instead the token is initially placed in room t4, then Jaakko has two strategies for winning. On the one hand, Jaakko may move the token through a visible corridor to room t5 where, as we have just seen, player Leon will necessarily lose after two more turns. On the other hand, Jaakko may use the secret corridor to move the token into room a and in the same turn further into dungeon t0 via a visible corridor, thus winning the game. Jaakko is said to have a winning strategy from room t4, and t4 is referred to as a winning position. However, a game may also end in a draw. For example, suppose the token is placed initially in room t8. Then Jaakko has several alternatives, but one of these leaves him in the hands of Leon. Indeed, if Jaakko moves the token to room t6, Leon can place the token into dungeon t0. Observe that if the token is instead placed in t9, the situation is similar in the sense that moving the token in room t6 will result in losing the game. Now, assuming that both players want to win and that they both know that placing the token in room t6 is the worst option, it follows that they will keep moving the token all the time through the dark–shaded part of Fig. 1, i.e., through sub–maze M2. Since inside M2 it is always possible to avoid room t6, the game can continue indefinitely in this fashion leading to a draw, whence rooms e, g, t8 and t9 are referred to as a draw positions.


Maze Games and Esterel.
The objective of this paper is to show that programs written in the kernel fragment of Esterel corresponding to combinational circuits can be understood very naturally as maze game boards, where signals are represented by rooms. Intuitively, the presence and absence of signals in the reaction instant that is described by a combinational program P , is “negotiated” between the system (the starting player) and its environment (the opponent). The system tries to prove a signal’s presence and the environment its absence. Thus, signal s must (cannot) be emitted in P if and only if room s in the maze M associated with P is a winning (losing) position. If the status of signal s is undefined, then and only then is room s a draw position.
Technically, strategies within M correspond to the must– and cannot– analysis for P , which is at the heart of Esterel’s behavioral semantics [3]. A simple way to make the connection is to read each visible (secret) corridor as a present–else statement (present–then statement ). We then get an exact correlation between Esterel’s declarative computation of must– and cannot– sets of signals [3] and an inductive computation of winning and losing positions in the game graph. We illustrate this correspondence using the sub–maze M1 in our example of Fig. 1. The program P1 associated with M1 is:
(present t3 else emit t2 end)  (present b then emit t3 end)  (present t6 else emit t3 end)  (present t0 else emit t6 end) .
We reason along the fixed–point computation of P1’s declarative semantics and start with the empty environment in which no signal is known to be present or absent, whence must0 = cannot0 = ∅. Since no emit is unguarded, the first iteration yields no present signals, i.e., must1 = ∅; but since there are no emit statements for b or t0, we get cannot1 = {b, t0} immediately. In game terms this corresponds to identifying both rooms b and t0 in M1 as positions in which the starting player loses right away. The fact that t6 is connected to t0 by a visible corridor means that the starting player now has a strategy to win t6, because he or she can move into t0 where his or her opponent loses. In the computation of Esterel’s declarative semantics for P1, this is the second iteration step: since t0 is known as absent, the emit statement in present t0 else emit t6 end is executed and t6 becomes present. We thus get must2 = {t6} and cannot2 = {b, t0}. Additionally, we know that the statement present b then emit t3 end is not executed in the current instant. In the game, this amounts to marking the secret corridor from t3 to b as useless for any winning strategy for t3. There is no point for any player in going across to b since the player keeps his or her turn and thus loses in b. It may still be possible to win by moving from t3 to t6. However, with the extra information just obtained, namely that t6 is a winning position, we conclude


that t3 is in fact a losing position. For moving from t3 to t6 does not help either since the opponent would get the turn in t6 and win. In the Esterel approximation sequence, t3 indeed enters the cannot set in the third iteration step: cannot3 = {b, t0, t3}. This is clear since t6 ∈ must2 and b ∈ cannot2, whence the only two statements that could emit t3 in P1 are both switched off. The must set does not change, whence must3 = must2 = {t6}. The fourth iteration step identifies t2 as emitted from the fact that t3 ∈ cannot3. For this means, the statement present t3 else emit t2 end is executed. In game terms, room t2 is clearly a winning position as t3 is a losing position. Hence, we obtain must4 = {t6, t2} and cannot4 = cannot3 = {b, t0, t3} as the fixed point of Esterel’s constructive analysis for P1. To sum up, we see that mustn+1 (cannotn+1) is the set of rooms that can be won (must be lost) by the starting player in at most n moves.
The example in Fig. 1 also illustrates how constructiveness of Esterel re- actions is reflected in the game model. We have seen above that the shaded area M2 of Mex contains only draw positions. The associated Esterel pro- gram P2 can be written as a parallel composition of eight present statements, as suggested above, or equivalently in a more compact form as
P2 := present g then present e then (present g else emit e end)  (present e else emit g end) end end ,
where the two rooms t8 and t9 are no longer represented as signals but are implicit in the nested present statements. As an aside, we will see below that our intermediate states ti in game graphs are necessary to express conjunctive behavior. The must– and cannot–analysis for P2 indeed leaves signals e and g constructively undecided. To justify emission of either e or g, both e and g would have to be present in the first place to activate the outmost present statements, which is causally unreasonable. At the same time, they must be absent to switch on the inner emit statements, which is contradictory overall. We cannot justify the absence of e and g, causally, either. For example, in order to deactivate the inner emits through one of the outer guarding present conditions we would need that one of e and g is absent, which is also causally problematic. There is a second possibility for the absence of e and g, namely that the inner emit statements are both switched off. This however requires both signals to be present, which is again a contradiction. Overall, there is only one logically coherent solution, namely that both e and g are absent, yet this solution is not causal. Since this is the only logically coherent solution, the logical behavioral semantics of Esterel [3] would return this as the response, whereas the constructive semantics rejects it. In our maze game, a logically


coherent solution amounts to a “speculative” assignment of 0 (losing) and 1 (winning) markings to rooms so that (i) a room is marked 1 exactly if one of its successor rooms that is accessible via a visible corridor is marked 0, or if a successor room connected via a secret corridor is marked 1; and (ii) a room is marked 0 if all rooms connected via visible corridors are marked 1 and if all rooms connected through a secret corridor are marked 0. In Fig. 1, e = g =0 and t8 = t9 = 1 is the only logically coherent marking for M2. Although this might suggest that both e and g are losing positions for the starting player, it is clear that this cannot be realized by any finite strategy of the opponent.

Mazes and Maze–Game Semantics
This section formalizes our two–player maze games and also provides an al- ternative denotational characterization of the operational notion of a winning position. The reader may find some background material on classical games in [10,12]. The only change in our setting over the classical definitions is that we (i) allow for two types of transitions in game graphs, i.e., visible and secret transitions, and (ii) admit draw positions. The latter feature is in contrast to the classical games used in automata theory and descriptive–set theory [12], where the absence of a winning strategy for one player automatically implies the existence of a winning strategy for the other.

Formalizing Mazes.
Mazes are essentially finite graphs with two kinds of directed edges, namely visible and secret edges. For our purposes, it is convenient to formally rep- resent these graphs as systems of unfolding rules M := (x ⇐ mx)x∈V in a language of mazes, for some finite set V of variables representing rooms and maze terms mx. Maze terms are defined in a process–algebraic fashion, which provides us with sufficient structure for proving the paper’s main results. The syntax of maze terms is given by the following BNF:
m ::= x | 0 | ι.m | τ.m | m + m . 
Intuitively, 0 represents a dungeon, ι.m (τ.m) represents a room with a visible (secret) corridor to room m, and m1 + m2 represents a room that merges rooms m1 and m2, respectively. In the remainder, we let M stand for the set of all maze terms.
For each room x in any given maze M we would like to determine whether it is a winning position (for the starting player). The game–theoretic se- mantics of maze M requires the introduction of a labeled transition system
⟨M, {ι, τ }, −→⟩, where M is the set of states (or rooms), {ι, τ } is the al- phabet with ι encoding a visible action and τ a secret action, and −→ ⊆


M× {ι, τ }× M is the transition relation representing valid moves (or corri- dors) between rooms. The transition relation is defined by the following rules, where γ ranges over {ι, τ }:

−−	m
γ	m'
m	γ	m'
m  γ	m'

	1 −→	1	

	2 −→	2	
−→
x ⇐ m . 

γ
γ.m
γ	'	γ	'	γ	'

−→ m
m1 + m2 −→ m1	m1 + m2 −→ m2	x −→ m

Essentially, this labeled transition system reflects the game graphs of Sec. 1, with dungeons being traps that have no outgoing transition. In the following,
we write m −→ for ∃m' ∃γ. m γ	m'. Note that operators “.”, “+”, and “⇐”
correspond to the process–algebraic operators preﬁx, choice, and recursion.

Example 2.1 Let us specify the maze in Fig. 1 relative to the program’s sig- nals, also called named rooms, i.e., V = {a, b, c, d, e, f, g}. The other rooms
{t0, t1,... , t9} are referred to as unnamed rooms and are represented implic- itly as sub–terms in the corresponding system of unfolding rules Mex := (x ⇐ mx)x∈V with a ⇐ ι.0, b ⇐ 0, c ⇐ ι.(ι.a + ι.ι.(τ.b + ι.ι.0)), d ⇐ ι.(τ.a +
ι.ι.ι.0) + ι.(ι.ι.0 + ι.e), e ⇐ ι.(ι.e + ι.g + τ.g + ι.ι.0), f ⇐ ι.(τ.a + ι.ι.ι.0), g ⇐ ι.(ι.g +ι.e+τ.e+ι.ι.0). Observe that, for any x ⇐ mx, applying the opera- tional rules to mx results in the part of the graph starting from room x. Specif- ically, for f ⇐ mf and mf = ι.(τ.a + ι.ι.ι.0), the first ι in the term corresponds to the visible corridor connecting f and the unnamed room t4 = τ.a + ι.ι.ι.0. From t4, either a secret corridor τ can be taken to room a, or a path of three visible corridors can be followed reaching dungeon t0.





Playing the Maze Game.
We now turn our attention to the game–theoretic semantics of our two– player maze game. For convenience, we will name the players simply A and B. We begin by defining the notions dungeon, path, and turn. Firstly, room m is a dungeon if m−→. Secondly, a path π through a maze M is a sequence
γi
of transitions (mi −→ mi+1)0≤i<k, where k ∈ N ∪ {ω} is referred to as the
length |π| of π. We say that π is finite in case k < ω; otherwise, π is infinite. A path π is maximal if it is either infinite, or if it is finite and m|π| −→. We

γi
abbreviate π’s finite prefix (m	m	)
of length j ∈ N by πj. Finally,

i −→
i+1 0≤i<j

given a finite (prefix of a) path π and assuming player A always starts off
the game, we can determine the player turn(π) whose turn it is in the final


	
room m|π| as follows, where A := B and B := A:
turn(π') if |π| > 0 and π = π'· −τ→

turn(π) :=	turn(π') if |π| > 0 and π = π'· −→ι
A	otherwise, i.e., |π| =0 .
A maze play is determined by the players’ strategies. A strategy is a (par- tial) function α : M ~ {ι, τ }× M such that, for all m ∈ M, if α(m) = 
α1 (m)
(α1(m), α2(m)) is defined then m −→ α2(m). Note that a strategy of a player
does not depend on the opponent’s strategy or on a play’s history. Given
strategies α and β for players A and B, respectively, the play playM (α, β, m)
γi
in maze M starting in room m with player A is a maximal path π = (mi −→
mi+1)0≤i<k in M such that m0 = m, mi+1 = α2(mi) and γi = α1(mi) if
turn(πi)= A, or mi+1 = β2(mi), γi = β1(mi) if turn(πi)= B.
The operational semantics of maze M = (x ⇐ mx)x∈V considers, for each room x, whether player A or B has a winning strategy, or neither of them. Intuitively, A (B) has a winning strategy, if he or she is always able to drive player B (A) into a dungeon, no matter which strategy B (A) employs and always assuming that player A starts off the game. Formally, player A has a winning strategy for room x in M if ∃α ∀β. |playM (α, β, x)| < ω and B = turn(playM (α, β, x)). Dually, player B has a winning strategy for room x in M if ∃β ∀α. |playM (α, β, x)| < ω and A = turn(playM (α, β, x)). If the selected starting player A has a winning strategy for room x, then x is simply called a winning position. If player B has a winning strategy, then x is a losing position. If both players can always avoid dungeons, thus engaging in infinite plays, neither player wins and the play ends in a draw. Accordingly, a position that is neither a winning nor a losing position is referred to as a draw position.
Example 2.2 Consider again maze Mex of Fig. 1. Suppose that the strat- egy α of player A is chosen such that A moves the token, whenever possible, to a named room from V through a secret corridor. Otherwise, he chooses a room ti with the smallest i. The strategy β of player B is that B prefers rooms of the form ti with the smallest i over any V. Yet, overall, B prefers secret corridors whenever there is one. For example, α(d) = t4, α(t6) = t0, β(t4) = a, β(a) = t0, β(t7) = t6.  Thus, the play playMex (α, β, d) is the
path d −→ι	t −τ→ a −→ι	t , along which A loses. In contrast, if player A
0
chooses t7 in the first turn, B would have selected the move to t6, from
where A moves to the dungeon t0 and player B loses. The play in that case
would be d −→ι	t  −→ι	t  −→ι	t . The best player B can do under this new
0
strategy of A is to set β(t7) = e, while otherwise keeping his preference for

secret corridors. In that case the play amounts to a draw along the infinite
path d −→ι	t −→ι	e −→ι	t −τ→ g −→ι	t −τ→ e −→ι	t ··· .
8

Denotational Characterization.
The semantics of mazes in terms of winning and losing positions may also be captured denotationally. The denotational approach relies on two predicates win and lose that take as parameters a maze term m and an en- vironment X. Adapting notational conventions from Esterel, we define an environment X as a set of signed variables x+ and x−, with the meaning that plus–tagged (minus–tagged) variables represent rooms that are known to be winning (losing) positions. Since a single room cannot be both a winning and a losing position, an environment must not contain both x+ and x−, for any x. Predicate win (lose) now holds for m and X if m corresponds to a winning (losing) position relative to X, respectively. Formally, these predicates are defined as the least predicates respecting the following rules:
lose(0,X)	win(x, X)	if x+ ∈ X	lose (x, X)	if x− ∈ X
win(ι.m, X) if lose(m, X)	lose (ι.m, X) if win(m, X)
win(τ.m, X) if win(m, X)	lose (τ.m, X) if lose(m, X) win(m1 + m2 ,X) if win(m1,X) or win(m2,X) lose(m1 + m2,X) if lose(m1,X) and lose(m2,X) .
Intuitively, the dungeon 0 is always a losing position. Room m1 + m2 is a winning position if at least one of m1 or m2 is, since m1 + m2 essentially gives a free choice to the leading player whether to continue with m1 or m2. Dually, m1 + m2 is a losing position if both m1 and m2 are. Room ι.m can only be left by the visible corridor ι to m, thereby giving control to the opponent. Hence, ι.m is a winning (losing) position for the leading player if m is a losing (winning) position for the opponent. Traversing a secret corridor does not change a player’s turn, whence τ.m is a winning (losing) position for the leading player if m is. Thus, by an appropriate choice of visible and secret corridors out of a room x we can make the winning (losing) predicate for x an arbitrary disjunctive (conjunctive) combination of negated and non–negated winning conditions of the immediate successor rooms. This is useful for normal–form representations and explains why we introduce secret corridors into the games model. We now define a function on environments:
maze(M )(X) := win(M, X)+ ∪ lose(M, X)− .
Here, win(M, X) denotes {x ∈V | win(mx,X), x ⇐ mx in M } and lose(M, X) for {x ∈V | lose(mx,X), x ⇐ mx in M }. Additionally, for any subset V ⊆V of variables, V + denotes the set {x+ | x ∈ V } and V − the set {x− | x ∈ V }. It can easily be proved that function maze(M ) is monotonic. Hence, the least fixed point µmaze(M ) of maze(M ) exists, which is taken to be the denotational


semantics of maze M . Moreover, because our universe of variables is finite, one may iteratively compute µmaze(M )= i∈N maze(M )i(∅).
Example 2.3 Let us obtain the sets of winning, losing, and draw positions for maze Mex of Fig. 1. Initially, the predicates that hold are lose(0, ∅) and win(ι.0, ∅). Since a ⇐ ι.0 and b ⇐ 0 we get maze(Mex)(∅) = {a+, b−}. In this environment, f ∈ lose(Mex, {a+, b−}) since f ⇐ ι.(τ.a + ι.ι.ι.0) and win(τ.a+ι.ι.ι.0, {a+, b−}), the latter essentially results from win(τ.a, {a+, b−}). Next we derive c ∈ win(Mex, {a+, b−}) from c ⇐ ι.(ι.a + ι.ι.(τ.b + ι.ι.0)) and the fact that win(a, {a+, b−}) and lose(b, {a+, b−}) both hold. This shows maze(Mex)2(∅) = {a+, c+, b−,f −}. Another iteration confirms this as least fixed point, i.e., µmaze(Mex)= {a+, c+, b−,f −}.
Theorem 2.4 (Coincidence) Let M be a maze and x be a variable.
x is a winning position in M if and only if x+ ∈ µmaze(M ).
x is a losing position in M if and only if x− ∈ µmaze(M ).
The proof of this theorem can be adapted from results on finite symmetric and memory–free games [10]. The only slight twist is that our setting allows for two types of transitions in game graphs, namely visible and secret ones.

Esterel Reactions and Mazes
This section first formally presents the combinational fragment of Esterel which we are concerned with and recalls its constructive behavioral semantics as defined by Berry in [3]. We then give a translation of combinational Esterel programs P into mazes M with the property that winning (losing) positions in M correspond exactly to signals that must (cannot) be emitted in P .

Esterel Reactions.
The syntax of the Esterel fragment, which specifies single reactions and will be used in the remainder, is defined by the following BNF, where s stands for a signal name taken from some (finite) universe S.
P ::= 0	nothing
| !s	emit s
| s+?(P )	present s then P
| s−?(P )	present s else P
| P | P	P ||P
Esterel’s more general choice statement “present s then P1 else P2” can be recovered in our syntax by the term s+?(P1) | s−?(P2) [6]. In this paper we


omit the combinational operators for sequential composition and local signal declaration, though we discuss in Sec. 4 various ways for including the latter. A consequence of this omission is that the completion codes needed in the behavioral semantics’ definition for the full language [3] become obsolete. We do away also with input signals i ∈ I = {i1,... , in}⊆ S. This is possible since the behavior of P under I is equivalent to the behavior of P | !ij1 | ··· | !ijm , where the indexes j1,... , jm ∈ {1,... , n} are exactly those for which signal ijk is present in I [6]. Finally, we further assume that the finite set S of signals includes all signals of the combinational Esterel programs that one wishes to reason about. This restriction is a mere technical convenience and could be dropped by maintaining for every program the finite set of relevant signals, i.e., a “signal sort.”
Berry’s behavioral semantics for Esterel considers statuses of signals. Each signal s ∈S can either be known to be present, i.e., have status s+, or known to be absent, i.e., have status s−, or have an unknown status. For any set S ⊆S we let S+ stand for {s+ | s ∈ S} and S− for {s− | s ∈ S}. Consistent sets E ⊆ S+ ∪S− of signal statuses such that / ∃s. s+ ∈ E and s− ∈ E are referred to as events, with E denoting the set of all events. Given a combinational Esterel program P and an event E, we define the sets must (P, E) and cannot(P, E) of those signals that must and cannot be emitted in P , respectively, relative to the knowledge of the signal statuses in E [3]:


must (0,E)	:= ∅	must (s+
must (!s, E)  := {s}	must (s−
?(P ),E)  :=
?(P ),E)  :=
must (P, E)  if s+ ∈ E
∅	otherwise
must (P, E) if s− ∈ E
∅	otherwise

must (P1 | P2,E)	:= must (P1 ,E) ∪ must (P2,E)
jS	if s− ∈ E

cannot (0,E) := S	cannot (s+?(P ),E) :=
—
cannot (P, E)  otherwise
S	if s+ ∈ E


cannot (P1 | P2 ,E) := cannot (P1,E) ∩ cannot (P2 ,E)
Note that both functions must and cannot are monotonic in E for subset inclusion. Since (E , ⊆) is a finite ∩–semi–lattice, the function
esterel(P )(E) := must (P, E)+ ∪ cannot(P, E)−
has a least fixed point µesterel(P )= i∈N esterel(P )i(∅). This least fixed point defines the behavioral semantics of P .
In [3] the construction of absent signals is based on the complement of the cannot sets, called can sets. Our equivalent formulation brings out an important structural invariant. Firstly, cannot(P, E) is the logical dual of must(P, E), obtained by interchanging ∩ for ∪, ∅ for S, and {s} for S\ {s}. Secondly, must and cannot are exclusive: must(P, E) ∩ cannot(P, E)= ∅, for


any event E. In general, however, must(P, E) ∪ cannot(P, E) /= S, whence must and cannot are not necessarily complements. This is analogous to the situation in two–player games: we will show below that must (cannot) corre- sponds to the construction of winning (losing) positions for the starting player. Elements neither in must (P, E) nor in cannot(P, E) indicate draw positions.

Representing Combinational Esterel Programs as Mazes.
With each Esterel program P we associate a maze ⟨⟨P ⟩⟩ := (a ⇐⟨⟨P ⟩⟩a)a∈S that exactly reflects the semantics of P . Here, signals play the role of variables representing distinguished rooms, and the maze term ⟨⟨P ⟩⟩a describes the game conforming to P that can be played starting in room a. Formally, ⟨⟨P ⟩⟩a is defined along the structure of P as follows.

⟨⟨0⟩⟩a := 0
 ι.0	if s = a
⟨⟨s+?(P )⟩⟩a := ι.(ι.s + ι.⟨⟨P ⟩⟩a)
⟨⟨s−?(P )⟩⟩a := ι.(τ.s + ι.⟨⟨P ⟩⟩a)

⟨⟨!s⟩⟩a :=
0	otherwise
⟨⟨P1 | P2⟩⟩a := ⟨⟨P1⟩⟩a + ⟨⟨P2⟩⟩a .

Intuitively, program 0 that cannot emit any signal, must correspond to a dungeon in which the leading player loses. The forced emission of signal a and absence of signals s /= a in program !a leads to immediate success for the leading player in room a ⇐ ι.0 —or unavoidable loss for the opponent— and loss in any other room b ⇐ 0. A program s+?(P ) that is positively guarded by signal s must emit signal a if, in room a, the leading player has both a winning strategy for s and for room a in the maze corresponding to P . We encode this conjunction into mazes by first giving control to the opponent, who in turn freely decides whether the leading player must continue with his or her play in s or in ⟨⟨P ⟩⟩a. Analogously, a program s−?(P ) that is negatively guarded by signal s must emit a if, in room a, the opponent player has a winning strategy for s, and if the leading player has a winning strategy for ⟨⟨P ⟩⟩a. Finally, an emission of signal a in a parallel composition may occur in either component and is thus encoded by a free choice for the leading player. In terms of maze graphs, parallel composition corresponds to forming the room– wise union (overlay) of corridors. As an example, the translation ⟨⟨P ⟩⟩ of the Esterel program Pex = !a | e+?(!d) | a−?(!d | !f ) | a+?(b−?(!c)) | g+?(e+?(g−?(!e) | e−?(!g))) (slightly optimised using the equivalence ⟨⟨Q⟩⟩s ≡ 0 when s does not occur in Q, as well as m +0 = m, ι.ι.m = m for all m) generates the unfolding rules of Example 2.1 and thus the maze in Fig. 1.
Proposition 3.1 Let P be a combinational Esterel program and E an event.
must(P, E)  = {a ∈S | win(⟨⟨P ⟩⟩a, E)}


cannot(P, E) = {a ∈S | lose(⟨⟨P ⟩⟩a, E)}
This proposition states the desired one–to–one relation between the must – and cannot–analysis in combinational Esterel programs and the determination of winning and losing positions in their corresponding mazes. Its proof can be conducted by induction on the structure of Esterel programs. As a conse- quence of the proposition, the functions esterel(P ) and maze(⟨⟨P ⟩⟩) coincide. This immediately proves the following main theorem of this paper.
Theorem 3.2 (Game–Theoretic Characterization) For every combina- tional Esterel program P, we have µesterel(P )= µmaze(⟨⟨P ⟩⟩).
We conclude this section by revisiting several of the pathological examples from Berry’s book [3]. For each of these combinational Esterel programs Pi (indexed as in Berry’s book), we take S to be the set of all signals occurring in Pi. The programs, except for P6, are illustrated as mazes in Figure 2.

Fig. 2. “Pathological” Esterel examples.

P4 := s+?(!s): According to our definitions we obtain M4 := ⟨⟨P4⟩⟩ = (s ⇐⟨⟨P4⟩⟩s) and m4,s := ⟨⟨P4⟩⟩s = ι.(ι.s + ι.ι.0). Hence, for any event E ∈ E:
win(m4,s, E) ⇐⇒ lose(ι.s + ι.ι.0, E)
⇐⇒ lose(ι.s, E) and lose(ι.ι.0, E)
⇐⇒ win(s, E) and lose(0, E)
⇐⇒ win(s, E) and true
⇐⇒ s+ ∈ E. 
Similarly, lose(m4,s, E)	⇐⇒	s− ∈ E.  This implies maze(M4)(∅) = ∅
according to the definition of function maze(M4), whence µmaze(M4)= ∅.
P3 := s−?(!s): Here we have M3 := ⟨⟨P3⟩⟩ = (s ⇐⟨⟨P3⟩⟩s) and m3,s :=
⟨⟨P3⟩⟩s = ι.(τ.s + ι.ι.0). We may then derive, for any event E ∈ E:
win(m3,s, E) ⇐⇒ lose(τ.s + ι.ι.0, E)
⇐⇒ lose(τ.s, E) and lose(ι.ι.0, E)
⇐⇒ lose(s, E) and true
⇐⇒ s− ∈ E. 
Moreover, lose(m3,s, E) ⇐⇒ s+ ∈ E. As in the case for M4, this implies
maze(M3)(∅)= ∅ and thus µmaze(M3)= ∅.


P0 := s+?(!s) | s−?(!s) = P4 | P3: Hence, M0 := ⟨⟨P0⟩⟩ = (s ⇐⟨⟨P0⟩⟩s) and m0,s := ⟨⟨P0⟩⟩s = ⟨⟨P4⟩⟩s +⟨⟨P3⟩⟩s according to the definition of ⟨⟨·⟩⟩s. Given the calculations for P4 and P3 we easily conclude:
win(m0,s, E) ⇐⇒ win(m4,s, E) or win(m3,s, E)
⇐⇒ s+ ∈ E or s− ∈ E
⇐⇒ lose(m0,s, E) .
It is easy to see that this yields again µmaze(M0)= ∅.
P6 := s+?(!s1) | s+?(!s0): This combinational program gives rise to the maze
0	1
M6 := ⟨⟨P6⟩⟩ = (s0 ⇐⟨⟨P6⟩⟩s0 , s1 ⇐⟨⟨P6⟩⟩s1 ), for m6,s0 := ⟨⟨P6⟩⟩s0 = τ.ι.(ι.s0 +
ι.0) + τ.ι.(ι.s1 + ι.ι.0) and m6,s1 := ⟨⟨P6⟩⟩s1 = τ.ι.(ι.s0 + ι.ι.0) + τ.ι.(ι.s1 + ι.0).
One can then easily infer, for i ∈ {1, 2}, that win(m6,s , E) ⇐⇒ s+	∈ E
i	1−i

and lose(m6,s , E) ⇐⇒ s−
∈ E. Again, this implies µmaze(M6)= ∅.

i	1−i
In all of the examples above, the relevant rooms s, or s0 and s1 in case of M6, are neither winning nor losing positions for the starting player but draw po- sitions. According to Thm. 3.2, all signal statuses are undetermined, and our example programs would be rejected by current Esterel compilers [4]. The game metaphor, thus, yields a natural explanation of constructiveness and non–constructiveness.

Local Signal Declarations
This final section of our main development shows that the game semantics can also support local signal declarations, which is another kernel operation of Esterel [3]. A signal declaration P \s introduces a locally defined signal s that is available for broadcast inside program P only. As an example consider the program (P \s) | Q where P := s+?(!a) | !s and Q := s+?(!b). In Q, signal s refers to a different incarnation than the one used inside P \s, whose scope is restricted by the local signal declaration. Consequently, the internal emission of s in P \s will trigger the emission of signal a in P but not that of signal b in Q.
The simplest way of interpreting local signal declarations in terms of mazes is to rename signal s in ⟨⟨P ⟩⟩ into some fresh signal name s', and to make sure that s' is never used outside of ⟨⟨P \s⟩⟩. While this “naming–apart” technique is a simple solution for a compiler, there is an algebraically more satisfac- tory way. Intuitively, ⟨⟨P \s⟩⟩ is the same as solving the recursive unfoldings characterizing maze ⟨⟨P ⟩⟩ with respect to signal s. If s ⇐ ms is the unfolding rule defining s, the least fixed–point solution for s is µs.ms, where µ denotes the standard fixed–point operator known from process algebra. This recursive term for the game starting in room s is then used, or substituted, wherever s


is referenced in the unfoldings defined by ⟨⟨P ⟩⟩ for all the other rooms. Thus,
s is eliminated. In our example, ⟨⟨P ⟩⟩ is the system
a ⇐ ι.(ι.s + ι.ι.0) + 0   b ⇐ ι.(ι.s + ι.0) + 0   s ⇐ ι.(ι.s + ι.0) + ι.0 ,

from which we obtain the maze equations for ⟨⟨P \s⟩⟩ by substituting the fixed point µs. (ι.(ι.s + ι.0) + ι.0) for every reference to s in the other expansions. The unfolding for s is “reset” to 0:
a ⇐ ι.(ι.(µs. (ι.(ι.s + ι.0) + ι.0)) + ι.ι.0) + 0	s ⇐ 0
b ⇐ ι.(ι.(µs. (ι.(ι.s + ι.0) + ι.0)) + ι.0) + 0 .
In the new system of unfolding rules the behavior of the original signal s is completely encapsulated, so that any extension can only refer to the named rooms a and b. The signal name s remaining in the maze now refers to a fresh signal that is per default not emitted and hence represented by a dungeon. Obviously, the precise technical formalization of this idea requires the addition of the fixed–point operator µs.m to our maze–term language.
Note that treating local signal declarations via fixed–point operators re- quires a slightly more general translation of s+?(P ) and s−?(Q) than the one given above. This observation has already been made by Berry in [3]. Consider, e.g., a positive guard c+?(P \ s) which makes winning inside P \ s dependent on winning signal c. This implies that any room in the maze of P\s can only be won under the extra condition that c can be won as well. This applies to all rooms inside P \s, even to the “local” room s. To give the op- ponent a chance to force the starting player into room c at any point, we may
break up each transition P '\s −→ι	P ''\s inside P \s via an auxiliary room in
which the opponent can choose to challenge the starting player into room c or
accept to continue with P '' \s. Formally, we may replace P ' \s −→ι	P '' \s by
P ' \s −→ι	ι.c + τ.(P '' \s), which can be done by appropriately modifying the
operational rules for maze terms, especially the rules for present statements.

Conclusions and Future Work
This paper presented a game–theoretic semantics for combinational Esterel programs, i.e., for the kernel fragment of Esterel corresponding to combina- tional circuits. Our approach translated combinational programs into finite two–player games in such a way that Esterel’s must and cannot analysis of sig- nal statuses [3] could be rephrased as the computation of winning strategies. Our results complement the existing behavioral, operational, circuit–based, and model–theoretic approaches to Esterel’s semantics [3,6]. In particular, they offer a novel didactic perspective for familiarizing students and engineers


with this intricate constructive semantics, by giving emphasis to more intu- ition (game graphs) and less mathematics (fixed points). It is worth pointing out that our game–theoretic framework is not specific to Esterel but should apply to other synchronous languages incorporating the semantic principles of synchrony and causality as well, such as Pnueli and Shalev’s Statecharts [9]. Regarding future work, we firstly want to extend our work to larger frag- ments of Esterel, especially those involving Esterel’s pause, wait, and loop constructs [3]. This would allow for reasoning about sequences of reactions rather than single reactions, and requires enriching the information content held by states in our game graphs. It should also be investigated how our game semantics relates to the operational semantics implemented in state-of- the-art Esterel compilers. Secondly, we wish to study whether our approach is amenable to a rigorous algebraic treatment. Although we presented mazes in a process–algebraic fashion both in style of a term–based syntax and a transition–systems–based semantics, the associated algebraic theory has not yet been fully developed. An algebraic semantics for mazes could be based on a notion of behavioral equivalence, such as bisimulation. This would provide a compositional semantics for our games and allow for the minimization of mazes. Note that the translation from combinational Esterel programs into mazes presented in this paper does not apply any optimizations. Thirdly, we plan to develop a logical interpretation of our game semantics, similar to the one of AJM’s games model in linear logic [2], thereby further exploring the logic behind Esterel [6]. As part of this plan, the relationship between our term language for mazes and Berry’s calculus of Constructive Boolean Logic [3,11]
deserves investigation.

References
S. Abramsky. Games in the semantics of programming languages. In 11th Amsterdam Colloquium, pages 1–5. Univ. of Amsterdam, 1997.
P. Baillot, V. Danos, T. Ehrhard, and L. Regnier. Believe it or not, AJM’s games model is a model of classical linear logic. In LICS ’97, pages 68–75. IEEE Comp. Soc. Press, 1997.
G. Berry. The constructive semantics of pure Esterel. CMA, Ecole des Mines, INRIA, 1999. Draft version 3.0.
Esterel Technologies. Esterel Studio. www.esterel-technologies.com, 2003.
M. Hyland and L. Ong. On full abstraction for PCF: I, II and III. Inform. and Comput., 163(2):285–408, 2000.
G. Lu¨ttgen and M. Mendler. Towards a model-theory for Esterel. In SLAP ’02, volume 65,5 of ENTCS. Elsevier Science, 2002.
P. Malacaria and C. Hankin. Generalised flowcharts and games. In ICALP ’98, volume 1443 of LNCS, pages 363–374. Springer-Verlag, 1998.


A. Pietarinen and G. Sandu. Games in philosophical logic. Nordic J. Philosophical Logic, 4:143–173, 2000.
A. Pnueli and M. Shalev. What is in a step: On the semantics of Statecharts. In TACS ’91, volume 526 of LNCS, pages 244–264. Springer-Verlag, 1991.
G. Schmidt and T. Str¨ohlein. On kernel of graphs and solutions of games: A synopsis based on relations and fixpoints. SIAM J. Algebraic Discrete Methods, 6:54–65, 1985.
T. Shiple, G. Berry, and H. Touati. Constructive analysis of cyclic circuits. In EDTC ’96, pages 328–333. IEEE Comp. Soc. Press, 1996.
W. Thomas. On the synthesis of strategies in infinite games. In STACS ’95, volume 900 of
LNCS, pages 1–13. Springer-Verlag, 1995.
