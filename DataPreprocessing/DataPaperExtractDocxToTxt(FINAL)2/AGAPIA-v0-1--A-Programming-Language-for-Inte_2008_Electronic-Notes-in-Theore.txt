Electronic Notes in Theoretical Computer Science 203 (2008) 69–94	
www.elsevier.com/locate/entcs

AGAPIA v0.1: A Programming Language for Interactive Systems and Its Typing System
Cezara Dragoi1 ,2 and Gheorghe Stefanescu1
Faculty of Mathematics and Computer Science, University of Bucharest Str. Academiei 14, Bucharest 010014, Romania
Email: {cdragoi,gheorghe}@funinf.cs.unibuc.ro


Abstract
A model (consisting of rv-systems), a core programming language (for developing rv-programs), several specification and analysis techniques appropriate for modeling, programming and reasoning about interac- tive computing systems have been recently introduced by Stefanescu using register machines and space-time duality, see [47]. After that, Dragoi and Stefanescu have developed structured programming techniques for rv-systems and their verification, see, e.g., [14,15,16,17,18].
In the present paper a kernel programming language AGAPIA v0.1 for interactive systems is introduced. The language contains definitions for complex spatial and temporal data, arithmetic and boolean expressions, modules, and while-programming statements with their temporal, spatial, and spatio-temporal versions. In AGAPIA v0.1 one can write programs for open processes located at various sites and having their temporal windows of adequate reaction to the environment. The main technical part of the paper describes a typing system for AGAPIA v0.1 programs.
Keywords: interactive systems, typing systems, AGAPIA programming, rv-programs, registers and voices, distributed termination protocols


Introduction
Interactive computation has a long tradition and there are many successful ap- proaches to deal with the intricate aspects of this type of computation, see [1,2,3,7,9,19,28,49,50], to mention just a few references from a very rich literature. However, a simple model for interactive computation extending the classical, pop- ular imperative programming paradigm is still to be find.
In an attempt to reconcile interactive and imperative computation styles, a model based on register machines and space-time duality have been recently pro- posed by Stefanescu, see [47]. Based on this model, a low level programming lan-

1 The authors acknowledge partial support from the Romanian Ministry of Education and Research (CEEX Program, Project 2-CEx06-11-97 and PNCDI-II Program 4, Project 11052/18.09.2007).
2 Current address: LIAFA, Universite Paris Diderot - Paris 7, France

1571-0661© 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.04.087

guage for writing interactive programs with registers and voices (rv-programs) have been presented [47]. One of the key features of the model is the introduction of high-level temporal data structures. Actually, having high level temporal data on interaction interfaces is of crucial importance in getting a compositional model for interactive systems, a goal not always easy to achieve (recall the difficulties in get- ting a compositional semantics for data-flow networks, [4,5,6,8,29]).
In a couple of papers Dragoi and Stefanescu have developed structured pro- gramming techniques for rv-programs and for their verification, see [14,15,16,17,18]. Here, a kernel structured programming languages AGAPIA v0.1 for interactive systems is introduced and its typing system is studied. 3
A first goal of the present paper is to introduce AGAPIA v0.1 language. An example is P in Sec. 3, an AGAPIA v0.1 program implementing a termination detection protocol. Here, we briefly touch on the key features of the language, with explicit reference to P.
The starting basic blocks for developing AGAPIA programs are “modules” in- herited from rv-programming. Such a module has two types of interfaces: one type is for spatial data, the other is for temporal data. A spatial interface is specified using registers, while a temporal interface is specified using voices, usually imple- mented on streams. Complex spatial and temporal data are built up on top of these primitive types. A module has explicit read/write and listen/speak state- ments for its spatial and temporal data, respectively. An example of module is R in program P.
The AGAPIA v0.1 structured programming operations extend the classical structured programming operations to this context. Composition has extensions to AGAPIA which exploit the multiple possibilities to compose blocks: (1) Verti- cal (or “temporal”) composition via spatial interfaces; (2) Horizontal (or “spatial”) composition via temporal interfaces; (3) Diagonal (or “spatio-temporal”) compo- sition, where both, the spatial and the temporal output data of a block become the spatial and the temporal input data of the next block, respectively. Tempo- ral, spatial, and diagonal compositions are denoted by ‘%’, ‘#’, and ‘$’, respectively. The iterated versions are introduced using the temporal, the spatial, and the diag- onal while statements, denoted by while t, while s, and while st, respectively. Occurrences of most of these statements may be found in program P.
While not subject of the present paper, notice that AGAPIA v0.1 language has a natural scenario-based operational semantics, as well as a compositional relational semantics based on spatio-temporal specifications (see [17,18] or Subsec. 2.3 for brief presentations).
A second goal of the paper is to study the typing system of AGAPIA v0.1. Our particular interest is to use the results for the design of AGAPIA v0.1 compilers. While it is the programmer duty to ensure the correctness of his/her program, our type checking procedure help him/her by checking the types of the programs and

3 The current low level version number reflects the restricted format of the language, particularly a restricted form of mixing structured rv-programming statements and module construction. (See [37] for the new AGAPIA v0.2 version, including stronger modularization techniques.)

returning a four-level answer: (1) ok (from the typing point of view the program is correct); (2) war0 (at each composing interface the sets of types of the composing programs are equal, but not reduced to a singleton, hence a running time miss- typing is possible); (3) war1 (at each composing interface the sets of types of the composing programs have nonempty intersection, hence there is a chance to have a well running program); and (4) err (at a composing interface the sets of types of the composing programs have an empty intersection, hence each running using that piece of code fails).
The paper is organized as follows. It starts with a brief presentation of rv- systems, including: scenarios, operations on scenarios, finite interactive systems, rv- systems and rv-programs. Then, structured rv-programs are introduced and their scenario-based operational semantics is presented. Next, the syntax of AGAPIA v0.1 is presented and an implementation of a termination detection protocol is developed. A more technical section follows, describing the typing systems for AGAPIA v0.1 programs. A few examples and final comments conclude the paper.

Preliminaries
Scenarios
In this subsection we briefly present temporal data, spatio-temporal specifications, grids, scenarios, and operations on scenarios.

Spatio-temporal specifications
To handle spatial data, common data structures and their natural representa- tions in memory are used. For the temporal data, we use streams: a stream is a sequence of data ordered in time and is denoted as a0-a1- .. ., where a0, a1,... are its data at time 0, 1,.. ., respectively. Typically, a stream results by observing the data transmitted along a channel: it exhibits a datum (corresponding to the channel type) at each clock cycle. (See [7,8] for more on streams, temporal specifications, and their algebraic representations.)
A voice is defined as the time-dual of a register: A voice is a temporal data structure that holds a natural number. It can be used (“heard”) at various locations. At each location it displays a particular value.
Voices may be implemented on top of a stream in a similar way registers are implemented on top of a Turing tape, for instance specifying their starting time and their length. Most of usual data structures have natural temporal representations. Examples include timed booleans, timed integers, timed arrays of timed integers, timed linked lists, etc.
When restricted to registers and voices only, a spatio-temporal speciﬁcation S : (m, p) → (n, q) is a relation S ⊆ (Nm × Np) × (Nn × Nq), where m (resp. p) is the number of input voices (resp. registers) and n (resp. q) is the number of output voices (resp. registers). It may be defined as a relation between tuples, written as
⟨v | r⟩ '→ ⟨v' | r'⟩, where v, v' (resp. r, r') are tuples of voices (resp. registers).

1:
x=4
A:
1:
y=nil
B:
1:
z=nil
C:	D
x=4


tx=4


tx=4


aabbabb abbcdbb bbabbca ccccaaa
1 1 1
AaBbBbB 2 1 1
AcAaBbB 2 2 1
AcAcAaB 2 2 2
X
3:
x=2
A:
U
3:
x=1
tx=4 Y
2:
y=4
B:
tx=2 V
2:
Z
2:
z=4
C:	D
W
2:
z=2

A:	B:
tx=1 V
C:	D:
W
U tx=1 V
tx=1 W

2:
x=0
y=4
z=1

(a)	(b)	(c)	(d)
Fig. 1. A grid (a), an abstract scenario (b), and concrete scenarios (c,d).
Specifications may be composed horizontally and vertically, as long as their types agree. For instance, for two specifications S1 : (m1, p1) → (n1, q1) and S2 : (m2, p2) → (n2, q2) the horizontal composition S1 d S2 is defined only if n1 = m2 and the type of S1 d S2 is (m1, p1 + p2) → (n2, q1 + q2).

Grids and scenarios
A grid is a rectangular two-dimensional area filled in with letters of a given alphabet. An example of a grid is presented in Fig. 1(a). In our standard inter- pretation, the columns correspond to processes, the top-to-bottom order describing their progress in time. The left-to-right order corresponds to process interaction in a nonblocking message passing discipline: a process sends a message to the right, then it resumes its execution.
A scenario is a grid enriched with data around each letter. The data may have various interpretation: they either represent control/interaction information, or current data of the variables, or both. Fig. 1(b) illustrates the first case, Fig. 1(c) the last case, and Fig. 1(d) the middle case. Notice that the scenario from Fig. 1(d) is similar to that in (c), but the control/interaction labels A,B,C,1,2,3 are omitted. The scenarios of a rv-program look like in (c), while those of structured rv-programs as in (d) - there are no control/interaction labels in the latter case.
The type of a scenario interface is represented as t1; t2; ... ; tk, where each tk is a tuple of simple types used in the scenario cells. 4 An empty tuple is also written 0 or nil and can be freely inserted to or omitted form such descriptions. The type of a scenario f is specified by the notation f : ⟨w|n⟩ → ⟨e|s⟩. For the example in Fig. 1(d), the type is ⟨nil; nil; nil|sn; nil; nil⟩ → ⟨nil; nil; nil|sn; sn; sn⟩, where sn denotes the spatial integer type.

Operations with scenarios
We say two scenario interfaces t = t1; t2; ... ; tk and t' = t' ; t' ; ... ; t' ' are equal
1  2	k
if k = k' and the types and the values of each pair ti, t' are equal. Two interfaces
are equal up to the insertion of nil elements, written t =n t', if one can insert nil
elements into these interfaces such that the resulting interfaces are equal.

4 If only registers and voices are used, then one may simply replace each tuple by the number of its components.

We denote by Idm,p : ⟨m|p⟩ → ⟨m|p⟩ the identity constant, i.e., the tempo- ral/spatial output is equal to the temporal/spatial input, respectively.




(a)	(b)	(c)
(d)
(f) (e) (g)

Fig. 2. Operations on scenarios

Horizontal composition: Suppose we start with two scenarios ƒi : ⟨wi|ni⟩ →
⟨ei|si⟩, i = 1, 2. Their horizontal composition ƒ1 d ƒ2 is defined only if e1 =n w2. For each inserted nil element in an interface, a dummy row is inserted in the corresponding scenario, resulting a scenario ƒi. After these transformations, the result is obtained putting ƒ1 on left of ƒ2. Notice that ƒ1 : ⟨w1|n1⟩ → ⟨t|s1⟩ and ƒ2 : ⟨t|n2⟩ → ⟨e2|s2⟩, where t is the resulting common interface. The result, ƒ1 d ƒ2 : ⟨w1|n1; n2⟩ → ⟨e2|s1; s2⟩, is unique up to insertion or deletion of dummy rows. See Fig. 3 (and Fig. 2(b)). Its identities are Idm,0.


 A nil B
A B
nil

(a)	(b)	(c)
Fig. 3. Horizontal composition of scenarios

Vertical composition: The definition of vertical composition ƒ1 · ƒ2 is similar, but now s1 =n n2. For each inserted nil element, a dummy column is inserted in the corresponding scenario, resulting a scenario ƒi. The result, ƒ1 · ƒ2 : ⟨w1; w2|n1⟩ → 
⟨e1; e2|s2⟩, is obtained putting ƒ1 on top of ƒ2. See Fig. 2(a). Its identities are Id0,m.
Constants: Except for the already defined identities I, additional constants may be used. Some of them may be found in Fig. 2: A recorder R (2nd cell in the 1st row of (c)), a speaker S (1st cell in the 2nd row of (c)), an empty cell Λ (3rd cell in the 1st row of (c)), etc.
Diagonal composition: The diagonal composition ƒ1 • ƒ2 is defined only if e1 =n
w2 and s1 =n n2. It is a derived operation defined by
ƒ1 • ƒ2 = (ƒ1 d R1 d Λ1) · (S2 d Id d R2) · (Λ2 d S1 d ƒ2)
for appropriate constants R, S, Id, Λ. See Fig. 2(c). In this case R1 : ⟨t| ⟩ → ⟨ |t⟩, S1 : ⟨ |t⟩ → ⟨t| ⟩, Id : ⟨u|t⟩ → ⟨u|t⟩, R2 : ⟨u| ⟩ → ⟨ |u⟩, S2 : ⟨ |u⟩ → ⟨u| ⟩, where t (resp. u) is a common representation for e1 and w2 (resp. s1 and n2) obtained inserting nil elements. Its identities are Idm,n.

Rv-systems
In this subsection we briefly describe rv-programs (interactive programs with reg- isters and voices); see [47] for more details.

Finite interactive systems
A ﬁnite interactive system (shortly fis) is a finite hyper-graph with two types of vertices and one type of (hyper) edges: the first type of vertices is for states (labeled by numbers), the second is for classes (labeled by capital letters) and the edges/transitions are labeled by letters denoting the atoms of the grids; each transition has two incoming arrows (one from a class and the other from a state), and two outgoing arrows (one to a class and the other to a state). Some classes/states may be initial (indicated by small incoming arrows) or ﬁnal (indicated by double circles); see, e.g., [46,47]. An example is shown below.
For the parsing procedure, given a fis F and a grid w, insert initial states/classes at the north/west border of w and parse the grid completing the scenario according to the fis transitions; if the grid is fully parsed and the south/east border contains final states/classes only, then the grid w is recognized by F . The language of F is

the set of its recognized grids. A fis F  and a parsing for	abb
cab
cca
are shown below.



F1 =


Interactive programs with registers and voices
An rv-system (interactive system with registers and voices) is a fis enriched with: (i) registers associated to its states and voices associated to its classes; and
(ii) appropriate spatio-temporal transformations for actions (that is, for the letters labeling the edges).
We study programmable rv-systems specified using rv-programs. An example of rv-program is presented in Fig. 4. A computation is described by a scenario like in a fis, but with data around each cell (the data represent values of their spatial and temporal variables); see Fig. 1(c) for an example.

Syntax of rv-programs
The syntax is based on the syntax used in imperative programming languages. The basic block is a module. To explain the syntax, let us focus on the first module of the program Perfect in Fig. 4. It has a name X and 4 areas: (1) In the top-left part we have a pair of labels (A,1) which specifies the interaction and control coordinates where this module has to be applied. (2) The top-right part declares the spatial input variables. (3) The bottom-left part declares the temporal input variables. (4)

in: A,1; out: D,2
Fig. 4. The rv-program Perfect (for perfect numbers)

The body of a module is its bottom-right part, including type declarations and C- like code. The exit from the module is specified by a goto statement. A statement like goto [B,3] indicates that: (i) the data of the spatial variables in the current module will be used in a next module with control state 3; (ii) the data of the temporal variables in the current module will be used for the interaction interface of a new module with interaction label B.

Operational and denotational semantics of rv-programs
The operational semantics is given in terms of scenarios. Scenarios are built up with the following procedure, described using the scenario in Fig. 1(c) for the rv-program Perfect:
Each cell has a module name as label.
In the areas around a cell we show how variables are modified.
In a current cell, the values of spatial variables are obtained going vertically up and collecting the last updated values.
Similarly, the full information on temporal variables in a current cell is obtained collecting their last updated values going horizontally on left.
The first column has an input class and particular values for its temporal variables; the first row has an input state and particular values for its spatial variables.
The computation in a cell α is done as follows: (i) Take a module β of the program bearing the class label of the left neighboring area of α and the state label of the top neighboring area of α. (ii) Follow the code in β using the spatial and the temporal variables of α with their current values. (iii) If the local execution of β is finished with a goto [Γ, γ] statement, then the label of the right neighboring area of α is set to Γ and the label of the bottom neighboring area of α is set to γ. (iv) Insert the values of the temporal variables updated by β in the right neighboring area of α and the values of the spatial variables updated by β in the bottom neighboring area of α.
A partial scenario (for an rv-program) is a scenario built up using the above rules; it is a complete scenario if the bottom row has only final states and the rightmost column has only final classes.

The scenario in Fig. 1(c) is a complete scenario for the rv-program Perfect.
The input-output denotation of an rv-program is the relation between the input data on the north/west borders and output data on the south/east borders of the program scenarios.
Notice that a global scoping rule is implicitly used here: once defined, a variable is always available. It is also possible to introduce rv-programs obeying a stronger typing discipline, where each module comes with an explicit type at each border. This option is actually used for structured programs to be introduced in the next subsection.

Space-Time Duality
Space-time duality interchanges information in space and information in time, e.g., registers and voices. Then, it is naturally lifted to grids, scenarios, fis-es, spatio-temporal specifications, rv-systems, and rv-programs, which are all space- time invariant. The space-time operator ∨ is defined by:
On grids: transpose the grid; replace each letter by a dual letter;
On fis-es: interchange states and classes; replace each letter by a dual letter;
On scenarios: apply ∨ to the underlying grid; around each letter interchange input registers with input voices and output registers with output voices ;
On rv-programs, in each module: interchange class and state labels; interchange temporal and spatial data; switch top-right and bottom-left corners; (notice that, except for label and variable type change, no more modifications are needed in the body of a module).
Theorem 2.1 For any rv-program R, its space-time dual R∨ is an rv-program and (R∨)∨ = R. Moreover, space-time duality respects operational semantics and input- output denotation of rv-programs.

Structured rv-programs
The rv-programs, presented in [47] (and briefly recalled in the previous subsection), resemble flowcharts and assembly languages: one freely uses goto statements, with both temporal and spatial labels. The aim of this section is to introduce struc- tured programming techniques on top of rv-programs. The resulting structured rv- programs may be described directly, from scratch. The lower level of rv-programs is used as a target language for compiling.

The syntax of structured rv-programs
The syntax is given by the BNF grammar
P ::= X | iƒ (C)then{P }else{P }| P %P | P #P | P $P
| while t(C){P }| while s(C){P }| while st(C){P }
X ::= module{listen t vars}{read s vars}{code; }{speak t vars}{write s vars}

Structured rv-programs use modules X as their basic blocks. On top of them, larger programs are built up by “if” and composition and iteration constructs for the vertical, the horizontal, and the diagonal directions 5 . These statements aim to capture at the program level the corresponding operations on scenarios.

On structured programming operations
Our choice of the above structured programming statements is determined by practical considerations: to have a set of easy to understand and use statements. Actually, these three types of composition and iterated composition statements are instances of a unique more general and complex, but less “structured” form:
P 1 comp{tv}{sv} P 2 and while{tv}{sv}{C}{P }
In this case, at an identification border, only a part of the connecting interfaces is to be matched, namely the tv part at a temporal interface and the sv part at a spatial interface. (The operations are illustrated in Fig. 5; see [43] for translations between “while” and “feedback” operations.)
Then, the horizontal form correspond to the choice tv = all, ts = ∅, the vertical form to tv = ∅, ts = all, and the diagonal form to tv = all, ts = all. To state it formally,
Proposition 2.2 Either {comp} or the pair {#, %} suffices to represent all com- position operations in {#, %, $, comp}, provided constants as those in Fig. 2 may be used. All particular iteration operators in {while t, while s, while st} are instances of the general while operator.

Fig. 5. General “composition” and “feedback” (equivalent to “while”)

Currently, we do not know whether the general while may be simulated using the particular forms in {while t, while s, while st}.

Examples
We include a simple, but rather general example of structured rv-program to give a clue to the reader on the naturalness and the expressiveness of the language. (See [14,17,18] for more examples.)

5 The iteration operators are also called the temporal, the spatial, and the spatio-temporal while statements.

The structured rv-program for a termination detection protocol, to be presented in full detail in a next section, has the following format
P :: [I1# for s(tid=0;tid<tn;tid++){I2}#] $
[while st(!(token.col==white && token.pos==0)){ for s(tid=0;tid<tn;tid++){R}}]
It starts with an initialization step where processes are created and inserted into the ring. Next, an autonomous “diagonal” iteration takes places where, in each step, the processes do their jobs and interact horizontally by passing a message list from one process to the next, in the order from process 0 to process tn-1. At the end of an iteration, if the guard condition is fulfilled, a new iteration takes place where the message list of process tn-1 is passed to process 0 and all processes continue the execution from their last memory states.
Such a program is rather generic and it may be used for many other problems, like n-player games, 8-queen problem, implementations of OO-systems based on message passing communication, etc.
The dynamic case where processes may freely join or leave the ring is an easy extension using the general while. By replacing in the above code while st by
while{all\k}{all}
we get a program where k is a temporal variables coming from the external temporal interface, not from R; this k may be used to specify the number of new processes that have to be inserted into the ring, a procedure that is handled as in I2. (A slightly different approach is presented in [37] using high-level structured rv-programs.)
Operational semantics of structured rv-programs
The operational semantics
| | : Structured rv-programs → Scenarios associates to each program the set of its possible running scenarios.
The type of a program P , which is denoted by P : ⟨w(P )|n(P )⟩ → ⟨e(P )|s(P )⟩, indicates the types at its west, north, east, and south border. On each side, the type may be quite complex (see AGAPIA interface types in Sec. 3). In their specification, the convention is to separate by “,” the data coming from within a module and by “;” the data coming from different modules. This convention refer to both, spatial data (coming from different processes) and temporal data (coming from different transactions).
Two interface types match if they have a nonempty intersection.

Modules
The starting blocks for building structured rv-programs are the modules. The listen (read) instruction is used to get the temporal (spatial) input and the speak (write) instruction to return the temporal (spatial) output. The code consists in

simple instructions as in the C code. No distinction between temporal and spatial variables is made within a module.
A scenario for a module consists of a unique cell, with particular data on the borders, and such that the output data are obtained from the input data applying the module code.

Composition
Due to their two dimensional structure, programs may be composed horizontally and vertically, as long as their types on the connecting interfaces agree. They can also be composed diagonally by mixing the horizontal and the vertical compositions.
Suppose two programs Pi : ⟨wi|ni⟩ → ⟨ei|si⟩, i = 1, 2 are given. We define the following composition operators.
Horizontal composition: P1#P2 is defined if the interfaces e1 and w2 match. The type of the composite is ⟨w1|n1; n2⟩ → ⟨e2|s1; s2⟩. A scenario for P1#P2 is a horizontal composition of a scenario in P1 and a scenario in P2.
Vertical composition: P1%P2 is similarly defined.
Diagonal composition: P1$P2 connects the east border of P1 to the west border of P2 and the south border of P1 to the north border of P2. It is defined if each pair of interfaces e1, w2 and s1, n2 matches. The type of the composite is ⟨w1|n1⟩→ ⟨e2|s2⟩. A scenario for P1$P2 is a diagonal composition of a scenario in P1 and a scenario in P2.

If
Given two programs Pi : ⟨wi|ni⟩ → ⟨ei|si⟩, i = 1, 2, a new program Q =
iƒ (C) then P1 else P2 is constructed, for a condition C involving both, the tempo- ral variables in w1 ∩ w2 and the spatial variables in n1 ∩ n2. The type of the result is Q : ⟨w1 ∪ w2|n1 ∪ n2⟩→ ⟨e1 ∪ e2|s1 ∪ s2⟩.
A scenario for Q is a scenario of P1 if the data on west and north borders of the scenario satisfy condition C, otherwise it is a scenario of P2.

While
We have introduced three while statements, each being the iteration of a corre- sponding composition operation.
Temporal while: For a program P : ⟨w|n⟩→ ⟨e|s⟩, the statement while t (C){P } is defined if the interfaces n and s match and C is a condition on the spatial variables in n ∩ s. The type of the result is ⟨(w; )∗|n ∪ s⟩ → ⟨(e; )∗|n ∪ s⟩. A scenario for while t (C){P } is either an identity (if C is false), or a repeated vertical composition ƒ1 · ƒ2 · ... · ƒk of scenarios for P , such that the north border of each ƒi satisfies C, while the south border of ƒk does not satisfy C. 6
Spatial while: The spatial version while s (C){P } is similar.

6 When the body program P of a temporal while has dummy temporal interfaces, the temporal while is the same as the usual while from imperative programming languages.

Spatio-temporal while: If P : ⟨w|n⟩ → ⟨e|s⟩, the statement while st (C){P } is defined if each pair of interfaces w, e and n, s matches and C is a condition on the temporal variables in w ∩ e and the spatial variables in n ∩ s. The type of the result is ⟨w ∪ e|n ∪ s⟩→ ⟨w ∪ e|n ∪ s⟩. A scenario for while st (C){P } is either an identity (if C is false), or a repeated diagonal composition ƒ1 • ƒ2 • ... • ƒk of scenarios for P , such that the west and north border of each ƒi satisfies C, while the east and south border of ƒk does not satisfy C.
The AGAPIA v0.1 language
The syntax of the AGAPIA v0.1 programs and an example are presented in this section. Extended comments, a type checking procedure, more examples are all deferred for the next section.
The syntax
Interfaces
SST ::= nil | sn | sb
| (SST ∪ SST ) | (SST, SST ) | (SST )∗
ST ::= (SST ) | (ST ∪ ST ) | (ST ; ST ) | (ST ; )∗
STT ::= nil | tn | tb
| (STT ∪ STT ) | (STT, STT ) | (STT )∗
TT ::= (STT ) | (TT ∪ TT ) | (TT ; TT ) | (TT ; )∗
Expressions
V ::= x : ST | x : TT | V (k)
| V.k | V.[k] | V @k | V @[k]
E ::= n | V | E + E | E ∗ E | E − E | E/E B ::= b | V | B&&B | B||B | !B | E < E
Programs
W ::= nil | new x : SST | new x : STT
| x := E | iƒ (B){W }else{W }
| W ; W | while(B){W }
M ::= module{listen x : STT }{read x : SST }
{W ; }{speak x : STT }{write x : SST }
P ::= nil | M | iƒ (B){P }else{P }
| P %P | P #P | P $P
| while t(B){P } | while s(B){P } | while st(B){P }
Fig. 6. The syntax of AGAPIA v0.1 programs
The syntax of the AGAPIA v0.1 programming language is presented in Fig. 6. This version of the language is intentionally kept simple to illustrate the key features of our approach.
With respect to the scoping discipline, we depart here from the global “once de- clared, always available” discipline used in rv-programs [47]. Here, via the module

construct, one is able to discards variables, as well. For instance, a newly declared temporal variable which is not present in the speak statement of a module is dis- carded from its temporal interface.
The types for spatial interfaces are built up starting with integers and booleans, denoted sn, sb, and applying ∪, ‘,’, ( )∗ to get process interfaces, and then applying
∪, ’;’, ( ; )∗ to get system interfaces. They look slightly too complicate. An argu- ment presented in Example 4.1 shows that whenever if and the temporal, spatial, and spatio-temporal composition and while statements are legitimate program- ming constructs, we have to allow such types. Similarly, the temporal types are introduced. Examples are included in the next section.
In practical programs, the description of data types will follow a more conven- tional approach: Star defines an array, hence the usual [ ] notation will be used. For union types, the “or” keyword will be used. Finally, the “,” and “;” product types are specified using the record notation, with items separated by “,” and “;”, respectively.
Given a type V , the notations V (k), V.k, V.[k],V @k, V @[k] are used to refer to its components. For instance, in the case of spatial interfaces, they refer to: V (k)- a component of a choice; V.k - a component of a tuple within a process; V.[k] - a component of an iterated tuple within a process; V @k - a component of a tuple of processes; and V @[k] - a component of an iterated tuple of processes.
Expressions, usual while programs, modules, and structured rv-programs are naturally introduced. This v0.1 version of AGAPIA has a strongly restricted for- mat: the module and the rv-programming statements are not mixed (see [37] for a new, more powerful release: AGAPIA v0.2.). The development starts with simple while programs, then modules are defined, and finally AGAPIA v0.1 programs are obtained applying structured rv-programming statements on modules. 7
Finally, notice that the language is space-time invariant. This means, one can formally define a space-time duality operator which maps an AGAPIA v0.1 program P to an AGAPIA v0.1 program P ∨ such that P = P ∨∨.
A useful derived statement, to be used in the sequel, is a simple form of a spatial “for” statement
for s(i=a;i<b;i++){R}
This is a macro for the pure AGAPIA v0.1 program

i=a# while s(i<b){R# i++#}

where i=a or i++ denotes a module with such a code, with empty spatial interfaces, and whose temporal interfaces are equal to the temporal interfaces of R (we suppose, i is included in the temporal interfaces of R).


7 Notice that the general while (presented in Subsec. 2.3) is not included in this version.

An example: Dual-pass termination detection protocol
We describe a slightly extended 8 AGAPIA v0.1 program P that implements a dual pass termination detection protocol for a network of distributed processes logically organized into a ring. This is a popular termination detection protocol, see, e.g., [13].
The protocol is used for termination detection of a ring of processes. It can handle the case when processes may be reactivated after their local termination. To this end, it uses colored (i.e., black or white) tokens. Processes are also colored: a black color means global termination may have not occurred. Then, the algorithm works as follows:
The root process P0 becomes white when it has terminated and it generates a white token that is passed to P1.
The token is passed through the ring from one process Pi to the next when Pi has terminated. However, the color of the token may changed. If a process Pi passes a task toa process Pj with j < i, then it becomes a black process; otherwise it is a white process. A black process will pass on a black token, while a white process will pass on the token in its original color. After Pi has passed on a token, it becomes a white process.
When P0 receives a black token, it passes on a white token; if it receives a white token, all processes have terminated.
Suppose there are m processes, denoted 0,...,m-1. Besides the input m, the program uses the spatial variables id : sInt, c : {white, black}, active : sBool and the temporal variables tm, tid : tInt, msg : tIntSet[ ]. (sInt, sBool, tInt, and tIntSet stands for spatial integers, spatial booleans, temporal integers, and temporal sets of integers, respectively.)
The program P is presented in Fig. 7. It is the diagonal composition P = I $ Q of an initialization program I and a core program Q. The diagonal composition ensures the communication of the last process with the first, as well as a correct continuation of each process execution from the former state. It is worthwhile to mention that the system here is closed. By a small change, it is possible to model an open version where processes may freely join or leave the ring.
The spatial variables id, c, active represent the process identity, its color, and its active/passive status. The temporal variables used in this program are: (i) tm,tid - temporal versions of m,id; (ii) msg[ ] - an array of sets, where msg[k] contains the id of the source processes of the pending messages sent to process k;
(iii) token.col - an element of {white,black} representing the color of the token; and (iv) token.pos - the number of the process that has the token.
The program starts with the initialization of the network (program I) by acti- vating all the processes (and setting the fields id, c, active). Initially, msg[i]= ∅, for all 0 ≤ i < m, because no jobs were sent and the default color/position of the

8 In this extension, except for simple and common programming conventions, we suppose to have an implementation of sets with their basic operations.



The program is P = I $ Q where:
I = I1# for s(tid=0;tid<tm;tid++){I2}# I1 = module{listen nil}{read m}{
tm=m; token.col=black; token.pos=0;
}{speak tm,tid,msg[ ],token(col,pos)}{write nil}
I2 = module{listen tm,tid,msg[ ],token(col,pos)}{read nil}{ id=tid; c=white; active=true; msg[id]=emptyset;
}{speak tm,tid,msg[ ],token(col,pos)}{write id,c,active}
Q = while st(!(token.col==white && token.pos==0)){ for s(tid=0;tid<tm;tid++){R}}
R = module{listen tm,tid,msg[ ],token(col,pos)}{read id,c,active}{ if(msg[id]!=emptyset){ //take my jobs
msg[id]=emptyset; active=true;}
if(active){ //execute code, send jobs, update color delay(random time);
r=random(tm-1);
for(i=0;i<r;i++){ k=random(tm-1); if(k!=id){msg[k]=msg[k]∪{id}}; if(k<id){c=black};}
active=random(true,false);}
if(!active && token.pos==id){ //termination if(id==0)token.col=white;
if(id!=0 && c==black){token.col=black;c=white};
token.pos=token.pos+1[mod tm];}
}{speak tm,tid,msg[ ],token(col,pos)}{write id,c,active}

Fig. 7. An AGAPIA v0.1 program for termination detection




token is black/0.
After the initialization part and until the first process receives a white token back, each process executes its code. If one process has the token and terminates, it passes the token to the next process (only the first process has the right to change the color of the token into white once it terminates).
When a process executes the code R, whether active or passive, it checks if new jobs were assigned to it; if the answer is positive, it collects its jobs from the jobs list and stays/becomes active. When it is active, it executes some code, sends new jobs to other processes, and randomly goes to an active or passive state. If it has the token, it keeps it until it reaches termination and afterward it passes it. A white process will pass the token with the same color as it was received and a black process will pass a black token (after passing the token, the process becomes white).

Types for AGAPIA v0.1 programs
In this section we present a typing system for AGAPIA v0.1 programs. The starting types are those used for the declared variables. The typing is naturally extended to expressions, simple while-programs, modules, and full AGAPIA v0.1 programs.
Interface types
In the representation of the types for interfaces we use two special separators “,” and “;”. On spatial interfaces, the role of “,” is to separate the types of the (spatial) variables used within a specific process, while “;” is used to separate the types of the variables from different processes. On temporal interfaces, the first separator “,” is used to separate the types of the temporal variables used within the same transaction, while the second separator “;” is a deliminator for the temporal vari- ables which occur in different transactions. Finally, union of types, denoted by “∪”, is allowed.

Simple spatial types
Simple spatial types are obtained with the following syntax:
SST ::= nil | sn | sb | (SST ∪ SST ) | (SST, SST ) | (SST )∗
where “,” and “nil” respect the monoid laws 9 and “∪” is associative. They are intended to be used in a process.
An example is ((((sn)∗)∗, sb, (sn, sb, sn)∗)∗, (sb ∪ sn)). In a conventional repre- sentation, the type represents two variables (x, y), where x an array of type struc1 and y is a boolean or an integer 10 . Next, struc1 is a structure with three fields (a, b, c), where a is an array of arrays of integers, b is a boolean, and c is an array of type struc2. Finally, struc2 is a structure with three fields (p, q, r), where p is an integer, q a boolean, and r an integer. Inserting such variables, one may write the type as
x:	struc1[], where
struc1 = ( a:	Int[][],
b:	Bool,
c:	struc2[], where
struc2 = (p:Int, q:Bool, r:Int)
),
y:	Bool or Int

General spatial types
General spatial types specify system interfaces, i.e., the spatial type of a collec- tion of processes running in different nodes. They are obtained with the following syntax:

9 I.e., “,” is associative, and has nil as a neutral element.
10 This is a simple instance of a polymorphic type.

ST ::= nil | (SST ) | (ST ∪ ST ) | (ST ; ST ) | (ST ; )∗
where, as above, “;” and “nil” respect the monoid laws and “∪” is associative. 11
An example is ((sn)∗)∗; nil; sb; ((sn)∗; )∗. This represents the spatial type of a collection of processes (A, B, C, D), where A is a process using an array of arrays of integers, B is a process with no starting spatial data 12 , C is a process using a boolean variable, and D is an array of processes, each process using an array of integers. Notice the difference between the first and the last subexpressions: In ((sn)∗)∗ both iterates are in the same place, while in ((sn)∗; )∗ the first iterate is in a certain place (within a process), while the second is spread on different places, hence generating an array of differently located processes. 13

Temporal types
They are similarly handled (use space-time duality).

Reshaping types
One may use transformed speakers and recorders 14 (i.e., space-to-time and time- to-space converters mixed with identities [17]) to reshape the spatial interfaces. For instance, there is a natural morphism from (sn; )∗ to (sn)∗, which may be imple- mented as follows: (1) use generalized speakers to transform the spatial integers sn into temporal integers tn and to propagate them along the processes; then, (2) use a large recorder to transform the temporal integers received at the temporal output interface of the last process into an array of spatial integers on a unique process. Formally, the morphism is
TSє,a1 d TS(a1)∨,a2 d TS(a1,a2)∨,a3 d ... d TS(a1,a2,...,an−1)∨,an d R(a1,a2,...,an)∨
: ⟨(a1; a2; ... ; an)| ⟩ → ⟨(a1, a2,... , an)| ⟩ 
where TSa,b is a generalized speaker of type ⟨a|b⟩ → ⟨a, b∨| ⟩ and Ra is a recorder of type ⟨a| ⟩ → ⟨ |a∨⟩. 15

Types vs. formal languages
Ultimately, the types specify complex structures of occurrences of primitive types. In a variable-free approach, two types may be considered equal if the formal languages represented by their expressions are equal. A simple example involving data structures from a single process is (sn, (sn)∗)= ((sn)∗, sn). It corresponds to

11 As usual, redundant parentheses are often omitted. E.g. the syntactically different expressions nil and (nil) or (a; (b; c)) and a; b; c are identified.
12 A typical example is the creation of a process or an object where the starting data come from their temporal interfaces (using a message, or a constructor).
13 To be more consistent, we should perhaps include the delimiter “,” also in the definition of SST using (SST, )∗. But the notation becomes a bit boring; e.g., the above type would become ((((sn, )∗, )∗, sb, (sn, sb, sn, )∗, )∗, (sb ∪ sn)). The case of “;” looks more natural as we are familiar with the use of “;” as a specification of the termination of a statement in usual imperative programming lan- guages.
14 They are presented in Subsec. 2.1, Fig. 2(e)(g).
15 Here, ∨ denotes the space-time duality operator, ‘,’ is a generic notation for the monoidal operation on simple spatial or temporal interfaces, and d denoted horizontal composition.

a list where the first (on left) and the last (on right) element is emphasized, respec- tively. In a conventional representation, they are represented as (x : Int, y : Int[ ]) and (z : Int[ ],w : Int). They look different, but there is a matching function which may be used to connect these interfaces 16 . Such an approach is common in functional programming studies dedicated to abstract data type, see, for instance, [38]. One can argue on the soundness of the equality (sn; (sn; )∗) = ((sn; )∗; sn) in our setting, as well. We do not use this implicit matching from “variable-free programming,” hence the interface matching below will be more restrictive. For instance, the above identification is accepted provided one has specific constants to reshape these interfaces.

Typing expressions
The typing here is relatively easy, provided one starts with proper types for V in both, E and B.

Typing declarations
The syntax for type declarations is x : ST or x : TT . In order to handle such complex data types, a mechanism for accessing their primitive integer or boolean components is needed. We use the following notation:
(k) for accessing the k-th element of an alternative choice (separated by “∪”)
.k for accessing the k-th element of a structure (separated by “,”)
.[k] for accessing the k-th element of an array (defined by (...)∗); @k for accessing the k-th process/transaction (separated by “;”)
@[k] for accessing the k-th process/transaction of an array of processes/transactions (defined by “(...; )∗”)
With this convention, if w is a datum with the type presented in a previous para- graph, i.e., ((((sn)∗)∗, sb, (sn, sb, sn)∗)∗, (sb ∪ sn)), then a component corresponding to the 2nd sb, (i.e., the q component of the above conventional representation of this type) may be specified by w.1.[i].3.[j].2, for appropriate i, j. For another example, if w : ((sn)∗)∗; nil; sb; ((sn ∪ sb)∗; )∗ the integer data corresponding to the last sn may be accessed by w@3@[i].[j](1). Notice that nil does not increase the counter.

Typing spatial variables
For a spatial variable V , the type σ(V ) represents its type, paired with a flag in
{ok, war0, err} indicating ok, a warning, or an error resulting from an attempt to access its components. A min function is defined on the set {ok, war0, war1, err}, thought of as an ordered set, decreasing from left to right (it returns the minimum of two elements). The typing is presented in Fig. 8.

16 For instance, if y, z have equal nonzero length it maps x in z[0], then y[0..len − 1] in z[1..len], and finally,
y[len] in w; if both are empty, it maps x in w; if the lengths are different, an error is raised.

σ(x : ST )= (ok, ST )


σ(x(k))	= ⎨

is the type of its k-th component

⎪⎩ (err, not defined) otherwise


σ(x.k)	= ⎨

α is the type of its k-th component

⎪⎩ (err, not defined) otherwise


σ(x[k])	= ⎨

α is the type of its components

⎪⎩ (err, not defined) otherwise


σ(x@k)	= ⎨

α is the type of its k-th component

⎪⎩ (err, not defined) otherwise


σ(x@[k]) = ⎨


and α is the type of its components

⎪⎩ (err, not defined) otherwise
Fig. 8. Typing spatial variables


Typing temporal variables
This case is similar to the case of spatial variables.



Typing arithmetic expressions
For an arithmetic expression, we collect in a set the variables occurring in the expression, together with their types. The leafs of the expression should have an integer sn or tn type, otherwise the error type err is associated. The typing of the leafs is naturally extended to the full expression, collecting the types of the components and propagating their ok, war0, err status flags.



Typing boolean expressions
For boolean expressions the typing is similar: The starting variables should have a boolean sb or tb type, otherwise the error type err is associated. This starting typing is extended to full expressions as above.

Typing programs
The types of AGAPIA v0.1 programs may be specified using the following mapping from programs to types
σ : P '→ (stσ(P ), ⟨wσ(P )|nσ(P )⟩→ ⟨eσ(P )|sσ(P )⟩)
where:
The status flag st is an element of {ok, war0, war1, err} specifying whether the program is: (1) well-typed; (2-3) partially well-typed with two levels of warning: a weak warning message war0 and a stronger warning message war1; or (4) wrongly typed. 17 When st = err, the second component is meaningless.
On each west, north, east, or south interface, the type wσ(P ), nσ(P ), eσ(P ), or
sσ(P ) consists of a set of variables paired with their associated types.
The comparison for the type matching on an interface proceeds along the fol- lowing steps: (1) Check if the same set of variables is used; (2) For each variable the comparison returns: ok - they are equal and singleton; war0 - they are equal and not singleton; war1 - they are not equal, but have a nonempty intersection; err - they are not equal and have an empty intersection; (3) Finally, the overall status flag is the minimum of the status flags for each variable in the interface set.
Typing simple while programs and modules
The typing of simple while programs and modules is a simple extension of the classical typing used in sequential programs.

Simple while programs
These are simple, usual while programs. Once we have a typing for the basic blocks (expressions and assignment statements), their typing may be defined as in [36]. 18
For instance, in the case of an assignment, the type of the variable on left is com- pared to the type of the expression on right. The status part {ok, war0, war1, err} collects the information on the status part for the variable, the status part for the expression, and the comparison result regarding the matching of these two types.

Modules
For a module, take the type of the body program and export on the interfaces the variables occurring in the corresponding listen/speak and read/write statements.
Typing structured rv-programs
On programs, the typing morphism is inductively defined as follows.

17 As said before, a min function is defined on the set {ok, war0, war1, err}, thought of as an ordered set, decreasing from left to right.
18 Notice that a global scoping is used here, hence subtyping rules are to be used, as well.

Vertical composition
σ(S1%S2) = (st, ⟨wσ(S1); wσ(S2)|nσ(S1)⟩→ ⟨eσ(S1); eσ(S2)|sσ(S2)⟩), where
⎧⎪ min(ok, stσ(S1), stσ(S2))	if sσ(S1) = nσ(S2) = singleton
st = ⎪⎨ min(war0, stσ(S1), stσ(S2)) if sσ(S1) = nσ(S2) = ¬singleton
min(war1, stσ(S1), stσ(S2)) if sσ(S1) ∩ nσ(S2) /= ∅
⎪⎪⎩ err	if sσ(S1) ∩ nσ(S2) = ∅

n1



n1	n2




s1	s2
Fig. 9. Typing vertical/horizontal composition and “if” statements



Horizontal composition
σ(S1#S2) = (st, ⟨wσ(S1) |nσ(S1); nσ(S2)⟩→ ⟨eσ(S2)|sσ(S1); sσ(S2)⟩), where
⎧⎪ min(ok, stσ(S1), stσ(S2))	if eσ(S1) = wσ(S2) = singleton
st = ⎪⎨ min(war0, stσ(S1), stσ(S2)) if eσ(S1) = wσ(S2) = ¬singleton
min(war1, stσ(S1), stσ(S2)) if eσ(S1) ∩ wσ(S2) /= ∅
⎪⎪⎩ err	if eσ(S1) ∩ wσ(S2) = ∅

Diagonal composition
σ(S1$S2) = (st, ⟨wσ(S1)|nσ(S1)⟩→ ⟨eσ(S2)|sσ(S2)⟩), where denoting
P 1 := sσ(S1) = nσ(S2) = singleton,	Q1 := eσ(S1) = wσ(S2) = singleton, P 2 := sσ(S1) = nσ(S2) = ¬singleton,	Q2 := eσ(S1) = wσ(S2) = ¬singleton, P 3 := sσ(S1) ∩ nσ(S2) /= ∅,	Q3 := eσ(S1) ∩ wσ(S2) /= ∅,
P 4 := sσ(S1) ∩ nσ(S1) = ∅,	Q4 := eσ(S1) ∩ wσ(S2) = ∅
we have
⎧

st = ⎪⎨ min(war0, stσ(S1), stσ(S2)) if P 2 ∧ (Q1 ∨ Q2) ∨ (P 1 ∨ P 2) ∧ Q2 min(war1, stσ(S1), stσ(S2)) if P 3 ∧ (Q1 ∨ Q2 ∨ Q3) ∨ (P 1 ∨ P 2 ∨ P 3) ∧ Q3
⎪⎩ err	if P 4 ∨ Q4

If
σ(iƒ (B){S1}else{S2})  = (st, ⟨wσ(S1) ∪ wσ(S2)|nσ(S1) ∪ nσ(S1)⟩  →  ⟨eσ(S1) ∪
eσ(S2)|sσ(S1) ∪ sσ(S2)⟩) where

⎪	if σ(B) ⊆ (wσ(S1) ∪ nσ(S1)) ∩ (wσ(S2) ∪ nσ(S2))= singleton


st = ⎪⎪⎨

if σ(B) ⊆ (wσ(S1)

∪ nσ(S1)

) ∩ (wσ(S2)

∪ nσ(S2)
)= ¬singleton

min(war1, stB, stσ(S1), stσ(S2))

⎪ err
⎪
⎩
if σ(B) ∩ ((wσ(S1) ∪ nσ(S1)) ∩ (wσ(S2) ∪ nσ(S2))) /= ∅


if σ(B) ∩ ((wσ(S1) ∪ nσ(S1)) ∩ (wσ(S2) ∪ nσ(S2))) = ∅



Temporal while
σ(while t(B){S}) = (st, ⟨(wσ(S); )∗|nσ(S) ∪ sσ(S)⟩ → ⟨(eσ(S); )∗|nσ(S) ∪ sσ(S)⟩) where denoting
P 1 := σB ⊆ wσ(S) ∪ nσ(S) = singleton,	Q1 := sσ(S) = nσ(S) = singleton, P 2 := σB ⊆ wσ(S) ∪ nσ(S) = ¬singleton,	Q2 := sσ(S) = nσ(S) = ¬singleton, P 3 := σB ∩ (wσ(S) ∪ nσ(S)) /= ∅,	Q3 := sσ(S) ∩ nσ(S) /= ∅,
P 4 := σB ∩ (wσ(S) ∪ nσ(S))= ∅,	Q4 := sσ(S) ∩ nσ(S) = ∅
we have
⎧⎪ min(ok, stB, stσ(S))	if P 1 ∧ Q1
st = ⎪⎨ min(war0, stB, stσ(S)) if P 2 ∧ (Q1 ∨ Q2) ∨ (P 1 ∨ P 2) ∧ Q2 min(war1, stB, stσ(S)) if P 3 ∧ (Q1 ∨ Q2 ∨ Q3) ∨ (P 1 ∨ P 2 ∨ P 3) ∧ Q3
⎪⎪⎩ err	if P 4 ∨ Q4


Spatial while
The spatial version σ(while s(B){S}) is similar to the temporal one.


Spatio-temporal while
The spatio-temporal while σ(while st(B){S}) is similar to the temporal while, but slightly more complicate to write down as we have 3 pairs of interfaces to compare now: first, σB vs. wσ(S) ∪ nσ(S); then, nσ(S) vs. sσ(S); and, finally, wσ(S) vs. eσ(S).

Examples
Example 4.1 This example shows that the presence of regular-like expressions on interface type specifications is a natural consequences of the presence of “composi- tion/if/while” statements in AGAPIA v0.1 programs. Consider the program
P 1= while t(x>0){R}, where
R  = module{listen nil}{read x}
{new y:tn; y = x; x--;}{speak y}{write x}
and its equivalent one-step unfolding
P 2= if(x>0) {R % while t(x>0){R}} else {nil}
where x is a spatial integer of type sn and y a temporal integer of type tn. Except for the flag, the type of P 1 is ⟨nil|sn⟩ → ⟨(tn; )∗|sn⟩, while the type of P 2 is
⟨nil|sn⟩ → ⟨nil ∪ (tn; (tn; )∗)|sn⟩. If the programs are to be identified, then (tn; )∗ and nil ∪ (tn; (tn; )∗) are to be valid interface specifications and equal. 19
Consequently, we have to allow for union “∪”, composition “;”, and star “(..; )∗” on temporal interfaces. A similar argument apply to spatial interfaces. Using space-to-time and time-to-space constants, one may reshape such an interface to have the operations in the same process or transaction (as in a previous example of reshaping interfaces, presented in Subsec. 4.1). To conclude, if one agrees to use “if” and the temporal, the spatial, and the spatio-temporal “composition” and “while” statements in programs, as well as reshaping of interfaces, than one has to allow for the interface types included in AGAPIA v0.1 programs, too.
Example 4.2 In this example we compute the type of the AGAPIA v0.1 termina- tion detection program presented in Sec. 3.
To start with, let us use the notation: a = (tm, tid, msg[ ], token),b = (id, c, active),c = (m). The corresponding interface type declarations are not for- mally specified and we simply refer to the types via these variables. Then:
Init:
I1 '→ (ok, ⟨nil|c⟩ → ⟨a|nil⟩)
I2 '→ (ok, ⟨a|nil⟩→ ⟨a|b⟩)
for s( ){I2} '→ (ok, ⟨a|(nil; )∗⟩→ ⟨a|(b; )∗⟩)= (ok, ⟨a|nil⟩→ ⟨a|(b; )∗⟩)
I1#for s( ){I2} '→ (ok, ⟨nil|c; nil⟩ → ⟨a|nil; (b; )∗⟩)= (ok, ⟨nil|c⟩ → ⟨a|(b; )∗⟩)
Repeat:
R '→ (ok, ⟨a|b⟩ → ⟨a|b⟩)
for s( ){R} '→ (ok, ⟨a|(b; )∗⟩→ ⟨a|(b; )∗⟩)
while st( ){for s( ){R}} '→ (war0, ⟨a|(b; )∗⟩→ ⟨a|(b; )∗⟩)
Full program:
P '→ (war0, ⟨nil|c⟩→ ⟨a|(b; )∗⟩)
While we know the program is correctly typed, the typing procedure rises a weak

19 By a well-known regular expression identity 1 ∪ aa∗ = a∗, the above types are equal, if formal language equivalence is used.

warring war0 as it doesn’t check whether the number tm of iterates in the inner for
does not change from one loop of the while st to the next.

Example 4.3 The typing procedure described in this section may reject correct programs, as it happens with many other similar type checkers. For instance, if a program has the structure
if (B) then { if (!B) then {X} else {Y} } else {Z}
then the X component is unreachable (provided there are no side-effects to change a variable value during a test). If a wrongly typed component is put on the place of X, then the program is rejected by the typing procedure, but it may be correct (provided the remaining part is correct).
To conclude, the typing procedure just presented has to be complemented with other program analysis techniques to get a friendly and powerful compiler.



Conclusions and future work

In this paper we have presented AGAPIA v0.1, a kernel programming language for interactive systems. A typing system for this language has been developed. A few lines for future work are presented below.
A first line of research is to develop the mathematics and the logics behind (structured) rv-systems. If one makes abstraction of both spatial and temporal data, one gets a mechanism equivalent to tile systems, existential monadic sec- ond order logics, etc. used for recognizable two-dimensional languages. There is a large literature dedicated to two-dimensional (or picture) languages (see, e.g., [20,21,27,31,32,33,34]) and it may be worthwhile to try to lift some results to the level of rv-systems. Particularly useful may be to find language preserving trans- formations which may be useful for developing efficient compilers for structured rv-programs.
In the last 20 years, a rich and successful algebraic approach to cyclic struc- tures has been developed, see, e.g., [10,11,12,30,25,26,39,40,43], either for control or for reactive models. There are attempts to mix these two models, see, e.g., [23,24,42,41,45,44] or the last chapter of [43]. The model of rv-systems, presented in this paper, falls into this class. A difficult, but worthwhile, research topics is to extend such algebraic techniques to rv-programs.
Finally, a general topics is to develop an efficient and fully flagged compiler for AGAPIA programs. Our current approach is to translate structured rv-programs to rv-programs, then we use a running machine for rv-programs to get the program output. Currently, we have an automatic procedure for the translation (see [18]), but it is not fully implemented as we still look for the possible optimizations to improve the compiler.

References
Abramsky, S. Retracing some paths in process algebra. In: “Proceedings of CONCUR’96, ” 1-17. LNCS 1119, Springer, 1996.
Agha, G. “Actors: A model of concurrent computation in distributed systems.” MIT Press, 1986.
Bergstra, J.A., and J.W. Klop. Process algebra for synchronous communication. Information and Control 60(1984), 109-137.
Bergstra, J.A., C.A. Middelburg and G. Stefanescu. Network algebra for asynchronous dataflow.
International Journal of Computer Mathematics 65(1997), 57-88.
Brock, J.D., and W.B. Ackermann. Scenarios: A model of non-determinate computation. In: “Proceedings of Formalization of Programming Concepts,” 252-259. LNCS 107, Springer, 1981.
Broy, M. Nondeterministic dataflow programs: How to avoid the merge anomaly. Science of Computer Programming 10(1988), 65-85.
Broy, M., and E.R. Olderog. Trace-oriented models of concurrency. In: “Handbook of process algebra” (Eds. Bergstra, J.A. et.al.), 101-196. North-Holland, 2001.
Broy, M., and G. Stefanescu. The algebra of stream processing functions. Theoretical Computer Science 258(2001), 99-129. (Technical Report TUM-I9620 and SFB-Bericht Nr. 342/11/96 A, Institute of Informatics, Technical University Munich, 1996.)
Bruni, R. “Tile logic for synchronized rewriting of concurrent systems.” PhD Thesis, Department of Computer Science, University of Pisa, 1999.
Cazanescu, V.E., and G. Stefanescu. Towards a new algebraic foundation of flowchart scheme theory.
Fundamenta Informaticae, 13(1990), 171-210.
Cazanescu, V.E., and G. Stefanescu. A general result of abstract flowchart schemes with applications to the study of accessibility, reduction and minimization. Theoretical Computer Science, 99(1992), 1-63. (Fundamental Study.)
Corradini, A., and F. Gadducci. Rewriting on cyclic structures: equivalence between the operational and the categorical description. Theoretical Informatics and Applications, 33(4/5)(1999), 467-493.
Dijkstra, E.W.  Shmuel Safra’s version of termination detection.  EWD Manuscript 998, URL:
http://www.cs.utexas.edu/users/EWD/ewd09xx/EWD998.PDF , January 1987.
Dragoi, C., and G. Stefanescu. Structured programming for interactive rv-systems. Institute of Mathematics of the Romanian Academy, IMAR Preprint 9/2006, Bucharest 2006.
Dragoi, C., and G. Stefanescu. Towards a Hoare-like logic for structured rv-programs. Institute of Mathematics of the Romanian Academy, IMAR Preprint 10/2006, Bucharest, 2006.
Dragoi, C., and G. Stefanescu. Implementation and verification of ring termination detection protocols using structured rv-programs. Annals of University of Bucharest, Mathematics-Informatics Series, 55(2006), 129-138.
Dragoi, C., and G. Stefanescu. Structured interactive programs with registers and voices and their verification. Draft, Bucharest, January 2007.
Dragoi, C., and G. Stefanescu. On compiling structured interactive programs with registers and voices. In: “Proc. SOFSEM 2008,” 259-270. LNCS 4910, Springer, 2008.
Gadducci, F., and U. Montanari. The tile model. In: “Proof, language, and interaction: Essays in honor of Robin Milner, ” 133-168. MIT Press, 1999.
Giammarresi, D., and A. Restivo. Two-dimensional languages. In: “Handbook of formal languages. Vol. 3: Beyond words” (Rozenberg, G., and A. Salomaa, eds.), 215-265. Springer, 1997.
Giammarresi, D., A. Restivo, S. Seibert, W. Thomas. Monadic second order logic over rectangular pictures and recognizability by tiling systems. Information and Computation, 125(1996), 32-45.
Goldin, D., S. Smolka and P. Wegner (Eds.). “Interactive computation: The new paradigm.” Springer, 2006.
Grosu, R., D. Lucanu, and G. Stefanescu. Mixed relations as enriched semiringal categories. Journal of Universal Computer Science, 6(1)(2000), 112-129.
Grosu, R., G. Stefanescu, and M. Broy. Visual formalism revised. In: “Proceeding of the CSD’98” (International Conference on Application of Concurrency to System Design, March 23-26, 1998, Fukushima, Japan), 41-51. IEEE Computer Society Press, 1998.


Hasegawa, M. “Models of Sharing Graphs: A Categorical Semantics of let and letrec. PhD thesis, University of Edinburgh, Department of Computer Science, 1997.
Hasegawa, M., M. Hofmann and G. Plotkin. Finite dimensional vector spaces are complete for traced symmetric monoidal categories. In: “Pillars of Computer Science: Essays Dedicated to Boris (Boaz) Trakhtenbrot on the Occasion of His 85th Birthday, ” 540-559. LNCS 4800, Springer 2008.
Inoue, K., and I. Takanami. A survey of two-dimensional automata theory. Information Sciences,
55(1991), 99-121.
Jensen, O.H., and R. Milner. Bigraphs and transitions. In: “Proc. POPL 2003,” 38-49.
Jonsson, B. A fully abstract trace model for dataflow and asynchronous networks. Distributed Computing, 7(1994), 197-212.
Joyal, A., R. Street and D. Verity. Traced monoidal categories. Proceedings of the Cambridge Philosophical Society, 119(1996), 447-468.
Lindgren, K., C. Moore and M. Nordahl. Complexity of two-dimensional patterns. Journal of Statistical Physics, 91(1998), 909-951.
Latteux, M., and D. Simplot. Recognizable picture languages and domino tiling. Theoretical Computer Science 178(1997), 275-283.
Latteux, M., and D. Simplot. Context-sensitive string languages and recognizable picture languages.
Information and Computation, 138(1997), 160-169.
Matz, O. Regular expressions and context-free grammars for picture languages. In: “Proceedings STACS’97”, LNCS 1200, 283-294. Springer, 1997.
Peri, S. and N. Mittal. On termination detection in an asynchronous system. In: “Proc. 17th Int’l. Conf. on Parallel and Distributed Computing Systems (PDCS-2004).” ISCA Publications, 2004, 209- 215.
Pierce, B. “Types and programming languages.” MIT Press, 2002.
Popa, A., A. Sofronia and G. Stefanescu. High-level structured interactive programs with registers and voices. Journal of Universal Computer Science, 13(11)(2007).
Preoteasa, V.  A relation between unambiguous regular expressions and abstract data types.
Fundamenta Informaticae, 40(1999), 53-77.
Stefanescu, G. Feedback theories (a calculus for isomorphism classes of flowchart schemes). Revue Roumaine de Mathematiques Pures et Applique, 35(1990), 73-79. (Early distributed as INCREST Preprint No.24/1986.)
Stefanescu, G. Algebra of flownomials: Part I. Binary flownomials; basic theory. Technical Report TUM-I9437 and SFB-Bericht Nr. 342/16/94 A, Institute of Informatics, Technical University Munich, 1994.
Stefanescu, G. Reaction and control I. Mixing additive and multiplicative network algebras. Logic Journal of the IGPL, 6(2)(1998), 349-368.
Stefanescu, G. Axiomatizing mixed relations. In: “Proceedings of 3rd RelMiCS Seminar, Hammamet, Tunisia,” 177-186. University of Science, Technology and Medicine of Tunis, 1997.
Stefanescu, G. “Network algebra.” Springer, 2000.
Stefanescu, G. Kleene algebras of two dimensional words: A model for interactive systems. Dagstuhl Seminar on ”Applications of Kleene algebras”, Seminar 01081, 19-23 February, 2001.
Stefanescu, G. On space-time duality in computing: Imperative programming versus wave computation. In: “Proc. 4th 3rd RelMiCS Seminar,” 197-202. Stefan Banach Mathematical Centre, Warsaw, 1998.
Stefanescu, G. Algebra of networks: modeling simple networks as well as complex interactive systems.
In: “Proof and System-Reliability, Proc. Marktoberdorf Summer School 2001.” Kluwer, 2002, 49-78.
Stefanescu, G. Interactive systems with registers and voices. Fundamenta Informaticae 73(2006), 285-306. (Early draft, School of Computing, National University of Singapore, July 2004.)
Stefanescu, G. Towards a Floyd logic for interactive rv-systems. In: “Proc. 2nd IEEE Conference on Intelligent Computer Communication and Processing” (Ed. A.I. Letia). Technical University of Cluj-Napoca, September 1-2, 2006, 169-178.
Wadge, W., and E.A. Ashcroft. “Lucid, the dataflow programming language.” Academic Press, 1985.
Wegner, P. Interactive foundations of computing. Theoretical Computer Science 192(1998), 315-351.
