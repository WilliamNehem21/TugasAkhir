	Electronic Notes in Theoretical Computer Science 190 (2007) 113–125	
www.elsevier.com/locate/entcs

Testing Planning Domains (without Model Checkers)1
Franco Raimondi2 ,4
Department of Computer Science, University College London, London, UK
Charles Pecheur3 ,5
Dept. INGI, Universit´e catholique de Louvain, Louvain-la-neuve, Belgium
Guillaume Brat6
RIACS/NASA Ames Research Center, Moffett Field, CA, USA

Abstract
We address the problem of verifying planning domains as used in model-based planning, for example in space missions. We propose a methodology for testing flight rules of planning domains which is self-contained, in the sense that flight rules are verified using a planner and no external tools are required. We review and analyse coverage conditions for requirements-based testing, and we reason in detail on ”Unique First Cause” (UFC) coverage for test suites. We characterise flight rules using patterns, encoded using LTL, and we provide UFC coverage for them. We then present a translation of LTL formulae into planning goals, and illustrate our approach on a case study.
Keywords: Specification-based Testing, Planning, Coverage criteria.


Introduction
The NASA rovers Spirit and Opportunity [14,15], exploring the surface of Mars since January 2004, are an example of complex systems, featuring significant autonomous

1 This work has been funded by NASA ETDP 6E Automation for Operations project.
2 The author acknowledges support from the European IST project PLASTIC and from Mission Critical Technologies, NASA Ames Research Center.
3 The author acknowledges support from RIACS / USRA.
4 Email: f.raimondi@cs.ucl.ac.uk
5 Email: charles.pecheur@uclouvain.be
6 Email: brat@email.arc.nasa.gov

1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2007.08.011




Fig. 1. From flight rules to planning goals (overview).


capabilities, that can be built using current software and hardware technologies. Due to the complexity of such systems and in order to avoid economic losses and mission failures, there is a growing interest in tools and methodologies to perform formal verification for this kind of autonomous applications. In this paper we are concerned with the problem of verifying planning domains. In the case of the Mars rovers, plans are generated using the Europa 2 planner [11] to satisfy some scientific and positioning goals. Then, the plans are manually checked (against a set of requirements called flight rules) before being uploaded to the rover. The generation and verification have to be done before the next Mars daytime cycle. The methodology we propose to verify planning domains would speed up the verification phase and help ensure that flight rules are not violated.
Verification of planning domains has been investigated in the past, for instance in [10,12]. The solutions proposed by these authors consist in the translation of the planning domain into the input language of some model checker. The main limita- tion of these approaches is the limited size of the domains that can be translated and the problematic correspondence between languages for planners and languages for model checkers. In this paper we suggest a different approach: we propose to translate the problem of verification of planning domains into a planning problem. Such an approach has the advantage that no external tools are required, because the actual planner can be used to perform verification. Specifically, we suggest to proceed as summarised in Figure 1: given as input a planning domain and a set of flight rules (this is normally provided as a text document), in step 1 we encode flight rules as LTL specifications. In the second step we derive test cases from the specifications; we employ a revised notion of requirements-based testing, using an approach similar to [17,16,8]. In the third step we convert the test cases generated into planning goals. The actual tests are performed by “enriching” the original planning model with the new set of goals, using the planner for which the domain was designed.
The rest of the paper is organised as follows. In Section 2 we review the no- tion of coverage for requirements-based testing. We present the planning problem in Section 3. A motivational example is introduced in Section 4. We show how flight rules can be encoded as temporal formulae in Section 5, and how these can be translated into planning goals in Section 6, using the example provided. We conclude in Section 7.

Testing and requirements-based testing
Various metrics exist to quantify the coverage of test suites [2], particularly for structural testing. Coverage metrics for functional testing can be defined as well when functional requirements are provided formally, for instance using temporal formulae. Previous work in this direction include [8,16,17]. In this section we briefly review MC/DC (structural) coverage, and then we reason on a metric for functional testing by extending MC/DC coverage to LTL formulae, based on the work of Whalen et al. [17].
MC/DC Coverage
In the scope of this paper, we use a metric inspired by the popular Modiﬁed Condi- tion/Decision Coverage (MC/DC) [7]. In particular, MC/DC coverage is required for the most critical categories of avionic software [13] and its extensions can be employed in specification-based testing (see below). MC/DC coverage is defined in terms of the Boolean decisions in the program, such as test expressions in if and while statements, and the elementary conditions (i.e. Boolean terms) that compose them. A test suite is said to achieve MC/DC if its execution ensures that (1) every basic condition in any decision has taken on all possible outcomes at least once, and (2) each basic condition has been shown to independently affect the decision’s outcome.
As an example, the program fragment if (a || b) { ... } contains the de- cision c ≡ (a V b) with conditions a and b. MC/DC is achieved if this decision is exercised with the following three valuations: 7
(1) a = T,b = ⊥,c = T; (2) a = ⊥,b = T,c = T; (3) a = ⊥,b = ⊥,c = ⊥;
Indeed, evaluations 1 and 3 only differ in a, showing cases where a independently affects the outcome of c, respectively in a positive and negative way. The same argument applies to evaluations 2 and 3 for b.
The MC/DC requirements for each condition can be captured by a pair of Boolean formulae, called trap formulae, capturing those valuations in which the condition is shown to positively and negatively affect the decision in which it occurs (also called the positive and the negative test cases). Coverage is achieved by build- ing test cases that exercise the condition in states which satisfy each trap formula. In the example above, the trap formulae for condition a in c are a л чb and чa л чb.
UFC Coverage
As mentioned above, if functional specifications are expressed in a formal framework, then functional testing can be measured in terms of coverage criteria similar to structural testing, but applied to the specifications rather than the implementation. This is the idea behind requirements-based testing, as investigated in [17] and in [16]. In particular, [17] defines the notion of Unique First Cause coverage (UFC), which extends ideas from MC/DC to requirements-based testing.

7 We use T and ⊥ to denote Boolean true and false.

UFC coverage is defined with respect to functional properties that executions of a system must satisfy, and to the atomic conditions occurring in these properties. As illustrated in Section 5, these properties are often expressed by means of temporal formulae, for instance using the logic LTL (we refer to [3] for more details). A test suite achieves UFC coverage of a set of requirements expressed as temporal formulae, if: (1) Every basic condition in any formula has taken on all possible outcomes at least once. (2) Each basic condition has been shown to affect the formula’s outcome as the unique ﬁrst cause.
Following [17], a condition a is the unique ﬁrst cause (UFC) for ϕ along a path π if, in the first state along π in which ϕ is satisfied, it is satisfied because of a. This can be formalised as follows. Let π be a a path and X a set of atomic conditions; we denote by π(X) the sequence of truth values of the atomic conditions in X along π (also called the projection of π over X).
Definition 2.1 [a-variant] Let AC(ϕ) be the set of occurrences of atomic conditions in a linear temporal formula ϕ. 8 Given a ∈ AC(ϕ) and a path π, an a-variant of π w.r.t. ϕ is a path π' such that π(AC(ϕ) − {a})= π'(AC(ϕ) − {a}).
Definition 2.2 [UFC coverage] Given a linear temporal formula ϕ, a condition a ∈ AC(ϕ) is the unique ﬁrst cause (UFC) for ϕ along a path π, or equivalently, π is an adequate (UFC positive) test case for a in ϕ, if π |= ϕ and there is an a-variant
π' of π such that π' |=/	ϕ.
When ϕ is a LTL formula, one can build a trap formula ufc(a, ϕ), which is a temporal formula characterising adequate test cases for a in ϕ, i.e. paths on which a is UFC for ϕ. 9  ufc(a, ϕ) is defined by induction on ϕ.  For example, given a ∈ AC(ϕa):
ufc(a, a)= a; ufc(a, чa)= чa ufc(a, ϕa V ϕb)= ufc(a, ϕa) л чϕb ufc(a, F ϕa)= (чϕa) U ufc(a, ϕa) ufc(a, G ϕa)= ϕa U (ufc(a, ϕa) л G ϕa)
A complete definition is found in [17], and as a refined version later in this section. This characterisation of test cases for LTL only applies to complete, inﬁnite paths. Realistic testing practices, however, are inherently limited to finite, truncated paths. In this context, the test case coverage criteria need to be refined further. Consider, for instance, the formula ϕ = G (a V b) expressing the requirement that either a or b must hold at any time. According to the definition above, an adequate test case for a in ϕ must satisfy
ufc(a, ϕ)= (a V b) U ((a л чb) л G (a V b))

8 Note that different occurrences of the same condition a are considered distinct. This poses technical difficulties with multiple occurrences. This is a known issue in the MC/DC context too.
9 [17] uses a different notation ϕ+ for the set of (positive) trap formulae for conditions in ϕ, that is, ϕ+ = {ufc(a, ϕ) | a occurs in ϕ}. The notation ϕ− = (¬ϕ)+ is also defined. We do not use these notations here to avoid confusion with strong/weak semantic variants |=+ and |=− (see below).

a,b	b	a,b	a

Fig. 2. Strong test case for a in F (a ∧ ¬b) and weak test case for a in G (a ∨ b).
A concrete, finite test case πf may reach a point where a л чb, showing evidence that a may contribute to making ϕ true. However, there is no guarantee that this πf is indeed a prefix of a π that satisfies ϕ, that is, that a V b can hold indefinitely beyond the end of πf . Such a finite prefix is defined as a weak test case for a in G (a V b).
A comprehensive treatment of temporal logic on truncated paths is found in [5], where strong and weak variants of semantic relations on finite prefixes are defined

(πf |=+ ϕ and πf |=− ϕ, respectively), where πf |=− ϕ iff πf
|=/
+ чϕ. Intuitively,

πf |=+ ϕ iff πf “carries all necessary evidence for” ϕ, whereas πf |=− ϕ iff it “carries no evidence against” ϕ. In particular, if πf |=+ ϕ, then for any (non- truncated) π extending πf we have π |= ϕ. Furthermore, [17] defines strengthening and weakening transformations [ϕ]+ and [ϕ]− such that πf |=± ϕ iff πf |= [ϕ]±. 10 In essence, [ϕ]+ converts weak untils to strong untils, and vice-versa for [ϕ]−; in particular, [G ϕ]+ = ⊥ and [F ϕ]− = T.
On this basis, [17] adapts the notion of UFC coverage by requiring that a (finite)
test πf case for a in ϕ satisfies ϕ according to the standard semantics up to the point where the effect of a is shown, and according to the weak semantics thereafter.
For example, the trap formula for ϕ = G (a ⇒ F b) becomes
ufc(a, ϕ)= (a ⇒ F b) U ((чa л чF b) л [G (a ⇒ F b)]−)
= (a ⇒ F b) U (чa л чF b)
since [G (a ⇒ F b)]− reduces to T. This also illustrates a lack of uniformity in the approach: the weakening cancels some of the obligations on Fb, but not all, although
the truncation may equally prevent all of them of being reached. Instead, in this paper we keep both weak and strong interpretations and apply them uniformly, obtaining two refined variants of UFC coverage.
Definition 2.3 [Strong/weak UFC coverage] Given a linear temporal formula ϕ, a condition a ∈ AC(ϕ) is the strong (resp. weak ) unique first cause for ϕ along a finite path πf , or equivalently, πf is an adequate strong (resp. weak ) test case for a

in ϕ, if πf |=+ ϕ (resp. |=−) and there is an a-variant π'
of πf such that π'
|=/ + ϕ

(resp. |=−).
As an example, the prefix in Figure 2 is, at the same time, a strong test case for a in F (a л чb) and a weak test case for a in G (a V b). Observe that, consistently the discussion above, no finite prefix can strongly test a formula such as G a, whose negation contains eventualities. We then refine ufc(a, ϕ) into strong and weak vari- ants ufc+ and ufc−, such that πf |= ufc±(a, ϕ) iff πf is a strong/weak test case for
a in ϕ. These are jointly defined as follows, given a ∈ AC(ϕa) and b ∈ AC(ϕb): 11
ufc±(a, a)= a ; ufc±(a, чa)= чa

10 Denoted strong[ϕ] and weak[ϕ] in [17], using LTL semantics extended to finite traces as in [5].
11 This definition covers all cases, by pushing negations down to atoms and by symmetry of Boolean oper- ators. Cases for F and G could be derived from U and W.


ufc±(a, ϕa л ϕb)= ufc±(a, ϕa) л [ϕb]±
ufc±(a, ϕa V ϕb)= ufc±(a, ϕa) л [чϕb]±
ufc±(a, X ϕa)= X ufc±(a, ϕa)
ufc±(a, F ϕa)= [чϕa]± U ufc±(a, ϕa)
ufc±(a, G ϕa)= [ϕa]± U (ufc±(a, ϕa) л [G ϕa]±)
ufc±(a, ϕa U ϕb)= [ϕa л чϕb]± U (ufc±(a, ϕa) л [чϕb]± л [ϕa U ϕb]±)
ufc±(b, ϕa U ϕb)= [ϕa л чϕb]± U ufc±(b, ϕb)
ufc±(a, ϕa W ϕb)= [ϕa л чϕb]± U (ufc±(a, ϕa) л [чϕb]± л [ϕa W ϕb]±)
ufc±(b, ϕa W ϕb)= [ϕa л чϕb]± U ufc±(b, ϕb)

Specifically, sub-terms in G and W are strengthened to ⊥ and U in the +-cases; in particular, ufc+(a, G ϕ) boils down to ⊥ for any ϕ (not a tautology), reflecting the fact that no adequate strong (finite) test case exists for G ϕ. Given an atomic condition a appearing in a formula ϕ and an execution model M , if there is a strong test case πf |= ufc+(a, ϕ) in the traces of M , then πf shows that a can necessarily positively affect ϕ, in the sense that any extension π of πf indeed satisfies ϕ. On the
other hand, if πf |= ufc−(a, ϕ), then πf only shows that a can possibly positively affect ϕ, in the sense that there is no guarantee that this prefix can be completed to a full path of M that satisfies ϕ. It is also possible that there is no πf in M for which πf |= ufc±(a, ϕ): if ϕ is a positive (desired) property, then this means that a is a vacuous condition in ϕ w.r.t. M [16]; if ϕ is a negative (forbidden) property, then it confirms that this particular case of ϕ cannot happen, which is the desired result. A test fails if it is possible to find a path πf in M such that πf |= ufc±(a, ϕ), where ϕ is a negative property.
Planning
[...] planning can be considered a process of generating descriptions of how to op- erate some system to accomplish something. The resulting descriptions are called plans, and the desired accomplishments are called goals. In order to generate plans for a given system a model of how the system works must be given.”[11]
Traditionally, in the description of a system there is a distinction between states and actions (see, for instance, the STRIPS planner and its associated language [6]). In this paper, however, we take a different approach and we consider the Europa 2 planner [11]; Europa 2 produces finite horizon, deterministic plans. The key concept of Europa 2 is the one of tokens, i.e., a temporally scoped (true) fact. For instance, a printer being ready between the time t = 2 and t = 5 is represented using a token ready (see the first token in Figure 3). Tokens may represent states of a single object in the system, and are sometimes mutually exclusive. A timeline is a structure where sequences of tokens appear contiguously. For instance, the state of a printer can be described by a sequence of tokens, as in Figure 3 (therefore, state is a timeline). In this example, the syntax {2} denotes the time instant t = 2, while

{2}
[3−5] [3−5]	{21} {21}
[30−34] [30−34]



. . .



Fig. 3. A sequence of tokens in a timeline.
class SimplePrinter extends Timeline {
predicate ready{} /* Predicates with no arguments and no body: these are tokens */
predicate busy{}
}
/* Simple rules to force a repeated cycle */ SimplePrintert::ready{
eq(duration, 10); meets (object.busy); met_by(object.busy);
}

Fig. 4. A very simple NDDL file.
[3 − 5] denotes a value of t between 3 and 5.
Europa 2 allows for the expression of various relations between tokens, based on Allen’s interval logic [1]. Allen’s interval logic includes 13 possible relations between a pair of tokens:   meets/met by, before/after, equals,
starts/ends, contains/contained by, contains start/starts during, contains end/ends during.	A planning problem is formulated in Europa 2 as a set of tokens (possibly belonging in a timeline), a set of rules expressed using the relations presented above, and a set of goals: these elements define a so-called partial plan, which is refined by Europa 2 into a complete plan, i.e., a plan where all tokens are active and no unbound variables exist. We refer to [11] and references therein for further details about the theoretical foundations of Europa 2.	The input files of Europa 2 are expressed using the New Domain Description Language (NDDL, pronounced “noodle”). NDDL is a (restricted) object-oriented, Java-like language; a simple example of a NDDL file (without goals) is given in Figure 4.

A concrete example: the Rover scenario
This section presents a concrete case study which will be used in the remainder of the paper to exemplify our methodology: an autonomous rover. A rover contains three main components: a navigator to manage the location and the movement of the rover; an instrument to perform scientific analysis; a commander, receiving instructions from scientists and directing the rover’s operations. Each of these components is mapped into a class (respectively: Navigator, Instrument, and Commands); each of these classes is a timeline. Additionally, the domain contains two classes Location and Path to represent physical locations and paths between locations. Each of the timelines contain the following tokens:
Navigator: At, Going (the rover is either at a location, or going between loca- tions).
Instrument: stow, unstow, stowed, place, takesample (the instrument can be stowed, can be in in the state of being stowed or unstowed, can be placed on

class Location {
string name; int x; int y; Location(string _name, int _x, int _y){ name = _name;	x = _x;	y = _y;
}
}
[...]
// Navigator is a Timeline
class Navigator extends Timeline { predicate At{
Location location;
}
predicate Going{
Location from;	Location to; neq(from, to);
// This is a rule: it prevents rover from going from a location
// straight back to that location.
}
}
// This is a rule for the token At Navigator::At{
met_by(object.Going from);// Allen’s relation: each At is met_by
// a Going token
eq(from.to, location); // next Going token starts at this location meets(object.Going to); // Allen’s relation: each At meets
// a Going token
eq(to.from, location); // prevous Going token ends at this location
} [...]
// A possible goal
goal(Commands.TakeSample sample); sample.start.specify(50); sample.rock.specify(rock4);

Fig. 5. Excerpt from the NDDL file for the rover example.

Fig. 6. Generated plan.

a target, or it can take a sample).
Commands: takesample, phonehome, phonelander (the rover can be instructed to take a sample, and it can communicate either with a lander, or directly with the Earth).
An extract of the NDDL code for this example is presented in Figure 5, where the NDDL code corresponding to a part of the declaration of the Navigator timeline is shown (notice the similarities with the syntax of Java). See the comments appearing in Figure 5 for more details. The class Timeline (not shown in the example) is a super-class containing two variables start and end (notice that in NDDL all variables and methods are public). A possible goal for this scenario is presented at the end of the code in Figure 5: the goal is to begin a sample of rock4 at time 50. When a NDDL file encoding the scenario and the goals is passed to Europa 2,
the planner generates a plan, similarly to the one presented in Figure 6

Flight rules
Flight Rules are requirements that must be satisfied in every execution. Typically, flight rules are a plain text document which accompanies the description of scenarios. For instance, a flight rule for the example presented in Section 4 is “all Instruments must be stowed when moving ”. The majority of flight rules falls into one of the temporal patterns defined in [4] and thus can be encoded by means of an LTL formula. For instance, the flight rule above can be encoded as ϕ = G (p → q) = G (чp V q), where p = moving and q = stowed.
Coverage sets for flight rules
As flight rules can be encoded as LTL formulae, the methodology presented in Section 2 can be applied to generate a set of test cases for flight rules with coverage guarantees. As an example, we consider the flight rule presented above, namely ϕ = G (чp V q) (where p = moving and q = stowed). Being a safety formula, we can only have weak evidences for the positive test cases (see Section 2.2) because the planner can only generate finite executions. Specifically, we have the following three test cases:
ufc−(p, ϕ)= ((чp л q) U (чp л чq));
ufc−(q, ϕ)= ((чp л q) U (p л q));
ufc±(p, чϕ)= ufc±(q, чϕ)= ((чp V q) U (p л чq)).
The first positive test case tests the true value of the whole formula caused by the proposition p (i.e., moving); the second test case tests the proposition q. There is only one test case for false value of the formula and it is contributed by both propositions; notice that this test case is the same for weak and for strong evidence. A similar exercise could be repeated for all the flight rules appearing in the specification for any given scenarios. Using the methodology presented above to compute test cases with UFC coverage guarantees would be an improvement per se with respect to the current testing methodologies (currently, test cases for Europa 2 are generated manually and without coverage guarantees). But our approach can be refined further, to the benefit of plan developers: in the next section we present how the execution of tests can be automated by translating temporal formulae into
planning goals.
From temporal formulae to planning goals
The key idea of this section is to translate LTL formulae encoding test cases into planning goals. This is achieved by building a parse tree of the formula and by associating a timeline to each node of the parse tree.
We present the details of this methodology using the first positive test case for the scenario presented in Section 4, namely, for the formula (чp л q) U (чp л чq), where p = moving and q = stowed
We start with proposition p, which is true whenever the rover is moving. We

// The new timeline with two tokens: class prop-p extends Timeline {
predicate TRUE { }; predicate FLASE { };
}
// The rule for TRUE: prop-p::TRUE {
Navigator nav; equals(nav.Going); met_by(object.FALSE f1); meets(object.FALSE f2);
}
// Additional rule for Navigator::Going Navigator::Going {
prop-p p; equals(p.TRUE);
}
class prop-not-p { predicate TRUE { }; predicate FLASE { };
}
prop-not-p::TRUE { meets(object.FALSE f1); met_by(object.FALSE f2); prop-p p; equals(p.FALSE);
}

Fig. 7. NDDL code for proposition p and ¬p (moving).

define a new timeline prop-p containing the two tokens TRUE and FALSE: token TRUE of prop-p is the case when the token Going of Navigator holds, and token FALSE of the timeline prop-p holds when TRUE does not hold. These requirements are translated into the NDDL code represented in Figure 7 (top part). The negation of proposition p is defined as a new timeline prop-not-p composed by the two tokens TRUE and FALSE and by the rules presented in Figure 7 (bottom part).
Proposition q (representing the fact that instruments are stowed) and its nega- tion are defined in a similar way as new timelines. The conjunction of two proposi- tions is encoded as a new timeline with four tokens representing the possible truth values of the two conjuncts. The scope of each token is defined using the two Allen’s relations contains and contained_by. The truth value of the whole con- junction is obtained using a third timeline with two tokens only (TRUE and FALSE). The NDDL code corresponding to the conjunction of two propositions is available from the authors upon request. We are now in a position to test the formula ϕ = (чp л q) U (чp л чq). For simplicity, let ϕ = A U B, where A and B are encoded using the timelines prop-A and prop-B respectively. The LTL proposition ϕ holds in the model iff the following goal can be satisfied:
goal(prop-A.TRUE); goal(prop-B.TRUE); eq(prop-A.start,0); contains_end(prop-B.TRUE,prop-A.TRUE);
Intuitively, the goal above states that proposition A has to be true at the be- ginning of the run (eq(prop-A.start,0)) and that B becomes true before the end of TRUE of A (contains_end(prop-B.TRUE,prop-A.TRUE)). The additional NDDL code presented above is added to the original NDDL code for the scenario (notice that, in doing so, the instrumentation process cannot introduce bugs in the original model). The new “enriched” NDDL code is passed to Europa 2 for plan gener- ation. If a plan can be obtained with the additional constraints for the positive




Fig. 8. Generated plan with additional timelines.


test case, the test is passed successfully. Figure 8 depicts Europa 2 output for the first test case. Notice the additional timelines for the propositions Boolean proposi- tions (compare with Figure 6). This plan illustrates an execution where the atomic condition q (stowed) is the unique first cause. This exercise can be repeated for the second positive test case, which is passed, and for the negative test case. As expected, no plan can be generated for the negative test case.

Discussion
While the scenario presented above is not as rich as real production and mission environments, it is nevertheless more complex than the biggest examples that could be analysed using translations into model checkers [12,10]. We have run our tests on a standard machine and the introduction of the new timelines did not affect the performance of the planner for positive test cases. This result was expected, as a domain with additional constraints should be “easier” to solve than a less constrained domain: the introduction of the new timelines seems to balance this benefit. Negative test cases, however, require more computational power because of the backtracking involved in over-constrained domains. The planner eventually fails on negative test cases in around 10 minutes for the rover example, while it is able to produce a result in less than 30 seconds for positive test cases. Even though our aim in this paper is mainly to provide feasible coverage guarantees for test suites of planning domains and we are not concerned with performance issues, nevertheless we consider our preliminary results encouraging.

Conclusion
Traditionally, the problem of verifying planning domains has been approached by translating the planning domain into an appropriate formalism for a model checker, where verification can be performed either in a direct way, or by generating test cases, with the exception of [9] where a planning techniques are suggested for the generation of tests. This latter work differs from ours in that different coverage conditions are considered, and tests are not generated from flight rules (i.e., tem- poral specifications). Some issues remain to be investigated. For instance, we do not have a methodology to deal with the translation of nested temporal operators into planning goals (but we did not find nested temporal operators in the flight rules analysed). We are currently working on this issue and on a software tool to automate the methodology: we are implementing a parser from temporal patterns encoding flight rules to LTL trap formulae using the definitions in Section 2.2, and finally to NDDL code.

References
J. F. Allen. Maintaining knowledge about temporal intervals. Commun. ACM, 26(11):832–843, 1983.
B. Beizer. Software testing techniques (2nd ed.). Van Nostrand Reinhold Co., New York, NY, USA, 1990.
E. M. Clarke, O. Grumberg, and D. A. Peled. Model Checking. The MIT Press, Cambridge, Massachusetts, 1999.
M. B. Dwyer, G. S. Avrunin, and J. C. Corbett. Property specification patterns for finite-state verification. In Mark Ardis, editor, Proceedings of the 2nd Workshop on Formal Methods in Software Practice (FMSP’98), pages 7–15, New York, 1998. ACM Press.
Cindy Eisner et al. Reasoning with temporal logic on truncated paths. In Proceedings of CAV ’03, volume 2725 of LNCS. Springer, 2003.
R. Fikes and N. J. Nilsson. Strips: A new approach to the application of theorem proving to problem solving. Artificial Intelligence, 2(3/4):189–208, 1971.
K. J. Hayhurst, D. S. Veerhusen, J.J Chilenski, and L. K. Riersn. A practical tutorial on modified condition/decision coverage. Technical Report TM-2001-210876, NASA Langley Research Center, 2001.
Hyoung Seok Hong, Insup Lee, Oleg Sokolsky, and Hasan Ural. A temporal logic based theory of test coverage and generation. In TACAS ’02: Proceedings of the 8th International Conference on Tools and Algorithms for the Construction and Analysis of Systems, pages 327–341, London, UK, 2002. Springer-Verlag.
A.E. Howe, A. von Mayrhauser, and R.T. Mraz. Test Case Generation as an AI Planning Problem.
Journal of Automated Software Engineering, pages 77–106, 4, 1997.
L. Khatib, N. Muscettola, and K. Havelund. Verification of plan models using UPPAAL. Lecture Notes in Computer Science, 1871, 2001.
C. McGann. How to solve it (Europa 2 User Guide). NASA Ames internal report, 2006.
J. Penix, C. Pecheur, and K. Havelund. Using Model Checking to Validate AI Planner Domains. In
Proceedings of the 23rd Annual Software Engineering Workshop. NASA Goddard, 1998.
RTCA. Software Considerations in Airborne Systems and Equipment Certification, 1992.
S. W. Squyres et al. The Opportunity Rover’s Athena Science Investigation at Meridiani Planum, Mars. Science, pages 1698–1703, 2004.
S. W. Squyres et al. The Spirit Rover’s Athena Science Investigation at Gusev Crater, Mars. Science, pages 1698–1703, 2004.


L. Tan, O. Sokolsky, and I. Lee. Specification-based testing with linear temporal logic. In Proceedings of the IEEE International Conference on Information Reuse and Integration (IRI04). IEEE Society, 2004.
M. W. Whalen, A. Rajan, M. P. E. Heimdahl, and S. P. Miller. Coverage metrics for requirements- based testing. In ISSTA’06: Proceedings of the 2006 international symposium on Software testing and analysis, pages 25–36, New York, NY, USA, 2006. ACM Press.
