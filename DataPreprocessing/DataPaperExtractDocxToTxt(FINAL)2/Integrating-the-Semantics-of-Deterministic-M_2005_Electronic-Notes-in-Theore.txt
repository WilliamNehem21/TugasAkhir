Electronic Notes in Theoretical Computer Science 115 (2005) 59–68  
www.elsevier.com/locate/entcs


Integrating the Semantics of Deterministic Multi-layered Communication Systems
Rui Gustavo Crespo1
Department of Electrical Engineering and Computers Technical University of Lisbon
Av. Rovisco Pais, 1049-001 Lisboa, Portugal

Abstract
Communication systems are now developed and tailored by different classes of participants, each one focusing his/her attention on particular aspects of the system.
We analyse how Phone and Internet services can be described by event and state representation schemes. We propose to use the denotational semantics to express the interpretation of different representation schemes for the development and personalisation of deterministic communication systems.
Keywords: Denotational semantics, Event and State viewpoints, Viewpoint integration


Introduction
Communicating systems are event driven, because they are distributed and reactive. Therefore, the event viewpoints are the first, the most important, and frequently the only viewpoints identified. Also, the third characteristic of the event driven systems, the concurrency, is not always present in the communication systems, such as the private phone exchange systems-PBX.
Lately, the market started to require the possibility of users to tailor the systems to their specific needs, such as the Internet telephony [10]. However, many users only understand state driven viewpoints. Hence questions arise, such as how can we interface the separated event and state viewpoints, and can the different representation schemes have one single formal semantics.

1 R.G.Crespo@digitais.ist.utl.pt


1571-0661 © 2005 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2004.09.031


Representation schemes
Because there are different participant classes in the development and use of communication systems, the event and the state viewpoints must use different representation schemes. Because the participants must be able to access to all information they need, the representation schemes must be powerful enough. To reason about the whole system and guarantee the coherence between the viewpoints, the two representation schemes must share the same semantics. Formal semantics of event driven representation schemes include traces [7] and LTS [5]. For state driven programming languages, analysts may adopt
operational [11], denotational [12] and axiomatic semantics [6].
The integration of event and state driven semantics reveals to be difficult (see SDL [4]). However, the use of a limited part of the representation scheme simplifies the integration of the semantic formalisms. Being nondeterminism absent, we adopt the denotational semantics and interpret events as deter- ministic state changes. Reason for the choice include the user’s familiarity to the state driven viewpoints, the tools availability and the easier integration of semantics due to the interpretation of the syntactic elements by functions. We note that the reverse approach is also possible, by modelling states as equivalence classes of event sequences.

System example
We are developing a PBX with many features, where users choose the features they wish to subscribe and define policies for feature selection upon an event arrival. We adopted a three-layer architecture. Starting from the lowest layer,
Call processing layer (CP), with a stand-alone definition of features.
Context update layer (CU), tailors the features to the individual needs.
Selection and execution layer (SE), which describes how to choose the feature to be executed.

Event driven scheme
FET-Feature Execution Trees [2] depicts the control logic of features in terms of subtrees that can succeed or fail, causing other subtrees to be evaluated.

FET language
A telephone feature must have the form shown in (1), with a trigger event
εTλ and three conditions: pre-condition, execution body and post-condition.


seq(event ∧ pre − condition, seq(body, post − condition))
The pre-condition states which predicates must be satisfied, in order the
system be able to execute the feature. The body depicts the events that the subscriber (L) and the other features (R) must launch, and the predicates that must be satisfied. The post-condition indicates the new status of the subscriber and which events are launched, after the execution of the body.
The figure 1 depicts the abstract syntax of the FET language. τ, ε and π
are the syntactical elements of terminal, event and predicate identifiers.

FET : Φ ::= εTλ, X → X → X
CondF : X ::= XΩφX | not X | true | Σ Tλ | Φ
Oper : Ωφ ::= seq | and | or,	Selector : Σ ::= ε | ε : ∆F | π Direction : ∆φ ::= launched | required,  T ermList : Tλ ::= τ, Tλ | τ
Fig. 1. Abstract syntax of FET language

Example 2.1 The CA service is triggered by the launch of the ev ring event, and requires the subscriber to be idle. The body requires the subscriber to launch the ev offhook event. After the execution of the CA service, one event is launched (ev ack), two events are cleared (ev offhook and ev ring), the predicate talk becomes satisfied and the predicate idle becomes not satisfied.
/ )
/
/

/ 
/ idle(self)
/ ) 

/	/
ev ring(A,C,self)	/
  
/\ 



ev offhook(self):L  /	\  •ev ring(A,C,self)
idle(self)•/ \	\  \
talk(self,A)\	\
ev ack(A,self)• ev offhook(self)

FET Semantics
Being nondeterminism absent in FET, the denotational semantics is powerful enough to identify the FET semantics and the events are interpreted, likewise predicates, by status functions.
Figure 2 depicts the semantic domains. The syntactic categories for FET are T erm = {ann,.. .}, IDp = {idle,.. .} and IDe = {ev ring,.. .}. Status is, simply, the union of Statusπ and Statusε. The semantics of a condition and the feature execution are a pair, made of the three-value logic result and the new system status. ⊥ represents an undefined execution of the feature.


Statusπ : σπ ::= T erm → IDp → seq T erm → Bool⊥ Statusε : σε ::= IDε → seq T erm → Bool⊥
Cφ : CondF → T erm → S → Bool⊥ ×Status 
CondF → T erm →∆φ → Status → Bool⊥ ×Status
F : T erm → Statusε → seq T erm → CondF → Cond2 → Status → Bool⊥ ×Status
Fig. 2. FET semantic domains
Figure 3 shows the valuation functions for seq and event constructs. The valuation functions for true and the not, or, and constructs are the classical. The valuation function of seq evaluates the second subtree, if and only if, the first subtree has the valuation value of true. The value function of the required events and predicates is, simply, the value of the corresponding Status
member. build : T ermList → seq T erm converts a set into a sequence of terminals.
Cφ[[X1 seq X2]]self σ =(if Cφ[[X1]]self σ ↓ 1 /= 1 then <Cφ[[X1]]self σ ↓ 1,σ>, else (if Cφ[[X2]]self σ ↓ 1 = ⊥ then < ⊥,σ>,
else (<C[[X2]]self σ ↓ 1, Cφ[[X2]]self σ ↓ 2 ⊕ Cφ[[X1]]self σ ↓ 2 >))) Cφ[[ε Tλ]]self δσ = (if δ = required then <Sε build(T λ),σ>,
else < 1,σ ⊕ ε '→ build[[T λ]] '→ 1 >)
Fig. 3. Valuation of seq and event C constructs
Figure 4 shows the valuation function of one individual feature. The valua- tion function says that the status is updated, if and only if the following results hold in succession: the event occurs, the pre-condition is evaluated to true and
the execution body is also evaluated to true. conv : CondF → T erm → S
generates a status function from a post-condition.
F [[ε Tλ, X1 → X2 → X3]]self σ =
(if Cφ[[εT λ]]self required σ ↓ 1 /=1 then <Cφ[[ε Tλ]]self required σ ↓ 1,σ>, else (if Cφ[[X1]]self σ ↓ 1 /= 1 then <Cφ[[X1]]self wσ ↓ 1,σ>,
else (if Cφ[[X2]]self σ ↓ 1 /= 1 then <Cφ[[X2]]self σ ↓ 1,σ>, else < 1,σ ⊕ conv[[X3]]self σ>)))
Fig. 4. Valuation function of F

State driven automata
The features are personalized with CPL-Call Processing Language [8] scripts.

CPL language
CPL scripts are trees of two kinds, incoming-for the arrival event and outgoing- for subscriber launched events.
The intermediate nodes are conditions, referred as switches. CPL offers over the values present in the call originator, locations and over time. Here, we restrict to the AS(address-switch) and to the TS(time-switch). The location modiﬁers change the locations or search for locations, in one location set.
If the condition is satisfied, the script refines the condition with an extra sequence of conditions, referred as outputs. There is one single output for the address-switch, the address. CPL provides a very reach set of outputs for the time-switch. There are no outputs for the location insertion and removal. If all refinements fail, the otherwise may be used as the last refinement condition.
For every output, the script proceeds with another switch, or a script leaf. CPL defines script leaves by event launch, designated as signalling operations. In this article, script leaves are references to features.
Example 3.1 The POTS is automatically made available to all users. Also, the incoming calls must be forwarded to Bob, between 10:00 and 12:00 AM. Other times, the incoming calls activate the ICS(Alice) feature.


incoming	)
incoming  ),,
 CB J



v



CFB
 J
The abstract syntax of the CPL is depicted in the figure 5. δ, π, τ, ν are syntactical elements of, respectively, a time-stamp, a location, a tag name and a value name.


Script : N ::= NΣ,	Node : CΠN ::= NΣ | NΛ | Φ
SNode : NΣ ::= Σν Oλ |Σν Tλ Oλ,	LNode : NΛ ::= ΩΛ Oλ |ΩΛ Tλ Oλ OutList : Oλ ::= Oν CΠN | Oν CΠN Oλ,	T agList : Tλ ::= T | T Tλ T ag : T ::= τ = π | τ = δ | τ = ν
LocOper : ΩΛ ::= location | removal  | lookup
SwName : Σν ::= AS | TS,  OutName : Oν ::= address | time | otherwise



CPL semantics
Fig. 5. Abstract syntax of CPL language

The CPL semantics is presented informally [8] and in temporal logics [13]. Here, we provide an overview of the CPL denotational semantics.
The figure 6 depicts the CPL semantic domains. Λ = PT erm, representing a location set and ∆T = {2003/11/26@11 : 00,.. .}, representing the set of all
possible time stamps, are syntactic categories. The semantics of a script is a pair, made of the new system status and a new set location.

Bπ ::= OutList → T erm → Bool⊥, Bδ ::= OutList → ∆2
→ (Bool⊥ × ∆T )

S ::= Node → (Status × Λ) → (T erm3 × ∆T ) → (Status × Λ)
Fig. 6. CPL Semantic domains
The figure 7 depicts some of the valuations of the B functions. δ is the cur- rent time and ι is the beginning of one time span. The time mark may contain several tags, such as the delimited time range (time dtstart>”9” dtend<”17”): in this case, the result is the conjunction of the logical result for each tag. The tag may embrace several values, such as the non-continuous periods (time by-
hour=”10” ”12”): in this case, the result is the disjunction of the logical result
for each value in the tag.
Bπ[[address is = A]](π) = (if π = A then 1, else 0)
Bδ[[time Th Tt]](δ, ι) = let ιmiddle = Bδ[[time Tt]](δ, Bδ[[time Th]](δ, ι) ↓ 2)
in <Bδ[[time Th]](δ, ι) ↓ 1 ∗ ιmiddle ↓ 1, Bδ[[time Tt]](δ, ιmiddle) ↓ 2 > Bδ[[time dtstart = T ]](δ, ι) = (if δ > T then < 1,T >, else < 0,ι>)
Fig. 7. Valuation of B functions
The figure 8 depicts some valuation functions of S. For the address-switch, we focus on the originator address. For the time-switch, we simply adapt the


current time to the designated time-zone of the call (using the auxiliary shif t function). When the server performs a switch in the script, the branch is selected according to the evaluation of the Bπ and Bδ functions: if selected, it evaluates the corresponding node, if not S proceeds in the output list.

S[[AS field = origin O N]](σ, Λ)(<π1, π2, π3 >, δ) = 
(if Bπ[[O]](π1) = 1 then S[[N]](σ, Λ)(<π1, π2, π3 >, δ), else <σ, Λ >) S[[TS Tz O N ]](σ, Λ)(T erm3, δ) = 
(if Bδ[[O]](shif t(δ), 0) ↓ 1 = 1 then S[[N]](σ, Λ)(T erm3, shif t(δ)), else <σ, Λ >)
S[[location tel = πt N]](σ, Λ)(T erm3, δ) = S[[N]](σ, Λ ∪ {πt})(T erm3, δ) S[[Φ]](σ, Λ)(T erm3, δ) =<F [[Φ ]self σ ↓ 2, Λ >
Fig. 8. Valuation of S function


Logic constrained state driven scheme
The final selection of the feature to be executed is implemented IRS-Interaction Resolution and feature Selection, which incorporates deontic logic constraints. The logic approach makes easier the abstract definition of the selection policies. The deontic operators are used at the top abstract SE layer, not on the CP layer [1]. We adopt a reduction of the deontic logics to the dynamic
logics [9], where Interdiction is the failure of an action execution. Hence, the
paradoxes of the deontic logics do not occur.

IRS Language
SE is divided into two parts, the interaction resolution and the policy selection.

Interaction resolution
The undesired interaction between pairs of features is resulted by a set of interdition constraints, in the form shown in (2).
(Request ∧ Condition) → Interdictions
The Request subformula is a conjunction of propositions, each one repre-
senting a feature selected in the CU layer. Condition is a ground formula, that identifies the values the terminal must hold and the events that must


have been launched. The Interdictions identify the features that cannot be executed, if the Request and the Condition subformulas are evaluated to true.
Example 4.1 Consider the ICS feature holds the highest priority, and CFB holds higher priority than the CW feature.
(RequestICS ∧RequestCFB) → I CFB, (RequestCFB ∧RequestCW ) → I CW
Figure 9 gives the abstract syntax of resolution part of the IRS language. The symbols ρ and φ are, respectively, a proposition representing a feature request for execution and a set of features.

FormIR : γ ::= R, Cι ⇒ ∆IR | γ; γ Request : R ::= ρ | R ∧ R
CondIR : Cι ::= R | Cι Ωι Cι | ¬Cι | π Tλ | ∃ξ : Cι | ∀ξ : Cι Deontic : ∆IR ::= I φ | ∆IR ∧ I φ, OperL : Ωι ::= ∧ | ∨ | →
Fig. 9. Abstract syntax of the resolution part


Selection policies
The IRS selection part is a declarative language, with a script made of guarded commands. The instructions are simple: clear an event, execute the selected feature, print one message and update the hop’s value (a terminal counter, to avoid feature looping [3]). The abstract syntax of the IRS selection part is depicted in the figure 10. τ, Φ and self are defined in the FET language. s and η are, respectively, a string and a natural number.

Script : ΣR ::= Cλ
CondIS : Cσ ::= size = ∆IS | head = ρ | CσΩιCσ | ¬Cσ | ϵT λ
Stmt : Σ ::= Cλ | CLEAR ϵ | EXEC Φ | MSG M | UP DATE τ, I
CondList : Cλ ::= Cλ Cσ → Σλ | Cσ → Σλ,	StmtList : Σλ ::= Σλ Σ | Σ
Dimension : ∆IS ::= many | one | null
V alue : I ::= η | I + I | HOP τ ,	Msg : M ::= s | M + M | self
Fig. 10. Abstract syntax of IRS language-selection part

Example 4.2 One simple selection policy is to choose the first feature in the sequence outcome of the resolution part of the SE layer.


[size=many V size=one] → (
[(head=CFA V head=CFB) Λ event=ev call(A,B,self)] →
(update(A,hop(A)+1); exec(head))
[head/=CFAΛ head/=CFB→] (update(A,0); exec(head)))
[size=null] → (Msg(”Internal error in terminal ” + self); Clear(event))

IRS Semantics
The semantics domains of the constraint part are depicted in the figure 11. The semantics of a formula is a subset of features, candidate for execution. The denotational semantics of the IRS selection part and of the programming languages [12] are similar.
F List : ΦR ::=PΦ
Constr :Γ::= FormI →ΦR×Statusπ ×T erm →ΦR Expr :  E ::= CondIR →ΦR×Statusπ ×T erm → N
Fig. 11. Semantic domains of the constraint part
The valuation functions for the Expr logical operators are equal to the valuation functions for similar Cφ constructs. The figure 12 depicts the valu- ation functions for the Expr syntactic constructs and for the feature request. Because the number of terminals is fixed, E is decidable.
E[[ρ]](φρ, σ, self )=(if ρ ∈ φρ then 1, else 0)

E[[∀ξ : Cι]](φρ, σ, self )= E[[[Cι]ξ
]](φρ, σ, self )∗ ... ∗E[[[Cι]ξ
]](φρ, σ, self )

Fig. 12. Evaluation functions for Expr
The figure 13 depicts some valuation functions for Constr. The evaluation of a sequence of two formulas, with equal Requests and equal Conditions, is the same as one single formula with the same Request and Condition and conjuntion of the interdictions of the two formulas.
Γ[[R, Cι ⇒ I φ1]](φρ, σ, self ) = 
(if E[[R]](φρ, σ, self )=1 and E[[Cι]](φρ, σ, self )=1 then φρ \ φ1,else φρ) Γ[[R, Cι ⇒∆IR ∧ I φ1]](φρ, σ, self )=Γ [R, Cι ⇒ I φ1]]
(φρ \ Γ[[R, Cι ⇒ ∆IR]](φρ, σ, self ), σ, self )
Fig. 13. Evaluation function for Constraint

References
Barbuceanu, M., T. Gray and S. Mankovski, Coordinating with obligations, in: 2nd Int’l Conference on Autonomous Agents (1998), pp. 62–69.
Crespo, R., The Semantics of Feature Execution Trees, in: 3rd IEEE Workshop on Formal Speciﬁcations of Computer-based Systems, 2002, pp. 39–46.
Crespo, R., L. Logrippo and T. Gray, Feature Execution Trees and Interactions, in: Int’l Conference on Parallel and Distributed Processing Techniques and Applications, 2002, pp. 1230–1236.
Eschbach, R., U. Gl¨asser, R. Cotzhein and A. Prinz, On the Formal Semantics of SDL-2000: A Compilation Approach Based on an Abstract SDL Machine, in: Abstract State Machines 2000, LNCS 1912 (2000), pp. 242–265.
Hennessy, M., “Algebraic Theory of Processes,” MIT Press, 1988.
Hoare, C., An axiomatic basis for computer programming, Communications of the ACM 12
(1969), pp. 576–580,583.
Hoare, C., “Communicating Sequential Processes,” Prentice-Hall, 1985.
Lennox, J. and H. Schulzrinne, CPL: A Language for User Control of Internet Telephony Services, Technical Report draft-ietf-iptel-cpl-06 (2002).
Meyer, J., A different approach to deontic logic: Deontic logic viewed as a variant of dynamic logic, Notre Dame Journal of Formal Logic 29 (1988), pp. 109–136.
Schulzrinne, H. and J. Lennox, The IETF Internet Telephony Architecture and Protocols, IEEE Network Magazine 13 (1999), pp. 18–23.
Wegner, P., The Vienna Deﬁnition Language, ACM Computing Surveys 4 (1972), pp. 5–63.
Winskel, G., “Formal Semantics of Programming Languages,” MIT Press, 1993.
Xu, Y., “Detecting Feature interactions in CPL,” Master’s thesis, School of Information Technology and Engineering at University of Ottawa (2003).
