Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 309 (2014) 75–93
www.elsevier.com/locate/entcs

Formalization and Verification of REST on HTTP Using CSP
Ting Yuan, Yiting Tang, Xi Wu, Yue Zhang Huibiao Zhu, Jian Guo
Shanghai Key Laboratory of Trustworthy Computing Software Engineering Institute, East China Normal University
3663 Zhongshan Road(North), Shanghai, China, 200062
Weijun Qin
State Key Laboratory of Information Security
Institute of Information Engineering, Chinese Academy of Sciences No.89 Min Zhuang Road, Haidian District, Beijing, China, 100093

Abstract
Representational State Transfer (REST), as a promising software architecture style, has been used in large scale since proposed. But considerable confusions about REST exist and many examples of supposedly RESTful applications violate key REST constraints. In this paper, we focus on the most important con- straints of REST, stateless property and hypertext-driven property. First we establish a formal model for REST on HTTP in CSP. In the model, components in RESTful systems communicate with each other using standard HTTP methods and are modeled as CSP processes. From the model we can find the effects of HTTP methods on resources. Then we give formal descriptions for failure cases of stateless, hypertext- driven constraints of REST, and safe, idempotent properties of HTTP methods, within which whether a system breaks REST constraints or basic HTTP requirements can be checked. Furthermore, we use model checker PAT to prove all the constraints hold in our model. In the end, a case study about the process of buying food is mapped to our model to better illustrate the REST concepts and our approach.
Keywords: REST, HTTP, CSP, Stateless, Hypertext-driven

Introduction
Protocols and standards like SOAP (Simple Object Access Protocol) [1] and HTTP (Hypertext Transport Protocol) [2] are used to construct web services. REST is a description of potential design principles of current Web architectures. It focuses on the scalability of component interactions, generality of interfaces and independent deployment of components.
The notion of REST was firstly proposed by Fielding in 2000 [3], who is also the co-author of the HTTP RFC [2]. Since then, the research and practice based

http://dx.doi.org/10.1016/j.entcs.2014.12.007
1571-0661/© 2014 The Authors. Published by Elsevier B.V.
This is an open access article under the CC BY-NC-ND license (http://creativecommons.org/licenses/by-nc-nd/3.0/).

on REST have kept developing. In practice, we can find more and more web APIs which claim to be RESTful, such as the photo sharing application Flickr and the online shopping web service Amazon. Books such as [4] and [5] are published to guide coders to develop RESTful applications. Researchers have done a lot of work related to clarifying REST. In [6], Tilkov et al. introduce REST’s key principles in the plainest languages with some easy examples to get readers to know more about them. In [7], Tomayko explains REST in the form of a daily dialog with his wife. The key ideas of the complicated architecture in this article turns out to be easily understood even by a housewife who has no background of computer. Webber et al. use the example of Starbucks to clarify each property of REST [8]. All the articles mentioned above make contributions to understanding better of the REST architecture in the informal way.
As to formal fields, Klein et al. apply temporal logic in describing REST’s two key principles [9]. In [10], Zuzak et al. use finite-state machines to model REST and propose a case study about weather forecast to show the feasibility of the model. The model maps the transactions between states to messages requested and replied. What the model ignores is the transfer process of the request, making the communication properties of REST hard to check. In [11], the static resources are described in triple spaces while the dynamic communications are modeled in CCS (Calculus of Communicating System) [12]. The model focuses on the feature of resources and ignores the details of interactions between them. Wu et al. give a basic model of REST architecture in CSP (Communicating Sequential Processes)
[13] and check several REST constraints [14]. But considerable confusions about REST exist and the REST architecture is often misunderstood and misapplied. In Fielding’s blog [15], he has criticized the design of some RESTful applications. Some systems that claim to be RESTful violate the constraint of hypertext-driven behavior, Flickr is such an example.
Inspired by [14] and [9], we formalize REST on HTTP in CSP. Compared to [14], we focus on the most two important constraints of REST and we give a more detailed representation of the REST behavior, where the method used in a request is specified. The constraints described in our paper are the most confusing con- cepts of REST. We aim to present a better understanding of REST. And in our paper, we also take resources into consideration, thus effects on resources through request/response between clients and server can be depicted. One of the REST constraint is uniform interface. The constraint stresses the uniform methods to manipulate the resources. And till now, HTTP’s four methods, GET, PUT, POST and DELETE, have been put into practice as the uniform methods. Regarding to this, we formalize REST based on HTTP in this paper, with the motivation of clar- ifying the architecture. We first introduce the basic knowledge of REST on HTTP. Then we use CSP to model a RESTful system which uses HTTP to communicate. Components of Client, Server and Resource are modeled as processes, thus commu- nications between each entity are converted to the communications between CSP processes. We give formal descriptions of failure cases of REST’s key constraints, stateless constraint and hypertext-driven constraint, and HTTP’s safe property and

idempotent property. Besides, model checker PAT (Process Analysis Toolkit) [16] is used to verify the constraints and properties in our model. Finally, giving a case study about the process of buying food, we use our achieved architecture to model the whole process and show the constraints and properties fulfilled in the case.
The remainder of the paper is structured as follows. The next section introduces the preliminaries about CSP and PAT. The overview of REST is shown in section
3. Section 4 presents the formal model of a RESTful system on HTTP in CSP. We give the formal description of REST’s key constraints and check them in PAT in section 5. Section 6 shows the case study of buying food. The last section concludes the paper and presents possible future work.
Preliminaries
CSP method
CSP (Communicating Sequential Processes) was first described by Hoare [13]. As developed and evolved constantly, it has already become one of mainstream process algebras. It specializes in describing patterns of interaction in concurrent systems. Due to the powerful expressive ability, CSP has been practically applied as a method for specifying and verifying the concurrent aspects of a variety of different systems, such as real time systems and web services. In CSP, processes are composed of basic processes and actions, and they are connected by operators.
The syntax of CSP is shown below:
P, Q ::= a → P | c?x → P | c!x → P | P Q | P [|X|]Q
Here P and Q represent processes which have alphabets α(P ) and α(Q) denoting the actions that the processes can perform respectively. Meanwhile a and b stand for the atomic actions and c is the name of the channel.
a → P represents that the process first performs action a, then behaves the same as process P .
c?x → P gets a message through channel c and assigns it to a variable x, then behaves like P .
c!x → P sends a message x using channel c, then behaves like P .
P  Q describes the concurrency of P and Q.
P [|X|]Q represents that P and Q perform the concurrent events on set X of channels.
More details about syntax of CSP can be found in [13].
PAT
PAT (Process Analysis Toolkit) [17,16] is a self-contained framework for compos- ing, simulating and reasoning of concurrent, real-time systems and other possible domains. It is designed as an extensible and modularized framework based on CSP and it implements various model checking techniques catering for different prop-

erties such as deadlock-freeness, divergence-freeness, reachability, LTL properties with fairness assumptions, refinement checking and probabilistic model checking. We list some notations in PAT as follows:
#define N 0 defines a global constant N which has the initial value 0.
var cache user list[N ] defines an array named cache user list and the size of it is N .
Channel c 5 defines a communication channel named c and its capacity is 5.
x = x +1 −→ Skip defines an event that can be attached with an assignment, using which we can update the value of a global variable x.
c!a.b −→ P and c?x.y −→ P refer to sending message a.b and receiving message from channel c respectively.
ifa(statement){ P } else{ Q } means if the statement is true, the behavior is like P , otherwise, like Q.
a{ x = x + 1; } −→ P means updating the global variable x in the block a and then do the process P .
More details about PAT can be found in [17,16,18].

Overview of REST on HTTP
REST is a set of principles that define how Web standards, such as HTTP and URIs, are supposed to be used (which often differs quite a bit from what many people actually do) [6]. Here we conclude all REST constriants into several key principles to be easily understood.
Each resource has an id. Resource is a concept newly shows up in [3]. It is an abstract unit of information with an intended meaning [9]. A book is a resource, and at the same time, a collection of books is also a resource. A service, e.g., “current temperature of Shanghai”, is a resource too. In a word, everything merits being identifiable is a resource. “Each resource has an id” means we have a unified naming function mapping identifiers to resources. In HTTP based applications, Uniform Resource Identifiers (URIs) [19] are the resource identifiers.
Resources are linked together. We can always see a confusing concept named “Hyper-media as the engine of application state” in REST related articles. At its core is the concept of hyper-media, or in other words, the idea of links. A resource is never a link, but a link exists between resources. When we request a resource, the server returns what we want, together with some more links that can take us to get more information. It is the link that makes the state of system change [20]. Resources are linked together so that we can get every resource we want just by following links. We give related representations in our model about this constraint.
Using standard methods. With the URIs, the system aims to do some- thing meaningful, so browser should know what to do with the URI. The browser knows it because every resource supports the same interface. The uniform interface between components makes REST distinguished from other network-based architec-

tures. It is the most important feature of REST. The application of the generality to the component interface improves the visibility of the interaction and makes it possible for information to communicate between independent components.
HTTP calls these uniform interfaces (or standard methods) verbs, and the set of standard methods includes GET, POST, PUT, DELETE, HEAD and OPTIONS. In this paper, we only take the first four verbs into consideration because only these four methods are related to resources. Almost all applications which claim to be RESTful use HTTP methods to communicate, but many of them misuse these four basic methods. So we introduce the whole REST architecture together with HTTP methods in our following model to approach the practical use of REST, with a hope of reducing the misuse of the great and promising architecture. The meanings of these methods are defined in the HTTP specification [2] and are introduced briefly in the following part, along with some guarantees about their behaviors. A method is called safe if it has no effect on the resource. And if a method is idempotent, it means duplicate actions cause no effect.
GET: The GET method means to retrieve whatever information is identified by requesting URI. It should be safe and idempotent.
PUT: The PUT method is used to create (if it does not exist) or modify the requested resource identified by URI. It should be idempotent.
POST: The POST method is used to create a new resource under the request- ing URI and make the new resource as its subordinate. It is neither safe nor idempotent.
DELETE: The DELETE method is used to delete the requested resource in the server identified by requesting URI. It should be idempotent.
More details about impacts on the entire system and the specifications of methods will be given in the modeling section.
Representations of resources. A resource representation is a description of the state of the resource at a given time [21]. A state may have different multiple representations. For example, a web page can be presented as HTML, or XML, or just an image of its content. The format of representation is negotiated by the client and server and should be understood by the application. The multiple representations of a resource make it available to anyone who knows how to use the web.
Stateless behavior of the communications. The communication be- tween client and server is stateless in REST. Each request contains all the infor- mation needed to understand the message. And all the session states are stored in clients. Any context remains in the server cannot be used.
One benefit of statelessness is the scalability of the system. If the server needs to save clients’ states, its footprint will be impacted. And stateless behavior brings another advantage. If a server crashes while running, it can be replaced without clients’ notice. We give a formal description of this constraint in the verification part.
The formal descriptions of the principles mentioned above can be found in the




Fig. 1. Combination strategy in our model
next two sections.

Modeling
We use CSP to model the REST architecture on HTTP in this section. The REST architecture has the components like user agent, the cache, origin server and inter- mediary components (proxies and gateways). Since the proxy and gateway are used to forward requests and responses with possible translations, we here combine user agent and proxy into the concept of Client, and origin server and gateway into the concept of Server. Cache exists in user agents and intermediaries to improve network efficiency. Since our focus has no relationship with cache, we do not take cache into consideration in our model. Resource is the key idea of REST and most communications between clients and server have effects on resources. We also model a process called Resource. Server can access to Resource. Client includes a num- ber of clients identified by client id. And Resource includes a number of resources identified by resource id. Figure 1 shows the combination strategy in our model.
First we define the following sets and channels. We use the set C to represent client identifiers. The set Oper stands for four HTTP methods related to resources. Hence, Oper = {get, post, put, delete}. ID is a set of resource identifiers; Root ⊆ ID is a finite set of root identifiers; Data is a set of data involved in requests and responses and it can be empty (null); Comm is a set of communications; and Repre is a set of representations of resources, a representation is a specific concept of data, it includes all links and other data in a resource. So representation ∈ Repre, Repre ⊆ Data. And repre(i) means the resource i’s representation. The set of root resource identifiers, Root, is considered as “common knowledge” for each specific web application, e.g., “www.example.com”. So usually |Root| = 1, the meaning of |s| is element number of the set s. We define assoc(c) as the set of resource identifiers that are ‘known’ by c, assoc(c) ⊆ ID, c ∈ C. And for each c ∈ C, assoc(c)= Root at the beginning. The set S(i) stands for the subordinate resources of the resource i, formally, S : ID '→ 2ID, mapping each resource identifier to the set of resource identifiers for its subordinate resources. Messages in our model are defined as follows:
MSGcs =df { oper.c.i.d | oper ∈ Oper, c ∈ C, i ∈ ID, d ∈ Data} MSGsc =df { d 1.d 2 | d 1,d 2 ∈ Data}
MSGsr =df { oper.i.d | oper ∈ Oper, i ∈ ID, d ∈ Data} MSGrs =df { d 1.d 2 | d 1,d 2 ∈ Data}
MSG	=df MSGcs ∪ MSGsc ∪ MSGsr ∪ MSGrs




Fig. 2. Model architecture via Channels
MSGcs represents the message sent by Client to Server; MSGcs represents the message sent by Server to Client. And MSGsr and MSGrs stands for the message between Server and Resource. We define a communication as “message cs + message sr/message sc + message rs”, that is, the whole process from client sending a request to client receiving a response. Here message cs ∈ MSG cs, message sr ∈ MSG sr, message sc ∈ MSG sc, and message rs ∈ MSG rs. The set L(m) describes resources that are made known to the requesting client, and includes resource identifiers that are returned as results in the communication m, or those are created by m. The set UL(m) represents the resource identi- fiers that are revoked at the client. Here, m ∈ Comm, L : Comm '→ 2ID, also UL : Comm '→ 2ID.
We use two channels to model the communications between the three compo- nents: ComCS and ComSR.
ComCS: it is used to send and receive messages between Client and Server.
ComSR: it is used to send and receive messages between Server and Resource. Figure 2 shows the architecture of our model.
Client
As we mentioned above, the process Client includes the part of user agent and proxy. In the whole communication, Client sends message to the next component of the whole system. HTTP defines 8 methods [2], they are GET, POST, PUT, DELETE, HEAD, OPTIONS, TRACE and CONNECT. But only the first four methods have effects on resources. So in our model, we only take these four methods into consideration. The model of Client is given in the following part:
Client = df ComCS!get.c.i.null
→ ComCS?representation.other data → Client
2 ComCS!post.c.i.resource data
→ ComCS?new id.other data → add assoc(c, new id) → Client
2 ComCS!put.c.i.resource data
→ ComCS?signal.other data → add assoc(c, i) → Client
2 ComCS!delete.c.i.null
→ ComCS?signal.other data → unlink assoc(c, i) → Client
The client sends message to the server and waits for the response. Here,
get, post, put, delete ∈ Oper are the names of methods; c ∈ C is the id of the client;
i ∈ ID is the requested resource identifier; reource data ∈ Data includes all links

and data of a resource; null ∈ Data represents empty information; other data ∈ Data are other data included in the returning message; representation ∈ Repre is the representation of a resource; add assoc(c, i) is a function, adding i to the client cJs association set, that is, after add assoc(c, i), assoc(c) turns to be assoc(c) ∪ {i}; unlink assoc(c, i) is a function, unlinking the resource i from the client c, which means after unlink assoc(c, i), assoc(c) turns to be assoc(c) −{i}. From the model we can see the client can do any of the four methods every time:
get: get.c.i.null means the client c sends a request to get the representation of i. The client then waits for the resource representation of i. Since the communica- tion does not link any new resource id to the client c, the set assoc(c) keeps the same. Both L and UL are empty.
post: post.c.i.resource data means the client c creates a new resource under i. The method uses resource data to create a fresh resource identified by new id and associates it to the client c. So repre(new id) = resource data. After the communication, the client c’s linking set adds the new identifier new id. And the new id becomes a subordinate of i and is added to S(i) since it is created under
i. Here L = {new id} and UL is empty.
put: put.c.i.resource data means the client c requests to update the resource i. This method waits for the signal whether the communication is processed success- fully. If i exists, the request will update i ’s information using resource data. If not, it will create a resource identified by i using resource data. After the commu- nication, repre(i) turns to be resource data. If i is updated, then i ∈ assoc(c), both L and UL are empty. If i is newly created, then i is added to assoc(c), and L = {i} while UL is empty, S(i) = {}. In either case, assoc(c) becomes assoc(c) ∪ {i} (if i ∈ assoc(c), assoc(c) equals assoc(c) ∪ {i}).
delete: delete.c.i.null means the client c requests to delete the resource i. The response is the signal whether the resource is deleted. The communication dis- associates i from client c, so assoc(c) becomes assoc(c) − {i}. Here L is empty while UL = {i}.
We should clarify the difference between the post method and put method when it comes to create a new resource. As we can see above, when the client uses post to create a new resource with the parameter i, it creates a new id new id under i. The server determines what new id is. For example, we suppose i is “www.example.com/books”, then new id may be “www.example.com/books/1” or “www.example.com/books/27”. But the put method creates a new resource that is exactly identified as i. Hence, we usually use post to create a subordinate of a collection. In our example, that is a book of books.

Server
In our model, the process of Server stands for the combination of gateway and the origin server. It receives requests from the client and sends responses accordingly. It also accesses to resources. The model of Server is shown below:

Server = df ComCS?method.client id.resource id.data →
if (method == get)
{ComSR!get.resource id.data
→ ComSR?representation.other data
→ ComCS!representation.other data} else if (method == post)
{ComSR!post.resource id.data
→ ComSR?new id.other data → ComCS!new id.other data} else if (method == put)
{ComSR!put.resource id.data
→ ComSR?signal.other data → ComCS!signal.other data} else if (method == delete)
{ComSR!delete.resource id.data
→ ComSR?signal.other data → ComCS!signal.other data}
→ Server
The server checks the type of method. If it requests to get the resource identified by resource id, the server sends the request forward to Resource with data (when method == get, data is empty since the client sends null with the get method). After that, the server waits the representation of resource id from Resource and then responses to Client. The server handles the other three cases in a familiar way, that is, sends forward the request to resources and sends back the returning data to clients.

Resource
The process Resource consists of numbers of resources in a RESTful system. It changes the status of resources and communicates with server. The model of Re- source is as follows:
Resource = df ComSR?method.resource id.data →
if (method == get)
{representation = get repre(resource id)
→ ComSR!representation.other data} else if (method == post)
{j = create resource(resource id, data)
→ ComSR!j.other data} else if (method == put)
{set resource(resource id, data)
→ ComSR!OK.other data} else if (method == delete)
{set resource(resource id, null)

→ ComSR!OK.other data}
→ Resource
Here, method ∈ Oper is a parameter passed from server, and it can be get or post or put or delete; resource id ∈ ID represents the requesting resource iden- tifier; OK ∈ Data is a signal of whether the method is processed successfully; get repre(resource id) is a function, returning the representation of resource id; the function create resource(resource id, data) creates a new resource under the identifier resource id, sets the representation of the new resource data and returns the resource identifier newly created; set resource(resource id, data) changes the representation of the resource resource id to data. When Resource receives a re- quest of getting a resource, it uses function get repre(resource id) to get the repre- sentation and returns it. A delete method makes repre(resource id) undefined, so we use the parameter null in the set resource() function when method == delete.

System
The whole application can be modeled as a concurrent composition of Client, Server and Resource.
System =df  Client[|ComCS|]Server[|ComSR|]Resource

Verification
In this section, we use first order logic to give formal definitions of failure cases of REST’s most important constraints. We also check safe and idempotent properties of HTTP methods in our model. Then the model checker PAT is used to prove the constraints, indicating our achieved model is reasonable. To better describe and understand the constraints, we first give the functions below:
set(a) represents the set a, e.g., c ∈ set(client) means c is a client. We define three sets: communication, client, method. A communication is the whole process that a client requests a resource and the server responses it. And the setcommunication represents the set of communications. And method ∈ {get, put, post, delete}.
resource(comm) represents the resource identiﬁer requested in the communica- tion comm.
response(comm) represents the response of the communication comm, that is, the returning message from server to client.
method(comm) represents the HTTP method of the communication
comm. Here method(comm) ∈ set(method).
link(comm) describes resources that are made known to the requesting client, and includes resource identifiers that are returned as results in the communication comm, or those are created by comm.
comm sequence(c) is a sequence of communication carried out between client c
and the server.

assoc(s, c) defines the set of resource identifiers that are “known” to the client c after the communication sequence s. Here, c ∈ set(client) and s ∈ comm sequence(c).
next(c) means the next communication carried out between client c and the server.

Stateless Behavior
In REST architecture, the communication is stateless. In other word, the client’s environment has no influence on the response and each request includes all the message needed. And the server does not store anything related to clients. We here give the failure case of stateless behavior:
Failure Case 1:
∀c, d ∈ set(client) ∧ c /= d, ∃com c, com d ∈ set(communication) •
comm sequence(c)= comm sequence(d)
∧next(c)= com c ∧ next(d)= com d
∧resource(com c)= resource(com d)
∧method(com c)= method(com d)
∧method(com c)= get
=⇒ response(com c) /= response(com d)
The failure case shows that, if two different clients request for reading the same resource, they get different results, then the system breaks the stateless behavior. This proves server’s actions are irrelevant to the clients’ environments.


Hypertext-driven Behavior
Hypertext-driven is the most important principle of REST which makes it distin- guished from other architectures. It focuses on the point that all data are linked to each other [20]. And the REST architecture insists on the principle of hypertext being the engine of application state. We give the following failure case of Hyper- text driven behavior:
Failure Case 2:
∀c ∈ set(client) ∧ ∀s ∈ comm sequence(c), ∃com ∈ set(communication) •
next(c)= com ∧ resource(com) /∈ assoc(s, c)
=⇒ resource(com) /∈ link(com)
We can see from the failure case that a client can only access to the linked resource. In an application, if a client requests for an unlinked resource, and it is not returned or created in the requesting process, the application then breaks hypertext driven behavior.

Properties of HTTP Methods
In the constraint of uniform interface [3], REST should have uniform manipulations of resources. HTTP is such a choice. But the misuses of HTTP’s four methods make it not as powerful as it supposes to be. So it is of great importance to understand and keep the properties of each method. As the network’s instability and insecurity, safety and idempotence are two properties that should be kept.

Safe method.
A safe method have no effect on any resource [2]. The method get should be safe. A way to check whether a method is safe or not is as follows:
Constraint 1:
∀c ∈ set(client), ∃com c 1, com c 2, com c 3 ∈ set(communication)
method(com c 1) = method(com c 3)
∧method(com c 1) = get
∧method(com c 2) = m
∧resource(com c 1) = resource(com c 2)
∧resource(com c 2) = resource(com c 3)
=⇒ response(com c 1) = response(com c 3)
Here, com c 1, com c 2, com c 3 are taken sequentially, and m is the method needs to be checked whether it has the safe property. m ∈ {get, delete, put, post}. First we let a client c get a resource, then c uses method m to request it and in the end we let c get it again. If c gets the same response, then the method m does not modify the resource and it has the safe property. HTTP defines only the method get has the property of safety and we will prove it in PAT.

Idempotent method.
According to HTTP RFC [2], a method is called idempotent if duplicate actions cause no effect. In HTTP standards, get, put and delete are defined idempotent. We can check a method m’s idempotence through following constraint:
Constraint 2:
∀c ∈ set(client), ∃com c 1, com c 2, com c 3, com c 4 ∈ set(communication)
method(com c 2) = method(com c 4)
∧method(com c 2) = get
∧method(com c 1) = method(com c 3)
∧method(com c 1) = m
∧resource(com c 1) = resource(com c 2)
∧resource(com c 2) = resource(com c 3)
∧resource(com c 3) = resource(com c 4)
=⇒ response(com c 2) = response(com c 4)

Here, com c 1, com c 2, com c 3, com c 4 are taken sequentially. A client c uses method m to manipulate a resource and uses get to see the effect. Then it uses the same method to manipulate the resource again and uses get to check the result. If the two get methods have the same results, then method m is idempotent. We will check whether get, put and delete keep the property in our model via PAT.

Modeling in PAT
We implement our model using PAT in this subsection. There are three processes in our model, client(), server() and resource(). We give the relevant codes about the client part:
client(client id, method, resource id, data)= 
ifa(method == 1)
{ComCS!method.client id.resource id.data
−→ ComCS?representation.other data
−→ client(client id, method, resource id, data)} else ifa(method == 2)
{ComCS!method.client id.resource id.data
−→ ComCS?new id.other data
−→ client(client id, method, resource id, data)} else ifa(method == 3)
{ComCS!method.client id.resource id.data
−→ ComCS?signal.other data
−→ client(client id, method, resource id, data)}
else
{ComCS!method.client id.resource id.data
−→ ComCS?signal.other data
−→ client(client id, method, resource id, data)};

Here, client id is the requesting client’s id; method represents the method, 1,2,3,4 for get, post, put, delete respectively, data can be null or other data of resource. First we use
r1() = client(1, 1, 1, 111)||server()||resource();
to create a new resource under resource 1. Then we use two processes
r2() = client(1, 0, 2, 0)||server()||resource();
r3() = client(2, 0, 2, 0)||server()||resource();
to represent two different clients identified by 1 and 2 to get the same resource 2. Then we observe the traces of these two systems to check the responses of them. The result shows that these two clients get the same response. In this way, we prove the server’s responses are irrelevant to the client’s context. So the stateless

constraint is proved. The complete codes of this proof will be given in the appendix. We also check the safety and idempotence properties of HTTP methods in our model in similar ways and prove that method get keeps safety, and methods get, put and delete keep idempotence in our model. The result lives up to the HTTP stan-
dards.
Case Study
In order to illustrate the model and constraints presented in this paper, we introduce an example: ordering a meal in a restaurant.
Here we choose a more accessible domain to illustrate our model rather than the one with a wealth of technical and domain-specific details:
Our restaurant, named “RESTaurant”, like most other businesses, is primarily interested in maximizing the throughput of orders. As a result, we use asynchronous processing. In other words, we have waiters taking customers’ orders and at the same time we have a cook making food in the kitchen. This allows the waiters to keep taking orders even if the cook is not available for the moment.
Model Mapped to the Whole Process
Customers–Client.
The customers in the whole process are clients in our model. They can place an order using post method, update an order using put method, ask for the cost of the food using get method and take the food away using delete method. We show each of them in the following part and the mapping of the model can also be found.
Place an order-“post”: A customer named Happy comes into RESTaurant and checks the menu to find all the food supplied. The customer makes the decision and says, “Steak, please.”. In this way, the customer sends related request and waits for the order number. The trace of Happy’s taking order is listed as follows:
< ComCS!post.“Happy”.“RESTaurant.org/order”.
{“steak”, “take away”, “unpaid”...}, ComCS?“RESTaurant.org/order/8”.data1 >
First, customer Happy asks for creating a new order, with the content of “steak” and other related data. Then he waits for the response. The waiter will tell him his order is under the URI of “RESTaurant.org/order”. And the data1 is in the form like:
order number (“RESTaurant.org/order/8” in our case) and the process of the whole process such as he needs to pay before taking the food. We can see the order created
data1= {< next rel = “http : //RESTaurant.org/payment”
uri = “http : //RESTaurant.org/payment/order/8”/ > ...}
Update the order-“put”: The customer may forget to order drinks. Before his payment, he can call a waiter to change (update) his order, with a PUT method. The trace of the customer Happy’s updating his order is like:

< ComCS!put.“Happy”.“RESTaurant.org/order/8”.
{“steak + orange juice”, “take away”, “unpaid”...}, ComCS?“OK”.other data >
Pay the order-“get+put”: Before enjoying the meal, the customer should pay for the bill. First, he should get his total cost. The trace of getting the total cost is in the following:
< ComCS!get.“Happy”.“RESTaurant.org/payment/order/8”.null, ComCS?“20dollars”.other data... >
After getting the total cost, the customer can pay his food using put method to change the state of “RESTaurant.org/payment/order/8” from “unpaid” to “paid”. The method is similar to updating the order and we no longer list it here. For successful payment, once the customer has received the signal “OK”, Happy can happily take away his steak and juice.
Clean up the order-“delete”: After taking away the food, the customer Happy has no more requirements and says “Goodbye” to the waiter. This is the signal of deleting Happy’s order. The trace is as follows:
< ComCS!delete.“Happy”.“RESTaurant.org/order/8”.null, ComCS?“OK”.other data >
Seeing the waiter saying goodbye to him, Happy leaves “RESTaurant” with food in his hand.

Cook–Server
In our case, cook is the server in our model. A cook receives orders and returns what customers need. As the resource part, all meaningful things in a system can be a resource. In our restaurant, food are resources, an order of food is a resource too. The mapping of cook and resource are similar to the mapping from customer to client. We do not list the trace of them any more.

Properties Shown in Our Case
Hypertext-driven Behavior.
When Happy makes his order, he receives data1 together with his order number. We see the form of data1 again:
data1= {< next rel = “http : //RESTaurant.org/payment”
uri = “http : //RESTaurant.org/payment/order/8”/ > ...}
With this information, the customer knows the next step is to pay his food using the URI of “http://RESTaurant.org/payment/order/8”. And this URI is added to the client Happy’s association set. Customers can always follow the links to move forward. This is similar to the constraint of hypertext-driven behaviors.

Statelessness.
Think about a situation, a friend of Happy comes into RESTaurant, and he is very generous to pay the bill for Happy. He can also get the total cost of the order by “http://RESTaurant.org/payment/order/8”, and pay the bill. The result has no difference, just 20 dollars for a steak and juice. It has the same principle as statelessness in REST, that is, the context of clients has no impact on the commu- nications.

Properties of HTTP Methods.
We give the descriptions of safe and idempotent property constraints in section
5. Here we take the get method as an example of safety and take put method as an example of idempotence. The method get should be safe and idempotent as required. When the customer Happy wants to check the cost of his food, he uses get method and knows the food costs him 20 dollars. After checking, the cost is still 20 dollars and the state of the payment is still unpaid. No change happens to the payment order after the get method. This means get is safe. And the customer asks to update the order, changing the food “steak” to “steak+orange juice”. Maybe waiter A helps to finish it and then he leaves the counter. Then waiter B takes over A’s job and enters the requirement again. In this way, the put method is carried out twice and the result is as same as once, that is, “steak+orange juice” for order 8. So put is idempotent.

Using our model, we can understand better of the RESTful system in this case study. And also the REST’s most important constraints can be illustrated clearly. Both demonstrate the feasibility of our model.

Conclusion
This paper has discussed the concepts of REST on HTTP. The main principles of REST, stateless property and hypertext driven property, are introduced. We model the main components of REST on HTTP in CSP, including three parts, Client, Server and Resource. Then four constraints are come up to check whether the model fulfills the requirements of stateless and hypertext-driven properties of a RESTful system, and the safe and idempotent properties of standard HTTP methods. We use model checker PAT to check all these constraints. Finally, a case study is shown to illustrate the process of a RESTful system on HTTP. All the efforts we have done are to clarify the concepts of REST on HTTP, with an expectation of reducing the misuse of it.
For the future, we will go on the research of REST in formal ways and analyze more properties about it. Besides, we will apply our model to practical applications. Using constraints proposed in section 5, we will check existing RESTful systems to find out whether they fulfill the basic principles of REST and HTTP.

Acknowledgement
This work was partly supported by the Danish National Research Foundation and the National Natural Science Foundation of China (Grant No. 61061130541) for the Danish-Chinese Center for Cyber Physical Systems. It was also sup- ported by National High Technology Research and Development Program of China (Grant No. 2012AA011205), National Basic Research Program of China (Grant No. 2011CB302904), National Natural Science Foundation of China (Grant Nos. 61021004 and 91118008), Shanghai STCSM Project (Grant No. 12511504205), and Key Lab of Information Network Security, Ministry of Public Security (No. C12604).

References
Curbera, F., Duftler, M., Khalaf, R., Nagy, W., Mukhi, N., Weerawarana, S.: Unraveling the Web services web: an introduction to SOAP, WSDL, and UDDI. Internet Computing, IEEE 6(2) (2002) 86–93
Fielding, R., Gettys, J., Mogul, J., Frystyk, H., Masinter, L., Leach, P., Berners-Lee, T.: Hypertext transfer protocol–HTTP/1.1 (1999)
Fielding, R.T.: Architectural styles and the design of network-based software architectures. PhD thesis, University of California (2000)
Richardson, L., Ruby, S.: RESTful web services. O’Reilly Media (2008)
Allamaraju, S.: RESTful Web Services Cookbook. Yahoo Press (2010)
Tilkov, S.: A brief introduction to REST. InfoQ, Dec 10 (2007)
Tomayko, R.: How I explained REST to my wife. The various writings and linkings of Ryan Tomayko. Np 12 (2004)
Webber, J., Parastatidis, S., Robinson, I.: How to GET a cup of coffee. InfoQ.[Online]. Retrieved on January 5 (2010)
Klein, U., Namjoshi, K.S.:  Formalization and automated verification of RESTful behavior.  In:
Computer Aided Verification, Springer (2011) 541–556
Zuzak, I., Budiselic, I., Delac, G.: Formal modeling of RESTful systems using finite-state machines.
In: Web Engineering. Springer (2011) 346–360
Hern´andez, A.G., Garc´ıa, M.N.M.: A formal definition of RESTful semantic web services. In:
Proceedings of the First International Workshop on RESTful Design, ACM (2010) 39–45
Moller, F., Tofts, C.: A temporal calculus of communicating systems. Springer (1990)
Hoare, C.: Communicating sequential processesprentice-hall international. Englewood Cliffs (1985)
Wu, X., Zhang, Y., Zhu, H., Zhao, Y., Sun, Z., Liu, P.: Formal Modeling and Analysis of the REST Architecture Using CSP. Web Services and Formal Methods (2012) 49
Fielding, R.T.: REST APIs must be hypertext-driven. Untangled musings of Roy T. Fielding (2008)
Sun, J., Liu, Y., Dong, J.S., Pang, J.: PAT: Towards flexible verification under fairness. In: Computer Aided Verification, Springer (2009) 709–714
Sun, J., Liu, Y., Dong, J.S.: Model checking CSP revisited: Introducing a process analysis toolkit. In:
Leveraging Applications of Formal Methods, Verification and Validation. Springer (2009) 307–322
Chen, C., Dong, J.S., Sun, J., Martin, A.: A verification system for interval-based specification languages. ACM Transactions on Software Engineering and Methodology (TOSEM) 19(4) (2010) 13

Masinter, L., Berners-Lee, T., Fielding, R.T.: Uniform resource identifier (URI): Generic syntax. (2005)
Bizer, C., Heath, T., Berners-Lee, T.: Linked data-the story so far. International Journal on Semantic Web and Information Systems (IJSWIS) 5(3) (2009) 1–22
Klein, U.: Topics in Formal Synthesis and Modeling. PhD thesis, New York University (2011)

A	Relevant Codes of PAT
// number o f r e s o u r c e s #d e f i n e N 5 0 ;
// d e f i n e the channels o f the system channel ComCS 1 ;
channel ComSR 1 ;
var r e p r e [ N + 1 ] ;
// to r e p r e s e n t the representations o f r es our c es var root [ N+ 1 ] ;
// the root o f each r e s o u r c e var j ;
var ok ;

client ( c l i e n t i d , method , r e s o u r c e i d , data)= i f a ( method==0)// get
{
ComCS ! method . c l i e n t i d . resource id . data−> ComCS? r e p r e s e n t a t i o n . o t h e r data −>
client ( c l i e n t i d , method , r e s o u r c e i d , data )
}
e l s e  i f a ( method==1)// post
{
ComCS ! method . c l i e n t i d . resource id . data−>
ComCS? new id −>client ( c l i e n t i d , method , r e s o u r c e i d , data )
}
e l s e  i f a ( method==2)// put
{
ComCS ! method . c l i e n t i d . resource id . data−>
ComCS? s i g n a l −>client ( c l i e n t i d , method , r e s o u r c e i d , data )
}
else // d e l e t e
{
ComCS ! method . c l i e n t i d . resource id . data−>
ComCS? s i g n a l −>client ( c l i e n t i d , method , r e s o u r c e i d , data )
} ;
server ()=
ComCS? method . c l i e n t i d . resource id . data−> i f a ( method==1)
{
ComSR ! 1 . r e s o u r c e id . data−>
ComSR? r e p r e s e n t a t i o n . o t h e r data −>
ComCS! representation . o t h e r data −>server () 
}
e l s e i f a ( method==2)
{
ComSR ! 2 . r e s o u r c e id . data−>
ComSR? new id . o ther data −>ComCS ! new id . o ther data −>server () 
}
e l s e i f a ( method==3)
{
ComSR ! 3 . r e s o u r c e id . data−>
ComSR? s i g n a l . o t h e r data −>ComCS ! signal . o t h e r data −>server () 
}
e l s e i f a ( method==4)
{


ComSR ! 4 . r e s o u r c e id . data−>
ComSR? s i g n a l . o t h e r data −>ComCS ! signal . o t h e r data −>server () 
} ;
resource ()=
ComSR? method . r e s o u r c e id . data−> i f a ( method==1)
{
ComSR ! r e p r e [ r e s o u r c e i d ].0 −> resource () 
}
e l s e i f a ( method==2)
{
set { j=resource id ∗ resource id ∗ resource id +1 }−>
create resource { root [ j ]= r e s o u r c e id ; r e p r e [ j ]= data }
−>ComSR ! j .0−> resource () 
}
e l s e i f a ( method==3)
{
set resource { r e p r e [ resource id ]= data }
−>ComSR ! ok.0−> resource () 
}
e l s e i f a ( method==4)
{
set resource { r e p r e [ resource id ]=0 }
−>ComSR ! ok.0−> resource () 
} ;
r 1 ()= c l i e n t (1 ,1 ,1 ,111) || server ( ) || resource ( ) ;
// client 1 to c r e a t e a new r e s o u r c e under 1
r 2 ()= c l i e n t (1 ,0 ,2 ,0) || server ( ) || resource ( ) ;
// c l i e n t 1 to get the newly created r e s o u r c e
r 3 ()= c l i e n t (2 ,0 ,2 ,0) || server ( ) || resource ( ) ;
// c l i e n t 2 to get the newly created r e s o u r c e
