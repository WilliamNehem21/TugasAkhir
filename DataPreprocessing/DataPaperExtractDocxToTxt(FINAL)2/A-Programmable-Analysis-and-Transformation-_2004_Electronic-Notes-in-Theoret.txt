	Electronic Notes in Theoretical Computer Science 94 (2004) 39–49	
www.elsevier.com/locate/entcs




A Programmable Analysis and Transformation Framework for Reverse Engineering
Ravindra Naik1  and Arun Bahulkar2
Tata Research Development and Design Centre 54, Industrial Estate, Hadapsar
Pune, INDIA

Abstract
Reverse Engineering refers to understanding an existing software system, and documenting the understanding in a desired format. Depending upon the purpose, which can be problem diagnosis, impact analysis, functional enhancements, or re-engineering to newer technologies or newer design, the reverse engineering artifacts vary in their definition, the abstraction level, and contents. Current state of practice relies on pre-cast tools, which extract a set of pre-defined information, with little or no inputs from the analyst. We propose a specification-based approach that allows analyst to specify and control the contents and abstraction level of the reverse engineering artifacts, while allowing user-interaction during extraction.
Keywords: Programmable Reverse Engineering, Reengineering, Program Analysis, Transformations


Reverse Engineering
Reverse engineering involves understanding an existing software system, and documenting the understanding in the desired format. Reverse engineering of a system may be undertaken for different purposes, viz.
Understanding different design views of the system
To enable re-development of the system using newer technologies
1 Email: rdnaik@pune.tcs.co.in
2 Email: arun@pune.tcs.co.in


1571-0661 © 2004 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2004.01.005

· To re-organize and re-structure the system so as to reduce the maintenance costs and prolong the life of the system
Understanding the system for impact analysis / problem diagnosis in case of ongoing maintenance of an existing system
Understanding the system for the purpose of extracting test specifications for the system
This activity involves extraction of artifacts at program-level like cross- references, data slice, program slice, program chops, etc. System level artifacts can be call-graphs, entity-relationship model, data-flow models, CRUD ma- trices, etc. Restructuring requirements need to locate code that implements different aspects like user-interface, business and reporting logic, database ac- cess, etc. Automating extraction of these artifacts is desirable. More desirable is the ability for tool builders to be able to specify the extraction of the arti- facts, how to view the artifacts, and how to interact and guide the extraction process.

State of practice
Most existing reverse engineering tools provide either predefined artifacts as output, or provide raw analysis information of programs that can be used by analysts for reverse engineering. Examples are [1] and [2].
Few frameworks exist, that are based on the extract-abstract-view princi- ple. Many allow querying over program sources and their structural properties, but do not support querying of semantic properties. Some of these frameworks are exploratory, while others are built for specific modern languages like C, C++ and Java. Examples are Acacia [3], CppAnal [4], and DALI [5].
Our approach differs primarily in that it provides mechanisms to define ab- stractions, to query on semantic program properties, and enable displaying the results in different forms appropriate for the purpose. The subject programs are represented as models. This provides an inherent, first level of abstrac- tion, and makes the framework to be language independent. In addition, the framework is based on a proven, flow-analysis framework for procedural lan- guages, Darpan [6]. Though the origin of this approach lies in our experience of building re-structuring and reverse engineering tools for COBOL and RPG applications, few lessons are derived from the work of Programmable Reverse Engineering [7]. Our work comes closest to the work by Stan Jarzabek and Guosheng Wang [10]. However, we have imperative style of specifications as against their declarative style, we support program semantic properties and aim to provide code level transformations.

Our approach
Programmable Analysis and Transformation Framework is a meta-framework, being developed for exploring and implementing reverse engineering tools that will enable program and system understanding, and their re-structuring.
The basic approach of our framework is to enable definition of abstractions (what-part), specify the way to extract them (how-part), and the way to view them (display-part). Codegen specifications will use the abstraction results to produce restructured programs from the source code.
The definition of abstraction involves specifying the composite type of the abstraction. This creates a representation for the abstraction, which is in terms of the model elements that represent a program.
The ”how part” involves search over semantic space of program properties, and includes:
syntax patterns based on syntactic pattern matching of the subject pro- grams. These are realized by search over the model that represents the subject program.
Extraction specifications can be seen as consisting of two parts:
Specifications that enable search of semantic patterns: these are queries of structural and static semantic properties of the source programs, and
use of these properties to identify the abstraction of interest
Specifications to generate the elements that represent the desired abstrac- tion
The codegen specifications will enable conversion of subject programs, based on the abstractions.
Display specifications enable mapping between abstraction definition and pre-defined display types. These enable the abstractions to be viewed using the specified displays. Alternately, user can view the abstractions in a manually programmed user-interface, or add new display types to the framework.
Though the current focus is on analysis of Mainframe technologies (JCL, COBOL, DB2), the framework is equally capable to support other program- ming technologies, like CICS, IMS, PL/I, C, etc.

Framework meta-model




We view the source programs as mod- els, thereby raising the level of abstrac- tion of the input. Core program anal- ysis is viewed as a process of com- puting pre-defined program properties from program models. Program prop- erties, like control-flow graph, data- flow information can also be viewed as abstractions.

Armed with these program properties, our framework allows search over source code (read program models), query of the program properties and gen- eration of abstractions (whose elements are program model objects or compo- sitions thereof), predicated by the program properties.
The program models are generic program representations, which are suit- able for programs written in procedural or OO programming languages. The models have placeholders for types and definition of symbols represented by symbol table [6]. The operations and computations are realized through vari- ous constructs of the programming language and are represented by abstract syntax tree [6].
The symbols and operations for database constructs, specific technologies on Mainframe machines (Job Control Language, CICS transaction manager, etc.) are represented using extensions of the symbol table and abstract syntax tree. Finally, an application is a composition of all symbol tables and abstract syntax trees.
Search over the source code is supported by providing a bottom-up and top-down search of the program model. The search yields program elements (like variables, functions, declarations) of interest.
The framework makes program properties available as primitives. Program properties like call-graph, def-use chains, alias information, copy constants, and others are computed by a data-flow analyzer, which is generated using Darpan [6]. New properties can be computed by writing new specifications for Darpan or can be provided by the user. The idea is to apply these properties to the program elements of interest, and based on the property values, decide whether the program element can belong to the abstraction being constructed.



For example, in COBOL, while con- structing ER model, if two logical files are always mapped to the same physical file, then the com- bination represents a single entity, else it represents to two independent entities. The type system for defining abstractions and accessing the program properties is shown in Figure 1.
Figure. 1
Abstractions so extracted should be displayed in a user-defined view. For this, our framework allows abstraction types to be mapped to display types. Currently supported display types are shown in Figure 2. The display types are editable (user can edit the displayed results), which enables the abstraction process to be interactive and iterative.
Summarizing, the abstraction process is, in gen- eral, iterative over the program models and pro- gram properties. User terminates the iterations when he is satisfied with the abstraction contents. This process can be viewed as a model transformer, which accepts the model representing the source programs as input, and allows analysts to spec- ify transformations to generate models represent-
Figure. 2	ing program understanding.

Framework Architecture
The framework consists of two logical activities:
Specification Processing and Validation
Specification Execution

Specification Processing and Validation
Specification processing checks syntax of

Search Specs

Transformation Specs

Display Specs
Codegen Specs

Instructions for Search, Transformation, Display,
Code generation
the specifications, and types of the sym- bols and expressions used in the specifica- tions. This step generates JVM instruc- tions that can be executed by Java Virtual Machine.
We are in the process of conceptualizing and defining the specifications for gener- ating models, and the codegen specifica- tions. We plan to base these transforma- tion specifications using MOF-QVT stan- dards [9].

Search pattern specifications
These are patterns that allow search over source code of programs. Source code elements like declaration, variable, function, statement, data files, database tables, and others can be specified as search elements.
For example, to extract error-handling code, a search pattern is written that fetches all declarations of variables that have the string error in their name. This is written as:
select $decl where ( namelike "error" ) $PROAXROOT
Transformation specifications
These are specifications that allow logical search over semantic proper- ties of programs. They allow queries of flow analysis (control and data) properties of the subject programs, and allow various kinds of traver- sals and compositions of these properties. They support primitive types like integer, string, Boolean; model types to represent source code el- ements like statement, expression, declaration, variable, function; com- posite types like sets, lists, records and operations like union, intersec- tion, enumeration. Imperative constructs for sequencing, conditional, and iteration, are supported. Modularization of specifications is supported through function construct.
For example, to extract error-handling code, one activity is to extract the variable references in the subject program, which occur in l-value context. This has to be done for each variable declaration that is a prospective error message variable. This is written as:
for each adecl in declSet
{
rvarSet = refers( adecl, $PROAXROOT );

for each rvar in rvarSet
{
if ( isComputed( rvar ) ) lvalVarSet += rvar
}
}
Two analysis primitives, viz. refers (returns all variable references of a declaration passed as 1st parameter in the scope identified by 2nd pa- rameter), and isComputed (returns true if the variable reference passed as parameter is used in l-value context) are used in the example.
Display specifications
These specifications allow users to specify two kinds of information. One is how the user would see the results of transformation specifica- tions; this part consists of window specifications. Second is a mapping specification to map the abstraction types to pre-defined display types. They are specified as XML specifications. An example mapping specifi- cation to display error-handling statements is written as:
<Map id = "eeh_res_tree">
<Abstraction-Type>
<Set>
<Stmt id= "n1" />
</Set>
</Abstraction-Type>
<Display-Type>
<DTree connected="false">
<Root-Node Heading="Error handling statements">
<Tree-Node>
<Tree-Node Data="n1" />
</Tree-Node>
</Root-Node>
</DTree>
</Display-Type>
</Map>
This specification maps the statement type to Tree type, and shows all error handling statements as nodes of a tree. Tables and Matrix are other display types supported.
The second kind of display specification is an operational specification of tool execution. This specification is an XML specification, and allows the execution environment to set up menus in the GUI, which (when clicked) initiate execution of the specified tool.

Codegen specifications
These specifications will allow analysts to specify transformation of the source programs to desired target programs. This will be based on analysis abstractions extracted earlier. One example is to separate the source programs into GUI layer and business layer. Code generation capability will need to generate concrete syntax of the target programs.At the moment, we are working on these specifications.


Specification Execution



The analysis and transformation framework is designed to be inter- pretive. The sole purpose is that the analysts can build reverse en- gineering tools quickly, and ex- plore by changing the tool speci- fications and viewing the changed behaviour of the tool. Vari- ous engines are provided to sup- port the execution environment: search engine, abstraction engine, display engine and data-flow ana- lyzer.

The framework can be viewed as a model transformer, which accepts the model representing the source programs as input, and allows analysts to spec- ify transformations to generate models representing program understanding.

Status
Having reused existing parsers, model representation of programs and ana- lyzer generator, the framework is currently in a prototype stage. Using the prototype, we are defining ER (Entity-Relationship) model extraction from COBOL programs. We propose to use this framework for DFD (Data-Flow) model extraction, both of these geared towards system documentation initia- tive.
We plan to extend the framework by supporting model types, and code generation. We also plan to add more viewing primitives. We hope that we can use third-party softwares, especially for viewing, by supporting standard exchange formats like [8].

Implementing a reverse engineering tool using the framework
We describe below the steps involved in defining and implementing a reverse engineering tool using the framework. The steps mentioned here are indicative. The analyst identifies the abstractions that are to be delivered (e.g. Call graph report, Error handling statements, Entity-Relations model, etc.). For
each abstraction, analyst defines the representation / type.
Analyst creates the GUI specifications for windows to be used, menus, menu-items and icons for the same, and associate the menu-items / icons with the name of tool specification (to be written next).
Analyst writes the search and transformation specifications for the tools. Simultaneously, he writes the mapping specifications for the display and re- quired user interaction.
Analyst implements the non-framework-based-tools (if any). This imple- mentation needs to comply with the type-system of the framework and inter- faces.
Analyst starts execution of the framework, which has a pre-defined user- interface. In case of framework-based-tool, analyst builds the tool. This runs the specification processor, generates interpreter instructions, and adds the tool to the menus of the framework. In case of non-framework-based-tool, analyst uses the build menu to specify mapping between tool and the class that implements the tool. The build will add the tool to the menus of the framework.

Sample specification
Included is a sample specification for extraction of Entities, Attributes for data files of COBOL. This specification treats each logical file that is accessed in a COBOL program as an entity, and its (record’s) layout as attribute. Other necessary functions are not included in this example, since this is meant to give a flavour of the specifications.
/* Extracting Entities -	*
Logical files accessed in programs are entities	*
Extracting Attributes -	*
Simple attributes are extracted from the record layouts */
//entity = ⟨ name, username, set of attributes, 01 level var,
//    corresponding logicalfile, set of physical files ⟩
typedef entity record ⟨ string, string, set attribute, decl, lfile, set pfile ⟩;
//attribute = ⟨ name, username, type, var, property (PK/FK) ⟩

typedef attribute record ⟨ string, string, string, decl, string ⟩;
//Extract all entities and attributes of each entity
set entity getAllEntities ( )
{
set lfile lFileSet;
lfile lFile;
set decl level01VarSet;
decl level01var;
set record ⟨ decl, string, lfile, set pfile ⟩ tempEntitySet = { };
record ⟨ decl, string, lfile, set pfile ⟩ tempEntityTup;
set attribute attrSet;
set decl attribVarSet;
entity   e;   set   entity   enSet   =   {   }; decl attribVar; string assgnName, Uname, pic, entityName;
lFileSet = select $lfile from $PROAXROOT; for each lFile in lFileSet
{
level01VarSet = layout(lFile);
for each level01Var in level0VarSet
{
tempEntitySet += ⟨ level01Var, assgnName, lFile, { } ⟩;
}
}
for each tempEntityTup in tempEntitySet
{
level01Var = atIndex ( tempEntityTup, 0 );
attribVarSet = getAttributes ( level01Var );
for each attribVar in attribVarSet
{
Uname = getName ( attribVar );
pic = getPicture ( attribVar );
attrSet += ⟨ Uname, ”null”, pic, attribVar, ”null” ⟩;
}
entityName = getName ( level01Var );
lFile = atIndex ( tempEntityTup, 2 ); aPfileSet = atIndex ( tempEntityTup, 3 );
e = ⟨ entityName, ”null”, attrSet, level01Var, lFile, aPfileSet ⟩;
enSet += e;
}

return enSet;
}
Conclusions
Based on our experience of building restructuring tools, we have evolved a specification driven reverse engineering framework that is independent of the programming language. The prototype has enabled tool builders to rapidly experiment with program analysis based, reverse engineering tools, and change the tool behaviour quickly. We believe that support for model generation, a proper balance between number of primitives and flexibility of specifications, and ability to integrate existing viewing tools, will go a long way to prove utility of this framework.

References
SEEC Mosaic, URL: http://www.asera.com/seecmosaic.shtml.
CERTC, Cobol Explorer from Reliance Technology Consultants, URL:
http://www.cobolexplorer.com.
Acacia, C++ Information Abstraction System, URL:
http://www.research.att.com/sw/tools/Acacia/.
CPPAnal and GUPRO, URL: http://www.uni-koblenz.de/ clange/IWPCPaper.pdf.
Dali, Architecture Reconstruction Workbench, URL:
http://www.sei.cmu.edu/ata/products-services/dali.html.
Darpan: Tata Research Development and Design Centre, TRDDC, Pune, India: Internal Technical Report, US Patent Pending, URL: http://www.pune.tcs.co.in/aboutus.htm.
Programmable Reverse Engineering: Scott R. Tilley, Kenny Wong, Margaret-Anne D. Storey, Hausi A. Muller, URL: http://www.rigi.csc.uvic.ca/Pages/publications/pre-abs.html.
Graph Exchange Language: Richard C. Holt, Andy Schurr, Suson Elliot Sim, Andreas Winter, URL: http://www.gupro.de/GXL/Introduction/background.html.
Revised Submission for MOF 2.0 Query / Views / Transformations RFP, URL:
http://qvtp.org/downloads/.
Model-based Design of Reverse Engineering Tools: Stan Jarzabek, Guosheng Wang: Journal of Software Maintenance: Research and Practice 1998.
