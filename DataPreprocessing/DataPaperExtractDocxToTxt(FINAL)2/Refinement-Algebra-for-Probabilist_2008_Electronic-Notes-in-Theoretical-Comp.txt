	Electronic Notes in Theoretical Computer Science 201 (2008) 177–195	
www.elsevier.com/locate/entcs


Refinement Algebra for Probabilistic Programs
Larissa Meinicke1,3
A˚bo Akademi, A˚bo, Finland
Kim Solin2,4
A˚bo Akademi, A˚bo, Finland

Abstract
We propose an abstract refinement algebra for reasoning about probabilistic programs in a total- correctness setting. The algebra is equipped with operators that determine whether a program is enabled, has certain failure or does not have certain failure, respectively. As an application, refinement rules for probabilistic action systems are derived in the algebra.
Keywords: refinement algebra, probability, Kleene algebra, action systems, data refinement


Introduction
Suppose one would like to replace the probabilistic program
while g do x p1 ⊕ y od; while g do u p2 ⊕ v od

1 Work partially done while at School of Information Technology and Electrical Engineer- ing, University of Queensland. Partially supported by Australian Research Council (ARC) Discovery Grant DP0558408, Analysing and generating fault-tolerant real-time systems.
2 Work partially done while visiting Institut fu¨r Informatik, Universita¨t Augsburg.
3 Email: larissa.meinicke@abo.fi
4 Email: kim.solin@abo.fi



1571-0661 © 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.02.020

by the probabilistic program
while g do x p1 ⊕ y od,
so as to get rid of the vacuous successor loop – the end goal being, for example, compiler optimisation. To do this, one would like a technique of transforming the initial program into the latter while preserving some notion of correctness. This technique should aspire to being both reliable and uncomplicated to use. Which methods are at hand?
Abstract algebra has a solid mathematical underpinning and simultane- ously provides a perspicuous notation that allows for simple symbol pushing instead of tedious model-theoretic reasoning. There have been several exam- ples of abstract algebra as an efficient reasoning tool. One of the earliest such abstract algebras is Kleene algebra with tests, which was employed by Kozen for proving transformation rules of loops [4]. Recently, McIver, Cohen and Morgan used probabilistic Kleene algebra for protocol verification [5] and Solin and von Wright used refinement algebras for program reasoning in a total-correctness environment [14,15,12,11].
In this paper, we present an abstract algebra for reasoning about prob- abilistic programs. It lifts the concrete-algebraic approach to probabilistic programs of Meinicke and Hayes [8] to a more abstract level, in the same way that Solin and von Wright [14,15,12] lift the concrete-algebraic approach to non-probabilistic programs of Back and von Wright [2]. The lifting not only provides a more perspicuous notation, but also allows for results proved in the algebra to be reused over different models for which the axiomatisation is sound. It also paves a more treadable way for automation.
We propose an abstraction which allows reasoning about total correctness,
i.e. the program transformations that are done are valid also when the pro- grams reasoned about are not necessarily terminating. The ability to assume that programs are possibly non-terminating is an important part of any form of reasoning about programs – a non-terminating loop is a classical program- ming error. Therefore a framework that only allows for reasoning in a partial correctness framework (such as the probabilistic Kleene algebra [5]) is not satisfactory.
The probabilistic refinement algebra has operators to represent sequential composition, choice and iteration. It is very similar to Kleene algebra, which constitutes a complete axiomatisation for the algebra of regular languages. The main differences to Kleene algebra is the addition of an iteration operator that is to model an iteration that either terminates or goes on forever, and the modification of three axioms. Although the elements in the carrier set may be interpreted to be probabilistic programs, we do not include a probabilistic

choice operator in our algebra. This decision reflects an important observation: many non-trivial transformation rules for probabilistic systems, such as the data refinement rules we derive in Sect. 6, may in fact be specified and verified without having to reason directly about probabilistic choices. We consider the elegance and simplicity of the framework to be a virtue. By not including a probabilistic choice operator we do not unnecessarily restrict its generality.
We do introduce guards and assertions into the refinement algebra. Guards form a Boolean subalgebra of the carrier set and can be used when modeling for example the predicates of conditionals and loops. Since Boolean algebra is again a very well-known structure, this does not endanger the simplicity of the abstraction. Assertions, which can also be used to model predicates but behave differently from guards when the predicate does not hold, are defined in terms of guards. Moreover, we define operators that determine whether a program is enabled, has certain failure (will abort with probability one) or does not have certain failure, respectively. The last-mentioned operators are similar to the domain operator of relational algebra and thus familiar to several with a background in computer science or discrete mathematics.
To show the elegance of the abstract-algebraic method, we apply the alge- bra to reasoning about action systems. Action systems can be used for model- ing parallel or distributed systems in which concurrent behaviour is modeled by interleaving atomic actions [1]. Probabilistic action systems extend action systems to account also for probabilistic behaviour, in that the actions are allowed to be probabilistic programs [10]. Employing the enabledness and the certain-failure operator we show how to prove data refinement rules of probabilistic action systems in the refinement algebra.
Our contribution in this paper is two-fold: firstly, the construction of an abstract refinement algebra for probabilistic programs in the style of Solin and von Wright and the development of its basic theory, and secondly the algebra’s application to the derivation of refinement rules for probabilistic action sys- tems. To make the presentation clearer, we will first build up the theory and only when this is done we apply the algebra. In the two following sections we thus present a probabilistic demonic reﬁnement algebra. We then introduce guards and assertions in Sect. 4, and enabledness and failure operators in Sect. 5. In Sect. 6 we use the refinement algebra to prove properties of prob- abilistic action systems: we derive three data refinement rules. We conclude in Sect. 7.

Probabilistic Demonic Refinement Algebra
In this section we introduce a probabilistic demonic refinement algebra. It ab- stracts the concrete expectation-transformer algebra of Meinicke and Hayes [8], and it is closely related to the abstract algebras presented in [15,5,13,9]. The algebra is axiomatised over the operators
; , H,∗ , and ω,

and the constants
T and 1.

The elements of the carrier set can be seen as probabilistic program state- ments. The operators should then be understood so that H is demonic choice – a choice we cannot affect and which is not made with respect to any prob- ability – and ; is sequential composition. The constant T is magic, a program statement that establishes any postcondition; and 1 is skip. Weak iteration ∗ (the Kleene star) can be seen as an iteration of any finite length. Strong iter- ation ω is an iteration that either terminates or goes on infinitely. The strong iteration operator may be used to model well-known programming statements such as while-loops, which are possibly non-terminating. While-loops that are certainly terminating may be more specifically modeled using the weak iteration operator. We also define a reﬁnement ordering on the algebra by
x ± y edf x H y = x

to be read “y establishes anything that x does and possibly more” (intuitively, if x is refined by y, then a demon would always choose x since y can do anything that x does and possibly more; by choosing x the demon has a better chance of winning).
Definition 2.1 A probabilistic demonic refinement algebra (pDRA) is a structure over the signature
(; , H,∗ ,ω , T, 1)
satisfying the following axioms and rules (H has least precedence, followed by
;, and then ∗ and ω, which have equal precedence – we omit ; so that x; y is written xy when no confusion can arise):

x H (y H z)= (x H y) H z,	(1)
x H y = y H x,	(2)
x HT = x,	(3)
x H x = x,	(4)
x(yz)= (xy)z,	(5)
1x = x = x1,	(6)
Tx = T,	(7)
x(y H z) ± xy H xz,	(8)
(x H y)z = xz H yz,	(9)
x∗ =1 H xx∗,	(10)
x∗ =1 H x∗(x H 1),	(11)
x ± yx H z ⇒x ± y∗z,	(12)
x ± x(y H 1) H z ⇒x ± zy∗,	(13)
xω =1 H xxω and	(14)
yx H z ± x⇒yωz ± x,	(15)
where the order ± is deﬁned by x ± y edf x H y = x.	 
To model program abortion, we define a constant ⊥ by
⊥ =df 1ω	(16)
and it is easily verified via axioms (15) and (6) that
⊥± x and ⊥x = ⊥	(17)
hold for any x [14], so ⊥ is a least element and is right annihilating. In a program interpretation, ⊥ may be seen as abort, a program establishing no postcondition. It is easy to prove that all the operators are isotone in all their arguments with respect to ± and that ± is a partial order.
The operators can be given an interpretation such that the set of expec- tation transformers over a fixed and finite state space that satisfy both sub- linearity and infinite scaling forms a pDRA (cf. App. A). All the concepts introduced in the rest of this paper can also be given expectation-transformer interpretations as sketched in App. A (we will not explicitly point this out in the sequel). This interpretation is our motivating and working model, but it is not to be seen as exclusive.
Let us look a bit closer at some of the axioms. Most of those not pertaining to the strong iteration operator should be familiar from Kleene algebra: in fact one of the Kleene algebra axioms is absent and three have been modified. The annihilation axiom, xT = T, is absent so that we can model non-termination.

For the same reason it is also excluded from other algebras including the de- monic refinement algebra [14] and M¨oller’s lazy Kleene algebra [9]. The three axioms from Kleene algebra which have been modified are right distributivity,
x(y H z)= xy H xz,	(18)
and the unfolding and induction axioms
x∗ =1 H x∗x and	(19)
x ± xy H z ⇒x ± zy∗.	(20)
As noted by Meinicke and Hayes [8], these properties do not hold for pro- grams which exhibit branching behaviour, and so right-distributivity is suit- ably weakened to right sub-distributivity (axiom (8)), and the unfolding and induction axioms are replaced by axioms (11) and (13). A similar generali- sation is also made in probabilistic Kleene algebra [5] and the monodic tree Kleene algebra [13]. Axiom (11) may be derived from the others, but is in- cluded for clarity. 5
As in the demonic refinement algebra (DRA) [14], we include unfolding
(14) and induction (15) axioms for the strong iteration operator. Unlike the demonic refinement algebra and lazy omega algebra [9], our algebra does not include the isolation axiom, xω = x∗HxωT, which states that a strong iteration may be decomposed into a simple choice between performing any finite or any infinite number of iterations: this property is not satisfied by probabilistic programs [8].
Although the primary focus of this paper is performing total correctness reasoning, we do not exclude discussions of the weak-iteration operator, since it can be applied when it is reasonable to assume that an iteration is termi- nating (see [5,8]). In Sect. 6 we show how weak iteration, via the new axiom (13), plays an important role in the derivation of a data refinement rule for probabilistic action systems.

Healthiness conditions and basic properties
In this section we introduce “healthiness conditions” and also derive some basic properties of the algebra. The healthiness conditions are stated in a fashion that would correspond to defining them in a point-free way in the expectation-transformer model, that is without going down to the level of expectations.

5 In the monodic tree Kleene algebra the axiom 1 + x∗(x + 1) ≤ x∗ could thus also be elided.

We thus say that an element x is conjunctive if it satisfies
x(y H z)= xy H xz	(21)
for any y and z in the carrier set. As mentioned in the previous section, conjunctivity is not satisfied by all probabilistic programs, hence it is not an axiom of pDRA. It is, however, satisfied by a large subset of these: the programs which do not include probabilistic choices. When it is reasonable to take conjuctivity as an assumption, many useful transformation rules which would otherwise not hold, may be verified. Also, we say that an element x is continuous if the condition
(6n • x(yn H u) ± zxn H vx) ⇒ xyωu ± zωvx	(22)
holds for any y, z, u and v in the carrier set (the bounded n is also in the carrier set). 6 Continuity is required in order to prove some useful commutativity rules for iterations.
Our axiomatisation extends von Wright’s general refinement algebra [15] with axioms (11) and (13) concerning weak iteration, so every proposition proved in general refinement algebra also holds in pDRA. We do for example have the following decomposition and leapfrog properties of strong iteration.
Proposition 3.1 For any x and y in the carrier set of a pDRA
(x H y)ω = xω(yxω)ω,	(23)
x(yx)ω ± (xy)ωx and	(24)
x(yx)ω = (xy)ωx, provided x is conjunctive,	(25)
hold.
In fact, the two first data refinement rules of Sect. 6 (in which we only consider strong iteration) are essentially applications of general refinement algebra – but taking into account the new definition of guards in the next section and the novel failure operator of Sect. 5. On the other hand, the new weak iteration axioms (11) and (13) are essential for the last data refinement rule of Sect. 6. The weak-iteration property
x∗ = x∗x∗,	(26)
for any x in the carrier set of a pDRA, is easy to prove and will be used in our application.

6 The condition is closely related to the fusion lemma of fixpoint theory. So, continuity is, in a certain sense, here defined via the fusion lemma. A point-free abstraction of the common definition of continuity would require an angelic-choice operator.

Guards, Assertions and the Initial Question
We now introduce guards and assertions into the algebra. Guards are to be seen as statements that check if a predicate holds and skip if the predicate holds, otherwise behave like magic. Guards must be introduced slightly differ- ently than in [14,15], since not every element is conjunctive but we still want guards to satisfy conjunctivity. Hence, an element g of the carrier set that
is conjunctive and
has a conjunctive complement g¯ satisfying g¯g = gg¯ = T and g H g¯ =1 
is called a guard. The first guard equation in the second condition says that either a predicate or its negation holds, and therefore a sequential composition of a guard and its complement will always result in a miracle. The second guard equation says that a demon will always be able to make the program skip when choosing between a guard and the guard’s complement. It can be established that the guards form a Boolean algebra (BA) over (H, ; , ¯ , 1, T), where H is meet, ; is join, ¯ is complement, 1 is the least element, and T is the greatest element [14].
Every guard is defined to have a corresponding assertion
g◦ = g¯⊥H 1	(27)
and so ◦ is a mapping from guards to a subset of the carrier set: the set of assertions. Assertions work in the same way as guards, except that they abort if the predicate does not hold. If the predicate does not hold, then a demon would choose the left hand side of the demonic choice: the negated guard would skip and the whole program abort (which is what a demon wants). If, on the other hand, the predicate holds, then a demon would choose the right hand side, since otherwise the negated guard would do magic and the demon would lose (the demon could then no longer establish abortion). Note that
g◦ = g¯⊥H g	(28)
can be shown equivalent to (27). It is easy to show that
g◦ ± 1 ± g2	(29)
holds for any assertion g◦ and any guard g2 [14]. The properties
gg◦ = g and g◦g = g◦	(30)
are also easy to prove and will be used later on.

As already mentioned, pDRA specifically requires that guards are con- junctive, which differs from DRA in which all elements by axiomatisation are conjunctive. On the other hand, the conjunctivity of assertions can be shown (by the definition of assertions and applying some basic axioms) to follow from the conjunctivity of guards.
Consider now our initial question in the introduction. With guards defined, we can express, for example, a probabilistic while-loop
while g do x p ⊕ y od
as (gu)ωg¯ in the algebra, where u is the abstraction of the binary probabilistic choice between probabilistic programs x and y, and the guard g expresses the guard of the loop. Our initial question can then be rephrased to asking if
(gu)ωg¯; (gv)ω; g¯ = (gu)ω; g¯ 
is true for any guard g and any u and v in the carrier set of a pDRA. That this is indeed the case follows from that fact that for any guard g and any carrier-set element x, it can be proved that
g¯(gx)ω = g¯ 
holds (by unfolding of strong iteration (14), the definition of guards and the fact that T is the top element (3)). This and the fact that the guards form a Boolean algebra shows that the successor loop can be elided.
Enabledness and Failure
In this section we introduce the enabledness and the failure operators. The en- abledness operator behaves just like in refinement algebra for non-probabilistic programs and the not-certain-failure operator is a probabilistic counterpart to the termination operator of non-probabilistic refinement algebra [12].
Enabledness
The enabledness operator ϵ is a unary operator that maps a carrier-set element of a pDRA to a guard and satisfies the axioms
ϵxx = x,	(31)
g ± ϵ(gx),	(32)
ϵ(xy)= ϵ(xϵy) and	(33)
ϵx⊥ = x⊥.	(34)

We will call a pDRA with an enabledness operator a pDRAe.
The intuition of ϵx is that it returns a guard that skips in those states from which x is not miraculous. That is to say, ϵx checks whether the program is enabled or not. The first axiom thus says that a program is equal to the same program preceded by a guard that checks if it is enabled: if the program is enabled, the guard skips and then executes the program, if the program is not enabled (that is, it will perform a miracle), the guard will not hold and thus the whole program will do magic. The other axioms can be interpreted similarly. Our axioms are suitable for probabilistic models in which programs are either miraculous from a given initial state, or they are not.
The properties
ϵ(x H y)= ϵx H ϵy and	(35)
x ± y ⇒ϵx ± ϵy	(36)
can be shown to hold by a similar proof as for the domain operator in [3], taking into consideration that guards are conjunctive.
Termination and Failure
For non-probabilistic demonic refinement algebra, a termination operator was defined by Solin and von Wright [12,11]. When applied to a non-probabilistic program, this termination operator returns an assertion that skips in those states from which the program will terminate, otherwise it aborts.
Since probabilistic programs terminate with some probability, a probabilis- tic termination operator might be expected to return a probabilistic assertion that skips with a probability equal to the termination probability of the pro- gram and aborts with a probability equal to the probability that the program will not terminate. The usefulness of such a termination operator is debatable, and, to express it we would also have to introduce probabilistic assertions into our algebra. Instead, we define a not-certain-failure operator which acts as a counterpart to the non-probabilistic termination operator. We define the not-certain-failure operator via an abstraction of the fail operator defined on expectation transformers by Meinicke and Hayes [8]. The intuition behind the fail operator is a guard that checks whether a program certainly aborts, and the intuition behind the not-certain-failure operator an assertion that skips in those states from which the program does not certainly fail – that is, the program has got a chance of terminating.
We denote the fail operator by f and define it as a mapping from the carrier set to the set of guards satisfying
fx⊥ = xT.	(37)
A pDRA with a failure operator we will denote pDRAf and a pDRA with an

enabledness operator and a failure operator we denote pDRAef. 7
When we define the not-certain-failure operator τ as
◦

τx = fx	(38)
this operator satisfies the axioms of the termination operator of non- probabilistic demonic refinement algebra [12,11]. That is to say, it can be verified (directly from (38) and axiom (37)) that τ satisfies
x = τxx,	(39)
τ (g◦x) ± g◦,	(40)
τ (xτy)= τ (xy),	(41)
τ xT = xT and	(42)
τ (x H y)= τx H τy.	(43)
Let us again look at the first axiom. It says that any program x is equal to a program consisting of an assertion that first checks that x will not certainly fail (will not abort) and then executes x: if x certainly fails, then the assertion fails so the composite program aborts, whereas if x does not certainly fail, then the assertion skips and x gets executed. Note that the fail operator cannot be defined in terms of the not-certain-failure operator, since this would demand the possibility to define guards in terms of assertions.
The failure operator satisfies the following properties that we will use later on. The first property says that a program can be refined by statement that checks that the program fails and then aborts (remember that the failure is checked by a guard, and thus a miracle happens if the program fails). The second property says that any program composed of any number of statements is refined by a program that checks if the first statement fails.
Proposition 5.1 For any x and y in the carrier set of a pDRAef
x± fx⊥ and	(44)
xy ± fx	(45)
hold.
Proof. The first part is proved by
x = x(TH 1) ± xTH x = fx⊥H x,
which holds by the definition of ±, the basic axioms (8) and (6) of the algebra and axiom (37). Then, by the first part of this proposition (44), property (17)

7 It can be shown that not all pDRAs are pDRAefs.

twice and axiom (6) we have
xy ± fx⊥y = fx⊥± fx1= fx
which proves the second property.	 

Data Refinement of Probabilistic Action Systems
This section comprises an application of our algebra to data refinement of action systems. Action systems can be used for reasoning about parallel or distributed systems in which concurrent behaviour is modeled by interleaving atomic actions [1]. Probabilistic action systems extend action systems to account also for probabilistic behaviour, in that the actions are allowed to be probabilistic programs [10]. An action system
do x1[] ... []xn od
is an iteration of a set of actions x1, ..., xn that terminates when none of the actions are enabled, that is to say, the iteration continues as long as any action is enabled. In the abstract algebra, we encode an action system as a strong iteration of a demonic choice between n actions and we express the termination condition with the aid of the enabledness operator [12,2,8]:
do x1[] ... []xn od =df (x1 H· · · H xn)ωϵx1 ... ϵxn.
The strong-iteration operator allows us to model action systems in tune with our urge for total-correctness: we allow infinite iterations to be expressed.
During the derivation of a program, the process of refining a so-called abstract program by a so-called concrete program that uses a different data representation is called data refinement. For probabilistic programs y, z and x, the program y is said to be data reﬁned by z through x if either
xy ± zx or yx ± xz.
In the first instance, the probabilistic program x can be seen to represent a (probabilistic) mapping from the concrete state of z to the abstract state of y, and in the second x can be seen to represent a (probabilistic) mapping from the abstract state of y to the concrete state of z. We refer to data refinement in the first instance as upward simulation, and downward simulation in the second instance.

Upward simulation. An upward simulation data-refinement rule for proba- bilistic action systems
x; do y od ± do z od; x
can be shown to hold assuming that
xy ± zx and
x(fy H ϵy) ± ϵzx
hold, that is, assuming that y is upwards data refined by z through x, and assuming that fy H ϵy is upwards data refined by ϵz through x. The first condition constrains the loop body y to be data refined by z, the second constrains the termination of the loops: it states that z may only be disabled when y either aborts or is disabled. To prove this we first derive an important general commutativity property: for any x, y, z, u and v in the carrier set of a pDRAef such that x is continuous we have that
xyωu ± zωvx	(46)
provided
xy ± zx and	(47)
x(fy H u) ± vx.	(48)
It can be proved as follows. For any n, x(yn H u)
=	{[ idempotence (4) ]}
x(yn H u) H x(yn H u)
±	{[ definition of ±, (45), isotony ]}
xyn H x(fy H u)
±	{[ assumptions (47) and (48), isotony ]}
zxn H vx,
and since x is continuous, the desired property follows from the continuity condition (22). The data refinement rule then follows by setting u to be ϵy and v to be ϵz.
The above commutativity property is more general than the theorem proved by Meinicke and Hayes in the concrete expectation transformer algebra [8], since there u and v are constrained to be guards.
Downward simlulation. Probabilistic action systems also have a downward simulation data-refinement rule, given by
do y od; x ± x; do z od

provided
(ϵy)◦yx ± x(ϵz)◦z and
xϵz ± ϵyx
hold, that is, provided (ϵy)◦y is downwards data refined by (ϵz)◦z through x, and provided ϵz is upwards data refined by ϵy through x. To prove this, we again first establish a general commutativity property: for any x, y and z in the carrier set and g1 and g2 in the guard set of a pDRA we have that
(g1y)ωg¯1x ± x(g2z)ωg¯2	(49)
provided
g1◦yx ± xg2◦z and	(50)
xg¯2 ± g¯1x.	(51)
This property was first proved in the concrete expectation-transformer algebra by Meinicke and Hayes [8]. We here present their proof as a smooth and transparent derivation in the abstract algebra: First, we have that
(g1y)ωg¯1x ± x(g2z)ωg¯2
⇐	{[ (15) ]}
g1yx(g2z)ωg¯2 H g¯1x ± x(g2z)ωg¯2
holds. That the antecedent follows from the assumptions is settled by
g1yx(g2z)ωg¯2 H g¯1x
=	{[ (30) ]}
g1g1◦yx(g2z)ωg¯2 H g¯1x
±	{[ assumption (50), isotony ]}
g1xg2◦z(g2z)ωg¯2 H g¯1x
=	{[ assertion definition (28) ]}
g1x(g¯2⊥H g2)z(g2z)ωg¯2 H g¯1x
=	{[ left distributivity (9) and preemption (17) ]}
g1x(g¯2⊥H g2z(g2z)ωg¯2) H g¯1x
±	{[ ⊥± 1, commutativity (2) ]}
g1x(g2z(g2z)ωg¯2 H g¯2) H g¯1x
=	{[ left distributivity (9) ]}
g1x(g2z(g2z)ω H 1)g¯2 H g¯1x
=	{[ folding (14) ]}
g1x(g2z)ωg¯2 H g¯1x
±	{[ 1 is unit (6), (29) ]}
g1x(g2z)ωg¯2 H g¯1xg¯2
=	{[ guards BA, preemption (7),T is unit (3) ]}
g1x(g2z)ωg¯2 H g¯1x(g¯2g2z(g2z)ω H g¯2)

=	{[ guards are conjunctive ]}
g1x(g2z)ωg¯2 H g¯1xg¯2(g2z(g2z)ω H 1)
±	{[ folding (14), 1 is unit (6), (29) ]}
g1x(g2z)ωg¯2 H g¯1xg¯2(g2z)ωg¯2
±	{[ assumption (51), guards BA ]}
g1x(g2z)ωg¯2 H g¯1x(g2z)ωg¯2
=		{[ left distributivity (9) ]} (g1 H g¯1)x(g2z)ωg¯2
=	{[ guard properties ]}
x(g2z)ωg¯2.
The data refinement rule then follows by setting g1 to be ϵy, setting g2 to be
ϵz, and taking the first enabledness axiom (31) into account.
General downward simulation. Unlike both the upward and downward simulation rules that have been presented, the following simulation rule al- lows data refinements to be verified between action systems in which finite sequences of stuttering steps have been added or removed – so a direct corre- spondence between the actions is not required. Since the sequences of stut- tering steps are assumed to be finite, the verification of this rule requires reasoning about both weak and strong iterations. Importantly, the finite- iteration assumption allows us to use the new weak iteration axiom (13), for which there is no counterpart for strong iteration. The rule [7] states that
do y od; x ± x; do z od
provided y = yq H y , z = zq H z , yqω = yq∗, zqω = zq∗, and
yq∗x± x(zq H 1),	(52)
(ϵy)◦y yq∗x± x(ϵz)◦z  and	(53)
xϵz ± ϵyx.	(54)
We refer to yq and zq as the stuttering actions, and y and z as the non- stuttering actions. The proof of Meinicke and Hayes [7] may then be expressed as a derivation in our abstract algebra.
From decomposition (Prop. 3.1 (23)), the general commutativity property presented for downward simulation, and the assumption that the iterations of yq and zq are terminating, it is sufficient to show that the following conditions hold
yq∗x± xzq∗,	(55)
(ϵy)◦y yq∗x± x(ϵz)◦z zq∗ and	(56)
xϵz ± ϵyx.	(57)

Condition (55) may be shown to hold given (52) as follows:
yq∗x ± x(zq H 1)
⇒	{[ isotony ]}
yq∗yq∗x ± yq∗x(zq H 1)
e	{[ (26) ]}
yq∗x ± yq∗x(zq H 1)
⇒	{[ from unfolding (10) yq∗x ± x, and refinement definition ]}
yq∗x ± yq∗x(zq H 1) H x
⇒	{[ induction (11) ]}
yq∗x ± xzq∗
Assuming (55) and (53), (56) can be shown to hold by (ϵy)◦y yq∗x
=	{[ (26) ]}
(ϵy)◦y yq∗yq∗x
±		{[ assumption (55) ]} (ϵy)◦y yq∗xzq∗
±	{[ assumption (53) ]}
x(ϵz)◦z zq∗.
Conditions (57) and (54) are equal.

Concluding Remarks and Outlook
In this paper we showed that abstract-algebraic reasoning also works well when probabilistic programs are concerned. We proposed a probabilistic refinement algebra facilitating total correctness and including a strong iteration operator, as well as operators for enabledness and certain failure. As an application, probabilistic action systems were cast in the abstract algebra and three data refinement rules were established.
This research could be taken further in several directions. One direction would be to introduce angelic choice into the algebra and another direction would be to consider probabilistic choice abstractly. It should also be interesting to apply the algebra to more elaborate case studies.


Acknowledgement
The authors are grateful to R.J.R. Back, Ian J. Hayes, Bernhard Mo¨ller, Graeme Smith and an anonymous referee for helpful suggestions.

References
R.J.R. Back and R. Kurki-Suonio. Decentralization of process nets with centralized control. In Proc. of the 2nd ACM SIGACT-SIGOPS Symp. on Principles of Distributed Computing, pages 131–142. ACM Press, 1983.
R.J.R. Back and J. von Wright. Reasoning algebraically about loops. Acta Informatica, 36(4):295–334, 1999.
J. Desharnais, B. M¨oller, and G. Struth. Kleene algebra with domain. ACM Transactions on Computational Logic, 7(4):798–833, 2006.
Dexter Kozen. Kleene algebra with tests. ACM Transactions on Programming Languages and Systems, 19(3):427–443, 1997.
A. K. McIver, E. Cohen, and C. C. Morgan. Using probabilistic Kleene algebra for protocol verification. In Relations and Kleene Algebra in Computer Science, volume 4136 of LNCS, pages 296–310, 2006.
Annabelle McIver and Carroll Morgan. Abstraction, Reﬁnement and Proof for Probabilistic Systems. Monographs in Computer Science. Springer, 2005.
Larissa Meinicke and Ian J. Hayes. Algebraic reasoning for probabilistic action systems and while-loops. Technical Report SSE-2006-05, School of Information Technology and Electrical Engineering, The University of Queensland, September 2006.
Larissa Meinicke and Ian J. Hayes. Reasoning algebraically about probabilistic loops. In Eighth Internatinal Conference on Formal Engineering Methods, volume 4260 of LNCS, 2006.
Bernhard M¨oller. Lazy Kleene algebra. In Mathematics of Program Construction, volume 3125 of LNCS, pages 252–273. Springer-Verlag, 2004.
Kaisa Sere and Elena Troubitsyna. Probabilities in action systems. In Proc. of the 8th Nordic Workshop on Programming Theory. Helsinki: Publishing Association, 1996.
Kim Solin. On two dually nondeterministic refinement algebras. In Relations and Kleene Algebra in Computer Science, volume 4136 of LNCS, pages 373–387, 2006.
Kim Solin and Joakim von Wright. Refinement algebra with operators for enabledness and termination. In Mathematics of Program Construction, volume 4014 of LNCS, pages 397–415. Springer, 2006.
Toshinori Takai and Hitoshi Furusawa. Monodic tree Kleene algebra. In Relations and Kleene Algebra in Computer Science, volume 4136 of LNCS, pages 402–416, 2006.
Joakim von Wright. From Kleene algebra to refinement algebra. In Mathematics of Program Construction, volume 2386 of LNCS, pages 233–262. Springer, 2002.
Joakim von Wright. Towards a refinement algebra. Science of Computer Programming, 51:23– 45, 2004.

A  Expectation transformers
This short appendix is written for those who are already somewhat familiar with the theory of expectation transformers. It provides an expectation- transformer interpretation of the concepts involved in the probabilistic refinement algebra. This appendix can unfortunately not be completely self-contained and self-explanatory, but we refer the interested reader to the comprehensive book by McIver and Morgan [6]. We use a slight variation

of the original theory of expectation transformers [6] so that miraculous program behaviour can be expressed. In this variation, which is documented in detail in [8], probabilistic programs may be miraculous from a given initial state with probability either 0 or 1.


Let p be a predicate on state space Σ; φ be an expectation of type S Σ (= Σ → R≥0 ∪ {∞}); and S and T be expectation transformers of type S Σ → S Σ. Let c1 and c2 be constants of type R≥0 ∪ {∞}, c be a constant of type R≥0, β1, β2 and β be expectations, and У be a directed set of expectations. For any subset У of a partially ordered set A, У is directed if (6α, β ∈У • (Eγ ∈У • α ± γ Λ β ± γ)) [2].
magic	T.φ	Infinity	(= (λσ ∈ Σ • ∞))
skip	1.φ	φ
sequential composition	(S; T ).ψ	S.(T.ψ) demonic choice	(S H T ).ψ S.ψ H T.ψ
weak iteration	 (S∗).φ	(νX • S; X H 1).φ strong iteration	 (Sω).φ	(μX • S; X H 1).φ abort	⊥.φ	False	(= (λσ ∈ Σ • 0))
guard	[p].φ	(λσ ∈ Σ • if p.σ then φ.σ else ∞)
assertion	{p}.φ	(λσ ∈ Σ • if p.σ then φ.σ else 0)
enabledness	[ϵ.S]	[(λσ ∈ Σ • S.False.σ = 0)] certain failure	 [f.S]	[(λσ ∈ Σ • S.Infinity.σ = 0)]
(c1 ∗ S.(β1)+ c2 ∗ S.(β2)) g c ≤ S.((c1 ∗ β1 + c2 ∗ β2) g c) (sublinearity)
S.(∞∗ β)= ∞∗ S.β
(infinite scaling)
S.β1 H S.β2 = S.(β1 H β2)
(conjunctivity)
S.(Hβ ∈У • β)= (Hβ ∈У • S.β)	(continuity)
Fig. A.1. Expectation transformer interpretation and healthiness conditions for expectation trans- formers.


In Fig. A.1 the operators, constants and special elements that were treated in the paper are listed in the order of their introduction, and given an expectation transformer interpretation. Fig. A.1 also lists the expectation- transformer concepts that correspond to the healthiness conditions that were mentioned in the paper, and it also contains the definitions of sublinearity and infinite scaling. Informally, infinite scaling and sublinearity characterise the set of probabilistic programs that may include discrete probabilistic and demonic choice. As mentioned, the set of sublinear and infinitely scal- ing expectation transformers over a fixed and finite state space form a pDRAef.
