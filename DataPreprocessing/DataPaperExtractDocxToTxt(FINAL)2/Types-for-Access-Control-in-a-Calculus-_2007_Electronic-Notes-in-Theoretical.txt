Electronic Notes in Theoretical Computer Science 180 (2007) 3–15	
www.elsevier.com/locate/entcs

Types for Access Control in a Calculus of Mobile Resources
Hans Hu¨ttel1
Department of Computer Science, Aalborg University Fredrik Bajersvej 7E, 9220 Aalborg Ø, Denmark
Morten Ku¨hnrich2
Department of Computer Science, University of Copenhagen Universitetsparken 1, 2100 København, Denmark

Abstract
This paper presents a type system for the calculus of Mobile Resources (MR) proposed by Godskesen et al. The type system is able to prevent undesirable border-crossing behaviour such as Trojan horses. This is achieved by combining the notion of group with a notion of security policy. Well-typed processes satisfy a safety property which is preserved under reduction. An algorithm is presented which computes the minimal security policy making a process well typed.
Keywords: Process calculus, mobility, types, access control, type inference.


Introduction
Mobility of software across computer networks is now a widespread phenomenon. Examples range from Java applets moving from servers to clients to the physical movement of a computer between wireless networks. As a result, ensuring the security of such migration has become an important issues.
A number of process calculi based on the π-calculus have been developed to address this and related issues. Examples include the calculus of Mobile Ambients [2], the Seal calculus [8], the Kell calculus [7] and the calculus of mobile resources [3].
In this setting, there already exist a number of type systems that describe infor- mation flow properties. Cardelli et al. introduced a type system for access control

1 E-mail: hans@cs.aau.dk
2 E-mail: mokyhn@diku.dk

1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2005.05.044

within Mobile Ambients [1]. Later, Merro and Sassone presented a type system [5] for border-crossing within the calculus of Boxed Ambients.
In this paper we present a first such type system for the calculus of Mobile Resources proposed by Godskesen et al. [3]. In contrast to e.g. the original for- mulation of Mobile Ambients, migration is objective – a process must be instructed to migrate by some other process. Moreover, the calculus is linear : once occupied, no process can enter a location until it becomes vacant. Finally, unlike e.g. Mobile Ambients, the MR calculus allows migration between arbitrary locations as long as their relative adresses (paths) are known.
Like [1] and [5], our type system is based on the notion of group. Moreover, we introduce a notion of security policy. Because migration may occur between any two locations, the type system needs to keep track of the nesting structure of a process. Still, the resulting type system is in our opinion less complex type than those of [1] and [5].
Our type system guarantees safety: Well-typed processes satisfy a specific safety property and, thanks to a subject reduction theorem, preserve safety under reduc- tion. Moreover (and unlike [5]) we handle type inference, in that we describe how one many compute the minimal security policy which makes a process well typed.

Syntax and semantics of the MR calculus
Syntax
Our syntax is that of [3] extended with type annotations. See Table 1.
We assume countable sets of names N and co-names N. We let m, n,... range over N, let m˜ , n˜,... ⊆N and let α range over N ∪ N. δ, δ',... range over arbitrary sequences from N+, and γ, γ',... range over N∗.
In MR locations are modelled as named slots which may be empty (written
n˜ [·♩m) or contain processes. Slots may be named by any non-empty set of names
n˜. If the name of a slot is unique, we omit brackets.
As slots can be nested, the exact location of a slot is described by its path. The MR calculus describes mobility by a move construct δ D δ' that moves the contents of the slot with path δ to a slot with path δ', provided that an empty slot with this path exists. Slots n˜ [p♩m can be removed by the prefix q m.
The remaining process constructs are standard. They include prefixing with
synchronization actions, parallel composition and replication. Note that a synchro- nization prefix may be a path, allowing communication between slots at different levels of nesting. Restriction makes the name n local to p. Restriction annotates the restricted name n by an s ∈ S, a so-called security policy type, and b ∈ B, which is a group. These will be described in section 3.
Restriction is the sole binder of MR; free names (fn(p)) and bound names (bn(p)) of a process p are defined as expected. The substitution of a free name n for a free name m in p is written p[m := n] and defined as expected. We write p ≡α p' if p' and p are equal up to renaming of bound names.


Table 1
The syntax of mobile resources

The set of slot names sn(p) of a process p is defined as the set of names used as names of slots in p.

Semantics
Our reduction semantics follows that of [3]; reductions correspond to communica- tions and moves. Reductions occur within evaluation contexts.
Definition 2.1 Evaluation contexts E have the syntax
E ::= (−) | n˜ [E♩m | (n : s, b)E | E  p
E(p) means that p is inserted at the hole in (−) in E.
Definition 2.2 The relation of structural equivalence ≡ on P is the least binary reflexive, symmetric and transitive relation satisfying the rules below.

p'')



if n ∈/ fn(q)	(E8) E(p) ≡ E(q),  if p ≡ q.
(E7) (n : s, b)n˜ [p♩m ≡ n˜ [(n : s, b)p♩m , (Eα) p ≡ q, if p ≡α q
if n ∈/ n˜ ∪ {m}

Path contexts denote the positions where moves and synchronizations may occur.

Definition 2.3 The N∗-indexed family of path contexts Cγ is defined by
Cε ::= (−)	Cnγ ::= n˜ [Cγ  p♩m ,
for arbitrary m and p and n˜ with n ∈ n˜.
Resource contexts single out the sources and targets of moves.
Definition 2.4 The resource contexts D are defined as
Dγn ::= Cγ(n˜ [(−)♩m), n ∈ n˜
We can now define the reduction semantics of the MR calculus.
Definition 2.5 Let −→ be the least relation on P satisfying the following rules:
(R1)	γα.p  Cγ(α.q) −→ p  Cγ(q)

(R2)	γδ1 D γδ2.p  Cγ Dδ1 (q)  Dδ2 (·)  −→ p  Cγ Dδ1 (·)  Dδ2 (q) 

(R3)	q m.p
 n˜ [r♩m −→ p,  r = ·∨ r = q

(R4)	E(p) −→ E(q), if p −→ q
(R5)	p' −→ q', if p' ≡ p and p −→ q and q ≡ q'.
The rule (R1) describes synchronization: A process γα.p can interact along a path γ with a process α.q. Rule (R2) describes migration. The (possibly empty) path γ describes the path common to the source slot and the target slot. Rule (R3) defines the semantics of slot deletion. Rules (R4) and (R5) describe the role of evaluation contexts and structural equivalence.

A type system for MR
Our type system assigns information of the form A&e to a process p. Here, A describes the potential interface of p and e the effect (cf. [4]), an abstract description of the potential moves of p.

Groups and security policies
Every slot is assigned a group name and a security policy. A security policy is a quadruple Sec[tg, ts, tr, tm], whose components are sets of types that describe the types of trusted guests (tg), trusted senders (ts), trusted receivers (tr) and possible move actions (tm).
If the set tr is known to be {T1,... , Ti}, we write tr[T1,... , Ti]. A slot whose security policy has this component allows moves to slots whose types are in {T1,... , Ti}. Similarly, a slot with component ts[T1,... , Ti] allows moves from slots of types {T1,... , Ti}, and a slot with component tg[T1,... , Ti] may contain slots of types {T1,... , Ti}. The wildcard type is  ; tr[ ] means that the contents

may be moved to slots of any type, ts[ ] that content may be sent from slots of any type and tg[ ] that slots of any type may occupy the slot.
If a security policy Σ has tr as its set of trusted receivers, we write tr ∈ Σ. The same notation applies for ts, tg and tm.
Definition 3.1 We let B range over a finite set of group names and let Σ range over the set of security policy types S whose syntax is

T ::= B | Σ	groups and security policies
Σ ::= Sec[R S G M ]	security policy
R ::= tr[ ] | tr[T1,... , Ti]	trusted receivers
S ::= ts[ ] | ts[T1,... , Ti]	trusted senders
G ::= tg[ ] | tg[T1,... , Ti]	trusted guests M ::= tm[ D ] | tm[W1,... , Wi]   trusted moves W ::= D B | B D | B D B	basic moves
Note that in any of the components, a security policy can be specified directly instead of providing the name of a group. Also note that we (unlike [5]) can describe full immobility, as TR may be empty.
Example 1 Consider a slot n with security policy Sec[tr[CIA, FBI] ts[Capitol] tg[Politicians] , tm[Politicians D Politicians]]. Here, moves from n to CIA and FBI are allowed (trusted receivers). Also moves from the Capitol to n are allowed (trusted senders). Politicians are welcome to guest n, and moves from any politician to another politician are allowed.

Effects
Effects describe potential migrations up to the groups involved.
Definition 3.2 The set of effects E  of a program are subsets of the set
{x D y | x, y ∈ B} .
Definition 3.3 The set of abstracted effects E∗ is {x D y | x, y ∈ B ∪S ∪ { }} .

Judgements and rules
The typing judgements used in the following are of the form Δ, Γ ▶ p ⇒ A & e, where A ⊆ N , e ∈E and Δ and Γ are the security type environment and the group environment:
Definition 3.4 The security policy type environment Δ is a mapping Δ : N → S. The group environment Γ is a mapping Γ : N → B.
We only consider environments that are well-formed.




(T-Nil)


Δ, Γ ▶ 0 ⇒∅ & ∅
(T-Sync)
Δ, Γ ▶ p ⇒ A & e


Δ, Γ ▶ γα.p ⇒ A & e

(T-Par)
Δ, Γ ▶ p1 ⇒ A1 & e1	Δ, Γ ▶ p2 ⇒ A2 & e2



(T-Bang)
Δ, Γ ▶ p ⇒ A & e


Δ, Γ ▶!p ⇒ A & e
(T-Remove)
Δ, Γ ▶ p ⇒ A & e


Δ, Γ ▶ q n.p ⇒ A & e



(T-Res)
Δ[n '→ s], Γ[n '→ b] ▶ p ⇒ A & e


Δ, Γ ▶ (n : s, b)p ⇒ A \ {n} & e



Table 2
Typing rules for standard processes

Definition 3.5 The well-formedness predicate for arbitrary environment pairs (Γ, Δ) and processes p, wf (p, Δ, Γ), is defined inductively by
wf(0, Δ, Γ) = true
wf(γα.p, Δ, Γ) = wf(p, Δ, Γ)

wf(δ D δ'.p, Δ, Γ) = wf(p, Δ, Γ)
wf(p1  p2, Δ, Γ) = wf(p1, Δ, Γ) ∧ wf(p2, Δ, Γ)
wf(!p, Δ, Γ) = wf(p, Δ, Γ)
wf((n : s, b)p, Δ, Γ) = wf(p, Δ[n '→ s], Γ[n '→ b])
wf(n˜ [·♩l , Δ, Γ) = ∀m, n ∈ n˜ : Δ(m)= Δ(n) ∧ Γ(m)= Γ(n)
wf(n˜ [p♩l , Δ, Γ) = wf(n˜ [·♩l , Δ, Γ) ∧ wf(p, Δ, Γ)
The typing rules are found in Tables 2 and 3. The rules in 3 describe the typing of migration and employ some auxiliary predicates that we shall now define.
In the T-Slot rule the guesthood relation ±Δ,Γ checks that names of slots in p
are allowed to guest the slot with name n˜.
Definition 3.6 Define the relation ±Δ,Γ⊆ P(N) × S by A ±Δ,Γ Σ iff   ∈
tg or ∀n ∈ A : Γ(n) ∈ tg ∨ Δ(n) ∈ tg, where tg ∈ Σ.
The effect relation ± also used in T-Slot checks that a given set of effects stays within the limits given by the security policy.
Definition 3.7 Define the relation ±⊆ E∗ ×S by e ± Σ iff  D ∈ tm or ∀w D w' ∈
e : w D w' ∈ tm ∨  D w' ∈ tm ∨ w D  ∈ tm, where tm ∈ Σ.

In the T-Move rule, the consistentΔ,Γ predicate checks if the paths δ and δ' are consistent. By this we mean that any subslot along the path actually is allowed as a guest in its superslot according to the security policy.
Definition 3.8 Define the predicate consistentΔ,Γ(δ) on N+ by
consistentΔ,Γ(n1 ... nk) iff





(T-Nil-Slot)


Δ, Γ ▶ n˜ [·♩m ⇒ n˜ & ∅
⎛ n ∈ n˜	⎞

	Δ, Γ ▶ p ⇒ A & e	
(T-Slot) Δ, Γ ▶ n˜ [p♩	⇒ A ∪ n˜ & e ⎜⎝ A	±

Δ,Γ
Δ(n) ⎟⎠

e	±	Δ(n)
⎛ δ = γ1n,	⎞
⎜ δ' = γ2n'	⎟

Δ, Γ ▶ p ⇒ A & e
(T-Move)
'
'	⎜ n daΔ,Γ n	⎟

Δ, Γ ▶ δ D δ .p ⇒ A & e ∪ {Γ(n) D Γ(n )}
⎜	⎟
consistentΔ,Γ(δ)
consistentΔ,Γ(δ')

Table 3
Typing rules for MR processes

∀1 ≤ i < k : tg ∈ Δ(ni) ⇒  ∈ tg ∨ tg' ⊆ tg,	where tg' ∈ Δ(ni+1) and
∀1 ≤ i ≤ k : tm ∈ Δ(ni) ⇒ tm ± Δ(ni−1).
Finally, the relation daΔ,Γ guarantees that the receiving slot allows more or just as many guests as the sending slot and that the slots grant each other access.
Definition 3.9 The relation daΔ,Γ⊆N × N is defined by m daΔ,Γ n if
(Guests)  ∈ tg' or tg ⊆ tg',  where tg ∈ Δ(m), tg' ∈ Δ(n).
(Sender and receiver)
∈ tr or Γ(n) ∈ tr or Δ(n) ∈ tr, where tr ∈ Δ(m) and
∈ ts or Γ(m) ∈ ts or Δ(m) ∈ ts, where ts ∈ Δ(n)
(Effects) If it holds that tm ± Δ(n) where tm ∈ Δ(m).
Note that the conditions on senders and receivers reflect the usual notions of co/contravariance found in e.g. [6].
Definition 3.10 Let p be a process and Δ, Γ be environments such that wf(p, Δ, Γ). We say that p is well-typed under Δ, Γ iff ∃A, e : Δ, Γ ▶ p ⇒ A & e.
Properties of the type system
The two central properties of our type system are that typability is preserved along reductions and that well-typed processes are well-behaved.
Theorem 3.11 (Subject reduction) For any well-typed process Δ, Γ ▶ p ⇒ A & e it holds that if p −→ p' then Δ, Γ ▶ p' ⇒ A' & e' is also well-typed and A' ⊆ A and e' ⊆ e.

Definition 3.12 The effect extraction function effects(Γ, p) is defined by effects(Γ, 0)= ∅
effects(Γ, γα.p) = effects(Γ, p)

effects(Γ,δ D δ'.p) = effects(Γ, p) ∪ {Γ(n) D Γ(n')}
where δ = γ1n and δ' = γ2n'
effects(Γ,q n.p) = effects(Γ, p)
effects(Γ, p1  p2) = effects(Γ, p1) ∪ effects(Γ, p2) effects(Γ, !p) = effects(Γ, p)
effects(Γ, (n : s, b)p) = effects(Γ, p) effects(Γ, n˜ [·♩m)= ∅
effects(Γ, n˜ [p♩m) = effects(Γ, p)
We call a process safe in (Γ, Δ) if every visible subslot is allowed by the guesthood relation (Definition 3.6) and all effects are allowed by the effect relation (Definition 3.7).
Let subp(n, p) denote the set of subprocesses of process p that are either slots named by n or subprocesses under such slots.
Definition 3.13 Given security environment Δ and group environment Γ, process
p is safe if for all free slot names n in p we have that
∀n˜ p'	∈ subp(n, p): sn(p') \ bn(p') ±Δ,Γ Δ(n) ∧ effects(p') ± Δ(n)
The following lemma states that the typing rules always extract the correct information about visible slots and potential moves.
Lemma 3.14 For any process p it holds that if Δ, Γ ▶ p ⇒ A & e then A = sn(p) \ bn(p) and e = effects(p).
Theorem 3.15 (Safety) Any well-typed process Δ, Γ ▶ p ⇒ A & e is safe.
Corollary 3.16 If p is well-typed under Δ, Γ and p →∗ p', then p' is safe.
Safe processes need not be well-typed. A simple counterexample is the pro- cess a [0♩  b [·♩  a D b.0 with typings Γ = {a '→ a', b '→ b'} and Δ = {a '→ Sec[tr[]ts[]tg[ ]tm[]], b '→ Sec[tr[]ts[]tg[]tm[]]}. This process is safe with re- spect to Γ and Δ but not typable, as b does not trust any senders – in particular,
a is not trusted. Thus the move a D b is not well-typed.
Example 2 Consider the processes
FireKit = Matchbox [Match [·♩♩  Acetone [·♩
MakeAFire = FireKit  MatchBox D Acetone.0
Camp = FireSite [MakeAFire♩
GoToLibrary = Camp  Library [·♩  FireSite D Library	 People [·♩

with group environment Γ = {Matchbox '→ b, Match '→ m, Acetone '→ a,
FireSite '→ f, Library '→ l, People '→ p} and security policy environment

Δ = { MatchBox '→ Sec[tr[ ] ts[b] tg[m] tm[ ]]
Match	'→ Sec[tr[ ] ts[] tg[] tm[ ]]
Acetone '→ Sec[tr[ ] ts[b] tg[m] tm[ ]]
FireSite '→ Sec[tr[l] ts[ ] tg[b, m, a] tm[b D a]]
Library '→ Sec[tr[p, l] ts[p, l] tg[p] tm[ ]]
People	'→ Sec[tr[ ] ts[] tg[] tm[ ]]
}

The process Camp is well-typed as fire starting is an allowed activity at the firesite. This activity cannot be moved to the library, since the library does not permit matches and acetone as guests. Thus the move FireSite D Library is not well- typed by the side conditions of T-Move.

Minimal security policy environments
We now consider the problem of finding a minimal security policy environment for a given process p, with a given group environment Γ. The idea is to construct the minimal security policy environment Δ∗ from p that makes p typable with respect to Δ∗ and Γ.
We make some simplifying assumptions on processes. For any process p we shall
assume that it has been alpha-converted to a form where fn(p) ∩ bn(p)= ∅ and all bound names are distinct.
Security policies occurring in restrictions are transformed as follows:
We replace stars  occurring in tr, ts and tg by ran(Γ), the range of Γ.
We replace all  D w with w1 D w,... , wk D w where {w1,... , wk} = ran(Γ) and
w ∈ ran(Γ). All occurrences of w D are replaced with w Dw1,... ,w Dwk. Finally
 D  is replaced with {w D w' | w, w' ∈ ran(Γ)}.
The above transform can be applied to the set S. Call the resulting set S\٨. We can then define an ordering on security policies in S\٨ as follows:
Definition 4.1 Let Σ, Σ' ∈ S\٨.

Σ ⊆ Σ' iff
tr ⊆ tr' ∧ ts ⊆ ts' ∧ tg ⊆ tg' ∧ tm ⊆ tm'
where tr, ts, tg, tm ∈ Σ and tr', ts', tg', tm' ∈ Σ'

Definition 4.2 Define the order ≤ on  Δ | Δ: N → S\٨} by
Δ ≤ Δ' iff ∀n ∈ dom(Δ) : Δ(n) ⊆ Δ'(n).
and dom(Δ) = dom(Δ').
Lemma 4.3 ( Δ | Δ: N → S\٨} , ≤) is a complete lattice.
We now show how to extract a set of constaints from a process. In our presenta- tion, ⟨A | B⟩ denotes a tuple consisting of sets A and B and ⊕ denotes component- wise union of such tuples.
The algorithm presented in Table 4 extracts a pair of constraint sets ⟨C1|C2⟩ from a given process p under a given group environment Γ. Here C1 contains constraints on the form D ⊆ (n, t) where D is a set of types, and n is a name and t ∈ {tr, ts, tg, tm}. For example, a constraint D ⊆ (n, tg) states that the set of types D is a subset of trusted guests in the security policy of n. The set C2 contains constraints on the form (m, t) ⊆ (n, t), t ∈ {tg, tm}. As an example (m, tm) ⊆ (n, tm) states that the trusted moves of m should also be trusted as valid moves by n.
Define N as sn(p) and let l be the number of free names in N . Given a pair of constraint sets ⟨C1|C2⟩ we can now compute a minimal security policy environment for p by finding the fixpoint of the composition of the two functions f1, f2 : P(N )l × P(N )l → P(N )l × P(N )l.
The function f1 finds the minimal requirements of a security policy as defined by the constraints C1:

f1(xG, xM )= (yG, yM )
where the components of yG and yM are given by yi

= xi


∪  (D⊆(i,tg))∈C1

D and

i  = xi
∪  (D⊆(i,tm))∈C1 D

The function f2 finds the requirements as defined by the constraints C2:
f2(xG, xM )= (yG, yM )

where yi
= xi ∪ 
xm and yi
= xi  ∪	xm

The function h = f2 ◦ f1 is clearly monotone since f1 and f2 are. By Tarski’s theorem, h has a least fixpoint which we call x∗. This is also the least prefixpoint under pointwise set inclusion, so x∗ is exactly a solution of the constraints in C1 and C2. x∗ can be computed iteratively using Tarski’s theorem as ran(h) is finite and as the set of group names is finite. The security policy environment can be found from x∗ as

where
Δ= [n '→ Σn]n∈N

Σn = Sec[tr[	  D] ts[	  D] tg[πnπ1x∗] tm[πnπ2x∗]]

(D⊆(n,tr))∈C1	(D⊆(n,ts))∈C1

function χ(p, Γ) =
case p of
0	: ⟨∅ | ∅⟩
γα.p	: χ(p, Γ)
m1 ... mkD
n1 ... nl.p :  {{Γ(nl)}⊆ (mk, tr),
{Γ(mk)}⊆ (nl, ts)}
{{(mk, tg) ⊆ (nl, tg), (mk, tm) ⊆ (nl, tm)}} ∪
{(mi, tg) ⊆ (mi−1, tg), (mi, tm) ⊆ (mi−1, tm)}1<i≤k ∪
{(ni, tg) ⊆ (ni−1, tg), (ni, tm) ⊆ (ni−1, tm)}1<i≤l 
χ(p, Γ)
q n.p	: χ(p, Γ)
p1  p2	: χ(p1, Γ) ⊕ χ(p2, Γ)
!p	: χ(p, Γ)
(n : s, b)(p) : ⟨{π1s ⊆ (n, tr), π2s ⊆ (n, ts),
π3s ⊆ (n, tg), π4s ⊆ (n, tm)} | ∅⟩ ⊕
χ(p, Γ[n '→ b])
n˜ [·♩	: ⟨∅ | ∅⟩
n˜ [p♩	: ⟨{Γ(sn(P )) ⊆ (n, tg), effects(p) ⊆ (n, tm)}n∈n˜ | ∅⟩ ⊕ 
χ(p, Γ)
end
end
Table 4
χ extracts constraints from a process for a given group environment Γ.

Definition 4.4 We write (p, Γ) ~ Δ if Δ is found as above from p and Γ.
Due to the presence of restriction, one may specify processes which do not have a minimal security policy environment. As an example consider
(a : s, a')(b : s, b')(a [0♩ b [·♩  a D b.0)
where s is Sec[tr[] ts[] tg[] tm[]]. Since the slots a and b do not trust each
another, the move operation is impossible – i.e. untypable. When this process is processed by the algorithm in Table 4 we among other constraints get the constraints

{{b'} ⊆ (a, tr), {a'} ⊆ (b, ts)}. The solution to this system will contain security policies for a and b which have been enlarged so that a and b now trust each other. The security policies have changed compared to their original security policy s. This problem gives rise to the following definition.
Definition 4.5 A process p with group environment Γ is inconsistent if it contains a subprocess (n : s, b)p' for which Δ(n) /= s, where (p, Γ) ~ Δ.
Definition 4.6 Given (p, Γ) ~ Δ and assume that p is not inconsistent. Then the minimal security policy environment Δ∗ for p and Γ is defined as
def
= Δ|sn(P )\bn(P ).
Theorem 4.7 Let Δ∗ be the minimal security policy environment for the consistent process p with respect to the group environment Γ. It holds that
Δ∗, Γ ▶ p ⇒ A & e for some A and e.
∄Δ' : Δ' < Δ∗ ∧ Δ', Γ ▶ p ⇒ A & e for some A and e.
Conclusions and future work
In this paper we have described a type system for the Calculus of Mobile Resources [3]. The type system allows us to reason about border-crossing phenomena, some- thing that is less straightforward in the setting of the MR calculus. Our type system preserves a safety property. To our knowledge, this is the first such type system proposed for the calculus. With our notion of security policy it becomes straight- forward to describe not just border-crossing properties but also properties such as immobility (contrast this with e.g. [5]).
We also describe an algorithm for finding the minimal security policy for a processes. A complexity analysis of our algorithm is a topic for further work.
One may imagine stronger type systems. In Definition 3.9 we require that the security policy regarding guests and effects for the receiving slot should be as least as general as that of the sending slot. Consider a [b [P ♩♩  c [·♩  d.a D c.0. Here there is no co-action d, so the move a D c never occurs. When this process is typed, the slot c must allow the same guests and effects as a. This gives a generality of the security policy for c which is unnecessary. It would be desirable to be able to type processes with respect to how they change configurations dynamically. This would in turn require a completely different type system in which issues concerning causality would become central.

References
Luca Cardelli, Giorgio Ghelli, and Andrew D. Gordon. Ambient groups and mobility types. In
Proceedings of TCS 2000 (Sendai, Japan), LNCS 1872, pp. 333–347, August 2000.
Luca Cardelli and Andrew D. Gordon. Mobile ambients. In Foundations of Software Science and Computation Structures: First International Conference, FOSSACS ’98. Springer-Verlag, Berlin Germany, 1998.


J. Godskesen, T. Hildebrandt, and V. Sassone. A calculus of mobile resources. Proceedings of CONCUR’02, LNCS 2421, pp. 272-287., 1644:p.230, 2002.
John M. Lucassen and David K. Gifford. Polymorphic effect systems. In POPL, pages 47–57, 1988.
M. Merro and V. Sassone. Typing and subtyping mobility in boxed ambients. CONCUR’02, LNCS 2421:304–320, 2002.
B. Pierce and D. Sangiorgi. Typing and Subtyping for Mobile Processes Mathematical Structures in Computer Science, vol. 6, pp. 409–454, 1996.
J. Stefani. A calculus of kells. In 2nd Workshop on Foundations of Global Computing. To appear, 2003.
Jan Vitek and Giuseppe Castagna. Seal: A framework for secure mobile computations. Lecture Notes in Computer Science, 1686, 1999.
