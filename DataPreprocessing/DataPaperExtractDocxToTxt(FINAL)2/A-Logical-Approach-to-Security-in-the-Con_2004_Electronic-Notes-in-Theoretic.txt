	Electronic Notes in Theoretical Computer Science 99 (2004) 3–29	
www.elsevier.com/locate/entcs




A Logical Approach to Security in the Context of Ambient Calculus
Radu Mardare1	and Corrado Priami2
Dipartimento di Informatica e Telecomunicazioni University of Trento, Italy

Abstract
2
In this paper  we advocate the use of a CTL* logic, built upon Ambient Calculus to analyze
security properties. Our logic is a more expressive alternative to Ambient Logic, based on a single modality, but still powerful enough to handle mobility and dynamic hierarchies of locations. Moreover, having a temporal logic to express properties of computation, we can reuse the algorithms for model checking temporal logics in analyzing models for security problems.
We resort to syntax trees of Ambient Calculus and enrich them with some labeling functions in order to obtain what we called labeled syntax trees. The labeled syntax trees will be used as possible worlds in a Kripke structure developed for a propositional branching temporal logic. The accessibility relation is generated by the reduction of Ambient Calculus considered as reduction between syntax trees.
Providing the algorithms for calculating the accessibility relation between states, we open the per- spective of model checking Ambient Calculus by using our algorithms together with the algorithms for model checking temporal logic.
b Work partially supported by the IST-FET project DEGAS and the MIUR-COFIN01 project MEFISTO.
Keywords: ambient calculus, temporal logic, set theory, model checking.


Introduction
Ambient Calculus [5] is a useful tool to construct mathematical models for security problems because of its facilities in expressing hierarchies of locations and their mobility. Strongly based on Ambient Calculus was constructed the

1 Email: mardare@dit.unitn.it
2 Email: priami@dit.unitn.it


1571-0661 © 2004 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2004.02.001

Ambient Logic [4,3], a logic that can describe properties of mobile computa- tions as well as the hierarchy of locations and modifications of this hierarchy in time.
The main idea of Ambient Logic is treating processes as spatio-temporal entities, thus were used two types of modalities - one for assertions about space and the other for assertions about time. We will prove here that a sin- gle modality suffices for describing the behavior of these entyties. The main intuition is that we only need to calculate the modification that each move- ment of the system is making over the initial state, because this information suffices to reconstruct the actual shape of the system using only a propositional branching temporal logic based on Ambient Calculus.
The advantage of using a temporal logic is relevant in security problems. Consider the model of the interaction between a firewall that keeps its name completely secret and an agent that intends to cross the firewall by means of previously arranged passwords k, k', k'' [5].

def
F irewall
νn)n[k[out n.in k'.in n.0]|open k'.open k''.P ]

= ( 
Agent def k'[open k.k''[Q]]
Agent|F irewall ≡
(νn)(k'[open k.k''[Q]]|n[k[out n.in k'.in n.0]|open k'.open k''.P ])
→∗ (νn)(k'[open k.k''[Q]]|k[in k'.in n.0]|n[open k'.open k''.P ])
→∗ (νn)(k'[open k.k''[Q]|k[in n.0]]|n[open k'.open k''.P ])
→∗ (νn)(k'[k''[Q]|in n.0]|n[open k'.open k''.P ])
→∗ (νn)(n[k'[k''[Q]]|open k'.open k''.P ])
→∗ (νn)(n[k''[Q]|open k''.P ])
→∗ (νn)n[Q|P ]
This computation describes correctly the desired interaction. Our veri- fication was possible because the formula was not too big, the computation was made in a few steps, and only one path of reductions was possible. In a more complex situation, in which the computational path have branches, i.e. there are moments when more then one reduction is possible, each possibility meaning different possible futures, when are involved also other agents that may know, entirely or partially, the passwords, we want to check wether this situation is always reachable, or if not, which is the configuration of the system in the excepted case.
We cannot obtain an answer to these problems inside Ambient Calculus. Only a logic able to predict about computations could give us an answer. Ambient Logic could express the possibility that a spatial configuration A of

the system will appear in one of the possible futures, by the formula ⬦A 3 , but it cannot say if this moment is the next one, or a moment very far in future, as it cannot say if this future is to be found in any possible temporal path. In our example we are interested to express that, for all possible future paths, sometime in the future, we will have the interaction between the processes P and Q. This is not possible using Ambient Logic. We can only say that, sometime in the future, this communication is, indeed, possible, but this does not exclude the possibility of existing a temporal path in which this interaction is not possible at all. It could also be important in other situations to know if a property is true in the next moment, or, as in the situation when we want a communication not to be possible until a password is recognized, that a property is false until another one becomes true. All these properties are expressible using a temporal logic.
Another argument for using temporal logics to model Ambient Calculus is the possibility of having model checking for our calculus reusing some software already developed for these logics such as SMV, NuSMV, SiMpLer, VIS.

Further we will enrich the syntax trees of the ambient processes with a decoration function that helps us interpreting them as states in a temporal logic. The action of the decoration function will group the nodes of the syntax tree by their nature and will associate with each one some identities that will depict the hierarchical structure of the ambient process.

Labeled syntax trees
In this section we define the labeled syntax trees for the ambient calculus processes starting from the syntax trees. This notion is crucial for the further construction, because some abstractions of the labeled syntax trees will be the states in the logic we are going to construct.
We first only consider processes without the new name operator (handled in the next section).
A syntax tree S = (S, →S) for a process is a graph with S = P ∪ C ∪ O = (PP ∪ PA) ∪ C ∪ O where
P is a set that contain all the unspecified process nodes (hereafter atomical processes 4 and collected in the subset PP ) and the ambient nodes (collected

3 ⬦ is used for temporal possibility
4 We use these to denote unspecified processes found inside an ambient process; this is a necessary requirement in developing model checking for Ambient Calculus because we have to recognize and distinguish, over time, unspecified processes inside the target process. For instance P is an unspecified process in n[in m.P ]

in the subset PA);
C is the set of capability nodes (we include here the input nodes and the nodes of variables over capabilities as well); and
O is the set of syntactical operator nodes (this set contains the parallel op- erators | and the prefix operators, •). We identify the subset O' = {•1 ∈ O | •1 →S | } ⊆ O of the prefix nodes that are immediately followed in the syntax tree by the parallel operator because they play an important role in the spatial structure of the ambient process 5 .
The intuition behind the construction of a labeled syntax tree is to asso- ciate to each node of the syntax tree some labeles by two functions: id that gives to each node an identity, and sp that registers the spatial position of the node.
The identity function id associates a label (urelement or ∅):
to each unspecified process and to each ambient; this label will identify the node and will help us further to distinguish between processes that have the same name
to each capability, the identity of the process in front of which this capa- bility is placed
∅, to each syntactical node
The spatial function sp associates:
to each ambient the set of the identities of its children 6 , while to unspec- ified processes associates the id-label.
to each capability, a natural number that counts the position of this ca- pability in the chain of capabilities (if any) belonging to the same process
to each syntactical node the spatial function associates 0, except for the nodes in O' to which the function sp will associate the set of identities of the processes connected by the main parallel operator in the compound process that this point is prefixing. For example in the situation c.(P |Q), sp(•)= {id(P ), id(Q)}.
We recall here some basic definitions of Set Theory and Graph Theory that are needed to formally define the functions id and sp above.
We choose to work inside Zermelo-Fraenkel system of Set Theory ZFC with

5 These point operators are those that connect a capability with a process formed by a parallel composition of other processes bounded together by brackets, hereafter complex processes, as in c.(P |Q)
6 We use the terms parent and child about processes, meaning the immediate parent and immediate child in Ambient Calculus processes.

the Foundation Axiom (FA), as being a fertile field that offers many tools for analyzing structures, as argued in [2]. This approach allows us to describe the spatial structure of ambient processes as equations in set theory, each such equation being then used as atomical proposition in our logic. In this way we will not use a modality in describing the hierarchy of locations, but only in describing the evolution of the hierarchy in time. Hereafter, we assume a class V of urelements, set-theoretical entities which are not sets (they do not have elements) but can be elements of sets. The urelements together with the empty set ∅ will generate all the sets we will work with (sometimes sets of sets).
Definition 2.1 A set a is transitive if all the elements of a set b, which is an element of a, also belong to a: ∀b ∈ a if c ∈ b then c ∈ a.
The transitive closure of a, denoted by TC(a) is the smallest transitive set including a. The existence of TC(a) could be justiﬁed as follows:
TC(a)= ∪{a, ∪a, ∪∪ a, ...}
Definition 2.2 The support of a set a, denoted by supp(a) is TC(a) ∩ V. The elements of supp(a) are the urelements that are somehow involved in a.
def
Definition 2.3 If a ⊆  then V (a) = {b | b is a set and supp(b) ⊆ a}. V (a)
is the class of all sets in which the only urelements that are somehow involved are the urelements of a.
Definition 2.4 Let SP = (S, →S) be the syntax tree associated with the am- bient process P. We call the structure graph associated with P, the graph obtained by restricting the edge relation of the syntax tree to P ∪ O', i.e. the graph TP = (P ∪ O', →T ) deﬁned by:
for n, m ∈ P ∪ O' we have n →T m iff n →∗ m and ∄p ∈ P ∪ O' such that
n →∗ p →∗ m
S	S
Intuitively, the structure graph of a process is obtained by restricting the edge relation of its syntax tree to P.
Definition 2.5 A decoration of a graph G = (G, →G) is an injective function
e : G → V (V) ∪ V such that for all a ∈ G we have:
if ∄b ∈ G such that a →G b then e(a) ∈ V
if ∃b ∈ G such that a →G b then e(a)= {e(b)| for all b such that a →G b}.
We now introduce a set of auxiliary functions that are the building blocks for id and sp (for the application of these and the following definitions see the Appendix).
Definition 2.6 Let the next functions be deﬁned on the subsets of nodes of the syntax tree (S, →) as follows:

Let spP : P∪O' → V (V)∪V be a decoration of the structure graph associated with our syntax tree.
Let idP : P → V be an injective function such that idP(P )= spP(P ) for all

P ∈ PP . Consider UP
def
= idP(PP ) ⊂	, UA
def
= idP(PA) ⊂

Let spO : O → V ∪ V (V) ∪ N deﬁned by
 spP(s) iff s ∈ O'

spO(s)= 
 0	iff s ∈ O \ O'



def
Consider O = sp
O(O') ⊂ V (V)

Let idO : O → V (V) ∪ V deﬁned by
idO(s)= ∅
Let spC : C → N such that
sp (c)=  1	iff | → • → c or n → • → c with n ∈ P
 k +1 iff •1 → •2 → c and •1 → c' ∈ C with spC(c')= k
Let idC : C → V (V) ∪ V deﬁned for c ∈ C such that •c → c by

idC(c)=  idC(c') iff •c → •' with •' → c'
 spO(•c) iff •c ∈ O'
Summarizing we can define the identity function id : P∪C∪O → V∪V (V) and the spatial function sp : P ∪ C ∪ O → V ∪ V (V) ∪ N by:


id(s)=  idC(s) iff s ∈ C
 idO(s) iff s ∈ O
 spP(s) iff s ∈ P
sp(s)=	spC(s) iff s ∈ C
 spO(s) iff s ∈ O

Observe that while the range of id is V ∪ V (V), the range of sp is V ∪ V (V)∪N (we consider here natural numbers as cardinals 7 so that no structure anomaly emerges as long as N ⊂ V ∪ V (V)). Hereafter, for the sake of the presentation, we will still consider natural numbers and not cardinals.

7 Informally, we treat 0 as ∅,1 as {∅},2 as {∅, {∅}},3 as {∅, {∅}, {∅, {∅}}} and so on.

We identify the sets UA of urelements chosen for ambients, UP of urelements chosen for atomical processes, and the set of sets of urelements O that contain all the addresses of the elements in O'.
We now define labeled syntax tree for a given syntax tree of an ambient process.
Definition 2.7 Let SP = (S, →) be the syntax tree of the ambient process P. We call the labeled syntax tree of it the triplet SlP = (S, →, φ) where φ is the function deﬁned on the nodes of the syntax tree by
φ(s)= ⟨id(s), sp(s)⟩ for all s ∈ S.
Remark 2.8 It is obvious the central position of the function id in the previ- ous deﬁnitions. For a particular ambient process, once we deﬁned the function id, all the construction, up to the labeled syntax tree, can be done inductively on the structure of the ambient process. Because of this, our construction of the labeled syntax tree is unique up to the choice of urelements (i.e. of UP and UA).
Definition 2.9 For a given labeled syntax tree Sl = (S, →, φ) we deﬁne the functions:
ur : P ∪ O' → UP ∪ UA ∪ O by:
ur(s)=  id(s) if s ∈ P
 sp(s) if s ∈ O'
This function associates to each node of the structure graph the set-theoretical identity deﬁned by the labeled syntax tree
Let e : UP ∪ UA ∪ O → V ∪ V (V) be the function deﬁned by
e(ν)= sp(ur−1(ν))
It associates to each ambient and compound process the set of addresses of its children.
f : UP ∪ UA ∪ O → Λ ∪ Π, where Λ is the set of names of ambients of Ambient Calculus, and Π is the set of atomical processes. For each ν ∈ UP ∪ UA ⊂ V, f (ν) is the name of the process with which ν is associated by id 8 , and f (ν) = ⟨0, 0⟩ if ν ∈ O. By the function f each urelement (or set of urelements) used as identity will receive the name of the ambient or

8 informally we could say that, on UA ∪ UP , we have f = id−1, but this is not exact for the reason that id is an injective function while f is not. Because if we have two processes named P , then, for both, the value by f will be P , but, by id−1, they point to different nodes in the syntax tree.

atomical process that it is pointing to (the sets receive the name ⟨0, 0⟩).
F : UP ∪ UA ∪ O → C∗ for each ν ∈ UP ∪ UA ∪ O, F (ν)= ⟨c1, c2, ...ck⟩ where ci ∈ C such that ∀i ∈ N, id(ci) = ν, sp(ci) = i and ∄ck+1 ∈ C such that id(ck+1)= ν and sp(ck+1)= k +1. In the case that, for ν we cannot ﬁnd any such ci, we deﬁne F (ν) = ⟨ε, ε, ...⟩, ε being the null capability. We adopt the following enrichment of the relation of equality on capability chains =C deﬁned by the next rules 9 :
· ⟨c1, c2, c3, ...cn⟩− ⟨c1⟩ =C ⟨c2, c3, ...cn⟩
· ⟨ε, c1, ..., ck⟩ =C ⟨c1, c2, ..., ck, ε⟩ =C ⟨c1, ..., ct, ε, ct+1, ...ck⟩ =C ⟨c1, c2, ..., ck⟩,
· ⟨ε, ε, ...ε⟩ =C ∅.
The function F associates with each of these the list of capabilities that exists in front of the process they point to.
Definition 2.10 Let S = (S, →, φ) be a labeled syntax tree of the ambient process P. We will call the canonical labeled syntax tree associated with P, denoted by S+ = (S+, →+, φ+), the restriction of the labeled syntax tree to the set S+ = {n| n ∈ S, f (n) /= 0 and F (n) /= ⟨ε, ...ε⟩}, where 0 is the null process and ε is the null capability.
Further we will discuss only about canonical labeled trees (by extension canonical processes), these being those who evolves during the ambient calcu- lus computations, so are those who really matters for our purpose.

Handling the binding operators
Consider the interaction between the firewall and the agent in parallel with other two processes n[R] and open n.t[S]:
k'[open k.k''[Q]]|(νn)n[k[out n.in k'.in n.0]|open k'.open k''.P ]|n[R]|open n.t[S]
Here, (νn) means that the name n inside the scope of (νn) is different of all the other names in the program. In the example, we want to be sure that out n and in n, which are capabilities prefixing the process 0, will never act over n[R] but only over the ambient that was chosen to name the firewall. Vice versa, open n, the capability of t, will never act over the firewall ambient, but only over n[R].
The intuition is that the name of the ambient chosen to name the firewall should be one unused before. A possible solution could be just to choose a new name r ∈ Λ and to replace n with it in all its occurrences inside the scope of (νn). This solution is, locally, good, but it will not prevent the name r

9 these rules are allowed by the syntax of Ambient Calculus together with the rules of structural congruence over processes

to be ever used in other processes that we could combine with ours, so that a name conflict would arise. In other words the renaming solution is not a compositional one. We guarantee compositionality by a trick that resembles de Bruijn indexes for name-free λ-calculus: we accept ordered pairs of natural numbers as possible names of ambients and we use them to completely remove any (νn) occurrence from processes. So, we replace the kth new name (νn) in a process with the pair ⟨k, 1⟩ 10 . This approach allows us to combine our process with others for which we already constructed the labeled syntax trees. In this way all the names in the second process will receive names as ⟨k, 2⟩ meaning that is the kth new name of the second process, and so on, the kth new name of the lth process will receive the name ⟨k, l⟩.
This construction is supported by the assumption that inside of an ambient process can only occur a finite number of new name operators and that we will combine only a finite number of processes.
According with the above, our example becomes:
k'[open k.k''[Q]]|⟨1, 1⟩[k[out ⟨1, 1⟩.in k'.in ⟨1, 1⟩.0]|open k'.open k''.P ]
|n[R]|open n.t[S]
The analysis of the reductions of our process as in the introduction, shows that the expected result is still possible without using the new name operator. Indeed:
F irewall def ⟨1, 1⟩[k[out ⟨1, 1⟩.in k'.in ⟨1, 1⟩.0]|open k'.open k''.P ]
Agent def k'[open k.k''[Q]]
Agent|F irewall|n[R]|open n.t[S] ≡
k'[open k.k''[Q]]|⟨1, 1⟩[k[out ⟨1, 1⟩.in k'.in ⟨1, 1⟩.0]|open k'.open k''.P ]|n[R]|open n.t[S]
→∗ k'[open k.k''[Q]|k[in ⟨1, 1⟩.0]]|⟨1, 1⟩[open k'.open k''.P ]|n[R]|open n.t[S]
→∗ k'[k''[Q]|in ⟨1, 1⟩.0]|⟨1, 1⟩[open k'.open k''.P ]|n[R]|open n.t[S]
→∗ ⟨1, 1⟩[k'[k''[Q]]|open k'.open k''.P ]|n[R]|open n.t[S]
→∗ ⟨1, 1⟩[Q|P ]|n[R]|open n.t[S]
→∗ ⟨1, 1⟩[Q|P ]|R|t[S]
We handle ⟨l, k⟩ as any other ambient name, whenever it appears in our processes. This means that the set Λ contains, as a subset, a subset of N ×
N. This modification does not affect the four rules of structural congruence ((Struct Res Res), (Struct Res Par), (Struct Res Amb) and (Struct Zero Res), see [5]). Only it modifies the intentional interpretation of (νn). It will not mean this name is new inside the scope of our quantiﬁer, but replace this name in all its occurrences inside the scope of our quantiﬁer by an unused pair of

10 we will replace in the ambient calculus process, all the occurrences of n inside the scope of (νn), being ambients or capabilities, with ⟨k, 1⟩

natural numbers.
In this way we reduce all the syntax trees of ambient calculus to syntax trees without new name operators.

Compositional analysis of Labeled Syntax Trees
In this section we define an Algebra of labeled syntax trees extending the compositional operations of Ambient Calculus from syntax trees to the labeled syntax trees. This mean that, starting from the labeled syntax tree of P1 and P2 we will define those for P1|P2, c1.c2...cn.m[P ] or !P .
Such a construction can be reduced to the construction of the function id
for each case 11 .
Parallel composition
Assume that (S1, →1, φ1) and (S2, →2, φ2) are the labeled syntax trees for the processes P1 respective P2. According to the Remark2.8, we can suppose that the sets of urelements chosen for the two labeled trees are disjunct (if this is not the case, we can choose other urelements for P1, because the labeled tree is unique up to the choice of the urelements). We can construct the syntax tree for P1|P2 using the rules of Ambient Calculus. All we have to do further is to define the function φ for the new syntax tree.
Suppose that α1, α2 ∈ V are the identities of the master ambients in the two cases (i.e. (S1, →1, φ1) is the tree for u1[P1] and (S2, →2, φ2) is the tree for u2[P2]). Consider α ∈ V a new urelement (unused in the two labeled trees). Now we define the function id for u[P1|P2] by:
id(u)= α,
id(n)= id1(n) for each n ∈ P1 \ {α1}, id is not defined in α1, id(n)= id2(n) for each n ∈ P2 \ {α2}, id is not defined in α2
Of course, from the way of composing two processes by parallel operator, we have eα = eα1 ∪ eα2 .
Ambient composition
Assume that the labeled syntax tree for P1 is (S1, →1, φ1). We want to con- struct the labeled syntax tree (S, →, φ) for c1.c2...ck.m[P1]. Consider that the labeled syntax tree of P1 has u1 as its master ambient the ambient with the identity α1. Let α, β ∈ V be two urelements unused in the labeled syntax tree of P1. Let u be the master ambient of c1.c2...ck.m[P1]. We can define, in the

11 see the Remark2.8

standard way, the syntax tree of u[c1.c2...ck.m[P1]] using the rules of Ambient Calculus. Further we define id for it by:
id(u)= α, id(m)= β,
id(n)= id1(n) for all n ∈ P1 \ {u}, id is not defined in u
Of course, from the way ambient composition is defined, we have eα = {eβ}, and eβ = eu.

Algebra of labeled trees
If we call by LST the class of all labeled syntax tree (with respect to the identity up to the choice of urelements), the two operations defined before could be introduced as:
 : LST × LST → LST for the parallel composition, and
c1.c2...ck.m@: LST → LST for the ambient composition
If (S1, →1, φ1) and (S2, →2, φ2) are the labeled syntax trees for the processes P1 respective P2 then the labeled syntax tree for P1|P2 constructed before is (S1, →1, φ1)  (S2, →2, φ2) and c1.c2...ck.m@(S1, →1, φ1) is the one constructed before for c1.c2...ck.m[P1].
These organize an interesting algebraic structure over LST.

The Replication
Assume that the labeled syntax tree for P is (SP , →P , φP ). Then the one for P |P will be (SP , →P , φP )  (SP , →P , φP ). Reconsidering the way of construct- ing the parallel composition of labeled trees we observe that for constructing (SP , →P , φP )  (SP , →P , φP ) we have to choose a duplicate of (SP , →P , φP ) that have the set of urelements disjunct of the initial one. Moreover, for each α1 ∈ V used as identity for n ∈ P in (SP , →P , φP ) we have to choose an α2 ∈ V used as identity for the same ambient or atomical process n ∈ P, but in the duplicated (SP , →P , φP ).

We can define (S
, → ,φ )  (S
, → ,φ 
def
S , →
,φ ) 2

P	P	P	P
P	P ) = ( P	P	P

In the same way we can define (SP , →P , φP )  k for all k ∈ N. Generally speaking, this construction is supposing to choose for each ambient or atomical process found, not an urelement as identity, but a finite chain of k urelements. For each i ∈ 1, 2, ...k, the ith elements of each chain satisfying the requirements of the identity labels for the elements of P. I.e., if {α, β, γ, ...ζ} are the urelements chosen for (SP , →P , φP ), then we will have the chains:
for α: α1, α2, ..., αk, for β: β1, β2, ..., βk, for γ: γ1, γ2, ..., γk .. for ζ: ζ1, ζ2, ..., ζk. And for each i ∈ 1, 2, ...k the urelements {αi, βi, γi, ...ζi} are identities for our

ambients and atomical processes of P .
In the same way we can choose a denumerable chain of urelements for each node of the process graph of P . We denote the labeled syntax tree constructed in this way by (SP , →P , φP )  ∞. More concrete, if the master ambient of (SP , →P , φP ) is α, and if we consider that α' ∈ V is the master

ambient of (S
, → ,φ ) ∞ then e∞ def ∪{e
| i ∈ 1, 2, ...k} and e∞ def ej ,

P	P	P
α'  =	αi
νj  =	νj

where νj ∈ {βj, γj, ...ζj}, e∞ being the function e of (SP , →P , φP ) ∞ and ej
the one for the labeled tree j.
As a consequence of the previous construction we can state that the labeled tree (SP , →P , φP ) ∞ is the labeled syntax tree of !P .

The Logic
The main goal of this paper is to construct a temporal logic strongly based on Ambient Calculus and able to describe properties of mobile computations as well as the hierarchy of locations and their modifications over time.
The logic we intend to construct is a branching propositional temporal logic, CTL∗ 12 . The requirements of such a construction [6] are to organize a structure M = (S0, S, R, L) where S0 is the initial state of our model, S is the class of all possible states in our model, R is the accessibility relation between states, R ⊆ S × S, and L : S −→ P(AP) is a function which associates to each state S ∈ S a set of atomical propositions L(S) ⊆ P(AP) - the set of the atomical propositions true in the state S (AP will be the class of atomical propositions).
We developed the labeled syntax trees to use them as states in our logic. The choice of the initial state depends on the purpose of our analysis. If we are interested in the future of an ambient calculus process P by himself, then the labeled syntax tree of P will be the initial state. But if P will interact with another process Q, or will become child of an ambient, or both like in m[P |Q], then, even if we have a particular interest in P, the initial state will be the labeled syntax tree of m[P |Q] (we can use, for defining this, the computation operations developed for labeled trees, i.e.  and m@).
The intuition in constructing S for a given initial state S0 = (S0, →0, φ0) (consisting in a labeled syntax tree of a given process P ) is to be done in such a way that to contain all the syntax trees of all processes that have the same ambients and atomical processes as P , with the same identities, but in possible different spatial structure 13 . Between these states we will eliminate

12 we choose CT L∗ because is more expressive then CTL, but a CTL is possible as well
13 we include here also the situations where some ambients were dissolved by consuming,



those Si for which O'
¢ O'
for the reason that such a spatial configuration

is not possible for a state obtained from S0 14 . These motivate the following definition:
Definition 5.1 Assume that S0 = (S0, →0, φ0) is our initial state. Then
def
S
= {(Si, →i, φi)| Pi ⊆ P0, Oi ⊆ O0, and for all n ∈ Pi, idi(n)= id0(n)}.
In conclusion we can consider, by extension, that all these processes have

U 0 = Ui , U 0 = Ui
and O0 = Oi. For this reason we discuss further about

A	A	P	P
UP , UA and O without other indexes.
Definition 5.2 We deﬁne the set of atomical propositions as:
AP = {xiny|x ∈ UP ∪ UA ∪ O and y ∈ UA ∪ O}.
In our logic xiny will be just an atomical proposition and x, y just letters. The cardinality of AP will be card(UP ∪UA ∪O)×card(UA ∪O) which depends (polynomial) on the number of atomical processes and ambients in the ambient calculus process S0.
Definition 5.3 We deﬁne the interpretation function L : S → P(AP) by:

L(S)= {xiny | x ∈ ey if x ∈ UP , or ex ∈ ey if x ∈ UA ∪ O}
Definition 5.4 We deﬁne the accessibility relation R ⊆ S × S as it follows: if (S0, →0, φ0) and (S1, →1, φ1) are the labeled syntax trees for the processes P0 and P1, then
⟨(S0, →0, φ0), (S1, →1, φ1)⟩ ∈ R iff P0 → P1
(i.e. P1 can be reached from P0 in one step of ambient calculus reduction).
The accessibility relation can be described using some simple algorithms, one for each reduction rule of Ambient Calculus. We developed these algo- rithms in a companion paper [8]. They determine, giving a state S, which are the possible states S' such that (S, S') ∈ R.
Following the classic way of introducing CTL∗ we define:
Definition 5.5 A fullpath is an inﬁnite sequence S0, S1, ... of states such that (Si, Si+1) ∈ R for all i. We use the convention that if x = (S0, S1, ...) denotes a fullpath, then xi denotes the suﬃx path (Si, Si+1, Si+2, ...).


for example, open capability; we consider, in this case, that these ambients still exist in our process but they have an ”empty position”.
14 the reduction rules of Ambient Calculus allow the destruction of some complex processes by consuming capabilities, but does not allow construction of some complex processes.

Syntax
We inductively define a class of state formulae (formulae which will be true or false of states) and a class of path formulae (true or false of paths), starting from AP. We accept, as basic operators the logical operators ∧ and ¬, the temporal operators X (next time) and ∪ (until ) and the path quantifier E (for some futures). We will derive from them all the usual propositional logic operators, the temporal operators G (always) and F (sometimes) and the path quantifier A (for all futures).
Syntactical rules:
Each atomical proposition αinβ ∈ AP is a state formula
If p, q are state formulae then so are p ∧ q, ¬p
If p is a path formula then E p, A p are state formulae 1’. Each state formula is a path formula
2’. If p, q are path formulae then so are p ∧ q, ¬p
3’. If p, q are path formulae then so are Xp, p ∪ q
Syntactical conventions:
Ap abbreviates ¬E¬p.
EFp abbreviates E(true ∪ p).
AGp abbreviates ¬EF ¬p.
AF p abbreviates A(true ∪ p).
EGp abbreviates ¬AF ¬p.

Semantics
We now define |= inductively. We write M, S0 |= p to mean that the state formula p is true at state S0 in the model M, and M,x |= p to mean that the path formula p is true for the fullpath x in the structure M. The rules are:
M, S0 |= P iff P ∈ L(S0), where P ∈ AP M, S0 |= p ∧ q iff M, S0 |= p and M, S0 |= q
M, S0 |= ¬p iff it is not the case that M, S0 |= p
M, S0 |= Ep iff ∃ fullpath x = (S0, S1, ...) in M with M,x |= p M, S0 |= Ap iff ∀ fullpath x = (S0, S1, ...) in M with M,x |= p M,x |= p iff M, S0 |= p
M,x |= p ∧ q iff M,x |= p and M,x |= q
M,x |= ¬p iff it is not the case that M,x |= p

M,x |= p ∪ q iff ∃i (M, xi |= q and ∀j (j < i implies M, xj |= p))
M,x |= Xp iff M, x1 |= p
Definition 5.6 A state formula p (resp. path formula p) is valid provided that for every structure M and every state S (resp. fullpath x) in M we have M,s |= p (resp. M,x |= p). A state formula (resp. path formula) p is satisfiable provided that for some structure M and some states S (resp. fullpath x) in M we have M,S |= p (resp. M,x |= p).
The following theorem provides a logical characterization of the structural congruence.
Theorem 5.7 Let P1, P2 be two ambient processes. Then the next assertions are equivalent:
P1 ≡α P2
There are two models M1, M2 for the two processes such that the next conditions are satisﬁed:
There exists two bijective functions
ψ : U 1 ∪ U 1 ∪ O1 → U 2 ∪ U 2 ∪ O2 and Pr :Λ ∪ Π → Λ ∪ Π with
P	A	P	A
the properties 15 :
ψ(U 1 )= U 2 , ψ(U 1 )= U 2 and ψ(y)= {ψ(x)| for all x ∈ y};
P	P	A	A
Pr(⟨0, 0⟩)= ⟨0, 0⟩ and Pr(n)= n for all n ∈ Λ ∪ Π \ (N × N)
Pr(f1(α)) = f2(ψ(α)) for all α ∈ U 1 ∪ U 1 ∪ O1
P	A
Pr(F1(α)) =C F2(ψ(α)) for all α ∈ U 1 ∪ U 1 ∪ O1
P	A
The two logics fulﬁll the conditions:
M1, S1 |= αinβ iff M2, S2 |= ψ(α)inψ(β)
The meaning of this theorem is that we can identify the structural equiv- alent processes 16 by the possibility of defining a one-to-one function between the urelements chosen for ambients 17 and between the urelements chosen for atomical processes in the two models that to allow the corresponding atom- ical propositions in the two logics to be true/false, in the same time, in the corresponding model.

Implementing the labeled syntax trees
In this section we sketch the way we implemented the labeled syntax trees in order to make model checking for Ambient Calculus. The main purpose

15 Further we wrote Pr(⟨c1, c2, ...⟩) for all ci ∈ C in order to denote the result of substituting all names n ∈ Λ ∪ Π that appear in capabilities by Pr(n)
16 do not forget that we discuss exclusively the canonical labeled trees
17 up to renaming of the new names by the projection Pr

of this paper is to show the advantages that could be obtained in analyzing the security problems expressed in Ambient Calculus by using our logic. For this reason we will not present here the algorithms that can compute the accessibility relation. These can be found in [8]. We present only the idea behind our implementation.
Moreover, our implementation is adapted to the requirements of NuSMV, but our logic could work as well with over model checkers.
The accessibility relation is defined, inductively, on the structure of the initial state, by analyzing all of its possible derivatives. We have to analyze how the use of the existing prefixes of the ambient process will influence the architecture of our labeled tree.
Consider the ambient process that describes the interaction of a firewall with an agent knowing the passwords, already handled earlier. We have
(νn)(k'[open k.k''[Q]]|n[k[out n.in k'.in n.0]|open k'.open k''.P ])	(1)
We construct the labeled syntax tree for it. As before, we wrap the process into a master ambient u:
u[(νn)(k'[open k.k''[Q]]|n[k[out n.in k'.in n.0]|open k'.open k''.P ])] (2) and we replace the new name by ⟨1, 1⟩.
u[k'[open k.k''[Q]]|⟨1, 1⟩[k[out ⟨1, 1⟩.in k'.in ⟨1, 1⟩.0]|open k'.open k''.P ]] (3)
For 3 we choose the urelements: α for u, β for ⟨1, 1⟩, o for 0, κ for k, κ'
for k', κ'' for k'', p for P and q for Q with α, β, κ, κ', κ'', p, q,o ∈ V. So,
UA = {α, β, κ, κ', κ''}, UP = {q, p, o}, and O = ∅ and f : UP ∪UA ∪O −→ Λ∪Π by: f (α) = u, f (β) = ⟨1, 1⟩, f (o) = 0, f (κ) = k, f (κ') = k', f (κ'') = k'', f (q)= Q, f (p)= P and e : UA ∪ UP ∪ O −→ V ∪ V (V) is defined by:


eα = {eκ' , eβ} =⇒
 eκ' ∈ eα
 eβ ∈ eα

κ'inα is true
=⇒
 βinα is true

eκ' = {eκ'' }	=⇒ { eκ'' ∈ eκ'  =⇒ { κ''inκ'	is true

e = {e , p}	=⇒  eκ ∈ eβ
=⇒  κinβ is true

 p ∈ eβ	 pinβ is true
eκ'' = {q}	=⇒ { q ∈ eκ''	=⇒ { qinκ''	is true
eκ = {o}	=⇒ { o ∈ eκ	=⇒ { oinκ	is true

Hence our initial state is described by the list of true atomical propositions.
We construct two matrices to encode this information.
The first matrix, T1, has one line for each element of UP ∪ UA ∪ O, one column for each element of UA ∪O, and is made by setting the entry of column x and row y to 1, if the proposition xiny is true. All the empty entries are set to 0. See Example table1.
The second matrix, T2, has as rows the elements of UP ∪ UA ∪ O, and as many columns as the number of prefixes forming the largest sequential chain of capabilities in the process plus two. Actually, we have the first column, indexed by f , reporting the value of f applied to the row index (if f is defined in it). The remaining columns define F . The last column is filled by ε. In our example we have
f (α)= u, F (α)= ⟨ε, ε, ...⟩, f (β)= ⟨1, 1⟩, F (β)= ⟨ε, ε, ...⟩,
f (o)= 0, F (o)= ⟨out⟨1, 1⟩, in k', in⟨1, 1⟩, ε⟩, f (κ)= k, F (κ)= ⟨ε, ε, ...⟩,
f (κ')= k', F (κ')= ⟨ε, ε, ...⟩, f (κ'')= k'', F (κ'')= ⟨open k, ε, ...⟩, f (q)= Q,
F (q)= ⟨ε, ε, ...⟩, f (p)= P , F (p)= ⟨open k', open k'', ε, ...⟩. See Example table2 for the construction of the matrix T2.

Example table1


Example table2

The two matrices T1 and T2 suffice to describe each state S. Actually we proved in [9] that the function that associates to each process the quadruple (UP ∪ UA ∪ O, e, f, F ), named the labeled structure tree associated with our process, give us a sound model for Ambient Calculus. We will not present this result here, being less important for our purpose.
If we consider the more complex example (A.1) discussed in the Appendix, where O /= ∅, for it the two matrices have the form:







In this case, the elements of O also appear in the matrices. For the construc- tion of the matrices in more complex cases, see also [8].
Putting the information of a state in the form of the two matrices, gives us the possibility to define an algorithm, the reduction algorithm, to compute the evolution of states under reductions.
Assume that the initial state S1 is described by the tables T1 and T2. The reduction algorithm will start by choosing randomly a row from the table T2. It will check the first capability form the chain of capabilities, i.e. the first position of the F -part of the matrix. If the capability found here, c, is the null capability, ε, then the algorithm will chouse an other row; else will proceed to verify the conditions of consuming this capability, hereafter c-condition algorithm. The c-condition algorithm is specific for each type of capability, and its role is to analyze the structure of the ambient process in order to see if such a reduction is possible 18 . If the capability cannot be consumed, the algorithm will chose an other row, different of those unaccepted before, and will restart the reduction algorithm; else it will proceed with c-reduction

18 it will analyze if the spatial arrangement of the process to see if it allows this reduction. Moreover, this algorithm will check more then the conditions generated by the reduction rules; it will stop the consuming of a forbidden capability, as in the case c1.(c2.P |Q) where the consuming of c2 is forbidden as time as c1 exists

algorithm which will update the two tables, T1 and T2, for the new state obtained by consuming the c capability. We will have a c-reduction algorithm for each type of capability as well.
The reduction algorithm, together with the algorithms c − condition and
c − reduction for all the types of capabilities, can be found in [8].
Denoting by S1 |=alg S2 that S2 is obtained from S1, in one step, using the reduction algorithm instantiated with suitable c-condition and c-reduction, we can define the accessibility relation between states as:
S1RS2 iff S1 |=alg S2

Applying the Logic
We will show in this section the advantages of using a temporal logic to de- scribe the computations of Ambient Calculus. Consider the previous example. We defined the firewall and the agent knowing the passwords as


def
F irewall
νn)n[k[out n.in k'.in n.0]|open k'.open k''.P ]

= ( 
Agent def k'[open k.k''[Q]]
If the mathematical model chosen to describe the firewall-agent interaction is appropriate, then our system shoud have the property that, independently of the path of time that it will choose, always we will meet, in the future, the situation (νn)n[Q|P ] (or, equivalently, ⟨1, 1⟩[Q|P ]).
Our logic allows us to formulate all these as a logical statement. In- deed, if we recall the construction of the labeled syntax tree for the process F irewall|Agent made in the previous section, then the property we are inter- ested in could be expressed as
F irewall|Agent |= AF (βinα  qinβ  pinβ)
It says that in all time paths exists at least a reachable state for which the new name ⟨1, 1⟩ = f (β) (versus n) is a child of the master ambient u = f (α), Q = f (q) is a child of ⟨1, 1⟩ and P = f (p) is a child of ⟨1, 1⟩. Further, for checking the truth value of this statement, a model checker could be used together with our algorithms for implementing the state-processes [8]. Proving that our logical formula is true it finally means that our mathematical model for describing the interaction between a F irewall and an Agent knowing the passwords is a correct one. Vice versa, if is not valid, the model checker will give us a counter example that will show the conflict in our model.
We now briefly present the results of model checking our example using NuSMV. The following formula represents our process after the translation

into the model for NuSMV
u[k1[open k.k2[Q]]|n[k[out n.in k1.in n.0]|open k1.open k2.P ]]
with the property specification of n[P |Q] (Q crosses the firewall) and its nega- tion that includes the claim that Q will not get inside the ambient n (it never crosses the firewall).
The above properties have been checked running NuSMV on a linux oper- ating system equipping a dual Intel Xeon CPU 2.4GHz with 2Gb RAM. The table below reports the amount of resources consumed.

The assertion crossing the ﬁrewall is true, while its negation is false and NuSMV provides the following trace as a counterexample
→ State1.1 ←
u[k1[open k.k2[Q]]|n[k[out n.in k1.in n.0]|open k1.open k2.P ]]
→ State1.2 ←
u[k1[open k.k2[Q]]|n[open k1.open k2.P ]|k[in k1.in n.0]]
→ State1.3 ←
u[k1[open k.k2[Q]|k[in n.0]]|n[open k1.open k2.P ]]
→ State1.4 ←
u[k1[k2[Q]|in n.0]|n[open k1.open k2.P ]]
→ State1.5 ←
u[n[open k1.open k2.P |k1[k2[Q]|0]]]
→ State1.6 ←
u[n[open k2.P |k2[Q]|0]]
→ State1.7 ←
u[n[P |Q|0]]

The property discussed here cannot be expressed in Ambient Logic. All we can say using this logic is that
F irewall|Agent |= ⬦n®n[A|B] where P |= A and Q |= B

But this formula says only that it is possible, in some future, to have the de- sired situation, but not in all possible time paths. If we replace the possibility quantifier by necessity one, we will express the fact that our situation it will happen in all the future moments, so it is still not what we tried to express.

Future work: Extending Ambient Calculus to Non- Wellfounded Structures
This approach to CTL* logic for Ambient Calculus is a refinement of a more abstract one we developed in [9] using a set theoretical description of trees as flat systems of equations, inspired by [2]. This set theoretical tools offers inter- esting perspectives in analyzing structures and, what is the most important, it gives the possibility of analyzing non-wellfounded structures (such as trees with circular branches) with the same accuracy and flexibility as the classical well-founded ones (classical trees). Unfortunately, because of their ”unusual” nature, these ideas are not used in Computer Science almost at all in spite of the fact that those who discovered them (F. Honsell and M. Forti (1983) [7],
P. Aczel (1988) [1], J.Barwise (1996) [2]) were developing them especially for being used in Computer Science.
We investigated this possibility in connection with Ambient Calculus. Con- sider, for example, that the firewall is expected to interact with all the agents that know the passwords. Generally speaking this is the situation in reality. Now the previous definition of the firewall is not satisfactory because it was modelled such that, if the interaction with one agent was done, the firewall cannot interact with any other, being unable to recognize the passwords once again.
A solution in this case could be to use the replication operator in the definition of the firewall.

def
F irewall
νn)n[k[out n.in k'.in n.0]|open k'.open k''.P ]) We can con-

= !((
def	def
sider now two agents Agent	k'[open k.k''[Q ]] and Agent	k'[open k.k''[Q ]].
1 =	1	2 =	2
We have
Agent1|Agent2|F irewall ≡
(νn)(k'[open k.k''[Q1]]|n[k[out n.in k'.in n.0]|open k'.open k''.P ])
|(νn)(k'[open k.k''[Q2]]|n[k[out n.in k'.in n.0]|open k'.open k''.P ])
|!((νn)n[k[out n.in k'.in n.0]|open k'.open k''.P ])
→∗ (νn)n[Q1|P ]|(νn)n[Q2|P ]|F irewall
This problem could be treated from a different point of view than using replication operator. This approach will enlarge the ambient calculus syntax to circular and self referential formulae.

Assume, informally, the formula
ΩP = (νn)(open n.P | n [open n.P | n [open n.P | n [	] ] ])
where n ∈/ f n(P ) and the structure of formula is cyclic. Such a formula
is forbidden in ambient calculus syntax, but it can be expressed using non- wellfouded trees, because our ambient n has the structure described by the equation:
eα = {β, eα}
This describes the non-wellfounded set (hyperset) α = {β, α}. We can recog- nize the non-wellfounded nature, if we try to apply the definition of α:
α = {β, α} = {β, {β, α}} = {β, {β, {β, α}}}
and so on. We can go on deeper and deeper to infinite.
It is easy to verify that
ΩP → ΩP |P → ΩP |P |P → ... → ΩP |P |P |P |...
The action of the process ΩP looks like the action of the replication operator, the only difference is that ΩP needs time (one reduction step) to replicate, while !P can do it instantaneously (by structural congruence). From other point of view, if we accept circular syntax trees for our processes, we do not need, necessarily, to use such an operator as the replication one. Moreover, the construction of the labeled syntax tree for this case is a very simple one and it follows exactly the same steps as the classical case. We do not need to choose new urelements for describing the cyclic definitions, we only need to write the appropriate function e (the flat system of equations).

Conclusions
Our approach to Ambient Calculus opens the perspective of using model check- ing algorithms (or software) developed for temporal logics in analyzing mobile computations. This is because we found a way of implementing the informa- tion behind the ambient processes, using the two matrices, and we constructed the algorithms to calculate the accessibility relation between states.
Having the description of the states, together with the algorithms for ac- cessibility relation, all we have to do for having model checking for mobile computations, is to use further the algorithms for model checking CTL* (a CTL is possible also) and we are investigating now this possibility.
Our ongoing researches make us confident in the possibility to use NuSMV, together with an external translator (used to assign to the ambient calculus process its labeled syntax tree) to model check Ambient Calculus.

References
P. Aczel. Non-Well-Founded Sets. CLSI Lecture Notes Number 14 Stanford: CSLI Publication, 1988.
J. Barwise and L. Moss. Vicious Circles. On the Mathematics of Non-Wellfounded Phenomena. CLSI Lecture Notes Number 60 Stanford: CSLI Publication, 1996.
L. Cardelli and A.D. Gordon. Ambient logic. http://www.luca.demon.co.uk/.
L. Cardelli and A.D. Gordon. Anytime, anywhere. modal logics for mobile ambients. Proceedings of the 27th ACM Symposium on Principles of Programming Languages, pages 365–377, 2000.
L. Cardelli and A.D. Gordon. Mobile ambients. Theoretical Computer Science, Special Issue on Coordination, D. Le Mtayer Editor, pages 177–213, June 2000.
E. A. Emerson. Temporal and modal logic. Handbook of Theoretical Computer Science, B: Formal Models and Sematics:995–1072, 1990.
F. Honsell and M. Forti. Set Theory with Free Construction Principles. Annali Scuola Normale Supeiore di Pisa, 1983.
R. Mardare and C. Priami. Computing the accessibility relation for ambient calculus. Technical report, Dipartimento di Informatica e Tlc, University of Trento, 2003. Available at www.dit.unitn.it following the link Publications.
R. Mardare and C. Priami. A propositional branching temporal logic for the ambient calculus. Technical report, Dipartimento di Informatica e Tlc, University of Trento, 2003. Available at www.dit.unitn.it following the link Publications.

A	The construction of a labeled syntax tree
We present further the construction of a labeled syntax tree. Consider the ambient calculus program:
m[open n.Q|s[out m.in m.n[open t.( out s.(open s.P |R)|K)] ] ] |n[P ]. (A.1)
As a general rule, we embed our program into a master ambient 19 (the master ambient will have a fresh name). Our program becomes:
u[m[open n.Q|s[out m.in m.n[open t.( out s.(open s.P |R)|K)] ] ] |n[P ]] (A.2) The syntax tree of this process is in Figure 19.
For constructing the labeled syntax tree we will define φ. We define the identity function id as:
id(u) = α, id(m) = β, id(n) = γ (the child of u), id(s) = δ, id(n) = µ,
id(Q)= q, id(P )= p' (the child of that n which have γ as identity),
id(P )= p (the child of that n which have µ as identity), id(R)= r, id(K)= k, where {α, β, γ, δ, µ, p, q, p', r, k} ⊂ V.

19 This is a technical trick that is not disturbing our analysis because of the rule (RedAmb): P → Q ⇒ n[P ] → n[Q], [5], but it helps to treat the processes as a whole from the spatial point of view.

u[] 


m[ ]	n[] 








in m	n[ ] 

Fig. A.1. Syntax tree of the process A.2.

Observe that in our situation O' = {•', •''} (see Figure 19). The space function sp for P ∪ O' will be defined starting from the values of id for atomic processes and following the definition of decoration:
sp(u)= {sp(m), sp(n)} (here n is the child of u), sp(m)= {sp(s), q},
sp(n)= {p'} (the child of u), sp(s)= {sp(n)}, sp(n)= {sp(•')},
sp(•')= {k, sp(•'')}, sp(•'')= {p, r}.
For capabilities the identity function have the values:
id(open n)= q, id(out m)= µ, id(in m)= µ, id(open t)= {k, {p, r}}, id(out s)= {p, r}, id(open s)= p
and the spatial function:
sp(open n)= 1, sp(out m)= 1, sp(in m)= 2, sp(open t)= 1, sp(out s)= 1,

sp(open s)= 1
Concluding, the function φ will be defined as (we will denote sp(x) by spx): φ(u)= ⟨α, {spm, spn}⟩,	φ(m)= ⟨β, {sps, q}⟩,
φ(n)= ⟨γ, {p'}⟩,(the child of u)	φ(P )= ⟨p', p'⟩(the child of n),
φ(open n)= ⟨q, 1⟩,	φ(Q)= ⟨q, q⟩,
φ(s)= ⟨δ, {spn}⟩,	φ(out m)= ⟨µ, 1⟩,
φ(in m)= ⟨µ, 2⟩,	φ(n)= ⟨µ, sp•' ⟩,
φ(•')= ⟨∅, {sp•'' }⟩,	φ(open t)= ⟨{k, {p, r}}, 1⟩,
φ(•'')= ⟨∅, {p, r}⟩,	φ(K)= ⟨k, k⟩,
φ(out s)= ⟨{p, r}, 1⟩,	φ(R)= ⟨r, r⟩,
φ(open s)= ⟨p, 1⟩,	φ(P )= ⟨p, p⟩,
for all • ∈ O \ O', φ(•)= ⟨∅, 0⟩,	for all | ∈ O, φ(|)= ⟨∅, 0⟩, The labeled syntax tree is in Figure 19.
We can define now the functions ur, e, f and F .
ur(u)= α, ur(m)= β, ur(n)= γ (the child of u), ur(s)= δ, ur(n)= µ,
ur(Q)= q, ur(P )= p' (the child of n), ur(P )= p, ur(R)= r, ur(K)= k,
ur(•')= {k, {p, r}}, ur(•'')= {p, r}
We can define now the function f :
f (α)= u, f (β)= m, f (γ)= n, f (δ)= s, f (µ)= n, f (q)= Q, f (p)= P ,
f (p')= P , f (r)= R, f (k)= K, f ({p, r})= ⟨0, 0⟩, f ({k, {p, r}})= ⟨0, 0⟩
Note that f is not injective because f (p)= f (p') and f (γ)= f (µ).
We define, as before, UA = {u ∈ V | f (u) ∈ Λ} and UP = {u ∈ V | f (u) ∈
Π}, which in our example became:
UP = {p, q, r, k, p'}, UA = {α, β, γ, δ, µ} and O = {{k, {p, r}}, {p, r}}.
The function e (as before, we denote e(x) by ex):
eα = {eβ, eγ} , eβ = {eδ, q}, eγ = {p'} , eδ = {eµ}, eµ = {e{k,{p,r}}},
e{k,{p,r}} = {k, e{p,r}}, e{p,r} = {p, r}.
The function F :
F (α)= ⟨ε, ε, ...⟩, F (β)= ⟨ε, ε, ...⟩, F (γ)= ⟨ε, ε, ...⟩ F (δ)= ⟨ε, ε, ...⟩ F (µ)= ⟨out m, in m, ε⟩, F (q)= ⟨open n, ε⟩, F (p)= ⟨ε, ε, ...⟩,
F (p')= ⟨open s, ε⟩, F (r)= ⟨ε, ε, ...⟩, F (k)= ⟨ε, ε, ...⟩, F ({p, r})= ⟨out s, ε⟩, F ({{p, r}, k})= ⟨open t, ε⟩.












φ
u[] → ⟨α, {spβ, spγ}⟩

φ
| → ⟨∅, 0⟩


φ
m[] 
β, {sp , q}⟩
φ
n[] 
γ, {p′}⟩

→ ⟨	δ	→ ⟨ 

φ
| → ⟨∅, 0⟩

P φ	′  ′

→ ⟨p ,p ⟩

φ
→ ⟨∅, 0⟩
φ
s[ ] → ⟨δ, {spµ}⟩

		
φ	φ	φ
open n → ⟨q, 1⟩	Q → ⟨q, q⟩	• → ⟨∅, 0⟩
	
φ	φ
out m → ⟨µ, 1⟩	• → ⟨∅, 0⟩
	
φ	φ
in m → ⟨µ, 2⟩	n[] → ⟨µ, {sp•' }⟩

φ
• → ⟨∅, {sp•'' }⟩
	
φ	φ
open t → ⟨{k, {p, r}}, 1⟩	| → ⟨∅, 0⟩
	

φ
→ ⟨∅, {p, r}⟩
φ
K → ⟨k, k⟩

	
φ	φ
out s → ⟨{p, r}, 1⟩	| → ⟨∅, 0⟩
	

φ
→ ⟨∅, 0⟩
φ
R → ⟨r, r⟩

	
φ	φ
open s → ⟨p, 1⟩	P → ⟨p, p⟩
Fig. A.2. Labeled syntax tree of A.2.
