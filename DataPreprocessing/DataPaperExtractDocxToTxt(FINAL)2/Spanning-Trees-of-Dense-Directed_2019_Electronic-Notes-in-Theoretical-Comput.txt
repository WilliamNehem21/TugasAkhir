Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 346 (2019) 645–654
www.elsevier.com/locate/entcs


Spanning Trees of Dense Directed Graphs
Richard Mycroft1  Tássio Naia2,3
School of Mathematics University of Birmingham Birmingham, United Kingdom

Abstract
In the nineties, Komlós, Sárközy and Szemerédi confirmed a conjecture of Bollobás, showing that for every positive α, Δ and suﬃciently large n, every graph with minimum degree (1/2+ α)n contains every tree of order n and maximum degree at most Δ. We obtain a directed graph analogue of their result, where the minimum degree is replaced by minimum semidegree (which is the minimum of all in- and out-degrees over
all vertices) and the maximum degree is replaced by the maximum degree of the underlying graph (i.e., the maximum degree of the graph we obtain by ignoring the orientation of edges).
In fact, we prove a stronger result, which states a suﬃcient condition for a tree of order n to be contained in every directed graph of order n and minimum semidegree (1/2+ α)n. This result implies that for all
positive real α and suﬃciently large n every directed graph of order n with minimum semidegree (1/2+ α)n
contains almost every spanning oriented tree T of order n.
Keywords: graph theory, spanning trees, directed graphs.


Introduction
Let F and G be graphs of order n. How large must δ(G) be to ensure that G contains a copy of F ? (We write δ(G) to denote the minimum degree of G). Perhaps one of the most well-known results in graph theory, Dirac’s theorem states that if n ≥ 3 and F is a Hamilton cycle, then n/2 is the answer. We are interested in a Dirac-type question for directed graphs (digraphs), replacing the notion of minimum degree by that of minimum semidegree δ0(G) of a digraph G, which is the minimum of all in- and outdegrees of vertices of G, i.e.,


δ0(G) :=  min
v∈V (G)
min deg−(v), deg+(v)},



1 Email: r.mycroft@bham.ac.uk
2 Email: tnaia@member.fsf.org
3 Research supported by CNPq grant 201114/2014-3.

https://doi.org/10.1016/j.entcs.2019.08.056
1571-0661/© 2019 The Author(s). Published by Elsevier B.V.
This is an open access article under the CC BY license (http://creativecommons.org/licenses/by/4.0/).


	

Fig. 1. Two digraphs with order n and semidegree n/2 which do not contain an antidirected Hamilton cycle, due to Cai [5] (left) and to DeBiasio and Molla [8] (right). In the figure, Kp denotes a digraph of order p where each pair of vertices is connected by two edges, one in each direction, and arrowed-lines mean that all possible edges (in the corresponding direction) are present.
where deg−(v) is the indegree of v and deg+(v) is the outdegree of v. An oriented
G	G
graph is a digraph obtained from a non-directed graph by choosing a direction for
each of its edges.
Problem 1.1 Let F be a family of oriented trees of order n (for instance, the set of all oriented paths of order n). What is the smallest integer δn,F such that every digraph G of order n with semidegree δ0(G) ≥ δn,F contains every tree in F?
Problem 1.1 has been solved for all sufficiently large values of n when F contains only orientations of paths. Ghouila-Houri [9] proved that if δ0(G) ≥ n/2, then G contains a directed Hamilton cycle (i.e., a spanning cycle v1 → · · · → vn → v1), and thus contains a spanning directed path (i.e., a spanning path v1 → · · · → vn). This has been extended by DeBiasio, Kühn, Molla, Osthus and Taylor [7], who proved that if δ0(G) ≥ n/2 (and n is sufficiently large) then G contains every possible orientation of a Hamilton cycle, except perhaps for the antidirected one; the known threshold for existence of antidirected Hamilton cycles is δ0(G) ≥ n/2+1 (again, for sufficiently large n) and was established by DeBiasio and Molla [8] (see Figure 1).
These results for paths are sharp in the sense that the value of δn,F is determined precisely. Indeed, if δ0(G) = [n/2|− 1 then G may not even be connected (see Figure 2), so δn,F ≥ n/2 whenever F is not empty (see also Figure 1). Hence if G has semidegree at least n/2 then G contains every orientation of a Hamilton path (consider a cycle of order n which is not anti-directed but contains a given orientation of an n-vertex path), and as noted above this bound is best possible. To the best of our knowledge, not much else is known about spanning trees of general digraphs G with given semidegree if no other conditions are imposed on G (although, for instance, more is known about the presence of Hamilton cycles in G if G is an oriented graph [10] or if G is strongly connected [17]).
The situation in the graph setting is quite different (see, e.g.: [15,16]). Of partic-


Fig. 2. Digraphs with order n, and semidegree [n/2|− 1 which do not contain any orientation of a Hamilton cycle. In the figure, Kk denotes a digraph of order k where each pair of vertices is connected by two edges, one in each direction. Left: two disjoint copies of Kk, so n = 2k. Right: two disjoint copies of Kk and a vertex connected (in both directions) to each vertex in each copy, so n = 2k + 1.

ular interest to us, a classical theorem by Komlós, Sárközy and Szemerédi [11] states that if δ(G) ≥ 1/2 + o(1) n then G contains every tree with bounded degree.
Theorem 1.2 [11] For every positive integer Δ, every real 0 < α < 1/2 and suffi- ciently large integer n, every graph of order n and minimum degree at least 1 + α n
contains every spanning tree T with maximum degree at most Δ.
Komlós, Sárközy and Szemerédi have later strengthened Theorem 1.2, replacing the constant bound Δ by cn/ log n, where c is some constant depending on α [12]. Several other variations and extensions of Theorem 1.2 exist (see, e.g., [2,3,4,6,18]).

Our contribution
We investigate directed graph analogues of Theorem 1.2 where the host digraph has high semidegree.
Theorem 2.1 For all positive real α, Δ there exists n0 such that for all n ≥ n0 the following holds. If G is a directed graph of order n and minimum semidegree at least ( 1 + α)n, then G contains every (spanning) tree of order n such that Δ(T ) ≤ Δ.
We prove Theorem 2.1 by establishing a stronger result. Let Gn,α be the set of all digraphs G of order n with δ0(G) ≥ (1/2+ α)n. Let C > 0, let T be an oriented tree of order n, where n is sufficiently large, and suppose that T has maximum degree Δ(T ) ≤ (log n)C (where the maximum degree of T is the maximum degree of the tree we obtain from T by ignoring the orientation of edges). We describe a sufficient condition for T to be contained in every G ∈ Gn,α, and use this to prove that almost every oriented tree of order n is contained in every G ∈ Gn,α. Theorem 2.1 follows because every (sufficiently large) oriented tree of bounded degree satisfies this condition (this is proved at the end of this section).
Before we state our main result, we introduce some definitions. A path P in a digraph T is bare if every edge e ∈ E(T ) \ E(P ) either does not intersect P or intersects P at one of its endvertices (which are the vertices in P with a single neighbour in P ). We use the notation x  y to indicate that for every positive y there exists a positive number x0 such that for every 0 < x < x0 the subsequent statements hold. Such statements with more variables are defined similarly. We always write log x to mean the natural logarithm of x, and omit floors and ceilings when this does not affect the arguments.
Theorem 2.2 Suppose that 1/n  1/C and that 1/n  λ  α. Let G be a digraph of order n with δ0(G) ≥ (1/2+ α)n, and let T be an oriented tree of order n such that Δ(T ) ≤ (log n)C. If T contains either
at least λn vertex-disjoint bare paths of order 7; or
at least λn vertex-disjoint edges incident to leaves, then G contains a copy of T.
(We sketch the proof of Theorem 2.2 in the next section.)

We remark that not every tree satisfies one of the conditions above. Indeed, consider the following construction. Let Bn be a rooted binary tree with n/ log n leaves, where the root has degree 2 and every other vertex which is not a leaf has degree 3. Then Bn has 2n/ log n − 1 vertices. Let Tn be the tree we obtain from Bn by appending log n − 2 new leaf vertices to each leaf vertex of Bn so that Tn has has order n − 1. Note that any bare-path in Tn is an edge, that Δ(T ) ≤ log n and moreover that T contains at most n/ log n distinct leaf-edges; this means that for all λ > 0 we can choose n sufficiently large so that Tn does not satisfy either condition (i) or (ii) of Theorem 2.2.
On the other hand, almost all labelled trees have sub-logarithmic maximum degree, as proved by Moon.
Theorem 2.3 [19, Corollaries 1 and 2] For every ε > 0, if T is chosen uniformly at random from the set of all labelled trees on n vertices, then asymptotically almost surely


(1 − ε)
log n


log log n
≤ Δ(T ) ≤ (1 + ε)
log n
.
log log n

Since a uniformly-random orientation of a uniformly-random labelled tree yields a uniformly-random labelled oriented tree, Theorem 2.3 remains valid if we replace ‘labelled tree’ by ‘labelled oriented tree’.
Moreover, we can prove (by a simple application of the second moment method) that almost every tree satisfies case (ii) of Theorem 2.2. This fact, combined with Theorem 2.3, immediately implies that almost every tree is contained in every digraph of high semidegree.
Theorem 2.4 Let Tn be the set of all labelled oriented trees of order n. For all positive α, ε, there exists n0 such that for all n ≥ n0 the following holds. There exists a family F ⊆ Tn with |F| ≥ (1 − ε)|Tn| such that if G is a digraph of order n ≥ n0 with δ0(G) ≥ (1/2+ α)n then G contains every tree T ∈ F.
We conclude this section describing how we can deduce Theorem 2.1 from The- orem 2.2. We first introduce a few definitions and a lemma. A path decomposition P of a tree T is a collection of edge-disjoint subpaths of T such that each edge of T is contained in precisely one path of P; we say that P is bare if each path of P is bare. In other words, two paths in a bare path decomposition of a tree are only allowed to intersect at their endvertices. We write p(T ) for the smallest size of a bare path-decomposition of T , and l(T ) for the number of leaves of T . In particular, if T is a path then p(T )= 1, and if T is a star then p(T )= l(T ). It is not difficult to prove the following lemma.
Lemma 2.5 If T is a tree which is not a path, then l(T ) ≤ p(T ) ≤ 2l(T ) − 3.
We are now in position to derive Theorem 2.1 using Theorem 2.2 and Lemma 2.5.
Proof. [Proof of Theorem 2.1] Let T be an oriented tree of order n with Δ(T ) ≤ Δ
and let G be a digraph with δ0(G) ≥ (1/2+ α)n. We introduce new constants λ

and λj with 1/n  λ  λj  α, Δ. If T contains at least λjn leaves, then T contains at least λjn/Δ > λn edge-disjoint leaf-edges, so G contains a copy of T by Theorem 2.2 (i). Otherwise, by Lemma 2.5, T contains a bare path decomposition P into at most 2λjn paths. Note that any bare path in T is a subpath of some P ∈ P, and that if P has length x (i.e., x edges) then P contains at least [x/t♩ edge-disjoint bare paths (of T ) of length t (and order t + 1). Let x1,..., xs be the lengths of the paths in P, so x1 + ··· + xs = n − 1. Then, for every positive integer t, we have
The number of edge-disjoint bare-paths of length t in

T ≥ Σ
i=1
 xi 

≥ Σ
i=1
xi − 1 =
t
n − 1
t
— s.

Choosing t = 8, it follows that T contains at least (n − 1)/8 − 2λjn ≥ n/10 edge- disjoint bare paths of length 8 (and order 9). Therefore, T contains at least n/10 vertex-disjoint bare paths of order 7, so G contains a copy of T by Theorem 2.2 (ii).2

Outline of proof of Theorem 2.2
In this section we briefly sketch the proof of Theorem 2.2. A detailed argument is contained in the second author’s PhD thesis [21]. Our proof of Theorem 2.2 builds on results of Kühn, Mycroft and Osthus [13,14] as well as on a previous paper by the au- thors [20]. An important ingredient shared by these results is the regularity method of Szemerédi [22,23], which we briefly introduce in the next section. (A version of Szemerédi’s regularity lemma for digraphs was developed by Alon and Shapira [1].)

A word on regularity
Roughly speaking, the regularity lemma states that if G is a (di)graph with many vertices, then there exists an equipartition V1,..., Vk of V (G) into a bounded number of sets—often called clusters—such that the distribution of edges between almost all pairs (Vi, Vj) is random-like. More precisely, for all X ⊆ Vi and all Y ⊆ Vj, we write eG(X, Y ) to denote the number of edges in G which are directed from X to Y ; we say that (Vi, Vj) is an ε-regular pair (informally, a random-like pair) if
eG(X, Y )	eG(Vi, Vj)−		< ε 
|X||Y |	|Vi||Vj|
for all X ⊆ Vi and all Y ⊆ Vj with |X|≥ ε|Vi| and |Y |≥ ε|Vj|.
The ‘reduced graph’ is a graph whose vertices correspond to clusters of G and whose edges correspond to the pairs of clusters which are connected in this random- like fashion and which are sufficiently ‘dense’. Formally, the reduced graph R = R(d) of G (with parameter d and with respect to a given vertex-partition V1,..., Vk) is defined as follows. Fix d with 0 < d < 1, and let R be the graph with vertex set
{1,..., k} such that for all i, j ∈ R we have i → j if and only if eG(Vi, Vj)/(|Vi||Vj|) > d.

Proof outline
Recall that the statement of Theorem 2.2 has two cases for the structure of T . The proof is different for each case, although both follow a similar outline. For the sake of simplicity, below we assume T falls into case (i) of Theorem 2.2.
Our strategy for finding a spanning tree T in a digraph G consists of three steps: ‘allocation’, ‘embedding’ and ‘extension’. As a preliminary step, we delete edges from T , obtaining a forest T j; the deleted edges are chosen carefully, so that they are far apart and so that one component of T j is large. The goal of the two first steps (allocation and embedding) is to find a copy of T j in G. The final step (extension) adds the missing matching.
The bulk of our proof consists of describing how to embed T j to G in such a way that the extension step can be made. At the core of our proofs lie two algorithms: a randomised algorithm for allocation and a greedy algorithm for embedding T j.
Let R be the reduced graph of G (note that R is a digraph), let k := |V (R)| and n := |V (G)|. Then each vertex of R corresponds to a set of approximately n/k vertices of G and the edges of R correspond to ‘regular pairs’ of clusters of G. We may assume that 1/n 1/k  α, and, using the fact that G has high semidegree, we can prove that R contains a spanning regular subdigraph Rj which is an expander, and (relabelling the clusters if necessary) we may assume that Rj has a directed Hamilton cycle 1 → 2 → ··· → k → 1. (A digraph D is an expander if, for each nonempty proper subset S of V (D), both the in- and outneighbourhoods of S in D are strictly larger than S.)
Informally, an allocation of T j to G is a homomorphism from T j to Rj. This homomorphism is constructed by the allocation algorithm (in fact, we alter the allocation of a few vertices at some stage, so that the number of vertices mapped to each cluster Vi equals |Vi|). We note that every vertex of G is allocated to some cluster in the allocation phase.
Once T j has been allocated, we embed T j to G using a (deterministic and greedy) embedding algorithm which finds a copy of T j in G by embedding, in turn, each vertex x ∈ T j to a vertex in the cluster ϕ(x), relying on the fact edges of R correspond to regular pairs. We take special care, while embedding, to ensure that vertices incident to edges in the removed matching of T are mapped to ‘good’ vertices. More precisely, let M be the edges which were removed from T at the start (i.e., T j := T − E(M )). The embedding is such that, writing Mi for the vertices of M embedded to cluster Vi, and V j for the image of Mi, the following hold.

|Mi| = |M|/k;
either
for each x ∈ Mi, the neighbour of x in Mi is embedded to V j


for all

i ∈ {1,..., k}, where addition is modulo k; or
for each x ∈ Mi, the neighbour of x in Mi is embedded to V j
for all

i ∈ {1,..., k}, where subtraction is modulo k);
(V j,V j  ) and (V j,V j  ) are regular pairs such that each vertex in V j has many
i	i+1	i	i—1	i
outneighbours in V j	and many inneighbours in V j  .

The conditions above ensure that we may find a copy of M which extends the embedding of T j to an embedding of T in G.

Allocation
The main challenge in allocation is ensuring that the homomorphism we produce maps the correct number of vertices of T to each cluster. This is achieved by a careful allocation of bare paths of T (or vertex-disjoint edges incident to leaves of T respectively) and by using a randomised allocation algorithm which produces (with high probability) an almost uniform distribution of vertices of a large tree to a small regular expander. (The allocation algorithm is described at the end of this section.) Here is how we proceed. We partition T into two large edge-disjoint subtrees T1 and T2; this can be done so that |V (T1)| ≤ |V (T2)| and so that T1 contains many bare paths. We fix two disjoint families P1, P2 of pairwise vertex-disjoint bare paths in T1, and contract all paths in P1 ∪ P2, yielding a tree T ٨. Let T j be the tree we obtain from T1 by this contraction. We allocate T j using the randomised allocation algorithm, and allocate the paths in P1 and P2 in a different manner (described below). The randomised algorithm produces a homomorphism of a tree T to a digraph R; we can prove that this algorithm yields, with high probability, an almost uniform distribution of vertices of T to vertices of R if R contains a spanning regular sub(di)graph Rj which satisfies some expansion properties and if T has maximum
degree bounded (as in the hypothesis of Theorem 2.2).
The allocation of T j produced by the algorithm, together with the allocation of paths in P1 ∪ P2 may not be very uniform (due to the allocation of the paths in P1 and P2). We recover almost-uniformity by allocating T2 using a weighted version of the allocation algorithm. The resulting allocation of T is then almost uniform.
The families of contracted paths serve distinct purposes. Paths in P1 are allo- cated so that they have more than one valid allocation (i.e., so that some of their vertices can be allocated to either one of at least two clusters while still yielding a homomorphism). In other words, we have some flexibility when choosing the alloca- tion of these vertices, which we use to refine the almost-uniform allocation of T1 ∪T2 into a precise allocation which matches the sizes of each cluster. Paths in P2, on the other hand, are meant to be used in the last step of the embedding phase: extension. Roughly speaking, the paths in P2 are mapped so as to ensure that many edges of certain orientation are allocated along certain edges of R; this will be useful when finding the desired matching M .
Allocation algorithm. Let r be the sole vertex at the intersection of T1 and T2, and consider T ٨ as rooted at r. We build a homomorphism from T ٨ to Rj one vertex at a time, starting at r, so that no vertex is processed before its parent and so that at each step we map a vertex v ∈ V (T ٨) to a vertex of Rj. (The parent of a vertex v is the neighbour of v in the path from v to r). When allocating any vertex x (other than the root), the parent p of x in T ٨ is the only neighbour of x for which ϕ has been defined. Let Cp be the children of p. We define ϕ for all vertices in Cp at once, as follows: first choose an inneighbour v— and an outneighbour v+ of ϕ(p) in Rj

uniformly at random, with choices made independently of all other choices in the algorithm; then map each child inneighbour of p to v— and each child outneighbour of p to v+.
We note that the algorithm above cannot ensure a good distribution of vertices for trees with small diameter. For instance, if T ٨ is a star, then the centre of T ٨ is the only vertex mapped to some vertex of R. However, by the hypothesis of Theorem 2.2, the maximum degree of T ٨ is never too high, and we avoid this problem. Indeed, an important step in the proof is to show that if Δ(T ٨) ≤ (log |T |)C, where 1/n  1/C, then most vertices of T lie (sufficiently) far away from one another.
Embedding
Most of the embedding is determined by the algorithm below. More precisely, we apply the embedding algorithm to a subtree of T , which has been obtained by con- tracting some edges belonging to paths in P2 (we are careful in doing this so that the restriction of the allocation to the contracted tree is still a homomorphism). Moreover, we do not apply the embedding algorithm to the whole of G, but to a subdigraph Gj ⊆ G (we reserve some sets of vertices in each cluster for the match- ings at the end). We prove that the embedding algorithm succeeds and that the embedding it produces can be extended to a full copy of T in G in the extension phase.
We conclude this section with an outline of the embedding algorithm. We note that the description below is very simplified, because a key property driving the algorithm, denoted (β, γ, ϕ, m)-goodness in [21], is somewhat technical and hence was ommited from this note.
Embedding algorithm. Similarly to the allocation algorithm, we consider the tree T ٨ which we wish to embed as being rooted; we embed the vertices of T ٨ greedily, so that siblings are embedded at the same step and every vertex is embedded after its parent. (The precise description of the algorithm is rather technical and hence we omit it.) In a nutshell, for each x ∈ T ٨, we embed x to the cluster ϕ(x), and when we do so we also reserve a set of vertices for the children of x. An important issue here is that not too many vertices can lie in reserved sets: this is ensured by choosing carefully the order in which vertices are processed.

Conclusion
Our Theorems 2.1, 2.2 and 2.4 describe a large family of spanning trees of every digraph of high semidegree; as it turns out this is a property of almost every tree, and of every sufficiently large tree whose maximum degree is bounded by a constant. This answers many instances of Problem 1.1. Let us note two very natural ways in which to generalise this problem. One direction is to consider weaker notions of degree, such as the total degree δtot(G), defined as

δtot(G) := min
 deg—(V )+ deg+(v) .



Problem 4.1 Do Theorems 2.1, 2.2 and 2.4 remain true if we replace δ0(G)
by δtot(G)/2?
It is also natural to consider more general classes of spanning subdigraphs (as has been done for undirected graphs), seeking directed graph analogues of generalisations of Theorem 1.2.
Problem 4.2 Which spanning subdigraphs must be contained in every graph of high semidegree?
It is often the case that directed versions of (undirected) graph problems require substantially distinct approaches in order to be solved. We believe that some of tools we introduce for Problem 1.1 can be adapted to obtain results towards Problems 4.1 and 4.2.

References
Alon, N. and A. Shapira, Testing subgraphs in directed graphs, Journal of Computer and System Sciences
69 (2004), pp. 354–382.
Balogh, J., B. Csaba and W. Samotij, Local resilience of almost spanning trees in random graphs, Random Structures & Algorithms 38 (2011), pp. 121–139.
Böttcher, J., J. Hàn, Y. Kohayakawa, R. Montgomery, O. Parczyk and Y. Person, Universality for bounded degree spanning trees in randomly perturbed graphs, ArXiv e-prints (2018).
Böttcher, J., M. Schacht and A. Taraz, Proof of the bandwidth conjecture of Bollobás and Komlós, Mathematische Annalen 343 (2009), pp. 175–205.
Cai, M. C., A counterexample to a conjecture of Grant, Discrete Mathematics 44 (1983), p. 111.
Clemens, D., A. Ferber, R. Glebov, D. Hefetz and A. Liebenau, Building spanning trees quickly in maker-breaker games, SIAM Journal on Discrete Mathematics 29 (2015), pp. 1683–1705.
DeBiasio, L., D. Kühn, T. Molla, D. Osthus and A. Taylor, Arbitrary orientations of Hamilton cycles in digraphs, SIAM Journal on Discrete Mathematics 29 (2015), pp. 1553–1584.
DeBiasio, L. and T. Molla, Semi-degree threshold for anti-directed Hamiltonian cycles, Electronic Journal of Combinatorics 22 (2015).
Houri, G., Une condition suﬃsante d’existence d’un circuit Hamiltonien, Comptes Rendus de l’Académie des Sciences 25 (1960), pp. 495–497.
Keevash, P., D. Kühn and D. Osthus, An exact minimum degree condition for Hamilton cycles in oriented graphs, Journal of the London Mathematical Society 79 (2009), pp. 144–166.
Komlós, J., G. N. Sárközy and E. Szemerédi, Proof of a packing conjecture of Bollobás, Combinatorics, Probability, and Computing 4 (1995), pp. 241–255.
Komlós, J., G. N. Sárközy and E. Szemerédi, Spanning trees in dense graphs, Combinatorics, Probability, and Computing 10 (2001), pp. 397–416.
Kühn, D., R. Mycroft and D. Osthus, A proof of Sumner’s universal tournament conjecture for large tournaments, Proceedings of the London Mathematical Society 102 (2010), pp. 731–766.
Kühn, D., R. Mycroft and D. Osthus, An approximate version of Sumner’s universal tournament conjecture., Journal of Combinatorial Theory, Series B 101 (2011), pp. 415–447.
Kühn, D. and D. Osthus, “Embedding large subgraphs into dense graphs,” London Mathematical Society Lecture Notes 365, Cambridge University Press, 2009 pp. 137–167.


Kühn, D. and D. Osthus, Hamilton cycles in graphs and hypergraphs: an extremal perspective, in: Proceedings of the International Congress of Mathematicians (Seoul, Korea), ICMC 2014 4, 2014, pp. 381–406.
Kühn, D., D. Osthus and T. Townsend, Proof of a tournament partition conjecture and an application to 1-factors with prescribed cycle lengths, Combinatorica 36 (2016), pp. 451–169.
Michael Krivelevich, B. S., Matthew Kwan, Bounded-degree spanning trees in randomly perturbed graphs, SIAM J. Discrete Math. 31 (2017), pp. 155––171.
Moon, J. W., “Counting labelled trees,” Number 1 in Canadian Mathematical Monographs, Canadian Mathematical Congress, 1970.
Mycroft, R. and T. Naia, Unavoidable trees in tournaments, Random Structures & Algorithms 53
(2018), pp. 352–385.
Naia, T., “Large Structures in Dense Directed Graphs,” Ph.D. thesis, University of Birmingham (2018).
Szemerédi, E., On sets of integers containing no k elements in arithmetic progression, Acta Arith. 27
(1975), pp. 199–245, collection of articles in memory of Juri˘ı Vladimirovič Linnik.
Szemerédi, E., Regular partitions of graphs, in: Problèmes combinatoires et théorie des graphes (Colloq. Internat. CNRS, Univ. Orsay, Orsay, 1976), CNRS, Paris, 1978 pp. 399–401.
