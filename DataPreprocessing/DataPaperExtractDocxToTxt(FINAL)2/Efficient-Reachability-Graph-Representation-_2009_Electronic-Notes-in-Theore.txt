

Electronic Notes in Theoretical Computer Science 239 (2009) 119–129
www.elsevier.com/locate/entcs

Efficient Reachability Graph Representation of Petri Nets With Unbounded Counters
Franck Pommereau1
LACL, Universit´e Paris 12. 61 avenue du g´en´eral de Gaulle. 94010 Cr´eteil, France
Raymond Devillers2
D´epartement d’Informatique, Universit´e Libre de Bruxelles. CP212, B-1050 Bruxelles, Belgium
Hanna Klaudel3
IBISC, FRE 2873 CNRS, Universit´e Evry-Val d’Essonne. 91000 Evry, France

Abstract
In this paper, we define a class of Petri nets, called Petri nets with counters, that can be seen as place/transition Petri nets enriched with a vector of integer variables on which linear operations may be applied. Their semantics usually leads to huge or infinite reachability graphs. Then, a more compact representation for this semantics is defined as a symbolic state graph whose nodes possibly encode infinitely many values for the variables. Both representations are shown behaviourally equivalent.
Keywords: Petri nets, unbounded integers, reachability, traces.


Introduction
Handling (and in particular model checking) systems with huge or infinite state spaces is known to be usually problematic, especially when one has to manage data with infinitely many values. The problem may be solved for instance when con- sidering effective well-structured systems (where the evolutions are monotonic with respect to some well chosen well quasi order), when the state sets under considera- tion are upward or downward closed, and thus may be characterised by a finite set of generators [3]. The reachability set is usually not closed itself, but when the data

1 Email: franck.pommereau@univ-paris12.fr
2 Email: rdevil@ulb.ac.be
3 Email: klaudel@ibisc.univ-evry.fr

1571-0661/© 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.05.034

space is regular enough, which is usually the case in practice (even if in all gener- ality reachability is often undecidable), it may happen that it can be represented using finite structures. This implies to be able to represent finitely infinite sets of states and to compute a possibly infinite set of reachable states in a finite amount of time. For instance, the approach developed in [1] (and implemented in [2]) allows to define data structures to represent sets of integer vectors that can be defined in the Presburger arithmetic and to apply to them linear transformations. It also allows to compute in a finite amount of time the result of an infinite sequence of transformations, which is called in [1]a meta-transition. If enough meta-transitions can be executed, the complete state space of a system may possibly be computed (and represented) in a finite amount of time. Of course, not all state spaces can be given a finite representation, nor all meta-transitions can be executed using a finite computation. Indeed, there exist transformations for which this “condensation” is not possible, but as explained in [1], it may be preferable to have a partial solution to a general interesting problem (especially if in practice it usually works) rather than a complete solution for a useless class of problems.
The aim of this paper is to apply these techniques in the context of Petri nets [6].
To do so, we define a class of Petri nets, called Petri nets with counters (PNZ ). They are place/transition (P/T) Petri nets enriched with data in a global vector of integer variables, manipulated through linear transformations. The places, arcs and tokens in PNZ are like in P/T nets, while each transition carry an annotation encoding the linear transformation to perform at each firing. A PNZ can be understood as coding the control state in its places and the data state in its variables. It may also be seen as a special case of coloured Petri nets, that implement the integer variables as integer marked places. Its semantics usually leads to produce infinite reachability graphs.
A more compact state graph construction is defined next. This is made possible by detecting executions that change the data state but not the control one, and executing them as a meta-transition. The result is a compact graph in which each state possibly encodes a huge or infinite number of reachable markings.
The main result of the paper is to show that the compressed state graph preserves the semantics of the system in that it encodes exactly the same set of traces (firing sequences) and the same set of reachable markings.
The basic motivation for specifically introducing a model of Petri nets with unbounded counters, equipped with a compressed semantics, is the aim of efficiently verifying systems modelled using the causal time approach where the passing of time is explicitly represented by counting the occurrences of a tick transition [5].
Basic notations and definitions
Let Z denote the set of integers and D = {•} Z the set of data values, where “•” is the Petri net black token. If f and g are two functions on a domain H, we denote by f ◦ g their composition, defined for all a ∈ H as (f ◦ g)(a) = f (g(a)).
Let n ≥ 0 be an integer and let V = {x0,... , xn−1} be a finite set of variables such that V ∩ D = ∅. We shall also assume to have chosen an ordering on those variables

and denote by X = [x0,... , xn−1] ∈ Vn
the corresponding vector enumerating all

those variables. In the examples we will use either X = [x, y, z] or simply X = [x].
A linear transformation L is a pair (C, U ) where:
C is a linear condition, i.e., an expression of the form PX ≤ Q, where P is an
m × n integer matrix, and Q is a vector in Zm, for m ≥ 0;
U is a linear update, i.e., an expression of the form AX + B where A is an
n × n integer matrix and B ∈ Zn.
Linear conditions allow to express a large variety of (conjunctive) conditions. For instance, (x < y) ∧ (x + 2y = 3z) ∧ (z > 5) is equivalent to (x − y ≤ −1) ∧ (x + 2y − 3z ≤ 0) ∧ (−x − 2y + 3z ≤ 0) ∧ (−z ≤ −6), that is linear. Disjunctive conditions, of the kind γ1 ∨ γ2, and in particular of the kind a /= b (which is in fact (a − b ≤ −1) ∨ (b − a ≤ −1)), are not expressible, but they may be replaced by several linear transformations associating each distinct disjunct to the same update. Linear updates allow to simultaneously assign all the variables in X with linear combinations of their previous values (multiplying variables is thus forbidden). For instance, we may have (x := 2x + y + 3; y := z; z := y + 1). Together with the previously given linear condition, we get the following linear transformation:

02  1 −1	0 3 2 x 3
2 −1 3
2 2 1 0 3 2 x 3
2 3 31

B6  1	2 −3 7 64 y 75 ≤ 6	7 ,  64 0 0 1 75 64 y 57 + 64 0 75C

−1 −2	3	0
z
0	0 −1	−6
0 1 0	z	1 A

In the following, we shall use both matrices or developed formulas.
For a vector V of size n, we denote by V [xi] its i-th component. In the example above, the linear update U is such that U [x]= 2x+ y + 3, U [y]= z and U [z]= y + 1. Let Z ⊆ Zn and L be a linear transformation (PX ≤ Q, AX + B). The appli- cation of L on Z, denoted by L(Z), is the subset of Zn defined by {AY + B | Y  ∈ Z, PY  ≤ Q}.	Moreover, the iterated application of L on Z, denoted by
L∗(Z), is the limit (union) of the increasing series of sets (Z )	df
i i≥0 where Z0 = Z
and Zi+1 = Zi ∪ L(Zi).
Coloured Petri nets
A Coloured Petri net (CPN ) [4] on D and V is a tuple N =df (S, T, l) where S is a finite set of places, T is a finite set of transitions such that S ∩ T = ∅, and l is the labelling function on places, transitions and arcs (elements from (S × T ) ∪ (T × S)):
for each place s ∈ S, l(s) ⊆ D is the type of s;
for each transition t ∈ T , l(t) is an evaluable Boolean expression on V, called the guard of t (a condition for its execution);
for each input arc (s, t) ∈ S × T , l(s, t) is a finite multiset over D ∪ V, repre- senting the values consumed in s when t is executed;
for each output arc (t, s) ∈ T × S, l(t, s) is a finite multiset of values in D, variables in V or evaluable expressions on them, representing the values pro- duced in s when t is executed. The difference with the input case is that a computation of new values is allowed by using expressions.

A state of a CPN N = (S, T, l) is represented by a marking M that is a mapping that associates to each place s ∈ S a multiset M (s) over l(s), that represents the tokens held by each place. A transition t ∈ T is enabled at M , if there exists a binding ρ : V → D such that:
the evaluation of the guard is true: evalρ(l(t)) = T ;
for each arc (s, t), there are enough tokens in the place s: M (s) ≥ evalρ(l(s, t));
for each arc (t, s), the type of s is respected: evalρ(l(t, s)) is a finite multiset over l(s).
If t is enabled at M for a binding ρ, it may ﬁre, leading to a new marking M '

defined for each s ∈
'	df
— eval (l(s, t)) + eval (l(t, s)). M ' is then

S by M (s) = M (s)	ρ	ρ
called reachable in one step from M (notice that, in all generality, many different bindings may lead from M to M ' through t). A trace, 4 or firing sequence, of a
length k ≥ 0 of a marked CPN (N, M ) is defined as M  −t−1−−,−−ρ−→−1 ··· −t−k−−,−−ρ−→−k  M , where
0	0	k
for all 1 ≤ i ≤ k, Mi is reachable in one step from Mi−1 by firing ti with the binding
ρi. Mk is then said to be reachable from M0 (in k steps); tracek(N, M0) denotes the
set of all the traces of length k of (N, M ) and trace(N, M ) =df	trace (N, M )
0	0	k≥0	k	0
is the set of all the traces of (N, M0). The set of traces of a family F of marked

CPNs is defined as trace(F ) =df 

(N,M0)∈F
trace(N, M0).

The reachability of the markings from the initial marking M0 in N can be
represented as a (possibly infinite) reachability graph which is the directed graph whose nodes are all reachable markings and where each arc represents a transition and a binding producing one marking from another. In this context, the reachability graph can be considered as a compact representation of trace(N, M0). In particular, it may remain finite (i.e., have a finite number of reachable markings) even if it admits infinite traces.
Coloured Petri nets may be seen as a generalisation of the P/T nets or, the other way round, a P/T net is a restricted coloured Petri net where:
for each place s ∈ S, l(s)= {•};
for each transition t ∈ T , l(t)= T (true guard);
for each arc (a, b) ∈ (S × T ) ∪ (T × S), l(a, b) is a finite multiset over {•}.
Because such a net does not use any variable, the bindings for it are not relevant and will be ignored in the following.
As usual, Petri nets will be represented graphically using circles for the places, rectangles for the transitions and directed links for the arcs. Arcs labelled by empty multisets will be omitted, as well as default annotations: T for a true guard and
{•} for a place type or an arc label.

Petri nets with Counters
A Petri net with counters (PNZ ) is a P/T net enriched with data represented through a global vector V ∈ Zn of integer values (counters). An additional labelling of the transitions of the net with linear transformations allows to check and update

4 Traces should not be confused here with Mazurkiewicz’ traces.



(x < ω/2,x := x + 1)
(x > 0,x := x − 1)


(x < ω, x := x + 1)

(x < ω, x := x + 1)
(x > 0,x := x − 1)

Fig. 1. An example PNZ, for which we assume X = [x]; its initial data is D0 = {[0]} and each transition is labelled by its associated linear transformation. The parameter ω is some fixed even non-negative integer.

df
the data at each firing of a transition. More precisely, a PNZ is a tuple N =
df
(S, T, l, L) where [N ♩ = (S, T, l) is a P/T net and L is mapping associating to each
df
transition t in T a linear transformation L(t) = (C(t),U (t)). An example PNZ is
depicted in the figure 1.
A (aggregated) state of a PNZ N is a pair (M, D) where M is a marking of [N ♩ and D ⊆ Zn, with D /= ∅, is a set of possible values for V . A state (M, D) such that D is a singleton is called a concrete state; a state in general encodes several concrete states, and possibly infinitely many of them.
A CPN semantics of PNZs
Let N = (S, T, l, L), with L = (C, U ) as defined above, be a PNZ and (M, D) be its
initial state. It can be translated into a family cpn(N, M, D) =df {((S',T ', l'),M  ) |
V ∈ D} of marked CPNs which differ only by the initial markings (each such marking corresponding to one concrete initial state), where:
S' =df S  {s | x ∈ V} and T ' =df T ;
for all s ∈ S, l'(s) =df {•} and for all x ∈ V, l'(s ) =df Z;
df	df
for all s ∈ S, MV (s) = M (s) and for all x ∈ V, MV (sx) = V [x];
for all t ∈ T , l'(t) =df C(t);
for all (a, b) ∈ (S × T ) ∪ (T ×	'	df

for all t ∈ T , for all x ∈ V, l'(s
x, t) = {x} and l'(t, sx) =
{U (t)[x]}.

The semantics of a PNZ N in an initial state (M, D) is the set trace(cpn(N, M, D)) of traces of the corresponding translated CPNs.
An example of such a translation, giving a single CPN, and the corresponding reachability graph are illustrated in the figures 2 and 3, respectively.
In order to compare a concrete state of a PNZ and a marking M of a CPN, we shall denote the latter by a pair (M•,V ), where M• is M restricted to the
places of type {•} and V ∈ Zn is defined for each x ∈ V by V [x] =df M (s ). For
x
example, the marking of the CPN depicted in the figure 2 may be represented as






x<ω/2
sx  0
x+1	x

t1
x−1 x
s1
•

x>0
t2
x
x+1
s2


t4 x<ω

x+1
x
t3
x<ω
x x−1
t5 x>0

Fig. 2. The CPN translation of the PNZ from the figure 1.



t1
t2







t3	t5	t2
Fig. 3. The reachability graph of the CPN from the figure 2 when ω = 6. Each state is labelled by its number, the place in {s1, s2} that is marked and the marking of sx. When ω grows, the left and right parts of the graph, which are connected through the states 6 and 7, become taller while keeping the same structures.
({s1 '→ {•}, s2 '→ ∅}, [0]).
Notice that it could also have been possible to first associate a fresh variable vs to each place s of N , to associate a value m to vs whenever M (s) = m · {•}, to keep a single place with side loops for each transition of N , and to adapt adequately their linear transformations. Indeed, the firing condition of a transition of a P/T net is linear in those new variables, as well as the result of its firing. However, it is generally preferable to keep the original places since the control state of the net has an intuitive meaning and, in many practical systems, the reachable states correspond to safe markings of those places (at most one • in each control place).
A more compact reachability graph
Let N = (S, T, l, L) be a PNZ in an initial state (M0, D0). Its semantics may be captured in a more compact manner by a symbolic state graph, whose nodes are states of the PNZ possibly aggregating infinitely many markings of the CPNs in cpn(N, M0, D0). More precisely, a transition t ∈ T is enabled at a state (M, D) if t is enabled in [N ♩ at M and at least one vector in D satisfies the condition C(t). The firing of t yields a state (M ', D') such that M ' is the marking produced by the

firing of t in [N ♩
built as follows:
and D
df
= L(t)(D). Then, a compacted state graph G may be

(M0, D0) is a node of G;
if (M, D) is a node of G such that (M, D) enables a transition t in N and (M ', D') is the state reachable from (M, D) by the firing of t, then, for D'' =df

∗	'	'
'' df	'

L(t) (D ) if M = M , or D  = D otherwise, we have:
if there is no node (M ', D''') in G such that D'' ⊆ D''', then we add the node (M ', D'') to G and an arc labelled t from (M, D) to (M ', D''),
otherwise, we choose in G an arbitrary node (M ', D''') such that D'' ⊆ D'''
and we add an arc labelled by t from (M, D) to (M ', D''').
Intuitively, if a transition t can fire at (M, D) leading to (M, D'), it means that
''	'' df	∗	'

t can fire (possibly many times) from (M, D
) with D  = L(t) (D ), at least if C

allows it. So, the idea is to aggregate the effect of all the firing sequences obtained by






t1
t5	t4
t4	t5
t5


t3




Fig. 4. A compacted state graph of the PNZ from the figure 1 when 6 ≤ ω < ∞. Each state is labelled by its rank in the construction, the marked place (either s1 or s2) and the set of possible values for x. Notice that the node 5 could have pointed to 6 instead of 1, if 6 was constructed before 5.
t1	t5
t1	t2
t4
t3
Fig. 5. The state graph of the PNZ from the figure 1 when ω is infinite, i.e., when all the conditions involving ω are dropped.


iterating t (there is potentially an infinity of them), considered as a meta-transition, into one symbolic state (M, D''). Because of the application of L(t)∗, a loop arc on (M, D'') labelled by t will always be constructed when the successors of (M, D'') will be computed. On the other hand, if from (M, D) a computed state is (M ', D''), and a state (M ', D'''), with D'' ⊆ D''', is already present in G, then (M ', D'') is covered by (M ', D''') and does not need to be added. It may also happen that a computed state covers some states already present in G (when D''' ⊂ D''). This point will be discussed in section 5.
It should be noted that this construction does not guarantee that G is unique (nor even finite); it may also depend on the order in which nodes and transitions are considered as well as on which D''' is chosen when several are possible. However, this will have no consequence on the desired properties. We denote by G(N, M0, D0) any possible graph built as above. Examples of such state graphs are depicted in figures 4 and 5.
As a state in a graph G = G(N, M0, D0) may aggregate several concrete states, a path starting from (M0, D0) may actually encode several elementary paths. (We will show later on that these elementary paths actually corresponds to traces for the PNZ.) More precisely, for k ≥ 0, let Pk(G) be the set of all the paths of length k in
df	t1	tk
G that start at (M0, D0). Then, if π = (M0, D0) −−−→− ··· −−−−→ (Mk, Dk) is a path in
Pk(G) (possibly reduced to the initial state if k = 0), then we define its unfolding unf(π) as the set of all the elementary paths of length k represented by π, i.e., sequences of transitions between concrete states that can actually be fired. More

precisely, unf(π) comprises all the elementary paths (M ,V ) t1
tk
(M ,V )

0	0 −−−−→ ··· −−−−→	k	k
for all Vi ∈ Di (0 ≤ i ≤ k) and such that L(tj)(Vj−1)= Vj (for 1 ≤ j ≤ k). The set

of elementary paths of length k is given by path (G) =df 

π∈Pk(G)
unf(π). The set of

zero-length elementary paths is thus path0(G)= {(M0,V ) | V ∈ D0}. Finally, the
set of elementary paths of G (which we shall also call the PNZ elementary paths)
is defined as path(G) =df	path (G).
k

It should be noted that there may exists paths in the compacted state graph that do not correspond to any elementary path, i.e., that cannot actually be executed. This is the case for instance in the graph of the figure 5 where the path 0 −−t−1−→ 1 −−t−2−→ 2 −−t−5−→ 2 is unfolded to an empty set (after t1, t2 we have x =0 thus t5 is disabled).
Behavioural equivalence
df	t1	tk
A PNZ elementary path π = (M0, V0) −−−−→ ··· −−−−→ (Mk, Vk) is equivalent to a CPN
df	t' ,ρ1	t' ,ρk
trace π' = (M ' ,V ') −−1−−−→− ··· −−−−−−→− (M ' ,V ') of the same length k, denoted π ∼ π',
0	0	k	k
if M ' = Mi, V ' = Vi and ti = t' for 0 ≤ i ≤ k. A set Π of PNZ elementary paths
i	i	i
is equivalent to a set Π' of CPN traces, denoted Π ∼ Π', if there exists a bijection
β :Π → Π' such that π ∼ β(π) for all π ∈ Π.
Theorem 4.1 Let N be a PNZ in a state (M, D). Then, for any state graph
G = G(N, M, D), we have path(G) ∼ trace(cpn(N, M, D)).
This property is proved by induction on the length of the elementary paths and
df
of the traces. Let NZ be a PNZ in the initial state (M0, D0) and G = G(NZ, M0, D0)
an arbitrary state graph of NZ. Without loss of generality, we assume that D0 is a singleton {V0}. Then, cpn(NZ, M0, D0)= {(NC , (M0, V0))}. By definition of cpn, NZ and NC have the same sets of transitions.
Basic case: k = 0.  By definition, we have path0(G) = {(M0,V ) | V ∈ D0} =
{(M0, V0)} = trace0(NC , (M0, V0)).
Induction hypothesis. Assume pathi(G) ∼ tracei(NC , (M0, V0)), for all i such that 0 ≤ i ≤ k.

Induction step:  k + 1.	It is worth noting that in a trace (M ,V ) t1 ,ρ1
tk,ρk

0	0 −−−−−−→− ··· −−−−−−→−
(Mk, Vk) of a CPN, the bindings ρi are entirely determined by Vi−1 for 1 ≤ i ≤ k: by definition of cpn, in particular how arcs are set, we must have ρi = {x '→ Vi−1[x] |
x ∈ V}. For this reason, we shall not consider the bindings in the following.

(⇒) Let π
df (M ,V ) t1
tk	tk+1
(M ,V )	(M
,V	) be an elemen-

0	0 −−−−→ ··· −−−−→
k	k  −−−−−→−
k+1
k+1

tary path in pathk+1(G). By induction hypothesis, we have a unique trace (M0, V0)
−t−1−−,−−ρ−→−1	···  −t−k−−,−−ρ−→−k	(M ,V ) in trace (N ,M ,V ) that is equivalent to the prefix
k	k	k	C	0	0
(M ,V ) t1	tk	(M ,V ) of π. By definition of cpn, in particular how guards
0	0 −−−−→ ··· −−−−→	k	k
and arcs to the places sx’s are set, since tk+1 can fire in NZ at (Mk, Vk), this is also the case in NC at (Mk, Vk) and its firing produces the corresponding state

(M	,V 
' df
t1,ρ1
tk,ρk
tk+1,ρk+1

k+1
k+1). Thus, π
= (M0, V0) −−−−−−→−
··· −−−−−−→− (Mk, Vk) −−−−−−−−−−−−−−→ (Mk+1, Vk+1)

is a trace in tracek+1(NC, M0, V0), it is unique and π ∼ π'.
(⇐) This may be exhibited essentially by a symmetric argument. 

Reachability equivalence
By theorem 4.1, a state graph is allowed to encode more than the actually reachable markings; indeed, because of the unfolding, only the executable elementary paths are kept. We show now that the state graph contains exactly the actually reachable states, each such state being usually reachable by only a subset of the paths in the graph that lead to it.

.	.	.	.
.	.
B	.
t2	.
E


t3		t4	t7 t5
C	F
t6
=⇒	=⇒


Fig. 6. Left: (M ', D'') is added and covers (M ', D'''). Middle: A and B are connected to the new state. Right: (M ', D''') is removed, then C becomes unreachable and is removed too.
Corollary 4.2 Let N be a PNZ in a state (M0, D0) and a corresponding com- pacted state graph G. For all node (M, D) in G and all V in D, there exists a marked net (N ', (M ',V ')) ∈ cpn(N, M0, D0) such that (M, V ) is reachable in N ' from (M ',V '). Conversely, for all marked net (N ', (M ',V ')) ∈ cpn(N, M0, D0) and all (M, V ) reachable in N ' from (M ',V '), there exists a node (M ', D') in G such that V ' ∈ D'.
(⊆) Holds by construction of G: it creates only states that are actually reached from the initial one, through finite (but possibly iterated) sequences of transitions.
(⊇) By theorem 4.1, equivalent executions lead to equivalent states. 
Implementation issues
We have produced a prototype implementation that computes a compacted state graph for a PNZ. The sets of integer vectors are stored using the NDD structure defined in [1] and implemented in the library Lash [2]. In some cases, our implemen- tation ends up with an error, when a transformation cannot be iterated by Lash (as explained in the introduction, this approach is not complete). Moreover, we cannot guarantee that it will terminate as this is a problem that is undecidable in general. However, sufficient conditions for the termination have been given in [1] and it is left as a future work to study how they could be applied in our setting.
We also implemented an optimisation with respect to the definitions presented above. If an existing state is covered by a newly computed one, the former may be replaced by the latter. It implies that the successors states of the replaced one have to be recomputed, as well as their own successors, and so on. Let (M ', D'') be the new state and (M ', D''') the existing one such that D''' ⊂ D''. For each state (M, D), which is a predecessor of (M ', D''') through an arc labelled by t, we create an arc from (M, D) to (M ', D'') also labelled by t. Then, (M ', D''') is removed, as well as all its successors that become unreachable from the initial node, and so on. This is illustrated in figure 6.
Doing so, we achieve the two expected goals: (M ', D''') is replaced by (M ', D'') and its successors will be recomputed. Indeed, in the figure 6, since C has been removed, a generalisation of it will be generated when the successors of (M ', D'') will be computed. This also holds for F but it could not be removed because it has a predecessor E. If later on we find a generalisation of F as a successor of (M ', D''),





t5
t2
Fig. 7. The state graph after the removing of the covered states: with respect to the graph of the figure 4, the states 1 and 4 have been removed since they are covered by the state 6 and the state 2 has been removed since it is covered by the state 5.
this new node will replace F , and E will be connected to it as just shown.
We also introduced another optimisation: since (M ', D'') generalises (M ', D'''), any execution that led from (M ', D''') to (M ', D'') could be performed again and again: we have discovered a cycle in the state graph. Thus, we can iterate the transformation that created D'' from D'''. In our example, we obtained D'' as L (D''') and also as L (D'''), where 5 L =df L(t ) ◦ L(t ) and L =df L(t ) ◦ L(t ) ◦ L(t3), since two paths exist from (M ', D''') to (M ', D''). It is thus possible to execute a meta-transition that corresponds to the iteration of L1 or L2 or any combination of them applied to D''. Unfortunately, we cannot use (L1 ∨ L2)∗ which is not an operation available on linear transformations. In our implementation, we compute the composition L = L ◦ L and to consider L∗(D'') instead of D'' when replacing (M ', D'''). This is not the only solution but there exist an infinite number of possible combinations of L1 and L2, so we have chosen to consider one of them. The properties of this optimisation should be studied in the future.
It should be stressed that these optimisations do not change the elementary paths encoded by the graph. Indeed, all the elementary paths based on A −−t−1−→ (M ', D''') are now encoded by A −−t−1−→ (M ', D''). Even if D'' has more values than D''', only the values that can actually be computed from A will be used in the elementary paths. Moreover, it is obvious that the optimisations have no impact on the reachability. As a result of these optimisations, we obtain the graph depicted in the figure 7.
Conclusion
We presented here the class of Petri nets with counters (PNZ ) as P/T nets enriched with unbounded (both ends) integer variables on which linear operations may be applied. The semantics of a PNZ is given by that of a family of coloured Petri nets that implement the integer variables as integer marked places. We have presented a compact state graph construction allowing to aggregate many reachable markings (possibly infinitely many) into a single state. This graph has been proved to preserve the trace semantics and to encode exactly the set of reachable markings. Finally, we introduced optimisations allowing to produce even more compact state graphs. Our next step will be a series of case studies in order to show that, even if not complete, this approach is usable and efficient in practice; in particular for systems with finite but large state spaces. Our first experiments show that it is the case for instance for the nets with causal time [5], even when we consider unbounded

5 Notice that, when we chain linear transformations, we not only have to compose their updates, but also their conditions; fortunately, both remain linear.

counters.
Future works should study the question of the termination of the construction, which is directly related to knowing whether a state graph is finite or not. Moreover, we should study carefully the optimisation introduced in the section 5 that execute a meta-transition when a cycle is discovered in the state graph. The theorem 4.1 being independent on the choice of the considered state graph G, it may also be possible during the construction of G to use adequate conditions that lead to smaller graphs. Another interesting work will be to generalise our approach to the other data structures defined in [1]: subsets of Rn and unbounded FIFO queues of integers.

References
B. Boigelot. Symbolic Methods for Exploring Infinite State Spaces. PhD Thesis, Univ. of Li`ege, 1999.
B.	Boigelot.	The	Li`ege	Automata-based	Symbolic	Handler.
http://www.montefiore.ulg.ac.be/~boigelot/research/lash/
G. Geeraerts. Coverability and Expressiveness Properties of Well-structured Transition Systems. PhD thesis, Universit´e Libre de Bruxelles, 2007.
K. Jensen. Coloured Petri nets. basic concepts, analysis methods and practical use. EATCS Monographs on Theoretical Computer Science, 1. Springer, 1992.
F. Pommereau. Causal time calculus. FORMATS’03, LNCS 2791, Springer, 2004
W. Reisig. Petri nets. EATCS Monographs on Theoretical Computer Science. Springer, 1985.
