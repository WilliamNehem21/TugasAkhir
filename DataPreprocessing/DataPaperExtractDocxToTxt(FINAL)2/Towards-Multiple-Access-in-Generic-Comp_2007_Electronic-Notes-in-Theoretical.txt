Electronic Notes in Theoretical Computer Science 176 (2007) 25–45	
www.elsevier.com/locate/entcs

Towards Multiple Access in Generic Component Architectures1
M. Klein, J. Padberg2
Institut fu¨r Softwaretechnik und Theoretische Informatik, Technische Universita¨t Berlin, Germany
F. Orejas3
Departament de Llenguatges i Sistemes Informa`tics, Universitat Polit`ecnica de Catalunya, Barcelona, Spain

Abstract
The paper introduces an abstract framework for the specification of components with multiple require and provide interfaces that allows the specification of multiple access to a single provide interface. This framework can be regarded as a generalization of abstract hierarchical and connector-based component specification approaches. The main ideas are clarified in a sample specification, a component architecture for a web browser suite. For this, elementary nets are applied and are shown to be an instantiation of the abstract framework.
Keywords: Component Architectures, Reduction Semantics


Introduction
By now component-based software development is becoming nearly a standard in large scale software engineering (see e.g. [21,22,33,34]), for several reasons: For ex- ample, components implemented once can easily be integrated in other projects requiring the same functionalities. It is possible to buy components with explic- itly defined interfaces, thus, time pressure in the development of software projects can be relaxed by paying for a piece of code that is quickly integrated into the project. Changes of a component body, or even a full exchange, can be processed encapsulated, i.e. with no effects for the component’s environment as long as the

1 Acknowledgment: This work is partially supported by the TMR network SEGRAVIS.
2 Email: [klein, padberg]@cs.tu-berlin.de
3 Email: orejas@lsi.upc.edu

1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2006.02.030

corresponding interfaces are preserved. See [24] for a survey of component-based software engineering.
But despite the wide acceptance of component-based software development ap- proaches, there is still a lack of specification techniques suited for component-based design. Especially the application of formal specification techniques is hardly sup- ported in a continuous fashion that comprises components and composition as well as the architecture. But whenever it is important to verify or to check the correct- ness of an implementation with respect to a specification, e.g. in the case of security relevant software, formal techniques equipped with a mathematical semantics have strong advantages compared to less formal techniques.
In [20] D. Garlan lists convincing arguments for the use of formal techniques ar- chitecture description languages. In [31] a survey (in German) over the use of formal techniques for the description of software architectures is given. Exemplarily stated there are: Process algebras are used for various architecture description languages,
e.g. Darwin [27,28], Wright [2,3] or AEmilia [4], but none of these specifies
the component itself. SARA [17] is an early architecture description language using Petri nets for the description of the operational behavior. In [9,10] dualistic Petri nets are proposed. These describe the architecture using abstract representations of parallel process objects. In ZCL [11] is based on Z [36] a set-theoretic specification language. Z schemes are used to describe the architecture structure as well as the dynamic changes. CommUnity [18] and COOL [23] are architecture description languages that are founded on graph transformations. But in COOL no explicit component specification is given.
But there are only a few other approaches with the aim to combine component- based architectures and formal specification techniques in order to have a contin- uous formal technique. Those examine only a particular specification technique in contrast to our generic approach. E.g. [7] uses the integrated formal specification technique Korrigan to specify components and their composition. CommUnity [8,19] is a prototype language for architectural modeling that is founded on graph transformations.
In [13] a transformation-based hierarchical component concept that is generic with respect to the used specification technique and the applied transformation no- tion, has been presented. This first step to close the gap between formal specification techniques and real life component architectures has been followed by another con- cept using generic specifications and transformations. In [16,12] connector-based architectures have been introduced to enable the specification of components with multiple provide interfaces that are coordinated by connectors with several require specifications. Both approaches have been successfully instantiated to a variety of specification techniques [14,15]. In this paper a new, even more general approach is introduced which allows the specification of components with several require and provide interfaces, where require interfaces correspond to import interfaces and pro- vide interfaces correspond to export interfaces in the previous transformation-based approaches.
Even more important, the approach allows the connection of different require-



Fig. 1. Sample Architecture Using Multiple Access
ment specifications of one or more components with the same provide specification. This is a very common scenario in a software developing process. Fig. 1 shows a small architecture containing a web browser, a mail program, a text editor, and a file browser that is accessed by both, the web browser and the mail program. In Sect. 2 it is shown that both accesses operate on the same provide specification and how this is handled within the new approach.
As the above mentioned generic transformation-based approaches, this paper concentrates on a static view of architectures. See Sect. 5 for a discussion of possible extensions handling dynamic architectures. Since the main motivation for a formal approach to component architectures is to enable verification and model checking, it is necessary to calculate the common specification for a given set of component specifications, i.e. the given architecture. This process, explained in detail in Sect. 3, is suitable for many specification techniques and application scenarios.

Example: Web Browser Suite
In this section the sample architecture shown in Fig. 1 is explained in detail. We use elementary nets as specification technique. In Sect. 4 we sketch the formal instantiation of our generic framework to this technique.


COMP WB
¸¸¸¸¸¸¸
COMP ¸M¸¸
¸¸¸¸¸

¸¸¸¸¸ z cz	¸¸¸¸¸ z 
COMP FB	COMP TE
Fig. 2. Architecture Graph of Web Browser Suite
Each component, in general and in the example, consists of a body and a set of provide and require specifications.	E.g. the component web browser is
given by COMP WB = (REQ WB → BOD WB ⇐ PRV WB ) where REQ WB
specifies the require interface, BOD WB the body and PRV WB the provide in-
terface. Each of these specifications is given an elementary net. Fig. 2 shows the architecture graph that is the components and their connection. The more detailed illustration in Fig. 7 shows all specifications of the example’s components and all
chitecture is given by I = {WB, M , FB , TE }, which is the set of abbreviations for connecting transformations and embeddings. The component index set of the ar- the component names: Web Browser, Mail, File Browser, Text Editor.

The specification of the web browser component as shown in Fig. 3 contains two provide and a single require interface. The provide interfaces of the web browser component state that this component initially is in a state called idle and two different events can occur: the simple loading of a web page (load page) or loading and storing a file to disk. Both events lead to the same state, the idle state.
The provide specification nets are refined by the component’s body net. The place idle (expressing the initial state of the component) and the load page transi- tion remain unchanged. The download and store transition is replaced by a subnet containing the three places controld, wait and file, and the transitions store file, download! and browse file. This subnet models that after each occurrence of the download! event the user has to start a file browser to determine the storage area and the save name of the file. After this selection, the actual download and the file saving are executed. The place controld ensures that the selected file is the result of the started browsing process. This file browsing process and the related places are in the component’s only require specification.
The component COMP WB also contains the connections between its provide and require interfaces and the body. For the case of the require interfaces, the corresponding embeddings are quite obvious, and thus omitted. In Fig. 4 the provide interface and the body of component COMP WB are connected. The only place of the provide interfaces is mapped to the same place in the body net. Since the transition load page remains unchanged in the body, it is mapped to the subnet containing the transition load page and the only place connected to the transition. The transition download and store is mapped to a net containing the whole body except the transition load page.
The specification of the mailer component is depicted in Fig. 5. Besides a body net it contains a single provide interface and two require interfaces. Initially the provide interface of this component allows two events: read mails and write mail. After a mail has been written, the net is enabled to send this message.  Both,

Fig. 3. Web Browser Component



















Fig. 4. Transformation prv WB


























Fig. 5. Mailer Component

the send mail and the read mails transitions lead to the initial state, specified by a marking on place ready.
In the body net of the component the process of writing a mail is refined. First, the mailer starts a text editor which is then used to write the content of the email. Afterwards, the user is enabled to send the mail or to attach a file to it. The latter includes the browsing of a suiting file. Both, the creation of the email content and the browsing of an attachment, are to be provided by the component’s environment.


	
Fig. 6. File Browser and Text Editor Component
This is expressed by the occurrence of the two transitions in the require interfaces.
Fig. 6 shows the components file browser and text editor. Both do not contain a require interface. The simple file browser is specified by only two transitions that offer to change the directory and to select finally the file. The text editor body is specified by three transitions, expressing the possibilities of writing a character, deleting a character and to finally export the written text.


PRV WB
prv WB
cz
PRV M
prv M
cz

BOD,W,B	BOD,M,¸¸¸
¸¸re¸q Mrm2

req WB 
REQ WB
conWB ,FB
req Mrm1
REQ Mrm1
conM ,rm1 ,FB

cz zPR V FB
prv FB
cz
¸¸¸¸¸
REQ Mrm2
conM ,rm2 ,TE
czPRV
prv TE
cz

BOD FB	BOD TE
Fig. 7. Detailed Architecture of the Web Browser Suite
Fig. 7 illustrates the architecture diagram of the web browser suite. It involves all specifications, transformations, and embeddings, but it disregards all the spe- cific elementary nets given in Figures 3-6. The abstraction of this diagram is the architecture graph in Fig. 2.
In this sample architecture all but one connecting transformation are identity transformations, i.e. we have equality of the corresponding require and provide interfaces. The transformation conM ,rm2,TE shown in Fig. 8 is different, since it actually applies the possibility to rename places along transformations of marked elementary nets. In general, our framework offers the possibility to connect require and provide interfaces by refining transformations. For the case of elementary nets this includes the possibility to replace transitions by subnets.
Since the main motivation for applying formal techniques to software engineering is verification we need to construct from the given components a single specification

REQ_Mrm2


ready_to_send


edit_ready



con M,rm2,TE,P

PRV_TE
con M,rm2,TE,T
con M,rm2,TE,P


edit_ready	text
create_text

Fig. 8. Transformation conM ,rm2 ,TE

that can be verified with the corresponding tools of that specification technique. In the next section we define how components can be composed to larger ones. In the case of our sample architecture, the repeated application of the composition operation yields a component that contains the whole behavior of the browser suite. Fig. 9 shows the body of the resulting component.

idle	ready
Fig. 9. Body of Composed Browser Suite

After having derived the complete specification, we now can start verification or model checking, respectively, with respect to a given requirement specification, but this is not within the scope of this paper.

The Generic Framework
One central aim of this work is to define generic notions of components and com- position operations capable of handling multiple access scenarios, as shown in the example of the previous section. As the approaches [13] and [16,12] this work applies generic specifications, embeddings and transformations to form components. Since not all classes of embeddings and transformations are suitable for this purpose we have to state some general requirements first. The validity of these requirements needs to be proven in the concrete specification technique when instantiating the generic concept.

General Requirements
Our generic technique requires a defined class of specifications, corresponding trans- formations and embeddings. Since the transformations are used in the framework to establish the connection between provide interfaces and the actual component specification, the component body, it is sensible to assume that the transformations define a class of refinements for the specifications. Since there exist so many notions of refinement, even for single specification techniques, this assumption should not be further formalized at the abstract level - but it has to be clarified when the concept is instantiated. In Sect. 2 we applied a refinement notion for elementary nets that allows mapping single transitions to whole subnets (see Sect. 4 for details).
For both, the transformations and the embeddings, we require a composition operation and a special identity instance. Moreover, it is necessary that the class of embeddings defines a subclass of the transformations, i.e. we require a mapping
trafo : EMB → TRAFO that selects a transformation for each embedding.
The extension property defined below is well-known from [12] and [13]. It states
that a single transition can be applied to a larger context.

Definition 3.1 Extension  Property  Given an embedding e : SPEC R → SPEC and a transformation t : SPEC R =⇒ SPEC '. Now there is a selected transformation t' : SPEC =⇒ SPEC' and a selected embedding e' : SPEC R'
→ SPEC ', such that diagram (1) in Fig. 10 becomes an extension diagram. In case
of t also being an embedding, we require the existence of a unique extension diagram
(2), called mutual extension diagram.
SPEC R   e	 SP EC	SPEC R   e	 SP EC
t	(1)	t '	t	(2)	t '
cz' 	  cz'	J  ' 	  J '

SPEC R	e'
SPEC
SPEC R	e'
SPEC

Fig. 10. Extension

The multiple extension defined below expresses the possibility to apply a set of transformations to a larger context within a single transformation. It differs from the parallel extension used in [16] and [12] by allowing given transformations with the same codomain only, and it contains the extension defined above as a special case. In general, this construction is not available for all families of embeddings and corresponding transformations. Intuitively, such families allow multiple extension, if the boundary of all embeddings is preserved i.e. the transformations do not delete or rewrite parts that are needed to maintain a well-formed specification, and all overlappings with respect to the embeddings are transformed uniquely.
ily of embeddings e = (ei : SPEC Ri → SPEC )i∈I and a family of transformations Definition 3.2 Multiple Extension Given an index set I, a corresponding fam- tr = (tri : SPEC Ri =⇒ SPEC R)i∈I . Now e and tr allow multiple extension, if there exist a selected transformation t : SPEC =⇒ SPEC ' and a single embedding e' : SPEC R → SPEC '. We call diagram (1i)i∈I multiple extension diagram.

SPEC R  ei	 SP EC

tri
(1i)i∈I	t

cz 	  cz'
SPEC R e'	SPEC
Fig. 11. Multiple Extension

family of embeddings (ei : SPEC Ri → SPEC )i∈I is compatible with multiple ex- Definition 3.3 Compatibility of Embeddings with Multiple Extension A tions (tri : SPEC Ri =⇒ SPEC R)i∈C ⊆I , we have for the family of embeddings tension, if for each multiple extension diagram (1) with a family of transforma-
(ej : SPEC Rj → SPEC )j ∈I \C a selected family of embeddings (e' : SPEC Rj →

SPEC ')j ∈I \C .

SPEC Ri

 ei	 SP EC ¸,ej


SPEC Rj

(2)
.....

tri
(1)
t	...e'

cz 	  cz .s. j
SPEC R e'	SPEC '
Fig. 12. Compatibility of Embeddings


We require the existence of a subclass D of all families of embeddings such that all elements in this subclass are compatible with multiple exten- sion.  Moreover, we require that D is closed under multiple extensions.  I.e.
if (ei : SPEC Ri → SPEC )i∈I in Fig. 12 is in class D and (1) is an extension

diagram and we have embeddings e'
then also (e' : SPEC Rj → SPEC ')j ∈I \C ∪

{e' : SPEC R → SPEC '} is in class D. In the corresponding instantiation this can
be achieved by defining D by non-overlapping embeddings. Note that the instan-
tiation has to define which transformations and embeddings make up a multiple extension diagram.
diagrams: Given diagrams (1), (2), (3) in Fig. 13 with i ∈ I and j ∈ J . Now Moreover, we assume horizontal and vertical composition of multiple extension (1+3) and (2+3) have to be multiple extension diagrams if (1) and (2) are multiple
extension diagrams and (3) is an extension diagram.
SPEC R  eri	 SP EC
tri	(1)	t

SPEC Cj
 ecj 	cz
SPEC R
er'	  cz'

trj
cz
(2)
ec'
t'	(3)
cz er ''
t''
cz

SPEC C
j  SP EC R'
 SP EC ''

Fig. 13. Composition of Extension Diagrams

Components and Composition
Based on the requirements explained above, we are now able to define component specifications and the corresponding composition operation.
Definition 3.4 Component  A  component  specification  COMP = (BOD , REQ , PRV , req , prv ) consists of a body specification BOD , a family of re- quire specifications REQ = (REQi )i∈I  for some index set I ,  a family of
families of embeddings req = (reqi : REQi → BOD )i∈I and transformations provide specifications PRV = (PRVj )j ∈J for some index set J and of suiting prv = (prvj : PRV =⇒ BOD )j ∈J , respectively, where we require that the family of
embeddings is in class D and thus compatible with multiple extension in the sense
of Def. 3.3.
Note that the components in our example in Sect. 2 fit into this abstract defi- nition. The web browser component in Fig. 3 contains two provide specifications, a body specification and a single require specification. The corresponding transfor- mations of the provide interfaces are shown in Fig. 4.
Next, we summarize the conditions ensuring that a given set of connected components can be reduced to a single component.  According to [16,12] we call such a set an architecture.  An architecture A is a set of compo- nents COMPS (A)= (COMP i )i∈I and corresponding connecting transformations
CONS (A) that fulfill the properties listed below. Each architecture A can be illus-
trated by an architecture graph GA (e.g. as for the web browser suite in Fig. 2), obtained by shrinking A to a graph representation that contains nodes labeled by the component names and edges labeled by the connecting transformations.
There are no isolated components in the architecture.
Each requirement specification is the source of at most one connecting transfor- mation.
For each component we require that its embedding of the require interfaces and the connected realizing transformations allow multiple extension.
(i.e. (prv 2y ◦ con1,j ,2,y )j ∈I 1 ,y ∈J C2 ,con1 ,j ,2 ∈CONS (A) allow multiple extension)
There are no cycles in the graph obtained by representing single specifications by
nodes and transformations and embeddings by non-directed edges.
In [16,12] it has been shown that architectures can be reduced to a single com- ponent, if the applied composition operations yield unique results independing of their application order. This is the case for the operations defined below.
The hierarchical composition with multiple interfaces defined below connects a single providing component to a single requiring component, possibly via differ- ent provide and require interfaces. Intuitively, the requiring component is glued with the providing component over the provide interfaces accessed by the requiring component.
Definition 3.5 Hierarchical Composition with Multiple Interfaces
Given	a	requiring	component	COMP R = (BOD R, REQ R, PRV R, req R,

prv R) and a providing component COMP P = (BOD P, REQ P, PRV P, req P, prv P ) with index sets I R, J R and I P, J P for the require and provide interfaces of the requiring component and the providing component, respectively. We denote the index set of the require interfaces actually connected with the
PRV Rj


REQ R
prv Rj
 req Ri   cz¸req,Rz REQ R



PRV Px

¸¸
i
coni
cz
Pl (i )
BOD R

xcon'
z
ccc
ccc
ccc
cc req R'



¸¸¸¸prv P
(1i)
c

¸¸¸ x
prv Pl (i)	cc

¸¸¸ z_cz	'	cc c

REQ Py
 req Py  BO D P  req R   c zj


Fig. 14. Hierarchical Composition with Multiple Requirements

providing component by C R ⊆ I R. Given corresponding connecting transfor- mations con = coni : REQ Ri =⇒ PRV Pl (i ) with i ∈ C R ⊆ I R and l (i ) ∈ J P , mations xconi = (prv Pl(i) ◦ coni )i∈C R allow multiple extension. The mapping such that the family of embeddings req R and the family of composed transfor- l : I R → J P has to be injective. The index sets of all components are dis- joint.  In the first step we can derive a multiple extension diagram (1i )i∈C R

with selected transformation xcon' and embedding req R'. The compatibility of the embeddings (req Ri )i∈I with respect to multiple extension, which is given by the component definition, yields a set of embeddings (req R' )z∈I R\C R, such that
(req R' )z∈I R\C R ∪ {req R'} is again in class D and thus compatible with respect
to multiple extension. Now we define the result of the Hierarchical Composition
with Multiple Interfaces (short: composition) by
COMP R ◦con COMP P =
COMP G = (BOD G, REQ G, PRV G, req G, prv G),

defined as I G = (I R \ C R) ∪ I P and J G = J R ∪ J P , respectively. And we where the index sets of the requirements and provisions of the new component are have:
REQ G = (REQ Rz )z∈I R\C R ∪ REQ P
req G = (req R' )z ∈I R\C R ∪ (req R' ◦ req Py )y∈I R
PRV G = PRV R ∪ PRV P
prv G = (xcon' ◦ prv Pj )j ∈J R ∪ (trafo(req R') ◦ prv Px )x∈J P
Note that the family of embeddings (req Gi )i∈I G is again in class D. In Fig. 15
the elements of the resulting component are depicted in detail.

PRV Rj



PRV P¸x

PRV Pl(i)

xcon'◦prv Rj
REQ Rz

¸¸¸¸¸p¸rv Px
....

¸¸¸¸¸
prv Pl (i)
....	'

¸¸ z_cz req R'
cz ..sreq Rz

 req Py 			.
y	BOD P 	 BO¸D G
trafo(req R')
Fig. 15. Result of Composition































Fig. 16. Composition of Mailer and Text Editor

Since we allow different components accessing the same provide interface, all provide interfaces are preserved by the composition.
Fig. 16 shows the composition of the mailer and the text editor component of our example from Sect. 2. Note that only the transformations prv TE , conM ,rm2,TE and the embedding req Mrm2 are shown in detail.
The hierarchical composition with multiple interfaces is independent of its appli- cation order. Since there are three possibilities of overlappings for two composition steps, we present three different theorems: associativity of composition, compati- bility of composition I and II.

Whenever we have two connections crossing the same level of a given component architecture, we also offer a parallel composition, which constructs the result of two compositions within a single step. This is the case in the Theorems 3.8 and 3.9.
COMP 1
con 1
cz
COMP 2
con 2
cz
COMP 3
Fig. 17. Architecture Graph GA1


COMP i = (BOD i , REQ i , PRV i , req i , prv i ) for i ∈ {1, 2, 3} as shown in Theorem 3.6 Associativity  of  Composition  Given  three  components the architecture graph GA1 and families of transformations con 1 = (con 1i :
REQ 1i =⇒ PRV 2l (i ))i∈C 1 , con 2 = (con 2k : REQ 2k ⇒ PRV 3l (k ))k∈C 2 , for some C 1 ⊆ I 1,C 2 ⊆ I 2, where I 1 and I 2 denote the index sets of the (prv 2l (i ) ◦ con 1i )i∈C 1 , req 1 and (prv 3l (k ) ◦ con 2k )k∈C 2 , req 2 allow multiple require interfaces of COMP 1 and COMP 2 , such that the pairs of families
extension, each. Then we have the following associativity law:
(COMP 1 ◦con 1 COMP 2 ) ◦con 2 COMP 3 =
COMP 1 ◦con 1 (COMP 2 ◦con 2 COMP 3 )
Proof. Fig. 18 shows the given components and connecting transformations in
detail, where we have:
j ∈ J 1,	l 1: C 1 → J 2 injective,
i ∈ C 1 ⊆ I 1,	k ∈ C 2 ⊆ I 2,
i' ∈ I \ C 1,	k' ∈ I 2 \ C 2, and
j' ∈ J 2 \ l(C 1),	m ∈ I 3,x ∈ J 3.
We are able to construct the multiple extension diagrams (1) and (2) due to
the assumptions. The extension diagram (3) exists, because there are no prop-
(COMP1 ◦con 1 COMP 2 ) ◦con 2 COMP 3 , is constructed by the following steps: erties required for this construction. The body of the left side of our equation, First, we have to construct extension diagram (1) to resolve con 1 . We know that
(2) and (3) are multiple extension diagrams, thus we can construct (2+3) and re- solve con 2 . For the construction of the body of the left side of our equation,
COMP 1 ◦con 1 (COMP 2 ◦con 2 COMP 3 ), the first step is to resolve con 2 us- ing multiple extension diagram (2), and afterwards resolving con 1 by multiple





REQ 1i
PRV 1j
prv 1j
 req 1i   cz¸re,q 1i'



REQ 1i'


REQ 2k' ¸	PRV 2j'
con 1i
cz
PRV 2l 1(i)


(1)

¸¸¸¸¸¸¸¸¸
¸¸¸¸¸prv 2 '

¸¸¸¸¸¸
¸¸¸¸ j
prv 2l(i)

REQ 2k
¸¸¸¸¸¸¸¸¸¸
 B OD 2	 B OD 12


PRV 3
¸¸¸¸¸¸¸¸¸
con 2k
cz
PRV 3l 2(k)

(2)

(3)

¸¸¸¸¸¸¸
z cz
cz	cz

REQ 3m req 3m B OD 3	 B OD 23	 B OD 123

Fig. 18. Associativity of Composition
extension diagram (1+3). Since extension yields unique resulting specifications and transformations, we obtain a unique body BOD 123 .	 

Compatibility of Composition
In order to ensure a unique reduction of architectures we need to prove that for all kinds of overlappings of components the result of several composition steps is independent of the order of the composition steps. In Thm. 3.6 this was shown for overlappings along an hierarchy. This section deals with composition steps that include overlappings of components of the same hierarchical level. Fig. 19 shows such an architecture. For this case, the result of the given compositions can be constructed within one parallel step. We can prove that the result of this parallel composition is equal to the sequential composition independent of the ordering.


COMP 1
¸¸¸¸c¸on 1
¸¸¸¸¸
COMP 2
con 2,,,,,
,,,,,,

¸ z  ¸,, 
COMP 3
Fig. 19. Architecture Graph GA2

(BOD i , REQ i , PRV i , req i , prv i ) for i ∈ {1, 2, 3} and families of trans- Definition 3.7 Parallel Composition Given three components COMP i = formations con 1 = (con 1i : REQ 1i =⇒ PRV 3l(i))i∈C 1 ,  con 2 = (con 2k : REQ 2k =⇒ PRV 3l (k ))k∈C 2 , for some C 1 ⊆ I 1,C 2 ⊆ I 2, such that the pairs (prv 3l(i) ◦ con 1i )i∈C 1 , req 1 and (prv 3l(k)◦ con 2k )k∈C 2 , req 2 allow multiple extension, each. Then we construct the multiple extension diagrams (1) and (2)

in Fig. 20. Diagram (3) is constructed as mutual extension diagram, including the resulting body BOD 123 . The result of the parallel composition is given by
(COMP 1 , COMP 2 ) ◦(con 1 ,con 2 ) COMP 3 =
COMP 123 = (REQ 123 , PRV 123 , req 123 , prv 123 ),
where
REQ 123 = (REQ 1i' )i ' ∈I 1 \C 1 ∪ (REQ 2k' )k ' ∈I 2 \C 2 ,
req 123 = (req 2 '' ◦ req 1 ' )i' ∈I 1 \C 1 ∪ (req 1 '' ◦ req 2 ' )k' ∈I 2 \C 2 ,
i '	k '
PRV 123 = (PRV 1j )j ∈J 1 ∪ (PRV 2j ' )j '∈J 2 ∪ (PRV 3x )x∈J 3 ,
prv 123 = (trafo(req 2 '') ◦ xcon 1 ' ◦ prv 1j )j ∈J 1 ∪
(trafo(req 1 '') ◦ xcon 2 ' ◦ prv 2j ' )j ' ∈J 2 ∪ (prv 3x )x∈J 3 .

PRV 1j
prv 1j
REQ 1 '   cz¸,REQ 1


REQ 2
PRV 2j '
prv 2 '
	  cz¸R,EQ 2 '

i	BOD 1

(1)
i
con 1i
cz

con 2k
k
(2)
cz
BOD 2	k

PRV 3l (i )
¸¸¸¸¸¸
PRV 3x
prv 3x
PRV 3l2 (k )
....
req 2'
k

prv 3 ¸¸¸¸¸¸¸¸¸
......

z cz
l1 (i)  ¸¸
....prv 3l2 (k )



BOD 13 ¸,	
zc˛ zs	  cz,c

¸¸¸¸¸ req 1 '
BOD 3
req 2 '
BOD 23
,,,

¸¸¸¸
,
,,,,

req 2¸''¸¸¸¸¸
(3)
,,,,,,  ''

¸¸z_
_,,.,
req 1

BOD 123

Fig. 20. Parallel Composition

Theorem 3.8 Compatibility of Composition I Given the same components and connecting transformations as in the deﬁnition above, then we have the following compatibility law:
COMP 1 ◦con 1 (COMP 2 ◦con 2 COMP 3 )= 
COMP 2 ◦con 2 (COMP 1 ◦con 1 COMP 3 )= (COMP 1 , COMP 2 ) ◦(con 1 ,con 2 ) COMP 3
The web browser suite presented in Sect. 2 involves such a situation: The web browser component and the mailer component access the file browser component, as shown in Figures 2 and 7.

Proof. Fig. 20 shows the given setting in detail, where the mappings l1 : I 1 → J 3 and l2 : I 2 → J 3 are injective each, but their codomains are not assumed to be disjoint. First, we construct the result of the parallel composition that resolves
both connection in a single step. In this case, we start by computing the multiple extension diagrams (1) and (2), which exist due to the assumption of multiple ex-
tension for prv 3l1 (i ) ◦ con 1i and req 1 as well as for prv 3l2 (k ) ◦ con 1k and req 2 . Diagram (3) is constructed as mutual extension diagram including the resulting
body BOD 123 . In case of processing only the composition along con 2 in the first


REQ 1  req 1i  BO D 1
con 1i
REQ 2  req 2k  BO D 2
con 2k

cz
PRV 3l1 (i )
trafo(req 1 ')◦prv 3l (i)
(1')
cz
PRV 3l2 (k )
trafo(req 2 ')◦prv 3l (k )
(2')

cz req 1 ''	cz	cz req 2 ''	cz
BOD 23 	 BO D 231	BOD 13 	 BO D 132

Fig. 21. Stepwise Composition

place, we obtain the extension diagram (2). Afterwards we construct the multiple extension diagram (1’) as depicted in Fig. 21. This diagram is constructed from the same given transformations and embeddings as diagram (1+3) in the case of the parallel composition explained above. This implies BOD 231 = BOD 123 .
Analogously we construct BOD 13 in the multiple extension diagram (1). Then we construct the extension diagram (2’) which is equal to (2+3) in the parallel composition. This implies BOD 132 = BOD 123 = BOD 231 . Additionally, in all three cases we obtain the same families of provide and require interfaces and the corresponding connections, because the disjoint index sets of the given components imply independence of the composition order.	 


COMP¸1¸

con 1,,,,,
,
¸,, 
¸¸¸¸c¸on 2
¸¸¸¸¸ z 

COMP 2	COMP 3
Fig. 22. Architecture Graph GA3



COMP i = (BOD i , REQ i , PRV i , req i , prv i ) for i ∈ {1, 2, 3} and fami- Theorem 3.9 Compatibility  of  Composition  II  Given three components lies of transformations con 1 = (con 1i : REQ 1i =⇒ PRV 2l (i ))i∈C 1 , con 2 = (con 2k : REQ 1k =⇒ PRV 3l(k))k∈C 2 , for some C 1 , C2 ⊆ I 1 such that the pairs (prv 2l (i ) ◦ con 1i )i∈C 1 , req 1 and (prv 3l (k ) ◦ con 2k )k∈C 2 , req 1 allow

multiple extension, each. Then we have the following compatibility law:
(COMP1 ◦con 1 COMP 2 ) ◦con 2 COMP 3 =
(COMP 1 ◦con 1 COMP 3 ) ◦con 2 COMP 2 )= 
COMP 1 ◦(con 1,con 2) (COMP 2 , COMP 3 )
In our example in Sect. 2 this situation occurs as well. Figures 2 and 7 show
that the mailer component accesses both, the file browser component and the text editor component.
A full proof of the theorem is given in [26]. Here, we only sketch its main idea. In [16] the parallel extension diagram was introduced that embeds independent transformations into a common larger context. Moreover, it offers a special case with all but one given transformation being identities. This is also the case here, because the require interfaces of COMP 1 are disjoint. Composing those diagrams yields the intended uniqueness of the body construction.

Instantiation to Elementary Nets
In this section we show that the specification technique of elementary nets [35] fits into our generic framework. This includes the definition of embeddings and transformations, and based on that, the construction of the multiple extensions.
The hierarchic transformation-based concept in [13] and the connector compo- nent framework in [16] have been instantiated with a variety of specification tech- niques: HLR-systems and algebraic specifications in [25], Petri nets in [15] and UML diagrams in [12]. Since our approach is a generalization of those two concepts the instantiations can be easily adopted to the new concept.
Elementary transition systems are a special notion of Petri nets, allowing only arcs and place weights of arity one. We use the algebraic notion of Petri nets as given in [29] and extend it by the initial marking. This enables us to use a set based representation of the pre and post functions of the transitions of the nets.
of transitions T . The functions pre, post : T → P(P ) represent the connecting arcs, An elementary net N = (P, T, pre, post, m) consists of a set of places P and a set and the set m ⊆ P contains all initially marked places. Plain morphismsf : N1 → N2 between elementary nets are mappings of places fP : P1 → P2 and of transitions fT : T1 → T2 that are compatible with the pre and post , i.e. fP ◦ pre1(t) = pre2 ◦ fT (t) and analogously for post . The mapping has to preserve and reflect the initial marking, i.e. fP (m1) ⊆ m2 and m2 \ fP (m1) ⊆ P2 \ fP (P1). This category ENplain has pushouts.
Embeddings are injective morphisms. The following notion of transformation of elementary nets is an adaption of the substitution morphisms of place/transition nets in [30]. These morphisms replace transitions of the original net by whole subnets in the target net and map places injectively. Again, the markings are preserved and reflected. More precisely, a substitution morphism s = (sP , sT ) : 

N1 → N2 with Ni = (Pi, Ti, prei, posti, mi) for (i = 1, 2) is given by an injective mapping of places sP : P1 → P2 and a mapping sT : T1 → P(N2) with sT (t) :=
Nt = (P t,T t, pre2, post2, m2) ⊆ N2 where pre2, post2 and m2 are restricted to the
2	2	2
subset of transitions T t and the subset of places Pt. Again we have preservation and
2	2
reflection of the marked places, i.e. sP (m1) ⊆ m2 and m2 \ sP (m1) ⊆ P2 \ sP (P1).
Composition is well-defined analogously to [30]. So, we have the category EN .
Similar to [30] plain morphisms are a special case of substitution morphisms.
We have the extension properties as required in Def. 3.1, because there are in the category EN pushouts of embeddings with substitution morphisms as well as pushouts of plain morphisms only. The abstract framework requires a class D with compatibility of embeddings with multiple extension (see Def 3.3). For this
instantiation with elementary nets a family of embeddings ei : Ni → N has no
overlappings, if the codomain of the embeddings ei(Ni) are pairwise disjoint.
Then we have multiple extension as required in Def. 3.2. Basically we glue N R with N together by replacing the embeddings of N Ri by their substitution subnets tri(N Ri) in N R. In the detailed proof [26] we have given the construction in categorical terms, based on the following diagram in EN :
N Ri  ei	 N 

tri
(i)
tcri

cz	 cz

N R	'
 N^  eb
 N˜  ee
 N '

ei	i	i
First, we construct i pushout diagrams (i). Next we construct the star-pushout

N Ri
e'
−→i
^	ebi
i −→
N˜ and subsequently the star-coequalizer N
ebi◦tcri ˜
=⇒
e
−→ N .

Then we have the unique e' = e˜◦ e^i ◦ e' and the unique tr = e˜◦ e^i ◦ t^r
We show in

i	i
[26] that this star-coequalizer exists and that e' is a well-defined embedding.
have for families of embeddings (ei : Ni → N )i∈I that have no overlappings, because Compatibility of embeddings with multiple extension as required in Def. 3.3 we the pushout and coequalizer constructions leave those parts that are not in the
codomain (ei(N  Ri))i∈C⊆I unchanged, especially the codomain of (ej(N  Rj))j∈I\C .

Hence there is the family of embeddings (e'
: N Rj → N ')j∈I\C that remains non-

overlapping, see [26].

N Ri  ei	 N ¸,


N Rj

tri
(i)
tcri	j

cz	 cz	J 

N R	'
 N^  eb
 N˜   ee
 N '

ei	i	i
Conclusion
In this paper we present a generic component concept capable of handling multiple provide and require interfaces and multiple access. This includes the definition of generic components and a hierarchical composition operation for multiple interfaces.

Moreover, we introduce the concurrent application of composition steps, called par- allel composition. Based on that we prove the result of two overlapping composition steps to be independent of the construction ordering. This induces that the given reduction semantics of architectures is unique. The generic concept is instantiated to the sample specification technique of elementary nets which is also used for the small web browser suite in order clarify the main ideas.
Dynamic software architectures that use formal techniques are investigated in [6,5]. Many of those approaches use graph transformations for the specification of dynamic changes and reconfigurations. In [32] we have integrated the generic component concept with high-level replacement systems, a categorical generalization of graph transformations. This work can be considered as the technical foundation for the extension of the approach introduced in this paper to dynamic architectures. Since the semantics of architectures is defined by graph transformations we can apply corresponding transformation engines as for example the AGG tool [1] in order to compute the semantics automatically.
As already mentioned in Sect. 3 the handling of multiple accesses in component architectures depends on the used specification technique and the corresponding instance notion. The composition operations presented in this paper are fully ad- equate for techniques with a loose semantics, i.e. each specification induces a set of valid instances. For techniques with a close semantics there are two possibilities of resolving multiple access. The first variant glues the requiring components over the providing one. This is suitable for a shared access, as used in our example of Sect. 2. Exclusive access requires a different composition operation that creates a copy of the required component for each request. See [26] for details.

References
AGG:	A	development	environment	for	attributed	graph	transformation	systems.
http://tfs.cs.tu-berlin.de/agg .
R. Allen and D. Garlan. The Wright architectural specification language. Technical Report CMU-CS- 96-TBD, School of Computer Science, Carnegie Mellon University, 1996.
R. Allen and D. Garlan. A formal basis for architectural connection. ACM Transactions on Software Engineering and Methodology, 1997.
S. Balsamo, M. Bernardo, and M. Simeoni. Performance evaluation at the software architecture level. volume 2804 of Lecture Notes in Computer Science, pages 207–258. Springer Verlag, 2003.
J.S. Bradbury. Organizing definitions and formalisms for dynamic software architectures. Technical Report 2004-477, Queens University, 2004.
J.S. Bradbury, J.R. Cordy, J. Dingel, and M. Wermelinger. A survey of self-management in dynamic software architecture specifications. In WOSS ’04: Proceedings of the 1st ACM SIGSOFT workshop on Self-managed systems, pages 28–33, New York, NY, USA, 2004. ACM Press.
C. Choppy, P. Poizat, and J. Royer. Formal specification of mixed components with Korrigan. In Proceedings of the 8th Asia-Pacific Software Engineering Conference, APSEC’2001, pages 169–176. IEEE, 2001.
http://www.fiadeiro.org/jose/CommUnity/ .
E.P. Dawis. Architecture of an SS7 protocol stack on a broadband switch platform using dualistic petri nets. In 2001 IEEE Pacific Rim Conference on Communications, Computers and Signal Processing, pages 323–326, 2001.


E.P. Dawis, J.F. Dawis, and W.P. Koo. Architecture of computer-based systems using dualistic petri nets. In Proceedings of the 2001 IEEE Systems, Man, and Cybernetics Conference, October 2001.
V.C. de Paula, G.R.B. Justo, and P.R.F. Cunha. Specifying and verifying reconfigurable software architectures. In International Symposium on Software Engineering for Parallel and Distributed Systems, pages 21 – 31, 2000.
H. Ehrig, B. Braatz, M. Klein, F. Orejas, S. Perez, and E. Pino. Object-Oriented Connector- Component Architectures. In Formal Foundations of Embedded Software and Component-Based Software Architectures (FESCA), volume 141 of Electronic Notes in Theoretical Computer Science. Elsevier, 2005.
H. Ehrig, F. Orejas, B. Braatz, M. Klein, and M. Piirainen. A Generic Component Concept for System Modeling. In Ralf-Detlef Kutsche and Herbert Weber, editors, Fundamental Approaches to Software Engineering (FASE 2002), volume 2306 of Lecture Notes in Computer Science, pages 33–48. Springer, 2002.
H. Ehrig, F. Orejas, B. Braatz, M. Klein, and M. Piirainen. A Transformation-Based Component Framework for a Generic Integrated Modeling Technique. Journal of Integrated Design and Process Science, 6(4):78–104, 2003.
H. Ehrig, F. Orejas, B. Braatz, M. Klein, and M. Piirainen. A component framework for system modeling based on high-level replacement systems. Software and System Modeling, 3(2):114–135, 2004.
H. Ehrig, J. Padberg, B. Braatz, M. Klein, F. Orejas, S. Perez, and E. Pino. A Generic Framework for Connector Architectures based on Components and Transformations. In Formal Foundations of Embedded Software and Component-Based Software Architectures (FESCA), volume 108 of Electronic Notes in Theoretical Computer Science. Elsevier, 2004.
G. Estrin, R. S. Fenchel, R. R. Razouk, and M. K. Vernon. Sara (system architects apprentice): modeling, analysis, and simulation support for design of concurrent systems. IEEE Trans. Softw. Eng., 12(2):293–311, 1986.
J. L. Fiadeiro and T. Maibaum. Categorical semantics of parallel program design. Science of Computer Programming, 28:111–138, 1997.
J.L. Fiadeiro, A. Lopes, and M. Wermelinger. A mathematical semantics for architectural connectors. In R. C. Backhouse and J. Gibbons, editors, Generic Programming, volume 2793 of Lecture Notes in Computer Science, pages 178–221. Springer, 2003.
D. Garlan. Formal modeling and analysis of software architecture: connectors, and events. In Formal Methods for Software Architecture, volume 2804 of Lecture Notes in Computer Science, pages 1–24. Springer, 2003.
F. Griffel. Componentware – Konzepte und Techniken eines Softwareparadigmas. dpunkt Verlag, 1998.
V. Gruhn and A. Thiel. Komponentenmodelle: DCOM, JavaBeans, EnterpriseJavaBeans, CORBA. Addison-Wesley, 2000.
L. Grunske. Strukturorientierte Optimierung der Qualit¨atseigenschaften von softwareintensiven technischen Systemen im Architekturentwurf. PhD thesis, Universit¨at Potsdam, 2004.
W. Hasselbring. Component-based software engineering. In S.K. Chang, editor, Handbook of Software Engineering and Knowledge Engineering, pages 289–305. World Scientific Publishing, New Jersey, 2002. ISBN 981-02-4974-8.
M. Klein. A Component Concept for System Modeling Based on High-Level Replacement Systems. Forschungsbericht 2003/09, Fakult¨at IV – Elektrotechnik und Informatik, TU Berlin, 2003.
M. Klein. Compatibility constructions for multiple access in generic component architectures. Forschungsbericht 2006/01, Fakult¨at IV – Elektrotechnik und Informatik, TU Berlin. To appear.
J. Magee, N. Dulay, S. Eisenbach, and J. Kramer. Specifying distributed software architectures. In
W. Schafer and P. Botella, editors, Proc. 5th European Software Engineering Conf. (ESEC 95), Lecture Notes in Computer Science 989, pages 137–153. Springer, 1995.
J. Magee and J. Kramer. Dynamic Structures in Software Architecture. In Proc. 4th ACM SIGSOFT Symposium on the Foundations of Software Engineering, pages 3–14, 1996.
J. Padberg. Abstract Petri Nets: A Uniform Approach and Rule-Based Refinement. PhD thesis, Technical University Berlin, 1996. Shaker Verlag.
J. Padberg. Petri net modules. Journal on Integrated Design and Process Technology, 6(4):105–120, 2002.
J. Padberg. Formale Techniken fu¨r die Beschreibung von Software-Architekturen. In R. Reussner and
W. Hasselbring, editors, Handbuch der Software-Architektur. d-punkt Verlag, 2005. Accepted.


J. Padberg. Integration of the generic component concepts for system modeling with adhesive HLR systems. EATCS Bulletin, 87:138–155, 2005.
M. Shaw and D. Garlan. Software Architecture - Perspectives on an Emerging Discipline. Prentice Hall, 1996.
C. Szyperski. Component Software – Beyond Object-Oriented Programming. Addison-Wesley, 1997.
P.S. Thiagarajan. Elementary Net Systems. In W. Brauer, W. Reisig, and G. Rozenberg, editors, Petri Nets : Central Models and Their Properties, number 254 in LNCS, pages 26–59. Springer Verlag, 1987.
J. Woodcock and J. Davies. Using Z. Prentice-Hall, 1996.
