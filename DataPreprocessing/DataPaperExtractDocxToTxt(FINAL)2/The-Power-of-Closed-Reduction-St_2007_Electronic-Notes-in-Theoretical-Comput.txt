Electronic Notes in Theoretical Computer Science 174 (2007) 57–74	
www.elsevier.com/locate/entcs

The Power of Closed Reduction Strategies 

Sandra Alvesa,2 ,3	Maribel Ferna´ndezb Mario Floridoa,2 Ian Mackieb,c,1
a University of Porto, Department of Computer Science & LIACC,
R. do Campo Alegre 823, 4150-180, Porto, Portugal
b King’s College London, Department of Computer Science, Strand, London WC2R 2LS, U.K.
c LIX, E´cole Polytechnique, 91128 Palaiseau Cedex, France

Abstract
Closed reduction strategies in the λ-calculus restrict the reduction rules: the idea is that reductions can only take place when certain terms are closed (i.e. do not contain free variables). This has lead to various applications, such as an α-conversion free calculus of explicit substitutions, and an efficient abstract machine. The main contribution of this paper is a new application of this strategy to a linear version of G¨odel’s System
T. We show that a linear System T with closed reduction offers a huge increase in expressive power over the usual linear systems, which are ‘closed by construction’ rather than ‘closed at reduction’.
Keywords: linear calculi, iteration, System T, strategies.


Introduction
To prove the correctness of the Geometry of Interaction [7], Girard used a strategy for cut-elimination in linear logic [6] which restricts cut-elimination steps so that they can only take place when the exponential boxes are closed. Not only is this strategy for cut-elimination simpler than the general one, it is also efficient in terms of the number of cut-elimination steps.
There are several translations of the λ-calculus into linear logic, which inspired the work on closed reduction in the λ-calculus [4,5]. Closed reductions avoid α- conversion by restricting β-reduction, so that only closed substitutions are gener-

٨ Research partially supported by the Treaty of Windsor Grant: “Linearity: Programming Languages and Implementations”.
1 Projet Logical, Pˆole Commun de Recherche en Informatique du plateau de Saclay, CNRS, E´cole Poly- technique, INRIA, Universit´e Paris-Sud.
2 Partially supported by funds granted to LIACC through the Programa de Financiamento Plurianual, Funda¸c˜ao para a Ciˆencia e Tecnologia and FEDER/POSI.
3 Programa Gulbenkian de Est´ımulo `a Investiga¸c˜ao.

1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2007.02.047

ated. In contrast with standard weak strategies, which also avoid α-conversion, closed reduction strategies allow β-reductions to take place under lambdas, which means that more sharing of computation can be achieved. Note that we use the word strategy to refer to a restriction in the application of reduction rules, for in- stance, the so-called weak strategies in the λ-calculus do not allow β-reductions inside lambda-abstractions, and the closed reduction systems defined in this paper will not allow the β-rule to apply when the argument is open.
Closed reductions have interesting properties: in addition to offering efficient reduction strategies, applications such as new calculi of explicit substitution were obtained; see [5] for more details. The purpose of this paper is to examine this family of strategies further. More precisely, in this paper we will analyse the computational power of linear λ-calculi with iterators, by using closed reductions (whereas the closed reduction systems studied in [4,5] are not linear and do not contain iterators in the syntax).
In [2] we defined a linear version of Go¨del’s System T with closed reductions, which we called System L. We showed that this linear system has all the compu- tational power of System T. This result is surprising because usual definitions of linear systems with iterators are strictly less powerful than System T [11,9].
In this paper, we claim that the use of closed reduction is a key to the power of System L. To support this claim, we analyse the interplay between linearity and closed reduction, and compare the computational power of linear systems with and
without closed reduction.
We will define two linear systems: LN and LN. Both systems are extensions of the linear λ-calculus [1] with numbers, booleans, pairs of natural numbers, and an iterator. System LN has the same syntax as System L [2], and as System L it uses the closed reduction strategy. However, its type system is more restrictive than System L’s. We will show that System LN can encode all the primitive recursive functions and more general functions such as Ackermann’s. On the other hand,
System LN does not restrict to closed reduction strategies, but, to be linear, it has
0	N
to restrict the set of terms. Actually, System L0 can be seen as a subsystem of Dal
Lago’s linear language H(∅) [11], albeit with a different syntax. System LN can encode only primitive recursive functions (Ackermann’s function is not definable), therefore this system is strictly weaker than System LN, and hence also weaker than System L.
In the next section we recall some background material. In Section 3 we define
the linear systems LN and LN, and in Section 4 we demonstrate that we can encode all the primitive recursive functions in these calculi. In Section 5 we show that System LN goes considerably beyond this class of functions. Finally we conclude the paper in Section 6.

Background: Closed Reduction, Linear Systems
C¸ a˘gman and Hindley [3] observed that α-conversion can be avoided if β-redexes are closed (i.e. (λx.t)u does not contain free variables). However, this is a strong

restriction on the application of the β-reduction rule, and the resulting calculus is very weak. In [4,5] closed reduction strategies were investigated which are less restrictive than this. The motivation for this study was to understand efficiency issues in addition to finding calculi that were free from α-conversion.
Two different versions of closed reduction were studied, based around the fol- lowing two options:
(λx.t)u → t[u/x]  if fv(λx.t)= ∅
(λx.t)u → t[u/x] if fv(u)= ∅
which correspond to closed function (cf ) and closed argument (ca) respectively. In both cases, there are a number of variants that lead to calculi with different properties. Substitution is taken to be explicit in these systems (see [5] for more details).
The closed argument strategy was used in [2] to define an extension of the linear λ-calculus [1] with natural numbers, booleans, linear pairs, linear conditionals and a linear iterator (and with implicit rather than explicit substitution). This linear version of Go¨del’s System T was called System L.
In [12] it was shown that the linear λ-calculus is the internal language for sym-
metric monoidal closed categories (the analogous result to the λ-calculus being the internal language to Cartesian Closed Categories). The addition of natural num- bers and an iterator corresponds to adding a natural number object in the category. Note that, in this linear setting, the iterator is only allowed to iterate closed linear functions. More precisely, the typing rule for iterators requires the function to be typed in an empty type-environment, that is, iterators are “closed by construction”:
Γ ▶ n : N	Δ ▶ b : A	▶ f : A −◦ A
Γ, Δ ▶ iter n b f 
In the same line, the linear System T of [11], called H(∅), only allows the construction of iterators on closed functions, and can only encode primitive recursive functions. On the other hand, System L has all the power of the full System T. To understand what gives these two linear versions of System T so different properties,
in the following sections we will define two linear systems, one which allows us to build iterators on functions with free variables, but requires that reduction takes place only after the functions become closed, and another that does not use closed reduction, but requires iterators to be closed by construction.
Linear Systems with and without Closed Reduction
In this section we will define two linear systems: System LN and System LN. Both systems extend the linear λ-calculus with booleans, numbers, pairs of natural num- bers, and an iterator. While System LN has the usual open β-reduction rule but, when building an iterator, requires the iterated function to be closed (therefore avoiding copying of free variables), System LN uses a closed reduction strategy [5,8] and allows the use of open functions in iterators.

We start by defining the syntax and the set of types, which will be common to the two systems (see also [2]).

Linear Terms and Types
The linear λ-terms are terms from the λ-calculus restricted in the following way (fv(t) denotes the set of free variables of t):

x
λx.t	if x ∈ fv(t)
t u	if fv(t) ∩ fv(u)= ∅

Note that x is used at least once in the body of the abstraction, and the condition on the application ensures that all variables are used at most once. Thus these conditions ensure syntactic linearity (variables occur exactly once).
Next we add to this linear λ-calculus: numbers, booleans and pairs, preserving syntactic linearity. We use the following syntax:
Pairs:
⟨t, u⟩	if fv(t) ∩ fv(u)= ∅
let ⟨x, y⟩ = t in u	if x, y ∈ fv(u) and fv(t) ∩ fv(u)=∅
Note that when projecting from a pair, we use both projections. A simple example of such a term is the function that swaps the components of a pair:

λx.let ⟨y, z⟩ = x in ⟨z, y⟩.
Booleans: true and false, and a conditional:
cond t u v	if fv(t) ∩ fv(u)= ∅ and fv(u)= fv(v)
Note that this linear conditional uses the same resources in each branch.
Numbers: 0 and S, and an iterator:
iter t u v	if  fv(t)∩fv(u)=fv(u)∩fv(v)=fv(v)∩fv(t)=∅

We follow standard notational conventions in the sequel: for instance, we write λxy.t instead of λx.λy.t, application is left-associative and we use brackets only when there is ambiguity. As an abbreviation, we write Sn0 to denote n applications of S to 0.
Table 1 summarises the syntax of System LN and System LN, showing the term
construction, variable constraints and free variables of terms.



Table 1 Syntax of Terms
Types
The set of linear types is generated by the grammar:
A, B ::= N | B | A −◦ B | N ⊗ N
That is, we consider two base types (natural numbers and booleans), linear arrows, and linear products on natural numbers.
System LN
We now define the reduction rules and the typing rules for System LN.
The dynamics of the system is given by a set of conditional reduction rules (which can be seen as a higher-order membership conditional rewrite system, see [14,15]). The conditions on the rewrite rules restrict the rewrite relation, ensuring that Beta only applies to redexes where the argument is a closed term (which implies that α-conversion is not needed to implement substitution), and only closed functions are iterated.
Definition 3.1 (Closed Reduction) Table 2 gives the reduction rules for System LN, substitution is a meta-operation defined as usual. Reductions can take place in any context. We use −→ to denote the one-step reduction relation, and −→∗ for its reflexive and transitive closure.
Reduction is weak: for example, λx.(λy.y)x is a normal form. Note that all the substitutions created during reduction (rules Beta, Let ) are closed; this corresponds


Table 2 Closed reduction

to a closed argument reduction strategy (ca, see [5]). Also note that Iter rules cannot be applied if the function v is open.
System LN’s syntax and reduction rules are the same as System L’s [2], as a consequence we inherit from System L the following properties, for the untyped calculus:
Lemma 3.2 (Correctness of Substitution) Let t and u be valid terms, x ∈
fv(t), and fv(u)= ø, then t[u/x] is valid.
Lemma 3.3 (Correctness of −→) Let t be a valid term, and t −→ u, then:
fv(t)= fv(u);
u is a valid term.
Lemma 3.4 (Confluence) If t −→∗ t1 and t −→∗ t2, then there is a term t3 such that t1 −→∗ t3 and t2 −→∗ t3.
We associate types to terms in System LN using the typing rules given in Fig- ure 1.
Since we are in a linear system, we do not have Weakening and Contraction rules. The only structural rule in Figure 1 is Exchange. For the same reason, the logical rules split the typing context between the premises. The rules for numbers are standard. In the case of a term of the form iter t u v, we check that t is a term of type N and that v and u are compatible.
Note that we allow the typing of iter t u v even if v is open (in contrast with [11,9]), but we do not allow reduction until v is closed. We will show later that this feature gives System LN more power (whereas systems that do not allow building an iterator with v open are strictly weaker).
Subject Reduction for System LN can be proved as for System L [2].
Theorem 3.5 (Subject Reduction) If Γ ▶LN t : A and t −→ u, then
Γ ▶LN u : A.





Axiom and Structural Rule:
(Axiom)

Γ,x : A, y : B, Δ ▶LN t : C



x : A ▶LN x : A
Logical Rules:
Γ,y : B, x : A, Δ ▶LN
(Exchange)
t : C



Γ,x : A ▶LN t : B
Γ ▶LN λx.t : A −◦ B
(−◦Intro)
Γ ▶LN t : A −◦ B	Δ ▶LN u : A
Γ, Δ ▶LN t u : B
(−◦Elim)

Γ ▶LN t : N	Δ ▶LN u : N
Γ, Δ ▶LN ⟨t, u⟩ : N ⊗ N

(⊗Intro)



Numbers:
Γ ▶LN t : N ⊗ N	x : N,y : N, Δ ▶LN u : C
Γ, Δ ▶LN let ⟨x, y⟩ = t in u : C
(⊗Elim)

(Zero)
Γ ▶LN n : N



▶LN 0: N
Γ ▶LN
(Succ)
S n : N



Booleans:
Γ ▶LN t : N	Θ ▶LN u : A	Δ ▶LN v : A → A


Γ, Θ, Δ ▶LN iter t u v : A
(Iter)



▶LN true : B
(True)


▶LN false : B
(False)

Δ ▶LN t : B	Γ ▶LN u : A	Γ ▶LN v : A
Γ, Δ ▶LN cond t u v : A
(Cond)



Fig. 1. Type System for System LN

Proof. (Sketch) By induction on the type derivation Γ ▶LN t : A, using a Substitu- tion Lemma: If Γ,x : A ▶LN u : B and Δ ▶LN v : A (where fv(u) ∩ fv(v)= ø) then Γ, Δ ▶LN u[v/x]: B.	 
Note that confluence of the untyped calculus, together with subject reduction, implies confluence of the typed calculus.
Since terms typable in System LN are also typable in System L, we inherit the strong normalisation property:
Theorem 3.6 (Strong Normalisation) If Γ ▶LN t : T , then t is strongly nor- malisable.

System LN
The set of terms for System LN is built in the same way as for System LN, except that when building an iterator, we don’t allow the iterated function to be an open

term. Thus iterators in this system have the following definition (note the additional constraint fv(v)= ø):
iter t u v  if fv(t)∩fv(u)=ø and fv(v)=ø
We now define the reduction rules and the typing rules for System LN.
Definition 3.7 (Reduction) Table 3 gives the reduction rules for System LN; sub- stitution is a meta-operation defined as usual. Reductions can take place in any context.

Table 3	N
Reduction for System L0


Correctness of Substitution is proved as for System L [2], but α-conversion must be used in substitution whenever necessary. Note that α-conversion was not needed in System L and therefore in System LN, because all the substitutions take a closed term.
Lemma 3.8 (Correctness of Substitution) Let t and u be valid terms, such that fv(t) ∩ fv(u)= ø and x ∈ fv(t), then t[u/x] is valid.
Proof. (Sketch) Straightforward induction on the structure of t, showing that sub- stitution preserves the variable constraints on terms.	 
Lemma 3.9 (Correctness of −→) Let t be a valid term, and t −→ u, then:
fv(t)= fv(u);
u is a valid term.
Proof. (Sketch) By structural induction on t, showing that reduction preserves the variable constraints on terms. Note that the only reduction rules that copy or erase terms are the rules for iterators, which either copy or erase the iterated function. However, because of the condition that the iterated function must be closed when constructing the term iter t u v, then reducing an iterator will either copy or erase a closed term. Therefore the set of free variables is preserved and the term obtained is valid.	 

Note that in System LN we do not have the constraint on the iterator term, but we have a condition in the reduction rules for iterators, which also guarantees that reducing an iterator will either copy or erase a closed term.
In Figure 2 we show how types are assigned to terms in System LN. The only

difference between the rules for this system and for System LN
0
is in the (Iter) rule,

where the typing context for the iterated function is always empty, which forces the
iterated function to be closed.



Axiom and Structural Rule:
(Axiom)

Γ,x : A, y : B, Δ ▶LN t : C
	0	 (Exchange)

x : A ▶ N x : A
0
Γ,y : B, x : A, Δ ▶
N t : C
0



Logical Rules:
Γ,x : A ▶LN t : B
		0	 (−◦Intro) Γ ▶ N λx.t : A −◦ B
0

Γ ▶LN t : A −◦ B	Δ ▶LN u : A
	0		0	 (−◦Elim) Γ, Δ ▶ N tu : B
0






Numbers:
Γ ▶LN t : N	Δ ▶LN u : N
		0	0	 (⊗Intro) Γ, Δ ▶ N ⟨t, u⟩ : N ⊗ N
0
Γ ▶LN t : N ⊗ N	x : N,y : N, Δ ▶LN u : C
	0		0	 (⊗Elim) Γ, Δ ▶ N let ⟨x, y⟩ = t in u : C
0

(Zero)
Γ ▶LN n : N
	0	 (Succ)

▶ N 0: N
0
Γ ▶ N S n : N
0



Booleans:
Γ ▶LN t : N	Θ ▶LN u : A	▶LN v : A → A
	0		0	0	 (Iter) Γ, Θ ▶ N iter t u v : A
0



▶ N true : B
0
(True)


▶ N false : B
0
(False)

Δ ▶LN t : B	Γ ▶LN u : A	Γ ▶LN v : A
	0		0	0	 (Cond) Γ, Δ ▶ N cond t u v : A
0

Fig. 2. Type System for System LN

As before, Subject Reduction for System LN can be proved as for System L [2].

Theorem 3.10 (Subject Reduction) If Γ ▶ N t : A and t −→ u, then
0
Γ ▶ N u : A.
0

Theorem 3.11 (Strong Normalisation) If Γ ▶ N t : T , then t is strongly nor-
0
malisable.
Proof. Note that any term typable in System LN is also typable in System LN,
N	0
therefore in System L. Thus, System L0 is strongly normalising.	 
Lemma 3.12 (Confluence) If t −→∗ t1 and t −→∗ t2, then there is a term t3
such that t1 −→∗ t3 and t2 −→∗ t3.
Proof. Confluence for typable terms in System LN is a direct consequence of strong normalisation and the fact that the rules are non-overlapping (using Newmann’s Lemma [13]). Moreover, we can apply directly Klop’s result [10] to the untyped calculus because the system is orthogonal (that is, left-linear and non-overlapping). 


Primitive Recursive Functions
Based on the results obtained for System L [2], in this section we show how we can define the primitive recursive functions in both System LN and System LN.
We choose to present an encoding that satisfies the term conditions of System LN,

since these are more restrictive than those of System LN
0
. In the next section we

show that in System LN we can encode substantially more than primitive recursive functions.
We start by recalling the definition of primitive recursive function.
Definition 4.1 A function f : Nn → N is primitive recursive if it can be defined using: the natural numbers; the projections: πn(x1,... , xn)= xi (1 ≤ i ≤ n); com- position; and the primitive recursive scheme, which allows us to define a recursive function h using two auxiliary (primitive recursive) functions f , g:

h(x, 0)	= f (x)
h(x, n + 1) = g(x, h(x, n), n)

Erasing linearly
Although System LN and System LN are linear calculi, we can erase numbers. In particular, we can define the projection functions on N2 fst, snd : N ⊗ N −◦ N as follows:

fst = λx.let ⟨u, v⟩ = x in iter v u (λz.z)
snd = λx.let ⟨u, v⟩ = x in iter u v (λz.z)
Lemma 4.2 For any numbers a and b, fst⟨a, b⟩ −→∗ a  and snd⟨a, b⟩ −→∗ b.









	
v : N ▶LN v : N	u : N ▶LN u : N
z : N ▶ N z : N
0
▶LN λz.z : N −◦ N

0	0	0

x : N ⊗ N ▶ N x : N ⊗ N
0
u : N,v : N ▶ N iter v u λz.z : N
0

x : N ⊗ N ▶ N let ⟨u, v⟩ = x in iter v u λz.z : N
0
▶ N λx.let ⟨u, v⟩ = x in iter v u λz.z : (N ⊗ N) −◦ N
0

Fig. 3. Typing of fst



Proof. We show the case for fst. Let a = Sn 0, b = Sm 0.

fst⟨a, b⟩	=	(λx.let ⟨u, v⟩ = x in iter v u (λz.z))⟨Sn 0, Sm 0⟩
−→ let ⟨u, v⟩ = ⟨Sn 0, Sm 0⟩ in iter v u λz.z
−→ iter (Sm 0) (Sn 0) λz.z
−→∗ Sn 0= a.




Note that fst and snd are valid typable terms in System LN (see Figure 3), and
they are closed terms.

Copying linearly
We can also copy natural numbers in these linear calculi. For this, we define a function C : N −◦ N ⊗ N that given a number n returns a pair ⟨n, n⟩:

C = λx.iter x ⟨0, 0⟩ (λx.let ⟨a, b⟩ = x in ⟨S a, S b⟩)

Lemma 4.3 For any number n, C n −→∗ ⟨n, n⟩.

In the derivation below, s is the term (λx.let ⟨a, b⟩ = x in ⟨S a, S b⟩)

	

a : N ▶ N a : N
0
a : N ▶ N S a : N
0
b : N ▶ N b : N
0
b : N ▶ N S b : N
0

x : N ⊗ N ▶ N x : N ⊗ N
0
a : N,b : N ▶ N ⟨S a, S b⟩ : N ⊗ N
0

x : N ⊗ N ▶ N let ⟨a, b⟩ = x in ⟨S a, S b⟩ : N ⊗ N
0
▶ N (λx.let ⟨a, b⟩ = x in ⟨S a, S b⟩): (N ⊗ N) −◦ (N ⊗ N)
0

	



x : N ▶ N x : N
0
▶ N 0: N	▶ N 0: N
	0	0	
▶ N ⟨0, 0⟩ : N ⊗ N
0
·
·
·
▶ N s : (N ⊗ N) −◦ (N ⊗ N)
0

x : N ▶ N iter x ⟨0, 0⟩ (λx.let ⟨a, b⟩ = x in ⟨S a, S b⟩): N ⊗ N
0
▶ N λx.iter x ⟨0, 0⟩ (λx.let ⟨a, b⟩ = x in ⟨S a, S b⟩): N −◦ (N ⊗ N)
0

Fig. 4. Typing of C

Proof. By induction on n.

C 0	−→ iter 0 ⟨0, 0⟩ (λx.let ⟨a, b⟩ = x in ⟨S a, S b⟩)
−→ ⟨0, 0⟩

C (Sn+1 0)	=	iter (Sn+1 0) ⟨0, 0⟩ (λx.let ⟨a, b⟩ = x in ⟨S a, S b⟩)
−→∗ (λx.let ⟨a, b⟩ = x in ⟨S a, S b⟩)⟨Sn 0, Sn 0⟩
−→ let ⟨a, b⟩ = ⟨Sn 0, Sn 0⟩ in ⟨S a, S b⟩
−→ ⟨Sn+1 0, Sn+1 0⟩

Again, C is valid in System LN (see Figure 4), and a closed term.

Primitive Recursive Scheme
We have already shown we can project, and of course we have composition. We now show how to encode, using iterators, a function h defined by primitive recursion from f and g (see Definition 4.1).
First, assume h is defined by the following, simpler scheme (it uses n only once

in the second equation):

h(x, 0)	= f (x)
h(x, n + 1) = g(x, h(x, n))

Given the closed functions G : N −◦N −◦N and F : N −◦N, representing the primitive recursive functions g and f , let g' be the term:
λy.λz.let ⟨z1, z2⟩ = C z in Gz1(yz2): (N −◦ N) −◦ (N −◦ N)
then h(x, n) is defined by the term (iter n F g') x : N, (see Figure 5). Note that the encoding of h is a closed term. This term is valid because F is closed (by assumption), and g' is closed since G is a closed term (by assumption).
Lemma 4.4 For any numbers x and n, (iter n F g') x reduces to the number
h(x, n).
Proof. By induction, using Lemma 4.3 to copy numbers: (iter 0 F g') x	−→ (F x)= h(x, 0)
(iter (Sn+1 0) F g') x −→ g' (iter (Sn 0) F g') x
−→∗ let ⟨z1, z2⟩ = ⟨x, x⟩ in G z1 ((iter (Sn 0) F g') z2)
−→ G x ((iter (Sn 0) F g') x)
−→∗ G x h(x, n) by induction hypothesis
=	h(x, n + 1).
 
Now to encode the standard primitive recursive scheme, which has an extra n in the last equation (see Definition 4.1), all we need to do is copy n. We use the notation introduced above (F, G are auxiliary functions, but G has now the type N −◦ N −◦ N −◦ N):
h(x, n)= let ⟨n1, n2⟩ = C n in s (pred n1) x
where
s = iter n2 (λx1.fst⟨F, x1⟩) s' s' = λyx2z.
let ⟨z1, z2⟩ = C z in (let ⟨w1, w2⟩ = C x2 in G z1 (y (pred w1) z2) w2)


·
·						
·
▶LN G : N −◦ N −◦ N	z1 : N ▶LN z1 : N	y : N −◦ N ▶LN y : N −◦ N	z2 : N ▶LN z2 : N

0	0
z1 : N ▶ N Gz1 : N −◦ N
0
0	0
y : N −◦ N, z2 : N ▶ N yz2 : N
0

y : N −◦ N, z1 : N, z2 : N ▶ N Gz1(yz2): N
0


·
·
·
z : N ▶ N C z : N ⊗ N
0
·
·
·
y : N −◦ N, z1 : N, z2 : N ▶ N Gz1(yz2): N
0

y : N −◦ N,z : N ▶ N let ⟨z1, z2⟩ = C z in Gz1(yz2): N
0
y : N −◦ N ▶ N λz.let ⟨z1, z2⟩ = C z in Gz1(yz2): N −◦ N
0
▶ N λyz.let ⟨z1, z2⟩ = C z in Gz1(yz2): (N −◦ N) −◦ (N −◦ N)
0



x : N ▶ N
0

x : N
·
·
·
▶ N F : N −◦ N
0

▶ N g'
0
·
·
·
: (N −◦ N) −◦ (N −◦ N)

n : N ▶ N iter n F g' : N −◦ N  x : N ▶ N x : N
L0	L0
n : N,x : N ▶ N (iter n F g')x : N
0

Fig. 5. Typing of functions defined by primitive recursion
Let pred be the encoding of the predecessor function defined as:
pred = λn.fst(iter n ⟨0, 0⟩ (λx.let ⟨t, u⟩ = C(snd x) in ⟨t, S u⟩))
It can be easily verified by induction that the predecessor function is correct, that is:
pred 0	= 0
pred (S n) = n
Also, the predecessor function is a closed typable function in System LN (see
Figure 6).

Beyond Primitive Recursion
In this section we show that it is possible to encode more than primitive recursive functions in System LN, by giving the encoding of a well-known non primitive recursive function: Ackermann’s function.
ack(0, n)	= S n
ack(S n, 0)	= ack(n, S 0)
ack(S n, S m) = ack(n, ack(S n, m))

In the derivation below, f is the term λx.let ⟨t, u⟩ = C(snd x) in ⟨t, S u⟩.



·	t : N ▶LN t : N
u : N ▶ N u : N
0
u : N ▶LN S u : N

·
·
x : N ⊗ N ▶ N C(snd x): N ⊗ N
0
	0	0	
t : N,u : N ▶ N ⟨t, S u⟩ : N ⊗ N
0

x : N ⊗ N ▶ N let ⟨t, u⟩ = C(snd x) in ⟨t, S u⟩ : N ⊗ N
0
▶ N λx.let ⟨t, u⟩ = C(snd x) in ⟨t, S u⟩ : (N ⊗ N) −◦ (N ⊗ N)
0




n : N ▶ N n : N
0
·
·
·
▶ N ⟨0, 0⟩ : N ⊗ N
0
·
·
·
▶ N f : (N ⊗ N) −◦ (N ⊗ N)
0

n : N ▶ N iter n ⟨0, 0⟩ (λx.let ⟨t, u⟩ = C(snd x) in ⟨t, S u⟩): N ⊗ N
0
n : N ▶ N fst(iter n ⟨0, 0⟩ (λx.let ⟨t, u⟩ = C(snd x) in ⟨t, S u⟩)) : N
0
▶ N fst(iter n ⟨0, 0⟩ (λx.let ⟨t, u⟩ = C(snd x) in ⟨t, S u⟩)) : N −◦ N
0

Fig. 6. Typing of predecessor
In a higher-order functional language, it can be defined as follows: Let succ = λx.S x : N −◦ N, then ack(m, n)= a m n where:
a 0	= succ
a (S n)	= A (a n)

A g 0	= g(S 0)
A g (S n) = g(A g n)
Lemma 5.1 Both deﬁnitions are equivalent:  a x y = ack(x, y), for all numbers
x, y.
Proof. By induction on x, using Lemma 5.2 below:
The case x = 0 is trivial: a 0 y = S y = ack(0, y).
By definition, a (S n) = A (a n), and by hypothesis this is A(λy.ack(n, y)). Therefore by Lemma 5.2 below, a (S n) z = ack(S n, z).

Lemma 5.2 If g = λy.ack(x, y) then A g n = ack(S x, n).
Proof. By induction on n.
A g 0= g(S 0) = ack(x, S 0) = ack(S x, 0).

A g (S n)= g (A g n)= g (ack(S x, n)) = ack(x, ack(S x, n)) = ack(S x, S n).

We can define a and A in System LN as follows:
a = λn.iter n succ A : N −◦ N −◦ N
A = λg n.iter (S n) (S 0) g : (N −◦ N) −◦ N −◦ N
We show by induction that this encoding is correct (we assume n is a number and
g a closed function):


A g 0	−→∗ iter (S 0) (S 0) g
−→∗ g(S 0)
A g (S n) −→∗ iter (S(S n)) (S 0) g
−→ g (iter (S n) (S 0) g)= g(A g n)
Then Ackermann’s function can be defined in System LN (see Figure 7) as:
ack = λm n.(iter m succ (λgu.iter (S u) (S 0) g)) n : N −◦ N −◦ N
The correctness of this encoding follows directly from the lemmas above.
Note that iter (S u) (S 0) g cannot be typed in System LN, because g is a free

variable. System LN
0
allows building the term with the free variable g, but does not

allow reduction until it is closed.
Every function in System LN can be defined in the system H(ø) studied in [11]: the syntax is different but the typing rules are equivalent (it is possible to define an encoding from terms/typings in System LN to terms/typings in H(ø)). It has been proved (see [11] for details) that Ackermann’s function cannot be represented
in H(ø), therefore it cannot be represented in System LN either. Thus, System LN
0	0
is strictly less powerful than System LN.
Conclusions and Future Work
Closed reduction strategies impose strong constraints on the application of reduction rules, but despite this fact, they can simulate both call-by-name and call-by-value



x : N ▶ N x : N
0
x : N ▶ N S x : N
0
▶ N succ = λx.S x : N −◦ N
0

	

u : N ▶ N u : N
0
u : N ▶LN S u : N
▶ N 0: N
0
▶LN S 0: N	g : N −◦ N ▶LN g : N −◦ N

0	0	0
g : N −◦ N,u : N ▶ N iter (S u) (S 0) g : N
0
g : N −◦ N ▶ N λu.iter (S u) (S 0) g : (N −◦ N)
0
▶ N A = λgu.iter (S u) (S 0) g : (N −◦ N) −◦ (N −◦ N)
0




m : N ▶ N m : N
0
·
·
·
▶ N succ : N −◦ N
0
·
·
·
▶ N A : (N −◦ N) −◦ (N −◦ N)
0

m : N ▶LN iter m succ A : N −◦ N	n : N ▶LN n : N
0	0
m : N,n : N ▶ N (iter m succ A) n : N
0
▶ N λm n.(iter m succ A) n : N −◦ N −◦ N
0

Fig. 7. Typing of Ackermann’s function
evaluations in the λ-calculus (as shown in [4]), and also more efficient evaluations (since reductions can take place under abstractions and thus achieve more sharing of computations); similar results hold for PCF (see [5]).
In this paper we have shown that in the case of a linear λ-calculus with iterators, the use of closed reduction strategies has another benefit: not only we can gain in efficiency, but also we gain in computational power, thanks to the fact that we can relax the constraints on the construction of iterator terms.

Acknowledgement
We are grateful to the anonymous referees for their comments, and to Bernhard Gramlich for pointing out relevant references.

References
S. Abramsky. Computational Interpretations of Linear Logic. Theoretical Computer Science, 111:3–57, 1993.
S. Alves, M. Fern´andez, M. Florido, and I. Mackie. The power of linear functions. In Proceedings of


Computer Science Logic (CSL’06), volume 4207 of Lecture Notes in Computer Science, pages 119–134. Springer-Verlag, September 2006.
N. C¸ a˘gman and J. R. Hindley. Combinatory weak reduction in lambda calculus. Theoretical Computer Science, 198(1–2):239–249, 1998.
M. Fern´andez and I. Mackie. Closed reduction in the λ-calculus. In J. Flum and M. Rodr´ıguez-Artalejo, editors, Proceedings of Computer Science Logic (CSL’99), volume 1683 of Lecture Notes in Computer Science, pages 220–234. Springer-Verlag, September 1999.
M. Fern´andez, I. Mackie, and F.-R. Sinot. Closed reduction: explicit substitutions without alpha conversion. Mathematical Structures in Computer Science, 15(2):343–381, 2005.
J.-Y. Girard. Linear Logic. Theoretical Computer Science, 50(1):1–102, 1987.
J.-Y. Girard. Geometry of interaction 1: Interpretation of System F. In R. Ferro, C. Bonotto,
S. Valentini, and A. Zanardo, editors, Logic Colloquium 88, volume 127 of Studies in Logic and the Foundations of Mathematics, pages 221–260. North Holland Publishing Company, Amsterdam, 1989.
J.-Y. Girard. Towards a geometry of interaction. In J. W. Gray and A. Scedrov, editors, Categories in Computer Science and Logic: Proc. of the Joint Summer Research Conference, pages 69–108. American Mathematical Society, Providence, RI, 1989.
M. Hofmann. Linear types and non-size-increasing polynomial time computation. In Proc. Logic in Computer Science (LICS’99). IEEE Computer Society, 1999.
J.-W. Klop, V. van Oostrom, and F. van Raamsdonk. Combinatory reduction systems, introduction and survey. Theoretical Computer Science, 121:279–308, 1993.
U. D. Lago. The geometry of linear higher-order recursion. In P. Panangaden, editor, Proceedings of the Twentieth Annual IEEE Symp. on Logic in Computer Science, LICS 2005, pages 366–375. IEEE Computer Society Press, June 2005.
I. Mackie, L. Rom´an, and S. Abramsky. An internal language for autonomous categories. Journal of Applied Categorical Structures, 1(3):311–343, 1993.
M. Newman. On theories with a combinatorial definition of “equivalence”. Annals of Mathematics, 43(2):223–243, 1942.
Y. Toyama. Confluent term rewriting systems with membership conditions. In Proceedings of the 1st International Workshop on Conditional Term Rewriting Systems, CTRS’87, Orsay, France, volume 308 of LNCS, pages 228–241. Springer-Verlag, 1988.
J. Yamada. Confluence of terminating membership conditional TRS. In Proceedings of the 3rd International Workshop on Conditional Term Rewriting Systems, CTRS’92, Pont--Mousson, France, volume 656 of LNCS, pages 378–392. Springer-Verlag, 1993.
