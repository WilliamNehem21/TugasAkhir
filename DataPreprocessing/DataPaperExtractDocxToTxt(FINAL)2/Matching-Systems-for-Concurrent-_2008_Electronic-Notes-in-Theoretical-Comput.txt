Electronic Notes in Theoretical Computer Science 194 (2008) 85–99	
www.elsevier.com/locate/entcs

Matching Systems for Concurrent Calculi
Bjørn Haagensen1
Aalborg University Denmark
Sergio Maffeis2
Imperial College London
Iain Phillips3
Imperial College London

Abstract
Matching systems were introduced by Carbone and Maffeis, and used to investigate the expressiveness of the pi-calculus with polyadic synchronisation. We adapt their definition and investigate matching systems for CCS, the pi-calculus and Mobile Ambients. We show among other results that the asynchronous pi-calculus with matching cannot be encoded (under certain conditions) in CCS with polyadic synchronisation of all finite levels.
Keywords: Matching systems, CCS, pi-calculus, Mobile Ambients


Introduction
Matching systems were introduced by Carbone and Maffeis [4]. A matching system is a protocol which ensures that a client matches successfully with a server if and only if both parties have the same sequence of names as parameters. This can be achieved trivially if client and server can synchronise on all names in a single atomic communication. However it may not be possible if, for instance, they can only synchronise on one name at a time, as in standard π-calculus. Carbone and Maffeis used matching systems to establish a hierarchy within eπ, the π-calculus with polyadic synchronisation. They show that there is no encoding (satisfying

1 Email: bh@cs.aau.dk
2 Email: maffeis@doc.ic.ac.uk
3 Email: iccp@doc.ic.ac.uk

1571-0661 © 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2007.11.004

certain conditions) of the asynchronous calculus with n-adic communication into the synchronous calculus with m-adic communication (for any m < n).
In this paper we investigate matching systems further. In particular, we pro- pose a weakened form of matching system, where if client and server agree on their parameters then there is a successful computation, but success is no longer guaran- teed, unlike in the original formulation. These weak matching systems enable us to obtain different separations between calculi. We regard matching systems (whether in the weak form or the original strong form) as measuring the capability of partic- ular calculi to perform transactions, in other words to perform a series of operations which can be treated as a single operation. Weak matching systems require only that all the commits are justified, whereas strong matching systems require also that the transaction is not rolled back an unbounded number of times.
Matching systems may be compared with De Nicola-Hennessy testing [6], where processes interact with test processes, and one analyses whether they can pass a test (“may” testing), or are guaranteed to pass a test (“must” testing). A weak matching system can be seen as a kind of may testing scenario where clients and servers test each other. Similarly, a strong matching system corresponds, in a sense, to a must testing scenario.
In [4], it is shown that there is no “sensible” encoding of matching in the π- calculus with mixed choice. Here we use weak matching systems to give a different separation result involving a language with matching, based on a different notion of encoding. We shall show there there is no encoding (subject to certain conditions) from the asynchronous π-calculus with matching into CCS with n-adic communi- cation (for any n).
This is related to the question of showing that the asynchronous π-calculus cannot be encoded into CCS. As far as we are aware, such a negative result has never been obtained, even though most researchers would presumably expect this to hold, since the asynchronous π-calculus has the ability to send and receive names (objects) and then use them as channels (subjects), and this is disallowed in CCS (even with value passing).
Palamidessi [10] used electoral systems to prove two relevant results. Firstly, she showed that CCS cannot be encoded in the asynchronous π-calculus (the converse of what we are discussing). Secondly, she showed that the π-calculus with mixed choice cannot be encoded in CCS. However her work leaves open the possibility that the asynchronous π-calculus can be encoded in CCS.
Banach and van Breugel [1] encoded the π-calculus into a version of CCS. This involves augmenting CCS with infinite operations (and not just infinite summation). Sangiorgi [13] defined the π-calculus with internal mobility (πI), where only private names can be transmitted. He gave a hierarchy of typed calculi within πI, such that the bottom level represents “the core of CCS”. He showed that higher levels in the hierarchy exhibit a “higher degree” of mobility, in the sense that they admit longer subject-object dependency chains. However he did not assert any
result about the non-encodability of higher levels in lower levels of the hierarchy.
Boreale [2] gave an encoding of the asynchronous π-calculus into πI. This en-

coding is in two steps, and goes via an intermediate calculus, localised π, or Lπ, the subset of the asynchronous π-calculus where the recipient of a name may only use it in output actions. This terminology is due to Merro and Sangiorgi [8]. They showed that Lπ can be encoded fully abstractly in localised πI using the second step in Boreale’s encoding.
After presenting our results on weak matching systems, we recast the separation result concerning polyadic synchronisation of [4] into our current setting, using the notion of replicated strong matching systems. Our new formulation is a slight generalisation of the previous result. Surprisingly, and against previous intuition, we have found that by simply requiring each instance of a matching system to be finite (strong matching systems), the full π-calculus is powerful enough to solve the problem for any degree n. We conjecture that the same is not possible for the asynchronous π-calculus, suggesting a possible new interpretation of the expressive power of the mixed choice construct.
The remainder of the paper is organised as follows. In Section 2 we define the calculi we shall be considering. Then in Sections 3 and 4 we investigate weak and strong matching systems, respectively. We finish with conclusions and further work.



Calculi
In this section we define the calculi that we shall be concerned with in this paper.
We let x, y,... range over the set of names N. We shall let −→x denote a tuple of names x1,... , xn.
Polyadic synchronisation, where e.g. an output process x · y⟨z⟩.P can synchro- nise with an input process x · y(w).Q, was introduced in [4].
Definition 2.1 The full πn-calculus (fπn) is deﬁned as the polyadic synchronous π-calculus with mixed choice, matching and mismatching, and polyadic synchroni- sation of degree n, that is
P ::= P | Q | νxP | !P | Σiαi.P | [x = y]P | [x /= y]P
where each αi is of the form x1 · ... · xn(−→y ) or x1 · ... · xn⟨−→y ⟩. We let S, T range over summations, and write the empty summation as 0.
Note that fπ1 is the standard full π-calculus. We define the free names fn(P ) as usual, with input and restriction being name-binding.
Definition 2.2 Structural congruence is the least congruence ≡ on fπn processes satisfying the following laws: P | Q ≡ Q | P, (P | Q) | R ≡ P | (Q | R), 0 | P ≡ P, [x = x]P ≡ P, [x /= y]P ≡ P if x /= y, !P ≡ P |!P and νx(P | Q) ≡ P | νxQ if x ∈/ fn(P ), together with reordering of summations.
Definition 2.3 The reduction relation on fπn is deﬁned by the following axiom and

rules

(x1 · ... · xn⟨y1,... , ym⟩.P + S) | (x1 · ... · xn(z1,... , zm).Q + T )
→ P | Q{y1,... , ym/z1,... , zm}

P → Q


P | R → Q | R
P → Q


νxP → νxQ
P ' ≡ P		P → Q	Q ≡ Q' P ' → Q'

We let ⇒ be the reflexive and transitive closure of →.
Definition 2.4 Input and output barbs are deﬁned by
P ↓x1 ·...·xn  iff P ≡ ν−→z ((x1 · ... · xn(−→y ).R + S) | Q) where −→x ∩ −→z = ∅
P ↓x1 ·...·xn  iff P ≡ ν−→z ((x1 · ... · xn⟨−→y ⟩.R + S) | Q) where −→x ∩ −→z = ∅
We let P ⇓x1·...·xn iff P ⇒↓x1·...·xn , and similarly for output barbs.
Definition 2.5 The calculus aπn is deﬁned as the polyadic asynchronous π-calculus with polyadic synchronisation of degree n, that is
P ::= 0 | P | Q | νxP | !P | x1 · ... · xn(−→y ).P | x1 · ... · xn⟨−→y ⟩
The only reduction axiom for aπn is
x1 · ... · xn(y1,... , ym).P | x1 · ... · xn⟨z1,... , zm⟩→ P {z1,... , zm/y1,... , ym}
Note that aπ1 is the standard asynchronous π-calculus. The localised π-calculus Lπ [2,8] is the subset of aπ1 where the recipient of a name may only use it in output actions. We write aπ= to denote aπn with matching [x = y]P .
Definition 2.6 The calculus CCSn is deﬁned as the fragment of fπn which has no name-passing and no matching or mismatching, that is
P ::= P | Q | νxP | !P | Σiαi.P
where each αi is of the form x1 · ... · xn or x1 · ... · xn.
The CCSn synchronisation rule is
(x1 · ... · xn.P + S) | (x1 · ... · xn.Q + T ) → P | Q . 
Note that CCS1 is a form of standard CCS. It resembles the CCS of [9] with replication instead of recursion.
Definition 2.7 The calculus of Mobile Ambients (MA) [5] has the following syntax:
P ::= 0 | P | Q | νxP | !P | x[ P ] | in x.P | out x.P | openx.P
| ⟨x⟩ | (x).P
Here x[ P ] is an ambient named x enclosing P , and in, out, open are the capabilities for entering, leaving or dissolving ambients. We also have asynchronous, anony- mous (no channel) output and input. 4 The free names fn(P ) of a process P are defined much as for the π-calculus, with input and restriction being name-binding.

4 Note that for simplicity we have just defined name-passing communication, whereas communication in [5] allows sequences of capabilities to be transmitted.

Structural congruence and reduction rules are adapted from the π-calculus, with the following reduction axioms:
x[ in y.P | Q ] | y[ R ] → y[ x[ P | Q ] | R ]
y[ x[ out y.P | Q ] | R ] → x[ P | Q ] | y[ R ]
openx.P | x[ Q ] → P | Q
⟨x⟩| (y).P → P {x/y}

Barbs are defined by

P ↓x iff P ≡ ν−→z (x[ P ] | Q) where x ∈/ −→z .

Pure public boxed MA (ppbMA) is got by omitting communication, restriction and the open capability. Recall that the open capability is omitted in the calculus of boxed ambients [3].
Let MA−in denote (full) MA with only the in capability omitted.

Weak Matching Systems
We present the weakened definition of matching system. Then we show that aπ2 has matching systems of every finite degree. We show that CCSn does not have matching systems of degree n + 1 or greater. We then show that matching systems are preserved by encodings satisfying certain properties. We deduce that there is no encoding from aπ2 to CCS satisfying those properties. We also present analogous results concerning ppbMA and CCS.
In matching systems [4], the idea is that clients C communicate with servers S and try to match their parameters, reporting success if there is a match. We change Carbone and Maffeis’s definition of matching system to the following, which applies to all the calculi defined in Section 2:
Definition 3.1 A weak matching system (WMS) of degree n is a tuple (C, S, x1,... , xn) where C and S are processes and x1,... , xn are distinct names, such that for all ﬁnite index sets I and J, and all injective substitutions σi (i ∈ I) and θj (j ∈ J) where dom(σi)= dom(θj)= {x1,... , xn},
(  Cσi |   Sθj) ⇓ω iff ∃i ∈ I, j ∈ J such that σi = θj .
i∈I	j∈J
Here ω is a special name used for reporting a successful match. We require that ω ∈/ 
{x1,... , xn} and that substitutions do not change any xi into ω. Also substitutions should not map any xi into a free name of C or S, other than x1,... , xn. When convenient, we display parameters explicitly, writing Cσ as C⟨σ(x1),... , σ(xn)⟩.
It is easy to see that, in a WMS (C, S, →x), all of →x must be free in both C and S. There are five changes from the pre-existing notion. Firstly, and most impor-
tantly, we do not require that if there is a match then every computation leads to success. Thus we have a “may” notion of success, rather than a “must” notion. Secondly, we do not use replication in the definition (for the server). Thirdly, we

omit the identifier for the client, so that client and server are symmetrical. Fourthly, we allow both client and server to contain free names not drawn from →x. Fifthly, we require that parameters are distinct, so that we are dealing with permutations rather than substitutions in general. This last condition will be useful when we show that matching systems are preserved by encodings (Theorem 3.9).
Note that in standard process calculi a weak matching system never needs to use recursion or replication. It must be the case that (C⟨→x⟩| S⟨→x⟩) ⇓ω by a finite com- putation. We can unfold recursion or replication enough to get this computation, and then set the recursion or replication part to the nil process 0. The modified client and server still give an ω barb when there is a match, and, since we have only reduced behaviour and not added any new behaviour, they still do not yield an ω barb when there is no match.
If a calculus has a WMS of degree n then it has WMSs of all smaller degrees:
Lemma 3.2 Let m  <  n.	If (C, S, x1,... , xn) is a WMS of degree n then
(C, S, x1,... , xm) is a WMS of degree m.	 
We now show that aπ= has weak matching systems of every degree:
Theorem 3.3 For every n ≥ 1, aπ= has a WMS of degree n.
Proof. (Sketch) We define Cn and Sn as follows:
df	'	n	'
n	1	n	1	i
Sn(x1,... , xn) =df νz(x1⟨z⟩| S'	⟨z, x2,... , xn⟩)

S'	(z, xk+1
df	'
n
).([xk+1 = x'
]S'
⟨z, xk+2,... , xn⟩)

n−k
,... ,x ) = z(xk+1
k+1
n−k−1

for k = 1,... ,n − 2
S' (z, xn) =df z(x' ).([xn = x' ]ω)
1	n	n
The server creates a new private name z, which is passed to the client on the first communication on x1. The client then uses this private channel to send the other names back to the server. As each name is received, the server checks that it matches. Notice that the computation can fail even if conducted entirely between a matching client and server, due to the nondeterminism in the order in which the messages from the client are sent. This does not cause a problem, since we are dealing with weak matching systems—a single successful computation is enough. 
Remark 3.4 We recall from [4] that matching can be encoded in aπ2; the process [x = y]P may be encoded as νz(z · x | z · y.P ) where z is fresh. Hence, Theo- rem 3.3 also holds for aπ2. Note also that, in fact, the solution is written in Lπ with matching.
If we try to eliminate the use of matching in the proof of Theorem 3.3 by using communication in an obvious manner, then the proof fails. Consider the case for n = 2. The client process is
df	'	'
C2(x1, x2) = x1(z ).z ⟨x2⟩

as before. The revised server process with matching replaced by communication is

S2(x1, x2) =df νz(x1⟨z⟩| z(x' ).(x'
| x2.ω))

2	2
Now consider
C2(a1, a2) | C2(a' , a' ) | S2(a1, a' ) | S2(a' , a2)
1	2	2	1
where a1, a2, a' , a' are all distinct. This network does not contain a match. However
1	2
there is a computation which succeeds erroneously. Suppose that S2(a1, a' ) receives
a2 from C2(a1, a2). It should then check a2 against a' , which should fail. Suppose
also that S2(a' , a2) receives a' from C2(a' , a' ). It should then check a' against a2,
1	2	1	2	2
which should again fail. But we can get a crossover between the two checks, so that
they both succeed erroneously.
We can also define matching systems using ambients:
Theorem 3.5 For every n ≥ 1, ppbMA has a WMS of degree n.
Proof. Let
Cn =df m[ in x1. ··· .in xn.out xn	out x1.ω[ out m ]] 
Sn df
= x1[ x2[ ... xn[ ]	]] .
The idea is that the client enters successively the stacked x1,... , xn ambients of the server, before returning to the top level to report success. The client simply gets stuck if there is no match.	 
We next investigate matching systems for CCS.
Theorem 3.6 Let m, n ≥ 1. Then CCSn has a WMS of degree m if and only if
n ≥ m.
Proof. (Sketch) First suppose that n ≥ m. We define a WMS of degree m in CCSn as follows:
Cm =df x1 · ... · xm	Sm =df x1 · ... · xm.ω
Notice that this WMS is guaranteed to succeed, and so it is in fact a strong MS, to be defined in Section 4.
For the converse direction, by Lemma 3.2 it is enough to show that CCSn does not have a WMS of degree n + 1.  So suppose for a contradiction that (C, S, x1,... , xn+1) is a WMS of degree n + 1 in CCSn. We shall show that there is a combination of clients and servers which does not contain a match, and yet erroneously returns success.
There is k ≥ 0 and there are Ci, Si (0 ≤ i ≤ k) such that
C | S = C0 | S0 → ··· → Ck | Sk	where (Ck | Sk) ↓ω .
This holds because there is a match between the single client and and the single server (using the identity substitution in both cases). Note that during the com- putation we may have to extrude the scope of restrictions in order to obtain the necessary redex, but we can then immediately return the scopes so that they lie

entirely within Ci+1 or Si+1. This returning of scopes would not in general be pos- sible in the π-calculus, where restricted names can be transmitted along channels, resulting in more than one process sharing the same restricted name.

Let x' ,... , x'
be distinct fresh names different from x1,... , xn+1. Let s =

1	n+1
s1 ··· sn+1 range over binary strings in {0, 1}n+1. Let σs be the substitution which
sets
σ (x ) =df ⎧⎨ xi if si =0 
s	i
x'  if si =1 
Let E = {s ∈ {0, 1}n+1 : s has an even number of 1s} and O = {s ∈ {0, 1}n+1 :
s has an odd number of 1s}. For i = 0,... ,k let
Pi =df   Ciσs |   Siσs
s∈E	s∈O
Then P does not contain a match. We show that P →2n P	for i = 0,... ,k − 1. Since plainly Pk ↓ω, we shall have a contradiction.
There are various cases
Suppose that Ci → Ci+1 with Si+1 = Si. Then for each s ∈ E we have
Ciσs → Ci+1σs, and for each s ∈ O we have Si+1σs = Siσs.
The case where Si → Si+1 with Ci+1 = Ci is handled like the preceding case.
Suppose that Ci | Si → Ci+1 | Si+1 by a communication on channel y1 · ... · yn.
Let j be such that xj ∈/ −→y . Let s ∈ E. Let t be the same as s except that
tj = 1 − sj. Then t ∈ O. Also, Ciσs and Siσt can communicate on channel σs(y1) · ... · σs(yn) to produce Ci+1σs | Si+1σt. In this way we pair off all clients and servers and we produce Pi+1 after 2n reductions.

The next result suggests that the in capability is needed to obtain WMSs for MA.
Theorem 3.7 For n ≥ 2, there is no WMS of degree n in pure MA−in.
Proof. (Sketch) We adapt the method used in the proof of Theorem 3.6. We suppose that we have a WMS of degree 2, and show for a contradiction that
C⟨x1, x2⟩| C⟨x' , x' ⟩| S⟨x' , x2⟩| S⟨x1, x' ⟩
1	2	1	2
has a successful computation. This is possible because the clients and servers can only interact at the top level of the ambient tree, due to the absence of the in capability.	 
Conjecture 3.8 For n ≥ 2 there is no WMS of degree n in pure MA without the
out capability.	 
We now establish conditions under which matching systems are preserved when encoding one language in another. Our result (Theorem 3.9) will apply to all the languages defined in Section 2.
We assume that we are dealing with process calculi L with a notion of weak barb P ⇓x such that for any permutation σ, P ⇓ω iff σ(P ) ⇓σ(ω). This holds for any

process calculus in the π-calculus family (including ambient calculi). We shall also assume that all calculi have the same set of names N, and that N is infinite.
The next theorem shows that weak matching systems are preserved by encodings satisfying certain conditions. The first two conditions are similar to those used by Palamidessi [10]. In the third condition, the injection ϕ and its properties are similar to Gorla’s “strict renaming policy” [7]. The idea is that names of the source language are mapped across to unique names in the target language by ϕ, with the names which are not in the range of ϕ being available as “reserved names” for use in the encoding (so ϕ could be the identity if the encoding required no reserved names). The encoding of a process P should not depend on the particular names in P , since names have no structure or meaning. This idea is expressed by requiring a property of invariance under injective substitution, mediated by ϕ.
Theorem 3.9 Let L and L' be process calculi. Let [[−]] : L → L' be an encoding satisfying:
P ⇓ω iff [[P ]] ⇓ω;
[P | Q]] = [[P ]] | [[Q]];
There is an injective ϕ : N → N with ϕ(ω) = ω, such that for all ﬁnite injective substitutions σ, if P is such that rge(σ) ∩ fn(P ) = ∅ then we have [[P σ]] = [[P ]]σ', where the injective substitution σ' is deﬁned by
σ'(ϕ(x)) = ϕ(σ(x))	if x ∈ dom(σ)
σ'(x) undeﬁned	otherwise
−−→
Let (C, S, →x) be a weak matching system of degree n in L. Then ([[C]], [[S]], ϕ(x)) is
a weak matching system of degree n in L'.


Proof. (Sketch) Consider

P =df  [[C]]σi |  [[S]]θj

i∈I	j∈J
where dom(σi)= dom(θj)= {ϕ(x1),... , ϕ(xn)}. We need to show that P ⇓ω iff P
has a match, i.e. there are i ∈ I and j ∈ J such that σi = θj.
Let A = i∈I rge(σi) ∪ j∈J rge(θj). Let B be a set of names in bijection with A via f : A → B, such that for each x ∈ B, both x and ϕ(x) are fresh. This is always possible, since we assume that N is infinite.
For each i ∈ I and each k = 1,... , n, let
σ'(xk) =df f (σi(ϕ(xk))) .
Similarly, for each j ∈ J and each k = 1,... , n, let
θ' (xk) =df f (θj(ϕ(xk))) .
Then σ', θ' are finite injective substitutions. Also σ'(xk), θ' (xk) ∈/ {ω}∪ fn(P ) ∪
i	j	i	j
fn(Q), since all x ∈ B are fresh.

Now P has a match iff


df
Q =
i∈I


Cσ' |

 

j∈J


Sθ'

has a match. This is because Q has a match iff ∃i, j. ∀k. f (σi(ϕ(xk))) = f (θj(ϕ(xk))) iff ∃i, j. ∀k. σi(ϕ(xk)) = θj(ϕ(xk)) (since f is a bijection) iff P has a match.
By property (iii) of the encoding, for each i ∈ I there is σ'' such that [Cσ']] =
i	i
[[C]]σ'' where σ''(ϕ(xk)) = ϕ(σ'(xk)). Similarly, for each j ∈ J there is θ'' such that
i	i	i	j
[[Sθ' ]] = [[S]]θ'' where θ''(ϕ(xk)) = ϕ(θ' (xk)).
j	j	j	j
Now Q has a match iff Q ⇓ω (since (C, S, −→x ) is a WMS). Also, Q ⇓ω iff [Q]] ⇓ω (property (i) of the encoding). Using property (ii) of the encoding, we have [Q]] = R, where
R =df  [[C]]σ'' |  [[S]]θ''


i∈I
i	j
j∈J

Notice that σ''(ϕ(xk)) = ϕ(σ'(xk)) = ϕ(f (σi(ϕ(xk)))).	Similarly, θ''(ϕ(xk)) =
i	i	j
ϕ(θ' (xk)) = ϕ(f (θj(ϕ(xk)))). Also note that rge(σ'') ∩ ((fn([[C]]) ∪ fn([[S]])) \
{ϕ(x1),... , ϕ(xn)}) = ∅, since all y ∈ ϕ(B) are fresh. Similarly for rge(θ''). Since f and ϕ are injective, we can extend their composition ϕ(f (·)) to a suitable per- mutation ρ which leaves ω unchanged, such that R = P ρ. But then R ⇓ω iff P ⇓ω (property of L').
Combining, we have: P has a match iff P ⇓ω, as required.	 

We can use Theorem 3.9 and our various preceding positive and negative results to state some non-encodability results:
Theorem 3.10 There is no encoding satisfying the conditions of Theorem 3.9 from
aπ= to CCSn (all n ≥ 1).
Proof. By Theorems 3.3, 3.6 and 3.9.	 

In connection with Theorem 3.10, we note that Carbone and Maffeis showed that

there is no sensible encoding from aπ=
into the standard π-calculus with mixed

choice (and without matching) [4, Theorem 4.1]. Our result here uses different conditions and holds for all levels of polyadic synchronisation in CCS.
Theorem 3.11 There is no encoding satisfying the conditions of Theorem 3.9 from ppbMA to CCSn (all n ≥ 1).

Proof. By Theorems 3.5, 3.6 and 3.9.	 

Concerning Theorem 3.11, Phillips and Vigliotti [12] showed there is no encoding (under different conditions) from pure public MA (with open) to CCS. Previously they showed that there is no encoding (under yet other conditions) from pure public boxed MA to aπ1 [11].

Strong Matching Systems
In this section we investigate strong matching systems, where if there is a match then every computation is guaranteed to succeed. We show that the full π-calculus fπ1 has strong matching systems of every finite degree (Theorem 4.4).
Definition 4.1 A strong matching system (SMS) of degree n is a tuple (C, S, x1,... , xn) where C and S are processes and x1,... , xn are distinct names, such that for all ﬁnite index sets I and J, and all substitutions σi (i ∈ I) and θj (j ∈ J) where dom(σi)= dom(θj)= {x1,... , xn}, deﬁning
MS =df   Cσi |   Sθj

i∈I
if MS ⇓ω then ∃i ∈ I, j ∈ J. σi = θj;
j∈J

if ∃i ∈ I, j ∈ J. σi = θj then ∀MS'. MS ⇒ MS' implies MS' ⇓ω;
there are no inﬁnite reduction sequences starting from MS.
A replicated SMS (!SMS for short) is deﬁned as an SMS, except that we require the servers to be replicated, so that

df
MS =
i∈I
Cσi
| 
j∈J
!Sθj

Observe that if (C, S, −→x ) is a !SMS then (C, !S, −→x ) is an SMS. Also, if (C, S, −→x ) is an SMS then (C, S, −→x ) is a WMS.
The notion of !SMS is quite close to the original formulation of matching system in [4]. It differs from the original MS in two ways: Firstly, we omit the identifier for the client, so that client and server are symmetrical. Secondly, we allow both client and server to contain free names not drawn from −→x .
The next result is similar to [4, Theorem 4.2]:
Theorem 4.2 For all non-negative integer numbers n and m, there is a !SMS of degree m in fπn if and only if n ≥ m.
Proof. (⇐) Choosing
Cm =df x1 · ... · xm⟨⟩	Sm =df x1 · ... · xm(z).ω⟨⟩
we have that (Cm, Sm, x1,... , xm) is a strong matching system of degree m.
(⇒) The idea is that a client can be endlessly “fooled” into interaction with servers which only partially match, giving rise to an infinite computation.
Consider the minimal case where m = n + 1 and suppose (C, S, x1,... , xm) is a
!SMS of degree m in πn. Let σ be an injective substitution of fresh names. Then
P =df Cσ | Sσ
is a matching instance of (C, S, x1,... , xm). Note that for any such σ and any R, if there is a Q such that Rσ ⇒ Q then there is also an R' such that R ⇒ R' and Q = R'σ.
By point (iii) of Definition 4.1, there must be C' and S' such that Cσ ⇒ C'σ
and C'σ /→, and similarly Sσ ⇒ S'σ and S'σ /→. By point (ii) of Definition 4.1, it

must be the case that P ⇒ (C'σ | S'σ) ⇓ω. By the contrapositive of point (i) of Definition 4.1, it must be the case that C'σ /↓ω and Sσ /↓ω. Hence, it must be the case that C'σ | S'σ → P ' ⇓ω for some appropriate P '.
By definition of reduction, without loss of generality, we can assume that C'σ ↓−→a

,... ,C'σ ↓−→ and S'σ ↓
,... , S'σ  ↓
−→	−→	1

ak	−→a1
−→, where
k
a1,... , ak are all of the possible

channels on which the two processes are ready to communicate. Since m > n, for
each j ∈ [1..k] there exists i such that σ(xi) /∈ −→a . Let ρ be defined as ρ (x )= d ,
for a fresh dj, and ρj(xh) = σ(xh) otherwise. By construction, since both σ and each ρj are injective and fresh, we have Sρj ⇒ S'ρj. Since σ and ρj agree on −→aj , it must be the case that S'ρj ↓−→. By the contrapositive of point (i) of Definition 4.1,
j

it must be the case that
P0 = (Cσ | Sρj) /⇓ω .

However, because of the complementary barbs, there must be Pj such that Pj → Pj.

Still, since

j df	j
1	0	1

P2 = P0 | Sσ
is a valid instance of a matching system, by point (ii) it must be the case that
Pj ⇓ω. Moreover, since

Pj ⇒
j df	j

2
it must be the case that Pj ⇓ω.
P3 = (P1 | Sσ)

We have established above that there must be S' such that Sσ ⇒ S'σ and S'σ /→, and S'σ ↓−→,... , S'σ ↓−→. Similarly, there must be Pj such that Pj ⇒ Pj ↓−→ for

a1	ak
4	1	4	ai

some i in [1..k]. By considering now
P0 =df Cσ |    !Sρj
j∈[1..k]
we have a contradiction because the system can enter a loop: each Sρj intercepts the corresponding attempt that Cσ must keep repeating in order to communicate with a potential matching server Sσ.	 
Theorem 4.3 For n ≥ 2, there is no !SMS of degree n in MA.
Proof. The idea is similar to the proof of Theorem 4.2.	 
By contrast with Theorem 4.2, we show that fπ1 is strong enough to have SMSs of all degrees:
Theorem 4.4 There is a strong matching system of degree n in fπ1.
Proof. (Sketch) Lists and operations on lists can be encoded in fπ1 without intro- ducing divergence, using only restricted names (we consider the encoding given by Turner [14]). For example the list [a, b], accessible through channel x, is represented by the process νy, z(!x(n, c).c⟨a, y⟩ |!y(n, c).c⟨b, z⟩ |!z(n, c).n⟨⟩). Note that this list above can be passed around as a single value by passing the name x. Below, we
use the context L[− df  −→	| −) to denote the machinery to implement lists and

head, tail, concatenation, etc. operations in fπ1. We assume that the names −→,
used to implement the list operations, are fresh, and that fn(L[0]) = ∅. Consider the processes
Cn =df L[e⟨[x1,... , xn], [ ]⟩]
df	⎛a⟨[ ], [x1,... , xn]⟩ |!a(x, y).(e⟨x, y⟩+ ⎞

Sm = L[νa ⎝

'	' 	'
'  ⎠]

e(z, w).F (x@z, y@w, x ,y ).a⟨x ,y ⟩)
where function F takes as input the lists x@z, y@w and returns the lists x', y' obtained by removing all the matching pairs from x@z and y@w (@ stands for list concatenation). For each matching pair, F produces the barb ω. Such a function can be implemented in fπ1 without introducing divergence, and is defined in OCAML by the code
let rec rd = function (l1,[],l3,[]) -> [l1,l3]
|(l1,[],l3,b::l4) -> rd(l1,[],l3@[b],l4)
|(l1,a::l2,l3,[]) -> rd(l1@[a],l2,[],l3)
|(l1,a::l2,l3,b::l4) -> if a=b then barb(omega); rd(l1,l2,[],l3@l4)
else rd(l1,a::l2,l3@[b],l4)

where barb is a user-defined function representing the barb. Note that the last clause defining F uses the conditional with a boolean guard given by name matching; this operation can be easily encoded in fπ1 because the language contains name matching and mismatching.	 
There is an essential use of mixed choice in the proof of Theorem 4.4. We conjecture that without mixed choice it is impossible to get SMSs of degree higher than the level of synchronisation in the language:
Conjecture 4.5 For m > n there is no SMS of degree m in aπn.

Conclusions and Further Work
We have adapted the notion of matching system from earlier work by Carbone and Maffeis. We have seen that there are two main types of matching system, the weak and the strong, depending on whether successful termination is possible or guaranteed (in the event of a match between some client and some server). In the strong case, there are two subtypes of matching system, depending on whether the server is required to be a replication or not (the former being the stronger of the two).
These notions can be used to “grade” process calculi according to how good they are at treating synchronisation on several different names as a single transaction.
We have seen that the full π-calculus is strong enough to have strong matching systems of all degrees, but not strong enough to have replicated strong matching systems of degree greater than one.

We also showed that the asynchronous π-calculus with matching has weak match- ing systems of every finite degree. Our work leaves open the question of whether the asynchronous π-calculus has a strong matching system of degree two or higher. We conjecture that the answer is no.
We showed that the calculus of Mobile Ambients has weak matching systems of all finite degrees. Furthermore, MA does not have replicated strong matching systems of degree two or higher. Our work leaves open the question of whether MA has a strong matching system of degree two or higher. Again, we conjecture that the answer is no.
We showed that CCS does not have weak matching systems of degree greater than one. By our result on preservation of weak matching systems by suitable en- codings, we could deduce a non-encodability result for the asynchronous π-calculus with matching into CCS with all levels of polyadic synchronisation.

Acknowledgements
We thank Uwe Nestmann, Diletta Cacciagrano and the anonymous referees for their helpful comments and suggestions.

References
Banach, R. and F. van Breugel, Mobility and modularity: expressing pi-calculus in CCS (extended abstract) (1998), draft.
Boreale, M., On the expressiveness of internal mobility in name-passing calculi, Theoretical Computer Science 195 (1998), pp. 205–226.
Bugliesi, M., G. Castagna and S. Crafa, Access control for mobile agents: the calculus of Boxed Ambients, ACM Transactions on Programming Languages and Systems 26 (2004), pp. 57–124.
Carbone, M. and S. Maffeis, On the expressive power of polyadic synchronisation in π-calculus, Nordic Journal of Computing 10 (2003), pp. 70–98.
Cardelli, L. and A.D. Gordon, Mobile ambients, Theoretical Computer Science 240 (2000), pp. 177–213.
De Nicola, R. and M. Hennessy, Testing equivalences for processes, Theoretical Computer Science 34
(1984), pp. 83–134.
Gorla, D., Comparing calculi for mobility via their relative expressive power, Technical Report 05/2006, Dip. di Informatica, Univ. di Roma “La Sapienza”, Italy (2006).
Merro, M. and D. Sangiorgi, On asynchrony in name-passing calculi, Mathematical Structures in Computer Science 14 (2004), pp. 715–767.
Milner, R., “Communicating and Mobile Systems: the π-calculus,” Cambridge University Press, 1999.
Palamidessi, C., Comparing the expressive power of the synchronous and the asynchronous π-calculi, Mathematical Structures in Computer Science 13 (2003), pp. 685–719.
Phillips, I.C.C. and M. Vigliotti, Electoral systems in ambient calculi, in: Proceedings of 7th International Conference on Foundations of Software Science and Computation Structures, FoSSaCS 2004, Lecture Notes in Computer Science 2987 (2004), pp. 408–422.
Phillips, I.C.C. and M. Vigliotti, Leader election in rings of ambient processes, Theoretical Computer Science 356 (2006), pp. 468–494.
Sangiorgi, D., π-calculus, internal mobility and agent-passing calculi, Theoretical Computer Science
167 (1996), pp. 235–274.

Turner, D.N., “The Polymorphic Pi-calculus: Theory and Implementation,” Ph.D. thesis, University of Edinburgh (1995).
