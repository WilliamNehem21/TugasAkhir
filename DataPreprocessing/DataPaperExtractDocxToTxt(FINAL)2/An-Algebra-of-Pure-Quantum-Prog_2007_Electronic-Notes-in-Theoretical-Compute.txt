Electronic Notes in Theoretical Computer Science 170 (2007) 23–47	
www.elsevier.com/locate/entcs

An Algebra of Pure Quantum Programming
Thorsten Altenkirch1	Jonathan Grattage1
The University of Nottingham, UK
Juliana K. Vizzotto2
Federal University of Rio Grande do Sul, Brazil
Amr Sabry3
Indiana University, USA

Abstract
We develop a sound and complete equational theory for the functional quantum programming language QML. The soundness and completeness of the theory are with respect to the previously developed denotational semantics of QML. The completeness proof also gives rise to a normalisation algorithm following the normalisation-by-evaluation approach. The current work focuses on the pure fragment of QML, omitting measurements.
Keywords: Denotational semantics, completeness, normalisation.


Introduction
The functional quantum language QML was recently introduced by Altenkirch and Grattage [2]. The semantics of QML is inspired by the denotational semantics of classical reversible computations; it provides a foundation for reasoning about quantum programs by mapping them to their denotations.

1 Email:  txa,jjg @cs.nottingham.ac.uk
2 Email: jkv@inf.ufrgs.br
3 Email: sabry@indiana.edu




1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2006.12.010

The next natural step is to develop reasoning principles on QML programs themselves, which avoid the detour via the denotational semantics. For ex- ample, consider the following QML definition of the Hadamard gate:
H x = if◦ x
then (false + (  1)  true )
else  (false + true)
We would like to verify that H (H x ) is observationally equivalent to x , using a derivation such as:
H (H x )= if◦ (if◦ x
then (false + (  1)	true)
else (false + true )) then (false + ( 1)	true) else (false + true)
-- by commuting conversion for if◦
= if◦ x
then if◦ (false + ( 1)	true) then (false + ( 1)		true) else (false + true)
else  if ◦ (false + true)
then (false + (  1)	true)
else  (false + true)
-- by if◦
= if◦ x
then (false − false + true + true)
else  (false + false + true − true)
-- by simplification and normalisation
= if◦ x then true else false
-- by η-rule for if◦
= x
It is relatively easy to develop some set of sound equational principles. Inspired by equivalences on classical computations, one may hypothesise that certain equations should hold, and simply verify that both sides of the equation have the same denotation.
However, as QML is based on a first-order functional language with finite types, it should be possible to also develop a complete set of equivalences that totally capture denotational equivalence. Technically, one can prove complete- ness of the equational semantics by “inverting” the denotational meaning- function. The construction is subtle in parts. We present it firstly in the

context of the classical sub-language of QML, and then extend it to deal with quantum data and control.
The paper is thus organised as follows. We begin with a quick survey of related work followed by an informal review of QML in Section 3. In Section 4, we present the denotational semantics of the classical sub-language of QML, and present a system of equations which is sound with respect to the denotational semantics. We then show that this set of equations is complete in Section 5. Section 6 repeats the development for the quantum constructs. Section 7 concludes.

Related work
Selinger’s influential paper [5] introduces a single-assignment (essentially func- tional) quantum programming language, which is based on the separation of classical control and quantum data. This language combines high-level classi- cal structures with operations on quantum data, and has a clear mathematical semantics in the form of superoperators. Quantum data can be manipulated by using unitary operators or by measurement, which can effect the classical control flow.
Recently, Selinger and Valiron [6] have presented a functional language based on the same classical control and quantum data paradigm. Selinger and Valiron’s approach is in some sense complementary to ours: they use an affine type system (no contraction), while we use a strict system (no weakening). The lack of contraction is justified by the no-cloning property of quantum states. However, this does not apply to our approach, since we model contraction not by copying but by sharing — this idea is also present in the calculus of Arrighi and Dowek [1].
Van Tonder [8,7] has proposed a quantum λ-calculus incorporating higher- order programs, but no measurements. He suggests an equational theory for strict (higher-order) computations, but shows neither completeness nor normalisation.

QML Syntax and Examples
The QML terms consist of those of a first-order functional language, extended with quantum data and quantum control. The full language also includes quantum measurement, which we do not consider in this paper. The syntax of terms is as follows:
(Variables)	x , y, ... ∈ Vars
(Prob.amplitudes) κ, ι, ... ∈  C

(Patterns)	p, q	::= x	(x , y )
(Terms)	t, u, e ::= x	()  (t, u)
let p = t in u
'
|	if  t then u else u
|	false | true | −→0 | κ ∗ t | t + u
The classical sub-language consists of variables, let-expressions, unit, pairs, booleans, and conditionals. Quantum data is modelled using the constructs κ t , −→0, and t +u. The term κ t , where κ is a complex number, associates the
probability amplitude κ with the term t . It is convenient to have a special con- stant −→0 for terms with probability amplitude zero. The term t + u is a quan- tum superposition of t and u. Quantum superpositions are first-class values:
when used as the first subexpression of a conditional, they turn the conditional into a quantum control construct. For example, if◦ (true +false) then t else u evaluates both t and u and combines their results in a quantum superposition.

Examples
To provide further insight into the semantics of QML, we consider a few inter- esting examples. In these examples, we allow the definition and use of “global” function symbols. Adding such definitions to the formalism is possible but te- dious, so we keep them at an informal meta-level.
The following three functions correspond to simple rotations on qubits:
qnot x = if◦ x then false else true
had x = if◦ x then ((−1) ∗ true + false) else (true + false)
z x   = if◦ x then ((−1) ∗ true) else false
The first is the quantum version of boolean negation; it behaves as usual when applied to classical values but it also applies to quantum data. Evaluating qnot (κ false + ι true) swaps the probability amplitudes associated with false and true. The second function represents the fundamental Hadamard matrix, and the third represents the Pauli-Z operator.
The function:
cnot cx = if◦ c
then (true, qnot x )
else  (false, x )
is the conditional-not operation, which behaves as follows: if the control qubit c is true it negates the second qubit x ; otherwise it leaves it unchanged. When the control qubit is in some superposition of true and false, the result is a superposition of the two pairs resulting from the evaluation of each branch of the conditional. For example, evaluating cnot (false + true) false produces the entangled pair (false, false)+ (true, true).

Copying and Discarding Quantum Data
To motivate the main aspects of the type system in the next section, we examine in detail the issues related to copying and discarding quantum data.
A simple example where quantum data appears to be copied, in violation of the no-cloning theorem [4], is:
let x = false + true
in (x , x )
As the formal semantics of QML clarifies, this expression does not actually clone quantum data; rather it shares one copy of the quantum data. In other words the expression does not evaluate to (false + true, false + true) which would make it impossible to realise. Rather the expression evaluates to (false, false)+ (true, true) which is realisable (and easily so). With this inter- pretation, one can freely duplicate variables bound to quantum data. When translated to the type system, this means that the type system imposes no restrictions on the use of the structural rule of contraction.
Discarding variables bound to quantum data, however, is problematic.
Consider the expression:
let (x , y )= (false, false)+ (true, true)
in x
where the quantum data bound to y is discarded. According to both the phys- ical interpretations of quantum computation and the semantics of QML, this corresponds to a measurement of y . Since measurement is semantically quite complicated to deal with, we insist that it should be represented explicitly. The language we consider in this paper lacks the explicit constructs for mea- surement so we reject the expression above. This means that the structural rule of weakening is never allowed in situations where information may be lost. More precisely the only value to which weakening applies is the unit value () as it carries no information.

The Classical Sub-language
By the classical sub-language, we mean the subset of terms excluding quantum superpositions. This also precludes the use of quantum control.
Type System
The main rˆole of the type system is to control the use of variables. The typing rules of QML are based on strict linear logic, where contractions are implicit and weakenings are not allowed when they correspond to information loss. As explained in the previous section, weakenings correspond to measurements,

which are not supported in the subset of the language discussed in this paper.
We use σ, τ, ρ to vary over QML types which are given by the following grammar:
σ = Q1 | Q2 | σ ⊗ τ
where Q1 is the type of (), and Q2 is the type of qubits. As apparent from the grammar, QML types are first-order and finite; there are no higher-order types and no recursive types. The only types we can represent are the types of collections of qubits.
Typing contexts (Γ, Δ) are given by:
Γ= •| Γ, x : σ
where stands for the empty context, but is omitted if the context is non- empty. For simplicity we assume that every variable appears at most once. Contexts correspond to functions from a finite set of variables to types. We introduce the operator ⊗, which maps pairs of contexts to contexts:
(Γ,x : σ) ⊗ (Δ,x : σ) = (Γ ⊗ Δ),x : σ
(Γ,x : σ) ⊗ Δ	= (Γ ⊗ Δ),x : σ if x ∈/ dom (Δ)
•⊗ Δ	= Δ
As explained in the typing rules, the operator allows us to share variables appearing in a given context. This operation is partial: it is only well-defined if the two contexts do not assign different types to the same variable. Whenever we use this operator we implicitly assume that it is well-defined.
Figure 1 presents the rules for deriving valid typing judgements Γ t : σ. The only variables that may be dropped from the context are the ones of type Q1 which, by definition, carry no information. Otherwise the type system forces every variable in the context to be used (perhaps more than once if it is shared).
The Category of Typed Terms
The set of typed terms can be organised in an elegant categorical structure, which facilitates some of the proofs given later. The objects of the category are contexts; the homset between the objects Γ and Δ, denoted Tm Γ Δ, consists of all terms t such that Γ ▶ t : |Δ| where |Δ| views the context Δ as a type. This latter map is defined as follows:
|•| = Q1
|Γ,x : σ| = |Γ|⊗ σ



Fig. 1. Typing classical terms

For each context Γ, the identity 1Γ ∈ TmΓΓ is defined as follows:

1• = ()
1Γ,x:σ = (1Γ, x)

Given d ∈ TmΔΓ and e ∈ Tm Γ Θ, the composition e ◦ d ∈ TmΔΘ is given by the term let∗ Γ= d in e. The let∗ construct is an abbreviation for iterated let-expressions which bind each of the variables in the intermediate context:
let∗ • = d in e	≡	e
let∗ Γ, x : σ = d in e	≡	let (xr, x )= d in let∗ Γ= xr in e
 Δ ▶ d : |Γ|	Γ ▶ e : |Θ| 
Δ ▶ let Γ= d in e : |Θ|



Semantics
The intention is to interpret every type σ and every context Γ as finite sets σ)
and  Γ), and then interpret a judgement Γ ▶ t : σ as a function  Γ ▶ t : σ) ∈
 Γ) →  σ). In the classical case, the type Q2 is simply the type of booleans

and ⊗ is the standard product type:

 Q1) = {0}
 Q2) = {0, 1}
 σ ⊗ τ ) =  σ) × τ )

We use the abbreviation  Γ) for  |Γ|).
The meaning function is defined in Figure 2 by induction over the structure of type derivations. It uses the following auxiliary maps:
id : S → S defined by id (a)= a
id ∗ : S →  Q1) × S and its inverse id ∗ defined by id ∗(a) = (0, a) and
id∗(0, a)= a
For a  S, the family of constant functions const a :  1)  S defined by (const a)(0) = a.
δ : S → (S, S) defined by δ(a)= (a, a)
swap : S  T  T  S defined by swap(a, b) = (b, a). We will usually implicitly use swap to avoid cluttering the figures with maps which just re-shuffle values.
For any two functions f ∈ S1 → T1 and g ∈ S2 → T2, the function (f × g): (S1 × S2) → (T1 × T2) is defined as usual:

(f × g)(a, b) = (f a, g b)

δΓ,Δ : Γ ⊗ Δ) → Γ) × Δ). This map is defined by induction on the definition of Γ ⊗ Δ as follows:
⎧⎪ δΓ',Δ' × δ if Γ = Γ',x : σ and Δ = Δ',x : σ δΓ,Δ =	δΓ',Δ × id if Γ = Γ',x : σ and x /∈ dom (Δ)

⎪⎪⎩
id ∗ if Γ = •


Intuitively, the map δΓ,Δ takes an incoming environment for an expression, creates shared copies of the appropriate values, and rearranges them (the shuffling is implicit and not shown in the above definition) into two envi- ronments that are then passed to the subexpressions.
For any two functions f, g ∈ S → T , we define the conditional f |g ∈



Fig. 2. Meaning of classical derivations
( Q2) × S) → T as follows:
(f |g) (1, a) = f a
(f |g) (0, a) = g a 

Equational Theory
We present the equational theory for the classical sub-language and then show its soundness and completeness. The equations refer to a set of syntactic values defined as follows:
val ∈ ValC ::= x | () | false | true | (val1, val2)
Definition 4.1 The classical equations are grouped in four categories. The equations are implicitly typed and this entails conditions on the occurrence of variables, e.g., the first commuting conversion can only be well-typed if the variables bound in p and q do not appear in t or u.
let-equation
let p = val in u	≡	u [val / p ]
β-equations

let (x , y )= (t, u) in e	≡	let x = t in let y = u in e
if◦ false then t else u	≡	u
if◦ true then t else u	≡	t
η-equations
()	≡	t	-- if t:Q1
let x = t in x	≡	t
let (x , y )= t in (x , y )	≡	t
if◦ t then true else false	≡	t
Commuting conversions
let p = t in let q = u in e	≡	let q = u in let p = t in e
let p = if◦ t then u0 else u1	≡	if◦ t
in e	then let p = u0 in e
else  let p = u1 in e
We write Γ	t	u : σ if Γ	t, u : σ and the equation t	u is derivable at the type σ.
Lemma 4.2 (Soundness) The equational theory is sound: if Γ ▶ t ≡ u : σ
then the functions  Γ ▶ t : σ) and  Γ ▶ u : σ) are extensionally equal.

Completeness of the Classical Theory
The equational theory is complete in a strong technical sense: any equivalence implied by the semantics is derivable in the theory. The proof technique is based on recent work by Altenkirch with Uustalu [3]. The proof presented here extends and simplifies the method presented in that work.

Proof Technique
The ultimate goal is to prove the following statement.
Proposition 5.1 (Completeness) If  Γ ▶ t : σ) and  Γ ▶ u : σ) are exten- sionally equal, then we can derive Γ ▶ t ≡ u : σ.


In order to prove this statement, we define a function qσ
which inverts

evaluation by producing a canonical syntactical representative. In fact, we define the function qσ such that it maps a denotation  Γ ▶ t : σ) to the normal
form of t.
Definition 5.2 If Γ ▶ t : σ, the normal form of t is given by nfσ(t) =
qσ( Γ ▶ t : σ)).

The normal form is well-defined: given an equation Γ		t	u : σ, we know by soundness that Γ	t : σ) is extensionally equal Γ	u : σ) and hence
we get that nfσ(t) = nfσ(u). If we now show that the syntactic theory can
Γ	Γ
prove that every term is equal to its normal form, then we can prove the
main completeness result. Indeed given the following lemma, we can prove completeness.
Lemma 5.3 (Inversion) If Γ ▶ t : σ, the equation Γ ▶ nfσ(t) ≡ t : σ is
derivable.
Proof of Proposition 5.1 (Completeness) We have:
Γ ▶ t ≡ qσ Γ ▶ t : σ) : σ by inversion
Γ ▶ q  Γ ▶ t : σ) ≡ q  Γ ▶ u : σ) : σ by assumption
Γ	Γ
Γ ▶ qσ Γ ▶ u : σ) ≡ u : σ by inversion


In summary, we can establish completeness by defining a function qσ that
inverts evaluation and that satisfies Lemma 5.3.

Adequacy
We begin by defining a family of functions qσ (quote) which invert the eval- uation of closed terms and prove a special case of the inversion lemma for closed terms called adequacy. These functions and the adequacy result are then used in the next section to invert the evaluation of open terms and prove the general inversion lemma.
Definition 5.4 The syntactic representation of denotations is given by:
qσ ∈  σ) → ValCσ
defined by induction over σ:
qQ1 0 = ()
qQ2 0 = false
qQ2 1 = true
qσ⊗τ (a, b) = (qσ a, qτ b)

The instance of the inversion lemma for closed terms is called adequacy. It guarantees that the equational theory is rich enough to equate every closed term with its final observable value.
Lemma 5.5 (Adequacy) The equation  qσ(   t : σ) 0)  t : σ is deriv- able.
Proof sketch. During the proof of such a statement we encounter open terms that must be closed before they are “quoted.” So in fact the statement to prove by induction over typing derivations is the following:
If g ∈ Γ) then ▶ qσ( Γ ▶ t : σ) g) ≡ let∗ Γ= qΓ (g ) in t : σ


Inverting Evaluation
As explained earlier, the main ingredient of the proof of completeness is the function qσ which inverts evaluation. To understand the basic idea of how the inverse of evaluation is defined, consider the following example. Let Γ be the environment x : (Q2 ⊗ Q2),y : Q2 and let f ∈ Γ) → Q2). To find a syntactic term corresponding to f , we proceed as follows:
Flatten all the products by introducing intermediate names which produces an updated environment Γ' = x1 : 2, x2 : 2,y : 2, and an updated semantic function f ' such that:
f ' ((((), x1), x2), y)= f (((), (x1, x2)), y)
Enumerate all possible values for the variables, and apply f ' to each enu- meration to produce a result in the set  Q2). For example, it could be the case that f (((), (1, 1)), 1) = 0. The result of each enumeration can be inverted to a syntactic term using qσ from Definition 5.4.
Put things together using nested conditions representing all the possible values for the input variables. In the example we are considering, we get:
let (x1 , x2 )= x
in if◦ x1
then if◦ x2
then if◦ y then false
else	...
else	...
else	...
The idea is formalised in the following definition.

Definition 5.6 The function
qσ ∈ ( Γ) →  σ)) → Tm Γ σ
for inverting evaluation is defined by analysing the context:
qσ(f ) = qσ (f (0))
qσ	(f ) = qσ (h)	where h(g)= f (g, 0)
Γ,x:Q1	Γ
qσ	(f ) = ( if◦ x then qσ (h1) else qσ (h0))
Γ,x:Q2	Γ	Γ
where hi(g)= f (g, i) for i ∈ {0, 1}

σ
Γ,x:(τ1⊗τ2)
(f ) = (let (x1, x2)= x in qσ
(h)

where h(g, x1, x2)= f (g, (x1, x2))
The base case is straightforward: the evaluation produces a closed value which can be inverted using the quote function of Definition 5.4. If the context includes a variable x of type 1, then we supply the only possible value for that variable (0), and inductively construct the term with the variable x bound to (). The result is of the correct type because we can add or drop bindings of variables of type Q1 to the environment. If the context includes a variable x of type Q2, then we supply the two possible values for that variable 0 and 1. A conditional is then used to select the correct branch depending on the actual value of x. Finally, if the context includes a variable of type τ1  τ2 then we simply flatten the product and proceed inductively. The function qσ does
indeed satisfy the inversion lemma 5.3.

Quantum Data and Control
We develop the typing rules and semantics of the quantum fragment of QML in two stages. First we extend the judgements Γ ▶ t : σ and the semantics of Section 4 to handle quantum data in a straightforward manner. However, this simple treatment is only an intermediate step in the development, as it admits quantum programs that are not realisable in a pure quantum system without measurement. We then refine both the type system and the semantics to identify exactly the realisable quantum programs.
The Category Vec
As a first approximation to a type system for QML programs, we consider the type system of Figure 1 extended with the rules in Figure 3.



Fig. 3. Typing quantum data (I)
Unlike the classical case, a judgement Γ ▶ t : σ is not interpreted as a function in Γ)		 σ). Rather, because we now have superpositions of terms with complex probability amplitudes, we interpret such judgements as functions in Γ)	 σ)Q where σ)Q represents the complex vectors over the base set σ). In other words, σ)Q is defined to be σ)	C which is sometimes denoted V  σ). All functions in the space must be linear which means that if f	V A	V B, α		 C, and v, v1, v2	V A, then f (v1 + v2)= f (v1)+ f (v2) and f (αv)= α(f v). We call the structure described above the category Vec. This change requires that we revisit the semantics of the classical terms given in Figure 2 so that each denotation returns a complex vector.	For
example, we now have:
 •▶ false : Q2)Q = const v	where v 0= 1.0 and v 1= 0.0
Instead of mapping the value representing the empty context to the denotation of false, we now return a vector v which associates the denotation of false with probability amplitude 1.0 and the denotation of true with probability amplitude 0.0.
This change can be done fairly systematically by using a monad whose
unit and lift operations are defined below:
return :: S → V S
return a (b) = 1.0 if a = b and 0.0 otherwise

(.∗) :: (S → V T ) → (V S → V T )
f ∗(v)(b) = Σa.(v a) ∗ (f a b)
More precisely, the changes to Figure 2 consist of:
Every result is explicitly tagged with the monadic return . This turns every function of type S → T to a function of type S → V T and hence all the composition operators on functions must be lifted to account for the fact that the result type is monadic.
The composition g ◦ f becomes g∗ ◦ f



Fig. 4. Meaning function for quantum data
The composition f × g uses the tensor product on the vectors instead of the classical product, i.e.: (f × g)(a, b)(x, y)= f a x ∗ g b y
The composition f |g requires non-trivial changes as explained in Section 6.3
The updated meaning function of Figure 2 together with the new cases in Figure 4 give the complete definition of the meaning function for QML.
Orthogonality
The type system presented so far correctly tracks the uses of variables and prevents variables from being weakened, yet the situation is more subtle. It turns out that the type system accepts terms which implicitly perform mea- surements and as a consequence accepts programs which are not realisable as pure quantum computations.
Consider the expression if◦ x then true else true. This expression ap- pears to use x , syntactically at least. However given the semantics of if◦, which returns a superposition of the branches, the expression happens to re- turn true without really using any information about x , i.e., it effectively forgets or measures x . In order to maintain the invariant that all measure- ments are explicit, the type system should therefore reject such an expression.
More precisely, the expression if◦ x then t else u should only be accepted if t and u are orthogonal quantum values (t  u). This notion intuitively ensures that the conditional operator does not implicitly discard any infor- mation about x during the evaluation. Indeed the incoming value of x is a superposition of the two orthogonal basis vectors representing false and true. If we require that the result of the if◦ expression is another superposition of orthogonal values, then it essentially becomes a rotation. Because of a similar concern, the two branches of a superposition should also be orthogonal.
We therefore introduce a new typing judgement Γ ▶◦ t : σ which is similar to the judgement Γ ▶ t : σ except that it uses modified rules for conditionals and superpositions which require that the relevant subexpressions are orthog- onal. The modified rules are given in Figure 5. The modification also achieves that programs are normalised, i.e., the sum of the probabilities of a superpo-



Fig. 5. Typing quantum data (II)

Fig. 6. Inner products and orthogonality
sition add up to 1. The judgement ◦ is not automatically closed under the equality judgement, hence we add the rule (subst). Our philosophy is that we allow equivalent representations of QML programs which do not satisfy the orthogonality criteria locally, as long as the program as a whole is equivalent to one which does satisfy the criteria.
It remains to define the syntactic orthogonality judgement t ⊥ u. Se- mantically the vectors vt and vu representing the values of the terms t and u are orthogonal if their inner product vt vu is 0. We provide a syntactic approximation of the inner product in Figure 6: the syntactic version assigns to any pair of terms Γ  t, u : σ a value t u  C  ? where ? is a “don’t know” answer. In the figure λ is the conjugate of the complex number λ. We extend multiplication to this domain by 0 ∗ x = x ∗ 0 for any x ∈ C ∪ {?} and
?=?	=? for x = 0. Addition is also extended by	+? = ? +	= ?.
The approximation is sound but clearly incomplete.
The Category Q◦
The restriction of the set of typable terms requires a similar semantic restric- tion. We require that all the functions preserve the inner products of vectors,

i.e., that they are isometries. A function f ∈ V A → V B is an isometry if for all v1, v2 ∈ V A, we have that ⟨v1|v2⟩ = ⟨f v1|f v2⟩. Intuitively such func- tions can never “forget” any information which is consistent with our desire to prevent situations which would accidentally measure a value.
It is fairly straightforward to show that all the functions introduced by the denotational semantics are isometries except of course for the cases of super- positions and if◦ which require side-conditions on their inputs as motivated in the previous section. Semantically the syntactic condition of orthogonality translates to the following requirement on the corresponding meaning func- tions. These functions must map arbitrary input environments to orthogonal vectors. We say that two morphisms f, g in V A → V B are orthogonal is for any two vectors v1, v2 V A, we have that f v1 g v2 = 0. To explain this semantic restriction, we consider the case of superpositions in detail; the case for if◦ is similar. Looking at the semantic definition in Figure 4, we would like to guarantee that h∗ is an isometry given that both f ∗ and g∗ are both isometries. We calculate as follows. Let r1 and r2 be vectors in V Γ, then using some fairly simple but tedious calculations we get:

∗	∗	1	∗	∗	∗	∗	∗	∗	∗	∗

⟨h r1|h r2⟩ = 2 (⟨f r1|f r2⟩ + ⟨g r1|g r2⟩ + ⟨f r1|g r2⟩ + ⟨g r1|f
r2⟩)

= ⟨r1|r2⟩ + 1(⟨f ∗r1|g∗r2⟩ + ⟨g∗r1|f ∗r2⟩)
= ⟨r1|r2⟩
The first step is because f ∗ and g∗ are both isometries that preserve the inner product. The second step is because of the additional requirement that f ∗ is orthogonal g∗.
We call the resulting category of vectors and isometries the category of strict quantum computations, Q◦. The homset of morphisms in Γ)  σ)Q is called Q◦ Γ) σ)Q. The meaning function is given as before but with the maps interpreted in the category Q◦, i.e., the meaning of a derivation Γ ▶ t : σ is a morphism Γ ▶ t : σ)Q ∈ Q◦ Γ) σ)Q. As explained above, the requirement for orthogonality in the type system is reflected semantically: the superposition is an isometry if the two components are orthogonal; similarly, the conditional f |g is an isometry if f and g are orthogonal.
Quantum Equational Theory
The equational theory for the quantum language inherits all the equations for the classical case. This can be informally verified by noting that the meaning function in the case of the quantum language is essentially identical to the classical case. Formally, the proof technique explained in Section 4

applies equally well to the quantum case and yields the same equations for the classical core plus additional equations to deal with quantum data.
Definition 6.1 The quantum equations are:
(if◦)
if◦ (λ ∗ t0 + κ ∗ t1) then u0 else u1

≡	λ ∗ (if
(superpositions)
t0 then u0 else u1)+ κ ∗ (if
t1 then u0 else u1)

t + u	u + t
t + −→0	≡	t
t + (u + v )	≡	(t + u)+ v λ ∗ (t + u)	≡	λ ∗ t + λ ∗ u λ ∗ t + κ ∗ t	≡	(λ + κ) ∗ t 0 ∗ t	≡		0
Lemma 6.2 (Soundness) The equational theory is sound. Given Γ ▶ t ≡
u : σ then the isometries  Γ ▶ t : σ)Q and  Γ ▶ u : σ)Q are extensionally equal.
The additional equations are used to prove equality between different quan- tum values. Semantically, two quantum values are the same if they denote the same vector, which is the case if the sum of the paths to each classical value is the same. For example, to find a simplified quantum value equivalent to:
(false + true)+ (false + (−1) ∗ true) we first normalise to:
(1 /	2)	((1 /	2)	false + (1 /	2)	true)+ (1 / √2) ∗ ((1 / √2) ∗ false + (−1 / √2) ∗ true)
This term has two√paths to √false; along each of them the product of the
amplitudes is (1 /	2) ∗ (1 /	2) which is 1 / 2. The sum of all the paths
to false is 1, and the sum of all the paths to true is 0. In other words, the entire term is equivalent to simply false. The above calculation proves that the Hadamard operation is self-inverse, as discussed in the introduction.


Quoting quantum values
We will now adapt the techniques developed in section 4 to the quantum case. A classical value v  ValCσ is simply a term representing an element in σ). A quantum value represents a vector in V σ)Q, hence we have to close values under superpositions. We define ValQ σ ⊆ Tm σ inductively as a subset of



closed terms of type σ:
C
v ∈ Val σ





0 ∈ ValQ σ

val v ∈ ValQ σ
v, w ∈ ValQ σ v + w ∈ ValQ σ

v ∈ ValQ σ κ ∗ v ∈ ValQ σ


We write ValQσ for isometric quantum values which satisfy the restrictions introduced in Figure 5.
We have already seen that there is a monadic structure on V A = A → C. Correspondingly, we have a Kleisli structure on ValQ. The return is val ∈ ValCσ → ValQσ, and bind is defined as: given v ∈ ValQσ and f ∈ ValCσ → ValQτ , we define v >>= f ∈ ValQ τ by induction over v:
(val x ) >>= f = f x
0	>>= f =0 
v + w  >>= f = (v >>= f )+ (w >>= f )
κ ∗ v	>>= f = κ ∗ (v >>= f )

Lemma 6.3 (ValC, ValQ, val, (>>=)) is a Kleisli structure, i.e. it satisﬁes the following equations:
val x >>= f ≡ f x
v >>= λx.val x ≡ v
v >>= λx.(f x ) >>= g ≡ (v >>= f ) >>= g
Proof. Case (i) follows from the definition. Cases (ii) and (iii) can be shown by induction over the structure of v.	 
While the classical definition of qσ (def. 5.4) was straightforward, its quan- tum counterpart is a bit more subtle, in particular in the case of tensor prod- ucts. As a special case consider qQ2⊗Q2 . Given an element
−→v ∈  Q2 ⊗ Q2)Q =  Q2) × Q2) → C
we have to construct a value qQ2⊗Q2 −→v ∈ ValQ Q2 ⊗ Q2. This can be done by calculating the probabilities that the first qubit is i, fst −→v i ∈ R+, given by
fst −→v i = √|−→v (i, 0)|2 + |−→v (i, 1)|2
creating the first level of the value as a tree, and then for the second level



Fig. 7. Value tree for Q2 ⊗ Q2
normalising the amplitudes with respect to the probabilities of the previous level (see figure 7 for the corresponding tree.) We write σ)P = σ) → R+ for the set of probability distributions; obviously we have σ)P ⊆ σ)Q. We observe that fst −→v  σ)P. Generalising the idea given above we arrive at the following definition of the “quote” function.
Definition 6.4 The syntactic representations of denotations is given by:
qσ ∈ σ)Q → ValQ σ
which is defined by induction over σ: qQ1 −→v = (−→v 0) ∗ val ()
qQ2 −→v = (−→v 1) ∗ val true + (−→v 0) ∗ val false
qσ⊗τ −→v = qσ(fst −→v )
>>=λx ∈ ValCσ.(1/(fst −→v ) x) ∗ qτ (λy ∈ ValCσ.−→v (x, y))
>>=λy ∈ ValCσ.val (x, y)
where:
Q	P
fst ∈  σ ⊗ τ )	→  σ)
fst −→v x = √Σy.|−→v (x, y)|2

P	P
1/− ∈  σ)  →  σ)
1/−→v x = λx.if −→v x ≡ 0 then 0 else 1/(−→v x)
To show adequacy we have to establish a number of properties of qσ. We have to show that it is linear and isometric, and that it preserves tensor products. This is summarised in the following proposition:
Proposition 6.5
qσ (κ ∗ −→v ) ≡ κ ∗ (qσ −→v )

qσ (−→v + −→w ) ≡ (qσ −→v )+ (qσ −→w )
⟨−→v |−→w ⟩ = ⟨qσ −→v |qσ −→w ⟩
qσ⊗τ (−→v ⊗ −→w ) ≡ (qσ −→v , qτ −→w )
The proof of the above proposition again isn’t completely straightforward, as linearity cannot just be proven by induction over σ. It is essential that we first establish some properties of re-normalising a vector with respect to a probability distribution. We define the product of a probability distribution p ∈ σ)P and a vector −→v ∈ σ)Q as:
p ∗ −→v ∈ σ)Q
p ∗ −→v = λx ∈  σ).(px) ∗ (−→v x)
Now we see that an analogous operation can be defined on values, given v ∈
ValQ σ and p ∈ σ)P as above, we define:
p ∗ v ∈ ValQ σ
p ∗ v = v >>= λx ∈ σ).(px) ∗ (val x)
The key property we establish is the following.
Lemma 6.6 Given p ∈  σ)P and −→v ∈  σ)Q
p ∗ (qσ −→v ) ≡ qσ (p ∗ −→v )
The lemma can be verified by induction over σ, and observing that while 1/− isn’t a proper inverse, it nevertheless satisfies the following property:
1/(p + q) ∗ (p + q)= (1/p) ∗ p
Using the fact that qσ is isometric we can show that it produces values satisfying the orthogonality constraints.
Proposition 6.7 Given v ∈  σ)Q
▶ q v : σ

Adequacy
We define a syntactic counterpart to δΓ,Δ	Q◦ Γ	Δ) ( Γ)Q	 Δ)Q). which denoted by:
δˆΓ,Δ ∈ Tm (Γ ⊗ Δ) (|Γ|⊗ |Δ|)

This term is defined as follows:



ˆ
Γ,Δ
= ⎪⎪⎨
⎪
and Δ = Δ',x : σ
let (g, d )= δΓ',Δin ((g, x ), d )	if Γ = Γ ,x : σ
and x /∈ dom Δ

⎪⎩ 1Δ	if Γ = •
To establish that qσ commutes with the context operations we have to show by induction on σ that contraction corresponds to δ ∈ Q◦ σ) ( σ)Q ⊗ σ)Q).
Lemma 6.8 Given v ∈  σ)Q we have let x = qσ v in (x , x ) ≡ qσ⊗σ v.
Exploiting this property we can show that the context operations commute with “quote”.
Lemma 6.9 Given −→v ∈  Γ ⊗ Δ)Q, we have:
q|Γ|⊗|Δ| (δΓ,Δ −→v ) ≡ δˆΓ,Δ q|Γ⊗Δ| −→v
Theorem 6.10 If Γ ▶ t : σ and g ∈  Γ)Q then:
▶ qσ( Γ ▶ t : σ)Qg) ≡ let∗ Γ= qΓ g in t : σ.
Proof. By induction over the derivation of Γ	t : σ, as an example consider the case for let:
qρ ( Γ ⊗ Δ ▶ let x = t in u : ρ)Q)
≡ {definition of	)Q}
qρ ( u)Q ◦ ( t)Q ⊗ id ) ◦ δΓ,Δ)
≡ {induction hypothesis for u and t} u ◦ (t ◦ qΓ ⊗ qΔ) ◦ δΓ,Δ)
≡{ Lemma 6.9 }
u ◦ (t ⊗ id ) ◦ δˆΓ,Δ ◦ q|Γ⊗Δ|
≡ (let x = t in u) ◦ q|Γ⊗Δ|
The other cases use the same style of reasoning to deal with the structural properties and exploit proposition 6.5. Note that the case for if◦ can be reduced to linearity.	 

Corollary 6.11 (Adequacy) If ▶ t : σ then ▶ qσ(  ▶ t : σ)Q) ≡ t : σ

Completeness and Normalisation
The development here follows closely the one in the classical case as presented in Section 5.3.
Definition 6.12 The function qσ	Q◦ Γ) σ)Q	Tm Γ σ for inverting eval- uation is defined by analysing the context:
qσ(f ) = qσ (f (return 0))

σ
Γ,x:Q1
−1
Γ,x:Q1
(qΓ) ◦ ΦΓ,x:Q1

qσ	(f ) = φ−1	◦ (q × q ) ◦ ΦΓ,x:Q

Γ,x:Q2	Γ,x:Q2	Γ	Γ
qσ	(f ) = φ−1	◦ q
2
ΦΓ,x:τ ⊗τ

The auxiliary isomorphisms are defined as follows:
φΓ,x:Q1 ∈ Tm (Γ,x : Q1) σ → Tm Γ σ φΓ,x:Q1 t = let x = () in t
φΓt = t








φ−1
φΓ,x:Q ∈ Tm (Γ,x : Q2 σ) → {(t0, t1) ∈ (Tm Γ σ)2 | t0 ⊥ t1} φx:Q2 t = (let x = false in t, let x = true in t)
(t, u) = if◦ x then t else u

Γ,x:Q2

φΓ,x:τ1⊗τ2 ∈ Tm (Γ,x : τ1 ⊗ τ2) ρ → Tm (Γ, x1 : τ1, x2 : τ2) φΓ,x:τ1⊗τ2 t = let x = (x1, x2) in t

−1
Γ,x:τ1⊗τ2
(t) = let (x1, x2)= x in t

Since the isomorphisms φ are defined as an operation on terms, we have corre- sponding isomorphisms in the semantic category (Q◦) which we denote by Φ.
For the inversion proof we only need the provability of one side of the isomorphisms which follows from the η-equalities.
Lemma 6.13 The family of equalities φ−1(φΓt) ≡ t is derivable.

Definition 6.14 The normal form of t is given by nfσ(t)= qσ( Γ ▶ t : σ)Q).
Lemma 6.15 (Inversion) The equation Γ ▶ nfσ(t) ≡ t is derivable.
Proof. By induction over the definition of qσ. In the case of Γ = • the result follows from adequacy, Corollary 6.11. In all the other cases we exploit Lemma
6.13.	 
Since all our definitions are effective nf indeed gives rise to a normalisation algorithm. As a consequence, our equational theory is decidable, modulo deciding equalities of the complex number terms which occur in our programs. We also note that as in the classical case, our theory is complete.
Proposition 6.16 (Completeness) If Γ ▶ t : σ)Q and Γ ▶ u : σ)Q are ex- tensionally equal, then we can derive Γ ▶ t ≡ u : σ.

Conclusions and Further Work
We have developed a sound and complete equational theory for a functional quantum programming language, while at the same time providing a nor- malisation algorithm. The construction is a modular extension of a classical theory; indeed the quantum theory inherits not just all the equations and term formers, it is also possible to generalise our proof technique to the quantum case. The quantum theory introduces additional constructs corresponding to superpositions and equations relating them.
The obvious next step is to generalise this approach to the full language QML including measurements. The equational theory is already a challenge, since a measurement can have non-local effects on shared data. Semantically, we will use superoperators to model programs with measurements. Clearly, we have to extend our quote operator to work on density matrices.
Another interesting direction would be to consider higher-order quantum programs and develop a complete equational theory and normalisation al- gorithm for this calculus. A likely semantic domain is given by presheaves, here the tensor product can be modelled using Day’s construction, which is automatically closed, i.e., provides an interpretation for higher types.

References
P. Arrighi and G. Dowek. Operational semantics for a formal tensorial calculus. In Proceedings of the 2nd International Workshop on Quantum Programming Languages, 2004.
T. Altenkirch and J. Grattage. A functional quantum programming language. In Prakash Panangaden, editor, Proceedings of the Twentieth Annual IEEE Symp. on Logic in Computer Science, LICS 2005, pages 249–258. IEEE Computer Society Press, June 2005.


T. Altenkirch and T. Uustalu. Normalization by evaluation for λ→2. In Functional and Logic Programming, number 2998 in LNCS, pages 260 – 275. Springer-Verlag, 2004.
M. Nielsen and I. Chuang. Quantum Computation and Quantum Information. Cambridge University Press, Cambridge, 2000.
P. Selinger. Towards a quantum programming language. Mathematical Structures in Computer Science, 14(4):527–586, 2004.
P. Selinger and B. Valiron. A lambda calculus for quantum computation with classical control. In Proceedings of the Seventh International Conference on Typed Lambda Calculi and Applications (TLCA), Springer-Verlag, LNCS 3461, pages 354–368, 2005.
A. van Tonder. Quantum computation, categorical semantics and linear logic. Available as
arXiv:quant-ph/0312174, 2003.
A. van Tonder. A lambda calculus for quantum computation. SIAM Journal on Computing, 33(5):1109–1135, 2004.
