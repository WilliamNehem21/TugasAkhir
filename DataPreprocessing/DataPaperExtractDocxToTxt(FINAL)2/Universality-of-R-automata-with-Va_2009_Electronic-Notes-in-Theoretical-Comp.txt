

Electronic Notes in Theoretical Computer Science 239 (2009) 131–141
www.elsevier.com/locate/entcs

Universality of R-automata with Value Copying 1
Parosh Aziz Abdulla, Pavel Krcal and Wang Yi2
Dept. of Information Technology, Uppsala University, Sweden

Abstract
R-automata are finite state machines extended with counters which can be incremented or reset to zero along the transitions. The universality question asks whether there is a constant D such that all words are accepted by some run along which no counter exceeds D. It has been shown in [2] that this question is decidable. In this paper, we add one more operation to R-automata, namely the operation which can copy the value of a counter into another one. The result of this paper is a reduction of the universality problem for R-automata with value copying to universality of R-automata, thus rendering the problem decidable. The reduction replaces copy operations by non-deterministic resets together with a mechanism ensuring that the number of such replacements is bounded between each two resets of a value.
Keywords: Distance automata with resets and copying, universality, decidability.


Introduction
Finite state machines usually serve as word acceptors, where the accepting condition is expressed in terms of the last reached state. For the acceptance of a word, it does not matter what has happened along the run, as long as we end up in an accepting state. One can also introduce a notion of the cost into finite automata by setting a price on each transition. The cost of a run is then the sum of the costs of the transitions. The cost of a word is the minimum of the costs of all accepting runs for this word. One way of bringing this concept into the automata model is to introduce counters which accumulate the cost along the runs.
A first such extension – distance automata of Hashiguchi [6] – contained one counter which could only be incremented. The operations on the counter are either increment (+1) or leaving the counter unchanged (0). Recently, this model was extended to several counters which can be also reset (r) – nested distance desert

1 This work has been partially supported by the EU CREDO project.
2 Email: {parosh,pavelk,yi}@it.uu.se

1571-0661/© 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.05.035

automata [9], B-automata [3], and R-automata [2]. In this work, we add new op- erations (∗j) where j is a counter name. These operations copy the content of the counter j into the counter to which this operation is applied.
Questions asked for these automata are concerned with the existence of bounds on the costs (i.e., counter values). The limitedness problem is to decide whether there is a bound such that all accepted words are accepted by a run along which no counter exceeds this bound. The universality problem is a special case of the limitedness problem, i.e., the question whether there is a bound such that all words are accepted by a run along which no counter exceeds this bound. This problem has been shown decidable for R-automata in [2] using the factorization forest theorem [12]. Here we show the decidability of the universality problem for R-automata with value copying by reducing it to the universality problem of R-automata (without copying).
The main idea of the reduction is to replace the copy instructions by resetting and swapping the counter values. We reset the counter into which a value should be copied and then we non-deterministically choose whether we swap the values of the involved counters. This allows us to choose in which of these two counters we keep the value accumulated so far. There is a mechanism which ensures that the number of such resets along the lifetime of each value, i.e., from the beginning (a reset) of a value until its end (the next reset or overwrite by a copy), is bounded by the number of the counters. By this, we can decrease the cost of each word only by a constant ratio.
The motivation for this particular class of counter automata comes from the sampled semantics of timed automata [10,1]. A sampled semantics given by a sam- pling rate ϵ = 1/ƒ for some positive integer ƒ allows time to pass only in steps equal to multiples of ϵ. The number of different clock valuations within one clock region (a bounded set of valuations) for a pair of clocks corresponds to a counter. It is finite for any ϵ while infinite in the standard (dense time) semantics of timed automata. Timed automata can generate runs along which clocks are forced to take different values from the same clock region. This is done by forcing a pair of clocks to increase/decrease their difference (an increment of a counter), keep exactly the same difference (a counter is left unchanged), forget about the previous difference (a counter reset), or assume the difference of some other clock pair (a counter copy).
Related work. Different proofs of the decidability of the limitedness problem for distance automata are reported in [7,11,13]. The last of these results [13] is based on the factorization forest theorem [12,5].Distance automata were extended in [8,9] with additional counters which can be reset following a hierarchical discipline resem- bling parity acceptance conditions. R-automata form a superclass of this extension. Universality of a similar type of automata for tree languages is studied in [4]. B- automata [3] contain counters which can be incremented and reset in the same way as in R-automata, but they accept infinite words such that the counters are bounded along an infinite accepting computation. The main result is that B-automata can be complemented.

Preliminaries
First, we introduce the model of RC-automata and its unparameterized semantics. Then we introduce the parameterized semantics, the languages accepted by the automaton, and the universality problem.
RC-automata. RC-automata are finite state machines extended with counters. A transition may increase the value of a counter, leave it unchanged, reset it back to zero, or copy it into another counter. The automaton on its own does not have the capability of testing the counter values. However, the semantics of these automata is parameterized by a natural number D which defines an upper bound on counter values which may appear along the computations of the automaton. Let N denote the set of non-negative integers. Let for a given number n of counters, E = {0, 1, r}∪
{∗m|1 ≤ m ≤ n} be the set of operations on a counter. An RC-automaton with
n counters is a 5-tuple A = ⟨S, Σ, Δ, s0,F ⟩ where S is a finite set of states, Σ is a finite alphabet, Δ ⊆ S × Σ × En × S is a transition relation, s0 ∈ S is an initial state, and F ⊆ S is a set of final states.
Transitions are labeled (together with a letter) by an effect on the counters. The symbol 0 corresponds to leaving the counter value unchanged, the symbol 1 represents an increment, the symbol r represents a reset, and a symbol ∗m means that the value of this counter is set to the value of the counter m. The operations 0, 1, and r take place first and after that the values are copied. An RC-automaton which does not contain any copy operations is called an R-automaton.
We use t, t1,... to denote elements of E n which we call eﬀects. By πi(t) we denote the i-th projection of t. Without loss of generality, we assume that the value of a counter is never directly copied into itself (πi(t) /= ∗i). A path is a sequence of transitions (s1, a1, t1, s2),(s2, a2, t2, s3),... , (sm, am, tm, sm+1), such that
∀1 ≤ i ≤ m.(si, ai, ti, si+1) ∈ Δ. We use si to refer to the i-th state of the path. An example of an RC-automaton is given in Figure 1.
b, (0, 1)



∗1)
a, (0, r)

Fig. 1. An R-automaton with two counters.

Unparameterized semantics. We define an operation ⊕ on the counter values: for any k ∈ N, k ⊕ 0= k, k ⊕ 1= k + 1, and k ⊕ r = 0. We extend this operation to n-tuples and copy operations as follows. For a t ∈ En, let tˆ be an effect with all copy instruction replaced by 0, i.e., πi(tˆ) = πi(t) if πi(t) ∈ {0, 1, r} and πi(tˆ) = 0
otherwise. For a t ∈ En and (c1,... , cn) ∈ Nn, (c1,... , cn) ⊕ t = (c' ,... , c' ), where
1	n
c' = cm ⊕ πm(tˆ) if πi(t)= ∗m for some m and c' = ci ⊕ πi(t) otherwise.
i	i

The operational semantics of an RC-automaton A = ⟨S, Σ, Δ, s0,F ⟩ is given by a labeled transition system (LTS) A) = ⟨Sˆ, Σ,T, sˆ0⟩, where the set of states Sˆ contains pairs ⟨s, (c1,... , cn)⟩, s ∈ S, ci ∈ N for all 1 ≤ i ≤ n, with the initial state sˆ0 = ⟨s0, (0,... , 0)⟩. The transition relation is defined by (⟨s, (c1,... , cn)⟩, a, ⟨s',
(c' ,... , c' )⟩) ∈ T if and only if ⟨s, a, t, s'⟩ ∈ Δ and (c' ,... , c' ) = (c1,... , cn) ⊕ t.
1	n	1	n	a
We shall call the states of the LTS configurations. We write ⟨s, (c1,... , cn)⟩ −→
⟨s', (c' ,... , c' )⟩ if (⟨s, (c1,... , cn)⟩, a, ⟨s', (c' , ... , c' )⟩) ∈ T . We extend this nota-
1	n	w	' 1 '	n'	+
tion also for words, ⟨s, (c1,... , cn)⟩ −→ ⟨s , (c1,... , cn)⟩, where w ∈ Σ .
Paths in an LTS are called runs to distinguish them from paths in the underly-
ing RC-automaton. Observe that the LTS contains infinitely many states, but the counter values do not influence the computations, since they are not tested any- where. In fact, for any RC-automaton A, A) is bisimilar to A considered as a finite automaton (without counters and effects).
Parameterized Semantics. Next, we define the D-semantics of RC-automata. The parameter D is a bound on the counter values which can occur along any run. For a given D ∈ N, let SˆD be the set of configurations restricted to the configu- rations which do not contain a counter exceeding D, i.e., SˆD = {⟨s, (c1,... , cn)⟩|
⟨s, (c1,... , cn)⟩∈ Sˆ ∧ (c1,... , cn) ≤ (D,... , D)} (≤ is applied componentwise). For an RC-automaton A, the D-semantics of A, denoted by  A)D, is  A) restricted to
SˆD. We write	1	n	a D ⟨s', (c' ,... , c' )⟩ to denote the transition relation
⟨s, (c ,... ,c )⟩ −→	1	n

of  A)D. We extend this notation to words,	1
n	w D ⟨s', (c' ,... , c' )⟩

where w ∈ Σ+.
⟨s, (c ,... ,c )⟩ −→	1	n

Language. The (unparametrized or D-) language of an RC-automaton is the
set of words which can be read along the runs in the corresponding LTS ending in an accepting state (a configuration whose first component is an accepting state). Formally, for a run ρ in A), let l(ρ) denote the concatenation of the labels along this run. A run ρ = ⟨s0, (0,... , 0)⟩ −→∗ ⟨s, (c1,... , cn)⟩ is accepting if s ∈ F . The unparametrized language accepted by an RC-automaton A is L(A) = {l(ρ)|ρ is an accepting run in A)}. For a given D ∈ N, the D-language accepted by an RC- automaton A is LD(A)= {l(ρ)|ρ is an accepting run in A)D}. The unparametrized language of the RC-automaton from Figure 1 is ab∗a∗. The 2-language of this automaton is a(ϵ + b + bb + bbb)a∗.
Problem Definition. Now we can ask the question about language universality of an RC-automaton A parameterized by D, i.e., is there a natural number D such that LD(A)= Σ∗.
Expressiveness
We argue that the expressive power of RC-automata is bigger than that of R- automata, where the expressivity takes into account the counter values. Let us for a given RC-automaton define the cost of a run as the maximum counter value which occurs along this run (maximum over all counters in all configurations) and the cost of a word w to be the minimum of the costs of its accepting runs (and +∞ if the word is not accepted). . We say that two RC-automata are cost equivalent if

the cost of each word is the same for both of them. In Figure 2 we give an example of an RC-automaton such that there is no cost equivalent R-automaton.
a, (1, 0)

c, (0, ∗1)

b, (0, 1)
Fig. 2. An RC-automaton A which does not have a cost equivalent R-automaton.

Let us assume that there is a cost equivalent R-automaton A' with k counters. Let us consider the words of the form ax1 by1 cax2 by2 c... axk byk . For big enough values of x1, y1, x2,... , yk, we can pump these values so that each accepting run of A' over the original word can be extended to an accepting run over the pumped word (a straightforward consequence of the pumping lemma for finite state automata). Clearly, the cost of these words in A is max{y1, x1 + y2, x1 + x2 + y3,... , x1 + ··· + xk−1 + yk, x1 + ··· + xk}.
The counters in A' have to count all of these values in each run of A' over such a word. If there is a run in which one of these values is skipped then we can pump the last summand in this value to make it the maximum. Since the control structure of the automaton (the states) cannot distinguish between different results of the pumping, this maximum will be missed by A'. We claim that for each of these values we need a special counter, contradicting thus the assumption that A' has k counters. If a counter calculates x1 + ··· + xi−1 + yi then it cannot be reused for any later value, since there is no way how could this counter learn about the value of xi (the corresponding part axi has already been read). Thus, by pumping the appropriate subword, we can always show that the cost of the pumped word accepted by A' is not equal to the cost of this word in A.
Universality
The main result of the paper is the decidability of the universality problem for RC-automata formulated in the following theorem.
Theorem 4.1 For a given RC-automaton A, the question whether there is D ∈ N
such that LD(A)= Σ∗ is decidable.
In order to avoid unnecessary technical complications in the main part of the proof, we restrict ourselves to RC-automata with at most one copy operation in each effect. We show how to extend the proof to the general model at the end of this section. We reduce the universality problem for (restricted) RC-automata to the universality problem of R-automata, for which it has been shown that this problem is decidable [2].

Construction

As the first step, we extend each R-automaton with a variable called parent pointer for each counter and with the ability to swap the values of the counters. The parent pointers range over {null}∪ {1,... , n}, where n is the number of the counters. Later on we use them to capture (a part of) the history of copying. We observe that for each R-automaton one can encode the value swapping and the parent pointers into the states. To express the encoding more formally, let us assume that the transitions in the semantics LTS are labeled also by the counter values (in the order encoded by the automaton) and the parent pointers. For each extended R-automaton A', we can build an R-automaton A¯ with |S|· n! · 2n states bisimilar to A'. Moreover, any number of value swaps and parent pointer operations can be encoded along each

transition of A¯ together with standard updates (increments, resets). branch upon the values of the parent pointers.
A¯ can also

Now we can present the reduction by constructing an extended R-automaton A' (which uses counter value swapping and the parent pointers) for each RC-automaton A such that A' is universal if and only if A is universal. A' has all the states of A together with an error sink and it has the same initial state s0 and the same set of accepting states as A. The error sink is a non-accepting state with no outgoing transitions except for the self-loops labeled by Σ and the effect (0,... , 0) which do not swap any counter values and do not manipulate the parent pointers. The automaton starts in the initial state with all parent pointers set to null. To define the transitions of A', we need to encode the copying using the tools of extended R-automata. To do this, we replace each copy by a reset, possibly with some (non- deterministic) value swapping and bookkeeping of the parent pointers. The parent pointers will help us to check whether all the non-deterministic choices were done correctly.
For each transition of A we either construct simulating transitions or a transition

going to the error sink. Let us denote the simulated transition of A by
a,t
s −→ s
', where

t = (e1,... , en). If there are counters k, l such that ek ∈ {0, 1}, el ∈/ {0, 1}, and the
parent pointer of k points to (is set to) l then we create a transition going to the

error sink. Otherwise, we build simulating transitions s
a,t',sp
−→ s
in A'
labeled by an

effect t' = (e' ,... , e' ), which might also swap some counter values and manipulate
1	n
the parent pointers (denoted by sp).
If t does not contain any copy operation then there is one simulating transition with t' = t and for all i such that ei = r, we set i’s parent pointer to null. No counter values are swapped.
If t contains a copy operation ei = ∗j then we create two simulating transitions.
Each of them has the same effect t', where e' = ek if k /= i and ei = r. These
two transitions give the simulating automaton a non-deterministic choice between
the counters i and j. The first transition corresponds to the choice of j. Along this transition, we perform the effect and set i’s parent pointer to j. No counter values are swapped. Along the other transition (corresponding to the choice of i), we perform the effect, swap the values of the counters i and j, we copy the value of

j’s parent pointer into i’s parent pointer, we change the value of all parent pointers with value j to i, and finally we set j’s parent pointer to i. Both transitions also set the k’s parent pointer to null for all k such that ek = r.
Proof of Correctness
Intuitively, the choice of a counter in the copy instruction tells that the value in this counter will be destroyed by a reset or overwritten by a copy instruction later than in the counter which was not chosen. The structure of the copies is captured by the parent pointers in the following sense. If the counter i points to the counter j then i contains an immediate copy of j (but possibly modified by increments) and its value will be destroyed earlier than the value in j. The automaton ends in the error sink if it witnesses a violation of some of these implicit claims, i.e., the value in the counter i is destroyed earlier than the value in the counter j.
First, we formalize the concept of the evolution of a value and define the corre- sponding runs. Then we show existence of corresponding accepting runs. Later on we use the fact that the parent pointers along the simulating traces have a special structure to show the correctness of the simulation.
Definition 4.2 Let n be the number of the counters. For a path p of length |p|
and two natural numbers 1 ≤ i < j ≤ |p|, a total function vt : {i, i + 1,... , j} −→
{1,... , n} is a value trace if for all k such that i ≤ k < j, t is the effect on the transition between the k-th and k + 1-st state on p, vt(k) = a, vt(k + 1) = b, the following holds: if a /= b then πb(t)= ∗a and if a = b then πb(t) ∈ {0, 1}.
A value trace follows a value from some time point during its evolution (in- crements, copying) in an RC-automaton. A value trace ends before the value is overwritten by a copy operation or reset. We also talk about a value trace along a run. Then we mean a value trace along a path which has induced the run. We order value traces by the set inclusion on their domains (e.g., vt : {2, 3} −→ {1,... , n} is smaller than vt : {2, 3, 4} −→ {1,... , n} regardless of the actual function values). We define the length of a value trace as the size of its domain.
Now we define the correspondence between accepting runs in an RC-automaton A and in its corresponding R-automaton A'. We say that a run ρ of A over w and a run ρ' of A' over w are corresponding if for all i the i-th transitions of ρ, ρ'

a,t	'
a,t',sp  '
a,t',sp  '

are obtained by executing the transitions s −→ s
and s
−→ s , where s
−→ s

is a simulating transition of s
a,t
−→ s
'. We show that for each accepting run of

one automaton there is an accepting corresponding run of the other automaton. It
follows immediately from the definitions that for each accepting run of A' there is exactly one accepting corresponding run of A.
The other direction is more complicated, because we have to show that A' can choose correct values for non-deterministic choices in the copy instruction so that it does not end up in the error sink. For each accepting run ρ of A, we construct an accepting run ρ' of A' as follows. We label each counter j in the k-th state of ρ (for all k ≤ |ρ|) by the length of a maximal value trace vt with domain being a subset

of [k, |ρ|] and vt(k) = j (this label is called expectancy ). A' takes the simulating transition for each transition of ρ (according to the rules above) and when it has to choose between i and j (ei = ∗j) along a transition ending in the k-th state, then it chooses i if and only if the expectancy of i in k is greater than the expectancy of j in k (expectancy rule). We show that this is a valid definition, i.e., the corresponding run of A' does not end up in the error sink. The main step in the proof is to show that the parent pointers always point to the counters with not smaller expectancy than that of the counter which owns the parent pointer.
Lemma 4.3 For each accepting run ρ of A there is an accepting corresponding run
ρ' of A'.
Proof. We prove by induction that for each prefix of ρ there is a simulating run which does not contain the error state such that for any state along ρ' and any two counters i, j in this state, if the parent pointer of i points to j then the expectancy of j is not smaller than that of i. Such a simulating run for |ρ| will also be accepting.
The basic step (i.e., the prefix length is 0) is trivial. For the induction step, let us assume that there is a simulation of the prefix of length k satisfying the induction hypothesis. To simulate the k + 1-st transition, we follow the expectancy rule.
Because of the induction hypothesis and the definition of expectancy, there are always simulating transitions (and not a transition leading to the error sink). If there is a copy instruction ei = ∗j in the transition, the non-deterministic choice is performed according to the vt function, so the result again satisfies the induction hypothesis. The transfer of the parent pointers does not violate it either, because expectancy of j in k is equal to 1 plus the maximum of the expectancies of i and j in k+1. The resets do not establish any new parent pointers, so the result again satisfies the induction hypothesis. The other effects result in decrementing the expectancy, which preserves the induction hypothesis for all the pointers inherited from the previous state as well as for the pointers changed by the copy instruction. 
Let us introduce the parent pointer relation →p for a state of A' as a relation on counters where i→pj if and only if the parent pointer of i is set to j.
Lemma 4.4 Let ρ be a run of A'. The transitive closure of →p is antireflexive in all states of ρ.
Proof. We prove by induction that for each prefix of ρ, the transitive closure of →p
is antireflexive in all states of the prefix.
The basic step is trivial, →p is empty in s0. For the induction step, we need to check that a single transition does not violate the antireflexivity. If the transition leads to the error sink then →p is not changed. Otherwise, it is a simulating transi- tion defined by the rules above. The resets make →p smaller and 0, 1 do not change it. In the copy instruction ei = ∗j, we introduce one new pointer, but we know that nothing points to i, because of the condition on creating the simulating transitions and the fact that the parent pointers of all reset counters are set to null. In the first case (j has been chosen), we set i’s parent pointer to j, which cannot introduce a loop, since nothing points to i. In the second case (i has been chosen), since we

have redirected all the pointers pointing to j to i, there is nothing pointing to j and newly introduced j→pi cannot create a loop. Also, since there was nothing pointing to i previously, the only pointers pointing to i now are those that previously pointed to j.	 
This leads to the following definition of ranks. For a counter i in a state s of A' we define rank(s, i) inductively by rank(s, i)= 0 if the parent pointer of i in s is null and rank(s, i) = rank(s, j)+ 1 if i→pj in s. From Lemma 4.4, we have that the ranks are well-defined and it follows directly from the definition that the rank of a counter is always bounded by the number of the counters. Now we formulate a lemma saying that the ranks never decrease along a value trace.
Lemma 4.5 Let ρ be a run of A' and vt be a value trace. Then for k ≤ l such that
vt(k), vt(l) are defined, rank(sk, vt(k)) ≤ rank(sl, vt(l)).
Proof. By induction on l − k.
The basic step: l = k and rank(sk, vt(k)) = rank(sl, vt(l)). The induction step: if the transition leads to the error sink then →p is not changed and therefore the ranks do not decrease. Otherwise, it is a simulating transition defined by the rules above. Because of the condition on creating the simulating transitions, we never decrease any rank by a reset. The operations 0, 1 also do not decrease any rank. Copy increases the rank of the branch with smaller expectancy (and the counter is reset) and keeps the rank for the branch with bigger expectancy (the one which keeps the value) unchanged. Because of the careful manipulation with the pointers, no ranks which depend on the rank of the longer branch change either.	 
The main property of the reduction is stated in the following lemma.
Lemma 4.6 Let A be a restricted RC-automaton with n counters and A' be the simulating R-automaton. For each D and for each word w, w ∈ LD(A) ⇒ w ∈ LD(A') and w ∈ LD(A') ⇒ w ∈ Ln·D(A).
Proof. The first implication: we know from Lemma 4.3 that for each accepting run ρ of A over w there is a corresponding accepting run ρ' of A' over w. It follows directly from the construction that for all k ≤ |ρ|, the counter values in the k-th state of ρ' are bounded by the counter values in the k-th state of ρ. All operations are simulated faithfully except for replacing copy operations by resets along ρ'.
The second implication: by contraposition, let us for each D consider a word w such that w ∈/ Ln·D(A). Any accepting run ρ' of A' over w must satisfy Lemma 4.5. Let vt be a maximal value trace for a value which exceeds n · D in ρ. We study the evolution of this value in ρ'. It is simulated faithfully except for some possible resets in the copy instructions. But for each such reset, the rank of the counter strictly increases. Therefore, there can be at most n − 1 such resets and there must be a state in which this value exceeds D.	 
An immediate consequence of this lemma is the correctness of the reduction.

Corollary 4.7 Let A be a restricted RC-automaton and A' be the simulating R- automaton. There is a D such that LD(A) = Σ∗ if and only if there is a D' such
'	∗
that LD' (A )= Σ .
Now we show that the result holds also for RC-automata with any number of copying in each step. Let us view the relation "i is copied to j" induced by an effect t as a directed graph (counters are nodes, there is an edge from i to j if πj(t)= ∗i). Because each node can have at most one incoming edge, such a graph is a collection of simple loops with isolated paths outgoing from them (nodes with no incoming edge are considered as degenerated loops). We can split application of such an effect t into an equivalent sequence of effects with at most one copy instruction and some swapping of the values and the parent pointers as follows. First, we perform tˆ (all increments and resets). Then we pick one of the counters j such that j has no outgoing edge and it has an (exactly one) incoming edge from i. We copy the value of i to j and leave all other counters unchanged, which can be described by the effect (0,... , ∗i,... , 0), where ∗i is on the j-th position. Then we remove the edge connecting i and j and continue to pick another such counter. When there is no node j with no outgoing edge and with an incoming edge, there still might be loops in the copying graph. We simply swap the counter values and the parent pointers in the loops. Because of the order in which we have copied the counters, the effect of this sequence of transitions with at most one copy instruction and swaps is the same as that of the original transition. Also, the correctness does not depend on the order in which we choose the edges. A careful analysis shows that this sequence of transitions can be encoded into one simulating transition in R-automata with value swapping and parent pointers.
Conclusions
We have defined RC-automata as an extension of R-automata – finite state machines with counters which can be incremented or reset to zero along the transitions – by the ability to copy the value of a counter into another counter. The universality problem for these automata is to decide whether there is a constant D such that all words are accepted by some run along which no counter exceeds D. We have shown that this problem is decidable for RC-automata by reducing it to the universality problem for R-automata, show decidable in [2].
References
Parosh Abdulla, Pavel Krcal, and Wang Yi. Sampled universality of timed automata. In Proc. of FOSSACS’07, volume 4423 of LNCS, pages 2–16. Springer, 2007.
Parosh Abdulla, Pavel Krcal, and Wang Yi. R-automata. In Proc. of CONCUR’08., volume 5201 of
LNCS, pages 67–81. Springer, 2008.
Mikolaj Bojańczyk and Thomas Colcombet. Bounds in omega-regularity. In Proc. of LICS’06, pages 285–296. IEEE Computer Society Press, 2006.
Thomas Colcombet and Christof Löding. The non-deterministic Mostowski hierarchy and distance- parity automata. In Proc. of ICALP’08, volume 5126 of LNCS, pages 398–409. Springer, 2008.


Thomas Colcombet. Factorisation forests for infinite words. In Proc. of FCT’07, volume 4639 of LNCS, pages 226–237. Springer, 2007.
Kosaburo Hashiguchi. Limitedness theorem on finite automata with distance functions. Journal of Computer and System Sciences, 24(2):233–244, 1982.
Kosaburo Hashiguchi. Improved limitedness theorems on finite automata with distance functions.
Theoretical Computer Science, 72(1):27–38, 1990.
Daniel Kirsten. Distance desert automata and the star height one problem. In Proc. of FoSSaCS’04, volume 2987 of LNCS, pages 257–272. Springer, 2004.
Daniel Kirsten. Distance desert automata and the star height problem. Informatique Theorique et Applications, 39(3):455–509, 2005.
Pavel Krcal and Radek Pelanek. On sampled semantics of timed systems. In Proc. of FSTTCS’05, volume 3821 of LNCS, pages 310–321. Springer, 2005.
Hing Leung. Limitedness theorem on finite automata with distance functions: an algebraic proof.
Theoretical Computer Science, 81(1):137–145, 1991.
Imre Simon. Factorization forests of finite height. Theoretical Computer Science, 72(1):65–94, 1990.
Imre Simon. On semigroups of matrices over the tropical semiring. Informatique Theorique et Applications, 28(3-4):277–294, 1994.
