Electronic Notes in Theoretical Computer Science 48 (2001)
URL: http://www.elsevier.nl/locate/entcs/volume48.html pp. 1 – 20



Correct Answers for First Order Logic

Gianluca Amato 1
Dipartimento di Matematica e Informatica Universit`a degli Studi di Udine
Udine, Italy


Abstract
Working within a semantic framework for sequent calculi developed in [3], we pro- pose a couple of extensions to the concepts of correct answers and correct resultants which can be applied to the full first order logic. With respect to previous proposals, this is based on proof theory rather than model theory. We motivate our choice with several examples and we show how to use correct answers to reconstruct an abstraction which is widely used in the static analysis of logic programs, namely groundness. As an example of application, we present a prototypical top-down static interpreter for properties of groundness which works for the full intuitionistic first order logic.


Introduction
One of the greatest benefits of logic programming, as presented in [20], is that it is based upon the notion of executable speciﬁcations. The text of a logic program is endowed with both an operational (algorithmic) interpretation and
an independent mathematical meaning which agree each other in several ways. The problem is that operational expressiveness (intended as the capability of directing the flow of execution of a program) tends to obscure the declara- tive meaning. Research in logic programming strives to find a good balance between these opposite needs.
Uniform proofs [21] have widely been accepted as one of the main tools for approaching the problem and to distinguish between logic without a clear com- putational flavor and logic programming languages. However, that of uniform
proofs being a concept heavily based on proof theory, researches conducted along this line have always been quite far from the traditional approach based on fixpoint semantics. In turn, this latter tradition has brought up several important results concerning the effective utilization of Horn clauses as a real

1 Email:amato@dimi.uniud.it
◯c 2001 Published by Elsevier Science B. V. Open access under CC BY-NC-ND license.


programming language. Among the others, problems such as compositionality of semantics [10,9], modularity [6,8], static analysis [14], debugging [11], have been tackled in this setting. Adapting these results to the new logic languages developed via the proof theoretic approach, such as λProlog [23] or LinLog [4], would probably require at least two things:
provide a fixpoint semantics for these new languages;
generalize a great number of concepts whose definition is too much tied to the case of Horn clauses.
In [3], the authors propose a semantic framework which can be useful in such an effort. The main idea is to recognize proofs in the sequent calculi as the general counterpart of SLD resolutions for positive logic programs. Thus, the three well-known semantics (operational, declarative and fixpoint) for Horn clause logic can be reformulated within this general setting and directly applied to all the logic languages based on sequent calculi.
Classical abstractions such as correct answers or resultants, used in the semantic studies of logic programs, and abstractions for static analysis like groundness, can be retrieved in terms of properties of proofs. Expressed in such a way, rather than referring to a computational procedure like SLD res- olution, they are more easily extendible to other logic languages.
However, the definition proposed in [3] for correct answers was based on the model theoretic idea that a correct answer for an existentially quantified formula ∃x.φ is a substitution θ for the variables in x such that φθ is true. When we tried to extend this simple idea from the well known case of Horn clauses to the full first order logic, we came with a general definition of correct answers which was rather involved and far less general than expected.
Since most of the work in the field of logic programming are heavily based on computed answers, which are the computational counterpart of correct answers, defining a solid foundation for the latter is essential if we want to adapt previous results to broader fragments of logic.
Here, we tackle the problem of correct answers from a proof theoretic point of view. We argue that the natural extension of the idea of “correct answer” to the first order logic is the recording of all the occurrences of quantifier introduction rules in a proof. In the case of Horn clauses, if we only consider the introductions of existential quantifiers, this turns out to be equivalent to the standard definition. We also introduce a corresponding generalization for “correct resultants”. Then, we consider a common abstraction for the semantics of logic programs, namely groundness, and we examine its extension to the case of full first order logic. A prototypical abstract interpreter for this observable has been developed, and we show some of the results we have obtained. At last, possible future developments are discussed.

The Framework
We give here a presentation for sequent calculi which is a wide generalization of most of the calculi which have been developed so far from the introduction of Gentzen’s LK calculus [17] . Actually, our formalization is so general that a name like tree calculi would probably be more appropriate. However, since we only use the framework in the context of proofs for logic systems, we will stick to the name of sequent calculi. A more detailed treatment of these topics can be found in [3] and [1].
Definition 2.1 Given a set S of sequents, the set Sch(S) of proof skeletons
over S is defined inductively as follows:
every S ∈S is a proof skeleton;
if S ∈ S, n ∈ N and Ti is a proof skeleton for each i ≤ n, then
T1 ··· Tn
(1)
S
is a proof skeleton, which we also denote by tree(S, T1,... , Tn). We admit the case n = 0.
We write Sch in the place of Sch(S) when S is clear from the context.
Then, we define two functions hyp : Sch(S) → S٨ and root : Sch(S) → S 
such that
hyp(S) = S	,
hyp(tree(S, T1,... , Tn)) = hyp(T1) ··· hyp(Tn) , and
root(S) = S	,
root(tree(S, T1,... , Tn)) = S	.
Given a proof skeleton π, hyp(π) is the sequence of hypotheses of π while root(π) is the root of π. When we want to state that π is a proof skeleton with hyp(π) = S1,... , Sn and root(π) = S, we write
π : S1,... , Sn ▶ S .	(2)
We also define the height of a proof skeleton π introducing the function height :
Sch(S) → N such that
height(S) = 0  ,
height(tree(S, T1,... , Tn)) = max{height(T1),... , height(Tn)} +1  , with the obvious assumption that max(∅) = 0.
Note that S, which we also denote by ϵS, and tree(S) are two different proof
skeletons. Actually, it is height(S) = 0 and hyp(S) = S but height(tree(S)) = 1 and hyp(tree(S)) = λ.


Now, we fix a set R of proof skeletons of height one. We call inference rules the elements of R. A proof skeleton π, which is obtained by pasting together the empty proof skeletons and the inference rules, is called proof. A proof with no hypothesis is said to be ﬁnal. A sequent S is provable if there is a final proof rooted at S. Finally, we call sequent calculus a pair (S, R).

Semantics
In the following, we assume fixed a sequent calculus (S, R). Given a sequent S, we denote by SchS the set of all the proof skeletons rooted at S. For each π ∈ SchS of the form
π : S1,... , Sn ▶ S ,	(3)

we have a corresponding semantic operator π : SchS1 × ··· × SchSn → SchS which works by pasting proof skeletons of the input sequents together with π, to obtain a new proof skeleton of the output sequent S. If Sch is the set of all the proof skeletons, π : S1,... , Sn ▶ S ∈ Sch and Xi ⊆ Sch for each i, we define a collecting variant of the semantic operator π, defined as
π(X1,... , Xn) = {π(π1,... , πn) | ∀1 ≤ i ≤ n. πi ∈ Xi ∩ SchSi} .  (4) We will write π(X) as a short form for π(X,... , X) with n identical copies of
X as input arguments.
An interpretation for (S, R) is a subset of Sch. We denote by I the set of all the interpretations, which is a complete lattice under subset ordering. A model is an interpretation I such that, for each inference rule r ∈ R, it is
r(I) ⊆ I .	(5)

Models form a complete lattice under the same ordering of the interpretations. However, it is not a sublattice, since the join operator and the bottom element differ. In particular, the bottom element of the lattice of models is what we call declarative semantics of the sequent calculus and we denote it by D.
D turns out to be the set of final proofs of (S, R). Hence, the declarative semantics precisely captures all the terminating computations. For a valid treatment of compositionality, we also need information about partial compu- tations [6]. If ϵ is the set of all the empty proof skeletons, we call complete declarative semantics of (S, R) and we denote it by Dc, the least model greater
then ϵ. It is possible to prove that Dc is actually the set of all the proofs of (S, R).
We have a bottom-up and a top-down construction of the least models using a couple of operators, similar in spirit to the immediate consequence operator TP and the unfolding operator UP for logic programs. The bottom-


up F operator, mapping interpretations to interpretations, is defined as follows
F (I) = I ∪ [ v(I) ,	(6)
r∈R
while the top-down U operator is
U (I) = [ π(R∪ ϵ) .	(7)
π∈I


The following properties hold:

F ω(∅) = D ,	(8)

F ω(ϵ) = Dc = U ω(ϵ) .	(9)
Abstractions
It is now possible to use the techniques of abstract interpretation [12] to de- velop a range of abstract semantics for sequent calculi. We call observable a triple (A, α, γ) where A (the abstract domain) is an ordered set w.r.t. the relation ≤ and α : I → A (the abstraction function) is a monotonic function with γ as right adjoint. Since α and γ in (A, α, γ) uniquely determine each other [13], we will often refer to an observable just by the abstraction function.
Given an observable and an operator on interpretations ⊗, we denote by
⊗α the corresponding optimal abstract operator on A. All the common results of the theory of abstract interpretation are inherited by our framework. In particular, the following properties hold:
F ω(α(∅)) ≥ α(D) ,	(10)
F ω(α(ϵ)) ≥ α(Dc) ,	(11)
U ω(α(ϵ)) ≥ α(Dc) .	(12)
This means we can compute an approximation of the abstract semantics α(D) working entirely within the abstract domain A.
Following the terminology introduced in [10,9] and [2], when Fα is precise (i.e.  when Fα ◦ α = α ◦ F ) the observable α is said to be denotational. In this case, the “greater than” sign in the equations (10) and (11) can be replaced by an equality sign. When Uα is precise, the observable is operational and the equation (12) become an equality. When α is both operational and denotational, it is called perfect.

Correct Answers and Resultants
The concepts of correct answer and computed answer are the cornerstones of the theory and practice of logic programming. If we want to extend the results we have for Horn clauses to other logic languages, we need to find



Γ1, B, C, Γ2 → ∆ interchangeL	Γ → ∆1, B, C, ∆2
interchangeR

Γ1, C, B, Γ2 → ∆	Γ → ∆1, C, B, ∆2
Γ, B,B → ∆ contractionL	Γ → B, B, ∆ contractionR
	
Γ,B → ∆	Γ → B, ∆



Γ,B → B, ∆
id where B = ⊥ or B is an atomic formula	Γ → ⊥ ⊥R
Γ → ∆

Γ → B, ∆
Γ → B ∨ C, ∆ ∨R1
Γ → B, ∆
Γ → C ∨ B, ∆ ∨R2
Γ,B → D, ∆	Γ,C → D, ∆
Γ,B ∨ C → D, ∆	∨ L

 Γ, B1, B2 → C, ∆ 	Γ → B, ∆  Γ → C, ∆

Γ, B1
∧ B2
→ C, ∆ ∧ L
Γ → B ∧ C, ∆	∧ R

Γ → B, ∆  Γ,C → ∆
Γ,B ⊃ C → ∆	⊃ L
Γ,B → C, ∆
Γ → B ⊃ C, ∆ ⊃ R


Γ, B[x/t] → ∆ Γ, ∀x.B → ∆ ∀L
Γ, B[x/a] → ∆
Γ → B[x/a], ∆
Γ → ∀x.B, ∆  ∀R where a is a fresh free variable
Γ → B[x/t], ∆

Γ, ∃x.B → ∆  ∃L where a is a fresh free variable
Γ → ∃x.B, ∆  ∃R


Fig. 1. Inference rules for classical logic

an analogous of these concepts in the new settings. Actually, since we are not discussing any computational mechanism, we only focus our attention to correct answers.
For the sake of clarity, we will assume to work in the domain of first order classical and intuitionistic logic. Therefore, we have a term signature Σ, a predicate signature Π and two infinite dijoint sets V and W of free and bound variables. The use of different sets for free and bound variables, although it is not needed, greatly simplifies proofs and statements of theorems [15].
Terms and formulas are defined as usual, sequents are made of two se- quences of formulas, separated by the symbol →, and inference rules are those obtained as instances of the schemas in Figure 1. When we want to denote a particular inference rule, we index the name of the schema in figure with the formulas occurring in the instance. For example, ∧Lλ,φ,φ',ψ,∆ is
φ, φ' → ψ, ∆
φ ∧ φ' → ψ, ∆ .	(13)

Intuitionistic logic differs from classical one by allowing at most one formula in the right hand side of the sequents. The common abbreviation ∃x1,... , xn.φ stands for ∃x1. ··· ∃xn.φ. We also write ∃φ and ∀φ for the existential and universal closure of φ. A Horn sequent is a sequent of the form Γ → ∃φ where Γ is a sequence of universal closures of definite clauses, and φ is a definite goal.


Correct Answers as Proof-Theoretical Properties
Given a Horn sequent S = Γ → ∃x.φ, according to the standard definition, a correct answer for the goal ∃x.φ in the program Γ is a substitution θ for x such that Γ → φθ is provable. In the following, we refer to θ as a correct answer for the sequent S. According to this definition, the concept of correct answer seems strictly related to model theory. It is essentially an assignment for the variables in x such that φ in valid in every Herbrand model of Γ.
However, if π is an intuitionistic proof for S, a correct answer for ∃x.φ can be extracted from π by examining the instances in π of the ∃R schema.
Example 3.1 If S is the sequent p(0), ∀x.p(x) → ∃y.p(y), then y/t is a correct answer for each term t. If π is the proof


id
∀x.p(x), p(0) → p(0)
∃R
∀x.p(x), p(0) → ∃y.p(y)

(14)

the ∃R rule gives origin to the correct answer y/0.
When we use hereditary Harrop formulas, we can keep the same defini- tion of correct answers we have for Horn clauses. However, the amount of information we obtain in this way is rather limited. For example, the sequent
∀x.p(x, x) → ∀y.∃z.p(y, z), only has a trivial empty correct answer, since the
right hand side of the sequent is not an existentially quantified formula. On the contrary, let us give a look to a proof of the same sequent:
id
p(a, a) → p(a, a)
∃R

p(a, a) → ∃z.p(a, z)
∀R
∀x.p(x, x) → ∃z.p(a, z)
(15)

∀L
∀x.p(x, x) → ∀y.∃z.p(y, z)

If we keep track of the occurrences of both the ∃R and ∀R inference rules, we obtain a substitution {y/a, z/a}. This makes explicit that for each y we have a z such that p(y, z) is true, and that y and z do coincide. Moreover, if we apply the substitution {y/a, z/a} to the right hand side, discarding all the quantifiers, we obtain the sequent ∀x.p(x, x) → p(a, a) which is trivially provable.
If we further extend the language to handle the full first order logic, we have to treat with sequents like ∃x.p(s(x)) → ∃y.p(y). Here, again, the stan- dard “model-theoretic” definition of correct answers gives us no interesting information, since there are no correct answers according to that definition. Actually, the sequent ∃x.p(s(x)) → p(t) is not provable for any term t. Let us


consider the following proof:
id
p(s(a)) → p(s(a))

∃R
p(s(a)) → ∃y.p(y)
∃L
(16)

∃x.p(s(x)) → ∃y.p(y)
If we keep track of all the instances of a quantifier introduction rule, we obtain a substitution {x/a, y/s(a)}. Here, the role of a is that of a witness. The existential quantifier on the left hand side produces a new object a such that p(s(a)) holds. The binding {y/s(a)} makes clear that the object y such that p(y) holds is s(a), where a is the same produced by the other existential quantifier. Again, if we apply the substitution discarding the quantifiers, we obtain the sequent p(s(a)) → p(s(a)) which is provable.
In the general case, we cannot bind a variable with a single term. For example, consider the sequent p(a) ∨ p(b) → ∃x.p(x), and the proof


id
p(a) → p(a)
id
p(b) → p(b)

∃R
p(a) → ∃x.p(x)
∃R
p(b) → ∃x.p(x)
∨L
(17)

p(a) ∨ p(b) → ∃x.p(x)
We have two different instances of the ∃R schema, each with a different term which is bound to the variable x. Therefore, we are led to consider bindings of the kind {x/{a, b}}.

Formalization
We now try to make precise the above informal discussion. Given a first order language (Σ, Π, V,W ), a candidate answer is a function θ : W → ℘f (FΣ(V ))

such  that  {v  ∈  W   |  θ(v)  =/
candidate answers.
∅} is finite.	We denote with Ans the set of

For each proof skeleton π, we have a corresponding candidate answer θπ
or answer(π), defined as follows:
∅	if π = id Γ,B,∆
{a}	if π = ∃LΓ,B,∆,x,a(π') or π = ∀RΓ,B,∆,x,a(π')
{t}	if π = ∃R	(π ) or π = ∀L	(π )
Sj=1...n θπj (x)	if π = v(π1,... , πn)
If π is a proof, then θπ is called the partial correct answer for π. If π is a final proof of the sequent S, then θ is a correct answer for the sequent S. The set of correct answers for the sequent S will be denoted by CAns(S), which is


defined as
CAns(S) = {θπ | π ∈ D ∩ SchS} .	(19)
We write CAnsc(S) or CAnsi(S) when we want to make clear if we are working in the realm of classical or intuitionistic logic.
Example 3.2 Let us consider the sequent S = ∀x.(p(x) ⊃ p(s(x))), p(0) →
∃y.p(y). In classical logic, θ is a correct answer for S if and only if
θ(x) ∈ ℘f (Term),
θ(y) ∈ ℘f (Term) and there exists si(0) ∈ θ(y) such that sj(0) ∈ θ(x) for every j ∈ {0,... ,i − 1}.
Here si(0) is the term s(s(··· s(0) ··· )) where s is repeated i times. In intu- itionistic logic, the form of the correct answers is simpler. In particular, θ is a correct answer for S if and only if
θ(x) ∈ ℘f (Term),
θ(y) = {si(0)} for some i ∈ N such that sj(0) ∈ θ(x) for every j ∈ {0,... , i−
1}.
The difference is due to the fact we cannot apply the contraction rule on the consequent.
Note that, often, a correct answer for the sequent S is meaningful only if there are no two different bindings for the same variable. In the following, we will call pure every sequent which satisfies this condition.
Our definition of correct answers essentially collects all the occurrences of introduction rules for quantifiers in a proof. A problem is that most of the answers we obtain are trivial. For example, given a sequent ∀x.φ → ∆ and a correct answer θ, then θ[x/L] is a correct answer, too, for each L = θ(x) ∪ F where F is a set of terms renamed apart from θ.
As a result, we are particularly interested to minimal correct answers, ac- cording to the obvious point-wise ordering. Proofs corresponding to minimal
answers are a sort of “non-redundant” proofs, where quantifiers are intro- duced only when they are really needed. In formulas, we denote by mAnsc(S) (mAnsi(S)) the set of minimal correct answer for the sequent S w.r.t. classical (intuitionistic) logic.
Example 3.3 In the previous example, both classic and intuitionistic logic have the same set of minimal correct answers, i.e. those θ such that
θ(y) = {si(0)} for some i ∈ N,
θ(x) = {sj(0) | j ∈ {0,... ,i − 1}}.
Note that we have a lot of information from these. We know that p(si(0)) is true for every i ∈ N. Moreover, we know that, in order to prove p(si(0)), we need to apply a ∀L introduction rule for the first binding with different terms,


namely all the sj(0) for j from 0 to i − 1.
In general, if mAnsc(S) /= mAnsi(S), it means that there is a proof of S which is “intrinsically” classical. We do not make precise this statement, since it requires further investigations. However, from an intuitive point of view, consider the following proof π of the sequent p(a) ∨ p(b) → ∃x.p(x) : 


id
p(a) → p(a), p(b)
id
p(b) → p(a), p(b)
∨L

p(a) ∨ p(b) → p(a), p(b)
∃R 2 times
p(a) ∨ p(b) → ∃x.p(x), ∃x.p(x)
(20)

p(a) ∨ p(b) → ∃x.p(x)
contractionR

If we move the ∃R rules upward, before the ∨L rule, we can easily obtain an intuitionistic proof π' such that θπ' ≤ θπ = {x/{a, b}}. However, consider the following proof π
id
p(a), p(b) → p(b), ⊥
∃R
p(a), p(b) → ∃x.p(x), ⊥
∃L
p(a), ∃y.p(y) → ∃x.p(x), ⊥
⊃ R

p(a) → ∃y.p(y) ⊃ ⊥, ∃x.p(x)


p(a) → ∃x.p(x) ∨ (∃y.p(y) ⊃ ⊥), ∃x.p(x) ∨ (∃y.p(y) ⊃ ⊥)


p(a) → ∃x.p(x) ∨ (∃y.p(y) ⊃ ⊥)
∨R (2 times) contractionR
(21)


Although the root sequent is intuitionistically provable, we are not able to write an intuitionistic proof π' such that θπ' ≤ θπ = {x/b, y/b}. This is because the use of the contraction rule in π is essential to the effort of moving
∃y.p(y) on the left side while keeping ∃x.p(x) on the right side.
If we compare the “standard” correct answers for Horn clauses with our minimal correct answers, we have a more general definition. However, if we restrict our answers to the existential quantifiers, we obtain the same results.

Theorem 3.4 If S = Γ → ∃x1. ··· ∃xn.φ is a pure Horn sequent, then η is a “standard” correct answer for S iff there is a minimal correct answer θ such that θ(xi) = xiη for each i ∈ {1,... , n}.

Note that we have not specified if the minimal correct answer should be considered w.r.t. intuitionistic or classical logic. Actually, if S is a pure Horn sequent, it is mAnsi(S) = mAnsc(S).


Resultants
Another typical abstraction of SLD-derivations is those of resultants [16]. A resultant for a goal G in a program P is a pair made of a partial computed answer for G and a new goal G’ which still needs to be refuted. We present an observable for proof skeletons which is inspired by this “standard” idea of resultant, although the relation here is more shallow than for correct answers.
Until now we have considered sequents as sequences of formulas. However, classical and intuitionistic logics are often presented by defining a sequent as a set of formulas. We use the term set sequent to refer to this alternative definition and we denote by SetS the collection of all the set sequents. If S ∈ S, we write S¯ for the corresponding element in SetS.
We call resultant a pair (θ, S) where θ ∈ Ans and S is a finite multi-set of set sequents. We denote by Res the set of all the resultants. For each proof skeleton π : S1,... , Sn ▶ S, we define a corresponding res(π) as
res(π) = (θπ, [S¯1,... , S¯n♩) ,	(22)
where [ ♩ denote a multi-set. If π is a proof for the sequent S, then res(π) is a correct resultant for S. The set of correct resultants for S will be denoted by CRes(S), which is defined as
CRes(S) = {res(π) | π ∈ Dc ∩ SchS} .	(23)
We write CResc(S) or CResi(S) when we want to specify if we are working in the realm of classical or intuitionistic logic. We define an order relation between two resultants, according to the following equation
(θ, S) ≤ (θ', S') iff θ ≤ θ' and S ⊆ S' .	(24)
Again, we talk of minimal correct resultants for the elements of CRes(S) which are minimal w.r.t. ≤. We denote the corresponding sets as mResc(S) and mResi(S).
Example 3.5 Let us consider the sequent S = p(0) → ∃x.p(x).  The set
mResc(S) contains all the pairs (θ, S) such that
θ = {x/0} and S = ∅, or
θ = {x/t} for t /= 0 and S = [p(0) → p(t)♩, or
θ = {x/t} for t /= 0 and S = [p(0) → ⊥♩. The same happens for mResi(S).
It is trivial to prove that the following correspondences hold between cor- rect answers and correct resultants:
CAns(S) = {θ | (θ, ∅) ∈ CRes(S)} ,	(25)
mAns(S) = {θ | (θ, ∅) ∈ mRes(S)} .	(26)

Observables
Now that we have defined what a correct answer is, we would like to find a bottom-up and a top-down construction for CAns and mAns. Following the abstract framework in [3], we define the observable of candidate answers as a tuple →[S → ℘(Ans)], αc, γc⟩ where [S → ℘(Ans)] is the set of functions from sequents to sets of candidate answers and
αc(I)(S) = {θπ | π : ·▶ S ∈ I} .	(27)
It is trivial to show that αc(D)(S) is exactly the set CAns(S) of all the correct answers for the sequent S. The optimal abstract operator corresponding to F is Fαc . Assuming A in the image of αc, it is
Fαc (A)(S) = A(S) ∪ [{vαc (A) | v ∈ R, root(v) = S} ,	(28) where, for each v : S1 ... Sn ▶ S ∈ R,
vαc (A) = {vαc (θ1,... , θn) | ∀i ∈ {1,... , n}, θi ∈ A(Si)} ,	(29)


and

θ1 ∪ [x/t]	if v is an introduction rule for a quantifier

vα (θ1,... , θn) = 
which replaces the bound variable x with

c	t,

θ1 ∪· · ·∪ θn	otherwise.

(30)

Here we write θ1 ∪θ2 for the candidate answer θ such that θ(x) = θ1(x) ∪θ2(x) for each x ∈ V and [x/t] for the candidate answer θ such that θ(x) = {t} and θ(y) = ∅ for y /= x.
Theorem 4.1 The observable αc of candidate answers is denotational.
We also have an observable for resultants which gives origin to complete bottom-up and top-down semantics. It is defined as the tuple →[SetS →
℘(Res)], αr, γr⟩ with the abstraction function

αr(I)(S¯) = {res(π) | π ∈ I, root(π) = S¯} .	(31)
The definition of the optimal bottom-up fixpoint operator is straightfor- ward. With respect to the top-down fixpoint operator, assuming A in the image of αr, we have

Uαc (A)(S¯) =	[
δ∈A(S¯)
δ(R∪ ϵ) ,	(32)

where, if δ = (θ, [S¯1,... , S¯n♩),

δ(X) = {δ([π1,... , πn♩) | ∀i ∈ {1 ... n}, πi ∈ X ∩ SchS' and S¯' = S¯i} ,
i	i
(33)

and
δ([π1,... , πn♩) = θ ∪ [x1/t1] ∪ ··· ∪ [xm/tm], [hyp(π1), ··· , hyp(πn)♩  ,
(34)

where, for each pair (xi, ti), there is an introduction rule for quantifiers among
{π1,... , πn} which replaces the variable xi with ti.
Theorem 4.2 The observable αr of correct resultants is perfect.
Since αr is a perfect observable, we could build a top-down interpreter which computes correct resultants. However, the efficient implementation of such an interpreter is a very difficult task which is the realm of automatic deduction. Here, we are more interested in computing abstractions of correct resultants, which can be used for static analysis of logic languages.


Groundness
If θ is a candidate answer for the sequent S, we say that θ is grounding for the variable x when θ(x) only contains variables which occur free in S. Let us define by GAns the set of functions V → ℘({g, ng}), which we call groundness answers. Given a candidate answer θ for the sequent S, we define a corresponding groundness answer β = groundS(θ) such that
g ∈ β(x) iff there exists t ∈ θ(x) such that vars(θ) ⊆ FV(S),
ng ∈ β(x) iff there exists t ∈ θ(x) such that vars(θ) /⊆ FV(S),
where FV(S) is the set of free variables in S. Then, we can define a Galois connection →αg, [S → ℘(Ans)], [S → ℘(GAns)], γg⟩ where
αg(A)(S) = {groundS(θ) | θ ∈ A(S)} .	(35) Then, by composing αg with αc, we obtain an observable →℘(GAns), αg ◦αc, γc ◦
γg⟩ for groundness answers. If β ∈ αg(CAns(S)), then β is a correct groundness answer. Moreover, if β ∈ αg(mAns(S)), then β is minimal according to the
obvious point-wise ordering.
Example 4.3 Let us give some examples of sequents and their corresponding


correct minimal groundness answers for intuitionistic logic.


sequent
∀y.p(y) → ∃x.p(x)
∀y.(p(a, y) ∧ p(y, b)) → ∃x.p(x, x)
p(a) ∨ v(b) → ∃x.(p(x) ∨ v(x))
⊥ → ∃x.p(x)
∀y.p(y, y) → ∀x1.∃x2.p(x1, x2)
∀x1. ∃x2. p(x1, x2) → ∃y.p(y, y)
∃y.p(y) → ∃x.p(x)
p(t(a)) → ∃x.p(v(x))
p(a) ∨ ∃x.v(x) ▶ ∃y.(p(y) ∨ v(y))
groundness answers
{x/g, y/g} {x/ng, y/ng}
{x/g, y/g}
{x/g}
{}
{y/g, x1/g, x2/g}, {y/ng, x1/ng, x2/ng}
—
{x/ng, y/ng}
—
{x/ng, y/{g, ng}}


Note that if θ is a correct answer for S and x is a bound variable which only appears in a negative existential quantifier, then θ is not grounding for
x. The same happens for positive universal bindings.
We may ask ourselves which is the correspondence between our observable and standard domains for analysis of groundness such as POS [5]. It is possible to prove the following
Theorem 4.4 Let P be a deﬁnite program and G a deﬁnite goal. We work in the realm of intuitionistic logic. Assume S = Γ → ∃x1,... , xn. G is the cor- responding pure Horn sequent. Consider x1,... , xn as propositional symbols and deﬁne the formula
Θ =	_	{∧ixβ(xi)} ,	(36)
β∈GAns(S)

where x{g} = xi and x{ng} = ¬xi. Then Θ is a positive formula.
i	i
Moreover, if X is the set of correct answers of G in P, let ℵ = αPOS(X).
Then ℵ and Θ are equivalent formulas.
We can also build an abstraction for groundness analysis starting from re- sultants. Given a formula φ, we denote by αv(φ) an abstract formula obtained from φ by replacing each term with the set of free variables occurring in them. Let us call by GS the set of abstract set sequents obtained from abstract for- mulas. A groundness resultant is a pair (β, ν) such that β ∈ GAns and ν is a multi-set of elements of GS. We write as GRes the set of groundness resul- tants. Then, we can define a Galois connection →αrg, [SetS → ℘(Res)], [GS → 

℘(GRes)], γrg⟩, where
αrg(A)(S) = {(groundS(θ),{αv(S¯1),... , αv(S¯n))}| 
(θ, {S¯ ,... , S¯ }) ∈ A(S¯), S = α (S¯)} .	(37)
1	n	v
We can compose αrg with αr to obtain a new observable which is well suited for a top-down analysis of correct groundness resultants. Following this idea, we have developed a prototypical abstract interpreter for intuitionistic logic. It is written in PROLOG and can be found at the author home page:
http://www.dimi.uniud.it/~amato
Example 4.5 By applying our analyzer to the sequents in the Example 4.3 we obtain precisely the same set of correct groundness answers, with the following exceptions:


sequent
p(t(a)) → ∃x.p(v(x))
∀x1. ∃x2. p(x1, x2) → ∃y.p(y, y)
groundness answers
{x/ng}
{y/ng, x1/ng, x2/ng}

The previous example shows two different situations in which we loose precision. The first one is due to the fact that we abstract a term with the set of its free variables, discarding information about the functors. The second situation arises from the fact that the abstract domain is not enough powerful to keep track of the side condition for the ∃L and the ∀R introduction rules. To overcome this problem, we would need to improve the representation of abstract terms, by introducing a sort of labeling similar to what [22] does for hereditary Harrop formulas.

Conclusions and Future Works
In this paper we have presented a new definition for correct answers and correct resultants which can be applied to the full first order logic (both classical and intuitionistic). Moreover, we have shown that a well known abstraction of logic program semantics, namely groundness, can be easily reintroduced inside our framework. This definitions are so general that they can be reused with only slight changes for every logic system with standard quantifier rules, such as linear logic or modal logic. We think that, w.r.t. [3], our new definitions of correct answers and groundness answers give us more intuitive and accurate results and a much cleaner theory.
From the point of view of the implementation of abstract domains, several things can be improved in the framework. For example, while a top-down analyzer can often be implemented straightforwardly, like our interpreter for groundness, the same definitely does not hold for bottom-up analyzers. Since for a bottom-up analysis we have to build the entire abstract semantics of a


sequent calculus, we need a way to isolate a finite number of “representative sequents” from which the semantics of all the others can easily be inferred: it is essentially a problem of compositionality.
We are actually studying this problem and we think that extending the notion of a sequent calculus with the introduction of some rules for the decom- position of sequents will add to the theoretical framework the power needed to easily derive compositional F operators.
We also need a way to reduce nondeterminism in abstract interpreters. This is a problem which has been tackled thoroughly in the field of automatic deduction. A standard solution is to use unification to reduce nondeterminism in the introductions of quantifiers [7,24]. We would like to treat unification in our framework, and we want to do this without any major modification. We are working in the direction of defining an abstraction of proof skeletons using extra-logical variables such that the corresponding optimal abstract operators automatically computes the semantics trough unification.

Proofs
Lemma 6.1 If the pure sequent S = Γ → ∃x.φ has a correct answer θ such that θ(x) = ∅, then Γ → ⊥ is provable.
Proof. If π is a final proof of S and θπ(x) = θ(x) = ∅, then there are no occurrences of ∃R inference rules, with ∃x.φ as the principal formula, in π. However, looking at the form of inference rules in Figure 1, it is evident that we need a way to discard the existential quantifier from the right hand side of the sequent and the only way, other than an ∃R rule, is a ⊥R rule.
Then, for each path in π from the root to the leafs, either ∃x.φ is never the principal formula of an introduction rule, or a ⊥R inference rule is applied. We can obtain a new proof π' of Γ → ⊥ just replacing every occurrence of
∃x.φ with ⊥, and deleting the ⊥R rules which are now useless.	✷
Proof. [of theorem 3.4] Assume η is a standard correct answer for S. It means that S' = Γ → φη is provable. Let π' be a proof of S'. If we apply a series of
∃R rules to π', we obtain a proof π for S. It is trivial that θπ(xi) = {xiη} for each i ∈ {1,... , n}. Now, consider the set of all the correct answers θ' for S such that θ' ≤ θπ. If θ'(xi) /= θπ(xi), then θ'(xi) = ∅, since θ(xi) is a singleton. By the previous lemma, however, this would mean that Γ is inconsistent, and this is not possible for Horn clauses. Then, if we take θ to be a minimal θ', we prove half of the theorem.
Now, assume θ is a minimal correct answer for S. We want to prove that, if we define η(xi) = θ(xi) for i ∈ {1,... , n}, then Γ → φη is provable. If π is a proof such that θ = θπ, we can think of permuting the inference rules to obtain a new proof π' with θπ' = θ and all the ∃R rules applied just after the root. Since in Horn clauses we do not have positive universal quantifiers or negative existential quantifiers, in π there are no occurrences of ∀R or ∃L

rules. As a result, in π there are no eigenvariables. Therefore, rules in classical logic can be permuted freely to obtain π'. If we work in intuitionistic logics, not all the permutations are allowed, but Kleene in [19] shows that the only rules ∃R does not permute with are ∨L and ∃L. Neither of this can never be applied if Γ is made of Horn clauses, hence π' can be found in intuitionistic logic, too. If we drop the ∃R rules from π', we remain with a proof of Γ → φη and the theorem is proved.	✷
Proof. [of Theorem 4.1] We need to prove that
Fαc (αc(I)) ⊆ αc(F (I)) ,	(38)
since the opposite disequality is trivial.
Assume θ ∈ Ans and θ ∈ Fαc (αc(I))(S). We have two cases: θ ∈ αc(I)(S) or θ ∈ vαc (αc(I)) for some v : S1,... , Sn ▶ S ∈ R. If θ ∈ αc(I)(S), then θ ∈ αc(F (I))(S) follows trivially. Otherwise, it is θ = vαc (θ1,... , θn), with θi ∈ αc(I)(Si) for each i ∈ {1,... , n}.
If v is an introduction rule for a quantifier, which replaces the variable x with the term t, then θ = θ1 ∪ [x/t]. Since θ1 ∈ αc(I)(S1), there exists a final proof skeleton in I with θ1 = θπ. By applying the rule v to π, we obtain a new final proof skeleton π' : · ▶ S such that θ = θπ' . Since π' ∈ F (I), it is θ ∈ αc(F (I))(S).
If v is not and introduction rule for a quantifier, then θ = θ1 ∪... ∪θn. For each θi, there exists a proof πi : ··· ▶ Si in I. By applying the rule v to π, we can reason as in the previous case, and we prove the theorem.	✷
Proof. [of Theorem 4.2] We need to prove that αr is both operational and denotational. We only prove it is operational, since the other proof proceeds as for Theorem 4.1. Actually, we only need to check the disequality
Uαr (α(I)) ⊆ αr(U (I)) ,	(39)
since the opposite one is trivial.
If δ = (θ, [S¯1,... , S¯n♩) ∈ Uα (αr(I))(S), there is a δ' = (θ', [S¯' ,... , S¯' ♩)
r	1	m
in αr(I)(S) such that δ = δ'([v1,... , vm♩), where vi ∈ R ∪ ϵ for each i ∈

{1,... , m}. By the definition of αr, there is a proof π' : Z' ,... , Z'
▶ Z in

1	l
I with Z, Z' ∈ S, Z¯ = S¯, [Z¯' ,... , Z¯'♩ = [S¯' ,... , S¯' ♩ and θπ' = θ'. We
i	1	l	1	m
can apply π' to appropriate v' ,... , v' such that [v¯1,... , v¯n♩ = [v¯' ,... , v¯' ♩ to
1	n	1	n
obtain a proof π : Z1,... , Zr ▶ Z ∈ U (I) with [Z¯1,... , Z¯r♩ = [S¯1,... , S¯m♩
and θπ = θ. This proves the theorem.	✷
Proof. [of Theorem 4.4] First of all, since Horn clauses are always consistent, it follows from Lemma 6.1 that, if β is a correct groundness answer for S, then θ(xi) /= ∅. Moreover, since we work in intuitionistic logic, each ∃R inference rule can be applied only once for each variable, hence β(xi) is a singleton for each xi. Therefore, xβ(xi) is well defined.


Now, consider an ordering ≤ on {g, ng} such that g ≤ ng with the corre- sponding lifting to groundness answers. If S = Γ → ∃x1,... , xn. G is a pure Horn sequent and β is a correct groundness answer, we call existential ground- ness answer the restriction of β to {x1,... , xn}. We denote by EAns(S) the set of all the existential groundness answer for the sequent S. If β ∈ EAns(S), then β' ∈ EAns(S) for each β' ≤ β. Therefore, consider the formula Θ. If S is a provable, there is an existential groundness answer β and, by the previous property, the answer β' ≤ β such that β'(xi) = {g} for each i is an element of EAns. Hence Θ is positive.
We still need to prove that Θ and ℵ are equivalent. Given an assignment ν of truth values to x1,... , xn, Θ is true iff there is an existential answer β such that β(xi) = {g} if ν(xi) = true, β(xi) = {ng} otherwise. In turn, this means that there exists a correct answer θ such that vars(θ(xi)) /⊆ FV(S) for each i with ν(xi) = false. Since FV(S) = ∅, it means that there is a correct answer θ such that θ(xi) is not ground for each xi ∈ ν−1(false).
By the definition of αPOS, we have that ℵ is true under the assignment ν iff for each correct answers θ, θ(xi) is ground if ν(xi) = true. But this is equivalent to state that there exists a correct answer θ such that ν(xi) = false implies θ(xi) not ground. Actually, this is the same statement which holds for Θ, then we have proved the required equivalence.	✷

References
Amato, G., “Sequent Calculi and Indexed Categories as a Foundation for Logic Programming,” Ph.D. thesis, Dipartimento di Informatica, Universita` di Pisa (2000).
Amato, G. and G. Levi, Properties of the lattice of observables in logic programming, in: M. Falaschi and M. Navarro, editors, Proceedings of the APPIA-GULP-PRODE’97 Joint Conference on Declarative Programming, 1997, pp. 175–187. 
Amato, G. and G. Levi, Abstract Interpretation Based Semantics of Sequent Calculi, in: J. Palsberg, editor, Static Analysis Symposium 2000, Lecture Notes in Computer Science 1824 (2000), pp. 38–57. 
Andreoli, J. M., Logic programming with focusing proofs in linear logic, Journal of Logic and Computation 2 (1992), pp. 297–347. 
Armstrong, T., K. Marriott, P. Schachte and H. Søndergaard, Boolean functions for dependency analysis: Algebraic properties and efficient representation., in: B. Le Charlier, editor, Proc. Static Analysis Symposium, SAS’94, Lecture Notes in Computer Science 864 (1994), pp. 266–280. 
Bossi, A., M. Gabbrielli, G. Levi and M. C. Meo, A Compositional Semantics for Logic Programs, Theoretical Computer Science 122 (1994), pp. 3–47. 


Bowem, K., Programming with full ﬁrst-order logic, Machine Intelligence 10
(1982), pp. 421–440. 
Brogi, A., P. Mancarella, D. Pedreschi and F. Turini, Modular logic programming, ACM Transactions on Programming Languages and Systems 16 (1994), pp. 1361–1398. 
Comini, M., “An Abstract Interpretation Framework for Semantics and Diagnosis of Logic Programs,” Ph.D. thesis, Dipartimento di Informatica, Universita´ di Pisa (1998).
Comini, M., G. Levi and M. C. Meo, A theory of observables for logic programs, Information and Computation (2001), to appear.
Comini, M., G. Levi, M. C. Meo and G. Vitiello, Abstract Diagnosis, Journal of Logic Programming 39 (1999), pp. 43–93, Special Issue on Synthesis, Transformation and Analysis of Logic Programs.
Cousot, P. and R. Cousot, Abstract Interpretation: A Uniﬁed Lattice Model for Static Analysis of Programs by Construction or Approximation of Fixpoints, in: Proc. Fourth ACM Symp. Principles of Programming Languages, 1977, pp. 238–252.
Cousot, P. and R. Cousot, Abstract Interpretation and Applications to Logic Programs, Journal of Logic Programming 13 (1992), pp. 103–179. 
Debray, S. K., Formal bases for dataflow analysis of logic programs, in: G. Levi, editor, Advances in logic programming theory, Clarendon Press, Oxford, 1994 pp. 115–182. 
Feferman, S., Lectures on proof theory, in: M. Lob, editor, Proceedings of the Summer School in Logic, Leeds ’67, Lecture Notes in Mathematics 70 (1968), pp. 1–107. 
Gabbrielli, M., G. Levi and M. C. Meo, Resultants semantics for PROLOG, Journal of Logic and Computation 6 (1996), pp. 491–521. 
Gentzen, G., Untersuchungen u¨ber das logische Schliessen, Mathematische
Zeitschrift 39 (1935), pp. 176–210, 405–431, english translation in [18], pp. 
68–131.
Gentzen, G., “Collected Papers of Gerhard Gentzen,” North Holland, Amsterdam, 1969, edited by M.E. Szabo.
Kleene, S., Permutability of inferences in Gentzen’s calculi LK and LJ, Memoris of the AMS 10 (1952).
Lloyd, J. W., “Foundations of Logic Programming,” Springer-Verlag, Berlin, 1987, second edition.
Miller, D., F. Pfenning, G. Nadathur and A. Scedrov, Uniform proofs as a foundation for Logic Programming, Annals of Pure and Applied Logic 51 (1991), pp. 125–157. 


Nadathur, G., A Proof Procedure for the Logic of Hereditary Harrop Formulas, Journal of Automated Reasoning 11 (1993), pp. 115–145. 
Nadathur, G. and D. Miller, An Overview of λProlog, in: K. A. Bowen and R. A. Kowalski, editors, Fifth International Logic Programmiong Conference (1988), pp. 810–827. 
Shankar, N., Proof search in the intuitionistic sequent calculus, in: M. Stickel, editor, 10th Int. Conf. on Automated Deduction, Lecture Notes in Artifical Intelligence 449 (1990), pp. 522–536. 
