Electronic Notes in Theoretical Computer Science 72 (2007) 59–74	
www.elsevier.com/locate/entcs

A Duality in Proof Systems for Recursive Type Equality and for Bisimulation Equivalence on Cyclic Term Graphs
Clemens Grabmayer1 ,2
Department of Mathematics and Computer Science Vrije Universiteit Amsterdam
de Boelelaan 1081a, 1081 HV Amsterdam, The Netherlands

Abstract
This paper is concerned with a proof-theoretic observation about two kinds of proof systems for regular cyclic objects. It is presented for the case of two formal systems that are complete with respect to the notion of “recursive type equality” on a restricted class of recursive types in μ-term notation. Here we show the existence of an immediate duality with a geometrical visualization between proofs in a variant of the coinductive axiom system due to Brandt and Henglein and “consistency-unfoldings” in a variant of a ‘syntactic-matching’ proof system for testing equations between recursive types due to Ariola and Klop. Finally we sketch an analogous result of a duality between a similar pair of proof systems for bisimulation equivalence on equational specifications of cyclic term graphs.
Keywords: Recursive types, recursive type equality, bisimulation, cyclic term graph


Introduction
The main part of this paper is concerned with an observation about two complete proof systems for the notion of “recursive type equality” on recursive types.
There are to our knowledge basically two different complete axiom systems known for recursive type equality: (i) A system due to Amadio and Cardelli given in [1] (1993) and (ii) a coinductively motivated axiom system introduced by Brandt and Henglein in [3] (1998). Apart from these axiomatizations, it is also possible to consider (iii) a ‘syntactic-matching’ proof system for which a notion of consistency relative to this system is complete for recursive type equality. Such a system can

1 Email: clemens@cs.vu.nl ; homepage: http://www.cs.vu.nl/~clemens .
2 I want to thank J.W. Klop for suggesting this study and for providing me with a couple of initial ideas. And I am also much indebted to Bas Luttik for his careful reading of drafts for this paper. Finally I would like to thank the referees, i.p. for a list with suggestions of specific alterations.

1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2002.09.007

be defined in a very similar way to one that was introduced by Ariola and Klop in
[2] (1995) for the notion of bisimulation equivalence on equational representations of cyclic term graphs. For our purpose we will consider only ‘normalized’ variants without symmetry and transitivity rules of the Brandt–Henglein and syntactic- matching systems. In Section 3 these variant systems will be defined and their respective soundness and completeness theorems stated.
It was noted by Klop that there appears to be a striking similarity between the activities of (a) trying to demonstrate the consistency of an equation between recursive types with respect to the syntactic-matching system and of (b) trying to prove the same equation in the system of Brandt and Henglein. This basic observation underlying the present paper will be described in Section 4.
In order to extract a precise statement from this intuitive recognition, two formal prerequisites turn out to be necessary: Firstly, in Section 5 we will introduce an extension of the variant Brandt–Henglein system with some more coinductive rules. And secondly, in Section 6 we define so called “consistency-unfoldings” of given equations between recursive types in the variant ‘syntactic-matching’ system as certain formalizations of successful consistency-checks. With these notions our main theorem is stated in Section 7: There exists even a “duality” via easily definable reflection mappings between derivations in the variant Brandt–Henglein system and corresponding consistency-unfoldings in the variant syntactic-matching system.
In Section 8 we furthermore outline an analogous result for a similar pair of proof systems concerned with the bisimulation relation on equational specifications of cyclic term graphs.

Preliminaries on recursive types
As in Brandt and Henglein [3] we consider only recursive types denoted by μ-terms in canonical form over the restricted class of finite types with → as the single type constructor. We assume a countably infinite set TVar of type variables. The small Greek letters α and β (possibly with subscripts) will be used as syntactical variables for type variables and the letters τ, σ, ρ, χ for recursive types.
Definition 2.1 (Recursive Types in Canonical Form).  The set can-μTp of
recursive types in canonical form is generated by the following grammar:
τ ::= ⊥| T| α | τ1 → τ2 | μα. (τ1 → τ2)	.	(2.1)
where`α ∈˛f¸v(τ1 x→ τ2)
By can-μTp–Eq we denote the set of all equations τ = σ between recursive types
τ and σ in canonical form.
The recursive types in can-μTp are in “canonical form” due to the two require- ments in the last disjunctive clause in grammar (2.1): For given α ∈ TVar the μ-operator may only be applied to a previously formed expression τ if τ is of the form τ1 → τ2 and if α occurs free in τ1 → τ2 . – Our results do not depend on the limitation to consider recursive types in canonical form only (cf. forthcoming [4]).



Figure 1 Example of two strongly equivalent recursive types.
We consider the recursive types in canonical form
τ :≡ μα. ((α → α) → α)	and	σ :≡ μα. (α → (α → α)) .
These correspond respectively to the different cyclic term graphs


G(τ )= 
˛→,r¸~J ~¸,  ¸  
  
  
and	G(σ)= 

→r,~¸~ ,, s 
,
but they possess the same tree unfolding of the form
Tree(τ )= Tree(σ)=
→,r¸~J ~,    

,,,,,
,,,,,
→,r¸~ ~, ,,s,
¸¸¸¸¸
¸¸¸¸¸
¸¸¸z→,r¸~ ~, ˛

   
 
→r,~¸~ ,,s 
¸¸¸
¸¸
→,r¸~z ~, 
   
 
→,r¸~ ~, ,s 
¸¸¸
¸¸
→,rz¸~ ~,   

,	,	,	,
,	,	,	,	.
Hence τ and σ are strongly equivalent, i.e. τ =μ σ holds, due to Definition 2.2.

Contrary to [3], we do not implicitly identify such recursive types in can-μTp that can be obtained from each other by a finite sequence of admissible renaming- steps for bound type variables, i.e. that are variants of each other. We will use the notation τ1 ≡v τ2 to express that τ1 and τ2 are variants of each other.
Via a natural transformation of μ-terms into cyclic term graphs described in (the extended version of) [2], it is possible to assign to every recursive type τ ∈ can-μTp a cyclic term graph G(τ ) whose nodes have at most two outgoing edges and are labelled by either the binary function symbol → or by a symbol of arity zero in
{⊥, T} ∪ TVar . Relying on this transformation, the tree unfolding Tree(τ ) of an arbitrary recursive type τ ∈ can-μTp can be defined as the tree unfolding of G(τ ). An alternative formal definition of Tree(τ ) can be found in [1]. 3 The leading symbol L(τ ) of a recursive type τ ∈ can-μTp is defined as the symbol that labels the root in the tree unfolding Tree(τ ) of τ . 4
Definition 2.2 (Recursive Type Equality (Strong Equivalence) =μ). Two recursive types τ, σ ∈ can-μTp are called strongly equivalent (symbolically denoted by: τ =μ σ ) iff they possess the same tree unfolding. More formally, the equivalence relation recursive type equality (also called strong recursive type equivalence ) =μ is

3 The definition in [1] is slightly more general than the one needed here because Amadio and Cardelli allow also recursive types not in canonical form like for example μα. (μβ. α) . 
4 Alternatively and more formally L(τ ) can be defined for all τ ∈ can -μTp by the 5 clauses L(⊥) := ⊥ , L(T) := T, L(α) := α (for all α ∈ TVar ) and L(τ1 → τ2) := L(μα. (τ1 → τ2)) := → (for all α ∈ TVar and τ1, τ2 ∈ can -μTp ).



Figure 2 A normalized version HB= of the coinductive axiomatization for recur- sive type equality =μ given by Brandt and Henglein.

The axioms and possible marked assumptions in HB=:
(REFL) τ = τ	(Assm) (τ = σ)x  (with x ∈ Mk ) .
The derivation rules of HB=:

 τ0[μα. τ0/α]= σ 
FOLD
 τ = σ0[μβ. σ0/β] 
FOLD

μα. τ0 = σ	l
r
τ = μβ. σ0

 τ = σ  VAR	(if τ ' ≡v τ
 τ1 = σ1	τ2 = σ2 
ARROW

τ ' = σ'
and σ' ≡v σ)
τ1 → τ2 = σ1 → σ2

⟨τ1 → τ2 = σ1 → σ2⟩x	⟨τ1 → τ2 = σ1 → σ2⟩x
D1	D2
 τ1 = σ1	τ2 = σ2  (ARROW/FIX)x

τ1 → τ2 = σ1 → σ2
(if side cond. I)	.



defined by: For all τ, σ ∈ can-μTp
τ =μ σ : ⇐⇒ Tree(τ )= Tree(σ) .
An example for Definition 2.2 and for the underlying notion of the tree unfolding of a recursive type in can-μTp is given in Figure 1.


The proof systems HB=
and AK=
for =μ

In this section we define the two proof systems on which our results will be based: A variant system HB= of the axiomatization for =μ given by Brandt and Henglein in [3] and a proof system AK= suitable for consistency-checking similar to a system defined by Ariola and Klop in [2]. We formulate these systems in natural-deduction style and for this and for later purposes we assume a countably infinite set Mk of assumption markers to be given.
Definition 3.1 (The axiom system HB= for =μ). The formal system HB= has
the equations in can-μTp–Eq as its formulas. It contains the axioms (REFL), allows marked assumptions (Assm) and has the derivation rules VAR, FOLDl, FOLDr, ARROW and ARROW/FIX listed in Figure 2. The side condition I on applications of ARROW/FIX requires that the class of discharged assumptions is actually inhabi- ted, i.e. non-empty. 5 A formula τ = σ is a theorem of HB= (symbolically denoted

by ▶HB=
τ = σ ) iff there is a derivation D in HB=
with conclusion τ = σ , in

which all marked assumptions have been discharged at respective applications of ARROW/FIX.

5 The aim here is to create a clear-cut distinction between applications of ARROW and applications of ARROW/FIX for easing the reasoning about a later defined transformation on derivations.



Figure 3 A normalized ‘syntactic-matching’ proof system AK= for checking the consistency of given equations with respect to =μ. This system is related to a one, that was introduced by Ariola and Klop.

The derivation rules of AK=:

	μα. τ0 = σ	 UNFOLD
	τ = μβ. σ0	 UNFOLD

l
τ [μα. τ /α]= σ
r
τ = σ [μβ. σ /β]

0	0	0	0


 τ = σ  VAR	(if τ ' ≡v τ
 τ1 → τ2 = σ1 → σ2  DECOMP (i = 1, 2)

τ ' = σ'
and σ' ≡v σ)
τi = σi	.


Apart from minor differences, the system HB= can be considered as a ‘norma- lized’ version of the complete axiomatization for =μ given in [3]. No symmetry and transitivity rules are present in HB= and the axioms (FOLD/UNFOLD) used in
[3] have been reformulated into the two rules FOLDl/r . HB= is ‘normalized’ in the sense that it satisfies a version of the subformula property. Although lacking the expressivity of symmetry and transitivity rules, the following also holds for HB= :
Theorem 3.2 (Soundness and Completeness of HB= with respect to =μ). The axiom system HB= is sound and complete with respect to strong recursive type equivalence =μ, i.e. for all τ, σ ∈ can-μTp it holds that

▶HB=
τ = σ	⇐⇒	τ =μ σ .

Both the soundness and the completeness of HB= with respect to =μ can be shown analogously as done by Brandt and Henglein in [3] for their system. We continue with the definition of a proof system very similar to a ‘syntactic-matching’ system introduced by Ariola and Klop in Section 3.4 of [2].
Definition 3.3 (A ‘syntactic-matching’ proof system AK= for =μ). The
formal system AK= contains precisely all equations in can-μTp–Eq as its formu- las. It contains no axioms. Its derivation rules are the rules VAR, UNFOLDl,
UNFOLDr and DECOMP that are listed in Figure 3. We will use τ = σ ▶AK= χ1 = χ2 (for
τ, σ, χ1, χ2 ∈ can-μTp ) as notation for the assertion that there is a derivation in
AK= from the assumption τ = σ with conclusion χ1 = χ2 .
The conspicuous feature of this system is the decomposition rule DECOMP,
which is a “destructive” counterpart of the “constructive” composition rules AR- ROW and ARROW/FIX in HB=. Like HB= the system AK= does not contain
0	0	0
symmetry and transitivity rules and is ‘normalized’ in the sense that it fulfills an
“inverse subformula property”.
Clearly, AK= does not axiomatize =μ, but a notion of consistency-checking with respect to AK= is sound and complete for =μ. For being able to state this properly, we need the following terminology: An equation τ = σ between recursive types is a contradiction with respect to =μ iff L(τ ) /= L(σ), i.e. iff the leading symbols of τ and σ differ. Furthermore an equation τ = σ is called AK=-inconsistent iff there



Figure 4 Assemblage to a finite downwards-growing “tree of consequences” C of the 6 different possible initial segments of derivations from μα. ((α → α) → α) = μα. (α → (α → α)) in AK= without VAR-applications until looping occurs.

≡: τ	≡: σ
 ¸μα. ((α →x`α) → α˛)= μ¸ α. (α →x`(α → α)˛) x
(τ → τ ) → τ = σ → (σ → σ)	UNFOLDl/r

(τ → τ = σ)y
(τ = σ → σ)z
DECOMP


	
τ → τ = σ → (σ → σ)	(τ → τ ) → τ = σ → σ

(τ = σ)x
	τ = σ → σ	
(τ → τ ) → τ = σ → σ
		τ → τ = σ	 τ → τ = σ → (σ → σ)
(τ = σ)x

(τ → τ = σ)y
(τ = σ)x
(τ = σ)x
(τ = σ → σ)z



exists a contradiction χ1 = χ2 with respect to =μ such that τ = σ ▶AK= χ1 = χ2 ;
otherwise we say that τ = σ is AK=-consistent .
Theorem 3.4 (Soundness and Completeness with respect to =μ of con- sistency-checking relative to AK=). Consistency with respect to AK= is
0	0
sound and complete in relation to =μ: For all τ, σ ∈ can-μTp it holds that
τ = σ  is AK=-consistent	⇐⇒	τ =μ σ .
Sketch of Proof Both the soundness-part “⇒” and the completeness-part “⇐” are easy consequences of the fact that derivations D in AK= from assumption τ = σ with conclusion χ1 = χ2 correspond to computations of χ1, χ2 ∈ can-μTp with the property that 6 Tree(τ )|p = Tree(χ1) and Tree(σ)|p = Tree(χ2) hold for some common position p in the tree unfoldings Tree(τ ) and Tree(σ) of τ and σ. 

The basic observation
It is our next aim to indicate the intuition behind the results of this paper by describing an observation about a concrete and simple example. In this section we keep τ and σ fixed as the two strongly equivalent types in can-μTp from Figure 1. Suppose that we want to prove that the equation τ = σ is indeed consistent with respect to the system AK=. Then we are obliged to show for every derivation D in AK= from the assumption τ = σ that the conclusion of D is not a contradiction with respect to =μ. But since there are potentially infinitely many such derivations
in AK=, we might not be able to check all of them in a finite amount of time.
However, it turns out that in every derivation in AK= from τ = σ of depth ≥ 7, that does not contain applications of VAR, a loop arises, i.e. one formula occurs at two different places. What is more, the initial segments until looping occurs of all derivations from τ = σ in AK= without VAR-applications can be arranged to the downwards-growing derivation-tree C depicted in Figure 4. There single and double lines in C separate the premises and conclusions of applications of UNFOLDl/r ,

6 Here Tree(τ )|p denotes the subtree of Tree(τ ) at position p.

Figure 5 The derivation D of μα. ((α → α) → α)= μα. (α → (α → α)) in HB=
without open assumption classes.

(.. .)y
τ → τ = σ
(.. .)x
τ = σ
(.. .)x
τ = σ
(.. .)z
τ = σ → σ

(.. .)x
τ = σ
(τ → τ ) → τ = σ → σ τ = σ → σ y
τ → τ = σ → (σ → σ)
τ → τ = σ
(.. .)x
τ = σ z

τ → τ = σ → (σ → σ)
τ → τ = σ
(τ → τ ) → τ = σ → σ
τ = σ → σ

(τ → τ ) → τ = σ → (σ → σ)
μα. ((α → α) → α) = μα. (α → (α → α))
(ARR./FIX)x
FOLDl/r

 	
≡: τ
≡˛:¸σ	x



whereas branchings at dashed lines stem from the two possible ways in which con- clusions can be drawn at rules DECOMP in AK=. The markers x, y and z used for some formula occurrences in C are intended to highlight the looping in those AK=-derivations, initial segments of which constitute the branches of C.
It is now possible to use the derivation tree C in an easy inductive proof 7 for the AK=-consistency of the equation τ = σ by combining 8 the following two properties of C: Firstly, as inspection shows, C does not contain any contradictions with respect to =μ . And secondly, C is the (positive) result of loop-checking for all possible derivations without VAR-applications from τ = σ in AK=.
As an indication about the particular relationship described in this paper be- tween the systems AK= and HB=, we observe 9 the following: By reflecting the
0	0
downwards-growing derivation tree C in AK= at a horizontal line, we obtain an upwards-growing prooftree Refl(C) in the system HB= with occurrences of open assumption classes. Thereby all applications of UNFOLDl/r in C are “reflected” into applications of FOLDl/r in Refl(C) and all branchings DECOMP into applica- tions of ARROW. To transform Refl(C) into a derivation D in HB= without open assumptions, we merely need to (1) to extend Refl(C) above each of its leaves by one or two applications of FOLDl/r , (2) to transfer respective assumption markers up to the new formulas at the top of the extended prooftree, and (3) to redirect the bindings described by these markers to respective applications of ARROW be- low, thereby changing these into ARROW/FIX-applications. In this way we reach the derivation D in HB= without open assumption classes suggestively depicted in
Figure 5.
And similarly, by reflecting the derivation D from Figure 5 at a horizontal line in an analogous way, we get a downwards-growing derivation tree Refl(D) from τ = σ in AK= that—although slightly different from C—like C can be taken as the basis

7 Hereby we mean a proof by induction on the depth |D| of derivations D in AK= from τ = σ .
8 However, the possible presence of applications of VAR in AK=-derivations from the assumption τ = σ
does technically complicate a necessary proof by induction to some extent here.
9 This was noted by J.W. Klop for a similar example in different, but comparable proof systems.

of an inductive argument for showing the AK=-consistency of τ = σ .
This example suggests a very direct relationship between derivations in HB= without open assumption classes having conclusion τ˜ = σ˜ (for some τ˜, σ˜ ∈ can-μTp) and finite downwards-growing trees of consequences from the same equation τ˜ = σ˜ in AK= that are the result of loop-checking and facilitate easy inductive proofs for

the consistency of
τ˜ = σ˜ relative to AK=.

The extension e-HB= of HB=
For obtaining a precise formulation of the observation in the previous section, it will be helpful to extend the system HB= with three more coinductive fixed-point
rules.
Definition 5.1 (The extension e-HB= of the system HB=). The extension
0	0
e-HB= of the system HB= has the same formulas and axioms as HB=, allows
0	0	0
the same marked assumptions, and contains all derivation rules of HB=. Addi- tionally, e-HB= possesses the rules VAR/FIX, FOLDl/FIX and FOLDr/FIX with applications of the respective form
[ τ = σ ]x
D0
 τ0 = σ0  (R/FIX)x	(if side cond.(s) I (and C for R = VAR))
τ = σ

 τ0 = σ0 
(with some τ, σ, τ ,σ ∈ can-μTp and x ∈ Mk ), given that	R
is an

0	0	τ = σ
application of a rule R ∈ { FOLDl/r , VAR } and that the respectively necessary side
conditions described below are satisfied. At such applications the class [τ = σ]x of open marked assumptions of the form (τ = σ)x in D0 gets discharged. The side condition I requires that the assumption class τ = σ in D0 is inhabited (not empty). For applications of VAR/FIX the side condition C demands furthermore that D0 is contractive with respect to the marked open assumptions (τ = σ)x , which means that for every thread in D0 from a marked open assumption (τ = σ)x downwards at least one application of ARROW or ARROW/FIX is passed. 10
Although the system e-HB= is an extension of HB=, it is not difficult to prove
0	0
that no additional theorems become derivable in e-HB= :
Theorem 5.2 (Equivalence of the systems HB= and e-HB=). The system
0	0

e-HB= is a conservative extension of HB= and hence 11 the systems HB=
and

0	0	0
e-HB= are equivalent (i.e. they possess the same theorems). More speciﬁcally, every
derivation D in e-HB= can effectively be transformed into a derivation D' in HB=
0	0
with the same conclusion and the same (if any) open assumption classes.

10 It is easy to see that either of two following more special requirements C1 and C2 could have been used instead of the side condition C for applications of VAR/FIX with an equivalent definition as the result: C1 is the condition “D0 contains at least one application of ARROW or ARROW/FIX” and C2 demands that
“there is at least one application of a rule different from VAR in D0”.
11 Since HB= and e-HB= have the same formulas.
0	0

Consistency-Unfoldings
In a second step of the formulation of the observation in Section 4 into a precise statement, we will formalize finite downwards-growing trees of consequences in AK= as “consistency-unfoldings”, which allow to prove easily the AK=-consistency of the formulas at their respective roots. – We have to give a definition of “partial consistency-unfoldings” first.
Definition 6.1 (Partial Consistency-Unfoldings in AK=). For all recursive types τ, σ ∈ can-μTp a partial consistency-unfolding (a p.c.u.) C of the equation τ = σ in AK= is a finite downwards-growing “tree of consequences” of τ = σ in
AK= that together with the assertion “C is a p.c.u. of τ = σ in AK=” can be formed
0	0
by a finite number of applications of the following 5 generation rules. Thereby the
notion of an unbound leaf-occurrence of a marked formula (an u.l.o.m.f.) in a p.c.u. is defined in parallel: 12
For all τ, σ ∈ can-μTp and x ∈ Mk	is a p.c.u. C from τ = σ . The
occurrence of (τ = σ)x in C is the single u.l.o.m.f. in C. – Furthermore for all
τ ∈ can-μTp	is a p.c.u. of τ = τ , which contains no u.l.o.m.f.’s in C.


For all τ, σ, τ ,σ 
∈ can-μTp
is a p.c.u. C of τ = σ given

0	0

that C0 is a p.c.u. of τ0 = σ0 and that R is an application of a rule UNFOLDl/r or VAR. An u.l.o.m.f. in C is such an occurrence of a marked formula in C within its subtree C0 that corresponds to an u.l.o.m.f. in C0.


For all τ, σ, τ0, σ0 ∈ can-μTp and x ∈ Mk	is a p.c.u. C


of τ = σ given that (1) C0 is a p.c.u. of τ0 = σ0 in which the (indicated) class [τ = σ]x of all u.l.o.m.f.’s of the form (τ = σ)x is non-empty and that either (2a) R is an application of a rule UNFOLDl/r or (2b) R is an application of VAR and C0 contains at least one application of a rule different from VAR. All occurrences of (τ = σ)x within the subtree C0 of C, that correspond to u.l.o.m.f.’s in C0, are bound back in C to the occurrence of (τ = σ)x at the
root. For all marked formulas (τ˜ = σ˜)x˜ different from (τ = σ)x the unbound
leaf-occurrences of this marked formula correspond uniquely and in an obvious
way to the u.l.o.’s of (τ˜ = σ˜)x˜ within the subtree C0 of C.

12 In the following clauses the addition “in AK=” in statements like “C is a p.c.u. in AK=” is always
0	0
dropped. Auxiliary framed boxes are usemd to delimit the defined p.c.u.’s from the surrounding text. Here
and later we will allow formulas (τ = σ)	with τ, σ ∈ can -μTp and a boldface-marker m to stand either
(a) for the unmarked formula τ = σ or (b) for a marked formula (τ = σ)x with some marker x ∈ Mk , which is furthermore assumed to be denoted by m in this case.


is a p.c.u. C of the formula

τ01 → τ02 = σ01 → σ02 for all τ01, τ02, σ01, σ02 ∈ can-μTp , given that C0i is a
p.c.u. of τ0i = σ0i for each i ∈ {1, 2}. The u.l.o.m.f.’s in C correspond uniquely and in an obvious way to the u.l.o.m.f.’s in either of its immediate subtrees C01 or C02 .


(with	some x ∈ Mk and


with τ :≡ τ01 → τ02 and σ :≡ σ01 → σ02 ) is a p.c.u. C of τ01 → τ02 = σ01 → σ02 for all τ01, τ02, σ01, σ02 ∈ can-μTp given that C0i is a p.c.u. of τ0i = σ0i for each i ∈ {1, 2} and that there is at least one unbound leaf-occurrence of the marked formula (τ01 → τ02 = σ01 → σ02)x in either C01 or in C02. All occurrences of (τ = σ)x within either of the immediate subtrees C01 and C02 of C, that cor- respond to u.l.o.m.f.’s in C01 or C02, are bound back in C to the occurrence of (τ = σ)x at the root (and hence are not u.l.o.m.f.’s in C). For every marked formula (τ˜ = σ˜)x˜ different from (τ = σ)x the unbound leaf-occurrences of this marked formula correspond uniquely and in an obvious way to the u.l.o.’s of
(τ˜ = σ˜)x˜ within either of the sub-p.c.u.’s C01 or C02 of C.
The depth |C| of a p.c.u. C is defined as the depth of the underlying (derivation-) tree.

Definition 6.2 (Consistency-Unfoldings in AK=). Let τ and σ be recursive
types in canonical form. A partial consistency-unfolding C of τ = σ in AK= is
called a consistency-unfolding (a c.u.) of τ = σ in AK= if and only if C does not contain any unbound leaf-occurrences of marked formulas.

According to these definitions the derivation tree C depicted in Figure 4 can now be recognized as a p.c.u. in AK= without u.l.o.m.f.’s and hence as a consistency- unfolding of μα. ((α → α) → α)= μα. (α → (α → α)) in AK=. – The following theorem establishes the connection motivated by the example in Section 4 between
the notions of “AK=-consistency” and “consistency-unfolding in AK=”. Hereby,
0	0
the proof of “⇐” in (6.1) generalizes an argument sketched in Section 4, whereas
the proof of “⇒” follows by an analogous, in fact as good as ‘dual’, reasoning to one involved in a proof (following [3]) for the completeness of HB= with respect to
=μ.

Figure 6	Three exemplary cases of inductive clauses in the definitions of the reflection mappings D(·) and C(·) between partial consistency-unfoldings in AK=
and derivations in e-HB= (with possibly open assumption classes).
D(·)
←−→−'
C(·)


D(·)
'−→
←−'
C(·)




D(·)
←−→−'
C(·)

'−→
←−'


Theorem 6.3 For all recursive types τ, σ ∈ can-μTp it holds that:


=
τ = σ is AK0 -consistent ⇐⇒ There exists a consistency-
unfolding of τ = σ in AK= .
(6.1)

A duality between the proof systems e-HB= and AK=
0	0
In a third step of our formalization of the observation in Section 4, we give a definition of a pair of reflection mappings D(·) and C(·) between p.c.u.’s in AK=
and derivations in e-HB=.
Definition 7.1 (Reflection Mappings D(·) and C(·)).	The reflection mapping
D(·) from partial consistency-unfoldings in AK= to derivations in e-HB= (with
0	0
possibly open assumption classes) is defined by induction on the depth |C˜| of a
p.c.u. C˜ according to 5 inductive clauses, which refer to the 5 cases in the inductive
definition of p.c.u.’s in Definition 6.1. Three exemplary cases (one each referring to items (i) and (iv) and one regarding the subcase for an UNFOLDl-rule of item (iii) in Definition 6.1) have been depicted in Figure 6. The definition of the reflection mapping C(·) in the opposite direction can be carried out for all derivations D˜ in e-HB= by induction on its depth |D˜| with clauses that apart from the base case distinguish the 8 cases of different rules in e-HB=, applications of which may occur as the last rule applications in D˜ ; three of the nine clauses are depicted in Figure 6.



Figure 7 Example consisting of a consistency-unfolding C˜ in AK= and of a deriva- tion D˜ in e-HB= that are each other’s reflection via the mappings D(·) and C(·):
This means that D(C˜)= D˜ and C(D˜)= C˜ hold for C˜ and D˜ as considered below.

⎧	 τ = σ x	⊥ = ⊥
⎪	 τ →⊥ = σ →⊥ 



ARROW

D˜ :=
⎪⎪⎨


 τ = σ → ⊥	⊥ = ⊥ 
ARROW
τ →⊥ = (σ → ⊥) →⊥ 

⎪	τ →⊥ = σ
FOLDr

⎪	μα. (α → ⊥) = μβ. ((β → ⊥) → ⊥)
(FOLDl/FIX)x

⎪⎩	`	≡˛:¸τ	x	`	≡˛:¸σ	x

⎧⎪
C˜ := ⎪⎨
 μα. (α → ⊥)= μβ. ((β → ⊥) → ⊥) x  UNFOLD
τ →⊥ = σ	
UNFOLDr
τ → ⊥ = (σ → ⊥) →⊥ 
DECOMP

	τ = σ → ⊥	
	τ →⊥ = σ → ⊥	
⎪
⊥ = ⊥

⎩	 τ = σ x
⊥ = ⊥
DECOMP



The well-definedness of D(·) and C(·) as functions between the set of p.c.u.’s in
AK= and the set of derivations in e-HB= with possibly open assumption classes
0	0
can be shown by induction on the depth of the elements in the domain of the
respective mapping. – We are now able to state our main theorem.
Theorem 7.2 (A Duality between derivations in e-HB= and consistency unfoldings in AK=). There is a bijective functional relationship between deriva-

tions in e-HB=
without open assumption classes and consistency-unfoldings in

AK=
via the reflection mappings D(·) and C(·) deﬁned in Deﬁnition 7.1 in the

following sense:
For every consistency-unfolding C˜ of τ = σ in AK= (with some τ, σ ∈ can-μTp) its reflection D(C˜) is a derivation in e-HB= with conclusion τ = σ and without
open assumption classes.
For every derivation D˜ in e-HB= without open assumption classes and with
conclusion τ = σ (for some τ, σ ∈ can-μTp ) its reflection C(D˜) is a consistency-
unfolding of τ = σ in AK=.
The functions D(·) of taking the reflection of a consistency-unfolding in AK=
and C(·) of taking the reflection of a derivation in e-HB= without open assump-
tion-classes are each other’s inverse.
The very immediate kind of this bijective functional relationship and the possibility to visualize the reflection functions in a geometrical way is reason to call it a duality.
Sketch of Proof All three items of the theorem (the third one can be split into the two assertions D◦ C = id and C◦ D = id ) can be shown by quite straightfor-



—
Figure 8  A Brandt–Henglein-like axiomatization HB0  without symmetry and
transitivity rules of bisimulation equivalence between canonical term graph specifi- cations over signature Σ.
—
The axioms and possible marked assumptions in HB0 :

(REFL) ⟨ α | {α = C, .. .}⟩ = ⟨ β | {β = C, .. .}⟩	(Assm)  (g = h)x .
(if C is a constant symbol in Σ)	(with x ∈ Mk )
—
The derivation rules of HB0 :	Rules COMP and rules COMP/FIX with


⟨⟨ ⟨ α | Eg ⟩ = ⟨ β | Eh ⟩ ⟩⟩x D1
⟨ α1 | Eg ⟩ = ⟨ β1 | Eh ⟩	... 
⟨⟨ ⟨ α | Eg ⟩ = ⟨ β | Eh ⟩ ⟩⟩x Dn
⟨ αn | Eg ⟩ = ⟨ βn | Eh ⟩	(COMP/

⟨ α | {α = F (α1,... , αn)} E(0) ⟩ = ⟨ β | {β = F (β1,... , βn)} E(0) ⟩
`	=˛E¸g	x	`	=˛E¸h	x
FIX)x
(if s.c. I)



ward inductions using the inductive clauses in the definitions of D(·) and C(·). In these inductions bookkeeping must be done for respectively the set of open marked assumptions in an e-HB=-derivation or the classes of u.l.o.m.f.’s in a p.c.u. in AK=.	 
An example of a pair (D˜, C˜) consisting of a derivation D˜ in e-HB= without open

assumption classes and a consistency-unfolding C˜ in AK=
that are each other’s

reflection via the operations D(·) and C(·) is depicted in Figure 7.

A duality in proof systems for bisimulation equiva- lence on cyclic term graphs
In this section we want to sketch how our duality result about two proof systems for recursive type equality can be transferred to similar proof systems concerned with bisimulation equivalence on equational representations of cyclic term graphs.
In the aim to limit technicalities and to follow [2], we will only consider equa- tional specifications of cyclic term graphs without free variables. We are assuming a countably infinite set RVar of recursion variables to underlie the following definition (we will let small Greek letters α, β,... vary through recursion variables).
Definition 8.1 (Canonical Term Graph Specifications).  Let Σ be a first- order signature. A canonical term graph speciﬁcation (a c.t.g.s.) is an equational specification of the form ⟨ α0 | {α0 = t0,... , αn = tn}⟩, where n ∈ N , α0,... , αn pairwisely different recursion variables in RVar and for all i with 0 ≤ i ≤ n the terms ti are of the form ti ≡ F (αi1,... , αini ) for some function symbol F ∈ Σ of arity ni and variables αi1,... , αini ∈ {α0,... , αn}. We will use the letters g and h to vary through c.t.g.s.’s and denote by T GS(Σ) the set of all c.t.g.s.’s over Σ.



—
Figure 9 A ‘syntactic-matching’ proof system AK0  for testing bisimulation equiv-
alence on equations between canonical term graph specifications.
—
The derivation rules of AK0 :

= Eg
= Eh

⟨ α | {¸α = F (α1, .x. `. , αn)} E(0˛) ⟩ = ⟨ β | {¸β = F (β1, . x. `. , βn)} E(0˛) ⟩

g
⟨ αi | Eg ⟩ = ⟨ βi | Eh ⟩
h	DECOMP
(for 1≤ i ≤n)



Bisimilarity between c.t.g.s.’s is defined in [3] as follows:
Definition 8.2 (Bisimulation Equivalence ↔ on c.t.g.s.’s).	Let Σ be a signature. Let g and h be canonical term graph specifications over Σ of the form
g = ⟨ α0 | {α0 = t0,... , αn = tn}⟩ and h = ⟨ α' | {α' = t' ,... , α' ' = t' ' }⟩.
0	0	0	n	n
R is called a bisimulation between g and h if and only if
R is a relation with domain {α0,... , αn} and codomain {α' ,... , α' ' };
0	n
α0 R α' ;
if αi R α' for some i, j with 0 ≤ i ≤ n and 0 ≤ j ≤ n' , and given that

ti ≡ F (αi1,... , αin ) and t' ≡ F '(α'
,... , α' ' ) with some ni, n' ∈ N 0 ,

i	j	j1
jnj	j

then F ≡ F ' (and hence ni = n' ) and αi1 R α'
, ... , αin
R α' '
must

hold.
j	j1
i	jnj

We say that g and h are bisimilar (symbolically denoted by g ↔ h ) iff there exists a bisimulation between g and h.
—
A sound and complete axiom system HB0 for ↔ , which is very similar to the
‘normalized’ version HB= of the axiom system for =μ by Brandt and Henglein, is depicted in Figure 8. Just as for its counterpart in HB=, the rule ARROW/FIX,
—	0
applications of the rule COMP/FIX in HB0  are subjected to the side condition I:
This requires that the discharged assumption class is in fact non-empty (to dis- tinguish such applications from ones of the “plain” COMP-rule). Soundness and
—
completeness of HB0  with respect to ↔ means, that

▶HB↔
g = h	⇐⇒	g ↔ h

holds for all g, h ∈T GS(Σ) (for some signature Σ).
—
A ‘syntactic matching’ proof system AK0  for ↔ , which is similar to the system
AK=, is depicted in Figure 9, its single derivation rule being the decomposition rule
0	↔
DECOMP. AK0  is sound and complete with respect to ↔ in the sense that
—
g = h is AK0 -consistent	⇐⇒	g ↔ h
holds for g, h ∈T GS(Σ) (for some signature Σ). Hereby an equation g˜ = h˜ between
˜	↔
two c.t.g.s.’s g˜ and h is called AK0 -consistent iff no contradiction with respect to

—
— is derivable in AK0
from
g˜ = h˜ . And furthermore an equation
g˜ = h˜
be-

tween two c.t.g.s.’s g˜ = ⟨ α0 | {α0 = t0,.. .}⟩ and h˜ = ⟨ α' | {α' = t' ,.. .}⟩ is agreed
0	0	0
to be a contradiction with respect to ↔ iff it holds that t0 ≡ F (α01,... , α0n0 ) and

t' ≡ G(α'
,... , α' ' ) for some n0, n'
∈ N 0 , variables α01,... , α0n0 , α' ,... , α' '

0	01
0n0	0
01	0n0

and different symbols F, G ∈ Σ (i.e. F /≡ G ).
Now it is very straightforward to define the notion of p.c.u.’s and consistency-
—
unfoldings in AK0  of equations between c.t.g.s.’s analogously to Definitions 6.1
—
and 6.2. Furthermore reflection functions C(·) and Ð(·) between p.c.u.’s in AK0
—
and derivations in HB0  can be defined very similar to (and in fact easier than in)
Definition 7.1. We are thus lead to the following counterpart of Theorem 7.2 :
—
Theorem 8.3 (A Duality between derivations in HB0	and consistency
—
unfoldings in AK0 ). There is a bijective functional relationship between deriva-
↔	↔
tions in HB0  without open assumption classes and consistency-unfoldings in AK0
via reflection mappings C(·) and Ð(·) : This means that completely analogous state- ments to that in items (i), (ii) and (iii) of Theorem 7.2 are true.

Conclusion
In the main part of this paper we have motivated and developed a precise for- mal relationship between two different proof systems concerned with recursive type equality =μ on (a very small class of) recursive types. We showed the existence of a bijective correspondence, which can geometrically be visualized, between (1) deriva-
tions in an extension e-HB= of a normalized version HB= of the axiomatization
0	0
for =μ by Brandt and Henglein and (2) what we defined as “consistency-unfoldings”
in a proof system AK= `a la Ariola and Klop for equational testing with respect to =μ. This correspondence takes place via two reflection mappings that formalize effective transformations and that are inverse to each other.
In the last section we indicated that the described duality result is not specific to the two considered proof systems for recursive types: We sketched an analogous duality theorem for a similar pair of proof systems concerned with the notion of bisimulation equivalence on equational specifications of cyclic term graphs.
Apart from establishing a precise link between the systems HB= and AK= by
0	0
tying together closely the notions of “derivability in HB= ” and “consistency with respect to AK= ”, the main significance of our duality result Theorem 7.2 consists perhaps in the following: It can be used to understand and justify the soundness of the—at least at first sight—seemingly paradoxical reasoning formalized by the rule ARROW/FIX in HB=. In fact, our results facilitate an alternative soundness proof for the system HB= that is independent from the one given in [3] by ‘reducing’ the
soundness of HB= to the soundness of the system AK=. – A more detailed version
0	0
of this paper is available at: http://www.cs.vu.nl/~clemens/tg02 ext.pdf .

References
Amadio, R.M., Cardelli, L.: “Subtyping Recursive Types”, ACM Transactions on Programming Languages and Systems 15 (4), pp. 575–631, 1993.
Ariola, Z.M., Klop, J.W.: “Equational Term Graph Rewriting”, Fundamenta Informaticae 26 (3,4),
pp. 207–240, June 1996; extended version as: Vrije Universiteit Amsterdam Technical Report IR–391 , September 1995.

Brandt, M., Henglein, F.: “Coinductive Axiomatization of Recursive Type Equality and Subtyping”,
Fundamenta Informaticae 33 , pp. 1–30, 1998.
Grabmayer, C.: “Proof-Theoretic Interconnections between Proof Systems for Recursive Type Equality”, forthcoming as Vrije Universiteit Amsterdam Technical Report, 2002.
