Electronic Notes in Theoretical Computer Science 112 (2005) 61–76  
www.elsevier.com/locate/entcs


Abstraction and Probabilities for Hybrid Logics
Michael Huth1
Department of Computing Imperial College London London, United Kingdom

Abstract
We suggest and develop mathematical foundations for quantitative versions of hybrid logics by means of two related themes: a relational abstraction technique for hybrid computation tree logic and hybrid Kripke structures as an extension of the model-checking framework for computation tree logic with the ability to name, bind, and retrieve states; and a syntax and semantics for hybrid probabilistic computation tree logic over hybrid extensions of labelled Markov chains for which the relational abstraction techniques of hybrid Kripke structures should be transferable.
Keywords: hybrid logic, model checking, probabilistic system, abstraction.


Introduction
Hybrid logics (see e.g. http://www.hylo.net enhance basic modal and tem- poral logics with the ability to bind names to unique states in models. This extension is an important ability in applications that have to track states or other objects across space or time. If we think of a hybrid logic as a tem- poral logic enriched with syntactic clauses for the look-up and binding of names, it is natural to ask whether established model-checking methodology can be adapted to, or retained, in this hybrid setting. Apart from the work by Franceschet & Rijke [10], surprisingly little attention has been given to the extension of model checking to hybrid temporal logics. We are also not aware

1 Email: M.Huth@doc.imperial.ac.uk



1571-0661 © 2004 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2004.01.023


of any work on hybrid logics over quantitative or probabilistic models. Note that this paper only discusses propositional temporal logics.
This paper therefore provides a modest first step in this direction by de- veloping two model-checking themes for a hybrid extension of computation tree logic [4] : the sound relational abstraction of qualitative models with re-
spect to all properties of a hybrid computation tree logic; and the extension of
probabilistic systems and probabilistic computation tree logic [12] with hybrid constructs. The connection between these themes is twofold:
probabilities can be seen as a form of abstraction of qualitative informa- tion, reducing the determinism of a system 2 ; and
the techniques for relational abstraction of qualitative systems are ex- pected to be transferable to probabilistic hybrid systems in future work.

Hybrid computation tree logic
We define a hybrid version of computation tree logic [4] and its models.
Definition 2.1	(i) A Kripke structure with signature Obs is a tuple M = (Σ,R ⊆ Σ×Σ, L: Obs → P(Σ)) where Obs is a set of atomic observables.
A hybrid Kripke structure with signature Obs = AP + Nom is a tuple M = (Σ,R ⊆ Σ × Σ, L: Obs → P(Σ)), where AP and Nom are disjoint sets of atomic propositions and nominals, respectively, such that for all n ∈ Nom the set L(n) contains exactly one element.
We write (M, i) to denote that state i of M is the initial state of M.
A hybrid Kripke structure consists of a set of states Σ, a state transition relation R, and a labelling function L where, for each observable o ∈ Obs, L(o) denotes the set of states in Σ at which o holds; see Figure 1. These models are not merely Kripke structures due to the constraints on L: all nominals n ∈ Nom hold at exactly one state of the model, whereas atomic propositions
p ∈ AP may hold at no, exactly one, or more than one state. In this paper,
we present a hybrid extension of computation tree logic for specifications of properties as this prepares the ground for a hybrid extension of probabilistic computation tree logic [12], but Theorem 3.6 of this paper adapts to the full propositional mu-calculus [15].
For a signature Obs = AP + Nom, an adequate fragment of computation tree logic is
φ ::= ⊥ | o | ¬φ | φ ∧ φ | EX φ | E[φ U φ] | AF φ

2 At the same time, probabilities may be seen as concretizations of a “zero-one” non- determinism.



s3	s2

s0	s1
Fig. 1. A hybrid Kripke structure M with signature Obs = {p, q} +{n1 , n2 , n3 }. A state s is tagged with o iff s ∈ L(o). In that case, we also write (M, s) |= o.
where o ∈ Obs. The temporal patterns EX φ, E[φ1 U φ2], and AF φ express “At some next state φ,” and “On some path φ1 until φ2,” and “For all paths, eventually φ,” respectively. Every hybrid Kripke structure M is also a Kripke structure if we “forget” the constraints on the labelling function. So the satisfaction relation (M, s) |= φ is the familiar one for Kripke structures (e.g. [7]). As usual, we write φ ∨ ψ for ¬(¬φ ∧ ¬ψ), and φ → ψ for ¬(φ ∧ ¬ψ). Moving from Kripke structures to hybrid Kripke structures restricts the class of models and so changes the notions of satisfiability and validity. We discuss two standard examples from the literature.
Example 2.2  (i) For the computation tree logic formula
EX (n ∧ p) ∧ EX (n ∧ q) → EX (p ∧ q)
we may think of n, p, and q as atomic propositions that can be true at no, one, or more states. Then we can easily ﬁnd a state in a Kripke structure where this formula is false. If we think of n as being a nominal in a hybrid Kripke structure, the formula is valid. For if the premise is true, then the unique successor state s named by n (i.e. L(n) = {s} ) satisﬁes p and satisﬁes q, so there is a successor state satisfying p ∧ q.
(ii) Using nominals, one also gets a richer correspondence theory between for- mula and properties of the transition relation. The formula n → ¬EX n, interpreted over nominals and Kripke frames 3 only, expresses that the transition relation R is irreflexive; it is known that this property cannot be expressed within modal logic over Kripke frames.
The analysis of hybrid models benefits from enhancing computation tree logic with standard hybrid operators, which we present here for a branching-

3 A Kripke frame F = (Σ, R) is like a Kripke structure M = (Σ, R, L) except that we are not in control of choosing the labelling function L, so (Σ, R) |= φ iff for all L, (Σ, R, L) |= φ.


time logic CTL. Let CTL(@) be the extension of computation tree logic with the satisfaction operator @
φ ::= ⊥ | o | ¬φ | @n φ | φ ∧ φ | EX φ | E[φ U φ] | AF φ
where o ∈ Obs and n ∈ Nom. The intended meaning of @n φ is to “jump” to the unique state s' ∈ L(n) and evaluate φ in that state:
(M, s) |= @n φ	iff	(M, s') |= φ for L(n) = {s'} .
Note that (M, s) |= @n φ either holds in all states of M or in none. This operator is self-dual: @n φ and ¬@n ¬φ are semantically equivalent over hybrid Kripke structures.
In a hybrid Kripke structure, the labelling function L binds all nominals to a unique state. Viewing nominals as parameters, we can bind them to unique states for the evaluation of formulas. Consider CTL(↓) which adds to computation tree logic the operator ↓ n.φ, whose semantics requires tagging |=
with the labelling function L of the underlying hybrid Kripke structure. For computation tree logic or CTL(@), the evaluation of (M, s) |=L φ does not change L. For CTL(↓) the labelling function L changes for the evaluation of clauses of the form ↓ n.φ.
Definition 2.3 Let L[n '→ s] be the labelling function with L[n '→ s](o) =
L(o) for all o ∈ Obs with o /= n and L[n '→ s](n) = {s}. Then we set
(M, s) |=L ↓ n.φ	iff	(M, s) |=L[n'→s] φ. 
We conclude that model checks for CTL(↓) over the hybrid model M are checks (M, s) |=L φ with the initial labelling function of M , but where the evaluation of checks for sub-formulas of the form ↓ n.ψ updates L statically.
In hybrid logic, the binder ↓ n.φ allows one to express that a state s belongs to a cycle (a property not expressible in temporal logic) by checking
(M, s) |=L ↓ n.E[¬⊥ U n] .
If we think of the labelling algorithm for model checking as an abstract ma- chine, then @n φ corresponds to a lookup of “location” n with a continuation that jumps to that located state and evaluates φ at that location, whereas
↓ n.φ stores the current location at n and continues with the evaluation of φ
at the current state.
Finally, consider CTL(∃) which adds a binder for locations that seems contrary to the locality principle inherent in Kripke’s satisfaction relation |=: 
(M, s) |=L ∃n.φ	iff	for some s ∈ Σ: (M, s) |=L[n'→s'] φ. 
The lack of locality of this operator means that no purely bottom-up labelling algorithm for model checking is available. For example, the check (M, s) |=
∃n.@n E[¬⊥ U n] holds iff the model M contains some cycle, not necessarily


through s; similar problems emerge in a bottom-up evaluation of ↓ n.φ. In the sequel, we write CTL(@, ↓) etc for extensions of CTL with all listed operators.
Example 2.4 In the hybrid Kripke structure in Figure 1, the check (M, s0) |=L @n2 EX ¬p holds since (M, s3) |=L EX ¬p. The check (M, s0) |=L ↓ n2.¬EX n2 holds since (M, s0) |=L[n2'→s0] ¬EX n2, which holds as (s0, s0) /∈ R. The check (M, s0) |=L ∃n1.@n1 ¬p ∧ EX p holds as, e.g., (M, s0) |=L[n1'→s3] @n1 ¬p ∧ EX p.

Relational abstraction of hybrid models
The state-explosion problem of model checking, that the size of the state space of a model is typically exponential in the number of atomic propositions, poses a significant challenge to the application of model checking to realistic and scalable problems [7]. This is exacerbated by the fact that the addition of the operators ↓ or ∃ to computation tree logic make the model checking problem PSPACE-complete, although the addition of nominals and @ alone does not change the linear complexity of checks in the size of the model [10].
Abstraction is seen as a key technique for mitigating the effect of state- space explosions. Its standard approach [6] abstracts a model via a “safe simulation” such that formulas of linear-time temporal logic or the universal fragment of computation tree logic (“for all paths”) which are true in the abstract model are also true in the concrete one. Counter-examples of the abstract model, however, often are spurious in that they do not reflect genuine bugs in the concrete model.
Three-valued model checking [8,2] abstracts concrete models by a “mix” of safe and live simulations such that verifications (“the property holds”) and refutations (“the property does not hold”) of properties on the abstract model apply to the concrete one as well, for temporal logics with unrestricted use of
path quantifiers or negation. The price being paid here is that model checks may have a third result value “unknown” which does not reveal anything about the abstract 4 or concrete model. But we gain the ability to freely combine such path quantifiers, e.g. as in the verification of a safety property on an abstraction (obtained by the “addition” of paths) by appeal to fairness assumptions (obtained by the “removal” of paths).
In this section we work with a hybrid Kripke structure M = (Σ, R, L) with signature Obs = AP+Nom, a set of designated abstract states Σˆ, and a relation ρ ⊆ Σ × Σˆ where sρt specifies that state t abstracts s (and, equivalently, that
s is a concrete instance of t). We wish to define a hybrid model Mˆ = (Σˆ, Rˆ, Lˆ)

4 In Bruns & Godefroid’s generalized model checking [3] “unknown” reveals that some concretizations of the abstraction do, and some don’t, satisfy the property.



such that ρ is, by construction, a witness to the fact that Mˆ
abstracts M . For

that, we assume that ρ is left-total and right-total (respectively):
∀s ∈ Σ ∃t ∈ Σˆ: sρt
∀t ∈ Σˆ ∃s ∈ Σ: sρt
A practically relevant example is Σˆ being the set of classes of some partition on Σ, and sρt stating s ∈ t. Such partitions could be induced by a finite set of formulas (e.g. boolean guards from program code) on the concrete state space.
The abstract structure Mˆ should satisfy that all verifications, (Mˆ , t) |= φ, and
all refutations, (Mˆ , t) |= ¬φ, of φ in the abstract model apply in the abstracted model (M, s) as well:
∀φ ∈ CTL(@, ↓, ∃) ∀(s, t) ∈ Σ × Σˆ: sρt & (Mˆ , t) |= φ ⇒ (M, s) |= φ. 
The abstraction introduced by the relation ρ relaxes the constraints of hybrid logic and presents them in a 3-valued version.
Definition 3.1 A 3-valued hybrid Kripke structure with signature Obs = AP+Nom is a tuple M = (Σ, Ra , Rc, La , Lc) where (Σ, Ra , La ) and (Σ, Rc, Lc) are Kripke structures with signature Obs subject to the following constraints:
Ra ⊆ Rc;
for all o ∈ Obs, La (o) ⊆ Lc(o); and
for all n ∈ Nom, La (n) contains at most one element; if so La (n) =
Lc(n).
The intuition about Ra and La , already expressed for labelled transition sys- tems by Larsen & Thomsen in [17], is that they represent “must”-information (“definite,” “necessarily so” etc), whereas Rc \ Ra and Lc(o) \ La (o) denote “may”-information (“possibly,” “could be so” etc). If La (n) is non-empty, we force La (n) = Lc(n) since no element of Lc(n) \ La (n) can have a refinement different from the one for s ∈ La (n), in the sense of Definition 3.4 below.
This interpretation of “may”- and “must”-information confirms that we can view a hybrid Kripke structure M = (Σ, R, L) as the 3-valued hybrid Kripke structure (Σ, R, R, L, L). Therefore, we may define abstractions on 3- valued hybrid Kripke structure in general, allowing for an incremental abstract- and-refine methodology of 3-valued model checking as in [11].
Definition 3.2 For a 3-valued hybrid Kripke structure A = (Σ, Ra , Rc, La , Lc) with signature Obs = AP + Nom, a set Σˆ, and a left-total and right-total rela- tion ρ ⊆ Σ × Σˆ we deﬁne a tuple Aˆ = (Σˆ, Rˆa , Rˆc , Lˆa , Lˆc ):
(t, t') ∈ Rˆa iff for all sρt there is some s'ρt' with (s, s') ∈ Ra ;
(t, t') ∈ Rˆc iff for some (s, s') ∈ Rc we have sρt and s'ρt';



Fig. 2. A shape graph. Nodes are cells in a heap. The set of nominals consists of those program identifiers x, y, and z that do point to a cell in the heap. As no identifier can point to more than one cell at a time we have a hybrid heap model.

t ∈ Lˆa (o) iff for all sρt we have s ∈ La (o); and
t ∈ Lˆc (o) iff for some sρt we have s ∈ Lc(o).
Example 3.3 The 3-valued hybrid Kripke structure Aˆ of Figure 3 is obtained in this manner from the hybrid Kripke structure A in Figure 2. To see this, we set
ρ = {(s0, t0), (s1, t1), (s2, t2), (s3, t2), (s4, t2)} .

Then ρ is left-total and right-total. In
Aˆ, the two transitions (s0, s1) and

(s1, s2) are modelled as solid lines since ti is only related to si for i = 1, 2; for the same reason, their labels x and p are preserved as “must”-information in t0 and t1, respectively. There is a dashed line from t2 to t1 because (i) there is a transition (s3, s1), s3ρt2, and s1ρt1; and (ii) s2ρt2 but there is no transition out of s2 to some s with sρt1. Similarly, we account for the dashed transition from t2 back to itself. No labels at t2 are “must”-information and all but x are “may”-information. For example, for y this is so since s3 satisﬁes y but s4 doesn’t and both are related to t2 via ρ.
This example suggests that hybrid models and logics can express shape graphs [19]. Note the definitions of Lˆa and Lˆc for nominals: If A is a hybrid Kripke structure, then Lˆa (n) = {t} iff {s ∈ Σ | sρt} = La (n); and Lˆc (n) contains all those t for which soρt where s0 ∈ Lc(n). So if we want to verify φ on an abstraction and N ⊆ Nom is the set of nominals occurring under an even number of negations in φ, then sn ∈ L(n) has to be abstracted as a singleton
for each n ∈ N . This won’t corrupt the reduction of the size of the state space as N will be very small compared to Σ, e.g. 7 versus 107.

Before we can show that the abstraction
Aˆ of A in Definition 3.2 se-

cures (9) we need to present the satisfaction relation |= for a 3-valued hybrid




Fig. 3. A 3-valued hybrid Kripke structure that is an abstraction of the hybrid Kripke structure from Figure 2. Solid lines and observables o comprise Ra and La (o), respectively. Dashed lines and observables o? comprise Rc \ Ra and Lc(o) \ La (o), respectively.

Kripke structure M in two modes, “a” (asserted) and “c” (consistent), where (M, s)|=a and (M, s)|=c denote “φ must hold at state s in M ” and “φ may hold at state s in M ,” respectively. If M = (Σ, R, L) is a hybrid Kripke struc- ture, then (Σ, R, R, L, L) is a 3-valued hybrid Kripke structure such that |=a and |=c are equal and so define |= formally for M . We also define abstraction and refinement formally.
Definition 3.4 Let A = (Σ, Ra , Rc, La , Lc) and Aˆ = (Σˆ, Rˆa , Rˆc , Lˆa , Lˆc ) be two 3-valued hybrid Kripke structures with signature Obs = AP + Nom.

A relation Q ⊆ Σ × Σˆ
is a refinement iff (s, t) ∈ Q implies

for all (t, t') ∈ Rˆa , there is some (s, s') ∈ Ra with (s', t') ∈ Q;
for all (s, s') ∈ Rc, there is some (t, t') ∈ Rˆc with (s', t') ∈ Q;
for all o ∈ Obs, t ∈ Lˆa (o) implies s ∈ La (o); and
for all o ∈ Obs, s ∈ Lc(o) implies t ∈ Lˆc (o).
We say that (Aˆ, t) abstracts (is refined by) (A, s) iff there is a reﬁnement
Q with (s, t) ∈ Q.
For s ∈ Σ and n ∈ Nom, the labelling L[n'→a s] is the pair of labelling functions (L[n'→a s]a , L[n'→a s]c), which equals (La , Lc) except at n, where L[n'→a s]a (n) = L[n'→a s]c(n) = {s}; the labelling L[n'→cs] is the pair of labelling functions (L[n'→cs]a , L[n'→cs]c), which equals (La , Lc) except at n, where L[n'→cs]c(n) = Lc(n) ∪ {s} and L[n'→a s]a (n) = {}.

We deﬁne |=a
and |=c
for 3-valued hybrid Kripke structures, where m ∈

{a, c}, ¬a = c, and ¬c = a:

(A, s)|=/
m ⊥;

(A, s) |=m o iff s ∈ Lm (o);

(A, s) |=m ¬φ iff (A, s)|=/
¬m φ;

(A, s) |=m @n φ iff there is some s' ∈ Lm (n) with (A, s') |=m φ;
L	L


(A, s) |=m ↓ n.φ iff (A, s) |=m	m	φ;
L	L[n'→ s]
(A, s) |=m ∃n.φ iff there is some s' with (A, s) |=m	m '  φ;
L	L[n'→ s ]
(A, s) |=m φ1 ∧ φ2 iff ((A, s) |=m φ1 and (A, s) |=m φ2);
L	L	L
(A, s) |=m EX φ iff there is some (s, s') ∈ Rm such that (A, s') |=m φ;
L	L
(A, s) |=m E[φ1 U φ2] iff there is some 0 ≤ j with s = s0 such that for all
k ∈ {0, 1,... ,j − 1} we have (sk, sk+1) ∈ Rm and (A, sk) |=m φ1, and
(A, sj) |=m φ2; and
(A, s) |=m AF φ iff there is no inﬁnite sequence (si)i≥0 with s = s0 such
that, for all k ≥ 0, (sk, sk+1) ∈ R¬m and (A, sk)|=/ m φ.
Remark 3.5 The ability to jump to arbitrary states in which to continue the evaluation of model checks means that (9) cannot be secured by just showing that the abstract state t indeed abstracts the concrete one s. Sound abstraction becomes a global property in that we need left-total and right-total reﬁnement relations, which are thankfully closed under composition and subsume all state space partitions.
The effect of Lˆ[n'→a t] in Aˆ is a “must”-bind of n to t; and the effect of L[n'→cs] is a “may”-bind of n to s. Both actions constrain the un-abstracted “may-” and “must-”bindings of n in A conservatively.
Theorem 3.6 (i) Let A = (Σ, Ra , Rc, La , Lc) and Aˆ = (Σˆ, Rˆa , Rˆc , Lˆa , Lˆc )
be two 3-valued hybrid Kripke structures with signature Obs = AP + Nom

and let Q ⊆ Σ × Σˆ
be a left-total and right-total reﬁnement such that

(s, t) ∈ Q. For all formulas φ ∈ CTL(@, ↓, ∃) we have that (Aˆ, t) |=a φ
L
implies (A, s) |=a φ; and (A, s) |=c φ implies (Aˆ, t) |=c φ.
L	L	Lˆ
(ii) Let A be a 3-valued hybrid Kripke structure and Aˆ deﬁned from A as in Deﬁnition 3.2 for a left-total and right-total ρ. Then Aˆ is a 3-valued hy- brid Kripke structure and for all sρt, (Aˆ, t) abstracts (A, s). In particular, item (1) applies.

Proof. Item (2) follows from item (1) by construction. We prove item (1) by structural induction on φ. We focus on the clauses o, @n φ, ↓ n.φ, and ∃n.φ as the proofs for the remaining clauses are standard (see e.g. [8,2,14]).
Consider o.

Let (Aˆ, t) |=a
L
o. Then t ∈ Lˆa (o). From (s, t) ∈ Q we infer s ∈ La (o)

which implies (A, s) |=a o.

· Let (A, s) |=c
o. Then s ∈ Lc(o). From (s, t) ∈ Q we infer t ∈ Lˆc (o)

which implies (Aˆ, t) |=c o.
L
Consider @n φ.
Let (Aˆ, t) |=a @n φ. Then there is some t' with t' ∈ Lˆa (n) and (Aˆ, t') |=a φ.
Lˆ	Lˆ


Since Q is right-total, there is some s' with (s', t') ∈ Q and so t' ∈ Lˆa (n)

implies s' ∈ La (n). By induction, (s', t') ∈ Q and (Aˆ, t') |=a
L
φ imply

(A, s') |=a φ. But then s' ∈ La (n) implies (A, s) |=a @n φ.
L	L
Let (A, s) |=c @n φ. Then there is some s' with s' ∈ Lc(n) and (A, s') |=c
φ. Since Q is left-total, there is some t' with (s', t') ∈ Q and so s' ∈ Lc(n)

implies t' ∈
Lˆc (n). By induction, (s', t') ∈ Q and (A, s') |=c
φ imply

(Aˆ, t') |=c
L
φ. But then t' ∈ Lˆc (n) implies (Aˆ, t) |=c
L
@n φ.

Consider ↓ n.φ.
Let (Aˆ, t) |=a ↓ n.φ. Then (Aˆ, t) |=a
φ. If we replace Lˆ with Lˆ[n'→a t]

Lˆ	Lˆ[n'→a t]
and L with L[n'→a s] in Aˆ and A (respectively), then the assumptions

of item (1) still hold. By induction, (Aˆ, t) |=a
L[n'→ t]
φ therefore implies

(A, s) |=a	a	φ and so (A, s) |=a ↓ n.φ.
L[n'→ s]	L

Let (A, s) |=c ↓ n.φ. Then (A, s) |=c
c  φ. If we replace Lˆ with Lˆ[n'→ct]

L
and L with L[n'→cs] in
L[n'→ s]
Aˆ and A (respectively), then the assumptions

of item (1) still hold. By induction, (A, s) |=c
c	φ therefore implies

(Aˆ, t) |=c
L[n'→ t]
Consider ∃n.φ.
φ and so (Aˆ, t) |=c
L
↓ n.φ.
L[n'→ s]

· Let (Aˆ, t) |=a
L
∃n.φ. Then there is some t' with (Aˆ, t) |=a
L[n'→ t ]
φ. Since

Q is right-total, there is some s' with (s', t') ∈ Q. If we replace Lˆ with
Lˆ[n'→a t'] and L with L[n'→a s'] in Aˆ and A (respectively), then the as-

sumptions of item (1) still hold. By induction, (Aˆ, t) |=a
L[n'→ t ]
φ therefore

implies (A, s) |=a	a '  φ and so (A, s) |=a ∃n.φ.
L[n'→ s ]	L
· Let (A, s) |=c ∃n.φ. Then there is some s' with (A, s) |=c	c ' φ. Since Q
L	L[n'→ s ]
is left-total, there is some t' with (s', t') ∈ Q. If we replace Lˆ with Lˆ[n'→ct'] and L with L[n'→cs'] in Aˆ and A (respectively), then the assumptions of

item (1) still hold.  By induction, (A, s) |=c
c '  φ therefore implies

(Aˆ, t) |=c
L[n'→ t ]
φ and so (Aˆ, t) |=c
∃n.φ.
L[n'→ s ]

Example 3.7 Let us re-consider the hybrid Kripke structure A of Figure 2 and its abstraction Aˆ of Figure 3.
We have (Aˆ, t2) |=a @x E[x ∨ p U ¬x] since we have (Aˆ, t0) |=a E[x ∨ p U ¬x],
Lˆ	Lˆ
where the latter is witnessed by the Rˆa -path t0 → t1 → t2. Since s4ρt2, Theorem 3.6 entails that (A, s4) |=L @x E[x ∨ p U ¬x].
Finally, we have (Aˆ, t2) |=c E[y U ¬p] since t2 ∈ Lˆc (p) \ Lˆa (p), but don’t

have (A, s4) |=c
E[y U ¬p] despite the fact that s4ρt2. The direction of

transfer of model-checking results is therefore mode-dependent as stated in Theorem 3.6.

Hybrid labelled Markov chains
Hybrid logics enrich temporal logics and their models with the ability to name and therefore track states in a model. For Kripke structures and computation tree logic, this enrichment requires a multiplicity constraint on the labelling function (which had to be relaxed in abstraction-based model checking) and the addition of standard hybrid operators to computation tree logic. In moving from qualitative hybrid logics to quantitative and probabilistic ones, several questions emerge:
How do or should hybrid operators generalize to a quantitative or prob- abilistic setting?
Is the use of model-checking back-ends and their data-structures (e.g. MTBBDs [5,1] and Kronecker Representation [18,9]) affected by the ad- dition of hybrid operators, and if so how?
Do relational abstraction techniques for qualitative hybrid models trans- fer smoothly to the quantitative or probabilistic setting?
What is the complexity for model checking hybrid extensions of labelled Markov chains over hybrid extensions of probabilistic computation tree logic? It is worse than the one for the non-hybrid setting?
In this paper, we focus on the first question and only in the setting of finite- state labelled Markov chains and probabilistic computation tree logic without “bounded Until,” e.g. as used in [1].
Definition 4.1 (i) A (finite-state) labelled Markov chain with signature Obs is a tuple M = (Σ, R:Σ × Σ → [0, 1], L: Obs → P(Σ)) where Σ is ﬁnite; Obs is a set of atomic observables; for all s ∈ Σ,  s'∈Σ R(s, s') = 1; and
Σ and L have the same interpretation as for Kripke structures.
(ii) A hybrid (ﬁnite-state) labelled Markov chain with signature Obs = AP + Nom is a tuple M = (Σ, R:Σ×Σ → [0, 1], L: (AP → P(Σ)) +(Nom ×Σ → [0, 1])) where (Σ, R, L|AP) is a ﬁnite-state labelled Markov chain 5 ; AP and Nom are disjoint sets of atomic propositions and nominals, respectively; and for all n ∈ Nom,  s∈Σ L(n, s) = 1.
In a hybrid labelled Markov chain, the labelling function L has a sum type: as in the case of labelled Markov chains, L(a) denotes those states of Σ in which atomic observable a ∈ AP holds; whereas λs.L(n, s) is the probability distribution of the nominal n in the state space Σ; see Figure 4 for a version of
the hybrid Kripke structure from Figure 1 as a hybrid labelled Markov chain.

5 We write L|AP to denote the restriction of L to type AP → P(Σ).



s3
n2 = 0.93
s2
n3 = 0.13
n1 = 0.55





n1 = 0.45
n3 = 0.87




s0	s1
n2 = 0.07

Fig. 4. A hybrid labelled Markov chain with signature Obs = {p, q} + {n1 , n2 , n3 }. Probabili- ties of nominals are depicted next to the respective states. For example, L(n3 , s0) = 0.87 and L(n3 , s3)= 0.


We treat nominals probabilistically as the function λs.L(n, s) is a probabil- ity distribution over the set of states for each nominal n ∈ Nom. Such a type is of interest as it models probabilistic uncertainty of an observable agent’s whereabouts. But it also allows us to retain the original intent of hybrid log- ics by choosing λs.L(n, s) to be a point distribution δs' which assigns 1 to s' and 0 to all other states. Alternatively, one could choose other quantitative
measures (risks, costs etc) so that  s∈Σ L(n, s) is no longer 1. The unifying point of such choices is that information about nominals is often uncertain or
incomplete.
Now we discuss a suitable hybrid probabilistic temporal logic. The probabilis- tic computation tree logic (without “bounded Until”)
φ ::= ⊥ | a | ¬φ | φ ∧ φ | [Xφ]±p | [φ U φ]±p
is due to Hansson & Jonsson [12] where a ∈ AP, p ∈ [0, 1], and ± ∈ {≥, >}. Below we extend the familiar semantics of probabilistic computation tree logic over labelled Markov chains to our hybrid setting. This interpretation suggests
probabilistic variants of the hybrid operators @n φ, ↓ n.φ, and ∃n.φ :
Should the check (M, s) |=L @±p.φ hold if Σ{L(n, s') | (M, s') |=L φ} ± 
p? Such an interpretation is similar to the one for [Xφ]±p, expect that the state “transition” probabilities are governed by the probability distribution
λs.L(n, s) instead of the probability distribution λs'.R(s, s'), and is there- fore computable with standard techniques from symbolic model checking of
Markov chains, e.g. as implemented in the PRISM model checker [16]. Yet this interpretation is at odds with the role of conditional probabilities: Since
L(n, s') is the probability of n’s being at state s', we wish to sum up all such weights for which the continuation check is true at s' under the assumption


that “nominal n resides at state s',” so we have to set

(M, s) |=L @±p.φ	iff	Σ{L(n, s') | (M, s') |=L[n'→δ
] φ}± p. 

n	s'
Unlike in the qualitative case, checks of @±pφ statically change the labelling function for the check of sub-formulas. Although this requires adaptations of
existing algorithms for probabilistic model checking, the good news is that the continuation resolves the labelling information for n to a qualitative observable as found in a labelled Markov chain.
The qualitative check (M, s) |=L ↓ n.φ holds iff (M, s) |=L[n'→δs] φ holds. Given that, we may as well assign probability distributions other than point
distributions to the continuation of a probabilistic check:
(M, s) |=L ↓(n, δ).φ	iff	(M, s) |=L[n'→δ] φ. 
The qualitative check (M, s) |=L ∃n.φ holds iff for some s' ∈ Σ the check (M, s) |=L[n'→δ ] φ holds. If we set ∆' = {δs' | s' ∈ Σ}, this is an instance of a general probabilistic check
(M, s) |=L ∃(n, ∆').φ	iff	for some δ ∈ ∆': (M, s) |=L[n'→δ] φ. 
For this operator ∃(n, ∆') we may have to restrict the range of ∆' in order to make it computable or even feasibly so. We judge such extensions of proba-
bilistic computation tree logic to be of potentially great use. For example, the idea of using probability distributions to model the presence of agents suggests applications in security.
This generality of probabilistic hybrid operators may not honor the original intent of hybrid temporal patterns. For example,
(M, s) |=L ↓(n, δ).[¬⊥ U (n ∧ ψ)]≥.9999
checks whether the node named by n is on a probabilistic cycle (on which ψ is true at least once) with probability at least .9999 only if the probability distribution δ does not smear the location of such a node, i.e. only if δ is of the form δs' for some s' ∈ Σ. Using point distributions, probabilistic hybrid logics
are therefore able to express a kind of probabilistic recurrence of probabilistic
trace sets.

Hybrid Probabilistic Computation Tree Logic
We summarize our discussion into a proposal for a hybrid probabilistic com- putation tree logic:
Definition 5.1 Let Obs = AP+Nom be a signature for hybrid labelled Markov chains and ∆ a class of discrete probability distributions subsuming all point distributions. Then hybrid probabilistic computation tree logic, without “bounded Until,” over Obs and ∆ is deﬁned by


φ ::= ⊥ | a | ¬φ | φ ∧ φ | [Xφ]±p | [φ U φ]±p n±p | @±p.φ | ↓(n, δ).φ | ∃(n, ∆').φ
where a ∈ AP, n ∈ Nom, p ∈ [0, 1], ± ∈ {≥, >}, δ ∈ ∆, and ∆' ⊆ ∆.
The qualitative operators ↓ n.φ and ∃n.φ are derived in that (M, s) |=L ↓ n.φ
is interpreted as (M, s) |=L ↓(n, δs).φ; and (M, s) |=L ∃n.φ as (M, s) |=L
∃(n, {δs | s ∈ Σ}).φ.
Let M = (Σ, R, L) be a hybrid finite-state labelled Markov chain with signature Obs. We define (M, s) |=L φ for all φ of hybrid probabilistic compu- tation tree logic. Given s ∈ Σ, let Path(s) be the set of infinite paths in M
beginning in s, where transitions s → s' occur iff R(s, s') > 0. Given φ, φ1, and φ2 of hybrid probabilistic computation tree logic and some π ∈ Path(s)
we define
π |=L X φ iff (M, s') |=L φ, where π = s → s' → .. .;
π |=L φ1 U φ2 iff there is some k ≥ 0 such that the first k − 1 states si of π
satisfy (M, si) |=L φ1 and the kth state sk satisfies (M, sk) |=L φ2.
So we define |=L over certain path formulas and all state formulas of hybrid probabilistic computation tree logic by mutual induction, as done for prob- abilistic computation tree logic [12]. The semantics for ⊥, a, negation, and conjunction is defined as for Kripke structures. The semantics for the path formulas and hybrid operators is
(M, s) |=L [Xφ]±p iff the probability of the set of those π ∈ Path(s) with
π |=L X φ is ± p;
(M, s) |=L [φ1 U φ2]±p iff the probability of the set of those π ∈ Path(s) with
π |=L φ1 U φ2 is ± p;
(M, s) |=L n±p iff L(n, s) ± p;
(M, s) |=L @±p.φ iff Σ{L(n, s') | (M, s') |=L[n'→δ ] φ}± p;
n	s'
(M, s) |=L ↓(n, δ).φ iff (M, s) |=L[n'→δ] φ; and
(M, s) |=L ∃(n, ∆').φ iff for some δ ∈ ∆', we have (M, s) |=L[n'→δ] φ.
Note that |=L is well defined for all hybrid finite-state labelled Markov chains since all path formulas over predicates (the sets of states for which a partic- ular formula of hybrid probabilistic computation tree logic is true) give rise to measurable path sets [20] through the standard construction of measures on sequence spaces. The semantics for path formulas given above is as for probabilistic computation tree logic.
Example 5.2 To illustrate our semantics of hybrid probabilistic computation tree logic, we check (M, s3) |=L @>0.1[¬⊥ U n3]≥0.01. For that, we need to de-


termine for which s with L(n3, s) > 0 we have (M, s) |=L[s'→δs] [¬⊥ U n3]≥0.01; and then sum up all those L(n3, s) and check whether that sum is > 0.1. Only s0 and s2 are relevant here.
At state s0 in M with labelling function L[n3 '→ δs0 ] the probability that s0
is on a cycle is 0.01 · 0.64 · 0.5 · (Σ∞ (0.64 · 0.5)i) = 0.00948529 ... which is
not ≥ 0.01 and so (M, s0) |=L[s'→δs ] [¬⊥ U n3]≥0.01 does not hold, meaning that L(s0, n3) = 0.87 does not contribute to that sum.
At state s2 in M with labelling function L[n3 '→ δs2 ] the probability that s2 is on a cycle is 0.64 · 0.5+ 0.64 · 0.5 · 0.01 = 0.3232 which is ≥ 0.01 and so (M, s2) |=L[s'→δs ] [¬⊥ U n3]≥0.01 holds, meaning that L(s2, n3) = 0.13 is the only contributor to that sum.
Since 0.13 > 0.1, we conclude that (M, s3) |=L @>0.1[¬⊥ U n3]≥0.01 holds.
Conclusions
We presented propositional hybrid logics as established enhancements of propo- sitional temporal logics with the ability to name and re-bind specific states. We then provided a sound relational abstraction technique for hybrid Kripke structures and a hybrid version of computation tree logic. We further moti- vated and discussed a definition of hybrid labelled Markov chains and a syntax and semantics of probabilistic computation tree logic in this hybrid setting. Our abstraction techniques for hybrid Kripke structures should be transfer-
able to hybrid labelled Markov chains and quantitative hybrid models, perhaps
along the lines of [13].

Acknowledgments
Our exposition of hybrid logics was heavily inspired by the introductory article at http://www.hylo.net/ and comments made by Chris Hankin, Sebastian Nanz, and Herbert Wiklicky. We thank the anonymous referees, Joost-Pieter Katoen, and Prakash Panangaden for constructive comments that helped shape the final version of this paper.

References
C. Baier, E. M. Clarke, V. Hartonas-Garmhausen, M. Kwiatkowska, and M. Ryan. Symbolic Model Checking for Probabilistic Processes. In Proc. ICALP’97, volume 1256 of Lecture Notes in Computer Science, pages 430–440, 1997.
G. Bruns and P. Godefroid. Model Checking Partial State Spaces with 3-Valued Temporal Logics. In Proc. of the 11th Conference on Computer Aided Veriﬁcation, volume 1633 of Lecture Notes in Computer Science, pages 274–287. Springer Verlag, July 1999.


G. Bruns and P. Godefroid. Generalized Model Checking: Reasoning about Partial State Spaces. In Proc. of CONCUR’2000 (11th International Conference on Concurrency Theory), volume 1877 of Lecture Notes in Computer Science, pages 168–182. Springer Verlag, August 2000.
E. M. Clarke and E. A. Emerson. Synthesis of synchronization skeletons for branching time temporal logic. In D. Kozen, editor, Logic of Programs Workshop, number 131 in LNCS. Springer Verlag, 1981.
E. M. Clarke, M. Fujita, and X. Zhao. Representations of discrete functions, chapter Multi- terminal binary decision diagrams and hybrid decision diagrams, pages 93–108. Kluwer academic publishers, 1996.
E. M. Clarke, O. Grumberg, and D. E. Long. Model checking and abstraction. ACM Transactions on Programming Languages and Systems, 16(5):1512–1542, 1994.
E. M. Clarke, O. Grumberg, and D. A. Peled. Model Checking. The MIT Press, January 2000.
D. Dams. Abstract interpretation and partition reﬁnement for model checking. PhD thesis, Technische Universiteit Eindhoven, The Netherlands, 1996.
L. de Alfaro, M. Kwiatkowska, G. Norman, D. Parker, and R. Segala. Symbolic Model Checking of Probablistic Processes using MTBBDs and the Kronecker Representation. In Tools and Algorithms for the Construction and Analysis of Systems: 6th International Conference, TACAS 2000, volume 1785 of Lecture Notes in Computer Science, pages 395–410, Berlin, Germany, March/April 2000. Springer Verlag.
M. Franceschet and M. de Rijke. Model Checking for Hybrid Logics. In Proc. of the Workshop on Methods for Modalities, 2003.
P. Godefroid and R. Jagadeesan. Automatic Abstraction Using Generalized Model Checking. In E. Brinksma and K. G. Larsen, editors, Proc. 14th Int’l Conference on Computer Aided Veriﬁcation (CAV 2002), volume 2404 of Lecture Notes in Computer Science, pages 137–150, Copenhagen, Denmark, July 2002. Springer Verlag.
H. A. Hansson and B. Jonsson. A logic for reasoning about time and reliability. Formal Aspects of Computing, 6(5):512–535, 1994.
M. Huth. Possibilistic and Probabilistic Abstraction-Based Model Checking. In H. Hermanns and R. Segala, editors, Process Algebra and Probabilistic Methods, Performance Modeling and Veriﬁcation, Second Joint International Workshop PAPM-PROBMIV 2002, volume 2399 of Lecture Notes in Computer Science, pages 115–134, Copenhagen, Denmark, July 25-26 2002. Springer.
M. Huth, R. Jagadeesan, and D. A. Schmidt. Modal transition systems: a foundation for three-valued program analysis. In Sands D., editor, Proc. of the European Symposium on Programming (ESOP’2001), pages 155–169. Springer Verlag, April 2001.
D. Kozen. Results on the propositional mu-calculus. Theoretical Computer Science, 27:333– 354, 1983.
M. Kwiatkowska. Model Checking for Probability and Time: From Theory to Practice. Invited paper in Proc. LICS’03, pages 351-360, IEEE Computer Society Press, 2003.
K. G. Larsen and B. Thomsen. A Modal Process Logic. In Proc. of LICS’88, pages 203–210. IEEE Computer Society Press, 1988.
B. Plateau. On the Stochastic Structure of Parallelism and Synchronization Models for Distributed Algorithms. In Proc. of the 1985 ACM SIGMETRICS Conference on Measurement and Modeling of Computer Systems, pages 147–154, Austin, Texas, May 1985. ACM Press.
M. Sagiv, T. Reps, and R. Wilhelm. Parametric Shape Analysis via 3-Valued Logic. In Proc. of the 26th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, pages 105–118, January 20-22, San Antonio, Texas 1999.
M. Vardi. Automatic verification of probabilistic concurrent finite-state programs. In Proc. 26th IEEE Symp. on Foundations of Computer Science, pages 327–338, Portland, Oregon, October 1985.
