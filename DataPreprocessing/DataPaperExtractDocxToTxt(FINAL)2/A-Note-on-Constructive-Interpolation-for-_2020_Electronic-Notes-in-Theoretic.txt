Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 354 (2020) 3–16
www.elsevier.com/locate/entcs


A Note on Constructive Interpolation for the Multi-Modal Logic Km
Everardo Bárcenasa,1 José-de-Jesús Lavalle-Martínezb,2 Guillermo Molero-Castilloa,3 Alejandro Velázquez-Menaa,4
a Universidad Nacional Autónoma de México Mexico City, Mexico
b Benemérita Universidad Autónoma de Puebla Puebla, Mexico

Abstract
The Craig Interpolation Theorem is a well-known property in the mathematical logic curricula, with many domain applications, such as in the modularization of formal specifications and ontologies. This property states the following: given an implication, say formula φ implies another formula ψ, then there is a formula β, called the interpolant, in the common language of φ and ψ, such that φ also implies β, as well as β implies ψ. Although it is already known that the propositional multi-modal logic Km enjoys Craig interpolation, we are not aware of method providing an explicit construction of interpolants. We describe in this paper a constructive proof of the Craig interpolation property on the multi-modal logic Km. Interpolants can be explicitly computed from the proof. Furthermore, we also describe an upper bound for the computation of interpolants. The proof is based on the application of Maehara technique on a tree-hypersequent calculus. As a corollary of interpolation, we also show Beth definability and Robinson joint consistency.
Keywords: Craig Interpolation, Multi-modal logic Km, Tree-Hypersequents, Beth Definability, Robinson Joint Consistency.


Introduction
Craig interpolation, Beth definability and Robinson joint consistency, are well-known properties on the relation of syntax and semantics of logical languages. In this paper, we study all these logical notions in the context of the propositional multi-modal logic Km.
The interpolation property was first proved for classical first-order logic by Craig [4].
Considering a formula φ implies another formula ψ, the interpolation property con-

1 Email: ebarcenas@unam.mx
2 Email: jlavalle@cs.buap.mx
3 Email: gmoleroca@fi-b.unam.mx
4 Email: mena@fi-b.unam.mx

https://doi.org/10.1016/j.entcs.2020.10.002
1571-0661/© 2020 The Author(s). Published by Elsevier B.V.
This is an open access article under the CC BY license (http://creativecommons.org/licenses/by/4.0/).

sists in the existence of a formula β, called the interpolant, in the common language of φ and β, which is assumed to be non-empty, such that φ implies β, and β implies ψ. Applications of interpolation in computer science have been recently studied for formal verification [22], computational complexity [3], and knowledge represen- tation [15,28], among others. Although it is already known that the propositional multi-modal logic Km enjoys Craig interpolation, we are not aware of method pro- viding an explicit construction of interpolants, which are of crucial importance in many computer science applications [22,15,28]. In this paper, we give a constructive proof the Craig interpolation theorem for the multi-modal logic Km. The proof implies a straightforward algorithm to compute interpolants. Furthermore, we also discuss the complexity of this computation.
An implicit definition consists of a pair of formulas φ(p1) and φ(p2) implies p1 and p2 are logically equivalent, where p1 and p2 are propositional variables occurring in φ, resp. An explicit definition consists in that formula φ(p) implies p is logically equivalent to another formula ψ composed by the vocabulary in φ (not considering p). In most common logical languages, it is straightforward that explicit definitions imply implicit definitions. However, the converse does not always hold. This con- verse implication is known as the Beth definability property. This property was first observed by Beth for classical first-order logic in [1]. Craig interpolation and Beth definability are sometimes equivalent, depends on the logical language. We describe in this paper how to construct explicit definitions from implicit ones with the help of interpolants.
Consistency is also a common notion in logical languages. Given two consistent logical theories (axiom systems, knowledge bases, etc.), with respect to a common vocabulary, it is natural to wonder whether or not the union these theories is also consistent. If in a logical language this union of theories is consistent, we say the lan- guage has the Robinson joint consistency property [26]. We also show this property is a consequence of interpolation in the context of Km.

Related work
In [5], D’Agostino reports an extensive survey on interpolation for non-classical logics, including modal logics.
Early studies about the interpolation property in modal logics are reported in [8,18]. In [8], Gabbay proved interpolation for several mono-modal logics includ- ing K and S4. Maksimova in [18] identifies a close connection of amalgamability
in topological boolean algebras and modal logics containing S4, and proved that only a finite number of modal logics containing S4 enjoys interpolation. Maksimova
later proved interpolation of all normal modal logics via amalgamation in [19]. This result was extended for multi-modal logics in [16]. In [21], Marx proved interpo- lation for several modal logics with a technique based on bisimulation. This work includes interpolation proofs for K, fibered modal logics and the multi-modal logics of knowledge and belief. In all the above works, interpolation is proved by semantics or algebraic methods. Although these methods are quite general and can be applied to several logics, they not provide an explicit construction of interpolants. In the

current paper, we provide a syntactic proof of interpolation for the multi-modal logic
Km. This proof includes an explicit construction of interpolants.
Syntactic interpolation proofs for modal logics KB, KDB, K5 and KD5 are described in [24]. In this work, interpolation is proved by means of a cut-free com- plete sequent-like tableau deduction system. Constructive interpolation for modal logics K and T is given in [2]. More precisely, a stronger form of interpolation, called uniform interpolation, is proved in this work. In uniform interpolation, in- terpolants are composed by the common language of formulas in the implication, but restricted by a choice of propositional variables. The closest work to our paper is [7]. In this work, constructive interpolation is proved for the entire modal cube, composed by the logics resulting from any combination of K, D, T , B, 5 and 4. The proof technique used in this work is based on nested sequents. In our paper, we obtain a constructive interpolation proof for the multi-modal logic Km, using the Maehara technique on a cut-free complete tree-hypersequent calculus.
In [9], it is widely reported on the relation of definability, interpolation and consistency in modal logics. In particular, several definability results for mono-modal and intuitionistic logics are described. These results were achieved by algebraic methods, which, according to the authors of [9], can also be applied to multi-modal logics. We show in this paper, as a direct consequence of interpolation, Km also has the Beth definability property. This proof is also constructive, given that we can compute interpolants in Km, we can then also construct explicit definitions from implicit ones. In the current work, we also indirectly test consistency with the help of interpolation, by constructing a contradiction composed by the interpolant of the inconsistent union of two theories. Another relatively recent study on definability in modal-like logics can be found in [28]. In this work, Beth definability is studied in the context of description logics. Applications in computer science, such as query rewriting, are also discussed. Definability is proved by means of a tableau method, which allows to compute explicit definitions. Furthermore, the computational cost of this method is also described. We also describe an upper bound for the computation of interpolants in Km.

Outline
We first introduce the multi-modal logic Km in Section 2. In Section 3, we describe a complete cut-free tree-hypersequent calculus for Km. Then, in Section 4, by means of Maehara technique, we extract interpolants from tree-hypersequent proofs of Km implications. A 2EXPTIME upper bound on the construction of interpolants is also provided in this Section. In Section 5, as a consequence of interpolation, we also prove Beth definability and Robinson joint consistency. Finally, in Section 6, we give a summary of the article and briefly argue further research perspectives.

Multi-modal logic
In this Section, we introduce syntax and semantics of multi-modal logic Km, then we present a corresponding Hilbert style proof system.

We assume a basic modal language: a non-empty set of propositions PROP; and a non-empty finite set of modalities MOD.
Definition 2.1 [Syntax] The set of formulas is inductively defined by the following grammar.
φ := p | ¬φ | φ ∧ φ | 2mφ
where p is a proposition and m is a modality.
Notation:
T := p ∨ ¬p	⊥ := ¬T	φ ∨ ψ := ¬(¬φ ∧ ¬ψ)
φ → ψ := ¬φ ∨ ψ	3mφ := ¬2m¬φ
A Kripke structure is a tuple M = (W, R, V ) where:
W is a non-empty set called domain;
R is a finite set of binary relations Rm : W × W , for every modality m; and
V : PROP '→ 2W is valuation function mapping propositions to domain subsets.
Definition 2.2 [Semantics] Given a Kripke structure M = (W, R, V ), formulas are interpreted as follows:
[[p]]n = {w ∈ V (p)}
[[¬φ]]n =W \ [[φ]]n
[[φ ∧ ψ]]n = [[φ]]n ∩ [[ψ]]n
[[2mφ]]n = w | ∀wj ∈ W : if (w, wj) ∈ Rm,
then wj ∈ [[φ]]n,

We may also write M,w |= φ instead of w ∈ [[φ]]n, M |= φ when for every w in M , we have that M,w |= φ, in which case we say M is a model of φ. If any Kripke structure is a model of φ, we write |= φ.
Definition 2.3 [Hilbert derivation system] We define the derivation system H by the following schemas and rules, for each m ∈ MOD:
A1 φ → (ψ → φ)
A2 (φ → (ψ → β)) → ((φ → ψ) → (φ → β))
A3 (¬φ → ¬ψ) → (ψ → φ)
A4 2m(φ → ψ) → (2mφ → 2mψ)
R1 φ → ψ	φ ψ
R2	φ
2mφ
We say a formula φn is derivable from H, written ▶H φn, if there is a sequence
φ1, φ2,..., φn, such that for each i ∈ {1,..., n}:

φi is either an instance, up to substitution, of a schema in H, or
there is (are) j < i (and k < i) such that φi and φj (and φk) are instances of the conclusion and premises, resp, of a rule in H.
Consider for instance the following derivation of 2m(φ ∧ ψ) → 2mφ:
(φ ∧ ψ) → φ, which by notation is an instance of A1, ¬φ ∨ ψ ∨ φ;
2m((φ ∧ ψ) → φ), from 1 by R2;
2m((φ ∧ ψ) → φ) → (2m(φ ∧ ψ) → 2mφ), from A4; and
2m(φ ∧ ψ) → 2mφ, from 2 and 3 by R1.
We conclude this Section recalling the Hilbert derivation system for Km is cor- rect.
Theorem 2.4 (Correctness [10]) For any formula φ, ▶H φ, if and only if, |= φ.

Tree-hypersequents
In this Section, we introduce the notion of tree hypersequents and describe a com- plete cut-free corresponding derivation system.
Definition 3.1 [Sequent] A sequent is an expression Γ ▶ Δ, where Γ and Δ are formula multisets, non-empty and finite.
Intuitively, a sequent Γ ▶ Δ is interpreted, in terms of logical symbols, as an implication, where the antecedent is composed by the conjunction of formulas in Γ, and the consequent is the disjunction of formulas in Δ.
Definition 3.2 [Sequent interpretation] We then define the following interpretation function:
n	k
(φ1,..., φn ▶ ψ1,..., ψk)I :=  φi →  ψj


where n and k are some positive integers.
i=1
j=1

In sequents, we often write φ, Γ or Γ,φ instead of {φ}∪ Γ, also ▶ Δ instead of
T▶ Δ, and Γ ▶ in place of Γ ▶ ⊥.
Definition 3.3 [Tree hypersequents] Tree hypersequents expressions are inductively defined by the following grammar:
T :=S [ST ]
ST :=∅| m : T, ST

where S is a sequent and m is a modality.
Tree hypersequents can be informally seen as a tree where nodes are composed by sets of sequents. Node adjacencies are labeled by modalities. The intuition in the tree hierarchization of sequents is to distinguish which formulas hold at particular

domain instances in a tree-shaped Kripke model. Consider for instance the following tree hypersequent:
2mφ ▶ [m : φ ▶]
The sequent parent is 2mφ ▶, while the sequent child is m : φ ▶. Intuitively, it means from 2mφ holding at a particular tree node, it can be implied that φ holds at a m-child node.
Given an interpretation of sequents I (Definition 3.2), tree hypersequents are formally interpreted as follows.
Definition 3.4 [Tree hypersequent interpretation] We extend the interpretation function of sequents for tree hypersequents as follows:
(S [ST ])I :=SI ∨ (ST )I (∅)I :=⊥
(m : T, ST )I :=2mT I ∨ (ST )I

When clear from context, we often write tree instead of tree hypersequent. It is usually written S instead of S [∅], also if S is Γ ▶ Δ, we write φ, S and S, φ instead of φ, Γ ▶ Δ and Γ ▶ φ, Δ, respectively.
Before defining an occurring relation on tree hypersequents. We give a precise notion of tree hypersequent equivalence.
p ≡p;
¬φ ≡¬ψ, when φ ≡ ψ,
φ1 ∧ φ2 ≡φj ∧ φj , when φi ≡ φj or φi ≡ φj,
1	2	i
for i, j = 1, 2, and i /= j;
2mφ ≡2mψ, when φ ≡ ψ;
{φi | i = 1,..., n} ≡{ψi | i = 1,..., n}, when φi ≡ ψi,
for i = 1,..., n;
(Σ ▶ Δ) ≡(Σj ▶ Δj), when Σ ≡ Σj and Δ ≡ Δj;
S[ST ] ≡Sj[STj], when S ≡ Sj and ST ≡ STj; and

{mi : Ti,j | i = 1,..., n; j = 1,..., m} ≡{mi : T j
| i = 1,..., n; j = 1,..., m},

when Ti,j ≡ T j
for i = 1,..., n, j = 1,..., m.

Now we write T ⟨S⟩ when a sequent S occurs in a tree T , more precisely:
S [ST ] ⟨S⟩;
Sj [ST ] ⟨S⟩, provided that Sj /≡ S and ST ⟨S⟩; and
(m : T j, ST ) ⟨S⟩, when either T j ⟨S⟩ or ST ⟨S⟩.
We extend the occurring relation T ⟨T j⟩ between trees as expected:
T ≡ T j;

(S [ST ]) ⟨T j⟩, when ST ⟨T j⟩;
(m : T j, STj) ⟨T j⟩; and
(m : T jj, STj) ⟨T j⟩, provided that T jj /≡ T j and STj ⟨T j⟩.
We also distinguish when m : T j occurs in a tree T , written T ⟨m : T j⟩:
(S [ST ]) ⟨m : T j⟩, when ST ⟨m : T j⟩;
(m : T j, STj) ⟨m : T j⟩; and
(mj : T jj, STj) ⟨T j⟩, provided that either m /= mj or T jj /≡ T j, and STj ⟨m : T j⟩.
We say a sequent S occurs, under a modality m, in a finite sequence of tree hyper- sequents m1 : T1, m2 : T2,..., mk : Tk, when there is an i such that mi is m and Ti has the form S [ST ]. Moreover, we often write S [m : Sj] instead of S [ST ], provided Sj occurs under m in ST .

Definition 3.5 [Tree-hypersequents derivation system] The derivation system for tree hypersequents G is defined as follows.
Initial tree hypersequents:



Propositional rules:

T ⟨S, φ⟩
T ⟨¬φ, S⟩ ¬L
T ⟨p, S, p⟩



T ⟨φ, S⟩
T ⟨S, ¬φ⟩ ¬R

T ⟨φ, ψ, S⟩

T ⟨φ ∧ ψ, S⟩ ∧L
T ⟨S, φ⟩	T ⟨S, ψ⟩

T ⟨S, φ ∧ ψ⟩	∧R


Modal rules:


T ⟨2mφ, S [m : φ, Sj]⟩
T ⟨S [m : ▶ φ, ST ]⟩

T ⟨2mφ, S [m : Sj]⟩
2mL
T ⟨S, 2mφ [ST ]⟩
2mR


Tree-hypersequents at the top part of a rule in G are called premises. Tree- hypersequents at bottom of a rule are called conclusions. Instances of a rule without premises are called tree-hypersequent-axioms. We now define the concept of deriva- tion tree as a tree built according to the rules of G, such that nodes are composed tree-hypersequents. The tree-hypersequent at the root of a derivation tree is called the end-tree-hypersequent. The tree-hypersequents at the leaves of a derivation tree are called initial tree-hypersequents. A proof of a tree-hypersequent T in G is a derivation tree, where all initial tree-hypersequents are tree-hypersequent-axioms and the end-tree-hypersequent is T . If there is a proof of T in G, we also say T is derivable in G and we write ▶G T .
Consider now for instance the following proof of A4:


T ⟨φ ▶ ψ, φ⟩
T ⟨φ, ψ ▶ ψ⟩
T ⟨φ ▶ ψ, ¬ψ⟩ ¬R

T ⟨φ ▶ ψ, φ ∧ ¬ψ⟩	∧R
 2m¬(φ ∧ ¬ψ), 2mφ ▶ [m : ¬(φ ∧ ¬ψ), φ ▶ ψ] ¬L

2m¬(φ ∧ ¬ψ), 2m
φ ▶ [m : φ ▶ ψ]
2mL
2mL

 2m¬(φ ∧ ¬ψ), 2mφ ▶ [m : ▶ ψ]
2mR
2m¬(φ ∧ ¬ψ), 2mφ ▶ 2mψ
2m¬(φ ∧ ¬ψ), 2mφ, ¬2mψ ▶ ¬L
2m¬(φ ∧ ¬ψ) ∧ 2mφ ∧ ¬2mψ ▶ ∧L
▶ ¬(2m¬(φ ∧ ¬ψ) ∧ 2mφ ∧ ¬2mψ) ¬R
In the proof, the first time rule 2mL is applied is to 2mφ, whereas the second time is applied to 2m(¬(φ ∧ ¬ψ).
We now recall the tree hypersequent derivation system is sound and complete with respect to the Hilbert derivation system.
Theorem 3.6 ([25,23]) For any sequent S, ▶G S, if and only if, ▶H S.
It is thus straightforward from Theorems 2.4 and 3.6, that the tree hypersequent derivation system is correct.
Corollary 3.7 For any sequent S, ▶G S, if and only if, |= SI .
We conclude this Section recalling the complexity of the tree hypersequent deriva- tion system.
Theorem 3.8 ([23]) For any given sequent S, deciding ▶G S is in 2EXPTIME.

Interpolation
We present our main result in this Section, Craig interpolation for Km. We follow a constructive technique originally introduced by Maehara [17]. Since Km can be seen as classical propositional logic extended with 2m operator, from the syntactic point of view, our proof coincides in all boolean cases with Maehara’s proof for classical first-order logic. However, this technique was not able to be generalized to rules for 2m operator before. This is because, until the introduction of the cut-free tree hypersequent system described in our paper, it was not known a sequent-like inference system satisfying the subformula property [23].
We first define the set of non-logical symbols Sym(φ) of a formula φ as follows:
Sym(p)= {p};
Sym(¬φ)= Sym(φ);
Sym(φ ∧ ψ)= Sym(φ) ∪ Sym(ψ); and
Sym(2mφ)= {m}∪ Sym(φ).
The set of non-logical symbols of a (multi-)set of formulas is defined as expected.

For technical convenience, we consider an equivalent extension Gj of the deriva- tion system G, where formulas T are considered per se (not as notation). All rules in G are also in Gj. Additionally, the initial sequent T ⟨S, T⟩ is also included in Gj.
Lemma 4.1 (Maehara’s Lemma) Let T ⟨Γ ▶ Δ⟩ be derivable in G, and let Γ1, Γ2 and Δ1, Δ2 be partitions of Γ and Δ, respectively. Then there is a formula β, called the interpolant, such that T ⟨Γ1 ▶ Δ1, β⟩ and T ⟨β, Γ2 ▶ Δ2⟩ are derivable in Gj, and Sym(β) ⊆ (Sym(Γ1) ∪ Sym(Δ1)) ∩ (Sym(Γ2) ∪ Sym(Δ2)).
Proof. By induction on the height of the proof tree.
The base case is T ⟨p, Γ ▶ Δ, p⟩. The interpolant β is then defined according to the occurrence of propositions p in partitions. In case both p’s occur in partitions Γ1 and Δ1, respectively, the interpolant is then ¬T. It is the clear that
T ⟨p, Γ1 ▶ Δ1, p, ¬T⟩	T ⟨¬T, Γ2 ▶ Δ2⟩

For the following cases, we just list the respective partitions and interpolants.
T ⟨Γ1 ▶ Δ1, T⟩	T ⟨T, p, Γ2 ▶ p, Δ2⟩
T ⟨p, Γ1 ▶ Δ1, p⟩	T ⟨p, Γ2 ▶ Δ2, p⟩
T ⟨Γ1 ▶ Δ1, p, ¬p⟩	T ⟨¬p, p, Γ2 ▶ Δ2⟩

Induction step. Assume the last inference is the following:
T ⟨Γ ▶ Δ, φ⟩	T ⟨Γ ▶ Δ, ψ⟩ T ⟨Γ ▶ Δ,φ ∧ ψ⟩
By induction hypothesis, there are interpolants β1 and β2 for the upper tree hyper- sequents. There are two possible cases, for each tree hypersequent on the top of the inference rule, according to the occurrence of φ and ψ in the respective partitions. We then have the following four proofs:
T ⟨Γ1 ▶ Δ1, φ, β1⟩	T ⟨β1, Γ2 ▶ Δ2⟩
T ⟨Γ1 ▶ Δ1, ψ, β2⟩	T ⟨β2, Γ2 ▶ Δ2⟩
T ⟨Γ1 ▶ Δ1, β1⟩	T ⟨β1, Γ2 ▶ Δ2, φ⟩
T ⟨Γ1 ▶ Δ1, β2⟩	T ⟨β2, Γ2 ▶ Δ2, ψ⟩

Depending on the occurrence of φ∧ψ in partitions, we then construct the interpolant
φ as follows:
T ⟨Γ1 ▶ Δ1,φ ∧ ψ, β1 ∨ β2⟩	T ⟨β1 ∨ β2, Γ2 ▶ Δ2⟩
T ⟨Γ1 ▶ Δ1, β1 ∧ β2⟩	T ⟨β1 ∧ β2, Γ2 ▶ Δ2,φ ∧ ψ⟩

Now consider the last inference is the following:
T ⟨Γ, φ,ψ ▶ Δ⟩
T ⟨Γ,φ ∧ ψ ▶ Δ⟩

By induction we have the following interpolant cases, depending on the occurrence of φ and ψ in partitions:
T ⟨Γ1, φ,ψ ▶ Δ1, β⟩	T ⟨β, Γ2 ▶ Δ2⟩
T ⟨Γ1,φ ▶ Δ1, β⟩	T ⟨β, ψ, Γ2 ▶ Δ2⟩
T ⟨Γ1,ψ ▶ Δ1, β⟩	T ⟨β, φ, Γ2 ▶ Δ2, ⟩
T ⟨Γ1 ▶ Δ1, β⟩	T ⟨β, φ, ψ, Γ2 ▶ Δ2⟩
Then, no matter in which partition occurs φ ∧ ψ, β is also the interpolant:
T ⟨Γ1,φ ∧ ψ ▶ Δ1, β⟩	T ⟨β, Γ2 ▶ Δ2⟩
T ⟨Γ1 ▶ Δ1, β⟩	T ⟨φ ∧ ψ, β, Γ2 ▶ Δ2⟩
If the last inference involves a negation of the right
T ⟨Γ,φ ▶ Δ⟩
T ⟨Γ ▶ Δ, ¬φ⟩
we then have the following interpolant by induction
T ⟨Γ1,φ ▶ Δ1, β⟩	T ⟨β, Γ2 ▶ Δ2⟩
T ⟨Γ1 ▶ Δ1, β⟩	T ⟨β, φ, Γ2 ▶ Δ2⟩
It is then clear β is also the interpolant of negation
T ⟨Γ1 ▶ Δ1, β, ¬φ⟩	T ⟨β, Γ2 ▶ Δ2⟩
T ⟨Γ1 ▶ Δ1, β⟩	T ⟨β, Γ2 ▶ Δ2, ¬φ⟩
We proceed analogously for the other induction step involving negation on the left:
T ⟨Γ ▶ φ, Δ⟩
T ⟨Γ, ¬φ ▶ Δ⟩
Consider now the induction step when the last inference is the following:
T ⟨2mφ, Γ ▶ Δ [m : φ, Γj ▶ Δj]⟩
T ⟨2mφ, Γ ▶ Δ [m : Γj ▶ Δj]⟩
By induction, there is an interpolant β for the upper tree hypersequent. By the occurrence of 2mφ in partitions, we distinguish two cases:
T 2mφ, Γ1 ▶ Δ1,β m : φ, Γj ▶ Δj	T β, Γ2 ▶ Δ2 m : φ, Γj ▶ Δj 
T Γ1 ▶ Δ1,β m : φ, Γj ▶ Δj	T β, 2mφ, Γ2 ▶ Δ2 m : φ, Γj ▶ Δj 
We then construct the following interpolants:
T  2mφ, Γ1 ▶ Δ1, 2mφ ∧ β m : Γj ▶ Δj   T  2mφ ∧ β, Γ2 ▶ Δ2 m : Γj ▶ Δj 
T Γ1 ▶ Δ1, ¬2mφ ∨ β m : Γj ▶ Δj	T  ¬2mφ ∨ β, 2mφ, Γ2 ▶ Δ2 m : Γj ▶ Δj 
Consider now the last inference is the following:

T ⟨Γ ▶ Δ [m : ▶ φ, ST ]⟩
T ⟨Γ ▶ Δ, 2mφ [ST ]⟩
We obtain the following interpolant β by induction:
T ⟨Γ1 ▶ Δ1,β [m : ▶ φ, ST ]⟩	T ⟨β, Γ2 ▶ Δ2 [m : ▶ φ, ST ]⟩
There are then two cases depending on the occurrence of 2mφ in partitions:
T ⟨Γ1 ▶ Δ1, 2mφ, ¬2mφ ∧ β [ST ]⟩	T ⟨¬2mφ ∧ β, Γ2 ▶ Δ2 [ST ]⟩
T ⟨Γ1 ▶ Δ1, 2mφ ∨ β [ST ]⟩	T ⟨2mφ ∨ β, Γ2 ▶ Δ2, 2mφ [ST ]⟩
2
Theorem 4.2 (Craig Interpolation) For any two formulas φ and ψ, if |= φ → ψ, then there is a formula β, such that |= φ → β, |= β → ψ and Sym(β) ⊆ Sym(φ) ∩ Sym(ψ), provided that there is a proposition p such that p ∈ Sym(φ) ∩ Sym(β).
Proof. Assume |= φ → ψ, then by Corollary 3.7, φ ▶ ψ is derivable in G. By Lemma 4.1, there is a formula β, such that φ ▶ β and β ▶ ψ are derivable in Gj. Let p ∈ Sym(φ) ∩ Sym(ψ).  Now, let βj be obtained from β by replacing T by
¬(p ∧ ¬p). It is straightforward that φ ▶ β and β ▶ φ are derivable in G, and hence (by Corollary 3.7) |= φ → β and |= β → ψ.	2
From Theorem 3.8 and Lemma 4.1, it is also immediate to obtain an upper bound for the computation of interpolants.
Corollary 4.3 (Complexity) Computing Km interpolants is in 2EXPTIME.
Definability and Consistency
The Beth definability property consists in that implicit definability implies explicit definability. We first show this property also holds for Km as direct corollary of Craig interpolation. Also as an immediate consequence of interpolation, we prove Km enjoys Robinson joint consistency, which states that the union of two consistent axiom systems (theories), with respect to their common alphabet, is consistent.
Definition 5.1 [Implicit definability] Let φ(p, p1,.	, pk) be a formula, where p, p1,
..., pk are propositions occurring in it. We say φ(p, p1,.	, pk) defines p implicitly
if
|= (φ(p, p1,..., pk) ∧ φ(pj, p1,..., pk)) → (p ↔ pj)
where p /= pj.
Definition 5.2 [Explicit definability] Let φ(p, p1,..., pk) be a formula, where p, p1,
..., pk are propositions occurring in it. We say φ(p, p1,..., pk) defines p explicitly, when
|= φ(p, p1,..., pk) → (p ↔ ψ)
where Sym(ψ) ⊆ Sym(φ(p, p1,..., pk)) \ {p}.

Theorem 5.3 (Beth Definability) Let φ(p, p1,..., pk) be a formula, where p, p1,
..., pk are propositions occurring in it. If φ(p, p1,..., pk) defines p implicitly, then
φ(p, p1,..., pk) defines p explicitly.
Proof. From the implicit definability assumption, it is easy to see that
|= (φ(p, p1,..., pk) ∧ p) → (φ(pj, p1,..., pk) → pj)
By the Craig Interpolation Theorem 4.2, we then obtain
|= (φ(p, p1,..., pk) ∧ p) → ψ
|= ψ → (φ(pj, p1,..., pk) → pj)
where Sym(ψ) ⊆ Sym(φ(p, p1,..., pk)) \ {p}.	2
Before defining the notion of consistency, we need a precise description of some concepts. An axiom system is a finite set of formulas. An axiom sequence is a (pos- sibly empty) subset of an axiom system. We say a sequent S is derivable (provable) in G from an axiom system A, if there is an axiom sequence Aj of A, such that
▶G Aj, S.
Definition 5.4 [Consistency] An axiom system is inconsistent if the empty sequent is derivable from it. We say an axiom system is consistent if it is not inconsistent.
Theorem 5.5 (Robinson Joint Consistency) Consider two consistent axiom sys- tems A1 and A2, if for any formula φ, such that Sym(φ) ⊆ Sym(A1) ∩ Sym(A2), if it is not the case that both φ and ¬φ are derivable from A1 and A2 (or A2 and A1), respectively, then A1 ∪ A2 is consistent.
Proof. We prove the contrapositive. If A1 ∪A2 is not consistent, then there are two

axiom sequences Aj
and Aj
of A1 and A2, resp., such that A1, A2 ▶ are derivable in

G. Recall each A1 and A2 is consistent, then not empty. By Lemma 4.1, there is an interpolant φ, where Sym(φ) ⊆ Sym(A1) ∩ Sym(A2), such that A1 ▶ φ and φ, A2 ▶ (hence A2 ▶ ¬φ) are both derivable in Gj. As in the proof of Theorem 4.2, it is straight forward that both A1 ▶ φ and A2 ▶ ¬φ are also derivable in G by replacing all the occurrences of T in φ by ¬(p ∧ ¬p) for a p ∈ Sym(A1) ∪ Sym(A2).	2
Conclusions
Although it was already known the multi-modal logic Km has the Craig interpolation property [21], in this paper, we give a constructive proof of the Craig interpolation property. The proof is based on the Maehara technique on a complete cut-free tree-hypersequent calculus. An interpolant algorithm can easily be inferred from the proof. To the best of our knowledge, such explicit construction of Km inter- polants was not known before. The construction of interpolants is important in many contexts, such as knowledge representation and formal verification, as a mod- ularization procedure [28,22]. Motivated by these applications, we also described a

2EXPTIME upper bound for interpolant computation. A lower bound is defini- tively an interesting further research direction.
Computation of interpolants can also be applied in the construction of explicit definitions from implicit ones. We also described a construction like this in order to prove the Beth Definability Theorem for Km. Computation of explicit definitions is known important in query rewriting algorithms, whose application domain is extensive to several areas in computer science [28]. It is then clear our motivation on interpolant size complexity as future work.
In many temporal extensions of modal logic K, interpolation is not common. In linear temporal logic (LTL), computation tree logic (CTL) and CTL٨, inter- polation fails [20]. It is also de the case for the epistemic logic with common knowledge [27].  Interpolation for propositional dynamic logic (PDL) has been a
notable elusive problem. First time interpolation for PDL has been claimed was by Leivant [14]. However, Kratch noticed some problems in this proof [13]. Later on came another interpolation claim for PDL by Kowalski [11], who soon retracted [12]. Hence, interpolation for PDL is definitely a very interesting and challenging research perspective.
Interpolation for μ-calculus is already known [6]. However, it is not known a constructive proof of it. Since it is also not known a cut-free sequent-like derivation system for the μ-calculus, it is then not trivial to generalize Maehara’s technique for this logic. A constructive proof of interpolation for the μ-calculus can thus also be an interesting research direction.

References
Beth, E. W., On Padoa’s method in the theory of deﬁnition, Journal of Symbolic Logic 21 (1956).
Bílková, M., Uniform interpolation and propositional quantiﬁers in modal logics, Studia Logica 85
(2007).
Cook, S. A. and R. A. Reckhow, The relative eﬃciency of propositional proof systems, J. Symb. Log.
44 (1979).
Craig, W., Three uses of the Herbrand-Gentzen theorem in relating model theory and proof theory, J. Symb. Log. 22 (1957).
D’Agostino, G., Interpolation in non-classical logics, Synthese 164 (2008).
D’Agostino, G. and M. Hollenberg, Logical questions concerning the μ-calculus: Interpolation, lyndon and Los-tarski, The Journal of Symbolic Logic 65 (2000).
Fitting, M. and R. Kuznets, Modal interpolation via nested sequents, Ann. Pure Appl. Logic 166 (2015).
Gabbay, D. M., Craig’s interpolation theorem for modal logics, in: W. Hodges, editor, Conference in Mathematical Logic — London ’70. Lecture Notes in Mathematics (1972).
Gabbay, D. M. and L. L. Maksimova, “Interpolation and Definability,” Springer Netherlands, Dordrecht, 2011 .
Halpern, J. Y. and Y. Moses, A guide to completeness and complexity for modal logics of knowledge and belief, Artif. Intell. 54 (1992).
Kowalski, T., PDL has interpolation, Journal of Symbolic Logic 67 (2002).
Kowalski, T., Retraction note for “PDL has interpolation”, Journal of Symbolic Logic 69 (2004).

Kracht, M., “Tools and Techniques in Modal Logic,” Elsevier, 1999.
Leivant, D., A proof theoretic methodology for propositional dynamic logic, in: J. Díaz and I. Ramos, editors, Formalization of Programming Concepts, International Colloquium,, Lecture Notes in Computer Science 107 (1981).
Lutz, C. and F. Wolter, Foundations for uniform interpolation and forgetting in expressive description logics, in: T. Walsh, editor, IJCAI, Proceedings of the 22nd International Joint Conference on Artiﬁcial Intelligence (2011).
Madarász, J. X., The Craig interpolation theorem in multi-modal logics, Bulletin of the Section of Logic
3 (1995).
Maehara, S., On the interpolation Theorem of Craig, Sugaku 12 (1960).
Maksimova, L., Interpolation theorems in modal logics and amalgamable varieties of topological boolean algebras, Algebra and Logic 18 (1979).
Maksimova, L., Amalgamation and interpolation in normal modal logics, Studia Logica 50 (1991).
Maksimova, L., Temporal logics with "the next" operator do not have interpolation or the beth property, Siberian Mathematical Journal 32 (1991).
Marx, M., Interpolation in modal logic, in: A. M. Haeberer, editor, Algebraic Methodology and Software Technology, 7th International Conference, AMAST, Proceedings, Lecture Notes in Computer Science 1548 (1998).
McMillan, K. L., Interpolation and model checking, in: E. M. Clarke, T. A. Henzinger, H. Veith and
R. Bloem, editors, Handbook of Model Checking., Springer, 2018 .
Munoz-Toriz, J.-P., E. Bárcenas, I. Martínez-Ruiz and J.-R.-E. Arrazola-Ramírez, (Hyper)sequent calculi for the ALC(S4) description logics, Computación y Sistemas 20 (2016).
Nguyen, L. A., Analytic tableau systems and interpolation for the modal logics KB, KDB, K5, KD5, Studia Logica 69 (2001).
Poggiolesi, F., “Sequent calculi for modal logic,” Ph.D. thesis, Università degli Studi di Firenze, Université Paris I Panthéon-Sorbonne (2008).
Robinson, A., A result on consistency and its application to the theory of deﬁnition, Journal of Symbolic Logic 25 (1960).
Studer, T., Common knowledge does not have the beth property, Inf. Process. Lett. 109 (2009).
ten Cate, B., E. Franconi and I. Seylan, Beth deﬁnability in expressive description logics, J. Artif. Intell. Res. 48 (2013).
