Electronic Notes in Theoretical Computer Science 170 (2007) 3–21	
www.elsevier.com/locate/entcs

A Process Algebra for Reasoning About Quantum Security
P. Ad˜ao1 ,3 ,4
Center for Logic and Computation, Department of Mathematics IST, Technical University of Lisbon
Lisbon, Portugal
P. Mateus2 ,3 ,5
Center for Logic and Computation, Department of Mathematics IST, Technical University of Lisbon
Lisbon, Portugal

Abstract
We present a process algebra for specifying and reasoning about quantum security protocols. Since the computational power of the protocol agents must be restricted to quantum polynomial-time, we introduce the logarithmic cost quantum random access machine (QRAM) similar to [4,6], and incorporate it in the syntax of the algebra. Probabilistic transition systems give the semantic for the process algebra. Term reduction is stochastic because quantum computation is probabilistic and, moreover, we consider a uniform scheduler to resolve non-deterministic choices. With the purpose of defining security properties, we introduce observational equivalence and quantum com- putational indistinguishability, and show that the latter is a congruence relation. A simple corollary of this result asserts that any security property defined via emulation is compositional. Finally, we illustrate our approach by establishing the concept of quantum zero-knowledge protocol.
Keywords: Quantum process algebras, quantum polynomial-time machines, quantum zero-knowledge proofs.


1 Email: pad@math.ist.utl.pt
2 Email: pmat@math.ist.utl.pt
3 Partially supported by FEDER/FCT project QuantLog POCI/MAT/55796/2004.
4 Additional support from FCT grant SFRH/BD/8148/2002.
5 Additional support from the Anglo-Portuguese Joint Research Programme, Treaty of Windsor B22/05, 2005-2006.



1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2006.12.009

Introduction

Security protocols are, in general, composed by several agents running in par- allel, where each agent computes information (bounded by polynomial-time on the security parameter) and exchange it with other agents. In the context of quantum processes, the computation is bounded by quantum polynomial- time and the information exchanged is supported by qubits. In this paper, the problem of defining quantum security properties is addressed using a quantum polynomial-time process algebra. This approach is highly inspired in [13,9].
The computational model we adopt to define quantum polynomial terms is based on the logarithmic cost random access machine [4]. A hybrid model, using both classic and quantum memory, similar to [6] but with complexity assumptions, is considered and it is shown to be (polynomial-time) equivalent to a uniform family of quantum circuits (which are, by themselves, equivalent to quantum Turing machines). Such machines model the computation of each agent, receive qubits as input, and return qubits as output.
Thanks to the non-cloning theorem, quantum information cannot be copied without prior knowledge of its state. This observation imposes some design options in the process algebra, since it is necessary to know which agent pos- sesses a qubit in order to know who can retrieve each piece of information. In order to deal with this fact, a set of agents is fixed and the qubits are partitioned among them.
Although several other approaches to quantum process algebras are al- ready present in the literature (see [5], for instance), ours is quite original, due to the universe of application—security protocols. In our approach, pro- cess terms are divided into local and global. An agent is modelled by a local process while a protocol is modelled by a global process so, a global pro- cess corresponds to local processes running in parallel. A semantics based on probabilistic transition systems (which can be easily translated to Markov chains) is provided, and the probabilistic transitions are defined using rules and assuming a uniform scheduler to resolve non-deterministic choices.
Agent observation is defined as a probability distribution over binary words obtained by measuring on the computational basis (some of) the agent’s qubits. This measurement is done at the end of a protocol run. This con- cept is the key ingredient to establish observational equivalence that, in the context of security protocols, is based on computational indistinguishability [14]. Intuitively, two process terms are observational equivalent for an agent if, after making all possible reductions to each process, it is impossible to distin- guish (in quantum polynomial-time) the qubits of the agent on both processes. Since we internalize quantum polynomial-time machines in the process alge-

bra language, observational equivalence is easily defined and it is shown to be a congruence relation.
One of the most successful ways for defining secure concurrent crypto- graphic tasks is via process emulation [1,2]. This definitional job boils down to the following: a process realizes a cryptographic task if and only if it emu- lates an ideal process that is known to realize such task. Based on the notion of observational equivalence, we establish the notion of emulation for the quan- tum process calculus and show that it is compositional. Finally, we provide the notion of quantum zero-knowledge via process emulation.
In Section 2 the process algebra is introduced together with the logarithmic cost random access machine. Both the syntax and the semantics of the process algebra are clearly established, and the section is concluded by presenting the notion of observational equivalence. Section 3 is devoted to emulation and its composition theorem, and finally, in Section 4 quantum zero-knowledge is defined using process emulation.

Process Algebra
In the context of security protocols it is common to consider a security pa- rameter η ∈ N. In the case of quantum protocols we will also consider such parameter in order to bound the quantum complexity of the principals and adversaries. From now on, the symbol η is reserved to designate such security parameter. The role of this parameter is twofold: it bounds to a polynomial on η the number of qubits that can be sent through channels, and it bounds all the computation to quantum polynomial time (on η). We now detail these aspects culminating with the presentation of the process algebra language.
Quantum polynomial machines
The computational model we adopted to define quantum polynomial machine is based on the logarithmic cost random access machine [4] and it is quite simi- lar to the quantum random access machine in [6]. We consider a hybrid model using both classic and quantum memory. In order to cope with a countable set of qubits qB we adopt the following Hilbert space H (isomorphic to l2(2qB) and L2(2qB, #)) to model the quantum state (see [10,11] for a discussion on why H is the correct Hilbert space for modelling a countable set of qubits):
each element is a map |ψ⟩ : 2qB → C such that:
supp(|ψ⟩)= {v ∈ 2qB : |ψ⟩(v) /= 0} is countable;
Σ ||ψ⟩(v)|2 =	Σ	||ψ⟩(v)|2 < ∞;
v∈2qB	v∈supp(|ψ⟩)

|ψ1⟩ + |ψ2⟩ = λv. |ψ1⟩(v)+ |ψ2⟩(v);
z|ψ⟩ = λv. z|ψ⟩(v);
⟨ψ1|ψ2⟩ = Σ |ψ1⟩(v) |ψ2⟩(v).
v V
The inner product induces the norm |||ψ⟩|| = √⟨ψ|ψ⟩ and so, the distance d(|ψ1⟩, |ψ2⟩)= |||ψ1⟩− |ψ2⟩||. Clearly, {|v⟩ : v ∈ 2qB} is an orthonormal basis of H where |v⟩(v) = 1 and |v⟩(v') = 0 for every v' /= v. This basis is called the computational or logic basis of H.
A configuration of a quantum random access machine (QRAM) is triple ξ = (m, |ψ⟩, s) where m ∈ NN, |ψ⟩ ∈ H and s ∈ N. The first component of the triple represents the classical memory of the machine—an infinite sequence of natural numbers, the second component represents the quantum state of the machine, and finally the third component is a counter that indicates how many (qu)bit operations are allowed.
We associate to each QRAM a positive polynomial q for bounding the number of allowed (qu)bit operations to q(η). In this way, we force each QRAM to terminate in polynomial-time. Given a finite set of qubits at state
|ϕ⟩, the initial conﬁguration of the QRAM is the triple ξ0(|ϕ⟩) = (m0, |ϕ⟩⊗ 
|0⟩, q(η)), where the sequence m0 is such that m0(k) = 0 for all k ∈ N and |0⟩ is the unit vector in H such that |0⟩(∅) = 1 (note that if Q is a 2n dimension Hilbert space, then there is a canonical isomorphism between H and Q⊗ H, and therefore |ϕ⟩⊗ |0⟩∈ Q ⊗ H can be seen as a unit vector in H). A QRAM receives as input a finite sequence of qubits, but since it is always possible to encode classical bits in qubits this is not a limitation.
The set of atomic commands AC, and their associated cost is presented in the table below 6 .












6 We denote the number of bits required to represent a natural number n by |n|.


Most of the commands above are self-explanatory, but it is worthwhile to notice that all commands are deterministic with exception of measure. In- deed, according to the measurement postulates of quantum mechanics (see for instance [3]), when a quantum system is measured the outcome is stochastic, and moreover the state evolves accordingly to this outcome. Note that we only consider measurements over the computational basis, nevertheless this is not a limitation since any other qubit measurement can be performed by applying a unitary transformation before measuring the qubit over the computational basis.
The set of QRAM commands C is obtained inductively as follows:
a ∈C if a ∈ AC;
c1; c2 ∈C if c1, c2 ∈ C;
(if (Rn > 0) then c) ∈C if c ∈ C;
(while (Rn > 0) c) ∈C if c ∈ C.
The execution of a QRAM command c is a stochastic function between configurations. Let Ξ = NN ×H× N be the set of all configurations, and Probfin(Ξ) be the set of all probability measures over (Ξ, 2Ξ) such that only a finite set of configurations have probability different from 0. The execution of a QRAM command c is a map runc :Ξ → Probfin(Ξ), and we write [c] ξ →p ξ' to denote that Prrunc(ξ)(ξ') = p. The execution of QRAM commands can be defined using the following rules, which are quite intuitive:




[Ri
s ≥ |n|
= n] (m, |ψ⟩, s) →1
(m', |ψ⟩,s − |n|) (Ri = n),

where m'(k)= m(k) for all k /= i and m'(i)= n;
	s ≥ |Rj|	
(R


= R ),

[Ri
= Rj] (m, |ψ⟩, s) →1
(m', |ψ⟩,s − |Rj|)

where m'(k)= m(k) for all k /= i and m'(i)= m(j);


	s ≥ |Rj| + |Rk|	
(R = R
+ R ),

[R = R
+ R ] (m, |ψ⟩, s) →
(m', |ψ⟩,s − (|R | + |R |))	i	j	k

where m'(k)= m(k) for all k /= i and m'(i)= m(j)+ m(k);


	s ≥ |Rj| + |Rk|	
(R = R
— R ),

[R = R
— R ] (m, |ψ⟩, s) →
(m', |ψ⟩,s − (|R | + |R |))	i	j	k

where m'(k)= m(k) for all k /= i and m'(i)= max(m(j) − m(k), 0);


	s ≥ |Rj|× |Rk|	
(R
= R R ),

[R = R R ] (m, |ψ⟩, s) →
(m', |ψ⟩,s − (|R |× |R |))	i	j  k

where m'(k)= m(k) for all k /= i and m'(i)= m(j)m(k);


	s ≥ |Rj|× |Rk|	
(R
= R /R ),

[R = R /R ] (m, |ψ⟩, s) →
(m', |ψ⟩,s − (|R |× |R |))	i	j	k

where m'(k)= m(k) for all k /= i and m'(i)= [m(j)/m(k)♩;


s ≥ |Rj| + |RRj |
(R = R	),

[R = R	] (m, |ψ⟩, s) → (m', |ψ⟩,s − (|R | + |R
|))	i	Rj

i	Rj	1	j	Rj
where m'(k)= m'(k) for all k /= i and m'(i)= m(m(j));


	s ≥ |Ri| + |Rj|	
(R
= R ),

[R	= R ] (m, |ψ⟩, s) → (m', |ψ⟩,s − (|R | + |R |))	Ri	j
Ri	j	1	i	j
where m'(k)= m(k) for all k /= m(i) and m'(m(i)) = m(j);




[PauliX
s ≥ 1 [b]] (m, |ψ⟩, s) →1
(m, |ψ'⟩,s − 1) (PauliX[b]),
⎡ 0	1 ⎤

where |ψ'⟩ is obtained from |ψ⟩ by applying the PauliX operator
1	0
qubit b. Similar rules apply to the following one-qubit operators:
⎦ on

⎡ 0 −i ⎤	⎡ 1	0 ⎤

PauliY
⎣ i	0
⎦;	PauliZ ⎣
;
0 −1

⎡ 1	1 ⎤
⎡ 1	0 ⎤
⎡ 1	0 ⎤

Hadamard 1
2
⎣ 1 −1
;	Phase	;	π
0	i
⎣ 0 eiπ/4 ⎦



s ≥ 1
[c-not[b ,b ]] (m, |ψ⟩, s) →
(m, |ψ'⟩,s − 1) (c-not[b1, b2]),

where |ψ'⟩ is obtained from |ψ⟩ by applying the control-not operator
⎡ 1	0	0	0 ⎤
0	1	0	0
0	0	0	1
0	0	1	0
on qubits b1 and b2;


s ≥ 1 [measure[b] → Ri] (m, |ψ⟩, s) →p
(m', |ψ'⟩,s − 1)) (measure[b] → Ri = 0),

where |ψ'⟩ is equal to  P0|ψ⟩ , p = |P0|ψ⟩| (P0 is the projector onto the subspace
|P0|ψ⟩|	'	'


s ≥ 1 [measure[b] → Ri] (m, |ψ⟩, s) →p
(m', |ψ'⟩,s − 1)) (measure[b] → Ri = 1),

where |ψ'⟩ is equal to  P1|ψ⟩ , p = |P1|ψ⟩| (P1 is the projector onto the subspace
|P1|ψ⟩|	'	'



[c1] (m, |ψ⟩, s) →p1 (m', |ψ'⟩, s')	[c2] (m', |ψ'⟩, s') →p2 (m'', |ψ''⟩, s'')
(c ; c );

[c1; c2] (m, |ψ⟩, s) →p1×p2
(m'', |ψ''⟩, s'')	1	2



m(n) > 0	s ≥ |Rn|	[c] (m, |ψ⟩,s − |Rn|) →p (m', |ψ'⟩, s')
[(if (Rn > 0) then c)] (m, |ψ⟩, s) →p [c] (m', |ψ'⟩, s')
(ifT);



m(n)= 0


[(if (Rn > 0) then c)] (m, |ψ⟩, s) →1 (m, |ψ⟩, s)
(if⊥);



m(n) > 0	s ≥ |Rn|
[c; (while (Rn > 0) c)] (m, |ψ⟩,s − |Rn|) →p (m', |ψ'⟩, s')
[(while (Rn > 0) c)] (m, |ψ⟩, s) →p (m', |ψ'⟩, s')


(whileT);



m(n)= 0

[(while (Rn > 0) c)] (m, |ψ⟩, s) →1 (m, |ψ⟩,s − |Rn|)
(while⊥).


Observe, that the reduction of QRAM commands always terminate, since every computation is bounded by q(η) (qu)bit steps. The execution of a QRAM command can be seen as a word run of a quantum automaton [8], however a detailed discussion about this subject is out of the scope of this abstract.
The output of a QRAM is the quantum state of a set of qubits. This output set is determined by another positive polynomial o associated to the machine. Given a security parameter η, the set of output qubits is constituted by the first o(η) qubits.
Definition 2.1 A quantum polynomial machine is a triple M = (c, q, o) where c is a QRAM command, q is a positive step bounding polynomial and o is a positive output polynomial. We denote the set of all these triples by QPM.
Given a quantum polynomial machine M and a security parameter η, the computation of M over state |ψ⟩ is the probability distribution over the state of the first o(η) qubits of |ψ'⟩, where this distribution is defined by the execution rules [c](m0, |ψ⟩, q(η)) →p (m', |ψ'⟩, s'). Hence, the computation of a QRAM is a probability distribution over the state space of the first o(η) qubits. It is traditional in quantum algorithms to measure all relevant qubits at the

end of the computation in order to obtain a classical result (see Shor’s and Grover’s algorithms). However, since we use QRAM to compute quantum information that can be sent through quantum channels, we do not impose this final measurement since it may be desirable to send a superposition through a quantum channel.
The following result asserts that the QRAM model is equivalent to the usual quantum circuit computational model (a careful presentation of this result is out of the scope of this abstract).
Proposition 2.2 For any uniform family of polynomial quantum circuits Q =
{Qη}η∈N, there exists a quantum polynomial machine MQ such that the MQ computes the same stochastic function as Q. Moreover, for any quantum polynomial machine M there exists an equivalent uniform family of polynomial quantum circuits QM = {Qη}η∈N.
Proof (Sketch): Note that a uniform circuit uses precisely the gates defined as quantum atomic commands of the QRAM. The construction of the circuit can be mimicked by a RAM command c. Since this construction must be poly- nomial in η, the program must terminate in polynomial time and therefore, there is a polynomial q to bound the number of steps, finally the output must always be a polynomial set of qubits, and therefore we are able to construct an equivalent QRAM machine.
On the other hand a QRAM program is the realization of the uniform family construction, since, for each η, a circuit can be retrieved by looking at the finite (do not forget that QRAM programs always terminate) sequence of quantum atomic gates generated by the execution of the command. The stochastic nature of the execution does not bring a problem, since gates placed after a measurement can be controlled by the outcome of that measurement. If a measurement gives the value 1 to a qubit and in that case a gate U is placed at some qubit b, then the circuit should be constructed by placing a control-U gate controlled by the measured qubit and targeted at b.	 

Process algebra
As stated before, we require to know who possesses a qubit in order to know who can retrieve some piece of information. In order to deal with this fact, a qubit is considered to belong to some agent, and therefore, the set of qubits qB is partitioned among all agents. To make this more precise, a countable set A = {a1,... , ak,... } of agents is fixed once and for all, and moreover the partition qB = {qBai }ai∈A of qB is such that each set qBai is countable and recursively enumerable.
Note that each qBai has a total order (with a bottom element) induced by

its recursive enumeration. The purpose of this total ordering is to re-index the qubits accessed by a QPM M when an agent a executes M. An obvious desideratum of the system is that an agent a is restricted to compute over its own qubits qBa, and therefore, when agent a executes a quantum polynomial machine M, this machine must have access only to the qubits in qBa (note that if the qubits of a are entangled with other qubits, then when the former are modified so can be the latter). Therefore, if, for instance, an agent a executes a machine that consists of the command PauliX[b], and if qBa is recursively enumerated by γ, then the command effectively executed is PauliX[γ(b)]. The same procedure applies to the input and output qubits, so when a machine executed by a outputs the first o(η) qubits, the machine is in fact outputting the qubits {γ(o(1)),... , γ(o(η))}⊂ qBa ⊆ qB.
Communication between agents is achieved via public channels, allowing qubits to be exchanged. Clearly, this process is modelled by modifying the partition of qB. It is also convenient to allow parallelism inside an agent (that is, an agent may be constituted by several processes in parallel), for this pur- pose, private channels (that cannot be intercepted) allowing communication between the agent local processes are introduced. To make this assumptions clear, two countable disjoint sets of quantum channels are considered, the set of global or public channels G = {g1, g2,... , gk,... }, and the set of local or private channels L = {l1, l2,... , lk,... }. We denote by C the set G ∪ L. All global channels can be read and written by an adversary while local channels correspond to private communication from one agent to itself. One role of the security parameter is to bound the bandwidth of the channels. Hence, we introduce a bandwidth map bw : C → q, where q is the set of all polynomials taking positive values. Given a value η for the security parameter, a channel c can send at most bw(c)(η) qubits.
We also consider a countable set of variables Var = {x1, x2,... , xk,... }, which are required to define qubit terms. A qubit term t is either a finite subset of qB or a variable x ∈ Var.
Finally, we present the language of processes, which is a fragment of π- calculus. Mind that the overall computation must be quantum polynomial on η and therefore we do not cope with recursion nor mobility. First, we establish the language of an agent, that we call local process language.
Definition 2.3 The language of local processes L is obtained inductively as follows:
0 ∈L (termination);
c⟨M(t)⟩∈ L where M ∈ QPM, t is a qubit term, and c ∈ C (output);
c(x).Q ∈L where c ∈ C, x ∈ Var and Q ∈L (input);

[M(t)= 0].Q where M ∈ QPM, t is a qubit term, and Q ∈L (match);
(Q1|Q2) where Q1, Q2 ∈L (parallel composition);
!qQ where Q ∈L and q ∈ q (bounded replication).
Most of the (local) process terms are intuitive. The output term c⟨M(qB')⟩ means that the output of machine M, which received the finite set of qubits qB' as input, is sent through channel c. The input term c(x).Q means that a set of qubits is going to be received on c, and upon reception, x takes the value of the received qubits.
After fixing the security parameter η, we can get rid of replication by evaluating each process !qR as q(η) copies of R in parallel. Therefore, we always assume that a process term has no replication. Now, as state before, a protocol is constituted by a set o agents running in parallel, therefore the global language (or protocol language) is quite simple:
Definition 2.4 The language of global processes G over a set of agents A is defined inductively as follows:
0 ∈G (global termination);
P (a : Q) ∈ G where P ∈ G, a ∈ A does not occur in P , and Q ∈ L 
(global parallel composition).
The following example uses the process language to describe the RSA cryptanalysis using Shor’s algorithm.
Example 2.5 [Shor’s based RSA cryptanalysis] Let p, q be primes (with η length binary expansion), and e, d integers such that ed ≡ 1 mod φ(pq). Alice is a simple process A that knows some message w and outputs we mod pq, where e is the public key of Bob. This dummy process can be presented as
(a : A(w)) := (a : g⟨we	mod pq⟩).
Bob receives x and computes xd mod pq. This procedure can be modelled by the following process:
(b : B) := (b : g(x).(l⟨xd	mod pq⟩|l(y).0)).
Therefore the RSA protocol is given by the process (a : A(w))  (b : B). Fi- nally, we can write the “attacking” process, Eve. She factorises pq, inverts e mod φ(pq) (thus, allowing her to find d), and intercepts the message sent by Alice (on channel g). We write this process as follows:
(c : l1⟨Shor(pq)⟩|l1(y).l2⟨Inv(y, e)⟩|g(x).l2(z).(l3⟨xz	mod pq⟩|l3(w).0)).

Semantics
In order to define the semantics of a local process we need to introduce the notion of local configuration. A local conﬁguration or agent conﬁguration is a triple (|ψ⟩, qBa, Q) where |ψ⟩ ∈ H, qBa ⊆ qB is a countable, recursive enumerable set and Q ∈ L. The first element of the local configuration is the global state of the protocol, the second element is the set of qubits the agent possesses and the last element is the local process term.
The semantics of a local process is a probabilistic transition system where the transitions are defined by rules. We use (|ψ⟩, qBa, Q) →p (|ψ'⟩, qBa, Q') to state that, at global state |ψ⟩, when agent a possesses qubits qBa, the local process Q is reduced to Q' and global state is modified to |ψ'⟩ with probability p. It is also worthwhile to observe that we use the notation M(|ψ⟩, qBa, qB1) →p (|ψ'⟩, qB2) to denote that the execution of the QRM M, operating on qBa (that is, using the recursive enumeration of qBa to re- index the position of the qubits), and receiving as input qB1, outputs qB2 and modifies the global state |ψ⟩ to |ψ'⟩ with probability p. For the case of local processes, the sets qB1 and qB2 are irrelevant, because the qubits owned by the agent remain the same when a local communication (LCom rule) is applied. Their functionality will be clear when we present the global rules.

M(|ψ⟩, qBa, qB1) →p (|ψ'⟩, qB2) qB1, qB2 ⊆ qBa  |qB2|≤ bw(l)(η) (LCom)
(|ψ⟩, qBa, l(x).Q|l⟨M(qB1)⟩) →p (|ψ'⟩, qBa, Qx	)
We also introduce the term M; Meas to denote the machine that, after ex- ecuting M performs a measurement on the computational basis of the output qubits of M. So a match corresponds to performing a measurement on the output qubits of M and checking whether the result is the 0 word.


(M; Meas)(|ψ⟩, qBa, qB1) →p (|ψ'⟩, qB2)	|ψ'⟩|qB2 = |0⟩


(|ψ⟩, qBa, [M(qB1)= 0].Q) →p (|ψ'⟩, qBa, Q)
(M; Meas)(|ψ⟩, qBa, qB1) →p (|ψ'⟩, qB2)	|ψ'⟩|qB2 /= |0⟩
(|ψ⟩, qBa, [M(qB1)= 0].Q) →p (|ψ'⟩, qBa, 0) The remaining rules are self-explanatory.
(MatchT) (Match⊥)



(|ψ⟩, qBa,P ) →p (|ψ'⟩, qBa,P ')
(|ψ⟩, qBa,P |Q) →p (|ψ'⟩, qBa,P '|Q)
(|ψ⟩, qBa, Q) →p (|ψ'⟩, qBa, Q')
(|ψ⟩, qBa,P |Q) →p (|ψ'⟩, qBa,P |Q')
(LLPar) (LRPar)

We proceed by presenting the global rules. A global conﬁguration is a triple (|ψ⟩, qB,P ) where |ψ⟩ ∈ H, qB = {qBa}a∈A is a partition of qB indexed by the set of agents A (where each qBa is countable and r.e.) and P ∈ G. The semantics of a global process is defined by the following rules:


(|ψ⟩, qBa, Q) →p (|ψ'⟩, qBa, Q') (|ψ⟩, qB, (a : Q)) →p (|ψ'⟩, qB, (a : Q))
(LtoG)



M(|ψ⟩, qBb, qB1) →p (|ψ'⟩, qB2)  qB1, qB2 ⊆ qBb  |qB2|≤ bw(g)(η)
(GCom)



where qB' = {qBa' }a∈A, qBa'
for all c /= a, b.
= qBa ∪ qB2, qBb'
= qBb \ qB2, and qBc'
= qBc



(|ψ⟩, qB, P1) →p (|ψ'⟩, qB', P1')
(GLPar)



(|ψ⟩, qB, P2) →p (|ψ'⟩, qB', P2')
(GRPar).


All the rules are very simple to grasp. The only non trivial rule is global communication (GCom), that makes qubits to be exchanged from one agent to another, and therefore an adjustment is required in the qubit partition.
Process term reductions are non-deterministic, in the sense that several different reductions could be chosen at some step. In order to be possible to make a quantitative analysis, this reduction should be probabilistic. For the sake of simplicity, we assume a uniform scheduler, that is, the choice on any possible reduction is done with uniform probability over all possible non- deterministic reductions. We do not present in detail the scheduler model but, in principle, any probability distribution modelled by a QPM can be used to model the scheduler policy. Finally, note that by applying local and global rules, and assuming a uniform scheduler, one can define the many step reduction →∗p such that (|ψ1⟩, qB1, P1) →∗p (|ψn⟩, qBn, Pn), whenever:
(|ψ1⟩, qB1, P1) →p1 (|ψ2⟩, qB2, P2) →p2 ··· →pn−1 (|ψn⟩, qBn, Pn);
p =  p1  ×  p2  ×·· ·×  pn−1  where Ri is the number of possible non-deterministic

R1	R2
Rn−1

choices for (|ψi⟩, qBi, Pi) for all i ∈ {1,... ,n − 1};
(|ψn⟩, qBn, Pn) cannot be reduced any more.
The many step reduction takes into account the scheduler choice, by weighting each stochastic reduction pi with yet another probability  1 , where Ri is the
number of possible non-deterministic choices at step i.

Observations and observational equivalence
At the end of a protocol, each agent a ∈ A is allowed to measure a polynomial (in η) number of qubits in qBa to extract information. We can always assume that these qubits are the first, say, r(η) qubits of qBa where r is a positive polynomial. Therefore, the many step reduction of a process term P induces a probability distribution on 2r(η), where 2r(η) is the set of all possible outcomes of r(η) qubits when measured over the computational basis (that is, 2r(η) is the set of all r(η)-long binary words).
Definition 2.6 Given a positive polynomial r and a global configuration (|ψ⟩, qB,P ), let
Γ(|ψ⟩,qB,P ) = {(|ψ'⟩, qB',P '): (|ψ⟩, qB,P ) →∗p (|ψ'⟩, qB',P ') and p > 0}.

We define the observation of an agent a to be the family of probability mea- sures
Oa = {(2r(η), 22r(η) , Pra	)}


where:
Pra


({w})= Σ
r	r(η)


pγ × |⟨w|ψγ⟩|;
η∈N

pγ is such that (|ψ⟩, qB,P ) →∗pγ γ;
|ψγ⟩ is the first component of γ;
|⟨w|ψγ⟩| is the probability of observing the r(η)-long binary word w by measuring the r(η) first qubits of qBa (qubits in possession of agent a) of
|ψγ⟩ in the computational basis.


Note that the summation used to compute Pra
({w}) is well defined, since

Γ(|ψ⟩,qB,P ) is finite. It is clear at this point,that an observation of an agent is
a random r(η)-long binary word, with distribution given by Pra	.
The notion of observational equivalence we adopt is based on computa- tional indistinguishability as usual in the security community [13]. First, we introduce the concept of context. The set of global contexts C is defined in- ductively as follows: [ ] ∈ C; C[ ] P and P C[ ] ∈ C provided that C[ ] ∈ C and P ∈ G. Given a context C[ ] and a global process P , the notation C[P ] means that we substitute the process P for the [ ] in C[ ].
Definition 2.7 Let P and P ' be process terms. We say that P is computa- tionally indistinguishable by agent a from P ' if and only if for every context C[ ], polynomials q and r, |ψ⟩ ∈ H, partition qB of qB, η sufficiently large



and binary word w ∈ 2r(η),

a r(η)


(w) − Pr'a

1
(w)|≤ 
q(η)



where Pra
is given by the observation of a for configuration (|ψ⟩, qB, C[P ])

and Pr'a
is given by the observation of a for configuration (|ψ⟩, qB, C[P ']).

In such case we write P  P '.
Two processes are computationally indistinguishable if they are indistin- guishable by contexts, that is, for any input (here modelled by |ψ⟩ and qB), there is no context which can distinguish, up to a negligible function, the outputs produced. The definition above extends the classical definition of computational indistinguishability to the quantum case, since processes can be modelled by quantum polynomial machines and therefore C[ ] induces the required distinguishing machine. A detailed proof of this result is out of the scope of this extended abstract.
In order to set up compositionality, the following result is of the utmost importance:
Proposition 2.8 Computational indistinguishability is a congruence relation with respect to the parallel primitive of G.
Proof. Both symmetry and reflexivity are trivial to check. Transitivity fol- lows by triangular inequality, and taking into account that 1 q(n) isa polyno- mial. Congruence on the global parallel operator follows by noticing that for any contexts C[] and C'[ ], C'[C[ ]] is also a context.	 

Emulation and Composition Theorem
One of the most successful ways for defining secure concurrent cryptographic tasks is via process emulation [1,2]. This definitional job boils down to the following: a process realizes a cryptographic task if and only if it emulates an ideal process that is known to realize such task. In this section, guided by the goal of defining secure functionalities, we detail the notion of emulation for the quantum process calculus defined in the previous section.
Let I be an ideal protocol that realizes (the honest part of) some secure protocol and P a process that implements the functionality specified by I. The overall goal is to show that P realizes, without flaws, (part of) the secure functionality specified by I. The goal is achieved if for any real adversary, say (a : A), the process P ||(a : A) is computationally indistinguishable by the adversary a from the process I||(a : B) for some ideal adversary (a : B),

where an ideal adversary is an adversary which cannot corrupt I and a real adversary is any local process for agent a. This property asserts that given a real adversary (a : A), agent a cannot distinguish the information leaked by P ||(a : A) from the information leaked by the well behaved process I||(a : B) for some ideal adversary (a : B), and therefore, we infer that P ||(a : A) is also well behaved. This discussion leads to the concept of emulation with respect to a set of real adversaries A and ideal adversaries B.
Definition 3.1 Let P and I be process terms and A and B sets of global processes where the only agent is the adversary a, then P emulates I with respect to A and B if and only if for all processes (a : A) ∈ A there exists a process (a : B) ∈B such that P ||(a : A)  I||(a : B). In such case we write

P ≡a
A,B
and B.
I and say that P is a secure implementation of I with respect to A

A desirable property of the emulation relation is the so called Composi- tion Theorem. This result was first discussed informally for the classical secure computation setting in [12], and states the following: if P is a secure imple- mentation of part I of an ideal protocol, R and J are two protocols which use the ideal protocol I as a component, and finally, R is a secure implementation

of J, then RI
should be a secure implementation of J. This result is captured

as follows:
Theorem 3.2 Let P, I be processes, R[ ] and J[ ] contexts and A, B sets of processes over agent a and C, D sets of processes over agent b. If R[I||(a :

B)] ≡b
C,D
J[I||(a : B)] for any (a : B) ∈ B and P ≡a
A,B
I then for any
b

adversary (a : A) ∈ A there exists (a : B) ∈ B such that R[Q||(a : A)] ≡
C,D
J[I||(a : B)].
Proof. Let (a : A) ∈ A and (a : B) ∈ B be such that P ||(a : A) I||(a : B).  Now choose some (b : C) ∈ C, clearly, R[Q||(a : A)]||(c : C)  R[I||(a : B)]||(c : C) since  is a congruence relation. Moreover, since R[I||(a : B)] ≡C,D J[I||(a : B)], there is a (b : D) ∈ D such that R[I|(a : B)]|C   J[I||(a : B)]||(b : D).  Finally, by transitivity of  , we have that R[Q||(a : A)]||(b : C)  J[I||(a : B)]||(b : D) and hence R[Q||(a : A)] ≡C,D J[I||(a : B)].	 
Observe that ideal protocols are constituted by a honest part I and an ideal adversary (a : B), and therefore are of the form I||(a : B). This justifies why R[I||(a : B)] was considered in the proposition above instead of R[I]. Moreover, adversaries for the functionality implemented by R and J might be different from those of I and Q, therefore, two pairs of sets of processes C, D and A, B are required to model two kinds of adversaries.

Quantum Zero-Knowledge Proofs
An interactive proof is a two party protocol, where one agent is called the prover and the other is called the veriﬁer. The main objective of the protocol is to let the prover convince the verifier of the validity of an assertion, however, this must be done in such a way that the prover cannot convince the verifier of the validity of some false assertion.
Any interactive proof system fulfills two properties: completeness and soundness. Completeness states that if the assertion the prover wants to convince the verifier is true, then the verifier should be convinced with prob- ability one. On the other hand, soundness is fulfilled if the verifier cannot be convinced, up to a negligible probability, of a false assertion. Therefore, completeness and soundness allow the verifier to check whether the assertion of the prover is true or false.
Zero-knowledge is a property of the prover (strategy). Consider the fol- lowing informal notion of (quantum) computational zero-knowledge strategy, which corresponds to the straightforward lifting to the quantum setting of the classical version:
Definition 4.1 A prover strategy S is said to be quantum computational zero-knowledge over a set L if and only if for every quantum polynomial-time verifier strategy, V there exists quantum polynomial-time algorithm M such that (S, V )(l) is (quantum) computationally indistinguishable from M(l) for all l ∈ L, where (S, V ) denotes the output of the interaction between S and V .
The main application of zero-knowledge proof protocols in the crypto- graphic setting is in the context of a user U that has a secret and is supposed to perform some steps, depending on the secret. The problem is how can other users assure that U has carried out the correct steps without U disclosing its secret. Zero-knowledge proof protocols (ZKP) can be used to satisfy these conflicting requirements.
Zero-knowledge essentially embodies that the verifier cannot gain more knowledge when interacting with the prover than by running alone a quantum polynomial time program (using the same input in both cases). That is, running a the verifier in parallel with the prover should be indistinguishable of some quantum polynomial time program.
Actually, the notion of (quantum computational) zero-knowledge proofs can be captured through emulation very easily. Assuming that a proof strategy S(x) and verifier V (x) are modelled as terms of the process algebra, it is actually possible to model the interaction between p and v by the process (p : S)||(v : V ). Denote by Lv(l) the set of all process terms for the verifier

(v : V )x, that is, any process term (v : V ) where the free variable x was replaced by the binary word l. We have the following characterization:
Proposition 4.2 A process term (p : S) denoting a proof strategy is com-

putational zero-knowledge for L if and only if (p : S)x
≡v v
v	0, for all

l ∈ L.
l	L (l),L (l)


Proof (Sketch): Notice that the ZKP resumes to impose that for all (v : V )x there is a process (v : V ')x such that (p : S)x||(v : V )x  0||(v : V ')x. Since the
l	l	l	l
semantics of a local process can be modelled by a QPM, and moreover 0||(v :
V ')x can model any QPM, the characterization proposed in this proposition is equivalent to Definition 4.1.	 

So, a process (p : S) models a quantum zero-knowledge strategy if, from the point of view of the verifier, it is impossible to distinguish the final result of the interaction with (p : S) from the interaction with the 0 process. A clear corollary of Theorem 3.2 is that, quantum zero-knowledge is compositional.
It is simple to adapt the emulation approach to several other quantum security properties, like quantum secure computation, authentication and so on.


Conclusions
The contributions of this paper are multiple. First, we introduced a process algebra for specifying and reasoning about (quantum) security protocols. To restrict the computation power of the agents to quantum polynomial-time, we introduced the logarithm cost quantum random access machine, and incor- porated it in the process language. Due to the special aspects of quantum information, qubits were assumed to be partitioned among agents, and the (quantum) computation of an agent was restricted to its own qubits.
Second, we defined observational equivalence and quantum computational indistinguishability for the process algebra at hand, and showed that the latter is a congruence relation. Moreover, we obtained a simple corollary of this result: security properties defined via emulation are compositional.
Finally, we illustrated the definition of a security property via emulation with the concept of quantum zero-knowledge. It is however straightforward to adapt this approach to several other quantum security properties, like quan- tum secure computation.

Acknowledgement
The authors wish to express their gratitude to the regular participants in the QCI Seminar at CLC, specially to Am´ılcar Sernadas and Joa˜o Rasga, who gave very useful feedback.

References
Abadi, M. and A. D. Gordon, A calculus for cryptographic protocols: The Spi Calculus, Information and Computation 148 (1999), pp. 1–70, full version available as SRC Research Report 149, January 1998.
Canetti, R., Universally composable security: A new paradigm for cryptographic protocols, in: 42nd IEEE Symposium on Foundations of Computer Science (FOCS) (2001), pp. 136–145, full version available at IACR ePrint Archive, Report 2000/067.
Cohen-Tannoudji, C., B. Diu and F. Lalo¨e, “Quantum Mechanics,” John Wiley, 1977.
Cook, S. A. and R. A. Reckhow, Time bounded random access machines, Journal of Computer and System Sciences 7 (1973), pp. 354–375.
Gay, S. J. and R. Nagarajan, Communicating quantum processes, in: J. Palsberg and M. Abadi, editors, Proceedings of the 32nd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (POPL) (2005), pp. 145–157.
Knill, E., Conventions for quantum pseudocode, Technical Report LAUR-96-2724, Los Alamos National Laboratory (1996).
Lincoln, P., J. Mitchell, M. Mitchell and A. Scedrov, A probabilistic polynomial-time framework for protocol analysis, in: M. Reiter, editor, Proceedings of the 5th ACM Conference on Computer and Communications Security (CCS) (1998), pp. 112–121.
Martins, A. M., P. Mateus and A. Sernadas, Minimization of quantum automata, Technical report, CLC, Department of Mathematics, Instituto Superior T´ecnico, 1049-001 Lisboa, Portugal (2005), submitted for publication.
Mateus, P., J. C. Mitchell and A. Scedrov, Composition of cryptographic protocols in a probabilistic polynomial-time process calculus, in: R. Amadio and D. Lugiez, editors, CONCUR 2003 - Concurrency Theory, Lecture Notes in Computer Science 2761 (2003), pp. 327–349.
Mateus, P. and A. Sernadas, Reasoning about quantum systems, in: J. J. Alferes and J. A. Leite, editors, Proceedings of the 9th European Conference on Logics in Artiﬁcial Intelligence, Lecture Notes in Artificial Intelligence 3229 (2004), pp. 239–251.
Mateus,	P.	and	A.	Sernadas,	Weakly complete axiomatization of exogenous quantum propositional logic, Technical report, CLC, Department of Mathematics, Instituto Superior T´ecnico, 1049-001 Lisboa, Portugal (2005), submitted for publication. arXiv:math.LO/0503453.
Micali, S. and P. Rogaway, Secure computation, in: J. Feigenbaum, editor, Advances in Cryptology - CRYPTO ’91, Lecture Notes in Computer Science 576 (1991), pp. 392–404.
Mitchell, J. C., A. Ramanathan, A. Scedrov and V. Teague, A probabilistic polynomial- time calculus for analysis of cryptographic protocols (preliminary report), Electronic Notes in Theoretical Computer Science 45 (2001), pp. 1–31.
Yao, A. C., Theory and applications of trapdoor functions, in: 23rd IEEE Symposium on Foundations of Computer Science (FOCS) (1982), pp. 80–91.
