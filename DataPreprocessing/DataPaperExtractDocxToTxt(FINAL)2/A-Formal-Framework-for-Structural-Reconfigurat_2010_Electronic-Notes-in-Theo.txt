

Electronic Notes in Theoretical Computer Science 263 (2010) 95–110
www.elsevier.com/locate/entcs

A Formal Framework for Structural Reconfiguration of Components under Behavioural Adaptation
Antonio Cansado, Carlos Canal, Gwen Salau¨n, and Javier Cubo

Department of Computer Science, University of Ma´laga Campus de Teatinos, 29071, Ma´laga, Spain
Emails: {acansado,canal,salaun,cubo}@lcc.uma.es


Abstract
A major asset of modern systems is to dynamically reconfigure systems to cope with failures or component updates. Nevertheless, designing such systems with off-the-shelf components is hardly feasible: components are black-boxes that can only interact with others on compatible interfaces. Part of the problem is solved through Software Adaptation techniques, which compensates mismatches between interfaces. Our approach aims at using results of Software Adaptation in order to also provide reconfiguration capabilities to black-box components.
This paper provides two contributions: (i) a formal framework that unifies behavioural adaptation and structural reconfiguration of components; this is used for statically reasoning whether it is possible to reconfigure a system. And (ii), two cases of reconfiguration in a client/server system in which the server is substituted by another one with a different behavioural interface, and the system keeps on working transparently from the client’s point of view.
Keywords: Components, reconfiguration, behavioural adaptation, formal methods

Introduction
The success of Component-Based Software Development comes from creating com- plex systems by assembling smaller, simpler components. Nevertheless, building systems based on off-the-shelf components is difficult because components must communicate on compatible interfaces. It is even more difficult when the system must be able to reconfigure because components must provide reconfiguration ca- pabilities. Here, we understand by reconfiguration the capacity of changing the component behaviour and/or component implementation at runtime [15]. For ex- ample, we are interested in upgrading a component, substituting a component by another, adding new components to a running system, and so on.
In general, components are black-box modules of software that come with be- havioural specifications of their interfaces. Therefore, there is no access to the source

1571-0661 © 2010 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2010.05.006

code of components, but it is possible to use tool-assisted techniques to analyse the behaviour of a component assembly [5,8]. Some applications of this analysis are used in Software Adaptation [24] to work out behavioural mismatches in the com- ponents’ interfaces. In [19], an adaptation contract defines rules on how mismatches can be worked out and a tool generates an adaptor that orchestrates the system execution and compensates incompatibilities existing in interfaces.
On the other hand, there is little support to analyse whether a reconfiguration is safe. Enabling system reconfiguration requires designers to define (i) when a component can be reconfigured, (ii) which kind of reconfiguration is supported by the component, and (iii) which kind of properties the reconfiguration holds. For example, ensuring that some parts of the system can be reconfigured without sys- tem disruption. Our approach aims at providing a formal framework that helps answering these questions.
There are several related approaches in the literature. SOFA 2.0 [8] proposes reconﬁguration patterns in order to avoid uncontrolled reconfigurations which lead to errors at runtime. This allows adding and removing components at runtime, passing references to components, etc., under predefined structural patterns. There are other more general approaches that deal with distributed systems and software architectures [12,13], graph transformation [1,23] or metamodelling [11].
Our goal is to reconfigure components that have not been designed with recon- figuration capabilities in mind. Moreover, we target reconfiguration of components that may be involved in an ongoing transaction without stopping the system. This fits in a context where reconfiguration may be triggered at any moment and a component must be substituted at runtime.
Since substituting a component usually requires finding a perfect match, re- configuration is usually limited to instances (or subtypes) of the same component. Our approach is to exploit behavioural adaptation to further allow reconfiguration. That is, we target reconfiguration scenarios in which both the former and the new component need some adaptation in order to allow substitution. We build on the basis that components are provided with behavioural interfaces and the composi- tion with adaptation contracts. Then, we show that in some cases the information found in the adaptation contract can be used to endow black-box components with reconfiguration capabilities.
This paper’s contributions are: (i) we present a formal model that includes behavioural adaptation and structural reconfiguration of components. With this framework it is possible to verify properties of the complete system, including those involving reconfiguration of a component by another one with a different behavioural interface. And (ii), we present two examples of reconfiguration in which a server is substituted by another one with a different behavioural interfaces. We also show how can we build a fault-tolerant system by constraining the system’s behaviour.
This paper is structured as follows: Firstly, Section 2 provides some background on formalisms that will be used throughout the paper. Then Section 3 introduces a client/server system that is used as running example. Section 4 provides the formal model that allows structural reconfiguration and behavioural adaptation. Section 5

provides applications of our approach for designing reconfigurable systems based on (non-reconfigurable) black-box components. Then, Section 6 presents related works on reconfiguration and behavioural adaptation and Section 7 concludes this paper.
Background
This work builds on previous work on hierarchical behavioural models [5] and Soft- ware Adaptation [9]. We recall in this section the main definitions that are used in this paper.
Networks of Synchronised Automata
We assume that component interfaces are equipped both with a signature (set of required and provided operations), and a protocol. We model the behaviour of a component as a Labelled Transition System (LTS). The LTS transitions encode the actions that a component can perform in a given state. In the following definitions, we frequently use indexed vectors: we note x˜I the vector ⟨..., xi , ...⟩ with i ∈ I , where I is a countable set.
Definition 2.1 [LTS]. A Labelled Transition System (LTS) is a tuple ⟨S, s0, L, →⟩
where S is the set of states, s0 ∈ S is the initial state, L is the set of labels, → is
the set of transitions : →⊆ S × L × S . We write s −→α  s' for (s, α, s') ∈ →.
Communication between components are represented using actions relative to the emission and reception of messages corresponding to operation calls, or internal actions performed by a component. Therefore, in our model, a label is either the internal action τ or a tuple (M , D ) where M is the message name and D stands for the communication direction (! for emission, and ? for reception).
Definition 2.2 [Network of LTSs]. Let Act be an action set. A Net is a tuple
⟨AG, J , O˜J , T⟩ where AG ⊆ Act is a set of global actions, J is a countable set of argument indexes, each index j ∈ J is called a hole. Oj is the sort of the hole j with Oj ⊂ Act. The transducer T is an LTS (ST , s0T , LT , →T ), and LT = {−→v =
⟨ag .α˜I ⟩, ag ∈ AG, I ⊆ J ∧ ∀ i ∈ I , αi ∈ Oi }
Synchronisation between components is specified using Nets [5]. Nets are in- spired by synchronisation vectors [2], that we use to synchronise a number of pro- cesses and can describe dynamic configurations of processes, in which the possible
synchronisations change with the state of the Net; they are transducers [18].
A transducer in the Net is encoded as an LTS whose labels are synchronisation vectors (−→v ), each one describing a particular synchronisation between the actions (α˜I ) of different argument processes; the result of this synchronisation is seen as a global action ag . Each state of the transducer T corresponds to a given config-
uration of the network in which a given set of synchronisations is possible. Some of those synchronisations can trigger a change of state in the transducer leading to a new configuration of the network; that is, it encodes a dynamic change on the configuration of the system.

Definition 2.3 [Sort]. The Sort is the set of actions that can be observed from outside the automaton. It is determined by its top-level node, L for an LTS, and AG for a Net:

Sort(⟨S, s0, L, →⟩) = L	Sort(⟨AG, J , O˜J , T⟩) = AG

A Net is a generalised parallel operator. Complex systems are built by combining LTSs in a hierarchical manner using Nets at each level. There is a natural typing compatibility constraint for this construction, in term of the sorts of formal and actual parameters. The standard compatibility relation is Sort inclusion: a system Sys can be used as an actual argument of a Net at position j only if it agrees with the sort of the hole Oj , i.e. Sort(Sys) ⊆ Oj .


Speciﬁcation of Adaptation Contracts
While building a new system by reusing existing components, behavioural interfaces do not always fit one another, and these interoperability issues have to be faced and worked out. Mismatches may be caused by different message names, a message without counterpart (or with several ones) in the partner, etc. The presence of mismatch results in a deadlocking execution of several components [3,10].
Adaptors can be automatically generated based on an abstract description of how mismatch situations can be solved. This is given by an adaptation contract.
In this paper, the adaptation contract AC between components is specified us- ing vectors [9]. Each action appearing in one vector is executed by one component and the overall result corresponds to a synchronisation between all the involved components. A vector may involve any number of components and does not re- quire interactions to occur on the same names of actions. Moreover, a vector may synchronise actions performed by sub-processes in a hierarchical fashion.
For example, a vector v = ⟨C 1 : on!, C 2 : activate?⟩ denotes that the action on! performed by component C 1 corresponds to action activate? performed by compo- nent C 2. This does not mean that both actions have to take place simultaneously, nor one action just after the other; the adaptor will take into account their respec- tive behaviour as specified in their LTS, accommodating the reception and sending of actions to the points in which the components are able to perform them (Fig. 1).


C1	Adaptor	C2

Fig. 1. Components C 1 and C 2 connected through an adaptor.

Running Example
This section presents the running example used in the following sections. It consists of a client/server system in which the server may be substituted by an alternative server component. This can be needed in case of server failure, or simply for a change in the client’s context or network connection that made unreachable the original server. We suppose none of the components have been designed with reconfiguration capabilities.
The client wants to buy books and magazines as shown in its behavioural inter- face in Fig. 2(a). The two servers A and B have behavioural interfaces depicted in Figs. 2(c) and 3(b) respectively. Server A can sell only one book per transaction 1 ; on the other hand, server B can sell a bounded number of books and magazines.
Initially, the client is connected to server A; we shall call this configuration cA. The client and the server agree on an adaptation contract ACC ,A (see Fig. 2(b)). Naturally, under configuration cA the client can only buy at most one book in each transaction but it is not allowed to buy magazines because this is not supported by server A. The latter is implicitly defined in the adaptation contract (Fig. 2(b)) because there is no vector allowing the client to perform the action buyMagazine!. Finally, server A does not send the acknowledgement ack ? (see v4 in Fig. 2(b)) expected by the client; this must also be worked out by the adaptor.









v1 = ⟨C : login!, A : user ?⟩
v2 = ⟨C : passwd !, A : passwd ?⟩

PASSWD !
v3 = ⟨C : buyBook !, A : buy ?⟩

v4 = ⟨C : ack ?, A : є⟩
v5 = ⟨C : logout !, A : disconnect ?⟩




LTS of Client C
Adaptation Contract ACC ,A
LTS of Server A


Fig. 2. Configuration cA.

In an alternative configuration cB the client is connected to server B whose protocol is depicted in Fig. 3(b). Similarly, the client and the server agree on an adaptation contract ACC ,B (see Fig. 3(a)). Under configuration cB , the client can buy a bounded number of books and magazines. In Fig. 3(a), we see that vector v5 allows the client to buy magazines. Moreover, server B sends a different acknowledgement for each product (see v4 and v6 in Fig. 3(a)).

1 A transaction starts in the LTS’s initial state and ends in the final one. The definition of LTS in Section 2.1 does not include final states, though one can understand as final state a state with no outgoing transitions.

We shall study reconfiguration from cA to cB which substitutes A by B . It is worth noting that A and B do not have the same behavioural interfaces. Not only B provides additional functionality w.r.t. A, but also B does not have the same names for the actions (and potentially the ordering of actions may be different as well). For instance, v1 of ACC ,A (see Fig. 2(b)) says that the login! action of the client relates to user ? of server A. On the other hand, this login! action must be related to connect ? of server B (see v1 of ACC ,B in Fig. 3(a)).






0

CONNECT ?


v1 = ⟨C : login!, B : connect ?⟩
v2 = ⟨C : passwd !, B : pwd ?⟩
v3 = ⟨C : buyBook !, B : buyBook ?⟩
v4 = ⟨C : ack ?, B : bookOk !⟩
v5 = ⟨C : buyMagazine!, B : buyMagazine?⟩ v6 = ⟨C : ack ?, B : magazineOk !⟩
v7 = ⟨C : logout !, B : disconnect ?⟩

1

PWD ? 2
DISCONNECT ? BUYBOOK ? BOOKOK !

3










BUYMAGAZINE ? MAGAZINEOK !

4



Adaptation Contract ACC ,B
LTS of Server B


Fig. 3. Configuration cB .


Formal Model
This section provides the formal model that enables reconfiguration and behavioural adaptation. We define a reconﬁguration contract to determine how the system may evolve in terms of structural changes. Then, we provide a formal model based on Nets for this kind of systems.

Reconﬁguration Contract
A system architecture consists of a finite number of components. Each conﬁgura- tion is a subset of these components connected together by means of adaptation contracts.
Definition 4.1 [Configuration]. A configuration c = ⟨P, AC, S ٨⟩ is a static structural configuration of a system. P is an indexed set of components. AC is an adaptation contract of components in P . S ٨ is a set of reconﬁguration states defined upon P ; these are states in which reconfiguration is allowed.
Changing a configuration by another is what we call a reconfiguration. This is specified in a reconﬁguration contract which separates reconfiguration concerns from the business logic. Each configuration can be thought of a static system and the “dynamic” part is specified by a reconfiguration operation. The selection of reconfiguration states is left out-of-scope in this paper. We assume here that they

are given by the designer, though we show how some of them can be obtained in our examples.
Definition 4.2 [Reconfiguration Contract].  A reconfiguration contract R =
⟨C , c0, →R⟩ is defined as:
C is a set of static configurations, where ci ∈ C , i ∈ {0..n}, is a static configura- tion. c0 ∈ C is the initial configuration. →R⊆ C ×Rop ×C is a set of reconfiguration operations, with reconfiguration operation Rop ⊆ S ٨ × S ٨, S ٨ ∈ ci , S ٨ ∈ cj .
i	j	i	j
From the definition above, reconfiguration can take place in the middle of a trans- action, and the new configuration may have a new adaptation contract. This allows reconfiguring a component by another one that implements a different behavioural interface. Nevertheless, for guaranteeing consistency this can only happen at pre- defined states. A state of the source configuration (s٨) defines when a configuration can be reconfigured. On the other hand, a state of the target configuration (s٨) says what is the starting state in the target configuration to resume the execution.

Example
In the running example, there are two configurations:
cA = ⟨{C , A}, ACC ,A, S ٨ ⟩ and cB = ⟨{C , B}, ACC ,B , S ٨ ⟩.
A	B
The reconfiguration contract R = ⟨C , cA, →R⟩ is given by:
C = {cA, cB }, and →R= {cA −→r cB }, with r = (s٨ , s٨ ).
A  B
r must specify the pairs of reconﬁguration states on which reconfiguration can
be performed. Since both servers have different behavioural interfaces, it is not straight-forward to determine how reconfiguration can take place after a transaction between the client and the server has started. Therefore, in the simplest scenario
reconfiguration from cA to cB is only allowed at the initial states of the client and
the server. This is specified as a unique reconfiguration state s٨ ∈ S ٨, i ∈ {A, B} for

i
each configuration; more precisely, s٨ = {C : s0, A : s0} and s٨
i
= {C : s0, B : s0}.

A	B
In Section 5 we will study how other pairs of reconfiguration states —apart from the initial states here— can be obtained.

Building Verifyable Systems
This section shows how to build Nets for the reconfiguration contract above. We have previously defined the system and now we generate a behavioural model of the complete system that can be fed into model-checking tools. There are two benefits in this approach.
Firstly, is it easier to verify properties related to reconfiguration if the complete system is modelled. In our running example, we can prove that the client may only buy magazines if the system is reconfigured towards a configuration cB .
Secondly, a Net is close enough to the structure of a program that it should be possible to implement the Net in a component model framework such as Fractal [7]. This would provide us, at runtime, a component system with predictable behaviour under reconfiguration.

As the adaptor represents the interactions between the adapted components, we will use states of the adaptor to identify states in which reconfiguration will be applied. Let AP be the adaptor LTS generated by AC [10], we add a reconfiguration action rss ? for each s٨ ∈ S ٨. This action leaves the adaptor in same state, defined
i	i
as the state in which all components are in the state given by s٨.
Definition 4.3 [Network of a Configuration]. A configuration c = ⟨P, AC, S ٨⟩, defines a Net cNet = ⟨AG, J , O˜J , T⟩, as:
Let AP be the adaptor LTS generated by AC, with a reconfiguration action rss ? for each s٨ ∈ S ٨. Each a! ∈ Sort (pi ) defines an action v = {pi : a!, AP : a?} ∈ AG . Each a? ∈ Sort (pi ) defines an action v = {pi : a?, AP : a!} ∈ AG . Each reconfiguration action rss ? defines an action v = {AP : rss ?} ∈ AG . Each process
i	i
pi and AP is an argument of J , with Sort (pi ) ⊆ Opi and Sort (AP ) ⊆ OAP .
The Net transducer T is defined as: a unique state sT = s0T ∈ ST ; and a
transition sT −→v  sT for each v ∈ AG .
In the definition above, a Net closely represents a configuration; the root of the Net ’s tree is the synchronisation operator given by the Net’s transducer, and the Net ’s leaves are the components pi and AP . The transducer actions are synchroni- sation vectors that relate actions between pi and the adaptor; note that due to the adaptation process, these actions are exact dual operations. The transducer has additional transitions taking care of reconfiguration capabilities, though they are not used within a configuration.
We construct a system that allows reconfiguration between conﬁgurations based on the reconﬁguration contract and the construction of a network for a conﬁguration.
Definition 4.4 [Network of Reconfiguration Contract]. A R = ⟨C , cA, →R⟩
defines a Net RNet = ⟨AG, J , O˜J , T⟩, with:
Each configuration ci ∈ C defines a Net ciNet ∈ J . Each reconfiguration op- eration r defines a process Pr used as argument of J . This process will be in charge of initialising the target configuration. The global actions AG are defined upon the union of the global actions of each configuration, and the reconfiguration

transactions. Formally, AG = [ 
∀ci ∈C
Sort(ci

Net
)] ∪ {r : ci −→r
cj ∈→R, i /= j }.

The sorts of each configuration ci

Net
define O˜J , i.e. Sort(ci

Net
) = Oi . The Net

transducer T=(ST , s0T , LT , →T ) orchestrates the system execution. Each configu- ration Net ciNet is represented by a state si ∈ ST .
Actions within a configuration are transitions over the same configuration state,
i.e., there is a transition s ag s for each a ∈ Sort(c	)\  r .
For each reconfiguration operation ci −→r cj we add a reconfiguration state sr in
the transducer (see Fig. 4). In this state, only actions within Pr can be performed,
i.e., sr rα  sr where rα are actions in Pr . The reconfiguration starts with an action
rstart = rss ? that changes the transducer state from si to sr . Reconfiguration actions are performed (rα), and finally the system changes to a configuration cj in a state defined by r by performing the action rend = rss ?.


rα
ag ∈ ciNet	ag ∈ cjNet

Fig. 4. Transducer representing a reconfiguration from configuration ci to configuration cj .

The reconfiguration contract is mapped into a Net RNet . The transducer of RNet is an LTS that has each of the configurations as states, and transitions representing either a reconfiguration r or the allowance of a (non-reconfiguring) action ag within a configuration. Additionally, each of the configurations ci is mapped into a Net ciNet that is used as an argument of the RNet ’s holes. Hence, we build a tree of processes in which the root is RNet , the internal nodes are configurations, and leaves are LTSs of the components’ behaviour.
Reconfigurations operations eventually move the system from a configuration to another (see Fig. 4). The role of the state sr is to halt system execution and initialise the new configuration so that it starts at the target reconfiguration state.

Example
Back to the running example, the first step in creating the Net is to generate the adaptors AC ,A (Fig. 5(a)) and AC ,B (Fig. 5(b)) in the form of LTSs. This is done by the Compositor tool [14]. Based on the adaptation contracts, Compositor automatically generates an adaptor for each configuration that is guaranteed to orchestrate deadlock-free interactions between the client and a server.
The Net for cA is created as follows 2 :
rss ?
We add a reconfiguration action s٨ −−A−→ s٨ in the adaptor.
A	A
AG has two actions for each vector in ACC ,A, i.e., v1 = ⟨C : login!, A : user ?⟩ generates the actions v1! = ⟨C : login!, AC ,A : login?⟩ and v1? = ⟨AC ,A : user !, A : user ?⟩. AG has the action rss ? = ⟨AC ,A : rss ?⟩.
A	A
LTSs of the components and the adaptor are the Net’s holes: J = {C , A, AC ,A};
O˜J = {Sort (C ), Sort (A), Sort (AC ,A)}.

T has a unique state s
, with s	ag  s , a ∈ A .

T	T −→ T	g	G
No initialisation of server B is needed after the reconfiguration because the system can only be reconfigured in its initial state. Therefore, Pr is a dummy automaton with a unique state and no transition.
Finally, we create RNet :  the transducer has states sA, sB , srA,B .  Non-

reconfiguration transitions are: sA
a
−→ A
, ag
∈ cANet
and sB
a
−→ B
, ag
∈ cBNet .



2 For the sake of size, the Net of cB is created in a similar way.













0

C:LOGIN ?

1	6

B:CONNECT !	B:BUYMAGAZINE !

2	9

C:PASSWD ?	B:MAGAZINEOK ? C:BUYMAGAZINE ?

3	10

B:PWD ! C:ACK !


4
?
C:BUYBOOK ?




C:LOGOUT ?


5	7


B:BUYBOOK !

C:ACK !

B:DISCONNECT !


8

B:BOOKOK ?

11



Adaptor AC ,A
Adaptor AC ,B

Fig. 5. Adaptors



rss ?
Reconfiguration transitions are: sA −−A−→ sr


A,B
and sr


A,B
rss ?
−−B−→ sB .

In this example, reconfiguration is only allowed in the initial state. Nevertheless, our goal is to allow reconfiguration in arbitrary states in which the client and the server have already started a transaction. This is the goal of Section 5.

Contract-Aware Reconfiguration
We have shown in the previous section that the running example can be reconfigured at the initial stage of the transaction. Nevertheless, more interesting are scenarios in which reconfiguration can take place at arbitrary stages of the transaction. With that purpose, Section 5.1 defines a test that determines whether it is possible to reconfigure the component system at a certain stage of the transaction. Afterwards, Section 5.2 studies how to design a fault-tolerant system in which reconfiguration can take place between two different configurations back and forth.

History-Aware Reconﬁguration
Now, suppose the previous example needs to be reconfigured during an ongoing transaction between C and A. This would be the case where a client connects to the

server A, logs in, and before disconnecting, A is substituted by B . Unfortunately, A and B do not provide such reconfiguration capabilities and it is not possible to substitute A by B without behavioural adaptation because they have different behavioural interfaces.
The client must not abort the ongoing transaction t . Therefore, if the execution trace of C (σC from now on) is valid in the new configuration cB , then C could have been interacting with B from the very beginning. We proceed by initialising B under this assumption, i.e., finding an execution trace σB such that the actions performed by C in t are feasible in cB when B has performed σB .
As the adaptor orchestrates the execution between the two parties, we can use the state of the adaptor as the global system state.  We say that t = ⟨σp1 , σp2 ⟩ ~s Ap1,p2  when actions performed by P1 in σp1 and P2 in σp2 lead
the adaptor Ap1,p2 to state s.
Definition 5.1 [Trace Compliant]. Let t ~s AC ,S , with t = ⟨σC , σS ⟩ where σC
and σS are traces of C and S respectively.
S' is trace compliant to S given t if there exists t ' = ⟨σC , σS' ⟩ ~s' AC ,S' .
Not all components are trace compliant given t . However, if t ' exists, the new configuration cB can reach a (deadlock-free) state s٨ that simulates the execution of cA when the latter reaches the state s٨. Therefore, it is possible to build a recon- figurable system that starts in a configuration cA and may reconfigure towards a configuration cB when the client has performed the actions in t . This reconfigura- tion does not affect the client in the sense it does not need to abort t nor to rollback. In fact, a new transaction t ' is created such that the client continues working on transparently, though it is warned that the adaptation contract has changed; even so, its previous actions are valid and considered in the running transaction (t').
Trace compliance assures that the client’s history is unchanged, though it says nothing about future actions. Therefore, it is possible to provide new functionality in the new configuration while maintaining consistency.

Example
In the running example, the login phase is similar in both configurations from the client’s point of view. Therefore, it is easy to notice that both configurations are trace compliant given σC = {login!; passwd !}. This allows us to define a recon- figuration from the state s٨ = {C : s2, A : s2} to the state s٨ = {C : s2, B : s2}. The
0	1
initialisation required by B is the result of finding t ', i.e., σB = {connect ?; pwd ?} (this specifies Pr ). Therefore, meanwhile the client is logged in, the server can be
substituted at runtime by another component with a different behavioural interface. Then, the client may log in server A, and after a reconfiguration to configuration cB the client can buy several books and magazines.
On the other hand, cB is not trace compliant to cA given an arbitrary trace σC . For example, if the client has bought a magazine (or several books) in σC , then this trace cannot be simulated in cA because A only supports transactions in which at one book is sold. Still, cB is trace compliant to cA for traces that do not include

buying several books or at least one magazine; we shall explore this scenario in Section 5.2.

Fault-Tolerant System
The previous example allowed reconfiguring the system from cA to cB , though reconfiguring the system from cB to cA is only possible on some of the traces per- formed by the client. We investigate here how to design a fault-tolerant system by constraining the behaviour of the previous system. We will guarantee that server A can always be substituted by B (and B by A likewise) transparently from the client’s point of view.
One way of ensuring two components are mutually substitutable is by means of a bisimulation equivalence [22]. A more relaxed equivalence takes into account only the behaviour of the servers given the constraints imposed by the environment. In our case, these constraints are summarised within the adaptors because they express the allowed behaviour performed by both parties.
An even more relaxed condition checks whether the adaptors AC ,A and AC ,B
are bisimilar 3 from the client’s point of view. There are two options: either to ignore the actions performed by the servers, or to map the actions of one server into another (through yet another adaptation contract). Both solutions allow servers to implement different behavioural interfaces; we have chosen to explore the former.
Even under this relaxed condition it is difficult to find two servers that provide clients with the same functionalities. More likely is that some of the actions allowed to the client are common in both configurations. Hence, if the system were to work on this reduced behaviour it would be possible to provide reconfiguration capabilities as shown in Section 5.1. Our solution is to create new adaptors that are equivalent from the client’s point of view. That is:

⎧⎨ ∀ t = ⟨σC , σA⟩ ~ss AR
, ∃ t ' = ⟨σC , σB ⟩ ~ss AR

⎩ ∀ t ' = ⟨σC , σB ⟩ ~ss AR
, ∃ t = ⟨σC , σA⟩ ~ss AR

These are adaptors that constrain the behaviours of the client and the servers such that we can perform reconfiguration at any moment (from the client’s point of view). They are found as follows:
Compute C R = Product ((Hide(LA) in AC ,A), (Hide(LB ) in AC ,B )). If C R is deadlock-free, proceed.

Compute AR
= Product (C R, AC ,A) and AR
= Product (C R, AC ,B ).








3 We leave open which kind of bisimulation is used; for example, strong, weak, or branching bisimulation.

Product synchronises matching labels of both parties into a new synchronised action. Hide makes a set of la- bels L be internal actions (τ ).
C R finds the behaviour that can be performed by the client in both adaptors. This is done by hiding the actions performed by the servers (LA and LB ) and building the synchronised product. If there are no traces that can be performed by the client in both adaptors, there is a dead- lock in C R and it is not possible to build a fault-tolerant system. Otherwise, using C R , we constrain each adaptor to this client behaviour which yields, by construction, trace

compliant AR
and AR
given any transaction.


Example
In the running example, the constrained system allows the client to buy at most one book in each transaction. In

fact, we find that AR
≡ AC ,A but AR
allows only the

traces in which the client buys a book or nothing at all (see Fig. on the right). In this scenario, either server A or B suits the client’s actions, and thus reconfiguration is
possible.
Any σC feasible in one of these new adaptors is feasible in the other. Therefore, we can apply the procedure from Section 5.1 for finding pairs of states on which reconfigura- tion can be applied. We build this way a system that can be reconfigured from one configuration to the other back and forth.

Related Work
Dynamic reconfiguration [15] is not a new topic and many solutions have al- ready been proposed in the context of distributed systems and software architec- tures [12,13], graph transformation [1,23], software adaptation [20,19], metamod- elling [11], or reconfiguration patterns [8]. On the other hand, Software Adaptation is a recent solution to build component-based systems accessed and reused through their public interfaces. Adaptation is known as the only way to compose black-box components with mismatching interfaces. However, only few works have focused so far on the reconfiguration of systems whose correct execution is ensured using adaptor components. In the rest of this section, we focus on approaches that tackled reconfiguration aspects for systems developed using adaptation techniques.
First of all, in [20], the authors present some issues raised while dynamically reconfiguring behavioural adaptors. In particular, they present an example in which a pair of reconfigurations is successively applied to an adaptor due to the upgrade of a component in which some actions have been first removed and next added. No

solution is proposed in this work to automate or support the adaptor reconfiguration when some changes occur in the system.
Most of the current adaptation proposals may be considered as global, since they proceed by computing global adaptors for closed systems made up of a predefined and fixed set of components. However, this is not satisfactory when the system
may evolve, with components entering or leaving it at any time, e.g., for pervasive
computing. To enable adaptation on such systems, an incremental approach should be considered, by which the adaptation is dynamically reconfigured depending on the components present in the system. One of the first attempts in this direction is [4], whose proposal for incremental software construction by means of refinement allows for simple signature adaptation. However, to our knowledge the only pro- posal addressing incremental adaptation at the behavioural level is [21,19]. In these papers, the authors present a solution to build step by step a system consisting of several components which need some adaptations. To do so, they propose some techniques to (i) generate an adaptor for each new component added to the system, and (ii) reconfigure the system (components and adaptors) when a component is removed.
Compared to [20,21,19], our goal is slightly different since we do not want to directly reconfigure adaptor behaviours, but we want to substitute both a compo- nent and its adaptor by another couple component-adaptor while preserving some properties of the system such as trace compliance.
Some recent approaches found in the literature [6,17,16] focus on existing pro- gramming languages and platforms, such as BPEL or SCA components, and suggest manual or at most semi-automated techniques for solving behavioural mismatch. In particular, the work presented in [16] deal with the monitoring and adaptation of BPEL services at run-time according to Quality of Services attributes. Their ap- proach also proposes replacement of partner services based on various strategies either syntactic or semantic. Although replaceability ideas presented in this paper are close to our reconfiguration problem, they mainly deal with QoS characteristics whereas our focus is on behavioural issues.

Conclusions
This paper has presented a novel framework that supports the design of reconfig- urable systems. The formal model defines reconfiguration as a transition from a (static) configuration to another. Each configuration specifies a component assem- bly with its own set of components and connections, and a reconﬁguration contract defines when the configuration can be reconfigured and which is the starting state in the new configuration in order to resume the execution.
We have integrated Software Adaptation in the framework in order to further enable reconfiguration. We have shown that, based on adaptation contracts, it is possible to substitute a component by another one that implements a different behavioural interface; this potentially includes mismatches in actions, ordering of actions, and functionality. Briefly, we build on the basis that for some cases it is

possible to find execution traces in which configurations are similar in some sense, and thus it is possible to simulate the execution of a system in another one with a different behavioural interface.
Perspectives. We have presented an initial step on reconfiguration of components
with mismatching behavioural interfaces. The framework is expressive and suitable for our needs and we have presented a case-study of runtime configuration. There are many open questions, though, that we wish to continue working on:
We have shown that in a simple setting it is possible to find system states in which it is safe to perform reconfiguration. Nevertheless, for more general scenarios finding correspondences between states based on trace compliance is not enough. We believe that it is necessary to refine what are the necessary properties the new configuration must hold. For example, by endowing a reconfiguration contract with invariants under the form of temporal properties.
An alternative is to augment component LTSs with sub-transactions. In our client/server example, the server would specify that a sub-transaction starts when buying a product and ends when the acknowledgement has been sent to the client.
Then, it would be possible to buy magazines from server B (which is not supported
by server A), and then substitute B by A.
We also plan to address other scenarios in which a component is substituted by a component assembly. For example, where the server is substituted by a component implemented by a front-end component and a back-end component. Our formal model can formalise the behaviour of such systems, though there are new challenges on how to simulate actions of the former configuration in the new one.
Finally, we plan to integrate this framework within a component model such as Fractal. We believe that the model built on Nets can be implemented in the runtime platform of Fractal in order to provide components with safe reconfiguration
capabilities.
Acknowledgement
This work has been partially supported by the project TIN2008-05932 funded by the Spanish Ministry of Science and Innovation, and project P06-TIC-02250 funded by the Andalusian local Government.

References
N. Aguirre and T. Maibaum. A Logical Basis for the Specification of Reconfigurable Component-Based Systems. In Proc. of FASE’03, volume 2621 of LNCS, pages 37–51. Springer, 2003.
A. Arnold. Finite transition systems. Semantics of communicating systems. Prentice-Hall, 1994.
M. Autili, P. Inverardi, A. Navarra, and M. Tivoli. SYNTHESIS: A Tool for Automatically Assembling Correct and Distributed Component-based Systems. In Proc. of ICSE’07, pages 784–787. IEEE Computer Society, 2007.
R. J. Back. Incremental Software Construction with Refinement Diagrams. Technical Report 660, Turku Center for Computer Science, 2005.
T. Barros, R. Ameur-Boulifa, A. Cansado, L. Henrio, and E. Madelaine. Behavioural models for distributed fractal components. Annals of Telecommunications, 64(1):25–43, 2009.


A. Brogi and R. Popescu. Automated Generation of BPEL Adapters. In Proc. of ICSOC’06, volume 4294 of Lecture Notes in Computer Science, pages 27–39. Springer, 2006.
E. Bruneton, T. Coupaye, M. Leclercq, V. Qu´ema, and J.-B. Stefani. The fractal component model and its support in java: Experiences with auto-adaptive and reconfigurable systems. Softw. Pract. Exper., 36(11-12):1257–1284, 2006.
T. Bureˇs, P. Hnetynka, and F. Pl´aˇsil. Sofa 2.0: Balancing advanced features in a hierarchical component model. In SERA ’06: Proceedings of the Fourth International Conference on Software Engineering Research, Management and Applications, pages 40–48, Washington, DC, USA, 2006. IEEE Computer Society.
J. C´amara, J. A. Martin, G. Salau¨n, J. Cubo, M. Ouederni, C. Canal, and E. Pimentel. Itaca: An integrated toolbox for the automatic composition and adaptation of web services. In Proc. of ICSE’09, pages 627–630. IEEE Computer Society, 2009.
C. Canal, P. Poizat, and G. Salau¨n. Model-Based Adaptation of Behavioural Mismatching Components.
IEEE Transactions on Software Engineering, 34(4):546–563, 2008.
A. Ketfi and N. Belkhatir. A Metamodel-Based Approach for the Dynamic Reconfiguration of Component-Based Software. In Proc. of ICSR’04, volume 3107 of LNCS, pages 264–273. Springer, 2004.
J. Kramer and J. Magee. The Evolving Philosophers Problem: Dynamic Change Management. IEEE Transactions on Software Engineering, 16(11):1293–1306, 1990.
J. Kramer and J. Magee. Analysing Dynamic Change in Distributed Software Architectures. IEE Proceedings - Software, 145(5):146–154, 1998.
R. Mateescu, P. Poizat, and G. Salau¨n. Adaptation of service protocols using process algebra and on-the-fly reduction techniques. In ICSOC ’08: Proceedings of the 6th International Conference on Service-Oriented Computing, pages 84–99, Berlin, Heidelberg, 2008. Springer-Verlag.
N. Medvidovic. ADLs and Dynamic Architecture Changes. In SIGSOFT 96 Workshop, pages 24–27. ACM, 1996.
O. Moser, F. Rosenberg, and S. Dustdar. Non-Intrusive Monitoring and Adaptation for WS-BPEL. In
Proc. of WWW’08, pages 815–824, 2008.
H. R. Motahari-Nezhad, B. Benatallah, A. Martens, F. Curbera, and F. Casati. Semi-Automated Adaptation of Service Interactions. In Proc. of WWW’07, pages 993–1002, 2007.
E. Najm, A. Lakas, A. Serouchni, E. Madelaine, and R. de Simone. ALTO: an interactive transformation tool for LOTOS and LOTOMATON. In Proc. of Lotosphere Workshop and Seminar, 1992.
P. Poizat and G. Salau¨n. Adaptation of Open Component-Based Systems. In Proc. of FMOODS’07, volume 4468, pages 141–156. Springer, 2007.
P. Poizat, G. Salau¨n, and M. Tivoli. On Dynamic Reconfiguration of Behavioural Adaptation. In Proc. of WCAT’06, pages 61–69, 2006.
P. Poizat, G. Salau¨n, and M. Tivoli. An Adaptation-based Approach to Incrementally Build Component Systems. In Proc. of FACS’06, volume 182, pages 39–55, 2007.
I. Cˇern´a, P. Vaˇrekov´a, and B. Zimmerova. Component substitutability via equivalencies of component- interaction automata. Electronic Notes in Theoretical Computer Science (ENTCS) series, 182:39–55, 2007.
M. Wermelinger, A. Lopes, and J. L. Fiadeiro. A Graph Based Architectural (Re)configuration Language. In Proc. of ESEC / SIGSOFT FSE 2001, pages 21–32. ACM, 2001.
D. M. Yellin and R. E. Strom. Protocol Specifications and Components Adaptors. ACM Transactions on Programming Languages and Systems, 19(2):292–333, 1997.
