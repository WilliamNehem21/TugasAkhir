Electronic Notes in Theoretical Computer Science 40 (2001)
URL: http://www.elsevier.nl/locate/entcs/volume40.html  44 pages


Typed Multiset Rewriting Speciﬁcations of Security Protocols

Iliano Cervesato 1 ,2
Advanced Engineering and Sciences Division ITT Industries, Inc.
Alexandria, VA 22303-1410 — USA


Abstract
The language MSR has successfully been used in the past to prove undecidability results about security protocols modeled according to the Dolev-Yao abstraction. In this paper, we revise this formalism into a flexible specification framework for complex crypto-protocols. More specifically, we equip it with an extensible typing infrastructure based on dependent types with subsorting, which elegantly captures and enforces basic relations among objects, such as between a public key and its inverse. We also introduce the notion of memory predicate, where principals can store information that survives role termination. These predicates allow specifying complex protocols structured into a coordinated collection of subprotocols. More- over, they permit describing different attacker models using the same syntax as any other role. We demonstrate this possibility and the precision of our type system by presenting two formalizations of the Dolev-Yao intruder. We discuss two execution models for this revised version of MSR, one sequential and one parallel, and prove that the latter can be simulated by the former.


Introduction
The language MSR [8,15,9] is a formalism designed to give simple specifica- tions of authentication protocols within the Dolev-Yao abstraction of computer security [20,14]. It models a protocol as a set of parametric multiset rewriting rules augmented with existential quantiﬁcation as a device to guarantee the freshness of newly generated data. Indeed, MSR is an acronym for MultiSet Rewriting. As usual, multisets (also called bags) are algebraic structures that differ from sets by not collapsing multiple occurrences of an object (they can

1 Partially supported by NSF grant INT98-15731 “Logical Methods for Formal Verification of Software” and NRL under contract N00173-00-C-2086.
2 Email: iliano@itd.nrl.navy.mil
◯c 2001 Published by Elsevier Science B. V. Open access under CC BY-NC-ND license.


alternatively been seen as unordered sequences). Roles, i.e. the sequence of messages sent or received by each principal participating in a protocol run, are expressed as multiset rewriting rules communicating through dedicated role state predicates that pass control and data to the next rule in the sequence. Rules operate on states, defined as multisets of first-order atomic formulas modeling the messages in transit, the role state predicates currently present, and persistent information which establishes immutable relations such as be- tween a key and its inverse.
MSR has successfully been used to prove that certifying the correctness of an authentication protocol is in general undecidable [8,15]. We have moreover showed its substantial equivalence in expressive power to extensions of popular specification languages for security protocols, such as strand spaces [16], and further studied their similarities under the microscope of linear logic [6]. On the practical side, MSR fuels the CAPSL authentication protocol verification tool in the form of the underlying CIL intermediate language [13].
In spite of these achievements, MSR is a very low level language, poorly suited for the direct specification of security protocols. In particular, the slack constraints on the persistent information predicates present in a rule makes designing automated support procedures difficult and reasoning about speci- fications error-prone. These predicates, together with an elementary form of typing, describe associations among objects, such as between a key and the principal who owns it; this could conceivably be used to catch such errors as attempted accesses to unauthorized keys. Another shortcoming concerns its rigid rule format that accounts for lengthy specifications (and the consequent model-checking overhead [12]). Finally, the language defined in [8,15,9] lacks the expressiveness needed to describe but the simplest of authentication pro- tocols. In particular, any protocol structured in a collection of subprotocols lies outside the scope of this language.
In this paper, we propose a thorough redesign of MSR intended to es- tablish it as a usable specification framework for complex security protocols. The major innovations include the adoption of a flexible yet powerful typ- ing methodology that subsumes persistent information predicates, and the introduction of memory predicates that significantly widen the range of appli- cability of this formalism. The detailed definition of this language also allows for a precise description of its execution semantics. We call this formalism Typed MSR, or just MSR when no ambiguity can arise. It fully subsumes our earlier presentations of this language [8,15].
The type annotations of our new language, drawn from the theory of de- pendent types with subsorting, enable precise object classifications for exam- ple by distinguishing keys on the basis of the principals they belong to, or in function of their intended use. Therefore, the public key of any two principals can be assigned a different type, in turn distinct from their digital signature keys. Protocol specifications, called protocol theories in MSR, are strongly typed, and we have devised algorithms for statically catching type violations,

e.g. the use of a shared key to perform public-key encryption [4]. Our typing infrastructure can point to more subtle errors, such as a principal trying to encrypt a message with a key that does not belong to him. A procedure for enforcing such access control policies is analyzed in [3].
Memory predicates allow a principal to remember information across role executions. Their presence opens the doors to the specification of protocols structured as a collection of coordinated subprotocols. This novel possibility is exemplified in [5], where we formalize the Neuman-Stubblebine repeated authentication protocol [21], which lies outside the reaches of our previous version of MSR. A particularly interesting application of memory predicates is given by their role in the specification of the intruder model against which a protocol is to be analyzed. Indeed, our enhanced version of MSR allows expressing an attacker as a distributed protocol that communicates through dedicated memory predicates. We exemplify this technique by giving two specifications of the generic Dolev-Yao intruder. We should stress that these specifications lie completely within the the language of our present version of MSR, while the attacker corresponded to a set of rules that did not fully follow the syntax of protocols in [8,15,9].
The detailed definition of MSR presented in this paper enables an unam- biguous description of its execution semantics. We propose two models: one based on the sequential application of rules, while the second allows indepen- dent rules to fire in parallel. We prove that the latter mode can be emulated by sequential execution. Although this result is not particularly surprising in itself, the ability to give a completely formal proof further establishes the merit of the precise definition of our language.
This paper is organized as follows: in Section 2, we define the term lan- guage of MSR. Section 3 introduces states and their components and Section 4 presents rules, roles and protocol theories. The sequential and parallel exe- cution models of MSR are discussed and correlated in Section 5. Section 6 formalize two variants of the Dolev-Yao intruder model in our language. Fi- nally, Section 7 concludes this paper and outlines directions of future work.




Typed Messages

In Section 2.1, we describe the messages, or more generally terms, that form the core of MSR. Then in Section 2.2, we introduce the typing infrastructure that allowus to make sense of these terms. We will need them in the definition of protocol rules in Section 4. We conclude in Section 2.3 by pointing out the major differences with respect to the messages used in previous work on MSR [8,9].

Messages
Messages are obtained by applying a number of message forming constructs, discussed below, to a variety of atomic messages. The atomic messages we will consider in this paper are principal identifiers, keys, nonces, and raw data (i.e. pieces of data that have no other function in a protocol than to be transmitted). We formalize our notion of atomic message by means of the following grammatical productions:
Atomic messages: a ::= A (Principal)
| k (Key)
| n (Nonce)
| m (Raw datum)
Here and in the rest of the paper, A, k, n, and m will range over principal names, keys, nonces, and raw data respectively. We will sometimes also use B to denote a principal. Although we will limit the discussion in this paper to these kinds of atomic messages, it should be noted that others can be accommodated by extending the appropriate definitions.
The message constructors we will consider consist of concatenation, shared- key encryption, and public-key encryption. Altogether, they give rise to the following definition of a message, or more properly a term.
Messages: t ::= a	(Atomic messages)
| x	(Variables)
| t1 t2 (Concatenation)
| {t}k (Symmetric-key encryption)
| {{t}}k (Asymmetric-key encryption)
We will use the letter t, possibly sub- and/or super-scripted, to range over terms. Observe that we use a different syntax for shared-key and public-key encryption. We could have identified them, as it is done in many approaches. We choose instead to distinguish them to showthe flexibility and precision of our technique.
Again, other constructors, for example digital signatures and hash func- tions, can easily be accommodated by extending the appropriate definitions. We refrain from doing so since their inclusion would lengthen the discussion without introducing substantially new concepts.
Type tuples (discussed in Section 3) and protocol rules (see Section 4) rely on objects that may contain variables to be instantiated during type-checking (this aspect is formalized in [4]) and execution, respectively. A parametric message allows variables where terms could appear in the messages of Sec- tion 2.1.
We will write A (or B), k, n and m, variously decorated, for atomic con- stants or variables that are principals, keys, nonces and rawdata respectively. Whenever the object we want to refer to cannot be but a constant (mostly in

the execution rules of Section 5), we will use the corresponding seriffed letters: A (or B), k, n and m. Instead, the letters x, y and z will stand for terms that must be variable. In some circumstances, we will need to refer to objects that can be either variables or atomic message constants, but not composite terms. We call these terms elementary and denote them with the letter e, variously decorated.
Since most of the object we will be dealing with in the rest of the paper contain variables, we will use the wording “term” (or “message”) to refer to “parametric terms” (or “messages”). Whenever we will be working with terms that do not contain variables, we will talk about “ground” terms (or messages), unless clear from the context.
Types
While types played a very modest role in the original definition of MSR [8,9], they stand at the core of the extension presented in this paper. Through typing, we can enforce basic well-formedness conditions (e.g. that only keys be used for encrypting a message), as described in detail in [4]. Types also provide a statically checkable way to ascertain complex desiderata such as, for example, that no principal may grab a key he/she is not entitled to access. This aspect is thoroughly analyzed in [3]. The central role of types in our present approach is witnessed by the fact that they subsume and integrally replace the “persistent information” of the original MSR [9].
The typing machinery that best fits our goals is based on the type-theoretic notion of dependent product types with subsorting. Rather than delving into the depth of the definitions and properties of this formalism, we will intro- duce only the facets that we will use, and only to the extent we will need them. In particular, we do not conduct an in-depth discussion of this type theory; we will even stay away from the most exotic aspects of its syntax. Readers who wish to further their understanding of this formalism are invited to consult [11,18,1,22].
Types are syntactic constructions that are used to classify other syntactic expression, such as terms. By doing so, they give them a meaning, saying for example that an object we interpret as a key is not a nonce. Whenever a key is used where a nonce is expected, something has gone wrong since the meaning of this term has been violated. The types we will use in this paper are summarized in the following grammar:
Types: τ ::= principal (Principals)
| nonce	(Nonces)
| shK AB (Shared keys)
| pubK A  (Public keys)
| privK k	(Private keys)
| atm	(Atomic messages)
| msg	(Messages)

In the sequel, τ , possibly variously decorated, will stand for a type. Needless to say, the types “principal” and “nonce” are used to classify principals and nonces respectively. The next three productions allowdistinguishing between shared keys, public keys and private keys. Dependent types offer a simple and flexible way to express the relations that hold between keys and their owner or other keys. Given principals “A” and “B”, a shared key “k” between “A” and “B” will have type “shKAB”. Here, the type of the key depends on the specific principals “A” and “B”. Similarly, a constant “k” is given type “pubK A” to indicate that it is a public key belonging to “A”. We use dependent types again to express the relation between a public key and its inverse. Continuing with the last example, the inverse of “k” will have type “privK k”, from which it is easy to establish that it belongs to principal “A”.
The type “atm” is intended to classify atomic terms, which clearly include rawdata, but also principal names, nonces and all the above key types. This statement implies, for example, that a nonce “n” has both type “nonce” and “atm”. We accommodate this form of hierarchical multiple classification by imposing a subsorting relation between types. We formalize this relation by means of the following judgment:
τ :: τ'	τ is a subsort of τ'
In this paper, the subsorting relation requires that the types of principals, nonces and keys be subtypes of atm. Its extension is expressed by means of the following rules as far as atomic terms are concerned:


	 ss pr
principal :: atm


nonce :: atm
ss nnc





shK AB :: atm
ss shK


pubK A :: atm
ss pbK


privK k :: atm
ss pvK

These rules are parametric since, for example, ss shK establishes that “shKAB ::
atm” holds for any choice of the principals “A” and “B”.
The type msg is used to classify generic messages. Since nonces, keys, and principal identifiers are routinely part of messages, we make atm a subsort of msg:



atm :: msg
ss atm

Again, the types and the subsorting rules above should be thought of as a reasonable instance of our approach rather than the approach itself. Other schemas can be specified by defining appropriate types and how they relate to each other. For example, digital signatures could be accommodated by introducing dedicated dependent types akin to “pubK A” and “privK k”. In another scenario, an application may find it convenient to see each of the key- related types above as a subtype of a universal key type, say “key”, in turn a subsort of msg. As a final example, we may want to define distinct types for

long-term keys and have them not be a subsort of msg, prohibiting in this way the transmission of long-term secrets as parts of messages; more complex key stratifications coud be captured as well. These possibilities are exemplified in [4,5].
In the first part of this section, we have introduced terms and the types intended to classify them. We will now present the typing rules that will allow us to establish whether an expression built according to the syntax of terms can be considered a ground message (more in general whether a given expression free of variables has a certain type).
The rules below systematically reduce the typability of a composite term to the validity of its subterms. This is adequate for constructors, but atomic messages need to be treated specially unless we are willing to write new rules for them each time we model a protocol. Independence of rules from actual atomic messages is achieved through the notion of a signature. A signature, written Σ, is a finite sequence of declarations that map atomic messages to their type. More formally,
Signatures: Σ ::= ·	(Empty signature)
| Σ, a : τ (Atomic message declaration)
| ( ... )
The dots in the last line express the fact that this definition is incomplete: we will extend it in the next section.
We assume that each atomic message in a signature is declared exactly once. We will also often elide the leading “·” from a non-empty signature, and promote the extension operator “,” to denote signature union. This operation is defined only if the resulting sequence is itself a signature (in particular it should not contain multiple declarations for the same constant).
Given the notions introduced so far, it is fairly easy to define a meaningful type system for messages and the other types we have described. In order to accomplish this goal, we will rely on the following message typing judgment:
Σ ▶ t : τ	Term t has type τ in signature Σ
All composite terms have type msg, given that their constituent submessages are correctly typed. This implies that the subterms of a concatenation (t1 t2) are themselves messages. On the other hand, the plaintext part t of an en- crypted message {t}k should have type msg but k should be a shared key between two principals. Terms encrypted with public keys, of the form {{t}}k, are handled similarly. This intuition is formally captured in the following typing rules for messages:


Σ ▶ t1 : msg	Σ ▶ t2 : msg

Σ ▶ t1 t2 : msg

mtp cnc



Σ ▶ t : msg	Σ ▶ k : shK AB 


Σ ▶ {t}k : msg
Σ ▶ t : msg	Σ ▶ k : pubK A

mtp ske

Σ ▶ {{t}}k : msg
mtp pke

These rules are parametric, as witnessed by the numerous meta-variables they contain, but also hypothetical in the sense that the validity of the consequent relies on the validity of their premises.
The next rule reduces verifying that a term t has type τ to checking that it has type τ' for some subsort of τ . In this way, we can for example use a nonce or a key where an object of type msg is expected. The formal rule is as follows:

Σ ▶ t : τ'	τ' :: τ

Σ ▶ t : τ
mtp ss

The last term typing rule deals with elementary messages components. An atomic message a has a type τ if the signature at hand contains the declaration “a : τ ”. The validity of the type τ in Σ is independently checked by verifying the validity of a signature [4].




(Σ,a : τ, Σ') ▶ a : τ
mtp a

This concludes the presentation of the typing rules needed in this paper. It should be noted that these rules do not guarantee that the signature decla- rations obey the typing policy: for example, nothing forces the arguments A and B of the type in the rightmost premise of rule mtp ske to be principals. Although well-typed signatures are an essential component of a correct spec- ification, we do not need to require them in this paper. These omitted typing rules can be found in [4] together with procedures designed to validate every element of an MSR protocol specification.
For the convenience of the reader, we collect all the rules presented in this paper in Appendix A.
Changes
We will now compare the above term infrastructure with the notion of message used in earlier versions of MSR [8,9]. The main differences concern the types and the way they are used.
Structurally, the original presentation of MSR referred to so-called simple types, i.e. types that do not depend on terms. These types would permit distinguishing objects into keys, nonces, messages, etc. (the taxonomy was open-ended), but would not allow any finer classification [7]. Sub- sorting introduced some flexibility. Most of the information that is now captured through types and especially their dependencies on terms was then expressed by means “persistent predicates” that cluttered protocol

specifications and complicated reasoning about them. These entities have been dropped.
Typing played a rather inessential role in [8,9]: constants were given types, but rules themselves did not carry such information. Furthermore, no type system was explicitly presented to validate terms or rules. Typing is central to the language proposed in this paper: every object is typed. Indeed, our approach allows not only verifying basic well-formedness con- ditions (e.g. that no message is encrypted with a nonce) [4], but types provide a statically checkable way to enforce complex requirements such as, for example, that no principal uses a key he/she is not entitled to access [3].
In this paper, we make a syntactic distinction between shared-key and public-key encryption. Although not present in [8,9], we could have easily distinguished the two forms of encryption in the earlier version of MSR.

Message Predicates and States
As we will see shortly, a state is a collection of specialized atomic first-order formulas. States are a fundamental concept in MSR. Indeed, they are the cen- tral constituent of the snapshots of a protocol execution. They are the objects transformed by rewrite rules to simulate message exchange and information update. Finally, together with execution traces, they are the hypothetical scenarios on which protocol analysis is based.
In this section, we will formalize the concept of state in MSR, together with the constructions needed to implement it. In Section 3.1 we introduce message tuples and a notion of type for them. Then in Section 3.2, we discuss the message predicates that appear in a state, and in Section 3.3 we define states.

Message Tuples and Dependent Types
As we will see shortly, message predicates are atomic first-order formulas with zero or more terms as their arguments. In this section, we are concerned with formalizing the concept of tuple and presenting suitable types for them.
A message tuple is an ordered sequence of terms. It is trivially defined as follows:
Message tuples →t ::= ·  (Empty tuple)
| t, →t (Tuple extension)
We will often omit the leading · whenever a tuple is not empty.
It is tempting to define the type of a tuple as the sequence of the types of its components. Therefore, if A is a principal name and kA is a public key for A, the tuple (A, kA) would have type “principal × pubK A” (the Cartesian product symbol “×” is the standard constructor for type tuples). This construction

allows us to associate a generic principal with A’s public key: if B is another principal, then (B, kA) will have this type as well. We will often need stricter associations, such as between a principal and its own public key. In order to achieve this, we will rely on the notion of dependent type tuple. In this example, the tuple (A, kA) will be attributed type “principal(A) × pubK A”, where the variable A in “principal(A)” records the name of the principal at hand and forces the type of the key to be “pubK A” for this particular A: therefore (A, kA) is a valid pair of type “principal(A) × pubK A”, but (B, kA) is nowill-typed since kA has type “pubK A” rather than the expected “pubK B”. 3 We do attribute a type to a term tuple by collecting the type of each constituent message, but we label these objects with variables to be used in later types that may depend on them. A dependent type tuple is therefore an
ordered sequence of types parameterized as follows:
Type tuples →τ ::= ·	(Empty tuple)
| τ (x) × →τ (Type tuple extension)
In the second line of this definition, the notation (x) on the left of the Cartesian product symbol binds the variable x in the type tuple →τ to its right. Similarly for example to a quantifier, τ (x) is a binder. Variables that are not bound in this way are said to be free. We will often be interested in closed type tuples, all of whose variables are bound. The scope of a binder is the expression over which its binding action spans. The scope of a type tuple component extends to the entire type tuple to its right.
Given a dependent tuple type τ (x) × →τ , we will drop the label (x) whenever the variable x does not occur (free) in →τ . The resulting simplified notation, τ × →τ , will help writing more legible specifications when possible. As for term tuples, we will omit the leading “·” whenever convenient.

Message Predicates
The predicates that can enter a state or a rewrite rule are of three kinds:
First, the predicate N( ) implements the contents of the public network in a distributed fashion: for each (ground) message t currently in transit, the state will contain a component of the form N(t).
Second, active roles rely on a number of role state predicates, generally one for each rule in them, of the form Ll( ,..., ), where l is a unique identifying label. The arguments of this predicate record the value of known parameters of the execution of the role up to the current point.

3 Our dependent type tuples are usually called weak dependent sums in the type theoretic community, and the standard notation for the dependent type tuple we have written as “principal(A) × pubK A” is “ΣA : principal. pubK A”. We believe that our syntax is likely to be more clear to the target audience of this paper.


Third, a principal A can store data in private memory predicates of the form MA( ,..., ) that survives role termination and can be used across the execution of different roles, as long as the principal stays the same.
The reader familiar with our previous work on MSR will have noticed a number of differences with respect to the definitions given in [8,9]. Memory predicates are indeed new. They are intended to model situations that need to maintain data private across role executions: for example, this allows a principal to remember its Kerberos ticket, or the trusted-third-party of a fair exchange protocol to avoid fraudulent recoveries from aborted transactions. Another difference with respect to earlier work is the absence of a dedicated predicate retaining the intruder’s knowledge. This can however be easily implemented using memory predicates, as we will see in Section 6.
Every protocol relies on a public network. Therefore, we will hardwire the network predicate N( ) in our language. Local state and memory predicates are different: they are defined on a per-protocol basis. This is similar to principals and keys. We therefore maintain generality by declaring them as part of the signature. We can now complete the definition of a signature as follows:
Signatures Σ ::= ·	(Empty signature)
| Σ, a : τ	(Atomic message declaration)
| Σ, Ll : →τ	(Local state predicate declaration)
| Σ, M : →τ (Memory predicate declaration)
States
A multiset is a collection of objects whose multiplicity counts, but whose order is irrelevant. We can see them either as unordered sequences, or as sets that allowseveral instances of the same element to coexist (and prohibit collapsing them). A state is a finite multiset of ground state predicates. The syntax of states is partially formalized by means of the following grammar:
States: S ::= ·	(Empty state)
| S, N(t)	(Extension with a network predicate)
| S, Ll(→t )	(Extension with a role state predicate)
| S, MA(→t ) (Extension with a memory predicate)
As for signatures, we will omit the leading “·” and interpret the extension construct “,” as a union operator. It will be convenient to break from the rigid format imposed by the above grammatical productions, and abstract from the order of the component predicates of a state, treating them as a multiset.
Protocol rules transform states. They do so by identifying a number of component predicates, removing them from the state, and adding other, usu- ally related, state elements. The antecedent and consequent of a rewrite rule

embed therefore substates. However, in order to be applicable to a wide array of states, rules usually contain variables that are instantiated at application time. This calls for a parametric notion of states and message predicates.
For the most part, this reduces to admitting variables in the embedded terms. However, role state predicates need to be created on the spot in order to avoid interferences. We achieve this by introducing variables, denoted L, that are instantiated to actual role state predicates during application. This makes our language weakly second-order, although we could easily reduce it to the first order by interpreting a role state predicate Ll as the symbol L indexed by a label l that is kept as a variable in rules. We however opt for the more direct solution since it does not have any drawback, and allows for slightly simpler definitions.
Changes
In the final part of this section, we will analyze the main differences between the notion of state and related concepts defined above and the analogous entities from the original definition of MSR [8,7].
Typing constitutes a minor distinction at this level since both versions of MSR rely on typed predicate names, although little use of this aspect was made in [8,7]. Our present usage of dependent type tuples is mostly a consequence of our adoption of dependent types to classify terms. The major differences regard instead the introduction of memory predicates and the elimination of persistent information and distinguished intruder knowledge predicates in states.
In earlier versions of MSR, a principal had no way to remember data across role executions: role state predicates are local to a role instance, and network messages are not intended for storing private information. Memory predicates survive role termination. As already mentioned, this is useful when modeling scenarios that require remembering information across role executions: for example, this allows a principal to remember its Kerberos ticket, or the trusted-third-party of a fair exchange protocol to avoid fraudulent recoveries from aborted transactions. Another novel important use of memory predicate is in modeling protocols consisting of a number of subprotocols: these predicates allow subprotocols to call each other and share data.
There is no trace in the above definitions of the persistent information that formed the immutable portion of the state of MSR in [8,7]. The functionality of those predicates is now performed by the strong typing policy of our updated framework, and in particular by our reliance on dependent types.
Finally, we should point out the absence of a dedicated predicate intended to hold the intruder’s knowledge. This aspect of our earlier work can now be realized transparently through memory predicates, as we will witness

in Section 6.
Multiset Rewriting Theories
In the past, crypto-protocols have often been presented as the temporal se- quence of messages being transmitted during a “normal” run. Recent pro- posals champion a viewthat places the involved parties in the foreground. A protocol is then a collection of independent roles that communicate by ex- changing messages, without any reference to runs of any kind. A role has an owner, the principal that executes it, and specifies the sequence of mes- sages that he/she will send, possibly in response to receiving messages of some expected form. A role can therefore be seen as a reactive system.
MSR adopts and formalizes this perspective. It represents protocols as a set of syntactic entities that we also call roles. A role is itself given as a parameterized collection of multiset rewrite rules that encode the expected message receptions and the corresponding transmission. Rule firing emulates receiving (and accepting) a message and/or sending a message, the smallest execution steps.
This section defines rules, roles and protocol theories. More specifically, in Section 4.1, we introduce rules and their constituents. Roles are defined in Section 4.2. Then, in Section 4.3, we turn our attention to protocol theories, which are our representation of protocols. Finally, in Section 4.4 we anticipate the dynamic notion of an active role. Roles and protocol theories will be fur- ther discussed in Sections 5 which focuses on execution. Section 4.5 examines howthese definitions differ from our original presentation of MSR.
Rules
The core of a rule has the form “lhs → rhs”. Rules are the basic mechanism that enables the transformation of a state into another, and therefore the simulation of protocol execution: whenever the antecedent “lhs” matches part of the current state, this portion may be substituted with the consequent “rhs” (after some processing).
It is convenient to make protocol rules parametric so that the same rule can be used in a number of slightly different scenarios (e.g. without fixing inter- locutors or nonces). A typical rule will therefore mention variables x1,..., xn that will be instantiated to actual terms during execution. Typed universal quantifiers can conveniently express this fact so that rules assume the form “∀x1 : τ1. ... ∀xn : τn. (lhs → rhs)”. This idea is more precisely captured by the following grammar:
Rule: r ::= lhs → rhs (Rule core)
| ∀x : τ. r	(Parameter closure)
The universal quantifiers used in rules bind the variables they are applied to.

Free variables can occur in the construction of a rule, but roles themselves should have all their variables bound (this is enforced by the typing rules): they are closed. The scope of all the binders in the above productions spans over a whole rule.
If we think of variables as place holders, binders dictate which place hold- ers must be instantiated with the same term (or predicate name). Variable names implement this association. Besides a possibly mnemonic function, the names of variables themselves have little importance and can be replaced with arbitrary strings as long as no conflict with a free variable is introduced (an effect called variable capture: renaming would cause a free variable to become bound). It will be convenient (e.g. when applying a substitution) to allow the implicit capture-free renaming of bound variables in a predicate sequence (this is known as α-conversion in type-theoretic circles).
The left-hand side, or antecedent, of a rule is a finite collection of paramet- ric message predicates, and is therefore given by the following grammar for predicate sequences:
Predicate sequences: lhs ::= ·	(Empty predicate sequence)
| lhs, N(t)	(Extension with a network predicate)
| lhs, L(→e)	(Extension with a role state predicate)
| lhs, MA(→t ) (Extension with a memory predicate)
Observe that rule antecedents and in general predicate sequences differ from states (see Section 3.3) mainly by the limited instantiation of role state predi- cates: in a rule, these objects consist of a role state predicate variable applied to as many elementary terms as dictated by its type. Recall that elementary terms are either variables or atomic message constants. Network and memory predicates will in general contain parametric terms, although not necessarily rawvariables as arguments.
The right-hand side, or consequent, of a rule consists of a predicate sequence possibly prefixed by a finite string of fresh data declarations such as nonces or short-term keys. We rely on the existential quantification symbol to express data generation. We have the following grammar:
Right-Hand sides: rhs ::= lhs	(Sequence of message predicates)
| ∃x : τ. rhs (Fresh data generation)
The notion of fresh and bound variable discussed earlier applies also here. Notice that the scope of these quantifiers is limited to the right-hand side of the current rule. Later rules can refer to the values created by these variables by introducing universal quantifiers of the proper type: synchronization is ensured by their occurrence in the role state predicates. We have shown in [6] that, when encoding of MSR in logic, our marker for fresh data is indeed rendered by an existential quantification.

Roles
Role state predicates record information accessed by a rule. They are also the mechanism by which a rule can enable the execution of another rule in the same role. Relying on a fixed protocol-wide set of role state predicates is dangerous since it could cause unexpected interferences between different instances of a role executing at the same time. Instead, we make role state predicates local to a role by requiring that fresh names be used each time a new instance of a role is executed. As in the case of rule consequents, we achieve this effect by using existential quantifiers: we prefix a collection of rules ρ that should share the same role state predicate L by a declaration of the form “∃L : →τ ”, where the typed existential quantifier expresses the fact that L should be instantiated with a fresh role state predicate name of type →τ . Again, a translation of MSR in logic interprets these declarations as existential quantifications [6].
With this insight, the following grammar defines the notion of rule collec- tion:
Rule collections: ρ ::= ·	(Empty role)
| ∃L : →τ. ρ (Role state predicate parameter declaration)
| r, ρ	(Extension with a rule)
It should be observed that this definition allows for role state predicate pa- rameters declarations and rules to be interleaved in a rule collection. We will however generally divide a collection in a preamble where all roles state parameters are declared, and a body that lists the rules that constitute a role.
A role is given as the association between a role owner A and a collection of rules ρ. Some roles, such as those implementing a server or an intruder, are intrinsically bound to a few specific principals, often just one. We call them anchored roles and denote them as
ρA

Here, the role owner A is an actual principal name, a constant. Other roles can be executed by any principal. In these cases A must be kept as a parameter bound to the role. We use the following syntax to represent these generic roles:
ρ∀A
where the implicitly typed universal quantification symbol implies that A should be instantiated to a principal before any rule in ρ is executed, and sets the scope of the binding to ρ. Observe that in this case A is a variable. With a slight abuse of notation, we will sometimes refer to roles of either kind with the letter ρ, variously subscripted.

Protocol Theories
A protocol theory, written P, is a finite collection of roles:
Protocol theories: P ::= ·	(Empty protocol theory)
| P, ρ∀A (Extension with a generic role)
| P, ρA (Extension with an anchored role)
It should be observed that we do not make any special provision for the in- truder. The adversary is expressed as one or more roles in the same way as the more legitimate message exchange in a protocol. We will illustrate how this is achieved for the standard Dolev-Yao intruder and for a variant of it in Section 6.
Active Roles
As we will see in Section 5, several instances of a given role, possibly stopped at different rules, can be present at any moment during execution. We record the role instances currently in use, the point at which each is stopped, and the principal who is executing them in an active role set. These objects are finite collections of active roles, i.e. partially instantiated rule collections, each labelled with a principal name. The following grammar captures their macro- scopic structure:
Active role sets: R ::= ·	(No active role)
| R, ρA (Extension with an instantiated role)
The notation ρA is reminiscent of anchored roles. Active roles are actually more liberal in that some of the role state predicate symbols as well as their arguments may be instantiated. Intuitively, ρA results from instantiating the contents of some role, with A is its elected owner.
Changes
It should be noted that the above syntax of rules is much more liberal than the original definition of MSR [8,9]. We dedicate the remainder of this section to commenting on these differences. We begin by noting structural changes (items i–iii), then move to persistent information (item iv), memory predicates (item v), and network predicates (item vi). We then continue with a number of remarks concerning the role state predicates (items vii–x), and conclude with active roles (item xi).
A protocol theory was defined in [8,9] as a collection of rules for which the graph generated by their role state predicates was acyclic (see item x below for further details). Each connected component corresponded to a role. Besides this constraint, the rules within a role were indepen- dent. This aspect is mostly maintained in our current formulation, but

our definition of role allow threading rules by using role state predicate declarations as a sequencing device. This option is seldom used since this effect can be achieved more simply by appropriately using role state predicates.
In [8,9], all variables were implicitly universally quantified at the head of a rule, unless marked in the consequent as fresh data. Here, these vari- ables are explicitly introduced by typed universal quantifiers. Explicit quantification simplifies rule analysis as far as type-checking [4] and ac- cess control [3] are concerned. More importantly, it declares the type of variables, which is necessary for the correct execution of a protocol (more on this aspect in 5).
The only quantifiers present in [8,9] appeared in rule consequents and had the purpose of introducing variables to be instantiated with fresh data. The adoption of dependent types makes this mechanism more powerful. Our current schema allows for example a server to generate a key to be shared among two specific principals.
As already observed, our current formulation does not make use of the persistent predicates of [8,9]. As we said, the information once conveyed by these objects is not entirely captured within the type system of MSR.
Memory predicates are a novel feature. As already mentioned, they are useful whenever data should be remembered across role executions, which happens, for example, when a subprotocol can be executed repeatedly after some initialization phase.
Any number of network predicates can appear in both the antecedent and the consequent of a rule. The original definition allowed at most once such predicate per rule, either in the left-hand side (in “receive” rules), or in the right-hand side (for “send” rules). Denker et al. [12] showed that, whenever some simple conditions are met, a sequence of contiguous message reception rules followed by a sequence of contiguous transmission rules can be soundly collapsed into a single rule of the proposed form. This is clearly a conservative extension of our previous proposal. Besides reducing the length of the specification of a protocol, the practical value of merging rules lies in the fact that it yields a huge overhead reduction when model-checking a protocol.
In [8,9], each rule contained exactly one role state predicate on each side, with the exception of the single “role generation rule” that acti- vated the role. The productions above instead allowzero, one, or several such predicates on either side. This definition simplifies the grammatical specification of roles. However, we will make a very limited use of this added expressive power. Having more than one role state predicate in the left-hand or right-hand side of a rule does not appear particularly useful since the arguments of these predicates collect data known to a principal in the current thread of execution of a role. The antecedent of

the first rule in a role cannot sensibly mention any role state predicate since its left-hand side could not match any state. The antecedent of the other rules typically will have such a predicate for synchronization, although this is not enforced. For the same reason, the consequent of a rule will generally contain a role state predicate. The natural exception to this practice regards the final rules of a role, which do not need to make provisions for further synchronization.
The role state predicate symbols allowed in [8,9] were constants rather than variables. We nowprefer to make them unique to each instantiation of a rule in order to avoid the possibility of interferences (although we have no examples in which such a phenomenon is harmful).
With the exception of [7], our previous work did not refer to any argu- ment of a role state predicate as a distinguished role owner. These early versions of MSR did not need to actively rely on role owners to fulfill their objectives, i.e. studying the decidability of discovering attacks in a protocol. Therefore, no particular emphasis was given to this notion. This information becomes crucial when trying to enforce access control, as described in [3].
For any given role, it is interesting to study the graph whose nodes are its role state predicates and whose edges link the predicate occurring in the left-hand side to the predicate in the right-hand side of each rule. In [8,9,6] we required that this graph be an upper semi-lattice, and in particular that it had a single entry point and be acyclic. This was a crucial assumption for studying the complexity of protocols [8,15]. Here, we drop this condition from the syntax of a role, but our firing rules will de facto implement a similar constraint at execution time.
Our previous work [8,9] did not have a notion of active role: since role state predicate symbols were constants, rules could not be threaded within a role and each rule was necessarily an independent object that could be applied whenever its antecedent matched the current state. The more complex pattern proposed in this chapter require memorizing which roles are in current use, and how they are instantiated. This is the pur- pose of active role sets. It must be observed that these entities are closely related to the notions of residual strands studied in [9] as a part of an execution model for strand specifications of security protocols [16].

Protocol Execution
In this section, we will define the execution model of MSR. More precisely, we first outline the definition of the pervasive notion of substitution in Section 5.1. Then, we present the basic one-step rule application and its sequential itera- tion in Section 5.2. In Section 5.3, we extend this notion to allow concurrent rule firing. We prove the admissibility of parallel firing in Section 5.4. We

conclude in Section 5.5 with a discussion of the main changes with respect to previous versions of MSR.

Substitutions
In this section, we introduce the notion of substitution used in the execution rules below. We focus mainly on the syntax of this operation. Its fairly standard definition is displayed in Appendix A.3.
Given a variable x and an object O that may mention x as a parameter, we denote the substitution of a term t for x in O as [t/x]O. As far as the execution rules are concerned, the instantiating term t will always be ground, and therefore the implementation of substitution does not need to take par- ticular provisions aimed at avoiding variable capture (i.e. the risk that a free variable in t may accidentally become bound in O). The parametric objects O we will be interested in are other terms t', term tuples →t, types τ , type tuples
→τ , predicate sequences lhs, right-hand sides rhs, rules r, and rule collections
ρ. All together, we will encounter the following forms of substitution:
[t/x]t'  [t/x]→t  [t/x]τ  [t/x]→τ  [t/x]lhs  [t/x]rhs  [t/x]r  [t/x]ρ
Observe that, for simplicity, we are overloading the bracket notation to denote the application of the substitution operation to objects belonging to different syntactic categories. We only need to define the substitution of t for x in objects that may mention x as a free variable. This is why we do not include protocol theories, states and active roles in the above list.
Besides term variables, rule collections contain a second kind of parameter, namely role state predicate symbols, that we have denoted with the letter L, variously decorated. During execution, we will need to instantiate them to constants of the form Ll, where l is a label. We extend our syntax and write [Ll/L]O for the substitution of variable L with Ll in object O. This operation applies to left-hand sides lhs, consequents rhs, rules r and rule collections ρ:
[Ll/L]lhs	[Ll/L]rhs	[Ll/L]r	[Ll/L]ρ
It should be observed that although L stands for a predicate symbol, it never needs to be instantiated to anything more complex than a constant. The higher-orderness of our notation is only apparent.
Again, the definition of these operations can be found in Appendix A.3.

Sequential Firing
Execution is concerned with the use of a protocol theory to move from a situation described by a state S to another situation modeled by a state S'. In this section, we will introduce judgments and rules describing the atomic execution steps that lead from S to S'. We will then show how they can be chained to perform multi-rule sequential applications.

Referring to the situation that the execution of a protocol has reached by means of a state is an oversimplification. Two more ingredients are required: first we need to know which roles can be used in order to continue the ex- ecution, at which point they were stopped, and how they were instantiated. This calls for an active role set. Second, it is very convenient to carry around a list of the constants in use in a signature: this allows us in particular to verify that instantiations are well-formed and well-typed. Situations are then formally defined as a triple consisting of a state S, an active role set R and a signature Σ. Such triples are called snapshots, and denoted as in the following grammatical production:
Snapshot: C ::= [S] R
We shall observe that no element in a snapshot contains free variables: Σ is clearly ground, and so is the state S; the active role set R will generally contain bound variables, but execution will always instantiate them to ground terms as it exposes them.
Given a protocol P, we describe the fact that execution transforms a snap- shot C into another snapshot C' in one step by means of the following judg- ment, where we have expanded the definition of C and C' to familiarize the reader:


P d [S] R
−→ [S'] R'
One-step sequential ﬁring

This judgment is implemented by the next six rules that fall into three classes. We should be able to: first, make a role from P available for execution; second, perform instantiations and apply a rule; and third, skip rules (more on this later).
We first examine how to extend the current active role set R with a role taken from the protocol specification P. As defined in Section 4.3, P can contain both anchored roles ρA and generic roles ρ∀A. This yields the following two rules, respectively:


(P, ρA) d [S] R
−→ [S] R,ρA
exs arole



Σ ▶ A : principal

exs grole

(P, ρ∀A) d [S] R
−→ [S] R,([A/A]ρ)A

Anchored roles can simply be copied to the current active role sets since their syntax meets the requirements for active roles. In order to make a generic role available for execution, we must assign it an owner. The premise of rule exs grole selects a principal name A from the current signature Σ and instantiates ρ with it. Observe that this premise relies the typing judgment to make sure that A is defined and that it actually stands for a principal name. We could have alternatively looked it up in Σ directly.

Once a role has been activated by either of the above rules, chances are that it contains role state predicate parameter declarations that require to be instantiated with actual constants before any of the embedded rules can be applied. This situation, characterized by the fact that the active role under examination has the form (∃L : →τ. ρ)A, is implemented by the following rule, which generates a fresh constant Ll, adds a declaration for it in the current signature Σ, and replaces every occurrence of L in ρ with it. Notice that Ll shall be a new symbol that appears nowhere in the current snapshot (in particular it should not occur in Σ).
	 exs rsp

P d [S] R,(∃L:→τ. ρ)A
R,([Ll/L]ρ)A
(Σ,Ll:→τ )

Processing a role state predicate parameter declaration prefix may have the effect of exposing a protocol rule v. At this point, v can participate in an atomic execution step in two ways: we can either skip it (discuss below), or we can apply it to the current snapshot to obtain a new configuration. The latter option is implemented by the inference rule below, which makes use of the rule application judgment “v d [S] Σ   [S'] Σ' ” to construct the state S' and the signature Σ' resulting from the application. We will describe this judgment shortly. The changes to the active role set are limited to discarding
the used rule v.

vd [S] Σ
  [S']

exs rule

P d [S] R,(r,ρ)A −→ [S'] R,(ρ)A
Only the simplest of security protocols specify a purely linear sequence of actions. More complex systems allowvarious forms of branching or even more complex layouts. In a protocol theory, the control structure is mostly realized by the role state predicates appearing in a role. Branching can be modeled by having two rules share the same role state predicate parameter in their left- hand side. Roles, on the other hand, are defined as a linear collection of rules. Therefore, in order to access alternative role continuations, we may need to skip a rule, i.e. discard it and continue with the rest of the specification. The following two execution rules implement this scenario:


P d [S] R,(r,ρ)A
−→ [S] R,(ρ)A
exs skp
P d [S] R,(·)A
−→ [S] R
exs dot

The inference on the left skips a protocol rule. Rule exs dot does some house- keeping by throwing away active roles that have been completely executed.
When successful, the application of a rule v to a state S in the signature Σ produces an updated state S' defined in the extended signature Σ'. This operation is defined by the following judgment:
vd [S] Σ   [S'] Σ'	Rule application

It is implemented by two rules that discriminate on the structure of a protocol rule.
In order to apply a rule to the current state, we first need to appropriately instantiate the universal variables that may appear in it. Our next execution rule will therefore examine rules of the form (∀x : τ. v). It instantiates x to some well-formed term t of type τ in the current signature:

'
Σ ▶ t : τ	[t/x]vd [S] Σ   [S ]

exs all


'
(∀x : τ. v) d [S] Σ   [S ]
Again, we make use of the typing judgment to ascertain that t has type τ in Σ. The attentive reader may be concerned by the fact that the construction of the instantiating term t is not guided by the contents of the state S. This isa very legitimate observation: the rule above provides an idealized model of the execution rather than the basis for the implementation of an actual simulator. We may want to think of the premise of this rule as a non-deterministic oracle that will construct the “right” term to successfully continue the execution. An operational model suited for implementation is the subject of current research. We now consider execution steps resulting from the application of a fully instantiated rule of the form “lhs → rhs”. The antecedent lhs must be ground and therefore it has the structure of a legal state. This rule identifies lhs in the current state and replaces it with a substate lhs' derived from the consequent rhs. This latter operation is performed in the premise of this rule by the right- hand side instantiation judgment “(rhs)Σ  (lhs )Σ' ” that will be discussed
shortly.

(rhs)Σ   (lhs )Σ'
exs core

'
(lhs → rhs) d [S, lhs] Σ  [S, lhs ]
The right-hand side instantiation judgment used in the premise of rule exs core generates a ground predicate sequence lhs from the consequent rhs of a fully instantiated rule v from an active role (v, ρ)A. The resulting changes to the current signature Σ are reflected in the updated signature Σ'. This judgment is defined as follows:
(rhs)Σ   (lhs)Σ'	Right-hand side instantiation
It is implemented by the following two rules, which instantiate the existentially quantified variables possibly wrapped around the core of rhs. If this parameter is already a predicate sequence, we simply return it, without making any change to the signature Σ:
	 exs seq
(lhs)Σ   (lhs)Σ
The instantiation of an existentially quantified term variable x is handled in rule exs nnc below. We generate a fresh term constant a of the appropriate

type, records this fact in the signature, and replaces every occurrence of x
with a before examining the body of rhs.
([a/x]rhs)(Σ,a:τ)   (lhs)Σ'

(∃x : τ. rhs)Σ   (lhs)Σ'
exs nnc

Observe that, in this rule, the generated constants should not appear anywhere in the current signature Σ (and therefore in the left-hand side of the judgment): this object is new.
We conclude this section by providing a judgment and the associated in- ference rules that allow us to chain the atomic steps presented above into multi-step sequential firings. This allows simulating executions consisting of the linear application of any number of basic steps between two snapshots of interest. We have the following judgment:
P d C −→∗ C'	Multi-step sequential ﬁring
The following rules define this judgment as the reflexive and transitive closure of the atomic step relation discussed above.
P d C −→ C'	P d C' −→∗ C''



P d C −→∗ C
exs it0
P d C −→∗ C''
exs itn


We conclude this section with a simple lemma that asserts that, as execu- tion proceeds, the initial signature can only be extended. As a space saver, we write P d C −→(∗) C' to indicate that we are considering the one-step (P d C −→ C') and the multi-step (P d C −→∗ C') versions of the sequential firing judgment at once.
Lemma 5.1 (Signature Extension)
Let Σ and Σ' be signatures, rhs the right-hand side of a rule, lhs a predicate sequence, v a rule, S and S' states, P a protocol theory, and R and R' active role sets.
If  (rhs)Σ  (lhs)Σ' ,  then  Σ = (Σ, Σ ) for some signature Σ .
If  vd [S] Σ   [S'] Σ' ,  then  Σ' = (Σ, Σ'') for some signature Σ''.

If	P d [S] R
−→(∗) [S'] R' ,	then	Σ' = (Σ, Σ'') for some signature Σ''.

Proof: The proof proceeds by induction on the structure of a derivation of the judgments in each of the three parts of this lemma. These results are not mutually recursive and shall be proved in the given order. We present only a sketch of this very simple proof, reserving a detailed illustration of the technique used for more substantial examples in the sequel.
The first result (1) is immediate for rule exs seq and follows by an ap- peal to the induction hypothesis for rule exs nnc. The second point in this

lemma (2) relies on (1) for rule exs core and the indurction hypothesis for rule exs all. The last result (3), is immediate for rules exs arole, exs grole, exs rsp, exs skp, exs dot, and exs it0. It relies on (2) for rule exs rule and follows by induction for rule exs itn.	✷

Parallel Firing
Multi-step sequential firing simulates the execution of a protocol one rule at a time. However, even the simplest of protocols are inherently concurrent sys- tems and allowindependent roles to be executing at the same time. Although interleaving permits reducing such a behavior to the sequential case, it is in- teresting to provide a direct specification of this model. In this section, we will first discuss executions that can be obtained as the parallel composition of one-step sequential firings, and then generalize it to multi-step parallel firing. In Section 5.4, we will establish a formal relationship between the sequential and parallel models of execution.
We will rely on the following judgment to express the fact that snapshot
C' is obtained from C by executing zero or more atomic steps in parallel:
P d C =⇒ C'	One-step parallel ﬁring
The two rules below implement this judgment. The toptmost inference cap- tures the degenerate situation where no basic step is applied: the current snapshot is returned as output. Rule exp par expresses parallel execution: intuitively, we want to partition the current state description into partial snap- shots, independently apply one basic step to each, and then merge the results together to obtain the output snapshot.




P d C =⇒ C
exp id

P d [S ] R1
'
−→ [S ] 1
P d [S ] R2
'
=⇒ [S ] 2

1 Σ	1
(Σ,Σ' )	2 Σ
2 (Σ,Σ' )

	 exp par

(R1,R2)
'	' (R' ,R' )

P d [S1, S2] Σ	=⇒ [S1, S2]
1  2
(Σ,Σ' ,Σ' )

Technically, rule exp par operates as follows: it splits the current state in two parts S1 and S2, and similarly partitions the active role set into R1 and R2. The left premise applies one atomic execution step to the partial snapshot
[S ] R1 , producing [S' ] R'	as a result, where Σ' is the amount by which the
1 Σ	1 (Σ,Σ' )	1
current signature Σ has been extended during this step. Rather than having an
unbounded number of premises, we call our parallel firing judgment recursively in the rightmost premise: in zero or more atomic steps, we transform the
remainder of the initial snapshot, [S ] R2 , into [S' ] R'	where again Σ' is the
2 Σ	2 (Σ,Σ' )	2
resulting signature extension. The overall output snapshot is constructed by
taking the multiset union of the returned states S' and S' , juxtaposing the

output active role sets R' and R' , and combining the resulting signatures
(Σ, Σ' ) and (Σ, Σ' ) into (Σ, Σ' , Σ' ).
1	2	1	2
It should be noted that the input snapshots to the premises of rule exp par
have no state element or active role in common: they are independent. They both rely on the same signature Σ since unrelated state objects and active roles may in general refer to the same constants. The application of a basic step can at most extend the initial signature Σ (see the Signature Extension Lemma 5.1 and Lemma 5.2 below), which justifies expressing the signature output by the two premises as (Σ, Σi), for i = 1, 2. We can always choose the newly generated names so that Σ1 and Σ2 do not declare the same constant: under this assumption, (Σ, Σ1, Σ2) is structurally a well-formed signature.
The last judgment we will consider iterates one-step parallel firings. It is expressed as follows:
P d C =⇒∗ C'	Multi-step parallel ﬁring
Similarly to multi-step sequential firing, it is obtained by taking the reflexive and transitive closure of its one-step restriction:
P d C =⇒ C'	P d C' =⇒∗ C''



P d C =⇒∗ C
exp it0
P d C =⇒∗ C''
exp itn

We now extend the Signature Extension Lemma 5.1 to parallel firing. Again, we write P d C =⇒(∗) C' to indicate that we are considering the one-step (P d C =⇒ C') and the multi-step (P d C =⇒∗ C') versions of the parallel firing judgment at once.
Lemma 5.2 (Signature Extension)
Let Σ and Σ' be signatures, P a protocol theory, S and S' states, and R
and R' active role sets. If	P d [S] R =⇒(∗) [S'] R' ,	then	Σ' = (Σ, Σ'') for
some signature Σ''.
Proof: This result is proved by induction hypothesis on the given premise. An appeal to Lemma 5.1(2) and to the induction hypothesis is needed to justify the form of the premises of rule exp par.	✷


Admissibility of Parallel Firing
We now turn to proving that parallel firing can be emulated by sequential execution. The proof of this property relies on a number of simple lemmas, the first of which, given below, states that term typing is invariant with respect to weakening: if a term is typable in a signature, it remains typable when considering additional declarations.

Lemma 5.3 (Weakening Term Typing)
Let (Σ, Σ'') be a signature, t a term and τ a type. If  (Σ, Σ'') ▶ t : τ, then  (Σ, Σ', Σ'') ▶ t : τ  for any signature Σ'.
Proof: The proof proceeds by induction on the structure of a derivation T of the given judgment. It is uncondionally valid when the last (and only) rule of T is mpt a. It relies on immediate appeals to the induction hypothesis in the other cases (rules mtp ss, mtp cnc, mtp ske and mtp pke).	✷

We nowcome to the central lemma in the proof of the admissibility of the rules for parallel firing. It asserts that not only signatures, but also states and active role sets can be weakened in an execution judgment, without influencing its derivability. The first result in this lemma is needed in the proof of the remaining two.
Lemma 5.4 (Weakening Execution)
Let Σ and Σ'' be signatures, rhs the right-hand side of a rule, lhs a predicate sequence, P be a protocol theory, S and S'' states, and R and R'' active role sets. For any signature Σ', state S' and active role set R',
if  (rhs)Σ   (lhs)Σ,Σ'' ,  then  (rhs)Σ,Σ'   (lhs)Σ,Σ',Σ'' .

if	P d [S] R
if	P d [S] R
(∗)	'' R''
Σ,Σ''
(∗)	'' R''
Σ,Σ''
,	then	P d [S, S'] R,R'
,	then	P d [S, S'] R,R'
(∗)	'	'' R',R''
Σ,Σ',Σ''
(∗)	'	'' R',R''
Σ,Σ',Σ''

Proof: We proceed by induction on the structure of a derivation for the antecedent of each result. In (1), the property is immediate for rule exs seq and is obained by application of the induction hypothesis for rule exs nnc. We proceed similarly in the case of (2), except that we make use of (1) for rule exs rule and of Lemma 5.3 for rules exs grole and exs all. The treatment of (3) is again similar: it should be noted that the state and active role sets extensions (S' and R' respectively) can be split arbitrarily in the premises of rule exp par.	✷

We can nowprove our admissibility result: an arbitrary parallel execution can be simulated by sequential firing sequences. Unsurprisingly, the reverse of this property holds as well: any sequential execution can be lifted to a (degenerate) form of parallel firing.
Theorem 5.5 (Admissibility of Parallel Execution)
Let P be a protocol theory, and C and C' two snapshots. If PdC =⇒(∗) C', then PdC −→∗ C'.  Viceversa, if PdC −→(∗) C', then PdC =⇒(∗) C'.
Proof: In its forward direction, the proof of this result proceeds by induction on the structure of a given derivation E of the judgment P d C =⇒(∗) C'. We will examine the one-step case in detail, but omit the simple proof of its

multi-step extension. We proceed by cases on the last rule of E : for single-step parallel firing, only rules exp id and exp par need to be considered.
E = 	 exp id
P d C =⇒ C
with C' = C.
The result is obtained by instantiating rule exs it0 with the same param- eters.


E1
'
P d [S ] R1  −→ [S' ] R
E2
'
P d [S ] R2  =⇒ [S' ] R

1 Σ	1
E =
Σ,Σ'
2 Σ	2
'	'
Σ,Σ'
exp par

P d [S ,S ] R1,R2  =⇒ [S' , S' ] R1,R2

1	2 Σ
1	2 Σ,Σ' ,Σ'

with C = [S ,S ] R1,R2
1  2
and C' = [S' , S' ] R' ,R'	.

1	2 Σ
1	2 Σ,Σ' ,Σ'

1  2
The proof of this case consists of the following transformations, where the first column gives a name to the derivation of the judgment in the second column:

E' :: P d [S1, S2] R1,R2
'	R' ,R2
1	2 (Σ,Σ' )
by the Weakening Lemma 5.4(2) on E1,

E∗ :: P d [S ] R2
−→∗ [S' ] R'
by induction hypothesis on E ,

2	2 Σ	2 (Σ,Σ' )	2

E'  :: Pd[S' ,S ] R' ,R2 −→∗ [S' , S' ] R' ,R'
by the Weakening Lemma 5.4(3)

2	1	2
Σ,Σ'
1	2 (Σ,Σ' ,Σ' )

1	1  2
on E∗,

E'  :: Pd[S ,S ] R1,R2 −→∗ [S' , S' ] R' ,R'
by rule exs itn on E'
and E' .

1	2 Σ
1	2 (Σ,Σ' ,Σ' )	1	2

1  2
Observe that a single-step parallel firing is mapped to a multi-step sequential execution. The multi-step parallel case builds on the result we just proved and is obtained by a simple induction on the derivation E .
The reverse direction of this theorem is proved as follows: we wrap each one-step sequential firing with one application of rule exp par by means of an instance of rule exp id with empty state and active role set. The multi-step case mimicks the corresponding sequential construction with parallel iteration rules.	✷

It should be observed that this proof does not operate directly on the rules that implement the one-step sequential execution judgment. Therefore, this relation can be altered at will without invalidating this theorem, as long as Lemma 5.4 still holds.
This result allows us to focus our efforts on the rules for sequential exe- cution: any property proved valid for the sequential case can immediately be ported to the parallel setting by using the appropriate direction of the above theorem. This does not mean, however, that we should do without parallel execution and eliminate its rules from our formalization: this form of execu-

tion is more faithful to the behavior of protocols in a distributed environment and therefore constitutes a more adequate model of their execution. The fact that parallel execution can be serialized does not imply that the resulting sequential behavior is better and should be adopted.
Changes
As done at the end of the previous major subdivisions of this paper, we con- clude this section with a discussions of the changes in the execution seman- tics of MSR with respect to previous versions of this formalism, as presented in [8,9].
In our previous work, the basic execution step of MSR consisted in the application of a protocol rule: instantiation of the variables appearing in its left-hand side happened by pattern matching with the current state, fresh constants were substituted for the existential parameters in its con- sequent and any additional variable was instantiated before installing the resulting right-hand side back into the state. Since rules were not threaded, there was no need to load an active role set before execut- ing them, nor was there any point in “skipping” a rule. The execution model discussed in this paper has clearly a finer grain. This is due to two reasons: on the one hand, our more detailed specification calls for a precise description of how execution actually happens. In particular, we make the instantiation of each variable individually observable (rule exs all) and separate this process from the actual application of a rule (rule exs rule). On the other hand, special provisions are required to handle some novelties of our syntax, in particular the possible threading of protocol rules in a role (rule exs skp), the presence of a distinguished role owner (rules exs arole and exs grole), and the notion of active role (rule exs dot).
In [8,9], the universal variables (then implicitly quantified) were instan- tiated by pattern matching at the time a rule was applied. Our current model is apparently more non-deterministic in that it relies on some guess work to instantiated these objects before the current state is accessed. As already said, this model is purposefully abstract and not intended as the basis for an implementation. We should however observe that [8,9] did not discuss how variables that appear only in the consequent of a rule ought to be instantiated, while our current proposal treats them trans- parently. This is the subject of future work.
As mentioned in Section 4, our earlier work on MSR demanded that the graph obtained by chasing the role state predicate names in a specifica- tion be acyclic. This eliminated the possibility of roles executions that required an unbounded number of steps, a major simplification in the proofs of the decidability results of [8,15]. Our present syntax admits roles where the corresponding graphs contain cycles. It should however

be noted that our execution model prevents taking advantage of them to implement a looping behavior: parametricity makes role state predicates unique to each individual invocation of a role. The rules in an active role, which realize this property, are however processed sequentially without any possibility of jumping back. Still, iteration is possible in MSR thanks to the introduction of memory predicates. This will be demonstrated in Section 6.
In the previous versions of MSR, the notion of execution was limited to sequential firing of rules. Parallel execution is therefore a novelty of this paper.
Intruder Models
In this section, we will demonstrate the expressive power of MSR by formaliz- ing what has come to be accepted as the standard abstraction of the attacker: the Dolev-Yao intruder [20,14]. More precisely, we define the Dolev-Yao ab- straction and the natural intruder model it induces in Section 6.1. We then provide a direct MSR encoding in Section 6.2. We conclude in Section 6.3 by presenting an optimized variant of the Dolev-Yao intruder model and hinting at its correctness.
Differently from what happens when specifying actual security protocols, all the roles we will need in this paper consist of a single rule. We will represent a role using the format in the following diagram, where we find it convenient to list the elements of its four blocks in columns.



	→
Owner





We will mark types that can be reconstructed from the other information present in a rule by denoting them in a shaded font. We will provide informal reasons in support of these elision, but we reserve a formal treatment of type reconstruction in the context of MSR to a future publication.
The Dolev-Yao Intruder Model
The Dolev-Yao abstraction of a crypto-protocol appears to be drawn from po- sitions taken in [20] and from a simplified model presented in [14]. It assumes that such elementary data as principal names, keys and nonces are atomic rather than strings of bits, as implemented in practice. Furthermore, it views the operations needed to assemble messages, i.e. concatenation, encryption and digital signature, as pure constructors in an initial algebra. Therefore, if n is a nonce and k a key, {n}k is a composite object whose structure is clearly recognizable. This means for example that a term of the form {t}k cannot be

mistaken for a concatenation (t1 t2), and that {t}k = {t }k' if and only if t = t and k = k'. This also means that the Dolev-Yao model abstracts away the details of the cryptographic algorithms in use, reducing in this way encryption and decryption to atomic operations. Indeed, it is often said to adopt a black box viewon cryptography.
The atomicity and initiality of the Dolev-Yao abstraction limits consider- ably the attacks that can be mounted against a protocol. In particular, its idealized encryption model makes it immune to any form of crypto-analysis: keys cannot be exhaustively searched, piecewise inferred from observed traf- fic, or guessed in any other manner. An encrypted message can be deciphered only when in possession of the appropriate key. The symbolic nature of this abstraction allows then to very precisely circumscribe the operations an in- truder has at his disposal to enact an attack against a protocol. All together, they define what has become to be known as the Dolev-Yao intruder. This attacker can do any combination of the following eight operations that we find convenient to organize in the five lines below:


Intercept and learn messages
Decompose concatenated messages he has learnt
Decipher encrypted messages if he knows the keys
Transmit known messages
Concatenate known messages

Encrypt	known	messages	with known keys

Access public information
Generate fresh data
The first line implies that the Dolev-Yao intruder has complete control of the network. This is clearly a worst case scenario.
MSR is a clear instance of the the Dolev-Yao abstraction. Elementary data are indeed atomic, message are constructed by applying symbolic operators, and the criterion for identifying terms is plain syntactic equality. We will now give a specification of the Dolev-Yao intruder in MSR. More specifically, we describe the attacker discussed above in this section. In Section 6.3, we will give an encoding to an optimized version of this attacker proposed in [19] and formalized using a previous version of MSR in [8].

An MSR Speciﬁcation of the Dolev-Yao Intruder
It has been proved that there is no advantage in considering more than one Dolev-Yao adversary in any given system [23]. Therefore, we select a principal, I say, and endowhim with the powers of the Dolev-Yao intruder.
Since the intruder can learn and manipulate information, he must be able to store data out of sight from other principals. This is easily achieved in MSR by associating I with a memory predicate MI( ) whose single argument can hold a message. A signature for this model must therefore contain the

following two declarations:
I : principal	and	M : principal × msg
On the basis of this declarations, we will express each of the intruder’s capabil- ities as one or more roles consisting of a single rule. Each of these roles will be anchored at I and altogether model the actions that the Dolev-Yao intruder can undertake to mount an attack. Thus, the knowledge of the intruder is represented in a distributed fashion as a collection of memory predicates of the form MI(t) for all known terms t.
The first line of the description of the Dolev-Yao intruder is then expressed by the following two roles, anchored on I. With the rule on the left, the in- truder can capture a network message N(t) and store its contents in a memory predicate. Observe that the execution semantics of MSR implies that N(t) is removed from the current state and therefore this message is not available any more to the principal it was supposed to reach. The rule on the right emits a memorized message out in the public network.
 ∀t : msg. N(t)	→	M (t) I	 ∀t : msg. M (t)	→	N(t) I
From now on, we will only be concerned with the memory predicate MI, which acts as a workshop where the intruder can dismantle intercepted com- munications and counterfeit messages. Concatenated messages do not offer any barrier to the intruder: he can take them apart at will. Similarly he can construct the concatenation of any two messages he knows. This is realized by the following two rules:
M (t ) I
MI(t2)
M (t )	 I
MI(t2)
The third line of the specification of the Dolev-Yao intruder, at the begin- ning of this section, states that I must know the appropriate decryption keys in order to access the contents of an encrypted message. Dually, he must be in possess of the correct key in order to perform an encryption. The following two rules formalize this requirement in MSR in the case of shared-key codings:

∀A, B : principal.
I
MI({t}k)

∀k : shK A B.
∀t : msg.
MI(k)	→	MI(t)

∀A, B : principal. MI(t)	

∀k : shK A B.
∀t : msg.
MI(k)	→	MI({t}k)


Both for taking apart and constructing a shared-key encrypted message, the intruder must know the key. Observe that most typing information can be inferred assuming that the specification at hand it well-typed [4]. Take for example the role on the left. In order for the message {t}k to be well-formed, k must be a shared key between two principals. Thus its type must be shK AB and the type of the dependent arguments A and B has to be principal. An algorithmic description of howtype reconstruction is performed is the subject of future work.
The treatment of public-key cryptography is similar. Notice that here the intruder must have access to a private key for decrypting, while the public key is sufficient for generating encrypted messages.

∀A : principal.
∀k: pubK A.
∀k' : privK k.
∀t : msg.

MI({{t}}k) MI(k')
I

→	MI(t)

∀A : principal.
I
MI(t)

∀k : pubK A.
∀t : msg.
MI(k)	→	MI({{t}}k)

Again, most typing information can be reconstructed on the base of the struc- ture of the terms present in this rule. The reasoning proceeds as in the case of shared keys.
We now tackle the often overlooked fourth line of the Dolev-Yao intruder specification above: the ability to access public information. He should clearly be entitled to look up the name and public keys of principals, but any at- tempted access to more sensitive information such as private keys should be forbidden. The clear exception to this rule consists of the keys he is indepen- dently entitled to look up, namely his own private key and keys he shares with other principals. This situation is therefore implemented by the following five rules:



  ∀A : principal.
 ∀A : principal. ·	→	M (A) I
 I	 ∀A : principal.	 I


  ∀A : principal.	 I	 ∀k : pubK I.	 I
	  
It should be observed that there is a close connection between these rules and the access control policy induced by the term language at hand [3]. In particular, the capabilities of the intruder with respect to public information access always correspond to the strongest rules that satisfy the access control policy.

The last line of the specification of the Dolev-Yao intruder hints at the fact that he should be able to create fresh data. We must be very careful when implementing this requirement: in most scenarios, it is inappropriate for I to generate a shared key k∗ between two principals A and B since this would result in unwanted trivial attacks where A and B use k∗ instead of their legitimate shared key kAB (this would be very close to permitting the intruder to guess keys). In general, we do not allow the intruder to generate keys. Similarly, the adversary should not be entitled to create newprincipals. Nonces and atomic messages are instead risk-frees. Therefore, we propose the following two rules:
  ·	→	∃n : nonce. M (n) I	 ·	→	∃m : atm. M (m) I
Observe that the rationale behind these two rules, although reasonable, may conflict with idiosyncrasies of individual protocols. For example, the full ver- sion of the Needham-Schroeder protocol specified in [4] may be more accu- rately validated in the presence of an intruder who can create public keys (but not the corresponding private keys). Therefore, depending on the proto- col at hand, any of the following rules may be included in the specification of the Dolev-Yao intruder:
 ∀A, B : principal. ·	→	∃k : shK A B. M (k) I
 ∀A: principal. ·	→	∃k : pubK A. M (k) I

∀A : principal.
∀k: pubK A.
I
·	→	∃k' : privK k. MI(k')

A similar rule for principals seems harder to justify since protocols never generate principals, at least not in the simple setting contemplated in this paper.
We provide our formalization of the Dolev-Yao intruder with two admin- istrative rules to allowhim to take full advantage of the above stated capabil- ities. The rule below on the left allows him to forget information. The more interesting rule on the right permits duplicating and reusing fabricated data.

 I	 
M (t) I


Last, we have two seldom needed rule schemata that allow the intruder to shuffle data between the knowledge predicate MI( ) used above and other memory predicates he may have. It is in general unnecessary for the standard Dolev-Yao intruder to rely on additional memory predicates. Here, we write M' for a generic intruder memory predicate with n + 1 arguments. We have the following role patterns, where i is an index between 2 and n + 1:

∀t1 : τ1.
I
M'(t1,..., tn)

··· 
∀tn : τn.
M'(t1,..., tn)	→
I
MI(ti)

∀t1 : τ .
I
1

··· 
M'(t1,..., tn)
'	'	

	I '	→	MI (t1,..., ti,..., tn)
∀tn : τn. MI(ti)
∀t' : τi.
The rule on the right replaces the argument ti of the memory predicate on its antecedent with t' in its consequent.
This concludes the MSR formalization of the Dolev-Yao intruder. A few aspects of this encoding deserve to be emphasized:
This specification lies fully within MSR and can therefore be adapted, were the protocol at hand to require it. This differs from many specifi- cation languages which either hardwire the intruder, or express him in a language different from the protocol under examination. It should be observed that our previous version of MSR belonged to this latter class: although the specification of the intruder was subject to the same exe- cution semantics as the other roles, it could not be specified in the same way as regular principals.
Typing allows a very precise characterization of what the intruder’s ca- pabilities actually are. This is clearly manifested in the rule clusters that formalize access to public information and fresh data generation.
All but the fresh data generation rules can be automatically generated from the term language, and their typing [4] and access control rules [3]. We conjecture that which fresh data generation rules are admissible is de- pendent on the protocol the intruder is running against. In turn, this may be realized by constraining the fresh data that a principal can generate by imposing a stricter access control policy.

An Optimized Dolev-Yao Intruder
The role set given in the previous section provides a declarative specification of the capabilities of the Dolev-Yao intruder. It is however too non-deterministic to stand as a basis for the form of model-checking simulation needed to an- alyze protocols, possibly uncovering attacks. We will now present a more operational variant of the Dolev-Yao intruder that eliminates a useless con- sequence of this non-determinism: looping behaviors caused by the intruder assembling a message and then taking it apart, and then recomposing it, etc. ad inﬁnitum.
Whenever the adversary intercepts a message, we will have him decompose it in its most elementary bits, store them in a dedicated memory predicate, and construct any message intended for transmission from stored elementary terms, without the possibility of undoing his own work. We therefore partition the actions of the intruder in three distinct activities: message decomposition, storage of elementary information, and message construction. This idea was first proposed in [19] and analyzed in an earlier version of MSR in [8].

We replace the single memory predicate MI( ) used in Section 6.2 with three predicates, DI( ), AI( ) and CI( ). The first is intended to contain messages while they are Decomposed into their elementary constituents. The second holds the Atomic terms learnt in this way. The third is used in the message Construction phase. Our signature shall therefore contain the following four declarations:
I : principal
D : principal × msg A : principal × atm C : principal × msg
The interception and transmission rules are updated as follows:
 ∀t : msg. N(t)	→	D (t) I	 ∀t : msg. C (t)	→	N(t) I
Observe that an intercepted message is placed in the decomposition memory predicate since it must be disassembled before its elementary constituents can be used. Dually, only constructed messages can be transmitted over the public network. This is enforced by having a construction predicate in the antecedent of the rule on the right.
The rules that dealt with composite message in Section 6.2 are adapted by replacing the generic MI( ) predicate with the appropriate refinement. When decomposing a message, its components may need further disassembling. Du- ally, messages intended for transmission are built by putting together con- structible pieces. Keys constitute an exception to this rule: they are clearly atomic and therefore can be accessed from the A predicate where such infor- mation is stored. We also need to copy them to the consequent of rules so that the intruder can use them again for other encryptions (as we will see shortly, this optimized scheme does without an explicit duplication rule).
D (t ) I	C (t )	 I


∀A, B : principal.
DI(t2)

DI({t}k)


I
DI(t)
CI(t2)

∀k : shK A B.
∀t : msg.
AI(k)	→	AI(k)

∀A, B : principal.

CI(t)
I
CI({t}k)


∀A : principal.
∀k : shK A B.
∀t : msg.
AI(k)	→
I
AI(k)	

∀k: pubK A.
∀k' : privK k.
∀t : msg.
DI({{t}}k) AI(k')
DI(t)
→	AI(k')



∀A : principal.
∀k : pubK A.
∀t : msg.

CI(t)	→
AI(k)
I
CI({{t}}k) AI(k)

It should be observed that the above rules do not apply to situations where the intruder does not knowthe decryption key of a ciphered message. We will treat this case shortly.
Once a captured message has been reduced to its atomic constituents, they are memorized in individual A predicates by the following rule:
I
∀a : atm. DI(a)	→	AI(a)
The atomicity of the decomposable message in this rule is enforced by assigning type atm to the variable a.
As observed earlier, not all terms can be decomposed into to their atomic constituents. In particular encrypted message cannot be exposed unless the intruder has access to the proper decryption key. The following rule is intended to deal with this situation. Here, a message t being disassembled is promoted as a constructible term. Notice that a copy of t is is kept in the decomposition queue in the eventuality that later captured information may allow breaking t into more elementary pieces.


 ∀t : msg. DI(t)	→
I
I
CI(t)

It should be observed that this rule provides a loophole in the scheme discussed in this section since it allows any message to transit from the decomposition pool to the construction queue without accessing its atomic components. To avoid this, it would be tempting to specialize this rule to the situations where t is indeed an encrypted message. This would however violate the access control policy in [3]. A precise specification that avoids these problems requires modifying the language underlying MSR to allowfor partial pattern matching and negative patterns, which are the subject of current research.
The next rule makes an atomic component available as a constructible message. Copying is required since this object could be needed again later.


 ∀a : atm. AI(a)	→

I
I
CI(a)

We continue with the rules that allow accessing public information and create fresh data. The changes with respect to the rules presented in the previous section is limited to replacing the memory predicate M with A , since the objects under consideration are atomic.
 ∀A : principal. ·	→	A (A) I

  ∀A : principal.	 I	 ∀A : principal.	 I

  ∀A : principal.	 I	 ∀k : pubK I.	 I
	  


I
→	∃n : nonce. AI(n)
I
→	∃m : atm. AI(m)

We conclude with the rules handling generic n + 1-ary memory predicates
' the intruder may have. We treat them as if the terms they record were
coming from the network: we read them into the decomposition queue, and store them back from the construction stack. Clearly, these rules can be specialized whenever we have additional information on the data stored in each argument of M'. In particular, atomic terms can be read to and from the AI( ) predicates. We have the following two schematic roles, where i is an index in 2,...,n + 1:

∀t1 : τ1.
	'
I

→	I	

	···	MI (t1,..., tn)
D (t )	

∀tn : τn.

∀t1
I  i


I
: τ1.

··· 
M'(t1,..., tn)
'	'	

	I '	→	MI (t1,..., ti,..., tn)
∀tn : τn. CI(ti)
∀t' : τi.
It should be noted that we have structured the above rules in such a way that no explicit copying rule is ever needed: whenever atomic or decomposable information is accessed for constructing an outgoing message, we always leave a copy for future use. On a similar note, we omit the deletion rule of Section 6.2: this version of the Dolev-Yao intruder only accumulate information, never eliminates it.
Proving the correctness of this optimized intruder model with respect to the role set presented in Section 6.2 is a rather simple task: indeed, mapping the specialized predicates DI( ), AI( ) and CI( ) back to MI( ) yields a set of rules that is almost identical to our original role set for the Dolev-Yao intruder. The minor discrepancies brought about by this translation are corrected by uses of the structural rule of deletion, and the elimination of one redundantly produced rule, whose antecedent and consequent are identical. Alternatively, this property can be seen as an instance of a more general result that states that the Doley-Yao intruder model subsumes every other intruder model that plays by the rules of the Dolev-Yao abstraction. This theorem is formally proved in [3].

The proof of the corresponding completeness result, which shows that our optimized model is powerful enough to simulate the original Dolev-Yao in- truder, is instead quite complex on the basis of the definitions given in this paper. The intuitively simple translation of runs into the optimized model is complicated by the need to perform context-dependent permutations between rule applications. Keeping track of firing dependencies among rules, while abstracting from unrelated rules that happen to be interleaved with them, is not handled elegantly in our execution model. Proofs of these forms call for a more abstract viewof execution, that chains together cooperating rules. Strand spaces [16] have those qualities and we are currently developing a sim- ilar model on top of our current execution rules. The core of this proof in the context of strand spaces can indeed be found in [17].

Conclusions and Future Work
In this paper, we have presented the execution model of MSR, a strongly-typed framework for the specification of security protocols. MSR extends previous attempts at using multiset rewriting for formalizing crypto-protocols [8,15,9] with the introduction of dependent types as a simple and effective mechanism for expressing relations among objects (e.g. between a key and its owner), and by permitting rules to mention memory predicates that allow a principal to store data that survives role termination. The typing infrastructure of MSR is discussed in detail in [4] while the related notion of access control is the subject of [3]. Memory predicates are a powerful mechanism that enables the specification of protocols consisting of a set of coordinated subprotocols that exchange data and pass control [5]. The intruder model that best fits the analysis of a given protocol is indeed expressed as a collection of such subprotocols that communicate through dedicated memory predicates. We exemplified this feature by presenting two detailed specifications of the Dolev- Yao intruder [20,14]. The execution model of MSR is based on parallel multiset rewriting. We proved the admissibility of this approach with respect to the interleaving model that we considered in our previous work [8,9].
In addition to the execution model presented here, MSR also embeds an extensive type system, fully discussed in [4], as well as a set of judgments and rules that formalize the notion of access control [3]. In the near future, we plan to develop MSR in three directions. First we want to extend our collection of case studies [5] to encompass not only the most popular authentication proto- cols [10], but also fair exchange protocols and schemes developed for achieving secure multicast (we are currently formalizing the OFT key management pol- icy [2]). Second, we are developing an operational execution model as a basis for simulation and model checking. This involves in particular delaying the instantiation of universal variables to limit non-determinism. Still on the pragmatic terrain, we are devising support for type reconstruction aimed at speeding up the correct formalization of a protocol. Third, we are designing a

flexible strand-like notation to describe protocol runs [16,17]. This is intended to simplify formal reasoning on chains of dependent rule applications while abstracting from non-interfering rules that may happen to be interleaved with them.

References
David Aspinall and Adriana Compagnoni.  Subtyping dependent types.  In
E. Clarke, editor, Proceedings of the 11th Annual Symposium on Logic in Computer Science, pages 86–97, New Brunswick, New Jersey, July 1996. IEEE Computer Society Press.
David Balenson, David McGrew, and Alan Sherman. Key management for large dynamic groups: One-way function trees and amortized initialization. Internet Draft (work in progres), draft-irtf-smug-groupkeymgmt-oft-00.txt, Internet Engineering Task Force (August 25, 2000).
Iliano Cervesato. MSR, access control, and the most powerful attacker. Unpublished manuscript. Accessible from the author’s web page at http://www.cs.stanford.edu/~iliano/.
Iliano Cervesato. A specification language for crypto-protocol based on multiset rewriting, dependent types and subsorting. Unpublished manuscript. Accessible from http://www.cs.stanford.edu/~iliano/.
Iliano Cervesato.  Typed MSR: Syntax and examples.  In V. Gorodetski,
V. Skormin, and L. Popyack, editors, Proceedings of the First International Workshop on Mathematical Methods, Models and Architectures for Computer Network Security — MMM’01, St. Petersburg, Russia, 21–23 May 2001. Springer-Verlag LNCS.
Iliano Cervesato, Nancy A. Durgin, Max Kanovich, and Andre Scedrov. Interpreting strands in linear logic. In 2000 Workshop on Formal Methods and Computer Security — FMCS’00, Chigaco, IL, July 2000.
Iliano Cervesato, Nancy A. Durgin, Patrick D. Lincoln, John C. Mitchell, and Andre Scedrov. Relating strands and multiset rewriting for security protocol analysis. Long version of [9]; forthcoming.
Iliano Cervesato, Nancy A. Durgin, Patrick D. Lincoln, John C. Mitchell, and Andre Scedrov. A meta-notation for protocol analysis. In P. Syverson, editor, Proceedings of the 12th IEEE Computer Security Foundations Workshop — CSFW’99, pages 55–69, Mordano, Italy, June 1999. IEEE Computer Society Press.
Iliano Cervesato, Nancy A. Durgin, Patrick D. Lincoln, John C. Mitchell, and Andre Scedrov. Relating strands and multiset rewriting for security protocol analysis. In P. Syverson, editor, 13th IEEE Computer Security Foundations Workshop — CSFW’00, pages 35–51, Cambrige, UK, July 2000. IEEE Computer Society Press.


John Clark and Jeremy Jacob. A survey of authentication protocol literature. Technical report, Department of Computer Science, University of York, 1997. Web Draft Version 1.0 available from http://www.cs.york.ac.uk/~jac/.
Ph. de Groote, editor. The Curry-Howard Isomorphism, volume 8 of Cahiers du Centre de Logique, D´epartement de Philosophie, Universit´e Catholique de Louvain. Academia, 1995.
Grit Denker, Jonathan Millen, A. Grau, and J. Filipe. Optimizing protocol rewrite rules of CIL specifications. In P. Syverson, editor, 13th IEEE Computer Security Foundations Workshop — CSFW’00, pages 52–62, Cambrige, UK, July 2000. IEEE Computer Society Press.
Grit Denker and Jonathan K. Millen.	CAPSL Intermediate Language.	In
N. Heintze and E. Clarke, editors, Proceedings of the Workshop on Formal Methods and Security Protocols — FMSP, Trento, Italy, July 1999.
Danny Dolev and Andrew C. Yao. On the security of public-key protocols.
IEEE Transactions on Information Theory, 2(29):198–208, 1983.
Nancy Durgin, Patrick Lincoln, John Mitchell, and Andre Scedrov. Undecidability of bounded security protocols. In N. Heintze and E. Clarke, editors, Proceedings of the Workshop on Formal Methods and Security Protocols
— FMSP, Trento, Italy, July 1999.
F. Javier Thayer Fa´brega, Jonathan C. Herzog, and Joshua D. Guttman. Strand spaces: Why is a security protocol correct? In Proceedings of the 1998 IEEE Symposium on Security and Privacy, pages 160–171, Oakland, CA, May 1998. IEEE Computer Society Press.
Joshua Guttman and Javier Thayer Fa´brega. Authentication tests and the normal, efficient penetrator. Theoretical Computer Science, 2001. To appear.
Robert Harper, Furio Honsell, and Gordon Plotkin. A framework for defining logics. Journal of the Association for Computing Machinery, 40(1):143–184, January 1993.
Will Marrero, Edmund M. Clarke, and Somesh Jha. Model checking for security protocols. In Proceedings of the 1997 DIMACS Workshop on Design and Formal Veriﬁcation of Security Protocols, 1997. A Preliminary version appeared as Technical Report TR-CMU-CS-97-139, Carnegie Mellon University, May 1997.
R.M. Needham and M.D. Schroeder. Using encryption for authentication in large networks of computers. Communications of the ACM, 21(12):993–999, 1978.
B. Clifford Neuman and Stuart G. Stubblebine. A note on the use of timestamps as nonces. Operating Systems Review, 27(2):10–14, April 1993.
Frank Pfenning. Refinement types for logical frameworks. In Herman Geuvers, editor, Informal Proceedings of the Workshop on Types for Proofs and Programs, pages 285–299, Nijmegen, The Netherlands, May 1993.


Paul Syverson, Catherine Meadows, and Iliano Cervesato. Dolev-Yao is no better than Machiavelli. In P. Degano, editor, First Workshop on Issues in the Theory of Security — WITS’00, pages 87–92, Geneva, Switzerland, 7-8 July 2000.


Collected Rules
This appendix collects the grammatical productions, judgments and rules used throughout the paper for the convenience of the reader. More specifically, the syntax of MSR is summa- rized in Section A.1. The minimal typing infrastructure needed in this paper is displayed in Section A.2. The definition of substitution for MSR is given in Section A.3. Finally, we collect the executions judgments of our language and associated inference rules in Sec- tion A.4. For the convenience of the reader, we specify the page number where each notion is first introduced.


Syntax

| lhs, MA(→t ) (Extension with a memory predicate)


Right-Hand sides: rhs ::= lhs	(Sequence of message predicates)	[p. 14]
| ∃x : τ. rhs (Fresh data generation)

| P, ρ∀A	(Extension with a generic role)
| P, ρA	(Extension with an anchored role)

Active role sets: R	::= ·	(No active role)	[p. 16]
| R, ρA	(Extension with an instantiated role)
Signatures: Σ	::= ·	(Empty signature)	[p. 7]
| Σ, a : τ	(Atomic message declaration)
| Σ, Ll : →τ	(Local state predicate declaration)	[p. 11]
| Σ, M : →τ (Memory predicate declaration)	[p. 11]
Snapshot: C	::= [S] R	[p. 20]

A.2	Typing Rules
τ :: τ′	τ is a subsort of τ′	[p. 6] Σ ▶ t : τ	Term t has type τ in signature Σ	[p. 7]



ss atm
	 ss pr		 ss nnc

atm :: msg
principal :: atm
nonce :: atm





shK AB :: atm
ss shK


pubK A :: atm
ss pbK


privK k :: atm
ss pvK




Σ ▶ t1 : msg	Σ ▶ t2 : msg
	 mtp cnc
Σ ▶ t1 t2 : msg

Σ ▶ t : msg	Σ ▶ k : shK AB 


Σ ▶ {t}k : msg
Σ ▶ t : τ′	τ′ :: τ


mtp ske
Σ ▶ t : msg	Σ ▶ k : pubK A


Σ ▶ {{t}}k : msg

mtp pke

	 mtp ss
Σ ▶ t : τ
	 mtp a
(Σ,a : τ, Σ′) ▶ a : τ


Substitutions






Execution Rules
(rhs)Σ  (lhs)Σ'
rd [S] Σ  [S′] Σ'
P d C −→ C′ P d C −→∗ C′ P d C =⇒ C′ P d C =⇒∗ C′



([a/x]rhs)(Σ,a:τ)   (lhs)Σ'
	 exs seq		 exs nnc
(lhs)Σ  (lhs)Σ	(∃x : τ. rhs)Σ  (lhs)Σ'



Σ ▶ t : τ	[t/x]rd [S] Σ   [S′] Σ'




exs all

(rhs)Σ  (lhs )Σ'
	 exs core

(∀x : τ. r) d [S] Σ  [S′] Σ'
′
(lhs → rhs) d [S, lhs] Σ  [S, lhs ] '






exs arole
Σ ▶ A : principal

exs grole

(P, ρA) d [S] R
−→ [S] R,ρA
(P, ρ∀A) d [S] R
−→ [S] R,([A/A]ρ)A


	 exs rsp
	r d [S] Σ  [S′] Σ'	
exs rule

P d [S] R,(∃L:→τ. ρ)A
R,([Ll/L]ρ)A
(Σ,Ll:→τ )
P d [S] R,(r,ρ)A
−→ [S′] R,(ρ)A


P d [S] R,(r,ρ)A

−→ [S] R,(ρ)A
exs skp

P d [S] R,(·)A

−→ [S] R
exs dot







P d C −→∗ C

exs it0
P d C −→ C′	P d C′ −→∗ C′′

P d C −→∗ C′′

exs itn





P d [S1] R1
′ R'
(Σ,Σ1)
P d [S2] R2
'
2
2 (Σ,Σ' )

exp id
	 exp par

(R1,R2)
′	′ (R' ,R' )


P d C =⇒ C
P d [S1, S2] Σ	=⇒ [S1, S2]
1  2
(Σ,Σ' ,Σ' )







P d C =⇒∗ C

exp it0
P d C =⇒ C′	P d C′ =⇒∗ C′′

P d C =⇒∗ C′′

exp itn
