Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 354 (2020) 171–186
www.elsevier.com/locate/entcs


Gradual Typing Using Union Typing With Records
Karla Ramírez Pulido1 Jorge Luis Ortega-Arjona2 Lourdes del Carmen González Huesca3
Departamento de Matemáticas, Facultad de Ciencias UNAM, Circuito Exterior S/N,
Cd. Universitaria 04510, CdMx, México

Abstract
Dynamic typed languages are characterized by their expressiveness and flexibility to develop prototypes, while static typed languages allow early detection of errors and the optimization of source code. Gradual typing languages allow programmers to make use of both approaches, static and dynamic typing, and thus, obtaining the advantages that both represent.
The objective here is to revisit the static part of the approach to a gradual interpretation of union types based on the design of Gradual Union Types through an extension with the record data-structure. This contributes to understand the abstraction and reasoning behind Gradual Typing in order to have useful future extensions for other data-structures.
Keywords: Gradual typing, Union types, Records


Introduction
Commonly, programming languages can be broadly categorized according to their typing as static or dynamic. Nevertheless, there are other typing classifications that allow to mix typing features between both static and dynamic extremes, such as hybrid typing and gradual typing [15]. In particular, gradual typing languages allow programmers to make use of static and dynamic typing, and thus, obtaining the advantages that both represent.
Gradual typing makes use of typed and untyped code in the same language. The concept has been proposed by Siek and Taha in 2006 [15], who expose the idea that mixing dynamic and static features in a single language may improve

1 Email: karla@ciencias.unam.mx
2 Email: jloa@ciencias.unam.mx
3 Email: luglzhuesca@ciencias.unam.mx

https://doi.org/10.1016/j.entcs.2020.10.013
1571-0661/© 2020 The Author(s). Published by Elsevier B.V.
This is an open access article under the CC BY-NC-ND license (http://creativecommons.org/licenses/by-nc-nd/4.0/).

the intrinsic typing characteristics of such a programming language. Having explicit types can guarantee certain properties about the program, related with its soundness and security, and thus, certain kind of optimizations can be performed for executable code, since some typing information is already known. Moreover, not having explicit types allow programmers to have a better expressiveness, and to generate prototypes of programs faster to test and execute.
In their original work, Siek and Taha [15] start from a language which is statically typed to obtain a gradual system by adding the character ? to express an unknown type. Having this type enforces the static properties of the system as gradual types represent static information, in this way gradual typing supports static and dynamic checking of program properties [2]. Programmers can explicitly write static types, as well as leave some parts of the code without typing. A type that has not been defined as “static” by the programmer should be verified at run-time, this information is depicted by a gradual type system which should preserve type consistency for both typed and untyped code.
In dynamic typed languages (such as Racket, Scheme or Lisp), an identity function can be declared as (lambda(x)x). In this declaration it is only stated that the type of x is unknown at this very moment. Later, during run-time, the type of x must be known. Notice that as it is an identity function, the type of the return value x can be only known until the type of the argument x is already known. In a gradual typing system, the above declaration should have a type that represents the notion of typing in run-time but in compilation time and hence a type consistency notion is essential.
The relation of consistency has a significant importance because it must be guar- anteed that programs do not fail, that is, if they reach an unsoundness state. The relation of consistency has to be maintained, even when the unknown type ? of Gradual Typing is present [7]. A consistency relation is given to extend conserva- tively the type equality: T ∼ T j expresses that during run-time, T is structurally equal to T j with the exception of some features but mainly to do not allow any type inconsistency. This will ensure that soundness and security, or safety of the gradual language is preserved.
Robustness of usual extensions of functional languages are based on the preser- vation of fundamental properties such as security. A meta-theory, as presented by Toro and Tanter [19] allows to extend a language into a gradual one in a safe man- ner: the gradual union of types and the unknown type ? are combined through the Abstract Gradual Typing (AGT) methodology. The AGT is based on abstract interpretation due to Cousot and Cousot [4], for a sound abstraction using Galois connections. Abstract Interpretation describes the computations made in a given system but in a different universe. For example, the elements in a program and their operations can be modeled in another language, preserving their semantics.
Since Siek and Taha introduced the term Gradual Typing [15], several other studies have been performed which encompass Gradual Typing with type security [5],

type states [8], Object-Orientation [14,18], and so on. Although the interest for Gradual Typed languages has been increased over the last few years, there are still questions about how more sophisticated language features can be included into them [7].
We present an extension of a functional language with records. Such an structure allows the programmer to manipulate expressions that could have different types. The gradual extension is carried out with gradual union types, which are intended to preserve the safety property. In this paper the extension of the type system is provided in order to understand the abstraction behind the AGT methodology, as proposed by [19].

Gradual Union Typing
Some proposals have been made to address the inexactness introduced by the un- known type ? of Gradual Typing languages. Two are mainly used [19]:
The use of disjoint (or tagged) types, such as the sum of the types T1 + T2
explicitly tagged; and
Untagged union types, denoted by T1 ∨ T2, which denotes the union of values of type T1 and of type T2.
Toro and Tanter combine these two proposals into a Gradual Union Typing (GUT) approach, in which it is possible to have the two different types of union: disjoint or tagged union types, and untagged union types. Mixing tagged and un- tagged unions in a language is named as optimistic type checking to ensure that statically any term will have a type. In particular, optimistic type checking means that some statement is well typed without the occurrence of any explicit projection or case analysis.
An Abstract Gradual Interpretation of union types is studied, following [19], in order to understand both proposals for the union of types. Thus, it is possible to mix both: disjoint or tagged union types and their variant types, as well as untagged union types:
Disjoint union types or tagged unions (T1 + T2) denote values of different types. They are called disjoint because some elements are explicitly tagged, so the type system recognizes the type of each element. Hence, it guarantees and ensures the type of each element during compilation and execution time.
Untagged unions (T1 ∨ T2) denote the unions of values of types T1 and T2 without any tagging mechanism. For example, a value v of type T1 is included as a value of type T1 ∨ T2, that is, the type of value v appears in the union of both sets of types T1 and T2, i.e. the highest lower bound between T1 and T2. Untagged unions can be used in the branches of conditionals inside of an if expression, where then and else branches can return a different type of values. Thus, untagged unions can be safely compiled, but can lead to errors during execution time.

2.1  A Gradual Interpretation of Union Types
Toro and Tanter, based on the AGT methodology, propose static semantics for a Gradual Typed Functional Language, which make use of gradual unions and un- known typing. The notion of gradual union types is to restrict the imprecise types to denote a finite number of static types [19]. Such a semantic is based on the Simply-Typed Functional Language (STFL), which is statically typed.
Types of a Gradual Type Functional Language (GTFL⊕), as defined by Toro and Tanter [19], extend the STFL syntax by adding the symbol ?, introduced as the unknown type. This type is present in the Gradual Type Functional System (GTFL) [7], which preserves the STFL structure, where static types, predicates, and partial functions are lifted to gradual types. This transformation between sets of static types and gradual types is based on a Galois connection as the AGT approach states. The consistency relationship extends static type equality and is defined by the following judgments [7]:


	
T ∼ T	T ∼?	? ∼ T
  T11 ∼ T21	T12 ∼ T22 
T11 → T12 ∼ T21 → T22


In this paper, the extension with records is carried out using the methodology given in [19]. The first transformation uses an abstraction function α? to convert STFL into an GTFL, and a concretization function γ? from GTFL to STFL to complete the Galois connection. Second step is to obtain a GTFL⊕ from GTFL by adding the gradual union denoted by: T1 ⊕ T2 and using α⊕ and γ⊕ functions between these languages for the Galois connection. Figure 1 shows these connections between languages.

Figure 1. Methodology proposed by Toro and Tanter, using α, γ, α⊕, γ⊕ functions to convert STFL into GTFL⊕.

For the purposes of this paper, the left side of Figure 2 shows the lifting of the types on STFL, which is expressed by the infinite power set ℘(TY PE), to the syntactic category GTYPE using functions α? and γ?.
From these sets, it is necessary to lift the set of types into a finite one, this implies the use of the power set operator ℘.

Then,	functions
℘fin(GTY PE) [19].
αı?  and
γÙ? are defined between ℘fin(℘(TY PE)) and



Figure 2. On the left, the finite lifting over ℘(TY PE) and GTY PE. On the right, the finite lifting over
℘fin(GTY PE) and UT Y PE.

The right side of Figure 2 shows the last transformation in order to obtain system GTFL⊕, through functions α⊕ and γ⊕, in particular between ℘(GTY PE) and UTY PE (i.e. between GTFL and GTFL⊕) [19].

Gradual Union Types with Records
This paper extends the GUT by Toro and Tanter with records. A record is a data- type that describes variables (called fields) and their values. Fields possibly have different types. Some programming languages use records to define new types, and therefore, are able to extend the language [6,12]. A record is composed by one or more labels, here denoted as l. Each label has an assigned term, which also has a type.
Adding records allows to extend a language maintaining complex information in the same structure, and having the possibility to access it through an identifier of each one of its fields. The extension here presented is based on the system of Toro and Tanter [19] and is given in Figure 3. The system adds records as primitive types (shown in boldface) where the labels li belong to a predetermined set LABEL.



T ∈ TY PE,	x ∈ V AR,	t ∈ TERM,	Γ ∈ V AR
-fin TY PE,	l ∈ LABEL


T ::= Int | Bool | T → T | [li : Ti i∈1..n]	(types)
v ::= n | b | λx : T.t | [li = vi i∈1..n]	(values)
t ::= v | x | t + t |if t then t else t | t :: T | t t | [li = ti i∈1..n] | t.lj	(terms)



Γ ▶ n : Int
(Tn)

Γ ▶ b : Bool
(Tb)	 x : T ∈ Γ  (Tx)
Γ ▶ x : T

 Γ ▶ t1 : T1	T1 = Int	Γ ▶ t2 : T2	T2 = Int 
Γ ▶ t1 + t2 : Int
 Γ ▶ t1 : T1	T1 = Bool	Γ ▶ t2 : T2	Γ ▶ t3 : T3 
Γ ▶ if t1 then t2 else t3 : equate(T2, T3)
(T+)

(Tif )

 Γ ▶ t : T	T = T1 
Γ ▶ (t :: T1): T1
(T::)

	Γ, x : T1 ▶ t : T2	
Γ ▶ (λx : T1.t): T1 → T2
(Tλ)

Γ ▶ t1 : T1	Γ ▶ t2 : T2	T2 = dom(T1)
(Tapp)
Γ ▶ t1 t : cod(T )
Γ ▶ ti : Ti i∈1..n	for each i

Γ ▶ [li
= ti
i∈1..n]: [li
: Ti
i∈1..n]	(Trec)

Γ ▶ t : [li : Ti i∈1..n]
(Tproj )
Γ ▶ t.lj : Tj	for some j ∈ 1..n

dom: TYPE - TYPE	cod: TYPE - TYPE	equate: TYPE × TYPE - TYPE
dom(T ) undefined in other case  cod(T ) undefined in other case  equate(T1, T2) undefined in other case

Figure 3. Syntax and type system of Simply Typed Functional Language, STFL [7] extended with records (shown in boldface).

From Figure 3, a record type is denoted by [li : Ti i∈1,...,n], where li denote a label. A record term is expressed as [li = ti i∈1,...,n], where li denotes a field for term ti and a record value is defined as [li = vi i∈1,...,n] where each vi is a value. Each record has a fixed size n. The typing rules for records are Trec and Tproj, following the typing rules given in [12]:
Trec: in order to assign a type to a record term, if each term ti has type Ti under
Γ, then term [li = ti i∈1..n] has type [li : Ti i∈1..n], in the same context Γ.
Tproj: in order to assign a type to a projection j, if a term t has a record type t : [li : Ti i∈1..n] in context Γ, then term tj of type Tj can be obtained through label lj.

System STFL has been proved safe [12], we only give some properties in order to prove the gradual extensions.
Record substitution:
[l1 = t1, l2 = t2, ..., ln = tn][v/x]= [l1 = t1[v/x], l2 = t2[v/x], ..., ln = tn[v/x]]
Projection of record substitution:
(t.lj)[v/x]= (t[v/x].lj)
Lemma 3.1 (Inversion of typing relation)

If Γ ▶ n : R, then n = Int.
If Γ ▶ true : R, then R = Bool.
If Γ ▶ false : R, then R = Bool.
If Γ ▶ x : R, then x : R ∈ Γ.
If Γ ▶ t1 + t2 : R, then R = Int.
If Γ ▶ t :: T1 : R, then Γ ▶ t : R and R = T1.
If Γ ▶ if t1 then t2 else t3 : R, then Γ ▶ t1 : Bool, Γ ▶ t2 : R and Γ ▶ t3 : R.
If Γ ▶ λx : T1.t2 : R, then R = T1 =⇒ R2 for some R2 with Γ,x : T1 ▶ t2 : R2.
If Γ ▶ t1t2 : R, then there is some type T11 such that Γ ▶ t1 : T11 =⇒ R and
Γ ▶ t2 : T11.
If Γ ▶ [li = ti i∈1..n]: [li : Ti i∈1..n] then Γ ▶ ti : Ti for each i ∈ 1..n.
If Γ ▶ t.lj : Tj for some j ∈ 1..n then Γ ▶ t : [li : Ti i∈1..n].

A Gradual Typing Language
The following step is to add records for a Gradual Typing Language (GTFL). This means adding the unknown type ? to the STFL. In the following, we present the extension with records based on the work of [19], the new cases are in boldface:
G ∈ GTY PE	G ::= Int | Bool | G → G | ? | [li : Ci i∈1..n]
The concretization function is defined as follows:
γ?(Int)= {Int}	γ?(Bool)= {Bool}	γ?(?)= TY PE γ?(G1 → G2)= {T1 → T2 | T1 ∈ γ?(G1) ∧ T2 ∈ γ?(G2)}
g?([li : C i∈1..n]) = {[li : T i∈1..n] | Ti ∈ g?(Ci) i∈1..n]}
i	i
Notice that the above function helps to preserve (i.e. to know) the static infor- mation of gradual types [19,7]. The case for γ?(?)= TY PE states that the unknown

type could be any of the types in the category TY PE defined in STFL.

The abstraction function, following [19], is defined using TÛ which denotes a set of types induced by T :

T¸→ T2
= {T j → T jj | T j ∈ Tı
∧ T jj ∈ Tı}

[lˇ: T i∈1..n]= {[l : T

i∈1..n] | T
∈ Gı ∧ i ∈ 1..n ∧ j ∈ 1..|Gı|}

i	i	i
i,j
i,j	i	i


α ({T})= T	α (T¸→ T )= α (Tı) → α (Tı)	α (∅)= undefined
?	?	1	2	?	1	?	2	?



α ([lˇ: T
i∈1..n]) = [l
: α (TÙ ) i∈1..n]	α (TÛ)= ? otherwise

?	i	i	i	?	i	?

The abstraction function α? helps the language to obtain or retain more precision, while the unknown type is decreased, that is, the α? function can produce a gradual type that abstracts a given set [7]. Toro and Tanter define optimal as the best approximation of α?, that means the most precise gradual type that is possible. Both functions γ? and α? define the Galois connection [19].
Definition 3.2 [GTY PE Precision] G1 is less imprecise than G2, G1 ± G2, if and only if γ?(G1) ⊆ γ?(G2).
The next proposition defines when α? is sound and optimal.
Proposition 3.3 (α? is sound and optimal) If TÛ is non empty, then:
TÛ ⊆ γ?(α?(TÛ))
TÛ ⊆ γ?(G) =⇒ α?(TÛ) ± G

Proof Proof by induction on the structure of G, we show the case for records.
Case 1 for records ([l˛: T i∈1..n])


If TÛ = [lˇ: Ti
i
i∈1..n]= {[li
i
: Ti,j

i∈1..n] | T


i,j

∈ TÙ

∧ i ∈ 1..n ∧ j ∈ 1..|TÙ|} then by

definition of α : α ([lˇ: T
i∈1..n]) = [l
: α (TÙ) i∈1..n]

?	?	i	i	i	?	i

and by definition of γ
for records we have γ (α (TÛ)) = γ ([li : α (TÙ) i∈1..n]) =

?	?	?	?	?	i
γ?([li : Gi i∈1..n]) = {[li : Ti i∈1..n] | Ti ∈ γ?(Gi) i∈1..n} = {[li : Ti i∈1..n] | Ti ∈
γ (α (TÙ)) i∈1..n}.
?	?	i

By induction hypothesis Ti,j ∈ TÙ ⊆ γ (α (TÙ)) for each T
then the result holds.

i	?	?	i
i,j


Case 2 for records ([l˛: T i∈1..n])
i	i

Let TÛ = [lˇ: T i∈1..n], and suppose TÛ = [lˇ: T
i∈1..n] ⊆ γ ([l : G
i∈1..n])

i	i	i	i
?	i	i

and by definition of γ?: {[li : Ti i∈1..n] | Ti ∈ γ?(Gi) i∈1..n}

By definition of α
for records: α ([l˛: T
i∈1..n]) = [l
: α (TÙ) i∈1..n]

?	?	i	i	i	?	i
By the induction hypothesis, for each TÙ if TÙ ⊆ γ (G ) then α (TÙ) ± G .
i	i	?	i	?	i	i
Therefore, by definition 3.2 γ (α ([l˛: T i∈1..n])) = γ ([l : α (TÙ) i∈1..n]) ⊆
?	?	i	i	?	i	?	i
γ?([li : Gi i∈1..n]) and the result holds.	2
The next step to give a Gradual Union Typing is to lift functions α? and γ? to sets, that is from ℘fin(℘(TY PE)) to ℘fin(GTY PE) and vice-versa. Observe that this lifting is over finite sets of types. We follow again Toro and Tanter [19].
Definition 3.4 [℘fin(GTY PE) Concretization]

γÙ? : ℘fin(GTY PE) → ℘fin(℘(TY PE)) is defined as:
Definition 3.5 [℘fin(GTY PE) Abstraction]
αı? : ℘fin(℘(TY PE)) - ℘fin(GTY PE) is defined as:
γÙ?(GÙ)= {γ?(G) | G ∈ GÙ}


αı?(∅)= undefined
αı?(TÙ)= 
[ α?(TÛ)

Û Ù
T ∈T
Proposition 3.6 (αı? is sound and optimal) If TÙ is non empty, then:
Ù ⊆ γÙ?(αı?(Ù

TÙ ⊆ γÙ?(GÙ) =⇒
αı?(TÙ)
± GÙ

Proof The proof is the same as in [19] as we are working with sets. An important observation is that TÙ is indeed a GÙ.	2

A Gradual Union Typing Language
In order to construct a Gradual Union Typing, it is proposed in [19] a STY PE grammar for the static types. This grammar is made up only of gradual unions (without the unknown type ?).
S ∈ STY PE

S ::= Int | Bool | S → S | S ⊕ S | [li : Si i∈1..n]
The static types are integers (Int), booleans (Bool), functions (S → S), the gradual unions denoted by S ⊕ S and the record type. Recall that gradual unions represent a finite set of types [19], where the concretization and abstraction func- tions are defined between static types and finite sets of types generating a Galois connection.

For a gradual interpretation of union types with records, the next step is to design gradual union types, using the AGT to construct the semantics for gradual types in terms of pre-existing sets of static types.
The new type system is composed of Gradual Unions ⊕, named GTFL⊕, com- bining both STY PE and UTY PE. The last syntactic category, UTY PE, is the extension including the unknown type, the gradual unions and records. Figure 4 shows the grammar of GTFL⊕, extended with records, where types are extended from GTFL with union types, x denotes the set of V ARiables, t denotes the set of gradual union terms, and contexts are partial function Γ ∈ V AR -fin UTY PE.
We define a Galois connection between UTY PE and ℘fin(GTY PE) as the next concretization function in UTY PE [19]. The extension with records is again ex- pressed in boldface:
Definition 3.7 [UTY PE concretization] γ⊕ : UTY PE → ℘fin(GTY PE) γ⊕(Int)= {Int}	γ⊕(Bool)= {Bool}	γ⊕(?)= {?}
γ⊕(U1 → U2)= {G1 → G2 | G1 ∈ γ⊕(U1) ∧ G2 ∈ γ⊕(U2)} γ⊕(U1 ⊕ U2)= γ⊕(U1) ∪ γ⊕(U2)
g⊕([li : Ui i∈1..n]) = {[li : Ci i∈1..n] | Ci ∈ g⊕(Ui) i∈1..n}

The definition of abstraction function α⊕ (UTY PE abstraction) is the same defined by Toro and Tanter [19] and produces finite sets, that is the gradual union of all elements in GÙ:
Definition 3.8 [UTY PE abstraction] α⊕ : ℘fin(GTY PE) - UTY PE


α⊕(GÙ) =  GÙ
if G /= ∅

= α⊕(G1) ⊕ α⊕(G2) ⊕ ... ⊕ α⊕(Gm)	where Gi ∈ GÙ
The next proposition states that α⊕ is sound and optimal for UTY PE. The notion of precision for UTY PE is the same as the one given above, that is U1 ± U2 if and only if γ⊕(U1) ⊆ γ⊕(U2)



U ∈ UT Y PE,  x ∈ V AR,
t˜∈ UT ERM, Γ ∈ V AR - UT Y PE,  A ∈ ULABEL



U ::= Int | Bool | U → U | U ⊕ U |? | [li : U i∈1..n]	(types)
v ::= n | true | false | (λx : U.˜t) | [li = vi	]	(values)

˜t ::= v | x | ˜t + ˜t | if ˜t then ˜t else ˜t | ˜t :: U | ˜t ˜t | [li = t˜i
i∈1..n
] | t˜.li	(terms)


Γ ▶ n : Int
(Un)

Γ ▶ b : Bool
(Ub)	 x : U ∈ Γ  Γ ▶ x : U
(Ux)

  Γ ▶ t‹1 : U1	U1 ∼ Int	Γ ▶ t‹2 : U2	U2 ∼ Int 
Γ ▶ t‹ + t‹ : Int	(U+)
1	2
  Γ ▶ t‹1 : U1	U1 ∼ Bool	Γ ▶ t‹2 : U2	Γ ▶ t‹3 : U3 

Γ ▶ if t‹1
then
t‹2
else
t‹3
:	U2
H U3
(Uif )

 Γ ▶ ˜t : U	U ∼ U1 
Γ ▶ (˜t :: U1): U1
(U::)

	Γ, x : U1 ▶ ˜t : U2	
Γ ▶ (λx : U1.˜t): U1 → U2
(Uλ)

Γ ▶ t‹1 : U1	Γ ▶ t‹2 : U2	U2 ∼ dﬁom(U1)

‹ ‹ ›
(Uapp)

Γ ▶ t1 t2 : cod(U1)
for − each i Γ ▶ t˜i : Ui i∈1..n

Γ ▶ [li = t˜i
i∈1..n
]: [li : Ui
i∈1..n]
(Urec)

Γ ▶ t : [li : Ui i∈1..n]
j∈1..n	(Uproj )

Γ ▶ t˜.lj = Uj
dﬁom : UT Y PE - UT Y PE
dﬁom(U )= α(d¯om(γ(U ))

c›od : UT Y PE - UT Y PE
c›od(U )= α(cˆod(γ(U ))


Figure 4. Syntaxs and Type System of Gradual Type Functional Language⊕, GTFL⊕ [19] extended with records in boldface.

Proposition 3.9 (α⊕ is sound and optimal). If GÙ is non empty, then:
1. GÙ ⊆ γ⊕(α⊕(GÙ))	2. GÙ ⊆ γ⊕(U ) =⇒ α⊕(GÙ) ± U

Proof The proof is carried out by induction on the structure of U .
Case 1 for records.

Suppose G = [li : Gi i∈1..n] then GÙ = {[li : Ti,j i∈1..n] | Ti,j ∈ Gı
∧ i ∈ 1..n ∧ j ∈

.|Gı|}. Without loss of generality, take j =1 for each Gı with i ∈ 1..(n − 1) and
i	i
|Gˆ| = m.
To prove that GÙ ⊆ γ⊕(α⊕(GÙ)) we proceed by applying the definition of α⊕(GÙ):

α⊕({[li : Ti, ln : T j] | T j ∈ Gˆ
  {[li : Ti, ln : T j] | T j ∈ Gˆ
∧ i ∈ 1..n − 1}) =
∧ i ∈ 1..n − 1} =

[li : α⊕(Ti), ln : α⊕(Gn1)] ⊕ ... ⊕ [li : α⊕(Ti), ln : α⊕(Gnm)]
Using definition of γ⊕:
γ⊕([li : α⊕(Ti), ln : α⊕(Gn1)] ⊕· · · ⊕ [li : α⊕(Ti), ln : α⊕(Gnm)]) =
γ⊕([li : α⊕(Ti), ln : α⊕(Gn1)]) ∪· · · ∪ γ⊕([li : α⊕(Ti), ln : α⊕(Gnm)]) =
{[li : γ⊕(α⊕(Ti)), ln : γ⊕(α⊕(Gn1))]}∪· · ·∪{[li : γ⊕(α⊕(Ti)), ln : γ⊕(α⊕(Gnm))]}  =
{[li : γ⊕(α⊕(Ti)), ln : Gnj] | Gnj ∈ γ⊕(α⊕(Gˆ)) ∧ j ∈ 1..m}.

By induction hypothesis, Ti  ∈
ı and also belongs to γ⊕
(α⊕
(Gı)) for each

i ∈ 1..n − 1 and Gnj ∈ Gˆ belongs also to γ⊕
(α⊕
(Gˆ)) and therefore

GÙ ⊆ γ⊕(α⊕(GÙ)).



Case 2 for records.
Suppose that GÙ ⊆ γ⊕(U ) where GÙ = [lˇ: Gi


i∈1..n]

and
γ⊕(U )= γ⊕([li : Ui i∈1..n]) = {[li : Gi i∈1..n] | Gi ∈ γ⊕(Ui) i∈1..n}
To prove α⊕(GÙ) ± U we proceed by definition of α⊕(GÙ):

α⊕([lˇ: G
i∈1..n]) =  {[li : Ti,j i∈1..n] | Ti,j ∈ Gı
∧ i ∈ 1..n ∧ j ∈ 1..|Gı|}




Without loss of generality, take j = 1 for each
|Gˆ| = m, then by definition of γ
ı with i ∈ 1..(n − 1) and

n	⊕
γ⊕({[li : Ti, ln : T j] | T j ∈ α⊕(Gˆ) ∧ i ∈ 1..n − 1})= 


 γ⊕({[li : Ti, ln : T j] | T j ∈ α⊕(Gˆ) ∧ i ∈ 1..n − 1})= 
 {[li : Ti, ln : T j] | T j ∈ γ⊕(α⊕(Gˆ)) ∧ i ∈ 1..n − 1}



The induction hypothesis states that Gı ⊆ γ⊕
(Ui) =⇒ α⊕
(Gı) ± Ui
for each

i which by definition of precision gives γ⊕(α⊕(Gı)) ⊆ γ⊕(Ui), in particular for Gn.
Therefore	 {[li : Ti, ln : T j] | T j ∈ γ⊕(Ui) ∧ i ∈ 1..n − 1} which is indeed
{[li : Gi i∈1..n] | Gi ∈ γ⊕(Ui) i∈1..n}.	2

Therefore, following Toro and Tanter [19], the stratified interpretation of UTY PE is defined in terms of sets of sets of static types with the composition of two presented Galois conections:
Definition 3.10 [UTY PE concretization]
γ : UTY PE → ℘fin(℘(TY PE))	γ = γÙ? ◦ γ⊕
Definition 3.11 [GTY PE abstraction]
α : ℘fin(℘(TY PE)) - UTY PE	α = α⊕ ◦ αı?
The next proposition is needed to prove that α is sound and optimal:
Proposition 3.12 (α is sound and optimal). If TÙ is non empty, then:
Ù ⊆ γ(α(Ù
Ù ⊆ γ(U ) =⇒ α(Ù ± U
Proof This proposition holds by Propositions 3.3, 3.9, and composition of sound and optimal abstractions.	2
The next consistency relation is defined for UTY PE as U1 ∼ U2 if and only if
there exists Tı ∈ γ(U ), T ∈ Tı, Tı ∈ γ(U ) and T ∈ Tı, such that T = T :
1	1	1	1	2	2	2	2	1	2
Proposition 3.13 (Consistency Relation)

U ∼ U	? ∼ U	U ∼ ?
	U ∼ U1	
U ∼ U1 ⊕ U2
	U ∼ U2	
U ∼ U1 ⊕ U2

		U1 ∼ U	 U1 ⊕ U2 ∼ U
		U2 ∼ U	 U1 ⊕ U2 ∼ U
  U21 ∼ U11	U12 ∼ U22	
U11 → U12 ∼ U21 → U22

	U11 ∼ U21 ... U1n ∼ U2n	
[l1 : U11, ..., ln : U1n] ∼ [l1 : U21, ..., ln : U2n]
In order to present the static semantics of Gradual Union Typing, is provided the next definition of Gradual Meet [19], which is extended for records.
Definition 3.14 [Gradual Meet] Let H : UTY PE - UTY PE be defined as:
U H U = U


? H U = U H ? = U
⎧⎪ U H U
⎪	1


if U H U2


is undefined

U H(U ⊕U )= (U ⊕U )HU = ⎪⎨

1	2	1	2
U H U2	if U H U1 is undefined
⎪⎪ (U H U ) ⊕ (U H U ) otherwise

(U11 → U12) H (U21 → U22)= (U11 H U21) → (U12 H U22)
[l1 : U11, ..., ln : U1n] H [l1 : U21, ..., ln : U2n] = [l1 : (U11 H U21), ..., ln : (U1n H U2n)]
U1 H U2 is undefined otherwise.


The following definition states the translation of the equate from STFL to a function in GTFL⊕, in order to preserve typing:
Definition 3.15 [Equate Lifting]
e‡quate(U1, U2)= U1 H U2 = α({Tı ∩ Tı | Tı ∈ γ(U1), Tı ∈ γ(U2)})= 
α⊕({e·quate?(G1, G2) | G1 ∈ γ⊕(U1), G2 ∈ γ⊕(U2)})
And the next proposition is needed to prove the gradual meet for GTFL⊕

Proposition 3.16 H = α ◦ ˙ ◦ γ
Proof Proof is made using structural induction and the definition of meet as in- tersection of sets of sets [19]. The case for records is straightforward as the meet is pointwise.	2

Conclusion and Future Work
Gradual Union Typing was initially proposed by Toro and Tanter [19], showing properties such as safety and consistency using AGT and Galois connections. Nev- ertheless, there has been investigated a lot of settings related to gradual typing in order to promote the development of more expressive programming languages. For instance, subtyping by García, Siek and Taha [14,7], Gradual Typing systems and cast insertion procedures by Cimini and Siek [3], the interaction between union types and Gradual Typing [16,1], typestates [8], refinement types [11], information- flow security typing [5], set-theoretic types and subtyping [2], refinement sums for exhaustive and non-exhaustive matches [10], and studies focused on performance at run-time and space management [13,9].
The type setting here provides a static extension using records for the study of Gradual Union Typing, as presented by Toro and Tanter in [19]. This approach contributes to the study of the theoretical perspective for the foundations of pro- gramming languages. Adding records to a functional language allows to create new variants of types, using them as basic types predefined in the language, for a richer and more versatile language. Extending the methodology for languages with gradual typing helps to combine the advantages of using both static and dynamic typing, while preserving the properties of consistency and security in it.
A related work from Garcia, Clark and Tanter [7] proposes an extension of a type system with records using subtyping, and formalizing a relation of consistency on gradual typing language, by following the methodology proposed by Siek and Taha [15]. Our approach here differs from theirs as we rely on gradual union types. Here it is already provided a static formal system. Further, the dynamic formal part, demonstrating its static and dynamic semantics properties, is aimed as future work. The main goal is to obtain a gradual system with records using the so-called Threesome Calculus [17] for the dynamic semantics.

References
Giuseppe Castagna and Victor Lanvin. Gradual typing with union and intersection types. Proceedings of the ACM on Programming Languages, 1(ICFP):41, 2017.
Giuseppe Castagna, Tommaso Petrucciani, and Kim Nguy˜en. Set-theoretic types for polymorphic variants. In Proceedings of the 21st ACM SIGPLAN International Conference on Functional Programming, ICFP 2016, pages 378–391, New York, NY, USA, 2016. ACM.
Matteo Cimini and Jeremy G Siek. The gradualizer: a methodology and algorithm for generating gradual type systems. ACM SIGPLAN Notices, 51(1):443–455, 2016.
Patrick Cousot and Radhia Cousot. Formal language, grammar and set-constraint-based program analysis by abstract interpretation. In FPCA, volume 95, pages 170–181, 1995.
Tim Disney and Cormac Flanagan. Gradual information flow typing. In International workshop on scripts to programs, 2011.
Daniel P Friedman, Mitchell Wand, and Christopher Thomas Haynes. Essentials of programming languages. MIT press, 2001.
Ronald Garcia, Alison M. Clark, and Éric Tanter. Abstracting gradual typing. In Proceedings of the 43rd Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, POPL ’16, pages 429–442, New York, NY, USA, 2016. ACM.


Ronald Garcia, Éric Tanter, Roger Wolff, and Jonathan Aldrich. Foundations of typestate-oriented programming. ACM Transactions on Programming Languages and Systems (TOPLAS), 36(4):12, 2014.
David Herman, Aaron Tomb, and Cormac Flanagan. Space-eﬃcient gradual typing. Higher-Order and Symbolic Computation, 23(2):167, 2010.
Khurram A Jafery and Joshua Dunfield. Sums of uncertainty: Refinements go gradual. ACM SIGPLAN Notices, 52(1):804–817, 2017.
Nico Lehmann and Éric Tanter. Gradual refinement types. In Proceedings of the 44th ACM SIGPLAN Symposium on Principles of Programming Languages, POPL 2017, pages 775–788, New York, NY, USA, 2017. ACM.
Benjamin C Pierce and C Benjamin. Types and programming languages. MIT press, 2002.
Aseem Rastogi, Nikhil Swamy, Cédric Fournet, Gavin Bierman, and Panagiotis Vekris. Safe &#38; eﬃcient gradual typing for typescript. In Proceedings of the 42Nd Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, POPL ’15, pages 167–180, New York, NY, USA, 2015. ACM.
Jeremy Siek and Walid Taha. Gradual typing for objects. In European Conference on Object-Oriented Programming, pages 2–27. Springer, 2007.
Jeremy G Siek and Walid Taha. Gradual typing for functional languages. In Scheme and Functional Programming Workshop, volume 6, pages 81–92, 2006.
Jeremy G Siek and Sam Tobin-Hochstadt. The recursive union of some gradual types. In A List of Successes That Can Change the World, pages 388–410. Springer, 2016.
Jeremy G. Siek and Philip Wadler. Threesomes, with and without blame. In Proceedings of the 37th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, POPL ’10, pages 365–376, New York, NY, USA, 2010. ACM.
Asumu Takikawa, T. Stephen Strickland, Christos Dimoulas, Sam Tobin-Hochstadt, and Matthias Felleisen. Gradual typing for first-class classes. In Proceedings of the ACM International Conference on Object Oriented Programming Systems Languages and Applications, OOPSLA ’12, pages 793–810, New York, NY, USA, 2012. ACM.
Matías Toro and Éric Tanter. A gradual interpretation of union types. In International Static Analysis Symposium, pages 382–404. Springer, 2017.
