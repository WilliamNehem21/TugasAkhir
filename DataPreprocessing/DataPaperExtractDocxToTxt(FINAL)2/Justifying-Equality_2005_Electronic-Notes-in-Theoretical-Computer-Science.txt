Electronic Notes in Theoretical Computer Science 125 (2005) 69–85  
www.elsevier.com/locate/entcs


Justifying Equality *

Leonardo de Moura,  Harald Rueß, and  Natarajan Shankar
SRI International, Computer Science Laboratory, 333 Ravenswood Avenue, Menlo Park, CA 94025, USA
{demoura,ruess,shankar}@csl.sri.com

Abstract
We consider the problem of finding irredundant bases for inconsistent sets of equalities and dis- equalities. These are subsets of inconsistent sets which do not contain any literals which do not contribute to the unsatisfiability in an essential way, and can therefore be discarded. The approach we are pursuing here is to decorate derivations with proofs and to extract irredundant sets of as- sumptions from these proofs. This requires specialized operators on proofs, but the basic inference systems are otherwise left unchanged. In particular, we include justifying inference systems for union-find structures and abstract congruence closure, but our constructions can also be applied to other inference systems such as Gaussian elimination.
Keywords: Decision Procedures, Satisfiability, Union-Find, Congruence Closure, Proof Theory, Minimal Proofs.


Introduction
Constraint solving has many applications, including the discovery of abstrac- tion predicates in protocol and software verification [4] and for lazy combina- tions for planning [13] and formal verification [13,2,6,5]. The effectiveness of these constraint solving problems depends on identifying “small” inconsistent subsets of constraints.
We therefore consider the problem of finding an irredundant basis for an inconsistent set Γ of equalities and disequalities. These are subsets of Γ which
do not contain any redundant literal, that is, literals which do not contribute to the unsatisfiability of Γ in an essential way, and can therefore be discarded.

 Funded by SRI International, by NSF Grants CCR-0082560 and CCR-ITR-0325808, DARPA/AFRL Contract F33615-00-C-3043, and NASA Contract NAS1-20334


1571-0661 © 2005 Published by Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2004.06.068


This notion of irredundant basis is unrelated to the commonly used proof- theoretic measure which counts the number of inference steps. Also, irredun- dant bases are not necessarily minimal among all inconsistent subsets of Γ. For example, {x = z, y = z, x = y, x /=y} is inconsistent, {x = z, y = z, x /=y} is an irredundant basis for this inconsistency, but obviously it is not minimal as {x = y, x /=y} is also inconsistent. Indeed, the computation of minimally inconsistent bases is usually harder than the problem of computing irredun- dant bases. For example, an irredundant basis for an inconsistent conjunc- tion of variable equalities and disequalities can be computed in O(n log(n)) time—with n the number of variables—whereas standard algorithms based on Boolean matrix multiplication for producing shortest deduction paths between two variables take O(n3) time. 1 Moreover, the problem of minimal bases for equality over uninterpreted functions is NP-hard [12].
Our starting point is the union-find structure used for deciding equality. A canonizer constructs canonical representatives for given terms with respect to the given equalities so that equality can be decided by syntactically comparing canonical forms. Such canonizer-based inference systems are attractive from an algorithmic point of view as equalities are applied in a directed way and term universes in combination procedures based on canonization are usually much smaller than the corresponding term universes in combination methods without such a canonizer. However, reduction to canonical forms accumulates many redundant literals into the assumptions of corresponding proofs.
Consider, for example, the inconsistent set {x = x', x' = z, y = x', u = f (x), u /=v, v = f (y)}, where f is an uninterpreted function symbol and all variables are existentially-quantified (constants). In processing these literals from left to right, abstract congruence closure (ACC) [8,1,9], builds up a set of directed equalities {x → z, x' → z, y → z}, with the left hand sides assumed to be larger than the right hand sides according to some given variable or- dering. The variable arguments of the uninterpreted terms f (x) and f (y) are both replaced with their canonical representative z, and application of congru- ence yields the inconsistency. Since all input literals are used in this proof of unsatisfiability, simply tracking dependencies or collecting assumptions from an explicitly generated proof object is not sufficient for generating irredundant bases. The algorithm in [6] for computing irredundant bases by successively eliminating redundant literals has proven to be too costly in practice.
The approach we are pursuing here is to decorate derivations with proofs and to extract an irredundant set of assumptions from these proofs. This requires specialized operators on proofs, but the basic inference procedures

1 But sub-cubic algorithms are possible for solving the related problem of finding successor vertices of shortest paths [7].



	
▶ es,t : s = t	▶ ds,t : s /=t



▶ 1t : t = t
▶ ρ : s = t


▶ ρ−1 : t = s
▶ τ : s = t, ▶ σ : t = r


▶ τ ; σ : s = r

▶ ρ1 : s1 = t1,... , ▶ ρn : sn = tn
▶ cgf (ρ1,... , ρn) : f (s1,..., sn) = f (t1,..., tn)
▶ ρ : t /=t
▶ 0t(ρ) : ⊥
Fig. 1. Proof theory for U.

are left unchanged. Our main contribution is a join operator on directed equality proofs for x = z and y = z with x, y larger than z according to some given variable ordering. Obviously, taking the union of the assumptions of these two proofs leads to imprecision as there might be a join z' of x, y which is greater than z. However, the symmetric difference of assumptions yields irredundant bases for these kinds of “valley” proofs. We extend this basic insight to produce proofs with small sets of justifications for congruence closure.


Background

Given a signature Σ, a Σ-structure M maps each n-ary function symbol f in Σ to an n-ary map M(f ) over a suitable domain. We assume that M also maps free variables x to domain elements M(x). The interpretation M[[t]] of a Σ-term t in a Σ-structure M is defined so that M[[x]] = M(x), and M[[f (t1,... , tn)]] = M(f )(M[[t1]],... ,M [[tn]]). A Σ-literal is either a Σ-equality or a Σ-disequality, and a Σ-equality s = t (Σ-disequality s /=t) is satisfied in Σ-structure M iff M[[s]] = M[[t]] ( M[[s]] /=M[[t]]). The interpretation of the propositional connectives and quantifiers is standard [10]. When Σ-structure
M satisfies a Σ-formula ϕ, we write M |= ϕ. A Σ-theory 7 is a class of Σ-structures—the models of the theory—closed under isomorphism. A set of
Σ-literals L is 7 -unsatisfiable if there is no Σ-structure M in 7 such that M |= l for all l ∈ L. Literals L are 7 -valid if for all Σ-structures M, M |= l for all l ∈ L.
The proof theory for the theory C of equality over uninterpreted functions is included in Figure 1. Judgements are of the form ▶ p : ϕ with p a proof of


literal ϕ. The assumptions of proofs are obtained as follows.
Ax(es,t) = {es,t}	Ax(ds,t) = {ds,t}
Ax(1 ) = ∅	Ax(ρ−1) = Ax(ρ)
Ax(τ ; σ) = Ax(τ ) ∪ Ax(σ)	Ax(cgf (ρ1,... , ρn)) = Ax(ρ1) ∪ ... ∪ Ax(ρn)
The theory of equality over variables is the C theory for the empty signature Σ. A set Γ of Σ literals is C-unsatisfiable if, and only if, there is a proof ρ of ⊥ with Ax(ρ) ⊆ Γ. Proofs built up from reflexivity (1t), symmetry (ρ−1), and transitivity (ρ; σ) are referred to as equality-chaining proofs. We also make use of a number of identities on proofs such as (1t; ρ) = ρ and cgf (1t1 ,... , 1tn ) = 1f (t1 ,...,tn).
Definition 2.1  Let Γ be a 7 -unsatisfiable set of Σ-literals.
If ∆ ⊆ Γ and ∆ is 7 -unsatisfiable, then ∆ is a 7 -basis for Γ.
A 7 -basis ∆ of Γ is minimal if there is no 7 -basis ∆' of Γ such that
|∆'| < |∆|, where |.| denotes the set-theoretic cardinality.
A 7 -basis ∆ of Γ is irredundant if no strict subset of ∆ is a 7 -basis for Γ.
Since Γ → ϕ is 7 -valid if, and only if, Γ ∧ ¬ϕ is 7 -unsatisfiable, we also say that Θ ⊆ Γ is a 7 -basis for ϕ if Θ → ϕ if 7 -valid. Moreover, ρ is an irredundant proof for ϕ if Ax(ρ) is an irredundant basis for ϕ.

Equality over Variables

A set Γ of equalities and disequalities over variables is inconsistent if, and only if, there is a disequality x /=y in Γ such that x and y are in the same equivalence class of the equivalence closure of the equalities in Γ. Using the
union-find algorithm, a partitioning of the variables in Γ is maintained in an incremental manner (see, for example, [3]).  The operation union(x = y) merges the two equivalence classes for x and y, and f ind(x) returns the canonical representative of the equivalence class containing the variable x. A sequence of m union and f ind operations can be performed in worst-case time O(m α(n)) with n the number of variables in Γ and α(n) the inverse of the
Ackermann function [11].
We extend the union-find algorithm with an operator explain(x = y) which returns an irredundant basis for the implied equality x = y, and analyze its complexity.


Definition 3.1 [Union-find-explain structure] Let (V , ≺) be a pair consisting of a nonempty, finite set V of variables with a total ordering ≺ on V, and let E be the set of equalities over V. Then, a union-ﬁnd-explain structure is a pair of functions (φ : V → V,π : V → 2E) such that, for all x ∈ V, φ(x) ≺ x
or φ(x) ≡ x, and π(x) is a basis for x = φ(x).
For a union-find-explain structure (φ, π), φ (x) denotes the canonical rep- resentative of the equivalence class for x, and π∗(x) is a basis for x = φ∗(x).

Definition 3.2 Let (φ, π) be a union-find-explain structure; then:

φ∗(x) := ⎧⎨ x	, φ(x) ≡ x
⎩ φ∗(φ(x)) , otherwise
π∗(x) := ⎧⎨ ∅	, φ(x) ≡ x
⎩ π(x)  π∗(φ(x)) , otherwise

where s1  s2 := (s1 ∪ s2)\(s1 ∩ s2) denotes the symmetric difference of two sets.
Variable equalities are added incrementally to a union-find-explain struc- ture by the union operation.
Definition 3.3 Let (φ, π) be a union-find-explain structure; then:



union


(φ,π)
(ρ, x, y) := ⎪⎨ (φ[x' := y'], π[x' := Π]) , y' ≺ x'
⎪⎪⎩ (φ[y' := x'], π[y' := Π]) , x' ≺ y'

with x ≡ φ (x), y ≡ φ (y), Π = π (x) ∪ π (y) ∪ {ρ}.
We say that (φ, π) is a union-find-explain structure for a finite set E of variable equalities if (φ, π) is the result of processing the equalities in E,
∗	∗
starting with (λx. x, λx. ∅).  In this case, φ (x) ≡ φ (y) if, and only if,
E → x = y is valid. In other words, a disequality x /=y is inconsistent with E
∗	∗
if, and only if, φ (x) ≡ φ (y). We show that an irredundant basis for implied
equalities x = y is obtained by computing the symmetric difference of π∗(x) and π∗(y).
Theorem 3.4	Let (φ, π) be a union-find-explain structure for a finite set of variable equalities; then (for all x, y ∈ V)
π∗(x) is an irredundant basis for x = φ∗(x), and
if φ∗(x) ≡ φ∗(y), then π∗(x)  π∗(y) is an irredundant basis for x = y.
Proof. By induction on the number of unions. These properties hold initially, since all nodes are distinct and for all x, φ(x) ≡ x, and π(x) is empty. For


the induction step from n to n + 1, we assume that these properties hold for (φn, πn), (φn+1, πn+1) = union(φ ,πn)(ρ, x, y), and, without loss of generality,
φ∗(y) ≺ φ∗(x). Then, for any x	x,


∗
n+1

(xˆ)= π∗ (xˆ)  π
∗


n+1
∗
ˆ in the equivalence class of
(φn(x))
∗

= πn(xˆ) (πn(x) ∪ {ρ}∪ πn(y))
= (π∗ (xˆ)  π∗ (x)) ∪ {ρ}∪ π∗ (y) , 
n	n	n
because the equivalence classes of x and y are disjoint, repeated assumptions can only occur within π∗ (xˆ)  π∗ (x), but we know by the induction hypothesis
n	n
that this basis is irredundant.
For the second part, we need to show that for xˆ and yˆ from the equivalence

classes of x and y, respectively, π∗
(xˆ) π∗
(yˆ) is irredundant. As we have

already seen,
π∗	(xˆ)= (π∗ (xˆ) π∗ (x)) ∪ {ρ}∪ π∗ (y) , and

n+1
∗
n+1
n	n	n
(yˆ)= π∗ (yˆ) . 

Hence π∗	(xˆ)  π∗	(yˆ) = (π∗ (xˆ) π∗ (x)) ∪ {ρ}∪ (π∗ (yˆ)  π∗ (y)) which we
n+1	n+1	n	n	n	n
know is irredundant by the induction hypothesis.	 
Example 3.5 Let Γ := {x ρ1 w, x ρ2 z, y ρ3 z}. Using the variable ordering
w ≺ z ≺ x ≺ y, processing the equalities from left to right yields the following representation of a union-find-explain structure, where “find” edges are labeled with the elements of the corresponding basis.
w

ρ1	ρ1, ρ2
x	z
ρ1, ρ2, ρ3
y

∗	∗
Clearly, the equality Γ → x = y is valid, since φ (x) ≡ φ (y) ≡ w. The
irredundant basis {ρ ,ρ } for x = y is obtained as π∗(x)  π∗(y) = {ρ } 
2	3	1
{ρ1, ρ2, ρ3}.
The bases thus obtained are irredundant by Theorem 3.4 but they are not necessarily minimal.
Example 3.6 Let Γ := {x ρ1 z, y ρ2 z, x ρ3 y}, then the minimal basis for
y = x is {ρ3}, but the method described above returns the basis {ρ1, ρ2}, which is irredundant but not minimal, since union discards the implied equality x = y.
Figure 2 includes an efficient implementation of union-find-explain as an extension of the usual union-find algorithm (see, for example, [3]). Sets of assumptions are represented using the constructors # (join), 1 (reflexivity),


and e[s = t] (assumption). The corresponding set of assumptions Ax(ρ) for such a representation ρ is obtained as follows.
Ax(1) = ∅
Ax(e[s = t]) = {e[s = t]}
Ax(ρ1 # ρ2)= Ax(ρ1)  Ax(ρ2) . 
The find structure is implemented using the function p (parent) which is the identity on variables (λx.x) initially, whereas the proof structure prf is ini- tially 1 (reflexivity) on all inputs. j ustify(x) is a straightforward implemen- tation of π∗. Since f ind(x) uses dynamic path compression, computations of π∗ are memoized and # -nodes may be structure-shared. union(x, y) uses the r ank structure for selecting the new canonical variable. Because of possible path compression in the initial finds, prf(z) and j ustify(z) coincide for input variables of union. We implicitly use the identities ρ #1 = 1 # ρ = ρ.
explain(x, y) computes the set Ax(justify(x)# j ustify(y)) as required by Theorem 3.4. Notice that an equality is in the assumptions Ax(p) of such a # -dag p if, and only if, it occurs an odd number of times. We use reference counters r ef(ρ) for counting the number of occurrences of visited subdags.
Subdags are visited in a breadth-first manner ignoring subdags with even reference counts. As a consequence, every ’node’ in the # -dag ρ is visited at most once in collect. Finally, the breadth-first traversal in collect is obtained
by a FIFO queue with operators enqueue, dequeue, and queue is empty,
which ensures that a node is dequeued only after its immediate parent nodes have been dequeued.

Example 3.7 Processing {x
ρ1 x , x
ρ2 x , y ρ3 x , z ρ4 x , x
ρ5 x , x ρ6

1 =  2
3 =  2
=  2	=  4
4 =  5	2 =

x4} yields a union-find-explain structure

Thus, explain(y, x3) = collect((ρ3 # ρ1)# η # (ρ2 # ρ1)# η) = {ρ2, ρ3} with- out visiting η, since this subdag occurs twice.
If h(n) denotes the maximum height of the find structure after n union and f ind operations, then clearly f ind takes at most O(h(n)) time and creates at most O(h(n)) new # -nodes, union takes at most O(h(n)) time and space. So, a sequence of n union operations takes at most O(n h(n)) time and space.


p ← (λx. x); prf ← (λρ. 1); rank ← (λx. 0); result ← ⊥; ref ← (λρ. ⊥)
f ind(x) =
if not(x ≡ p(x)) then
p(x) ← f ind(p(x)); prf(x) ← (prf(p(x)) # prf(x)); return p(x)
union(x, y) =
'	'
x ← f ind(x); y ← f ind(y);
'	'
if rank(x ) > rank(y ) then
'	'	'
p(y ) ← x ; prf(y ) ← (prf(x)# prf(y)# e[x = y])
else
'	'	'
p(x ) ← y ; prf(x ) ← (prf(x)# prf(y)# e[x = y]);
'	'	'	'
if rank(x ) ≡ rank(y ) then rank(y ) ← rank(y )+1 
explain(x, y) =
result ← ∅; ref ← (λρ. 0); collect(j ustif y(x)# j ustif y(y)); return result
j ustif y(x) =
if x ≡ p(x) then 1 else (prf(x)# j ustif y(p(x)))
collect(ρ) =
register(ρ);
while not(q ueue is empty()) do
τ ← dequeue();
if is odd(r ef (τ )) then
if τ ≡ ρ1 # ρ2 then register(ρ1); register(ρ2)
else if τ ≡ e[x = y] then result ← result ∪ {e[x = y]}


register(ρ) =
if ref (ρ) ≡ 0 then enqueue(ρ); ref (ρ) ← 1 else ref (ρ) ← ref (ρ)+ 1 Fig. 2. Implementation of union-find-explain.
The explain is linear in the number of # -nodes in j ustify(x)# j ustify(y),
so it takes at most O(n h(n)) time. Since the algorithm is using the weighted- union heuristic based on the r ank structure, h(n) is bounded by log(n). In fact, the run time of explain is bounded by O(n α(n)), since the core union-


find algorithm has this complexity and any (recursive) invocation of f ind and
union produces only a constant number of # nodes.

Equality over Uninterpreted Functions
We consider the problem of inferring small justifications for problems in the theory C of equalities over uninterpreted functions. The starting point is abstract congruence closure (ACC) as defined by Kapur [8] and Bachmair and Tiwari [1]. ACC incrementally processes a finite set E of C-equalities into an equivalent configuration V, U with V a union-find-explain structure and U a set of directed, flat equalities of the form x = f (x1,... , xn) with x, xi variables. Irreducible configurations are congruence-closed in the sense that
V implies x = y if U contains x = f (x1,... , xn) and y = f (x1,... , xn). The length of any maximal derivation using the inference rules for constructing an ACC is at most quadratic in the input size. In [9] we define a canonizer
can(V,U)(t) on irreducible configurations (V, U ) and terms t for solving uniform word problems in C; that is, can(V,U)(t1) ≡ can(V,U)(t2) if, and only if, E → t1 = t2 is C-valid. In other words, a disequality t1 /=t2 is C-inconsistent with E if, and only if, can(V,U)(t1) ≡ can(V,U)(t2).
Justifying congruence closure is based on the ACC procedure in [9], and the results of Section 3 for generating irredundant bases using union-find-explain are reused below. In contrast to the developments in Section 3, however, justifications are given in terms of proof terms (see Figure 1) instead of sets of assumptions. This use of proof terms suggests various optimizations.
Example 4.1 Consider the following equality chains.

f (x ) =τ1 x  ρ1 x
=σ1 f (x	) , 

1	1	1 =  2
1	n+1

... ,

f (x ) τ=n x  ρn x
σ=n f (x	)

n	1	n =
n+1
n	n+1

With these equalities one obtains proofs (i = 1,... , n) πi := τi; ρi; σi
πi := cgf (ρ1; ... ; ρn)
2	i
for fi(x1) = fi(xn+1) . These two proofs are essentially different in that the set of assumptions Ax(πi ) and Ax(πi ) are incomparable with respect to set
1	2
inclusion. There are 2n different proofs for the equality
g(f1(x1), ..., fn(x1)) = g(f1(xn+1), ..., fn(xn+1))
depending on whether πi or πi is chosen for establishing equality between the
1	2


ith argument terms, but the only irredundant proof is cgg (π1,... , πn).
2	2
This example shows that the generation of irredundant proofs for equalities in C is expensive in general. Therefore, we introduce a weaker criterion that
only requires irredundancy for equality chaining subproofs, that is, subproofs
built up entirely from reflexivity, symmetry, and transitivity. The operator unchain transforms proofs to a set of non-equality-chaining subproofs. This operator is then used for defining a localized irredundancy criterion for proofs.

Definition 4.2 [Chaining]
unchain(ρ1; ρ2)= unchain(ρ1) ∪ unchain(ρ2)
unchain(ρ−1)= unchain(ρ) unchain(1t)= ∅ unchain(es,t)= {es,t}
unchain(cgf (ρ1,... , ρn)) = {cgf (ρ1,... , ρn)}
If ρ1 ▶ t1 = t2 and ρ2 ▶ t2 = t3, then unchain(ρ1) unchain(ρ2) is an irredundant basis (Definition 2.1) for t1 = t3. The unchaining operator is used for defining the notion of local irredundancy for proofs. Intuitively, a proof is locally irredundant if all pure equality chaining subproofs are irredundant.
Definition 4.3 [Locally Irredundant Proofs] A proof ρ for s = t is locally irredundant if
ρ ≡ 1s or ρ ≡ es,t or
ρ ≡ cgf (ρ1,... , ρn), and ρ1, ..., ρn are locally irredundant, or
ρ ≡ ρ ; ρ  or ρ ≡ ρ −1, and there is no proof ρ' for s = t, such that
1	2	1
unchain(ρ') ⊂ unchain(ρ), and for all τ ∈ unchain(ρ), τ is locally irre- dundant.
A locally irredundant proof is not necessarily irredundant.
Example 4.4 Reconsider Example 4.1.	The proof cgg (π1, π2,... , πn), for
1	2	2
example, is locally irredundant but it is not irredundant, since the proof
cgg (π1,... , πn) has a strictly smaller set of assumptions.
2	2

Example 4.5 Consider the judgement cg
f (ex,y
, ey,z
); cg
f (ex,y
−1, 1 ) ▶ f (x, y) = 

f (x, z) . This proof is locally irredundant but it is not irredundant, since ey,z
already justifies f (x, y) = f (x, z) using the proof cgf (1x, ey,z).
The operator chains,t simply converts a set of non-equality-chaining proofs for s = t, as obtained from the unchaining operator, into an equality chaining proof for s = t.

π∗(x)= ⎧ 1x	, x ≡ φ(x)
π(x) ↓ π∗(φ(x)) , otherwise


union φ π (ρ, x, y)= ⎪⎨ (φ[x' := y'], π[x' := (π∗(x −1

ρ; π∗(y))]) , y' ≺ x'

( ,  )
)	;
⎪⎪⎩ (φ[y' := x'], π[y' := (π∗(y −1;

ρ; π∗(x))]) , x' ≺ y'

where x ≡ φ (x), y ≡ φ (y) . 
Fig. 3. Union-find-explain with proofs.
Definition 4.6 Let Π be a set of non-equality chaining proofs as obtained from unchain(ρ) for ρ ▶ s = t; then:
⎧ 1t	, Π = ∅
chains,t(Π) =	ρ; chainr,t(Π − {ρ})	, ρ ∈ Π ∧ ρ ▶ s = r

⎪⎪⎩ ρ−1; chain

r,t
(Π − {ρ}) , ρ ∈ Π ∧ ρ ▶ r = s

Obviously, chains,t(Π) ▶ s = t. Equality-chaining proofs are transformed by the proof transformer ρ1 ↓ ρ2 in order to eliminate redundancies.
Definition 4.7 For ρ1 ▶ s1 = t and ρ2 ▶ s2 = t, define the join of ρ1 and ρ2
as
ρ1 ↓ ρ2 := chains1,s2 (unchain(ρ1)  unchain(ρ2)).
Notice that (ρ1 ↓ ρ2) ▶ s1 = s2 and Ax(ρ1 ↓ ρ2) ⊆ (Ax(ρ1) ∪ Ax(ρ2)). By
a slight abuse of notation, we will just write ρ ↓ ρ  for ρ ↓ ρ −1, ρ −1 ↓ ρ ,

or ρ −1 ↓ ρ −1 in the following.
1	2	1	2	1	2

1	2
The justifying ACC includes a union-find-explain structure (φ, π). Whereas, φ is identical to the one in Definition 3.1, the π component is now a function from variables to equality proof terms. The π∗ and union operations on vari-
ables in Section 3 are adjusted to include proofs instead of sets of assumptions (Figure 3).
Definition 4.8 A union-find-explain structure (φ, π) is locally irredundant if, and only if, for all x and y with φ∗(x) ≡ φ∗(y), the proof π∗(x) ↓ π∗(y) is locally irredundant.
By replacing symmetric difference on sets of assumptions by the join oper- ator, irredundant proofs for variable equalities are obtained as in Theorem 3.4.


Lemma 4.9 Let (φ, π) be a union-find-explain structure with proofs for a set of equalities (see Figure 3), then:
π∗(x) is a locally irredundant proof for x = φ∗(x), and
(φ, π) is locally irredundant.
Proof. Similar to Theorem 3.4.	 
Example 4.10 For the literals in Example 3.5 one obtains the union-find- explain structure (φ, π) with
φ := {x '→ w, z '→ w, y '→ w}
π := {x '→ ex,w, z '→ (ex,z−1; ex,w), y '→ (ey,z; ex,z−1; ex,w)}
and a proof of x = y is ex,z; ey,z−1 because (ex,w) ↓ (ey,z ; ex,z−1; ex,w)
= chainx,y(unchain(ex,w)  unchain(ey,z; ex,z−1; ex,w))
= chainx,y({ex,w}  {ey,z, ex,z, ex,w})
= chainx,y({ey,z, ex,z})
= ex,z; ey,z −1.
Configurations of justifying ACC include (V, U ) with V a union-find-explain structure and U a renaming context for representing a finite set of equalities u = f (x1,... , xn).
Definition 4.11 A renaming context is a finite map of bindings of the form u '→ f (x1 : ρ1,... , xn : ρn) with u, x1,... , xn ∈ V and ρi ▶ ti = xi for terms ti (i = 1,... , n).
Definition 4.12  A pair (V, U ) consisting of a union-find-explain structure and a renaming context is locally irredundant if
V is a locally irredundant, and
for every u '→ f (x1 : ρ1,... , xn : ρn) in U , ρ1, ..., ρn are locally irredun- dant proofs.
Abstract congruence closure (ACC) flattens input terms by introducing fresh renaming variables for nested flat subterms. The initial step in processing an equality or disequality in the ACC procedure compiles terms into variables by iteratively replacing flat subterms f (x1,... , xn) with a renaming variable from a possibly extended renaming context. The following canonizer includes flattening and always returns a variable which is equal to the argument term in a possibly extended renaming context.
Definition 4.13 For a union-find-explain structure V = (φ, π) and a justify- ing renaming context U , define:



can

(V,U )
= (φ∗(x) : π∗(x), U )

⎧⎪ (φ∗(u) : cg (ρ ↓ τ ,...,ρ  ↓ τ ); π∗(u),U )
f	1	1	n	n	n
⎪

can
(f (t ,... ,t )) = ⎪⎨
if (u '→ f (x1 : τ1,... , xn : τn)) ∈ Un

(V,U )	1
n
(v : 1v, {v '→ f (x1 : ρ1,... , xn : ρn)}∪ Un)
⎪

⎪⎩	otherwise (with v fresh)
where  (x1 : ρ1, U1) = can(V,U)(t1),
(x2 : ρ2, U2) = can(V,U1 )(t2),... ,
(xn : ρn, Un) = can(V,Un−1 )(tn) . 
can(V,U)(t) is a canonizer in the sense that the x ≡ y for (x, ) = can(V,U)(t1) and (y, ) = can(V,U)(t2) if, and only if, t1 = t2 is validated by the equalities
of (V, U ) [9]. Moreover, this canonizer returns locally irredundant proofs for the equality of its source and target term.
Lemma 4.14  If (V, U ) is locally irredundant, and can(V,U)(t) = (x : ρ, U '), then
(V, U ') is also locally irredundant, and
ρ is a locally irredundant proof for t = x.
Proof. By induction on the structure of the term t, and Lemma 4.9.	 
A justifying ACC inference system for processing equalities and disequal- ities over uninterpreted functions is described in Figure 4. Conﬁgurations (Γ, D, V,U ) of this inference system consist of a finite set Γ of assumptions of the form es,t and ds,t, a finite set D of variable disequalities ds,t '→ (x : ρ1) /=y (: ρ2) with ρ1 ▶ s = x and ρ2 ▶ t = y, a union-find-explain structure V = (φ, π), and a renaming context U .
Definition 4.15 A configuration (Γ, D, V,U ) is locally irredundant if V, U is locally irredundant according to Definition 4.12, and for every ds,t '→ (x : ρ1) /=y (: ρ2) in D, ρ1 and ρ2 are locally irredundant.
The eq rule in Figure 4 processes input equalities s = t by merging the corresponding decorated variables in V , and, similarly, diseq processes dise- qualities s /=t. Disequalities x /=x are reduced to the unsatisfiable ⊥ using the bot rule, whereas cong deduces variable equalities u = v from u = t and v = t with t a flat term, and uprop and dprop propagate variable equalities into renaming contexts U and disequalities D, respectively. Here, dprop is applied symmetrically.


eq	({es,t}∪ Γ, V, D, U )	''
−1
(Γ, unionV ((τ  ; es,t; σ), x, y), D, U )
where (x : τ, U )= can(V,U)(s) and (y : σ, U )= can(V,U')(t)

diseq	({ds,t}∪ Γ, V, D, U )	''
(Γ, V, {ds,t '→ (x : τ ) /= (y : σ)}∪ D, U )
where (x : τ, U )= can(V,U)(s), and (y : σ, U )= can(V,U')(t)
bot	(Γ, V, {ds,t '→ (x : τ ) /= (x : σ)}∪ D, U )
unsat (ds,t,τ ↓ σ)
uprop	 (Γ, (φ, π), D, {u '→ f(x1 : ρ1,. .., xi : ρi,..., xn : ρn)}∪ U ) 
(Γ, (φ, π), D, {u '→ f (x1 : ρ1,. ..,y : ρi ↓ τ,..., xn : ρn)}∪ U )
where φ (xi) ≡ y and π (xi)= τ

dprop	 (Γ, (φ, π), {ds,t '→ (x : σ1) /= (z : σ2)}∪ D, U ) 
(Γ, (φ, π), {ds,t '→ (y : τ ↓ σ1) /= (z : σ2 )}∪ D, U )
where φ (x) ≡ y and π (x)= τ

(Γ, V, D,	u '→ f (x1 : ρ1,, ..., xn : ρn),	∪ U )
v '→ f (x1 : τ1,, ..., xn : τn)

cong
'	
(Γ, V , D, {u '→ f (x1 : ρ1, ,..., xn : ρn)}∪ U )

where V ' = union
(cg (ρ ↓ τ ,.. .,ρ ↓ τ ), u, v)

V	f  1	1	n	n

Fig. 4. Abstract congruence closure with proofs.



For termination, soundness and completion of undecorated versions of this abstract congruence closure procedure see, for example, [1,9].

Theorem 4.16 Let Γ be an unsatisfiable, finite set of C-equalities and C- disequalities, and let unsat (ds,t, ρ) be an irreducible configuration with respect to the justifying ACC inference system in Figure 4 and starting configuration
(Γ, (λx.x, λx.1x), ∅, ∅), then ρ is a locally irredundant proof.

Proof. Clearly the initial configuration is locally irredundant. By Lemmas 4.9 and 4.14, all rules but bot preserve local irredundancy. The proof ρ ≡ τ ↓ σ obtained by the application of the bot rule is locally irredundant, because τ and σ are locally irredundant proofs for s = x and t = x (Lemma 4.9). 


Example 4.17 Processing {x
ρ1 f (x ), x
ρ2 f (x ), x
ρ3 x , x
ρ4 x , x ρ5

1 =	2	3 =
4	5 =  6
2 =  5	4 =


x5} from the left to right yields the final configuration

⎧⎪⎨ x

ρ
u ,	x

ρ
u ,	x

ρ3 x
⎫⎪⎬


⎪⎩ x
ρ4; ρ3 x , x ρ5; ρ3 x , u 
f	4	5
u ⎪⎭

First, canonization of x1 yields (x1 : 1x1 ) and canonization of f (x2) yields (u1 : 1u1 ), where u1 is a fresh variable and u1 '→ f (x2 : 1x2 ) is the corre- sponding renaming. Using rule eq, variables x1 and u1 are merged with proof
(1 −1; ρ ; 1  ) = ρ . Second, when processing x = f (x ), x canonizes to
x1	1	u1	1	3	4	3
(x3 : 1x3 ) and f (x4) canonizes to (u2 : 1u2 ), where u2 is fresh variable and u2 '→ f (x4 : 1x4 ) is the corresponding renaming. Thus, x3 and u2 are merged with proof ρ2 (rule eq). Third, x5 and x6 are canonized to (x5 : 1x5 ) and (x6 : 1x6 ), respectively. Using rule eq, variables x5 and x6 are merged with proof ρ3. Forth, x2 and x5 are canonized to (x2 : 1x2 ) and (x6 : ρ3), re- spectively. Using rule eq, variables x2 and x6 are merged with proof ρ4; ρ3.
This variable equality is propagated (rule uprop) to obtain the instantiated renaming u1 '→ f (x6 : ρ4; ρ3). Finally, x4 and x5 are canonized to (x4 : 1x4 ) and (x6 : ρ3), respectively. Using rule eq, variables x4 and x6 are merged with proof ρ5; ρ3. This variable equality is propagated (rule uprop) to obtain the instantiated renaming u2 '→ f (x6 : ρ5; ρ3). Using rule cong, variables u1
and u are merged with proof cg ((ρ ; ρ ) ↓ (ρ ; ρ )) = cg (ρ ; ρ −1), and the
2	f	4	3	5	3	f	4	5
renaming u1 '→ f (x6 : ρ4; ρ3) is removed from U .
Now, consider the implied equality f (x2) = f (x4).	Its left hand side
f (x ) canonizes to (u	: cg (ρ ; ρ −1)), whereas f (x ) canonizes to (u	:
2	2	f	4	5	4	2
cg ((ρ ; ρ ) ↓ (ρ ; ρ ))) = (u : 1  ). Thus (cg (ρ ; ρ −1)) ↓ 1	= cg (ρ ; ρ −1)

f	5	3	5	3
2	x4
f	4	5
x4	f	4	5

is a locally irredundant proof for f (x2) = f (x4). This proof also happens to be
minimal. Now, consider the implied equality f (x2) = f (x6). The right hand
side f (x ) canonizes to (u : cg (ρ ; ρ )). Thus cg (ρ ; ρ −1); cg (ρ ; ρ ) is a

6	2	f	5	3
f	4	5
f	5	3

locally irredundant proof for f (x2) = f (x6), but it is not irredundant. How-
ever, this proof can be simplied using the following identity on proofs.
(cg f (τ1,..., τn); cg f (σ1,... , σn)) = cgf (τ1 ↓ σ1,... , τn ↓ σn)
Thus we obtain the irredundant proof cg ((ρ ; ρ −1) ↓ (ρ ; ρ )) = cg (ρ ; ρ ) for f (x2) = f (x6).
Lemma 4.18
Ax(cgf (τ1 ↓ σ1,... , τn ↓ σn)) ⊆ Ax(cg f (τ1,... , τn); cgf (σ1,... , σn))
Proof. Using Ax(ρ1 ↓ ρ2) ⊆ (Ax(ρ1) ∪ Ax(ρ2)).	 


In general justifying ACC does not yield irredundant proofs or even min- imal proofs (Example 4.1), but irredundant proofs may be obtained by re- placing equality-chaining subproofs σ with congruence subproofs τ whenever
Ax(τ ) ⊆ Ax(σ). For example, the proof cgf (σ); cgf (τ ) might be replaced by
cgf (σ ↓ τ ). In cases Ax(σ) and Ax(τ ) are incomparable with respect to set inclusion (as is the case in Example 4.1), however, it is unclear which proof should be used, since the proof transformation may now depend on the struc-
ture of the complete proof. Therefore, it seems too expensive, in practice, to produce (globally) irredundant proofs, and, arguably, maintaining locally irredundant proofs is a good compromise between the conflicting goals of con- ciseness of justifications and associated computational costs.

Conclusions
We have presented systems for proving irredundant proofs for variable equality and extended this proof-producing system to obtain “small”, that is, locally ir- redundant proofs, for abstract congruence closure. The main characteristics of our proof-producing extensions is that they do not change the underlying algo- rithms and therefore the algorithmic advantage of canonization is maintained. Although it is possible to maintain fully irredundant proofs for congruence closure and other theories, this may be prohibitively expensive in practice as search is involved.
Our approach can be extended to also work for other inference systems such as Gaussian elimination for the linear arithmetic equality theory. Polynomials are decorated with proofs to obtain (q0 + q1x1 : σ1 + ...+ qnxn : σn) : ρ. Such a
decoration represents a proof (ρ; cg (σ ,...,σ )) for p' = q + q x + ... + q x ,
1	n	0	1 1	n  n
for some source polynomial p'. Our justifying equality framework can also be applied to obtain small proofs for a Shostak combination [9].


References
L. Bachmair and A. Tiwari. Abstract congruence closure and specializations. In D. McAllester, editor, Automated Deduction—CADE-17, volume 1831 of LNAI, pages 64–78. Springer, June 2000.
C.W. Barrett, D.L. Dill, and A. Stump. Checking satisfiability of first-order formulas by incremental translation to SAT. In Computer-Aided Veriﬁcation, CAV ’2002, volume 2404 of LNCS, pages 236–249. Springer, July 2002.
T.H. Cormen, C.E. Leiserson, and R.L. Rivest. Introduction to Algorithms. The MIT Press, Cambridge, MA, 1990.
S. Das and D.L. Dill. Counter-example based predicate discovery in predicate abstraction. In
Formal Methods in Computer-Aided Design, LNCS, pages 19–32. Springer, November 2002.


L. de Moura and H. Rueß. Lemmas on demand for satisfiability solvers. In Fifth International Symposium on the Theory and Applications of Satisﬁability Testing (SAT’02), May 2002. Extended version at http://www.csl.sri.com/users/ruess/papers/SAT2002/index.html.
L. de Moura, H. Rueß, and M. Sorea. Lazy theorem proving for bounded model checking over infinite domains. In A. Voronkov, editor, International Conference on Automated Deduction (CADE’02), volume 2392 of LNCS, pages 438–455. Springer, July 2002.
Z. Galil and O. Margalit. Witnesses for boolean matrix multiplication and for transitive closure.
Journal of Complexity, 9:201–221, 1993.
D. Kapur. Shostak’s congruence closure as completion. In H. Comon, editor, Rewriting Techniques and Applications, RTA 1997, volume 1103 of LNCS, pages 23–37. Springer, July 1997.
N. Shankar and H. Rueß. Combining Shostak theories. In S. Tison, editor, RTA‘02, volume 2378 of LNCS, pages 1–18. Springer, 2002.
J. R. Shoenfield. Mathematical Logic. Addison-Wesley, Reading, MA, 1967.
R.E. Tarjan. Efficiency of a good but not linear set union algorithm. Journal of the ACM, pages 215–225, 1975.
A. Tiwari. Personal communication. June 2004.
S.A. Wolfman and D.S. Weld. The LPSAT engine: Its application to resource planning. In
IJCAI, pages 310–317, 1999.
