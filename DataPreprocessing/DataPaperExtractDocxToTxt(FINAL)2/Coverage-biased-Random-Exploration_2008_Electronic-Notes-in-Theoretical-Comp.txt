

Electronic Notes in Theoretical Computer Science 220 (2008) 3–14
www.elsevier.com/locate/entcs

Coverage-biased Random Exploration of Models
Marie-Claude Gaudel,a,1,2 Alain Denise,a,3 Sandrine-Dominique Gouraud,a,3 Richard Lassaigne,b,4
Johan Oudinetb,5 and Sylvain Peyronnetb,5
a LRI
Universit´e Paris-Sud 91405 Orsay, France
b Equipe de Logique Universit´e Paris 7
75013 Paris, France

Abstract
This paper describes a set of methods for randomly drawing traces in large models either uniformly among all traces, or with a coverage criterion as target. Classical random walk methods have some drawbacks. In case of irregular topology of the underlying graph, uniform choice of the next state is far from being optimal from a coverage point of view. Moreover, for the same reason, it is generally not practicable to get an estimation of the coverage obtained after one or several random walks: it would require some complex global analysis of the model topology. We present here some methods that give up the uniform choice of the next state. These methods bias this choice according to the number of traces, or states, or transitions, reachable via each successor.
Keywords: D.2.4 Software/Program Verification, D.2.5 Testing and Debugging, G.2.1 Combinatorics


Introduction
This paper describes a set of methods for randomly drawing traces in large models either uniformly among all traces, or with a coverage criterion as target.
Classical random walk methods have some drawbacks. In case of irregular topol- ogy of the underlying graph, uniform choice of the next state is far from being op-

1 Marie-Claude Gaudel warmly thanks the MBT08 chairs for the invitation to the workshop and to the proceedings
2 Email: mcg@lri.fr
3 Email: {denise, gouraud}@lri.fr
4 Email: lassaign@logique.jussieu.fr
5 Email: {Johan.Oudinet, syp}@lri.fr

1571-0661 © 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.11.002

timal from a coverage point of view. For instance, in Figure 1, when considering traces of length 3, trace b.e.f is followed with probability 0.5 while trace a.c.d has probability 0.03125 only. Moreover, for the same reason, it is generally not practica- ble to get an estimation of the coverage obtained after one or several random walks: it would require some complex global analysis of the model topology. We present







Fig. 1. Some example of irregular topology

here some methods that give up the uniform choice of the next state. They bias this choice according to the number of traces, or states, or transitions, reachable via each successor. The methods rely upon techniques for counting and drawing uniformly at random words in regular languages as defined by Flajolet et al. [5] and imple- mented in the CS package of the Mupad environment [12]. These techniques have, in the considered cases, a linear complexity in the size of the underlying automata, thus they allow dealing with rather large models.
Taking into account the number of traces starting from a state, it is shown in section 2 how it is possible to ensure a uniform probability on traces of a given length, or below a given length.
However, even linear complexity techniques cannot cope with very large models. But it is possible to exploit the fact that most of them are the result of the concurrent composition of several components, i.e a product, synchronised or not, of several models. Each component is considered as an automaton defining such a language. It is shown how it is possible to combine local uniform drawings of traces, and to obtain some global uniform random sampling, without constructing the global model. This is described in section 3
Considering coverage of other elements of the model than traces, such as states or transitions, is done by maximising the minimum probability to reach such an element, thus biasing random exploration toward classical coverage criteria such as state coverage or transition coverage, or less classical ones. Thus the probability

of reaching a given coverage criterion after a certain number of drawings can be assessed. This is described in section 4.

Uniform generation of traces of a given length
First, let us consider traces of a given length n. Given any state s, let ls(k) be the number of traces of length k that start from s. If s has m successors s1, s2,..., sm, a condition for trace uniformity is to choose si after s with probability lsi (k−1)/ls(k). The issue is to compute these probabilities in an efficient way. Fortunately, traces in a model can be expressed as combinatorial structures. The next subsection is a very short introduction to these structures and powerful methods for counting them.

A few words on counting and drawing combinatorial structures
Two major approaches have been developed for counting and drawing uniformly at random combinatorial structures : The Markov Chain Monte-Carlo approach (see e.g. the survey by Jerrum and Sinclair [8]) and the so-called recursive method, as described by Flajolet et al. in [5] and implemented in [12]. Although the former is more general in its applications, the latter is particularly efficient for dealing with a very large class of structures, namely those formed of atoms combined by the following constructions:
+, ×, Seq, PSet, MSet, Cyc
respectively corresponding to disjoint union, cartesian product, finite sequence, set, multiset, directed cycles. It is possible to state cardinality constraints via subscripts (for instance Seq≤3). These structures are called decomposable structures. The size
of an object is the number of atoms it contains.
The enumeration of decomposable structures is based on generating functions. Let Cn be the number of objects of C of size n, the corresponding generating function is:
C(z) = Σ Cnzn
n≥0
Decomposable structures can be translated into generating functions using classical results of combinatorial analysis. For instance, the specification B = Z + (B× B) that defines binary trees, becomes B = z + B2. A comprehensive dictionary is given in [5].
The main result on counting and uniform random generation of decomposable structures is:
Theorem 2.1 Consider a combinatorial class C, which is decomposable. Then the counts {Cj|j = 0 ... n} can be computed in O(n1+є) arithmetic operations. In addi- tion, it is possible to draw an element of size n uniformly at random in O(n log n) arithmetic operations in the worst case.

Remark 2.2 A first version of this theorem, with a computation of the count- ing sequence {Cj|j = 0 ... n} in O(n2) was given by Flajolet et al. in [5]. The improvement to O(n1+є) is due to van der Hoeven [13].
This theory has led to powerful practical tools for random generation [12]. There is a preprocessing step for the construction of the {Cj|j = 0 ... n} tables . Then the drawing is performed following the decomposition pattern of C, taking into account the cardinalities of the involved sub-structures.

Drawing uniformly at random traces of length n
Traces can be considered as decomposable structures where atoms are transitions that are combined by products and disjoint unions. For such simple structures, uniform drawing of size n is in O(n).
For a given length n, the number ls(k),k = 0,...,n of traces of length k starting from state s is given by the following recurrence formulas:
ls(0) = 1 
ls(k) = Σ ls' (k − 1)for k > 0
s→s'
where s → s' means that there exists a transition from s to s'.
From the theorem above, it is possible to compute these values in linear time. However, the number of values to be stored is n times the number of states of the model. This is the bottleneck of the method.

Generalisation to traces of length ≤ n
It is possible to generate traces of length ≤ n instead of exactly n, by performing a
small change in the model. It is sufficient to add a new state s' which becomes the
new initial state, with a fictive transition from s' to s0 and a fictive loop transition

from s'
to itself. Each trace of length n + 1 from s'
to a state of this new model

crosses k times the new loop transition for some k such that 0 ≤ k ≤ n and exactly
once the one from s' to s0. It is obvious to associate to such a trace a trace of
length n − k of the original model. It is straightforward to verify that any trace of length ≤ n can be generated in such a way, and the generation is uniform.

Some experimental results
We report some experiments performed on models of the VLTS (Very Large Transi- tion Systems) benchmark suite that is maintained by INRIA and CWI and available at http://tinyurl.com/yuroxx. These first experiments have been performed on a Intel Xeon 2.80GHz processor with 1GB memory, only. The table below was first published in [10].
As said above, the main problem is memory. When there is enough memory to store the ls(k),k = 0,..., n, it is very efficient. However, one can see in Table 1


Table 1
Elapsed time for uniform drawing of 100 traces of various lengths in models of various sizes. ✓ means there is not enough memory to build the table of the ls(i)

that it was not possible to deal with systems of size more than 104 states. Even if the memory size of the processor was bigger, it is rather unlikely that it would be possible to gain an order of magnitude. This is the motivation of the next section, where we show that generating traces of composed models allows to handle up to 1027 states and more.

Uniform trace generation in products of models
Fortunately, huge models are rarely stated from scratch. They are obtained by com- position of smaller ones, the main source of state number explosion being parallel compositions. We show here how to use uniform random walks in the components to perform (approximately) uniform random walks in the global system.

Parallel composition without synchronisation
When there is no synchronisation, the parallel composition of r models Mod1,...,Modr is the product of the underlying automata [1]. The set of states is the cartesian product of the states of the Modi models. Transitions are labelled by the union of the labels of the Modi models. Traces are interleavings of local traces, namely of traces of the Modi models. A brute force method to uniformly drawing traces is to build the product and to use the methods above. Since it is possible for moderate sizes only (more or less 104 states) we have developed an alternative method that avoids the construction of the global model. This method is presented in detail in [3] and [10]. We sketch it below.
Given n the length of the global trace to be drawn
Choose some lengths n1,..., nr such that Σi=1,...,r ni = n, with adequate proba-
bilities (see below)
For each Modi, draw uniformly at random some trace wi of length ni

Interleave the r wi in a randomised way that ensures uniformity among interleav- ings.
Let l(n) be the number of global traces of length n, and li(k),i = 1,...,r the number of traces of length k in Modi. The choice of the n1,..., nr should be done with the probability below:


(1)

Pr(n1,..., nr) =
n n1,...,nr
 l1(n1) ... lr(nr) l(n)

where the numerator is the number of interleavings of length n that can be built with r local traces of lengths n1,..., nr. Since computing the exact value of l(n) would require the construction of the global model and of the corresponding tables, we use the following approximation from [4]:
(2)	l(n) ∼ Cωn.
where C and ω are two constants. A sufficient, but not necessary, condition for this approximation to hold is aperiodicity and strong connectivity of the automaton, which is satisfied by any LTS with a reset. Details of weaker conditions can be found in [4]. This approximation is precise enough even for small values of n since Cωn/l(n) converges to 1 at exponential rate.
Using the same approximations for the li(ni),i = 1,..., r, we get (see [3]):

(3)
and then
l(n) ∼ C1 ... Cr(ω1 + ... + ωr)n

	n	 ωn1 ωn2 ... ωnr

(4)
Pr(n ,...,n ) ∼
n1,...,nr	1	2	r  .

1	r	(ω1 + ω2 + ... + ωr)n
This avoids the computation of l(n), and the constants ωi,i = 1,...,r are com- putable in polynomial time with respect to the size of the Modi. It means that the complexity is dependent on the size of the components only, and not of the size of the global model.
In [3], we provide an algorithm for drawing n1,..., nr with this probability
without computing it: draw a random sequence of n integers in {1,..., r}, with the probability to choose i equal to Pr(i) =    ωi	 ; then take as ni the number of
occurrences of i in this sequence.
This concludes the issue of the choice of the n1,..., nr. Below, we recall a classical randomised way of interleaving r wi of lengths ni that ensures uniformity. Algorithm 1 w ← ε; n ← Σi=1...r ni;
while n > 0 do {
choose i in {1,..., r} with probability ni/n ; put the ﬁrst symbol of wi at the end of w ; remove the ﬁrst symbol of wi ;
ni ← ni − 1; n ← n − 1 }
done

To summarise, we have presented a way of drawing traces of length n approximately uniformly at random in a product of r models Modi, without constructing the product. The complexity of the method is:
polynomial (cubic) in the sizes of the Modi models for the computations of the constants ωi, that are done once only for each i, i = 1,..., r, as pre-processing the drawings of the ni,
linear in n for the drawing of the ni,
linear, in the sizes of the Modi models and in n, for pre-processing the uniform local drawings of the wi, to be done once only for each i, i = 1,..., r,
linear in ni for the drawing of the local wi,
linear in n for the interleaving of the wi.
Table 2 gives the average times for drawing 100 traces of lengths 200 to 8000 in compositions of the vasy 0 1 model (see Table 1) with itself 6 . The vasy 0 1 model
has 289 states.

Table 2
Average times for drawing 100 traces in composed models without synchronisation (vasy 0 1 is composed with itself).

We observe that 28912 is of the same order as 1027. It means that this method is applicable to very large models. Other experiments are reported in [10].

Parallel composition with synchronisation
We present here the generalisation of the method above to synchronised products when there is one synchronised transition in every model. Let note α its label, s→α
its origin state in Modi, and sα→ its target state in Modi model.
A trace in the synchronised product [1] of the Modi models has the following

6 This table is slightly different from the one presented during the workshop, and it is also the case for Table 3. New experiment campaigns have been performed with a new implementation where pre-processings and drawings are no more performed with MUPAD, but with a specific C++ library. Each figure in these new tables corresponds to the average time for ten drawings.

shape:

W0αW1αW2α... αWm

where m is the number of occurrences of α and
W0 is some interleaving of r local traces w0,i = 1,..., r, without α, that respec- tively start from the initial state of Modi and lead to s→α,
W1 is some interleaving of r local traces w1,i = 1,..., r, without α, that re- spectively start from sα→ and lead to s→α; W2,..., Wm−1 are defined in similar
i	i
ways.
Wm is some interleaving of r local traces wm,i = 1,..., r, without α, that respec- tively start from sα→ and lead to any state of Modi.
Moreover, there is a special case for m = 0, namely interleavings of r local traces wi,i = 1,..., r, without α, that respectively start from the initial state of Modi and lead to any state of Modi.
The definition above leads to consider four sub-languages of traces without α
for each Modi, i.e. four sub-models.
The generalisation of the method of subsection 3.1 is sketched below:
Given n the length of the global trace to be drawn,
Choose some m with probability l(n, m)/l(n) where l(m, n) is the number of global traces of length n with m synchronisations α,
Choose some lengths i0,..., im for the W0,..., Wm such that Σk=0,...,m ik =
n − m, with adequate probabilities,
For each Wk, draw uniformly at random some global trace of length ik in the product of the r relevant sub-models using the method of subsection 3.1,
Build the concatenation of the m +1 Wk interspersed with m occurrences of α.
Details on the computations of the suitable probabilities, using the same approxi- mation as in subsection 3.1 can be found in [3] and in [9]. The approximate com- putation of the values l(n, m)/l(n) is in O(n3 + r) operations and needs to be done once only for a given n. Drawing is quadratic in n. The various pre-processings are polynomial in the size of the biggest Modi model.
We performed some experiments using a modified version of the vasy 0 1 model (see Table 1), where we picked at random a transition and labelled it as synchro- nised, that we composed with itself several times (2 to 12). Table 3 gives the average times for drawing 100 traces of lengths 100 to 600 in these compositions. The limitation to 600 is due, again, to memory overflow during the pre-processing.

The generalisation to several synchronisations is sketched in [9] and is the topic of an on-going Ph.D. thesis. Preliminary results on complexity let think that it will be practicable in the case of a small number of synchronisations only. However, in presence of many synchronisations, the synchronised product is smaller and a brute-force method, where it is constructed and used for uniform drawings, may become feasible. Actually, practical solutions are probably combinations of these


Table 3
Average time for drawing 100 traces in composed systems with synchronisation (the modified version of
vasy 0 1 is composed with itself).

two approaches depending on the architecture of the global system. The classifica- tion of architecture patterns accordingly to such combinations is also part of this on-going work.

Combination of weaker coverage criteria and random- ness
Until now, we have considered as coverage criterion the coverage of all paths of length ≤ n. This criterion is very demanding and in practice other ones are used, such as all transitions or all states. In this section we discuss the following questions: How a randomised selection of paths can ensure a good coverage of such elements of a model? What does it mean to “satisfy” a coverage criteria in a randomised framework? Then we provide some method for drawing traces according to such coverage criteria.

Quality of a random distribution on traces w.r.t. a coverage criterion
Let G be some graph, and Ω some distribution on its paths (bounded by a given length if there are loops). Given a coverage criterion C that requires a set
{e1,..., em} of elements of G to be covered, Ω defines some probabilities pi to reach
ei,i = 1,...,m when drawing a path in G. Let pmin = min(p1,..., pm). Similarly to Th´evenod-Fosse and Waeselink in [11] we start with the idea that pmin char- acterises the quality of distribution Ω w.r.t. coverage criterion C. Thus it seems natural, for a given G and a given C to define the Ω distribution in a way such that pmin is maximum.
However, maximising pmin must not lead to give up the randomness of the method. It may happen, for instance, when there is a path in G going through all the elements e1,..., em to be covered. In this case, maximising pmin leads to give probability 1 to this path and 0 to all the other ones, yielding a deterministic

exploration strategy of the graph...
It turns out that biasing random walks toward coverage criteria in an optimal way is a somewhat difficult multi-criteria problem that would requires, in addition to the maximisation of pmin, a non null probability for any path traversing an element to be covered. Even more, to be coherent with the maximisation of pmin, the minimal probability on such paths should be maximised. But there are cases where these requirements are contradictory (see [7], [6]).
In the next sub-section, we present a method that slightly weakens these re- quirements. It makes it possible to draw paths at random in such a way that: any path traversing an element to be covered must have a non-null probability and the minimal probability of reaching by a path any element to be covered is maximum.
A drawing method in two steps
Given a graph G and a set S = {e1,..., em} of elements to be covered (vertices or arcs of G), drawing a path of length ≤ n is performed in the following way:
Draw non uniformly some e among the e1,..., em with probabilities πi,i = 1,...,m (the determination of these probabilities is given below),
Draw uniformly a path of length ≤ n among those traversing e.
Let αi the number of paths of length ≤ n in G traversing ei, and αi,j the number of paths of length ≤ n in G traversing both ei and ej, the probability of an element ei,i = 1,...,m to be reached when drawing a path is:




which simplifies to
pi = πi
+	Σ
j∈[1..m]−{i}

m
π αi,j ,
j αj

(5)
pi = Σ π
j=1
αi,j
j αj

since αi,i = αi. Note that using techniques for counting combinatorial structures as seen in subsection 2.1, the αi and αi,j can be efficiently computed. More details can be found in [2].
We now explain how to compute the πi values in order to fulfill the two require- ments stated in the above sub-section. The values πi,i = 1,...,m must satisfy the following two first constraints:
π1 + ... + πm = 1,	∀i = 1,..., m, πi ≥ ε
The second constraint is sufficient to ensure that any path traversing an element to be covered has a non-null probability. The choice of the value of ε is a matter of balance between the two requirements: the bigger it is, the smaller is the maximum possible value of pmin. Moreover, pmin must satisfy the following constraints, that are linear in πi:

∀i ≤ m,	p

min
≤ pi
= Σ π
j=1
αi,j
j αj

Therefore, the maximisation of pmin is just a linear programming problem where the unknowns are the πi,i = 1,... m. Thus standard methods that are polynomial in m can be used.
This method was implemented and experimented on some C programs. Some experimental results are reported in [6] and [2].

Assessing coverage satisfaction
For deterministic testing methods, coverage satisfaction is a binary concept: either it is achieved by a test set, or not. Moreover, the minimal required number of tests can be determined. In the case of randomised testing methods, coverage satisfaction becomes a probabilistic concept: what is the probability of satisfying a given criterion after a certain number of tests? What number of tests are required to satisfy it with a given probability?
Given a random test method based on some distribution Ω on the paths of a graph G, and a coverage criterion C characterised by a set S = {e1,..., em} of elements to be covered, the probability to reach element ei after N tests is greater than 1 − (1 − pmin)N . This gives a minorant of the probability to satisfy C after N
tests.
Conversely, the number N of tests to reach criterion C with a given probability
pC satisfies the inequality:

(6)
 log(1 − pC) 
log(1 − pmin)

We get the minimum required number of tests to satisfy C with a given probability.

Conclusion
In this paper, we have briefly presented how to combine random exploration of models and coverage criteria. We have reported some promising first results in this area. A common basis of these various pieces of work is that they are based upon powerful techniques on counting and drawing uniformly at random combinatorial structures. It is our belief that these techniques could bring much to simulation, model based testing, structural testing or model-checking.

References
Arnold A. , “Finite Transition Systems”, Prentice-Hall, 1994.
A. Denise, M.-C. Gaudel et S.-D. Gouraud. A Generic Method for Statistical Testing, 15th IEEE Int. Symp. on Software Reliability Engineering (ISSRE), 25-34, (2004).
Denise A., M.-C. Gaudel, S.-D. Gouraud, R. Lassaigne and S. Peyronnet. Uniform Random Sampling of Traces in very Large Models. 1st Int. ACM Workshop on Random Testing (2006), 10 -19, ACM Press.
Ph. Flajolet and R. Sedgewick. Analytic combinatorics: functional equations, rational, and algebraic functions, INRIA Research Report RR4103, January 2001, 98 pages. Part of the book project “Analytic Combinatorics”. URL: http://algo.inria.fr/flajolet/Publications/books.html.

Flajolet Ph., and P. Zimmermann, and B. Van Cutsem. A Calculus for the Random Generation of Labelled Combinatorial Structures, Theoretical Computer Science, 132 (1994), 1-35.
Gouraud S.-D. “Utilisation des Structures Combinatoires pour le Test Statistique”. PhD thesis, Universit´e Paris-Sud 11, Orsay, 2004.
Gouraud S.-D., A. Denise, M.-C. Gaudel, and B. Marre. A new way of automating statistical testing methods. In IEEE Int. Conf. on Automated Software Engineering (ASE), 5-12, 2001.
Jerrum M., and A. Sinclair. The Markov chain Monte Carlo method: an approach to approximate counting and integration. in “Approximation Algorithms for NP-hard Problems”, D.S.Hochbaum ed., PWS Publishing, Boston, 1996.
Oudinet J. “Uniform random walks in concurrent models”. Master thesis, Universit´e de Paris-Sud, 2007 URL: http://www.lri.fr/~oudinet/publis/07/mthesis.pdf

Oudinet J. Uniform random walks in very large models. 2nd Int. ACM workshop on Random testing (2007) 26-29, ACM Press.
Th´evenod-Fosse P. and H. Waeselynck. An investigation of software statistical testing. Journal of Software Testing, Verification and Reliability, 1(2), (1991), 5-26.
Thi´ery N. M. Mupad-combinat algebraic combinatorics package for MUPAD. URL: http://mupad-combinat.sourceforge.net/.
van der Hoeven J. Relax, but dont be too lazy, Journal of Symbolic Computation, 34(6) (2002), 479-542.
