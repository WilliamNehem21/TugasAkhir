

Electronic Notes in Theoretical Computer Science 264 (2010) 177–197
www.elsevier.com/locate/entcs

Coinduction in Concurrent Timed Systems
Jan Komenda1 ,2
Institute of Mathematics, Czech Academy of Sciences, Brno, Czech Republic

Abstract
An important class of timed transition systems can be modeled by deterministic weighted automata, which are essentially partial Mealy automata, and their extensions using synchronous compositions defined over extended alphabets. From a coalgebraic viewpoint, behaviours of deterministic partial Mealy automata are causal and length preserving partial functions between finite and infinite sequences of inputs and out- puts, called stream functionals. After a study of fundamental properties of functional stream calculus an application to the definition by coinduction of the synchronous product of stream functionals is proposed.
Keywords: deterministic weighted automata, Mealy automata, final coalgebra, synchronous product, coinduction


Introduction
Universal coalgebra as a general theory of (dynamical) systems offers definitions and proofs by coinduction [16], which are complementary to classical approaches based on induction and turned out to be valuable in simplifying the definitions and proofs of many concepts and properties that are hard or even impossible to for- mulate within the algebraic framework. The techniques borrowed from coalgebra have proven their usefullness in many areas of theoretical computer science (e.g. functional and object orienting programming), but also in control theory, in par- ticular of discrete state transition systems that are called in control community discrete-event systems. The reference model for discrete-event systems are partial automata, which are coalgebras of a functor on the category of sets. They have been studied in [15] as the model for control of discrete-event (dynamical) systems (DES) together with the partial automaton of (partial) languages as the final coalgebra. Purely logical DES in the form of partial automata have also been studied using coalgebraic techniques in [10].

1 Email: komenda@math.cas.cz
2 This work was supported by the Academy of Sciences of the Czech Republic, Inst. Research Plan No. AV0Z10190503 and by 7FP EU.ICT project DISC, N.224498.

1571-0661 © 2010 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2010.07.020

Deterministic weighted automata and more generally deterministic transducers are typical instances of state transition structures that can easily be recasted as coalgebras of set functors. Actually, general nondeterministic weighted automata may be viewed as coalgebras as well, but it is difficult to put in use the corresponding final coalgebra [1], because the corresponding set functor involves powerset (even though sometimes only finite powerset is considered).
Deterministic (sequential) K-weighted automata with input alphabet A and weights in a semiring K are essentially partial Mealy automata [7], where the out- put alphabet is just replaced by a semiring K of weigths. The initial and output functions of Weighted automata (WA) are neglected or viewed as functions having values 0, 1 ∈ K defining initial and final states.
Mealy automata have been studied from a coalgebraic perspective in [18]. It has
been shown that Mealy automata have final coalgebras, namely causal functions between streams (infinite sequences) over the input alphabet and streams over the output alphabet. This can be extended to the case of partial Mealy automata, which are Mealy automata with transition function that is only partially defined. Such a case is motivated by applications in control theory, where state-transition functions are partial functions corresponding e.g. to automata models of manufacturing sys- tems. These are often represented by (timed) Petri nets [19] and can be translated into deterministic (weighted) automata using reachability graphs of (labelled) Petri nets, which are naturally partial automata.
It will be shown that the final coagebra of partial Mealy automata is formed by causal partially defined and length preserving functions between finite or infi- nite sequences over input alphabet and finite or infinite sequences over output set (semiring K).
WA model state transition systems with a quantitative information encoded by output values of transitions that can be e.g. cost of a transition, a timing information (like duration of executing a transition) or probability of a transition between given states. The underlying semiring is then typically the (R ∪ {∞}, min, +), (R ∪
{−∞}, max, +) or the probability semiring (R+, +, ×), respectively.
As for timed transition systems, there are two basic ways of representing com- plex timed systems with concurrency (i.e. simultaneous occurrence of events) by WA: use of nondeterminism and synchronous product constructs. The first one relies on nondeterminism. Indeed, it is well known that unlike logical automata, nondeterministic WA have significantly higher expressive power compared to deter- ministic ones. More specifically, it is known from [9] that nondeterministic (max,+)- automata have a strong expressive power in terms of timed Petri nets: every 1-safe timed Petri net can be represented by a special (max,+) automaton, called heap model. The advantage of nondeterministic WA is that these are typically much smaller than their deterministic counterparts with the same behavior (if these hap- pen to exist at all as finite WA). However, this approach is not easy to apply, because of problems with determinization and decidability issues [14].
The second way of modeling complex timed transition systems is using explicit product constructs. Partial Mealy automata with a suitable (number or interval

based) semiring as an output set naturally model a simple class of timed transi- tion systems: deterministic one clock timed automata or equivalently timed state graphs (machines). Timed state graphs are timed Petri nets, where no synchro- nization is allowed: every transition has exactly one upstream and one downstream place. The corresponding Mealy automata are simply formed using reachability graphs, where duration of a transition in the timed Petri net is exactly the output value of the associated transition in the Mealy automaton. In fact, such a Mealy automaton may be viewed as a one clock timed automaton [2], where the single clock is implicite and is replaced by the corresponding (exact) duration or interval duration from the underlying semiring (typically the so called (max,+) semiring
Rmax = (R ∪ {−∞}, max, +) or the associated interval semiring). Such systems are intrinsically sequential, because the duration of consecutive events are simply added (the classical addition is the multiplication of (R∪{−∞}, max, +) to compute the execution times of event sequences (words). Therefore, explicit synchronous product is needed to model more complex timed behaviors (corresponding to multi- clock timed automata). Another reason why synchronous product of deterministic weighted automata is needed comes from applications, e.g. in manufacturing sys-
tems, where the underlying timed Petri nets models are formed by elementary timed state graphs that are composed using shared synchronization transitions. The over- all system can then be modeled by the synchronous product of elementary timed state graphs (components) as in [19].
We have proposed a (truly) synchronous composition of deterministic
(max,+)-automata based on tensor linear algebra and extended (multi-event set) alphabet in [12]. It turned out that there is no algebraic formula in terms of lo- cal (algebraic) behaviors (formal power series), but only using linear (automata) representations. In this paper a coalgebraic definition is given using coinductive definitions on stream functionals.
The paper is organized as follows. In Section 2 Mealy automata as coalgebras are recalled and partial Mealy automata are proposed. Final coalgebras of partial Mealy automata are studied and two theorems of functional stream calculus are stated. Section 3 is an introduction to deterministic (max,+) automata and their algebraic and coalgebraic behaviors. The notion of a timed language is recalled and compared to formal power series and causal stream functions. In section 4 coinduc- tive definition of synchronous product of causal stream functions is proposed. An example is presented that illustrates the coalgebraic approach to concurrent timed systems. Finally, section 5 proposes a discussion and hints for future investigations.

Partial Mealy automata and deterministic weighted automata
In this section we recall from [18] Mealy automata as coalgebras and extend them to the case of partially defined transition function. A fundamental theorem of func- tional stream calculus is proposed that is the counterpart of fundamental theorem of (ordinary) stream calculus presented in [17]. Other properties of stream functions

called stream functionals by analogy with mathematical analysis are stated.
Let A, K be arbitrary sets (typically finite and referred to as the set of inputs or events). The empty string will be denoted by λ. Further notation is 1 = {∅} to denote a special one element set that will encode partiality of the transition function (when no transition is defined).

Definition 2.1 A partial Mealy automaton with inputs in A and outputs in K is the structure (S, t), where S is the set of states and the transition function is t : S → (1 + (K × S))A. This function maps any state s ∈ S a function t(s): A → (1 + (K × S)) that associates to any input event A either a pair ⟨k, s'⟩ consisting of the new state and the output k ∈ K or the symbol ∅ ∈ 1. The latter case means that there is no transition from s to s' labeled by a and this is donoted by s →/ a .

Thus, Mealy automata with partially defined transition functions are coalgebras on the category Set of the functor F : Set → Set given by F (S)= (1 + (K × S))A. The following notation, borrowed from [18], will be used: s a|k s' iff t(s)(a) = 
⟨k, s'⟩. The fact that there is no transition labeled by a from s to any state is denoted by s →/  a . Since we work with deterministic Mealy machines this notation is justified and is equivalent to the absence transition labeled by a from s to any s' ∈ S.

Remark 2.2 If K is a semiring, i.e. K is endowed with addition and multipli- cation satisfying the semiring axioms, one may view partial Mealy automata as deterministic weighted automata. Typically, weighted automata are nondetermin- istic and have also quantitative initial and final functions that may represent cost, probability or duration (time) and associate to any state the initial or final value in the corresponding semiring (i.e. (R ∪ {∞}, min, +)-semiring, probability semiring
or (R ∪ {−∞}, max, +)-semiring), respectively. In other cases only logical initial
and final functions are considered that determine simply initial or final states. The
initial state and final states play no role in this study. It is implicitly assumed that any state is final and that there is exactly one initial state. Note that unlike weighted automata, where the fact that there is no transition from s to s' labeled by a is expressed by the zero value of the corresponding output from the semiring K, in our case the absence of transitions is encoded using special symbol ∅. Only
later we will get rid of this symbol and represent partiality of transition functions
by (only) partially defined stream functionals.

The basic cornerstones of coalgebras of partial Mealy automata are stated: ho- momorphisms and bisimulation relations. A homomorphism between two partial Mealy automata S = (S, t) and S' = (S', t') is a function f : S → S' such that for all s ∈ S and a ∈ A: if s a|b s' then f (s) a|b f (s'), which can be captured by the

equality F (f ) ◦ t = t' ◦ f corresponding to the commutative diagram below:
(1 + (K × S))A	t	S

f )	f
v	t'	v
(1 + (K × S'))A (	 S'

Definition 2.3 A bisimulation between two partial Mealy automata S = (S, t) and S' = (S', t') isa relation R ⊆ S × S' such that for all s ∈ S and s' ∈ S': if ⟨s, s'⟩ ∈ R then

a|b
a|b'

∀a ∈ A : s → q ⇒ s' → q' such that ⟨q, q'⟩ ∈ R, and b = b', and

' a|b' '
a|b	'	'

∀a ∈ A : s → q  ⇒ s → q such that ⟨q, q ⟩ ∈ R, and b = b .
∀a ∈ A: s /→a iff s' /→a
As usual, we write s ∼ s' whenever there exists a bisimulation R with ⟨s, s'⟩ ∈ R. This relation is the union of all bisimulations, i.e. the greatest bisimulation also called bisimilarity.
Final partial Mealy machine
First we consider causal functions between infinite sequences over A and infinite sequences over 1 + K. Only later these will be formulated in a different way, where partiality of the transition function on stream functions will be expressed without
using special symbol ∅ ∈ 1. Partial functions between finite or infinite sequences over A and finite or infinite sequences over K will be considered instead.
The set of all infinite sequences (streams) over a set A is denoted by Aω. Simi- larly, the set of finite or infinite sequences (streams) over a set A is denoted by A∞,
i.e. A∞ = Aω ∪ A+, where A+ stands for A∗ \ {λ}. The empty string λ is excluded from A∞, because Mealy automata have no output on empty input (unlike Moore automata).
The elements of stream calculus as coinductive study of infinite sequences over a semiring K are first recalled from [17]. It relies on the fact that streams from Kω together with the initial value (the initial output from K, also called head of the stream) and the stream derivative (also known as tail of the stream) form
the final coalgebra (Kω, ⟨head, tail⟩) of the set functor F (S) = K × S. Formally, for s = (s(0), s(1), s(2), s(3),.. .) ∈ Kω : head(s) = s(0) and tail(s) = s' = (s(1), s(2), s(3),.. .).
The notion of stream derivative applies to both infinite and finite sequences. For a sequence s = (s(0), s(1), s(2), s(3),... , s(k)) ∈ A+ its stream derivative, de-
noted s' ∈ A∗, is defined by s' = (s(1), s(2), s(3),... , s(k)). Otherwise stated, for
k = 0, 1, 2,... s'(k)= s(k + 1). Obviously, s' does not preserve the length of finite
sequences.

For a ∈ A and σ = (σ(0), σ(1),... , σ(k),.. .) ∈ A∞ the following notation is adopted: a : σ = (a, σ(0), σ(1),.. .).
The notion of causality [18] applies to functions between both finite and infinite sequences. f is causal means that for any σ ∈ A∞ the n-th element of the stream f (σ) ∈ K∞ depends only on the first n elements of σ ∈ A∞. Formally, f : A∞ → K∞ is causal if ∀n ∈ N, σ, τ ∈ A∞: ∀i : i ≤ n: σ(i)= τ (i) then f (σ)(n)= f (τ )(n). Unlike [18], where Mealy machines with complete transition functions are studied another property (that we call consistency of f ) is required. Finally, f : A∞ → (1 + K)∞ is called consistent if for any stream σ ∈ Aω the sequence f (σ) ∈ (1 + K)ω has the property that the symbols ∅ must only be placed on the rightmost part of the stream. Formally, f is consistent if σ ∈ Aω: f (σ)(k)= ∅ then f (σ)(n)= ∅ for
any n > k. The concept of consistency is close to prefix closedness of languages.
The initial output and functional stream derivative of f are defined in the same way as in [18]. Hence, f [a]= f (a : σ)(0), which is well defined (independent of σ) due to causality. The functional stream derivative fa : A∞ → (1 + K)∞ is defined by fa(σ)= f (a : σ)'. There seems to be a problem with defining stream derivative
of a sequence of length 1. Fortunately, we only need the stream derivatives of finite sequences in the context of functional stream derivatives of [18], i.e. f (a : σ)'. Since σ ∈ A∞ is of length at least one, a : σ is of length at least two, hence f (a : σ)' ∈ (1 + K)∞ is either of length at least one or is undefined.
It has been shown in [18] that causal functions from streams over A to streams
over K, where functional stream derivative plays the role of the transition function form final coalgebra of Mealy machines with complete transition functions.
Now we are ready to propose the following (universal) partial Mealy automaton.

Definition 2.4 Let us define the partial Mealy automaton F = (F, tF ) with the carrier set F = {f : Aω → (1 + K)ω |f is causal and consistent}.
The first output and functional stream derivative endow F with partial Mealy automaton structure (F, tF ), where tF : F → (1 + (K × F))A is defined by
t  (f )(a)= ⎧⎨ ⟨f [a], fa⟩  if f [a] /= ∅ ∈ 1,
⎩ ∅	otherwise,
The definition of derivative can be extended to strings using the classical chain rule: for w ∈ A∗ and a ∈ A: (fw)a = fwa.
Below we point out that to any state of any partial Mealy automaton we can
associate its behavior from F such that the mapping f : S → F be a homomorphism of partial Mealy automata.
Proposition 2.5 The partial Mealy automaton (F, tF ) is a ﬁnal partial Mealy au- tomaton: for every partial Mealy automaton (S, t) (with inputs in A and outputs in K), there exists a unique homomorphism l : (S, t) → (F, tF ).
Proof. For any Mealy automaton (S, t) we define a function l : S → F. It associates

to a s0 ∈ S the function l(s0) : Aω → (1 + K)ω in the following way: for σ ∈ Aω
and n ∈ {0, 1, 2,.. .}, the sequence of transitions corresponding to σ is considered

(if it exists), i.e. s0
σ(0)|k0
→	s1
σ(1)|k1
→	s2 ... 
σ(n)|kn
→	sn+1.  We define in this case

l(s0)(σ)(n)= kn. If there is no such a transition along the path labeled σ(0) ... σ(n),
then we put l(s0)(σ)(n)= ∅. Otherwise stated, l maps any input sequence σ ∈ Aω to the stream (k0, k1, k2,.. .) ∈ (1+K)ω of outputs observed along this input starting in s0. Then no transition possible starting from σm is expressed by putting special symbols encoding ”empty” obervation: kl = ∅ for l ≥ m.
It is immediately seen that l(s0) is consistent, because clearly l(s0)(σ)(n) = ∅ for any n > m whenever l(s0)(σ)(m) = ∅. It is not difficult to verify that l(s0) is causal and that l is a homomorphism, which is moreover a unique one (up to isomorphism).	 
The stream function l(s0) above is called the (input-output) behavior of s0. Final coalgebra F has the property that bisimulation on F implies (and henceforth is equivalent to) equality. This opens the possibility of proving equality of two causal and consistent stream functions f, g ∈ F by coinduction, which amounts to showing that f ∼ g: there exists a bisimulation relation R ⊆ F × F such that
⟨f, g⟩ ∈ R. Since the transition function of F is defined using the tuple of the first output and functional stream derivative, the proof of R being a bisimulation (used
further) consists of two steps. Firstly, it is shown that first outputs for any input coincide on all related pairs of stream functions, and secondly it is to be shown that the functional stream derivatives with respect to all input events are again related by R.
Now the final coalgebra F is formulated in an equivalent way, where ∅ is not needed, but both infinite and finite sequences of inputs and outputs are considered and the function between them must preserve their length. We will consider causal partial (partially defined) functions from finite or infinite sequences over A to finite
or infinite sequences over K that are length preserving, i.e. finite sequences over A are mapped to finite sequences over K of the same length and infinite sequences over A are mapped to infinite sequences over K. It is easily seen that F is isomorphic to the following structure:

F∞ = {f : A∞ → K∞,f length preserving,causal with dom(f ) prefix-closed}.
Note that the output set 1 + K is replaced by K and f is a partial function between finite or infinite sequences over input and output set. The consistency of f : Aω → (1 + K)ω enables to recast f as an element of F∞.
It follows from the construction below. First, it is shown how to obtain from
f ∈ F an element of F∞. Since f is consistent, there are two possibilities: either for σ ∈ Aω and any n ∈ N we have f (σ)(n) ∈ K, i.e. f (σ)(k) /= ∅, or there is a k ∈ N such that f (σ)(k)= ∅. In the former case f is automatically an element of F∞. In the latter case the consistency of f means that f (σ)(n) = ∅ for n > k. Then it is useless to evaluate f in the whole infinite sequence σ. It is then sufficient to consider

only finite words like σ(0)σ(1) ... σ(k) ∈ A∗ and the corresponding finite words in the outputs f (σ)(0).f (σ)(1) ... f (σ)(k) ∈ K∗. It is clear that such a mapping f is only partial (as we forget the value of f on suffixes of σ(0)σ(1) ... σ(k)), and that f is length preserving. Let us not here that intuitively, σ(0)σ(1) ... σ(k) ∈ A∗ is in the (prefix-closed) language of the underlying partial Boolean automaton that forgets the outputs, while σ(0)σ(1) ... σ(k + 1) is already out of this prefix-closed language. It is immediately seen that dom(f ) is prefix-closed.
Conversely, to any length preserving and causal f : A∞ → K∞ with prefix- closed domain we can construct a causal and consistent mapping f : Aω → (1+K)ω . Indeed, it is simply sufficient to extend the maximal (wrt prefix-order) finite words for which f is defined to infinite words and complete the image sequences by symbols
∅ that are placed on the rightmost part of the streams f (σ). Naturally, f is again causal and consistent.
An important observation is that for f ∈ F∞ we have in fact f [a] = f (a)(0) whenever f is defined for a ∈ A. Otherwise, f [a] is undefined and there is no a-transition in F∞ from f .
For each length preserving and causal function f ∈ F we define the initial (first) value (of output) corresponding to a ∈ A simply by f [a] = f (a)(0). Also, the functional stream derivative of f (with respect to input a) is defined as the function fa : A∞ → (1 + K)∞ given by fa(s) = f (a : s)' if it is defined. Clearly, fa is again causal and preserves the length of s, because prefixig a finite sequence by a increases the length by 1 and f keeps the length, but the derivatives reduces it back to the original length. The transition function tF : F → (1 + (K × F))A is defined using the first output function and the functional stream derivative, similarly tF∞ : F∞ → (1 + (K × F∞))A is defined by




tF∞
(f )(a)= ⎧⎨ ⟨f [a], fa⟩	if f [a] is defined

⎩ undefined	otherwise,

Fundamental properties of stream functions
It is natural to call functions between streams by stream functionals to stress the analogy with functional analysis. First we recall other elementary concepts from stream calculus for streams over a semiring K = (K, ⊕, ⊗, 0, 1). The constant stream corresponding to r ∈ K is given by [r] = (r, 0,.. .). The notation X = (0, 1, 0,.. .) is important to describe any stream using constant streams, addition and multiplication. The addition (sum) of streams is defined using addition of K: For σ, τ ∈ Kω:
(σ ⊕ τ )(n)= σ(n) ⊕ τ (n)
and Cauchy (convolution) multiplication of streams given by

(σ ⊗ τ )(n)=   σ(k) ⊗ τ (n − k).
k=0

The symbol ⊗ for multiplication of streams is often left out as in the classical calculus, cf. Xfσ(0)(σ')(0) below meaning X ⊗ fσ(0)(σ')(0) etc. The n-th Cauchy power of X, i.e. Xn = (0,... , 0, 1, 0,.. .) with 1 being placed on the n + 1-st place. Finally the notation σ(k) is used to denote the k-th stream derivative of σ.
The following theorem is provided that is the counterpart of fundamental the- orem of stream calculus in functional stream calculus. Fundamental theorem of stream functionals is stated in Theorem 2.6. Let us note that similarly as in the
stream calculus the sum ⊕ is formal, although it is well defined, because there is only one element per component in ⊕ below.
Theorem 2.6 For any f ∈ F and σ = (σ(0), σ(1),... , σ(k),.. .) ∈ Aω we have:
f (σ)= f (σ)(0) ⊕ Xfσ(0)(σ')(0) ⊕ ... Xkfσ(0)...,σ(k−1)(ω(k))(0) ⊕ ... 
or equivalently,
f (σ)= f [σ(0)] ⊕ Xfσ(0)[σ(1)] ⊕ ... Xkfσ(0)...,σ(k−1)[σ(k)] ⊕ ... 

Proof. It follows from the fundamental theorem of stream calculus, which states that for any σ ∈ Aω it holds that σ = σ(0) ⊕ X.σ', which can be extended to σ = σ(0) ⊕ Xσ'(0) ⊕ X2σ'(0) ⊕ ... Similarly, it sufficies to show that f (σ) = f (σ)(0) ⊕ Xfσ(0)(σ'), which is a direct consequence of the fundamental identity on Kω for f (σ): f (σ)= f (σ)(0) ⊕ Xf (σ)'. Indeed, σ = σ(0) : σ', hence by definition of functional stream derivative we get: fσ(0)(σ') = f (σ(0) : σ')' = f (σ)'. Hence, f (σ)= f (σ)(0) ⊕ Xfσ(0)(σ').

In the proof of Theorem 2.6 we did not make use of coinduction, but implic- itly : it relies on fundamental theorem of stream calculus, which can be proven by coinduction. Let us also mention that similar fundamental theorem holds for
functionals from F∞. Now the set F∞ is considered. In the next results partiality of the functionals from F∞ is important. Functionals from F∞ have interesting properties and some of them are proven below by coinduction on stream functions. Some of them are listed below. The fact that we can evaluate these functionals on finite words that are prefixes of (potentially) infinite words (streams) has interesting consequences. For instance, the lemma below.
Lemma 2.7 For any f ∈ F∞, ω ∈ A∞, and a ∈ A: f (a) : fa(ω) = f (aω). More generally, for any u ∈ A+ and ω ∈ A∞: f (u): fu(ω)= f (uω).
Proof. First we stress that the f (a) : fa(ω) is an element of K∞. Hence, the equality can be shown by coinduction on streams [17] extended to finite and infinite sequences, which is the final coalgebra of partial stream automata given by the Set functor F : S → 1+ (K × S). Put
R = {⟨f (a): fa(ω),f (aω)⟩∪ ⟨σ, σ⟩ | f ∈ F∞, σ ∈ K∞, and a ∈ A.}

This amounts to show that the heads (initial values) are the same and that the stream derivatives are also related by R. Firstly, [f (a) : fa(ω)](0) = f (a) and f (aω)(0) = f (a)(0) = f (a), because f is causal. Secondly, {f (a): fa(ω)}' = fa(ω) and f (aω)' = fa(ω) from the very definition of functional stream derivative. It is
also easy to see that f (a): fa(ω) can not make further transition iff f (aω) can not (namely iff f (a) is undefined), which shows the partial stream counterpart of (iii) of Definition 2.3.	 
An interesting and useful observation is that the first output function at first input f [a]= f (a)(0) can be seen as a simple stream functional. Indeed, the initial output function can be seen as a particular partial stream functional defined by
f ∞[a](σ)= ⎧⎨ f [a]	if σ = a,
⎩ undefined	otherwise: σ /= a,
The following concatenation like multiplication (denoted by ⊙) of a stream func- tional g with this special stream functional f ∞[a] on the left, helps formulating another fundamental identity of functional stream calculus.
Definition 2.8 For any f, g ∈ J∞, σ = (σ(0) : σ') ∈ A∞, and a ∈ A we define
f (σ(0)) : g(σ') if a = σ(0) ∈ dom(f ),
(f ∞[a] ⊙ g)(σ(0) : σ')= 
⎩ undefined	otherwise,

Note that the multiplication on the right is just stream concatenation on K∞ following the notation of [17]. We make the convention that f (a): g(σ')= f (a) if g(σ') is undefined. Addition on streams from K∞ induces addition on J∞. Simply, one defines for fi ∈ J∞, i ∈ I: (  i∈I fi)(σ)=  i∈I (fi(σ)). Then we can write:
Theorem 2.9 For any f ∈ J∞ we have: f =  a∈A f ∞[a] ⊙ fa.
Proof. It can be shown by coinduction on J∞. We put
R = {⟨  f ∞[a] ⊙ fa,f ⟩∪ ⟨f, f ⟩ | f ∈ J∞ and a ∈ A}.
a∈A

Then R is a bisimulation on J∞. Indeed, for any b ∈ A we get (f ∞[a] ⊙ fa)[b] = (f ∞[a] ⊙ fa)(b)(0) = (f ∞[a](b). Let us observe that according to definition of f ∞[a] we have either f ∞[a](b)= f [b] or it is undefined, depending on b = a or not. Hence, a∈A(f ∞[a] ⊙ fa)[b] = f [b] and the first outputs are equal for	a∈A(f ∞[a] ⊙ fa)
and f .

Now, let ( 

a∈A
f ∞[a] ⊙ fa
b|k
→
f '. Then f '(σ) = ( 

a∈A
f ∞[a] ⊙ fa)b(σ) =

  a∈A{(f ∞[a] ⊙ fa)(bσ)}' = {f [b]: fb(σ)}' = fb(σ). Again, (f ∞[a](b)= f [b] in case

b = a has been used. Finally, it is obvious that 

a∈A
f ∞[a] ⊙ fa /→a
iff f →/ a
(namely

iff f [a] is undefined), which shows (iii) of Definition 2.3.
Hence, ⟨(  a∈A f ∞[a]: fa)b, fb⟩ ∈ R, which was to be shown.	 

This equality may be viewed as a functional stream counterpart of the fundamen- tal theorem of (multivariable) formal power series (behaviors of Moore automata): s = s(λ)+  a∈A a.sa for s : A∗ → K. Therefore, multiplying a stream functional f by the elementary functional given by f [a], i.e. f ∞[a], in the sense of definition 2.8
can be seen as a functional counterpart of formal power series integration, which is given by aσ, i.e. Xσ for monovariable streams over X = (0, 1, 0,.. .). This is expressed in the Proposition below.
Proposition 2.10 For any f ∈ J∞ and a ∈ A: (f ∞[a] ⊙ f )a = f
Proof. The equality is shown by coinduction on J∞. Let
R = {⟨(f ∞[a] ⊙ f )a,f ⟩∪ ⟨f, f ⟩| f ∈ J and a ∈ A}.
Then R is a bisimulation on J∞. Indeed, for any b ∈ A we get (f ∞[a] ⊙ f )a[b] = 
{(f ∞[a] ⊙ f )(ab)}'(0) = (f ∞[a] ⊙ f )(ab)(1)={f (a): f (b)}(1) = f (b).

Now, let (f ∞[a] ⊙ f )a
b|k
→
f '. Then f '(σ) = (f ∞[a] ⊙ f )ab
(σ) = {(f ∞[a] ⊙

f )(abσ)}'' = {f (a) : f (bσ)}'' = f (bσ)' = fb(σ). Hence, (f ∞[a] ⊙ f )ab = fb and
a	a
therefore ⟨(f ∞[a] ⊙ f )ab,f ⟩ ∈ R. Also, it is easy to see that (f ∞[a] ⊙ f )a /→ iff f →/
(namely iff f [a] is undefined), which shows (iii) of Definition 2.3.

Remark 2.11 In section 4 we need a semiring structure on K in order to introduce the synchronous product operation on causal and length preserving functions that are behaviours of deterministic time-weighted automata.
Finally, let us mention that the behavior of Mealy automata are typically de- scribed in the literature as formal power series f : A+ → K. Still we prefer to work with J, because as is shown in the next section, in the case of deterministic time-weighted automata coalgebraic behaviors are similar to timed languages from timed automata theory.

Deterministic weighted automata and timed languages
In this section deterministic (max,+) and interval automata without initial and final delays are considered and three representations of their behaviors are discussed: for- mal power series, timed languages and functions between finite or infinite sequences of inputs and outputs.
Let us start with the definition of deterministic K-weighted automata.  Let
K = (K, ⊕, ⊗) be a semiring.
Definition 3.1 A deterministic K-weighted automaton over the input alphabet A and with weights in K is the Mealy automaton (S, t), where S is the set of states and the transition function is t : S → (1 + (K × S))A.
Two important cases of semiring K are considered in this paper. A deterministic
(max,+)-automaton is a deterministic K-weighted automaton with K = Rmax =

(R ∪ {−∞}, max, +). The zero element, i.e. −∞ of Rmax is denoted by ε in accordance with idempotent semiring notation [8] and the unit element is denoted by e = 0. A deterministic interval automaton is a deterministic K-weighted automaton
with K = Imax = (R × R  ∪ (−∞, −∞), ⊕, ⊗), where ⊕ is the componentwise
maximum and ⊗ is the componentwise (conventional) addition.
At the first sight our deterministic K-weighted automata might seem very dif- ferent from (non)deterministic K-weighted automata in algebra, which are defined by G = (Q, A, α, μ, β), where Q is a finite set of states, A is the set of events, and the linear triple consists of α : Q → K, t : Q × A × Q → K, and β : Q → K,
called input, transition, and output delays, respectively. Let us recall that t can be
algebraically viewed as a collection of matrices
μ : A → KQ×Q, μ(a)q q'  t(q, a, q').
Since the definition μ can be extended from a ∈ A to w ∈ A∗ using the morphism property, i.e.
μ(a1 ... an)= μ(a1) ⊗ ... ⊗ μ(an),
μ is often called a morphism matrix. Such a triple (α, μ, β) is called a linear rep- resentation of G. In this algebraic representation there is no need of using special symbols to express partiality of the transition function, because t(q, a, q')= 0 ∈ K means there is no transition from q to q' labeled by a. The transition function
associates to a state q ∈ Q, a discrete input a ∈ A and a new state q' ∈ Q, an output value t(q, a, q') ∈ K corresponding to the a−transition from q to q'.
As our K-weighted automata (viewed as coalgebras) are assumed to be deter-
ministic, there is exactly one initial state and t is deterministic, i.e. t : Q × A → (1 + K × Q). Note that in this deterministic transition function t the set ∅ ∈ 1 is needed to encode the partiality of the transition function, unlike the nondeter- ministic transition function, where the zero element of K, i.e. 0 ∈ K encodes the fact that there is no transition between two given states with a given label. It is immediately seen that this deterministic transition function can be recasted in the coalgebraic form in terms of the set functor F (S)= (1 + (K × S))A, cf. Definition 3.1.
Essentially, our attention is restricted to transition function, while initial and final weights (called delays in timed systems) are discarded, or at least α and β take their values in the Boolean subsemiring of K: e.g. ∀q ∈ A : α(q) ∈ {0, 1} meaning α(q) = 1 iff q is the initial state. Initial and final state play no role in our study,
because from a coalgebraic perspective any state can play a role of an initial state in the sense that the behavior homomorphism l : S → J evaluated in s ∈ S gives the behavior of S, where s is the initial state.
Below it is assumed that K = Rmax. From an algebraic viewpoint, behaviors of timed systems are timed languages or formal power series. Below the notion of a timed language is recalled from the theory of timed automata [2].
Definition 3.2 A timed word st is a (finite or infinite) sequence over the alphabet
A × R, i.e. st ∈ (A × R)∞, where (σ1, t1) ... (σn, σn) ... means that the execution

time of an event ai is achieved at time ti, i = 1, 2,.	A timed language is a subset
of timed words, i.e. Lt ⊆ (A × R)∗.
It is easy to see the relationship between elements of the final coalgebra J or its equivalent presentation J∞ from the previous section and timed languages. In fact, timed languages give the cumulated execution time of a sequence, which is the sum of durations of individual events in the sequence. This subsumes that the multiplication of the underlying output alphabet, which is the semiring Rmax is the conventional addition. In particular, it means that the sequence of execution times t1 ... tn  from Definition 3.2 is nondecreasing.
On the contrary, for any partial, length preserving, and causal function f : J∞ and σ ∈ A∞ the value f (σ) gives the sequence of duration times of individual events from σ, which is naturally not nondecreasing in general. For a given f ∈ J∞ it is easy to obtain the corresponding timed language by simply making the sum of the duration of consecutive events from the initial event up to a given one. For

instance, the function f : A+ → R+
that maps the sequence a, b, c, b to the

sequence 1, 2, 4, 3 and is only defined on nonempty prefixes of a, b, c, d (e.g. a, b is
mapped to the time sequence 1, 2) corresponds to the finite timed language given by a single timed word (a, 1)(b, 3)(c, 7)(b, 10). The timed words and such simple stream functionals are easy to obtain from one another. However, timed languages (subsets of timed words) are strictly more expressive than our stream functionals. This is natural, because timed words can express concurrent timed behaviors of general timed automata, while stream functionals are tailored to sequential (single clock) timed systems. Still it will be shown in section 4 that there is a class of concurrent timed behaviors that can be expressed by stream functionals using synchronous product based on extended alphabets.
Let us note that timed words are even closer to formal power series than stream functionals, but in general formal power series may hide some timing information. In the example above, the corresponding formal power series is 1a⊕3ab⊕7abc⊕10abcb. However, for another formal power series 1a ⊕ 7abc ⊕ 10abcb there is no information about the execution time of ab, but only the one about abc is specified and we only know that ab is executed in time interval (1, 7).
But timed languages have no such a nice and rich structure as partial, length pre- serving, and causal functions from J∞. This feature is important for our main goal: coinductive definition of synchronous product of deterministic weighted automata. Therefore, we only work with behaviors from J∞ in the rest of this paper.

Behaviors of concurrent deterministic (max,+) au- tomata
In this section the main result of this paper is presented: coinductive definition of synchronous product of behaviors of deterministic time-weighted automata, i.e. functions from J∞, is proposed and discussed in detail.
Let us first recall the automaton based definition of synchronous product pro-

posed in [12]. It is assumed that a distributed timed system is given by two deter- ministic (max,+)-automata. Let G1 = (S1, t1) and G2 = (S2, t2) be two (max,+)- automata defined over local alphabets A1 and A2. Then associated natural projec-
tions are P1 : (A1 ∪ A2)∗ → A∗ et P2 : (A1 ∪ A2)∗ → A∗. We also need the Boolean
1	2
matrices associated to morphism matrices :


[Bμ(a)]ij
= ⎧⎨ e = 0,	if [μ(a)]ij /= ε
⎩ ε = −∞,  else

In order to avoid heavy notation, Bμ(a) is in the sequel denoted by B(a). This notation can be extended to a (Boolean) morphism on words from B : A∗ →
{0, −∞}n×n using morphism property B(a1 ... an)= B(a1) ... B(an).
The synchronous composition of two (max,+)- automata is based on an extended alphabet composed of two types of events. Firstly, it includes all shared events. Secondly, it includes pairs of local sequences in between the synchronization event.
Formally, A = (A1 ∩ A2) ∪(A1 \ A2)∗ ×(A2 \ A1)∗. The problem is that the alphabet actually depends on the particular distributed timed system under consideration in the sense that not all pairs of local sequences (which would make the extended alphabet infinite) need to be included in A. It suffices to include those pairs from (A1 \ A2)∗ ×(A2 \ A1)∗ that are actually executed by the automata. In fact, we need to include in A exactly the pairs of maximal local strings (maximality is with respect to the prefix order) in between two consecutive synchronization events. A can in general be infinite, but only in the case, where at least one local automaton G1 or G2 has loops consisting of private events only from A1 \ A2 or A2 \ A1, respectively, and local systems are unable to get synchronized. Otherwise stated, if any loop in local subsystems contains at least one shared (synchronization) event then the extended alphabet A for a given distributed timed system is finite.
In order to define the synchronous product on behaviors from J∞ it is necessary to use extended alphabet A.
The Kronecker (tensor) product of matrices denoted by ⊗t is involved. If A = (aij) is a m ×n matrix and B is a p ×q matrix over K, then their Kronecker (tensor) product A ⊗t B is the mp × nq block matrix
(A ⊗t B)ik,jl = aij ⊗ bkl.
The parallel products of weighted automata a` la A. Arnold [3] or P. Bucholtz [4] is not suitable for timed systems, because if these are applied to(max,+)-automata, their product as product of weighted automata remains a sequential model.
In the logical setting trace theory has been developed, where events that may occur simultaneously are related by independence relation. However, it is not clear how to extend the trace theory into the timed transition systems setting. Let us recall that classical composition of weighted automata [3] is simply given by tensor product of their linear representations. This corresponds to classical synchronous product of underlying Boolean automata, but the duration of a transition in the synchronous product is the product (i.e. conventional sum in Rmax)of the dura-

tions of participating transitions. This is not suitable for timed systems modeled by (max,+)-automata, unless there is no concurrency between events: e.g. the alpha- bets of subsystems are equal. Indeed, one would need to distinguish simultaneously executed events or strings and in the extreme case the duration of a global string is the sum of durations of corresponding (projected or local) strings. Therefore, definition below has been proposed, which corresponds to the intuition that in be- tween two synchronizing transitions the local strings are executed in parallel, i.e. the duration of a string v of non shared events equals the maximum of durations of its projections P1(v) and P2(v) in local automata. A much simple coalgebraic counterpart of this definition will be given later in this section.
Definition 4.1 Synchronous Composition of (max,+)-automata
G1 = (Q1, A1, α1, μ1, β1) and G2 = (Q2, A2, α2, μ2, β2), is the following interval automaton defined over the alphabet
A = (A1 ∩ A2) ∪ [(A1 \ A2)∗ × (A2 \ A1))∗] G1  G2 = G = (Q1 × Q2, A, α, μ, β)
with Q1 × Q2 set of states, A set of events, α = α1 ⊗t α2 the initial delay, μ : A∗ →

R|Q|×|Q| the morphism matrix and β = β ⊗t β
final delay. The morphism matrix

max	1	2
is defined by :
8>< μ1(v) ⊗t B2(v) ⊕ B1(v) ⊗t μ2(v),	if v = a ∈ A1 ∩ A2

μ(v)= 
>:
μ1(P1(v)) ⊗t B2(P2(v)) ⊕ B1(P1(v)) ⊗t μ2(P2(v)), if v = (P1(v), P2(v)) ∈
(A1 \ A2)∗ × (A2 \ A1)∗


Let us now explain the intuition behind this seemingly complicated definition. The interval automata G1 and G2 are synchronized over the shared events set: A1 ∩ A2, but in between two consecutive synchronizations the automata G1 and G2 are free to execute their respective private events belonging to A \ (A1 ∩ A2). These private events are represented by pairs of corresponding local strings P1(v) ∈ (A1 \ A2)∗ and P2(v) ∈ (A2 \ A1)∗. Not all events of A are needed in concrete synchronous products. In fact, only those pairs of local events are included that actually occur in local subsystems between two synchronizing events. The extended alphabet A is still potentially infinite, which is the main drawback of our approach. Fortunately, this may only happen if there are loops of private events in one of the subsystems and the subsystems are unable to synchronize. If this case is excluded a finite extended alphabet A can be found.
In [12] we could not find any algebraic definition compatible with this automata
definition that would be based on formal power series l1 = l(G1) and l1 = l(G1),
i.e. independent of the linear representation G1 of l1 and G2 of l2. A definition for behaviors is only possible if automata representations are fixed, but there is no algebraic definition independent of automata representation. Yet, the formula for behavior of the synchronous product from [12] is very complex and not practical
to use, because for a given word over A1 ∪ A2 it is the sum of a number of terms that is exponential in the number of synchronization events in this word. Still, even

in the case of infinite alphabet A, we have been able to compute the (algebraic) behavior of G1  G2 on finite words from A = A1 ∪ A2. Indeed, any w ∈ A∗ can be decomposed as w = v0a1v1 ... anvn, where ai ∈ A1 ∩ A2, i = 1,... ,n are shared (synchronization) events and vi ∈ (A \ (A1 ∩ A2))∗, i = 0,... ,n are sequences of private local events. For such a vi the corresponding local strings in G1 and
G2 are given by natural projections P1(vi) ∈ A∗ and P2(vi) ∈ A∗, respectively.
This way, any word over distributed (global) event set A∗ can be seen as the word
w = P1(v0) × P2(v0)a1P1(v1) × P2(v1) ... anP1(vn0) × P2(vn) over the extended alphabet A. The duration of private strings vi ∈ (A \ (A1 ∩ A2))∗ is simply given by the maximum of the durations of local strings P1(v) and P2(v).
In this paper such a definition for behaviors is given using finality of J∞ formed by causal and length preserving functions between A∞ and K∞ with prefix closed domains. They are endowed by partial Mealy automaton structure as in section 2, where A is just replaced by the extended alphabet A. The first output function of (l1  l2) will be defined using first output functions of l1 and l2 extended to strings. The following concept is now needed. For li ∈ J∞ over Ai and vi = a1 ... ak ∈ A+
we define for i = 1, 2:
(li)[vi]= (li)[a1] ⊗ (li)a1 [a2] ⊗ ... ⊗ (li)a1 ...ak−1 [ak].
This is needed, because the whole local vi string playing the role of Pi(v) from definition below is executed in Gi in a sequential way: the duration of its execution is simply the usual sum, i.e. ⊗, of execution times of individual events a1,... ak from vi.
Definition 4.2 Define the following binary operation on J∞ over A: for l1, l2 ∈ J∞
and ∀v ∈ A:
(l1  l2)v = (l1)P1 (v)  (l2)P2 (v) and
(l1  l2)[v]= l1[P1(v)] ⊗ Bl2[P2(v)] ⊕ Bl1[P1(v)] ⊗ l2[P2(v)].
Note that equivalently one can write:


(1)

(l1
l )[v]= ⎧⎨ max(l1[P1(v)], l2[P2(v)]) if li[Pi(v)] /= ε for i = 1, 2

⎩ ε	else, i.e. ∃i = 1, 2: li[Pi(v)] = ε
This definition is similar to the coinductive definition of synchronous product [15] of partial languages (behaviors of partial automata). Indeed, our functional input derivative for a shared event has the same form as the input derivative for lan- guages. As for private events, the extended alphabet contains strings of these events (typically a finite number of them), but clearly our definition of functional input derivative is formally of the same form as the input derivative from the language
definition [15] extended to strings. Namely, for partial languages L1 = (L1, L2),
1	1
L2 = (L1, L2), and w ∈ A∗ we have in fact (L1  L2)w = (L1)P (w)  (L2)P (w). Of
2	2	1	2
course, the first output function is specific to the timed setting, but it is easy to
understand from the equivalent form (1). This formal simplicity of Definition 4.2 is another advantage of the coalgebraic approach compared to the algebraic one, where

it is only possible to give automata definitions. It seems that there is no algebraic formula in terms of local (algebraic) behaviors (formal power series), but only using linear (automata) representations. Coalgebraic framework makes it simpler due to the fact that final coalgebras are endowed with the same automaton structure as another automaton of a given functor. In fact, algebraic behaviors (formal power series) formal power series can also be endowed with a coalgebra structure [17], but only for the Moore automata functor. Maybe for this reason the algebraic defini- tion of synchronous product is not so elegant and it seems to works on automata representations only: we could not find any definition for formal power series.
Let us mention another two points. Firstly, in the definition of functional stream derivatives it is not necessary to distinguish the type of extended event. Secondly, the first output function can equivalently be written as follows, where we recall
ε = −∞ is the zero element of Rmax. The value ε in equation (1) can be viewed as undefined. In the special case with full synchronization, i.e. A1 = A2 there is no need for using extended alphabet, in fact in this case A = A1 = A2. Note that for any v = a ∈ A we have in fact P1(v)= P2(v)= a.
Thus, we obtain for l1, l2 ∈ J∞ and ∀a ∈ A:
(l1  l2)a = (l1)a  (l2)a
and (l1  l2)[a] = l1[a] ⊗ Bl2[a] ⊕ Bl1[a] ⊗ l2[a]. Interestingly, synchronous product differs from sum or Hadamard product of two functionals (with obvious definitions) in the initial condition, which is different from both sum and the Hadamard product.
Example
In this section the coinductive definition of the last section is applied to a con- crete example. We consider a simple distributed timed system consisting of two subsystems: (max,+)-automata G1 and G2 over the alphabets A1 = {a, b, d} and A2 = {a, c}, respectively, drawn in figure 1. Their synchronous product is by Defi- nition 4.1 the following (max,+)-automaton :
G1  G2 = G = (Q1 × Q2, A, α, μ, β),
where Q1 × Q2 is the set of states,
A = {a, (be, c), (d, c)} ⊆ (A1 ∩ A2) ∪ (A \ (A1 ∩ A2))∗, α = α1 ⊗t α2, β = β1 ⊗t β2, and
⎧	t	t
ν(v)= ⎪⎨ μ1(be) ⊗t B2(c) ⊕ B1(be) ⊗t μ2(c), if v = (be, c)
⎪⎪⎩ μ1(d) ⊗t B2(c) ⊕ B1(d) ⊗t μ2(c),	if v = (d, c)
can easily be computed. The synchronous product G1  G2 is drawn in figure 1 on the right.


	
Fig. 1. G1, G2 and G1  G2
The behavior of the composed automaton is the synchronous product of be- haviors of local components over A1 = {a, b, d, e} and A2 = {a, c}, which are l1 : (A1)∞ → (Rmax)∞ and l2 : (A2)∞ → (Rmax)∞.
An important feature is that the extended alphabet is based on the underlying
untimed partial automata and it includes only those sequences of private events that can occur in between two synchronization events (a). In our case these are sequences bec, bce, cbe (not to be distinguished one from another) represented by their projections to the local alphabets, i.e. (be, c). and sequences dc, cd repre- sented by (d, c). Hence, the extended alphabet is A = {a, (be, c), (d, c)}. Note that
P1(be, c) = be ∈ A∗, P2(be, c) = c ∈ A∗, and similarly for (d, c). Hence, the differ-
1	2
ential equation for (l1  l2)v, v ∈ A makes sense. The first output and derivative for
v = a are as follows:
(l1  l2)a = (l1)a  (l2)a and
(l1  l2)[a]= l1[a] ⊗ Bl2[a] ⊕ Bl1[a] ⊗ l2[a].
Let us mention that (l1  l2)(a) = (l1  l2)(a)(0) = 5 = (l1  l2)[a], because (l1  l2) is length preserving and a ∈ A∞ is of length 1. Now, according to the fundamental theorem of functional stream calculus we get
(l1  l2)(a(d, c)) = (l1  l2)(a(d, c))(0) ⊕ (l1  l2)a(d, c)(0).
Direct application of the formulas for derivative and first output function yields (l1  l2)a(dc)= ((l1)a  (l2)a)(dc)= ((l1)a  (l2)a)(dc)(0) = ((l1)a  (l2)a)[dc]
= (l1)a[d] ⊗ B(l2)a[c] ⊕ B(l1)a[d] ⊗ (l2)a[c]= (l1)(ad)(1) ⊗ B(l2)(ac)(1)⊕ B(l1)(ad)(1) ⊗ (l2)(ac)(1) = 8 ⊗ 0 ⊕ 0 × 7= 8.
The second last equality follows from fa[d]= fa(d)(0) = f (a : d)'(0) = f (ad)(1) for any f ∈ J∞.
Similarly, we get (l1  l2)(a(be, c)) = (l1  l2)(a(be, c))(0)⊕(l1  l2)a((be, c))(0), where
(l1  l2)a(be, c)= ... = (l1)(a(be))(1) ⊗ B(l2)(ac)(1) ⊕ B(l1)(a(be))(1) ⊗ (l2)(ac)(1) =

5⊗0⊕0×7 = 7. These lines shows that the synchronous product is easy to compute and moreover if the composed automaton is drawn, its behavior is very intuitive and can directly be written down, cf. Figure 1.
The behavior functional l1  l2 ∈ J∞ is only partially defined: essentially it is not defined for words that are outside the (prefix-closed) language of the underlying partial automaton and all infinite suffixes of such words. For instance, for w = aa or w = aω. On the other hand we have (l1  l2)(a(d, c))ω = (585 8 .. .)= (5 8)ω.
The conclusion for this example is that both algebraic and coalgebraic framework can be used to compute the behaviors of synchronous product of (max,+)-automata. However, the coalgebraic approach does not use large matrices (but scalar behav- iors), while the algebraic framework needs automata representations.
Remark 4.3 Two points are stressed. Firstly, our approach can be extended to more than two local components as described in [12], but it becomes quite complex. Secondly, synchronous product of interval automata, i.e. deterministic weighted
automata with weights in Imax, can be introduced in a similar way as the syn- chronous product of (max,+)-automata. Interval automata has been studied as Bu¨chi automata over interval based alphabets in [6] and their synchronous prod- uct are known as Product Interval Automata (PIA). The same construction based
on extended event alphabet can be applied to interval automata and synchronous product of their behaviors can be defined by coinduction.
PIA correspond to an important class of timed automata, where the clocks are read (i.e. compared to constants in transition guards) and reset in a particular fashion: there are n clocks (one per component) and during a transition in a PIA only clocks that correspond to the components that are active in a transition are read and reset. This way the reading and reseting of clocks is compatible with the distributed event set structure. Thus, the usage of clocks can be completely avoided and PIA can be described by symbolic purely algebraic methods.
PIA are capable of modeling many interesting applications like asynchronous circuits. Hence, they represent a nice trade off between tractability (all fundamental problems are known to be decidable for this class of timed automata) and modeling power.

Concluding discussion
In this paper deterministic (sequential) weighted automata has been studied coal- gebraically as partial Mealy automata. We have recasted their behaviors (causal and consistent stream functions) as partial, length preserving functions (also called stream functionals) and extended basic results of stream calculus into functional stream calculus.
The main advantage of the coalgebraic approach is the possibility to use coin- ductive definitions and proofs that are known to be pertinent in many applications. Moreover, final coalgebra itself is endowed with the same structure as another coal- gebra of a given functor. This helps defining operations on behaviors of state transi- tion systems, e.g. streams, (partial) languages or (partial) stream functions, because

these behaviors are seen as corresponding types of automata, e.g. stream automata, (partial) automata or Mealy automata. The corresponding definitions on automata are then simplified into coinductive definitions on behaviors.
In this work another application demonstrating power of coinductive definitions compared to definitions by induction is given: synchronous product of behaviors of deterministic weighted automata are defined by coinduction. The main advantage of our approach is that the composed automaton remains deterministic. On the other hand, the composed system has many states and decentralized approaches must be used in order to avoid the state explosion problem. Since our approach is compositional by construction, it is tailored to decentralized (component-wise) techniques.
Recently we have developed supervisory control theory for (max,+) automata that is applicable to nondeterministic (max,+) automata as well [11] (because de- terminism plays no essential role.) However, a major problem is that the resulting controller series computed within a behavioral (i.e. formal power series framework) need not be (max,+)-rational. Recall that a series is (max,+)- rational (respectively (min,+)- rational) if it is in the rational closure of series with finite supports, i.e. if it can be formed from polynomial series (i.e. those with finite support) by rational operation ⊕ (corresponding to max, respectively to min), ⊗, and the Kleene star.
A notion close to that of a deterministic series is a unambiguous series, which is
a series recognized by unambiguous automata, i.e. automata in which there is at most one successful path labeled by w for every word w. It is known from Lom- bardy and Sacharovitch [14] that the class of formal power series that are at the same time (max,+) and (min,+) rational coincides with unambiguous series. More- over, for these families of series, the equality (and inequality) of series is proven to be decidable. Let us recall that sequentialization of weighted automata (i.e. their determinizing) and its decidability status is not known for formal power series over idempotent semirings (unlike the ring case, which is not so interesting for applica- tions in distributed timed systems). The results of [14] show that essentially, beyond the class of deterministic series (i.e. those for which deterministic representations exist) and hence deterministic representations of the timed systems and their (con- trol) specifications there is a little chance of obtaining a rational (i.e. finite state) controller automaton. Also, equality of nondeterministic (max,+)-series is is known to be undecidable [13]. This is a major motivation for our study that consists in cod- ing concurrent (non sequential) timed systems using synchronous product construct instead of using nondeterministic representations `a la heap automata.
Among plans for further research, we plan to apply the coinductive definitions presented in this paper in the study of decentralized control (as in [10]) of distributed timed systems that are formed as synchronous compositions of sequential (i.e. one clock) systems. This would lead to an exponential saving of complexity of control synthesis compared to global control synthesis of distributed timed systems.

References
J. Ad´amek, S. Milius and J. Velebil. On coalgebra Based on Classes. Theoretical Computer Science 316, pp.3-23, 2004.
R. Alur and D. Dill. The Theory of Timed Automata. Theoretical Computer Science, 126:183-235, 1994.
A. Arnold. A. Arnold Finite Transition Systems. Semantics of Communicating Sytems, Prentice-Hall, Englewood Cliffs, NJ, 1994.
P. Buchholz, P. Kemper. Weak Bisimulation for (max/+)-Automata and Related Models. Journal of Automata, Languages and Combinatorics (2003) 8 (2), 187-218.
S.G. Cassandras and S. Lafortune. Introduction to Discrete Event Systems, Kluwer Academic Publishers, 1999.
D. D’Souza and P.S.Thiagarajan. Product Interval Automata, In Sadhana, Academy Proceedings in Engineering Sciences, Vol. 27, No. 2, Indian Academy of Sciences, pp. 181–208, 2002.
S. Eilenberg. Automata, Languages, and Machines, Vol. A. Academic Press, New York, 1974.
S. Gaubert. Performance evaluation of (max,+) automata, IEEE Trans. on Automatic Control, vol. 40(12), pp. 2014-2025, 1995.
S. Gaubert and J. Mairesse. Modeling and analysis of timed Petri nets using heaps of pieces. IEEE Trans. on Automatic Control, vol. 44(4): 683-698, 1999.
J. Komenda and J. H. van Schuppen: Modular Control of Discrete-Event Systems with Coalgebra.
IEEE Transactions on Automatic Control, 53, N2, pp. 447-460, 2008.
J. Komenda, S. Lahaye, and J.-L. Boimond. Supervisory Control of (max,+) automata: a behavioral approach. Discrete Event Dynamic Systems, 19, N4 , pp. 525-549, Springer, 2009.
J. Komenda, S. Lahaye, and J.-L. Boimond. Le produit synchrone des automates (max,+). Mod´elisation des Syst`emes R´eactifs (MSR09), Nantes, France, 2009. In JESA (Journal Europ´een des Syst`emes Automatis´es), vol. 43, pp.1033–1047, 2009.
D. Krob. The equality problem for rational series with multiplicities in the tropical semiring is undecidable. Internat. J. Algebra Comput., 4, pp. 405 - 425, 1994.
S. Lombardy and J. Mairesse. Series which are both max-plus and min-plus rational are unambiguous, RAIRO - Theoretical Informatics and Applications 40, pp. 1-14, 2006.
J.J.M.M. Rutten. Coalgebra, Concurrency, and Control. Research Report CWI, SEN-R9921, Amsterdam, November 1999. Available also at http://www.cwi.nl/~janr.
J.J.M.M. Rutten. Universal Coalgebra: A Theory of Systems. Theoretical Computer Science 249(1):3- 80, 2000.
J.J.M.M. Rutten. Behavioural differential equations: a coinductive calculus of streams, automata, and power series. Theoretical Computer Science Volume 308(1–3), pp. 1–53, 2003.
J.J.M.M. Rutten. Algebraic Specification and Coalgebraic Synthesis of Mealy Automata. Proceedings FACS 2005, ENTCS Vol. 160, Elsevier, 2006, pp. 305-319.
J. Sifakis and S. Yovine. Compositional Specification of Timed Systems. Invited paper in Proceedings of the 13th Annual Symp. on Theoretical Aspects of Computer Science, STACS’96, pp. 347-359, Springer LNCS 1046, February 1996.
