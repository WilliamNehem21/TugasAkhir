	Electronic Notes in Theoretical Computer Science 204 (2008) 111–127	
www.elsevier.com/locate/entcs

Towards a Sharing Strategy for the Graph Rewriting Calculus
P. Baldana and C. Bertolissib and H. Cirsteac and C. Kirchnerd
a Dipartimento di Informatica, Universita` Ca’ Foscari di Venezia, Italy
b LIF-Universit´e de Provence, Marseille, France
c Nancy Universit´e-LORIA, France
d INRIA-LORIA, Nancy, France

Abstract
The graph rewriting calculus is an extension of the ρ-calculus, handling graph like structures rather than simple terms. The calculus over terms is naturally generalized by using unification constraints in addition to the standard ρ-calculus matching constraints. The transformations are performed by explicit application of rewrite rules as first class entities. The possibility of expressing sharing and cycles allows one to represent and compute over regular infinite entities.
We propose in this paper a reduction strategy for the graph rewriting calculus which aims at maintaining the sharing information as long as possible in the terms. The corresponding reduction relation is shown to be confluent and complete w.r.t. the small-step semantics of the graph rewriting calculus.
Keywords: rewriting calculus, term graphs, sharing, reduction strategies, confluence, matching and unification constraints

Introduction
Main interest for term rewriting stem from functional and rewrite based languages as well as from theorem proving. In particular, we can describe the behaviour of a functional or rewrite based program by analyzing some properties of the associated term rewriting system. In this framework, terms are often seen as trees but in order to improve the efficiency of the implementation of such languages, it is of fundamental interest to think and implement terms as graphs [6]. In this case, the possibility of sharing subterms allows to save space (by using multiple pointers to the same subterm instead of duplicating the subterm) and to save time (a redex appearing in a shared subterm will be reduced at most once and equality tests can be done in constant time when the sharing is maximal).
Graph rewriting is a useful technique for the optimization of functional and declarative languages implementations [15]. Moreover, the possibility to define cy- cles leads to an increased expressive power that allows one to represent easily regular

1571-0661 © 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.03.057

infinite data structures. Cyclic term graph rewriting has been widely studied, both from an operational [6,1] and from a categorical/logical point of view [7] (see [17] for a survey on term graph rewriting).
The graph rewriting calculus, or ρg-calculus, introduced in [5], is a common
generalization of the cyclic λ-calculus [AK97] and the ρ-calculus [9], providing a framework where pattern matching, graphical structures and higher-order capabil- ities are primitive. The ρg-calculus deals with cyclic terms with bound variables
and can express vertical sharing as well as horizontal sharing by means of a list of recursion equations. In the ρg-calculus computations related to the matching are made explicit and performed at the object-level. The calculus, under suitable
linearity constraints for patterns, has been shown to be confluent [3] and expressive enough for simulating cyclic λ-calculus and term-graph rewriting.
In view of its future implementation, we are interested in improving the effi- ciency of the ρg-calculus evaluation process. To this aim we present a reduction strategy aimed at keeping the sharing information as long as possible in ρg-calculus terms. In the ρg-calculus the loss of sharing is caused by the application of the substitution rules, which allow to create copies of (sub)terms of a ρg-calculus term. Indeed, during the computation, some loss of sharing is unavoidable, for example for making a rule application explicit or for solving a matching constraint. However, a strategy which suitably restricts the application of the substitution rules can avoid some useless loss of sharing, leading to more compact normal forms. The strategy should allow to perform essentially the same reductions to normal form as in the unconstrained calculus, in the sense that the normal form of a term with respect to the strategy (when it exists) should be the same as in the original calculus, up to sharing.
Indeed, we will show that, under suitable linearity constraints, the proposed strategy is correct and complete with respect to the reduction relation of the ρg-calculus. Additionally, we will show that the reduction relation of the ρg-calculus induced by such a strategy is confluent.
The paper is organized as follows. In the next section we review the graph rewriting calculus. Section 3 describes the reduction strategy SharingStrat proposed for preserving sharing in ρg-calculus terms. In Section 4 we show that SharingStrat is sound and complete with respect to the small step semantics of the ρg-calculus. Moreover, along the lines of the proof of confluence for the ρg-calculus, we show that the ρg-calculus with SharingStrat is confluent. We conclude in Section 5 by presenting some perspectives of future work.

The graph rewriting calculus
The syntax of the ρg-calculus is presented in Fig. 1. As in the plain ρ-calculus, λ-abstraction is generalized by a rule abstraction P d G, where P is in general an arbitrary term. There are two different application operators: the functional application operator, denoted simply by concatenation, and the constraint appli- cation operator, denoted by “  [ ]”.  Terms can be grouped together into struc-



Terms
G, P ::= X	(Variables)
| K	(Constants)
| P d G (Abstraction)
| G G	(Functional application)
| G G	(Structure)
| G [C]	(Constraint application)
Constraints
C ::= є	(Empty constraint)
| X = G (Recursion equation)
| P  G (Match equation)
| C, C	(Conjunction)


Fig. 1. Syntax of the ρg-calculus
tures built using the operator “  ”. This operator is useful for representing the (non-deterministic) application of a set of rewrite rules and consequently, the non- deterministic results. For example, the non-deterministic application of one of the rules in {a d b, a d c} to the term a can be written (a d b  a d c) a. This term, as it will become clearer after the formal definition of the semantics of the calculus (see Fig. 2), reduces to (a d b) a (a d c) a and then to b c. Note that the calculus is untyped, but type systems, in the style of those introduced for the ρ-calculus in [4,18], would be conceivable.
In the ρg-calculus constraints are conjunctions (built using the operator “ , ”) of match equations of the form P G and recursion equations of the form X = G. The empty constraint is denoted by ϵ. The operator “ , ” is supposed to be associative, commutative, with ϵ as neutral element.
We assume that the application operator associates to the left, while the other operators associate to the right. To simplify the syntax, operators have different priorities.  Here are the operators ordered from higher to lower priority: “  ”, “ d ”, “  ”, “ [ ]” , “   ”, “ = ” and “ , ”.
The symbols G, H, P . . . range over the set G of terms, x, y, . . . range over the
set X of variables, a, b, . . . range over a set K of constants. The symbols E, F, . . .
range over the set C of constraints.
We call algebraic the terms of the form (((f G1) G2) .. .) Gn, with f ∈ K, Gi ∈ X ∪ K or Gi algebraic for i = 1 ... n, and we usually denote them by f (G1, G2,..., Gn).
We denote by • (black hole) a constant, already introduced in [1] using the equational approach and also in [12] using the categorical approach, to give a name to “undefined” terms that correspond to the expression x [x = x] (self-loop). The notation x =◦ x is an abbreviation for the sequence x = x1,..., xn = x. We use the symbol Ctx[ ] for a context with exactly one hole . We say that a ρg-term is acyclic if it contains no sequence of constraints of the form Ctx0[x0]  Ctx1[x1], Ctx2[x1]   Ctx3[x2], . . . , Ctxm[xn]   Ctxm+1[x0], with n, m ∈ N and  ∈ {=, }. A sequence of this kind is called a cycle.
For the purposes of this paper we restrict to left-hand sides of abstractions and match equations that are acyclic, algebraic terms in normal form. The set of all these terms, called patterns, is denoted by P.  For instance, the ρg-term f (y) [y = g(y)] d a is not allowed since the abstraction has a cyclic left-hand side. A ρg-term is called well-formed if each variable occurs at most once as left- hand side of a recursion equation. All the ρg-terms considered in the sequel will be

implicitly assumed to be well-formed.
The notions of free and bound variables of ρg-terms take into account the three binders of the calculus: abstraction, recursion and match. Intuitively, variables on the left hand-side of any of these operators are bound by the operator. As usual, we work modulo α-conversion. The set of free variables of a ρg-term G is denoted by FV(G). A variable in a term G is called active, or in active position, if it appears free in the left-hand side of an application occurring in G. Moreover, given a constraint C we will refer to the set DV(C), of variables “defined” in C. This set includes, for any recursion equation x = G in C, the variable x and for any match P  G in C, the set of free variables of P . For a formal definition, see [2].
Finally, in order to ensure the confluence of the calculus, we will assume all patterns to be linear. Roughly, a pattern is called linear if each variable occurs free at most once in the pattern.
Definition 2.1 (Linear ρg-calculus) The class of (algebraic) linear patterns is deﬁned as follows:
L ::= X | K | (((K L0) L1) .. .) Ln | L0 [X1 = L1,..., Xn = Ln]
where we assume that FV(Li) ∩ FV(Lj) = ∅ for i /= j. A constraint [L1   G1,
..., Ln   Gn], where  ∈ {=, }, is linear if all patterns L1,..., Ln are linear and FV(Li) ∩ FV(Lj) = ∅, i /= j. The linear ρg-calculus is the calculus where all the patterns in the left-hand side of abstractions and all constraints are linear.
In this paper we will focus on the linear ρg-calculus, hence the qualification “linear” will be often omitted, and the involved patterns and constraints will be assumed to be linear unless stated otherwise.
We define next an order over variables bound by a match or an equation. This order will be later used in the definition of the substitution rule of the calculus, which will allow for only “upward” substitutions, a constraint which is essential for the confluence of the calculus (see [3]). We denote by ≤ the occur-check ordering, that is the least pre-order on recursion variables such that x ≥ y if x = Ctx[y] appears in the list of constraints for some context Ctx[ ]. The equivalence induced by the pre-order is denoted ≡ and we say that x and y are cyclically equivalent (x ≡ y) if x ≥ y ≥ x (they lie on a common cycle). We write x > y if x ≥ y and x /≡ y.
Example 2.2 [Some ρg-terms]
In the rule (2 ∗ f (x)) d ((y + y) [y = f (x)]) the sharing in the right-hand side avoids the copying of the object instantiating f (x), when the rule is applied to a ρg-term.
The ρg-term x [x = cons(0, x)] represents an infinite list of zeros.
The ρg-term f (x, y) [x = g(y),y = g(x)] is an example of twisted sharing that can be expressed using mutually recursive constraints (to be read as a letrec construct). We have that x ≥ y and y ≥ x, hence x ≡ y.
The complete set of evaluation rules of the ρg-calculus is presented in Fig. 2.

Basic rules:
(ρ) (P d G2) G3	→ρ G2 [P  G3] (P d G2) [E] G3 →ρ G2 [P  G3, E]
(δ) (G1  G2) G3	→δ G1 G3  G2 G3
(G1  G2) [E] G3 →δ (G1 G3  G2 G3) [E]
Matching rules:
(propagate) P  (G [E])	→p P   G, E	if P /= x
(decompose) K(G1,..., Gn)  K(G' ,..., G' ) →dk G1  G' ,..., Gn  G'
1	n	1	n
with n ≥ 0
(solved)	x  G, E	→s x = G, E	if x /∈ DV(E)
Graph rules:
(external sub) Ctx[y] [y = G, E]	→es Ctx[G] [y = G, E]
(acyclic sub)	G [P   Ctx[y],y = G1, E] →ac G [P   Ctx[G1],y = G1, E]
if G1 is a variable or
(x > y, ∀x ∈ FV(P ))
where ∈ {=, }
(garbage)	G [E, x = G']	→gc G [E]
if x /∈ FV(E) ∪ FV(G)
G [ϵ]	→gc G
(black hole)	Ctx[x] [x =◦ x, E]	→bh Ctx[•] [x =◦ x, E]
G [P   Ctx[y],y =◦ y, E] →bh G [P   Ctx[•],y =◦ y, E]
if x > y, ∀x ∈ FV(P )
Fig. 2. Small-step semantics of the ρg-calculus

As in the plain ρ-calculus, in the ρg-calculus the application of a rewrite rule to a term is represented as the application of an abstraction. A redex can be activated
using the ρ rule in the Basic rules, which creates the corresponding matching
constraint. The computation of the substitution which solves the matching is then performed explicitly by the Matching rules and, if the computation is successful, the result is a recursion equation added to the list of constraints of the term. This
means that the substitution is not applied immediately to the term but it is kept in the environment for a delayed application or for deletion if useless, as expressed by the Graph rules.
More precisely, the first two rules ρ and δ come from the ρ-calculus. For each of these rules, an additional rule dealing with the presence of constraints is considered.

The Matching rules and in particular the rule decompose are strongly related to the theory modulo which we want to compute the solutions of the matching. In this paper we consider the syntactical matching, which is known to be decidable, but extensions to more elaborated theories are possible.
The Graph rules are inherited from the cyclic λ-calculus [AK97]. The first two rules make a copy of a ρg-term associated to a recursion variable into a term that is inside the scope of the corresponding constraint. As already mentioned, the substitution rule allows one to make the copies only upwards w.r.t. the order defined on the variables of ρg-terms. Recall that “ , ” is assumed to be associative, commutative and with ϵ as neutral element, and thus evaluation steps are performed modulo the corresponding theory.
We denote by →ρg ('→M) and →ρg ( →M) the relations induced by the set of rules of Fig. 2 and by the subset of Matching rules, respectively. For any two rules r and s belonging to this set, we will write →r,s to express the two steps '→r'→s.
As mentioned above, the (linear) ρg-calculus, with the rewrite relation →ρg, has been shown to be confluent [3]. A term G is in normal form if none of the reduction rules of Fig. 2 can be applied to G. A reduction of a term H into its normal form G, when it exists, is denoted by H →ρg! G.

Example 2.3 [A simple reduction] (f (a, a) d a) (f (y, y) [y = a])
→ρ	a [f (a, a)  f (y, y) [y = a]] '→p a [f (a, a)  f (y, y),y = a] '→dk a [a  y, a  y, y = a] = a [a  y, y = a] (by idempotency) '→ac a [a  a, y = a] '→dk a [y = a] →gc a
Example 2.4 [Reduction to the normal form]
Consider the term G = f (y, y) [y = z f (a),z = f (x) d x]. We show one of the possible reductions of G to its normal form.
f (y, y) [y = z f (a),z = f (x) d x]
'→ac f (y, y) [y = (f (x) d x) f (a),z = f (x) d x]
→ρ	f (y, y) [y = x [f (x)  f (a)],z = f (x) d x]
'→dk f (y, y) [y = x [x  a],z = f (x) d x]
'→s f (y, y) [y = x [x = a],z = f (x) d x]
'→es f (y, y) [y = a [x = a],z = f (x) d x]
→gc f (y, y) [y = a, z = f (x) d x]
→es f (a, a) [y = a, z = f (x) d x] '→gc f (a, a)

Example 2.5 [Encoding of the Peano addition]
We suppose given the constants 0, S, add and rec. We define the following ρ-term

that computes the addition over Peano integers.

(add 0 y) d y
plus   (rec z) d
 (add (S x) y) d S (z (rec z) (add xy))
The variable z will contain a copy of plus to allow “recursive calls”. If we use the notations m, m+n and m−n for the terms S(... (S 0) .. .) with the right number of S symbols, then the term plus (rec plus) (add nm) reduces to m+n. Actually, to obtain this result we also need a way of getting rid of some stuck subterms, in which matching definitively fails (see [11,8]).
A sharing strategy for ρg-calculus
In view of a future efficient implementation of the calculus, we are interested in studying suitable strategies that aim at keeping the sharing information as long as possible in ρg-terms.
Intuitively, the strategy should delay as much as possible the application of the substitution rules, (external sub) and (acyclic sub), which can break the sharing by duplicating terms. For instance, consider the reduction
f (x, x) [x = (a d g(b))a]
'→es f ((a d g(b))a, x) [x = (a d g(b))a]
'→es f ((a d g(b))a, (a d g(b))a) [x = (a d g(b))a]
→ρ	f (g(b) [a  a], g(b) [a  a]) [x = (a d g(b))a]
→p	f (g(b) [ϵ], g(b) [ϵ]) [x = (a d g(b))a]
→gc f (g(b), g(b))
The uncontrolled use of substitution induces useless and expensive (both in terms of time and space) duplications of terms. For instance, in the case above, the following reduction would be preferable
f (x, x) [x = (a d g(b))a]
'→ρ f (x, x) [x = g(b) [a  a]]
'→p f (x, x) [x = g(b) [ϵ]]
→gc f (x, x) [x = g(b)]
The idea underlying the proposed strategy is to constrain substitution rules to be applied only if they are needed for generating new redexes for the basic or matching rules. Note that, in particular, substitutions which do not contribute to generating new basic or matching redexes will never be applied. Hence the strategy will enlarge the class of terms which are in normal form.
For instance, we allow the application of the (external sub) rule to the terms

x a [x = f (x) d x] or x a [x = a (a d b)], since this is useful for creating, respectively, a new (ρ) redex and a new (δ) redex. Instead, (external sub) cannot be applied to the terms f (x, x) [x = g(x)] or x [x = f (x)] which are actually considered in normal form. Note, however, that capturing the notion of “substitution needed for generating a new redex” is not straightforward since more than one substitution step can be needed to generate a new redex for the basic or matching rules as it happens below, where the generated redex is underlined:
y [y = x f (a),x = f (z) d y] '→es x f (a) [y = x f (a),x = f (z) d y]
'→es (f (z) d y) f (a) [y = x f (a),x = f (z) d y]

Note that a single step would suffice to generate the redex if we removed the acyclic- ity constraint for substitutions, allowing the reduction
y [y = x f (a),x = f (z) d y] '→ y [y = (f (z) d y) f (a),x = f (z) d y]
The definition of the strategy will rely on the fact, formally proved later, that the above phenomenon is an instance of a completely general case.

There is one more situation in which we want to apply the substitution rules, that is when we have trivial recursion equations of the kind x = y where both sides are single variables, like in x ∗ y + x [x = z, y = z, z = 1]. In this case, we may want to simplify the term to (z ∗ z + z) [z = 1] in which useless names have been eliminated by garbage collection.
Hereafter, we call basic redex any term which has one of the shapes (P d G2) G3, (P d G2) [E] G3, (G1  G2) G3 or (G1  G2) [E] G3, which can be reduced using the Basic rules in Fig. 2. Similarly, a term of the form P  G is called a matching redex if it can be reduced by one of the Matching rules.
We define next the reduction strategy we can adopt in the ρg-calculus to maintain the sharing information during the reduction as long as possible.
Definition 3.1 [Sharing Strategy] The evaluation strategy SharingStrat is defined as follows.
All the evaluation rules but (external sub) and (acyclic sub) are applicable without any restriction.
The rules (external sub) and (acyclic sub) are applied to a term G only if no other rule is applicable and if
their application replaces a variable by a variable (renaming), or

their application creates (in one step) a basic or a matching redex, or
the term G has the form G' [x = Ctx[y],y = Ctx'[z], E], with x ≡ y and
Ctx[Ctx'[x]] includes a basic or a matching redex.


In other words the rules (external sub) and (acyclic sub) are applied when their application leads to
the instantiation of a variable by a variable (condition (ii)a);
the instantiation of an active variable by an abstraction or a structure, which produces a Basic redex (condition (ii)b);
the instantiation of a variable in a stuck match equation, which produces a Match- ing redex, i.e., which enables a decomposition or constraint propagation w.r.t. the match equation (condition (ii)b).
Additionally, condition (ii)c captures the fact that, given a term G [E] if a cyclic substitution in E would generate a redex, then one is allowed to apply some external substitutions in order to reproduce the same redex in G.

Example 3.2 [Multiplication]
Let us use an infix notation for the constant “∗”. The following ρg-term corre- sponds to the application of the rewrite rule R = x ∗ s(y) d (x ∗ y + x) to the term 1 ∗ s(1) where the constant 1 is shared.
(x ∗ s(y) d (x ∗ y + x)) (z ∗ s(z) [z = 1])
→ρ  x ∗ y + x [x ∗ s(y)  (z ∗ s(z) [z = 1])]
'→p  x ∗ y + x [x ∗ s(y)  z ∗ s(z),z = 1]
→dk x ∗ y + x [x  z, y  z, z = 1]
→s x ∗ y + x [x = z, y = z, z = 1]
→es (z ∗ z + z) [x = z, y = z, z = 1] (allowed by Def. 3.1(ii) a))
→gc (z ∗ z + z) [z = 1]
Notice that the term (z ∗ z + z) [z = 1] is in normal form w.r.t. the strategy
SharingStrat but can be reduced to (1 ∗ 1 + 1) if no evaluation strategy is used.

Example 3.3 [Reduction to normal form]
We consider the term G of Example 2.4 and we reduce it following the strategy
SharingStrat. We obtain:
f (y, y) [y = z f (a),z = f (x) d x]
'→ac f (y, y) [y = (f (x) d x) f (a),z = f (x) d x] (by Def. 3.1(ii) b))
→ρ	f (y, y) [y = x [f (x)  f (a)],z = f (x) d x]

'→dk f (y, y) [y = x [x  a],z = f (x) d x]
→s	f (y, y) [y = x [x = a],z = f (x) d x]
'→gc f (y, y) [y = x [x = a]]
Note that the normal form with respect to SharingStrat, i.e., the term f (y, y) [y = x [x = a]], represents a graph where the arguments of f are shared. In- stead, as shown in Example 2.4, the reduction in the ρg-calculus with no evaluation strategy leads to the term f (a, a) where the arguments of f are duplicated.
Example 3.4 Consider the ρg-term G = f (y)[y = x a, x = y  b]. Notice that
x ≡ y, thus the (acyclic sub) rule cannot be applied. We have instead the reduction:
f (y)[y = x a, x = y b] '→es f (x a)[y = x a, x = y b] '→es
f ((y b) a)[y = x a, x = y b] →δ f ((y a b a))[y = x a, x = y b]
This derivation is a valid derivation using the strategy SharingStrat. Indeed, there exists a cyclic substitution step which transforms the pre-redex x a into a basic redex (y b) a. Hence, the first (external sub) rule step can be performed following Definition 3.1(ii) c). The second (external sub) rule step is needed to create the basic redex (y b) a, thus it is permitted by Definition 3.1(ii) b).
Properties of the sharing strategy
In this section we will show some basic properties of the ρg-calculus with the evalu- ation strategy SharingStrat. First, we will show the soundness and completeness of the strategy SharingStrat w.r.t. ρg-calculus (normalising) derivations. In the second part, we will adapt the confluence proof described in [3] in order to prove that the ρg-calculus with the strategy SharingStrat is still confluent.

Soundness and completeness
Here we prove that the reduction strategy proposed for the ρg-calculus is sound and complete with respect to the one step semantics of the ρg-calculus as defined in Section 2. Actually, while soundness is immediate, completeness will be proved only for normalising reductions.
Proposition 4.1 (Soundness) Given two ρg-terms G and Gn, if G →ρg Gn in the
ρg-calculus with the strategy SharingStrat, then G →ρg Gn in the ρg-calculus.
Proof. Trivial.	 
The completeness result relies on a couple of technical lemmata. In the proofs, it will be convenient to refer to a notion of cyclic substitution, which consists of the application of the rule (ac) without any restriction on the order of variables
G [P   Ctx[y],y = G1, E] →c G [P   Ctx[G1],y = G1, E]
We will denote by '→s any application of the substitution rules, i.e. (external sub) or (acyclic sub), possibly cyclic, if this is specified.

We remark that these cyclic substitutions are not allowed in the calculus, but they are just used as a technically convenient tool in proofs. In particular we will use the following simple fact.
Proposition 4.2 Let G be G' [x = Ctx[y],y = Ctx'[z], E] with {x, y}∩JV(G') /= ∅. If G '→c G' [x = Ctx[Ctx'[z]],y = Ctx'[z], E] and Ctx[Ctx'[z]] includes a basic or matching redex, then G is not in normal form with respect to SharingStrat.
Proof. If x ≡ y, then by Definition 3.1(ii)c we can apply an external substitution, replacing in G' x or y with their definition. Otherwise, the considered step is a valid application of rule (ac).	 
Lemma 4.3 Let Ctx[ ], Ctx1[ ] be two ρ-contexts such that Ctx1[x] is neither a free variable nor a free constrained variable (i.e. neither x nor x [E] with ÐV(E) ∩
{x} = ∅). Let Ctx[Ctx1[y]] be a ρ-term without redexes and Ctx[Ctx1[G]] be a ρ- term containing a Basic or Matching redex. Then, Ctx1[G] contains a Basic or Matching redex.
Proof. [Sketch.] By induction on the form of Ctx[ ]. The interesting cases are the followings:
Ctx[ ] is an application. In this case Ctx[ ] = Ctx'[ ] G' or Ctx[ ] = G' Ctx'[ ]. If Ctx'[x] is not a free (constrained) variable, then we conclude by inductive hy- pothesis. Hence, either Ctx[ ] =  G' or Ctx[ ] = G' .
If Ctx[ ] =  G', note that Ctx1[y] cannot be a variable and it cannot be an abstraction or a structure (otherwise Ctx[Ctx1[y]] would contain a redex). If Ctx1[y] is an application the property clearly holds since no new redexes can be created by instantiation. If Ctx1[y] is a constraint application of the form H [E] then, again, H cannot be an abstraction or a structure (otherwise Ctx[Ctx1[y]]
would contain a redex). If H = y then it can be instantiated by G and create a new redex only if y /∈ ÐV(E) but this contradicts the hypothesis.
If instead, Ctx[ ] = G'  the property trivially holds.
Ctx[ ] is a matching equation. Then Ctx[ ] = G'  Ctx'[ ], and as above, when Ctx'[ ] is non-empty we conclude by inductive hypothesis. Thus, let Ctx[ ] = G'. Since the term f (G1, G2,..., Gn)  Ctx1[y] contains redexes then Ctx1[y] is not of the form f (H1, H2,..., Hn) or H [E]. The term f (G1, G2,..., Gn)  Ctx1[G] is a redex only if Ctx1[G] has the form f (H1, H2,..., Hn) or H [E] and this is possible only if Ctx1[x] is a free (constrained) variable (which contradicts the hypothesis).
 
A key point is that it is not possible to create a Basic or Matching redex by further reducing a term that is in normal form w.r.t. the reduction strategy. To prove this result, we use the following lemma.
Lemma 4.4 Let G, G1, G2 be ρg-terms not containing trivial recursion equations,
i.e. equations of the form x = y. Let G '→s G1 '→s G2 be two (possibly cyclic) substitution steps such that G and G1 do not contain a Basic or Matching redex

and G2 does. Then, there exists a (possibly cyclic) substitution step G '→s G' , such
that the Basic or Matching redex is present in G' .
Proof.
Consider the two-steps external sub reduction Ctx[y] [y = Ctx1[z],z = H, E] '→es
Ctx[Ctx1[z]] [y = Ctx1[z],z = H, E] '→es Ctx[Ctx1[H]] [y = Ctx1[z],z = H, E]

where only the last term contains a
Basic
or Matching redex.	Since by

hypothesis Ctx1[ ] is not empty, by Lemma 4.3, we know that the redex is in the term Ctx1[H]. Hence we can build the following one-step reduction: Ctx[y] [y = Ctx1[z],z = H, E] '→ac Ctx[y] [y = Ctx1[H],z = H, E] Notice that
this substitution step may be cyclic, if y and z are cyclically equivalent.
For the two-steps acyclic sub reduction x [x = Ctx[y],y = Ctx1[z],z = H, E] '→ac x [x = Ctx[Ctx1[z]],y = Ctx1[z],z = H, E] '→es x [x = Ctx[Ctx1[H]],y = Ctx1[z],z = H, E] we proceed similarly as in the previous case.
Consider the two-steps reduction Ctx[y] [y = Ctx1[z],z = H, E] '→ac Ctx[y] [y = Ctx1[H],z = H, E] '→es Ctx[Ctx1[H]] [y = Ctx1[H],z = H, E] Since by hypoth- esis Ctx1[ ] is not empty, the first acyclic sub step instantiates a variable in the term Ctx1[z] without changing its structure. Thus, to create a redex, it is suf- ficient to perform the one-step reduction Ctx[y] [y = Ctx1[z],z = H, E] '→es Ctx[Ctx1[z]] [y = Ctx1[z],z = H, E].
Consider the two-steps reduction Ctx[y] [y = Ctx1[z],z = H, E] '→es Ctx[Ctx1[z]] [y = Ctx1[z],z = H, E] '→ac Ctx[Ctx1[z]] [y = Ctx1[H],z = H, E] The redex is created in Ctx1[H]. The first external sub step copies a sub-term in the graph but is without effect w.r.t. redex creation. We thus can build the one- step reduction Ctx[y] [y = Ctx1[z],z = H, E] '→ac Ctx[y] [y = Ctx1[H],z = H, E].
 
Corollary 4.5 Let G be a ρg-term with no trivial recursion equations, and let G →s Gn such that Gn contains a Basic or Matching redex and G does not, then there existsaa (possibly cyclic) substitution step G '→s G' , such that the Basic or
Matching redex is present in G' .
Proof. By induction, using Lemma 4.4.	 
Using the above result and exploiting Proposition 4.2 we easily prove the result below, from which completeness follows.
Corollary 4.6 If a ρg-term G is in normal form with respect to the strategy Shar- ingStrat and G →es,ac Gn, then Gn is in normal form with respect to the strategy SharingStrat.
Theorem 4.7 (Completeness) Given a normalising ρg-term G, if G →ρg! Gn in the ρg-calculus, then there exists a ρg-term Gm such that G →ρg! Gm in the ρg-calculus with the strategy SharingStrat and Gm →es,ac Gn.
Proof. First, notice that in the ρg-calculus with the strategy SharingStrat, the reduction G →ρg ... cannot be infinite, otherwise we would have an infinite reduction



·_   R	 _· 
·_   R	 _· 
·_   R	 _· 
_· ∼AC1 _·

R	R	R
J	J	J 
R	R1
J	J 
R	R
J	J 
J	· ∼

·  · ∼ AC1 ·
R
·   · ∼ AC1 ·
R
·   · ∼ AC1 ·
R1
AC1 ·

Local	Confluence	Commutation	Compatibility confluence

Fig. 3. Properties of rewriting modulo AC1

also in the ρg-calculus. Thus we have G →ρg! Gm. Moreover, we have Gm →ρg! Gn in the ρg-calculus, since the calculus is confluent. In order to conclude we have to prove that Gm →es,ac Gn (using only substitution steps).
This follows immediately from Corollary 4.6. In fact, by contradiction, if there
were a reduction Gn →es,ac G' '→M G'' , then, by Corollary 4.6, Gn would not be in
normal form w.r.t. the strategy SharingStrat.	 
Notice that we cannot expect completeness to hold in general, since “useless” unsharing followed by the reduction of some basic or matching redexes cannot be simulated while obeying SharingStrat. For instance, the result in Theorem 4.7 would not hold for the derivation
f (x, x) [x = (a d b) a]
'→es f ((a d b) a, x) [x = (a d b) a]
→ρ,dk f (b, x) [x = (a d b) a]

Confluence
We will next show that the (linear) ρg-calculus calculus with the evaluation strategy SharingStrat is confluent. The proof is obtained by adapting the confluence proof for the ρg-calculus [3].
As already mentioned, in the ρg-calculus, rewriting can be thought of as acting over equivalence classes of ρg-graphs with respect to the congruence relation, de- noted by ∼AC1 or simply AC1 , generated by the associativity, commutativity and neutral element axioms for the “ , ” operator. The relation induced over AC1 - equivalence classes is written '→ρg/AC1 . Concretely, in the proof, the notion of rewriting modulo AC1 [16], denoted '→ρg,AC1 , is used. Figure 4.2 provides a graph- ical representation of some properties of a relation R modulo the congruence relation
∼AC1 . The formal definitions can be found in [13,14].
A key property in the confluence proof is the compatibility of the reduction relation with respect to the equivalence on terms, that holds for any subset of rules of the ρg-calculus. This property ensures that the rewrite relation is particularly well-behaved w.r.t. the congruence relation AC1 .
Clearly, according to the strategy SharingStrat, the order in which constraints are listed does not influence the applicability of substitution rules. Therefore com-

patibility for the ρg-calculus with strategy SharingStrat can be proved exactly as for in the unrestricted calculus.
Lemma 4.8 (Compatibility of ρg) Compatibility with AC1 holds for any rule r
of the ρg-calculus with strategy SharingStrat.
←r',AC1 · ∼AC1	⊆ ∼AC1 · ←'r,AC1

Following the proof in [3], the evaluation rules of the ρg-calculus are split into two subsets for which confluence is first proved independently. Then, this intermediate result, together with a commutation lemma, is used for proving the confluence of the union of the two subsets. Here this proof is adapted to the ρg-calculus calculus with the strategy SharingStrat, under the same assumptions of linearity for patterns and constraints.
The first subset of rules, called τ , includes (ρ), (propagate), (decompose), (solved), (garbage) and (black hole), and the second one, called Σ, consists of the remaining rules, i.e. (external sub), (acyclic sub) and the (δ). Since only the latter set includes rules whose application is constrained by the strategy SharingStrat, only the proofs concerning the relation induced by this set should be adapted w.r.t. to the unrestricted version of the calculus. In what follows we detail the corresponding proofs, while the properties that can be inherited from the unrestricted calculus [3] are just stated.
Proposition 4.9 The relation τ is confluent modulo AC1 under the strategy Shar- ingStrat.
The relation induced by the set of rules Σ is shown to be confluent adapting the complete development method defined for the λ-calculus: a terminating version of the relation (the development), denoted Σ, can be defined and its properties are used for deducing the confluence of the original rewrite relation. Due to space constraints, the development relation cannot be defined in full details here. Roughly, a step G →Σ H of such relation consists of the complete development, with respect to Σ, of a set of redexes selected in the starting term G. The notation Σ arises from the fact that the selection is done by underlining the redexes.
First of all, notice that since the strategy SharingStrat affects the rewrite relation by restraining the application of the substitution rules, the relation Σ is clearly still normalising under this strategy. Hence, for proving its confluence, we simply need to verify its local confluence.
Lemma 4.10 The relation (es ∪ ac) is locally confluent modulo AC1 under the strategy SharingStrat:
 	  
es,ac

J 
G2	 G '  ∼AC1	G'

es∪ac	2

Proof. By analysis of the critical pairs. If the terms duplicated by the substitutions are simply variables, then local confluence follows from the corresponding result for the ρg-calculus. A non trivial critical pair arises when one of the substitution steps occurs in the term duplicated by the other substitution. For example, consider the term G = G0 [y = x a, x = f (z a) b, z = a d b] and the two (ac)-steps leading respectively to G1 = G0 [y = x a, x = f ((a d b) a)  b, z = a d b] and G2 = G0 [y = (f (z a) b) a, x = f (z a) b, z = a d b]. We can close the critical pair since there exist two reductions G1 '→ac G3 and G2 →ac G3 such that G3 = G0 [y = (f ((a d b) a) b) a, x = f ((a d b) a) b, z = a d b].
 
The same arguments as for the unrestricted version of the calculus can be used to show that the relations (es ∪ ac) and (δ) commute. Using this result and the compatibility of the two relations we obtain the confluence of the Σ relation and then of the Σ relation.
Proposition 4.11 The relation Σ is confluent modulo AC1 under the strategy
SharingStrat.
Once having proved the confluence of the two rewrite relation independently, we prove general confluence of the (ρg, AC1 ) relation by showing the (strong) commu- tation of the two subsets of rules [14].
Lemma 4.12 The relations τ and Σ commute modulo AC1 .
Proof. Since the relations τ and Σ are compatible with AC1 , it is enough to show strong commutation between the two relations instead of general commutation:

G 	 G 

_
Σ
J 
τ



  '
_1
Σ 0/1
J 

G2	τ
G1 ∼AC1	G'

If the applied Σ-rule is the (δ) rule, the diagram can be closed as described in [3]. We are interested here in the cases where the applied Σ-rule is a substitution rule. We proceed by analysing the critical pairs. The diagram can always be closed under the strategy SharingStrat, since the τ -rules do not interfere with the creation of basic redexes. For example :


P   (Ctx[y] [y = H, E])
_
es
  p	 P   Ctx[y],y = H, E
ac

J 
P   (Ctx[H] [y =
H, E])   p
 P  Ctx[
J 
H],y =
H, E


The basic redex Ctx[H] can be created before or after the propagation of the list of constraints. We can reason similarly for the application of the other τ -rules, like

the (decompose) or the (garbage) rule (in this case we may have zero Σ-steps for closing the diagram).	 
Theorem 4.13 (Confluence of ρg, AC1 ) The rewrite relation ρg, AC1 is conflu- ent modulo AC1 under the strategy SharingStrat.
Finally, the main theorem states the confluence of the ρg/AC1 relation, by deducing it from the confluence of the (ρg, AC1 ) relation.
Theorem 4.14 (Confluence) The linear ρg-calculus with the strategy Shar- ingStrat is confluent modulo AC1 .
Conclusions
In this paper, focussing on the ρg-calculus, an extension of the ρ-calculus able to deal with graph like structures, we have proposed a reduction strategy SharingStrat aimed at maintaining the sharing information as long as possible in ρg-terms. The strategy has been shown to be sound and complete (for normalising terms) and, additionally, the ρg-calculus with the strategy SharingStrat has been shown to be confluent, under some restrictions of linearity on patterns.
There are several interesting directions for future research. We intend to in- vestigate the issue of optimality for the reduction strategy, where the notion of “optimal” has to be formally defined, for example in terms of time, space or sharing preservation. In this case a natural reference to compare with would be the work on optimal reduction for lambda calculus. Moreover, it would be interesting to in- vestigate the possibility of modelling the rewrite strategy not at the meta level, but in the calculus itself. Taking inspiration from analogous work in the ρ-calculus [10], we would like to have rewrite rules as primal strategies and iterate rewritings on a ρg-term adding a fix-point operator to the calculus. This would also require the definition of an exception handling mechanism in order to detect failures of rewrite rule application at some occurrences.

References
Z. M. Ariola and J. W. Klop. Equational term graph rewriting. Foundamenta Informaticae, 26(3- 4):207–240, 1996.
[AK97] Z. M. Ariola and J. W. Klop.	Lambda calculus with explicit recursion.	Information and Computation, 139(2):154–233, 1997.
C. Bertolissi, P. Baldan, H. Cirstea, and C. Kirchner. A rewriting calculus for cyclic higher-order term graphs. In M. Fernandez, editor, 2nd International Workshop on Term Graph Rewriting, volume 127, pages 21–41, Roma, Italy, September 2005. Electronic Notes in Theoretical Computer Science.
C. Bertolissi, P. Baldan, H. Cirstea, and C. Kirchner. A rewriting calculus for cyclic higher-order term graphs. To appear in Mathematical Structures in Computer Science, 2007.
G. Barthe, H. Cirstea, C. Kirchner, and L. Liquori. Pure Patterns Type Systems. In Proceedings of POPL’03: Principles of Programming Languages, New Orleans, USA, volume 38, pages 250–261. ACM, 2003.
C. Bertolissi. The graph rewriting calculus: properties and expressive capabilities. Th`ese de Doctorat d’Universit´e, Institut National Polytechnique de Lorraine, Nancy, France, Octobre 2005.

H. P. Barendregt, M. C. J. D. van Eekelen, J. R. W. Glauert, J. R. Kennaway, M. J. Plasmeijer, and
M. R. Sleep. Term graph rewriting. In Proceedings of PARLE’87, Parallel Architectures and Languages Europe, volume 259 of Lecture Notes in Computer Science, pages 141–158, Eindhoven, 1987. Springer- Verlag.
A. Corradini and F. Gadducci. Rewriting on cyclic structures: Equivalence of operational and categorical descriptions. Theoretical Informatics and Applications, 33:467–493, 1999.
Horatiu Cirstea, Clement Houtmann, and Benjamin Wack. Distributive rho-calculus. In 6th International Workshop on Rewriting Logic and its Applications, Electronic Notes in Theoretical Computer Science. Elsevier, 2006. to appear.
H. Cirstea and C. Kirchner. The rewriting calculus — Part I and II. Logic Journal of the Interest Group in Pure and Applied Logics, 9(3):427–498, May 2001.
H. Cirstea, C. Kirchner, L. Liquori, and B. Wack. Rewrite strategies in the rewriting calculus. In Bernhard Gramlich and Salvador Lucas, editors, Third International Workshop on Reduction Strategies in Rewriting and Programming , Valencia, Spain, June 2003. Electronic Notes in Theoretical Computer Science.
H. Cirstea, L. Liquori, and B. Wack. Rewriting calculus with fixpoints: Untyped and first-order systems. In Stefano Berardi, Mario Coppo, and Ferruccio Damian, editors, Types for Proofs and Programs (TYPES), volume 3085 of Lecture Notes in Computer Science, pages 147–171, Torino (Italy), May 2003.
A. Corradini. Term rewriting in CTΣ. In M.-C. Gaudel and J.-P. Jouannaud, editors, Proceedings of TAPSOFT’93, Theory and Practice of Software Development—4th International Joint Conference CAAP/FASE, pages 468–484. Springer, Berlin, Heidelberg, 1993.
J.-P. Jouannaud and H. Kirchner. Completion of a set of rules modulo a set of equations. SIAM Journal of Computing, 15(4):1155–1194, 1986.
E. Ohlebusch. Church-Rosser Theorems for Abstract Reduction Modulo an Equivalence Relation. In T. Nipkow, editor, Proceedings of the 9th International Conference on Rewriting Techniques and Applications (RTA-98), volume 1379 of Lecture Notes in Computer Science, pages 17–31. Springer, 1998.
S. Peyton-Jones. The implementation of functional programming languages. Prentice Hall, Inc., 1987.
G. Peterson and M. E. Stickel. Complete sets of reductions for some equational theories. Journal of the ACM, 28:233–264, 1981.
M. R. Sleep, M. J. Plasmeijer, and M. C. J. D. van Eekelen, editors. Term graph rewriting: theory and practice. Wiley, London, 1993.
B. Wack. Typage et d´eduction dans le calcul de r´e´ecriture. Th`ese de doctorat, Universit´e Henri Poincar´e
- Nancy I, October, 7- 2005.
