Electronic Notes in Theoretical Computer Science 174 (2007) 17–30	
www.elsevier.com/locate/entcs

A Compact Linear Translation for Bounded Model Checking 1
Paul B. Jackson2
School of Informatics, University of Edinburgh, King’s Buildings, Edinburgh EH9 3JZ, United Kingdom
Daniel Sheridan3
Adelard LLP, 10 Northampton Square, London EC1V 0HB, United Kingdom

Abstract
We present a syntactic scheme for translating future-time LTL bounded model checking problems into propositional satisfiability problems. The scheme is similar in principle to the Separated Normal Form encoding proposed in [5] and extended to past time in [3]: an initial phase involves putting LTL formulae into a normal form based on linear-time fixpoint characterisations of temporal operators.
As with [3] and [7], the size of propositional formulae produced is linear in the model checking bound, but the constant of proportionality appears to be lower.
A denotational approach is taken in the presentation which is significantly more rigorous than that in [5]
and [3], and which provides an elegant alternative way of viewing fixpoint based translations in [7] and [1].
Keywords: Bounded Model Checking, Linear Temporal Logic, Fixpoints, SAT, Denotational Semantics


Introduction
Frisch, Sheridan and Walsh [5] proposed a scheme for translating LTL bounded model checking problems into satisfiability problems that is significantly different from the original bounded model checking encoding scheme presented in [2]. This scheme involves simplifying temporal formulae using rules based on fixpoint char- acterisations of temporal operators to put formulae into a separated normal form (SNF) similar to that used by Fisher in his temporal resolution work [4]. Frisch, Sheridan and Walsh [5] showed that this new scheme had significant advantages

1 This research was funded in part by UK EPSRC Grant GR/N64243/01
2 Email: pbj@inf.ed.ac.uk
3 Email: dan.sheridan@contact.org.uk

1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2006.12.020

in terms of compactness of propositional formulae generated and SAT solver run times. This SNF approach smoothly extends to handle past time LTL [3] and has similarities with automata-based translations [8].
In this paper, we present an alternate set of simplification rules for future time LTL that again exploits fixpoint characterisations, but is simpler to describe. As with [3] and [7], the size of propositional formulae produced is linear in the model checking bound, 4 and the constant of proportionality is smaller than with [7].
A major contribution of the paper is in providing a denotational semantics ap- proach to justifying the encoding. This justification is much more complete and rigorous than that in [5] and [3], and it enables easy exploration of variations on these and other encodings.
A minor novelty is that we experiment with using an abstract symbolic rep- resentation of Kripke structures. Most formal presentations of BMC conflate a description of the BMC translation from LTL syntax to propositional logic syntax with a description of its semantics, and only informally refer to possible symbolic representations (for example, using propositional formulae, BDDs or Boolean cir- cuits) of Kripke structures. Our approach allows us to keep the translation and semantics distinct. While our approach is more verbose, we argue that it is easier to understand, especially when handling the auxiliary variables introduced by our translation.
Our implementation is not yet complete so we do not have empirical data on SAT solver performance on the resulting encoded problems. We certainly expect the performance to be no worse than with SNF because of the similarity.
The structure of the rest of the paper is as follows. In Section 2 we present the foundations of our denotational approach, closely following the logic of the original BMC translation from [2]. Section 3 then gives a high-level overview of our new translation. The translation is split into two phases: the normalisation phase is covered in Section 4 and the translation to propositional logic phase in Section 5. Section 6 covers related work and we draw our conclusions in Section 7.

Preliminaries
Syntax for LTL
Fix some set V of Boolean-valued state variables. We use these as the atomic propositions of our LTL formulae. We initially consider LTL formulae described by the grammar
φ ::= v | ¬v | φ ∧ φ | φ ∨ φ | X φ | F φ | G φ | φ U φ | φ R φ
where v ∈ V . Such formulae are in negation normal form (NNF): negations are only applied to state variables. Any LTL formula can be transformed into an equivalent

4 The super-linear behaviour of the SNF encoding as noted in [7] was obtained with an older version of the SNF code than that presented in [3]

NNF formula by pushing negations inwards. We use φ ⇒ ψ as an abbreviation for
¬φ ∨ ψ.

Kripke structures
The set of states S associated with a set of state variables V is the set of valuations
V → B of those variables. A Kripke structure M over a set of state variables V is a pair ⟨I, T ⟩ where I ⊆ S is a set of initial states and T ⊆ S × S is a transition relation which has to be total. Many treatments of Kripke Structures consider the set of states S more abstractly and introduce a labelling function specifying which atomic propositions are true in each state. It is straightforward to adapt our presentation to this more general approach, but, for simplicity, we do not. A similar simplification is common in automata-based approaches to LTL model checking. An
unconstrained path π over M is an infinite sequence of states π = s0, s1,... where si ∈ S. A constrained path or simply a path over M must satisfy the constraints s0 ∈ I and, for every i ≥ 0, ⟨si, si+1⟩ ∈ T . Let Paths(M ) be the set of all paths over
M . A ﬁnite path is a finite prefix of a path. A finite path s0, s1,... , sk−1 has bound
k.
We denote distinct copies of the set of state variables using superscripts. For example, V ', V i for i ∈ N. If v ∈ V , the corresponding variable in V ' is v' and

in V i is vi. A symbolic Kripke structure Mˆ
over a set of state variables V is a

pair ⟨Iˆ, Tˆ⟩ where Iˆ(V ) is a symbolic representation of the set of initial states and Tˆ(V, V ') is a symbolic representation of the transition relation. The notation A(V ) here indicates that the symbolic representation A is over the variables V . We then
write elsewhere A(W ) for A with the variables V replaced with the variables W .
ˆ	.	ˆ	.
The Kripke structure corresponding to M has I = {s ∈ S | s |= I} and T = {⟨s, t⟩ ∈ S × S | s, t |= Tˆ}. This definition uses satisfiability relations |= for single states and pairs of states satisfying a propositional formula defined in the expected way.

Inﬁnite path semantics
A common approach to LTL semantics is to define an inductive relation π |=i φ indicating at which positions i ∈ N on path π the LTL formula φ is satisfied. We give an exactly equivalent definition in a denotational style. We define the infinite

denotation
π [φ]] of formula φ to be an infinite sequence of a0, a1,... of Boolean

values, elements of B = {⊥, T}, such that ai is true just when φ is satisfied at position i of path π. We write the set of all such infinite boolean sequences as Bω. We often view a sequence a ∈ Bω as a function of type N → B, and refer to element i as a(i). When we say that a formula is satisfied by a path without indicating an explicit position on the path, we mean that the formula is satisfied at position 0. Formally, the inﬁnite denotation of an LTL formula is given inductively by:


π[[v]](i) = si(v)
π[[¬v]] = [[¬]](π[[v]])
π[[O φ]]	= [[O]](π[[φ]])	for O ∈ {X, F, G}
π[[φ O ψ]] = [[O]](π[[φ]], π[[ψ]]) for O ∈ {∧, ∨, U, R}

where the individual operator denotations are given by

[[¬]](a)(i)	.
.
[[F]](a)(i)	.
.

[[∧]](a, b)(i)
[[∨]](a, b)(i)
= a(i) ∧ b(i)
.
= a(i) ∨ b(i)
[[G]](a)(i)
[[U]](a, b)(i)
= ∀j ≥ i. a(j)
.
= ∃j ≥ i. b(j) ∧ ∀n ∈ {i .. j −1}. a(n)

[[X]](a)(i)	.
[[R]](a, b)(i)
.
= ∀j ≥ i. b(j) ∨ ∃n ∈ {i .. j −1}. a(n)


Here a, b ∈ Bω are infinite denotations and i ∈ N indexes positions in denotations. These explicit denotations for operators help simplify the presentation later. Their use emphasises that the meaning of operators is dependent only on the meaning of subformulae, not on the syntactic structure of subformulae.
Let us write φ ≡ ψ when LTL formulae φ and ψ have the same infinite denotation for all Kripke structures M and paths π over those structures.

Finite denotations when paths are looping
In producing finite propositional encodings of model checking problems, bounded model checking works with finite representations of infinite paths and infinite de- notations. In this subsection we consider loop case representations. In the next subsection we consider preﬁx case representations.
In the loop case with bound k and loop start l where 0 ≤ l < k, a finite path π˙ =
s0,... , sk−1 such that T (sk−1, sl) represents the infinite path s0 ... sl−1(sl ... sk−1)ω.
We call such infinite paths (k, l) loop paths. Similarly, a finite loop-case denotation
a˙ = a0,... , ak−1 where ai ∈ B represents the infinite denotation a0 ... al−1(al ... ak−1)ω. A loop-case inflation function ↑∞ maps finite paths and denotations to the corre- sponding infinite paths and denotations. A restriction function |k maps (k, l) loop paths and infinite loop-case denotations to their finite representations.
When working with loop paths and their finite denotations, we can define a ﬁnite
F
loop-case denotation function π˙ [[φ]]k with range Bk that exactly mimics the infinite

denotation function:

π˙ ↑∞
[[φ]] =
F
π˙ [[φ]]k ∞

where π˙ is a k-bounded path representing a (k, l) loop path. The definition is similar to that of the infinite denotation with the following changes:



F	.
l [[X]]k (a˙ )(i) =
a˙(i+1) if i < k −1
a˙(l)	if i = k −1
F
l [[F]]k (a˙ )(i)
F
l [[G]]k (a˙)(i)
.
= ∃j ∈ {min(i, l) .. k −1}. a˙(j)
.
= ∀j ∈ {min(i, l) .. k −1}. a˙(j)

F	˙	.	˙
l [[U]]k (a˙ , b)(i) = (∃j ∈ {i .. k −1}. b(j) ∧ ∀n ∈ {i .. j −1}. a˙ (n))
∨ ∃j ∈ {l .. i−1}. b˙(j) ∧ ∀n ∈ {i .. k −1}∪ {l .. j −1}. a˙(n)
F	˙	.	˙
l [[R]]k (a˙, b)(i) = (∀j ∈ {i .. k −1}. b(j) ∨ ∃n ∈ {i .. j −1}. a˙ (n))
∧ ∀j ∈ {l .. i−1}. b˙(j) ∨ ∃n ∈ {i .. k −1}∪ {l .. j −1}. a˙(n)
where a˙, b˙ ∈ Bk are finite denotations and index i is in range {0 .. k−1}.
All quantifications in the finite loop-case denotation function are over finite ranges. Following the denotation function’s structure, we can define an executable

loop-case translation function [φ]i
that can translate a question concerning the

l	k
existence of a finite path loop-case satisfying a formula into a propositional satisfia-
bility question. The relationship between the loop-case denotation and translation functions is expressed by:


F
π˙ [[φ]] (i)	⇔
π˙ |= [φ]i

where the relation π˙ |= q for when a finite path π˙ satisfies a propositional formula q is defined in the expected way. Representative cases of the definition of the loop-case translation function are

[v]i	.

i	[F φ]i
.   k−1
[φ]j


In the original paper introducing BMC [2] and many other papers in the BMC literature, symbolic Kripke structures are not explicitly introduced and confusing
semantic notations occur in translation function definitions. For example, the base
case of the translation function might be written as [v]i	.	i
l	k  = v(s ) where a state
variable v is treated as function which it is not, and a state si is introduced which
is part of the semantic presentation, not part of the language of propositional logic that is being translated into.
Finite denotations when paths have common preﬁx
In the prefix case with bound k, a finite path π˙ = s0,... , sk−1 represents the set of all paths that have it as a prefix. Prefix-case denotations such as a˙ = a0,... , ak−1 where ai ∈ B represent infinite denotations a˙ ⊥ω. A preﬁx-case inflation function ↑∞ maps finite denotations to the corresponding infinite denotations. The restriction function π|k introduced in the last section is also used to select the k-bounded prefix of an infinite path π.

We define a ﬁnite preﬁx-case denotation function
F
π˙ [[φ]]k
(or sometimes
F
π˙ [[φ]]k )

in a similar way to the the finite loop-case denotation function. In this case, the
denotations for the LTL temporal operators are given by:


F	.
[[X]]k (a˙ )(i) =
a˙ (i + 1) if i < k −1
⊥	if i = k −1
F
[[F]]k (a˙ )(i)
F
[[G]]k (a˙ )(i)
.
= ∃j ∈ {i .. k −1}. a˙(j)
.
= ⊥

F	˙	.	˙
[[U]]k (a˙ , b)(i) = ∃j ∈ {i .. k −1}. b(j) ∧ ∀n ∈ {i .. j −1}. a˙(n)
F	˙	.	˙
[[R]]k (a˙ , b)(i) = ∃j ∈ {i .. k −1}. a˙(j) ∧ ∀n ∈ {i .. j}. b(n)
The prefix case denotation underapproximates the standard infinite denotation and so is sound. We can express this by the assertion
F
π|	∞	π
k [[φ]]k ↑	±	[[φ]]
where π is any infinite path and we are treating the domain of infinite denotations
Bω as a lattice with order relation a ± b	.	∀i ∈ N. a(i) ⇒ b(i). As with the

loop-case, we can derive a prefix translation function [φ]i
(sometimes written as

[φ]i ) from the prefix-case denotation function.
—	k
The new full translation
We describe here the high-level structure and properties of our translation in order to motivate the details in subsequent sections. The translation takes an LTL formula φ,

symbolic Kripke structure Mˆ
and bound k and creates a propositional formula that

is satisfiable just when some path in Mˆ
with a k-bounded representation satisfies

φ. Conceptually the translation proceeds in 3 stages:
Apply normalisation function N () to φ to create normalised temporal logic formula ψ.
Create a formula

[Mˆ ]
∧  [ψ]0
k−1
∨
lLk (Mˆ ) ∧ [ψ]0	(1)

k	k	l	k
l=0
that brings together the prefix case and loop case translations of ψ and cor-
respondingly checks that an unconstrained finite path is representing a prefix
.	 k−2 ˆ
case or a loop case path. Here [Mˆ ]k	Iˆ(V 0) ∧	T (V i,V i+1) gener-
ates a proposition for checking that a finite state sequence is a finite path
and lLk (Mˆ ) = Tˆ(V k−1,V l) is a constraint for specifying that a finite path
represents a (k, l) loop path.
Apply standard logic transformations so as to collect together common factors in the disjuncts of Formula (1) and ensure the formula’s size is linear in k.
The original translation of [2] consists of step 2 without steps 1 and 3. Even with careful optimisations, the size of the original translation is claimed in [7] to be cubic in the worst case. Our normalisation in step 1 enables the factoring for linear size in step 3.
We formally write our full translation as:

Full[Mˆ , φ]	.
ˆ  N (φ) ]

where the normalised-formula translation function Norm[Mˆ , ψ]k groups together steps 2 and 3. This translation function produces formulae of form ∃ z. q where z is a vector of propositional variables and q is a propositional logic formula. The function body() returns the body q of such formulae. This existential quantification ∃z arises because N () produces formulae in LTL extended with existential quantification. See Section 4 for a full definition of N () and Section 5 for a full definition of
Norm[Mˆ , ψ]k.
To state the correctness of our full translation, we introduce a reference semantics which combines the infinite and finite prefix-case semantics. A (k, l) loop path π satisﬁes at bound k an LTL formula φ if π satisfies it in the standard infinite semantics ( if π [φ ](0) holds). If π is not a (k, l) loop path for any l, then π satisﬁes at bound k a formula φ if the k-bounded prefix of π satisfies φ in the finite prefix

F
case semantics ( if π|k [[φ]]k (0) holds). A formula φ is existentially valid with bound k in Kripke structure M , written M |=k E φ, when some path π of M satifies φ at bound k. We can now state the overall correctness claim for our new translation as follows.
Theorem 3.1 (Correctness of new translation).  For any symbolic Kripke

structure Mˆ
with corresponding semantic structure M, any LTL formula φ and any

bound k > 0, we have that
M |=k E φ	⇔	Full[Mˆ , φ]k is satisﬁable
Formula normalisation
Overview
Normalisation proceeds in two main stages. Firstly the LTL operators F, G, Uand R in the input formula are all converted into forms involving greatest fixpoint operators. Section 4.3 handles how this is done with G and R, operators with natural greatest fixpoint characterisations and Section 4.4 handles the more subtle case of F and U which have natural least fixpoint characterisations. Secondly, as described in Section 4.5, each greatest fixpoint expression is converted into a form involving existential quantification at the outermost level of the formula. Section 4.5 also explains why least fixpoint characterisations cannot be handled. Normalisation also involves some renaming transforms on X in the input formula and on certain new formulae produced in the first normalisation stage. Section 4.6 covers renaming transforms in general. Finally Section 4.7 gives a self-contained summary of the normalisation function.
The interesting part of the proof of Theorem 3.1 involves showing the following two equations concerning normalisation:
π˙ ↑∞	π˙ F	∞
◦ [[φ]] = l [[N (φ)]] ↑◦	(2)
F	F
π˙ [[φ]]k = π˙ [[N (φ)]]k	(3)
where φ is any LTL formula and l ∈ {0 .. k−1}. Equation (2) states that the finite loop-case denotation of normalized formulae is equivalent to their standard infinite denotation. Equation (3) states that the prefix-case denotation is preserved by
normalisation. The subsections which follow include assertions of equalities which are intermediate steps in the proofs of Equation (2) and Equation (3).
We write φ ≡L ψ (φ ≡P ψ) when two formulae always have the same finite loop-case (prefix-case) denotation, and φ ≡F ψ when they always have the same denotation under both finite semantics.
Extending LTL with a greatest ﬁxpoint operator
We add to the syntax of LTL formulae timed variables α (also known as flexible variables), and greatest fixpoint expressions να. φ with infinite and finite semantics:



π[[α]]ρ	= ρ(α)	πF  ρ˙
= ρ˙(α)


π	ρ	ω π

ρ[α'→a]
l [[α]]k
F
π˙	ρ˙
F
k  π˙

ρ˙[α'→a˙ ]

[[λα.φ]]
= λa ∈ B
.  [[φ]]
l [[λα.φ]]k = λa˙ ∈ B .
l [[φ]]k

π[[να.φ]]ρ
`π[[λα.φ]]ρ´
π˙ F	ρ˙
`π˙ F
ρ˙ ´


where l ∈ {0 .. k−1}∪ {−}. Lambda abstractions λα.φ are examples of unary func- tion formulae. To provide meaning in the semantics for free variables, we extend the semantic functions with an environment argument ρ or ρ˙. An unbounded envi- ronment ρ maps each free variable to an infinite sequence in Bω and a k-bounded

environment
ρ˙ maps each free variable to a finite sequence in Bk. In the other

previously-defined clauses of the semantic functions, the environments are recur- sively propagated down unchanged.
The greatest fixpoint operator gfp is given the standard definition from the
Tarski-Knaster construction. Let F be a monotone function of type D → D on a
complete lattice ⟨D, ±⟩ with least upper bound operator H. We have that gfp(F ) .
H{x ∈ D|x ± F (x)} . In all our semantics D is of form R → B. In the infinite
semantics R = N and in both finite semantics R = {0 .. k−1}. The order relation ±
and least upper bound operation H are defined pointwise: x ± y  .  ∀i. x(i) ⇒ y(i)

and (H
. S)(i) =
∃x ∈ S. x(i) where lattice elements x, y ∈ R → B, set of elements

S ⊆ R → B and index i ∈ R.
Greatest ﬁxpoint characterisations for G and R
Fixpoint versions of the globally operator G and the release operator R are
˜	.	˜	.
G β = να. β ∧ X α	β R γ = να. γ ∧ (β ∨ X α)
Our following discussion focusses the G˜ operator. It extends very straightforwardly

to cover the R˜
operator too.

It is well known that the standard G is equivalent to this fixpoint version in the infinite semantics: G β ≡ G˜ β. It is straightforward to check that this equivalence also holds in the prefix semantics. For example, it is easy to show G β ≡P G˜ β once one observes that λα. β ∧ X α has a unique fixpoint in the prefix semantics when a binding for β is fixed. Indeed, if one adds least fixpoint operators μα. φ to LTL, one can also make the definitions
˜	.	˜	.
F β = μα. β ∨ X α	β U γ = μα. γ ∨ (β ∧ X α)
and show F β ≡P F˜ β and β U γ ≡P β U˜ γ. This provides some justification for the naturalness of the prefix-case semantics of the LTL operators.
In the proof of Equation (2), an appropriate stage of normalisation for shifting
to the finite semantics is after G˜ and R˜ have been introduced. With l ∈ {0 .. k−1}

and b˙ ∈ Bk, we have the following:
[[G˜ ]](b˙ ↑∞

  F ˜


˙  ↑∞

Greatest ﬁxpoint characterisations for F and U
As noted in the previous section, in the prefix case the fixpoint with operators F˜

and U˜
is unique, the least and greatest fixpoints are the same. For example, we

have that:
F˜ β  ≡P	να. β ∨ X α. The loop-case is not so simple. Consider the

loop-case semantics for F.
F
l [[F]]k (a˙)(i)= ∃j ∈ {min(i, l) .. k−1}. a˙(j)
The right-hand side here is equivalent to
(∃j ∈ {i .. k−1}. a˙(j)) ∨ (∃j ∈ {l .. k−1}. a˙(j))
Each disjunct here is an instance of the prefix semantics for F and, as above, we know we can switch to greatest fixpoints in the prefix semantics. We craft some definitions of new operators to take advantage of this observation.
Let us introduce variations XT and X⊥ on the next step operator that have non-looping semantics even in the loop case. Their finite semantics is

F T	.
ja˙ (i + 1) if i < k −1	F ⊥
. ja˙ (i + 1) if i < k −1

where l ∈ {0 .. k−1}∪ {−}. We use these in the definitions
F˜⊥ β	.	⊥	G˜ T	.	T

β U˜ ⊥
= να. β ∨ X  α
.	⊥
β = να. β ∧ X  α

γ = να. γ ∨ (β ∧ X  α)
These newly introduced fixpoint operators have the following semantic characteri- sations in both the prefix and the loop cases.
F˜⊥
l [[F ]]k (a˙ )(i)	= ∃j ∈ {i .. k −1}. a˙ (j)

F
l [[G
]]k (a˙ )(i)	= ∀j ∈ {i .. k −1}. a˙ (j)

F ˜⊥	˙	˙
l [[U ]]k (a˙ , b)(i) = ∃j ∈ {i .. k −1}. b(j) ∧ ∀n ∈ {i .. j −1}. a˙ (n)
To force consideration of the semantics of an operator at the loop start in the loop case, we introduce a unary LTL operator loopstart with semantics

F	.
l [[loopstart]]k (a˙ )(i) =
a˙ (l) if l ∈ {0 .. k −1}
⊥	if l = −

With these new operators at hand, we have the following identities allowing us to replace F and U with expressions involving greatest fixpoint operators.

F α	≡F
F˜⊥ α ∨ loopstart F˜⊥ α

α U β ≡F  α U˜ ⊥ β ∨ (G˜ T α ∧ loopstart(α U˜ ⊥ β))

The identity involving F can readily be derived using facts presented above. The main steps are:

F
π [[F˜⊥ α ∨ loopstart F˜⊥ α]]
F
F
(i) = π [[F˜⊥ α]]
F
(i) ∨ π [[F˜⊥ α]]
F
k (l)
F

= (∃j ∈ {i .. k −1}. π [[α]]k (j)) ∨ (∃j ∈ {l .. k −1}. π [[α]]k (j)) = π [[F α]]k (i)
l	l	l

These identities are also closely related to those discussed in Section 6.1.
Expressing greatest ﬁxpoints using existential operators
We focus on the cases of the two finite semantics since these are the cases we need. A similar discussion applies with the infinite semantics.
Let us augment our LTL syntax with existential quantification over timed vari- ables ∃α. φ and a globally from the start operator G0 which have finite semantics

π˙ F	ρ˙	.
F
k  π˙
ρ˙[α'→a˙ ]

l [[∃α. φ]]k (i)
F
= ∃a˙ ∈ B . l [[φ]]k	(i)
.

l [[G0]]k (a˙ )(i)
= ∀j ∈ {0 .. k −1}. a˙(j)

where 0 ≤ i < k, a˙ ∈ Bk and l ∈ {0 .. k−1}∪ {−}. Note that the globally-from-the- start operator G0 always quantifies over the full time range, no matter what index i we consider its value at, even in the prefix case.
Using these definitions we can phrase an identity for eliminating greatest fixpoint expressions occurring in contexts, buried under other operators:
Ψ[να. φ] ≡F ∃α. G0 (α ⇒ φ) ∧ Ψ[α]
where context expression Ψ is a unary function formula with monotone denotation, and the notation ·[·] is the application operator for such functions.
The existential quantification derives from the least-upper-bound operator in the
definition of the gfp operator, and semantics of the formula G0 (α ⇒ φ) captures the x ± F (x) constraint in the definition body (see Section 4.2).
The corresponding identity for an lfp (least-fixpoint) operator involves a univer-
sal quantification derived from the greatest-lower-bound operator in the lfp operator definition. Since our goal is to eventually produce satisfiability problems, we cannot make use of this identity.
Renamings
An LTL formula in some context is renamed if it replaced by a new timed variable which is asserted equivalent to it. When contexts are monotone, it is sufficient to assert an implicational relationship between the new variable and the renamed formula. We have that
Ψ[φ] ≡F ∃α. G0 (α ⇒ φ) ∧ Ψ[α] where Ψ is a monotone unary function formula.
In some cases, the formula to be replaced is time invariant : it has denotation ⊥k or Tk. In these cases, it is sufficient to replace it by an untimed variable (sometimes called a rigid variable) and use existential quantification over untimed variables. Let us add untimed variables x to the LTL syntax and existential quantification over them ∃x. φ with semantics:

π˙ F ρ˙
π˙ F	ρ˙
π˙ F ρ˙[x'→a0]

l [[x]]k (i) =
ρ˙(x)
l [[∃x. φ]]k (i) = ∃a0 ∈ B.
l [[φ]]k	(i)

where 0 ≤ i < k, a˙
∈ Bk and l ∈ {0 .. k−1}∪ {−}, and we extend the notion of

environment ρ˙ to provide Boolean-valued bindings for untimed variables. We then
have:
Ψ[φ] ≡F ∃x. (x ⇒ φ) ∧ Ψ[x]
where Ψ is a monotone unary function formula and φ a time invariant formula.

The normalisation function
We assemble here the results from the previous subsections into a single overall definition of the normalisation function N (). Assume that formulae to start are in negation normal form. N () applies the following transformation rules:
Ψ[G f ]	−→ ∃α. Ψ[α] ∧ G0 (α ⇒ f ∧ X α)
Ψ[f R g] −→ ∃α. Ψ[α] ∧ G0 (α ⇒ g ∧ (f ∨ X α)) Ψ[X f ]	−→ ∃α. Ψ[α] ∧ G0 (α ⇒ X f )
Ψ[F f ]	−→ ∃α, x. Ψ[α ∨ x] ∧ G0 (α ⇒ f ∨ X⊥ α) ∧ (x ⇒ loopstart α)
Ψ[f U g] −→ ∃α, β, x. Ψ[α ∨ (β ∧ x)] ∧ G0 (α ⇒ g ∨ (f ∧ X⊥ α))
∧ G0 (β ⇒ f ∧ XT β) ∧ (x ⇒ loopstart α)

These rules are applied in a single bottom-up pass over the initial formula. To sug- gest this bottom-up direction, the subformulae f and g are required to be propo- sitional, free from temporal operators. Rules are not applied to any of the new generated structure, for example, new X s. Usual assumptions are made about variables bound by the existential quantifiers being suitably renamed to avoid any unintentional capture of variables. An example of applying the normalisation func- tion is
FG ¬p −→ ∃α. F α ∧ G0 (α ⇒ ¬p ∧ X α)	by G rule
−→ ∃α, β, x. (β ∨ x) ∧ G0 (β ⇒ α ∨ X⊥ β)

∧ (x ⇒ loopstart β) ∧ G0 (α ⇒ ¬p ∧ X α)	by F rule
where, in the intermediate expression, we have underlined the partially reduced input formula that is about to be transformed by a second rule, and, in the final expression, the propositional residue of the input formula.
The resulting formulae have normal form
∃α, x. R ∧ LS ∧ G0 (X ∧ X∗)
where α is a vector of timed variables, x is a vector of untimed variables, R is the residual top-level propositional structure of the initial formula, LS is a conjunction of formulae of form x ⇒ loopstart α, X is a conjunction of formulae of form α ⇒ f [X g] where context f and formula g are propositional, and X∗ is a conjunction of formulae of form α ⇒ f [XT g] and α ⇒ f [X⊥ g] where again context f and formula g are propositional.
The function N (φ) can be computed in time linear in the size φ.

Translation of normalised formulae
The loop-case and prefix-case translation functions over the syntax of the compo- nents R, LS, X and X∗ of our normalised formulae are as follows:

[α]i
= αi
[v]i
= vi
[φ ∧ ψ]i
= [φ]i ∧ [ψ]i

l	k	l	k	l	k	l	k	l	k

[x]i = x
[¬φ]i = ¬ [φ]i
[φ ∨ ψ]i = [φ]i ∨ [ψ]i

l	k


8> [φ]i+1
l	k	l	k


if i < k −1
l	k	l	k	l	k



(
		


>: [φ]l
if i = k −1
T	if i = k −1

l	k	and l ∈ {0 .. k −1}
i	( [φ]i+1
if i < k −1


[loopstart φ]i
= (⊥	if l = −
l	k	⊥	if i = k −1

l	k	[φ]l
if l ∈ {0 .. k −1}

where l ∈ {0 .. k−1} for the loop case and l = − for the prefix case. The translation function for formulae ψ in the normal form described at the end of the last section is:

Norm[Mˆ , ψ]	.
ˆ	∧ [R]0 ∧ Vk−2 [X]i  ∧ Vk−1 [X∗]i ∧

` ([LS]0 ∧ [X]k−1) ∨ Wk−1 ( L (Mˆ ) ∧ [LS]0 ∧ [X]k−1) ´
where [Mˆ ]k and lLk (Mˆ ) are as defined in Section 3 and the vector of propositional variables z contains variables α0,... , αk−1 for each timed variable α in α and a variable x for each untimed variable x in x. The resulting formula has size linear in k, |φ| and |Mˆ |. More precisely, its size is O(|Iˆ| + k · (|φ| + |Tˆ|)).

Related work
Helsinki work
The BMC translations closest to ours are those of [7] and [6]. These translations are also linear in k and they exploit fixpoint characterisations of operators. A core observation in [7] from the viewpoint of this paper is that the loop-case denotations of the LTL operators F, G, U and R are all equivalent to the restriction to bound k of the denotation of non-looping versions of the operators at bound k + (k − l)−1.
For example:

F	 F ˜T
k+(k−l)−1 

l [[G]]k (a˙) =	l [[G ]]k (a˙↑◦	) |k
k	k' .	∞	'
where a˙ ∈ B , l ∈ {0..k−1}, a˙↑◦ = a˙ ↑◦ |k' unrolls a loop denotation to bound k and
G˜ T is as defined in Section 4.4. The justification in [7] for these identities is rather indirect and involves appealing to arguments about fixpoints in CTL. However, we note that we can prove them straightforwardly using some of the same insights as are necessary to prove the identity


π˙ ↑∞
[[φ]] =
F
π˙ [[φ]]k ∞

introduced in Section 2.4 which is at the heart of the justification of the original bounded model checking translation of [2].
A major apparent difference is that the approach in [7] introduces very few auxiliary variables by encoding to reduced Boolean circuits (RBCs), a DAG rep- resentation of Boolean formulae. However, when these circuits are subsequently translated into CNF, auxiliary variables are introduced for many of the internal nodes of the circuits, and we guess that one gets roughly one new auxiliary variable per fixpoint step, the same as what we use.
Comparing the sizes of resulting propositional formulae in the approach of [7] to ours, we observe that our encoding for G and R involves unrolling the fixpoint functions for k rather than 2k steps, and so involves introducing about half the number of ∧s and ∨s. For F and U the number of ∧s and ∨s introduced appears
to be more similar, though for F we introduce roughly half the number of auxiliary
variables into the final CNF formulae.
The approach of more recent work [6] from the same group is more similar to an automata-based approach in that the fixpoint constraints on auxiliary variables in the loop case also have a loop shape. Ignoring the incremental and past-time aspects of [6], the numbers of operators and auxiliary variables introduced seem to be slightly closer to those with our approach.
Experimentation and more detailed analysis are needed to sharpen the above preliminary remarks and importantly to compare how the approaches affect SAT run times.

Other work
The BMC journal paper [1] gives a translation exploiting fixpoint characterisations, though the encoding size is not linear in the bound. As written, the translation is not sound: it appears to be using a greatest fixpoint characterisation for all the LTL operators which is clearly unsound for F and U. We speculate that this mistake could have been avoided if the translation had been derived within a formal framework such as presented in this paper.
We observe that a recent NuSMV release (V2.3.1, Nov 2005) seems to use a similar translation that is sound. This translation has some similarities to that of
[7] discussed above in Section 6.1 in that the loop case translation is calculated using non-looping fixpoint constraints.

Conclusions
We have presented a translation for future time LTL bounded model checking that is linear in the bound k and more compact than competing translations, in particular that of [7].
We have also presented a rigorous framework for analysing translations. Both the body of the paper and the discussion of related work show the usefulness of the framework, and it is expected that it will be of significant use in exploring future

variations on and extensions to BMC translations.

References
Biere, A., A. Cimatti, E. M. Clarke, O. Strichman and Y. Zhu, Bounded model checking, Advances in Computers 58 (2003).
Biere, A., A. Cimatti, E. M. Clarke and Y. Zhu, Symbolic model checking without BDDs, in:
W. Cleaveland, editor, Tools and Algorithms for the Construction and Analysis of Systems. 5th International Conference, TACAS 99, Lecture Notes in Computer Science 1579 (1999), pp. 193–207.
Cimatti, A., M. Roveri and D. Sheridan, Bounded verification of past LTL, in: A. J. Hu and A. K. Martin, editors, Proceedings of the 5th International Conference on Formal Methods in Computer Aided Design (FMCAD 2004), Lecture Notes in Computer Science (2004).
Fisher, M., A resolution method for temporal logic, in: Proceedings of the 12th International Joint Conference on Artificial Intelligence (IJCAI) (1991).
Frisch, A., D. Sheridan and T. Walsh, A fixpoint based encoding for bounded model checking, in: M. D. Aagaard and J. W. O’Leary, editors, Formal Methods in Computer-Aided Design; 4th International Conference, FMCAD 2002, Lecture Notes in Computer Science 2517 (2002), pp. 238–254.
Heljanko, K., T. Junttila and T. Latvala, Incremental and complete bounded model checkinfg for full pltl, in: K. Etessami and S. K. Rajamani, editors, Computer Aided Verification: 17th International Conference, CAV 2005, Lecture Notes in Computer Science 3576 (2005), pp. 98–111.
Latvala, T., A. Biere, K. Heljanko and T. Junttila, Simple bounded LTL model checking, in: Formal Methods in Computer-Aided Design; 5th International Conference, FMCAD 2004, Lecture Notes in Computer Science 3312 (2004), pp. 186–200.
Sheridan, D., Bounded model checking with SNF, alternating automata and Bu¨chi automata, in: Second International Workshop on Bounded Model Checking, Electronic Notes in Theoretical Computer Science (2004).
