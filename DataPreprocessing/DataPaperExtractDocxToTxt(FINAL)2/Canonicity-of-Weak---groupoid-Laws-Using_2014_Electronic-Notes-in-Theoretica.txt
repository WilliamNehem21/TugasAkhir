Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 308 (2014) 229–244
www.elsevier.com/locate/entcs

Canonicity of Weak ω-groupoid Laws Using Parametricity Theory
Marc Lasson
INRIA Paris-Rocquencourt, PiR2, Univ Paris Diderot, Sorbonne Paris Cité F-78153 Le Chesnay France

Abstract
We show that terms witnessing a groupoid law from the ω-groupoid structure of types are all propositionally equal. Our proof reduce this problem to the unicity of the canonical point in the n-th loop space and conclude using Bernardy’s parametricity theory for dependent types.
Keywords: type theory, parametricity, loop spaces, groupoids, identity types


Introduction
The synthetic approach to weak ω-groupoids promoted by the univalent foundation program [8] is the idea that (homotopy) type theory should be the primitive language in which spaces, points, paths, homotopies are derived. Following this approach, spaces are represented by types, points by inhabitants and paths by equalities be- tween points (also known as identity types) and algebraic properties of these objects should not be enforced a priori (for instance by axioms) but should be derived di- rectly from the language. To justify the synthetic approach, one should prove the canonicity of each definition, in the sense that no important choice should be made by choosing a particular implementation of a definition over another.
Garner, van den Berg [9] and Lumsdsaine [5] independently showed that in type theory, each type can be equipped with a structure of weak ω-groupoids. For this, they show that a minimal fragment of Martin-Löf type theory, where identity types are the only allowed type constructors, bears a weak ω-category structure. In- formally, these results state the possibility to express algebraic properties of weak ω-groupoids as types and in each case to find a canonical inhabitant of these types reflecting the fact that the property holds. Identities, inversion and concatenation of

1 Email: marc.lasson@inria.fr

http://dx.doi.org/10.1016/j.entcs.2014.10.013
1571-0661/© 2014 Elsevier B.V. All rights reserved.

path, associativities, involution of inversion, horizontal and vertical compositions of 2-paths, are all examples of groupoid laws. The canonicity of witnesses of groupoid laws here means there is a path between any two inhabitants of the law witnessing their equality, but also that this path should be canonical: there should be a path between any two paths between two inhabitants of the same law, and so on ... This canonicity is already a known fact within the fragment. The main result of this article is to extend the canonicity to the whole Martin-Löf type theory.
In this work, we follow a syntactic approach inspired by Brunerie [3] to formalize the notion of groupoid law. We call groupoid law any closed type ∀Γ.c such that the sequent Γ ▶ c : Type is derivable in the minimal fragment and such that the context Γ is contractible. A contractible context is a context of the following shape: A : Type,a : A, x1 : C1, y1 : M1 = x1,..., xn : Cn, yn : Mn = xn where xi does not occur in Mi. The shape of these contexts is stable by path-induction, which allows to find an inhabitant of any groupoid law by successive path inductions. We show that this inhabitant is canonical, even outside of the fragment.
The main idea of the proof is to use successive path inductions to reduce the problem of the uniqueness of inhabitants of a given groupoid law to the uniqueness of the canonical point inhabiting a parametric loop space. Given a base type A and a point a : A, the n-th loop space and its canonical point are inductively defined by:


Ω0(A, a) := A
Ωn+1(A, a) := Ωn(a = a, 1a)
ω0(A, a) := a
ωn+1(A, a) := ωn(a = a, 1a)

where 1a : a = a denotes the reflexivity. Thus for any integer n, ∀X : Type,x : X.Ωn(X, x) is a groupoid law inhabited by λX : Type,x : X.ωn(X, x) (note that using one universe, it is possible to internalize the quantification over n; everything that we state here will be true whether or not this is used). We call this groupoid law the n-th parametric loop space.
The 0-th parametric loop space, is the polymorphic type ∀X : Type.X → X of identity functions, and its canonical inhabitant is λX : Type,x : X.x, ie. the identity function. This term is the only one up to function extensionality inhabiting its type. The standard tool to prove this kind of properties is by using Reynold’s parametricity theory [7] which was introduced to study the behavior of type quan- tifications within polymorphic λ-calculus (a.k.a. System F). It refers to the concept that well-typed programs cannot inspect types; they must behave uniformly with respect to abstract types. Reynolds formalizes this notion by showing that poly- morphic programs satisfy the so-called logical relations defined by induction on the structure of types. This tool has been extended by Bernardy et al. [2] to depen- dent type systems. It provides a uniform translation of terms, types and contexts preserving typing (the so-called abstraction theorem). In its unary version, the only needed for this work, logical relations are defined by associating to any well-formed type A : Type a predicate JA) : A → Type and to any inhabitant M : A a witness JM ) : JA) M that the M satisfies the predicate. This translation may be extended to cope with identity types by setting Ja = b) : a = b → Type to be the predicate λp : a = b.p∗(Ja)) = Jb) where p∗ is the transport along p of the predicate gener-

ated by the common type of a and b. Then, it is easy -although quite verbose- to find a translation of introduction and elimination rules of identity types as well as checking that these translations preserve computation rules. This allows to extend Bernardy’s abstraction theorem to identity types. Using this framework, we are able to generalize the uniqueness property of the polymorphic identity type to any parametric loop space. The proof proceed by induction on the index of the loop space and uses algebraic properties of transport.

Outline of the paper.
In Section 2, we introduce the type theoretical setting that is used in the article. Section 3 is devoted to the proof that Bernardy’s parametricity may be extended to cope with identity types. In Section 4, we use this translation to prove the canonicity result for loop spaces; we prove that all inhabitants of parametric loop spaces are propositionally equal (Theorem 4.3). In Section 5, we introduce the fragment MLID of type theory to define our notion of groupoid laws and we show that the result of Section 4 may be generalized to all groupoid laws (Theorem 5.6). Finally Section 6 is devoted to various discussions.

Presentation of the syntax
We give a presentation of Martin-Löf type theory with identity types and universes which is close to the syntax of pure type systems [1] in order to reuse the para- metricity theory presented in [2]. In this framework, computation rules are treated in an untyped way and subtyping of universes is achieved using Luo’s cumulativity relation introduced for the extended calculus of constructions [6]. The reader may be more used to judgemental presentations of type theory where each computation steps are checked to be well-typed. This is just a matter of presentation; all the material presented here could be adapted without much effort to suit type systems using a judgemental equality. Also, the use of cumulativity is not really needed but makes our results more general and closer to implementations such as coq.
The terms of the system are given by the following grammar:
A, B, C, M, N, U, V :=	x	|	(M N )	|	λx : A.M	|	∀x : A.B	|	Typei

|	M =A N	|	1C
|	J∀x:C,y:M =x.A(B, U, V )

where universes Typei are indexed by i ∈ N. Variables are considered up to α- conversion and we write M [N/x] to denote the term obtained by substituting all free occurrences of x in M by N . To ease the reading of terms, we allow ourselves to omit some typing annotations when they could be guessed from the context (in particular M = N , 1M and J(B, U, V ) will be used often in this text).
The grammar of terms is obtained by adding to the syntax of pure type systems:
The type constructor M =A N for forming identity types,
The introduction rule for identity types, 1C , to witness the reflexivity M =C M ,

The elimination rule (also known as “path-induction”) J6x:C,y:M=x.A(B, U, V ). Given any dependent type A(x, y) which depends on a point x and a path y from a base point M to x, given a witness for A(M, 1M ) (the base case of the induction), given a point U and a path V , the path-induction provides an in- habitant of A(U, V ). This formulation of path-induction, due to Paulin-Möhring (also called based path induction), is equivalent to the other version where A is parametrized by two points and a path between them.
We use the symbol ≡ to denote the syntactic equality (up to α-conversion) between terms. The conversion between terms will be denoted by M ≡β N , it is de- fined as the smallest congruence containing the usual β-reduction (λx : A.M ) N ≡β M [N/x] and the computation rule for identity types: J6x:c,y:M=x,Δ.P (N, M, 1C ) ≡β
N . And the cumulativity order is defined as the smallest partial order “ compatible with ≡β and satisfying for i ≤ j:
∀x1 : A1, ..., xn : An.Typei “ ∀x1 : A1, ..., xn : An.Typej

Like in the extended calculus of constructions, the cumulativity rule is not fully contravariant with respect to the domain of functions (Aj “ A and B “ Bj does not imply ∀x : A.B “ ∀x : Aj.Bj) otherwise it would break the decidability of type checking. Contexts are finite lists of the form x1 : A1, ··· , xn : An mapping a variable to its type. The rules of the type system are given in Figure 1. As we follow standard lines, we do not develop in details the metatheory of the system.
The non-dependent version of path-induction is called transport and is defined
by
P∗x:C.X (M ) ≡ J6x:C,y:U =x.X (M, V, P )
where y does not occur in X. It is often used to coerce between type families: given a type family X : C → Typei, a path P : U = V between two points U, V : C, and a term M in X U , the transport P∗x:C.X (M ) of M along P inhabits X V . It satisfies the following derivable rule :
Γ,x : C ▶ X : Typej	Γ ▶ P : U =C V	Γ ▶ M : X[U/x] Γ ▶ P∗x:C.X (M ): X[V/x]
transport
We sometimes also omit the type family when it can be guessed from the context. The computation rule tells us that transporting along a reflexivity is same as doing nothing : 1U ∗(M ) ≡β M .

Extending Relational Parametricity to Identity types
In this section, we explain how to extend Bernardy’s parametricity translation be- low to primitive identity types. Then we prove that this extension preserves typ- ing (Theorem 3.2). Here is the definition of the translation for the syntax of pure





⟨⟩ wf
wf-empty
Γ wf	Γ ▶ B : Typei Γ,x : B wf
wf

	Γ wf	 Γ ▶ Typei : Typei+1 univ
Γ wf	(x : A) ∈ Γ Γ ▶ x : A
variables

Γ,x : A ▶ M : B
Γ ▶ λx : A.M : ∀x : A.B
abstraction
Γ ▶ M : Aj	Γ ▶ A : Typei
 Γ ▶ M : ∀x : A.B	Γ ▶ N : A Γ ▶ (M N ): B[N/x]
application
Γ ▶ A : Typei	Γ,x : A ▶ B : Typei

Γ ▶ M : A
conversion
Aj “ A


Γ ▶ ∀x : A.B : Typei
product

Γ ▶ M : C	Γ ▶ N : C	Γ ▶ C : Typei		Γ ▶ M : C	

Γ ▶ M =C N : Typei
Γ ▶ 1C
: M =C M

identity	reflexivity


Γ ▶ M : C
Γ,x : C, y : M = x ▶ P : Typei	Γ ▶ B : P [M/x, 1C /y]
Γ ▶ J6x:C,y:M=x.P (B, U, V ): P [U/x, V/y]
path-induction
Fig. 1. Type theory with identity types (MLTT).
Γ ▶ U : C
Γ ▶ V : M = U

type systems:
J∀x : A.B) ≡ λf : ∀x : A.B.∀x : A, xR : x ∈ JA).(f x) ∈ JB) JTypei) ≡ λx : Typei.x → Typei
Jλx : A.M ) ≡ λx : A, xR : x ∈ JA).JM )
JM N ) ≡ JM ) N JN )
Jx) ≡ xR
where M ∈ JA) simply stands as a notation for JA) M (it makes formulas a bit easier to read). As said in the introduction, the predicate generated by an identity type M =C N is defined by the type family over M =C N selecting paths transporting JM ) to JN ):
JM =C N ) : M =C N → Type
JM =C N ) ≡ λp : M =C N.p∗x:C.x∈JC) (JM )) =JC) N JN )
Thanks to the computational rule
C ∈ JM =C M ) ≡β 1C  x:c.x∈JC) (JM )) =M∈JC) JM ) ≡β JM ) =M∈JC) JM )
the translation J1C ) : 1C  ∈ JM =C M ) of reflexivity is a reflexivity: J1C ) ≡
M	M	M
1M∈JC). And finally, the elimination rule is translated in terms of nested path-

inductions:
JJ6x:C,y:M =x.P (B, U, V )) ≡
J6xR:U∈JC),yR:V∗(JM ))=xR.J∀x:C,y:M=x.P (B,U,V )∈JP )[U/x,V/y]
(J6x:C,y:M =x.J∀x:C,y:M=x.P (B,x,y)∈JP )[y∗(JM ))/xR,1	/yR](JB), U,V ), JU ), JV ))

The translation of the predicate of path inductions are quite verbose and make the translation hard to read. However if we ignore the annotation, we see that the translation JJ(B, U, V )) ≡ J(J(JB), U,V ), JU ), JV )) is simply a duplication of path induction which should be compared to the duplication in abstractions and applica- tions. We can check that this translation behaves well with respect to substitution and conversion :
Lemma 3.1 (Substitution and conversion lemma) We have :
JM [N/x]) ≡ JM )[N/x, JN )/xR],
If M ≡β Mj, then JM ) ≡β JMj).
If M “ Mj, then JM ) “ JMj).
Proof. The proof of (i) is a routine proof by induction on M . And (iii) is a rather direct consequence of (ii). To prove (ii), we only do here the only check that is not in Bernardy’s translation :
JJ(N, M, 1C )) ≡ J(J(JN ), M, 1C ), JM ), J1C ))
M	M	M
≡ J(J(JN ), M, 1C ), JM ), 1M∈JC))

M
≡β J(JN ), JM ), 1M∈JC)))
JM )

≡β JN )
2
Now we can check that this extension preserve typing :
Theorem 3.2 (Abstraction) If Γ ▶ M : A, then
JΓ) ▶ M : A	(a)
JΓ) ▶ JM ) : M ∈ JA)	(b)
moreover if Γ wf then JΓ) wf (c).
Proof. The abstraction theorem is proved by induction on derivations. In each cases, proving the statement (a) is straightforward. Since the treatment of other rules is now standard, we only deal here with the rules concerning identity types. Even though we do not detailed it here, the treatment of conversion uses previous lemma.
identity: The induction hypothesis gives us JΓ) ▶ JM ) : M ∈ JC) (1), JΓ) ▶
JN ) : N ∈ JC) (2) and JΓ),x : C ▶ x ∈ JC) : Typei (3). Using transport we

derive from (1) and (3), that JΓ),p : M =C N ▶ p∗λx:C.x∈C (JM )) : N ∈ JC).

Then, using
identity
and (2) we build a derivation for JΓ),p : M =C N ▶

p∗λx:C.x∈C (JM )) =N∈JC) JN ) and finally we conclude JΓ) ▶ JM =C N ) : M =C
N → Typei with abstraction.
reflexivity: By induction hypothesis, we have JΓ) ▶ JM ) : M ∈ JC) (1). Using

(1) we can check that JΓ) ▶ 1M∈JC) : JM ) =
JM ) which is convertible to

JM )
M∈JC)

JΓ) ▶ 1M∈JC) : 1C  (JM )) =M∈JC) JM ). So, we conclude JΓ) ▶ J1C ) : 1C
∈ JC).

JM )	M ∗	M	M
path-induction: The induction hypothesis for (b) are :
JΓ) ▶ JM ) : M ∈ JC)	(1)	JΓ,x : C, y : M = x) ▶ JP ) : P → Typei	(2)
JΓ) ▶ JB) : B ∈ JP [M/x, 1C /y])	(3)	JΓ) ▶ JU ) : U ∈ JC)	(4)
JΓ) ▶ JV ) : V ∈ JM = U )	(5)
and the induction hypothesis for (a) are :
JΓ) ▶ M : C	(6)	JΓ,x : C, y : M = x) ▶ P : Typei	(7)
JΓ) ▶ B : P [M/x, 1C /y]	(8)	JΓ) ▶ U : C	(9)
JΓ) ▶ V : M = U	(10)
Let T be the following term :
J6x:C,y:M =x.J(B,x,y)∈JP )[y  (JM ))/x  ,1	/y ](JB), U,V )
y∗ (JM ))

First, we have to typecheck T by showing that
JΓ) ▶ T : J(B, U, V ) ∈ JP )[y∗(JM ))/xR, 1y∗ (JM ))/yR, U/x,V/y]	(∗)
which means, using path-induction, checking :
· The predicate is well-formed :
JΓ),x : C, y : M = x ▶ J(B, x, y) ∈ JP )[y∗(JM ))/xR, 1y∗ (JM ))/yR]: Type
This is obtained by substituting xR and yR in (2) using a derivation of
JΓ),x : C, y : M = x ▶ y∗(JM )): x ∈ JC)

and of JΓ),x : C, y : M = x ▶ 1y∗ (JM )) : y∗(JM )) = y∗(JM )) which are easily derived from (1) and by applying JΓ),x : C, y : M = x ▶ J(B, x, y) : P to the substituted derivation.
· The arguments are correct : We derive
JΓ) ▶ JB) : J(B, M, 1M ) ∈ JP )[y∗(JM ))/xR, 1y∗ (JM ))/yR, M/x, 1M /y]

by noticing using computation rules that :
J(B, M, 1M ) ∈ JP )[y∗(JM ))/xR, 1y∗ (JM ))/yR, M/x, 1M /y]
≡β B ∈ JP )[M/x, JM )/xR, 1M /y, 1y∗ (JM ))/yR]
and therefore conversion and (3) allow us to conclude. Finally, we have to check that target point and path are correct ie. JΓ) ▶ U : C and JΓ) ▶ V : M = U which are given by (9) and (10).
Let K be the following term:
J6xR:U∈JC),yR:V∗(JM ))=xR.J∀x:C,y:M=x.P (B,U,V )∈JP )[U/x,V/y](T, JU ), JV ))
We now want to check that : JΓ) ▶ K : J6x:C,y:M=x.P (B, U, V ) ∈ JP [U/x, V/y])
using path-induction, we have to show that :
· The predicate is well-formed :
JΓ), xR : U ∈ JC), yR : V∗(JM ))= xR ▶
J6x:C,y:M=x.P (B, U, V ) ∈ JP )[U/x, V/y]: Typei
which is obtained by substituting x and y in (2) using (9) and (10) and by ap- plying JΓ) ▶ J6x:C,y:M=x.P (B, U, V ): P [U/x, V/y] to the substituted derivation.
· The arguments are correct : We use (*) for type checking T and we use (4) and
(5) for type checking JU ) and JV ).
2

Canonicity in parametric loop spaces
The goal of this section is to prove Theorem 4.3. The following lemma is needed to perform the main induction in Lemma 4.2. The proofs terms are described in a semi-formal style for reading purpose, they could be easily constructed from the prose. However, as a consequence of Thereom 4.3, the precise shape of these terms is not important. In this section, we use p . q and p−1 to denote respectively the concatenation of paths and the inverse.
Lemma 4.1 Let P : A → Type be a type family and u : P a for some a : A and assume we have φ : ∀x : A.P x → a = x. Then, for all p : a = a such that p∗(u)= u, we have 1= p.
Proof. By applying the functorial action of path on p∗(u)= u using φa we obtain a two dimensional path φa(p∗(u)) = φa(u) and by the naturality of transport (Lemma 2.3.11 in [8]), we obtain a path p∗(φa(u)) = φa(u). The left-hand side path p∗(φa(u)) is transport over an identity type, we therefore have p∗(φa(u)) = φa(u) . p and therefore φa(u) . p = φa(u). So, we conclude 1 = p by cancelling by φa(u) and by symmetry.	2
Here is the main induction which allows us to derive Theorem 4.3:

Lemma 4.2 Let A, P, a, u and φ defined as in previous lemma. Then for all n- dimensional loop p : Ωn(A, a), the type family JΩn)(A, P, a, u) : Ωn(A, a) → Type satisfies : ∀p : Ωn(A, a).JΩn)(A, P, a, u) p → ωn(A, a)= p.
Proof. By induction on n, the base case is exactly witness by φ. For the inductive step, we need to prove ∀p : Ωn+1(A, a).p ∈ JΩn+1)(A, P, a, u) → ωn+1(A, a) = p which is convertible to :
∀p : Ωn(a = a, 1).p ∈ JΩn)(a = a, λq : a = a.q∗(u)= u, 1, 1) → ωn(a = a, 1) = p
We may therefore apply the induction hypothesis by providing a proof that ∀q : a =
a.q∗(u)= u → 1= q which is given by previous lemma.	2
We can deduce :
Theorem 4.3 (Canonicity for loop spaces) If ▶ M : ∀A : Type,a : A.Ωn(A, a)
then there is a term π such that ▶ π : ∀A : Type,a : A.ωn(A, a)= M A a.
Proof. The abstraction theorem gives us a proof JM ) that ∀A : Type, AR : A →
Type,a : A, aR : AR a.(M A a) ∈ JΩn)(A, AR, a, ar) by instantiating AR with λx :
A.a = x we can conclude by applying previous lemma.	2
Note that as a corollary, the proof π is unique up to propositional equality (and so on). If we have two such proofs π and πj then (πA a).(πj A a)—1 is of type ωn(A, a)= ωn(A, a) which is Ωn+1(A, a). Therefore, by applying the previous theorem we obtain a proof of (πA a).(πj A a)—1 = ωn+1(A, a) which is also (πA a).(πj A a)—1 = 1ω (A,a).
Therefore we conclude (πA a)= (πj A a).

Groupoid laws
In this section, we start by describing a fragment MLID of the previous type sys- tem MLTT. This sub-system is used to characterise groupoid laws. Informally, it is obtained from MLTT by removing the rules abstraction, application and uni- verses and by restricting valid sequents to the contractible contexts defined in the introduction. In the absence of function spaces, the rule path-induction has to be strengthened in order to be able to make a path induction along a path which is not the last one of the context. Therefore, we need to extend the grammar of terms

in MLID with terms of the shape J
−→
6x:C,y:M =x,Δ.P (B, U, V, W )
where Δ is a context

and where the vectorial notation −→ denotes a tuple (W , ..., W
) of terms.

The typing rules are given in Figure 2. Formally a context Γ is said to be con- tractible if Γ contr is derivable; the reader should notice that all contexts occurring

in derivations of MLID are contractible. In the typing rules, we write
−→
Γ ▶ W : Δ 

to denote the conjunction for k = 1, ··· ,n of Γ ▶ Wk[A1/y1, ··· , Ak—1/yk—1] : Ak
when Δ is of the shape y : A , ··· ,y  : A . Moreover, −→	denotes the iterated

1	1	n	n
[W /Δ]

substitution [W1/y1, ··· , Wn[A1/y1, ··· , An—1/yn—1]/yn].



A : Type0,x : A contr
init
Γ contr	Γ ▶id B : Type0	Γ ▶id M : B


Γ,x : B, p : M =B x contr
contr

Γ ▶id M : C	Γ ▶id N : C	Γ ▶id C : Type0
	Γ ▶id M : C	

Γ ▶id M =C N : Type0
Γ ▶id 1C
: M =C M

identity	reflexivity

Γ contr	(x : A) ∈ Γ
Γ ▶id M : Aj	Γ ▶id Aj : Type0	j

Γ ▶id x : A
Γ ▶id M : A
A ≡β A

variable

Γ ▶id M : C
conversion

Γ ▶id U : C

Γ,x : C, y : M = x, Δ ▶id P : Type0
Γ ▶id V : M = U

Γ, Δ[M/x, 1C /y] ▶
B : P [M/x, 1C /y]	−→

M	id
M	Γ ▶id W :Δ 
−→	−→

Γ ▶id J6x:C,y:M=x,Δ.P (B, U, V, W ): P [U/x, V/y, W /Δ]
extended-path-induction
Fig. 2. The minimal fragment MLID of type theory with identity types.
In order to embed MLID into MLTT, we translate extended path inductions into normal ones according to the following translation :
−→
J6x:C,y:M =x,Δ.P (B, U, V, W ) ≡
λ−→x : Δ.(J6x:C,y:M=x.6Δ.P (λx : Δ[M/x, 1C /y].B, U, V ) −→x )
where −→y  : Δ means that y1, ··· , yn are the variables assigned in Δ, and where
∀Δ, λΔ, and (J −→x ) denote respectively iterated products, abstractions and appli-
cations. It is then straightforward to check that extended-path-induction is an admissible rule of MLTT.
Groupoid laws are characterized by a contractible context and a derivable type in MLID (Figure 3 contains some examples of groupoid laws):
Definition 5.1 [Groupoid law] A groupoid law is a term of the shape ∀Γ.C such that Γ ▶id C : Type0.
The only groupoid laws in the “initial” contractible context A : Type,a : A are loop spaces. Since we do not change the base type and the base point of loop spaces in this section we simply denote by ωn (resp. Ωn) the terms ωn(A, a) (resp. Ωn(A, a)). Using these notations we have :
Lemma 5.2 If A : Type,a : A ▶id T : Type0, then
there exists |T|∈ N such that T ≡β Ω|T |,
moreover, if A : Type,a : A ▶id W : T then W ≡β ω|T |.
Proof. We proceed by induction on the derivation of A : Type,a : A ▶id T : Type0. We notice that the only two possible last used rules are identity and variable

refl : 6X : Type,x : X.x = x	sym : 6X : Type,x : X.x = y → y = x
concat : 6X : Type,x : X, y : X.x = y → 6z : X.y = z → x = z
assoc : 6X : Type,x : X, y : X, p : x = y, z : X, q : y = z, t : X, r : z = t.
concat X x z (concat X x y p z q) tr = concat X x y p t (concat X y z q t r)
neutral : 6X : Type,x : X, y : X, p : x = y.(concat X x y p y (refl X y)) = p
idem : 6X : Type,x : X, y : X, p : x = y.sym X y x (sym X x y p)= p
horizontal : 6X : Type,x : X, y : X, p : x = y, p′ : x = y.p = p′ →
6z : X, q : x = z, q′ : x = z.q = q′ → concat X x y p z q = concat X x y p′ z q′


Fig. 3. Examples of groupoid laws with aliases for canonical inhabitants


since Type0 does not inhabit Type0 it is not possible to invoke extended-path- induction nor conversion.
In the variable case, we necessarily have T ≡ A and therefore we can conclude by taking |T | = 0. In the identity case, T is of the shape M =C N and by induction hypothesis M ≡β ω|C|, N ≡β ω|C| and C ≡β Ω|C|. So we conclude by taking |T | = |C| + 1.
Without loss of generality (MLTT is normalizing) we can assume that W is in normal form. We proceed by a (nested) induction on the derivation A : Type,a : A ▶id W : T , we treat each possible case (identity and conversion are obviously impossible since T cannot be Type0):
variable: In this case, we necessarily have W ≡ a and T ≡ A. So we have
|T | =0 and W ≡ ω0.
reflexivity: In this case, W and T are respectively of the shape 1C and
M =C M . By induction hypothesis, we have M ≡β ω|C|. Therefore |T | =
|C| +1 and W ≡β ω|C|+1.
extended-path-induction: This is in fact an impossible case. We would

have W of the shape J
−→
6x:C,y:M =x,Δ.P (B, U, V, Z )
and by induction hypothesis,

we would have M ≡β ω|C| ≡β U and V ≡β ω|C|+1. Therefore V is a reflexivity and so W is not in normal form.
2

The previous lemma allow us to find a canonic instantiation of any contractible context given by :

(A : Type,a : A)+ = (A, a)
(Γ,x : A, y : M =C x)+ = (Γ+, ω|C[Γ+/Γ]|, ω|C[Γ+/Γ]|+1)

The following lemma state that this instantiation is correct :

Lemma 5.3

Γ contr implies A : Type0,a : A ▶id Γ+ :Γ	(1)
Γ ▶id T : Type0 implies T [Γ+/Γ] ≡β Ω|T [Γ+/Γ]|	(2)

Γ ▶id T : Type0 and Γ ▶id M : T implies M ≡β ω|T [Γ+/Γ]|	(3)
Proof. We proceed by induction on size of derivations in MLID. We prove (1) by inspecting the last possible rule :
initial: Γ is of the shape A : Type0,a : A and Γ+ = (A, a). By using two times
variable, we check that : (A : Type0,a : A) ▶id (A, a): (A : Type0,a : A).
contractible: Γ is of the shape Δ,x : B, p : M =B x with Δ ▶id B : Type0 and Γ ▶id M : B. By induction hypothesis, we have A : Type0,a : A ▶id Δ+ : Δ, B[Δ+/Δ] ≡β Ω|B[Δ+/Δ]| and M [Δ+/Δ] ≡β ω|B[Δ+/Δ]|. It is then easy to check us- ing conversion that we have (A : Type0,a : A) ▶id (Δ+, ω|C[Γ+/Γ]|, ω|c[Γ+/Γ]|+1): (Δ,x : B, p : M =B x).
To prove (2) and (3), we notice that within the derivation of Γ ▶id T : Type0 there is a strictly smaller derivation of Γ contr so we can use the induction hypothesis to obtain A : Type0,a : A ▶id Γ+ : Γ. Now by substitution, we derive that A : Type0,a : A ▶id T [Γ+/Γ] : Type0 and A : Type0,a : A ▶id M [Γ+/Γ] : T [Γ+/Γ]. We conclude that T [Γ+/Γ] ≡β Ω|T [Γ+/Γ]| and M ≡β ω|T [Γ+/Γ]| by previous lemma.	2
Lemma 5.4 (All groupoid laws are inhabited) If Γ ▶id T : Type0, then there exists θΓ.T such that Γ ▶id θΓ.T : T .
Proof. The contractible context Γ is of the shape
A : Type0,a : A, x1 : C1, y1 : M1 = x1,.	, xn : Cn, yn : Mn = xn
we construct θΓ.c by n successive extended path-inductions (from left to right). After all the inductions, it remains to find an inhabitant of T [Γ+/Γ] in the context A : Type0,a : A. But thanks to the previous lemma, we know that T [Γ+/Γ] ≡β Ω|T [Γ+/Γ]|, therefore using conversion we can use ω|T [Γ+/Γ]|. Spelled out, the term θΓ.T is :
θΓ.T ≡ J6x1:C1,y1:M1=x1,. ,xn:Cn,yn:Mn=xn.T (
J6(x2:C2,y2:M2=x2,.  ,xn:Cn,yn:Mn=xn.T )[ω|C1|/x1,ω|C1|+1/y1](
··· J6(xn:Cn,yn:Mn=xn.T )[Δ+/Δ](ω|T [Γ+/Γ]|, xn, yn)	, x2, y2), x1, y1)
where Δ is the context such that Γ= Δ, xn : Cn, yn : Mn = xn.	2
As a corollary, we obtain the following theorem :
Theorem 5.5 (Canonicity for groupoid laws in MLID) If Γ ▶id T : Type and if we have two terms M and N such that Γ ▶id M : T and Γ ▶id N : T , then there is a proof π such that Γ ▶ π : M = N.
Proof. Simply notice that Γ ▶ M = N : Type0 and apply previous lemma.	2

The reader should remark here that the proof π is also unique up to equality (by applying the theorem to M = N ). We are now ready to show that previous theorem may be generalized to the whole system MLTT by using parametricity theory.
Theorem 5.6 (Canonicity of inhabitants of groupoid laws in MLTT) If Γ ▶id T : Type, ▶ M : ∀Γ.T and ▶ N : ∀Γ.T, then there is a proof π such that −→γ :Γ ▶ π : (M −→γ )= (N −→γ ).
Proof. By successive extended path-inductions (from left to right), we can derive
−→γ : Γ ▶ (M −→γ ) = (N −→γ ) from a derivation of A : Type0,a : A ▶ (M Γ+) = (N Γ+). We notice that the type of (M Γ+) is T [Γ+/Γ] which is typable in MLID; by substitution we have A : Type0,a : A ▶id T [Γ+/Γ] : Type0. Therefore Lemma 5.3 gives us that T [Γ+/Γ] ≡β Ωn for some n ∈ N. Using conversion, we have A : Type0,a : A ▶ (M Γ+): Ωn. Therefore (M Γ+) is an inhabitant of a parametric loop space; therefore we can invoke Theorem 4.3 to obtain of proof that (M Γ+) = ωn. Similarly we have a proof of (N Γ+)= ωn and by concatenating them we obtain a proof of (M −→γ )= (N −→γ ).	2
Finally, using the same arguments as at the end of Section 4 we can prove that
π is unique up to propositional equality (and so on).

Discussions
The definition of groupoid laws
Our definition of MLID is inspired by an unpublished note written by Brunerie [3]. Our syntax for contractible contexts is a bit more general: in Brunerie’s definition the starting point of paths occurring at odd positions are always variable (ie. Mk is always a variable) and there is no computation rules in his syntax. Brunerie defines ω-groupoids as models of its syntax, since the absence of computation rules makes his framework more free about how coherence issues are dealt with. However, the goal of our syntax is not give the general syntax for weak ω-groupoids but rather to study only the groupoid structure in the particular case of type theory where computation rules are the natural way to deal with coherence. Nevertheless, it would be an interesting future work to make a precise comparison between other definitions of ω-groupoids and models of MLID.
The semantical nature of Garner and van den Berg [9] makes it quite difficult to relate to our work, however we believe that Lumsdaine’s construction [5] of a contractible globular operad may be described in our framework.

The n-ary case
Throughout this article, we only use the unary case of parametricity theory, but it could be easily generalized to the binary case by transporting along two paths : Jx = y)2 ≡ λ(p : x = y)(q : xj = yj).p∗(q∗(xR)) = yR. This translation is well-typed

under the binary translation Jα : Typei,x : α, y : α)2 given by
ααj : Typei, αR : α → αj → Typei,x : α, xj : αj, xR : αR x xj,y : α, yj : αj, yR : αR y yj
The translation J1α) : 1α  1α (x ) = x	of 1α is given by J1α) ≡ 1αR xx which
is defined under the translated context Jα : Type,x : α)2. Similarly, the translation of path-induction is obtained by nesting 2+1 path-induction:
JJ(B, U, V ))2 ≡ J(J(J(JB)2, U,V ),Uj,V j), JU )2, JV )2)
It is a routine check to generalize the abstraction theorem of Section 3, in order to a have a binary version of parametricity. Likewise, the n-ary case, is obtained by transporting along n path and the translation of path-induction is obtained by nesting n +1 path-inductions.
Encoding identity types with inductive families.
In dependent type systems that support inductive families, it is possible to encode identity types by an inductive predicate [4]. For instance, in the coq proof assistant:
Inductive paths (A : Type) (a : A) : A → Type := idpath : paths A a a.
As explained in [2] (Section 5.4), the parametricity translation extends well to inductive families. The idea is to translate an inductive type I by a new inductive IR whose constructors are the translation of constructors of I. Likewise, the elimination scheme for IR is the translation of the one of I.
Inductive paths_R (A : Type) (A_R : A → Type) (a : A) (a_R : A_R a) : 
forall x, A_R x → paths A a x → Type :=
idpath_R : paths_R A A_R a a_R a a_R (idpath A a).
There is an equivalence of types (in the homotopy theory sense, see [8]) between this inductive type and our translation of identity. It is obtained by using the induction principle associated with pathsR in one direction; and by nested path- inductions on p and on the proof of transport along p in the other direction. This indicates that they are morally the same; it may convince the reader that the results of the last two sections could have been carried out using the encoding instead of the primitive notion of identity types.
Dealing with axioms
While formalizing proofs that need axioms which are independent, it is a common practice to simply add them in the context. Then, if one want to use the para- metricity translation, he also needs to provide a witness of the parametricity of the axiom. Therefore axioms that can prove their own parametricity are well-behaved with respect to the translation. More formally, we say that a closed type P : Type is provably parametric if the type ∀h : P, h ∈ JP ) is inhabited. We will now give two examples of axioms using identity types which are provably parametric.

uniqueness of identity proofs (UIP) : Let uip be the following type uip ≡ ∀X : Type,xy : X, p q : x = y.p = q. We want to find an inhabitant of ∀f : uip.f ∈ Juip). The statement f ∈ Juip) unfolds into ∀JX : Type,xy : X, p q : x = y).(f A x y p q)∗(pR) = qR. The conclusion is an equality between paths, so it is provable using f .
function extensionality : Let funext be the following type funext ≡ ∀A : Type,B : A → Type,f g : ∀x : A.Bx.(∀x : A.f x = g x) → f = g. In his original development, Voedvoesky showed that funext is logically equivalent (there is a function in both directions) to the so-called weak extensionality (see [8]). It is defined by weakext ≡ ∀A : Type,P : A → Type.(∀x : A.Contr P x) → Contr (∀x : A.P x)) where Contr A ≡ ∃x : A.∀y : A.x = y is the predicate for contractible types; ie. types which are equivalent to the singleton type. We now sketch the proof that weakext is provably parametric (and thus so is funext). The main idea is to notice that M ∈ JContr A) is logically equivalent to Contr (JA) M1) where M1 is the first projection of M . The unfolding of k ∈ Jweakext) is:
∀A : Type, AR : A → Type,P : A → Type, PR : (∀x : A, xR : AR x.P x → Type), φ : (∀x : A.Contr (P x)), φR : (∀x : A, xR : AR x.(φ x) ∈ JContr P x)).
(kA P φ) ∈ JContr (∀x : A.P x))
Therefore, using the logical equivalence in one direction we can deduce the conclu- sion from Contr (kA P φ)1 ∈ J∀x : A.P x))). Then using k : weakext two times, it is enough to prove that ∀x : A, xR : AR x.Contr ((kA P φ)1x) ∈ JP x)) (1). Notice that (kA P φ)1 x =A (φ x)1 because A is contractible. So we can trans- port along this path in (1) to obtain ∀x : A, xR : AR x.Contr ((φx)1 ∈ JP x))
(2).  Now, using the other direction of logical implication, (2) is implied by
∀x : A, xR : AR x.(φx) ∈ JContr (P x))) which is exactly the type of φR.
Conclusion
This work shows that parametricity theory may be used to deduce properties about the algebraic structure of identity types. It allows to give formal arguments to prove canonicity results about definitions in a proof-relevant setting.
The most important question that remains open is whether or not we can extend the translation and the uniqueness property of groupoid laws to deal with Voevod- sky’s univalence axiom. One way to solve this question would be to prove that univalence axiom is provably parametric which would yield to a positive answer to the question of the compatibility of parametricity theory and univalence. Regard- less of the answer to this problem, solving it would give a better understanding of polymorphic type quantifications in univalent universes.

References
Henk Barendregt. Lambda Calculi with Types. In Handbook of Logic in Computer Science, pages 117–309. Oxford University Press, 1992.

Jean-Philippe Bernardy, Patrik Jansson, and Ross Paterson. Proofs for free - parametricity for dependent types. J. Funct. Program., 22(2):107–152, 2012.
Guillaume Brunerie. Syntactic grothendieck weak ∞-groupoids. Available as http://uf-ias-2012. wikispaces.com/file/view/SyntacticInfinityGroupoidsRawDefinition.pdf.
Peter Dybjer. Inductive families. Formal Asp. Comput., 6(4):440–465, 1994.
Peter LeFanu Lumsdaine. Weak omega-categories from intensional type theory. In Pierre-Louis Curien, editor, TLCA, volume 5608 of Lecture Notes in Computer Science, pages 172–187. Springer, 2009.
Zhaohui Luo. Ecc, an extended calculus of constructions. In LICS, pages 386–395. IEEE Computer Society, 1989.
John C. Reynolds. Types, Abstraction and Parametric Polymorphism. In IFIP Congress, pages 513–523, 1983.
The Univalent Foundations Program. Homotopy Type Theory: Univalent Foundations of Mathematics.
http://homotopytypetheory.org/book, Institute for Advanced Study, 2013.
Benno van den Berg and Richard Garner. Types are weak ω-groupoids. Proceedings of the London Mathematical Society, 102(2):370–394, 2011.
