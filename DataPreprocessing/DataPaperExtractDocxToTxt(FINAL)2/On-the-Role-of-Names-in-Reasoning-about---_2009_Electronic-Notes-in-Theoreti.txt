

Electronic Notes in Theoretical Computer Science 228 (2009) 135–150
www.elsevier.com/locate/entcs
On the Role of Names in Reasoning about
λ-tree Syntax Specifications
Alwen Tiu
Computer Sciences Laboratory The Australian National University
Canberra ACT 0200, Australia Email: Alwen.Tiu@rsise.anu.edu.au

Abstract
Lambda tree syntax (a variant of HOAS) and nominal techniques are two approaches to representing and reasoning about languages containing bindings. Although they are based on separate foundations, recent advances in the proof theory of generic judgments have shown that one may be able to incorporate some aspects of nominal techniques (i.e., the equivariant principle) to simplify reasoning about λ-tree syntax specifications, while still maintaining the crucial aspects of λ-tree syntax. In this paper, we present a logic, called LGnω, which incorporates a notion of generic judgments and equivariant reasoning. The logic LGnω is a simple extension of a logic called LGω by Tiu, and can be seen as a special case of the logic G by Gacek, Miller and Nadathur. A central idea of LGnω is the representation of a data type for names (represented by
a predicate). Although the data type is inhabited by infinitely many elements, the judgments of the logic only ever use finitely many of them, and more importantly, validity of these judgments are preserved under arbitrary permutation of names, i.e., they are equivariant judgments. This finite support of judgments allows for tractable introduction rules of the name predicate. We illustrate with two examples how this simple extension can be used for reasoning about specifications involving bindings. In the first example, we show how one can represent the data type for λ-terms, and derive a structural induction principle for inductive reasoning over λ-terms. In the second example, we re-examine previous known encodings of open and late bisimulations for the π-calculus. We show that the difference between open and late bisimulation can be characterized by the choice of the encodings of names: the “untyped” version (for the former) versus
the “typed” one (for the latter).
Keywords: generic judgments, nominal techniques, logical framework, pi-calculus, bisimulation

Introduction
Lambda-tree syntax [10] is an abstract syntax for representing syntactic structures involving bindings using Church’s simply typed λ-calculus. It is a weak variant of higher-order abstract syntax (HOAS) and shares two main aspects of the HOAS en- coding style, namely, the use of λ-abstraction to represent bindings in object-level syntactic structures, and the use of applications to represent object-level substi- tutions. The representation language in λ-tree syntax is intentionally weak, so as to avoid certain problems with adequacy of representations. To compensate for this weakness in representation, reasoning about properties of the encodings are

1571-0661/© 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.12.122

delegated to a meta-logic (typically first-order or higher-order logics), whose term structures are those of the simply typed λ-calculus.
In reasoning about λ-tree syntax specifications of object systems, say, type sys- tems for functional languages, one is often faced with the problem of representing object-level typing contexts faithfully in the meta level. Such a representation re- quires an interpretation of object-level “names” or “variables”. The roles of these names or variables, in the object level, are often confined to providing distinct iden- tifiers. Thus, when encoding the typing judgments at the meta level, one may want to ensure that this notion of distinctness is represented faithfully. This is one of the motivations behind the design of the proof theory for generic judgments [12,21], on which we base our meta logic designs.
One observation that one can make about many of the operational semantics of modern programming languages and type systems is that most of the judgments of interest, such as typing judgments, evaluations, bisimulation, etc., are invariant un- der injective variable renaming, and more specifically, under arbitrary permutations of the variables. In other words, these judgments are equivariant judgments. This notion of equivariance is first formalised by Gabbay and Pitts [6] using FM-sets, and is later given a first-order axiomatizations by Pitts [15], resulting in an extension of first-order logic called nominal logic. It is adopted into a meta logic based on λ-tree syntax, called LGω, in [22]. To capture this notion of equivariance in LGω, we introduce a set of base types, called nominal types, each of which is inhabited by infinitely many constants, called nominal constants (or just names). The role of these constants is to enforce the equivariant principle. The meta logic is designed in a way such that provability of judgments is invariant under arbitrary permutation of names. Names in the meta logic have a similar role to eigenvariables; they act as proof level binders for a new quantifier, called ∇.
The logic LGω was introduced as a first attempt to address a certain gap in in- ductive reasoning involving generic judgments in its predecessor, the logic LINC [21], which also features the ∇-quantifier. In LINC there is no interplay between the in- duction rule and the variable context surrounding the judgment being proved. This makes it unsuitable for certain applications, such as reasoning about type systems, which heavily involves reasoning about variables in typing contexts. Although LGω is more expressive than LINC (for reasoning about bindings), the gap is essentially still there. This gap is finally closed in the recently introduced logic G by Gacek, Miller and Nadathur [4]. The logic G makes a simple, but crucial, extension to LGω: it allows one to specify a fixed point definition which carries around a variable con- text, encoded via ∇. This extension is surprisingly powerful, allowing one to specify and reason, quite naturally, about a variety of properties not previously expressible directly in LINC or LGω (see [5]). A main motivation for the present work is to understand better the expressivity of G in a minimal setting, that is, the minimal extension to LGω that is still powerful enough to reason about inductive properties of λ-tree syntax specifications. The minimal extension proposed here, called LGnω, is essentially G with only one extended fixed point definition, denoting a datatype for names. This extension is also motivated by its applications in formalising the

π-calculus [11], in which the notion of names plays a central role in its meta theory. As it turns out, we can still do a variety of reasoning tasks that seem to be the core novel features of G using LGnω (see Section 5 for a discussion).
Although LGnω is motivated by a specialization of G, we follow a different ap- proach to the design of the logic. Instead of using the extended fixed point definition as in G to define a datatype for names, we take as primitive a notion of datatype for names that arises naturally from its intended interpretation. We introduce a built- in predicate called name of single arity, which recognizes its argument as being a name. That is, the proposition name a is derivable in the logic if and only if a is a nominal constant. Since we assume an infinite set of names (nominal constants), the case analysis rule for this datatype is simply an enumeration of all possible nominal constants. In a simplified form, this rule can be presented as an infinite branching rule:
Γ =⇒ P a1	Γ =⇒ P a2	···	Γ =⇒ P an	··· 
Γ =⇒ ∀x.name x ⊃ P x
However, thanks to the equivariant property of the logic, in using the rule, we only need to consider a finite number of cases: those in which the name x is instantiated to one which occurs already in P , plus an additional one where the name is “fresh” with respect to P. It thus allows us to derive a version of the rule which uses only a finite number of names, similar to that of G, while at the same time makes it easier for us to establish the meta theory of LGnω using the simpler, infinitary rule.
We show with a couple of examples how the predicate name can be used. In the first example (Section 3), we show how one can encode the data type for untyped λ-terms, along with a structural induction principle. We define some standard rela- tions on λ-terms, namely, the notion of freshness of a name with respect to a term, abstraction of a name from a term and substitutions of a name in a term with an- other term. We then prove some properties about these relations that show: (a) the notion of freshness is implicitly supported by meta-level scoping restrictions and the
∇ quantifier, and (b) meta-level applications co-incide with the inductively defined substitution predicate. In the second example (Section 4), we re-examine a previous known encoding of the π-calculus [24] and the notions open and late bisimulations [20]. As shown in [24], the difference between open and late bisimulation can be characterized by the presence or absence of the assumption about the decidability of name equality, i.e.,

∀x∀y.name x ⊃ name y ⊃ x = y ∨ x /= y.

Name equality happens to be decidable in LGnω. Therefore we obtain a new, simpler characterization of the difference between open and late bisimulation: In late bisimulation, names are typed, whereas in open bisimulation, names are untyped.
Some of the proofs are omitted from the main text and can be found in the appendix of an extended version of the paper. The proofs concerning the examples in Section 3 have been mechanically verified in the proof assistant Abella [2] and

can be found on the web. 1
The logic LGnω
In this section, we present the proof system for LGnω. Since LGnω is just a small extension of LGω, a significant part of this section is an overview of LGω. LGnω is based on a subset of Church’s Simple Theory of Types. Following Church, we designate a special type o to denote formulas. The core fragment of LGnω, shares the same set of connectives as LGω, namely, ⊥, T, ∧, ∨, ⊃, ∀τ , ∃τ and ∇τ . The type τ in the quantifiers is restricted to that which does not contain the type o. Hence the logic is essentially first-order. We abbreviate (B ⊃ C) ∧ (C ⊃ B) as B ≡ C.
To enforce equivariant reasoning, we introduce a distinguished set of base types, called nominal types, which is denoted with N . Nominal types are ranged over by ι. We restrict the ∇ quantifier to nominal types. For each nominal type ι ∈ N , we assume an infinite number of constants of that type, denoted by Cι. These constants are called nominal constants. We denote the family of nominal constants by CN . Provability of formulas in LGnω is invariant under permutations of nominal constants. The set of non-nominal constants is denoted by K.
We assume the usual notion of capture-avoiding and type preserving substitu- tions. Substitutions are ranged over by θ, σ and ρ. Application of substitutions is written in a postfix notation, e.g., tθ is an application of θ to the term t. Given two substitutions θ and θ', we denote their composition by θ ◦ θ' which is defined as t(θ ◦ θ') = (tθ)θ'. A typing context is a set of typed variables or constants. The judgment Δ ▶ t : τ denotes the fact that the term t has the simple type τ , given the typing context Δ. Its operational semantics is the usual type system for Church’s simple type theory. A signature is a set of variables. We denote by Σθ the signature obtained by replacing every x ∈ Σ with the free variables in θ(x).
Definition 2.1 A permutation on CN is a bijection from CN to CN . The permu- tations on CN are ranged over by π. Application of a permutation π to a nominal constant a is denoted with π(a). We shall be concerned only with permutations which respect types, i.e., for every a : ι, π(a) : ι. Further, we shall also restrict to permutations which are finite, that is, the set {a | π(a) /= a} is finite. Application of a permutation to an arbitrary term (or formula), written π.t, is defined as follows:

π.a = π(a), if a ∈ CN .	π.c = c,	if c /∈ CN .	π.x = x π.(M N ) = (π.M ) (π.N )	 π.(λx.M ) = λx.(π.M )
Notice that the permutation action on variables is an identity. Implicit in this definition is the assumption that variables always have empty support. This design feature allows us to omit explicit representation of permutations at the term level. Dependency of a variable on names can be encoded via a technique called raising, to be explained shortly.

1 URL: http://rsise.anu.edu.au/~tiu/papers/names.thm

π.B = B'


Σ; Γ,B =⇒ B' id
Σ; Γ =⇒ B Σ; B, Δ =⇒ C
Σ; Γ, Δ =⇒ C	cut
Σ; Γ,B,B =⇒ C


Σ; Γ,B =⇒ C	cL

Σ; Γ, ⊥ =⇒ C ⊥L	Σ; Γ =⇒T TR
  Σ; Γ, Bi =⇒ C		Σ; Γ =⇒ B Σ; Γ =⇒ C
∧L,i ∈ {1, 2}	∧R
Σ; Γ, B1 ∧ B2 =⇒ C	Σ; Γ =⇒ B ∧ C

Σ; Γ,B =⇒ C  Σ; Γ,D =⇒ C


Σ; Γ,B ∨ D =⇒ C
Σ; Γ =⇒ Bi


∨L	Σ; Γ =⇒ B1 ∨ B2
∨R,i ∈ {1, 2}

Σ; Γ =⇒ B Σ; Γ,D =⇒ C


Σ; Γ,B ⊃ D =⇒ C	⊃L 
Σ; Γ,B =⇒ C


Σ; Γ =⇒ B ⊃ C ⊃R 

Σ, K, CN ▶ t : τ  Σ; Γ,B[t/x] =⇒ C
Σ; Γ, ∀τ x.B =⇒ C	∀L
Σ; Γ,B[a/x] =⇒ C
∇L,a /∈ supp(B)
Σ; Γ, ∇x.B =⇒ C
Σ, h; Γ,B[h →c/x] =⇒ C
Σ, h;Γ =⇒ B[h →c/x]
∀R,h /∈ Σ, supp(B)= {→c}
Σ; Γ =⇒ ∀x.B
Σ; Γ =⇒ B[a/x]
∇R,a /∈ supp(B)
Σ; Γ =⇒ ∇x.B
Σ, K, CN ▶ t : τ Σ; Γ =⇒ B[t/x]

∃L,h /∈ Σ, supp(B)= {→c}
Σ; Γ, ∃x.B =⇒ C
Σ; Γ =⇒ ∃τ x.B	∃R



Fig. 1. The core inference rules of LGnω.


{Σθ; Γθ =⇒ Cθ | tθ = sθ, supp(θ)= ∅} Σ; Γ,s = t =⇒ C

eqL


Σ; Γ =⇒ t = t

eqR



{Σθ; Γθ =⇒ Cθ | tθ ∈ Cι and supp(t, Γ,C)#θ}


Σ; nameι t, Γ =⇒ C	nameL
a ∈ Cι


Σ; Γ =⇒ nameι a nameR



Fig. 2. The inference rules for equality and names.

The support of a term (or formula) t, written supp(t), is the set of nominal constants appearing in it. The support of a substitution, written supp(θ) is the set of nominal constants appearing in the range of the substitutions. A substitution is a closed substitution if its support is empty. Given a list of nominal constant →c and a term t, we say that →c is fresh for t, written →c#t, if {→c}∩ supp(t) = ∅. Similarly, given a list of nominal constants →c and a substitution θ, we say that →c is fresh for θ, written →c#θ, if supp(θ) ∩ {→c} = ∅.
A sequent in LGnω is an expression of the form Σ; Γ =⇒ C where Σ is a signature and the formulas in Γ ∪ {C} are in βη-normal form. The free variables of Γ and C are among the variables in Σ. The inference rules for the core fragment of LGnω are given in Figure 1.
In the ∇L and ∇R rules, a denotes a nominal constant. In the ∃L and ∀R rules, we use raising [8] to encode the dependency of the quantified variable on the support of B. In the rules, the variable h has its type raised in the following way: suppose
→c is the list c1 : ι1,..., cn : ιn and the quantified variable x is of type τ . Then the
variable h is of type: ι1 → ι2 → ... → ιn → τ. Raising is used to encode explicitly the minimal support of the quantified variable. As we shall see later, provability is preserved under support extensions.
We now extend the core logic with a proof theoretic notion of names, equality,

Σ; Γ,B[→t/→x] =⇒ C	Σ; Γ =⇒ B[→t/→x]
Σ; Γ,p →t =⇒ C	defL,p →x = B	Σ; Γ =⇒ p →t	def Y,p →x = B
=⇒ Dz j; Dj =⇒ D (sj) Σ; Γ,D I =⇒ C
Σ; Γ, nat I =⇒ C	natL
Σ; Γ =⇒ nat I

Σ; Γ =⇒ nat z natY
natY
Σ; Γ =⇒ nat (sI)



Fig. 3. Fixed points and induction

fixed points and natural number induction. The latter three are the same as in LGω. The rules for fixed points are the standard ones, and have been considered in many previous work [7,19,3,9]. We first look at the equality rules, given in Figure 2. In eqL, we specify the premise of the rule as a set to mean that every element of the set is a premise. What the rule does, reading it bottom-up, is essentially computing a set of uniﬁers for s and t. Notice that the substitution θ is a closed substitution, therefore solvability of the equation s = t is the same as solvability of the equation: λ→c.s =βη λ→c.t, where →c is the support of s = t, and θ can be computed using standard higher-order unification algorithms.
The datatype for names is encoded via a family of special predicates nameι : ι →
o. We shall often omit the subscript ι in nameι when the type ι is not important or when it can be inferred from context. The introduction rules for name are given in Figure 2. The right introduction rule simply recognizes that a constant belongs to the set of nominal constants. The more interesting rule is nameL, which considers all possible substitutions to a term t such that the resulting term tθ is a nominal constant. If t is headed with a non-nominal constant, then the rule simply produces an empty premise, in which case the lower sequent is proved trivially. Notice that in nameL we allow substitutions that mention nominal constants, as long as these constants are fresh with respect to the conclusions. The rule can be infinitary, since the set of nominal constants is infinite. We shall see later that it can be restricted to a version which uses only a finite number of names.
We now introduce a proof theoretic notion of deﬁnitions.
Definition 2.2 To each atomic formula, we associate a fixed point equation, or a
deﬁnition clause. A definition clause is written ∀→x.p →x =Δ B where the free variables of B are among →x. The predicate p →x is called the head of the definition clause, and B is called the body. A deﬁnition is a set of definition clauses. We often omit the outer quantifiers when referring to a definition clause.
We adopt a style of definitions with no patterns in the heads, but as it has been shown in [21], allowing patterns in the head does not add any expressive power, and both styles of definitions are interchangable in the presence of equality. However, when we discuss examples, we shall use patterned definitions. The introduction rules for defined atoms are given in Figure 3. Certain monotonicity restrictions need to be imposed on definition clauses so as to guarantee cut elimination. These restritions are the same as the ones for LGω (see [22] for details).

The rules for natural numbers are given in Figure 3. We introduce a type nt to denote natural numbers, with the usual constants z : nt (zero) and s : nt → nt (the successor function), and a special predicate nat : nt → o. These rules are the same as those in FOλΔIN [9]. In natL, we restrict the invariant D to a closed term such that supp(D) = ∅. We do not gain any expressive power by allowing nominal constants in D, since these constants can be introduced via the ∇ quantifier.
The cut elimination proof for LGnω follows much of the cut elimination proof of LGω[23]. One subtle difference is in the proof transformation involving substitu- tions, stated in the following proposition.
Proposition 2.3 Let Π be a derivation of the sequent Σ; Γ =⇒ C in LGnω. Let →c be the list of nominal constants occuring in Γ and C. Let θ be a substitution with such that →c#θ. Then there exists a derivation Π' of Σθ; Γθ =⇒ Cθ in LGnω such that the height of Π' is less or equal to the height of Π.
Note that, unlike, LGω, proof-level substitutions can mention nominal constants, as long as they are fresh with respect to the sequents in the proofs.
Theorem 2.4 Cut elimination holds for LGnω.

A version of nameL with finite names
The rule nameL as given in Figure 2 can have infinitely many premises. For example, applying the rule to a sequent like
x : ι; name x, Γ(x) =⇒ C(x)
results in infinitely many premises, each of which replaces the variable x with a name a ∈ CN . We now show that one can restrict the rule to one which uses finitely many names, without losing soundness. This rule is given below.
{Σ'θ; Γ'θ =⇒ C'θ | t'θ ∈ supp(t, Γ, C) ∪ {a}, a#(t, Γ, C) and supp(θ) = ∅} name
fL 
Σ; nameι t, Γ =⇒ C
Here Σ', t', Γ' and C' are obtained as follows. Let →c = c1 : ι1,..., cn : ιn be the support of (t, Γ, C) and let a : ι be a new nominal constant not in →c. Define a substitution σ as follows:
σ = {(h' a) | h ∈ Σ and h' is a variable of suitable type that is not in Σ}.
Then Σ', t', Γ' and C' are defined as Σσ, tσ, Γσ and Cσ, respectively. We call this substitution σ a raising substitution of the rule. This rule essentially reduces the extension of the support of the conclusion sequent to one in which only one new name is used, and since the judgments of the logic are equivariant, it does not matter which name we choose, as long as it is fresh with respect to the current support. There is another potential infinity in the rule because we consider arbitrary matching substitution θ. Since θ in this case is a closed substitution, the problem of matching t' with a name b ∈ supp(t, Γ, C) ∪ {a} reduces to a specific case of


Δ	Δ
tm I X = name X.	tm (s I) (app M N ) = tm I M ∧ tm I N.
Δ	Δ
tm (s I) (lam M ) = ∇x.tm I (M x).	term M = ∃I.nat I ∧ tm I M.

Δ
fresh A B = name A ∧ name B ∧ A /= B.
Δ
fresh A (app M N ) = fresh A M ∧ fresh A N.
Δ
fresh A (lam M ) = ∇x.fresh A (M x).

Δ
abstract A A (λx.x) = name A.
Δ
abstract A B (λx.B) = name A ∧ name B ∧ (A /= B).
Δ
abstract A (app M N ) (λx.app (R x) (T x)) = abstract A M R ∧ abstract A N T.
Δ
abstract A (lam M ) (λx.lam (T x)) = ∇y.abstract A (M y) (λx.T x y).

Δ
subst X M X M = name X.
Δ
subst X M Y Y = name X ∧ name Y ∧ X /= Y.
Δ
subst X M (app R S) (app U V ) = subst X M R U ∧ subst X M S V.
Δ
subst X M (lam N ) (lam R) = ∇x.subst X M (N x) (R x).

Fig. 4. A data type for λ-terms and some relations over λ-terms
higher-order matching: λ→cλa.t' =βη λ→cλa.b where →c = supp(t, Γ, C). Readers who are familar with Huet’s higher-order unification algorithm will notice that in solving this matching problem, one needs only use the projection step. This matching problem can be shown to be decidable and there exists a finite complete set of unifiers (CSU), if it is solvable. Hence, in practice one needs only to consider a finite number of premises generated by this CSU.
We refer to the logic LGnω with the nameL rule replaced by namefL as LGnω.

Proposition 2.5 Let Π be a derivation of Σ; Γ =⇒ C in LGnω. Then there exists
a derivation Π' of the same sequent in LGnω.

λ-terms, freshness and substitutions
In this section, we show a few simple examples of representing and reasoning about an encoding of untyped λ-terms. These examples serve only to illustrate how one can reason inductively about data structures with bindings. We prove some basic properties related to freshness and substitutions, which are basic ingredients for more complicated reasoning tasks. We encode these structures directly as definitions in LGnω, and derive a structural induction principle for λ-terms. In the following, we assume there is one nominal type for representing expressions, denoted by exp.

A structural induction rule for λ-terms
The data structure representing λ-terms is encoded as the definition clause for term given in Figure 4. The syntactic types of the constructors are as expected, namely, app : exp → exp → exp and lam : (exp → exp) → exp. Notice that we need to index the predicates tm with a natural number since we intend to perform induction over

{.; . =⇒ P (λ→n. a) | a ∈ {→n}∪ {b},b /∈ →n}
M, N ; P M ∧ P N =⇒ P (λ→n.(app (M →n) (N →n)))
M ; ∇a.P (λ→n.M →n a) =⇒ P (λ→n.lam (M →n)) Σ; P (λ→n.t), Γ =⇒ C
Σ; term t, Γ =⇒ C	termL


Fig. 5. A structural induction rule for λ-terms. In the rule, →n = supp(t).

the structure of terms, and since in LGnω we allow only natural number induction. Proving inductive properties of terms using natural number induction can be quite cumbersome. We shall derive a more user-friendly rule for induction over term. In reasoning about term t, we often need to take into account the support of t.  The set supp(t) can be seen as some sort of context for the term t.  To make this context explicit in the invariants of the induction, we use (meta-level) λ-abstraction to encode this context into the invariants. Therefore, in the derived rule, the invariants can be abstractions of arbitrary arity, depending on the support of t. This rule is given in Figure 5. In the rule, →n = supp(t) and P is a closed term of type exp → · · · → exp → o. For the base cases, we consider all the cases where the term is a name, i.e., the cases where it is among the support of t and another
case where it is a new name.
Proposition 3.1 The rule termL is derivable in LGnω.

Freshness and scoping
The notion of freshness of a name with respect to a term is encoded via a predicate called fresh, given in Figure 4. In the figure, we abbreviate (X = Y ) ⊃⊥ as X /= Y. Scoping restrictions at the meta level can be shown to imply the derivability of the freshness relation, as given in the following theorem.
Theorem 3.2 Freshness and scopes. The formula ∀M∇x.term M ⊃ fresh x M 
is derivable in LGnω.

Abstractions
In this example, we show how one can abstract a name from a term. This relation is defined via the predicate abstract in Figure 4. As in the case with freshness, scoping restrictions and ∇-quantification at the meta level imply derivability of an abstraction.
Theorem 3.3 The following formulas are derivable in LGnω.
∀M∇x.term (M x) ⊃ abstract x (M x) M.
∀M∇x∀N.term (M x) ⊃ abstract x (M x) N ⊃ M = N.
As expected, an abstracted name is fresh with respect to the abstracted term, as stated in the following theorem.


τ	Δ
τ P −−→ P = T


A	Δ	A

↓ X	Δ	match x x P −−→ Q = P −−→ Q

in X M −−- M = T
A	Δ	A

† xy	Δ
out x y P −−→ P = T
match x x P −−- Q = P −−- Q 


A	Δ	A
P + Q

A	'	Δ	A	'

−−→ R = P −−→ R
P | Q −−→ P | Q = P −−→ P

A	Δ	A
P + Q
A	' Δ	A	'

−−→ R = Q −−→ R
P | Q −−→ P | Q = Q −−→ Q

A	Δ	A	A
rcl
Δ	A

P + Q −−→ R = P −−- R	P | Q −−- λn(M n | Q) = P −−- M 
A	Δ	A	A	Δ	A
P + Q −−→ R = Q −−- R	P | Q −−- λn(P | N n) = Q −−- N.

A	Δ	A
νn.Pn −−→ νn.Qn = ∇n(Pn −−→ Qn)

A
νn.Pn
A
'	∇n(Pn	'

† X
νy.My	'
† Xy	'

−−- M = ∇y(My −−→ M y)
τ	Δ	↓ X	† X
P | Q −−→ νy.(My | Ny) = ∃X.P −−- M ∧ Q −−- N 
τ	Δ	† X	↓ X
P | Q −−→ νy.(My | Ny) = ∃X.P −−- M ∧ Q −−- N 

τ
P | Q
MY |
' Δ ∃X.P ↓ X
∧ Q † XY Q'

τ
P | Q
P' |
Δ ∃X.P † XY P' ∧ Q ↓ X


Fig. 6. A specification of the operational semantics of the π-calculus.
Theorem 3.4 The following formula is derivable in LGnω:
∀A∀M∀N.name A ⊃ term M ⊃ abstract A M N ⊃ fresh A (lam N ).

Substitutions and meta-level applications
Substitutions of a name for a term can be encoded as the predicate subst in Figure 4. This explicit encoding of substitutions co-incides with the implicit one using meta- level applications.
Theorem 3.5 The following formula is derivable in LGnω.

∀M∀N∇y∀R.term M ∧ term (N y) ⊃ subst y M (N y) R ≡ (R = (N M ))

The π-calculus and bisimulation
We now consider a specification of the π-calculus and its associated notions of bisimulation. We consider here only the finite fragment of the π-calculus, given by the following grammar:

P ::= 0 | τ.P | x¯y.P | x(y).P | (νx)P | [x = y]P | P|P | P + P.
We use the symbols P, Q, R, S, and T to denote processes and lower case letters, e.g., a, b, c, d, x, y, z to denote names. The occurrence of y in the process x(y).P and (y)P is a binding occurrence, with P as its scope. We consider processes to be syntactical equivalent up to renaming of bound names.

The encoding of the operational semantics of the π-calculus in λ-tree syntax has been done in several previous work, e.g., [10,24,12], so we shall not go into every formal detail of the encoding. Three primitive syntactic categories are used to encode the π-calculus expressions: n for names, p for processes, and a for actions. The type n is a nominal type, and it is the only nominal type we consider in this section. The process expressions are encoded into λ-tree syntax using the following constructors:

0 : p	τ : p → p	out : n → n → p → p	in : n → (n → p) → p
+ : p → p → p	| : p → p → p	match : n → n → p → p	ν : (n → p) → p
We shall write the constructors + and | using the infix notation. The mapping between π-calculus processes and λ-terms of type p is defined in a straightforward way, where the input prefix (x(y).P ) maps to (in x λy.P ), output prefix (x¯(y).P ) maps to out x y P , and the match operator [. = .] maps to match.
There are three kinds of one-step transition relations for the late version of the
α
π-calculus: the free transition P −−→ Q, where α is either a silent action, or an
x¯(y)
output action (of the form x¯y), the bound output transition P −−→ Q and the bound
x(y)
input transition P −−→ Q. In the bound input and bound output transitions, the
name y is a binder whose scope is Q. The encoding of these transitions in λ-tree syntax are given in the following:

τ	↑ xy	↑ x	↓ x
P −−→ Q	P −−→ Q	P −−~ (λy.Q)	P −−~ (λy.Q)

representing, respectively, a silent transition, a free output transition, a bound output transition and a bound input transition. Here, the constructors ↑ and ↓ have the type n → n → a. The encoding of the operational semantics of the finite π-calculus is given in Figure 6.
We now look at specifications of bisimulation for the π-calculus. We consider two variants of bisimulation: the strong late bisimulation and the strong open bisimu- lation [20]. Given a relation R on processes, we write P R Q to denote (P, Q) ∈ R. Given a process P , we denote with fn(P ) the set of free names in P . This notation extends to free names of sets of processes in the obvious way.
Definition 4.1 A process relation R is a strong late bisimulation if R is symmetric and whenever P R Q,



if P −−→
P' R Q';
x(z)
P' and α is a free action, then there is Q' such that Q	α

x(z)
Q' and

if P −−→ P' and z /∈ fn(P, Q) then there is Q' such that Q −−→ Q' and, for every name y, P'[y/z] R Q'[y/z]; and
x¯(z)	x¯(z)
if P −−→ P' and z /∈ fn(P, Q) then there is Q' such that Q −−→ Q' and P' R Q'.


Δ	'	A	'	'	A	'	'  '
lbisim P Q = ∀A∀P [P −−→ P ⊃ ∃Q . Q −−→ Q ∧ lbisim P Q ] ∧

∀A∀Q' [Q A
∀X∀P' [P ↓ X
Q' ⊃ ∃P'. P A
' ⊃ ∃Q'. Q ↓ X
P' ∧ lbisim Q' P'] ∧
' ∧ ∀w.name w ⊃ lbisim (P'w) (Q'w)] ∧

∀X∀Q' [Q ↓ X
' ⊃ ∃P'. P ↓ X
' ∧ ∀w.name w ⊃ lbisim (Q'w) (P'w)] ∧

∀X∀P' [P † X
' ⊃ ∃Q'. Q † X
' ∧ ∇w.lbisim (P'w) (Q'w)] ∧

∀X∀Q' [Q † X
' ⊃ ∃P'. P † X
' ∧ ∇w.lbisim (Q'w) (P'w)]


Δ	'	A	'	'	A	'	'  '
obisim P Q = ∀A∀P [P −−→ P ⊃ ∃Q . Q −−→ Q ∧ obisim P Q ] ∧

∀A∀Q' [Q A
∀X∀P' [P ↓ X
Q' ⊃ ∃P'. P A
' ⊃ ∃Q'. Q ↓ X
P' ∧ obisim Q' P'] ∧
' ∧ ∀w.obisim (P'w) (Q'w)] ∧

∀X∀Q' [Q ↓ X
' ⊃ ∃P'. P ↓ X
' ∧ ∀w. obisim (Q'w) (P'w)] ∧

∀X∀P' [P † X
' ⊃ ∃Q'. Q † X
' ∧ ∇w. obisim (P'w) (Q'w)] ∧

∀X∀Q' [Q † X
' ⊃ ∃P'. P † X
' ∧ ∇w. obisim (Q'w) (P'w)]


Fig. 7. Specification of strong late, lbisim, and open, obisim, bisimulations.

The processes P and Q are strong late bisimilar, written P ~l Q, if there is a strong late bisimulation Y such that P Y Q.
Notice that in the late bisimulation, in the clause concerning input transitions, one needs to perform a case analysis on the input name of the process pair before checking the bisimilarity of their continuations. Also, implicit in the definition is the idea that free names in processes are constants. As a consequence, late bisimilarity is not closed under input prefix. Open bisimulation, on the other hand, treats names more like variables. But to enforce the “freshness” of names introduced by the bound output prefix, one needs to augment the definition of bisimulation with a notion of distinctions among names.
Definition 4.2 A distinction D is a finite symmetric and irreflexive relation on names. A substitution θ respects a distinction D if (x, y) ∈ D implies xθ /= yθ. We refer to the substitution θ as a D-substitution. Given a distinction D and a D- substitution θ, the result of applying θ to all variables in D, written Dθ, is another distinction. We denote with fn(D) the set of names occurring in D.
Definition 4.3 The set £ = {£D}D of process relations is an indexed open bisim- ulation if for each D, £D is symmetric and for every θ that respects D, P £D Q implies:



if Pθ ——→
P'£DθQ',
x(z)
P' and α is a free action, then there is Q' such that Qθ	α

x(z)
Q' and

if Pθ
——→ P' and z /∈ fn(Pθ, Qθ) then there is Q' such that Qθ
——→ Q' and

P' £Dθ Q',
x¯(z)

x¯(z)

if Pθ ——→ P' and z /∈ fn(Pθ, Qθ) then there is Q' such that Qθ
——→ Q' and

P' £D' Q' where D' = Dθ ∪ ({z}× fn(Pθ, Qθ, Dθ)).

The processes P and Q are strong open D-bisimilar, written P ~D Q, if there is an indexed open bisimulation £ such that P £D Q. The processes P and Q are strong open bisimilar if P ~∅ Q.
Notice that the definition of open bisimulation uses quantification over substitu- tions. A direct encoding would therefore formalize this name substitution explicitly. However, we can obtain a more concise encoding by using quantifiers of logic. This encoding is not new and has been used in a previous work [24]. We refer the reader to this work for the details concerning the use of quantifier alternations to encode distinctions and to avoid explicit encodings of substitutions.
The specifications of late and open bisimulations in LGnω are given in Figure 7. The specification of open bisimulation is the same as in [24]. In that work, actually both open and late bisimulation are defined using the same definition (in the logic
FOλΔ∇), i.e., the predicate obisim in this case.  Their difference appears in the
statement of adequacy. For late bisimulation, P ~l Q corresponds to the provability of the FOλΔ∇ formula S э ∇→x.obisim P Q where →x are the free names of P and
Q and S is a set of formulas of the form F = ∇→y6u6v.u = v V u /= v. This extra assumption is needed to guarantee the completeness of the encoding, and it is used to perform case analysis on names. Such a case analysis is needed in proving certain bisimilar processes, in particular, when non-deterministic choice is presence in the processes (see [17] for an example).
As noted earlier, equality between names is decidable in LGnω, provided we explicitly annotate each name variable as belonging to the set of names, using the name predicate. That is, the formula F above, modified slightly with explicit name predicates, i.e., ∇→y6u6v.name u э name v э u = v V u /= v, is a theorem in LGnω, for any →y. To get a complete encoding of late bisimulation, we then need only to explicitly “type” every name that is introduced in the body of the definition, as shown in Figure 7.
We now state the adequacy statements for the encoding of open and late bisim- ulations. The proof for the adequacy of open bisimulation is basically the same as the one done for its encoding in FOλΔ∇. We state the theorem here without proofs;
interested readers can refer to [24] for an outline, and [25] for more detailed proofs. The adequacy result of late bisimulation is, however, new and requires a different proof than that in [24,25].
Theorem 4.4 Adequacy of open bisimulation. Let P and Q be two processes and
let n¯ be the free names in P and Q. Then P ~o Q if and only if 6n¯.obisim P Q is
derivable in LGnω.
Notice that we universally quantify the free names of P and Q in the above theorem, to capture the idea that these names can be identified with each other. The late bisimulation encoding requires ∇-quantification of free names, since these are supposed to be pairwise distinct constants.
Theorem 4.5 Adequacy of late bisimulation. Let P and Q be two processes and let
n¯ be the free names in P and Q. Then P ~l Q iff ∇n¯.lbisim P Q is derivable in LGnω.

Conclusion and related work
We have shown a proof theoretic treatment of a notion of names and the equivariant principle in a logical framework based on λ-tree syntax. Most of the foundations needed to build this framework have been done in LGω[22]. However, with a small, but crucial extension involving an explicit data type for names, one can do a variety of reasoning tasks involving names and bindings in a rather clean way. We have also shown that one can derive a structural induction rule for λ-terms, in which the context of induction is encoded via abstractions. The case analysis rule on name also allows us to prove the decidability of name equality. This results in a simpler characterization of the difference between late and open bisimulation for the π-calculus, as the difference between typed and untyped encodings of names.
The logic LGnω, with the nameL-rule replaced by a version with finite number of names (see Section 2), can be seen as a specific instance of the logic G [4]. The logic G allows definition clauses with ∇-quantifiers in the head of the clauses. The predicate name of LGnω can be seen as the extended definition clause

(∇x.name x) =Δ T

of G. The scoping of variables and alternation of quantifiers in the head of a definition clause in G enforces the notion of freshness of a name with respect to a term. For example, in G, the fresh predicate would be encoded simply as

6M (∇x.fresh x M ) = T,

from which one can prove 6M∇x.fresh x M . Most of the examples studied in G so far seem to make use of only this aspect of ∇ in the head of definitions. We have seen that we can encode this notion of freshness, provided we explicitly type the term M above. Therefore it seems that, in principle, we can do most of the examples done in G in LGnω, with perhaps extra inductive definitions. Note that by restricting to LGnω, the unification problem that arises from rule applications (nameL and eqL) is a higher-order unification problem, whereas the more general fixed point rules of G require also permutation of names on top of higher-order unification. The latter can be seen as the higher-order version of the equivariant unification problem [1]. However, equivariant unification can still arises in proof search since the id rule requires checking equality modulo permutations.
The work on LGω and LGnω is closely related to nominal logic. We have adapted the notion of names and equivariant principle from nominal logic. However, the related notions of freshness and permutations are not taken as primitives of the logic. As a result, we do not have to deal explicitly with freshness and permutations, which is possible through the use of raising to encode explicitly the support of a term. As a consequence, we are able to obtain a rather simple induction rule for λ-terms. Similar induction principles have been obtained in other works, e.g., [13,26], but explicit assumptions about freshness and permutations are a part of the induction scheme. Note that these works aim at formalising the “informal” (meaning, not

machine-checked) practice often used in mathematic proofs, e.g., the Barendregt variable convention. Our approach is essentially HOAS-based, so it would require familiarity with this particular style of encodings, which is relatively more removed from the usual informal practice in mathematics. In [26], the authors impose some conditions on the schematic rules for induction, which is aimed at ruling out faulty reasoning with variables and binders. It is interesting to investigate whether there is a parallel to their rule conditions in our setting.
The idea of induction and/or recursion over open terms in a context has also been studied in the type theoretic setting, see e.g., [18] and more recently, [16,14]. The use of nominal constants seems very similar to the notion of parameters used in [16] to provide some form of implicit variable context, in which a ∇-like quantifier is used to type patterns involving these parameters. In [14], the variable context in an open term is represented explicitly; such a term-in-context is typed using a contextual type system. In these works, a distinction is drawn between computation types and representation types. An analog of this separation is the two-level encoding used in [5], where the object-logic can be seen as the “representation” level and the meta logic the “computation” level.
Acknowledgement. The author thanks Andrew Gacek for his help with the proof
assistant Abella. The author also thanks him and the anonymous referees for their comments on an earlier draft of the paper. This work is supported by a project funded by the Australian Research Council.

References
James Cheney. Equivariant unification. In Proceedings of RTA, volume 3467 of Lecture Notes in Computer Science, pages 74–89. Springer, 2005.
Andrew Gacek. System description: Abella – A system for reasoning about computations. Accepted to IJCAR 2008. Available from http://arxiv.org/abs/0803.2305, 2008.
Jean-Yves Girard. A fixpoint theorem in linear logic. Email to the linear@cs.stanford.edu mailing list, February 1992.
Andrew Gacek, Dale Miller, and Gopalan Nadathur. Combining generic judgments with recursive definitions. In F. Pfenning, editor, Proceedings of LICS 2008. IEEE Computer Society Press, 2008. To appear.
Andrew Gacek, Dale Miller, and Gopalan Nadathur. Reasoning in Abella about structural operational semantics specifications. Accepted to LFMTP 2008, April 2008.
M. J. Gabbay and A. M. Pitts. A new approach to abstract syntax involving binders. In Proceedings of LICS 1999, pages 214–224. IEEE Computer Society Press, 1999.
Lars Halln¨as and Peter Schroeder-Heister. A proof-theoretic approach to logic programming. II. Programs as definitions. Journal of Logic and Computation, 1(5):635–660, October 1991.
Dale Miller. Unification under a mixed prefix. Journal of Symbolic Computation, 14(4):321–358, 1992.
Raymond McDowell and Dale Miller. Cut-elimination for a logic with definitions and induction.
Theoretical Computer Science, 232:91–119, 2000.
Dale Miller and Catuscia Palamidessi. Foundational aspects of syntax. In Pierpaolo Degano, Roberto Gorrieri, Alberto Marchetti-Spaccamela, and Peter Wegner, editors, ACM Computing Surveys Symposium on Theoretical Computer Science: A Perspective, volume 31. ACM, September 1999.
Robin Milner, Joachim Parrow, and David Walker. A calculus of mobile processes, Part II. Information and Computation, pages 41–77, 1992.

Dale Miller and Alwen Tiu. A proof theory for generic judgments. ACM Trans. on Computational Logic, 6(4):749–783, October 2005.
Michael Norrish. Mechanising lambda-calculus using a classical first order theory of terms with permutations. Higher-Order and Symbolic Computation, 19(2-3):169–195, 2006.
Brigitte Pientka. A type-theoretic foundation for programming with higher-order abstract syntax and first-class substitutions. In Proceedings of POPL, pages 371–382, 2008.
Andrew M. Pitts. Nominal logic, a first order theory of names and binding. Information and Computation, 186(2):165–193, 2003.
Adam Poswolsky and Carsten Schu¨rmann. Practical programming with higher-order encodings and dependent types. In Proceedings of ESOP 2008, volume 4960 of LNCS, pages 93–107. Springer, 2008.
Davide Sangiorgi. A theory of bisimulation for the π-calculus. Acta Informatica, 33(1):69–97, 1996.
Carsten Schu¨rmann. Automating the Meta Theory of Deductive Systems. PhD thesis, Carnegie Mellon University, October 2000.
Peter Schroeder-Heister. Cut-elimination in logics with definitional reflection. In D. Pearce and
H. Wansing, editors, Nonclassical Logics and Information Processing, volume 619 of LNCS, pages 146–171. Springer, 1992.
Davide Sangiorgi and David Walker. π-Calculus: A Theory of Mobile Processes. Cambridge University Press, 2001.
Alwen Tiu. A Logical Framework for Reasoning about Logical Specifications. PhD thesis, Pennsylvania State University, May 2004.
Alwen Tiu. A logic for reasoning about generic judgments. Electr. Notes Theor. Comput. Sci., 174(5):3– 18, 2007.
Alwen Tiu. Cut elimination for a logic with generic judgments and induction. Technical report, January 2008. Extended version of LFMTP’06 paper. Available from http://arxiv.org/abs/0801.3065.
Alwen Tiu and Dale Miller. A proof search specification of the π-calculus. In 3rd Workshop on the Foundations of Global Ubiquitous Computing, volume 138 of ENTCS, pages 79–101, September 2004.
Alwen Tiu and Dale Miller. Proof search specifications for bisimulation and modal logics for the
π-calculus. Submitted. Available via http://arXiv.org/abs/0805.2785, 2008.
Christian Urban, Stefan Berghofer, and Michael Norrish. Barendregt’s variable convention in rule inductions. In Proceedings of CADE-21, pages 35–50, 2007.
