	Electronic Notes in Theoretical Computer Science 176 (2007) 95–111	
www.elsevier.com/locate/entcs

Distributive ρ-calculus
Horatiu Cirsteab, Cl´ement Houtmanna and Benjamin Wackb
a LORIA, ENS-Cachan, 61 avenue du Pr´esident Wilson, 94235 Cachan Cedex, France
Clement.Houtmann@loria.fr
b LORIA & NANCY I & NANCY II, BP 239, 54506 Vandoeuvre-l`es-Nancy Cedex France
{Horatiu.Cirstea, Benjamin.Wack}@loria.fr


Abstract
The rewriting calculus has been introduced as a general formalism that uniformly integrates rewriting and λ-calculus. In this calculus all the basic ingredients of rewriting such as rewrite rules, rule applications and results are first-class objects. The rewriting calculus has been originally designed and used for expressing the semantics of rule based as well as object oriented paradigms. We have previously shown that convergent term rewriting systems and classic strategies can be encoded naturally in the calculus.
In this paper, we go a step further and we propose an extended version of the calculus that allows one to encode unrestricted term rewriting systems. This version of the calculus features a new evaluation rule describing the behavior of the result structures and a call-by-value evaluation strategy. We prove the confluence of the obtained calculus and the correctness and completeness of the proposed encoding.
Keywords: rewriting calculus, lambda calculus, term rewriting systems, fixpoints.

Introduction
The ability to discriminate patterns is one of the main basic mechanisms the human reasoning is based on. Indeed, the ability to recognize patterns, i.e. pattern match- ing, is present since the beginning of information processing modeling. Instances of it can be traced back to pattern recognition and it has been extensively studied when dealing with strings [11], trees [9] or feature objects [1].
Pattern matching has also been widely used in functional programming (e.g. ML, Haskell, Scheme), logic programming (e.g. Prolog), rewrite based programming (e.g. ASF+SDF [14], ELAN [2], Maude [13], Obj∗ [8]), script programming (e.g. sed, awk). It has been generally considered as a convenient mechanism for expressing complex requirements about the argument of a function, more than a real computation paradigm.
The rewriting calculus [5,7] by unifying λ-calculus and rewriting, makes all the basic ingredients of rewriting explicit objects, in particular the notions of rule application and result. Its basic idea is to abstract on patterns instead of simple

1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2007.06.010

variables as in the λ-calculus, and then to produce terms such as f (x) d x, that could be represented in a λ-style as λf (x).x.
The rewriting calculus has been originally designed and used for expressing the semantics of rule based as well as object oriented paradigms [6]. Indeed, in rewriting calculus the term rewriting system (TRS) consisting of the rules a → b and b → c can be represented by the structure a d b b d c and its application to the constant a is encoded by the term (a d b b d c) a, i.e. the application of the structure to the argument. This latter term reduces in the rewriting calculus to b. If we consider the structure a d b a d c consisting of two rules with overlapping left-hand sides, the application (a d b  a d c) a evaluates to the structure b  c that can be seen as the non-deterministic choice between the two terms b and c.
General term rewriting systems and classical guiding strategies have been en- coded in the original rewriting calculus [5] by adding an additional operator that intuitively selects one of the elements from a set of results. We have shown that an equivalent operator can be encoded in the current version of the calculus but the encoding is limited in this case to convergent term rewriting systems [7].
We show in this paper that the previously proposed encoding can be extended to the general case, i.e. to arbitrary term rewrite systems. For this, a new eval- uation rule that enriches the semantics of the structure operator is added and an evaluation strategy is enforced by imposing a certain discipline on the application of the evaluation rules. This strategy is defined syntactically using an appropriate notion of value and is used in order to recover the confluence of the calculus that is lost in the general case.
Roadmap  In Section 2, we give the syntax and the evaluation semantics of the proposed calculus and we prove its confluence. Then in Section 3, we discuss the expressive power of the calculus. More precisely we propose an encoding of (non-convergent ) term rewriting systems in the calculus. Finally in Section 4, we conclude and give some perspectives of this work.

The distributive ρ-calculus: ρd-calculus
We present here the syntax and the semantics of the proposed calculus as well as its main properties.

Syntax
We consider in what follows the meta-symbols “ d ” (abstraction operator), and “  ” (structure operator), and the (hidden) application operator. We assume that the application operator associates to the left, while the other operators associate to the right. The priority of the application is higher than that of “ d “ which is, in turn, of higher priority than the “ ”. The symbols A, B, C,... range over the set T of terms, the symbols x, y, z,... range over the set X of variables (X ⊆ T ), the symbols a, b, c,... , f, g,h and string built from them range over a set K of term constants (K ⊆ T ). Finally, the symbols P, Q range over the set P of patterns,

(X ⊆ P ⊆ T ). All symbols can be indexed. The symbol stk is a special constant denoting matching failures and whose semantics will be given in the next section. To denote a tuple of terms A1 ... An, we will use the vector notation A. This notation will be used in combination with the application operator : AB means (((AB1) .. .)Bn).
The syntax of the basic rewriting calculus is inductively defined as follows:

P  ::= X | K | K P | stk	Patterns
T  ::= X | K | P d T | T T | T  T | stk	Terms
We call algebraic the patterns used in this version of the calculus and we usually denote a term of the form (... ((f A1) A2) .. .) An with f ∈ K by f (A1, A2,... , An). A linear pattern is a pattern where every variable occurs at most once.
The values represent intuitively the terms that we do not need to evaluate and are inductively defined by:

V ::= X | K | K V | P d T	Values
These values can be extended to the so-called structure values and stuck values, which will restrict the applications of the evaluation rules (γ), (ρ) and (δ):

Vγ	::= V | Vγ  Vγ	Structure Values
Vρδ  ::= V | stk	Stuck Values

One can notice that the only potential redexes (i.e. applications of variables, abstractions or structures) in values are inside abstractions. In what follows the symbol V ranges over the set V of values, the symbol V γ ranges over the set Vγ of structure values, the symbol V ρδ ranges over the set Vρδ of stuck values. All these symbols can be indexed.
Definition 2.1 (Free and bound variables) Given a term A, the sets of its free variables denoted FV(A) and bound variables denoted BV(A) are deﬁned as follows:


FV(x)  {x} FV(f )  ∅
FV(P d A)  FV(A) \ FV(P )
BV(x) = ∅ BV(f ) = ∅
BV(P d A) = BV(A) ∪ FV(P )



FV(A B)   FV(A) ∪ FV(B)
FV(A  B)   FV(A) ∪ FV(B)
FV(stk)   ∅
BV(A B) = BV(A) ∪ BV(B)
BV(A  B) = BV(A) ∪ BV(B)
BV(stk) = ∅

As usual, we work modulo “α-conversion” and adopt Barendregt’s “hygiene- convention” , i.e. free and bound variables have different names.
Definition 2.2 (Substitutions)
A substitution θ is a mapping from the set of variables to the set of terms. A ﬁnite substitution θ has the form {A1/x1 ... Am/xm}, and its domain {x1,... , xm} is denoted by Dom(θ). The application of a substitution θ to a term A such that Dom(θ) ∩ BV(A)= ∅, denoted by Aθ, is deﬁned as follows:

x θ   ⎧⎪⎨ Ai if xi ∈ Dom(θ)
⎪⎩ xi otherwise
fθ	 f
stkθ  stk

(P d A)θ  P d Aθ (A B)θ	 Aθ Bθ (A B)θ	 Aθ Bθ


We should point out that since we consider classes of terms modulo the α-conversion, any term A has a proper representative A' such that BV(A') ∩ Dom(θ)= ∅, which avoids potential variable captures.

Operational semantics
The evaluation mechanism of the rewriting calculus relies on the fundamental op- eration of matching that allows us to bind variables to their current values. In the general rewriting calculus we allow the matching to be performed modulo a congru- ence on terms. This congruence used at matching time is a fundamental parameter of the calculus and different instances are obtained when instantiating this parame- ter by a congruence defined, for example, syntactically, or equationally or in a more elaborated way [6].
For the purpose of this paper we restrict to syntactic matching, in which case the matching substitution, when it exists, is unique and can be computed by a simple recursive algorithm given for example by G. Huet [10].
The operational semantics of the ρd-calculus is defined by the following rules: (P d A) V ρδ →ρ Aθ	if Pθ ≡ V ρδ
(A  B) V ρδ →δ AV ρδ  B V ρδ

A (V γ  V γ) →γ AV γ  AV γ
1	2	1	2
The rule (ρ) can be applied if (and only if) such a substitution θ exists and in this case it is applied to the term A. If such a substitution does not exist then this rule can not be fired and the term is left as it is, representing a failure. Nevertheless, further reductions or instantiations are likely to modify V ρδ so that the appropriate

substitution can be found and the rule can be fired. The rule (δ) right-distributes the application over the structures. This gives the possibility, for example, to apply in parallel two distinct pattern abstractions to a given term. The rule (γ) is the counterpart of the rule (δ) and left-distributes the application of a term over a structure. The implicit conditions imposing that the arguments of an application are values are essentially related to the confluence of the calculus and are discussed in Section 2.3.
Definition 2.3 (One-step relation)
The one-step relation induced by a set of rewrite rules R is noted '→R and is the compatible closure of the relation induced by the set of rules R:
if t →R u then t '→R u;
if t '→R u then f (t1,... , t,... , tn) '→R f (t1,... , u,... , tn).
The multi-step relation, denoted →R, is the reflexive and transitive closure of '→R. Similarly, the multi-step relation induced by the rules of the ρd-calculus is denoted →ρδγ, with the compatible closure defined as follows.
Definition 2.4 (Compatible closure of →ρδγ)
In the distributive ρ-calculus, a context is a special term deﬁned by the following grammar:
C[ ]	::=	[ ] | P d C[ ] | T C[ ] | C[ ] T | C[ ]  T | T  C[ ] 
The compatible closure of →ρδγ is the (ﬁnest) relation →ρδγ such that if t →ρδγ u, then for any context C[ ], we have C[t] →ρδγ C[u].
Example 2.5 (Simple example + failures)
If we consider the terms (f (x) d (3 d 3) x) f (3) and (f (x) d (3 d 3) x) f (4)
then the following reductions are obtained:
(f (x) d (3 d 3) x) f (3) →ρ (3 d 3) 3 →ρ  3
(f (x) d (3 d 3) x) f (4) →ρ  (3 d 3) 4
The term (a d b  a d c) a reduces to b  c:
(a d b  a d c) a	→δ	(a d b) a  (a d c) a	→ρ	b c
The term (a d b b d c) a reduces similarly to b (b d c) a.
Notice that the term (a d b b d c) a does not reduce to b as one might expect. Instead, the fact that the rule b d c fails to apply to a (in classical rewriting) is also recorded in the final result as a (failure) term in normal form. This approach is very interesting when we want to handle explicitly the failures by allowing rules that can handle such particular terms (e.g. for an exception handling mechanism). However, if the user is not interested in the explicit manipulation of matching failures and just wants to ignore such a behavior, we need to handle uniformly matching failures and eliminate them when not significant for the computation.
For this, we first want to represent all the definitive failures by the constant stk
whose exact semantics should be the following: if for any reduction of the argument,

there exist no matching substitution, then the ρ-redex is reduced to stk:
6θ1, θ2, 6B', Bθ1 →ρδγ B' ⇒ Pθ2 /≡ B'
(P d A) B →stk stk
One can easily notice that B can contain a ρ-term with an arbitrary (possibly infi- nite) number of possible reductions which should be all explored in order to decide if the appropriate substitution exists. The condition of this rule is thus undecidable and consequently the operational semantics of the calculus cannot be defined us- ing such a rule. Nevertheless, in practice and particularly when dealing with term rewriting systems we do not need to be so general and a sufficient condition can be used.
Definition 2.6 (Definitive failures)
The relation /± on У × 7 is inductively deﬁned by:
stk	/± g B	if g /≡ stk
stk	/± Q d B
f P1 ... Pm /± g B1 ... Bn	if f /≡ g or n /= m or Ei, Pi /± Bi f P	/± stk

f P	/± Q d B
Starting from this relation, the operational semantics of the ρstk-calculus are defined by the rules (ρ), (δ), (γ) introduced above and by the following rules:
(P d A) B →stk stk	if P /± B
stk A →stk A A stk →stk A stk A →stk stk
As mentioned previously, these rules are used to determine, propagate or elimi- nate the definitive failures. If the matching between the left-hand side of a rule and the argument the rule is applied on is definitive then the failure is made explicit by transforming the application into a stk; this is done by the first rule. Structures can be seen as collections of results and thus we want to eliminate all the (matching) failures from these collections; this is done by the next two rules. On the other hand, a stk term can be seen as an empty set of results; the last rule corresponds then to the (δ) rule dealing with empty structures and thus, to a propagation of the failure. We will see in Section 3 why the stk-rule corresponding to the (γ) rule is not suitable.
The →stk induced relations are denoted →stk, →stk. The relation →ρδγ ∪ →stk is

denoted '→stk and its transitive and reflexive closure is denoted →stk.

ρδγ
Example 2.7 (failures)
The term (a d b  b d c) a reduces now to b:
ρδγ

(a d b  b d c) a  →δ	(a d b) a (b d c) a  →ρ  b  (b d c) a
→stk  b  stk →stk  b





Properties

As we have mentioned in the previous section the ρd-calculus would not be confluent if we did not restrict the application of an abstraction and of a structure to be effective only when the argument is a value. When this restriction is not imposed on the (ρ) rule, potentially non-joinable critical pairs between the rules (ρ) and (γ) are obtained. Intuitively, restricting the argument of the application in the rule (ρ) to a value guarantees that it has been reduced enough to check if there exists a unique match between the pattern and the argument. Alternatively, we can accept any term as argument and use a more complex matching algorithm to find the appropriate substitution.
Example 2.8 (ρ without values)
When the conditions on values in the rule (ρ) are omitted, non-confluent reductions can be obtained:
(x d f (x, x)) a  b
¸¸¸¸¸¸¸¸¸¸ γ

ρ
J 
f (a  b, a  b)
γ
J 
f (a, a  b)  f (b, a  b)
γ,γ
J 
f (a, a) f (a, b) f (b, a) f (b, b)
¸¸¸¸¸¸¸¸¸¸	z 
(x d f (x, x)) a  (x d f (x, x)) b
ρ,ρ
J 
f (a, a) f (b, b)


Similarly, when the argument of the application is not restricted to a value in the (δ) rule, a critical pair between the rules (δ) and (γ) is obtained. The conflu- ence can be retrieved either by enforcing this condition or by using an associative- commutative underlying theory for the structure operator.
Example 2.9 (δ without values)
When no conditions are imposed in the rule (δ) non-confluent reductions can be

obtained:

(a b) (c  d)
¸¸¸¸¸¸¸ δ

γ J	¸¸¸¸¸¸ z

(a b) c (a b) d
δ,δ
J 
¸¸
a (c  d)  b (c  d)
γ,γ
J 

ac bc ad bd	a c ad bc bd 


For the (γ) rule, the condition imposes that the terms in the structure do not reduce to a failure. If one of them can lead to a failure then it should be first reduced to stk and then eliminated from the structure using the stk rules.
Example 2.10 (γ without values)
If the terms of a structure applied to an argument are not restricted to values then the application of the rule (γ) can lead to non-confluent reductions:
(x d f (x)) (stk  a)
¸¸¸¸¸¸¸¸stk
J	¸¸¸¸¸¸¸¸ z_
(x d f (x)) stk (x d f (x)) a	(x d f (x)) a
ρ,ρ	ρ
J	J 
f (stk) f (a)	f (a)

It is quite clear that using a set of values leads to a call-by-value reduction strategy. The two calculi presented above are confluent in this case.
Theorem 2.11 (Confluence of left-linear ρd-calculus)
If all patterns are linear, the relation →ρδγ is confluent.
Proof. The proof is detailed in [4]. It uses the parallel reduction technique intro- duced for the λ-calculus in [12].	 
Theorem 2.12 (Confluence of left-linear ρstk-calculus)
stk	d
If all patterns are linear, the relation →ρδγ is confluent.
Proof. The proof is detailed in [4]. It is based on the proof introduced in [7,16]. 
The unrestricted ρd-calculus is non-confluent since the Klop counter example holds in this case (see [4]).
ρd-calculus modulo some congruence
Defining a similar calculus modulo some congruence is certainly interesting but out of the scope of this paper. Such an extension would induce an encoding of general term rewriting systems just as our present calculus induces the encoding of syntactic term rewriting systems presented in the next section.

The main difficulty in defining such a calculus comes from the fact that matching modulo the given congruence is generally non-unitary (at least for classical theories like associativity and commutativity). Indeed there might exist (infinitely) many solutions and there exists no natural ordering for these solutions (i.e. substitutions). For example let us consider the term (f (x, y) d x) f (a, b) when working modulo the commutativity of the symbol f . There exist two solutions of the matching problem: {a/x, b/y} and {b/x, a/y}. Depending on the substitution we use, we
obtain two possible non-confluent reductions:
(f (x, y) d x) f (a, b)  C   (f (y, x) d y) f (a, b)
ρ	ρ
J	J 
a  b	b a
In order to recover confluence, the only solution may finally consist in declaring the structure operator as commutative, associative and idempotent.
Moreover, a particular reduction strategy should be enforced when working mod- ulo some congruence. This strategy should prevent matching against uninstantiated terms, which would lead to non-confluent reductions as shown in the following ex- ample where the symbol “::” is considered associative:
(z d ((x :: y d x) (a :: z))) (b :: c)
ρ

J 
(x :: y d x) (a :: (b :: c))
ρ
J 
z˛
((z d a) (b :: c))
ρ
J 

a  (a :: b)	a
Finally, the notion of deﬁnitive failures should be adapted to the reduction strategy of the new calculus in order to guarantee the coherence with the considered matching.

Encoding Term Rewriting Systems
We have already shown [6,16] that (the reduction of) convergent term rewriting systems (TRS) can be encoded in the classical rewriting calculus. The restriction to convergent TRS is due to the “uncomplete” treatment of the structure operator in the classical rewriting calculus where the application operator is left-distributive over the structure operator but not right-distributive. As we have already seen this choice was motivated by the meta-properties the calculus should have. More precisely, adding right-distributivity would lead to a non-confluent calculus. Never- theless, this property can be retrieved either by enforcing a certain discipline on the evaluation (strategy) [5] or by restricting the term formation as done in this paper. In ρstk-calculus the (γ) rule defines the right-distributivity of the application over the structure and in this section we show how this feature can be used to
encode (non-confluent) TRS in the ρstk-calculus.

More precisely, given a TRS R we build the terms Ω1 and ΩR such that
1 m represents (i.e. reduces to) the one-step reduced of m w.r.t. R,
ΩR m represents the normal form of m w.r.t. R (if it exists).
Rule selection
As we wish to compute the normal forms, we obviously wish to decide when the reduction is effective, i.e. when some rule of R can be applied, and then to discrim- inate cases:
if some rule of R can be applied to m, then we reduce m,
if not, m is a normal form, and m is left as it is.
This ability to discriminate cases, i.e. to select between two (or more) terms which one can be applied successfully to a given argument, is encoded in the first term usually defined [7] in the rewriting calculus by:
first  u d v d x d (stk d v x y d y) (u x) One can easily check that first has the intended behavior:
(first A1 A2) t →stk V ρδ if A1 t →stk V ρδ;
ρδγ	1	ρδγ	1
(first A1 A2) t →stk V ρδ if A1 t →stk stk and A2 t →stk V ρδ.

ρδγ	2
ρδγ
ρδγ	2

Intuitively, if we replace the term A1 by the ρ-term R encoding a TRS R and the term A2 by the identity then we obtain the desired discrimination facility: the case
Rt →stk V ρδ corresponds to a reduction of t w.r.t. R while Rt →stk stk corresponds
ρδγ	1	ρδγ
to the case where no rule can be applied to t and thus the term is left as it is (in
fact the identity is applied to this term).
As the normal form of some terms w.r.t. a non-confluent TRS is not unique, we will obviously have to deal with sets of results. We choose here to encode sets of results as structures. The empty set is represented by stk and the union of two sets is represented using the structure operator. In the rewriting calculus the representation of some set is not unique as the structure operator is not considered as commutative, associative or idempotent.
Since we wish to discriminate cases such as no rule of R matches m, reformulated as the set of one-step reduced of m is empty, we need to pattern match on stk. The statement if the set M is empty, then T1 else T2 can be encoded by
first (stk d T1) (x d T2) M
Since we need the ability to pattern match on stk we have the rule
stk A →stk stk
that complements the (δ) rule but not the symmetric one
A stk →stk stk

that would complement the (γ) rule and that would correspond to a strict propa- gation of the failure. 1

Context propagation
When rewriting w.r.t. a rewriting system, the application of the rules can be done on any subterm of the rewritten term. In the rewriting calculus, a rule is always applied on the head of the term and thus the encoding of a TRS has to propagate explicitly the application deeper in the term. For example, the application of the rewrite rule a → b to the term f (a) is naively encoded by the term (f (x) d f ((a d b) x)) f (a) that eventually reduces, as expected, to f (b).
If the application of a rewrite rule fails on all the subterms of a given term then the ρ-term encoding the application should be reduced to stk. On the other hand, if we apply the same naive methodology as above for propagating the rule application into contexts then the application of the rewrite rule a → b to the term f (b) is encoded by the term (f (x) d f ((a d b) x)) f (b) that reduces to f (stk) and not to stk.
More generally, the propagation of stk should be performed w.r.t. to any context. Therefore, for each symbol f of arity n ≥ 1 from a signature Σ we define a term Γf :


Γf 
⎛ stk d nop(stk)	⎞

ν d xn d (nop(z) d z) (first ⎝ y d nop(f (x1,... , xk−1, y,... , xn)) ⎠(ν xk))
where nop ∈/ Σ and for any n ≥ 1, xn d M  x1 d x2 d ... d xn d M .
Each Γf allows us to express the application of a given term to the subterm Mk
of some term f (M1,... , Mn). The following lemma states the behavior of Γf :
Lemma 3.1 Let f ∈ Σ be a symbol of arity n. Let M1, ..., Mn be some algebraic
terms and T an arbitrary term. Let V γ, ... V γ be some values in V . Then
⎛ 1	γ⎞
f (M1,... , Mk−1,V γ,... Mn)
Γf T M ... Mn →stk ⎜ ...	⎟

k	1	ρδγ
⎝ f (M ,... ,M	,V γ,... ,M ) ⎠


if T M  →stk V γ  ...  V γ and
1	k−1	p	n

k	ρδγ	1	p
Γf T M1 ... Mn →stk stk if T Mk →stk stk.
k	ρδγ	ρδγ
Proof. The proof of this lemma just consists in checking that the reductions hold. It is presented in [4].	 
Let us remark that for any patterns P1 and P2 the term first (P1 d stk) (P2 d M ) N will always reduce to the same term as (P2 d M ) N . Indeed the first operator does not check if N matches P1 but if (P1 d stk) N reduces to stk which

1 This strict behavior can be obviously encoded using the rule stk d stk.

is always the case. Consequently, the term


ν d xn

stk d stk
d (first
y d f (x1,... , xk−1, y,... , xn)
⎞
⎠ (ν xk))

does not have the same behavior as Γf . The use of the constant nop in this latter term allows us to claim that a reduction to stk is equivalent to a pattern matching failure.
We can now define the term Γf
Γf  Γf	 Γf
1	n
that represents intuitively the application of some term to each subterm Mk of a term M = f (M1,... Mn). The structure grouping together the different results obtained when a term T is applied to M is obtained by reducing the ρ-term Γf T M :
Γf T M →stk Γf T M	 Γf T M 
ρδγ	1	n
One-step reduction
Let us consider now a term rewriting system R = {l1 → r1,... , ln → rn}. We denote by '→R the compatible closure of R, →R its transitive and reflexive closure. The multiset of all one-step reducts of a term M is denoted {T | M '→R T } where the arity of some term T is the number of one-step reductions from M to
T . Finally we write M →R! T if and only if M →R T and there exists no term N such that T '→R N . The multiset of all normal forms of a term M w.r.t. R is denoted {T | M →R! T } where the arity of some term T is the number of multi-step reductions from M to T .
The term that encodes the one-step reduction w.r.t. a term rewrite system R is

denoted by Ω1
and defined by


1   ω1	1

where ω1
⎛ ...  li d ri  ...	for all li → ri ∈ R	⎞
... f (x1,... , xn) d Γf (π π) x1 ... xn ... for all f of arity n ≥ 1 ⎠


The definition of ω1
can be cut in two parts: the first one encodes the rewriting

at the head position w.r.t. R since we only transcript each rule of R by the corre-
sponding rule in the ρstk-calculus; the second one uses the terms Γf to express that

d
we also rewrite inside contexts. The term Ω1
k
completes a fixpoint by means of the

expression (π π) in order to iterate the use of the Γk and to get down in the term
as much as needed.

Theorem 3.2 Let M be an algebraic term.
If {T | M '→R T } = ∅ then


If {T | M '→R T } /= ∅ then
1 M →stk stk .



Ω1 M →stk T
 ...  T
with {T | M '→
T } = {T ,... T } .

R	ρδγ	1	p
R	1	p

Moreover as the left-linear ρstk-calculus is confluent, if R is left-linear and since
T1  ...  Tp and stk are in normal form, then these are the unique normal forms of
1 M.
Proof. The proof of this Theorem is done by induction on the term M . It is presented in [4].	 

Normal form reduction
We now define the term that encodes the normal form reduction w.r.t. a term rewrite system R.
More precisely, we want to define a term ΩR such that its application to some term M , ΩRM reduces to M if Ω1 M reduces to stk (M is a normal form) and continues applying the term ΩR to the result of Ω1 M if it is different from stk. We

define thus the term

where
ΩR  ωR ωR

ωR  s d x d first (stk d x) (z d (s s) z) (Ω1 x)
Let us introduce now the relation−⊂ that represents intuitively the observability
of some “result” in a structured set of terms.

Definition 3.3 The relation−⊂
for any term M , M −⊂ M ;
is defined inductively by:

for any terms M , N1 and N2, M −⊂ N1 ⇒ M −⊂ N1  N2 and M −⊂ N2  N1.
Using the above relation we can state the correctness and completeness of the encoding:
Theorem 3.4 Given two algebraic terms M and M ',


M →R!
M '	⇐⇒	ET, ΩR
M →stk T and M '−⊂ T.

Moreover if R terminates on M then
Ω M →stk T  ...  T with {T | M →  T } = {T ,... T } .
R	ρδγ	1	p	R!	1	p
Moreover as the left-linear ρstk-calculus is confluent, if R is left-linear and since
T1  ...  Tp is a normal form, it is the unique normal form of ΩR M.

Proof. The proof of this theorem is done first by induction on the term M , and then by induction on the largest length of a reduction w.r.t. R of M to a normal form. It uses the Theorem 3.2 and it is presented in [4].	 



This theorem claims that our encoding of some term rewriting system encodes its reductions in the ρstk-calculus.  Indeed the ρstk-calculus computes the finite
d	d
multiset of normal forms of any term on which the term rewriting system terminates.
Moreover if the system is divergent on some term, all reductions are still encoded since the ρstk-calculus computes a non-terminating reduction, generating normal forms as in a breadth first search of the reduction tree. All normal forms are computed at some iteration although the computation never stops, and may even never stop generating new normal forms.

Example 3.5 (Oriented groups) Let us consider the group theory axioms ori- ented as follows:

Σ= {e(0), i(1), f (2)}





⎧⎨ f (x, e) → x
⎩ f (e, x) → x
⎧⎨ f (x, i(x)) → e
⎩ f (i(x), x) → e

f (f (x, y), z) → f (x, f (y, z))



This TRS is non-confluent since

f (f (i(i(a)), i(a)), a)
,,,,,,,

_,.,,,,,,
f (i(i(a)),f (i(a), a))

J 
f (i(i(a)), e)

J 
i(i(a))
J 
f (e, a)

J 
a


The terms ω1 , Ω1 , ωR and ΩR are then deﬁned by:
R	R

1
R
⎛ f (x, e) d x	⎞
⎜ f (e, x) d x	⎟
⎜ f (x, i(x)) d e	⎟
⎜ f (i(x), x) d e	⎟
⎜ f (f (x, y), z) d f (x, f (y, z))	⎟
π d⎜ i(x) d (nop(z) d z) (first ⎛ stk d nop(stk) ⎞	⎟,

⎜	⎝ y d nop(i(y))
⎠ ((π π) x))	⎟

⎜ f (x ,x ) d (nop(z) d z) (first ⎛ stk d nop(stk)	⎞	⎟
⎜	⎝	⎠ ((π π) x1))⎟
y d nop(f (y, x2))
⎜	⎛	⎞	⎟
⎜⎝ f (x ,x ) d (nop(z) d z) (first ⎝ stk d nop(stk)	⎠	⎟⎠



1   ω1
ω1 ,




and
ωR  s d x d first (stk d x) (z d (s s) z) (Ω1 x)

ΩR  ωR ωR.
Then we have the following reductions in the ρstk-calculus:
one-step reductions


1 f (f (i(i(a)), i(a)), a)	→stk
1 f (i(i(a)),f (i(a), a))	→stk
1 f (i(i(a)), e)	→stk
1 i(i(a))	→stk
1 f (e, a)	→stk
1	stk
R	ρδγ
f (i(i(a),f (i(a), a))  f (e, a) f (i(i(a)), e)
i(i(a))
stk a stk

normal form reduction

Ω  f (f (i(i(a)), i(a)), a)	→stk
i(i(a))  a

This latter reduction expresses well the non-confluent reductions of the term f (f (i(i(a)), i(a)), a) w.r.t. the TRS R since the result i(i(a)) a represents the two normal forms.

Conclusions
We have studied the confluence and the expressive power of a rewriting calculus featuring left-distributivity of the application over the structure, whereas only right- distributivity was available in former versions. The confluence of the calculus, which is endangered by careless distributivity of one operator over another, has been recovered using a call-by-value reduction, and is proved using the usual parallel reduction technique.
Since, in the rewriting calculus, a structure of ρ-rules can be seen as a naive encoding of a term rewrite system then the right-distributivity rule describes the application of each rewrite rule in the structure to the argument. Moreover, struc- tures can be also used to denote the sets of results obtained as result of such an application and the left-distributivity describes the application of a given rule (or structure of rules) to many distinct arguments in parallel. Thus, we can encode the simultaneous exploration of many reduction paths in a term.
Using the left-distributivity together with some earlier techniques, we obtain a better handling of matching failures, and we are able to faithfully encode the behavior of any term rewriting system, even non-confluent. This allows for many interesting theoretical developments, such as the computation of all the normal forms of a given term, which is needed, for example, for the completion of a term rewriting system.
The extension to general term rewriting systems is considered as the next step of this work. A major difficulty when dealing with matching modulo some congruence consists in the multiplicity of solutions and since these solutions cannot be ordered in any natural way, the structure operator should be then considered as associative, commutative and idempotent. Moreover the notion of definitive failures should be adapted to the considered matching theories and a call-by-value strategy should be enforced to prevent matching against uninstanciated terms and thus to avoid loosing matching solutions.


Related Work.
V. van Oostrom has widely studied the confluence of a λ-calculus with patterns [15], but which does not feature structures. Our encoding of TRS shares some similarities with the one presented by S. Byun et al. [3] that describes an untyped encoding of every strongly separable orthogonal TRS into λ-calculus. However, they need some really strong assumptions on the confluence of the original system.

Acknowledgement
We would like to thank Claude Kirchner for the useful interactions we had on the topics of this paper and to Germain Faure for his detailed and very useful comments on a preliminary version of this work.

References
H. Ait-Kaci, A. Podelski, and G. Smolka. A feature constraint system for logic programming with entailment. Theoretical Computer Science, 122(1-2):263–283, 1994.
P. Borovansky, C. Kirchner, H. Kirchner, and P.-E. Moreau. ELAN from a rewriting logic point of view. Theoretical Computer Science, 2(285):155–185, 2002.
S. Byun, R. Kennaway, V. van Oostrom, and F. de Vries. Separability and translatability of sequential term rewrite systems into the lambda calculus. Technical Report tr-2001-16, University of Leicester, 2001.
H. Cirstea, C. Houtmann, and B. Wack. Distributive rho-calculus. Technical report, INRIA Lorraine, 2006. Available at http://hal.inria.fr.
H. Cirstea and C. Kirchner. The rewriting calculus — Part I and II. Logic Journal of the Interest Group in Pure and Applied Logics, 9(3):427–498, May 2001.
H. Cirstea, C. Kirchner, and L. Liquori. Matching Power. In A. Middeldorp, editor, Proceedings of RTA’2001, Lecture Notes in Computer Science, Utrecht (The Netherlands), May 2001. Springer-Verlag.
H. Cirstea, L. Liquori, and B. Wack. Rewriting calculus with fixpoints: Untyped and first-order systems. Post-procededings of TYPES, 2003.
K. Futatsugi and A. Nakagawa. An Overview of Cafe Project. In Proc. of CafeOBJ Workshop, 1996.
C. M. Hoffmann and M. J. O’Donnell. Pattern matching in trees. Journal of the ACM, 29(1):68–95, 1982.
G. Huet. Resolution d’Equations dans les Languages d’Ordre 1,2,...,ω. These de Doctorat D’Etat, Universite Paris VII, 1976.
D. E. Knuth, J. Morris, and V. Pratt. Fast pattern matching in strings. SIAM Journal of Computing, 6(2):323–350, 1977.
M. Takahashi. Parallel reduction in lambda-calculus. Information and Computation, 118(1):120–127, 1995.
The Maude Team. The Maude Home Page, 2003. http://maude.cs.uiuc.edu/ .
A. van Deursen. An Overview of ASF+SDF. In Language Prototyping, pages 1–31. World Scientific, 1996.
V. van Oostrom. Lambda Calculus with Patterns. Technical Report IR-228, Faculteit der Wiskunde en Informatica, Vrije Universiteit Amsterdam, 1990.
B. Wack. Typage et d´eduction dans le calcul de r´e´ecriture. Th`ese de doctorat, Universit´e Henri Poincar´e
- Nancy I, Oct. 2005.
