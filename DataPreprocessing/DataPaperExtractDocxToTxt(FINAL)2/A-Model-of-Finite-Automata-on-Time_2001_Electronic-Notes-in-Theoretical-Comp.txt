Electronic Notes in Theoretical Computer Science 42 (2001)
URL: http://www.elsevier.nl/locate/entcs/volume42.html 16 pages


A Model of Finite Automata on Timed ω-Trees

Salvatore La Torre a,b and Margherita Napoli b
a University of Pennsylvania
b Universit`a degli Studi di Salerno
sallat,napoli@unisa.it


Abstract
In the last decade Alur and Dill introduced a model of automata on timed ω- sequences which extends the traditional models of finite automata. In this paper we present a theory of timed ω-trees which extends both the theory of timed ω- sequences and the theory of ω-trees. Main motivation is to introduce a new way of specifying real-time systems and provide tools for studying decidability problems in the field of quantitative temporal logics. We study properties and decision problems of the obtained classes of timed ω-tree languages. Our main result is the decidability of the emptiness problem for all the classes of timed ω-tree automata we consider.

Introduction
In the last decades, a significant amount of literature has been devoted to the theory of finite automata on ω-sequences and ω-trees. In the sixties with their pioneering works Bu¨chi [3], McNaughton [11], and Rabin [12] introduced this theory, which, more recently, turned out to be an important source of tools for synthesis and verification of nonterminating computer programs. A recent survey on automata on infinite objects is [15]. Connections with Temporal Logic have been particularly successful [4,7,16,17]. The main results in this perspective consist of reducing temporal logic problems to decidable problems in the automata theory field. To model and verify real-time systems (that is, systems that interact with physical processes and whose correct running crucially depends upon real-time considerations) finite automata, as well as other specification tools, have been powered with clocks in order to explic- itly consider time. In [2] a model of finite automata on timed ω-sequences is proposed and a theory of timed languages is developed. In this model time grows continuously in the range of the positive real numbers. Here we present an extension to timed ω-trees of previously existing automata models and, as in [2], we assume that time is dense. Our aim is the introduction of a new formalism to specify real-time systems and provide a robust theory for
◯c 2001 Published by Elsevier Science B. V. Open access under CC BY-NC-ND license.


studying decidability problems of branching-time temporal logics with timing constraints. Branching-time logics are suitable for reasoning about nondeter- minism which, in turn, is useful to model concurrent programs (nondetermin- istic interleaving of atomic processes). Moreover, they provide an existential path quantifier, which allows to express lower bounds on nondeterminism and concurrency, particularly helpful in applications such as program synthesis. Furthermore, inevitability of a predicate and possibility of a predicate can be distinguished and the closure under semantic negation of the logic is ensured. See also [4,6]. We consider timed ω-trees, i.e. ω-trees in which a real-valued time of occurrence is associated with each node, and introduce finite automata on timed ω-trees. We obtain various models by considering both determin- istic and nondeterministic paradigms and both Muller and Bu¨chi acceptance conditions. We prove that, differently from the timed ω-sequences, for timed ω-trees the Muller acceptance condition turns out to be strictly stronger than the Bu¨chi one, and the nondeterministic Bu¨chi and the deterministic Muller acceptance conditions result to be not comparable. Moreover, we prove that all the classes are closed under both union and intersection, but they are not closed under complementation. The nondeterministic classes turn out to be closed also under concatenation and ω-iteration. As regards decision problems, we prove the decidability of the emptiness problem for these models: this re- sult is important in connection to the application to temporal logic [10]. We also show that the equivalence problem is undecidable for nondeterministic timed tree automata while it is decidable for the deterministic ones. Finally, we introduce the concept if highly-deterministic timed tree automaton and prove that a language accepted by a timed tree automaton is not empty if and only if this automaton contains a highly-deterministic timed tree automaton. Since our proof is not constructive this result cannot be used to obtain an alternative proof of the decidability of the emptiness problem. Anyway, it is still interesting since it can be used to relate timed tree automata to timed graphs so reducing the finite satisfiability of Tctl [1] to the emptiness problem of Bu¨chi tree automata (see [9]).

The model
In this section we introduce the concept of timed ω-tree and timed ω-tree automaton and define various models of automata, by considering both de- terministic and nondeterministic paradigms and different conditions on the acceptance of a timed ω-tree.
Let Σ be an alphabet and dom(t) be a subset of {1,..., k}∗, for a positive integer k, with the properties:
if wj ∈ dom(t), then wi ∈ dom(t) for all i such that 1 ≤ i < j;
if w ∈ dom(t), then there exists i ∈ {1,..., k} such that wi ∈ dom(t);
if w ∈ dom(t) and w = ui, with i ∈ {1,..., k}, then u ∈ dom(t).


A Σ-valued ω-tree is a mapping t : dom(t) −→ Σ. Each w ∈ dom(t) is called a node of t , or simply a node. Given a node w, we denote with deg(w) the arity of w, that is deg(w) = max{j | wj ∈ dom(t)}, and with pre(w) the set of the prefixes of w. Moreover, a path in t is a maximal subset of dom(t) linearly ordered by the prefix relation. Often, we will denote a path with the ordered sequence of its nodes, that is, given a path π we denote it as π = v0, v1, v2,... where v0 is ε. With In(t|π) we denote the set of the symbols labelling infinitely many nodes on the path π in t. Let ঩+ be the set of the non negative real numbers. A timed Σ-valued ω-tree is a pair (t, τ ) where t is a Σ-valued ω-tree and τ , called time tree, is a mapping from dom(t) into ঩+ with the properties:
positiveness: τ (w) > 0 ∀w ∈ dom(t) − {ε} and τ (ε) ≥ 0;
progress: ∀ path π and ∀ x ∈ ঩+ ∃ w ∈ π such that Σv∈pre(w) τ (v) ≥ x.
We consider timed ω-trees as objects accepted by a finite-state automaton. We assume that the nodes of an ω-tree becomes available as the time elapses, that is at a given time only a finite portion of the ω-tree is available for reading. Then, we capture this situation by labelling each node of a timed ω- tree by a pair (symbol, real number). The real number is (except for the root ε, where this number is assumed to be the absolute time of occurrence) the time which has elapsed since the parent node has been scanned at input. The positiveness property of a time tree implies that a positive delay exists between any two consecutive nodes. Progress requirement guarantees that infinitely many events (i.e. nodes appearing at input) cannot occur in a finite slice of time (nonzenoness). Given a timed ω-tree (t, τ ) and a node w, we denote with γw the time at which w is available at input, that is γw =  v∈pre(w) τ (v).

Furthermore, we denote with Tk
the set of the Σ-valued timed ω-trees (t, τ )

with dom(t) ⊆ {1,..., k}∗. From now on, in this paper we use the term tree to refer to a Σ-valued ω-tree for some alphabet Σ and the term timed tree to refer to a timed Σ-valued ω-tree. Moreover, a (timed) tree language is any set of (timed) trees.
Now, we introduce an automaton recognizing timed tree languages. It is similar to the one defined in [2] for timed ω-sequences and it models a system with only one (real-valued) clock that scans the time for the whole system. A finite set of clock variables (also said simply clocks) are used for testing timing constraints on which state transitions depend. Each clock can be seen as a chronograph synchronized with the system clock. Their values can be read or set to zero (reset): after a reset, a clock restarts automatically. In the automaton the timing constraints are expressed by the clock constraints. Let C be a set of clocks, the set of clock constraints Φ(C) contains:
x ≤ y + c, x ≥ y + c, x ≤ c and x ≥ c where x, y ∈ C and c is a rational number;
¬δ and δ1 ∧ δ2 where δ, δ1, δ2 ∈ Φ(C).
Furthermore, a clock interpretation is a mapping ν : C −→ ঩+. If ν is a clock


interpretation, λ is a set of clocks and d is a real number, we denote with [λ → 0](ν + d) the clock interpretation that for each clock x ∈ λ gives 0 and for each clock x /∈ λ gives the value ν(x)+ d. A nondeterministic timed tree transition table is the 5-tuple (Σ,S,S0,∆,C), where:
Σ is an alphabet;
S is a finite set of states;
S0 ⊆S is the set of starting states;
C is a finite set of clocks;
∆ is a finite subset of   (S × Σ × Sk × (2C)k × Φ(C)).
k≥0
A timed tree transition table is deterministic if |S0| = 1 and for each pair of dif- ferent tuples (s, σ, s1,..., sk, λ1,... , λk, δ) and (s, σ, s' ,..., s' , λ' ,..., λ' , δ')
1	k	1	k
in ∆, δ and δ' are inconsistent (i.e., δ ∧ δ' = false for all clock interpreta- tions). Informally, a transition rule (s, σ, s1,..., sk, λ1,..., λk, δ) ∈ ∆ can be described as follows. Suppose that when the system entered the state s the
clock values were given by ν and after a delay d the symbol σ is ready at in- put. The system can actually take the transition (s, σ, s1,..., sk, λ1,..., λk, δ) if the current clock evaluation (i.e. ν + d) satisfies the clock constraint δ. As a consequence of the transition, the system will enter the states s1,..., sk with clock values given respectively by [λ1 → 0](ν + d),..., [λk → 0](ν + d). Then, a timed tree transition table (Σ, S, S0, ∆, C) associates to each node of a timed tree a state belonging to S and a clock interpretation, according to the transition rules in ∆. Formally, the behaviour of a timed tree transition table is captured by the following definition. Let A=(Σ, S, S0, ∆, C) be a (deterministic or nondeterministic) timed tree transition table and (t,τ ) be a timed tree. A run of A on (t,τ ) is a pair (r,ν), where:
r:dom(t)−→S and ν:dom(t)−→ ঩C;
r(ε) ∈ S0 and ν(ε) = ν0 where ν0(x)=0 ∀x ∈ C;
∀w ∈ dom(t), k = deg(w): (r(w),t(w),r(w1),. . . ,r(wk),λ1,..., λk,δ)∈∆,
ν(w)+τ (w) fulfils δ and ν(wi)= [λi → 0] (ν(w)+τ (w)) ∀i ∈ {1,..., k}.
Clearly, deterministic transition tables have at most one run for each timed tree. Given a transition table we define a timed tree automaton by spec- ifying the acceptance conditions: obviously, the runs of an automaton are those of the corresponding transition table. A nondeterministic (resp. deter- ministic) Bu¨chi timed tree automaton is a 6-tuple A=(Σ,S,S0,∆,C,F), where (Σ,S,S0,∆,C) is a nondeterministic (resp. deterministic) timed tree transition table and F⊆S is the set of the final states. A timed tree (t,τ ) is accepted by a Bu¨chi timed tree automaton A if an only if there is a run (r,ν) of A on (t,τ ) such that In(r|π) ∩ F /= ∅ for each path π in r. The language accepted by A, denoted by T (A), is defined as the set {(t, τ ) | (t, τ ) is accepted by A}. We define a nondeterministic (resp. deterministic) Muller timed tree automaton


analogously. The only changes needed are: an accepting family Φ ⊆ 2S for the set of final states F and the new acceptance condition “In(r|π) ∈ Φ” for “In(r|π) ∩ F /= ∅”. Hence, we have four classes of timed tree auto- mata and we denote them (and the corresponding classes of languages) with the abbreviations: TMTA (nondeterministics Muller timed tree automata), TBTA (nondeterministic Bu¨chi timed tree automata), DTMTA (determinis- tic Muller timed tree automata) and DTBTA (deterministic Bu¨chi timed tree automata). Moreover, we denote the classes of (deterministic) Muller tree au- tomata (and the corresponding classes of languages) with (D)MTA and (de- terministic) Bu¨chi tree automata (and the corresponding classes of languages) with (D)BTA. The classes MTA and BTA are treated in [15].

From timed to untimed languages
In this section we give two theorems that relate timed tree languages and tree languages. These results are crucial, but their proofs are similar to those given in [2] for ω-sequence languages, so some details will be omitted. We start with the definition of the so-called Untime operator. Let T be a timed tree language, Untime(T) is {t | (t, τ ) ∈ T for some time tree τ}. We say that a clock x0 of a timed tree automaton A is nondivergent if and only if for all (t, τ ) ∈ T (A), for all runs (r,ν) of A on (t, τ ), and for all paths π in t there are u1 < v1 < u2 < v2 <... in π such that ν(uh)(x0) = 0 and ν(vh)(x0) ≥ 1, for all h ≥ 1.
The following result holds.
Lemma 3.1 Let A be a timed tree automaton in TMTA (resp. TBTA, DTMTA and DTBTA), then there is a timed tree automaton A' in TMTA (resp. TBTA, DTMTA and DTBTA) with a nondivergent clock such that T (A) = T (A').
Proof : Let A = (Σ, S, S0, ∆, C, Φ) be a nondeterministic Muller timed tree automaton. We define the non deterministic Muller tree automaton A' = (Σ,S × {0, 1}, S0 × {0}, ∆', C', Φ'), where:
C' = C ∪ {x0} with x0 /∈ C;
∆' contains ((s, 0), σ, (s1, 0),..., (sk, 0), λ1,..., λk,δ ∧ (x0 < 1)), ((s, 0), σ,
(s1, 1),..., (sk, 1), λ1,..., λk,δ ∧ (x0 ≥ 1)) and ((s, 1), σ, (s1, 0),..., (sk, 0),
λ1 ∪ {x0},..., λk ∪ {x0}, δ), for all rules (s, σ, s1,..., sk, λ1,..., λk, δ) ∈ ∆;
Φ' = {Y ⊆ S × {0, 1} | ρ1(Y ) ∈ Φ}, where ρ1 is the projection of the first component of a pair.
Note that the constraints on the clock x0 affect only the second component of the states of A'. The first component, which is relevant for the acceptance, follows the transition rules of A. Thus, we have that T (A) = T (A') and, due to the progress property of timed trees, the clock x0 is obviously nondivergent. Furthermore, if A is in TBTA, the Bu¨chi automaton A' is obtained by consid- ering as set of final states the set {s ∈ S ×{0, 1} | ρ1(s) ∈ F}, where F is the


set of final states of A. The above constructions preserve the determinism, hence it also holds for A in DTMTA or DTBTA.	✷ For traditional automata the transitions are determined by the current state and the current symbol at input. With the introduction of the time, the transitions are also influenced by clock values. Thus, the concept of state
is now replaced by the concept of extended state ⟨s, ν⟩, i.e. a state s of the
automaton together with the values of the clocks given by the clock interpre- tation ν. For a timed tree automaton the number of clock interpretations is infinite. However, they can be partitioned in a finite number of equivalence
classes, called clock regions, so that all the clock interpretations in an equiva-
lence class satisfy the same set of clock constraints of the considered transition table. To formalize this notion, we introduce first some notations. For h ∈ ঩+ and a natural k, we denote with [h♩k the integer n and with fractk(h) the real m such that h = n 1 + m and 0 ≤ m < k. Given a timed transition table A = (Σ, S, S0, ∆, C), let u be the least common denominator among all the rational numbers in the clock constraints of A and for all clocks x ∈ C, let cx be the largest integer c such that (x ≤ cu) or (x ≥ cu) is a subformula of some clock constraint in ∆. The region equivalence, denoted by , is defined as the
equivalence relation over the pairs of clock interpretations such that ν ν' if and only if the following conditions hold:
for x ∈ C, either [ν(x)♩u = [ν'(x)♩u or both ν(x) > cxu and ν'(x) > cxu;
for x, y ∈ C with ν(x) ≤ cxu and ν(y) ≤ cyu, fractu(ν(x)) ≤ fractu(ν(y)) if and only if fractu(ν'(x)) ≤ fractu(ν'(y));
for x ∈ C with ν(x) ≤ cxu, fractu(ν(x)) = 0 if and only if fractu(ν'(x)) = 0.
Then a clock region is an equivalence class of clock interpretations induced by . Note that the definition of clock region we introduced is equivalent to the one introduced in [2] for timed automata on ω-sequences. In [2], the authors proved that the number of the clock regions is upper bounded by
|C|!2|C|Πx∈C(2cx + 2). Obviously, this upper bound holds here, too. Given a clock interpretation ν, [ν] denotes the clock region containing ν. From the definition of region equivalence, it holds that if ν satisfies a clock constraint δ then it is so for all ν' ∈ [ν]. Then, we consistently say that [ν] satisfies a clock constraint δ if ν satisfies δ. Moreover, a clock region α' is said to be
a time-successor of a clock region α if and only if for all ν ∈ α there is a
positive h ∈ ঩+ such that ν + h ∈ α'. Let A = (Σ, S, S0, ∆, C) be a timed tree transition table, the corresponding Region Automaton R(A) is a transition table defined by:
the set of states R(S) = {⟨s, α⟩ | s ∈ S and α is a clock region for A};
the set of starting states R(S0) = {⟨s0, α0⟩ | s0 ∈ S0 and for x ∈ C, α0
satisfies x = 0};
the transition rules R(∆) defined as: (⟨s, α⟩, σ, ⟨s1, α1⟩,..., ⟨sk, αk⟩) ∈ R(∆) if and only if (s, σ, s1,..., sk, λ1,..., λk, δ) ∈ ∆ and there is a time-successor


α' of α such that α' satisfies δ and αi = [λi → 0]α' for all i ∈ {1,..., k}.
The Region Automaton is the transition table of a tree automaton accept- ing the Untime of the language accepted by a given timed tree automa- ton. Let us consider a nondeterministic Muller timed tree automaton A = (Σ, S, S0, ∆, C, Φ) accepting T and having a nondivergent clock x0. We define the Muller tree automaton AU = (Σ, SU , SU , ∆U , ΦU ), where:
SU contains ⟨s, α, h⟩ where s ∈ S, α is a clock region and h ∈ {0, 1, 2};
SU contains ⟨s, α, 2⟩ where ⟨s, α⟩∈ R(S0);
(⟨s, α, h⟩, σ, ⟨s1, α1, h1⟩,..., ⟨sk, αk, hk⟩) ∈ ∆U if and only if
(⟨s, α⟩, σ, ⟨s1, α1⟩,..., ⟨sk, αk⟩) ∈ R(∆) and ∀i ∈ {1,..., k}:

hi =  2 if αi satisfies x0 = 0 and h = 1 
 0 otherwise.
ΦU = {Y ⊆ SU | ρ1(Y ) ∈ Φ and ρ3(Y ) ∩ {2} /= ∅} with ρi the projection of the i-th component of a triple.
If the automaton A is a TBTA, then a BTA analogous to AU can be defined. In particular the unique difference is that the set of the final states becomes FU = {s ∈ SU | ρ1(s) ∈ S and ρ3(s) = 2}. We call again this automaton AU .
The following theorem states the relationship between a timed tree lan- guage T and Untime(T ).
Theorem 3.2 If T is a timed tree language in TMTA (resp. in TBTA) then Untime(T) is in MTA (resp. in BTA).
Proof : Let A be a TMTA and AU be defined as above. We show that T (AU ) = Untime(T (A)). Let (r, ν) be an accepting run of A on timed tree (t, τ ), we define r' as r'(w) = ⟨r(w), [ν(w)]⟩ for every w ∈ dom(t). By the definition of AU it is easy to verify that r' is an accepting run of AU on t. Vice-versa let r' be an accepting run of AU on a tree t, with r'(w) = ⟨sw, αw⟩ for all w ∈ dom(t). We observe that, since r' is an accepting run, for all paths π there are u1 < v1 < u2 < v2 < . . . in π such that αuh satisfies x0 = 0 and αvh satisfies x0 ≥ 1 for all h ∈ {1, 2, 3,.. .}. For all w ∈ dom(t), let τ (w) = d where d is such that k = deg(w), (sw, t(w), sw1,..., swk, λw1,..., λwk, δ) ∈ ∆, αwi = [λi → 0](αw +d) for i = 1,...,k and αw +d satisfies δ. By the definition of R(∆), τ (w) is always defined and positive. Moreover, the above property for the paths of an accepting run of AU guarantees that τ is a time tree. An accepting run (r, ν) of A on (t, τ ) can be obtained in this way: r(w) = sw and ν(w) ∈ αw. So, there exists an accepting run of A on t if and only if there exist τ and an accepting run of AU on (t, τ ). Hence, T (AU ) = Untime(T (A)). The result for Bu¨chi automata can be proved in a similar way.	✷
Given a symbol c ∈ Σ, we define a set Qc of the states ⟨s, α⟩ of R(A)


such that AU , starting from ⟨s, α, 2⟩, accepts some timed tree whose root is labelled by c. We denote this set as the set of the c-starting states of A. The following theorem gives a strong result concerning the relation between a particular class of timed languages and their corresponding Untime.
Theorem 3.3 Let T be a tree language, then:
{(t, τ ) | t ∈T and τ is a time tree} is in (D)TBTA if and only if T is in (D)BTA;
{(t, τ ) | t ∈T and τ is a time tree} is in (D)TMTA if and only if T is in (D)MTA.
Proof : The “if” part of all the assertions is immediate since the automaton accepting {(t, τ ) | t ∈ T and τ is a time tree} is obtained directly from the one accepting T by simply adding the constant true as clock constraint in all the transitions. The “only if” part for the nondeterministic classes comes from Theorem 3.2. For the deterministic classes, we consider first the language T ' = {(t, τ ) | t ∈ T, τ (w) = 1 ∀w ∈ dom(t)} which is in the same class of
{(t, τ ) | t ∈ T and τ is a time tree}. In fact, a timed tree automata for T ' can be designed starting from the one accepting {(t, τ ) | t ∈ T and τ is a time tree} by simply considering a new clock variable, say x, and adding both the constraint x = 1 ad the reset of x in all the transitions. Then, by the same construction used in Theorem 3.2, we obtain an automaton accepting T . Since in T ' the delay associated to all nodes is fixed, the above construction preserves the determinism and, then, the theorem is proved.	✷ Note that in general, for a timed tree language T ' ∈ (D)TBTA (resp. T ' ∈ (D)TMTA), it is not true that Untime(T') ∈ (D)BTA (resp. Untime(T') ∈
(D)MTA). The following counter-example is due to Alur and Dill [2].
Example 3.4 Let T be the language {(t, τ ) ∈ Tk	| for all paths π in t and all
{a}
v ∈ π there exists w ∈ π such that	u∈pre(w)−pre(v) τ (u) = 1}. Untime(T ) ∈
DBTA while T does not belong to any of the timed tree language classes we
have introduced.

Properties and decision problems
In this section we compare the different classes of timed tree languages. Then we state the closure of all the considered classes with respect to union and intersection and the nonclosure under complementation. Next, we prove the closure of the nondeterministic classes and the nonclosure of the deterministic ones under concatenation and ω-iteration. Moreover, the decidability of the emptiness problem for all the classes under consideration is shown. Finally, we prove that the equivalence problem is decidable for the classes of timed tree languages recognized by deterministic automata while it is undecidable for the nondeterministic models; nevertheless, one can introduce a weaker notion of equivalence, called untimed equivalence, whose problem turns out to be


decidable in all classes.
Language comparisons. The relationships between the considered classes of languages are inherited from those between tree languages, by means of Theorem 3.3. It is known that BTA is strictly included in MTA [13]. The proof of this result can be easily modified to obtain DBTA ⊂ DMTA. The following theorem complete the relationships among all the classes of tree languages.
Theorem 4.1 It holds that:
DBTA ⊂ BTA ∩ DMTA;
BTA and DMTA are not comparable;
BTA ∪ DMTA ⊂ MTA.
Proof :
“1.” Let T1 be the language {t ∈ T 1	| π = ε, 1, 11,..., 1i,... and a /∈
In(t|π)}. Note that T1 is a set of ω-sequences which is not accepted by a deterministic Bu¨chi automaton and is accepted by a nondeterministic Bu¨chi automaton (see also [15]). Moreover, the nondeterministic Bu¨chi automata and the deterministic Muller automata on ω-sequences are equivalent [11]. Thus, we have DBTA ⊂ BTA ∩ DMTA.

“2.”	Let k > 1 and T2 be the language {t ∈ Tk
| ∀ paths π in

t, a /∈ In(t|π)}. Rabin in [13] showed that T2 is accepted by a determinis- tic Muller tree automaton but it is not accepted by a Bu¨chi tree automaton.
Thus, T2 ∈ DMTA − BTA. Let k > 1 and T3 be the language {t ∈ Tk	|
there exists a path π in t such that b ∈ In(t|π)}. The language T3 is ac- cepted by a nondeterministic Bu¨chi tree automaton that guesses a path π on which it checks the infiniteness of the occurrences of the symbol “b” and ac- cepts unconditionally on the other paths. Furthermore, by using a standard argument, similar for example to the one used to show the weakness of the deterministic frontier-to-root tree automata over finite trees compared to the nondeterministic ones (see [8]), we can prove that T3 is not in DMTA. Thus, T3 ∈ BTA − DMTA.

“3.” Let k > 1 and T4 be the tree language {t ∈ Tk
| ∀ paths π in t,

a /∈ In(t|π) and there exists a path π' in t such that b ∈ In(t|π')}. Note that T4 = T2 ∩ T3 and, then, from the closure under intersection of MTA we have T4 ∈ MTA. In order to show that T4 /∈ BTA, let us suppose that there is a Bu¨chi tree automaton A accepting T4 and let A' be the automaton obtained from A by replacing transition rules on symbol “b” with identical, except for the input symbol, transition rules on symbol “c”. Thus, A' would accept the
language {t ∈ Tk	| ∀ paths π in t, a /∈ In(t|π)} which is not in BTA, hence
T4 /∈ BTA. By using a similar argument as that used for T3, it can be shown that T4 is not in DMTA and, then, BTA ∪ DMTA ⊂ MTA.	✷
The next corollary extends the previous results to timed tree languages.
Corollary 4.2	DTBTA ⊂ TBTA ∩ DTMTA,	TBTA ∪ DTMTA ⊂ TMTA,

TBTA and DTMTA are not comparable.
Proof : By the usual constructions we have DTBTA ⊆ DTMTA and TBTA ⊆ TMTA. The proof is completed by Theorems 3.3 and 4.1.	✷

Fig. 1. Relationships between the classes TMTA, TBTA, DTMTA and DTBTA.
Closure properties.
Theorem 4.3 The classes DTBTA, DTMTA, TBTA and TMTA are closed under intersection and union, but they are not closed under complementation.
Proof : The positive results are proved with the usual constructions having care of the timing features (see for example the constructions in [2]). The nonclosure under complementation is proved with counter-examples which
are similar to the counter-example given in [2]. Let T = {(t, τ ) ∈ Tk	|
Σ	{a}
It can be seen that T ∈TBTA, but its complement with respect to Tk	is
not in TMTA. Finally, the language {(t, τ ) ∈ Tk	| for all paths π in t,

a ∈ In(t|π)} ∈ DTBTA and its complement with respect to Tk
is not in

DTMTA.	✷
In spite of the nonclosure under complementation of the considered classes we can prove that the complement of a language belonging to DTMTA is in TMTA. This result will be useful to prove the decidability of the equiva- lence problem for DTMTA. Let DTMTA be the set of languages obtained by complementation of the languages in DTMTA. It holds the following result.
Theorem 4.4 DTMTA∪DTMTA ⊂TMTA.
Proof :	Let us consider a DTMTA A having exactly one run for each (t, τ ) ∈ Tk.	The timed tree automaton A', accepting the complement of T (A), nondeterministically guesses a path on which it verifies that the ac- cepting conditions of A do not hold and accepts unconditionally on the other paths. Hence we have the containment. From the nonclosure of TMTA under complementation (Theorem 4.3), it follows that the containment is strict. ✷ The concatenation of two timed tree languages T1 and T2, denoted with
T1·c T2, is defined as the ω-tree language obtained from timed trees in T1 by replacing a timed tree of T2 for each subtree rooted in a node labelled with the “first” occurrence of c along a path. Note that different timed trees of T2 can be substituted for different subtrees of a given t ∈ T1. The ω-iteration of a timed tree language T , denoted with Tωc, is defined as the infinite iteration
of the concatenation.


Theorem 4.5 The classes TBTA and TMTA are closed under concatenation and ω-iteration.
Proof : We start with the closure under concatenation for TBTA. Let Ai = (Σ, Si, S0, ∆i, Ci, Fi) for i = 1, 2 be two nondeterministic Bu¨chi timed tree automata with S1 ∩ S2 = ∅ and C1 ∩ C2 = ∅. Let Qc be the set of the c- starting states of A1. Given a clock region α and a set of clocks λ, let δ(α, λ) be the clock constraint δ1 ∨ ... ∨ δr where, given the clock regions α' ,..., α'
1	r
such that α = [λ → 0]α' + d for a d ∈ ঩+, δi is the clock constraint equivalent
to α' (in the sense that a clock interpretation ν satisfies δi if and only if ν is
a clock interpretation in α'). A nondeterministic Bu¨chi timed tree automaton accepting T (A1)·c T (A2) is A = (Σ, S1 ∪ S2, S0, ∆, C1 ∪ C2, F1 ∪ F2) where

S0 = S0 ∪ S0 if ∃s ∈ S0
and ⟨s, α0, 2⟩ ∈ Qc (where α0 is the clock region

1	2	1
containing the clock interpretation ν(x) = 0, ∀x ∈ C1) else S0 = S0, and ∆
contains ∆2 and the set of the rules (s, σ, s1,..., sk, λ1,..., λk, δ) such that:
σ /= c;
there exist a (s, σ, s' ,..., s' , λ' ,..., λ' , δ') ∈ ∆1, 0 ≤ i1,..., ih ≤ k, and
1	k	1	k

regions αi ,..., αi , such that (1) ⟨s' , αi ⟩ ∈ Qc, si ∈ S0 and λi
= C2

1	h	ij	j	j	2	j
∀j ∈ {1,..., h}, (2) sj = s' and λj = λ' ∀j /∈ {i1,..., ih} and (3) δ =
δ' ∧ δ(αi , λ' ) ∧ ... ∧ δ(αi , λ' ).
1	i1	h	ih
When the automaton A starts, it behaves as A1. When A1 enters an extended state ⟨s, ν⟩ and ⟨s, [ν]⟩ is a c-starting state, a possible root of a tree in T (A2) is processed, and then A switches to A2. Since the nodes on which the trees in T2 are pasted are a priori unknown, a nondeterministic choice occurs on every node (including the root). The same construction holds for A1 and A2 in TMTA with the unique difference that the accepting family of A is Φ = Φ1 ∪ Φ2, where Φi is the accepting family of Ai, i = 1, 2.
For the closure under ω-iteration, we suppose that the automaton A1 has the property that in its runs the starting states appear only at the root. A timed tree automaton accepting (T (A1))ωc is A' = (Σ −{c}, S1, S0, ∆, C1, F1 ∪ S0) where ∆ contains (s, σ, s1,..., sk, λ1,..., λk, δ) such that (s, σ, s' ,..., s' , λ' ,
1	1	k	1

..., λ' , δ') ∈ ∆1, {⟨s' , αi ⟩,..., ⟨s' , αi ⟩} ⊆ Qc and:	(1) si	∈ S0
and

k	i1	1	ih	h	j	1

λij
= C1 ∀j ∈ {1,..., h}, (2) sj = s' and λj = λ' ∀j /∈ {i1,..., ih}, and

(3) δ = δ' ∧δ(αi , λ' ) ∧... ∧δ(αi , λ'
). If we consider Muller timed tree auto-

1	i1	h	ih
mata, in the previous construction some changes are needed. First, the set of
states is S1 ×{0, 1}. The second component of each state implements a binary counter that is incremented every time a starting state of A1 is entered. As a consequence, the transition rules are suitably modified. Last, the accepting family is {X ⊆ S1 × {0, 1} | ρ1(X) ∈ Φ1 or ρ2(X) = {0, 1}} where ρi projects the i-th component of a pair and Φ1 is the accepting family of A1.	✷
The above results do not hold for the deterministic classes. A counter-
example for the concatenation is given by the languages T1 = {(t, τ ) ∈ Tk	|
∀ paths π = ε, v1, v2,... ∃i such that t(vi) = c} and T2 = {(t, τ ) ∈ Tk	| ∀

paths π = ε, v1, v2,... ∃i such that Σi	τ (vj) = 1}.  Thus, the language
T = T1·c T2 contains the timed {a}-valued trees having two cuts such that
the delay between the nodes of the first cut and those of the second one is 1. A deterministic timed tree automaton accepting T would have an unbounded number of clocks, thus T is not in DTMTA, while the languages T1 and T2
are both in DTBTA. The language {(t, τ ) ∈ Tk	| t(ε) = a and ∀ paths
π = ε, v1, v2,... there are i, j such that i < j, t(vh) = a for every 1 ≤ h ≤ i,
t(vj) = c, and Σi	τ (vh) = 1} gives the counter-example for the ω-iteration.



Fig. 2. Summary of results on closure properties.


Decision problems.
Theorem 4.6 The emptiness problem is decidable for TMTA.
Proof : Let T∈TMTA, we have that T is empty if and only if Untime(T) is empty. From the Theorem 3.2, Untime(T) is accepted by Muller tree auto- mata. Since the emptiness problem is decidable for the tree languages accepted by Muller automata (see [14]), we have the decidability for TMTA.	✷ By Corollary 4.2 and the above theorem we have that the the emptiness
problem is decidable also for DTBTA, DTMTA and TBTA.
Theorem 4.7 The equivalence problem is undecidable for TMTA and TBTA while it is decidable for DTMTA and DTBTA.
Proof : The undecidability is inherited from the undecidability of the equiv- alence problem for the corresponding classes of timed ω-sequence languages (see [2]). The decidability for the deterministic classes follows from Theorems
4.4 and 4.6.	✷
Let A and A' be two timed tree automata, we say that A is untimed equivalent to A' if and only if Untime(T (A)) = Untime(T (A')). From the decidability of the equivalence problem for MTA and Theorem 3.2, we can state the following:
Theorem 4.8 The untimed equivalence problem is decidable for TMTA.


Fig. 3. Summary of results on decision problems.
Highly-deterministic timed tree automata
In this section we define for timed tree automata a concept which captures some of the properties that regular trees have in the context of tree languages. A timed tree automaton A = (Σ, S, S0, ∆, C,F ) is said to be highly de-
terministic if Untime(T (A)) contains a unique tree, and for s ∈ S, e =
(s, σ, s1,..., sk, λ1,..., λk, δ) ∈ ∆ and e' = (s, σ', s' ,..., s' , λ' ,..., λ' , δ') ∈ ∆
1	h	1	h
imply that e = e'.  The second property of highly-deterministic timed
tree automata simply states that there is at most one transition rule that can be executed in each location s ∈ S. Given a timed tree automa- ton A = (Σ, S, S0, ∆, C,F ), we say that a timed tree automaton A' =
(Σ, S', S' , ∆', C,F') is contained in A if S' ⊆ S, S' ⊆ S0, ∆' ⊆ ∆, and F ' ⊆ F .
0	0
Clearly, T (A') ⊆ T (A) holds. We recall that a regular tree contains a finite number of subtrees. Given a timed tree automaton A = (Σ, S, S0, ∆, C,F ), and a regular run r of R(A) on a regular tree t ∈ T (R(A)), we define a shrink of r and t as the labelled directed finite graph G = (V, E, lab) such that there
is a mapping θ : dom(t) −→ V such that:
for any u, u' ∈ dom(r), θ(u) = θ(u') implies that deg(u) = deg(u'), and for each i = 1,..., deg(u), θ(ui) = θ(u'i);
E = {(θ(u), θ(ui), i) | u ∈ dom(r) and i ≤ deg(u)}, and (v, v', i) ∈ E is an edge from v to v' labelled by i;
for v ∈ V , lab(v) = (r(u), t(u)) for any u such that v = θ(u).
From the definition of regular tree, such a graph G always exists. Thus, the following theorem holds.
Theorem 5.1 Given a timed tree automaton A, T (A) is not empty if and only if there exists a highly-deterministic timed tree automaton contained in A.
Proof : We consider first the forward direction. By hypothesis T (A) is not empty, then Untime(T (A)) is also not empty. Thus there exist an accepting regular run r of R(A) and a corresponding regular tree t ∈ Untime(T (A)) [14]. Let G = (V, E, lab) be a shrink of r and t, where ε corresponds to v0 and lab(v0) = (r(ε), t(ε)). We define Adet as the timed tree automaton (Σ, Sdet, {s' }, ∆det, C, Sdet) where:
⟨s' , [ν0]⟩ = r(ε) with ν0(x) = 0 for any x ∈ C;


Sdet = {s | ∃v ∈ V such that lab(v) = (⟨s, α⟩, σ)};
a transition rule (s, σ, s1,..., sk, λ1,..., λk, δ) ∈ ∆ belongs to ∆det if and only if the sequence (v, v1, 1),..., (v, vh, h) ∈ E of all the edges from v is such that (1) h = k, (2) lab(v) = (⟨s, α⟩, σ), and lab(vi) = (⟨si, αi⟩, σi) for i = 1,..., k, and (3) there exists a d > 0 such that (α + d) satisfies δ and αi = [λi → 0](α + d) for i = 1,..., k.
Directly from the above definition we have that Untime(T (Adet)) = {t}, and for each s ∈ Sdet there is only a transition rule that can be executed from s. Thus Adet is a highly-deterministic timed tree automaton. More- over, Adet is contained in A, and thus we have proved that if T (A) is not empty then there exists a highly-deterministic timed tree automaton con- tained in A. The converse direction is a direct consequence of the facts that any highly-deterministic timed tree automaton A' accepts a non-empty lan- guage and T (A') ⊆ T (A) since A' is contained in A.	✷ For any highly-deterministic timed tree automaton A, it is easy to prove that there exists a highly-deterministic timed automaton A' such that T (A) = 
T (A') and for any transition rule (s, σ, s1,..., sk, λ1,..., λk, δ) of A' we have
that si /= sj for i /= j. We call such an automaton a graph-representable timed tree automaton, since it corresponds to a labelled directed graph such that for any ordered pair of locations (s, s') there is exactly an edge connecting s to s' in the graph. This does not hold in general for a highly-deterministic timed tree automaton. We can easily obtain A' from A by simply adding multiple copies of the A locations that break the graph-representability property.

Conclusions
In this paper we have introduced a theory of finite automata on timed ω-trees. We have considered both deterministic and nondeterministic paradigms and both Muller and Bu¨chi acceptance conditions. We have studied the relation- ships among the various classes of languages, some closure properties, and decision problems. Concerning to this theory the main result is the decid- ability of the emptiness problem, which turned out to be extremely useful in obtaining decidability results in the field of dense-time temporal logics. In

particular, in [10] the satisfiability problem of
Stctl
(a real-time extension

of Ctl [5]) is reduced to the emptiness problem of Bu¨chi automata on timed ω-trees. Moreover, the result on highly-deterministic timed tree automata presented in Section 5 is used to relate timed tree automata to timed graphs and to reduce the finite satisfiability of Tctl [1] to the emptiness problem of Bu¨chi automata on timed ω-trees (see [9]).

Acknowledgments
This research was partially supported by the M.U.R.S.T. in the framework of project Tosca, NSF Career award CCR97-34115 and SRC award 99-TJ-688.

References
R. Alur, C. Courcoubetis, and D.L. Dill. Model-checking in dense real-time.
Information and Computation, 104(1):2–34, 1993.
R. Alur and D.L. Dill. A theory of timed automata. Theoretical Computer Science, 126:183–235, 1994.
J.R. Bu¨chi.  On a decision method in restricted second-order arithmetic. In Proceedings of the International Congress on Logic, Methodology, and Philosophy of Science 1960, pages 1–12. Stanford University Press, 1962.
O. Bernholtz, M.Y. Vardi, and P. Wolper. An automata-theoretic approach to branching-time model checking. In Proceedings of the 6th International Conference on Computer Aided Verification, LNCS 818, pages 142–155. Springer-Verlag, 1994.
E.A. Emerson and E.M. Clarke. Characterizing correctness properties of parallel programs as fixpoints. In Proceedings of the 7-th International Colloquium on Automata, Languages and Programming, LNCS 85, pages 169–
181. Springer-Verlag, 1981.
E.A. Emerson and J.Y. Halpern. Sometimes and not never revisited: On branching versus linear time. Journal of the ACM, 33(1):151–178, 1986.
E.A. Emerson. Temporal and modal logic. In J. van Leeuwen, editor, Handbook of Theoretical Computer Science, volume B, pages 995–1072. Elsevier Science Publishers, 1990.
F. G´ecseg and M. Steinby. Tree Automata. Akadem´ iai Kiado, Budapest, 1984.
S. LaTorre and M. Napoli. A decidable dense branching-time temporal logic. In Proceedings of the 20th Conference on the Foundations of Software Technology and Theoretical Computer Science, FSTTCS’00, LNCS 1974. Springer-Verlag, 2000.
S. LaTorre and M. Napoli. Timed tree automata with an application to temporal logic. To appear on Acta Informatica, 2001.
R. McNaughton. Testing and generating infinite sequences by a finite automaton. Information and Control, 9:521–530, 1966.
M.O. Rabin. Decidability of second-order theories and automata on infinite trees. Trans. Amer. Math. Soc., 141:1–35, 1969.
M.O. Rabin. Weakly definable relations and special automata. Mathematical Logic and Foundations of Set theory, 1970.
M.O. Rabin. Automata on infinite objects and Church’s problem. Trans. Amer. Math. Soc., 1972.


W. Thomas. Automata on infinite objects. In J. van Leeuwen, editor, Handbook of Theoretical Computer Science, volume B, pages 133–191. Elsevier Science Publishers, 1990.
M.Y. Vardi. Nontraditional applications of automata theory. In Proceedings of the International Symposium TACS’94, LNCS 789, pages 575–597. Springer- Verlag, 1994.
M.Y. Vardi and P. Wolper. Automata-theoretic techniques for modal logics of programs. Journal of Computer and System Sciences, 32:182–211, 1986.
