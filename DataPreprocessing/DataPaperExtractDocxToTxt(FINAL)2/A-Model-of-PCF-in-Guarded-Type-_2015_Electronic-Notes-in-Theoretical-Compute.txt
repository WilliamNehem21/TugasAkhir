Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 319 (2015) 333–349
www.elsevier.com/locate/entcs
A Model of PCF in Guarded Type Theory
Marco Paviotti1
IT University of Copenhagen
Rasmus Ejlers Møgelberg2
IT University of Copenhagen
Lars Birkedal3
Dept. of Comp. Science, Aarhus University

Abstract
Guarded recursion is a form of recursion where recursive calls are guarded by delay modalities. Previous work has shown how guarded recursion is useful for constructing logics for reasoning about programming languages with advanced features, as well as for constructing and reasoning about elements of coinductive types. In this paper we investigate how type theory with guarded recursion can be used as a metalanguage for denotational semantics useful both for constructing models and for proving properties of these. We do this by constructing a fairly intensional model of PCF and proving it computationally adequate. The model construction is related to Escardo’s metric model for PCF, but here everything is carried out entirely in type theory with guarded recursion, including the formulation of the operational semantics, the model construction and the proof of adequacy.
Keywords: Denotational semantics, guarded recursion, type theory, PCF, synthetic domain theory


Introduction
Variations of type theory with guarded recursive types and guarded recursively defined predicates have proved useful for giving abstract accounts of operationally- based step-indexed models of programming languages with features that are chal- lenging to model, such as recursive types and general references [1,6], countable nondeterminism [7], and concurrency [15]. Following observations of Nakano [13]

1 Email: mpav@itu.dk
2 Email: mogel@itu.dk
3 Email: birkedal@cs.au.dk

http://dx.doi.org/10.1016/j.entcs.2015.12.020
1571-0661/© 2015 The Authors. Published by Elsevier B.V.
This is an open access article under the CC BY-NC-ND license (http://creativecommons.org/licenses/by-nc-nd/4.0/).

and Atkey and McBride [2], guarded type theory also offers an attractive type- based approach to (1) ensuring productivity of definitions of elements of coinduc- tive types [12], and (2) proving properties of elements of coinductive types [8]. One of the key features of guarded type theory is a modality on types, denoted d and pronounced ‘later’. This modality is used to guard recursive definitions and the intuition is that elements of type dA are elements of A only available one time step from now.
In this paper, we initiate an exploration of the use of guarded type theory for denotational semantics and use it to further test guarded type theory. More specifically, we present a model of PCF in guarded dependent type theory. To do so we, of course, need a way to represent possibly diverging computations in type theory. Here we follow earlier work of Escardo [10] and Capretta [9] and use a lifting monad L, which allows us to represent a possibly diverging computation of type X by a function into L(X). In Capretta’s work, L is defined using coinductive types. Here, instead, we use a guarded recursive type to define L. Using this approach we get a fairly intensional model of PCF which, intuitively keeps track of the number of computation steps, similar to [10]. We show this formally by proving that the denotational model is adequate with respect to a step-counting operational semantics. The definition of this step-counting operational semantics is delicate — to be able to show adequacy the steps in the operational semantics have to correspond to the abstract notion of time-steps used in the guarded type theory via the d operator. Our adequacy result is related to one given by Escardo in [10]. To show adequacy, we define the operational semantics in guarded type theory and also define a logical relation in guarded type theory to relate the operational and denotational semantics. To carry out the logical relations proof, we make crucial use of some novel features of guarded dependent type theory recently proposed in [8], which, intuitively, allow us to reason now about elements that are only available later.
The adequacy result of this paper may be seen as a version of Plotkin’s classic result from domain theory [14] set in guarded type theory. There has been work to formalise domain theory in Coq [4], however, this is difficult due to the use of classical mathematics. In fact, [4] uses a coinductively defined lifting monad similar to that of Capretta [9]. We believe that guarded type theory is more suitable for encoding in proof assistants such as Coq or Agda, and thus this work can be seen as a step towards enabling the use of the models for formal reasoning.
The remainder of the paper is organized as follows. In Section 2 we recall the core parts of guarded dependent type theory and the model thereof in the topos of trees [6,8]. Then we define a step-counting operational semantics of PCF in Section 3 and the denotational semantics is defined in Section 4. We prove adequacy in Section 5. In Section 6 we use the topos of trees model of the guarded type theory to summarize briefly what the results proved in guarded type theory mean externally, in standard set theory. Finally, we conclude and discuss future work in Section 7.

Guarded recursion
In this paper we work in a type theory with dependent types, natural numbers, inductive types and guarded recursion. The presentation of the paper will be in- formal, but the results of the paper can be formalised in gDTT as presented in [8]. We start by recalling the core of this type theory (as described in [6]), introducing further constructions later on as needed.
A guarded recursive definition is a recursive definition where the recursive calls are guarded by time steps. The time steps are introduced via a type modality d pronounced ‘later’. If A is a type then dA is the type of elements of A available only one time step from now. The type constructor d is an applicative functor in the sense of [11], which means that there is a term next: A → dA freezing an element of A so that it can be used one time step from now, and a ‘later application’
②: d(A → B) → dA → dB written infix, satisfying next(f ) ② next(t)= next(f (t)) among other axioms (see also [5]). In particular, d extends to a functor mapping f : A → B to λx : dA. next(f ) ② x.
Recursion on the level of terms is given by a fixed point operator fix : (dA → A) → A satisfying f (next(fix(f ))) = fix(f ). Intuitively, fix can compute the fixed point of any recursive definition, as long as that definition will only look at its argument later. This fixed point combinator is particularly useful in connection with guarded recursive types, i.e., types where the recursion variable occurs only guarded under a d as, e.g., in the type of guarded streams:
Strg  A × d Strg

The cons operation consg for Strg has type A → d Strg → Strg . Hence, we can
A	A  g	Ag

define, e.g., constant streams as constant a = fix(λxs : d StrA . cons
a xs).

Guarded recursive types can be constructed using universes and fix as we now describe [5]. We shall assume a universe type U closed under both binary and dependent sums and products as usual, and containing a type of natural numbers. We write N^ for the code of natural numbers satisfying El(N^) N and likewise ×^ for the code of binary products satisfying El(A ×^ B)  El(A) × El(B). The universe is also closed under d in the sense that there exists an ^d : dU → U satisfying
El(^d(next(A)))  d El(A).	(1)
Using these, the type Strg can be defined as El(Sˆtrg ) where Sˆtrg = fix(λB : dU.N^×^^dB).
Note that this satisfies the expected type equality because
El(Sˆtrg )  El(N^×^^d(next(Sˆtrg )))  El(N^) × El(^d(next(Sˆtrg )))  N × d El(Sˆtrg )
Likewise, guarded recursive (proof-relevant) predicates on a type A, i.e., terms of type A →U can be defined using fix as we shall see an example of in Section 5.
Note that we just assume a single universe and that the above only allows us




Γ,x : σ, Δ ▶ x : σ
Γ,x : σ ▶ M : τ
Γ ▶ (λx : σ.M ): σ → τ

Γ ▶ M : σ → τ	Γ ▶ N : σ
Γ ▶ MN : τ
Γ ▶ M : nat
Γ ▶ M : σ → σ
Γ ▶ Yσ M : σ
Γ ▶ M : nat

Γ ▶ n : nat
Γ ▶ succ M : nat
Γ ▶ pred M : nat

Γ ▶ L : nat	Γ ▶ M : σ	Γ ▶ N : σ
Γ ▶ ifz L M N : σ

Fig. 1. PCF typing rules
to solve type equations that can be expressed as endomorphisms on this universe. 4 All the type equations considered in this paper are on this form, but we shall not always prove this explicitly, and often work with types rather than codes, in order to keep the presentation simple.
The topos of trees model
The type theory gDTT can be modelled in the topos of trees [6], i.e., the category of presheaves over ω, the first infinite ordinal. Since this is a topos, it is a model of extensional type theory. A closed type is modelled as a family of sets X(n) indexed by natural numbers together with restriction maps rn : X(n + 1) → X(n). We think of X(n) as how the type looks if we have n computation steps to reason about it. Using the propositions-as-types interpretation, we say that X is true at stage n if X(n) is inhabited. Note that if X is true at stage n, it is also true at stage k for all k ≤ n. Thus, the intuition of this model is that a proposition is initially considered true and can only be falsified by further computation.
In the topos of trees model, the d modality is interpreted as dX(0) = 1 and dX(n + 1) = X(n), i.e., from the logical point of view, the d modality delays evaluation of a proposition by one time step. For example, if 0 is the constantly empty presheaf (corresponding to a false proposition), then dn0 is the proposition that appears true for the first n computation steps and is falsified after n + 1 steps.
PCF
This section defines the syntax, typing judgements, and operational semantics of PCF. These should be read as judgements in guarded type theory, but as stated above we work informally in type theory, which here means that we ignore standard problems of representing syntax up to α-equality. Note that this is a perpendicular issue to the one we are trying to solve here.
Unlike the operational semantics to be defined below, the typing judgements of PCF are defined in an entirely standard way, see Figure 1. In the figure, v ranges

4 It is also sound to add guarded recursive types as primitives to the type theory without use of universes, see [6]


⇓ : TermPCF × N × (ValuePCF → U) →U 

v ⇓0 Q =de=f pred M ⇓k Q =de=f succ M ⇓k Q =de=f Yσ M ⇓k+1 Q =de=f MN ⇓k+m Q =de=f
Q(v)
M ⇓k (λx.Σn : N.x = n and Q(n − 1)) M ⇓k (λx.Σn : N.x = n and Q(n + 1)) d(M (Yσ M ) ⇓k Q)
M ⇓k Qj

where Qj(λx.L)= L[N/x] ⇓m Q

ifz L M N ⇓k+m Q =de=f
L ⇓k Qj

where Qj(0)= M ⇓m Q and Qj(n + 1)= N ⇓m Q

Fig. 2. Step-indexed Big-Step Operational Semantics for PCF
over values of PCF, i.e., terms of the form v = n, where n is a natural number or v = λx.M . Note that we distinguish notationally between a natural number n and the corresponding PCF value n. We denote by TypePCF , TermPCFand ValuePCF the types of PCF types, closed terms, and closed values of PCF.
Big-step semantics
The big-step operational semantics defined in Figure 2 is a relation between terms, numbers and predicates on values. The statement M ⇓k Q should be read as M evaluates in k steps to a value satisfying Q. The relation can either be defined by a combination of guarded recursion and induction on M , or simply by ordinary induction first on k then on M .
Figure 2 uses standard syntactic sugar, for example, only non-empty cases are mentioned, e.g, v ⇓k Q is defined to be 0 in case k > 0, and the case of function application should be read as

MN ⇓l Q =de=f
Σ k, m : N.(k + m = l) and M ⇓k Qj


Note in particular that this means that Yσ M ⇓0 Q is always false.
As mentioned in the introduction, the formulation of the big-step operational semantics is quite delicate – the wrong definition will make the adequacy theorem false. First of all, the definition must ensure that the steps of PCF are synchronised with the steps on the meta level. This is the reason for the use of d in the case of the fixed point combinator. Secondly, the use of predicates on values on the right hand side of ⇓ rather than simply values is necessary to ensure that the right hand side is not looked at before the term is fully evaluated. For example, a naive definition of the operational semantics using values on the right hand side and the rule


succ M ⇓k v =de=f
Σn : N.(v = n + 1) and M ⇓k n



	
(λx : σ.M )(N ) →0 M [N/x]	Yσ M →1 M (Yσ M ) pred 0 →0 0	pred n +1 →0 n
ifz 0 M N →0 M	ifz (n + 1) M N →0 N

M →k Mj
M (N ) →k Mj(N )
M →k Mj
succ M →k succ Mj

M →k Mj
pred M →k pred Mj
L →k Lj
ifz L M N →k ifz Lj M N 

Fig. 3. Step-Indexed Small Step semantics of PCF. In the rules, k can be 0 or 1.
Would make (succ (Ynat (λx : nat.x)) ⇓42 0) false, but to obtain computational adequacy, we need this statement to be true for the first 42 steps before being falsified. (For an explanation of this point, see Remark 5.8 below.) In general, M ⇓k Q should be defined in such a way that in the topos of trees model it is true at stage n (using vocabulary from Section 2.1) iff either
k < n and M evaluates in precisely k steps to a value satisfying Q, or
k ≥ n and evaluation of M takes more than k steps.
In particular, if M diverges, then M ⇓k Q should be true at stages n ≤ k and false for n > k.
The use of predicates means that partial results of term evaluation are ignored, and comparison of the result to the right hand side of ⇓ is postponed until evaluation of the term is complete. The more standard big-step evaluation of terms to values can be defined as

M ⇓k v =de=f
M ⇓k λvj.vj = v


Small-step semantics
Figure 3 defines the small-step operational semantics. Just like the big step seman- tics, the small step semantics counts unfoldings of fixed points. The small steps semantics will be proved equivalent to the big-step semantics, but is introduced because it is more suitable for the proofs of soundness and computational adequacy.
Note the following easy lemma.
Lemma 3.1 The small-step semantics is deterministic: if M →k N and M →k′
Nj, then k = kj and N = Nj.
The transitive closure of the small step semantics is defined using d to ensure that the steps of PCF are synchronised with the steps of the meta language.
Definition 3.2 Denote by →0 the reflexive, transitive closure of →0. The closure

of the small step semantics, written M ⇒k Q is a relation between closed terms, natural numbers, and predicates on closed terms, defined by induction on k as


M ⇒0 Q =de=f
ΣN : TermPCF
.M →0 N and Q(N )

M ⇒k+1 Q =de=f
ΣMj,Mjj : Term


PCF
.M →0 Mj and Mj →1 Mjj and d(Mjj ⇒k Q)



Similarly to the case of the big-step semantics we define M ⇒k v =de=f λN.v = N
M ⇒k

We will now prove the correspondence between the big-step and the small step operational semantics. First we need the following lemma.
Lemma 3.3 Let M, N be closed terms of type τ, and let Q : TermPCF → U.
If M →0 N and N ⇓k Q then M ⇓k Q
If M →1 N and d(N ⇓k Q) then M ⇓k+1 Q
Proof sketch
By induction on M →0 N . We consider the case ifz L M N →0 ifz Lj M N . Assume ifz Lj M N ⇓k Q. By definition Lj ⇓k Qj. By induction hypothesis L ⇓k Qj and by definition ifz L M N ⇓k Q. All the other cases are similar.
By induction on M →1 N . The base case is Yσ M →1 M (Yσ M ). Assume d(M (Yσ M ) ⇓k Q). Then by definition Yσ M ⇓k+1 Q. We consider now the inductive cases pred M →1 pred Mj. Assume d(pred Mj ⇓k Q). By definition d(Mj ⇓k λx.Q(x − 1)) and by induction hypothesis M ⇓k+1 λx.Q(x − 1). By definition pred M ⇓k+1 Q.
2
Lemma 3.4 Let M be a closed term and Q : ValuePCF → U a relation on values. If M ⇒k (λN.N ⇓m Q) then M ⇓k+m Q
Proof. The proof is by induction on k. In the case where k = kj +1 we have as assumptions that M →0 N and N →1 Nj and d(Nj ⇒k′+m (λN.N ⇓m Q)). By induction we have d(Nj ⇓k′+m Q) and now by repeated application of Lemma 3.3 also M ⇓k+m Q as desired.	2
Now we can state the correspondence. Note that we have to massage the predi- cate of the ⇒ relation to make things type check properly.
Lemma 3.5 If M : TermPCF and Q : ValuePCF  → U, then M ⇓k Q iff M ⇒k
(λN.Σv.N = v ∧ Q(v))
Proof. We consider implication from left to right in the case of the fix-point. As- sume Yσ M ⇓k+1 Q. By definition d(M Yσ M ⇓k Q). By induction hypothesis d(M Yσ M ⇒k (λN.Σv.N = v and Q(v)). As Yσ M →1 M (Yσ M ) by definition Yσ M ⇒k+1 (λN.Σv.N = v and Q(v)). For the case from right to left assume M ⇒k (λN.Σv.N = v and Q(v)). Since Σv.N = v and Q(v) implies N ⇓0 Q the assumption implies M ⇒k (λN.N ⇓0 Q). By Lemma 3.4 this implies M ⇒k Q  2

The following is the standard statement for operational correspondence and follows directly from Lemma 3.5.
Corollary 3.6 M ⇓k v ⇔ M ⇒k v
Denotational semantics
We now define the denotational semantics of PCF. For this, we use the guarded recursive lifting monad on types, defined as the guarded recursive type 5


LA =de=f
fix X.(A + dX).

Let i : A + dLA ∼= LA be the isomorphism, let θ : dLA → LA be the right inclusion composed with i and let η : A → LA (the unit of the monad) denote the left inclusion composed with i. Note that any element of LA is either of the form η(a) or θ(r).
We can describe the universal property of LA as follows. Define a d-algebra to be a type B together with a map θB : dB → B. The lifting LA as defined above is
the free d-algebra on A. Given f : A → B with B a d-algebra, the unique extension of f to a homomorphism of d-algebras fˆ: LA → B is defined as


fˆ(η(a)) =de=f
fˆ(θ(r)) =de=f
f (a) θB(next(fˆ) ② r)

which can be formally expressed as a fixed point of a term of type d(LA → B) →
LA → B.
The intuition the reader should have for L is that LA is the type of compu- tations possibly returning an element of A, recording the number of steps used in the computation. The unit η gives an inclusion of values into computations, the composite δ = θ ◦ next: LA → LA is an operation that adds one time step to a computation, and the bottom element ⊥ = fix(θ) is the diverging computation. In fact, any d-algebra has a bottom element and an operation δ as defined above, and homorphisms preserve this structure.
Interpretation
The interpretation function J·) : TypePCF  →U is defined by induction.

Jnat) =de=f Jτ → σ) =de=f
LN
Jτ ) → Jσ)

The denotation of every type is a d-algebra: the map θσ : dJσ) → Jσ) is defined by induction on σ by
θσ→τ = λf : d(Jσ) → Jτ )).λx : Jσ).θτ (f ② next(x))

5 Since guarded recursive types are encoded using universes, L is strictly an operation on U. We will only apply L to types that have codes in U.


Jx1 : σ1, ··· , xk : σk ▶ xi)(γ)= πiγ
JΓ ▶ n : nat)(γ)= η(n)
JΓ ▶ Yσ M )(γ)= (fixJσ))(λx : dJσ).θσ(next(JM )(γ))) ② x))
JΓ ▶ λx.M )(γ)= λx.JM )(γ, x)
JΓ ▶ MN )(γ)= JM )(γ)JN )(γ)
JΓ ▶ succ M )(γ)= L(λx.x + 1)(JM )(γ))
JΓ ▶ pred M )(γ)= L(λx.x − 1)(JM )(γ))
JΓ ▶ ifz L M N )(γ)= (i^fz(JM )(γ), JN )(γ)))(JL)(γ))

Fig. 4. Interpretation of terms
Typing judgements Γ ▶ M : σ are interpreted as usual as functions from JΓ) to Jσ), where the interpretation of contexts is defined as Jx1 : σ1, ··· , xk : σk) =de=f Jσ1) ×· · ·× Jσn). Figure 4 defines the interpretation of judgements. Below we often write JM ) rather than JΓ ▶ M : σ). Natural numbers in PCF are computations that produce a value in zero step, so we interpret them by using η. In the case of Yσ we have by induction a map JM )(γ) of type Jσ) → Jσ). Morally, JΓ ▶ Yσ M )(γ) should be the fixed point of JM )(γ) composed with δ, ensuring that each unfolding of the fixed point is recorded as a step in the model, but to get the types correct, we have to apply the functorial action of d to JM )(γ) and compose with θ instead of δ. The intuition given above is captured in the following lemma.
Lemma 4.1 Let Γ ▶ M : σ → σ then JYσ M ) = δσ ◦ JM (Yσ M ))
We now explain the interpretation of ifz L M N .	Define first a semantic ifz : Jσ) → Jσ) → N → Jσ) operation by
ifz x y 0 =de=f x	ifz x y (n + 1) =de=f y
The operation i^fz : Jσ) → Jσ) → Jnat) → Jσ) is defined by i^fz x y being the
extension of ifz x y to a homomorphism of d-algebras. As a direct consequence of this definition we get
Lemma 4.2  (i)
J λx : nat. ifz x M N )(θ(r)) = θ(next(J λx : nat. ifz x M N )(γ)) ② r)
(ii) If JL)(γ)= δ(JLj)(γ)), then Jifz L M N )(γ)= δJifz Lj M N )(γ)
Soundness
The soundness theorem states that if a program M evaluates to a value v in k steps then the interpretation of M is equal to the interpretation of v delayed k times by the semantic delay operation δ. Thus the soundness theorem captures not just extensional but also intensional behaviour of terms.

The theorem is proved using the small-step semantics. We first need a lemma for the single step reduction.
Lemma 4.3 Let M be a closed term of type τ. If M →k N then JM )(∗)= δkJN )(∗)
Proof. The proof goes by induction on M →k N , and here we only consider two cases. The case of Yσ M →1 M (Yσ M ) follows from Lemma 4.1. In the case of ifz M1 N1 N2 →1 ifz M2 N1 N2, the induction hypothesis gives JM1) = δ ◦ JM2), and now Lemma 4.2 applies proving the case.	2
We prove it now for ⇒k.
Lemma 4.4 Let M bea closed term of type τ, if M ⇒k N then JM )(∗)= δkJN )(∗)
Proof. By induction on k. The case k = 0 follows from Lemma 4.3. Assume k = kJ + 1. By definition we have M →0 MJ and MJ →1 MJJ and D(MJJ ⇒k′ N ). By repeated application of Lemma 4.3 we get JM )(∗) = JMJ)(∗) and JMJ)(∗) = δ(JMJJ)(∗)).
By induction hypothesis we get D(JMJJ)(∗)= δk′ JN )(∗)). By gDTT rule TY − COM
d
this implies next(JMJJ)(∗)) = next(δk′ JN )(∗))) and since δ = θ ◦ next, this im-
plies δJMJJ)(∗) = δkJN )(∗).	By putting together the equations we get finally
JM )(∗)= δkJN )(∗).	2
The Soundness theorem follows from the fact that the small-step semantics is equivalent to the big step, which is Corollary 3.6.
Theorem 4.5 (Soundness) Let M be a closed term of type τ, if M ⇓k v then
JM )(∗)= δkJv)(∗)
Computational Adequacy
In this section we prove that the denotational semantics is computationally ade- quate with respect to the operational semantics. At a high level, we proceed in the standard way, by constructing a logical relation Rσ between denotations Jσ) and terms TermPCF and then proving that open terms and their denotation respect this relation (Lemma 5.6 below). We define our logical relation in guarded dependent type theory, so formally, it will be a map into the universe U of types. Thus we work with a proof-relevant logical relation, similar to what was recently done in work of Benton et. al. [3].
To formulate the definition of the logical relations and also to carry out the proof of the fundamental theorem of logical relations, we need some more sophisticated features of gDTT, which we now recall.
Guarded Dependent Type Theory
We recall some key features of gDTT; see [8] for more details.

As mentioned in Section 2, the later functor d is an applicative functor. Guarded dependent type theory extends the later application ②: d(A → B) → dA → dB to the dependent case using a new notion of delayed substitution: if Γ ▶ f : dΠ(x : A).B and Γ ▶ t : dA, then the term f ② t has type d [x › t] .B, where [x › t] is a delayed substitution. Note that since t has type dA, and not A, we can not substitute t for x in B. Intuitively, t will eventually reduce to some value next u, and at that time the resulting type should be dB[u/x]. But when t is an open term, we can not perform this reduction, and thus can not type this term. Hence we use the type mentioned earlier d [x › t] .B, in which x is bound in B. Definitional equality rules allow us to simplify this type when t has form next u, i.e.,
d[x › next u].B  dB[u/x]
as expected. Here we have just considered a single delayed substitution, in general, we may have sequences of delayed substitutions (such as d [x › t, y › u] .C).
Delayed substitutions can also occur in terms, e.g., if Γ,x : A ▶ t : B and Γ ▶ u : dA, then Γ ▶ next [x › u] .t : d [x › u] .B. Using this, one can express a generalisation of the rule (1)
El(^d(next ξ.A))  dξ. El(A)	(2)
where ξ ranges over delayed substitutions. We recall the following rules from [8] which we will need in the development below. The notation ξ[x › t] means the extension of the delayed substitution ξ with [x › t].

Of these, (3) and (4) can be considered β and η laws, and (5) is a weakening principle.
Rather than be taken as primitive, later application ② can be defined using delayed substitutions as


g ② y =de=f
next [f › g, x › y] .f (x)

Note that with this definition, the rule next(f (t)) = next f ② next t from Section 2 generalises to
next ξ.(f t)= (next ξ.f ) ② (next ξ.t)
which follows from (3).
Logical Relation
In this section we define a logical relation to prove the adequacy theorem. This relation is a function to U.

We introduce the following notation:
Notation 1 Let R : A → B → U be a relation from A to B, t of type dA and u

of type dB. Deﬁne t dR u =de=f
d [x › t, y › u] .(x R y)

More precisely, we can define t dR u as a term of type U by defining it to be d(next [x › t, y › u] .(x R y)), what we have defined above are the elements of this term. From this, one can prove that
((next ξ.t) dR (next ξ.u))  dξ.(tRu)	(6)
using (3) and (2).
Lemma 5.1 The mapping λR. dR : (A → B → U) → dA → dB → U is contrac- tive, i.e., can be factored as F ◦ next for some F : d(A → B → U) → dA → dB → U.
Proof. Define F (S) xy = ^d(S ② x ② y).	2
Definition 5.2 [Logical Relation] The logical relation Rτ : Jτ ) × TermPCF → U is inductively defined on types.

η(v) Rnat M =de=f θnat(r) Rnat M =de=f
M ⇓0 v
ΣMj,Mjj : Term
PCF
.M →0 Mj and Mj →1 Mjj and r dRnat next(Mjj)

f Rτ→σ M =de=f
Πα : Jτ ),N : TermPCF.α Rτ N =⇒ f (α) Rσ (MN )

The definition of Rnat is by guarded recursion using Lemma 5.1.
We now prove a series of lemmas needed for the proof of computational adequacy. The first states that the applicative functor action ② respects the logical relation.
Lemma 5.3 If f dRτ→σ next(M ) and r dRτ next(L) then (f ②r) dRσ next(ML).
Proof. The first hypothesis unfolds to
d [g › f ] .(g Rτ→σ M )  d [g › f ] .(Π(y : Jσ))(L : TermPCF).y Rτ L → g(y) Rσ ML) By delayed application of this to r, next(L) and the second hypothesis we get
d [g › f, y › r] .(g(y) Rσ ML), which by (6) reduces to
next [g › f, y › r] .(g(y)) dRσ next [g › f, y › r] .(ML)  (f ② r) dRσ next(ML) .

2
The following lemma generalises the second case of Rnat to all types.
Lemma 5.4 Let α of type dJσ) and two terms N and M, if (α dRσ next(N )) and
M →1 N then θσ(α) Rσ M
Proof. The proof is by induction on σ. The case σ = nat is by definition of Rnat .

For the induction step, suppose α of type dJτ1 → τ2), and M , N are closed terms such that α dRτ →τ next(N ) and M →1 N . We must show that if β : Jτ1), P : TermPCF and β Rτ1 P then (θτ1→τ2 (α))(β) Rτ2 (MP ).
So suppose β Rτ1 P , and thus also d(β Rτ1 P ) which is equal to next(β) dRτ1 next(P ).
By applying Lemma 5.3 to this and α dRτ1→τ2  next(N ) we get
α ② (next(β)) dRτ2  next(NP )
Since M →1 N also MP →1 NP , and thus, by the induction hypothesis for τ2, θτ2 (α ② (next(β))) Rτ2 MP . Since by definition θτ1→τ2 (α)(β) = θτ2 (α ② next(β)), this proves the case.	2
Lemma 5.5 If M →0 N then α Rσ M iff α Rσ N
Proof. The proof is by induction on σ. We show the left to right implication in the case of σ = nat. We proceed by case analysis on α and show the case of α = θnat(r). From the assumption α Rσ M we have that there exists Mj and Mjj
such that M →0 Mj and Mj →1 Mjj and α dRnat next(Mjj). By determinism
of the small-step semantics (Lemma 3.1) the reduction M →0 Mj must factor as
M → N →0 Mj and thus α Rnat N as desired.	2
We can now finally prove the fundamental lemma, which can be thought of as a strengthened induction hypothesis for computational adequacy, generalised to open terms.
Lemma 5.6 (Fundamental Lemma) Let Γ ▶ t : τ, suppose Γ ≡ x1 : τ1,	, xn :
τn and ti : τi, αi : Jτi) and αi RJτi) ti for i ∈ {1,..., n}, then Jt)(α) Rτ t[t/x]
Proof. The proof is by induction on the height of the typing judgement, and we just show the two most difficult cases.
We start off by the case Γ ▶ Yσ M : σ. The argument is by guarded recursion: we assume
d(JYσ M )(α) Rσ (Yσ M )([t/x]))	(7)
and prove JYσ  M )(α) Rσ (Yσ  M )([t/x]).	By induction hypothesis we know
JM )(α) Rσ→σ M [t/x], hence we derive d(JM )(α) Rσ→σ M [t/x]), i.e.,
d(Πα : Jσ).N : TermPCF. α Rσ N ⇒ JM )(α)(α) Rσ (M [t/x]N ))	(8)
Applying (8) to (7) we get
d(JM )(α)(JYσ M )(α)) Rσ (M [t/x](Yσ M [t/x]))) which is equal as types to
d(JM (Yσ M ))(α) Rσ (M (Yσ M ))[t/x]
  next(JM (Yσ M ))(α)) dRσ next((M (Yσ M ))[t/x])

Thus, by Lemma 5.4
θσ(next(JM (Yσ M ))(α))) Rσ (Yσ M )([t/x]) and as δσ = θσ ◦ next, by Lemma 4.1
JYσ M )(α) Rσ (Yσ M )([t/x])
as desired.
Now the case of Γ ▶ ifz L M N : σ. This case can be proved by showing that
Jλy. ifz y M N )(α) Rnat→σ  (λy. ifz y M N )[t/x]
and then applying this to the induction hypothesis JL)(α) Rnat L[t/x]. The argu- ment is by guarded recursion. Assume
d(Jλy. ifz y M N )(α) Rnat→σ (λy. ifz y M N )[t/x])	(9) We must show that if β : Jnat), L : TermPCF and β Rnat L then
Jλy. ifz y M N )(α)(β) Rσ ((λy. ifz y M N )[t/x](L))
We proceed by case analysis on β. The interesting case is β = θnat(r). Here r is of type dJnat) and L : TermPCF. The hypothesis θnat(r) Rnat L states that there exist Lj, Ljj : TermPCF s.t. L →0 Lj, Lj →1 Ljj and
r dRnat next(Ljj)	(10)
Since (9) is equal to
(next(Jλy. ifz y M N )(α))) dRnat→σ next((λy. ifz y M N )[t/x]) We can apply Lemma 5.3 to that and (10) to get (using Lemma 5.5)
(next(Jλy. ifz y M N )(α)) ② r) dRσ next(ifz Ljj M [t/x] N [t/x])
By Lemma 5.4 with Lj →1 Ljj this implies
θσ(next(Jλy. ifz y M N )(α)) ② r) Rσ (ifz Lj M [t/x] N [t/x])
and by Lemma 4.2 along with repeated application of Lemma 5.5 this implies
Jλy. ifz y M N )(α)(β) Rσ  (λy. ifz y M N )[t/x](L)
thus getting what we wanted.	2
We have now all the pieces in place to prove adequacy.

Theorem 5.7 (Computational Adequacy) If M is a closed term of type nat
then M ⇓k v iff JM )(∗)= δkJv).
Proof. The left to right implication is soundness (Theorem 4.5). For the right to left implication note first that the Fundamental Lemma (Lemma 5.6) implies

δk(Jv)) Rnat M . To complete the proof it suffices to show that δk
(Jv)) Rnat M

implies M ⇓k v.
This is proved by guarded recursion: the case of k = 0 is immediate by definition

of Rnat . If k = kj+1 first assume δk
(Jv)) Rnat M . By definition of R there exist

Mj and Mjj such that M →0 Mj, Mj →1 Mjj and next(δk—1(Jv))) dRnat next(Mjj)
∗	nat
which is type equal to d(δk—1(Jv)) Rnat Mjj). By the guarded recursion assumption we get d(Mjj ⇓k—1 v) which by Lemma 3.3 implies M ⇓k v.	2
Remark 5.8 In the topos of trees model Jnat)(n) ∼= {1,.  , n}× N + {⊥}. Values
are modelled as elements of the form (1, k) and δ is defined as δ(j, k)= (j + 1, k) if j < n and δ(n, k)= ⊥. Thus, if a term M diverges, then JM )(∗)= δkJv) holds at stage n whenever k ≥ n explaining the need for M ⇓k v to be true also at stage n when k ≥ n.
The external viewpoint
The adequacy theorem is a statement formulated entirely in gDTT, relating two notions of semantics also formulated entirely in gDTT. While we believe that gDTT is a natural setting to do semantics in, and that the result therefore is interesting in its own right, it is still natural to ask what we proved in the “real world”. One way of formulating this question more precisely is to use the interpretation of gDTT in the topos of trees (henceforth denoted by Q−¢). For example, the types of PCF types, terms and values are inductively defined types, which are interpreted as constant presheaves over the corresponding sets of types, terms and values. Types of PCF as understood in set theory, thus correspond bijectively to global elements of QTypePCF ¢, which by composing with the interpretation of PCF defined in gDTT gives rise to an object in the topos of trees. Likewise, a PCF term gives rise to a morphism in the topos of trees. Thus, essentially by composing the interpretation of PCF given above with the interpretation of gDTT, we get an interpretation of PCF into the topos of trees, which we will denote by J−)ext.

We denote by M ⇓k
v the usual external formulation of the big-step semantics

for PCF obtained from Figure 2 by removing ds and replacing dependent sums by existential quantifiers (see e.g. [10]).
Lemma 6.1 The type QM ⇓k Q¢ is globally inhabited iff there exists a value v such

that M ⇓k
v and QQ(v)¢ is globally inhabited.

Proof. The proof is by induction over k and then M . Here we sketch the fix-point case. The object QYσ M ⇓k+1 Q¢ is globally inhabited iff Qd(M (Yσ M ) ⇓k Q)¢ is globally inhabited. Since the set of global elements of an object A is isomorphic to the set of global elements of dA, the latter holds iff QM (Yσ M ) ⇓k Q¢ is globally

inhabited.
By induction hypothesis, QM (Yσ M ) ⇓k Q¢ is globally inhabited iff there exists

a value v such that M (Yσ M ) ⇓k
v and QQ(v)¢ is globally inhabited. The former

holds iff Yσ M ⇓k+1 v, thus concluding the proof.	2
As a special case, Theorem 5.7 states that QM ⇓k v¢ is inhabited by a global element iff QJM )(∗) = δkJv)¢ is inhabited by a global element. Since the topos of trees is a model of extensional type theory, the latter holds precisely when JM )ext = δkJv)ext.
Theorem 6.2 (Computational Adequacy, externally) If ▶ M : σ with σ a
ground type, then M ⇓k	v iff JM )ext(∗)= δkJv)ext
Theorem 6.2 is a restatement of Escardo’s adequacy result for PCF in metric spaces [10, Theorem 4.1]. Precisely, Escardo’s model construction uses complete bounded ultrametric spaces. Since the spaces used are all bisected, Escardo’s model can be embedded in the topos of trees [6, Section 5] and up to this embedding, his model agrees with the externalisation of the model constructed in this paper.

Discussion and Future Work
In earlier work, it has been shown how guarded type theory can be used to give abstract accounts of operationally-based step-indexed models [6,15]. There the op- erational semantics of the programming language under consideration is also defined inside guarded type theory, but there are no explicit counting of steps (indeed, part of the point is to avoid the steps). Instead, the operational semantics is defined by the transitive closure of a single-step relation — and, importantly, the transitive closure is defined by a fixed point using guarded recursion. Thus some readers might be surprised that we use a step-counting operational semantics here. The reason is simply that we want to show, in the type theory, that the denotational semantics is adequate with respect to an operational semantics and since the denotational semantics is intensional and steps thus matter, we also need to count steps in the operational semantics to formulate adequacy.
In previous work [6] we have studied the internal topos logic of the topos of trees model of guarded recursion and used this for reasoning about advanced pro- gramming languages. In this paper, we could have likewise chosen to reason in topos logic rather than type theory. We believe that the proofs of soundness and computational adequacy would have gone through also in this setting, but the in- teraction between the d type modality and the existential quantifiers in the topos of trees, makes this an unnatural choice. For example, one can prove the statement
∃k.∃v. Ynat (λx.x) ⇓k v in the internal logic using guarded recursion as follows: assume d(∃k.∃v. Ynat (λx.x) ⇓k v). Because nat is total and inhabited we can pull out the existentials by Theorem 2.7.4 in [6] and derive ∃k.∃v.d(Ynat (λx.x) ⇓k v) which implies ∃k.∃v. Ynat (λx.x) ⇓k v. The corresponding statement in type the-
ory: Σ k, v. Ynat (λx.x) ⇓k v is not derivable as can be proved using the topos of

trees. Intuitively the difference is the constructiveness of the dependent sum, which allows us to extract the witnesses k and n.
In future work, we would like to explore models of FPC (i.e., PCF extended with recursive types) and also investigate how to define a more extensional model by quotienting the present intensional model. The latter would be related to Escardo’s results in [10].
Acknowledgement
We thank Aleˇs Bizjak for fruitful discussions.

References
Andrew W Appel, Paul-Andr´e Melli`es, Christopher D Richards, and J´erˆome Vouillon. A very modal model of a modern, major, general type system. In POPL, pages 109–122, 2007.
Robert Atkey and Conor McBride. Productive coprogramming with guarded recursion. In ICFP, pages 197–208, 2013.
Nick Benton, Martin Hofmann, and Vivek Nigam. Abstract effects and proof-relevant logical relations. In POPL, 2014.
Nick Benton, Andrew Kennedy, and Carsten Varming. Some domain theory and denotational semantics in coq. In Theorem Proving in Higher Order Logics, 22nd International Conference, TPHOLs 2009, Munich, Germany, August 17-20, 2009. Proceedings, pages 115–130, 2009.
Lars Birkedal and Rasmus Ejlers Møgelberg. Intensional type theory with guarded recursive types qua fixed points on universes. In LICS, pages 213–222, 2013.
Lars Birkedal, Rasmus Ejlers Møgelberg, Jan Schwinghammer, and Kristian Støvring. First steps in synthetic guarded domain theory: step-indexing in the topos of trees. LMCS, 8(4), 2012.
Ales Bizjak, Lars Birkedal, and Marino Miculan. A model of countable nondeterminism in guarded type theory. In RTA-TLCA, pages 108–123, 2014.
Aleˇs Bizjak, Hans Bugge Grathwohl, Ranald Clouston, Rasmus Ejlers Møgelberg, and Lars Birkedal. Guarded dependent type theory with coinductive types. Manuscript, 2015.
Venanzio Capretta. General recursion via coinductive types. Logical Methods in Computer Science, 1(2), 2005.
M.H. Escardo. A metric model of PCF. Laboratory for Foundations of Computer Science, University of Edinburgh,
http://www.dcs.st-and.ac.uk/~mhe/, April 1999.
C. McBride and R. Paterson. Applicative programming with effects. Journal of Functional Programming, 18(1), 2008.
Rasmus Ejlers Møgelberg. A type theory for productive coprogramming via guarded recursion. In
CSL-LICS, 2014.
Hiroshi Nakano. A modality for recursion. In LICS, pages 255–266, 2000.
G. Plotkin. LCF considered as a programming language. Theoretical Computer Science, 5(3):223–256, December 1977.
Kasper Svendsen and Lars Birkedal. Impredicative concurrent abstract predicates. In ESOP, 2014.
