Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 347 (2019) 223–239
www.elsevier.com/locate/entcs
Towards a Directed Homotopy Type Theory
Paige Randall North1,2
Department of Mathematics The Ohio State University Columbus, OH, USA

Abstract
In this paper, we present a directed homotopy type theory for reasoning synthetically about (higher) categories and directed homotopy theory. We specify a new ‘homomorphism’ type former for Martin-L¨of type theory which is roughly analogous to the identity type former originally introduced by Martin-Lo¨f. The homomorphism type former is meant to capture the notions of morphism (from the theory of categories) and directed path (from directed homotopy theory) just as the identity type former is known to capture the notions of isomorphism (from the theory of groupoids) and path (from homotopy theory). Our main result is an interpretation of these homomorphism types into Cat, the category of small categories. There, the interpretation of each homomorphism type homC (a, b) is indeed the set of morphisms between the objects a and b of the category C. We end the paper with an analysis of the interpretation in Cat with which we argue
that our homomorphism types are indeed the directed version of Martin-L¨of’s identity types.
Keywords: dependent type theory, directed homotopy theory, semantics of type theory


Introduction
Martin-Lo¨f type theory, together with its identity type, is now often described as a synthetic theory of higher groupoids. This rich structure of the identity type was first discovered by Hofmann and Streicher in their disproof of the uniqueness of identity proofs [3]. There, the authors construct an interpretation of Martin-L¨of’s identity type into the category of groupoids where for any terms a, b in a type G, the identity type IdG (a, b) is interpreted to be the set of morphisms a → b in the groupoid interpreting G.
The full extent of this structure was later made explicit in Voevodsky’s interpre- tation of Martin-L¨of type theory with the identity type (amongst other types) into the category of Kan complexes, the objects of which represent spaces or ∞-groupoids

1 This material is based upon work supported by the Air Force Office of Scientific Research under award number FA9550-16-1-0212. We also acknowledge the support of COST Action EUTypes CA15123 and the Centre for Advanced Study (CAS) in Oslo, Norway, which funded and hosted the research project Homotopy Type Theory and Univalent Foundations during the 2018/19 academic year.
2 Email: north.138@osu.edu

https://doi.org/10.1016/j.entcs.2019.09.012
1571-0661/© 2019 The Author(s). Published by Elsevier B.V.
This is an open access article under the CC BY license (http://creativecommons.org/licenses/by/4.0/).

[6]. In this interpretation, the identity type IdK(a, b) of any two points a, b in a Kan complex K is itself a Kan complex, or space.
In addition to these concrete interpretations, others (e.g. [13,2,9]) have compared Martin-L¨of’s specification of the identity types with the part of Quillen’s axioma- tization of homotopy theory that is today called the theory of weak factorization systems [11,1]. In [9], the author has shown that in any finitely complete category, models of Martin-Lo¨f’s identity type are in correspondence with weak factorization systems with two stability properties.
Such results present an illuminating perspective on the theory of higher groupoids. This theory is, to some extent, already very well understood by topologists who have studied concrete models of it for the better part of a century. However, if one thinks of the theory of higher groupoids as being a theory of (reversible) paths, then one might wonder whether there is also a type theory which describes a theory of irreversible, or directed, paths. One might hope that such a type theory would shed light on the less well understood theories of higher categories and directed spaces. Both of these theories have a notion of directed paths at their heart, and for both of these theories, there are many competing concrete models. Thus, having a synthetic theory of directed paths might shed light on this situation.
In this paper, we present the core of such a type theory. Our long-term goal is to use this type theory to prove and verify theorems about higher categories and directed homotopy theory.

Previous work
Several other type theories with semantics in category theories have been proposed. In [7], the authors construct a type theory that gives a synthetic theory of 1-categories. In [12], the authors construct a type theory that gives a theory of (∞, 1)-categories. Other works-in-progress [10,14] do hope to give a theory of ∞-categories.
In this paper, we aim to give a syntax which not only describes ∞-categories but also directed spaces. We have three design criteria: (1) that our notion of directed paths is introduced via a type former and not as a judgement, so that it can be iterated as Martin-L¨of’s identity type can be, (2) that our theory allows us to transport terms of dependent types along directed paths, and (3) that our theory does not always allow us to transport terms of the type of directed paths along identities, since such a transportation does not hold in categories of directed spaces. The syntaxes of [7] and [10] do not meet our first criterion since their directed paths are introduced as a judgement and not as a type former. This seems to make the theory somewhat unwieldy: in [7], only the theory of 1-categories is introduced and [10] includes no semantics. The theory of [14] does not meet our second criterion,
and the theory of [12] does not meet our third criterion.

Organization
In Section 2, we present the syntax for our type theory, which consists of one new type former hom within Martin-Lo¨f type theory. In Section 3, we interpret the rules

of this new type former hom within a comprehension category derived from the category Cat of small categories. Even though the objects of Cat are simpler than those of our intended semantics (higher categories and directed spaces), we see this as an important test case since its theory is much better understood than those of of our intended semantics.

The syntax
In this section, we define a type of homomorphisms within standard Martin-Lo¨f type theory [8]. We only work in the bare type theory. That is, we assume that we have all the structural rules of [8], but none of the type-forming rules given there.
First, we require that for every type T , there are two new types


Γ ▶ T TYPE


Γ ▶ T core TYPE
Γ ▶ T TYPE


Γ ▶ T op TYPE



together with the following functions.
Γ ▶ T TYPE	Γ ▶ t : T core


Γ ▶ i(t): T


Γ ▶ T TYPE	Γ ▶ t : T core


Γ ▶ iop(t): T op

Now we can define our type of homomorphisms.

hom formation :	hom introduction :

Γ ▶ T TYPE	Γ ▶ s : T op	Γ ▶ t : T
Γ ▶ homT (s, t) TYPE
Γ ▶ T TYPE	Γ ▶ t : T core


Γ ▶ 1t : homT (iopt, it) TYPE


right hom elimination :
Γ ▶ T TYPE
Γ,s : T core ▶ Θ TYPE	Γ,s : T core,t : T, f : homT (iops, t),θ :Θ ▶ D TYPE
Γ,s : T core,θ :Θ ▶ d : D[is/t, 1s/f ]
Γ ▶ sj : T core	Γ ▶ tj : T	Γ ▶ fj : homT (iopsj, tj)	Γ ▶ θj : Θ[sj/s]
Γ ▶ eR(s.Θ, s.t.f.θ.D, s.θ.d, sj, tj,fj, θj): D[sj/s, tj/t, fj/f, θj/θ]

left hom elimination :
Γ ▶ T TYPE
Γ,t : T core ▶ Θ TYPE	Γ,s : T op,t : T core,f : homT (s, it),θ :Θ ▶ D TYPE
Γ,t : T core,θ :Θ ▶ d : D(iopt/s, 1t/f )
Γ ▶ sj : T op	Γ ▶ tj : T core	Γ ▶ fj : homT (sj, itj)	Γ ▶ θj : Θ[tj/t]
Γ ▶ eL(t.Θ, s.t.f.θ.D, t.θ.d, sj, tj,fj, θj): D[sj/s, tj/t, fj/f, θj/θ]

right hom computation :
Γ ▶ T TYPE
Γ,s : T core ▶ Θ TYPE	Γ,s : T core,t : T, f : homT (iops, t),θ :Θ ▶ D TYPE
Γ,s : T core,θ :Θ ▶ d : D[is/t, 1s/f ]	Γ ▶ sj : T core	Γ ▶ θj : Θ[sj/s]
j	j	j	j	j	j	op j	j
Γ ▶ eR(s.Θ, s.t.f.θ.D, s.θ.d, s , is , 1s′ ,θ )= d[s /s, θ /θ]: D[s /s, i  s /t, 1s′ /f, θ /θ]

left hom computation :
Γ ▶ T TYPE
Γ,t : T core ▶ Θ TYPE	Γ,s : T op,t : T core,f : homT (s, it),θ :Θ ▶ D TYPE
Γ,t : T core,θ :Θ ▶ d : D(iopt/s, 1t/f )	Γ ▶ tj : T core	Γ ▶ θj : Θ[tj/t]
op j  j	j	j	j	op j	j	j
Γ ▶ eL(t.Θ, s.t.f.θ.D, t.θ.d, i t ,t , 1t′ ,θ )= d[t /t, θ /θ]: D[i t /s, t /t, 1t′ /f, θ /θ]
Transportation and composition
Before we develop semantics for these rules, we prove some illustrative results in the syntax.
First, we show that we can transport types along homomorphisms, which is analogous to the transportation along identities in homotopy type theory.
Proposition 2.1 For any type Γ,t : T ▶ E TYPE, any term Γ,s : T core ▶ ej : E[is/t], and any homomorphism Γ ▶ sj : T core, Γ ▶ tj : T, Γ ▶ f : homT (iopsj, tj), we have a term Γ ▶ transportR(ej,f ): E[tj/t].
Proof. By plugging the data
Γ ▶ T TYPE
Γ,s : T core ▶ E[is/t]
Γ,s : T core,t : T, f : homT (iops, t),e : E[is/t] ▶ E TYPE
Γ,s : T core,e : E[is/t] ▶ e : E[is/t]
Γ ▶ sj : T core
Γ ▶ tj : T
Γ ▶ f : homT (iopsj, tj)
Γ ▶ ej : E[isj/t]
into the right hom computation rule, we find a term
Γ ▶ eR(s.E[is/t], s.t.f.e.E, s.e.e, sj, tj, f, ej): E[tj/t]
which we abbreviate by transportR(ej,f ).	2
Now using this transportation, we can show that we can compose two homomor- phisms.
Proposition 2.2 For any type Γ ▶ T TYPE, any terms Γ ▶ r : T op, Γ ▶ s : T core, Γ ▶ t : T, and any homomorphisms Γ ▶ f : homT (r, is) and Γ ▶ g : homT (iops, t), we have a homomorphism Γ ▶ compR(f, g): homT (r, t).

Proof. Using Proposition 2.1, we obtain a term Γ ▶ transportR(f, g) : homF (r, t) which we call compR(f, g).	2
By the right hom computation rule, we find that for any f : homF (r, is), the composition compR(f, 1s) is strictly equal to f : homF (r, is). Using left hom elimi- nation, we could analogously construct a left transportation transportL and a left composition compL such that for any g : homF (iops, t), the composition compL(1s, g) is strictly equal to g in the type homF (iops, t).
The semantics in Cat
In this section, we construct an interpretation in the category of categories.
We work in a set theory with two uncountable inaccessible cardinals κ < λ. Let Cat denote the category of κ-small categories, and let CAT denote the 2-category of λ-small categories. We have arranged this so that CAT contains both Cat and all the objects of Cat. Note that there are no universes in our syntax, so this is as much of a tower of universes in the semantics as we need.
Grothendieck (op)ﬁbrations
The theory of Grothendieck fibrations and opfibrations play a central role in this interpretation, so we briefly review it here. See [5] for more details.
Consider a functor P : E → B in CAT . We say that a morphism e : EJ → E in E is cartesian if for any other morphism eJ : EJJ → E in E , any factorization of P (eJ) through P (e) (that is, a morphism b : P (EJJ) → P (EJ) such that P (e) ◦ b = P (eJ)) lifts uniquely to a factorization of eJ through e (that is, there is a unique morphism l : EJJ → EJ such that e ◦ l = eJ and P (l)= b).

e′
E	EJJ  	 E¸J	e	 zE¸ 
P

  
B	P (E
JJ)
  b	 P¸(EJ)
P (e′)
P (e)  ˛E¸ 


The archetypical cartesian morphisms are pullback squares, in the following sense. First, let 2 denote the poset 0 ≤ 1. Then C2 is the category of morphisms of a category C. Let cod : C2 →C be the functor which sends each morphism to its codomain. Now consider any category C in CAT with all pullbacks. Then a morphism in C2 whose underlying diagram in C is a pullback square is a cartesian morphism with respect to the functor cod.
A functor P : E → B in CAT is a Grothendieck ﬁbration if for any object E of E , any morphism b : B → P (E) in B can be lifted to a cartesian morphism e : EJ → E (so that P (e)= b).
The archetypical Grothendieck fibration is a functor of the form cod : C2 →C 
for any category C with all pullbacks. This is because for any object f in C2 (which

is a morphism f : X → Y in C) and morphism g : Z → cod(f ) in C, the pullback square π : g∗f → f is a cartesian morphism in C2 which is a lift of g.
Dually, we can define cocartesian morphisms and Grothendieck opfibrations.
For a functor P : E → B in CAT , a cocartesian morphism in E is a cartesian morphism in Eop with respect to the functor Pop. Then our archetypical cocartesian morphisms are pushout squares in any C2 with respect to the functor dom : C2 → C.
A Grothendieck opﬁbration is a functor P : E → B in CAT such that Pop is a
Grothendieck fibration. Our archetypical Grothendieck opfibration is dom : C2 →C 
for any category C with all pushouts.
One reason that Grothendieck (op)fibrations have been of interest is that they are equivalent to pseudofunctors into Cat. We will not make full use of that equivalence here, but we will make use of the Grothendieck construction. Consider any category C in Cat, and any functor F : C → Cat. We can construct, following Grothendieck, a new category C.F as follows. The objects of C.F are pairs (X, Y ) where X is an object of C and Y is an object of F (X). Morphisms (X, Y ) → (Xj,Y j) in C.F are pairs (f, g) where f : X → Xj is a morphism in C and g : F (f )(Y ) → Y j is a morphism in F (Xj). Then there is a projection functor πC : C.F →C which takes each pair (X, Y ) to X. The functor πC is a Grothendieck opfibration since given any (X, Y ) in C.F , we can lift any morphism f : X → Xj in C to the cocartesian morphism (f, 1F (Y )): (X, Y ) → (Xj,F (Y )) in C.F .
Dually, given any functor of the form F : Cop → Cat, one can construct a
Grothendieck fibration πC : C.F → C. The objects of C.F are still pairs (X, Y ) such that X is an object of C and Y is an object of F (X), but the morphisms (X, Y ) → (Xj,Y j) of C.F are pairs (f, g) such that f : X → Xj is a morphism in C and g : Y → F (f )(Y j) is a morphism in F (X).

The comprehension category
A comprehension category over Cat (following [4]) consists of a category E , a functor χ : E → Cat2, and a Grothendieck fibration G : E → Cat in CAT making the following diagram commute and such that χ sends cartesian morphisms in E to cartesian morphisms in Cat2 (that is, pullback squares).
E 	χ	 Ca¸t2

Cat
When interpreting a type theory into this framework, we take the objects of Cat to be our collection of contexts, the morphisms of Cat to be context morphisms, and each fiber G—1(Γ) to be the collection of types in the context Γ. The terminal category ∗ is the interpretation of the empty context. By applying the functor χ to an object T of G—1(Γ), we obtain a morphism χ(T ) in Cat with codomain Γ; the domain of χ(T ) is the context extension (or comprehension) of Γ by T . Thus, terms in a type T dependent on a context Γ are interpreted by sections of χ(T ).

Problem 3.1 To construct a comprehension category over Cat.
Example 3.2 Before we construct the comprehension category, we indicate what
G—1(∗) (the types in the empty context) will be. This will be the category of functors
∗→ Cat, which is isomorphic to Cat itself. The comprehension functor χ will take a functor of the form C : ∗ → Cat to a functor which is isomorphic to the unique functor C(∗) → ∗. Thus, terms of C are functors ∗→ C(∗), which are just objects of the category C(∗).
Construction 3.3 [for Problem 3.1] Consider the functor
[−, Cat]: Catop → Cat
which takes each object Γ in Cat to the category [Γ, Cat] of functors Γ → Cat in CAT and lax natural transformations between them (note that the notation [Γ, Cat] is slightly nonstandard). Performing the Grothendieck construction on this functor, we get the Grothendieck fibration
πCat : Cat.[−, Cat] → Cat.
The objects of Cat.[−, Cat] are pairs (Γ,T ) where Γ is a category in Cat and T :Γ → Cat is a functor. The morphisms (Γ,T ) → (Γj,Tj) are pairs (F, τ ) where F :Γ → Γj is a functor and τ : T ⇒ T j ◦ F is a lax natural transformation.
Γ   F  C a¸t,


Γj

Now we define the functor χ : Cat.[−, Cat] → Cat2 to be the Grothendieck construction. That is, for any object (Γ,T ) in Cat.[−, Cat], we have
χ(Γ,T )	:=	πΓ : Γ.T → Γ.
For any morphism (F, τ ): (Γ,T ) → (Γj,Tj) we have that χ(F, τ ) is the morphism in
C2 with the following underlying commutative square in Cat
Γ.T 	F.τ	 Γj¸.T j

πΓ
	F
Γ
πΓ′
  
 Γj¸

where F.τ is the functor which sends each (X, Y ) in Γ.T to (F (X), τX (Y )) in Γj.T j.
By Lemma 3.4 below, the functor χ preserves cartesian morphisms.
Now it is straight-forward to check that the following diagram commutes.
Cat.[−, Cat] 	χ	 Ca¸t2

Cat

In particular, on objects, we have codχ(Γ,T ) = cod(πΓ : Γ.T → Γ) = Γ and
πCat(Γ,T )= Γ.	2
Lemma 3.4 The functor χ preserves cartesian morphisms.
Proof. Consider a cartesian morphism (F, τ ): (Γ,T ) → (Γj,Tj) in Cat.[−, Cat].
Γ   F  C a¸t,


Γj

Applying χ to this morphism, we obtain the following morphism in Cat2, which is a commutative square in Cat.
Γ.T 	F.τ	 Γj¸.T j
πΓ	πΓ′
  	  
Γ	 Γj¸
We want to show that this is cartesian with respect to cod : Cat2 → Cat.
So consider a morphism ⟨α, β⟩ : Z → πΓ′ in Cat2 and a morphism γ : Z1 → Γ in
Cat such that Fγ = β as illustrated below.


α

Z0
Z	πΓ

z 
Γj¸.T j
πΓ′



(∗)

   γ	  F
Z1 	 Γ ¸	 Γj¸

β
We need to show that there is a unique δ : Z0 → Γ.T which makes the diagram commute.
Consider the object (Z0, ∗Z0 ) in Cat.[−, Cat] (where ∗Z0 is the functor Z0 → Cat which sends everything to the terminal category). Then there is a morphism (FγZ, α): (Z0, ∗Z ) → (Γj,Tj) where αz is the functor ∗→ T jFγZ(z) which picks out the object α(z) for any object z ∈ Z0.







Γj

Since (F, τ ) is cartesian, there is a unique lax natural transformation δ : ∗Z0 ⇒



TFγZ such that α = τδ. This gives rise to the functor δ : Z0 → Γ.T by setting
δ(z) := (γZ(z), δz(∗)). This makes the diagram (∗) above commute.
If there were another such functor δj making the diagram (∗) commute, by making
j
an analogous argument, we would find another lax natural transformation δ . But

j
then δ
= δ, and so δj
= δ. Thus, δ is the unique functor making the diagram (∗)

commute.
Thus, χ(F, τ ) is cartesian for every cartesian (F, τ ) so χ is cartesian.	2
This comprehension category has a unit η : Cat → Cat.[−, Cat] which takes a category Γ to (Γ, ∗Γ : Γ → Cat) where ∗Γ is the functor which is constant at the terminal category ∗. Then χ(Γ, ∗Γ) is an isomorphism πΓ : Γ.∗Γ → Γ. Recall that for any (Γ,T ) in Cat.[−, Cat], we interpret the terms of T as sections of χ(Γ,T ). These are in bijection with morphisms (Γ, ∗Γ) → (Γ,T ) in the fiber π—1 Γ which are just
morphisms ∗Γ → T in the category [Γ, Cat].
Thus, in the sections that follow, we will interpret contexts as categories Γ in Cat, we will interpret types in context Γ as objects of the category [Γ, Cat] (which are functors Γ → Cat), and we will interpret terms of such an object T in [Γ, Cat] as lax natural transformations ∗Γ ⇒ T .

core and op
In this section, we interpret the type formers core and op and the functions i and iop
into our comprehension category.
Problem 3.5 To construct functorially, from each functor T :Γ → Cat, functors T core :Γ → Cat and T op :Γ → Cat and lax natural transformations i : T core ⇒T and iop : T core ⇒T op.
Example 3.6 Before we give the construction, we describe what it will be in the empty context.
Consider a type C in the empty context, which is just a category. Then Ccore will be just the set 3 of objects of C and Cop will be the usual opposite category of C. Then i : Ccore →C and iop : Ccore → Cop will be the injections which are the identity on objects.
Construction 3.7 [for Problem 3.5] Recall the two oft-encountered endofunctors (−)core and (−)op on Cat. For any category C, the category Ccore is the set ob(C). The objects of Cop are the objects of C, and for all objects X, Y of Cop, the homomorphisms X → Y in Cop are the homomorphisms Y → X in C. There are moreover natural transformations i : (−)core ⇒ idCat and iop : (−)core ⇒ (−)op induced by the identity function on objects.
Postcomposition with the functors (−)core and (−)op gives two functors which take any T :Γ → Cat to T core :Γ → Cat and T op :Γ → Cat, respectively.

3 We will often talk about a set X in the category Cat. To be clear, we mean the category whose objects are the elements of X and whose morphisms are only identity morphisms.

Whiskering with i (resp. iop) gives a functor which takes any T :Γ → Cat to the natural transformation i : T core ⇒T (resp. iop : T core ⇒T op).	2

hom formation
In this section, we interpret the hom formation rule.
Problem 3.8 To functorially construct for each functor T : Γ → Cat and lax natural transformations s : ∗Γ ⇒T op,t : ∗Γ ⇒T , a functor homf (s, t):Γ → Cat.
Example 3.9 In the empty context, our problem reduces to finding for each category C and object (x, y) ∈ Cop × C, a category homC (x, y). Our construction will produce the usual homset homC (x, y).
Construction 3.10 [for Problem 3.8] Let (−)op × idCat : Cat → CAT denote the functor which takes any C ∈ Cat to Cop ×C in CAT . Then let cEet : Cat → CAT be the constant functor at Set, the category of κ-small sets.
There is a lax natural transformation hom : (−)op × idCat ⇒ cEet which at each C ∈ Cat is the usual functor homC : Cop ×C ⇒ Set (which maps an object (X, Y ) ∈ Cop ×C to the set homC (X, Y ) of morphisms X → Y in C).
Cop ×C Fop×F D¸op ×D 

homC
hom
   ====⇒
homD
  

Set	Set
Now for any functor T :Γ → Cat and lax natural transformations s : ∗Γ ⇒T op,t :
∗Γ ⇒T , we have the following diagram of functors and lax natural transformations.


∗Γ
(s,t)  z(—)op ×id
Γ	 Ca¸t


z 
CA¸ T,


(∗)


cSet

By pasting together the diagram above, we obtain a lax natural transformation
homf (s, t): ∗Γ ⇒ cEetT . At every object γ ∈ Γ, this gives a functor homf (s, t)γ :
∗ → Set which is just a set homf (s, t)γ(∗). For every morphism φ : γ → γj in Γ, this produces a lax natural transformation


∗
homT (s,t)γ



hom T (s,t)φ
∗
homT (s,t)γ′

  =======⇒
Set	Set
which is just a function homf (s, t)φ∗ : homf (s, t)γ(∗) → homf (s, t)γj(∗). In other words, homf (s, t) is a functor Γ → Cat.	2

hom introduction
In this section, we interpret the hom introduction rule.
Problem 3.11 To functorially construct for each functor T : Γ → Cat and lax natural transformation t : ∗Γ ⇒ T core, a lax natural transformation 1t : ∗Γ ⇒ homf (iopt, it).
Example 3.12 In the empty context, our problem reduces to finding for each category C and object t ∈ Ccore, an object 1t ∈ homF (t, t). Our construction will produce the usual identity morphism t → t.
Construction 3.13 [for Problem 3.11] For every category C and for every t ∈ Ccore (that is, an object t of C), there is an element 1C ∈ homC (t, t), the identity morphism t → t. Since this is (vacuously) lax natural in t, it assembles into the lax natural transformation shown below



Ccore
c∗


homC (iop ×i)
z
_Se¸t

where c∗ is the constant functor at the terminal set.
This is furthermore natural in C, so it assembles into the following modification.



Cat
(—)core

z_
_CA¸T


cSet

Now, consider a functor T :Γ → Cat and a lax natural transformation t : ∗Γ ⇒ T core. We obtain the following diagram.

∗Γ


T

cSet


Then pasting together this diagram, we obtain a modification c∗ $ homC (iopt, it) which unfolds into a lax natural transformation 1t : ∗Γ ⇒ hom(iopt, it). This has
at each γ ∈ Γ the component 1tγ : ∗ → hom(tγ, tγ) which picks out the identity morphism tγ → tγ.	2
Right hom elimination and computation
In this section, we interpret the right hom elimination rule so that it satisfies the strict equality required by the right hom computation rule.

Problem 3.14 To functorially construct for each functor T :Γ → Cat, each functor Θ : Γ.T core → Cat, each functor D : Γ.T core.T .homf (iop × 1).Θ → Cat, and each lax natural transformation
d : ∗Γ.f core .Θ ⇒D ◦ Γ.1•.Θ: Γ.T	.Θ → Cat,
a lax natural transformation
er(d): ∗Γ.f core .f .homT (iop×1).Θ ⇒D : Γ.T	.T .homf (i	× 1).Θ → Cat,
such that er(d) ◦ Γ.1•.Θ= d.
Example 3.15 Where Γ and Θ are both empty contexts, our problem reduces to finding for each category C, each functor D : Ccore.C.homC (iop × 1) → Cat, and each lax natural transformation d : ∗Ccore ⇒ D ◦ 1• : Ccore → Cat, a lax natural transformation
er(d): ∗Ccore .C.homC (iop×1) ⇒D : C	.C.homC (i	× 1) → Cat,
such that er(d)1• = d.
The objects of Ccore.C.homC (iop × 1) are triples (X, Y, f ) such that f : X → Y is a morphism in C. Its morphisms are of the form g : (X, Y, f ) → (X, Y j,g ◦ f ) where g : Y → Y j is a morphism of C.
Since er(d)1• must be d, we know that er(d)(X,X,1X ) must be d(X) for any object X of Ccore. Now for any other object (X, Y, f ) of Ccore.C.homC (iop × 1), there is a morphism f : (X, X, 1X ) → (X, Y, f ). Then we get a morphism D(f ) : D(X, X, 1X ) → D(X, Y, f ). We apply this functor to d(X) to obtain er(d)f . That is, we set
er(d)f := D(f ) (dX) .
Construction 3.16 [for Problem 3.14] Consider the data given in the Problem. The objects of the category Γ.T core.T .homf (iop × 1).Θ are quintuples (γ, s, t, f, θ) where γ is an object of Γ, f : s → t is a morphism in the category T (γ), and θ is an object of Θ(γ, s). Morphisms in Γ.T core.T .homf (iop × 1).Θ are of the form
(φ, α, β): (γ, s, t, f, θ) → (γj, T (φ)(s), tj, α ◦T (φ)(f ), θj)	(∗) where φ : γ → γj is a morphism in Γ, α : T (φ)(t) → tj is a morphism in T (γj), and
β : Θ(φ)(θ) → θj is a morphism in Θ(γj, T (φ)(s)).
The objects of the category Γ.T core.Θ are triples (γ, t, θ) where γ ∈ Γ, t ∈ T core(γ), and θ ∈ Θ(γ, t). The morphisms are of the form (φ, β) : (γ, t, θ) → (γj,T (φ)(t), θj) where φ : γ → γj is a morphism in Γ and β : Θ(φ)θ → θj is a morphism in Θ(γj,T (φ)(t)).
The functor Γ.1•.Θ : Γ.T core.Θ → Γ.T core.T .homf (iop × 1).Θ takes a triple (γ, t, θ) to the quintuple (γ, t, t, 1t, θ).
Now, to construct the lax natural transformation
er(d): ∗⇒D : Γ.T core.T .homf (iop × 1).Θ → Cat,

we need to first specify all of its components er(d)(γ,s,t,f,θ) : ∗→ D(γ, s, t, f, θ). So fix an object (γ, s, t, f, θ) of the category Γ.T core.T .homf (iop × 1).Θ. To construct a functor er(d)(γ,s,t,f,θ) : ∗ → D(γ, s, t, f, θ) is to find an object of the category D(γ, s, t, f, θ). Consider the morphism (1γ, f, 1θ) : (γ, s, s, 1s, θ) → (γ, s, t, f, θ) in Γ.T core.T .homf (iop × 1).Θ. By applying the functor D, we get a functor
D(1γ, f, 1θ): D◦ Γ.1•(s).Θ= D(γ, s, s, 1s, θ) → D(γ, s, t, f, θ).

Now we apply this functor to the object d(γ, s, θ)(∗) of D◦ Γ.1•.Θ(γ, s, θ) to get
er(d)(γ,s,t,f,θ) as follows:
er(d)(γ,s,t,f,θ)(∗) := D(1γ, f, 1θ)d(γ, s, θ)(∗).

We need to check that this choice is lax natural, which amounts to showing that for any morphism in Γ.T core.T .homf (iop × 1).Θ as in line (∗) above, there is a natural transformation
D(φ, α, β)er (d)(γ,s,t,f,θ)  =⇒  er (d)(γ′,F (φ)(s),t′,αF (φ)(f ),θ′).

But we have
D(φ, α, β)e(d)(γ,s,t,f,θ) = D(φ, α, β)D(1γ, f, 1θ)d(γ, s, θ)
= D(φ, αT (φ)(f ), β)d(γ, s, θ)
= D(1γ′ , αT (φ)(f ), 1θ )D(φ, 1F (φ)s, β)d(γ, s, θ)
j	j	j
⇒ D(1γ′ , αT (φ)(f ), 1θ )d(γ ,T (φ)(s),θ )
= er (d)(γ′,F (φ)(s),t′,αF (φ)(f ),θ′)

where the first equality and last equality come from our definition of er(d), the second and third equalities come from composition in the category Γ.T core.T .homf (iop × 1).Θ, and the natural transformation comes from the lax naturality of d.
Now we only need to check that er(d) ◦ Γ.1•.Θ= d. For any (γ, s, θ) of Γ.T core.Θ, we have that
er(d)Γ.1•.Θ(γ, s, θ)= er(d)(γ, s, s, 1s, θ)
= D(1γ, 1s, 1θ)d(γ, s, θ)
= d(γ, s, θ)
where the first equality is the definition of 1•, the second is the definition of er(d), and the third is the functoriality of D. For any (φ, β): (γ, s, θ) → (γj, T (φ)(s), θj) of Γ.T core.Θ, the natural transformation D(φ, 1F (φ)(s), β)e(d)(γ,s,s,1s,θ)  =⇒ er(d)(γ′,F (φ)(s),F (φ)(s),1T (φ)(s),θ′) defined above reduces to the natural transformation D(φ, 1F (φ)s, β)d(γ, s, θ) =⇒ d(γj,T (φ)(s), θj) given by the lax naturality of d. Therefore, we have that er(d)1• = d.	2

Left hom elimination and computation
In this section, we interpret the left hom elimination rule so that it satisfies the strict equality required by the left hom computation rule. However, it just takes an application of right hom elimination and computation.
Problem 3.17 To functorially construct for each functor T :Γ → Cat, each functor Θ : Γ.T core → Cat, each functor D : Γ.T op.T core.homf (1 × i).Θ → Cat, and each lax natural transformation
d : ∗Γ.f core .Θ ⇒D ◦ Γ.1•.Θ: Γ.T	.Θ → Cat,
a lax natural transformation
er(d): ∗Γ.f op.f core .homT (1×i).Θ ⇒D : Γ.T	.T	.homf (1 × i).Θ → Cat,
such that er(d) ◦ Γ.1•.Θ= d.
Construction 3.18 [for Problem 3.17] Note that (T op)core = T core, and Γ.(T op)core.T op.homf op (i × 1).Θ =∼ Γ.T op.T core.homf (1 × i).Θ.
Then by substituting T op in for T everywhere in the statement of the Problem 3.14, we find that our problem has already been solved.	2
The homotopy theory
In this section, we describe the (directed) homotopy theory that this interpretation inhabits in Cat.
To understand this homotopy theory in Cat, first recall that there are two weak factorization systems on Cat [9]. We begin with the following two factorizations of the fold map

∗ + ∗  0+1  2 ¸!	 ∗ ¸
∗ + ∗  0+1  I  ¸!	 ∗ ¸
(→)
(∼=)

where 2 is the category generated by one morphism 0 → 1, I is the category
generated by one isomorphism 0 ∼= 1.  This gives us, by exponentiation, two
functorial factorizations of the diagonal C → C × C of any category C.
C	C!	 C2¸ C0×C1  C ¸× C	(C→)
C	C!	 CI¸ C0×C1  C ¸× C	(C∼=)
Then, we can functorially factor any functor F : C → D in two ways.


C	1×D!F  C ¸× 
D2	D1	 D¸
(l→, r→)



C	1×D!F  C ¸× 
DI	D1	 D¸
(l∼=
, r∼=)

This gives the factorizations of two functorial weak factorization systems (L→, R→)
and (L∼=, R∼=) on Cat.
We can characterize the right maps of these weak factorization systems in another way. The maps in R→ are exactly those maps which have the enriched right lifting property against the inclusion of the domain into the generic morphism: 0 : ∗→ 2.
∼=
The maps in R  are exactly those maps which have the enriched right lifting property
against the inclusion of the domain into the generic isomorphism: 0 : ∗→ I.
While the usual identity type of Martin-Lo¨f type theory has an interpretation into
the weak factorization system (L∼=, R∼=) [9], we claim that we have constructed in the
preceding sections an interpretation into the weak factorization system (L→, R→). By this, we just mean that (1) given any interpretation of a dependent type T :Γ → Cat, its comprehension πΓ : Γ.T → Γ is in R→, and (2) the elimination property can be seen as the existence of a lift between a map of L→ and a map of R→.
To show that any comprehension πΓ : Γ.T → Γ is in R→, note first that it is a Grothendieck opfibration.
Proposition 3.19 Any Grothendieck opﬁbration p : E → B is in R→.
Proof. We need to show that there is a lift l in the following square.


E
1×B!p	l
  
 E,
p
  

E × 0 B2 	 B¸
B1

An object of E ×B0 B2 is a pair (e, ƒ ) where e is an object of E and ƒ : pe → b is a morphism in B. By the definition of Grothendieck opfibration, there is a lift of ƒ , which we will denote (˜e, ƒ ) : e → l(e, ƒ ) such that p(˜e, ƒ ) = p. We will choose

(˜e, 1pe
) to always be 1e.

A morphism (e0, ƒ0) → (e1, ƒ1) of E ×B0 B2 is a pair (ϵ, φ) where ϵ : e0 → e1 is morphism of E and φ : b0 → b1 is a morphism of B which makes the following square commute in B.

pe0
f0
pє pe¸1
f1

   φ
b0 	 b1¸
Now, in E we have the following diagram of solid arrows.
e0 	є	 e1¸
(e˜,f )	(e˜,f )
0 0	1 1
 	 ¸ 
l(e0, ƒ0)	l(e1, ƒ1)
By the definition of Grothendieck opfibration, we obtain a unique morphism l(e0, ƒ0) → l(e1, ƒ1), which we will denote l(ϵ, φ), which makes the above diagram into a commutative square.

It is straightforward to check that l is a functor which makes the first diagram of this proof commute.	2
Now the right elimination property (in the empty context) says that for any category C, any functor D : Ccore.C.homC → Cat, and any functor d : Ccore → Ccore.C.homC.D making the following square commute, there is a lift l making both triangles commute.
Ccore 	d	 Cc¸ore .C.homC.D

Ccore
1•
  
.C.homC
l

	 Ccore
π
  
.C.homC

We want to see that this arises as the solution of a lifting problem between a left map and a right map of our weak factorization system. We just saw that π is a right map, so now we prove that 1• is a left map.
Proposition 3.20 For any category C, the functor
1• : Ccore → Ccore.C.homC

is in L→.
Proof. Factor the functor i : Ccore → C.
Ccore 1×C!i Cc¸ore ×	C2 C1 C ¸

We claim that the middle object, Ccore ×C0 C2, is isomorphic to Ccore.C.homC and this makes 1• isomorphic to 1 × C!i, the left factor of the factorization for the weak factorization system (L→, R→). Thus, 1• will be in L→.
The objects of Ccore.C.homC are pairs ((x, y),ƒ ) where (x, y) is an object of
Ccore ×C and ƒ is morphism x → y.
The objects of Ccore ×C0 C2 are pairs (x, ƒ ) where x is an object of Ccore (that is,
x is an object of C) and ƒ is morphism with domain x.
On objects, define the functor α : Ccore.C.homC → Ccore ×C0 C2 by α((x, y),ƒ ) := (x, ƒ ) and its inverse by α—1(x, ƒ ) := ((x, codƒ ),ƒ ).
The morphisms ((x, y),ƒ ) → ((x, yj),ƒj) of Ccore.C.homC are morphisms (1x, g): (x, y) → (x, yj) of Ccore ×C such that gƒ = ƒj.
The morphisms (x, ƒ ) → (x, ƒj) of Ccore ×C0 C2 are morphisms (1x, g): ƒ → ƒj of
C2 (so that gƒ = ƒj).
On morphisms, define the functor α and its inverse both by (1x, g) '→ (1x, g). This gives an isomorphism α : Ccore.C.homC ∼= Ccore ×C0 C2.
Now, we just check that α1• =1 × C!i. For any object x of Ccore, we have that
α1•(x) and 1 × C!i(x) are both (x, 1x) (and Ccore has no nonidentity morphisms).2
This concludes the interpretation of our syntax in Cat.

Acknowledgement
We thank Sanjeevi Krishnan for posing this problem and for many useful discussions. We also thank the anonymous referees for their insightful and useful comments.

References
	K. S. Brown. Abstract homotopy theory and generalized sheaf cohomology. Trans. Amer. Math. Soc., 186:419–458, 1973.
	N. Gambino and R. Garner. The identity type weak factorisation system. Theoret. Comput. Sci., 409(1):94–109, 2008.
M. Hofmann and T. Streicher. The groupoid interpretation of type theory. In In Venice Festschrift, pages 83–111. Oxford University Press, 1996.
	B. Jacobs. Comprehension categories and the semantics of type dependency. Theoret. Comput. Sci., 107(2):169–207, 1993.
P. T. Johnstone. Sketches of an Elephant: A Topos Theory Compendium, volume 1. The Clarendon Press, Oxford University Press, 2002.
C. Kapulkin and P. L. Lumsdaine. The Simplicial Model of Univalent Foundations (after Voevodsky), to appear in J. Eur. Math. Soc.
	D. R. Licata and R. Harper. 2-dimensional directed type theory. Electronic Notes in Theoretical Computer Science, 276:263 – 289, 2011.
	P. Martin-L¨of. Constructive mathematics and computer programming. In Logic, Methodology and Philosophy of Science VI, volume 104 of Studies in Logic and the Foundations of Mathematics, pages 153 – 175. Elsevier, 1982.
P. R. North. Type-theoretic weak factorization systems. PhD thesis, University of Cambridge, 2017.
A. Nuyts. Towards a directed homotopy type theory based on 4 kinds of variance. Master’s thesis, KU Leuven, 2015.
D. G. Quillen. Homotopical algebra. Springer-Verlag, Berlin, 1967.
	E. Riehl and M. Shulman. A type theory for synthetic ∞-categories. Higher Structures, 1(1):116–193, 2017.
M. Warren. Homotopy theoretic aspects of constructive type theory. PhD thesis, Carnegie Mellon University, 2008.
M. Warren. Directed type theory, 2013. https://video.ias.edu/univalent/1213/0410-MichaelWarren.
