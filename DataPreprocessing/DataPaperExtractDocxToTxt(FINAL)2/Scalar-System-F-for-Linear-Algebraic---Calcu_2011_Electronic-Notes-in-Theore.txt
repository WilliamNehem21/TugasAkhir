

Electronic Notes in Theoretical Computer Science 270 (2) (2011) 219–229
www.elsevier.com/locate/entcs
Scalar System F for Linear-Algebraic
λ-Calculus: Towards a Quantum Physical Logic
Pablo Arrighi1 Alejandro D´ıaz-Caro2
Universit´e de Grenoble, Laboratoire d’Informatique de Grenoble 220 rue de la Chimie, 38400 Saint Martin d’H`eres, France

Abstract
The Linear-Algebraic λ-Calculus [2] extends the λ-calculus with the possibility of making arbitrary linear combinations of terms α.t + β.u. Since one can express fixed points over sums in this calculus, one has a notion of infinities arising, and hence indefinite forms. As a consequence, in order to guarantee the confluence, t t does not always reduce to 0 – only if t is closed normal. In this paper we provide a System F like type system for the Linear-Algebraic λ-Calculus, which guarantees normalisation and hence no need for such restrictions, t t always reduces to 0. Moreover this type system keeps track of ‘the amount of a type’. As such it can be seen as probabilistic type system, guaranteeing that terms define correct probabilistic functions. It can also be seen as a step along the quest toward a quantum physical logic through the Curry-Howard isomorphism [12].
Keywords: Type Theory, Quantum Logic, Probabilistic Lambda Calculus, Curry-Howard


Introduction
In recent years a number of researchers have sought to develop quantum program- ming languages [6,10]. One of the purposes of such languages is to express quantum programs, but this is not a good enough reason as not many algorithms are known. A more important reason is to provide a framework for reasoning about the pro- grams expressing those algorithms – and about quantum information in general.
Indeed, in classical computer science it is possible to express the reasoning behind a program via several formally-defined logics. They provide an important framework in which to reason and prove properties about the computational processes. Usually

1 Email: Pablo.Arrighi@imag.fr
2 Email: Alejandro.Diaz-Caro@imag.fr
3 A complete version, with detailed proofs, can be found at arXiv:0903.3741, and a full journal version is ongoing

1571-0661 © 2011 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2011.01.033

these logics arise via the study of type systems for the language [12]. Related to our motivation there is already a quantum logic [4], which was developed before quantum computing. However it is not known to have a clear relation to quantum programs.
So there is a need for a logic that could aid us in isolating the reasoning behind some quantum algorithms; i.e. that would provide a tool to explore whether or not there is some typically ‘quantum piece of thinking’ behind some algorithms such as Grover’s [9] and Shor’s [11]. Rather than coming up with some ‘ad hoc’ logics that would only reflect our current lack of understanding of the deep nature of quantum information, we would like such a logic to arise naturally and legitimately from the study of type system or a quantum programming language. The reason why we use Linear-Algebraic λ-Calculus (Lineal ) [2] is because it has the advantage of not being bound to a particular type system (it is untyped), and it is minimal, yet it is general enough to describe any quantum computation.
The aim of this work is to set up a System F type system `a la Curry for the Linear-Algebraic λ-Calculus, able to handle scalars within the types, and hence in some way characterise the amount of a type, following the idea of superposition in the sense of how much a term belongs to a type. In this sense this scalar type system is a step in a research program which seeks for a form quantum physical logic obtained via the Curry-Howard isomorphism; it is also interesting in itself because of its relations with probabilistic systems, Linear Logic (LL), cloning, etc. (see section 5).
There are also two other products of this research. First, since Lineal can express fixed points over sums (e.g. nothing forbids that a term t should reduce to t + t), it has infinities, and hence indefinite forms (e.g. t − t). As a consequence, in order to guarantee confluence, t − t should not reduce to 0. This rule has to be restricted to closed normal terms [2]. As this paper provides a System F like type system for the Linear-Algebraic λ-Calculus and hence guarantees normalisation of all terms, this removes all need for such restrictions, making Lineal a more intuitive language: in the typed version t − t always reduces to 0. Moreover by keeping track of ‘the amount of a type’ our type system is ready-functioning as a probabilistic type system; guaranteeing that terms define correct probabilistic functions. Although this latter result was not our primary purpose, this does define a probabilistic typed λ-calculus [5].
We now present a small overview of the Linear-Algebraic λ-Calculus (Lineal ) [2]. Section 2 presents the scalar type system with its grammar, equivalences and inference rules. Section 3 shows the subject reduction property giving consistency to the system. Section 4 shows the strong normalisation property for this system, allowing us to lift the above discussed restrictions in the reduction rules. In section 5 we discuss the meaning of this type system; i.e. its relationship with probabilistic calculus and Linear Logic (LL). Section 6 presents our conclusions.

Linear-Algebraic λ-Calculus
Simply, the Linear-Algebraic λ-Calculus is λ-calculus together with the possibility to make arbitrary linear combinations of terms. Consider a first-order language, called the language of scalars, containing at least constants 0 and 1 and binary function symbols + and ×. Then the language of vectors is a two-sorted language, with a sort for vectors and a sort for scalars, described by the following term grammar:
t ::= x | λx t | (t t) | 0 | α.t | t + t
where α has the sort of scalars and the terms contain vector variables but no scalar variables (see [2, sec. III] for details).
There are rewrite rules for the scalar rewrite system which are compatible with the axioms of rings, and there are 16 AC-rewrite rules for vectors divided in 4 groups:
Elementary rules such as u + 0 → u and α.(u + v) → α.u + α.v.
Factorisation rules such as α.u + β.u → (α + β).u.
Application rules such as u (v + w) → (u v)+ (u w).
Beta reduction: (λx t) b → t[b/x], where b is a base vector (i.e. an abstraction or variable).
Factorisation and application rules have restrictions of the kind ‘v + w is closed normal’ to avoid problems occurring when handling non-terminating terms. These kind of problems are akin to indefinite forms ∞− ∞.
Example 1.1 It is possible to define fixed point operators such as
Y = λy ((λx (y + (x x))) (λx (y + (x x))))
Then, let b be a base vector, so (Y b) reduces to b + (Y b), so if there were no restriction on rules as the factorisation rules, then the term (Y b) − (Y b) would reduce to (1 + (−1)).(Y b) which reduces to 0. However, note that it would also reduce to b + (Y b) − (Y b) breaking the confluence.
By asking for u closed normal in the factorisation rules this problem is avoided (see [2, sec. II] for more details).

The Scalar Type System
The set of types is defined by the following abstract grammar:

T = U | ∀X.T | α.T | 0,	U = X | U → T | ∀X.U
where α ∈ S and (S, +, ×) is a commutative ring. Note that the grammar for U , called unit types, does not allow scalars except to the right of an arrow.
We also define an equivalence between types as follows:
Definition 2.1 Let α, β ∈S and T ∈T . We define a type equivalence ≡

α.0 ≡ 0	• 0.T ≡ 0	• 1.T ≡ T	• α.(β.T ) ≡ (α × β).T	• ∀X.α.T ≡ α.∀X.T
The typical System F rules are changed to handle scalars as showed below



Γ,x : U ▶ x : U

ax[U ]
Γ ▶ u : α.(U → T )	Γ ▶ v : β.U
→ E
Γ ▶ (u v): (α × β).T
 Γ,x : U ▶ t : T 
Γ ▶ λx t : U → T

→ I[U ]

 Γ ▶ u : ∀X.T 
Γ ▶ u : T [U/X]

∀E[X := U ]
 Γ ▶ u : T 
Γ ▶ u : ∀X.T

∀I[X] with X ∈/ FV (Γ)




Γ ▶ 0 : 0

ax0
Γ  u : α.T	Γ  v : β.T
+I
Γ ▶ u + v : (α + β).T
  Γ ▶ u : T 
Γ ▶ α.u : α.T

sI[α]

Where U ∈U and Name[Cond] represents a family of rules – one for each condition.
Subject reduction
The following theorem ensures that typing is preserved by reduction, making our type system consistent.
Theorem 3.1 (Subject Reduction) Let t →∗ tj. Then Γ ▶ t : T ⇒ Γ ▶ tj : T .
Proof. The proof proceeds by checking that every reduction rule preserves the type. Due to the large number of such reduction rules the proof is highly technical, with 27 auxiliary lemmas. Some of the interesting ones are stated below.	2
Lemma 3.2 (α-Unit) ∀T ∈T , ∃U ∈ U, ∃α ∈S such that T ≡ α.U.
Lemma 3.3 (Complement) Let denote by Sn to a sequent which admits a proof of depth n. Let Sn =Γ ▶ u+v : α.T. Then ∃δ, γ, r, s with δ+γ = α and max(r, s) < n such that Sr =Γ ▶ u : δ.T and Ss =Γ ▶ v : γ.T .
Lemma 3.4 (Base vectors are in unit) Let b be a base vector, i.e. a variable or an abstraction. Then Γ ▶ b : T ⇒ ∃U ∈U s.t. T ≡ U.
Strong normalisation
As our system is derived from System F, it can be proved that it has the strong normalisation property. In order to do so we set up another type system, a straight- forward extension of System F, called λ2la, and prove strong normalisation for it. Then we show that every term which has a type in scalar has a type in λ2la.
In this section we use Γ H t : T to say that it is possible to derive the type T ∈ T(λ2la) for the term t in the context of Γ by using the typing rules from λ2la. And we just use ▶ for scalar. In addition, we use R  to refer to a type rule in λ2 .
Definition 4.1 The type rules of λ2la are the same as System F plus the following rules:



Γ H 0 : A
ax¢
Γ H u : A	Γ H v : A

Γ H u + v : A
Γ H t : A
+I¢		
Γ H α.t : A

αI¢

In order to prove strong normalisation we extend the proof for λ2 which is given in [3, sec 4.3]. Most of the definitions are taken from this reference – with slight modifications to handle the extra λ2la rules.

Definition 4.2 SN = {t ∈ Λ | t is strongly normalising}.
Definition 4.3
A subset X ⊆ SN is called saturated if
∀n ≥ 0, (((x t1) ... ) tn) ∈ X where ti ∈ SN ;
v[b/x] t ∈ X ⇒ (λx v) b t ∈ X;
t, u ∈ X ⇒ t + u ∈ X;

∀α, t ∈ X ⇒ α.t ∈ X;
  Σ

∀i ∈ I, ((ui w1) ... wn) ∈ X ⇒
i∈I ui
w1 ... wn ∈ X;

∀i ∈ I, (u wi) ∈ X ⇒ u
Σi∈I wi
∈ X;

α.((t1 t2) ... tn) ∈X ⇔ ((t1 t2) ... α.tk) ... tn ∈X (1 ≤k ≤n);
0 ∈ X;
∀ t ∈ SN , (0 t ) ∈ X;
∀t, u ∈ SN , (t 0) u ∈ X.
SAT = {X ⊆ Λ | X is saturated}
Lemma 4.4 (i) SN ∈ SAT, (ii) A, B ∈ SAT ⇒ A → B ∈ SAT,  (iii) For all collection Ai of members of SAT,	i Ai ∈ SAT.
Definition 4.5 Let ξ(·): TV ar → SAT . We define the following mapping [[X]]ξ = ξ(X)	[A → B]]ξ = [[A]]ξ → [[B]]ξ	[[∀X.T ]]ξ = TY ∈SAT [[T ]]ξ(X:=Y )
Lemma 4.6 Given a valuation ξ and a type T , [[T ]]ξ ∈ SAT
Definition 4.7 For Γ = x1 : A1,..., xn : An, Γ ▶ t : T means that ∀ξ, [x1 ∈
[[A1]]ξ,... xn ∈ [[An]]ξ ⇒ t ∈ [[T ]]ξ].
Theorem 4.8 (Soundness) Γ H t : T ⇒ Γ ▶ t : T .
Proof. (Sketch) We prove this by induction on the derivation of Γ H t : T (In fact the definition of ▶ is slightly different to strengthen the induction hypothesis).	2
Theorem 4.9 (SN for λ2Lα) Γ H t : T ⇒ t is strongly normalising.
Proof. Let Γ H t : T . Then by theorem 4.8, Γ ▶ t : T and so by definition 4.7, if
∀(xi : Ai) ∈ Γ, xi ∈ [[Ai]]ξ then t ∈ [[T ]]ξ. Note that by lemma 4.6, [[Ai]]ξ is saturated, then xi ∈ [[Ai]]ξ, and so t is strong normalising since [T ]]ξ ⊆ SN also by lemma
4.6.	2

Definition 4.10 Let (·)q be a map from T \ {0} to T(λ2Lα) defined as follows. (α.X)q = X	(α.∀X.T )q = ∀X.Tq	(α.A → B)q = Aq → Bq
(A[B/X])q = Aq[Bq/X]	∀T1 ≡ T2, T q = T q

Notation Γq = {(x : T q) | (x : T ) ∈ Γ} and 0q = T for whatever type T ∈ T(λ2Lα).
Lemma 4.11 (Correspondence with λ2Lα) Γ ▶ t : T ⇒ Γq H t : T q.
Proof. Let n be the minimum number of steps to derive Γ ▶ t : T . We proceed by induction over n.

Base cases (n = 1)
ax[U ]
Γ,x : U ▶ x : U

(Γ,x : U )q = Γq,x : Uq, so by axa, (Γ,x : U )q H x : Uq.

q

ax0	By ax0a, Γq H 0 : T for any T ∈ T(λ2La), so take 0 = T .
Γ ▶ 0 : 0

Inductive cases In all cases, if A ≡ 0 we can take Aq = T for any T ∈ T(λ2La) and it is still valid by using the type equivalences.
By the induction hypothesis

Γ ▶ u : α.(U → B)	Γ ▶ v : β.U
Γq H u : Uq → Bq and Γq H v : Uq, so by

Γ ▶ u v : (α × β).B
→ E	a
→ E
, Γq H u v : Bq
= ((α × β).B)q.

 Γ,x : U ▶ t : A 
Γ ▶ λx t : U → A
 Γ ▶ t : ∀X.B 

→ I[U ]
By the induction hypothesis Γq,x : Uq H t : Aq, so by
→ I , Γ H λx t : U  → A = (U → A) .
By the induction hypothesis

​
∀E[X := U ]
Γq  H t : (∀X.B)q  = ∀X.Bq, so by ∀Ea, Γq  H

Γ ▶ t : B[U/X]	q	q


 Γ ▶ t : T 
Γ ▶ t : ∀X.T


∀I[X]
t : B [U /X].
By the induction hypothesis Γq H t : T q, so by ∀Ia, Γq H
t : ∀X.Tq = (∀X.T )q.

Γ ▶ u : α.A	Γ ▶ v : β.A Γ ▶ u + v : (α + β).A
By the induction hypothesis Γq H u : Aq and Γq H
v : Aq, so by +Ia, Γq H u + v : Aq = ((α + β).A)q.

  Γ ▶ t : A 
Γ ▶ α.t : α.A

sI[α]
By the induction hypothesis Γq H t : Aq, so by αIa, Γq H
α.x : Aq = (α.A)q.

2

Theorem 4.12 (Strong normalisation) Γ ▶ t : T ⇒ t is strongly normalising.

Proof. By Lemma 4.11 Γq H t : T q, then by theorem 4.9 t is strong normalising. 2

Theorem 4.12 ensures that all the typable terms have a normal form, hence we do not need the restriction of closed normal forms on the reduction rules of Lineal, as they were there only due to the impossibility of checking the normalisation property in the typeless setting. This is an important simplification of the language.
Taking up again example 1.1, terms like Y are simply not allowed in this typed setting, as all the terms are strong normalising. So we do not have infinities, and hence the restrictions to have closed normal forms on factorising reductions can be dropped – giving us a more powerful and intuitive tool to represent superpositions and work with them. This reinforces also the idea there is a formal correspondence between normalisation in rewriting and expressions of finite norm in algebra.

Example 4.13 Given some complicated term t. If t has a type, then it must be strong normalising, and so a term like α.t − α.t can be reduced by a factorisation rule into (α − α).t. This reduces in one step to 0, without the need to reduce t.

Discussion
Computational content
By restricting our scalars to positive reals, the scalar type system can be seen as a probabilistic type system. For example, one can type functions such as f ::= λx {x [ 1 .(true + false)] [ 1 .true + 3 .false]} : B → B with the type system serving as a
guarantee that the function conserves probabilities summing to one (see [2, sec. III] for details about the {} and [] notations, which are not relevant to this discussion).
The term can be seen as a function such that, if it receives true, it returns a balanced distribution of true and false, but if it receives false, it returns more false than true. We can ask what would the result be if it receives 1 .(true + false):
f 1 .(true + false)  −→∗ 3	5	2
pected, with probabilities summing to one.
To make this intuition more formal, let us define a type system with the rules and grammar of scalar, where the valid types are the classic ones (i.e. types exempt of any scalar) and all other types are intermediate types:
Definition 5.1 We define the probabilistic type system to be the scalar type system with the following restrictions:
+
• S = R ,
Contexts in the probabilistic type system are sets of tuples (x : C) such that C is in the set C Ç U of classic types, that is types exempt of any scalar,
Type variables run over classic types instead of unit types, i.e. the family of
∀E[X := C] rules accepts only C ∈ C,
The final sequent is well-formed in the following sense: ∀C ∈ C, any derivable sequent Γ ▶ t : C is well-formed, even if the derivation has scalars appearing at intermediate stages.
We define a weight function to check when a term is a probability distribution of terms:
Definition 5.2 Let ω :Λ → R+ be a function defined inductively by:
ω(0)=0	ω(t1 + t2)= ω(t1)+ ω(t2)	ω(b)=1 
ω(α.t)= α × ω(t)	ω(t1 t2)= ω(t1) × ω(t2)
where b is a base vector.
So, we can enunciate the following theorem that shows that every term with a well-formed typing in the probabilistic type system reduces to a term with weight 1:
Theorem 5.3 (Terms in probabilistic have weight 1) Let Γ ▶ t : C be well- formed, then ω(t ↓)= 1.
Proof. (Sketch) We prove that Γ ▶ t : α.C ⇒ ω(t ↓) = α by structural induction over t ↓.	2

By [2, Proposition 2], closed normal terms have form Σn
αi.λx ti+Σm
λx uj,

i=1
then the above theorem entails that Σn	αi + m = 1.
j=1

Hence the probabilistic type system, an easy variation of the scalar type system, specializes Lineal into a probabilistic higher-order λ-calculus.
Computational content: quantum computation
In [2, sec. IV] it is shown how to encode quantum bits and gates in an original manner. Such an encoding no longer works under the scalar type system. This is because conditional functions have to have the same type on each branch, which in this case entails that they must have the same scalar in their type.
Example 5.4 The Hadamard gate is encoded in the untyped calculus in the follow- ing way: H = λy {y [ √1 .(false + true)] [ √1 .(false − true)]}. In this system the types
2	2
 1	 1
for each branch of the gate are different: √2 .(false + true): √2 .((1 + 1).B) ≡	2.B
and √1 .(false − true): √1 .((1 − 1).B) ≡ 0. Hence it is not possible to give a type to
such an encoding of the Hadamard gate, as each branch has a different type.
This is a trivial consequence of the fact that we are characterising vectors by only magnitude and sign, not taking into account their directions. In a future version of the type system we plan to be able to distinguish qubit vectors from non-qubit vectors, allowing each branch to return qubit vectors in this example. This could be done by keeping track of the orthogonality of types. Orthogonality questions have already been raised in quantum programing languages such as QML [1].
Working out the logical content
We can use the Curry-Howard isomorphism in an original way: instead of making the relationship between an already set logic and our type system, we can remove all the terms from the inference rules of scalar and set up the Scalar Logic. This Scalar Logic (SL) is the first non-trivial logic obtained from a Curry-Howard isomorphism of a type system for a language inspired by quantum computing. In this sense it is not an ad hoc logic that we have fabricated in order to convey an a priori meaning, but rather a logic that arises naturally and legitimately by applying a well-established method upon a quantum programming language. This discussion section is an attempt to understand the a posteriori meaning of this logic. It is somewhat informal, experimental, yet provides several intuitions ending with a clear-cut result (theorem 5.7).
SL seems to count the quantity of proofs of a proposition that we have present in the proof of a sequent. For instance, the +I rule suggests that we need two proofs of A present in the proof tree in order to prove 2.A. However, we immediately see that there is a problem with the family of rules sI[·], because they trivially say that if we have one proof of a proposition then we have many proofs. If we were to remove this family of rules we would lose subject reduction (specifically in the rule α.u + β.u → (α + β).u), so we would need to add an alternative typing rule such as

Γ ▶ α.u : δ.T	Γ ▶ β.u : γ.T
Γ ▶ (α + β).u : (δ + γ).T
From this alternative rule we would still be able to derive sI[·] as a theorem, but in this process we would have to repeat the proof of A α times in order to get to α.A, and so this proof-counting interpretation would continue to hold (note that every α would now be a natural number) to some extent.
Nevertheless, consider the duplicator ▶ λx 2.x : ∀X.X → 2.X, which allows
·

==================
▶ λx 2.x : ∀X.X → 2.X
  · 
∀E[X := A]

▶ λx 2.x : A → 2.A	▶ t : A
→ E
▶ (λx 2.x) t : 2.A
without needing to prove A twice; i.e. there is a fixed proof method for proving
2.A from a single proof of A. Hence we can say only that if we do use the alternative rule instead of sI[·] then the proof-counting interpretation holds, but only after cut- elimination; i.e. the removal of all → E in the derivation tree. The idea of counting proofs, and hence considering them as resources, is very similar to linear logic (LL)
[7] or bounded linear logic (BLL) [8]. However LL and BLL do not only count the amount of resources available, they make it impossible to add new resources. In LL the context puts a definite limit on how many resources we can use. In SL, on the other hand, we are counting the amount of proofs we used modulo cut-elimination, but nothing prevented us from using many more proofs. To make this more formal let us introduce some notation:
Remark 5.5 We denote by Γ ▶ A ⇒ Δ ▶ B the fact that we have a witness derivation:


Γ ▶ A

·
·


Δ ▶ B
That is without any other leaf than Γ ▶ A (all other leaves of the tree are ax[·] or ax0 rules) we can have Δ ▶ B as the conclusion of the derivation tree. We call this the meta-implication, because in general we may have Γ ▶ A ⇒ Δ ▶ B but not A → B, due to the particular form the → I[·] rules may have. For instance in the SL we simply cannot have any type left of an arrow, only U types. The distinction between Γ ▶ A ⇒ Δ ▶ B and A → B refines our discussion.

In SL we do not have A → 2.A for all A, only for U , which could suggest interpreting U as the banged propositions of LL. However, this interpretation is too fragile; consider lemma 3.2: we know that any A ≡ α.U , and hence the above duplicator ∀XX → 2.X would still be able to produce 2.A, without even the need to depend upon A. Therefore, we clearly have Γ ▶ A ⇒ Γ ▶ 2.A, unlike in LL, whether A is U or not.
We will now see whether a stronger connection with LL can arise in a different manner. The ‘copy’ of LL could be interpreted in our calculus as λx x ⊗ x (where
⊗ is the classical encoding for tuples, see [2, sec IV]). Here again we do not have
A → A ⊗ A for all A, only for U (more formally consider an extra type equivalence

(α.U ) ⊗ (β.V ) ≡ α.β.(U ⊗ V )). Again, this suggests interpreting U as banged propositions of LL, but this again fails since we have that Γ ▶ A ⇒ Δ ▶ A ⊗ A, unlike LL, whether A is U or not. However the crucial difference this time is that there is no fixed proof method for doing the cloning. Indeed, if A ≡ α.U then a copy machine of the form ∀X.X → X⊗X will definitely not yield (α.U )⊗(α.U )= A⊗A, but α.(U ⊗ U ), which is not expressible in LL. The proof method which derives A⊗A from A crucially depends upon A for non-unit types. We capture this intuition as follows:
Lemma 5.6 (Scalar Logic rules are deterministic) Let R be a typing rule and let Qi, Qji with i = 1,...,n be sequents. Then

Q1,..., Qn
Q′ ,..., Q′


	 R
S′
R ∧ ∀i, Qi
≡ Qji}⇒ S ≡ Sj

Hence we can define Π as a tree of typing rules and think of Π as a function from lists of sequents to proofs. This is what we called informally a proof method in the previous discussion.
Theorem 5.7 (No-cloning) ∄Π such that ∀A, Π(Γ ▶ A) is a witness of Γ ▶ A ⇒
Δ ▶ A ⊗ A.
Note that our no-cloning allows the existence of a Π(Γ ▶ A) that is a witness of Γ ▶ A ⇒ Δ ▶ A ⊗ A, but does not allow the same proof method Π to work for any type. Hence the non-existence of a universal proof method Π for doing cloning in SL is very much akin to the non-existence of a universal context Γ for doing cloning in LL. Notice that by replacing quantification over Π by quantification over Γ, then theorem 5.7 is a well-known result of LL. However, the SL way of phrasing no-cloning might be more in line with quantum theory. Quantum theory states that it is not possible to have a universal cloning machine, but does allow cloning machines of speciﬁc vectors. The interpretation of Π as a machine is possibly more natural than thinking about resources in Γ as machines.
Summary of conclusions
The scalar type system can be seen as a probabilistic type system guaranteeing probabilistic functions to be well defined.
As a direct consequence of theorem 4.12, some restrictions were lifted in the reduction rules, allowing the factorisation not only of closed normal terms but also of strong normalising terms, which all the typable terms are.
Theorem 5.7 possibly indicates that this approach is more in line with quantum theoretical thinking than the LL approach, as in SL the restrictions is placed on cloning machines rather than and resources.
This scalar type system is the first step towards a future vectorial type system. The scalar type system is able to handle the magnitude and signs for type vectors. In a future system we will deal with the direction, i.e. addition and orthogonality of types.

Acknowledgement
We would like to thank to Gilles Dowek, Benoˆıt Valiron, Fr´ed´eric Prost, Jonathan Grattage, Simon Perdrix and Philippe Jorrand for enlightening discussions.

References
Altenkirch, T., J. J. Grattage, J. K. Vizzotto and A. Sabry, An algebra of pure quantum programming, Electronic Notes in Theoretical Computer Science 170 (2007), pp. 23–47.
Arrighi, P. and G. Dowek, Linear-algebraic λ-calculus: higher-order, encodings and confluence, Lecture Notes in Computer Science (RTA’08) 5117 (2008), pp. 17–31.
Barendregt, H. P., “Lambda calculi with types,” Handbook of Logic in Computer Science 2, Clarendon Press, Oxford, 1992.
Birkhoff, G. and J. von Neumann, The logic of quantum mechanics, Annals of Mathematics 37 (1936),
pp. 823–843.
Di Pierro, A., C. Hankin and H. Wiklicky, Probabilistic λ-calculus and quantitative program analysis, Journal of Logic and Computation 15 (2005), pp. 159–179.
Gay, S. J., Quantum programming languages: survey and bibliography, Mathematical Structures in Computer Science 16 (2006), pp. 581–600.
Girard, J.-Y., Linear logic, Theoretical Computer Science 50 (1987), pp. 1–102.
Girard, J.-Y., A. Scedrov and P. J. Scott, Bounded linear logic: a modular approach to polynomial-time computability, Theoretical Computer Science 97 (1992), pp. 1–66.
Grover, L. K., A fast quantum mechanical algorithm for database search, in: STOC ’96: Proceedings of the twenty-eighth annual ACM symposium on Theory of computing (1996), pp. 212–219.
Selinger, P., A brief survey of quantum programming languages, in: Functional and Logic Programming, Lecture Notes in Computer Science 2998 (2004), pp. 1–6.
Shor, P. W., Polynomial-time algorithms for prime factorization and discrete logarithms on a quantum computer, SIAM Journal on Computing 26 (1997), pp. 1484–1509.
Sørensen, M. H. and P. Urzyczyn, “Lectures on the Curry-Howard Isomorphism, Volume 149 (Studies in Logic and the Foundations of Mathematics),” Elsevier Science Inc., New York, NY, USA, 2006.
