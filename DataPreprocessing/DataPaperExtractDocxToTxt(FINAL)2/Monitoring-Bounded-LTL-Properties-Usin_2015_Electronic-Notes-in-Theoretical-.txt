Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 317 (2015) 85–100
www.elsevier.com/locate/entcs

Monitoring Bounded LTL Properties Using Interval Analysis
Daisuke Ishii1 Naoki Yonezaki2
Tokyo Institute of Technology, Tokyo, Japan
Alexandre Goldsztejn3
CNRS, IRCCyN, Nantes, France

Abstract
Verification of temporal logic properties plays a crucial role in proving the desired behaviors of hybrid sys- tems. In this paper, we propose an interval method for verifying the properties described by a bounded linear temporal logic. We relax the problem to allow outputting an inconclusive result when verification process cannot succeed with a prescribed precision, and present an efficient and rigorous monitoring algo- rithm that demonstrates that the problem is decidable. This algorithm performs a forward simulation of a hybrid automaton, detects a set of time intervals in which the atomic propositions hold, and validates the property by propagating the time intervals. A continuous state at a certain time computed in each step is enclosed by an interval vector that is proven to contain a unique solution. In the experiments, we show that the proposed method provides a useful tool for formal analysis of nonlinear and complex hybrid systems.
Keywords: Hybrid systems, interval analysis, linear temporal logic, bounded model checking.


Introduction
Reasoning of the temporal logic properties in a hybrid system is a challenging and important task that lies in the intersection among computer science, numerical anal- ysis, and control theory. Various methods for falsification of hybrid systems with temporal properties have been developed, e.g., [21,20,6,27], and these methods en- able verification of various properties (e.g., safety, stability, and robustness) of large and complex systems. The state-of-the-art tools are based on numerical simula- tions whose numerical errors often produce a qualitatively wrong result and become problematic even in a statistical evaluation.

1 Email: dsksh@acm.org
2 Email: yonezaki@cs.titech.ac.jp
3 Email: alexandre.goldsztejn@gmail.com

http://dx.doi.org/10.1016/j.entcs.2015.10.009
1571-0661/© 2015 The Authors. Published by Elsevier B.V.
This is an open access article under the CC BY license (http://creativecommons.org/licenses/by/4.0/).

A fundamental process in formal methods for hybrid systems is computation of rigorously approximated reachable sets. The techniques based on interval analysis (Section 3) have shown practicality in the reachability analysis of nonlinear and complex hybrid systems [8,5,24,15,3,11,12]. In these frameworks, computation is δ- complete [10]: function values are allowed to be perturbed within a predefined δ ∈ R>0, and, by setting bounds in a problem description, many generically undecidable problems become decidable. The δ-complete verification of generic properties other than reachability is a challenging topic.
In this paper, we present an interval method for verifying bounded linear tem- poral logic (BLTL) properties (Section 5) for a class of hybrid automata (Section 4). Our method computes three values in a reliable manner: the algorithm assures the soundness using interval analysis when the result valid or unsat is output; other- wise, unknown is output when the verification process reaches a prescribed precision threshold. We present an algorithm (Section 6) based on the forward simulation of a system. It encloses a trajectory with a set of boxes (i.e., interval vectors) and also ensures the unique existence property (i.e., we ensure that a unique state is enclosed in a box corresponding to each initial value) for each step of the simulation. For each atomic proposition involved in a property ϕ to verify, the algorithm obtains an inner and outer approximation of the time intervals in which the proposition holds. Next, the set of time intervals is modified according to the syntax of the property ϕ, and finally the algorithm checks whether ϕ holds at the initial time. Using our implementation, we show that nonlinear models are verified and the nu- merical robustness of a trajectory is assured (Section 7). Although our method is simple, it enables reliable analysis of a set of trajectories and provides a foundation for validated model checking and controller synthesis.

Related Work
Many previous studies have applied interval methods to reachability analysis of hybrid systems [8,5,24,15,3,11,12]. The outcome of these methods is an over- approximation of a set of reachable states with a set of boxes. In interval analysis, a computation often provides a proof of unique existence of a solution within a resulting interval. This technique also applies in interval-based reachability analy- sis [15,14], but it is not considered in most of the methods for hybrid systems. Our method enforces the use of the proof to verify more generic temporal properties.
Reasoning of real-time temporal logic has been a research topic of interest [2,25]. Numerical method for falsiﬁcation of a temporal property is straightforward [16]. It simulates a trajectory of a bounded length and checks the satisfiability of the negation of the property described by a bounded temporal logic. This paper presents an interval extension of this falsification method.
A tree-search method for searching witness trajectories [21], a falsification method based on a Monte-Carlo optimization technique [20], and statistical model checking methods [6,27] for hybrid systems have been proposed. These methods have been shown their practicality in the verification of realistic nonlinear models;

however, their implementations are based on numerical simulations and might suffer from numerical error. An application of our interval method includes an integra- tion with these statistical methods to achieve both reliability and practicality. An integrated statistical and interval method was also proposed in [26] for reachability analysis.
Notions of robustness have been proposed to facilitate the simulation-based ver- ification of temporal properties [9,7,20]. In these works, the degree of robustness is represented as a distance between a trajectory and a region where a proposition holds. A non-robust trajectory, which is computed numerically, is likely to be in- consistent with the considered model due to numerical errors. Our method ensures a robustness rigorously by verifying that a trajectory intersects with each boundary in the state space.
There exist a few methods for model checking of temporal logic properties [23,4].
[23] proposed a method specialized in stability properties, which is described as a specific form of temporal logic formula. [4] proposed a method that translates a verification problem into a reachability problem with the k-Liveness scheme, which is incomplete in general settings. Our method can be viewed as a bounded model checking method that validates a bounded temporal property by ensuring that all trajectories that emerge from an initial interval value satisfy the property.
Interval Analysis
This section introduces selected topics and techniques based on interval analy- sis [17,19]. The techniques are used in the proposed method in Section 6.
Basic Notions and Techniques
A (bounded) interval a = [a, a] is a connected set of real numbers {b ∈ R | a ≤ b ≤ a} and I denotes the set of intervals. For an interval a, a and a denote the lower and upper bounds; the width is defined as a−a; and int a denotes the interior
{b ∈ R | a < b < a}. [a] denotes a point interval [a, a]. For intervals a and b, d(a, b) denotes the hypermetric between the two, i.e., max(|a − b|, |a − b|). For a set S ⊂ R, 2S denotes the interval [inf S, sup S]. All of these definitions are naturally extended to interval vectors; an n-dimensional box (or interval vector) a is a tuple of n intervals (a1,..., an), and In denotes the set of n-dimensional boxes. For a ∈ Rn and a ∈ In, we use the notation a ∈ a, which is interpreted as
∀i∈{1,..., n} ai ∈ ai. In an actual implementation, the bounds of intervals should
be machine-representable floating-point numbers and other real values are rounded in the appropriate directions.
For a function f : Rn → R, f : In → I is known as an interval extension of f if and only if it satisfies the containment condition ∀a ∈ In ∀a ∈ a (f (a) ∈ f (a)). This definition is generalized to function vectors f : Rn → Rnf where nf ∈ N>1. Given intervals a, b ∈ I, interval extensions of four operators ◦ ∈ {+, −, ∗, /} can be computed as 2{a ◦ b, a ◦ b, a ◦ b, a ◦ b} (we assume 0 /∈ b for division).
For arbitrary intervals a, b, d ∈ I, the extended division 2{d ∈ d | ∃a ∈ a ∃b ∈

b a = bd} can be implemented as follows (see Section 4.3 of [19]):
⎧a/b ∩ d	if 0 /∈ b
ExtDiv(a, b, d) := ⎨2(d \ (a/b, a/b))	if a > 0 ∈ b
⎪⎪⎩d	if 0 ∈ a, b
In the second and third cases, when b = 0 (resp. b = 0), we set a/b and a/b as −∞
and ∞ (resp. a/b and a/b as ∞ and −∞).
Given a differentiable function f (a) : R → R and a domain interval a, a root
a˜ ∈ a of f such that f (a˜) = 0 is included in the result of an interval Newton operator
a ∩ aˆ − f (aˆ)/  d f (a) ,
where aˆ ∈ a, and f and  d f are interval extensions of f and the derivative of f . Iterative applications of the operator will converge. Let aj be the result of applying the operator to a. If aj ⊆ int a holds, a unique root exists in aj.
ODE Integration
An initial value problem (IVP) for an ordinary differential equation (ODE) is spec- ified by a triple (t0, x0,F ) consisting of an initial value x0 ∈ Rn at time t0 ∈ R and a flow function F : Rn → Rn (assume Lipschitz continuity). Given a time interval t ∈ I and a continuous trajectory x˜(t) : t → Rn, the satisfaction for IVP-ODEs is defined as

x˜, t |= (t0, x0,F ) iff
x˜(t0)= x0 ∧ ∀t˜∈ t  d x˜(t˜)= F (x˜(t˜)).

Given t0 ∈ I and x0 ∈ In, we can consider a parametric IVP-ODE (t0, x0,F ), where the initial condition is parameterized, and its satisfaction relation is defined as
x˜, t |= (t0, x0,F ) iff ∃t0 ∈ t0 ∃x0 ∈ x0 x˜, t |= (t0, x0,F ).
TS t(t0, x0,F ) denotes the set of satisfied trajectories on t.
Using the tools based on the interval Taylor methods, e.g., CAPD 4 and VN- ODE [18], we can obtain an interval extension X : I → In of solution trajectories in TS t(t0, x0,F ). Given tj ∈ I, such tools compute a value X(tj) by performing the stepwise integration of the flow function F from the initial time t0 to time tj. In the stepwise computation of the interval Taylor methods, the unique existence of a solution is verified for a box enclosure computed in each step based on the Picard- Lindel¨of operator and Banach’s fixpoint theorem. Accordingly, when an interval enclosure X(tj) (assume tj ≥ t0) is computed with an interval Taylor method, the following property holds:
∀t0 ∈ t0 ∀x0 ∈ x0 ∃unique x˜∈ (tj → X(tj)) x˜, tj |= (t0, x0,F ).

4 http://capd.ii.uj.edu.pl/

In principle, if F is Lipschitz continuous and we can assume an arbitrary pre- cision, we obtain an arbitrary narrow interval enclosure X([t]) for t ∈ R. However, since the implementations use machine-representable real numbers, it may fail to compute an enclosure in the process that verifies the unique existence property, even with the smallest step size.

Hybrid Automata
We model a hybrid system as a hybrid automaton [1]. For simplicity in this paper, we consider deterministic systems, i.e., the location invariant is the negation of guard conditions and two guards do not overlap in a location. The proposed method can be extended to handle non-deterministic systems, e.g., by enumerating possible paths and computing a trajectory enclosure for each path.
Definition 4.1 A hybrid automaton is a septet
HA :=  Q, x, X, Init, {Fq}q∈Q, {Gq,q′ }q∈Q,q′∈Q, {Rq,q′ }q∈Q,q′∈Q  ,
that consists of the following components:
A finite set of locations Q = {q1,..., qnq }.
A vector of real-valued variables x = (x1,..., xn).
A domain X ⊆ In for the valuation of the variables.
A set of initial values Init ⊆ {q}×X where q ∈ Q.
A set of vector ﬁelds Fq : X → X (assume Lipschitz continuity).
A set of guards Gq,q′ ⊆ X described by a condition of the form g(x)=0 ∧ h(x) < 0 where g, h : X → R.
A set of reset functions Rq,q′ : X → X.
Behaviors of the states σ ∈ Q×X over the timeline are formalized as trajectories.
In this work, we assume that there are no consecutive multiple discrete changes.
Definition 4.2 Given an HA, an initial state (q0, s0) ∈ Init , and a time interval t = [0, tmax] (tmax ∈ R≥0), a state at each time t ∈ t is determined as a trajectory (q, s), which consists of a location trajectory q : t → Q and a continuous state trajectory s : t → X. The value of the trajectory is defined recursively as follows:


(q(0), s(0)) := (q0, s0),
(q(t), s(t)) := σ ∈ Q×X  s.t. ∃tj ∈ (0, t) ∃σj ∈Q×X (q(tj), s(tj)) t—t′

σj −→0 σ,



where the relation σ1 −→t
σ2 ∈ (Q×X)×t×(Q×X) is given by the following rules:




Gq,q′ (s)	Rq,q′ (s)= sj


f (0) = s	∀t˜∈ [0, t]  d f (t˜)= Fq(f (t˜))
∀t˜∈ [0, t) ∀qj ∈Q ¬Gq,q′ (f (t˜))



(q, s) −→0
(qj, sj)
(q, s) −→t
(q, f (t))








3





x
1
true U[0,5] x1>2 
¬(true U[0,5] x >2) 
true U[0,10] ¬(true U[0,5] x1>2) 
¬(true U[0,10] ¬(true U[0,5] x >2)) 

Figure 1. Verification of the bouncing ball example
Note that the second rule also applies for t = 0. The set of trajectories of length
tmax is denoted by TStmax (HA).

When a discrete change −→0
is applied at time t, the state (q(t), s(t)) overwrites

the state σj before the discrete change. An HA has a unique trajectory (q, s) starting from an initial state (q0, s0) ∈ Init because we have assumed that two guards do not hold simultaneously.
Example 4.3 We model a bouncing ball on a moving table as an HA:
x := (x1, x2, x3) ∈ X := ([−1, 10], [−10, 10], [0, 1000])
L := {q}
Init := {q}×([2, 7], [0], [0])
Fq := (x2, −1+ 0.04x2 sgn x2, 1)
Gq,q := x1 − sin x3 =0 ∧ x2 − cos x3 < 0
Rq,q := (x1, −0.9x2 + 1.9 cos x3, x3)
Variables x1, x2, and x3 represent the height and velocity of the ball, and the (global) time, respectively. Air resistance is considered in the dynamics. The height of the table sinusoidally oscillates within [−1, 1] and is represented as sin x3. The second proposition of the guard is to forbid the guard to hold right after a discrete change. Possible trajectories of x1 and x2 are illustrated in Figure 1.

Bounded Linear Temporal Logic
We consider a fragment [16] of the real-time metric temporal logic [2] such that the temporal modalities are bounded by an interval t = [t, t] such that the bounds t, t are in Q. We refer to the logic bounded linear temporal logic (BLTL) as in [27].

Definition 5.1 We consider constraints in the real domain as atomic propositions.
The syntax of the BLTL formulae is defined by the grammar
ϕ ::= true | p | ϕ ∨ ϕ | ¬ϕ | ϕ Ut ϕ	p ::= f (x) < 0 | f (x) ≤ 0
where p belongs to a set of atomic propositions APϕ, Ut is the “until” operator bounded with a non-empty positive time interval t ∈ I, x = (x1,..., xn) is a vector of variables, and f : Rn → R. We use the standard abbreviations, e.g., ϕ1 ∧ ϕ2 :=
¬(¬ϕ1 ∨ ¬ϕ2), Ftϕ := true Ut ϕ (“eventually”), and Gtϕ := ¬Ft¬ϕ (“always”). An
equation f (x) = 0 can be encoded as f (x) ≤ 0 ∧ −f (x) ≤ 0.
Semantics
The necessary length ||ϕ|| of trajectories for checking a formula ϕ is inductively defined by the structure of the formula:
||p|| := 0	||ϕ1 ∨ ϕ2|| := max (||ϕ1||, ||ϕ2||)
||¬ϕ|| := ||ϕ||	||ϕ1 Ut ϕ2|| := max (||ϕ1||, ||ϕ2||)+ t
A map O : APϕ → 2X corresponds each proposition p ∈ APϕ to a set O(p)= {s∈ X | p(s)}. Let (q, s) be a trajectory in TS ||ϕ||(HA) and ϕ bea BLTL property. We have a satisfaction relation defined as follows:
s,t |= true
s,t |= p	iff s(t) ∈ O(p)
s,t |= ϕ1 ∨ ϕ2	iff s,t |= ϕ1 ∨ s,t |= ϕ2
s,t |= ¬ϕ	iff s,t |= ϕ
s,t |= ϕ1 Ut ϕ2	iff ∃tj ∈ (t + t) s, tj |= ϕ2 ∧ (∀tjj ∈ [t, tj] s, tjj |= ϕ1)
ϕ1 Ut ϕ2 intuitively means that (assuming we are at time t) ϕ2 will hold within the time interval t+t and ϕ1 always hold until then. We also have a validation relation defined as:
HA |= ϕ iff ∀(q, s) ∈TS ||ϕ||(HA) s, 0 |= ϕ
Method for Monitoring BLTL Formulae
Our interval method is based on the method proposed in [16] that decides whether a trajectory satisfies a BLTL property. In this section, we explain this basic method. First, we introduce the notion of consistent time intervals against BLTL formulae.
Definition 5.2 Let (q, s) be a trajectory of length tmax and ϕ bea BLTL formula. We say that a left-closed and right-open interval [t, t) ⊂ [0, tmax] is consistent with ϕ iff ∀t∈ [t, t) s,t |= ϕ.
The satisfiability of a property ϕ by a trajectory is checked as follows:
For each atomic proposition p in ϕ, monitor the trajectory of length ||ϕ|| and identify a non-overlapping set of consistent time intervals Tp = {t1,..., tnp }.

Following the parse tree of ϕ in a bottom-up fashion, compute a set of consistent time intervals of ϕ. For each construct of BLTL, compute as follows:
Tчp := [0, ||ϕ||) \ Tp	Tp1Vp2 := Tp1 ∪ Tp2 Tp1Utp2 := {Shiftt(t1 ∩ t2) ∩ t1 | t1 ∈ Tp1 , t2 ∈ Tp2 }
where Shiftt(s) := [s − t, s − t) ∩ [0, ||ϕ||).
Check whether t1 ∈ Tϕ contains time 0. If yes, ϕ is satisfied; otherwise, it is not satisfied.
Example 5.3 We verify the property
G[0,10]F[0,5] 2 − x1 < 0 ≡ ¬(true U[0,10] ¬(true U[0,5] 2 − x1 < 0))
for the model in Example 4.3. Computation with the monitoring method (which is extended to an interval method) is illustrated in Figure 1.
Interval-Based Simulation and Monitoring Method
In this section, we propose an interval extension of the monitoring method in Sec- tion 5.2.
In Step (i) of the method, given an HA and a BLTL property ϕ, we first simulate the HA for length ||ϕ||. Our simulation method computes an over-approximation of a trajectory of HA in which the existence of a unique trajectory is verified, i.e., it verifies the property
∀(q0, x0) ∈Init ∃unique (q, s) ∈ TS ||ϕ||(HA) q(0) = q0 ∧ s(0) = x0
meaning that for each initial value, there exists a unique trajectory of length ||ϕ||.
Next, our method identifies the time intervals that are consistent with an atomic proposition in ϕ (Definition 5.2). A consistent time interval [t, t) is, in general, not representable in an actual implementation; therefore, we approximate it by a pair of intervals u and uj such that each of them encloses the boundaries t or t. Given an atomic proposition f (x) ◦ 0 (◦ ∈ {<, ≤}) and a trajectory s, we search for a boundary enclosure u such that f (s(u)) e 0 where f is an interval extension of f . In Step (ii), the set of consistent time intervals is updated to be consistent with ϕ. This computation requires u to contain a unique boundary point, and
thus a naive over-approximation u˜ does not suffice because an interval extension
f (u˜) may contain 0 although f (u˜) does not contain a boundary or contains several boundaries. Thanks to interval techniques, our method verifies the unique existence of a boundary in u. Finally, as an extension of the above property, our method verifies
∀(q0, x0) ∈Init ∃unique (q, s) ∈ TS ||ϕ||(HA) q(0) = q0 ∧ s(0) = x0 ∧ s, 0 |= ϕ.
The proposed method has some limitations. First, it is a semi-decision pro- cedure that may output an inconclusive result (unknown) because of a failure in

Input: HA, ϕ
Output: valid, unsat, or unknown
1: t := 0;	q := q0;	x := x0;	T := {∅,..., ∅}
2: while t < ||ϕ|| do try
3:	tc := ||ϕ||
4:	for qj ∈ Q do	{Find zeros for each edge}
5:	tj := SearchZero(X, Fq, Gq,q′ , [t, ||ϕ||])
c j	j
6:	if tc /= ∅ ∧ tc < tc then
7:	qjj := qj; tc := tj
j	c

8:	else if tc ≥ tc then
9:	return unknown
10:	end if
11:	end for
12:	for p = f ◦ 0 ∈ APϕ do	{Find boundaries of APs}
13:	tj := [t, tc]
14:	loop
15:	tj := SearchZero(X, Fq,f = 0, tj )
c	c
16:	if tj = ∅ then break end if
j  c	j	j
17:	tc := [tc, tc];	T p := T p ∪ {tc}
18:	end loop
19:	end for
20:	x := Jump(X, tc, Rq,q′′ , APϕ, T )	{Discrete change}
21:	q := qjj;	t := tc
22: catch error then return unknown end try
23: end while
24: return AnalIntervals(T )
Figure 2. Monitor algorithm

the verification of unique existence; both the procedures for enclosing a continuous trajectory and enclosing a time where a discrete change occurs may cause errors. However, this mechanism is valuable in terms of reliability and complexity of the problem; a non-robust trajectory and a zeno HA will be rejected as an error in the verification process. In practice, when addressing a nonlinear HAs, the method may only work successfully with a sufficiently small subset Initj ⊂ Init of initial values. In this way, the method can be still used for sat/invalid checking. Second, the method is a bounded model-checking method in the sense that the domain X of the variables is bounded, and it assumes a bounded length and a number of discrete changes in a trajectory.

Main Algorithm
Given an HA and a BLTL property ϕ, the proposed Monitor algorithm (Figure 2) outputs the following results: valid that implies HA |= ϕ; unsat that implies HA |=

¬ϕ; or unknown when the computation is inconclusive.
An iteration of the outmost loop corresponds to a continuous phase of the tra- jectory and a discrete change. At Lines 4–11, each guard for a possible transition is evaluated. The SearchZero algorithm is described in Section 6.4 and will return

a time interval tj
within which the guard is satisfied or ∅ if no state satisfies the

guard. Next, the algorithm attempts to decide the earliest time interval by check-
ing whether tj is strongly less than tc. If two guard crossings are too close, so two
crossing time intervals overlap, the algorithm returns unknown. At Lines 12–19, for each atomic proposition of ϕ of the form f ◦ 0 (◦∈ {<, ≤}), the algorithm searches for a boundary where the sign of f changes. Because several boundaries can exist in a continuous phase, the inner loop searches for all of them. The detected time inter- vals are saved in the set T associated with the atomic propositions. At Lines 20–21, the discrete change between the locations q and qjj is computed by evaluating an interval extension of Rq,q′′ (X(tc)). A jump of state might switch the state of an atomic proposition; if such a switch exists, the Jump procedure should detect and record it in T . Finally, boundary points (which are enclosed by intervals) of the consistent time intervals saved in T are analyzed by the AnalIntervals procedure (Line 24, Section 6.2). The procedures X (Section 3.2) and SearchZero (Section 6.4) may results in errors. These errors are caught by the catch clause at Line 22.

Evaluation of BLTL Properties
The BLTL evaluation explained in Section 5.2 can be implemented as a rigorously approximated procedure AnalIntervals.
First, we approximate a set of consistent time intervals Tϕ = {t1,..., tnϕ } by
T ϕ = {u1, uj ,..., un , uj } such that ui, uj ∈ I, t ∈ ui, ti ∈ uj, ui ≤ uj, and
1	ϕ	nϕ	i	i	i	i
j ≤ ui+1, for i ∈ {1,..., nϕ}. T = ∅ and T = {[0, tmax)} are approximated as
T = ∅ and T = {[0], [tmax]}. For ui, uj in T ϕ and a continuous trajectory s,
∀t∈ [ui, uj) s,t |= ϕ holds.
Next, the evaluation on the set of time intervals in Step (ii) is extended to address the approximated sets: the set of the inverted time intervals for ¬ϕ can

be represented as T чϕ = {[0], u1,..., uj
, [tmax]}; the union of two sets of time

intervals for ϕ1 ∨ ϕ2 can be implemented as a merge and sort process of the two approximated sets; and the Shiftt procedure for ϕ1Utϕ2 can be implemented as
translations of the time intervals ui and uj for t and t, respectively. Some more
case analyses should be applied, e.g., when the intervals in T ϕ become redundant or when they overlap.
Finally, we obtain T ϕ and conclude that ϕ is valid if u1 ≤ 0 ≤ uj ; it is unsat if
T ϕ = ∅ or 0 < u1; or the satisfaction is unknown if 0 ∈ [u1, u1).
Computation of a Continuous Trajectory
If the system is in a location q ∈ Q and the value of the state variables is x ∈ In at time t ∈ I, then the subsequent continuous evolution is specified by an IVP-ODE (t, x, Fq). Next, we can obtain an interval extension X : I → In of the continuous

Input: X : I → In,	F : X → X,	g =0 ∧ h< 0,	tinit ∈ I
Output: t ∈ I ∪ {∅} Parameter: ϵ ∈ Q>0, θ ∈ (0, 1) 1: t := tinit
2: repeat	{Lower bound reduction}
3:	told := t
4:	dg := Dt(g, X, F, t); dh := Dt(h, X, F, t)
5:	t := t + ExtDiv(−g(X(t)), dg, t − t)
		
6:	t := t + ExtDiv(−h(X(t)) − [0, ∞], dh, t − t)
7: until d(told, t) ≤ ϵ
8: if t = ∅ then return ∅ end if
9: t := t
10: loop	{Unique solution existence verification}
11:	dg := Dt(g, X, F, t)
12:	if dg e 0 then error end if
13:	tj := t − g(X(t))/dg
14:	if tj ⊆ int t then t := tj; break end if
15:	tbak := t
16:	t := tinit ∩ Inflate(tj, 1+θ)
17:	if d(t, tj) > (1−θ) d(tj, tbak) then error end if
18: end loop
19: if sup h(X(t)) ≥ 0 then error end if
20: return t
Figure 3. SearchZero algorithm
trajectories in TS [t,||ϕ||](t, x, Fq) as described in Section 3.2.

Evaluation of Boundary Conditions
Guards and atomic propositions can be treated as boundary conditions in the state space X ⊆ Rn of the form
B(x) := g(x)=0 ∧ h(x) < 0,
where g : X → R and h : X → R. We propose the SearchZero algorithm shown in Figure 3 for searching the intersection between a trajectory and a boundary condition. Inputs to the algorithm consist of an interval extension of the continuous trajectory X : I → In, a vector field of the current location F : X → X, the boundary condition B(x), and a time interval tinit ∈ I to be searched. SearchZero searches for the earliest time interval t ⊆ tinit such that the state X(t) encloses a unique solution of the boundary condition, i.e.,
t = 2 min{t∈ tinit | B(s(t))} | s ∈TS tinit (t0, x0, Fq)},		(1) where (t0, x0, Fq) denotes the IVP-ODE of the current location.	Moreover,

SearchZero verifies the following property:
∀s ∈TS tinit (t0, x0, Fq) ∃unique t∈ t B(s(t))	(2) Otherwise, SearchZero returns ∅ when the boundary condition is unsatisfiable, i.e.,
∀s ∈TS tinit (t0, x0, Fq) ∀t∈ tinit ¬B(s(t)).	(3)
Lemma 6.1 If SearchZero returns a non-empty interval t, the properties (1) and
(2) hold. If it returns ∅, the property (3) holds.
To justify the soundness, we describe some details of the algorithm. At Lines 2– 7, the time interval t is filtered repeatedly using an interval Newton operator. At Line 4 (and at Line 11), given a function g, the Dt procedure computes an interval enclosure of the derivative  d g(s(t)) over the time interval t using the chain rule
 d g(s(t)) =  d g(s(t)) ·  d s(t) ⊆  d g(X(t)) · F (X(t)).
dt	dx	dt	dx

Next, at Lines 5 and 6, the interval Newton is applied. The extended division (Section 3) is used to implement the interval Newton to handle the numerator intervals dg, dh containing zero. Because we expand the interval Newton on the lower bound t and the extended division encloses the values in the domain t −t, the resulting t is filtered its inconsistent portion, without losing the solutions or being expanded. When the interval Newton results in ∅, SearchZero also returns ∅ to signal the unsatisfiability. At Line 9, because t may contain several solutions, t is reset to the lower bound as a starting value to compute an enclosure of the earliest solution. At Lines 10–18, SearchZero applies the interval Newton method with the inclusion test to prove the unique existence of a solution within the contracted interval tj. This interval Newton verification is repeated with an inflation process of the time interval (see [13] for a detailed implementation). When reaching Line 19 with no error, the time interval t is a sharp enclosure of the first zero of g(s(t)) = 0. It remains to check that the inequality constraint h(s(t)) < 0 is satisfied inside t.
When SearchZero is implemented with machine representable real numbers, or when there is a tangency between the trajectory and the guard constraint, a com- putation may result in an error. Line 12 of SearchZero may give rise to error if the derivative on an (inflated) time interval contains zero. At Line 17, we limit the number of iterations according to whether the inflation ratio reaches the threshold as proposed in [13].

Experiments
We have implemented the proposed method and experimented on two examples to confirm the effectiveness of the method. Experiments were run using a 2.4GHz Intel Core i5 processor with 16GB of RAM.

Implementation
We have implemented the proposed algorithms in Figures 2 and 3 in OCaml and C/C++. The CAPD library was used for solving ODEs. Parameters tmin, ϵ, and θ should be configured. Each parameter corresponds to the smallest integration step size that CAPD can take, the threshold used in Figure 3, or a threshold used in Inflate. In the experiments, these parameters were set as tmin := 10—14, ϵ := 10—14, and θ := 0.01.
For most of models, our implementation only accepts small interval values, as reported in the next section, because an interval enclosure of the state after a continuous evolution and a jump expands by quite a large amount, and thus, the verification process in SearchZero or the solving process of CAPD will fail.
Bouncing ball
Example 5.3 can be verified using the implementation by limiting the initial value of x2 to a small interval of width at most 0.01. We verified the model with three configurations: 1) with setting a point initial value to x2; 2) with an interval initial value of width 0.01; and 3) with a point initial value and the property in which the time bound for the G operator was set to [0, 100]. Each experiment was run 1000 times with the initial values of x2 randomly picked within [2, 7]. The results are shown in Table 1. In the table, the second column represents the width of the
Table 1
Experimental results (bouncing ball)

initial values. For each r ∈ {valid, unsat, unknown}, the column “# r” represents the number of runs that resulted in r. The column “# errors” represents that how many of unknown results are caused by an error in the SearchZero procedure. The column “time” shows average timings.
The computation of each experiment was quite efficient.
Regarding the rate of inconclusive runs in each experiment, all the verifications succeeded in the first experiment. Because we set the point initial values and the bounded simulation time, considered trajectories were always enclosed with tight intervals, and thus the verification process succeeded even in a situation that was close to singular. The result also implied that we did not meet a zeno behavior. Contrastingly, around 90% and 80% of the runs in the second and third experiments, respectively, resulted in errors. Our verification process with the interval Newton failed more often if a trajectory and a guard approached or they became close to tangent. Because the model was chaotic, a coarser enclosure of states or a longer simulation time increased the possibility to meet such situations.


1.1

0.5

0.0

–0.5



0.5  1.0  1.5  2.0
time

0.5	1.0

0.5	0.5	1.0	1.5	2.0

Considered model
Our
method
dReal

Figure 4. Results of boundary detection of the bouncing ball example





m−1

G[0,30]
(—(xi — xj )2 — (yi — yj )2 + 64 < 0)
m2

i=1 j=i+1
m
^	i	2	i	2

∧
i=1
F[0,10] G[0,10]((x — cx)
+ (y
cy )
25 < 0)

∧ F[10,20](—(xi — cx)2 — (yi — cy)2 + 100 < 0) 




Figure 5. A trajectory of ATM (left) and the BLTL property to verify (right)



In the second and third experiments, most of the successful runs resulted in valid. These runs became stable (i.e., there are less difference between the continuous trajectories in each step) in the later steps, and thus satisfied the property ϕ. We confirmed that most of the inconclusive runs fell into zeno behaviors.
It was quite rare that the result of AnalIntervals became unknown because there were always a few (or no) tight boundaries in T ϕ and they rarely contained zero.
Next, we experimented with dReal (version 2.14.08), a solver for δ-weakened SMT problems, for comparison. We consider a portion of the model of (another instance of) the bouncing ball such that the initial state is (1.1, 0, 0) and the tra- jectories of the ball and the table become close to tangent (Figure 4 (a)). Next, we analyzed this model by simulating the underlying HA with our method and by solving the SMT problem with dReal, respectively. Figure 4 (b) and (c) show the computed witness trajectories. Our implementation verified the occurrence of the first contact with the floor. dReal computed two enclosures for the possible trajec- tories of the model; they seemed corresponding to the first and last intersections with the guard. The second witness seemed wrong because the guard condition became δ-sat around tj = 0.5 with δ = 0.001. The computation of a boundary can be troublesome in this way, without the unique existence verification process.

Air Traffic Maneuver
We performed a verification of a simplified model of an air traffic maneuver (ATM) [22] in which the number of aircrafts was parameterized. A trajectory of (xi, yi) when m = 4 is illustrated in Figure 5. We verified the following property shown in Figure 5. The first line describes that the distance between each pair of aircrafts is larger than the threshold 8/m during ||ϕ|| = 30 time units. The follow- ing of the property describes that all aircrafts reach within the circle with radius 5 within the time interval [0, 10], stay there at least 10 time units, and reach outside the circle with radius 10 after another 10 time units. We verified 10 times for each instance with m = 2, 4, 6, 8. In each verification, we randomly picked a point initial value. All runs resulted in valid. The specification of the instances and the results are shown in Table 2. The columns “# vars” and “# APs” represent the numbers
Table 2 Experimental results (ATM)

of variables in HA and APs in the property. The average timings rose exponentially as m increased.
Conclusions
We have presented a sound BLTL validation method that assures that all initialized trajectories satisfy the property. The proposed method is able to detect a witness trajectory that is verified its unique existence with an interval-based ODE inte- gration and an interval Newton method. We consider the experimental results are promising for the practical use.
In future work, our method and implementation should be improved to allow large and uncertain initial values. Examples in a realistic setting should be demon- strated with the implementation.
Acknowledgment
This work was partially funded by JSPS (KAKENHI 25880008).

References
Alur, R., C. Courcoubetis, N. Halbwachsc, T. A. Henzinger, P. H. Ho, X. Nicollin, A. Olivero, J. Sifakis and S. Yovine, The algorithmic analysis of hybrid systems, Theoretical Computer Science 138 (1995),
pp. 3–34.
Alur, R., T. Feder and T. A. Henzinger, The Benefits of Relaxing Punctuality, Journal of the ACM 43
(1996), pp. 116–146.


Chen, X., E. Abraham and S. Sankaranarayanan, Taylor Model Flowpipe Construction for Non-linear Hybrid Systems, in: IEEE Real-Time Systems Symposium, 2012.
Cimatti, A., A. Griggio, S. Mover and S. Tonetta, Verifying LTL Properties of Hybrid Systems with K-LIVENESS, in: CAV, LNCS 8559, 2014, pp. 424–440.
Collins, P. and A. Goldsztejn, The Reach-and-Evolve Algorithm for Reachability Analysis of Nonlinear Dynamical Systems, Electronic Notes in Theoretical Computer Science 223 (2008), pp. 87–102.
David, A., D. Du, K. G. Larsen, A. Legay, M. Mikuˇcionis, D. B. g. Poulsen and S. Sedwards, Statistical Model Checking for Stochastic Hybrid Systems, Electronic Proceedings in Theoretical Computer Science 92 (2012), pp. 122–136.
Donz´e, A. and O. Maler, Robust Satisfaction of Temporal Logic over Real-Valued Signals, in:
FORMATS, LNCS 6246, 2010, pp. 92–106.
Eggers, A., M. Franzle and C. Herde, SAT Modulo ODE : A Direct SAT Approach to Hybrid Systems, in: ATVA, LNCS 5311, 2008, pp. 171–185.
Fainekos, G., A. Girard and G. Pappas, Temporal logic verification using simulation, in: FORMATS, LNCS 4202, 2006, pp. 171–186.
Gao, S., J. Avigad and E. M. Clarke, Delta-Decidability over the Reals, in: LICS, 2012, pp. 305–314.
Gao, S. and E. M. Clarke, Satisfiability Modulo ODEs, in: FMCAD, 2013, pp. 105–112.
Gao, S., S. Kong, W. Chen and E. M. Clarke, δ -Complete Analysis for Bounded Reachability of Hybrid Systems (2014).
Goldsztejn, A. and L. Jaulin, Inner approximation of the range of vector-valued functions, Reliable Computing 14 (2010), pp. 1–23.
Goubault, E., O. Mullier and M. Kieffer, Inner Approximated Reachability Analysis, in: HSCC, 2014,
pp. 163–172.
Ishii, D., K. Ueda and H. Hosobe, An interval-based SAT modulo ODE solver for model checking nonlinear hybrid systems, International Journal on Software Tools for Technology Transfer (STTT) 13 (2011), pp. 449–461.
Maler, O. and D. Nickovic, Monitoring Temporal Properties of Continuous Signals, in: FORMATS, LNCS 3253, 2003, pp. 152–166.
Moore, R. E., “Interval Analysis,” Prentice-Hall, 1966.
Nedialkov, N. S., VNODE-LP — A Validated Solver for Initial Value Problems in Ordinary Differential Equations, Technical report, McMaster University (2006).
Neumaier, A., “Interval Methods for Systems of Equations,” Cambridge University Press, 1990.
Nghiem, T., S. Sankaranarayanan, G. Fainekos, F. Ivancic, A. Gupta and G. J. Pappas, Monte-Carlo Techniques for Falsification of Temporal Properties of Non-Linear Hybrid Systems, in: HSCC, 2010,
pp. 211–220.
Plaku, E., L. E. Kavraki and M. Y. Vardi, Falsification of LTL Safety Properties in Hybrid Systems, in: TACAS, LNCS 5505, 2009, pp. 368–382.
Platzer, A. and E. M. Clarke, Formal Verification of Curved Flight Collision Avoidance Maneuvers : A Case Study, in: FM, LNCS 5850, 2009, pp. 547–562.
Podelski, A. and S. Wagner, Model Checking of Hybrid Systems : From Reachability towards Stability, in: HSCC, LNCS 3927, 2006, pp. 507–521.
Ramdani, N. and N. S. Nedialkov, Computing reachable sets for uncertain nonlinear hybrid systems using interval constraint-propagation techniques, Nonlinear Analysis: Hybrid Systems 5 (2011), pp. 149– 162.
Shultz, B. and B. J. Kuipers, Proving properties of continuous systems : qualitative simulation and temporal logic, Artificial Intelligence 92 (1997), pp. 91–129.
Wang, Q., P. Zuliani, S. Kong, S. Gao and E. Clarke, SReach : Combining Statistical Tests and Bounded Model Checking for Nonlinear Hybrid Systems with Parametric Uncertainty, Technical report, Carnegie Mellon University (2014).
Zuliani, P., A. Platzer and E. M. Clarke, Bayesian statistical model checking with application to Stateflow/Simulink verification, Formal Methods in System Design 43 (2013), pp. 338–367.
