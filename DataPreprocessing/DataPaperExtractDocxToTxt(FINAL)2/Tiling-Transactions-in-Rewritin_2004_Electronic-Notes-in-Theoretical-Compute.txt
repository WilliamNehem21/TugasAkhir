Electronic Notes in Theoretical Computer Science 71 (2003)
URL: http://www.elsevier.nl/locate/entcs/volume71.html  20 pages


Tiling Transactions in Rewriting Logic ?

Roberto Bruni a,1, Jose´ Meseguer b,2, and Ugo Montanari a,1
a Computer Science Department, University of Pisa, Italy.
b CS Department, University of Illinois at Urbana-Champaign, USA.



Abstract
We propose a modular high-level approach to the specification of transactions in rewrit- ing logic, where the operational and the abstract views are related by suitable adjunctions between categories of tile theories and of rewrite theories.
Key words: tile logic, rewriting logic, category theory, transactions, zero-safe nets, Petri nets.



Introduction
The enormous growth of the World Wide Web has increased the demand for global computing applications, where the “orchestration” of the flow of data and of mo- bile processes is a key issue. While synchronous communication on the web is unrealistic, and thus asynchronous formal models are preferred, many applications often require a coordination layer between distributed components that are designed and implemented separately (e.g. in e-commerce or on-line auction systems). For this purpose, platforms like BizTalk and Javaspaces exploit a centralized trans- action manager (TM) to guarantee the so-called ACID—Atomicity, Consistency, Isolation, and Durability—properties (e.g. if a transaction aborts then a consistent configuration must be restored). Nevertheless, TM’s are not a panacea, since their presence raises several questions that involve both theoretical aspects and pragmat- ics (perhaps even ethics). For example: (1) the lack of a formal abstract model; (2) the heavy task overload on the servers running TM’s; and (3) when two or more organizations are involved in a transaction, which TM should take control?
? Research supported by IST-2001-32747 Project agile, by the Italian MIUR Project cometa, and by ONR Grant N00014-02-1-0715. The first author is also supported by an Italian cnr fel- lowship for research on Information Sciences and Technologies, and by the CS Department of the University of Illinois at Urbana-Champaign.
1 Email: {bruni,ugo}@di.unipi.it
2 Email: meseguer@cs.uiuc.edu
◯c 2003 Published by Elsevier Science B. V. Open access under CC BY-NC-ND license.



µ	(actµ)
µ

structural congruence

.P −→ P

−→ Pj
(lparµ)
(ass)	P | (Q | R)	≡	(P | Q) | R

P | Q  µ
P  µ
Pj | Q
j
(sym)	P | Q
≡	Q | P

−→ P
(rparµ)
(id)	P | 0	≡	P

Q | P  µ  Q | Pj

P 	j
¯	j
rewrite rules

 −→ P Q −→ Q 
(com)	¯

P | Q   Pj | Qj
(sync)	.P | .Q	⇒	P | Q

Figure 1. LTS vs reduction semantics illustrated.

In this paper, we propose a high-level specification formalism for distributed transactions together with a meta-theoretic approach, where two views are kept distinct, but are formally related: (i) an abstract view, where transactions are seen as atomic activities that can take place independently from the rest of the system; and
(ii) a refined view, where the coordination layer is made explicit. These two views reflect the two principal ways for defining the dynamics of many calculi: (a) by defining a rewriting (or “reduction”) semantics over terms up to a suitable structural congruence (in the style of the CHAM [1] or, more generally, rewriting logic [13]); and (b) by means of labeled transition systems (LTS) specified in the SOS style [17], where transition labels are the means for coordinating system components.
A typical example that illustrates the different flavor of (a) and (b) is given by the elementary CCS-like calculus with inactive process 0, action prefix µ. (with actions µ ∈ A ] A¯] {}) and parallel composition  | , whose two semantics are
compared in Figure 1 (actually, reductions under action prefix must be forbidden). Suppose that a process P in the calculus above is used to model a network through which the users Q1 and Q2 are willing to communicate on a certain channel a. Then the SOS rules of the LTS semantics specify how the communication must be propagated through the network, while the rewriting semantics just assumes that the network can be rearranged in such a way that Q1 and Q2 can locally “shake-hands.” Thanks to their generality as specification and logical frameworks, we choose rewriting logic and tile logic as suitable candidates for the formal modeling of the
views (i) and (ii) above, respectively.
Rewriting logic (RL) [13] not only supports the reduction paradigm, but also exploits proof terms of rewrites as first class citizens, endowing the system with an algebra of computations that can be further abstracted to characterize behavioural equivalences. Furthermore, proof terms precisely characterize concurrent computa- tions. These features make RL an expressive semantic framework for concurrency, parallelism and interaction, and for representing other logics.
Tile logic (TL) [10] is an extension of RL that links the most interesting features of LTS and reduction semantics. Tile logic exploits a three-dimensional view of concurrent systems: the horizontal dimension (space) is devoted to the modeling of states and components; the vertical dimension (time) models labeled steps; and the third dimension (concurrency) accounts for the distribution of activities and re-


sources. This separation of concerns makes it possible to select different flavors of TL simply by fine tuning the algebraic structure of the elements in space and time and by fixing their interplay. Recent applications of TL concern an interac- tive view of Logic Programming [7] and a meta-theory of concurrent semantics centered around causal and spatial aspects [6]. This paper proposes a further appli- cation area, namely the semantics of distributed transactions.
There are two more reasons motivating our choice. The first motivation is that, under reasonable circumstances, TL specifications can be translated to exe- cutable RL specifications, by exploiting reflection and meta-strategies [8] to control rewrites (see e.g. [15,4,2]). Since transactions are essentially “selected” computa- tion patterns, they can be directly translated in meta-strategies that bridge the gap between the refined and the abstract level. The second reason is that the simplest class of tile theories (called zero-safe nets), where both configurations and observa- tions are multisets of basic elements, has already been shown to extend ordinary P/T Petri nets (that are just a special case of rewrite theories) with the notion of concur- rent transaction. Hence a generalization of this net-based account of transactions to arbitrary tile and rewrite theories yields a high-level and expressive specifica- tion formalism that is amenable to a large field of applications for which the net modeling would not fit adequately or would require complex encodings.
The main reference for zero-safe nets is [5]. Besides ordinary places, called sta- ble, zero-safe nets come equipped with zero places, which are empty in any stable marking; a transaction is a concurrent computation which may use zero tokens as triggers, but defines an evolution between stable markings only. The abstract view of a zero-safe net N is an ordinary P/T Petri net whose places are the stable places of N, and whose transitions are the basic transactions of N. The relation between zero-safe nets and their abstract counterparts is expressed by a categorical coreflec- tion. The paper [3] presents a distributed implementation of zero-safe nets, where centralized TM’s are replaced by a fully distributed commit algorithm. Note that it is the interpreter’s task to guarantee that transactions are executed correctly (or aborted if they cannot be completed). The ideas proposed in this paper can be used as a basis for more general distributed transaction algorithms. In fact, we generalize the relationship between zero-safe nets and P/T Petri nets to tile theories (system design level) and rewrite theories (abstract level) to define a general framework for transactions, where: (1) the low-level view of the system is given by a tile machine running under the ACID properties of transactions; (2) the high-level view of the system is an ordinary rewrite theory generated by the (refined) tile theories, such that there is one rewrite rule for each concurrent transaction of the tile machine.
Our main result is the definition of a coreflection between the category of rewrite theories and the category of tile theories with suitable refinement mor- phisms. This leads to a conceptual clarification of how TL and RL are related and gives a faithful description of the effective communication mechanism needed in rewrite rules to model coordination. As an example, we give a formal justification for the claim that in passing from the LTS to the reduction semantics in Figure 1 there is a loss of information about the way in which synchronization is achieved.


Structure of the paper. In § 2, we fix the categorical presentation of rewrite the- ories (§ 2.1) and of tile theories (§ 2.2). In § 3, we recall the theory of zero-safe nets and the algebraic constructions carried out in [5]. In § 4, we extend the zero- safe approach to tiles, studying the algebraic constructions for computational and abstract models. It is worth noting that the construction for zero-safe nets now be- comes just a special case of the more general theory developed in this paper. Our technique is illustrated by a simple example in § 5. Conclusions are drawn in § 6. Appendices A and B recall some preliminary notion about double categories and adjunctions, respectively. Moreover, two tables by the end Appendix B summarizes all the categories and all the constructions discussed in the paper.

Computads and categories of computations
Rewriting logic and 2-computads
The main ingredients of RL are the signature of configurations , the set of struc- tural axioms E, and the set of rewrite rules R over the congruence classes [t]E (of
-terms t modulo the axioms in E). Then, proof terms form a cartesian 2-category generated by the rewrites in R via simple inference rules (see e.g. [12,13]).
Here, we give a more abstract presentation of rewriting logic by taking config- urations in a (strict) monoidal category C. We assume that the reader has some familiarity with category theory. An arrow f with domain d( f ) = a and codomain c( f ) = b is written f : a → b. We denote each identity by the object name itself, ar-
row composition (in diagrammatic order) by  ; , the monoidal tensor product by
⊗ and its unit element by e. Since we always consider strict monoidal categories and functors, in the following we shall omit the word “strict.”
The standard case follows by taking as C the Lawvere theory L,E associated with the equational theory (, E) [11]. Roughly, the cartesian category L,E has underlined natural numbers as objects (n represents a set with n ordered variables for which we use standard names x1, ..., xn), and the tuples of (equivalence classes of) terms [t]E as arrows ( f : n → m is an m-tuple of terms over x1, ..., xn), with com- position given by term substitution. The cartesian product of L,E gives the ten- sor product ⊗ on configurations. We use the terminology 2-computads, borrowed from [18,19], for this abstract flavor of rewrite theories.
Definition 2.1 A 2-computad is a 4-tuple C = (C, R, l, r), where C is the monoidal category of configurations, R is a set of rule names, and l, r: R → C are the source and target functions denoting the lefthand side and the righthand side of each rule r ∈ R, with the constraints that: (1) d(l(r)) = d(r(r)), and (2) c(l(r)) = c(r(r)).
Note that if C has only one object (the unit e), then sequential composition coincides with the tensor product (by monoidality and functoriality of ⊗), and the constraints (1–2) of Definition 2.1 are trivially satisfied.
From the computational point of view, the arrows in C are the configurations of the system, which can be composed in parallel (⊗) and sequentially (;). Domains



f : a → b ∈ C (id)
f : f ⇒ f
	r ∈ R	 (gen)
r: l(r) ⇒ r(r)
 1: f1 ⇒ g1, 2: f2 ⇒ g2  (par)
1 ⊗ 2: f1 ⊗ f2 ⇒ g1 ⊗ g2
i: fi ⇒ gi, i = 1, 2, c( f1) = d( f2) (hseq)
1 ∗ 2: f1; f2 ⇒ g1; g2
: f ⇒ g, : g ⇒ h (vseq)
 · : f ⇒ h


Equations.

Inference rules.
Figure 2. The cells in rw(C ).
and codomains model, respectively, the input and output interfaces of components. A rule r ∈ R models a basic reduction from the configuration l(r) to r(r). Each re- duction r can take place independently from the context where l(r) resides, thus any configuration f ; l(r); g can be rewritten to f ; r(r); g by applying r. Moreover, given two rules r1, r2 ∈ R and the configurations l(r1); l(r2) and l(r1) ⊗ l(r2), then concur- rent reductions are possible that lead to r(r1); r(r2) and r(r1) ⊗ r(r2), respectively. This yields a 2-category whose cells are concurrent computations.
Definition 2.2 Given a 2-computad C = (C, R, l, r), the monoidal 2-category rw(C ) has the same objects and arrows as C, and cells defined by the inference rules in Figure 2(a) modulo the laws of monoidal 2-categories in Figure 2(b) (valid when- ever both sides of the equations are correctly defined cells).
Compositions ∗ and · are called horizontal and vertical, respectively, according to the graphical convention of composing configurations horizontally from left to right and computations vertically from top to bottom. For example, the rewrite r, with arguments f and inside the context g is denoted by the proof term f ∗ r ∗ g:
l(r)

a 	f	z, d(l(r))
⇓r
r(r)
c(l(r))	g
,˛
,z b

Definition 2.3 A 2-computad morphism between (C1, R1, l1, r1) and (C2, R2, l2, r2) is a pair (C , R) where C : C1 → C2 is a monoidal functor, and R: R1 → R2 is a func- tion such that for any r ∈ R1: (1) C (l1(r)) = l2(R(r)) and (2) C (r1(r)) = r2(R(r)). We let 2Comp be the category whose objects are 2-computads and whose arrows are 2-computad morphisms (with obvious identities and pairwise composition). Moreover, we denote by 2Compc the full subcategory of 2Comp whose objects are 2-computads with a commutative monoidal category of configurations (i.e., where the tensor product ⊗ is commutative).
2-computads C are related to their computations rw(C ) via an adjunction.



initial input interface ◦ 	s	z, ◦
initial output interface


final input interface
u
◦²,
	v
t	z, ◦,²

final output interface


Figure 3. The tile : s  u	t.
v
Proposition 2.4 Let 2MCat be the category of monoidal 2-categories (as objects) and monoidal 2-functors (as arrows). The obvious forgetful functor U2: 2MCat → 2Comp has a left adjoint F2: 2Comp → 2MCat with F2(C ) ' rw(C ).

Tile logic and D-computads
Tiles extend ordinary rewrite rules with the possibility of changing the input and output interfaces during system evolution. The way in which they are changed is ex- pressed by arrows in a vertical category. More generally, vertical arrows model the information passed between interfaces. Graphically, this amounts to representing
rules as rectangles, whence the name tile. The tile in Figure 3 is written : s	u  t,
v
and states that the initial configuration s can evolve to the final configuration t, pro- ducing the effect v when the trigger u is provided by the components connected to the input interface of s. The arrows s, u, v and t form the border of  and are con- ventionally denoted by the initials of the four main compass points (e.g. n() = s).
Definition 2.5 A D-computad is a 7-tuple D = (H, V, T, n, s, w, e), where H is the monoidal category of configurations, V is the monoidal category of observations, T is a set of tile names, n, s: T → H, and w, e: T → V are the (bidimensional) source and target functions denoting, respectively, the initial and final configurations, the trigger, and the effect of each tile r ∈ T , with the constraints that:
the categories H and V have the same objects;
d(n(r)) = d(w(r)), for any r ∈ T ;
c(n(r)) = d(e(r)), for any r ∈ T ;
d(s(r)) = c(w(r)), for any r ∈ T ;
c(s(r)) = c(e(r)), for any r ∈ T .
It is immediate that any 2-computad is just a particular D-computad whose ver- tical category V of observations is the discrete category of objects in the horizontal category H (by taking C = H and l = n and r = s). Note that tile rewrites cannot be applied in arbitrary contexts. For example, the tile r can be applied to f ; n(r); g only if its trigger w(r) can be coordinated with f , and its effect e(r) with g:
a	f	z, d(n(r))	n(r)	,z c(n(r)) 	g	z, b
w(r)	⇓r	e(r)

?,²
z, d(s(r))	s(r)
,z c(s(r))
,z ?,²

Like rewrite rules, tiles can be composed horizontally, vertically, and in parallel to generate larger steps. The three compositions are illustrated in Figure 4. Due to




◦ 	z, ◦	z, ◦

◦	 z, ◦
◦	z, ◦


		◦
◦,²
z, ◦
,z ◦,²
◦,² 	z, ◦,²

◦,² 	,z ◦², 	,z ◦,²
◦²,  	

◦,² 	z, ◦,²

Figure 4. Horizontal, parallel and vertical tile compositions.
u	w

t: a → b ∈ H
a
−→
(hid)
1: s1−→t1, 2: s2−→t2
	w	v	 (hseq)

t: t  b t	1 ∗ 2: s1; s2−→t1; t2
u1	u2

u: a → b ∈ V (vid)
u: a−→b
1: s−→q, 2: q−→t
u1;u2
−→
v1;v2
(vseq)

u1	u2

	r ∈ T	
w(r)
r: n(r)−→s(r)
(gen)
1: s1−→t1, 2: s2−→t2
u1⊗u2
1 ⊗ 2: s1 ⊗ s2 −→ t1 ⊗ t2
(par)

Figure 5. The cells in tl(D).
space limitation, we refer to [9,15,2] for the theory of ordinary and monoidal double categories. For the reader’s convenience, some basics are recalled in Appendix A. Roughly, the elements of monoidal double categories are cells analogous to the rectangle in Figure 3 and have two sequential compositions (horizontal and vertical) and a tensor product, all the operations being mutually functorial.
Definition 2.6 Given a D-computad D = (H, V, T, n, s, w, e), the monoidal double category tl(D) has horizontal 1-category H, vertical 1-category V, and (double) cells defined by the inference rules in Figure 5, modulo the laws of monoidal double categories (cf. [2,15] for details).

Definition 2.7 A D-computad morphism between D1 and D2 is a triple (H , V , T ) such that H : H1 → H2 and V : V1 → V2 are monoidal functors, and T : T1 → T2 is a function such that:
the functors H and V coincide on objects;
H (n1(r)) = n2(T (r)), for any r ∈ T1;
H (s1(r)) = s2(T (r)), for any r ∈ T1;
V (w1(r)) = w2(T (r)), for any r ∈ T1;
V (e1(r)) = e2(T (r)), for any r ∈ T1.
We let DComp denote the category whose objects are D-computads and whose arrows are D-computad morphisms. Moreover, we denote by DCompc the full subcategory of DComp consisting of D-computads whose configurations and ob- servations are commutative monoidal categories.
A D-computad D is related to the monoidal double category tl(D) of its com-


putations via an adjunction.
Proposition 2.8 Let DMCat be the category of monoidal double categories (as objects) and monoidal double functors (as arrows). The obvious forgetful functor Ud: DMCat → DComp has a left adjoint Fd with Fd(D) ' tl(D).

Review of the zero-safe approach
P/T Petri nets are graphs whose set of nodes is the free commutative monoid S⊕ over the places S, and whose arcs are called transitions. A Petri net morphism is a graph morphism that in addition preserves the monoidal structure of markings (i.e. a graph morphism whose node component is a monoid morphism). The category Petri has Petri nets as objects and Petri net morphisms as arrows.
Since S⊕ can be regarded as a monoidal category having a unique object (the unit e), the elements of S⊕ as arrows, and composition given by m; mj = m ⊕ mj, then P/T Petri nets can be regarded as 2-computads by a direct translation of tran- sitions into rewrite rules. In fact, each m ∈ S⊕ exactly defines a multiset of places (marking) and any transition t with pre-set m and post-set mj can be seen as a rewrite t: m → mj. Note that rewrites can be applied (concurrently) inside any larger multi- set (see [16] for the RL specification of several kinds of nets).
Proposition 3.1 The category Petri is isomorphic to the full subcategory of 2Compc
(and hence of 2Comp) whose objects are 2-computads of the form (S⊕, T, l, r).
A zero-safe net [5] is a P/T Petri net whose set of places S is partitioned into two disjoint subsets of stable places L and zero places Z, and whose transitions in a transactional way, as we explain below.
The key idea is that transitions can be fired only as part of transactions that lead from stable markings (i.e. elements of L⊕) to stable markings. Starting from a stable marking, the net computes by firing transitions that can fetch tokens of both kinds. After each firing, only the zero tokens in the post-set are made available for the successive firings: the stable tokens in the post-set will be made available to the system only at commit time, when no zero token involved in the transaction is left. This assumption introduces a coordination mechanism between transitions that can be implemented in distributed languages [3]. While zero tokens are useful at the specification level for modeling coordination, at the abstract level the system can be viewed as an ordinary P/T Petri net, whose places are the stable places of the system and whose transitions are the basic transactions. The advantage is that the zero-safe specification is in general simpler and more natural than its abstract view (finite specifications can yield infinitely many transactions). Furthermore, the abstract view can be defined via a categorical adjunction as recalled below from [5]. For example, let us consider the zero-safe net with two stable places a and b, a zero place z and two transitions t1: a → z ⊕ b and t2: b ⊕ z → a. Then, if the initial
marking is a, no transaction can be performed, as the token in b produced by a
firing of t1 would not be available immediately, and thus t2 would not be enabled.


Instead, if the initial marking is a ⊕ b then t1 can be fired first and then the token initially present in b can be used together with the token in z produced by t1 to enable t2 and close the transaction (whose commit releases fresh tokens in a and b). Let ZPetri be the category of zero-safe nets and the obvious graph homomor- phisms between them (preserving place partitioning to stable and zero), with the
additional condition that distinct zero places have disjoint multisets as images.
The first step is to define a category HCatZPetri of zero-safe nets whose set of transitions has a (commutative) monoidal operation ⊗, a horizontal sequential operation ∗ (that concatenates on zero places only and behaves as the parallel com- position on stable pre- and post-sets), and identities, quotiented out by suitable axioms. The morphisms of HCatZPetri are zero-safe net morphisms preserving all the additional structure. Horizontal composition allows building transactions that exploit the flow of zero tokens. There is an adjunction between ZPetri and HCatZPetri. We let Z : ZPetri → HCatZPetri denote the free functor.
The second step is the characterization of basic transactions: given a transition
 of a net in HCatZPetri, we say that : m → mj with m and mj stable is prime if it cannot be decomposed as the concurrent execution of two other non-trivial transitions. Formally,  is prime if  /= e and if whenever  = 1 ⊗ 2 then 1 = e ∨ 2 = e. Given a zero-safe net N, prime arrows in Z (N) are shown to exactly model the (basic) transactions of N, defining an implementation of the abstract net. Hence, a refinement morphism R: N1 → N2 is a zero-safe net morphism Rˆ: N1 → Z (N2) that maps transitions either to prime arrows or to transitions of N2.
In the example discussed above, we have t1 ⊗ t2: a ⊕ b ⊕ z → b ⊕ z ⊕ a, while t1 ∗ t2: a ⊕ b → b ⊕ a (the token in z produced by t1 is consumed by t2). Moreover, t1 ∗ t2 is a prime arrow (the only one), while e.g. (t1 ⊗ t1) ∗(t2 ⊗ t2): a ⊕ b ⊕ a ⊕ b → b ⊕ a ⊕ b ⊕ a is not a prime arrow because it can be decomposed as (t1 ∗t2) ⊗(t1 ∗t2). Hence the abstract net has two places (a and b) and one transition t: a ⊕ b → b ⊕ a which can be mapped by a refinement morphism to the prime arrow t1 ∗ t2. (We refer to [5] for more detailed examples.)
The third step is the definition of the category ZSN of zero-safe nets (as ob- jects) and refinement morphisms (as arrows). In fact, refinement morphisms can be composed via a lifting that preserves primality. The category Petri is a coreflective subcategory of ZSN. Moreover, the right adjoint Az: ZSN → Petri maps zero-safe nets to their abstract counterparts, and the counit of the adjunction maps transitions of the abstract net to the transactions they represent. The properties of adjunctions show that Z and Az are the “best” feasible constructions (up to isomorphism).




Zero-safe rewrite theories

We first explain in detail the analogy between zero-safe nets and tiles, and then generalize the constructions in [5] to tiles and rewrite theories.


Zero-safe nets as tiles
As noticed at the begininning of Section 3, the free commutative monoid S⊕ over the places S can be seen as a category with a unique object e. Moreover, if L is the set of stable places and Z is the set of zero places of a zero-safe net, it is easy to see that (L ] Z)⊕ ' L⊕ × Z⊕. We already noticed that P/T Petri nets are just 2-computads of the form (L⊕, T, l, r), for l and r the pre- and post-set functions, and that the notion of net morphism coincides with that of 2-computad morphism (Proposition 3.1). Analogously, a zero-safe net can be regarded as the D-computad (L⊕, Z⊕, T, n, s, w, e) where: (i) the pre-set of t ∈ T is n(t) ⊕ w(t); and (ii) the post- set of t ∈ T is s(t) ⊕ e(t). Then, it can be easily verified that the additional algebraic structure of transitions in the objects of HCatZPetri is just given by the ordinary identity, parallel and horizontal composition of tiles (but note that here the parallel composition is commutative). For example, if ai, bi are stable places, z is a zero

place, t : a	e z
b1 is a transition from a1 to b1 ⊕ z and t2: a2	z
e
b2 is a transition

from a2 ⊕ z to b2, then their horizontal composition t1
∗ t2: a1; a2 −e	b1; b2
e
forms a

transaction from a1 ⊕ a2 = a1; a2 to b1 ⊕ b2 = b1; b2.
However, at the morphism level, DComp is more permissive than ZPetri, be- cause the images of two distinct vertical arrows (e.g. zero places) are not neces- sarily disjoint multisets. This property is central to the lifting of refinement mor- phisms used in ZSN for arrow composition. Thus ZPetri is strictly included in the full subcategory of DComp whose objects are all the D-computads of the form
(L⊕, Z⊕, T, n, s, w, e). To make the correspondence more precise, we can restrict D-
computad morphisms to satisfy an extended notion of the disjoint image property.
Definition 4.1 A D-computad morphism (H , V , T ) from D1 to D2 is disjoint if the functor V is injective on objects and faithful on arrows. We call ZComp the category of D-computads as objects and disjoint D-computad morphisms as ar- rows, and we let ZCompc denote the full subcategory of ZComp whose objects are D-computads over commutative monoidal categories of configurations and ob- servations.
Proposition 4.2 The category ZPetri is naturally isomorphic to the full subcate- gory of ZCompc whose objects are D-computads of the form (L⊕, Z⊕, T, n, s, w, e).
As exemplified by the construction tl(D), D-computads have standard hori- zontal and parallel compositions, hence we can define the category HCatZComp, where: (1) the objects are D-computads whose set of tiles possesses a monoidal op- eration ⊗ and horizontal composition ∗ with horizontal identities for observations (but neither the vertical composition · nor the vertical identities for configurations are considered); and (2) the arrows are disjoint D-computad morphisms preserv- ing all the additional structure. We let HCatZCompc be the full subcategory of HCatZComp whose D-computads have a commutative parallel composition ⊗.
Proposition 4.3 The category HCatZPetri is isomorphic to the full subcategory of
HCatZCompc whose objects are D-computads of the form (L⊕, Z⊕, T, n, s, w, e).


Proposition 4.4 There is an obvious adjunction between ZComp and HCatZComp that builds the horizontal computations of tiles. We let D denote the free functor. Analogously, there is an adjunction between ZCompc and HCatZCompc and we let D c denote the corresponding free functor. Then, the diagram of functors and obvious embeddings
ZPetri 	Z	z, HCatZPetri
˛	'	˛ z
ZCo²mpc	z, HCatZ²Compc
D
commutes (up to natural isomorphism).
In Section 4.2 we show how to generalize the notion of refinement morphism in such a way that the coreflection between Petri (abstract view) and ZSN (specifi- cation view) can be properly extended to rewrite and tile theories.

From tiles to transactional rewrite rules
The idea is that, starting from a given configuration, double computads can begin rewriting it, producing observations that must be coordinated in the continuation of the transaction. Enabled rewrites can be executed concurrently. A transaction is completed when all actions have been coordinated (the global trigger and effect must be identities, as the transaction can be executed in isolation). At the abstract level, each transaction is thus an ordinary rewrite rule. The bidimensional repre- sentation of tiles marks a clear distinction between system configurations and the structure involved in the coordination of rewrites. Conceptually, this resembles the zero-safe approach, and the abstract view can be defined by generalizing the alge- braic construction based on refinement morphisms. The first step is to generalize the notion of primality, so as to characterize the basic transactions.
Definition 4.5 Given a tile  of a D-computad in HCatZComp, we say that  is
prime if it cannot be decomposed as the concurrent execution of two other non-

trivial tiles. Formally, : s  a
b
t,  /= e is prime if a and b are identities and

 = 1 ⊗ 2	=⇒	1 = e ∨ 2 = e.
Unfortunately the above constraint is not strong enough for guaranteeing that prime arrows represent atomic activities. In fact, suppose that  = 1 ∗ 2 with 1 and 2 prime, such that the trigger of 2 (and hence the effect of 1, which must be equal) is an identity arrow, then it would not be correct to assume that 1 and 2 are interacting in the same transactions (unless 1 or 2 are object identities). The difference w.r.t. the case of zero-safe nets is due to the fact that in HCatZPetri, if
 = 1 ∗ 2 and the trigger of 2 is e (the only possible identity), then  = 1 ⊗ 2 and the normal constraint can be applied. To guarantee atomicity, we must avoid any possible embedding between basic transactions.



Definition 4.6 A prime tile 1: s
a1
1 −→ 1
b1
is elementary if

1 = 1 ∗ (u1 ⊗ 2 ⊗ u2) ∗ 2 with 2: s2  a2
b2
t2	=⇒	1 = 2 ∨ 2 = a2.

Since ∗ and ⊗ are the only operations for composing tiles in HCatZPetri, the context 1 ∗ (u1 ⊗ ⊗ u2) ∗ 2, where u1 and u2 are suitable horizontal identities, models the more general situation for embedding a transaction inside another. Of course, identities of objects like a2 are not considered as transactions and can be used in elementary tiles.
Definition 4.7 A computad refinement morphism M : D1 → D2 is a disjoint D- computad morphism Mˆ: D1 → D [D2] sending tiles either to tiles of D2 or to ele- mentary elements of D [D2].
Lemma 4.8 Given a computad refinement morphism M : D1 → D2, let us denote by M˜: D [D1] → D [D2] its unique extension in HCatZComp by means of the ad- junction D. Then, M˜preserves elementary tiles.
Proof (Sketch) We must show that, if  is elementary in D [D1], then M () is also elementary. We fix a representation of  as the horizontal composition of n tiles of the form ui ⊗ i ⊗ vi for i = 1..n, where the i’s are basic tiles in D1 and then we proceed by contradiction by showing that if
M˜() = ³M (u1) ⊗ M (1) ⊗ M (v1)´∗ ... ∗ ³M (un) ⊗ M (n) ⊗ M (vn)´
is not elementary, then, by exploiting the faithfulness of disjoint D-computad mor- phisms,  also can be shown to be non-elementary, contradicting the hypothesis. (The key fact is that each M (i) must be a basic tile of D2, by elementarity of .)
Thanks to Lemma 4.8, the composition of two computad refinement morphisms M1: D1 → D2 and M2: D2 → D3 is defined as the morphism M1; M2, and it is again a computad refinement morphism. Thus, together with the obvious identities, computad refinement morphisms form a category.
Definition 4.9 The category RComp has D-computads as objects and computad refinement morphisms as arrows.
The analogy between nets and computads can now be fully exploited, leading to the main result of the paper.
Theorem 4.10 The category 2Comp is a coreflective subcategory of RComp. Proof (Sketch) First we show that the obvious inclusion I of 2Comp into RComp
is full and faithful. If D is a 2-computad, then the elementary arrows of D [D] are
just the rewrite rules of D. This means that, given any 2-computads D1 and D2, any computad refinement morphism is just a 2-computad morphism. On the other hand, it is obvious that any 2-computad morphism is also a computad refinement morphism, because it maps transitions into transitions. Next, we must show that I has a right adjoint Ad. Given a D-computad D = (H, V, T, n, s, w, e), let Ad[D]



1	µ⊗1

1⊗µ
⊗¯


		
actµ: µ.x1−→x1	lparµ: x1 | x2−→x1 | x2	rparµ: x1 | x2−→x1 | x2	com: x1 | x2−→x1 | x2
µ	µ	µ	1

Figure 6. Tiles for the SOS rules in Figure 1
be the D-computad having the same horizontal 1-category of D, the discrete ver- tical 1-category given by the objects of V, and as tiles all the elementary tiles of D [D] (with obvious borders). Since the vertical 1-category of Ad[D] is discrete, it is obvious that its tiles are ordinary rewrite rules, and therefore Ad[D] is just a 2-computad. The mapping Ad can be extended to a functor by mapping each com- putad refinement morphism M : D1 → D2 into its lifted version, with domain re- stricted to the tiles in Ad[D1]. The definition is correct, because the lifting preserves
the “elementary” property. The proof of adjunction follows from the definition of computad refinement morphism.
The right adjoint Ad characterizes the abstract behaviours of D-computads by associating with a D-computad D = (H, V, T, n, s, w, e), a 2-computad Ad[D] hav- ing the same horizontal 1-category of D and as rewrite rules all the elementary tiles of D [D] (the counit maps rewrite rules of Ad[D] to the tile transactions they represent).
An analogous construction is possible also when a commutative tensor prod- uct of tiles is considered, yielding the category RCompc of which 2Compc is a coreflective subcategory. We denote by A c the corresponding right adjoint.
Finally, the coreflection of Petri in ZSN becomes just a special case of the more general coreflection between 2Compc and RCompc.
Proposition 4.11 The diagram of functors and straightforward embeddings
ZSN 	Az	z, Petri
˛	'	˛ z
RCo² mpc 	z, 2Co²mpc
d
commutes (up to natural isomorphism).

Example
To illustrate our construction, let us consider again the simple process calculus defined in the Introduction (see Figure 1). The D-computad CCS corresponding to the LTS can be easily defined by a straightforward translation of the SOS rules (see examples in [2,15]). We take the free cartesian category (Lawvere theory) Proc generated by the process signature as the category of configurations. The vertical category is obtained by taking the free monoidal category over the actions
µ (regarded as arrows from 1 to 1). The tiles are illustrated in Figure 6.
Let us assume that a transaction should be given by the synchronization of two processes. In this case, after the synchronization, the  action should not be prop- agated further, as the rest of the system can evolve independently. For this reason,

elementary transactions (where 1 ≤ i < j ≤ n)
Ci, j−i[x , ..., .x , ..., ¯.x , ..., x ] ⇒ Ci, j−i[x , ..., x ]
n	1	i	j	n	n	1	n
synchronization contexts (where l, k ≥ 0 and i, r ≥ 1)

Ci,l+r
::=	(Li | Rr	)

i+l+r+k	l	i+l,k
L1 ::=	[ 1]	R1  ::=	[ n+1]

0	n,0
Li	::=	(Li | [ i+l+1])	Rr	::=	(Rr
| [ n+r+k+1])

l+1	l
n,k+1
n,k

Li+1 ::=	([ 1] | Ri )	Rr+1 ::=	([ n+1] | Rr	)

l	1,l
n,k
n+1,k

Figure 7. CCS abstract transactions.

in the rule com we define the effect of a synchronization to be just an identity. Note that this solution can introduce reductions under action prefixes, in the same way as the rule sync in Figure 1. To prevent such reductions the standard solution is to introduce a “top” operator and enforce rewriting at the top (or use order-sorted theories that distinguish between sequential and concurrent processes). Here, for the sake of simplicity, we assume that action prefix is declared as a frozen operator, so that the rewrite engine (e.g. the Maude interpreter) cannot rewrite under action prefixes.
By applying the construction Ad to CCS we obtain a 2-computad Ad[CCS] that models the atomic reductions available at the abstract level of the system. The rewrite rules in Ad[CCS] are the elementary tiles of D [CCS]. A generic (stable) state is an arbitrary parallel composition of sequential processes (i.e., either 0 or processes guarded by action prefix). Since reductions cannot be performed under action prefixes, the relevant part of the state can be depicted as a binary tree (internal nodes are labeled by parallel composition as in the ordinary view of terms as trees) whose leaves are labeled by sequential processes.
A generic transaction requires the occurrence of two complementary tiles, say
act and act¯, in two leaves of the tree, the subsequent propagation of their obser- vations  and ¯ toward the top of the tree (via lpar, rpar, lpar¯, and rpar¯), until their first common ancestor (i.e. the node associated with the least parallel
composition enclosing both sequential processes) receives the two triggers and can coordinate them via com. All the other nodes in the tree do not actively participate in the transaction.
Each transaction has the form C[x1, ..., .xi, ..., ¯.x j, ..., xn] ⇒ C[x1, ..., xn] for a
suitable context C with n holes, built using only parallel composition, which defines the binary synchronization tree going from the two interacting components .xi and
¯.x j to the first common parallel operator enclosing them. It is worth noting that
each elementary transaction is uniquely determined by its left-hand side.
Formally, the interesting contexts for elementary transactions are defined by the grammar in Figure 7. As sketched in Figure 8, a context Ci,m defines a synchro- nization tree with n leaves (the holes of the context), whose ith and jth leaves want to interact (with j = i + m). Since the root is the first common parallel operator enclosing the above leaves, it follows that it can be divided into two subtrees: Li



i, j−i n
|
....
...
¸¸¸¸
¸¸¸¸

....	i
Rr  ¸¸¸¸

....	Ll
...
i+l,k
¸¸¸
¸

[ 1]	i	[ i]	l	[ i+l ] r	[ j]	k	[ n]
Figure 8. Synchronization contexts, graphically (where j = i + l + r and n = j + k).

containing the first i + l leaves; and Rr	containing the remaining r + k leaves,
with l + r = m. The two subtrees are characterized by the fact that at every branch- ing one child is a hole, while the other child is the subtree containing one of the two interacting positions. For example, we have the derivations below:

C2,3 → L2 | R2
→ ([ 1] | R1
) | R2
→ ([ 1] | (R1
| [ 3])) | R2	→

5	1	3,0
1,1
3,0
1,0
3,0

([ 1] | ([ 2] | [ 3])) | R2	→ ([ 1] | ([ 2] | [ 3])) | ([ 4] | R1 ) →
([ 1] | ([ 2] | [ 3])) | ([ 4] | [ 5])

C2,3 → L2 | R3
→∗ ([ 1] | [ 2]) | R3
→∗ ([ 1] | [ 2]) | ([ 3] | ([ 4] | [ 5]))

5	0	2,0	2,0
On the other hand, the context ([ 1] | [ 2]) | (([ 3] | [ 4]) | [ 5]) cannot be generated from C2,3, because the subterm [ 3] | [ 4] is inessential to the transaction between the second (i = 2) and fifth ( j = i + 3) holes.
Thus, the abstract view of the D-computad is a 2-computad with infinitely many rewrite rules, one for each possible (binary) synchronization tree connecting two complementary action prefixes.
For example the transaction  = act ⊗ 1 ⊗ act¯  ∗ lpar ⊗ ¯ ∗ com de-
fines a reduction (.x1 | x2) | ¯.x3 ⇒ (x1 | x2) | x3 (obtained by taking C1,2 →
L1 | R1  ), while  = ³act ⊗ 1 ⊗ act¯´∗ ³ ⊗ rpar¯´∗ com defines a reduc-
tion .x1 | (x2 | ¯.x3) ⇒ x1 | (x2 | x3) (obtained by taking C1,2 → L1 | R2 ).
3	0	1,0
Note that concurrent transactions can take place under parallel composition (but not under prefixes, which are frozen). This is because, once an elementary trans- action  has been closed by the tile com, the context where it is embedded does
not take part in that transaction (by  being elementary) but can participate in other
transactions disjoint from .
If we take configurations in Proc/ ≡ (i.e. processes modulo associativity, com- mutativity and identity of parallel composition), then the abstract 2-computad has still infinitely many rewrite rules (the same as before), but now many of them have the same lefthand and righthand sides. For example, the transactions  and  above
are now two distinct ways of performing the reduction .x1 | x2 | ¯.x3 ⇒ x1 | x2 | x3.
Finally, the relationship between Ad[CCS/ ≡] and the reduction system in Fig- ure 1 can be expressed by the 2-computad morphism that sends the rule sync (i.e.
obtained as an instance of C1,1) in Figure 1 to the transaction (act ⊗ act¯) ∗ com,
2	
showing that this is just a possible way of synchronizing two processes.

Conclusion
We have extended the zero-safe approach of [5] to the more general framework of tile and rewrite theories. The coreflection between the abstract and the specification view relates the two principal operational models based on LTS and reductions and provides a systematic general approach to the definition of transactions. In fact, the universal property of coreflections guarantees that the abstract system is the best possible representation (among rewrite theories) of the concurrent transactions of its corresponding tile theory. It is worth noting that the representation results for zero-safe nets presented in [5] now follow from the more general constructions de- fined here. Let us finally mention that the horizontal composition of D-computads has some analogies with conditional rewriting logic, but we leave the study of the precise correspondence between these two specification options for future work.
Acknowledgment. We warmfully thank Narciso Mart´ı-Oliet for his many comments on a preliminary draft of the paper, which have been very helpful in improving the quality of our submission. We also thank the anonymous referees for their useful suggestions.

References
G. Berry, and G. Boudol. The chemical abstract machine, Theoret. Comput. Sci. 96
(1992), pp. 217–248.
R. Bruni. “Tile Logic for Synchronized Rewriting of Concurrent Systems,” Ph.D. thesis, Computer Science Department, University of Pisa (1999).
R. Bruni, C. Laneve, and U. Montanari. Orchestrating transactions in join calculus, in
Proc. CONCUR 2002, Lect. Notes in Comput. Sci. (2002), to appear.
R. Bruni, J. Meseguer, and U. Montanari. Process and term tile logic, Technical Report SRI-CSL-98-06, SRI International (1998).
R. Bruni and U. Montanari. Zero-safe nets: Comparing the collective and individual token approaches, Inform. and Comput. 156 (2000), pp. 46–89.
R. Bruni and U. Montanari. Dynamic connectors for concurrency, Theoret. Comput. Sci. 281(1-2) (2002), pp. 131–176.
R. Bruni, U. Montanari, and F. Rossi. An interactive semantics of logic programming, Theory and Practice of Logic Programming. 1 (2001), pp. 647–690.
M. Clavel and J. Meseguer. Reflection and strategies in rewriting logic, in Proc. WRLA’96, Elect. Notes in Th. Comput. Sci. 4 (1996).

E. Ehresmann. Cate´gories structure`es: I–II, Annales (1963), pp. 349–426.
E´ cole Normal Superieur 80

F. Gadducci and U. Montanari. The tile model, in Proof, Language and Interaction: Essays in Honour of Robin Milner, MIT Press, 2000. pp. 133–166.


F. W. Lawvere. Functorial semantics of algebraic theories, Proc. National Academy of Sciences 50 (1963), pp. 869–872.
J. Meseguer. Rewriting as a unified model of concurrency, Technical Report SRI-CSL- 90-02R, SRI International (1990).
J. Meseguer. Conditional rewriting logic as a unified model of concurrency, Theoret. Comput. Sci. 96 (1992), pp. 73–155.
J. Meseguer and U. Montanari. Petri nets are monoids, Inform. and Comput. 88(2) (1990), pp. 105–155.
J. Meseguer and U. Montanari. Mapping tile logic into rewriting logic, in Proc. WADT’97, Lect. Notes in Comput. Sci. 1376 (1998), pp. 62–91.
J. Meseguer, P. O¨ lveczky, and M.-O. Stehr. Rewriting logic as a unifying framework for Petri nets, in Advances in Petri Nets: Unifying Petri Nets, Lect. Notes in Comput. Sci. 2128, Springer Verlag, 2001. pp. 250–303.
G. Plotkin. A structural approach to operational semantics, Technical Report DAIMI FN-19, Aarhus University, Computer Science Department (1981).
R. Street. Higher categories, strings, cubes and simplex equations, Applied Categorical Structures 3 (1995), pp. 29–77.
R. Street. Categorical structures, in: M. Hazewinkel, editor, Handbook of Algebra, Elsevier Science, 1996. pp. 529–577.

Monoidal Double Categories
A double category is an internal category in Cat, the category of categories (as objects) and functors (as arrows). More na¨ıvely, they can be defined as below:
Definition A.1 A double category consists of a collection a, b, c, ... of objects, a collection h, g, f , ... of horizontal arrows, a collection v, u, w,... of vertical arrows and a collection , , , ... of cells.
Objects and horizontal arrows form the horizontal 1-category with identity a for each object a, and composition ; . Similarly, objects and vertical arrows form the vertical 1-category, with identity a for each object a, and composition ; .
Cells are assigned horizontal source and target (which are vertical arrows) and vertical source and target (which are horizontal arrows); furthermore sources and targets must be compatible, in the sense that they must form a square-shaped dia-
gram like the one below, for which we use the notation : h	v	g.
u
a 	h	z, b

v
c,²
	u
g	z, d,²


Cells can be composed both horizontally (∗) and vertically (·) as follows: if

: h	v
g, 	u	z
v	v;z

−→	: f −→ k, and : g −→ p, then  ∗ : h; f −→ g; k, and  · : h −→ p.
u	w	x	w	u;x

Moreover, given a fourth cell : k	x
y
q, the following exchange law holds:

( · ) ∗ ( · ) = ( ∗ ) · ( ∗ )
Under these rules, cells form both a horizontal category and a vertical category, with

identities 1v
−v c and 1h : h a v	b
h, respectively. Given 1h : h a
b
h and 1g : g  b
c

g, the equation 1h ∗ 1g = 1h;g must hold (and similarly for vertical composition of horizontal identities).
Furthermore, horizontal and vertical identities of identities coincide, i.e., 1a =
1a and are denoted just by a (analogously, 1h and 1v are just denoted by h and v).
A double functor G : D1 → D2 is a 4-tuple of functions (one for objects, one for horizontal arrows, one for vertical arrows, and one for cells), preserving identities and compositions of all kinds. We let DCat be the category of double categories (as objects) and double functors (as arrows).
Definition A.2 A monoidal double category is a double category D equipped with a double functor ⊗: D × D → D (the tensor product) and with an object e (the unit) such that: (1) (⊗ × 1D); ⊗ = (1D × ⊗); ⊗, and (2) (e × 1D); ⊗ = (1D × e); ⊗ = 1D.
A monoidal double category can be equivalently defined either as an internal category in MCat, the category of monoidal categories (as objects) and monoidal functors (as arrows), or as an internal monoid in DCat (see [15]).
A monoidal double functor is a double functor that (strictly) preserves tensor product and unit. The category of monoidal double categories (as objects) and monoidal double functors (as arrows) is called DMCat.

Categories and Constructions
For the reader’s convenience, in this Appendix we summarize in two tables the relevant categories and constructions between them that are discussed in the paper. We recall that the notion of adjunction is an elegant categorical tool for estab- lishing a correspondence between categories. There are several equivalent defini- tions of adjunction. Probably, the more “constructive” presentation consists of the scenario with two categories A and B and a functor F : A → B. Then, given an object b ∈ B we would like to find the object a ∈ A that “better approximates” b
via F , where:
approximation means the existence of a morphism f from F (a) to b in B;
best approximation means that any other approximation f j: F (aj) → b via an object aj ∈ A can be expressed in terms of f and (the image of) a uniquely de- termined morphism from aj to a (the so-called universal property, as formalized below).


F (G )  b	z, b	B

A	Gb
¸O
g^
¸O
F (g^)
yyyy˛,
yyy

yy g
a	F (a)
Figure B.1. The left adjoint F .


When best approximations exist for all objects of B, then they can be used to rep- resent the relevant structure of B inside A itself (from the point of view of F ).

Definition B.1 Let A and B be two categories and let F : A → B be a functor. We say that F is a left adjoint if for each object b ∈ B there exist an object Gb ∈ A and an arrow b: F (Gb) → b ∈ B, such that for any object a ∈ A and for any arrow g: F (a) → b ∈ B, there is a unique arrow g: a → Gb ∈ A, such that g = F (g); b (see Figure B.1).

A consequence of this fact is the existence of a backward functor G : B → A that maps each object b into its best approximation Gb. To see this point, note that given an arrow h: b → bj ∈ B, then the composite arrow b; h: F (Gb) → bj factorizes through bj via the image of a unique arrow f : Gb → Gbj ∈ A (by definition of adjoint f = b; h). Hence the functor G can be defined by letting G (h) = f .
The functor G is called the right adjoint of F , and we write F E G . The collection  = {b}b∈B is called the counit of the adjunction and defines a natu- ral transformation from G ; F to 1B. Dually, it is possible to define a collection
of “least upper” approximations  = {a: a → G (F (a))}a∈A, where a = i^dF(a),
which defines a natural transformation from 1A to F ; G (called unit).
An important property of adjunctions is the preservation of universal construc- tions: left adjoints preserve colimits, and right adjoints preserve limits. Since (co)limits can be seen as the categorical way of expressing operations, adjunctions guarantee to some extent a “compositional” interpretation for such operations.
The typical situation involves a category B that has more structure than A, and a forgetful functor G that projects B to A, deleting the extra structure. If G has left adjoint F , then F defines the best way of adding that extra structure to A.
Reflection and coreflection are two particularly kinds of adjunction, where, re- spectively, the counit and the unit define natural isomorphisms, yielding optimal approximations. When the unit is a natural isomorphism, then A can be seen just as subcategory of B, with the left adjoint F being the inclusion functor. Thus, core- flection is the ideal situation from the semantics point of view. In fact, the typical situation involves a category of operational models B that contains a subcategory of abstract models A, with G (b) being the abstraction of b. Then, the universal property of coreflections means that there is a natural isomorphisms between the observations of any concrete model b and of its abstract counterpart G (b), i.e. that b is the same as G (b) when observed from the abstract point of view defined by A.



