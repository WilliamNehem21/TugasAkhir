Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 351 (2020) 3–23
www.elsevier.com/locate/entcs


EVL: A Typed Higher-order Functional Language for Events
Sandra Alves1
DCC-FCUP & CRACS
University of Porto, Porto, Portugal
Maribel Fernández2
Dept. of Informatics
King’s College London, London WC2B 4BG, U.K.
Miguel Ramos3
DCC-FCUP & CRACS
University of Porto, Porto, Portugal

Abstract
We define EVL, a minimal higher-order functional language for dealing with generic events. The notion of generic event extends the well-known notion of event traditionally used in a variety of areas, such as database management, concurrency, reactive systems and cybersecurity. Generic events were introduced in the context of a metamodel to deal with obligations in access control systems. Event specifications are represented as records and we use polymorphic record types to type events in our language. We show how the higher-order capabilities of EVL can be used in the context of Complex Event Processing (CEP), to define higher-order parameterised functions that deal with the usual CEP techniques.
Keywords: events, access control, obligations, record types.


Introduction
In today’s complex systems, where information is constantly being generated, there is a pressing need for efficiently processing data, and in particular data related with actions taking place in a system. Occurrences of actions, or happenings, are known as events, and technology for processing event streams, referred to as Complex Event

1 Email: sandra@fc.up.pt
2 Email: maribel.fernandez@kcl.ac.uk
3 Email: jmiguelsramos@gmail.com

https://doi.org/10.1016/j.entcs.2020.08.002
1571-0661/© 2020 The Author(s). Published by Elsevier B.V.
This is an open access article under the CC BY license (http://creativecommons.org/licenses/by/4.0/).

Processing (CEP), has been around for decades [6,23,15]. Most of the CEP systems focus on real-life application therefore investing in issues such as scalability, fault tolerance, distribution, amongst others, but often lacking a formal semantics, making them difficult to understand, extend or generalize.
In the context of security, and in particular when modeling access control, it is often the case that granting or denying access to certain resources depends on the occurrence of a particular event [7,21,8]. This is even more crucial in access control systems dealing with obligations, where the status of a particular obligations is usu- ally defined in terms of event occurrences in the system, and several models that deal with obligations have to deal in some way with the notion of event. The Category- Based metatamodel for Access Control and Obligations (CBACO [2]), defines an axiomatisation of the notion of obligation based on generic relations to type events and extract event intervals. A key notion in that model is to distinguish between event schemes, which provide a general description of the kind of events that can occur in a particular system, and specific events, which describe actual events that have occurred. Note that events can take various forms, depending on the system that is being considered (for example, messages exchanged over a network, actions performed by users of the system, occurrences of physical phenomena such as a disk error or a fire alarm, etc). To deal with event classification in a uniform way, Alves et. al. [1] defined a general term-based language for events. In this language, events were presented as typed-terms, built from a user-defined signature, that is, a partic- ular set of typed function symbols that are specific to the system modelled. With this approach it is possible to define general functions to implement event typing and to compute event intervals, without needing to know the exact type of events. In that context, a compound event [1] links a set of events that can occur sep- arately in the history, but should be identified as a single event occurrence. For simplicity, in [1] compound events were assumed to appear as a single event in his- tory, leaving a more detailed and realistic treatment of compound events for future work. This notion of compound or composite event is also a key feature in CEP systems, which put great emphasis on the ability to detect complex patterns of
incoming streams of events and establish sequencing and ordering relations.
Types were used in [1] not only to ensure that terms representing events respect the type signature specific to the system under study, but also to formally define the notion of event instantiation, associating specific events to generic events through an implicit notion of subtyping, inspired by Ohori’s system of polymorphic record types [24]. Because of the implicit subtyping rule for typing records, the system defined in [1] allowed for type-checking of event-specification, but not for dealing with most general types for event specifications.
In this paper we take a step further and define EVL, a higher-order polymorphic typed language, designed to facilitate the specification and processing of events. Our language is both a restriction and an extension of Ohori’s polymorphic record calculus [24], and although our type system is very much based on that system, it is not meant to be a general language, but rather a language purposely designed for dealing with events. Languages traditionally used in event processing systems

are usually derived from relational languages, in particular, relational algebra and SQL, extended with additional ad-hoc operators to better support information flow or imperative programming. This paper explores the potential of the functional paradigm in this context, both at the level of the type-system, as well as exploring the higher-order capabilities of the language. The main contributions of this paper are:
The design of EVL: a higher-order typed polymorphic record calculus for event processing. Our goal is to have a minimal language, but which is expressive enough to specify and manipulate events.
A sound and complete type inference algorithm for EVL, defined as both an ex- tension and a restriction of the ML-style record calculus in [24].
A comprehensive study of the EVL higher-order/functional capabilities and its application in the context of CEP.

Overview
In Section 2 we define the EVL language and its set of types. In Section 3 we define a type system for EVL and in Section 4 we present a type inference algorithm, which is proved to be sound and complete. In Section 5 we discuss CEP and explore EVL’s capabilities in this context. We discuss related work in Section 6 and we finally conclude and discuss further work in Section 7.
The EVL typed language
In this section we introduce EVL, a minimalistic typed language to specify events. EVL is an extension of the λ-calculus that includes records, a flexible data structure that is used here to deal with event specifications as defined in [1]. More precisely, an event specification is a labelled structure (or record) of the form {l1 = v1,..., ln = vn}, representing a set of labels l1,..., ln with associated values v1,..., vn. We assume some familiarity with the λ-calculus (see [5] for a detailed reference).
Terms
We start by formally defining the set of EVL terms. In the following, let x, y, z, . . . range over a countable set of variables and l, l1,... range over a countable set L of labels.
Definition 2.1 The set of EVL terms is given by the following grammar:
M ::= x | MM | λx.M | if M then M else M
let x = M in M | letEv x = M in M
{l = M,...,l = M}| M.l | modify(M, l, M )
Notation: We will use the notation let x x1 ... xn = M and letEv x x1 ... xn =
M for let x = λx1 ... λxn.M and letEv x = λx1 ... λxn.M , respectively. As an

abuse of notation, in examples, we will use more meaningful names for functions, labels and events. Furthermore, event names will always start with a capital letter, to help distinguish them from functions.
We choose not to add other potentially useful constructors to the language, for instance pairs and projections, since we are aiming at a minimal language. Never- theless, we can easily encode pairs (M1, M2) and projections π1M and π2M in our language by means of records of the form {fst = M1, snd = M2} and M.fst, M.snd, respectively. This can trivially be extended to tuples in general, and we will often use this notation when writing examples.
Example 2.2 In this simple example, FireDanger reports the fire danger level of a particular location.
let Ev FireDanger = λ l λd . { location = l , fire_danger = d} in Fire Danger " Porto " " low "

To make our examples more readable, we will also use the following terms, ab- breviating list construction:
n i l = {empty = true }

cons x  l i s t = {empty = f a l s e ,  head = x ,  t a i l = l i s t } .

Note that, much like what happens with tuples, the type of a particular list in this notation will be closely related to the size of the list in question. A more realistic approach is to add lists and list-types as primitive notions in the language, but, as we mentioned before, we are focusing on a minimal language. Furthermore, we will often use constants (numbers, booleans, strings, etc) and operators (arithmetic, boolean, etc) in our examples. However, following the minimalistic approach, we do not add constants/operators to the grammar and instead use free variables to represent them. Again, in a more general approach we could extend the grammar with other data structures and operators, for numbers, booleans, lists, etc.
Example 2.3 Consider the following example illustrating the definition of a generic event FireDanger and of a function check that determines if there is the danger of a fire erupting in a particular location, using the weather information associated with that location. Function check creates an appropriate instance of FireDanger to report the appropriate fire danger level.
let Ev Fire Danger  l d = { location = l ,  fire_danger = d} in l e t check x = i f  ( x . temperature > 29 and x . wind > 32
and x . humidity < 20 and x . p recipitation < 50 ) then Fire Danger x . location "high" 
e l s e Fire Danger x . location " low " i n check { temperature = 10 , wind = 20 , humidity = 30 ,
pre cipi tati on = 10 , location = " Porto "}


Types
We now define the set of types, and a typing system for the EVL language. We use record types to type labelled structures following Ohori’s ML-system with poly-

morphic record types [24]. This extends the standard type system for parametric polymorphism by Damas and Milner [13]. In Ohori’s system, polymorphic types are defined by type schemes of the form ∀α :: κ.σ, where the type variable α is restricted to a set of types κ called a kind. We assume a finite set B of constant types and a countable set V of type variables, and we will use b, b1,... , α, α1,... and κ, κ1,... to denote constant types, type variables and kinds, respectively. The set B of constant types will always contain the type bool.
Definition 2.4 The set of types σ and kinds κ are specified by the following gram- mar.
σ ::= τ | ∀α :: κ.σ
τ ::= α | b | τ → τ | {l : τ, ...,l : τ} ρ ::= α | b | τ → ρ
γ ::= τ → {l : ρ,...,l : ρ}| {l : ρ,...,l : ρ} κ ::= U | {{l : τ, ...,l : τ }}
Following Damas and Milner’s type system, we divide the set of types into monotypes (ranged over by τ ) and polytypes (of the form ∀α :: κ.σ). More precisely, σ represents all types and τ represents all monotypes. We denote by ρ (included in τ ) the type of event fields, and by γ (also included in τ ) the type of event definitions. This distinction is necessary to adequately type event definitions and its purpose will become clear in the definition of the typing system. We use U for the kind representing every possible type, and the kind {{l1 : τ1,..., ln : τn}} represents record types that contain, at least, the fields l1,..., ln, with types τ1,..., τn, respectively.
We do not allow nested events, and to that end we clearly separate types for event definitions, denoted by γ, and which are a subset of the general types denoted by τ . However, we do allow for nested records of general type. The following is an example of a term that is typed with a nested record type:
{ empty = f a l s e , head = 1 , t a i l = { empty = f a l s e , head = 2 , t a i l = { empty = t r u e } } } .
Let F range over functions from a finite set of labels to types. We write {F} and
{{F }} to denote the record type identified by F and the record kind identified by F , respectively. For two functions F1 and F2 we write F1 ± F2 for the function F such that dom(F ) = dom(F1) ∪ dom(F2) and such that for l ∈ dom(F ), F (l) = F1(l) if l ∈ dom(F1); otherwise F (l)= F2(l).
Notation: Following the notation for pairs introduced above, we write (σ1 ×σ2)
for the product type corresponding to {fst : σ1, snd : σ2}.
A typing environment Γ is a set of statements x : σ where all subjects x are distinct. We write dom(Γ) to denote the domain of a typing environment Γ= {x1 : σ1,..., xn : σn}, which is the set {x1,..., xn}. The type of a variable xi ∈ dom(Γ) is Γ(xi) = σi, and we write Γx to denote Γ \ {x : Γ(x)}. A kinding environment K is a set of statements α :: κ. Similarly, the domain of a kinding environment K = {α1 :: κ1,..., αn :: κn}, denoted dom(K), is the set {α1,..., αn} and the kind of a type αi ∈ dom(K) is K(αi)= κi. A type variable α occurring in a type/kind

is bound, if it occurs under the scope of a ∀-quantifier on α, otherwise it is free. We denote by FTV(σ) (FTV(κ)) the set of free variables of σ (respectively, κ). We say that a type σ and a kind κ are well-formed under a kinding environment K if FTV(σ) ⊆ dom(K) and FTV(κ) ⊆ dom(K), respectively. A typing environment Γ is well-formed under a kinding environment K, if ∀x ∈ dom(Γ), Γ(x) is well-formed under K. A kinding environment K is well-formed, if ∀α ∈ dom(K), FTV(K(α)) ⊆ dom(K). This reflects the fact that every free type variable in an expression has to be restricted by a kind in the kinding environment. Therefore, every type variable is either restricted by the kind in the type scheme or by a kind in the kinding environment.
Furthermore, we consider the set of essentially free type variables of a type σ under a kinding environment K (denoted as EFTV(K, σ)) as the smallest set such that, FTV(σ) ⊆ EFTV(K, σ) and if α ∈ EFTV(K, σ), then FTV(K(α)) ⊆ EFTV(K, σ). This reflects the fact that a type variable α is essentially free in σ under a kinding environment K, if α is free in σ or in a restriction in K.
Definition 2.5 Let τ be a monotype, κ a kind, and K a kinding environment. Then we say that τ has kind κ under K (written K H τ :: κ), if τ :: κ can be obtain by applying the following rules:
K H τ :: U for all τ well-formed under K
K H α :: {{l1 : τ1,..., ln : τn}} if K(α)= {{l1 : τ1,..., ln : τn,... }}
K H {l1 : τ1,..., ln : τn,... } :: {{l1 : τ1,..., ln : τn}}
if {l1 : τ1,..., ln : τn,... } is well-formed under K
Note that, if K H σ :: κ, then σ and κ are well-formed under K.
Example 2.6 Let τ = α1 → {l2 : int, l3 : (α2 × α3)}. Then, τ is well-formed under K1 = {α1 :: U, α2 :: U, α3 :: U}, because FTV(τ ) ⊆ dom(K1), but not under K2 = {α1 :: U, α2 :: U}, because α3 /∈ dom(K2), and, therefore, FTV(τ ) /⊆ dom(K2). Because τ is well-formed under K1, we can write K1 H τ :: U .

Type assignment
We now define how types are assigned to EVL terms. Because we are dealing with polymorphic type schemes, we need to define the notion of generic instance for which we first need to discuss well-formed substitutions.
A substitution S = [σ1/α1,..., σn/αn] is well-formed under a kinding environ- ment K, if for all α ∈ dom(S), S(α) is well-formed under K. This reflects the fact that applying a substitution to a type that is well-formed under a kinding en- vironment K, should result in a type that is also well-formed under K. A kinded substitution is a pair (K, S) of a kind assignment K and a substitution S that is well-formed under K. This reflects the fact that a substitution S should only be applied to a type that is well-formed under S, such that the resulting type is kinded by K.

Example 3.1 Let S = [α2/α1] be a substitution. Then dom(S) = {α1}, S(α1) = α2, and FTV(α2) = {α2}. For the kinding environment K1 = {α2 :: κ}, we have that S is well-formed under K1, since α2 ∈ dom(K1). On the other hand, for the kinding environment K2 = {α3 :: κ}, we have that S is not well-formed under K2, since α2 /∈ dom(K2).
Definition 3.2 We say that a kinded substitution (K1, S) respects a kinding envi- ronment K2, if ∀α ∈ dom(K2), K1 H S(α) :: S(K2(α)).
Example 3.3 Let K1 = {α1 :: {{l1 : α2}}, α2 :: U} and S = [{l1 : int}/α1]. Then, the restricted substitution (K1, S) respects K2 = {α1 :: {{l1 : int}}}, because for dom(K2)= {α1}, we have:
K1 H S(α1) :: S(K2(α1))
K1 H S(α1) :: S({{l1 : int}})
K1 H S(α1) :: {{l1 : S(int)}}
K1 H {l1 : int} :: {{l1 : int}}
Lemma 3.4 If FTV(σ) ⊆ dom(K) and (K1, S) respects K, then FTV(S(σ)) ⊆
dom(K1).
Proof. If (K1, S) respects K, then we know that ∀α ∈ dom(K), K1 H S(α) :: S(K(α)). This means that, if FTV(σ) ⊆ dom(K), then ∀αj ∈ FTV(σ), K1 H S(αj) :: S(K(αj)). Consequently, both S(αj) and S(K(αj)) are well formed under K1, which means that FTV(S(αj)) ⊆ dom(K1) and FTV(S(K(αj))) ⊆ dom(K1). Therefore, it is now easy to see that FTV(S(σ)) ⊆ dom(K1).
2
Lemma 3.5 If K H σ :: κ, and a kinded substitution (K1, S) respects K, then
K1 H S(σ) :: S(κ).
Proof. The proof follows the definition of K H σ :: κ	2
Definition 3.6 Let σ1 be a well-formed type under a kinding environment K. Then, σ2 is a generic instance of σ1 under K (denoted as K H σ1 ≥ σ2), if σ1 = ∀α1 :: κ1 ··· ∀αn :: κ1 .τ1, σ2 = ∀β1 :: κ2 ··· ∀βm :: κ2 .τ2, and there exists a substitution
1	n	1	m
S such that dom(S) = {α1,..., αn}, (K ∪ {β1 :: κ2,..., βm :: κ2 }, S) respects
1	m
K ∪ {α1 :: κ1,..., αn :: κ1 }, and τ2 = S(τ1).
1	n
Definition 3.7 Let Γ be a typing environment and τ be a type, both well-formed under a kinding environment K. The closure of τ under Γ and K (denoted as Cls(K, Γ,τ )) is a pair (Kj, ∀α1 :: κ1 ··· ∀αn :: κn.τ ) such that Kj ∪ {α1 :: κ1,... αn :: κn} = K and {α1,..., αn} = EFTV(K, τ ) \ EFTV(K, Γ).
Example 3.8 Let K = {α2 :: U, α3 :: U, α4 :: U, α1 :: {{l1 : α2}}}, Γ =
{x : α1}, and τ  = {l1 : α2, l4 : bool} → {l2 : int, l3 : (α3 × α4)}.	Then
Cls(K, Γ,τ ) = ({α2 :: U, α1 :: {{l1 : α2}}}, ∀α3 :: U.∀α4 :: U.{l1 : α2, l4 :
bool} → {l2 : int, l3 : (α3 × α4)}), because K = {α2 :: U, α1 :: {{l1 : α2}}} ∪

{α3 :: U, α4 :: U}, EFTV(K, τ ) = {α2, α3, α4, α1}, EFTV(K, Γ) = {α1, α2}, and
EFTV(K, τ ) \ EFTV(K, Γ) = {α2, α3, α4, α1}\ {α1, α2} = {α3, α4}.
The type assignment system for EVL is given in Figure 1, and can be seen as both a restriction and an extension of the Ohori type system for record types. Unlike Ohori, we do not deal with variant types in this system, but we have additional language constructors, like conditionals and explicit event definition. We use K, Γ ▶ M : σ to denote that the EVL term M has type σ given the type and kind environments Γ and K, respectively.
K H Γ(x) ≥ τ , Γ is well-formed under K (Var)
K, Γ ▶ x : τ

 K, Γ ▶ M1 : τ1 → τ2	K, Γ ▶ M2 : τ1  (App)
K, Γ ▶ M1 M2 : τ2

K, Γx ∪ {x : τ1} ▶ M : τ2 (Abs)
K, Γx ▶ λx.M : τ1 → τ2


K′, Γx ▶ M1 : τ′	Cls(K′, Γx,τ′)= (K, σ)	K, Γx ∪ {x : σ} ▶ M2 : τ K, Γx ▶ let x = M1 in M2 : τ

K′, Γx ▶ M1 : γ		Cls(K′, Γx,γ)= (K, σ)	K, Γx ∪ {x : σ} ▶ M2 : τ K, Γx ▶ letEv x = M1 in M2 : τ


	K, Γ ▶ Mi : τi, 1 ≤ i ≤ n	 (Rec)
K, Γ ▶ {l1 = M1,..., ln = Mn} : {l1 : τ1,..., ln : τn},n ≥ 1

(Let)



(LetEv)



K, Γ ▶ M : τ′	K H τ′ :: {{l : τ }} K, Γ ▶ M.l : τ

(Sel)



K, Γ ▶ M1 : τ	K, Γ ▶ M2 : τ′	K H τ :: {{l : τ′}}
K, Γ ▶ modify(M1, l, M2): τ

(Modif)



 K, Γ ▶ M1 : bool	K, Γ ▶ M2 : τ	K, Γ ▶ M3 : τ  (Cond)
K, Γ ▶ if M1 then M2 else M3 : τ

Fig. 1. Type assignment system for EVL


Example 3.9 Let M = {location = l, fire_danger = d}, τ1 = {location : α1,fire_danger : α2}, τ2 = ∀α1 :: U.∀α2 :: U.α1 → α2 → τ1, τ3 = {location : ltype,fire_danger : f dtype}, τ4 = ltype → fdtype → τ3, and Γ = {“Porto” : ltype, “low”: fdtype}. A type derivation for M is given in Figure 2.

Lemma 3.10 If K, Γ ▶ M : σ and (K1, S) respects K, then K1, S(Γ) ▶ M : S(σ).
Proof. By induction on K, Γ ▶ M : σ.	2

{α1 :: U, α2 :: U}, {l : α1 ,d : α2 } ∪ Γ ▶ l : α1
(Var)
(Var)
{α1 :: U, α2 :: U}, {l : α1 ,d : α2 } ∪ Γ ▶ d : α2  (Rec)

{α1 :: U, α2 :: U}, {l : α1 ,d : α2 } ∪ Γ ▶ M : τ1	(Abs)
{α1 :: U, α2 :: U}, {l : α1 } ∪ Γ ▶ λd.M : α2 → τ1
Φ1 = 	 (Abs)
{α1 :: U, α2 :: U}, Γ ▶ λl.λd.M : α1 → α2 → τ1

Φ2 = Cls({α1 :: U, α2 :: U}, Γ, α1 → α2 → τ1)= ({}, τ2)



{}, {FireDanger : τ2 } ∪ Γ ▶ FireDanger : τ4
(Var)

{}, {FireDanger : τ2 } ∪ Γ ▶ “Porto”: ltype
(Var)

Φ3 = 	 (App)
{}, {FireDanger : τ2 } ∪ Γ ▶ FireDanger “Porto”: fdtype → τ3



Φ4 =
Φ3	{}, {FireDanger : τ2} ∪ Γ ▶ “low”: fdtype
(Var)
(App)

{}, {FireDanger : τ2} ∪ Γ ▶ FireDanger “Porto” “low”: τ3


Φ1	Φ2	Φ4	(LetEv)
{}, Γ ▶ letEv FireDanger = λl.λd.M in FireDanger “Porto” “low”: τ3

Fig. 2. Type derivation for M = letEv FireDanger = λl.λd.M in FireDanger “Porto” “low”
A type inference algorithm for EVL
We now adapt Ohori’s WK(K, Γ,M ) inference algorithm to our language. It uses a refinement of Robinson’s unification algorithm [27] that considers kind constraints on type variables. We start by discussing kinded unification for EVL types.

Kinded unification
A kinded set of equations is a pair (K, E), where K is a kinding environment and E is a set of pairs of types (τ1, τ2) that are well-formed under K. A kinded substitution (K, S) is a unifier of a kinded set of equations (K, E), if every type that appears in E respects K, and ∀(τ1, τ2) ∈ E, S(τ1)= S(τ2) (S satisfies E). A kinded substitution (K1, S1) is the most general unifier of (K, E) if it is a unifier of (K, E) and if for any other unifier (K2, S2) of (K, E) there is some substitution S3 such that (K2, S3) respects K1 and S2 = S3 ◦ S1.
The kinded unification algorithm, U(E, K), is defined by the transformation rules in Figure 3. Each rule is of the form (E1, K1, S1) ⇒ (E2, K2, S2), where E1, E2 are sets of pairs of types, K1, K2 are kinding environments, and S1, S2 are substitutions. After a transformation step, E2 keeps the set of pairs of types to be unified, K2 specifies kind constraints to be verified, and S2 is the substitution resulting from unifying the pairs of types that have been removed from E. Given a kinded set of equations (K1, E1) the algorithm U(E1, K1) proceeds by applying the transformation rules to (E1, K1, ∅), until no more rules can be applied, resulting in a triple (E, K, S). If E = ∅ then it returns the pair (K, S), otherwise it reports failure.
Example 4.1 Let α1 and α2 be two type variables and K = {α1 :: {{location : α3}},

(E ∪ {(τ, τ )}, K,S) ⇒ (E, K, S)

(E ∪ {(α, τ )},K ∪ {(α, U )},S) ⇒ ([τ/α]E, [τ/α]K, [τ/α]S ∪ {(α, τ )})

(E ∪ {(τ, α)},K ∪ {(α, U )},S) ⇒ ([τ/α]E, [τ/α]K, [τ/α]S ∪ {(α, τ )})

(E ∪ {(α1, α2)},K ∪ {(α1, {{F1}}), (α2, {{F2}})},S) ⇒ ([α2/α1](E ∪ {(F1(l), F2(l)) | l ∈ dom(F1) ∩ dom(F2)}),
[α2/α1](K) ∪ {(α2, [α2/α1]({{F1 ± F2}}))}, [α2/α1](S) ∪ {(α1, α2)})

(E ∪ {(α, {F2})},K ∪ {(α, {{F1}})},S) ⇒ ([{F2}/α](E ∪ {(F1(l), F2(l)) | l ∈ dom(F1)}),
[{F2}/α](K),
[{F2}/α](S) ∪ {(α, {F2)})})
if dom(F1) ⊆ dom(F2) and α /∈ FTV({F2})

(E ∪ {({F2}, α)},K ∪ {(α, {{F1}})},S) ⇒ ([{F2}/α](E ∪ {(F1(l), F2(l)) | l ∈ dom(F1)}),
[{F2}/α](K),
[{F2}/α](S) ∪ {(α, {F2)})})
if dom(F1) ⊆ dom(F2) and α /∈ FTV({F2})

(E ∪ {({F1}, {F2})}, K,S) ⇒ (E ∪ {(F1(l), F2(l)) | l ∈ dom(F1)}, K,S)
if dom(F1)= dom(F2)

(E ∪ {(τ 1 → τ 2,τ 1 → τ 2}, K,S) ⇒ (E ∪ {(τ 1,τ 1), (τ 2,τ 2)}, K,S)
1	1  2	2	1  2	1  2

Fig. 3. Kinded Unification



α2 :: {{f ire_danger : fdtype, location : ltype}}, α3 :: U}.
({(α1, α2)}, {(α1, {{location : α3}}), (α2, {{fire_danger : fdtype, location : ltype}}), (α3, U )}, {})
⇒ ({(α3, ltype)}, {(α2, {{fire_danger : fdtype, location : α3}}), (α3, U )}, {(α1, α2)})
⇒ ({}, {(α2, {{fire_danger : fdtype, location : ltype}})}, {(α1, α2), (α3, ltype)})

The most general unifier between α1 and α2 is the kinded substitution ({α2 ::
{{f ire_danger : fdtype, location : ltype}}}, [α2/α1, ltype/α3]). Following Ohori’s no- tation, in the kinded unification algorithm we use pairs in the representation of sub- stitutions and kind assignments. Also, note that the unification algorithm in [24] has a kind assignment as an extra parameter, which is used to record the solved kind constraints encountered through the unification process. However, we choose to omit this parameter because its information is only used in the proofs in [24] but not in the unification process itself.
In [24], the correctness and completeness of the kinded unification algorithm was proved, in the sense that it takes any kinded set of equations and computes its most general unifier if one exists and reports failure otherwise.
Type inference
The type inference algorithm, WK(K, Γ,M ), is defined in Figure 4. Given a kinding environment K, a typing environment Γ, and an EVL term M , then WK(K1, Γ,M )= 

(Kj, S, σ), such that σ is the type of M under the kinding environment Kj and typing environment S(Γ). It is implicitly assumed that the inference algorithm fails if unification or any of the recursive calls on subterms fails.

WK(K, Γ, x) = if x ∈ dom(Γ) then fail
else let ∀α1 :: κ1 ··· ∀αn :: κn.τ = Γ(x),
S = [β1/α1,..., βn/αn] (β1,..., βn are fresh) in (K ∪ {β1 :: S(κ1),..., βn :: S(κn)}, id,S(τ ))
WK(K, Γ, M1 M2) = let (K1, S1, τ1)= WK(K, Γ, M1)
(K2, S2, τ2)= WK(K1, S1(Γ), M2)
(K3, S3)= U(K2, {(S2(τ1), τ2 → α)}) (α is fresh) in (K3, S3 ◦ S2 ◦ S1, S3(α))
WK(K, Γ, λx.M ) = let (K1, S1,τ )= WK(K ∪ {α :: U}, Γ ∪ {x : α},M ) (α fresh) in (K1, S1, S1(α) → τ )
WK(K, Γ, let x = M1 in M2) = let (K1, S1, τ1)= WK(K, Γ, M1)
(K′ , σ)= Cls(K1, S1(Γ), τ1)
(K2, S2, τ2)= WK(K′ , S1(Γ) ∪ {x : σ}, M2)
in (K2, S2 ◦ S1, τ2)
WK(K, Γ, letEv x = M1 in M2) = let (K1, S1,γ)= WK(K, Γ, M1)
(K′ , σ)= Cls(K1, S1(Γ),γ)
(K2, S2, τ2)= WK(K′ , S1(Γ) ∪ {x : σ}, M2)
in (K2, S2 ◦ S1, τ2)
WK(K, Γ, {l1 = M1,..., ln = Mn}) = let (K1, S1, τ1)= WK(K, Γ, M1)
(Ki, Si, τi)= WK(Ki−1, Si−1 ◦ ··· ◦ S1(Γ), Mi) (2 ≤ i ≤ n)
in (Kn, Sn ◦ ··· ◦ S2 ◦ S1,
{l1 : Sn ◦ ··· ◦ S2(τ1),..., li : Sn ◦ ··· ◦ Si+1(τi),..., ln : τn})
WK(K, Γ,M.l) = let (K1, S1, τ1)= WK(K, Γ,M )
(K2, S2)= U(K1 ∪ {α1 :: U, α2 :: {{l : α1}}}, {(α2, τ1)}) (α1, α2 fresh) in (K2, S2 ◦ S1, S2(α1))
WK(K, Γ, modify(M1, l, M2)) = let (K1, S1, τ1)= WK(K, Γ, M1)
(K2, S2, τ2)= WK(K1, S1(Γ), M2)
(K3, S3)= U(K2 ∪ {α1 :: U, α2 :: {{l : α1}}}, {(α1, τ2), (α2, S2(τ1))})
(α1, α2 are fresh)
in (K3, S3 ◦ S2 ◦ S1, S3(α2))
WK(K, Γ, if M1 then M2 else M3) = let (K1, S1, τ1)= WK(K, Γ, M1)
(K2, S2)= U(K1, {(τ1, bool)})
(K3, S3, τ2)= WK(K2, S2 ◦ S1(Γ), M2)
(K4, S4, τ3)= WK(K3, S3 ◦ S2 ◦ S1(Γ), M3)
(K5, S5)= U(K4, {(S4(τ2), τ3)})
in (K5, S5 ◦ S4 ◦ S3 ◦ S2 ◦ S1, S5 ◦ S4(τ2))

Fig. 4. Type inference algorithm



Example 4.2 Following Example 3.9, we consider M  =  {location  = l, fire_danger = d}, τ1 = {location : α1,fire_danger : α2}, τ2 = ∀α1 :: U.∀α2 :: U.α1 → α2 → τ1, τ3 = {location : ltype,fire_danger : f dtype}, and τ4 = ltype → fdtype → τ3, we further consider τ5 = {location : α3,fire_danger : α4}, τ6 = ∀α3 :: U.∀α4 :: U.α3 → α4 → τ5, τ7 = {location : α5,fire_danger : α6}, S1 = [ltype/α5] ◦ [α5/α3, α6/α4], and S2 = [fdtype/α6] ◦ S1 ◦ [α4/α2] ◦ [α3/α1]. A run of the algorithm for letEv FireDanger = λl.λd.M in FireDanger “Porto” “low”

is given in Figure 5.

WK({}, {}, letEv FireDanger = λl.λd.M in FireDanger “Porto” “low”) = ({}, S2, τ3)
WK({}, {}, λl.λd.M )= ({α3 :: C, α4 :: C}, [α4/α2] ○ [α3/α1], α3 → α4 → τ5)
WK({α1 :: C}, {l : α1}, λd.M )= ({α3 :: C, α4 :: C}, [α4/α2] ○ [α3/α1], α4 → τ5)
WK({α1 :: C, α2 :: C}, {l : α1,d : α2},M )= ({α3 :: C, α4 :: C}, [α4/α2] ○ [α3/α1], τ5)
WK({α1 :: C, α2 :: C}, {l : α1,d : α2}, l)= ({α2 :: C, α3 :: C}, [α3/α1], α3)
WK({α2 :: C, α3 :: C}, {l : α3,d : α2}, d)= (α3 :: C, α4 :: C}, [α4/α2], α4)
Cls({α3 :: C, α4 :: C}, {}, α3 → α4 → τ5)= ({}, τ6)
WK({}, {FireDanger : τ6},FireDanger “Porto” “low”) = ({}, [fdtype/α6] ○ S1, τ3)
WK({}, {FireDanger : τ6},FireDanger “Porto”) = ({}, S1, α6 → {location : ltype,fire_danger : α6})
WK({}, {FireDanger : τ6},FireDanger)= ({}, [α5/α3, α6/α4], α5 → α6 → τ7)
WK({}, {FireDanger : τ6}, “Porto”) = ({}, id, ltype)
U({}, (α5, ltype)) = ({}, [ltype/α5])
WK({}, {FireDanger : τ6}, “low”) = ({}, id, fdtype)
U({}, (α6,fdtype)) = ({}, [fdtype/α6])


Fig. 5. Type inference run for letEv FireDanger = λl.λd.M in FireDanger “Porto” “low”



Soundness and completeness of WK
In this section we establish the results from soundness and completeness of our type inference algorithm.
Theorem 4.3 If WK(K, Γ,M )= (Kj, S,τ ) then (Kj, S) respects K and there is a derivation in our type system such that Kj, S(Γ) ▶ M : τ.
Proof. The proof is by induction on the structure of M .	2
Theorem 4.4 If WK(K, Γ,M ) = fail, then there is no (K0, S0) and τ0 such that
(K0, S0) respects K and K0, S0(Γ) ▶ M : τ0.
If WK(K, Γ,M ) = (Kj, S,τ ), then if K0, S0(Γ) ▶ M : τ0 for some (K0, S0) and τ0 such that (K0, S0) respects K, then there is some Sj such that (K0, Sj) respects Kj, τ0 = Sj(τ ), and S0(Γ) = Sj ◦ S(Γ).
Proof. The proof is by induction on the structure of M .	2
EVL for Complex Event Processing
In this section we are going to study the application of EVL in the context of Complex Event Processing (CEP). See [15] for a detailed reference on the area. The area of CEP comprises a series of techniques to deal with streams of events such as event processing, detection of patterns and relationships, filtering, transformation and ab- straction, amongst others. Because EVL is a higher-order functional language, we are going to explore the higher-order capabilities, to define higher-order parameterized functions that deal with the usual CEP techniques.

Event processing
The canonical model [10,15] for event processing is based on a producer-consumer model: an event processing agent (EPA) takes events from event producers and distributes them among event consumers. This process often involves filtering or translating. Filtering may happen because not every event will be of interest or available to every consumer: in some cases access control policies might be in place that restrict what events consumers might receive. Translating events allows us to change, add or remove information from the agents based on particular consumers. The processing of events can be done in a one-event in/one-event out form, but it is also possible to have event processing agents that process a collection of events as a whole or that produce a set of events as result: for example, an incoming event may be split into multiple events, each containing a subset of the information from the original event.
EVL can be used to program event processing agents. It is able to process raw events produced by some event processing system and generate derived events as a result. These derived events can then be passed on to an event consumer.
Principal types allow us to identify event processing agents. An event processing agent is any function whose principal types is of the form ∀α1 :: κ1 ··· ∀αn :: κn.γ. In the following section we will explore the different types of event processing agents.
Types of event processing agents
Event processing agents are classified according to the actions that they perform to process incoming events:
Filter agents - Filter agents take an incoming event object and apply a test to decide whether to discard it or whether to pass it on for processing by subsequent agents. The test is usually stateless, i.e. based solely on the content of the event instance.
Transformation agents - Transformation agents modify the content of the event objects that they receive. These agents can be further classified based on the cardinality of their inputs and outputs (translate, split, aggregate or compose agents)
Pattern Detect agents - Pattern Detect agents take collections of incoming event objects and examine them to see if they can spot the occurrence of particular patterns.
We are now going to look into the different types of event processing agents in a little more depth. All of the definitions that we are going to present can be found in [15].
Definition 5.1 [Filter event processing agent] A filter agent is an event processing agent that performs filtering only, so it does not transform the input event.
Example 5.2 This example represents an event processing agent that uses a higher- order filter function filter (to be defined later) to filter events according to their location.

l e t  p x = ( x . location == " Porto ")  i n λx. ( filter  p x )

Definition 5.3 [Transformation event processing agent] A Transformation event processing agent is an event processing agent that includes a derivation step, and optionally also a filtering step.
Transformation event processing agents can be either stateless (if events are processed without taking into account preceding or following events) or stateful (if the way events are processed is influenced by preceding or following events). In the former case, events are processed individually. In the latter, the way events are processed can depend on preceding or succeeding events. Transformation events can be further classified as translate, split, aggregate or compose agents. In the following we describe some transformation events that we are going to focus on.
Definition 5.4 [Translate event processing agent] Translate event processing agents can be used to convert events from one type to another, or to add, remove, or modify the values of an event’s attributes.
At the moment EVL does not allow us to add or remove attributes. One can create new events based on attributes from incoming events as well as modify the value of existing attributes. We follow Ohori’s treatment of record types, therefore we do not consider operations that extend a record with a new field or that remove an existing field from a record. This is a limitation of our current calculus, and we intend to improve on this in the future.
Example 5.5 This example represents an event processing agent that converts the temperature field of an event from degrees Fahrenheit to degrees Celsius.
farToCel x = modify ( x ,  temperature ,  ( x . temperature − 32 )/ 1 . 8 )

Definition 5.6 [Aggregate event processing agent] Aggregate agents take a stream of incoming events and produce an output event that is a map of the incoming events.
Example 5.7 This example represents an event processing agent that receives two events, x and y, and outputs event y with its precipitation level updated with the average of the two.
avg x y = modify ( y ,  precipitation ,  ( x . p recipitation + y . precipitation )/ 2 )

Definition 5.8 [Compose event processing agent] Compose agents take two streams of incoming events and process them to produce a single output stream of events.
Example 5.9 This example represents an event processing agent that composes the partial weather information that is provided by two different sensors. One of the sensors outputs event x, which contains information about the temperature and wind velocity, and the other sensor outputs event y, which contains information about the humidity and precipitation levels. This event processing agent outputs an instance of WeatherInfo with the complete weather information.

composeInfo x y = WeatherInfo x . temperature x . wind y . humidity y . p r ecipitation 


Definition 5.10 [Pattern Detect event processing agent] A Pattern Detect event processing agent is an event processing agent that performs a pattern matching function on one or more input streams. It emits one or more derived events if it detects an occurrence of the specified pattern in the input events.
Example 5.11 The check function in Example 2.3 is an event processing agent that generates the appropriate FireDanger event by detecting its corresponding fire weather information.
check x = i f  ( x . temperature > 29 and x . wind > 32
and x . humidity < 20 and x . p r e c i pitation < 50 ) then Fire Danger x . location "high" 
e l s e Fire Danger x . location " low "


An area where pattern-detect agents are quite relevant is in publish-subscribe systems, where consumers are allowed to subscribe to selective events by specify- ing filters using a subscription language. The filters define constraints, usually in the form of name-value pairs of properties and basic comparison operators, which identify valid events. Constraints can be logically combined to form what are called complex subscription patterns [16]. CEP systems extend the functionality of tra- ditional publish-subscribe systems by increasing the expressive power of the sub- scription language to consider complex event patterns that involve the occurrence of multiple, related events [12].

A higher-order library for CEP
Since EVL is a higher-order language, we use higher-order functions that allow us to deal with a sequence of events (represented as a list of events). We now provide some of these useful higher-order functions, which are naturally implemented in a higher-order functional language.
filter is a function that filters the events in the sequence according to some filtering expression:
fi lt er p list = i f list . empty then list 
else i f ( p list . head ) then ( cons list . head ( f ilt er p list . t a i l ) ) else f i l t e r p l i s t . t a i l

transform is a function that applies a transformation to all of the events in the sequence:
trans form  f  l i s t = i f  l i s t . empty then  l i s t
e l s e ( cons ( f  l i s t . head ) ( trans form  f  l i s t . tail ) )

aggregater is a function that produces some output value by aggregating by right association the events of the sequence according to some binary aggregating function:
a g g r e g a te r  f  z  l i s t = i f  l i s t . empty then z
e l s e  f  l i s t . head ( a g g r e g a te r  f  z  l i s t . tail )

aggregatel is very similar to aggregater but it aggregates the events by left association:
aggregatel  f  z  l i s t = i f  l i s t . empty then z
e l s e  a ggregatel  f  ( f  z  l i s t . head )  l i s t . tail 

We use the function names transform and aggregateX, instead of the usual func- tional programming names map and foldX, because of the particular context of CEP.
Event types
When dealing with event processing applications, many events will have a similar structure and a similar meaning. Consider a temperature sensor: all of the events produced by it have the same kind of information, such as temperature reading, timestamp and maybe location, but with possibly different values. This means that instead of defining the structure of each event individually, we can specify the structure of an entire class of events [15]. This relationship was formally defined in [1] as that between Generic and Specific events. EVL is based on the typed language that was defined in [1], but it extends it by allowing explicit subtyping between record types according to [24].
The definition of a generic event may contain references to other events when there is a semantic relationship between them. These relationships can be separated into four types [15] that we are now going to discuss.

Membership
A generic event ge1 is said to be a member of another generic event ge2 if the instances of ge1 are included in the instances of ge2. This notion can easily be checked in EVL through the explicit subtyping relation between record types.

Generalization
The generalization relation indicates that an event is a generalization of another event. In the type theory of EVL, this relation is given by the generalization relation Cls.

Specialization
The specialization relation indicates that an event is a specialization of another event. In the type theory of EVL, this relation is given by the type instantiation relation.

Retraction
A retraction event relationship is a property of an event referencing a second event. It indicates that the second event is a logical reversal of the event type that references it. For example, an event that starts a fire alert and the event that stops it. This is a notion that is also present in access control systems with obligations. In [1], this is defined by a closing function that describes how events are linked to

subsequent events in history. That is, which are the generic events in time that are closed by a particular generic event provided that some time constraints are satisfied and following a specific strategy. These functions are assumed to be defined for each system and are used to extract intervals from a given history. One of the motivations to develop EVL was to provide a simple language to program such functions.

A comprehensive example
We now give an example that illustrates several features described in this section.
Example 5.12 Consider a sequence of events produced by sensors distributed across some number of locations. The events produced by a particular sensor con- tains information about the weather conditions at that sensor’s location. More specifically, it contains information about the temperature (in degrees Celsius), the humidity level (as a percentage), the wind speed (in km/h) and the amount of pre- cipitation (in mm), as well as information about its location. Now, consider an EPA that infers the fire danger of a particular location based on a given sequence of events produced by an arbitrary number of these sensors. This can be done with varying degrees of accuracy, but this is not the subject of this paper, so let us consider a simple algorithm based on the following three steps:
Filtering the events according to the specified location;
Aggregating the events according to the latest values of temperature, humidity and wind speed, and by the mean precipitation;
Producing an event that indicates if there is fire danger in that particular location considering the values obtained in the previous step and comparing them to their threshold levels.
We now provide an implementation of this algorithm in EVL:
let Ev Fire Danger l d = { location = l ,  fire_danger = d} i n l e t p x = ( x . location == " Porto ") i n
l e t  f x y = ( x . f s t + 1 , modify ( y ,  precipitation ,
( x . snd . p recipitation + y . precipitation )/ x . f s t ) ) i n l e t check x = i f ( x . temperature > 29 and x . wind > 32
and x . humidity < 20 and x . p recipitation < 50 ) then Fire Danger x . location "high" 
e l s e Fire Danger x . location " low " i n
λx . ( check  ( aggregatel  f  ( 1 ,  { p r e cipitation = 0 })  ( filter  p x ) ) . snd )



Related Work
Alternative type systems to deal with records have been presented in the literature using row variables [28], which are variables ranging over finite sets of field types. One of the most flexible systems using row variables [25] allows for powerful opera- tions on records, such as extending a record with a new field or removing an existing field from a record. Record extension is also available in other systems [22,19,9], as well as record concatenation operations [20,26,29], however adding these operations results in complications in the typing process. By following Ohori’s approach we ob-

tain a sound and complete efficient type system supporting the basic operations for dealing with records. Nevertheless, regarding the applicability of our language in the context of CEP, the integration of more flexible record operations in our language is an aspect to be further investigated.
When it comes to processing flows of information, there are two main mod- els leading the research done in this area: the data stream processing model [4] (that looks at streams of data coming from different sources to produce new data streams as output); and the complex event processing model [23] (that looks at events happening, which are then filtered and combined to produce new events). In [12], several information processing systems were surveyed, which showed a gap between data processing languages and event detection languages, and the need to define a minimal set of language constructors to combine both features in the same language. We believe that EVL is a good candidate to explore the gap between these two models.
Following the complex event processing model, one of the key features is the abil- ity to derive complex events (composite) from lower-level events and several special purpose Event Query Languages (EQLs) have been proposed for that [14]. Complex event queries over real-time streams of RFID readings have been dealt with in [30] yet again using a query language. The TESLA language [11] supports content-based event filtering as well as been able to establish temporal relations on events, while providing a formal semantics based on temporal logic. The lack of a simple denota- tional semantics is a common criticism of CEP query languages [31,3,17], with several languages not guaranteeing important language features, such as orthogonality, as well as an overlapping of definitions that make reasoning about these languages that much harder. Recently, a formal framework based on a complex event logic (CEL) was proposed [18], with the purpose of “giving a rigorous and efficient framework to CEP”. The authors define well-formed and safe formulas, as syntactic restrictions that characterize semantic properties, and argue that only well-formed formulas should be considered and that users should understand that all variables in a for- mula must be correctly defined. This notion of well-formed formulas and correctly defined variables is naturally guaranteed in a typed language like EVL. Therefore we believe that EVL can be used to provide formal semantics to CEP systems.
In the context of access control systems, the Obligation Specification Language (OSL) defined in [21], presents a language for events to monitor and reason about data usage requirements. The paper defines the refinesEv instance relation between events, which is based on a subset relation on labels, as is the case for the instance re- lation in [2]. The instance relation in [1] was defined by implicit subtyping on records but more generally using variable instantiation. In this paper we further generalise the notion of instance relation and define it formally using kinded instantiation.
Still in the context of access control, Barker et al [7] have given a represen- tation of events as finite sets of ground 2-place facts (atoms) that describe an event, uniquely identified by ei,i ∈ N, and which includes three necessary facts: happens(ei, tj), act(ei, al) and agent(ei, un), and n non-necessary facts. This rep- resentation is claimed to be more flexible than a term-based representation with a

fixed set of attributes. The language in this paper is flexible enough to encode the event representation in [7]. Furthermore, the typing system allows us to guarantee any necessary facts by means of the typing information.

Conclusions and Future Work
In this paper we present EVL, a typed higher-order functional language for events, with a typing system based on Ohori’s record calculus, as well as a sound and com- plete type inference algorithm. We explore the expressiveness of our language by showing its application in the context of CEP. This is a starting point to an area of research exploring the well-studied properties of higher-order functional typed languages and their ability to reason with dynamical properties of systems, while applying it to the areas of obligation models for access control and complex event processing (CEP). We believe the language defined in this paper proved to be bet- ter equipped to deal with generic events when compared to traditional relational languages used in the CEP area.
With respect to future work, events in our language are represented by records of the form {l1 = v1,..., ln = vn}, with appropriate constructors for creating, accessing and modifying records. Additionally one could consider more powerful operations on records, such as extending a record with a new field or removing an existing field from a record, which are not part of EVL but could prove useful in both CEP and in the treatment of obligations in the context of access control models.
We would also like to fully exploit EVL’s capabilities in the context of the CBACO metamodel [2]. Furthermore, we would like to explore extensions of EVL with pattern matching, which is a powerful mechanism for decomposing and processing data. The ability to detect patterns is a key notion in most CEP systems, therefore adding matching primitives to EVL would greatly improve its capability with respect to pattern detection.
Acknowledgment
This work was partially funded by National Funds through the Portuguese fund- ing agency, FCT - Fundação para a Ciência e a Tecnologia, within project UIDB/50014/2020 and by Project “Safe Cities”, ref. POCI-01-0247-FEDER-041435, financed by Fundo Europeu de Desenvolvimento Regional (FEDER), through COM- PETE 2020 and Portugal 2020.

References
Alves, S., S. Broda and M. Fernández, A typed language for events, in: M. Falaschi, editor, Logic-Based Program Synthesis and Transformation - 25th International Symposium, LOPSTR 2015, Siena, Italy, July 13-15, 2015. Revised Selected Papers, Lecture Notes in Computer Science 9527 (2015), pp. 107–
123.
URL https://doi.org/10.1007/978-3-319-27436-2_7

Alves, S., A. Degtyarev and M. Fernández, Access Control and Obligations in the Category-Based Metamodel: A Rewrite-Based Semantics, in: Proceedings of LOPSTR’14, LNCS 8981, Springer, 2015
pp. 148–163.


Artikis, A., A. Margara, M. Ugarte, S. Vansummeren and M. Weidlich, Complex event recognition languages: Tutorial, in: Proceedings of the 11th ACM International Conference on Distributed and Event-Based Systems, DEBS ’17 (2017), p. 7–10.
URL https://doi.org/10.1145/3093742.3095106

Babcock, B., S. Babu, M. Datar, R. Motwani and J. Widom, Models and issues in data stream systems, in: Proceedings of the Twenty-First ACM SIGMOD-SIGACT-SIGART Symposium on Principles of Database Systems, PODS ’02 (2002), p. 1–16.
URL https://doi.org/10.1145/543613.543615

Barendregt, H. P., “The lambda calculus - its syntax and semantics,” Studies in logic and the foundations of mathematics 103, North-Holland, 1985.
Barga, R. S., J. Goldstein, M. H. Ali and M. Hong, Consistent streaming through time: A vision for event stream processing, in: CIDR 2007, Third Biennial Conference on Innovative Data Systems Research, Asilomar, CA, USA, January 7-10, 2007, Online Proceedings (2007), pp. 363–374.
URL http://cidrdb.org/cidr2007/papers/cidr07p42.pdf

Barker, S., M. J. Sergot and D. Wijesekera, Status-Based Access Control, ACM Transactions on Information and System Security 12 (2008), pp. 1:1–1:47.
Bertino, E., P. A. Bonatti and E. Ferrari, TRBAC: A Temporal Role-based Access Control Model, ACM Transactions on Information and System Security 4 (2001), pp. 191–233.
Cardelli, L. and J. C. Mitchell, Operations on records, in: M. Main, A. Melton, M. Mislove and
D. Schmidt, editors, Mathematical Foundations of Programming Semantics (1990), pp. 22–52.
Chandy, M. K., O. Etzion and R. von Ammon, The event processing manifesto, in: K. M. Chandy,
O. Etzion and R. von Ammon, editors, Event Processing, number 10201 in Dagstuhl Seminar Proceedings (2011).
URL http://drops.dagstuhl.de/opus/volltexte/2011/2985

Cugola, G. and A. Margara, Tesla: A formally deﬁned event speciﬁcation language, in: Proceedings of the Fourth ACM International Conference on Distributed Event-Based Systems, DEBS ’10 (2010), p. 50–61.
URL https://doi.org/10.1145/1827418.1827427

Cugola, G. and A. Margara, Processing flows of information: From data stream to complex event processing, ACM Comput. Surv. 44 (2012).
URL https://doi.org/10.1145/2187671.2187677

Damas, L. and R. Milner, Principal type-schemes for functional programs, in: R. A. DeMillo, editor, Conference Record of the Ninth Annual ACM Symposium on Principles of Programming Languages, Albuquerque, New Mexico, USA, January 1982 (1982), pp. 207–212.
URL https://doi.org/10.1145/582153.582176

Eckert, M., F. Bry, S. Brodt, O. Poppe and S. Hausmann, “A CEP Babelfish: Languages for Complex Event Processing and Querying Surveyed,” Springer Berlin Heidelberg, Berlin, Heidelberg, 2011 pp. 47–70.
URL https://doi.org/10.1007/978-3-642-19724-6_3

Etzion, O. and P. Niblett, “Event Processing in Action,” Manning Publications Co., USA, 2010, 1st edition.
Eugster, P. T., P. A. Felber, R. Guerraoui and A.-M. Kermarrec, The many faces of publish/subscribe, ACM Comput. Surv. 35 (2003), p. 114–131.
URL https://doi.org/10.1145/857076.857078
Galton, A. and J. C. Augusto, Two approaches to event deﬁnition, in: A. Hameurlain, R. Cicchetti and
R. Traunmüller, editors, Database and Expert Systems Applications (2002), pp. 547–556.
Grez, A., C. Riveros and M. Ugarte, A Formal Framework for Complex Event Processing, in: P. Barcelo and M. Calautti, editors, 22nd International Conference on Database Theory (ICDT 2019), Leibniz International Proceedings in Informatics (LIPIcs) 127 (2019), pp. 5:1–5:18.
URL http://drops.dagstuhl.de/opus/volltexte/2019/10307

Harper, R. and J. C. Mitchell, On the type structure of standard ML, ACM Trans. Program. Lang. Syst. 15 (1993), pp. 211–252.
URL https://doi.org/10.1145/169701.169696

Harper, R. and B. C. Pierce, A record calculus based on symmetric concatenation, in: D. S. Wise, editor, Conference Record of the Eighteenth Annual ACM Symposium on Principles of Programming Languages, Orlando, Florida, USA, January 21-23, 1991 (1991), pp. 131–142.
URL https://doi.org/10.1145/99583.99603


Hilty, M., A. Pretschner, D. A. Basin, C. Schaefer and T. Walter, A Policy Language for Distributed Usage Control, in: Proceedings of ESORICS’07, 2007, pp. 531–546.
Jategaonkar, L. A. and J. C. Mitchell, Type inference with extended pattern matching and subtypes, Fundam. Inf. 19 (1993), p. 127–165.

Luckham, D., “The Power of Events: An Introduction to Complex Event Processing in Distributed Enterprise Systems,” Addison-Wesley, Boston, MA, 2002.
Ohori, A Polymorphic Record Calculus and its Compilation, ACM Transactions on Programming Languages and Systems 17 (1995), pp. 844–895.

Rémy, D., Eﬃcient representation of extensible records, in: Proceedings of the 1992 workshop on ML and its Applications, San Francisco, USA, 1992, p. 12.
Rémy, D., Typing record concatenation for free, in: R. Sethi, editor, Conference Record of the Nineteenth Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, Albuquerque, New Mexico, USA, January 19-22, 1992 (1992), pp. 166–176.
URL https://doi.org/10.1145/143165.143202

Robinson, J. A., A machine-oriented logic based on the resolution principle, Journal of the Association for Computing Machinery (ACM) 12 (1965), pp. 23–41.
Wand, M., Complete type inference for simple objects, in: Proceedings of the Symposium on Logic in Computer Science (LICS’87), Ithaca, New York, USA, June 22-25, 1987 (1987), pp. 37–44.
URL http://www.ccs.neu.edu/home/wand/papers/wand-lics-87.pdf

Wand, M., Type inference for record concatenation and multiple inheritance, in: Proceedings of the Fourth Annual Symposium on Logic in Computer Science (LICS ’89), Paciﬁc Grove, California, USA, June 5-8, 1989 (1989), pp. 92–97.
URL https://doi.org/10.1109/LICS.1989.39162

Wu, E., Y. Diao and S. Rizvi, High-performance complex event processing over streams, in: Proceedings of the 2006 ACM SIGMOD International Conference on Management of Data, SIGMOD ’06 (2006),
p. 407–418.
URL https://doi.org/10.1145/1142473.1142520

Zimmer, D. and R. Unland, On the semantics of complex events in active database management systems, in: Proceedings 15th International Conference on Data Engineering (Cat. No.99CB36337), 1999, pp. 392–399.
