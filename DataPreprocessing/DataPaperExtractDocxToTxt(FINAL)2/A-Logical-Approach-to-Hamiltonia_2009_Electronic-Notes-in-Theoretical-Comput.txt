

Electronic Notes in Theoretical Computer Science 247 (2009) 123–138
www.elsevier.com/locate/entcs
A Logical Approach to Hamiltonian Graphs
L. Menasch´e Schechter1,2
Systems and Computer Engineering Program Federal University of Rio de Janeiro
Brazil

Abstract
Graphs are among the most frequently used structures in computer science. A lot of problems can be modelled using a graph and can then be solved by checking whether the graph satisfies some property. In this work, we are interested in how to use logical frameworks as a generic tool to express and efficiently check graph properties. In order to reason about this, we choose to analyze the Hamiltonian property and choose the family of modal logics as our framework. Our analysis has to deal with two central issues: whether each of the modal languages under consideration has enough expressive power to describe this property and how complex (computationally) it is to use these logics to actually test whether a given graph has this property. First, we show that this property is not definable in a basic modal logic or in any bisimulation-invariant extension of it, like the modal μ-calculus. We then show that it is possible to express it in a basic hybrid logic. Unfortunately, the Hamiltonian property still cannot be efficiently checked in this logic. In a second attempt, we extend this basic hybrid logic with the ↓ operator and show that we can check the Hamiltonian property with optimal (NP-Complete) complexity in this logic.
Keywords: Hamiltonian Graphs, Modal Logics, Model-Checking, Frame-Checking, Computational Complexity


Introduction
Graphs are among the most frequently used structures in computer science [8]. In this discipline, many important problems admit a graph representation and the solu- tion of the original problem is often reduced to checking whether the graph satisfies some property. As an example, in the field of distributed systems, graphs are used to describe and to solve problems such as resource sharing problems, scheduling problems and deadlock issues, among others [4,14].
Graph theory provides a lot of tools to describe such problems and presents many efficient algorithmic methods to solve them. However, there is an important distinction between the two sides of this matter. In the “description” side, graphs provide a great level of generality, allowing for the description of very different

1 The author was supported by a D.Sc. scholarship from CNPq.
2 Email: luis@cos.ufrj.br

1571-0661 © 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.07.052

problems in the same simple framework. But in the “solution” side, each graph problem has to be solved and each graph property has to be tested with a specific method that usually does not generalize to other different problems or properties.
A logical framework, on the other hand, may provide this level of generalization. In an intuitive and non-technical language, this can be stated as follows. Consider a logic L with its formulas and structures where these formulas are semantically evaluated. We need to be able to answer the following questions:
Can we encode a graph as a structure for L?
Can we encode the graph properties that we want to verify as L-formulas?
Does L has decidable inference methods to check whether a formula is satisfied (or valid) in a structure?
If the answers to all of these questions are positive, then we can use the inference methods of the logic to verify every graph property that we want, provided that we can express it as an L-formula. Of course, there is still a fourth question that has to be answered:
Is the logical method as efficient in testing a given property as the graph theoretical method?
In order to satisfy the first question, we choose to work with the family of modal logics [7]. A very strong reason to choose modal logics for this task, instead of any other logic, is that modal logic formulas are evaluated in structures that are essentially graphs, which makes it a very natural choice for our work. As the first slogan in the preface of [7] states, “modal languages are simple yet expressive languages for talking about relational structures”.
Many important graph properties are what we can call global graph properties,
which means that they are properties that hold for the graph as a whole and that depend on the structure of the whole graph. In order to reason about the issues stated above, we choose one of these properties, the Hamiltonian property, to guide our exposition throughout this work.
In this work, we analyze how we can express and efficiently check the Hamilto- nian property using modal logics. This involves two issues: the first is whether each of the modal languages that we consider has enough expressive power to describe this property; the second is how complex (computationally) it is to use these logics to actually test whether a given graph has this property.
This work can be considered as a follow-up to [6]. In that work, the goal was also to find formulas that could describe global graph properties, but the practical issue of how computationally complex it would be to use those formulas to check whether a graph satisfies the correspondent property was not addressed.
A ﬁnite directed graph (from now on called simply a graph) G is a pair (V, R),
where V is a finite set of vertices and R ⊆ V × V is a set of ordered pairs of vertices (a binary relation on V ), called edges. If ⟨vi, vj⟩∈ R, we say that vi is adjacent to vj and vj is adjacent from vi. The out-degree of a vertex is the number of vertices adjacent from it and the in-degree the number of vertices adjacent to it. The set R

of edges can also be written as a relation between two vertices vi and vj. We write
viRvj to express the fact that vi is adjacent to vj.
A path in a graph G is a sequence of vertices ⟨v1, v2,..., vn⟩, where ⟨vi, vi+1⟩∈ R, for 0 < i < n. A closed path is a path such that v1 = vn. A cycle is a path where v1 = vn and vi /= vj, for 1 ≤ i, j < n, i /= j. A graph G is said to be acyclic if there is no cycle in it, otherwise it is cyclic.
The rest of this paper is organized as follows. In Section 2, we present a sim- ple modal logic suited for the description of graph properties. In Section 3, we investigate the issue of whether the Hamiltonian property is definable or not in the language presented in the previous section. In Section 4, we extend the modal logic of the previous sections with nominals, obtaining a hybrid modal logic, and use it to express the Hamiltonian property. In Section 5, we extend the basic hybrid logic of Section 4 with the ↓ operator and show that we can check the Hamiltonian property with optimal (NP-Complete) complexity in this logic, thus answering positively the fourth question above. Finally, in Section 6, we draw our concluding remarks.
Basic Graph Logic
In this section, we define a modal logic 3 with two modal operators:  and  +. We call it basic graph logic.
Definition 2.1 The language of the basic graph logic is a modal language consisting of a set Φ of countably many proposition symbols (the elements of Φ are denoted by p1, p2,.. .), the boolean connectives ч and Λ and two modal operators:   and
  +. The formulas are defined as follows:
ϕ ::= p |T| чϕ | ϕ1 Λ ϕ2 |  ϕ |  +ϕ

We freely use the standard boolean abbreviations V, →, — and ⊥ and also the following abbreviations for the duals:  ϕ := ч чϕ and +ϕ = ч +чϕ. Also, in order to make the language more elegant, we introduce some abbreviations for the reflexive and transitive closures:  ∗ϕ = ϕ V  +ϕ and  ∗ϕ = ч ∗чϕ.
We now define the structures in which we evaluate formulas in modal logics:
frames and models.
Definition 2.2 A frame for the basic graph logic is a pair J = (V, R), where V is a set (finite or not) of vertices and R is a binary relation over V, i.e., R ⊆ V × V .
As we see, a frame for the basic graph logic is essentially a graph. This confirms our statement in the first section that modal logics are a very natural choice for this work.
Definition 2.3 A model for the basic graph logic is a pair ł = (J, V), where J is a frame and V is a valuation function mapping proposition symbols into subsets of V , i.e., V : Φ '→ У(V ).

3 For a broad reference on modal logics, [7] can be consulted.

The semantical notion of satisfaction is defined as follows:
Definition 2.4 Let ł = (J, V) be a model. The notion of satisfaction of a formula ϕ in a model ł at a vertex v, notation ł,v H ϕ, can be inductively defined as follows:
ł,v H p iff v ∈ V(p);
ł,v H T always;
ł,v H чϕ iff ł,v /H ϕ;
ł,v H ϕ1 Λ ϕ2 iff ł,v H ϕ1 and ł,v H ϕ2;
ł,v H ϕ iff there is a w ∈ V such that vRw and ł,w H ϕ;
ł,v H +ϕ iff there is a w ∈ V such that vR+w and ł,w H ϕ. Here, R+ denotes the transitive closure of R.
Let ł be the model shown (without its valuation) in Figure 1. In order to illustrate the use of the logic, we can see that the following formulas are satisfied at vertex w in ł, supposing that ϕ is satisfied at vertex v in ł: ł,w H ϕ, ł,w H   ϕ, ł,w H  +ϕ and ł,w H  + ⊥.
v





w
Fig. 1. Model M, where a formula ϕ is satisfied at vertex v.
If ł,v H ϕ for every vertex v in a model ł, we say that ϕ is globally satisﬁed in ł, notation ł H ϕ. And if ϕ is globally satisfied in all models ł of a frame J, we say that ϕ is valid in J, notation J H ϕ.
In this work, for each logic that we consider, we want to find a modal formula φ, such that a graph G has the Hamiltonian property if and only if J H φ, where J is the frame that represents G.
For each modal logic that we consider for this task, there are two issues involved. The first one is whether the modal language has enough expressive power to describe the graph property that we want. In case the answer is negative, we need to search for a language with greater expressive power. In case the answer is positive and we are able to find such a formula, then we need to estimate how complex (computa- tionally) it is to use the inference mechanisms of the logic to actually test, using the formula that we found, whether a given graph has the Hamiltonian property.
The issue of expressive power with respect to the language of the basic graph logic will be addressed in the next section. The issue of the complexity for testing graph properties involves four basic decision problems.
Definition 2.5 The satisﬁability problem consists of, given a formula φ, determin- ing whether there is a model ł and a vertex v in ł such that ł,v H φ.

Definition 2.6 The validity problem consists of, given a formula φ, determining whether J H φ, for all frames J.
The satisfiability problem and the validity problem are duals to each other, as a formula φ is valid if and only if the formula чφ is not satisfiable.
Definition 2.7 The model-checking problem consists of, given a formula φ, a model
ł and a vertex v in ł, determining whether ł,v H φ.
Definition 2.8 The frame-checking problem consists of, given a formula φ and a frame J, determining whether J H φ.
Theorem 2.9 ([7]) The satisﬁability problem and the validity problem for the basic graph logic are EXPTIME-Complete in the length of the formula.
Definition 2.10 Let ł = (V, R, V) be a model. Let |V | be the number of vertices in V and |R| the number of pairs in R. We define the size of the model (or the frame, or the graph) as |V | + |R|.
Theorem 2.11 ([10]) The model-checking problem for the basic graph logic is PTIME both in the size of the model and in the length of the formula.
We can provide a simple upper bound for the complexity of the frame-checking problem based on the complexity of the correspondent model-checking problem. Let FC be the complexity of the frame-checking problem and MC be the complexity of the model-checking problem. Then,
FC = O(2|p|∗n ∗ n ∗ MC),

where |p| is the number of distinct proposition symbols that occur on the given formula φ and n is the number of vertices in J. We need to apply the model-checking algorithm to every pair (ł, v) based on the given frame J. Every proposition symbol that appears in φ may receive 2n possible valuations.
Theorem 2.12 The frame-checking problem for the basic graph logic is PTIME in the length of the formula and EXPTIME in the size of the frame and in the number of distinct proposition symbols that occur in the formula.
It should be noticed that this calculation of the complexity of the frame-checking problem is just a general upper-bound and it can possibly be reduced in some concrete situations.
Modal Definability
In this section, we investigate whether the Hamiltonian property is definable or not in the language of the basic graph logic.
The limits to the expressive power of basic modal languages are fairly well known. There are a series of standard results that state that frames that are “similar” in a number of ways must agree on the validity of formulas. We can then use these

results to prove that a certain property cannot be expressed by any modal formula. To do this, we take two frames that are “similar” and show that in one the desired property holds, while in the other it does not. We present one of these “similarity” results (more details about it and other related results may be found in [7]), and then we prove a theorem for the Hamiltonian property using it.
Definition 3.1 Let ł = (W, R, V) and ł' = (W', R', V') be two models. A function f : W → W' is a bounded morphism if it satisfies the following conditions:
w and f (w) satisfy the same proposition symbols;
f is a homomorphism with respect to R (if wRv, then f (w)R'f (v));
if f (w)R'v', then there is a v such that wRv and f (v) = v'.
If there is a surjective bounded morphism from W to W', then we say that ł'
is a bounded morphic image of ł and use the notation ł⇒ ł'.
A similar definition can be given for a bounded morphism of frames, just remov- ing the part of the above definition that deals with valuations.
Below is a basic theorem about modal definability that is going to be used in the next subsection. Its proof for a language that contains only  can be found in [7]. It is not difficult to extend that proof to a language that contains both  and
 +.
Theorem 3.2 Let ł = (W, R, V) and ł' = (W', R', V') be two models such that
ł⇒ ł'. Then, ł,w H φ if and only if ł',f (w) H φ.
Corollary 3.3 Let J = (W, R) and J' = (W', R') be two frames such that J ⇒ J'. If J H φ, then J' H φ.
Hamiltonian Graphs
Definition 3.4 A connected graph G is said to be Hamiltonian if and only if there is a cycle in G that goes through every vertex of it.
Theorem 3.5 The class of Hamiltonian graphs is not modally deﬁnable.
Proof.	From Figure 2, let f = {(1, a), (2, b), (3, c), (4, d), (5, b)}. It is straightfor-

2	3	c


1

5	4	d
Fig. 2. Graph 1,2,3,4,5 is Hamiltonian and graph a,b,c,d is not.

ward to prove that f is a bounded morphism. By Corollary 3.3, since the Hamil- tonian property is not preserved under bounded morphic images, it is not modally definable.	 

The Modal μ-Calculus
Looking at the results of the previous subsections, we see that, unfortunately, the language of the basic graph logic does not have enough expressive power to define the property that we want. We need a stronger language. One idea could be to use the modal μ-calculus [9,16]. Its language incorporates fixpoint operators and is very expressive. In fact, not only the basic graph logic can be embedded into the μ-calculus, but so can be the temporal logics LTL, CTL and CTL∗ [11].
Unfortunately, even with all this expressive power, the language of the μ-calculus fails to express this property because of the same reason exposed in the previous subsection. This happens because μ-calculus formulas, as the basic graph formulas, are invariant under bisimulations (bounded morphisms are a special case of bisim- ulation). In fact, the μ-calculus is the bisimulation-invariant fragment of Monadic Second-Order Logic (MSOL) [9].
To bypass this problem, we introduce a different kind of language in the next section. This language has a mechanism to name vertices of the model and allows us to express the Hamiltonian property.
Hybrid Graph Logic
As was shown in the previous section, the language of the basic graph logic does not have enough expressive power to describe the property that we want. In order to achieve our goal, we need a logic that has a language with more expressive power but, if possible, is still decidable with respect to the problems stated in the Definitions 2.5 until 2.8.
One interesting class of logics to take into consideration is the class of hybrid logics [3,7]. In these logics, there is a new kind of atomic symbol: nominals. Nom-
inals behave similarly to proposition symbols. The key difference between them is related to their valuation in a model. While the set V(p) for a proposition symbol p can be any element of У(V ), the set V(i) for a nominal i has to be a singleton set. This way, each nominal is satisfied at exactly one vertex, and thus, can be used to reference a unique vertex of the model.
A hybrid extension of our previous logic is an interesting choice because of a combination of factors. Its language has an improved expressive power, since hybrid formulas are no longer invariant under bounded morphic images [3], but it is still a decidable logic, as discussed in the following subsection.
In this section, we define an extension of the basic graph logic that includes nominals. We call it hybrid graph logic. After that, we try to express, in this new logic, the Hamiltonian property.

Language
Definition 4.1 The language of the hybrid graph logic is a hybrid language con- sisting of a set Φ of countably many proposition symbols (the elements of Φ are denoted by p1, p2,.. .), a set L of countably many nominals (the elements of L are

denoted by i1, i2,.. .) such that Φ ∩L = ∅ (the elements of Φ ∪L are called atoms), the boolean connectives ч and Λ and the modal operators @i, for each nominal i,
  and  +. The formulas are defined as follows:
ϕ ::= p | i |T| чϕ | ϕ1 Λ ϕ2 |  ϕ |  +ϕ | @iϕ
Again, we freely use the standard abbreviations V, →, —, ⊥,  ϕ,  +ϕ,  ∗ϕ
and  ∗ϕ.
The definition of a frame is the same as the one from Section 2. The definition of a model is slightly different.
Definition 4.2 A model for the hybrid graph logic is a pair ł = (J, V), where J is a frame and V is a valuation function mapping proposition symbols into subsets of V , i.e., V : Φ '→ У(V ), and mapping nominals into singleton subsets of V , i.e, if i is a nominal then V(i) = {v} for some v ∈ V . We call this unique vertex that belongs to V(i) the denotation of i under V. We can also say that i denotes or names the single vertex belonging to V(i).
Definition 4.3 The notion of satisfaction is defined adding two extra clauses to Definition 2.4:
ł,v H i iff v ∈ V(i);
ł,v H @iϕ iff ł,d H ϕ, where d is the denotation of i under V.
It is interesting to see that the operators @i are duals to themselves: ł,v H ч@iφ iff ł,v /H @iφ iff ł,d /H φ, where d is the denotation of i under the valuation of ł, iff ł,d H чφ iff ł,v H @iчφ.
As in Section 2, if ł,v H ϕ for every vertex v, we say that ϕ is globally satisﬁed in the model ł (ł H ϕ) and if ϕ is globally satisfied in all models ł of a frame J, we say that ϕ is valid in J (J H ϕ).
Theorem 4.4 ([2]) The satisﬁability problem and the validity problem for the hy- brid graph logic are EXPTIME-Complete in the length of the formula.
Theorem 4.5 ([12]) The model-checking problem for the hybrid graph logic is PTIME both in the size of the model and in the length of the formula.
The upper bound for the complexity of the frame-checking problem is a little different in the case of a hybrid logic, because of the special restriction on the valuation of nominals. For hybrid logics, the upper bound has the form
FC = O(2|p|∗n ∗ n|i| ∗ n ∗ MC),
where |p| is the number of distinct proposition symbols that occur on the given formula φ, |i| is the number of distinct nominals that occur in φ and n is the number of vertices in J. We need to apply the model-checking algorithm to every pair (ł, v) based on the given frame J. Every proposition symbol that appears in φ may receive 2n possible valuations, while every nominal may only receive n possible valuations.

Theorem 4.6 The frame-checking problem for the hybrid graph logic is PTIME in the length of the formula and EXPTIME in the size of the frame, in the number of distinct proposition symbols that occur in the formula and in the number of distinct nominals that occur in the formula.
We can see then that the hybrid graph logic is indeed a very interesting choice, since we get a greater expressive power without any increase in computational com- plexity.
Hybrid Deﬁnability
Before trying to find a formula to describe the Hamiltonian graphs, we need to consider some graph-theoretical issues. In graph theory [8], there is no known result that states a necessary and sufficient condition for a graph to be Hamiltonian. If we could find a formula that describes the Hamiltonian graphs without having to describe the Hamiltonian cycle itself, we would be finding such necessary and sufficient condition. Thus, what our formulas do is to inspect all of the paths in the graph, searching for a Hamiltonian cycle. Not surprisingly then, a formula for a graph with n vertices uses n nominals.
Let Ln = {i1,..., in} be a set containing n nominals. Before defining a formula
for the Hamiltonian property, we will define a formula that is globally satisfied in a model under a valuation V if and only if V(ik) /= V(il), for all ik, il ∈ Ln such that k /= l.
Lemma 4.7 A valuation satisﬁes V(ik) /= V(il), for all ik, il ∈ Ln such that k /= l, if and only if (J, V) H ψn, where ψn is the formula


ψn =	 
1≤k≤n
⎛
⎝@ik

 
1≤l≤n,l/=k
⎞
чil⎠ .

Proof. It follows directly from the definitions of a valuation for a nominal and of satisfaction for a nominal and for a formula @iϕ.	 
We now define a set F of permutations of the nominals in Ln. This set has n! elements. We represent a permutation as a bijective function σ : {1,..., n} '→ Ln.
Theorem 4.8 A connected graph G (with n vertices) with frame J is Hamiltonian
if and only if J H φ, where φ is the formula
φ = ψn → δn,
with
δn =   (σ(1) Λ  (σ(2) Λ  (σ(3) ... (σ(n — 1) Λ  (σ(n) Λ  σ(1)) .. .).
σ∈F
Proof. (⇐) Suppose that the formula φ is valid in J. This means that, for any arbitrary vertex v and any arbitrary valuation V, (J, V),v H φ. In particular,

(J, V∗), v∗ H φ, where V∗ satisfies ψn and V∗(i1) = {v∗}. First, this means that, under this valuation, each nominal is denoting a different vertex. Second, V∗ must also satisfy δn at v∗. If δn is satisfied, at least one of the members in its disjunction is satisfied. Let σ' be the permutation correspondent to this member. To simplify the notation and without loss of generality, we consider that σ'(k) = ik. Let then Δn = in Λ i1. We also define the formulas Δk, for 1 ≤ k ≤ n — 1, as
Δk = ik Λ  Δk+1.
Thus, (J, V∗), v∗ H Δ1. From this and from the construction rule of the formulas Δk, we have that there are vertices wk, 2 ≤ k ≤ n, in G such that (J, V∗), wk H Δk, with wkRwk+1, for 2 ≤ k ≤ n — 1, v∗Rw2 and wnRv∗.  We then have that
⟨v∗, w2,..., wn, v∗⟩ is a Hamiltonian cycle in G.
(⇒) Suppose that there is a Hamiltonian cycle ⟨v1,... vn, v1⟩ in G. We denote the vertices with nominals in such a way that Ln = {i1,..., in} and ik denotes vk. This valuation satisfies ψn. We have that vnRv1, so Δn is satisfied at vn. Similarly, Δk is satisfied at vk. Since Δ1 is a member of the disjunction in δn, δn is satisfied at v1. Repeating the previous line of thought, but starting the cycle at v2, v3 and so on, we can see that δn is also satisfied at all the vertices in the cycle. Since the cycle is Hamiltonian, this means that δn is satisfied in all the vertices of G. Since φ is trivially satisfied in all the valuations that do not satisfy ψn, we only need to think about the ones that do. If we change the valuation of the nominals in Ln to another one that satisfies ψn, this is equivalent to applying a permutation to the nominals. As δn contains a member in its disjunction for each permutation, we conclude that in fact φ is valid in J.	 
This is the simplest and most direct attempt to describe the Hamiltonian prop- erty: pure brute force. The formula has factorial length on the size of the graph, which makes it impossible to be frame-checked. However, the length of the formula is not the only problem. In order to see that, we present an alternative formula that has polynomial length on the size of the graph.
Theorem 4.9 A connected graph G (with n vertices) with frame J is not Hamil- tonian if and only if J H чφ, where φ is the formula

φ =	 
1≤k<n
@ik ik+1 Λ @in i1 Λ ψn.

Proof. It is not difficult to show, using a proof similar to the one in the previous theorem, that G is Hamiltonian if and only if there is a valuation V∗ such that (J, V∗) H φ.	 
Now, the formula has polynomial length on the size of the graph and the frame- checking complexity is PTIME in the length of the formula (Theorem 4.6), but we still cannot perform an efficient frame-check. The reason for this is that not only the length of the formula is linked to the size of the graph, but so is the number of distinct nominals in the formula. If we look at the complexity of the frame-checking

problem in the hybrid graph logic (Theorem 4.6 and the formula above it), this means that FC = O(nn ∗MC). Even if we consider only the valuations that satisfy ψn, i.e., valuations that assign n distinct vertices to the n distinct nominals in the formula, we still get FC = O(n! ∗ MC). Even though the length of the formula is now polynomial, we still have a factorial time complexity to check the Hamiltonian property in the hybrid graph logic. Hence, we must search for an alternative form to express this property using another logic. This is what we do in the next section.
Hybrid Graph Logic with the ↓ Binder
In the previous section, we were only able to test whether a graph is Hamiltonian using a frame-checking method in factorial time. In this section, we describe a third logic, which is an extension of the hybrid graph logic with state-variables and the ↓ binder 4 . We then use it to build a formula that expresses the Hamiltonian property. With this formula, we are able to significantly reduce the complexity of testing whether a graph is Hamiltonian using a frame-checking method. This happens because we are able, for this particular formula, to reduce the frame- checking problem to a model-checking problem.

Language
Definition 5.1 The language of the hybrid graph logic with the ↓ binder is a hybrid language consisting of a set Φ of countably many proposition symbols (the elements of Φ are denoted by p1, p2,.. .), a set L of countably many nominals (the elements of L are denoted by i1, i2,.. .), a set S of countably many state-variables (the elements of S are denoted by x1, x2,.. .), such that Φ, L and S are pairwise disjoint (the elements of Φ ∪L∪S are called atoms), the boolean connectives ч and Λ and the modal operators @i, for each nominal i, @x, for each state-variable x,  ,  + and
↓. The formulas are defined as follows:
ϕ ::= p | i | x |T| чϕ | ϕ1 Λ ϕ2 |  ϕ |  +ϕ | @iϕ | @xϕ |↓ x.ϕ
Again, we freely use the standard abbreviations V, →, —, ⊥,  ϕ,  +ϕ,  ∗ϕ
and  ∗ϕ.
The definition of a frame and of a model are the same as the ones from Section
4.
In order to deal with the state-variables, we need to introduce the notion of
assignments.
Definition 5.2 An assignment is a function g that maps state-variables to vertices of the model, i.e., g : S '→ V . We use the notation g' = g[v1/x1,..., vn/xn] to denote an assignment such that g'(x) = g(x) if x ∈/ {x1,..., xn} and g'(xi) = vi, otherwise.
The semantical notion of satisfaction is defined as follows:

4 For more information on hybrid logics with the ↓ binder, [3] and [15] can be consulted.

Definition 5.3 The notion of satisfaction of a formula φ in a model ł at a vertex v with an assignment g, notation ł, g,v H φ, is inductively defined adding the assignment g to all the clauses in Definitions 2.4 and 4.3 and the following three extra clauses:
ł, g,v H x iff g(x) = v;
ł, g,v H @xφ iff ł, g,d H φ, where d = g(x);
ł, g,v H↓ x.φ iff ł, g[v/x],v H φ.
The formula ↓ x.φ means that, using x as a name for the present vertex (state- variables can be thought of as “on-the-fly nominals”), φ is satisfied. The ↓ operator is the only operator that binds a variable. Free and bounded variables are defined in the usual way. The only case worth mentioning is that in the formula @xψ, the variable x occurring in the satisfaction operator is free. A sentence is a formula with no free variables. We only consider formulas that are sentences, because we do not want to include the assignments in the model-checking and frame-checking problems.
The ↓ binder, just as the satisfaction operators, is dual to itself: ł, g,v H ч↓ 
x.φ iff ł, g,v /H↓ x.φ iff ł, g[v/x],v /H φ iff ł, g[v/x],v H чφ iff ł, g,v H↓ x.чφ.
Theorem 5.4 ([1]) The satisﬁability problem and the validity problem for the hy- brid graph logic with the ↓ binder are undecidable.
This result shows that the inclusion of state-variables and the ↓ operator turns a logic that had the same complexity as the basic graph logic into an undecidable logic.
Theorem 5.5 ([12]) The model-checking problem for the hybrid graph logic with the ↓ binder is PSPACE-Complete both in the size of the model and in the length of the formula.
In [15], it is shown that, for a family of hybrid logics with the ↓ binder, there are fragments of these logics in which the complexities of the satisfiability problem and the model-checking problem are lower than in the full logics. One of these fragments, which is defined using the notion of formulas in negation normal form, turns out to be also a fragment of the hybrid graph logic with the ↓ binder. According to [15], the complexity of the model-checking problem in this fragment is lower than the one stated above for the full hybrid graph logic with the ↓ binder. This result will be central to our discussion in this section.
Definition 5.6 A formula of the hybrid graph logic with the ↓ binder is in negation normal form (NNF) if the negation symbol (ч) appears only in front of proposition symbols, nominals and state-variables.
Lemma 5.7 If we consider the dual operators of T, Λ,  and  +, i.e., ⊥, V,  and
 + as primitive operators of the language, then each formula of the hybrid graph logic with the ↓ binder is semantically equivalent to a formula in NNF.

Proof. Let (Δ, q) be one of the following pairs of dual operators: (Λ, V), ( , ), ( +, +), (↓, ↓) and (@z, @z), where z is either a nominal or a state-variable. Using the semantic equivalences чT ≡ ⊥, ч⊥ ≡ T, ччφ ≡ φ and чΔ φ ≡ qчφ, we can push the negation symbols inside the formulas until they appear only in front of proposition symbols, nominals and state-variables.	 
Theorem 5.8 ([15]) The model-checking problem for a formula in the hybrid graph logic with the ↓ binder that, when put in NNF, does not have any occurrence of  ,
 + and  + is NP-Complete both in the size of the model and in the length of the formula.
The upper bound for the complexity of the frame-checking problem is again

FC = O(2|p|∗n ∗ n|i| ∗ n ∗ MC),

where |p| is the number of distinct proposition symbols that occur on the given formula φ, |i| is the number of distinct nominals that occur in φ and n is the number of vertices in J. It should be noticed that, if the model-checking problem can be solved in polynomial space, then the frame-checking problem can also be solved in polynomial space. This happens because the frame-checking is done through a series of completely independent model-checkings, which means that the same amount of memory space used to perform a single model-checking can be reused multiple times to perform a frame-checking.
Theorem 5.9 The frame-checking problem for the hybrid graph logic is PSPACE in the length of the formula and in the size of the frame.
The Hamiltonian Property
Theorem 5.10 A connected graph G (with n vertices) with frame J is Hamiltonian
if and only if J H φ, where φ is the formula

φ =↓ x1.  ↓ x2.(чx1 Λ  ↓ x3.( 
1≤k<3
чxk Λ  ...  ↓ xn−1.(	 
1≤k<n−1
чxk Λ  ↓ xn.


( 
1≤k<n

чxk Λ  x1) .. .).

Proof. (⇐) Suppose that the formula φ is valid in J. We will evaluate φ in an arbitrary vertex v1 of a model with an arbitrary valuation V and an arbitrary assignment g. If ł, g, v1 H φ, then ł, g[v1/x1], v1 H  ↓ x2.чx1	This means
that there is a vertex v2 such that v1Rv2 and ł, g[v1/x1], v2 H↓ x2.чx1 Λ  ↓ x3  ,
which means that ł, g[v1/x1, v2/x2], v2 H чx1 Λ  ↓ x3 .. .. This implies that v2 /= v1 and ł, g[v1/x1, v2/x2], v2 H  ↓ x3 .. .. If we keep repeating this, we conclude that there are n distinct vertices v1,..., vn such that viRvi+1, 1 ≤ i < n and vnRv1. We have a path that starts and ends in the vertex v1 and visit every other vertex of G exactly once. This is exactly a Hamiltonian cycle.

(⇒) Suppose that there is a Hamiltonian cycle ⟨v1,... vn, v1⟩ in G. We have that ł, g[v /x ,..., v /x ], v H	чx Λ x . This means that ł, g[v /x ,..., vn−1/xn−1], vn H↓ xn.  1≤k<n чxk Λ  x1, which implies that ł, g[v1/x1,..., vn−1/
n−1	n−1	1≤k<n−1	k	n	1≤k<n	k	1
this, we conclude that ł, g, v1 H φ, for an arbitrary assignment g. If we start the
Hamiltonian cycle in another vertex, the same argument easily applies. Thus, φ is globally satisfied in ł. As the valuation in ł is completely irrelevant, φ is valid in J.	 
Let us now determine how complex it is to test whether a graph is Hamiltonian using the above formula φ. First of all, we now have a formula that is a sentence with quadratic length in the size of the graph. Also, there are no proposition symbols and no nominals. This means that the valuation is completely irrelevant to the satisfaction of this sentence. From the fact that an Hamiltonian cycle goes through every vertex of the graph, it is not difficult to see that the formula is satisfied in one vertex of the model if and only if it is satisfied in all vertices of the model. Thus, the frame-checking problem is reduced to the model-checking problem for an arbitrary vertex of an arbitrary model of the frame. Let HAM be the complexity of testing whether a graph is Hamiltonian through a frame-checking of φ. Then, taking into account the above observations, we have that

HAM = MC.

Now, we should notice that φ is already in NNF and it does not have any occurrence of , + or +. So, the reduction in the model-checking complexity stated in Theorem 5.8 applies, and the model-checking complexity for this formula is NP-Complete.
Theorem 5.11 The complexity to check whether a graph is Hamiltonian using the above formula φ is NP-Complete in the size of the graph.
The above formula φ is an “optimal” formula to describe the Hamiltonian prop- erty, in the following sense: since the problem of testing whether a graph is Hamil- tonian is NP-Complete [13] and the test that we developed using this formula is also NP-Complete, it is impossible to find any other formula, in this logic or in any other logic, that describes the Hamiltonian property and can be tested faster than φ (assuming that NP /= P).

Conclusions
Our goal in this paper is to try to express and efficiently check, using modal logics, a graph property that is central in computer science: the Hamiltonian property. The works presented in [5] and [6] are closely related to this one. In [5], the interest was also in how to use modal logics to express global graph properties. However, in that work, only the basic graph logic was considered and the properties analyzed were connectivity and acyclicity. Moreover, the focus of that work was on how to build

axiomatizations for classes of graphs with these global properties, while our focus is on finding formulas expressing a global graph property that can be efficiently used to test whether a graph satisfies it. In [6], the goal was also to find formulas that could describe global graph properties, but the practical issue of how computationally complex it would be to use those formulas to check whether a graph satisfies the correspondent property was not addressed.
In this work, we present three increasingly expressive formalisms, from a very basic modal logic to a hybrid logic with variables and use them to express and test the Hamiltonian property. It would also be interesting to continue this line of work and try to express some other global graph properties such as planarity and k-colorability of vertices and edges.
This work is an interesting way of exposing an important issue. Sometimes, standard modal logics, even the ones that are incredibly expressive, such as the μ-calculus, are not capable of expressing some important properties. This happens because of some strong invariance conditions that these logics satisfy (for example, the modal logic defined in Section 2 can only express properties that are invariant under bounded-morphisms, as shown in Section 3). In these cases, the use of a hybrid logic is a very simple way to bypass this problem. Hybrid logics have much weaker invariance conditions [3], which increases the number of definable properties. In Section 5, we are able to find a formula in a hybrid logic with the ↓ opera- tor that expresses the Hamiltonian property and can be checked in NP-Complete time. This is an optimal result, since the problem of deciding whether a graph is Hamiltonian is NP-Complete [13]. Also, if we think about the results presented in Section 5 in the reverse order, the fact that we can express the Hamiltonian prop-
erty with a formula that contain no  ,  + or  + provides an alternative proof for
the NP-hardness in Theorem 5.8, different from the one presented in [15].
Besides that, the formula that expresses the Hamiltonian property and the for- mula presented in [15] to express the propositional satisfiability problem (another NP-Complete problem) are remarkably similar, consisting of an alternating sequence of ↓’s and ’s. This suggests that the fragment presented in [15] could be a simple framework for the description of NP-Complete problems. Expressing these prob- lems in a common language could highlight the underlying similarities between them. As graph theory has a rich collection of NP-Complete problems, it would also be interesting to analyze how we can express them in this fragment.

References
Areces, C., P. Blackburn and M. Marx, A road-map on complexity for hybrid logics, in: Proceedings of the 8th Annual Conference of the EACSL, Lecture Notes in Computer Science 1683 (1999), pp. 307–321.
Areces, C., P. Blackburn and M. Marx, The computational complexity of hybrid temporal logics, Logic Journal of the IGPL 8 (2000), pp. 653–679.
Areces, C. and B. ten Cate, Hybrid logics, in: P. Blackburn, J. van Benthem and F. Wolter, editors,
Handbook of Modal Logic, Elsevier, 2006 pp. 821–868.
Barbosa, V. C., “An Introduction to Distributed Algorithms,” MIT Press, 1996.


Benevides, M. R. F., Modal logics for finite graphs, in: R. Queiroz, editor, Logic for Synchronization and Concurrency, Trends in Logic, Kluwer Academic Publisher, 2003 pp. 239–267.
Benevides, M. R. F. and L. M. Schechter, Modal expressiveness of graph properties, in: Proceedings of the 2nd Workshop on Logical and Semantic Frameworks, with Applications, Electronic Notes in Theoretical Computer Science 205 (2008), pp. 31–47.
Blackburn, P., M. de Rijke and Y. Venema, “Modal Logic,” Theoretical Tracts in Computer Science, Cambridge University Press, 2001.
Bondy, J. A. and U. S. R. Murty, “Graph Theory with Applications,” Elsevier, New York, 1979.
Bradfield, J. and C. Stirling, Modal mu calculi, in: P. Blackburn, J. van Benthem and F. Wolter, editors,
Handbook of Modal Logic, Elsevier, 2006 pp. 721–756.
Clarke, E. M., O. Grumberg and D. Peled, “Model Checking,” MIT Press, 2000.
Dam, M., CTL∗ and ECTL∗ as fragments of the modal mu-calculus, Theoretical Computer Science
126 (1994), pp. 77–96.
Franceschet, M. and M. de Rijke, Model checking hybrid logics (with an application to semistructured data), Journal of Applied Logic 4 (2006), pp. 279–304.
Karp, R., Reducibility among combinatorial problems, in: Complexity of Computer Computations, Plenum, New York, 1972 pp. 85–103.
Lynch, N., “Distributed Algorithms,” Morgan Kaufmann Publishers, San Mateo, 1996.
ten Cate, B. and M. Franceschet, On the complexity of hybrid logics with binders, in: Proceedings of the 19th International Workshop of Computer Science Logic, Lecture Notes in Computer Science 3634 (2005), pp. 339–354.
Venema, Y., Lectures on the modal mu-calculus (2008). URL http://staff.science.uva.nl/~yde/ teaching/ml/mu/mu.pdf
