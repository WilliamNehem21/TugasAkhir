

Electronic Notes in Theoretical Computer Science 239 (2009) 105–117
www.elsevier.com/locate/entcs

On Decidability of LTL+Past Model Checking for Process Rewrite Systems
Mojm´ır Kˇret´ınsky´1 ,4	Vojtˇech Rˇeha´k2 ,5	Jan Strejˇcek3 ,6
Faculty of Informatics, Masaryk University Botanicka´ 68a, 60200 Brno, Czech Republic

Abstract
The paper [4] shows that the model checking problem for (weakly extended) Process Rewrite Systems and properties given by LTL formulae with temporal operators strict eventually and strict always is decidable. The same paper contains an open question whether the problem remains decidable even if we extend the set of properties by allowing also past counterparts of the mentioned operators. The current paper gives a positive answer to this question.
Keywords: rewrite systems, infinite-state systems, model checking, decidability, linear temporal logic


Introduction
To specify (the classes of) infinite-state systems we employ term rewrite systems called Process Rewrite Systems (PRS) [16]. PRS subsume a variety of the formalisms studied in the context of formal verification, e.g. Petri nets (PN), pushdown pro- cesses (PDA), and process algebras like PA. Moreover, they are suitable to model current software systems with restricted forms of dynamic creation and synchroniza- tion of concurrent processes or recursive procedures or both. The relevance of PRS (and their subclasses) for modelling and analysing programs is shown, for example, in [7]; for automatic verification we refer to surveys [5,19].

1 Email: kretinsky@fi.muni.cz
2 Email: rehak@fi.muni.cz
3 Email: strejcek@fi.muni.cz
4 Supported by Ministry of Education of the Czech Republic, project No. MSM0021622419, and by the Czech Science Foundation, grant No. 201/09/1389.
5 Supported by the research centre “Institute for Theoretical Computer Science (ITI)”, project No. 1M0545, and by the Czech Science Foundation, grant No. 201/08/P459.
6 Supported by the Academy of Sciences of the Czech Republic, grant No. 1ET408050503, and by the Czech Science Foundation, grant No. 201/08/P375.

1571-0661/© 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.05.033

Another merit of PRS is that the reachability problem is decidable for PRS [16]. In [13], we have presented weakly extended PRS (wPRS), where a finite-state control unit with self-loops as the only loops is added to the standard PRS formalism (addi- tion of a general finite-state control unit makes PRS language equivalent to Turing machines). This weak control unit enriches PRS by abilities to model a bounded number of arbitrary communication events and global variables whose values are changed only a bounded number of times during any computation. We have shown that the reachability problem remains decidable for wPRS [12].
One of the mainstreams in an automatic verification of programs is model check- ing. Here we focus on Linear Temporal Logic (LTL). Recall that LTL model checking is decidable for both PDA (EXPTIME-complete [1]) and PN (at least as hard as the reachability problem for PN [6]). Conversely, LTL model checking is undecidable for all the classes subsuming PA [2,15]. So far, there are few positive results for these classes. Model checking of infinite runs is decidable for the PA class and the fragment simple PLTL , see [2], and also for the PRS class and a fragment of LTL expressing exactly fairness properties [3]. Recently, the model checking problem has been shown decidable for (w)PRS and properties given by an LTL fragment LTL(Fs, Gs), i.e. that with operators strict eventually and strict always only, see [4]. Our contribution: As a main result we extend a proof technique used in [4] with past modalities and show that the model checking problem stays decidable even for wPRS and LTL(Fs, Ps), i.e. an LTL fragment with modalities strict eventually and eventually in the strict past (and where strict always and always in the strict past can be used as derived modalities). We note that a role of past operators in program verification is advocated e.g. in [14,9]. Let us mention that the expressive power of the fragment LTL(Fs, Ps) semantically coincides with formulae of First- Order Monadic Logic of Order containing at most 2 variables and no successor predicate (FO2[<]), see [8] for effective translations. Thus we also positively solve
the model checking problem for the wPRS class and FO2[<].

Preliminaries
Weakly Extended PRS (wPRS)
Let Const = {X,.. .} be a set of process constants. A set T of process terms t is defined by the abstract syntax t ::= ε | X | t.t | t  t, where ε is the empty term, X ∈ Const , and ’.’ and ’  ’ mean sequential and parallel compositions, respectively. We always work with equivalence classes of terms modulo commutativity and asso- ciativity of ’  ’, associativity of ’.’, and neutrality of ε, i.e. ε.t = t.ε = t  ε = t.
Let M = {o, p, q,.. .} be a set of control states, ≤ be a partial ordering on this set, and Act = {a, b, c,.. .} be a set of actions. An wPRS (weakly extended process rewrite system) Δ is a tuple (R, p0, t0), where

R is a finite set of rewrite rules of the form (p, t ) ‹a  (q, t ), where t ,t 
∈ T ,

1  →	2	1  2
t1 /= ε, a ∈ Act , and p, q ∈ M satisfy p ≤ q,
the pair (p0, t0) ∈ M ×T forms the distinguished initial state.

By Act (Δ), Const (Δ), and M (Δ) we denote the respective sets of actions, process constants, and control states occurring in the rewrite rules or the initial state of Δ. A wPRS Δ = (R, p0, t0) induces a labelled transition system, whose states are pairs (p, t) such that p ∈ M (Δ) and t is a process term over Const (Δ). The transition relation −→ is the least relation satisfying the following inference rules:


a
((p, t ) ‹
(q, t )) ∈ R
(p, t ) −a→ (q, t )
(p, t ) −a→ (q, t )

	1  →	2	
(p, t1) −a→ (q, t2)
	1	2			1	2	
(p, t1  t' ) −a→ (q, t2  t' )	(p, t1.t' ) −a→ (q, t2.t' )

1	1	1	1
To shorten our notation we write pt in lieu of (p, t). A state pt is called terminal if there is no state p't' and no action a such that pt −a→ p't'. Here, we always consider only such systems where the initial state is not terminal. A (finite or infinite) sequence

σ = p0t0
−a→0
p1t1
−a→1
... −a→n
pn+1tn+1
an
−→ ... 

is called a run of Δ over the word u = a0a1 ... an(an+1 .. .) if it starts in the initial state and, provided it is finite, ends in a terminal state. Further, L(Δ) denotes the set of words u such that there is a run of Δ over u.
If M (Δ) is a singleton, then wPRS Δ is called a process rewrite system (PRS ) [16]. PRS, wPRS, and their respective subclasses are discussed in more detail in [18].
Linear Temporal Logic (LTL) and the Studied Problems
The syntax of Linear Temporal Logic (LTL) [17] is defined as follows
ϕ ::= tt | a | ¬ϕ | ϕ ∧ ϕ | Xϕ | ϕ U ϕ | Yϕ | ϕ S ϕ,
where X and U are future modal operators next and until, while Y and S are their past counterparts previously and since, and a ranges over Act . The logic is inter- preted over infinite and nonempty finite pointed words of actions. Given a word u = a0a1a2 ... ∈ Act ∗ ∪ Act ω, |u| denotes the length of the word (we set |u| = ∞ if u is infinite). A pointed word is a pair (u, i) of a nonempty word u and a position 0 ≤ i < |u| in this word.
The semantics of LTL formulae is defined inductively as follows: (u, i) |= tt
(u, i) |= a	iff  u = a0a1a2 ... and ai = a
(u, i) |= ¬ϕ	iff	(u, i) |= ϕ
(u, i) |= ϕ1 ∧ ϕ2	iff	(u, i) |= ϕ1 and (u, i) |= ϕ2
(u, i) |= Xϕ	iff	i +1 < |u| and (u, i + 1) |= ϕ
(u, i) |= ϕ1 U ϕ2	iff	∃k. i ≤ k < |u|  ∧  (u, k) |= ϕ2 ∧
∧ ∀j. (i ≤ j < k ⇒ (u, j) |= ϕ1)
(u, i) |= Yϕ	iff	0 < i and (u, i − 1) |= ϕ
(u, i) |= ϕ1 S ϕ2	iff	∃k. 0 ≤ k ≤ i  ∧  (u, k) |= ϕ2 ∧

We say that (u, i) satisﬁes ϕ whenever (u, i) |= ϕ. Further, a nonempty word u satisﬁes ϕ, written u |= ϕ, whenever (u, 0) |= ϕ. Given a set L of words, we write L |= ϕ if u |= ϕ holds for all u ∈ L. Finally, we say that a run σ of a wPRS Δ over a word u satisfies ϕ, written σ |= ϕ, whenever u |= ϕ.
Formulae ϕ, ψ are (initially) equivalent, written ϕ ≡i ψ, iff, for all words u, it holds that u |= ϕ ⇐⇒ u |= ψ. Formulae ϕ, ψ are globally equivalent, written ϕ ≡ ψ, iff, for all pointed words (u, i), it holds that (u, i) |= ϕ ⇐⇒ (u, i) |= ψ. Clearly, if two formulae are globally equivalent then they are also initially equivalent.
The following table defines some derived future operators and their past coun- terparts.

Given a set {O1,... , On} of modalities, then LTL(O1,... , On) denotes an LTL fragment containing all formulae with modalities O1,... , On only. Such a frag- ment is called basic if it contains future operators only or with each future op- erator it contains its past counterpart. For example, the fragment LTL(F, S) is not basic. Figure 1 shows an expressiveness hierarchy of all studied basic LTL fragments. Indeed, every basic LTL fragment using standard 7 modalities is equiva- lent to one of the fragments in the hierarchy, where equivalence between fragments means that every formula of one fragment can be effectively translated into an ini- tially equivalent formula of the other fragment and vice versa. We also mind the result of [9] stating that each LTL formula can be converted to the one which em- ploys future operators only, i.e. LTL(U, X) ≡i LTL(U, S, X, Y). However note that LTL(Fs, Ps, Gs, Hs) ≡ LTL(Fs, Ps) is strictly more expressive than LTL(Fs, Gs) as can be exemplified by a formula Fs(b ∧ Hsa) ≡i a ∧ X(a U b). We refer to [20] for greater detail.
This paper deals with the following two verification problems. Let F be an LTL fragment. The model checking problem for F and wPRS is to decide, for any given formula ϕ ∈ F and any given wPRS system Δ, whether L(Δ) |= ϕ holds. Further, given any formula ϕ ∈ F, any wPRS system Δ, and any nonterminal state pt of Δ, the pointed model checking problem for F and wPRS is to decide whether L(pt, Δ) |= ϕ; here L(pt, Δ) denotes the set of all pointed words (u, i) such that

a
Δ has a (finite or infinite) run p0t0 −→
a
p1t1 −→
ai−1
... −→
ai
piti −→
... satisfying

u = a0a1a2 ... and pt = piti.


7 By standard modalities we mean the ones defined here and also other commonly used modalities like strict until, release, weak until, etc. However, it is well possible that one can define a new modality such that there is a basic fragment not equivalent to any of the fragments in the hierarchy.

LTL(U, X) ≡¸i FO3
¸¸¸¸
¸¸¸¸
¸¸¸¸
LTL(U, Fs, S, Ps)
ssss
sss

LTL(F, X, P, Y ) ≡ FO2
,	_	¸
ssss
LTL( U , F )

¸¸¸¸¸	.
¸¸¸ 
¸ s¸ss
sss ¸

c ¸¸¸¸
sss	, 

LTL(F, X)
ı	LTL(Fs, Ps) ≡ FO2[<]  ¸ ¸
LTL(U)

¸¸¸¸¸¸¸ı
¸¸¸¸¸
¸¸¸ ¸ 
	¸¸¸¸
¸ _ _ _ _ _ 

s	¸¸¸ ¸ 
∞	c	 
   
LTL(F , G )
¸¸¸
LTL(F, P)

LTL( F , X)	c	s	s

, ¸ ¸¸¸¸¸
¸¸¸¸¸¸¸

_ _ _ _ _ _
¸ ¸¸¸
¸¸¸¸

¸¸¸¸¸¸¸
¸¸¸¸¸¸¸
¸¸¸¸¸¸¸
¸¸¸
LTL(F, G)

    
LTL(X)
¸¸¸¸¸¸¸
∞
LTL( F)

¸¸¸¸¸
¸¸¸¸¸
¸¸¸¸¸
¸¸¸¸¸
...
...
...
...

LTL()

Fig. 1. The hierarchy of basic LTL fragments with respect to the initial equivalence. The dashed line shows the decidability boundary of the model checking problem for wPRS.

Main Result
In [4], we have shown that the model checking problem is decidable for LTL(Fs, Gs). Before we prove that the problem remains decidable even for a more expressive fragment LTL(Fs, Ps), we recall the basic structure of the proof for LTL(Fs, Gs).
First, the proof shows that every LTL(Fs, Gs) formula can be effectively trans- lated into an equivalent disjunction of so-called α-formulae, which are defined be- low. Note that LTL() denotes the fragment of formulae without any modality,
i.e. boolean combinations of actions. In what follows, we use ϕ1 U+ ϕ2 to abbreviate ϕ1 ∧ X(ϕ1 U ϕ2). Let δ = θ1O1θ2O2 ... θnOnθn+1, where n > 0, each θi ∈ LTL(), On is ‘∧ Gs’, and, for each i < n, Oi is either ‘U’ or ‘U+’ or ‘∧ X’. Further, let B ⊆ LTL() be a finite set. An α-formula is defined as
α(δ, B)= θ1O1(θ2O2 ... (θnOnθn+1) .. .)  ∧   GsFsψ . 
ψ∈B
Hence, a word u satisfies α(δ, B) iff u can be written as a concatenation v1.v2 ... vn+1
of words, where
each word vi consists only of actions satisfying θi and

|vi| ≥ 0 if i = n +1 or Oi is ‘U’,
|vi| > 0 if Oi is ‘U+’,
|vi| =1 if Oi is ‘∧ X’ or ‘∧ Gs’,
and vn+1 satisfies GsFsψ for every ψ ∈ B.
Second, decidability of the model checking problem for LTL(Fs, Gs) is then a di- rect consequence of the following theorem.
Theorem 3.1 ([4]) The problem whether any given wPRS systems has a run sat- isfying any given α-formula is decidable.
To prove decidability for LTL(Fs, Ps), we show that every LTL(Fs, Ps) formula can be effectively translated into a disjunction of Pα-formulae. Intuitively, a Pα-formula is a conjunction of an α-formula and a past version of the α-formula. A formal definition of a Pα-formula makes use of ϕ1 S+ ϕ2 to abbreviate ϕ1 ∧ Y(ϕ1 S ϕ2).
Definition 3.2 Let η = ι1P1ι2P2 ... ιmPmιm+1, where m > 0, each ιj ∈ LTL(), and, for each j < m, Pj is either ‘S’ or ‘S+’ or ‘∧ Y’. Further, let α(δ, B) be an α-formula. Then a Pα-formula is defined as
Pα(η, δ, B)= ι1P1(ι2P2 ... (ιmPmιm+1) .. .)  ∧ α(δ, B) .

Note that the definition of a Pα-formula does not contain any past counterpart of ∧ψ∈BGsFsψ as every history is finite — the semantics of LTL is given in terms of words with a fixed beginning.
Therefore, a pointed word (u, k) |= Pα(η, δ, B) if and only if (u, k) satisfies α(δ, B) and a0 ... ak−1ak can be written as a concatenation vm+1.vm ... v2.v1, where each word vi consists only of actions satisfying ιi and
|vi| ≥ 0 if i = m +1 or Pi is ‘S’,
|vi| > 0 if Pi is ‘S+’,
|vi| =1 if Pi is ‘∧ Y’ or ‘∧ Hs’.
The proof of the following lemma is intuitively clear but it is quite a technical exercise, see [18] for some hints.
Lemma 3.3 Let ϕ be a Pα-formula and p ∈ LTL(). Formulae Xϕ, Yϕ, p U ϕ, p S ϕ, Fsϕ, Ps(ϕ), as well as, a conjunction of Pα-formulae can be effectively converted into a globally equivalent disjunction of Pα-formulae.
Theorem 3.4 Every LTL(Fs, Ps) formula ϕ can be translated into a globally equiv- alent disjunction of Pα-formulae.
Proof. As Fs, Gs and Ps, Hs are dual modalities, we can assume that every LTL(Fs, Gs, Ps, Hs) formula contains negations only in front of actions. Given an LTL(Fs, Gs, Ps, Hs) formula ϕ, we construct a finite set Aϕ of α-formulae such that ϕ is equivalent to the disjunction of formulae in Aϕ. Although our proof looks like by induction on the structure of ϕ, it is in fact by induction on the length of ϕ. Thus, if ϕ /∈ LTL(), then we assume that for every LTL(Fs, Gs, Ps, Hs) formula ϕ' shorter

than ϕ we can construct the corresponding set Aϕ' . In this proof, p represents a formula of LTL(). The structure of ϕ fits into one of the following cases.
p Case p: In this case, ϕ is equivalent to p ∧ Gstt. Hence Aϕ = {Pα(tt ∧ Hstt,p ∧
Gstt, ∅)}.
•∨ Case ϕ1 ∨ ϕ2: Due to induction hypothesis, we can assume that we have sets
Aϕ1 and Aϕ2 . Clearly, Aϕ = Aϕ1 ∪ Aϕ2 .
•∧ Case ϕ1 ∧ ϕ2: Due to Lemma 3.3, Aϕ can be constructed from the sets Aϕ1
and Aϕ2 .
Fs Case Fsϕ1: Due to Lemma 3.3, the set Aϕ can be constructed from the set Aϕ1 .
Ps Case Psϕ1: Due to Lemma 3.3, the set Aϕ can be constructed from the set
Aϕ1 .
Gs Case Gsϕ1 is divided into the following subcases according to the structure of ϕ1 :
p Case Gsp: As Gsp is equivalent to tt ∧ Gsp, we set Aϕ = {Pα(tt ∧ Hstt, tt ∧
Gsp, ∅)}.
◦∧ Case Gs(ϕ2 ∧ ϕ3): As Gs(ϕ2 ∧ ϕ3) ≡ (Gsϕ2) ∧ (Gsϕ3), the set Aϕ can be constructed from AGs ϕ2 and AGs ϕ3 using Lemma 3.3. Note that AGs ϕ2 and AGs ϕ3 can be constructed because Gsϕ2 and Gsϕ3 are shorter than Gs(ϕ2 ∧ ϕ3).
Fs Case GsFsϕ2: This case is again divided into the following subcases.
−p Case GsFsp: As p ∈ LTL(), we directly set Aϕ = {Pα(tt ∧ Hstt, tt ∧
Gstt, {p})}.
−∨ Case GsFs(ϕ3 ∨ ϕ4): As GsFs(ϕ3 ∨ ϕ4) ≡ (GsFsϕ3) ∨ (GsFsϕ4), we set Aϕ =
AGs Fs ϕ3 ∪ AGs Fs ϕ4 .
−∧ Case GsFs(ϕ3 ∧ ϕ4): This case is also divided into subcases depending on the formulae ϕ3 and ϕ4.
∗p Case GsFs(p3 ∧ p4): As p3 ∧ p4 ∈ LTL(), this subcase has already been covered by Case GsFsp.
∗∨ Case GsFs(ϕ3 ∧ (ϕ5 ∨ ϕ6)): As GsFs(ϕ3 ∧ (ϕ5 ∨ ϕ6)) ≡ GsFs(ϕ3 ∧ ϕ5) ∨
GsFs(ϕ3 ∧ ϕ6), we set Aϕ = AGs Fs (ϕ3 ∧ϕ5) ∪ AGs Fs (ϕ3 ∧ϕ6).
∗Fs Case GsFs(ϕ3 ∧ Fsϕ5): As GsFs(ϕ3 ∧ Fsϕ5) ≡ (GsFsϕ3) ∧ (GsFsϕ5), the set
Aϕ can be constructed from AGs Fs ϕ3 and AGs Fs ϕ5 using Lemma 3.3.
∗Ps Case GsFs(ϕ3 ∧ Psϕ5): As GsFs(ϕ3 ∧ Psϕ5) ≡ (GsFsϕ3) ∧ (GsFsPsϕ5), the set Aϕ can be constructed from AGs Fs ϕ3 and AGs Fs Psϕ5 using Lemma 3.3.
∗Gs Case GsFs(ϕ3 ∧ Gsϕ5): As GsFs(ϕ3 ∧ Gsϕ5) ≡ (GsFsϕ3) ∧ (GsFsGsϕ5), the
set Aϕ can be constructed from AGs Fs ϕ3 and AGs Fs Gsϕ5 using Lemma 3.3.
∗Hs Case GsFs(ϕ3 ∧ Hsϕ5): As GsFs(ϕ3 ∧ Hsϕ5) ≡ (GsFsϕ3) ∧ (GsFsHsϕ5), the set Aϕ can be constructed from AGs Fs ϕ3 and AGs Fs Hsϕ5 using Lemma 3.3.
−Fs Case GsFsFsϕ3: As GsFsFsϕ3 ≡ GsFsϕ3, we set Aϕ = AGs Fs ϕ3 .
−Ps Case GsFsPsϕ3: A pointed word (u, i) satisfies GsFsPsϕ3 iff i = |u|− 1 or u is an infinite word satisfying Fϕ3. Note that Gs¬tt is satisfied only by finite words at their last position. Further, a word u satisfies (Fstt) ∧ (GsFstt) iff u is infinite. Thus, GsFsPsϕ3 ≡ (Gs¬tt) ∨ ϕ' where ϕ' = (Fstt) ∧ (GsFstt) ∧ (ϕ3 ∨ Psϕ3 ∨ Fsϕ3). Hence, Aϕ = AGs¬tt ∪ Aϕ' where Aϕ' is constructed from AFs tt,

AGs Fs tt, and Aq3 ∪ APs q3 ∪ AFs q3 using Lemma 3.3.
−Gs Case GsFsGsϕ3: A pointed word (u, i) satisfies GsFsGsϕ3 iff i = |u| − 1 or u is an infinite word satisfying FsGsϕ3. Thus, GsFsGsϕ3 ≡ (Gs¬tt) ∨ ϕ' where ϕ' = (Fstt) ∧ (GsFstt) ∧ (FsGsϕ3). Hence, Aq = AG ¬tt ∪ Aq' where Aq' is constructed from AFs tt, AGs Fs tt, and AFs Gs q3 using Lemma 3.3.
−Hs Case GsFsHsϕ3: A pointed word (u, i) satisfies GsFsHsϕ3 iff i = |u|− 1 or
u is an infinite word satisfying Gϕ3. Thus, GsFsHsϕ3 ≡ (Gs¬tt) ∨ ϕ' where ϕ' = (Fstt)∧(GsFstt)∧(ϕ3 ∧Hsϕ3 ∧Gsϕ3). Hence, Aq = AG ¬tt ∪Aq' where Aq' is constructed from AFs tt, AGs Fs tt, Aq3 , AHs q3 , and AGs q3 using Lemma 3.3.
Ps Case GsPsϕ2: A pointed word (u, i) satisfies GsPsϕ2 iff i = |u| − 1 or (u, i)
satisfies Pϕ2. Hence, Aq = AGs¬tt ∪ Aq2 ∪ APs q2 .
◦∨ Case Gs(ϕ2 ∨ ϕ3): According to the structure of ϕ2 and ϕ3, there are the following subcases.
−p Case Gs(p2 ∨p3): As p2∨p3 ∈ LTL(), this subcase has already been covered by Case Gsp.
−∧ Case Gs(ϕ2∨(ϕ4∧ϕ5)): As Gs(ϕ2∨(ϕ4∧ϕ5)) ≡ Gs(ϕ2∨ϕ4)∧Gs(ϕ2∨ϕ5), the set Aq can be constructed from AGs(q2 ∨q4) and AGs(q2 ∨q5) using Lemma 3.3.
−Fs Case Gs(ϕ2 ∨ Fsϕ4): It holds that Gs(ϕ2 ∨ Fsϕ4) ≡ (Gsϕ2) ∨ Fs(Fsϕ4 ∧
Gsϕ2) ∨ GsFsϕ4. Therefore, the set Aq can be constructed as AGsq2 ∪ AFs(Fs q4∧Gs q2) ∪ AGsFs q4 , where AFs(Fs q4 ∧Gsq2 ) is obtained from AFs q4 and AGsq2 using Lemma 3.3.
−Hs Case Gs(ϕ2∨Hsϕ4): As Gs(ϕ2∨Hsϕ4) ≡ (Gsϕ2)∨Fs(Hsϕ4∧Gsϕ2)∨GsHsϕ4. Hence, Aq = AGsq2 ∪ AFs(Hsq4∧Gsq2) ∪ A(GsHsq4) where AFs(Hsq4∧Gsq2) can be obtained from AHsq4 and AGs q2 using Lemma 3.3.
−Gs, Ps There are only the following six subcases (the others fit to some of the
previous cases).
Case  Gs(  q'∈G Gsϕ'):	It holds that Gs( q'∈G Gsϕ') ≡  (Gs¬tt) ∨

q'∈G
(XGsϕ').	Therefore, the set Aq can be constructed as AG ¬tt ∪

A	' where each A	' is obtained from A	' using Lemma 3.3.
Case  Gs(p2 ∨  q'∈G Gsϕ'):	As Gs(p2 ∨  q'∈G Gsϕ') ≡  (Gsp2) ∨

q'∈G
(X(p2 U (Gsϕ'))),  the set Aq  can be constructed as AG p  ∪


 q'∈G AX(p2 U (Gs q')) where each AX(p2 U (Gs q')) is obtained from AGs q' us- ing Lemma 3.3.
Case Gs( q''∈P Psϕ''):  It holds that Gs( q''∈P Psϕ'') ≡ (Gs¬tt) ∨

q''∈P
(XPsϕ'').	Therefore, the set Aq can be constructed as AG ¬tt ∪

A	'' where each A	'' is obtained from A	'' using Lemma 3.3.
Case Gs(p2 ∨  q''∈P Psϕ''):	As Gs(p2 ∨  q''∈P Psϕ'') ≡ (Gsp2) ∨

q''∈P
(X(p2 U (Psϕ''))), the set Aq  can be constructed as AG p  ∪

q''∈P AX(p2 U (Ps q'')) where each AX(p2 U (Ps q'')) is obtained from APs q'' using
Lemma 3.3.
Case Gs( q'∈G Gsϕ' ∨  q''∈P Psϕ''): As Gs( q'∈G Gsϕ' ∨  q''∈P Psϕ'') ≡ (G ¬tt) ∨	(XG ϕ') ∨	(XP ϕ''), the set A can be constructed as AGs¬tt ∪ q'∈G AXGs q' ∪ q''∈P AXPs q'' where each AXGs q' is obtained from AGs q' and each AXPs q'' is obtained from APs q'' using Lemma 3.3.

Case G (p  ∨	G ϕ' ∨	P ϕ''):  As G (p  ∨	G ϕ' ∨
 q''∈P Psϕ'') ≡ (Gsp2) ∨  q'∈G(X(p2 U (Gsϕ'))) ∨  q''∈P (X(p2 U (Psϕ''))), the set	can be constructed as
 q''∈P AX(p2 U (Ps q'')) where each AX(p2 U (Gs q')) is obtained from AGs q' and each AX(p2 U (Ps q'')) is obtained from APs q'' using Lemma 3.3.
Gs Case GsGsϕ2:  As Gs(Gsϕ2) ≡ (Gs¬tt) ∨ (XGsϕ2), the set Aq can be
constructed as AGs¬tt ∪ AXGs q2 where AXGsq2 is obtained from AGsq2 using Lemma 3.3.
Hs Case GsHsϕ2: A pointed word (u, i) satisfies Gs(Hsϕ2) iff i = |u| − 1 or (u, |u|− 1) satisfies Hsϕ2 or u is infinite and all its positions satisfy ϕ2. Hence, Aq = AGs¬tt ∪ AFs((Gs¬tt)∧(Hsq2)) ∪ A(Hsq2)∧q2∧(Gsq2) where AFs((Gs¬tt)∧(Hsq2)) and A(Hs q2 )∧q2 ∧(Gs q2) are obtained from AGs¬tt, AHs q2 , Aq2 , and AGs q2 using Lemma 3.3.
Hs Case Hsϕ1: This case is divided into the following subcases according to the structure of ϕ1.
p Case Hsp: As Hsp is globally equivalent to tt ∧ Hsp, we set Aq = {Pα(tt ∧
Hsp, tt ∧ Gstt, ∅)}.
◦∧ Case Hs(ϕ2 ∧ ϕ3): As Hs(ϕ2 ∧ ϕ3) ≡ (Hsϕ2) ∧ (Hsϕ3), the set Aq can be constructed from AHsq2 and AHsq3 using Lemma 3.3.
Fs Case HsFsϕ2: A pointed word (u, i) satisfies HsFsϕ2 iff i =0 or (u, i) satisfies
Fϕ2. Note that Hs¬tt is satisfied by (u, i) only if i = 0. Therefore, Aq =
AHs¬tt ∪ Aq2 ∪ AFsq2 .
Ps Case HsPsϕ2: A pointed word (u, i) satisfies HsPsϕ2 iff i = 0. Therefore,
Aq = AHs¬tt.
◦∨ Case Hs(ϕ2 ∨ ϕ3): According to the structure of ϕ2 and ϕ3, there are the following subcases.
−p Case Hs(p2∨p3): As p2∨p3 ∈ LTL(), this subcase has already been covered by Case Hsp.
−∧ Case Hs(ϕ2 ∨ (ϕ4 ∧ ϕ5)): As Hs(ϕ2 ∨ (ϕ4 ∧ ϕ5)) ≡ Hs(ϕ2 ∨ ϕ4) ∧ Hs(ϕ2 ∨ ϕ5), the set Aq can be constructed from AHs(q2 ∨q4) and AHs(q2 ∨q5 ) using Lemma 3.3.
−Ps Case Hs(ϕ2 ∨Psϕ4): It holds that Hs(ϕ2 ∨Psϕ4) ≡ (Hsϕ2)∨Ps(Psϕ4 ∧Hsϕ2). Therefore, the set Aq can be constructed as AHs q2 ∪ APs(Ps q4∧Hs q2), where APs(Ps q4 ∧Hsq2 ) is obtained from APsq4 and AHs q2 using Lemma 3.3.
−Gs Case Hs(ϕ2 ∨ Gsϕ4): As Hs(ϕ2 ∨ Gsϕ4) ≡ (Hsϕ2) ∨ Ps(Gsϕ4 ∧ Hsϕ2), Aq is
constructed as AHs q2 ∪ APs(Gs q4∧Hs q2) where APs(Gs q4∧Hs q2) is obtained from
AGs q4 and AHs q2) using Lemma 3.3.
−Fs, Hs There are only the following six subcases (the others fit to some of the previous cases).
Case  Hs(  q'∈F Fsϕ'):	It holds that Hs( q'∈F Fsϕ') ≡  (Hs¬tt) ∨

q'∈F
(YFsϕ').	Therefore, the set Aq can be constructed as AH ¬tt ∪

A	' where each A	' is obtained from A	' using Lemma 3.3.
Case  Hs(p2 ∨  q'∈F Fsϕ'):	As Hs(p2 ∨  q'∈F Fsϕ') ≡  (Hsp2) ∨

q'∈F
(Y(p2 S (Fsϕ'))),  the set Aq  can be constructed as AH p	∪

q'∈F AY(p2 S (Fs q')) where each AY(p2 S (Fs q')) is obtained from AFs q' using Lemma 3.3.
Case Hs( q''∈H Hsϕ''): It holds that Hs( q''∈H Hsϕ'') ≡ (Hs¬tt) ∨

q''∈H
(YHsϕ''). Therefore, the set Aq can be constructed as AH ¬tt ∪


 q''∈H AYHsq''	where each AYHs q''	is obtained from AHs q''	using Lemma 3.3.
Case Hs(p2 ∨  q''∈H Hsϕ''):  As Hs(p2 ∨  q''∈H Hsϕ'') ≡ (Hsp2) ∨

q''∈H
(Y(p2 S (Hsϕ''))), the set Aq  can be constructed as AH p  ∪

q''∈H AY(p2 S (Hs q'')) where each AY(p2 S (Hs q'')) is obtained from AHs q'' us-
ing Lemma 3.3.
Case Hs( q'∈F Fsϕ' ∨  q''∈H Hsϕ''): As Hs( q'∈F Fsϕ' ∨  q''∈H Hsϕ'') ≡ (H ¬tt) ∨	(YF ϕ') ∨	(YH ϕ''), the set A can be constructed as AHs¬tt ∪ q'∈F AYFs q' ∪ q''∈H AYHs q'' where each AYFs q' is obtained from AFs q' and each AYHsq'' is obtained from AHsq'' using Lemma 3.3.
Case H (p  ∨	F ϕ' ∨	H ϕ''):  As H (p  ∨	F ϕ' ∨
q''∈H Hsϕ'') ≡ (Hsp2) ∨	q'∈F (Y(p2 S (Fsϕ'))) ∨	q''∈H (Y(p2 S (Hsϕ''))), the set A	can be constructed as A	∪		A	'	∪
 q''∈H AY(p2 S (Hs q'')) where each AY(p2 S (Fs q')) is obtained from AFs q' and each AY(p2 S (Hsq'')) is obtained from AHs q'' using Lemma 3.3.
Gs Case HsGsϕ2: A pointed word (u, i) satisfies Hs(Gsϕ2) iff i = 0 or (u, 0)
satisfies Gsϕ2. Hence, Aq = AHs¬tt ∪ APs((Hs¬tt)∧(Gsq2)) where APs((Hs¬tt)∧(Gsq2))
is obtained from AHs¬tt and AGs q2 using Lemma 3.3.
Hs Case HsHsϕ2: As Hs(Hsϕ2) ≡ (Hs¬tt) ∨ (YHsϕ2), the set Aq can be constructed as AHs¬tt ∪ AYHsq2 where AYHs q2 is obtained from AHs q2 using Lemma 3.3.
 
Remark 3.5 In other words, we have just shown that LTL(Fs, Ps) is a semantic subset (with respect to global equivalence) of every formalism that is (i) able to express p, Gsp, Hsp, and GsFsp, where p ∈ LTL(); and (ii) is closed under disjunction, conjunction, and applications of X , Y , p U , and p S , where p ∈ LTL().
Now, using Theorem 3.1, we can easily solve the problem dual to the model checking problem, i.e. given any wPRS system and any Pα-formula, to decide whether the system has a run satisfying the formula.
Theorem 3.6 The problem whether any given wPRS system has a run satisfying a given Pα-formula is decidable.
Proof. A run over a nonempty (finite or infinite) word u = a0a1a2 ... satisfies a formula ϕ iff (u, 0) |= ϕ. Moreover, (u, 0) |= Pα(η, δ, B) iff (a0, 0) |= η and (u, 0) |= α(δ, B). Let η = ι1P1ι2P2 ... ιmPmιm+1. It follows from the semantics of LTL that (a0, 0) |= η if and only if (a0, 0) |= ιm and Pi = S for all i < m. Therefore, the problem is to check whether Pi = S for all i < m and whether the given wPRS system has a run satisfying ιm ∧ α(δ, B). As ιm ∧ α(δ, B) can be easily translated into a disjunction of α-formulae, Theorem 3.1 finishes the proof.	 

As LTL(Fs, Ps) is closed under negation, Theorem 3.4 and Theorem 3.6 give us the following.
Corollary 3.7 The model checking problem for wPRS and LTL(Fs, Ps) is decidable.
Moreover, we can show that the pointed model checking problem is decidable for wPRS and LTL(Fs, Ps) as well. Again, we solve the dual problem.
Theorem 3.8 Let Δ be a wPRS and pt be a reachable nonterminal state of Δ. The problem whether L(pt, Δ) contains a pointed word (u, i) satisfying any given Pα-formula is decidable.
Proof. Let Δ = (M, ≥, R, p0, t0) be a wPRS and pt be a reachable nonterminal state of Δ. We construct a wPRS Δ' = (M, ≥, R', p0, t0.X) where X /∈ Const (Δ) is a fresh process constant, f /∈ Act (Δ) is a fresh action,
R' = R ∪ {(p(t.X) ‹a pX ), (pX ‹f  pY ), (pY ‹a p't') | pt —a→ p't'},
→	a	a →	a	a →
and Xa, Ya /∈ Const (Δ) are fresh process constants for each a ∈ Act (Δ).
It is easy to see that (u, i) is in L(pt, Δ) iff u = a0a1 ... ai−1ai.f.ai.ai+1 ... is in L(Δ'). Hence, for any given Pα-formula ϕ = Pα(η, δ, У) we construct a Pα-formula ϕ' = Pα(η, tt Λ Xf Λ Xδ, У). We get that
L(pt, Δ) |= Pα(η, δ, У)	⇐⇒	L(Δ') |= F(Pα(η, tt Λ Xf Λ Xδ, У))
and due to Lemma 3.3 and Theorem 3.6 the proof is done.	 
As LTL(Fs, Ps) is closed under negation and Theorem 3.4 works with global equivalence, Theorem 3.8 give us the following.
Corollary 3.9 The pointed model checking problem is decidable for wPRS and LTL(Fs, Ps).

Conclusion
We have examined the model checking problem for basic LTL fragments with both future and past modalities and the PRS class, i.e. the class of infinite state system generated by Process Rewrite Systems (PRS), possibly enriched with a weak finite control unit (weakly extended PRS – wPRS). We have proved that the problem is decidable for wPRS and LTL(Fs, Ps), i.e. the fragment with modalities strict even- tually, eventually in the strict past, and derived modalities strict always and always in the strict past. 8 However, both these problems are at least as hard as the reach- ability problem for PN [6] (EXPSPACE-hard without any elementary upper bound known).
Note that the expressive power of the fragment LTL(Fs, Ps) semantically coincides with formulae of First-Order Monadic Logic of Order containing at most 2 variables

8 In fact, we have shown that the problem is decidable even for a more expressive fragment containing negations of disjunctions of so-called Pα-formulae (see Definition 3.2).

and no successor predicate (FO2[<]), and that First-Order Monadic Logic of Order containing at most 2 variables (FO2) coincides with an LTL(F, X, P, Y) fragment [8]. Further, let us recall our undecidability results for model checking of PA systems
∞
(a subclass of PRS) and fragments LTL( F , X) and LTL( U ), respectively (the former
with modalities inﬁnitely often and next only, the latter with until as the only modality), see [4].
Thus, we have located the borderline between decidability and undecidability of the problem for wPRS and the LTL fragments, as well as for wPRS and First-Order Monadic Logic of Order: it is decidable for FO2[<] and undecidable for FO2. For the sake of completeness, we note that the First-Order Monadic Logic of Order containing at most 3 variables (FO3) coincides with the set of all LTL formulae as well as with the full First-Order Monadic Logic of Order [11,10]. Finally, we note that the decidability results are new for the PRS class too and they are illustrated by the decidability border in Figure 1.

References
Bouajjani, A., J. Esparza and O. Maler, Reachability Analysis of Pushdown Automata: Application to Model-Checking, in: Proc. of CONCUR’97, LNCS 1243, 1997, pp. 135–150.
Bouajjani, A. and P. Habermehl, Constrained Properties, Semilinear Systems, and Petri Nets, in:
Proc. of CONCUR’96, LNCS 1119 (1996), pp. 481–497.
Bozzelli, L., Model checking for process rewrite systems and a class of action-based regular properties, in: Proc. of VMCAI’05, LNCS 3385 (2005), pp. 282–297.
Bozzelli, L., M. Kˇret´ınsky´, V. Rˇeha´k and J. Strejˇcek, On decidability of LTL model checking for process rewrite systems, in: FSTTCS 2006, LNCS 4337 (2006), pp. 248–259.
Burkart, O., D. Caucal, F. Moller and B. Steffen, Verification on infinite structures, in: Handbook of Process Algebra (2001), pp. 545–623.
Esparza, J., On the Decidability of Model Checking for Several mu-calculi and Petri Nets, in: CAAP, LNCS 787 (1994), pp. 115–129.
Esparza, J., Grammars as Processes, in: Formal and Natural Computing, LNCS 2300 (2002), pp. 277–297.
Etessami, K., M. Y. Vardi and T. Wilke, First-order logic with two variables and unary temporal logic, Information and Computation 179 (2002), pp. 279–295.
Gabbay, D., The Declarative Past and Imperative Future: Executable Temporal Logic for Interactive Systems, in: Temporal Logic in Specification, LNCS 398, 1987, pp. 409–448.
Gabbay, D., A. Pnueli, S. Shelah and J. Stavi, On the Temporal Analysis of Fairness, in: Conference Record of the 7th Annual ACM Symposium on Principles of Programming Languages (POPL’80) (1980), pp. 163–173.
Kamp, J. A. W., “Tense Logic and the Theory of Linear Order,” Ph.D. thesis, University of California, Los Angeles (1968).
Kˇret´ınsky´, M., V. Rˇeha´k and J. Strejˇcek, Extended Process Rewrite Systems: Expressiveness and Reachability, in: Proceedings of CONCUR’04, LNCS 3170 (2004), pp. 355–370.
Kˇret´ınsky´, M., V. Rˇeha´k and J. Strejˇcek, On Extensions of Process Rewrite Systems: Rewrite Systems with Weak Finite-State Unit, in: Proceedings of INFINITY’03, Electr. Notes Theor. Comput. Sci. 98 (2004), pp. 75–88.
Lichtenstein, O., A. Pnueli and L. D. Zuck, The Glory of The Past, in: Logic of Programs, LNCS 193, 1985, pp. 196–218.

Mayr, R., “Decidability and Complexity of Model Checking Problems for Infinite-State Systems,” Ph.D. thesis, Technische Universit¨at Mu¨nchen (1998).
Mayr, R., Process rewrite systems, Information and Computation 156 (2000), pp. 264–286.
Pnueli, A., The Temporal Logic of Programs, in: Proc. 18th IEEE Symposium on the Foundations of Computer Science, 1977, pp. 46–57.
Rˇeh´ak, V., “On Extensions of Process Rewrite Systems,” Ph.D. thesis, Faculty of Informatics, Masaryk University, Brno (2007).
Srba, J., “Roadmap of Infinite Results,” Current Trends In Theoretical Computer Science, The Challenge of the New Century Vol 2: Formal Models and Semantics, World Scientific Publishing Co., 2004, 337–350 pp.
Strejˇcek, J., “Linear Temporal Logic: Expressiveness and Model Checking,” Ph.D. thesis, Faculty of Informatics, Masaryk University, Brno (2004).
