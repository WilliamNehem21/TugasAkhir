Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 289 (2012) 41–51
www.elsevier.com/locate/entcs

Normalisation of Loops with Covariant Variables
Marianne De Michiel1 Armelle Bonenfant1 Hugues Cass´e1
IRIT
Universit´e de Toulouse Toulouse, France

Abstract
Temporal property verification is utterly important to ensure safety of critical real-time systems. A main component of this verification is the computation of Worst Case Execution Time (WCET) that requires, in turn, the determination of loop bounds. Although a lot of efforts have been performed in this domain, it remains relatively common cases which are unsolved. For example, to our knowledge, no fast automatic method can cope with the loop bound of a simple binary search look-up. In this paper, we present an approach to solve such loops by using arithmetico-geometric series, that is, loops with arithmetic and/or geometric incrementation with several variables. We have implemented and experimented this approach in our tool oRange.
Keywords: Timing analysis, worst-case execution time, loop bound analysis, abstract interpretation


Introduction
Critical hard real-time systems are composed of tasks which must imperatively finish before their deadline. In order to guarantee this, a task scheduling analysis, which requires the knowledge of the WCET of each task, is performed.
The static WCET analysis is performed by a timing analysis tool which needs loop upper bounds. Such bounds may be given by the developer with manual annotations in the programs or by automatic evaluation. The automatic approach is more user-friendly and less error-prone but no automatic method for loop bounds analysis can give an exact answer for all loops. This paper presents a new method to extend the domain of computable loop bounds with covariant induction variables. We focus on finding a numeric value for a bound (iteration number), not on the termination of the program [4]. The WCET quality depends on the quality of the found bounds.

1 Email: {michiel,bonenfant,casse}@irit.fr


1571-0661 © 2012 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2012.11.005

Several approaches have been explored in flow analysis concerning loop bounds [2,1,7,11,14,5]. Most of these approaches use Abstract Interpretation [6] to build a map which associates to the variables an abstract representation of its value. This permits to give safe, but possibly overestimated, sets of the states at the different program points.
A classical example of binary search is the program ”bs.c” of the Ma¨lardalen benchmark suite [3]. According to our knowledge the only approach resolving it are described in [14] and in [9]. Yet, [14] uses model checking by Binary Tightening and Widening and embedded it into a more general approach using a set of analysis methods. As an overall result it increases computational complexity for proving or dis-proving relevant time bounds of a program. SWEET [9] resolves loop bounds by using abstract execution that expands each loop iteration. In both cases, the genericity of the solution is at the cost of computation time, sometimes prohibitive. Moreover these tools obtain loop bound values and cannot be instanciated in dif- ferent call contexts.
In [12] 74% bounds of M¨alardalen benchmark loops are successfully computed, but there is no detail on which loops are processed (especially ”bs.c”).
oRange [13] combines loop bound expression built on C programs with abstract interpretation. For a loop Li, two kinds of loop bounds are computed: totali (the total number of iterations in the overall execution of the program) and maxii (the maximum number of iterations for each loop start-up). The analysis proceeds in three steps: 1) context-insensitive identification and normalization of increment and loop bound expressions [8], 2) context sensitive construction of totali and maxii symbolic expressions, and finally 3) computation final totali and maxii expressions and values. oRange supports numerous condition types (including && for example), the most frequent induction variable expressions (i.e. expressions containing +,-
,×, /) and any type of C loop statements. The complex control flow statements (break, goto, etc) are processed by a semantics-preserving simplifier of the program representation. Complete description of oRange can be found in [13].
This paper is organised as follow: Section 2 is the motivation , Section 3 presents our method, Section 3.5 describes some limitations of the method, Section 4 is a typical example and we conclude in Section 5.


Bounding loops with arithmetico-geometric series
In the program below the function oracle returns an integer, possibly random, value:

Example 1: Basic Covariance
void main () {
int i = 0 , j = 10; while ( i < j) {
if( oracle ()) i = ( i + j) / 2; else j = ( i + j) / 2;
}
}

The iteration number of the while loop depends on both variables, i and/or j, which are separately modified in both branches of the selection. As these variables are condition induction variables, they are called covariant and the loop iteration bound requires to survey the covariation of these variables. This type of loop is called covariant.
The goal of normalisation is to get a loop for which the loop variable get through all values of [0..borneMax] incrementing by 1. This permits to simplify computation, especially in case of nested loops.
In the initial analysis performed by oRange, if two or more paths lead to different incrementations of a condition induction variable, the associated increment value is approximated by T (any possible incrementation) because we cannot support multiple incrementations. To survey how both variables i and j evolve, a new meta-variable X is introduced such that X = j − i sums up the evolution of i and j for the loop condition. X is a temporary variable which permits to process the regular normalization. To achieve this, we insert at the end of each block containing
i or j modifications, a new assignment for X to take into account the effect of i and
j changes on X. The if instruction of the example 1 becomes now:

Example 2: Introducing X for series determination
if( oracle ()){ 
i = ( i + j) / 2;
X = j - i;
}
else {
j = ( i + j) / 2;
X = j - i;
}

Then, X is analyzed and the application of the variable rewriting algorithm of oRange on the assignment of the then-part of the selection produces Xn → jn−1 − (in−1 + jn−1)/2= (jn−1 − in−1)/2, that is, Xn = Xn−1/2. The assignment of the else-part is processed in the same way: Xn → (in−1 + jn−1)/2 − in−1 = (jn−1 − in−1)/2, that is, Xn = Xn−1/2. Finally, the forms of X on each branch can be joined to obtain, in this particular case, the geometric series Xn = Xn−1/2.
If the join can produce known series, the initial program is rewritten to embed X as a condition induction variable (initialization, loop condition, body incrementa- tion) whose bound represents a safe estimation of the whole loop bound (as below).

Example 3: Final rewriting of the loop
void main () {
int i=0 , j=10 , X;
X = j - i;
while (0 < X && i < j) {
if ( oracle ()) i = ( i + j ) / 2; else	j = ( i + j) / 2;
X = X /2;
}
}
The first approach is correct (trivial by renaming) when the induction variables are floating point values. The integers make things a bit trickier because of prop- erties of discrete arithmetics for division and modulo. In fact, the series we obtain

for integer cases (X has the form X = X ∗ q + k with 0 < q < 1) do not always bound the actual executed series.
A table like table 1 represents the trace of a loop and will be used further. The two first columns represent the variation of i, j variables, the third column is the comparison used as right member of the loop condition. The X column is the values of X and the last is the values of the left member of the loop condition. The two last columns are the representation of the modified loop. We compare the behavior of the two conditions (i < j and 0 < X) in order to exhibit when X is not an adequate series. X represents the exact series if for all trace the two conditions change of value simultaneously, if the 0 < X changes ultimately after the other one, then we have found an overestimation. Otherwise, the series cannot bound the loop properly.
Table 1
Trace of example 3 and 3 corrected (X = X/2+ 1)
(a) without/with X condition	(b) example 3 corrected
Indeed, the table 1 (a) shows that the loop of example 1 (second column) do not terminate before to the rewritten loop of example 3 (fifth column) because of the condition 0 < X. Series Xn = Xn−1/2 is not a correct model of the loop bound.
The real loop series have to be fixed bya constant E so as to ensure that the new series gives a sound upper bound of the real series (see proof in appendix 6). We
define E = n.m.(k−1) + m.(k−1) where n is the number of induction variables, m the
k	k
number of terms divided and k = 1/q the constant divisor of each term. In example
3, n = 2, m = 1 and k = 2 so E = 2(2 − 1)/2 = 1. So the resulting arithmetico- geometric series is Xn = Xn−1/2 + 1. By replacing X = X/2 by X = X/2+1 in example 3, we get the new trace displayed in table 1 (b). As expected, the loop of Example 1 and the rewritten one exhibit now the same behaviour (no termination in some cases).
Method
To solve this problem, we have to detect the covariant loops, insert X variable pro- cessing and bound X based on arithmetico-geometric series properties. This applies only in the first analysis step: the next two steps of oRange remain unchanged.
The original abstract interpretation performed in oRange uses the domain of abstract stores, AS: AS : Id → Expr where Id are the variables of the C program and Expr are C expressions. This domain is applied on the program using update: Stmt × AS → AS that asserts the effects of a statement s ∈ Stmt on the program σ ∈ AS and using join : AS × AS → AS that merges the abstract stores of two

execution paths.
In order to compute covariance, we extend it to AS∗ : Id ∪ X → Expr where X is the set of X meta-variables (which are introduced to represent the covariant variables). The update and join functions remain the same for each variable v ∈/ X. The aim of the following paragraphs is now to define updatej and joinj, respectively, update and join functions for X variables. From this, update∗ and join∗ are easily defined by:
updatej(s, σ) if s = [X = e],X ∈ X
update∗(s, σ)= 
⎩ update(s, σ) otherwise
⎨ σ[X]= join∗(σ1, σ2)[X] if X ∈ X

join∗(σ1, σ2)= σ s.t.

Deﬁnitions
⎩ σ[v]= joinj(σ1, σ2)[v] otherwise

Let L be a loop, c ∈ Expr its condition (expression) and b ∈ Stmt its body. Let LVE (c) be the set of variables in c and LVA(b) the set of variables assigned inside b. Let I = LVE (c)  LVA(b) and n = |I| the number of condition induction variables in c. If n > 1 and c is a binary expression of the form exp = exp1 op exp2 2 where op ∈ {<, ≤, ≥, >} and at least ∃x ∈ I, ∃y ∈ I such as x and y are modified at least in two different paths of b, then x and y are covariant variables.

Condition and its Induction Variable
We show here how to determine the performed increments in the loop body and how to check if they can be processed. Our current analysis only supports affine forms (exp = k0 + Σi∈[1..n]ki × xi).
Let ki be the coefficient of the variable xi ∈ LVE (exp). ki are in Z or in R depending on the type of the comparison operator. If all ki can be resolved, we can find the increment of loop variables: X = Σi∈[1..n]ki × xi.
In order to replace the analysis of the covariant variables by the one of X, we insert in the code the assignment X = Σi∈[1..n]ki × xi into specific places: before the loop body and after each block modifying an xi. In addition, the condition c is replaced by cj =0 op X + k0 && c. This definition allows to cope with bound of X even if an overestimation of X is exhibited.

Increment Evaluation
In this exploration step, we consider that the incrementation of induction variable is only performed in the body of the loop and neither in called functions nor in the body of an internal loop. In the actual implementation, we consider that in the

2 exp = exp1 op exp2 when op ∈ {>, ≥} and exp = exp2 op exp1 if op ∈ {<, ≤} to have only to support <
or ≤ comparators

later cases the incrementation cannot be analyzed (although a conservative specific value of T is assumed).
In order to shorten the presentation, we only present cases where induction variables are modified in sequence or in conditional paths. Actually, other cases are processed in the actual implementation.
Abstract interpretation applies to a sequence of instructions and an abstract store σ and result in a new abstract store. Initial context is σ0 = ∅. The statements are evaluated in sequence. Let pl be the last evaluated program point and σpl its context. We evaluate the next point pj with σpl as input abstract store and the statement after the program point pl to the program point pj. The result is the output context σpl and X symbolic expression.
Example 4: Computation points location
while (...) {	// p0
if ( oracle ()) {
i = ( i + j) / 2;
X = j - i;	// p1
}
else {
j = ( i + j) / 2;
X = j - i;	// p2
}	// p3
}
The first evaluation, in p1 obtains X → j - (i + j) / 2. The second one, in p2 obtains X → (i + j) / 2 - i. According to the symbolic form of X at point pj, we try to identify a form such as X → qjX + kj0 known as arithmetic-geometric series [10]. We search if Eqj ≥ 0 s.t. 6i ∈ [1..n] kj = qj × kj,i. If we do not find the suitable form, the X is evaluated to T.
Increment evaluation in a sequence: updatej
Let X = q1X + k10 be the first assignment of X in a sequence, and X = q2X + k20
be the following one.
Table 2
update′


* when this X value is propagated along the paths, if it leads to exit the loop, then the loop is bounded, otherwise the loop may never terminate.
To enlarge the application domain of oRange, the covariance coefficients q and k are not only single values but may also be sets noted SET (q1, q2) 3 where q1, q2 are single values. In order to apply this representation to our arithmetic-geometric

3 oRange bounds the set to two values in order to avoid complexity explosion. Bigger sets are abstracted to T.

series, we redefine operators (+, ×...) for SET in table 3, where q1, q2 are single values.
Table 3 Sequential operators




Increment evaluation of joinj
In the case of two expressions in X: one into each part of join, we set X = q1X + k10 and X = q2X + k20 as the two X assignments to join. The resulting increment depends on the four next ordered cases else it is undefined (T). joinj uses the operation compose defined in the table 4.
if q1 = 0 and if this X assignment is the one which leads to exit the loop, then X = q2X + k20 is the default increment. When the first branch of if is executed, either the constant value of X gives that the loop condition is false at the next iteration so the maximum number of iteration of the loop is obtained when the second branch is always executed. Either the loop condition is true so the loop may never terminate (resp. if q2 = 0 is the last iteration case then X = q1X + k10) else it is undefined.
if q1 = q2 = 1 then it is a classical arithmetic form: if k10 ×k20 > 0 the resulting assignment of X is X = X + compose(k10, k20) else it is undefined.
if k10 = k20 = 0 then it is a classical geometric form: if (q1 < 1 and q2 < 1) or (q1 > 1 and q2 > 1) the resulting assignment of X is X = X × compose(q1, q2) else it is undefined.
else it is a arithmetico-geometric form, the resulting increment is:
if (q1 < 1 and q2 < 1 and k10 < 0 and k20 < 0) or (q1 > 1 and q2 > 1 and
k10 > 0 and k20 > 0) then the series is bounded by X = X × compose(q1, q2)
+compose(k10, k20) else it is undefined.
Table 4
compose


We apply increment evaluation in example 5. When compare() == 0, X = i − 1 − i = 1, the test 0 < X is false it is the last loop iteration. The loop bound is obtained when this case is never taken. The obtained incrementation is

X = X/2 − 1. The adjustment is E = n.m.(k−1) + m.(k−1)
= 2(2 − 1)/2 = 1. So

k	k
the resulting arithmetico-geometric series are Xn = Xn−1/2 − 1 + 1, pure geometric
series. This sample 5 is equivalent to ”bs.c”.
Example 5: Increment evaluation application
void main () {
int i = 0 , j = 10; while ( i < j) {
if( compare ()==0) j= i -1 ; else
if( compare () >0) j= ( i + j) / 2 - 1; else i = ( i + j) / 2 + 1 ;
}
}


The arithmetico-geometric form
We consider strictly decreasing or increasing forms. Other forms are undefined. Classical arithmetic or geometric forms are not considered here (previous cases). We want to translate it into a geometric form using mathematical results. In order to do that, we replace the X series by new series V where Vn = Xn + c and c = −k10/(1 − q1). The normalisation is done by introducing V assignment in place of X one and change the condition according to V variable.
If it is not possible (because of SET), sometimes we may approximate the form X = q1X + k10 by bounding arithmetic (see the next ordered formulea) or geometric series.
if lower (q1) = 1 then if lower (k10)> 0.0 then X = X + k10 else undefined.
Ex.X = X × SET (2, 1) + 1 then a bound is X = X +1 
if upper (q1)= 1 then if upper (k10)< 0.0 then X = X + k10 else undefined.
Ex. X = X ×SET (1/2, 1) − 1 then a bound is X = X − 1
if q1 > 1 then
if X > 0 then X = q1X
if X ≥ 0 then the same as in the previous case with +1 for the loop bound because if X = 0 when k10 is positive the loop increases too.
else undefined
if 0 < q1 < 1
if X > 0 then X = q1X
if X ≥ 0 then the same as in the previous case with +1 for the loop bound because if X = 0 when k10 is negative the loop decreases too.
else undefined
Definition: Let q1 ∈ C and q2 ∈ C. Let lower (q1) (respectively lower (q2))=
if q1 ∈ R then if q1
if q1 = SET (f1, f2) then min(f1, f2) (respectively max(f1, f2))

Limitations
In this section, we present two variations of the initial example. Let modify the condition i < j into i +1 < j (resp. i +2 < j), we rewrite the condition on X as 0 < X − 1 (resp. 0 < X − 2). Table 5 represents the resulting traces.
Table 5
Trace of example 1 with modified condition
(a)	with	condition	i  +  1	<	j	(b) with condition i +2 < j 
In the first case, the loop is bounded whereas the series is not: we cannot determine if the loop is bounded. In the second case, the loop and the series are bounded but the series reach the bound after the loop: the series are pessimistic.
In conclusion, when we find series, they will always bound the original loop. The limitation of our technique is that the bound may be exact, pessimistic or even undetermined.

Significant example
We present here a significant example inspired by industrial real time applications (this form of loop is not represented in M¨alardalen benchmark). It features array and several covariant variables.
Example 6: Interval and series
int  main ()  {
int  i=0 , j=0 , k =0;
int tab [10][5][10]; // int X = i *50+10* j+k;
while ( i *50+10* j+k <500) { // c ’= ( i * 50+10* j+k <500) && (X - 500 <0)
// p0
t[ i][ j][ k ]=0;
if ( k <9) // k in [ 0.. 8] , j in [ 0 .. 4 ]
k++; // p1
else if (j <4) { // k = 9 and j in [0..3] 
k=0;
j++;	// p2 }
else { // k= 9 , j=4 , i in [ 0..9] 
k=0; j=0;
i++;	// p3
} // p4
} // p5
}
First we proceed to interval analysis and obtain i ∈ [0..9], j ∈ [0..4] and k ∈ [0..9]. Then we compute the expression of X and obtain X = X + 1 for each point. In points p2 and p3, because we get neither the form X = cte nor X = cte1 ∗ X + cte2 we need to artificially re-introduce j and k thanks to the interval analysis (in p3, we replace 0 by k − 9). The series obtained for this example is a single arithmetic form. The limit of the loop is 500.

Conclusion
The type of loops found in bs.c M¨alardalen benchmark is now bounded by oRange. We call this family of loop covariant: the number of iteration depends on several increment variables having a correlated behavior. Such loops are found in industrial cases, and not only for binary search.
Our method consists to express the increment variables into a single one which has the behavior of arithmetico-geometric series. We can then apply oRange to this single increment variable.
The next work will be to introduce interval analysis. We think it will help to find bounding series when it was not possible before and improving the accuracy of the bounding series.

References
Bound-t tool. http://www.tidorum.fi/bound-t, 2005.
ait tool. http://www.absint.com, 2007.
Wcet project. http://www.mrtc.mdh.se/projects/WCC08, 2008.
Christophe Alias, Alain Darte, Paul Feautrier, and Laure Gonnord. Multi-dimensional rankings, program termination, and complexity bounds of flowchart programs. In Static Analysis (SAS 2010), volume 6337 of LNCS, 2010.
Joel Coffman, Christopher A. Healy, Frank Mueller, and David B. Whalley. Generalizing parametric timing analysis. In Conference on Languages, Compilers, and Tools for Embedded Systems (LCTES’07), San Diego, California, USA, 2007.
Patrick Cousot and Radhia Cousot. Abstract interpretation: A unified lattice model for static analysis of programs by construction or approximation of fixpoints. In POPL, 1977.
Christoph Cullmann and Florian Martin. Data-flow based detection of loop bounds. In 7th Intl. Workshop on Worst-Case Execution Time (WCET) Analysis, Pisa, Italy, 2007.
Marianne De Michiel, Armelle Bonenfant, Pascal Sainrat, and Hugues Cass´e. Loop Normalisation to Evaluate Maximum Number of Iteration of Loop in WCET Context. Rapport de recherche IRIT/RR- 2008-3-EN, IRIT, Universit´e Paul Sabatier, Toulouse, f´evrier 2008.
Andreas Ermedahl, Christer Sandberg, Jan Gustafsson, Stefan Bygde, and Bj¨orn Lisper. Loop bound analysis based on a combination of program slicing, abstract interpretation, and invariant analysis. In 7th Intl. Workshop on Worst-Case Execution Time (WCET) Analysis, Pisa, Italy, 2007.
J´erˆome Feret. The arithmetic-geometric progression abstract domain. In Verification, Model Checking and Abstract Interpretation (VMCAI’05), 2005.
Jan Gustafsson and Andreas Ermedahl. Experiences from applying wcet analysis in industrial settings. In Tenth IEEE International Symposium on Object-Oriented Real-Time Distributed Computing (ISORC 2007), Santorini Island, Greece, 2007.
Paul Lokuciejewski, Daniel Cordes, Heiko Falk, and Peter Marwedel. A fast and precise static loop analysis based on abstract interpretation, program slicing and polytope models. In CGO ’09: Proceedings of the 7th annual IEEE/ACM International Symposium on Code Generation and Optimization, 2009.
Marianne De Michiel, Armelle Bonenfant, Hugues Cass´e, and Pascal Sainrat. Static loop bound analysis of c programs based on flow analysis and abstract interpretation. In The 14th IEEE International Conference on Embedded and Real-Time Computing Systems and Applications, RTCSA 2008, Taiwan, 2008.
Adrian Prantl, Jens Knoop, Raimund Kirner, Albrecht Kadlec, and Markus Schordan. From trusted annotations to verified knowledge. In 9th Intl. Workshop on Worst-Case Execution Time Analysis, WCET 2009, Dublin, Ireland, 2009.

Appendix
Preliminary proof
In this appendix, we prove that if we find a bound for a loop thanks to our method this bound is valid.

Let I = {xi}n
the set of the induction variables of the loop. Let n = |I| its number of elements.

∀i ∈ [1..n], xi∈ Z, ai∈ Z and k∈ N −{0}
In this proof we use the usual definition for integer / and % operators of C. According to these definitions ∀x ∈ Z, x = (x/k) ∗ k + r with −(k − 1) ≤ r ≤ k − 1.
So x = −x and −x%k = (−x)%k. These properties permit us to consider that a difference is like a
k	k
sum when using − for each coefficient ai ∈ Z.
Let show that we can bound the following formula:

n
A =	i=1
(aixi )
. Let aixi = qik + ri with −(k − 1) ≤ ri ≤ k − 1.

k
A =   i=1 (qik+ri ) = Σn
Σn
qi +  i=1 

k
Let B = Σn
i=1
(aixi ) = Σn
k
(qik+ri ) integer division Σn  q



Σn	i=1 k	k	k

n(k−1) thus B − n(k−1) ≤ Σn
qi +  i=1 ri ≤ B + n(k−1)

This leads to our theorem:
Theorem 6.1

Σ aixi

 

n(k − 1)


Σn  (aixi)
Σ aixi


 

n(k − 1)





Proof for bounding formulae
We would like to bound formula of the following type:  with b ∈ Z, S = b + Σn

 


(a0ixi) + 

In order to make the prove simpler we first consider that ∀j ∈ [1..m] bj = 0 thus S becomes S =
Σn  (a  x )

n i=1
(a0ixi)+ Σm
  i=1 ji i 
k

Σn  a  x

With T0 = Σn
(a0ixi) and Aj =
i=1
k
ji i , S = b + T0 + Σm Aj

By applying theorem 6.1 we obtain b + T0 + Σm  Σn
ajixi − nm(k−1)
≤ S ≤ b + T0 +

Σm  Σn


ajixi + nm(k−1)
j=1
i=1  k	k

We introduce a new value U = b +
i=1
j=1
= b +
i=1
j=1
= b + T0 +

Σn  Σm  a  x	k	k
 i=1 j=1 ji i
k
Thanks to theorΣem 6.1 we can bound U:	Σ

b + T0 +
m j=1
n i=1
(ajixi )
k
m(k−1) k
≤ U ≤ b + T0 +
m j=1
n i=1
(ajixi )
k
m(k−1) k

Thus, we can rewrite this inequality using S:
S − m(k−1) ≤ U ≤ S + m(k−1)1 so S ≤ U + m(k−1)
k	k	k
This leads to bound S:

S ≤ U + m(k−1) ≤ b + T0 + Σm  Σn
(ajixi ) + nm(k−1) + m(k−1)


k	k

As we are able to compute b + T0 + Σm
n i=1
(ajixi ) and E, we are able to bound S.

Remark: when bj /= 0, E = (n+1)m(k−1) + m(k−1)
k	k
