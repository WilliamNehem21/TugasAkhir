

Electronic Notes in Theoretical Computer Science 238 (2009) 23–43
www.elsevier.com/locate/entcs

Strategy-Based Proof Calculus for Membrane Systems
Oana Andrei1 ,3
INRIA Nancy Grand-Est & LORIA Nancy, France
Dorel Lucanu1 ,2
Faculty of Computer Science Alexandru Ioan Cuza University Ia¸si, Romania

Abstract
In a previous work, we showed how rewrite strategies can be used for defining the semantics of membrane systems, in particular for expressing the different control mechanisms in membranes. The insufficient expres- sivity of the existing concept of rewrite strategies for describing certain control mechanisms for membranes lead us to defining a more generic concept of strategies.
In this paper we introduce strategy-based rewriting logic which uses strategy controllers to reason at the higher level of computation given by the evolution of the membrane systems. We give a detailed presentation of the proof calculus, model theory, and completeness. A main consequence of the approach is that we get an algebraic semantics for membrane systems. Implementation issues are also discussed.
Keywords: Rewriting Logic, Strategy-based Rewriting Logic, Strategy Controller, Membrane System, Membership Equational Logic.


Introduction
Membrane systems represent an abstract model of parallel and distributed com- puting inspired by cell compartments and molecular membranes [22]. A membrane system consists of several disjoint or nested membranes, among which a particular one surrounding them all called skin membrane, and a finite set of objects O. Each membrane consists of a multiset (also called soup) w of objects from O, a set R of evolution rules over multisets of objects, and a control mechanism describing the

1 This work is partially supported by the PN II grant ID 393/2007 and CEEX grant 47/2005.
2 Email: dlucanu@info.uaic.ro
3 Email: Oana.Andrei@loria.fr

1571-0661/© 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.05.011

way in which the rules are used to modify the multiset w in an evolution step. The application of an evolution rule r : u → v on a multiset w consists in replacing the occurrence of u in w with v, if possible; otherwise we say that w is r-irreducible. A multiset is irreducible if it r-irreducible for each evolution rule r. An evolution step of a membrane is given by the application of several evolution rules according to its control mechanism.
There are various control mechanisms in membrane systems inspired by some biological entities. Each membrane may have its own control mechanism and a different task, and all membranes must work simultaneously to accomplish a more general task for the whole system. In this paper we consider the control mechanisms given by maximal parallel rewriting (mpr) and maximal parallel rewriting with pri- orities (pri). Other available control mechanism are defined in the literature for the membrane systems like for instance: maximal parallel rewriting with promoters or inhibitors [22] where promoters and inhibitors are represented as multisets of objects associated to rules, and such a rule can be used only if all the promoting objects are present, and none of the inhibiting object is present in its membrane; the minimal parallel rewriting [8] saying that if at least a rule from a set of rules associated with a membrane can be used, then at least one rule from that membrane must be used, without any other restriction; non-synchronized rewriting [13] where any number of rules is used in any step; or cooperative rewriting [10] where, for a given k, we can use exactly k, at least k, or at most k rules.
Maximal parallel rewriting means that as many as possible evolution rules are

mpr
applied in parallel. Formally, we say that w ===⇒ M w
mpr
(or w ===⇒ w
if unam-

biguous) if and only if there is a multiset of rules r1 : u1 → v1,... , rn : un → vn in the membrane M such that w = u1 ... unz, w' = v1 ... vnz, and z is irreducible (z could be the empty multiset). In a membrane, a priority relation among rules is expressed by a partial order relation on the set of all rules, with the meaning that a rule can be chosen to be applied only if no rule of a higher priority is applicable in the same

pri
membrane. Formally, we say that w ===⇒ M w
pri
(or w ===⇒ w
if unambiguous)

mpr
if and only if w ===⇒ w
using the multiset of rules r1 : u1 → v1,... , rn : un → vn

and there is no rule r : u → v in M applicable to w which has a greater priority than any ri : ui → vi.
The following two membrane examples are used throughout the whole paper. Let M1 denote a membrane over the set of objects {a, b, c, d} with the evolution rules R1 = {r11 : aa → ab, r12 : ab → cd, r13 : b → dd} such that r12 has a
pri
higher priority than r13, i.e., r12 > r13. We have aaaaabb ===⇒ ababcdb using
the multiset r11, r11, r12. The rule r13 cannot be applied because it has a lower priority than r12 and r12 is applicable to aaaabb. Another possible evolution step
pri
is aaaaabb ===⇒ abcdcda obtained by using the multiset of rules r11, r12, r12. The
second membrane M2 is defined over the same set of objects as M1 and has the evolution rules R2 = {r21 : bb → a, r22 : a → ab}. Since M2 does not include priorities over evolution rules, only evolution steps defined by maximal parallel
mpr
rewriting are possible. Such an evolution step is aabb ===⇒ ababa using r22, r22, r21

(and this is the only evolution step starting from aabb).
A state of a membrane system is given by the state of its skin membrane, where the states of elementary or composite membranes are formally defined as follows:
if M is the name of an elementary membrane with w the multiset of objects, then
⟨ M | w ⟩ is the state of the membrane;
if M is the name of a composite membrane with w the multiset of objects, and t1,... , tn are the states of its internal membranes, then ⟨ M | w { t1,... , tn }⟩ is the state of the membrane.
We denote by ctrlM ∈ {mpr , pri ,.. .} the control associated to a membrane named
M .
An evolution step t ⇒ t' for a membrane system is defined over states by struc- tural induction:

for t = ⟨ M | w ⟩ and t' = ⟨ M | w' ⟩
ctrlM
w', then t ⇒ t';

, if w ===⇒ M
for t = ⟨ M | w { t1,... , tn }⟩ and t' = ⟨ M | w { t' ,... , t'

} ⟩,

if
ctrlM
1	n
'	ctrlM	'

either w is irreducible w.r.t. ===⇒ M and w
and for i = 1,... , n,
= w, or w ===⇒ M w ,

either ti is irreducible (w.r.t. ⇒) and t' = ti, or ti ⇒ t'
i	i
and not all of w, t1,... , tn are irreducible, then t ⇒ t'.
For instance, a possible evolution step for the system Π1 with the structure
⟨M1 | {M2}⟩ is ⟨ M1 | aabb {⟨ M2 | aabb ⟩}⟩ ⇒ ⟨ M1 | abbb {⟨ M2 | ababa ⟩} ⟩ because
pri	mpr
aabb ===⇒ M1 abbb and aabb ===⇒ M2 ababa.
Our aim is to find a suitable rewrite-based framework for specifying the dynam- ics of systems similar to membrane systems, where one step evolutions are given by controlled applications of sets of elementary evolution steps expressed as rewrite rules. In our opinion, a framework (semantics) is rewrite-based if it satisﬁes (at least) the following conditions: the evolution rules are viewed as rewrite rules, it preserves the locality of the evolution rules, the communication and structural ac- tions are modelled as rewrite rules, and an event (action) occurrence is given by the application of a rewrite rule.
The first candidate for membrane systems was (conditional) Rewriting Logic (RL) [20]. We showed in [2] that it is possible to describe the operational semantics of membrane systems in RL. Moreover, it is known that the Maude system [9] can be used to analyse the behaviour of concurrent systems. However, in practice we noticed that it is not easy to identify the one step evolutions of a nested membrane system or of its subsystems because in Maude the description of the whole system is given by a flat rewrite theory, hence the difficulty to separate the rules belonging to a membrane. Moreover, since one step evolution is given by the execution of a sequence of rewrites, it is difficult the use of analysis tools, like the Maude LTL model checker [12] or search command. In a recent paper [17], it is shown that the rewrite theories describing membrane systems cannot preserve the maximal

concurrency given by the maximal parallel rewriting.
Then we started to look for a framework where the one step evolution can be specified by other mechanisms. In [1] we showed that the control mechanisms for membranes can be expressed by means of rewrite strategies. While the maximal parallel rewriting can be expressed using a strategy language including recursive definitions, other mechanisms, e.g., the maximal parallel rewriting with priorities, require more elaborated specification languages. For instance, the language must include means to compute the set of rules applicable in the current state.
The solution we propose in this paper is based on the combination between rewrite theories, strategies, and strategy controllers. The intuition behind a strat- egy controller is that it decides which strategy is applied in the current state. We refer to the set of evolution rules of a membrane as a control-free membrane. Sim- ilarly, by a control-free membrane system we refer to the set of evolution rules of a membrane system. A control-free membrane (system) is specified by a rewrite theory in RL. Based on the current state, a strategy controller produces a strategy (called evolution strategy ) describing the possibly next one-step evolutions. For in- stance, if the strategy controller for M1 is pri, then strategy computed by pri for
pri
aabb is (r11 id)+ (r12 r12) (the next possible one-steps are aabb ===⇒ abbb and
pri
aabb ===⇒ ccdd).
We use Membership Equational Logic (MEL) as a framework where the three above concepts can be uniformly presented. We proceed in a similar way to that of Generalized Rewriting Logic [7]. For a given membrane system Π, we construct a (nontrivial) MEL theory Proof (Π) which supplies a sequents-based proof calculus for membrane systems. Proof (Π) has initial model which can be used to extract the usual operational semantics for membrane systems [2]. This is true even for mem- brane systems with heterogeneous control mechanisms which are not considered in [2]. Moreover, using the theory Proof (Π), we can define a model-theoretic se- mantics for membrane systems. In this way, a membrane system Π can be regarded as a specification of a larger class of systems having similar behavior.
Based on the theoretical foundation supplied by the theory Proof (Π), we de- veloped a pattern-based implementation of the membrane systems using the Maude strategy language [18].
The structure of the paper is as follows. Section 2 gives the main notations and concepts related to Rewriting Logic. Section 3 is the main part of the paper. Here we describe why the membrane systems are not rewrite theories and we present the strategy-based rewriting logic for membrane systems. Both the syntax and the semantics are presented as MEL theories. Soundness and completenes results are also included. In Section 4 an implementation based on the Maude strategy language is discussed. The case of communicating and dissolving membranes is discussed in Section 5.

Preliminaries
We assume that the reader is familiar with the basic definitions and notations for many-sorted equational logic [14] and term rewriting [3].
Term Algebra. A many-sorted signature is a pair (S, Σ), where S is called the sort set and Σ is an S∗ × S-sorted family {Σw,s | w ∈ S∗ and s ∈ S}. A many-sorted Σ-algebra A consists of a many-sorted family of sets {As}s∈S and an operation Af : As1 ... Asn −→ As for every operation symbol f ∈ Σs1...sn,s. For X = {Xs} an S-sorted family of disjoint sets of variables, TΣ(X) is the smallest set of Σ-terms over X built with operators from Σ and variables from X. If X is empty, then we write TΣ for TΣ(∅). The set of all terms of sort s is denoted by TΣ,s(X). We denote by V ar(t) the set of variables occurring in t. A ground substitution is a partial mapping from X to terms in TΣ and it uniquely extends to a Σ-homomorphism from TΣ(X) to TΣ. We denote by t¯n a sequence of terms t1,... , tn, for ti ∈ TΣ(X), i = 1, n. Considering S as a partially ordered set leads to quite similar definitions for order-sorted signature, terms and substitutions [14].
Term Rewriting. A set R of rewrite rules is a set of ordered pairs of terms from TΣ(X), denoted u → v, such that u and v belong to the same sort, u /∈ X and V ar(v) ⊆ V ar(u). The rewriting relation induced by R is denoted by →R (→ if there is no ambiguity about R), and defined by t → t' iff there exists a substitution σ and a position p in t such that t = t[σu]p for some rule u → v of R, and t' = t[σv]p.
Membership Equational Logic (MEL). Membership equational logic [21,7] ex- tends many-sorted equational logic with membership assertions t : s stating that a term t belongs to a sort s. A signature in membership equation logic is a triple (K, Σ, S) (Σ for short) where K is a set of kinds, Σ = {Σw,k}(w,k)∈K∗×K is a many- kinded signature, and S = {Sk}k∈K a K-kinded family of disjoint sets of sorts. Note that in this paper we adopt the same approach as in Maude [9] of not ex- plicitly name the kinds. A kind is identified with its equivalence class of sorts and we usually denote it by enclosing the name of a sort in square brackets. A MEL Σ-algebra A is a many-kinded algebra having a set As with As ⊆ Ak for every s ∈ Sk. We denote by TΣ(X)k the set of k-kinded terms built over Σ with vari- ables from a set X. An atomic formula is either a Σ-equation (∀X) t = t' or a membership assertion (∀X) t : s, for t, t' ∈ TΣ(X)k and s ∈ Sk. A Σ-sentence is a
universally quantified Horn clause on an atomic formula F over TΣ(X) of the form
(∀X) F if   ui = u' ∧   vj : sj with ui, u' , vj ∈ TΣ(X). A MEL theory is a pair
(Σ, E) of a MEL signature Σ and a set E of Σ-sentences.
As a shorthand, we use subsort declarations instead of giving the corresponding membership equations, as well as operation declaration at the sort level instead of the kind level, if not otherwise needed.
Example 2.1 The static description of the membranes is represented by the MEL theory (Σm, Em), where Σm includes the sorts Object and Soup with Object < Soup, ϵ : −→ Soup, the concatenation   : Soup Soup −→ Soup, together with
the sort RuleLabel for representing rule labels,














Fig. 1. Inference rules for (unconditional) MEL-based rewrite theories
the sort MembraneName for representing membrane names,
the projections l hs : RuleLabel −→ Soup for the left-hand side of a rule, and
l abel : Rule −→ RuleLabel for the label of a rule.
Em includes axioms expressing the associativity and commutativity of   with ϵ the identity element.
The static description of membrane systems is represented by the MEL theory (Σp, Ep) consisting of (Σm, Em) together with:
the sort Membrane for states of both simple and composite membranes,
the sort MembraneBag for multisets of membranes, together with its constructors: the subsort relation Membrane < MembraneBag, the constant NULL denoting the empty multiset, and the union of multisets , : MembraneBag MembraneBag −→ MembraneBag,
the constructors for Membrane: ⟨ | ⟩ : MembraneName Soup −→ Membrane and
⟨ | { }⟩ : MembraneName Soup MembraneBag −→ Membrane,
the axioms expressing the associativity and commutativity of , with NULL the identity element.
MEL-based Rewrite Theories. A (unconditional) MEL-based rewrite theory [7] is a triple R = (Σ, E, R), where (Σ, E) is a MEL theory and R is a set of (universally quantified) labelled (unconditional) rewrite rules having the form (∀X) r : u → v, with u, v ∈ TΣ(X)s for some sort s and V ar(v) ⊆ V ar(u). The rewriting logic (RL) of a MEL-based rewrite theory R is a sequent calculus, where a sequent of R is a pair of (universally quantified) terms written as (∀X) t → t', with t, t' ∈ TΣ(X). We say that R entails the sequent (∀X) t → t', and write R ▶ (∀X) t → t', if (∀X) t → t' can be derived using the inference rules in Figure 1.
The rewrite theories defined in [7] also includes frozen operators. These operators are not needed for our purpose. Therefore by a MEL-based rewrite theory we mean a rewrite theory defined as in [7] but without frozen operators.
Example 2.2 The complete description of a control-free membrane M is repre- sented by the MEL rewrite theory M = (Σm ∪ O, Em, R), where (Σm, Em) is the MEL theory given in Example 2.1, O the set of object constants, and R includes

the rewrite rules corresponding to the evolution rules. For the example of M1, we have O = {a, b, c, d} and R = R1. We may use the inference rules in Figure 1 to deduce a concurrent rewriting step describing an evolution step:


r11 : aa → ab aa → ab

Replacement
r12 : ab → cd ab → cd

Replacement


(Congruence&Equality)∗

	aaaaabb → ababcdb	
⟨ M1 | aaaaabb ⟩→ ⟨ M1 | ababcdb ⟩

where by (Congruence&Equality)∗ we mean that the rules Congruence and Equality are applied of several times. Note that the evolution rules have no variables, so that we omitted to specify the set of universal quantified variables for the above rules and sequents.


Strategy-based Rewriting Logic for Membrane Sys- tems
Why Membrane Systems are not Rewrite Theories
A control-free membrane system is described by the rewrite theory RΠ = (Σp ∪ O, Ep, R), where (Σp, Ep) is the MEL theory given in Example 2.1, and R includes the rewrite rules coming from all the component membranes. We include further in this theory the following items:
for each rule r : u → v, add a constant r : RuleLabel and an equation lhs (r)= u;
for each membrane name M , add a constant M : MembraneName . From now on we assume that the object constants O are included in Σp.
If we apply the inference rules in Figure 1 for RΠ, then we might deduce tran-
sitions which are not valid for membrane systems. For instance, the concurrent rewriting obtained by the following inference


r11 : aa → ab aa → ab

Replacement
r21 : bb → a bb → a

Replacement


(Congruence&Equality)∗

	aabbb → abab	
⟨ M1 | aabbb {⟨ M2 | bcc ⟩}⟩ → ⟨ M1 | abab {⟨ M2 | bcc ⟩} ⟩

does not describe a valid evolution step for Π1 because it uses a rule of M2 in order to modify the content of M1. The evolution rules are local to a region (membrane). A rewrite theory correctly describing a rewrite theory should use the reflection property of RL in order to include meta-level information as that regarding the locality of the evolution rules. But in that case, an evolution step of a compound membrane cannot be described by a concurrent rewriting step (see [17] for more details).

Syntax of Strategy-based Rewriting Logic for Membrane Systems
In this section we present a new framework, called strategy-based rewriting logic, which avoids the above drawback. The main idea is to use strategies instead of the proof-terms [7] describing the inference trees corresponding to the concurrent rewriting steps. In practice, in order to apply a concurrent rewrite step in a rewrite theory R, we need an algorithm which for a given term t, it returns a set of triples (pi, θi, ri), where {pi} is a set of disjoint positions, θi is a substitution, and ri is a rewrite rule ri : ui → vi such that t|pi = θi(ui). Then a concurrent rewrite step is t → t', where t' is t{θ(vi)/pi}. In strategy-based rewriting logic we need an algorithm that for a given term t, returns a strategy expression s. Then a step is t → t', where t' is obtained from t according to the the strategy s (the evolution strategy). In Subsection 3.2.1 we introduce a MEL theory STRAT(Π) defining the strategy language needed for membrane systems, and in Subsection
3.2.2 we introduce a MEL theory STRAT-CTRL(Π) defining the strategy controllers
for membrane systems as a means to specify algorithms that compute strategies for state terms. We refer the triple (RΠ, STRAT(Π), STRAT-CTRL(Π)) as strategy-based rewrite theory.

Strategies for Membrane Systems
We can think of a rewriting strategy as an algorithm for defining a computation step induced by a set of rules. In particular, the rewriting rules are elementary strategies. In general, a rewriting strategy language consists of expressions built using rewriting rules and strategy operators. Various approaches have been followed, yielding slightly different strategy languages such as ELAN [16,6], Stratego [23], TOM [4], or Maude [18]. All these languages provide flexible and expressive strategy languages where high-level strategies are defined by combining low level primitives, and they all share the concern to provide abstract ways to express control of rule applications, by using reflexivity and the metalevel for Maude, or the notion of rewriting strategies for ELAN or Stratego. Strategies such as bottom-up, top-down or leftmost-innermost are higher-order features that describe how rewrite rules should be applied.
In this section we introduce the MEL theory defining the syntax for the strate- gies defined over the rewrite theory (Σp, Ep, R) specifying a control-free membrane system Π. The syntax for these strategies can be split in two: a first part which is independent of the particular choice of Π (in fact of R), and a second part which de- scribes the rules in Π as elementary strategies. We start by defining the independent part.
STRAT-BASIC is the MEL theory consisting of:
the sort Rule for representing rules, the sort Strategy for strategies,
the constructor for the sort Rule,( :  → ): RuleLabel State State −→ Rule,
the subsort relation RuleLabel < Strategy ,
the strategy constructors for identity, failure, non-deterministic choice, and se-

quential composition respectively:
id fail : −→ Strategy
+ : Strategy Strategy −→ Strategy [assoc comm]
; : Strategy Strategy −→ Strategy [assoc id : id]
a congruence strategy operator for each of the constructors of Soup, Membrane
and MembraneBag :
  : Strategy Strategy −→ Strategy [assoc comm]
⟨ | ⟩ : MembraneName Strategy → Strategy
⟨ | { }⟩ : MembraneName Strategy Strategy −→ Strategy
, : Strategy Strategy −→ Strategy [assoc comm]
the equations
s + s = s	id id = id
s; f ail = f ail; s = f ail	s + f ail = s
⟨M | s + s'⟩ = ⟨M | s⟩ + ⟨M | s'⟩	sfail = f ail s = f ail
⟨M | s1 + s' {s2}⟩ = ⟨M | s1{s2}⟩ + ⟨M | s' {s2}⟩  s1 (s2 + s' )= s1 s2 + s1 s'
1	1	2	2
⟨M | s1{s2 + s' }⟩ = ⟨M | s1{s2}⟩ + ⟨M | s1{s' }⟩  s1, (s2 + s' )= s1, s2 + s1, s'
2	2	2	2
The strategy language defined by the above theory corresponds to the mem- brane systems we consider in this paper. It includes the identity strategy (id), the failure strategy (f ail), non-deterministic choice ( + ), sequential composition ( ; ), and the strategy congruence operators corresponding to the constructors for Soup, Membrane, and MembraneBag. This language can be enriched with new constructs needed for defining other control mechanisms [1].
The strategy language corresponding to a rewrite theory representing a control- free membrane system is obtained by adding to the basic strategies the elementary strategies defined by the rules: STRAT(Π) contains the MEL theory STRAT-BASIC together with a membership axiom r : RuleLabel and an equation axiom lhs(r )= u, for each rule r : u → v in R.
Strategy Controllers for Membrane Systems
Strategy controllers generalize strategies in the sense that they supply a very gen- eral solution for describing algorithms that computes evolution strategies. Such a strategy is computed in each state term t and it should describe all evolution steps possible from t. It should be equal to fail if and only if no evolution step is possible from t.
In order to be able to represents the control mechanisms of membranes, we might need to enrich the algebraic structure (Σm, Em) for membranes with special items. For instance, if the control is the maximal parallel rewriting with priorities, then a binary operator > is introduced for the priority relation, and, for each pair in the priority relation r > r', an equation r > r' = true is added.

The MEL theory STRAT-CTRL describes the strategy controllers for the mem- brane systems and it consists of:
the MEL theory STRAT-BASIC given in Sect. 3.2.1;
a sort StrategyController for strategy controllers together a constant for each membrane control mechanism like mpr, pri and so on, together with a constant evrl corresponding to the application of the evolution rules;
an operation getCtrl : MembraneName −→ StrategyController which returns the strategy controller of a given membrane.

Semantics of Strategy-based Rewriting Logic for Membrane Systems
The semantics is given by a MEL theory Proof (Π) which includes the semantics of the strategies and the semantics of the strategy controllers.

Semantics of Strategies
The definition of the semantics for strategies can be given in various ways, see, e.g., [24,23,6,5,18,11]. We proceed here on a slightly different approach and give the semantics of the strategies by means of a MEL theory. This helps us later when we define the algebraic semantics of the membrane systems.
The MEL theory STRAT-BASIC-SEM which includes STRAT-BASIC,a sort Strat- Sequent for strategic sequents, the constructor for strategic sequents:
( d  → ): Strategy State State −→ [StratSequent ],
a sort State, the subsort relations Soup Membrane MembraneBag < State , the fol- lowing membership axioms:
(r d u → v): StratSequent if r : RuleLabel ∧ (r : u → v): Rule	(1)
id d t → t' : StratSequent if Ep ▶ t = t'	(2)
s1 + s2 dt → t' : StratSequent	(3)
if s1 dt → t' : StratSequent ∨ s2 dt → t' : StratSequent
s1; s2 dt → t' : StratSequent	(4)
if s1 dt → t'' : StratSequent ∧ s2 d t'' → t' : StratSequent

s1 s2 d t1 t2 → t' t'
: StratSequent	(5)

1 2

if s1 d t1 → t'
: StratSequent ∧ s1 d t1 → t'
: StratSequent

⟨M | s⟩ d ⟨M | t⟩→ ⟨M | t'⟩ : StratSequent if sdt → t' : StratSequent	(6)
⟨ M | s1 { s2 }⟩ d ⟨ M | t1 { t2 }⟩ → ⟨ M | t' { t' }⟩ : StratSequent	(7)
1	2

if s1 d t1 → t'
: StratSequent ∧ s2 d t2 → t'
: StratSequent

s1, s2 d t1, t2 → t' , t'
: StratSequent	(8)

1  2
if s1 d t1 → t' : StratSequent ∧ s1 d t1 → t' : StratSequent
1	1
If Π is a membrane system, then STRAT-SEM(Π) is the MEL theory STRAT- BASIC-SEM together with a membership axiom (r : u → v): Rule, for each rule r : u → v in R.

The axiom 1 defines the semantics of a rule as the only sequent it defines, i.e., the unique one-step rewriting obtained by applying the rule at the top. Recall that the evolution rules have no variables. The axioms 2-4 define the semantics for iden- tity, non-deterministic choice, and sequential composition, respectively, according to their intuitive definitions. The semantics of the congruence strategy operator given by axiom 5 consists of the parallel application of the rewrites given by the arguments. Recall that the operator   is associative and commutative and hence we can have an arbitrary number of parallel rewrites. Axioms 6-8 give semantics for the congruence strategy operators corresponding to the constructors of membranes (including systems).
Remark 3.1 The theory STRAT-BASIC-SEM has only a theoretical value. In prac- tice, systems like Maude are not able to handle the axiom [4]. See, e.g., [5,18,19] for an executable semantics of these strategies. In terms of [11], STRAT-BASIC- SEM can be defined as a parameterized strategy module and STRAT-SEM(Π) as an instance of it.
The next result shows that the equations included in STRAT-BASIC are sound
w.r.t. the above semantics.
Theorem 3.2 If
STRAT(Π) |= s = s' and STRAT − SEM(Π) |= sd t1 → t2 : StratSequent ,
then there are t' , t' such that

1  2
STRAT − SEM(Π) |= s' d t'
→ t'
: StratSequent ,

(Σp, Ep) |= t1 = t' and (Σp, Ep) |= t2 = t' .
Proof (Sketch) We proceed by structural induction on s = s' by showing only on a few cases, since the others are handled similarly.
Case s + s = s. By definition, s + sd t1 → t2 : StratSequent implies
sd t1 → t2 : StratSequent ∨ sd t1 → t2 : StratSequent,
which is equivalent to sd t1 → t2 : StratSequent. Obviously, (Σp, Ep) |= t1 = t1
and (Σp, Ep) |= t2 = t2.
Case ⟨ M | s + s' ⟩ = ⟨ M | s ⟩ + ⟨ M | s' ⟩. ⟨ M | s + s' ⟩ d t1 → t2 : StratSequent
implies by axiom 6 the existence of t' , t' such that (Σp, Ep) |= ⟨ M | t' ⟩ = t1 and
1  2	1
(Σp, Ep) |= ⟨ M | t' ⟩ = t2, and s + s' d t' → t' : StratSequent. By axiom 3 we

have (sd t'
→ t'
2
: StratSequent ∨ s' d t'
1
→ t'
2
: StratSequent); then, by axiom 6,

⟨ M | s ⟩ d ⟨ M | t' ⟩→ ⟨ M | t' ⟩ : StratSequent ∨⟨ M | s' ⟩ d ⟨ M | t' ⟩→ ⟨ M | t' ⟩ :
1	2	1	2
StratSequent, and by axiom 3, we obtain ⟨ M | s ⟩ +⟨ M | s' ⟩ d ⟨ M | t' ⟩→ ⟨ M | t' ⟩ :
1	2
StratSequent.

Semantics of Strategy Controllers
The semantics of the strategy controllers for membrane systems is given by a MEL theory STRAT-CTRL-SEM which includes STRAT-CTRL, R(Π), together with:
a sort RuleSet for representing sets of rules;

an operation getRules : MembraneName → RuleSet , which returns the set of rules for a given membrane name;
a subsort relation Rule < RuleSet and the usual set-like constructors for the sort
RuleSet , none for the empty set and ,  for the union;
an overloaded operation
getStrat : StrategyController State −→ Strategy
getStrat : MembraneName StrategyController State −→ Strategy
which returns the strategy instance of (a given strategy controller for) a given term representing a (membrane) state;
a set of operations and equations giving semantics of the strategy controllers like
mpr, pri (see below);
a set of equations giving the semantics of the strategy controller evrl: getStrat (evrl , ⟨ M | w ⟩)= ⟨ M | getStrat (M , getCtrl (M ), w ) ⟩ getStrat (evrl , ⟨ M | w { t1 ,..., tn } ⟩)= 
⟨ M | getStrat (M , getCtrl (M ), w ) { getStrat (evrl , t1 ),..., getStrat (evrl , tn) }⟩ 
In what follows we present the equational definitions for mpr and pri controls.
The definition of the membrane control mpr is given as follows:
an overloaded strategy controller defined by mpr : −→ StrategyController and mpr : RuleSet −→ StrategyController, where the unary operation takes as pa- rameter the set of rules a strategy controller must be built from.
the equational definition of the binary operation getStrat for mpr is given using an auxiliary operation
mpr : RuleSet Soup RuleSet Strategy −→ StrategyController
together with the following equations:
getStrat (M , mpr, w )= getStrat (mpr (getRules (M )), w ) getStrat (mpr (RS ), w )= getStrat (mpr (RS, w, none, fail ), w ) getStrat (M , mpr ((RS , r ), w, RS ′, S ), w )= 
(r getStrat (M , mpr ((RS , r ), w ′, none, id ))) + getStrat (mpr ((RS , r ), w, (RS ′, r ), fail ), w )
if lhs(r )w ′ := w ∧ notIn(r, RS ′)
M , getStrat (mpr (RS, w, RS ′, S ), w )= S [owise]
The third argument of the quaternary operation mpr represents the set of rules already used for the construction of a strategy applicable to w; such iterative ap- plication allows to equally consider each of the rules given in the first argument for computing a strategy. As soon as a rule is tested as applicable and is used in a con- catenation for building a strategy, then the fourth argument of mpr becomes id to mark the success. When the first two equations can no longer be applied, the third one is applied: if last argument of mpr is fail, this means no rule was applicable, and the strategy computed is fail; otherwise, the strategy id is concatenated to the multiset of rules already found as applicable.
In the definition of an operator using conditional equations, the cases when none of the equations can be applied are accumulated by an unconditional equation with

the attribute “owise” (otherwise).
The definition of the membrane control pri uses the definition of mpr and the following items:
an operator for defining a (partial) order on rule labels corresponding to a priority relation on rule applications, > : RuleLabel RuleLabel −→ Bool ;
an operation ﬁlter : RuleSet Soup −→ RuleSet that discards from a set of rules RS all rules either not applicable on a given soup or of a lower priority than an applicable rule r:
ﬁlter ((RS , r, r '), w ) = ﬁlter ((RS , r ), w )
if lhs(r )w ' := w ∧ label (r ) > label (r ')
ﬁlter ((RS , r ), w ) = ﬁlter (RS , w ) if notIn(lhs(r ), w )
ﬁlter (RS , w ) = RS [owise]
where notIn(u, w ) returns true if and only if u is not a sub-multiset of w;
an equation defining getStrat for pri that proceeds as for mpr but with a filtered set of rules:
getStrat (M , pri , w )= getStrat (mpr (ﬁlter (getRules(M ), w )), w )
Remark 3.3 The mechanism given by the ﬁlter function can be also used for other mechanisms as promoters and inhibitors [22], minimal parallel rewriting [8] and so on.
Theorem 3.4 STRAT-CTRL-SEM is terminating and confluent.
Proof (Sketch) We can define a reduction order based on the following:
the operation ﬁlter reduces the number of rules in the first argument at each recursive call;
for the equations defining getStrat, either:
the operator is propagated in the term (hence the size as number of operations of the second argument decreases in the right-hand side), or,
in the conditional equation, either:
the size of the soup of objects decreases or
the size of the difference between the rules taken as first argument by mpr and the rules already used taken as the third argument decreases.
STRAT-CTRL-SEM has no critical pairs, and since it is terminating, it follows that it is confluent.	 
The above theorem shows that for each state t and appropriate strategy con- troller ctrl, getStrat (ctrl, t ) returns a unique strategy. If from t more than one evolution step are possible, then these are given by a sum of strategies. If no evo- lution step is possible from t, then getStrat (ctrl (RS ), t ) returns fail. Since this strategy describes the possible evolutions from the current state, it is called evolu- tion strategy.

Lemma 3.5 Given a membrane M with the strategy controller ctrl ∈ {mpr , pri } and a soup w, then getStrat (M , ctrl, w ) reduces either to fail or to a strategy of the form s1 + ... + sn, n ≥ 1, where each si is a concatenation of rules from R.
Proof (Sketch) Only the concatenation congruence operator and the sum are used in the definition of getStrat (M , ctrl, w ). The conclusion follows applying the axiom s (s1 + s2)= ss1 + ss2.	 

Theorem 3.6 Given a state term t, then getStrat (t ) reduces either to fail or to a strategy of the form s1 + ... + sn, n ≥ 1, where si corresponds to an evolution step.
Proof (Sketch) By previous lemma and using the other axioms included in STRAT- BASIC.	 
Remark 3.7 It is worth noting that the sequential composition operator ; is not used. This is due to the fact we did not consider yet the case of communication and structural actions for membrane systems (see Section 5).
Remark 3.8 For s a strategy, we write si <: s whenever s can be written as a non-deterministic choice between the strategies s1,... , sn, n ≥ 1,with sj /= id and sj /= fail , for all j = 1,... , n. We note that we can express s <: s', for any two strategies s, s', as a MEL formula. In particular, in the context of Lemma 3.5, we have si <: getStrat (M , ctrl, w ) for all i = 1,... , n.
In an evolution step for a membrane system Π, the strategy controller for a membrane that does not evolve is reduced to the strategy fail. If for all membranes in the system the results of computing their strategy controllers for a given state are equal to fail, then the strategy controller of the entire system reduces to fail. Otherwise, since the membranes that can evolve must evolve despite others that cannot, all fail strategies are replaced by id.
Example 3.9 Let us consider the membrane system Π1 introduced in Section 1 with the structure ⟨M1 | {M2}⟩. By definition, g etStrat(M1, pri , aabb) reduces to r11 id+r12 r12 which will rewrite aabb into abbb or ccdd, and g etStrat(M2, mpr , aabb) reduces to r22 r22 r21 which rewrites aabb into ababa = aaabb. Then
g etStrat(evrl, ⟨ M1 | aabb {⟨ M2 | aabb ⟩} ⟩)

reduces to

⟨ M1 | g etStrat(M1, pri , aabb) { g etStrat(M2, mpr , aabb) }⟩ 

which reduces to

which is equal to

⟨ M1 | r1 id + r2 r2 {⟨ M2 | r22 r22 r21 ⟩} ⟩

⟨ M1 | r1 id {⟨ M2 | r22 r22 r21 ⟩}⟩ + ⟨ M1 | r2 r2 {⟨ M2 | r22 r22 r21 ⟩} ⟩.
Hence, the states which can be obtained from ⟨ M1 | aabb {⟨ M2 | aabb ⟩} ⟩ in one

evolution step are:
⟨ M1 | abbb {⟨ M2 | aaabb ⟩} ⟩
⟨ M1 | ccdd {⟨ M2 | aaabb ⟩}⟩ 

The theory Proof (Π)
Let Π be a membrane system. The MEL theory Proof (Π) includes STRAT-SEM(Π), STRAT-CTRL-SEM, equations defining getRules (M ) for each membrane M in Π, a sort EvStepSequent, an operation →evStep : State State −→ [EvStepSequent ] for evolution steps sequents, and the membership axiom
(t →evStep t'): EvStepSequent
if s := getStrat (evrl, t ) ∧ s' <: s ∧ s' dt → t' : StratSequent
The matching equation s := getStrat (evrl, t ) assigns to variable s the result of the evaluation of getStrat (ctrl(Π), t). The membership predicate s' d t → t' : StratSequent is equivalent with checking if there is a computation among all com- puted by getStrat which rewrites t into t'. Note that s' dt → t' : StratSequent implies s' : Strategy , i.e., s' is indeed a strategy, and, moreover, a non-failing strategy since a failure does not correspond to an evolution step of the system.
In Figure 2 we give the diagram describing the construction of the theory
Proof (Π).
Since the proof calculus is described as a MEL theory, we get for free the alge- braic semantics for the strategic-based rewrite theories.
Definition 3.10 An algebraic model for Π is a Proof (Π)-algebra.
Proof (Π) is a MEL theory, hence it admits initial model [21], denoted by TProof (Π).

Theorem 3.11 Let Π be a membrane system.
Proof (Π) ▶ (t →evStep t'): EvStepSequent ⇐⇒ Proof (Π) |= (t →evStep t'): EvStepSequent ⇐⇒ [(t →evStep t')] ∈ TProof (Π),EvStepSequent .
Theorem 3.12 Let Π be a membrane system and let t, t' be two states. Then t ⇒ t'
if and only if Proof (Π) |= (t →evStep t'): EvStepSequent.
Proof (Sketch) We give the proof for a simple membrane with R the sets of rules and mpr the strategy controller. Then the theorem reduces to:

mpr
w ===⇒ w
iff s := getStrat(M, mpr, w) ∧ s'
<: s ∧ s'
d w → w'
: StratSequent.

The case of pri as strategy controller is similar, apart from an initial step when the set of applicable rules w.r.t. the priority relation is computed using the operation f ilter.


(	dependsOn








Syntax








Semantics







Fig. 2. The construction of the theory Proof (Π)



mpr
“⇒
”. Since w ===⇒ w , then, by definition, there is a multiset of rules from
R = getRules(M ), ri : ui → vi, for i = 1,... , n, such that w = u1 ... unz and w' = v1 ... vnz with z irreducible. Then, by Lemma 3.5, getStrat (M , mpr , w ) reduces to a strategy equivalent to r1 ... rn id + s' or r1 ... rn id. By definition, ri d ui → vi : StratSequent, for i = 1,... , n, hence r1 ... rn id d w → w' : StratSequent.
“⇐”. If s := getStrat (M , mpr , w ) with s' <: s and s' dw → w' : StratSequent , then from the definition of getStrat it follows that s' is equivalent to a concatenation of rules r1 ... rn id, with ri : ui → vi, for all i = 1,... , n, such that there is a multiset z of objects irreducible by any ri and (Σp, Ep) |= w = u1 ... unz,

(Σ ,E ) |	'
mpr
w'.

p	p  = w = v1 ... vnz. In other words, w ===⇒
The theorem is then easily proved by using structural induction on the membranes.
 

The properties proved here are valid for membrane systems having mpr and/or pri strategy controllers. Adding new strategy controllers may require reviewing the previous properties and their proofs.

Implementation

One of the best candidate for implementing membrane systems, using the approach presented in this paper, is Maude system [9]. This is mainly motivated by the following two reasons: Maude already has implemented a strategy language and Maude language is reflective allowing us to work with operators at metalevel, as it is the case of getRules. A prototype of this implementation is already working. The development of this application uses Maude patterns described in [15].
A membrane is specified as a module having a syntax as follows:
membrane M1 is
ev r1 : a a -> a b . ev r2 : a b -> c d . ev r3 : b -> d d . pr r2 > r3 .
end
This module is compiled into a Maude system module according to Section 2. Since M1 includes a partial order over rules, we can deduce that its control mech- anism is pri. In general, we assume that the description of a membrane includes enough information such that getCtrl() can compute the right controller by analyz- ing it. Having introduced a set of membranes, these can be combined for construct- ing systems with different structures. Here is a dialog with the application where all the possible next one step evolutions for the current state ⟨ M1 | aabb {⟨ M2 | aabb ⟩}⟩ are computed:
Maude> (transAll < M1 | a a b b { < M2 | a a b b > } > .) Solution 1 :	< M1 | a b b b{< M2 | a a a b b >}> Solution 2 :	< M1 | c c d d{< M2 | a a a b b >}>
The execution of this command is performed in three stages:
First the module Π is computed on-the-fly from the configuration given as parameter of the command.
Then the term getStrat (⟨ M1 | aabb {⟨ M2 | aabb ⟩} ⟩ is reduced in order to compute the instance strategy corresponding to the state parameter. The result is similar to the strategy expression given in Example 3.9.
Finally, the operation procSrewAll from the API implementing Maude Strat- egy Language [19] is used to compute all t such that
Proof (Π) |= ⟨ M1 | aabb {⟨ M2 | aabb ⟩} ⟩ →evStep t : EvStepSequent .
Since the syntax of Maude Strategy Language is different from that used in this paper, we have to encode the congruence strategy operators in this language. We also note that the execution of the getStrat operation produces a sequence of the corresponding API operations calls instead of the strategy expression. Here is a fragment of the sequence corresponding to the above example:
matchrew(’<_|_‘{_‘}>[’M1.MembraneName, ’X:Soup,
’<_|_>[’M2.MembraneName, ’Y:Soup]], ’true.Bool = ’true.Bool,
(’X:Soup using or(matchrew(’  [LHS,’W1:Soup],
’true.Bool = ’true.Bool, (LHS using ’r1[none]) ...

where LHS := lhs(r1). Note that using direct the left-hand side of the rule instead of a generic variable ’W0:Soup, the execution time of the engine applying the strategies is substantially reduced. Moreover, using the axioms from STRAT-BASIC, written now as
eq matchrew(’  [T1, T2], EC, ((T1 using S1),
(T2 using matchrew(T3, EC, TSL))))
=
matchrew(’  [T1, T3], EC, ((T1 using S1), TSL)) .
the evolution rules can be applied in parallel.
The current version of the prototype 4 is not a complete system for handling and analyzing membrane systems. Only the control mechanisms mpr and pri are implemented. The main goal was to demonstrate that the strategy controllers are appropriate for describing the behavior of the membrane systems in terms of the strategy-based rewrite theory. We claim that the other features of the membrane systems can be easily added to the actual prototype.

Communication and Dissolving
The communicating membranes uses cooperative evolution rules, which have the form r : u → v, with u a non-empty multiset over O, v a multiset over O ∪ Tar , where Tar = {here, out }∪ {inj | 1 ≤ j ≤ m}. The elements of Tar are called tar- get indications and have the following meaning: an object having associated the indication here remains in the same region, one having associated the indication inM goes immediately into the directly lower membrane M , and out indicates that the object has to exit the membrane, thus becoming an element of the region sur- rounding it. The description of these membrane can be done very easily in strategy- based rewriting logic. We consider a new sort HotSoup with Soup < HotSoup and (w, tar ) : HotSoup if w : Soup and tar ∈ Tar . The communication between mem- branes is realized by the means of the following two rules:
in(M, M ): ⟨ M | w1(w2, inM' ) {⟨ M | w { X } ⟩,Y }⟩ →
⟨ M | w1 {⟨ M ' | w'w2 { X } ⟩,Y }⟩ 
out (M ',M ): ⟨ M | w {⟨ M ' | w' (w' , out ) { X } ⟩,Y }⟩ →
1	2
⟨ M | ww' {⟨ M ' | w' { X } ⟩,Y }⟩ 
2	1
A rule of the form in-out, which simultaneously exchange messages between two membranes, can also be considered. Then we consider a strategy controller comm (constant of sort StrategyController) and we have to add a set of equations defining getStrat (comm, t ), which should return a strategy applying the rewrite rules in and out in a maximal parallel way. Even if the algorithms returning such a strategy is challenging, it is out the goal of this paper. The actual version of the proto- type defines getStrat (comm, t ) as (in + out )!, where s! means “repeat s as much as

4 The prototype can be downloaded from http://thor.info.uaic.ro/~rewps/.

possible” [18]. An evolution step is described by the strategy
getStrat (evrl, t ); getStrat (comm, t ' ) where t' is a state satisfying
STRAT-SEM(Π) ▶ (getStrat (evrl, t ) d t → t '): StratSequent .
The dissolving of a membrane is obtained by the means of a special object δ, called dissolving action, and rules of the form r : u → vδ. If at least one of the rules introduces the dissolving action δ, then the membrane is dissolved, and its content becomes part of the immediately upper membrane, provided that this membrane was not dissolved at the same time, a case where we stop in the first upper membrane which was not dissolved (at least the skin remains intact). The rules of the dissolved membranes are lost. We may describe the dissolving action by the rewriting rule
diss (M ',M ): ⟨ M | w {⟨ M ' | w'δ { X } ⟩,Y }⟩ → ⟨ M | ww' { X, Y }⟩ 
Besides of this rule, a StrategyController constant diss and a set of equations defining getStrat (diss, t ) it is all we have to add to our strategy-based rewrite theory. In the actual version of the prototype, getStrat (diss, t ) returns diss !. An evolution step is completely described now by the strategy
getStrat (evrl, t ); getStrat (comm, t ' ); getStrat (diss, t '') where t', t'' are two terms satisfying
STRAT-SEM(Π) ▶ (getStrat (evrl, t ) d t → t '): StratSequent

and

STRAT-SEM(Π) ▶ (getStrat (comm, t ') d t ' → t ''): StratSequent .

Related Work and Perspectives
The construction method of sequents-based theory for membrane systems is similar to the one used for the theory of proof terms Proof (R) given in [7], and to the one used for defining rewrite theories for strategies given in [5]. In the later work, the strategy language used is the one defined for ELAN, and it is larger than the one we used and needed in this paper. However, the framework we introduced here permits to extend easily the strategy language without changing the basic results.
In [6] the authors present a method of iteratively constructing a tower of strate- gies starting on the first level with primal strategies (rewrite rules, identity, con- catenation and congruence operations), then the second level corresponds to the elementary strategies (selection operations), and the third level corresponds to user- defined strategies, such that each level is based on the previous one, except for the first level. Our work on constructing a hierarchy of MEL theories is somehow based

on the same principle as in [6]. However, strategy controls are more than complex strategies since they cannot be defined using only elementary strategies. They are generic in the sense of being parameterized on the term to rewrite.
A related notion is that of parameterized strategy defined in [11], referring to generic strategies like map and backtracking. We adopted a different meaning for strategy controls, in the sense that they are instantiated on a state term producing an effective strategy.
The construction of the theory Proof (Π) for a membrane system Π gives the theoretical foundations for a rewrite semantics for Π. Based on this foundations, we developed an implementation of the membrane systems using the Maude strategy language [18] and the patterns for Maude Metalanguage Applications described in [15]. In the future we intend to extend the approach to a larger class of systems whose behavior is similar to that of membrane systems.
In this paper we do not concern with defining new control mechanisms for mem- brane systems or to investigate the role of such mechanism in reasoning about bio- logical systems. However, reasoning at the level of strategies of computing, rather than at the rule level, is an incentive direction in formally studying and analyzing biological systems and we consider it an open question for future work. Our goal was to study ways of defining a framework based on Rewriting Logic suitable for describing and analyzing membrane systems. The concept of strategy controllers proves to be a powerful tool, yet not very difficult to understand and handle, for defining various control mechanism, and we illustrate it in this paper on two such mechanisms.

References
Andrei, O., G. Ciobanu and D. Lucanu, Expressing Control Mechanisms in P systems by Rewriting Strategies, in: H. J. Hoogeboom, G. Paun, G. Rozenberg and A. Salomaa, editors, Workshop on Membrane Computing, Lecture Notes in Computer Science 4361 (2006), pp. 154–169.
Andrei, O., G. Ciobanu and D. Lucanu, A rewriting logic framework for operational semantics of membrane systems, Theoretical Computer Science 373 (2007), pp. 163 – 181.
Baader, F. and T. Nipkow, “Term Rewriting and All That.” Cambridge University Press, 1998.
Balland, E., P. Brauner, R. Kopetz, P.-E. Moreau and A. Reilles, Tom: Piggybacking Rewriting on Java, in: F. Baader, editor, RTA, Lecture Notes in Computer Science 4533 (2007), pp. 36–47.
Borovansky´, P., C. Kirchner, H. Kirchner and P.-E. Moreau, ELAN from a Rewriting Logic Point of View, Theoretical Computer Science 285 (2002), pp. 155–185.
Borovansky´, P., C. Kirchner, H. Kirchner and C. Ringeissen, Rewriting with Strategies in ELAN: A Functional Semantics, Int. J. Found. Comput. Sci. 12 (2001), pp. 69–95.
Bruni, R. and J. Meseguer, Semantic foundations for generalized rewrite theories, Theoretical Computer Science 360 (2006), pp. 386–414.
Ciobanu, G., L. Pan, G. Paun and M. J. P´erez-Jim´enez, P systems with minimal parallelism, Theoretical Computer Science 378 (2007), pp. 117–130.
Clavel, M., F. Dur´an, S. Eker, P. Lincoln, N. Mart´ı-Oliet, J. Meseguer and C. L. Talcott, “All About Maude - A High-Performance Logical Framework: How to Specify, Program, and Verify Systems in Rewriting Logic,” Lecture Notes in Computer Science 4350, Springer, 2007.
Dang, Z. and O. Ibarra, On P systems operating in sequential mode, in: Pre-proceedings of DCFS Workshop, London, Ontario, 2004, pp. 164–177.

Eker, S., N. Mart´ı-Oliet, J. Meseguer and A. Verdejo, Deduction, Strategies, and Rewriting, Electronic Notes in Theoretical Computer Science 174 (2007), pp. 3–25.
Eker, S., J. Meseguer and A. Sridharanarayanan, The Maude LTL Model Checker and Its Implementation, in: T. Ball and S. K. Rajamani, editors, SPIN, Lecture Notes in Computer Science 2648 (2003), pp. 230–234.
Freund, R., Asynchronous P Systems and P Systems Working in the Sequential Mode, in: G. Mauri,
G. Paun, M. J. P´erez-Jim´enez, G. Rozenberg and A. Salomaa, editors, Workshop on Membrane Computing 2004, Lecture Notes in Computer Science 3365 (2005), pp. 36–62.
Goguen, J. A. and J. Meseguer, Order-Sorted Algebra I: Equational Deduction for Multiple Inheritance, Overloading, Exceptions and Partial Operations, Theoretical Computer Science 105 (1992), pp. 217– 273.
Goriac, E., G. Caltais, D. Lucanu, O. Andrei and G. Grigora¸s, Patterns for Maude Metalanguage Applications, in: Proceedings of WRLA, 2008.
Kirchner, C., H. Kirchner and M. Vittek, Designing Constraint Logic Programming Languages using Computational Systems, in: P. Van Hentenryck and V. Saraswat, editors, Principles and Practice of Constraint Programming. The Newport Papers., MIT Press, 1995 pp. 131–158.
Lucanu, D., Rewriting Logic-based Semantics of Membrane Systems and the Maximal Concurrency, in: Proceedings of Prague International Workshop on Membrane Computing (2008), pp. 23–34.
Mart´ı-Oliet, N., J. Meseguer and A. Verdejo, Towards a Strategy Language for Maude, Electronic Notes in Theoretical Computer Science 117 (2005), pp. 417–441.
Mart´ı-Oliet, N., J. Meseguer and A. Verdejo, A Rewriting Semantics for Maude Strategies, in:
Proceedings of WRLA, 2008, pp. 207–226, to appear in ENTCS.
Meseguer, J., Conditional Rewriting Logic as a Unified Model of Concurrency, Theoretical Computer Science 96 (1992), pp. 73–155.
Meseguer, J., Membership algebra as a logical framework for equational specification, in: Francesco Parisi-Presicce, editor, WADT, Lecture Notes in Computer Science 1376 (1997), pp. 18–61.
Paun, G., “Membrane Computing. An Introduction,” Springer, 2002.
Visser, E., Stratego: A Language for Program Transformation based on Rewriting Strategies. System Description of Stratego 0.5, in: A. Middeldorp, editor, RTA, Lecture Notes in Computer Science 2051 (2001), pp. 357–361.
Visser, E., Z.-E.-A. Benaissa and A. P. Tolmach, Building Program Optimizers with Rewriting Strategies, in: ICFP, 1998, pp. 13–26.
