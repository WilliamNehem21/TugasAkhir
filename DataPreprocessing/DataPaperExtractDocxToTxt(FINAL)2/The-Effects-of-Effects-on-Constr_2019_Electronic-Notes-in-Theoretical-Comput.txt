Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 347 (2019) 87–120
www.elsevier.com/locate/entcs
The Effects of Effects on Constructivism
Liron Cohena, Sofia Abreu Faro and Ross Tatea
a Department of Computer Science Cornell University
Ithaca, NY 14853-7501

Abstract
It is commonly understood that Countable Choice holds constructively due to the underlying computa- tional nature of constructivism. However, in this paper we demonstrate that invoking different notions of computation result in radically different behaviors regarding Countable Choice. In particular, we illustrate that, although deterministic computation guarantees Countable Choice, non-deterministic computation can negate Countable Choice. We then further show that using stateful computation can restore Countable Choice even in the presence of non-determinism. This finding suggests that much of the modern discourse of constructivism assumes a deterministic underlying computational system, despite non-determinism being a fundamental aspect of modern-day computation.
Keywords: constructivism, effects, countable choice, non-determinism, stateful computation

Introduction
As software has grown increasingly critical to our society’s infrastructure, mechan- ically verified software has grown increasingly important, feasible, and prevalent. Proof assistants such as Coq [5], Agda [8], Twelf, and Nuprl [1, 14] are some of the most popular tools for mechanical verification. Each of these proof assistants sits on top of a computational system that embodies the mathematical philosophy of constructivism “under which an object exists only if we can construct it” [9]. In proof assistants, construction is done through programs via a tight correspondence to proofs often referred to as the proofs-as-programs paradigm [2].
This paradigm, most famously exhibited by the BHK interpretation, grounds constructivism in computation [43]. Yet there are many different notions of com- putation. While Turing machines and the λ-calculus crosscut these notions, even they have some subtlety. For example, an algorithm is required to terminate on all inputs, but the definition of termination varies in non-classical settings. One definition gives Markov’s Principle [28], where an iterative computation terminates if it cannot proceed indefinitely; another definition gives Bar Induction [12], where a recursive computation terminates if every possible recursion path encounters a

https://doi.org/10.1016/j.entcs.2019.09.006
1571-0661/© 2019 The Author(s). Published by Elsevier B.V.
This is an open access article under the CC BY-NC-ND license (http://creativecommons.org/licenses/by-nc-nd/4.0/).

base case; and there are yet more definitions. Thus it is well known that some constructive principles depend on the specifics of what one considers to entail com- putation [9].
Nonetheless, some principles are often considered to transcend such details about computation, meaning their verity or falsity is independent of the particular notion of computation employed. A notable example is Countable Choice (CC), which is widely accepted amongst contructivists [7, 9, 25, 32, 33, 36, 44], though not uni- versally [37–41]. Put simply, CC states that any total relation from the natural numbers has a corresponding function exhibiting the totality of that relation. It has been shown that CC holds for any model of type theory standardly constructed from any model of the λ-calculus—more specifically from any partial combinatory algebra [15, 17, 47]—and as such is independent of factors such as a particular def- inition of termination. In essence, the computation realizing the proof of totality itself describes the desired choice function. This example is particularly important to constructivism because CC is often relied upon to achieve what classically would be done through the Law of Excluded Middle (LEM). For example, without CC and LEM the types (not to be confused with setoids) of (modulated) Cauchy re- als are not necessarily Cauchy complete, nor are they necessarily equivalent to the Dedekind reals [27]. CC unifies the most common constructive formulations of the reals, namely the Cauchy, modulated Cauchy, and Dedekind reals [10].
However, in this paper we illustrate that the standard justification for CC makes an implicit assumption about computation, one that underlies much of the discourse of constructivism. That assumption is that the computation used to construct an object (in order to show it exists) is deterministic. Indeed, the computational systems underlying every major proof assistant are all deterministic. While some systems such as Coq rely on canonicalization to achieve decidable type-checking, even undecidable extensional systems like Nuprl have coincidentally all made their computational systems deterministic. That is, while there is significant research in constructively modeling and reasoning about non-deterministic computation, non- deterministic computation has not itself been directly incorporated into the compu- tational systems underlying proof assistants.
We show how non-deterministic computation can be soundly incorporated into these computational systems. In fact, the standard computational models of type theory trivially extend to non-deterministic computation—none of the definitions or proofs for these models were truly utilizing the deterministic assumption. However, the same is not true for principles that were derived from these standard models. For example, we show that adding even a modicum of non-determinism, in the form of a possibilistic coin flip, not only makes CC no longer hold in the model, it in fact makes the negation of CC hold. This formally supports Schuster’s philosoph- ical concern that CC would be incompatible with non-deterministic extensions to constructivism [41].
Non-determinism is just one example of effectful computation. Thus, we also consider the impact of stateful computation on constructive models. We show that, in addition to still forming a consistent model of type theory, stateful computation

can be used to restore CC even in the presence of non-determinism. This is because state can be used to memoize [29] computations. Thus CC can be implemented by memoizing the computation contained in the proof of totality. This suggests that constructive systems wanting to directly support (rather than just model) probabilistic or non-deterministically parallel algorithms should also support some form of state as well in order to be consistent with CC and the unification of the reals.

Background
While our discussion will be focused on constructive type theory, we want our find- ings to be relevant to set theory as well, and so we must discuss type theories with appropriate expressivenes. Since we will be building multiple such type theories to evaluate the various impacts of effects, to focus on the computational aspects of these theories we rely on known tools to generate the boilerplate. To this end we provide background on topos theory and tripos theory corresponding to models of type/set theory and higher-order logic.

From Set Theory to Topos Theory
In order to be comparable to common set theories, a type theory needs to exhibit certain important properties. One is that proofs must be irrelevant but not erased, meaning proofs can be used in computations so long as the result of the computation does not depend on the specifics of the proof. This enables functions to correspond to total and determined relations. Another is extensionality of entailment, i.e. that equality on predicates is extensional. This enables the correspondence between functions and total, determined relations to be bijective. Lastly, propositions must be impredicative, meaning there is a type/set (not just universe) of propositions, denoted Ω. This enables the construction of powersets.
Altogether these requirements place us in the setting of (elementary) topos the- ory [23]. Toposes are well established to form models of both set theory and exten- sional dependent type theories with impredicative propositions [34]. More specif- ically, since we here focus on Countable Choice, we work within the context of W -topos theory, i.e. toposes with a natural-number object modeling the natural numbers.

From Tripos Theory to Topos Theory
We will be particularly interested in toposes constructed from triposes [19, 35]. A tripos is a model of higher-order logic whose type theory is modeled by sets and functions. 1  Higher-order logic has a simple type theory—unit, pairs, and

1 A tripos is actually a model of higher-order dependent predicate logic whose dependent type theory is modeled by sets and functions, but the additional dependent structure is irrelevant for our purposes. We use triposes solely in order to construct toposes, and the process for doing so applies to any model of higher-order (simple) logic over any (simple) type theory [20, Corollary 6.1.7].

functions—and a predicate logic formed by T, ⊥, conjunction, disjunction, impli- cation, equality, and universal and existential quantification. Importantly, the type theory also includes a type, Ω, of propositions, whose terms correspond to proposi- tions in the predicate logic. Thus, higher-order logic provides a means of abstractly reasoning about relations, including impredicative quantification over propositions. Given a tripos modeling higher-order logic (or more generally a higher-order fibration [20, Definition 5.3.1] 2 ), one can construct a topos via the “tripos-to-topos construction” [19]. Whereas the tripos models a simple type theory, the resulting topos is well established to model a dependent type theory. And whereas the tripos might not model extensionality of entailment, the resulting topos necessarily will.
Thus the tripos-to-topos construction enables us to work in a simpler setting, with the more complex constructions being automatically generated for us.
Since this construction is standard, we only review the key components. First, an object in the constructed topos is given by a pair ⟨I, ≈I⟩ of a type I and a partial- equivalence relation ≈I on I×I in the tripos. Second, a morphism in the constructed topos from ⟨I, ≈I⟩ to ⟨J, ≈J ⟩ is a relation R on I × J that respects ≈I and ≈J in the tripos. This relation must be total, meaning ∀i : I. i ≈I i ⊃ ∃j : J. i R j holds in the tripos, and determined, meaning ∀i : I, j, jj : J. i R j ∧ i R jj ⊃ j ≈J jj holds in the tripos. Furthermore, two morphisms are considered equal if their relations are equivalent in the tripos, effectively baking in extensionality of entailment.

Realizability Toposes and Triposes
The tripos-to-topos construction is often used for building realizability models [24, 47] of (extensional, impredicative) dependent type theory. In particular, a real- izability topos is a topos that is constructed from a realizability tripos, where a realizability tripos is a tripos that is constructed from a partial combinatory alge- bra (of codes) through a process we discuss in Section 3.2. The key intuition is that a predicate on a set I specifies for each element i of I which codes (if any) “realize” that the predicate holds for i. This means that an object in the resulting realizability topos is a set I (from the metatheory) along with a relation i ≈I ij specifying which codes (if any) are considered to realize that i and ij are equal. A common example takes I to be set of natural numbers N and takes n ≈N nj to be realized solely by the Church encoding of n when n and nj are equal, and by nothing otherwise. Thus objects in a realizability topos conceptually specify a set I along with a computational interpretation of equality on I.
Another example is the object representing the powerset of natural numbers. For this object the set I is the set of predicates on N in the tripos. The predi- cate ≈I states that a code realizes that two predicates φ and ψ are equivalent if it can convert any realizer of φ(n) into the Church encoding of n and it can convert any realizer of φ(n) into a realizer of ψ(n) and vice versa. Thus two predicates are con-

2 There is an error in this definition due to a change in terminology across works [21]. The definition should only require a weak generic object. This is relevant and evident because realizability triposes have a strict generic object, which can only be shown to be weak generic objects. Non-weak generic objects furthermore model extensionality of entailment.

sidered equivalent if they are computationally strict, i.e. there is a computation that can extract the natural number for which the realizer holds, and computationally equivalent, i.e. there is a computation that can convert between the realizers.
Note that ≈I is not reflexive since there may not be a way to computationally realize that a predicate is strict. Hence, the predicate i ≈I i is often called the “ex- istence predicate” for i as it indicates that i “exists”. The definition of morphisms is designed so that they conceptually need only handle elements that exist according to this existence predicate.


Relating Topos and Tripos Models of Higher-Order Logic
A topos has an internal model of higher-order logic given by its subobjects, i.e. sub- sets [20, Corollary 5.4.9]. When a topos is constructed from a tripos, the inter- nal model of the topos is closely related to the associated tripos. In particular, (equivalence classes of) subobjects of ⟨I, ≈I⟩ in the topos bijectively correspond to (equivalence classes of) predicates on I that are strict with respect to ≈I in the tripos [20, Proposition 6.1.6(ii)]. As such, the interpretations of many propositional connectives, like conjunction, coincide in the two models.
However, there are some differences between these models. For example, the quantification ∀i : ⟨I, ≈I⟩. φ(i) in the topos corresponds to the quantification ∀i :
I. i ≈I i ⊃ φ(i) in the tripos, and similarly ∃i : ⟨I, ≈I⟩. φ(i) in the topos corresponds to ∃i : I. i ≈I i ∧ φ(i) in the tripos [20, Proposition 6.1.6(iii)]. That is, whenever the topos quantifies over an element i : ⟨I, ≈I⟩, the translation of that quantifi- cation in the tripos quantifies over an element of i : I and insists that i “exists”,
i.e. i ≈I i. This step in the translation is particularly important for realizability toposes since it means that proofs of ∀i : ⟨I, ≈I⟩. φ(i) can have access to a realizer that i “computationally exists”, i.e. i ≈I i, and that proofs of ∃i : ⟨I, ≈I⟩. φ(i) must provide a realizer that i “computationally exists”.


Countable Choice in a Tripos
CC has an internal and an external definition in topos theory that correspond to internal and external CC in set theory [23, 45]. In this paper we discuss internal CC because we are concerned about whether it can be used within the theory.
Definition 2.1 (Internal CC for Topos) CC holds internally in a W-topos when the following holds in its internal model of higher-order logic for all objects τ:
∀R : N × τ → Ω. (∀n : N.∃t : τ. n R t) ⊃ ∃f : N → τ.∀n : N. n R f (n)
In this paper we focus on toposes constructed from triposes, so we focus on this definition’s counterpart in tripos theory.
Definition 2.2 (Internal CC for Tripos) CC holds internally in a tripos when the following holds in its internal model of higher-order logic for all sets I:

∀R : N × I → Ω.	Tot(R) ⊃ ∃S : N × I → Ω. Tot(S) ∧ S ⊆ R ∧ Det(S)
where	Tot(R)	∀n : N. 𝕟n ⊃ ∃i : I. n R i
𝕟n	∀φ : N → Ω. φ(0) ∧ (∀nj : N. φ(nj) ⊃ φ(nj+1)) ⊃ φ(n) 3
S ⊆ R	∀n : N,i : I. n S i ⊃ n R i
Det(S)	∀n : N, i, ij : I. n S i ∧ n S ij ⊃ i =I ij



Lemma 2.3 A W-topos constructed from a tripos internally models CC iff the tripos internally models CC.
Proof In the case where τ is of the form ⟨I, =I⟩, this follows easily from interpret- ing Definition 2.1 in the model of strict predicates of the tripos, which is equiv- alent to the internal model of the topos constructed from that tripos [20, Propo- sition 6.1.6(ii)]. For τ of the form ⟨I, ≈I⟩, the S given by Definition 2.1 only re- spects =I , so one then defines n Sj i as ∃ij : I. ij ≈I i ∧ n S ij to get the appropriate relation that furthermore respects ≈I .	2
In the sequel we construct three triposes each based on a different notion of computation with respect to which effects are directly incorporated into the com- putational model. Using Lemma 2.3, we demonstrate that varying one’s notion of computation wildly affects the validity of CC in the resulting constructive type theory.
In order to avoid digressing into low-level details or metatheoretic concerns, we take ZFC [46] as our prevailing metatheory, though we do make a point to note where this particular choice of metatheory is relevant. All of the following lemmas and theorems have been mechanically verified, with more care taken towards metatheoretic concerns, so we refer readers interested in those details to the Coq proofs [13] or appendices.
Constructivism and Determinism
Realizability is at the heart of constructivism as it captures the notion of extracting (computable) content from proofs. In turn, partial combinatory algebras [15, 17] are at the heart of realizability as they formalize the key components of compu- tation that serve the proofs-as-programs correspondence. Indeed, a topos is called a realizability topos if it can be derived through a standard construction from a partial combinatory algebra. Due to the properties of this construction and of par- tial combinatory algebras, every realizability topos models CC [47], supporting the common understanding that CC holds constructively [7,9,25,32,33,36,44]. Next we review partial combinatory algebras and the relevant standard constructions, and we illustrate why CC follows from these foundations of constructivism.
3 𝕟 is designed so that defining n ≈N n′ as n =N n′ Λ 𝕟n makes ⟨N, ≈N⟩ a natural-number object in the constructed topos.

Partial Combinatory Algebras


Put simply, a computation accepts inputs and produces outputs. These inputs and outputs can themselves describe computation, i.e. computations are also data. A combinatory algebra formalizes this view, which is critical to developing Turing- complete systems like the λ-calculus, via a set of codes and an ability to apply codes to one another to produce outputs. However, another important aspect of Turing-completeness is that computations may not always manage to actually pro- duce an output, i.e. terminate. A partial combinatory algebra incorporates this by permitting application of codes to be partial.
Partial combinatory algebras are formalized in two steps. The first introduces the concepts of codes and application of codes—known as a partial applicative struc- ture. The second step then ensures that the partial applicative structure has the necessary expressiveness for modeling computational systems like the λ-calculus.
Definition 3.1 (Partial Applicative Structure) A partial applicative structure is a set C of “codes” c and a partial binary “application” operator · on C. We use cf · ca ↓ cr to denote cr being the (successful) result of the application cf · ca.
Given a partial applicative structure, one can consider application “expressions” such as (c1 ·(c2 · c3)) ·(c4 · c5). A partial combinatory algebra is a partial applicative structure that is “functionally complete”, meaning there is a way to encode such expressions with n free variables as individual codes accepting n arguments through applications.



e ::= i ∈ N | c ∈ C | e · e
En = {e | all is in e are < n}
c ↓ c
ef ↓ cf	ea ↓ ca	cf · ca ↓ cr
ef · ea ↓ cr


Definition 3.2 (Partial Combinatory Algebra) A partial combinatory algebra (PCA) is a partial applicative structure with an assignment of every expression e ∈ En+1 to a code cλn.e ∈ C that conceptually embodies the λ-calculus term binding the n +1 free variables in e, as formalized by the following requirements:
∀n.∀e ∈ En+2.∀ca. cλn+1.e · ca ↓ cλn.e[ca]	∀e ∈ E1.∀ca, cr. cλ0.e · ca ↓ cr ⇐⇒
e[ca] ↓ cr
Perhaps the more standard definition of PCAs is as partial applicative structures with S and K combinators satisfying certain behaviors [47]. These combinators are simply encodings of particular expressions that are sufficient to ensure that all ex- pressions can be encoded. In our formalization, the S and K combinators are simply the codes cλ2.(0 · 2) ·(1 · 2) and cλ1.0 modeling the λ-calculus terms λx.λy.λz. (x z) (y z) and λx.λy.x, respectively. Similarly, one can define a code cλ that Church-encodes

the natural number n:
cλ = cλ1.1	cλ

= cλ1.0 ·((cλ · 0) · 1)

0	n+1	n

Modeling Higher-Order Logic with PCAs
Given a PCA one can construct its corresponding realizability tripos via a standard construction [47]. The core intuition behind a realizability tripos is that a predicate on a set I specifies for each element i which codes from the PCA serve as realizers that the predicate holds for i, and that one predicate φ entails another ψ when there is a uniform code that converts all the realizers of φi, i.e. φ(i), to realizers of ψi for every i in I. Uniformity means that the code does not itself depend on i—the same code must work for all elements of I.
Uniformity is critical for ensuring entailment corresponds to computation. To see why, consider the fact that in every realizability tripos there is a predicate 𝕟 on the natural numbers N specifying that its only realizer for a natural number n is its Church encoding cλ. Given a function f : N → N in the metatheory, we can define another predicate on the natural numbers, call it φf , whose only realizer for
a given n is cλ	. Consider what it means for 𝕟 to entail φf . If entailment could be
evidenced by a different code cn for each n ∈ N, then 𝕟 entails φf for any function f

since cn could be the constant computation that returns cλ
. However, requiring

a uniform code that works for all indices n ∈ N ensures the predicate 𝕟 entails φf if and only if f is computable according to the PCA at hand. Thus uniformity ensures that entailment actually has computational significance.
With these intuitions in mind, we can informally describe how the various propo- sitional connectives are modeled by realizability triposes, with formal descriptions to come as a special case of the more general system in Figure 2. The realizers of a conjunction φ1 ∧ φ2 are simply the Church-encoded pairs of realizers of φ1 and φ2. The realizers of an implication φ1 ⊃ φ2 are simply the codes that, when applied to a realizer of φ1, necessarily produce a realizer of φ2. There are no realizers for ⊥, and the realizers of a disjunction φ1 ∨ φ2 are the Church-encoded tagged unions of realizers of φ1 and realizers of φ2. A realizer of a universal quantification ∀i:I.φi (for inhabited I) is anything that is a realizer of φi for every i ∈ I, whereas a realizer of an existential quantification ∃i:I.φi is anything that is a realizer of φi for some i ∈ I. Lastly, any code is a realizer of T, and any code is a realizer of i =I ij if and only if i and ij are equal in I in the metatheory.
Notice that the realizers for the quantifiers are themselves uniform. That is, a realizer of ∃i:I.φi has no computational way of knowing which i it is a realizer for, and similarly a realizer of ∀i:I.φi cannot computationally depend on the index i. Thus there is a difference between, for example, realizers of ∀n:N.φn versus realizers of ∀n:N. 𝕟n ⊃ φn. A realizer of the former must be a single code that simultaneously realizes all φns, whereas a realizer of the latter is a computation that maps each n to a realizer of φn.

Countable Choice in Realizability Triposes
Now we consider Countable Choice with this model of higher-order logic in mind. For this, we introduce a new notation, “∃i : I | φi. ψi”, indicating that there internally exists an i in I that externally satisfies φi and internally satisfies ψi.

A realizer of ∃i : I | φi. ψi is anything that is a realizer of ψi for some i ∈ I satisfying φi. We also denote n R i with R⟨n,i⟩, and we use R⟨n,i⟩(c) to denote that c is a realizer for R⟨n,i⟩.
Lemma 3.3 CC is equivalent in every realizability tripos to the following holding for every set I:
∀R : N × I → Ω. Tot(R) ⊃ ∃S : N × I → Ω | S ⊆ R Λ Det(S). Tot(S)
where
S ⊆ R = ∀n, i, c. S(n,i⟩(c) =⇒ R(n,i⟩(c)	Det(S)= ∀n, i, i′, c, c′. S(n,i⟩(c) Λ S(n,i'⟩(c′) =⇒ i = i′

Proof [13, E-A3] Given Lemma 2.3, this lemma essentially states that inclusion and determinism can be proven computationally if and only if they can be proven in the metatheory. The backwards direction of this is simple. Unfolding definitions, a realizer of inclusions is a code that uniformly converts realizers of S⟨n,i⟩ to realizers of R⟨n,i⟩. If inclusion is provable in the metatheory, then the identity computation exhibits inclusion trivially. Unfolding the definition of determinism, note that the equality predicate =I is computationally vacuous, meaning the realizers have no computational value beyond whether a realizer exists at all. In this case, i =I ij has a realizer if and only if i and ij are equal (in I) in the metatheory. Consequently, Det is itself computationally vacuous; it has a realizer if and only if S⟨n,i⟩ and S⟨n,i′⟩ both have realizers for a given n only when i equals ij in the metatheory. Thus, if determinism is provable in the metatheory, then the identity computation exhibits determinism since equality is realized by anything provided the equality holds.
The greater challenge is the forwards direction: showing there is a relation where inclusion and determinism hold in the metatheory whenever there is an appropriate relation where inclusion and determinism are proven computationally.  Given a

realizer cc of CC and a realizer cR
of totality for some relation R, then applying cc

R
tot
necessarily results in a triple of codes cS
S
det
, and cS
that realize inclusion,

determinism, and totality, respectively, for some relation S. Define a new relation Sˆ

such that Sˆ
is realized by c when R⟨n,i⟩
is realized by c and S⟨n,i⟩
has a realizer

(which can be anything). Clearly Sˆ is included in R in the metatheory. Similarly,
Sˆ is determined in the metatheory because it has realizers for ⟨n, i⟩ and ⟨n, ij⟩ only

when S does, which the existence of cS
realizing Det(S) in turn implies that i

and ij are equal. Lastly, totality of Sˆ is realized by the sequential composition

S
tot
realizing totality of S and cS
realizing inclusion of S into R.	2

Theorem 3.4 CC is modeled by every realizability tripos.
Proof [13, E-B1; adapted from 18] By Lemma 3.3, it is sufficient to provide a code that converts realizers that an arbitrary relation R is total into realizers that some metatheoretically-determined subrelation S of R is total. That code is simply the identity computation cλ0.0. To see why, note that the definition of S can depend on
the specific realizer cR that R is total. By the definition of totality, applying cR
to the Church encoding of any natural number n must result in a realizer, say cn, of R⟨n,i⟩ for some index i ∈ I, without specifying or even necessarily knowing what i is. In fact, the returned code might even be a realizer of R⟨n,i⟩ for multiple indices

in I. Let in ∈ I be such a corresponding index for each n ∈ N. 4 Define S⟨n,i⟩ to be realized by cn if and only if i equals in, trivially making S determined. Since each cn is a realizer of R⟨n,in⟩, S is a subrelation of R. Because application is deterministic,
applying cR to the Church encoding of n will always result in cn and hence always
be a realizer of S⟨n,in⟩, thereby realizing totality.	2
Thus all realizability toposes, which by definition are derived from PCAs, nec- essarily model CC.

Introducing Non-Deterministic Computation
Notice that the fact that application is deterministic is critical to the proof that realizability models exhibit CC. However, as we show next, determinism is entirely irrelevant to the realizability interpretation of higher-order logic. Rather, determin- ism is simply a historical artifact imposing an artificial constraint, and realizability can actually be similarly formulated on the basis of non-deterministic, i.e. relational, combinatory algebras. Thus, in this section we develop relational combinatory al- gebras, illustrate how they naturally still form a model of higher-order logic, and demonstrate that this natural generalization has dramatic effect on constructivism, with something as simple as a coin flip changing CC from being necessarily true to being necessarily false.

Relational Combinatory Algebras
In order to directly model non-deterministic computation, we developed relational combinatory algebras (RCAs), a generalization of PCAs in which the application operator is relational rather than functional. Thus applying one code to another can have zero, one, or many possible outcomes.
There is a subtlety to address though. Because PCAs are deterministic, if an application results in some code then that application always terminates. However, with RCAs, an application can successfully result in a code on one execution yet fail to terminate on another execution. Thus RCAs need a termination predicate in addition to an application relation.
Definition 4.1 (Relational Applicative Structure) A relational applicative struc- ture is a set C of “codes” c, an “application” relation cf · ca ↓ cr, and a “termina- tion” predicate cf · ca↓ satisfying the following:
Progress ∀cf , ca. cf · ca↓ =⇒ ∃cr. cf · ca ↓ cr
For a relational applicative structure, one can extend the termination predi- cate e↓ to applicative expressions:
ef ↓	ea↓	∀cf , ca. ef ↓ cf ∧ ea ↓ ca =⇒ cf · ca↓
c↓	ef · ea↓

4 This assumes CC in the metatheory, which is standard practice here, and which is why we assume specifically ZFC in this paper.




c ::= λn.En+1 | n | p
e[c]↓	e[c] ↓ c′

   
(λ0.e) · c↓	(λ0.e) · c ↓ c′	(λn+1.e) · c↓	(λn+1.e) · c ↓ λn.e[c]

p ::= constn | succ | on →n do p else p′ | flip
→n ::= n,... 
p · n↓	constn' · n ↓ n′	succ · n ↓ n +1	flip · n ↓ 0	flip · n ↓ 1


n ∈ →n	p · n ↓ n′
(on →n do p else p′) · n ↓ n′



n ∈/ →n	p′ · n ↓ n′
(on →n do p else p′) · n ↓ n′


Figure 1. Flip-RCA
Definition 4.2 (Relational Combinatory Algebra) A relational combinatory algebra is a relational applicative structure with an assignment of expressions e ∈ En+1 to codes cλn.e ∈ C satisfying the followings:
∀n.∀e ∈ En+2.∀ca, cr.	cλn+1.e · ca ↓ cr =⇒ cr = cλn.e[ca]
∀e ∈ E1.∀ca, cr.	cλ0.e · ca ↓ cr =⇒ e[ca] ↓ cr
∀n.∀e ∈ En+2.∀ca.	cλn+1.e · ca↓
∀e ∈ E1.∀ca.	e[ca]↓ =⇒ cλ0.e · ca↓
Each of these definitions are the straightforward generalizations of PCAs to non- terminating non-deterministic computation. That is, PCAs are simply the special case of RCAs in which application is deterministic and implies termination:

∀cf , ca, cr, cj . cf · ca ↓ cr ∧ cf · ca ↓ cj =⇒ cr = cj
∀cf , ca, cr. cf · ca ↓

r	r	r
cr =⇒ cf · ca↓

Modeling Higher-Order Logic with RCAs
Given an RCA one can construct its corresponding RCA tripos. All truths in this tripos are still realizable, suggesting that having the term “realizability tripos” refer specifically to PCAs is a misnomer. As such, we introduce the more accurate term “PCA tripos” for that particular notion of realizability.
The core intuition behind an RCA tripos is exactly the same as fora PCA tripos. A predicate on a set I specifies which codes from the RCA serve as realizers that the predicate holds for a particular element i. A predicate φ entails another predicate ψ when there is a uniform code that for all i ∈ I terminates when applied to any realizer of φi and any possible resulting code is a realizer of ψi. The constructions and the proofs are all the same as well, with formal descriptions to come as a special case of the more general system in Figure 2. Thus the deterministic behavior of PCAs is surprisingly irrelevant to their ability to model higher-order logic (and type theory), suggesting that RCAs are actually a more natural fit for realizability theory.
Refuting Countable Choice with Non-Determinism
This natural generalization of realizability theory, however, has major consequences. In particular, in Figure 1 we present Flip-RCA, an RCA whose corresponding tripos refutes CC simply due to the presence of a coin flip.
Flip-RCA is comprised of three key parts. The first is the λn.En+1 construct,

which describes a λ-value with n + 1 variables. This construction makes functional completeness trivial, since the code cλn.e is simply given by λn.e. The termina- tion and reduction rules are standardly defined to guarantee such codes behave as required by functional completeness.
The second key part is the natural-number codes n and primitives succ and on →n do p else pj. These are not strictly necessary, but they make the proof much simpler due to the fact that every “primitive” p only accepts inputs and produces outputs of the form n. In particular, on →n do p else pj emulates the behavior of p on a finite list of inputs →n and otherwise defers to pj. Also, defining cast(e) as e · succ · 0 provides an expression that evaluates to n whenever the expression e evaluates to the Church encoding of n.
The third key part is flip, the only source of non-determinism in the system that makes this an RCA that is not a PCA. All flip does is non-deterministically evaluate to either 0 or 1.
Lemma 4.3 Flip-RCA is an RCA.
Proof [13, E-C2] The cλn.e codes are given by the λn.e codes.	2
This simple coin flip is enough to refute CC. To demonstrate how, we rely on the following lemma capturing the fact that Flip-RCA describes an extensional finitary
computational system. In the lemma we use c˙ to informally denote codes with
a “primitive hole” such that c˙[p] denotes the code resulting from filling that hole with the primitive p. The formal definitions are tedious and thus omitted here, but can be found in [13, E-C3]. The lemma states that any reduction involving a primitive follows from only finite interactions with that primitive, and so the reduction can proceed similarly for any other primitive that can also exhibit those same interactions.
Lemma 4.4 For all c˙f , c˙a, p, and cr, such that c˙f [p] · c˙a[p] ↓ cr holds, there exists a c˙r satisfying:
cr = c˙r[p] ∧ ∃B ⊆ N × N. B is ﬁnite ∧ ∀⟨ni, no⟩∈ B. p · ni ↓ no
∧ ∀pj. (∀⟨ni, no⟩∈ B. pj · ni ↓ no) =⇒ c˙f [pj] · c˙a[pj] ↓ c˙r[pj]
Proof [13, E-C4] Induction on the proof of c˙f [p] · c˙a[p] ↓ cr.	2
Lemma 4.5 CC is internally equivalent in every RCA tripos to the following hold- ing for every set I:
∀R : N × I → Ω. Tot(R) ⊃ ∃S : N × I → Ω | S ⊆ R ∧ Det(S). Tot(S)
Proof [13, E-A3] Same definitions of S ⊆ R and Det(S) and proof as with PCAs in Lemma 3.3.	2
Theorem 4.6 There exists a set I for which the negation of CC is internally mod- eled by the Flip-RCA tripos.
Proof [13, E-C5] We use N as the set I for which we prove this negation. RCA (and PCA) triposes model ¬φ if φ has no realizers. Thus it suffices to show that

the existence of a realizer of CC onto N for Flip-RCA leads to a contradiction. By Lemma 4.5, we can do so by showing there is no code that can convert realizers of totality for relations R on N into realizers of totality for some metatheoretically- determined subrelation of R.
Suppose cc is such a code. Consider applying cc to λ0.const0 · cast(0). The code λ0.const0 · cast(0) is a realizer of totality for the relation R0 whose sole realizer
for R0 ′ is 0 when nj equals 0. Thus this application terminates and results in
a realizer c0	of totality for some subrelation S0 of R0. Since R0 is a determined

relation, one can easily deduce that this implies that c0
results in 0 whenever it is

applied to a Church encoding of a natural number.
Now define c˙ to be λ0.•· cast(0) so that c˙[const0] is λ0.const0 · cast(0). Lemma 4.4 implies there is a c˙tot and some finite behavior B exhibitable by const0 such that

c˙tot [const0] equals c0
and applying cc to c˙[p] can reduce to c˙tot [p] whenever p can

exhibit behavior B. Let →n be the list of inputs in B. Then on →n do const0 else p is guaranteed to exhibit behavior B regardless of what p is. Thus applying cc to c˙[on →n do const0 else p] can reduce to c˙tot [on →n do const0 else p] for any primi- tive p.
There are two particularly important primitives to consider. One is primi- tives of the form constm, in which case c˙[on →n do const0 else constm] is a realizer

of totality for the relation R→n;m whose sole realizer for R→n;m
is 0 when n is in →n

and nj equals 0, or m when n is not in →n and nj equals m. This implies that c˙tot[on →n do const0 else constm] is a realizer of totality for some subrelation S→n;m of R→n;m. Again, since R→n;m is a determined relation, one can easily deduce that this implies that c→n;m = c˙tot [on →n do const0 else constm] results in m whenever it is applied to a Church encoding of a natural number not in →n.
The other important case is the primitive flip. Then, c˙[on →n do const0 else flip] is a non-deterministic realizer of totality for the relation RN whose sole realizer

for RN
′ is nj for any n. This implies that cflip
= c˙[on →n do const0 else flip] is a 

realizer of totality for some determined subrelation SN of RN. Now consider what happens when we apply cflip to some n not in →n. We know that c→n;m · n evaluates
tot	tot
to m. Since flip can recreate the input-output behaviors of both const0 and const1,
Lemma 4.4 implies that cflip · →n can evaluate to both 0 and 1. This means that

0 must realize SN
for some n0, and similarly 1 must realize SN
for some n1.

Since 0 can only realize RN	when n0 equals 0, and SN is a subrelation of RN, this
implies n0 must equal 0, and similarly n1 must equal 1. Thus both SN  and SN
are realizable. Since the assumed behavior of cc implies that SN is determined, this implies 0 equals 1, thereby producing a contradiction.	2
Interestingly, this proof can easily be modified to show that Flip-RCA refutes even Weak Countable Choice, which states that choice is possible if there is at most one choice to be made across all the countable inputs [10]. Weak Countable Choice is sufficient to unify the various formulations of the reals [10], thus suggesting that the Cauchy, modulated Cauchy, and Dedekind reals might indeed be distinct in the topos for Flip-RCA.

Introducing Stateful Computation
We have shown that, although non-determinism naturally fits into realizability mod- els of higher-order logic, a flip of a coin can invalidate CC despite it holding so trivially before. Now we demonstrate that further extending the computation sys- tem with mutable state can restore CC even in the presence of non-determinism. This means that CC is not wholly incompatible with non-determinism, contrary to Schuster’s concern [41].


Stateful Combinatory Algebras
In order to directly model stateful computation, we developed stateful combinatory algebras (SCAs), a generalization of RCAs in which the application operator is stateful. That is, applying one code to another requires a state that it can then mutate. Just as there are PCAs that can model non-deterministic computation [42], PCAs can model state by using, say, the state monad [31]. But it is impossible to force PCA computations to share state—the requirements for the S combinator force it to duplicate any state a PCA computation might be using. SCAs ensure that all computation operates on the same mutating state, which, as we show, is a critical component in their ability to implement CC even in the presence of non-deterministic computation.
Definition 5.1 (Stateful Applicative Structure) A stateful applicative struc- ture is an inhabited set Σ of “states” σ, a “possible future” preorder σ ≤ σj, a set C of “codes” c, 5 an “application” relation cf · ca ↓σ′ cr, and a “termination”
predicate cf · ca↓σ satisfying the following properties:
Preservation ∀σ, cf , ca, σj, cr. cf · ca ↓σ′ cr =⇒ σ ≤ σj
Progress ∀σ, cf , ca. cf · ca↓σ =⇒ ∃σj, cr. cf · ca ↓σ′ cr
The concept of “possible futures” here captures the fact that, even in a system with mutable state, the system can maintain certain invariants about its state and how it progresses, as enforced by the preservation property. These invariants will be critical to implementing CC. Note, though, that the application relation and termi- nation predicate are not themselves necessarily preserved by futures; an application is permitted to reduce to a code in a given state that it cannot reduce to in a future state, and a termination only guarantees that the current state can be mutated to provide a result. Thus this is not simply a standard possible-worlds structure [26]. We extend the definitions of application e ↓σ′ cr and termination e↓σ to applica-
tive expressions as follows:


5 Our Coq formalization [13, C-D1] also permits one to specify a “validity” predicate σ ▶ c indicating which codes are valid in which states. Here we elide this additional degree of control as it is irrelevant for the current discussion.

ef ↓σ′ cf
′
ea  σ′′ ca
cf · ca
′′
σ′′′ cr



c ↓σ c

e ↓σ	∀σj,c . e ↓σ c
ef · ea ↓σ′′′ cr
=⇒ e ↓σ′ ∧ ∀σjj,c . e ↓σ′ c

=⇒ c

· c ↓σ′′

f


c↓σ
f	f  σ′  f
a
ef · ea↓σ
a	a  σ′′  a	f	a

Definition 5.2 (Stateful Combinatory Algebra) A stateful combinatory alge- bra is a stateful applicative structure with an assignment of every expression e ∈ En+1 to a code cλn.e ∈ C satisfying the following properties in all states σ, σj ∈ Σ:

∀n.∀e ∈ En+2.∀ca, cr.	cλn+1.e · ca ↓σ′ cr =⇒ σj
= σ ∧ cr = cλn.e[ca]

∀e ∈ E1.∀ca, cr.	cλ0.e · ca ↓σ′ cr =⇒ e[ca] ↓σ′ cr
σ	σ
∀n.∀e ∈ En+2.∀ca.	cλn+1.e · ca↓σ
∀e ∈ E1.∀ca.	e[ca]↓σ  =⇒ cλ0.e · ca↓σ
RCAs are the special case of SCAs with precisely one state.

Modeling Higher-Order Logic with SCAs
Since PCAs and RCAs are each special cases of SCAs, we were informal about how they model impredicative higher-order logic. Now we provide a formal de- scription of the model in Figure 2. One technical note is that types in our model are inhabited sets. This technically means that our model specifies a higher-order fibration [20, Definition 5.3.1] 6 , which is a generalization of a tripos. We do this because it permits a simpler interpretation of universal quantification. Furthermore, the standard tripos-to-topos construction works for any higher-order fibration [20, Corollary 6.1.7], so the applicability to set theory and type theory is maintained. In fact, the resulting topos is equivalent to the topos that would be derived from the tripos construction.
Theorem 5.3 For any SCA, Figure 2 speciﬁes a consistent model of higher-order logic.
Proof [13, D-C1] The remaining components and proofs for a higher-order fibration follow easily from the definitions in Figure 2. The only thing we prove explicitly here is consistency.
A proposition φ in Figure 2 is realizable if there exists a state σ and code cφ such that φσ(cφ) holds. The progress property of SCAs and the definition of entailment in Figure 2 imply that when a proposition entails another one, realizability of the former implies realizability of the latter. Since the proposition T is realizable and the proposition ⊥ is not, T cannot entail ⊥, guaranteeing consistency of the model for any SCA.	2
6 There is an error in this definition due to a change in terminology across works [21]. The definition should only require a weak generic object. This is relevant and evident because realizability triposes have a strict generic object, which can only be shown to be weak generic objects. Non-weak generic objects furthermore model extensionality of entailment.

Notation	Predicates

cf · ca ↓σ φ , cf · ca↓σ Λ ∀σ′, cr. cf · ca ↓σ' cr	=⇒
φσ' (c )
Fibration	
Type A type τ is an inhabited set.
Top The predicate T in Γ is realized by (any) c
for γ in σ.
Conjunction The predicate φ × ψ in Γ is real- ized by c for γ in σ if the following holds:

Context A context Γ is an inhabited set.
∀σ′. σ ≤ σ′ =⇒ c · c

λ1 .1
↓σ' φ
Λ c · c

λ1 .2
↓σ'

Proposition A proposition φ is a “stateful” predicate on codes φσ(c) that is “future-stable”:

∀σ, σ′, c. σ ≤ σ′ Λ φσ(c) =⇒ φσ' (c)
ψγ


Bottom The predicate ⊥ in Γ has no realizers for γ in any σ.
Disjunction The predicate φ∨ψ in Γ is realized

Predicate A predicate φ in context Γ assigns to each in- habitant γ of Γ a proposition φγ .
by cλ1 .1 · cφ
by cλ1 .2 · cfi
for γ in σ if φσ(cφ) holds, and
for γ in σ if ψσ(cψ) holds.

Entailment A predicate φ entails a predicate ψ in Γ if there exists a code c satisfying the following:
∀γ ∈ Γ.∀σ, cφ. φσ(cφ) =⇒ c · cφ ↓σ ψγ

Substitution A substitution t from a context Γ to a con- text Γ′ is a function from Γ to Γ′. For a predicate φ in context Γ′, the substituted predicate φ[t] in Γ is realized by c for γ in σ when φσ (c) holds.
Types
Unit The type 1 is the singleton set 1.
Product The type τ × τ′ is the set of pairs τ × τ′.
Function The type τ → τ′ is the set of functions τ → τ′.
Impredicativity The	type		Ω	is	the	set	of future-stable	stateful	predicates		on		codes
{φ ⊆ Σ × C | φ is future-stable}.
Implication The predicate φ ⊃ ψ in Γ is real- ized by c for γ in σ if the following holds:

'	'
∀σ , cφ. σ ≤ σ Λ φγ (cφ) =⇒ c · cφ ↓
ψγ


Equality The predicate =τ  in context Γ × (τ × τ ) is realized by (any) c for
⟨γ, ⟨x, y⟩⟩ ∈ Γ × (τ × τ ) in σ if x equals y.
Universal Quantification For a predicate φ in a context Γ × τ , the predicate ∀τ.φ in Γ is realized by c for γ in σ if ∀x ∈ τ. φσ  (c)
holds.
Existential Quantification For a predicate φ in a context Γ × τ , the predicate ∃τ.φ in Γ is realized by c for γ in σ if ∃x ∈

σ
(γ,x⟩
Figure 2. SCA Model of Higher-Order Logic
(c) holds.

Restoring Countable Choice with State
Next we show that introducing state enables SCA triposes to model CC even in the presence of non-determinism. In particular, we use state to memoize realizers of totality. Memoization [29] (whose original intent was to optimize computation) is the method of wrapping a computation with something that keeps track of inputs already passed to this computation and their corresponding outputs. Most impor- tantly for our purposes, it has the benefit of always providing the same output for a given input even when the generating computation is itself non-deterministic. While we could provide a general proof that a tripos for any SCA with a special memoiz- ing combinator models CC, due to space constraints we simply provide a concrete example of such an SCA. Thus Figure 3 defines Mem-SCA, whose ndnat code pro- vides non-determinism, and whose memo code implements memoization (via lookup codes).
Mem-SCA is presented in two parts. We describe the left-hand side of Figure 3 first, which formalizes pre-states and a “frozen” computational system under a given pre-state ς. A pre-state is comprised of an “allocation” table α and a “memoization” table μ. These tables do not necessarily satisfy the invariants of the system that will enable Mem-SCA to model CC, but they are sufficient for specifying a computational system. An entry ⟨l, c⟩ in an allocation table α indicates that the memoizations at location l should be generated by code c. An entry ⟨l, n, c⟩ in a memoization table μ




Figure 3. Mem-SCA

indicates that the input n has a memoized output c at location l. Consequently, the computational system specifies that memo applied to a code c can reduce to a lookupl for any location l whose entries should be generated by c according to α. Similarly, the computational system specifies that lookupl applied to a Church-encoded natural number n can reduce to a memoized ouput c for input n at location l according to μ. The remainder of the computational system behaves as expected for the λ-calculus, with the addition that ndnat can reduce to any Church-encoded natural number.
Note that a pre-state does not actually guarantee that the entries in its mem- oization table are generated according to its allocation table, nor does it have any notion of mutating state. Both of these issues are addressed by the right-hand side of Figure 3, which formalizes states and a mutating computational system. A state is a pre-state satisfying additional invariants. First and second, a given location can be generated by at most one code and can have at most one memoized output for each given input. Third, every memoized output is indeed a possible result of applying the input to the generating code. Last, the tables are finite. A state’s possible futures are simply all states containing its entries (and possibly more). Termination is straightforward, with the one subtlety that lookupl only terminates on inputs that its generating code terminates on. Lastly, mutating reduction does not actually prescribe how the state should be mutated—instead, its effect is that the state can be mutated to any future state provided the application would re- duce according to the frozen computational system, i.e. provided the future state has enough entries that the application can reduce without needing to add more entries. This means that the issue of determining actually how to mutate the state such that the reduction can be completed is delegated to the proof of progress.
Lemma 5.4 Mem-SCA is an SCA.
Proof [13, E-D2] We provide the only interesting aspect of this proof, which is progress. For this, we rely on the fact that cf · ca ↓ς cr is easily shown to imply
′
cf · ca ↓ς c whenever ςj contains all the entries in ς. Progress is proven by in-
duction on the proof of termination, the only interesting cases for which are memo
and lookupl.

Suppose memo · ca↓σ holds. We need to provide a state σj and a code cr such that memo · ca ↓σ′ cr holds. Since ασ is finite, there is an “unused” location l. Define ςj to be ςσ with ⟨l, c⟩ added to the allocation table, and define cr to be lookupl. The required reduction and the fact that the pre-state ςj satisfies the requirements to provide a state σj follow easily.
Now suppose lookupl · ca↓σ holds. We need to provide a state σj and a code cr such that lookupl · ca ↓σ′ cr holds. The assumption implies that ca is the Church encoding of some natural number n, that l has a corresponding code cf in the allocation table ασ, and that cf · cλ↓σ holds. Since μσ is finite we can check to see if it has a code c corresponding to l and n, in which case σj is simply σ and cr is simply c. Otherwise, by the induction hypothesis cf · cλ↓σ entails the existence
of a state σˆ and code cˆ such that cf · cλ	σ cˆ holds. Again, since μσˆ is finite we
can check to see if it has a code cj corresponding to l and n, in which case σj is simply σˆ and cr is simply cj. Otherwise, we define ςj to be ςσˆ with ⟨l, cˆ⟩ added to the allocation table, and we define cr to be cˆ. The required reduction and the fact that the pre-state ςj satisfies the requirements to provide a state σj follow easily. 2
Lemma 5.5 CC is internally equivalent in every SCA tripos to the following hold- ing for every set I:
∀R : N × I → Ω. Tot(R) ⊃ ∃S : N × I → Ω | S ⊆ R ∧ Det(S). Tot(S)
where

S ⊆ R :	∀n, i, σ, c. Sσ
(c) =⇒ Rσ
(c)

Det(S):	∀n, i, ij, σ, c, cj. Sσ	(c) ∧ Sσ ′ (cj) =⇒ i = ij
⟨n,i⟩	⟨n,i ⟩
Proof [13, E-A5] The reasoning is very similar to PCAs and RCAs except for one

nuance with state. One applies cc to cR
as before, now in some given state σ, to

again get a triple of codes cS
S
det
, and cS
, and a future state σj. As before, define

the new relation Sˆ such that Sˆσ′′
is realized by c when Rσ′′
is realized by c, Sσ′′

has a realizer, and σjj is a possible future of σj. This final requirement addresses the

fact that cS
S
det
, and cS
are only guaranteed to exhibit their expected behaviors

in state σj and any of its possible futures due to the future-stability of propositions.
Consequently, the remainder of the proof can proceed as before.	2
Note that the definition of Det(S) in Lemma 5.5 requires realizability of S⟨n,i⟩
j
and S⟨n,i′⟩ to imply that i and i are equal only if they are realizable in the same
state σ. Thus it is perfectly acceptable for S⟨n,i⟩ and S⟨n,i′⟩ to be realizable for distinct i and ij in distinct states. Furthermore, totality of S only requires S⟨n,i⟩ to eventually be a realizable for some i for each n. Thus S can be non-deterministic
across states and be only finitely defined at any particular state, which is how we address the challenges of non-determinism.
Theorem 5.6 CC is internally modeled by the tripos for Mem-SCA.
Proof [13, E-D3] The realizer of the proposition in Lemma 5.5 for Mem-SCA is

simply memo. Suppose cR
is a realizer of totality in a given state σ for a relation R.

We need to show that memo · cR
terminates in σ, and that any code it can reduce

to in a possible future σj is necessarily a realizer of totality in σj of some determined subrelation of R. Termination is trivial since memo is defined to terminate on all inputs in all states, so reduction is the primary challenge.

By definition, memo · cR
only reduces to lookupl and only in states σj for which

⟨l, cR ⟩ is in ασ′ . Thus we need to show that lookupl is a realizer of totality in σj for
σ′′	σ′′
some determined subrelation of R. Let cn  denote codes for which ⟨l, n, cn ⟩∈ μσ′′
and σj ≤ σjj hold, which (if it exists) is necessarily unique for a given σjj. Note

that, if cσ′′ exists, then it is a realizer of Rσ′′
for some i. The reason is that, by

n	⟨n,i⟩
the required properties of states, in order to be in the memoization table for l the
code cσ′′ must be a possible result of applying the generator for l (as specified by α)

to cλ. By assumption, that generator is cR
and consequently a realizer of totality

n	tot

of R, so its output on input cλ is necessarily a realizer of Rσ′′
for some i. So let

n	⟨n,i⟩

iσ′′ be a selection of indices in I such that cσ′′ is a realizer of Rσ′′
, and such that

n	n	⟨n,iσ′′ ⟩
iσ′′′ equals iσ′′ whenever both are defined and σjjj is a possible future of σjj (and so

n
cσ′′′
n
σ′′  7

n	equals cn ).
Given these choices, define Sσ′′
(c) to hold when c equals cσ′′
and when i

equals iσ′′
(and both cσ′′
and iσ′′
exist). Each proposition S
⟨n,i⟩
is future-stable

because cσ′′ is future-stable and each iσ′′ was chosen to be future-stable. Since we

n
already established that cσ′′
n
is a realizer of Rσ′′
n
, S is a subrelation of R. By

definition, Sσ′′
σ′′
⟨n,i′⟩
are both realizable in a given state σjj only when both

equal in , ensuring determinism of S. It remains to prove that lookupl is a realizer
of totality for S. Since cR is a realizer of totality in σj, it terminates on all Church-
encoded natural-number inputs in σj, which implies lookupl does as well. Any code that can result from applying lookupl to a cλ in a possible future σjj is necessarily

in the memoization table for l in σjj
′′
and therefore equal to cn , which by definition

is a realizer of S⟨n,iσ′′ ⟩ in σjj. Thus lookupl is a realizer of totality for a determined subrelation of R, and hence memo is a realizer of the proposition in Lemma 5.5, thereby evidencing that the tripos for Mem-SCA models CC.	2
Although we do not formally develop it here, a similar SCA can even model a principle known as dependent choice (DC), which is strictly stronger than CC [4,22]. The state provides a table in which each entry of the required sequence is simply generated on demand from the previous one according to the allocated realizer of totality. As with Mem-SCA, this works even in the presence of non-determinism.
Related Work and Conclusions
This paper demonstrates that key principles of constructivism highly depend on the effectful notion of the computation system, using CC as an illustrative example. We show that the traditional constructive proof of CC fundamentally relies upon a deterministic computational system, and that adding even a coin flip entails its

7 This assumes Zorn’s Lemma in the metatheory, which is why we assume specifically ZFC in this pa- per. The Coq proof provides a more careful construction that, as is standard practice here, assumes only countable choice in the metatheory [13, E-D3].

negation. We further show that then adding mutable state to the computational system makes it again possible to implement CC. In doing so, the paper extends the boundaries of constructivism towards a truly proofs-as-programs paradigm, not just a proofs-as-deterministic-programs paradigm.
This paper focuses on the effect of effects on existing principles of constructivism. Other works similarly each make some choice principle compatible with computa- tions with continuations [3, 16, 30]. Interestingly, despite the difference in goals, these systems use techniques as coinduction, lazy evaluation, and infinite terms that are employed in a manner bearing resemblance to our memoization technique. It would also be interesting to explore what new principles might be made possible by effects. For example, Bickford et al. [6] explore using the stateful nature of Nuprl’s library system to provide free-choice sequences [11]. We suspect these techniques can be combined to model both CC and free choice, and even extended
to support notions of choice almost reaching ZFC.

References
Stuart F. Allen, Mark Bickford, Robert L. Constable, Richard Eaton, Christoph Kreitz, Lori Lorigo, and Evan Moran. Innovations in Computational Type Theory using Nuprl. Journal of Applied Logic, 4(4):428–469, 2006.
Joseph L. Bates and Robert L. Constable. Proofs as Programs. Transactions on Programming Languages and Systems, 7(1):113–136, January 1985.
Stefano Berardi, Marc Bezem, and Thierry Coquand. On the Computational Content of the Axiom of Choice. Journal of Symbolic Logic, 63(2):600–622, 1998.
Paul Bernays. A System of Axiomatic Set Theory. Part III. Infinity and Enumerability. Analysis.
Journal of Symbolic Logic, 7(2):65–89, 1942.
Yves Bertot and Pierre Casteran. Interactive Theorem Proving and Program Development. Springer- Verlag Berlin Heidelberg, 2004.
Mark Bickford, Liron Cohen, Robert L. Constable, and Vincent Rahli. Computability beyond Church- Turing via Choice Sequences. In Logic in Computer Science, pages 245–254, 2018.
Errett Bishop and Douglas Bridges. Constructive Analysis. Springer-Verlag Berlin Heidelberg, 1985.
Ana Bove, Peter Dybjer, and Ulf Norell. A Brief Overview of Agda – A Functional Language with Dependent Types. In Theorem Proving in Higher Order Logics, pages 73–78, 2009.
Douglas Bridges and Fred Richman. Varieties of Constructive Mathematics. London Mathematical Society Lecture Notes Series. Cambridge University Press, 1987.
Douglas Bridges, Fred Richman, and Peter Schuster. A Weak Countable Choice Principle. Proceedings of the American Mathematical Society, 128(9):2749–2752, 2000.
L. E. J. Brouwer. Begru¨ndung der Mengenlehre unabha¨ngig vom logischen Satz vom ausgeschlossenen Dritten. Zweiter Teil: Theorie der Punktmengen. Verhandelingen der Koninklijke Nederlandse Akademie van Wetenschappen te Amsterdam (Eerste Sectie), 12(7), 1919.
L. E. J. Brouwer. Brouwer’s Cambridge Lectures on Intuitionism. Cambridge University Press, 1981.
Liron Cohen, Sofia Abreu Faro, and Ross Tate. The Effects of Effects on Constructivism: Coq Proof. preprint, 2019. URL: https://www.cs.cornell.edu/~ross/publications/effectful/

R. L. Constable, S. F. Allen, H. M. Bromley, W. R. Cleaveland, J. F. Cremer, R. W. Harper, D. J. Howe, T. B. Knoblock, N. P. Mendler, P. Panangaden, J. T. Sasaki, and S. F. Smith. Implementing Mathematics with the Nuprl Proof Development System. Prentice-Hall, Inc., 1986.
Solomon Feferman. A Language and Axioms for Explicit Mathematics. In Algebra and Logic, pages 87–139, 1975.


Hugo Herbelin. A Constructive Proof of Dependent Choice, Compatible with Classical Logic. In Logic in Computer Science, pages 365–374, 2012.
Pieter J. W. Hofstra. Partial Combinatory Algebras and Realizability Toposes. 2004.
J. M. E. Hyland. The Effective Topos. In The L. E. J. Brouwer Centenary Symposium, volume 110 of Studies in Logic and the Foundations of Mathematics, pages 165–216. North-Holland, 1982.
J. M. E. Hyland, P. T. Johnstone, and A. M. Pitts. Tripos Theory. Mathematical Proceedings of the Cambridge Philosophical Society, 88(2):205–232, 1980.
Bart Jacobs. Categorical Logic and Type Theory, volume 141 of Studies in Logic and the Foundations of Mathematics. North-Holland, 1998.
Bart Jacobs. Personal communication, 2014.
R. B. Jensen. Independence of the axiom of dependent choices from the countable axiom of choice (abstract). Journal of Symbolic Logic, 31(2):294, 1966.
Peter T. Johnstone. Sketches of an Elephant: A Topos Theory Compendium, volume 1. Oxford University Press, 2002.
S. C. Kleene. On the Interpretation of Intuitionistic Number Theory. The Journal of Symbolic Logic, 10(4):109–124, 1945.
Stephen Cole Kleene and Richard Eugene Vesley. The Foundations of Intuitionistic Mathematics: Especially in Relation to Recursive Functions, volume 39 of Studies in Logic and the Foundations of Mathematics. North-Holland, 1965.
Saul A. Kripke. Semantical Considerations on Modal Logic. Acta Philosophica Fennica, 16(16):83–94, 1963.
Robert S. Lubarsky. On the Cauchy Completeness of the Constructive Cauchy Reals. Electronic Notes in Theoretical Computer Science, 167:225–254, 2007. Proceedings of the Third International Conference on Computability and Complexity in Analysis.
A. A. Markov. On the Continuity of Constructive Functions. Uspekhi Matematicheskikh Nauk, 9(3):226–230, 1954. Meetings of the Moscow Mathematical Society.
Donald Michie. “Memo” Functions and Machine Learning. Nature, 218(5136):19–22, 1968.
E´tienne Miquey. A Sequent Calculus with Dependent Types for Classical Arithmetic. In Logic in Computer Science, pages 720–729, 2018.
Eugenio Moggi. Notions of Computation and Monads. Information and Computation, 93(1):55–92, 1991. Selections from 1989 IEEE Symposium on Logic in Computer Science.
Joan Rand Moschovakis and Garyfallia Vafeiadou. Some Axioms for Constructive Analysis. Archive for Mathematical Logic, 51(5-6):443–459, 2012.
John Myhill. Constructive Set Theory. The Journal of Symbolic Logic, 40(3):347–382, 1975.
Gerhard Osius. Categorical Set Theory: A Characterization of the Category of Sets. Journal of Pure and Applied Algebra, 4(1):79–119, 1974.
Andrew M. Pitts. Tripos Theory in Retrospect. Mathematical Structures in Computer Science, 12(3):265–279, 2002.
Michael Rathjen. Choice Principles in Constructive and Classical Set Theories. In Logic Colloquium, Lecture Notes in Logic, pages 299–326. Cambridge University Press, 2002.
Fred Richman. Constructive Mathematics without Choice. In Reuniting the Antipodes — Constructive and Nonstandard Views of the Continuum, pages 199–205. Springer Netherlands, 2001.
Fred Richman. Pointwise Differentiability. In Reuniting the Antipodes — Constructive and Nonstandard Views of the Continuum, pages 207–210. Springer Netherlands, 2001.
Wim Ruitenburg. Constructing Roots of Polynomials over the Complex Numbers. In Computational Aspects of Lie Group Representations and Related Topics, pages 107–128, 1990.
Peter M. Schuster. Elementary Choiceless Constructive Analysis. In Computer Science Logic, pages 512–526, 2000.
Peter M. Schuster. Countable Choice as a Questionable Uniformity Principle. Philosophia Mathematica, 12(2):106–134, 2004.


Dana Scott. Completeness and Axiomatizability in Many-Valued Logic. In Proceedings of the Tarski Symposium, pages 411–436, 1974.
A. S. Troelstra. History of Constructivism in the 20th Century. In Set Theory, Arithmetic, and Foundations of Mathematics: Theorems, Philosophies, Lecture Notes in Logic, pages 150–179. Cambridge University Press, 2011.
A. S. Troelstra and D. van Dalen. Constructivism in Mathematics: An Introduction, Volume I, volume 121 of Studies in Logic and the Foundations of Mathematics. North-Holland, 1988.
Benno van den Berg. Predicative Topos Theory and Models for Constructive Set Theory. PhD thesis, Utrecht University, 2006.
Jean van Heijenoort. From Frege to Go¨del: A Source Book in Mathematical Logic, 1879–1931. Harvard University Press, 1967.
Jaap van Oosten. Realizability: An Introduction to its Categorical Side, volume 152 of Studies in Logic and the Foundations of Mathematics. North-Holland, 2008.

Coq Formalization: Table of Contents

3	Definition of a Stateful Combinatory Algebra . . . . . . . . . . . . . . . . . . . . . . . . . . 
Lambdas.v
112

1	Framework for Building Codes with Lambda-Terms and Primitives	112
FreeRCA.v
1	Framework for Building Relational Combinatory Algebras with Lambda-Terms and Primitives .	112
FreeSCA.v
1	Framework for Building Stateful Combinatory Algebras with Lambda-Terms and Primitives	112
Higher-Order Fibrations	113
HOFs.v
1	Definition of a Higher-Order Fibration	113
RCAstoHOFs.v
1	Proof that a Relational Combinatory Algebra forms a Higher-Order Fibration	114
SCAstoHOFs.v
1	Proof that a Stateful Combinatory Algebra forms a Higher-Order Fibration	115
Countable Choice	116
CountableChoice.v
E-A1	Definition of Internal Countable Choice in Evidenced Frames	116
E-A2	Definition of Internal Countable Choice in Relational Combinatory Algebras	116
E-A3	Proof that Internal CC for a PCA/RCA is Equivalent to Internal CC for its Higher-Order
Fibration	116
4	Definition of Internal Countable Choice in Stateful Combinatory Algebras	116
5	Proof that Internal CC for an SCA is Equivalent to Internal CC for its Higher-Order Fibration	117
CCPCAs.v
1	Proof that Partial Combinatory Algebras Internally Model Countable Choice	117
NCCRCA.v
1	Definition of Flip-RCA	117
E-C2	Proof that Flip-RCA is an RCA	117
E-C3	Definition of Flip-RCA Codes with Primitive Holes	117
E-C4	Proof that Flip-RCA is Extensional and Finitary	118
E-C5	Proof that Flip-RCA Internally Negates Countable Choice	118


E-D CCSCA.v
Overview
The contributions of this paper have all been mechanically verified. This appendix is intended to let the reader know what exactly has been mechanically verified. In particular, it provides all the relevant formal definitions and formal statements of the lemmas and theorems. It does not, however, walk through the proofs in detail. For that, we refer the interested reader to directly interact with the Coq proofs themselves [13].
A-A. Conventions
Because Coq does not have quotient types and true subset types (due to the lack of baked-in proof irrelevance with support for unification), we employ a convention of define a type, then a validity predicate on that type, and then an equivalence relation on that type if appropriate. We only use elements of a type that are valid.
A-B. Metatheoretic Assumptions
The proof only makes one metatheoretic assumption, countable choice, in two places: the proof that all PCAs model countable choice, and the proof that Mem-SCA models countable choice.
Categories
B-A. Common.v
We use Set to ensure that a type belongs to the universe of sets rather than some larger universe. We cannot use the standard Set universe because we need Set to contain Prop to model impredicativity.
Definition Set : Type := Type. Inductive ∅ : Set :=.
B-B. Categories.v
1. Definition of a Category
This definition is standard. We include here only the structural components so that the reader may be introduced the notation.
Module Type Category.
Parameter O : Type. Parameter JO : O → Prop.
Parameter ~ : O → O → Type.
Parameter J~ : ∀ {o1 o2 : O}, ~ o1 o2 → Prop.
Parameter ≈~ : ∀ {o1 o2 : O}, ~ o1 o2 → ~ o1 o2 → Prop.
End Category.
B-C. Cartesian.v
1. Definition of a Cartesian Category
This definition is standard. We include here only the structural components so that the reader may be introduced the notation.
Module Type CartesianCategory.
Include Category.
Parameter 1 : O.
Parameter ! : ∀ o : O, ~ o 1.
Parameter × : O → O → O.
Parameter (·, ·⟩ : ∀ {o o1 o2 : O}, ~ o o1 → ~ o o2 → ~ o (× o1 o2 ).
Parameter π1 : ∀ o1 o2 : O, ~ (× o1 o2 ) o1 .
Parameter π2 : ∀ o1 o2 : O, ~ (× o1 o2 ) o2 .
End CartesianCategory.
B-C2. Definition of a Cartesian-Closed Category
This definition is standard. We include here only the structural components so that the reader may be introduced the notation.
Module Type CartesianClosedCategory.
Include CartesianCategory.
Parameter ⇒ : O → O → O.
Parameter Λ : ∀ {o o1 o2 : O}, ~ (× o o1 ) o2 → ~ o (⇒ o1 o2 ).
Parameter eval : ∀ o1 o2 : O, ~ (× (⇒ o1 o2 ) o1 ) o2 .
End CartesianClosedCategory.
B-C3. Definition of a Nautral-Number Object
This definition is standard. We include here only the structural components so that the reader may be introduced the notation.
Module Type NaturalNumberObject (CC : CartesianCategory ).
Parameter N : O.
Parameter Z : ~ 1 N.


Parameter S : ~ N N.
Parameter recN : ∀ {o : O}, ~ 1 o → ~ o o → ~ N o.
End NaturalNumberObject.
B-D. Sets.v
B-D1. Definition of the Category of Inhabited Sets
Module InhabitedSets <: CartesianClosedCategory.
Record O : Type := { set : Set; Jset : set → Prop; ≈set : set → set → Prop }.
Objects are required to be inhabited sets (but not pointed sets), as indicated by sinh.
Record JO (o : O) : Prop
:= { sinh : ∃ s : set o, Jset o s 
; srefl : ∀ s : set o, Jset o s → ≈set o s s
; ssym : ∀ s s’ : set o, Jset o s → Jset o s’ → ≈set o s s’ → ≈set o s’ s
; strans : ∀ s s’ s’’ : set o, Jset o s → Jset o s’ → Jset o s’’ → ≈set o s s’ → ≈set o s’ s’’ → ≈set o s s’’ }.
Definition ~ (o1 o2 : O) : Type := set o1 → set o2 .
Note that morphisms are not required to preserve the required inhabitant, making this the category of inhabited sets rather than pointed sets.
Record J~ (o1 o2 : O) (m : ~ o1 o2 ) : Prop
:= { mpresv : ∀ s1 : set o1 , Jset o1 s1 → Jset o2 (m s1 )
; mprese : ∀ s1 s1’ : set o1 , Jset o1 s1 → Jset o1 s1’ → ≈set o1 s1 s1’ → ≈set o2 (m s1 ) (m s1’ ) }.
Definition ≈~ {o1 o2 : O} (m1 m2 : ~ o1 o2 ) : Prop := ∀ s1 s1’ : set o1 , Jset o1 s1 → Jset o1 s1’ → ≈set o1 s1 s1’ →
≈set o2 (m1 s1 ) (m2 s1’ ).
We omit the remainder of this module as it simply demonstrates that inhabited sets form a cartesian-closed category, which is not novel. Note, though, that the ability to customize the validity predicate and equivalence relation are necessary for this construction.
End InhabitedSets.
Module InhabitedSetsNat <: NaturalNumberObject InhabitedSets.
We omit the contents of this module as they simply demonstrate that inhabited sets have the obvious natural-number object.
End InhabitedSetsNat.
Combinatory Algebras
C-A. Expressions.v
1. Definition of Applicative Expressions
Module ApplicativeExpression.
Fixpoint V (C : Set) (n : N) : Type := match n with 0 '→ C | S n '→ option (V C n ) end.
Fixpoint vcode {C : Type} (c : C) (n : N) : V C n := match n with 0 '→ c | S n '→ Some (vcode c n ) end.
Inductive E? {C : Set} {n : N} : Type := evar (c : V C n ) | · (ef ea : E?).
Definition Expr (C : Set) : Type := E? C 0.
Fixpoint JV {C : Set} (JC : C → Prop) {n : N} : V C n → Prop
:= match n with 0 '→ JC | S n '→ λ v '→ match v with None '→ True | Some v '→ JV JC v end end. Inductive JE {C : Set} (JC : C → Prop) {n : N} : E? C n → Prop
:= evarv (c : V C n ) : JV JC c → JE JC (evar n c)
| eappv (ef ea : E? C n ) : JE JC ef → JE JC ea → JE JC (· ef ea ).
Fixpoint e˙[·] {C : Set} (c : C) {n : N} (e : E? C (S n)) : E? C n
:= match e with evar  v '→ evar n (match v with None '→ vcode c n | Some v '→ v end) | · ef ea '→ · (e˙[·] c ef ) (e˙[·] c
ea ) end.
Lemma esubstv (C : Set) (JC : C → Prop) (c : C) (n : N) (e : E? C (S n)) : JC c → JE JC e → JE JC (e˙[·] c e).
Definition (·) {C : Set} (c : C) {n : N} : E? C n := evar n (vcode c n ).
Lemma ecodev (C : Set) (JC : C → Prop) (c : C) (n : N) : JC c → JE JC (n := n ) ((·) c).
End ApplicativeExpression.
C-B. RCAs.v
1. Definition of a Relational Applicative Structure
This is the formal statement of Definition 4.1.
Module Type RelationalApplicativeStructure.
Parameter C : Set.
Parameter JC : C → Prop.
Parameter ↓c : C → C → C → Prop. Parameter ↓ : C → C → Prop.
Parameter preservation : ∀ cf ca cr : C, JC cf → JC ca → ↓c cf ca cr → JC cr .
Parameter progress : ∀ cf ca : C, JC cf → JC ca → ↓ cf ca → ∃ cr : C, ↓c cf ca cr .
End RelationalApplicativeStructure.
C-B2. Definition of Relational Reduction and Termination of Applicative Expressions
Module RelationalApplicativeExpression.
Inductive ↓E {C : Set} (↓c : C → C → C → Prop) : E0 C → C → Prop
:= revar (c : C) : ↓E ↓c (evar 0 c) c
| reapp (ef ea : E0 C) (cf ca cr : C) : ↓E ↓c ef cf → ↓E ↓c ea ca → ↓c cf ca cr → ↓E ↓c (· ef ea ) cr .
c	c	c


Inductive ↓E {C : Set} (↓c : C → C → C → Prop) (↓ : C → C → Prop) : E0 C → Prop
:= tevar (c : C) : ↓E ↓c ↓ (evar 0 c)
| teapp (ef ea : E0 C) : ↓E ↓c ↓ ef → (∀ cf : C, ↓E ↓c ef cf → ↓E ↓c ↓ ea ∧ (∀ ca : C, ↓E ↓c ea ca → ↓ cf ca ))
c	c
→ ↓E ↓c ↓ (· ef ea ).
Definition ↓φ {C : Set} (↓c : C → C → C → Prop) (↓ : C → C → Prop) (cf ca : C) (φr : C → Prop) : Prop
:= ↓ cf ca ∧ (∀ cr : C, ↓c cf ca cr → φr cr ).
Lemma termred forall {C I : Set} (↓c : C → C → C → Prop) (↓ : C → C → Prop) (JI : I → Prop) (cf ca : C) (φr : I
→ C → Prop) : (∃ i : I, JI i ) → (∀ i : I, JI i → ↓φ ↓c ↓ cf ca (φr i )) → ↓φ ↓c ↓ cf ca (λ cr '→ ∀ i : I, JI i → φr i cr ).
Fixpoint ↓E {C : Set} (↓c : C → C → C → Prop) (↓ : C → C → Prop) (e : E0 C) (φr : C → Prop) : Prop
:= match e with evar  c '→ φr c | · ef ea '→ ↓E ↓c ↓ ef (λ cf '→ ↓E ↓c ↓ ea (λ ca '→ ↓φ ↓c ↓ cf ca φr )) end.
φ	φ
Lemma termredexpr {C : Set} (↓c : C → C → C → Prop) (↓ : C → C → Prop) (e : E0 C) (φr : C → Prop) : ↓E ↓c ↓
e φr → ↓E ↓c ↓ e ∧ (∀ cr : C, ↓E ↓c e cr → φr cr ).
End RelationalApplicativeExpression.
3. Definition of a Relational Combinatory Algebra
This is the formal statement of Definition 4.2.
Module Type RelationalCombinatoryAlgebra.
Include RelationalApplicativeStructure.
Parameter cλ : ∀ n : N, E? C (S n) → C.
Parameter cencodev : ∀ n : N, ∀ e : E? C (S n), JE JC e → JC (cλ n e).
Parameter red encode S : ∀ n : N, ∀ e : E? C (S (S n)), ∀ ca cr : C, JE JC e → JC ca → ↓c (cλ (S n) e) ca cr → cλ n
(e˙[·] ca e) = cr .
Parameter red encode 0 : ∀ e : E? C 1, ∀ ca cr : C, JE JC e → JC ca → ↓c (cλ 0 e) ca cr → ↓E ↓c (e˙[·] ca e) cr .
Parameter term encode S : ∀ n : N, ∀ e : E? C (S (S n)), ∀ ca : C, JE JC e → JC ca → ↓ (cλ (S n) e) ca .
Parameter term encode 0 : ∀ e : E? C 1, ∀ ca : C, JE JC e → JC ca → ↓E ↓c ↓ (e˙[·] ca e) → ↓ (cλ 0 e) ca .
End RelationalCombinatoryAlgebra.
C-C. PCAs.v
1. Definition of a Partial Combinatory Algebra
This is the formal statement of Definition 3.2
Module Type PartialCombinatoryAlgebra.
Include RelationalCombinatoryAlgebra.
Parameter red deterministic : ∀ cf ca cr c' : C, JC cf → JC ca → ↓c cf ca cr → ↓c cf ca c' → cr = c' .
r	r	r
Parameter red term : ∀ cf ca cr : C, JC cf → JC ca → JC cr → ↓c cf ca cr → ↓ cf ca .
End PartialCombinatoryAlgebra.
C-D. SCAs.v
1. Definition of a Stateful Applicative Structure
This is the formal statement of Definition 5.1. One difference, though, is that in this definition we allow code-validity to depend on the current state so long as code-validity is future-stable. Although our proofs do not rely on this additional degree of flexibility, it can be convenient for keeping the model clean, say by guaranteeing that any references a valid code has to the state necessarily refer to allocated locations.
Module Type StatefulApplicativeStructure.
Parameter Σ : Set.
Parameter JΣ : Σ → Prop. Parameter sinhabited : ∃ σ : Σ, JΣ σ.
Parameter ≤ : Σ → Σ → Prop. Parameter frefl : ∀ σ : Σ, JΣ σ → ≤ σ σ.
Parameter ftrans : ∀ σ σ' σ'' : Σ, JΣ σ → JΣ σ' → JΣ σ'' → ≤ σ σ' → ≤ σ' σ'' → ≤ σ σ'' .
Parameter C : Set.
Parameter JC : Σ → C → Prop.
Parameter codev fut : ∀ σ σ' : Σ, ∀ c : C, JΣ σ → JΣ σ' → ≤ σ σ' → JC σ c → JC σ' c.
Parameter ↓c : Σ → C → C → Σ → C → Prop. Parameter ↓ : Σ → C → C → Prop.
Parameter preservation : ∀ σ : Σ, ∀ cf ca : C, ∀ σ' : Σ, ∀ cr : C, JΣ σ → JC σ cf → JC σ ca → ↓c σ cf ca σ' cr →
JΣ σ' ∧ ≤ σ σ' ∧ JC σ' cr .
Parameter progress : ∀ σ : Σ, ∀ cf ca : C, JΣ σ → JC σ cf → JC σ ca → ↓ σ cf ca → ∃ σ' : Σ, ∃ cr : C, ↓c σ cf ca
σ' cr .
End StatefulApplicativeStructure.
C-D2. Definition of Stateful Reduction and Termination of Applicative Expressions
Module StatefulApplicativeExpression.
Inductive ↓E {Σ C : Set} (↓c : Σ → C → C → Σ → C → Prop) : Σ → E0 C → Σ → C → Prop
:= revar (σ : Σ) (c : C) : ↓E ↓c σ (evar 0 c) σ c
| reapp (σ : Σ) (ef ea : E0 C) (σ' : Σ) (cf : C) (σ'' : Σ) (ca : C) (s’’’ : Σ) (cr : C) : ↓E ↓c σ ef σ' cf → ↓E ↓c σ'
c	c
ea σ'' ca → ↓c σ'' cf ca s’’’ cr → ↓E ↓c σ (· ef ea ) s’’’ cr .
Inductive ↓E {Σ C : Set} (↓c : Σ → C → C → Σ → C → Prop) (↓ : Σ → C → C → Prop) : Σ → E0 C → Prop
:= tevar (σ : Σ) (c : C) : ↓E ↓c ↓ σ (evar 0 c)
| teapp (σ : Σ) (ef ea : E0 C) : ↓E ↓c ↓ σ ef → (∀ σ' : Σ, ∀ cf : C, ↓E ↓c σ ef σ' cf → ↓E ↓c ↓ σ' ea ∧ (∀ σ'' :
Σ, ∀ ca : C, ↓E ↓c σ' ea σ'' ca → ↓ σ'' cf ca )) → ↓E ↓c ↓ σ (· ef ea ).
Definition ↓φ {Σ C : Set} (↓c : Σ → C → C → Σ → C → Prop) (↓ : Σ → C → C → Prop) (σ : Σ) (cf ca : C) (φr : Σ → C → Prop) : Prop


:= ↓ σ cf ca ∧ (∀ σ' : Σ, ∀ cr : C, ↓c σ cf ca σ' cr → φr σ' cr ).
Lemma termred forall {Σ C I : Set} (↓c : Σ → C → C → Σ → C → Prop) (↓ : Σ → C → C → Prop) (JI : I → Prop) (σ : Σ) (cf ca : C) (φr : I → Σ → C → Prop) : (∃ i : I, JI i ) → (∀ i : I, JI i → ↓φ ↓c ↓ σ cf ca (φr i )) → ↓φ ↓c ↓ σ cf ca (λ σ' cr '→ ∀ i : I, JI i → φr i σ' cr ).
Fixpoint ↓E {Σ C : Set} (↓c : Σ → C → C → Σ → C → Prop) (↓ : Σ → C → C → Prop) (σ : Σ) (e : E0 C) (φr : Σ 
→ C → Prop) : Prop
:= match e with evar  c '→ φr σ c | · ef ea '→ ↓E ↓c ↓ σ ef (λ σ' cf '→ ↓E ↓c ↓ σ' ea (λ σ'' ca '→ ↓φ ↓c ↓ σ'' cf ca
φ	φ
φr )) end.
Lemma termredexpr {Σ C : Set} (↓c : Σ → C → C → Σ → C → Prop) (↓ : Σ → C → C → Prop) (σ : Σ) (e : E0 C)
(φr : Σ → C → Prop) : ↓E ↓c ↓ σ e φr → ↓E ↓c ↓ σ e ∧ (∀ σ' : Σ, ∀ cr : C, ↓E ↓c σ e σ' cr → φr σ' cr ).
φ	c
End StatefulApplicativeExpression.
3. Definition of a Stateful Combinatory Algebra
This is the formal statement of Definition 5.2.
Module Type StatefulCombinatoryAlgebra.
Include StatefulApplicativeStructure.
Parameter cλ : ∀ n : N, E? C (S n) → C.
Parameter cencodev : ∀ n : N, ∀ e : E? C (S n), ∀ σ : Σ, JΣ σ → JE (JC σ) e → JC σ (cλ n e).
Parameter red encode S : ∀ σ σ' : Σ, ∀ n : N, ∀ e : E? C (S (S n)), ∀ ca cr : C, JΣ σ → JE (JC σ) e → JC σ ca → ↓c
σ (cλ (S n) e) ca σ' cr → σ' = σ ∧ cλ n (e˙[·] ca e) = cr .
Parameter red encode 0 : ∀ σ σ' : Σ, ∀ e : E? C 1, ∀ ca cr : C, JΣ σ → JE (JC σ) e → JC σ ca → ↓c σ (cλ 0 e) ca σ' cr → ↓E ↓c σ (e˙[·] ca e) σ' cr .
Parameter term encode S : ∀ σ : Σ, ∀ n : N, ∀ e : E? C (S (S n)), ∀ ca : C, JΣ σ → JE (JC σ) e → JC σ ca → ↓ σ (cλ
(S n) e) ca .
Parameter term encode 0 : ∀ σ : Σ, ∀ e : E? C 1, ∀ ca : C, JΣ σ → JE (JC σ) e → JC σ ca → ↓E ↓c ↓ σ (e˙[·] ca e) →
↓ σ (cλ 0 e) ca .
End StatefulCombinatoryAlgebra.
C-E. Lambdas.v
1. Framework for Building Codes with Lambda-Terms and Primitives
Module LambdaTerm.
Defines λ-body expressions L parameterized by a set of codes C, and defines codes C? parameterized by a set of primitives P such that a code is either a primitive or a λ-code of a λ-body expression.
End LambdaTerm.
C-F. FreeRCA.v
1. Framework for Building Relational Combinatory Algebras with Lambda-Terms and Primitives
We elide the construction as it is just tedious and made complex by the fact that there is no direct way to define mutually dependent inductive types or propositions across modules. We only show the module type for specifying the set of primitives and their termination and reduction behavior.
Module FreeRelationalCombinatoryCode.

Defines relational application ↓λ and termination ↓λ
C
for λ-body expressions, and application ↓c  and termination ↓

for codes, each parameterized by application and termination rules for the appropriate unknown sets of codes/primitives.
End FreeRelationalCombinatoryCode.
Module Type PrimitiveApplicativeStructure.
Parameter P : Set.
Parameter JP : P → Prop.
Parameter ↓p : P → C? P → C? P → Prop. Parameter ↓p : P → C? P → Prop.

Parameter preservation prim : ∀ pf : P , ∀ ca : C? P , ∀ cr : C? P , JP pf → JC
JP ca → ↓p pf ca cr → JC
JP cr .

?	c	?
p	p
Parameter progress prim : ∀ pf : P , ∀ ca : C? P , JP pf → JC? JP ca → ↓ pf ca → ∃ cr : C? P , ↓ pf ca cr .
End PrimitiveApplicativeStructure.
Module FreeRelationalCombinatoryAlgebra (PAS : PrimitiveApplicativeStructure) <: RelationalCombinatoryAlgebra.
Include FreeRelationalCombinatoryCode.
Include PAS.
Tediously ties the mutually recursive knot.
End FreeRelationalCombinatoryAlgebra.
C-G. FreeSCA.v
1. Framework for Building Stateful Combinatory Algebras with Lambda-Terms and Primitives
We elide the construction as it is just tedious and made complex by the fact that there is no direct way to define mutually dependent inductive types or propositions across modules. We only show the module type for specifying the set of primitives and their termination and reduction behavior.
Module FreeStatefulCombinatoryCode.
Defines stateful application ↓λ and termination ↓λ for λ-body expressions, and application ↓C? and termination ↓C?
c	c
for codes, each parameterized by application and termination rules for the appropriate unknown sets of codes/primitives
and states.
End FreeStatefulCombinatoryCode.
Module Type PrimitiveApplicativeStructure.



Parameter Σ : Set.
Parameter P : Set.
Parameter JΣ : Σ → Prop. Parameter sinhabited : ∃ σ : Σ, JΣ σ.
Parameter ≤ : Σ → Σ → Prop. Parameter frefl : ∀ σ : Σ, JΣ σ → ≤ σ σ.
Parameter ftrans : ∀ σ σ' σ'' : Σ, JΣ σ → JΣ σ' → JΣ σ'' → ≤ σ σ' → ≤ σ' σ'' → ≤ σ σ'' .
Parameter JP : Σ → P → Prop.
Parameter primv fut : ∀ σ σ' : Σ, ∀ p : P , JΣ σ → JΣ σ' → ≤ σ σ' → JP σ p → JP σ' p.
Parameter ↓p : Σ → P → C? P → Σ → C? P → Prop. Parameter ↓p : Σ → P → C? P → Prop.
Parameter preservation prim : ∀ σ : Σ, ∀ pf : P , ∀ ca : C? P , ∀ σ' : Σ, ∀ cr : C? P , JΣ σ → JP σ pf → JC














(JP σ) ca

→ ↓p σ pf ca σ' cr → JΣ σ' ∧ ≤ σ σ' ∧ JC (JP σ' ) cr .
c	?
p	'
Parameter progress prim : ∀ σ : Σ, ∀ pf : P , ∀ ca : C? P , JΣ σ → JP σ pf → JC? (JP σ) ca → ↓ σ pf ca → ∃ σ : Σ,
∃ cr : C? P , ↓p σ pf ca σ' cr .
End PrimitiveApplicativeStructure.
Module FreeStatefulCombinatoryAlgebra (PAS : PrimitiveApplicativeStructure) <: StatefulCombinatoryAlgebra.
Include FreeStatefulCombinatoryCode.
Include PAS.
Tediously ties the mutually recursive knot.
End FreeStatefulCombinatoryAlgebra.
Higher-Order Fibrations
D-A. HOFs.v
D-A1. Definition of a Higher-Order Fibration
Module Type HigherOrderFibration (CCC : CartesianClosedCategory).
Propositions
Parameter Φ : O → Type.
Parameter JΦ : ∀ {o : O}, Φ o → Prop.
Entailment
Parameter ▶ : ∀ {o : O}, Φ o → Φ o → Prop.
Parameter refl : ∀ o : O, ∀ φ : Φ o, JO o → JΦ φ → ▶ φ φ.
Parameter trans : ∀ o : O, ∀ φ1 φ2 φ3 : Φ o, JO o → JΦ φ1 → JΦ φ2 → JΦ φ3 → ▶ φ1 φ2 → ▶ φ2 φ3 → ▶ φ1 φ3 .
Substition
Parameter φ˙[·] : ∀ {o1 o2 : O}, ∀ m : ~ o1 o2 , Φ o2 → Φ o1 .
Parameter substv : ∀ o1 o2 : O, ∀ m : ~ o1 o2 , ∀ φ2 : Φ o2 , JO o1 → JO o2 → J~ m → JΦ φ2 → JΦ (φ˙[·] m φ2 ).
Parameter substi : ∀ o1 o2 : O, ∀ m : ~ o1 o2 , ∀ φ2 φ' : Φ o2 , JO o1 → JO o2 → J~ m → JΦ φ2 → JΦ φ' → ▶ φ2 φ'
2	2	2
→ ▶ (φ˙[·] m φ2 ) (φ˙[·] m φ' ).
Parameter subste : ∀ o1 o2 : O, ∀ m1 m2 : ~ o1 o2 , ∀ φ2 : Φ o2 , JO o1 → JO o2 → J~ m1 → J~ m2 → JΦ φ2 → ≈~
m1 m2 → ▶ (φ˙[·] m1 φ2 ) (φ˙[·] m2 φ2 ) ∧ ▶ (φ˙[·] m2 φ2 ) (φ˙[·] m1 φ2 ).
Parameter substid : ∀ o : O, ∀ φ : Φ o, JO o → JΦ φ → ▶ φ (φ˙[·] (id o) φ) ∧ ▶ (φ˙[·] (id o) φ) φ.
Parameter substcomp : ∀ o1 o2 o3 : O, ∀ m12 : ~ o1 o2 , ∀ m23 : ~ o2 o3 , ∀ φ3 : Φ o3 , JO o1 → JO o2 → JO o3 → J~ m12 → J~ m23 → JΦ φ3 → ▶ (φ˙[·] m12 (φ˙[·] m23 φ3 )) (φ˙[·] (; m12 m23 ) φ3 ) ∧ ▶ (φ˙[·] (; m12 m23 ) φ3 ) (φ˙[·] m12 (φ˙[·] m23 φ3 )).
True
Parameter T : ∀ o : O, Φ o.
Parameter topv : ∀ o : O, JO o → JΦ (T o).
Parameter topi : ∀ o : O, ∀ φ : Φ o, JO o → JΦ φ → ▶ φ (T o).
Parameter tops : ∀ o1 o2 : O, ∀ m : ~ o1 o2 , JO o1 → JO o2 → J~ m → ▶ (T o1 ) (φ˙[·] m (T o2 )).
Conjunction
Parameter ∧ : ∀ {o : O}, Φ o → Φ o → Φ o.
Parameter conjv : ∀ o : O, ∀ φ1 φ2 : Φ o, JO o → JΦ φ1 → JΦ φ2 → JΦ (∧ φ1 φ2 ).
Parameter conji : ∀ o : O, ∀ φ φ1 φ2 : Φ o, JO o → JΦ φ → JΦ φ1 → JΦ φ2 → ▶ φ φ1 → ▶ φ φ2 → ▶ φ (∧ φ1 φ2 ).
Parameter conje1 : ∀ o : O, ∀ φ1 φ2 : Φ o, JO o → JΦ φ1 → JΦ φ2 → ▶ (∧ φ1 φ2 ) φ1 .
Parameter conje2 : ∀ o : O, ∀ φ1 φ2 : Φ o, JO o → JΦ φ1 → JΦ φ2 → ▶ (∧ φ1 φ2 ) φ2 .
Parameter conjs : ∀ o1 o2 : O, ∀ m : ~ o1 o2 , ∀ φ1 φ2 : Φ o2 , JO o1 → JO o2 → J~ m → JΦ φ1 → JΦ φ2 → ▶ (∧ (φ˙[·]
m φ1 ) (φ˙[·] m φ2 )) (φ˙[·] m (∧ φ1 φ2 )).
False
Parameter ⊥ : ∀ o : O, Φ o.
Parameter botv : ∀ o : O, JO o → JΦ (⊥ o).
Parameter bote : ∀ o : O, ∀ φ : Φ o, JO o → JΦ φ → ▶ (⊥ o) φ.
Parameter bots : ∀ o1 o2 : O, ∀ m : ~ o1 o2 , JO o1 → JO o2 → J~ m → ▶ (φ˙[·] m (⊥ o2 )) (⊥ o1 ).
Disjunction
Parameter ∨ : ∀ {o : O}, Φ o → Φ o → Φ o.
Parameter disjv : ∀ o : O, ∀ φ1 φ2 : Φ o, JO o → JΦ φ1 → JΦ φ2 → JΦ (∨ φ1 φ2 ). Parameter disji1 : ∀ o : O, ∀ φ1 φ2 : Φ o, JO o → JΦ φ1 → JΦ φ2 → ▶ φ1 (∨ φ1 φ2 ). Parameter disji2 : ∀ o : O, ∀ φ1 φ2 : Φ o, JO o → JΦ φ1 → JΦ φ2 → ▶ φ2 (∨ φ1 φ2 ).
Parameter disje : ∀ o : O, ∀ φ1 φ2 φ : Φ o, JO o → JΦ φ1 → JΦ φ2 → JΦ φ → ▶ φ1 φ → ▶ φ2 φ → ▶ (∨ φ1 φ2 ) φ.
Parameter disjs : ∀ o1 o2 : O, ∀ m : ~ o1 o2 , ∀ φ1 φ2 : Φ o2 , JO o1 → JO o2 → J~ m → JΦ φ1 → JΦ φ2 → ▶ (φ˙[·] m
(∨ φ1 φ2 )) (∨ (φ˙[·] m φ1 ) (φ˙[·] m φ2 )).


Implication
Parameter ⊃ : ∀ {o : O}, Φ o → Φ o → Φ o.
Parameter impv : ∀ o : O, ∀ φ1 φ2 : Φ o, JO o → JΦ φ1 → JΦ φ2 → JΦ (⊃ φ1 φ2 ).
Parameter impi : ∀ o : O, ∀ φ φ1 φ2 : Φ o, JO o → JΦ φ → JΦ φ1 → JΦ φ2 → ▶ (∧ φ φ1 ) φ2 → ▶ φ (⊃ φ1 φ2 ).
Parameter impe : ∀ o : O, ∀ φ1 φ2 : Φ o, JO o → JΦ φ1 → JΦ φ2 → ▶ (∧ (⊃ φ1 φ2 ) φ1 ) φ2 .
Parameter imps : ∀ o1 o2 : O, ∀ m : ~ o1 o2 , ∀ φ1 φ2 : Φ o2 , JO o1 → JO o2 → J~ m → JΦ φ1 → JΦ φ2 → ▶ (⊃ (φ˙[·]
m φ1 ) (φ˙[·] m φ2 )) (φ˙[·] m (⊃ φ1 φ2 )).
Universal Quantification
Parameter ∀ : ∀ {o1 : O}, ∀ o2 : O, Φ (× o1 o2 ) → Φ o1 .
Parameter sforallv : ∀ o1 o2 : O, ∀ φ12 : Φ (× o1 o2 ), JO o1 → JO o2 → JΦ φ12 → JΦ (∀ o2 φ12 ).
Parameter sforalli : ∀ o1 o2 : O, ∀ φ1 : Φ o1 , ∀ φ12 : Φ (× o1 o2 ), JO o1 → JO o2 → JΦ φ1 → JΦ φ12 → ▶ (φ˙[·] (π1 o1 o2 ) φ1 ) φ12 → ▶ φ1 (∀ o2 φ12 ).
Parameter sforalle : ∀ o1 o2 : O, ∀ φ1 : Φ o1 , ∀ φ12 : Φ (× o1 o2 ), JO o1 → JO o2 → JΦ φ1 → JΦ φ12 → ▶ φ1 (∀ o2
φ12 ) → ▶ (φ˙[·] (π1 o1 o2 ) φ1 ) φ12 .
Parameter sforalls : ∀ o1 o' o2 : O, ∀ m : ~ o1 o' , ∀ φ' : Φ (× o' o2 ), JO o1 → JO o' → JO o2 → J~ m → JΦ φ'
1	1	12	1	1	12
→ ▶ (∀ o2 (φ˙[·] ((·, ·⟩ (; (π1 o1 o2 ) m ) (π2 o1 o2 )) φ' )) (φ˙[·] m (∀ o2 φ' )).

Existential Quantification
12	12

Parameter ∃ : ∀ {o1 : O}, ∀ o2 : O, Φ (× o1 o2 ) → Φ o1 .
Parameter sexistsv : ∀ o1 o2 : O, ∀ φ12 : Φ (× o1 o2 ), JO o1 → JO o2 → JΦ φ12 → JΦ (∃ o2 φ12 ).
Parameter sexistsi : ∀ o1 o2 : O, ∀ φ12 : Φ (× o1 o2 ), ∀ φ1 : Φ o1 , JO o1 → JO o2 → JΦ φ12 → JΦ φ1 → ▶ φ12 (φ˙[·] (π1 o1 o2 ) φ1 ) → ▶ (∃ o2 φ12 ) φ1 .
Parameter sexistse : ∀ o1 o2 : O, ∀ φ12 : Φ (× o1 o2 ), ∀ φ1 : Φ o1 , JO o1 → JO o2 → JΦ φ12 → JΦ φ1 → ▶ (∃ o2 φ12 )
φ1 → ▶ φ12 (φ˙[·] (π1 o1 o2 ) φ1 ).
Parameter sexistss : ∀ o1 o' o2 : O, ∀ m : ~ o1 o' , ∀ φ' : Φ (× o' o2 ), JO o1 → JO o' → JO o2 → J~ m → JΦ φ'
1	1	12	1	1	12
→ ▶ (φ˙[·] m (∃ o2 φ' )) (∃ o2 (φ˙[·] ((·, ·⟩ (; (π1 o1 o2 ) m ) (π2 o1 o2 )) φ' )).
12	12
Equality
Parameter = : ∀ {o1 : O}, ∀ o2 : O, Φ (× o1 o2 ) → Φ (× o1 (× o2 o2 )).
Parameter seqv : ∀ o1 o2 : O, ∀ φ12 : Φ (× o1 o2 ), JO o1 → JO o2 → JΦ φ12 → JΦ (= o2 φ12 ).
Parameter seqi : ∀ o1 o2 : O, ∀ φ12 : Φ (× o1 o2 ), ∀ φ122 : Φ (× o1 (× o2 o2 )), JO o1 → JO o2 → JΦ φ12 → JΦ φ122
→ ▶ φ12 (φ˙[·] ((·, ·⟩ (π1 o1 o2 ) ((·, ·⟩ (π2 o1 o2 ) (π2 o1 o2 ))) φ122 ) → ▶ (= o2 φ12 ) φ122 .
Parameter seqe : ∀ o1 o2 : O, ∀ φ12 : Φ (× o1 o2 ), ∀ φ122 : Φ (× o1 (× o2 o2 )), JO o1 → JO o2 → JΦ φ12 → JΦ φ122
→ ▶ (= o2 φ12 ) φ122 → ▶ φ12 (φ˙[·] ((·, ·⟩ (π1 o1 o2 ) ((·, ·⟩ (π2 o1 o2 ) (π2 o1 o2 ))) φ122 ).
Parameter seqs : ∀ o1 o' o2 : O, ∀ m : ~ o1 o' , ∀ φ' : Φ (× o' o2 ), JO o1 → JO o' → JO o2 → J~ m → JΦ φ' → ▶ 
1	1	12	1	1	12
(φ˙[·] ((·, ·⟩ (; (π1 o1 (× o2 o2 )) m ) (π2 o1 (× o2 o2 ))) (= o2 φ' )) (= o2 (φ˙[·] ((·, ·⟩ (; (π1 o1 o2 ) m ) (π2 o1 o2 )) φ' )).
12	12
Impredicativity
Parameter Ω : O.
Parameter holds : Φ Ω.
Parameter χ : ∀ {o : O}, Φ o → ~ o Ω.
Parameter opropv : JO Ω.
Parameter holdsv : JΦ holds.
Parameter characterv : ∀ o : O, ∀ φ : Φ o, JO o → JΦ φ → J~ (χ φ).
Parameter holdsi : ∀ o : O, ∀ φ : Φ o, JO o → JΦ φ → ▶ φ (φ˙[·] (χ φ) holds).
Parameter holdse : ∀ o : O, ∀ φ : Φ o, JO o → JΦ φ → ▶ (φ˙[·] (χ φ) holds) φ.
End HigherOrderFibration.
When a higher-order fibration is defined over a category with a natural-number object N, it automatically has an 𝕟 predicate over N. However, the automatic construction of 𝕟 tends to be complicated, so here we allow one to specify an optimized, necessarily equivalent, construction.
Module Type NatHigherOrderFibration (CCC : CartesianClosedCategory) (NNO : NaturalNumberObject CCC ).
Include HigherOrderFibration CCC.
Parameter 𝕟 : Φ N.
Parameter isnatv : JΦ 𝕟.
Parameter isnatiz : ▶ (T 1) (φ˙[·] Z 𝕟).
Parameter isnatis : ▶ 𝕟 (φ˙[·] S 𝕟).
Parameter isnate : ∀ φ : Φ N, JΦ φ → ▶ (T 1) (φ˙[·] Z φ) → ▶ φ (φ˙[·] S φ) → ▶ 𝕟 φ.
End NatHigherOrderFibration.
D-B. RCAstoHOFs.v
D-B1. Proof that a Relational Combinatory Algebra forms a Higher-Order Fibration
This module demonstrates that every relational (and partial) combinatory algebra forms a consistent higher-order fibration over the inhabited sets, as claimed in Section 4.2 (and Section 3.2). We only show the definitions of the constructions and the realizers of the various entailments and omit the lemmas required by NatHigherOrderFibration, the proofs of which are straightforward from the definitions.
Module RCAtoHOF (RCA : RelationalCombinatoryAlgebra ) <: NatHigherOrderFibration InhabitedSets InhabitedSetsNat.
Definition Φ (o : O) : Type := set o → C → Prop.
Definition JΦ {o : O} (φ : Φ o) : Prop := ∀ x x’ : set o, ∀ c : C, Jset o x → Jset o x’ → ≈set o x x’ → JC c → φ x c → φ
x’ c.
Definition ▶ {o : O} (φ1 φ2 : Φ o) : Prop := ∃ c : C, JC c ∧ ∀ x : set o, ∀ c1 : C, Jset o x → JC c1 → φ1 x c1 → ↓φ
↓c ↓ c c1 (φ2 x ).
Definition ⊆Φ {o : O} (φ1 φ2 : Φ o) : Prop := ∀ x : set o, ∀ c : C, Jset o x → JC c → φ1 x c → φ2 x c.
Definition caxiom : C := cλ 0 (evar 1 None).
Definition ccut (c1 c2 : C) : C := cλ 0 (· ((·) c2 ) (· ((·) c1 ) (evar 1 None))).
Definition φ˙[·] {o1 o2 : O} (m : ~ o1 o2 ) (φ2 : Φ o2 ) : Φ o1 := λ s1 '→ φ2 (m s1 ).
Definition T (o : O) : Φ o := λ x c '→ True.


Definition c2sel1 : C := cλ 1 (evar 2 None).
Definition c2sel2 : C := cλ 1 (evar 2 (Some None)).
Definition ∧ {o : O} (φ1 φ2 : Φ o) : Φ o := λ x c '→ ↓φ ↓c ↓ c c2sel1 (φ1 x ) ∧ ↓φ ↓c ↓ c c2sel2 (φ2 x ).
Definition cconji (e1 e2 : C): C := cλ 1 (· (· (evar 2 (Some None)) (· ((·) e1 ) (evar 2 None))) (· ((·) e2 ) (evar 2 None))).
Definition cconje1 : C := cλ 0 (· (evar 1 None) ((·) c2sel1 )).
Definition cconje2 : C := cλ 0 (· (evar 1 None) ((·) c2sel2 )).
Definition ⊥ (o : O) : Φ o := λ x c '→ False.
Definition ∨ {o : O} (φ1 φ2 : Φ o) : Φ o := λ x c '→ (∃ c1 : C, JC c1 ∧ φ1 x c1 ∧ cλ 1 (· (evar 2 None) ((·) c1 )) = c)
∨ (∃ c2 : C, JC c2 ∧ φ2 x c2 ∧ cλ 1 (· (evar 2 (Some None)) ((·) c2 )) = c).
Definition cdisji1 : C := cλ 2 (· (evar 3 (Some None)) (evar 3 None)). Definition cdisji2 : C := cλ 2 (· (evar 3 (Some (Some None))) (evar 3 None)). Definition cdisje (e1 e2 : C) : C := cλ 0 (· (· (evar 1 None) ((·) e1 )) ((·) e2 )).
Definition ⊃ {o : O} (φ1 φ2 : Φ o) : Φ o := λ x c '→ ∀ c1 : C, JC c1 → φ1 x c1 → ↓φ ↓c ↓ c c1 (φ2 x ). Definition ctuple2 : C := cλ 2 (· (· (evar 3 (Some (Some None))) (evar 3 None)) (evar 3 (Some None))). Definition cimpi (e : C) : C := cλ 1 (· ((·) e) (· (· ((·) ctuple2 ) (evar 2 None)) (evar 2 (Some None)))). Definition cimpe : C := cλ 0 (· (· (evar 1 None) ((·) c2sel1 )) (· (evar 1 None) ((·) c2sel2 ))).
Definition ∀ {o1 : O} (o2 : O) (φ12 : Φ (× o1 o2 )) : Φ o1 := λ x1 c '→ ∀ x2 : set o2 , Jset o2 x2 → φ12 (pair x1 x2 ) c. Definition ∃ {o1 : O} (o2 : O) (φ12 : Φ (× o1 o2 )) : Φ o1 := λ x1 c '→ ∃ x2 : set o2 , Jset o2 x2 ∧ φ12 (pair x1 x2 ) c. Definition = {o1 : O} (o2 : O) (φ12 : Φ (× o1 o2 )) : Φ (× o1 (× o2 o2 ))
:= λ x122 c '→ ≈set o2 (fst (snd x122 )) (snd (snd x122 )) ∧ φ12 (pair (fst x122 ) (fst (snd x122 ))) c.
Definition Ω : O := {| set := C → Prop; Jset := λ φ '→ ∀ c : C, JC c → φ c → φ c; ≈set := λ φ p’ '→ ∀ c : C, JC c → φ
c ↔ p’ c |}.
Definition holds : Φ Ω := λ φ '→ φ.
Definition χ {o : O} (φ : Φ o) : ~ o Ω := φ.
Fixpoint cλ (n : N) : C
:= match n with 0 '→ cλ 1 (evar 2 (Some None)) | S n '→ cλ 1 (· (evar 2 None) (· (· ((·) (cλ n )) (evar 2 None)) (evar 2
(Some None)))) end.
Definition 𝕟 : Φ N := λ n '→ eq (cλ n ).
Definition cnatiz : C := cλ 0 ((·) (cλ 0)).
Definition cnatis : C := cλ 2 (· (evar 3 (Some None)) (· (· (evar 3 None) (evar 3 (Some None))) (evar 3 (Some (Some None))))).
Definition cnate (cz cs : C) : C := cλ 0 (· (· ((·) (cλ 1 (· (· (evar 2 None) ((·) cs)) (evar 2 (Some None))))) (evar 1
None)) (· ((·) cz ) ((·) caxiom ))).
Inductive Realizable (φ : Φ 1) : Prop := realizable (c : C) : JC c → φ tt c → Realizable φ.
Theorem entails realizable (φ1 φ2 : Φ 1) : JΦ φ1 → JΦ φ2 → ▶ φ1 φ2 → Realizable φ1 → Realizable φ2 .
Theorem consistent : ▶ (T 1) (⊥ 1) → False. End RCAtoHOF.
D-C. SCAstoHOFs.v
D-C1. Proof that a Stateful Combinatory Algebra forms a Higher-Order Fibration
This module demonstrates that every stateful combinatory algebra forms a consistent higher-order fibration over the in- habited sets, as claimed in Theorem 5.3. It is the formal statement of Figure 2. We only show the definitions of the constructions and omit the lemmas required by NatHigherOrderFibration, the proofs of which are straightforward from the definitions (and the realizers of entailment for which are the same as for RCAs).
Module SCAtoHOF (SCA : StatefulCombinatoryAlgebra ) <: NatHigherOrderFibration InhabitedSets InhabitedSetsNat.
Definition Φ (o : O) : Type := set o → Σ → C → Prop. Record JΦ {o : O} (φˆ : Φ o) : Prop
:=
{ propv : ∀ x : set o, ∀ s s’ : Σ, ∀ c : C, Jset o x → JΣ s → JΣ s’ → ≤ s s’ → JC s c → φˆ x s c → φˆ x s’ c
; prope : ∀ x x’ : set o, ∀ s : Σ, ∀ c : C, Jset o x → Jset o x’ → ≈set o x x’ → JΣ s → JC s c → φˆ x s c → φˆ x’ s c
}.
Definition ▶ {o : O} (φˆ1 φˆ2 : Φ o) : Prop := ∃ c : C, ∀ s : Σ, JΣ s → JC s c ∧ ∀ x : set o, ∀ s : Σ, ∀ c1 : C, Jset o x →
JΣ s → JC s c1 → φˆ1 x s c1 → ↓φ ↓c ↓ s c c1 (φˆ2 x ).
Definition ⊆Φ {o : O} (φˆ1 φˆ2 : Φ o) : Prop := ∀ x : set o, ∀ s : Σ, ∀ c : C, Jset o x → JΣ s → JC s c → φˆ1 x s c → φˆ2
x s c.
Definition φ˙[·] {o1 o2 : O} (m : ~ o1 o2 ) (φˆ2 : Φ o2 ) : Φ o1 := λ s1 '→ φˆ2 (m s1 ).
Definition T (o : O) : Φ o := λ x s c '→ True.
Definition c2sel1 : C := cλ 1 (evar 2 None).
Definition c2sel2 : C := cλ 1 (evar 2 (Some None)).
Definition ∧ {o : O} (φˆ1 φˆ2 : Φ o) : Φ o := λ x s c '→ ∀ s’ : Σ, JΣ s’ → ≤ s s’ → ↓φ ↓c ↓ s’ c c2sel1 (φˆ1 x ) ∧ ↓φ ↓c ↓
s’ c c2sel2 (φˆ2 x ).
Definition ⊥ (o : O) : Φ o := λ x s c '→ False.
Definition ∨ {o : O} (φˆ1 φˆ2 : Φ o) : Φ o := λ x s c '→ (∃ c1 : C, JC s c1 ∧ φˆ1 x s c1 ∧ cλ 1 (· (evar 2 None) ((·) c1 ))
= c) ∨ (∃ c2 : C, JC s c2 ∧ φˆ2 x s c2 ∧ cλ 1 (· (evar 2 (Some None)) ((·) c2 )) = c).
Definition ⊃ {o : O} (φˆ1 φˆ2 : Φ o) : Φ o := λ x s c '→ ∀ s’ : Σ, ∀ c1 : C, JΣ s’ → ≤ s s’ → JC s’ c1 → φˆ1 x s’ c1 →
↓φ ↓c ↓ s’ c c1 (φˆ2 x ).
Definition ∀ {o1 : O} (o2 : O) (φˆ12 : Φ (× o1 o2 )) : Φ o1 := λ x1 s c '→ ∀ x2 : set o2 , Jset o2 x2 → φˆ12 (pair x1 x2 ) s c. Definition ∃ {o1 : O} (o2 : O) (φˆ12 : Φ (× o1 o2 )) : Φ o1 := λ x1 s c '→ ∃ x2 : set o2 , Jset o2 x2 ∧ φˆ12 (pair x1 x2 ) s c. Definition = {o1 : O} (o2 : O) (φˆ12 : Φ (× o1 o2 )) : Φ (× o1 (× o2 o2 ))
:= λ x122 s c '→ ≈set o2 (fst (snd x122 )) (snd (snd x122 )) ∧ φˆ12 (pair (fst x122 ) (fst (snd x122 ))) s c.
Definition Ω : O
:= {| set := Σ → C → Prop
; Jset := λ φˆ '→ ∀ s s’ : Σ, ∀ c : C, JΣ s → JΣ s’ → ≤ s s’ → JC s c → φˆ s c → φˆ s’ c


; ≈set := λ φˆ p’ '→ ∀ s : Σ, ∀ c : C, JΣ s → JC s c → φˆ s c ↔ p’ s c |}.
Definition holds : Φ Ω := λ φˆ '→ φˆ.
Definition χ {o : O} (φˆ : Φ o) : ~ o Ω := φˆ.
Fixpoint cλ (n : N) : C
:= match n with 0 '→ cλ 1 (evar 2 (Some None)) | S n '→ cλ 1 (· (evar 2 None) (· (· ((·) (cλ n )) (evar 2 None)) (evar 2
(Some None)))) end.
Definition 𝕟 : Φ N := λ n  '→ eq (cλ n ).
Inductive Realizable (φˆ : Φ 1) : Prop := realizable (s : Σ) (c : C) : JΣ s → JC s c → φˆ tt s c → Realizable φˆ.
Theorem entails realizable (φˆ1 φˆ2 : Φ 1) : JΦ φˆ1 → JΦ φˆ2 → ▶ φˆ1 φˆ2 → Realizable φˆ1 → Realizable φˆ2 .
Theorem consistent : ▶ (T 1) (⊥ 1) → False. End SCAtoHOF.
Countable Choice
E-A. CountableChoice.v
E-A1. Definition of Internal Countable Choice in Evidenced Frames
This is the formal statement of Definition 2.2. It is in point-free notation because it is defined over any cartesian-closed category, not just sets.
Module CCinHOF (CCC : CartesianClosedCategory) (NNO : NaturalNumberObject CCC ) (HOF : NatHigherOrderFibration CCC NNO ).
Definition total (o1 o2 : O) (φ1 : Φ o1 ) : Φ (⇒ o1 (⇒ o2 Ω))
:= ∀ o1 (⊃ (φ˙[·] π2 φ1 ) (φ˙[·] (eval o1 (⇒ o2 Ω)) (∃ o2 (φ˙[·] (eval o2 Ω) holds)))).
Definition includes : Φ (× Ω Ω) := ⊃ (φ˙[·] π2 holds) (φ˙[·] π1 holds).
Definition lift (o1 o2 : O) (φ2 : Φ (× o2 o2 )) : Φ (× (⇒ o1 o2 ) (⇒ o1 o2 ))
:= ∀ o1 (φ˙[·] ((·, ·⟩ (; ((·, ·⟩ (; π1 π1 ) π2 ) (eval o1 o2 )) (; ((·, ·⟩ (; π1 π2 ) π2 ) (eval o1 o2 ))) φ2 ).
Definition determined (o1 o2 : O) : Φ (⇒ o1 (⇒ o2 Ω))
:= ∀ o1 (φ˙[·] (eval o1 (⇒ o2 Ω)) (∀ o2 (∀ o2 (⊃ (φ˙[·] (; ((·, ·⟩ (; π1 π1 ) (; π1 π2 )) (eval o2 Ω)) holds)
(⊃ (φ˙[·] (; ((·, ·⟩ (; π1 π1 ) π2 ) (eval o2 Ω)) holds)
(φ˙[·] ((·, ·⟩ ! ((·, ·⟩ (; π1 π2 ) π2 )) (= o2 (T (× 1 o2 ))))))))).
Definition countable choice (o : O) : Φ 1
:= ∀ (⇒ N (⇒ o Ω)) (φ˙[·] π2 (⊃ (total N o 𝕟)
(∃ (⇒ N (⇒ o Ω)) (∧ (∧ (φ˙[·] π2 (total N o 𝕟)) (lift N (⇒ o Ω) (lift o Ω includes)))
(φ˙[·] π2 (determined N o)))))).
End CCinHOF.
E-A2. Definition of Internal Countable Choice in Relational Combinatory Algebras
This is the formal statement of the definition in Lemmas 3.3 and 4.5.
Module CCinRCA (RCA : RelationalCombinatoryAlgebra ).
Definition ∃| {o1 : O} (o2 : O) (P12 : set o1 → set o2 → Prop) (p12 : Φ (× o1 o2 )) : Φ o1
:= λ x1 c '→ ∃ x2 : set o2 , Jset o2 x2 ∧ P12 x1 x2 ∧ p12 (pair x1 x2 ) c.
Definition rca included {o : O} (S R : set (⇒ N (⇒ o Ω))) : Prop := ∀ n : N, ∀ x : set o, ∀ c : C, Jset o x → JC c → S n x c→ R n x c.
Definition rca determined {o : O} (S : set (⇒ N (⇒ o Ω))) : Prop
:= ∀ n : N, ∀ x x’ : set o, ∀ c c’ : C, Jset o x → Jset o x’ → JC c → JC c’ → S n x c → S n x’ c’ → ≈set o x x’.
Definition rca countable choice (o : O) : Φ 1
:= ∀ (⇒ N (⇒ o Ω)) (φ˙[·] π2 (⊃ (total N o 𝕟)
(∃| (⇒ N (⇒ o Ω)) (λ R S '→ rca included S R ∧ rca determined S ) (φ˙[·] π2 (total N o
𝕟))))).
E-A3.  Proof that Internal CC for a PCA/RCA is Equivalent to Internal CC for its Higher-Order Fibration
We provide the codes exhibiting equivalence, but we elide here the actual proof of Lemmas 3.3 and 4.5 as it is rather tedious and follows from the definitions of the codes.
Definition csimplify : C := cλ 1 (· ((·) (cλ 1 (· (· (evar 2 None) ((·) csnd )) (· (· (evar 2 None) ((·) cfst )) (evar 2 (Some None)))))) (· (· (evar 2 None) (evar 2 (Some None))) ((·) cfst ))).
Definition ccomplicate : C := cλ 1 (· ((·) (cλ 1 (· (· (evar 2 (Some None)) (· ((·) (cλ 1 (· (· (evar 2 (Some None)) (evar
2 None)) ((·) (cλ 0 (evar 1 None)))))) (evar 2 None))) ((·) (cλ 2 (evar 3 (Some (Some None)))))))) (· (evar 2 None) (evar 2 (Some None)))).
Lemma rca countable choice equiv (o : O): JO o →▶ (countable choice o) (rca countable choice o) ∧▶ (rca countable choice o) (countable choice o).
End CCinRCA.
E-A4. Definition of Internal Countable Choice in Stateful Combinatory Algebras
This is the formal statement of the definition in Lemma 5.5.
Module CCinSCA (SCA : StatefulCombinatoryAlgebra ).
Definition ∃| {o1 : O} (o2 : O) (P12 : set o1 → set o2 → Prop) (p12 : Φ (× o1 o2 )) : Φ o1
:= λ x1 σ c '→ ∃ x2 : set o2 , Jset o2 x2 ∧ P12 x1 x2 ∧ p12 (pair x1 x2 ) σ c.
Definition sca included {o : O} (S R : set (⇒ N (⇒ o Ω))) : Prop
:= ∀ n : N, ∀ x : set o, ∀ σ : Σ, ∀ c : C, Jset o x → JΣ σ → JC σ c → S n x σ c→ R n x σ c.
Definition sca determined {o : O} (S : set (⇒ N (⇒ o Ω))) : Prop
:= ∀ n : N, ∀ x x’ : set o, ∀ σ : Σ, ∀ c c’ : C, Jset o x → Jset o x’ → JΣ σ → JC σ c → JC σ c’ → S n x σ c → S n x’ σ
c’ → ≈set o x x’.
Definition sca countable choice (o : O) : Φ 1
:= ∀ (⇒ N (⇒ o Ω)) (φ˙[·] π2 (⊃ (total N o 𝕟)
(∃| (⇒ N (⇒ o Ω)) (λ R S '→ sca included S R ∧ sca determined S ) (φ˙[·] π2 (total N o
𝕟))))).

5. Proof that Internal CC for an SCA is Equivalent to Internal CC for its Higher-Order Fibration
We provide the codes exhibiting equivalence, but we elide here the actual proof of Lemma 5.5 as it is rather tedious and follows from the definitions of the codes.
Definition csimplify : C := cλ 1 (· ((·) (cλ 1 (· (· (evar 2 None) ((·) csnd )) (· (· (evar 2 None) ((·) cfst )) (evar 2 (Some None)))))) (· (· (evar 2 None) (evar 2 (Some None))) ((·) cfst ))).
Definition ccomplicate : C := cλ 1 (· ((·) (cλ 1 (· (· (evar 2 (Some None)) (· ((·) (cλ 1 (· (· (evar 2 (Some None)) (evar
2 None)) ((·) (cλ 0 (evar 1 None)))))) (evar 2 None))) ((·) (cλ 2 (evar 3 (Some (Some None)))))))) (· (evar 2 None) (evar 2 (Some None)))).
Lemma sca countable choice equiv (o : O): JO o →▶ (countable choice o) (sca countable choice o) ∧▶ (sca countable choice o) (countable choice o).
End CCinSCA.
E-B. CCPCAs.v
1. Proof that Partial Combinatory Algebras Internally Model Countable Choice
This module demonstrates that the higher-order fibration for any PCA internally models countable choice, as claimed in Theorem 3.4. We only show the metatheoretic assumption made and the key lemma enabled by determinism that permits PCAs to model countable choice; we elide here the detailed proof of the theorem.
Module CCPCA (PCA : PartialCombinatoryAlgebra ).
Here we assume the axiom of countable choice in the metatheory.
Axiom axiom of countable choice : ∀ I : Set, ∀ JI : I → Prop, ∀ R : N → I → Prop, (∀ n : N, ∃ i : I, JI i ∧ R n i ) → ∃ 
S : N → I → Prop, (∀ n : N, ∀ i : I, S n i → R n i ) ∧ (∀ n : N, ∀ i i’ : I, S n i → S n i’ → i = i’ ) ∧ ∀ n : N, ∃ i : I, JI i
∧ S n i.
This is the key lemma that enables us to prove choice. It requires the red deterministic property of PCAs.
Lemma red exists (cf ca : C) (I : Set) (JI : I → Prop) (φ· : I → C → Prop) : JC cf → JC ca → (∃ i : I, JI i ) → ↓φ ↓c
↓ cf ca (λ cr '→ ∃ i : I, JI i ∧ φ· i cr ) → ∃ i : I, JI i ∧ ↓φ ↓c ↓ cf ca (φ· i ).
Definition cc : C := cλ 0 ((·) caxiom ).
Theorem countable choice (o : O) : JO o → ▶ (T 1) (countable choice o).
End CCPCA.
E-C. NCCRCA.v
1. Definition of Flip-RCA
This is the formal definition of Flip-RCA in Figure 1. It uses the FreeRCA module for λ-terms, so the following module specifies the primitives and their behavior. Note that primitives here include the n codes, with pvalue being the corresponding constructor. We use O here to refer to what the paper refers to as primitives.
Module FlipApplicativeStructure <: PrimitiveApplicativeStructure.
Inductive O : Set := const (n : N) | succ | on · do · else · (n : list N) (oon ooff : O) | flip.
Inductive Prim’ : Set := pvalue (n : N) | pop (o : O).
Definition JP (p : P ) : Prop := True.
Inductive ↓O : O → N → N → Prop
:= roconst (n na : N) : ↓O (const n ) na n
| rosucc (n : N) : ↓O succ n (S n)
| robranchon (n : list N) (oon ooff : O) (na nr : N) : In na n → ↓O oon na nr → ↓O (on · do · else · n oon ooff ) na nr
| robranchoff (n : list N) (oon ooff : O) (na nr : N) : (In na n → False) → ↓O ooff na nr → ↓O (on · do · else · n oon ooff ) na nr
| rotails (na : N) : ↓O flip na 0
| roheads (na : N) : ↓O flip na 1.
Definition ↓p (pf : P ) (ca : C? P ) (cr : C? P ) : Prop
:= ∃ of : O, pop of = pf ∧ ∃ na : N, (·) (pvalue na ) = ca ∧ ∃ nr : N, (·) (pvalue nr ) = cr ∧ ↓O of na nr .
Definition ↓p (pf : P ) (ca : C? P ) : Prop := ∃ of : O, pop of = pf ∧ ∃ na : N, (·) (pvalue na ) = ca .

Lemma preservation prim (pf : P ) (ca : C? P ) (cr : C? P ) : JP pf → JC
JP ca → ↓p pf ca cr → JC
JP cr .

?	c	?
p	p
Lemma progress prim (pf : P ) (ca : C? P ) : JP pf → JC? JP ca → ↓ pf ca → ∃ cr : C? P , ↓ pf ca cr .
End FlipApplicativeStructure.
E-C2. Proof that Flip-RCA is an RCA.
The proof of Lemma 4.3 is a trival application of the FreeRCA module.
Module FlipRCA := FreeRelationalCombinatoryAlgebra FlipApplicativeStructure.
E-C3. Definition of Flip-RCA Codes with Primitive Holes
The first part of this module provides the formal definitions of codes with holes and of the operations for filling those holes used in Lemma 4.4.
Module FlipNCC.
Inductive O˙ : Type := hohole | hoconst (n : N) | hosucc | hobranch (n : list N) (o˙on o˙off : O˙ ) | hoflip.
Fixpoint fill op (o : O) (o˙ : O˙ ) : O
:= match o˙ with
| hohole '→ o
| hoconst n '→ const n
| hosucc '→ succ
| hobranch n o˙on o˙off '→ on · do · else · n (fill op o o˙on ) (fill op o o˙off )
| hoflip '→ flip
end.
Inductive P˙ : Type := hpvalue (n : N) | hpop (o˙ : O˙ ).
Definition C˙ : Type := C? P˙ .
Definition fill prim (o : O) (p˙ : P˙ ) : P := match p˙ with hpvalue n '→ pvalue n | hpop o˙ '→ pop (fill op o o˙) end. Definition fill lambda (fill code : C˙ → C) {n : N} : L C˙ n → L C n


:= fix fill lambda (hl : L C˙ n ) : L C n
:= match hl with (·) c˙ '→ (·) (fill code c˙) | lvar  v '→ lvar n v | · hlf hla '→ · (fill lambda hlf ) (fill lambda hla ) end.
Fixpoint fill code (o : O) (c˙ : C˙ ) : C := match c˙ with (·) p˙ '→ (·) (fill prim o p˙) | λ· n hl '→ λ· n (fill lambda (fill code o) hl ) end.
E-C4. Proof that Flip-RCA is Extensional and Finitary
The actual proof is elided here, as it is straightforward from induction on the given proof of application. Only the formal statement of Lemma 4.4 is shown.
Lemma continuity code (c˙f c˙a : C˙ ) (o : O) (cr : C)
: ↓C? ↓p (fill code o c˙ ) (fill code o c˙a ) cr
c	c	f

→ ∃ c˙r : C˙ ,
fill code o c˙r = cr
∧ ∃ io : list (prod N N),
Forall (λ io '→ ↓O o (fst io) (snd io)) io
∧ ∀ o’ : O, Forall (λ io '→ ↓O




C? ↓p (fill code o’ c˙ ) (fill code o’ c˙a ) (fill code o’ c˙r ).

o’ (fst io) (snd io)) io → ↓c	c	f
E-C5. Proof that Flip-RCA Internally Negates Countable Choice
The detailed proof of Theorem 4.6 is elided here, but we provide the primary lemmas to provide some insight.
Fixpoint filled op (o : O) : O˙
:= match o with const n '→ hoconst n | succ '→ hosucc | on · do · else · n oon ooff '→ hobranch n (filled op oon ) (filled op ooff )
| flip '→ hoflip end.
Definition filled prim (p : P ) : P˙ := match p with pvalue n '→ hpvalue n | pop o '→ hpop (filled op o) end. Definition filled lambda (filled code : C → C˙ ) {n : N} : L C n → L C˙ n
:= fix filled lambda (Æ : L C n ) : L C˙ n
:= match Æ with (·) c '→ (·) (filled code c) | lvar  v '→ lvar n v | · Æf Æa '→ · (filled lambda Æf ) (filled lambda Æa ) end. Fixpoint filled code (c : C) : C˙ := match c with (·) p '→ (·) (filled prim p) | λ· n Æ '→ λ· n (filled lambda filled code Æ)
end.
Lemma fill filled code (o : O) (c : C) : fill code o (filled code c) = c.
Lemma red cnat (n : N) : ↓C? ↓p ↓p (cλ n ) ((·) (pop succ)) ∧ ∀ cns : C, ↓C? ↓p (cλ n ) ((·) (pop succ)) cns → ∀ m : N,
c	·	c	c  ·
↓C? ↓p ↓p cns ((·) (pvalue m )) ∧ ∀ cnm : C, ↓C? ↓p cns ((·) (pvalue m )) cnm → (·) (pvalue (n + m )) = cnm .
c	c	c
Definition cop (o : O) : C := λ· 0 (· ((·) ((·) (pop o))) (· (· (lvar 1 None) ((·) ((·) (pop succ)))) ((·) ((·) (pvalue 0))))).
Lemma red cop (o : O) (m : N) (cm : C) (φr : C → Prop) : 𝕟 m cm → (∀ n : N, ↓O o m n → φr ((·) (pvalue n ))) → ↓φ
↓c ↓ (cop o) cm φr .
Definition hcop (o˙ : O˙ ) : C˙ := λ· 0 (· ((·) ((·) (hpop o˙))) (· (· (lvar 1 None) ((·) ((·) (hpop hosucc)))) ((·) ((·) (hpvalue 0))))).
Lemma fill cop (o : O) (o˙ : O˙ ) : fill code o (hcop o˙) = cop (fill op o o˙).
Definition Rop (o : O) : set (⇒ N (⇒ N Ω)) := λ m n c '→ ↓O o m n ∧ ((·) (pvalue n )) = c.
Lemma Ropv (o : O) : Jset (⇒ N (⇒ N Ω)) (Rop o).
Lemma Rop total (o : O) : total N N 𝕟 (Rop o) (cop o).
Definition ncc : C := caxiom.
Theorem neg countable choice : ∃ o : O, ▶ (countable choice o) (⊥ 1).
End FlipNCC.
E-D. CCSCA.v
E-D1. Definition of Mem-SCA
This is the formal definition of Mem-SCA in Figure 3. It uses the FreeSCA module for λ-terms, so the following module specifies the primitives and their behavior. There are a few differences between this definition and that in Figure 3, all for the sake of reducing metatheoretic assumptions. In particular, Σ (i.e. the set of ςs) is defined inductively as a sequence of allocation/memoization events, and ≤ is simply to be defined to be prefix. This means that if a pre-state has two predecessors, then one of the those predecessors must be a future of the other. It also means that if a location-input pair has a memoization in the current pre-state, then we can determine via sfirst the first point in the past where that pair was allocated in the pre-state. Any subsequent futures will have that same first state for the given entry, as proven by sfirst fut eq. This means that we can take a choice relation that is not future-stable, and define from it a choice relation that is future-stable by having every state instead the choice for a particular entry that was assigned to its first predecessor that had that entry (which might be itself). Beyond this, the proof is the same is given in Theorem 5.6.
Module MemoizingApplicativeStructure <: PrimitiveApplicativeStructure.
Primitives and Pre-States
Definition L : Set := N.
Inductive P : Set := ndnat | memo | lookup (Æ : L).
Inductive Σ : Set := sempty | sallocate (σ : Σ) (Æ : L) (cf : C? P ) | smemoize (σ : Σ) (Æ : L) (n : N) (cr : C? P ).
Inductive ≤ (σ : Σ) : Σ → Prop
:= frefl’ : ≤ σ σ 
| fallocate (σ' : Σ) (Æ : L) (cf : C? P ) : ≤ σ σ' → ≤ σ (sallocate σ' Æ cf )
| fmemoize (σ' : Σ) (Æ : L) (n : N) (cr : C? P ) : ≤ σ σ' → ≤ σ (smemoize σ' Æ n cr ).
Lemma ftrans’ (σ σ' σ'' : Σ) : ≤ σ σ' → ≤ σ' σ'' → ≤ σ σ'' .
Lemma flinear {s1 s2 σ' : Σ} : ≤ s1 σ' → ≤ s2 σ' → ≤ s1 s2 ∨ ≤ s2 s1.
Inductive Allocated (σ : Σ) (Æ : L) (cf : C? P ) : Prop := aallocate (sa : Σ) : ≤ (sallocate sa Æ cf ) σ → Allocated σ Æ cf .
Inductive Memoized (σ : Σ) (Æ : L) (n : N) (cr : C? P ) : Prop := mmemoize (sm : Σ) : ≤ (smemoize sm Æ n cr ) σ →
Memoized σ Æ n cr .
Inductive JP (σ : Σ) : P → Prop
:= pndv : JP σ ndnat
| pallocv : JP σ memo
| plookupv (n : N) (cf : C? P ) : Allocated σ n cf → JP σ (lookup n ).
Lemma allocated fut (σ σ' : Σ) (Æ : L) (cf : C? P ) : ≤ σ σ' → Allocated σ Æ cf → Allocated σ' Æ cf .
Lemma memoized fut (σ σ' : Σ) (Æ : L) (n : N) (cr : C? P ) : ≤ σ σ' → Memoized σ Æ n cr → Memoized σ' Æ n cr .


Lemma primv fut’ (σ σ' : Σ) (p : P ) : ≤ σ σ' → JP σ p → JP σ' p.

Lemma pcodev fut’ (σ σ' : Σ) (c : C? P ) : ≤ σ σ' → JC (JP σ) c → JC
?
(JP σ' ) c.

Fixpoint cchurch {P : Set} (n : N) : C? P
:= match n with 0 '→ λ· 1 (lvar 2 (Some None)) | S n '→ λ· 1 (· (lvar 2 None) (· (· ((·) (cchurch n )) (lvar 2 None)) (lvar
2 (Some None)))) end.
Application within a Pre-State
These define frozen reduction within a pre-state.
Inductive ↓p ? (σ : Σ) : P → C? P → C? P → Prop
:= rpfnd (ca : C? P ) (n : N) : ↓p ? σ ndnat ca (cchurch n )
| rpfalloc (cf : C? P ) (Æ : L) : Allocated σ Æ cf → ↓p ? σ memo cf ((·) (lookup Æ))
| rpflookup (Æ : L) (n : N) (cr : C? P ) : Memoized σ Æ n cr → ↓p ? σ (lookup Æ) (cchurch n ) cr .

Inductive ↓λ (↓C? : C  P → C  P → C  P → Prop) : L (C  P ) 0 → C
P → Prop

:= rlfcode (c : C
P ) : ↓λ ↓C? ((·) c) c

?	ς  ς

| rlfapp (lf la : L (C
? P ) 0) (cf ca cr : C?
P ) : ↓λ ↓C? lf c → ↓λ ↓C? la ca
→ ↓C? c  ca cr → ↓λ ↓C? (· lf la) cr .

Inductive ↓C? (σ : Σ) : C
P → C?
P → C?
P → Prop

:= rcprim (p
: P ) (ca : C  P ) (cr : C  P ) : ↓p ? σ p  ca cr
C? σ ((·) p ) ca cr

f	?	?	ς	f
→ ↓ς	f

| rclam0 (lb : L (C
P ) 1) (ca cr : C  P ) : ↓λ (↓C? σ) (lsubst ca lb) cr
C? σ (λ· 0 lb) ca cr

?	?	ς	ς
→ ↓ς

| rclamS (n : N) (lb : L (C?
P ) (S (S n))) (ca : C?
P ) : ↓C? σ (λ· (S n) lb) ca (λ· n (lsubst ca lb)).

Lemma red lambda frozen fut (↓C? ⇓C? : C P → C P → C P → Prop) (Æ : L (C P ) 0) (cr : C P ) : (∀ c
ca cr :

C P , ↓C? c
ca cr
→ ⇓C? c
ca cr ) → ↓λ ↓C? Æ cr → ↓λ ⇓C? Æ cr .

Lemma red prim frozen fut (σ σ' : Σ) (pf : P ) (ca : C? P ) (cr : C? P ) : ≤ σ σ' → ↓p ? σ pf ca cr → ↓p ? σ' pf ca cr .

Lemma red code frozen fut (σ σ' : Σ) (c
ca cr : C
ς
'	C? σ c ca cr
C? σ' c
ς
ca cr .

f
Inductive UnAllocated : Σ → L → Prop
? P ) : ≤ σ σ → ↓ς	f
→ ↓ς	f

:= uaempty (lf : L) : UnAllocated sempty lf
| uaallocate (lf : L) (σ : Σ) (Æ : L) (cf : C? P ) : UnAllocated σ lf → (lf = Æ → False) → UnAllocated (sallocate σ Æ cf )
lf
| uamemoized (lf : L) (σ : Σ) (Æ : L) (n : N) (cr : C? P ) : UnAllocated σ lf → UnAllocated (smemoize σ Æ n cr ) lf.
Inductive UnMemoized : Σ → L → N → Prop
:= umempty (lf : L) (nf : N) : UnMemoized sempty lf nf
| umallocate (lf : L) (nf : N) (σ : Σ) (Æ : L) (cf : C? P ) : UnMemoized σ lf nf → UnMemoized (sallocate σ Æ cf ) lf nf
| ummemoized (lf : L) (nf : N) (σ : Σ) (Æ : L) (n : N) (cr : C? P ): UnMemoized σ lf nf → (lf = Æ → nf = n → False)
→ UnMemoized (smemoize σ Æ n cr ) lf nf.
Lemma memoized unmemoized false (σ : Σ) (Æ : L) (n : N) (cr : C? P ) : Memoized σ Æ n cr → UnMemoized σ Æ n →
False.
States
Rather than defining state validity by the behaviors we need of states, as in Figure 3, we define state validity inductively and prove that it implies the necessary behaviors.
Inductive JΣ : Σ → Prop
:= semptyv : JΣ sempty
| sallocatev (σ : Σ) (Æ : L) (cf : C? P ) : JΣ σ → UnAllocated σ Æ → JC? (JP σ) cf → JΣ (sallocate σ Æ cf )
| smemoizev (σ : Σ) (Æ : L) (n : N) (cr : C? P ) (cf : C? P ) : JΣ σ → Allocated σ Æ cf → UnMemoized σ Æ n → JC?

(J σ) cr
C? σ c (cchurch n ) cr → J (smemoize σ Æ n cr ).

P	→ ↓ς	f	Σ
Lemma statev fut (σ σ' : Σ) : ≤ σ σ' → JΣ σ' → JΣ σ.
Lemma allocated det (σ : Σ) (sv : JΣ σ) (Æ : L) (cf cf’ : C? P ) : Allocated σ Æ cf → Allocated σ Æ cf’ → cf = cf’.
Lemma memoized det (σ : Σ) (sv : JΣ σ) (Æ : L) (n : N) (cr cr’ : C? P ) : Memoized σ Æ n cr → Memoized σ Æ n cr’ →
cr = cr’.
Lemma allocated valid (σ : Σ) (sv : JΣ σ) (Æ : L) (cf : C? P ) : Allocated σ Æ cf → JC? (JP σ) cf .
Lemma memoized valid (σ : Σ) (sv : JΣ σ) (Æ : L) (n : N) (cr : C? P ) : Memoized σ Æ n cr → JC? (JP σ) cr .
Lemma memoized allocated (σ : Σ) (sv : JΣ σ) (Æ : L) (n : N) (cr : C? P ) : Memoized σ Æ n cr → ∃ cf : C? P , Allocated
σ Æ cf .
Lemma memoized red (σ : Σ) (sv : JΣ σ) (Æ : L) (cf : C? P ) (n : N) (cr : C? P ) : Allocated σ Æ cf → Memoized σ Æ n
c	C?
r → ↓ς  σ cf (cchurch n ) cr .
Lemma sinhabited : ∃ σ : Σ, JΣ σ.
Lemma frefl (σ : Σ) : JΣ σ → ≤ σ σ.
Lemma ftrans (σ σ' σ'' : Σ) : JΣ σ → JΣ σ' → JΣ σ'' → ≤ σ σ' → ≤ σ' σ'' → ≤ σ σ'' .
Lemma primv fut (σ σ' : Σ) (p : P ) : JΣ σ → JΣ σ' → ≤ σ σ' → JP σ p → JP σ' p.

Lemma pcodev fut (σ σ' : Σ) (c : C? P ) : JΣ σ → JΣ σ' → ≤ σ σ' → JC (JP σ) c → JC
?
(JP σ' ) c.

Application and Termination with States
This defines the application relation that does mutate pre-state.
Definition ↓p (σ : Σ) (pf : P ) (ca : C? P ) (σ' : Σ) (cr : C? P ) : Prop := ≤ σ σ' ∧ JΣ σ' ∧ ↓p ? σ' pf ca cr .
c	ς
Inductive ↓p (σ : Σ) : P → C? P → Prop
:= tpfnd (ca : C? P ) : ↓p σ ndnat ca
| tpfalloc (cf : C? P ) : ↓p σ memo cf
| tpflookup (Æ : L) (n : N) (cf : C? P ) : Allocated σ Æ cf → ↓C? ↓p ↓p σ cf (cchurch n ) → ↓p σ (lookup Æ) (cchurch n ).

Progress
Lemma preservation prim (σ : Σ) (pf : P ) (ca : C? P ) (σ' : Σ) (cr : C? P ) : JΣ σ → JP σ pf → JC


(JP σ) ca → ↓p σ

pf ca σ' cr → JΣ σ' ∧ ≤ σ σ' ∧ JC (JP σ' ) cr .
Lemma new (σ : Σ) : (∃ Æ : L, ∀ Æ' : L, Æ ≤ Æ' → UnAllocated σ Æ' ).
Lemma memoized (σ : Σ) (Æ : L) (n : N) : (∃ cr : C? P , Memoized σ Æ n cr ) ∨ (UnMemoized σ Æ n ).


Lemma red code freeze (σ : Σ) (c ca : &

P ) (σ' : Σ) (cr : &

P ) : J σ → J  (J σ) c  → J

(J σ) ca

C? ↓p

f	?
C?
σ cf ca σ' cr → ↓	σ' c  ca cr .
?	Σ	C?  P
f	C?  P
→ ↓c	c

Lemma red code thaw (σ : Σ) (c
ca : &
P ) (cr : &
C? σ c  ca cr
C? ↓p σ c  ca σ cr .

f	?	? P ) : JΣ σ → ↓ς	f
→ ↓c	c	f

p	'
Lemma progress prim (σ : Σ) (pf : P ) (ca : &? P ) : JΣ σ → JP σ pf → JC? (JP σ) ca → ↓ σ pf ca → ∃ σ : Σ, ∃ cr :
&? P , ↓p σ pf ca σ' cr .
End MemoizingApplicativeStructure.
E-D2. Proof that Mem-SCA is an SCA.
The proof of Lemma 5.4 is a trival application of the FreeSCA module.
Module MemoizingSCA := FreeStatefulCombinatoryAlgebra MemoizingApplicativeStructure.
E-D3. Proof that Mem-SCA Internally Models Countable Choice
The detailed proof of Theorem 5.6 is elided here, but we provide the primary lemmas to provide some insight.
Module MemoizingCC.
Here we assume the axiom of countable choice in the metatheory, asserting without proof that the set of states Σ and the set of codes C are both countable, and that JΣ , ≤, and Memoized are each recognizable predicates so that the subset of states and codes satisfying them is also countable.
Axiom axiom of countable choice : ∀ I : Set, ∀ JI : I → Prop, ∀ σ : Σ, ∀ Æ : L, ∀ R : N → I → Σ → & → Prop, (∀ n : N,
∀ σ' : Σ, ∀ c : &, JΣ σ' → ≤ σ σ' → Memoized σ' Æ n c → ∃ i : I, JI i ∧ R n i σ' c) → ∃ S : N → I → Σ → & → Prop, (∀ n : N, ∀ i : I, ∀ σ' : Σ, ∀ c : &, S n i σ' c → R n i σ' c) ∧ (∀ n : N, ∀ i i’ : I, ∀ σ' : Σ, ∀ c : &, S n i σ' c → S n i’ σ' c → i = i’ ) ∧ ∀ n : N, ∀ σ' : Σ, ∀ c : &, JΣ σ' → ≤ σ σ' → Memoized σ' Æ n c → ∃ i : I, JI i ∧ S n i σ' c.
First predecessor with a given entry
Fixpoint sfirst (Æ : L) (n : N) (σ : Σ) : Σ 
:= match σ with
| sempty '→ sempty
| sallocate σ Æ' cf '→ sfirst Æ n σ
| smemoize σ Æ' n’ cr '→ if eq dec Æ Æ' then if eq dec n n’ then smemoize σ Æ' n’ cr else sfirst Æ n σ else sfirst Æ n σ
end.
Lemma smemoize sfirst fut (σ σ' : Σ) (Æ : L) (n : N) (cr : &): ≤ (smemoize σ Æ n cr ) σ' → ≤ (smemoize σ Æ n cr ) (sfirst
Æ n σ' ).
Lemma sfirst memoized (Æ : L) (n : N) (σ : Σ) (cr : &) : Memoized σ Æ n cr → Memoized (sfirst Æ n σ) Æ n cr .
Lemma sfirst fut eq (Æ : L) (n : N) (σ σ' : Σ) (cr : &) : JΣ σ' → ≤ σ σ' → Memoized σ Æ n cr → sfirst Æ n σ = sfirst Æ
n σ' .
Lemma sfirst fut (Æ : L) (n : N) (σ : Σ) : ≤ (sfirst Æ n σ) σ.
Lemma sfirst unmemoized (σ : Σ) (Æ : L) (n : N) (σ' : Σ) (cr : &) : UnMemoized σ Æ n → Memoized σ' Æ n cr → ≤ σ σ'
→ ≤ σ (sfirst Æ n σ' ).
Countable Choice
Definition cc : & := cλ 0 (ecode ((·) memo)).
Theorem countable choice (o : O) : JO o → ▶ (T 1) (countable choice o).
End MemoizingCC.
