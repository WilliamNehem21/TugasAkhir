

Electronic Notes in Theoretical Computer Science 259 (2009) 225–243
www.elsevier.com/locate/entcs
Supporting ArcAngel in ProofPower
Frank Zeydaa,1, Marcel Oliveirab and Ana Cavalcantia
a Department of Computer Science, University of York, York, YO10 5DD, UK
b Departamento de Informa´tica e Matema´tica Aplicada, Universidade Federal do Rio Grande do Norte, Brazil

Abstract
ArcAngel is a specialised tactic language devised to facilitate and automate program developments using Morgan’s refinement calculus. It is especially well-suited for the specification of high-level strategies to derive programs by construction, and equipped with a formal semantics that enables reasoning about tactics. In this paper, we present an implementation of ArcAngel for the ProofPower theorem prover. We discuss the underlying design, explain how it implements the semantics of ArcAngel, and examine differences in expressiveness and flexibility in comparison to ProofPower’s in-built tactic language. ArcAngel supports backtracking through angelic choice; this is beyond the basic capabilities of ProofPower and many other main-stream theorem provers. The implementation is demonstrated with a non-trivial tactic example.
Keywords: tactic language; proof automation; refinement; Z


Introduction
Morgan’s refinement calculus [10] supports the derivation of programs from specifi- cations. It incorporates the constructs of Dijkstra’s guarded command language and adds a specification statement w : [pre, post ] which captures the behaviour of a pro- gram that can update the variables in the list w (the frame), and has precondition pre and postcondition post . Specifications are transformed into executable programs by a series of correctness-preserving refinement steps, and each step is justified by the application of a law within the calculus. This guarantees by construction that the concrete refinement correctly implements its abstract specification.
To automate recurring sequences of derivation steps in the refinement of program specifications, the ArcAngel tactic language was proposed [12]. It has a formal semantics and an extensive set of algebraic laws that support transformation and reasoning about tactics. ArcAngel is itself an extension of Angel [6,8], owing its name to the angelic resolution of nondeterminism in the process of solving proof goals.

1 Email: zeyda@cs.york.ac.uk

1571-0661 © 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.12.027


Fig. 1. Two examples of elementary refinement laws.
Whereas Angel is a general-purpose tactic language, ArcAngel specifically targets transformation of programs. We can think of ArcAngel tactics as procedures for rewriting program expressions in Morgan’s calculus.
ArcAngel tactics are written in a notation that supports the application of prim- itive refinement laws, as well as various operators to combine tactics; the latter are often called tacticals. Two fundamental tactic combinators are alternation t1 | t2 and sequential composition t1 ; t2. Alternation first attempts to apply t1, and if this leads to failure at any point, applies t2. Sequential composition applies the tactics t1 and t2 in sequence. In general, failure might occur for a number of reasons, one of them is a primitive law not being applicable to a program.
An important feature of the alternating choice in ArcAngel is that it is angelic, in that it always finds a successful execution, if there is one, by making the right choices. As an example, we consider the following tactic.
robustFollowAssign(x, E ) = (skip | law expandFrame(x )) ; law followAssign(x, E )
The law name(args) constru^ct invokes a parametrised refinement law name passing the list of arguments args. Here, we use refinement laws from [10]: expandFrame(x ) extends the frame of a specification with a variable x , and followAssign(x, E ) refines
a specification statement into a sequence composed of a specification statement followed by the assignment x := E . The definition of the laws is in Fig.1. The skip tactic always succeeds and does not alter the program.
We observe that followAssign(x, E ) can only be applied if the program is of the form w, x : [pre, post ]. The tactic robustFollowAssign(x, E ) above, on the other hand, may be successfully applied to specification statements that may not have x in their frame. Operationally, this results in followAssign(x, E ) failing after the first choice skip is taken, and the execution backtracking to explore the second choice of the alternation in attempting to find a successful path of continuation.
The angelic nondeterminism embedded in the choice supports a concise and general description of many robust tactics of refinement and proof. Several examples are presented in [12]. The implicit backtracking manifests itself in the following law which is valid for ArcAngel (and Angel): (t1 | t2); t3 = (t1 ; t3) | (t2 ; t3).
The Ergo theorem prover [16], which is implemented in Prolog, was extended to use Angel as a tactic language [9]. ArcAngel is incorporated in the refinement editor REFINE [14], which however does not provide facilities for theorem proving. In this paper, we present an implementation of ArcAngel in ProofPower, a flexible and extensible theorem prover based on HOL. It has an open architecture and has been successfully used on industrial-scale projects [1]. ProofPower also provides an embedding and formalisation of the Z language. This is useful in defining a semantic

model for Morgan’s refinement calculus as part of the ArcAngel implementation.
To encode the ArcAngel tactic above in ProofPower, we could try and use the tactical ORELSE to represent alternation, and THEN to represent sequencing. Even so (t1 ORELSE t2) THEN t3 would not have the same operational behaviour as the ArcAngel tactic (t1 | t2); t3. The ProofPower tactic would first apply t1, and if this fails resolve to applying t2. The choice of either applying t1 or t2, however, is not revised if t3 subsequently turns out to fail. In general, ORELSE acts like a cut on alternation; the choice it makes is not a provisional one unless t1 on its own fails, in which case t2 is executed. Similar limitations to backtracking also exist in LCF and HOL. PVS, on the other hand, does provide in-built support for backtracking tactics via its try tactical, but its semantics is more difficult to describe (and, consequently, more difficult to use) as failure and backtracking are treated as distinct outcomes of tactic applications; this becomes apparent, for example, in [5].
A second limitation that we overcome in our implementation is that conven- tionally tactics in ProofPower, like in many other theorem provers, apply to goals (sequents), namely pairs of assumptions and conclusions. The purpose of ArcAn- gel tactics, on the other hand, is to transform program expressions. In this paper we describe how we support the use of ArcAngel tactics, which is independent of the ProofPower tactic language. Our implementation is very close to the formal semantics of ArcAngel, increasing confidence in its correctness.
We also address several issues that led to a generalisation and in parts unification of ArcAngel with its kin Angel, as well as the more specialised derivate ArcAngelC , a variant tailored for refinement in the Circus language [11]. Whereas Angel deals with proving general theorems, ArcAngel(C ) are methods for constructive refinement. A by-product of this unification is a framework that fosters the development of other derivatives of Angel, and we explain how we support their embedding.
The structure of the paper is as follows. In Section 2 we introduce the relevant preliminary material; more specifically, we give a brief account of the syntax and semantics of ArcAngel, and the ProofPower theorem prover. Section 3 discusses the fundamental design of our implementation and its relationship to the ArcAngel semantics. The following section illustrates the use of the tool through an example, and in Section 5 we draw our conclusions, address some aspects of extensions and generalisations, and identify future work.

Preliminaries
In this section, we introduce the relevant preliminary material. First, the ArcAngel tactic language is explained in more detail: we illustrate its use, and briefly discuss its semantic model. The last section provides background information on ProofPower.
ArcAngel
ArcAngel includes basic tactics, like skip or the application of laws, tacticals, and structural combinators, which facilitate the application of tactics to arguments of the program operators. The basic tactics and tacticals are inherited from Angel,

albeit adapted to deal with refinement laws. Whereas Angel provides one struc- tural combinator for applying tactics to sequences of subgoals, ArcAngel provides a collection of structural combinators corresponding to the program constructors.
A tactic program in ArcAngel is a sequence of tactic declarations. We declare a tactic name with body t and arguments args as Tactic name(args) t end. The optional clause proof obligations documents the proof obligations (provisos) pro- duced by application of t . An additional optional clause generates records the shape of the generated program. The body of the declaration can be any tactic expression involving the variables introduced through args.
The most basic tactic is law name(args); it assumes name, the law, to be a priori defined and to have parameters that are suitably instantiated by args. If name with arguments args is applicable, the application of the tactic succeeds and returns a new program, possibly generating proof obligations for the provisos of name. If, on the other hand, the law is not applicable, the tactic fails. An analogous construct exists to invoke a declared tactic. Its syntax is tactic name(args) where name is the name of the tactic, and args the list of arguments passed to it.
The other basic tactics are skip, fail, and abort. The tactic skip always suc- ceeds leaving the program unchanged, fail always fails, and abort neither succeeds nor fails, but may produce any (list of) outcome(s) or even run indefinitely. Nonter- mination is not equated with failure since we cannot compute it. With regards to implementability of angelic nondeterminism, failure must always be inferable from tactic execution. Thence comes the need to distinguish fail and abort.
Tactics can be composed using tacticals. We already met the binary tacticals t1 ; t2 for sequential composition, and t1 | t2 for alternation. Alternation is strict with respect to abort in its first operand, but not the second one, because, whenever t1 succeeds or leads to success, application of t2 is not carried out.
The cut operator ! t is a unary tactical. Its effect is to apply t , but only considers the first result of the application when there is more than one possible outcome due to nondeterminism. It acts like a ‘cut’ in Prolog with regards to the backtracking search of finding a feasible path of tactic execution.
Two further unary tactics are the assertions succs t and fails t . The first ter- minates without changing the program (that is, behaving like skip) if t succeeds, and otherwise fails. The second terminates without changing the program if t fails, and otherwise fails. Both are strict with respect to abort too.
ArcAngel also permits the specification of recursive tactics; they are generally useful to define tactics that carry out repetitive actions. The fixed-point construc- tion μ X • f (X ) is used for this purpose; here f is some function on tactics.
The tactic applies to p do t guards the application of t by checking whether the program the tactic is applied to is of the form p, which acts as a pattern. If the pattern matching succeeds, the free variables in p are instantiated as meta-variables, and can be referenced in the definition of t . Otherwise, the tactic fails. To illustrate this, consider, for example, applies to w : [pre, post1 ∧ post2] do t being applied to the program x , y : [true, x = 1 ∧ y = 2]. The matching in this case associates w with ⟨x , y⟩, pre with true, post1 with x = 1, and post2 with y = 2. The body of t


Tactic takeConjAsInv(invBound, lstVar, lstVal, variantExp)
applies to w : [pre, inv ∧¬ guard ] do law strPost(inv ∧ invBound ∧¬ guard ); law seqComp(inv ∧ invBound ); 

(law assign(lstVar, lstVal )
proof obligations
law iter(⟨guard⟩, variantExp))

inv ∧¬ guard ∧ invBound ⇒ inv ∧¬ guard (from strPost)
pre ⇒ (inv ∧ invBound )[lstVar\lstVal ] (from assign)
generates
lstVar := lstVal ;




end
do guard → w :	inv ∧ invBound ∧ guard,
inv ∧ 0 ≤ variantExp < variantExp[w\w0]

Fig. 2. Definition of the takeConjAsInv tactic.

  od

can refer to w , pre, post1 and post2 in its definition.
Finally, structural combinators allow us to apply tactics to subprograms of some
program operator. For example, t1	t2 transforms programs of the form p1 ; p2 by
applying t1 to p1 and t2 to p2. The proof obligations generated are those arising from both tactic applications, and the piecewise application of the tactics is sound because of monotonicity, namely here of sequential composition in both operands. In ArcAngel, we have a structural combinator for each syntactic construct of the refinement calculus. They are easily identifiable as boxed versions of the program operators. In the sequel, we give an example of a non-trivial ArcAngel tactic.

Tactic Example
Fig. 2 presents a tactic to derive an initialised iteration. It uses the iter law in Fig. 3 to refine a specification of the form w : [inv, inv ∧ ¬ GG ] into an iteration do [] i • Gi → w : [inv ∧ Gi , inv ∧ 0 ≤ V < V0] od. Notice that 0-subscripted variables in the postcondition refer to initial values. Here, inv is the invariant of the loop, and GG the disjunction of the guards Gi . To apply this law, we have to provide a list of guards ⟨G1, G2,..., Gn ⟩ as well as a variant expression V .
The tactic takeConjAsInv performs a more sophisticated refinement of such spec- ifications by additionally strengthening the invariant with a user-supplied (bound- ary) constraint, and performing an initialisation of the variables modified by the iteration. It was originally presented in [12]. In its definition and hereafter, we assume that ∧ associates to the left ; this reduces the number of parentheses.
The tactic takeConjAsInv is parametrised in terms of the additional invariant constraint invBound , the left-hand side lstVar and right-hand side lstVal of the initialising assignment, and the variant expression variantExp. The applies to  do  construct requires the program to be of the form w : [pre, inv ∧ ¬ guard ] for the tactic to be applicable. Its body executes the primitive laws strPost, seqComp, assign and iter; their definitions are also given, in Fig. 3.


Fig. 3. Laws used in the definition of the takeConjAsInv tactic.
First, the application of the strPost law strengthens the postcondition of the specification statement to inv ∧ invBound ∧ ¬ guard , including the additional conjunct invBound . The corresponding proviso (1) is always true. The second law seqComp decomposes the specification statement using inv ∧ invBound as an intermediate condition. The program resulting from this step is of the general form
w : [pre, inv ∧ invBound ]; w : [inv ∧ invBound, inv ∧ invBound ∧¬ guard ]
The law seqComp is applicable providing that neither the intermediate condition nor the postcondition inv ∧ invBound ∧ ¬ guard contains initial variables. The final
step uses the structural combinator	to apply the assign law to the first operand
of the sequential composition, and the iter law to the second operand. The assign law refines a specification statement into an assignment, and gives rise to proof obligation (2). We thus obtain the program reported in the generates clause.
In Section 4 we encode takeConjAsInv in ProofPower.

Semantics of ArcAngel
An important feature of ArcAngel is that, like Angel, it is equipped with a formal semantics. Tactics in ArcAngel are characterised by functions that map refinement cells to (possibly infinite) lists of refinement cells. A refinement cell captures a program expression and includes a set of proof obligations to derive that program.
RCell == Program × P Predicate and Tactic == RCell →' pfiseq RCell
Program is the semantic domain for program expressions, and Predicate represents proof obligations. The list generated by a tactic application can be infinite, namely if there is an infinite succession of possible outcomes, and also has to admit the possibility of being only partially defined. For example, the tactic skip | abort generates a list for which evaluation of only the first element is guaranteed to suc- ceed. Any further outcome is undefined and could even lead to evaluation failing to terminate. The standard representation of lists as (finite) sequences is not expres- sive enough. In [7] Martin presents a model for partial, finite and infinite lists (pfi lists). The function pfiseq above is the type constructor for such lists.
In this model lists can be either partial or finite. Whereas finite lists end in concatenation with the empty list as in 1 : 2 : [ ], partial lists end in concatenation with the undefined list ⊥. The interpretation of, for example, 1 : 2 : ⊥, is that

evaluation of only the first two elements is guaranteed to succeed; attempting to evaluate the remainder of the list could give any result, and even fail to terminate. To illustrate how infinite lists represent tactic outcomes, we consider the appli-
cation of skip | abort to a refinement cell r . Applying skip only yields one result,
the finite list r : [ ]. When moving to infinite lists, we however have to consider all approximations, here that is {⊥, r : ⊥, r : [ ]}. The result of applying abort, on the other hand, is ⊥, and the chain of approximations is the singleton set {⊥}.
The semantic function .. .) for tactics is further parametrised in terms of law and tactic environments which record the declared laws and tactics. Its type is TacExpr →LEnv →TEnv →Tactic, where TacExpr is the set of tactic expressions.
The semantics of basic tactics is then given as follows.
 skip) ΓL ΓT r = [r ]	 fail) ΓL ΓT r = [ ]	 abort) ΓL ΓT r = ⊥
Here, ΓL and ΓT denote the law and tactic environments under which application is considered, and r the refinement cell to which the tactic is applied.
The semantics of law name(args) is a singleton list with the refinement cell containing the transformed program and possibly additional proof obligations, or otherwise an empty list if application fails. The law definition is inferred from the law environment. Similarly, tactic name(args) executes the tactic name by inferring its definition from the tactic environment.
For sequential composition, we have the following definition.


 t1
; t2) ΓL ΓT r =
/ ( t2) ΓL
ΓT ) ∗ ( t1) ΓL ΓT r )

Here, -∞
is the distributed concatenation of pfi lists. The operator ∗ is a mapping

function: (f ∗) s applies f to all elements of a pfi list s. Informally, we apply t2 to all cells obtained by applying t1, and flatten the resulting list of lists.
We omit a discussion of the semantics of the remaining tacticals and structural combinators [12]. Recursive tactics are defined using Kleene’s fixed-point theorem.
μ X • f (X ) =	{i : N • f i (abort)}
This requires a complete partial ordering on tactics with respect to which the tactic operators must be continuous. It is defined by t1 ±T t2 ≡ ∀ r : RCell • t1 r ±∞ t2 r where ±∞ is the generalised prefix ordering on infinite lists. Intuitively, if t1 is refined by t2 then t1 can at least produce as many outcomes as t2 if applied to some arbitrary program. Moreover, whenever t1 guarantees to terminate, t2 must also be guaranteed to terminate under the same conditions. The notion of equivalence and refinement of tactics provides opportunities for specifying and proving algebraic laws about the tactic language. In the context of our work, they additionally allow us to test the correctness of the implementation to be developed.

ProofPower and Standard ML
ProofPower is a mechanical theorem prover that resulted from a re-engineering of the

Cambridge HOL proof system. The latter is itself a descendant of LCF, and hence ProofPower shares various commonalities with the LCF prover; for example, it uses Standard ML (SML) as its implementation language and takes advantage of ML’s type system to ensure that theorems can be constructed only by means of logical inference, and hence must be valid. This level of assurance is achieved by introducing an abstract data type THM for proved theorems whose exposed constructor functions invariably correspond to valid inferences in the logic.
A design objective of ProofPower was to facilitate the semantic embedding of other languages. In particular, the Z language has been embedded and formalised, producing the ProofPower-Z package and dialect. It is in essence an extension of ProofPower that provides additional syntactic constructs, parsing facilities, rules, theorems and tactics specific to transforming and proving theorems about Z expres- sions. The open architecture and flexibility of ProofPower encouraged the develop- ment of several tools that promoted its use on industrial-scale projects [4,2].
Our implementation of ArcAngel integrates with ProofPower by supplying a database of additional SML constants and function definitions. Although much of it needs to use lower-level functions of ProofPower for dissecting syntactic ex- pressions, manipulating type information, and so on, none of this poses a risk in terms of soundness, neither can potential bugs lead to unsound inferences.
Standard ML is a strongly-typed, strict and impure functional language. It is a modern descendant of the ML programming language that was used in implementing the Edinburgh LCF proof system. Being impure it permits the use of global mutable data structures by means of reference types. A comprehensive account of the ML language and its facilities can be found in [15] and http://www.smlnj.org.
Fundamental Design
In this section we discuss some of the core features of the design integrating ArcAngel into ProofPower. We first explain how we encode tactics, secondly address some implementation issues of operator encodings, and lastly show how ArcAngel tactics are used together with the standard backward proof facilities of ProofPower.

Encoding of ArcAngel Tactics
As already hinted, encoding ArcAngel tactics directly by virtue of ProofPower tactics is problematic. First, ProofPower tactics do not exhibit backtracking behaviour, and secondly ProofPower tactics solve (or reduce) proof goals whereas ArcAngel tactics transform program expressions. To bridge this gap, we first introduce the notion of a reﬁnement theorem. It is a theorem of the form Γ ▶ A ± B , where Γ is a list of assumptions (provisos), and both A and B are program expressions. The operator
± is assumed to represent refinement in Morgan’s calculus. We later highlight that it may indeed be any reflexive and transitive relation.
Because refinement theorems are of central importance, we introduce a type ab- breviation REFTHM for them. In fact, REFTHM is equated with THM, but it allows us to indicate when functions expect or return refinement theorems, and we implicitly

assume that such theorems will always be of the correct shape.
ArcAngel tactics in ProofPower apply to refinement theorems rather than pro- gram expressions. Their application results in transformation of the second program of a refinement theorem. For example, if we have a tactic t which refines x := x + y into x := y + x , applying it to the theorem ▶ x : [x = x0 + y ] ± x := x + y yields the refinement theorem ▶ x : [x = x0 + y ] ± x := y + x .
In general, the successful application of a single law to a refinement theorem Γ1 ▶ A ± B delivers a theorem Γ1, Γ2 ▶ A ± B' where B' is a valid refinement of B under the additional provisos Γ2, which contribute to those of the resulting theorem. It is obtained by first matching the left-hand program of the refinement law against
B . This gives an instantiation Γ2 ▶ B ± B' of the law which, by transitivity of refinement, permits the prover to conclude Γ1, Γ2 ▶ A ± B'.
The above design unifies ArcAngel’s approach to program transformation with the design of ProofPower which is centred on theorem-generating functions. The application of an ArcAngel tactic to a program X can be simulated by first creating an initial refinement theorem ▶ X ± X that is trivially proved by reflexivity of refinement. To it, we apply the encoding of the ArcAngel tactic. If successful, it returns a theorem Γ ▶ X ± Y encapsulating the transformation of X to Y . The validity of the refinement is established by the soundness of primitive inferences of ProofPower’s core logic; for that reason it is independent of our actual implementa- tion of ArcAngel which merely drives the prover. This protection we do not get in an implementation of ArcAngel based on rewrite systems such as Gabriel [14], since in those the validity of rules and laws are not independently verified.

Nondeterminism and Inﬁnite Behaviours
To accommodate nondeterminism, which surfaces when the application of a tactic can produce more than one possible result, we have to keep track of all possible outcomes of tactic behaviours. For example, t1 | t2 can have two possible outcomes if both tactics are applicable to the program. In order to determine which execution path leads to success and realise backtracking, if necessary, we have to keep track of both outcomes. We therefore characterise tactics as functions mapping refinement theorems to lists of refinement theorems. This characterisation closely resembles the semantic model of ArcAngel presented in Section 2.1 that modelled tactics by functions mapping refinement cells to (infinite) lists of refinement cells.
This design is obviously suitable for tactics with finite behaviours, but extra care is required to cater for tactics that potentially generate an infinite number of outcomes, or otherwise fail to produce any result due to nontermination. To illustrate this case, consider the following recursive tactical.
EXHAUST(t ) = μ X • (t ; X ) | skip
It entails the possibility of applying t once, twice, or in fact an arbitrary number of times. If t repetitively shows to be applicable, the tactic has an infinite number of potential outcomes.  Operationally, this results in an infinite list p - t (p) - t 2(p) - t 3(p) ... to be computed when EXHAUST(t ) is applied to some program

p. From a computational point of view this evaluation cannot succeed, however EXHAUST(t ) is distinct from abort and its behaviour is perfectly well-defined as long as we are not attempting to utilise (evaluate) all outcomes.
A similar situation arises with ! (t | μ X • X ). The tactic μ X • X is equivalent to abort. On the other hand, if t does not fail, the behaviour of ! (t | μ X • X ) is determined by the first result delivered by t . The application of (t | μ X • X ) then relies on the result of applying only t eluding the abortive recursion.
We, therefore, adopt lazy evaluation when computing the outcomes of tactic applications. Specifically, we introduced a datatype lazylists that allows us to defer evaluation of tactics until we actually require their results. Since evaluation in SML is strict, lazy evaluation must be simulated by means of additional layers of functions with a spurious argument. For example, evaluation of t is deferred in (fn () => t p) until we apply the function to an empty tuple. (The construction (fn args => body ) is generally used in Standard ML for anonymous functions.)
In particular, lazylists, defined below, gives us explicit control over which elements have their evaluation deferred. As an extreme case, it also permits deferred evaluation of the entire list. This is important to represent ⊥.
datatype ’a lazylist = LazyNil | LazyAtom of ’a |
LazyJoin of (’a lazylist) * (’a lazylist) | LazyDefer of (unit -> ’a lazylist);
This datatype provides four constructor functions. LazyNil is used to construct empty lazy lists, LazyAtom to construct atomic (non-lazy) elements, LazyJoin to concatenate two lazy lists, and LazyDefer to explicitly defer evaluation. This list model, being a lazy variant of the join list model, was tailored to provide the flexibility and expressiveness to implement ArcAngel operators in a correct, concise, and efficient way, in particular, the tactic combinators for alternation and recursion. To support parametrised tactics and the applies to p do t operator, it is nec- essary to incorporate a special notion of environment that binds (meta)variables to
expressions. They are represented by a list of pairs of ProofPower terms, where the first component gives the variable, and the second component the bound expression. We introduce the type abbreviation ENV to represent the set of such lists.
To conclude, ArcAngel tactics are encoded by functions that map environments and refinement theorems to lazy lists of refinement theorems.
type AA_TACTIC = ENV -> (REF_THM -> REF_THM lazylist);
Environments are in most cases just propagated to the operands in tactic combi- nators; the exception is applies to p do t and law and tactic applications which need to process them. In the next section we will look at some issues related to the implementation of the ArcAngel operators.


Fig. 4. SML functions that encode ArcAngel operators.
Operator Implementation
Each operator of ArcAngel is implemented by a designated SML function. They are listed in Fig. 4. The structural combinators are omitted in this table as they can be added dynamically by virtue of a set of constructor functions.
The implementation of the literal tactics is very simple. TSkip returns a sin- gleton lazy list containing the program the tactic is applied to, TFail returns an empty lazy list, and TAbort raises an exception Abort that indicates abortion.
For law applications via TLaw the implementation essentially carries out the steps discussed in the previous section. It has to do a bit more work, however, to substitute meta-variables occurring free in the arguments, and move implications in the conclusion of the law theorem into the assumptions to make them provisos. For laws to be applicable, they first have to be declared using the TLawDecl function. It expects the name of the law, its formal arguments as a list of typed
terms, and the corresponding ProofPower theorem. Similarly, we declare a tactic
using the TTacDecl function and apply it using TTactic. The function TTacDecl
corresponds to the Tactic name(args) tbody end construct of ArcAngel.
The implementation of tacticals mirrors in most cases the respective semantic definitions. For example, SML implementation of TSeq is as follows.
fun (t1 : AA_TACTIC) TSeq (t2 : AA_TACTIC) : AA_TACTIC =
(fn env : ENV => (fn p : REF_THM =>
(lazyflat (lazymap (t2 env) (t1 env p)))));

It is a direct literal translation of the semantics where -∞
is encoded by lazyflat,

and ∗ is encoded by lazymap. These two SML functions perform operations on lazy lists similar to the semantic functions on infinite lists. Both functions are implemented in a way that defers evaluation until an element is requested.
A further interesting function is TRec, which implements the ArcAngel recursion construct, and whose implementation is given below.

fun TRec (tfun : AA_TACTIC -> AA_TACTIC) : AA_TACTIC =
(let val rec (trec : AA_TACTIC) = (fn env => (fn p =>
(defer_tac_eval (tfun trec) env p))) in trec
end);
The tfun argument provides the body of the recursion: a function on ArcAngel tactics. The local constant trec is introduced as a recursively-defined value which is used to determine the result of TRec. In defining trec it is vital that the recursive unfolding takes place incrementally and application of the tactic to the goal is deferred in each step. This is achieved by the function defertaceval which defers the application of one unfolding (tfun trec) to the program p.
fun defer_tac_eval (t : AA_TACTIC) (env : ENV) (p : REF_THM) = LazyDefer (fn () => t env p);
This function takes advantage of the lazy list constructor LazyDefer to create a deferred list, suppressing the application of t to the environment and program.
In the next section we will clarify the integration of ArcAngel tactics with Proof- Power’s subgoal package providing the facilities for backward proofs.

Backward Proofs
The embedding of ArcAngel was developed outside the subgoal package of Proof- Power. We can, however, support the use of ArcAngel tactics to facilitate the proof of refinement conjectures in a backward manner. This makes ArcAngel available to support development of programs correct by construction and verification of pro- posed refinements. For example, a proof goal of the form A ± B can be discharged by an ArcAngel tactic that is able to transform A into B while possibly generating some provisos which contribute to the subgoals of the proof. Alternatively, if the tactic cannot discharge the goal in one step, it may still be able to reduce it to some intermediate refinement which may be discharged with less effort.
In order to invoke ArcAngel tactics within backward proofs, we provide a function (aatac atac) that lifts an ArcAngel tactic atac into a corresponding ProofPower tactic. The behaviour of the ProofPower tactic for a proof goal of the form A ± B is as follows. First, the ArcAngel tactic is applied to the first program of the refinement conjecture. If the application of the ArcAngel tactics fails, this also results in failure of the wrapping ProofPower tactic. Otherwise we take the first element of the list of generated refinement theorems; it will always be of the form Γ ▶ A ± A'.
By adding the provisos Γ as subgoals to the current proof tree, we can justify the addition of A ± A' to the goal hypotheses. ProofPower’s default asmtac achieves this for assumptionless theorems, and we have a more general version that also handles assumptions. The additional hypothesis either immediately discharges the goal if A' = B , or can be used to reduce the goal to A' ± B . This is justified by transitivity of refinement since A ± A' and A' ± B imply the initial goal A ± B . The low-level steps of this reduction are automatically carried out by aatac.

We also provide an alternative implementation (aasolvetac atac) that eval- uates all outcomes of tactic applications to A, and selects one that discharges the goal or otherwise fails if none exists. Such a behaviour is faithful to the angelic interpretation of nondeterminism at the top level since the notion of success is clearly defined here as discharging the proof goal. This is also compatible with the mechanics of Angel which explores all possible paths of tactic executions.
In the next section we illustrate our implementation using takeConjAsInv .

Tactic Example
The tactic takeConjAsInv was presented in Fig. 2 in Section 2.1.1. It invokes four laws, strPost, seqComp, assign and iter. Each law is first formulated as a ProofPower- Z theorem, and afterwards declared and registered using the TLawDecl function. For example, the law strPost (see Fig. 3) is formalised by the theorem
▶ ∀ u : MORGAN UNIVERSE ; f : seq M VARNAME ;
preC : MORGAN CONDITION ; postC , postC ' : MORGAN POSTCOND |
(u, f , preC , postC ) ∈ WF SpecStmtM ∧
(u, f , preC , postC ') ∈ WF SpecStmtM ∧ Tautology (postC ' ⇒P postC ) •
SpecStmtM (u, f , preC , postC ) ± SpecStmtM (u, f , preC , postC ')


The law is specified in the context of a semantic encoding of Morgan’s calculus based on a mechanisation of the Unifying Theories of Programming (UTP), tailored for ProofPower-Z [13,17]. That mechanisation, and within it the semantic characteri- sation of Morgan’s calculus, is for space considerations not discussed in detail. The
functions SpecStmtM and ⇒P encode the specification statement and the implication operator, and Tautology determines whether a given predicate is universally true. We also have semantic sets used as types: MORGAN UNIVERSE contains all valid type constraints on the variables (universes), M VARNAME the set of permis- sible frame variables, and MORGAN CONDITION and MORGAN POSTCOND
the semantic domain for the pre and postconditions of a specification statement; the latter two are restricted forms of predicates. Lastly, the set WF SpecStmtM encapsulates well-definedness constraints for applying the SpecStmtM function.
The quantified variables u, f , preC and postC of the theorem are matched against the program when the law is instantiated. As already explained, the program is obtained as the right-hand side of the refinement conjecture to which the law is applied, and the matching is needed to instantiate the law so that its left-hand side equals the program to be refined. The variable postC ', on the contrary, is a parameter of the law. It is not matched but substituted by the actual argument when the law is invoked through TLaw with a specific list of arguments.
The antecedents of the law establish well-formedness constraints as well as the provisos of the law. The former here ensure that SpecStmtM (u, f , preC , postC ) and SpecStmtM (u, f , preC , postC ') are well-defined expressions in the semantic model. The only genuine proviso is Tautology (postC ' ⇒P postC ). The theorem thus is a

faithful encoding of the abstractly specified law.
The law is configured to be used by the implementation with the following command which identifies its formal parameters.
TLawDecl "strPost" [ postC ' ⊕ ALPHA PREDICATE ’ ] strPost_thm;
Z	⊕
We assume that the SML constant strPost_thm has been initialised to hold the law theorem. The first argument "strPost" specifies the name of the declared law in ArcAngel, and the second argument supplies the list of quantified variables used as parameters. The variables are given as (ProofPower) variable terms whose type must
be explicitly specified by virtue of the ‘⊕ ’ operator. The presence of type information in formal arguments is exploited to inject possibly missing type information into the actual arguments when the law is applied; this makes the application of laws altogether more robust since a lack of type information in arguments might cause technical problems, like argument substitution to fail because of a discrepancy in types between substituting and substituted terms. It also allows for run-time type checks on parameters when the law is invoked.
Our implementation supports law theorems that are either given in pure HOL or the Z sub-language of ProofPower-Z. It also permits laws to have free variables (which are just treated as quantified ones, so that the outer universal quantification is optional), and finally enables the law theorems to contain provisos and assump- tions. A general form for a law theorem is thus
Γ ▶ ∀ v1 : Tn ; v2 : Tn ; ... | p1 ∧ p2 ∧ ... • q1 ∧ q2 ∧ ... ⇒ A ± B
where Γ as well as the pi and qi collectively contribute as assumptions of the law. The responsibility of proving theorems for laws resides with the user, and the proofs are formally justified within our semantic model of the Morgan calculus.
We omit the encoding of the remaining laws seqComp, assign and iter. The encoding of the iter law (see Fig. 3) is challenging as it is parametrised by a sequence
of guarded commands, and the implementation in its present form can only support individual instances of this law with a fixed number of guarded commands.
We now declare the compound tactic whose body invokes the four laws.
TTacDecl "takeConjAsInv" [
⊕	⊕
Z invBound ⊕ ALPHA PREDICATE ’ , Z lstVar ⊕ seq M VAR NAME ’ ,
⊕	⊕
 Z lstVal ⊕ seq EXPRESSION ’ , Z variantExp ⊕ EXPRESSION ’ ] ( 
TAppliesTo Z SpecStmt M (u, w, preC , invConj ∧P (¬P guard ))’ TDo ( (TLaw "strPost" [Z (invBound ∧P invConj ) ∧P (¬P guard )’ ]) TSeq (TLaw "seqComp" [ Z invBound ∧P invConj ’ ]) TSeq
((TLaw "assign" [Z lstVar ’ , Z lstVal ’ ])
TSCSeq (TLaw "iter_unary" [ Z variantExp ’ ]))));
As with law declarations, tactic declarations have to provide a name for the tactic and a list of terms for the formal arguments, each being a variable with fully-qualified type information. The third argument specifies the body of the tactic. The transla- tion that encodes the tactic is very direct, simply replacing ArcAngel operators and structural combinators by their corresponding ML functions. Fig. 4 may be used as a reference here, and a similar list of functions exists for the structural combinators

of ArcAngel. For instance, TSCSeq encodes the structural combinator for sequential composition as an infix operator on tactics.
Variables introduced in a tactic declaration via TTacDecl or the TAppliesTo construct become local and can be used in its body. For example, the local variable invBound is introduced by the tactic declaration, and used in specifying the argu- ments for the law applications of strPost and seqComp. To illustrate the application of the tactic, we first create a program that encodes the specification statement
q, r : [a ≥ 0 ∧ b > 0, a = q ∗ b + r ∧¬ r ≥ b]
It calculates the quotient and remainder of two positive numbers a and b; they are respectively recorded in the variables q and r . Its encoding in the semantic model is slightly tedious, but inherently not difficult. We associate it to a constant prog. We apply the tactic takeConjAsInv now to the above program. For this pur- pose, we use the function aa_rule. It expects an ArcAngel tactic and a program expression, and automatically creates an initial refinement theorem ▶ P ± P to
which it applies the tactic. Here, all this takes place outside the subgoal package of ProofPower, although, as we explained in Section 3.3, ArcAngel tactics may also be directly used within the standard backward proof engine.
aa_rule (TTactic "takeConjAsInv"
[Z TrueP u ’ , Z ⟨q, r⟩’ , Z ⟨Val (Int (0)), Var (a)⟩’ , Z Var (r )’ ]) prog
Analogous to TLaw, TTactic supports the application of a declared tactic. The parameters given are TrueP u for invBound , ⟨q, r⟩ for lstVar , ⟨Val (Int (0)), Var (a)⟩ for lstVal , and Var (r ) for variantExp. The invBound parameter is used to provide an additional predicate to strengthen the invariant, for example to encapsulate some boundary conditions on indexed variables. It is not relevant here, hence set to be true. The lstVar and lstVal parameters determine how the variables altered by the loop are to be initialised. Here we want to carry out the initialisation q, r := a, 0 before entering the loop. Further, variantExp provides a variant. The result of the tactic application is the following refinement theorem, which we obtained as a result of applying the tactic in ProofPower-Z and type-setting the output.
... ▶
SpecStmtM (u, ⟨q, r⟩, RelP (u, ( ≥V ), Var a, Val (Int 0)) ∧P RelP (u, ( >V  ), Var b, Val (Int 0)),
(=P (u, Var (dash a), Fun2(( +V ), Fun2(( ∗V ), Var q, Var b), Var r )) ∧P
RelP (u, ( ≤V ), Val (Int 0), Var r )) ∧P ¬P (RelP (u, ( ≥V ), Var r, Var b)))
±
AssignM (u, ⟨q, r⟩, ⟨Val (Int 0), Var a⟩) ;M
doM (⟨RelP (u, ( ≥V  ), Var r, Var b)⟩,
⟨SpecStmtM (u, ⟨q, r⟩,
(TrueP u ∧P =P (u, Var (dash a), Fun2(( +V ), Fun2(( ∗V ), Var q, Var b), Var r )) ∧P
RelP (u, ( ≤V ), Val (Int 0), Var r )) ∧P RelP (u, ( ≥V ), Var r, Var b),
(TrueP u ∧P =P (u, Var (dash a), Fun2(( +V ), Fun2(( ∗V ), Var q, Var b), Var r )) ∧P
RelP (u, ( ≤V ), Val (Int 0), Var r )) ∧P RelP (u, ( ≤V ), Val (Int 0), Var r ) ∧P
RelP (u, ( <V  ), Var r, SubstE (Var r, zero))⟩) odM

The above theorem encodes the program refinement
q, r : [a ≥ 0 ∧ b > 0, a = q ∗ b + r ∧¬ r ≥ b]
±

q, r := 0, a ;
do r	b	q r :	a = q ∗ b + r ∧ 0 ≤ r ∧ r ≥ b,
a = q ∗ b + r ∧ 0 ≤ r ∧ r ≥ b ∧ r ≤ r0

  od

For readability, the assumptions of the theorem have been omitted. Most of them carry constraints regarding the well-definedness of operator applications which were accumulated through application of the laws and monotonicity theorems. In prac- tice, we anticipate that most of these assumptions are provable automatically with- out any user intervention. The remaining assumptions encapsulate the provisos of the laws. For example, we find the following assumption encoding the first proof obligation of the law, that is, the provisos of the strPost law.
Tautology(((TrueP u ∧P =P (u, Var (dash a), Fun2(( +V ), Fun2(( ∗V ), Var q, Var b), Var r ))
∧P RelP (u, ( ≤V ), Val (Int 0), Var r )) ∧ ¬ (RelP (u, ( ≤V ), Var r, Var b)))
⇒P (=P (u, Var (dash a), Fun2(( +V ), Fun2(( ∗V ), Var q, Var b), Var r )) ∧P
RelP (u, ( ≤V ), Val (Int 0), Var r )) ∧P ¬ (RelP (u, ( ≥V ), Var r, Var b)))
The proof of provisos like the above is expected in most cases to require hu- man interaction and knowledge, although automation for restricted domains of application has been successful even in industry [1]. Here we have to show that true ∧ a' = q ∗ b + r ∧ 0 ≤ r ∧ ¬ r ≤ b ⇒ a' = q ∗ b + r ∧ 0 ≤ r ∧ ¬ r ≥ b. This can be trivially proved by using true ∧ P ⇒ P ≡ true.
When applying ArcAngel tactics outside the subgoal package of ProofPower as above, tactic applications usually increase the number of assumptions of the gen- erated refinement theorem. In backward proofs we use the refinement theorem to simplify a refinement goal, and in this case the assumptions contribute as addi- tional subgoals of the proof and need to be discharged separately. Fortunately, ProofPower offers a lot of flexibility in implementing programming utilities and tac- tics to automate proofs, and for this purpose we have already developed a collection of specialised (ProofPower) tactics that can automatically discharge most of the well-definedness constraints encountered so far so that the only real proof effort that has to be invested is in discharging the provisos of the laws.
We applied the takeConjAsInv tactic to several other examples to calculate the product, exponentiation and factorial. The corresponding source code for the ex- amples, including the semantic embedding of Morgan’s refinement calculus, can be found at http://www.cs.york.ac.uk/circus/tp/tools.html. The tactic was originally used as an example in [14] and [11], and we did in fact encode the other tactics given in those publications too.
Conclusions
In this paper we have presented an implementation of the ArcAngel tactic language for the ProofPower theorem prover. We discussed several aspects of the implementa-

tion as well as decisions made in its design, and illustrated it by virtue of an example. Notably, we managed to realise a very direct translation of the ArcAngel semantics in which refinement cells in the semantic model are identified with refinement theo- rems in the implementation model. A faithful representation of partial and infinite lists was achieved through the use of lazy evaluation, and recursive ArcAngel tac- tics are directly supported through recursive ML functions on tactics. Hence, the encoding of particular tactics is mostly trivial and amenable to automation.
To verify that the design correctly reflects the semantics of ArcAngel, we con- ducted a series of tests in which we verified (in specific pathological cases) that tactics which can be proved equal in the semantics also exhibit similar behaviours in the implementation. This provided some empirical evidence for the correctness of the implementation and indeed revealed deficiencies in earlier designs, which have been gradually refined to culminate into the one presented in this paper.
The implementation has suggested several extensions and generalisation that due to space limitations could not be discussed in the paper. A first extension we realised is to simultaneously deal with the proof of equivalences and genuine refinements in the application of ArcAngel tactics. Conceptually, ArcAngel is oblivious to the interpretation of the underlying refinement relation — it is at core a method for transforming programs. In ProofPower, the application of ArcAngel tactics results in the generation of refinement theorems, making the refinement relation explicit. This offers the possibility to deal with various kinds of relations at once, namely A ± B and A ≡ B . This feature was implemented as to always generate the strongest theorem that can be asserted based on the shape of the applied laws.
A second extension ventured a step further by isolating the program model from the core implementation of ArcAngel and thereby making it dynamically config- urable. We hereby unified the application of ArcAngel tactics to various kinds of objects (not just Morgan computations) by identifying what the minimal require- ments are for the equivalence and refinement relations necessary for the mechanics of the implementation to work. In particular, the essence of an ArcAngel model can be captured in a small number of theorems about the equivalence and refinement relations whilst their actual definitions and types are irrelevant. Factoring out the program model retains ArcAngel’s flexibility as a general method for transforming terms, and provides future opportunities for the implementation to be applied in different scenarios. It also constitutes a unification with ArcAngelC [11] and in parts with Angel as both can be obtained as derivatives by means of suitable models.
A third extension that we provided addresses the problem of nontermination in tactics. Tactics that get trapped in a nonterminating loop are not uncommon in theorem provers, for example, if repetitive rewrites of expressions continually suc- ceed. In our implementation it is possible to concisely deal with nontermination because the only point where it may occur is in recursive tactics. We do this by imposing a limit on the number of recursive calls, and give a semantic interpreta- tion of bounded recursion in terms of an approximation to the exact meaning of the recursive tactic as a fixed point respective to the refinement ordering on tactics. Although the bounded recursive tactic ‘loses’ some behaviour of the respective un-

bounded one, in practice the limit on the recursive calls may be set to a sufficiently high value to justify the use of the former in place of the latter.
Related work apart from REFINE and Gabriel is the implementation of Angel in
Ergo [16,9], a theorem prover developed in Prolog. A major difference between Ergo and ProofPower is that Ergo does not have a core object logic, whereas ProofPower is based upon a formalisation of HOL logic. The implementation of Angel in Ergo
is more general in that it allows tactics to be applied not just to single goals, but sequences of goals that in turn may result from the application of tactics. This in particular would be an interesting extension to our implementation as it might allow us to define tactics that specify how provisos should be handled in the generation
of refinement theorems. For example, they could in some cases be further subject to proof through application of (Arc)Angel tactics.
Future work first consists of enhancing and extending the implementation. An issue that has been pointed out in the previous section relates to specifying the iter law in its general form. To do so, we require certain pre and post-processing steps in the application of the law, namely to rewrite instantiated theorems to carry out possible syntactic operations in processing the law application. ProofPower’s conversion mechanism may be conveniently used for that.
A second crucial area of improvement is the handling of provisos generated by tactic applications. These can amount to a considerable number of assumptions which all need to be proved when the generated refinement theorem is used, for example, as part of some standard backward proof. To reduce these assumptions, a number of approaches may be considered. First, we may try to prove them in-line using specialised tactics. Additionally, rules may be specified that compress the assumptions of refinement theorems by attempting to prove individual assumptions from the residual ones, and using the cut rule to eliminate them. Features in the interface are required to first identify which provisos should be proved in-line, and secondly what ProofPower or even ArcAngel tactic should be used to discharge them.
A final area for future work is the development of case studies for realistic ap- plications. Here, we anticipate to formulate the refinement strategy for control laws presented in [3] as a collection of ArcAngel tactics and thereby automate the application of the refinement strategy to arbitrary and sizable examples.

Acknowledgement
We are grateful to Matthew Naylor for suggestions regarding the use of lazy lists. We also acknowledge EPSRC for funding this work under the ‘Programming from Con- trol Laws’ research grant EP/E025366/1. INES and CNPq partially supports the work of Marcel Oliveira: grants 550946/2007-1, 620132/2008-6, and 573964/2008-4.

References
Adams, M. and P. Clayton, ClawZ: Cost-Effective Formal Verification of Control Systems, in: Formal Methods and Software Engineering, Lecture Notes in Computer Science 3785 (2005), pp. 465–479.

Arthan, R., P. Caseley, C. O’Halloran and A. Smith, ClawZ: Control laws in Z, in: 3rd International Conference on Formal Engineering Methods (2000), pp. 169–176.
Cavalcanti, A., From Control Laws to Ada via Circus, Technical report, University of York, York, YO10 5DD, UK (2008), available from http://www.cs.york.ac.uk/ftpdir/reports/2008/YCS/428/ YCS-2008-428.pdf.
Clayton, P. and C. O’Halloran, Using the Compliance Notation in Industry, in: Refinement Techniques in Software Engineering, Lecture Notes in Computer Science 3167 (2006), pp. 269–314.
Kirchner, F. and C. Mun˜oz, PVS#: Streamlined Tacticals for PVS, Electronic Notes in Theoretical Computer Science 174 (2007), pp. 47–58.
Martin, A., “Machine-Assisted Theorem Proving for Software Engineering,” Ph.D. thesis, Oxford, UK (1994), technical Monograph PRG-121.
Martin, A., Infinite Lists for Specifying Functional Programs in Z, in: Proceedings of Fifth Australasian Refinement Workshop (1996).
Martin, A., P. Gardiner and J. Woodcock, A Tactical Calculus – Abridged Version, Formal Aspects of Computing 8 (1996), pp. 479–489.
Martin, A., R. Nickson and M. Utting, A Tactic Language for Ergo, in: Formal Methods – Pacific 97, Discrete Mathematics and Theoretical Computer Science, 1997, pp. 186–207.
Morgan, C., “Programming from Specifications,” Prentice Hall International Series in Computer Science, Prentice Hall, 1998.
Oliveira, M. and A. Cavalcanti, ArcAngelC: a Refinement Tactic Language for Circus, Electronic Notes in Theoretical Computer Science 214 (2008), pp. 203–229.
Oliveira, M., A. Cavalcanti and J. Woodcock, ArcAngel: a Tactic Language for Refinement, Formal Aspects of Computing 15 (2003), pp. 28–47.
Oliveira, M., A. Cavalcanti and J. Woodcock, Unifying Theories in ProofPower-Z, in: Unifying Theories of Programming, First International Symposium, Lecture Notes in Computer Science 4010 (2006), pp. 123–140.
Oliveira, M., M. Xavier and A. Cavalcanti, Refine and Gabriel: Support for Refinement and Tactics, in: Proceedings of the Second International Conference on Software Engineering and Formal Methods (2004), pp. 310–319.
Paulson, L. C., “ML for the Working Programmer, 2nd Edition,” Cambridge University Press, 1996.
Utting, M. and K. Whitwell, Ergo User Manual – An Interactive Theorem Prover (1994).
Zeyda, F. and A. Cavalcanti, Mechanical Reasoning about Families of UTP Theories, in: SBMF 2008, Brazilian Symposium on Formal Methods, 2008, pp. 145–160.
