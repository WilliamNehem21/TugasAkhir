Electronic Notes in Theoretical Computer Science 44 No. 4 (2001)
URL: http://www.elsevier.nl/locate/entcs/volume44.html 15 pages


GRACE as a unifying approach to graph-transformation-based specification *

Hans-J¨org Kreowski, Giorgio Busatto, Sabine Kuske
University of Bremen 1

Abstract
In this paper, we sketch some basic ideas and features of the graph-transformation- based specification language GRACE. The aim of GRACE is to support the model- ing of a wide spectrum of graph and graphical processes in a structured and uniform way including visualization and verification.


Introduction
Eventually, GRACE will be the acronym of a GRAph and rule CEntered specification language. Meanwhile, it is rather naming a creative process that is going on for some years and involves a varying number of researchers from Berlin, Bremen, Erlangen, Mu¨nchen, Oldenburg, and Paderborn. At several working meetings, various aspects of graph transformation have been discussed like structuring, hierarchical graph models, object orientation, tool support, and graph exchange formats. The aims of these meetings have been to develop graph transformation as a methodology for the modeling and the specification of data-processing systems and to identify the necessary means to make graph transformation more visible in the applied areas of computer science. The outcome of the GRACE process consists so far of some papers which are more or less influenced by the discussed ideas and a part of which refers explicitly to GRACE (see, e.g., [10], [17], [11], [21], [16], [1], [8], [12], [13], [2], [4], [9],
[14], [15], [18]).
In this paper, we introduce and survey GRACE as a unifying approach to graph-transformation-based specification with emphasis on uniform modeling of graphical processes. In particular, the following fundamentals are discussed:
approach independence,

 This work was partially supported by the ESPRIT Working Group Applications of Graph Transformation (APPLIGRAPH) and the EC TMR Network GETGRATS (General Theory of Graph Transformation Systems).
1 E-mail: {kreo, giorgio, kuske}@informatik.uni-bremen.de
◯c 2001 Published by Elsevier Science B. V. Open access under CC BY-NC-ND license.


transformation units,
modularization,
visualization and animation,
verification.
To show the usefulness of the GRACE concepts for handling graphical processes, we illustrate our considerations by Petri nets, finite state automata and several graph processing examples. In particular, we introduce new con- cepts for the transformation of graphs of different types into each other.

Approach Independence
In contrast to strings and trees, graphs are quite generic structures which are used in dozens of variants, types, and modes. Accordingly, one encounters quite a spectrum of competing graph transformation approaches in the liter- ature (see, e.g., the three volumes of the Handbook on Graph Grammars and Computing by Graph Transformation [20], [5], [6]). While those familiar with graph transformation may appreciate the flexibility of graph notions and the wide range of choices to deal with them, others who want to use graph trans- formation for the first time may get confused easily. Approach independence is intended to avoid such a trouble by considering graph transformation as a uniform framework. This is achieved by the abstract and kind of axiomatic notion of a graph transformation approach that can be instantiated however it may be appropriate. A graph transformation approach provides a class of graphs, a class of rules, and a rule application operator specifying how a graph is directly derived from a graph by applying a rule. Since a rule defines a binary relation on graphs, a set of rules specifies a derivation relation as the reflexive and transitive closure of the union of the rule application rela- tions. Moreover, a graph transformation approach provides means to restrict the nondeterminism of rule applications and their iteration. To illustrate the concepts, we consider Petri nets, finite state automata, hierarchical graphs and others.

Graph Transformation Approach
A graph transformation approach provides the basic ingredients of a GRACE program, namely graphs, rules, a rule application operator, graph class expres- sions, and control conditions. More formally, a graph transformation approach consists of a class G of graphs, a class R of rules, a rule application operator
⇒ yielding a binary relation ⇒r ⊆ G × G for every r ∈ R, a class E of graph class expressions such that every e ∈ E specifies a subclass SEM(e) ⊆ G, and a class C of control conditions such that each c ∈ C specifies a binary relation SEM(c) ⊆ G × G.
Examples for graph classes are labeled directed graphs, hypergraphs, trees,

forests, finite automata, Petri nets, etc. Rule classes may vary from the more restrictive ones, like edge or node replacement to the more general ones as double pushout rules, single pushout rules, or PROGRES rules. In general,
the rule application operator ⇒ describes how the rules in R are applied to the graphs in G.
The control conditions are used to regulate the derivation process. They
determine, for example, the order in which rules may be applied. The aim of graph class expressions is to restrict the set of graphs to which certain rules may be applied or to filter out a subset of all the graphs that can be derived by a set of rules. Typically, a graph class expression may be some logic formula describing a graph property like connectivity, or acyclicity, or the occurrence or absence of certain node or edge labels.
Confer 2.4 to see how the components of a graph transformation approach are used.

Petri Nets
The usual firing of a transition in a place/transition net may be seen as a rule application. In this way, one gets a graph transformation approach PT that provides the basic elements of Petri nets. The class of graphs of PT consists of all marked place/transition nets N = (S, T, F, m) where S is the set of places, T is the set of transitions, F ⊆ S × T ∪ T × S is the flow relation and m : S −→ N is a marking. The class of rules consists of all transitions. And such a rule t can be applied to a net N = (S, T, F, m) if t ∈ T and all input places of t carry tokens, i.e. m(s) ≥ 1 for all s ∈ •t, or •t ≤ m for short. The resulting net differs from N only in the marking. The new marking is obtained by removing a token from each input place of t and adding a token to each output place, i.e. m − •t + t• as usual for place/transition nets. Figure 1 shows the firing of a transition, where the rule application is denoted by [ > rather than ⇒.




Fig. 1. Petri net: Firing t2.

Similarly, one may choose multisets of transitions as rules yielding the graph transformation approach PT +. Again this is illustrated by an example (see Figure 2).

See 3.2 for the graph class and control conditions in the context of Petri nets.




Fig. 2. Petri net: Firing 2t2 + t3.


Finite State Automata
The recognition process of finite state automata is based on state transitions while reading input symbols. Such basic steps can be seen as rule applications of the graph transformation approach FSA.
The class of graphs of FSA consists of pairs of input strings and state graphs. An input string may be represented by a string graph of the form
depicted in Figure 3.


read	a1	a2
... 
an	end

	


Fig. 3. A string graph.

where a1 ··· an is the represented string and read and end are extra labels to mark the ends of a string. A state graph is an edge-labeled directed graph where each a-labeled edge represents a transition from the source node to
the target node with input a. Moreover, there are an edge labeled with init, another labeled with actual, and some edges labeled with ﬁn indicating the initial state, the actual state and the final states respectively. An FSA graph is depicted in Figure 4.
In Figure 5, an FSA rule is depicted. It can be applied to an FSA graph wherever the left-hand side occurs as subgraph. The application consumes the first input symbol and resets the actual state from the source to the target of the transition. The application of the rule with x = c to the graph above is
depicted in Figure 6.
See 3.3 for the graph class and control conditions used in the context of finite state automata.



read	c	a	b	a	end

Fig. 4. An FSA graph.



read	x



::=



Fig. 5. An FSA rule.
read




read	c	a	b	a	end	read	a	b	a	end


=⇒


Fig. 6. Application of the rule with x = c.
Graph Processing
Given a graph transformation approach, one can derive graphs from graphs by the repeated application of rules where all processed graphs stem from the same class. But how can graph problems be handled which involve graphs of different types like the transformation of directed graphs into undirected ones or of hypergraphs into bipartite graphs? Graph transformations like these occur often in connection with the reduction of some graph problem

into another graph problem like a connectivity test for directed graphs that can be reduced to a connectivity test for undirected graphs.
The problem of transforming graphs of different types into each other can be solved by combining two graph transformation approaches in such a way that the resulting approach covers the given approaches suitably. An explicit construction of this kind works as follows.
Let Ai = (Gi, Ri, =⇒, Ei, Ci) for i = 1, 2 be two graph transformation approaches such that any graph G ∈ Gi is provided with a set of distinguished items XG, which may be the set of nodes, the set of edges, a particular subset of the set of nodes or edges or whatever. Analogously, we assume that each rule r ∈ Ri is also provided with such a set Xr and that each rule application G ⇒r G' is associated with an occurrence map f : Xr → XG.
Then one can couple A1 an A2 into a new graph transformation approach A1 ⊗ A2 which restricts the Cartesian product of A1 and A2 to those pairs of graphs and pairs of rules with equal distinguished items and to those rule applications that use the same occurrence map and keep the distinguished items invariant.
A1 ⊗ A2 = (G1 ⊗ G2, R1 ⊗ R2, =⇒, E1 × E2, C1 × C2)
with
G1 ⊗ G2 = {(G1, G2) ∈ G1 × G2 | XG1 = XG2 },
R1 ⊗ R2 = {(r1, r2) ∈ R1 × R2 | Xr1 = Xr2 },
(G1, G2) =⇒ (G' , G' ) for (G1, G2), (G' , G' ) ∈ G1 ⊗ G2, (r1, r2) ∈ R1 ⊗ R2
(r1,r2)	1	2	1	2

provided that Gi =⇒ G', XG	= XG'
for i = 1, 2, and f1 = f2 for the

r1	i	i	i
corresponding occurrence maps.
SEM (e1, e2)= SEM (e1) × SEM (e2) ∩ G1 ⊗ G2 for (e1, e2) ∈ E1 × E2,
((G1, G2), (G' , G' )) ∈ SEM (c1, c2) iff (G1, G2), (G' , G' ) ∈ G1 ⊗ G2 and
1	2	1	2
(Gi, G') ∈ SEM (ci) for ci ∈ Ci and i = 1, 2.
If each set X of distinguished items is associated with two particular graphs graphi(X) ∈ Gi for i = 1, 2 with Xgraphi(X) = X, then one can identify every graph G1 ∈ G1 with (G1, graph2(XG1 )) and G2 ∈ G2 with (graph1(XG2 ), G2). In this sense, we have G1 ∪ G2 ⊆ G1 ⊗ G2. Moreover, we may use G1 and G2 as extra graph class expressions with SEM (Gi)= Gi for i = 1, 2 (cf. 3.4), i.e. that we use the names of the graph classes to refer to them in the coupled approach where they are subclasses of the class of coupled graphs. To avoid confusion between the classes of graphs and their names, one may use other suitable identifiers that G1 and G2.
A typical example of such a coupling is given by approaches Adir and Aundir with classes of directed graphs, Gdir , and of undirected graphs, Gundir , respec- tively, where the sets of nodes are considered as distinguished, i.e. XG = VG for G ∈ Gdir ∪ Gundir . To simplify the technicalities, we restrict our consideration

to simple graphs meaning that the set of edges EG of G ∈ Gdir is a subset of VG × VG and the set of edges EG of G ∈ Gundir is a subset of the 1-element sub- sets and the 2-elements subsets of VG. Moreover, we consider only rules of the form r = (L ::= R) where L and R are graphs with Xr = VL = VR. Given an occurrence map f : Xr → XG, the application of r to G yields the graph G' with VG' = VG and EG' = (EG − f (EL)) ∪ f (ER). Here the image of a set of edges is defined by mapping the nodes of each edge. This definition applies to directed and undirected graphs as well. Accordingly, (G1, G2) ∈ Gdir ⊗ Gundir is a pair of a directed and an undirected graph with the same set of nodes. As the rule applications are only allowed if the distinguished items are kept invariant, only the sets of edges are rewritten. Moreover, if a graph – directed or undirected – is paired with its set of nodes considered as discrete graph with empty set of edges, the class of directed graphs as well as the class of undirected graphs can be considered as subclasses of the class of coupled graphs. Accordingly, we will use the terms directed graphs and undirected graphs as graph class expressions. The first expression specifies all pairs (G, G') ∈ Gdir ⊗ Gundir such that G' is a discrete graph whereas SEM (undirectedgraphs) contains all pairs (G, G') ∈ Gdir ⊗ Gundir such that G is a discrete graph. Additionally, we will use one particular control condition, which will be explained in Section 4. The discussion of this approach is continued in 3.4.
Hierarchical Graphs
Using a similar coupling mechanism, we have introduced a framework for hierarchical graphs in [3]. Graphs with distinguished sets of nodes from an arbitrary graph are combined with acyclic graphs and bipartite connection graphs. A connection graph relates the distinguished set of nodes with the nodes of the acyclic graph and imposes a hierarchy on the graph in this way.

Transformation Units
Transformation units are the main syntactic entities of GRACE that allow to specify binary relations on graphs. They consist of rules, input, output and control conditions as well as of import components. Semantically, such a transformation unit imports binary relations on graphs which are interleaved with the rule applications such that input, output and control conditions are obeyed. In this way, a transformation unit encapsulates a computational process. And since it specifies a binary relation on graphs, it can be imported by other transformation units such that the concept supports structuring in a simple, but effective way. Based on the graph transformation approach PT of
2.2, each place/transition net with an initial marking defines a transformation
unit the semantic relation of which comprises all reachable markings. Given the graph transformation approach FSA of 2.3, each finite state automaton defines a transformation unit the semantic relation of which describes the recognized language.

Moreover, we illustrate the use of the coupling mechanism as introduced in 2.4.
Syntax and Semantics of Transformation Units
Let A = (G, R, =⇒, E , C) be a graph transformation approach.
A transformation unit (over A) is a system tu = (I, U, P, C, T ) where I and T are graph class expressions, U is a set of identifiers, P is a set of rules, and C is a control conditions.
The elements of SEM (I) are called initial graphs, and the elements of SEM (T ) terminal graphs respectively. U is the import component of tu which is also called use component.
Let SEM (t) ⊆ G × G be some binary relation on graphs for each t ∈ U and SEM (U ) the union of these relations. Then the interleaving semantics SEM (tu) of tu is defined by
(=⇒ ∪ SEM (U ))∗ ∩ SEM (I) × SEM (T ) ∩ SEM (C)
P
i.e. initial and terminal graphs are related by interleaving rule applications and calls of imported relations while the control condition is obeyed.
Petri Nets as Transformation Units
Consider the graph transformation approach PT of place/transition nets, and let N = (S, T, F, m) be a marked net. Then N induces a transformation unit tu(N )= (N, ∅, T, true, all ) where N as a graph class expression specifies itself, i.e. SEM (N ) = {N }, and the transitions of N are available as rules. Moreover, nothing is imported, there is no extra control, and all marked nets are considered as terminal. Therefore, the semantics is given by all firing sequences which start in the initial marking such that the semantic relation of tu(N ) corresponds to the set of reachable markings.

Finite State Automata as Transformation Units
Consider the graph transformation approach FSA, and let A be a finite state automaton with input alphabet I. Then A induces a transformation unit tu(A)= (IA, ∅, PA, true, TA) where IA specifies all FSA-graphs that consist of input strings and the state graph of A with the initial state as actual state, PA consists of all rules corresponding to state transitions of A, and TA specifies the FSA-graphs that consist of the empty input string and the state graph of A with one of the final states as actual state. Therefore, an initial and a terminal graph are semantically related if and only if the initial input string is accepted by A. In this way, the recognition process of a finite state automa- ton can be seen as a special case of the computational processes provided by
transformation units.

Transforming directed graphs into undirected graphs
Based on the graph transformation approach Adir ⊗ Aundir in 2.4, the follow- ing transformation unit specifies the transformation of directed graphs into undirected graphs. Starting from a directed graph, each of its directed edges is replaced by an undirected edge between the same nodes as long as one ends
up with an undirected graph.
dir-undir
initial:	directed graphs
rules:		::=	
terminal: undirected graphs
The		given			rule		represents	the	combination	of	the rule		::=				∈ Rdir , which removes a directed edge, with 	::=				∈ Rundir , which adds an undirected edge between
two nodes. The two nodes are shared by both rules such that the removed
and added edge are incident to the same nodes. If one starts the application from a directed graph, all its edges must be replaced by undirected ones before the transformation results in the corresponding undirected graph.
In a similar way, one can specify a transformation unit that transforms a hypergraph into a bipartite graph where each hyperedge is represented by a new node and many other transformations between graphs of different types.

Modularization
In this section, we summarize the module concept of GRACE briefly. More details can be found in [12], [4], [9], [14], [15].
A transformation unit specifies a binary relation on graphs depending on the choice of the used binary relations in the import part. But how can the used relations be chosen? One possibility is that relations are stored in some relation library and may be called by their names. Another possibil- ity is to use the relations specified by transformation units. Both together leads to the notion of a transformation module as a network of transforma- tion units which use each other and where the edges reflect the use struc- ture. Moreover, each module has an import interface, which plays the same role as the import component of units, and an export interface containing the units that are provided by the module to the environment and may be imported by other units and modules later on. More formally, a transfor- mation module is a system MOD = (IMPORT , BODY , EXPORT ) where BODY is a set of transformation units, IMPORT is a set of identifiers, and
EXPORT ⊆ BODY ∪ IMPORT . Moreover, every body unit may use only units of BODY and IMPORT , i.e. for every tu = (I, U, P, C, T ) ∈ BODY , we require that U ⊆ BODY ∪ IMPORT . (Note that we do not explicitly

distinguish transformation units and their names.)
Semantically, a transformation module specifies a set of binary relations on graphs, one relation for each export unit, depending on the choice of the imported relations. If the network underlying a module is acyclic (and finite), the semantics is constructed level by level by means of the interleaving se- mantics. One starts with the transformation units that use relations from the import interface only, and proceeds step by step with those units whose use component has got a semantics already. In the case, of cyclic use structures, the interleaving of rule applications and used relations is repeated ad infini- tum starting from the imported relations and the empty relations for the body units.
To illustrate the module concept, we present a transformation module which provides connectivity tests for directed and undirected graphs. It im- ports a connectivity test for undirected graphs and the unit dir-undir in 3.4.
connectivity-tests
import:	connectivity-test-undir,dir-undir
body:	connectivity-test-dir
export:	connectivity-test-dir, connectivity-test-undir
with
connectivity-test-dir
uses:	connectivity-test-undir, dir-undir
conds:	dir-undir; connectivity-test-undir.

This transformation unit specifies the connectivity test for directed graphs as the sequential composition of the transformation from directed to undirected graphs followed by the corresponding test for undirected graphs. The latter test may be available in some library in which form ever, or it may also be specified as a transformation unit like the following.
connectivity-test-undir
initial:	undirected graphs
rules:		::=			|	
terminal: 

This unit has got two rules with the same left-hand side and two alternative right-hand sides. The first rule removes an edge if applied in the way defined in 2.4. The second rule is an extra rule not yet introduced. It can be applied to a node with degree one such that this node and its only incident edge is removed.

Visualization and Animation
Graphical structures like diagrams, maps, nets, and graphs are very popular because they allow one to represent complex structures in an intuitive way GRACE is intended to support visual modeling by means of a graphical interface. This interface must be extremely flexible because of the approach independence. There is no fixed notion of graphs, but the graphs of a graph transformation approach can be chosen according to one’s tastes or needs. And the graphical interface should respect and reflect this generality by offering a wide spectrum of possibilities. At least, it should be feasible to deal with directed graphs as well as with undirected ones, with hypergraphs as well as with simple graphs, with labeled graphs as well as with unlabeled ones etc. The most important requirement is that the visualization of graphs can be done in such a way that the graphs look like the structures they represent. For example, a Petri net should look like a Petri net, and a UML class diagram should look like a UML class diagram (see e.g. Figure 7). One may even imagine that in modeling the production processes of a factory by the use of graph transformation the representing graphs look like a machine hall. For purposes like this, the graphical interface of GRACE may offer colored 3-D representations of graphs (as the experimental implementation of GRACEland by Martin Faust [7]).
If the graphs can be properly visualized in the GRACE context, then one has also a visualization of a rule application, which is given by two graphs. Therefore, animation is obtained by the iteration of rule applications such that the dynamic behaviour of transformation units can be looked at. This applies even to transformation units that import other transformation units. If the semantic process of the imported units can be animated, one gets the ani- mation of the importing units by interleaving the visualized rule applications with the animation sequences of the imported units.

Verification
The GRACE concepts support verification in two ways. On one hand, the structuring by units and modules gives rise to structured proofs. On the other hand, the interleaving semantics provides an induction proof schema.
To illustrate structured proofs in a very simple case, consider the unit connectivity-test-dir in Section 4. By definition, the relation it specifies is the sequential composition of the relations specified by dir-undir in 3.4 and connectivity-test-undir. If the latter is correct meaning that it tests the con- nectivity of undirected graphs, and if the former transforms a directed into an undirected graph by forgetting the direction of edges, but keeping the incidences, then the sequential composition is a correct realization of a con- nectivity test for directed graphs as it is often defined in graph theory.
To show the correctness of connectivity-test-undir and dir-undir, one can







Fig. 7. An UML class diagram.

run induction proofs on the length of interleaving sequences, which are deriva- tion sequences in the two cases because both units do not use other units.
In the first case, it is easy to prove the following: If G ⇒∗ G' and G' is connected, then G is connected. Hence, only connected graphs can be derived into a single node. Moreover, one can prove by induction on the
number of edges, that any connected graph can be derived into a single node. Both together means for the semantic relation of connectivity-test-undir that a graph G is related to the single-node graph if and only if G is connected. In this sense, we have a correct connectivity test for undirected graphs.
Again by induction on the lengths of derivation sequences, one can prove that the incidences are kept invariant by derivations in dir-undir. Moreover, the rule is applicable as long as there are directed edges. This proves the transformation of directed into undirected graphs as desired.
Altogether, the module connectivity-tests in Section 4 provides correct con- nectivity tests for directed and undirected graphs. Further and more com- plicated examples of correctness proofs for GRACE units can be found in

[12,13,19].

Conclusion
In this paper, we have sketched some basic ideas and features as well as some potentials of the graph-transformation-based language GRACE. It is approach-independent meaning that the type of graphs, rules, rule applica- tions, etc. is not fixed from the very beginning, but can be chosen according to the intended application and one’s taste. In particular, the structuring concepts of transformation units and transformation modules work quite un- restricted while special constructions like the coupling of approaches require special assumptions.
In contrast to syntax and semantics of the structuring concepts, which are already discussed and worked out in some detail (cf. [16], [12], [13],[4], [9]), the ideas how to deal with graphs of different types and how to visualize, animate, and verify graph transformation in GRACE are in a very premature state and need further investigation.

References

Marc Andries, Gregor Engels, Annegret Habel, Berthold Hoffmann, Hans-Jo¨rg Kreowski, Sabine Kuske, Detlef Plump, Andy Schu¨rr, and Gabriele Taentzer. Graph transformation for specification and programming. Science of Computer Programming, 34(1):1–54, 1999.
Paolo Bottoni, Manuel Koch, Francesco Parisi-Presicce, and Gabriele Taentzer. Consistency checking and visualization of OCL constraints. In Andy Evans, Stuart Kent, and Bran Selic, editors, Proc. UML 2000 - The Unified Modeling Language. Advancing the Standard, volume 1939 of Lecture Notes in Computer Science, pages 294–308, 2000.
Giorgio Busatto, Hans-Jo¨rg Kreowski, and Sabine Kuske. An abstract hierarchical graph data model. In preparation, 2001.
Frank Drewes, Peter Knirsch, Hans-J¨org Kreowski, and Sabine Kuske. Graph transformation modules and their composition. In Manfred Nagl, Andreas Schu¨rr, and Manfred Mu¨nch, editors, Proc. Applications of Graph Transformations With Industrial Relevance, volume 1779 of Lecture Notes in Computer Science, pages 15–30, 2000.
Hartmut Ehrig, Gregor Engels, Hans-Jo¨rg Kreowski, and Grzegorz Rozenberg, editors. Handbook of Graph Grammars and Computing by Graph Transformation, Vol. 2: Applications, Languages and Tools. World Scientific, Singapore, 1999.
Hartmut Ehrig, Hans-Jo¨rg Kreowski, Ugo Montanari, and Grzegorz Rozenberg, editors.   Handbook of Graph Grammars and Computing by Graph


Transformation, Vol. 3: Concurrency, Parallelism, and Distribution. World Scientific, Singapore, 1999.
Martin Faust. The GRACEland web page. URL:
http://www.informatik.uni-bremen.de/theorie/GRACEland, 1998.
Reiko Heckel, Gregor Engels, Hartmut Ehrig, and Gabriele Taentzer. Classification and comparison of module concepts for graph transformation systems. In Ehrig et al. [5], pages 639–689.
Reiko Heckel, Berthold Hoffmann, Peter Knirsch, and Sabine Kuske. Simple modules for GRACE. In Hartmut Ehrig, Gregor Engels, Hans-Jo¨rg Kreowski, and Grzegorz Rozenberg, editors, Proc. Theory and Application of Graph Transformations, volume 1764 of Lecture Notes in Computer Science, pages 383–395, 2000.
Hans-J¨org Kreowski. Graph grammars for software specification and programming: An eulogy in praise of GRACE. In Francesc Rossello´ Llompart and Gabriel Valiente Feruglio, editors, Proc. Colloquium on Graph Transformation and its Application in Computer Science, Technical Report, Palma de Mallorca, pages 55–61, 1995.
Hans-J¨org Kreowski and Sabine Kuske. On the interleaving semantics of transformation units — a step into GRACE. In Janice E. Cuny, Hartmut Ehrig, Gregor Engels, and Grzegorz Rozenberg, editors, Proc. Graph Grammars and Their Application to Computer Science, volume 1073 of Lecture Notes in Computer Science, pages 89–108, 1996.
Hans-J¨org Kreowski and Sabine Kuske. Graph transformation units and modules. In Ehrig et al. [5], pages 607–638.
Hans-J¨org Kreowski and Sabine Kuske. Graph transformation units with interleaving semantics. Formal Aspects of Computing, 11(6):690–723, 1999.
Hans-J¨org Kreowski and Sabine Kuske. Note on approach-independent structuring concepts for rule-based systems. In Hartmut Ehrig and Gabi Taentzer, editors, Proc. Joint APPLIGRAPH and GETGRATS Workshop on Graph Transformation Systems, Technical Report Nr. 2000-2, Technische Universita¨t Berlin, pages 41–49, 2000.
Hans-J¨org Kreowski and Sabine Kuske. Suggestions on the modularization of rule-based systems. In Martin Wirsing, Martin Gogolla, Hans-Jo¨rg Kreowski, Tobias Nipkow, and Wolfgang Reif, editors, Proc. Rigorose Entwicklung software-intensiver Systeme, Technical Report 0005, University of Munich, pages 73–82, 2000.
Hans-J¨org Kreowski, Sabine Kuske, and Andy Schu¨rr. Nested graph transformation units. International Journal on Software Engineering and Knowledge Engineering, 7(4):479–502, 1997.
Sabine Kuske. Semantic aspects of the graph and rule centered language GRACE. In Francesc Rossell´o Llompart and Gabriel Valiente Feruglio, editors,


Proc. Colloquium on Graph Transformation and its Application in Computer Science, Technical Report, Palma de Mallorca, pages 63–70, 1995.
Sabine Kuske. More about control conditions for transformation units. In Hartmut Ehrig, Gregor Engels, Hans-Jo¨rg Kreowski, and Grzegorz Rozenberg, editors, Proc. Theory and Application of Graph Transformations, volume 1764 of Lecture Notes in Computer Science, pages 323–337, 2000.
Sabine Kuske. Transformation Units – A Structuring Concept for Graph Transformation Systems. PhD thesis, Universita¨t Bremen, 2000.
Grzegorz Rozenberg, editor. Handbook of Graph Grammars and Computing by Graph Transformation, Vol. 1: Foundations. World Scientific, Singapore, 1997.
Andy Schu¨rr. Programmed graph transformations and graph transformation units in GRACE. In Janice E. Cuny, Hartmut Ehrig, Gregor Engels, and Grzegorz Rozenberg, editors, Proc. Graph Grammars and Their Application to Computer Science, volume 1073 of Lecture Notes in Computer Science, pages 122–136, 1996.
