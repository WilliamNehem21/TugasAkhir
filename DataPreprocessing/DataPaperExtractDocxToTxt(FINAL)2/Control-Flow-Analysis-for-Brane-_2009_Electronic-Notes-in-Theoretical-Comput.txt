

Electronic Notes in Theoretical Computer Science 227 (2009) 59–75
www.elsevier.com/locate/entcs
Control Flow Analysis for Brane Calculi
Chiara Bodei1, Andrea Bracciali1 and Davide Chiarugi2
1 Dipartimento di Informatica, Universita` di Pisa, Via Pontecorvo, 3 - 56127 Pisa - Italia
{chiara,braccia}@di.unipi.it
2 Dipartimento di Scienze Matematiche e Informatiche, Universita` di Siena,
Pian dei Mantellini, 4 - 53100 Siena - Italia
chiarugi3@unisi.it


Abstract
We introduce a Control Flow Analysis for Brane Calculi. This verification technique allows properties regarding the behaviour of biological systems to be checked. This is an approximate technique that focusses on the static specification of a system, rather than on its dynamics, striving for effectiveness. Examples illustrate the approach.
Keywords: Brane calculi, control flow analysis, systems biology

Introduction
Systems biology gives computer scientists the opportunity of providing models and formalisms for describing and analysing complex biological systems. In this regard, well established and founded theories and techniques from formal methods offer a fertile ground.
The underlying idea is that a biological system can be abstractly modelled as a concurrent system [18]. Several approaches – developed to predict the dynamic behaviour of the modelled systems – have introduced the idea of performing in silico
experiments to establish which in vitro experiments are more promising.
The behaviour of a system is usually given in terms of its transition system, whose size can be huge, making its exploration computationally hard. Resorting to static techniques offers the possibility of drastically reducing the computational costs, particular high when modelling complex biological systems. The specification of the system is statically analysed in order to obtain information on the dynamic behaviour and to check the related dynamic properties, without actually exploring the whole state space of the associated transition system. The price to be paid is a loss in precision, because usually these techniques can only approximate the actual

1571-0661/© 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.12.104

behaviour.  Static analysis can be exploited for a sort of preliminary screening of the in silico experiments by efficiently testing different hypothesis and rapidly identifying which in vitro experiments worth to be performed. We first introduce a Control Flow Analysis for the version of Brane Calculi [6,7], called MBD and based on the operations for membrane fusion and splitting. Afterwards, we extend the framework, in order to include also the PEP actions that represent the operations modeling endocytosis and exocytosis. The analysis offers predictions on the contents of membranes: which membranes can be contained in the analysed one and which actions can affect it. This information offers a basis for studying dynamic properties, by suitably handling the over-approximation the static analysis introduces. Having a safe over-approximation of the exact behaviour of a system means that all the valid behaviour are captured. More precisely, all those events that the prediction does not include will never happen, while when included, the events can happen,
i.e. they are only possible.
We apply our analysis to two simple examples: (1) a model of the infection due to membrane enveloped viruses, recalling in particular the Semliki Forest Virus [6] and (2) a model of communication via mobile vesicles [19].
The paper follows the tradition initiated by [12,13] and continued with [15,16,3] of applying static techniques and, in particular, Control Flow Analysis to process calculi used for modelling biological phenomena. Our choice of the Brane calculi depends on the fact they have resulted to be particularly useful for modelling and reasoning about a large class of biological systems, such as the one of the eukaryiotic cells that, differently from the prokaryiotes, possess a set of internal membranes. Other applications of static analysis techniques have been proposed, like the Ab- stract Interpretation for BioAmbient in [10]. In a different context, the behaviour of processes is safely approximated and the properties of a fragment of Computation Tree Logic preserved. This makes it possible to address temporal properties and therefore some kinds of causality.
Among the first formalisms used to investigate biological membranes there are the P Systems [14], introduces by Pa˘un, which formalize distributed parallel com- putations biologically-inspired: a biological system is seen as a complex hierarchical structure of nested membranes inspired by the structure of living cells.
Finally, besides Brane, there are other calculi of interest for our approach, that have been specifically defined for modelling biological structures such as compart- ments and membranes, e.g. κ-calculus [9], Beta Binders [17] and the Calculus of Looping Sequences [2].
The rest of the paper is organised as follows. In Section 2 we present the MBD version of Brane Calculi. We introduce the Control Flow Analysis in Section 3. In Section 4 the analysis is extended in order to also treat the PEP actions. In Section 5 the new analysis is applied to a model of infective cycle of the Semliki Forest Virus and to a model of communication via a mobile vesicle. Section 6 presents some concluding remarks. Proofs of theorems and lemmata presented throughout the paper are collected in Appendix A.

The Calculus
Syntax
The basic structure of Brane Calculi [6] consists of two commutative monoids plus a replication operator, where ◦ is used for system composition, with unit ⬦, and | is used for membrane composition, with unit 0. Replication ! is used to represent the composition of an unbounded number of instances. We focus here on the version of the calculus without communication primitives and molecular complexes, first introducing the MBD actions and, only afterwards, the PEP ones. A system consists of nested membranes and membranes consist of collections of actions. The MBD actions are inspired by membrane fusion and splitting. The first is modelled by the mating operation, while the second can be rendered both by budding, that consists in splitting off exactly one internal membrane, and dripping, that consists in splitting off one empty membrane.

P, Q ::= ⬦ | P ◦ Q | !P | σ⟨P ⟩μ	systems S
σ, τ ::= 0 | σ|τ | !σ | a.σ	membrane processes B
a, b ::= maten | mate⊥ | budn | bud⊥(ρ) | drip(ρ) MBD actions ActMBD
n	n
Here, n is taken by a countable set Λ of names. Membranes are nameless entities, but to facilitate our analysis, we annotate them as in σ⟨P ⟩μ, in order to distinguish different syntactic occurrences of membranes. We refer to μ ∈ M as the identity of the membrane σ⟨P ⟩μ, where M is the finite set of membrane identities. Still to simplify our analysis, we assume that each considered system is contained in an ideal outermost membrane, identified by a distinguished element ∗ ∈ M.
The term σ⟨P ⟩μ denotes a system whose behaviour depends on the actions in σ and that includes the system P : σ represents a membrane and P its contents. The term a.σ denotes a process that executes a and then behaves as σ. Actions for mating (maten) and budding (budn) have the corresponding co-actions (mate⊥, bud⊥ resp.) to synchronise with. The actions bud⊥(ρ) and drip(ρ) are equipped
n	n
with a process ρ to associate with the membrane created by the performed action.

Semantics
The standard structural congruence ≡ on systems and membranes is the least congruence satisfying the following clauses:
(S/≡, ◦, ⬦) is a commutative monoid;
!⬦ ≡ ⬦, !(P ◦ Q) ≡!P ◦!Q, !!P ≡!P , !P ≡ P ◦ !P ;
(B/≡, |, 0) is a commutative monoid;
!0 ≡ 0, !(σ|τ ) ≡!σ|!τ , !!σ ≡!σ, !σ ≡ σ|!σ;
0⟨⬦⟩μo ≡ ⬦;
P ≡ Q ⇒ P ◦ R ≡ Q ◦ R, P ≡ Q ⇒!P ≡!Q, P ≡ Q ∧ σ ≡ τ ⇒ σ⟨P ⟩μ ≡ τ ⟨Q⟩μ
σ ≡ τ ⇒ σ|ρ ≡ τ |ρ, σ ≡ τ ⇒!σ ≡!τ , σ ≡ τ ⇒ a.σ ≡ a.τ .




Table 1
Reduction Semantics for Brane Calculus.





The interleaving semantics is based on the above notion of structural congruence and is composed by the basic reaction rules, valid for all brane calculi (upper part of Table 1) and by the reaction axioms for the MBD version (lower part of Table 1). Observe that, given a system, the set of its membrane identities is finite. Indeed, the structural congruence rule !P ≡!P |P applied to !σ⟨P ⟩μ gives !σ⟨P ⟩μ ≡!σ⟨P ⟩μ|σ⟨P ⟩μ,
i.e. no new identity is ever introduced in recursive calls. However, we need a dis- tinguished membrane identity each time a certain action is performed, in order to identify the membrane obtained in the target. More precisely, we need a membrane identity for the membrane resulting from the firing of an action mate, possible whenever a maten (mate⊥, resp.) resides on a membrane identified by μP (μQ, resp.), with μP and μQ included in a membrane identified by μ.  Also we need a single membrane identity for each other possible pair of action/coaction occur- ring in siblings membranes. The number of such membrane identities is finite, due to the above structural congruence rule. Similarly, we need a distinguished mem- brane identity for each action bud or drip, i.e. either when a budn (bud⊥, resp.) resides on a membrane identified by μP (μQ, resp.), with the membrane μP in- cluded in the membrane μQ, in turn included in a membrane μ, or when a drip resides on a membrane identified by μP , included in the membrane μ. To obtain the needed membrane identities, one can exploit functions that are injective and surjective on their images. These auxiliary functions return fresh membrane iden- tities, depending on the actions and on their syntactic contexts. More precisely:

MImate : ActMBD × M × M × M → M MIbud : ActMBD × M × M × M → M MIdrip : ActMBD × M × M → M
We dispense from the actual definition of these functions.  We just recall that,
given a system, the number of needed membrane identities is finite, as finite are the possible combinations of actions and contexts. Therefore, we choose M such that, given an action and the identities of the membranes on which the action (and the corresponding co-action, if any) reside, M includes the membrane identity needed to identify the membrane obtained by firing that action.

Control Flow Analysis
We develop a Control Flow Analysis for analysing Brane calculus systems, borrow- ing some ideas from [13]. The aim of the analysis is over-approximating all the possible behaviour of a Brane system. In particular, our analysis keeps track of the possible contents of membranes, thus taking care of the possible modifications of the containment hierarchy, due to the dynamics. An approximation of the contents of a membrane or estimate I is defined as
I : M → ℘(M ∪ Act),
where ℘(S) stands for the power-set of the set S and Act is the set of Brane actions. Here, μ' ∈ I(μ) means that the membrane identified by μ may contain the one identified by μ'; a ∈ I(μ) means that the action a may reside on and affect the membrane identified by μ. To validate the correctness of a proposed estimate I, we state a set of clauses operating upon judgements like I |=μ P . This judgement expresses that when P is enclosed within a membrane identified by μ ∈ M, then I correctly captures the behaviour of P , i.e. the estimate is valid also for all the states Q passed through a computation of P .
Following [13], the analysis is specified in two phases. First, we check that I describes the initial process. This is done in Table 2, where the clauses amount to a structural traversal of process syntax. These clauses rely on the following auxiliary function that collects all the actions in a membrane process σ.
Definition 3.1 A : B → Act
A(0) = ∅;
A(σ|τ ) = A(σ) ∪ A(τ );
A(!σ) = A(σ);
A(a.σ) = {a}∪ A(σ);
Note that the actions collected by A, e.g., in σ = σ0.σ1 are equal to the ones in σ' = σ0|σ1, witnessing the fact that the analysis is insensitive to the context and introduces imprecision and approximation.

The clause for membrane system σ⟨P ⟩μ' checks that whenever a membrane μ' is introduced inside a membrane μ, the relative hierarchy position must be reflected in I, i.e. μ' ∈ I(μ). Furthermore, the actions in σ that affect the membrane μ' and that are collected in A(σ), are recorded in I(μ'). Finally, when inspecting the content P , the fact that the enclosing membrane is μ' is recorded, as reflected by the judgement I |=μ' P . The rule for ⬦ and 0 do not restrict the analysis result, while the rules for parallel composition ◦, and replication ! ensure that the analysis also holds for the immediate sub-systems, by ensuring their traversal. In particular, the analysis of !P is equal to the one of P . This is another source of imprecision.
Secondly, we check that I also takes into account the dynamics of the process under consideration; in particular, the dynamics of the containment hierarchy of membranes. This is expressed by the closure conditions in the lower part of Table 2 that mimic the semantics, by modelling, without exceeding the precision boundaries of the analysis, the semantic preconditions and the consequences of the possible actions. More precisely, the precondition checks, in terms of I, for the possible presence of the redexes necessary for an action to be performed. The conclusion imposes the additional requirements on I, necessary to give a valid prediction of the analysed action. Consider e.g., the clause for (Mate) (the other clauses are similar). We have to make sure that the precondition requirements are satisfied, i.e. that:
there exists an occurrence of mate action: maten ∈ I(μP );
there exists an occurrence of the corresponding co-mate action: mate⊥ ∈ I(μQ);
the corresponding membranes must be siblings: μP , μQ ∈ I(μ)
If the precondition requirements are satisfied, then the conclusions of the clause express the consequences of performing the transition mate. In this case, we have that I must reflect that
there may exist a membrane μPQ inside μ, with the same father of the membranes
μP and μQ: μPQ ∈ I(μ); and that
the contents of μP and of μQ may also be inside μPQ, and therefore μPQ contains every membrane that is inside μP or μQ, while each action affecting μP or μQ, affects also μPQ: I(μP ) ∪ I(μQ) ⊆ I(μPQ).
This corresponds to the application of the semantic rule (Mate) that would result in the fusion of the two membranes.
Example 3.2 We illustrate our analysis on a simple example, taken from [5], of which we report one of the possible steps of computation: the (Mate) one.

(maten|bud⊥ (ρ1))⟨budm⟨⟩μP0  ◦ budo⟨⟩μP1 ⟩μP  ◦ (mate⊥|bud⊥(ρ2))⟨⟩μQ  M−→ate
m	n	o
(bud⊥ (ρ1)|bud⊥(ρ2))⟨budm⟨⟩μP0 ◦ budo⟨⟩μP1 ◦ ⬦⟩μPQ 
m	o
The main entries of the analysis are reported in Table 3, where ∗ identifies the ideal outermost membrane in which the system top-level membranes are. It is easy to check that I is a valid estimate, by following the two stages explained above. The transition maten is predicted as possible in I, as its precondition requirements are



Table 2
Analysis for Brane Processes

Table 3
Some Entries of the Example Analysis

satisfied: maten ∈ I(μP ) and mate⊥ ∈ I(μQ), and the two membranes are siblings. We can observe that the corresponding conclusion requirements are satisfied as well, because both I(μP ) and I(μQ) are included in I(μPQ), where μPQ identifies the new membrane created by the fusion. Also the transition on budm is initially possible and this result is actually predicted by the analysis. Instead, we can observe that the transition on budo cannot be performed in the initial system, because the actions do not reside on two membranes where one is the father of the other. This

is reflected by the analysis; indeed we have that the precondition requirements are
not satisfied: budo ∈ f(μP ), bud⊥ ∈ f(μQ), but μP  ∈/ f(μQ). Nonetheless, the
1	o	1
transition on budo can be performed, after the mate transition (reported above), as correctly predicted by the analysis, since budo ∈ f(μP1 ), with μP1 ∈ f(μPQ) and
bud⊥ ∈ f(μPQ).  Note that the action budm can be performed in the context in
which budm ∈ f(μP ), bud⊥ ∈ f(μP ), with μP  ∈ f(μP ), but also in the one where
0	m	0
budm ∈ f(μP ), bud⊥ ∈ f(μPQ), with μP ∈ f(μPQ). The obtained membranes are
0	m	0

therefore differently identified: μR1
in the first case and μ'
1
in the second.

Semantic Correctness
Our analysis is semantically correct with respect to the given semantics, i.e. a valid estimate enjoys the following subject reduction property with respect to the semantics.
Theorem 3.3 (Subject Reduction)
If P → Q and f |=μ P then also f |=μ Q.
This result depends on the fact that analysis is invariant under the structural congruence, as stated below.
Lemma 3.4 (Invariance of Structural Congruence) If P ≡ Q and f |=μ P
then also f |=μ Q.

Existence of the Analysis
We have previously seen a procedure for verifying whether or not a proposed estimate f is valid. We now show that for any given P there always is a least choice of f that is acceptable according to the rules in Table 2, i.e. such that f |=μ P .
Definition 3.5 The set of proposed solutions can be partially ordered by setting
f ± f' iff 6μ : f(μ) ± f'(μ).
This suffices for making the set of proposed solutions into a complete lattice; using standard notation we write f H f' for the binary least upper bound (defined point-wise), HE for the greatest lower bound of a set E of proposed estimates (also defined pointwise), and ⊥ for the least element.
Definition 3.6 A set E of proposed estimates is a Moore family if and only if it contains HF for all F ⊆ E (in particular F = ∅ and F = E).
When E is a Moore family it contains a greatest element (H∅) as well as a least element (HE). The following theorem then guarantees that there always is an estimate satisfying the specification in Table 2.
Theorem 3.7 (Moore Family)
For any system P, the set {f| f |=μ P } is a Moore family.
Currently, our analysis is not implemented, but it can, along the lines of the Control Flow Analysis for BioAmbients [13]. This means that it is possible, given a process, to compute its least estimate.

Extension to the PEP Actions
The presented analysis can be extended (see below) in order to deal with the Phago/Exo/Pino (PEP) version of Brane Calculus. These further operations are used to describe endocytosis and exocytosis processes. The first indicates the pro- cess of incorporating external material into a cell, by engulfing it with the cell membrane, while the second one indicates the reverse process. Endocytosys is ren- dered by two more basic operations: phagocytosis (denoted by phago), that consists in engulfing just one external membrane, and pinocytosis (denoted by pino), consists in engulfing zero external membranes; exocytosis is instead denoted by exo. The detailed extensions to the syntax follow, while the semantics ones are in Table 4.

a ::= phagon | phago⊥(ρ) | exon | exo⊥ | pino(ρ) PEP actions ActPEP
n	n
MIphago : ActPEP × M × M × M → M MIpino : ActPEP × M × M → M


Table 4
Reduction Rules for PEP Actions.

The Control Flow Analysis can be extended by adding the closure conditions in Table 5. Our extended analysis is still semantically correct with respect to the given semantics and the estimates still form a Moore family, therefore guaranteeing the existence of a least estimate satisfying the clauses in Tables 2 and 5. The extended results are handled and proved in the Appendix.

The Analysis at Work
In Brane calculi the dynamics of biological membranes is abstracted by means of interactions that lead to modifications of the hierarchy of compartments. Control Flow Analysis gives information on the possible variations of the containment hier- archy. Both examples presented below show why this information is important, as it offers the basis for qualified predictions about the possible dynamic behaviour.



Table 5
Closure Rules for PEP Actions
Viral Infection
We first refer to the abstract specification introduced in [6] of the viral infection cycle of the Semliki Forest Virus, shown in Figure 1. This is one of the so-called “enveloped viruses”. These viruses possess a lipidic bilayer envelope that surrounds the nucleocapsid, the part of the virus composed by the genome and its protective coat formed by identical protein subunits (capsomers). The viral outer envelope is a modified form of one of the membranes of the host cell, either the cell membrane, or an internal membrane, e.g. the nuclear membrane or endoplasmic reticulum. Noticeably, most enveloped viruses depend on their envelope for their infectivity.






Fig. 1. Viral Infection (highlighted part) and Reproduction. [Adapted from [6] and [1]]
In our example, we consider the first stage of the infective cycle of the Semliki Forest Virus (highlighted part in Figure 1), whose steps can be coded as in Table 6.



Table 6
Viral Infection System

Table 7
Viral Infection Evolution

Table 8
Viral Infection Analysis Results

We focus only on the first stage, because it lends itself to show how the Control Flow Analysis predictions could reflect the dynamic modifications of the membranes hierarchy. In addition, striving for simplicity, it does not require further extensions to the bunch of Brane Calculi primitives used here.
Usually, the Semliki Forest Virus is brought into the cell by phagocytosis, thus wrapped by an additional membrane layer. An endosome compartment is merged with the wrapped-up virus. At this point, the virus uses one of its special (viral encoded) membrane protein to trigger the exocytosis process that leads the naked nucleocapsid into the cytosol, ready to continue the infective cycle. By summarising,
if the cell gets close to the virus, then it evolves into an infected cell:
virus ◦ cell →∗ membrane⟨nucap ◦ cytosol⟩μmemb
The complete evolution of the viral infection is reported in Table 7, while the main analysis entries are in Table 8. The analysis results allow us to predict the effects of the infection. Indeed, the inclusion μnucap ∈ f(μmemb) reflects the fact that, at the end of the shown computation, nucap is inside membrane, together with cytosol.

Communication via a Mobile Vesicle
In eucaryotic cells a large variety of proteins is targetted to its final destination via mobile transport vesicles, i.e. small membrane-enclosed sacs separated from the cytosol by a lipidic bilayer. Proteins can be contained in the vesicles (e.g. secretory proteins) or embedded in their membrane, e.g. transmembrane proteins.



Table 9
Communication via a Mobile Vesicle: Encoding

Table 10
Communication via a Mobile Vesicle: Evolution

Through vesicular trafficking, proteins follow routes involving intracellular locations (e.g. endoplasmic reticulum, Golgi apparatus or lysosomes) as well as the plasma membrane, in the case of endo- and exocytosis.
In [19], the PEP Brane calculus, plus the bud action, had been used to model a
hypothetical scenario of communication via a mobile vesicle. As shown in Figure 2, a vesicle containing (embedded in its membrane) a substance that needs to be shuttled between two compartments, buds from a membrane Source. Then, it is engulfed by another compartment through phagocytosis and, finally, the mobile vesicle merges with the membrane Target releasing the transported substance in it. The encoding of this scenario is in Table 9. There, ωG, ωX , ωSource, and ωT arget stand for skin membranes processes (not specified as not relevant at this level of abstraction).

Fig. 2. A vesicle with the substance (rendered as |) embedded in its membrane, buds from the source membrane (1 and 2). The vesicle is then phagocytated by the target membrane (3 and 4) and merges with it (5 and 6) so delivering the substance to the final destination.

The dynamic evolution is reported in Table 10. The action budn1 triggers the communication process, by leading to the gemmation of a vesicle containing the substance ωX ⟨⬦⟩μX coming from the membrane Source. The vesicle fuses with membrane Target, by means of actions phagon2 and exo.
The main entries of the Control Flow Analysis are reported in Table 11. The inclusion μX ∈ f(μT ) reflects that the substance to be transmitted can eventually finish inside the target membrane.



Table 11
Communication via a Mobile Vesicle: Analysis Results
Conclusion
We have introduced a Control Flow Analysis for the static approximation of the dynamic behaviour of processes, expressed in the MBD + PEP version of Brane calculi.
Like the ones in [12,13,3], our analysis is context-insensitive and also flow- insensitive and these features affect the analysis precision. Future work regards the improvement of our analysis precision, along the lines of [15,16]. Preliminary results make us confident that useful information on the behaviour of the analysed systems can be obtained and used in order to establish biological properties of the systems under consideration. In particular, the properties that can be expressed as reachability properties of the model. Furthermore, we can obtain information on the role played by the various elements composing the investigated system. There- fore, it becomes easier to evaluate the behaviour of the whole system when a single element is added or removed, following an approach similar to [4].

Acknowledgement
We are grateful to Pierpaolo Degano for his helpful discussions and to the referees for their valuable suggestions.

References
B. Alberts, D. Bray, J. Lewis, M. Raff, K. Roberts, and J.D. Watson. “Molecular Biology of the Cell”. Third Edition, Garland.
R. Barbuti, G. Caravagna, A. Maggiolo-Schettini, P. Milazzo, and G. Pardini. The calculus of looping sequences. In Proc. of SFM’08, Lecture Notes in Computer Science 5016 (2008), 387–423.
C. Bodei. A Control Flow Analysis for Beta-binders with and without Static Compartments. To appear in Theoretical Computer Science (2008), Elsevier.
C. Bodei, A. Bracciali, and D. Chiarugi. On Deducing Causality in Metabolic Networks. In BMC Bioinformatics, 9(4) (2008).


N. Busi. Towards a Causal Semantics for Brane Calculi. In What is it About Government that Americans Dislike, 1945–1965, University Press, 2007.
L. Cardelli. Brane calculi - interactions of biological membranes. In Proc. of Computational Methods in Systems Biology (CMSB’04) Lecture Notes in Computer Science 3082 (2005), 257–280, Springer.
L. Cardelli and G. Paun. An universality result for a (mem)brane calculus based on mate/drip operations. Int. J. Found. Comput. Sci. 17 (1) (2006), 49–68, World Scientific.
V. Danos and J. Krivine. Transactions in RCCS. In Proc. of Conference on Concurrency Theory (CONCUR’05), Lecture Notes in Computer Science 3653 (2005), 398–412, Springer.
V. Danos and Cosimo. Laneve. Graphs for core molecular biology. In Proc. of Computational Methods in Systems Biology (CMSB’03), Lecture Notes in Computer Science 2602 (2003), 34–46, Springer.
R. Gori, F. Levi. An Analysis for Proving Temporal Properties of Biological Systems. In Proc. of APLAS, Lecture Notes in Computer Science 4279 (2006), 234–252.
R. Milner. “Communicating and mobile systems: the π-calculus”. Cambridge University Press, 1999.
F Nielson, H Riis-Nielson, D Schuch-Da-Rosa, and C Priami. Static analysis for systems biology. In Proc. of Workshop on Systeomatics - dynamic biological systems informatics, 1–6. Computer Science Press, 2004.
F. Nielson, H. Riis Nielson, C. Priami, and D. Schuch da Rosa. Control Flow Analysis for BioAmbients. Electronic Notes in Theoretical Computer Science 180(3) (2007), 65–79, Elsevier.
G. Paun. Computing with membranes (P systems): A variant. Int. J. Found. Comput. Sci., 11(1)
(2000), 167–181.
H. Pilegaard, F. Nielson, H. R. Nielson. Static analysis of a Model of the LDL degradation pathway. In Proc. of Workshop on Computational Methods in Systems Biology (CMSB’05), 2005.
H. Pilegaard, F. Nielson, H. Riis Nielson. Context Dependent Analysis of BioAmbients. In Proc. of Emerging Aspects of Abstract Interpretation ’06, 2006.
C. Priami and P. Quaglia. Beta binders for biological interactions. In Proceedings of Computational Methods in Systems Biology (CMSB’04), Lecture Notes in Computer Science 3082 (2005), 20–33, Springer.
A. Regev and E. Shapiro. Cellular Abstractions: Cells as Computation, Nature, 419 (2002).
A. Vitale and G. Mauri. Communication via Mobile Vesicles in Brane Calculi. Electronic Notes in Theoretical Computer Science 171 (2) (2007), 187–196, Elsevier.

A  Proofs
This appendix restates the lemmata and theorems presented earlier in the paper and gives the proofs of their correctness.
To establish the semantic correctness, the following auxiliary results are needed.

Fact A.1 If f |=μ1 P and f(μ1) ⊆ f(μ2), then f |=μ2 P.
Proof. By structural induction on P . This is straightforward, because the mem- brane identity is only used in recursive calls, to establish a fact like μ ∈ f(μi) or a ∈ f(μi). We show just one case.
Case P = σ⟨P ⟩μ' . We have that f |=μ1 P is equivalent to μ' ∈ f(μ ) ∧ A(σ) ∈
f(μ') ∧ f |=μ' P . Now, μ' ∈ f(μ ) and f(μ ) ⊆ f(μ ) imply μ' ∈ f(μ ), and by
1	1	2	2
induction hypothesis, we have that f |=μ2 P .	 
Fact A.2 If σ ≡ τ then A(σ) = A(τ ).

Proof. The proof amounts to a straightforward inspection of each of the clauses defining the structural congruence clauses relative to membranes. We show only two cases, the others are similar.
Case σ0|σ1 ≡ σ1|σ0. We have that A(σ0|σ1) = A(σ0) ∪ A(σ1) = A(σ1|σ0).
Case σ ≡ τ ⇒ σ|ρ ≡ τ |ρ. We have that A(σ|ρ) = A(σ) ∪ A(ρ). Now, since σ ≡ τ , we have that A(σ) = A(τ ) and therefore A(σ|ρ) = A(τ ) ∪ A(ρ), from which the required A(τ |ρ).	 
Lemma A.3 (Invariance of Structural Congruence) If P ≡ Q and f |=μ P
then also f |=μ Q.
Proof. The proof amounts to a straightforward inspection of each of the clauses defining the structural congruence clauses.
Case P0 ◦ P1 ≡ P1 ◦ P0. We have that f |=μ P0 ◦ P1 is equivalent to f |=μ P0 ∧
f |=μ P1, that is equivalent to f |=μ P1 ∧f |=μ P0 and therefore to f |=μ P1 ◦ P0. Case P0 ◦ (P1 ◦ P2) ≡ (P0 ◦ P1) ◦ P2. We have that f |=μ P0 ◦ (P1 ◦ P2) is equivalent to f |=μ P0 ∧f |=μ P1 ◦ P2, that is equivalent to f |=μ P0 ∧f |=μ P1 ∧f |=μ P2 and, in turn, to f |=μ P0 ◦ P1 ∧f |=μ P2, and therefore to f |=μ (P0 ◦ P1) ◦ P2.
Case P0 ◦ ⬦ ≡ P0. We have that f |=μ P0 ◦⬦ is equivalent to f |=μ P0 ∧ f |=μ ⬦, that is equivalent to f |=μ P0 ∧ true, and therefore to f |=μ P0.
Case !⬦ ≡ ⬦. We have that f |=μ !⬦ is equivalent to f |=μ ⬦.
Case !(P0◦P1) ≡!P0◦!P1. We have that f |=μ !(P0 ◦ P1) is equivalent to f |=μ (P0 ◦ P1), that is equivalent to f |=μ P0 ∧f |=μ P1, that is equivalent to f |=μ !P0 ∧f |=μ !P1 and therefore to f |=μ !P0◦!P1.
Case !!P ≡!P . We have that f |=μ !!P is equivalent to f |=μ !P .
Case !P ≡ P ◦!P . We have that f |=μ !P is equivalent to f |=μ P , that is equivalent to f |=μ P ∧f |=μ !P , and therefore to f |=μ P ◦!P .
Case 0⟨⬦⟩μ' ≡ ⬦. We have that f |=μ 0⟨⬦⟩μ' is equivalent to μ' ∈ f(μ) ∧ A(0) =
∅ ⊆ f(μ') ∧ f |=μ' ⬦, that is equivalent to f |=μ' ⬦ ∧ true, that implies true and, in turn, f |=μ ⬦.
Case P ≡ Q ⇒ P ◦ R ≡ Q ◦ R. We have that f |=μ P ◦ R is equivalent to f |=μ P ∧f |=μ R, and from the hypothesis f |=μ P , we have that f |=μ Q. There- fore from f |=μ Q ∧f |=μ R, we obtain the required f |=μ Q ◦ R.
Case P ≡ Q ⇒!P ≡!Q: similar.
Case P ≡ Q ∧ σ ≡ τ ⇒ σ⟨P ⟩μ' ≡ τ ⟨Q⟩μ' . We have that f |=μ σ⟨P ⟩μ' is equivalent to μ' ∈ f(μ) ∧ A(σ) ∈ f(μ') ∧f |=μ' P . By Fact A.2, A(τ ) ∈ f(μ'), and by induc- tion hypothesis, we have that μ' ∈ f(μ) ∧ A(τ ) ∈ f(μ') ∧ f |=μ' Q and therefore f |=μ τ ⟨Q⟩μ' .	 
Theorem A.4 (Subject Reduction)
If P → Q and f |=μ P then also f |=μ Q.
Proof. The proof is by induction on P → Q. The proofs for the rules (Par) and (Brane) are straightforward, using the induction hypothesis and the clauses in Table 2. The proof for the (Struct) uses instead the induction hypothesis and Lemma A.3. The proofs for the basic actions in the lower part of Table 1 and in Table 4 are straightforward, using the clauses in Tables 2 and 5.

Case (Par). Let P be P0 ◦ P1 and Q be P ' ◦ P1. We have to prove that f |=μ Q. Now f |=μ P is equivalent to f |=μ P0 ∧ f |=μ P1. By induction hypothesis,
we have that f |=μ P ', and from f |=μ P ' ∧ f |=μ P1 we obtain the required
0	0
f |=μ Q.
Case (Brane).	Let P be σ⟨P ⟩μ'  and Q be σ⟨P'⟩μ' .	We have to prove that
0	0
f |=μ σ⟨P'⟩μ' . Now f |=μ P is equivalent to μ' ∈ f(μ) ∧ A(σ) ∈ f(μ') ∧ f |=μ' P .
0	0
By induction hypothesis, we have that f |=μ P ', and from μ' ∈ f(μ) ∧ A(σ) ∈
0
'	μ'	'
f(μ ) ∧ f |=	P0 we obtain the required f |=μ Q.
Case (Struct). Let P ≡ P0, with P0 → P1 such that P1 ≡ Q. By Lemma A.3, we have that f |=μ P0, by induction hypothesis f |=μ P1 and, again by Lemma A.3, f |=μ Q.
Case (Mate). Let P be maten.σ|σ0⟨P0⟩μ0 ◦mate⊥.τ |τ0⟨P1⟩μ1 and Q be σ|σ0|τ |τ0⟨P0◦
P1⟩μ01 .	We have that f |=μ P is equivalent to maten ∈ f(μ0)  ∧  mate⊥ ∈
f(μ1)∧ μ0, μ1 ∈ f(μ) (1) and A(σ) ∈ f(μ0) ∧ A(σ0) ∈ f(μ0) ∧ f |=μ0 P0 ∧ A(τ ) ∈ f(μ1) ∧ A(τ0) ∈ f(μ1) ∧ f |=μ1 P1. In particular, because of the closure con- ditions, from (1), we have that μ01 ∈ f(μ) ∧ f(μ0) ∪ f(μ1) ⊆ f(μ01). Since f(μi) ⊆ f(μ01) for i = 0, 1, then, by Fact A.1, we have that A(σ) ∈ f(μ01) ∧ A(σ0) ∈ f(μ01) ∧f |=μ01 P0 and A(τ ) ∈ f(μ01) ∧ A(τ0) ∈ f(μ01) ∧ f |=μ01 P1, and hence the required f |=μ Q.
Case (Bud). Let P be bud⊥(ρ).τ |τ0⟨budn.σ|σ0⟨P0⟩μ0 ◦P1⟩μ1 and Q be ρ⟨σ|σ0⟨P0⟩μ0 ⟩μR ◦
τ |τ0⟨P1⟩μ1 . We have that f |=μ P is equivalent to budn ∈ f(μ0) ∧ bud⊥(ρ) ∈ f(μ1) ∧ μ0 ∈ f(μ1) ∧ μ1 ∈ f(μ) (1) and A(σ) ∈ f(μ0) ∧ A(σ0) ∈ f(μ0) ∧ f |=μ0 P0 ∧ A(τ ) ∈ f(μ1) ∧ A(τ0) ∈ f(μ1) ∧ f |=μ1 P1. In particular, because of the closure conditions, from (1), we have that A(ρ) ∈ f(μR) ∧ μR ∈ f(μ) and μ0 ∈ f(μR), and therefore the required f |=μ Q.
Case (Drip). Let P be drip(ρ).σ|σ0⟨P0⟩μ0 and Q be ρ⟨⟩μR ◦ σ|σ0⟨P0⟩μ0 . We have that f |=μ P is equivalent to drip(ρ) ∈ f(μ0) ∧ μ0 ∈ f(μ) (1) and A(σ) ∈ f(μ0) ∧ A(σ0) ∈ f(μ0) ∧ f |=μ0 P0. In particular, because of the closure condi- tions, from (1), we have that A(ρ) ∈ f(μR) ∧ μR ∈ f(μ), and therefore the required f |=μ Q.
Case (Phago).  Let P be phagon.σ|σ0⟨P0⟩μ0 ◦ phago⊥(ρ).τ |τ0⟨P1⟩μ1 and Q be τ |τ0⟨ρ⟨σ|σ0.⟨P0⟩μ0 ⟩μR ◦ P1⟩μ1 . We have that f |=μ P is equivalent to phagon ∈ f(μ0) ∧ phago⊥(ρ) ∈ f(μ1) ∧ μ0, μ1 ∈ f(μ) (1) and A(σ) ∈ f(μ0) ∧ A(σ0) ∈ f(μ0) ∧ f |=μ0 P0 ∧ A(τ ) ∈ f(μ1) ∧ A(τ0) ∈ f(μ1) ∧ f |=μ1 P1. In particular, because of the closure conditions, from (1), we have that A(ρ) ∈ f(μR) ∧ μR ∈ f(μ1) ∧ μ0 ∈ f(μR), and hence the required f |=μ Q.
Case (Exo). Let P be exo⊥.τ |τ0⟨exon.σ|σ0⟨P0⟩μ0 ◦P1⟩μ1 and let Q be P0◦σ|σ0|τ |τ0⟨P1⟩μ1 .
We have that f |=μ P is equivalent to exon ∈ f(μ0) ∧ exo⊥ ∈ f(μ1) ∧ μ0 ∈
f(μ1) ∧ μ1 ∈ f(μ) (1) and A(σ) ∈ f(μ0) ∧ A(σ0) ∈ f(μ0) ∧ f |=μ0 P0 ∧ A(τ ) ∈ f(μ1) ∧ A(τ0) ∈ f(μ1) ∧ f |=μ1 P1. In particular, because of the closure condi- tions, from (1), we have that A(σ), A(σ0) ∈ f(μ1) ∧ f(μ0) ⊆ f(μ). By Fact A.1, we have that f |=μ P0 and therefore the required f |=μ Q.
Case (Pino). Let P be pino(ρ).σ|σ0⟨P0⟩μ0 and Q be σ|σ0⟨ρ⟨⟩μR ◦ P0⟩μ0 . We have that f |=μ P is equivalent to pino(ρ) ∈ f(μ0) ∧ μ0 ∈ f(μ) (1) and A(σ) ∈ f(μ0) ∧ A(σ0) ∈ f(μ0) ∧ f |=μ0 P0. In particular, because of the closure condi-

tions, from (1), we have that A(ρ) ∈ f(μR) ∧ μR ∈ f(μ0), and therefore the required
f |=μ Q.

Theorem A.5 (Moore Family)
For any system P, the set {f| f |=μ P } is a Moore family.
Proof. We proceed by structural induction on P . Let E be a set of proposed estimates and let F and fj such that F ⊆ E = {fj| j ∈ F }. Next, define f' = HF We have to check that f' |=μ' P . We just consider one case. The others are similar.
Case (σ⟨P ⟩μ' ). Since 6j ∈ F : f |=μ σ⟨P ⟩μ, then
0	j	0


6j ∈ F : μ' ∈ f (μ) ∧ A(σ) ∈ f (μ') ∧ f
|=μ' P

j	j	j
Using the induction hypothesis and the fact that f' is obtained in a pointwise way, we then obtain that
μ' ∈ f'(μ) ∧ A(σ) ∈ f'(μ') ∧ f' |=μ' P
thus establishing the required f' |=μ σ⟨P0⟩μ' .	 
