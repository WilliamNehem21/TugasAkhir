Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 290 (2012) 37–50
www.elsevier.com/locate/entcs

Order-sorted Equational Unification Revisited
Joe Hendrix1,2
Galois, Inc Portland, OR 97204, USA
José Meseguer1,3
Department of Computer Science University of Illinois at Urbana-Champaign Urbana, IL 61801, USA

Abstract
This paper presents a rule-based algorithm for performing order-sorted E-unification using an unsorted E-unification decision procedure under assumptions about E that are commonly satisfied in practice. We have implemented this algorithm in Maude for use with the Maude-NRL protocol analyzer and have used CiME for unsorted E-unification for E any set of AC and ACU axioms. In many examples of interest, using order-sorted unification over unsorted unification is able to reduce the total number of unifiers considered, and dramatically improve the performance of the Maude-NRL tool.
Keywords: Order-sorted unification, rule-based programming.


Introduction
Unification is a fundamental operation in many applications. For example, in solv- ing reachability problems using narrowing, the unification procedure is called many times to unify terms representing reachable states against the left-hand sides of rewrite rules. This process is computationally expensive and often generates a large number of different terms — many of which may represent states that do not corre- spond to legal states. In order to avoid this problem tools such as the Maude-NRL protocol analyzer [5,6] use order-sorted algebras and rely on the sorts to only con- sider well-formed terms.
We present an algorithm which can use a procedure for unsorted E-unification to perform order-sorted E-unification under conditions general enough to cover many

1 The research has been supported in part by ONR grant N00014-02-1-0715 and NSF grant CNS-07-16638.
2 Email: jhendrix@galois.com
3 Email: meseguer@cs.uiuc.edu

1571-0661 © 2012 Published by Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2012.11.010

practical applications. This algorithm solves a key challenge faced by the Maude- NRL protocol analyzer — most existing unification tools only support unsorted unification and ignore the sort information. Since equational unification procedures are often quite complex, it requires significantly less work to use an existing unifica- tion tool rather that writing an order-sorted equational unification procedure from scratch.
The order-sorted unification algorithm we present in this work can be natu- rally described by a terminating and confluent set of rewrite rules which compute order-sorted unifiers θ1,..., θn for each unsorted unifier θ returned by the unsorted unification procedure. We have implemented the algorithm in Maude, and have used CiME as the unsorted equational unification procedure. Our experimental results so far have shown that, although technically there may be many order-sorted uni- fiers for each unsorted unifier, this is rarely the case in practice. In fact, in practice there are usually fewer order-sorted unifiers than unsorted unifiers, and the use of order-sorted unification is essential for both correctness and performance, that is, so that the terms explored are always well-formed terms, and to ensure that the Maude-NRL analyzer is capable of handling real problems.
Our idea is not new, and was presented in [12] and more recently without a proof of correctness in [5]. However, after implementing these ideas in the Maude-NRL protocol analyzer, we felt that a new paper presenting the basic ideas was in order for several reasons:
Our experience with the Maude-NRL protocol analyzer so far has suggested that for theories with AC operators, for practical protocol verification tools based on narrowing it is essential to use the sort information during unification. However, most existing unification procedures only perform unsorted E-unification and do not support sorts and subsorts. By using the techniques described in this work, one can obtain an order-sorted E-unification procedure from an unsorted one with very little effort for many equational theories.
The algorithm in [12] was buried in a function’s definition appearing in the proof of Theorem 34 in [12]. In this paper, we present a simple rule-based algorithm which is almost directly implementable in Maude. The algorithm only consists of three confluent and terminating rewrite rules, and it should be easily possible to compose these rules with inference steps in a modular way in other reasoning tools using unification.
Perhaps most important from a technical perspective, the correctness results in [12] imposed unnecessarily strong technical conditions which excluded the ma- jority of E-unification problems when E contains collapsing equations like idem- potence x + x = x and identity x +0 = x. As identity was important for the Maude-NRL protocol analyzer and idempotence is a common axiom in many E- unification algorithms, in this paper we prove the correctness results under weaker assumptions about the equational theory and some technical assumptions about the unification engine. The assumptions about the unification engine should be satisfied in practice. Additionally, we show specifically how the algorithm can be

used in Maude for equational theories with any combination of free, commutative, AC, and ACU symbols.
This paper is organized as follows. In Section 2, we review basic definitions of order-sorted algebra and unification. In Section 3, we present our algorithm to compute order-sorted unifiers from unsorted unifiers. In Section 4, we illustrate how it can be used for AC and ACU order-sorted unification in Maude and, in Section 5 we prove its correctness. Finally, in Section 6, we discuss related work and suggest directions for future research.

Preliminaries
Order Sorted Algebra
An order-sorted signature Σ = (S, F, ≤) consists of a set of sorts S, a family of operators F = { Fw,s }(w,s)∈S∗×S , and a partial order ≤⊆ S × S called the subsort ordering. We let X = { Xs }s∈S denote a fixed S-sorted family of infinite sets of variables that are both pairwise disjoint for different sorts, i.e., Xs ∩ Xs∗ = ∅ for distinct s, sj ∈ S, and disjoint from the operators F . As a notational convenience, we write xs to denote that x ∈ Xs when the variables X are clear from the context. The Σ-terms with variables X are members of the family TΣ(X)= { TΣ(X)s }s∈S, where TΣ,s(X) denotes the Σ-terms with any sort sj ≤ s. An order-sorted theory E = (Σ, E) consists of an order-sorted signature Σ and a finite set E of equations l = r where l, r ∈ TΣ,s(X) for some sort s ∈ S. An order-sorted substitution is a function θ : Y → TΣ(X) with Y a finite subset of X, and for each variable xs ∈ Y , xsθ ∈ TΣ(X)s. We let rvars(θ) denote the variables occurring in a terms in the codomain
of θ, i.e., rvars(θ) = Sx∈Y vars(xθ). Given substitutions θ1, θ2 : Y → TΣ(X), we
write θ1 =£ θ2 if xθ1 =£ xθ2 for all x ∈ Y , and we write θ1 ≥£ θ2 if there is a substitution ψ : rvars(θ1) → TΣ(X) such that θ1ψ =£ θ2. For an equational theory E = (Σ, E), we define the relation =£ ⊆ TΣ(X) × TΣ(X) as the least equivalence relation defined by the logical equivalence t =£ tj ⇐⇒ E ▶ (∀X) t = tj where X is
our fixed set of variables and ▶ is the order-sorted deduction relation [8,11]. For each order-sorted theory E = (Σ, E) with Σ= (S, F, ≤), there is an underlying unsorted
theory E = (Σ, E) over variables X = Ss∈S Xs such that Σ is a ranked alphabet
containing an operator f with arity n iff there is an operator f ∈ Fs1...sn,s for some sorts s1,..., sn,s ∈ S. Observe that a Σ-equation l = r ∈ E is always a Σ-equation.
Order-sorted Equational Unification
For a fixed order-sorted theory E = (Σ, E) with Σ= (S, F, ≤), we define an order- sorted unification problem to be a finite conjunctive set Γ of Σ-equations t = u where t and u are terms in TΣ(X) whose sorts belong to the same connected component in (S, ≤). A E-unifier for Γ is an order-sorted substitution θ : vars(Γ) → TΣ(X) such that tθ =£ uθ for each equation t = u ∈ Γ. We denote the set of E -unifiers for Γ by Un£ (Γ), and we let UnΣ(Γ) denote the syntactic unifiers for Γ, i.e., UnΣ(Γ) = Un(Σ,∅)(Γ). A set S ⊆ Un£ (Γ) of E -unifiers of Γ is complete if for all unifiers

ψ ∈ Un£ (Γ), there is a unifier θ ∈ S such that θ ≥£ ψ. A set of E -unifiers S is most-general if for distinct substitutions θ1, θ2 ∈ S, θ1 /≥£ θ2. A given theory E has a finitary unification problem if there is a complete finite set of E -unifiers S for each unification problem Γ.

Order-sorted Unification
Our main goal in this work is to develop a clear rule-based algorithm for solving order-sorted E -unification problems using an unsorted E -unification procedure. In order to show that the rule-based algorithm returns a complete set of most-general unifiers, there are some technical requirements placed on the order-sorted theory E as well as on the most-general unifiers U returned by the unsorted E -unification procedure. The basic techniques behind our algorithm were described in [12]. How- ever the correctness shown in [12] imposed conditions that are too strong when the theory E contains collapsing equations like identity or idempotence axioms.
Our approach to find suitable requirements is then to relax the requirements on E while making requirements on the unsorted unification procedure in relation to the theory E . At first this appears to be less general than the approach in [12], since that work did not make any assumption about the unsorted unification procedure. However, as we will discuss later, the theories we are interested in are such that every practical unification procedure will satisfy the requirements. Most importantly for our work, this includes theories with identity axioms.
In this section, we assume the following conditions on the order-sorted theory
E = (Σ, E) and the unsorted unification procedure for E .
Σ is preregular [8], that is every term t ∈ TΣ(X) has a least sort ls(t) ∈ S.
E is sort-independent which means that for all order-sorted terms t, u ∈ TΣ(X),
t =£ u ⇒ t =£ u.


For each unification problem Γ, the unsorted unification procedure generates a complete finite set of most-general unifiers U which is sort preserving, which means that for each order-sorted unifier ψ ∈ Un£ (Γ), there is an unsorted unifier θ ∈ U and unsorted substitution φ : rvars(θ) → TΣ(X) such that: (1) ψ =£ θφ, and (2) θφ is an order-sorted substitution.

If the equational theory E and unsorted E -unification procedure satisfy the pre- vious requirements, as we show below, the unsorted E -unification procedure can be used to solve order-sorted E -unification problems. We can split the process of solving an order-sorted unification problem Γ= t1 =£ u1 ∧· · · ∧ tn =£ un into two phases: an unsorted unification phase and a sort propagation phase.

Unsorted Unification. First, we call the unsorted E -unification procedure on the unsorted E -unification problem Γ = t1 =£ u1 ∧ · · · ∧ tn =£ un to obtain a finite complete set of most-general sort-preserving unifiers U for Γ.



Given an initial set of membership constraints D, we freely apply the rules below to obtain a final set of constraints D∗.

Intersection	{ t : s1 ∧ t : s2 ∧ M }→ 
{ t : s ∧ M }

s ∈ glbΣ(s1,s2)


Propagation	{ f (t1,..., tn): s ∧ M }→	 
{ t1 : s1 ∧· · · ∧ tn : sn ∧ M }

s1...sn∈arΣ(f,s,n)

Subsumption	{ M1, M2 }→{ M1 }	if M1 ≥ M2

where glbΣ(s1, s2) =	sup≤({ s ∈ S | s ≤ s1 ∧ s ≤ s2 }),
arΣ(f, s, n)  =	sup≤n ({ w ∈ Sn | (∃sj ∈ S) f ∈ Fw,s∗ ∧ sj ≤ s }), and
M1 ≥ M2 ⇐⇒ (∀t : s ∈ M1)(∃sj ∈ S) sj ≤ s ∧ t : sj ∈ M2.

Fig. 1. Sort Propagation Algorithm


Sort Propagation. In the second phase, for each unsorted unifier θ ∈ U , we use the membership propagation algorithm described below to generate a set of variable renamings. In this context, a variable renaming is an injective function ρ : rvars(θ) → X. For each variable renaming ρ generated for an unsorted unifier θ ∈ U , our procedure returns θρ as one element in the complete set of most-general unifiers.
The membership propagation algorithm is described by a set of rules that main- tain a disjunctive set D of membership constraints. Each membership constraint M ∈ D is a conjunctive formula of the form M = t1 : s1 ∧ ··· ∧ tn : sn, and D is a finite set D = { M1,..., Mp } of membership constraints. A membership constraint M captures constraints for an unsorted unifier to be an formed order-sorted unifier. For each unsorted unifier θ ∈ U , we initially generate a singleton set D(θ) re-
flecting the sort constraints on the variables appearing in the original unification

problem Γ.
D(θ)= {
xs∈vars(Γ)


xsθ : s }.



We then apply the three rewrite rules in Fig. 1 to D(θ) until termination. The Inter- section rule exploits the preregularity assumption to simplify multiple membership constraints t : s1 and t : s2 on the same term t. The Propagation rule simplifies constraints on terms f (t1,..., tn) : s to the smaller terms t1,..., tn. Finally, the Subsumption rule is used to eliminate membership constraints that are subsumed by other more-general membership constraints. We let D∗ denote the unique normal form obtained by rewriting D until completion.
Upon termination of the rules each membership constraint M ∈ D∗ will have the

form x1 : s1∧· · ·∧xn : sn where xi /= xj if i /= j. We call membership constraints with this form reduced. A reduced membership constraint can be viewed as a function sortM : rvars(θ) → S that maps each variable xi ∈ rvars(θ) to the sort si ∈ S. Furthermore, for each reduced membership constraint M , we let ρM : rvars(θ) → X be a variable renaming which maps each variable x ∈ rvars(θ) to a fresh variable xρM with sort sortM (x).
For the set of unsorted sort-preserving unifiers U ⊆ Un£ (Γ), we define the set

OS(U )= { θρM | θ ∈ U ∧ M ∈ D(θ)∗ }.
As an example, consider the unification problem xNzNat = yNat + zNat over an order- sorted theory E = (F, E) where + contains the following operator declarations:
+: Nat Nat → Nat  +: Nat NzNat → NzNat  +: NzNat Nat → NzNat
where the declaration f : s1 s2 → s means that f ∈ Fs1s2,s. In this case, the unsorted unification engine can return a single unifier
θ = (x '→ y + z, y '→ y, z '→ z).

However, θ is not an order-sorted unifier, because y + z does not have sort NzNat . We pass θ to the sort propagation algorithm, which generates the initial set of membership constraints
D(θ)= { y + z : NzNat ∧ y : Nat ∧ z : Nat }.
For this simple example, a single application of Propagation yields the membership constraints:

D(θ)j = { (y : Nat ∧ z : NzNat ∧ y : Nat ∧ z : Nat ),
(y : NzNat ∧ z : Nat ∧ y : Nat ∧ z : Nat ) }.

From D(θ)j, we only need to apply Intersection several times to yield the final set of membership constraints:

D(θ)∗ = { (y : Nat ∧ z : NzNat ), (y : NzNat ∧ z : Nat ) }.

From D(θ)∗, we can extract two variables renamings. When applied to the initial unsorted unifier θ, this yields the final complete set of order-sorted unifiers:
OS(U )= { (x '→ uNat + vNzNat , y '→ uNat , z '→ vNzNat ),
(x '→ uNzNat + vNat , y '→ uNzNat , z '→ vNat ) }.

We prove the following result in Section 5 to show that our algorithm is correct,
Theorem Let E = (Σ, E) denote an order-sorted theory satisfying requirements (i) and (ii) above, then given a unification problem Γ with a complete set of most-


	
general sort-preserving unsorted unifiers U, OS(U ) is a complete set of most-general order-sorted unifiers for Γ.
Order-sorted AC + ACU unification

As the requirements on E and U seem rather technical, to give the reader a more intuitive feel for them, we show how the requirements are satisfied by many order- sorted equational theories specified as Maude modules having free, commutative, AC, and ACU symbols. Essentially, each such Maude module can be viewed as an order-sorted theory E = (Σ, E) with Σ= (S, F, ≤) such that:
Each equivalence class [s] ∈ S/ ≡≤ contains a maximal element ks called the kind of s where ≡≤ denotes the equivalence relation generated by ≤. More- over, for each operator declaration f ∈ Fs1...sn,s, there is also a declaration f ∈ Fks1 ...ksn ,ks .
E contains axioms of the following forms:

f (f (x, y), z)= f (x, f (y, z))	f (x, y)= f (y, x)	f (c, x)= x
associativity	commutativity	unit

where the sorts of x, y, z are maximal sorts, that is, sorts of the form ks for some s ∈ S, and for each binary symbol f ∈ F , either f does not appear in E, or E contains commutativity (C), associativity and commutativity (AC), or associativity, commutativity, and unit (ACU) axioms for f .
Σ is preregular.
Each axiom l = r ∈ E is sort-preserving, that is for each variable mapping
ρ : X → X, ls(lρ)= ls(rρ).
The assumptions (a)–(d) are quite reasonable for order-sorted Maude specifica- tions with free, commutative, AC, and ACU operators. Maude will automatically introduce additional top-most sorts ks, and requires that associativity, commutativ- ity, and unit axioms satisfy the requirements in (b). Maude does allow associative symbols that are not commutative, however unification for such theories may be infinitary [13] and is not considered here. The preregularity requirement is checked automatically by Maude when the module is entered. The sort-preservation require- ment (d) is essential as the sort-propagation algorithm described in the previous section operates syntactically on terms, and disregards the possibility that applying an equation may change the sort of a term. It is guaranteed by a three-pronged approach:
For each associativity axiom f (f (x, y), z)= f (x, f (y, z)), Maude checks that it is sort preserving by considering possible variable mappings.
For each commutativity axiom f (x, y)= f (y, x) and each declaration f : s1s2 → s, Maude completes the theory by adding a declaration f : s2 s1 → s.
For each pair of identity axioms f (x, c) = x and f (c, x) = x, our unification

procedure completes the theory by introducing a fresh sort sc together with: (1) an operator declaration c : → sc, (2) a subsort declaration sc < ls(t); and (3) for each sort s ∈ [ls(t)], operator declarations f : s sc → s and f : sc s → s.
We now focus on the relationship between the assumptions (a)–(d) and the earlier requirements (i)–(iii). The first preregularity requirement follows from the prereg- ularity assumption. The sort-independence requirements follows form the assump- tions (a) and (b).
Theorem 4.1 If E = (Σ, E) is an order-sorted theory satisfying assumptions (a) and (b) above, then E is sort-independent.
Proof. Showing that E is sort-independent requires showing that for all t, u ∈
TΣ(X), t =£ u implies t =£ u.
We first partition E into disjoint sets E = R Ax where Ax contains the associa- tivity and commutativity equations in E and the identity equations f (c, x) = x in E are interpreted as rules f (c, x) → x in R. It is not difficult to see that the rules R modulo Ax are terminating and confluent, and therefore t =£ u iff t↓R/Ax =Ax u↓R/Ax .
As Ax only contains associativity and commutativity axioms, if t ∈ TΣ(X)ks
for some maximal sort ks and t =Ax v, then it easily follows that v ∈ TΣ(X)ks

and t =Ax
v by the requirement (a). It also easily follows that if t →∗ 
x
v, then

v ∈ TΣ(X)ks
and t →∗
v. From this, we can conclude that


t↓R/Ax =Ax u↓R/Ax =⇒ t↓R/Ax =Ax u↓R/Ax .
It easily follows that t =£ u, and thus E is sort-independent.	2
In general, the requirement that the unification procedure is sort-preserving does not follow from the assumptions given above. For an example, consider the theory E with two unrelated top-most sorts Nat and Cns where Nat contains the ACU symbol + with the identity element 0, and Cns contains the constant a. Given the unification problem xCns = a, it would be permissible for the unsorted unification procedure to return the unifiers
U = { (x '→ a + 0) }.
This is a complete set of unsorted unifiers due to the identity axiom, but unsuitable for our sort propagation algorithm as a +0 is not a legal term. This counterexample illustrates why the earlier work [12] imposed significant restrictions on theories with collapsing equations like identity.
These stronger restrictions appear unnecessary in practice — in our experience, the procedure will not introduce extra symbols, and in this case return the simpler unifier x '→ a. The reason that unsorted AC and ACU unification procedures satisfy this assumption is that the unifiers are computed from the terms appearing in equations l = r ∈ Γ. When those subterms are well-typed with the same top- most sort k, substitutions generated by the unsorted unification procedure should

be well-typed as well Provided that the sorts of fresh variables in the right hand side of a variable are given the appropriate top sort k, due to our assumption (a), we have found it is safe to assume the following:

For each unifier θ in the set of unifiers U returned by the unsorted unification procedure for the order-sorted unification problem Γ, and for each variable xs ∈ vars(Γ), xsθ ∈ TΣ(X)ks .
To validate these ideas and test this assumption, we have extended an alpha version of Maude so that it may communicate with CiME [3,4] by passing unsorted unification problems as strings, and parsing the unsorted unifiers returned from CiME back into Maude terms. As an additional safeguard, the parsing process checks the substitutions returned by CiME to verify that assumption (e) is satisfied. These checks have always been satisfied in our experience using the procedure so far. We then apply the sort propagation algorithm described in the previous section to generate order-sorted E -unifiers. The order-sorted unification procedure is used to analyze cryptographic protocols with algebraic properties of associativity and commutativity using the Maude-NRL protocol analyzer [5].

Correctness Proof
The goal of this section is to show the correctness of our approach to order-sorted equational unification. Before we can show this, we need several intermediate lem- mas. The first lemma shows how preregularity is used.
Lemma 5.1 If Σ= (S, F, ≤) is preregular, then for all sorts s1, s2 ∈ S and terms
t ∈ TΣ(X),
t ∈ TΣ(X)s1 ∩ TΣ(X)s2 ⇐⇒ (∃s ∈ glbΣ(s1, s2)) t ∈ TΣ(X)s
where glbΣ(s1, s2)= sup≤({ s ∈ S | s ≤ s1 ∧ s ≤ s2 }).
Proof. If there is a sort s ∈ glb(s1, s2) such that t ∈ TΣ(X)s, then t ∈ TΣ(X)s1 ∩ TΣ(X)s2 as s ≤ s1 and s ≤ s2. We still must show that t ∈ TΣ(X)s1 ∩ TΣ(X)s2 implies that there is a sort s ∈ glb(s1, s2) such that t ∈ TΣ(X)s.  However, this
follows immediately as t must have a least sort sj ∈ S. It must be the case that sj ≤ s1 and sj ≤ s2. Therefore, there is an s ∈ glb(s1, s2) such that sj ≤ s. As TΣ(X)s∗ ⊆ TΣ(X)s, it follows that t ∈ TΣ(X)s.	2
Lemma 5.2 For all terms f (t1,.  , tn) ∈ TΣ(X) and sorts s ∈ S,
f (t1,.	, tn) ∈ TΣ(X)s
⇐⇒ (∃s1 ... sn ∈ arΣ(f, s, n)) t1 ∈ TΣ(X)s1 ∧	∧ tn ∈ TΣ(X)sn
where arΣ(f, s, n)= sup≤n ({ w ∈ Sn | (∃sj ∈ S) f ∈ Fw,s∗ ∧ sj ≤ s }).
Proof. If there are sorts s1 ... sn ∈ arΣ(f, s, n) such that ti ∈ TΣ(X)si for i ∈
[1, n], then there must be a sort sj ≤ s such that f ∈ Fs ...s ,s∗ . It follows that
1	n
f (t1,..., tn) ∈ TΣ(X)s∗ , and thus f (t1,..., tn) ∈ TΣ(X)s.

On the other hand, if f (t1,..., tn) ∈ TΣ(X)s, then there is some sj ≤ s such
that f ∈ Fs∗ ...s∗ ,s∗ and ti ∈ TΣ(X)s∗ for i ∈ [1, n]. It follows that there are sorts
1	n	j i
s1 ... sn ∈ arΣ(f, s, n) such that si ≤ si for i ∈ [1, n]. Consequently, ti ∈ TΣ(X)si
for i ∈ [1, n].	2
For a membership constraint M , we define the unifiers for M , denoted UnΣ(M ) to be the set of unsorted substitutions θ : X → TΣ(X) such that for each membership t : s ∈ M , tθ ∈ TΣ(X)s.
Lemma 5.3 For each order-sorted signature Σ= (S, F, ≤) and pair of membership constraints M1 and M2,
M1 ≥ M2 =⇒ UnΣ(M1) ⊇ UnΣ(M2).
Proof. To show that UnΣ(M1) ⊇ UnΣ(M2), we must show for each substitution θ ∈ UnΣ(M2) and membership t : s ∈ M1, we have tθ ∈ TΣ(X)s. However, since M1 ≥ M2, we know that for each t : s ∈ M1, there is a membership t : sj ∈ M2 such that sj ≤ s. By definition tθ ∈ TΣ(X)s∗ , and therefore tθ ∈ TΣ(X)s.	2
When the membership constraints M1 and M2 are reduced, the previous impli- cation holds in the other direction.
Lemma 5.4 For each order-sorted signature Σ = (S, F, ≤) and pair of reduced membership constraints M1 and M2 such that vars(M1)= vars(M2),
UnΣ(M1) ⊇ UnΣ(M2) =⇒ M1 ≥ M2
Proof. Since both M1 and M2 are reduced and vars(M1)= vars(M2), to show that M1 ≥ M2, it is sufficient to show that for each x ∈ vars(M1), sortM1 (x) ≥ sortM2 (x). Since M2 is reduced, there is a substitution ρM2 : vars(M2) → TΣ(X) which maps each variable x ∈ vars(M2) to the a fresh variable xj with sort sortM (x) ∈ S. Clearly ρM2 ∈ UnΣ(M2), and so ρM2 ∈ UnΣ(M1) by assumption. It follows that for each x ∈ vars(M2) that sortM1 (x) ≥ sortM2 (x) since xρM2 is a variable with sort sortM2 (x) and xρM2 ∈ UnΣ(M2).	2
For a disjunctive set of membership constraints D, we let UnΣ(D) denote the set of unsorted substitutions that are unifiers for a set of membership constraints

M ∈ D, i.e.,
UnΣ(D)= 
M∈D

UnΣ(M ).

The key correctness property of the inference rules in Fig. 1 is captured by the following lemma.
Lemma 5.5 For an preregular order-sorted signature Σ, if D1 →∗ D2 using the inference rules in Fig. 1, then UnΣ(D1)= UnΣ(D2).
Proof. To show this it is enough to show the single step case that D1 → D2 implies
UnΣ(D1)= UnΣ(D2). The full lemma follows easily by induction on the number of

rules used to show D1 →∗ D2. To show the single step case, we must consider three separate cases, one for each of the inference rules in Fig. 1.
If Intersection is used, we know that D1 and D2 have the forms D1 = { t : s1 ∧ t : s2 ∧ M }∪ D and D2 = Ss ∈ glbΣ(s1,s2){ t : s∧ M }∪ D. However, for each order- sorted substitution θ we know by Lemma 5.1 that tθ ∈ TΣ(X)s1 ∩TΣ(X)s2 iff there is a sort s ∈ glbΣ(s1, s2) such that tθ ∈ TΣ(X)s. It follows that Un(D1) = Un(D2).
If Propagation is used, we know that D1 and D2 have the forms D1 =
{ f (t1,..., tn): s∧M }∪D and D2 = Ss1...sn∈arΣ(f,s){ t1 : s1∧·· ·∧tn : sn∧M }∪D.
However, for each order-sorted substitution θ we know by Lemma 5.2 that
f (t1θ, ..., tnθ) ∈ TΣ(X)s iff there are sorts (s1 ... sn) ∈ arΣ(f, s) such that
tiθ ∈ TΣ(X)si for i ∈ [1, n].
If Subsumption is used, we know that D1 and D2 have the forms D1 =
{ M1, M2 } ∪ D and D2 = { M1 } ∪ D where M1 ≥ M2. However, it follows easily that Un(D1) = Un(D2) as for each substitution Un(M2) ⊆ Un(M1) by Lemma 5.3.
2
In order to preserve the set of substitutions, we also need to show that the inference rules do not discard variables or introduce new ones:
Lemma 5.6 If D1 →∗ D2 using the inference rules in Fig. 1 and each set of mem- bership constraints M1 ∈ D1 has the same variables vars(M1) = X, then for all M2 ∈ D2, vars(M2)= X.
Proof. This is a straightforward induction over the number of rewrites used to show
D1 →∗ D2 and considering each rule separately.	2
The following lemma is useful to show that the inference rules terminate with a unique set of membership constraints.
Lemma 5.7 If D1 and D2 are both disjunctive sets of membership constraints that are irreducible by the inference rules in Fig. 1, then UnΣ(D1) = UnΣ(D2) implies D1 = D2.
Proof. We show this by showing that D1 /= D2 implies Un(D1) /= Un(D2). If D1 /= D2, then there must be a conjunction of membership constraints M1 which is in D1 \ D2 or D2 \ D1. We assume that the M1 is in D1 as the other case is symmetric. Since the rules in Fig. 1 cannot be applied to D1, we know that M1 must be reduced, and hence has the form M1 = x1 : s1 ∧ ··· ∧ xn : sn with xi /= xj for each i /= j. Let ρM1 denote the substitution mapping each variable x ∈ vars(M1)
to a fresh variable xρM1 with sort sortM1 (x) ∈ S. By definition ρM1 ∈ UnΣ(M1)
and therefore ρM1 ∈ Un(D1). If ρM1 /∈ Un(D2), then Un(D1) /= Un(D2), and consequently we are done. Otherwise, ρM1 is in Un(D2), and so there must be a membership M2 ∈ Un(D2) such that for each membership x : s ∈ M2 there is a membership x : sj ∈ M1 with sj ≤ s.  It follows that M2 ≥ M1.  Since D1 is
fully reduced by the rules in Fig. 1, it follows that the substitution ρM2 is not in

UnΣ(D1), since this would imply that there is a mapping M ≥ M2 ≥ M1 in D1. This is impossible since D1 has been fully reduced by the rules in Fig. 1.	2
Using the previous lemmas, it is not difficult to show the following Termina- tion Theorem which shows that the inference rules terminate with a unique set of membership constraints.
Theorem 5.8 (Termination Theorem) For each disjunctive set of membership constraints D, there is a unique set of membership constraints D∗ such that D →! D∗ using the inference rules in Fig. 1.
Proof. Showing this requires proving that: (1) the rules in Fig. 1 are terminating and (2) if D →! D1 and D →! D2, then D1 = D2. The rules in Fig. 1 are terminating, because each rewrite either reduces the size of a term in a membership, or preserves the terms while reducing the total number of memberships. To show (2), observe that if D →! D1 and D →! D2, then UnΣ(D1)= UnΣ(D)= UnΣ(D2) by Lemma 5.5. Therefore, D1 = D2 by Lemma 5.7.	2
We are now ready to conclude with a proof of the main theorem of the paper:
Theorem 5.9 Let E = (Σ, E) denote a preregular and sort-independent order-sorted theory, then given a unification problem Γ with a complete set of most-general sort- preserving unsorted unifiers U, OS(U ) is a complete set of most-general order-sorted unifiers for Γ.
Proof. Since E is sort-independent, we can assume that E can be partitioned into rewrite rules R and equations A such that R is confluent and terminating modulo
A. Moreover, we can assume that each substitution θ ∈ U is R/A-irreducible. Proving the above theorem requires showing three things: (1) each element of
OS(U ) is an order-sorted unifier for Γ; (2) the set of unifiers OS(U ) is complete; (3)
the set of unifiers OS(U ) is most-general. We show each of these facts separately.

For each element θ ∈ OS(U ), there is an unsorted unifier θ ∈ U and reduced membership constraints M ∈ D(θ)∗ such that θ = θρM . We first show that xsθ ∈ TΣ(X)s for each variable xs ∈ vars(Γ). To see this, observe that by defini- tion ρM ∈ UnΣ(D(θ)∗), and so by Lemma 5.5, ρM ∈ UnΣ(D(θ)). Furthermore, by Lemma 5.6, we know that vars(M ) = vars(D(θ)) = vars(Γ). It follows by definition that for each variable xs ∈ vars(Γ), xθ = xθρM is in TΣ(X)s. For each equation t = u in Γ, we know that both t and u are well-sorted terms belonging
to the same component. It follows that tθ and uθ are well-sorted terms with the same connected component. By definition tθ =£ uθ, and as E is sort-independent it follows that tθ =£ uθ.

To show that OS(U ) is complete, we must show for each order-sorted unifier ψ ∈ Un£ (Γ), there is a unifier θ ∈ OS(U ) and order-sorted substitution φ : rvars(θ) → TΣ(X) such that xψ =£ xθφ for each x ∈ vars(Γ). Let ψ be a unifier in Un£ (Γ). As U is a complete set of sort-preserving unifiers, there is an unifier θ ∈ U such that ψ =£ θφ for some unsorted substitution φ : Y → TΣ(X) with



Y = rvars(θ). Moreover, since xsψ ∈ TΣ(X)s for each variable xs ∈ vars(Γ), we can assume that xsθφ ∈ TΣ(X)s since U is sort-preserving.
It follows that φ ∈ UnΣ(D(θ)). By Lemma 5.5 and Theorem 5.8, there must be a reduced set of membership constraints M ∈ D(θ)∗ such that
(∀x ∈ Y ) xφ ∈ TΣ(X)sortM (x).	(1) Since M is reduced, there is a variable renaming ρM with maps each variable
x ∈ Y to a fresh variable xj with sort sortM (x).  Let ρ−1 denote the inverse
of that renaming. By using (1), it should be clear that ρ−1; φ is an order- sorted substitution. Moreover, as ρM ∈ UnΣ(M ) and therefore in UnΣ(D(θ)) by Lemma 5.5, θ; ρM must be an order-sorted substitution. Since θ; ρM ∈ OS(U ) and ψ = (θ; ρM ); (ρ−1; φ), it follows that OS(U ) is a complete set of unifiers.
To show that OS(U ) is a most-general set of unifiers, we must show for all distinct substitutions θ1, θ2 ∈ OS(U ), we have θ1 /≥ θ2. We prove this by contradiction. Assume there are substitutions θ1, θ2 ∈ OS(U ) and a substitution ψ : Y → TΣ(X) such that θ1 = θ2; ψ, where Y denotes the variables in the right-hand side of θ2. Since both θ1 and θ2 are in OS(U ), we know they must have the form θ1 =
θ1; ρM1 and θ2 = θ2; ρM2 with θ1, θ2 ∈ U , M1 ∈ D(θ1) , and M2 ∈ D(θ2) . Our
∗	∗
assumption θ1 = θ2; ψ implies that θ1 = θ2; (ρM ; ψ; ρ−1 ). Since U is most-general,
2	M1
this can only be the case if θ1 = θ2. As we assumed that θ1 = θ2; ψ, it is not
difficult to show that ψ = ρ−1 ρM . For each variable x ∈ Y , we know that the sort
M2	1
of the variable xρ−1 ρM  is sortM (xρ−1 ), and sortM (xρ−1 ) ≤ sortM (xρ−1 ) since

M2	1
1	M2
M2
M2

ψ is an order-sorted substitution. It follows that M2 ≥ M1 which is impossible since both M1, M2 ∈ D(θ1)∗ and D(θ1)∗ have been fully normalized using the inference rules in Fig. 1.
2

Conclusions and Related Work
There is a considerable amount of research already in unification in theories with sorts and subsorts (e.g., [1,7,9,12,14,15]) due to the improved expressiveness of order- sorted algebras and ability to simplify automated reasoning. The use of rule-based al- gorithms in describing unification has a long history as well with the most well-known example being Martelli and Montanari’s algorithm for syntactic unification [10]. Our use of a rule-based approach to order-sorted unification is not particularly novel; however we wanted to revisit order-sorted equational unification after discovering that the soundness for the AC and ACI unification problems we were trying to solve did not follow from previous results.
Since our initial implementation of order-sorted unification in the Maude-NRL analyzer, an order-sorted unification engine has been included in the most recent Maude release [2]. This unification engine makes similar assumptions about the supported theories, however it has better performance as it will no longer need to parse unsorted unifiers back as strings, and can more tightly integrate the order-

sorted constraints into the core unification routines. This engine uses BDDs to symbolically solve the sort constraints, and has the advantage that the subsumption checks can be handled automatically by the BDD generation-algorithms.
Our aim in this paper is more general than the Maude-based applications of our algorithm. Our aim is one of modularity, so that different formal tool building efforts
needing equational order-sorted unification procedures may be able to modularly decompose such a procedure into its unsorted part where several existing tools may be used and the rule-based sort propagation algorithm that we have presented and
proved correct.

Acknowledgement
The authors would like to thank the referees for comments which helped to improve the paper.

References
Boudet, A., Uniﬁcation in order-sorted algebras with overloading, in: D. Kapur, editor, Proc. of CADE 1992, Lecture Notes in Comp. Sci. 607 (1992), pp. 193–207.
Clavel, M., F. Durán, S. Eker, S. Escobar, P. Lincoln, N. Martí-Oliet, J. Meseguer and C. L. Talcott, Uniﬁcation and narrowing in Maude 2.4, in: R. Treinen, editor, RTA, Lecture Notes in Computer Science 5595 (2009), pp. 380–390.
Contejean, E. and C. Marché, CiME: Completion modulo E, in: H. Ganzinger, editor, Proc. of RTA’96, Lecture Notes in Comp. Sci. 1103 (1996), pp. 416–419.
Contejean, E., C. Marché, B. Monate and X. Urbain, CiME 2, Available at: http://cime.lri.fr.
Escobar, S., J. Hendrix, C. Meadows and J. Meseguer, Diﬃe-Hellman cryptographic reasoning in the Maude-NRL protocol analyzer, in: Proc. of SecRet 2007, 2007.
Escobar, S., C. Meadows and J. Meseguer, Equational cryptographic reasoning in the Maude-NRL protocol analyzer, Electr. Notes Theor. Comput. Sci. 171 (2007), pp. 23–36.
Gallier, J. and T. Isakowitz, Order-sorted rigid E-uniﬁcation, Technical Report STERN IS-91-40, Stern School of Business at New York University (1991), available at http://hdl.handle.net/2451/14397.
Goguen, J. A. and J. Meseguer, Order-sorted algebra i: Equational deduction for multiple inheritance, overloading, exceptions and partial operations, Theor. Comput. Sci. 105 (1992), pp. 217–273.
Kirchner, C., Order-sorted equational uniﬁcation, Presented at the fifth International Conference on Logic Programming (Seattle, USA) (1988), also as rapport de recherche INRIA 954, Dec. 88.
Martelli, A. and U. Montanari, An eﬃcient uniﬁcation algorithm, ACM Trans. Program. Lang. Syst.
4 (1982), pp. 258–282.
Meseguer, J., Membership algebra as a logical framework for equational speciﬁcation, in: F. Parisi- Presicce, editor, Proc. of WADT’97, Lecture Notes in Comp. Sci. 1376 (1997), pp. 18–61.
Meseguer, J., J. A. Goguen and G. Smolka, Order-sorted uniﬁcation, J. Symbolic Computation 8 (1989),
pp. 383–413.
Plotkin, G., Building-in equational theories, Machine Intelligence 7 (1972), pp. 73–90.
Walther, C., Many-sorted uniﬁcation, J. ACM 35 (1988), pp. 1–17.
Weidenbach, C., Uniﬁcation in sort theories and its applications, Annals of Mathematics and Artificial Intelligence 18 (1996), pp. 261–293.
