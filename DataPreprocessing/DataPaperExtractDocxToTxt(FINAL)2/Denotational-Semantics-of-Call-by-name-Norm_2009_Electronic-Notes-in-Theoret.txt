

Electronic Notes in Theoretical Computer Science 225 (2009) 161–179
www.elsevier.com/locate/entcs

Denotational Semantics of Call-by-name Normalization in Lambda-mu Calculus
Vladimir Komendantsky1,2
INRIA Sophia Antipolis 2004 rte Lucioles, B.P. 93
06902 Sophia Antipolis cedex, France

Abstract
We study normalization in the simply typed lambda-mu calculus, an extension of lambda calculus with control flow operators. Using an enriched version of the Yoneda embedding, we obtain a categorical normal form function for simply typed lambda-mu terms, which gives a special kind of a call-by-name denotational semantics particularly useful for deciding equalities in the lambda-mu calculus.
Keywords: Yoneda embedding, categorical semantics, categories of continuations, lambda-mu calculus, normalization, partial equivalence relations


Introduction
We study normalization of terms in the simply typed λμ-calculus introduced by Parigot in [13]. This calculus is an extension of the simply typed λ-calculus with operators that influence the sequential control flow during the evaluation of a term. The primary reason for this extension was to provide a constructive notion of a classical natural deduction proof. Moreover, subsequent studies showed that the λμ-calculus can also be realized as a calculus of continuations, and that control operators of certain functional programming languages can be formalized by means of its μ-abstraction mechanism. A very instructive discussion of possible meanings of λμ-terms can be found in [14], §4.2. The suggested background reading in λ- calculus is [2] and [9].
Our approach to normalization is based on a categorical technique called the normalization by the Yoneda embedding, whose motivation is clearly explained in

1 Funded by the Boole Centre for Research in Informatics postdoc grant and the Royal Society & Royal Irish Academy grant “Category theory and nature inspired models of computation”.
2 Email: Vladimir.Komendantsky@sophia.inria.fr

1571-0661/© 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.12.072

Introduction to the paper [4]. This technique employs category theory, and our reference on this subject is Mac Lane’s book [10].
Before embarking in the technical exposition we would like to discuss some important topics which are particularly relevant in the context of our paper.
Continuations and classical logic. Continuations in programming languages generalize the notion of a control flow. In functional languages continuations are es- pecially important tools providing rich expressivity. A characteristic example is the operator call-with-current-continuation, or call/cc, of the language Scheme. A common approach to semantics of languages with continuations (such as those providing labels and jumps, e.g., our simply typed λμ-calculus) involves a transla- tion of a given language into a language that represents continuations as functions. Such translations are known as continuation passing style (CPS) translations. Stud- ies of continuations in programming languages and CPS translations of λ-calculus commenced in early 70’s (the relevant references could be found in [16]); e.g., in 1975 Plotkin introduced a call-by-name variant of the CPS translation. Notably, the well-known Go¨del’s and Kolmogoroff’s ¬¬-translations of classical logic into intuitionistic one correspond, on the level of propositions-as-types, respectively to call-by-name CPS translation with values and call-by-value CPS translation, which were studied starting from mid 80’s by Felleisen and his co-workers in relationship to the λ-calculus with control operator, cf. [16]. In our paper we employ yet another CPS translation, an elegant call-by-name CPS translation studied in [8,6,14] which was motivated by Lafont’s ¬¬-translation of classical logic into the ¬∧-fragment of intuitionistic logic. Classical logic has several variants of proof-theoretic seman- tics given by the above mentioned translations of classical into constructive logic; such semantics were studied, e.g., in [5,11,12,16]. Our work can also be seen as a contribution to those studies of proof-theoretic semantics of classical logic.
Minimal-sized definition for response categories and categories of con- tinuations. Our normalization method is based on an enriched case of categories of continuations. These categories are traditionally constructed from so-called cate- gories of responses, as it was done, e.g., by Selinger in [14]. Categories of responses are essentially a categorical version of CPS semantics of λ-calculus. In [15] Selinger remarks on the minimal-sized definition for categories of responses. The enriched version of a category of responses we define in this paper is in fact based on the minimal-sized definition from the latter source. In our case the minimality is crucial since redundancies in the definition of a category of responses, such as presence of coproducts, can lead to a failure of the normalization function. This can happen because the Yoneda embedding which is used extensively in our semantics does not preserve coproducts. Therefore our definition of an enriched response cate- gory corresponds to a simple generalization of a cartesian closed category without coproducts, in which only a single fixed object is required to have exponentials.
Denotational semantics of the λμ-calculus. Lambda calculus is usually introduced as a theory of computable functions. The relationship of this theory to actual functions, e.g., functions between sets, is established by means of a suitable denotational semantics. Denotational semantics gives meaning to a language, in

our case the simply typed λμ-calculus, by assigning mathematical objects as values to its terms. If M is a λμ-term, we will write  M ) for the meaning of M under a given interpretation function −), and ≡ will be some congruence relation on interpretations (≡ can be an equality, but in general it suffices to be just a decidable congruence relation such as α-congruence). Consider some equality predicate =t on λμ-terms. Given a particular interpretation function, soundness is the property that M =t N implies M ) ≡ N ). Then completeness is the property M ) ≡ N ) implies M =t N .
The decision problem for the λμ-calculus can be formulated as follows: For any possibly open λμ-terms M and N of type A, an object context Γ, and a control context Δ, decide whether M =Γ,Δ N , where =Γ,Δ denotes the equality of λμ-terms in the context of Γ and Δ. With each λμ-term M in context Γ, Δ we associate its abstract normal form nfΓ,Δ(M ), for which there exists a reverse function fnΓ,Δ from normal forms to terms, such that the following properties hold:
(NF1)	fnΓ,Δ(nfΓ,Δ(M )) =Γ,Δ M,
(NF2)	M =Γ,Δ N	implies	nfΓ,Δ(M ) ≡ nfΓ,Δ(N ).
Note that nf is allowed not to be injective and hence there is no inverse function nf−1 in general. Since the conditions (NF1) and (NF2) imply M =Γ,Δ N if and only if nfΓ,Δ(M ) ≡ nfΓ,Δ(N ) (that is the soundness and completeness property), comparing such abstract normal forms can yield a denotational semantics and a decision procedure for the λμ-calculus, with (NF1) corresponding to the complete- ness property and (NF2) corresponding to the soundness property. Our (NF1) and (NF2) are similar to those appeared in [1] and applied there to normalization by the Yoneda embedding in simply typed λ-calculus with coproducts. However, our categorical techniques are different from those of [1].
Normalization by the Yoneda embedding and normalization by eval- uation. The fact that normalization by the Yoneda embedding is closely related to the algorithm of normalization by evaluation due to Berger and Schwichtenberg
[3] was noted in [4]. The correspondence is that the free interpretation, ß−J in our notation, corresponds to the “evaluation functional” of [3], and the components ι and ι−1 of the natural isomorphism between the interpretation of generators by
the Yoneda embedding and its free extension ß−J correspond respectively to the functionals “procedure → expression”, p→e, and “make self evaluating”, mse. The difference of course is that, unlike in the normalization by evaluation method, in normalization by Yoneda one does not mention any rewriting techniques.
In Sec. 2, following Kelly [7] we give definitions for a special instance of enriched category theory, category theory enriched over the category with objects being sets equipped with partial equivalence relations and morphisms being functions preserving these relations. Specifically, in §2.4 we develop an enriched version of categories of continuations. The idea of such an enrichment appeared in [4]; however, our definitions are different and in fact are just instances of more general definitions given by Kelly. In Sec. 3, we define the simply typed λμ-calculus, the call-by-name CPS translation and the categorical interpretation function. The aim of Sec. 3 is

to show how the λμ-calculus can be embedded into the λR×-calculus. Finally, in Sec. 4 we obtain the normal form function for simply typed λμ-terms. In §4.3, we characterize the obtained normal form function and sketch the proofs for soundness and completeness theorems, thus showing that our normal form function induces a special kind of a call-by-name denotational semantics for the λμ-calculus which is particularly useful for deciding equalities in the λμ-calculus.

PSet-enriched category theory
Per-sets and PSet-categories
A per-set A is a pair A = (|A|, ∼A), where |A| is a set and ∼A is a partial equiva- lence relation (per) on |A|. A per-function between the per-sets A = (|A|, ∼A) and B = (|B|, ∼B) is a function f : |A|→ |B| such that a ∼A a' implies f (a) ∼B f (a'), for all a, a' ∈ |A|.
Specifically, we will need the following kinds of per-sets:
the one-point per-set 1 = ({∗}, ∼1), where ∗ ∼1 ∗;
the cartesian product of two per-sets A and B, that is the per-set A × B = (|A| × |B|, ∼A×B), where ⟨a, b⟩ ∼A×B ⟨a', b'⟩ if a ∼A a' and b ∼B b', for all a, a' ∈ |A| and b, b' ∈ |B|;
the exponential of a per-set B by a per-set A, that is the per-set BA = (|B||A|, ∼BA ), where f ∼BA g if, for all a, a' ∈ |A|, a ∼A a' implies f (a) ∼B g(a'), for all f, g ∈ |B||A|.
A cartesian category is a category with finite products and the terminal ob- ject. A cartesian closed category (ccc) C is a cartesian category in which each functor −× A : C → C has a right adjoint (−)A.
Per-sets and per-functions form a cartesian closed category, denoted PSet0, whose objects are (small) per-sets and whose morphisms are per-functions between per-sets. The cartesian closedness of PSet0 means that there is an adjunction
PSet0(C × A, B) ∼= PSet0(C, BA),	(1)

which is a bijection natural in C and B, with unit d : C → (C × A)A and counit
e : BA × A → B.
A PSet-enriched category (or, shorter, a PSet-category) A consists of
a set ob(A) of objects,
a hom-object A(A, B) ∈ ob(PSet0), for each pair of objects of A (the elements of the hom-object are called morphisms from A to B),
a per-function ◦ = ◦A,B,C : A(B, C) × A(A, B) → A(A, C), for each triple of objects A, B, C ∈ ob(A) (called the composition law of A, B, C),
and a per-function id = idA : 1 → A(A, A), for each object A ∈ ob(A) (called the identity element of A);

each of the above subject to the associativity and unit axioms expressed by the commutativity of the following two diagrams:

(A(C, D) × A(B, C)) × A(A, B)	a	A  ( C, D) × (A(B, C) × A(A, B))

◦×1
A(B, D) J (A, B)

A(C, D)
1×◦
J (	)

×A ¸¸¸¸¸¸
¸¸¸¸¸¸¸¸
,,,,,
,,,,,
×A A, C

¸¸¸¸z_
,,,,,	◦



and
A(A, D)_.

A(B, B) × A(A, B)   ◦	 A (A, B) ¸,◦  A(A, B) × A(A, A)

(2)

(3)

,,
id×1
,,,, ¸
,,,
¸¸¸¸¸¸
¸¸¸¸
,,
1×id

,,,,	l
1 × A(A, B)
r	¸¸¸
A(A, B) × 1

For PSet-categories A and B, a PSet-functor F : A→B consists of
a function F : ob(A) → ob(B),
and, for each pair A, B ∈ ob(A), a map FA,B : A(A, B) → B(FA, FB);
subject to the compatibility with composition and identities expressed by the com- mutativity of


A(B, C) × A(A, B) 	◦	 A (A, C)
and	A(A, A)
id ssss¸,
(4)

F×F
J 
F
	   J 
sss
ss
F

B(FB, FC) × B(FA, FB)  ◦
B(FA, FC)
I ¸¸¸¸
¸¸¸¸

id ¸¸z J 
B(FA, FA)
The PSet-functor F : A → B is said to be fully faithful if each FA,B is an isomorphism.
For PSet-functors F, G : A → B, a PSet-natural transformation α : F → G : A → B is an ob(A)-indexed family of components αA : 1 → B(FA, GA) satisfying the PSet-naturality condition expressed by the commutativity of

1 × A(A, B) 	αB×F	 B( FB, GB) × B(FA, FB)

l−1,,,,, ¸
,,,,,
A(A, B)
¸¸¸
¸¸¸
¸¸¸¸¸¸¸
¸◦¸¸¸¸¸¸
z_
B(FA, GB)
,,,,,_ 
,,,

r−1	¸¸z˛
,,,,,	◦

A(A, B) × 1
G×αA
 B( GA, GB) × B(FA, GA)

(5)

For α :  F → G :  A → B and β :  G → H :  A → B, their “vertical” composite

β ◦ α has the component (β ◦ α)A given by
1 ∼= 1 × 1 βA×αA	(GA, HA) × B(FA, GA) −→◦  B(FA, HA)	(6)
−−−−−→B 

The composite of α with Q : B → C has for its component (Qα)A the composite

1 αA	Q
−−→ B(FA, GA) −−→ C(QFA, QGA)	(7)

while the composite of α with R :  D → A has for its component (αR)D simply
αRD.
Given two PSet-categories A and B, and two PSet-functors F : A→B and U : B → A, a PSet-adjunction between F (the left adjoint) and U (the right adjoint) consists of PSet-natural transformations η : 1 → FU (the unit) and ε : UF → 1 (the counit) satisfying the equations Fε ◦ ηF = 1 and εU ◦ Uη = 1.

The PSet-category PSet
Now we will give the standard argument in the style of [7] to exhibit the PSet- category PSet.
Lemma 2.1 There isa PSet-category PSet, whose objects are per-sets and where
PSet(A, B) = BA.
Proof. Putting C = 1 in the adjunction (1), using the isomorphism l : 1 × A ∼= A, and writing P for the ordinary set-valued functor PSet0(1, −) : PSet0 → Set, we get the natural isomorphism
PSet0(A, B) ∼= P (BA).	(8)
which gives an equivalence between PSet0 and the underlying ordinary category of the PSet-category, which we will denote PSet, whose objects are those of PSet0, and whose hom-object PSet(A, B) is BA. Since BA is thus exhibited as a lifting through P of the hom-set PSet0(A, B), it is the internal hom of A and B of PSet. The important point here is that the internal hom of PSet makes PSet itself into a PSet-category. Its composition law ◦ : BA × AC → BC corresponds under (1) to the composite


(BA × AC) × C −a→ BA × (AC × C) −−1×−→e
BA × A −→e
B	(9)

and the identity element idA : 1 → AA corresponds under (1) to l : 1 × A → A. Verification of the axioms (2) and (3) is easy since the definition (9) of ◦ is equivalent to e(◦× 1) = e(1 × e)a.	 

The PSet-functor category BA and the PSet-enriched Yoneda lemma
Let A and B be PSet-categories. The PSet-functor category BA is defined as follows:

objects of BA are all PSet-functors from A to B;
for two such functors F, G : A → B, their hom-object BA(F, G) is a per-set of ob(A)-indexed families of components αA in |B(FA, GA)|, with the per on families defined by α ∼BA(F,G) β if α and β satisfy the PSet-naturality condition and, for all A, αA ∼B(FA,GA) βA;
◦F,G,H(α, β) is defined componentwise by ◦F,G,H(α, β)A = ◦F A,GA,HA(αA, βA);
idF : 1 → BA(F, F ) is defined componentwise by (idF )A = idFA.
We define the PSet-enriched Yoneda functor Y : A → PSetAop by YA = A(−, A). Below we instantiate Kelly’s V-enriched (strong) Yoneda lemma [7] with our data. The parameter V becomes PSet. The Yoneda lemma is given for reference purposes, and hence without proof which can be found in [7] (for the case of the covariant Yoneda functor). In this paper we use the Yoneda lemma by way of its Corollary 2.3.
Lemma 2.2 (PSet-enriched Yoneda) Let A be a PSet-category, K an object of A, and F : Aop → PSet. The transformation φA : FK → (F A)Y KA, PSet- natural in A, expresses FK as the equalizer

PSetAop
(Y K, F ) −−−E−−→

Y KA	ρ
−−−−−−→

 (FB)Y KA

 Aop(A,B)

A∈ob(A)
σ	A,B∈ob(A)

where ρA,B and σA,B are the transformations of (F−)Y KA 


A,B
and  (FB)Y K− 


B,A

respectively; so that we have the following isomorphism PSet-natural in K and F:
φ : FK ∼= PSetAop (Y K, F ).
Corollary 2.3 For any PSet-category A, the PSet-functor Y : A → PSetAop is fully faithful.
Due to this corollary Y is called the PSet-enriched Yoneda embedding. The fact that it is full justifies that a morphism YA → YB in PSetAop is essentially the same as A → B in A. Note that PSetAop always exists since, by definition, A is locally small (its hom-objects are small per-sets).

PSet-categories of continuations
A PSet-category of responses is a PSet-category C with finite products and exponentials of the form RA for a fixed object of responses R and any object A of C. The latter means that there is a canonical isomorphism
C(B, RA) ∼= C(B × A, R)	(10)

PSet-natural in A.
Given a PSet-category of responses C (and the exponentiable object R of C), we construct its PSet-category of continuations CR as follows:

objects of CR are n-tuples of objects of C, for n ≥ 0;
for all A = ⟨A1,..., An⟩ and B = ⟨B1,..., Bm⟩ in ob(CR), their hom-object
CR(A, B) is C(  i RAi ,  j RBj ).
Therefore CR is the full subcategory of C on objects of the kind RA1 × ··· × RAn , which we abbreviate to RA. It follows that, in CR, the composition ◦A,B,C : CR(B, C) × CR(A, B) → CR(A, C) coincides with the composition ◦RA,RB,RC : C(RB, RC) × C(RA, RB) → C(RA, RC) in C, and the identity element idA : 1 →
CR(A, A) coincides with the identity element idRA : 1 → C(RA, RA) in C. Thus CR
satisfies the axioms of PSet-categories (2) and (3) in the trivial way.
We note that PSet-categories of continuations are cartesian closed PSet-categories.
Indeed, given CR, one has finite products in CR as a consequence of it being a full
subcategory of C. Next, if A = ⟨A1,..., An⟩ and B = ⟨B1,..., Bm⟩ then the ob-
ject BA =  j RBj×Qi R	is their exponential in C, and thus C	is closed under
Ai

exponentiation, and there is an isomorphism
PSet(  RCk ×  RAi ,  RBj ) ∼= PSet(  RCk ,  RBj×Qi RAi ),	(11)
k	i	j	k	j
PSet-natural in Ck and Bj, giving rise to a PSet-adjunction with unit η and counit
ε, respectively:
η :  RCk →  RCk×Qi RAi ×  RAi×Qi RAi ,
k	k	i
ε :   RBj×Qi RAi ×   RAi →   RBj .
j	i	j
Hence we will use standard notation for the PSet-categorical analogues of structural ccc-morphisms.
Given two PSet-categories of continuations CR and DR' , and a PSet-functor from the first to the second, an obvious question arises about whether F in its image preserves the structure of the first category, for instance, whether the ex- ponentiable object of responses retains its qualities in the image. We make this precise in the following definition. Given two PSet-categories of continuations CR and DR' , a PSet-functor of PSet-categories of continuations, or, in short, a PSet-coc functor, is a PSet-functor F : CR → DR' , together with PSet-natural isomorphisms, for n ≥ 0,


R
⟨A1,...,An⟩
: R'F A1 × ··· × R'F An −−∼=→ F

(RA1 × ··· × RAn )

(12)

×
A1,...,An
:	R'F A1×···×FAn −−∼=→ R
'F (A1×···×An)

commuting with the morphism structure in all the evident ways. Note that despite some notational clumsiness arising from the presence of the exponentiable object,

the meaning of the isomorphisms is very clear since rR
1	n
is an element of the

hom-object
DR' (⟨F A1,...,FAn⟩,F⟨A1,..., An⟩),

×
A1,...,An
is an element of the hom-object
DR' (F A1 ×· · · × F An,F (A1 ×· · · × An)).


In the following we will be especially interested in actions of the Yoneda embed- ding Y on a PSet-category of continuations CR. In this situation the image of Y on CR is a PSet-category which will be later shown to be a PSet-category of contin- uations. However, it is more convenient to define Y not just on CR but on C itself, so we have Y : C → PSetCop , where PSetCop is obtained as a usual PSet-functor category and is clearly a PSet-category of responses with the object of responses being YR = C(−, R). As for the corresponding PSet-category of continuations, denoted PSetCop , we obtain it as follows 3 :
objects of PSetCop are n-tuples ⟨YA ,...,Y A ⟩, for n ≥ 0 and ⟨A ,...,A ⟩ ∈ 
Y R	1	n	1	n
ob(CR);

hom-objects of PSetCop are PSetCop (⟨YA ,...,Y A ⟩, ⟨YB ,...,Y B
⟩) = 

Y R	Y R	1	n	1	m
PSetCop ((Y R)Y A1 × · · · × (Y R)Y An , (Y R)Y B1 × · · · × (Y R)Y Bm ), for n, m ≥ 0,
⟨A1,..., An⟩∈ ob(CR) and ⟨B1,..., Bm⟩∈ ob(CR);
the composition law and the identity element are defined in the obvious way;
the object of responses is YR = C(−, R) ∈ ob(PSetCop ).
The statement about the object of responses might seem not straightforward, there- fore we will give it some more attention. Note that in PSetCop the object of re- sponses YR = C(−, R) is isomorphic to (Y R)Y 1 = C(−, R)C(−,1) since Y 1 is terminal in PSetCop . Also observe that, for any A ∈ ob(C), the isomorphism C(−, RA) ∼= C(−, RA)C(−,1) ∼= C(−, R)C(−,A) holds. This allows one to consider the full subcate- gory of PSetCop on objects of the kind C(−, R)C(−,A1) ×···× C(−, R)C(−,An), which is precisely our PSetCop . The result can be stated in the following lemma.
op
Lemma 2.4 For a PSet-category of continuations CR, the PSet-category PSetC
is a PSet-category of continuations with the object of responses being C(−, R) ∈
ob(PSetCop ).
The Yoneda embedding Y : C → PSetCop restricts on C	to a PSet-functor
op
YR : CR → PSetC	which consists of

a function Y
: ob(C ) → ob(PSetCop ) which sends an n-tuple ⟨A ,...,A ⟩ to

R	R	Y R	1	n

the n-tuple ⟨Y A1,...,Y An⟩;
for each pair of tuples A, B ∈ ob(C ), a map (Y )	: C (A, B) → PSetCop (Y

A, Y B)

R	R A,B	R
Y R	R	R

which sends each f ∈ CR(A, B) = C(RA1 × ··· × RAn , RB1 × ··· × RBm ) to
Yf ∈ PSetCop ((Y R)Y A1 ×· · ·× (Y R)Y An , (Y R)Y B1 ×· · ·× (Y R)Y Bm ), and such that, for f, g ∈ CR(A, B), YR(f ) ∼ YR(g) if and only if f ∼ g.
This YR is not actually the Yoneda embedding any more, but it is still an embed- ding and, moreover, a PSet-coc functor since one has the required PSet-natural

3 The notation PSetCop is handy but ambiguous in that Y R can be understood differently; the only correct understanding is [Cop, PSet]YR.

isomorphisms in PSetCop due to the fact that Y preserves finite products:


rR	:  C(−, R)C(−,A1) ×· · ·× C(−, R)C(−,An)  ∼=
(−, RA1 × ··· × RAn )

⟨A1,...,An⟩
−−→C 

r×	:	C(−, R)C(−,A1)×···×C(−,An)  ∼=
(−, R)C(−,A1×···×An)

A1,...,An

Hence one has the following lemma.
−−→C 

Lemma 2.5 Let C be a PSet-category of responses with the object of responses R,
op
so that CR is a PSet-category of continuations. The restriction YR : CR → PSetC
of the PSet-categorical Yoneda embedding Y : C → PSetCop on the full subcategory
CR is a PSet-coc functor.

λμ-calculus
Syntax of the λμ-calculus
Let σ, σ1,... range over a set ΣT of type constants.  Types, ranged over by
A, B, ... , are constructed by the grammar:

A ::= σ | BA |⊥ 

Let Vo and Vc be two given countable disjoint sets of object variables x, y, . . . and control variables α, β, . . . , respectively. Let ΣK be a set of typed object con- stants cA, cB,... The pair (ΣT , ΣK) is called a signature of the λμ-calculus, and denoted by Σ. Terms, ranged over by M, N, . . . , are constructed by the grammar:

M ::= x | cA | MN | λxA.M | [α]M | μαA.M

Terms of the form MN , λxA.M , μαA.M and [α]M are called respectively an ap- plication, a λ-abstraction, a μ-abstraction and a named term. In the terms λxA.M and μαA.M , the object variable x, respectively the control variable α, is bound.
Now we define typing of the λμ-calculus. An object context is a finite, possibly empty sequence Γ = x1:B1, x2:B2,..., xn:Bn of pairs of an object vari- able and a type, such that xi /= xj, for all i /= j. A control context Δ = α1:A1, α2:A2,..., αm:Am is defined analogously. A typing judgement is an ex- pression of the form Γ ▶ M : A | Δ. Such a judgement has an interpretation in sequent calculus for classical logic, with ▶ interpreted as entailment symbol (for- mally corresponding to implication) and | interpreted as disjunction. Valid typing judgements are derived using the typing rules in Table 1. An equation is an expression of the form Γ ▶ M = N : A, where Γ ▶ M : A | Δ and Γ ▶ N : A | Δ are valid typing judgements. We do not discuss here what a valid equation could be because we use an analogous notion of call-by-name equivalence introduced in
§3.2.


if x:A ∈ Γ
Γ ▶ x : A | Δ	Γ ▶ cA : A | Δ

Γ ▶ M : BA | Δ	Γ ▶ N : A | Δ Γ ▶ MN : B | Δ
Γ, x:A ▶ M : B | Δ


Γ ▶ λxA.M : BA | Δ

Γ ▶ M : A | Δ


Γ ▶ [α]M : ⊥| Δ Γ ▶ M : A | Δ
Γ' ▶ M : A | Δ'
if α:A ∈ Δ	Γ ▶ M : ⊥| α:A, Δ Γ ▶ μαA.M : A | Δ
if Γ ⊆ Γ', Δ ⊆ Δ'

Table 1
Typing rules of the λμ-calculus


Call-by-came continuation passing style translation
Consider the λμ-calculus over a given signature Σ = (ΣT , ΣK). We will review the call-by-name semantics of this calculus by the continuation passing style (CPS) translation obtained in [6] and [14]. The target language of the CPS translation is a λR×-calculus, that is a λ-calculus with products and a distinguished type R of responses. We assume that the target calculus has
a type constant σ˜ for each type constant σ ∈ ΣT of the λμ-calculus;
a pair of types KA (the type of continuations of type A) and CA (the type of computations of type A) for each type A of the λμ-calculus, defined as follows:

Kσ = σ˜ 
CA = RKA
where σ is a type constant

KBA = CA × KB K⊥ =1 
a constant c˜ for each object constant cA ∈ ΣK of the λμ-calculus;
a distinct variable x˜ and a distinct variable α˜ for each object variable x and each control variable α, respectively.
The call-by-name CPS translation M of a typed term M is given in Table 2.


x = λkKA .x˜k	where x : A cA = λkKA .c˜k
MN  = λkKB .M⟨N, k⟩	where M : BA, N : A λxA.M = λ⟨x˜, k⟩KBA .Mk		where M : B
[α]M = λkK⊥ .M α˜	where M : A
μαA.M = λα˜KA .M ∗	where M : ⊥

Table 2
The call-by-name CPS translation of the λμ-calculus

As can be easily seen, the CPS translation respects the typing in the sense that a judgement of the λμ-calculus
x1:B1,..., xn:Bn ▶ M : A | α1:A1,..., αm:Am	(13)

is translated to the judgement of the λR×-calculus
x˜1:CB1 ,..., x˜n:CBn , α˜1:KA1 ,..., α˜m:KAm ▶ M : CA .	(14)
Analogously, it respects the typing of equations. Therefore we can consistently use the notation Γ ▶ M : A | Δ for the translation of a typing judgement, and Γ ▶ M = N : A | Δ for the translation of an equation.
Let M and N be the terms of the λμ-calculus such that Γ ▶ M : A | Δ and Γ ▶ N : A | Δ. We say that M and N are call-by-name equivalent, and then write M =Γ,Δ N , if Γ ▶ M = N : A | Δ, that is if the CPS translation of M is βη-equivalent in the context to the CPS translation of N . The call-by-name λμ-theory determined by a λR×-theory T is then defined to be the set of all equations E of the λμ-calculus such that E ∈T .

Categorical call-by-name interpretation of the λμ-calculus
The target λR×-calculus of the above call-by-name CPS translation will now be interpreted in a PSet-category of responses C. We give the PSet-enriched general- ization of the construction that was originally developed for the ordinary category case in [6] and [14].
Since the CPS translation is type respecting, a typing λμ-judgement of the form
(13) gives rise to a morphism in C: CB1 ×··· ×CBn ×KA1 ×··· ×KAm → CA, which in turn, using CA = RKA and then using the canonical isomorphism (10), amounts to a morphism RKB1 × ··· × RKBn → RKA×KA1 ×···×KAm , which now lies within the PSet-category of continuations CR. Note that we do not mention the computation types of the form CA any more. Henceforth we will simply write A instead of KA in the context of the CPS translation.
Let CR be a PSet-category of continuations, and let Σ = (ΣT , ΣK) be the signature of the λμ-calculus. Assume now a choice of an object σ˜ ∈ ob(C) for every type constant σ ∈ ΣT . Each type constructor is interpreted by the corresponding object constructor of PSet-categories of continuations:
 σ) = σ˜,	where σ is a type constant,

 BA) = R A) × B),
 ⊥) = 1
(15)

If Γ = x1:B1,..., xn:Bn is an object context, its interpretation in the PSet-category of continuations C is R B1) ×· · ·×R Bn) which we abbreviate simply to  i R Bi), and we denote the l-th projection map by π :   R Bi) → R Bl). If Δ = α :A ,..., α :A
is a control context, its interpretation in C is R A1)×···× Am), abbreviated to RQj Aj ),

and we denote its l-th weakening map by wl = Rπl : R Al) → RQj Aj ). As- sume also a choice in CR of a morphism c˜ : 1 → R A) for each object constant cA ∈ ΣK. Now we can interpret a typing judgement Γ ▶ M : A | Δ as a morphism
 A)×Q  Aj )
 Γ ▶ M : A | Δ) :  i R Bi) → R	j	which can be abbreviated to M ) when
the context allows. The inductive definition for the PSet-categorical interpretation is given in Table 3.



 Γ ▶ xl

: Bl
| Δ) =  R Bi) πl i

 Bl) −→w
R Bl)×Qj Aj )

 Γ ▶ cA : A | Δ) =  R Bi) −→0
i
1 −→c˜
R A) −→w
R A)×Qj Aj )

 Γ ▶ MN : B | Δ) =  R Bi) ⟨ M ), N )⟩
R A)× B)×Qj Aj ) × R A)×Qj Aj )

i
εQj Aj )

 B)×Q  A )

−−−−−→ R	j	j

Γ	A	:
A  Δ = 
 B )  M )∗
R A)× B)×Q  A )

▶ λx .M  B	|	)	R i −−−→ R	j	j
i

Γ	[  ]	:	Δ = 
 B )  M )
 A  )×Q  A  )   (wl)Qj  Aj )
Q  A )×Q  A )

▶ αl M
⊥|	)
R i −−→ R l	j	j −−−−−−−→ R j	j	j	j
i

(Qj id A ),Qj id A )⟩	Q
∼=	Q

−−−−−−−−−−−−−−→ R
j Aj ) −→ R1×
j Aj )

 Γ ▶ μαA.M : A | Δ) =  R Bi)  M )
1× A)×Qj Aj ) −→∼= R
 A)×Q  Aj )

i

Table 3
The call-by-name interpretation of the λμ-calculus in a PSet-category of responses

Until now the description of the PSet-categorical interpretation did not differ from the ordinary categorical one [14] in any significant way. But the present in- terpretation does differ if one considers λμ-theories. In this case we define partial equivalence relations between morphisms to be given by the call-by-name equiva- lence in a λμ-theory, with the composition law defined componentwise, and with the obvious choice of identity elements (each of these being the unique morphism from a fixed variable of a given type to itself). This will be made precise in the definition of a syntactic PSet-category of continuations in 4.1. Meanwhile, analogously to the case of the ordinary categorical interpretation (cf. [14], Lemma 5.4) we relate the CPS and the PSet-categorical interpretations of the λμ-calculus by the following lemma, which can be proved by the straightforward induction on the complexity of λμ-terms.
Lemma 3.1 Given a PSet-category of continuations CR, the PSet-categorical call- by-name interpretation of the λμ-calculus in CR coincides with the interpretation of the call-by-name CPS translation in CR.
From this lemma we immediately obtain the following soundness and complete-

ness result for λR×-theories (whose corresponding ordinary category case is Propo- sition 5.5 of [14]).
Corollary 3.2 The λR×-theories induced on the λμ-calculus by the PSet-categorical call-by-name interpretation are precisely the λR×-theories induced by the call-by- name CPS translation.
Therefore λμ-theories intuitively can be seen as embedded into λR×-theories, and interpreted semantically as λR×-theories of a special kind.

Categorical semantics of normalization in λμ-calculus
Syntactic PSet-category of continuations and canonical call-by-name inter- pretation of the λμ-calculus
Let x be a fixed object variable. We say that a λR×-judgement is in standard form if it has the form
x:A1 × ··· × An ▶ M : B1 ×· · · × Bm,

that is if the object context declares exactly the one variable x.	Every λR×- judgement x1:RA1 ,..., xn:RAn ▶ M : RB1 × ··· × RBm has a standard form
x:RA1 ×· · · × RAn ▶ (λx1 ... xn.M )(π1x) ... (πnx) : RB1 ×· · · × RBm .	(16)

Therefore the call-by-name CPS translation of every λμ-judgement has a yet simpler standard form
x:RA1 ×· · · × RAn ▶ (λx1 ... xn.M )(π1x) ... (πnx) : RB.	(17) Using the notion of a standard form, we will define structural operations of
PSet-categories of continuations in a way similar to defining structural operations
of cartesian closed categories by typing judgements of simply typed lambda calculus. The following lemma can be easily checked case by case.
Lemma 4.1 The structural operations of a PSet-category of responses C with the object of responses R are deﬁned by the operations on typing judgements shown in Table 4, with pers on hom-objects deﬁned by id ∼ id, 0 ∼ 0, πl ∼ πl, ε ∼ ε,
 Γ ▶ M : A | Δ) ∼ Γ ▶ N : A | Δ) if M and N are call-by-name equivalent, and such that all the operations respect ∼.
The following lemma is just an instantiation of Lemma 4.1 (see also Lemma 5.6 of [14] for a closely related case of the structural operations of control categories).
Lemma 4.2 The structural operations of a PSet-category of continuations CR are deﬁned by the operations on typing judgements shown in Table 5, with pers on hom- objects deﬁned by id ∼ id, 0 ∼ 0, πl ∼ πl, ε ∼ ε, Γ ▶ M : A | Δ) ∼ Γ ▶ N : A | Δ) if M and N are call-by-name equivalent, and such that all the operations respect ∼.



id =x:A ▶ x : A
0 =x:A ▶∗ : 1
π =x:  A ▶ π x : A
f = x:A ▶ M : B	g = x:B ▶ N : C


g ◦ f = x:A ▶ (λxB.N )M : C
f = x:A ▶ M : B	g = x:A ▶ N : C



l	i	l	l
i
⟨g, f⟩ = x:A ▶ ⟨M, N⟩ : B × C
f = x:A × B ▶ M : RC

ε =x:RA×B × A ▶ (π1x)(π2x) : RB


f∗ = x:A ▶ λyB.(λxA×B.M )⟨x, y⟩ : RB×C


Table 4
Operations of a PSet-category of responses on typing judgements



id =	A	A
f = x:RA ▶ M : RB	g = x:RB ▶ N : RC

x:R  ▶ x : R
0 =x:RA ▶∗ : 1
 


g ◦ f = x:RA ▶ (λxRB .N )M : RC
f = x:RA ▶ M : RB	g = x:RA ▶ N : RC

πl =x:	RAi ▶ πlx : RAl
i


⟨g, f⟩ = x:RA ▶ ⟨M, N⟩ : RB × RC
f = x:RA × RB ▶ M : RC

ε =x:RRA×B × RA ▶ (π x)(π x) : RB 	
1	2	f∗ = x:RA ▶ λyRB .(λxRA×RB .M )⟨x, y⟩ : RRB×C

Table 5
Operations of a PSet-category of continuations on typing judgements


Given a λμ-signature Σ = (ΣT , ΣK), we construct the syntactic PSet-category of continuations CΣ as follows. First, we define its underlying PSet-category of responses CΣ to consist of
objects  n	Ai, for n ≥ 0, where either Ai ∈ ΣT ∪ {R} or Ai = RB, for B an
object;
hom-objects CΣ(A, B) containing an element f ∈ CΣ(A, B), for each well-typed standard form λR×-judgement x:A ▶ M : B, with the per of morphisms from A to B being the least per containing id ∼ id (if A = B), 0 ∼ 0 (if B = 1), πl ∼ πl (if B = Al), ε ∼ ε (if A = RC ×C and B = R), Γ ▶ M : A | Δ) ∼ Γ ▶ N : A | Δ) if M and N are call-by-name equivalent, and closed under the structural operations of PSet-categories of responses shown in Table 4;
for each triple of objects A, B, C, the composition law ◦ = ◦A,B,C defined com- ponentwise: for f = (x:A ▶ M : B) and g = (x:B ▶ N : C), their composition is g ◦f = (x:A ▶ (λxB.N )M : C), — and interacting with pers of the corresponding hom-objects as follows: for f, f' ∈ CΣ(A, B) and g, g' ∈ CΣ(B, C), it holds that
g ◦ f ∼CΣ(A,C) g' ◦ f' if and only if f ∼CΣ(A,B) f' and g ∼CΣ(B,C) g';
for each object A, the identity element id = idA = (x:A ▶ x : A).
Second, we construct the required syntactic PSet-category of continuations CΣ as
follows:
objects are n-tuples of objects of CΣ, for n ≥ 0;

for A, B ∈ ob(CΣ), their hom-object CΣ(A, B) = CΣ(⟨A1,..., An⟩, ⟨B1,..., Bm⟩)
R	R	R
is the hom-object CΣ(RA1 ×· · ·× RAn , RB1 ×· · ·× RBm ) of the underlying PSet-
category of responses, named by x:RA ▶ M : RB;
composition laws and identity elements are borrowed from CΣ as usual.
There is a free call-by-name interpretation  −)0 (sometimes also called a canonical call-by-name interpretation) of the λμ-calculus with signature Σ in

CΣ, defined by σ˜
= σ and
c˜ = x:1 ▶ c : RA, for each cA ∈ ΣK.  It has the

property that the interpretation of each typing judgement is call-by-name equivalent to its standard form. The pair (CΣ, −)0) is determined up to isomorphism by the following universal property: For each call-by-name interpretation −) in DR' , which agrees with −)0 on generators, there is a unique (up to PSet-natural isomorphism) PSet-coc functor
Q : CΣ → DR'	(18)
such that Q A)0 = A) for all λμ-types A, and Q Γ ▶ M : A | Δ)0 = Γ ▶ M : A |
Δ) for all well-typed judgements Γ ▶ M : A | Δ.
Σ	0
Assume that H : CR → DR' is another PSet-coc functor such that H −) =
 −). We will exhibit a PSet-natural isomorphism ι : Q → H by induction on the complexity of an object of CΣ using the structural PSet-natural isomorphisms rR
and r× from (12):

ι⟨⟩ = rR,	ι−1 = 0H⟨⟩,	ι⟨σ⟩ = ι−1 = id⟨σ⟩,	ι⟨1⟩ = ι−1 = id⟨1⟩,
⟨⟩	⟨⟩	⟨σ⟩	⟨1⟩
ι  A  = rR (ι	ε⟨π1, ι−1 π2⟩)∗,	ι−1	= (ι−1(Hε)r×	⟨π1,ι	π2⟩)∗,

⟨R ⟩
⟨A⟩
⟨1⟩
⟨A⟩
⟨RA⟩
⟨1⟩
RA,A
⟨A⟩
(19)

ι⟨A ×···×A ⟩ = ι⟨A ⟩ ×· · · × ι⟨A ⟩,	ι−1
= ι−1
×· · · × ι−1 ,

1	n	1
n	⟨A1×···×An⟩
⟨A1⟩
⟨An⟩

ι⟨A ,...,A ⟩ = ⟨ι⟨A ⟩,..., ι⟨A ⟩⟩,	ι−1
= ⟨ι−1
,..., ι−1 ⟩,

1	n	1	n
⟨A1,...,An⟩
⟨A1⟩
⟨An⟩


where n > 1. The above given components of ι define the required PSet-natural isomorphism. The fact is easy to establish by checking the condition (5) routinely.


The normal form function
Henceforth let Y denote the PSet-categorical Yoneda embedding Y : CΣ → PSet(CΣ)op
defined as in 2.3 and discussed further in 2.4. Recall that YR is the restriction of Y
on CΣ. We let ß−J : CΣ → PSet(C )	be the PSet-coc functor freely extending the
R	R	Y R 
interpretation of base types by YR. We deliberately chose the bracketed notation for the free extension functor to emphasize the fact that ß−J is also an interpretation (moreover, a free interpretation) and, besides, to improve readability.
By the universal property of the pair (CΣ, −)0), there is a natural isomorphism
∼=	R
ι : ß−J −→ YR. Hence, by Corollary 2.3, for each hom-object of CΣ, we can construct

the inverse of the interpretation ß−J on this hom-object according to the diagram


CΣ(A, B) 	ß−J	 P Set(CΣ)op (
)	(20)

R	¸,¸¸¸¸
¸¸¸
¸¸¸¸Y¸R¸
Y R 
     
     
ßAJ, ßBJ

— (id
)¸¸¸¸¸¸
 ι	−1

A	A	¸¸¸
¸¸¸¸z 
op
     
 s
B ◦ ß−J ◦ ιA

PSet(CΣ)  (Y
R
A, YRB)


Hence, for any f ∈ CΣ(A, B), we obtain a PSet-natural transformation


ι−1
ßf J	ι

YA −−A→ ßAJ −−→ ßBJ −→B YB 

which, if further evaluated at A, gives


ι−1
CΣ(A, A) −−A−,→A
ßf JA
ßAJA −−−→

ιB,A
ßBJA −−−→
CΣ(A, B).


Thus we define the normal form function to be
nf(f ) = ιB,A(ßf JA(ι−1 (idA))),	(21)
where f ∈ CΣ(A, B) is a morphism named by a λR×-judgement x:RA ▶ M : RB, and idA is the morphism named by x:RA ▶ x : RA. Note that in (21) we could equally write the judgements naming the morphisms f and idA. The “functional” notation nf(f ) is especially handy if we note that the typing contexts are implicitly given in f , thus one should not write them explicitly.
In the setting of a syntactic PSet-category of continuations CΣ, nf is a per- function on λR×-terms (and not just a function on βη-convertibility classes of λR×- terms, as it would be if one considered only the underlying ordinary categories).

Characterization of categorical normal forms
We will check whether our nf from 4.2 satisfies the characteristic properties (NF1) and (NF2) from Introduction.
Recall from 3.2 that, for λμ-terms M and N , we write M = N if M and N are call-by-name equivalent. Without loss of generality we assume that interpretations of λμ-terms in the syntactic PSet-category of continuations CΣ are given in their
standard forms.
Theorem 4.3 (Completeness, NF1) There is a function fn from abstract nor- mal forms to terms such that, for a well-typed λμ-judgement Γ ▶ M : C | Δ, it holds that fn(nf( Γ ▶ M : C | Δ)0)) =Γ,Δ M.
Proof (sketch). Let Γ = x1:A1,..., xn:An, Δ = α1:B1,..., αm:Bm and f =

 Γ ▶ M : C | Δ)0, and let f ∈ CΣ(A, B) be of the form
x:RA1 ×· · · × RAn ▶ (λx1 ... xn.M )(π1x) ... (πnx) : RC×B1×···×Bm
(by our global assumption interpretations are given in standard form). Since CΣ has the canonical structure of PSet-categories of continuations, we can use induction on the complexity of M to prove that nf(f ) ∼ g for some g in standard form:
g  = x:RA1 × ··· × RAn ▶ (λx1 ... xn.N )(π1x) ... (πnx) : RC×B1×···×Bm .

Since nf is a per preserving function, it follows that f ∼ g, i.e., the λR×-term naming f is βη-equivalent to the λR×-term naming nf(f ). Therefore M and N are βη-equivalent, and hence M and N are call-by-name equivalent. Thus we can put fn(nf( Γ ▶ M : C | Δ)0)) := N .	 
In the following soundness theorem we employ the method developed in [4], Section 3.4, for proving the uniqueness property of categorical normal forms there. We modify this method to suit the case of PSet-categories of continuations.
Theorem 4.4 (Soundness, NF2) If M and N are of type C, and M =Γ,Δ N, it holds that nf( Γ ▶ M : C | Δ)0) ≡ nf( Γ ▶ N : C | Δ)0).
Proof. Let f = Γ ▶ M : C | Δ)0, g = Γ ▶ N : C | Δ)0 and f, g ∈ CΣ(A, B). Let CΣ,≡ denote the PSet-category of continuations which has the same objects and the same underlying sets of morphisms as CΣ, but whose pers ≡ on morphisms are given by α-congruence on terms naming the morphisms. Observe that the PSet-category of responses CΣ,≡ is already given with CΣ,≡ by construction. By analogy with (20),
consider a PSet-coc functor ß−J≡ : CΣ → PSet(CΣ,≡)op freely extending the inter-
R	Y R 
pretation of objects of CΣ by Yoneda Y ≡ : CΣ → PSet(CΣ,≡)op . Being a PSet-coc
R	R	R
functor, ß−J≡ is such that f ∼ g implies ßf J≡ ≡ ßgJ≡. By the universal property of (CΣ, −)0), it holds that ιB,Aßf J≡ι−1 (idA) ≡ ιB,AßgJ≡ι−1 (idA). Clearly, the
R	A A,A	A A,A
ordinary categories underlying PSet(CΣ)op and PSet(CΣ,≡)op have the same structure
Y R	≡ Y R 
of categories of continuations. Therefore ιB,Aßf JAι−1 (idA) = ιB,Aßf JAι−1 (idA)
A,A	A,A
and ιB,AßgJ≡ι−1 (idA) = ιB,AßgJ ι−1 (idA). Hence nf(f ) ≡ nf(g).	 
A A,A	A A,A
Conclusions
We have shown that the method of normalization by the Yoneda embedding [4,1] can be successfully applied to the problem of normalization of simply typed λμ- terms. We obtained a solution for this problem by developing an apparatus of categories of continuations enriched over the category of sets with partial equivalence relations and functions preserving these relations. As a result we constructed a sound and complete denotational semantics of call-by-name normalization in simply typed λμ-calculus. An important role in this semantics was played by the call-by- name continuation passing style translation obtained in [6,14].

Future research should be dedicated to algorithmization of the soundness and completeness theorems (for the purpose of extracting functional programs from soundness and completeness proofs) and to extensions of the normalization method onto more expressive calculi such as the simply typed λμ-calculus with products and coproducts.
Acknowledgement
I wish to thank my joint grantholders Anthony Seda and John Power for their support, encouragement and helpful discussions.

References
Altenkirch, T., P. Dybjer, M. Hofmann and P. Scott, Normalization by evaluation for typed lambda calculus with coproducts, in: 16th Annual IEEE Symposium on Logic in Computer Science (LICS’01) (2001), pp. 303–.
Barendregt, H. P., “The lambda calculus,” Studies in logic 103, North-Holland, 1984.
Berger, U. and H. Schwichtenberg, An inverse to the evaluation functional for typed λ-calculus, in:
Proc. 6th Annual IEEE Symp. on Logic in Computer Science, 1991, pp. 203–211.
Cˇubri´c, D., P. Dybjer and P. Scott, Normalization and the Yoneda embedding, Mathematical Structures in Computer Science 8 (1998), pp. 153–192.
Griffin, T. G., A formulae-as-types notion of control, in: Proc. 17th ACM/SIGACT-SIGPLAN Symp. Principles of Programming Languages (POPL), 1990.
Hofmann, M. and T. Streicher, Completeness of continuation models for λμ-calculus, Information and Computation 179 (2002), pp. 332–355.
Kelly, G. M., “Basic concepts of enriched category theory,” London Mathematical Sosciety Lecture Notes 64, Cambridge University Press, 1982, published online in Reprints in Theory and Applications of Categories, No. 10, 2005.
Lafont, Y., B. Reus and T. Streicher, Continuation semantics or expressing implication by negation, Technical Report 93–27, University of Munich (1993).
Lambek, J. and P. J. Scott, “Introduction to higher-order categorical logic,” Cambridge Studies in Advanced Mathematics 7, Cambridge University Press, Cambridge, 1988, first paperback (with corrections) edition.
Mac Lane, S., “Categories for the Working Mathematician,” Springer-Verlag, 1971.
Ogata, I., A proof theoretical account of continuation passing style, in: Proc. CSL’02, LNCS (2002),
pp. 490–505.
Ong, C.-H. L., A semantic view of classical proofs: Type-theoretic, categorical, and denotational characterizations, in: Proc. 11th Annual IEEE Symp. on Logic in Computer Science, 1996, pp. 230–241.
Parigot, M., λμ-calculus: an algorithmic interpretation of classical natural deduction, in: A. Voronkov, editor, Proc. Intl. Conf. Logic Programming and Automated Reasoning, LNAI 624 (1992), pp. 190–201.
Selinger, P., Control categories and duality: on the categorical semantics of the lambda-mu calculus, Math. Struct. Comp. Science 11 (2001), pp. 207–260.
Selinger, P., Some remarks on control categories, Preprint (2003).
Streicher, T. and B. Reus, Classical logic: Continuation semantics and abstract machines, Journal of Functional Programming 8 (1998), pp. 543–572.
