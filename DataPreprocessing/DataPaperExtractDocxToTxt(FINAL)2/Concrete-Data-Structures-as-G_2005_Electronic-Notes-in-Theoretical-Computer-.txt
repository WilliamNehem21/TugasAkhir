Electronic Notes in Theoretical Computer Science 122 (2005) 193–210 
www.elsevier.com/locate/entcs


Concrete Data Structures as Games
Andrea Schalk1 and Jos´e Juan Palacios-Perez2
Department of Computer Science University of Manchester
United Kingdom

Abstract
A result by Curien establishes that filiform concrete data structures can be viewed as games. We extend the idea to cover all stable concrete data structures. This necessitates a theory of games with an equivalence relation on positions. We present a faithful functor from the category of concrete data structures to this new category of games, allowing a game-like reading of the former. It is possible to restrict to a cartesian closed subcategory of these games, where the function space does not decompose and the product is given by the usual tensor product construction. There is a close connection between these games and graph games.
Keywords: Linear logic, games, concrete data structures, sequential computation

Concrete data structures were introduced by Kahn and Plotkin [9] as a domain for computation. There is a close connection between certain kinds of concrete data structures, namely those with a linear dependency between cells, and a simple category of games (with an intuitionistic rather than linear func- tion space)—these categories are equivalent. This result is established in [4]. The main of this paper is to extend the result to non-linear data structures. However, rather than extending it to all concrete data structures we have to limit ourselves to the stable case. Our result requires the introduction of a new category of games. Here positions within the game can be identified, and that limits the number of possible strategies similar to the conflict-freeness condition for graph games. We define a functor from the category of stable concrete data structures to this new category of games. By characterizing its image we exhibit a subcategory of the latter which is equivalent to the former.

1 Email:A.Schalk@cs.man.ac.uk
2 Email:palacioj@cs.man.ac.uk



1571-0661 © 2005 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2004.06.058

Background
Notation. If A is a subset of B, and r is a word over the alphabet B then we write r|A for the word that arises by removing all those letters from r which are not in A. Given words r, r' over the same alphabet we write rr' for their concatenation, r ∧ r' for their greatest joint prefix and if r is a prefix of r' we write r Ð r'. We extend the concatenation notation to sets of symbols and use ( )∗ for the Kleene star. Given a set S of words over some alphabet we use pre(S) for the prefix closure of S.
We allow ourselves to view both A and B as subsets of their sum A + B. Where this could cause confusion (for example in the sum A + A), we use the injections inl and inr.
Games
We describe a simple category of games.
Definition 1.1 A game A consists of
two disjoint sets AP (of Player or P-moves) and AO (of Opponent or O- moves);
a prefix-closed subset pos(A) of the language pre((AOAP )∗) (the game tree).
Hence a position in a game A is a word in pre((AOAP )∗) which belongs to the game tree, that is an element of pos(A). A position is a P-position if its last move is a P -move, and otherwise it is an O-position. In other words, P - positions are the even length words in the language pos(A) while O-positions are the odd length ones. We use posP (A) to refer to the set of all P -positions and similarly for posO (A).
The set pos(A) can easily be seen as a tree whose edges are labelled by moves and whose nodes correspond to positions, that is the elements of pos(A). The ‘initial position’ or root of the tree is given by the empty word. For r, r' ∈ pos(A) we sometimes write r −→ r' if there is a letter a such that r' = ra. A play of the game A is a word in pos(A) (or a path from the root in the game tree).
Definition 1.2 A strategy (for Player) for a game A is a prefix-closed sub- language α of pos(A) with the following properties:
If r ∈ pos(A) is an O-position and ra, ra' are two positions in α then a = a'
(this is known as determinacy);
if r ∈ pos(A) is a P -position in α then all ra ∈ pos(A) are also in α.
We sometimes write α : A if α is a strategy for A. If we think of pos(A)


as a (game) tree then a strategy α must be a subtree. A play in accord with a strategy α on A is a word in α.
Definition 1.3 The linear function space A  B of two games has
sets of moves (A  B)O = AP + BO, (A  B)P = AO + BP , and
game tree pos(A  B)= {t ∈ pre(((A  B)O(A  B)P )∗) | t|A ∈ pos(A),
t|B ∈ pos(B)}.
In the usual way a (linear) morphism from A to B in our category of games is a strategy on A  B. We solve the problem of composition. Let
ξ : A 	) B and ζ : B 	) C. We define a joint sequence in accord with ξ
and ζ to be a word w over the alphabet AP + AO + BP + BO + CP + CO such that
w|A+B is a play in accord with ξ and
w|B+C is a play in accord with ζ.
We define the composite to be
ζ ◦ ξ = {w|A+C | w is a joint sequence in accord with ξ and ζ}.
It is easy to show that if t is a position in ζ ◦ξ then there is a unique minimal joint sequence in accord with ξ and ζ, say w, with w|A+C = t. Further, if t Ð t' and w and w' are the respective minimal joint sequences then w Ð w'. The identity on a game A is given by the ‘copycat’ strategy, where Player copies Opponent’s moves from one copy of A to the other. This composition can also be described as a relational composition by using a faithful functor to the category of sets and relations, see [6].
Definition 1.4 The tensor product A ⊗ B of two games has
sets of moves (A ⊗ B)O = AO + BO, (A ⊗ B)P = AP + BP , and
game tree pos(A ⊗ B)= {t ∈ pre(((A ⊗ B)O(A ⊗ B)P )∗) | t|A ∈ pos(A),
t|B ∈ pos(B)}.
Definition 1.5 The product A × B of two games A and B has
sets of moves (A × B)O = AO + BO and (A × B)P = AP + BP ;
positions pos(A + B)= pos(A) ∪ pos(B).
The terminal game 1 is the game which has no moves.
This defines a well-known symmetric monoidal closed category Gaml. We can define a linear exponential comonad in the sense of [8] so that the resulting Kleisli category Gam is cartesian closed. The linear exponential is due to


Lamarche and Curien (see for example [4]). Further Gaml embeds faithfully into Gam.
Concrete data structures
Concrete data structures were introduced by Kahn and Plotkin [9] as a par- ticular kind of computation domain. Their intended use was as a semantic universe for programming languages. Since then, they have been used to un- derstand sequentiality in a number of ways. Accounts can be found in [2,3].
Definition 1.6 A concrete data structure (cds) R = (C, V, ev(R), ▶) has
a set C (of cells);
a set V (of values) disjoint from C;
a relation ev(R) ⊆ C × V (of events);
a relation ▶ between finite sets of events and cells (the enabling relation).
We assume without further comment that the enabling relation is well- founded in the sense of [2].
Definition 1.7 A state ρ of a concrete data structure R is a set of events with the following properties:
If (c, v) and (c, v') are both in ρ then v = v' (this is known as consistency).
For all (c, v) in ρ there are (c1, v1, ), ..., (cn, vn)= (c, v) in ρ such that for all 1 ≤ i ≤ n, {(c1, v1),... , (ci−1, vi−1)} contains an enabling of ci (this is known as safety).
We typically use st(R) to refer to the set of all states of R, and stf(R) for the set of all finite states of R. We sometimes write ρ : R to indicate that ρ is a state of R. Given a set of events ρ we say that a cell c is enabled but not ﬁlled in ρ provided that ρ contains an enabling of c and c does not occur in ρ. When we translate cdss into games we want to view the cells as Opponent and the values as Player moves. In particular we want to establish a reading of a sequence of events satisfying the safety and consistency conditions as a
play which is a string in pre((CV )∗).
On the other hand, given a string r ∈ pre((CV )∗) we can obtain a subset of C × V which we refer to as [r♩ by setting
[r♩ = {(c, v) ∈ C × V | ∃r' ∈ (CV )∗. r'cv Ð r}.
Under the right circumstances, [r♩ will be a set of events or even a state.
A run of a cds R is a word r in pre((CV )∗) such that for each prefix r' of
r

[r'♩ is a state;
if r' = r''c has odd length then c is enabled but not filled in [r''♩.
A run of a state ρ of R is a run r of R such that [r♩ ⊆ ρ. We can recover a state from the set of all its runs. We can think of the enabling relation as specifying that some events must have taken place before others can occur— we are given some information about possible sequentializations of states. In general there will be many ways of sequentializing a state, that is, for a given state ρ there will be a number of runs r such that [r♩ = ρ. Some of the substrings of such an r will be freely interchangeable, because nothing that occurs in the one substring depends on anything occurring in the other. When we turn cdss into games and states into strategies we do this in terms of such sequentializations.
Definition 1.8 We say that a cds is stable if for all enablings x ▶ c, x' ▶ c such that there is a state containing both, x and x', there is x'' ⊆ x ∩ x' with x'' ▶ c.
We find it convenient to assume that all cdss are stable and will do so from now on without further notice.
Definition 1.9 The function space R ⇒ S of two cdss R = (C, V, ev(R), ▶) and S = (D, W, ev(S), ▶) has
cells: stf(R) × D;
values: C + W ;
events: all pairs
((ρ, d), c) such that c is enabled but not filled in ρ,
((ρ, d), w) such that (d, w) is an event in S;
enablings: all instances of
((ρ, d), c) ▶ (ρ', d)
such that there exists v ∈ V with ρ' = ρ ∪ {(c, v)}, and
((ρ1, d1), w1),... , ((ρn, dn), wn) ▶ (ρ, d)
such that ρ = ρ1 ∪ ··· ∪ ρn and (d1, w1),... , (dn, wn) ▶ d in S.
A morphism of cdss from R = (C, V, E, ▶) to S = (D, W, F, ▶) is a state of the function space. We can view such a morphism as a set of instructions which allows us to use information (values in cells from R) in the left hand game in order to fill cells in the right hand game.


It is non-trivial to define composition. We give a brief account here which is taken from [2]. Given a state φ in R ⇒ S one can define a partial function
gφ : stfR × D	~ C + W, 
that is a partial function from cells of R ⇒ S to values of the same cds. This works by setting
gφ(ρ, d)= z iff ∃ρ' ⊆ ρ with ((ρ', d), z) ∈ φ and ((ρ, d), z) an event in R ⇒ S.
Such a gφ is known as an ‘abstract algorithm’. Given g : stfR × D	~ C + W
there exists φ : R ⇒ S with g = gφ if and only if the following hold:
If g(ρ, d)= z then ((ρ, d), z) is an event in R ⇒ S.
If g(ρ, d)= z and if there is ρ' ⊇ ρ such that ((ρ', d), z) is an event in R ⇒ S
then g(ρ', d)= z.
If g(ρ, d) is defined then d is enabled in {(d', w) | g(ρ, d')= w}, and if there is ρ' ⊆ ρ such that d is also enabled in {(d', w) | g(ρ', d')= w} then g(ρ', d) is also defined.
We can recover φ from gφ
φ = {((ρ, d), x) | gφ(ρ, d)= x and ρ is minimal with that property}.
In order to compose abstract algorithms we have to note that a state
φ : R ⇒ S defines a function st(φ): st(R)   ) st(S) by setting
st(φ)(ρ)= {(d, w) ∈ ev(S) | ∃ρ' ⊆ ρ. ((ρ', d), w) ∈ φ}.
Given two states φ : R ⇒ S and ψ : S ⇒ T the standard definition of their composite is to give the corresponding abstract algorithm, which is


(gψ
g )(ρ, e)= ⎧⎨ x	gψ(st(φ)(ρ), e)= x

⎩ c	gψ(st(φ)(ρ), e)= d and gφ(ρ, d)= c.
The identity of a cds R is described by



gidR
(ρ, c)= ⎧⎨ v	(c, v) ∈ ρ
⎩ c	(c, v) /∈ ρ.


There is an alternative definition of composition with a more game-like flavour. Assume we have a morphism φ : R 	) S, that is a state φ of R ⇒ S. The
following lemma is a consequence of material contained in [2].


Lemma 1.10 The following hold for a cds of the form R ⇒ S. Call a run of some φ of R ⇒ S normal if it is of the form
(ρ1, d1)c1 ··· (ρ1	, d1)c1	(ρ1 , d1)w1(ρ2, d2)c2 ··· 
1	1	n1 −1	n1−1	n1	1	1
(ρm, dm)cm ··· (ρm	, dm)cm	(ρm , dn)wm
1	1	nm−1	nm−1	nm

where the last element is optional, such that  i,j
i is a state of R. Then

φ = {((ρ, d), x) ∈ φ | ∃normal run of φ ending in (ρ, d)x}.
In other words, in a normal run as soon as a cell d in D has been played we cannot mention other cells from D until d has been filled. Further, we only allow runs which are consistent in their requirement of information from R.
A normal run of φ contains a lot of information, some of which we can discard. Given a normal run we want to build a string in pre((D(CV )∗W )∗) which we require below to interpret φ as a strategy. An economic run of φ : R ⇒ S is a word in pre((D(CV )∗W )∗) which is generated recursively by a normal run of φ as follows:
Run of length 0. For an empty run take the empty string.
Run of length n + 1. Let (ρ1, d1)x1 ··· (ρn, dn)xn(ρn+1, dn+1)xn+1 be a normal run of φ and r be the economic run corresponding to the given run up to (ρn, dn)xn. We make a case distinction based on whether xn is an element of C or one of W
xn ∈ C. In this case dn = dn+1 and ρn+1 = ρn ∪ {(xn, v)} for some v ∈ V , and we take rvxn+1.
xn ∈ W . In this case, dn and dn+1 are distinct, and we take rdn+1xn+1.
Clearly no information is really lost by moving from a normal run to the corresponding economic one, and we can easily reconstruct the former from the latter. However, we require stripping away still further information.
Note that by the definition of normal run, if an economic run contains a cell c more than once then its successor, a value from V , has to be the same for all occurrences. Given an economic run r we obtain the corresponding basic run by removing pairs cv ∈ ev(R) which are repetitions. It is in gen- eral not possible to reconstruct an economic run from its corresponding basic version. However, taken together the basic runs of a morphism are sufficient to characterize it.
Example 1.11 Consider the cds R which has one initially enabled cell c and one value for it, v, and the cds S with two initially enabled cells d and d', both of which can be filled with value w. Then
φ = {((∅, d), c), (({(c, v)}, d), w), ((∅, d'), c), (({(c, v)}, d'), w)}


is a state of R ⇒ S with maximal normal runs (∅, d)c({(c, v)}, d)w(∅, d')c({(c, v)}, d')w
and (∅, d')c({(c, v)}, d')w(∅, d)c({(c, v)}, d)w,
maximal economic runs dcvwd'cvw and d'cvwdcvw and maximal basic runs dcvwd'w and d'cvwdw. Both these runs together allow us to deduce that both, d and d' require the cell c to be filled in order be assigned a value.
Note that basic runs of the identity on R are very reminiscent of plays of a copycat strategy.
Lemma 1.12 A state φ of R ⇒ S is uniquely determined by its set of basic runs.
Proof (Sketch) Given an event ((ρ, d), x) in R⇒S we have to decide whether it is in φ. Consider all basic runs t which contain d as their last symbol from D and x as their last letter, and which are such that [t|C+V ♩ is contained in ρ. If there is such a run which is minimal among all these in the prefix order with the property that [t|C+V ♩ is equal to ρ then our event belongs to φ, else it does not.	 
A joint basic run of φ and ψ is a word z in (C + V + D + W + E + X) such that
z|C+V +D+W is a basic run of φ and
z|D+W +E+X is a basic run of ψ.
Proposition 1.13 The set of basic runs of ψ ◦ φ is the set
{z|C+V +E+X | z joint basic run of φ and ψ}.
Proof (Sketch) It is not too difficult to show that the above set of basic runs is contained in the set of basic runs for ψ ◦ φ—the proof is an induction by the way joint basic runs are formed. The other inclusion is reminiscent of the proof that composition in Gam can be described as a relational composition. 
Definition 1.14 The product R × S of two cdss R = (C, V, E, ▶) and S = (D, W, F, ▶) has
cells: C + D;
values: V + W ;
events: evR + ev(S) ⊆ (C × V )+ (D × W ) ⊆ (C + D) × (V + W );
enablings: all enablings from R and all enablings from S. The terminal cds 1 has empty sets of cells and values.


Theorem 1.15 The category CDS is cartesian closed with the structure given above.
Games and ﬁliform cdss
There are very special concrete data structures which are closely related to games. They have the property that the enabling relation has a very restricted form; as a result of which the minimal states containing a given event have a unique sequentialization.
Definition 1.16 We say that a cds is filiform if all instances of the enabling relation refer to sets of events with at most one element.
We call such a concrete data structure an fcds. Let FCDS be the full subcategory of CDS whose objects are the stable filiform concrete data struc- tures.
Since function space and product in CDS preserve the filiform property,
FCDS is cartesian closed.
For a cds we define a game whose Opponent moves are the cells of R and whose Player moves are the values. A play should then correspond to a certain kind of run, namely one where at each stage the next cell has become enabled for the first time. For a filiform cds R a state ρ is precisely given by its runs of this kind. For a cds R let TR be the game that has
sets of moves (T R)O = C and (T R)P = V ;
· The empty word is in pos(T R).
Given r ∈ posP (T R), rc ∈ posO(T R) for c in C if and only if
c is enabled but not filled in [r♩;
if r' Ð r then c enabled in [r'♩ implies r = r'.
Given r ∈ posO (T R), rv ∈ pos(T R) for v in V if and only if r = r'c for some c ∈ C and (c, v) is an event;
Then states on R correspond precisely to strategies on T R: Given such a
ρ, let the corresponding strategy be given by
{r ∈ pos(T R) | [r♩ ∈ ρ}.
This helps in establishing the following result.
Proposition 1.17 The categories FCDS and Gam are equivalent.
In [4] the author describes a category of sequential data structures which are something of a hybrid between games and fcdss, but it is clear that his category is equivalent to our Gam and FCDS. It is the main purpose of this


paper to extend this idea to a result for all stable cdss. It is clear that the match between games and general cdss cannot be expected to be as close. It can be improved by considering games where some positions are identified.
Games with identified positions
It has been noted variously that there may be reasons why one might want to consider positions in a game only up to some equivalence relation. Graph games [8] are a somewhat extreme version of this approach, and we know of at least two others, by Melli`es [10] and Houston [5]. Here we try to keep the theory as simple as possible while still making it general enough to be applicable to other situations.
Our motivation comes from trying to view all cdss as games, that is without restricting to the filiform case. Clearly for that we have to come up with another way of constructing a game from a cds.
For a cds we want to define a game that contains all the possible runs of the cds. We again turn the cells into Opponent-moves and the values into Player-moves. For filiform cdss we can capture all the structure if we have a cell defining a valid move from a given position if and only if the cell is enabled but not filled in that position, and if the cell is not enabled by any prefix of that position. For general cdss however we have to pick a different way of forming valid plays—we have to drop the condition that the cell not be enabled in an earlier position.
Given a cds R let FR be the game that has:
sets of moves (FR)O = C and (FR)P = V ;
· The empty word is in pos(FR).
Given r ∈ posP (FR), rc ∈ posO (FR) for c in C if and only if c is enabled but not filled in [r♩.
Given r ∈ posO (FR), rv ∈ pos(FR) for v in V if and only if r = r'c for some c ∈ C and (c, v) is an event;
Remark. There is a one-to-one correspondence between plays of FR and runs of R, whereas in the filiform case for TR it is between plays and restricted runs. Clearly in general, there are more strategies on FR than there are states on R.
Example 2.1 Consider the cds R where C = {c, c', c''}, V = {v}, all possible combinations of cells and values are events, and where c and c' are enabled by the empty set whereas (c, v), (c', v) ▶ c''. This is the smallest non-filiform cds.



There are four states for the cds, but nine strategies for FR. We aim in what follows to remove at least some undesirable strategies.
One reason for the mismatch between states of R and strategies on FR is that a strategy contains sequentializations of states, and in general a state may have many of those. Moreover, a strategy may be willing to carry out some of these sequentializations, but not others. This problem does not arise for fcdss since there every minimal state containing some event has precisely one sequentialization.
One way of cutting down the number of strategies is by identifying those positions in FR which correspond to the same underlying state, and then demanding that all strategies are well-behaved with respect to that equivalence relation. We want to identify positions r, r' ∈ posP (FR) if and only if
[r♩ = [r'♩,
which is equivalent to saying that the pairs consisting of an Opponent move followed by a Player move performed in r and r' are the same, they merely occur in a different order. We identify rc, r'c' ∈ posO (FR) if and only if r ∼ r' and c = c'.
Definition 2.2 A ∼-game (A, ∼) is a game A with an equivalence relation
~ on positions of A satisfying the following conditions.
P -positions can be related only to other P -positions, and so the analogue is true for O-positions.
If r and r' are two ∼-related positions then if ra ∈ pos(A) then r'a ∈ pos(A) and ra ∼ r'a.
No position is ∼-related to one of its proper prefixes.
If ra and ra' are ∼-related then a = a'.
Note that if r and r' are two ∼-related positions then the full subtree of the game rooted at r is the same as the subtree of the game rooted at r', including the ∼ relation.
Definition 2.3 The linear function space of (A, ∼) and (B, ∼) is (A 


B, ∼) where for positions t and t' of A  B we set
t ∼ t'	if and only if	(t|A ∼ t'|A and t|B ∼ t' ).
An analogous definition is used to define a tensor product for ∼-games. More interestingly, what notion of strategy should we consider for ∼-
games? Clearly if our motivation for identifying positions is to make sense, then at a minimum one would only want to allow those strategies α on A for which if r ∼ r' are O-positions in α then α has an answer to r if and only if it has an answer to r', and the two resulting positions are once more equivalent. A stronger version would be to demand, in this situation, that ra ∈ α if and only if r'a ∈ α. But it turns out that neither of those is strong enough on its own to ensure that the resulting strategies compose. See [5] for a discussion of this issue in a slightly different setting.
Before we give the definition we introduce the following notation. For two positions r, r' in a ∼-game we write
r ≤ r'	if and only if	there exists rˆ with r Ð rˆ ∼ r'.
In other words r is a play which can become equivalent to r' once further moves have been added. Put differently again, in the acyclic directed graph obtained by identifying those positions which are ∼-related there is a path from the node corresponding to (the equivalence class of) r to (that of) r'. We write r ≺ r' if r ≤ r' but not r ∼ r'—in other words, to get from r to a play which is ∼-related to r' we have to add at least one move.
If A and B are two games then we can determine the relation ≤ on A  B from those on A and B, although there is a side-condition: If, for example, for positions t and t' in A  B we have t|A ∼ t'|A, t|B ≺ t'|B and all these are P -positions, then the only way of reaching something related to t' from t would be by making further moves in B. However, if t|A and t|B are both P -positions then the next move has to occur in A, so we are ‘stuck’ on our way to something related to t'.
Lemma 2.4 Let t and t' be two positions in A  B. Then
t ≤ t'   if and only if   (t|A ≤ t'|A) and (t|B ≤ t'|B) and
not ((t|A ∼ t'|A, t|B ≺ t' , all P-positions) or (t|A ≺ t'|A, t|B ∼ t' ,  all O-positions)).
Definition 2.5 A ∼-strategy α on (A, ∼) is a strategy α on A such that
if r, r' ∈ α are O-positions and ra ∈ α for some P -move a then r'a ∈ α;


if r ∈ posO (A) and r' ∈ posP (A) are two positions in α with r ≺ r' then there exists ra ∈ α such that ra ≤ r'.
Identities are obviously ∼-strategies. To show that ∼-strategies compose we need an auxiliary result. Let ξ : A  B and ζ : B  C be two ∼-strategies.
Lemma 2.6 Let t and t' be two positions in ζ ◦ ξ, and let w and w' be the unique minimal joint sequences in accord with ξ and ζ for t and t' respectively, so w|A+C = t, w'|A+C = t'. If t ∼ t' then w|B ∼ w'|B.
Proof (Sketch) The proof proceeds by induction over the construction of w. So assume we have built v Ð w up to length n such that v|A ≤ w'|A, v|B ≤ w'|B and v|C ≤ w'|C—clearly the empty sequence has these properties. We stop when we have reached v = w, so assume that at least one of v|A ≺ w'|A and v|C ≺ w'|C. There are four cases which can arise when lengthening v by one move, namely (v|A, v|B, v|C) in
posP (A) × posP (B) × posP (C): The next move is for Opponent in C, call it c. But vc|C Ð w|C ≤ w', and the restrictions to moves from A or B haven’t changed.
posP (A) × posP (B) × posO (C): The next move is ζ’s answer to w|B+C, call it d (from either B or C). But whichever it is, vd|B+C ≤ w'|B+C since ζ is a ∼-strategy, and so vd|B ≤ w'|B as well as vd|C ≤ w'|C.
posP (A) × posO (B) × posO(C): This case is dual to the previous one.
posO (A) × posO (B) × posO(C): This case is dual to the first one.
 
Corollary 2.7 Let t and t' be two positions in ζ ◦ ξ, and w and w' be the respective unique joint sequences. Then
t ≤ t'	if and only if	w|A ≺ w'|A and w|B ≺ w'|B and w|C ≺ w' .
Proposition 2.8 The composite of two ∼-strategies is a ∼-strategy.
Proof (Sketch) The first condition is shown by making use of the way joint sequences are built; it is a simple case distinction (a new move added to an existing position in a composite can be from either the source or the target) and uses that the composed strategies satisfy that condition. The second condition can be shown by an application of the preceding two Lemmas. 
It is obvious that (A ⊗ B)  C is isomorphic to A  (B  C) and so we obtain a symmetric monoidal closed category Gam∼. It is also obvious how to define the product of two ∼-games, the equivalence relation is the union of the two equivalence relations. The terminal object has only one position and therefore there is only one equivalence relation turning it into a ∼-game. We


can give a linear exponential comonad for ∼-games, but since we make no use of it here we do not include a definition.
There is an obvious forgetful functor from Gam∼ to Gaml which preserves the categorical structure and which is faithful. On the other hand if we equip a game with the trivial equivalence relation, where every position is equivalent only to itself, then we obtain a monoidal functor which is full and faithful. However, these two functors do not form an adjunction. The reason for this is that the only candidates for the unit and co-units are copycat strategies, but the one which lives in Gam∼ is not a ∼-strategy.
Proposition 2.9 The category Gam∼ is equivalent to the category of graph
games GGam in [7].
Proof (Sketch) We map a ∼-game A to the graph game whose positions are equivalence classes of positions A, where there is a move from [r] to [r'] if and only if there exists a with ra ∼ r'. It is obvious what to do for ∼- strategies, the main challenge is to prove that the results satisfies the conflict- freeness condition, but that’s obvious from the condition for ∼-strategies. In the opposite direction, map a graph game A to the game whose moves are of the form (rr') whenever r −→ r' in A. Two positions are equivalent if and only if their last moves end in the same position from A. This is the ‘treeification’ functor from [7] equipped with the obvious equivalence relation.	 
For this application we prefer to work in Gam∼ because in GGam we do not have the notion of named moves. Our category bears a vague resemblance to Melli`es category of extensional data structures (edss) [10]: Given a ∼-game, read it as an eds and take the equivalence classes of P -positions as extensions, where such a class realizes all its members. Our ∼-strategies are then strategies of edss which implement all extensions. However, Melli`es has a more general notion of morphism, so while we get a functor the connection is not close. Further, given an eds there is no obvious way of turning it into a ∼-game.
Cdss as ∼-games
We want to turn the assignment F into a functor CDS   ) Gam∼. Note that
F (R × S) ∼= FR ⊗ FS	and	F 1 ∼= I,
so F maps products in CDS to tensor products in Gam∼.
For fcdss we had a nice relation between states on R and strategies on T R. If we look at the situation for general cdss and F then we note that if ρ is a state of R then we can derive a ∼-strategy Fρ on FR from it. The idea


is that Fρ is trying to ‘mimic’ ρ by attempting to fill all the cells that ρ fills with the appropriate value. Formally, for a play r of FR,
r ∈ Fρ	if and only if	[r♩ ∈ ρ.
However, in general there are more ∼-strategies for FR than there are states of R. The reason for this is that while a ∼-strategy might be prepared to fill some cell c with value v under some circumstances there is nothing that compels it to do so whenever it can.
In particular in Example 2.1 consider the strategy pre{cvc', c'vc}. The only state this could possibly correspond to is ρ = {(c, v), (c', v)}, but that is much better interpreted by Fρ = pre{cvc'v, c'vcv}.
Slightly more generally, consider F (R×S) ∼= FR ⊗ FS. The only strategies on F (R × S) which arise from Fτ for some state τ on R × S are of the form Fρ ⊗ Fσ with ρ : R and σ : S.
We have defined an action on objects of CDS and it remains to ex- tend it to morphisms to obtain a functor F : CDS  ) Gam∼. Assume we have a morphism φ : R   ) S, that is a state φ of R ⇒ S. Then we define Fφ : FR  ) FS to be the set of all runs of φ. Note that we can read ρ : R as a morphism ρ : 1   ) R which is mapped to Fρ : I = F 1   ) F R, and this
corresponds to Fρ : FR defined above.
Proposition 3.1 This deﬁnes a faithful functor F : CDS 	) Gam∼. Proof (Sketch) It is easy to show that every run of φ is indeed a play of
FR  FS, and not much harder to establish that this set defines a ∼-strategy.
For functoriality all the hard work is done by Proposition 1.13, and we know the assignment is faithful by Lemma 1.12.	 
Note that we can describe Fφ inductively by making use of the abstract algorithm corresponding to φ, gφ.
Proposition 3.2 The following are equivalent given ξ : FR 	) FS:
there exists φ : R ⇒ S with ξ = Fφ;
there exists an abstract algorithm gξ : stf R × D  ~ C + W deﬁning ξ in the following sense: Let t be an odd-length word in Fφ and let d be the last symbol from D occurring in t. Then ξ’s unique answer to t is given by gξ([t|C+V ♩, d) (if gξ is undeﬁned at that point then so is ξ);
φ maps ∼-strategies of the form Fρ for FR by post-composition to ∼- strategies of the form Fσ for FS.
This condition is a generalization of history-freeness [1] in the sense that if
α : FR then if α is equal to Fρ for some ρ : R if and only if it is history-free.

It is instructive to see a definition of the functor G : CDS  ) GGam which is F composed with the equivalence of Proposition 2.9. For a cds R let GR be the graph game that has P -positions the finite states of R, and O-positions such a state ρ together with a cell c enabled but not filled in ρ. Moves are obvious. For a state φ : R ⇒ S, let Gφ be the strategy defined by
⎧
Gφ(ρ, (σ, d)) = ⎪⎨ ((ρ, c), (σ, d))	gφ(ρ, d)= c
⎪⎪⎩ undefined	otherwise.
The image of morphisms under G has nice characterizations, but we do not give them here since that would require introducing more material about graph games.
We can identify a subcategory of Gam∼ which is the image of CDS un- der F . For this we generalize the definition of [♩ to a play r of an arbitrary game A by setting
[r♩ = {(a, a') ∈ AO × AP | ∃r' ∈ (AOAP )∗. r'aa' Ð r}.
Proposition 3.3 Given a ∼-game A, there is a cds R with FR = A if and only if for all plays r, r' of A
rar'a ∈ posO (A) implies r is the empty string (every O-move may occur at most once in every play);
· for r, r' ∈ posP (A), r ∼ r' if and only if [r♩ = [r'♩,
for ra, r'a' ∈ posO (A), ra ∼ r'a' if and only if r ∼ r' and a = a'
(two plays are equivalent if they consist of the same (O-move, P-move) pairs possibly in a different order, with the appropriate handling of trailing O-moves);
r ∼ r' implies r ∧ r' ∈ posP (A) (equivalent positions diverge at an O-move);
raa' ∈ posP (A), r'a ∈ posO (A) imply r'aa' ∈ posP (A) (if the P-move a' is once a valid answer to the O-move a then this is true everywhere);
ra ∈ posO (A), r' ∈ posP (A), [r♩ ⊆ [r'♩, a does not appear in r' imply
r'a ∈ posO (A) (a being enabled remains valid until it has been answered);
ra, r'a ∈ posO(A) and r ∧ r' ∈ posP (A) imply (r ∧ r')a ∈ posO(A) (stability).
Proof (Sketch) The cds R has cells AO, values AP , events all (a, a') ∈ AO × AP such that there exists r ∈ pos(A) with raa' ∈ pos(A) and enablings all instances of [r♩ ▶ a such that ra ∈ pos(A) and for all r' Ð r, r'a /∈ pos(A). 
Let CDSGam∼ be the category given by the image of F .

Theorem 3.4 The category CDSGam∼ is cartesian closed and equivalent to
CDS.
This is somewhat surprising in that this is a cartesian closed category of games which is not based on a decomposition of the function space—instead,

the function space is the linear function space of Gam∼
and the product

is the tensor product from that category. It is instructive to see why the tensor product for the identified subcategory becomes a product. There are
projections for ⊗ in Gaml already, for example πl : A ⊗ B   ) A is given
by the copy-cat strategy which copies the moves of the right hand copy of A to the left hand copy and vice versa, the game B never gets started. In CDSGam∼ these are the images of projections under F . The problem lies in defining the pairing operation.
But in the image of F we have a diagonal δR : FR 	) FR ⊗ FR (the image of the diagonal R 	) R × R in CDS): Given an O-position t in δR
we calculate its restriction to all three components to obtain three plays r, r' and r'' of FR, where r is an interleaving of r' and r'', plus or minus one extra move at the end. If there is an extra move in r we copy it as our answer to t, else there is an extra move to one of r' or r'', and we copy that. Note that this is only possible because we know that the appropriate move is available in FR, so we are making considerable use of the special nature of games of this form.
For Fφ : FR  FS, Fψ : FR  FT we set ⟨Fφ, Fψ⟩: FR 	) FS ⊗ FT 
to
FR δR) FR ⊗ FR Fφ⊗F)ψ FS ⊗ FT,
and this is equal to F ⟨φ, ψ⟩: FR 	) F (S × T ) ∼= FS ⊗ FT .
Note that in order to compose strategies in our cartesian closed category we can just use the composition of linear morphisms and do not have to go via some Kleisli category. In some ways, objects of the form FR behave a bit like an object of type !A, but to our knowledge there is no linear exponential which would allow us to write FR as such.
Conclusions and future work
We have established a category of games which is equivalent to the category of concrete data structures. This yields a description of a cartesian closed category of games which is not the Kleisli-category for some linear exponential. For this work it was vital to define a category of games with the additional structure of an equivalence relation on positions. This category is equivalent to the category of graph games, but it has named moves without which a cartesian closed subcategory cannot be defined. For this category we have


to restrict to games of a very special nature and to morphisms which can be described using a partial function.
Concrete data structures can be viewed as special event structures, and we argue above that some events in a state are independent from others, yielding a primitive notion of concurrency. An interesting question is whether these games can be used to model more elaborate versions. But the category Gam∼ throws up other questions: What is so special about this choice of game and strategy?

References
Abramsky, S. and R. Jagadeesan, Games and full completeness for multiplicative linear logic,
J. Symbolic Logic 59 (1994), pp. 543–574.
Amadio, R. and P.-L. Curien, “Domains and Lambda-Calculi,” Number 46 in Cambridge Tracts in Theoretical Computer Science, Cambridge University Press, 1998.
Curien, P.-L., “Categorical Combinators, Sequential Algorithms and Functional Program- ming,” Birkha¨user, 1993, 2nd edn
Curien, P.-L., On the symmetry of sequentiality, in: Proceedings of MFPS93, Lecture Notes in Computer Science 802 (1994), pp. 29–71.
Houston, R., “Categories of Games,” Master’s thesis, University of Manchester (2003).
Hyland, M. and A. Schalk, Abstract games for linear logic. Extended abstract, in: Proceedings of CTCS ’99, Electronic Notes on Theoretical Computer Science 29, 1999.
Hyland, M. and A. Schalk, Games on graphs and sequentially realizable functionals. Extended abstract, in: Proc. Logic in Computer Science 2002 (2002), pp. 257–264.
Hyland, M. and A. Schalk, Glueing and orthogonality for models of linear logic, Theoretical Computer Science 294 (2003), pp. 183–231.
Kahn, G. and G. Plotkin, Concrete domains, Theoretical Computer Science 121 (1993),
pp. 187–277.
Melli´es, P.-A., Sequential algorithms and strongly stable functions, to appear in the special issue of Theoretical Computer Science: Game Theory Meets Theoretical Computer Science.
