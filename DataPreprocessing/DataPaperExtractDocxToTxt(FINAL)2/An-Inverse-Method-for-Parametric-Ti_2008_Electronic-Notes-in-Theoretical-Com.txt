

Electronic Notes in Theoretical Computer Science 223 (2008) 29–46
www.elsevier.com/locate/entcs

An Inverse Method
for Parametric Timed Automata
E´tienne Andr´e, Thomas Chatain, Laurent Fribourg1
LSV – ENS de Cachan & CNRS, France
Emmanuelle Encrenaz2
LIP6 – Universit´e Pierre et Marie Curie & CNRS, France

Abstract
Given a timed automaton with parametric timings, our objective is to describe a procedure for deriving constraints on the parametric timings in order to ensure that, for each value of parameters satisfying these constraints, the behaviors of the timed automata are time-abstract equivalent. We will exploit a reference valuation of the parameters that is supposed to capture a characteristic proper behavior of the system. The method has been implemented and is illustrated on various examples of asynchronous circuits.
Keywords: Timed automata, parameters, verification, asynchronous circuits.


Introduction
This work aims at extending the inverse method described in the restricted frame- work of “Time Separation of Events” [11]. The problem of time separation can be stated as follows: given a system made of several connected components, each one entailing a local delay known with uncertainty, what is the maximum time for traversing the global system? This problem is useful, e.g. in the domain of digital circuits, for determining the global traversal time of a signal from the knowledge of bounds on the component propagation delays. The inverse problem is the follow- ing: we seek intervals for component delays for which the global traversal time is guaranteed to be no greater than a specified maximum. The system is represented in [11] under the form of a timing constraint graph, which is an oriented graph whose

٨ This work is partially supported by the French ANR project VALMEM and FARMAN project SIMOP.
1 Email: {andre,chatain,fribourg}@lsv.ens-cachan.fr
2 Email: emmanuelle.encrenaz@lip6.fr

1571-0661 © 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.12.029

vertices represent events and directed edges causal dependency between them. We consider here systems modeled by timed automata. The model of timed automata is more general than timing constraint graphs as it allows for composition of sys- tems and choice of actions. The timing bounds involved in the action guards and location invariants of our timed automata are not constants, but parameters. Those parametric timed automata allow to model various kinds of timed systems, e.g. communication protocols or asynchronous circuits.
We will also assume that we are given an initial set of values for the parameters that form the so-called “reference parameter valuation”, which corresponds to values for which the system is known to behave properly. Our goal is to compute a con- straint K on the parameters, satisfied by the reference valuation, guaranteeing that, under any valuation satisfying K, the system behaves in the same manner: for any two valuations of the parameters satisfying K, the behaviors of the timed automata are (time-abstract) equivalent, i.e., the traces of execution (or runs) viewed as al- ternating sequences of actions and locations are identical. Our procedure consists in generating growing paths starting from the initial state. When one generates a path ending in a state incompatible with the reference values, the path is discarded by refining appropriately the current constraint K on parameters. The generation procedure is then restarted until a new incompatible state is produced, and so on, iteratively until no incompatible state is generated.

Comparison with Related Work.
The synthesis of constraints has been studied in the context of parametric timed automata or hybrid systems, e.g. in [4], or in [13] where the authors use a prototype extension of Uppaal [14] for linear parametric model checking. Note that [4] is able to infer non-linear constraints.
Another interesting related work on parametric timed automata is the 2nd part of [13], which shows decidability results for the verification of a special class, called “L/U automata”. This class is somehow restricted: for example, it does not allow for systems with guards of the form x = p (i.e., x ≤ p ∧ p ≤ x), where x is a clock and p a parameter, because parameters must appear either as lower bounds or as upper bounds of clocks, but not both. Furthermore, the way for synthesizing constraints is indirect: one needs to guess a constraint, then check that an appropri- ate instance of the system is correct under this constraint, from which the general correctness is inferred by an equivalence theoretical result. Two subclasses of L/U automata, called lower-bound and upper-bound parametric timed automata, are also considered in [17], with decidability results.
As pointed out in [12], a major strength of tool HyTech is its ability to perform parametric analysis. One can synthesize constraints on parameters for which a given “bad” state is reachable (see, e.g., Fisher’s mutual exclusion protocol in [12]). This is done by computing the set Post ∗(sinit ) of reachable states, intersecting with the bad states, and eliminating the non-parameter variables.
The synthesis of constraints has also been studied in the context of asynchronous circuits, mainly by Myers and co-workers on the one hand (see, e.g., [18]), and by

Clariso and Cortadella on the other hand (see, e.g., [6,7]). They also proceed by analyzing failure traces and generating timing constraints that prevent the occur- rence of such failures. A basic difference between the two works is that Myers et al ’s approach is not fully parametric, but appeals to a numeric ILP (Integer Linear Programming) procedure, which tightens the delay bounds according to the gen- erated timing constraints. Myers et al ’s approach is somehow reminiscent to the technique of timing verification by successive approximation, used by [3] and [15] in the framework of timed automata. In contrast, Clariso-Cortadella’s approach, as ours, is fully parametric and handles linear constraints on parameters (rather than numeric intervals). Clariso-Cortadella computes the effect of loop iteration, using extrapolation techniques such as “widening” borrowed to the domain of Abstract Interpretation [10], and focuses on a restricted class of linear constraints (called “octahedra”). Our procedure differs on these points, since it does not iterate loops, and handles general linear constraints.
This idea of synthesizing constraints by refinement from counter-examples has often been used in the literature, e.g. using TReX [9], and more generally with CEGAR-based methods (counter-example guided abstraction refinement [8]). Note that, in our work, the notion of bad state corresponds to the notion of state incom- patible with the reference valuation.

Overview of the paper
We first introduce Parametric Timed Automata (Sect. 2) and a motivating ex- ample (Sect. 3). Then, we present our method of synthesis of constraints (Sect. 4), and apply it to the motivating example, as well as to an example in the case of cyclic traces (Sect. 5). We finally give some remarks and directions for future work (Sect. 6).

Parametric Timed Automata
We assume familiarity with standard timed automata [1]. All clock constraints of standard timed automata are boolean combinations of atomic conditions that compare values with nonnegative integer constants. Parametric timed automata allow within clock constraints the use of parameters in place of constants (see [2]).

Parameters and Constraints
Throughout this paper, we assume a fixed set of parameters P = {p1,... , p2R}. We assume that this set is partitioned into a set P l = {pl ,... , pl } of “lower bounds”
1	R
and a set P u = {pu,... , pu } of “upper bounds”, satisfying implicitly the set of
1	R
constraints 0 ≤ pl ≤ pu (for i = 1,... , R) 3 . Besides, we assume given a subset
P = of P made of parameters pl and pu, satisfying the constraint pl = pu. In the
examples (see Sect. 3), such parameters will be denoted by p without superscript.

3 This definition does not restrict our result, and is only introduced in order to treat the examples in an intuitive way.

A parameter valuation π is a function π : P → R≥0 assigning a non-negative real value to each parameter. There is a one-to-one correspondence between valu- ations and points in (R≥0)2R. We will often identify a valuation π with the point (π(p1),... , π(p2R)).
A clock is a variable xi with value in R≥0. The set of clocks will be denoted by X = {x1,... , xH}. Given a constant d ∈ R≥0, we use X + d to denote the set {x1 + d,... , xH + d}. Similarly to the parameter valuation, we define a clock valuation as a function w : X → R≥0 assigning a non-negative real value to each clock. We will often identify a valuation w with the point (w(x1),... , w(xH )). We will use the notation λx.0 for the clock valuation assigning value 0 to each clock.
Definition 2.1 An (X, P )-atom is a linear inequality of the form: γx + Σiαipl ≺
δy + Σjβjpu where ≺ ∈ {<, ≤}, γ, δ ∈ {0, 1}, αi, βj ∈ N, pl ∈ P l, pu ∈ P u, and
j	i	j
x, y ∈ X. An (X, P )-constraint is a conjunction of (X, P )-atoms.
If C is an (X, P )-constraint and π a parameter valuation, then C[π] denotes the X-constraint (constraint on clocks) obtained by replacing each parameter p in C with π(p). Likewise, given a clock valuation w, C[π][w] denotes the expression obtained by replacing each clock x in C[π] with w(x). A clock valuation w satisﬁes X-constraint C[π], denoted w |= C[π], if C[π][w] evaluates to true. The semantics of X-constraint C[π], denoted C[π]) is the set of clock valuations that satisfy C[π]. We say that C[π] is satisﬁable if C[π]) is nonempty.
We say that a parameter valuation π satisﬁes (X, P )-constraint C, denoted π |= C, if C[π] is satisfiable. The semantics of an (X, P )-constraint C, denoted C), is the set of parameter valuations that satisfy C. We say that C is satisﬁable if C) is nonempty.
Remarks
We will use the notation <w, π> |= C to indicate that C[π][w] evaluates to true. Given an (X, P )-constraint C, it is sometimes convenient to rename the set of

variables X = {x1,... , xH} as X' = {x' ,... , x'
}. We use the notation C(X) (resp.

1	H
C(X')) to indicate that X (resp. X') is the set of clock variables occurring in C.
Sets of parameter valuations will be represented themselves under a constraint form.
Definition 2.2 A P-atom is a linear inequality of the form
Σi∈Lαipl ≺ Σj∈U βj pu
i	j
where L, U are subsets of {1,... , R}, ≺∈ {<, ≤}, αi, βj ∈ N, pl ∈ P l and pu ∈ P u.
i	j

Let J be a P -atom of the form Σi∈Lαipl
≤ Σj∈U βjpu
(resp.	Σi∈Lαipl <

Σj∈U βjpu). The negated form of J , denoted by ¬J , is the P -atom defined by:
Σi∈Lαipl > Σj∈U βjpu (resp. Σi∈Lαipl ≥ Σj∈U βjpu).
i	j	i	j
A P-constraint is a conjunction of P -atoms. Similarly to the semantics of (X, P )- constraints, we say that a parameter valuation π satisﬁes P -constraint K, denoted

π |= K, if K[π] is satisfiable, which means that the expression obtained by replacing each parameter p in K with π(p) evaluates to true.
We will consider the special atom True as a P -atom, corresponding to the set of all possible values for P .
Deﬁnition of Parametric Timed Automata
The following definition is an extension of the class of timed automata (considered in e.g. [16]) to the parametric case. With respect to the classical definition, this class is contrived by the fact that guards and invariants are necessarily in conjunctive form, but this is not restrictive in practice.
Definition 2.3 A parametric timed automaton (PTA) is a 7-tuple of the form
A(K)= (Σ, Q, qinit , X, P,I, →), where:
Σ is a finite set of actions (or “step labels”),
Q is a finite set of locations (or “control states”),
qinit is the initial location,
X is a finite set of clocks,
P is a finite set of parameters partitioned as P = P l  P u,
K is a P -constraint on the set of parameters P ,
I is the invariant, assigning to every q ∈ Q a conjunction Iq(X) of (X, P )-atoms of the form x ≤ pu, for some clock variable x ∈ X and parameter pu ∈ P u, and
→ is a step (or “transition”) relation consisting of elements of the form
'	g,a,ρ	'	'

(q, g, a, ρ, q ), also denoted q → q , where q, q
∈ Q, a ∈ Σ, ρ ⊆ X is a set

of clock variables to be reset by the step, and g(X) (the step guard) is a conjunc-
tion of (X, P )-atoms of the form pl ≺ x with ≺ ∈ {≤, <} for some clock variable
x ∈ X and parameter pl ∈ P l.
For every parameter valuation π = (π1,... , π2R), we denote A[π] the (standard)

timed automaton A( 

i=1,...,2R
(pi = πi)) i.e. the automaton obtained by substitut-

ing every occurrence of a parameter pi by the integer πi in the guards and invariants
of A.
We use X' = ρ(X), where X' is a renaming of X, to denote the conjunction of equalities x' =0 for all xi ∈ ρ, and x' = xi for all the other variables xi of X.
i	i
Concrete Semantics
Concrete States
Given a PTA A and a valuation π of its set of parameters, a concrete state s of A[π] is a pair (q, w) where q is a location and w a valuation of the clock variables.
Definition 2.4 A labeled transition system (LTS) over a set of symbols Σ is a triple L = (S, S0, →), with S a set of states, S0 ⊆ S a set of initial states, and
→ ∈ S × Σ × S a transition relation. We write s →a s' for (s, a, s') ∈ →. A trace, or

run, of L is a finite alternating sequence of states si ∈ S and symbols ai ∈ Σ of the
a0	a1	am−1
form s0 → s1 → ··· → sm, such that s0 ∈ S0.
Definition 2.5 Let A[π] = (Σ, Q, qinit , X, P,I, →) be a PTA, where π is a valua- tion of P . The concrete semantics of A under π is the labeled transition system (S, S0, ⇒) over (Σ ∪ R≥0) where

S = {(q, w) ∈ Q × (X → R≥0) | <w, π> |= I(q)}, S0 = {(q, w) ∈ S | q = qinit ∧ w = λx.0}
and the transition predicate ⇒ is specified by the following three rules. For all (q, w), (q', w') ∈ S, d ≥ 0 and a ∈ Σ,

(q, w) →d
(q', w') if q = q' and w' = w + d;

a	'	'
g,a,ρ  '	'

(q, w) → (q ,w ) if ∃g, ρ : q → q
and <w, π> |= g and w
= ρ(w).

(q, w) ⇒a
(q', w') if ∃d, q'', w'' : (q, w) →d
(q'', w'') →a
(q', w').

Note that this LTS has at most one initial state. It has no initial state if the invariant assigned to the initial location qinit of A is unsatisfiable.

Concrete Traces
Definition 2.6 Let A be a PTA on a set of parameters P , let sinit be its initial state, let π be a valuation of P . A concrete trace, or concrete run, T of A[π] (of length m − 1) is a finite alternating sequence of concrete states and actions of the form:
a1	a2	am−1
s1 ⇒ s2 ⇒ ··· si ... ⇒ sm

such that s1
a
= sinit and, for all i = 1,... ,m − 1, ai ∈ Σ and si ⇒ si+1
is a step in

the concrete semantics.


a1	am−1

The last state of a trace of the form s1 ⇒ ... ⇒ sm is sm.

Symbolic Semantics
Symbolic States
A symbolic state s is a pair (q, C) where q is a location and C an (X, P )-constraint. For each valuation π of the parameters P , we may view a symbolic state s as the set of pairs (q, w) where w is a clock valuation such that there exists a parameter valuation π such that <w, π> |= C.
The P-constraint associated to a state s = (q, C) is the constraint D obtained by eliminating the clock variables (i.e. variables of X) in C, for example via Fourier- Motzkin. We have: D ⇔ (∃X : C) 4 .

4 Unlike [13], we introduce no canonical form for D.

Proposition 2.7 Let C be an (X, P )-constraint on a set of parameters P and a set of clocks X, let D be the P-constraint associated to C, let π be a valuation of P. Then:
π |= C ⇔ π |= D
Proof. (sketch) From the definition of the P -constraint associated to a state, and the semantics of a P -constraint and an (X, P )-constraint.	 
Let Xinit be a subset of X made of clocks initially instantiated to 0 (the other being only constrained to have non-negative initial values). The initial (X, P )-
constraint, denoted by Cinit , is of the form:
Xinit =0 ∧	pl ≤ pu ∧	= pl = pu ∧ K,
i=1,...,R i	i	i∈I	i	i
where I= is the subset of {1, ..., R} corresponding to indices of the elements of P =. The initial state, denoted by sinit , is (qinit , Cinit ).
The semantics of a parametric timed automaton is given in terms of global steps as follows. Given a state s = (q, C), a step (or transition) of the automaton from s is one of the following:

A discrete step: (q, C) →a
(q',C'), which means that, for some step (q, g, a, ρ, q') ∈

→, C' is an (X, P )-constraint defined, using the set of (renamed) clock variables
X', by:
C'(X')= {∃X  [C(X) ∧ Iq(X) ∧ g(X) ∧ X' = ρ(X) ∧ Iq' (X')]}.
A time step: (q, C) →d  (q, C') where d is a new parameter with values in R≥0,
which means that C' is given by:
C'(X')= {∃X  [C(X) ∧ X' = X + d ∧ Iq(X')]}.
d,a  '
A compound step: s ⇒ s , which is a time step followed by a discrete step, i.e:

d	''
'' a	'	''
d,a	'	'

s → s ∧ s  → s for some state s . In other words: (q, C) ⇒ (q ,C ), means that,
for some step (q, g, a, ρ, q') ∈ →, C' is an (X, P )-constraint defined by:
C'(X')= {∃X  [C(X) ∧ Iq(X + d) ∧ g(X + d) ∧ X' = ρ(X + d) ∧ Iq' (X')]}.

A (general) step: s ⇒a
s', which means ∃d ∈ R
d,a	'

≥0 : s ⇒ s . In other words:

(q, C) ⇒a
(q',C'), means that, for some step (q, g, a, ρ, q') ∈ →, C' is an (X, P )-

constraint defined by:
C'(X')= {∃X, d [C(X) ∧ Iq(X + d) ∧ g(X + d) ∧ X' = ρ(X + d) ∧ Iq' (X')]}. 5
Example. Consider the following PTA, with 2 states and one clock (X = {x}):

Starting from q1, we consider a time step and a discrete a-transition. Thus, we have
(q ,C (X)) →d (q ,C' (X)) →a (q ,C (X)). We have C (X) = (x ≤ pu). From the
1	1	1	1	2	2	1	1
definition of the semantics of a time step, we have C' (X)= (x ≤ pu ∧ x + d ≤ pu).
1	1	1
And from the definition of the semantics of a general step, we have:

5 It can be shown that C'(X') can be put under the form of an (X, P )-constraint.

C2(X)= ∃d : (x ≤ pu ∧ x + d ≤ pu ∧ x + d ≥ pl ∧ x + d ≤ pu)
1	1	1	2
and after elimination of d: C2(X)= x ≤ pu ∧ pl ≤ pu ∧ pl ≤ pu, which gives us in

particular the new P -constraint pl
1	1	1	1	2
≤ pu.

Remark. The presence of P = and the associated equalities will allow us to express guards of the form x ≥ p on transitions exiting from locations having x ≤ p as invariants, where p (= pl = pu) belongs to P =. This feature is not expressible with L/U automata (see [13]), where parameters can be used as either lower bounds of clocks or upper bounds, but not both. We thus consider here a superclass of L/U automata.
Given a set of states S, the posterior set of states of S, denoted by Post A(K)(S), is the set of states reachable in at most one general step from a state of S, i.e.:

Post
A(K)
(S) = S ∪ {s' | s ⇒a
s', for some s ∈ S and a ∈ Σ}.

As usual, one defines Post i	(S) as the set of states reachable from S in at

most i steps, and Post ∗	(S) = 

i≥0
i
A(K)
(S). Note that, if Post i+1
(S) = 

i
A(K)
(S) for some i, then Post ∗
(S) = Post i
(S). In the sequel, we will

be interested in computing the set Post ∗	(sinit ) where K is a given P -constraint.
Symbolic Traces
Definition 2.8 Given a PTA A(K) of initial state sinit,a symbolic trace T of A(K) (of length m − 1) is a finite alternating sequence of symbolic states and actions of the form:
a1	a2	am−1
s1 ⇒ s2 ⇒ ··· si ... ⇒ sm

such that s1
a
= sinit and, for all i = 1,... ,m − 1, ai ∈ Σ and si ⇒ si+1
is a step.

We say that a symbolic trace is acyclic if it never passes twice by the same location.
We say that a symbolic trace is trivially cyclic if, when entering for the second time in a previously visited location, the constraint associated to the second visit is stronger than the first time. More formally:
Definition 2.9 Let A(K) be a PTA. A symbolic trace T of A(K) of the form

a
(q1, C1) ⇒ ··· 
am−1
⇒  (qm, Cm) is trivially cyclic iff:

∃i < m : qi = qm ∧ Cm ⊆ Ci and ∀j < m : i /= j ⇒ qi /= qj
By extension, any symbolic trace containing as a prefix a trivially cyclic trace is also considered as a trivially cyclic trace.
The signiﬁcant length, or simply length, of a trivially cyclic trace T is defined as the length of the smallest prefix of T being a trivially cyclic trace.
We now define both notions of symbolic trace simulated by a concrete trace, and concrete trace simulated by a symbolic trace.
Definition 2.10 Let A be a PTA on a set of parameters P , let K be a P -constraint on P , let π be a valuation of P .

A symbolic trace of A(K) of the form (q , C ) ⇒a1 ··· 
a1
am−1
⇒  (qm, Cm) is simu-
am−1

lated by a concrete trace of A[π] of the form (q1, w1) ⇒ ···  ⇒  (qm, wm), where
C1,... , Cm are (X, P )-constraints and w1,... , wm are clock valuations, iff
∀i, 1 ≤ i ≤ m : wi |= Ci[π].
Definition 2.11 Let A be a PTA on a set of parameters P , let K be a P -constraint on P , let π be a valuation of P .

A concrete trace of A[π] of the form (q , w ) ⇒a1 ··· 
am−1
⇒  (qm, wm) is simulated by

a symbolic trace of A(K) of the form (q , C ) ⇒a1 ··· 
am−1
⇒  (qm, Cm), where C1,... , Cm

are (X, P )-constraints and w1,... , wm are clock valuations, iff
∀i, 1 ≤ i ≤ m : wi |= Ci[π].
Thus, we can define the notion of equivalence between set of traces.
Definition 2.12 Let A be a PTA on a set of parameters P , let K be a P -constraint on P , let π be a valuation of P .
We say that a set S of symbolic traces of A(K) and a set S' of concrete traces of A[π] are equivalent iff:
any trace in S is simulated by a trace in S';
any trace in S' is simulated by a trace in S.

Networks of Parametric Timed Automata
This presentation is adapted from [16] to the parametric framework. For each au- tomaton Ai(Ki), where Ki is a constraint on a local set of parameters Pi = P l  P u,
i	i
let Σi be its local alphabet, i.e., the set of step labels it uses.

Definition 2.13 Let P =  N
Pi be a set of parameters where Pi are mutually

disjoint sets of local parameters, let K =
i=1,...,N Ki be a constraint on P . A

network of parametric timed automata (NPTA) is A(K)= A1(K1)  ··· AN (KN ),
where  is the standard operator for parallel composition, and each automaton is of the form Ai = (Σi, Qi, qiniti, Xi, Pi, Ii, →i). The sets of locations and clocks are mutually disjoint.
The global automaton obtained from the network of parametric timed automata

is A(K) = (Σ, Q, qinit, X, P,I, →), where Q = ΠN
Qi, qinit = (qinit1 ,... , qinit ),

  N	 N
  N	i=1	N

X  =	i=1 Xi, P  =	i=1 Pi and Σ =
i=1 Σi.	We write global locations as

q = (q1,... , qN ) ∈ Q and global (X, P )-constraints as C = C1 ∧ ... ∧ CN .
The symbolic semantics of the NPTA is given in terms of compound and general steps as follows:
	d,a  '	'
A compound step: (q, C) ⇒ (q ,C ) is such that, for every i either a ∈ Σi and

d,a	'	'
d	'	'

(qi, Ci) ⇒ (qi, Ci) isa step of Ai, or a /∈ Σi and (qi, Ci) → (qi, Ci) isa step of Ai,
and C' = C' ∧ ... ∧ C' .
1	N
A (general) step: (q, C) ⇒a (q',C') means that (q, C) d⇒,a (q',C') for some d ∈ R	.



Fig. 1. Flip-flop circuit

Fig. 2. Reachability graph of the flip-flop circuit

The concrete semantics is similarly defined in a natural way.

An Illustrating Example
Consider an asynchronous “D flip-flop” circuit described in [6] and depicted on Fig. 1. It is composed of 4 gates (g1, g2, g3 and g4) which are interconnected in a cyclic way, and an environment which corresponds to 2 input signals D and CK .
Each gate gi has a symbolic delay in the interval [pl , pu ]. Each gate is modeled
by a timed automaton, plus a timed automaton modeling the environment. There are 12 timing parameters, among which 4 belong to P = (viz., THI , TLO, TSetup, and THold). We set the following parameters as follows:
THI = 20	TLO = 15	TSetup = 10	THold = 15

u = 1	pl
u = 10	pl
= 1	pu
= 8	pu
= 6	pl  = 5 
= 5	pl  = 3 

For these values, the set of traces of execution of the system is depicted under the compact form of a (time-abstract) reachability graph, given in Fig. 2. Note that this example is non deterministic, since we have several possible traces for the same set of values.
We are interested in finding a constraint K on the parameters, such that, for any valuation of P satisfying K, the reachability graph will be the same. This amounts to say:


The simple idea of the procedure that we are going to describe is to start with K = True, enumerate all the states and remove the states incompatible with π by iteratively refining K.

Synthesis of P -Constraints
We first define the notion of π-compatible state.
Definition 4.1 A symbolic state s = (q, C) is said to be π-compatible iff π |= D, where D is the P -constraint associated to s.
A state is said to be π-incompatible if it is not π-compatible.
In [13], Prop. 3.17 states that each symbolic trace is simulated by a concrete trace. The formalism in [13] uses PDBM, whereas we use a first-order form of (X, P )-constraints. However, this has no incidence on the result used here. The following proposition is a reformulation of Prop. 3.17 in our formalism.
Proposition 4.2 Let A be a PTA on a set of parameters P, let π be a valuation of P, let K be a P-constraint. For each parameter valuation π and clock valuation w, if there is a symbolic trace of A(K) reaching state (q, C), with <w, π> |= C, then this trace is simulated by a concrete trace of A[π] reaching state (q, w).
Proof. Cf. [13].	 
Conversely, we state that, given π |= K, each concrete trace of A[π] is simulated by a symbolic trace of A(K).
Proposition 4.3 Let A be a PTA on a set of parameters P, let π be a valuation of P and K be a P-constraint such that π |= K. For each clock valuation w, if there is a concrete trace of A[π] reaching state (q, w), then this trace is simulated by a symbolic trace of A(K) reaching a state (q, C), such that <w, π> |= C.
Proof. By adapting the proof of Prop. 3.18 of [13] to take into account the fact that π |= K.	 

Algorithm SYNTHESIS
Prop. 4.3 gives us a hint for the synthesis procedure: in order to find a generalization of π, for which the set of traces mimics the set of π, it suffices to prevent the generation of states traces which are π-incompatible.
Given an NPTA A(K), an initial state sinit and a reference valuation π of the parameters, we are going to describe a procedure finding by refinement a constraint K on the parameters that preclude the generation of any π-incompatible state. The idea of the procedure for synthesizing K is as follows, starting from K := True:

Generate Post i
(sinit ) for i = 1, 2,... until a π-incompatible state is gener-

ated;
strengthen K in order to prevent the generation of this state;



Fig. 3. Algorithm SYNTHESIS
go to (i).
Step (i) can incorporate a fixpoint test for the set of generated states, and step (ii) a satisfiability test for K with the reference valuation. Note that, if the P -constraint associated to a state does not satisfy π, then it necessarily contains an atom J such that π |= K ∧ ¬J (because any P -constraint is stronger than K). Note also that π |= K is an invariant.
We present the procedure SYNTHESIS on Fig. 3, where K is the current P - constraint, and S the current set of generated states.
The pair (K, S) can be seen as a successful answer given by the procedure, where

K is satisfied by π, and S is a fixpoint of Post (i.e.: S = Post ∗
(sinit )). This

answer is produced nondeterministically for each selection of π-incompatible state,
and each selection of atom J .

Correction
We now state the correction of the algorithm.
Theorem 4.4 Let A be a PTA on a set of parameters P, let sinit be its initial state, let π be a valuation of the parameters P, let K be the result of SYNTHESIS applied to (A, sinit , π). Then π |= K, and the set of traces of A(K) and the set of

traces of A[π] are equivalent.
Proof. By construction of K, we have π |= K.
Let us consider a symbolic trace T of A(K), whose last state is (qm, Cm). By construction of K, all the symbolic states of T are π-compatible, which means Cm[π] is satisfiable. Thus, there exists a clock valuation w such that w |= Cm[π]. Thus, we have a trace in the symbolic semantics reaching state (qm, Cm), with <w, π> |= Cm. Which means, applying Prop. 4.2, that T is simulated by a trace of A[π].
Conversely, we prove that any concrete trace of A[π] is simulated by a symbolic trace of A(K) applying Prop. 4.3.	 
It follows that, for any two valuations π1 and π2 of P satisfying K, the set of traces of A[π1] and A[π2] are equivalent.
Termination
Reachability analysis is known to be undecidable in the framework of PTA [2], and computations performed with tools dealing with PTA (such as HyTech [12]) might not terminate. However, we give sufficient condition for ensuring termination of our method.
The following lemma, used to prove termination, states that, for any i, the number of states of a PTA symbolically reachable in i iterations is finite. This, of course, does not mean that the number of all reachable states (Post ∗) is finite.
Lemma 4.5 Let A be a PTA on a set of parameters P, let sinit be its initial state, let K be a P-constraint on P, let i be a positive integer. Then, the number of states

in Post i
(sinit) is ﬁnite.

Proof. (sketch) Based on the fact that there is a finite number of branching at each iteration.	 

Acyclic Case
Let us first assume that all symbolic traces of A[π] are acyclic.
Theorem 4.6 Let A be a PTA on a set of parameters P, let π be a valuation of P. If all symbolic traces of A[π] are acyclic, then algorithm SYNTHESIS terminates in n iterations, where n is the length of the longest symbolic trace of A[π].
Proof. Let us first consider the inner DO loop.
At each iteration, we select an inequality J in the P -constraint associated to a state s, we negate it and add it to K. Thus, s can not be reached anymore. Moreover, no new state can be reached, as K was strengthened with the addition of ¬J . As

i remains constant in this loop, and as Post i
(sinit ) contains a finite number of

states (Lemma 4.5), then the number of states in S strictly decreases. Thus, the number of π-incompatible states strictly decreases and a finite number of iterations of the inner DO loop is performed.
Let us now consider the outer DO loop.

Let us suppose the algorithm terminates when i < n. Then, as the instanti- ated traces are acyclic, we can find an instantiated trace which is strictly bigger than any parametric trace. Which is not possible because of the correction of SYNTHESIS (Theorem 4.4).
Let us suppose we are still in the outer DO loop when i = n + 1. Then we reached new states which were not reachable at step n. Consider one state s of those new states. If s is π-compatible, then it should have been encountered in the instantiated trace, which is not possible because it has length n and is acyclic. If s is π-incompatible, then it will be cut by negation of an inequality in its associated P -constraint, and the set of states will finally be the same one as at iteration n, thus the fixpoint and the termination.

Cyclic Case
Let us now consider that the symbolic traces of A[π] may be trivially cyclic. We conjecture that our algorithm also terminates in the case where all symbolic traces of A[π] are either of finite length, or trivially cyclic. This conjecture was observed to be true on all the examples we treated.
Conjecture 4.7 Let A be a PTA on a set of parameters P, let π be a valuation of P. If all symbolic traces of A[π] are either acyclic or trivially cyclic, then algo- rithm SYNTHESIS terminates in n iterations, where n is the longest length of a symbolic trace of A[π].
An example of cyclic system is given in Sect. 5.2.
Complexity and Optimizations
An elementary complexity analysis can show that our procedure is exponential with the number of parameters P , exponential with the number of locations of A, and doubly exponential with the number of clocks X. However, in practice, we have successfully applied SYNTHESIS to various examples containing up to 10 parameters, 10 clocks and several thousands of potentially reachable locations. One reason for which it behaves well in practice, apart from the optimizations (see below), is that the procedure quickly reduces the number of reachable states, by iteratively refining K.

Optimization
The first Post i (in the outer DO loop) can actually be replaced with a simple Post computation: Post A(K)(S). Indeed, K did not change since the last computa- tion and, as i was since incremented, the Post i newly computed is only the posterior set of states of the S.
Another optimization is the test of equality S = Sprev . Its computation is theoretically exponential, but we use a method in negligible time to perform it. Indeed, in the case of our algorithm, it is sufficient in practice to consider the

number of reachable states ordered by location in order to know whether we reached the fixpoint or not. Correction of this optimization can be verified by computing

∗ A(K)
at the end of the algorithm and checking that it is equal to S.


Examples
The procedure SYNTHESIS described in Sect. 4, has been implemented under the form of a script program written in Python and calling HyTech [12] for computing the Post operator on the current set of states. The selection of the atom J to be negated is performed randomly. The experiments were conducted on a 3.20 GHz Intel Xeon with 2 GB memory. The two examples are asynchronous circuits modeled using the bi-bounded inertial delay (see [5,15]).

Flip-flop Example
Applied to the NPTA modeling the flip-flop circuit depicted with the associated set of parameter valuations given in Section 3, the program generates the following set K of inequalities ¬J in 6 seconds:
TLO > TSetup
TSetup > pu
THold > pu
THold > pu	u
A minimal constraint K' is obtained from K by removing the 3rd inequality (THold > pu ). The set of reachable states is exactly the same as the one depicted on Fig. 2. Surprisingly, we noticed that, whatever the algorithm randomly chooses at each iteration for the atom ¬J , the constraint finally computed always remains equivalently the same.
Besides, by construction on the environment (signals D, CK and Q), we have the implicit additional constraint: THI > THold . By comparison, the authors of [6] find (besides THI > THold ):
TLO > TSetup

THI > pu
u	u
g4	g2

TSetup + pl
u	u
g1	g2

THold > pu	u
l	u
g1	g2
Note that the authors of [6] generated the previous constraint in order to prevent
bad system behaviors. The bad state is defined as the case where CK ↓ occurs before Q↑. The time-abstraction of the two sets of traces (modeled under the form of a reachability graph in Fig. 2) coincide. As we chose values for the parameters having the same good behavior as in [6], and thus avoiding the bad state, our reachability graph avoids the bad state. Therefore, our constraint also prevents bad system behaviors.
Our constraint strictly includes the one of [6], which can be easily checked with HyTech. In other terms, our constraint allows a strictly bigger set of behaviors (in terms of NPTA zone inclusion) than the one in [6].



Fig. 4. And–Or Component


Fig. 5. Reachability graph for the instantiated And–Or component



An Example of Cyclic Trace
This example deals with an “And–Or” circuit described in [7] and depicted on Fig. 4. It is composed of 2 gates (one And-gate and one Or-gate) which are interconnected in a cyclic way, and the environment which corresponds to 2 input signals a and b, with cyclic alternating rising edges and falling edges. Each rising (resp. falling) edge of signal a, b,.. ., is denoted by a↑,... (resp. a↓,.. .) The delay between the

rising and the falling edge of a↑ (resp. a↓) and a↓ (resp. a↑) is in [pl + , pu
] (resp.

a	a+

[pl − , pu
]), and similarly for b. The traversal of the gate Or takes also a delay in

a	a−
l	u
Or	Or
], and likewise for gate And. There are 12 timing parameters.

A bad state expresses that the rising edge of output signal x occurs before the
rising edge of a within the same cycle. We set the parameters to the following values, ensuring that the bad state is not reachable:

u a+ u b+
u
And
= 20	pl
a
= 8	pl +
= 10	pl
= 19	pu
a
= 7	pu
= 9	pu
= 18	pl −
a
= 21	pl −
= 5	pl
= 16
= 20
= 4 

Using those values, we get the reachability graph on Fig. 5. This ensures that the bad state is not reached, i.e., the rising edges and falling edges of a, b, x alternate properly. Using our program, the following set K of inequalities ¬J is computed in 11 seconds:
pl + > pu	+ pu
a	And	b+
pl + + pl − > pu + pu
b	b	Or	a+
(4)	pl + > pu

(4)	pl
b	Or
l	u
Or	b

The set of traces, expressed under the compact form of a reachability graph, is depicted on Fig. 5 and, by construction, does not reach any bad state. As in the case of the flip-flop example, we noticed that, whatever the algorithm randomly chooses at each iteration for the atom ¬J , the constraint finally computed always remains equivalently the same. In [7], the set of generated inequalities is not given.

Final Remarks
We presented an algorithm SYNTHESIS allowing to synthesize a constraint en- suring to get the same set of traces than the set of traces of a given valuation of the parameters. Our method suits particularly well in the framework of asyn- chronous circuits. It is in particular experimented at a larger scale in the framework of French ANR project VALMEM, for synthesizing timing constraints of memory circuits designed by ST-Microelectronics. Using the implementation of the algo- rithm SYNTHESIS , we successfully treated in less than 2 minutes the case of an asynchronous circuit containing several dozens of gates. One of the objectives of this project is to treat even larger circuits, containing several hundreds of gates.
We are currently working on proving Conjecture 4.7, allowing to state that our algorithm terminates, provided all symbolic traces of A[π] are either of finite length, or trivially cyclic. This conjecture was observed to be true on all the examples we treated.
Moreover, as noticed in the two examples, the random selection of the atom
¬J in the algorithm always gives an (equivalently) identical final constraint. This phenomenon was also observed on much larger examples. It would be interesting to see under which condition this phenomenon holds.
We presented in this paper a method based on a reference valuation, leading to totally ordered traces. We are also interested in extending the method to the case of partially ordered traces.

References
R. Alur and D. L. Dill. A theory of timed automata. Theor. Comput. Sci., 126(2):183–235, 1994.
R. Alur, T. A. Henzinger, and M. Y. Vardi. Parametric real-time reasoning. In STOC ’93, pages 592–601, New York, NY, USA, 1993. ACM.
R. Alur, A. Itai, R. P. Kurshan, and M. Yannakakis. Timing verification by successive approximation. In CAV ’92. Springer-Verlag, 1993.
A. Annichini, E. Asarin, and A. Bouajjani. Symbolic techniques for parametric reasoning about counter and clock systems. In CAV ’00, pages 419–434. Springer-Verlag, 2000.
J. A. Brzozowski and C. J. Seger. Asynchronous Circuits. Springer-Verlag, 1995.
R. Claris´o and J. Cortadella. The octahedron abstract domain. In SAS ’04, 2004.
R. Claris´o and J. Cortadella. Verification of concurrent systems with parametric delays using octahedra. In ACSD ’05. IEEE Computer Society, 2005.
E. M. Clarke, O. Grumberg, S. Jha, Y. Lu, and H. Veith. Counterexample-guided abstraction refinement. In CAV ’00, pages 154–169. Springer-Verlag, 2000.
A. Collomb–Annichini and M. Sighireanu. Parameterized reachability analysis of the IEEE 1394 Root Contention Protocol using TReX. In RT-TOOLS ’01, 2001.
P. Cousot and N. Halbwachs. Automatic discovery of linear restraints among variables of a program. In POPL ’78, pages 84–96. ACM, 1978.
E. Encrenaz and L. Fribourg. Time separation of events: An inverse method. In Proceedings of the LIX Colloquium ’06, volume 209 of ENTCS, Palaiseau, France, 2008. Elsevier Science Publishers.
T. A. Henzinger, P. Ho, and H. Wong-Toi. A user guide to HyTech. In TACAS, pages 41–71, 1995.


T. Hune, J. Romijn, M. Stoelinga, and F. W. Vaandrager. Linear parametric model checking of timed automata. In TACAS ’01, pages 189–203. Springer-Verlag, 2001.

K. G. Larsen, P. Pettersson, and W. Yi.
Uppaal in a nutshell. International Journal on Software

Tools for Technology Transfer, 1(1-2):134–152, 1997.
O. Maler and A. Pnueli. Timing analysis of asynchronous circuits using timed automata. In CHARME ’95, pages 189–205. Springer-Verlag, 1995.
R. Ben Salah, M. Bozga, and O. Maler. On interleaving in timed automata. In CONCUR ’06, volume 4137 of LNCS, pages 465–476. Springer, 2006.
F. Wang and H.C. Yen. Timing parameter characterization of real-time systems. In CIAA ’03, volume 2759 of LNCS, pages 23–34, 2003.
T. Yoneda, T. Kitai, and C. J. Myers. Automatic derivation of timing constraints by failure analysis. In CAV ’02, pages 195–208. Springer-Verlag, 2002.
