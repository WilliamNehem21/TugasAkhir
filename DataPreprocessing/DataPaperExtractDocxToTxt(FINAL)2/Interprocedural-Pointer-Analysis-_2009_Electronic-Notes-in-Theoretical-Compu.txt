

Electronic Notes in Theoretical Computer Science 254 (2009) 65–83
www.elsevier.com/locate/entcs

Interprocedural Pointer Analysis in Goanna
J¨org Brauerb,2 Ralf Huucka Bastian Schlichb,2
a National ICT Australia Ltd. (NICTA) Locked Bag 6016, University of New South Wales
Sydney NSW 1466, Australia 1
b Embedded Software Laboratory Ahornstr. 55, RWTH Aachen University 52074 Aachen, Germany

Abstract
Goanna is an industrial-strength static analysis tool used in academia and industry alike to find bugs in C/C++ programs. Unlike existing approaches, Goanna uses the off-the-shelf model checker NuSMV as its core analysis engine on a syntactic flow-sensitive program abstraction. The CTL- based model checking approach enables a high degree of flexibility in writing checks and scales to large code bases. In this paper, a new approach to pointer analysis for C is described. It is detailed how this technique is integrated into the model checking approach in order to perform interprocedural analysis. The performance and precision of this approach are demonstrated using a case study.
Keywords: Static Analysis, Interprocedural Analysis, Model Checking, Pointer Analysis


Introduction
Automatic tools support software developers in detecting bugs as early as possible in the development process, and thus, help minimizing cost of devel- opment and testing. Static analysis [19] tools identify syntactically correct but semantically incorrect programs without executing or simulating the an- alyzed program. Static analyzers typically do not guarantee the absence of

1 National ICT Australia is funded by the Australian Governments Department of Com- munications, Information Technology and the Arts and the Australian Research Council through Backing Australia’s Ability and the ICT Research Centre of Excellence programs.
2 This work was carried out while being on leave at NICTA.




1571-0661 © 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.09.060

defects. In recent years, much effort has been put into the development of static analyzers and some tools have become widely used in industry [11].
Model checking [6] is an automatic technique used in the field of formal verification, which allows verifying specifications for a given system by ex-
ploring its complete state space. Goanna [16] is a static analyzer for C and
C++ programs, which differs from other static analyzers in that it uses model checking techniques to perform static analysis [12,21,20]. Using model check- ing to conduct static analysis allows a straightforward specification of desired program properties in Computation Tree Logic (CTL) [2]. Furthermore, if a specification is violated, a counterexample leading to the error is automatically generated, which is a valuable support for locating and fixing the defect.
Many static analyzers perform intraprocedural analyses without taking the effects of procedure invocations into account. Even though many defects can be found using intraprocedural analyses, other failures occur through the use of procedures in the wrong program context. A procedure may expose a correct local behavior but may still lead to a false program execution due to unexpected input values, for example. This paper describes an approach to interprocedural analysis of pointers for C based procedure summaries. Using procedure summaries allows to capture the influence of a procedure call on the program state and reuse these results whenever the corresponding procedure is called. In our approach, summaries are computed based on an intraprocedural pointer analysis.
Program Analysis in Goanna
Goanna is a static analyzer for C and C++ programs. This section first describes the general approach of Goanna, before the construction of models and the translation into the input language of NuSMV are detailed. NuSMV is used as the core analysis engine. A more thorough description of Goanna and the underlying intraprocedural analysis framework is given by Fehnker et al. [12].
Overview
The basic idea of the approach implemented in Goanna is to map a C/C++ program to its control flow graph (CFG) and to automatically label nodes in the CFG with syntactic constructs of interest such as declarations of variables. The CFG together with the labels can be seen as a Kripke structure [6], which
can be easily mapped to the input language of a model checker. Goanna
uses an interval constraint solving approach based on the work of Gawlitza and Seidl [14] to detect buffer overruns. This approach is also used to per-

form false path elimination [13], a technique related to counterexample guided abstraction refinement [5].

Model Construction
An abstract syntax tree (AST) of a C/C++ function over alphabets of at- tributes ΣL, ΣE can be seen as an attributed tree (L, E, μL, μE) with nodes L, edges E, and labeling functions μL : L → ΣL and μE : E → ΣE. The labeling functions assign attributes to nodes and edges, respectively. Nodes are labeled with program statements and expressions, while edges are attributed with the role of a branch. For instance, the edges leaving an if-then-else statement are labeled with then and else, or the edges leaving a node representing a binary operator are labeled with rhs and lhs to indicate right-hand side and left-hand side operands.

1   fibonacci ( n) {
2	  x = 0, y = 1, q, i = 0;
 {
  oldy = y;
y = x;
q = x + oldy ;
x = q;
i ++;
9	}  (i < n);
10	 q; 
11 }

Fig. 1. Example C program.
From an AST, a CFG can be constructed in a straightfordward manner. A CFG is a directed graph with a single root node. Note that a CFG does not contain all information available in the AST, only the control structure down to the level of statements is contained. No information about expressions or types is present. Given the set of atomic propositions AP , a triple (Lf , Ef , μf ) with nodes Lf representing statements, an edge relation Ef ⊆ Lf × Lf , and an additional labeling function μf : Lf → 2AP defines a CFG. The label- ing function μf defines the set of atomic propositions holding in a program location.
The CFG of the function fibonacci() from Fig. 1 is depicted in Fig. 2. The node labels in the CFG correspond to line numbers. The CFG is annoted with atomic propositions for the use of variable q. The variable q is declared

in line 2 and then assigned a value in line 6. Its value is read in lines 7 and 10.


Fig. 2. CFG of the function fibonacci() in Fig. 1.


2.3	Translation to NuSMV
In order to automatically check the generated model with respect to de-

fined properties, it is translated into a
NuSMV
model.	For a C/C++

function f , we translate the corresponding labeled CFG (Lf , Ef , μf ) and

a set of specifications CTLf over AP into a (varf , Δf , Def f , CTLNuSMV), where:
NuSMV
model NuSMV f  =

varf is an enumerated type variable over the set of nodes Lf .
Δf ⊆ Lf × Lf is the transition relation defined as Δf := {(l, succ(l))|l ∈ Lf ∧ succ(l)= {l'|(l, l') ∈ Ef }}. The target of each transition is the set of reachable locations.
Def f = {deﬁne(p)= {l|μf (l)= p ∧ l ∈ Lf }|p ∈ Σf }, where every deﬁne(p) is a DEFINE declaration, which indicates that an atomic proposition p ∈ AP holds in a particular set of locations.
CTLNuSMV is the set of CTL specifications CTLf in NuSMV syntax.
This model is automatically generated and used as the input for NuSMV. If one of the specifications in CTLNuSMV is violated, a counterexample trace is generated and mapped to the corresponding C statements, which helps users to understand how the defect emerged. Consider the CTL specification AG (declq ⇒ (A ¬readq W writeq)). This formula expresses that whenever vari- able q has been declared, no path exists such that q is read before it is assigned a value. The CFG in Fig. 2 satisfies this formula.

Intraprocedural Pointer Analysis
This section details our approach to intraprocedural pointer analysis for C, which serves as a basis for both the generation of procedure summaries and

the actual detection of bugs (see Sect. 4). This is achieved by augmenting the
NuSMV model with additional interprocedural information.
In presence of aliasing, a memory location can be accessed through dif- ferent variables. In combination with structured types, this leads to complex problems to be tackled when analyzing pointer dependencies. Our under- lying memory model abstracts from the physical representation to a coarse symbolic model but does not handle complex pointer arithmetic. The pre- sented algorithm computes for each variable and each program location the sets of memory locations a variable can alias, its so-called points-to sets. The approach comprises the following steps:
An intraprocedural abstraction of the physical memory is generated from the analyzed procedure.
Based on this representation, a static memory ownership model is estab- lished.
An equation system that represents dependencies between pointers in all program locations is generated.
A reduction pass that resolves aliasing dependencies is conducted.
The least solution of the reduced equation system is computed.
These steps are resembled by the structure of this section and detailed in the following. In the end, an example is presented. Given a procedure f , the following notations are introduced: Let Lf be the set of all program statements in f , and let Vf be the set of all variables under the scope of f . For the following computations, each procedure is converted into canonical static single assignment form [7]. This means, a unique instance of each variable is introduced for each program location. In this representation, a variable is a pair (v, l) ∈ Vf × Lf , which we denote by vl. We denote the initial statement in Lf by 0, that is, the initial values of v under the scope of a procedure are denoted by v0.

Abstract Memory Model
In the memory abstraction used, memory locations are represented by sym- bolic values, which are induced through a number of constructs in C. A call of malloc(), for instance, allocates memory and returns an address, or memory locations may be introduced by parameters. Two special purpose labels are in- troduced: one for the address NULL, which is typically assigned to uninitialized pointers, and * to denote addresses resulting from operations not modeled in our abstraction. Nested pointers such as int** are currently not supported. The set of all memory locations in a procedure f is denoted by Mf . The

number of labels in f is finite and the corresponding powerset 2Mf forms a complete lattice with the common operations on sets, ⊥ = ∅, and T = Mf .
Furthermore, we define Mf := Mf \ {*, NULL}.
Memory Ownership
A static ownership model for each symbolic memory value is computed. This

means, for every memory label in Mf
it is detected which variable it is first

assigned to. This model is used both for the generation of intraprocedural
alias information and interprocedural summaries (cp. Sect. 4). A variable vl

owns a memory location m ∈ Mf
iff v is assigned m in l, and l is the first

occurence of m. The ownership relation defines a mapping θ : Mf → Vf ×Lf ,
which is used to distribute effects of operations on memory locations to all
corresponding aliases in the following steps.
Encoding of Memory Aliasing
In data flow analysis, a standard approach to express and to solve relations of variables in different program locations is to encode these in terms of equation systems [19], which allows to resolve cyclic dependencies. In case of pointer analysis, a variable represents a subset of Mf . For each variable v ∈ Vf and each program location l ∈ Lf , we introduce an equation. These equations have one of the following two forms:
vl ∼= x: Here, x is a variable or a memory location, x is assigned to variable
v in program location l.
vl ∼= {φ(vk)|k is predecessor of l}: This equation unites values of v coming from predecessors of l in the CFG if vl is not changed in l. The function φ : Vf → Vf transforms the incoming values according to the encoding described in the following. That is, it maps variables to variables in order to handle aliasing.
In case a complex expression is assigned to vl, we set vl ∼= *. That is, the lattice element representing unknown is assigned to vl. Intuitively speaking, the equation system assigns to each vl either a value assigned in l or propagates incoming information along the CFG if vl is not changed. The challenge with modeling aliasing in structures is that assignments to a field of a structure influence its own children and the children of all respective aliases. To model this, we cover four different situations during the generation of an equation for a variable v ∈ V f in a program location l ∈ Lf .
For v ∈ V f such that v0 /= θ(m) for all m ∈ Mf , set v0 ∼= ⊥. That is, all variables that are not initialized in the first program location, for

instance, through a function parameter, are set to ⊥.
There exists m ∈ Mf such that vl = θ(m). In this case, the equation vl ∼= m is generated. This is the case if a fresh memory label is introduced at location l and assigned to variable v, for instance by a C statement such as int *q = (int*)malloc(sizeof(int)).
vl is an alias created in the C program in location l, for instance, through an assignment of the form int *v = w. The value assigned to v is the value of w coming from a predecessor of l in the CFG. The source variable w in the assignment is marked as a reference, denoted by vl ∼= −→wl. The explicit notation of references is used to denote variables that alias a memory location owned by another variable. References are used to track
transitive dependencies between owning and non-owning variables. If v is of structured type, the same procedure is applied to all children of v. That is, we set v->pl ∼= −−−→. Otherwise, assignments made to children
of a non-owning alias would not affect the children of the owning alias.
If the value of vl is not changed by the statement in l, then we set vl ∼=
{φ(vk)|k is a predecessor of l} where φ replaces all references wk' in vk
with updated references −→wl, which expresses that vl corresponds to wl. If
there exists l' ∈ Lf and m ∈ Mf such that vl' = θ(m), then vk is replaced with m. The other values remain unchanged by φ.
Step (iv) transforms references in incoming variables to express that the references in the equation correspond to the variables in the current program
location l. References – denoted by −→wl – are a syntactic means used to model
that v corresponds to w in the same program location. If the equations are generated following the rules described above, a unidirectional syntactic de- pendency between owners and non-owners of a memory location is established in the equation system. As these rules explicitly tackle aliasing, they are only applied to pointer variables.
Reduction
During the reduction phase, all references in the equation system are elimi- nated to perform a unification of owning and non-owning aliases. The model- ing of aliasing in the previous section has introduced references on the right-
hand sides of the equation system such as, for instance, vl ∼= wl− . These references were introduced to track aliasing dependencies.
In the reduction step, references are resolved to distribute information from actions applied to non-owning variables to other aliases. Without this step, the effects would only be visible to the owning variable. As a result, all aliases correspond to the same memory labels. If we write v->v' in a structure, then

v and v' may be structured variables themselves. Using this notation, the described reduction can easily be applied to nested structures. The equation system is reduced by applying the following actions:
Phase 1 The first phase reduces references in structures. If v->vl owns a memory location m ∈ Mf and the direct predecessor vl− of vl contains a reference wl− , then the following four actions are conducted:
The existing equation for w->vl is removed from the equation system.
The value m is assigned to w->vl , all variables referenced in the original
'	'
equation of w->vl , and all variables referencing w->vl . This operation
can be implemented efficiently by storing all references while the equa- tion system is generated in the first place.
The reference wl− in the equation of vl− is replaced by wl− .
For all attributes w' of the structure w, we set w->w' = ⊥.
These steps are repeated for all variables owning memory locations. If vl−
−→
contains a reference wl− , this means that in a statement preceeding the
current statement, the variable vl− is an alias of a memory location owned by the variable w in some program location.
Phase 2 All references that still exist in the equation systems are replaced
with the corresponding values, for instance, a reference −→wl is replaced with
wl.
In the resulting equation system, all dependencies caused by aliasing be- tween structures are resolved and replaced by assignments of values.

Resolving Dependencies
The points-to sets are then generated by computing the least fixed point of the equation system, which is implemented using the worklist algorithm [19]. The least fixed point of the equation system defines the points-to set of each vari- able in each program location. The existence of least fixed point is guaranteed by the finiteness of Mf and the monotonicity of the operations.

Example
This section describes the intraprocedural pointer analysis for the example function perform() depicted in Fig. 3. Here, memory for two structures of types dev t and cont t is allocated. An alias q for the field s->p is created, and using this alias, memory for the field q->v is allocated. That means, that q->v and s->p->v alias the same memory location.
The structure of the stack and the heap as well as the points-to depen- dencies of this program after execution of the corresponding line numbers is


  dev_t * s = ( dev_t *) malloc ( ( dev_t ));
s->p = ( cont_t *) malloc ( ( cont_t ));
	cont_t * q = s- >p ;
q->v = ( *) malloc ( ( ));
9 }

Fig. 3. Example program for nested aliasing of structures in C.
depicted in Fig. 4.

4	5	6	7	8
Stack



Heap



Fig. 4. Structure of stack and heap during execution perform().
Encoding the nested aliasing using the algorithm described in Sect. 3.3 leads to the equation system depicted in Fig. 5 for the procedure perform(). For clarity, variables as well as memory locations introduced in a statement are annotated with their corresponding line numbers. The equation s5 ∼= m5
is generated by applying condition (ii) from Sect. 3.3. In contrast, the updated

reference in the equation q8
−−−→
= s->p8 is generated due to the application of con-

dition (iv). Note, that at this stage no connection between s->p->v and q->v
exists, and hence, no information can be passed from q->v to s->p->v. This implies that the allocation of memory using q->v is not passed to s->p->v, although they alias the same memory location.
Reducing the equation system shown in Fig. 5 produces the equation sys- tem given in Fig. 6. The equations for the variables s and s->p remain un- changed by the reduction algorithm, and hence, they are omitted here. The

reference in the equation q->v7
−−−−−−→
= s->p->v7 causes the memory location m8

to be passed to s->p->v8. The least fixed point at the end of the analyzed
procedure perform() produces the exact points-to sets, namely s8 = {m5},
s->p8 = {m6}, s->p->v8 = {m8}, q8 = {m6}, and q->v8 = {m8}.


Fig. 5. Equation system generated from procedure perform() in Fig. 3 before reduction.

Fig. 6. Reduced equation system generated from Fig. 5.
Interprocedural Analysis
This section details how to capture the behavior of functions with respect to pointer analysis using procedure summaries based on the intraprocedural points-to sets. Moreover, it describes our approach of combining aliasing infor- mation with procedure summaries in the intraprocedural analysis framework of Goanna. This allows us to detect invalid memory accesses that result from procedure calls by extending the existing intraprocedural model described in Sect. 2.

Procedure Summaries
In Goanna, procedure summaries are represented as sets of variables. Each procedure summary describes a single property of interest and contains vari- ables for which the respective property is fulfilled after termination of the procedure. Due to the call-by-value semantics of C, three kinds of summaries are required to detect invalid memory accesses across boundaries of proce- dure scopes. These summaries for a function f state whether a parameter is dereferenced, validated, or invalidated.
An invalid pointer directly passed to a function cannot be validated by the callee because a copy of the aliased address is passed and not the address of

the pointer itself. This is only true in the absence of nested pointers such as int**. In contrast, uninitialized fields in a structure can be validated because their addresses may be accessed through the structure stored on the heap. The set of parameters does not only contain explicitly declared formal parameters, but also parameters hidden in structures. This is called a transitive attribute closure. Given a parameter p in f and m ∈ Mf with p0 := θ(m), we have the following summaries:
Memory Dereference p ∈ Ðf iff m is dereferenced in f or passed to a procedure called from f , where it is dereferenced.
Memory Invalidation p ∈ ff iff m is invalidated in f , for instance, by calling free(), or passed to a procedure g called by f and invalidated in g. Memory Validation p /∈ Vf if p is of simple type for the reasons described
before. That is, pointers passed by value cannot be validated in a called function. Memory for fields in structures, however, can be validated. De- tection of validation is based on the intraprocedural points-to sets.
A call graph is a directed graph where each node represents one procedure in the analyzed program. It contains an edge (f, g) if g is called by f . Proce- dure summaries describe the behavior of f . Moreover, the summaries depend on all summaries of functions called from f . If the call graph is acyclic, the summaries are generated by visiting all procedures in reverse topological order. In contrast, recursive dependencies between procedures require computing the least fixed point in all strongly connected components.

Model Generation


In this section, we describe how a
NuSMV
model for the interprocedural

analysis of pointers is generated based on procedure summaries and the in- traprocedural pointer analysis. The underlying model is an extension of the intraprocedural model given in Sect. 2.3. Given a procedure f and its intrapro- cedural model NuSMV f = (var f , Δf , Def f , CTLf ), the interprocedural model
for pointer analysis is a quadruple NuSMV f	= (var f , Δf  , Def f  , CTLf  )
PA	PA	PA	PA	PA 
consisting of:
Variables varf	For each memory location m ∈ Mf , we introduce a state
variable with possible values valid and invalid to track state changes during
the execution of f . Note that memory allocations indicated by the validation summary Vf increase the size of Mf , and hence, the number of state vari- ables. The coarse memory abstraction leads to a symbolic memory address
* for unknown memory locations. To avoid producing a multitude of spuri- ous warnings, we exclude this label, which leads to an under-approximation.

Hence, it is varf	= varf ∪ Mf .

Transitions Δf
Each m ∈ Mf
is initialized with valid .	Furthermore,

for each invocation of a function g in a statement l ∈ Lf to which
m is potentially passed, the effect of the function call is encoded based on the memory invalidation summary fg. Hence, we add a transition (statement = l ∧ m = valid ) → m = invalid to the model if we have m ∈ fg. That is, if the corresponding summary states that m may be invalidated by g, then the status of m is changed to invalid .
Labels Def f	For each dereference of a memory location m ∈ Mf in a pro-
gram location l ∈ Lf based on the dereference summary, a label deref m is
added to the state representing l.
Specifications CTLf	For each memory location m ∈ Mf , we add an in-
variant specification AG(deref m ⇒ m = valid ).  That is, if a variable
aliasing m is derefenced, then m is required to be valid.
In the memory abstraction used, memory locations are introduced through parameters or return values of functions such as malloc(). Pointers accessed in f may be invalid in both cases: A programmer may pass an invalid pointer to f or malloc() may fail. In the first case, the defect in f is detected during the analysis of the caller of f . The second case is dealt with by an intraprocedural check that requires all allocated memory to be checked before it is dereferenced. To detect dereferences of NULL pointers, a specification AG(¬deref NULL) is added.

The encoding of the pointer analysis in the
NuSMV
model could be

conducted in a different manner.  It would, for instance, also be possi- ble to distribute the detected memory statuses to all program locations us- ing a forward data flow analysis and label the corresponding locations with atomic propositions. In this case, an invariant specification of the form AG¬(deref m ∧ invalidm) would be sufficient and state variables are not re- quired.

Example
This section describes the application of the analysis to parts of the Linux
2.6 kernel, namely the sound module. The code contains a defect caused by false pointer deallocation nested in two function calls. The procedure snd hwdep release() in Fig. 7 is implemented in sound/core/hwdep.c. In line 10, it calls snd card file remove() (see Fig. 8) and passes hw->card, which is then dereferenced in line 12.
The function snd card file remove() calls snd card do free(), which

		snd_hwdep_release ( inode * inode ,
  file * file ) {
  err = - ENXIO ;
	snd_hwdep * hw = file - > private_data ;
mutex_lock (& hw - > open_mutex );
  ( hw - > ops . release ) {
err = hw - > ops . release ( hw , file );
hw - >used --;
9	}
snd_card_file_remove (hw - >card , file ); // free
mutex_unlock (& hw - > open_mutex );
module_put ( hw - >card - > module );	// deref
 err ;
14 }

Fig. 7. Function snd hwdep release from Linux 2.6 kernel.
invalidates the parameter hw->card by calling kfree(). This means, when hw->card is dereferenced in line 12 of snd hwdep release(), it has possibly been freed. The summaries generated for snd card file remove() are:
Ðsnd card file remove = {card} fsnd card file remove = {card}
In the model of snd hwdep release(), the variable hw->card is mapped to card in snd card file remove() and the invalidation summary is applied. This means, the state of hw->card in the NuSMV model is set to invalid

when the function snd card file remove() is called.
NuSMV
reports a

violation of the specification AG(derefhw->card ⇒ hw->card = valid) in line
12.
		snd_card_do_free ( snd_card * card ,
  file * file ) {
...
  ( last_close ) {
wake_up (& card - > shutdown_sleep );
  ( card - > free_on_last_close )
snd_card_do_free ( card );
8	}
9 }

Fig. 8. Functions snd card file remove() and snd card do free() from Linux 2.6 kernel.

Case Study
We have evaluated the performance of the intraprocedural pointer analysis and the summary-based interprocedural analysis by analyzing some source directories of OpenSSL 0.9.8d. These directories contain between 1,633 and 28,916 lines of C code. This section first describes the applied checks and then presents the analysis results.

Evaluation Principles
The hardware platform used for the experiments is a DELL PowerEdge
SC1425 server, with an Intel Xeon processor running at 3.4 GHz, 2 MiB
L2 cache and 1.5 GiB DDR-2 400 Mhz ECC memory. We compare the per-
formance of Goanna running with the following three configurations: (i)
intraprocedural analysis with all standard checks enabled, but array bounds checking and false path elimination disabled, (ii) with intraprocedural pointer analysis, and (iii) with summary-based interprocedural analysis. The standard checks include checks for uninitialized variables, unused values, unreachable code and simple memory checks, which do not consider aliasing. For the other configurations, these checks are performed as well. Moreover, the runtimes also include the time required for parsing the respective programs. For com- pleteness, we compare the results with the time needed by GCC required for compiling these source directories.

Analysis Performance
The analysis performance is depicted in Tab. 1. The intraprocedural pointer analysis usually requires 3 to 6 times more time than the analysis with stan- dard checks. The runtimes show that the interprocedural analysis scales with the code size. The modeling of implicit aliasing through the transitive at- tribute closure introduces large numbers of auxiliary variables in the equation system, and in consequence, slows down the pointer analysis.
About 90% of the slowdown caused by the pointer analysis is spent on the generation of the equation system. Fehnker et al. [12] already noticed that one particular performance bottleneck of Goanna is the currently used tree matching algorithm for the AST, which is based on an XML represen- tation and XPath in order to detect statements and expressions of interest. This mechanism is extensively used when the equation system is generated and causes most of the slowdown. The fixed point iteration for computing the points-to sets themselves is barely noticeable in terms of runtime. The same applies for model checking the extended interprocedural model. During

Table 1
Analysis performance of Goanna for OpenSSL 0.9.8d.

the evaluation, we found some files for which the poor performance results was caused by extensive use of preprocessor macros, which introduced large numbers of auxiliary variables. The analysis of the files in the crypto/engine directory, for instance, was slowed down by one file eng padlock.c, on which 70% of the overall runtime was spent.
Despite these downsides, we showed that the developed approach can be successfully applied to large code bases. We have also applied the approach to parts of the Firefox codebase, for which the slowdown was also linear. Applying Goanna to the complete source code of Firefox did not produce meaningful results due to the extensive use of C++ features such as templates. The performance drawback could be minimized by optimizing the XPath al- gorithm, which would lead to competitive runtimes. In practice, runtimes can be significantly decreased using incremental analysis. Only those program fragments affected by a modified summary have to be reanalyzed. Typically, this involves only small parts of the program.

Related Work
In Steensgard’s flow-insensitive algorithm based on unification [23], the pointer analysis problem is reduced to finding a well-typed environment using set con- straints, which allows a points-to analysis in almost linear time. Andersen’s subtyping-based approach [1] relies on constraint solving over inclusion con- straints. The algorithm is slower than Steengard’s approach, but produces more precise results. The approach by Das [8] is an extension of Steensgard’s algorithm based on a restricted form of subtyping. Unification of symbols at top levels of pointer chains in the points-to graph is avoided. Shapiro and Horwitz [22] developed an extension of Steensgard’s algorithm in which the points-to set of a variable is partitioned into multiple categories. All ap- proaches described so far are flow-insensitive.

Flow-sensitive analyses produce more precise results than flow-insensitive approaches. In practice, however, Hind and Pioli [15] observed little ben- efit on most benchmarks. Nevertheless, a flow-sensitive approach promises a lower rate of spurious warnings. An interprocedural algorithm for condi- tional may-aliasing based on abstract interpretation was described by Landi and Ryder [17]. Choi et al. [4] presented an interprocedural algorithm, which combines flow-sensitive and -insensitive techniques. A similar approach was described by Emami et al. [10], who proposed a technique for context-sensitive analysis of stack-allocated data structures, which is specifically suitable in the presence of function pointers. In contrast, our approach focuses on heap- allocated data. An interprocedural analysis algorithm for recursive data struc- tures was described by Deutsch [9]. Another context-sensitive points-to anal- ysis, which uses partial transfer functions for procedure summaries, was devel- oped by Wilson and Lam [24]. Incomplete transfer functions are used, which only cover input conditions that exist in a program. Their points-to analysis uses an iterative data flow approach to find potential pointer values. Cheng and Hwu [3] described an approach using accesses paths for interprocedural pointer analysis of C programs based on context-sensitive transfer functions. Access paths are used to distinguish non-recursive heap structures.
Closely related to our approach is the context-insensitive but flow-sensitive points-to analysis for Java programs described by Ma and Foster [18]. Their abstraction of physical memory using memory labels is similar to our approach. In contrast to our algorithm, their approach lacks support for nested data structures. While most approaches rely on equation solving in order to resolve points-to information, Ma and Foster use constraint solving.

Conclusion and Future Work
Many defects found in real software are related to false handling of pointers. This is especially true for languages such as C, which allow arbitrary pointer arithmetic and have no built-in mechanisms for pointer safety. It turned out that static analysis based on purely syntactic properties of a program allows an efficient analysis but also generates large numbers of false warnings. We
have combined the syntactic analysis framework in Goanna with a mem-
ory abstraction. This paper describes an approach to interprocedural pointer analysis that is integrated into the intraprocedural analysis framework. This approach consists of a two-pass algorithm. First, an intraprocedural pointer analysis is performed, based on fixed point iteration over an equation system. The obtained intraprocedural points-to information is then integrated into a

NuSMV
model for interprocedural analysis, which is used by
Goanna to

conduct static analysis.
The implementation smoothly integrates into the existing framework. The intraprocedural analysis alone improves the existing intraprocedural analysis framework. It integrates well with incremental analyses. The interprocedural NuSMV model is an extension of the original model. One of the advantages of using model checking for static analysis is the automatic generation of counterexamples. With interprocedural analysis using summaries, this cannot be achieved easily. During the analysis of a function, no information about the intrinsics of called functions is present. Hence, different techniques have to be developed to tackle this problem.
The pointer analysis is based on a coarse abstraction of the physical mem- ory, which has proven to be powerful enough to detect bugs in real software. The discussed approach has some disadvantages. One obvious flaw of the cur- rent implementation is the assumption that parameters passed to a function are separated, that is, they do not alias the same memory locations. This can be fixed with minor extensions of the described algorithm. Only the results of the points-to analysis have to be updated, that is, aliasing of parameters can be expressed by replacing memory labels introduced through two parameters by a single one. The corresponding procedure does not have to be reanalyzed. Another improvement would be to integrate of the interval solving tech- niques and the memory model to gain further precision. A challenge for static code checkers is to detect inobvious defects while not producing vast amounts of spurious warnings, which is sometimes contradictory. The average defect density in Goanna is around 0.3 to 2 bugs per 1,000 lines of code, which is comparable with commercial static analyzers [11]. The number of false warn- ings strongly depends on the analyzed code. Function pointers, for instance, often cause spurious warnings. Combining different techniques promises the detection of more classes of defects while at the same time reducing the number
of false warnings.

References
Andersen, L. O., “Program Analysis and Specialization for the C Programming Language,” Dissertation, DIKU, University of Copenhagen, Copenhagen, Denmark (1994).
Ben-Ari, M., Z. Manna and A. Pnueli, The temporal logic of branching time, Acta Informatica
20 (1983), pp. 207–226.
Cheng, B.-C. and W.-M. W. Hwu, Modular interprocedural pointer analysis using access paths: Design, implementation, and evaluation, in: Programming Language Design and Implementation (PLDI 2000), Vancouver, Canada (2000), pp. 57–69.
Choi, J.-D., M. Burke and P. Carini, Efficient flow-sensitive interprocedural computation of pointer-induced aliases and side effects, in: Principles of Programming Languages (POPL 1993), Charleston, USA, 1993.

Clarke, E. M., O. Grumberg, S. Jha, Y. Lu and H. Veith, Counterexample-guided abstraction reﬁnement, in: 12th International Conference on Computer Aided Veriﬁcation (CAV 2000), Chicago, USA, Lecture Notes in Computer Science 1855 (2000), pp. 154–169.
Clarke, E. M., O. Grumberg and D. A. Peled, “Model Checking,” The MIT Press, 1999.
Cytron, R., J. Ferrante, B. K. Rosen, M. N. Wegman and F. K. Zadeck, Effciently computing static single assignment form and the control dependence graph, ACM Transaction on Programming Languages and Systems (1991), pp. 451–590.
Das, M., Uniﬁcation-based pointer analysis with directional assignments, in: ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI 2000), Vancouver, Canada (2000), pp. 35–46.
Deutsch, A., Interprocedural may-alias analysis for pointers: Beyond k-limiting, in: Programming Language Design and Implementation (PLDI 1994), New York, USA, 1994, pp. 230–241.
Emami, M., R. Ghiya and L. J. Hendren, Context-sensitive interprocedural points-to analysis in the presence of function pointers, in: Programming Language Design and Implementation (PLDI 1994), Orlando, USA (1994), pp. 242–256.
Emanuelsson, P. and U. Nilsson, A comparative study of industrial static analysis tools, in: 3rd International Workshop on Systems Software Veriﬁcation (SSV 2008), Sydney, Australia, Electronic Notes in Theoretical Computer Science 217 (2008), pp. 5–21.
Fehnker, A., R. Huuck, P. Jayet, M. Lussenburg and F. Rauch, Model checking software at compile-time, in: Theoretical Aspects of Software Engineering (TASE ’07), Shanghai, China (2007), pp. 45–56.
Fehnker, A., R. Huuck and S. Seefried, Counterexample guided path reduction for static program analysis, in: Correctness, Concurrency, Compositionality: Essays in honor of Willem-Paul de Roever, Lecture Notes in Computer Science (2008).
Gawlitza, T. and H. Seidl, Precise ﬁxpoint computation through strategy iteration, in: 16th European Symposium on Programming (ESOP 2007), Braga, Portugal, Lecture Notes in Computer Science 4421 (2007), pp. 300–315.
Hind, M. and A. Pioli, Assessing the effects of flow-sensitivity on pointer alias analyses, in: Symposium on Static Analysis (SAS 1998), Pisa, Italy, Lecture Notes in Computer Science (1998), pp. 57–81.
Huuck, R., A. Fehnker, S. Seefried and J. Brauer, Goanna: Syntactic software model checking, in: Automated Technology for Veriﬁcation and Analysis (ATVA 2008), Seoul, Korea, Lecture Notes in Computer Science 5311 (2008), pp. 216–221.
Landi, W. and B. G. Ryder, A safe approximate algorithm for interprocedural pointer aliasing, in: Programming Language Design and Implementation (PLDI 1992), San Francisco, USA (1992), pp. 473–489.
Ma, K.-K. and J. S. Foster, Inferring aliasing and encapsulation properties for Java, in: ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA 2007), Montreal, Canada (2007), pp. 423–440.
Nielson, F., H. R. Nielson and C. Hankin, “Principles of Program Analysis,” Springer, 1999.
Schmidt, D. A., Data flow analysis is model checking of abstract interpretations, in: 25th ACM Symposium on Principles of Programming Languages (POPL 1998), San Diego, USA (1998),
pp. 38–48.
Schmidt, D. A. and B. Steffen, Program analysis as model checking of abstract interpretations, in: 5th International Symposium on Static Analysis (SAS 1998), Pisa, Italy, Lecture Notes in Computer Science 1503 (1998), pp. 351–380.
Shapiro, M. and S. Horwitz, Fast and accurate flow-insensitive points-to analysis, in: 24th Symposium on Principles of Programming Languages (POPL 1997), Paris, France (1997), pp. 1–14.

Steensgard, B., Points-to analysis in almost linear time, in: 23th ACM Symposium on Principles of Programm Language (POPL 1996), St. Petersburg Beach, USA (1996), pp. 32–41.
Wilson, R. P. and M. Lam, Efficient context-sensitive pointer analysis for C programs, in: SIGPLAN Conference on Programming Language Design and Implementation (PLDI 1995), La Jolla, USA (1995), pp. 1–12.
