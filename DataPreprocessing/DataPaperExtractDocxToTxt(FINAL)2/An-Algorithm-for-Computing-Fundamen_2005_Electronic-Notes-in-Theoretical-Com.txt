Electronic Notes in Theoretical Computer Science 120 (2005) 201–215 
www.elsevier.com/locate/entcs


An Algorithm for Computing Fundamental Solutions
Klaus Weihrauch1
Department of Computer Science Fernuniversitat
58084 Hagen, Germany
Ning Zhong2 ,3
Department of Mathematical Sciences University of Cincinnati
Ohio 45221-0025, USA

Abstract
For a partial differential operator P = P  cαDα with constant coefficients cα, a generalized function u is a fundamental solution, if Pu = δ, where δ is the Dirac distribution. In this article we provide an algorithm which computes a fundamental solution for every such differential operator
P on a Turing machine, if the input- and output-data are represented canonically.
Keywords: computable analysis, partial differential equations, fundamental solution


Introduction
In the theory of differential operators with constant coefficients, fundamental solutions have a central place. Let
P = P (D)=	cαDα	(1)
|α|≤m

1 Email: Klaus.Weihrauch@fernuni-hagen.de
2 Email: Ning.Zhong@uc.edu
3 The author has been supported in part by the University of Cincinnati’s Summer Faculty
Research Fellowship.


1571-0661 © 2005 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2004.06.045


be a partial differential operator with constant coefficients cα, where α =
(α1,... , αn) is a multi-i√ndex of order |α| = α1 + ··· + αn, Dj = (1/i)∂/∂xj
α	α1	α2	αn
with 1 ≤ j ≤ n and i =	−1, D = (D1,... , Dn) and D  = D  D	··· D	. A 
distribution is called a fundamental solution of the partial differential operator
P if it is a solution of the point source problem

P (D)u =
|α|≤m
cαDαu = δ	(2)

where δ is the Dirac measure at 0. In 1954 Malgrange and Ehrenpreis proved that every partial differential operator with constant coefficients has a funda- mental solution. Fundamental solutions are very useful tools in the theory of partial differential equations, for instance, in solving inhomogeneous equations and in providing information about the regularity and growth of solutions. In the case of solving inhomogeneous equations, if E is a fundamental solution of the partial differential operator P = P (D) and if f is a distribution, then, E f is a solution of the equation P (D)u = f whenever the convolution is defined.
Many classical differential operators are known to have computable func- tions as fundamental solutions. For example, the Schwartz function
E  (t, x)= (4πνt)−n/2e−|x|2/4νt
which is a computable real function, is a fundamental solution of the heat equation
n	2
∂u = ν Σ ∂ u, (t, x) ∈ R × Rn.

∂t
i=1
∂x2

In general, however, a fundamental solution is a distribution. Has every partial
differential operator P (D) with computable coefficients a computable funda- mental solution? In fact, this follows from the even more general result we prove in this note: There is a computable operator mapping every differential operator P (D) (as in (1)) to a fundamental solution. We present an algorithm which in a well-defined realistic model of computation computes a fundamen- tal solution of any given differential operator P from its coefficients, where abstract data are encoded canonically by, generally infinite, sequences of sym- bols and computations are (can be) performed by Turing machines.

Preliminaries
In this note, we consider the representation approach as a model of compu- tation for analysis [5]. Computable functions on Σ∗ and Σω (the set of finite


and infinite sequences of symbols, respectively, from the finite alphabet Σ) are defined by Turing machines which can read and write finite and infinite sequences. A multifunction f : ⊆ X ⇒ Y is a function which assigns to every x ∈ X a set f (x)⊆Y , the set of “acceptable” values (f (x)= ∅, if x /∈ dom(f )).
Computability on other sets is defined by using Σ∗ and Σω as codes or names. A notation (representation) is a multifunction ν :	Σ∗ ⇒ M (δ : Σω ⇒ M). For the natural numbers and the rational numbers we use canonical notations νN : ⊆ Σ∗ → N and νQ : ⊆ Σ∗ → Q, respectively. For the real numbers we use the representation ρ : ⊆Σω → R, where ρ(p)= x if p encodes a sequence (ai)i of rational numbers such that |x − ai| ≤ 2−i. For a naming system γ : ⊆ Y → M (Y ∈ {Σ∗, Σω}) the representation γk : ⊆ Y → Mk is defined by γ y1,... , yk := (γ(y1),... γ(yk)) where	is a tupling function. For the complex numbers we use the representation ρ2 of R2.
For naming systems γi : ⊆ Yi ⇒ Mi a function h : ⊆ Y1 → Y2 (on sequences of symbols) realizes a multifunction f : ⊆ M1 ⇒ M2, if
γ2 ◦ h(y) ∩ f (x) /= ∅	if γ1(y) ∈ dom(f ) ,
that is, h(y) is a name of some z ∈ f (x) if y is a name of x ∈ dom(f ). The multifunction f is (γ1, γ2)-computable, if it has a computable realization, and (γ1, γ2)-continuous, if it has a continuous realization.
Multifunctions occur naturally in Computable Analysis. As an example, there is an algorithm which maps every ρ-name p of x  R (i.e., every se- quence of rational numbers rapidly converging to x) to some n N such that x < n. This algorithm, however, might give another upper bound n' of x, if fed with another ρ-name p' of x. The algorithm is not “(ρ, νN)-extensional”. Nevertheless, the algorithm realizes the multifuntion f : R ⇒ N, defined by n  f (x)   x < n. There is no (ρ, νN)-computable function g : R  N such that x < f (x).
As generalizations of the “acceptable Go¨del numbering ϕ : N → P (1)” of the partial recursive functions, for any a, b  , ω there is a canonical representation ηab : Σω  F ab of continuous functions f : Σa  Σb sat- isfying the “utm-theorem” and the “smn-theorem” [5]. For naming systems γ1 : ⊆ Σa → M1 and γ2 : ⊆ Σb → M2 a representation [γ1 → γ2] of the total (γ1, γ2)-continuous functions is defined by


[γ1 → γ2](p)= f : ⇐⇒ ηab
realizes f	w.r.t. (γ1, γ2) ,

and a multirepresentation [γ1 →p γ2] of all partial (γ1, γ2)-continuous functions is defined by


f ∈ [γ1 →p γ2](p): ⇐⇒ ηab
realizes f	w.r.t. (γ1, γ2) .


Notice that [γ1 → γ2] is the “weakest” representation δ of the set of total (γ1, γ2)-continuous functions such that the evaluation (f, x) '→ f (x) becomes (δ, γ1, γ2)-computable (Lemma 3.3.14 in [5]).
For definitions and mathematical properties of distributions see [1,2]. In [6] computability on distributions over the real line are studied. The definitions and theorems can be generalized straightforwardly to distributions over Rn (n	1). For the space of continuous functions f : Rn	C we use the representation [ρn	ρ2]:	Σω	 C(Rn). For the space C∞(Rn) of infinitely differentiable functions f : Rn	C we use the representation δ∞ :	Σω C∞(Rn) defined by
δ∞(⟨pα⟩α∈Nn )= f : ⇐⇒ (∀α ∈ N ) D f = [ρ → ρ ](pα)
ω
(where ⟨pα⟩α∈Nn ∈ Σ  is a canonical merging of the infinitely many infinite
sequences pα ∈ Σω, α ∈ Nn). The topology of C∞(Rn) can be defined by the semi-norms f → |Dmf |k = sup|α|≤m(supx∈K |Dαf (x)|), as m varies over the set of non-negative integers and K varies over the family of compact subsets of Rn.
A test function is a function f ∈ C∞(Rn) with compact support supp(f ) := cls{x ∈ Rn | f (x) /= 0}. The set of test functions is denoted by D(Rn) and its topology is induced by C∞(Rn). We use the representation δD : ⊆ Σω → D(Rn) defined by
δD(0k1p)= f : ⇐⇒ δ∞(p)= f and supp(f ) ⊆ [−k; k]n .
A Schwartz function is a function f ∈ C∞(Rn) such that supx∈Rn (|x|j |Dαf |) ≤
∞ for all j ∈ N and α ∈ N . The set of Schwartz functions is denoted by
S(Rn). We use the representation δS : ⊆Σω → S(Rn) defined by
δD(⟨p, q⟩)= f : ⇐⇒ δ∞(p)= f and q encodes a function h : Nn+1 → N
such that  (∀ j, α) supx∈Rn (|x|j |Dαf |) ≤ h(j, α).
Of course, the above representations can be replaced by equivalent ones. Ex- amples for the case n = 1 are discussed in [6].
A continuous linear map T : D(Rn) → C (T : S(Rn) → C) is called a distribution (tempered distribution), (where “continuous” means sequentially continuous w.r.t. the canonical convergence relations on D(Rn) and S(Rn), resp.). The set of all distributions (tempered distributions) is denoted as '(Rn) ( '(Rn)). For the set	'(Rn) we use the representation [δD	ρ2]
(restricted to the linear functions).


Remember that the evaluation function is computable, i.e., there is Type-2 Turing machine which computes a ρ2-name of T (φ) whenever given a [δD
ρ2]-name of T and a δD-name of φ as input.	Usually T (φ) is written as
<T, φ> .
We conclude this section with recalling some further definitions and facts [2]. The Dirac measure δ on Rn at 0 is a tempered distribution defined by δ(φ) = <δ, φ> = φ(0) for any Schwartz function φ  (Rn). The Dirac measure can be viewed as a point source. The Fourier transform of a Schwartz
function φ ∈ S(Rn), denoted as φˆ or F(φ), is defined as


(φ)(ξ)= φˆ(ξ) := (2π)−n/2
Rn
e−ixξφ(x)dx

where x = (x1, x2,... , xn), ξ = (ξ1, ξ2,... , ξn) and xξ = x1ξ1+x2ξ2+·· ·+xnξn. The Fourier transform is a linear bijection of S(R) to itself. For every partial derivative,
F(Djφ)= ξjF(φ) and DjF(φ)= F(−ξjφ)	(3) Therefore, for any partial differential operator P (D) with constant coefficients
<F(P (D)), φ>  = P (ξ)φˆ,	∀φ ∈ S(R).	(4)
D = −i∂.
Since S(R) is sequentially dense in S'(R), by a duality argument, F and Dj can be uniquely extended from S(R) to S'(R) defined by the following formulae:
<F T, φ> := <T, F φ> ,	(5)
<DjT, φ> := <T, −Djφ>	(6)

for any T	'(R) and φ	(R). The Fourier transform measure δ is a constant:
−n/2
δˆ of the Dirac

F(δ)= (2π)	.	(7)
Let R be the reflexion operator on S(Rn) defined by R(u)(x) := u(−x). Lemma 2.1 For any E ∈ D'(Rn) let ⟨E˜, φ> := <E, Rφ> . Then E is a fundamental solution of P (D), that is, P (D)E = δ, iff
<E˜, P (D)φ> = φ(0)	for all φ ∈ D(Rn) .
Proof By (6), <E, RDjφ> = <E, −DjRφ> = <DjE, Rφ> , and there- fore,
<E˜, P (D)φ> = <E, RP (D)φ> = <P (D)E, Rφ> .
We obtain P (D)E = δ, iff (∀φ) <P (D)E, Rφ> = Rφ(0) = φ(0), iff
(∀φ) <E˜, P (D)φ> = φ(0).	 

Computing a Fundamental Solution
Formally, the problem of constructing a fundamental solution of a partial differential operator P (D) is very easy. Indeed, suppose that we have
P (D)E = δ. 
Since F DjT = ξjF T (from (3), (5) and (6)), by taking the Fourier transform we obtain P (ξ)F E = (2π)	, hence
(2π)−n/2

F E =
,
P (ξ)

and E should be defined as the inverse Fourier transform of (2π)−n/2/P (ξ). This is meaningful if P (ξ) has no real zeros. In the general case, we will overcome the difficulty by selecting domains of integration which avoids the zeros of P (ξ).
For m ≥ 1 let P(m) be the linear space of all polynomials P (ξ) =
cαξα, cα ∈ C, in n variables of degree ≤ m, where ξα = ξα1 · ... · ξαn
for α = (α1,..., αn) and |α| = α1 + ... + αn. This space has dimension

a basis. On P(m) we consider the norm || Σ|α|≤m cαξα||m :=
Σ|α|≤m |cα|2.

Lemma 3.1 [3] From m a ﬁnite set Am = {νi | 1 ≤ i ≤ L(m, n)}⊆ Qn of vectors, L(m, n) := (m + 1)(n+1), can be computed such that for all P ∈ P(m), P /≡ 0,
(∃ ν ∈ Am)(∀z ∈ C, |z| = 1)P (zν) /= 0 .	(8)
Am can be chosen as follows: A =  k ν : ν  A',k = 0, 1,..., m , where A' =  ξ   Rn : ξi   0, 1, 2,..., m , 1  i   n . Observe that Am = (m + 1)(n+1) =: L(m, n).
Lemma 3.2 There is a Type-2 Turing machine which, for every polynomial
P ∈ P(m) of degree m > 0, computes a number l ∈ N such that

2−l < sup
ν∈Am
inf
|z|=1
|P (ξ + zν)|	for all	ξ ∈ R .	(9)



(|α| ≤ m) of a polynomial P (ξ) =
computes a number l such that (9).
Proof
|α|≤m cαξα of degree m the machine

By Lemma 3.1 there is some ν ∈ Am such that for all z ∈ C, P (zν) /= 0 if
|z| = 1. Since z '→ |P (zν)| is continuous,



0 < sup
ν∈Am
inf
|z|=1
|P (zν)| .	(10)

For every ν ∈ Am the function
(c˜, z) '→ |P (zν)|	is (ρ2N(m,n), ρ2, ρ)-computable
(c˜ := (cα)|α|≤m	CN(m,n)). By Theorem 3.3.15 in [5] on type conversion, the function
c˜ '→ (z '→ |P (zν)|)	is (ρ2N(m,n), [ρ2 → ρ])-computable.
Since z	C	z = 1 is a κ2-computable compact set (Def. 5.1.2 in [5]) the function

f	inf
|z|=1
f (z)	is ([ρ2, ρ], ρ)-computable

by Cor. 6.2.5 in [5]. Therefore, for each ν ∈ Am, the function

c˜	inf
|z|=1
|P (zν)|	is (ρ2N(m,n), ρ)-computable.	(11)

By Thm. 6.1.2 in [5], the function
c˜ '→ sup inf |P (zν)|	is (ρ	, ρ)-computable.	(12)

ν∈Am |z|=1

Since Bm := {c˜ |	|α|≤m |cα|2 = 1} is compact and c˜ '→ supν∈A
is continuous by (12), by (10)
inf|z|=1 |P (zν)|

inf	sup inf |P (zν)| > 0 .
||c˜||m=1 ν∈Am |z|=1
Since Bm is κ2N(m,n)-computable, by (12) and Cor. 6.2.5 in [5],
inf	sup inf |P (zν)| > 0	is ρ-computable.
||c˜||m=1 ν∈Am |z|=1
Since all the above computations are uniform in the degree m, a rational number Cm > 0 can be computed from m such that
Cm < sup inf |P (zν)|	if ||P ||m = 1 .	(13)
ν∈Am |z|=1
Now consider arbitrary polynomials P (ξ)=  |α|≤m cαξα of degree m. There is a Type-2 machine which on input m and the coefficients (cα)|α|≤m computes some rational number aP such that 0 < aP < |cβ| for some index β with

β = m.
For fixed ξ ∈ Rn, P (ξ + ξ')= Σ

cα(ξ + ξ')α =
Σ dα(ξ) ξ'α where the coeffi-

cients of the polynomials dα(ξ) can be determined by algebraic computation. By an easy observation, dβ(ξ) = cβ since |β| = m. Let Q(ξ') := P (ξ + ξ').



Then aP < |cβ|≤	|dα(ξ)|2 = ||Q||m. Since Q/||Q||m has norm 1, by (13),
Cm < supν∈Am inf|z|=1 |Q(zν)|/||Q||m, therefore


aP · Cm < ||Q||m · Cm ≤ sup
inf
|z|=1
Q(zν) = sup
ν∈Am
inf
|z|=1
|P (ξ + zν)| .

Finally some l ∈ N can be computed such that 2−l ≤ aP Cm.	 

In the following we denote, for any (ξ1,... , ξn) ∈ Rn, |(ξ1,..., ξn)| := supj ξj . X will denote the closure and X◦ will denote the interior of a set
X. For vectors in Rn let (xn,... , xn) < (yn,... , yn), iff xi < yi for all i. For
a, b ∈ Rn, a < b, let (a; b] be the semi-open interval (box) {x ∈ Rn | a < x ≤ b}. Let B1 := {(a; b] | a, b ∈ Qn and a < b} be the set of all semi-open rational intervals with canonical notation νB1. The set {I◦ | I ∈ B1} is a basis of the topology on Rn. Let B be the set of all finite unions of elements from B1 with standard notation νB. Notice that ∅∈ B and B is closed under union, intersection and difference (I, J) '→ I \ J and that every J ∈ B is a finite union of pairwise disjoint semi-open intervals from B1. Union and difference are (νB, νB, νB)-computable.
Integration of total continuous functions over intervals is computable [5]. We need a generalization to partial functions. In [4] such multirepresentations have been used for partial continuous functions on computable metric spaces. The following lemma generalizes Thm. 6.4.1 in [5]. It can be proved by using standard techniques.
Lemma 3.3  (i) The function f '→ ∫|z|=1 f (z) dz for continuous f : ⊆C → C
which is deﬁned if {z | |z| = 1}⊆dom(f ) is ([ρ2 →p ρ2], ρ2)-computable.
(ii) The function (f, I) '→ ∫I f (ξ) dξ for continuous f : ⊆R → C and I ∈B 
n
which is deﬁned if I⊆dom(f ), is ([ρn →p ρ2], νB, ρ2)-computable.
Since the boundary of every I ∈ B has measure 0, for every continuous function f ,
f (ξ) dξ =	f (ξ) dξ =	f (ξ) dξ ,
I	I	I◦

if I⊆dom(f ). After these preparations we can prove our main theorem.

Theorem 3.4 There is a Type-2 Turing machine which for every differential operator P (D) =	|α|≤m cαDα /≡ 0 computes a fundamental solution E ∈
D (Rn). More precisely, from m and ρ2-names of the cα ∈ C (|α| ≤ m) it
computes a [δD → ρ2]-name of a fundamental solution E.


Proof
First, we assume that the degree m of the polynomial P (ξ)=  |α|≤m cαξα is fixed. Let c˜ := (cα)|α|≤m ∈ CN(m,n) be the vector of coefficients of P (ξ). Let Am = {νi | 1 ≤ i ≤ L(m, n)} be any set satisfying Lemma 3.1. Let l ∈ N be some constant such that (9). For 1 ≤ j ≤ L(m, n) Define

Ωj := ξ	Rn  2−l < inf
|z|=1
|P (ξ + zνj)|} .	(14)

Let M−1 := M0 := ∅∈ У and Mk := ((—k,..., —k); (k,..., k)] ∈У for k ≥ 1. For k, j ∈ N, 1 ≤ j ≤ L(m, n), let T k ∈У be sets such that
Tk⊆Ωj, Tk ∩ Tk = ∅ for i /= j and   Tk = Mk \ Mk−1 .	(15)
j	i	j	j
j
Since for each k the Tk (1 ≤ j ≤ L(m, n)) are a partition of Mk \ Mk−1 and
'
the M \ M	are partition of Rn, Tk ∩ Tk = ∅ if k /= k' or j /= j'. Define


Tj :=  k
k−1
Tk. Then
j	j'

Tj⊆Ωj, Ti ∩ Tj = ∅ for i /= j and	Tj = Rn .	(16)
j
For any u ∈ Ð(Rn) and k ∈ N define


E˜k (u) := (2π)−n/2
LΣ(m,n) ∫
dξ  1  ∫
 uˆ(ξ + zνj) 1

dz	(17)


and
k
j=1	j


LΣ(m,n) ∫
2πi


 1  ∫
|z|=1 P (ξ + zνj) z


 uˆ(ξ + zν ) 1

E˜(u) := (2π)−n/2

j=1
dξ
Tj	2πi
j
|z|=1 P (ξ + zνj) z
dz .	(18)

If P (ξ + zνj) becomes 0 in the domain of integration, the integrals possibly do not exist. By (14), however, for any j, any ξ ∈ Ωj and for |z| = 1,

  uˆ(ξ + zνj) 1 ≤  |uˆ(ξ + zνj)| 1
≤	2 · |uˆ(ξ + zν )| .	(19)

The integrals exist, since z = 1 is considered and the function uˆ  (Rn) is rapidly decaying.
Define E by <E, φ> := <E˜, Yφ> for all φ ∈ Ð(Rn). Then <E˜, φ> =
<E˜, Y2φ>  =  <E, Yφ>  for all φ ∈ Ð(Rn).  We show in the following
that E is a fundamental solution of P (D). By Lemma 2.1, E is a fundamental solution of P (D) iff E˜(P (D)v)= v(0) for any v ∈ Ð(Rn). For any u = P (D)v, v ∈ Ð(R),



E˜(u)= E˜(P (D)v)
L(m,n)
= (2π)−n/2

dξ  1  ∫


F(P (D)v)(ξ + zνj) 1 dz

j=1	Tj
2πi
|z|=1
P (ξ + zνj)	z

LΣ(m,n) ∫
 1  ∫
P (ξ + zν )vˆ(ξ + zν ) 1

= (2π)−n/2

j=1
dξ
Tj	2πi

|z|=1
j
P (ξ + zνj)
j	dz
z


= (2π)−n/2
LΣ(m,n) ∫
dξ  1  ∫
1
vˆ(ξ + zνj)

dz .


We observe that
j=1	Tj
2πi
|z|=1	z

 1  ∫
1
vˆ(ξ + zν ) dz

2πi
=  1 
2πi
|z|=1


|z|=1
j z

(2π)−n/2
Rn

e−ix(ξ+zνj )v(x)dx1 dz
z

= (2π)

−n/2
Rn

e−ixξ
v(x)dx
 1  2πi



|z|=1
e−ixzνj
dz
z

= (2π)−n/2
Rn
e−ixξv(x)e−ix0νj dx	(Cauchy integral)

= (2π)−n/2
R
= vˆ(ξ) .
Thus we obtain
e−ixξv(x)dx



LΣ(m,n) ∫

E˜(P (D)v)= (2π)−n/2

j=1
vˆ(ξ)dξ
Tj

= (2π)−n/2
Rn
= (2π)−n/2
Rn
vˆ(ξ)dξ

ei0ξvˆ(ξ)dξ

= v(0) .

Next we determine an upper bound of |E˜k (u)|. Since uˆ ∈ £(Rn),
(∃ k ∈ N)	(|uˆ(ξ)| |ξ|	≤ 1 if |ξ|≥ k ) .	(20) Define ν¯ := maxν∈Am |ν|.
Let k ≥ k +ν¯+1 and k ≥ 2ν¯+2. Then for ξ ∈ R , z ∈ C and 1 ≤ j ≤ L(m, n),
'
|ξ + zνj|≥ |ξ|— ν¯ ≥ k	if |ξ|≥ k — 1 and |z| = 1 .	(21)



We obtain
|E˜k(u)|≤ (2π)−n/2


L(m,n)	 1
dξ
T k	2π

 |uˆ(ξ + zνj)| 1
|z|=1 |P (ξ + zνj)| |z|


|dz|


≤ 2 (2π)

−n/2
L(m,n)	 1
dξ
T k	2π



|z|=1

|uˆ(ξ + zνj)||dz| (by (14), (15))

j=1	j
LΣ(m,n) ∫
 1 ∫

|uˆ(ξ + zν )|· |ξ + zν |n+2

≤ 2 (2π)
−n/2

j=1
dξ
k	2π
j

|z|=1
j
|ξ + zνj|
n+2	|dz|


≤ 2 (2π)

−n/2
LΣ(m,n) ∫
dξ  1 ∫
	1	
n+2 |dz|

j=1
k	2π
j
|z|=1 |ξ + zνj |

(by (20)and (21), since |ξ|≥ k — 1 for ξ ∈ T k)

≤ 2 (2π)

−n/2
LΣ(m,n) ∫
dξ  1 ∫
	1	
n+2 |dz|

j=1
k	2π
j
|z|=1 (k — 1 — ν¯)

≤ 2 (2π)

−n/2
L(m,n)

T k
	1	
dξ
(k — 1 — ν¯)n+2

≤ 2 (2π)
−n/2	(2k)n
(k — 1 — ν¯)n+2	(by (15))

≤ 2 · (2π)
−n/2
22n+2 1	(since k	2ν¯ + 2)
k2

Since Σ
 1 	 1

we obtain for all K ≥ k' + 2ν¯ + 2,

Σ |E˜ (u)| ≤ 2l+2n+2 · (2π)−n/2  1 ,
k	K
k=K+1
and by (15) - (18),
∞

E˜(u) =
E˜k (u)	(22)
k=0

and for all K ≥ k' + 2ν¯ + 2,
|E˜(u) — Σ E˜ (u)| ≤ 2l+2n+2 · (2π)−n/2  1

.	(23)

k	K
k=0
It remains to prove that the fundamental solution E can be computed from the polynomial P . Concretely, a polynomial P of degree m is given by the list


c˜ = (cα)|α|≤m, cα  C, of its coefficients represented by ρ2N(m,n). Let Am be a set of vectors according to Lemma 3.1.
By Lemma 3.2, the multifunction c˜|⇒ l such that (9) is (ρ2N(m,n), νN)- computable.
Next we compute the sets Ωj defined in (14). For each number j the func- tion (l, c˜, ξ) inf|z|=1 P (ξ+zνj) 2−l is (νN, ρ2N(m,n), ρn, ρ)-computable. The proof is essentially that of (11). By Thm. 3.3.12 in [5] on type con- version, for each j the function


(l, c˜)	(ξ	inf
|z|=1
|P (ξ + zνj)|— 2 )

is (νN, ρ2N(m,n), [ρn → ρ])-computable. For the open subsets of Rn we use the representation θ< defined by θ<(p) = U , iff p ∈ Σω is (encodes) a list of all I ∈ У1 such that I⊆U (Def. 5.1.15 in [5]). Notice that
Thm. 6.2.4.1 in [5] for each j the function
(l, c˜) '→ Ωj is (νN, ρ2N(m,n), θ<)-computable.
We describe how to compute sets T k from sequences pj ∈ Σω such that θ<(pj) = Ωj. Consider k ∈ N. Simultaneously for all j = 1,... , L(m, n) produce the lists of intervals I ∈ У1 encoded by the  pj. Halt as soon asa finite set of intervals C⊆У1 has been found such that Mk \ Mk−1⊆	I∈C I (finite covering of a compact set). For each j let Cj⊆C be the set of
intervals from C so far listed by pj. Let Tk := ∅ and determine the
Tk⊆У successively by the rule
Tk := (   I ∩ (Mk \ Mk−1)) \   Tk .

j
I∈Cj
j'
j'<j

If (9) holds for the number l, then j Ωj = Rn, a set C will be found by compactness of Mk \ Mk−1, and (15) and (16) are true. As a summary, we have a multifunction
(l, c˜) |⇒ ((k, j) '→ Tk) which is (νN, ρ2N(m,n), [ν2 → νB])-computable.
Next we prove that (c˜, k, u, ((k, j) '→ T k)) '→ E˜k (u) defined in (17) is (ρ2N(m,n), νN, δD, [ν2 → νB], ρ2)-computable.
First let j be fixed. Since the identity from Ð(Rn) to £(Rn) is (δD, δS)- computable, the Fourier transform is (δS, δS)-computable and the identity

from £(Rn) to C(Rn) is (δS, [ρn → ρ2])-computable, the function


 uˆ(ξ + zνj) 1 (u, c˜, ξ, z) '→ P (ξ + zν ) z
is (δD
, ρ2N(m,n), ρn, ρ2, ρ2)-computable .



Therefore by type conversion,
 uˆ(ξ + zνj) 1
(u, c˜, ξ) '→ (z '→	) is (δ



, ρ2N (m,n) , ρn, [ρ2 →


ρ2])-computable .

P (ξ + zνj) z
By Lemma 3.3 the function


(u, c˜, ξ)
|z|=1
 uˆ(ξ + zνj) 1
dz	is (δD
P (ξ + zνj) z
, ρ2N(m,n), ρn, ρ2)-computable .

Again after type conversion by Lemma 3.3, the function

(I, u, c˜) '→ ∫
dξ ∫
 uˆ(ξ + zνj) 1
dz is (ν

,δ  , ρ2N(m,n), ρ2)-computable .

I	|z|=1
P (ξ + zνj) z

Finally, since π is computable, we can conclude that
(c˜, k, u, ((k, j) '→ Tk)) '→ E˜k (u)
is (ρ2N(m,n), νN, δD, [ν2 → νB], ρ )-computable. By Thm. 3.1.7 in [5] on
primitive recursion the function
(c˜, K, u, ((k, j) '→ Tk)) '→ Σ E˜k(u)
k=0

is (ρ2N(m,n), νN, δD, [ν2 → νB], ρ2)-computable.

As above, from u ∈ Ð(Rn), uˆ ∈ £(Rn) can be computed. By the defini- tion of δS,a number k' can be computed from uˆ such that |v(ξ)||ξ|n+2 ≤ 1 if |ξ| ≥ k'. From l, k' and L ∈ N, a number K can be computed such that K ≥ k' + 2ν¯ +2 and K ≥ 2l+2n+2 · (2π)−n/2 · 2L+1. Then by (23),
K
|E˜(u) —	E˜k(u)| ≤ 2−L−1 .
k=0
By (d) above, from c˜, K, u, ((k, j) '→ T k) and L a rational bL ∈ C can be

computed such that

K
|bL —	E˜k (u)| ≤ 2−L−1 .
k=0
From the sequence b0, b1,... we can compute a ρ2-name of E˜(u). There- fore, after type conversion, the function
(c˜, l, ((k, j) '→ Tk)) '→ (u '→ E˜(u))
is (ρ2N(m,n), νN, [ν2 → νB], [δD → ρ2])-computable.
From (a), (c) and (e), the multifunction c˜|⇒ E˜ is (ρ2N(m,n), [δD → ρ2])-com- putable. Since <E, u> = <E˜, Yu> = <YE˜, u> and Y is computable on Ð'(Rn) by Lemma 4.7 in [6], the operator u |⇒ E mapping a polynomial of degree m to some fundamental solution is (ρ2N(m,n), [δD → ρ2])-computable.
So far we have assumed a fixed degree m of the polynomial. Since the set Am can be computed from m (Lemma 3.1) and all the other computations are uniform also in m the proof is finished.	 

In the proof multivalued functions occur several times. A critical part is the computation of the sets T k which determines a partition of Rn into (at most) L(m, n) sets. The resulting distribution depends essentially on this partition. However, the function from CN(m,n) to these sets cannot be com- putable (hence continuous) and single-valued at the same time, provided it is not trivial (Lemma 4.3.15 in [5]).
Problem: Is there a single-valued computable function mapping any polyno- mial of degree m to a fundamental solution?
As usual in recursion theory, we have not merely proved the existence of a computable function (from names of input objects to names of output objects) but the proof is constructive, i.e. it explains how a concrete Turing machine or computer program can be constructed for computing this function. Of course the algorithm is not trivial since subroutines for integration, for Fourier transform on Schwartz space etc. have to be included. The presented algorithms can be improved, since, e.g., no derivatives of the Fourier transform
uˆ of the input test function u ∈ £(Rn) are needed for computing the E˜k (u)
by integration.
Problem: Can our informal algorithm be converted to a feasible numerical algorithm for computing fundamental solutions efficiently or is the problem

inherently difficult?


References
Jos´e Barros-Neto. An introduction to the theory of distributions, volume 14 of Pure and Applied Mathematics. Marcel Dekker Inc., New York, 1973.
Jeffrey Rauch. Partial differential equations, volume 128 of Graduate Texts in Mathematics. Springer, New York, 2nd edition, 1997.
Fran¸cois Treves. Linear Partial Differential Equations with Constant Coefficients. Gordon and Breach Science Publishers, New York, 1966.
Klaus Weihrauch. Computability on computable metric spaces. Theoretical Computer Science, 113:191–210, 1993. Fundamental Study.
Klaus Weihrauch. Computable Analysis. Springer, Berlin, 2000.
Ning Zhong and Klaus Weihrauch. Computability theory of generalized functions. Journal of the Association for Computing Machinery, 50(4):469–505, 2003.
