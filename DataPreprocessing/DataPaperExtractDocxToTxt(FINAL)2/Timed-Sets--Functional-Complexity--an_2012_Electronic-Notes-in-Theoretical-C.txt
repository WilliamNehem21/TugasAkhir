Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 286 (2012) 117–137
www.elsevier.com/locate/entcs

Timed Sets, Functional Complexity, and Computability
Robin Cockett a,1,5 Joaqu´ın D´ıaz-Bo¨ıls b,4,6
Jonathan Gallaghera,3,7 Pavel Hrubeˇs a,2,8
a Department of Computer Science University of Calgary
Calgary, Canada
b Departamento de L´ogica y Filosoph´ıa Universidad de Valencia
Valencia, Spain

Abstract
The construction of various categories of “timed sets” is described in which the timing of maps is considered modulo a “complexity order”. The properties of these categories are developed: under appropriate condi- tions they form discrete, distributive restriction categories with an iteration. They provide a categorical basis for modeling functional complexity classes and allow the development of computability within these settings. Indeed, by considering “program objects” and the functions they compute, one can obtain models of computability – i.e. Turing categories – in which the total maps belong to specific complexity classes. Two examples of this are introduced in some detail which respectively have their total maps corresponding to PTIME and LOGSPACE.
Keywords: Restriction categories, complexity measures, functional complexity, computability, Turing categories


Introduction
The goal of this paper is to provide a general construction of categories of “timed sets” which may be used as a categorical basis for modeling functional complexity

1 Supported by NSERC
2 Supported by PIMS
3 Supported by the University of Calgary
4 Universidad de Valencia
5 Email: robin@ucalgary.ca
6 Email: ximo104@hotmail.com
7 Email: jdgallag@ucalgary.ca
8 Email: pahrubes@gmail.com

1571-0661 © 2012 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2012.08.009

classes. A motivating example concerns the modeling of polynomially timed func- tions: this example is of additional interest as it is possible to show one obtains a full model of computability – a Turing category [2,10] – in which the total func- tions are precisely the PTIME functions in the usual complexity sense. One may therefore identify the computability theory of this Turing category with the theory of PTIME complexity.
To achieve such a modeling, a number of ingredients must be collected. The first and simplest ingredient is a notion of “timing”: here we take a very basic approach supposing that a (partial) map between sets is timed if for every input (on which the map defined) there is a measurement of the “running time” of the function on that input. Of course, “time” here could be replaced by any resource which one might wish to measure. Indeed, at the end of the paper we include a discussion using space as a resource in order to obtain a Turing category whose total functions belong to LOGSPACE.
Formally, the measurement of the resources used by a partial function, f , when applied to an element, x, in its domain, is given by associating to that element a value in a size monoid. The canonical example of a size monoid is, of course, the natural numbers, N , under addition. Thus, for measuring time complexity, we associate to each x in the domain of f , a time |x|f ∈ N . If one had wished to measure space, a natural size monoid might be the natural numbers under maximum as the space usage of the composite of two functions is often 9 the maximum of the individual space usages.
Sets with “timed maps” in this sense certainly form a category in which two timed maps are considered to be equal if and only if they have exactly the same timing. Typically, however, in complexity theory one wants to regard maps whose timings are “similar” to be equal. So for example, if the functions have timings which asymptotically differ only by a linear factor (e.g. as in “big O” notation), one may want to regard them, from a complexity standpoint, to be equivalent. To capture this idea, which is fundamental to complexity theory, it is clear that one must pass to a quotient of the basic category of timed sets. However, there is a technical problem: one must describe precisely when two timed maps should be equivalent.
Unfortunately, one cannot simply use asymptotic behavior (e.g. “big O” no- tation) as, a priori , it is only defined for maps from the natural numbers to the real numbers. The timing functions in which we are interested have domain an arbitrary set and codomain an arbitrary size monoid. Thus, some other mechanism must be sought: we introduce here the notion of a complexity order to serve this purpose. A complexity order is a set of monotone endomorphisms of a size monoid, C ⊆ Mon(M, M ) satisfying certain properties. Given a complexity order, C one can preorder timed maps: one map, f , being of better C-complexity than another, g, if it is defined whenever the latter is, and its cost is bounded by the latter’s cost modified by a map from the order C, that is |x|f ≤ F (|x|g) for all x in the domain

9 For LOGSPACE it turns out (see later) that the appropriate size monoid is actually the natural numbers under addition: however, for example for PSPACE it does seem that maximum is more appropriate.

of g and for some F ∈ C. The maps equivalent under this preorder are then taken as being equal.
Of course, for this to make good sense, C must satisfy some basic properties: it must certainly be closed to composition, but also, more technically, it must be “laxly additive.” A canonical example of a complexity order is generated by the polynomial maps, P ⊆ Mon(N , N ), on the natural numbers. Another important example, closely related to “big O” notation, is generated by the linear maps, L⊆ Mon(N , N ). After the maps are quotiented by this C-equivalence, a category of timed sets is obtained whose maps are partially ordered by their C-complexity. If the complexity order, C, is closed to addition – which certainly implies that C is laxly additive – something quite striking happens: the resulting category of timed sets naturally has the structure of a restriction category. Restriction categories are important as they provide a completely algebraic way of expressing partiality. The completeness the- orem for restriction categories asserts that every restriction category is canonically a full subcategory of a partial map category: the canonical partial map category is
actually formed by splitting the restriction idempotents.
In complexity theory, one always considers the running time of a function in terms of the size of its input. Yet, in the development so far, no mention of input size has been made. The effect of splitting the restriction idempotents elegantly corrects this defect. When one considers a timed map whose starting point is an idempotent the timing of that idempotent can be viewed as providing the “size” of its input. One can view the restriction idempotents as giving the cost of “reproducing” or “reading” the input both of which are, intuitively, measures of its size. In fact, these idempotents can provide a surprisingly sophisticated interpretation of size as witnessed by their use in modeling space complexity.
Splitting the idempotents has another remarkable effect. The total maps of this split category become exactly the maps whose complexity belongs to the complexity order, C. Thus, for example, if C = P, then one obtains, as the total maps of the split category, exactly the polynomially timed maps.
This is striking: it is not at all obvious that there should be any relationship between complexity, given in this very concrete manner, and partiality. Yet, in a very straightforward way, one can exhibit a direct relationship. Of course, the polynomially timed maps, obtained in this manner, are by no means the PTIME maps as understood by complexity theorists. The category of timed sets allows all possible timings for all partial maps given between sets whether they are realizable by machine or not. To obtain the classical PTIME maps we need to link these ideas up with computability: for to be a PTIME map, one must also be able to realize the map by a computation on a machine.
This introduces a further technical problem: one must explain what a reasonable notion of computation is in timed sets. One approach to this is to view a computable map as one obtained by iterating a basic (total) machine step. For this approach to work requires that one can produce a well-defined notion of iteration – that is a trace on the coproduct – for categories of timed sets. To achieve this requires that the complexity order, C, which determines the notion of equivalence, satisfies

an additional requirement: namely, that the order is generated by maps which are “lax” with respect to addition. When this is the case there is a canonical notion of iteration which allows one to talk about iterating the state change of a machine (such as a Turing machine) which, in turn, allows one to “time” computations in a natural way.
In this manner one can obtain a categorical model of computability – in the sense of being a Turing category [2,10] – whose total maps are precisely the PTIME maps as standardly understood by complexity theorists. In particular, this suggests that one can identify the computability theory of this Turing category with the theory of PTIME complexity.
These results are explained in the last section: the development relies on a number of standard results from complexity theory and on a basic understanding of Turing categories. A similar technique allows one to obtain models of Turing categories of other low complexity classes such as ELEMENTARY, PRIM (prim- itive recursive). These techniques can also be applied when space is taken as the resource: to illustrate this we briefly discuss LOGSPACE computations which also organize themselves into a Turing category. Finally, we illustrate the possibility of interpreting complexity hierarchy problems as questions about functors between these Turing categories.



Timed Maps
A size monoid, M = (U (M ), +, 0, ≤) is an ordered commutative monoid (thus (U (M ), +, 0) is a commutative monoid, where U (M ) is the underlying set of M and
≤ a partial order on U (M )) such that
0 ≤ m for all m ∈ M ;
if a ≤ aj and b ≤ bj then a + b ≤ aj + bj.
A basic example of a size monoid is the natural numbers under addition. Of course, the natural numbers also form a size monoid under maximum and multipli- cation. In general, given any commutative monoid M we may place a preorder on it by setting x ≤ y if and only ∃a.x + a = y. The equivalence relation determined by x ∼ y ⇔ x ≤ y&y ≤ x is then a congruence on the monoid: the quotient by this congruence is the universal size monoid associated with that commutative monoid. Formally this gives a left adjoint to the underlying functor, SzMon → CMon, from size monoids to commutative monoids. Notice that under this adjunction the univer- sal size monoid associated to a commutative group is always trivial: so size monoids are, in this sense, orthogonal to groups. In addition, this is a Galois adjunction: the category of size monoids such that x ≤ y ⇔ ∃a.x + a = y (one may think of these as “positive cones”) forms a coreflective subcategory of sized monoids and a reflective subcategory of commutative monoids.

Given a size monoid M we can form a category TSet(M ) 10 , the category of
M -timed sets:
Objects: Sets;
Maps: A timed map f : X → Y is a pair f = (U (f ), | |f ) where U (f ): X → Y is a partial function and | |f : X → M is the timing or cost of the map which is defined precisely when U (f ) is defined.
Composition: Given timed maps f : X → Y and g : Y → Z the composite fg 
has U (fg)= U (f )U (g) and |x|fg = |x|f + |f (x)|g;
Identities: The timed identity 1X : X → X has U (1X)= 1X and |x|1X =0 for all
x ∈ X.
This is clearly a category whose maps have attached timings in the size monoid
M . Two maps in this category are equal only if they have precisely the same timings. Our objective is to now relax this latter constraint: to do this we introduce the notion of a complexity order. A complexity order for a size monoid, M , is given by a class C of monotone endomorphisms (i.e., satisfying P (x) ≤ P (y) whenever x ≤ y), C ⊆ Mon(M, M ), such that:
C is down closed: if P ∈C and Q ∈ Mon(M, M ) with Q(m) ≤ P (m) for every
m ∈ M then Q ∈ C.
C is closed to composition: the identity map, I(x)= x is in C and, if P, Q ∈C then PQ ∈ C (where P Q(x) = Q(P (x)) – as we are writing composition in diagrammatic order rather than applicative order).
C is laxly additive: if P1, P2 ∈ C then there is a Q ∈ C such that for all x and
y, P1(x)+ P2(y) ≤ Q(x + y).
We shall say a complexity order C is additive in case we replace the last axiom by the requirement that whenever P, Q ∈C then P + Q ∈ C. Clearly, being additive implies being laxly additive as P1(x)+P2(y) ≤ P1(x+y)+P2(x+y)= (P1+P2)(x+y), so with this modification, it is still a complexity order. It is not hard to see, conversely, that a laxly additive order is additive if and only if it contains I + I.
Given a complexity order C and two M -timed partial maps maps f, g : X → Y we shall say f has better C-complexity than g, denoted f ≤C g, in case as partial maps U (f ) ≥ U (g) (that is whenever U (g) is defined U (f ) is defined and equal to U (g)) and there is a F ∈C such that for all x for which g is defined |x|f ≤ F (|x|g). 11 Intuitively, one should think that a map f has better complexity than g, when it is not only as least as defined as g, but also its timing is no worse than g’s (up to a C increment). We say f =C g, that is f and g have the same C-complexity if f ≤C g and f ≥C g. This means that U (f )= U (g) and there are P, Q ∈C such that
|x|f ≤ P (|x|g) and |x|g ≤ Q(|x|f ).

10 There is a monad involved in this construction for which TSet(M) is the Kleisli category. Using a monad to model timing was described by Doug Gurr in his PhD thesis [7].
11 It would be more in the spirit of the asymptotic definition of order to require |x|f ≤ P (|x|g) holds almost everywhere – that is it holds for all but a finite set of x. While the development certainly works with this definition, as we shall see, most complexity orders already accommodate finitely many exceptions thus the gain of this complication is limited.

A complexity order C is said to be generated by a subset S of its maps, denoted C = ⟨S⟩, when every map in the order is dominated by one in the subset. Here are some examples of complexity orders:
The smallest complexity order for any size monoid M is generated by the identity map. In this case f ≤C g if and only if f is more defined than g and
|x|f ≤ |x|g whenever g(x) is defined.
Given any size monoid M there is always the constant complexity order gen- erated by translations:
KM = ⟨Km|Km = λx.x + m, m ∈ M⟩.
Here f ≤KM g if and only if f is more defined than g and there is an m ∈ M
such that for all x ∈ X with g(x) defined, |x|f ≤ |x|g + m.
Given any size monoid M there is always the linear complexity order:
LM = ⟨λx.n · x|n · x = x + ... + x,n ∈ N ⟩.
 
n times
When M = N , note that f ≤L g implies that, using “big O” notation, f ∈ O(g).
When M = N (or M = R ≥0) then we may consider the orders:
n	n
P = ⟨λx. Σ aixi|ai,n ∈ N ⟩	P∗ = ⟨λx. Σ aixi|ai,n ∈ N ⟩.
i=0	i=1
These are the polynomial complexity orders. Note that the second does not include the constant functions. If M = N , the sums are not nec- essary as they are dominated by the largest power. Hence, for example, P∗ = λx.axi|a, i ∈ N ,i > 0 .
We start by observing:
Lemma 2.1 Given any complexity order, C, on a size monoid M:
Each homset of TSet(M )(X, Y ) is preordered by f ≤C g;
If f ≤C g and h ≤C k in TSet(M ) then , fh ≤C gk (i.e. this is a preorder enrichment for TSet(M ));
(iii)	=C	is a congruence on TSet(M ).
Proof.
It is immediate that f ≤C f the only difficulty is to show transitivity. So suppose f ≤C g ≤C h then for P, Q ∈ C we have |x|f ≤ P (|x|g) and |x|g ≤ Q(|x|h) but this means |x|f ≤ P (|x|g) ≤ P (Q(|x|h)) as P is monotone. But QP ∈C so we are done.
Suppose |x|f ≤ P1(|x|g) and |y|h ≤ P2(|y|k) whenever they are defined. Then,

as C is laxly additive there is a Q ∈C with P1(x)+ P2(y) ≤ Q(x + y) and we have:
|x|fh = |x|f + |f (x)|h
≤ P1(|x|g)+ P2(|f (x)|k)
≤ Q(|x|g + |f (x)|k)
= Q(|x|gk).
(iii)		=C	is a congruence on TSet(M ) as this is so for the equivalences in any preorder enriched category.
2
This means that we can pass to the category TSet(M )/C where partial map equality is determined by f =C g. Thus, in TSet(N )/K two timed maps will be counted as being equal if they are equal as partial maps and their timings differ by at most a constant. Similarly, in TSet(N )/L two maps are counted to be equal if their timings are linearly comparable.
Timed Sets and Partial Map Categories
In this section we consider TSet(M )/C, where C is an additive complexity order. Some of the orders mentioned above are not additive: in particular, neither the order generated by the identity map, nor the order KM generated by translations, is additive. On the other hand, the linear and polynomial orders, L, P and P∗, are additive.
The purpose of this section is to establish:
Proposition 3.1 When C is additive then TSet(M )/C is a discrete distributive restriction category with the restriction given by:
f : X → Y
f = (U (f ), | |f ): X → X
A distributive restriction category is a Cartesian restriction category – that is it has finite products in an appropriate partial sense (explained below) – with coproducts over which these products distribute (see [4]). It is discrete in case all diagonal maps Δ : A → A × A have partial inverses 12 Δ(−1).
The significance of Proposition 3.1 lies in the fact that restriction categories are abstract categories of partial maps. In particular, every restriction category is a full subcategory of a (real) partial map category (see [3,11]). Furthermore, the canonical partial map category, of which it is a full subcategory, is obtained by splitting the “restriction” idempotents to obtain a larger restriction category. From this one can extract the subcategory of total maps which can be used to form the partial map category in which the original restriction category sits (see [3]).

12 A map f : A → B in a restriction category has a partial inverse if there is a map f(−1) : B → A with
ff(−1) = f and f(−1)f = f(−1): partial inverses are unique.

In section 5 we carry out these formal steps for TSet(M )/C. While abstractly these steps are quite routine, their realization in this case is quite striking. As we shall see, this allows the construction of a restriction category whose total maps are precisely those with timings bounded by the complexity order C. This provides a direct link between complexity and partiality.
A restriction category is a category with a restriction combinator which, to any map, assigns an endomorphism of its domain:
f : A → B f : A → A
This must satisfy just four identities:
[R.1] ff = f	[R.2] f g = g f
[R.3] f g = g f	[R.4] f g = fg f

As f f = f f = f , the restriction of a map is always an idempotent, called a restriction idempotent, which should be thought of as a partial identity. In a restriction category a map f : A → B is said to be total in case f = 1A: the total maps always form a subcategory.
The proof of proposition 3.1 can be broken into parts: proving that it is a restriction category, that it is Cartesian, distributive, and discrete. The verification that it is a restriction category is straightforward: we shall prove [R.1] and [R.4] as these show why the additive assumption is needed:
[R.1] We know already that the behavior at the level of partial maps is correct: the problem is to provide a bounding function from C for ff in terms of f . We have
|x|ff = |x|f + |x|f = |x|f + |x|f ≤ (I + I)(|x|f )
where we use the additivity to produce the bound.

[R.4] Again it is obtaining the bound for fgf in terms of that of fg which is the only difficulty. We have:
|x|fgf = |x|fg + |x|f = |x|fg + |x|f =2 · |x|f + |f (x)|g
≤ 2 · (|x|f + |f (x)|g)= (I + I)(|x|f + |f (x)|g) Clearly, again, we have to use the fact that C is additive.
Thus, TSet(M )/C is a restriction category. A restriction category is Cartesian when it has a restriction terminal object and restriction (binary) products. A restriction terminal object is an object 1 with, for each object A, a unique total map !A : A → 1 such that any map f : A → 1 has f = f !A.
In TSet(M )/C the terminal object is the one element set 1 = {()} and !A is determined by setting U (!A)(a)= () for every a ∈ A and |a|!A = 0. One then has, given an f : A → 1, that whenever f is defined on a that |a|f!A = |a|f + |a|!A = |a|f . An object, A×B, with two total projections, π0 : A×B → A and π1 : A×B → B,
is a restriction product in case for any pair of maps f : X → A and g : X → B



there isa unique map ⟨f, g⟩ : X → A×B such that ⟨f, g⟩ π0 = gf and ⟨f, g⟩ π1 = fg. In TSet(M )/C, the restriction product A×B is the Cartesian product of the sets, where πi, i = 0 or 1, has U (πi) the appropriate projection in sets, and |(x, y)|πi = 0. We set U (⟨f, g⟩) to be the pairing map, which, on x ∈ X, is only defined when both f and g are defined, and set |x|⟨f,g⟩ = |x|f + |x|g. To show that this is well- defined, that is that if f =C fj and g =C gj that ⟨f, g⟩ =C ⟨fj, gj⟩, it suffices to show that if f ≤C fj and g ≤C gj then ⟨f, g⟩ ≤C ⟨fj, gj⟩. So suppose P1, P2 ∈ C with
|x|f ≤ P1(|x|f′ ) and |x|g ≤ P2(|x|g′ ) then
|x|⟨f,g⟩ = |x|f + |x|g ≤ P1(|x|f′ )+ P2(|x|g′ ) ≤ Q(|x|f′ + |x|g′ ) ,
where we are using the fact that C is laxly additive.
To verify that ⟨f, g⟩ π0 = gf , first recall that this is so for the underlying partial maps between sets, so we need only check the bounds. However, for this we have:
|x|⟨f,g⟩π0 = |x|⟨f,g⟩ + |(f (x), g(x))|π0 = |x|⟨f,g⟩ = |x|f + |x|g = |x|g + |x|f = |x|gf .
To establish uniqueness, suppose h : X → A × B satisfies these conditions, then certainly U (h)= U (⟨f, g⟩); so that it remains to show that there are P, Q ∈C with
|x|⟨f,g⟩ ≤ P (|x|h) and |x|h ≤ Q(|x|⟨f,g⟩). We have hπ0 = gf so we have a P and Q
such that |x|hπ0 ≤ P (|x|gf ) and |x|gf ≤ Q(|x|hπ0 ). Now observe |x|gf = |x|f + |x|g =
|x|⟨f,g⟩ and |x|hπ0 = |x|h + |h(x)|π0 = |x|h, so that these bounds suffice.
We have now established that TSet(M )/C is a Cartesian restriction category.
Given this structure, the diagonal map Δ = ⟨1A, 1A⟩ : A → A × A is clearly a zero cost map and so has a zero cost partial inverse whose domain of definition is exactly the diagonal elements and which has Δ(—1)(x, x)= x.
Finally, we must show that TSet(M )/C has coproducts: the empty set is clearly the initial object. The binary coproduct A + B is just the disjoint union of the sets: the injections σ0 and σ1 are the inclusion maps in sets with a zero timing. The copairing map for f : A → X and g : B → X is the map ⟨f|g⟩ : A + B → X, where U (⟨f|g⟩) is the usual copairing for sets and partial functions (U (⟨f|g⟩)(a) = f (a) for a ∈ A and U ⟨f|g⟩ (b)= g(b) for b ∈ B) with timing |a|⟨f|g⟩ = |a|f for a ∈ A and
|b|⟨f|g⟩ = |b|g for b ∈ B. As before we must show this is well-defined: this requires finding a bounding function which works for both components 13 – and the sum of the bounding functions of the individual components will clearly work. It is now routine to show one has a coproduct. Furthermore, as the canonical map
⟨1A × σ0|1A × σ1⟩ : A × B + A × C → A × (B + A)
has zero cost and is an isomorphism in sets, it follows easily that TSet(M )/C is distributive.
This completes the proof of proposition 3.1.

13 In order to make the product and coproduct well-defined, a simultaneous bound for all the components is required. While for finite products and coproducts this is simply given by adding the individual bounds, this technique does not work for infinite products or coproducts and, indeed, TSet(M)/C does not have these limits.

It should be noted that in TSet(M )/C, the total maps are (up to equivalence) zero cost maps. Thus, even when C = P this allows only maps with timings which are bounded by a constant to be total. Furthermore, these maps take no account of the size of their inputs (or outputs for that matter). These are major defects from the complexity perspective: however, as we shall see shortly, they are all corrected by the formal construction of splitting idempotents (see section 5).
Joins, Ranges, and Iteration
Given any restriction category there is always an induced restriction partial order on parallel maps; it is defined by f ≤ g if and only if fg = f . This makes any restric- tion category a partial order enriched category. Observe first that this restriction ordering is actually the converse of the complexity ordering:
Lemma 4.1 In TSet(M )/C, for additive C, f ≤ g in the restriction order if and only if g ≤C f in the complexity order.

Proof. For suppose f ≤ g then fg = f so U (g) is at least as defined as U (f ) but, furthermore, on the timing we have a P ∈C such that
|x|g ≤ |x|f + |x|g = |x|fg ≤ P (|x|f )
it follows that g has better C-complexity than f (i.e. g ≤C f ). Conversely, suppose g ≤C f then U (f ) ≤ U (g) and there isa Pj ∈C such that |x|g ≤ Pj(|x|f ). It follows then that
|x| = |x|f + |x|g ≤ |x|f + Pj(|x|f )= (I + Pj)(|x|f )
where the desired bound is I + Pj which, as C is additive, is certainly in C.    2
In any restriction category we say that two parallel maps f and g are compati- ble, f × g, in case fg = gf . In sets and partial maps this means that they take the same value when they are both defined: thus, clearly, the join of the partial maps in sets, f ∨ g, exists. It is not the case that in TSet(M )/C, for an arbitrary M , that one can join maps in this manner. Technically a restriction category has joins if whenever f and g are parallel maps with f × g then there is a parallel map f ∨ g such that, with respect to the restriction order, it is the join – that is f ≤ f ∨ g, g ≤ f ∨ g, and if f ≤ h and g ≤ h then f ∨ g ≤ h – and that join is stable – that is h(f ∨ g) = (hf ) ∨ (hg): in a restriction category this then implies universality, (f ∨ g)k = (fk) ∨ (gk).
In fact, from the general theory [4], any distributive restriction category is an “extensive” restriction category. Extensive restriction categories always have dis- joint joins of partial maps. This provides:
Proposition 4.2 When C is additive, TSet(M )/C has ﬁnite disjoint joins of par- allel maps.
This means that when f, g : A → B are parallel maps with disjoint domains, that is fg = ∅ = gf , where ∅ is the empty partial map then the join of f and g exists: it

is written f Hg to emphasize the disjointness. For a general M it will not be the case that joins of compatible maps exist, however, if we assume M has binary infima, which are preserved by addition (in the sense that (x ∧ y)+ z = (x + z) ∧ (y + z)), then we have:
Proposition 4.3 When M has binary inﬁma which are preserved by addition and
C is additive, then TSet(M )/C has ﬁnite joins of all compatible maps.
Proof. We define f ∨ g to have U (f ∨ g)= U (f ) ∨ U (g) and
⎧ |x|f	f (x) ↓ and g(x) ↑
|x|f ∨g =	|x|g	f (x) ↑ and g(x) ↓
⎪⎪⎩ |x|f ∧ |x|g f (x) ↓ and g(x) ↓
It is left to the reader to check this is well-defined. That it has all the required properties is also straightforward to check.	2
Certainly when M = N the requirements 14 of Proposition 4.3 are satisfied so, in this case, we have finite joins of compatible maps. As N is well ordered, we may also form “ranges” [10,5]: the range associates to each map f : A → B a restriction
idempotent f : B → B such that f f = f , f g = f g, and fg = f g. A range operator provides an algebraic description of the image of a map. Sets and partial maps have ranges because every map has a partial section. For an additive C, TSet(N )/C, also has partial sections for every map: however, the section must be chosen carefully!
We briefly outline these ideas. Given a partial map f : A → B a partial section is a map g : B → A such that gf = g and fgf = f : if a map has a partial section g then f = g. Given f : A → B in TSet(N )/C we may define a zero cost section g so that g(y) is defined only if y = f (x) for some x ∈ X, further, when it is defined, f (g(y)) = y and |g(y)|f = min{|x|f | f (x)= y} (here we use the well-ordering of N ). This is last requirement is necessary as can be seen from the proof that fgf = f . The key steps in the bounding argument are
|x|fgf = |x|f + |f (x)|g + |g(f (x))|f = |x|f +0+ |g(f (x))|f ≤ |x|f + |x|f
where the last step is possible because of the way we chose g(y) to have |g(y)|f minimal. We state without further justification – because it is quite remarkable that these categories are so well-structured:
Proposition 4.4 When C is additive, TSet(N )/C is a discrete range restriction category with ﬁnite joins.
The last aspect of structure we require from these categories is that it should be possible to iterate maps. A category has iteration precisely when it is traced on

14 In this case, as N is well-ordered, it may be tempting to think that as we have arbitrary non-empty infima that we will have arbitrary joins for any set of compatible parallel maps (i.e. not just for finite sets). However, this is not the case: the join of an infinite collection will in general not be well-defined as finding uniform bounds is only possible for finite families.

the coproduct [8,9]. The iteration combinator has the following form:


h : A → A + B
h† : A → B
Iteration

However, in an extensive restriction category any map h : A → A + B can be broken down into two disjoint maps h = f Hg : A → A + B where f : A → A and g : A → B allowing the iteration to be re-expressed as a “Kleene wand”:
f : A → A	g : A → B	f ⊥ g
f٨| g : A → B	Kleene Wand
where f ⊥ g means f g = ∅. Intuitively f is iterated until the guard g is encountered at which point an output is produced. In sets and partial functions the canonical
Kleene wand may be expressed as f٨| g = .∞ f ig. Of course, as both f and g are
partial f٨| g will certainly be partial. However, note that there is an added source of partiality as the iteration of f may never hit the guard.
The Kleene wand, in order to correspond to a well-behaved trace, must satisfy some basic equations:
[W.1] When f ⊥ h then (fg)٨| h = h H f ((gf )٨| (gh));
[W.2] When f ⊥ g, g ⊥ h, and f ⊥ h then (f H g)٨|h = (f٨| g)٨| (f٨| h);
[W.3] When f ⊥ g then (f٨| g)h = f٨| (gh);
[W.4] When f ⊥ g then 1A × (f٨| g)= (1A × f )٨| (1A × g); [W.5] When f ≤ fj, g ≤ gj, and fj ⊥ gj then f٨| g ≤ fj٨| gj. The first identity allows finite unwindings of the iteration:
f٨| g = g H (f٨|fg)= g H fg H (f٨|ffg)= ...
Note that the third identity tells us that f٨| g = (f٨| g)g where f٨| g provides a more primitive form in which g may be regarded as implementing a predicate guard. The fourth identity allows one to trace in a context A.
Sets and partial maps satisfy all these identities and we shall use this to es- tablish that TSet(M )/C also has iteration which is defined in the obvious manner: f٨| g(x) := g(f n(x)) when this is defined for some n (at most one n will work) and
|x|fs| g := ( n—1 |f i(x)|f )+ |f n(x)|g. The only technical problem is then to show that iteration, as we have defined it, is actually well-defined with respect to the equivalence on maps. For this it is necessary to demand more of the complexity order C.
We say that a complexity order is lax if it generated by a class of functions which are lax in the sense that P (m)+ P (n) ≤ P (m + n) (we always have 0 ≤ P (0)). Note that sums and composites of lax functions are lax.
Proposition 4.5 When C is additive and lax TSet(N )/C has iteration.
Proof. The equations all follow easily from the fact that sets and partial maps

satisfy the equations. The only difficulty is to prove that if f ≤C fj and g ≤C gj
then f٨| g ≤C fj٨| gj. Because of these inequalities we have:
f (x) ↓⇒ |x|f ≤ P (|x|f′ )
g (x) ↓⇒ |x|g ≤ Q(|x|g′ )
Suppose now that fj٨| gj(x) is defined then clearly f٨| g(x) will be defined and in fact their evaluations on this element will be the same. That is there is a unique n so that g(f n(x)) = gj(fjn(x)) and they are both defined. Consider the cost of these:
|x|fs| g = |x|fng
= |x|f + |f (x)|f + ... + |f n(x)|g
≤ P (|x|f′ )+ P (|f (x)|f′ )+ ... + Q(|f  (x)|g′
≤ (P + Q)(|x|f′ )+ (P + Q)(|f (x)|f′ )+ ... + (P + Q)(|f  (x)|g′
≤ (P + Q)(|x|f′ + |f (x)|f′ + ... + |f  (x)|g′ )
≤ (P + Q)(|x|f′s| g′ ).
2
The class L (linear time) is lax. Significantly the class P is not lax: the problem is that constant functions are not lax. However, the class P∗ is lax as we removed the constant functions! Recall that constant functions are only important when the input sizes can be zero: we shall remove this possibility shortly.
It is worth remarking that categories of timed sets often have more than one trace. Consider, for example, TSet/L where L is the linear order on the natural numbers with addition. As described above L is lax so that there is a trace as defined above. However, on any size monoid (such as N ) which has a maximum L is also an order for that monoid where addition is replaced by the maximum (e.g. for N regarded as size monoid with addition given by max(x, y)). Furthermore, the two categories of timed sets are then actually isomorphic. However, significantly, the traces given by the above, with respect to addition and maximum, are not the same. This not only demonstrates that a category can have more than one trace but also is a reminder that when one wishes to talk of iteration one may have a choice of iteration!

Splitting Restriction Idempotents
Our next objective is to split the restriction idempotents of TSet(M )/C to produce Split(TSet(M )/C). This is a standard construction (also – for all idempotents – known as the Karoubi envelope or Cauchy completion) which turns the idempo- tents e and ej into objects and takes as the maps f : e → ej those maps in the original category such that efej = f . The construction is remarkable as it pre- serves almost all the properties of the original category. In particular, if one starts with a distributive restriction category then the result will be a distributive restric- tion category. Furthermore, ranges, joins, and iteration are all transferred onto the splitting.

Let us consider in detail what an object of Split(TSet(M )/C) looks like. Recall that a restriction idempotent is just a timed partial identity: it is easy to see that the elements which are not in the domain of the underlying partial identity will not play any role. So it suffices to consider the objects whose underlying partial identity is actually the identity: this makes the only important information the timing of the idempotent. Thus, such an object is essentially a set A with a map which assigns to each element a ∈ A a “size”  a  e (these are called sized sets in [6]). A timed map f : e → ej between two sized sets, in this sense, is a partial map such that
 x  e + |x|f + f (x)  e′ ≤ P (|x|f )	(P ∈ C)
(recall we must have efej =C f ). We may think of this as requiring that the timing of a map cannot be “faster” than what is required to read the input and produce the output! Stated like this it seems to be a reasonable requirement, however, it does mean that even “doing nothing”, in the sense of just passing on the input unchanged involves actually reading the input and writing an output.
In particular, note that a map f : e → ej is total in case f = e which means in terms of timing that
|x|f ≤ P (  x  e)	(P ∈ C) .
If this condition holds, we say that f has time complexity in C. (The other bounding identity holds already from the requirement above.) To have time complexity in C means that the timing of f is C-bounded by the size of its input: so, intuitively, f “runs” in time P (n) where P ∈C and n ∈ M is the size of the input.
Summarizing this discussion we have:
Proposition 5.1 When C is additive Split(TSet(M )/C) is a discrete distributive restriction category in which the total maps are precisely the maps whose time com- plexity lies in C. Furthermore, if TSet(M )/C has joins, ranges, or iteration then so does Split(TSet(M )/C).
There is a technical move we must make at this stage to avoid elements with zero size – which are undesirable in complexity calculations. Every object in Split(TSet(M )/C) has a unique total map to the terminal object ! : X → 1; x '→ () and |x|! = x  . Now there is a subobject of the object 1 = {()} given by splitting the total idempotent  : 1 → 1 where |()|٨ = 1. By slicing the category over the object , Split(TSet(M )/C)/ (note here the objects are total maps kX : X → e with maps f : X → Y with f kY ≤ kX) we make  the restriction final object.
We shall say that C is a pointed complexity order if P (0) = 0 for all P ∈ C. Note that L and P∗ are pointed complexity orders. We observe:
Lemma 5.2 If C is a pointed and additive complexity order then an object Y ∈ Split(TSet(M )/C) has a total map to  (it must be unique) if and only if each element of Y has a non-zero size.
From now on we shall avoid zero size elements by working in Split(TSet(M )/C)/ 
for a pointed complexity order C.

Computability in Timed Sets
The total maps in PTSet := Split(TSet(N )/P∗)/ are by no means the standard PTIME maps of complexity theory as there was no requirement that these maps be realizable by a computation. We have only managed, by construction, to arrange that the “timings” – which are quite arbitrarily given – of all total maps must be polynomially bounded on their input sizes. To obtain, for example, the standard notion of PTIME we must restrict to those timed maps which can be realized by a Turing machine (or some variant thereof – possibly with input and output tapes) in a number of steps which is P-equivalent to the given timing.
Our objective, however, is not merely to cut out the PTIME maps from PTSet but to show how they can be seen to sit in a model of computability in which the total maps are the PTIME maps. More precisely we shall show that the “computable” maps in PTSet form a Turing category in which the total maps are exactly the PTIME maps.
A Turing category may be described as a Cartesian restriction category with an special object T , called a Turing object, such that:
Every object in the category is a retract of T .
There is an application map, also called a Turing morphism, • : T × T → T such that for every (partial) map f : T × T → T there is a total map f : A → T , called an index of f , such that:
T ×,T, •	/ T ¸,
f˜×1T	f
T × T
Turing categories provide a unifying formulation of abstract computability (see [2]), and when the category has joins and is discrete, one can obtain many standard results from computability theory.
We show how to obtain a Turing category in two stages: first, we shall view Turing machines (in the standard sense) as providing a “program object” which acts on lists of bits. Second, we shall describe when a program object makes its values a Turing object so that the programmable maps form a Turing category. Thus, our discussion starts by introducing how the set of Turing machines may be viewed as a “program object”, P . Programs can be evaluated on values (inputs), A, to produce new values (outputs), thus, associated with a program object is an evaluation (partial) map ev : P ×A → A: we then refer to P as being an A-program object. We say a map is “P -programmable” if it is of the form f : A → A; x '→ ev([f|, x), where [f| : 1 → P is an element of P , that is a program. Clearly we would like the programmable maps to form a Cartesian restriction category: to achieve this, however, requires more structure.
In order, for an A-program object to be able to describe maps from An → Am it suffices to describe programmable maps An → A (and when m = 0 the total map An → 1 must be programmable). To describe programmable maps An → A it suffices to be able to encode A2 in A in a programmable way and this leads us to

demanding that the values themselves have a special property.
In a Cartesian restriction category X an object A is a powerful in case there are total maps s× : A × A → A, s1 :1 → A and partial maps P0, P1 : A → A such that s× ⟨P0, P1⟩ = 1A×A (and s1!A = 11). The terminal object 1 is always a trivial example of a powerful object. A more interesting example, which we shall use below, is List(Bool) (lists of Booleans) in LTSet, with size given by x  = 2 · (1 + len(x)) (i.e., twice the length of the list plus one). The map s1 :1 → List(Bool) picks out the empty list. There are then linear time maps s×, P0, and P1 which code and decode pairs:
s×(b : bs, bj : bsj)=1: b :1: bj : s×(bs, bsj)  P0(1 : b : : : rs)= b : P0(rs)
s×([], bj : bsj)=0:0:1: bj : s×([], bsj)    P0(0 : 0 :  :  : rs)= []
s×(b : bs, []) = 1 : b :0:0: s×(bs, [])	P1( :  :1: bj : rs)= bj : P1(rs)
P1( :  :0:0: rs)= []
Given a powerful object A, an A-program object is an object P which has total operations comp, pair : P ×P → P together with total points I0, I1, I, J :1 → P and a partial evaluation map ev : P × A → A such that:


A 	⟨I,1⟩ /P¸× A
ev
P × P ×
1×ev
comp×1/¸
ev
P × P × A pair×1	/P¸× A
⟨π0,π2,π1,π2⟩

J	J	J	J 

A	P × A	ev	/A¸
P × A × P × A	ev
ev×ev

A	i = 0, 1
A 	⟨J,1⟩  /P¸× A	A J	J 



⟨Ii,1A⟩


Pi
J 	z 


!	ev
J	 J 
× A	s×	/A¸

P × A	ev	/A¸
1	s1	/A¸

Program object requirements can be explained as follows. The first diagram states that there must be an identity program. The second says that one must be able to compose programs. The third says that there is an operation, pair, for combining two programs which you wish to apply to a single input in order to produce a pair of answers encoded. The last three diagrams require that there are programs for projecting from an encoded pair and to the terminal object. Clearly the codes of a Turing object include these required elements and can be combined in these ways: so every Turing object is automatically a program object. The converse, of course, is not true.
A map f : A → A is said to be P -programmable in case there is an element
[f| :1 → P such that	P × A  ev	/A¸
⟨[f |,1A⟩	f
A
We shall indicate that X is retract of A by writing X  r A, where sr = 1X and

rs is an idempotent of A. A retract of A, X  r A, isa P -programmable retract
in case the idempotent rs : A → A is P -programmable. If X  r A and Y  v A are
s	u
P -programmable retracts of A then a map h : X → Y is P -programmable if the
map A →r X →h Y →u A is P -programmable.
Note that the conditions of P being an A-program object ensure that 1A is com- putable and if f and g are computable fg is computable: ⟨⟨[g|, [f|⟩ comp, 1A⟩ ev =
⟨[g|, ⟨[f|, 1A⟩ ev⟩ ev = f ⟨[g|, 1A⟩ ev = fg Furthermore, these conditions ensure that all powers An are P -programmable retracts of A (including when n = 0) and, thus, we may form a category, ProgP/A(X), of P -programmable maps in X whose objects are just the powers of A. In fact, it is not hard to prove:
Proposition 6.1 If A is a powerful object and P is an A-program object in a Carte- sian restriction category then the subcategory of P-programmable maps, ProgP/A(X), forms a Cartesian restriction subcategory.
One thing which is perhaps less obvious concerns how the restriction is defined: one uses the fact that f = ⟨1,f⟩ π0: if f is programmable then f = ⟨1,f⟩ π0 =
⟨⟨⟨I, [f|⟩ pair, I0⟩ comp, 1A⟩ ev.
Finally, in order to obtain a model of computability, we wish to understand when an A-program P object turns A into a Turing object in the subcategory of P -programmable maps. The following is the main formal observation of this section:
Proposition 6.2 If X is a Cartesian restriction category with a powerful object A and an A-program object P such that P is a P-programmable retract of A and comp, pair, ev, I0, I1, and I are all P-programmable then ProgP/A(X) is a Turing category.
Proof. Define the program Q := [⟨P0, P1⟩ f| then


A
s××1
× A × A

A × A,×,A 1×s	/A¸×,A,	/P¸× A
sP ×1	ev

(QsP )×1×1
P  × A  	ev	z/A ¸

,,	 ,
Q×1

A × A	s×	/A¸
/A¸× A
⟨P0,P1⟩

where (Q × 1)sP s× is the required total map and the Turing morphism is • := (⟨P0, P1⟩× 1)(rP × s×)ev.	2
Notice that the proof uses all the structure of a programming object and the powerfulness of A. In particular, the definitions of the Turing morphism and of the index use pairing and composition non-trivially.
Our aim is to apply this to the set of Turing machines regarded as List(Bool)- program object in PTSet with the usual timing of evaluation. First note that regarding the program object, P , as the set of specifications of Turing machines

certainly means that P may be viewed a programmable retract of A = List(Bool). Some bit strings may not be legal specifications of a Turing machine but recognizing the legal specifications can certainly be achieved in polynomial time – indeed in linear time as the legal specification can be given by a regular language. The composition and pairing function must take in two specifications of Turing machines and modify them to produce, respectively, the composite or the interleaved pairing. Composition is clearly programmable map on pairs of programs: it basically involves identifying the starting state of the second machine with the final state of the first. Thus, it can be done in linear time. Somewhat trickier is to see that pairing is programmable: the trick is to view pairing as a composite of duplicating the input (onto “odd” and “even” positions on the tape) modifying the first program to act on only “even” bits and composing it with the second program modified to only act on “odd” bits. This can be done in linear time and is certainly programmable and total.
The only remaining difficulty is to show that the map ev is programmable. Recall that the way we defined evaluation was to run the specified Turing machine on the input: now we are asking that there be a universal Turing machine which can interpret any Turing machine specification in a manner so as to make the two maps equivalent with respect to the complexity order (here P∗). Fortunately, that any Turing machine can be simulated by a universal Turing machine with only a loss of an O(log n) factor in performance is well-known (see [1] Theorem 1.9 or [12] in the proof of the “Time Hierarchy Theorem” 9.10). This tells us that evaluation is programmable.
This discussion shows that the conditions of Proposition 6.2 are satisfied and yields:
Corollary 6.3 The maps which are programmable by a Turing machine in polyno- mial time in PTSet form a Turing category, Tptime, whose total maps are precisely the PTIME maps.
As the best known simulation of a Turing machine by a universal Turing machine has an order log n overhead, one cannot quite make the argument (as presented) work for linear time computations. However, for any additive complexity order which contains n log n the argument works verbatim. Hence, this provides a number of examples of Turing categories whose total maps have low time complexity.
We have in these arguments relied on having a priori a grasp of how a Turing machine is timed. However, it is worth remarking that this too can be explained within this formalism using the trace. A Turing machine has the property that its evaluation map is given by iterating a total transition map, that is ev = step٨| halt where step ∨ halt = 1P ×A. The existence of a total transition map is a key ingredient of being a (deterministic) machine. By modeling the machine steps in PTSet one adds timing. Notice, however, that to arrange that each step has unit cost we are essentially forced to assume that the input has unit cost. This makes step٨| halt exceedingly partial. This means these maps do not live in Tptime. On the other hand, Tptime does inherit the trace of PTSet and, in fact, the evaluation map – the Turing morphism we consider above – is given by such an iteration (up to the equivalence

determined by P∗). However, now a single step must have a timing that dominates the cost of “reading” its input (i.e. the size of the tape), so this internal machine, while present, does not reflect well the usual step-counting intuition for measuring time complexity. Thus, it seems that the usual intuition is better served by using the iteration in PTSet with unit timing (as above) together with input and output functions that restore the usual sizing of the input and output. Specifically, taking step٨| halt to be the iteration that counts steps, and ein,eout to be the restriction idempotents whose timing measures the size of lists of bits correctly, the evalution map we actually require in PTSet is
List(Bool)2 ein;steps| halt;eout  /Li¸st(Bool) .
The arguments above all rely, mimicking the approach taken in complexity the- ory, heavily on the machine model and the way resources are measured. Changing the machine model, of course, changes what can be computed and also the overhead of simulation. To illustrate this we briefly discuss LOGSPACE computations. Re- call that a transducer is a Turing machine with a read only input tape (on which one can go backward and forward), a read/write working tape, and a write only out- put tape (on which one can only write and move right): the maximum length that the work tape attains during a computation is the space resource which is measured – this is abstractly now to be the “timing” of the map. The manner of composing transducers is crucial: this, in particular, determines how we set the “timing” of the identity on a list of bits. A transducer thinks of its input as being generated “by need”: if it requires the nth bit it simply runs the transducer which generates its input, throwing away all the bits it generates, until the required bit is produced. It then proceeds with its calculation having obtained the required bit. This is ex- tremely time inefficient but it is space efficient. Minimally to do this one must be able to actually count the bits one must throw away and, for this, one needs roughly O(log n) space. Therefore, the cost of the “reading” the input (the idempotent) on a list of bits is set to be the logarithm (base 2) of the length of the list (rounded away from zero). Furthermore, somewhat surprisingly, the “timing” of composition is given by addition under the linear complexity order, L. Thus, the category of LOGSPACE computations is carved out from LTSet := Split(TSet(N )/L)/ . Fur- thermore, the program object we use this time is the set of transducer specifications on lists of bits.
Again we wish to use Proposition 6.2 to show this category is a Turing category. For this we need to check the requirements. Clearly legal transducer specifications, represented as list of bits, can be recognized using a log space computation so P is a programmable retract of A. Clearly, also, A is still a powerful object with respect to the same maps as above which are all clearly log space. It is less obvious how composition and pairing of transducers can be performed in log space. Composition is implemented by the second program calling on the first program whenever it moves the input head, the first program provides the input required by running itself until the required output is generated. This is achieved by modifying the second program’s read instructions to call the first program and to record a position and can

be achieved in log space. Once one has composition the pairing is straightforward using the technique described above: one expresses it as a composite of duplicating the input, modifying the first program to work on “odd” bits and the second to work on “even” bits. Clearly, these modifications can all be managed in LOGSPACE. For the program evaluation map itself we recall that it is well-known that a universal Turing machine (or transducer) can simulate a specified transducer with only a constant factor of degradation in space efficiency (see exercises in [12,1]).
We therefore have:
Corollary 6.4 The maps which are programmable by transducers in logarithmic time in LTSet form a Turing category, Tlogspace, whose total maps are precisely the LOGSPACE maps.
It is also worth remarking that there is a functor V : Tlogspace → Tptime which takes a LOGSPACE computation to a PTIME computation using the fact that a computation in space s can be performed in time 2O(s)(using [1] Theorem 4.2 for example): the only subtlety is that one must actually “slow down” space compu- tations which do not use the full exponential time so that equivalent programs are taken to equivalent programs. Clearly, this functor preserves the meaning in sets and partial maps:
Tlogspace 	V	/Tp¸time

Par
This shows how relationships between functional complexity classes give rise to functorial relationships between their Turing categories. Whether there exists an isomorphism between Tlogspace and Tptime is, of course, an intriguing question equiv- alent 15 to the open problem whether PTIME = LOGSPACE.

Conclusion
The objective of this work was to provide concrete models of computability, as em- bodied in Turing categories, in which the total maps belong to a specific functional complexity class (such as PTIME and LOGSPACE). The constructions we have provided do achieve this. Furthermore, they closely mimic the standard approach taken in complexity theory. This suggests that the results of complexity theory may be mapped fairly directly into categorical facts.

15 It is immediately clear that if this functor is an isomorphism then PTIME = LOGSPACE. The converse not obvious but, nonetheless, is true. From the assumption that PTIME = LOGSPACE, one can prove that this V must be an isomorphism for all “computable” functions. Here is a sketch of the proof: the idea is to view an arbitrary computation, f, as a function which has a time bound provided by an additional argument, so that f(x) = a ⇔ ∃t.f ′(x, t) = a + 1. The computation f ′(x, t) is total: one interprets f ′(x, t) = 0 as meaning that the computation had not completed by time t. One can further assume that, when it has completed, so that f ′(x, t)= a + 1, then for every t′ ≥ t one has f ′(x, t′)= a + 1. In fact, f ′ is not only total and runs in polynomial time but, when t is represented in unary , it can actually be arranged to run in linear time. This means, by assumption, the program f ′ can be transformed into a LOGSPACE program. However one can then iteratively search over the time, t, using the program f ′ to show that f(x) can be implemented in LOGSPACE.

References
S. Aurora and B. Barak, Computational Complexity: a modern approach. Cambridge University Press (2009).
J.R.B Cockett and P. Hofstra, Introduction to Turing Categories. Annals of Pure and Applied Logic, Vol. 156 (2008) 183–209.
J. R. B. Cockett and S. Lack, Restriction Categories I: Categories of partial maps. Theoretical Computer Science, Vol 270 (2002) 223-259.
J.R.B. Cockett and S. Lack, Restriction categories III: colimits, partial limits and extensivity.
Mathematical Structures in Computer Science, Vol 17- 4 (2007) 775-817.
J.R.B. Cockett and E. Manes, Boolean and Classical Restriction Categories. Mathematical Structures in Computer Science, Vol 19-2 (2009) 357-416.
J. R. B. Cockett and B. F. Redmond A Categorical Setting for Lower Complexity. Electronic Notes in Theoretical Computer Science, Vol. 265 (2010) 277 300.
D. Gurr, Semantic frameworks for complexity. PhD Thesis, University of Edinburgh (1991).
M. Hasegawa, On traced monoidal closed categories. Mathematical Structures in Computer Science, Vol 19-2 (2009):217-244.
A. Joyal, R. Street, and D. Verity, Traced monoidal categories. Math. Proc. Cambridge Philos. Soc. Vol. 119-3 (1996) 447468.
R.A. Di Paola and A. Heller, Dominical categories: recursion theory without elements. Journal of Symbolic Logic, Vol. 52 (1987), 595-635.
E. Robinson and G. Rosolini Categories of partial maps. Information and Computation, vol. 79 (1988) 94–130.
M. Sipser Introduction to the theory of computation. PWS Publishing Company (1996)
