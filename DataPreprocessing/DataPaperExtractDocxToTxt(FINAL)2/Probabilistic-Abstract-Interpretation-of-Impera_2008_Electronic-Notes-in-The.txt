

Electronic Notes in Theoretical Computer Science 220 (2008) 43–59
www.elsevier.com/locate/entcs

Probabilistic Abstract Interpretation of Imperative Programs using Truncated Normal Distributions
Michael J. A. Smith1 ,2
Laboratory for Foundations of Computer Science University of Edinburgh
Edinburgh, United Kingdom

Abstract
When modelling a complex system, such as one with distributed functionality, we need to choose an ap- propriate level of abstraction. When analysing quantitative properties of the system, this abstraction is typically probabilistic, since we introduce uncertainty about its state and therefore its behaviour. In par- ticular, when we aggregate several concrete states into a single abstract state we would like to know the distribution over these states. In reality, any probability distribution may be possible, but this leads to an intractable analysis. Therefore, we must find a way to approximate these distributions in a safe manner. We present an abstract interpretation for a simple imperative language with message passing, where trun- cated multivariate normal distributions are used as the abstraction. This allows the probabilities of transient properties to be bounded, without needing to calculate the exact distribution. We describe the semantics of programs in terms of automata, whose transitions are linear operators on measures. Given an input mea- sure, we generate a probabilistic trace whose states are labelled by measures, describing the distribution of the values of variables at that point. By the use of appropriate widening operators, we are able to abstract the behaviour of loops to various degrees of precision.
Keywords: Probabilistic abstract interpretation, Probabilistic semantics, Truncated normal distributions, Widening operators


Introduction
In classical program analysis, abstract interpretation [1] is a powerful framework for computing safe approximations to properties of interest. These properties may be undecidable in general, but we can compute them efficiently if we are prepared for the answer to be uncertain some of the time, in that impossible behaviours are thought to be possible. Importantly though, the safety of our abstraction ensures that the converse is false – no possible behaviour is ever thought to be impossible.

1 This work was funded by a Microsoft Research European Scholarship
2 Email:M.J.A.Smith@sms.ed.ac.uk

1571-0661 © 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.11.018

In 1981, Kozen [3] described a semantics for probabilistic programming languages in terms of linear operators on Banach spaces. A program is then a linear map from an input probability measure (the joint distribution of the initial values of its vari- ables) to an output sub-probability measure (since there may be some probability of non-termination). Monniaux [4] and Di Pierro and Wiklicky [6] use two different ideas to extend abstract interpretation to these domains, resulting in a probabilistic abstract interpretation.
The approach taken by Wiklicky and Di Pierro defines the notion of ‘closeness’ of approximation in terms of an inner-product metric on measures. Monniaux, on the other hand, applies the more classical order-theoretic approach to Banach spaces, by ordering measures based on their total measure. Both approaches, whilst theoretically applicable to continuous measures, have difficulty in practice – in the former, the abstraction and concretisation functions need to actually be constructed, and in the latter the distributions must be discretised to the required precision.
In this paper, we present an alternative approach, which is less general than the two aforementioned, but provides an abstract domain in which continuous measures can be operated on in an efficient and scalable manner. This is not to say that the aforementioned have not been successfully applied to other domains, such as approximation of finite probabilistic automata in the case of Wiklicky and Di Pierro, but we wish to avoid discretising distributions, which can lead to a state space explosion.
Our motivation is to provide a probabilistic abstraction of deterministic pro- grams, in that we are interested in the behaviour of a program when its input follows some distribution. This is particularly applicable to distributed systems, where we are interested in the behaviour of the system given some environment (such as a distribution of packet lengths, or over varieties of client behaviour), which is often not deterministic. In this case, knowing how the system behaves on a particular input cannot necessarily help us to determine more global performance properties. In building an abstract interpretation we need to have some property that we want to approximate, and in our case this is the probability of being in a certain state of the system, and also of taking a particular path through the system. As a consequence, we look for abstract measures that are strict upper bounds of the concrete, or actual measures. For our abstract domain, we choose the truncated multivariate normal distributions (or more precisely, measures), because they can be easily operated upon, since they have only a small number of parameters, and can approximate a variety of distributions (for example, an exponential distribution
can be approximated by truncating a normal distribution to just its tail).
This paper is structured as follows. In Section 2 we describe a simple imper- ative language with message passing, and give a concrete probabilistic semantics in Section 3. Following this, we review the framework of abstract interpretation in Section 4 before presenting our abstraction and abstract semantics in Section 5. We conclude with Section 6.

Syntax of Imperative Programs

We consider simple imperative programs with the following syntax. Variables X are real-valued, which can be viewed as a continuous abstraction of integer-valued variables. Arithmetic expressions E have the following syntax (where c ∈ R are constants):
E	::=	c | X | −E | E + E | c × E
Note that these expressions are always linear. This does not reduce expressivity, since non-linear operations can be encoded using loops. By defining our language in this way we will need only to abstract loops in order to abstract non-linear behaviour, hence two separate abstractions are not necessary.
For Boolean expressions B:
::=	true | false | X < c | X ≤ c | ¬B
Note that without loss of generality, we only allow a variable to be compared with a constant. Since we can construct more complex comparisons by first defining a new variable, this serves to simplify our abstraction as we shall see later. Furthermore, conjunctions and disjunctions of conditions can be expressed (albeit inefficiently) by nesting if-statements, hence are not necessary as primitives.
Finally, a command C is of the following form:
::=	skip | return E | X := E | X := f (X,... ,X)
|	C ; C | if B then C else C | while B do C
|	sendα(X) | recvα(X, X)
To simplify the presentation, we do not allow recursive function calls. The only un- usual feature of this language is asynchronous message passing. This is implemented by the send and recv actions, which are parameterised by a channel name, α. Both of these commands are asynchronous, in that the program will never block on their execution. The sendα(X) command writes the value of variable X to channel α (overwriting any value that is already on the channel), and recvα(X, Y ) attempts to place the content of α into X. If the recv is successful, then Y is assigned the value 1, otherwise Y := 0. A channel can be thought of as a global variable with two states – either it is empty, or it contains a real value.
A system consists of a number of function definitions, and an initial state. Func- tion definitions are of the form f (X,... ,X) { C }. The initial state S is of the form:
S	::=	f (X,... ,X) | S | S
This can be thought of as the parallel composition of a number of function calls, with the initial values of the arguments described by a joint distribution. These function calls, or threads, can communicate with one another via message passing, and will execute in parallel (we use an interleaved semantics). Since we do not allow the explicit creation or deletion of threads, the number of threads in the system is

constant.

Concrete Semantics
Before we describe our semantics in terms of probabilistic automata, we first need to describe the data environment of a program; in other words, the domain of its variables. Rather than considering individual values that a variable can take, we consider it to take a range of values according to some probability distribution. In essence, variables are viewed as random variables and the operation of the program is to transform them. However, since we are only concerned with the distribution of these random variables (specifically, their joint distribution), we can treat the program as operating on this distribution directly.
Before we proceed, let us remind ourselves of the following definitions from measure theory:
A σ-algebra of a set X is a subset of P(X) that contains ∅ and X, and is closed under countable union and intersection.
A measurable space (X, σX ) is a set X with a σ-algebra σX. The elements of σX
are the measurable subsets of X.
A measurable function is a well-behaved function between two measurable spaces.
A measure is a countably additive function μ : σX → R.
A positive measure is a countably additive function μ : σX → R+.
The total weight of a measure μ on a measurable space (X, σX ) is given by μ(X).
A probability measure is a positive measure with total weight 1.
A measure space (X, σX , μ) is a measurable space (X, σX ) equipped with a mea- sure μ.
A probability space is a measurable space equipped with a probability measure.
A random variable is a measurable function whose domain is a probability space.
As per Kozen [3], we consider the state of a program’s variables to be described by a probability measure. That is to say, we can assign a probability to each (mea- surable) set of values that the variables could range over. For a given measurable space, the set of measures over that space induces a Banach space. In other words, it induces a normed vector space that is complete with respect to the metric induced by its norm.
The operation of a program is to transform one measure into another, and so is a linear operator between two measure spaces, or a continuous linear operator on the induced Banach space. Kozen describes a denotational semantics in which a single linear operator describes the entire program. We can think of such an operator as a map from a probability to a sub-probability space in general, since the program may not terminate on all inputs. Under this approach, loops are denoted using a least fixed point operator, in the style of conventional Scott-Strachey semantics. In our semantics we represent loops by cyclic transitions in an automaton, but for

sequential code that does not involve message passing, our semantics are essentially the same.
We will refer in the following to three distinct semantics. ·) is the conventional deterministic semantics of our programs, and we use this to define what we mean by assignment, and boolean conditions on our variables. ·)p is the probabilistic semantics described by Kozen, which we will use for the sequential fragments of our programs. Finally, ·)pa is the probabilistic automaton semantics, which we will define shortly.
A program consists of a vector of N variables, X1,... , XN , which may be as- signed to linear expressions of one another. In the deterministic semantics, our state is a vector of size N , storing the value of each variable, and so we view an assignment as follows:
 Xi := E) = ⟨x1,... , xi−1, xi, xi+1,... , xn⟩ '→ ⟨x1,... , xi−1, E), xi+1,... , xn⟩
As usual, we replace the old value of the variable by the new, which is given by the expression E. Extending this to the probabilistic setting, we want instead a map between two measures. We have an initial measure μ, and so the new measure
μ' after executing the assignment can be found by ‘reversing’ the assignment, then applying μ. In other words, the probability of being in a certain state s after the assignment is the probability of being in any of the states that could lead to s before the assignment. Formally, the semantics is as follows:
 Xi := E)p(μ)= μ ◦ Xi := E)−1
To describe our semantics ·)pa, we need a little more than just linear operators. In particular we have a set of states, and a transition relation between these states. Since a transition represents a sequence of sequential operations, we associate a linear operator with it, in the same way as above. We only introduce states when there is a branch in control-flow due to a loop, or due to message passing (which is encoded by a label on the state). Forward branches due to conditional statements do not require additional states, and can be represented by multiple transitions out of a state (analogous to addition in ·)p).
More formally, the semantics of a program consists of the following elements:
A vector X of variables, X1,... , XN (where N is the number of variables).
A set C of channels.
A set S of internal states (which may be empty). States have an optional label
L ∈L = {send i , recv i,j | α ∈ C, 1 ≤ i ≤ N }, which specify sending or receiving
the value of a variable Xi over a channel α (and in the case of a recv recording the success in variable Xj).
A transition relation T ⊆ ({•} ∪ S)2 × M, where M is the set of linear operators M : μ → μ on measures μ. For convenience, we will write a transition (s, s',M ) as s −M→ s'.
The special state • denotes the entry and exit points of the automaton, depending

on whether it occurs on the left or right hand side of a transition. For simplicity, we will assume that X and C are fixed, and are known before applying the seman- tics to our programs. In particular, this means that there are no name conflicts between variables in different functions; a condition easily met by replacing a func- tion with an α-equivalent version. The remaining two factors, the states and the
transitions, may vary between two programs, and we use  ·)S and  ·)T to refer to
these respectively.
We can now describe our probabilistic automaton semantics. We begin with the skip command, which is trivially the identity map (I(μ) = μ) on the input measure, and has no states:


 skip)S
= {}	 skip)T
= {• −→ •}


Perhaps surprisingly, return statements are treated in the same way – since we do not modify any variables, it has no effect on their joint distribution:


 return E)S
= {}	 return E)T
= {• −→I  •}


Basic assignments do not introduce any state, and are denoted by the same operator as in Kozen’s semantics:
 Xi := E)S = {}
M
 Xi := E)T = {• −→ •} where M = Xi := E)p
Calling a function f , defined f (Xj1 ,... , Xjn ) { C }, can be thought of as modifying the denotation of the body of the function so that the argument variables are re- placed by the actual arguments, and the return call is replaced by the appropriate variable assignment. More formally:
 Xi := f (Xi1 ,... , Xin ))pa = C{Xi1 /Xj1 ,... , Xin /Xjn ,X := E/return E})pa Sequencing involves composing two automata, so that the exit transitions of the first are merged with the entry transitions of the second. The resulting linear operator
is the composition of the originals. If there is more than one start or exit transition, we must take all possible combinations. Hence in the worst case, the size of the automaton may grow exponentially in the number of branching instructions.
Formally, the semantics is as follows:

 C1 ; C2)S
= C1)S ∪  C2)pa

 C  ; C )T
= {s M1◦M2
s' | s M1
 C )T
s' ∈ C )T } ∪

{s −→ s
∈  C1)pa | s
/= •} ∪ {s −→ s
∈ C2)pa | s /= •}

To describe the semantics of if-statements, we first need to describe the semantics of conditions. A condition B denotes the set  B) of valuations of variables that satisfy
B. Let the measure μY be such that μY (Z) = μ(Y ∩ Z). Then we define e B) to be the linear operator μ '→ μ B). Intuitively, we throw away all the unreachable environments (that do not satisfy the condition B) before applying the measure μ:


Repeater(X,Y ) {
while (Y > 0) {
sendα(X);
Y := Y − 1;
}
return Y ;
}



Fig. 1. An example program and its concrete semantics

 if B then C1 else C2)S
= C1)S ∪  C2)pa

 if B then C1 else C2)T
e B) ◦M
= {• −−−−−→
s |• −M→ s ∈  C1)T } ∪

{s −→ s ∈ C1)pa | s /= •} ∪
e ¬B) ◦M	M	T
{• −−−−−−→ s | • −→ s ∈ C2)pa} ∪
{s −→ s ∈ C2)pa | s /= •}
The behaviour of while loops requires us to introduce an additional state. This corresponds to the beginning of the body of the loop, so that reentering the loop equates to returning to this state. If we were to unroll the loop, we would effectively compute the fixed point, as done explicitly by Kozen. The formal statement of this semantics is as follows, where s' is a fresh state:

 while B do C)S
= C)S ∪ {s }

 while B do C)T
e B)
= {• −−−→
'	e ¬B)
s } ∪ {• −−−→ •} ∪

' M	M	T
{s −→ s |• −→ s ∈ C)pa} ∪
M ◦e B)	'	M	T
{s −−−−−→ s | s −→•∈ C)pa} ∪
M ◦e ¬B)	M	T
{s −−−−−−→•| s −→•∈ C)pa} ∪
{s −→ s ∈ C1)pa | s /= •∧ s /= •}
Finally, we consider the semantics of message passing. For both send and recv calls, the only action is to introduce an additional state, with the corresponding label. In the following, s is a fresh state:


 sendα(Xi))S = {s[send i ]}	 sendα(Xi))T
= {• −→I s, s −→I •}

pa
 recv (X ,X ))S
α
= {s[recv i,j]}	 recv
pa
I
(X ,X  ))T   = {• −→

s, s −→I  •}


The above semantics gives an automaton describing the behaviour of the pro- gram as a function of its input distribution. An example program and its semantics

are shown in Figure 1 for illustration. If we consider a particular input distribution, the concrete interpretation of this automaton yields a probabilistic trace. If there are n variables in a program, the states of this trace are of the form μ  s, where μ is a sub-probability measure over the measurable space (Rn, σ(n)), and s is a state in the automaton. A transition μ ▶ s → μ' ▶ s' in the trace exists iff there is a transition s −M→ s' in the automaton, and μ' = M (μ). This transition occurs with

μ(Rn )
Due to lack of space, and since it is not essential to the probabilistic abstract interpretation, we will not formally describe the trace semantics of labelled states. Intuitively, a state labelled with sendα replaces the measure associated with channel
α (over (R ∪ {⊥}, σR∪{⊥})) with the measure obtained by projecting the variable we wish to send. Similarly, a state labelled with recvα replaces the measures on the two variables we receive into (the data and the success indicator) based on the
measure on α. Essentially, we treat channels just like any other variable, except that the interleaving semantics introduces non-determinism.
Since we are interested not in the concrete interpretation itself, but in some property of it, we define a collecting semantics to describe this. In our case, we choose to look at the total measure of each state in the automaton (corresponding roughly to points in the program). This is the sum of all the measures that occur at a particular state in the automaton throughout the trace. The collecting semantics Coll [ P )pa(μ)] of the concrete interpretation of the semantics ·)pa of a program P with input μ is defined as:
Coll [ P )pa(μ)](s)=	Σ	μ'
μ'▶s∈ P )pa(μ)
This can be thought of as the semantics of profiling, in that collected measures μ(X) give the expected number of times that we will see the values X in the given state. We can obtain an average measure for the state by dividing by μ(Rn), the total measure.
Abstract Interpretation
Classical abstract interpretation [1] is a mathematical framework that relates a concrete domain to an abstract one. Properties in the abstract domain are safe approximations (supersets) of their concrete counterparts. By constructing a suit- able abstract domain and abstract semantics, we can reason about properties of a program that would otherwise be undecidable in general, at the cost of some precision.
Abstract interpretation can be applied to many different semantic frameworks, but since we are working with a transition system style of semantics, we will de- scribe it just in this setting. Consider two preordered sets, the concrete domain (X, ≤) and the abstract domain (X , ≤ ). To relate the two domains, we have an abstraction function, α : X → X , and a concretisation function, γ : X → X. A safe abstraction will be one that satisfies, for all x ∈ X, x ≤ γ(α(x)). If X ⊂ X, we

can let the concretisation function be the identity map so that we can concentrate solely on the definition of α.
The usefulness of this framework comes when we apply it to our transition semantics. If a property x ∈ X (e.g. a valuation of variables) holds at a state s (e.g. a program point), then we write the statement x ▶ s. The concrete semantics then induces a transition relation → between these statements. An abstract semantics, inducing → for x ∈ X , is then safe if the following property holds:

Definition 4.1 A concrete and an abstract transition relation, → and → , satisfy the relational homomorphism property if x1 ▶ s1 → x2 ▶ s2 and α(x1) ≤ x imply that there is an abstract transition x ▶ s1 → x ▶ s2 such that α(x2) ≤ x .

For the proof of this, see [7]. Note that a very common way of constructing an abstract interpretation is to find monotone functions α and γ that form a Galois connection [1]. To do this, we need a notion of ‘best’ approximation, which does not always exist, and indeed does not exist for our domains. This approach has the advantage of telling us how to construct our abstract semantics, as opposed to constructing it first and then proving that it is safe.
In the probabilistic setting, our domains are Banach spaces rather than pre- ordered sets, but the above approach still applies. By applying classical abstract interpretation to the probabilistic setting, we take an approach similar to Mon- niaux [4]. Rather than comparing measures by their total measure, however, we choose a much stronger comparison, which we call the strict ordering on measures.


Definition 4.2 Two measures μ and μ' over the same measurable space (X, σX ) are comparable under the strict ordering on measures so that μ ≤str μ', if:

∀x ∈ σX.μ(x) ≤ μ (x)

Our motivation for this ordering is that it allows the measures on any set to be compared. For example, an approximation of the probability of taking a control-flow decision can be obtained by looking at the measure on the set of values that satisfy the condition. Note that any measure that approximates a probability measure (other than itself) will be a super-probability measure – if the abstraction gives a probability of 0.5 then we know that the actual probability is less than or equal to this, but can never be greater.
An alternative approach taken by Di Pierro, Wiklicky et al [6,5] is to look for a probabilistic analogue of the Galois connection. This, the Moore-Penrose pseudo inverse, gives the closest approximation to the inverse of a function, leading to a probabilistic notion of safety. While this approach has had much success, it is difficult to use in practice for infinite Banach spaces (i.e. continuous measures), such as the ones we consider.



Fig. 2. Overview of our probabilistic abstract interpretation
Abstract Semantics
So far, we have considered the concrete domain, where any probability measure is allowed. In a practical sense, however, it is infeasible to deal with such arbitrary distributions, as we need to represent them somehow. The approach taken by Mon- niaux [4] is to discretise distributions to the required degree of precision and operate on these. We take a different approach, by looking for a suitable class of contin- uous distributions that are easily parameterised, and therefore lend themselves to efficient manipulation in the abstract domain.
Such a class of distributions are the multivariate normal distributions [9], and more generally the truncated multivariate normal distributions. The appeal of nor- mal distributions is that they are preserved under linear operations, and are com- monly observed in practice, due to the central limit theorem. By using a multi- variate distribution, we can represent dependencies between variables in a compact way. Truncations represent control-flow constraints, which restrict the range of values that the variables can take. An overview of our abstract interpretation is shown in Figure 2. Note that at every stage we have a safety relation between the concrete and abstract domains, so that the safety of our abstraction is preserved throughout. Just like the concrete semantics, there are three stages to deriving an abstract property of a program:
Abstract semantics – we compute an abstract probabilistic automaton that is a safe approximation of the concrete semantics of the program. In other words, we satisfy the relational homomorphism property (Definition 4.1).
Abstract interpretation – we “execute” the abstract automaton with a particu- lar input measure. This generates a probabilistic trace that approximates the concrete one, in that the set of measures associated to each state bounds that of the concrete trace. It follows that the abstract transition probabilities are

also upper bounds of the concrete transition probabilities.
The main issue here is ensuring that the abstract interpretation terminates, and to do so we employ memoisation, or widening operators, as we shall see later.
Abstract collecting semantics – we sum the measures associated with each state in the automaton (which may appear more than once in the trace). Since the actual measure may be difficult to calculate, we compute a safe over- approximation.
We will present each of these stages in more detail, but first we need to formally describe the abstract domain.
Since we will be over-approximating the measures in the concrete domain, the abstract measures will not in general be probability measures. We will therefore work with truncated multivariate normal measures, which can be thought of as truncated multivariate normal distributions, with an additional parameter denoting its total measure. For our purposes, we will describe a measure μ by the pair (μT ,f ), where f is a probability density function, and μT is the total measure of μ (μ(Rn)).
Hence μ(X)= μT ∫x∈X f (x)dx. If μ has the probability density function f , then we
write μ ∼ f .
Definition 5.1 A multivariate normal measure, μ ∼ Nn(μ, Σ), is a measure over (Rn, σ(n)) with the following probability density function:

1	1	T  −1

f (x)= 
1 √   e− 2 (x−μ) Σ
(x−μ)

|Σ| 2	2π
where n is the number of variables, μ is the mean vector of length n, and Σ is the n  n covariance matrix. If we think of this as the joint distribution of values of a vector X of n variables, then the elements of Σ are such that σii = Var(Xi), and σij = Cov(Xi, Xj)= σji.
It is unfortunate that the Greek letter μ is conventionally used for both measures and means, however since we are dealing with multivariate distributions, we will always use boldface μ to refer to the mean, and lightface μ for measures.
In order to allow truncated multivariate normal measures, we define a truncation function T [a, b] over measures:
Definition 5.2 The truncation function T [a, b], where a and b are column vectors of length n, is defined for measures μ over (Rn, σ(n)), such that:
T [a, b](μ)(X)= μ(X ∩ {x ∈ Rn | a ≤ x ≤ b})
The elements of a and b are from the set R ∪ {⊥, T}, where ∀x ∈ R. ⊥ < x < T.
Intuitively, the truncation T [a, b] confines measures to the rectangular region [a, b], such that the measure on any set outside this region is zero. We can now define the class of truncated multivariate normal measures:

Definition 5.3 A measure μ is a truncated multivariate normal measure if it can be written in the form T [a, b](μ'), where μ' is a multivariate normal measure. When
'  = 1 (i.e. μ' is a probability measure), we will use the shorthand T [a, b]Nn(μ, Σ)
to completely define μ.

Before we describe our abstraction function α and our abstract semantics, we will recall an important property of the multivariate normal distribution. For a vector of random variables X ∼ Nn(μ, Σ), if we apply a linear operation such that B is an n × n matrix and c is a column vector of size n, the following standard result [9] holds:
Y = BX + c ∼ Nn(Bμ + c, BΣBT )
So that we can directly talk about an operation on measures, rather than on random variables, we introduce the operator L[B, c], which is defined as follows:
Definition 5.4 The linear operator function L[B, c], where B is an n × n matrix and c is a column vector of length n, is defined for measures μ over (Rn, σ(n)), such

that:

L[B, c](μ)(X)= μ({x | Bx + c ∈ X})

A consequence of the standard properties of multivariate normal distributions is that if μ ∼ Nn(μ, Σ) then L[B, c](μ) ∼ Nn(Bμ + c, BΣBT ).

Notice that we can easily apply such linear operations precisely to multivariate normal measures, but not to truncated multivariate normal measures (which will in general not remain truncated multivariate normal after the operation [2]). To combat this, we introduce an abstract linear operator function L [B, c]:
Definition 5.5 The abstract linear operator function L [B, c] is defined over trun- cated multivariate normal measures T [a, b](μ), such that:

L [B, c] ◦ T [a, b](μ)= T (B[a, b]+ c) ◦ L[B, c](μ) where B[a, b]+ c is defined as per interval analysis.
The safety of this abstraction is established in the following theorem, which
allows us to over-approximate the actual answer by reversing the order of the linear operation and the truncation.
Theorem 5.6 For all measures μ, L[B, c] ◦ T [a, b](μ) ≤str L [B, c] ◦ T [a, b](μ).

Proof. By definition of the operators, and since we can safely apply the new trun- cation interval T (B[a, b]+ c) first (values outside this region are impossible to

obtain), we have:
L[B, c] ◦ T [a, b](μ)(X) =
T (B[a, b]+ c) ◦ L[B, c] ◦ T [a, b](μ)(X)
=  T (B[a, b]+ c) ◦ L[B, c](μ(X ∩ {x ∈ Rn | a ≤ x ≤ b}))
= T (B[a, b]+ c) ◦ μ({x | Bx + c ∈ X ∩ {x ∈ Rn | a ≤ x ≤ b}})
≤str T (B[a, b]+ c) ◦ μ({x | Bx + c ∈ X})
=  T (B[a, b]+ c) ◦ L[B, c](μ)(X)= L [B, c] ◦ T [a, b](μ)(X)


Relating the Concrete and Abstract Domains
We would like our concrete domain to consist of all possible measures, and our abstract domain to be the truncated multivariate normal measures, as described. Unfortunately, constructing an abstraction function from such a domain is not a simple task. Not only does it contain measures that we cannot write down, but it is difficult to satisfy the relational homomorphism property (Definition 4.1). Instead we restrict our concrete domain to those measures that can be computed by a series of linear operations and truncations applied to a multivariate normal measure. Whilst this is restrictive, it still allows us to represent a useful class of measures, and loosening this is the subject of future work. More formally:
The concrete domain D consists of measures of the form L[Bn, cn] ◦ T [an, bn] ◦
... ◦ L[B1, c1] ◦ T [a1, b1](μ), and is ordered by the strict ordering on measures.
The abstract domain D consists of measures of the form T [a, b](μ), and is ordered

 
str
. This is defined such that T [a1, b1](μ1) ≤ 
T [a2, b2](μ2) if μ1 ≤str μ2

and [a1, b1] ⊆ [a2, b2].
The ordering of the abstract domain is necessarily stronger than that of the concrete domain, in order for the abstract semantics to be monotone. We can now define our abstraction function as follows:
Definition 5.7 The abstraction function α : D → D of a measure μ ∈D is defined inductively as follows:
α(μ)	= μ if μ is a multivariate normal measure
α(T [a, b](μ)) = T [a, b](α(μ))
α(L[B, c](μ)) = L [B, c](α(μ))
Note that T [a2, b2] ◦ T [a1, b1] = T ([a2, b2] ∩ [a1, b1]) if the intersection of the intervals is non-empty, and λx.0 (the zero measure) otherwise. For linear operators, L[B2, c2] ◦ L[B1, c1]= L[B2B1, B2c1 + c2].

Stage 1 – Abstract Semantics
The abstract semantics of a program is an automaton with the same states as its concrete semantics, but with transitions that operate on truncated multivariate nor- mal measures, rather than arbitrary measures. Since the structure of the automaton is the same as for the concrete semantics, we need only describe the abstraction of the functions on transitions. Hence we need an abstraction for the probabilistic
semantics of assignment,  ·) , and for the semantics of conditional operators, e  .

Given these,  C) 
= C)
p
{ ·)  /  ·) , e
/ e  }.
 ·)

We begin with the abstract semantics of assignment:
 Xi:=E) (μ)= L [B, c](μ)
where B and c describe the operation of E, such that if the program’s variables have state x (a column vector of length n), then Xi:=E)(x)= Bx + c.
For the abstract semantics of conditional operators, we have the following:


 
 true)
e 
 
 false)
(μ) = T [⊥, b](μ)	e 
(μ)	= λx.0
(μ) = T [a, T](μ)

 Xi≤c)
 
 Xi≤c)
 ¬(Xi<c))
(μ) = T [⊥, b](μ)	e 
(μ) = T [a, T](μ)

where bi = c, bj = T (for j /= i), and ai = c, aj = ⊥ (for j /= i). Note that there is a slight over-approximation for the {<, >} comparisons, to avoid distinguishing between open and closed truncation intervals in the abstract domain.
It remains to prove that the abstract semantics is safe; that is to say, that it satisfies the relational homomorphism property (Definition 4.1).
Theorem 5.8 For all programs P, for all transitions s1 —M→ s2 ∈ P )pa there exists

an abstract transition s1
M 
——→ s2
∈  P )pa
such that for all measures μ ∈ Ð, if

α(μ) ≤ 
μ ∈ D then α(M (μ)) ≤ 
M (μ ).

Proof. Firstly, we note that there is a bijection between concrete and abstract transitions, which ensures a unique M for each M . The structure of both M and M consists of a sequence of truncation operators and linear operators (ignoring the identity operator as trivial). We prove the theorem by induction on this structure, starting with the two base cases.
For a truncation operator, we note that the abstract semantics generates an interval that over-approximates the actual set of values that satisfy the condition. Hence if α(M (μ)) = α(T [a, b](μ)) = T [a, b](α(μ)) (using the definition of α), then

M (μ ) = T [a', b'](μ ), where [a, b] ⊆ [a', b']. Hence α(M (μ)) ≤ 
M (μ ) since

α(μ) ≤  μ .
If M and M are linear operators then they have the forms L[B, c] and L [B, c] respectively. Let α(μ)= T [a1, b1](μ1) and μ = T [a2, b2](μ2). Then:

α(L[B, c](μ)) = L [B, c](α(μ)) from the definition of α
= L [B, c](T [a1, b1](μ1))
= T (B[a1, b1]+ c)  L[B, c](μ1)
 
≤str T (B[a2, b2]+ c)L[B, c](μ2) since α(μ) ≤str μ
= L [B, c](T [a2, b2](μ2)) = L [B, c](μ )
This uses the fact that if μ1 ≤str μ2 then L[B, c](μ1) ≤str L[B, c](μ2).
Finally, the inductive step completes the proof. If M = M2 ◦ M1 and M  =
M ◦M , such that M2 and M are base operators, then by the induction hypothesis
the theorem holds for M1 and M . Hence α(M1(μ)) ≤  M1(μ ), and since M2 and
M are both either truncation or linear operators, it follows that α(M2 ◦M1(μ)) ≤ 
M2 ◦ M1(μ ) holds by the above cases.	 

Stage 2 – Abstract Interpretation
The abstract interpretation of our abstract automaton is defined in the same way as for the concrete automaton, inducing an abstract transition relation → when given an input distribution. This has states μ ▶ s, where μ is a truncated multivariate normal measure, and s is a state in the abstract automaton. The safety of the abstract interpretation is a consequence of Theorem 5.8, which ensures that the concrete trace generated from the measure μ is simulated by the abstract traces
generated from all μ ≥  α(μ).
As it stands, the abstract interpretation may not terminate, and even if it does, it may take a long time to do so, due to the presence of loops. To avoid this problem, we memoise it, using a widening operator o, which allows us to jump to an over-approximation of all the measures that can ever occur at a given state. This requires a slight modification to our abstract semantics, so that the states in the trace are assigned a set of measures, M, rather than a single measure μ. We say
that  M ± M'  if  ∀m  ∈ M.  ∃m'  ∈  M'. m  ≤  	m'. We denote by T the set of
all truncated multivariate normal measures, which is the worst case approximation
when we lack precision.
To perform the memoised abstract interpretation, we keep a lookup table of the set of measures lookup(s) that have so far been assigned to each state s. We allow such sets to either be empty (when we have yet to visit the state), T (when we cannot say anything about the measures that can occur), contain just one measure, or contain a parameterised set of measures. For the purposes of this paper, the latter must be of the form M = {T [a, b] ◦ Nn(μ + cx, Σ) | c ∈ N}. This corresponds to a set of multivariate normal measures with linearly varying means that are truncated to the interval [a, b]. This would occur in a state within a loop where the variables are only incremented or decremented by a constant value.
To execute the abstract semantics, we do the following. If we are currently
at state M ▶ s then for each transition s —M→ s' in the automaton, we generate a transition M ▶ s → M (M)olookup(s') ▶ s' in the abstract trace. Finally, we update the lookup table so that lookup(s') = M (M)olookup(s'). The map

M (ł) is defined such that M ({}) = {}, M (T) = T, M ({μ}) = {M (μ)}, and
M ({T [a, b] ◦ Nn(μ + cx, Σ)})= {M ◦ T [a, b] ◦ Nn(μ + cx, Σ)} (for c ∈ N).
The widening operator is defined as follows, with {}oł = ł, Toł = T, and
ł1oł2 = ł2oł1:
{μ}o{T [a, b] ◦ Nn(μ + cx, Σ)}
⎨ {T [a, b]Nn(μ + cx, Σ)} if μ ∈ {T [a, b]Nn(μ + cx, Σ)}
=
⎩ T	otherwise
{T [a1, b1] ◦ Nn(μ1 + cx1, Σ1)}o{T [a2, b2] ◦ Nn(μ2 + cx2, Σ2)}
⎨ {T ([a1, b1] ∩ [a2, b2])Nn(μ1 + cx1, Σ1)} if μ1 = μ2 Λ Σ1 = Σ2 Λ x1 = x2
=
⎩ T	otherwise
{T [a1, b1]Nn(μ1, Σ1)}o{T [a2, b2]Nn(μ2, Σ2)}
⎨ {T [a1, b1]Nn(μ1 + cx, Σ1)} if [a2, b2] ⊆ [a1, b1] Λ Σ1 = Σ2 Λ x = μ2 — μ1
=
⎩ T	otherwise
where c ranges over N.
The interesting case is the last one, which identifies loops whose variables are only incremented or decremented by a constant value. This occurs when the covari- ance matrix is unmodified, meaning that the variables have only been shifted by a constant amount. We can extend this to detect other types of loop activity (for example, a multiplicative update), but that is beyond the scope of this paper.
Stage 3 – Abstract Collecting Semantics
We conclude this paper with a brief discussion of the abstract collecting semantics. As we have seen, our memoised abstract interpretation associates a set of measures to each state in the abstract semantics. We are not interested in the set itself, however, but in the sum of the measures it contains. Thus our collecting semantics can be seen as a way to safely approximate this sum to a measure that is easier to compute. This need not be a truncated multivariate normal measure as the result of this final stage of analysis is not needed for further computation.
At present, the only general solution we have is a numerical one. To compute an upper bound of the measure on a particular interval [a, b], we iteratively sum all the measures in the set, applied to this interval. Although the set of measures will in general be infinite, we note that the iterated sum will quickly converge as the residual probability mass exponentially decreases. It is easy to calculate such measures from a truncated multivariate normal measure, by performing eigenvalue decomposition to separate it into independent truncated normal measures. This loses some precision, since we over-approximate the truncation interval, but it is a safe approximation.
Analytical solutions certainly exist, where we compute a single measure as an

upper approximation, but we have yet to find one that is both computationally easy to compute, and gives a satisfactory precision in general.

Conclusions
In this paper, we presented an abstract interpretation of a probabilistic automaton semantics for a simple imperative language. We believe that this work is comple- mentary to other approaches to probabilistic abstract interpretation, allowing an efficient approximation to the behaviour of programs whose input is governed by a probability distribution. There is clearly some way to go in terms of improving this approach, for example finding a better abstract collecting semantics and a greater range of widening operators. We also need to carry out some larger case studies, to investigate the precision of the bounds in comparison to other methodologies.
The ultimate aim of this work is to provide a formal framework for the ideas presented in [8], where we attempt to derive stochastic models of communication protocols directly from source code. The advantage of abstract interpretation is that it can be easily automated, and therefore fits in well with the aim of providing tools that can be used by real developers. We feel that the abstract interpretation presented in this paper is an important milestone towards this goal.

References
P. Cousot and R. Cousot. Abstract interpretation: A unified lattice model for static analysis of programs by construction or approximation of fixpoints. In POPL ’77: Proceedings of the 4th ACM SIGACT- SIGPLAN symposium on Principles of programming languages, pages 238–252. ACM, 1977.
W. C. Horrace. Some results on the multivariate truncated normal distribution. In Journal of Multivariate Analysis, volume 94, pages 209–221, 2005.
D. Kozen. Semantics of probabilistic programs. Journal of Computer and System Sciences, 22(3):328– 350, 1981.
D. Monniaux. Abstract interpretation of probabilistic semantics. In Seventh International Static Analysis Symposium (SAS’00), number 1824 in Lecture Notes in Computer Science, pages 322–339. Springer-Verlag, 2000.
A. Di Pierro, C. Hankin, and H. Wiklicky. Quantitative static analysis of distributed systems. Journal of Functional Programming, 15(5):703–749, 2005.
A. Di Pierro and H. Wiklicky. Probabilistic abstract interpretation and statistical testing. In PAPM- PROBMIV, pages 211–212, 2002.
D. Schmidt. Abstract interpretation in the operational semantics hierarchy. Technical report, Kansas State University, 1997.
M. J. A. Smith. Stochastic modelling of communication protocols from source code. In Proceedings of the 5th Workshop on Quantitative Aspects of Programming Languages (QAPL), 2007.
Y. L. Tong. The Multivariate Normal Distribution. Springer-Verlag, 1990.
