	Electronic Notes in Theoretical Computer Science 176 (2007) 125–141	
www.elsevier.com/locate/entcs

Local Module Checking for CTL Specifications
Samik Basu1
Department of Computer Science Iowa State University
Ames, USA
Partha S Roop, Roopak Sinha2 ,3
Department of Electical and Computer Engineering University of Auckland
Auckland, New Zealand

Abstract
Model checking is a well known technique for the verification of finite state models using temporal logic specification. While model checking is suitable for transformational systems (also called closed systems), it is unsuitable for open systems (also known as reactive systems) where the nondeterminism in the environment must be considered during verification. Module checking is an approach for the verification of open systems which have both closed (internal) and open (environment or external) states. It has been demonstrated in [10] that the complexity of module checking branching time logic CTL is EXPTIME-complete. The approach to module checking is global and the method tries to establish that the property in question holds over all possible environments.
This papers develops a local approach to CTL module checking using tableau rules. The proposed approach tries to determine a single environment under which the negation of the property is satisfied over the given module. Such a strategy, thus, leads to a local approach to module checking where we only explore states that are relevant to proving that the negation of the property can be satisfied over the given module using an appropriate witness (environment) that the algorithm also generates. While the worst case complexity of our algorithm is identical to the earlier complexity, we demonstrate that practical implementation of the proposed approach is feasible and yields much better results than the global approach.
Keywords: module checking, open systems, tableau based verification


Introduction
Reactive systems [7,13] are open systems that continuously interact with their en- vironment while executing a non-terminating control program. Examples include

1 Email: sbasu@cs.iastate.edu
2 Email: p.roop@auckland.ac.nz
3 Email: rsin077@ec.auckland.ac.nz

1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2006.02.035

operating systems, communication protocols, missile and avionics systems and con- trollers for nuclear plants and simple home appliances such as microwaves, DVD players and washing machines. Such applications require careful analysis, design and validation techniques as they can often be safety critical. Hence, formal tech- niques have often been used in the design, development and validation of these systems [16,11,5,6,3,12,15]. Formal techniques use precise syntax and semantics for defining specifications and models of systems so that rigorous verification of properties such as correctness, reliability and security is made possible.
With the advent and widespread use of embedded systems, which are ubiquitous reactive computing systems ranging from simple home appliances to very complex applications in avionics and defense, the need for formal methods in the design of reactive systems is growing. One very common approach to verification of reac- tive systems has been model checking. A model checker takes a formula in some temporal logic [14] as a desirable property and performs formal analysis over a finite- state model of a system (called a Kripke structure [3], a special class of finite state machines). The model checking process is essentially an automated reachability analysis task over the finite state model of the system. This task either terminates with a proof that the temporal property holds over the model or on failure generates a counter example.
The model checker, during the reachability analysis phase, assumes that all transitions out of any given state of a model is eventually enabled. This assumption is based on the fact that the model is considered to be closed i.e., all states of the system are purely internal and that it is the system that gets to choose which transition to take based on some internal computation. This approach to analysis, while being suitable for transformational systems which are closed, are unsuitable for reactive systems that are open.
An open system maintains an ongoing interaction with its environment. Hence, the state-space of such a system may be partitioned into a set of states that are open (also called external or environment states) and another set of states that are closed (also called internal or system states) [8,9]. An environment state reacts to events in the external environment of the open system and the environment is considered asynchronous and uncontrollable. A system state, on the other hand, takes no inputs from the external environment and the system automatically chooses one of the transitions based on some internal decision (such as say the value of a variable or the result returned by a function). Kupferman et al. have recently shown that model checking may not be enough for open systems due to the presence of environment states and when branching formulas are considered in the specification [9]. The proposed technique, called module checking, takes the asynchronous environment into account while doing a proof for branching-time logics. [6,5] further discuss techniques devoted to issues concerning verification of open systems.
This paper illustrates the need for module checking reactive systems and pro- poses an alternate approach to module checking that has efficient implementation avenues compared to the original approach. We first illustrate the need for module checking followed by our approach to local module checking.

Motivating Example - The Coffee Brewer Veriﬁcation Problem
Consider a simple coffee brewer model as depicted in the Figure 1. In this figure, environment states are shown using elipses whereas system states are drawn as circles. Each transition out of any state is marked by a natural number starting with 1. The brewer serves either ﬁve or ten cups of coffee in either medium or strong flavor. A user can select the number of cups of coffee (using a switch as an input) and the strength of coffee (using another switch). The brewer is normally in the off state until the switched on. Hence, the initial state labeled by the proposition OFF is an environment state. Once the brewer is switched on, it enters a state labeled by the proposition CHOOSE. This is again an environment state. In this state, the user can select the number of cups of coffee and the strength of coffee. Depending on the selection (two switches lead to four different possibilities), the brewer enters any one of the following states: (f ive, medium), (f ive, strong), (ten, medium) or (ten, strong). Once the selections have been made and the corresponding state has been reached, the brew cycle switch has to be switched on to start the brewing. Hence all the above four states are also environment states. Once the brew cycle is set, the brewer makes a transition to a state labeled BREW . This state is a system state since no inputs from the environment is required to make progress. From the BREW state, the brewer makes an automatic transition to the DONE state after a predetermined time period (which is the amount of time taken by the brewing process). The state labeled DONE is also a system state since the brewer takes one of two possible branches based on some internal condition. If any error is detected (say not enough coffee or no milk power), then a transition is made to an error state (labeled by ERROR). Alternatively, the brewer can reach a state labeled SERV E where the actual coffee selected is served.
CTL is a branching time temporal logic that has been shown to be quite efficient for model checking. Let us consider the following CTL property:
AGEF (TEN ∧ AF (SERV E ∨ ERROR)) which demands that from any state one can possibly eventually select ten cups of coffee and once selected, ten cups will always be served (or an error encountered) in the future.
Note that a model checker will always return a true answer for this question. However, consider the following situation. Due to cost cutting in the work place where the brewer is installed, brewing ten cups of coffee at a time is not allowed (this has been enforced through a circular and the ten cups switch is masked). Hence, no user will be allowed to make this selection from the CHOOSE state. Thus, it will not be possible to guarantee the selection of ten cups of coffee and hence the property fails to hold over the coffee brewer model. This property could also be violated if all users request five cups of coffee or tea (and no users request ten cups of any beverage). In this case, even though the machine is capable of dispensing ten cups of tea or coffee, the environment in which it operates effectively disables it from doing that.
This property illustrates that due to the presence of environment states, it may not be always possible to satisfy branching time temporal properties. As the envi- ronment of an open system is asynchronous and hence uncontrollable, the environ-



Fig. 1. The coffee brewer example
ment may never enable some desired transitions leading to failure of the property. This example thus motivates the module checking problem: how do we ensure that a given property holds over a known module (a model with environment and system states) assuming an uncertain environment. The basic idea in module checking is to prove that the property holds over all possible choices made in the environment states. In other words, the module checking problem is to decide if a CTL formula ϕ holds over a module M provided for all possible environments E such that M×E  satisfy ϕ. Here, M× E denotes the composition of the model and the environment running in parallel (to be formalized later).
This may be expressed as follows: module checking, denoted by M |=o ϕ, there- fore, amounts to deciding whether ∀E.M× E |= ϕ; i.e.
M |=o ϕ ⇔ ∀E .M× E |= ϕ	(1)
It has been shown in Kupferman et al. [10] that the module checking problem for the temporal logic CTL is EXPTIME-complete unlike the polynomial complexity for the model checking problem. The reason for this complexity may be intuitively seen from the above equation since the proof has to be carried out for all possi- ble environments. This is unlike model checking, where the system is closed and hence the reachability proof proceeds without considering any nondeterminism in the environment.
While this sounds like bad news, a practical implementation of module checking is possible by the following observation.
Proceeding further, from Equation 1 we state that
M |=o ϕ ⇔ ∃E'.(M× E' |= ϕ ⇔M × E' |= ¬ϕ)	(2)

In the above, the negation on ϕ can be pushed inside the formula such that all tem- poral and boolean operators are free from negation. Furthermore as the existence of E' ensures that M |=o ϕ, E' acts as a witness to the violation. Such a witness can be used to provide useful insights to the reason for violation of a desired property over an open systems. The main beauty of this procedure is that we are looking for only one environment using which we can prove that the formula is not satisfied. We will illustrate later that we can employ a set of tableau rules to perform the computation of E' locally. This local computation is similar to on-the-fly model checking [1] where the state space of the system under verification is constructed on a need-driven basis. Even though the worst case complexity of local module checking is still bounded by the results of [10], we demonstrate that the proposed approach to local module checking yields much better practical results. The main contributions of this paper are:
We propose a set of sound and complete tableau rules for local module checking. The proposed approach determines a single witness (environment) so that un- der the witness the negation of the given CTL property is satisfied. The proof proceeds only along a local set of states that are needed for the generation of a witness.
We have developed a local module checker by extending NuSMV [2]. Local module checking has been compared with the generation of the maximal envi- ronment under which the given CTL property is satisfied to demonstrate the performance gain of the proposed approach. The benchmarks are examples from NuSMV with both environment and system states.
The rest of this paper is organized as follows. Section 2 presents fundamental theory. Section 3 formulates CTL local module checking and presents the tableau rules for both system and environment states. Section 4 describes the implementa- tion of a local module checker and section 5 contains the results obtained from it. Concluding remarks follow in section 6.

Preliminaries
Kripke Structure.
System behavior is described using Kripke structure M = (S, s0, →, P, L), where S is the set of states, s0 ∈ S is the start state, →⊆ S × S is the set of transition relations, P is the set of propositions relevant to M and finally, L : S → 2P is the labeling function mapping each state to set of propositions.

Temporal logic: CTL.
Properties of the system are defined using branching time temporal logic CTL. A CTL formula is defined over a set of propositions using temporal and boolean operators as follows:
φ → P | ¬P | tt | ff | φ ∧ φ | φ ∨ φ | AXφ | EXφ | A(φUφ) | E(φUφ) | AGφ | EGφ

Note that CTL in general allows negations on temporal and boolean operators. However, we restrict ourselves to verifying CTL formulas where negations can only be applied to propositions.
Semantics of CTL formula, ϕ denoted by [ϕ]]M is given in terms of set of states in Kripke structure, M , which satisfies the formula. See Fig. 2.
[[p]]M ={s | p ∈ L(s)}
[[¬p]]M ={s | p /∈ L(s)}
[[tt]]M =S
[[ff]]M =Φ
[[ϕ ∧ ψ]]M =[[ϕ]]M ∩ [[ψ]]M
[[ϕ ∨ ψ]]M =[[ϕ]]M ∪ [[ψ]]M
[[AXϕ]]M ={s|∀s → s' ∧ s' ∈ [[ϕ]]M }
[[EXϕ]]M ={s|∃s → s' ∧ s' ∈ [[ϕ]]M }
[[A(ϕU ψ)]]M ={s|∀s = s1 → s2 → ... ∧ ∃i, j.sj |= ψ ∧ ∀i < j.si |= ϕ}
[[E(ϕU ψ)]]M ={s|∃s = s1 → s2 → ... ∧ ∃i, j.sj |= ψ ∧ ∀i < j.si |= ϕ}
[[AGϕ]]M ={s|∀s = s1 → s2 → ... ∧ ∀i.si |= ϕ}
[[EGϕ]]M ={s|∃s = s1 → s2 → ... ∧ ∀i.si |= ϕ}

Fig. 2. Semantics of CTL

A state s ∈ S is said to satisfy a CTL formula ϕ, denoted by M, s |= ϕ, if s ∈ [[ϕ]]M . We will omit M from |= relation and [ ] if the model is evident in the context. We will also say that M |= ϕ iff M, s0 |= ϕ. The complexity for model checking M against a CTL formula ϕ is O(|M |× |ϕ|) where |M | and |ϕ| are size of the model and the formula respectively.

Module Checking.  [8]
In contrast to model checking where all transitions in every state of the model are always enabled, module checking is specifically directed for verification of models of open systems with states where the environment decides which transitions are enabled. Typically, in models of open systems, modules in short, the states are partitioned into two sets Ss and Se where Ss consists of system states with all outgoing transitions enabled while Se is the set of environment-controlled states where some (at least one) transitions are enabled. Note that, the environment can enable one or more transitions but cannot disable all transitions.
[10] presents the complexities for module checking in the setting of different temporal logic. While LTL module checking problem has the same complexity as LTL model checking, module checking branching-time temporal logics (CTL, CTL*)

is harder compared to corresponding model checking. It has been proved that the problem of module checking is EXPTIME-Complete for CTL and 2EXPTIME- complete for CTL* specifications.

Tableau-based CTL Module Checking
In this paper, we present a technique for module checking CTL specifications such that the state-space of the module is explored locally and on-the-fly, i.e. our tech- nique only explores the states needed to (dis)satisfy a given CTL formula.
We consider the behavior of a module M in the context of an environment E such that at each system state of M, the environment is incapable of altering the behavior of the module while at each environment state, the environment can decide which transitions to enable. To address such restrictions on the interaction, the behavioral patterns of M and E are described using labeled Kripke structure defined as follows:
Definition 3.1 [Labeled Kripke Structure] A labeled Kripke structure LKS = (S, s0, →, P, L,K) where S, s0, P,L are defined as before, K is the maximum out- going branching factor of states in S and →⊆ S × {1, 2,... , n}× S with n ≤ K.

The state set S of a module may be partitioned into two subsets, Se, the set of all environment states and Ss, the set of all system states. In the above, each transition is annotated by a branching identifier whose domain is equal to the maximum

branching factor. We will write s →i
s if (s, i, s') ∈→.
s' to denote the i-th out-going transition from

Definition 3.2 [Parallel Composition] Given a module M = (SM, s0 , →M
, PM, LM,K), its environment E = (SE , s0 , →E	E	E	M
E	,P ,L ,K), their parallel compo-
sition resulting in M× E ≡ P = (SP , s0 , →P , PP , LP ,K) are defined as follows
SP ⊆ SM × SE

s0
P
= (s0
M
, s0 )
E

PP = PM ∪ PE
LP (s1, s2)= LM(s1) ∪ LE (s2) where s1 ∈ SM and s2 ∈ SE

(s ,s ) →i	(s' , s' ) if s →i	s' and s →i	s' where s , s' ∈ S
and s , s' ∈

1	2	P	1	2
SE
M  1
E  2
1	1	M	2	2

Furthermore, following constraints are imposed to restrict E
System-state conformity. if s1 is a system state then ∀s1 →i M s' ⇒ ∃s2 →i E
s'2 and vice versa.
Environment-controllability. if s1 is an environment-controlled state then

∃s2 →i E
s'2 ∧ (∀s
j
2 →E
s2''
⇒ ∃s
j
1 →M
s1'')



Given a CTL formula ϕ, we say that M× E  ≡ P  |= ϕ  ⇔ s0
|= ϕ. Module

checking, denoted by ł |=o
P
ϕ, therefore, amounts to deciding whether
∀E.M×E |=

reorg   ss|e |= {ϕ1,...,ϕn}	
ss|e |= ϕ1 ... ss|e |= ϕn

prop ss|e |= p p ∈ L(ss)	Λ 	ss|e |= ϕ1∧ϕ2	

.

V1 ss|e |= ϕ1∨ϕ2
ss|e |= ϕ1

unreu 	ss|e |= E(ϕUψ)	
ss|e |= ψ∨(ϕ∧EXE(ϕU ψ))

unreg 	ss|e |= EGϕ	 ss|e |= ϕ∧EXEGϕ
ss|e |= ϕ1	ss|e |= ϕ2
V2 ss|e |= ϕ1∨ϕ2
ss|e |= ϕ2

unrau 	ss|e |= A(ϕUψ)	
ss|e |= ψ∨(ϕ∧AXA(ϕU ψ))

unrag 	ss|e |= AGϕ	
ss|e |= ϕ∧AXAGϕ



unr


ss|e |= EXϕ
⎧⎨ si ∈ NS = {sI |s →I

M sI }, sj,...,k

∈ NS — {si}

ss,ex
si ei = ϕ, sj ej =tt...sk ek =tt
i,j,...,k
∈ NSe
= {eI |e →I E
eI }

unrs ,ax 	ss|e |= AXϕ	 61 ≤ i ≤ k.ss →i	si Λ e →i	ei
s	s1|e1 |= ϕ ... sk|ek |= ϕ	M	E
Fig. 3. Tableau Rules for Module Checking System States
ϕ; i.e.
ł |=o ϕ e 6S .ł× S |= ϕ	(3)
Proceeding further, from Equation 3 we state that
ł |=o ϕ e ES'.(ł× S' |= ϕ eł × S' |= чϕ)	(4)
It is important to note however that ł |=o ϕ /⇒ł |=o чϕ. It can be shown that a module does not satisfy both a formula and its negation 4 . A module might satisfy a formula and its negation under different environments. For example: given ł =

({s0, s1, s2}, s0, {s0 →1
s1, s0 →2
s2, s1 →1
s1, s2 →1
s2}, {p}, L, 2}) where L(s1)= {p}

and CTL formula AXp, it is easy to see that ł |=o AXp and ł |=o EXчp.
3.1 Local Module Checking and Generation of Witness
We present here a tableau-based technique similar to [4] for constructing the witness environment S, existence of which ensures that the module does not satisfy original formula. Tableau rules are defined as
Antecedent Consequent
where the Antecedent represents the current obligation for module checking and Consequent denotes the next obligation. A successful tableau (see below) will result in automatic generation of the environment S. Figs. 3 and 4 present the complete tableau where the former corresponds to the rules for system states and the latter for the environment-controlled states.

4 Note that the same is not true for model checking problem: M |= ϕ ⇔ M |= ¬ϕ







emp  se|e |={}
reorg  se|e |= ϕ 
se|e |= {ϕ}

prop se|e |= {p,C} p ∈ L(se)
se|e |= C



Λ se|e |= {ϕ1∧ϕ2,C}
se|e |= {ϕ1,ϕ2,C}
V1 se|e |= {ϕ1∨ϕ2,C}
se|e |= {ϕ1,C}
V1 se|e |= {ϕ1∨ϕ2,C}
se|e |= {ϕ2,C}



unreu 	se|e |= {E(ϕUψ),C}	
se|e |= {(ψ∨(ϕ∧EXE(ϕU ψ))),C}

unreg 	se|e |= {EGϕ,C}	
se|e |= {ϕ∧EXEGϕ,C}
unrau 	se|e |= {A(ϕUψ),C}	
se|e |= {(ψ∨(ϕ∧AXA(ϕU ψ))),C}

unrag 	se|e |= {AGϕ,C}	
se|e |= {ϕ∧AXAGϕ,C}

⎧ Cax = 
⎪

AXϕk∈C ϕk



unrse



se|e |= C


∃π⊆Π. ∃ΠCex (π). ∀i∈π. si|ei|=Cax∪Ci
Cex =  EXϕl C ϕl
⎪⎨ Π= {i | se →i M si}
⎪ ΠCex (π)= {Ci | i ∈ π ⊆ Π Λ Ci ⊆ Cex}
⎪⎩  i:Ci∈ΠCex (π) Ci =Φ 

Fig. 4. Tableau Rules for Module Checking Environment States

Tableau for System States.  Consider first the Fig. 3 (without the reorg rule). The rules for prop, Λ, Vs are simple and intuitive. The prop rule leads to a successful tableau leaf, the Λ rule is successful if both its consequents are successful and finally, the success of V-rule depends on the success of any of its consequents. The rule unreu corresponds to unrolling of the EU formula expression. A state satisfies E(ϕU ψ) iff (a) ψ is satisfied in the current state or (b) ϕ is true in the current state and in one of its next states E(ϕU ψ) is satisfied. The rule for unrau is similar to unreu with exception of the presence of universal quantification on the next states (AX). The rule unreg (unrag) states that the current state satisfies ϕ and in some (all) next state EGϕ (AGϕ) holds true.
Finally, the rules for unrss,ex and unrss,ax correspond to the unfolding of the state and the formula expression simultaneously. Note that in the former, we are searching for at least one next state, while in the latter all next states should satisfy ϕ. As such for the EX-formula expression, the tableau selects any one of the next states si|ei and if the selected state satisfies ϕ, there is no obligation left for the rest of the next states; the obligations on the remaining next states sj,...,k in the context of the environment is to satisfy tt 5 (any state satisfies the propositional constant tt ). Note that, the tableau can potentially have k sub-tableaus for unrss,ex each of which will correspond to selection of one next state si from the set of k next states

5 For the purpose of constructing the environment, in Rule unrss,ex, we can safely assume that all the environment states ej...,k replicates the behavioral patterns of module states sj...,k.

of ss.
Observe that, the rules unrss,ex, unrss,ax lead to one-step construction of the environment. Conforming to the constraint that the environment at the system state cannot control the enabled transition, the environment must have exactly the same number of transitions as the system state.
Tableau for Environment-Controlled States. The tableau rules (Fig. 4) for environ- ment controlled states are slightly different from the one described above. Instead of asking whether a state satisfies a formula expression (see Fig. 3), the question asked is whether a state satisfies a set of formula expressions. In fact the set represents a formula expression equivalent to conjunction over its elements. The reason for altering the tableau rule structure stems from the fact the environment plays an ac- tive role in deciding the enabled transitions. For example: in order to construct an environment state e such that se|e |= ϕΛψ, we need to construct e1 and e2 such that se|e1 |= ϕ and se|e2 |= ψ with the constraint that e1 = e2, i.e. exactly the same set of transitions is enabled to module check ϕ and ψ at the state se. To address to this state of affairs, the tableau rules for environment-controlled state maintains a global view of all the formula to be satisﬁed and ensures consistent enabling/disabling of transitions by the environment (to be constructed).
The rules for prop, V, unreu, unrau, unreg, unrag in Fig. 4 are similar to that in Fig. 3. The rule for Λ aggregates all the conjuncts in the set. The emp-rule represents the case the state does not have obligation to satisfy any formula and a (successful) tableau leaf is reached. The rule unrse is applied only when no other rules are applicable. In other words, the set C only contains EX and/or AX formula expressions. Cax is the set of all formula expressions that must be satisfied in all next states while Cex is the set of the formula expressions each of which must be satisfied in at least one of the next states. Π records all the indices of the outgoing transitions from se, while ΠCex (π) is a subset of Cex such that there is at least one subset for each i present in a subset π ∈ Π. For example, if π is a singleton set, then ΠCex (π) is also a singleton set containing Cex. In short, ΠCex (π) is used to associate with i-th selection of next state-environment pair a set of elements Ci ⊆ Cex. The consequent of the rule, therefore, fires the obligation that all states identified by the indices in π must satisfy Cax and the corresponding subset of Cex as identified by ΠCex (π).
This rule is illustrated by Fig. 5. All states in the Fig. 5(a) are environment states and the proposition p is true at states s1, s4, and s6. The obligation at s0|e0 is to satisfy C = {AXEXp, EXEXчp, EXp}. As there are 3 transitions from s0 there are 23 —1 = 7 different choices for π. Fig. 5(b) shows subsets consisting of only 1 and 2. π represents the indices of enabled transitions. These transitions lead to states which must satisfy all the elements of Cax = {EXp}. Corresponding to each π, there exists at least one choice for ΠCex (π) which subsets Cex = {p, EXчp} in |π| subsets where |π| is the size of π. It also assigns each subset to different subset of next states where elements of the assigned subset must be satisfied. For example for π = {1, 2}, there are two possible ways of assigning subsets of Cex to s1|e1 and s2|e2 (see Fig. 5(b)). In this example, we obtain an environment e0 for π = {1, 2} (i.e.

Antecedent: s0|e0 |= C  Cax = {EXp}, Cex = {p, EX¬p}
	
(a)	(b)
Fig. 5. Illustration of unrse tableau rule
the transition labeled 3 from s0 is disabled), and ΠCex (π)= {{p}, {EXчp}}. Note that, our local approach does not necessarily examine all possible choices for π and the corresponding subsets ΠCex (π); instead it terminates as soon as an environment that leads to satisfiability of given formula is obtained.
Finally, consider the reorg (re-organize) rules in Figures 3 and 4. These rules rearrang the formula obligations from set-based to expression-based or vice versa depending on the type of the model state being considered.
Finitizing the Tableau. The given tableau rules can be of infinite depth as each recursive formula expressions AU, EU, AG, EG are unfolded infinitely many times. However, the total number of states in the Kripke structure for the module is N = |S|, and this finitizes the tableau depth. In Fig. 3, if the pair (ss, ϕ) in ss|e |= ϕ, where ϕ is either EG or AG formula expression, appears twice in a tableau path, we fold back the tableau by pointing the second occurrence to the first and stating a successful tableau loop is obtained. Note that this also leads to generation of a loop in the constructed environment. On the other hand, if the pair (ss, ϕ), where ϕ is of the form EU or AU , appears twice, the second occurrence is classified as an unsuccessful tableau leaf and is replaced by ff.
The idea of folding back or replacing using false relies on fixed point semantics of CTL formulas. The CTL formulas EG and AG can be represented by greatest fixed point recursive equations:
EGϕ ≡ Z =ν ϕ Λ EXZ	AGϕ ≡ Z =ν ϕ Λ AXZ
In the above ν represents the sign of the equation and is used to denote greatest fixed point and Z is recursive variable whose valuation/semantics (set of model states) is the greatest fixed point computation of its definition. Similarly the fixed point representation of CTL formulas AU and EU are
E(ϕU ψ) ≡ Z =μ ψ V (ϕ Λ EXZ)	A(ϕU ψ) ≡ Z =μ ψ V (ϕ Λ AXZ)
The fixed point computation proceeds by iteratively computing the approxima- tions of Z over the lattice of set of states in the model. A solution is reached only when two consecutive approximations are identical. For greatest fixed point com- putation, the first approximation is the set of the all states (top of the lattice) and

as such a system can satisfy a greatest fixed point formula along an infinite path (using loops). On the other hand, the first approximation of the least fixed point variable is empty set (bottom of the lattice) and therefore satisfiable paths for least fixed point formula are always of finite length.
For the tableau in Fig. 4, the finitization condition is similar. If the pair (se,C) in se|e |= C, appears twice in a tableau path and if C contains any least fixed point CTL formula expression, then the second occurrence is replaced by ff ; otherwise the second occurrence is made to point to the first and a successful tableau is obtained.
Theorem 3.3 (Sound and Complete) Given a module ł and CTL formula ϕ, ł |=o ϕ, iff the tableau in Figures 3 and 4 generates an environment S where ł× S |= чϕ.
Proof. The proof proceeds by realizing the soundness and completeness of each of the tableau rules. For brevity, we present here the proof-sketch for unrse , proofs for the other rules are straightforward.
Recall that, se|e |= C, where C is the set of formula expressions with temporal operators AX and EX, is satisfiable if the next states proof obligations are satisfied by destination states reachable via transitions enabled by the environment e. The environment can enable any subset (barring ∅) of transitions. The tableau rule, therefore, considers all possible subset of destination states of enabled transitions. As each transition is annotated by an index (whose domain is over the out-going branching factor of se), we construct Π, the set of indices of out-going transitions. In other words, i ∈ Π ⇒ si is reachable via the transition with index i. We are required to identify one possible subset of Π which represents the enabled transitions whose destinations conform to the satisfiability obligations in the consequent (see Eπ ⊆ Π in the consequent). Let πs = {si | i ∈ π} be the next states reachable via
(selected) enabled transitions.
The consequent of the tableau rule has the following obligations. All elements of πs in parallel composition with the environment must satisfy the expressions in Cax and for each formula expression ϕ in Cex, there must be at least one state which in conjunction with the corresponding environment satisfies ϕ. Observe that, there is requirement for an existence of a subset, ΠCex (π), of Cex corresponding to a subset π such that next state-environment pairs satisfy the corresponding obligations. This ensures that the environment constructed is consistent, i.e., ei is constructed such that si|ei satisfies both the for all obligations (Cax) and its share of existential obligations (Ci). Therefore, if we can generate an environment for se corresponding to rule unrse , then se |=o ψ where ψ is the disjunction of the elements of the set
{AXчϕ | ϕ ∈ Cex}∪ {EXчψ | ψ ∈ Cax}. The other direction can be proved likewise.	 

Complexity.
The main factor in complexity is attributed to the handling of universal and existential formulas in unrse rule in Fig. 4. The number of different obligations that can be fired on the basis of each selection of π ⊆ Π, is O(2|Cex |×|π|) where |Cex|



Fig. 6. The witness environment for the coffee brewer example

and |π| are respectively the size of the respective sets. This is because we need to consider all possible permutations of elements of Cex and match the permutations with all possible permutations for selecting element from π. Overall complexity is, therefore, exponential to the maximum branching factor (maximum size of π) of the module times the size of the formula to be satisfied. It is worth noting here that if the given formula is free from EX and EU , the complexity of tableau-based approach will be polynomial to the sizes of the formula and module (same as model checking). This is due to the fact that in the presence of only AX-formulas in rule unrse , we are only required to find one element from Π; the state corresponding to which satisfies Cax.
Figure 6 shows the witness environment generated for the coffee brewer in Fig- ure 1. The witness environment disables three transitions of state s1 such that there is no path where ten cups can be selected. Under this witness, it can be shown that the model does not satisfy the original property AG E(tt U TEN Λ AF (SERV E V ERROR)).

Implementation
A local module checking tool has been implemented using C/C++ and many SMV benchmarks from the NuSMV package have been tested. The tool proceeds as follows:
An SMV model is converted into an explicit state FSM using NuSMV. This is achieved by traversing the model’s state space in NuSMV and writing all reachability information (states, transitions and labels) to a file. As there is no explicit notion of system/environment states in NuSMV, the state space is di- vided randomly into two sets of equal size representing system and environment states respectively.
The file containing the explicit state FSM is read by the tool along with the

CTL property to be used for verification.
The CTL property is negated and the negation is carried inwards. CTL prop- erties can not have negations applied to formulas other than propositions.
A search for a witness is carried out, starting with the initial state, and the tool attempts to generate an environment under which the module satisfies the negated CTL property. If a witness is present, then the module does not satisfy the original property.
The algorithm applies the appropriate system or environment state tableau rules on the current state. Once all present (current-state) commitments are met, any future commitments are passed to its successors. It uses a heuristic to compute a small set of successors of the current state which satisfy all its future commitments. This is used to ensure that the generated witness is small. If no witness can be computed, it can be concluded that the module satisfies the CTL property. Note that the algorithm attempts to generate a small witness and not the minimal witness for a given property and module. In order to compare the obtained results, the tool was extended to find an environment under which the original CTL property is satisfied. This is achieved as follows:
The CTL property (non-negated) is read along with the module FSM (as above).
The algorithm attempts to find an environment under which the given CTL property is satisfied by traversing all of the reachable state space.
It is important to note here that the above is not an implementation of global module checking. Global module checking advocates the need to check if the given property is satisfied by the module under all environments. However, the above approach constructs only a single environment under which the given CTL property is satisfied by the module. However, unlike the local module checker which attempts to generate a small witness, the algorithm for global module checking constructs the biggest environment under which the module satisfies the given property. This is done by enabling all but those transitions in reachable environment states which may lead to the dissatisfaction of the given property. It was observed that on the average, computing the maximal environment under which the original CTL property is satisfied consumes more time than computing a small witness under which it fails.
The problem of computing all possible environments (global module checking) is even more harder and time consuming and the benefits of local module checking will be even more apparent in such a case.

Experimental Results
The results are given in table 1. The first column contains the name and size (in number of states) of the verified module and the CTL property used is given in the second column. The results obtained from local module checking are presented in


Table 1 Implementation Results

the third column. The fourth column contains the results of generating the maximal environment under which the given CTL property is satisfied 6 .
Note that for many modules, the original property and its negation were both satisfied under different environments. A majority of models had multiple start states. In these cases, the local module checker (and the maximal witness generater) was executed on each start state. Models with dense transition relations such as dme1 and syncarb5 took significantly more time. Models with relatively sparse transitions relations such as abp4 and idle took lesser time even though they had a higher number of reachable states. The local module checker took slightly longer when the original CTL formula was satisfied by the module (abp4, pqueue, periodic).

Conclusions
Module checking extends model checking for open systems. It has been shown in [10] that the complexity of module checking for branching time logic CTL is EXPTIME complete. The above approach to module checking generates all possible environments so that the composition of the model and the environment satisfies the CTL property. In this paper we propose a local approach to CTL module checking. The proposed approach tries to determine a witness environment so that the negation of the property is satisfied by the composition of the witness and the model. When this is possible, the original property is not satisfied over the module. We have developed a set of sound and complete tableau rules for local

6 The results are in format TimeTaken(seconds)/Result(SUCCESS or FAILURE)/Number of disablings (Number of states traversed locally during local module checking).

module checking of CTL. The efficiency of the proposed approach is demonstrated by comparing the performance of local and traditional global module checking using benchmarks from NuSMV. The results presented compare the generation of one environment in both cases. Answering the module checking question using a global strategy requires the generation of all environments, which will be computationally much more expensive than the local approach.

References
Girish Bhat, Rance Cleaveland, and Orna Grumberg. Efficient on-the-fly model checking for CTL*. In Proceedings of the Tenth Annual Symposium on Logic in Computer Science, pages 388–397, June 1995.
R. Cavada, Alessandro Cimatt, E. Olivetti, M. Pistore, and M. Roveri. NuSMV 2.1 User Manual, June 2003.
E. M. Clarke, O. Grumberg, and D. Peled. Model Checking. MIT Press, 2000.
R. Cleaveland. Tableau-based model checking in the propositional mu-calculus. Acta Informatica, 27(8):725–748, 1990.
Matthew B. Dwyer and Corina S. Pasareanu. Filter-based model checking of partial systems. In
Foundations of Software Engineering, pages 189–202, 1998.
Patrice Godefroid. Reasoning about abstract open systems with generalized module checking. In
EMSOFT’2003 (3rd Conference on Embedded Software), pages 223–240, 2003.
D. Harel. Statecharts : a visual formalism for complex systems. Science of Computer Programming, 8:231–274, 1987.
O. Kupferman and MY. Vardi. Module checking [model checking of open systems]. In Computer Aided Verification. 8th International Conference, CAV ’96, pages 75–86, Berlin, Germany, 1996. Springer- Verlag.
Orna Kupferman and Moshe Y. Vardi. Module Checking Revisited. In CAV, 1997.
Orna Kupferman, Moshe Y. Vardi, and Pierre Wolper. Module checking. Information and Computation, 164:322–344, 2001.
Z. Manna and A. Pnueli. A temporal proof methodology for reactive systems. In Program Design calculi, NATO ASI Series, Series F: Computer and System sciences. Springer-Verlag, 1993.
Doron A. Peled. Software Reliability Methods. Springer-Verlag, 2001.
A. Pnueli. The temporal logic of programs. In 18th IEEE Symp. found. Comp. Sci. (FOCS), 1977.
A. Pnueli. A temporal logic of concurrent programs. Theoretical Computer Science, 1981.
P. S. Roop and A. Sowmya. Forced simulation: A technique for automating component reuse in embedded systems. In ACM Transactions on Design Automation of Electronic Systems, October 2001.
M. Y. Vardi. Verification of concurrent programs: The automata theoretic framework. In 2nd IEEE Symp. on Logic in Computer Science, 1987.

Appendix
Example. Table 2 describes the steps involved in generating a witness environ- ment for the coffee brewer example in Figure 1. First, the original CTL property AG E (tt UTEN Λ AF (SERV E V ERROR)) is negated (and the negation carried inwards) to E(tt U AGчTEN V AG(чSERV E Λ чERROR)). The local module checker is then called on the initial state (s0) of the model along with the negated

s0|e0 |= {E(tt U AG¬TEN ∨ AG(¬SERV E ∧ ¬ERROR))}

s0|e0 |= {AG(¬TEN ∨ AG(¬SERV E ∧ ¬ERROR)
∨ (tt ∧ EXE(tt U AG¬TEN ∨ AG(¬SERV E ∧ ¬ERROR)))}
s0|e0 |= {AG(¬TEN ∨ AG(¬SERV E ∧ ¬ERROR)}

s0|e0 |= {¬TEN , AXAG(¬TEN ∨ AG(¬SERV E ∧ ¬ERROR)}
s1|e1 |= {AG(¬TEN ∨ AG(¬SERV E ∧ ¬ERROR)}
s1|e1 |= {¬TEN , AXAG(¬TEN ∨ AG(¬SERV E ∧ ¬ERROR)} (
s2|e2 OR s3|e3 OR s4|e4 OR s5|e5 |= {AG(¬TEN ∨ AG(¬SERV E ∧ ¬ERROR)}} s2|e2 |= {AG(¬TEN ∨ AG(¬SERV E ∧ ¬ERROR)}} (s3, s4, s5 not explored) s2|e2 |= {¬TEN , AXAG(¬TEN ∨ AG(¬SERV E ∧ ¬ERROR)}
(
s6|e6 |= AG(¬TEN ∨ AG(¬SERV E ∧ ¬ERROR)
s6|e6 |= ¬TEN ∧ AXAG(¬TEN ∨ AG(¬SERV E ∧ ¬ERROR) (
s7|e7 |= AG(¬TEN ∨ AG(¬SERV E ∧ ¬ERROR)
s7|e7 |= ¬TEN ∧ AXAG(¬TEN ∨ AG(¬SERV E ∧ ¬ERROR) (
s8|e8 AND s9|e9 |= {AG(¬TEN ∨ AG(¬SERV E ∧ ¬ERROR)}}
s8|e9 AND s9|e9 |= {¬TEN , AXAG(¬TEN ∨ AG(¬SERV E ∧ ¬ERROR)}
( 0
s |e0 |= {AG(¬TEN ∨ AG(¬SERV E ∧ ¬ERROR)}
Table 2
Tableau for constructing witness environment for the coffee brewer example in Figure 1

formula. The algorithm applies the appropriate tableau rules described earlier and first attempts to check if the current state satisfies all current-state commitments. Then the next-state commitments are passed on to the successors.
For example, initially the negated property E(tt U AGчTEN V AG(чSERV E Λ чERROR)) is passed to the initial state s0 of the model. The negated prop- erty is then broken down (using the environment state tableau rule unreu) to
{AG (чTEN V AG(чSERV E Λ чERROR) V  (tt  Λ  EX Ett U AG(чTEN V
AG(чSERV E Λ ч ERROR))). The resulting disjunction is then broken further (using the tableau rule Λ). Once the current-state commitments are met, all next state commitments of s0 are passed to its successor s1. This is shown using ( in table 2. Note that for environment states, formulas are organized into set notation whereas for system states, they are applied in the order they arrive. The algo- rithm terminates when a strongly connected component which satisfies the negated property is found.
