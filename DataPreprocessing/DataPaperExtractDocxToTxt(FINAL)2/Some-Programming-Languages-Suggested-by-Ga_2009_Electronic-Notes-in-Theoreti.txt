

Electronic Notes in Theoretical Computer Science 249 (2009) 117–134
www.elsevier.com/locate/entcs

Some Programming Languages Suggested by Game Models
(Extended Abstract)
John Longley1
LFCS, School of Informatics University of Edinburgh
10 Crichton Street, Edinburgh, UK

Abstract
We consider a simple and well-known category of alternating games (also known as sequential data struc- tures) and several categories derived from it. In each case, we present an extension of Plotkin’s language FPC (or a suitable linearization thereof) which defines all computable strategies of appropriate types. The quest for such languages results in a novel selection of language primitives for state encapsulation, coroutining and backtracking.
Keywords: Game semantics, sequential data structures, definability, coroutines, backtracking, linear types, FPC

Introduction
Ever since Plotkin’s classic paper [24], one of the principal concerns of denotational semantics has been to establish close connections between particular programming languages and particular mathematical models of computation — preferably models whose construction is independent of the syntax of the language in question. For example, one might prove that an interpretation [[ − ]] of a language L in a model M is fully abstract, or that all computable elements of M are deﬁnable by programs of L. In general, the tighter the connection, the better the prospects for using M to prove facts about programs in L (see e.g. [19]).
As explained e.g. in [8], one can broadly distinguish two approaches to this enterprise: either we take a language as given and look for a mathematical model to fit it, or we take the model as given and look for a corresponding programming language. A possible motivation for the latter approach is that it offers the prospect

1 Email: jrl@staffmail.ed.ac.uk

1571-0661 © 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.07.087

of more mathematically based programming languages or language features: given a model M with a rich and pleasing mathematical structure, a language L that closely matches M can be expected to be particularly amenable to reasoning. Moreover, a definability result will assure us that we are getting “value for money” from M, in the sense that all behaviours which M gives us the capacity to reason about are expressible in the language. (Already in [24] it was suggested that denotational semantics could be used in this way to identify language constructs “unintentionally left out by the language designer”.)
Of course, in some cases this approach may lead to languages that look decidedly unnatural from a programming language point of view, even when the model M is mathematically a natural one — witness the language PCF+parallel-or+exists cor- responding to the Scott/Ershov model of partial continuous functions [24], or (even worse) the language PCF+H corresponding to the sequentially realizable function- als [16]. However, the approach seems more promising in the case of models that represent a range of computational phenomena more in accord with realistic pro- gramming practice. Among the denotational models currently on the market, we suggest that game models offer a particularly attractive combination of rich mathe- matical structure and computational expressiveness. For a survey of the main ideas and results in game semantics, see e.g. [7].
In much of the game semantics literature to date, the language-driven (or feature- driven) perspective has been dominant: by and large, the goal has been to provide fully abstract models for a range of toy languages embodying familiar programming constructs. This programme has been very successful, as witnessed by the wide range of language features (exceptions, higher-order store, non-determinism, poly- morphism, name generation etc.) that have been modelled using games. However, this success has often come at a price: in order to obtain a precise fit with a given language, some specialized machinery typically needs to be incorporated into the model construction (e.g. justification pointers, innocence, visibility, well-bracketing, permutation invariance), with the consequence that many game model constructions in the literature are technically quite elaborate. In the present paper, we offer some contributions to game semantics from a more model-driven perspective: starting from some models that appear simple and mathematically compelling in their own right, we ask what programming languages might correspond to them (in the sense of full abstraction and definability). These results are of some intrinsic interest in that they shed light on the precise level of computational power inherent in the models; but we also venture to suggest that some of the language primitives arising in this way may hold interest as a basis for some novel and useful programming lan- guage constructs, in particular for various forms of state encapsulation, coroutining and backtracking.
In fact, in this paper we shall concentrate entirely on categories derived from one of the simplest and most natural of all game models — the category of (negative) alternating games or sequential data structures as studied in [1,6]. This category, itself symmetric monoidal closed, can be endowed with a linear exponential (or ‘!’  operator) in at least three natural ways, making it in each case a model of

intuitionistic linear logic. Each of these in turn gives rise to a cartesian closed category in the usual way, so including the underlying category itself we have a total of seven models of interest. We summarize the construction and basic properties of these models in Section 2.
For each of the seven models, we will present a programming language with the corresponding computational power, formulated as an extension of the recursively typed functional language FPC (or an appropriate linearization thereof). In each case, we obtain definability and full abstraction results using the method explained
in [17], exploiting the fact that our model possesses a universal object U with a
particularly simple structure, denotable by a certain language type υ. Since de- finability and full abstraction at type υ are clear, it suffices to show that a small handful of types (such as υ∗υ, υ−oυ, !υ) are definable retracts of υ. In most cases, it was the requirement that these retractions be programmable that led us naturally to the identification of suitable language primitives. In Section 3 we introduce a suitable collection of primitives at a semantic level, and in Section 4 we use these to give complete languages for our models. In this extended abstract, we content ourselves with statements of the results and a high-level discussion of the proofs — further details will appear elsewhere.
The models studied in this paper form the semantic basis for our “Eriskay project” [20], in which we are seeking to take seriously the challenge of basing the design of a usable programming language on clean mathematical foundations. To date, we have completed a formal definition for a substantial sublanguage of Eriskay (called Lingay [18]), and provided an implementation based on a direct animation of the underlying game semantics. The language primitives described here do indeed feature in Lingay, and part of our purpose here is to explain where they came from. Note that we are concentrating here on the theory underlying the “quasi-functional” aspects of Lingay (broadly speaking, the fragment consisting of FPC-like types, albeit with non-functional operators at these types) — the seman- tic foundations for the specifically “object-oriented” aspects of the language (class implementations, inheritance, dynamic binding) are not treated in this paper.
I am grateful to the coordinators of the Mathematically Structured Functional Programming special session for the invitation to present this material, and to Jim Laird, Guy McCusker and Nicholas Wolverson for helpful and enjoyable discussions. Much of the research reported in this paper was carried out under the EPSRC project GR/T08791: “A programming language based on game semantics.”

The game model and its exponentials
We give the definition of our game model in a form close to that of Curien [6], who was inspired by earlier unpublished work of Lamarche [15]. The model corresponds to the category of negative games and strategies as described in [1].
For any sets X, Y we write Alt(X, Y ) for the set of finite sequences z0 ... zn
where zi ∈ X for i even, zi ∈ Y for i odd. If L ⊆ Alt(X, Y ), we write Lodd, Leven
for the sets of odd- and even-length sequences in L respectively.

Definition 2.1 (i) A game G consists of disjoint countable sets OG, PG of opponent and player moves, together with a non-empty prefix-closed set LG ⊆ Alt(OG, PG) of legal positions.
(ii) A (player) strategy for G is a partial function f : Lodd ~ PG such that
f (s) = y implies sy ∈ LG, and syx ∈ dom f implies f (s) = y.
We write X +Y for the set {(x, 0) | x ∈ X}∪{(y, 1) | y ∈ Y }. Given any sequence s whose elements are pairs, we write si for the inverse image under z '→ (z, i) of the subsequence of s consisting of elements (z, i).
Given games G, H, we may form games G⊗H, G   H, G&H, G  H as follows:
OG⊗H  = OG + OH	PG⊗H  = PG + PH
LG⊗H  = {s ∈ Alt(OG⊗H, PG⊗H ) | s0 ∈ LG, s1 ∈ LH}
OG  H  = PG + OH	PG  H  = OG + PH
LG  H = {s ∈ Alt(OG  H, PG  H) | s0 ∈ LG, s1 ∈ LH}
OG&H  = OG + OH	PG&H  = PG + PH
LG&H  = {s ∈ Alt(OG&H, PG&H ) | (s0 ∈ LG ∧ s1 = ϵ) ∨ (s1 ∈ LG ∧ s0 = ϵ)}
OG H  = OG + OH	PG H  = PG + PH
LG H = {s ∈ LG⊗H | s = ϵ ∨ s starts with a move (0, x)}
We now obtain a category G as follows: objects are games, and morphisms G → H are strategies for G H. Identities and composition are defined as usual in game semantics (see e.g. [6] for definitions and further intuition). It is routine to check that G has the structure of a symmetric monoidal (in fact affine) closed category; note however that G does not contain diagonals G → G ⊗ G. In addition, & is actually a cartesian product operation on G. The operator is the sequoidal product introduced by Laird in [12], except that our G H is his H  G. Note that G  H is a retract of G ⊗ H. Detailed proofs of all these facts are given in [26].
The strategies for any game G form a CPO under the inclusion ordering, and games themselves form a (large) CPO under the ordering
G ± H  iff OG ⊆ OH, PG ⊆ PH, LG ⊆ LH
These observations enable us to interpret recursion at the level of terms and types respectively in a familiar way (note in particular that  is covariantly monotone in both arguments).
We denote the empty game by 1. The following games N, Nω and U will also play an important role:
ON = {?}	PN = N	LN = {ϵ, ?, ?0, ?1,.. .}
ONω = N  PNω = N  LNω = {s ∈ Alt(N, N) | length(s) ≤ 2}
OU = N   PU = N   LU = Alt(N, N)
The game N will serve to interpret the type nat of natural numbers, and Nω

the call-by-value type nat -o nat of functions on natural numbers that may be invoked just once. A trivial but crucial fact is that U is a universal object in G, in the sense that every game G ∈G is a retract of U . Later, we will also be exploiting the fact that U is isomorphic to the denotation of the (!-free) affine FPC type rectype t => nat -o nat * t (see Section 4).
The relatively simple definition of G thus gives rise to a rich and pleasing math- ematical structure. Further (and deeper) evidence for the mathematical credentials of this model is provided by a striking result of Laird [13]: if the definition of strategy is modified to allow for a single non-recoverable error value T, our model becomes equivalent to the (well-pointed) category of locally Boolean domains and affine bistable maps.
Next, we describe three ways in which G may be endowed with an operator ‘!’, each embodying a different conception of what it means for a strategy to be “reusable”. Each of these has appeared previously in the literature, though not all in the same place as far as we know. We point out in advance that each of our operators carries the categorical structure of a linear exponential comonad on G
(see [25]), and moreover satisfies !(G&H) ∼= !G⊗!H. As is now well known, this is
sufficient to yield an interpretation of intuitionistic linear logic, and also implies that the co-Kleisli category G! is cartesian closed. (Recall that G!-morphisms G → H
are G-morphisms !G → H.) For our present purposes, a description of the action of each ‘!’ on objects will be all that is required; we shall refer to the literature for definitions of the remaining structure and verifications of the requisite properties.
Our first ‘!’ is the non-repetitive backtracking exponential, outlined in [1] and
studied in detail in [6].
Definition 2.2 For any game G, we define !1G as follows. Moves are given by
O! G = Leven × OG	P! G = PG
1	G	1
Legal positions in !1G are sequences s ∈ Alt(O!1G, P!1G) such that
if an O-move (t, x) appears in s then tx ∈ Lodd, and if (t, x) is immediately followed in s by a P-move y then txy ∈ Leven ;
if an O-move (txy, z) appears in s, then the adjacent move pair (t, x)y must appear at some earlier point in s ;
no O-move (t, x) appears more than once in s.
The intuition is that the game G is here made reusable in the sense that at any point, Opponent may “backtrack” to a previously encountered position in G and play a new move so as to explore a fresh part of the game tree for G (repetitions of earlier moves are not admitted). In principle, one could get away with tagging an O-move x with the list of O-moves in t rather than the whole of t, but the
above formulation simplifies the definition of L!1G.  For the associated structure
and verification of the required properties, see [6], where it is also shown that the co-Kleisli category G!1 is a full sub-CCC of the sequential algorithms model of [4].
Our second ‘!’ may be described as a repetitive exponential without backtrack-
ing. It was introduced in [11], and is perhaps the most easily grasped of our three

exponentials.
Definition 2.3 For any game G, we define !2G as follows. Moves are given by
O!2G  = N × OG	P!2G  = N × PG
Legal positions in !2G are sequences s ∈ Alt(O!2G, P!2G) such that
for each i ∈ N, si ∈ LG ;
if a move (i + 1, z) appears in s, then a move (i, x) appears at some earlier point in s.
The definition implies that any P-move carries the same index i as the preced- ing O-move (thus, we could in principle dispense with the P-indices). Intuitively, Opponent may at any point either play in an existing “copy” of G or choose to start a new play in a fresh copy (where copies must be activated in the order 0, 1, 2,.. .). By contrast with !1, Opponent cannot backtrack to an arbitrary previous position
— only to the start of the game G. However, a strategy for !2G may behave quite differently in different copies of G, suggesting that this ‘!’ corresponds to some kind of stateful behaviour.
An economical but rigorous presentation of the structure and relevant properties of !2 is given in [26]. A useful observation is that !2G ∼= G !2G (in fact, !2G is the minimal solution to this equation). As noted in [14], !2 also enjoys a certain distinguished status as the cofree commutative comonoid on G.
Our final ‘!’ may be regarded as a repetitive backtracking exponential, combining the power of the previous two. It is tempting to think that such an exponential could be obtained simply by dropping condition 3 from the definition of !1, but un- fortunately the operator thus obtained is not even functorial. The correct definition is given by making each O-move in !3G refer not just to a previously arising play in G, but to a particular occurrence of such a play. This exponential was first explicitly presented in [10], along with its associated structure; an informal description of the corresponding co-Kleisli category also appeared in [17]. We here write N1 for the natural numbers excluding 0.
Definition 2.4 For any game G, we define !3G as follows. Moves are given by
O!3G = N × OG	P!3G = N1 × PG
Legal positions in !3G are finite sequences
s = (a1, x1)(b1, y1)(a2, x2)(b2, y2) ...  ∈ Alt(O!3G, P!3G)
such that
each ai < i and each bi = i ;
for each prefix s' of s, the thread θ(s') extracted from s' is a position in LG. Here the mapping θ is defined by:
θ(ϵ) = ϵ ;
if s is even then θ(s(0, x)) = x ;
if s = (a1, x1) ... (br, yr) and 0 < a ≤ r then
θ(s(a, x)) = θ((a1, x1) ... (ba, ya))x ;

if s is odd then θ(s(b, y)) = θ(s)y.
Thus, each O-move in a play of !3G is either initial (annotated with 0) or points to an earlier P-move occurrence.
The mere existence of all these structures on G is in itself an indication of the mathematical fecundity of this model. However, the above definitions may appear rather mysterious, and the precise computational power embodied by the respective exponentials may not be very evident at this stage. The programming language characterizations to be given below will shed more light on this.
We will also employ one further categorical construction. It will be mildly more convenient to formulate our programming languages in a call-by-value style, since (for example) the mathematically natural universal types are denotable in such a framework, and several of our language primitives also look more natural in a call-by-value setting. We therefore invoke a general construction described in [3], yielding a category Fam(G) suitable for modelling call-by-value computation. We see the passage from G to Fam(G) as a mild convenience that expands the category to accommodate the full range of FPC types; however, from the point of view of computational power, it adds nothing essential and everything of interest can in principle be expressed in terms of G alone.
We summarize here what we will need to know about Fam(G). Objects are set- indexed families (Gi | i ∈ I) of objects of G, and morphisms (Gi | i ∈ I) → (Hj | j ∈ J) are functions mapping elements i ∈ I to pairs (j ∈ J, f ∈ G(Gi, Hj)). Both G and the category of sets embed fully in Fam(G) via the inclusions G '→ (G | i ∈ {∗}) and I '→ (1i | i ∈ I) respectively; we shall often tacitly identify a game G or set I with its image in Fam(G), and also refer to sets as ground objects within Fam(G). Affine products ⊗ lift readily to Fam(G), and  on G yields a bifunctor
  : Fam(G)op × G → G. Moreover, Fam(G) has sums (denoted using +). We also have a lift functor −⊥ : Fam(G) → G, taking an object (Gi | i ∈ I) to a game whose legal positions are all sequences ∗is and prefixes thereof, where ∗ is a distinguished initial move, i ∈ I, and s ∈ LGi . In this context, we will call the O-move ∗ the request associated with the application of −⊥, and the P-move i the corresponding reply. Clearly, each of our comonads on G lifts to one on Fam(G) via !(Gi | i ∈ I) = (!Gi | i ∈ I); note that under this correspondence, the category Fam(G)! coincides with Fam(G!).
Finally, we note that all the categories C we have introduced are algebraically simple, in the sense that they admit no proper algebraic quotients that do not collapse (say) the homset C(1,N ). This is essentially because if f, f ' are distinct strategies in a game G, it is easy to define a strategy for G  N which plays in G up to a point at which f and f ' differ, and then exposes this difference in N . Thus, definability results for C entail full abstraction results in the following sense: given any language L with a compositional interpretation [ − ]] in C such that every morphism in C([[ σ ]],N ) is definable by an L-context K[− : σ] : nat, then we have [[ e ]] = [[ e' ] for any closed terms e, e' : σ where [ K[e] ]] = [[ K[e'] ] for all such K. This condition captures the purely denotational aspect of full abstraction without reference to an operational semantics of L. It follows that if L is endowed with any

operational semantics for which [ − ] is adequate, then [ − ] will be fully abstract in the usual sense. Thus, we are justified in restricting attention henceforth to definability results.
State, coroutining and backtracking operators
In this section we now point out some strategies of particular interest that live in our various models, intuitively embodying various kinds of stateful, backtracking or coroutining behaviour. These will give us what we need in order to interpret the languages to be introduced in Section 4.

State operators
Even in G at !-free types, some mildly stateful behaviour may be observed. Consider for instance the following strategy share : U  U ⊗ U , which transforms a strategy for U into a pair of such strategies via a simple coding N + N ∼= N. We write inl, inr1 and inr2 for the injections on move sets corresponding to the three appearances
of U in the above type.

One may think of this operation as “stateful” insofar as it would be naturally implemented by storing the argument of type U where it could be accessed by both sides of the result (bearing in mind that this argument is “non-copyable”).
More interesting stateful behaviour arises in connection with !i where i = 2, 3. An easy but powerful observation is that for these exponentials (though not for
i = 1) we have a canonical isomorphism flatteni : U →!iNω (whence !2Nω ∼= !3Nω).
Thus, flatteni uses a non-reusable lazy forest to create a reusable function N ~ N, which is stateful insofar as repetitions of the same function call may yield different results. This small piece of magic is a significant part of what makes these models mathematically pleasant to work with (we shall see this when we obtain definability results for the models involving !2 and !3).
In fact, flatten can be seen as arising from a more general state operator, which is most easily presented in the call-by-value setting. We first consider the situation for !2. If S, X, Y are objects in Fam(G), we may ask whether we have a morphism
encaps2,S,X,Y : S ⊗ !2((S ⊗ X)   (S ⊗ Y )⊥) −→ !2(X   Y⊥)
which can be seen as creating a single-method “object” with encapsulated internal state of type S, given an initial state and a concrete method implementation. It turns out that such a morphism does indeed exist when X is a ground object in Fam(G) — a straightforward recursive definition may be given by exploiting the
isomorphisms !2G ∼= G  !2G in G. (For full details and an axiomatization of the

key properties of this morphism, see [26, Chapter 3], where the morphism is called linthread .)  It is easy to see how flatten2 may be obtained from encaps2 (with S = U ), and also how encaps2 may be used to construct an integer store cell; thus, encaps2 embodies a level of stateful behaviour intermediate between ground-type and full higher-order store.
A similar operator exists for !3 (again for X a ground object), except that here it seems best to modify the type slightly:
encaps3,S,X,Y : S ⊗ !3((S ⊗ X)   (S⊗!3Y )⊥) −→ !3(X   Y⊥)
The extra !3 on Y here allows for the possibility that Opponent might invoke the resulting function !3(X  Y⊥) and then exploit backtracking to re-use the resulting value of type Y (even if the type Y is not itself reusable). A construction analogous to that of encaps2 may be used to define such an operator.
We digress briefly to mention a further generalization of encaps, which is not required for the main results of this paper but gives some additional insight into the relative computational power of our various models (and also furnishes another example of a semantically inspired language construct). One may ask whether operators encapsi,S,X,Y exist where X is a non-ground object (for i = 2, 3). In such a case, we had better insist that S is reusable (say S = !iS'), since interaction with X might trigger “re-entrant” method calls resulting in multiple concurrent interactions with the state. Subject to this proviso, an encapsulation operator does exist, but it only works well in conjunction with strategies g for !i((S ⊗ X)  (S ⊗ Y )⊥) satisfying the following argument-safety condition: after the reply to the initial ‘⊥’ request, g never responds to a move in the right-hand copy of S with a move in
X. The argument-safety condition permits certain kinds of interaction with higher- order arguments, but prevents the construction of a general higher-order store cell. The notion of argument-safety and the corresponding encapsulation operators are studied in detail in [26], where it is shown that such a condition can be statically enforced in a programming language via a suitable syntactic restriction.

Backtracking
Next, we observe some structure that is available for our two backtracking ex- ponentials !1 and !3, but not for !2.  Given a game G and moves x ∈ OG, y ∈ PG, let us define Gxy to be the game with the same moves as G, and with LGxy = {s | xys ∈ LG}. We may now note that, for i = 1, 3, there is a canonical
isomorphism (!iG)xy ∼= !i(Gxy), where we identify xy with an initial move pair in !iG
in the obvious way. Intuitively, in the presence of backtracking, the tree of possible plays in !i(Gxy) arises as the subtree rooted at xy of the tree of possible plays in
!iG. (This does not hold for !2, since the tree for !2G branches only at its root.)
Using this idea, for any object X of Fam(G) one may define a morphism
forcei,X : !(X⊥) −→ (!X)⊥
The operational intuition here is that an interaction with X⊥ consists of two stages: forcing the “thunk” to yield a value of type X, and further interaction with this value. The above operator forces the thunk in a way which allows the result to be

re-used, giving us a point in the computation to which we may later “backtrack”.

Coroutining
We now describe an operator with a coroutining flavour, living in the basic model G without ‘!’. Operationally, this may be viewed as a linearly typed version of a resumable exception operator as found e.g. in Common Lisp — it allows us not only to jump out of a computation, but to jump back in at a later time and continue from where we left off.
Once again, it is easiest to work in Fam(G). Consider a strategy f of type (X  Y⊥)  (Z0 ⊗ Z1)⊥, where X and Z0 are ground objects, and (for simplicity) Z1 ∈ G. The initial O-move x in this game will be the unique request corresponding to the right-hand ‘⊥’, and f will respond to this (if at all) in one of two ways:
f may respond immediately with a reply y for the right-hand ‘⊥’, carrying an element of Z0. In this case, the subsequent behaviour of f in the subgame rooted at xy may be canonically identified with a strategy in (X  Y⊥)  Z1.
f may choose to invoke the argument of type X  Y⊥. Specifically, f may play a request for the left-hand ‘⊥’, carrying an element of X. In this case, the ongoing behaviour of f canonically yields a strategy in Y  (Z0 ⊗ Z1)⊥.
Putting this together, we obtain a canonical morphism
lincatchcont : ((X   Y⊥)   (Z0 ⊗ Z1)⊥) −→
(Z0 ⊗ ((X  Y⊥)  Z1)) + (X ⊗ (Y   (Z0 ⊗ Z1)⊥)
The name here means “linear catch-with-continue”, suggesting its kinship with the Cartwright/Felleisen catch operator [5]. “Linear” means the X  Y⊥ argument is not reusable (cf. the catchcont operator in the current version of Lingay [18]).
Our operator is essentially equivalent in computational power to the morphism lfe−1 identified by Laird in [14]. Laird’s categorical analysis of G is in a sense more fundamental than what we are attempting here, and his operator captures more succinctly than ours the quintessence of this kind of coroutining behaviour. However, Laird’s operator does not live at an (affine) FPC-denotable type, whereas our concern here is to show how this level of computational power may be expressed within the realm of such types, and also perhaps to make a stronger connection with programming intuition.
Let us also comment briefly on the relationship with callcc, of which lincatchcont may seem reminiscent. It is possible to define strategies within G for higher order (linear versions of) callcc. However, it seems that these strategies do not suffice for defining lincatchcont without the further addition of some kind of higher-order store operator. It thus appears that it is lincatchcont rather than some version of callcc that naturally captures the computational strength of G. We note also that lincatchcont enforces a “delimited” form of non-local control which pre-empts the kinds of runtime errors that sometimes arise from expired continuations in typical implementations of callcc. Finally, we have found that many people will admit that

they find lincatchcont easier to grasp as a programming primitive than callcc.
More powerful operators of this kind are possible in the models (G, !i). For instance, if i = 1, 3, a straightforward variation on the above construction leads to the definition of a morphism
catchconti : (!i(X   Y⊥)   (Z0 ⊗ Z1)⊥) −→
(Z0 ⊗ (!i(X   Y⊥)   Z1)) +
(X ⊗ (!iY   !i(X   Y⊥)   (Z0 ⊗ Z1)⊥)
This operator acts on a strategy f which may invoke its “throw operation” of type
X  Y⊥ several times. This means that in the second summand of the result type, an additional argument of type !i(X Y⊥) is needed so that after resuming interaction with f , we know what to do when f subsequently re-invokes the throw operation. The appearance of !iY rather than Y in the second summand is explained by the fact that if the exponential in !i(X  Y⊥) allows backtracking, then f is also allowed to perform multiple explorations the result returned from the first throw
invocation. (We also naturally obtain a morphism catchcont 2, but its type has Y
in place of !iY at this point.)
There is an important operational difference between catchcont 1 and catchcont 3. In the case of the non-repetitive !1, if the given strategy f happens to arise as the denotation of a program which (operationally) invokes its throw twice with the same value v of type X, only the first of these invocations will show up in the strategy f itself. When we invoke the resume operation provided by catchcont 1(f ), it is therefore as if the supplied argument of type !Y is “memoized” so that it can be re-used whenever the value v is again thrown; only for thrown values v' /= v will we refer to the supplied argument of type !(X Y⊥). By contrast, in the case of !3, repeated throw invocations do show up in f , so that after resumption, later throw invocations are always referred to the !(X Y⊥) argument. To emphasize this distinction, we shall later refer to catchcont 1 by the name memocatchcont , and to catchcont 3 by the name fullcatchcont .

Dynamic selection of strategies
One final jigsaw piece is needed. We have seen how the encaps operators provide means to construct non-trivial strategies at types !2G, !3G (that is, strategies that are not merely promotions of strategies for G), but we do not yet possess a way to do this for !1G. The following operator fills this gap.
The idea is that for any X ∈ Fam(G), we can give a strategy in !1(N  X⊥) by first giving an N-indexed family of possible such strategies, and then deciding which of these strategies to use in response to the first Opponent move played (which will be a request carrying a natural number). This mildly stateful behaviour may be embodied by a morphism
switchX : (N  !1(N  X⊥)) −→ !1(N  X⊥)
which may readily be seen to exist in (G, !1). Note that the number n supplied by

the first Opponent move will initially be used for both of the N arguments in the type N  !1(N  X⊥).

Languages for game models
The base languages
We now work towards defining programming languages that match each of our seven models, in the sense that they define all computable morphisms of appropriate type. As a base to work from, we use Plotkin’s recursively typed language FPC and linearizations thereof: specifically, we use an affine variant AFPC for the underlying model G; an affine-exponential variant AEFPC for the models (G, !); and the original (intuitionistic) language FPC for the co-Kleisli categories G!. The definitions of these languages and their semantic interpretation proceed along mostly standard lines, so we content ourselves here with a summary of the essential points. Since our results consider these languages from a purely denotational perspective, operational semantics will not be required.
We start with FPC itself, as it is familiar from the literature. Types τ of FPC may be generated by the following grammar, where α ranges over type variables:
τ ::= α | τ xτ | τ +τ | τ ->τ | rectype α=>τ
The syntax of terms e may be defined by the following grammar, where x ranges over variables and ρ over rectypes:
e ::= x | (e,e) | let (x,x')=e in e | inlτ,τ' e | inrτ,τ' e
| case e of inl x=>e|inr x'=>e
| fn x : τ =>e | ee | foldρ e | unfold e | rec x : τ =>e
The choice of unpairing construct here, and the inclusion of rec as a primitive, are intended to facilitate a uniform presentation of the ordinary and affine languages. Typing judgements are of the form Γ ▶ e : τ , where contexts Γ are of the form x1 : τ1,..., xn : τn. Typing rules are given as in the literature (see e.g. [23]). Note in particular that contraction is freely available — that is, there is no restriction on the re-use of variables.
Next we describe the affine variant AFPC, intended for interpretation in G. Here the type constructors x, -> are replaced by their linear counterparts:
τ ::= α | τ *τ | τ +τ | τ -oτ | rectype α=>τ
The grammar for terms may be taken to be identical to that of FPC, but the typing rules differ in three ways. First, the type constructors x, -> are replaced by *, -o respectively throughout the rules for pairing, unpairing, abstraction and application. (The overloading of term constructs here should cause little confusion given that we are keeping the type constructors syntactically distinct.) Secondly, as usual in linear type systems, the treatment of contexts in multi-premise rules is

set up to prevent re-use of variables, for example:
Γ ▶ e : τ1 + τ2	Γ',x : τ1 ▶ e1 : τ '	Γ',x : τ2 ▶ e2 : τ '
Γ, Γ' ▶ case e of inl x=>e : τ '
where Γ, Γ' are required to be disjoint (contraction is not admitted). Thirdly, a rec
expression is permitted only if it has no free variables.
The language AEFPC is obtained by extending AFPC with a type constructor
!τ and term constructors der e and prom e. A type is reusable if it is of the form !τ ; a context x1 : τ1,..., xn : τn is reusable if all the τi are reusable. The typing rules for der and prom are as follows, where v ranges over values (i.e. terms constructed using variables, pairing, injection, abstraction, folding and promotion).

Γ ▶ e : !τ


Γ ▶ der e : τ
Γ ▶ v : τ


Γ ▶ prom v : !τ

Γ reusable

Contraction is admitted for variables of reusable type only; likewise, the restriction on rec expressions is that their free variables must be reusable.
We now turn to the interpretation of these languages in our models. The call- by-value interpretation of AFPC in G is straightforward. Each type τ denotes an object [ τ ]]Ξ of Fam(G) relative to a valuation Ξ assigning objects of Fam(G) to type variables:
[[ α ]]Ξ = Ξ(α)	[ τ *τ ' ]]Ξ = [ τ ]]Ξ ⊗ [[ τ ' ]]Ξ
[[ τ +τ ' ]]Ξ = [ τ ]]Ξ + [[ τ ' ]]Ξ  [[ τ -oτ ' ]]Ξ = [ τ ]]Ξ  ([[ τ ' ]]Ξ)⊥
[[ rectype α=>τ ]]Ξ = Fix (X '→ [[ τ ]]Ξ,α'→X )
(In the last clause we appeal to the CPO structure on the class of games mentioned in Section 2.) Typing judgements x1 : τ1,..., xn : τn ▶ e : τ are then interpreted by morphisms [ τ1 ]] ⊗· · ·⊗ [[ τn ]] → [[ τ ]]⊥ in Fam(G) along standard lines (cf. [2]), paying due attention to issues of linearity. Furthermore, for each of our models (G, !i), the above interpretation may be readily extended to AEFPC, by defining [[ !τ ]]Ξ = !i [[ τ ]]Ξ and using the comonad structure to interpret der and prom.
We would also like to define a call-by-value interpretation of FPC in the cate- gories Fam(G!i ). However, there is a snag: in general, the lifting monad on G need not itself “lift” to a monad on G!. What is needed in order for it to do so is a distributivity law !⊥→ ⊥! (cf. [10]) — in fact, none other than our force operator! Thus, a call-by-value interpretation of FPC in Fam(G!i ) works for i = 1, 3 but not for i = 2. We will sidestep this obstacle by contenting ourselves with a call-by-name interpretation when we come to consider the language for G!2 (see Theorem 4.6) — such an interpretation may be straightforwardly given along the lines of [23]. In
what follows, the notation [ − ] will refer to the call-by-value interpretation unless otherwise stated.

Deﬁnability results
We now come to our main results. We say a language L is complete for a game model C if all computable strategies in C at L-denotable types are definable in L.

We shall present extensions of the above languages that are complete for each of our models (whence, by the discussion at the end of Section 2, the models are also fully abstract for these languages). We give here only a high-level route map of the proofs, omitting many interesting details. A source file containing Lingay implementations for most of the programs here claimed to exist is available online [21].
In AFPC and AEFPC, we define the following useful types:
empty = rectype α=>α	unit = void -o void
nat = rectype α=>unit + α	univ = rectype α=>nat-o(nat*α) We use γ, δ to range over ground types, i.e. those that may be constructed from
unit without use of -o.
Consider first the interpretation of AFPC in Fam(G). It is easy to check that [[ univ ]] ∼= U , and that all partial computable functions on N, and hence all com- putable strategies in [ univ ]], are definable in AFPC. For general reasons (see [17]), we will have definability at all types as soon as each of [ univ + univ ]], [[ univ * univ ]], [[ univ -o univ ] is a programmable retract of [ univ ]]. For ‘+’ this is already true in AFPC, while for ‘*’ it clearly becomes true if we add a constant
share : univ -o univ*univ to the language. (We adopt the evident convention that a named language primitive is to be interpreted using the semantic operation of the same name introduced in Section 3.) For -o, there is a semantically evident retraction [ univ -o univ ]] [[ univ ]], of which the “application” half is definable in AFPC, while the “abstraction” half is non-trivial and naturally calls for the operator
lincatchcontγ,σ,δ,τ : ((γ-oσ)-o(δ*τ )) -o (δ*((γ-oσ)-oτ ) + (γ*(σ-o(δ*τ )))) We thus have:
Theorem 4.1 The language AFPC + lincatchcont + share is complete for G.
One might wonder whether the “stateful” strategy share could itself be defined from a more primitive operator in G with more of the feel of a natural programming construct, but this seems to us to be more trouble than it is worth. We note that share is not needed for definability at types not involving *.
Next, consider the interpretations of AEFPC in our models (G, !i). In each case, all that we require in addition to the above is that some retraction [ !univ ]] [[ univ ]] is programmable. The case of !1 is perhaps the most delicate. A suitable section [[ !univ ]] → [[ univ ] may be coded up using the operator
forceτ : !(unit -o τ ) -o !τ
(or equivalently by admitting terms prom e where e need not be a value), while the corresponding retraction may be implemented using the primitive
switch : (nat -o !(nat -o nat*univ)) -o !(nat -o nat*univ) together with another use of share. We thus have:
Theorem 4.2 The language AEFPC + lincatchcont + force + share + switch
is complete for (G, !1).

For both !2 and !3, we can exploit the isomorphism [ univ ]] ∼= [[ !(nat -o nat) ]], which becomes programmable once we add a language primitive
encapsσ,γ,δ : σ * !(σ*γ -o σ*δ) -o !(γ-oδ)
(The distinction between encaps2 and encaps3 is immaterial at such types, although of course we can add more general forms of encaps2, encaps3 to our languages if we wish.) In the case of !2, this isomorphism, along with some uses of ground type store cells which may also be coded using encaps, is by itself sufficient to define a retraction [ !univ ]]  [[ univ ]]. Since share may be defined using encaps, we have
Theorem 4.3 The language AEFPC + lincatchcont + encaps is complete for
(G, !2).
Finally, in the case of !3, the retraction [ !univ ]]  [[ univ ] is definable using
force and encaps (an analogue of switch is not necessary here), so we have
Theorem 4.4 The language AEFPC+lincatchcont+force+encaps is complete for (G, !3).
We next turn to FPC and the co-Kleisli models. Of course, the primitives identified above for (G, !i) already suffice to define everything in Gi, but the point is to find primitives of intuitionistic type that precisely represent the computational power available at such types.
Define empty, unit, nat as before, replacing -o by ->. For our methodology to apply, we need to find a universal type univ’ within the world of FPC types. Here we can simply replace -o by -> in the definition of univ, or else use the following ingenious choice due to Laird [14]:
univ’ = nat -> (nat->nat) -> empty
Remarkably, this gives [ univ’ ]] ∼= U (canonically in the case of !2 and !3, or less canonically in the case of !1). In either case, our principal task is to ensure that some retraction [ univ -> univ ]]  [[ univ ] is programmable, the retractions for x and + being straightforwardly definable in FPC.
In the case of !1, the co-Kleisli model coincides with the world of sequential algorithms, and it is already known that the language FPC+catch is complete for this model [5]; however, an alternative solution, which fits better into the overall scheme we are presenting, is to introduce the language primitive
memocatchcontγ,σ,δ,τ :  ((γ->σ)->(δxτ )) ->
(δ x ((γ->σ)->τ ) + (γ x (σ->(γ->σ)->(δxτ )))
We then have
Theorem 4.5 The language FPC + memocatchcont is complete for G!1 .
A potential advantage of memocatchcont over catch here is that it promises a tighter, more “intensional” correspondence between strategies and operational behaviour: with catch, there are operations that cannot be computed without repeated function invocations at an operational level, whereas these can be avoided using memocatchcont. We leave this as a topic for future research.

For !2, we may define an operator
coroutineγ,δ,γ',δ' :  ((γ->δ) -> γ ) -> (γ -> (δ->γ) -> δ ) -> γ +δ
This pleasantly captures what is perhaps the most familiar conception of corou- tining within a simply-typed framework. Informally, coroutine interleaves the execution of two processes, starting with the first, and transferring control between them whenever the “yield” operations of types γ->δ and δ->γ are invoked. The output of whichever process completes first is returned as the final result. One may easily define a game semantics for coroutineγ,δ,γ',δ' and coroutineδ,γ,δ',γ' by simul- taneous recursion, using a suitable catchcont operator to pass between them; the differences between a call-by-value and call-by-name interpretation here are merely bureaucratic.
Theorem 4.6 The language FPC+coroutine (with a call-by-name interpretation) is complete for G!2 .
An essentially equivalent result appears in [14], formulated in terms of a lambda calculus with coroutine composition.
Finally, for !3, we may introduce the primitive fullcatchcont with the same
type as memocatchcont, and we then have:
Theorem 4.7 The language FPC + fullcatchcont is complete for G!3 .
Conclusion
The methodology of obtaining definability results via universal types has led us to a selection of primitive operators which shed light on the computational power of some natural mathematical models. As we have seen, this approach leads us to a choice of programming primitives related to, but not the same as, those usually encountered in existing languages: we are led to favour data encapsulation rather than store cells as the basic mechanism for stateful behaviour, and coroutining rather than first-class continuations as the basis for a flexible approach to control. Moreover, our operators exploit the potentialities of a linear type system to advan- tage, e.g. offering the programmer valuable runtime security guarantees in the case of lincatchcont. Finally, our semantic approach highlights certain combinations of these operators which may coexist safely (for instance, we can combine powerful control operators with certain higher order store constructs without losing runtime safety). We suggest that the primitives we have discussed might serve as a basis for the design of practically useful language constructs (we are pursuing this possibility in our ongoing work on Eriskay).
Our primary motivation for a model-driven approach to language design is the prospect of obtaining languages amenable to program verification. However, it would also be interesting to explore the possible programming applications of our primitives more extensively than we have done so far. One promising area of ap- plication is the construction of efficient “generic search” algorithms. For instance, consider the problem of counting the vectors x ∈ {0, 1}n (for fixed n) satisfying

a certain property P (which might arise, for instance, from a formula of proposi- tional logic). In the interests of modularity and reusability, one would like to do this uniformly in P — that is, by means of a higher order program taking P as an input. One may improve on the naive approach by representing vectors x using the type nat -> bool, and properties P using (nat -> bool) -> bool, and us- ing catchcont and force to implement a traversal of the search space which uses backtracking to avoid repeated computation, and which moreover takes care of 2n−r vectors at a stroke if only r components of x are requested. Of course, this kind of algorithm could also be naturally implemented in a callcc style with reusable con- tinuations, but we think our operators lead to more perspicuous implementations. For other algorithms of a similar flavour but involving inﬁnite search spaces, see [9].
An obvious omission from this paper is the lack of any precise connection with operational semantics (although the executability of the game semantics means that this is already in some sense “operational”). Adequacy for a language with higher- order state encapsulation is proved in [26]. A traditional big-step semantics for catchcont and force is included in [18], although in these cases detailed adequacy proofs have yet to be carried out.
More also remains to be done on the mathematical side. For instance, the math- ematical relationships between our various exponentials require further elucidation (see [22] for some relevant results). It would also be interesting to carry out a sim- ilar investigation of the computational power of the various exponentials in other natural game models; the selection in [22] offers a good starting point.

References
Abramsky, S., and R. Jagadeesan, Games and full completeness for multiplicative linear logic. Technical report: DoC 92/94, Imperial College (1992). Journal version: J. Symb. Logic 59 (1994) 543–574.
Abramsky, S., K. Honda, and G. McCusker, A fully abstract game semantics for general references, Proc. Logic in Computer Science 1998, 334–344,
Abramsky, S., and G. McCusker, Call-by-value games, Lect. Notes in Comp. Sci. 1414 (1998), Springer, 1–17.
Berry, G., and P.-L. Curien, Sequential algorithms on concrete data structures, Theor. Comp. Sci. 20
(1982) 265-321.
Cartwright, R., P.-L. Curien and M. Felleisen, Observable sequentiality and full abstraction, Proc. POPL, 1992.
Curien, P.-L., On the symmetry of sequentiality, Proc. 9th MFPS, Lect. Notes in Comp. Sci. 802 (1993), Springer, 29–71.
Curien, P.-L., Notes on game semantics, course notes, 2006.
Curien, P.-L., Definability and full abstraction, Electr. Notes in Theor. Comp. Sci. 172 (2007) 301–310.
Escard´o, M.H., Infinite sets that admit fast exhaustive search, Proc. Logic in Computer Science 2007, 443–452.
Harmer, R., J.M.E. Hyland and P.-A. Melli`es, Categorical combinatorics for innocent strategies, Proc. Logic in Computer Science 2007, 379–388.
Hyland, J.M.E., Game semantics, in Semantics and Logics of Computation, CUP, 1997, 131–194.
Laird, J., A categorical semantics of higher-order store, Proc. CTCS ’02, Electr. Notes in Theor. Comp. Sci. 69 (2002).

Laird, J., Locally Boolean domains, Theor. Comp. Sci. 342 (2005) 132–148.
Laird, J., Higher-order programs as coroutines: a semantic analysis, to appear in Logical Methods in Computer Science.
Lamarche, F., Sequentiality, games and linear logic, Proc. CLiCS workshop, Aarhus University, DAIMI- 397-II, 1992.
Longley, J., The sequentially realizable functionals, Ann. Pure Appl. Logic 117 (2002) 1–93.
Longley, J., Universal types and what they are good for, Proc. 2nd Int. Symp. Domain Theory, Kluwer, 2003, 25–63.
Longley, J., Definition of the Lingay programming language (Version 0.2), Research report EDI-INF- RR-1283, University of Edinburgh, 2008.
Longley, J., and G. Plotkin, Logical full abstraction and PCF, Tbilisi Symp. Logic, Language and Comp., CSLI, 1997, 333–352.
Longley, J.R., and N. Wolverson, “Eriskay: a programming language based on game semantics”, presented at GaLoP III, Budapest, 2008. For further information, see the Eriskay project website at http://homepages.inf.ed.ac.uk/jrl/Eriskay

Longley, J.R., “Universal languages for certain game models”. Lingay source fi le available at
http://homepages.inf.ed.ac.uk/jrl/Eriskay/gamelangs.er
Melli`es, P.-A., Comparing hierarchies of types in models of linear logic, Inf. Comp. 189 (2004) 202–234.
McCusker, G., Games and full abstraction for FPC, Inf. Comp. 160 (2000) 1–61.
Plotkin, G.D., LCF considered as a programming language, Theor. Comp. Sci. 5 (1977) 223–255.
Schalk, A., What is a categorical model for Linear Logic?, lecture notes, University of Manchester, 2004.
Wolverson, N., “Game semantics for an object-oriented language,” PhD thesis, University of Edinburgh, approved 2008.
