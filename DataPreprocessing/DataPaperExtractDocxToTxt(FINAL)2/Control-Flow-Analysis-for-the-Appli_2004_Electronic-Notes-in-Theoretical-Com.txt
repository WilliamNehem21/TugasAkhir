 Electronic Notes in Theoretical Computer Science 99 (2004) 87–110  
www.elsevier.com/locate/entcs




Control Flow Analysis for the Applied π–calculus
Roberto Zunino 1 ,2
Dipartimento di Informatica, Universita` di Pisa, Italy

Abstract
We define a control flow analysis for the applied π–calculus and we prove it correct with respect to the operational semantics. Then, we apply our analysis to verify a simple security property.
Keywords: static analysis, control flow analysis, applied pi calculus, security


Introduction
The importance of mobile calculi is steadily growing. Often, when dealing with networked environments and distributed systems, mobile calculi offer a good approach with a solid formal ground for designing new systems and pro- tocols, as well as for studying existing ones. Mobile calculi are not meant to be full–featured programming languages for the implementation of systems; rather, they provide a core language for system specification that also facili- tates reasoning about the properties of systems.
In many cases, the system is designed to work in an unsafe (and possibly hostile) environment where security is the main concern and cryptography is commonly used to prevent disclosure of secret data and to ensure data authenticity and integrity. However, using a good cryptosystem is not enough to guarantee that a system behaves in a secure manner: in fact, even with

1 Partially supported by the EU project DEGAS and the MIUR project MEFISTO
2 Email: zunino@di.unipi.it


1571-0661 © 2004 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2004.02.004

unbreakable cryptography, there is still room for attacks (such as replay and man–in–the–middle attacks). Under those circumstances, formal proofs of correctness are often required. However, manually proving the correctness of a large system can be a tedious, error–prone and expensive task.
Automatic static analysis techniques can dramatically reduce the cost of the formal proofs. Type systems 3 and control flow analysis have been defined for many mobile calculi as the π–calculus and the Spi calculus [3]. Examples of control flow analysis for the π–calculus and the Spi calculus can be found in [5,4,7,6].
The applied π–calculus has been introduced by Mart´ın Abadi and C´edric Fournet in [2]. Its main advantage over other calculi lies in the fact that it does not use a fixed set of primitive operators (as encrypt, decrypt, sign, etc.) but follows a more general approach using an arbitrary set of terms and an equivalence relation that identifies semantically equivalent terms. In
[2] it is shown how this set can be chosen for handling both symmetric and asymmetric cryptography, key exchange, message authentication codes and other security–related primitives. In spite of this flexibility, many general results can still be proved to hold for every choice of the set above. The paper in [10] also describes some applications of the calculus.
In this work we deal with a slight variant of the applied π–calculus. The syntax and semantics are basically the same of [2], the only significant change being that substitution variables can be introduced only at certain points, as we shall see in Section 3. We offer a technique for statically analyzing processes via control flow analysis. Then we prove our analysis correct with respect to the operational semantics. These are our main results and, to the best of our knowledge, this is the first proposal for a static analysis of the applied π–calculus.
More in detail, in Section 2 we define the syntax of the applied π–calculus. Terms, plain processes and extended processes are described along with their intuitive meaning. The operational semantics is discussed in Section 3: we first introduce some auxiliary relations (α–conversion, structural equivalence and the >> reduction) and then we define the semantics of processes as a labeled transition system (the commitment relation). In Section 4 we introduce a control flow analysis for the applied π–calculus. In Section 5 we prove the correctness of our analysis (i.e. we show that the analysis agrees with the semantics) by establishing subject reduction. We deal with the existence of the minimum solution and we discuss some issues about its construction. Finally, in Section 6, we show how our analysis can be used to prove security properties.

3 We shall not discuss in any detail the various type systems proposed for process calculi; we only cite here [1].

The Applied π–calculus
In this section we survey the applied π–calculus. We introduce its syntax and we intuitively describe its semantics, which we shall define in Section
3. Our definition of the operational semantics and more deeply that of the static analysis benefit from some changes to the original syntax. This is why many of the definitions presented here may appear more complex than strictly necessary.


Syntax
We use the following sets:
N = {n[j] | i, j ∈ N} is the denumerable set of names;
L = {li | i ∈ N} is the denumerable set of labels;
X = {x[j] | i, j ∈ N} is the denumerable set of input variables;
Z = {z[j] | j ∈ N, li ∈ L} is the denumerable set of substitution variables
where all the n[j], li, x[j], z[j] are assumed distinct. Intuitively, a name rep-
i	i	li
resents a communication channel which can be used to send and receive data
of the form of terms (which we will define shortly); a label is used to mark a point in the program 4 ; an input variable is a placeholder for received values (e.g. “read x from channel ni and send x to channel nj”); a substitution vari- able is used during communication to convey data. Our use of substitution variables, as we will see, is more restricted than in the applied π–calculus as defined in [2].
To simplify the notation, we simply write n, l, x, zl (or ni, xi, zli ) where all their occurrences have the same indexes. For instance, we write fst(cons(ni, nj)) =
ni instead of fst(cons(n[k], n[m])) = n[k] and {n/x} instead of {n[k]/x[m]}.
i	j	i	i	j
Accordingly, in inference rules or in propositions involving names, input
variables and substitution variables, we sometimes write u to denote an ele- ment of N , X or Z to avoid being too verbose. We now give the definition of terms.
Definition 2.1 Given a signature Σ consisting in a set of function symbols,


4 This will be useful for static analysis. Moreover, labeling is performed automatically and labels are inserted in the internal representation of the process.

each with its own arity, terms are defined by the following grammar:
M := n	names
x	input variables
zl	substitution variables
f(M1,... , Mm)	function application
where f ∈ Σ, n ∈ N , x ∈ X , zl ∈ Z, l ∈L and m is the arity of f.
We adopt the common convention that constants are functions of arity 0, thus including them into terms. Examples of terms are M1 = encrypt(ni, nj), M2 = fst(cons(n, x)) and M3 = n where encrypt, fst and cons are func- tion symbols. According to the intended meaning of cons and fst, the two terms M2 and M3 should be equivalent: we shall address this point when we will define the semantics. Since names are terms, they have both the roles of communication channels and of data: this aspect is crucial for mo- bility. Moreover, names are also used to denote cryptographic keys and se- crets: for instance, encryption of a term M with a symmetric key n could be represented as encrypt(M, n). Similarly, decrypt(encrypt(M, n), n) could be used to model decryption. Asymmetric cryptography can be modeled as well: pri(n) and pub(n) can be used to model corresponding keys so that the term decrypt(encrypt(M, pub(ni)), pri(nj)) is equivalent to M if and only if i = j.
A ground term is a term without variables (of any kind).
Definition 2.2 Plain processes are recursively defined by the following gram- mar:
P := 0	nil
P1 | P2	parallel composition
!P	replication
νn.P	name restriction
if M1 = M2 then P1 else P2	conditional
M (x).P	input

M1⟨M2⟩l.P	output
Intuitively, 0 is the process that does nothing; P | Q runs P and Q con- currently; !P represents an unlimited number of instances of P running con- currently; restriction defines the scope of the name, actually creating a new

local name; a conditional compares two ground terms for equality; input re- ceives some value from the channel M (the subject), binds it to the variable x (the object) and then behaves as P (the continuation); output sends the value M2 (the object) to the channel M1 (the subject) and then behaves as P (the continuation).
The term used as the subject in input and output processes should evaluate to a name at run–time; otherwise they behave as 0. Also, note that labels are used to mark outputs.
For example, the following are processes:

A1 = n1(x).fst(x)⟨snd(x)⟩l1 .0 | n1⟨cons(n2, n3)⟩l2 .0 A2 = νn1. νn2.n0⟨sign(n2, pri(n1))⟩l0 .0 |
n0(x).if check(x, pub(n1)) = ok
then n0⟨removesign(x)⟩l1 .0 else n0⟨error⟩l2 .0 

Accordingly to the intuitive semantics, in the first example A1, fst(x) at run- time evaluates to a name (n2). The second example A2 shows a process that creates a new name (n2), signs it with a private key pri(n1) and sends it. Another process receives it, checks the signature and uses n2. Note that for A2 to work, the term check(sign(n2, pri(n1)), pub(n1)) should evaluate to ok and removesign(sign(n2, pri(n1))) should evaluate to n2.
In order to simplify the semantics, we extend the syntax of plain processes to include substitutions.

Definition 2.3 Extended processes are recursively defined by the following grammar:

A := P	plain process
A1 | A2	parallel composition
νn.A	name restriction
νzl.A	variable restriction
{M/zl}	substitution

A substitution process is used to bind some substitution variable to some term. For example
νzl.({n/zl} | zl⟨zl⟩l.0)
can be reduced to n⟨n⟩l.0. We will return on the issue of introducing and eliminating substitution variables in Section 3.
We write bound(A) for the set of all the u ∈ N ∪ X ∪ Z that occur in A under a restriction or as the object of an input. We define sym(A) to be the set of all the u ∈ N ∪X ∪Z that occur in A and sym(M ) to be the set of all the u ∈ N ∪X ∪Z that occur in M . We write free(A) for sym(A) \ bound(A). We also use vars(M ) for sym(M ) ∩ (X ∪ Z).
As usual, a context is a process (or a term) with a hole. There are contexts of type process with an hole of type process (as A1 | [−]), contexts of type process with an hole of type term (as n⟨[−]⟩.0) and contexts of type term with an hole of type term (as cons(n, [−])).
If sym(M ) ∩ bound(A) = ∅, we write A{M/zl} for the replacement of all free occurrences of zl with M . Of course, this constraint is always satisfied if we suitably α–convert A before substituting.

Operational Semantics
In this section we define a formal semantics of the applied π–calculus. We point out the differences with the semantics given in [2] and describe the rationale for those differences.
The semantics is defined by steps. First, α–conversion ( =α ), structural equivalence (≡) and reduction(>>) are introduced. Secondly, the commitment relation (−−α→) is used to define the actual semantics.
α–Conversion
As usual, α–conversion is a kind of variable renaming that is sometimes neces- sary: for instance, in the process
νn[0].n0⟨n[0]⟩l0 .0 | νn[0].n0⟨n[0]⟩l1 .0 | n0(x0).n0(x1).P
1	1	1	1
the values assumed by x0 and x1 are originated by two different ν and therefore should be different. Because of this, the operational semantics must allow

communication only if one n[0]
rewrite the above process into
has been renamed. For example we could

νn[0].n0⟨n[0]⟩l0 .0 | νn[1].n0⟨n[1]⟩l1 .0 | n0(x0).n0(x1).P
1	1	1	1

allowing communication.

Definition 3.1 We define α-conversion ( =α ) as the minimum equivalence relation on extended processes that is closed under contexts and such that

Res	νu[i].A =α νu[j].A{u[j]/u[i]}	if u[j] /∈ sym(A)
k	k	k	k	k
In	M (x[i]).P  =α  M (x[j]).P {x[j]/x[i]}	if x[j] /∈ sym(P )
k	k	k	k	k


Note that this form of α-conversion never changes the subscript index k. We have chosen to only rename the superscript so that, when dealing with static analysis, we can trace an α–converted name (or variable) to its origi- nating restriction. This is possible if we initially choose unique subscripts for names and variables, which we can always do before performing the analysis. Moreover, we choose u[0] to be the canonical name (or canonical variable) for all the names (or variables) of the form u[i]. Similarly, we say that a term is canonical if only canonical names and variables occur in it. This helps when
considering names or variables up to α–conversion.



Structural Equivalence

Syntax often imposes some unwanted structure on processes: for instance, while A1 | A2 and A2 | A1 are syntactically different processes, we want to identify them semantically. Moreover, we also want to identify some terms like fst(cons(n1, n2)) and n1 under the standard intuition for fst and cons. For these purposes we use structural equivalence.
We consider an equivalence relation on ground terms (Σ ▶ M1 = M2) that is closed under application of contexts (of type term with an hole of type term). This relation will be used to identify processes of the form A[M1] and A[M2] where A[—] is a context and Σ ▶ M1 = M2 (rule Context below). We sometimes write Σ /▶ M1 = M2 for ч(Σ ▶ M1 = M2).

Definition 3.2 Structural equivalence (≡) is the minimum equivalence rela-

tion on extended processes that is preserved by contexts and such that

A few points are noteworthy: Repl rule, for instance, is all we need to define the semantics of replication. Res-Scope “moves” restrictions: note that in some cases we have to α–convert u to enlarge its scope. This is mainly used in the following case, assuming u /∈ free(n(x).P ):
n(x).P1 | νu.(P3 | n⟨M ⟩.P2) ≡ νu.(n(x).P1 | n⟨M ⟩.P2 | P3)
The processes performing input and output are now side-by-side, so that they can communicate.
In the rule Context, A[—] is a context of type process with a hole of type term.
The Subst rule is a special case of the more general rule General-Subst	A{M/x}≡ νx.(A | {M/x})	if x /∈ sym(M )
that appears in [2], where there is no distinction between input variables
and substitution variables. In fact, if we allowed General-Subst we could simplify both syntax and semantics: there would be no need of distinguishing between X and Z (thus using a single set of variables) and no need of the reduction relation (that we are going to define in Section 3.3). In spite of this, it would be much harder to define the control flow analysis. The difficulty lies in the fact that at run–time new variables can appear and that statically

we cannot know anything about them. Unlike General-Subst, the rule Subst “remembers” which output generated the substitution: for instance, if the substitution {M/zl51 } is generated at run–time, we know that M was the object of the output whose label is l51.

Reduction
Although we decided not to use General-Subst, we cannot simply discard it. While we do not want to introduce new variables (via General-Subst applied left-to-right), we should permit the elimination of variables and the applica- tion of substitution processes to adjacent processes (via General-Subst applied right-to-left). To this purpose, we introduce the following reduction relation.
Definition 3.3 Reduction (>>) is the minimum transitive relation that is closed under contexts and such that

Equiv A1 >> A2	if A1 ≡ A2
Res	νzl.{M/zl} >> 0
Subst {M/zl} | A >> {M/zl} | A{M/zl}

We now compare reduction with structural equivalence “enriched” with the General-Subst rule. In order to do the comparison, we assume X = Z; i.e., we make no distinction between input and substitution variables. We define
≡GS in the same fashion as ≡ (Definition 3.2) but adding General-Subst to the rule set.
If A1 and A2 have no free substitution variables, the following property holds:
A1 >> A2 =⇒ A1 ≡GS A2

This property ensures that the reduction relation does not extend the seman- tics given in [2].
The converse implication
A1 ≡GS A2 =⇒ A1 >> A2

also holds as long as new substitution variables are not introduced in A2. Under this hypothesis, ≡GS is a conservative extension of >>.

Commitment


The commitment relation defines the actual semantics for extended processes,
µ
describing a labeled transition system. We write A1 ——→ A2 when the process
A1 performs the action µ and transforms itself into A2. Actions µ can be
→
inputs (n(M )), output (ν u .n⟨M ⟩) or silent moves (τ ).
The input action is performed when the process reads something from the outside world, and similarly the outputs sends data to the outside; in the last case the object could contain some restricted variables and names that become “public” (i.e. unrestricted) because of the output: these extruded
→
variables and names are shown in the action as the u vector (possibly empty).
The τ actions are used to represent internal communication (that is, from one process to another).
For example the process A = n(x).P1 | n⟨M ⟩l.P2 can perform the following actions





n(M1)
A
————→ P1{M1/x} | n⟨M ⟩ .P2

n⟨M ⟩
A ————→ n(x).P1 | P2
A ———τ—→ P {M/x} | P







→
where the u in the second action is empty.
We extend free, bound and sym to actions: free(µ) are all the u not under
→
a ν u that occur in µ; bound(µ) are the restricted ones; sym(µ) = free(µ) ∪
bound(µ). We are now ready to define the commitment relation.






µ
Definition 3.4 The commitment relation A1 ——→ A2 is defined by the fol-

lowing inference rules:

Comm	n⟨u⟩l.P | n(x).P ——τ→ P | P {u/x}



T hen
vars(M )= ∅


τ

if M = M then P1 else P2 ——→ P1


Else
vars(M1)= vars(M2)= ∅	Σ /▶ M1 = M2

if M = M then P else P ——τ→ P



n(M )
In	n(x).P ————→ P {M/x}


Out-T erm	n⟨M ⟩l.P	n⟨M ⟩	P


→

νu.n⟨M ⟩	→

Open-All
A1 ——————→ A2	ui ∈ free(M ) \ {n,u}

→
νui,u.n⟨M ⟩
νui.A1 ———————→ A2




Scope
µ
A1 ——→ A2	u /∈ sym(µ)

µ
νu.A1 ——→ νu.A2




P ar
µ
A1 ——→ A2	bound(µ) ∩ free(A3)= ∅

µ
A1 | A3 ——→ A2 | A3




Struct
µ
A1 >> A2	A2 ——→ A3	A3 >> A4

µ
A1 ——→ A4


Note that for inter–process communication, there is no need for extrusion. It suffices to apply α–conversion and structural equivalence to enlarge the scope of the restricted variables so that they can be made adjacent. The rule Comm is rather simple: it only transmits variables and names. If we want to transmit a more complex term, we can use structural equivalence in the

following way (assuming zl /∈ sym(P )):

n0(x).P | n0⟨cons(n1, n2)⟩l.0
≡	n0(x).P | νzl.({cons(n1, n2)/zl} | n0⟨zl⟩l.0)
≡	νzl.(n0(x).P | {cons(n1, n2)/zl} | n0⟨zl⟩l.0)
——τ→ νz .(P {z /x} | {cons(n ,n )/z } | 0)
l	l	1	2	l
>> νzl.(P {cons(n1, n2)/x} | {cons(n1, n2)/zl} | 0)
≡	P {cons(n1, n2)/x} | νzl.{cons(n1, n2)/zl}
>> P {cons(n1, n2)/x} | 0
≡	P {cons(n1, n2)/x}
Applying Struct we obtain
n (x).P | n ⟨cons(n ,n )⟩l.0 ——τ→ P {cons(n ,n )/x}
0	0	1	2	1	2
There is no rule for 0 since it cannot do any action. Moreover, we note that a conditional is executed only when the terms are ground and otherwise it behaves as 0. Inputs and outputs also behave as 0 unless the subject is a name (or is reduced via >> to a name).
Our operational semantics is label insensitive. In fact, the definition of the commitment relation never involve labels. Labels affect only the Subst rule in structural equivalence (≡) since the new substitution variable zl is chosen to match the label.

Control Flow Analysis
In this section we define the control flow analysis (CFA) for the applied π– calculus. The main difference between this and previous analyses for other calculi (e.g. π) lies in the fact that we need to handle Σ–equivalence between terms and deal with substitution processes.
The purpose of CFA is to determine statically which parts of a program may be reached from which other parts and what values are passed between them. In the applied π–calculus, control flow is rather primitive because there are no equivalents for loops, function calls or recursion that are commonly used in some other paradigms. However, it is useful to analyze the values that

are transmitted on channels and the values that are assumed by variables at run–time.








CFA for the Applied π–calculus


We let the set of values V al be the set of canonical ground terms, and use the following functions:
ρ : X ∪ Z → P(V al) is the abstract environment that maps a variable to the set of all values that may be assumed by that variable;
κ : N → P(V al) is the abstract channel environment that maps a channel (a name) to the set of all values that may be transmitted on that channel.
Thus, ρ(x) represents an upper bound to the (set of) values that x can assume at run–time. Similarly, κ(n) is an upper bound to the values that are transmitted over the channel n at run–time.
Instead, ρ(zl) has a twofold meaning. First, it is an upper bound to the values assumed by terms that occur as objects in outputs labeled with l. For example, in n⟨M ⟩l.P we expect ρ(zl) to include all the possible run–time values of M . Second, ρ(zl) is an upper bound to the values assumed by terms in substitutions of zl. For example, in {M/zl} | A we expect ρ(zl) to include all the possible run–time values of M . This double nature of ρ(zl) is related to the Subst rules of ≡ and >>.
Below, we define when a pair (ρ, κ) is acceptable for an extended process A; that is, (ρ, κ) gives an actual upper bound to run–time semantics. Since the problem in this form is obviously undecidable, we must put strong constraints on (ρ, κ) to make acceptability statically computable. We will call the pairs (ρ, κ) that satisfy such constraints CFA solutions (for an extended process A). After defining which pairs (ρ, κ) are CFA solutions, we must show that they actually agree with run-time semantics (i.e., that they are upper bounds): this
correctness property is called subject reduction and is proved in Section 5.

The following are natural, basic constraints that CFA solutions must sat- isfy:


	
 κ(n[i])= κ(n[j])

Σ–clos	∀x ∈ X , zl ∈ Z,n ∈ N , M1, M2 ∈ V al :Σ ▶ M1 = M2 =⇒
 M1 ∈ ρ(x) =⇒ M2 ∈ ρ(x)
M1 ∈ ρ(zl) =⇒ M2 ∈ ρ(zl)
 M1 ∈ κ(n) =⇒ M2 ∈ κ(n)
The α–inv constraint makes solutions stable under α–conversion while Σ–clos is used to identify Σ–equivalent terms, making ρ(x), ρ(zl) and κ(n) closed under Σ–equivalence.
We now define the abstract semantics for terms, that is the set of canon- ical values that a term may assume at run–time. Since a term may contain variables, its values depend on ρ.
Definition 4.1 (Abstract Semantics for Terms)
If V is a set of values, we write VΣ for its closure under Σ–equivalence. We define the abstract semantics of a term [—]]ρ by structural induction in the following way:
[[n[i]]]ρ	= {n[0]}Σ
k	k
[[x[i]]]ρ	= ρ(x[0])
k	k
[[z[i]]]ρ	= ρ(z[0])
lk	lk
[[f(M1,... , Mk)]]ρ = {f(m1,... , mk) | ∀i ∈ [1..k]: mi ∈ [[Mi]]ρ}Σ
Using the abstract semantics for terms, we are now ready to define the control flow analysis for the applied π–calculus.
Definition 4.2 (Control Flow Analysis)
A pair (ρ, κ) ∈ (X ∪Z → P(V al))×(N → P(V al)) that satisfies the α–inv and Σ–clos constraints is a CFA solution for an extended process A ((ρ, κ) |= A)

if and only if it satisfies the following clauses.

N il	(ρ, κ) |= 0	⇔ T rue
P ar	(ρ, κ) |= A1 | A2	⇔ (ρ, κ) |= A1 ∧ (ρ, κ) |= A2 Nres (ρ, κ) |= νn.A	⇔ (ρ, κ) |= A
V res (ρ, κ) |= νzl.A	⇔ (ρ, κ) |= A Subst (ρ, κ) |= {M/zl}	⇔ ρ(zl) ⊇ [[M ]]ρ Repl (ρ, κ) |= !P	⇔ (ρ, κ) |= P


if M1 = M2
If	(ρ, κ) |=
then P1 else P2
([[M1]]ρ ∩ [[M2]]ρ = ∅∨ (ρ, κ) |= P1)∧
⇔
(ρ, κ) |= P2

In	(ρ, κ) |= M (x).P	⇔ ∀n ∈ [[M ]]ρ : ρ(x) ⊇ κ(n) ∧ (ρ, κ) |= P

Out	(ρ, κ) |= M ⟨M ⟩l.P	⇔ ∀n ∈ [[M1]]ρ : κ(n) ⊇ ρ(zl) ∧
1	2
ρ(zl) ⊇ [[M2]]ρ ∧ (ρ, κ) |= P

Any (ρ, κ) is a solution for 0. A solution for a parallel composition of two processes is a solution for each of them. Restriction of names and (substitu- tion) variables does not affect solutions, as well as replication. A substitution requires that ρ(zl) is an upper bound to the possible values of the term M . A solution for a conditional must always be a solution for the “else” branch. If the abstract semantics of M1 and M2 are disjoint, we infer that the “then” branch is never executed and we put no further constraints on (ρ, κ). If this is not the case, we require that (ρ, κ) be valid for both branches. A solution for an input process must
ensure that ρ(x) is an upper bound to all values that are transmitted on all channels which are the result of the abstract evaluation of M and
be a solution for the input continuation P .
An output requires that
ρ(zl) is an upper bound to the abstract evaluation of M2 and
for every channel n that is the result of the abstract evaluation of M1, κ(n) contains ρ(zl) (and therefore it contains every value of M2) and
the solution is also a solution for the output continuation P .

The definition above is by no means the only possible one. The Appendix briefly surveys some alternatives. Indeed, there is huge room for further im- provements to our CFA. However, proving correctness for more precise CFA can be very hard. For instance, to prove subject reduction for the last CFA variant for conditionals given in the Appendix, one has to consider all the execution of the process, i.e. all the sequence of commitment steps.

Subject Reduction
In this section we show the correctness the CFA of Section 4 with respect to the formal semantics of Section 3 by proving a subject reduction result. Most proofs are by structural induction or rule induction, and are quite straightfor- ward. In the case, we simply sketch the proof.
We also deal with the existence of the minimum CFA solution and its construction.

Preliminary Lemmata
The following lemma is useful when dealing with substitutions and α–conversion.

Lemma 5.1 Substitution Lemma
u ∈X ∪ Z ∧ ρ(u) ⊇ [[M1]]ρ =⇒ [[M2]]ρ ⊇ [[M2{M1/u}]]ρ
(1)
u ∈X ∪ Z ∧ (ρ, κ) |= A ∧ ρ(u) ⊇ [[M ]]ρ =⇒ (ρ, κ) |= A{M/u}	(2)
n[j] /∈ sym(A) ∧ (ρ, κ) |= A =⇒ (ρ, κ) |= A{n[j]/n[i]}	(3)
k	k	k
Proof. It suffices to apply structural induction on M and A. In order to show (3) we also use α–inv.	 
Under suitable hypotheses, the context lemma stated below allows us to replace a subprocess or a subterm of a given extended process A without invalidating CFA solutions.
Lemma 5.2 Context Lemma Let A[—] be a context. We have


(ρ, κ) |= A[A1] ∧ ((ρ, κ) |= A1 ⇒ (ρ, κ) |= A2) =⇒ (ρ, κ) |= A[A2] (ρ, κ) |= A[M1] ∧ Σ ▶ M1 = M2 =⇒ (ρ, κ) |= A[M2]

(4)
(5)

Proof. By structural induction on the context A[—], also using Σ–clos for
(5).	 
Our CFA solutions are also stable under =α , ≡, >>.
Lemma 5.3 Stability Lemma
(ρ, κ) |= A1 ∧ A1 =α A2 =⇒ (ρ, κ) |= A2	(6)
(ρ, κ) |= A1 ∧ A1 ≡ A2 =⇒ (ρ, κ) |= A2	(7)
(ρ, κ) |= A1 ∧ A1 >> A2 =⇒ (ρ, κ) |= A2	(8)
Proof.	The proof is by rule induction on the definitions of the relations
=α , ≡, and >>; we use here both the Substitution Lemma and the Context Lemma. Most cases are straightforward: the most interesting one is that of
(7) when applying the Subst rule left-to-right.

M1⟨M2⟩l.P	≡	νzl.(M1⟨zl⟩l.P | {M2/zl})
In this case, the label l plays a crucial roˆle. The CFA definition for the output process in fact foresees the introduction of the variable zl by requiring that κ(n) ⊇ ρ(zl) and ρ(zl) ⊇ [[M2]]ρ. This allows us to show that (ρ, κ) is also a solution for the right hand–side process.	 

Subject Reduction
This is our main result that proves the semantic correctness of our CFA. It says that at run–time A performs a sequence of actions µi that have been “statically predicted” by the CFA solution (ρ, κ), provided that the inputs from the environment agree with the abstract channel environment 5 κ.
For proving subject reduction, it suffices to show the correctness for a
µ
single step A1 ——→ A2 and to show that CFA solutions are preserved by the
commitment relation, allowing induction on steps.
Theorem 5.4 Subject Reduction

µ
(ρ, κ) |= A1 ∧ A1 ——→ A2 =⇒
 µ = τ	=⇒ (ρ, κ) |= A2
µ = n(M ) ∧ κ(n) ⊇ [[M ]]ρ =⇒ (ρ, κ) |= A2

 µ =	→ ⟨M ⟩	=⇒ κ(n) ⊇ [[M ]]

∧ (ρ, κ) |= A

5 This hypothesis plays a crucial role when dealing with security properties. In Section 6 we show why it is important.

Proof. The proof is by rule induction on the definition of the commitment relation.	 

Existence of Solutions
The procedure induced by Definition 4.2 tests which pairs (ρ, κ) are acceptable solutions for a process A. In this section we show that, given a process A, the minimum CFA solution exists, according to the following ordering:
Definition 5.5 We write Sol for the set of the pairs (ρ, κ) that satisfy α–inv and Σ–clos. We partially order the set Sol in the following way:
 6u ∈X ∪ Z : ρ(u) ≥ ρ'(u)

(ρ, κ) ± (ρ', κ') ⇐⇒
 6n ∈U : κ(n) ≥ κ'(n)

The minimum CFA solution provides the tightest bound for values that can be assumed by variables and for values that can be sent over channels at run–time.
We write HS for the greatest lower bound of the set S ⊆ Sol, and HS for
its least upper bound. It is easy to see that (Sol, ±) is a complete lattice, since the ordering is pointwise and the properties α–inv and Σ–clos are preserved by H and H. We write (⊥, ⊥) for H∅.
The existence of the minimum solution follows from the fact that solutions form a Moore family:
Definition 5.6 Let S be a subset of Sol. S is a Moore family if and only if
6Z ⊆ S : HZ ∈ S.
The following theorem proves that the set S of the CFA solutions for a process A is a Moore family. Therefore, HS is the minimum CFA solution for A.
Theorem 5.7 (Existence of CFA Solutions)
Let A be an extended process. The set
S = {(ρ, κ) | (ρ, κ) |= A}
is a Moore family.
Proof.
Structural induction on A suffices to prove the following property:
6(ρ, κ) ∈ Sol : {(ρ, κ) | (ρ, κ) |= A Λ(ρ, κ) ± (ρ, κ)} is a Moore family (∗)

The theorem then follows by letting (ρ, κ)= (⊥, ⊥).
Since (∗) is a standard result for CFA solutions, the proof is very similar to those present in the literature. See e.g. [6] where the property above is proved for the π–calculus. We omit this proof.	 

Construction of CFA Solutions
We now briefly discuss a procedure which computes the minimum CFA solu- tion for a process A.
The standard approach is to derive from A a set of constraints over the domain D of all the pairs (ρ, κ) in such a way that the constraints are satisfied by (ρ, κ) if and only if (ρ, κ) |= A. Then a constraint–solving algorithm is applied, thus computing the minimum element D satisfying the constraints (see, e.g. [6,8]).
The generation of constraints from our CFA in Definition 4.2 can be per- formed in a rather straightforward way by induction on the structure of A. Nevertheless, some points are noteworthy:
The sets U , X and Z are infinite. This, however, poses no problems since we can restrict our procedure to deal only with sym(A) (i.e., the names and variables occurring in A) which is a finite set.
Our constraints are over the domain
D = (X ∪ Z → P(V al)) × (U → P(V al))
To make constraint–solving computable, we need a finite representation for its elements. This basically means we need a finite representation for sets of values that are closed under Σ–equivalence such as [M ]]ρ, ρ(zl) and κ(n).
Such a representation must have an operation to join sets of values: for instance, we need to reduce the constraint set {κ(n) ≥ [[M1]]ρ, κ(n) ≥ [[M2]]ρ} into {κ(n) ≥ V} for suitable V, the join of [M1]]ρ and [M2]]ρ.
Disjointness of two value sets must be decidable in order to handle the constraints generated by the If case.
Below, we briefly discuss some possible cases.
First, if Σ–equivalence is not decidable, there is no algorithm for solving constraints. Moreover, even if Σ–equivalence is decidable, we foresee difficul- ties if it does not admit normal forms. Also, the computational complexity of the constraint–solving algorithm is deeply affected by Σ–equivalence. We presently do not know when Σ–equivalence makes it possible to efficiently con- struct the minimum CFA solution. This is one of the main points for future

research.
We now consider the simplest case, i.e. when Σ–equivalence is the identity relation and we use the free term algebra. This is the case, e.g. for the Spi–calculus. Dealing with point ii, we could use tree grammars to finitely represent sets of values. This is an adequate representation for a free term algebra. Moreover, this representation permits to join two sets of constraints in a rather straightforward way (point iii) and to decide whether two value sets are disjoint (point iv). Some techniques for handling of tree grammars are described in [11].

A Simple Application for Security
We introduce as an example the Wide Mouthed Frog protocol, modeled in the applied π–calculus.
AA = νnK	.nAS⟨encrypt(nK	, nK	)⟩l1 .nAB⟨encrypt(M, nK	)⟩l2 .0 AS = nAS(xK		).nBS⟨encrypt(decrypt(xK	, nK	), nK	)⟩l3 .0

AB = nBS(x'
).nAB(xM ).AB' (decrypt(xM , decrypt(x'
, nKBS
)))

Asys = νnKAS .νnKBS .(AA | AB | AS)
In this scenario, two participants (A and B) share a long term symmetric key with a trusted server (S): the key KAS is known only to A and S, while the key KBS is known only to B and S. The participant A generates a new key KAB and wants to share it with B. To perform it in a secure way, A sends the new key to S, encrypting it with the key that shares with the server. The server S simply decrypts it and encrypts it again, this time using KBS; then it sends it to B. Principal B receives the key from the server and an encrypted term M from A: now the continuation B' can decrypt the key from the server and then decrypt M .
The purpose of this protocol is to keep the term M secret. Hopefully, provided B' is well-behaved, an eavesdropper or an attacker can not fool the system and make it reveal M . To prove that, we model the attacker as a Dolev–Yao attacker [9]. Such an attacker can eavesdrop on every public com- munication channel, thus reading everything that is sent along them. In the applied π–calculus, the public channels are the unrestricted names (or, equiv- alently, the ones that interact with the external environment). Moreover, a Dolev–Yao attacker can intercept messages rerouting them to himself so that they don’t reach the intended receiver. Finally, it can send any messages on

public channels if it can build them from both data learnt by eavesdropping and public data. In the applied π–calculus, “building a message” is done by applying some function symbol in Σ to known terms.
We divide the names in secret and public ones. The names under a re- striction are secret: in particular names with subscript KAB, KAS, KBS (and their α–conversions) are secret. All the others are public. For example, those with subscript AS, BS, AB are public.
To prove the secrecy of M , we search for a CFA solution (ρ, κ) such that M can not be deduced from the union of the sets κ(n), where n is a public name. However, note that it may be not enough to search for the minimum solution of A. This is because subject reduction ensures that the terms sent over public channels by the process A are bound by κ only as long as the terms sent over public channels by the attacker are bound by κ. If κ is too small, requiring the attacker’s messages to be bound by κ is too strong a hypothesis and thus unfaithful to both the Dolev–Yao model and reality.
Instead, we search for a CFA solution (ρ, κ) of A such that for every public name n we have κ(n)= K where
K includes the set of public names
K is closed under function application
K does not contain the message M .
The first requirement models the Dolev–Yao attacker’s initial knowledge, the second one models its ability to compute new messages, and the last one states the secrecy of M . Note that K represents both the values that are sent by the attacker to the process A and values that are sent by A itself; this implicitly models the fact that the attacker can intercept messages and use them to build new ones. Note that requiring the attacker to be bound by such a K is implied by the standard assumptions on the Dolev–Yao attacker. Therefore, if such a solution exists, subject reduction proves that M is kept secret even if A is under attack by a Dolev–Yao saboteur.
For instance, in the case AB' = 0, we can find such a solution by letting

κ(nKAB
) = {nKAB
}Σ, κ(nK
) = {nKAS
}Σ, κ(nK
) = {nKBS
}Σ and letting

κ(nAB) = κ(nAS) = κ(nBS) = ρ(xKAB
) = ρ(x'
) = ρ(xM ) = K, where

K is the minimum set of values closed under Σ–equivalence and function
application that satisfies the following constraints:

encrypt(nKAB , nKAS ) ∈ K
encrypt(M, nKAB ) ∈ K
M1 ∈ K =⇒ encrypt(decrypt(M1, nKAS ), nKBS ) ∈ K

Since M /∈ K, the process A preserves the secrecy of M .
Conclusions
We introduced a slight variant of the applied π–calculus. Many cryptographic primitive operations (encryption, decryption, signing, etc.) can be added to the applied π–calculus by modifying the equivalence relation on terms Σ ▶ M1 = M2. So, this calculus is particularly suited for specifying cryptographic protocols.
We defined a control flow analysis that is correct with respect to the op- erational semantics (subject reduction) and we discussed the existence of the minimum CFA solution and its construction.
Finally, we applied our CFA to show a simple security property.

References
M. Abadi. Secrecy by typing in security protocols. Journal of the ACM, 5(46):18–36, sept 1999.
Mart´ın Abadi and C´edric Fournet. Mobile values, new names, and secure communication. In Proceedings of the 28th ACM Symposium on Principles of Programming Languages (POPL’01), pages 104-115., January 2001.
Mart´ın Abadi and Andrew D. Gordon. A calculus for cryptographic protocols - the spi calculus.
Information and Computation, 148, 1:1–70, January 1999.
C. Bodei, M. Buchholtz, P. Degano, F. Nielson, and H. Riis Nielson. Automatic validation of protocol narration. In 16th IEEE Computer Security Foundations Workshop (CSFW’03), pages 126–140. IEEE Computer Society, 2003.
C. Bodei, P. Degano, F. Nielson, and H. Riis Nielson. Static analysis for secrecy and non- interference in networks of processes. Lecture Notes in Computer Science, 2127, 2001.
Chiara Bodei and Pierpaolo Degano. Static analysis for the π–calculus with applications to security. Information and Computation, 165:68–92, 2001.
Chiara Bodei, Pierpaolo Degano, Riccardo Focardi, Roberto Gorrieri, and Fabio Martinelli. Techniques for security checking: Non-interference vs control flow analysis. In Marina Lenisa and Marino Miculan, editors, Electronic Notes in Theoretical Computer Science, volume 62. Elsevier Science Publishers, 2002.
M. Buchholtz, H. Riis Nielson, and F. Nielson. Experiments with succinct solvers. Technical report, Informatics and Mathematical Modelling, Richard Petersens Plads, Building 321, DK- 2800 Kgs. Lyngby, Denmark, feb 2002.
D. Dolev and A.C. Yao. On the security of public key protocols. IEEE Transactions on Information Theory, IT-29(12):198–208, March 1983.
Cedric Fournet and Mart´ın Abadi. Hiding names: Private authentication in the applied pi calculus. In Proceedings of the International Symposium on software Security (ISSS’02), LNCS. Springer-Verlag, 2002.
F. Nielson, H. Riis Nielson, and H. Seidl. Cryptographic analysis in cubic time. Electronic Notes of Theoretical Computer Science, 62, 2002.

A  Alternative CFA Definitions
Speaking generally, there are two aspects that must be considered when defin- ing a CFA:
Correctness The (static) solutions must agree with the (run–time) semantics. In our case, subject reduction must hold.
Precision CFA should have as many solutions as possible. The more solutions we have, the tighter the bounds are.
For example if we accepted as solution only the pair (ρ, κ) such that ρ(x)= ρ(zl)= κ(n)= V al we would be correct but not precise. On the other hand, allowing every pair as a solution would be very precise but not correct.
Obviously, correctness is more important than precision: we should look at correctness as a mandatory requirement and at precision as a desirable one. We have analyzed a few variants of the CFA above; those on the conditional are the most interesting and worthy of discussion. One simple alternative to
the CFA for a conditional could be


(ρ, κ) |=
if M1 = M2
then P1 else P2
⇔ (ρ, κ) |= P1 Λ (ρ, κ) |= P2

However, while this is certainly correct 6 , it provides us with a less precise CFA allowing fewer solutions.
The CFA for conditionals that we chose,


if M1 = M2
(ρ, κ) |=
then P1 else P2
([[M1]]ρ ∩ [[M2]]ρ = ∅∨ (ρ, κ) |= P1)Λ
⇔
(ρ, κ) |= P2

is more precise since it does not require the solution to be valid for the “then” branch in some cases, i.e. when it can be statically proven that the “then” branch will never be executed.
Improving precision, we could even use this variant
(ρ, κ) |= if M1 = M2 then P1 else P2 ⇔
([[M1]]ρ ∩ [[M2]]ρ = ∅∨ (ρ, κ) |= P1)Λ
((∃M : vars(M )= ∅Λ [[M1]]ρ = [[M2]]ρ = [[M ]]ρ) ∨ (ρ, κ) |= P2)
that tries to prove statically that the “else” branch is never executed. However,

6 That is, subject reduction still holds.

this CFA is not correct as can be seen analyzing the following process:
!νn1.n0⟨n1⟩l.0 | n0(x0).n0(x1).if x0 = x1 then P1 else P2
Even if x0 and x1 are always bound to values that originate from “the same ν”, at run–time they will have different values because n1 must be α–converted.
Another way to refine our CFA could be to place labels on conditionals in the following way


if M1
li,lj
= M2 then P1 else P2

and imposing ρ(zli ) ≥ [[M1]]ρ and ρ(zlj ) ≥ [[M2]]ρ or (even better) some weaker constraint on ρ. This could allow some further refinement. For example in

if M

li,lj
M

then  if M

lk,lm M

then P

else P  else P


it should be enough to require (i) ρ(zlk ) ≥ ρ(zl1 ) ∩ ρ(zlj ) instead of (ii) ρ(zlk ) ≥ [[M1]]ρ. The constraint (i) could be weaker than (ii), since it could be that ρ(zl1 ) ∩ ρ(zlj ) Ç [[M1]]ρ. This variant appears to be both correct and more precise than our CFA. In fact our CFA abstract semantics for terms gives a global upper bound to run–time values of a term M , instead of a local one that depends on where M is used (this would require to label each occurrence of terms obtaining Ml). A similar approach can be taken on ρ: we could use local upper bounds for variables too.
