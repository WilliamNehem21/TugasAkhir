Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 348 (2020) 23–41
www.elsevier.com/locate/entcs


Deciding Quantifier-free Definability in Finite Algebraic Structures
Miguel Campercholi1	Mauricio Tellechea2 Pablo Ventura3
FaMAF
Universidad Nacional de Córdoba Córdoba, Argentina

Abstract
This work deals with the definability problem by quantifier-free first-order formulas over a finite algebraic structure. We show the problem to be coNP-complete and present a decision algorithm based on a semantical characterization of definable relations as those preserved by isomorphisms of substructures. Our approach also includes the design of an algorithm that computes the isomorphism type of a tuple in a finite algebraic structure. Proofs of soundness and completeness of the algorithms are presented, as well as empirical tests assessing their performances.
Keywords: Definability, logic, decision algorithm, complexity


Introduction
Given a logic L, a model-theoretic semantics for L is a function that assigns to each formula ϕ of L and each structure A for L a set of tuples from the domain of A. This set of tuples is called the extension of ϕ in A, and we usually think of these tuples as the interpretations that make ϕ true in A, though it also makes sense to think of them as the ones singled out, or named, by the properties expressed in ϕ. Various fundamental computational problems arise from this setting, of which surely the most prominent one is the satisfiability problem for L, that for a given formula ϕ from L asks whether there is model A such that the extension of ϕ in A is non-empty. The model-checking problem for L, which consists in computing, given a model A and a formula ϕ, the extension of ϕ in A, has also played an important role in computational logic. A third fundamental problem, the one that concerns us in this article, is the definability problem for L, which given a finite model A and a

1 Email:camper@famaf.unc.edu.ar
2 Email:mauriciotellechea@gmail.com
3 Email:pablogventura@gmail.com

https://doi.org/10.1016/j.entcs.2020.02.003 1571-0661/© 2020 Published by Elsevier B.V.
This is an open access article under the CC BY-NC-ND license (http://creativecommons.org/licenses/by-nc-nd/4.0/).

set R of tuples from A asks whether there is a formula ϕ such that the extension of ϕ in A agrees with R. This problem has been studied for several logics, due to its fundamental nature and its applications, for example to the Theory of Databases
[11] and in the Generation of Referral Expressions [10,4,3]. The computational complexity of the definability problem has also been investigated for various logics. The article [9] investigates the definability problem for classical propositional logic under the name of inverse satisfiability, proving it is complete for coNP in the general case. They also characterize for which special syntactical cases the problem lies in
P. It is proved in [5] that the definability problem is GI-complete (under Turing reductions) for first-order logic. For the primitive positive fragment of first-order logic the definability problem is coNEXPTIME-complete [12], and for basic modal logic [4] and some of its fragments [3] it is in P. In the article [1], it is shown that for the quantifier-free fragment of first-order logic with a purely relational vocabulary the definability problem is coNP-complete, and in the same article a parameterized version of the problem is proved to be complete for the complexity class W[1].
To illustrate the concept of definability let us look at an example. Let D =
⟨{⊥, T, u, uj}, Λ, V⟩ be the lattice depicted below, and let R = {(a, b) ∈ D2 : a ≤ b}.

T


u	u′


⊥

Figure 1. The lattice D


We want to know if R is quantifier-free definable in D. That is, if there exists a quantifier-free formula ϕ(x, y), in the vocabulary of D, such that R = {(a, b) ∈ D2 : D ▶ ϕ(a, b)}. It is easy to see that the formula ϕ(x, y) := (x V y) = y works. Next, consider the relation Rj = {(⊥, u), (⊥, uj), (⊥, T)}; is it quantifier-free definable in D? The answer is no, and here is why. Note that the map γ : {⊥, T} →
{u, T} is an isomorphism between sublattices of D, and quantifier free formulas are preserved by such maps. That is, if ϕ(x, y) is quantifier free and D ▶ ϕ(a, b), then D ▶ ϕ(γa, γb). Thus, for any structure, every relation definable by a quantifier-free formula is preserved by isomorphisms between substructures (we call these maps subisomorphisms). Returning to our example, we can see that (⊥, T) ∈ Rj but (γ⊥, γT) ∈/ Rj, so Rj is not preseved by γ, and thus it is not quantifier-free definable in D. Interestingly, the converse of this criterion holds for finite structures; i.e., if a A is a finite structure, then a relation R ⊆ Ak is quantifier-free definable in A if and only if R is preserved by all subisomorphisms of A (see Theorem 2.1 below).
This characterization of quantifier-free definable relations is applied in [2] to obtain an algorithm that decides the definability problem for the quantifier-free fragment of first-order logic with a purely relational vocabulary (called the open-

definability problem in [2]). In the current note, which continues and complements the work in [2], we develop an algorithm based on the same semantical character- ization but for algebraic vocabularies (i.e., without relation symbols). It is worth noting that in fragments of first-order logic that allow quantification, the relational and algebraic definability problems collapse, since, at the expense of introducing quantifiers, every formula can be effectively transformed into an equivalent one which is unnested. However, in the quantifier-free case the problems are not the same and require different algorithmic strategies. The main difference lies in the fact that computing the isomorphisms between substructures of a structure in the algebraic case, requires computing the subuniverses of the structure. The approach of our algorithm to decide definability in this article is based on the observation that computing the subuniverse generated by (the elements of) a tuple a¯ in a structure A is not far off from computing the isomorphism type of a¯ in a A (see Section 4).
In addition to presenting the above mentioned algorithm, we prove that the computational complexity of the quantifier-free definability problem for algebraic vocabularies is complete for coNP.
The paper is organized as follows. In the next section we fix notation and pro- vide the basic definitions. In Section 3 is the exposition of our complexity result. In Section 4 we introduce the algorithm that computes the isomorphism type of a tuple in an algebra. The algorithm to decide quantifier-free-definability for algebraic structures is presented in Section 5. In Section 6 some empirical tests are performed, showing that our algorithm performs better on models with a large amount of sym- metries. Finally, Section 7 provides a summary of the results obtained as well as further research directions which arise from the developments we present here.
Preliminaries
In this section we provide some basic definitions and fix notation. We assume basic knowledge of first-order logic. For a detailed account see, e.g., [7]. Given a first order vocabulary τ and k ∈ ω let Tk denote the set of τ -terms of depth k with variables from VAR := {x1, x2,..., xn,.. .}. We write T :=  k∈ω Tk for the set of all τ -terms over VAR. For a function or relation symbol s we write ar(s) denote the arity of s. In this note we are concerned with algebraic vocabularies, that is, without relation symbols. In this context, atomic formulas are of the form t = tj where t and tj are terms. A quantifier-free formula is a boolean combination of atomic formulas. We write ϕ(v1,..., vk) for a formula ϕ whose variables are all included in {v1,..., vk}. An algebra is a structure of an algebraic vocabulary; algebras are denoted by boldface letters (e.g., A, B, C,...) and their universes by the corresponding non-bold letter. Given an algebra A, a formula ϕ(v1,..., vk), and a sequence of elements a¯ = (a1,..., ak) ∈ Ak we write A |= ϕ(a¯) if ϕ is true in A under an assignment that maps vi to ai. We say that a subset R ⊆ Ak is quantifier-free definable in A (qf-definable for short) provided there is a quantifier-free first-order formula ϕ(x1,..., xk) in the vocabulary of A such that
R = {a¯ ∈ Ak : A |= ϕ(a¯)}.

In this article we study the following computational decision problem:
QfDefAlg
Input : A finite algebra A and a target relation R ⊆ Ak.
Question: Is R qf-definable in A?
Let A be an algebra. A subset S ⊆ A is a subuniverse of A if S is nonempty and it is closed under the fundamental operations of A. For a tuple a¯ = (a1,..., ak) ∈ Ak we write Sg(a¯) to denote the subuniverse of A generated by {a1,..., ak}. Let γ : dom γ ⊆ A → A be a function. we say that γ preserves R ⊆ Ak if for all (a1,..., ak) ∈ R ∩ (dom γ)k we have (γa1,..., γak) ∈ R. The function γ is a subisomorphism of A provided that γ is injective, dom γ is a subuniverse of A, and γ preserves the graph of f A for each f ∈ τ . (Note that a subisomorphism of A is precisely an isomorphism between two substructures of A.) The following result characterizing qf-definability in terms of subisomorphisms plays a central role in this article.
Theorem 2.1 [6, Thm 3.1]
Let A be a finite model of an arbitrary first order signature and let R ⊆ Ak. The following are equivalent:
R is definable in A by a quantifier-free first-order formula.
R is preserved by all isomorphisms between k-generated substructures of A.

QfDefAlg is coNP-complete
In what follows a graph is a model G of the language with a single binary relation E, such that EG is symmetric and irreflexive. In [1] it is proved that the following problem is complete for coNP.
QfDef[Graphs]
Input : A finite graph G and a target relation R ⊆ Gk.
Question: Is R qf-definable in G?
A subisomorphism of a graph G = (G, E) is an injective function γ : dom γ ⊆
G → G such that (a, b) ∈ E if and only if (γa, γb) ∈ E.
Theorem 3.1 QfDefAlg is coNP-complete.
Proof Given a finite graph G = (G, E) let ˆ0 and ˆ1 denote the first two positive integers not in G. We define the algebra G∗ := (G ∪ {ˆ0, ˆ1},f ) where f is the binary operation
f (a, b)=	ˆ1	if (a, b) ∈ E or a = b ∈ {ˆ0, ˆ1}
ˆ0	otherwise.
It is straightforward to check that:

If γ is a subisomorphism of G, then the extension γ∗ of γ given by γ∗(ˆ0) = ˆ0
and γ∗(ˆ1) = ˆ1 is a subisomorphism of G∗.
If δ is a subisomorphism of G∗, then δ[G] ⊆ G and δ|G is a subisomorphism of
G.
We prove next that ⟨G, R⟩ '−→ ⟨G∗, R⟩ is a polynomial time (Karp) reduction from QfDef[Graphs] to QfDefAlg. Clearly G∗ can be computed from G in polynomial time, so it remains to show that R is qf-definable in G if and only if R is qf-definable in G∗. Fix a finite graph G and R ⊆ Gk. Suppose R is not qf-definable in G. Then, by Theorem 2.1, there is γ, a subisomorphism of G, that does not preserve R. Now
(1) says that γ∗ is a subisomorphism of G∗, and since it does not preserve R, it follows that R is not qf-definable in G∗. For the remaining direction, suppose R is not qf-definable in G∗. Once again Theorem 2.1 produces a subisomorphism δ of G∗ that does not preserve R. It follows from (2), that δ|G is a subisomorphism of G that does not preserve R; hence R is not qf-definable in G.
Showing that QfDefAlg is in coNP is a straightforward application of Theorem
2.1. In fact, each negative instance ⟨A, R⟩ of QfDefAlg is witnessed by a bijection γ between subsets of A satisfying conditions easily checked in poly-time w.r.t. the size of ⟨A, R⟩.	2
It follows from the proof of Theorem 3.1 that the restriction of QfDefAlg to structures with a single binary commutative operation is already complete for coNP.
Computing the isomorphism type of a tuple
In this section we present an algorithm to compute the isomorphism type of a tuple a¯ in a finite algebraic structure A, and prove it to be correct. We start with some needed definitions and preliminary results.
Let A be a finite algebra, for each k ∈ ω we define the equivalence relation ≈k
over An by a¯ ≈k ¯b if and only if for all terms t, s ∈ Tk(x0,.  , xn−1) we have that
tA(a¯)= sA(a¯) ⇐⇒ tA(¯b)= sA(¯b).
Define the equivalence relation ≈ over An by a¯ ≈ ¯b if and only if a¯ ≈k ¯b for all k ∈ ω. For a¯ ∈ An let
Ka¯ := min{k ∈ ω : for all t ∈ Tk(x¯) there is tˆ∈ Tk−1(x¯) such that tA(a¯)= tˆA(a¯)}.
Note that, since A is finite, this minimum always exists.
Lemma 4.1 Let A be a finite algebra and a¯, ¯b ∈ An.
If a¯ ≈Ka¯ ¯b, then for any term t(x¯) there is a term tˆ(x¯) ∈ Tl with l < Ka¯ such that tA(a¯)= tˆA(a¯) and tA(¯b)= tˆA(¯b).
If a¯ ≈Ka¯ ¯b, then a¯ ≈ ¯b.
Proof (i) Observe first that from the definition it follows that Ka¯ = K¯b; we write
K for Ka¯. Fix a term t(x¯). If t(x¯) ∈ TK−1 we can take t = tˆ, so suppose t ∈ TK+j

with j ≥ 0. We show that tˆ exists by induction on j. Suppose j = 0; by the
definition of Ka¯ there is tˆ ∈ TK—1 such that tA(a¯) = tˆA(a¯), and since a¯ ≈K ¯b it
follows that tA(¯b) = tˆA(¯b). Assume next that j > 0 and suppose t = f (t1, ..., tr),
with each ti ∈ TK+j—1. By the inductive hypothesis, there are terms tˆ1, ..., tˆr ∈ Tu
with u < K, each satisfying tA(a¯) = tˆA(a¯) and tA(¯b) = tˆA(¯b). That means
i	i	i	i
t˜:= f (tˆ1, ..., tˆr ) ∈ Tu+1 satisfies t˜A(a¯)= tA(a¯) and tˇA(¯b)= tA(¯b). Since u +1 ≤ K,
by the case j =0 we have a term tˆ∈ Tl with l < K for which tˆA(a¯)= tA(a¯)= tA(a¯)
and tˆA(¯b)= t˜A(¯b)= tA(¯b).
(ii) Let t, s ∈ T such that tA(a¯) = sA(a¯). Take tˆ, sˆ the terms given by (i).

Since
tˆA(a¯) =
sˆA(a¯), by the hypothesis we have
tˆA(¯b) =
sˆA(¯b), and therefore

tA(¯b)= sA(¯b).	2
Next we introduce, in the form of pseudocode, the algorithm that computes the function isoType (see Algorithm 1 below). This function takes a finite algebra A and a tuple a¯ from A and returns a representation of the isomorphism type of a¯, and the subuniverse of A generated by a¯ listed in a specific order. The isomorphism type is obtained by traversing the terms in a specified order and evaluating them on a¯. As we shall see (Corollary 4.3), it suffices to record which terms return the same value to capture the isomorphism type of a¯.
Let us describe how Algorithm 1 works. Fix an input algebra A with vocabulary τ (assume the function symbols in τ are listed in a specific order). Given a tuple a¯ ∈ An, at the start of the algorithm, variable V is set to [a0,.  , an—1]. Then the
while loop starts, and the elements added to V are obtained by applying fundamental operations of A to earlier values in V. Thus, all elements in V belong to Sg(a¯). Vari- able P records the repetitions in appearances of such elements as they are computed, while variable H stores the indexes where each element of Sg(a¯) appears for the first time in V. At the end of each pass through the while loop, variable N is assigned with the indexes that were added to H on that pass. Since A is finite, eventually no new elements are produced, and N is assigned with the empty list. This guarantees termination and the fact that all elements of Sg(a¯) are listed in V when the algorithm halts. Observe that the while loop is executed exactly Ka¯ times on input a¯. We remark that lines 3 and 16 - 17 in Algorithm 1, whose purpose is to initialize and update the variable VJ, are not actually needed to compute the function isoType, but are included to make our proofs easier to follow.
To compute elements in V on each pass, for each arity of some fundamental operation we construct a list T of tuples of indexes of elements where the fundamental operations of that arity will be applied. We require these tuples have at least one element that has not appeared before to avoid unnecessary computations.
To illustrate how this algorithm functions let us work out an example.  Let
D = ⟨{T, ⊥, u, uJ}, Λ, V⟩ be the lattice from the introduction (see Figure 1). The
fundamental operations are assumed to be ordered: [Λ, V]. On input D, a¯ = (u, uJ, ⊥), the variables are initialized as follows:
V = [u, uJ, ⊥]	P = [[0], [1], [2]]	H = [0, 1, 2]	N = [0, 1, 2].
After the first pass through the while loop the state is:

V = [u, uj, ⊥, u , ⊥ , ⊥ , ⊥
, uj
, ⊥ , ⊥ , ⊥ ,

`u˛Λ¸ux `u˛Λ¸ux′ `u˛Λ¸⊥x `u˛′Λ¸ux u`′˛Λ¸ux′
u`′˛Λ¸⊥x `⊥˛Λ¸ux ⊥`˛Λ¸ux′

`⊥˛Λ¸⊥x `u˛V¸ux `u˛V¸ux′ `u˛V¸⊥x `u˛′V¸ux u`′˛V¸ux′ u`′˛V¸⊥x `⊥˛V¸ux ⊥`˛V¸ux′ `⊥˛V¸⊥x
P = [[0, 3, 12, 14, 18], [1, 7, 16, 17, 19], [2, 4, 5, 6, 8, 9, 10, 11, 20], [13, 15]]
H = [0, 1, 2, 13]
N = [13].

Now the element T, which was not in V before, makes its first appearance in position
13. Thus, on the next pass the fundamental operations will be applied to all pairs with elements from [u, uj, T, ⊥] in which T appears at least once. So, the next round produces:

V = V+[ u , uj , ⊥ , u , uj
, ⊥ , T , T , T , T , T , T
, T , T ]

`u˛Λ¸Tx u`′˛Λ¸Tx `⊥˛Λ¸Tx `T˛Λ¸ux T`˛Λ¸ux′ `T˛Λ¸⊥x `T˛Λ¸Tx `u˛V¸Tx u`′˛V¸Tx `⊥˛V¸Tx `T˛V¸ux T`˛V¸ux′ `T˛V¸⊥x `T˛V¸Tx
P = [[0, 3, 12, 14, 18, 21, 24], [1, 7, 16, 17, 19, 22, 25], [2, 4, 5, 6, 8, 9, 10, 11, 20, 23, 26, ],
[13, 15, 27, 28, 29, 30, 31, 32, 33, 34]]
H = [0, 1, 2, 13]
N = [ ].
The variable N is now empty due to the fact that no new elements have been pro- duced, so Algorithm 1 halts returning the partition P and U = [u, uj, ⊥, T]= Sg(a¯). Running the algorithm for the tuple ¯b = (uj, u, ⊥) we get:
V = [uj, u, ⊥, uj, ⊥, ⊥, ⊥, u, ⊥, ⊥, ⊥, ⊥, uj, T, uj, T, u, u, uj, u, ⊥, uj, u, ⊥, uj, u, ⊥, T, T, T, T, T, T, T, T]
H = [0, 1, 2, 13]
P = [[0, 3, 12, 14, 18, 21, 24], [1, 7, 16, 17, 19, 22, 25], [2, 4, 5, 6, 8, 9, 10, 11, 20, 23, 26],
[13, 15, 27, 28, 29, 30, 31, 32, 33, 34]]
U = [uj, u, ⊥, T].
Since the final partitions are the same for a¯ and ¯b, by Corollary 4.3 below, the map
γ from [u, uj, ⊥, T] to [uj, u, ⊥, T] is a subisomorphism satisfying γ : a¯ '→ ¯b.
Soundness and completeness
For X a variable name in {V, Vj, P, H, N} and k ∈ {0,..., Ka¯}, let
Xa¯,k be the value of variable X in a run of Algorithm 1 with input A, a¯, after k
executions of the while loop.
Also, given an arity r of a function symbol of A, let

r
a¯,k
be the value assigned to variable T in a run of Algorithm 1 with input A, a¯,

once an arity r has been fixed in the for loop (line 10), during the kth execution of the while loop.
We write Xa¯ for Xa¯,Ka¯ , and for k > Ka¯ we define Xa¯,k to be Xa¯. The subindex a¯ is omitted when no confusion may arise.

Algorithm 1 Tuple isomorphism type
1 function IsoType(A, a¯)
2	V = [a0,..., an−1]


d A is an algebra and a¯ is a tuple from A

V′ = [“x0”,..., “xn−1”]	d this is a list of variables (terms are represented as strings)
P = [B1,..., Bk] the partition of {0,...,n — 1} where i, j are in the same block iff ai = aj
H = sorted([min(Bj ): Bj ∈ P])	d sorted increasingly
N = H
arities =[r1, ..., rk]	d where r1 < ... < rk are all the arities of operations in A
while N /= ∅ do
H_old = copy(H)
for r ∈ arities do
T = sorted([¯L ∈ (H_old)r : Lj ∈ N for some j])	d sorted lexicographically
for ƒ ∈ op(r) do	d op(r) is the list of operation symbols of arity r in the order given by z
for ¯L ∈ T do
value = ƒ A(V[L0], ..., V[Lr−1])
append value to V
term = ƒ ++ “(” ++ V′[L0] ++ “, ” ++ ... ++ “, ” ++ V′[Lr−1] ++ “)”
append term to V′
d update of the partition P
if there is j ∈ H such that value = V[j] then	d value was already in V
add |V|— 1 to the block of P that contains j
else	d value is new
add the block {|V|— 1} to P
add |V|— 1 to H

d update of N
N = [L : L ∈ H and L ∈/ H_old]
U = [V[j]: j ∈ H]	d U lists the elements of Sg(a¯) in the order they appeared in V
return P, U

Given a tuple a¯ ∈ An and k ∈ ω let ρa¯,k be the equivalence relation over
Tk(x0,..., xn—1) defined by t ρa¯,k s ⇐⇒ tA(a¯) = sA(a¯). Also, Eq(Y ) denotes the set of all equivalence relations over the set Y . The following lemma provides a series of technical results necessary to establish the soundness of Algorithm 1, which is done in Corollary 4.3 below.
Lemma 4.2 For any a¯ ∈ An and k ∈ ω we have:
Each member of VJ is term in the variables x0,..., xn—1 of degree at most k.
The invariant Vk[i]= VJ [i]A(a¯) holds throughout the for loop in line 13.
If a¯ ≈k ¯b then Xa¯,k = X¯b,k for X any variable name in {VJ, P, H, N}.
For all 1 ≤ k ≤ Ka¯ there is a function
Fk : Tk(x0,..., xn—1) × Eq(Tk—1(x0,..., xn—1)) → ω,
such that for each t ∈ Tk(x0,..., xn—1) the index i = Fk(t, ρa¯,k—1) satisfies
i ≤ |Vk|− 1 and tA(a¯)= Vk[i].
For all k ≤ Ka¯ we have that Pk determines Xj for all j < k and X any variable name in {VJ, P, H, N}.
If Pa¯ = P¯b, then a¯ ≈ ¯b.

Proof (i) is easily proved by induction in k. (ii) is clear from lines 14 to 17.
We proceed by induction in k. The case k = 0 is straightforward. Assume now k +1 ≤ min(Ka¯, K¯b), and suppose a¯ ≈k+1 ¯b. Since a¯ ≈k ¯b, by our inductive hypothesis we have that
Xa¯,k = X¯b,k for X any variable name in {VJ, P, H, N}.
Note that the first line executed when starting the k + 1th run of the while loop sets the value of H_old to the value of Hk. Now, observe that the value assigned to T for

each arity r only depends on H_old and Nk. Thus Tr
r b,k+1
for all arities r.

This, along with the fact that the function symbols at the for loop starting at Line 12

appear always in the same order, implies that VJ
J
b,k+1
. We prove next that

Pa¯,k+1 = P¯b,k+1; suppose the indexes i and j are in the same block of Pa¯,k+1. That is,

Vk+1(a¯)[i]= Vk+1(a¯)[j], so, by (ii), we have VJ
[i]A(a¯)= VJ
[j]A(a¯). Now, (i)

says that VJ
(a¯)[i] and VJ
(a¯)[j] are terms of degree at most k + 1, and they agree

on a¯. Hence they agree on ¯b, since a¯ ≈k+1 ¯b. Invoking (ii) once again yields that i
and j are in the same block of P¯b,k+1. From the fact that Pa¯,k+1 = P¯b,k+1 it easy to see that Ha¯,k+1 = H¯b,k+1 and Na¯,k+1 = N¯b,k+1. In particular, for any l ≤ min(Ka¯, K¯b) we have that Na¯,L = ∅ if and only if N¯b,L = ∅. So Ka¯ = K¯b, from which it follows at once that (iii) holds for k +1 > min(Ka¯, K¯b).
Take t = f (t0,..., tr—1) ∈ Tk+1 and suppose k +1 ≤ Ka¯. For k = 0, define
F0(xj)= j. If k ≥ 1, by inductive hypothesis we have the function Fk, and thus we can obtain indexes i0 := Fk(t0, ρk—1),..., ir—1 := Fk(tr—1, ρk—1) functionally from t
and ρk (obviously t0,..., tr—1 can be obtained as functions of t and ρk—1 = ρk∩T 2  ).
If k = 0, just take i0 := F0(t0),..., ir—1 := F0(tr—1). Next, define

t˜0 := VJ [i0]

.
t˜r—1 := VJ [ir—1],
and once again, note that these t˜L can be obtained functionally since VJ



can be

obtained functionally from ρk. Also, by our inductive hypothesis, we have tA(a¯)= 
f (t˜0,..., t˜r—1)A(a¯).
Assume first that there is l ∈ {0,...,r −1} such that iL ∈ Hk \Hk—1. Then iL ∈ Nk,
so ⟨i0,..., ir—1⟩∈ Tr	, and we have that the term f (t˜0,..., t˜r—1) is appended to VJ,
say with index j, during the (k + 1)th pass of the while loop. Observe that j only
depends on the signature of A and the numbers Tu	 for u an arity less or equal
than r. But Tu	depends only on Hk and Nk, which in turn are determined by ρk.
Thus j can be obtained as a function of t and ρk, and we can define Fk+1(t, ρk) := j in the case that there is l ∈ {0,...,r − 1} such that iL ∈ Hk \ Hk—1. Suppose on the other hand that i0,..., ir—1 ∈ Hk—1. Then, by (i), we have that t˜0,..., t˜r—1 ∈ Tk—1, and thus f (t˜0,..., t˜r—1) ∈ Tk. Hence, in this case we can define Fk+1(t, ρk) := Fk(f (t˜0,..., t˜r—1), ρk—1).
Notice first that, for j ≤ k, we have Pj is the restriction of Pk to the set

{0, ..., |Vj| − 1}. Also, Hj = [min(B) : B ∈ Pj], so that Pj determines Hj. On
the other hand, N0 is defined as H0, while Nj+1 = Hj+1 \ Hj. Observe also that VJ is
also determined just by the length of a¯, and that VJ	is obtained from Hj and Nj,
so it is determined by Hj and Hj—1. Using these observations, the conclusion follows now from an easy inductive argument.

Let K = Ka¯. By (v), for every k ≤ K we have Pa¯,k = P¯b,k
J
a¯,k
J
b,k
. Let

t, s ∈ TK such that tA(a¯)= sA(a¯). Define i = FK(t, ρa¯,K—1) and j = FK(s, ρa¯,K—1).

Define also
ˆ	J
a¯,k
[i] and
J
a¯,k
[j].  This means
tˆA(a¯) =
sˆA(a¯) and, since

J
a¯,K
J
b,K
, we have tˆA(¯b) = sˆA(¯b), which in turn implies tA(¯b) = sA(¯b). This

shows a¯ ≈K ¯b, so by Lemma 4.1.(ii) we have a¯ ≈ ¯b.	2
Given a finite algebra A and a¯ ∈ An, define iType(a¯) and iUniv(a¯) by isoType(A, a¯)
= (iType(a¯), iUniv(a¯)). Notice that iUniv(a¯) is a list without repetitions of all the elements in Sg(a¯).
The next corollary summarizes the results collected in Lemma 4.2 using the terminology just introduced. It shows that the output of our algorithm captures the isomorphism type of a tuple a¯ in a finite algebraic structure.
Corollary 4.3 Let A be a finite algebra. Then for any a¯, ¯b ∈ An the following are equivalent:
a¯ ≈ ¯b
iType(a¯) = iType(¯b).
Moreover, if either of these conditions hold, then the map γ : iUniv(a¯)[j] '→ iUniv(¯b)[j] for j ∈ {0, ..., | iUniv(a¯)|− 1} is an isomorphism from Sg(a¯) into Sg(¯b) mapping a¯ to ¯b.
Proof If a¯ ≈ ¯b, in view of Lemma 4.2.(iii) we have iType(a¯) = iType(¯b). Conversely, if iType(a¯) = iType(¯b), then by lemma (4.2).(vi) we have a¯ ≈ ¯b. In either case, by
lemma (4.2).(iii), we get Xa¯ = X¯b for X ∈ {VJ, P, H, N}. In particular, Ha¯ = H¯b, from which it follows that | iUniv(a¯)| = | iUniv(¯b)|. Since all the elements in iUniv(a¯) (and also those in iUniv(¯b)) are different, we have that γ is a well-defined bijection.
Also, since Pa¯,0 = P¯b,0, we have that γ sends each aj into bj. To prove γ is an
homomorphism, let t be a term. Let i ∈ Ha¯ be such that tA(a¯) = Va¯[i], and define
tˆ = VJ [i]. By (ii), t and tˆ agree on a¯, hence they also agree on ¯b. So we have
γ(tA(a¯)) = γ(tˆA(a¯)) = V¯[i] = VJ¯[i]A(¯b), and since VJa¯ = VJ , this equals tˆA(¯b) = 
b	b	¯b
tA(¯b)= tA(γ(a¯)).	2

Computing QfDefAlg
In this section we present our algorithm to decide qf-definability in a finite algebraic structure. The algorithm is based on a slight improvement of Theorem 2.1, stated below as Corollary 5.1.
Let a¯ = (a1,..., ak) be a tuple. We define the pattern of a¯, denoted by pattern a¯, to be the partition of {1,..., n} such that i, j are in the same block if and only if

ai = aj. For example, pattern(a, a, b, c, b, c)= {{1, 2}, {3, 5}, {4, 6}}. We write [a¯♩ to denote the tuple obtained from a¯ by deleting every entry equal to a prior entry. E.g., [(a, a, b, c, b, c)♩ = (a, b, c). Let R be a relation and θ a pattern, we define:
[R♩ := {[a¯♩ : a¯ ∈ R},
spec(R) := {|[a¯♩| : a¯ ∈ R},
Rθ := {a¯ ∈ R : pattern a¯ = θ}
Given a tuple a¯ from A and relations R1,..., RL over A, let relType(a¯, R1,..., RL) ∈
{True, False}L be the tuple (R1(a¯),..., RL(a¯)). For a positive integer k let A(k) :=
{(a1,..., ak) ∈ Ak : ai = aj ⇔ i = j}.
Corollary 5.1 Let A be a finite algebra, R ⊆ Am and let R1,..., RL be all the relations of the form [Rpattern a¯♩ for a¯ ∈ R. The following are equivalent:
R is qf-definable in A.
R1,..., RL are qf-definable in A.

For all k ∈ spec(R) and for all
a¯, ¯b ∈ A(k) we have that a¯
≈ ¯b implies

relType(a¯, R1,..., RL) = relType(¯b, R1,..., RL).
Proof The equivalence between (i)⇔(ii) is an easy exercise, and (ii)⇔(iii) is just a restatement of Theorem 2.1.	2

Breakdown of Algorithm 2
Let A be an finite algebra and let R ⊆ An. Our strategy to decide if R is qf-definable in A can be summarized as follows.
Compute all the relations of the form [Rpattern a¯♩ for a¯ ∈ R. Suppose these are
R1,.  , RL.
For each k ∈ spec(R) compute the partition induced by the equivalence relation
≈ on A(k).
If for some k ∈ spec(R) there are a¯, ¯b ∈ A(k) such that relType(a¯, R1,.  , RL) /=
relType(¯b, R1,..., RL) and a¯ ≈ ¯b return False. Otherwise, return True.
Step (i) strips down the target relation into relations without superfluous informa- tion. This can have a serious impact on performance, given that the search space depends exponentially on the arity of the target.
An obvious method for carrying out steps (ii) and (iii) is to use the function isoType to tag each tuple in k∈spec(R) A(k) with its isomorphism type, and every time two tuples have the same iType check that they have the same relType with respect to R1,..., RL. Clearly, it is convenient to carry out this test as soon as two tuples with the same isomorphism type are discovered, because if it fails the algorithm can stop (and return False). Another observation to improve on this first
approach is that, whenever we find tuples a¯, ¯b with the same isomorphism type, we
have access (essentially without any further computational cost) to an isomorphism
γ between Sg(a¯) and Sg(¯b). If two tuples are connected by γ, they have the same

isomorphism type, and thus it suffices to compute the isomorphism type of one of them. These observations together with a deliberate strategy to cycle through the tuples comprise the main ideas behind our algorithm. We explain next how they are implemented.
At every point during an execution, the data stored in orbitsk is a partition of A(k) where each block is annotated with some additional information. We call these annotated blocks orbits, and they have the form (B, RT,T,U ) where B ⊆ A(k) is the actual block, RT is the relType of all tuples in B, T shall store the iType of the tuples in B (when known), and U shall store the iUniv of a tuple in B (when known). When the algorithm starts, every block is a singleton annotated with its relType, and T ,U are set to Null. The algorithm traverses and processes
the tuples in k∈spec(R) A(k) in a DFS-like fashion. The tree that is traversed is comprised by the subuniverses of A and has A as its root. At every point of an execution, the algorithm is working on a node S of this tree by processing the tuples in  k∈spec(R) S(k). To keep track of the current and previously visited nodes, and the tuples already processed at each node, a stack is used. The entries in the stack have the form (S, L, G) where S is a subuniverse, L is the list of tuples from S still to be processed, and G ⊆  k∈spec(R) S(k) is a set of tuples such that: every tuple in G generates S, and no two tuples in G have the same isomorphism type. (The point of keeping track of such a G shall become clear below.) The stack is initialized with (A, L0, ∅) where L0 is a list of the tuples in k∈spec(R) A(k) ordered increasingly by arity. The first tuple processed during an execution is the first element in L0, and every time the algorithm is ready to process a new tuple, there is a triplet (S, L, G) on the top of the stack and the first element of L is popped and processed. To see how a tuple is processed, suppose the top of the stack is (S, L, G) and a tuple a¯ has been popped from L. If the isomorphism type of a¯ is known (i.e., if a¯ belongs to an orbit with known type), we pop the next tuple in L (if there are no more tuples in L, the entry (S, L, G) is removed from the stack). If, on the other hand, the type of a¯ is unknown, the function isoType is called to compute it, and the next step is to search through the orbits to see if there is one tagged with iType(a¯). However, which orbits we inspect (and the behaviour of the algorithm afterwards) depends on
whether Sg(a¯) is smaller than S.
Case |Sg(a¯)| = |S|. Here we only inspect the orbits of tuples in G for one tagged with iType(a¯) (to see why this suffices see Lemma 5.3). If none of these orbits is tagged with iType(a¯), we call the function tag_orbit to tag a¯’s orbit with iType(a¯) and iUniv(a¯), and add a¯ to G. If, on the other hand, there is an orbit (B, RT, T, U ) of an element in G with T = iType(a¯), then, by Corollary 4.3, the function γ : iUniv(a¯)[i] '→ U [i] is a subisomorphism of A. So, we proceed to merge orbits containing tuples connected by γ. In particular, the orbit containing a¯ is merged
with (B, RT,T,U ), and thus a¯ ends up in an orbit tagged with iType(a¯). The
merging is done by the function try_merge_orbits (see Algorithm 3), which also checks that any two orbits to be merged have the same relType (if this test fails, Algorithm 2 stops and returns False).
Case |Sg(a¯)| < |S|. In this case we inspect all orbits in orbits|a¯| in search for one



Algorithm 2 Quantifier-free Definability Algorithm
function isQfDefAlg(A, R)
d A is an algebra and R is a relation over A
targets = (R1,..., Rl) where the Rj ’s are all the distinct relations of the form [Rpattern a¯♩ for
a¯ ∈ R.
spec = sorted(spec(R))	d sorted increasingly
for k ∈ spec do
orbitsk = {({a¯}, relType(a¯, targets), Null, Null): a¯ ∈ A(k)}	d initialization of the orbits
orbits = {orbitsk : k ∈ spec}
tuples_to_process = sorted(S	A(k))	d sorted decreasingly by arity
stack = [(A, tuples_to_process, ∅)]	d initialization of the stack
while stack is not empty do
Let (current_sub, tuples_to_process, generators) be a reference to the top of stack
while tuples_to_process /= [] do
a¯ = pop first element of tuples_to_process
if Type(a¯)= Null then	d a¯’s type is unknown
(type_a, universe_a)= IsoType(A, a¯)
if |universe_a| = |current_sub| then	d Sg(a¯) is not smaller
if there is (B, RT, T, U) ∈ {orbits of tuples in generators} such that type_a = T then
g = the isomorphism from universe_a to U
if not try_merge_orbits(g, orbits) then	d see Algorithm 3
return False
else	d a¯’s type is new
tag_orbit(a¯, type_a, universe_a)
add a¯ to generators
else	d Sg(a¯) is smaller
if there is (B, RT, T, U) ∈ orbits|a¯| such that type_a = T then	d a¯’s type is not new
g = the isomorphism from universe_a to U
if not try_merge_orbits(g, orbits) then	d see Algorithm 3
return False
else	d a¯’s type is new
tag_orbit(a¯, type_a, universe_a)
new_current_sub = universe_a
new_tuples_to_process = sorted(S	universe_a(k))

new_generators = {a¯}

d push new node on the stack

push (new_current_sub, new_tuples_to_process, new_generators) onto stack
tag_orbit(a¯, type, universe)
break
if tuples_to_process = [] then
delete top of the stack
return True


with isomorphism type iType(a¯). If there is no such orbit, then orbit containing a¯ is annotated with iType(a¯) and iUniv(a¯). We also push (Sg(a¯), Lj, {a¯}) on top of the stack (i.e. we move to a new node of the subuniverse tree). If there is an orbit in orbits|a¯| tagged with iType(a¯), we proceed in the same way as above by calling try_merge_orbits.
Eventually, if no call to try_merge_orbits returns False, every tuple in k∈spec(R) A(k)
is processed, and when the algorithm halts we have computed for each k ∈ spec(R)

the partition induced by ≈ on A(k). Since we ensure that all tuples in the same orbit have the same relType, Corollary 5.1 guarantees that R is qf-definable in A.

Algorithm 3 Merging orbits
function try_merge_orbits(g, orbits)
for k ∈ spec do
for a¯ ∈ (Dom(g))(k) do
if orbit(a¯) /= orbit(g(a¯)) then
(B, RT, T, U)= orbit(a¯)
(B′, RT′, T′, U′)= orbit(g(a¯))
if RT /= RT′ then
return False	d RelTypes differ
B_merge = B ∪ B′	d blocks are merged
RT_merge = RT
if T /= Null then	d first block was tagged
T_merge = T
U_merge = U
else if T′ /= Null then	d second block was tagged
T_merge = T′
U_merge = U′
else	d no block is tagged
T_merge = Null
U_merge = Null
delete (B, RT, T, U) and (B′, RT′, T′, U′) from orbitsk
add (B_merge, RT_merge, T_merge, U_merge) to orbitsk]
return True



Proof of soundness and completeness
To prove soundness and completeness we need some auxiliary lemmas.
Lemma 5.2 The following properties hold throughout an execution of Algorithm 2 for each k ∈ spec(R):
The set {B : (B, RT,T,U ) ∈ orbitsk} is a partition of A(k).
For each (B, RT, T, U ) ∈ orbitsk we have that:
For all a¯ in B we have relType(a¯, R1,..., RL)= RT.
For all a¯, ¯b in B we have a¯ ≈ ¯b.
If U /= Null, then there is a¯0 ∈ B such that iUniv(a¯0)= U.
If T /= Null, then T = iType(a¯) for every a¯ in B.
Proof The properties are obviously true at the initialization of orbitsk. Note that the only instructions of Algorithm 2 that may change orbitsk are calls to the functions try_merge_orbits and tag_orbit, and it is easy to see that these functions preserve (i) and (ii).	2
In order to make the proofs below more succinct, we say that (at a certain point of an execution of Algorithm 2):
an orbit (B, RT, T, U ) is tagged if T /= Null.

the tuple a¯ has known type if the (unique) orbit containing a¯ is tagged.
Lemma 5.3 The following properties hold throughout an execution of Algorithm 2:
If the stack is [(Sm, Lm, Gm), (Sm—1, Lm—1, Gm—1),..., (S0, L0, G0)] then |Sm| <
··· < |S0|.
If an entry (S, L, G) is removed from the stack, then every tuple in	k∈spec(R) S(k)
has known type.
Suppose the top of the stack is (S, L, G). If a¯ is a tuple with known type such that |Sg(a¯)| < |S|, then every tuple in	k∈spec(R) Sg(a¯)(k) has known type.
Suppose the top of the stack is (S, L, G). If a¯ is a tuple with known type such that |Sg(a¯)| = |S|, then either:
there is g¯ ∈ G and g¯ is in the same orbit as a¯, or
every tuple in	k∈spec(R) Sg(a¯)(k) has known type.
For all k ∈ spec(R), and for any O = (B, RT, T, U ) and Oj = (Bj, RTj,Tj,Uj)
in orbitsk such that T /= Null, we have that
T = T j ⇐⇒ O = Oj.

Proof Item (i) is easily seen to hold. We prove (ii). When an element (S, L, G) is pushed onto the stack then L is a list containing all tuples in  k∈spec(R) S(k), and (S, L, G) is only removed from the stack when all tuples in T have been processed. It is not hard to see that when a tuple a¯ is processed, we find that either:
the orbit containing it is already tagged , or
it is tagged by a call to tag_orbit or try_merge_orbits, unless the call to
try_merge_orbits returns False (making Algorithm 2 halt and return False).
Let us prove (iii). Suppose the top of the stack is (S, L, G), and let a¯ be as in the statement. Note that there are two ways in which the orbit containing a¯ could have been tagged: either by a call to tag_orbit or by the merging of a¯’s orbit with another orbit that was already tagged. Suppose first that at some point the algorithm executed the call tag_orbit(a¯, iType(a¯), iUniv(a¯)). The key observation is that then (Sg(a¯), Lj, Gj) has been on the stack. Now, since |Sg(a¯)| < |S|, item (i) says that (Sg(a¯), Lj, Gj) is no longer on the stack, and, by (ii), it follows that every tuple from Sg(a¯) has known type. Next, assume that a¯’s orbit was not tagged by such a call to tag_orbit.Since the only way to introduce a new type in orbits is
with a call to tag_orbit, there must exist a tuple ¯b such that:
iType(¯b)= iType(a¯), and tag_orbit(¯b, iType(a¯), iUniv(¯b)) has been executed at an earlier time, and
a¯’s orbit was tagged by eventually being merged with ¯b’s orbit.
Using the same reasoning as above we can conclude that every tuple from Sg(¯b) has known type. Finally, observe that through the merging process every tuple from Sg(a¯) ends up in an orbit with a tuple from Sg(¯b), and thus has known type.
We leave (iv) to the reader as the proof is similar to the one of (iii).

To conclude we prove (v). Note that it suffices to check that the calls to tag_orbit and try_merge_orbits preserve (v). This is clear for try_merge_orbits, since this function does not tag orbits with new types. So we focus on the calls to tag_orbit; let us begin with the one on line 34 of Algorithm 2. Notice that im- mediately before this call is executed we check that the type to be introduced does not occur anywhere in orbits, and thus (v) is preserved. Finally, assume a call tag_orbit(a¯, iType(a¯), iUniv(a¯)) on line 21. Due to the tests carried out before this call we know that (at the time of this call) the top of the stack is (Sg(a¯), L, G)
and that no tuple in G has the same type as a¯. We want to show that no orbit is tagged with iType(a¯). For the sake of contradiction assume there is ¯b such that its orbit, say Oj, has type iType(a¯). So, since no tuple from G is in Oj, item (iv) says that every tuple from Sg(¯b) has known type. It follows that Sg(¯b) /= A, since otherwise a¯ would have had known type. Hence (Sg(a¯), L, G) was pushed on the stack by processing a tuple g¯ which was found to have a new type. But this is a contradiction, since Sg(¯b) contains an isomorphic copy of g¯, and thus would have had known type.	2
Proposition 5.4 Algorithm 2 is sound and complete.
Proof Note that the algorithm terminates if and only if either:
a call to try_merge_orbits returns false and Algorithm 2 returns false, or
the stack is empty and Algorithm 2 returns true.
In the former case, it is clear from an inspection of Algorithm 3, that try_merge_orbits returns false if and only if there are two orbits tagged with the same isomorphism type and different relTypes. Thus, by Lemma 5.2, there are tuples a¯, ¯b such that
a¯ ≈ ¯b and relType(a¯, R1,..., RL) /= relType(¯b, R1,..., RL). So, Corollary 5.1 says
that R is not qf-definable in A.
Suppose next that the algorithm ends due to the stack being empty. Recall that the stack is initialized with (A, L0, ∅), so, by Lemma 5.3.(ii), every tuple in
Sk∈spec(R) A(k) has known type when the algorithm halts. We prove that (3) of
Now Lemma 5.2 together with Lemma 5.3.(v) guarantee that a¯ and ¯b are in the same orbit, and thus item (a) of Lemma 5.2 says that relType(a¯, R1,..., RL) = relType(¯b, R1,..., RL).	2
Empirical tests
In this section we present an empirical testing of the performance of algorithm IsoType (Algorithm 1) versus the isomorphisms search via CSP, as well as an empirical testing of algorithm QfDefAlg for different input algebras. Our imple- mentations are written in Python 3 under GPL 3 license, source code available in https://github.com/pablogventura/QfDefAlg. All tests were performed using an In- tel Xeon E5-2620v3 processor with 12 cores (however, our algorithm does not make use of parallelization) at 2.40GHz, 128 GiB DDR4 RAM 2133MHz. Memory was

never an issue in the tests we ran.

Comparing isoType to a CSP solver
In our previous work [2], we used the CSP solver Minion [8] to compute isomor- phisms between substructures in our algorithm to decide qf-definability in a rela- tional structure. In this new approach to the problem we use the function IsoType to compute those isomorphisms. In order to compare our previous strategy with the one we present here, we designed the following test. Given an algebra A, the test consists in partitioning a random subset R of Ak, first using IsoType, and then via CSP to find relational isomorphisms in the following way: for each a¯ ∈ R, we compute the subuniverse it generates Sg(a) and then construct a relational struc-

Rel
Sg(a)
with universe Sg(a) and, for each operation symbol f in A, the relation

F = graph(f A|Sg(a)) (the graph of the restriction of f A to Sg(a)). Note that A  B
if and only if ARel  BRel. This allows us to use CSP to search for isomorphisms

between ARel
Rel
Sg(b)
that extend the map a¯ → ¯b. We compare running times

of this last strategy to one of the first one.




Figure 2. Time to compute the isomorphism types
Figure 3. Time to decide definability


Since there is no standard set of tests for these problems, we used five families of algebras: distributive lattices, boolean algebras, groups, abelian groups and finally random algebras. These latter were generated by choosing random operations over a fixed universe. For each family we ran the test on 300 algebras and we took the median of the wall time samples. In figure 2 we can see how the IsoType strategy is faster; the reason behind this is that IsoType stores the isomorphism type instead of computing it every time, as CSP does. It is interesting to note how the amount of time increases as the number of subisomorphisms decreases, where our strategy based on inner symmetries is less efficient.

Assessing the performance of QfDefAlg
Now we present testings of algorithm 2 to decide definability, varying both the size of universes and the families of algebras. In these tests we used universes of

cardinality 4, 8, 16 and 32. In all cases the target relation was the binary relation consisting of all pairs from the domain of the algebra. Random algebras are endowed with a binary and a ternary operation. Abelian groups are obtained as products of cyclic groups Zk. In Figure 3 we can see how the algorithm takes advantage of inner symmetries of the algebras; the phenomenon of increasing time for decreasing number of subisomorphisms is again observed, as in Figure 2. It is interesting to observe the behaviour of the abelian groups curve. Since all groups in the test are direct products with factors in {Z2, Z4} (e.g., the 16-element one is Z2 × Z2 × Z4 and the 32-element one is Z2 × Z4 × Z4), the fact that the larger groups have repeated factors increases the number of subisomorphisms, and thus our algorithm has a better performance.



Conclusions and future work
We have presented an algorithm that decides the definability problem by quantifier- free first-order formulas over a purely functional language. This algorithm relies on the semantic characterization of quantifier-free definability given in [6]. We showed that this problem is coNP-complete, which is the same complexity we obtained on the relational case [1]. Prior to this we developed an algorithm that gives a charac- terization of the isomorphism type of a tuple a¯ in the given structure (in particular, the subuniverse it generates is obtained), and showed, by means of empirical tests, that this task is performed very efficiently.
Our definability-decision algorithm partitions the set of all k-tuples from the universe with k ∈ spec(R), and has to exhaust the search space to give a positive answer. Therefore, the execution time of our algorithm depends exponentially on the parameter k. Our empirical tests confirm the exponential dependence on k, and give us an idea of the impact of the cardinality of the input structure and the family of algebras on which we performed the tests. They also confirm the hypothesis that our algorithm, which is based on the existence of symmetries, would perform better on models with a large amount of subisomorphisms, as we observed in the case of relational models; see [2]. We may add that the strategy used in our previous work [2] on quantifier-free definability for relational structures, based on the search of isomorphisms using CSP, proves much less efficient when applied to purely functional structures.
There are several possible lines for future research. Due to the lack of standard testings to decide definability, the empirical tests we presented are preliminary, and more evaluation is needed. We hope to extend the design of models to reach a broader class of algebras, and to be able to introduce control variables, as we extend our approach and tool to other fragments of first-order logic. It would also be natural to study definability over finite classes of models instead of a single structure. Lastly, it would be useful to find classes of algebras in which the problem is well-conditioned and for which polynomial time algorithms exist.

References
C. Areces, M. Campercholi, D. Penazzi, and P. Ventura. The complexity of definability by open first- order formulas. Submitted, arXiv:1904.04637, 2019.
C. Areces, M. Campercholi, and P. Ventura. Deciding open definability via subisomorphisms. In Logic, Language, Information, and Computation - 25th International Workshop, WoLLIC 2018, Bogota, Colombia, July 24-27, 2018, Proceedings, pages 91–105, 2018.
C. Areces, S. Figueira, and D. Gorín. Using logic in the generation of referring expressions. In
S. Pogodalla and J. Prost, editors, Proceedings of the 6th International Conference on Logical Aspects of Computational Linguistics (LACL 2011), volume 6736 of Lecture Notes in Computer Science, pages 17–32. Springer, 2011.
C. Areces, A. Koller, and K. Striegnitz. Referring expressions as formulas of description logic. In
Proceedings of the Fifth International Natural Language Generation Conference (INLG’08), pages 42–
49. Association for Computational Linguistics, 2008.
M. Arenas and G. Diaz. The exact complexity of the first-order logic definability problem. ACM Transactions on Database Systems, 41(2):13:1–13:14, 2016.
M. Campercholi and D. Vaggione. Semantical conditions for the definability of functions and relations.
Algebra universalis, 76(1):71–98, Sep 2016.
H. Ebbinghaus, J. Flum, and W. Thomas. Mathematical Logic. Springer-Verlag, 1994.
I. Gent, Ch. Jefferson, and I. Miguel. MINION: a fast, scalable, constraint solver. In Proceedings of the 17th European Conference on Artiﬁcial Intelligence (ECAI 2006), pages 98–102. IOS Press, 2006.
D. Kavvadias and M. Sideri. The inverse satisfiability problem. SIAM Journal on Computing, 28(1):152–163, January 1998.
E. Krahmer and K. van Deemter.  Computational generation of referring expressions: A survey.
Computational Linguistics, 38(1):173–218, 2012.
Q. T. Tran, C.Y. Chan, and S. Parthasarathy. Query by output. In Proceedings of the 35th SIGMOD international conference on Management of data - SIGMOD ’09. ACM Press, 2009.
R. Willard. Testing expressibility is hard. In D. Cohen, editor, Principles and Practice of Constraint Programming – CP 2010, pages 9–23, Berlin, Heidelberg, 2010. Springer Berlin Heidelberg.
