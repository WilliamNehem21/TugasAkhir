Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 347 (2019) 25–43
www.elsevier.com/locate/entcs
Diacritical Companions
Dariusz Biernackia,1 Sergue¨ı Lengletb,2 Piotr Polesiuka,3
a Institute of Computer Science, University of Wrocl-aw, Wrocl-aw, Poland
b Loria, Universit´e de Lorraine, Nancy, France

Abstract
Coinductive reasoning in terms of bisimulations is in practice routinely supported by carefully crafted up-to techniques that can greatly simplify proofs. However, designing and proving such bisimulation enhancements sound can be challenging, especially when striving for modularity. In this article, we present a theory of up-to techniques that builds on the notion of companion introduced by Pous and that extends our previous work which allows for powerful up-to techniques defined in terms of diacritical progress of relations. The theory of diacritical companion that we put forward works in any complete lattice and makes it possible to modularly prove soundness of up-to techniques which rely on the distinction between passive and active progresses, such as up to context in λ-calculi with control operators and extensionality.
Keywords: coinduction, bisimulation, up-to technique, diacritical progress, companion


Introduction
Coinduction allows to define and reason about potentially infinite objects, such as streams [14] or program behaviors [8]. Proving a property by coinduction consists in exhibiting an invariant, known as bisimulation in the context of program equivalence. Finding the appropriate invariant for a given property can be challenging, as it has to be large enough for the invariant to hold, but also small enough to keep the proof as simple as possible. Up-to techniques or enhancements [15,13] have been introduced to relieve this tension, as they permit to consider smaller objects which are not invariant but contained into one. For example, in some languages, it is safe to ignore a common context when proving the equivalence of two given programs [4]. This reasoning up to context is not sound in general, so the problem becomes how to prove that a given technique is indeed valid, especially since the composition of two up-to techniques is not necessarily sound.

1 Email: dabi@cs.uni.wroc.pl
2 Email: serguei.lenglet@univ-lorraine.fr
3 Email: ppolesiuk@cs.uni.wroc.pl

https://doi.org/10.1016/j.entcs.2019.09.003
1571-0661/© 2019 The Author(s). Published by Elsevier B.V.
This is an open access article under the CC BY license (http://creativecommons.org/licenses/by/4.0/).

Sangiorgi and Pous studied up-to techniques first for binary relations [15], and then in the more general setting of complete lattices [13], focusing on finding composable enhancements for better modularity. Their work led to the definition of the subclass of compatible enhancements, which is closed by function composition and union. Following up on a remark by Hur et al. [6], Pous [11] shows how useful the greatest compatible function (the companion) can be used as a sufficient, modular criterion for the validity of up-to techniques. Indeed, any function (compatible or not) below the companion is an up-to technique, and being below the companion is preserved by composition and union. As further demonstrated by Pous, the notion of companion is surrounded by an array of tools that in practice are highly flexible and effective, compared to relying on the notion of compatibility alone. The companion has since been studied as a categorical object [12,2] and has been characterized in a classical [9] and constructive [16] setting. Danielsson [5] uses the former characterization to relate the companion to size-preserving functions, a class of up-to techniques proved valid using types.
In our studies of equivalences for variants of the λ-calculus [1,3], we restrict the use of up-to techniques in some cases, to allow for more powerful enhancements which would otherwise be unsound when applied in an unconstrained way. We then distinguish the strong up-to techniques, which can safely be used with no restrictions, from the regular ones with a restricted use. This distinction makes it possible to define a highly expressive variant of environmental bisimulation up to context, particularly useful in the presence of context-manipulating constructs such as control operators [1]. It also enables up-to techniques for normal-form bisimulation which respect η-expansion [3]. In the aforementioned papers, we propose diacritical compatibility as a sufficient criterion to be a (strong) up-to technique in our setting. This notion does not allow for an interesting notion of companion, as it is defined at the level of sets of functions and not for individual functions.
This paper fixes this issue by revisiting our view of up-to techniques: instead of distinguishing between strong and regular techniques, we decompose an up-to technique into a pair, composed of a safe (or strong ) part, which can be used every- where, and a restricted (or weak ) one, which cannot. We then define compatibility for pairs of functions; the corresponding companion is therefore itself a pair, called the diacritical companion. We show that the diacritical companion enjoys the same properties as Pous’ companion, and can be used as a sufficient criterion for the validity of up-to techniques. In contrast with our previous papers, the current developments are not restricted to binary relations and take place in any complete lattice. The theory of this article therefore extends our previous work as well as Pous’.
In the rest of the paper, we first introduce the concepts and notions used throughout this work in Section 2. We define the diacritical companion in Section 3, and then extend it to the higher-order setting to use it as a proof technique to show that a given pair of functions is below the first-order diacritical companion (Section 4). We conclude in Section 5. The theory (not the examples) has been formalized in the Coq proof assistant; the developments are available at https:

//bitbucket.org/pl-uwr/companion/.

Diacritical Progress, Complete Lattices, and Com- panion
We set the stage by reminding the notion of diacritical progress, usual definitions about complete lattices, and Pous’ companion.
Diacritical Progress
The notion of progress [15] between relations makes it possible to uniformly describe bisimulations and up-to techniques. A relation R progresses to S, usually written R > S, if terms related by R can be turned into terms related by S by following some conditions given by >. A simulation is then a relation which progresses to itself, i.e., R > R; a bisimulation R is a relation such that R and its inverse R—1 are simulations, and bisimilarity is the largest bisimulation. An up-to technique or enhancement is a function f on relations such that R > f(R) implies that R is included in the bisimilarity.
Example 2.1 All along the paper, we use normal-form bisimilarity [7] for the λ- calculus as an illustrative example. We let x, y, z range over variables. The syntax of terms (e), values (v), and evaluation contexts (E) is given by:
e ::= v | e e	v ::= x | λx.e	E ::=  | E e | v E 
An abstraction λx.e binds x in e; a variable that is not bound is called free. We work modulo α-conversion of bound variables, and a variable is called fresh if it does not occur in the terms under consideration. We write E[e] for plugging a term in an evaluation context, and e{v/x} for the capture-avoiding substitution of v for x in e, defined as usual. We abbreviate successive λ-abstractions λx.λy.e as λxy.e. The call-by-value reduction semantics is given by the following rule.
E[(λx.e) v] → E[e{v/x}]
We write →∗ for the reflexive and transitive closure of →.
Normal-form bisimilarity [7] relates terms by reducing them to normal forms, which are then decomposed into bisimilar subterms. With the chosen semantics, normal forms are either values or open-stuck terms of the form E[x v]. The notion of progress corresponding to normal-form bisimilarity can be given as follows: R > S if R⊆S and e1 R e2 implies:

if e1 → ej
then there exists ej
such that e2 →∗ ej
and ej
S ej ;

if e1 = v1 then there exists v2 such that e2 →∗ v2 and for a fresh variable z, we have v1 z S v2 z;
if e1 = E1[x v1] then there exist E2 and v2 such that e2 →∗ E2[x v2] and for a fresh variable z, we have E1[z] S E2[z] and v1 z S v2 z.

Clause (ii) allows for a uniform treatment of values by simply applying them to a fresh variable. Such a formulation respects η-expansion and scales to richer calculi with, e.g., control operators [3].	□
In our previous work [1,3], we decomposed progress into a passive and an active part, with the idea that passive progress covers administrative steps, and active progress actual computation steps. Diacritical progress R >⭢ Q, S means that R progresses towards Q in the passive case, and towards S in the active one. The
resulting notions of simulation and bisimilarity are not affected by this change, since a simulation still progresses to itself in the active and passive cases: R >⭢ R, R.
Instead, diacritical progress allows for a finer control on enhancements by forbid-
ding the application of some of them in the passive case. We distinguish between regular techniques, which can be used only in the active case, from the strong ones usable everywhere. Formally, a function f is an up-to technique if R >⭢ R, f (R) im- plies that R is included in the bisimilarity, and it is a strong one if R >⭢ f (R), f (R) implies the same property. Such a distinction enables techniques that otherwise would be unsound if applied in an unconstrained way.
Example 2.2 For normal-form bisimilarity [3], we consider the clauses (i) and (iii) as active, since computation happens in both cases, either explicitly in (i), or implicitly in (iii). Indeed, clause (iii) runs the surrounding context E with a variable z which plays the role of a value obtained by at least one reduction step of x v1, if x was replaced with a λ-abstraction. In contrast, value testing (ii) is passive, as it simply builds terms and does not reduce them.
W.r.t. up-to techniques, such a choice allows to forbid in particular the factoriza- tion of a common context when comparing values, as authorizing such a technique in that case would be unsound: v1 R v2 implies that v1 z and v2 z are related up to context for any z, v1, and v2. Up to context can still be safely used when comparing open-stuck terms or after a reduction step.	□
In our previous work, we proposed a sufficient criterion to show that a function is a (strong) up-to technique, phrased in terms of evolution and compatibility. A function f diacritically evolves to g and h if R >⭢ R, S implies f(R) >⭢ g(R), h(S), and it strongly evolves to g and h if R >⭢ Q, S implies f(R) >⭢ g(Q), h(S). These notions mean that f is transformed into g in the passive case, and into h in the active one. Diacritical evolution makes the extra hypothesis that R passively progresses to itself, so that we can normalize the elements in R w.r.t. passive progress before
making an active progress. Compatibility is then defined for sets of functions: roughly, a set F is compatible if it contains a subset S such that
every function f of S strongly evolves towards g and h such that g is built from
S (using composition and union), and h is built from F;
every function f of F diacritically evolves towards g1 ◦ f ◦ g2 and h such that g1
and g2 are built from S and h is built from F.
If F is compatible, then every function in F is an up-to technique, and every function in S is a strong up-to technique. In both cases, h can be built out of functions in F,

meaning that any up-to technique can be used in the active case, while only strong techniques can be used in the passive case to build g, g1, or g2.
Such a definition of compatibility does not lend itself to a notion of companion, because it is defined at the level of sets and not individual functions. We propose a much cleaner theory in this paper, by defining a notion of compatibility and its corresponding companion which allows for the distinction between active and passive progress while extending Pous’ framework.

Progress for Complete Lattices
The notion of progress underlying a bisimilarity can also be expressed as a monotone function b on relations [13]; bisimulations are then post-ﬁxpoints of b, i.e., relations Y verifying Y ⊆ b(Y). Bisimilarity is the greatest fixpoint of b, and can be characterized by Knaster-Tarksi’s theorem as the union of all bisimulations. Pous defines the companion for any complete lattice for a given monotone function [11]. However, the notion of progress can also be generalized to any complete lattice [10], with a one-to-one correspondence to monotone functions, meaning that we still benefit from Knaster-Tarski’s theorem. We present our work using this notion of progress, as we believe it simplifies the presentation of the theory and its comprehension. In particular, our examples relying on normal-form bisimilarity can still be formulated in terms of progress and do not need a less natural translation to monotone functions. To be consistent with this choice, we use progress-like notations and terminology all along the paper, like, e.g., simulation for post-fixpoint and similarity for greatest
fixpoint.
We remind some general notions and fix some notations. A complete lattice
consists of a set L (whose elements are ranged over by Y, £, Q) equipped with a partial order ± such that any subset X of L has a least upper bound . X verifying: for all Y ∈ L, . X ± Y iff for all £ ∈ X, £ ± Y. The least upper bound of two
elements Y and £ is written YH £, and we write ⊥ for the bottom element of
L, defined as . ∅. Given a predicate P on elements of L, we write . Y.P(Y) for
{Y | P(Y)}. By inverting the ordering, we derive the definition of the greatest lower bound . of a set, including the binary one H, as well as the top element T.
A function f from L to L is monotone if for all x, y, x ± y implies f(x) ± f(y). We write [L → L] for the set of monotone functions from L to L, and denote its
elements with either f, g, h, b, or s. The set [L → L] forms a complete lattice if we extend ± and . as follows: f ± g if for all x ∈ L, f(x) ± g(x), and for all X ⊆ [L → L], . X =Δ x '→ . f(x).f ∈ X. We write id for the identity function. Given
two complete lattices L1 and L2, their product L1 × L2, ordered pointwise, is also a
complete lattice. We write π1 and π2 for respectively the first and second projection.
Given a complete lattice L, the general definition of progress [10] describes how
to go from one element of L to another, respecting the ordering ± and the least upper bound ..
Definition 2.3 A binary relation > on L is a progress relation if the following holds:

if Y > Q and Q±£ then Y > £;
if Y±Q and Q > £ then Y > £;
for any subset X of L, if for each Y∈ X we have Y > £, then . X > £.
Least upper bounds are preserved by > on the left, but also on the right, as a consequence of the first item. Indeed, given a subset X of L, if £ ∈ X implies Y > £,
then since £ ± . X, we also have Y > . X.
Progress relations correspond to monotone functions since we can define a

progress >b
from a given monotone function b, and vice versa:

Y >b
Δ
£ = Y± b(£)	b
(£) =	Y.Y > £.



A progress relation >b
Definition 2.4 Let >b
on L induces its counterpart in [L → L], called b-evolution.
be a progress relation on L, and (f, g) ∈ [L → L]2. The

function f b-evolves to g, written f ~b
g, if for all (Y, £) ∈ L2, Y >b
£ implies

f(Y) >b
g(£).

Evolution is a progress relation on [L → L], and is preserved by composition.

Proposition 2.5 If f1 ~b
g1 and f2 ~b
g2 then f1 ◦ f2 ~b
g1 ◦ g2.


Companion
We briefly remind the definition and the main properties of Pous’ companion [11], reformulated using progress and evolution to be consistent with the rest of the paper.

Let L be a complete lattice, and >b
a progress relation on L, for which we consider

the corresponding notion of similarity, written ν(>b ).

A compatible function for >b
is a monotone function f such that f ~b
f, and the

companion, written t, is the largest compatible function. What makes t interesting is that it is an up-to technique, and any function below t is an up-to technique.
Theorem 2.6 Let Y∈ L. If Y >b t(Y) then Y± ν(>b ).
Corollary 2.7 Let f ∈ [L → L]. If f ± t then f is an up-to technique.
To show that f is below t, we just need to consider the lattice [L → L] and the progress relation ~b , whose simulations and similarity are, respectively, compatible functions and t. The higher-order companion T is then the companion for ~b , and instantiating Theorem 2.6 in that setting gives the following result.


Corollary 2.8 Let f ∈ [L → L]. If f ~b
T(f) then f ± t.

The b-evolution proof for a given f can then be simplified thanks to the following properties of T, where we write b for the monotone function corresponding to >b .

Proposition 2.9 Let f ∈ [L → L]. The following holds:

Our goal is to tell a similar story for diacritical progress. We start in the following section by defining a companion for which we prove a result similar to Theorem 2.6.

First-order Diacritical Companion
Henceforth, we fix a complete lattice L with order ± and least upper bound ., and
two progress relations >p and >a , referred to as the passive and active progress,
respectively. Diacritical progress >⭢ is the conjunction of the two progresses, and a

simulation for >⭢ is therefore a simulation for >p for the corresponding similarity.
and for >a . We write ν(>p , >a )

Example 3.1 The passive and active progresses for normal-form similarity are defined as follows. Let Y, £ be relations on λ-terms.

We write Y >p
£ if Y⊆£ and v1 Y e2 implies that there exists v2 such that

e2 →∗ v2, and v1 z £ v2 z for a fresh variable z.

We write Y >a
£ if Y⊆£ and e1 Y e2 implies

if e1 → ej , then there exists ej such that e2 →∗ ej and ej £ ej ;
1	2	2	1	2
if e1 = E1[x v1], then there exist E2, v2 such that e2 →∗ E2[x v2], E1[z] £
E2[z], and v1 z £ v2 z for a fresh variable z.
We discuss the need for the inclusion hypothesis Y ⊆ £ and its consequences in Remark 4.9.	□
In our previous work, we defined compatibility not simply for functions but for sets of functions, to allow for a strong candidate to evolve towards a regular one in the active progress case, as we can see with the definition of strong evolution in Section 2.1. The same purpose can be achieved by decomposing up-to techniques into pairs of monotone functions (s, f), where s is the function applied after the passive progress, while f is applied after the active one.
Definition 3.2 Let (s, f) ∈ [L → L]2; (s, f) is an up-to technique if for all Y∈ L,
Y >p s(Y) and Y >a f(Y) imply Y± ν(>p , >a ).
By considering pairs of functions, we generalize the distinction between strong and regular up-to techniques described in Section 2.1; we decompose an up-to technique into its strong and weak components, respectively s and f. Such a change allows for a definition of evolution between two pairs (s, f) and (sj, fj) where s evolves towards fj in the active progress case.
The function f can be seen as weak since it requires an extra hypothesis in its evolution proof, i.e., it requires arguments that passively progress to themselves— recall that diacritical evolution in Section 2.1 is defined for Y verifying Y >⭢ Y, £.

Weak functions may require Y to make administrative steps (passive progress) before making a computing step (active progress). We reflect this condition in the following notion of restricted evolution.
Definition 3.3 Let (f, g) ∈ [L → L]2; f restrictively evolves to g, written f p|a g, if
for all (Y, £) ∈ L2, Y >p Y and Y >a £ imply f(Y) >a g(£).
Restricted evolution is a progress relation on [L → L], and it is preserved by composition under the following hypotheses.

p|a
p|a	p
p|a

Proposition 3.4 If f1 ~ g1, and f2 ~ g2, and f2 ~ f2, then f1 ◦ f2 ~ g1 ◦ g2.
Remark 3.5 The notions of strong and diacritical evolution from our previous work (cf Section 2.1) can be related to the notions of (restricted) evolution of this paper just by unfolding the definitions:

f strongly evolves to g and h iff f p
g and f ~a h.

If f diacritically evolves to g and h, then f p
p|a
g and f ~ h.

As a result, we reuse the evolution results of our previous papers in the examples about normal-form bisimulation.
We use evolution and restricted evolution to define compatibility for pairs of monotone functions.
Definition 3.6 Let (s, f) ∈ [L → L]2. The pair (s, f) is compatible if:
s p	a
~ s	s ~ f
p	p|a
f ~ f	f ~ f
The diacritical companion is the greatest compatible pair, composed of the strong
and weak companions, written respectively u and w:

(u, w)	Δ
.(s, f).(s, f) is compatible

A pair (s, f) is compatible if each function is compatible w.r.t. passive progress. The conditions for active progress follow the intuitions hinted before: first, the strong component s evolves towards the weak one, since any up-to technique, not necessary strong ones, can be used after the active progress. Second, the weak component f uses restricted evolution, as f may require the elements of L to passively progress to themselves before making an active progress.
Example 3.7 In deterministic languages, simulation up to reduction [13] allows terms to reduce before being related: we can therefore ignore the intermediary reduction steps and reason in a big-step manner even with a small-step semantics. The definition of the corresponding technique in the λ-calculus is as follows.


e1 →∗ ej
e2 →∗ ej e1 red(Y) e2
j Y ej

p
In [3], we show that red ~
red ∪ id and red ~a
red ∪ id, but since id ± red, we have in

p
fact red ~
red and red ~a
p|a
red. The latter implies that red ~ red, therefore the pair

(red, red) is compatible.
Example 3.8 We give an example of technique for which restricted evolution is needed. We define


e1 Y e2	E1[x] Y E2[x]	x fresh


E1[e1] ectx(Y) E2[e2]
e1 Y e2	v1 x Y v2 x	x fresh


e1{v1/x} subst(Y) e2{v2/x}

The technique ectx allows to factor out different evaluation contexts, as long as these contexts are related when plugged with a fresh variable. Similarly, subst allows to
p
reason up to substitution of related values. We prove in [3] that subst ~ subst and
subst ~a ectx ◦ subst2. In contrast, we need restricted evolution to conclude about
ectx. We sketch the subcase which illustrates why.

Let Y, £ be such that Y >p
Y and Y >a
£, and suppose we have x v1 ectx(Y)

E2[e2] with x Y e2 and y v1 Y E2[y] for a fresh y. Since x v1 is an open-stuck term, we have to show that E2[e2] also reduces to an open-stuck term. Because
x Y e2 and Y >p Y, there exists v such that e2 →∗ v and x z Y v z for a fresh z.
Combined with y v1 Y E2[y], we get that x v1 subst(Y) E2[v]. Because Y >a £ and
subst ~a ectx ◦ subst2, we know that E2[v] reduces to an open-stuck term as well.
Without restricted evolution, we would have x v1 subst(£) E2[v], with £ instead of Y, and since we do not have any progress hypothesis about £, it would not be
possible to go further.

p
More generally, we can show that ectx ~
ectx and ectx p|a ectx ◦ subst2 [3]. The

pair (subst, ectx) is not compatible, but we still show it is below the diacritical companion in Section 4.	□
Compatibility for pairs behaves like regular compatibility. In particular, the composition of two compatible pairs produces a compatible pair.
Proposition 3.9
If (s1, f1) and (s2, f2) are compatible, then (s1 ◦ s2, f1 ◦ f2) is compatible.
The pair (id, id) is compatible.
The pair (u, w) is compatible.
	Let Y be a simulation, and Y the function constant to Y. The pair (Y, Y) is compatible.
Proof. The proofs follow from a straightforward unfolding of the definitions. Item (i)
uses Propositions 2.5 and 3.4.	□
Like Pous’ companion, u and w are idempotent and above id. Besides, similarity can be characterized using w.
Proposition 3.10 Let Y∈ L. The following holds:
id ± u,	id ± w,

u ± u ◦ u,	w ± w ◦ w,
u ◦ u ± u,	w ◦ w ± w,
ν(>p , >a ) ± u(Y),	ν(>p , >a ) ± w(Y),
ν(>p , >a )= w(⊥).
Proof. Item (i) follows from Proposition 3.9, item (ii). Item (ii) is a direct con- sequence of (i). To prove (iii) we check that (u ◦ u, w ◦ w) is compatible using the items (i) and (iii) of Proposition 3.9. Because ν(>p , >a ) is a simulation, we derive (iv) from the item (iv) of Proposition 3.9.
Finally, for (v), we already know that ν(>p , >a ) ± w(⊥) with (iv). For the
reverse inequality, we show that w(⊥) is a simulation. By definition of ⊥, we have
⊥ >p ⊥ and ⊥ >a ⊥. Because (u, w) is compatible, we get w(⊥) >p w(⊥) and

w(⊥) >a
w(⊥), as wished. There is no corresponding property for u.	□

With these properties, we can show the main result of this section, that the diacritical companion is indeed an up-to technique.

Theorem 3.11 Let Y∈ L. If Y >p
u(Y) and Y >a
w(Y) then Y± ν(>p , >a ).

Proof. By the first item of Proposition 3.10, we have Y± (w ◦ u)(Y). We show that (w ◦ u)(Y) is a simulation to conclude. From the hypotheses of the theorem, compatibility and idempotence of the companions, we get

u(Y) >p
u(u(Y)) ± u(Y) and u(Y) >a
w(w(Y)) ± w(Y).

Therefore u(Y) >p
u(Y) and u(Y) >a
w(Y) because >p
and >a
are progress relations.

Using again the compatibility of the diacritical companion, we deduce

w(u(Y)) >p
w(u(Y)) and w(u(Y)) >a
w(w(Y)),

but w(w(Y)) ± w(Y) = w(id(Y)) ± w(u(Y)) using the properties of Proposi-
tion 3.10. In the end, we obtain w(u(Y)) >p w(u(Y)) and w(u(Y)) >a w(u(Y)), as
wished.	□
An immediate consequence is that any pair of monotone functions below the com- panion is an up-to technique.
Corollary 3.12 If (s, f) ± (u, w) then (s, f) is an up-to technique.
Δ	Δ	Δ
Example 3.13 Let θ = λxy.y (λz.x x y z) and δx = λy.x (λz.y y z); then Θ = θ θ 
Δ
and Δ = λx.δx δx are respectively Turing’s and Curry’s call-by-value fixed-point
combinators.  We show that θ θ x and δx δx are normal-form similar with a
Δ	∗
single pair Y = {(θ θ x, δx δx)}. Indeed, we have θ θ x →→ x (λz.θ θ x z) and
δx δx → x (λz.δx δx z); we see that the two resulting terms share the common context x λz. z. Let
e1 Y e2
λx.e1 lam(Y) λx.e2

Then Y >a
(red ◦ ectx ◦ lam ◦ ectx)(Y). We know that red ≤ w (Example 3.7) and we

show that ectx ≤ w (Example 4.7) and lam ≤ w (Example 4.8). Using idempotence of the weak companion, we have red ◦ ectx ◦ lam ◦ ectx ± w4 ± w, so we can conclude with Theorem 3.11.	□

Higher-Order Diacritical Companion
Example 3.8 shows that some interesting up-to techniques are not compatible. Yet, we can show they are below the diacritical companion, by turning to higher-order.

Deﬁnition and Properties
The key observation for this section is that the diacritical companion can be de- fined coinductively, by defining passive and active progresses on pairs of monotone functions. We write L† as a shorthand for the complete lattice [L → L] × [L → L].
Definition 4.1 Let (s, f), (sj, fj) ∈ (L†)2. The pair (s, f) passively evolves to (sj, fj),
written (s, f) p (sj, fj), if s p sj and f p fj. It actively evolves to (sj, fj), written

(s, f) a
(sj, fj), if s ~a
fj and f p|a fj.

Passive and active evolutions are progress relations over L†. By definition, a com-

patible pair (s, f) verifies (s, f) p
(s, f) and (s, f) a
(s, f), i.e., it is a simulation for

p	a
=⇒ and =⇒. Consequently, the corresponding similarity is the diacritical companion,
meaning that (u, w)= ν( p , a ), and we can apply the theory of Section 3 to the
lattice L†.
A compatible pair for L† is composed of functions in [L† → L†], which we denote with capital letters. The higher-order diacritical companion, written (U, W), is the

diacritical companion defined w.r.t.	p
and a . A first result we show by going

higher-order is that u is below w; it means that any function below u can be used as a strong or weak component of an up-to technique. In particular, if s ± u, then (s, s) is an up-to technique.
Proposition 4.2 u ± w.

Proof. By Theorem 3.11, it is enough to show that (u, u) p
U(u, u) and (u, u) a

W(u, u). For the former, we prove that (u, u) p
(u, u), and then use item (i) of
p

Proposition 3.10. But since (u, w) is compatible, we have in particular u ~ u, from

which we deduce (u, u) p
To show that (u, u) a
(u, u).
W(u, u), we prove that (u, u) a
(u, w); since (u, w)= 

ν( p , a ), item (iv) of Proposition 3.10 then gives us (u, w) ± W(u, u). Because

(u, w) is compatible, we already have u ~a
p|a
w, which in turn entails u ~ w. We

therefore have (u, u) a
(u, w), as wished.	□

Theorem 3.11 is the main technique to show that a pair (s, f) is below (u, w); we rephrase it to make its application easier in the higher-order setting. First of all, remember that the codomain of U and W is a product L† = [L → L] × [L → L],

which we decompose using projections. Let
U	Δ	Δ
str = π1 ◦ U,	Wstr = π1 ◦ W,
U	Δ	Δ
wk = π2 ◦ U,	Wwk = π2 ◦ W.
Then for all (s, f) ∈ L†, we have U(s, f) = (Ustr(s, f), Uwk(s, f)) and W(s, f) = (Wstr(s, f), Wwk(s, f)). With these functions and by unfolding the definitions of p
and a , Theorem 3.11 can be presented as follows.
Corollary 4.3 Let (s, f) ∈ L†. If
p
s
~ Ustr(s, f)	s ~ Wwk(s, f)
p	p|a
f ~ Uwk(s, f)	f ~ Wwk(s, f)
then (s, f) ± (u, w) and (s, f) is an up-to technique.
Following the first-order intuition, U contains the enhancements allowed after passive evolution, and W the ones after active evolution. More precisely, Ustr contains the enhancements allowed after the evolution of the strong component s, and Uwk those after the weak component f. Due to the asymmetric nature of active evolution, Wwk is used for both components. These functions combine s and f in some way; the question is then which combinations are allowed in the different cases. We provide some answers with the help of the following auxiliary lemma.
Lemma 4.4 Let (s, f) ∈ L†. We deﬁne:

D (s, f
Δ s ◦ s, s ◦ f)	D (s, f
Δ s ◦ s, f ◦ f)	C(s, f Δ
f ◦ w).

1	) =( 
2	) =( 
) = (⊥,

The pairs (D1, D2) and (C, C) are compatible.
We relate the higher-order companions to the first-order functions and show how they can be composed. For sake of completeness, we give the properties of Wstr even though it is not used in Corollary 4.3.
Proposition 4.5 Let (s, f) ∈ L†. The following holds:
s ± Ustr(s, f),	s ± Wstr(s, f),
s ± Uwk(s, f),	s ± Wwk(s, f),
f ± Uwk(s, f),	f ± Wwk(s, f),
u ± Ustr(s, f),	u ± Wstr(s, f),
u ± Uwk(s, f),	u ± Wwk(s, f),
w ± Uwk(s, f),	w ± Wwk(s, f),
id ± Ustr(s, f),	id ± Wstr(s, f),
id ± Uwk(s, f),	id ± Wwk(s, f),
Ustr(U(s, f)) ± Ustr(s, f),	Wstr(W(s, f)) ± Wstr(s, f),
Uwk(U(s, f)) ± Uwk(s, f),	Wwk(W(s, f)) ± Wwk(s, f),

Ustr(s, f) ◦ Ustr(s, f) ± Ustr(s, f),	Wstr(s, f) ◦ Wstr(s, f) ± Wstr(s, f),
Wwk(s, f) ◦ Wwk(s, f) ± Wwk(s, f),
Ustr(s, f) ◦ Uwk(s, f) ± Uwk(s, f),
Uwk(s, f) ◦ w ± Uwk(s, f),
Ustr(s, f) ± Wstr(s, f),
Uwk(s, f) ± Wwk(s, f),
Ustr(s, f) ± Uwk(s, f).
Proof. By Proposition 3.10, we know that id ± U and id ± W, which imply (s, f) ± U(s, f) and (s, f) ± W(s, f), i.e., s ± Ustr(s, f), f ± Uwk(s, f), s ± Wstr(s, f), and f ± Wwk(s, f). The remaining inequalities of (i) then follow from items (xi) and (x). Similarly, item (iv) of Proposition 3.10 gives us (u, w) ± U(s, f) and (u, w) ± W(s, f), from which we deduce the inequalities in (iii) and (iv). Item (v) follows from (iii) and the fact that id ± u, and (vi) is a direct consequence of the idempotence of the (higher-order) companion.
To prove (vii) and (viii), we remark that D1 ± U and D2 ± W hold by Lemma 4.4. Using idempotence of the higher-order companions, we have the following sequences of inequalities.
D1(U(s, f)) ± U(U(s, f))  ± U(s, f)
D2(W(s, f)) ± W(W(s, f)) ± W(s, f)
Unfolding the definition of D1 and D2 and taking the appropriate projections give us the inequalities in (vii) and (viii). Similarly, we prove (ix) using compatibility of the pair (C, C). Item (x) simply recasts Proposition 4.2 in the higher-order setting, and (xi) can be derived from (viii) and (v).	□
Items (v) and (vii) imply that Ustr(s, f), Wstr(s, f), and Wwk(s, f) are in fact idempotent. This property does not hold for Uwk(s, f), as shown by the following counterexample.
Example 4.6 We consider normal-form simulation in the λ-calculus as in the previous examples, and define the function f by the following rules, where x, y, and z are any variables.




x f(Y) y
x Y y


x z f(Y) y z 

Our goal is to apply Corollary 4.3 to the pair (⊥, f) to eventually show it is an up-to
p	p|a
technique. To this end, we study how f evolves w.r.t. ~ and ~.

p
We first show that f ~
f ◦ f. Let Y, £ such that Y >p
£; we want f(Y) >p
f(f(£)).

Let e1 f(Y) e2; for passive progress, e1 must be a value, which is possible only if the first rule defining f has been used. Therefore, we have x f(Y) y, and we want x z f(f(£)) y z for a fresh z, which holds by definition of f.

We also show that f p|a f ◦ f. Let Y, £ such that Y >p
Y and Y >a
£; we want

f(Y) >a
f(f(£)). For active progress, only the terms related by the second rule are

concerned, i.e., we have x z f(Y) y z with x Y y. Because x z and y z are open-stuck terms, we need to show that x = y and xj z f(f(£)) xj z for a fresh xj. Again, the
latter holds by definition of f. From x Y y and Y >p Y, we know that x zj Y y zj
for a fresh zj. But these terms are open-stuck, so Y >a £ implies that x = y, as wished.
p	p|a
As a result, we have f ~ f ◦ f ± Uwk(⊥, f) ◦ Uwk(⊥, f), and similarly for ~. If
Uwk(⊥, f) ◦ Uwk(⊥, f) ± Uwk(⊥, f), then we can apply Corollary 4.3, and show that f ± w, which in turn implies that any two variables are normal-form bisimilar, a contradiction.	□
Fortunately, we still have some weaker properties about how Uwk can be composed. The property (viii) shows that any technique allowed after the p-evolution of s can be composed on the left of Uwk, like, for instance, s itself, since we have s ± Ustr(s, f). Similarly, item (ix) allows to compose any technique below w on the right of Uwk. These properties differ from our previous work, where a weak candidate f should p-evolve towards a function g1 ◦ f ◦ g2 such that g1 and g2 are built from strong candidate functions (cf. Section 2.1). We still have composition on the left with strong candidates using (viii), but we no longer have composition on the right. Instead, we can compose with techniques that are already proven weak (below w) using (ix). In Section 4.2, we show that we can recover some composition on the right with strong candidates by changing the hypotheses of Corollary 4.3.

p
Example 4.7 We remind from Example 3.8 that subst ~
subst, subst ~a
ectx ◦

subst2, ectx p ectx, and ectx p|a ectx ◦ subst2. From Proposition 4.5, we deduce
subst ± Ustr(subst, ectx), ectx ± Uwk(subst, ectx), and subst ± Wwk(subst, ectx) by (i), and ectx ± Wwk(subst, ectx) by (ii). Consequently, we have
ectx ◦ subst2 ± (Wwk(subst, ectx))3 ± Wwk(subst, ectx)
by (vi). The pair (subst, ectx) satisfies the conditions of Corollary 4.3, and is therefore an up-to technique.	□
Example 4.8 We deduce from the previous example that (lam, ⊥) is also an up-to
technique. Let Y >p £, and suppose λx.e1 lam(Y) λx.e2 with e1 Y e2. For a fresh
y, we have (λx.e1) y → e1{y/x}, and (λx.e2) y → e2{y/x}, so the resulting terms are in red(subst(Y)), and because Y ⊆ £ by definition of >p , we have lam(Y) >p
p
((red ◦ subst) H lam)(£), i.e., lam ~ (red ◦ subst) H lam. It is enough to conclude, as lam
does not actively progress and (red ◦ subst) H lam ± u2 H Ustr(lam, ⊥) ± Ustr(lam, ⊥).□
Remark 4.9 Example 4.8 shows why progress for normal-form simulation requires Y⊆ £, as it would not be possible to conclude otherwise. As a result, compatibility in that case is in fact respectfulness [15]. In Pous’ work [11], it does not matter to consider either compatibility or respectfulness, as the two notions produce the same companion. We do not know if the same result holds in our framework; Pous’ proof relies on the fact that the progress function b is below the companion t. We do not
know the relationship between the monotone functions corresponding to >p and >a ,

and u and w.
Recovering Composition on the Right
As explained before, the properties we have so far for Uwk do not allow to compose strong candidates on the right, while our previous theory permits it. We show that we can recover such a property by only slightly strengthening the hypotheses of Corollary 4.3.
We first observe that Proposition 4.5 does not relate in any way a weak candidate f and Ustr(s, f). As a result, given h, s, f, and a proof of h ± Ustr(s, f) which uses solely the inequalities of Proposition 4.5, we can easily use the same proof to show that h ± Ustr(s, ⊥). The function Ustr(s, ⊥) is interesting because it does not mention any weak candidate, so we can study how it evolves more easily.

Lemma 4.10 Let (s, f) ∈ L†. If s p
Ustr
(s, ⊥) then U

str
p
(s, ⊥) ~
Ustr
(s, ⊥). If

s ~a
Wwk
(s, f) then U
str
p|a
(s, ⊥) ~ Wwk
(s, f).
p

Proof. By definition of ⊥ and progress, we have, respectively, ⊥ ~ Uwk(s, ⊥) and
p|a	p	a
⊥ ~ Uwk(s, f), and therefore (s, ⊥) =⇒ U(s, ⊥) and (s, ⊥) =⇒ W(s, f). Because
(U, W) is compatible, we deduce U(s, ⊥) p U(U(s, ⊥)) and U(s, ⊥) a W(W(s, f)).
We conclude by idempotence of U and W and with the appropriate projections. □
To achieve the goal of this section, we define a function Urc which contains Uwk and allows for composition on the right with Ustr(s, ⊥). Let (s, f) ∈ L†; we define Urc as the smallest function verifying the following properties.
f ± Urc(s, f),
Uwk(s, Urc(s, f)) ± Urc(s, f),
Urc(s, f) ◦ Ustr(s, ⊥) ± Urc(s, f).
We show that Urc indeed contains Uwk, from which we deduce some properties.
Proposition 4.11 Let (s, f) ∈ L†. The following holds:
Uwk(s, f) ± Urc(s, f),
s ± Urc(s, f),
Ustr(s, f) ± Urc(s, f).
Ustr(s, f) ◦ Urc(s, f) ± Urc(s, f).
Proof. Because Uwk is monotone and by definition of Urc, we have Uwk(s, f) ± Uwk(s, Urc(s, f)) ± Urc(s, f). The second and third items are then direct consequences of the first one and Proposition 4.5. For the last one,
Ustr(s, f) ◦ Urc(s, f) ± Ustr(s, Urc(s, f)) ◦ Urc(s, f)	Ustr monotone; definition Urc
± Ustr(s, Urc(s, f)) ◦ Uwk(s, Urc(s, f)) Prop 4.5, item (ii)
± Uwk(s, Urc(s, f))	Prop 4.5, item (viii)
± Urc(s, f)	definition of Urc.

□
We modify Corollary 4.3 to use Urc instead of Uwk. The other change we need is the hypothesis about the p-evolution of s, which is now towards Ustr(s, ⊥) instead of Ustr(s, f). As explained at the beginning of the section, the change does not matter much when the evolution proof is based on the inequalities of Proposition 4.5.
Theorem 4.12 Let (s, f) ∈ L†. If
s p	a
~ Ustr(s, ⊥),	s ~ Wwk(s, f)
p	p|a
f ~ Urc(s, f),	f ~ Wwk(s, f).
then (s, f) ± (u, w), and (s, f) is an up-to technique.
Proof. We prove that (s, Urc(s, f)) ± (u, w) using Corollary 4.3. For s, we need
s p	a
~ Ustr(s, Urc(s, f)) and s ~ Wwk(s, Urc(s, f)), which can be derived directly from
the hypotheses of the theorem, since ⊥± Urc(s, f), f ± Urc(s, f), and Ustr and Wwk
are monotone,
We show that Urc(s, f) also respects the hypotheses of Corollary 4.3, by proving
p	p	p
first that s ~ Ustr(s, ⊥) and f ~ Urc(s, f) imply Urc(s, f) ~ Urc(s, f). We proceed
by induction on the definition of Urc. For the base case, we have to show that
p
f ~ Urc(s, f), which is an assumption.
p	p
For the inductive cases, let h such that h ~ Urc(s, f); we show Urc(s, h) ~ Urc(s, f)

and h ◦ U
str
p
(s, ⊥) ~
Urc
(s, f). For the first one, we have (s, h) p
(Ustr
(s, ⊥), Urc
(s, f))

by the assumptions. Since (U, W) is compatible, we have in particular U(s, h) p

U(U
str
(s, ⊥), Urc
(s, f)), which implies Uwk
p
(s, h) ~
Uwk
(Ustr
(s, ⊥), Urc
(s, f)). But

Uwk(Ustr(s, ⊥), Urc(s, f)) ± Uwk(Ustr(s, Urc(s, f)), Urc(s, f))	⊥± Urc(s, f)
± Uwk(Ustr(s, Urc(s, f)), Uwk(s, Urc(s, f)))  Prop 4.5, item (ii)
± Uwk(U(s, Urc(s, f)))	definition Ustr, Uwk
± Uwk(s, Urc(s, f))	Prop 4.5, item (vi)
± Urc(s, f)	definition Urc.
p
Therefore, we have Uwk(s, h) ~ Urc(s, f), as wished.
p	p
We now prove h ◦ Ustr(s, ⊥) ~ Urc(s, f) with Proposition 3.4. Indeed h ~ Urc(s, f)
p
holds by assumption, and Ustr(s, ⊥) ~ Ustr(s, ⊥) from Lemma 4.10, from which we
p	p
deduce Ustr(s, ⊥) ~ Ustr(s, ⊥). As a result, we get h◦Ustr(s, ⊥) ~ Urc(s, f)◦Ustr(s, ⊥),
which is enough since Urc(s, f) ◦ Ustr(s, ⊥) ± Urc(s, f) by definition of Urc.

p
Similarly, we can show that s ~
Ustr
(s, ⊥), s ~a
Wwk
p|a
(s, f), and f ~ Wwk
(s, f) im-

p|a
ply Urc(s, f) ~ Wwk(s, f). In the end, Urc(f, s) satisfies the conditions of Corollary 4.3,
as wished.	□
As an application of Theorem 4.12, we show that the present theory subsumes our previous work. Let F be a set of monotone functions compatible as defined in Section 2.1, with S as its largest subset of strong functions. We prove that for

any s ∈ S and f ∈ F, we have (s, f) ± (u, w). To do so, given a set X of monotone functions, we consider setX Δ . f.f ∈ X as well as the largest function built from X using composition and union, written setω , which can be defined inductively as
follows.
id ± setω ;
if f ∈ X, then f ◦ setω ± setω , setω ◦ f ± setω , f H setω ± setω , and setω H f ± setω .

X	X	X
X	X	X	X	X
p

The definition of compatible set (Section 2.1) and Remark 3.5 then imply s ~

setω, s ~a setω, f  p  setω ◦ f ◦ setω, and f p|a
setω, and therefore set
p setω,

S	F	~	S
S	~	F
S ~	S

set
~a setω, set
p setω ◦ set
setω, and set
p|a
setω. It is easy to show by

S	F	F ~	S	F	S
F ~	F

induction that setω ± Ustr(setS, ⊥) and setω ± Wwk(setS, setF). As a result, we have
S	F
setω ◦ setF ◦ setω ± Ustr(setS, ⊥) ◦ Uwk(setS, setF) ◦ Ustr(setS, ⊥) ± Urc(setS, setF). The
S	S
pair (setS, setF) satisfies the conditions of Theorem 4.12, and is therefore below
(u, w).
Symmetry
So far, the results and examples are phrased in terms of simulation and similarity. As in Pous [11], we show that assuming symmetry of the underlying progress relations, we can go from the similarity to the bisimilarity. Let i ∈ [L → L] be an involution, i.e., i◦i = id. An element Y∈ L is symmetric if i(Y)= Y, and a function f ∈ [L → L] is symmetric if f ◦ i = i ◦ f. For binary relations, i is the usual inverse ·—1.

Let >b
∈ {>p , >a }; suppose there exists >b
such that >b
= >b
∧ i ◦ >b
i. Then

j	2	b	b	b
b|b′
b|b′
b|b′

for all (b, b ) ∈ {p, a} , we also have ~ = ~ ∧ i ◦ ~ ◦ i and ~ = ~ ∧ i ◦ ~ ◦ i. We
can relate progresses and evolutions as follows.
Proposition 4.13 Let (Y, £) ∈ L2 such that Y is symmetric, and f ∈ {u, w}. Then

Y >b
f(£) iff Y >b
f(£).

Let (s, f, g) ∈ (L†)3 such that g is symmetric, and F ∈ {Ustr, U	, Urc, Wstr, W	}.
Then:

g ~b


F(s, f) iff g ~b
F(s, f);

b|b′	b|b′
g ~ F(s, f) iff g ~ F(s, f).
Proof. The left-to-right implications are by hypothesis on >b , so we focus on the
right-to-left ones. First, we show that (i, ⊥) is compatible. Indeed, let Y >b £;

then Y >b
£ and i(Y) >b
i(£). Since i is involutive, we have i(i(Y)) >b
i(i(£)) and

i(Y) >b
i(£), i.e., i(Y) >b
i(£), as wished. Therefore, i ± u ± w.

For the first-order property, from i ± f, i ◦ i = id, and idempotence of the

companions, we deduce i ◦ f = f. Therefore, Y >b
f(£) implies Y >b
i(f(£)), i.e.,

i(Y) >b
i(f(£)) since Y is symmetric. In the end, we have Y >b
f(£), as expected.

For the higher-order properties, we first notice that i ◦ F(s, f)= F(s, f)= F(s, f) ◦ i. If F ∈ {Ustr, Wstr, Wwk}, then i ◦ F(s, f) ± u ◦ F(s, f) ± F(s, f) ◦ F(s, f) ± F(s, f) using items (iii) and (vi) of Proposition 4.5. From i ◦ F(s, f) ± F(s, f), we get

i ◦ i ◦ F(s, f) ± i ◦ F(s, f), i.e., F(s, f) ± i ◦ F(s, f), and therefore i ◦ F(s, f) = F(s, f). The proof for F(s, f) ◦ i = F(s, f) is similar. If F = Uwk, the proof is the same using the items (viii) and (ix) of Proposition 4.5, and for F = Urc, use item (iv) of Proposition 4.11 and item (iii) from the definition of Urc.
We now prove item (i) of Proposition 4.13, the proof for (ii) being similar.

Let Y >b
£; then Y >b
£ and i(Y) >b

i(£). Because g ~b
F(s, f), it implies

g(Y) >b
F(s, f)(£) and g(i(Y)) >b
F(s, f)(i(£)). Because g is symmetric and F(s, f)◦i =

i ◦ F(s, f), the last progress can be rewritten as i(g(Y)) >b
i(F(s, f)(£)), meaning that

g(Y) >b
F(s, f)(£) holds, and g ~b
F(s, f).	□

Conclusion
In this paper, we propose, through the diacritical companion, a sufficient criterion to show in the presence of passive and active progresses that a function is an up-to technique. The key change compared to our previous work is the decomposition of an up-to technique into its strong and weak components, allowing a definition of active evolution where a strong component may evolve to a weak one. The diacritical companion enjoys most of the properties of Pous’ companion, and in particular, when considered in the higher-order setting, it provides a proof technique to show that a pair of functions is below the first-order diacritical companion. A natural future work is then to investigate if the subsequent characterizations of Pous’ companion [9,16,12,2] scale to the diacritical one.
Acknowledgement
We thank the anonymous reviewers for their helpful comments on the presentation of this work. This work was partially supported by COST Action EUTypes CA15123.

References
	A. Aristiz´abal, D. Biernacki, S. Lenglet, and P. Polesiuk. Environmental Bisimulations for Delimited- Control Operators with Dynamic Prompt Generation. Logical Methods in Computer Science, 13(3), 2017.
H. Basold, D. Pous, and J. Rot. Monoidal company for accessible functors. In F. Bonchi and B. Ko¨nig, editors, 7th Conference on Algebra and Coalgebra in Computer Science, CALCO 2017, volume 72 of LIPIcs, pages 5:1–5:16, Ljubljana, Slovenia, June 2017. Schloss Dagstuhl - Leibniz-Zentrum fuer Informatik.
	D. Biernacki, S. Lenglet, and P. Polesiuk. Proving soundness of extensional normal-form bisimilarities. In A. Silva, editor, Proceedings of the 33th Annual Conference on Mathematical Foundations of Programming Semantics(MFPS XXXIII), volume 336 of Electronic Notes in Theoretical Computer Science, pages 41–56, Ljubljana, Slovenia, June 2017.
	F. Bonchi, D. Petrisan, D. Pous, and J. Rot. Coinduction up-to in a fibrational setting. In T. A. Henzinger and D. Miller, editors, Joint Meeting of the Twenty-Third EACSL Annual Conference on Computer Science Logic (CSL) and the Twenty-Ninth Annual ACM/IEEE Symposium on Logic in Computer Science (LICS), CSL-LICS ’14, pages 20:1–20:9. ACM, July 2014.
N. A. Danielsson. Up-to techniques using sized types. PACMPL, 2(POPL):43:1–43:28, 2018.
	C. Hur, G. Neis, D. Dreyer, and V. Vafeiadis. The power of parameterization in coinductive proof. In R. Giacobazzi and R. Cousot, editors, The 40th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, POPL ’13, pages 193–206, Rome, Italy, Jan. 2013. ACM.


S. B. Lassen. Eager normal form bisimulation. In P. Panangaden, editor, LICS’05, pages 345–354, Chicago, IL, June 2005. IEEE Computer Society Press.
R. Milner. Communication and Concurrency. Prentice Hall, 1989.
	J. Parrow and T. Weber. The largest respectful function. Logical Methods in Computer Science, 12(2), 2016.
D. Pous. Complete lattices and up-to techniques. In Z. Shao, editor, APLAS’07, number 4807 in LNCS, pages 351–366, Singapore, Dec. 2007. Springer-Verlag.
	D. Pous. Coinduction all the way up. In M. Grohe, E. Koskinen, and N. Shankar, editors, Proceedings of the 31st Annual ACM/IEEE Symposium on Logic in Computer Science, LICS ’16, pages 307–316, New York, NY, USA, July 2016. ACM.
	D. Pous and J. Rot. Companions, codensity and causality. In J. Esparza and A. S. Murawski, editors, Foundations of Software Science and Computation Structures - 20th International Conference, FOSSACS 2017, Held as Part of the European Joint Conferences on Theory and Practice of Software, ETAPS 2017, volume 10203 of Lecture Notes in Computer Science, pages 106–123, Uppsala, Sweden, Apr. 2017.
D. Pous and D. Sangiorgi. Enhancements of the bisimulation proof method. In D. Sangiorgi and
J. Rutten, editors, Advanced Topics in Bisimulation and Coinduction, chapter 6, pages 233–289. Cambridge University Press, 2011.
	J. J. M. M. Rutten. A coinductive calculus of streams. Mathematical Structures in Computer Science, 15(1):93–147, 2005.
D. Sangiorgi. On the bisimulation proof method. Mathematical Structures in Computer Science, 8(5):447–479, Oct. 1998.
S. Sch¨afer and G. Smolka. Tower induction and up-to techniques for CCS with fixed points. In
P. H¨ofner, D. Pous, and G. Struth, editors, Relational and Algebraic Methods in Computer Science - 16th International Conference, RAMiCS 2017, Lyon, France, May 15-18, 2017, Proceedings, volume 10226 of Lecture Notes in Computer Science, pages 274–289, 2017.
