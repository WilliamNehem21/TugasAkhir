	Electronic Notes in Theoretical Computer Science 206 (2008) 91–110	
www.elsevier.com/locate/entcs

Algebraic Stuttering Simulations 
Narciso Mart´ı-Oliet1
Departamento de Sistemas Informa´ticos y Computacio´n, Universidad Complutense de Madrid
Jos´e Meseguer2
Computer Science Department, University of Illinois at Urbana-Champaign
Miguel Palomino3
Departamento de Sistemas Informa´ticos y Computacio´n, Universidad Complutense de Madrid

Abstract
Rewrite theories and their associated Kripke structures constitute a flexible and executable framework in which a wide range of systems can be studied. We present a general notion of simulation between Kripke structures, study its categorical aspects, and propose rewriting logic as a framework in which these simulations can be represented. Several representability results showing that rewriting logic is indeed a suitable framework for this purpose are given, and we illustrate its use with two examples.
Keywords: Rewriting logic, simulation, category, representability.


Introduction
Rewriting logic is a very flexible framework with good properties for representing many concurrent systems at a high level [16,14]. Rewrite theories can be executed in a language such as Maude [7] and give rise to an associated Kripke structure in which properties, when the number of states is finite, can be verified using Maude’s model checker.

٨ Research supported by ONR Grant N00014-02-1-0715, NSF GrantCCR-0234524, and by DARPA through Air Force Research Laboratory Contract F30602-02-C-0130; and by the Spanish projects MIDAS TIC 2003–0100, DESAFIOS TIN2006–15660–C02–01, and by Comunidad de Madrid program PROMESAS S– 0505/TIC/0407
1 Email: narciso@sip.ucm.es
2 Email: meseguer@cs.uiuc.edu
3 Email: miguelpt@sip.ucm.es

1571-0661 © 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.03.077

Hence, this paper tries to advance two main goals: the first, to generalize the notion of simulation between Kripke structures as much as possible, and the sec- ond, to provide general representability results showing that Kripke structures and generalized simulations can be represented in rewriting logic. These two goals are themselves motivated by pragmatic reasons. The reason for trying to advance the first goal is that simulations are essential for compositional reasoning. A cornerstone in such reasoning is the result that simulations reflect interesting classes of temporal logic properties, that is, if we have a simulation of Kripke structures H : A −→ B and a suitable temporal logic formula ϕ, then if aHb and B,b |= ϕ, we can conclude that A,a |= ϕ. Since this result is enormously powerful, there are strong reasons to generalize it: a more general notion of simulation will give it a wider applicability, even when the class of formulas ϕ for which it applies may have to be restricted.
Advancing the second goal is also motivated by pragmatic reasons, namely: (i) executability, (ii) ease of specification, and (iii) ease of proof. The point about
(i) and (ii) is that rewriting logic is a very flexible framework, so that concurrent systems can usually be specified quite easily and at a very high level; furthermore, such specifications can be used directly to execute a system or to reason about it, which is point (iii). Indeed, both rewriting logic and its underlying equational logic can be very useful for formal reasoning, since any temporal logic deductive reasoning needs to include first-order and often inductive reasoning at the level of state predicates. This is precisely where rewriting and equational logics and their initial models supporting inductive reasoning are quite useful. In a previous paper
[19] we have shown the usefulness of defining abstraction simulations equationally in rewriting logic, and of using tools such as Maude’s LTL model checker [10] and inductive theorem prover [8] to verify properties and prove abstractions correct. The paper [15] further generalized [19] by allowing not just the addition of equations E' to a theory (Σ, E) for abstraction purposes, thus obtaining a subtheory inclusion (Σ, E) ⊆ (Σ',E ∪ E'), but also the use of very general theory morphisms H : (Σ, E) −→ (Σ', E'). This work substantially widens those previous results. The emphasis here is on foundations, but we have included two examples to illustrate the general methodology; we refer the reader to the extended version [20] (which also contains the proofs of the results presented here) for a discussion of the related proof obligations for our proposed simulations.
We advance the first goal by generalizing simulations in three directions. First, we consider stuttering simulations in the sense of [3,22,13], which are quite general and useful to relate concurrent systems with different levels of atomicity; second we relax the condition on preservation of atomic properties from equality to con- tainment; and third, we allow different alphabets AP and AP ' of atomic propo- sitions in Kripke structures A and B related by generalized stuttering simulations (α, H) : A −→ B, so that an atomic proposition p ∈ AP is mapped by α to a state formula over AP '. A categorical viewpoint is indeed the most natural to understand these generalized simulations, but as far as we know this viewpoint has not been systematically exploited before. In [23] we treated several of these categorical aspects at the level of Kripke structures, including a classification in

terms of institutions; here we expand some of those ideas. We advance the second goal by proving several representability results showing that any Kripke structure (resp. any recursive Kripke structure) can be represented by a rewrite theory (resp. a recursive rewrite theory), and that any generalized simulation (resp. recursively enumerable—in short, r.e.—generalized simulation) can be represented by a rewrite relation.

Relating Kripke Structures
Stuttering Simulations
A Kripke structure over a set AP of atomic propositions consists of a transition system A = (A, →A) and a labeling function LA : A −→ P(AP ).  A path in A is a function π : IN −→ A such that π(i) →A π(i + 1) for each i ∈ IN. To specify system properties we use the logic ACTL∗(AP ), which is the restriction of the branching-time temporal logic CTL∗(AP ) (see for example [5, Sect. 3.1]) to those formulas such that their negation-normal forms (with negations pushed to atoms) do not contain any existential path quantifiers. There are two types of formulas in CTL∗(AP ): state formulas, denoted by State(AP ), and path formulas. The satisfaction relations are denoted by A,a |= ϕ and A,π |= ψ for a Kripke structure A, an initial state a ∈ A, a state formula ϕ,a path π, and a path formula ψ. Sometimes, to avoid introducing implicitly existential quantifiers, it is more convenient to restrict ourselves to the negation-free fragment ACTL∗\¬(AP ) of ACTL∗(AP ).
For example, the behaviour of a simple periodic system could be represented by means of a transition system with four states, s0, s1, s2, and s3, and transitions si → s(i+1)%3, s0 → s3, and s3 → s3. Now, to distinguish among the different states and to reason about the system, this transition system can be extended to a Kripke structure by making explicit some atomic properties satisfied by the states, say L(s0)= {sleep}, L(s1)= {wait}, L(s2)= {work}, and L(s3)= {error}. The path s0 → s1 → s2 → s0 → s1 → ... satisfies the path formula GF work, indicating that the system always ends up doing some working. However, the state formula AGF work does not hold in s0 because a path starting at s0 may eventually leap to s3 and remain there.
In [19] we presented a notion of simulation similar to that in [5], but somewhat more general (simulations in [5] essentially correspond to our strict simulations). Here we generalize that definition in two ways. The first direction in which the original definition can be extended is that of stuttering bisimulations [3,22] and, more generally, stuttering simulations [13]. Our definition is closely related to the one given by Manolios [13], but with some technical and methodological differences. For A = (A, →A) and B = (B, →B) transition systems and H ⊆ A×B a relation,
we say that a path ρ in B H-matches a path π in A if there are strictly increasing functions α, β : IN −→ IN with α(0) = β(0) = 0 such that, for all i, j, k ∈ IN, if α(i) ≤ j < α(i + 1) and β(i) ≤ k < β(i + 1), it holds that π(j)Hρ(k). For example, the following diagram shows the beginning of two matching paths, where related

elements are joined by dashed lines and α(0) = β(0) = 0, α(1) = 2, β(1) = 3,
α(2) = 5, etc.

π  • ¸¸
 • 	 • 	 • 	 • 	 · · · 

  ¸¸ ¸ ¸ ¸
    ¸ ¸ ¸ ¸¸
¸	 
¸ ¸ 

ρ  •	 •	 • 	 • 	 • 	 · · · 
Definition 2.1 [[15]] Given transition systems A and B,a stuttering simulation of transition systems H : A −→ B is a binary relation H ⊆ A × B such that if aHb, then for each path π in A starting at a there is a path ρ in B starting at b that H-matches π. If H is a function we say that H is a stuttering map of transition systems. If both H and H−1 are stuttering simulations, then we call H a stuttering bisimulation.
Given Kripke structures A = (A, →A, LA) and B = (B, →B, LB) over AP , a stuttering AP -simulation H : A −→ B is a stuttering simulation of transition systems H : (A, →A) −→ (B, →B) such that if aHb then LB(b) ⊆ LA(a). If H is a function we call H a stuttering AP -map. We call H a stuttering AP -bisimulation if H and H−1 are stuttering AP -simulations. We call H strict if aHb implies LB(b)= LA(a).
The fact that H : A −→ B is a stuttering simulation of transition systems guarantees that for each concrete path in A starting at a state related to one in B there is a path simulating it in B. The condition on properties implies that a state in B can at best satisfy only those atomic propositions that hold in all the states in A that it simulates.
Notice that these definitions are very general, not even requiring H to be to- tal. This leads to some perhaps unexpected consequences: for example, the empty relation is vacuously a stuttering bisimulation of Kripke structures! The notion is natural, however, in that every stuttering AP -simulation arises from a total one restricted to a certain domain of interest.
Definition 2.2 Given transition systems A and B, A is a subsystem of B if A ⊆ B and →A ⊆ →B; we then write A⊆ B. We say that a subsystem A is full in B if for all a ∈ A, if a →B a' then a' ∈ A and a →A a'. A Kripke structure A is a Kripke substructure of B if A’s underlying transition system is a subsystem of that of B and LA = LB|A; it is full if it is so at the level of transition systems.
Proposition 2.3 Let H : A −→ B be a stuttering AP -simulation. For any full Kripke substructure B' ⊆ B, H−1(B') = (H−1(B'), →A ∩ H−1(B') × H−1(B'), LA|H−1 (B')) is a full Kripke substructure of A.
In particular, H−1(B) is a full Kripke substructure of A. Therefore, every stut- tering AP -simulation H : A −→ B can alternatively be seen as a total stuttering AP -simulation H : H−1(B) −→ B. Stuttering simulations of transition systems (see [13]) and of Kripke structures compose. Note also that the identity func- tion 1A : A −→ A is trivially a stuttering simulation of transition systems and of Kripke structures. Therefore, transition systems together with stuttering simula- tions define a category STSys. Similarly, Kripke structures together with stuttering

AP -simulations define a category KSSimAP , with two corresponding subcategories KSMapAP and KSBSimAP whose morphisms are, respectively, stuttering AP - maps and stuttering AP -bisimulations. There are also correspondings subcategories of strict stuttering simulations.

Shifting Our Ground
We also seek to generalize the definition of simulation so that Kripke structures over different sets of atomic propositions can be related. This will provide us with a very flexible way of relating Kripke structures and will allow us to gather all the previous categories KSSimAP into a single one. First we need the following definition to translate the properties of a Kripke structure to a different set of atomic propositions.
Definition 2.4 [[23]] Given a function α : AP −→ State(AP ') and a Kripke struc- ture A = (A, →A, LA) over AP ', we define the reduct Kripke structure A|α = (A, →A, LA|α ) over AP , with labeling function LA|α (a)= {p ∈ AP | A,a |= α(p)}.
Proposition 2.5 ([23]) Let α : AP −→ State(AP ') be a function and let ϕ be a formula in CTL∗(AP ). Then, for all Kripke structures A = (A, →A, LA) over AP ', states a ∈ A, and paths π:
if ϕ is a state formula, A,a |= α(ϕ) ⇐⇒ A|α,a |= ϕ, and
if ϕ is a path formula, A,π |= α(ϕ) ⇐⇒ A|α,π |= ϕ.
The notation α above stands for the homomorphic extension of α to formulas ϕ ∈ CTL∗(AP ). Note that it makes no sense to map an atomic proposition, which is a state formula, to an arbitrary CTL∗ formula that may turn out to be a path for- mula. Therefore, the choice of State(AP ') as the range of the functions α is as gen- eral as possible. To deal with stuttering, however, we should restrict the range of α to formulas without the “next” operator X. Also, note that when dealing with non- strict simulations, since the reflected formulas will be in ACTL∗\¬(AP ) we will want our maps α to have their range in the negation-free fragment State\{¬, X}(AP '), i.e., we will use maps α : AP −→ State\{¬, X}(AP ') instead. For example, let AP = {init, compute} and AP ' = {sleep, wait, work, error}, and α : AP −→ AP ' given by α(init)= work, α(compute)= AG work. If A is the previous peri- odic system, then A|α, s2 |= init but A|α, s2 |= compute.
The definition of generalized stuttering simulations is now immediate.
Definition 2.6 [23] Given a Kripke structure A over a set AP of atomic propo- sitions and a Kripke structure B over a set AP ', a stuttering simulation (resp. strict stuttering simulation) (α, H) : (AP, A) −→ (AP ', B) consists of a function α : AP −→ State\{¬, X}(AP ') (resp. α : AP −→ State \ X(AP ')) and a stuttering AP -simulation (resp. strict stuttering AP -simulation) H : A −→ B|α.
To simplify notation, from now on we will write (α, H) : A −→ B instead of (α, H): (AP, A) −→ (AP ', B) except in those cases where it could lead to confusion.



Composition of simulations can be defined as (β, G) ◦ (α, F ) = (β ◦ α, G ◦ F ). Using as objects pairs (AP, M) with AP a set of atomic propositions and M a Kripke structure over AP , this immediately gives rise to a category KSSim; see
[23] for a categorical discussion.
The important fact about stuttering simulations is that they reflect satisfaction of appropriate classes of formulas. Given Kripke structures A over AP and B over AP ', a stuttering simulation (α, H): A −→B reflects the satisfaction of a formula ϕ ∈ CTL∗(AP ) if either:
ϕ is a state formula, and B,b |= α(ϕ) and aHb imply that A,a |= ϕ; or
ϕ is a path formula, and B,ρ |= α(ϕ) and ρ H-matches π imply that A,π |= ϕ.
It is clear that the “next” operator X of temporal logic is not reflected by stuttering simulations; however, if we restrict our attention to ACTL∗ \ X and ACTL∗\{¬, X}, that is, the fragments of the logics that do not contain X, formulas are reflected.
Theorem 2.7 Stuttering simulations always reflect satisfaction of ACTL∗\{¬, X} formulas. Strict stuttering simulations also reflect satisfaction of ACTL∗ \ X for- mulas.
Rewriting Logic
One can distinguish two specification levels: a system specification level, in which the computational system of interest is specified, and a property specification level. These two levels correspond respectively to the specification of the transition system and the Kripke structure associated to the computational system. The main inter- est of rewriting logic [16] is that it provides a very flexible framework for specifying concurrent systems and for associating to them transition systems and Kripke struc- tures. Rewriting logic is parameterized by an underlying equational logic. Here we use membership equational logic [18], an expressive extension of many-sorted equa- tional logic that has kinds in addition to sorts (to simplify the presentation, we call them both types here), and allows subtypes defined by semantic conditions and op- erator overloading. Sentences are Horn clauses over atomic formulas, which include both equations t = t' and membership assertions w : s stating that the term w has type s.
Concurrent systems are axiomatized in rewriting logic by means of rewrite theo- ries [16] of the form R = (Σ, E, R). The set of states is described by a membership equational theory (Σ, E) as the algebraic data type TΣ/E,k associated to the ini- tial algebra TΣ/E of (Σ, E) by the choice of a type k of states in Σ. The system’s transitions are axiomatized by the conditional rewrite rules R which are of the form
λ : (∀X) t −→ t' if  i∈I pi = qi∧
 j∈J wj : sj ∧  l∈L tl −→ t' ,
with λ a label, pi = qi and wj : sj atomic formulas in membership equational logic for i ∈ I and j ∈ J, and for appropriate types k and kl, t, t' ∈ TΣ,k(X),

and tl, t'
∈ TΣ,kl (X) for l ∈ L. Under reasonable assumptions about E and R,

rewrite theories are executable. Indeed, there are several rewriting logic language
implementations, including CafeOBJ [11], ELAN [2], and Maude [6,7].
Rewriting logic then has inference rules to infer all the possible concurrent com- putations in a system [16,4], in the sense that, given two states [u], [v] ∈ TΣ/E,k, we can reach [v] from [u] by some possibly complex concurrent computation iff we can prove u −→ v in the logic; we denote this provability by R ▶ u −→ v. In particular we can easily define the one-step R-rewriting relation, which is a binary
relation →1	on TΣ,k that holds between terms u, v ∈ TΣ,k iff there is a proof of
u −→ v in which only one rewrite rule in R is applied to a single subterm. We can

get a binary relation (with the same name) →1
on TΣ/E,k by defining [u] →1
[v]

iff u' →1	v' for some u' ∈ [u], v' ∈ [v]. This determines a transition system

T (R)k = (TΣ/E,k, →1
) for each k ∈ K.



Example: Semantics of a Functional Language
In [12], a simple functional language called Fpl is defined along with a computation semantics and a more concrete semantics which uses an abstract machine. A state of the abstract machine is a triple ⟨S, ρ, e⟩, where S is a stack of values, ρ is an environment assigning values to variables, and e is an expression. A state for the computation semantics is a pair ⟨ρ, e⟩, with ρ an environment and e an expression. The transition relations ⟨S, ρ, e⟩ −→ ⟨S', ρ', e'⟩ and ⟨ρ, e⟩ −→ ⟨ρ', e'⟩ defined in [12] were translated to rewriting logic in [25]. They are summarized in App. A, in Maude notation, and we use them here to illustrate the main components of rewriting logic. Environments in Fpl ’s computation semantics are represented in a rewrite the- ory by terms of type Env. Similarly, there are two types to represent numerical
and Boolean expressions, NExp and BExp, together with several operators, like +
: [NExp] [NExp] -> [NExp] to represent addition, or If Then Else : [BExp] [NExp] [NExp] -> [NExp] for conditional expressions, where the underbars are placeholders for the arguments. Finally, states are constructed with < , > : [Env] [NExp] -> [State] and < , > : [Env] [BExp] -> [State]. In this particular example no equations are needed. Then, the transitions of the system are given by rewrite rules like
rl [IfRc] : < rho, If True Then e Else e’ >
=> < rho, e > .
that specifies the behavior of the If expression when its condition is true. (IfRc is the label, and crl would be used to introduce a conditional rule.) The semantics of the stack machine is specified analogously.
These rewrite theories give rise to two transition systems, A = (A, →A) and C = (C, →C ), for the abstract machine and the computation semantics respectively. The evaluation of a single expression in each of them requires the execution of several steps; therefore, it makes sense to study the relationship between those executions in order to prove the correctness of the implementation, and we do so in Sect. 5.

Specifying Kripke Structures as Rewrite Theories
Temporal Properties of Rewrite Theories
In order to associate temporal properties to a rewrite theory R = (Σ, E, R) we need to make explicit two things: the intended type k of states in the signature Σ, and the relevant state predicates. Once the type k is fixed, the transitions between states are given by T (R)k. In general, however, the state predicates need not be part of the system specification but only of the property specification. We can assume that they have been defined by means of equations D in a protecting theory extension (Σ',E ∪ D) of (Σ, E); that is, the extension is conservative in the sense that the unique Σ-homomorphism TΣ/E −→ TΣ'/E∪D|Σ should be bijective at each type in Σ. We also assume that (Σ',E ∪ D) contains the theory BOOL of Boolean values in protecting mode. Furthermore, we assume that the syntax defining the state predicates consists of a subsignature Π ⊆ Σ' of operators, with each p ∈ Π a different state predicate symbol that can be parameterized, that is, p need not be a constant, but can in general be an operator p : s1 ... sn −→ Prop, with Prop the type of propositions. If k is the type of states, the semantics of the state predicates Π is defined with the help of an operator	|=	: k Prop −→ Bool in Σ' and by the equations E ∪ D. By definition, given ground terms u1,... , un, we say that the state predicate p(u1,... , un) holds in the state [t] iff E ∪ D ▶ t |= p(u1,... , un)= true.
Then, we associate to a rewrite theory R = (Σ, E, R) (with a selected type k of states and with state predicates Π) a Kripke structure whose atomic propo- sitions are specified by the set APΠ = {θ(p) | p ∈ Π, θ ground substitution}, where by convention we use the simplified notation θ(p) to denote the ground

term θ(p(x1,... , xn)). We define K(R, k)Π = (TΣ/E,k , →1
, LΠ), where LΠ([t]) =

{θ(p) ∈ APΠ | θ(p) holds in [t]}.
For example, if we consider as the set of atomic propositions the set of all possible values, the rewrite theory specifying Fpl ’s computation semantics can be extended by declaring a constant v : -> Prop for each value v and equations (in Maude notation)
ceq (< rho, v > |= w) = true if v = w .
defining LC(⟨ρ, v⟩)= {v} and LC(c) empty otherwise. For the abstract machine:
ceq (< empty, rho, v > |= w) = true if v = w . ceq (< v, rho, empty > |= w) = true if v = w .
These extensions lift the transition systems C and A to the level of Kripke structures.

General Representability Results
What is the point of using rewrite theories to specify Kripke structures? It is a logical point: in this way, we have at our disposal two logics to specify a system and its predicates, namely membership equational logic to specify the data type of states and its atomic propositions, and rewriting logic to specify the system’s transitions. This is quite useful for reasoning about the properties of a system so specified. For example, when doing deductive reasoning about temporal logic properties we

can use a host of inductive equational techniques combined with temporal logic reasoning to prove that certain formulas hold. Likewise, for model checking it is possible to specify at a high level many different Kripke structures as rewrite theories and (assuming finitary reachability) to model check their properties in a tool like Maude’s LTL model checker [10].
What is the generality of rewriting logic to specify Kripke structures? That is, can we specify in this way any Kripke structure that we may care about? The answer is yes. Furthermore, if the Kripke structure is recursive, then the corresponding rewrite theory will be finitary and also recursive in a suitable sense. This brings us to the notion of recursive Kripke structures. We use the notion of recursive set and recursive function in the same sense as Shoenfield [24].

Definition 4.1 A transition system B = (B, →B) is called recursive if B is a re- cursive set and there is a recursive function next : B −→ Pfin(B) (where Pfin(B) is the recursive set of finite subsets of B) such that a →B b iff b ∈ next(a).
A Kripke structure B = (B, →B, LB) over AP is called recursive if (B, →B) is a recursive transition system, AP is a recursive set, and the function LˆB : B × AP −→ Bool mapping a pair (a, p) to true if p ∈ LB(a) and to false otherwise, is recursive.

The above notions of recursive transition system and recursive Kripke structure capture the intuition of systems for which we can effectively determine in a finite number of steps all the one-step successors of a given state. This is a stronger notion than just requiring that the transition relation →B is recursive, since then the set of next states of a given state would in general only be r.e. Note that being a recursive Kripke structure is a necessary condition for effectively model checking the satisfaction of temporal logic formulas in an initial state. In general, however, recursiveness is not a sufficient condition for effective model checking unless the set of states reachable from the given initial state is ﬁnite.
By a well-known metatheorem of Bergstra and Tucker [1], recursive sets and recursive functions coincide with those sets and functions that can be specified by a finite signature Σ and a finite set of Church-Rosser and terminating equations E. The underlying carrier sets of the initial algebra TΣ/E are the desired recursive sets, and the underlying operations of the algebra provide the recursive functions. In
the context of Kripke structures, this means that if B = (B, →B, LB) is a recursive Kripke structure, then B, AP , and LˆB can always be specified by finite signatures and sets of equations. In our approach, this is accomplished by specifying B as the carrier of a type k of an initial algebra TΣ/E with Σ finite and E Church-Rosser and terminating, and specifying LˆB (which is denoted |= in our terminology) in an also Church-Rosser and terminating protecting extension (Σ',E ∪ D) ⊇ (Σ, E) in which the state predicates Π have been specified.
What about the specification of the transition relation →B? Here is where rewrite theories come in.
Definition 4.2 Let R = (Σ,E ∪ A, R) be a finitary rewrite theory such that all its

rules are of the form
(†)	λ : (∀X) t −→ t' if   pi = qi ∧  wj : sj ,
i∈I	j∈J
with i vars(pi) ∪ vars(qi) ∪ j vars(wj) ⊆ vars(t) ∪ vars(t'), and where either vars(t') ⊆ vars(t), or, more generally, the rules (†) are admissible in the sense of [6]; that is, any extra variables not in vars(t) can only be introduced incremen- tally by “matching equations” in the condition, so that they are all instantiated by matching.
We call R recursive if:
there exists a matching algorithm modulo the equational axioms 4 A;
the equational theory (Σ,E ∪ A) is (ground) Church-Rosser and terminating modulo A [9]; and
the rules R are (ground) coherent [26] relative to the equations E modulo A.
Notice that the rules that specify Fpl ’s semantics in our example (see App. A) are admissible, and that only those labeled Varm contain matching equations (in- troduced with :=).
The last condition means that no rewrites are lost by reducing a term t to its (unique modulo A) canonical form canE/A(t) with respect to E before applying any of the rules. Then, if R is a recursive rewrite theory, it can be proven that we have a recursive function nextR : TΣ/E∪A,k −→ Pfin(TΣ/E∪A,k). As a consequence, if R is recursive then T (R)k is recursive and if, in addition, the extension (Σ',E ∪ D) ⊇ (Σ, E) is protecting with E ∪ D Church-Rosser and terminating, then K(R, k)Π is a recursive Kripke structure. The converse also holds, that is, each recursive system and Kripke structure can be specified this way. For lack of space we omit the proofs of these results and refer the reader to [20] for a detailed discussion.
At the price of allowing infinite signatures and losing computability, there is obviously a general representability result stating that any Kripke structure can be modeled in rewriting logic.

Algebraic Stuttering Simulations
We have already noted that, in order to reason about computational systems, these can be abstractly described by means of transition systems and Kripke structures. As explained in the previous sections, rewriting logic can be used to specify both kinds of structures in a natural and modular way. Our goal now is to study how to relate different rewrite theories and how to lift to this specification level all the pre- vious results about stuttering simulations of Kripke structures. In previous works we did it by means of equational abstractions [19] and theoroidal morphisms [15]. Here we substantially extend those previous notions by considering two increasingly more general ways of defining stuttering simulations for rewrite theories that specify

4 In the rewriting logic language Maude, the axioms A for which the rewrite engine supports matching modulo are any combination of associativity, commutativity, and identity axioms for different binary oper- ators.

a concurrent system. In both ways we represent Kripke structures as rewrite theo- ries; in the first case we represent stuttering maps as equationally defined functions, and in the second, more general case, we represent stuttering simulations as rewrite relations.

Stuttering Maps as Equationally Deﬁned Functions
We define a category SRWTh|= of rewrite theories that specify Kripke structures and stuttering maps, with the maps specified as equationally defined functions. We also define a subcategory RecSRWTh|= where everything is recursive. For that we need to consider a theory BOOL|= extending BOOL with two new types, State and Prop, and a new operator |= : State Prop −→ Bool.
Objects in the category SRWTh|= will be rewriting logic specifications of Kripke structures, and arrows will define stuttering maps between them. As already ex- plained, there are both a system and a property specification levels involved in the description of a Kripke structure, namely the transition system level, and the level in which propositions are added. Therefore, objects in SRWTh|= will be pairs consisting of a rewrite theory specifying the underlying transition system, and an equational theory specifying the relevant atomic propositions. We will add, how- ever, a third component whose purpose will be to distinguish the chosen type of states and also to make sure that the theory BOOL remains fixed along simulations.
More precisely, objects in SRWTh|= are given by triples
(R, (Σ',E ∪ D),J)
where:
R = (Σ, E, R) is a rewrite theory specifying the transition system.
(Σ, E) ⊆ (Σ',E ∪ D) is a protecting theory extension, containing and protect- ing also the theory BOOL of Booleans, that defines the atomic propositions satisfied by the states. We define Π ⊆ Σ' as the subsignature of operators of coarity Prop.
J : BOOL|= −→ (Σ',E ∪ D) is a membership equational theory morphism
[18] that selects the distinguished type of states J(State ) and such that: (i) it is the identity when restricted to BOOL, (ii) J(Prop) = Prop, and (iii) J( |= : State Prop → Bool)= |= : J(State ) Prop → Bool.
Objects in the subcategory RecSRWTh|= are also triples (R, (Σ',E∪D),J) but now we require the rewrite theory R to be recursive and the protecting extension (Σ',E ∪ D) ⊇ (Σ, E) to be Church-Rosser and terminating.
What about morphisms? At the end of Sect. 4.2 we showed that any Kripke structure can be defined in rewriting logic. Likewise, it is obvious that any stuttering map of Kripke structures (α, h): A −→B can be equationally defined in a protecting extension of RA and RB. Therefore, without loss of generality we can focus our attention on those stuttering maps that can be equationally defined. A morphism
(R1, (Σ' , E1 ∪ D1), J1) −→ (R2, (Σ' , E2 ∪ D2), J2) in SRWTh|=, called an algebraic
1	2

stuttering map, is a pair (α, h) such that:
(α, h) is a stuttering map (α, h): K(R1, J1(State ))Π1 −→ K(R2, J2(State ))Π2 .
There exists a theory extension (Ω, G) containing and protecting disjoint copies of (Σ' , E1 ∪ D1) and (Σ' , E2 ∪ D2) in which α and h can be equationally defined
1	2
through operators α : Prop1 −→ StateForm2 and h : J1(State )1 −→ J2(State )2
in Ω; the subscripts 1, 2 indicate the corresponding names for the disjoint copies of the types, and StateForm2 is a new type for representing state formulas over Prop2.
Note the existential quantifier in the second item; therefore, we do not need to choose any particular such extension to define the category: existence is enough. Since, by the general representability result, we can always find an extension (Ω, G) in which such a function h can be equationally defined, the category is well-defined, because for each composition we can do the same, perhaps with an extension unrelated to the extensions for each of the morphisms being composed.
The important point is that if α and h are recursive, and K(R1, J1(State ))Π1 and K(R2, J2(State ))Π2 are objects in RecSRWTh|=, then by the metaresult of Bergstra and Tucker [1] we can always find a ﬁnitary extension (Ω, G) that is both protecting of the pieces and Church-Rosser and terminating, and in which both α and h can be specified by means of Church-Rosser and terminating equations. Therefore, we define morphisms in RecSRWTh|=, called recursive algebraic stut- tering maps, to be pairs (α, h) as before, but now with the extra requirement that both α and h can be defined by means of Church-Rosser and terminating equations
in the extension (Ω, G).
We can now show that the construction defined in Sect. 4.1 that associates a Kripke structure to a rewrite theory with a chosen type of states and chosen state predicates is actually a functor. More precisely, we define K : SRWTh|= −→ KSMap, where KSMap is the global category of Kripke structures and stuttering maps, as follows:
for objects, K(R, (Σ',E ∪ D),J)= K(R,J(State ))Π;
for morphisms (α, h): (R1, (Σ' , E1∪D1), J1) −→ (R2, (Σ' , E2∪D2), J2), K(α, h)= 
1	2
(α, h).
Now, if we denote with RecKSMap the category whose objects are recursive Kripke structures and whose morphisms are stuttering maps (α, h): A −→ B such that α and h are both recursive functions, we have the following result.

Proposition 5.1 The functor K from SRWTh|= to KSMap is an equivalence of categories. Similarly, K : RecSRWTh|= −→ RecKSMap is also an equivalence.

The fact that K is an equivalence of categories is a general representability result, stating that all (resp. all recursive) Kripke structures and stuttering maps can be represented by rewrite theories and equationally defined functions (resp. recursive rewrite theories and recursive equationally defined functions).

The Example Revisited
To prove the correctness of the abstract machine implementation relative to the computation semantics we show that there exists a recursive algebraic stuttering map h between them.
Intuitively, ⟨empty, ρ, e⟩ should be related to ⟨ρ, e⟩. Consider this derivation:
⟨empty, empty, 2+ 3⟩→A⟨empty, empty, 2.3.+⟩
→A⟨2, empty, 3.+⟩
→A⟨3.2, empty, +⟩
→A⟨5, empty, empty⟩
The second, third, and fourth states in the derivation carry exactly the same infor- mation as the first one, though in a different order. The rules used to reach them are examples of what are called analysis rules in [12]. It seems appropriate, then, to relate them to the same state as the first one, namely ⟨empty, 2+ 3⟩. The situation is different for the last state: some information has been lost, and it seems more appropriate to relate this state to ⟨empty, 5⟩. This last step is an example of an application rule.
So we define h : A −→C by h(a)= ⟨ρ, e⟩ if a can be obtained from ⟨empty, ρ, e⟩ by zero or more applications of the analysis rules for the abstract machine together with Valm and Locm2 (see App. A). Note that h is partial: it is only defined for reachable states, which constitute a full substructure of A where h is total.
Alternatively, h can be defined by means of the following set of equations.
eq [Base] : h(< empty,rho,e>) = < rho,e > . eq [Opm1] : h(< S,rho,e . e’ . op . C >) =
h(< S,rho,e op e’ . C >) .
eq [Opm1] : h(< S,rho,be . be’ . bop . C >) = h(< S,rho,be bop be’ . C >) .
eq [Ifm1] : h(< S,rho,be . if(e, e’) . C >) = h(< S,rho,If be Then e Else e’ . C >) .
eq [Locm1] : h(< S,rho,e. <x, e’> . C >) = h(< S,rho,let x = e in e’ . C >) .
eq [Notm1] : h(< S,rho,be . not. C >) =
h(< S, rho, Not be . C >) .
eq [Eqm1] : h(< S,rho,e . e’ . equal . C >) =
h(< S,rho,Equal(e, e’) . C >) .
eq [Locm2] :
h(< S,(x, v) . rho,e . pop . C >) =
h(< v . S,rho,<x, e> . C >) .
eq [Valm] : h(< v . S,rho,C >) =
h(< S,rho,v . C >) if not(enabled(C)) .
eq [Valm] : h(< bv . S,rho,C >) =
h(< S,rho,bv . C >) if not(enabled(C)) .
The auxiliary predicate enabled used in [Valm] checks that none of the other equations can be applied.
Lemma 5.2 If h(⟨S, ρ, e.C⟩) = ⟨ρ, e'⟩, then there is a position p in e' such that e'|p = e and, if e is not a value, then e is a subexpression that can be reduced in e' by the rules of the computation semantics in the next step.
Theorem 5.3 h : A −→C is a recursive algebraic stuttering map.
Then, by the preservation result in Theorem 2.7, for all expressions e and en-

vironments ρ, we have that C, ⟨ρ, e⟩ |= AFv implies A, ⟨empty, ρ, e⟩ |= AFv. That is, A is a correct implementation of C. Note that h is not a bisimulation. In the computation semantics, for an expression e op e' we can choose whether to evaluate e before e' or vice versa, whereas the abstract machine always evaluates e first. That means that, for example, the transition ⟨empty, (1+2)+(3+4)⟩ → ⟨empty, (1+2)+7⟩ cannot be simulated by the abstract machine.
Stuttering Simulations as Rewrite Relations
The notion of map in Sect. 5.1, though already very general and applicable to many situations, is unsatisfactory in the sense that it restricts us to work only with functions. This drawback can be avoided by a simple extension of the ideas introduced above.
We define a category SRelRWTh|= with the same objects as SRWTh|=. Now, a morphism (R1, (Σ' , E1 ∪ D1), J1) −→ (R2, (Σ' , E2 ∪ D2), J2) in SRelRWTh|=,
1	2
called an algebraic stuttering simulation, is a pair (α, H) such that:
(α, H): K(R1, J1(State ))Π1 −→ K(R2, J2(State ))Π2 is a stuttering simulation of Kripke structures.
There exists a rewrite theory extension R3 containing and protecting disjoint copies of (Σ' , E1 ∪D1, R1) and (Σ' , E2 ∪D2, R2) in which α can be equationally
1	2
defined through an operator α : Prop1 −→ StateForm2, and H is defined by
rewrite rules through an operator H : J1(State )1 J2(State )2 −→ Bool such that
xHy iff R3 ▶ H(x, y) −→ true.
The subcategory RecSRelRWTh|= of recursive rewrite theories and r.e. alge- braic stuttering simulations is defined analogously, but we now require the theory extension R3 to be finitary and admissible in the sense of [6]. That is, R satisfies requirements similar to those for a recursive rewrite theory, but the conditions of the rules can now contain rewrites as long as they do not have new variables on their lefthand sides. Note that this is equivalent to requiring H to be r.e.
It is worth mentioning that when we work with functions in RecSRWTh|= we only consider recursive functions, whereas we allow arbitrary r.e. relations in RecSRelRWTh|=. This seems a natural extension to us, since in general the composition of recursive relations is not recursive.
Let us denote by RecKSSim the category of recursive Kripke structures and stuttering simulations (α, H): A −→ B such that α is recursive and H is r.e. The forgetful functor K is extended in the obvious way to the new categories, and we have the following result.
Proposition 5.4 With the above deﬁnitions, the functor K : SRelRWTh|= −→
KSSim is an equivalence of categories, and so is K : RecSRelRWTh|= −→
RecKSSim
This is the most general representability result possible for stuttering simulations as we have defined them. It shows that we can represent both Kripke structures and stuttering simulations in rewriting logic, and can use rewriting logic and membership

equational logic to reason about them.

A Communication Protocol Example
To emphasize the usefulness of the compositional approach, we illustrate it with an example that shows how a system can be successively abstracted until a finite one that can be model checked is reached.
If a communication mechanism does not provide reliable, in-order delivery of messages, it may be necessary to generate this service using the given unreliable basis. In [17] it is shown how this might be done and we slightly adapt it here, in a module PROTOCOL, to consider a system with messages a, b, and c of type Elem. The system consists of a “soup” of type Config of senders, receivers, and mes-
sages, built with the following constructors (Qid is a type of quoted identifiers):
op to:_(_,_) : Qid Elem Nat -> Msg . op to:_ack_ : Qid Nat -> Msg .
--- rec is the receiver, sendq is the
--- outgoing queue, sendbuff is either empty
--- or the current data, sendcnt is the
--- sender sequence number
op <_: Sender | rec:_, sendq:_ , sendbuff:_, sendcnt:_ > : Qid Qid List Contents Nat
-> Object .
--- sender is the sender, recq is the
--- incoming queue, and reccnt is the
--- receiver sequence number
op <_: Receiver | sender:_, recq:_,
reccnt:_ > : Qid Qid List Nat -> Object .
The sender produces a message (we omit the rules for b and c) and keeps on broadcasting it, together with an identifying number, until it receives an acknowl- edgment from the receiver.
rl [produce-a] :
< S : Sender | rec: R, sendq: L, sendbuff: empty, sendcnt: N > =>
< S : Sender | rec: R, sendq: L : a, sendbuff: a, sendcnt: N + 1 > .
rl [send] :
< S : Sender | rec: R, sendq: L, sendbuff: E, sendcnt: N > =>
< S : Sender | rec: R, sendq: L,
sendbuff: E, sendcnt: N > (to: R (E,N)) . rl [rec-ack] :
< S : Sender | rec: R, sendq: L, sendbuff: C, sendcnt: N >
(to: S ack M) =>
< S : Sender | rec: R, sendq: L,
sendbuff: (if N == M then empty else C fi), sendcnt: N > .
The receiver, in turn, waits for a message and sends an acknowledgment upon reception.
rl [receive] :
< R : Receiver | sender: S, recq: L, reccnt: M > (to: R (E,N)) =>
(if N == M + 1 
then < R : Receiver | sender: S, recq: L : E, reccnt: M + 1 >
else < R : Receiver | sender: S, recq: L, reccnt: M > fi)
(to: S ack N) .
Under reasonable fairness assumptions, these definitions will generate a reliable,

in-order communication mechanism from an unreliable one. The fault modes of the communication channel can be explicitly modeled using a Destroyer object in a module PROTOCOL-FAULTY.
op <_: Destroyer | sender:_, rec:_, cnt:_,
cnt’:_, rate:_ > : Qid Qid Qid Nat Nat Nat -> Object .
rl [destroy1] :
< D : Destroyer | sender: S, rec: R, cnt: N, cnt’: s(N’), rate: K >
(to: R (E,N)) =>
< D : Destroyer | sender: S, rec: R, cnt: N, cnt’: N’, rate: K > .
rl [destroy2] :
< D : Destroyer | sender: S, rec: R, cnt: N, cnt’: s(N’), rate: K >
(to: R ack N)
=>
< D : Destroyer | sender: S, rec: R, cnt: N, cnt’: N’, rate: K > .
rl [limited-injury] :
< D : Destroyer | sender: S, rec: R, cnt: N, cnt’: 0, rate: K >
=>
< D : Destroyer | sender: S, rec: R, cnt: s(N), cnt’: K, rate: K > .
Messages may be erased by objects of class Destroyer. The first counter repre- sents the identifying number of the messages they can destroy, and the second one is the number of remaining messages with that number that they are still allowed to remove. The attribute rate is used to reset the value of cnt’ once it reaches zero.
To check if messages are delivered in the correct order we define a state predicate prefix(S,R) in Π which holds for a sender S and a receiver R whenever the queue associated to R is a prefix of that of S. This is done in both modules by means of:
op prefix : Qid Qid -> Prop .
eq < S : Sender | rec: R, sendq: L1 : L2, sendbuff: C, sendcnt: N >
< R : Receiver | sender: S, recq: L1, reccnt: M >
CO:Config |= prefix(S, R) = true .
The new system will satisfy the same correctness conditions as PROTOCOL regard- less of messages being destroyed or arriving out of order. In particular, it should satisfy the formula AG prefix(’A, ’B) for the initial state:
eq init =
< ’A : Sender | rec: ’B,sendq: nil, sendbuff: empty,sendcnt: 0 >
< ’B : Receiver | sender: ’A,recq: nil, reccnt: 0 > .
For a proof, we define a stuttering simulation
H : K(PROTOCOL-FAULTY, Config)Π −→ K(PROTOCOL, Config)Π .
Given configurations (states) a in PROTOCOL-FAULTY and b in PROTOCOL, aHb iff:
b is obtained from a by removing all objects of class Destroyer, or
there exists a' such that a'Hb and a can be obtained from a' by the rules that belong only to PROTOCOL-FAULTY.

We can define H as a rewrite relation in an admissible rewrite theory that extends PROTOCOL and PROTOCOL-FAULTY as follows. In this specification, the types of states have been renamed as Config1 and Config2, and removeD and messages are aux- iliary functions that, given a configuration, remove all objects of class Destroyer and return all messages in it, respectively.
op H : Config1 Config2 -> Bool .
op undo-d1 : Qid Elem Nat -> Msg . op undo-d2 : Qid Nat -> Msg .
op undo-injury : -> Msg .
rl [destroy1-inv] :
< D : Destroyer | sender: S, rec: R, cnt: N, cnt’: N’ > undo-d1(R,E,N)
=>
< D : Destroyer | sender: S, rec: R, cnt: N, cnt’: s(N’) > (to: R (E,N)) .
rl [destroy2-inv] :
< D : Destroyer | sender: S, rec: R, cnt: N, cnt’: N’ > undo-d2(R,N)
=>
< D : Destroyer | sender: S, rec: R, cnt: N, cnt’: s(N’) > (to: R ack N) .
rl [limited-injury-inv] :
< D : Destroyer | sender: S, rec: R, cnt: s(N), cnt’: K, rate: K >
undo-injury
=>
< D : Destroyer | sender: S, rec: R, cnt: N, cnt’: 0 > .
crl H(C, C’) => true if removeD(C) = C’ . crl H(C, C’) => true
if M (to: R (E,N)) := messages(C’) /\
(to: R (E,N)) in messages(C) = false /\ C undo-d1(R,E,N) => C’’ /\
H(C’’, C’) => true .
crl H(C, C’) => true
if M (to: R ack N) := messages(C’) /\
(to: R ack N) in messages(C) = false /\ C undo-d2(R,E) => C’’ /\
H(C’’, C’) => true .
crl H(C, C’) => true
if C undo-injury => C’’ /\ H(C’’, C’) => true .


Theorem 5.5 H : K(PROTOCOL-FAULTY, Config)Π −→ K(PROTOCOL, Config)Π is an r.e. algebraic stuttering simulation.

By Theorem 2.7, the existence of H shows that if AG prefix(’A, ’B) is true in PROTOCOL then it must also hold in PROTOCOL-FAULTY; however, we must first prove that, and PROTOCOL is still an infinite state system. But PROTOCOL is now amenable to the equational techniques described in [19] and we can obtain a finite abstraction
G : K(PROTOCOL, Config)Π −→ K(ABS-PROTOCOL, Config)Π
by simply adding some equations to PROTOCOL (see [21] for the details of a very similar abstraction). Since ABS-PROTOCOL is finite we can prove the property using Maude’s model checker; by composing G with H this also proves that the same property is true in PROTOCOL-FAULTY.

Concluding Remarks
We have introduced a quite general notion of stuttering simulation between Kripke structures that relaxes the requirements on preservation of state predicates, both in not requiring identical preservation and in allowing formulas to be translated. We have also presented general representability results showing that both Kripke structures and their simulations can be fruitfully represented in rewriting logic. As witnessed by the numerous references in [14], rewriting logic is a very flexible framework for the specification of a wide range of systems; we believe that the ideas presented in this work, and in particular the compositional approach, can be useful in order to deal with the complexity of those systems and to reduce them to finite ones where properties can be proved using Maude’s model checker.

References
J. Bergstra and J. Tucker. Characterization of computable data types by means of a finite equational specification method. In J. W. de Bakker and J. van Leeuwen, editors, ICALP’80, LNCS 81, pages 76–90. Springer, 1980.
P. Borovansky´, C. Kirchner, H. Kirchner, and P.-E. Moreau. ELAN from a rewriting logic point of view. Theoretical Computer Science, 285(2):155–185, 2002.
M. C. Browne, E. M. Clarke, and O. Gru¨mberg. Characterizing finite Kripke structures in propositional temporal logic. Theoretical Computer Science, 59:115–131, 1988.
R. Bruni and J. Meseguer. Generalized rewrite theories. In J. C. M. Baeten et al, editors, ICALP 2003, LNCS 2719, pages 252–266. Springer, 2003.
E. M. Clarke, O. Grumberg, and D. A. Peled. Model Checking. MIT Press, 1999.
M. Clavel, F. Dur´an, S. Eker, P. Lincoln, N. Mart´ı-Oliet, J. Meseguer, and J. F. Quesada. Maude: Specification and programming in rewriting logic. Theoretical Computer Science, 285(2):187–243, 2002.
M. Clavel, F. Dur´an, S. Eker, P. Lincoln, N. Mart´ı-Oliet, J. Meseguer, and C. Talcott. Maude manual (version 2.3). http://maude.cs.uiuc.edu/manual/ , 2007.
M. Clavel, M. Palomino, and A. Riesco. Introducing the ITP tool: a tutorial. Journal of Universal Computer Science, 12(11):1618–1650, 2006. Selected papers from PROLE 2005.
N. Dershowitz and J.-P. Jouannaud. Rewrite systems. In J. van Leeuwen, editor, Handbook of Theoretical Computer Science, Vol. B, pages 243–320. North-Holland, 1990.
S. Eker, J. Meseguer, and A. Sridharanarayanan. The Maude LTL model checker. In F. Gadducci and
U. Montanari, editors, WRLA’02, ENTCS 71. Elsevier, 2002.
K. Futatsugi and R. Diaconescu. CafeOBJ Report. World Scientific, AMAST Series, 1998.
M. Hennessy. The Semantics of Programming Languages: An Elementary Introduction Using Structural Operational Semantics. John Wiley & Sons, 1990.
P. Manolios. Mechanical Verification of Reactive Systems. PhD thesis, University of Texas at Austin, Aug. 2001.
N. Mart´ı-Oliet and J. Meseguer. Rewriting logic: Roadmap and bibliography. Theoretical Computer Science, 285(2):121–154, 2002.
N. Mart´ı-Oliet, J. Meseguer, and M. Palomino. Theoroidal maps as algebraic simulations. In J. L. Fiadeiro et al, editors, WADT 2004, LNCS 3423, pages 126–143. Springer, 2005.
J. Meseguer. Conditional rewriting logic as a unified model of concurrency. Theoretical Computer Science, 96(1):73–155, 1992.
J. Meseguer. A logical theory of concurrent objects and its realization in the Maude language. In
G. Agha et al, editors, Research Directions in Concurrent Object-Oriented Programming, pages 314–
390. MIT Press, 1993.


J. Meseguer. Membership algebra as a logical framework for equational specification. In F. Parisi- Presicce, editor, WADT’97, LNCS 1376, pages 18–61. Springer, 1998.
J. Meseguer, M. Palomino, and N. Mart´ı-Oliet. Equational abstractions. In F. Baader, editor, CADE- 19, LNCS 2741, pages 2–16. Springer, 2003.
J.	Meseguer,	M.	Palomino,	and	N.	Mart´ı-Oliet.	Algebraic	simulations.
http://maude.sip.ucm.es/∼ miguelpt/, 2007.
J. Meseguer, M. Palomino, and N. Mart´ı-Oliet. Equational abstractions. Extended version. Submitted.
http://maude.sip.ucm.es/∼ miguelpt/, 2007.
K. S. Namjoshi. A simple characterization of stuttering bisimulation. In S. Ramesh and G. Sivakumar, editors, FSTTCS’97, LNCS 1346, pages 284–296. Springer, 1997.
M. Palomino, J. Meseguer, and N. Mart´ı-Oliet. A categorical approach to Kripke structures and simulations. In J. L. Fiadeiro et al, editors, CALCO 2005, LNCS 3629, pages 313–330. Springer, 2005.
J. R. Shoenfield. Degrees of Unsolvability. North-Holland, 1971.
A. Verdejo and N. Mart´ı-Oliet. Executable structural operational semantics in Maude. Technical Report 134-03, Departamento de Sistemas Inform´aticos y Programaci´on, Universidad Complutense de Madrid, 2003.
P. Viry. Equational rules for rewriting logic. Theoretical Computer Science, 285(2):487–517, 2002.

A	Semantics of Fpl
Computation semantics for Fpl. (There is an analogous set of rules for Boolean expressions [20].)
rl [VarRc] : < rho, x > => < rho, rho(x) > . rl [OpRc] : < rho, v op v’ > =>
< rho, Ap(op,v,v’) > . crl [OpRc] : < rho, e op e’ > =>
< rho’, e’’ op e’ >
if < rho, e > => < rho’, e’’ > . crl [OpRc] : < rho, e op e’ > =>
< rho’, e op e’’ >
if < rho, e’ > => < rho’, e’’ > . crl [IfRc] : < rho,If be Then e Else e’ >
=> < rho’,If be’ Then e Else e’ > if < rho, be > => < rho’, be’ > .
rl [IfRc] : < rho, If T Then e Else e’ >
=> < rho, e > .
rl [IfRc] : < rho, If F Then e Else e’ >
=> < rho, e’ > .
crl [LocRc] : < rho, let x = e in e’ > =>
< rho’, let x = e’’ in e’ > if < rho, e > => < rho’, e’’ > .
rl [LocRc] : < rho, let x = v in e’ > =>
< rho, e’[v / x] > .
Analysis rules for the abstract machine.
rl [Opm1] : < ST, rho, e op e’ . C > =>
< ST, rho, e . e’ . op . C > . rl [Opm1] : < ST, rho, be op be’ . C > =>
< ST, rho,be . be’ . bop . C > .
rl [Ifm1] :
< ST, rho, If be Then e Else e’ . C >
=> < ST, rho, be . if(e, e’) . C > .
rl [Locm1] : < ST, rho, let x = e in e’ . C >
=> < ST, rho, e . < x, e’ > . C > . 
rl [Notm1] : < ST, rho, Not be . C > =>
< ST, rho, be . not . C > . rl [Eqm1] : < ST,rho,Equal(e, e’) . C > =>
< ST,rho, e . e’ . equal . C > .
Application rules for the abstract machine.
rl [Opm2] : < v’ . v . ST, rho, op . C >
=> < Ap(op,v,v’) . ST,rho,C > .
rl [Opm2] : < bv’ . bv . ST, rho, bop . C >
=> < Ap(bop,bv,bv’) . ST, rho, C > . crl [Varm] : < ST, rho, x . C > =>


< v . ST, rho, C > if v := lookup(rho,x) .
crl [Varm] : < ST, rho, bx . C > =>
< bv . ST, rho, C > if bv := lookup(rho,bx) .
rl [Valm] : < ST, rho, v . C > =>
< v . ST, rho, C > . rl [Valm] : < ST, rho, bv . C > =>
< bv . ST, rho, C > .
rl [Notm2] : < T . ST, rho, not . C > =>
< F . ST, rho, C > .
rl [Notm2] : < F . ST, rho, not . C > =>
< T . ST, rho, C > .
crl [Eqm2] : < v . v’ . ST, rho, equal . C > 
=> < T . ST, rho, C >
if v = v’ . 
crl [Eqm2] : < v . v’ . ST, rho, equal . C > 
=> < F . ST, rho, C >
if v =/= v’ .
rl [Ifm2] : < T . ST, if(e, e’) . C > =>
< ST, rho, e . C > .
rl [Ifm2] : < F . ST, rho, if(e, e’) . C >
=> < ST, rho, e’ . C > .
rl [Locm2] : < v . ST, rho, < x, e > . C >
=> < ST, (x,v) . rho, e . pop .C >. 
rl [Pop] : < ST, (x,v) . rho, pop . C >
=> < ST, rho, C > .
