

Electronic Notes in Theoretical Computer Science 265 (2010) 423–436
www.elsevier.com/locate/entcs

Full Abstraction Without Synchronization Primitives
Andrzej S. Murawski1
Oxford University Computing Laboratory Wolfson Building, Parks Road, Oxford OX1 3QD, UK


Abstract
Using game semantics, we prove a full abstraction result (with respect to the may-testing preorder) for Ide- alized Algol augmented with parallel composition (IA||). Although it is common knowledge that semaphores
can be implemented using shared memory, we find that semaphores do not extend IA|| conservatively. We explain the reasons for the mismatch.
Keywords: Shared-Variable Concurrency, Mutual Exclusion, Full Abstraction, Game Semantics


Introduction
The mutual exclusion problem asks one to find sections of code that will allow two threads to share a single-use resource without conflict. It turns out that shared memory (with atomic reads and writes) can be used to solve it without any addi- tional synchronization primitives. A typical solution consists of two sections of code (called entry and exit protocols respectively) that each of the two processes can use to enter and exit their designated criticial sections respectively.
Quite a collection of trial solutions have been shown to be incorrect and at some moment people that had played with the problem started to doubt whether it could be solved at all.
So writes Dijkstra [3] about early attempts to attack the problem. He credits Dekker with the first correct solution, which was later simplified by several other authors.

1 Supported by an EPSRC Advanced Research Fellowship (EP/C539753/1).

1571-0661© 2010 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2010.08.025

Peterson’s tie-breaker algorithm [10], reproduced below, was particularly elegant.

/* Entry Code 1 */
Q [1 ] := 1;
turn := 1;
while (Q [2 ] and (turn = 1)) do skip;


/* Exit Code 1 */
Q [1 ] := 0;
/* Entry Code 2 */
Q [2 ] := 1;
turn := 2;
while (Q [1 ] and (turn = 2)) do skip;


/* Exit Code 2 */
Q [2 ] := 0;

Solutions to the two-process case were subsequently generalized to n processes (Lamport’s bakery algorithm [7] is one of the simplest). Although the results demon- strated that, from a theoretical point of view, the sharing of memory was sufficient to enforce mutual exclusion, they were considered unsatisfactory from the conceptual and implementation-oriented points of view. The intricacy of interactions gener- ated by the code was judged to obscure the purpose it was supposed to serve and the “busy-waiting” involved looked wasteful. This motivated the introduction of semaphores [3], a synchronization construct on a higher level than memory reads and writes.
In this paper we would like to focus on the expressive power of semaphores in the setting of shared-variable higher-order concurrency and contextual testing. We consider a variant IA of Reynolds’ Idealized Algol [11] augmented with parallel
composition, referred to as IA||, and prove an inequational full abstraction result for
the induced notion of contextual may-testing. The result is obtained using game semantics by uncovering a preorder on strategies, founded on a notion reminiscent of racing computations.
Contrary to what the various mutual-exclusion algorithms might suggest, we find that there are strategies corresponding to programs with semaphores, which do not correspond to any IA||-terms. What is more, we can identify a game-semantic closure property enjoyed by all strategies corresponding to IA||-terms, which may fail in the presence of semaphores. This makes it possible to apply our model to the semantic detection of the “need for semaphores”. As for contextual may-approximation and may-equivalence, we show that IA|| extended with semaphores does not constitute a conservative extension of IA||. We conclude by relating the apparent mismatch to non-uniformity of mutual-exclusion algorithms based on shared memory alone.
From the game-semantic perspective, our results demonstrate that a language without semaphores is considerably more difficult to handle than one incorporating them. So, the addition of communication primitives to a language can lead to cleaner mathematical structure.

Idealized Algols
We shall be concerned with parallel extensions of Reynolds’ Idealized Algol [11], which has become the canonical blueprint for synthesizing imperative and functional



Fig. 1. Syntax of IA

programming. The particular variant of Idealized Algol, presented in Figure 1 and henceforth referrred to as IA, is known in the literature as Idealized Algol with active expressions [1]. This paper is primarily devoted to IA extended with the parallel composition operator ||. It enters the syntax through the following typing rule.
Γ ▶ M1 : com   Γ ▶ M2 : com Γ ▶ M1 || M2 : com
We shall write IA|| to denote the extended language. Our main goal will be to arrive at a fully abstract model for contextual approximation and equivalence induced by IA||. In particular, we would like to understand how the addition of semaphores to IA|| affects the two. To that end, we consider yet another prototypical language, called PA, which is IA|| extended with semaphores. We give the syntax of PA in Figure 2. We assume that semaphores and variables are initialized to “available” and 0 respectively.
Remark 2.1 PA was introduced in [4]. It is closely related to Brookes’ Paral- lel Algol [2], which, in contrast to PA, represents the coarse-grained approach to enforcing atomicity. Parallel Algol contains the await M then N construct which executes the guard M as an atomic action and, if the guard is true, N is run im- mediately afterwards, also as an indivisible operation. PA and Parallel Algol appear equi-expressive. Clearly, semaphores can be implemented using await - then - and ordinary variables. A translation in the other direction is also possible, for exam-



Fig. 2. Syntax of PA
ple, in the style of the encoding of Parallel Algol into the π-calculus [12]. We use PA because the game semantics we rely on is better suited to modelling ﬁne-grained concurrency and await would have had to be interpreted indirectly by translation.
For a closed IA-, IA||-, PA-term ▶ M : com we shall write M ⇓ iff there exists a terminating run of M (the reduction rules are routine and can be found, for example, in [4]). Note that our notion of termination is angelic. Accordingly, the notions of contextual approximation and equivalence considered here will be consistent with may-testing and will not take the possibility of deadlock/divergence into account.
Definition 2.2 Let Γ ▶ M1, M2 : θ be IA||-terms. Γ ▶ M1 : θ is said to contex- tually approximate Γ ▶ M2 : θ (written Γ ▶ M1 ±IA|| M2 : θ), if, and only if, for any IA||-context C[−] such that ▶ C[Mi] : com (i = 1, 2), C[M1] ⇓ implies C[M2] ⇓. Further, Γ ▶ M1 : θ and Γ ▶ M2 : θ are contextually equivalent (writ- ten Γ ▶ M1 ∼=IA|| M2) if each contextually approximates the other.
Analogously, one can define contextual approximation (resp. equivalence) using terms and contexts of IA or PA. We shall write ±IA (respectively ∼=IA) or ±PA (resp.
∼=PA when referring to them). For example, it can be readily seen that ±IA|| is not a conservative extension of IA.
Example 2.3 The two IA-terms
λf exp→com→com.newvar x in f (!x)(x := !x + 2)
λf exp→com→com.newvar x in f (!x)(x := !x + 1; x := !x + 1)
are IA-equivalent, but are not PA-equivalent.
The main result of our paper is an explicit characterization of ±IA|| (Theorem 4.5) in terms of a preorder on strategies. It will allow us to demonstrate that PA is not a conservative extension of IA||.
Example 2.4 In view of the results given below, the simplest example illustrating the non-conservativity of PA with respect to IA|| (as far as contextual approximation

is concerned) are the terms x and x||x, where x is a free identifier of type com. We shall have x ±IA|| x||x and x/±PA x||x.
Informally, x approximates x||x in IA||, because any successful run of C[x] can
be closely followed by that of C[x||x] in which each atomic action of the second x takes place right after the corresponding action of the first x (one keeps on racing the other).  In contrast, in PA, x might be instantiated with code that will try
to acquire a semaphore, in which case x||x will not terminate (take, for example,
C[] ≡ newsem S in ((λxcom.[ ]) grab(S))).
Similar terms demonstrate that contextual equivalence is not preserved either. We have (x or (x||x)) ∼=IA|| (x||x), but (x or (x||x)) ∼/=PA (x||x), where M or N stands for
newvar X in ((X :=0 || X := 1); if !X then M else N ).



Game semantics
IA and PA have already been studied using game semantics, in [1] and [4] respec- tively. The full abstraction results presented therein are particularly elegant, as they characterize ±IA and ±PA via (complete-)play containment. Next we shall review the game model of PA (originally presented in [4]), as our full abstraction result for IA|| will be phrased in terms of strategies from that model. More precisely, we are going to exhibit a preorder, different from inclusion, that will turn out to capture contextual approximation in IA||. The induced equivalence relation, characterizing
∼=IA|| , is also different from play equivalence.


Game semantics uses arenas to interpret types.
Definition 3.1 An arena A is a triple ⟨MA, λA, ▶A⟩, where
MA is a set of moves;
λA : MA → { O, P } × { Q, A} is a function determining whether m ∈ MA is an Opponent or a Proponent move, a question or an answer; we write λOP , λQA for the composite of λA with respectively the ﬁrst and second projections;
A	A
▶A is a binary relation on MA, called enabling, such that m ▶A n implies
λQA(m) = Q and λOP (m) /= λOP (n). Moreover, if n ∈ MA is such that m /▶A n
A	A	A
for any m ∈ MA then λA(n) = (O, Q).
If m ▶A n we say that m enables n. We shall write IA for the set of all moves of A which have no enabler; such moves are called initial. Note that an initial move must be an Opponent question.
In arenas used to interpret base types all questions are initial and all P-moves are answers enabled by initial moves as detailed in the table below, where m ∈ N.


Contexts and function types are modelled with the help of additional constructions on arenas:

MA×B = MA + MB λA×B = [λA, λB]
MA⇒B = MA + MB
λA⇒B = [⟨ λPO, λQA ⟩, λB]

A	A
▶A×B = ▶A + ▶B	▶A⇒B = ▶A + ▶B +{ (b, a) | b ∈ IB and a ∈ IA }
The function λPO : MA → { O, P } is defined by λPO(m) = O iff λOP (m) = P .
A	A	A
Arenas provide all the details necessary to specify the allowable exchanges of moves. Formally, they will be justified sequences satisfying some extra properties. A justiﬁed sequence in arena A is a finite sequence of moves of A equipped with
pointers. The first move is initial and has no pointer, but each subsequent move n must have a unique pointer to an earlier occurrence of a move m such that m ▶A n. We say that n is (explicitly) justified by m or, when n is an answer, that n answers
m. If a question does not have an answer in a justified sequence, we say that it is pending (or open) in that sequence. In what follows we use the letters q and a to refer to question- and answer-moves respectively, o and p to stand for O- and P-moves, and m to denote arbitrary moves.
Not all justified sequences will be regarded as valid. In order to constitute a legal play, a justified sequence must satisfy a well-formedness condition, which reflects the “static” style of concurrency in PA: any process starting sub-processes must wait for the children to terminate in order to continue. In game terms: if a question is answered then all questions justified by it must have been answered earlier (exactly once). This is made precise in the following definition.
Definition 3.2 The set PA of plays over A consists of justiﬁed sequences s over
A satisfying the two conditions below.

FORK In any preﬁx s' = ··· q ,{
m of s, the question q must be pending

before m is played.
WAIT In any preﬁx s' = ··· q ,{

a of s, all questions justiﬁed by q must be

answered.
Note that interleavings of justified sequences are not justified sequences; instead we shall call them shuﬄed sequences. For two shuffled sequences s1 and s2, s1 M s2 denotes the set of all interleavings of s1 and s2. For two sets of shuffled sequences

S1 and S2, S1 M S2 = S
s1∈S1,s2∈S2
s1 M s2. Given a set X of shuffled sequences, we

define X0 = X, Xi+1 = Xi M X. Then X③, called iterated shuﬄe of X, is defined

to be S

i∈N
Xi.

We say that a subset σ of PA is O-complete if s ∈ σ and so ∈ PA entail so ∈ σ.
Definition 3.3 A strategy σ on A (written σ : A) is a preﬁx-closed and O-complete subset of PA.

Strategies σ : A ⇒ B and τ : B ⇒ C are composed in the standard way, by considering all possible interactions of plays from τ with shuffled sequences of σ③ in the shared arena B, and then hiding the B moves.
For modelling concurrent programs, one considers a special class of so-called saturated strategies, which contain all possible (sequential) observations of the rel- evant (parallel) interactions. Consequently, actions of the environment (O-moves) can always be observed earlier (as soon as they have been enabled), actions of the program can always be observed later (but not later than moves that they justify). To formalize this, for any arena A, one defines a preorder ≤ on PA as the least reflexive and transitive relation satisfying s0s1os2 ≤ s0os1s2 and s0ps1s2 ≤ s0s1ps2 for all s0, s1, s2. In the above-mentioned pairs of plays, moves on the left-hand side of ≤ are meant to have the same justifiers as on the right-hand side. The two sat- uration conditions, in various formulations, have a long history in the semantics of concurrency [13,5,6].
Definition 3.4 A strategy σ is saturated iff s ∈ σ and s ≤ s' imply s' ∈ σ.
Arenas and saturated strategies form a Cartesian closed category Gsat, in which Gsat(A, B) consists of saturated strategies on A ⇒ B. The identity strategy is defined by “saturating” the alternating plays s ∈ PA1⇒A2 in which P “copies” O- moves to the other A-component (formally, for any even-length prefix t of s we have t T A1 = t T A2). We used A1 and A2 to distinguish the two copies of A in the arena A ⇒ A).
PA-terms x1 : θ1, ··· , xn : θn ▶ M : θ can be interpreted in Gsat as strategies in the arena Jθ1) ×· · ·× Jθn) ⇒ Jθ). The identity strategies are used to interpret free identifiers. Other elements of the syntax are interpreted by composition with desig- nated strategies. Below we give plays defining some of them (as the least saturated strategies containing the plays). We use subscripts to indicate the subarena a move comes from.

The strategies for variable- and semaphore-binding are for playing in arenas (Jvar)0 ⇒ Jβ)1) ⇒ Jβ)2 and (Jsem)0 ⇒ Jβ)1) ⇒ Jβ)2 respectively.
As shown in [4], the interpretation of PA sketched above yields a fully abstract model as detailed in Theorem 3.5. A play is called complete if it does not contain

unanswered questions. We write comp(σ) to denote the set of non-empty complete
plays of the strategy σ.
Theorem 3.5 [4] For any PA-terms Γ ▶ M1 : θ and Γ ▶ M2 : θ, Γ ▶ M1 ±PA M2 if, and only if, comp(JΓ ▶ M1)) ⊆ comp(JΓ ▶ M2)). Hence, Γ ▶ M1 ∼=PA M2 if, and only if, comp(JΓ ▶ M1)) = comp(JΓ ▶ M2)).
We are going to prove an analogous result for IA||, though the preorder involved will be much more complicated.

Cloning
A shuffled sequence which is an interleaving of plays will be called a shuffled play. A shuffled play will be called complete if it is an interleaving of complete plays. In order to capture contextual approximation in IA||, it turns out useful to introduce an auxiliary operation on complete shuffled plays. The operation will clone part of the sequence, namely, a selected question along with all the moves that it justifies.
Formally, let s be a complete shuffled play and let q be an occurrence of a question in s. Suppose m1, ··· , mk are all the moves hereditarily justified by q in s and, in particular, that mk is the answer justified by q. For convenience we write m0 for q, so that s = s0m0s1m1 ··· skmksk+1, where each si (0 ≤ i ≤ k + 1) is a possibly empty sequence of moves. Let us now define another sequence sq to be s in which each mi (0 ≤ i ≤ k) is followed by its fresh copy m', i.e.
sq = s0m0m' s1m1m' ··· skmkm' sk+1,
0	1	k

m0 and m'
are justified by the same move (from s0, if any) and m'
justifies m'

(i < j) if, and only if, mi justifies mj. We shall call m'
and m'
the anchor

points. Intuitively, sq can be thought of as s in which part of the play is being
“shadowed”, as in a racing computation. Note that if s is a complete play and q is chosen to be the initial question, then the whole of s will be cloned and sq will become a complete shuffled play.
Definition 4.1 Given two complete shuffled plays s, t ∈ PA, we shall write s t provided s contains an occurrence of a question q such that t = sq. If we want to stress that q is an X-question (X ∈ { O, P }), we write s  X t. In what follows, we shall often consider the transitive closure of the above relations, which will be

denoted by  ∗,  ∗
and  ∗
respectively.

Example 4.2	(i) Consider the following two plays in ((Jcom)3 ⇒ Jcom)2) ×
Jexp)1) ⇒ Jcom)0.




s1 = r0 r2 r3 q1 01 d3 d2 d0 O P O P O P  O P
s2 = r0 r2 r3 r3 q1 01 d3 d3 d2 d0 O P  O O P  O P  P  O  P

We have omitted some pointers for the sake of clarity: in both plays r0 justifies
r2, q1, d0; r2 justifies d2; r0 justifies d0, and q1 justifies 01. Then s1  O s2.
(ii) Consider the following two plays in Jcom)1 ⇒ Jcom)0.


	
s1 = r0 r1 d1 d0	s2 = r0 r1 r1 d1 d1 d0
Note that s1  P s2.
Definition 4.3 Let σ1, σ2 : A.  We define σ1 ≤ σ2 to hold when for any s1 ∈
comp(σ1) there exists s2 ∈ comp(σ2) such that s1  ∗ s2.
Example 4.4 Jx : com ▶ x : com) ≤ Jx : com ▶ x||x : com)
≤ underpins our full abstraction result. The remainder of the paper will be devoted to its proof.
Theorem 4.5 (Full Abstraction) Let Γ ▶ M1, M2 : θ be IA||-terms. Then Γ ▶
M1 ±IA|| M2 if, and only if, JΓ ▶ M1) ≤ JΓ ▶ M2).
Definability
First we proceed to establish the left-to-right implication of Theorem 4.5, for which we need to prove a definability result. Recall from [4] that, for any complete play s, it is possible to construct a PA-term such that the corresponding strategy is the least saturated strategy containing s. This property no longer holds for IA||-terms (this will follow from the next section in which we identify a closure property of strategies corresponding to IA||-terms). Instead we shall prove a weakened result for IA|| (Lemma 5.2).
Example 5.1 Let us write [cond ] for if cond then skip else Ωcom. Consider the play s = r0r1r2d2d1d0 from J(com2 → com1) → com0) and the term
λf com→com.newvar X in newsem S in f (grab(S); X := 1); [!X = 1],
which is actually interpreted by the least saturated strategy containing s. When semaphores are no longer available, the“best” one can do to make sure that the assignment X := 1 is executed once is to protect it with the guard [!X = 0] instead of grab(S). However, this will not prevent multiple assignments from taking place if f runs several copies of its argument in parallel (so that each can pass the test
!X = 0 before X is set to 1). Accordingly, the strategy corresponding to
λf com→com.newvar X in f ([!X = 0]; X := 1); [!X = 1],
will contain, among others, the complete play r0r1r2r2d2d2d1d0. In fact, the strat-
egy contains all complete plays t such that s  ∗ t. This observation admits the
following generalization.
Lemma 5.2 Suppose Θ is an IA||-type and s ∈ comp(PJΘ)). There there exists an
IA||-term ▶ Ms : Θ such that

comp(J ▶ Ms)) = { u | ∃t ∈ PJΘ). (s  ∗
t and t ≤ u) }.

Let us describe some of the ideas behind the construction of Ms. First of all, it is worth noting that, since saturated strategies are involved, s determines dependencies of P-moves on preceding O-moves. To enforce that order, we arrange for O-moves

to generate global side-effects (Gi := 1) so that P-moves can only take place if the side-effects corresponding to preceding O-moves occurred.
The example above shows that with shared memory alone we are unable to control the exact number of O-moves in complete plays. However, we can make sure that whenever copies of O-moves from the original play are played, they are globally synchronized. To this end, before the corresponding flag variable Gi is set to 1, we arrange for a test [!Gi = 0]. This creates a “window of opportunity” for the racing O-moves, into which they have to fit if a complete play is to be reached (late arrivals will fail the test and cause divergence).
Having synchronized racing on O-moves, we also need to make sure that the “races” are consistent with s. The global side effects are not enough for that purpose as they only signal that in one of the races the requisite moves have been made. To ensure consistency with s in cloned subplays (i.e. to ensure that all relevant moves from s are cloned) we introduce local flags Li, each of which is set at the same time as Gi, except that there is a local test whether Li has indeed been set. It suffices to use this mechanism for O-questions only, as the presence of O-answers follows from the fact that a complete play is to be reached in the end.
Example 5.3 Consider θ ≡ (((com4 → com3) → com2) → com1) → com0 and the following play s ∈ PJθ), in which we suppressed pointers from questions to answers.

r0 r1 r2 r3 r4 d4 d3 d2 d1 d0 O P O P O P  O P  O P
The term Ms below satisfies Lemma 5.2. Note how the presence of L4 ensures that in any complete play from J ▶ Ms) containing two occurrences of r2 we must also have at least one occurrence of r4 hereditarily justified by r2. G4 alone would not suffice for this purpose.
λf. newvar G0, G2, G4, G6, G8, L0 in
[!G0 = 0]; G0 := 1; L0 := 1; [!G0 = 1];
newvar L2 in
f (λg. [!G2 = 0]; G2 := 1; L2 := 1; [	(!Gj = 1)];

newvar L4 in
g([!G4 = 0]; G4 := 1; L4 := 1; [ 

(!Gj = 1)]);

[!L4 = 1];
[!G6 = 0]; G6 := 1; [ 

(!Gj = 1)]);

[!L2 = 1];
[!G8 = 0]; G8 := 1; [ 

(!Gj = 1)]

With the definability result in place, we obtain the following corollary.

Corollary 5.4 For any IA||-terms ▶ M1, M2 : θ, if ▶ M1 ±
M1 : θ) ≤ J ▶ M2 : θ).
IA|| M2 : θ then J ▶

Soundness
In this section we identify a technical property satisfied by strategies corresponding to IA||-terms. In addition to helping us complete the proof of our full abstraction re- sult, it provides us with a tool for checking whether a given strategy might originate from an IA||-term.
Lemma 6.1 Let Γ ▶ M be an IA||-term, σ = JΓ ▶ M ) and s ∈ comp(σ). Then, for
any play t such that s  ∗ t, there exists u ∈ comp(σ) such that t  ∗ u.
Intuitively, the Lemma asserts that, for each successful interaction between the environment and the system, the environment can always trigger others, which closely follow (race) the original blueprint. Its logical structure resembles the con- ditions used to characterize mkvar-free computation in the game semantics litera- ture [8,9].
Before discussing the proof, let us consider a number of examples.
Example 6.2	(i) Lemma 6.1 fails for the strategy σ used to interpret semaphore- binding, generated by plays of the form
q2 q1 (grab0 okg release0 okr )∗ (grab0 okg + ϵ) a1 a2.
0	0	0
Observe	that	s	=	q2 q1 grab0 okg a1 a2	∈	σ	and	consider	t	=
g	g	0	∗
q2 q1 grab0 grab0 ok 0 ok 0 a1 a2. Clearly s  O t. However, note that t  P u, where u ∈ comp(σ), must imply t = u (the only P-move that can possibly be
taken to support t  + u is q1, but plays in σ can only contain one occur-
rence of q1). t = u ∈ comp(σ) is impossible, though, because any play from σ
that contains two occurrences of okg must contain at least one occurrence of
release0. Consequently, the “semaphore strategy” does not satisfy Lemma 6.1.
The reasoning above does not apply to the strategy τ responsible for memory management.  For instance, for s = q2 q1 write(3) ok a1 a2, t = q2 q1 write(3) write(3) ok ok a1 a2 we do have t ∈ comp(τ ), because one of the defining plays is q2 q1 write(3) ok write(3) ok a1 a2.
The identity strategy is easily seen to satisfy Lemma 6.1.
All the other strategies corresponding to the syntax of IA|| satisfy the Lemma
vacuously, because s ∈ comp(σ) and s  ∗ t, where t is a play, imply s = t.
To prove the Lemma it suffices to show that the property involved is preserved by composition.  The natural approach would be to try to apply the property to the two strategies alternately with the hope of deriving it for the composite. However, given the current formulation, this alternation might seemingly have no end! To recover, we shall make the property more precise by relating the operations

witnessing t  ∗
u to those fulfulling the same task for s  ∗
t. Intuitively, we want

to express the fact that each of the clonings underlying t  ∗ u is embedded into a
cloning underpinning s  ∗ t. To make the intuition precise, let us assign a fresh
colour to the two anchor points involved in each step of s  ∗ t (the colours are to
stay with the moves as additional moves are being added). Then we shall say that

t  ∗
u occurs within s  ∗
t iff for each pair of anchor points generated during

the passage from t to u (according to t  ∗ u), both are between moves of the same
colour.
An immediate consequence of the new requirement will be that the maximum distance (calculated in a way to be introduced) between anchor points involved in
s  ∗ t will be strictly larger than the maximum distance between anchor points
generated by t  ∗ u 2 . This is not necessarily the case for the obvious notion of
distance (number of moves in-between), because  -steps add moves to plays.
Definition 6.3 Given a sequence of moves s, we define the alternating length of s to be the number of times the ownership of moves changes as we scan the sequence from left to right. The empty sequence is assumed to have alternating length 0.
For instance, o1o2o3 is of (alternating) length 0, o1o2p2p3 has length 1 and o1p1o2p3 is of length 3. From now on, the distance between anchor points will be defined to be the alternating length of the segment between them (without the
points). Given s1  ∗ s2 we shall say that the associated w eight is the largest of
the distances between anchor points involved in the transitions from s1 to s2. Note
that if s  t then s and t have the same alternating length. Because of that, if

t  ∗
u occurs within s  ∗
t, the weight of t  ∗
u must be strictly smaller than

that of s  ∗ t.
Another consequence of “occurring within”, crucial for establishing composition- ality, is the fact that during composition of σ with τ , due to the embeddings, local decreases in weight effected by σ imply that the corresponding weight calculated for σ③ also decreases. Moreover, the decreases caused by σ and τ can be meaningfully combined. As a consequence, we can show a strengthened version of Lemma 6.1.
Lemma 6.4 Let Γ ▶ M be an IA||-term, σ = JΓ ▶ M ) and s ∈ comp(σ). Then,

for any play t such that s  ∗
t, there exists u ∈ comp(σ) such that t  ∗
u, and

t  ∗ u occurs within s  ∗ t.
Example 6.5 The closure property spelt out in Lemma 6.4 shows that the prob- lems identified in Example 5.1 are unavoidable: there can be no IA||-term ▶ M : ((com2 → com1) → com0 such that comp(J ▶ M )) = { r0r1r2d2d1d0 }. In contrast, the PA-term
λf com→com.newvar X in newsem S in f (grab(S); X := 1); [!X = 1]
does satisfy the equation. Consequently, in PA, semaphores (in fact, even a single occurrence of grab) cannot be replaced with shared memory up to observational equivalence.
Example 6.6 The test-and-set instruction (test-set(X)) sets the value of the given variable to 1 and returns the old value as a single atomic (non-interruptible) operation. Observe that, if we added test-set(X) to IA||, we could replace
λf com→com.newvar X in newsem S in f (grab(S); X := 1); [!X = 1]



2 Abusing the notation somewhat, here we regard s  ∗
t as shorthand for a concrete sequence demon-

O
strating that s  ∗ t.

with
λf com→com.newvar X in f ([test-set(X) = 0]); [!X = 1].
Since the definability argument for PA [4] only relies on “grabs” of this kind, it carries over to IA|| + test-set. Consequently, IA|| + test-set has the same discriminating power as PA.

Using Lemma 6.4 we can eventually complete the proof of Theorem 4.5 by showing :
Corollary 6.7 For any IA||-terms ▶ M1 : θ and ▶ M2 : θ, if J ▶ M1 : θ) ≤ J ▶
M2 : θ) then ▶ M1 ±IA|| M2 : θ.

Conclusion
We have constructed an inequationally fully abstract model of IA|| inside an existing model of PA and given an explicit characterization of contextual approximation in PA in terms of a preorder on complete plays. We have also identified a closure property that all IA||-terms satisfy and some PA-terms do not. Consequently, we can conclude that semaphores cannot be programmed in IA|| if the translation is to preserve observational equivalence (of PA-terms). So, why do the solutions to the mutual exclusion problem not apply?
The reason is that semaphores offer a uniform solution to the mutual exclusion problem. Whenever different processes intend to use a critical section, they can run identical entry and exit protocols (grab(S) and release(s) respectively). In contrast, existing solutions based on shared memory are not uniform, even though they are often “symmetric”, in that the code run by each process depends only on its identifier. For instance, in Peterson’s algorithm the codes for the two processes are the same up to the permutation that swaps 1 and 2. Such solutions will not help us to mimic the effect of grab(S) in, say, f (grab(S)), because f can also make its argument run in parallel with itself, a scenario which does not arise in the framework of cooperating sequential processes.
Furthermore, our results demonstrate that PA is not a conservative extension of IA|| with respect to observational equivalence (and hence also observational ap-
proximation). Here are the simplest instances of that failure, now easily verifiable, thanks to Theorems 3.5 and 4.5.
x : com ▶ x ±IA||  (x||x) : com
x : com ▶ x /±PA (x||x) : com


x : com ▶ (x or (x||x)) ∼=IA|| (x||x) : com
x : com ▶ (x or (x||x)) /∼=PA (x||x) : com

Acknowledgement
I am grateful to Samson Abramsky for discussions on the topic of this paper.

References
Abramsky, S. and G. McCusker, Linearity, sharing and state: a fully abstract game semantics for Idealized Algol with active expressions, in: P. W. O’Hearn and R. D. Tennent, editors, Algol-like languages, Birkhau¨ser, 1997 pp. 297–329.
Brookes, S. D., The essence of Parallel Algol, Information and Computation 179 (2002), pp. 118–149.
Dijkstra, E. W., Cooperating sequential processes, in: F. Genuys, editor, Programming Languages: NATO Advanced Study Institute, Academic Press, 1968 pp. 43–112.
Ghica, D. R. and A. S. Murawski, Angelic semantics of fine-grained concurrency, Annals of Pure and Applied Logic 151(2-3) (2008), pp. 89–114.
Jifeng, H., M. B. Josephs and C. A. R. Hoare, A theory of synchrony and asynchrony, in: Programming Concepts and Methods, Elsevier, 1990 pp. 459–473.
Laird, J., A game semantics of Idealized CSP, in: Proceedings of MFPS’01, Elsevier, 2001 pp. 1–26, ENTCS, Vol. 45.
Lamport, L., A new solution of Dijkstra’s concurrent programming problem, Communications of the ACM 17 (1974), pp. 453–455.
McCusker, G., On the semantics of Idealized Algol without the bad-variable constructor., in: Proceedings of MFPS, Electronic Notes in Theoretical Computer Science 83 (2003).
Murawski, A. S., Bad variables under control, in: Proceedings of CSL, Lecture Notes in Computer Science 4646, Springer, 2007 pp. 558–572.
Peterson, G. L., Myths about the mutual exclusion problem, Information Processing Letters 12 (1981),
pp. 115–116.
Reynolds, J. C., The essence of Algol, in: J. W. de Bakker and J. van Vliet, editors, Algorithmic Languages, North Holland, 1981 pp. 345–372.
R¨ockl, C. and D. Sangiorgi, A pi-calculus process semantics of Concurrent Idealised Algol, in:
Proceedings of FoSSaCS, Lecture Notes in Computer Science 1578 (1999), pp. 306–321.
Udding, J. T., A formal model for defining and classifying delay-insensitive circuits and systems, Distributed Computing 1(4) (1986), pp. 197–204.
