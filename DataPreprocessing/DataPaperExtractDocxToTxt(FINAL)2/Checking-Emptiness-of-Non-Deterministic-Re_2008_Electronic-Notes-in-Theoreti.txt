	Electronic Notes in Theoretical Computer Science 212 (2008) 191–206	
www.elsevier.com/locate/entcs

Checking Emptiness of Non-Deterministic Regular Types with Set Operators
Lunjin Lu
Oakland University

Abstract
An algorithm to decide the emptiness of a regular type expression with set operators given a set of param- eterized type definitions is presented. The algorithm generalizes previous work in that tuple distributivity is not assumed and set operators are permitted in type expressions.
Keywords: Regular types, Emptiness, Subtyping, Tabulation

1	Introduction
Types play an important role in programming languages. They make programs easier to understand and help detect errors. A type checker [23,28] requires the programmer to declare types for components of a program and verifies at compile- time that the execution of the program is prosecuted without violating the declared types. A type inference system [12,15,6,18,17,20] infers types for program com- ponents from its usage in the program. In between a type reconstruction system would allow the programmer to declares types for some program components and infer types for others [21]. One of important issues in a type system is to decide if one type is a subtype of another. There are two approaches to solving the subtyping problem. The syntactic approach consists in defining the subtyping relation by ax- iomatizing it by a set of inductive or co-inductive rules [5]. The semantic approach interprets types as subsets of the domain of computation and defines the subtyping relation as the inclusion of denoted sets [11].
A type is a finite expression that denotes a possibly infinite set of ground terms. An integral part of any type system is its type language that specifies which sets of ground terms are types. Regular term languages [7], called regular types, have been used widely used as types [25,22,8,24,12,28,15,13,6,18,17,20]. Most type systems use tuple distributive types [22] which are strictly less powerful than regular types. Tuple distributive types are regular types closed under tuple distributive closure.

1571-0661 © 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.04.062

192	L. Lu / Electronic Notes in Theoretical Computer Science 212 (2008) 191–206
Intuitively, the tuple distributive closure of a set of terms is the set of all terms constructed recursively by permuting each argument position among all terms that have the same function symbol [28]. Tuple distributive types are not closed under set union and complement.
This paper gives an algorithm to decide if a type expression denotes the empty set of terms. The subtyping problem can be reduced to the emptiness problem in our setting since our language of types is closed under set union, set intersection and set complement. The correctness of the algorithm is proved and its complexity is analyzed. The algorithm works on regular types with parametric type defini- tions [24]. We allow parametric and overloading polymorphism in type definitions. These types are useful both in compilers and other program manipulation tools such as debuggers because they are easy to understand for programmers. Type ex- pressions may contain set operators with their usual interpretations. Set operators allow concise and intuitive representation of regular types.
Though using regular term languages as types allow us to make use of theoret- ical results in the field of tree automata [12], algorithms for testing the emptiness of tree automata cannot be applied directly as type definitions may be parameter- ized. For instance, in order to decide the emptiness of a type expression given a set of type definitions, it would be necessary to construct a tree automaton from the type expression and the set of type definitions before an algorithm for determining the emptiness of an tree automaton can be used. When type definitions are pa- rameterized, this would make it necessary to construct a different automaton each time the emptiness of a type expression is tested. Thus, an algorithm that works directly with type definitions is desirable as it avoids this repeated construction of automata. This is the main contribution of this paper.
Attempts have been made in the past to find algorithms for regular types [22,12,28,27,9,8]. Dart and Zobel’s work [9] is the only one to present decision algorithms for emptiness and inclusion problems for regular types without the tuple distributive restriction. Unfortunately, their algorithm for the inclusion problem is incorrect for regular types in general. See [19] for a counterexample. Moreover, the type language of Dart and Zobel is less expressive than that presented in this paper since it doesn’t allow set operators and parameterized type definitions.
Set constraint solving has also been used in type checking and type infer- ence [3,2,16,10]. However, algorithms proposed for set constraint solving [3,4,2,1] are not applicable to the emptiness problem we considered in this paper as they don’t take type definitions into account.
The remainder of this paper is organized as follows. Section 2 describes our language of type expressions and type definitions. Section 3 presents our algorithm for testing if a type expression denotes an empty set of terms. Section 4 addresses the correctness of the algorithm. Section 5 presents the complexity of the algorithm and section 6 concludes the paper. Proofs in an appendix can be omitted in the final version of the paper.

Let Σ be a fixed ranked alphabet. Each symbol in Σ is called a function symbol and has a fixed arity. The arity of a symbol f is denoted as arity(f ). Assume that Σ contains at least one constant that is a function symbol of arity 0. Let 7 (Φ) be the set of all terms over Φ. 7 (Σ) is the set of all possible values that a program variable can take. We shall use regular term languages over Σ as types.
A type is represented by a ground term constructed from another ranked al- phabet Π and {H, H, ~, 1, 0}, called type constructors. It is assumed that (Π ∪
{H, H, ~, 1, 0}) ∩ Σ= ∅. Thus, a type expression is a term in 7 (Π ∪ {H, H, ~, 1, 0}).
Types are defined by type rules. A type rule is a production rule of the form c(ζ1, ··· , ζm) → τ where c ∈ Π, ζ1, ··· , ζm are different type parameters and τ ∈ 7 (Σ ∪ Π ∪ Ξm) where Ξm = {ζ1, ··· , ζm}. The condition that every type parameter in the righthand side of a type rule occurs in its lefthand side is often referred to as type preserving [26] and is shared by other formalisms for defining types such as tree automata [7], regular term grammars [9] and regular unary logic programs [28].
Note that overloading of function symbols is permitted as a function symbol can appear in the righthand sides of many type rules. We denote by Δ the set of all type
def 
rules and define Ξ =	c∈Π Ξarity(c). ⟨Π, Σ, Δ⟩ is a restricted form of context-free
term grammar.
Example 2.1 Let Σ = {0, s(), nil, cons(, )} and Π = {Nat, Even, List()}. The following set of type rules defines natural numbers, even numbers and lists.
Δ= ⎧⎨ Nat → 0 | s(Nat),  Even → 0 | s(s(Even)), ⎫⎬
⎩ List(ζ) → nil | cons(ζ, List(ζ))	⎭
where, for instance, Nat → 0 | s(Nat) is an abbreviation of two rules Nat → 0 and
Nat → s(Nat).
We assume that Δ is simplified in that τ in each type rule c(ζ1, ··· , ζm) → τ is of the form f (τ1, ··· , τn) such that each τj, for 1 ≤ j ≤ n, is either in Ξm or of the form
d(ζ' , ··· ,ζ' ) and ζ' , ··· ,ζ' ∈ Ξm. There is no loss of generality to use a simplified
1	k	1	k
set of type rules since every set of type rules can be simplified by introducing new
type constructors and rewriting and adding type rules in the spirit of [9].
Example 2.2 The following is the simplified version of the set of type rules in
example 2.1. Σ = {0, s(), nil, cons(, )}, Π = {Nat, Even, Odd, List()} and
Δ= ⎧⎨ Nat → 0 | s(Nat), Even → 0 | s(Odd),	⎫⎬
⎩ Odd → s(Even),	List(ζ) → nil | cons(ζ, List(ζ)) ⎭
A type valuation φ is a mapping from Ξ to 7 (Π ∪ {H, H, ~, 1, 0}). The in- stance φ(R) of a production rule R under φ results from substituting φ(ζ) for each occurrence of type parameter ζ in R. For instance, List(NatH(~Even)) → cons(N atH(~Even), List(NatH(~Even)))   is   the   instance   of List(ζ) → cons(ζ, List(ζ)) under φ = {ζ '→ NatH(~Even)}. Let

ground(Δ) d=ef {φ(R) | R ∈ Δ Λ φ ∈ (Ξ '→ 7 (Π ∪ {H, H, ~, 1, 0}))}
∪ {1 '→ f (1, ··· , 1) | f ∈ Σ}
ground(Δ) is the set of all ground instances of grammar rules in Δ plus rules of the form 1 → f (1, ··· , 1) for every f ∈ Σ.
Given a set Δ of type definitions, the type denoted by a type expression is
determined by the following meaning function.
[1]	d=ef 7 (Σ),	[0]	d=ef ∅,	[~E]	d=ef 7 (Σ) — [E] ,

[E1HE2]Δ
d=ef [E1]
∩ [E2]Δ
,	[E1HE2]Δ
d=ef [E1]
∪ [E2]Δ,

[ω]Δ
d=ef 

(ω→f (E1,···,En))∈ground(Δ)
{f (t1, ··· , tn) | 61 ≤ i ≤ n. ti ∈ [Ei]Δ}

where ω is a type whose main constructor is in Π.	Type constructors H, H and
~ are interpreted by [·]Δ as set intersection, set union and set complement with respect to 7 (Σ). Type 1 denotes 7 (Σ) and type 0 the empty set.
Example 2.3 Let Δ be that in example 2.2. We have
[Nat]Δ = {0, s(0), s(s(0)), ·· ·}
[Even]Δ = {0, s(s(0)), s(s(s(s(0)))), ·· ·}
[NatH~Even]Δ = {s(0), s(s(s(0))), s(s(s(s(s(0))))), ·· ·}
[List(NatH~Even)]Δ = {cons(s(0), nil), cons(s(s(s(0))), nil), ·· ·}
Lemma 2.4 [ł]Δ is a regular term language for any type expression ł.


We extend [·]
to sequences θ of type expressions: [ϵ]	def {ϵ} and [⟨E⟩• θ']	def

Δ	Δ =	Δ =
[E]Δ × [θ']Δ where ϵ is the empty sequence, • is the infix sequence concatenation operator, ⟨E⟩ is the sequence consisting of the type expression E and × is the Cartesian product operator. As a sequence of type expressions, ϵ can be thought of consisting of zero instance of 1. We use Λ to denote the sequence consisting of zero instance of 0 and define [Λ]]Δ = ∅.
We shall call a sequence of type expressions simply a sequence. A sequence expression is an expression consisting of sequences of the same length and H, H and
~. The length of the sequences in a sequence expression θ is called the dimension
of θ and is denoted by  θ  . Let θ, θ1 and θ2 be sequence expressions of the same
length and
[θ1Hθ2]	d=ef [θ1] ∩ [θ2]	[θ1Hθ2]	d=ef [θ1] ∪ [θ2]
def
[~θ]Δ = 7 (Σ) × ··· × 7 (Σ) —[θ]
`	θ  ˛t¸imes	x
A conjunctive sequence expression is a sequence expression of the form γ1 Λ ··· Λ γm
where each γi, for 1 ≤ i ≤ m, is a sequence.

Emptiness Algorithm
This section presents an algorithm that decides if a type expression denotes the empty set with respect to a given set of type definitions. The algorithm can also be used to decide if (the denotation of) one type expression is included in (the denotation of) another because E1 is included in E2 iff E1H~E2 is empty.
We first introduce some terminology and notations. A type atom is a type
expression of which the principal type constructor is not a set operator. A type literal is either a type atom or the complement of a type atom. A conjunctive type expression C is of the form Hi∈ILi with Li being a type literal. Let α be a type atom. F(α) defined below is the set of the principal function symbols of the terms in [α]Δ.
F(α) d=ef {f ∈ Σ | ∃ζ1 ··· ζk.((α → f (ζ1, ··· , ζk)) ∈ ground(Δ))}
Let f ∈ Σ. Define
α = {⟨α1, ··· , αk⟩ | (α → f (α1, ··· , αk)) ∈ ground(Δ)}

We have [Af ]	= {⟨t , ··· ,t ⟩ | f (t , ··· ,t ) ∈ [α] }. Both F(α) and Af
are finite

α Δ	1	k	1	k	Δ	α
even though ground(Δ)) is usually not finite.
The algorithm repeatedly reduces the emptiness problem of a type expression to the emptiness problems of sequence expressions and then reduces the emptiness problem of a sequence expression to the emptiness problems of type expressions. Tabulation is used to break down any possible loop and to ensure termination. Let O be a type expression or a sequence expression. Define empty(O) d=ef ([O] = ∅).
Two Reduction Rules
We shall first sketch the two reduction rules and then add tabulation to form an algorithm. Initially the algorithm is to decide the validity of a formula of the form

(1)
where E is a type expression.
empty(E)


Reduction Rule One.
The first reduction rule rewrites a formula of the form (1) into a conjunction of formulae of the following form.
empty(σ)
where σ is a sequence expression where ~ is applied to type expressions but not to any sequence expression.
It is obvious that a type expression has a unique (modulo equivalence of deno- tation) disjunctive normal form. Let DNF(E) be the disjunctive normal form of
E. Then empty(E) can written into ΛC∈DNF(E)empty(C). Each C is a conjunc- tive type expression. We assume that C contains at least one positive type literal. This doesn’t cause any loss of generality as [1HC]Δ = [C]Δ for any conjunctive type

expression C. We also assume that C doesn’t contain repeated occurrences of the same type literal.
Let C = H1≤i≤mωi H H1≤j≤n~τj where ωi and τj are type atoms. The set of positive type literals in C is pos(C) d=ef {ωi | 1 ≤ i ≤ m}, the set of complemented

type atoms is neg(C) d=ef
{τj | 1 ≤ j ≤ n}. Let lit(C) denote the set of literals

occurring in C. The following equivalence holds.
Lemma 3.1 empty(C) is equivalent to
6f ∈ (∩α∈pos(C)J(α)). empty((Hω∈pos(C)(HAf ))H(Hτ∈neg(C)~(HAf )))
ω	τ
The intuition behind the equivalence is as follows. [C]Δ is empty iff, for ev- ery function symbol f , the set of the sequences ⟨t1, ··· , tk⟩ of terms such that f (t1, ··· , tk) ∈ [C]Δ is empty. Only the function symbols in ∩α∈pos(C)J(α) need to be considered.
We note the following two special cases of the formula (3).
If ∩α∈pos(C)J(α) = ∅ then the formula (3) is true because Λ∅ = true. In par- ticular, J(0) = ∅. Thus, if 0 ∈ pos(C) then ∩α∈pos(C)J(α) = ∅ and hence the formula (3) is true.
If Af = ∅ for some τ ∈ neg(C) then HAf = ⟨0, ··· , 0⟩ and ~(HAf )= ⟨1, ··· , 1⟩.
τ	τ	τ
Thus, τ has no effect on the subformula for f when Af = ∅.
In order to get rid of complement operators over sequence sub-expressions, the complement operator in ~(HAf ) is pushed inwards by the function push defined
in the following.
push(~(Hi∈Iγi)) d=ef Hi∈Ipush(~γi)
push(~⟨E1, E2, ··· , Ek⟩) d=ef H1≤l≤k⟨ 1, ··· , 1, ~El, 1, ··· , 1 ⟩	for k ≥ 1


push(~ϵ) d=ef Λ 
`  ˛¸  x



`  ˛¸  x




It follows from De Morgan’s law and the definition of [·]
that [push(~(HAf ))]	=

Δ	τ	Δ
[~(HAf )] . Substituting push(~(HAf )) for ~(HAf ) in the formula (3) gives rise to
τ  Δ	τ	τ
a formula of the form (2).
Reduction Rule Two.
The second reduction rule rewrites a formula of the form (2) to a conjunction of disjunctions of formulae of the form (1). Formula (2) is written into a disjunction of formulae of the form.
empty(Γ)
where Γ be a conjunctive sequence expression. Let Γ = γ1H ··· Hγk, Γ↓j d=ef H1≤i≤kγj
with γj being the jth component of γi.
In the case  Γ  = 0, empty(Γ) can be decided without further reduction. If Λ ∈ Γ then empty(Γ) is true because [Λ]]Δ = ∅. Otherwise, empty(Γ) is false because [[Γ]]Δ = {ϵ}.

In the case Γ  /= 0,
Lemma 3.2 empty(Γ) is equivalent to V1≤j≤Γ  empty(Γ↓j).
Note that Γ↓j is a type expression and empty(Γ↓j) is of the form (1).
Algorithm
The two reduction rules in the previous section form the core of the algorithm. However, they alone cannot be used as an algorithm because a formula empty(E) may reduce to a formula containing empty(E) as a sub-formula, leading to nonter- mination. Suppose Σ = {f (), a},Π = {N ull} and Δ = {N ull → f (N ull)}. Clearly,
empty(N ull) is true. However, by the first reduction rule, empty(N ull) reduces to
empty(⟨N ull⟩) which then reduces to empty(N ull) by the second reduction rule. This process will not terminate.
The solution, inspired by [9], is to remember in a table a particular kind of formulae of which truth is being tested. When a formula of that kind is tested, the table is first looked up. If the formula is implied by any formula in the table, then it is determined as true. Otherwise, the formula is added into the table and then reduced by a reduction rule.
The emptiness algorithm presented below remembers every conjunctive type expression of which emptiness is being tested. Thus the table is a set of con- junctive type expressions. Let C1 and C2 be conjunctive type expressions. We

define (C1 ≤ C2) d=ef
(lit(C1) ≥ lit(C2)). Since Ci = HL∈lit(Ci)L, C1 ≤ C2 im-

plies [C1]Δ ⊆ [C2]Δ and hence (C1 ≤ C2) Λ empty(C2) implies empty(C1). Let

f = (H
ω∈pos(C)
(HAf ))H(H
τ ∈neg(C)
push(~(HAf ))). Adding tabulation to the two

reduction rules, we obtain the following algorithm for checking emptiness of types.



etype(E) d=ef etype(E, ∅)
etype(E, Ψ) d=ef ∀C ∈ DNF(E).etype conj(C, Ψ)
8>< true,	if pos(C) ∩ neg(C) /= ∅,




etype conj(C, Ψ) d=ef

def
true,	if ∃C' ∈ Ψ.C ≤ C',
>: ∀f ∈ ∩α∈pos(C)F(α).eseq(Bf , Ψ ∪ {C}),	otherwise.

eseq(Θ, Ψ) = ∀Γ ∈ DNF(Θ).eseq conj(Γ, Ψ)
8>< true	if Γ =0 ∧ Λ ∈ Γ,


eseq conj(Γ, Ψ) d=ef
false	if Γ =0 ∧ Λ /∈ Γ,
>: ∃1 ≤ j ≤ Γ  .etype(Γ↓j, Ψ)	if Γ  /= 0.

Equation 4 initialises the table to the empty set. Equations 5 and 6 implement the first reduction rule while equations 7 and 8 implement the second reduction rule. etype(, ) and etype conj(, ) test the emptiness of an arbitrary type expression and that of a conjunctive type expression respectively. eseq(, ) tests emptiness of a se- quence expression consisting of sequences and H and H operators while eseq conj(, )
tests the emptiness of a conjunctive sequence expression. The expression of which
emptiness is to be tested is passed as the first argument to these functions. The table is passed as the second argument. It is used in etype conj(, ) to detect a con- junctive type expression of which emptiness is implied by the emptiness of a tabled

etype(A)
3
etype(A, ∅)
4
etype conj(A, ∅)
Legend:
A = NatH~EvenH~Odd
B = NatH~OddH~Even
C = ⟨Nat⟩H⟨~Odd⟩H⟨~Even⟩

5	Λ
eseq(ϵHΛ, {A})
6
eseq conj(ϵHΛ, {A})
7
true
5
eseq(C, {A})
6
eseq conj(C, {A})
7
etype(B, {A})
4
etype conj(B, {A})
5
true

Fig. 1. Evaluation of etype(NatH~EvenH~Odd))

conjunctive type expression. As we shall show later, this ensures the termination of the algorithm. Each of the four binary functions returns true iff the emptiness of the first argument is implied by the second argument and the set of type definitions. Tabling any other kind of expressions such as arbitrary type expressions can also ensure termination. However, tabling conjunctive type expressions makes it easier to detect the implication of the emptiness of one expression by that of another because lit(C) can be easily computed given a conjunctive type expression C which
can be represented as lit(C) in the table.
The first two definitions for etype conj(C, Ψ) in equation 6 terminates the al- gorithm when the emptiness of C can be decided by C and Ψ without using type definitions. The first definition also excludes from the table any conjunctive type expression that contains both a type atom and its complement.

Examples
We now illustrate the algorithm with some examples.
Example 3.3 Let type definitions be given as in example 2.2. The tree in figure 1 depicts the evaluation of etype(N atH~EvenH~Odd) by the algorithm. Nodes are labeled with function calls. We will identity a node with its label. Arcs from a node to its children are labeled with the number of the equation that is used to
evaluate the node. Abbreviations used in the labels are defined in the legend to the right of the tree. Though [A]Δ = [B]Δ, A and B are syntactically different type expressions. The evaluation returns true, verifying [NatH~EvenH~Odd]Δ =
∅. Consider etype conj(B, {A}).  We have B ≤ A as lit(A) = lit(B). Thus, by
equation 6, etype conj(B, {A})= true.
Example 3.4 Let type definitions be given as in example 2.2. The tree in figure 2 depicts the evaluation of etype(List(EvenH~N at)) by the algorithm. It returns false, verifying [List(EvenH~Nat)]Δ /= ∅. Indeed, [List(EvenH~Nat)]Δ = {nil}.

etype(A)
(3)
etype(A, ∅)
(4)
etype conj(A, ∅)
Legend:
A = List(EvenH~Nat)
B = EvenH~Nat

(5)/nil
Λ   (5)/cons(,)

eseq(ϵ, {A})
(6)
eseq conj(ϵ, {A})
(7)
false
eseq(⟨B, A⟩, {A})



Fig. 2. Evaluation of etype(List(EvenH~Nat))


The rightmost node is not evaluated as its sibling returns false, which is enough to establish the falsity of their parent node.
Example 3.5 The following is a simplified version of the type definitions that is used in [19] to show the incorrectness of the algorithm by Dart and Zobel for testing inclusion of one regular type in another [9].
Let Π = {α, β, θ, σ, ω, ζ, η}, Σ = {a, b, g(), h(, )} and
⎧⎨ α → g(ω), β → g(θ) | g(σ), θ → a | h(θ, ζ), σ → b | h(σ, η), ⎫⎬
⎩ ω → a | b | h(ω, ζ) | h(ω, η), ζ → a,	η → b	⎭
Let t = g(h(h(a, b), a)). t ∈ [α]Δ and t /∈ [β]Δ, see example 3 in [19] for more details. So, [α]Δ /⊆ [β]Δ. This is verified by our algorithm as follows. Let Ψ1 =
{αH~β} and Ψ2 = Ψ1 ∪ {ωH~θH~σ}. By applying equations 4, 5, 6, 7, 8 and 5 in that order, we have etype(αH~β)= etype conj(ωH~θH~σ, Ψ1). By equation 6, we have etype(αH~β)= eseq(ϵHΛHϵ, Ψ2) Λ eseq(ϵHϵHΛ, Ψ2) Λ eseq(Θ, Ψ2) where Θ = (⟨ω, ζ⟩H⟨ω, η⟩)H(⟨~θ, 1⟩H⟨1, ~ζ⟩)H(⟨~σ, 1⟩H⟨1, ~η⟩). We choose not to simplify ex- pressions such as ϵHϵH~Λ so as to make the example easy to follow. By applying equations 7 and 8, we have both eseq(ϵHΛHϵ, Ψ2) = true and eseq(ϵHϵHΛ, Ψ2) = true. So, etype(αH~β) = eseq(Θ, Ψ2). Let Γ = ⟨ω, ζ⟩H⟨~θ, 1⟩H⟨1, ~η⟩. To show etype(αH~β) = false, it suffices to show eseq conj(Γ, Ψ2) = false by equation 7 because Γ ∈ DNF(Θ) and etype(αH~β)= eseq(Θ, Ψ2).
Figure 3 depicts the evaluation of eseq conj(Γ, Ψ2). The node that is linked to
its parent by a dashed line is not evaluated because one of its siblings returns false, which is sufficient to establish the falsity of its parent. It is clear from the figure that etype conj(Θ, Ψ2) = false and hence etype(αH~β)= false.

Correctness
This section addresses the correctness of the algorithm. We shall first show that tabulation ensures the termination of the algorithm because the table can only be of finite size. We then establish the partial correctness of the algorithm.


7
etyp(ωH~θ, Ψ2)
4
etype conj(Γ, Ψ2)
V

etype(ζH~η, Ψ2)
4

etyp conj(ωH~θ, Ψ2)	etype conj(ζH~η, Ψ2)

5/a
Λ	5/b
5/h(,)	5

eseq(ϵHΛ, Ψ3)
6
eseq conj(ϵHΛ, Ψ3)
7
true Legend:
eseq(ϵHϵ, Ψ3)
6
eseq conj(ϵHϵ, Ψ3)
7
false
eseq(Θ1, Ψ3)
eseq(ϵHϵ, Ψ4)
6
eseq conj(ϵHϵ, Ψ4)
7
false

Θ1 = (⟨ω, ζ⟩H⟨ω, η⟩)H(⟨~θ, 1⟩H⟨1, ~ζ⟩) Ψ3 = Ψ2 ∪ {ωH~θ}
Ψ4 = Ψ2 ∪ {ζH~η}
Γ= ⟨ω, ζ⟩H⟨~θ, 1⟩H⟨1, ~η⟩
Fig. 3. Evaluation of etype conj(Γ, Ψ2)


Termination
Given a type expression E, a top-level type atom in E is a type atom in E that is not a sub-term of any type atom in E. The set of top-level type atoms in E is denoted by TLA(E).  For instance, letting E = ~List(Nat)HTree(NatH~Even),
TLA(E) = {List(Nat),Tree(NatH~Even)}.  We extend TLA(·) to sequences by

TLA(⟨E1, E2, ··· , Ek⟩
def 
TLA(Ei).

Given a type expression E0, the evaluation tree for etype(E0) contains nodes
of the form etype(E, Ψ), etype conj(C, Ψ), eseq(Θ, Ψ) and eseq conj(Γ, Ψ) in ad- dition to the root that is etype(E0). Only nodes of the form etype conj(C, Ψ) add conjunctive type expressions to the table. Other forms of nodes only pass the table around. Therefore, it suffices to show that the type atoms occurring in the first argument of the nodes are from a finite set because any conjunctive type expression added into the table is the first argument of a node of the form etype conj(C, Ψ).
The set RTA(E0) of type atoms relevant to a type expression E0 is the smallest set of type atoms satisfying
TLA(E0) ⊆ RTA(E0), and
if τ is in RTA(E0) and τ → f (τ1, τ2, ··· , τk) is in ground(Δ) then TLA(τi) ⊆
RTA(E0) for 1 ≤ i ≤ k.
The height of τi is no more than that of τ for any τ → f (τ1, τ2, ··· , τk) in ground(Δ). Thus, the height of any type atom in RTA(E0) is finite. There are only a finite number of type constructors in Π. Thus, RTA(E0) is of finite size. It follows by examining the algorithm that type atoms in the first argument of the nodes in
the evaluation tree for etype(E0) are from RTA(E0) which is finite. Therefore, the algorithm terminates.

Partial Correctness
The partial correctness of the algorithm is established by showing etype(E0) = true iff empty(E0). Let Ψ be a set of conjunctive type expressions. Define ρΨ d=ef
ΛC∈Ψempty(C). The following two lemmas form the core of our proof of the partial correctness of the algorithm.
Lemma 4.1 Let Ψ be a set of conjunctive type expressions, E a type expression, C a conjunctive type expression, Θ a sequence expression and Γ a conjunctive sequence expression.
If ρΨ |= empty(C) then etype conj(C, Ψ) = true, and
If ρΨ |= empty(E) then etype(E, Ψ) = true, and
If ρΨ |= empty(Γ) then etype(Γ, Ψ) = true, and
If ρΨ |= empty(Θ) then etype(Θ, Ψ) = true.
Proof. The proof is done by induction on the size of the complement of Ψ with respect to the set of all possible conjunctive type expressions in which type atoms are from RTA(E0) where E0 is a type expression.
Basis. The complement is empty. Ψ contains all possible conjunctive type expressions in which type atoms are from RTA(E0). We have C ∈ Ψ and hence etype conj(C, Ψ) = true by equation 6. Therefore, (a) holds. (b) follows from (a) and equation 5. (c) follows from (b), equation 8 and lemma 3.2, and (d) follows
from (c) and equation 7.
Induction.  By lemma 3.1 in the appendix, ρΨ |= empty(C) implies ρΨ |=
empty(Уf ) for any f ∈ ∩α∈pos(C)J(α). Thus, ρΨ∪{C} |= empty(Уf ). The comple-
C	C
ment of Ψ∪ {C} is smaller than the complement of Ψ. By the induction hypothesis, we have eseq(Уf , Ψ ∪ {C})= true. By equation 6, etype conj(C, Ψ) = true. There- fore, (a) holds. (b) follows from (a) and equation 5. (c) follows from (b), equation 8
and lemma 3.2 and (d) follows from (c) and equation 7.	 
Lemma 4.1 establishes the completeness of etype(, ), etype conj(, ), eseq(, ) and
eseq conj(, ) while the following lemma establishes their soundness.
Lemma 4.2 Let Ψ be a set of conjunctive type expressions, E a type expression, C a conjunctive type expression, Θ a sequence expression and Γ a conjunctive sequence expression.
ρΨ |= empty(C) if etype conj(C, Ψ) = true, and
ρΨ |= empty(E) if etype(E, Ψ) = true, and
ρΨ |= empty(Γ) if etype(Γ, Ψ) = true, and
ρΨ |= empty(Θ) if etype(Θ, Ψ) = true.
Proof. It suffices to prove (a) since (b),(c) and (d) follow from (a) as in lemma 4.1. The proof is done by induction on dp(C, Ψ) the depth of the evaluation tree for etype conj(C, Ψ).

Basis. dp(C, Ψ) = 1. etype conj(C, Ψ) = true implies either (i) pos(C) ∩ neg(C) /= ∅ or (ii) ∃C' ∈ Ψ.C ≤ C'. In case (i), empty(C) is true and ρΨ |= empty(C). Consider case (ii). By the definition of ≤ and ρΨ, we have that etype conj(C, Ψ) = true implies ρΨ |= empty(C).
Induction. dp(C, Ψ) > 1. Assume etype conj(C, Ψ) = true and ρΨ |= ¬empty(C). By lemma 3.1, there is f ∈ ∩α∈pos(C)J(α) such that ρΨ |= ¬empty(Уf ). We have
ρΨ∪{C} |= ¬empty(Уf ). dp(Уf , Ψ ∪ {C}) < dp(C, Ψ). By the induction hypoth-
C	C
esis, we have eseq(Уf , Ψ ∪ {C}) = false for otherwise, ρΨ∪{C} |= Уf . By equa-
C	C
tion 6, etype conj(C, Ψ) = false which contradicts etype conj(C, Ψ) = true. So,
ρΨ |= empty(C) if etype conj(C, Ψ) = true. This completes the induction and the proof of the lemma.	 
The following theorem is a corollary of lemmas 4.1 and 4.2.
Theorem 4.3 For any type expression E, etype(E)= true iff empty(E).
Proof. By equation 4, etype(E)= etype(E, ∅). By lemma 4.1.(b) and lemma 4.2.(b), we have etype(E, ∅)= true iff ρ∅ |= empty(E). The result follows since ρ∅ = true. 

Complexity
We now address the issue of complexity of the algorithm. We only consider the worst-case time complexity of the algorithm. The time spent on evaluating etype(E0) for a given type expression E0 can be measured in terms of the number of nodes in the evaluation tree for etype(E0).
The algorithm cycles through etype(, ), etype conj(, ), eseq(, ) and eseq conj(, ). Thus, children of a node of the form etype(E, Ψ) can only be of the form etype conj(C, Ψ), and so on.
Let |S| be the number of elements in a given set S. The largest possible table in the evaluation of etype(E0) contains all the conjunctive type expressions of which type atoms are from RTA(E0). Therefore, the table can contain at most 2|RTA(E0 )| conjunctive type expressions. So, the height of the tree is bounded by O(2|RTA(E0 )|).
We now show that the branching factor of the tree is also bounded by O(2|RTA(E0 )|). By equation 5, the number of children of etype(E, Ψ) is bounded by two to the
power of the number of type atoms in E which is bounded by |RTA(E0)| because E can only contain type atoms from RTA(E0). By equation 6, the number of children of etype conj(C, Ψ) is bounded by |Σ|. The largest number of children of a node eseq(Θ, Ψ) is bounded by two to the power of the number of sequences
in Θ where Θ = Уf . For each τ ∈ neg(C), |push(~(HAf ))| is O(arity(f )) and
C	τ
|C| < |RTA(E0)|. Thus, the number of sequences in Θ is O(arity(f ) ∗ |RTA(E0)|) and hence the number of children of eseq(Θ, Ψ) is O(2|RTA(E0)|) since arity(f ) is a constant. By equation 8, the number of children of eseq conj(Γ, Ψ) is bounded
by maxf∈Σ arity(f ).  Therefore, the branching factor of the tree is bounded by
O(2|RTA(E0)|). The above discussion leads to the following conclusion.
Proposition 5.1 The time complexity of the algorithm is O(2|RTA(E0 )|).

The fact that the algorithm is exponential in time is expected because the com- plexity coincides with the complexity of deciding the emptiness of any tree automa- ton constructed from the type expression and the type definitions. A deterministic frontier-to-root tree automaton recognising [E0]Δ will consist of 2|RTA(E0 )| states as observed in the proof of lemma 2.4. It is well-known that the decision of the emptiness of the language of a deterministic frontier-to-root tree automaton takes time polynomial in the number of the states of the tree automaton. Therefore, the
worst-case complexity of the algorithm is the best we can expect from an algorithm for deciding the emptiness of regular types that contain set operators.

Conclusion
We have presented an algorithm for deciding the emptiness of non-deterministic regular types with set operators. Type expressions are constructed from type con- structors and set operators. Type definitions define the meaning of type expressions. The algorithm uses tabulation to ensure termination. Though the tabulation is inspired by Dart and Zobel [9], the decision problem we consider in this paper is more complex as type expressions may contain set operators. For that reason, the algorithm can also be used for inclusion and equivalence problems of regular types. The way we use tabulation leads to a correct algorithm for regular types while the
Dart-Zobel algorithm has been proved incorrect for regular types [19] in general. In addition to correctness, our algorithm generalises the work of Dart and Zo-
bel [9] in that type expressions can contain set operators and type definitions can be parameterised. Parameterised type definitions are more natural than monomor- phic type definitions [12,23,28] while set operators makes type expressions con- cise. The combination of these two features allows more natural type declarations. For instance, the type of the logic program append can be declared or inferred as append(List(α), List(β), List(αHβ)).
The algorithm is exponential in time. This coincides with deciding the emptiness
of the language recognised by a tree automaton constructed from the type expression and the type definitions. However, the algorithm avoids the construction of the tree automaton which cannot be constructed a priori when type definitions are parameterised.
Another related field is set constraint solving [3,2,16,10]. However, set constraint solving methods are intended to infer regular tree languages as approximations to program properties rather than for checking the emptiness of regular types that are defined by a priori type definitions [24]. Therefore, they are useful in different set- tings from the algorithm presented in this paper. In addition, algorithms proposed for solving set constraints [3,4,2,1] are not applicable to the emptiness problem we considered in this paper. Take for example the constructor rule in [3,2] which states
that emptiness of f (E1, E2, ··· , Em) is equivalent to the emptiness of Ei for some 1 ≤ i ≤ m. However, empty(List(0)) is not equivalent to empty(0). The latter is true while the former is false since [List(0)]Δ = {nil}. The constructor rule doesn’t apply because it deals with function symbols only but doesn’t take the type

definitions into account.

References
A. Aiken, D. Kozen, M. Vardi, and E. Wimmers. The complexity of set constraints. In Proceedings of 1993 Computer Science Logic Conference, pages 1–17, 1992
A. Aiken and T.K. Lakshman. Directional type checking of logic programs. In B. Le Charlier, editor,
Proceedings of the First International Static Analysis Symposium, pages 43–60. Springer-Verlag, 1994.
A. Aiken and E. Wimmers. Solving systems of set constraints. In Proceedings of the Seventh IEEE Symposium on Logic in Computer Science, pages 329–340. The IEEE Computer Society Press, 1992.
A. Aiken and E. Wimmers. Type inclusion constraints and type inference. In Proceedings of the 1993 Conference on Functional Programming Languages and Computer Architecture, pages 31–41, 1993.
M. Brandt and F. Henglein. Coinductive axiomatization of recursive type equality and subtyping.
Fundamenta Informaticae, 33(4):309–338, 1998.
M. Codish and V. Lagoon. Type dependencies for logic programs using ACI-unification. Theoretical Computer Science, 238:131–159, 2000.
H. Comon, M. Dauchet, R. Gilleron, C. L¨oding, F. Jacquemard, D. Lugiez, S. Tison, and M. Tommasi. Tree automata techniques and applications. http://www.grappa.univ-lille3.fr/tata , 2007.
P.W. Dart and J. Zobel. Efficient run-time type checking of typed logic programs. The Journal of Logic Programming, 14(1-2):31–69, 1992.
P.W. Dart and J. Zobel. A regular type language for logic programs. In F. Pfenning, editor, Types in Logic Programming, pages 157–189. The MIT Press, 1992.
P. Devienne, J-M. Talbot, and S. Tison. Co-definite set constraints with membership expressions. In
J. Jaffar, editor, Proceedings of the 1998 Joint Conference and Symposium on Logic Programming, pages 25–39. The MIT Press, 1998.
A. Frisch, G. Castagna, and V. Benzaken. Semantic subtyping. In Proceedings of the Seventeenth IEEE Symposium on Logic in Computer Science, pages 137–146. The IEEE Computer Society, 2002.
T. Fru¨hwirth, E. Shapiro, M.Y. Vardi, and E. Yardeni. Logic programs as types for logic programs. In Proceedings of Sixth Annual IEEE Symposium on Logic in Computer Science, pages 300–309. The IEEE Computer Society Press, 1991.
J.P. Gallagher and D.A. de Waal. Fast and precise regular approximations of logic programs. In
M. Bruynooghe, editor, Proceedings of the Eleventh International Conference on Logic Programming, pages 599–613. The MIT Press, 1994.
F. G´ecseg and M. Steinby. Tree languages. In G. Rozenberg and A. Salomma, editors, Handbook of Formal Languages, pages 1–68. Springer-Verlag, 1996.
N. Heintze and J. Jaffar. Semantic types for logic programs. In F. Pfenning, editor, Types in Logic Programming, pages 141–155. The MIT Press, 1992.
N. Heintze and J. Jaffar. Set constraints and set-based analysis. In A. Borning, editor, Principles and Practice of Constraint Programming, pages 281–298. Springer, 1994.
P. M. Hill and F. Spoto. Generalising Def and Pos to type analysis. Journal of Logic and Computation, 12(3):497–542, 2002.
L. Lu. A polymorphic type analysis in logic programs by abstract interpretation. The Journal of Logic Programming, 36(1):1–54, 1998.
L. Lu. On the Dart-Zobel algorithm for testing regular type inclusion. SIGPLAN Notices, 36(9):81–85, 2001.
L. Lu. Improving precision of type analysis using non-discriminative union. Theory and Practice of Logic Programming, 8(1):33–79, 2008.
R. Milner. A theory of type polymorphism in programming. Journal of Computer and System Science, 17:348–375, 1978.
P. Mishra. Towards a theory of types in Prolog. In Proceedings of the IEEE international Symposium on Logic Programming, pages 289–298. The IEEE Computer Society Press, 1984.


A. Mycroft and R.A. O’Keefe. A polymorphic type system for Prolog. Artificial Intelligence, 23(3):295– 307, 1984.
U.S. Reddy. Types for logic programs. In Proceedings of the 1990 North American Conference on Logic Programming, pages 836–40. The MIT Press, 1990.
M. Soloman. Type definitions with parameters. In Conference Record of the Fifth ACM Symposium on Principles of Programming Languages, pages 31–38, 1978.
J. Tiuryn. Type inference problems: A survey. In B. Roven, editor, Proceedings of the Fifteenth International Symposium on Mathematical Foundations of Computer Science, pages 105–120. Springer- Verlag, 1990.
E. Yardeni, T. Fruehwirth, and E. Shapiro. Polymorphically typed logic programs. In K. Furukawa, editor, Proceedings of the Eighth International Conference on Logic Programming, pages 379–93. The MIT Press, 1991.
E. Yardeni and E. Shapiro. A type system for logic programs. The Journal of Logic Programming, 10(2):125–153, 1991.

Appendix
Proof of Lemma 3.1.
Let t be a sequence of terms and f a function symbol. By the definition of [·]Δ,

f (t) ∈ [C]Δ
iff f ∈ ∩α∈pos(C)
J(α) and t ∈ [H
ω∈pos(C)
(HAf ))]
\[(H
τ ∈neg(C)
(HAf ))] .

t ∈ [Hω∈pos(C)(HAf ))]
\ [(Hτ∈neg(C)(HAf ))]
iff

t ∈ [(Hω∈pos(C)(HAf ))H(Hτ ∈neg(C)~(HAf ))]  .


Thus, empty(C) holds iff empty((H
ω

ω∈pos(C)
(HAf ))H(H
τ

τ ∈neg(C)
Δ
~(HAf ))) holds for

each f ∈ ∩α∈pos(C)J(α).	 
Proof of Lemma 3.2.
Let  Γ  = n and Γ = γ1Hγ2H ··· Hγm with γi = ⟨γi,1, γi,2, ··· , γi,n⟩. We have [Γ]] =	[γ ] . We have Γ↓j = γ Hγ H ··· Hγ . E1 ≤ j ≤ n.empty(Γ↓j) iff E1 ≤ j ≤ n. 1≤i≤m [γi,j]Δ = ∅ iff [Γ]]Δ = ∅ iff empty(Γ).	 

Proof of Lemma 2.4.
The proof is done by constructing a regular term grammar for ł [7]. We first consider the case ł ∈ 7 (Π ∪ {1, 0}). Let R = ⟨RTA(ł), Σ, ∅, Υ, ł⟩ with
Υ= {(α → f (α1, ··· , αk)) ∈ ground(Δ) | α ∈ RTA(ł)}
R is a regular term grammar. It now suffices to prove that t ∈ [ł]Δ iff ł ⇒∗ t.

Sufficiency. Assume ł ⇒∗
t. The proof is done by induction on derivation steps

in ł ⇒∗ t.
Basis. ł ⇒R t. t must be a constant and ł → t is in Υ which implies ł → t
is in ground(Δ). By the definition of [·]Δ, t ∈ [ł]Δ.
Induction. Suppose ł ⇒ f (ł1, ··· , łk) ⇒(n−1) t. Then t = f (t1, ··· , tk)

and łi ⇒n
R
i t with ni ≤ (n — 1). By the induction hypothesis, ti ∈ [łi]Δ and

R
hence t ∈ [ł]Δ by the definition of [·]Δ.

Necessity. Assume t ∈ [ł]Δ. The proof is done by the height of t, denoted as
height(t).
height(t) = 0 implies that t is a constant. t ∈ [ł]Δ implies that ł → t is in
ground(Δ) and hence ł → t is in Υ. Therefore, ł ⇒R t.
Let height(t) = n. Then t = f (t1, ··· , tk). t ∈ [ł]Δ implies that (ł → f (ł1, ··· , łk)) ∈ ground(Δ) and ti ∈ [łi]Δ. By the definition of Υ, we have (ł → f (ł1, ··· , łk)) ∈ Υ. By the definition of RTA(·), we have

łi ∈ RTA(ł). By the induction hypothesis, łi ⇒∗
ti. Therefore, ł ⇒R

f (ł1, ··· , łk) ⇒∗
f (t1, ··· , tk)= t.

Now consider the case ł ∈ 7 (Π ∪ {H, H, ~, 1, 0}). We complete the proof by induction on the height of ł.
height(ł)= 0. Then ł doesn’t contain set operator. We have already proved that [ł]Δ is a regular term language.
Now suppose height(ł)= n. If ł doesn’t contain set operator then the lemma has already been proved. If the principal type constructor is one of set operators then the result follows immediately as regular term languages are closed under
union, intersection and complement operators [14,7]. It now suffices to prove the case ł = c(ł1, ··· , łl) with c ∈ Π. Let N = c(X1, ··· , Xl) where each Xj is a different new type constructor of arity 0.
Let Π' =Π ∪ {X1, ··· , Xl}, Σ' =Σ ∪ {x1, ··· , xl} and Δ' =Δ ∪ {Xj → xj|1 ≤ j ≤ l}. [N]Δ' is a regular term language on Σ ∪ {x1, ··· , xl} because N doesn’t contain set operators. By the induction hypothesis, [łj]Δ is a regular term language. By the definition of [·]·, we have
[ł]Δ = [N]Δ' [x1 := [ł1]Δ, ··· , xl := [łl]Δ]
which is a regular term language [14,7]. S[y1 := Sy1 , ··· , ] is the set of terms each of which is obtained from a term in S by replacing each occurrence of yj with a (possibly different) term from Syj . This completes the induction and the proof.
The proof also indicates that a non-deterministic frontier-to-root tree automaton that recognizes [ł]Δ has |RTA(ł)| states and that a deterministic frontier-to-root tree automaton that recognizes [ł]Δ has O(2|RTA(M)|) states.	 
