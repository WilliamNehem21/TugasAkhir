	Electronic Notes in Theoretical Computer Science 175 (2007) 119–134	
www.elsevier.com/locate/entcs

Dynamic Transition Refinement
Michael K¨ohler and Heiko Ro¨lke
University of Hamburg, Department for Informatics

Abstract
Refinement of Petri nets is well suited for the hierarchical design of system models. It is used to represent a model at different levels of abstraction.
Usually, refinement is a static concept. For many scenarios, however, it is desirable to have a more flexible form of refinement. For example in the context of service updates, e.g. version control in distributed systems, a mechanism for dynamic transition refinement is needed.
The requirement of dynamic refinement at runtime is quite strong. Since we would like to redefine the system structure by itself, transition refinement cannot be implemented by a model transformation. Instead, an approach is needed which allows for dynamic net structures that can evolve as an effect of transitions firing. In previous work we introduced nets-within-nets as a formalism for the dynamic refinement of tokens. Here we consider an extension of nets-within-nets that uses special net tokens describing the refinement structure of transitions. Using this formalism it is possible to update refinements, introduce alternative refinements, etc. We present some formal properties of the extended formalism and introduce an example implementation for the tool Renew in the context of workflow modeling.
Keywords: duality, refinement, nets-within-nets, Petri nets

Motivation: Refinement of Transitions
The top-down design of a software product has several advantages. Using a graphical formalism for software design, perhaps the most important advantage is to have an abstract, but nevertheless functional, view of the system. A software designer wants to have a (Petri net) view like that in Figure 1(a). To depict a refined – or refinable – transition just like an unrefined one emphasizes the functionality of the abstract net disregarding the refinement. Hence, the net’s structure describes the abstract behaviour. At the same time there is the risk to lose sight of the refinement. This may be tolerated if the refinement is free from side effects, but some kind of labelling should be considered.
In later stages of the software design process the (re)action transition in Fig- ure 1(a) should be refined, e.g. by substituting it with one or several sub-nets (per- haps following some refinement rules like those of Fehling [4]). A Petri net formalism supporting transition refinement has the advantage over other formalisms that the original abstract net of the early design stages does not have to be redefined, but is continuously used for the later models and for the implementation models. An

1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2007.03.007



(re)action








trigger event(s), pre-condition(s)



(re)action









result(s), post-condition(s)
trigger event(s), pre-condition(s)





implementation of action: behaviour

result(s), post-condition(s)



A refined transition should look like a normal transition
Idea of dynamic refinement

Fig. 1. First approach to refinement
example of such a formalism is the one of (hierarchical) Coloured Petri Nets [8] used in the Design/CPN tool [2].

(re)action
sn:start()	sn:end()


trigger event(s),
sn
start
sn
end

result(s),

pre-condition(s)
sn	sn
start	stop
post-condition(s)


:start()	:end()


implementation of action: behaviour

Fig. 2. Dynamic refinement using reference nets
Unfortunately the proposed transition refinement procedures in [8] only support static refinements that cannot be changed at runtime. In some situations it is desirable to have a dynamic refinement at hand 1 , for example by specifying the refined net as a marking on a place. This is illustrated in Figure 1(b). The side condition in the figure is meant to specify the refinement mode of the transition, it can be considered as a kind of parameter. Two advantages are met by this approach: First, the refinement is introduced without extra constructs but with well-known net elements, and second, the dynamics may also be expressed in terms of a well- known Petri net action, the firing of transitions altering the marking of the side condition (not illustrated in the figure).
In fact, such a Petri net formalism exists, namely reference nets [13,14], a variant of the nets-within-nets idea of Valk [19]. The desired functionality of Figure 1(b) is illustrated in more detail in Figure 2 using proper syntax of reference nets. 2 The white transition-like box (re)action in the figure only highlights a component and is not to be confused with a transition.
The example of Figure 2 incorporates dynamic refinement, several alternative refining nets are possible, and the change of the refinement can take place at runtime, but it has the disadvantage of changing the graphical structure of the original net

1 This holds true for all kinds of dynamic systems that should be adapted like workflow systems or that have the ability to adapt theirselves, like multi-agent systems
2 Note that nets-within-nets actually describe refinements of tokens or states. Because the token refinement is done in terms of an active concept – a net – it has become quite common to use the token refinement as a sort of net structure refinement, and therefore behavior refinement.

– compare Figure 2 to Figure 1(a) – thus making the abstract net view difficult to read. The general idea that has led us to the new net formalism described in this paper was to incorporate the refined net(s) describing the behaviour of a transition (back) into the transition itself, leading to the diagrammatic illustration of Figure 3.

(re)action




trigger event(s), pre-condition(s)
result(s), post-condition(s)



Fig. 3. Dynamic transition refinement
The “only” novelties our new formalism requires, are marked transitions and the
ﬁring of places(sic!). 3
The remaining sections are structured as follows: In Section 2 we introduce our approach of marked transitions for Petri nets. We define super-dual nets and their firing rule. In Section 3 we describe how the concept of super-dual nets can be lifted to object nets and give an abbreviated definition of the new formalism of super-dual object nets. In Section 4 we describe how super-dual object nets can be simulated by object nets. Section 5 explains a first attempt to integrate dynamic transition refinement in Renew. The paper ends with a conclusion. The appendix recalls definitions of multi-sets.
Introduction to Super-Dual Petri Nets
This section starts with a short remainder of Petri nets basics. This is to avoid notational confusions. After that super-dual nets will be introduced.
Basic Deﬁnitions
The definition of Petri nets relies on the notion of multi-sets. A multi-set on the set D is a mapping A : D → N. The set of all mapings from D to N is denoted by ND. Multi-sets are generalisations of sets in the sense that every subset of D corresponds to a multi-set A with A(x) ≤ 1 for all x ∈ D. The empty multi-set 0 is defined as 0(x) = 0 for all x ∈ D. The carrier of a multi-set A is dom(A) := {x ∈ D | A(x) > 0}. The cardinality of a multi-set is |A| := x∈D A(x). A multi-set A is called ﬁnite iff |A| < ∞. The multi-set sum A+B is defined as (A+B)(x) := A(x)+B(x), the difference A − B by (A − B)(x) := max(A(x) − B(x), 0). Equality A = B is defined element-wise: ∀x ∈ D : A(x) = B(x). Multi-sets are partially ordered: A ≤ B ⇐⇒ ∀x ∈ D : A(x) ≤ B(x). The strict order A < B holds iff A ≤ B and A /= B. The notation is overloaded, being used for sets as well as multi-sets. The meaning will be apparent from its use.
In the following we assume all multi-sets to be finite. A finite multi-set A can

be considered as the formal sum A = Σ
x∈D
A(x) · x = Σn
xi. Finite multi-sets

3 Note, that in Figure 3 (re)action is a proper transition with the implementing net as a marking.

are the freely generated commutative monoid. If the set D is finite, then a multi-set
A ∈ ND can be represented equivalently as a vector A ∈ N|D|.
Any mapping f : D → D' can be generalised to a homomorphism f : ND → ND'
on multi-sets: f (Σn	ai)= Σn	f (ai). This includes the special case f (0)= 0.
These definitions are in accordance with the set-theoretic notation f (A)= {f (a) |
a ∈ A}. In this paper we simply use f instead of f .

Petri Nets
A Petri net is a tuple N = (P, T, F ) where P is a set of places, T is a set of transitions, disjoint from P , i.e. P ∩ T = ∅, and F ⊆ (P × T ) ∪ (T × P ) is the flow relation. Some commonly used notations for Petri nets are •y := ( F y) for the preset and y• := (yF ) for the postset of a net element y.
To simplify the definition of duality and conjugation we only consider ordinary Petri nets, i.e. we do not deal with arc weights. The mappings F −,F + are defined by F −(t)(p) := |F ∩ {(p, t)}| and F +(t)(p) := |F ∩ {(t, p)}|.
A marking of a net N is a multi-set of places: m ∈ NP . Places are depicted as circles, transitions as rectangles, and the flow relation as arcs between the nodes. The marking is visualised as m(p) tokens on the place p.
A marked Petri net is a tuple (N, m0) consisting of a Petri net and a start marking. Throughout this paper we speak of Petri nets or simply nets instead of (ordinary) marked Petri nets.
A multi-set of transitions u ∈ NT of a net N is enabled in marking m iff ∀p ∈
P : m(p) ≥ F −(u)(p) holds. The enablement of u in marking m is denoted by
m u	'
−→. A transition multi-set u enabled in m can fire in the successor marking m
where m'(p)= m(p) − F −(u)(p)+ F +(u)(p). Firing is denoted by m u m'.

u
Using multi-set operators m −→
is equivalent to m ≥ F −(u), and the successor

marking is m' = m − F −(u)+ F +(u).

Super-dual Nets
A super-dual net contains a G-flow (short: a glow) G ⊆ (P × T ∪ T × P ) as an additional structure. G connects places and transitions the same way as the flow F , but with a different semantics (see below).
Definition 2.1 A super-dual net is a tuple SD = (P, T, F, G) where
P is a set of places,
T is a set of transitions with P ∩ T = ∅,
F ⊆ (P × T ∪ T × P ) is the flow relation, and
G ⊆ (P × T ∪ T × P ) is the glow relation.
The preset w.r.t. the glow G is □ y := ( G y) and the postset is y□ := (yG ). Analogously to the flow mappings we define the glow mappings G−, G+ : T → (P → N) by G−(t)(p) := |G ∩ {(p, t)}| and G+(t)(p) := |G ∩ {(t, p)}|.

In super-dual nets also the transitions may be marked. A marking of a super- dual net is a multi-set of places and transitions: m ∈ N(P ∪T ). The tokens on transitions are called pokens. A poken is visualised as a little filled square. A marked super-dual net is denoted as (P, T, F, G, m).
For super-dual nets the firing rule considers the firing of transitions as well as the firing of places.
A marking m enables a transition t only if its preset •t is marked and t itself is marked. For a transition multi-set u ∈ NT we define enabling by:

m(p) ≥ F −(u)(p) for all p ∈ P
m(t) ≥ u(t)	for all t ∈ T

This means, that the number of pokens m(t) limits the maximal concurrency of the transition t. Thus m(t) = 0 describes a disabled transition.
Conversely, a marking m enables a place p only if its preset □ p is marked and
p itself is marked. For a place multi-set u ∈ NP we define enablement by:
m(p) ≥ u(p)	for all p ∈ P
m(t) ≥ G−(u)(t) for all t ∈ T



p1	t1	p2









p4


Fig. 4. The super-dual net SD
Example 2.2 Cf. the net in Figure 4. The place p5 is connected by glow arcs (the dashed ones) with transitions t1 and t2. In the depicted marking only the transition t1 is enabled – more exactly: it is enabled twice. Despite the fact, that the preset of transition t2 is marked, it is not enabled, since t2 itself is unmarked. Firing of p5 transfers a poken from t1 to t2, and t2 is then enabled.
Both cases – firing of transitions and of places – can occur in a single step.
Definition 2.3 A multi-set of places and transitions u ∈ N(P ∪T ) of a super-dual net SD is enabled in the marking m ∈ N(P ∪T ), denoted by m u , iff
m(p) ≥ F −(u|T )(p) + u(p) for all p ∈ P and
m(t) ≥ G−(u|P )(t) + u(t) for all t ∈ T.

u
An enabled multi-set u can fire, denoted by m −→
m', resulting in the successor

marking m' defined by

m'(p) = m(p) − F −(u|T )(p) + F +(u|T )(p)
m'(t) = m(t) − G−(u|P )(t) + G+(u|P )(t).

Define pre(u) := F −(u|T )+ G−(u|P ) and post(u) := F +(u|T )+ G+(u|P ).
u
Using multi-set notations m −→ is equivalent to m ≥ pre(u)+ u. The successor
marking is m' = m − pre(u)+ post(u).

Duality
Given a super-dual net SD = (P, T, F, G, m) the dual net (interchanging transitions and places) is defined as SD d := (T, P, F, G, m) and the conjugated net (interchang- ing flow and glow) is SD c := (P, T, G, F, m). Note, that also the dual of a marking can be considered for super-dual nets. We have the commutativity: SD cd = SD dc. For the super-dual net of Figure 4 these constructions are illustrated in Figure 5.

Fig. 5. Duality and Conjugation

The following property justifies the name “super-dual nets”.
Proposition 2.4 Let SD be a super-dual net. SD corresponds to SD cd:

m  u	'	u	'

−−→ m
SD
⇐⇒ m −−−→ m
SD cd


Proof. Simultanously interchanging P and T as well as F and G in Definition 2.3 is the identity transformation.	 

Components
We define the F -component SD |F and the G-component SD |G of a marked super- dual net SD = (P, T, F, G, m) as:
SD |F := (P, T, F, m|P )	(1)
SD |G := (P, T, G, m|T )	(2)
Both constructions are illustrated in Figure 6. Note, that the components SD |F
and the dual of the G-component, SD |d (but not SD |G itself) are Petri nets.


p1	t1




p5



p3	t2
SD |F
p2	p1









p4	p3
SD |G
t1	p2



p5




t2	p4



Fig. 6. The F - and the G-component

The following proposition relates the behaviour of a super-dual net to that of its components.
Proposition 2.5 Let m ∈ N(P ∪T ) be a marking of a super-dual net SD = (P, T, F, G). Let u ∈ N(P ∪T ). Then for the F-component and the dual of the G-component we have (For the proof see [12]):


∀u ∈ NT : m  u

m' ⇐⇒  m

m'|	∧ m|  = m'|

≥ u 

−−→
SD
|P −−−→	P	T	T
SD |F

∀u ∈ NP : m  u
m' ⇐⇒  m	m'|	∧ m|  = m'|
≥ u 

−−→
SD
|T −−−→	T	P	P
SD |d


From Object Nets to Super-Dual Object Nets
We are interested in a dynamic refinement of transitions, i.e. a refinement that can be changed at runtime. This change should be made by the net itself. Our basic approach is to regard sub-nets as special tokens of transitions. As mentioned in the introduction this approach proposes two extensions to the Petri net formalism: (1) Petri nets can be used as tokens and (2) transitions may be marked.
The first extension of Petri nets to object nets – also known as the nets-within- nets approach – has been proposed by Valk [18,19], and further developed e.g. in [3], [16], and [10,11]. The Petri nets that are used as tokens are called net-tokens. Net- tokens are tokens with internal structure and inner activity. This is different from place refinement, since tokens are transported while a place refinement is static. Net-tokens are some kind of dynamic refinement of states.

Object Nets and Object Net Systems
In the following we give a condensed definition of object net systems. For simplicity reasons we abstract from the syntax of inscriptions of net elements and synchroni- sations as it is used for reference nets [13] in the Renew tool (cf. [14]).
Object net systems have the set of object nets as their colour set. In [10] we generate the net-tokens via instantiation from a finite set of nets. In this definition, we assume for simplicity reasons an arbitrary set of object nets:
N = {N0, N1,.. .}
One object net models black tokens: • ∈ N . This net has one initally unmarked place and no transitions.
In coloured nets each transition t fires according to a mode b generated from transition guards, arc expressions and variable assignments. Let B be the set of firing modes. Each object net is a tuple
N = (PN , TN ,F −,F +)
N	N
where F −,F + : TN → (B → (PN → NN )). Given a binding b F −(t)(b)(p) is a
N	N	N
multiset of object nets.
Let P denote the union of all place components: P :=	N ∈N PN . Assume analogously defined union sets for transitions T , etc.
A marking μ of an object net system maps each place to a multi-set of object nets:
μ : P → NN
Here μ(p)(N ) > 0 describes the fact, that the place p is marked with μ(p)(N ) net-tokens of the type N .
Transitions in different nets may be synchronised via channels. In Renew chan- nels are also used to exchange parameters. Each transition has at most one uplink, which is passive, and several downlinks, which are active in the sense that they choose the synchronisation partner. Due to this structure we obtain tree-like syn- chronisations. The formal definition is based on the synchronisation trees. The set of all synchronisation trees is T =  n≥0 Tn where
Tn := {(t, b)[θ1 ··· θk] | t ∈ T ∧ b ∈ B ∧ ∀1 ≤ i ≤ k : θi ∈ l<n Tl}.	(3) The predomain F − (and analogously for F +) is extended to F − :Θ → (PN →
NN ) by:
F^−((t, b)[θ ··· θ ]) = F −(t)(b)+ Σk	F^−(θ )	(4)
Definition 3.1 An Object Net System is a tuple OS = (N , Θ, μ0) where
N is a set of object nets,
Θ ⊆ T is the set of system events, and

μ0 is the initial marking.
As usual we have μ −→θ μ' iff μ ≥ F^−(θ) and μ' = μ − F^−(θ)+ F^+(θ). This firing
rule describes the reference semantics of object nets – for an in-deep comparison of
alternative firing rules cf. [19,11].
Super-Dual Object Nets
Similarly to the extension of Petri nets to super-dual nets in section 2, we extend the object net formalism by using nets as pokens, called net-pokens. The net-pokens can be used as a dynamic reﬁnement (similar to a sub routine) of the transitions they mark. Figure 7 shows a super-dual object net with nets on places and on transitions.

Fig. 7. A Petri net with nets as tokens for places and transitions

Fig. 8. Equivalent refinement after firing of place p

Since these refinements are defined as markings it is possible to move net-pokens using the token-game of object nets. In Figure 7 the place p “fires” the net-poken from t2 to t. Transition t is then marked by two net-pokens, which means that there are two modes of refinement for t. The equivalent net containing the conflict between the possible refinement is given in Figure 8.
Each object net is a super-dual object net N = (PN , TN ,F −,F +, G− , G+ ) where
N	N	N	N
G± : TN → (B → (PN → NN )) define the inscriptions for glow arcs. One net models black pokens: □ ∈ N . Each net-poken N ∈ N has one transition startN with empty preset and one transition endN with empty postset. These transitions are used to start (or end, respectively) the dynamic refinement implemented by the net-poken. From a practical point of view it is reasonable to require that the net is unmarked when the refinement is started (i.e. when transition startN fires) and is unmarked again when it is ended by endN . We we do not adopt such a restriction here to allow a general definition.

A marking μ of a super-dual object net system maps each place and transition to a multi-set of object nets:
μ : (P ∪ T ) → NN
In analogy to T we define a tree structure of places: P =  n≥0 Pn where
Pn = {(p, b)[π1 ··· πk] | p ∈ P ∧ b ∈ B ∧ ∀1 ≤ i ≤ k : πi ∈ l<n Pl}.	(5) The mappings G− and G+ are defined analogously to F − and F +.
The mapping ν : (P ∪ T ) → N(P ∪T ) constructs a multiset by removing the nesting structure:


ν(x[ξ1
··· ξk
]) := x +	k
i=1
ν(ξi)	(6)

Here, ν(θ)(t, b) is the number of occurences of (t, b) in the nested structure θ.
A dynamically refined transition t is enabled in a mode N where N is the net- poken implementing the refinement. If N is the black poken □ , then this transition is not refined and synchronisation is possible. If N is not the black poken, it is used as a dynamic refinement of t. This refinement splits t into a start and an end part: (t, b, N, start ) and (t, b, N, end ).
R = {(t, b, N, α) | t ∈ T ∧ b ∈ B ∧ □ /= N ∈ N ,α ∈ {start , end }}	(7)
Definition 3.2 A Super-Dual Object Net System SDOS = (N , Θ, μ0) consists of the following components:
N is a set of object nets,
Θ ⊆ (T ∪ P ∪ R) is the set of system events, and
μ0 : (P ∪ T ) → NN is the initial marking.
The set of system events Θ contains elements from T , P, and R. So, we have different kinds of firing modes:

θ ∈ Θ ∩ T : As usual we have μ −→θ  μ' iff ∀p ∈ P : μ(p) ≥
F^−
(θ)(p) and

μ(t)(□ ) ≥ Σb∈B ν(θ)(t, b). Then μ' = μ − F^−(θ)+ F^+(θ).

θ ∈ Θ ∩ P: As usual we have μ −→π  μ' iff ∀t ∈ T : μ(t) ≥
G^−
(π)(t) and

μ(p)(•) ≥ Σb∈B ν(θ)(p, b). Then μ' = μ − G−(π)+ G+(π).
θ ∈ Θ ∩ R: A dynamic refinement has two parts.
The control is carried over from t to a refining net-poken N :


(t,b,N,start )
μ −−−−−−−→ μ
⇐⇒ ∀p ∈ P : μ(p) ≥ F
−(t)(b)(p)

∧ μ(t)(N ) ≥ 1 ∧ μ(startN )(□ ) ≥ 1
∧ μ' = μ − F −(t)(b)+ F +(startN )(b)

The control is given back from N to t:


(t,b,N,end )
μ −−−−−−−→ μ
⇐⇒ ∀p ∈ P : μ(p) ≥ F
−(endN )(b)(p)

∧ μ(t)(N ) ≥ 1 ∧ μ(endN )(□ ) ≥ 1
∧ μ' = μ − F −(endN )(b)+ F +(t)(b)
Proposition 3.3 Object nets are a special case of super-dual object nets: Each object net system is simulated by a super-dual object net system.
Proof. The super-dual object net system is obtained from the object net system adding no glow arcs marking all transitions with enough black-pokens. To allow all synchronisations θ ∈ Θ, the transition t is marked with max{ν(θ)(t, b) | b ∈ B, θ ∈ Θ} black-pokens. Then the super-dual object net system behaves the same way as the object net system since we have no refinements and no events θ ∈ Θ ∩ P. All the events θ ∈ Θ ∩T are enabled correspondingly and the effect is the same as for the object net system.	 

Simulating Super-Dual Object Nets
In our previous work [12] we have shown that super-dual nets can simulate Petri nets and, more interesting, that Petri nets can simulate super-dual nets – both in respect to the possible firing sequnces. The construction uses the dual of the G-component (i.e. SD |d ), renames all nodes x to x(d) and combines it with the F -component. The result is the simulating Petri net N (SD ) (Figure 9 illustrates the construction for the net SD of Figure 4).

p1	t1	p2

p1	t1	p2
p5
 p5(d)
p4


p3
SD |d
t2	p4


N (SD )

Fig. 9. The simulating net N (SD )
We will now lift our results to object nets and super-dual object nets to come back to the goal of this work, dynamic refinement of transitions. The construction for super-dual object nets is similar to the construction of N (SD ) for super-dual nets. We illustrate the construction of the simulating object net OS (SDOS ) at the example net from Figure 7. The construction involves two steps: In the first step the dual of the G-component (the unfilled nodes) is added to the F -component (the filled nodes) as side conditions for each object net. The refining net-pokens become net-tokens. The resulting net is given in Figure 10. Note, that the side transitions
named p(d) and p(d) have no effect. The same holds for the side condition named p.
1	2



Fig. 10. Adding the dual component to the net of Figure 7
These nodes might be omitted. In the second step we split each transition t of the F - component into two parts: tstart and tend , similarly to the construction suggested in the introduction (cf. Fig. 2). Transition tstart synchronises with the input transition startN , i.e. it starts the refining subnet N . Similarly, tend synchronises with the output transition. The resulting net – omitting synchronisation inscriptions – is given in Figure 11.

Fig. 11. Adding the start/end structure
We formalise this dualisation construction in the following. The element in the dual component corresponding to n ∈ P ∪ T is denoted n(d). The mapping f P maps each transition t to its dual, i.e. the place t(d) and each place p to its dual,
i.e. the place p(d): f X(n)= n if n ∈ X and f X(n)= n(d) if n /∈ X. The notation extends to pairs: f X((a, b)) = (f X(a),f X (b)) and to sets: f X(A) = {f X(a) | a ∈ A}. This definition also extends to the nested structures У and 7 the usual way: f X(x[ξ1 ... ξk]) := f X(x)[f X (ξ1) ... f X(ξk)].
net μ˜ is defined by μ˜(p)= μ(p) and μ˜(t)= μ(t(d)) or shorter for n ∈ P ∪ T : For each marking μ in the super-dual object net the marking in the simulating
μ˜(n)= μ(f (n))	(8)
The simulating event θ˜ is defined according to the three kinds of firing: A
places θ ∈ Θ∩У is simulated by θ(d). Both cases are subsumed by the definition θ˜ := synchronisation of transitions θ ∈ Θ ∩ 7 is simulated by θ. A synchronisation of

f T (θ). The start event (t, b, N, start ) ∈ Θ ∩R is simulated by the synchronisation of tstart (i.e. the first part of t) with the starting transition startN of the refining net N :
(tstart , b)[(startN , b)[]]
Similarily for the event (t, b, N, end ). This leads to the following definition:


θ˜ :=
⎧⎨ f T (θ),	if θ ∈ Θ ∩ (7 ∪ У)
⎩ (tα, b)[(αN , b)[]], if θ = (t, b, N, α) ∈ Θ ∩ R,α ∈ {start , end }

(9)

The notation extends to sets: Θ˜ = {θ˜ | θ ∈ Θ}.
Definition 4.1 Given a super-dual object system SDOS = (N , Θ, μ0) we define the object net system
OS (SDOS )= ({N˜ | N ∈ N }, Θ˜, μ˜0)
where N = (f P (P ∪ T ),f T (P ∪ T ), F −, F +) and with the bindings B = B ×N the
pre- and post conditions are defined by:
⎧ F ±(t)(b)(p), if n = p ∈ P

F˜±(t)(b, N )(n)= ⎨ N,	if n = t(d),t ∈ T (d)
⎪⎪⎩ 0,	otherwise

and
⎧ G±(p)(b)(t), if n = t(d) ∈ T (d)

F˜±(p(d))(b, N )(n)= ⎨ N,	if n = p ∈ P
⎪⎪⎩ 0,	otherwise

Then we have the following simulation property:
Proposition 4.2 Let SDOS be a super-dual object net. For the object net system OS (SDOS ) we have:


μ −−−θ−→ μ' ⇐⇒
SDOS
e
μ −−−−θ−−−→
OS (SDOS )
μ˜'

Proof. It is easy to observe from the construction, that whenever an event θ of
SDOS is enabled in μ then the event θ of is enabled in μ in the simulation object net system OS (SDOS ). This holds for the three cases of firing modes. No other events are enabled and the successor markings correspond.	 
This approach of expressing dynamic transition refinement using object nets is implemented as a special construct in our tool Renew. In the following we will illustrate the tool extension for the domain of dynamic workflows.

Transition Refinement: A First Approach in Renew
The concept of dynamic refinement is especially valuable in the context of workflow management systems. Dynamic refinements can be used to replace a sub workflow with a more up-to-date version respecting some preservation rules, like workflow inheritance (cf. [20]).
A first attempt to implement dynamic transition refinement in the Petri net tool Renew was done in the so-called workflow plug-in 4 [7]. Among various means for the definition and execution of workflows a so-called task transition was imple- mented. The task transition does not exactly meet our design criteria for dynamic refinement, but comes close enough to take a look.
The task transition implements two features. The first is irrelevant for the topic of this paper: The execution of a task transition may be canceled (see [7]). The second feature is close to the desired behaviour of a refined transition postulated in Section 1 (Figures 1(a) – 3).
Statically, a task transition looks like a normal transition with bold lines at the left and right side of its rectangle figure – see Figure 12. It is inscribed with a triple consisting of a task, i.e. the net 5 that refines the transition, a set of parameters to pass to this net and the expected result that should be passed back. The figure gives the semantics of a task transition in terms of a reference net. It is important to notice, that the task associated to a task transition need not be statically associated but may be exchanged at runtime. The task transition therefore puts dynamic transition refinement down to dynamic place refinement in terms of nets-within- nets.
When firing a task transition, the transition gets marked with the subnet that

refines it.
Renew treats this refinement token just as an ordinary token, so that

the usual means for inspection and manipulation are available.
What is missing to fully meet our design criteria is – besides some implemen- tation details – a better support for the separation of net refinement tokens from other tokens. This could be done in terms of a net type hierarchy.









y
x	z
[task,param,result]
result	y






Fig. 12. The workflow task transition

4 Renew offers a powerful plug-in concept making it easy to implement new functionality in all areas of net design, simulation and analysis.
5 Note, that in the workflow implementation a task is not necessarily a net, but may also be Java code.

Related work
To the best of our knowledge there are no publications describing dynamic transition refinements for Petri nets. There exists, however, a small amount of publications on Petri nets that can modify their structure at runtime and, separated from these, on duality in Petri nets:
Our approach describes a special kind of Petri nets that can modify their struc- ture via dynamic refinement of transitions. A first approach to the ability of struc- ture changing at runtime are self-modifying nets [17] which allow for arc weights that are marking depending. A special case is the empty marking that temporarily deletes arcs from the net. Another approach to structure modification in Petri nets is that of mobile nets [1] and recursive nets [6].
Duality is an important concept in Petri’s general net theory and is discussed in [5]. Petri only considers unmarked nets, so no “problems” with tokens on transitions arise. The restriction to unmarked nets is renounced by Lautenbach [15]. However, his concept of duality differs from the one presented in this paper. He considers firing in the dual reverse net Nrd. In his approach transitions become marked and places fire the tokens, which are lying on transitions, in the reversed arc direction. Additionally, contrary to our approach, for his definition a token on a transition disables its firing.

Conclusion
In this presentation we studied the dynamic refinement of transitions. Following the ideas of extending Petri nets to super-dual nets we generalised object net systems to super-dual object systems. Super-dual object net systems are nets-within-nets allowing nets as tokens both on places and on transitions. Transition marking nets, called net-pokens, may be moved around from one transition to another. They refine the transition they are actually marking. This offers the desired properties of a dynamic, run-time refinement procedure that is controlled by the net itself.
Super-dual object nets are related to an implementation of a workflow extension plugin of the Renew tool. This extension has a special notion of dynamically refin- able transitions, called tasks. These task transitions are executed by instantiating a net-token that implements a sub-workflow. In accordance with our definitions these sub-workflows are the dual of normal workflows, i.e. they have a unique input transition and a unique output transition. The workflow management system can make use of this mechanism when replacing sub-workflows by updates at runtime. This can be done easily by moving net-tokens around or creating new ones at run- time, e.g. as a result of a planning process. One can think of mobile workflows implemented by mobile agents in the style of [9].

References
Busi, N., Mobile nets, Formal Methods for Open Object-Based Distributed Systems (1999), pp. 51–66.

Design/CPN, Design/CPN homepage, http://www.daimi.au.dk/designCPN/ (2005).
Farwer, B., A linear logic view of object Petri nets, Fundamenta Informaticae 37 (1999), pp. 225–246.
Fehling, R., A concept of hierarchical Petri nets with building blocks, in: G. Rozenberg, editor, Advances in Petri Nets 1993, Lecture Notes in Computer Science 674 (1993), pp. 148–168.
Genrich, H. J., K. Lautenbach and P. S. Thiagarajan, Elements of general net theory, in: Brauer, W., editor, Net Theory and Applications, Advanced Course on General Net Theory of Processes and Systems, Hamburg, 1979, Lecture Notes in Computer Science 84 (1980), pp. 21–163.
Haddad, S. and D. Poitrenaud, Theoretical aspects of recursive Petri nets, in: S. Donatelli and J. Kleijn, editors, Application and Theory of Petri Nets 1999, Lecture Notes in Computer Science 1630 (1999),
pp. 228–247.
Jacob, T., O. Kummer, D. Moldt and U. Ultes-Nitsche, Implementation of workflow systems using reference nets – security and operability aspects, in: K. Jensen, editor, Fourth Workshop and Tutorial on Practical Use of Coloured Petri Nets and the CPN Tools (2002).
Jensen, K., “Coloured Petri nets, Basic Methods, Analysis Methods and Practical Use,” EATCS monographs on theoretical computer science, Springer-Verlag, 1992.
K¨ohler, M., D. Moldt and H. R¨olke, Modelling mobility and mobile agents using nets within nets, in:
W. v. d. Aalst and E. Best, editors, International Conference on Application and Theory of Petri Nets 2003, Lecture Notes in Computer Science 2679 (2003), pp. 121–140.
URL http://www.springerlink.com/link.asp?id=xf5vqh9cn0q1nukw
K¨ohler, M. and H. R¨olke, Concurrency for mobile object-net systems, Fundamenta Informaticae 54
(2003).
K¨ohler, M. and H. R¨olke, Properties of Object Petri Nets, in: J. Cortadella and W. Reisig, editors, International Conference on Application and Theory of Petri Nets 2004, Lecture Notes in Computer Science 3099 (2004), pp. 278–297.
URL http://www.springerlink.com/index/BLXWQ2EP7CFU2P0Y
K¨ohler, M. and H. R¨olke, Properties super-dual nets, Fundamenta Informaticae 72 (2006), pp. 245–254.
Kummer, O., Introduction to Petri nets and reference nets, Sozionik-aktuell 1 (2001).
URL http://www.sozionik-aktuell.de/

Kummer, O., F. Wienberg, M. Duvigneau, J. Schumacher, M. K¨ohler, D. Moldt, H. R¨olke and R. Valk, An extensible editor and simulation engine for Petri nets: Renew, in: J. Cortadella and W. Reisig, editors, International Conference on Application and Theory of Petri Nets 2004, Lecture Notes in Computer Science 3099 (2004), pp. 484 – 493.
Lautenbach, K., Duality of marked place/transition nets, Technical Report 18, Universit¨at Koblenz- Landau (2003).
Lomazova, I. A., Nested Petri nets – a formalism for specification of multi-agent distributed systems, Fundamenta Informaticae 43 (2000), pp. 195–214.
Valk, R., Self-modifying nets, a natural extension of Petri nets., in: Ausiello, G. and B¨ohm, C., editors,
Automata, Languages and Programming, Lecture Notes in Computer Science 62 (1978), pp. 464–476.
Valk, R., Modelling concurrency by task/flow EN systems, in: 3rd Workshop on Concurrency and Compositionality, number 191 in GMD-Studien (1991).
Valk, R., Object Petri nets: Using the nets-within-nets paradigm, in: J. Desel, W. Reisig and
G. Rozenberg, editors, Advanced Course on Petri Nets 2003, Lecture Notes in Computer Science 3098
(2003), pp. 819–848.
van der Aalst, W. and T. Basten, Inheritance of workflows: An approach to tackling problems related to change, Theoretical Computer Science 270 (2002), pp. 125–203.
