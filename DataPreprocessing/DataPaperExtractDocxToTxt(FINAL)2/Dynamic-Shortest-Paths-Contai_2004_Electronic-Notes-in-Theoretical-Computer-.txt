	Electronic Notes in Theoretical Computer Science 92 (2004) 65–84	
www.elsevier.com/locate/entcs




Dynamic Shortest Paths Containers
Dorothea Wagnera,1 , Thomas Willhalma,1 , and Christos Zaroliagisb,1
a Institut fu¨r Logik, Komplexit¨at und Deduktionssysteme Universit¨at Karlsruhe
76128 Karlsruhe, Germany
b Computer Technology Institute, and Department of Computer Engineering & Informatics
University of Patras, 26500 Patras, Greece

Abstract
Using a set of geometric containers to speed up shortest path queries in a weighted graph has been proven a useful tool for dealing with large sparse graphs. Given a layout of a graph G = (V, E), we store, for each edge (u, v) ∈ E, the bounding box of all nodes t ∈ V for which a shortest u-t-path
starts with (u, v). Shortest path queries can then be answered by Dijkstra’s algorithm restricted
to edges where the corresponding bounding box contains the target.
In this paper, we present new algorithms as well as an empirical study for the dynamic case of this problem, where edge weights are subject to change and the bounding boxes have to be updated. We evaluate the quality and the time for different update strategies that guarantee correct shortest paths in an interesting application to railway information systems, using real-world data from six European countries.
Keywords: geometric container, dynamic shortest path, graph layout.


Introduction
In this paper we consider a typical application in traffic, and in particular in railway, systems where a central server has to answer a huge number of customer queries asking for their best itineraries. The most frequently en- countered applications of the above scenario involve route planning systems

1 This work was partially supported by the Human Potential Programme of the European Union under contract no. HPRN-CT-1999-00104 (AMORE). Part of this work was done while the second author was visiting the Computer Technology Institute in Patras.


1571-0661 © 2004 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2003.12.023

for cars, bikes and hikers [21,2], or scheduled vehicles like trains and busses [19,11,13,17,10]. Further applications include spatial databases [18] and web searching [3]. Users of such a system continuously enter their requests for finding their “best” connections.
The algorithmic core problem that underlies the above problem is a special case of the single source shortest path problem on a given directed graph with nonnegative edge lengths related to a layout of the graph which is also provided. The particular graph is quite large (though sparse), and hence space requirements are only acceptable to be linear in the number of nodes.
In [17], angular sectors were introduced to speed up the processing of such shortest path queries. In a preprocessing step, the angular sector of each edge is determined that contains all nodes to which a shortest path using this edge exists. The shortest path queries are then answered by Dijkstra’s algorithm
[5] restricted to edges where the target node is inside the angular sector. Note that this method is guaranteed to find a shortest path, but it requires a time consuming all-pairs shortest paths computation as a preprocessing.
A recent experimental study in [20] replaces the angular sectors by other convex geometric containers and compares their impact on the number of visited nodes and the running time. Surprisingly, simple bounding boxes turn out to produce the fastest algorithm and are also competitive in the number of visited nodes.
This idea of geometric pruning can be extended to bi-directional search [12]. A second set of bounding boxes is determined by reversing all edges and running the preprocessing a second time on this modified graph. As illustrated in Figure 1, we will refer to the bounding boxes of this graph with reversed edges as “source containers” (containing the sources of shortest paths that end with this edge) in contrast to “target containers” (containing the target of shortest paths that start with this edge). A forward step in the bi-directional search checks the target containers whereas a backward step uses source containers.
All previous approaches, however, deal with the static version of the inves- tigated problem. In this paper, we are concerned with the dynamic version of the above mentioned scenario; namely, with the case where the graph may dynamically change over time as streets may be blocked, built, or destroyed, and trains may be added or canceled. In this work, we present new algorithms that dynamically maintain geometric containers when the weight of an edge is increased or decreased (note that these cases cover also edge deletions and insertions). We also report on an experimental study with real-world railway data. Our experiments show that the new algorithms are 2-3 times faster than the naive approach of recomputing the geometric containers from scratch.



Fig. 1. A target container T (u, v) contains (at least) all nodes t for which a shortest path from u to t starts with the edge (u, v). Analogously, a source container S(u, v) contains all nodes s for which a shortest path from s to v ends with the edge (u, v).

Our dynamic algorithms are perhaps the first results towards an efficient algorithm for the dynamic single source shortest path problem without using the output complexity model – introduced in [14,15] and extended in [7,8] – under which algorithms for the dynamic single source shortest path problem are usually analyzed. We would also like to mention that existing approaches for the dynamic all-pairs shortest paths problem (see e.g., [6,16,4,1,9], and [22] for a recent overview) are not applicable to maintain geometric containers, because of their inherent quadratic space requirements.
In the next section, a formal description of the dynamic shortest path containers and necessary definitions are given. The subsequent section 3 re- capitulates the static case of the preprocessing. Section 4 contains algorithms to update geometric containers for weight decreases and weight increases. Ex- periments and results are described in section 5 before the conclusion in the last section.

Definitions
A directed simple graph G is a pair (V, E), where V is a finite set and E ⊆ V × V . The elements of V are the nodes and the elements of E are the edges of the graph G. Throughout this paper, the number of nodes |V | is denoted by n and the number of edges |E| is denoted by m. A path in G is a sequence of nodes u1,... , uk such that (ui, ui+1) ∈ E for all 1 ≤ i < k. The edges of a graph are weighted by a function w : E → R+. We interpret the weights as edge lengths in the sense that the length of a path is the sum of the weights of its edges. Throughout the paper we assume that for all pairs (s, t) ∈ V × V , the shortest path from s to t is unique. 2

2 This can be achieved by adding a small fraction to the edge weights, if necessary.

If n denotes the number of nodes, a graph (without multiple edges) can have up to n2 edges. We call a graph sparse, if the number of edges m is in O(n), and we call a graph large, if one can only afford a memory consumption in O(n). In particular for large sparse graphs, n2 space is not affordable.
We assume that we are given a layout L : V → R2 in the Euclidean plane. For ease of notation we will identify a node v ∈ V with its location L(v) ∈ R2 in the plane. Throughout the paper, we will assume that the layout is fixed.
We call a region R ⊂ R2 with
 (x, y) ∈ R2 : xmin ≤ x ≤ xmax ∧ ymin ≤ y ≤ ymax}
an (axes-parallel) rectangle. Given a set of points P ⊂ R2, the smallest rect- angle R with P ⊂ R is called the bounding box of P . Note that the bounding box of a finite set P always exists and is unique.
Definition 2.1 Let G = (V, E), w : E → R+ be a weighted graph with layout L : V → R2. A rectangle T (u, v) for an edge (u, v) ∈ E is called a (consistent) target container of (u, v), if T (u, v) contains (at least) all nodes t for which there is a shortest u-t-path starting with the edge (u, v). Similarly, a rectangle S(u, v) for an edge (u, v) ∈ E is called a (consistent) source container S(u, v) of (u, v), if S(u, v) contains (at least) all nodes s for which there is a shortest s-v-path ending with the edge (u, v).
Note that further nodes may be part of a target container. However, at least the nodes that can be reached by a shortest path starting with e must be in T (e). We will refer to the additional nodes as wrong nodes, since they lead us the wrong way.

Creating Consistent Containers
We now describe in detail how to compute T (s, x) for all edges (s, x) ∈ E. The complete algorithm is shown as Algorithm 1 (light gray lines indicate Dijkstra’s original pseudocode, while the rest indicate our modifications). To determine T (s, x) for every edge (s, x) ∈ E, Dijkstra’s algorithm is run for each node s ∈ V . We keep a node array A where the entry A[v], v ∈ V , stores the first edge (s, x) in a shortest s-v-path in G. This can be constructed in a way similar to that of a shortest path tree: Every time the distance label of a node v is adjusted via (u, v), we set A[v] to (u, v), if u = s, and to A[u], otherwise (lines 14–17). When a node u is removed from the priority queue, A[u] holds the outgoing edge of s with which a shortest path from s to u starts. In line 18 and 19, for each edge (s, x) the bounding box of all nodes y ∈ V with A[u] = (s, x) is computed. It is a consistent target container for

Create-Containers
Input: graph G = (V, E), weights w : E → R+
Output: consistent target containers
for all s ∈ V do
set d(u) := ∞ for all nodes u ∈ V
create empty priority queue Q
insert source s in Q and set d(s) := 0
while priority queue is not empty
get node u with smallest tentative distance in Q
for all neighbor nodes v of u
set new-dist := dist(u)+ w(u, v)
if new-dist < dist(v)
if d(v)= ∞
insert neighbor node v in Q with priority new-dist
else
set priority of neighbor node v in Q to new-dist
set dist(v) := new-dist
if u = s
set A[v] := (s, v)
else
set A[v] := A[u]
for all nodes y ∈ V \{s}
enlarge the bounding box of A[y] to contain y
Algorithm 1. Create-Containers. Running a modification of Dijkstra’s algorithm for all nodes
s ∈ V to create consistent target containers.

(s, x). The overall running time is O(n2 log n), because Dijkstra’s algorithm runs in O(n log n) time for sparse graphs. The storage requirement is O(n).
Consistent source containers can be created by reversing the edges and running Create-Containers on this modified graph.


Updating Containers
If a weight of an edge is changed, some source and target containers must be enlarged to stay consistent. More precisely, for every new shortest path u0, u1,... , uk−1, uk in the graph, T (u0, u1) and S(uk−1, uk) have to be updated to include uk and u0, respectively. Throughout this section, we will mark variables before the update with the subscript “old” and updated values with the subscript “new”.



Fig. 2. When the weight of the edge (x, y) is increased, the source s of a new shortest path from s
to t must be inside Sold(x, y).
Increasing an edge weight
Let us first consider the case of increasing the weight of an edge (x, y) ∈ E. We will show that it suffices to consider paths that start at vertices in Sold(x, y) to correct all source containers (see Figure 2). The update itself can be achieved by running a truncated Dijkstra’s algorithm for all these nodes.
Lemma 4.1 Let G = (V, E), w : E → R+ be a weighted graph. Assume that the increase of the weight of an edge (x, y) ∈ E creates a new shortest s-t-path Pnew in G. Then, before the weight change, (x, y) is the last edge of a shortest s-y-path and the ﬁrst edge of a shortest x-t-path.
Proof. Let Pold denote the old shortest path from s to t. Since the weight w(x, y) is increased, (x, y) ∈ Pold. Let Psy denote the first part of this path Pold from s to y. Since a sub-path of a shortest path is again a shortest path, Psy was the shortest path from s to y. For symmetric reasons, the first edge of a shortest x-t-path is (x, y).	 
Corollary 4.2 Let G = (V, E), w : E → R+ be a weighted graph. Assume that the increase of the weight of an edge (x, y) ∈ E creates a new shortest s-t-path Pnew in G. Then
s ∈ Sold(x, y)	and	t ∈ Told(x, y).

So, to enlarge the containers, it suffices to search for shortest paths that start from a node in Sold(x, y) and end with a node in Told(x, y). Running Create-Containers restricted to nodes in Sold(x, y) therefore fixes the source containers. However, it is possible to further truncate Dijkstra’s algorithm using the following Lemma.

Increase-Edge-Weight(x, y)
Input: graph G = (V, E), weights w : E → R+,
consistent target containers for old edge weight wold(x, y), increased edge weight wnew(x, y)
Output: consistent target containers for increased edge weight wnew(x, y)
for all s ∈ Sold(x, y) do
set d(u) := ∞ for all nodes u ∈ V
create empty priority queue Q
insert source s in Q and set d(s) := 0
while priority queue is not empty
get node u with smallest tentative distance in Q
5a	if u /= s enlarge T (A[u]) to contain u
for all neighbor nodes v of u
set new-dist := dist(u)+ w(u, v)
7a	if new-dist < d(s, x)+ wnew(x, y)+ d(y, v)
if new-dist < dist(v)
if d(v)= ∞
insert neighbor node v in Q with priority new-dist
else
set priority of neighbor node v in Q to new-dist
set dist(v) := new-dist
if u = s
set A[v] := (s, v)
else
set A[v] := A[u]
Algorithm 2. Increase-Edge-Weight(x, y). Dijkstra’s algorithm truncated to enlarge target containers after an increase of the weight w(x, y). A neighbor v is only visited, if the path from s to v does not contain the edge (x, y).
Lemma 4.3 Let G = (V, E), w : E → R+ be a weighted graph and let Pnew be a path from a node s toa node t that has become a shortest path because of an increase of the weight of an edge (x, y). Then, for all nodes u ∈ Pnew:
dnew(s, u) < dnew(s, x)+ wnew(x, y)+ dnew(y, u)
Proof. The new shortest path Pnew does not contain the edge (x, y), and the sub-path of Pnew from s to u is also a shortest path that does not contain the edge (x, y). The right hand side of the inequality is the length of some path from s to u containing (x, y). Since shortest paths are assumed to be unique, the lemma follows immediately.	 
Algorithm 2 (Increase-Edge-Weight(x, y)) combines the result of Corol- lary 4.2 and Lemma 4.3. Dijkstra’s algorithm is only run for all nodes in

Sold(x, y) and nodes are only inserted into the queue Q, if the condition of Lemma 4.3 is fulfilled. The rest of the nodes that do not satisfy Lemma 4.3 are never inserted in the queue Q.
Theorem 4.4 Increase-Edge-Weight(x, y) (Algorithm 2) enlarges all tar- get containers after an increase of the weight w(x, y) as necessary.
Proof. Consider the shortest path P from s to t that is found by an unmod- ified Dijkstra’s algorithm. If for all nodes v ∈ P the condition in line 7a is fulfilled, the path P is found by Increase-Edge-Weight(x, y), because the pruning does not change the order in which the edges are processed. 
Let
Pot-Aff(s) := {v ∈ V : dnew(s, v) < dnew(s, x)+ wnew(x, y)+ dnew(y, v)}
denote the set of potentially affected nodes for s ∈ V after an increase of the edge weight w(x, y). For each node s ∈ Sold(x, y), Increase-Edge- Weight(x, y) runs Dijkstra’s algorithm restricted to the graph induced by Pot-Aff(s). The running time of Increase-Edge-Weight(x, y) is therefore

linear in	Σ
s∈Sold(x,y)
|Pot-Aff(s)|

If |Pot-Aff(s)| is bounded for all s ∈ Sold(x, y) by some p, then the running time is O(k · p log p) where k := |{s ∈ Sold(x, y)}|.
The source containers are the counterpart to target containers, if all edges in the graph are reversed. So, Increase-Edge-Weight(x, y) applied to a graph with reversed edges enlarges the source containers as necessary.
The algorithm Increase-Edge-Weight(x, y) uses distance values d(u, x) and d(y, u) for different u ∈ E, which have to be computed beforehand. So, the overall method for an increase of w(x, y) is as follows:
Run Dijkstra’s algorithm for the source y to compute d(y, u) for all u ∈ V .
Run Dijkstra’s algorithm with reversed edges for the source x to compute
d(u, x) for all u ∈ V .
Run Increase-Edge-Weight(x, y) to enlarge target containers.
Run Increase-Edge-Weight(x, y) with reversed edges to enlarge source containers.
Decreasing an edge weight
Similar to the case of an increase, we can prove a lemma about start and end nodes of new shortest paths for the case of a decrease. This time however, the updated source and target containers must be used.

Lemma 4.5 Let G = (V, E), w : E → R+ be a weighted graph. Assume that the decrease of the weight of an edge (x, y) ∈ E creates a new shortest s-t-path Pnew in G. Then, after the weight change, (x, y) is the last edge of a shortest s-y-path and the ﬁrst edge of a shortest x-t-path.
Proof. Obviously, the edge (x, y) must be part of this path Pnew. Let Psy denote the sub-path of Pnew from s to v. As a sub-path of a shortest path Psy is also a shortest path. In particular, Psy is a shortest path that ends with the edge (x, y). For symmetric reasons, the first edge of a shortest x-t-path is (x, y).	 
Corollary 4.6 Let G = (V, E), w : E → R+ be a weighted graph. Assume that the decrease of the weight of an edge (x, y) ∈ E creates a new shortest s-t-path Pnew in G. Then
s ∈ Snew(x, y)	and	t ∈ Tnew(x, y).
In order to run a (truncated) Dijkstra for all nodes in Tnew(x, y), it is necessary to compute Tnew(x, y), i.e. to enlarge it if necessary. This can be achieved by Algorithm 3 Compute-Tnew(x, y). The container is enlarged similar to its creation in Create-Containers. If a new shortest path is found to a node t, the container T (x, y) is enlarged in line 5a. This variant of Dijkstra’s algorithm is truncated to the part of the graph, where distance labels change.
Theorem 4.7 Let G = (V, E), w : E → R+ be a weighted graph and Sold(x, y) a consistent source container. Compute-Tnew(x, y) (Algorithm 3) enlarges the source container for a decrease of the weight w(x, y) as necessary.
Proof. It is obvious that without line 7a the algorithm Compute-Tnew(x, y) works as expected. If a node v is excluded in line 7a, we distinguish between two cases. If new-dist = wnew(x, y)+ dold(y, v), the distance of v has not changed. Furthermore, the distance has not changed for all nodes a where the shortest x-a-path contains v. Ignoring nodes v ∈ V with new-dist = wnew(x, y)+ dold(y, v) therefore does not change the result of the algorithm. If new-dist > wnew(x, y)+ dold(y, v), there exists a shorter path from x to v that does not contain (u, v). The node v can therefore be ignored in this case, too.	 
Our final goal is to run a truncated version of Dijkstra’s algorithm for all nodes in Snew(x, y) to adjust all start containers after an edge weight decrease. The truncation is realized similarly to Lemma 4.3, but this time the old weight of the edge (x, y) is used in the comparison.

Compute-Tnew(x, y)
Input: graph G = (V, E), weights w : E → R+,
consistent target containers for old edge weight wold(x, y), decreased edge weight wnew(x, y)
Output: consistent target container Tnew(x, y)
set s := x
set d(u) := ∞ for all nodes u ∈ V
create empty priority queue Q
insert source s in Q and set d(s) := 0
while priority queue is not empty
get node u with smallest tentative distance in Q
5a	if u /= s and T (A[u]) = (x, y) enlarge T ((x, y)) to contain u
for all neighbor nodes v of u
set new-dist := dist(u)+ w(u, v) 7a	if new-dist < wold(x, y)+ dold(y, u)
if dist(v) > new-dist
if d(v)= ∞
insert neighbor node v in Q with priority new-dist
else
set priority of neighbor node v in Q to new-dist
set dist(v) := new-dist
if u = s
set A[v] := (s, v)
else
set A[v] := A[u]
Algorithm 3. Compute-Tnew (x, y). Dijkstra’s algorithm truncated to enlarge target container T (x, y) after an decrease of the weight w(x, y). A neighbor v is only visited, if the distance from x to v is shorter than the old distance dold(x, v).

Fig. 3. When the weight of the edge (x, y) is decreased, for all nodes u on a new shortest path from s to t, dnew(s, u) < dnew(s, x)+ wold(x, y)+ dnew(y, u).

Lemma 4.8 Let G = (V, E), w : E → R+ be a weighted graph and let Pnew be a path from a node s toa node t that has become a shortest path because of a decrease of the weight of an edge (x, y). Then, for all nodes u ∈ Pnew:
dnew(s, u) < dnew(s, x)+ wold(x, y)+ dnew(y, u)
Proof. Since wnew(x, y) < wold(x, y), the new distance dnew(s, t) must be shorter than the old distance dold(s, t). The new shortest path Pnew does con- tain the edge (x, y) in contrast to the old shortest path from s to t. Therefore
dnew(s, t) = dnew(s, x)+ wnew(x, y)+ dnew(y, t)
< dnew(s, x)+ wold(x, y)+ dnew(y, t)
Consider now some node u ∈ Pnew (illustrated in Figure 3). Let Ps,u denote the sub-path of Pnew from s to u. If Ps,u does not contain (x, y), i.e. if the edge (x, y) appears in Pnew after u,
dnew(s, u) < dnew(s, x) < dnew(s, x)+ wold(x, y)+ dnew(y, t) since wold(x, y) > 0. If Ps,u contains (x, y), then
dnew(s, u)= dnew(s, x)+ wnew(x, y)+ dnew(y, u)
otherwise a shorter path from s to u would exist which contradicts the fact that Pnew is a shortest path. Since wold(x, y) > wnew(x, y) the lemma follows. 
Using Lemma 4.6 and 4.8, the correctness of Decrease-Edge-Weight(x, y) (Algorithm 4) follows immediately as stated in the following Theorem.
Theorem 4.9 Decrease-Edge-Weight(x, y) (Algorithm 4) enlarges all tar- get containers after a decrease of the weight w(x, y).	 
Let
Pot-Aff'(s) := {v ∈ V : dnew(s, v) < dnew(s, x)+ wold(x, y)+ dnew(y, v)}
denote the set of potentially affected nodes for s ∈ V after a decrease of the edge weight w(x, y). For each node s ∈ Snew(x, y), Decrease-Edge- Weight(x, y) runs Dijkstra’s algorithm restricted to the graph induced by Pot-Aff'(s). The running time of Decrease-Edge-Weight(x, y) is therefore

linear in	Σ
s∈Snew(x,y)
|Pot-Aff'(s)|

If |Pot-Aff'(s)| is bounded for all s ∈ Snew(x, y) by some p, then the running time is O(k · p log p) where k := |{s ∈ Snew(x, y)}|.
In summary, the combination of Compute-Tnew(x, y) for reversed edges and Decrease-Edge-Weight(x, y) enlarges the target containers after an decrease of an edge weight w(x, y). As in the previous case, source containers

Decrease-Edge-Weight(x, y)
Input: graph G = (V, E), weights w : E → R+,
consistent target containers for old edge weight wold(x, y), decreased edge weight wnew(x, y),
consistent source container Snew(x, y)
Output: consistent target containers for decreased edge weight wnew(x, y)
for all s ∈ Snew(x, y) do
set d(u) := ∞ for all nodes u ∈ V
create empty priority queue Q
insert source s in Q and set d(s) := 0
while priority queue is not empty
get node u with smallest tentative distance in Q
5a	if u /= s enlarge T (A[u]) to contain u
for all neighbor nodes v of u
set new-dist := dist(u)+ w(u, v)
7a	if new-dist < d(s, x)+ wold(x, y)+ d(y, v)
if dist(v) > new-dist
if d(v)= ∞
insert neighbor node v in Q with priority new-dist
else
set priority of neighbor node v in Q to new-dist
set dist(v) := new-dist
if u = s
set A[v] := (s, v)
else
set A[v] := A[u]
Algorithm 4. Decrease-Edge-Weight(x, y). Dijkstra’s algorithm truncated to enlarge target containers after an decrease of the weight w(x, y). A neighbor v is only visited, if the path from s to v is shorter than the shortest path from s to v that uses edge (x, y) with the old weight wold(x, y).
can be treated similarly with all edges reversed. The complete algorithm to update source and target containers after an edge decrease is therefore:
Run Dijkstra’s algorithm for the source y to compute d(y, u) for all u ∈ V .
Run Dijkstra’s algorithm with reversed edges for the source x to compute
d(u, x) for all u ∈ V .
Run Compute-Tnew(x, y) to enlarge the target containers S(x, y).
Run Compute-Tnew(x, y) for y with reversed edges to enlarge the source container S(x, y).
Run Decrease-Edge-Weight(x, y) to enlarge start containers.
Run Decrease-Edge-Weight(x, y) with reversed edges to enlarge source

containers.

Experiments
Experimental Setup
We performed an experimental study to evaluate the performance and quality of our algorithms. More precisely the following two questions were examined:
How much time is needed to update the containers (on average)?
How much do the containers differ from containers computed from scratch? (Remember that we do not shrink containers in our updates.)
The quality of a set of containers was evaluated according to the following criterion.
Definition 5.1 Let C denote the set of containers we want to examine and Cref denote the reference set of containers that has been computed from scratch. For both sets, we count the number of nodes inside all containers e∈E |{t ∈ C(e)}|. Both sums are bounded by n · m. We therefore define the
quality of C as:
nm − Σe∈E |{t ∈ C(e)}| nm − Σe∈E |{t ∈ Cref(e)}|
This fraction equals 1, if the number of wrong nodes inside containers is the same for C and Cref, but is biased by the number of correct nodes. If all containers in C contain the entire graph, the quality of C is 0.
The test graphs in our computational study are railway networks of dif- ferent European countries. The nodes of such a graph are the stations and an edge between two stations exists iff there is an non-stop connection. The edges are weighted by the average travel time. The sizes of these networks are given in Table 1.
For each graph, we increase the weight of 100 random edges to a large value (i.e. the sum of all weights in the graph). This is similar to removing the edge from the graph. After every weight change, the containers are updated according to section 4.1. A second set of containers is determined from scratch to compute the quality and compare the computation time.
For the evaluation of decreasing edge weights, we start with the graph where 100 random edges have been set to a large weight. The weights are then decreased to their original values. Again, the updated containers are compared to newly computed containers.
Apart from the algorithms in section 4, we evaluated updates, if source containers are not maintained. In this case, Increase-Edge-Weight(x, y)

and Decrease-Edge-Weight(x, y) cannot iterate over all nodes in Sold(x, y) and Snew(x, y), respectively. The nodes, where containers have to be updated, must be determined beforehand. According to Lemma 4.1 and 4.5, for such a node s ∈ V , the last edge on a shortest s-y-path is (x, y). These nodes can be determined by a run of a modified Dijkstra starting at y with reversed edges. Note that in this case only half of the containers need maintenance.
Both variants, with source containers and without source containers, find those nodes for which the containers of incident edges must be updated. For both variants, we studied three methods to update the container of an edge:
Enlarge the container as described in Section 4. A variant of Dijkstra’s algorithm pruned according to Lemma 4.3 and 4.8 enlarges the containers.
Compute the container from scratch. The result is slightly different from recomputing all containers from scratch, because some may shrink but are not updated. However, the distances of all nodes to x and from y to all nodes are not needed in this case and their computation can be omitted.
Enlarge the container to infinity (without any further computation). If the entire graph is inside the container, it is certainly consistent. However, the quality of the containers is going down rapidly. Again, the distances of all nodes to x and from y to all nodes are not needed in this case and their computation can be omitted.
All six variants have been implemented in C++ based on the graph struc- ture provided by LEDA 4.4. The programs were compiled with GCC 3.2 and run on a single Intel Xeon with 2.4 GHz performing Linux 2.4.

Computational Results
Figures 4 and 5 depict the changes of the quality for updated containers. In both cases – with and without source containers – the outcome is very similar. Furthermore, the case of an edge weight increase resembles the case of an edge weight decrease.
If containers are only enlarged, their quality decreases most of the time as expected. It is interesting to note that the larger the graph, the larger its quality remains. Single “bad” containers are clearly less important, if the graph contains more edges. For large graphs, the quality stays close to 1 even after 100 updates.
If the containers are simply set to infinity, the situation is dramatically dif- ferent though. After a few updates, the containers settle in a state where almost all nodes are inside all containers. Such a state is clearly not desir- able, because no nodes are pruned by Dijkstra’s algorithm for queries.


Table 1
Average speed-up for updating the containers after increasing an edge weight


The situation is slightly better in Figure 5, where source containers are not used, because they may already be very bad from previous updates. Still the resulting containers are not acceptable after a few updates.
The case where containers of adjacent edges are recomputed from scratch is missing in the figures, since the resulting containers coincide most of the time with the newly computed containers. In other words, the quality equals 1 after almost every update. In practice, such updates can therefore be considered as good as using freshly determined containers.
The analysis of the time measurements are shown in Table 1 for weight increases and Table 2 for weight decreases. The first two columns list the number of nodes and the number of edges in the respective graphs. The other six columns refer to the six cases that have been examined in our study. The three types of updates (enlarge the containers to infinity, enlarge the containers according to Lemma 4.3 and 4.8, and recompute the containers from scratch) were tested with maintenance of source containers and without it (using a backward Dijkstra instead). Although the time improvements are huge, if the containers are enlarged to infinity, these values are more or less meaningless, because of the inacceptable quality. Discussing them does not really make sense and they are mainly shown for sake of completeness.































0	20	40	60	80	100	0	20	40	60	80	100

Index


enlarged containers after increasing weights
Index


enlarged containers after decreasing weights














infinite containers after increasing weights
infinite containers after decreasing weights


Fig. 4. The quality of containers after 100 changed edge weights, if source containers are available and maintained. In the upper diagrams, the containers are updated by a pruned Dijkstra for all nodes in the source container of the edge with changed weight (see Algorithms 2 and 4). In the lower diagrams, containers are enlarged to infinity for all edges incident to nodes inside Sold(x, y).






























0	20	40	60	80	100	0	20	40	60	80	100

Index	Index


enlarged containers after increasing weights
enlarged containers after decreasing weights



























0	20	40	60	80	100	0	20	40	60	80	100

Index	Index


infinite containers after increasing weights
infinite containers after decreasing weights


Fig. 5. The quality of containers after 100 changed edge weights. In the upper diagrams, the containers are enlarged by a pruned Dijkstra for all nodes s with (x, y) as the last edge of a shortest s-y-path. In the lower diagrams, the containers are enlarged to infinity for all edges incident to nodes s with (x, y) as the last edge of a shortest s-y-path.


Table 2
Average speed-up for updating the containers after decreasing an edge weight

An interesting observation is the fact that the speed-up factor does not seem to be correlated with the size of the graph. Furthermore the similarity of the algorithms for increasing and decreasing edge weights probably ex- plains the similar behavior in terms of timings. The speed-up values with and without source containers are quite similar, but note that the absolute time values with source containers are about twice as large. Maintaining source containers can therefore only justified, if they are used otherwise (e.g. for a bi-directional search). The most interesting observation however is the fact that using a pruned Dijkstra (column “enlarge”) is often slower than Dijkstra without pruning (column “from scratch”). Obviously the additional check and computing the distances to x and from y for all nodes outweigh the gain of the pruning.

Conclusion and Outlook
We have seen that it is possible to speed up the maintenance of geometric con- tainers by a factor of about 2-3 while preserving optimality in almost all cases. Enlarging containers to infinity leads to a cascading effect that destroys the benefit of geometric containers. If containers are only enlarged, the presented pruning of Dijkstra’s algorithm does not justify the loss of quality.

It would be interesting to find other simplifications that guarantee con- sistent containers, but realize a good compromise between optimality and running time. Furthermore, our results suggest that it should be possible to get a speed-up factor of about 2 with an (provable) optimal update strategy. Finally, it might be possible to combine edge weight increases and edge weight decreases in a single algorithm.

References
Ausiello, G., G. F. Italiano, A. Marchetti-Spaccamela and U. Nanni, Incremental algorithms for minimal length paths, Journal of Algorithms 12 (1991), pp. 615–638.
Barrett, C., K. Bisset, R. Jacob, G. Konjevod and M. Marathe, Classical and contemporary shortest path problems in road networks: Implementation and experimental analysis of the transims router, in: R. M¨ohring and R. Raman, editors, ESA 2002, LNCS 2461 (2002), pp. 126–138.
Barrett, C., R. Jacob and M. Marathe, Formal-language-constrained path problems, SIAM Journal on Computing 30 (2000), pp. 809–837.
URL http://epubs.siam.org/sam-bin/dbq/article/33771
Demetrescu, C. and G. F. Italiano, A new approach to dynamic all pairs shortest paths, in:
Proceedings of the thirty-ﬁfth ACM Symposium on Theory of Computing (STOC 2003) (2003),
pp. 159 – 166.
URL http://doi.acm.org/10.1145/780542.780567
Dijkstra, E. W., A note on two problems in connexion with graphs, Numerische Mathematik 1
(1959), pp. 269–271.
Even, S. and H. Gazit, Updating distances in dynamic graphs, Methods of Operations Research
49 (1985), pp. 371–387.
Frigioni, D., Semidynamic algorithms for maintaining single-source shortest path trees, Algorithmica 22 (1998), pp. 250–274.
URL http://www.springerlink.com/link.asp?id=23udd5uwx8lp

Frigioni, D., A. Marchetti-Spaccamela and U. Nanni, Fully dynamic output bounded single source shortest path problem, in: SODA, 1996, pp. 212–221.
King, V., Fully dynamic algorithms for maintaining all-pairs shortest paths and transitive closure in digraphs, in: Proc. 40th IEEE Symposium on Foundations of Computer Science (FOCS’99), 1999, pp. 81–91.
Mu¨ller-Hannemann, M. and K. Weihe, Pareto shortest paths is often feasible in practice, in:
G. Brodal, D. Frigioni and A. Marchetti-Spaccamela, editors, WAE 2001, LNCS 2461 (2001),
pp. 185–197.
Nachtigall, K., Time depending shortest-path problems with applications to railway networks, European Journal of Operational Research 83 (1995), pp. 154–166.
Pohl, I., Bi-directional search, in: B. Meltzer and D. Michie, editors, Sixth Annual Machine Intelligence Workshop, Machine Intelligence 6 (1971), pp. 137–140.
Preuss, T. and J.-H. Syrbe, An integrated traffic information system, in: Proc. 6th Int. Conf. Appl. Computer Networking in Architecture, Construction, Design, Civil Eng., and Urban Planning (europIA ’97), 1997.
Ramalingam, G. and T. W. Reps, An incremental algorithm for a generalization of the shortest- path problem, Journal of Algorithms 21 (1996), pp. 267–305.


Ramalingam, G. and T. W. Reps, On the computational complexity of dynamic graph problems, Theoretical Computer Science 158 (1996), pp. 233–277.
Rohnert, H., A dynamization of the all pairs least cost path problem, in: Proc. Symp. Theoretical Aspects of Computer Science (STACS’85), LNCS 182 (1985), pp. 279–286.
Schulz, F., D. Wagner and K. Weihe, Dijkstra’s algorithm on-line: An empirical case study from public railroad transport, Journal of Experimental Algorithmics 5 (2000).
URL http://www.jea.acm.org/2000/SchulzDijkstra/
Shekhar, S., A. Fetterer and B. Goyal, Materialization trade-offs in hierarchical shortest path algorithms, in: Symposium on Large Spatial Databases, 1997, pp. 94–111.
Sikl´ossy, L. and E. Tulp, Trains, an active time-table searcher, in: Proc. 8th European Conf. Artiﬁcial Intelligence, 1988, pp. 170–175.
Wagner, D. and T. Willhalm, Geometric speed-up techniques for ﬁnding shortest paths in large sparse graphs, in: Proc. 11th European Symposium on Algorithms (ESA 2003), LNCS (2003), to appear.
Zahn, F. B. and C. E. Noon, A comparison between label-setting and label-correcting algorithms for computing one-to-one shortest paths, Journal of Geographic Information and Decision Analysis 4 (2000).
URL http://www.geodec.org/
Zaroliagis, C., Implementations and experimental studies of dynamic graph algorithms, in:
R. Fleischer, B. Moret and E. M. Schmidt, editors, Experimental Algorithmics, LNCS 2547
(2002), pp. 229–278.
