

Electronic Notes in Theoretical Computer Science 249 (2009) 135–156
www.elsevier.com/locate/entcs

Game Semantics for Access Control
Samson Abramsky1 ,2
Oxford University Computing Laboratory Wolfson Building, Parks Road, Oxford OX1 3QD, U.K.
Radha Jagadeesan3
School of CTI, DePaul University
243 S. Wabash Ave, Chicago, Illinois 6064–2287, U.S.A.

Abstract
We introduce a semantic approach to the study of logics for access control and dependency analysis, based on Game Semantics. We use a variant of AJM games with explicit justification (but without pointers). Based on this, we give a simple and intuitive model of the information flow constraints underlying access control. This is used to give strikingly simple proofs of non-interference theorems in robust, semantic versions.
Keywords: Access Control, Authorization Logic, Dependency Analysis, Game Semantics.


Introduction
In recent years, there has been a significant development of constructive logics and type theories for access control [1,19,20]. The core structure of these logics has turned out to coincide in large part with a calculus previously developed as a basis for various forms of dependency analysis in programming languages [3]. This structure can be described quite succinctly as follows. We take a standard type theory as a basic setting. This may be the simply-typed or polymorphic λ-calculus [1], or some form of linear type theory [19]. Such type theories correspond to systems of logic under the Curry-Howard correspondence. We then extend the type theory with a family of monads, indexed by the elements of a “security lattice” L [1]. This lattice can be interpreted in various ways. The basic reading is to think of the

1 This research was partly supported by EPSRC Grant EP/D038987/1
2 Email: samson@comlab.ox.ac.uk
3 Email: rjagadeesan@cs.depaul.edu

1571-0661 © 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.07.088

elements of the lattice as indicating security levels. We shall follow the convention, as in [1], that a higher level (more trusted) is lower down in the lattice ordering.
The reading which is often followed is to think of an underlying partially ordered set of “principals”, with the lattice elements corresponding to sets of principals. This leads to the reading of TlA, where Tl is the monad indexed at the security level l, as “l says A”. The monads are type-theoretic counterparts of logical modalities
[26]; their use is well established both in logical type theories and in programming languages [33,18,12]. We illustrate their use in the specification of access control with an example drawn from Garg and Abadi [GA08].
Example 1.1 [ [GA08]] Let there be two principals, Bob (a user) and admin (stand- ing for administration). Let dfile stand for the proposition that a certain file should be deleted. Consider the collection of assertions:
(admin says dfile) ⇒ dfile
admin says ((Bob says dfile) ⇒ dfile )
Bob says dfile
Using the unit of the monad with (iii) yields (admin says (Bob says dfile)). Using modal consequence with (ii) yields:
(admin says (Bob says dfile)) ⇒ (admin says dfile) dfile now follows using modus ponens.
The main results which are obtained in this setting, as a basis for access con- trol or dependency analysis, are non-interference theorems 4 , which guarantee the absence of information flows or logical dependencies which would contradict the con- straints expressed by the security lattice L. A typical example of a non-interference theorem could be expressed informally as follows:
No proof of a formula of the form “P says φ” can make any essential use of formulas of the form “Q says ψ” unless Q is at the same or higher security level as P. In other words, we cannot rely on a lower standard of “evidence” or authorization in passing to a higher level.
In the flow analysis context, it is natural to think of the constraints as ensuring that information does not flow from “higher” to “lower” variables [3]. We would then use the same definitions, and obtain the same results — but with the opposite reading of the security lattice!
Thus far, access control logics have predominantly been studied using proof- theoretic methods. Our aim in the present paper is to initiate a semantic approach based on Game Semantics.
Game Semantics has been developed over the past 15 years as an ap- proach to the semantics of both programming languages and logical type theories [9,10,25,11,27,8,22,7,38]. It has yielded numerous full abstraction and full complete-

4 The term ‘interference’ is used in a number of senses in the security literature. Our usage follows that in [1,19,20].

ness results, in many cases the only such results which have been obtained. There has also been an extensive development of algorithmic methods, with applications to verification [21,6,34,35,29].
Our aim in the present paper is to show that Game Semantics provides an intuitive and illuminating account of access control, and moreover leads to strikingly simple and robust proofs of interference-freedom.

General Advantages of the Semantic Approach
Proof-theoretic approaches to negative results such as non-interference proper- ties necessarily proceed by induction over the proof system at hand. This embodies a “closed world assumption” that the universe is inductively generated by the syn- tax of the system, which means that each new system requires a new proof. A semantic approach, which is carried out in a semantic framework capable of pro- viding models for a wide range of systems, and which supplies positive reasons — structural properties and invariants of the semantic universe — for the negative re- sults, can be more general and more robust. We shall give an illustrative example of how semantic non-interference results can be used to obtain results about syntactic calculi in Section 5.

Specific Features of the Games Model
A number of features of the version of Game semantics which we shall use in this paper are interesting in their own right, and will be developed further in future work.
We shall introduce a novel version of AJM games [10] which has a notion of justiﬁer, which will be used in the modelling of the access control constraints. This notion plays an important rˆole in HO-games [25], the other main variant of game semantics, but it assumes a much simpler form in the present setting (in particular, no pointers are needed). This is a first step in the development of a common framework which combines the best features of both styles of game semantics.
We also achieve a considerable simplification of the treatment of strategies in AJM games. In particular, we eliminate the need for an “intensional equivalence” on strategies [10].
The further contents of the paper are as follows. In Section 2, we develop our variant of AJM games. In Section 3, we describe the games model for access control. We give a semantic treatment of non-interference theorems in Section 4. The relation to syntax is discussed briefly in Section 5. Finally, in Section 6 we conclude with a discussion of directions for future work.

Justified AJM Games
In this section, we shall introduce a minor variant of AJM games [10] which will provide a basis for our semantics of access control, while yielding a model of Intu-

itionistic Linear Logic and related languages isomorphic to that given by the usual AJM games.
We wish to refine AJM games by introducing a notion of justifying move. A clear intuition for this notion can be given in terms of procedural control-flow. A call of procedure P will have as its justifier the currently active call of the procedure in which P was (statically) declared. Thus the justifier corresponds to the link in the “static chain” in compiler terminology for ALGOL-like languages [13]. A top- level procedure call will have no justifier — it will be an “initial action”. Finally, a procedure return will have the corresponding call as its justifier.
In AJM games, moves are classified as questions or answers, and equating pro- cedure calls with questions and returns with answers, we get the appropriate notion of justifier for games.
The notion of justifier plays a central rˆole in Hyland-Ong (HO) games [25]. In that context, the identification of the justifier of a move in a given play involves an additional structure of “justification pointers”, which are a considerable complica- tion. The need for this additional structure arises for two reasons:
Firstly, the treatment of copying in HO games allows multiple occurrences of the same move in a given play. This means that extra structure is required to identify the “threads” corresponding to the different copies. By contrast, plays in AJM games are naturally linear, i.e. moves only occur once, with the threads for different copies indicated explicitly.
The other source of the need for explicit indication of justifiers in plays is that the justification or enabling relation is in general not functional in HO games; a given move may have several possible justifiers, and we must indicate explicitly which one applies. In fact, in the original version of HO games [25], justification was functional; the relaxation to more general enabling relations was introduced later for convenience [32], given that in the HO format, justification pointers were going to be used anyway.
It turns out that unique justifiers can be defined straightforwardly in AJM games; the only change which is required is a minor one to the definition of linear implication. This follows the device used in [25] to preserve the functionality of justification.
Given that we have both linearity of plays and unique justifiers, we get a very simple, purely “static” notion of justification which is determined by the game, and requires no additional information at the level of plays. The resulting notion of AJM games is equivalent to the standard one as a model of ILL, but carries the additional structure needed to support our semantics for access control.
We shall now proceed to describe the category of justified AJM games. Since a detailed account of the standard AJM category can be found in [10] and the differences are quite minor, we shall only provide a brief outline, emphasizing the points where something new happens.

The Games
A game is a structure A = (MA, λA, jA, PA, ≈A), where
MA is the set of moves.
λA : MA → {P, O}× {Q, A} is the labelling function.
The labelling function indicates if a move is by Player (P) or Opponent (O), and if a move is a question (Q) or an answer (A). The idea is that questions correspond to requests for data or procedure calls, while answers correspond to data (e.g. integer or boolean values) or procedure returns. In a higher-order context, where arguments may be functions which may themselves be applied to arguments, all four combinations of Player/Opponent with Question/Answer are possible. Note that λA can be decomposed into two functions λPO : MA → {P, O}
and λQA : MA → {Q, A}.
We write
{P, O}× {Q, A} = {PQ,PA, OQ, OA}
M P = λ−1({P }× {Q, A}),	M O = λ−1({O}× {Q, A})
A	A	A	A
M Q = λ−1({P, O}× {Q}),	M A = λ−1({P, O}× {A})

A	A
and define
A	A


P = O, O = P,

λPO(a)= λPO(a),  λA = ⟨λPO, λQA⟩.
A	A	A	A
The justification function jA : MA ~ MA is a partial function on moves satisfying the following conditions:
For each move m, for some k > 0, jk (m) is undefined, so that the forest of justifiers is well-founded. A move m such that jA(m) is undefined is called initial ; we write InitA for the set of initial moves of A.
P -moves must be justified by O-moves, and vice versa; answers must be justified by questions.

Let M ③
be the set of all finite sequences s of moves satisfying the following

conditions:
(p1) Opponent starts If s is non-empty, it starts with an O-move.
(p2) Alternation Moves in s alternate between O and P.
(p3) Linearity Any move occurs at most once in s.
(p4) Well-bracketing Write each answer a as )a and the corresponding ques- tion q = jA(a) as (a. Define the set W of well-bracketed strings over A induc- tively as follows: ε ∈ W ; u ∈ W ⇒ (a u )a ∈ W ; u, v ∈ W ⇒ uv ∈ W . Then we require that s is a prefix of a string in W .
(p5) Justification If m occurs in s, s = s1ms2, then the justifier jA(m) must occur in s1.
Then PA, the set of positions of the game, is a non-empty prefix-closed subset of M ③.
The conditions (p1)–(p5) are global rules applying to all games.

≈A is an equivalence relation on PA satisfying
(e1) s ≈A t =⇒ λ٨ (s)= λ٨ (t)
A	A




Here λ٨
(e2) s ≈A t, s' ± s, t' ± t, |s'| = |t'| =⇒ s' ≈A t'
(e3) s ≈A t, sa ∈ PA =⇒ ∃b. sa ≈A tb.
is the extension of λA to sequences; while ± is the prefix ordering. Note

in particular that (e1) implies that if s ≈A t, then |s| = |t|.
If we compare this definition to that of standard AJM games, the new component is the justification function jA. This allows a simpler statement of the well-bracketing condition. The new conditions on plays are Linearity and Justification. These hold automatically for the interpretation of ILL types in AJM games as given in [10].
Constructions
We now describe the constructions on justified AJM games corresponding to the ILL connectives. These are all defined exactly as for the standard AJM games in [10], with justification carried along as a passenger and defined in the obvious componentwise fashion, with the sole exception of linear implication.
Times We define the tensor product A⊗B as follows.
MA⊗B = MA + MB, the disjoint union of the two move sets.
λA⊗B = [λA, λB], the source tupling.
jA⊗B = jA + jB.
PA⊗B = {s ∈ M ③	| sTA ∈ PA ∧ sTB ∈ PB}.
s ≈A⊗B t iff sTA ≈A tTA ∧ sTB ≈B tTB ∧ out٨(s)= out٨(t).
Here out : Σi∈I Xi → I :: (x ∈ Xi) '→ i maps an element of a disjoint union to the index of its summand. Concretely in this case, out(m) is 1 if m ∈ MA, and 2 if m ∈ MB. Note that there is no need to formulate a ‘stack condition’ explicitly as
in [10], since this is implied by the component-wise definition of the justification function.
Tensor Unit  The tensor unit is given by
I = (∅, ∅, ∅, {ϵ}, {(ϵ, ϵ)}).
Additive Conjunction The game A & B is defined as follows.
MA & B = MA + MB
λA & B = [λA, λB] jA⊗B = jA + jB PA & B = PA + PB
≈A & B = ≈A + ≈B .
Bang The game !A is defined as the “infinite symmetric tensor power” of A. The symmetry is built in via the equivalence relation on positions.
M!A = ω × MA =  i∈ω MA, the disjoint union of countably many copies of the moves of A. So, moves of !A have the form (i, m), where i is a natural number, called the index, and m is a move of A.

Labelling is by source tupling:
λ!A(i, a)= λA(a).

Justification is componentwise: j!A(i, m)= (i, jA(m)).
We write sTi to indicate the restriction to moves with index i.
P!A = {s ∈ M ③ | (∀i ∈ ω) sTi ∈ PA} .
Let S(ω) be the set of permutations on ω.
s ≈!A t ⇐⇒ (∃π ∈ S(ω))[(∀i ∈ ω. sTi ≈A tTπ(i)) ∧ (π ◦ fst)∗(s)= fst∗(t)].
Linear Implication The only subtlety arises in this case. The justifier of an initial move in A played within A  B should be an initial move in B; but which one? To render this unambiguous, we make a disjoint copy of the moves in A for each
initial move in B. A similar device is used in [25]. We write Σb∈InitB MA for this disjoint union of copies of MA, which is equivalently defined as InitB × MA.
MA  B = (Σb∈InitB MA)+ MB.
λA  B = [[λA | b ∈ InitB], λB].
We define justification by cases. We write mb, for m ∈ MA and b ∈ InitB, for the b-th copy of m.


jA  B
(m ) = ⎧⎨ b,	m ∈ InitA

⎩ (jA(m))b, m /∈ InitA
jA  B(m) = jB(m),	m ∈ MB .
We write sTA to indicate the restriction to moves in Σb∈InitB MA, replacing each
mb by m.

PA  B = {s ∈ M ③
| sTA ∈ PA ∧ sTB ∈ PB}

Note that Linearity for A implies that only one copy mb of each m ∈ MA can occur in any play s ∈ PA B.
s ≈A  B t iff (∀b ∈ InitB) sTA, b ≈A tTA, b ∧ sTB ≈B tTB ∧ out٨(s)= out٨(t). Note that, by (p1), the first move in any position in PA  B must be in B.


Basic Types
Given a set X, we define the flat game Xb over X as follows:
MXb = {q0} + X
λXb (q0)= OQ, λXb (x)= PA for x ∈ X.
jXb (q0) is undefined (so q0 is initial); jXb (x)= q0.
Plays in Xb are prefixes of sequences q0x, x ∈ X.
The equivalence ≈Xb is the identity relation.
For example, we obtain a game Natb for the natural numbers.

Strategies
Our aim is to present a reformulation of strategies for AJM games, which is equiv- alent to the standard account in [10], but offers several advantages:
A major drawback of AJM games is that strategies must be quotiented by an equivalence to obtain a category with the required structure. This is workable, but lacks elegance and impedes intuition. This problem is completely eliminated here: we present a notion of strategy which is ‘on the nose’, without any quotient.
At the same time, the existing notions are related to the new approach, and the standard methods of defining AJM strategies can still be used.
Although we shall not elaborate on this here, the order-enriched structure of strategies is vastly simplified, since the ordering is now simply subset inclusion.
The idea of using strategies saturated under the equivalence relation on plays can be found in [14]; but that paper concerned a ‘relaxed’ model, which could be used for Classical Linear Logic, and did not establish any relationship with the standard AJM notions.
Definition 2.1 A strategy on a game A is a non-empty set σ ⊆ P even of even-length
plays satisfying the following conditions:
Causal Consistency sab ∈ σ =⇒ s ∈ σ
Representation Independence s ∈ σ ∧ s ≈A t =⇒ t ∈ σ
Determinacy sab, ta'b' ∈ σ ∧ sa ≈A ta' =⇒ sab ≈A ta'b'.
To relate this to the usual notion of AJM strategies, we introduce the notion of
skeleton.
Definition 2.2 A skeleton of a strategy σ is a non-empty causally consistent subset
φ ⊆ σ which satisfies the following condition:
Uniformization ∀sab ∈ σ. s ∈ φ =⇒ ∃!b'. sab' ∈ φ.
Note that the play sab' whose existence is asserted by Uniformization satisfies:
sab ≈A sab'. This follows immediately from φ ⊆ σ and Determinacy.
Proposition 2.3 Let φ be a skeleton of a strategy σ. Then φ satisﬁes the following properties:
Functional Determinacy: sab, sac ∈ σ =⇒ b = c
Functional Representation Independence:
sab ∈ φ ∧ t ∈ φ ∧ sa ≈A ta' =⇒ ∃!b'. ta'b' ∈ φ ∧ sab ≈A ta'b'.
Proof.
Functional Determinacy. If sab, sac ∈ φ, then sab ∈ σ and s ∈ φ. By Uniformiza- tion, the b such that sab is in φ is unique, so b = c.
Functional Representation Independence. Suppose that sab ∈ φ, t ∈ φ, sa ≈A ta'. Then sab ∈ σ, and by (e3), for some b'', sab ≈A ta'b''. By Representation

Independence, ta'b'' ∈ σ. By Uniformization, for some unique b', ta'b' ∈ φ, and by the remark after the definition of skeleton, sab ≈A ta'b'.
Hence we conclude.	 
Definition 2.4 We shall define a skeleton more generally — independently of any strategy — to be a non-empty, causally consistent set of even-length plays, satisfying Functional Determinacy and Functional Representation Independence.
Note that a skeleton φ is exactly the usual notion of AJM strategy such that
φ и φ [10].
Given a skeleton φ, we define φ• = {t | ∃s ∈ φ. s ≈A t}.
Proposition 2.5 If φ is a skeleton, then φ• is a strategy, and φ is a skeleton of
φ•.
Proof. We verify the conditions for φ• to be a strategy.
Causal Consistency. If ta'b' ∈ φ•, then for some sab ∈ φ, sab ≈A ta'b'. Since φ is causally consistent, s ∈ φ, and s ≈A t, hence t ∈ φ•.
Representation Independence. If t ≈A s ∈ φ and u ≈a t, then u ≈A s, and hence
u ∈ φ•.
Determinacy. Suppose sab, ta'b' ∈ φ•. This means that sab ≈A s1a1b1 ∈ φ, and ta'b' ≈A s2a2b2 ∈ φ. Now sa ≈A ta' implies that s1a1 ≈A s2a2. By Functional Determinacy and Functional Representation Independence, s1a1b1 ≈A s2a2b2. Hence sab ≈A ta'b', as required.
Now we verify that φ is a skeleton of φ•, i.e. that Uniformization holds. Suppose that sab ∈ φ• and s ∈ φ. By Functional Representation Independence, there is a unique b' such that sab' ∈ φ and sab ≈A sab'. By Functional Determinacy, this is the unique b' such that sab' ∈ φ.	 
Proposition 2.6 If φ is a skeleton of σ, then φ• = σ.
Proof. Certainly φ• ⊆ σ by Representation Independence. We prove the converse by induction on the length of s ∈ σ. The basis case for ε is immediate. For sab ∈ σ, by induction hypothesis s ∈ φ•. Hence for some s' ∈ φ, s ≈A s'. We can find a', b' such that sab ≈A s'a'b'. By Representation Independence, s'a'b' ∈ σ. By Uniformization, for some b'', s'a'b'' ∈ φ, where s'a'b' ≈A s'a'b''. Hence sab ∈ φ•. 
Corollary 2.7 φ is a skeleton of σ if and only if φ is a skeleton, and φ• = σ.
Proposition 2.8 Every strategy σ has a skeleton φ.
Proof. We define a family of sets of plays φk by induction on k. φ0 = {ε}. To define φk+1, for each s ∈ φk and a ∈ M O, consider the set Xs,a of all plays in σ of the form sab for some b. Note that (s, a) /= (s', a') implies that Xs,a ∩ Xs',a' = ∅. Let C be the family of all non-empty Xs,a. Then φk+1 is a choice set for C which
selects exactly one element of each member of C. Finally, define φ = k∈ω φk. It is immediate from the construction that φ is a skeleton for σ.	 

We now recall the definition of the preorder on skeletons (standard AJM strate- gies) from [10]:
φ и ψ ≡ sab ∈ φ, s' ∈ ψ, sa ≈ s'a' =⇒ ∃b'. [s'a'b' ∈ ψ ∧ sab ≈ s'a'b'].
Proposition 2.9 For skeletons φ, ψ on A: φ и ψ iff φ• ⊆ ψ•.
Proof. Suppose firstly that φ• ⊆ ψ•, and that sab ∈ φ, t ∈ ψ, sa ≈A ta'. Then sab ∈ ψ•, so there is some s1a1b1 ∈ ψ with s1a1b1 ≈A sab. Then s1a1 ≈A ta', so by Functional Representation Independence, there exists a unique b' such that ta'b' ∈ ψ, and ta'b' ≈A s1a1b1 ≈A sab. Thus φ и ψ, as required.
For the converse, we assume that φ и ψ. It is sufficient to prove that φ ⊆ ψ•, which we do by induction on the length of plays in φ. The base case is immediate.
Now suppose that sab ∈ φ. By induction hypothesis, s ∈ ψ•. Then for some
s' ∈ ψ, s ≈A s'. For some a', s'a' ≈A sa. Since φ и ψ, there exists b' such that

' ' '
' ' '	•	≈

s a b
∈ ψ ∧ sab ≈ s a b . But then sab ∈ ψ , as required.	 

We can now obtain a rather clear picture of the relationship between partial equivalence classes of strategies as in [10], and strategies and their skeletons in the present formulation.
Proposition 2.10 For any strategy σ:
Any two skeletons of σ are equivalent.
σ =  {φ | φ is a skeleton on σ}.
For any skeleton φ of σ: σ =  {ψ | ψ ≈ φ}.
Proof. 1. If φ, ψ are skeletons of σ, by Proposition 2.6 φ• = ψ•, hence by Propo-
sition 2.9, φ и ψ and ψ и φ.
≈	≈
The right-to-left inclusion is clear. For the converse, given any s ∈ σ, we can
guide the choices made in the construction of φ in the proof of Proposition 2.8 to ensure that s ∈ φ.
The right-to-left inclusion follows from Proposition 2.9. The converse follows from part 2, Corollary 2.7, and Proposition 2.9.	 
Finally, we show how history-free strategies, which play an important roˆle in AJM game semantics, fit into the new scheme. We define a strategy to be history- free if it has a skeleton φ satisfying the following additional conditions:
sab, tac ∈ φ =⇒ b = c
sab, t ∈ φ, ta ∈ PA =⇒ tab ∈ φ.
As in [10], a skeleton is history-free if and only if it is generated by a function on moves.

Constructions on strategies
In the light of these results, we can define a strategy σ by defining a skeleton
φ and then taking σ = φ•. In particular, this is the evident method for defining

history-free strategies. Thus all the constructions of particular strategies carry over directly from [10].
What of operations on strategies, such as composition, tensor product etc.? We can define an operation O on strategies via an operation Osk on skeletons as follows. Given strategies σ, τ , we take skeletons φ of σ and ψ of τ , and define
O(σ, τ )= Osk(φ, ψ)•.
Of course, this definition should be independent of the choice of skeletons.
Proposition 2.11 An operation O ‘deﬁned’ in terms of Osk as above is well-deﬁned and monotone with respect to subset inclusion if and only if Osk is monotone with respect to и.
Proof. Suppose that Osk is monotone with respect to и and that we are given

'	'	'	'
' ≈  '

σ ⊆ σ , τ ⊆ τ , and skeletons φ of σ, φ of σ , ψ of τ , ψ
of τ . By Proposition 2.9,

φ и φ' and ψ и ψ'. Then Osk(φ, ψ) и Osk(φ', ψ'), and so, using Proposition 2.9 again,
≈	≈	≈
O(σ, τ )= Osk(φ, ψ)• ⊆ Osk(φ', ψ')• = O(σ',τ ').
Note that, taking σ = σ' and τ = τ ', this also shows that O is well-defined.
Conversely, suppose that O is well-defined and monotone, and consider φиφ', ψиψ'.

•	'	'•
•	'	'•
'  ≈	≈ '

Let σ = φ , σ
Then
= φ , τ = ψ , τ
= ψ . By Proposition 2.9, σ ⊆ σ
and τ ⊆ τ .

Osk(φ, ψ)• = O(σ, τ ) ⊆ O(σ',τ ')= Osk(φ', ψ')•
so by Proposition 2.9, Osk(φ, ψ) и Osk(φ', ψ').	 
Thus again, all the operations on strategies from [10] carry over to the new scheme.
Categories of Games
We build a category G:
Objects : Justified AJM Games
Morphisms : σ : A → B ≡ strategies on A  B.


Copy-Cat
The copy-cat strategy [9] is defined by:
idA = {s ∈ P even



| sT1 ≈A sT2}.


Composition
We need a slight modification of the definition of composition as given in [9,10], to fit the revised definition of linear implication. Suppose we are given σ : A → B and τ : B → C. We define:

٨
(A  B)  C
| sTA, B ∈ σ ∧ sTB, C ∈ τ }

σ; τ = {sTA, C | s ∈ σ τ } .

Note that
M(A  B)  C = (Σc∈InitC (Σb∈InitB MA)+ MB)+ MC
∼= Σc∈InitC (Σb∈InitB MA) + Σc∈InitC MB + MC
so we can regard sTB, C as a play in B  C. Similarly, sTA, B, where we erase all tags from C, can be regarded as a play in A  B. Finally, sTA, C, where all tags from B are erased, so that (mb)c is replaced by mc, can be regarded as a play in A  C. This last transformation, erasing tags in B, corresponds to the elision of justification pointers in the definition of composition for HO games [25].
Proposition 2.12 G equipped with composition of strategies, and with the copy-cat strategies idA : A → A as identities, is a category. There is also a sub-category Ghf of history-free strategies.
The further development of these categories as models of ILL proceeds exactly as in [10]. The main point to note is that monoidal closure still works, in exactly the same way as in [10]. Indeed, we have an isomorphism
(A ⊗ B)  C ∼= A  (B  C) induced concretely by the bijection on moves
M(A⊗B)  C = Σc∈InitC (MA + MB)+ MC
∼= Σc∈InitC MA + (Σc∈InitC MB + MC)
= MA  (B  C)
since the initial moves in B  C are just those in C. Since arrows are defined as strategies on the internal hom, this immediately yields the required adjunction
G(A ⊗ B, C) ∼= G(A, B  C).
The monoidal structure for ⊗ is witnessed similarly by copy-cat strategies induced by bijections on move sets, as in [9]. Thus we get a symmetric monoidal closed (SMC) category (G, ⊗,I,  ), with an SMC sub-category Ghf.
Next we note that there are natural transformations
ϵA : !A → A,	δA : !A → !!A
and a functorial action for ! which endow it with the structure of a comonad. The counit ϵ plays copycat between A and one fixed index in !A, while the comultipli- cation δ uses a pairing function
p : ω × ω > ω
to play copycat between pairs of indices in !!A and indices in !A. The functorial action !σ : !A → !B simply plays σ componentwise in each index. The coding- dependence in these constructions is factored out by the equivalence ≈.
The co-Kleisli category K!(G) for this comonad has arrows !A → B, with identities given by the counits ϵA. Composition is defined via promotion: given σ :!A → B, we define
σ† = δA; !σ : !A → !B.

The Kleisli composition of σ with τ :!B → C is then σ†; τ : !A → C.
The additive conjunction is the product in the coKleisli category, while I is the terminal object. There are exponential isomorphisms
!(A & B) ∼= !A ⊗ !B,	!I ∼= I.
This ensures that the coKleisli category is cartesian closed: defining A ⇒ B = !A 
B, we have
K!(G)(A & B, C) = G(!(A & B), C)
∼= G(!A ⊗ !B, C)
∼= G(!A, !B  C)
= K!(G)(A, B ⇒ C).
Thus we have a symmetric monoidal closed category (G, ⊗,I, ) and a cartesian closed category (K!(G), & ,I, ⇒). There is, automatically, an adjunction between G and its coKleisli category K!(G). This adjunction is moreover monoidal by virtue of the exponential isomorphisms. This provides exactly the required structure for a model of ILL [16,31]. Moreover, all this structure cuts down to the history-free strategies. The interpretation of the ILL type theory lives inside the history-free sub-category Ghf.

The Model
We shall now show how a simple refinement of the games model leads to a semantics for access control.
We shall assume as given a security semilattice (L, H, ⊥), where H is the binary join, and ⊥ the least element. The partial order on the semilattice is defined by
l ≤ l' ≡ l H l' = l'.
We shall now form a category GL, with a history-free sub-category Ghf, as follows.
The objects of GL have the form
A = (MA, λA, jA, PA, ≈A, levA)
where (MA, λA, jA, PA, ≈A) is a justified AJM game, and levA : MA → L assigns a security level to each move of the game. This additional piece of structure is carried through the type constructions in the simplest componentwise fashion:
levA⊗B = levA&B = [levA, levB],	lev !A = [levA | i ∈ ω]
levA  B = [[levA | b ∈ InitB], levB].
The remainder of the definition of GL goes exactly as for G, with a single additional condition on plays in the definition of M ③:
(p6) Levels A non-initial move m can only be played if levA(m) ≤ levA(jA(m)).
This constraint has a clear motivation, reflecting the basic intuition for access con- trol: a principal can only affirm a proposition at its own level of authorization based

on assertions made at the same level or higher. In terms of control flow (where the lattice has the opposite interpretation): a procedure can only perform an action at its own security level or lower.
Note that formally, this is a purely static constraint: it is used to discard certain moves (actions) at the level of the game (type), and independent of any particular play (run) or strategy (term). This is remarkably simple, yet as we shall see, it suffices to soundly model the formal properties of the type theories which have been proposed for access control.
The content of this constraint is essentially the same as that described at a more concrete level in [30]. 5 What we have achieved here is to express this in a general, compositional form at the level of the semantic model. This allows general non-interference results to be proved, whereas the focus in [30] is on static analysis of specific programs.
Level Monads
For each AJM game A and l ∈ L, there is a game Al in GL with levA(m) = l for all m ∈ MA. Note that, fixing l, the assignment A '→ Al defines a full and faithful embedding of G in GL. The interesting structure of GL as a model for access control arises when there are moves at different levels.
We now define, for each l ∈ L, a construction Tl on games. This acts only on the level assignment, as follows:
levTÆA(m)= levA(m) H l.
All other components of A remain unchanged in TlA. Note in particular that PTÆA = PA. We must check that the Level condition (p6) is satisfied by plays s ∈ PA with respect to levTÆA. This holds since s satisfies (p6) with respect to levA, and
l1 ≤ l2 ⇒ l1 H l ≤ l2 H l.
The following commutation properties of Tl are immediate.
Proposition 3.1 The following equations hold:
TlI	= I
Tl(A ⊗ B) = TlA ⊗ TlB Tl(A  B) = TlA  TlB Tl(A & B) = TlA & TlB Tl !A	= !TlA
Tl(A ⇒ B) = TlA ⇒ TlB
The semilattice structure on L acts on the L-indexed family of monads in the evident fashion:

5 This connection was pointed out to us by one of the referees.

Proposition 3.2 The following equations hold:
Tl(Tl' A) = TlHl' A T⊥A	= A.
We can extend each Tl with a functorial action: if σ : A → B then we can define
Tlσ : TlA → TlB simply by taking Tlσ = σ. To justify this, note that
PA  B = PTÆ(A  B) = PTÆA  TÆB ,
using Proposition 3.1. Hence σ is a well-defined strategy for TlA  TlB. Proposition 3.3 The copy-cat strategy is well deﬁned on A  TlA. Proof. Consider a play of the copy-cat strategy
A   TlA
.	.
O	m1
P m1
O m2
P	m2
which we write as s = s1m' m''m''m' . If m1 is initial, levA(m1) ≤ levT A(m1), so the
1  1	2	2	Æ

Level condition holds for m''. If m1 is non-initial, by Justification m'
is preceded

1	1
by its justifier m in sTTlA. Since sTTlA ∈ PT A = PA, levA(m1) ≤ levA(m), so m''
Æ	1
satisfies the Level condition in this case as well. Finally,
levA(m2) ≤ levA(jA(m2)) ⇒ levTÆA(m2) ≤ levTÆA(jA(m2))
so m' satisfies the Level condition.	 
Thus we can define a natural transformation
ηA : A → TlA
where ηA is the copy-cat strategy. Furthermore, by Proposition 3.2, TlTlA = TlA. Thus we obtain:
Proposition 3.4 Each Tl is an idempotent commutative monad.
A similar argument to that of Proposition 3.3 yields the following:

Proposition 3.5 If l ≤ l', then there is a natural transformation ιl,l'
: TlA →

Tl' A, where each component is the copy-cat strategy.
Non-Interference  Results
We now turn to the most important aspect of our semantics; the basis it provides for showing that certain kinds of data-access which would violate the constraints imposed by the security levels cannot in fact be performed.

Firstly, we prove a strong form of converse of Proposition 3.5.
Proposition 4.1 If ¬(l ≤ l'), then there is no natural transformation from Tl to
Tl' .
Proof. Suppose for a contradiction that there is such a natural transformation τ .
Given any flat game Xb , with lev b (m)= ⊥ for all moves m ∈ M b , the strategy
⊥	X⊥	X⊥
τ  b  : TlXb → Tl' Xb can only play in Tl' Xb , since playing the initial move in TlXb
X⊥	⊥	⊥	⊥	⊥
would violate the Level condition.
For readability, in the remainder of the proof we let A = Natb . Now consider

the naturality square
T A	τA ) T ' A



Tlσ
v
Tl' σ
v

TlA 	) Tl' A τA
Since τA can only play in Tl' A, for all σ, σ' : A → A we have Tlσ; τA = Tlσ'; τA, and hence τA; Tl' σ = τA; Tl' σ' by naturality. Recall that Tl' σ = σ. But we can take σ = {ε, q00}, σ' = {ε, q01}, and q00 ∈ τA; Tl' σ \ τA; Tl' σ', yielding the required contradiction.	 
The key step in the above argument was to show that control could not flow

back from Tl' Xb
to the “context” TlXb
because its security level l is not below l'.

We shall now extend this idea into an important general principle for the semantic
analysis of access control.
The No-Flow Theorem
Consider the following situation. We have a term in context Γ ▶ t : T , and we wish to guarantee that t is not able to access some part of the context. For example, we may have Γ = x : U, Γ', and we may wish to verify that t cannot access x. Rather than analyzing the particular term t, we may wish to guarantee this purely
at the level of the types, in which case it is reasonable to assume that this should be determined by the types U and T , and independent of Γ'.
This can be expressed in terms of the categorical semantics as follows. Note
that the denotation of such a term in context will be a morphism of the form
f : A ⊗ C → B, where A = U ), C = Γ'), B = T ).
Definition 4.2 Let C be an affine category, i.e. a symmetric monoidal category in which the tensor unit I is the terminal object. We write TA : A → I for the unique arrow. We define A /→ B if for all objects C, and f : A ⊗ C → B, f factors as
TA⊗id&	∼=	g
f = A ⊗ C 	) I ⊗ C   ) C   ) B.
The idea is that no information from A can be used by f — it is “constant in A”. Note that GL and Ghf are affine, so this definition applies directly to our situation.

Firstly, we characterize this notion in GL and Ghf .

Lemma 4.3 In GL and Ghf , A /→ B if and only if, for any strategy σ : A ⊗ C → B, σ does not play any move in A.

Proof. This reduces to verifying that σ factors if and only if it plays no move in A. Certainly, if it factors it plays no move in A, since any such move in the composition must be preceded by one in I, which has none. Conversely, if it plays no move in A, then it is well-defined as a strategy σ : C → B, and so it essentially factors through itself.	 


We now give a simple characterization for when this “no-flow” relation holds between games.
Given a game A, we define:
Level(A) = {levA(m) | m ∈ InitA}
A D B	≡ ∀l ∈ Level(A), l' ∈ Level(B). ¬(l ≤ l')

Theorem 4.4 (No-Flow) For any games A, B in GL:
A /→ B  ⇐⇒ A D B.


Proof. If A D B, then any strategy σ : A ⊗ C → B cannot play a move in A. The first such move would be an initial move in A, which would be justified by an initial move in B, and this would violate the Level condition since A D B.
Conversely, suppose there are initial moves m in A and m' in B such that levA(m) ≤ levB(m'). Then for any C, σ = {ε, m'm} is a strategy σ : A ⊗ C → B which moves in A.	 




Computing Levels
The characterization of no-flow in terms of the levels of types means that we can obtain useful information by computing levels.
We consider a syntax of types built from basic types (to be interpreted as flat games at a stipulated level) using the connectives of ILL extended with the level monads. For any such type T , we can give a simple inductive definition of Level(A)

where A = T ):
Level(Xb)	= {l}
Level(I)	= ∅
Level(A ⊗ B) = Level(A) ∪ Level(B)
Level(A  B) = Level(B)
Level(A & B)  = Level(A) ∪ Level(B)
Level(A ⇒ B) = Level(B) Level(!A)	= Level(A)
Level(TlA)	= {l H l' | l' ∈ Level(A)}
This yields a simple, computable analysis which by Theorem 4.4 can be used to guarantee access constraints of the kind described above.
Protected Types
We give a semantic account of protected types, which play a key roˆle in the DCC type system [3].
Definition 4.5 We say that a game A is protected at level l if Level(A) ≥ l, meaning that l' ≥ l for all l' ∈ Level(A).
This notion extends immediately to types via their denotations as games.
The following (used as an inductive definition of protection in [3,1]) is an imme- diate consequence of the definition.
Lemma 4.6	(i) If l ≤ l', then Tl' A is protected at level l.
If B is protected at level l, so are A  B and A ⇒ B.
If A and B are protected are level l, so are A & B and A ⊗ B.
If A is protected at level l, so is !A.
I is protected at level l.
We also have the following protected promotion lemma, which shows the sound- ness of the key typing rule in DCC [3].
Lemma 4.7 If σ : !A → TlB, τ : !B → C, and C is protected at level l, then the coKleisli composition


is well-deﬁned.
σ†; τ : !A → C

Proof. Firstly, by Proposition 3.1, Tl !B = !TlB. So it suffices to show that τ is well-defined as a strategy τ : Tl !B → C. If we consider an initial move m in Tl !B played by τ , we must have lev !B(m) ≤ lev(j(m)) since τ : !B → C is well-defined. Moreover, l ≤ lev(j(m)) since C is protected at l. Hence levTÆ !B(m) ≤ lev(j(m)). 

Stability Under Erasure
We now give a semantic version of the main result in [1] (Theorem 7.6), which shows stability of the type theory under erasure of level constraints. This is used in [1] to derive several other results relating to non-interference.
Firstly, given l ∈ L, we define the erasure Al of a type A, which replaces every sub-expression of A of the form Tl' B, with l' ≥ l, by T. Semantically, this corresponds to erasing all moves m in the game (denoted by) A such that lev(m) ≥ l,
and all plays containing such moves.
Abadi’s result is that, if we can derive a typed term in context Γ ▶ e : A, then we can derive a term Γl ▶ e' : Al. To obtain an appropriate semantic version, we need to introduce the notion of total strategies. A strategy σ is total if when
s ∈ σ, and sa ∈ PA, then sab ∈ σ for some b. This is the direct analogue of totality for functions, and will hold for the strategies denoted by terms in a logical type theory — although not in general for terms in a programming language equipped with general recursion. One can show that total strategies which are ﬁnite (or alternatively winning ) in a suitable sense form a category with the appropriate structure to model intuitionistic and linear type theories [5,24].
Theorem 4.8 Suppose that σ : A → B is a total strategy. Then so is σ' : Al → Bl
for any l ∈ L, where σ' is the restriction of σ to plays in Al  Bl.
Proof. Suppose for a contradiction that σ' is not total, and consider a witness sab ∈ σ \ σ', with sa ∈ PAÆ BÆ . Then lev(b) ≥ l; but by the Level constraint, we must have lev(j(b)) ≥ l, which by the Justification condition contradicts sa ∈ PAÆ BÆ .	 

Semantic vs. Syntactic Non-Interference
Our primary emphasis in this paper is on a semantic approach to access control, and we have proved semantic versions of a number of non-interference results. A detailed analysis of how these relate to the results proved by syntactic and proof- theoretic means for calculi such as DCC would take us too far afield. However, we shall provide an illustrative example of how semantic non-interference results can be used to obtain results about syntactic calculi.
For a simple and paradigmatic example, we consider a core fragment of DCC, obtained by extending the simply-typed λ-calculus with the level monads. There are two typing rules associated with the monads:

Γ ▶ e : A


Γ ▶ ηle : A
Γ ▶ e : TlA	Γ,x : A ▶ e' : B
Γ ▶ bind x = e in e' : B	B is protected at level l

The term rewriting rules, in addition to the usual β-reduction and η-expansion, are
ηle −→ e	bind x = e in e' −→ e'[e/x]
Thus the normal forms in this term calculus will be the usual long βη-normal forms of the simply typed λ-calculus. We say that a proof uses an assumption x : A if the term corresponding to the proof contains x free in its normal form.

It follows from the results in Section 3 that our game semantics provides a sound model for this calculus. We have the following simple result.
Proposition 5.1 Let Γ,x : A ▶ t : B be a term in context of core DCC, where t is in long βη-normal form. Then x occurs free in t if and only if the strategy it denotes moves in A).
Proof. Given an occurrence of x as a head variable in some sub-term of t, we can construct a play with appropriate choices of O-moves, which will “activate” this variable, whose denotation plays a copy-cat strategy with the occurrence of x in the context, thus generating a move in A as required. The converse is easily shown by induction on normal forms.	 
Combining this with Lemma 4.3 and the No-Flow Theorem 4.4, we immediately obtain:
Proposition 5.2 If A D B, any derivation of Γ,x : A ▶ t : B cannot use the assumption x : A.
Suitable adaptations of this argument to other type theories will yield corre- sponding non-interference results.

Further Directions
We have shown that Game Semantics provides a natural setting for the semantic analysis of access control. There are many further directions for this work:
We have considered a semantic setting which is adequate for both intuitionistic and (intuitionistic-)linear type theories. It would also be interesting to look at access control in the context of classical type theories such as λμ [37], particularly since it is suggested in [1,20] that there are problems with access control logics in classical settings. There have been some studies of game semantics for classical type theories [36,28]. It would be of considerable interest to see if our approach could carry over to the classical case.
There are a number of other natural extensions, such as to polymorphic types.
It would also be of interest to develop the applications to dependency analysis for programming languages. The same game semantics framework provides a common basis for this and the study of logical type theories.
The development of algorithmic game semantics [21,6,34,35], including several implemented verification tools [15,17,29], suggests that it may be promising to look at automated analysis based on our semantic approach.
We have developed our semantics in the setting of AJM games, equipped with a notion of justification. One could alternatively take HO-games as the starting point, but these would also have to be used in a hybridized form, with “AJM-like” features, in order to provide models for linear type theories [32]. In fact, one would like a form of game semantics which combined the best features (and minimized

the disadvantages) of the two approaches. Some of the ideas introduced in the present paper may be useful steps in this direction.

References
Mart´ın Abadi. Access control in a core calculus of dependency. In John H. Reppy and Julia L. Lawall, editors, ICFP, pages 263–273. ACM, 2006.
Mart´ın Abadi. Variations in access control logic. In Ron van der Meyden and Leendert van der Torre, editors, DEON, volume 5076 of Lecture Notes in Computer Science, pages 96–109. Springer, 2008.
Mart´ın Abadi, Anindya Banerjee, Nevin Heintze, and Jon G. Riecke. A core calculus of dependency. In POPL, pages 147–160, 1999.
Mart´ın Abadi, Michael Burrows, Butler W. Lampson, and Gordon D. Plotkin. A calculus for access control in distributed systems. ACM Trans. Program. Lang. Syst., 15(4):706–734, 1993.
S. Abramsky. Semantics of Interaction: an introduction to Game Semantics. In Semantics and Logics of Computation, ed. P. Dybjer and A. Pitts, Cambridge University Press 1997, 1–31.
S. Abramsky. Algorithmic game semantics: a tutorial introduction. In: Proof and System-Reliability, Kluwer, 2002.
S. Abramsky, D. R. Ghica, A. S. Murawski, I. D. B. Stark and C.-H. L. Ong. Nominal games and full abstraction for the nu-calculus. In Proceedings LICS 2004, 150–159.
S. Abramsky and K. Honda and G. McCusker. A fully abstract game semantics for general references. In Proceedings LiCS 1998, 334–344.
S. Abramsky and R. Jagadeesan. Games and full completeness for multiplicative linear logic. Journal of Symbolic Logic 59, 543–574, 1994.
S. Abramsky, R. Jagadeesan and P. Malacaria. Full abstraction for PCF. Information and Computation
163, 409–470, 2000.
S. Abramsky and G. McCusker. Linearity, sharing and state. In: P. O’Hearn and R. D. Tennent, eds.
Algol-like languages, pp. 317–348. Birkhauser, 1997.
Natasha Alechina, Michael Mendler, Valeria de Paiva and Eike Ritter. Categorical and Kripke Semantics for Constructive S4 Modal Logic. CSL 2001: 292–307.
A. Appel and M. Ginsburg. Modern Compiler Implementation in C. Cambridge University Press, 1998.
Patrick Baillot, Vincent Danos, Thomas Ehrhard and Laurent Regnier. Believe it or not, AJM’s Games Model is a Model of Classical Linear Logic. LICS 1997: 68–75.
Adam Bakewell and Dan R. Ghica. Game-based safety checking with Mage. SAVCBS 2007: 85–87.
Gavin M. Bierman. What is a Categorical Model of Intuitionistic Linear Logic? TLCA 1995: 78–93.
Aleksandar Dimovski and Ranko Lazic. Compositional software verification based on game semantics and process algebra. STTT 9(1): 37–51 (2007).
Matt Fairtlough and Michael Mendler. An intuitionistic modal logic with applications to the formal verification of hardware. In Leszek Pacholski and Jerzy Tiuryn, editors, CSL, volume 933 of Lecture Notes in Computer Science, pages 354–368. Springer, 1994.
[GA08] Deepak Garg and Mart´ın Abadi. A modal deconstruction of access control logics. In Foundations of Software Science and Computational Structures, 11th International Conference, FOSSACS 2008, Held as Part of the Joint European Conferences on Theory and Practice of Software, ETAPS 2008, Budapest, Hungary, March 29 - April 6, 2008. Proceedings, volume 4962 of Lecture Notes in Computer Science, pages 216–230, 2008.
Deepak Garg, Lujo Bauer, Kevin D. Bowers, Frank Pfenning, and Michael K. Reiter. A linear logic of authorization and knowledge. In Dieter Gollmann, Jan Meier, and Andrei Sabelfeld, editors, ESORICS, volume 4189 of Lecture Notes in Computer Science, pages 297–312. Springer, 2006.
Deepak Garg and Frank Pfenning. Non-interference in constructive authorization logic. 19th IEEE Computer Security Foundations Workshop (CSFW’06), 0:283–296, 2006.
D. R. Ghica and G. McCusker.	Reasoning about idealized algol using regular languages.	In
Proc. ICALP’00, pp. 103–116. 2000. LNCS 1853.

D. R. Ghica and A. S. Murawski. Angelic semantics of fine-grained concurrency. In Proc. FOSSACS’04,
pp. 211–225. 2004. LNCS 2987.
J.-Y. Girard, Linear Logic. Theoretical Computer Science 50(1):1-102, 1987.
J. M. E. Hyland. Game Semantics. In Semantics and Logics of Computation, ed. P. Dybjer and A. Pitts, Cambridge University Press 1997, 131–183.
J. M. E. Hyland and C.-H. L. Ong. On full abstraction for PCF. Information and Computation 163, 285–408, 2000.
Satoshi Kobayashi. Monad as Modality. Theor. Comput. Sci. 175(1): 29–74 (1997).
J. Laird. Full abstraction for functional languages with control. Extended abstract, in Proceedings LICS 1997.
Olivier Laurent. Polarized games. Ann. Pure Appl. Logic 130(1-3): 79–123 (2004).
Axel Legay, Andrzej S. Murawski, Jol Ouaknine and James Worrell. On Automated Verification of Probabilistic Programs. TACAS 2008: 173–187.
Pasquale Malacaria and Chris Hankin. Non-Deterministic Games and Program Analysis: An Application to Security. In Proceedings LICS 1999: 443-452.
Maria Emilia Maietti, Paola Maneggia, Valeria de Paiva and Eike Ritter. Relating Categorical Semantics for Intuitionistic Linear Logic. Applied Categorical Structures 13(1): 1–36 (2005).
Guy McCusker. Games and Full Abstraction for a Functional Metalanguage with Recursive Types. Springer (1998).
Eugenio Moggi. Notions of Computation and Monads, Inf. Comput. 93(1): 55–92 (1991),
A. S. Murawski, C.-H. L. Ong, and I. Walukiewicz. Idealized Algol with ground recursion and DPDA equivalence. In Proc. ICALP’05, pp. 917–929. 2005. LNCS 35
Andrzej S. Murawski and Igor Walukiewicz. Third-Order Idealized Algol with Iteration Is Decidable. FoSSaCS 2005: 202–218.
C.-H. Luke Ong. A Semantic View of Classical Proofs: Type-Theoretic, Categorical, and Denotational Characterizations (Preliminary Extended Abstract). LICS 1996: 230–241.
Michel Parigot. Lambda-Mu-Calculus: An Algorithmic Interpretation of Classical Natural Deduction. LPAR 1992: 190–201.
Nikos Tzevelekos, Full abstraction for nominal general references, in Proceedings LICS 2007, pp. 399– 410.
