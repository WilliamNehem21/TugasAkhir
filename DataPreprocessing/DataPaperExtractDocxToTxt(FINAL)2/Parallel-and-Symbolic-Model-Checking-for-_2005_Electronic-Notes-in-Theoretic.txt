Electronic Notes in Theoretical Computer Science 128 (2005) 125–138 
www.elsevier.com/locate/entcs


Parallel and Symbolic Model Checking for Fixpoint Logic with Chop 1
Martin Lange and Hans Wolfgang Loidl
Institut fu¨r Informatik, University of Munich, Germany Email: {mlange,hwloidl}@tcs.ifi.lmu.de

Abstract
We consider the model checking problem for FLC, a modal fixpoint logic capable of defining non- regular properties. This paper presents a refinement of a symbolic model checker and discusses how to parallelise this algorithm. It reports on a prototype implementation of the algorithm in Glasgow Parallel Haskell (GpH) and its performance on a cluster of workstations.
Keywords: Symbolic Model Checking, Functional Programming.


Introduction
Nowadays, model checking for (temporal) logics is commonly accepted as one of the key methods in verification. A major limitation to the usefulness of model checking for verification purposes is the state space explosion problem. To tackle this problem one employs symbolic methods [3] that work on process descriptions directly and usually achieves better performance there.
The need for efficiency together with facing huge state spaces in relevant applications often leads to the use of logics with little expressive power for model checking tasks. This bears an obvious disadvantage: what if a desired correctness property is not expressible in this logic? This justifies the search for (as efficient as possible) decision procedures for logics with higher expressive power.

1 This work has been partially supported by the EC under the FET proactive initiative on Global Computing as project IST-2001-33149 (MRG).


1571-0661 © 2005 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2004.10.023


A great step on the expressivity ladder regarding temporal logics was made with the introduction of FLC [9], a fixpoint logic that extends the modal µ- calculus with an operator for sequential composition. This gives FLC the power to express non-regular properties like “on every path the number of a’s so far never exceeds the number of b’s” or “something holds on all paths at the same time”.
In this paper we present a symbolic model checking algorithm for FLC, using BDDs, based on the sequential algorithm presented in [5] and discuss how to improve its efficiency through parallelism.
Given that — as opposed to the modal µ-calculus — the semantics of a formula is a function, this opens up new opportunities for parallel evaluations besides the obvious ones of evaluating boolean connectives simultaneously. For instance, fixpoint iterations require to test two functions for equality on a finite set of arguments which can be done in parallel.
The paper reports first runtime results, comparing a sequential and a par- allel version of the symbolic model checker. We use Glasgow Parallel Haskell (GpH) as programming language for three reasons. Firstly, GpH provides an easy means of adding parallelism to an existing sequential algorithm, dele- gating decisions about task distribution etc to the runtime system. Secondly, using a language with functions as first-class citizens makes it easy to ex- press the semantics of FLC formulas, which simply are functions (from sets of states to sets of states). And thirdly, Haskell’s laziness provides locality for the model checking algorithm. Note that — with the semantics living in a function space — a local algorithm is now one that computes only that part of a function that is really needed. Globality in the original sense — computing all the states that have a certain property — is given by the use of BDDs.
For the basic BDD operations we use a tuned C library. We exploit the following language features of GpH: semi-explicit parallelism, for ease of ex- pressing parallel execution; higher-order functions, for naturally expressing the model checking algorithm as a function; the foreign-function-interface (FFI) of Haskell, to incorporate Long’s BDD library [8] that manages its own garbage collected heap.
Related Work
[4] presented a distributed version of a symbolic model checker for the modal µ-calculus. Parallelism is obtained through independent evaluations of sub- formulas — as we do, too — and these tasks are explicitly distributed using state space slicing. Parallelism on the evaluation of sub-formulas seems to be the only possibility to distribute the model checking task for the full modal µ-calculus, a logic involving complex fixpoint formulas.


In case of restricted alternation between fixpoints explicit graph-colouring methods have been employed that benefit from the fact that the model check- ing graph can be partitioned into components that can be dealt with sepa- rately. This method is used by [1] for the alternation-free fragment of the µ-calculus and by [6] for alternation depth one only. [1] also reports on a parallel version implemented in Haskell with explicit message passing. How- ever, their explicit message passing approach to parallelisation is more verbose than our implementation in GpH. In contrast to their implementation we use a tuned C-based BDD library to gain high sequential performance, a problem reported in the pure Haskell implementation in [1].
Hence, our work differs from comparable algorithms and implementations not only by handling a much richer logic but also by using the built-in com- piler support of a parallel language. Thus we do not have to administer the parallelisation task ourselves.
Organisation
The paper is structured as follows. Section 2 introduces Fixpoint Logic with Chop (FLC), focusing on properties relevant for the parallelisation of the model checking algorithm. Section 3 then describes the sequential symbolic model checking algorithm for FLC. Section 4 introduces the main concepts of Glasgow Parallel Haskell (GpH) and then discusses several parallel versions of the algorithm. Section 5 gives empirical data on running the parallel algorithm on a cluster of workstations, and summarises the results.

Preliminaries
Let P = {tt, ff, q, q,.. .} be a set of propositional constants that is closed under complementation, V = {Z, Y,.. .} a set of propositional variables, and A = {a, b,.. .} a set of action names. A labelled transition system is a graph

T = (S, {−→a
| a ∈ A}, L) where S is a set of states, −→a
for each a ∈ A is a

binary relation on states and L : S → 2P labels the states such that, for all
s ∈ S : q ∈ L(s) iff q /∈ L(s), tt ∈ L(s), and ff /∈ L(s). We will use infix

notation s −→a
t for transition relations. In the context of this paper we will

always assume transition systems to be finite. Thus, they can be represented using BDDs.
For a proper introduction to BDDs see for example [2]. In [3] it is shown how to use BDDs for verification purposes in general and for a variant of the modal µ-calculus due to Park and the temporal logic CTL in particular.
Given such a T , w.l.o.g. assume that |S| ≤ 2n for some n ∈ N. Then every state has a unique number between 0 and 2n − 1 and one can identify a state

s with its binary representation s1 ... sn, si ∈ B.
T can be represented by |A| + |P| many BDDs over 2 · n variables. We fix their names and a total order as x1 < y1 < ... < xn < yn.
For every proposition q ∈ P we have a BDD tq over the variables x1,... , xn
s.t. tq(x1,... , xn)= tt iff q ∈ L(x1 ... xn).
For every action a ∈ A we have a BDD ta over the variables x1,... , xn,

y1,... , yn s.t. ta(x1, y1,... , xn, yn)= tt iff x1 ... xn −→a
Formulas of FLC are given by the following grammar.
y1 ... yn.

ϕ  ::=  q | Z | τ | ⟨a⟩ | [a] | ϕ ∨ ϕ | ϕ ∧ ϕ | µZ.ϕ | νZ.ϕ | ϕ; ϕ
where q ∈ P, Z ∈ V, and a ∈ A. We will write σ for µ or ν. To save brackets we introduce the convention that ; binds stronger than ∧ which binds stronger than ∨. Formulas are assumed to be well-named in the sense that each binder variable is distinct. Our main interest is with formulas that do not have free variables, in which case there is a function fp() : V → FLC that maps each variable to its defining fixpoint formula.
The set Sub(ϕ) of sub-formulas of ϕ is defined as usual, with Sub(σZ.ψ)= 
{σZ.ψ}∪ Sub(ψ).
The tail of the rightmost free occurrence of a variable X in ψ, tl X(ψ) is – intuitively – everything that occurs behind this X in ψ. Technically, it is defined inductively with


tl X
(ϕ; ψ) := ⎧⎨ tl X(ψ)	if X occurs in ψ
⎩ {ϕ'; ψ | ϕ' ∈ tl X(ϕ)} o.w.

and the other cases straight-forward: tl X(ϕ ∧ ψ) := tl X (ϕ) ∪ tl X(ψ), etc. The set of tails of a variable X, tl (X) is the union over all tl X(X; ϕ) where fp(X) = σX.ϕ and all rightmost occurrences are successively replaced by tt if σ = ν and ff otherwise.
An environment ρ : V → (2S → 2S) maps variables to monotone functions of sets to sets. ρ[Z '→ f ] is the function that maps Z to f and agrees with ρ on all other arguments. The semantics [·]]T : 2S → 2S of an FLC formula, relative to T and ρ, is a monotone function on subsets of states with respect to the inclusion ordering on 2S . These functions together with the partial order given by
f ± g iff ∀X ⊆ S : f (X) ⊆ g(X)
form a complete lattice with joins H and meets H. By the Tarski-Knaster Theorem the least and greatest fixpoints of functionals F : (2S → 2S ) →


(2S → 2S ) exist. They are used to interpret fixpoint formulas of FLC.
To simplify the notation we assume a transition system T to be fixed, and

write [·]]ρ
instead of [·]]T .
[[q]]ρ  := λX.{s ∈ S | q ∈ L(s)}	[[Z]]ρ  := ρ(Z)
[[τ ]]ρ := λX.X	[[ϕ; ψ]]ρ :=	[ϕ]]ρ ◦ [[ψ]]ρ

[[ϕ ∨ ψ]]ρ  :=	[ϕ]]ρ H [[ψ]]ρ
[[⟨a⟩]]	:=  λX.{s ∈ S | ∃t ∈ X, s.t. s −→a t}

[[[a]]]ρ
:= λX.{s ∈ S | ∀t ∈ S,s −→a t ⇒ t ∈ X}

[[µZ.ϕ]]ρ
:= . {f : 2S → 2S | f monotone, [ϕ]]

ρ[Z'→f ]
± f }

with the cases of ϕ ∧ ψ and νX.ϕ being similar. A state s satisfies a formula ϕ under ρ, written s |=ρ ϕ, iff s ∈ [[ϕ]](S). If ϕ is a closed formula then ρ can be omitted and we write [ϕ]](S) as well as s |= ϕ. We will give a few examples of FLC formulas.
Example 2.1 a) Let A = {a, b, c, d} and
ϕ1  := νY.[b]; ff ∧ ([c] ∧ [d]); Y ∧
[a]; (νZ.[b] ∧ ([c] ∧ [d]); Z ∧ [a]; Z; Z); (([a]; ff ∧ [b]; ff) ∨ Y )
Formula ϕ1 expresses “the number of b’s never exceeds the number of a’s” which is non-regular and, therefore, is not expressible in the modal µ-calculus.
The sub-formula ψ = νZ.[b] ∧ ([c] ∧ [d]); Z ∧ [a]; Z; Z expresses “there can be at most one b more than there are a’s”. This can be understood best by unfolding the fixpoint formula and thus obtaining sequences of modalities and variables. It is easy to see that replacing a Z with a [b] reduces the number of Z’s whereas replacing it with the other conjunct adds a new Z to the sequence. Then, [b]; ff ∧ [a]; ψ postulates that at the beginning no b is possible and for every sequence of n a-actions there can be at most n b-actions. Finally, the Y in ϕ1 allows such sequences to be composed or finished in a deadlock
state.
b) Let ϕ3 := νX.τ ∧ [a]; X; ⟨b⟩∧ (µY.[a]; Y ; [b] ∨ [b]; Y ; [a] ∨ τ ); X. It is best understood by thinking of it as a context-free grammar with intersections. Then the inner least fixpoint formula generates sequences of an even number of [·] formulas before an X in which there are as many a’s as b’s. Together with the other conjuncts, unfolding X creates arbitrary formulas of the form [c1]; ... ; [cn]; ⟨b⟩; ... ; ⟨b⟩ where ⟨b⟩ occurs m times with n ≥ m, ci ∈ {a, b} for all i and m = |{i | ci = a}|−|{i | ci = b}|. Thus, ϕ3 says that after k a-actions and l b-actions it is always possible to do another k − l b-actions.



Fig. 1. The sequential and symbolic model checking algorithm for FLC.


The Sequential Algorithm
A BDD-based and sequential model checking algorithm for FLC was presented in [5]. However, the version given there is not correct. The semantics of an FLC formula is an element of a lattice of monotone functions. Fixpoints in this lattice are computed using the usual fixpoint iteration method. In order to decide whether or not a fixpoint is found, one has to compare functions on several (and possibly exponentially many) arguments rather than one only. Consequently, the symbolic model checking algorithm is more expensive than previously expected, and improving its performance becomes an even more important issue.
The algorithm is local in the following sense. However, in order to deter- mine whether or not s |= ϕ holds for given s and ϕ, it is not necessary to compute the entire semantics [ϕ ]. Instead it suffices to calculate it pointwise starting with [ϕ]](S) for the underlying set of states S, etc. Compare this to the usual idea of a local model checking algorithm which does not calculate the set of all states satisfying a given formula.


The algorithm MC shown in Figure 1 takes as arguments an environment ρ and an FLC formula ϕ and returns [ϕ]]ρ. Thus, it is global in the usual sense. An evaluation strategy in a functional language guarantees that only those parts of [ϕ]]ρ are computed that are needed in order to establish or refute s |= ϕ.
Algorithm MC calls the function fixPoint which computes the fixpoint iterations until stability is reached. Due to our type of locality, functions are not evaluated on every argument. This means that the fixpoint iteration can become stable on a given argument although the fixpoint in the function space is not reached yet. Thus, the function fixPoint has to evaluate the fixpoint iteration on several arguments. It approximates the necessary ones (i.e. BDDs representing sets of states) using the function tcψ,X(t) which takes an FLC formula ψ, a free variable X, an environment ρ and a BDD t, and first computes the reflexive and transitive closure of {t} under the functions
{[[ϕ]]ρ | ϕ ∈ tl (X)}. This set includes the set of all BDDs that are needed as arguments in order to compute the fixpoint in the function space.

Parallelising Algorithm MC
Glasgow Parallel Haskell (GpH)
GpH [11] is a modest conservative extension of the non-strict, purely functional programming language Haskell98 [10], adding a constructor par for parallel composition (the sequential seq combinator is already part of Haskell98): x ‘par‘ e expresses potential parallel execution of x and e. Typically x is a variable occurring in e, but it can be a general Haskell expression. The result of the expression is that of e, thus semantically par is a projection on its second argument. Operationally, this expression adds x to a pool of potentially parallel executions. The decision whether to indeed execute x in parallel, and if so, where to execute it, is made automatically by the runtime-system. In GpH the programmer uses the par combinator to annotate expressions as being potentially parallel and leaves the management of the parallelism to the runtime system. We call this a model of semi-explicit parallelism.
The implementation of GpH models a virtual shared heap, i.e. all program variables are accessible as if residing on the same processor. The runtime system arranges for automatic data transfer between processors if this is not the case. A virtual shared heap facilitates the development of architecture independent programs that are able to exploit large numbers of processors. In contrast, the number of processors in physical shared memory machines is bounded by hardware constraints, usually to a few dozens. For applications wanting to exploit only small amounts of parallelism such a simpler shared


memory could be used. An experimental version of the runtime system for physical shared memory machines exists, but currently suffers from high over- head during normal execution, because of frequent locking that becomes nec- essary when allocating new data structures. Therefore, we ultimately want to integrate shared memory machines into our model by optimising the com- munication routines for the physical shared memory case where possible, but retain an overall virtual shared memory model even for these machines.
One important language feature for this application is the FFI interface provided in Haskell. This enables us to use existing, tuned C-code for basic BDD operations. However, since the Long BDD library [8] that we use, man- ages its own heap, interaction between the Haskell heap and the C heap is necessary. On Haskell side this means that a BDD is represented as a For- eign Object, i.e. a data-structure that is constructed outside the Haskell heap. This data structure is represented by a pointer into the C heap and a finaliser routine that is executed once it is not used from the Haskell heap anymore.
In order to provide a higher level of abstraction we usually use evalua- tion strategies [11] to express parallelism in more complex Haskell programs. These strategies are polymorphic, higher-order functions that express paral- lelism, evaluation order and evaluation degree. Strategies are formulated in terms of par and seq and are attached to program expressions by the using combinator. For example, parallel evaluation of all elements in a list xs, evaluating each list element to normal form, can be written as xs ‘using‘ parList rnf. The predefined strategy parList can be written as foldr par (). In this paper we will only use the overloaded strategy rnf, which evaluates a data structure to normal form.
The Parallel Algorithm
Our first parallel version of algorithm MC, PMC1(n) where n denotes the number of processors used in its execution, exploits parallelism over the con- structs ϕ ∧ ψ or ϕ ∨ ψ. No dependencies exist between the executions of both branches, yielding a rich source of massive parallelism. The structure of this parallel algorithm is divide-and-conquer. But sequential profiling in Section 5.1 shows that unrestricted usage of parallelism over these constructs will generate far too much parallelism to be efficient. Therefore, we combine this version with a thresholding mechanism often used for divide-and-conquer parallelism: in the tree of formulas that are generated by the model checking algorithm, parallelism is only generated up to a certain depth, or threshold. We provide the threshold as an additional parameter to the algorithm.
While this parallelism can be described with only one par combinator, we also need to specify the evaluation order, using a seq combinator, and


evaluation degree, using the reduce to normal form evaluation strategy rnf. Additionally, the system requires all data, that is input to a parallel thread, to exist in the Haskell heap. Otherwise only a pointer into the C heap would be transmitted to another processor, where this pointer would, of course, be invalid. Therefore, we have to introduce functions freezeBDD and thawBDD, which copy a BDD from the C to the Haskell heap and vice versa. The function fMC is a variant of MC that works over such “frozen” BDDs.
The parallel code for the ∧-branch in the algorithm looks like this, describ-
ing evaluation of ψ in parallel to the main thread that evaluates ϕ ∧ ψ:
And f g -> \ t ->
let t’	= freezeBDD t
(x’, y’) = (fMC f e t’, fMC g e t’) (x, y)	= (thawBDD x’, thawBDD y’)
in (rnf t’) ‘seq‘ ((rnf y’) ‘par‘ ((rnf x’) ‘seq‘ (x ‘bAND‘ y)))
where bAND combines two BDDs with the boolean ∧.
The computation of the test set T with the help of tcψ,X,ρ requires calls to the model checker MC (on a smaller formula) again. This is because the tails of X in ψ need to be transformed into functions from BDDs to BDDs in order to compute the transitive closure of t under these functions. This gives rise to further evaluations of boolean connectives. Furthermore, the computation of the transitive closure over a set of functions could be parallelised.
Algorithm PMC2 results from MC by computing the test set in parallel to the fixpoint calculation itself. This requires a change in the innermost let of the σ case in Figure 1:
let t’	= freezeBDD t
xs’	= ((map freezeBDD) . setToList . tests . thawBDD) t’ testset = (mkSet . map thawBDD) xs’
in
(rnf t’) ‘seq‘ (rnf xs’) ‘par‘ fixpoint n f a testset t
Again, additional code for freezing and thawing the input and output of po- tentially parallel computations is needed. Parallelism is generated by the rnf xs’ clause, which performs a computation of the test set by calling tests (corresponding to tc in Figure 1). Note, that the thread computing xs’ will run in parallel with the main thread computing fixpoint n f a testset
t. Synchronisation will be needed when the latter requires data structures produced by the former.
The main advantage of this source of parallelism is its coarse granular- ity, turning the entire test set generation into a parallel thread. The form of parallelism exploited here is producer-consumer (or pipeline) parallelism, where producer and consumer work in parallel on the same data structure. This parallelism could be combined with the massive amount of divide-and- conquer parallelism in version PMC1. Additionally, we could also compute the test set itself in parallel. This is possible since there are finitely many functions under which the closure of a set of BDDs needs to be computed.


Not only can the single functions be applied in parallel, it is also possible to parallelise a single iteration with a single function since it needs to be applied to several BDDs.

Empirical Test Data
In this section we describe a family of transition systems that model bounded stacks or counters. Let P = {tt, ff} and A = {push, pop, reset, idle}. An N-
bit-counter is a T = (S, {−→a | a ∈ A}, L) with S = {0,..., 2N − 1} and for all

s, t ∈ S: s −−pu−s→h
t iff t = s + 1, s −p−o→p
t iff t = s − 1, s −−re−se→t
t iff t = 0, s −−id−l→e t

iff s = t. Note that T does not count modulo 2N . Instead, value 0 cannot be decreased and 2N − 1 cannot be increased. In other words, an N-bit-counter can be increased and decreased between the values 0 and 2N − 1, reset to 0 and do nothing. According to Section 2, an N-bit-counter can be represented by 4 BDDs over 2 · N variables.
Algorithms MC, PMC1(1) and PMC1(4) have been run on N-bit-counters for some values of N in its sequential and parallel versions. The following formulas have been used as inputs: ϕ1 and ϕ3 from Example 2.1 with a := push, b := pop, c := reset, d := idle, as well as ϕ2 := νX.τ ∧ X; ⟨push⟩ demanding push-paths of unbounded length and the (µ-calculus definable) formula ϕ4 := µX.[push]; X. The running times (in seconds) in relation to the size 2N of an N-bit-counter are given in Figure 2.
All measurements have been run on a cluster of SuSE 9.0 PCs with 1.6GHz AMD Athlon processors, 256kB cache, 512MB of DDR SDRAM memory and a 9.5GB local harddisk. The network is a 100MB/s Fast Ethernet with latency of 120µs measured under PVM 3.4.3. We use GHC 5.02.3 for compilation, and our parallel extension of its runtime system, GUM.

Sequential Proﬁling
Following our methodology for developing parallel programs [7], we start with profiling the sequential code to identify the most time consuming components. We use cost centre profiling to classify time and heap consumption by program points responsible for the computation.
In analysing the profiling results for ϕ3 with N = 4, the most striking result is the high overhead for the finaliser routines of the Foreign Objects: 47% of heap and 23% of time. The model checking algorithm generates a large number of Foreign Objects: circa 18 million through calls to ∃ and ∀, 17 million through ∨ operations, and 116 million through BDD ∧ operations. Sharing the finaliser routines for a class of Foreign Objects, those representing




3000
2000
1000
0



1000
500
0
sec



0	1	2	3	4

sec



ϕ1


×1000 states



ϕ3

2000
1000
0


6000
4000
2000
0
sec



0	2	4	6
sec



ϕ2


×100 states



ϕ4

0	5	10	15
states
0	5	10
×100 states

+ +  MC		PMC1(1)	PMC1(4)
Fig. 2. The sequential and parallel running times.

BDDs, would improve sequential performance in this case. While the direct time consumption of the ∨ and ∧ branches is fairly small, 1.3% and 8.3%, those cases initiate much larger computations in the [ ] and ⟨ ⟩ branches, in total 25.9%, and indirectly through the fixpoint computation. The overall heap residency remains low throughout the computation, never exceeding 400kB. In summary, while the BDD operations are rather cheap, they are called very often, thus contributing to the overall costs. This is a typical characteristic for symbolic applications [7] with irregular parallelism and represents a good match with the dynamic management of parallelism performed in GpH.
Parallel Runtimes
Our performance results show that version PMC1 produces extremely fine grained parallelism, i.e. the generated threads have only a small amount of work to do. The parallel version contains overhead for freezing and thawing BDDs and for generating and managing a large number of threads. Therefore, the naive and/or parallel version does not achieve any speedup. When com- bining the and/or parallelism with thresholding the total number of threads that are generated drops significantly: for ϕ2 and N = 7 from 468 down to
408. Running this version with input ϕ2 on 4 processors we obtain relative speedups of 1.28 for N = 7 and 1.09 for N = 8. For this formula the overhead


of the 1 processor version, compared to a sequential version, stays within a factor of 2, but for other formulas it increases considerably. In particular, ver- sions producing more potential parallelism perform much more data transfer between heaps. For the other formulas we achieve relative speedups of up to
1.07 for ϕ1, 1.13 for ϕ3 and 1.12 for ϕ4. When keeping the threshold fixed, the speedups drop for larger inputs.
For an only mildly tuned parallel algorithm with highly irregular paral- lelism such low speedups are unsurprising. Clearly the algorithm does not suffer from a shortage of parallelism. Our current work focuses on granularity control in the algorithm, and using thresholding is one step in that direction. However, the choice of the best threshold will in general depend on the input formula, and we are currently exploring alternatives in automatically choosing this threshold. The strong dependence of performance on thread granularity is underlined by the poorer speedup for formula ϕ1 and N = 11: 0.98 (a slow-down). For this input 2062 threads are generated in total, far more than for ϕ2. Performance improves again when reducing the threshold and thus limiting the amount of parallelism as well as the overhead attached to it.
One important goal in our design of the parallel algorithm is to achieve scalability, i.e. to ensure that a larger number of processors than those cur- rently used can be exploited without changes to the code. Unfortunately, this property also triggers more data transfer between heaps than necessary. An implementation that uses laziness to avoid these operations unless parallelism is definitely exploited should improve the one processor performance, but is tricky to implement. Hardwiring such explicit order of evaluation into the code is the main reason for its complexity in an otherwise simple model of parallelism. We therefore now work on an approach where the structure of a Foreign Object is extended with a marshalling function, that will be auto- matically started as part of the graph packing algorithm used by the runtime- system to transfer computations between processors. This ensures that data transfer between heaps is only done when needed for parallel execution, and eliminates this complexity from the parallel GpH code.
Whereas version PMC2 avoids the problem of too fine-grained parallelism, it only creates one parallel thread on top of the main thread of execution. The code discussed in Section 4 generates producer-consumer parallelism, ex- ploiting the non-strict semantics of GpH: the consumer can start working on the intermediate data structure (the test set) even before it has been fully generated. Our measurements of this version, however, show that the data dependency between test set generation and fixpoint iteration are too tight to achieve a useful amount of parallelism: most of the time one of the two threads is blocked, waiting for remote data to arrive. For example with ϕ2


and N = 7, during 96% of the time only one thread is running, with the other thread blocked on data that has not been produced, yet, leaving virtually no parallelism in overlapping these two computations. As a result PMC2 does not achieve any speed-up at all: for ϕ1 and N = 10 the speedup is 0.98, for ϕ2 and N = 7 the speedup is 0.99. For more complex input formulas it would be possible to compute the test set for a sub-formula of the form σX.ψ at the very beginning, before reaching the quantifier in the formula. In this case, the test set can be computed in parallel with model checking the other parts of the formula, and all test sets can be computed in parallel, too. This, however, may create work that turns out to be unnecessary, and the effectiveness of this version very much depends on the structure of the input formula.

Summary
The presented symbolic model checker generates highly irregular parallelism in the form of deep, unbalanced divide-and-conquer trees, that need thresholding to limit the total amount of parallelism generated by and/or parallelism over the input formulas. The achieved speedups are small: in the best case, ϕ2 and N = 7, we can report an absolute speedup of 1.2 on 4 processors, in the worst case we get considerable slow-down. We identified overheads of converting C into Haskell data structures and too fine thread granularity as the main limitations. To improve performance, we need a method for better controlling thread granularity. Using the size of the test set to guide the decision whether or not to generate parallelism in one subtree of the computation hierarchy would be promising. The parallel computation of the test set itself did not prove worthwhile, since the data-dependencies between the producer of the test set, and the consumer are too tight to allow for a significant amount of parallel execution between these two threads.
In more general terms our experience of using Haskell as the top-level language for the sequential and the parallel algorithms has been a positive one. The algorithm itself is much closer to the high-level presentation given here, compared to an earlier Java-based implementation [5]. Using a tuned BDD library gives us high performance in the sequential case already, exploit- ing Haskell’s foreign function interface (FFI). GpH as parallel language allows rapid prototyping of different parallel versions, to a degree not possible in conventional parallel languages. However, using an external BDD library, we had to write explicit marshalling code to convert BDDs in the C heap into Haskell data structures. At the moment data marshalling has to be explicitly controlled in the GpH code adding to the complexity of the parallel algorithm. In the future we plan to integrate data marshalling into the automatic graph packing algorithm that is used to transfer computations. For writing the mar-


shalling code, an additional layer on top of the FFI, similar to the GreenCard tool, would be very useful.

References
B. Bollig, M. Leucker, and M. Weber. Local parallel model checking for the alternation-free µ-calculus. In S. Leue D. Bonaki, editor, Proc. 9th Int. SPIN Workshop on Model checking of Software, SPIN’02, volume 2318 of LNCS, pages 128–147. Springer, 2002.
R. E. Bryant. Graph-based algorithms for boolean function manipulation. IEEE Transactions on Computers, 35(8):677–691, August 1986.
J. R. Burch, E. M. Clarke, K. L. McMillan, D. L. Dill, and L. J. Hwang. Symbolic model checking: 1020 states and beyond. Information and Computation, 98(2):142–170, June 1992.
O. Grumberg, T. Heyman, and A. Schuster. Distributed symbolic model checking for µ- calculus. In G. Berry, H. Comon, and A. Finkel, editors, Proc. 13th Conf. on Computer-Aided Veriﬁcation, CAV’01, volume 2102 of LNCS, pages 350–362. Springer, July 2001.
M. Lange. Symbolic model checking of non-regular properties. In R. Alur and D. Peled, editors, Proc. 16th Conf. on Computer Aided Veriﬁcation, CAV’04, volume 3114 of LNCS, pages 83–95, Boston, MA, USA, August 2004. Springer.
M. Leucker, R. Somla, and M. Weber. Parallel model checking for LTL, CTL∗ and L2 . In
L. Brim and O. Grumberg, editors, 2nd Int. Workshop on Parallel and Distributed Model Checking, PDMC’03, volume 89 of Electronic Notes in Theoretical Computer Science. Elsevier, 2003.
H.-W. Loidl, P.W. Trinder, K. Hammond, S.B. Junaidu, R.G. Morgan, and S.L. Peyton Jones. Engineering Parallel Symbolic Programs in GPH. Concurrency — Practice and Experience, 11:701–752, 1999.
D.  Long.	The  Long  BDD  Library.	Web  page,  May  2004.
http://www-2.cs.cmu.edu/~modelcheck/bdd.html .
M. Mu¨ller-Olm. A modal fixpoint logic with chop. In C. Meinel and S. Tison, editors, Proc. 16th Symp. on Theoretical Aspects of Computer Science, STACS’99, volume 1563 of LNCS, pages 510–520, Trier, Germany, 1999. Springer.
S.L. Peyton Jones, J. Hughes et al. Haskell 98: A Non-strict, Purely Functional Language, 1999. Available at http://www.haskell.org/.
P.W. Trinder, K. Hammond, H.-W. Loidl, and S.L. Peyton Jones. Algorithm + Strategy = Parallelism. J. of Functional Programming, 8(1):23–60, Jan. 1998.
