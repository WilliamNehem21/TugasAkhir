

Electronic Notes in Theoretical Computer Science 253 (2009) 83–96
www.elsevier.com/locate/entcs

Experiments with Non-Termination Analysis for Java Bytecode
E´tienne Payet1
IREMIA
Universit´e de La R´eunion France

Fausto Spoto2
Dipartimento di Informatica Universit`a di Verona
Italy

Abstract
Non-termination analysis proves that programs, or parts of a program, do not terminate. This is important since non-termination is often an unexpected behaviour of computer programs and exposes a bug in their code. While research has found ways of proving non-termination of logic programs and of term rewriting systems, this is hardly the case for imperative programs. In this paper, we describe and experiment with a technique for proving non-termination of imperative, bytecode programs by relating their non-termination to that of a (constraint) logic program. Moreover, we show that our non-termination test effectively helps a termination test, by avoiding expensive search for termination proofs of those portions of the code where such proofs do not exist.
Keywords: Java, Java bytecode, static analysis, termination, non-termination


Introduction
Java bytecode [8] is the result of the compilation of Java, as well as of other pro- gramming languages. It is a low-level, object-oriented, type-safe language which is distributed in a machine-independent format, hence executable on different archi- tectures. It is the target of choice for the compilation of applications that must be downloaded from the net into client computers or mobile phones. The recent

1 Email: epayet@univ-reunion.fr
2 Email: fausto.spoto@univr.it

1571-0661 © 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.11.016

Android system by Google [1] uses the Java bytecode as the target of the compila- tion of Android programs, before translating it into a machine-centered lower-level bytecode.
As a consequence of the wide use of Java bytecode, research is increasingly fo- cused on checking, in an automatic way, that Java bytecode applications are not harmful. This includes the proof that, for instance, they do not overuse the resources of the system. One such resource is time. In particular, proofs of termination of Java bytecode programs guarantee that they will actually terminate. Such proofs are important for the software developer, since they support the quality standards of his product. Nevertheless, termination of computer programs being an undecidable property, the termination of many methods remains unproved and such methods might hence be potentially non-terminating. A direct proof of their non-termination becomes desirable, since it exhibits an actual, typically unexpected behaviour of the program and often means that the non-terminating methods contain a bug. Cur- rently, no system exists to prove the non-termination of Java bytecode methods, since research has mainly been focused on proofs of non-termination for logic pro- grams [4,11,10,2,16,15] and term rewriting systems [21,5,24,22,23,9]. In the recent paper [7], the authors consider non-termination of C programs and [6,14] provide some techniques for testing C programs that detect errors such as program crashes, assertion violation and non-termination. In [20], an approach to automatically check non-termination of imperative programs is introduced; it is based on the generation of invariants that are used to prove that some potential loops are never exited; the technique is experimented on a set of programs written in a fragment of Java and does not consider heap data structures. In this paper, we provide an example where our approach successfully proves the non-termination of a program where a data structure is defined.
This paper provides a first experimentation with the automatic derivation of non-termination proofs for Java bytecode programs. We start from our previous work on a tool Julia+BinTerm for the termination analysis of Java bytecode [19]. There, we translated the original Java bytecode program P into a constraint logic program PCLP whose termination entails that of P . Here, we show how, in those cases when the approximation of the bytecodes is exact, the non-termination of PCLP entails that of P . Hence, we use the same tool as in [19] to prove the non- termination of Java bytecode programs by exploiting previous results from non- termination analysis of logic programs [10]; namely, we prove the non-termination of PCLP and hence infer, when possible, that of P . Although these results are far from being a definite solution to the problem of non-termination analysis of Java bytecode programs, they represent a first step in that direction and highlight weaknesses of the current approach, that must be solved if non-termination analysis must be applied to real Java and Java bytecode software. Note that, while a notion of existential non-termination for C is considered in [7], we instead consider a notion of universal non-termination here for the CLP program derived from the Java bytecode program.
This paper also shows that our non-termination test effectively helps the termi- nation test defined in [19]. Namely, we use our non-termination test to signal to the

termination prover in [19] that some clauses in PCLP diverge, so that it is useless to look for an (often expensive) termination proof for them. Note that this technique is applicable and profitable for all Java bytecode programs, also when the approxi- mation of their bytecodes is not exact or when all their methods actually terminate. Our termination test is applied, indeed, to the CLP program, whose clauses might not terminate because of the approximations induced by the abstraction from P to
PCLP .

Compilation of Java bytecode into constraint logic programs
Java bytecode is a low-level object-oriented type-safe language. Its static analysis is complicated by the fact that it has no explicit structure, differently from high- level languages, and that it uses a stack of temporary variables. Hence the number and type of the variables are different at different program points inside the same method.
We have recently developed a static analysis of Java bytecode programs (and hence of Java programs) that proves the termination of most methods of a pro- gram [19]. The idea is that the Java bytecode program is first translated into its
basic blocks and then an abstract interpretation [3], based on a denotational seman-
tics over those blocks, is applied by using different abstract domains of analysis. The latter provide a conservative approximation of the numerical and structural constraints on the numbers or data structure used by the program: a first domain,
for sharing [13], determines when data structures bound to program variables might
share locations on the heap, so that an update of one variable might also affect the others. This information is exploited in the second domain, for cyclicity [12], which determines when the data structure bound to a program variable might contain
loops of locations, so that an iteration over that data structure might not necessarily terminate. Both kinds of information are then used in a path-length domain [17,19], that computes the relationship between the size of program variables before and
after the execution of each instruction in the bytecode: the size or path-length of a variable bound to a data structure is the maximal length of pointers that one can follow from that variable; the path-length of a variable bound to an array is the length of the array; the path-length of a numerical variable is its value; the path-length of a Boolean variable is 0 for false and 1 for true. The result of the path-length is finally used to express the relationship between the size of the vari- ables at the beginning and at the end of each basic block of the program. This is written in terms of a constraint logic program PCLP over linear constraints, whose predicates b(vars) correspond to each basic block b of P and vars are the variables at the beginning of the execution of b. These approximations build constraints that are later used in order to derive bounds on the values of variables in programs, which is crucial for termination and non-termination analyses to work. The main result proved in [19], wrt. termination analysis, is the following:
Theorem 2.1 Let P be a Java bytecode program and b a basic block of P. If the

query b(vars) has only terminating computations in PCLP , for all ﬁxed integer values for vars, then all executions of a Java Virtual Machine started at b terminate.	 

The converse, however, does not hold in general: we can find programs P and a basic block b of P such that, in the translation PCLP , predicate b(vars) does not terminate for some fixed initial integer values for vars, although all executions of P starting at b do terminate. This is due to the approximations done during the translation of P into PCLP : both sharing and cyclicity analyses are approximated, so that, for instance, the analyser might not necessarily prove that a non-cyclical list is actually non-cyclical. Moreover, some bytecodes have an inherently non-linear behaviour, such as multiplications and divisions, and cannot hence be approximated by using the linear constraints available for the path-length.
The translation from Java or Java bytecode to CLP makes it uniform the treat- ment of any kind of loops: for, while loops, recursion, loops having exit conditions depending on numerical, reference or Boolean variables, loops exiting become of the break statement, all become a loop in the graph of blocks of PCLP . The termination of PCLP can hence be established in a uniform way, also in the presence of Boolean variable assigned inside an if statement and hence making a loop exit.
An important point about the program PCLP is that its termination is mean- ingful for ground inputs only, where all variables have been bound to their integer path-length (Theorem 2.1). Moreover, the clauses of PCLP are binary, that is, they have the form p(X˜) ← c, q(Y˜ ), with only one predicate on the right.
The termination of PCLP is proved by the BinTerm tool by F. Mesnard, that finds decreasing measures across iterations of most loops in PCLP . The computa- tional cost of the tool decreases by reducing the number of clauses in PCLP : namely, only clauses in a loop are considered, since they correspond to loops or recursion in the original program P and are those that determine the termination or non- termination of the program. Moreover, its cost is reduced also by decreasing the arity of the predicates, when it is clear that the removed arguments are irrelevant for the termination of the predicates. These optimisations are defined and proved correct in [18]. As a consequence, in all our examples, the CLP program will express the path-length relationships for the loops of the program only.
Although the converse of Theorem 2.1 does not hold in general, there are many cases when the approximation of the original program P into path-length is exact, in the sense that all denotations represented by the PCLP program are actual deno- tations that represent real, concrete executions of P . This is the case, for instance, of the approximations of the instructions dealing with integer values, with the no- table exception of multiplications and divisions; as well as of instructions dealing with data structures that have been successfully proved to be non-cyclical by the cyclicity analysis. In those frequent cases, a proof of non-termination for the CLP program induces a proof of non-termination for the original Java bytecode program. In the following, we discuss how proofs of non-termination for CLP programs can be constructed and exemplify many cases when we can conclude (or not) that the original Java bytecode program does not terminate either.

Proving non-termination of constraint logic programs
A non-termination criterion is provided in [10] for the standard operational seman- tics of constraint logic programming, where free variables may occur in a call to a predicate. The specialisation of this criterion to the semantics we consider in this paper (free variables are not allowed in a call to a predicate) is briefly described in this section.
We consider constraint logic programs over path-length polyhedra (CLP (PL)).
We let t˜denote a sequence of terms, X˜ and Y˜ denote sequences of distinct variables, p and q denote predicate symbols and c denote a path-length constraint. An atom has the form p(t˜) where the length of t˜ equals the arity of p. A query has the form
⟨p(X˜) | c⟩. A clause has the form p(X˜) ← c, q(Y˜ ) where X˜ and Y˜ are disjoint and the variables occurring in c necessarily occur in X˜ ∪ Y˜ . A CLP (PL) program is a finite
set of clauses. We use ∃X˜ c as a shortcut for ∃X1 ... ∃Xnc where X1,..., Xn := X˜.

The projection of c onto the sequence X˜ is denoted by ∃ ˜c and is the constraint
X
∃Var (c)\X˜ c, where Var (c) is the set of variables occurring in c. The set described
by a query Q := ⟨p(X˜) | c⟩ is denoted by Set (Q); it consists of all the atoms of the
form p(v(X1),..., v(Xn)) where X1,..., Xn := X˜ and v is a ground solution of c.
We say that Set (Q) is non-terminating wrt. a CLP (PL) program P when for all
p(v(X1),..., v(Xn)) ∈ Set (Q), the query
⟨p(X1,..., Xn) | X1 = v(X1),..., Xn = v(Xn)⟩
is non-terminating wrt. P by using the standard semantics of constraint logic pro- grams. This means that an infinite computation can be built for that query in the program P . Note that we do not consider any precedence between the clauses of P , that is, we assume a non-deterministic resolution of a predicate with all the clauses that define that predicate. The following results provide simple non-termination conditions for constraint logic programs.
Theorem 3.1 ([10]) Let p(X˜) ← c, p(Y˜ ) be a recursive clause in a CLP (PL) pro- gram P. If Set (⟨p(Y˜ ) | ∃Y˜ c⟩) ⊆ Set (⟨p(X˜) | ∃X˜ c⟩) then Set (⟨p(X˜) | ∃X˜ c⟩) is non- terminating wrt. P.	 
Theorem 3.1 means that if the set of values assigned to Y˜ by all the solutions of c is included in the set of values assigned to X˜ by all the solutions of c, then any value assigned to X˜ by a solution of c provides a non-terminating ground query. Indeed, intuitively, the constraint ∃X˜ c is the guard of the clause and Set (⟨p(Y˜ ) | ∃Y˜ c⟩) ⊆ Set (⟨p(X˜) | ∃X˜ c⟩) means that every output value of the clause satisfies this guard.
Hence, if a value satisfies the guard, then it enters the clause and the corresponding
output satisfies the guard, so this output can also enter the clause and the next output satisfies the guard, and so on. Notice that the converse of the implication in Theorem 3.1 does not always hold: consider for instance the recursive clause p(X) ←
X ≥ 3, p(Y ); we have that Set (⟨p(X) | ∃XX ≥ 3⟩), i.e. Set (⟨p(X) | X ≥ 3⟩), is non-
terminating wrt. this clause although Set (⟨p(Y ) | ∃Y X ≥ 3⟩), i.e. Set (⟨p(Y ) | true⟩), is not included in Set (⟨p(X) | X ≥ 3⟩).

Theorem 3.2 ([10]) Let q(X˜) ← c, p(Y˜ ) be a clause in a CLP (PL) program P and Q be a query such that Set (Q) is non-terminating wrt. P. If Set (⟨p(Y˜ ) | ∃Y˜ c⟩) ⊆ Set (Q) then Set (⟨q(X˜) | ∃X˜ c⟩) is non-terminating wrt. P.	 

The intuition of Theorem 3.2 is that any value q(x˜) in Set (⟨q(X˜) | ∃X˜ c⟩) satisfies

∃X˜ c, the guard of the clause, and the corresponding output p(y˜) is included in Set (⟨p(Y˜ ) | ∃Y˜ c⟩). As Set (⟨p(Y˜ ) | ∃Y˜ c⟩) ⊆ Set (Q) and Set (Q) is non-terminating wrt. P , then p(y˜) does not terminate wrt. P , so q(x˜) does not terminate also.
These theorems provide a simple mechanism to infer ground non-terminating queries: first, use Theorem 3.1 to infer a set of non-terminating queries from the recursive clauses of the program and then complete this set with the help of Theo- rem 3.2.

Proving non-termination of Java bytecode programs
In this section, we give several examples of situations where we can conclude the non-termination of the original program from that of the CLP program, as well as examples where instead this is not possible.

Exact approximations with iterations
When the approximation into a path-length constraint of the Java bytecode program P under analysis is exact, a proof of non-termination of PCLP is also a proof of non- termination of P . The formal definition of exact requires the bytecodes to have a concrete behaviour which is exactly matched by their numerical abstraction, that is, every pair of states satisfying the input/output abstraction of the bytecode must correspond to an actual, concrete behaviour of the bytecode. Note that the converse must always hold by the correctness of the abstraction.
Definition 4.1 [Exact Abstraction] Let ins be a bytecode instruction, formalised as an input/output map on concrete JVM states, as in [19], and let insPL be a correct approximation of its behaviour, i.e., a constraint over input variables vˇ and output variables vˆ. This approximation is exact if and only if, for all input states σˇ and output variable σˆ satisfying the static information at ins (number and type
of local variables and stack elements), whenever {vˇ '→ pathlength(σˇ(v))}∪ {vˆ '→
pathlength(σˆ(v))} |= insPL then σ(σˇ) = σˆ.	 
Consider for instance the program Add1 :
public class Add1 {
public static void main(String args[]) { int k = 3;
for(int i = 2; i < 2 + k; i++);
}
}
The approximation of the bytecode program corresponding to Add1 is exact: the

loop guard involves the add bytecode instruction whose approximation, as provided in [19], is
add PL = Unchangedq(#l, #s − 2) ∪ {sˇ#s−2 + sˇ#s−1 = sˆ#s−2}
where #l and #s are the number of local variables and stack elements at program point q where the instruction occurs; we distinguish between variables v at the beginning of the execution of the bytecode, written as vˇ, and variables at its end, written as vˆ. The formula above means that add does not modify any local variable nor any stack element not involved in the addition; moreover, the new top of the stack (sˆ#s−2) holds a value which is equal the addition of the former two topmost stack elements (sˇ#s−2 and sˇ#s−1). This approximation is exact since, for every couple of input state σˇ and output state σˆ satisfying the static information at this bytecode and the approximation above, we must have that the local variables have the same values in σˇ and σˆ and the top of the stack of σˆ is the sum of the topmost
two values on top of the stack of σˇ, so that those states are such that addq(σˇ) = σˆ. The corresponding CLP (PL) program Add1 CLP is:
entry (IL2 ) ← {IL2 − OL2 = −1, −IL2 ≥ −4, IL2 ≥ 2}, entry (OL2 )
The predicate entry denotes the entry point of the loop of the program; local variable 2 implements i while variable k has been removed since it is irrelevant for the termination of the program. This CLP program has been derived by using the abstract interpretations cited in the introduction. Namely, we have used the path- length abstract analysis, which has derived the constraint IL2 −OL2 = −1 (that is, local variable 2, which is i, decreases along iterations of the loop) and the constraints
−IL2 ≥ −4, IL2 ≥ 2, which provide bounds on the possible values of that variable inside the loop. That CLP program terminates. By Theorem 2.1 we conclude that Add1 terminates also. If we turn Add1 into the non-terminating program:
public class Add2 {
public static void main(String args[]) { int k = 3;
for(int i = 2; i < 2 + k; i--);
}
}
we get the CLP (PL) program Add2 CLP :
entry (IL2 ) ← {IL2 − OL2 = 1, −IL2 ≥ −2}, entry (OL2 )
which by Theorem 3.1 does not terminate because the projection of the constraint of its unique clause onto IL2 (resp. OL2 ) is −IL2 ≥ −2 (resp. −OL2 ≥ −1) and we have
Set (⟨entry (OL2 ) | −OL2 ≥ −1⟩) ⊆ Set (⟨entry (IL2 ) | −IL2 ≥ −2⟩) .
Here, we can safely conclude the non-termination of Add2 from that of Add2 CLP . Our technique is also able to handle more complicated situations. For instance,
if we nest the non-terminating loop of program Add2 into a terminating loop, we

get:
public class Add3 {
public static void main(String args[]) { int k = 3;
for(int j = 0; j < 10; j++)
for (int i = 2; i < 2 + k; i--);
}
}
The corresponding CLP (PL) program Add3 CLP :
entry (IL3 ) ← {OL3 = 2}, block (OL3 )
block (IL3 ) ← {IL3 − OL3 = 1, −IL3 ≥ −2}, block (OL3 )
does not terminate. Note that the outer loop does not appear in the CLP program, since the exit condition i ≥ 2 + k of the inner loop is found to be false during the path-length analysis and no clause is generated with a false constraint. Indeed, such clause would not influence the termination or non-termination behaviour of the program, since it would just stop the CLP resolution process. Indeed, by applying Theorem 3.1 to the recursive clause we get that Set (Q) is non-terminating wrt. Add3 CLP where
Q := ⟨block (IL3 ) | −IL3 ≥ −2⟩ .
Notice that we have to infer a non-terminating query of the form ⟨entry (·· ·) |·· ·⟩ to conclude the non-termination of Add3 CLP because the entry point of the loops of the program is the predicate entry . The projection of the constraint of the first clause onto OL3 is OL3 = 2 and we have
Set (⟨block (OL3 ) | OL3 = 2⟩) ⊆ Set (Q) .
Hence, by Theorem 3.2 applied to the first clause of Add3 CLP and to Q, we have that Set (⟨entry (IL3 ) | true⟩) is non-terminating wrt. Add3 CLP (where true denotes the always satisfiable constraint). Therefore, Add3 CLP does not terminate so we conclude that Add3 does not terminate either.
If we nest the non-terminating loop of program Add2 into a separated method, such as in:
public class Add4 {
public static void loop(int k) { for(int i = 2; i < 2 + k; i--);
}
public static void main(String args[]) { loop(3);
}
}
we get the CLP (PL) program Add4 CLP :
entry (IL1 ) ← {IL1 − OL1 = 1, −IL1 ≥ −2}, entry (OL1 )

which does not terminate (by Theorem 3.1). Hence we conclude that Add4 does not terminate either.

Exact approximations with recursion
The following terminating Java program involves a recursive method:
public class Rec1 {
public static int sum(int n) { if (n <= 0) return 0;
else return n + sum(n-1);
}
public static void main(String args[]) { sum(2);
}
}
The CLP (PL) program Rec1 CLP :
entry (IL0 ) ← {IL0 − OL0 = 1, IL0 ≥ 1, −IL0 ≥ −2}, entry (OL0 )
terminates, hence by Theorem 2.1 we conclude that Rec1 terminates. If we turn Rec1 into the following non-terminating program (where the programmer forgot the base case in the recursive method):
public class Rec2 {
public static int sum(int n) { return n + sum(n-1);
}
public static void main(String args[]) { sum(2);
}
}
we get the CLP (PL) program Rec2 CLP :
entry (IL0 ) ← {IL0 − OL0 = 1, −IL0 ≥ −2}, entry (OL0 )
By Theorem 3.1, Rec2 CLP does not terminate. As the approximation of the byte- code program corresponding to Rec2 is exact, we can safely conclude that Rec2 does not terminate either.

Exact approximations with data structures
All examples above deal with integer values only. Let us consider the following program now, where a list data structure is defined and recursively scanned:
public class List { private int head; private List tail;
public List(int head, List tail) {


this.head = head; this.tail = tail;
}
private void iter() {
if (tail != null) iter();
}
public static void main(String args[]) { List l = new List(0, new List(1, null)); l.iter();
}
}
The method iter (intended to perform an iteration over a list) contains a bug since it recurs on the same list rather than on its tail (iter() instead of tail.iter()). The bytecode version of this program has an exact approximation as our cyclicity analysis correctly infers that the list l in the method main is not cyclical.  The
corresponding CLP (PL) program List CLP :
entry ← true, entry
(true denotes the always satisfiable constraint) does not terminate, hence we safely conclude that the program List does not terminate either.


Non-exact approximations
Consider the mul bytecode instruction that removes the two top operand stack elements and replaces them with the result of their multiplication. As there is no linear way of expressing a constraint on the result of the multiplication, we just set
mul PL = Unchangedq(#l, #s − 2)
(#l and #s are the number of local variables and stack elements at program point q where the instruction occurs) meaning that the instruction does not modify any local variables nor any stack element which are not its operands; however, no constraint on the new top of the stack (the result of the multiplication) is generated. The Java program:
public class Mul {
public static void main(String args[]) { int k = 3;
for(int i = 2; i < 2 * k; i++);
}
}
terminates. Notice that the guard of the loop involves a multiplication. The corre- sponding CLP (PL) program Mul CLP :
entry (IL2 ) ← {IL2 − OL2 = −1, IL2 ≥ 2}, entry (OL2 )

does not terminate. Indeed, the projection of the constraint of the unique clause of
Mul CLP onto IL2 (resp. OL2 ) is IL2 ≥ 2 (resp. OL2 ≥ 3) and we have
Set (⟨entry (OL2 ) | OL2 ≥ 3⟩) ⊆ Set (⟨entry (IL2 ) | IL2 ≥ 2⟩) .
Therefore, by Theorem 3.1, the non-empty set Set (⟨entry (IL2 ) | IL2 ≥ 2⟩) is non- terminating wrt. Mul CLP . However, the non-termination of Mul does not follow from this result, since we are using approximated constraints.
We are facing a similar situation when dealing with numeric fields. The getﬁeld f instruction takes the reference to an object o located on top of the stack and replaces it with the value of o.f . In [19] we defined
getﬁeld PL f = Unchangedq(#l, #s − 1)
whenever the field f has integer type (#l and #s are the number of local variables and stack elements at program point q where the instruction occurs). No constraint is generated for the new top of the operand stack (the value of the field) since its path-length is unknown. The Java program:
public class Field { private int n = 6;
public static void main(String args[]) { Field f = new Field();
for(int i = 2; i < f.n; i++);
}
}
terminates. The corresponding CLP (PL) program Field CLP :
entry (IL2 ) ← {OL2 − IL2 = 1}, entry (OL2 )
does not terminate as the projection of the constraint of its clause onto IL2 or onto
OL2 is the always satisfiable constraint true and we have
Set (⟨entry (OL2 ) | true⟩) ⊆ Set (⟨entry (IL2 ) | true⟩) .

Using non-termination proofs to support termination analysis of Java bytecode
A completely different use of our non-termination tests consists in proving the non- termination of clauses of the PCLP program generated during the termination anal- ysis of a Java bytecode program P . By removing such clauses, which cannot have any termination proof, we help the termination checker by simplifying its task. Since our non-termination tests are extremely efficient, while a thorough quest for a termination proof is in general expensive, the trade-off is positive and we get a more efficient termination analysis still keeping the same precision.
In particular, we have implemented the non-termination tests of Section 3 to help the termination prover BinTerm used in the tool Julia+BinTerm [19]. Given a Java bytecode program P , our approach consists in a preliminary analysis which considers the strongly connected components (SCCs) of PCLP ; any SCC where a

non-terminating ground query is found is removed from PCLP and the resulting
CLP program P'	is analysed by BinTerm.
We have run Julia+BinTerm on the following Java bytecode programs using a Linux machine based on a 2.33GHz Intel Core 2 Duo with 2 gigabytes of RAM.

The next table summarizes the results. For each program P , it reports: the number of clauses removed from PCLP by the non-termination analysis; the non-termination
analysis time; the BinTerm running time on P '	; the BinTerm running time on
PCLP . All the times are in seconds.

In these experiments on large programs, the computational overhead of the non- termination analysis is not important and the running time of BinTerm is smaller

'
CLP
than on PCLP .  For JLex, BinTerm is more than twice faster on P '

than on PCLP , as the non-termination analysis removes 204 clauses from PCLP out
of 356; among the removed clauses, there is a huge SCC containing 122 clauses where the arity of the involved predicate symbols is 8, which explains the gain in efficiency. On the contrary, the clauses removed for Kitten are several but include relatively small components and have small arity, so that the gain in efficiency is not significant there. This is because the cost of the termination analysis increases significantly with the arity of the predicates and, by removing clauses with small arity, we do not affect very much the efficiency of the termination analysis.

Conclusion
In this paper, we have presented some experiments with the automatic derivation of non-termination proofs for Java bytecode programs. When the approximation of the bytecodes into a path-length constraint is exact, the non-termination of the original program can be deduced from that of its CLP translation. When the approximation is not exact, it may happen that the bytecode program terminates while its CLP version does not terminate (Section 4.4 illustrates this situation). As a future work, we plan to replace some non-exact approximations (such as that of the getﬁeld instruction or of the non-linear arithmetic operations) with exact ones

that are suitable for deriving non-termination proofs of Java bytecode programs. To that purpose, a possibility is that of finding specific executions that make the program diverge, instead of proving a universal non-termination. In that direction, we might make some program variables ground, hence linearising some operations. This would be similar to the technique used in [6].
We have also implemented the non-termination tests of Section 3 in order to help the termination prover BinTerm used in the tool Julia+BinTerm. The results we have presented in Section 5 are encouraging; even for some large Java bytecode pro- grams, the computational overhead of the non-termination analysis is unimportant; moreover, the termination prover BinTerm runs much faster when the components detected as non-terminating are removed from the CLP translation of the original bytecode program.

References
Android - An Open Handset Alliance Project, http://code.google.com/android/.
Bol, R. N., K. R. Apt and J. W. Klop, An Analysis of Loop Checking Mechanisms for Logic Programs, Theoretical Computer Science 86 (1991), pp. 35–79.
Cousot, P. and R. Cousot, Abstract Interpretation: A Unified Lattice Model for Static Analysis of Programs by Construction or Approximation of Fixpoints, in: Proc. of the 4th ACM SIGPLAN- SIGACT Symposium on Principles of Programming Languages (POPL’77), 1977, pp. 238–252.

De Schreye, D., K. Verschaetse and M. Bruynooghe, A Practical Technique for Detecting non- Terminating Queries for a Restricted Class of Horn Clauses, using Directed, Weighted Graphs, in: Proc. of ICLP’90 (1990), pp. 649–663.

Giesl, J., R. Thiemann and P. Schneider-Kamp, Proving and Disproving Termination of Higher-order Functions, in: B. Gramlich, editor, Proc. of the 5th International Workshop on Frontiers of Combining Systems (FroCoS’05), Lecture Notes in Artificial Intelligence 3717 (2005), pp. 216–231.

Godefroid, P., N. Klarlund and K. Sen, DART: Directed Automated Random Testing, in: V. Sarkar and M. W. Hall, editors, Proc. of the ACM SIGPLAN 2005 Conference on Programming Language Design and Implementation (PLDI’05) (2005), pp. 213–223.
Gupta, A., T. Henzinger, R. Majumdar, A. Rybalchenko and R. Xu, Proving non-Termination, in:
G. Necula and P. Wadler, editors, Proc. of the 35th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (POPL’08) (2008), pp. 147–158.

Lindholm, T. and F. Yellin, “The JavaTM Virtual Machine Specification,” Addison-Wesley, 1999, second edition.
Payet, E., Loop Detection in Term Rewriting Using the Eliminating Unfoldings, Theoretical Computer Science 403 (2008), pp. 307–327.
Payet, E. and F. Mesnard, A non-Termination Criterion for Binary Constraint Logic Programs, Technical report, IREMIA, Universit´e de La R´eunion (2008), available at http://arxiv.org/abs/0807. 3451.
Payet, E. and F. Mesnard, Non-Termination Inference of Logic Programs, ACM Transactions on Programming Languages and Systems 28, Issue 2 (March 2006), pp. 256–289.
Rossignoli, S. and F. Spoto, Detecting Non-Cyclicity by Abstract Compilation into Boolean Functions, in: E. A. Emerson and K. S. Namjoshi, editors, Proc. of the 7th International Conference on Verification, Model Checking and Abstract Interpretation (VMCAI’06), Lecture Notes in Computer Science 3855 (2006), pp. 95–110.
Secci, S. and F. Spoto, Pair-Sharing Analysis of Object-Oriented Programs, in: C. Hankin and
I. Siveroni, editors, Proc. of Static Analysis Symposium (SAS’05), Lecture Notes in Computer Science
3672, London, UK, 2005, pp. 320–335.


Sen, K., D. Marinov and G. Agha, CUTE: a Concolic Unit Testing Engine for C, in: M. Wermelinger and H. Gall, editors, Proc. of the 10th European Software Engineering Conference held jointly with 13th ACM SIGSOFT International Symposium on Foundations of Software Engineering (2005), pp. 263–272.
Shen, Y.-D., J.-H. You, L.-Y. Yuan, S. Shen and Q. Yang, A Dynamic Approach to Characterizing Termination of General Logic Programs, ACM Transactions on Computational Logic 4 (2003), pp. 417– 434.
Shen, Y.-D., L.-Y. Yuan and J.-H. You, Loops Checks for Logic Programs with Functions, Theoretical Computer Science 266 (2001), pp. 441–461.
Spoto, F., P. M. Hill and E. Payet, Path-Length Analysis for Object-Oriented Programs, in: First International Workshop on Emerging Applications of Abstract Interpretation (EAAI’06), Vienna, Austria, 2006, available at the web address http://profs.sci.univr.it/~spoto/papers.html.
Spoto, F., L. Lu and F. Mesnard, Using CLP Simplifications to Improve Java Bytecode Termination Analysis, submitted for publication to Bytecode’09.
Spoto, F., F. Mesnard and E. Payet, A Termination Analyser for Java Bytecode Based on Path-Length, submitted for publication in August 2007.
Velroyen, H. and P. Ru¨mmer, Non-Termination Checking for Imperative Programs, in: B. Beckert and
R. H¨ahnle, editors, Proc. of the 2nd International Conference on Tests and Proofs (TAP’08), Lecture Notes in Computer Science 4966 (2008), pp. 154–170.
Waldmann, J., Matchbox: A Tool for Match-bounded String Rewriting, in: V. van Oostrom, editor, Proc. of the 15th International Conference on Rewriting Techniques and Applications (RTA’04), Lecture Notes in Computer Science 3091 (2004), pp. 85–94.
Waldmann, J., Compressed Loops (draft) (2007), available at http://dfa.imn.htwk-leipzig.de/ matchbox/methods/.
Zankl, H. and A. Middeldorp, Nontermination of String Rewriting using SAT, in: Proc. of the 9th International Workshop on Termination (WST’07), 2007, pp. 52–55.
Zantema, H., Termination of String Rewriting Proved Automatically, Journal of Automated Reasoning
34 (2005), pp. 105–139.
