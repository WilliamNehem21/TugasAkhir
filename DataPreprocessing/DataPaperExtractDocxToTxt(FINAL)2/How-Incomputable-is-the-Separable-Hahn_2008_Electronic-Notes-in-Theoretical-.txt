

Electronic Notes in Theoretical Computer Science 221 (2008) 85–102
www.elsevier.com/locate/entcs

How Incomputable is the Separable Hahn-Banach Theorem?
Guido Gherardi1,2
Dipartimento di Filosofia Universit`a di Bologna Italy
Alberto Marcone3
Dipartimento di Matematica e Informatica Universit`a di Udine
Italy

Abstract
We investigate some basic connections between reverse mathematics and computable analysis. In particular, we show how to use Weak K¨onig’s Lemma within the framework of computable analysis to classify incom- putable functions of low complexity. By defining the multi-valued function Sep and through the definition of a natural notion of reducibility for multi-valued functions, we obtain a computational counterpart of the subsystem of second order arithmetic WKL0. We study analogies and differences between WKL0 and the class of Sep-computable multi-valued functions. We use these notions to provide a method to determine the computational complexity of the Hahn-Banach Extension Theorem.
Keywords: Computable Analysis, Reverse Mathematics, Weak K¨onig’s Lemma, Hahn-Banach Extension Theorem, multi-valued functions.


1	Introduction
In this paper we tackle a problem in computable analysis ([19] is the main reference in the area) borrowing ideas and proof-techniques from the research program of reverse mathematics ([17] is the standard reference). The two subjects share the goal of classifying complexity of mathematical practice. Reverse mathematics was started by Harvey Friedman in the 1970’s ([7]). It adopts a proof-theoretic view- point (although techniques from computability theory are increasingly important

1 We would like to thank V. Brattka for profitable discussion on the subject.
2 Email: guido.gherardi@unibo.it
3 Email: alberto.marcone@dimi.uniud.it

1571-0661© 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.12.009

in the subject) and investigates which axioms are needed to prove a given theorem. On the other hand, computable analysis extends to computable separable metric spaces the notions of computability and incomputability by combining concepts of approximation and of computation. To this end the representation approach (type-2 theory of effectivity, TTE), introduced for real functions by Grzegorczyk and La- combe ([8,12]), is used. This approach provides a realistic and flexible model of computation.
One of the goals of computable analysis is to study and compare degrees of in- computability of (possibly multi-valued) functions between separable metric spaces. Multi-valued functions are the appropriate way of dealing with situations where problems have non-unique solutions and have been studied in computable analy- sis since [19]. In this paper we introduce a notion of computable reducibility for multi-valued functions which generalizes at once both notions of reducibility for single-valued functions extensively studied by Brattka in [3].
Let f : ⊆X ⇒ Y 4 and g : ⊆U ⇒ V be (partial) multi-valued functions, where X, Y, U, V are separable metric spaces. We say that f is computably reducible to g, and write f ≤c g, if there are computable multi-valued functions h : ⊆X ⇒ U and k : ⊆X × V ⇒ Y such that k(x, g(h(x))) ⊆ f (x) (see Definition 2.1 below for the definition of composition of multi-valued functions) for all x ∈ dom(f ). We use
<c and ∼=c to denote the strict order and the equivalence relation defined in the
obvious way.
In [4] Brattka started the study of the separable Hahn-Banach Theorem from the viewpoint of computable analysis. Given a computable separable Banach space
X consider a multi-valued function HX mapping a closed linear subspace A of
X and a bounded linear functional f : A → R with f  = 1 to the set of all bounded linear functionals g : X → R which extend f and are such that g  =
1. For many computable separable Banach spaces X, it turns out that HX is incomputable. Brattka does not establish precisely the degree of incomputability of these functions, as he shows, in our terminology, that for every X, HX <c C1. Here
C1 is a standard function considered in computable analysis, the first in a sequence
(Ck) of increasingly incomputable functions: for every k ∈ N let Ck : NN → NN be defined by
C (p)(n) = ⎧⎨ 0 if ∃nk ∀nk−1 ∃nk−2 ... Qn1 p(⟨n, nk, nk−1,..., n1⟩) /= 0;
otherwise.
where Q is ∃ when k is odd and ∀ when k is even.
We generalize Brattka’s approach and consider the following “global separable Hahn-Banach multi-valued function” HB: HB takes as input a separable Banach space X, a closed linear subspace A ⊆ X and a bounded linear functional f : A → R of norm 1, and gives as output the bounded linear functionals g : X → R which extend f and are such that  g  = 1.

4 The notation f : ⊆X ⇒ Y means that f is a multi-valued function with dom(f ) ⊆ X and ran(f ) ⊆ Y . Following [19, §1.4], we view a partial multi-valued function f : ⊆X ⇒ Y as a subset of X × Y . When x ∈ dom(f ) we have f (x)= { y ∈ Y | (x, y) ∈ f }.

Reverse mathematics suggests a plausible representative for the degree of in- computability of HB. To see this, recall that reverse mathematics singled out five subsystems of second order arithmetic: in order of increasing strength these are RCA0, WKL0, ACA0, ATR0 and Π0 − CA0. Most theorems of ordinary mathematics are either provable in the weak base system RCA0 or are equivalent, over RCA0, to one of the other systems. Computable functions naturally correspond to RCA0 and is easy to see that C1 (and indeed any Ck with k > 0) corresponds to ACA0 (the correspondence between a system and a function will be made precise in Section 3 below). Brown and Simpson ([6]) showed that, over the base theory RCA0, the Hahn-Banach Theorem for separable Banach spaces is equivalent to WKL0. Thus to define a representative for the incomputability degree of HB we could look for a function in computable analysis corresponding to WKL0.
We consider the multi-valued function Sep : ⊆NN × NN ⇒ 2N defined on
{ (p, q) ∈ NN × NN | ∀n ∀m p(n) /= q(m) } by
Sep(p, q) = { r ∈ 2N | ∀n(r(p(n)) = 0 ∧ r(q(n)) = 1) }.
In other words, the domain of Sep is the collection of pair of functions from the nat- ural numbers into themselves (i.e. of elements of Baire space) with disjoint ranges, and, for any such pair (p, q), Sep(p, q) is the set of the characteristic functions of sets of natural numbers (i.e. elements of Cantor space) separating the range of p and the range of q. Thus Sep corresponds to a statement (strictly connected with Σ0- separation) which is well-known to be equivalent to WKL0 (see [17, Lemma IV.4.4]). Sep is not computable, and using our definition of computable reducibility between multi-valued functions we obtain, as expected, Sep <c C1.  We also show that
Sep ∼=c Path2, where Path2 is the multi-valued function associating to an infinite subtree of 2<N the set of its infinite paths. Moreover we prove that Sep ∼=c HB,
establishing the degree of incomputability of the separable Hahn-Banach Theorem.
The “reversal” in Brown and Simpson’s result (i.e. the proof that the separable Hahn-Banach Theorem implies WKL0) is based on a construction due to Bishop, Metakides, Nerode and Shore ([13]) and appears also in [17, Theorem IV.9.4]. We exploit the ideas of this proof to show Sep ≤c HB. The original proof by Brown and Simpson of the “forward direction” (showing that WKL0 proves the separable Hahn-Banach Theorem) has been simplified first by Shioji and Tanaka ([16], this is essentially the proof contained in [17, §IV.9]) and then by Humphreys and Simp- son ([11]). No details of these or other proofs of the Hahn-Banach Theorem are needed for showing HB ≤c Sep. Brattka noticed the possibility of avoiding these details in [4] and wrote: Surprisingly, the proof of this theorem does not require a constructivization of the classical proof but just an “external analysis”. We explain this fact by observing that the computable analyst is allowed to conduct an un- bounded search for an object she is guaranteed to exist by her (nonconstructive) mathematical knowledge, whereas the reverse mathematician has the burden of an existence proof with limited means. We give another instance of this phenomenon in Example 3.8 below.
Of course, each of the mathematical objects mentioned above needs some “cod- ing” (in reverse mathematics jargon) or “representation” (using computable analysis

terminology). In this respect the computable analysis and the reverse mathematics traditions have developed slightly different approaches to separable Banach spaces.
The plan of the paper is as follows. Section 2 deals with multi-valued functions and computable reductions among them. In Section 3 we compare reverse math- ematics and computable analysis. We show the analogies of the two approaches but also that results cannot be translated authomatically in either direction. The multi-valued function Sep is studied in Section 4. Section 5 sets up the study of
Banach spaces in computable analysis, while Section 6 shows that HB ∼=c Sep.

Notation for sequences
Let N<N be the set of all finite sequences of natural numbers. When s ∈ N<N we use |s| to denote its length and, for i < |s|, s(i) to denote the (i + 1)-th element in the sequence. Let Nn be set of all s ∈ N<N with |s| = n. We use ¯0 to denote the sequence which always takes value 0. When s, t ∈ N<N we write s ± t to mean that s is an initial segment of t. s-t is the sequence obtained by concatenating t after s, and when k ∈ N, s ∗ k abbreviates s- ⟨k⟩, and k ∗ s abbreviates ⟨k⟩ -s. If p ∈ NN and n ∈ N we write p[n] for the sequence ⟨p(0), p(1),..., p(n − 1)⟩∈ Nn.
We define 2N, 2<N and 2n as the subsets of 2N, 2<N and Nn, respectively, whose elements are values in {0, 1}.
We fix a bijection between N<N and N and we identify an element of N<N with the corresponding natural number. We assume that the maps s '→ |s|, (s, i) '→ s(i), k '→ ⟨k⟩, and (s, t) '→ s-t are all computable.
Of course, NN has a natural topology, namely the product topology starting from the discrete topology on N. When we view NN as a topological space we call it the Baire space. Similarly, 2N with the relative topology is the Cantor space.

Multi-valued functions in computable analysis
The main goal of this section is to give the notion of reducibility of multi-valued func- tions. Since we will often compose multi-valued functions, we spell out Weihrauch’s definition for this operation. This definition extends the usual definition of com- position for single-valued functions and appears to be the most useful notion of composition of multi-valued functions.
Definition 2.1 [Composition of multi-valued functions] Given two (partial) multi- valued functions f : ⊆X ⇒ Y and g : ⊆Y ⇒ Z, the composition g ◦ f : ⊆X ⇒ Z is the multi-valued function defined by:
dom(g ◦ f ) = { x ∈ dom(f ) | f (x) ⊆ dom(g) };
∀x ∈ dom(g ◦ f ) (g ◦ f )(x) =  y∈f (x) g(y).
Our definition of computable multi-valued function agrees with [19, Definition 3.1.3.4] and [3, p. 21]. Notice however that Brattka’s paper includes also the defini- tion of Σ0-computable multi-valued function; for single-valued functions the notions

of computable and Σ0-computable coincide, but for arbitrary multi-valued functions the latter is stronger.
Definition 2.2 [Realizers] Let (X, σX ) and (Y, σY ) be represented spaces and f :
⊆X ⇒ Y . A (σX, σY )-realizer for f is a (single-valued) function F : ⊆NN → NN
such that σY (F (p)) ∈ f (σX (p)) for every p ∈ dom(f ◦ σX ).
Notice that in Definition 2.2 we do not require that σX (p) = σX (p') implies σY (F (p)) = σY (F (p')). In other words the realizer F , in general, does not lift to a single-valued function from X to Y which acts as a selector for f .
Definition 2.3 [Computability of multi-valued functions] Let (X, σX ) and (Y, σY ) be represented spaces. A multi-valued function f : ⊆X ⇒ Y is (σX, σY )-computable if it has a computable (σX, σY )-realizer. In practice we often omit explicit mention of the representations and write just computable.

Reducibility of multi-valued functions
We now define the notion of computable reducibility for multi-valued functions. The intuitive idea is that one problem is reducible to another, provided that whenever we have a method to compute a solution for the second problem, we can uniformly find a way to compute a solution for the first one. This generalizes the notion of reducibility between single-valued functions investigated in [3] and extensively used in recent work in computable analysis. Actually, in [3] there are two notions (Defini- tions 5.1 and 7.1) of computable reducibility between single-valued functions. Our definition generalizes the first, and Lemma 2.5 below shows that the generalization of Brattka’s “realizer reducibility” leads to an equivalent concept 5 . Thus the notion of computable reducibility appears to be more robust in the multi-valued setting.
Definition 2.4 [Reducibility of multi-valued functions] Let (X, σX ), (Y, σY ), (Z, σZ), (W, σW ) be represented spaces. Let f : ⊆X ⇒ Y and g : ⊆Z ⇒ W be multi-valued functions. We say that f is computably reducible to g, and write f ≤c g, if there exist computable multi-valued functions h : ⊆X ⇒ Z and k : ⊆X ×W ⇒ Y such that k(x, (g ◦ h)(x)) ⊆ f (x) for all x ∈ dom(f ).
Notice that when f and g are single-valued k is single-valued on { (x, (g ◦ h)(x)) | x ∈ dom(f ) }, but it may be the case that h is not single-valued. Therefore the restriction of our notion of computable reducibility to single-valued functions is weaker than Brattka’s notion of computable reducibility for single-valued functions. However when dealing with multi-valued functions it is natural to allow h and k to be multi-valued as well. As we have pointed out, the following lemma gives further support to our definition, by showing that it coincides with the natural generalization of Brattka’s notion of realizer reducibility.

5 Brattka’s notion of realizer reducibility, as well its generalization to the case of multi-valued functions (Lemma 2.5.(ii)), are particular cases of Wadge’s reducibility for sets of functions as defined in [19, Def. 8.2.5].

Lemma 2.5 Let (X, σX ), (Y, σY ), (Z, σZ), (W, σW ) be represented spaces. Let f : ⊆X ⇒ Y and g : ⊆Z ⇒ W be multi-valued functions. The following are equivalent:
f ≤c g;
there exist computable functions H : ⊆NN → NN and K : ⊆NN × NN → NN such that p '→ K(p, (G ◦ H)(p)) is a realizer for f whenever G is a realizer for g.
Since transitivity of ≤c for multi-valued functions is not immediately obvious, we state it explicitly.
Lemma 2.6 ≤c is transitive.
Thus ≤c is a preorder (reflexivity is obvious) and we can give the usual defini- tions.
Definition 2.7 As usual we use <c and ∼=c for the strict relation and the equiva- lence relation arising from ≤c.
We now give two simple lemmas about ≤c.
Lemma 2.8 Let f, g : ⊆X ⇒ Y be multi-valued functions such that dom(f ) ⊆
dom(g) and g(x) ⊆ f (x) for every x ∈ dom(g). Then f ≤c g.
Lemma 2.9 Let h : ⊆X ⇒ Y and g : ⊆Z ⇒ W be computable multi-valued functions. For any multi-valued function f : ⊆Y ⇒ Z we have (g ◦ f ◦ h) ≤c f.
Our definition of Σ0 -computability for multi-valued functions is motivated by the characterization of this notion for singled-valued functions of Theorems 5.5 and
7.6 (one for each notion of reducibility) in [3]. The reader should however be aware
that Brattka defined a notion of Σ0 -computability for multi-valued functions which is properly stronger than ours ([3, Definition 3.5]).
Definition 2.10 [Σ0 -computable and Σ0 -complete] Let k ≥ 1 and (X, σX ), (Y, σY )
k	k
be represented spaces. A multi-valued function f : ⊆X ⇒ Y is Σ0 -computable if
f ≤c Ck−1, and Σ0-complete if f ∼=c Ck−1.
Lemma 2.5 above and Theorem 7.6 in [3] imply that a multi-valued function is Σ0 -computable if and only if it has a Σ0 -computable realizer.
k	k
Reverse mathematics and computable analysis
Correspondence between subsystems of second order arithmetic and functions
Many mathematical statements can be expressed in the language of second order arithmetic in the form
∀X(ψ(X) =⇒ ∃Y ϕ(X, Y ))

where X and Y range over sets of natural numbers. Here are a few examples (we use the standard coding techniques for expressing in the language of second order arithmetic functions, real numbers, sequences, etc.):
the statement of Weak K¨onig’s Lemma (the main axiom of WKL0) is
∀T (T is an infinite binary tree ⇒ ∃pp is a path in T );
the existence of the range of any function is
∀p(p : N → N ⇒ ∃Y ∀m(m ∈ Y ⇐⇒ ∃nm = p(n)));
the existence of the least upper bound for any sequence in I = [0, 1] is
∀ ⟨xn : n ∈ N⟩ (∀nxn ∈ I ⇒ ∃x(∀n xn ≤ x ∧ ∀k ∃nx < xn + 2−k));
separation of disjoint ranges is
∀p, q(∀n, mp(n) /= q(m) ⇒ ∃Y ∀n(p(n) ∈ Y ∧ q(n) ∈/ Y ));
the statement of the Heine-Borel compactness of the interval I is

∀ ⟨Ik : k ∈ N⟩ (∀k Ik ⊆ I is an interval with rational endpoints ∧

∧I =   Ik ⇒ ∃nI =   Ik)
k∈N	k<n
the statement of the Hahn-Banach Theorem is

∀X, A, f (X is a Banach space ∧ A is a closed linear subspace of X∧

∧f is a bounded linear functional on A ⇒
⇒ ∃g(g is a bounded linear functional on X extending f ∧ g  =  f  )).
If ∀X(ψ(X) ⇒ ∃!Y ϕ(X, Y )) holds (this is the case in (ii) and (iii) above) it is natural to consider the partial function f : ⊆P(N) → P(N) with dom(f ) =
{ X ∈ P(N) | ψ(X) } such that ϕ(X, f (X)) for every X ∈ dom(f ). When the uniqueness condition fails we could consider all possible functions f with the prop- erties above. However it seems more useful to study the multi-valued function H : ⊆P(N) ⇒ P(N) defined by H(X) = { Y | ϕ(X, Y ) } for all X such that ψ(X).
Remark 3.1 In many cases, including some of the examples given above, it is best to view the domain and the range of H as represented spaces different from P(N), thus unraveling the coding used in the reverse mathematics approach. E.g. the functions arising from examples (i) and (iii) are best viewed respectively as a partial multi-valued function from P(2<N) to 2N and a total single-valued function from IN to I.
We have thus associated to the mathematical statement a function between rep- resented spaces which can be studied within the framework of computable analysis. Notice that the lack of restrictions on the complexity of ψ corresponds to the prin- ciple of computable analysis stating that “the user is responsible for the correctness of the input” (see [9, §6] for a discussion).

We can also reverse the procedure. If we want to study from the viewpoint of computable analysis a multi-valued function f : ⊆X ⇒ Y , we can look at the reverse mathematics of the statement
∀x(x ∈ dom(f ) ⇒ ∃y ∈ Y y ∈ f (x)),
with the hope of gaining some useful insight. E.g. if k ≥ 1, from Ck we obtain the statement
∀p(p ∈ NN ⇒ ∃q ∈ 2N ∀n(q(n) = 0 ⇐⇒
⇐⇒ ∃nk ∀nk−1 ∃nk−2 ... Qn1 p(⟨n, nk, nk−1,..., n1⟩) /= 0)), which is easily seen to be equivalent (over RCA0) to Σ0 -comprehension.
In any case, we expect some connection between the proof-theoretic strength of the statement and the computability strength of the function.
Notice that statements corresponding to functions belonging to different degrees of incomputability may collapse into a single system of reverse mathematics. Indeed, for any k ≥ 1, the statement obtained above in correspondence with Ck is equivalent to arithmetic comprehension. This means that each Ck with k ≥ 1 corresponds to
ACA0, while is well-known that Ck <c Ck+1. In other words, at the level of ACA0
computable analysis is finer than reverse mathematics.
The correspondence between proof-theoretic and computable equivalence is more useful when we are at the level of RCA0 or WKL0. First, the computable sets are the intended ω-model of RCA0, which is therefore a formal version of computable mathematics. Hence we expect that a statement provable in RCA0 gives rise to a computable function. Second, we expect most statements equivalent to WKL0 to give rise to computably equivalent uncomputable functions.
Sometimes these expectations are fulfilled, and some reverse mathematics proofs even translate naturally into computable analysis proofs: this is the case with The- orems 4.5 and 6.11 below. However the existence of this translation cannot be taken for granted, and for each direction of the correspondence we give examples of failures. In other words, no automatic translation from the reverse mathematics literature to computable analysis, or viceversa, is possible. This phenomenon is a consequence of the different methods and goals of the two approaches. On one hand, the subsystems of second order arithmetic studied in reverse mathematics use freely classical principles with no algorithmic content, such as excluded middle and proofs by contraposition. On the other hand, the algorithms of computable analysis may assume the existence of the objects they have to compute, without the need of proving it. The examples of failure of the correspondence below highlight these differences.

Success of the correspondence
An often-used equivalent of ACA0 is the statement that the range of every one-to-one function from N to N is a set. Using the approach described above this translates into the following function.
Definition 3.2 [Range] Let Range : ⊆NN → 2N be the function that maps any

one-to-one function to the characteristic function of its range, i.e.
Range(p)(n) = ⎧ 1, if ∃m p(m) = n;
0, otherwise.
for every injective p : N → N and every n.
As expected, we have the following Lemma.
Lemma 3.3 Range ∼=c C1.
A basic example of reverse mathematics deals with the existence of least upper bounds of bounded sequences of real numbers. Indeed, this mathematical principle turns out to be equivalent to ACA0 ([17, Theorem III.2.2]). We now show how this equivalence translates into computable analysis.
Definition 3.4 [Sup] Let Sup : IN → I be the function that maps any sequence in IN to its least upper bound.
Theorem 3.5 C1 ∼=c Sup.

Failure of the correspondence
We now exhibit some examples where the correspondence outlined above fails. We first show that sometimes functions arising from statements provable in RCA0 are incomputable.
Example 3.6 The following function, known as the “Allwissenheitsprinzip” (Prin- ciple of Omniscience), has been studied in detail from the viewpoint of computable analysis ([18,14]).
Let Ω : NN → {0, 1} be defined by


Ω(p
) = ⎧⎨ 0 if p = ¯0;
⎩ 1 otherwise.

(we recall that ∀n ¯0(n) = 0.) The incomputability of Ω follows immediately from its discontinuity. On the other hand, the statement corresponding to Ω is
∀p ∈ NN ∃i ∈ {0, 1}(i = 0 ⇐⇒ ∀np(n) = 0),
which is obviously provable in RCA0 (and indeed just from the excluded middle, except for the coding of functions in the language of second order arithmetic).
We now give another example, which is more mathematical, but again has its roots in the use of classical logic in reverse mathematics.
Example 3.7 Let A−(2N) be the hyperspace of closed subsets of 2N represented by negative information (see Definition 5.4 below) and Sel : ⊆A−(2N) ⇒ 2N be the multi-valued function which selects a point from nonempty closed subsets of 2N. In other words Sel(A) = A, but on the left-hand side of this equality A is a closed set

(and hence a single element in the hyperspace), while on the right-hand side it is a set of points in the space 2N.
The statement corresponding to Sel is ∀A ∈ A−(2N)(A /= ∅ → ∃xx ∈ A), which is a tautology, since A /= ∅ is an abbreviation for ∃xx ∈ A, and hence provable in RCA0. On the other hand it follows from Theorem 6.2 below that, if we represent closed sets with respect to negative information (coherently with
the reverse mathematics definition of closed set), Sel ∼=c Sep and hence Sel is
incomputable.
We now give an example of the opposite phenomena: a theorem which is not provable in RCA0 but corresponds to a computable function.
Example 3.8 The Heine-Borel compactness of the interval I is example (v) at the beginning of this section. In reverse mathematics it is well-known that this statement is equivalent to WKL0 ([17, Theorem IV.1.2]). On the other hand in computable analysis it is well-known that the function which maps each countable open covering of I made of intervals with rational endpoints to a finite subcovering is computable ([19]). We sketch the proof, to highlight the difference between the reverse mathematics and the computable analysis approaches in this case.
There exists a computable enumeration (Cn) of all finite open coverings of I consisting of intervals with rational endpoints (notice that in RCA0 we can even prove that the set of all these finite open coverings does exist). If we are given an (infinite) open covering (Uk) of I, where each Uk is an interval with rational endpoints, it suffices to search for j, n ∈ N such that any interval in Cn is Uk for some k ≤ j. Then ⟨Uk : k ≤ j⟩ is the desired finite subcovering.
In this proof our knowledge of the compactness of I insures that the search will sooner or later succeed. From the reverse mathematics viewpoint, the algorithm can be defined in RCA0, but the proof of its termination requires WKL0.
The multi-valued function Sep
For the reader’s convenience, we repeat here the definition of Sep given in the introduction.
Definition 4.1 [Sep] Let Sep : ⊆NN × NN ⇒ 2N be defined by dom(Sep) =
{ (p, q) ∈ NN × NN | ∀n ∀m p(n) /= q(m) },
Sep(p, q) = { r ∈ 2N | ∀n(r(p(n)) = 0 ∧ r(q(n)) = 1) }.
Thus Sep(p, q) is the set of the characteristic functions of the sets separating ran(p) and ran(q).
The following fact follows from standard facts in computability theory (Ω was defined in Example 3.6).
Lemma 4.2 Sep ¢c Ω, and hence Sep is not computable.
We intend to use computable reducibility to Sep as a way of assessing incom- putability of other functions.

Definition 4.3 [Sep-computable and Sep-complete] Let (X, σX ), (Y, σY ) be rep- resented spaces. Then a multi-valued (possibly single-valued) function f : ⊆X ⇒ Y is Sep-computable if f ≤c Sep, Sep-complete if f ∼=c Sep.
To study Sep we introduce the function Path2, which corresponds to Weak K¨onig’s Lemma, i.e. the statement asserting the existence of infinite paths in any infinite binary tree.
Definition 4.4 [Path2] Let InfTr2 ⊆ P(2<N) be the set of all infinite binary trees:
InfTr2 = { T ⊆ 2<N | ∀t ∈ T ∀s ± ts ∈ T ∧ ∀nT ∩ 2n /= ∅ }.
Let Path2 : P(2<N) ⇒ 2N with dom(Path2) = InfTr2 be the multi-valued function mapping each infinite binary tree to the set of its infinite paths:
Path2(T ) = { p ∈ 2N | ∀n p[n] ∈ T }.
The proof of the next theorem follows closely the proof of [17, Lemma IV.4.4].
Theorem 4.5 Sep ∼=c Path2.
We now show the incomparability of Sep and Ω. We already know from Lemma
4.2 that Sep ¢c Ω. Theorem 4.6 Ω ¢c Sep. Corollary 4.7 Sep <c C1.
We point out that the iteration of Sep-computable functions does not increase
the degree of incomputability. Thus the situation is quite different from the case of
the Ci’s, where we have Ci ∼=c C1 ◦ C1 ◦ ... ◦ C1 and hence (recalling that Ci <c Cj
when i < j) Ci <c Ci ◦ Ci for e`very	˛¸	x
i times

Theorem 4.8 Let f : ⊆X ⇒ Y and g : ⊆Y ⇒ Z be Sep-computable multi-valued functions between represented spaces. Then g ◦ f : ⊆X ⇒ Z is Sep-computable.
Banach spaces in computable analysis
Effective metric and Banach spaces
We take the following definition from [19]:
Definition 5.1 [Effective metric space] An effective metric space is a triple (X, d, a) where:
(X, d) is a separable metric space;
a : N → X is a dense sequence in X.
In particular, we have the effective metric space (R, d, aQ), where d(x, y) = |x−y| and aQ is a standard computable enumeration of the set of the rational numbers (we assume that αQ(0) = 0, αQ(1) = 1).

A rational open ball in (X, d, a) is an open ball of the form BX (c; α) = { x ∈ X | d(x, c) < α } with c ∈ ran(a), and α ∈ Q+ ∪ {0}. Let { BX | n ∈ N } be an enumer- ation of the rational open balls in X with the property that there exist computable functions c and r such that BX has center a(c(n)) and radius αQ(r(n)).
If there is no danger of confusion, we often write X in place of (X, d, a).
Definition 5.2 [Effective Banach space] An effective Banach space is a triple (X,  , e) such that:
X is a Banach space with norm  ;
e : N → X is a fundamental sequence, i.e. a sequence whose linear span is dense in X;
(X, d, ae) is an effective metric space, where d(x, y) =  x − y  and ae(s) =
i≤|s| αQ(s(i)) · e(i) for s ∈ N<N.
We will always assume that X is nontrivial, i.e. that  e(i)  /= 0 for some i ∈ N.
Notice that an effective Banach space is necessarily separable.
The domain of the multi-valued function corresponding to the Hahn-Banach Theorem consists of all effective Banach spaces. If this is interpreted naively, we would need a method to code any possible effective Banach space. Clearly, there are “too many” such spaces to allow a well defined single-valued representation and, since the collection of all effective Banach spaces is not even a set, even a multi-representation approach (in the sense of [10]) is questionable.
We can overcome this problem by considering a set which contains all effective Banach spaces up to isomorphism. For this set we can then define a proper single- valued representation. (Notice that this approach is very close to the one used in reverse mathematics, where it is customary to represent mathematical objects by “codes”.) We will adapt Weihrauch’s notion of constructive metric completion (see [19]) to the case of effective Banach spaces.

Constructive Banach completions
For every s ∈ N<N let
cs =	αQ(s(i)) · i
i<|s|
where we are viewing the right-hand side as a formal linear combination of elements of N with scalars in Q. Let C = { cs | s ∈ N<N }.
We define sum on C and scalar multiplication of an element of C by an element of Q in the obvious way. A noted pseudo-normed space is then a pair N = (C,  ) such that   : C → R is a pseudo-norm on C, i.e.:
 cs  = 0 whenever s(i) = 0 for all i < |s| (recall that αQ(0) = 0);
 cs + ct  ≤ cs  + ct  , for all s, t ∈ N<N;
 α · cs  = |α|·cs  for all s ∈ N<N and α ∈ Q. Again, we assume that  cs  /= 0 for some s ∈ N<N.

The pseudo-norm 	 defines a pseudo-metric d over C in the usual way:
d(cs, ct) =  cs − ct  .
We now build the constructive Banach completion of N , as a particular effective Banach space. Let C be the set of all Cauchy sequences of elements of C which satisfy the usual effective requirement:

i	i	j
Define an equivalence relation ∼ on C^ by
(csi ) ∼ (cti ) ⇐⇒ lim d(csi , cti ) = 0,
and notice that this condition is equivalent to ∀id(cs , ct ) ≤ 2−(i−1). We denote by
i	i
[csi ]i∈N the ∼-equivalence class of (csi ). We introduce then the linear operations on
C^/∼ by
[csi ]i∈N + [cti ]i∈N = [csi+1 + cti+1 ]i∈N;
a · [csi ]i∈N = [αQ(nk+i) · csk+i ]i∈N
where a ∈ R, (αQ(ni))i∈N is a Cauchy sequence effectively converging to a, and k
is such that |αQ(n0)| +  cs0  +2 < 2 . We leave to the reader checking that these
k
definitions are meaningful and make C/∼ a vector space (some of the details are spelled out in [17, p.75]).
We further define

 [csi ]i∈N
 Cb/∼ = lim csi 

and one can check that C/∼ is a Banach space. Notice that dCb/∼([csi ]i∈N, [cti ]i∈N) = lim d(csi , cti ).
Define e : N → C^/∼ by e(n) = [c¯0[n]∗1]i∈N (recall that αQ(0) = 0 and
(C^/∼,  Cb/∼, e) is an effective Banach space: the constructive Banach completion
of the noted pseudo-normed space N .
The function cs '→ [cs]i∈N maps C into C/∼ respecting the vector operations and the (pseudo-)norm. Therefore we can view C as the linearly closed dense subspace of C/∼ generated by the fundamental sequence e.
Definition 5.3 [The space of all effective Banach spaces] Let BS be the set of all constructive Banach completions. This set contains all effective Banach spaces up to isomorphism, and we consider it as the space of all effective Banach spaces.
Consider now the second countable T0-topology on BS with sub-basis given by
the sets of the form:

U⟨i,s,t,j⟩ = { (C^/∼, 
 Cb/∼, e) | αQ(i) < dCb/∼(ae(s), ae(t)) < αQ(j) }

for s, t ∈ N<N and i, j ∈ N. This topology on BS is associated with the standard

representation δBS : ⊆NN → BS defined by δBS (p) = (C^/∼,   b
, e) if and only if

p enumerates the set

{ ⟨i, s, t, j⟩| (C^/∼,  

Cb/∼, e) ∈ U⟨i,s,t,j⟩ }.

We will often write (X,	, e) ∈ BS, or simply X  ∈ BS, in place of

(C^/∼, 
 Cb/∼, e) ∈ BS, but we always understand that the construction of X as

a constructive Banach completion gives a unique norm and a unique fundamental sequence.
An element in BS with a computable name is a computable Banach space in the sense of [4]. Since we see BS as the space of all effective Banach spaces, we can see the subset of its computable objects as the set of all computable Banach spaces.
Representations of closed and compact sets and of linear bounded functions
We recall some representations of closed and compact subsets of metric spaces which have been widely used in the literature (see e.g.[5]).
Definition 5.4 [Representations of closed sets] For an effective metric space X we denote by A+(X) and A−(X) the hyperspace of closed subsets of X viewed respectively with representations ψX and ψX , where:
+	−
ψX (p) = A if and only if pi ∈ dom(δX ) for all i ∈ N (where pi(j) = p(⟨i, j⟩)) and
A = { δX (pi) | i ∈ N };
ψX (p) = A if and only if X \ A =  BX .
Definition 5.5 [Representations of compact sets] For an effective metric space X we denote by K(X) and K−(X) the hyperspace of compact subsets of X viewed respectively with representations κX and κX , where:

κX (p) = K if and only if p enumerates
X
s(i)
κX (p) = K if and only if p enumerates

∧ ∀i < |s| K ∩ BX

/= ∅ };

{ s | K ⊆  i<|s| BX  }.
Let η be a standard representation of all continuous F : ⊆NN → NN with Gδ- domain, satisfying the utm- and the smn-property (see [19]). We use the customary way to denote continuous functions over metric spaces through their continuous realizers (for the case of partial functions with closed domain, see [20]) and we give the following definition:
Definition 5.6 [Space of partial linear bounded functionals] Let PF be the set of all quadruples (X, A, f, r) (usually written f(X,A,r)) such that
X ∈ BS;
A is a closed linear subspace of X;
f : A → R is linear and bounded;
r =  f  ∈ R 6 .
The representation of PF is defined by δPF (p) = f(X,A,r) if and only if
δBS (p0) = X;
ψX (p1) = A;

6 Recall that the norm f  is defined by f = sup{ |f (x)|| x ∈ A ∧ x =1 }.

η(p2) is a realizer of f ;
δR(p3) = r
(the pi’s were defined in Definition 5.4).

The Hahn-Banach Theorem
We now come to the question of the computational complexity of the Hahn-Banach Theorem. We start by giving the formal definition of the Hahn-Banach multi-valued function.
Definition 6.1 [Hahn-Banach multi-valued function] Let HB : ⊆УJ Σ УJ be the multi-valued function with dom(HB) = {f(X,A,1) ∈ УJ} defined by
HB(f(X,A,1)) = { g(X,X,1) | g T A = f }.
For any computable normed space X, and in particular for any computable Ba- nach space, Brattka ([4]) first proves a computable version of the Banach-Alaoglu Theorem. Then he shows that for any computable Banach space there is a Σ0- computable multi-valued function that maps f to the extensions g which satisfy the requirements of the Hahn-Banach Theorem (although the notion of Σ0-computable multi-valued function is not explicitly used in [4]). We will use the same ideas to show that HB is Sep-computable, but some fundamental modifications are neces- sary.
First, we point out that Brattka’s proof is not uniform, since it breaks up into two cases, depending on whether the dimension of the normed space X is finite or infi- nite. Even for countable vector spaces over Q, the function establishing whether the space is finite-dimensional is not computable, and indeed not even Sep-computable. Since we are interested in evaluating the complexity of a multi-valued function which is defined on all effective Banach spaces, we need to get rid of this dichotomy.

Selecting points in closed subsets of compact sets
We will thus give a uniform structure to Brattka’s proof, simplifying also some steps along the way. In particular, Brattka’s proof uses a multi-valued choice function on compact sets to select elements in the set H(f ) of all the extensions of f (this is the Σ0-computable step in that proof). Actually, in this approach one needs to consider H(f ) as a compact subset of a compact space X. We do not need this step, since the simpler property of being closed in the compact set X is enough to apply a selection multi-valued function which is Sep-computable, by Theorem 6.2 below.
Theorem 6.2 For a computable metric space (X, d, a), let SelK(X) : K(X) × A−(X) Σ X be the multi-valued function
SelK(X)(K, A) = A
(where on the left-hand side A is a member of the hyperspace of the closed subsets of
X, while on the right-hand side is a set of points) with ∅ /= A ⊆ K. Thus, SelK(X)

is the multi-valued function which selects a point from a nonempty closed subset of a compact subset of X. Then SelK(X) is Sep-computable.
Equivalence of Sep and HB
To transform Brattka’s argument into a uniform proof we slightly modify the Ef- fective Independence Lemma by Pour-El and Richards ([15, p.142]) used there.
Lemma 6.3 (Uniform Effective Independence Lemma) For all elements (X,   , e) ∈ BS there exists q ∈ NN such that, letting R = { j > 0 | q(j) = q(0) }, q restricted to N \ R is one-to-one and { (e ◦ q)(j) | j ∈ N \ R } is a (possibly ﬁnite) linearly independent set whose linear span is dense in X.
Let ζ : BS Σ NN be the multi-valued function such that ζ(X,   , e) is the set of all q satisfying the condition above. Then ζ is computable.
The main feature of Lemma 6.3 is that we can uniformly find a sequence of linearly independent vectors whose linear span is dense in X by allowing repetitions of the single element (e ◦ q)(0) and forgetting all occurrences of this element after the first.
Definition 6.4 Let BS+ be the graph of the computable multi-valued function ζ
of Lemma 6.3. In other words,
BS+ = { ((X,    , e), q) ∈ BS × NN | q ∈ ζ(X,    , e) }.
When we write X+ ∈ BS+ we mean that X ∈ BS and X+ = (X, q) for some
q ∈ ζ(X).
Using Lemma 6.3 we obtain a uniform proof of Lemma 3 in [4].
Definition 6.5 [Identity problem] For an effective Banach space (X,  , e) the identity problem for (X,  , e) is the set
I(X,  , e) = { (s, t) ∈ N<N × N<N | ae(s) = ae(t) }.
Lemma 6.6 (Identity problem lemma) Given ((X,    , e), q) ∈ BS+ let e' =
e ◦ q.
The function ((X,    , e), q) '→ e' is computable;
id : (X,    , e) → (X,    , e') and its inverse are uniformly computable in
((X,   , e), q) ∈ BS+;
the function which associates to ((X,   , e), q) ∈ BS+ the characteristic function of I(X,   , e') is computable.
Lemma 6.7 The function which maps every (xn)n∈N ∈ RN to the compact space
  n∈N[−|xn|, |xn|] ∈ K(RN) is computable.
We recall that the Banach-Alaoglu Theorem states that the closed unit ball of the dual space of a normed vector space is compact in the weak* topology. The next theorem is a uniform version of Theorem 6 in [4]. The idea here is that we uniformly embed each closed unit ball of a dual spaces X∗, with X ∈ BS, onto a

closed subset A⊆K, for K compact in RN. Moreover this is done taking into account the change of fundamental sequence provided by Lemma 6.6. In the statement of the theorem the reader should keep in mind that φ restricted to fixed (X, q) ∈ BS+ is this embedding and χ computes its inverse, taking in input also the norm of the functional.
Theorem 6.8 (Uniform Computable Banach-Alaoglu Theorem) Let φ  :
⊆УJ × NN → RN be the function with
dom(φ) = { (g(X,X,r), q) | r ≤ 1 ∧ (X, q) ∈ BS+ }

deﬁned by

φ(g(X,X,r), q) = ((g ◦ ae' )(n)),

where e' = e ◦ q as in Lemma 6.6.
φ is computable and φ(g(X,X,r), q) = φ(g'	' , q) implies g = g' and r = r';
(X,X,r )
there exist computable functions	: BS+ → K(RN) and	: BS+ → A−(RN)
such that X+ ⊆ X+ and φ(g(X,X,r), q) ∈ (˜X, q);
there exists a computable χ : ⊆RN × BS+ × R → УJ × NN such that
dom(χ) =   (an),X+, r  | (an) ∈ X˜+ ∧ r = sup{	| n ∈ N }  ,
and we have always χ((an), (X, q), r) = (g(X,X,r), q) for some function g such that φ(g(X,X,r), q) = (an).
Lemma 6.9 Let H : ⊆УJ × NN → A−(RN) be the function with
dom(H) = { (f(X,A,r), q) | (X, q) ∈ BS+ ∧ r = 1 }

deﬁned by

H(f(X,A,1), q) = { φ(g(X,X,1), q) | g T A = f }.

Then H is computable.
Finally, using the machinery developed above, we obtain the first half of our main result.
Theorem 6.10 HB is Sep-computable.
The proof of the other half of our main result is obtained by adapting the proof of Theorem IV.9.4 in [17].
Theorem 6.11 Sep ≤c HB.

References
Brattka, V., and G. Gherardi, Borel complexity of topological operations on computable metric spaces,
J. Logic Comput. to appear.
Brattka, V., and G. Gherardi, Borel complexity of topological operations on computable metric spaces, in “Computation and logic in the real world”. Proceedings of the third conference Computability in Europe, CiE 2007, Siena, Italy, Lect. Not. Comp. Sci. 4497, 18–23, Springer, Berlin, 2007.

Brattka, V., Effective Borel measurability and reducibility of functions, MLQ Math. Log. Q. 51(1) (2005), 19–44.
Brattka, V., Borel complexity and computability of the HahnBanach Theorem, Arch. Math. Logic 46(7– 8) (2008), 547-564.
Brattka, V., and G. Presser, Computability on subsets of metric spaces, Theor. Comp. Sci. 305 (2003), 43–76.
Brown, D. K., and S. G. Simpson, Which set existence axioms are needed to prove the separable Hahn- Banach theorem?, Ann. Pure Appl. Logic, 31(2-3) (1986), 123–144.
Friedman, H., Some systems of second order arithmetic and their use, in “Proceedings of the International Congress of Mathematicians (Vancouver, B. C., 1974)” vol. 1, 235–242, Canad. Math. Congress, Montreal, Que., 1975.
Grzegorczyk, A., Computable functionals. Fund. Math., 42 (1955), 168–202.
Grubba, T., M. Schr¨oder, and K. Weihrauch, Computable metrization, MLQ Math. Log. Q., 53(4-5) (2007), 381–395.
Grubba, T., and K. Weihrauch, A computable version of Dini’s theorem for topological spaces, in “Computability and Complexity in Analysis”, Informatik Berichte 326, 117–129, FernUniversit¨at Hagen, 2005.
Humphreys, A. J., and S. G. Simpson, Separation and weak Ko¨nig’s lemma, J. Symbolic Logic, 64(1) (1999), 268–278.
Lacombe, D., Extension de la notion de fonction r´ecursive aux fonctions d’une ou plusieurs variables r´eelles, C. R. Acad. Sci. Paris, 240 (1955), 2478–2480.
Metakides, G., A. Nerode, and R.A Shore, Recursive limits on the Hahn-Banach theorem, in “Errett Bishop: reflections on him and his research (San Diego, Calif., 1983)”, Contemp. Math. 39, 85–91, Amer. Math. Soc., Providence, RI, 1985.
Mylatz, U., “Vergleich unstetiger Funktionen in der Analysis”, PhD thesis, FernUniversit¨at Hagen, 1989.
Pour-El, M. B., and J. I. Richards, “Computability in analysis and physics”, Perspectives in Mathematical Logic, Springer-Verlag, Berlin, 1989.
Shioji N., and K. Tanaka, Fixed point theory in weak second-order arithmetic, Ann. Pure Appl. Logic,
47(2) (1990), 167–188.
Simpson, S. G., “Subsystems of second order arithmetic”, Springer-Verlag, Berlin, 1999.
von Stein, T., “Vergleich nicht konstruktiv l¨osbarer Probleme in der Analysis”, PhD thesis, FernUniversit¨at Hagen, 1989.
Weihrauch, K., “Computable analysis”, Texts in Theoretical Computer Science, Springer-Verlag, Berlin, 2000.
Weihrauch, K., On computable metric spaces Tietze-Urysohn extension is computable, in “Computability and complexity in analysis (Swansea, 2000), Lect. Not. Comp. Sci., 2064, 357–368, Springer, Berlin, 2001.
