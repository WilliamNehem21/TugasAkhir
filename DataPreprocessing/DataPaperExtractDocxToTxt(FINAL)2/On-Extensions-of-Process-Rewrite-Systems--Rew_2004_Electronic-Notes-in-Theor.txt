	Electronic Notes in Theoretical Computer Science 98 (2004) 75–88	
www.elsevier.com/locate/entcs




On Extensions of Process Rewrite Systems: Rewrite Systems with Weak Finite-State Unit 1
Mojm´ır Kˇret´ınsky´2	Vojtˇech Rˇeh´ak2	Jan Strejˇcek2
Faculty of Informatics Masaryk University Brno, Czech Republic

Abstract
Various classes of infinite-state processes are often specified by rewrite systems. We extend Mayr’s Process Rewrite Systems (PRS) [13] by finite-state unit whose transition function satisfies some restrictions inspired by weak finite automata. We classify these models by their expressiveness and show how the hierarchy of new classes (w.r.t. bisimilarity) is related to both PRS hierarchy of Mayr and two other hierarchies of PRS extensions introduced in [9,22].
Keywords: process rewrite systems, state extension, infinite state


Introduction
As the state-space infiniteness of concurrent systems has a various, real-life sources (e.g. data manipulation, asynchronous communication, etc.), a moti- vation is to provide adequate representations of concurrent systems as well as to study the possibilities of their formal verification. Concurrent systems can be modelled in a number of ways (e.g. Process Algebras, Petri Nets, etc.), how- ever a unifying view is to interpret them as labelled transition systems (LTS) with possibly infinite number of states. LTS families are often specified via

1 This work has been partially supported by GACˇR, grant No. 201/03/1161.
2 Emails: {kretinsky,rehak,strejcek}@fi.muni.cz


1571-0661 © 2004 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2003.10.008

a variety of rewrite systems and form hierarchies (w.r.t. bisimulation equiva- lence), see for example [5,3,15,13]. Here we employ the classes of infinite-state systems defined by Process Rewrite Systems (PRS, introduced by Mayr in [13]) as they contain a variety of the formalisms studied in the context of formal verification. For surveys of formal verification techniques and results see for example [15,4,2,10,20].
It is possible to extend rewriting mechanisms by a finite-state unit [15,9]. However this extension is very powerful as the state-extended version of PA processes (i.e. the state-extended (1,G)-PRS) has a full Turing-power [1], while unrestricted PRS is not Turing-powerful [13]. One of motivations for introduc- ing state-extended PRS classes can be seen as follows: it is required to specify some process classes which are not explicitly present in PRS hierarchy. This can be exemplified by the class of so called Parallel Push-Down Automata (PPDA) introduced by Moller as a state-extended version of BPP in [15]. Please note BPP forms a proper subclass of PPDA which is properly contained in Petri nets [16]. We also note the problem of bisimulation equivalence on BPP is decidable [6] (the recent results [21,8] show it is PSPACE-complete), while the same problem on their state-extended version is undecidable [15].
In this paper we aim at weakening the strength of state-extension by putting some restrictions on (the transition function of) finite-state unit – we use weak finite automaton as introduced in [17], but used here as a non- deterministic (NFA) rather than alternating one. A NFA A = (Q, Σ , δ, q0,F )
is weak if its state space is partitioned into a disjoint union Q =	Qi, and
there is a partial order ≥ on the collection of the Qi. The transition function δ : Q × Σ → P(Q) is such that if q ∈ Qi and q' ∈ δ(q, a) then q' ∈ Qj, where Qi ≥ Qj. The set F of final states will not play any role in this paper, however recall it is required that Qi ⊆ F or Qi ∩ F = ∅ for each Qi. Due to their con- nections to (modal) logics weak (nondeterministic, alternating,...) automata have been used in several contexts and in fact their slightly modified variants have been employed. For example we refer to [12] where the common fragment of a linear time logic LTL [18] and a branching time logic ACTL (which is a fragment of CTL [7]) is given by exactly those LTL formulae the negation of which can be represented by 1-weak Bu¨chi automaton (automaton is 1-weak if each partition block contains exactly one state). We mention the 1-weak variant only and skip the others as this will serve as a suitable abstraction used in our definition of PRS with weak unit.
In state-extended PRS a finite-state unit keeps a sort of global information accessible to all parallel (ready to be reduced) components of a PRS term. For example different (sub)sets of rewriting rules can be applied depending on the current state of unit. Elsewhere [22] one of the authors of this paper enriched

(pure) PRS by ’monotonically evolving’ unit and showed the introduced fcPRS classes (’fc’ standing for ’finitely constrained’ – see Section 3) are strictly more expressible than the respective classes of PRS provided the respective PRS class does not subsume some notion of ’control state’ as e.g. PDA or Petri Nets do.
Some basic definitions and properties of PRS (taken from[13]) and fcPRS ([22]) are recalled in Sections 2 and 3. We introduce PRS with weak unit (wPRS) and mention state-extended PRS in Section 4. Some relationships between the respective new classes and the already existing ones as well as the (combined) hierarchy of PRS and (relevant classes of) extended PRSs are shown in Section 5.

Process rewrite systems (PRS)
A labelled transition system (LTS) L is a tuple (S, Act, −→, α0), where S is a set of states or processes, Act is a set of atomic actions or labels, −→⊆ S ×Act ×S is a transition relation (written α −a→ β instead of (α, a, β) ∈−→), α0 ∈ S is a distinguished initial state. A state α ∈ S is terminal (or deadlocked,
written α −→) if there is no a ∈ Act and β ∈ S such that α −→ β. We also use the natural generalization α −σ→ β for finite sequences of actions σ ∈ Act∗.
The state α is reachable if there is σ ∈ Act∗ such that α −σ→ α.
A binary relation R on set of states S is a bisimulation [14] iff for each (α, β) ∈ R the following conditions hold:
∀ α' ∈ S, a ∈ Act : α −a→ α' =⇒ (∃β' ∈ S : β −a→ β' ∧ (α', β') ∈ R)
∀ β' ∈ S, a ∈ Act : β −a→ β' =⇒ (∃α' ∈ S : α −a→ α' ∧ (α', β') ∈ R) Bisimulation equivalence on an assumed LTS is the maximal bisimulation (i.e. union of all bisimulations).
Let Const = {X,.. .} be a countably infinite set of process constants. The set T of process terms (ranged over by t,.. .) is defined by the abstract syntax
t = ε | X | t1.t2 | t1  t2,
where ε is the empty term, X ∈ Const is a process constant (used as an atomic process), ’  ’ and ’.’ mean parallel and sequential compositions respectively. The set Const(t) is the set of all constants occurring in a process term t. We always work with equivalence classes of terms modulo commutativity and associativity of ’  ’ and modulo associativity of ’.’ We also define ε.t = t = t.ε and t  ε = t.
We distinguish four classes of process terms: ’1’ stands for terms consist- ing of a single process constant only (i.e. ε /∈ 1), ’S’ are sequential terms – without parallel composition, ’P’ are parallel terms - without sequential com-

position, ’G’ are general terms with arbitrarily nested sequential and parallel compositions.


Definition 2.1 Let Act = {a, b, ·· ·} be a countably infinite set of atomic actions, α, β ∈ {1, S, P, G} such that α ⊆ β. An (α, β)-PRS (process rewrite system) is a pair ∆ = (R, t0), where
R is a finite set of rewrite rules of the form t −a→ t , where t ∈ α, t /= ε, t2 ∈ β are process terms and a ∈ Act is an atomic action,
t0 ∈ β is an initial state.


Unless stated otherwise we assume a given ∆ as in Definition 2.1. We define Const(∆) as the set of all constants occurring in the rewrite rules of ∆ or in its initial state, and Act(∆) as the set of all actions occurring in the rewrite
rules of ∆. We sometimes write (t −a→ t ) ∈ ∆ instead of (t −a→ t ) ∈ R.
1	2	1	2
The semantics of ∆ is given by the LTS (S, Act(∆), −→, t0), where S =
{t ∈ β | Const(t) ⊆ Const(∆)} and −→ is the least relation satisfying the inference rules:


(t1
−a→ t ) ∈ ∆
,
t −a→ t'
,
t −a→ t'
.


t −a→ t
t .t −a→ t' .t

1	2
1 2	1 2

If no confusion can arise, we sometimes speak about “process rewrite system” meaning “labelled transition system generated by process rewrite system”.
The PRS-hierarchy of (α, β)-PRS is depicted as a sub-hierarchy in Figure 1. Some classes included in the hierarchy correspond to widely known models
as Finite State systems (FS), Basic Process Algebras (BPA), Basic Parallel Processes (BPP), Process Algebras (PA), Push-Down Processes (PDA, see [5] for justification), and Petri Nets (PN). The other three classes were introduced (and named) by Mayr [13]. The relationship between the class name and its (α, β)-PRS counter-part is given in Figure 1 as well.
PRS-hierarchy is not strict w.r.t. language equivalence (e.g. both BPA and PDA define the class of ε-free context-free languages). The strictness of the hierarchy w.r.t. bisimularity follows from the results presented (or cited) in [3,15] and from the following two examples [13].


Example 2.2 A PDA system with the initial state U.X which is not bisimilar

to any PAN system (for proof see [13]).
U.X −a→ U.A.X	U.A −a→ U.A.A	U.B −a→ U.A.B

U.X −→b
U.X −→c
U.B.X	U.A −→b
V.X	U.A −→c
U.B.A	U.B −→b
V.A	U.B −→c
U.B.B V.B

U.X −d→ W.X	U.A −d→ W.A	U.B −→d
W.B

V.X −→e
f
W.X −→
V	V.A −a→ V	 V.B −→b	V W	W.A −a→ W	W.B −→b		W

Example 2.3 A Petri net given as (P, P )-PRS with the initial state X  A  B
which is not bisimilar to any PAD process (for proof see [13]).
X	g	a	d	d
−→ X  A  B	Y A −→ Y	X  A −→ Z	Y A −→ Z

X −→c
Y	Y B −→b
Y	X  B −d→ Z	Y B −d→ Z


PRS with finite constraint systems (fcPRS)
In this section we recall the extension of process rewrite systems with finite constraint systems. This extension has been directly motivated by constraint
systems used in concurrent constraint programming (CCP) – see e.g. [19]. A constraint system is a bounded lattice (C, ▶, ∧, tt, ff), where C is the set of constraints, ▶ (called entailment) is an ordering on this set, ∧ is the lub operation, and tt (true), ff (false) are the least and the greatest elements of C respectively (ff ▶ tt and tt /= ff). The constraint system describes a state space and possible evolution of a unit called store.
Definition 3.1 Let α, β ∈ {1, S, P, G} such that α ⊆ β. An (α, β)-fcPRS (PRS with finite constraint system) is a tuple ∆ = (C, R, t0), where
C = (C, ▶, ∧, tt, ff) is a finite constraint system describing the store; the elements of C represent values of the store,
R is a finite set of rewrite rules of the form (t −a→ t , m, n), where t ∈ α, t1 /= ε, t2 ∈ β are process terms, a ∈ Act is an atomic action, and m, n ∈ C are constraints,
t0 ∈ β is a distinguished initial process term.
The semantics of an (α, β)-fcPRS system ∆ = (C, R, t0) is given by the LTS (S, Act(∆), −→, (t0, tt)), where S = {t ∈ β | Const(t) ⊆ Const(∆)} × 

(C z {ff}) and −→ is the least relation satisfying the inference rules:
a

(t1 −→ t2, m, n) ∈ ∆
(t , o) −a→ (t ,o ∧ n)
if o ▶ m and o ∧ n /= ff,

1	2

	(t , o) −a→ (t' , p)
,
  (t , o) −a→ (t' , p)
.

(t t , o) −a→ (t'  t , p)	(t .t , o) −a→ (t' .t , p)
1  2	1  2	1 2	1 2
The two side conditions in the first inference rule are very close to principles used in CCP. The first one (o ▶ m) ensures the rule (t1 −→ t2, m, n) ∈ ∆ can be used only if the current value of the store o entails m (it is similar to ask(m) in CCP). The second condition (o ∧ n /= ff) guarantees that the store stays consistent after application of the rule (analogous to the consistency requirement when processing tell(n) in CCP).
An important observation is that the value of a store can move in a lattice only upwards as o ∧ n always entails o. Intuitively, partial information can
only be added to the store, but never retracted (the store is monotonic).
Also note that an execution of a transition which starts in a state with o on the store and which is generated by a rule (t1 −→ t2, m, n) ∈ ∆ implies that for every subsequent value of the store p the conditions p ▶ m and p ∧ n /= ff
are satisfied (and thus the use of the rule cannot be forbidden by a value of the store in future). The first condition p ▶ m comes from the monotonic behaviour of the store. The second condition comes from the facts that the constraint n in the rule can change the store only in the first application of the rule and that for each subsequent state p of the store p ∧ n = p holds.

PRS with weak finite-state unit (wPRS)

Definition 4.1 Let α, β ∈ {1, S, P, G} such that α ⊆ β. An (α, β)-wPRS (PRS with weak finite-state unit) is a tuple ∆ = (Q, ≥, R, m0, t0), where
(Q, ≥) is partially ordered finite set representing states of weak finite-state unit ; the elements of Q are called w-states,

R is a finite set of rewrite rules of the form mt1
−a→ nt satisfying the

condition m ≥ n, where m, n ∈ Q, t1 ∈ α, t1 /= ε, t2 ∈ β, and a ∈ Act,
m0 ∈ Q, t0 ∈ β, and m0t0 is the initial state of the system.
The semantics of an (α, β)-wPRS ∆ = (Q, ≥, R, m0, t0) is given by the LTS (S, Act(∆), −→, m0t0), where S = {mt | m ∈ Q, t ∈ β, Const(t) ⊆ Const(∆)} and −→ is defined as the least relation satisfying the inference rules:

(mt1
−a→ nt ) ∈ ∆
,
mt1
−a→ nt'
,
mt1
−a→ nt'
.

mt −a→ nt
m(t .t ) −a→ n(t' .t )

The presented notion of weakness corresponds to 1-weakness condition in automata theory (mentioned already in Section 1; the general weak unit with- out considering final states would coincide with standard state-extension as all the states of Q could be included in one partition block). In any transi- tion sequence the w-state components of visited states form a non-increasing sequence w.r.t. ≥ (i.e. can only change finitely many times). However, in contrast to fcPRS, the weak unit can forbid the application of any rewrite rule.
State Extended PRS If we relax from the condition m ≥ n imposed on rewrite rules in Definition 4.1, we get the definition of state-extended (α, β)-PRS (denoted by prefix ’se’). Instead of (1, S)-sePRS, (1,P )-sePRS, ... we also use more traditional abbreviations seBPA, seBPP, .... and we also take up this notation for all the classes of both fcPRS and wPRS introduced earlier.
We remind a motivation of introducing sePRS given in Section 1. Of course, seBPA and seBPP coincides with PDA and PPDA respectively. Also recall that (S,S)-PRS and PDA are equivalent w.r.t. bisimilarity as shown by Cau- cal [5], while seBPP has no bisimulation equivalent counter-part within PRS hierarchy (it is strictly under (P,P)-PRS as shown by Moller in [16]).

Relations between classes, refining hierarchy
We start with some very obvious observations. Given process classes X, Y the notation X ⊆ Y means that every LTS definable in class X can be defined (up to bisimulation equivalence) also in class Y. We say Y is at least as expressive as X.
An immediate observation is the classes FS, PDA and PN have the same expressiveness as the corresponding {fc, w, se} extended classes. We also note that
(α, β)-PRS ⊆ (α, β)-fcPRS ⊆ (α, β)-wPRS ⊆ (α, β)-sePRS
hold for every (α, β)-PRS class (even up to isomorphism). For the second inclusion take an arbitrary (α, β)-fcPRS ∆ with an initial term t0 and a con- straint system C = (C, ▶, ∧, tt, ff). The corresponding (α, β)-wPRS is ∆' =
(C z {ff}, ≥, R', tt,t ), where ≥ = (▶)−1 and R' = {ot −a→ (o ∧ n)t | (t −a→
0	1	2	1
t2, m, n) ∈ ∆ and o ▶ m and o ∧ n /= ff}. The first and third inclusions are
obvious as well.
Relations between the classes of PRS-hierarchy, the corresponding classes extended with finite constraint systems or weak state unit, and the PPDA class (the only class of Moller’s hierarchy not covered by previous formalisms) are depicted in Figure 1. The shape of the hierarchy follows from the defi-


wPRS
¸¸¸¸

fcPRS
¸¸¸

¸¸¸¸
¸¸¸

PRS
¸¸¸
¸¸¸¸

(G, G)-PR¸S	¸¸	¸¸
¸¸¸¸	¸¸¸¸ ¸

wPAD
¸¸	¸ wPAN

¸¸ 
¸¸	¸¸ ¸

 ¸¸¸¸ 
¸¸¸ 

fcPAD	 ¸¸
 ¸¸ fcPAN

¸¸ ¸ 
PAD	¸¸
¸¸¸
¸¸
¸¸ 
   PAN

(S, G)-PR¸S
¸¸¸¸	¸¸¸
   (P, G)-PRS

¸¸¸
¸¸¸	¸¸

¸¸¸¸
¸¸¸
wPA

¸¸	¸¸¸ 
¸¸ 

wPDA=fcPDA=PDA
¸¸¸ 
 ¸¸¸   wPN=fcPN=PN

(S, S)-PRS
  ¸¸¸
fcPA
 ¸ ¸¸¸
(P, P )-PRS

¸ ¸ 
   
¸¸ ¸ 
PA  ¸¸¸¸
¸¸¸
¸

(1, G)-PR¸S
¸¸¸	¸¸ PPDA

¸¸¸
¸¸¸ ¸¸

wBPA
¸¸¸
¸¸ wBPP

    

fcBPA
¸¸¸
¸¸
¸¸¸
fcBPP

BPA
¸¸¸
BPP

(1,S)-PRS
¸¸¸¸
¸¸¸¸
¸¸¸
¸¸
(1,P )-PRS
    
    
   
  

wFS=fcFS=FS
(1, 1)-PRS
Fig. 1. The hierarchy of classes defined by (extended) rewrite formalisms

nitions of included classes and from the relations between considered exten- sions. The strictness of the PRS-hierarchy (w.r.t. bisimulation equivalence) has been proved by Mayr [13]. The strictness of the hierarchy covering classes from PRS-hierarchy and corresponding classes with finite constraint systems has been proved in [22] (with one exception – the strictness between PRS and fcPRS is just a conjecture).
In the rest of this section we show that
there is a PDA system which is not bisimilar to any wPAN system,
there is a PPDA system which is not bisimilar to any wPAD system,
there is a wBPP system which is not bisimilar to any fcPAD system (this proof formulates a property that is a sufficient condition for a PAD to be bisimilar to some PDA),
there is a wBPA system which is not bisimilar to any fcPAN system. These proofs together with the fact that PPDA are strictly less expressive

than PN [16] will finish the proof of the strictness of our hierarchy (with two exceptions – the strictness of the relations between PRS, fcPRS, and wPRS re- mains unproved, although we conjecture the existence of the separating gaps).

PDA non-bisimilar to wPAN
Example 5.1 Let us consider a PDA system of Example 2.2 but having
U.X.Y as the initial state and two more rewrite rules: V.Y −x→ U.X.Y, W.Y −x→
U.X.Y . This system, denoted by ∆1, behaves like that defined in Example 2.2,
but whenever the original system terminates, the enhanced ∆1 is restarted un- der the action x.
Lemma 5.2 There is no wPAN ∆ bisimilar to the PDA ∆1 of Example 5.1.
Proof. To derive a contradiction assume a wPAN ∆ bisimilar to the PDA
∆1. As the weak state unit of ∆ is finite then there exists a reachable state mt of ∆ such that every state reachable from mt has also m as its w-state component (the opposite would imply the infiniteness of the weak state unit).
There exists a word w ∈ {a, b, c, d, e, f }∗ such that mt −w→.x mt', where mt'
is bisimilar to the state U.X.Y of the PDA process ∆1. If the rules labelled
by the action x are removed from ∆ and mt' is taken as the initial state, we obtain the system whose all reachable states have m as w-state component and which is bisimilar to the pushdown process of Example 2.2.
Now let ∆' be a PAN system with the initial state t' and with the set of
rewrite rules consisting of the rules l −v→ r, where (ml −v→ mr) ∈ ∆ and
v ∈ {a, b, c, d, e, f }. It is obvious that this PAN system ∆' is bisimilar to the PDA system defined in Example 2.2 – a contradiction.	 

PPDA non-bisimilar to wPAD
Example 5.3 Let ∆ be a PPDA process with the initial state xA  B  C and the following rewrite rules:
−→ xA  B  C





The rules labelled by g, c, a, b, d correspond to the rules of the Petri net given in Example 2.3. Hence the PPDA ∆ behaves as the mentioned Petri net, but when the Petri net terminates, the PPDA ∆ can remove an arbitrary

number of A and B symbols from the parallel stack and then “restart” the system under action r.
Lemma 5.4 There is no wPAD ∆' bisimilar to the PPDA ∆ of Example 5.3.
The proof is similar to the proof of Lemma 5.2 using the fact the Petri net of Example 2.3 is not bisimilar to any PAD system.

wBPP non-bisimilar to fcPAD
A rewriting system is deadlockable if for each reachable nonterminal state
s (of its underlying LTS) there is a transition from s to a terminal state,
i.e. ∃ a, t : s −a→ t−→ .
Definition 5.5 A sequential subterm t (i.e. t ∈ S) of term g ∈ G is a ready parallel component iff t is a maximal subtree in the syntax tree of term g such that t is not in the right-hand side subtree of any sequential node (i.e. node corresponding to sequential operator). A ready parallel component t is live in a PAD system ∆ if t is not deadlocked (i.e. there is a rule applicable to t).
Intuitively the ready parallel components are defined as the maximal se- quential parts of a PAD process g such that g can perform an action a if and only if some of its ready parallel components can perform the same action a.
Lemma 5.6 Every reachable state of an arbitrary deadlockable PAD system has at most one live ready parallel component.
Proof. Observe that the application of a PAD rewrite rule can only modify one ready parallel component. Hence there is no way how to deadlock more than one live ready parallel component by one application of a PAD rewrite rule.	 
Lemma 5.7 Every deadlockable PAD system is bisimilar to a PDA system.
Proof. An idea is to transform PAD rewrite rules onto corresponding PDA rewrite rules (this is sufficient as for every PAD there is a bisimilar PAD system with a single process constant as the initial process term).
There is only one way to revive a deadlocked parallel component, namely to rewrite adjacent components onto ε. For example if B.C is a deadlocked ready
parallel component of (A.C  B.C).D and (A.C  B.C).D −w→ (ε  B.C).D =
B.C.D then the ready parallel component B.C.D can be live.
Let ∆ be a PAD system and X /∈ Const(∆) be a fresh process constant. Let us consider a rewrite rule of ∆ with the right hand side containing a max- imal subterm of the form l.(t1  t2).r, where t1, t2 ∈ S and l, r can be ε. In

an arbitrary transition sequence the components t1, t2 generated by the appli- cation of the considered rewrite rule become ready at the same time. Thus at least one of them is deadlocked. Let t2 be deadlocked. We replace the subterm l.(t1  t2).r of the rule by l.X.t1.X.t2.r (or just t1.X.t2.r whenever l is ε). The process constant X eliminates any possible (unwanted) interaction of (the tail of) the term l and (the beginning of) the term t1 (or the tail of t1 and the beginning of t2 respectively). Repeating this procedure eliminates all parallel operators from rewrite rules. The resulting PDA system ∆' enriched by rewrite rules of the form X.s −a→ s' for every rule s −a→ s' ∈ ∆' is bisimilar to a given ∆.	 
Example 5.8 Let ∆2 be the wBPP system with the initial state pX and the rules:

pX −→c
pX  A  B	pA −a→ pε	pB −→b
pε	pX −→d  qε

Lemma 5.9 There is no PAD system bisimilar to the wBPP system ∆2 of Example 5.8.
Proof. ∆2 is deadlockable. Due to Lemma 5.7 it suffices to prove there is no PDA system bisimilar to ∆2. This directly follows from the fact that the
∗ ∗ ∗	k l m
language L generated by ∆2 is not context-free (L ∩ c a b d = {c a b d | 0 ≤
l,m ≤ k} is not a context-free language).	 
Lemma 5.10 There is no fcPAD system bisimilar to the wBPP system ∆2
of Example 5.8.
Proof. For the sake of a contradiction we assume a fcPAD ∆ bisimilar to ∆2.
The finiteness of the constraint system used in ∆ implies that there exists a reachable non-terminal state (t, m) of ∆ such that every non-terminal state reachable from (t, m) has also m on the store (the contrary would mean the constraint system is infinite). As (t, m) is non-terminal there exists a word
w ∈ {a, b}∗ such that (t, m) −w→ (s, m) and (s, m) is bisimilar to the initial
state pX of ∆2. The only transitions starting at states reachable from (s, m) and changing the value of the store can be the transitions leading to terminal
states, i.e. the transitions labelled by d. Hence we can directly assume that all
x
rewrite rules of ∆ labelled with x ∈ {a, b, c} have the form (t1 −→ t , tt, tt).
Let ∆' be a PAD system with the set of rewrite rules as
{t1 −x→ t2 | (t1 −x→ t2, tt, tt) ∈ ∆,x /= d} ∪ 
∪ {t1 −d→ Z | (t1 −d→ t2, tt, n) ∈ ∆,n /= ff},
where Z /∈ Const(∆) is a fresh process constant. If we restrict the systems ∆ and ∆' to actions a, b, c then ∆ and ∆' are bisimilar.  Furthermore in every

state q of ∆' reachable under w ∈ {a, b, c}∗ there is atransition labelled by d and starting at q. It suffices to show that this transition is leading to a terminal state.
The state (q, tt) (corresponding to the state q) has a ready parallel compo- nent able to perform an action c. This action cannot be disabled by any action performed by another ready parallel component. Hence there is just one ready parallel component able to perform both c and d. For the same reason this
component is the only one which is able to perform actions a and b if they are enabled in the state (q, tt). The same holds for the state q of ∆'. Moreover the ready parallel component rewritten by the action d is deadlocked by the process constant Z.  Thus the state reached under d is terminal and we get

a PAD system ∆' bisimilar to the wBPP ∆
of Example 5.8 – a contradiction

(see Lemma 5.9).	 

wBPA non-bisimilar to fcPAN
Example 5.11 Let us consider the following wBPA system with initial state
pX.



pX −a→ pAX	pX −→b	pBX	pA −a→ pε	pB −→b	pε
a	b	a'	b'
pA −→ pAA	pA −→ pBA	pA −→ qε	pB −→ qε
a	b	a'	b'
pB −→ pAB	pB −→ pBB	qA −→ qε	qB −→ qε
Lemma 5.12 There is no fcPAN system bisimilar to the wBPA system of Example 5.11.
The proof employs the notion of ready sequential components (an analogue of ready parallel components introduced in Definition 5.5). As the proof is much more technically involved we skip it. The full version of the proof is published in [11].

Conclusion and future work
We have extended Process Rewrite Systems (PRS) [13] by ’weak’ finite-state unit and have classified new classes by their expressiveness. We have shown the refined hierarchy (w.r.t. bisimilarity) containing new classes as well as those generated by both PRS and of two other PRS extensions introduced in [9,22].
We emphasize the results showing that BPP class and its three extensions form a strict (sub)hierarchy w.r.t. bisimulation,
BPP Ç fcBPP Ç wBPP Ç seBPP Ç PN

which is decidable (even PSPACE-complete) on the BPP class and undecidable on the class of state-extended BPP (i.e. PPDA). It remains open for other two classes (i.e. fcBPP and wBPP) and is a subject of our further research. We are motivated by the fact the strictness of two leftmost inclusions can be proved (but is not shown here) even for language equivalence. The strictness of inclusion between wBPP and seBPP on the language equivalence level is just our conjecture.

References
Bouajjani, A., R. Echahed and P. Habermehl, On the verification problem of nonregular properties for nonregular processes, in: Proc. of LICS’95 (1995).
Burkart, O., D. Caucal, F. Moller and B. Steffen, Verification on infinite structures, in:
Handbook of Process Algebra (2001), pp. 545–623.
Burkart, O., D. Caucal and B. Steffen, Bisimulation collapse and the process taxonomy, in:
Proc. of CONCUR’96, LNCS 1119 (1996), pp. 247–262.
Burkart, O. and J. Esparza, More infinite results, Electronic Notes in Theoretical Computer Science 5 (1997).
Caucal, D., On the regular structure of prefix rewriting, Theoretical Computer Science 106
(1992), pp. 61–86.
Christensen, S., Y. Hirshfeld and F. Moller, Bisimulation is decidable for all basic parallel processes, in: Proceedings of CONCUR’93, LNCS 715 (1993), pp. 143–157.
Clarke, E. M. and E. A. Emerson, Design and synthesis of synconization skeletons using branching time temporal logic, in: Proc. IBM Workshop on Logic of Programs, LNCS 131 (1981), pp. 52–71.
Janˇcar, P., Strong bisimilarity on basic parallel processes is PSPACE-complete, in: Proc. of 18th IEEE Symposium on Logic in Computer Science (LICS’03) (2003), pp. 218–227.
Janˇcar, P., A. Kuˇcera and R. Mayr, Deciding bisimulation-like equivalences with finite-state processes, Theoretical Computer Science 258 (2001), pp. 409–433.
Kuˇcera, A. and P. Janˇcar, Equivalence-checking with infinite-state systems: Techniques and results, in: Proc. SOFSEM’2002, LNCS 2540 (2002).
Kˇret´ınsky´, M., V. Rˇeh´ak and J. Strejˇcek, Process Rewrite Systems with Weak Finite-State Unit, Technical Report FIMU-RS-2003-05, Faculty of Informatics, Masaryk University Brno (2003), full version of this paper.
Maidl, M., The common fragment of CTL and LTL, in: Proc. 41th Annual Symposium on Foundations of Computer Science, 2000, pp. 643–652.
Mayr, R., Process rewrite systems, Information and Computation 156 (2000), pp. 264–286.
Milner, R., “Communication and Concurrency,” Prentice-Hall, 1989.
Moller, F., Infinite results, in: Proc. of CONCUR’96, LNCS 1119 (1996), pp. 195–216.
Moller, F., Pushdown Automata, Multiset Automata and Petri Nets, MFCS Workshop on concurrency, Electronic Notes in Theoretical Computer Science 18 (1998).
Muller, D., A. Saoudi and P. Schupp, Alternating automata, the weak monadic theory of trees and its complexity, Theoret. Computer Science 97 (1992), pp. 233–244.


Pnueli, A., The temporal logic of programs, in: Proc. 18th IEEE Symposium on the Foundations of Computer Science, 1977, pp. 46–57.
Saraswat, V. A. and M. Rinard, Concurrent constraint programming, in: Proc. of 17th POPL
(1990), pp. 232–245.
Srba, J., Roadmap of infinite results, EATCS Bulletin (2002), pp. 163–175.
Srba, J., Strong bisimilarity and regularity of basic parallel processes is PSPACE-hard, in:
Proc. STACS 2002, LNCS 2285 (2002), pp. 535–546.
Strejˇcek, J., Rewrite systems with constraints, EXPRESS’01, Electronic Notes in Theoretical Computer Science 52 (2002).
