

Electronic Notes in Theoretical Computer Science 229 (2009) 11–26
www.elsevier.com/locate/entcs

MarCaSPiS: a Markovian Extension of a Calculus for Services
Rocco De Nicola
Dipartimento di Sistemi e Informatica - Universita` di Firenze
Diego Latella
Istituto di Scienza e Tecnologie dell’Informazione “A. Faedo”- Consiglio Nazionale delle Ricerche
Michele Loreti
Dipartimento di Sistemi e Informatica - Universita` di Firenze
Mieke Massink
Istituto di Scienza e Tecnologie dell’Informazione “A. Faedo”- Consiglio Nazionale delle Ricerche

Abstract
Service Oriented Computing (SOC) is a design paradigm that has evolved from earlier paradigms including object-orientation and component-based software engineering. Important features of services are composi- tionality, context-independence, encapsulation and re-usability. To support the formal design and analysis of SOC applications recently a number of Service Oriented Calculi have been proposed. Most of them are based on process algebras enriched with primitives specific of service orientation such as operators for manipulating semi-structured data, mechanisms for describing safe client-service interactions, constructors for composing possibly unreliable services and techniques for services query and discovery. In this paper we show a versatile technique for the definition of Structural Operational Semantics of MarCaSPiS, a Marko- vian extension of one of such calculi, namely the Calculus of Sessions and Pipelines, CaSPiS. The semantics deals in an elegant way with a stochastic version of two-party synchronisation, typical of a service-oriented approach, and with the problem of transition multiplicity while preserving highly desirable mathematical properties such as associativity and commutativity of parallel composition.
We also show how the proposed semantics can be naturally used for defining a bisimulation-based be- havioural equivalence for MarCaSPiS terms that induces the same equalities as those obtained via Strong Markovian Equivalence.
Keywords: Calculi for Service Oriented Computing, Quantitative Analysis of Systems, Stochastic Process Algebras

Introduction
Service Oriented Computing (SOC) is a design paradigm that has evolved from earlier paradigms including object-orientation and component-based software engi-

1571-0661 © 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.07.071

neering. Important features of services are compositionality, context-independence, encapsulation and re-usability. To support the formal design and analysis of SOC applications recently a number of Service Oriented Calculi have been proposed. Most of them are based on process algebras enriched with primitives specific of service orientation such as operators for manipulating semi-structured data, mech- anisms for describing safe client-service interactions, constructors for composing possibly unreliable services and techniques for query and discovery of services, see for example [2,19,6,23,5,21,7,20,3]. These calculi provide clean mathematical foun- dations for modeling typical aspects of service oriented computing like safe service composition, service interaction and service orchestration. Besides qualitative as- pects of service oriented systems it is also important that phenomena related to performance and dependability are addressed to deal with issues related to quality of service. These aspects are particularly relevant for this class of systems because often the latter rely on components interacting over networks where failures are likely and congestion may cause unpredictable delays.
Traditional performance modeling techniques such as queuing networks and stochastic variants of Petri nets are widely adopted to describe performance and dependability models. Their lack of compositionality, however, hinders their usabil- ity when dealing with complex systems consisting of many components: it turns out to be difficult, or even impossible, to “glue” together specifications of system components such that an overall model of the system is obtained. This observation has given rise to the development of stochastic extensions of process algebras (see e.g. [4]), since these formalisms assign great importance to compositionality.
The main contribution of this paper is the introduction of a versatile technique for the definition of structured operational semantics (SOS) of stochastic exten- sions of service oriented calculi that handles the problem of transition multiplicity and considers two-party CCS-like interaction which is typical for service oriented approaches. We illustrate the technique providing a Markovian extension for one of the service oriented calculi namely the Calculus of Sessions and Pipelines [3] (CaSPiS). CaSPiS is a core calculus where sessions and pipelines are viewed as nat- ural constructors for structuring client-service interaction and service orchestration. The stochastic extension of CaSPiS, that we shall call MarCaSPiS, permits an inte- grated analysis of both qualitative and quantitative aspects of formal specifications of services. We define a formal structural operational semantics that is used as the basis for associating a Continuous Time Markov Chain (CTMC) with each MarCaSPiS specification while handling appropriately and naturally the problem of dealing with multiple transitions leading via the same action to the same state. In our approach, the transition relation associates each pair of MarCaSPiS terms and actions to a function from MarCaSPiS terms to transition rates. This function maps each MarCaSPiS term into the rate with which it can be reached from the term at the source of the transition, via the action.
Another aspect that differentiates our work from that, e.g., by [25,24], is the spe- cific choice in the adaptation of the apparent rate approach proposed for a process algebra with multi-party (CSP-like) synchronisation by Hillston [16] to a calcu-

lus with two-party (CCS-like) synchronisation while guaranteeing associativity and commutativity of parallel composition.
We also show how the proposed semantics can be naturally used for defining a bisimulation-based behavioural equivalence on MarCaSPiS terms that induces the same equalities as those obtained via Strong Markovian Equivalence. We do expect that our approach is not limited to MarCaSPiS but can be used in many similar situations where stochastic extensions of calculi are needed.
The rest of the paper is organised as follows. In Section 2, we briefly recall CaSPiS and its informal semantics while in Section 3 we introduce MarCaSPiS and its stochastic semantics. In Section 4 we introduce Rate Aware Bisimulation Equiv- alence. Section 5 concludes the paper. Due to page limitations, for the formal proofs of theorems and lemmata of Section 3 and Section 4 we refer to [10].

CaSPiS: A Calculus of Sessions and Pipelines
CaSPiS (Calculus of Sessions and Pipelines) [3] is a core calculus where sessions and pipelines are viewed as natural tools for structuring client-service interaction and service orchestration. In the following we give a flavour of CaSPiS by means of a small running example. In CaSPiS, service definitions and invocations are written like (nullary) input and output prefixes in the π-calculus [22]. Service deﬁnition and service invocation are respectively rendered as s.P and s.Q, where s is the name of the service. However, differently from π-calculus, P and Q are not continuations but identify the protocols governing the interaction between client (service invoker) and server (service provider). For example:

news.⟨“news item”⟩0	news.(?x)⟨x⟩↑0	(1)

defines respectively a service that, once activated, sends the latest news item and a client invoking the news service, reading the news item and returning it as a result to the enclosing environment.
Synchronisation of s.P and s.Q leads to the creation of a new session, identified
by a fresh name r that can be viewed as a private, synchronous channel binding caller and callee. Since client and service may be far apart, a session naturally comes with two sides, written r D P and r D Q. Synchronisation of client and service in
(1) leads to:
(νr) r D ⟨“news item”⟩0|r D (?x)⟨x⟩↑0	(2)
In CaSPiS, like in π-calculus, names can be restricted. Indeed, (νn)P identifies a process P that uses a private name n. Standard rules for extrusion of private names are used for handling passing of private names among processes.
Processes at the two sides of a session can interact with each other by means of concretions (⟨V ⟩P ) and abstractions ((F )P ): the former produce a value V while the latter read a value matching pattern F . Values produced by P via concretions can be consumed (synchronously) by abstractions in Q, and vice-versa: this permits the description of interaction patterns more complex than the usual one-way and

request-response (provided e.g. by Orc [23] and Web Service technologies). Rules governing creation and scoping of sessions are based on those of the restriction oper- ator in the π-calculus. Values consist of expressions composed of constructors, from a given signature Σ, and names x, y, ..., u, v, .... Constructors f, f', ... are equipped with an integer arity, while names play the role of variables or basic values de- pending on the context. Richer languages of expressions, comprising specific data values and evaluation mechanisms, are easy to accommodate. Patterns (F ) can also contain variables (?x), i.e. (F )P can only read those values V matching pattern
F . This leads to a substitution σ such that match(F, V ) = σ. Here, the pattern- matching function match is defined as expected: match(F, V ) = σ, if σ is the (only) substitution such that dom(σ) = bn(F ) and Fσ = V (where ?xσ = σ(x)).
For the process in (2) the expression (νr) r D ⟨“news item”⟩0|r D (?x)⟨x⟩↑0 eveolves to (νr) r D 0|r D ⟨“news item”⟩↑0 . The remaining activity will then be performed by the client-side of the session: r D ⟨“news item”⟩↑0 will emit “news item” outside the session on the client side, becoming the inert process r D 0 (as already happened to the service side). In fact, values can be returned outside a session to the enclosing environment using the return operator, ⟨· ⟩↑. These values can be sent over sessions, or used to invoke other services, to start new activities. This is achieved using the pipeline operator, written:

P > Q .
Here, a new instance of process Q is activated each time P emits a value that Q can consume. Such new instance runs in parallel with P' > Q, where P' is the continuation of P . For instance, what follows is a client that invokes the service news and then uses the obtained news to invoke the service emailMe:

news.(?y)⟨y⟩↑0 > (?z)emailMe.⟨z⟩0
When a next news item V is received from service news and it is returned by the client as above, the following configuration will be reached:

 r D 0 > (?z)emailMe.⟨z⟩0 |emailMe.⟨V ⟩0
Within sessions, it is also possible to invoke services, thus giving rise to hierar- chies of nested sessions, like r1 D (r2 D P2|r3 D P3).
Iterative behaviour of CaSPiS processes is modelled by means of recursion 1 . Intuitively, process rec X.P behaves like P [rec X.P/X]. The example above can be rewritten as follows:
news.rec X.⟨“news item”⟩X  news.rec Y.(?y)⟨y⟩↑Y > (?z)emailMe.⟨z⟩ (3) After its invocation service news continuously sends “news items” to the client that

1 In the original version of CaSPiS presented in [3] standard π calculus replication is used for modelling iteration. It is a common practice to use recursion for modeling iteration in stochastic and probabilistic calculi, see for instance [14] and [25]

will send a mail for each of the received elements. The formal syntax and semantics of CaSPiS can be found in [3].
MarCaSPiS: Markovian CaSPiS
In this section we propose a Markovian extension of CaSPiS (called MarCaSPiS). In MarCaSPiS, each output activity (service invocation, concretion and return) is equipped with a parameter (a rate, λ ∈ R+) characterising a random variable with a negative exponential distribution, modeling the duration of the activity. Further- more, each input activity (service definition and abstractions) is annotated with a weight (ω ∈ N+): a positive integer that will be used for determining the probability that the specific input is selected when a complementary output is executed.
This choice assigns an active role to output actions and a passive one to input actions. Passive actions have been introduced in stochastic process algebras (see e.g. [16]) to model server activities which can handle any request rate. In this paper we follow the above mentioned approach; in Section 5 we shall see that other choices can be easily accommodated using our approach. The one we are presenting in this paper has been chosen because, in our opinion, it naturally fits with the SOC paradigm.
The stochastic operational semantics of MarCaSPiS is defined by a transition
relation associating to each process P and transition label α a function (denoted by P, Q,. . . ) that maps each MarCaSPiS process to a non negative real number.

Basically, P	α) P and P(Q) = v ∈ R
means that Q is reachable from P via

the execution of α with rate/weight v; on the other hand, P(Q) = 0 means that Q is not reachable from P via α. In the sequel, we will use [P1 '→ v1,..., Pn '→ vn] to denote a function associating vi to Pi and 0 to all the other processes.
As an appetiser to our approach to stochastic semantics, let us consider the parallel composition of processes P = sλ1 .P1 + sλ2 .P2 and Q = sω1 .Q1 + sω2 .Q2. P models a process that can invoke service s either with protocol P1 or with protocol P2 and the duration of these invocations is determined by rates λ1 and λ2. In Q there are two definitions for service s: one with weight ω1 and the other with weight ω2. These weights model the probability of selecting each of the available definitions when service s is invoked.
The transitions corresponding to the possible synchronisations of P|Q on service
s, labeled by ←→s , are the following:

←→s) ˆ

  ω1 

  ω2 

P|Q
((νr)r Q P1|r Q Q1) '→ ω1 +ω2 · λ1, ((νr)r Q P1|r Q Q2) '→ ω1 +ω2 · λ1,
((νr)r Q P2|r Q Q1) '→  ω1  · λ2, ((νr)r Q P2|r Q Q2) '→  ω2  · λ2˜
(4)


The sum of the rates of the above transitions is λ1 + λ2, which is the total rate of invocation of s in P|Q, while the actual rate of each transition is determined by multiplying the rate of output actions (λ1 and λ2) by the probability of selecting the pairing input action. This probability is defined as the weight of the selected
action divided by the total weight of the same actions in the system (  ω1  and

  ω2 
ω1+ω2
ω1+ω2

P, Q ::= A	Guarded Sum	π ::= (F )ω Abstraction
| D	Service Definitions	| ⟨V ⟩λ Concretion

| I	Service Invocations	| ⟨V ⟩↑
Return

| r Q P	Session	A ::= πP | A + A
| P > Q	Pipeline	D ::= sω.P | D + D
| P|Q	Parallel Composition  I ::= sλ.P | I + I
| (νn)P	Restriction
| rec X.P  Recursion
| X	Process Variable
V ::= u | f (V˜ ) (f ∈ Σ)	F ::= ?x| u | f (F˜) (f ∈ Σ) Fig. 1. Syntax of MarCaSPiS processes.
It is important to notice that, when P|Q is combined in parallel with a process
R, that might provide new definitions for s, the synchronisations rates occurring in P|Q have to be updated to take into account the possibility of new synchronisations. This is essential to guarantee standard properties of parallel composition like, for instance, associativity. Indeed, the rules for parallel composition will be defined in such a way that the rates of each action are always updated to consider the role of each partner of the parallel composition.  Finally, the adopted semantics will
guarantee that if P  α) P, then total rate/weight of α in P is sum of all values
in the codomain of P (ΣQ P(Q)), which will be proved finite for each α and P .
Syntax and Stochastic semantics of MarCaSPiS
The syntax of MarCaSPiS is presented in Figure 1, where operators are listed in
decreasing order of precedence while V˜ and F˜ denote a sequence of values and patterns respectively.
Let N be a countable set of names ranged over by n, n', .... Set N contains two disjoint countable sets Nsrv of service names s, s', ... and Nsess of session names r, r' .. ., such that N \ (Nsrv ∪ Nsess) is infinite. The set N \ Nsess is ranged over by x, y, ..., u, v....
The syntax of MarCaSPiS is similar to that of CaSPiS except for CaSPiS output activities, which are enriched with by the rates of exponential distributions, and input activities, which are enriched with weights. We shall also assume that for each process rec X.P , variable X is not bound in P and occurs only guarded, i.e. prefixed by π, sω or sλ. Moreover, for each process P we assume that each session name r occurs in P at most twice and that for each process r D Q, r does not occur in Q. The set of all MarCaSPiS processes will be denoted by C.
Structural congruence ≡ is defined as the least congruence relation induced by the laws in Figure 2. This set of laws contains the structural rules for restriction from the π-calculus, plus the obvious extension of the restriction’s scope extrusion law to pipelines and sessions. For each P ∈C we let [P ] denote its structural congruence class and rep([P ]) the associated representative. We abstract from the particular definition of rep([P ]). We usually write rep[P ] or even P instead of rep([P ]), the intended meaning being clear from the context.



Fig. 2. Structural congruence laws.




The operational semantics of MarCaSPiS processes is defined in terms of the labelled transition relation defined by the rules of Table 1 and Table 2. For each process P and transition label α the relation yields a function P, called the next state function, associating a non-negative real value to each process in C. If the transition label refers to an output activity or a synchronisation activity, this value has to be intended as the transition execution rate. In this case the next state function can be thought of as the row of the rate matrix that will be used for defining the Continuous Time Markov Chain associated to a process P . If the transition label refers to an input activity, the next state function identifies weights used to compute the probability of reaching one of the possible next configurations.
We find it convenient to introduce the following notations and operations on next state functions.


Definition 3.1 For each P, Q : C → R≥0 and P , Q in C, C ⊆ C, we let:
P(C) = ΣP∈C P(P )
∅ denote the constant 0, for each Q ∈ C: ∅(Q) = 0 
[P0 '→ λ0,..., Pn '→ λn] (i /= j → Pi /= Pj) denote the function P : C → R≥0
such that: P(P ) = if P = Pi then λi else 0.
(P + Q)(P ) = P(P )+ Q(P )
(P|Q)(R) = if R = P|Q then P(P ) · Q(Q) else 0
( P·ω1 )(P ) = if ω2 /= 0 then P(P )·ω1 else 0, where ω1, ω2 ∈ R≥0
ω2	ω2
⊕(P) = P(C)
P/≡(P ) = if P = rep[P ] then P([P ]) else 0


In the spirit of SOS, the transitions of a process are determined by com- posing transitions of its sub-processes. For this reason, a specific notation will be used for describing this composition. If op is a process algebra operator, and Q a process, we let P op Q be the function R : C → R≥0 such that: R(R) = if (R = P op Q) then P(P ) else 0. The same for Q op P and op P.
Similarly, we let P[Q/X](R) = Σ{P :P [Q/X]=R} P(P ).

We let L be the set of transition labels α having the following syntax and names:
α ::=	s(r) | s(r)	(service definition/invocation)
|	(V ) | ⟨V ⟩	(value consumption/production)
| r : (V ) | r : ⟨V ⟩ (consumption/production within session r)
| ↑ V	(value return)
| ←→s	(service synchronization)
| ←→r	(session synchronization)
| τ	(silent step)
| (νn)α  (open).

We define names n(α), free names fn(α) and bound names bn(α) as expected; in particular bn(s(r)) = bn(s(r)) = {r} while bn((νn˜)α) = {n˜}∪ bn(α).
Rules (Out),(In), (Ret), (Inv) and (Def) describe the behaviour of concretion, abstraction, return, service definition and service invocation. For instance, rule (Out) states that expression ⟨V ⟩λP evolves to process P with rate λ, while (In) states that if σ = match(V, F ) then (F )ωP evolves to Pσ with weight ω.
Rule (Sum) states that P + Q can behave either like P or like Q. Moreover, rates/weights of each transition are added to take multiplicity into account. For instance:


⟨3⟩.5
0  ⟨3)⟩

[0 '→ .5]
(Out)

⟨3⟩.75
0  ⟨3)⟩

[0 '→ .75]
(Out)
(Sum)

⟨3⟩.5
0 + ⟨3⟩
.75
0  ⟨3)⟩
[0 '→ 1.25]

Rules (S-Out), (S-In) and (S-Ret) respectively state that each output (⟨V ⟩), input ((V )) and return (↑ V ) performed within a session becomes a session output (r : ⟨V ⟩), a session input (r : (V )) and an output.
Rule (S-Pass) states that if P performs a transition labelled α leading to P and α is not an input, an output or a return, and does not contain name r, the same transition is performed by r D P leading to r D P. Rule (P-Pass) behaves similarly.
Rule (P-Sync) governs synchronisation within pipelines. A state R can be reached from P > Q P evolves with τ to P ' and R = P' > Q or P produces a value V (leading to P') that Q can consume (leading to Q') and R = (P ' > Q)|Q'. All the
transitions not involving communication along the pipe are captured by P	τ) P
while the other ones are determined by considering, for each value V , PV and QV

such that P  ⟨V)⟩
P	and Q (V))
QV . Hence, (PV
> Q)|QV
characterises all the

processes reachable from P > Q after a synchronisation on value V while ⊕QV is the
total weight of input of V in Q. Thus, (PV >Q)|QV  characterises the synchronisation rates on V . The complete synchronisation rate is finally obtained by considering all possible values V that P can generate as an output: ΣV (PV >Q)|QV  . This value is finite and computable. Indeed, for each process P the set of values V such that

P  ⟨V)⟩
P and P /= ∅ is finite (see Lemma 3.2).

Rule (Par) states that if α is not a synchronisation action (←→s or ←→r ), the states


(Out)
σ = match(V, F )

(In)

⟨V ⟩ P (V)⟩
[P '→ λ]
(F )ω
P (V))
[Pσ '→ ω]


(Ret)

r /∈ fn(P )

(Inv)

⟨V ⟩† P  †)V
[P '→ λ]
sλ.P  s()r)
[r Q P '→ λ]

r /∈ fn(P )

(Def)
P	α) P Q α) Q

(Sum)

sω.P  s()r)
[r Q P '→ ω]
P + Q α) P + Q

P (V)⟩ P

(S-Out)
P (V)) P

(S-In)

r Q P r:()V ⟩ r Q P
P  †)V  P



(S-Ret)
r Q P r:()V ) r Q P
P	α) P α /= ⟨V ⟩, (V ), † V	r /∈ fn(α)



(S-Pass)

r Q P  (V)⟩
r Q P
r Q P	α) r Q P

P	α)
P α /= ⟨V ⟩,τ 


(P-Pass)
P	τ) P 6V. “P (V)⟩
P , Q (V))
QV ”


(P-Sync)

P > Q  α) P > Q 
P > Q	τ) (P > Q)+Σ 
(PV >Q)|QV 
⊕QV

P	α) P Q α) Q α /= ←→s , ←→r , (νn)α' P|Q  α) P|Q + P|Q

(Par)

←→s
P	P P
s()r)

Pd  P
s()r)

Pi  Q

←→s
Q Q
s()r)

Qi  Q
s()r)
d

←→s
P|Q·⊕P
P |Q·⊕Q
(νr)(P  |Q )
(νr)(P |Q  )
(Call)

P|Q   )
	d  + 	d  + 	d  i  + 	i  d 

⊕(Pd +Qd )
⊕(Pd +Qd )
⊕(Pd +Qd )
⊕(Pd +Qd )

←→r)
←→r)
„	r:()V ⟩
r:()V )
r:()V ⟩
r:()V )	«


P|Q
←→r)
P|Q + P|Q + ΣV

P(V ⟩ |Q(V )
⊕Q(V )	V

P(V ) |Q(V ⟩
⊕P(V )
(S-Sync)

P	α) P n /∈ n(α) α /= τ
←→n)	τ)

 P	Pn  P	P 
(R-Pass)	(Hide)

(νn)P	α) (νn)P
(νn)P	τ) (νn)(P + P)

P	α) P α = (νn˜)⟨V ⟩, (νn˜) † V, (νn˜)r : ⟨V ⟩ n /∈ {n˜} n ∈ fn(V ) (νn)P (νn))α P

(Open)

P [rec X.P/X] α) P
rec X.P	α) P

(Rec)
P ≡ Q Q  α) P
α)
/≡

(Struct)

Table 1
Stochastic Labelled Transition Relation (Part 1)

reachable from P|Q via α are those reachable from P composed in parallel with Q, and the states reachable from Q, composed in parallel with P . Notice that it is crucial to have specific rules for for proving the ∅ derivation when a side of the parallel composition is not able to perform a given action (see below). The rules defined in Table 2) are then introduced for modeling the impossibility of a process to perform a given action. They state that no process is reachable from concretions, abstractions, returns, service definitions and service invocations by a transition that is not labelled by one of the following: ⟨V ⟩, (V ), ↑ V , s(r) or s(r) respectively. Rule (Nil) states that process 0 cannot evolve to any other process while rule (F-Res)

α /= ⟨V ⟩ bn(α) ∩ fn(⟨V ⟩λP )= ∅
⟨V ⟩ P	α) ∅

(F-Out)
α /=† V	bn(α) ∩ fn(⟨V ⟩λP )= ∅
⟨V ⟩† P	α) ∅

(F-Ret)

α = (V ) → ¬match(V, F )  bn(α) ∩ fn(⟨V ⟩λP )= ∅



(F-In)


α /= s(r) bn(α) ∩ fn(sλ.P )= ∅
α)
(F )ω P	∅
α /= s(r)  bn(α) ∩ fn(sω.P )= ∅

sλ.P	α) ∅
(F-Inv)
sω.P	α) ∅
(F-Def)

α	(Nil)	←→n	(F-Res)
0	∅	(νn)P	∅

Table 2
Stochastic Labelled Transition Relation (Part 2)

states that no synchronisation on n can occur in (νn)P . It is easy to show that the operational semantics rules guarantee that for each P ∈ C and for each transition
label α, if f n(P ) ∩ bn(α) = ∅, then there exists P such that P  α) P. Moreover,
side conditions on free names permit avoiding unexpected binding by bound names in α.
Rules (Call) and (S-Sync) model synchronisation of parallel components. These rules are similar to (P-Sync), but they have to take into account local syn-
chronisations occurring in P and Q in order to build the global next state function. Let us consider (Call) for the activation of service s. We first consider the simpli- fied scenario in which no activation of service s can be performed by P or Q alone,

i.e. P
←→s)
∅ and Q
←→s)
∅. In this case, as a simple generalisation of example (4)

we get the rule below:
P s(r)) P


P s(r)) P


Q s(r)) Q


Q s(r)) Q

P|Q
←→s) (νr)(Pd|Qi)+(νr)(Pi|Qd)
⊕(Pd+Qd)

Notice that in the above rule the probabilities obtained from the weights associated to the specific synchronisations (i.e. Pd and Qd) and the total weight of the defi- nitions for service s (i.e. ⊕(Pd + Qd)), are combined with the relevant rates in the
resulting next state function (νr)(Pd|Qi)+(νr)(Pi|Qd) .
d	d
In the general case, when activation of service s can also be performed (locally)

by P , i.e. P
←→s)
P /= ∅, or by Q, i.e. Q
←→s)
Q /= ∅, the total weight to be

used for computing transition probabilities, including those modeling activations of
service s local to P (Q respectively), is ⊕(Pd + Qd). This implies that the next state function for such local activation of service s, namely P|Q (P|Q, respectively) must be first “cleaned up” of (total) weight ⊕(Pd) (⊕(Qd), respectively), relative to P (Q, respectively) alone.
Rule (S-Sync) is similar. However, local synchronisations over session r within P (resp. within Q) cannot take place. Rules (R-Pass), (Hide), and (Open) handle name restrictions. The first rule states that if α does not contain the restricted name, then the next state function of (νn)P is obtained as the restriction of the

next state function of P . Rule (Hide) handles synchronisations in the presence of a private name while (Open) handles extrusion of private names. Finally, rules (Rec) and (Struct) are standard rules for recursion and for handling structural equivalent terms, where P/ ≡ is the next state function obtained by summation of the rates of structurally congruent terms. Notice that Lemma 3.2 and Lemma 3.3 below guarantee finiteness and uniqueness of calculated rates.
We now present some results that guarantee tractability of the proposed oper- ational semantics. Indeed, we show that each process can emit only a finite set of values. Moreover, each process can only evolve into a finite set of processes.
Lemma 3.2 For each P, the set {V |∃P.P ⟨V)⟩ P ∨P	†V) P ∧P /= ∅} is ﬁnite.
Proof. The claim easily follows by induction on the syntax of P .	 
Lemma 3.3 If P	α) P then the set {Q|P(Q) > 0} is ﬁnite.
Proof. The claim easily follows by induction on the definition of 	) by using Lemma 3.2.		 
The following theorem guarantees that if we can prove two different behaviours for P , namely there exists α such that P	α) P and P	α) Q, then these are the
same when one only considers representatives of the classes of equivalent processes (P/≡ = Q/≡).
Theorem 3.4 For each P and α, if there exist P and Q such that P	α) P and
P	α) Q then P	= Q	.
Proof. The statement follows by induction on the syntax of P	 

Generating Continuous Time Markov Chains
As in  previous approaches  to enhance  calculi with  stochastic aspects,  see
e.g. [25,24,8,9], we use transition relation 	) to associate a CTMC to each
MarCaSPiS specification.
A continuous-time Markov chain (CTMC) is a tuple (S, R) where S is a count- able set of states and R a rate matrix assigning non-negative values to pairs of
states, such that Σs'∈S R[s, s'] converges 2 . Intuitively, (S, R) models a stochastic
process where, for any state s ∈ S, whenever Σs'∈S R[s, s'] > 0, the probability
to take an outgoing transition from s by (continuous) time t is 1 − e− Ps'∈S R[s,s']·t,
i.e. the s-residence time is exponentially distributed with rate	s'∈S R[s, s'], and the probability to take a transition from state s to state s', given that s is left,

is P
R(s,s')
. If Σ
R[s, s'] = 0, then s is said to be absorbing, i.e.  if the

process enters state s, it remains in s forever.  In what follows, the rate matrix
function R of any CTMC (S, R) is lifted to sets of states C ⊆ S in the natural way:

R[s, C] d=ef Σ

s'∈C
R[s, s'].



2 Notice that this definition allows self loops in CTMC, i.e. R[s, s] > 0 is allowed; we refer to [1] for details.

For each set of processes C, the CTMC associated to C (CTMC[C]) is obtained by considering the processes reachable from C by means of internal actions (τ ) or
service interactions (←→s ), where structural equivalent terms are identified.
Definition 3.5 For set C ⊆ C, the set of derivatives of C, denoted as Der(C), is the smallest set such that:
C ⊆ Der(C), and if Q ∈ Der(C) and there exists Q such that Q	τ ) Q or

∃s.Q
←→s)
Q: then {Q'
| Q/≡(Q') > 0}⊆ Der(C)



Definition 3.6 For C ⊆ C, the CTMC of C, is defined as CTMC[C] d=ef
where
S d=ef {rep[Q] | Q ∈ Der(C)}
(S, R)

For all P, Q ∈ S and s ∈N 
, if Pτ is such that P	τ) Pτ and, for each s, Ps

←→	srv

is such that P
s) Ps; then: R[P, Q] d=ef Pτ
/≡(Q)+ Σ

s∈Nsrv
Ps/≡
(Q)

Notice that Theorem 3.4 guarantees well-definedness of CTMC[C].

Rate aware bisimulation
One of the key concepts in the theory of process algebras is the notion of behavioural equivalence and congruence which permits identifying different processes exhibiting similar behaviour. These notions have been very useful for formal reasoning about processes, for minimising process representations and for replacing equivalent com- ponents with “better” ones according to specific quality criteria without changing the overall behaviour. For example, one could say that Q is “better” than P if it has fewer states, lower complexity, fewer components, clearer structure, etc.
In the literature, many behavioural equivalences have been proposed which dif- fer in what are considered to be the essential aspects of observable behaviour. More recently, such behavioural equivalences have been extended to Markovian process al- gebras where “better” would refer to better performance relative to specific criteria. In this paper we focus on Strong Markovian Bisimulation Equivalence [16], which has a direct correspondence to the notion of lumpability—a successful minimisation technique—of CTMCs [16,17], and for which efficient algorithms have been devised for computing the best possible lumping [15]. We introduce Rate Aware Bisimula- tion Equivalence as the natural equivalence induced by the next state function and we show that this equivalence implies Strong Markovian Bisimulation Equivalence. We point out that the semantic approach we used in this paper makes the defini- tion of the Rate Aware Bisimulation Equivalence a very simple one. The following definition is recalled from [4].
Definition 4.1 [Strong Markovian bisimilarity] Given generic CTMC (S, R)
An equivalence relation E on S is a Markovian bisimulation on S if and only if for all (s, s') ∈ E and for all equivalence classes C ∈ S/E the following condition holds: R[s, C] ≤ R[s', C].

Two states s, s' ∈ S are strong Markovian bisimilar, written s ∼M s', if and only if there exists a Markovian bisimulation E on S with (s, s') ∈ E .
The definition of Rate Aware Bisimulation Equivalence follows:
Definition 4.2 [Rate Aware Bisimilarity]
An equivalence relation E on C is a rate aware bisimulation if and only if, for each (P, Q) ∈E and for each α, P, Q and for all equivalence classes C ∈ C/E :
P	α) P ∧ Q	α) Q =⇒ P(C) = Q(C)
Two processes P, Q ∈ C are rate aware bisimilar (P ∼ Q) if there exists a rate aware bisimulation E such that (P, Q) ∈ E .
The following theorem guarantees that the proposed equivalence is a congruence for all the operators but for abstractions.
Theorem 4.3 For each P, Q ∈ C, if P ∼ Q then for each V , s, r, n and R: sλ.P ∼ sλ.Q, sω.P ∼ sω.Q; ⟨V ⟩λP ∼ ⟨V ⟩λQ; ⟨V ⟩† P ∼ ⟨V ⟩† Q; r D P ∼ r D Q;
λ	λ
P + R ∼ Q + R; (νn)P ∼ (νn)Q; P|R ∼ Q|R.
The following theorem guarantees that if two processes are rate aware equivalent processes, then the corresponding states in the generated CTMC are strong Marko- vian equivalent. Notice that the reverse is not true.
Theorem 4.4 Let P, Q ∈C and (S, R) = CTMC[{P, Q}]: P ∼ Q =⇒ rep[P ] ∼M
rep[Q]
Proof. The theorem follows by proving that E = {(rep[P ], rep[Q])|P ∼ Q} is a Markovian bisimulation.	 
Rate aware bisimilarity can be used for proving associativity of parallel compo- sition. Indeed, one has to prove that for each P , Q and R, (P|Q)|R ∼ P|(Q|R).
Proposition 4.5 For each P, Q and R, (P|Q)|R ∼ P|(Q|R).
Proof. The	statement	follows	by	proving	that	E	=
{((νn˜)((P, Q)|R), (νn˜)(P |(Q|R))|P, Q, R ∈ C} is a rate aware bisimulation.	 

Variations and Conclusions
In this paper we have presented MarCaSPiS, a stochastic extension of CaSPiS (Cal- culus of Sessions and Pipelines), together with a structured operational semantics that uses a novel technique to deal with the problem of transition multiplicity. The proposed approach is somewhat reminiscent to that of Deng et al. [12] where terms of a CSP-like probabilistic process algebra are associated to a discrete probability distribution over such terms. However, differently from [12], we consider a CCS-like synchronisation in a stochastic context.

In MarCaSPiS, each output activity has been equipped with a rate modeling the duration of the activity. Moreover, input activities have been considered passive, and each of them has been assigned a weight. These weights are used in order to compute the relative probabilities of the involved input activities (service definitions and abstractions). Indeed, the actual probability of an input activity depends on the context in which it is executed. On the other hand, quantitative evaluation normally can be applied only to completely specified models where probabilities are completely none.
Even if in the present paper we have considered a synchronisation mechanism implicitly based on active and passive actions, other synchronisation patterns pro- posed in the literature can be easily dealt with using our approach. For instance, one could associate proper rates both to output and input actions and define the synchronisation rate as a suitable function of such rates.
For instance, if one assumes the synchronisation policy of TIPP [13], where the rate of the synchronisation of two activities with rate r1 and r2 is defined as the product r1 · r2, then the rule (CALL) for service activation reduces to:


←→s
P	P	P
s(r))
Pd	P
s(r))
Pi	Q
←→s
Q	Q
s(r))
Qd	Q
s(r))
i

P|Q
←→s)
P|Q + (νr)(Pd|Qi)+ (νr)(Pi|Qd)+ P|Q


Similarly, one can obtain the synchronisation policy used in PEPA [16], which is based on a CSP-like interaction pattern and on the notions of apparent and minimal rates. The adaptation consists mainly in replacing in the PEPA synchronisation rule the apparent rates relative to the two instances of the synchronisation action with the total-input and total-output rates of the two complementary actions, while keeping the principle of minimal rate. The resulting rule for service synchronisation is:

←→s
P	P	P
s(r))
Pd	P
s(r))
Pi	Q
←→s
Q	Q
s(r))
Qd	Q
s(r))
i

P|Q	τ)  P|Q + P |Q + P |Q + P |Q  · w

where wP = W[Pd, Pi], wQ = W[Qd, Qi], wPQ = W[Pd + Qd, Pi + Qi], and
def min(⊕F, ⊕G )

W[F, G ] =


⊕F · ⊕G

We would like to emphasize that the synchronisation introduced above guar- antees associativity of parallel composition, and that this is instead lost if a more direct adaptation of Hillston’s approach is used and the apparent rate approach is directly applied to CCS-like interaction [18]. This is, for instance, the case of stochastic π-calculus by Priami [25]. Also in this calculus the two-party synchroni- sation paradigm is considered and its semantics is directly inspired by the apparent rate approach of [16]. The stochastic semantics of [25] relies on so-called proved transition systems to deal with transition multiplicity and takes into account also

rates of non-internal actions. Instead, we consider only the rates of τ -transitions for the construction of a CTMC. To a certain extent, such a line has been followed also in later works by Priami when evolutions of π-calculus such as [26,11] were consid- ered for the stochastic modelling of biological systems. However, in that work the synchronisation mechanism differs considerably from the one proposed in our work. Recently, a stochastic extension of COWS [24], Calculus for Orchestration of Web Services has been developed. This calculus is based on correlation sets rather than sessions and pipelines. Also stochastic semantics of COWS is based on proved
transition systems.
The work presented in this paper is a first step towards definition of a set of formal tools for specifying and verifying quantitative properties of service oriented architectures. Indeed, we plan to study stochastic modal logics that permit char- acterising interesting properties of services and that simplifying the formalisation of stochastic properties of MarCaSPiS systems. Moreover, we also plan to develop tools that, in the spirit of [9], permit automatically verifying stochastic behaviours of MarCaSPiS processes by relying on powerful and well studied automatic tools like MRMC and PRISM.

Acknowledgement
This work has been partially funded by the EU project Sensoria (IST-2005-016004), by the EU project Resist/Faerus (IST-2006-026764), by the CNR/RSTL XXL project and by the Italian MUR project FIRB tocai.it.

References
C. Baier, B. Haverkort, H. Hermanns, and J.-P. Katoen. Model-Checking Algorithms for Continuous- Time Markov Chains. IEEE Transactions on Software Engineering, 29(6):524–541, 2003.
M. Boreale, R. Bruni, L. Caires, R. De Nicola, I. Lanese, M. Loreti, F. Martins, U. Montanari, A. Ravara,
D. Sangiorgi, V. Vasconcelos, and G. Zavattaro. SCC: a service centered calculus. In Proc. of WS-FM 2006, volume 4184 of Lect. Notes in Comput. Sci., pages 38–57. Springer, 2006.
M. Boreale, R. Bruni, R. De Nicola, and M. Loreti. Sessions and pipelines for structured service programming. In Proc. of FMOODS’08, Lect. Notes in Comput. Sci., 2008. To appear.
E. Brinksma and H. Hermanns. Process algebra and markov chains. In E. Brinksma, H. Hermanns, and J.-P. Katoen, editors, Euro Summer School on Trends in Computer Science, volume 2090 of Lect. Notes in Comput. Sci., pages 183–231. Springer, 2001.
N. Busi, R. Gorrieri, C. Guidi, R. Lucchi, and G. Zavattaro. Choreography and orchestration conformance for system design. In Proc. of COORDINATION’06, volume 4038 of Lect. Notes in Comput. Sci., pages 63–81. Springer, 2006.
L. Caires and H. Viera. The conversation calculus: A model for service oriented computation. In Proc. of ESOP’08, volume 4960 of Lect. Notes in Comput. Sci., pages 269–283. Springer, 2008.
M. Carbone, K. Honda, and N. Yoshida. Structured communication-centred programming for web serices. In ESOP ’07, volume 4421 of Lect. Notes in Comput. Sci., pages 2–17. Springer, 2007.
R. De Nicola, J.-P. Katoen, D. Latella, M. Loreti, and M. Massink. MoSL: A Stochastic Logic for
StoKlaim. Technical report, ISTI, 2006. Available at http://www1.isti.cnr.it/~Latella/MoSL.pdf.
R. De Nicola, J.-P. Katoen, D. Latella, M. Loreti, and M. Massink. Model checking mobile stochastic logic. Theoretical Computer Science, 382(1):42–70, 2007.


R. De Nicola, D. Latella, M. Loreti, and M. Massink. Marcaspis: a markovian extension of a calculus for services. Technical report, 2008.
P. Degano, D. Prandi, C. Priami, and P. Quaglia. Beta-binders for biological quantitative experiments.
Electronic Notes in Theoretical Computer Science - Proc. of QAPL 2006, 164(3):101–117, 2006.
Y. Deng, R. van Glabbeek, M. Hennessy, C. Morgan, and C. Zhang. Characterising testing preorders for finite probabilistic processes. In Proc. of LICS’07, volume 313-325. IEEE Computer Society, 2007.
N. Glotz, U. Herzog, and M. Rettelbach. Multiprocessor and distributed systems design: The integration of functional specification and performance analysis using stochastic process algebras. In L. Donatiello and R. Nelson, editors, Performaance Evaluation of Computer and Communication Systems, volume 729 of Lect. Notes in Comput. Sci. Springer, 1993.
O. Herescu and C. Palamidessi. Probabilistic Asynchronous π-Calculus. In J. Tiuryn, editor, FoSSaCS 2000, volume 1784 of Lect. Notes in Comput. Sci., pages 146–160. Springer, 2000.
H. Hermanns and M. Siegle. Bisimulation Algorithms for Stochastic Process Algebras and Their BDD- Based Implementation. In ARTS, Lect. Notes in Comput. Sci., pages 244–264. Springer, 1999.
J. Hillston. A compositional approach to performance modelling, 1996. Distinguished Dissertation in Computer Science. Cambridge University Press.
J. Kemeny and J. Snell. Finite Markov Chains. Springer, 1976.
B. Klin and V. Sassone. Structural operational semantics for stochastic process calculi. In Proc. of FOSSACS 2008, volume 4968 of Lecture Notes in Computer Science. Springer, 2008.
I. Lanese, F. Martins, A. Ravara, and V. Vasconcelos. Disciplining orchestration and conversation in service-oriented computing. In Proc. of SEFM ’07, pages 305–314. IEEE Computer Society Press, 2007.
C. Laneve and L. Padovani. Smooth orchestrators. In Proc. of FoSSaCS ’06, volume 3921 of Lect. Notes in Comput. Sci., pages 32–46. Springer, 2006.
A. Lapadula, R. Pugliese, and F. Tiezzi. A calculus for orchestration of web services. In ESOP ’07, volume 4421 of Lect. Notes in Comput. Sci., pages 33–47. Springer, 2007.
R. Milner, J. Parrow, and J. Walker. A Calculus of Mobile Processes, I and II. Information and Computation, 100(1):1–40, 41–77, 1992.
J. Misra and W. R. Cook. Computation orchestration: A basis for wide-area computing. Journal of Software and Systems Modeling, 6(1):83–110, 2007.
D. Prandi and P. Quaglia. Stochastic COWS. In Proc. of ICSOC ’07, volume 4749 of LNCS, 2007.
C. Priami. Stochastic π-Calculus. The Computer Journal, 38(7):578–589, 1995.
C. Priami and P. Quaglia. Beta binders for biological interactions. In V. Danos and V. Sch¨achter, editors, Proc. of CMSB 2004, volume 3082 of Lecture Notes in Computer Science, pages 20–33. Springer, 2005.
