Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 323 (2016) 21–37
www.elsevier.com/locate/entcs

Deductive Argumentation by Enhanced Sequent Calculi and Dynamic Derivations
Ofer Arieli1
School of Computer Science The Academic College of Tel-Aviv
Tel-Aviv, Israel
Christian Straßer2
Institute of Philosophy II Ruhr University Bochum Bochum, Germany

Abstract
Logic-based approaches for analyzing and evaluating arguments have been largely studied in recent years, yielding a variety of formal methods for argumentation-based reasoning. The goal of this paper is to provide an abstract, proof theoretical investigation of logical argumentation, where arguments are represented by sequents, conflicts between arguments are represented by sequent elimination rules, and deductions are made by dynamic proof systems extending standard sequent calculi.
Keywords: logical argumentation, sequent calculi, dynamic derivations.


Introduction
Logical argumentation (sometimes called deductive argumentation) is a logic-based approach for formalizing debates, disagreements, and entailment relations for draw- ing conclusions from argumentation-based settings [8,17,18,20]. The basic entities in this context are called arguments. An argument is a pair of a finite set of formulas (Γ, the support set) and a formula (ψ, the conclusion), expressed in an arbitrary propositional language, such that the latter follows, according to some underlying logic, from the former. As indicated in [1] and [4], this gives rise to the association of arguments with Gentzen’s notion of sequents [13], where an argument is expressed

1 Email: oarieli@mta.ac.il. Supported by the Israel Science Foundation (grant No. 817/15).
2 Email: Christian.Strasser@ruhr-uni-bochum.de. Supported by the Alexander von Humboldt Founda- tion and the German Ministry for Education and Research.

http://dx.doi.org/10.1016/j.entcs.2016.06.003
1571-0661/© 2016 The Author(s). Published by Elsevier B.V.
This is an open access article under the CC BY-NC-ND license (http://creativecommons.org/licenses/by-nc-nd/4.0/).

by a sequent of the form Γ ⇒ψ. Accordingly, logical argumentation boils down to the exposition of formalized methods for reasoning with these syntactical objects.
A first step towards a proof theoretical investigation of sequent-based logical argumentation is done in [3]. In this paper we revise and extend that work. In particular, we introduce a modified proof theoretical approach and show that this approach is better suited to argumentation-based reasoning than that of [3] (see also Note 5 below). For this, in the next section we recall some basic notions be- hind abstract argumentation in general and (sequent-based) logical argumentation in particular. Then, in Section 3 we consider a generic method of drawing conclu- sions from a given set of sequent-based arguments, which is tolerant to different logics, languages, and attack relations among the arguments. This is achieved by introducing the notions of dynamic proofs, which are intended for explicating ac- tual reasoning in an argumentation framework. Unlike ‘standard’ proof methods, the idea here is that an argument can be challenged by a counter-argument, and so a certain sequent may be considered as not derived at a certain stage of the proof, even if it were considered derived in an earlier stage of the proof. In Section 4 we give some demonstrations showing that despite this non-monotonic nature of dynamic derivations one may still draw solid conclusions, which are faithful to the intended semantics of the logical argumentation framework at hand. This is formally proved in Section 5, where several properties of the underlying entailment relations are discussed, including some restricted forms of reflexivity and monotonicity. Finally, in Section 6 we give a brief outlook to future work.
Preliminaries
We start by reviewing the notion of sequent-based argumentation, as defined in [4]. First, we recall the more general notion of abstract argumentation frameworks.

Argumentation Frameworks and Their Semantics
Abstract argumentation frameworks are directed graphs, where the nodes repre- sent (abstract) arguments and the arrows represent attacks between arguments, as defined next.
Definition 2.1 An (abstract) argumentation framework [11] is a pair AF =
⟨Args, Attack⟩, where Args is a denumerable set of elements, called arguments, and Attack is a binary relation on Args, whose instances are called attacks.
Given an argumentation framework, a key issue in its understanding is to de- termine what combinations of arguments (called extensions) can collectively be accepted from it. For this we recall the notions of conflict-freeness and defense.
Definition 2.2 Let AF = ⟨Args, Attack ⟩ be an argumentation framework, A ∈ Args an argument, and E ⊆ Args a set of arguments. We say that E attacks an argument A if there is an argument B ∈ E that attacks A (i.e., (B, A) ∈ Attack ). The set of arguments that are attacked by E is denoted E +. We say that E defends

A if E attacks every argument that attacks A. We denote by Def(E ) the set of all the elements that are defended by E . The set E is called conflict-free if it does not attack any of its elements (i.e., E + ∩E = ∅), E is called admissible if it is conflict-free and defends all of its elements (i.e., E ⊆ Def(E )), and E is complete if it is admissible and contains all the arguments that it defends (E = Def(E )).
The requirements defined above express basic properties that every plausible extension of a framework should have. Intuitively, a set of arguments is conflict-free if all of its elements ‘can stand together’ (since they do not attack each other), and admissibility guarantees that such elements ‘can stand on their own’, i.e., are able to respond to any attack by attacks of their own members (see also [5,6]).
Next, we recall some acceptability semantics for an argumentation framework.
Definition 2.3 [11] Let AF = ⟨Args, Attack⟩ be an argumentation framework.
The minimal complete subset of Args is the grounded extension of AF,
A maximal complete subset of Args is a preferred extension of AF,
A complete subset E of Args that attacks every argument in Args \E is a stable extension of AF.
We denote by Cmpl(AF) (respectively, Grnd(AF), Prf(AF), Stbl(AF)) the set of all the complete (respectively, all the grounded, preferred, stable) extensions of AF.
As shown in [11], an argumentation framework always has a unique grounded extension, but not necessarily a stable extension. If a stable extension does exist, it is also preferred. Other extensions are considered, e.g., in [5,6].
Example 2.4 Consider the following argumentation framework:

Here ∅, {A}, {B} and {B, D} are admissible sets, and with the exception of {B} all of them are also complete. The grounded extension is ∅, the preferred extensions are {A} and {B, D}, and the stable extension is {B, D}.
Sequent-Based Argumentation Frameworks
When it comes to specific applications of formal argumentation it is often useful to provide a specific account of the structure of arguments and the concrete nature of argumentative attacks. As indicated previously, we do so by following the sequent- based approach introduced in [1,4]. By this, we are able to fully abstract the notion of an argument and base it solely on the logical dependency between the support and the conclusion at hand. Furthermore, treating arguments as sequents allows to

incorporate well-established proof theoretical means for automatically constructing, identifying, and reasoning with arguments (see [1,4] for further justifications).
In what follows, we shall denote by L an arbitrary propositional language. Atomic formulas in L are denoted by p, q, r, arbitrary sets of formulas in L are denoted by S, T , and ﬁnite sets of formulas are denoted by Γ, Δ.
Definition 2.5 A (propositional) logic for a language L is a pair L = ⟨L, ▶⟩, where
▶ is a (Tarskian) consequence relation for L, that is, a binary relation between sets of formulas and formulas in L, satisfying the following conditions:
Reflexivity : if ψ ∈S then S ▶ ψ.
Monotonicity : if S ▶ ψ and S ⊆ Sj, then Sj ▶ ψ.
Transitivity : if S ▶ ψ and Sj,ψ ▶ φ then S, Sj ▶ φ.
In addition, we shall assume that L is ﬁnitary , that is: if S ▶ ψ then there is a ﬁnite
theory Γ ⊆S such that Γ ▶ ψ. 3
We shall assume that the language L contains at least the following connectives:
a ▶-negation ¬, satisfying: p /▶ ¬p and ¬p /▶ p (for every atomic p), 4 and
a ▶-conjunction ∧, satisfying: S ▶ ψ ∧ φ iff S ▶ ψ and S ▶ φ.
For a finite set Γ we denote by VΓ the conjunction of all the formulas in Γ.
Arguments As Sequents
There are several ways of defining the structure of an argument. The next definition is derived from the understanding that sequents are useful for representing logical arguments since they can be regarded as specific kinds of judgments (see [1,4] again).
Definition 2.6 Let L = ⟨L, ▶⟩ be a propositional logic and S a set of L-formulas.
An L-sequent (a sequent, for short) is an expression of the form Γ ⇒ Δ, where Γ and Δ are finite sets of L-formulas, and ⇒ is a reserved symbol (not in L).
An L-argument is an L-sequent of the form Γ ⇒ ψ where Γ ▶ ψ.
An L-argument based on S is an L-argument Γ ⇒ ψ, where Γ ⊆ S. The set of all the L-arguments that are based on S is denoted ArgL(S).
Note 1 Clearly, Γ ⇒ ψ ∈ ArgL(S) for some (finite) Γ ⊆S iff S ▶ ψ.
Proof systems that operate on sequents (and so on arguments) are called sequent calculi [13]. The sequent calculi considered here consist of inference rules of the form

(1)
Γ1 ⇒ Δ1 .. . Γn ⇒ Δn .
Γ ⇒ Δ



3 The last property is satisfied by every logic that has a decent proof system, and will be useful in what follows (see, e.g., Note 1).
4 There is no general agreement about the properties that a negation connective should satisfy (see, e.g., the papers collection in [12]). The requirement from a negation connective in this paper is a very minimal one, taken from [2,16].

In what follows we shall say that the sequents Γi ⇒ Δi (i = 1,..., n) are the conditions (or the prerequisites) of the rule above, and that Γ ⇒ Δ is its conclusion. As usual, axioms are treated as inference rules without conditions, i.e., they are rules of the form Γ⇒Δ .
In the sequel we shall usually assume that the underlying logic has a sound and complete sequent calculus, that is, a sequent-based proof system C, such that Γ ▶ ψ iff the sequent Γ ⇒ ψ is provable in C.
Example 2.7 In this paper we shall usually use classical logic (CL) for our demon- strations. Gentzen’s well-known sequent calculus LK, which is sound and complete for CL, is represented in Figure 1.










Fig. 1. The proof system LK


Attacks as Elimination Rules
Different attack relations have been considered in the literature for logical argumen- tation frameworks (see, e.g., [8,14,17]). In our case, attacks allow for the elimination (or, the discharging) of sequents. We shall denote by Γ /⇒ ψ the elimination of the sequent Γ ⇒ψ. Alternatively, s denotes the elimination of s. Now, a sequent elimi- nation rule (or attack rule) has a similar form as an inference rule, except that its conclusion is a discharging of one condition, i.e., it is a rule of the following form:

(2)
Γ1 ⇒ Δ1,..., Γn ⇒ Δn .
Γn /⇒ Δn

The prerequisites of attack rules usually consist of three ingredients. To help the

reader distinguish between these ingredients, we shall write them in a certain or- der: the first sequent in the rule’s prerequisites is the “attacking” sequent, the last sequent in the rule’s prerequisites is the “attacked” sequent, and the other pre- requisites are the conditions for the attack. In this view, conclusions of sequent elimination rules are the eliminations of the attacked arguments.
Example 2.8 Figure 2 lists some elimination rules in the context of logical ar- gumentation systems (see also [4]). Similar rules for deontic logics and normative reasoning can be found in [22]. In this paper we shall exploit only a small number of these rules. We refer to [4,8,14,22] for further demonstrations of their usefulness.

Fig. 2. Sequent elimination rules

Argumentation Settings and the Induced Logical Frameworks
We now combine sequents and elimination rules for defining corresponding argu- mentation frameworks. For this, we need the following definition.
Definition 2.9 An argumentation setting (a setting, for short) is a triple S =
⟨L, C, A⟩, where L= ⟨L, ▶⟩ is a propositional logic, C is a sound and complete sequent calculus for L, and A is a set of attack rules expressed in terms of L-sequents.
Definition 2.10 Let S = ⟨L, C, A⟩ be a setting, S a set of formulas, and θ an
L-substitution (that is, a substitution of atoms in L by formulas in L).
An inference rule R of the form of (1) above is ArgL(S)-applicable (for S, with respect to θ), if for every 1 ≤ i ≤ n, θ(Γi) ⇒ θ(Δi) is C-provable.
An elimination rule R of the form of (2) above is ArgL(S)-applicable (for S, with respect to θ), if θ(Γ1) ⇒ θ(Δ1) and θ(Γn) ⇒ θ(Δn) are in ArgL(S) and for each 1 < i < n, θ(Γi) ⇒ θ(Δi) is C-provable.
In the second case above we shall say that θ(Γ1) ⇒ θ(Δ1) R-attacks θ(Γn) ⇒ θ(Δn). Note that the attacker and the attacked sequents must be elements of ArgL(S).
The induced argumentation framework is now defined as follows:
Definition 2.11 Let S = ⟨L, C, A⟩ be a setting and let S be a set of formulas. The sequent-based (logical) argumentation framework for S (induced by S) is the argumentation framework AFS(S)= ⟨ArgL(S), Attack ⟩, where (s1, s2) ∈ Attack iff there is an R∈ A such that s1 R-attacks s2.
In what follows, somewhat abusing the notations, we shall sometimes identify
Attack with A.

Dynamic Proofs
We now consider the notions of proofs (or derivations) for argumentation settings. In what follows we fix a given setting S= ⟨L, C, A⟩ (so that the underlying logic, a Gentzen-type proof system for it and the elimination rules are pre-determined).
Definition 3.1 A (proof) tuple (also called derivation steps or proof steps) is a quadruple ⟨i, s, J, A⟩, where i (the tuple’s index) is a natural number, s (the tuple’s sequent) is either a sequent or an eliminated sequent, J (the tuple’s justification) is a string, and A (the tuple’s attacker) is an empty-set or a singleton of a sequent.
In what follows we shall sometimes omit the last component of a tuple in case that it is the empty-set, and omit the enclosing parentheses if it is a singleton.
As in ‘standard’ Gentzen-type systems, proofs are sequences of tuples, obtained by applications of rules. In our case, the underlying rules may be either introductory or eliminating, that is, applications of elements in C or A, as defined next.

Definition 3.2 Let S= ⟨L, C, A⟩ be a setting and S a set of formulas in L. A simple (dynamic) derivation (with respect to S and S) is a finite sequence D = ⟨T1,... Tm⟩ of proof tuples, where each Ti ∈D is of one of the following forms:
Introducing Tuples, of the form Ti = ⟨i, θ(Γ) ⇒ θ(Δ), J, ∅⟩, where there is an inference rule R∈ C of the form of (1) above that is ArgL(S)-applicable for some L-substitution θ, and for every 1 ≤ k ≤ n there is a proof tuple ⟨ik, sk, Jk, ∅⟩ in which ik < i and sk = θ(Γk) ⇒ θ(Δk). In this case, J =“R; i1,..., in”.
Eliminating Tuples, of the form Ti = ⟨i, θ(Γn) /⇒ θ(Δn), J, θ(Γ1) ⇒ θ(Δ1)⟩, where there is an elimination rule R ∈ A of the form of (2) above that is ArgL(S)-applicable for some L-substitution θ, 5 and for every 1 ≤ k ≤ n there is a proof tuple ⟨ik, sk, Jk, ∅⟩, in which ik < i and sk = θ(Γk) ⇒ θ(Δk). In this case, J =“R; i1,..., in”.
In the sequel we shall sometimes identify introducing tuples with their derived sequents and eliminating tuples with their attacking sequents.
Given a simple derivation D, we shall denote by Top(D) the tuple with the highest index in D and by Tail(D) the simple derivation D without Top(D). Also, we shall denote by Dj = D ⊕ ⟨T1,..., Tn⟩ the simple derivation whose prefix is D and whose suffix is ⟨T1,..., Tn⟩ (Thus, for instance, when n = 1 we have that T = Top(D⊕T ) and D = Tail(D⊕T )). We call Dj the extension of D by ⟨T1,..., Tn⟩.
To indicate that the validity of a derived sequent (in a simple derivation) is in question due to attacks on it, we need the following evaluation process.
Definition 3.3 Given a simple derivation D, the iterative top-down function Evaluate(D) (see Algorithm 1) computes the following three sets: Elim(D) – the sequents that (at least once in D) are attacked by an attacker which is not al- ready attacked, Attack(D) – the sequents that attack a sequent in Elim(D), and Accept(D) – the derived sequents in D that are not in Elim(D).
Definition 3.4 A simple derivation D is coherent , if Attack(D) ∩ Elim(D)= ∅. 6
Next, we show the adequacy of Algorithm 1 for a derivation D, in terms of the argumentation framework induced by that derivation.
Definition 3.5 Let D be a simple derivation. The sequent-based argumentation framework that is induced by D is the graph AF(D) = ⟨Derived (D), Attack (D)⟩, where s ∈ Derived (D) if there is an introducing tuple ⟨i, s, J, ∅⟩ in D, and (r, s) ∈ Attack (D) if there is an eliminating tuple ⟨i, s, J, r⟩ in D. 7

5 Remember that this means, in particular, that the attacking sequent θ(Γ1) ⇒ θ(Δ1) and the attacked sequent θ(Γn) ⇒ θ(Δn) are both in ArgL(E). This prevents situations in which, e.g., чp ⇒ чp attacks p ⇒ p, although E = {p}.
6 That is, there is no sequent that eliminates another sequent, and later on is eliminated itself.
7 Note that while Derived (Q) is the same as the set Derived(Q) produced by the function Evaluate(Q) (Algorithm 1), Attack (Q) is not the same as the set Attack(Q) produced by that function, since here just the existence of an eliminating tuple merits a directed edge from the attacker to the attacked sequent, no matter whether the attacker is counter-attacked.





















Algorithm 1. Evaluation of a simple derivation
Proposition 3.6 For every simple derivation D the set Accept(D) is conflict-free in AF(D). If D is coherent then Accept(D) is a stable extension of AF(D).
Sketch of proof. We show that Accept(D) has the property defining stable sets, namely that Accept(D) ∪ Accept(D)+ = Derived(D), leaving the other properties (conflict-freeness, admissibility and completeness) to the reader.
Since Derived(D)= Accept(D) ∪ Elim(D), it is enough to show that Accept(D)+
coincides with Elim(D). Indeed,
To see that Elim(D) ⊆ Accept(D)+, let s ∈ Elim(D). Hence, there is an attacking tuple T = ⟨i, s, J, t⟩ ∈ D and when the algorithm reaches T , we have that t /∈ Elim(D). Thus t ∈ Attack(D), and since D is coherent, t /∈ Elim(D) also when the algorithm terminates. It follows that t ∈ Accept(D), and so s ∈ Accept(D)+.
To see that Accept(D)+ ⊆ Elim(D), let s ∈ Accept(D)+. Then there is a tuple	 T = ⟨i, s, J, t⟩∈D such that t ∈ Accept(D). Since D is coherent, at the end of the	 execution of the algorithm t /∈ Elim(D). Thus, since Elim(D) grows monotonically	 during the execution, in particular t /∈ Elim(D) when the algorithm reaches the	 tuple T . It follows that s ∈ Elim(D).	2
Interestingly, the following proposition also holds:
Proposition 3.7 Let D be a simple derivation. If E is a stable extension of AF(D) then there is a coherent simple derivation Dj such that AF(Dj) = AF(D) and E = Accept(Dj).
Proof. Let D be a simple derivation and let E be a stable extension of the sequent- based argumentation framework AF(D)= ⟨Derived (D), Attack (D)⟩ that is induced by D. Consider a simple derivation Dj = Dj ⊕Dj ⊕Dj , where Dj contains the tuples
1	2	3	1
introducing the sequents in Derived (D), Dj consists of tuples of the form ⟨i, s, J, t⟩

where t ∈ E and s ∈ E +, and Dj
consists of the attacking tuples for the other

elements in Attack (D) (the order of the elements in Dj
and in Dj
may be arbitrary,

and some of these sequences may be empty for some Dj). Now, by the definition of Dj, clearly AF(Dj) = AF(D). Also, since E is stable, E + = Derived (D) \E =

Derived (Dj) \ E , and so when the algorithm completes its pass over Dj
it holds

that Attack(Dj) = E and Elim(Dj) = Derived (Dj) \ E . Clearly, the other tuples will not affect these sets, thus Dj is coherent (since Accept(Dj) ∩ Elim(Dj)= ∅) and Accept(Dj)= Derived (Dj) \ Elim(Dj)= E .	2
Together, Propositions 3.6 and 3.7 show a correspondence between accepted sets of coherent simple derivations and the stable models of sequent-based argumentation framework that are induced by those derivations.
Now we are ready to define derivations in a dynamic proof system.
Definition 3.8 Let S= ⟨L, C, A⟩ be an argumentation setting and let S be a set of formulas in L. A (dynamic) derivation (for S, based on S) is a simple derivation D of one of the following forms:
D = ⟨T⟩, where T = ⟨1, s, J, ∅⟩ is a proof tuple.
D is an extension of a dynamic derivation by a sequence ⟨T1,.  , Tn⟩ of intro-
ducing tuples (of the form ⟨i, s, J, ∅⟩), whose derived sequents (the s’s) are not in Elim(D).
D is an extension of a dynamic derivation by a sequence ⟨T1,.  , Tn⟩ of elimi-
nating tuples (of the form ⟨i, s, J, r⟩), such that:
D is coherent: Attack(D) ∩ Elim(D)= ∅, and
	the new attacking sequents (the r’s) are not A-attacked by sequents in Accept(D) ∩ ArgL(S), where the attack is based on prerequisite conditions in D.
Note 2 Conditions c(i) and c(ii) above assure that the attacks are sound: by co- herence neither of the attacking sequents of the additional elimination tuples is in Elim(D), and by Condition c(ii) they are not attacked by an accepted S-based se- quent. As we show below (see Footnote 11), these two conditions are not dependent.
Intuitively, one may think of a dynamic derivation as a proof that progresses over derivation steps. At each step the current derivation is extended by a ‘block’ of introducing or eliminating tuples (satisfying certain validity conditions), and the status of the derived sequents is updated accordingly. In particular, derived sequents may be eliminated (i.e., marked as unreliable) in light of new proof tuples, but also the other way around is possible: an eliminated sequent may be ‘restored’ if its attacking tuple is counter-attacked by a new eliminating tuple. It follows that previously derived data may not be derived anymore (and vice-versa) until and unless new derived information revises the state of affairs (see the examples in Section 4).
Proposition 3.9 Every dynamic derivation is coherent.
Proof. Easily follows from Definition 3.8.	2

The next definition, of the outcomes of a dynamic derivation, states that we can safely (or ’finally’) derive a derived sequent only when we are sure that there is no scenario in which it will be eliminated in some extension of the derivation.
Definition 3.10 Let S= ⟨L, C, A⟩ be a setting and let S be a set of formulas in L. A sequent s is ﬁnally derived (or safely derived) in a dynamic derivation D (for S, based on S), if s ∈ Accept(D), and D cannot be extended to a dynamic derivation Dj (for S, based on S) such that s ∈ Elim(Dj).
Note 3 Unlike ordinary proofs (e.g., in standard sequent calculi), the amount of derived sequents does not grow monotonically in the size of the derivation. However, final derivability is monotonic in the length of dynamic derivations. Indeed,
Proposition 3.11 If s is ﬁnally derived in D then it is ﬁnally derived in any ex- tension of D.
The induced entailment is now defined as follows:
Definition 3.12 Given an argumentation setting S = ⟨L, C, A⟩ and a set S of formulas, we denote by S |∼S ψ that there is an S-based dynamic derivation for S, in which Γ ⇒ ψ is finally derived for some finite Γ ⊆ S.
When the underlying argumentation setting is clear from the context we shall sometimes abbreviate |∼S by |∼.
Some Examples
We now give some examples of dynamic derivations. To simplify the reading, in the examples below we shall sometimes use abbreviations or omit some details, e.g. the tuple signs in proof steps.
Example 4.1 Consider the argumentation setting S = ⟨CL, LK, Ucut⟩, based on classical logic CL, its sequent calculus LK (Figure 1), and the attack rule Undercut (Figure 2). Below is a dynamic derivation for S, based on S1 = {p, ¬p, q}:
p ⇒ p	Axiom
⇒ p, ¬p	[⇒¬], 1
⇒ p ∨ ¬p	[⇒∨], 2
p ∨ ¬p ⇒ ¬(p ∧ ¬p)	... 
¬(p ∧ ¬p) ⇒ p ∨ ¬p	. . .
q ⇒ q	Axiom
Note that q ⇒ q is finally derived here. Indeed, the only sequents in ArgCL(S1) that can potentially attack q ⇒ q are of the form p, ¬p ⇒ ψ or p, ¬p, q ⇒ ψ, where ψ is logically equivalent to ¬q, however those sequents are counter attacked by
⇒ p ∨ ¬p (which is derived in Tuple 3), using the justifications in Tuples 4 and 5. 8

8 It is important to note that Ucut-attackers of q ⇒ q may still be derived in an extension of Q. However, as note above, by Condition (ii) in Definition 3.8(c) they cannot be used for eliminating q ⇒ q.

Thus, the above derivation cannot be extended to a derivation in which q ⇒ q is eliminated, and so £1 |~ q.
The situation is completely different as far as p⇒p is concerned. This is due to the fact that the above derivation can be extended by the following tuples, yielding an elimination of p⇒p:
чp ⇒ чp	Axiom
p /⇒ p	Ucut, 7, 7, 7, 1   чp ⇒ чp
In turn, this derivation can be further extended, to get an attack on чp⇒чp:
p ⇒ ччp	... 
ччp ⇒ p	... 
чp /⇒ чp	Ucut, 1, 9, 10, 7	p ⇒ p
In the last derivation p ⇒ p is not eliminated anymore. Nevertheless, p⇒p can be re-attacked by the sequent чp⇒чp. Alternatively, p⇒p can be re-attacked by any sequent of the form чp ⇒ ψ, where ψ is equivalent to чp (e.g., ψ = ч2n+1p, i.e., a formula in which p is preceded by an odd number of negations). As a consequence, p /⇒ p is reintroduced in extensions of this derivation, and similarly чp /⇒ чp may be reintroduced as well. It follows that neither of these sequents is finally derived. In an analogous way any dynamic derivation based on £1 can always be extended in such a way that all the sequents in ArgL(£1) whose conclusion is p (respectively, чp) are eliminated, and so £1 |~ p (respectively, £1 |~ чp).
This state of affairs is intuitively justified by the fact that while q is not related to the inconsistency in £1 and so it may safely follow from £1, the information in
£1 about p is contradictory, and so neither p nor чp may be safely inferred from £1.
Example 4.2 Let us consider the following variation of the previous example. The underlying setting is the same as before: S= ⟨CL, LK, Ucut⟩, but now we take the

conjunction of p and q: £j
= {p Λ q, чp}. Again, although both of p Λ q ⇒ p and

чp⇒чp are LK-derivable, neither p nor чp follows according to S from £j , because, e.g., the first sequent Ucut-attacks the other sequent and is Ucut-attacked by the sequent чp ⇒ ч(p Λ q) (the details are quite similar to those in Example 4.1). This time, however, q is not S-derivable from £j , because both the sequents p Λ q ⇒ q and чp, pΛq ⇒ q are also Ucut-attacked by the LK-derivable sequent чp ⇒ ч(pΛq) and cannot be permanently defended by sequents in ArgCL(£j ). 9
Note 4 The last two examples show in particular that |~S is sensitive to the syn-
tactic form of the premises: although £1 (Example 4.1) and £j (Example 4.2) are
CL-equivalent, their S-conclusions are not the same. This may be intuitively jus- tified by the fact that in £j , unlike in £1, q is not neutral with respect to the inconsistency of the set of premises and it is ‘linked’ to p by the conjunction (as is also reflected by the above Ucut-attack on p Λ q). Indeed, syntax sensitivity is

9 Note that the ArgCL(E′ )-sequent p Λ q ⇒ p does not prevent the Ucut-attack on p Λ q ⇒ q by the ArgCL(E′ )-sequent чp ⇒ ч(p Λ q), because the latter attacks both of them. This situation is different from the one in Example 4.1, where ⇒ p V чp ‘blocks’ any potential Ucut-attack on q ⇒ q, since in Example 4.1
⇒ p V чp couldn’t be counter Ucut-attacked.

not unusual in the context of non-monotonic reasoning. The same phenomenon is implied by Darwiche and Pearl’s postulates for iterated belief revision [10], ac- cording to which a new information abolishes any existing data that contradicts it. Thus, for instance, if Reasoner 1 ‘believes’ that p Λ q and Reasoner 2 ‘believes’ that p and that q, the introduction of чp forces Reasoner 1 to retract p Λ q, while Reasoner 2 has to withdraw p only. As a consequence, Reasoner 2 still believes q, while Reasoner 1 has no indication that q holds. A similar phenomenon happens when the maximally consistent subsets of the premises are taken into account: q is in the intersection of the maximally consistent subsets of £1, while the intersection
of the maximally consistent subsets of £j is empty (see also [19]). 10
Example 4.3 Consider a logic with a negation connective ч (so p /▶ чp andчp /▶ p), which doesn’t respect double-negation introduction (i.e., p /▶ ччp), and sup- pose that Direct Defeat (D-Def; See Figure 2) is the only attack rule.  Let
£2 = {p, чp, ччp, чччp, ччччp}. We write si (i ∈ N) for the sequent чip ⇒ чip (where ч0p = p). Note that by reflexivity si is provable in any complete calculus for the base logic. Now, consider the following sequence Ð of proof tuples:

It is easy to verify that Ð is a valid derivation. Extending it only with the tuple
s3   D-Def, 8, 8, 5  s4
yields a simple derivation Ðj, in which the attacker (s4) is not counter-attacked by an accepted sequent, yet Ðj is not coherent since s1 ∈ Attack(Ðj) ∩ Elim(Ðj). 11 Note, however, that Ð may be extended to a coherent derivation containing Tuple 9, provided that the latter is introduced together with the following eliminating tuple:
s1   D-Def, 3, 3, 2  s2
Indeed, the extension of Ð with the sequence ⟨T9, T10⟩ is a valid derivation. This demonstrates the need in Definition 3.8 to introduce more than one elimination tuple at a time.
Let us now check what can be finally derived from £2. First, the sequent s4 is attacked according to D-Def only by sequents whose right-hand side is ч5p, but since double-negation introduction does not hold, such sequents cannot be in ArgL(£2).

10 Syntax dependency ceases to hold when E1 (or E′ ) is consistent. This follows from Proposition 5.2 below.
11 This shows, in particular, that the two conditions in Definition 3.8(c) are not dependent.

It follows that s4 is finally derived by the above derivation, and so £2 |~ч4p. Also, s3 cannot be finally derived since any derivation in which it is derived can be extended by a tuple of the form ⟨i, s3, D-Def, s4⟩, which causes the elimination of s3. Thus
£2 |~ч3p. In turn, since the attacker (s3) of s2 is eliminated and cannot be recovered,
s2 is finally derived, thus £2 |~ ччp. Similar considerations show that in this case
£2 |~ чp and that £2 |~ p.
Note 5 The last example emphasizes the basic difference between the derivation process introduced here and the one considered in [3]. While the process in [3] allows to reintroduce sequents irrespective of whether they are attacked, here the way sequents can be introduced in a proof is restricted and it depends on the already introduced elimination sequents. Thus, e.g., while according to the approach in [3] the sequent чp ⇒ чp may be reintroduced in an extension of the dynamic derivation of Example 4.3, this is not possible according to the present formalism. Hence, according to [3] only s4 is finally derivable in Example 4.3, while in our case both s2 and s0 are also finally derivable, although they are attacked. This allows for a better ‘diffusion of attacks’ and it is in line with standard extensions of the corresponding argumentation frameworks (see [11]): although s2 is attacked by s3, that attack is counter-attacked by s4, and so s2 is ‘defended’ or ‘reinstated’ by s4 (see also Proposition 3.6).
Some Properties of |~
In this section we consider some properties of the entailment relations that are induced by dynamic proof systems according to Definition 3.12. We still denote by
|~ an arbitrary entailment relation that is covered by this definition. Due to lack of space proofs in this section are omitted and will appear in an extended version of this paper.
Relations between |~ and ▶
We start with some results concerning the relations between the base consequence relation and the entailments induced by the corresponding argumentation setting. In these propositions we refer to an entailment |~ that is induced by an argumen- tation setting S = ⟨L, C, A⟩ with a base logic L = ⟨L, ▶⟩.
Tarskian consequence relations may be viewed as particular S-entailments:
Proposition 5.1 If A = ∅ then |~ and ▶ coincide.
Another case where |~ and ▶ correlate is the following:
Proposition 5.2 If £ is conflict-free with respect to S (that is, there are no A- attacks between the elements in ArgL(£)), then £ |~ ψ iff £ ▶ ψ.
In general, |~ is weaker than ▶:
Proposition 5.3 If £ |~ ψ then £ ▶ ψ.

The converse of Proposition 5.3 holds for ▶-theorems and theorem-preserving rules:
Definition 5.4 An elimination rule R of the form of (2) above is theorem-preserving (with respect to a logic L), if there is no application of R by a substitution θ such that θ(Γn)= ∅.
Intuitively, a rule is theorem-preserving if it cannot be used for attacking theo- rems of the underlying (base) logic. The various variations of Undercut and Defeat in Figure 2 are examples of rules that are theorem-preserving with respect to any logic.
Proposition 5.5 If A consists only of theorem-preserving rules, then ▶ ψ implies that |~ ψ.
Corollary 5.6 If A consists only of theorem-preserving rules, then (i) ▶ ψ iff |~ ψ, and (ii) C is weakly sound and complete for |~ (that is, |~ ψ iff ⇒ψ is C-derivable).
We note also that some properties of the base logic are ‘inherited’ by |~. One of them is ч-paraconsistency [9]:
Proposition 5.7 If ▶ is ч-paraconsistent (that is, there are atoms p, q such that
p, чp /▶ q) then so is |~.

Cautious Reflexivity
As the examples in Section 4 show, in general |~ is not reflexive: a formula ψ does not necessarily follow from £ even if ψ ∈ £. Yet, the next proposition and corollary show that |~ is cautiously reflexive.
Proposition 5.8 If £ is conflict-free then £ |~ ψ for all ψ ∈ £.
Corollary 5.9
For every formula ψ such that {ψ} is conflict-free in S, we have that ψ |~ ψ.
For every atom p it holds that p |~ p.
Note 6 The condition in the last proposition and corollary is indeed required. For instance, if |~ is the entailment relation that is induced by S = ⟨CL, LK, {Ucut}⟩ (Example 4.1) then p Λ чp |~ p Λ чp.

Restricted Monotonicity
Clearly, |~ is not monotonic. For instance, by Corollary 5.9 p |~ p while Example 4.1 shows a case in which p, чp, q |~ p. Like reflexivity, monotonicity can be guaranteed in particular cases. For instance, as Proposition 5.12 below shows, when adding unrelated information to a framework with Undercut, this information should not disturb previous inferences. For this proposition we first define in precise terms what ‘unrelated information’ means and then recall the known notion of uniformity.

Definition 5.10 Let £ be a set of formulas and ψ a formula in a language L. We denote by Atoms(£) the set of atomic formulas that appear (in some subformula of a formula) in £. We say that £ is relevant to ψ, if Atoms(£) ∩ Atoms({ψ}) = ∅ implies that £ = ∅. A nonempty set £ is irrelevant to a (nonempty) set T if £ is not relevant to any formula in T , i.e.: Atoms(£) ∩ Atoms(T )= ∅.
Definition 5.11 Let L = ⟨L, ▶⟩ be a propositional logic. A set £ of L-formulas is ▶-consistent , if there exists an L-formula ψ such that £ /▶ ψ. We say that L is uniform, if £1 ▶ ψ when £1, £2 ▶ ψ and £2 is ▶-consistent and irrelevant to £1 ∪{ψ}.
Note 7 By L- os-Suzsko Theorem [15], a finitary propositional logic ⟨L, ▶⟩ is uniform iff it has a single characteristic matrix (see also [23]). Thus, classical logic as well as many other logics are uniform.
Proposition 5.12 Let S = ⟨L, C, {Ucut}⟩ be a setting whose base logic L is uni- form, and let |~ be the induced entailment. If £1 |~ ψ and £2 is a ▶-consistent set of formulas that is irrelevant to £1, then £1, £2 |~ ψ.
Note 8 A crucial property for Proposition 5.12 is that Ucut-attacks are preserved when the premises of the attacked sequents are weakened: if Γ ⇒ ψ is Ucut-attacked then Γj ⇒ ψ is Ucut-attacked (by the same attacker) whenever Γj contains Γ.
Note 9 The last proposition holds also for Direct Undercut. Under the additional condition that £2 is irrelevant to {ψ} the proposition holds also for Rebuttal.
Conclusion and Future Work
We have introduced a deductive method for reasoning with sequent-based argu- mentation systems. The non-monotonic nature of its derivations resembles other dynamic proof systems in other contexts, such as adaptive logics [7,21]. In our setting, a proof progressing over derivation steps may be viewed as a dialogue explicating actual (dynamic) reasoning in an argumentation framework. This, and other opportunities of using dynamic derivations for imitating commonsense reasoning, as well as the exact relations to related semantics, like those that are induced by Dung-style formalisms, should yet be explored in future work.


References
O. Arieli. A sequent-based representation of logical argumentation. In Proc. CLIMA’13, LNCS 8143, pages 69–85. Springer, 2013.
O. Arieli, A. Avron, and A. Zamansky. Maximal and premaximal paraconsistency in the framework of three-valued semantics. Studia Logica, 97(1):31–60, 2011.

O. Arieli and C. Straßer. Dynamic derivations for sequent-based logical argumentation. In Proc. COMMA’14, Frontiers in Artificial Intelligence and Applications 266, pages 89–100. IOS Press, 2014.
O. Arieli and C. Straßer. Sequent-based logical argumentation. Journal of Argument and Computation, 6(1):73–99, 2015.

P. Baroni, M. Caminada, and M. Giacomin. An introduction to argumentation semantics. The Knowledge Engineering Review, 26(4):365–410, 2011.
P. Baroni and M. Giacomin. Semantics for abstract argumentation systems. In I. Rahwan and G. R. Simary, editors, Argumentation in Artificial Intelligence, pages 25–44. 2009.
D. Batens. A universal logic approach to adaptive logics. Logica Universalis, 1:221–242, 2007.
Ph. Besnard and A. Hunter. A logic-based theory of deductive arguments. Artificial Intelligence, 128(1–2):203–235, 2001.
N. C. A. da Costa. On the theory of inconsistent formal systems. Notre Dame Journal of Formal Logic, 15:497–510, 1974.
A. Darwiche and J. Pearl. On the logic of iterated belief revision. Artificial Intelligence, 89(1–2):1–29, 1997.
P. M. Dung. On the acceptability of arguments and its fundamental role in nonmonotonic reasoning, logic programming and n-person games. Artificial Intelligence, 77:321–357, 1995.
D. Gabbay and H. Wansing, editors. What is Negation?, volume 13 of Applied Logic Series. Springer, 1999.
G. Gentzen. Investigations into logical deduction, 1934. In German. An English translation appears in ‘The Collected Works of Gerhard Gentzen’, edited by M. E. Szabo, North-Holland, 1969.
N. Gorogiannis and A. Hunter. Instantiating abstract argumentation with classical logic arguments: Postulates and properties. Artificial Intelligence, 175(9–10):1479–1497, 2011.
J. L- os and R. Suzsko. Remarks on sentential logics. Indagationes Mathematicae, 20:177–183, 1958.
J. Marcos. On negation: Pure local rules. Journal of Applied Logic, 3(1):185–219, 2005.
J. Pollock. How to reason defeasibly. Artificial Intelligence, 57(1):1–42, 1992.
H. Prakken. Two approaches to the formalisation of defeasible deontic reasoning. Studia Logica, 57(1):73–90, 1996.
N. Rescher and R. Manor. On inference from inconsistent premises. Theory and Decision, 1:179–217, 1970.
G. R Simari and R. P. Loui. A mathematical treatment of defeasible reasoning and its implementation.
Artificial Intelligence, 53(2–3):125–157, 1992.
C. Straßer. Adaptive Logic and Defeasible Reasoning. Applications in Argumentation, Normative Reasoning and Default Reasoning, volume 38 of Trends in Logic. Springer, 2014.
C. Straßer and O. Arieli. Sequent-based argumentation for normative reasoning. In Proc. DEON’14, LNCS 8554, pages 224–240. Springer, 2014.
A. Urquhart. Many-valued logic. In D. Gabbay and F. Guenthner, editors, Handbook of Philosophical Logic, volume II, pages 249–295. Kluwer, 2001. second edition.
