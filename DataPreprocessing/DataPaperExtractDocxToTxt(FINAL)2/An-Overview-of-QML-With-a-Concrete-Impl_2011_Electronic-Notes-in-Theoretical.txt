

Electronic Notes in Theoretical Computer Science 270 (1) (2011) 165–174
www.elsevier.com/locate/entcs

An Overview of QML With a Concrete Implementation in Haskell
Jonathan Grattage
Laboratoire d’Informatique de Grenoble, CNRS, France
jonathan.grattage@imag.fr


Abstract
This paper gives an introduction to and overview of the functional quantum programming language QML. The syntax of this language is defined and explained, along with a new QML definition of the quantum teleport algorithm. The categorical operational semantics of QML is also briefly introduced, in the form of annotated quantum circuits. This definition leads to a denotational semantics, given in terms of su- peroperators. Finally, an implementation in Haskell of the semantics for QML is presented as a compiler. The compiler takes QML programs as input, which are parsed into a Haskell datatype. The output from the compiler is either a quantum circuit (operational), an isometry (pure denotational) or a superoperator
(impure denotational). Orthogonality judgements and problems with coproducts in QML are also discussed.
Keywords: QML, language, functional, teleport, denotational semantics, operational semantics, Haskell.


Introduction and motivation
Language development for quantum computation is a rapidly developing research area [4], motivated by the application of established formal reasoning and verifica- tion techniques within a quantum framework, understanding the behaviour of quan- tum computation, aiding the development of new algorithms and gaining a deeper understanding of how they work. This paper discusses the syntax and features of, and gives a compiler for, a language allowing both classical and quantum control: QML [1,5]. The syntax and semantics for QML is a complete redevelopment of that presented previously [1], as the language has been changed to remove a problematic interpretation of coproducts (section 2.2); the interpretation of orthogonality has also been updated (section 2.1). In addition, in this work the operational semantics is made concrete by a compiler for QML programs implemented in Haskell.

1 The author gratefully acknowledges Thorsten Altenkirch in the development of QML and the operational semantics. Ellie D’Hondt is also thanked for her constructive suggestions.

1571-0661 © 2011 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2011.01.015

QML has a syntax similar to other functional languages [4], and is based on strict linear logic: i.e. linear logic with contraction, but without implicit weakening (in contrast, Selinger’s QPL uses affine linear logic [8], which allows weakening but not contraction). QML also integrates reversible and irreversible computations in a single language, where weakenings (which can give rise to the collapse of super- positions and entanglement) must be explicit. Contractions are allowed and are modelled as a form of sharing, analogous to the behaviour of classical functional languages. Differences between QML and other languages include the use of a quan- tum control operation, provided by the quantum-if construct if ◦. To use the if ◦ operation, the branches of the computation must be orthogonal (distinguishable), the proof of which is supplied automatically by the type checker at compilation, and hence the programmer need not supply the condition, nor need it appear in the syntax of terms. Classical control is provided by a second classical-if construct if , which measures the term being branched over.
QML has both an operational and denotational semantics [5], supporting formal reasoning principles with an algebra for equational reasoning and a normal form [2]. The operational semantics of QML is presented using a categorical formalisation of the quantum circuit model, which is realised by a compiler that translates QML programs into ‘typed’ quantum circuits. The denotational semantics is also imple- mented, which translates QML terms, via the operational semantics category FQC, into either isometries Q◦ or superoperators Q.
Recent developments in QML include a fully operational compiler, with a type inference algorithm for QML terms, and the automatic derivation and extension of the orthogonality judgements and circuits required for quantum control, which have all been implemented. The implementation of the orthogonality judgements is such that it can be easily expanded as new rules for proving the orthogonality of terms are added to QML. This short paper outlines the new syntax of QML and its semantics. A new and faithful interpretation of the quantum teleportation algorithm in QML is also presented as an example of using QML. Details for using the compiler, and the output it generates, are then provided. Finally, the future development of the language, the semantics and compiler, and the uses of the compiler are described.

The syntax of QML
This section introduces the syntax for QML (see also ref. [5]). The symbols σ, τ are used to vary over QML types, given by σ = Q1 | Q2 | σ ⊗ τ , where the type constructor is the tensor product ⊗ corresponding to a product type and Q2 is a qubit type. x, y, z are used to vary over names. Typing contexts (Γ, Δ) are given by Γ = • | Γ, x : σ where • is the empty context. Contexts correspond to functions from a finite set of variables to types.
Constants κ, ι ∈ C are also used to define the syntax of expressions. Function variables are used to refer to previously defined QML programs. The terms of QML consist of those of a first-order functional language, extended with quantum data, a quantum control structure, and a measurement operator. The vector notation y

is used for sequence variables to be measured (weakened). The grammar of QML terms is defined thus:
(Variables)	x , y, ... ∈ Vars (Prob amplitudes) κ, ι, ... ∈ C (Patterns)	p, q	::= x | (x , y )
(Terms)	t, u	::= x | x y | () | (t, u) | let p = t in u
| if t then u else uj | if ○ t then u else uj
| qfalsey | qtruey | κ × t | t + u
Quantum data is modelled using the constructs κ × t and t + u. The term κ × t, associates the probability amplitude κ with the term t. The term t + u describes a quantum superposition of t and u. Quantum superpositions are first class values, and can be used in conditional expressions to provide quantum control. For example: if ○ (qtrue + qfalse) then t else u evaluates both t and u and combines the results in a quantum superposition. Note that the term λ0 × t + λ1 × u, where t, u are not qubits, is syntactic-sugar for if ○ (λ0 × qtrue + λ1 × qfalse) then t else u. The type-checker and orthogonality judgements ensure that this is a valid operation, by providing a proof that t and u are orthogonal (distinguishable in some way), that their types match, and that they are strict terms (they produce no garbage).
In a quantum control operation, the two branches must be orthogonal, other- wise the type system would accept terms that implicitly perform measurements. Without this restriction “valid” programs could be written in QML that are not physically realisable by a quantum computer. Orthogonality judgements are in- ferred automatically by static analysis of terms (see section 2.1).
As an example of superposition formation, the term ( √1 )×qfalse+( √1 )×qtrue
2	2
is an equal superposition of qfalse and qtrue. Normalisation factors that are equal
may be omitted.
Finally, a QML program is a sequence of function definitions, where a function definition is given by f Γ= t : τ . A Haskell-style syntax is used to present program examples. For example, the QML function below (left) is equivalent to the following Haskell-like code (right):
f (x1 : σ1, x2 : σ2,.., xn : σn)	f : σ1 ( σ2 .. ( σn ( τ
= t : τ	f x1 x2 .. xn = t

QML orthogonality judgements
QML has a basic type system that tracks the use of variables, preventing them from being weakened inappropriately. However, the type system still accepts terms which implicitly perform measurements. As a consequence QML would accept programs which are not realisable as quantum computations.
Consider the expression if ○ x then qtrue else qtrue. This expression returns qtrue without using any information about x . In order to maintain the invariant that all measurements are explicit, the type system should reject the above expres- sion. More precisely, the expression if ○ x then t else u should only be accepted if t ⊥ u. This notion intuitively ensures that the conditional operator does not

implicitly discard any information about x during the evaluation. The branches of a superposition should also be orthogonal for similar reasons.
Mathematically, two terms, t, u, are orthogonal if their inner-product is equal to zero, ⟨t|u⟩ = 0. If this is the case then the judgement t ⊥ u is true, but if the inner- product yields any other value then t is not orthogonal to u. In the presentation of an equational theory for QML [2] the orthogonality judgements are replaced by an inner-product judgement on terms, to much the same effect. However, the inner- product approach is more informative and flexible, and gives a method of reasoning about orthogonality, hence in future this method may be adopted for all terms.
The following rules give the current QML orthogonality judgements:

qtrue ⊥ qfalse	qfalse ⊥ qtrue


	t ⊥ u	
(t, v ) ⊥ (u, w )

⊥ pair0
	t ⊥ u	
(v, t ) ⊥ (w, u)

⊥ pair1


t ⊥ u	λ∗κ0 = −λ∗κ1
⊥ sup
λ0 × t + λ1 × u ⊥ κ0 × t + κ1 × u
t ⊥ u	λ∗κ0 = −λ∗κ1
0	1
⊥ supif
if ◦ (λ0 × qtrue + λ1 × qfalse) then t else u ⊥ if ◦ (κ0 × qtrue + κ1 × qfalse) then t else u


t ⊥ u	t ⊥ u′
◦

′ ⊥ if 0
t ⊥ u	t ⊥ u′
′

⊥ if 1

t ⊥ if c then u else u
if c then u else u ⊥ t


The first two axioms state that the basic states of qtrue and qfalse are orthogonal. The third and fourth rules state that pairs of terms can be orthogonal, provided that one component of a pair is orthogonal to the other pair’s corresponding component. The two sup rules state when superpositions of terms can be orthogonal; the second is a restatement of the first, translating superpositions using if ○. The final two rules state that if ○ statements can be orthogonal if all the component terms are.
The use of if ○ in QML programs is valid only if the two branches are orthogonal. Hence, for the Hadamard operation (section 4), it is required that −qtrue+qfalse ⊥ qtrue + qfalse, with the appropriate renormalisation. In this case the ⊥ sup rule verifies orthogonality.
The rules for orthogonality given so far are incomplete, and may be extended. Orthogonality judgements must also be interpreted by the operational semantics, discussed in ref [5].
Removing coproducts from QML
In a previous version of QML [1], here referred to as QML⊕, the language included the notion of a tensorial coproduct, denoted by ⊕. This coproduct has now been removed. The types of QML⊕ were generated by Q1, σ ⊗τ , and σ ⊕τ . Qubits were not primitive, but defined as Q2 = Q1 ⊕Q1. The coproduct allowed any finite type

to be directly represented in this way; not just limited to Q2. The introduction rules used for ⊕ were the usual coproduct rules of a left and a right injection:

Γ ▶a s : σ


Γ ▶a inl s : σ ⊕ τ

+introl
Γ ▶a t : τ


Γ ▶a inr t : σ ⊕ τ

+intror

The coproduct type was interpreted as σ ⊕ τ = Q2 ⊗ |σ H τ |, where |σ H τ | could store a value of either |σ| or |τ |, by padding the smaller type. Using the coproduct and injection rules, qfalse and qtrue were defined in QML⊕ as inl() : Q2 and qfalse = inr() : Q2, respectively, omitting the weakening property of QML⊕.
Instead of if and if ○ rules, QML⊕ implemented two ⊕-elimination rules: case, providing classical-control (a generalisation of if ), and a quantum-control operation case○ (generalising if ○). The quantum (non-measuring) ⊕-elimination rule is similar to the standard coproduct elimination rule, and is given as:
Γ ▶a c : σ ⊕ τ
Δ, x : σ ▶◦ t : ρ
Δ, y : τ ▶◦ u : ρ	t ⊥ u



Γ ⊗ Δ ▶a case◦ c of {inl x ⇒ t | inr y ⇒ u} : ρ
⊕elim◦

The non-strict (measuring) case removes the orthogonality requirement, and does not require sub-terms to be strict. The if a rules (a ∈ {◦, −}; if a = ◦ then the rules are strict, i.e. measurement-free) would then be derived as:
if a b then t else u = casea b of {inl  ⇒ t | inr  ⇒ u }
The branches of a case○ operation can be of different sizes, and this was dealt with in the semantics of QML⊕ by padding the type of the smaller branch. The padding of one type in this way can lead to the garbage becoming entangled with the useful output in some way. This happens, for example, if branching over Q1 ⊗ Q2. The garbage created by padding may indirectly measure the qubit which is being branched over. Consequently, this approach is not compositional, and has therefore been rejected.
This version of QML resolves this issue by removing the coproduct. Qubits are now primitive, as are if and if ○. Additionally, the strict if ○ does not allow any garbage to be produced. Coproducts may be reintroduced, possibly limited to classical types.
An operational semantics for QML
The new operational semantics for QML is briefly discussed here, which is an up- dated version of that presented in [1]. This semantics is defined by giving a trans- lation from QML terms into morphisms in the category FQC. FQC morphisms consist of a reversible quantum circuit φ, the input context Γ, the output type σ, and the size of the auxiliary heap h and any garbage g . Any heap qubits are initially set to 0 (false) in the computational basis, and garbage qubits can be removed by the partial trace operation at the end of the computation. A full development of FQC is given in references [5,6].
As an example, the classical if construct is defined by the following typing rule and operational semantic:


Γ ▶ c : Q2
	Δ ▶ t, u : σ	 if
Γ ⊗ Δ ▶ if c then t else u : σ
c ∈ FQC Γ Q2
t ∈ FQC Δ σ
	u ∈ FQC Δ σ	
ifOp ctu ∈ FQC (Γ ⊗ Δ) σ
ifOp ctu = (hC + hc + ht|u, gc + 1, φ)

where φ in the operational semantics is the following circuit:

Γ⊗Δ
Γ,,e,e	,,,cc

	Δee, 
	φc
Q2   cc,
,,,cc
φt|φu
,,,cc, σ



 	cc ,	 
with φC as a “context-splitting” operation that copies any variables used by both subterms. φt|φu denotes a conditional circuit which performs φt if the result of the conditional circuit c is true (|1⟩) and φu if it is false (|0⟩).
In this way, the semantics of QML is defined recursively over the syntax of terms, and results in a valid FQC morphism for a valid QML term. Given a QML term, the QML compiler follows the operational semantics and outputs an FQC morphism represented as a typed circuit, which can then either be displayed, exported for use with other programs, or used to directly implement the program on a quantum- circuit based quantum computer. The FQC morphism can be further evaluated via the denotational semantics, producing a unitary matrix Q (for strict-QML terms without heap), an isometry Q○ (for strict-QML terms), or a superoperator Q (for QML terms that produce garbage). In addition, orthogonality judgements and circuits for quantum control and superpositions of terms are automatically inferred by the compiler at compile-time, so there can be no orthogonality errors during run- time. The relationships between QML without measurement (QML○), full QML (QML), typed quantum circuits (FQC), and isometries (Q○) and superoperators (Q), is shown in the following diagram:
QML◦ Γ σ ,˛	/QM/L Γ¸σ

J·)◦
...
¸¸¸J·)

Op .
.x..s.
Op
¸¸¸z 

FQC◦ Γ¸σ ,˛	/FQ/C Γ σ
¸¸¸¸¸¸	sssss

J·)d
¸¸¸z 	
ssssJ·)d

Q◦ Γ σ // ^.	/Q/Γ σ

where J·)Op denotes the operational semantics, and J·)D denotes the additional translation from quantum circuits into the denotational semantics. The full seman- tics can be found in reference [5].
Example: Teleportation in QML
The quantum teleportation describes how to transport a quantum state using a small amount of classical communication. A QML interpretation of the teleportation circuit with deferred measurement has previously been presented, along with a full description of the algorithm [5]. However, this circuit relies on the existence of a quantum channel. In order to demonstrate and explain the syntax of QML and the compiler, a new, faithful, implementation of the quantum teleport algorithm, which

explicitly makes use of measurement, is presented. 2 This algorithm is similar to that developed by Selinger and Valiron [9], and also in reference [3], which includes a relevant discussion of teleportation, both with and without deferred measurement. These examples show the elegance of allowing quantum control via the quantum if ○ construct (CNot ) and term superpositions (Epr ), in writing functions. For simple one qubit functions (Had ), the branches of the quantum control are the columns from the unitary matrices that describe the operation. A simple measurement operation, using classical control, is also defined in the following example which implements the teleportation algorithm (Tele):
Had, Qnot, Meas	Q2 ( Q2
Had b = if ◦ b then qfalse +	qtrue -- The Hadamard operation
else qfalse + qtrue
Qnot b = if ◦ b then qfalse else qtrue	 -- The Not operation (Pauli X) Meas b = if b then qtrue else qfalse	 -- A measurement operator, using if CNot	Q2 ( Q2 ( Q2	Q2	-- A quantum cnot operation
CNot s t = if ◦ s then (qtrue, Qnot t )
else (qfalse, t )
Epr	Q2	Q2	-- The EPR pair, 00 + 11
Epr = (qtrue, qtrue)+ (qfalse, qfalse)
Bmeas	Q2 ( Q2 ( Q2	Q2	-- The Bell-measurement operation
Bmeas x y = let (x′, y′)= CNot x y
in (Meas (Had x′), Meas y′)
U	Q2 ( Q2	Q2 ( Q2	-- The unitary correction operations
U q xy = let (x, y )= xy in if x then  (if y then U11 q else U10 q )
else	(if y then U01 q else q )
U01, U10, U11  Q2 ( Q2
U01 x = if ◦ x then qfalse else qtrue U10 x = if ◦ x then − qtrue else qfalse U11 x = if ◦ x then − qfalse else qtrue
-- The quantum teleportation algorithm
Tele	Q2 ( Q2
Tele q = let (a, b)	= Epr	-- a is given to Alice, b to Bob
f	= Bmeas q a -- Result of Alice’s Bell-measurement is classical data
in U b f	-- Bob applies U to his qubit, using classical data f

The QML compiler
This section briefly describes the design and operation of the Haskell QML compiler, which can be found on the project website. 3 The objective is to takea file containing a QML program, consisting of QML function definitions, and output an annotated (typed) quantum circuit which realises the QML program as an FQC object. This is achieved by implementing the operational semantics in Haskell. Additionally, the circuit produced by the compiler can be further processed to produce either a unitary matrix (Q ), isometry (Q○), or superoperator (Q), as appropriate, giving an implementation of the denotational semantics of QML, as factored through the operational semantics.
The compiler has a modular design, giving a clear logical structure. For example,

2 The code is included with the compiler as teleport.qml, see section 5.
3 Instructions for downloading the QML compiler can be found on the QML compiler website http://fop. cs.nott.ac.uk/qml/compiler. The Haskell compiler GHC is also required. To use the compiler, the QML system must be loaded into GHC via the command “ghci qml ”. This will initialise the system with all the modules required to interpret and evaluate QML programs.

the QOrth module contains all the code for generating the orthogonality judgements and circuits, while QCirc contains the definition of the circuit datatypes and asso- ciated functions. The compiler exploits advanced Haskell features, such as monads and pattern matching, and making use of the ideas put forward by Vizzotto et al [10]. The operational semantics is realised in the QComp (Q ML Compilation) module.
To compile QML functions into the operational semantics (FQC morphisms, represented as typed circuits), the “run typed circuit” command is used: runTC "#filename" "#function". For example, to evaluate the typed circuit of the function Epr (from section 4) the command is runTC "teleport.qml" "Epr". This outputs the following typed circuit (as a Haskell datatype):

H   •	 Q2
	 Q2
where there is no input context, the heap is two qubits (marked ▶), and a pair of qubits are the output. H and X are the Hadamard and Pauli-X operations. As heap is initialised to qfalse, this circuit describes the function |00⟩ → |00⟩ +
|11⟩, producing an EPR pair. The compilation of a QML term into a circuit is efficient; each QML term is recursively translated directly into an FQC morphism (an annotated circuit), as described in section 3. No quantum computation is simulated, so this does not effect the efficiency of the compiler - it is a simple recursive translation into circuits. The output is further optimised after compilation, by collapsing identities and permutations and other simple circuit manipulations which do not effect the action of the circuit (see QCirc).
There are three main options for further evaluation of a QML term:
The QML term could be evaluated to a unitary matrix (Q ), interpreting only the reversible circuit φ from the FQC morphism. As this option classically computes the full mathematical interpretation of the program it is inherently inefficient. The output is actually a triple (h, g, φ) ∈ (Int, Int,Unit), where h, g gives the size of any heap required or garbage produced. The command for producing a unitary matrix is runM ;
The function could be evaluated to an isometry (Q○), which initialises any re- quired heap, and is the full description for terms that produce no garbage. This option is no less efficient than the runM option, and is the preferred evaluation option. The output is actually a pair (g, φ) ∈ (Int, Q○), where g gives the size of any garbage (if the QML function is impure). The command for evaluating to an isometry is runI ;
Thirdly, the QML term can be interpreted as a superoperator (Q), which ini- tialises heap and traces out any garbage, using the command runS . This option is substantially less efficient than the previous two options, as the state space is doubled and the partial trace is a computationally expensive operation.
Together, the options runI and runS give an interpretation of the denotational

semantics of QML factored through the category FQC, as shown in the diagram in section 3. A direct implementation of the denotational semantics, without using the operational semantics, is an extension currently being developed. Please refer to the project website for full details.
Conclusions and further work
This paper introduces the language QML and presents its semantics with a compiler and example programs. The semantics and compiler give a realisable interpretation of QML programs as quantum circuits in a formal, categorical, setting. The seman- tics can be extended in many ways, such as expanding the current orthogonality judgements, or by the addition of non-linear, classical, data. The algebra for the pure fragment of QML [2] is currently being extended to include measurement, fol- lowing work on van Tonder’s quantum lambda calculus [3]. It would be instructive to implement this algebra, especially the normal form, as part of the QML compiler. Future possibilities for the development of the language also including developing a notion of higher-order functions for QML, and adding iteration to the language.
The development of QML and the compiler is an ongoing project which has already reached a functional state. As the language and semantics evolve, exten- sions and new features can be incorporated into the compiler; which also provides a useful testbed for the development of new language features and capabilities. For example, an extension of the orthogonality circuits given in [5] was developed using the compiler in this way. The compiler also facilitates the testing and development of new QML algorithms, such as the described teleportation algorithm. It has also been useful in allowing others to experiment with quantum programming and get immediate feedback on the behaviour of their functions, in a style that is famil- iar to computer scientists, logicians, and physicists with functional programming experience.
Further extensions to the compiler include adding the ability to export typed circuits as images, or in notation compatible with tools such as MatLab and Math- ematica. Possible relationships with the measurement calculus, the Haskell QIO monad [7], and other formalisms are being studied, and may provide new insights. This will lead to new features being developed, such as basis independence, and further useful abstractions.

References
Altenkirch, T. and J. Grattage, A functional quantum programming language, in: LICS 2005 proceedings
(2005), pp. 249–258, also arXiv:quant-ph/0409065.
URL http://fop.cs.nott.ac.uk/qml

Altenkirch, T., J. Grattage, J. K. Vizzotto and A. Sabry, An algebra of pure quantum programming, ENTCS 170 (2007), pp. 23–47, also arXiv:quant-ph/0506012v1.
URL http://fop.cs.nott.ac.uk/qml

D´ıaz-Caro, A., P. Arrighi, M. Gadella and J. Grattage, Measurements and confluence in quantum lambda calculi with explicit qubits (2008), accepted by DCM/QPL (ICALP 2008).
URL   http://equipes-lig.imag.fr/capp/qcg/people/jgrattage/papers/adc-lambdameas-qpl.pdf


Gay, S. J., Quantum programming languages: Survey and bibliography, Mathematical Structures in Computer Science 16 (2006).
URL http://www.dcs.gla.ac.uk/~simon/publications/QPLsurvey.pdf
Grattage, J., “QML: A functional quantum programming language,” Ph.D. thesis, School of Computer Science and School of Mathematical Physics, The University of Nottingham (2006).
URL http://etheses.nottingham.ac.uk/archive/00000250/

Green, A. and T. Altenkirch, From reversible to irreversible computations, in: P. Selinger, editor, QPL 2006 proceedings, ENTCS (2006).
URL http://fop.cs.nott.ac.uk/qml

Green, A. and T. Altenkirch, Shor in Haskell: The quantum IO monad (2008), accepted by Trends in Functional Programming 2008.
URL http://www.cs.nott.ac.uk/~asg/pdfs/tfp08.pdf
Selinger, P., Towards a Quantum Programming Language, Mathematical Structures in Computer Science 14 (2004), pp. 527–586.
URL http://www.mathstat.dal.ca/~selinger/papers.html#qpl
Selinger, P. and B. Valiron, A lambda calculus for quantum computation with classical control, in:
TLCA 2005 proceedings, LNCS 3461 (2005).
URL http://www.mathstat.dal.ca/~selinger/papers.html#qlambda
Vizzotto, J. K., T. Altenkirch and A. Sabry, Structuring Quantum Effects: Superoperators as Arrows
(2005), also arXiv:quant-ph/0501151.
