

Electronic Notes in Theoretical Computer Science 239 (2009) 17–42
www.elsevier.com/locate/entcs

Normed Processes, Unique Decomposition, and Complexity of Bisimulation Equivalences
Sibylle Fro¨schle1 ,3
Department fu¨r Informatik Universita¨t Oldenburg 26111 Oldenburg, Germany

S-lawomir Lasota2 ,4
Institute of Informatics Warsaw University
02–097 Warszawa, Banacha 2, Poland

Abstract
We propose a decision procedure for a general class of normed commutative process rewrite systems and their induced bisimulation equivalences. Our technique is inspired by the polynomial-time algorithm for strong bisimilarity on normed Basic Parallel Processes (BPP), developed by Hirshfeld, Jerrum and Moller. As part of our framework we present a generic unique decomposition result, which we obtain by building on a characterization by Luttik and van Oostrom. We apply our general technique to derive polynomial- time algorithms for strong bisimilarity on normed BPP with communication and for distributed bisimilarity on all BPP with communication. Moreover, our technique yields a PSPACE upper bound for weak and branching bisimilarity on totally normed BPP.
Keywords: Bisimulation equivalence, distributed bisimulation, weak bisimulation, branching bisimulation, Basic Parallel Processes, unique decomposition.


Introduction
The idea of unique prime decomposition is relevant in process theory: given a behavioural equivalence one asks whether the commutative monoid of the equiva- lence classes of processes, with parallel composition as binary operation, has unique

1 This work was partially done while the first author was a postdoc at Warsaw University, funded by the EU Research Training Network Games.
2 Partially supported by the Polish government grant N206 008 32/0810 and by the EU Research Training Network Games.
3 Email: froeschle@informatik.uni-oldenburg.de
4 Email: sl@mimuw.edu.pl

1571-0661/© 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.05.028

decomposition. This means that every element can be uniquely expressed as a com- position of primes; an element is prime if it is not the composition of two non-trivial elements.
Unique decomposition results in process theory have helped to construct decision procedures for bisimulation equivalences on various process classes. A classical ex- ample is the algorithm of Hirshfeld et al. [6,2], which proves that strong bisimilarity on normed Basic Parallel Processes (BPP) is polynomial-time decidable. Using this algorithm as a subroutine, Lasota has shown that distributed bisimilarity on BPP is also polynomial-time decidable [11]. Hirshfeld et al.’s technique does not extend to strong bisimilarity on the full BPP class. Indeed, it has turned out that this prob- lem is PSPACE-complete [15,8]. The PSPACE decision procedure uses a special technique developed by Janˇcar, which can also be applied to obtain polynomial- time algorithms for strong bisimilarity on normed BPP and distributed bisimilarity on BPP [9,10].
Weak bisimilarity on BPP is PSPACE-hard [14], and it is not even known whether the notion is decidable; this is a long-standing open problem. For normed BPP, weak bisimilarity remains PSPACE-hard but decidability has been achieved for slightly more restricted classes [5,16]; one of them is the class of totally normed BPP [5]. However, both algorithms seem to have non-elementary complexity. Branching bisimilarity [17], which like weak bisimilarity reflects a notion of ob- servable behaviour, is also decidable on totally normed BPP [5].
Two directions seem important to gear up the techniques towards realistic sys- tems: one is to cover process classes with communication; the second is to obtain better techniques for observational equivalences. For BPPτ , which extends BPP with CCS-style communication, strong bisimilarity restricted to the normed case as well as distributed bisimilarity have been proved decidable [3]. The algorithms are based on unique decomposition results but they both run in exponential time. Janˇcar’s technique is not suited to processes with communication, and it appears not be applicable to observable semantics either. Thus, we were motivated to take another look at unique decomposition. In this paper we will present a general technique, based on unique decomposition, that applies to a wide range of process semantics.
Our contributions are as follows. (1) We define a general class of commutative rewrite systems (CRS’ ) and a general definition of when a CRS is normed. With each CRS we associate a notion of bisimilarity. (2) We demonstrate that a wide range of semantics can be captured within our framework. In particular, we show that each of the following equivalences can be expressed as the bisimilarity of a normed CRS: strong bisimilarity on normed BPPτ , distributed bisimilarity on all BPPτ , weak and branching bisimilarity on totally normed BPP. (3) We prove that the notions of bisimilarity induced by normed CRS’, and hence our four concrete equivalences, satisfy unique decomposition. To our knowledge, no unique decompo- sition result for weak or branching bisimilarity on a BPP class has been achieved before. (4) We exhibit a general procedure which, given an effectively represented normed CRS, decides its associated notion of bisimilarity. (5) We instantiate this

general technique to obtain the following concrete results: strong bisimilarity on normed BPPτ and distributed bisimilarity on all BPPτ are polynomial-time de- cidable; weak and branching bisimilarity on totally normed BPP are decidable in PSPACE. To our knowledge all of these results are new. The result on weak bisim- ilarity is particularly interesting: no elementary upper bound has been achieved before for this equivalence on a reasonably large infinite-state class.
It is standard to define classes of infinite-state processes in terms of rewrite systems [2,13]. For example, BPP are captured by what is commonly referred to as (1, P)-PRS [13]. Our notion of CRS generalizes (1, P)-PRS in two ways. Firstly, we allow processes to communicate; the type of communication will be specified by means of a synchronization algebra, a concept that originates from the semantics of concurrency [18]. Secondly, we allow a process to evolve into a tuple of processes rather than only one. This ensures we can capture generalizations of transition systems such as that used by distributed bisimilarity but it is also crucial to capture branching bisimilarity.
Our unique decomposition result is achieved with the help of an important tool of Luttik and van Oostrom [12]: a partial commutative monoid has unique decompo- sition iff it has a decomposition order. The concept of decomposition order captures the algebraic properties that typically underly unique decomposition proofs in pro- cess theory. Each normed CRS induces a notion of norm-reducing bisimulation. We will show that congruences which are norm-reducing bisimulations have a natural decomposition order, and hence by [12] they satisfy unique decomposition. Not only will this result imply unique decomposition for bisimilarity but it will also provide the backbone of our general decision procedure.
Our decision procedure is an extension of Hirshfeld et al.’s technique for strong bisimilarity on normed BPP [6,2]. In their algorithm bisimilarity is approximated from above, in a small number of steps, by a sequence of norm-preserving congru- ences which have unique decomposition. We will make prominent what is underlying but hidden in [6]: each approximation is obtained as the greatest norm-reducing bisimulation that contains a refinement of the previous approximation. Combined with our general unique decomposition result this makes the technique applicable to a wide range of processes. Furthermore, we generalize [6] in that our notion of norm-reducing transition is non-strict.
It is interesting that we can capture the four concrete cases as instantiations of the same type of normed CRS. On the one hand, this makes concrete the connection between strong bisimilarity on normed BPP and distributed bisimilarity on all BPP that has already become apparent from the similarity in their decision procedures [11,9,10]. On the other hand, it shows that this connection extends to BPPτ . Finally, and perhaps most interestingly, it highlights a new connection between observable transitions and communication. Altogether, our framework brings to light structural similarities between a priori very different notions. Thus, we hope our general technique will be applicable to a wide range of process semantics beyond those studied in this paper.
The remainder of the paper is structured according to our contributions. In

Section 2 we introduce our setting of (normed) CRS’. In is intentionally presented in an abstract and general way. Four concrete instantiations of this setting, corre- sponding to the above-mentioned four bisimulation equivalences, are given in detail in the following Section 3. For the sake of clarity of presentation, we prefer to keep distinct the abstract definitions, and their concrete examples. However, simultane- ously with reading Section 2 the Reader is encouraged to inspect Section 3 to get some concrete intuitions about the necessarily abstract notions. Section 4 prepares a tool, the unique decomposition theorem, which we use later. In Section 5, being the core part of the paper, we outline the algorithm. It is again presented in a generic, abstract setting of CRS’. Then in Section 6 we explain how this general framework applies to the four bisimulation equivalences from Section 3. The last section contains conclusions and future plans.

Normed Commutative Rewrite Systems
For technical convenience we assume a special action ∗, the idle action, which can always happen. A synchronization algebra is a pair Act = (Act, •) where Act is a set of actions such that ∗ /∈ Act, and • : (Act ∪ {∗})2 → Act ∪ {∗} is a binary, commutative, associative partial operation which satisfies:
(S1) a • b = ∗ iff a = ∗ = b; (S2) a •∗ = ∗• a = a.
Axiom (S1) is standard. By imposing (S2) we restrict our attention to communica- tion schemes where all actions can occur asynchronously. Typically, we let a, b,... range over actions including ∗.

Commutative Rewrite Systems
By V ⊗ we denote the free commutative monoid over a finite set V . Its elements are multisets of elements from V .
A commutative rewrite system (CRS ) is a triple P = (V, Act, Γ) where
V is a finite set of variables,
Act is a finite synchronization algebra, and
Γ is a finitely presentable set of rewrite rules of the form (X, a, α1,... , αm) where
X ∈ V , a ∈ Act, and αi ∈ V ⊗. m ≥ 1 is fixed throughout Γ.
Γ is assumed to be ﬁnitely presentable but not necessarily finite; in fact in the most interesting cases Γ will be infinite or exponential wrt. the actual size of presentation of Γ. We do not assume here anything about the way Γ is presented; this will be made clear in each concrete case. Typically, a presentation will be a finite BPP definition in normal form [3,2]. All the complexity considerations in the following sections will be with respect to the size of the presentation of Γ.
Variables are thought to represent elementary processes, and multisets of vari- ables are interpreted as parallel compositions of elementary processes. The elements

of V ⊗ are thus thought to represent the processes of P . Let X, Y,... range over V , and α, β,... over V ⊗. We write αβ for the composition of α and β. The empty process (empty multiset) is denoted by ϵ.
The rewrite rules of Γ specify the behaviour of elementary processes: if (X, a, α1,
... , αm) ∈ Γ then X can perform action a and thereby evolve into the tuple of processes (α1,... , αm). The case m > 1 will turn out to be useful for expressing, e.g., distributed and branching bisimilarity. We impose the natural assumption that the idle transitions are determined, in the sense that for all X ∈ V :
(C1) there exists exactly one rule for the idle action (X, ∗, α1,... , αm) ∈ Γ, and for this rule αm = X.
Note that all derivatives may change due to an idle transition, except the last one. The rules for the idle action will be called idle rules in the sequel.
We define a transition relation for all processes inductively as follows:
a
if (X, a, α1,... , αm) ∈ Γ then X → (α1,... αm);

if α
a
→ (α1,... , αm), β
b
→ (β1,... , βm), and a • b is defined then we have

a•b
αβ → (α1β1,... , αmβm).
From the m-ary steps we derive single-derivative steps as follows: α	a	α'

iff

a	'
α → α1,... , αm with αm = α . This means we single out the mth derivate to play a
a	'	∗
special role. The transition relation α −→ α is extended to finite words w ∈ Act ,
w	'
written α −→ α , in a standard way.
Fact 2.1 Let a, b, and c range over Act ∪ {∗}.
∗
α −→ α.
a	'	b	'	a•b	' '
If α −→ α , β −→ β , and a • b is deﬁned then αβ −→ α β .
c	'	'	' '

If αβ
−→ γ then there are some a, b, α , β such that c = a • b, γ = α β ,

a	'	b	'
α −→ α , and β −→ β .

Normed Commutative Rewrite Systems
The norm of a process α, denoted by |α|, is the smallest weight necessary to reach from α the empty process by a sequence of transitions. Formally, we define:
w	∗	w	∗
|α| = min{W (w): α −→ ϵ, w ∈ Act }  if α −→ ϵ for some w ∈ Act ,
|α| = ∞	otherwise.
Note that we allow |α| = 0 even if α /= ε, whereas in normed and totally normed BPP (cf. Section 3) α /= ε always implies |α| > 0. Norm is additive wrt. composition of processes:
Proposition 2.2 if α and β have ﬁnite norms then |αβ| = |α| + |β|.
w	v	wv
Proof. If α −→ ϵ and β −→ ϵ then we can derive αβ −→ ϵ by applying Axiom (S2),
w
Fact 2.1(i), and Fact 2.1(ii). Hence, |αβ|≤ |α| +|β|. On the other hand, if αβ −→ ϵ

then by Fact 2.1(iii) we obtain α
u
−→ ϵ and β
v
−→ ϵ for some u, v such that

W (u)+ W (v)= W (w) by Axiom (S4). Thus, |αβ| ≥ |α| + |β|.	 
A weighted synchronization algebra is a triple (Act , •,W ) where (Act , •) is a synchronization algebra and W : Act ∪ {∗} → N0 is a weight function such that: (S3) W (∗)= 0;
(S4) a • b = c implies W (c)= W (a)+ W (b).
Axiom (S3) ensures the idle action has weight 0. (S4) expresses that the weight of an action does not depend on how it arises from synchronization. The weight of a sequence w = a1 ... ak is W (w)= W (a1)+ ... + W (ak).
A normed CRS is a triple (V, Act, Γ) satisfying the definition of CRS, such that Act is a weighted synchronization algebra, and the following holds:
(N1) each process α /= ϵ has finite and positive norm: 0 < |α| < ∞.
We will impose a second condition (N2). For its formulation we need some more
a	'
definitions. Let (V, Act, Γ) be a normed CRS as defined so far. A transition α −→ α
a	'
is norm-reducing, denoted by α −→n−r α , iff it can be extended to a sequence from
a	'	a	'  w	∗

α to ϵ of minimal weight: α −→n−r α iff α −→ α −→ ϵ for some w ∈ Act
with

W (aw) = |α|. We extend norm-reducing transitions to sequences v ∈ Act∗ as one
v	'	v	'  w	∗

could expect: α −→n−r α iff α −→ α −→ ϵ for some w ∈ Act
with W (vw)= |α|.

Due to additivity of norm we obtain the analogue of Fact 2.1 for −→n−r .
Without loss of generality we may assume that the variables of V are given as a sequence X1,... , Xk, ordered by non-decreasing norm: |X1|≤ |X2|≤ ... ≤ |Xk|.
Remark 2.3 Norm-reducing transitions are non-strict in that they do not lead to a
a	'	'	'
strict decrease in norm: if α −→n−r α then |α |≤ |α|, but not necessarily |α | < |α|.
This is a more general setting than usually considered.
If norm-reducing transitions were strict then a norm-reducing transition from a variable Xi would always lead to a multiset of variables of index strictly smaller than
i. We will assume that every normed CRS satisfies a weakening of this property:
(N2) Xi −→n−r α implies α ∈ {X1,... , Xi}⊗.
(N2) cannot be derived from (N1) in general, but it is satisfied immediately or modulo bisimilarity by all the concrete normed CRS’ we will study. With (N2) we obtain the crucial properties of norm-reducing transitions.
a	⊗
Proposition 2.4 If Xi −→n−r α then α ∈ {X1,... , Xi−1}	or α = Xi.
This is easily deduced from (N2) because |α|≤ |Xi|.

Bisimulations and Norm-Reducing Bisimulations
In this section we work relative to a CRS P = (V, Act, Γ). We naturally associate a notion of bisimilarity with P , defined as follows.

Definition 2.5 Given a relation R ⊆ V ⊗×V ⊗, we say a pair (α, β) ∈ V ⊗×V ⊗
satisﬁes expansion in R iff:
a
whenever α → (α1,... , αm) for some a, α1,... , αm then there exist β1,... , βm
a
such that β → (β1,... , βm) and all pairs (α1, β1),... , (αm, βm) are in R;
the symmetric condition holds.
We denote the set of pairs (α, β) that satisfy expansion in R by exp(R). A relation R ⊆ V ⊗×V ⊗ is a bisimulation iff each pair of R satisfies expansion in R, in other words, iff R ⊆ exp(R). We denote the greatest bisimulation by ≈ and refer to it as bisimilarity. If P is not clear from the context we also use the terms P -bisimulation and P -bisimilarity; the latter is denoted by ≈P .
A congruence is any equivalence ≡ that is compositional: if α ≡ α' and β ≡ β'
then αβ ≡ α'β'. The following fact is proved in a routine way:
Proposition 2.6 (i) Bisimilarity is a congruence. (ii) If ≡ is a congruence then the relation exp(≡) is a congruence too.
Assume P to be normed. Then there is also a notion of norm-reducing bisimula- tion associated with P . There is an important difference between bisimulations and norm-reducing bisimulations: the former are defined over m-ary steps → while the latter over single-derivative steps −→ only.
Definition 2.7 Given a relation R ⊆ V ⊗ × V ⊗, we say a pair (α, β) ∈ V ⊗×V ⊗
satisfies norm-reducing expansion in R, written (α, β) ∈ n − r − exp(R), iff:
a	'	'	'	a	'
whenever α −→n−r α for some a, α then there exists β such that β −→ β
and (α', β') ∈ R;
the symmetric condition holds.
A relation R ⊆ V ⊗×V ⊗ is a norm-reducing bisimulation iff R ⊆ n − r − exp(R).
Note an asymmetry in the definition: the response to the norm-reducing moves are unrestricted. Due to this, each bisimulation is a norm-reducing bisimulation. We say that a relation R ⊆ V ⊗×V ⊗ is norm-preserving iff |α| = |β| for each (α, β) ∈ R.

Proposition 2.8 Each norm-reducing bisimulation, and thus each bisimulation, is norm-preserving.
Proof. Let R be a norm-reducing bisimulation and let (α, β) ∈ R. Assume |α| < |β|
w	w
and consider a sequence α −→ ϵ of minimal weight. Observe that α −→ ϵ is norm-
reducing, α −→n−r ϵ. There must be some β' with β −→ β' and (ϵ, β') ∈ R. But
for any such β' we have necessarily |β'| > 0 and consequently there is a transition
β  −→n−r β'' for some a and β'', to which ϵ has no response. Hence, necessarily
|α| = |β|.	 
As a consequence we obtain: in each norm-reducing bisimulation, every (nec- essarily norm-reducing) transition will be matched by a transition that is norm-

reducing itself. We will assume this property in the sequel without further men- tioning.
Given a congruence ≡, the greatest norm-reducing bisimulation contained in ≡ always exists, and is given by the set-theoretic union of all norm-reducing bisimu- lations contained in ≡. We denote this relation by gnrb(≡).

Proposition 2.9 Given a congruence ≡, gnrb(≡) is a congruence.

Proof. That gnrb(≡) is an equivalence follows easily from ≡ being an equiva- lence. Compositionality of gnrb(≡) is easily proved by showing that the relation
{(αβ, α'β'): (α, α') ∈ gnrb(≡), (β, β') ∈ gnrb(≡)} is a norm-reducing bisimulation contained in ≡.	 


gnrb(≡) has a fix-point characterization which we will need later on:

Proposition 2.10 Let ≡ be a congruence. (α, β) ∈ gnrb(≡) iff α ≡ β and (α, β) ∈
n − r − exp(gnrb(≡)).

Proof. The only-if implication is obvious. For the opposite implication, we show that the relation {(α, β) : α ≡ β and (α, β) ∈ n − r − exp(gnrb(≡))} is a norm- reducing bisimulation contained in ≡, using the only-if implication.	 




Concrete Normed Commutative Rewrite Systems

Finally, we will get to know concrete CRS’, and see how their associated notions of bisimilarity coincide with the well-known equivalences: (i) strong bisimilarity on normed BPPτ , (ii) distributed bisimilarity on all BPPτ , (iii) weak bisimilarity on totally normed BPP, and (iv) branching bisimilarity on totally normed BPP. We cannot be completely self-contained here; in particular we refer the reader to the literature for the definitions [2,3,5].
In the following, we will need variables, ranged over by X, Y,.. ., and actions Act , ranged over by a, b,.. .. We will use BPP definitions Δ containing a finite
a

number of rules, typically of the form X
a
−→ α, where α is a finite multiset of

variables; in short we write Δ = {X −→ α}. We always assume that if a variable
occurs on the right side of a rule it will also appear on the left side of some rule.
In each case below, Δ will be a finite presentation of (will induce) a CRS P ; and bisimilarity ≈P will correspond to the bisimulation equivalence under consideration.

BPPτ under Interleaving Semantics
Assume a set of complementary actions
Act = a¯, ¯b, c¯,.. .. Let τ be a special el-

ement not contained in Act , the silent action. BPPτ uses CCS-style commu- nication where two complementary ac- tions can synchronize forming τ . The silent action can also occur by itself and any action can occur asynchronously. The corresponding synchronization alge-
∗ a	a¯
b	¯b ... τ

bra, ActCCS , is then (Act ∪ Act ∪ {τ }, •) where • is defined by the table on the right. We extend ActCCS by a weight function W , defined by: W (∗) = 0, W (a) = 1 for all a ∈ Act ∪ Act, and W (τ )= 2.
¯b ¯b	τ	... 
.	.	.	.	.	.  ... .
τ  τ	... 

a

A BPPτ definition in normal form is a finite set Δ = {X −→ α} where a ∈
Act CCS . Δ induces a CRS P = (V, Act, Γ) as follows: V and Act are derived from Δ and Act CCS in the obvious way; Γ is Δ with the additional rule (X, ∗,X) for all X ∈ V . The transition relation →P coincides with that obtained from the standard operational semantics for BPPτ definition Δ. This implies:
Fact 3.1 ≈P coincides with classical strong bisimilarity on processes of Δ.
Our notion of norm for processes of P coincides with that typically associated with processes of Δ [2]. Δ is normed iff every non-empty process has finite norm.
Fact 3.2 If Δ is normed then P is a normed CRS.

BPPτ under Distributed Semantics
Distributed bisimilarity reflects that whenever a process performs an action it can be thought to evolve into a local remainder and a concurrent remainder. Any guarded BPPτ definition can be transformed (in polynomial-time) into a BPPτ definition
a
in distributed normal form [3], that is a finite set Δ = {X −→ (αl, αc)} where
a ∈ Act CCS and the following relation ≺ on the variables of Δ is irreflexive: ≺ is the transitive closure of the relation ≺1 where Y ≺1 X iff there is a rule (X, a, αl, αc) in Δ such that Y ∈ αc. Intuitively, αl and αc express the local and concurrent part, respectively, of a derivative of X [3].
Δ induces a CRS P = (V, Act, Γ) as follows: V and Act are derived from Δ and Act CCS in the obvious way; Γ is Δ with the additional rule (X, ∗, ϵ,X) ∈ Γ for all X ∈ V . The transition relation →P coincides with that obtained from the distributed operational semantics for Δ. Thus, we have:
Fact 3.3 ≈P coincides with distributed bisimilarity on processes of Δ.
We assume that the variables of P are ordered according to ≺: Xi ≺ Xj implies

i < j. Then it is immediate:
Fact 3.4 P is a normed CRS.


BPP under Weak Semantics
Let Δ be a BPP definition, i.e., a BPPτ definition that does not contain any actions of Act. By −→ denote the transition relation associated with Δ under the standard operational semantics, or equivalently, the transition relation of the CRS induced by Δ.
τ	∗
Given two processes α, β, we write α (−→) β if β can be reached from α by
an arbitrary number of τ transitions. Weak bisimilarity abstracts away from silent actions by reflecting the following weak transition relation:
⎧⎨	τ	∗

⎩	τ	∗  '	a
''	τ	∗

'	''


To capture weak bisimilarity as a notion of P -bisimilarity, we need to exhibit a suitable CRS P such that →P coincides with =⇒. We achieve this by defining the synchronization algebra of weak actions, ActW = (Act W , •) where Act W and • are as follows.
Act W is the set of weak actions given by {'τ ∗aτ ∗' : a ∈ Act}∪ {'τ ∗'}. The action names indicate the type of weak transition a weak action is thought to represent; but note that we could have chosen other names just as well. When a process α performs a weak transition then several of α’s elementary processes may contribute to it. To reflect this we allow weak actions to occur as synchronized actions: two processes may jointly perform action 'τ ∗aτ ∗' if one process performs 'τ ∗aτ ∗' and the other process performs 'τ ∗'. Similarly, two processes may jointly perform action 'τ ∗' if they both perform 'τ ∗'. Formally, • is given by the following table:

... 
... 
... 

We associate a weight function W with Act W , defined by: W (∗)= 0, W ('τ ∗')= 0, and W ('τ ∗aτ ∗') = 1 for all a ∈ Act .
Δ induces a CRS P = (V, Act, Γ) as follows: V and Act are derived from V and

Act W in the obvious way; Γ is defined by:
(X, 'τ ∗', α) ∈ Γ	iff
(X, 'τ ∗aτ ∗', α) ∈ Γ	iff
(X, ∗,X) ∈ Γ.


τ
X =⇒ α,
a
X =⇒ α,

Note here a difference between Γ and its presentation. The set of rules Γ is infinite, in general; however, it is succinctly represented by a finite Δ.
The transition relation →P indeed captures the weak transition relation of Δ:
'τ ∗'	τ	'τ ∗ aτ ∗'	a
α → β iff α =⇒ β; and, α	→	β iff α =⇒ β. Thus, we obtain:
Fact 3.5 ≈P coincides with weak bisimilarity on processes of Δ.
Our notion of norm for processes of P coincides with that typically associated with processes of Δ in the context of weak bisimilarity. Δ is totally normed if each process has finite and positive norm. Assume P is induced from a totally normed Δ. Then it is immediate that P satisfies (N1) of the definition of normed CRS. However, condition (N2) is not necessarily obtainable: simply consider two

τ
variables X, Y such that X =⇒ Y
τ
=⇒ X. On the other hand, it is easy to check

that such X and Y will be weakly bisimilar (|X| = |Y | in particular). Thus, we can transform P into an equivalent (weakly bisimilar) CRS P ' by removing one of

τ
X or Y , say Y , whenever X =⇒ Y
τ
=⇒ X. This also involves substituting X for Y

whenever Y appears on the right side of a rule in Γ. Then the following relation ≤
τ
is a partial order: X ≤ Y iff |X| < |Y | or Y =⇒ X. We assume that the variables
of P ' are ordered according to ≺: Xi ≺ Yj implies i < j. Then P ' will indeed satisfy
(N2): whenever Xi −→n−r α then α ∈ {X1,... , Xi−1}⊗.
Fact 3.6 P ' is a normed CRS.
BPP under Branching Semantics
Branching bisimilarity abstracts away from silent actions while preserving the
branching structure in more detail than weak bisimilarity. It can be captured by considering the following type of observable transitions:
⎧⎨	τ	∗	a

(1)
a
α =⇒ (α1, α2) iff
α (−→) α1 −→ α2, or
τ

⎩ α (−→)∗ α1 = α2 and a = τ.
This is based on the notion of semi-branching bisimulation. In [1] it was shown that this variant of bisimulation induced the branching bisimilarity. For a concise
(a)	a
formulation, by α1 −→ α2 we mean α1 −→ α2 or a = τ and α1 = α2. The following
may be easily deduced from [1]:
Proposition 3.7 A binary relation R over processes is a semi-branching bisimula- tion if and only if for each (α, β) ∈ R and a ∈ Act ∪ {τ },

τ	∗	' (a)	''
τ	∗	' (a)	''

'	''

whenever α (−→) α −→ α
then β (−→) β −→ β
, for some β , β
, with

(α', β') ∈ R and (α'', β'') ∈ R;

the symmetric condition holds.
Accordingly, the set of branching-observable actions is now {'τ ∗a' : a ∈ Act ∪
{τ }} ∪ {'τ ∗'}. Note that we distinguish between 'τ ∗' and 'τ ∗τ ', which correspond to the two different cases in (1). By similar considerations as for weak bisimilarity we arrive at the following synchronization algebra.

∗
... 
... 
... 
... 
... 
Clearly 'τ ∗' • 'τ ∗' = 'τ ∗' and 'τ ∗' • 'τ ∗a' = 'τ ∗a', but 'τ ∗τ ' • 'τ ∗a' is undefined. Hence necessarily 'τ ∗' /= 'τ ∗τ '. On the other hand, branching bisimilarity allows to match a 'τ ∗' step by 'τ ∗τ ' and vice versa. This motivates the following definition of Γ:
(X, 'τ ∗',α ,α ) ∈ Γ	iff	τ	∗
1	2	X (−→) α1 = α2,

(2)
' ∗ '
τ	∗	(a)

(X, τ
a , α1, α2) ∈ Γ	iff	X (−→)
α1 −→ α2.

Note that if (X, 'τ ∗', α1, α2) ∈ Γ then (X, 'τ ∗τ ', α1, α2) ∈ Γ as well. Additionally we put (X, ∗, X,X) ∈ Γ. This induces a CRS P and we obtain:
Fact 3.8 ≈P coincides with branching bisimilarity on processes of Δ.
If Δ is totally normed, then P can be easily made normed, similarly as before.
For comparison, we summarize the different formats of idle rules used to char- acterize the four equivalences:

Note a difference between distributed and branching equivalence: in the former one, the idle move of X ’contributes’ the empty process ϵ to the local derivative; in the latter, instead of ϵ, X itself must be used, to faithfully respect definition of semi-branching bisimulation [1].
The observation that the very different kinds of bisimulation equivalences can be captured in a uniform way, was the starting point and motivation for developing the general algorithm presented in Section 5.

Unique Decomposition
We now prove our unique decomposition results. As explained in the introduction we build on a theorem by Luttik and van Oostrom that characterizes when a par- tial commutative monoid has unique decomposition. We first introduce this tool, specialized to the case of commutative monoids.
Let M be a commutative monoid with identity element e. An element p of M is called indecomposable if p /= e and p = xy implies x = e or y = e. A decomposition
of x in M is a finite multiset pa1 ... par of indecomposable elements of M such that
1	r
x = pa1 ... par . If every element of M has a unique decomposition (up to multiset
1	r
equality) then we say that M has unique decomposition.
A partial order ≤⊆ M ×M is a decomposition order if
it is well-founded : every non-empty subset of M has a ≤-minimal element;
e is the least element of M wrt. ≤: e ≤ x for all x ∈ M ;
it is strictly compatible: for all x, y, z ∈ M , if x ≺ y then xz ≺ yz;
it is precompositional : for all x, y, z ∈ M , x ≤ yz implies x = y'z' for some
y' ≤ y and z' ≤ z; and
it is Archimedean: for all x, y ∈ M , xn ≺ y for all n ∈ N implies x = e.
Corollary 4.1 (by Corollary 3.15 from [12]) A	commutative	monoid	has unique decomposition iff it has a decomposition order.
With the help of this tool we now prove our unique decomposition results. Let P = (V, Act, Γ) be a normed CRS, and ∼ ⊆ V ⊗×V ⊗ be a congruence. V ⊗/∼ is the quotient of V ⊗ by ∼, i.e., the set of equivalence classes of V ⊗ wrt. ∼. We write [α]∼ for the equivalence class containing α. Since ∼ is a congruence we can define on V ⊗/∼ a binary operation as follows: [α]∼[β]∼ = [αβ]∼. It is easy to verify that V ⊗/∼ is a commutative monoid under this operation with identity element [ϵ]∼.
Theorem 4.2 Let ∼ be a congruence which is a norm-reducing bisimulation. The commutative monoid V ⊗/∼ has unique decomposition.
Assume ∼ to be a congruence which is a norm-reducing bisimulation. We can exploit the properties of norm-reducing transitions to exhibit a decomposition order on V ⊗/∼. Define a relation “ on V ⊗/∼ as follows:

[β]∼ “ [α]∼
'	n−r β' ∼ β for some α', β', and w ∈ Act∗.

Proposition 4.3 below establishes that “ is a decomposition order. Theorem 4.2 is then an immediate consequence of Corollary 4.1.
Proposition 4.3  (i) “ is a partial order.	(ii) “ is a decomposition order.
Proof. (i) Reflexivity is immediate from the definition. Transitivity follows since
~ is a norm-reducing bisimulation. It remains to show that “ is antisymmetric.

Assume [β]∼ “ [α]∼ and [α]∼ “ [β]∼. Hence α ∼ α' −w→n−r β'
~ β ∼ β
v
−→n−r

α'' ∼ α for some w, v, α', α'', β', β''. Since ∼ is a norm-reducing bisimulation this

allows us to deduce an infinite sequence
'  w	'  v	w	v	w

α −→n−r β
−→n−r α1 −→n−r β1 −→n−r α2 −→n−r β2 ... 

for some α1, β1, α2, β2,... such that for all i, α ∼ αi and β ∼ βi. By an analog of Fact 2.1(iii) for norm-reducing transitions, we can transform the above sequence into one where all the transitions result from rewriting a single variable. By Prop. 2.4 we immediately deduce that the sequence must be constant from some point i onwards: αi = βi = αi+1 = βi+1 =   This implies α ∼ β and hence [β]∼ = [α]∼ as required.
(ii) We verify that Properties (i) to (v) of the definition of decomposition order are satisfied by “. (i) Well-foundedness: assume that there exists an infinite strictly descending chain wrt. “, and observe that the norm does not increase along the chain. Therefore, this would require infinitely many processes of norm bounded by the norm of the first element – a contradiction. Property (ii) is immediate since
w
for all α, α −→n−r ϵ for some w. To verify Property (iii) recall that by Axiom
(S2) of synchronization algebras every action can occur asynchronously: a •∗ = a. Then strict compatibility and precompositionality are immediate by norm-reducing versions of Fact 2.1(2) and Fact 2.1(iii), respectively. To validate Property (v) observe: for all α such that α /= ϵ and β we can always find n such that |αn| > |β|.
(v) is then immediate since by Prop. 2.8 norm carries over from V ⊗ to V ⊗/∼. 
Since ≈P is a congruence and every bisimulation is a norm-reducing bisimulation we immediately obtain:
Corollary 4.4 The commutative monoid V ⊗/≈P has unique decomposition.
Finally, in view of our algorithm we derive a more compact formulation of our unique decomposition results. The formulation is in the style of [6], and makes use of the assumption that decompositions preserve norm, and that variables are given in order of non-decreasing norm.
Assume ∼ to be a norm-preserving congruence. An elementary process Xi is decomposable wrt. ∼ if there exists α ∈ {X1,... , Xi−1}⊗ such that Xi ∼ α. Oth- erwise Xi is prime wrt. ∼. Let P1,... , Pr be the primes of V wrt. ∼, ordered consistently with V itself. We say that ∼ has unique decomposition if for any
processes α = Pa1 ... Par and β = Pb1 ... Pbr , α ∼ β implies a1 = b1,... , ar = br.
1	r	1	r
Corollary 4.5
Let ∼ be a congruence which is a norm-reducing bisimulation. Then ∼ has unique decomposition.
≈P has unique decomposition.
Proof. (i) This follows from Theorem 4.2 by the following observation: if Xi is prime wrt. ∼, then [Xi]∼ is indecomposable in V ⊗/∼. By Prop. 2.8 norm-reducing bisimulations are norm-preserving. Hence, any proper component of [Xi]∼ is of norm smaller than Xi, which implies [Xi]∼ is either prime or representable by variables of index smaller than i.
(ii) is then also obvious.	 

Decision Procedure
Motivated by concrete CRS’ from Section 3 we introduce the following notions. A
presentation Δ consists of a finite set V of variables, a finite set of actions, and a
afinite   set of rules of the form X (α ,... , α ), for some fixed m, where X ∈ V , a is a action, and each αi ∈ V ⊗ consists exclusively of variables than appear on the left-hand side of some rule. A presentation mapping is a partial function P that assigns, to a presentation Δ, a normed CRS P = P(Δ) over the same variables V . Assume a fixed presentation mapping P in this section. If P = P(Δ) we say that Δ is a presentation of P , or that P is represented by Δ.
In this section we provide our general decision procedure. As explained in Sec- tion 1 it is an extension of [6]. We consider the following bisimilarity problem:
Input:	A presentation Δ of a normed CRS P , and two variables X, Y .
Question:	Decide whether X ≈P Y .
From our generic decision procedure, one obtains the algorithms for the four concrete bisimulation equivalences (cf. Section 6), by providing a particular implementation of a subroutine that we specify in the sequel.
In the following, we first present some preliminaries. In particular, we will define when, wrt. to a given complexity class 7 , we consider the presentation mapping to be 7 -effective. We will then prove our main result: whenever a presentation mapping is 7 -effective then the bisimilarity problem can be decided in 7 . Finally, we provide the proofs that have been left out in the main text.

Preliminaries
Throughout the section, let P = (V, Act, Γ) be a normed CRS represented by Δ. Recall that the set of rewrite rules Γ can be infinite. However, the input to our algorithm will be Δ, not P itself. The set of variables V is available through Δ while the synchronization algebra Act will not be explicitly needed. All we need is that the presentation mapping is 7 -effective. As we will see below this ensures a sufficient set of the behaviour of P can be enumerated in 7 . We impose the following assumption though.
Assumption 1 We assume that the presentation Δ of P satisﬁes the following condition. For each variable X ∈ V we have:
(i) The idle rule for X is in Δ. (Recall that the idle rule is unique.)
a(ii) X    (α ,... , α  ) is in Δ for at least one rule (X, a, α ,... , α ) ∈ Γ such
athat X	α	and X /= α .
The first condition guarantees that idle transitions are available for the com- putation as a part of input; it is used later on to prove Prop. 5.4(i). The second condition, necessary to prove Prop. 5.1 below, requires availability of at least one non-trivial norm-reducing transition of each X. The conditions are naturally satis- fiable for all the concrete cases we will consider in Section 6. In the following, we

denote the size of presentation Δ by n.
We assume that processes of P are represented as products Xa1 ... Xak , where
1	k
the exponents a1,... , ak are encoded in binary. Often, it will be sufficient to consider
small processes only. A process α is called small if |α| ≤ |X| for some variable X. We will make use of the following observations:
Proposition 5.1
The norms of all variables are computable in time polynomial wrt. n.
The norm of a process α can be computed in time polynomial wrt. n and the size of α.
The norm of a variable, and hence, of a small process is at most exponential wrt. n.
A small process can be represented in space polynomial wrt. n.
For the purpose of generality, we work in this section with an arbitrary determin- istic complexity class 7 that includes PTIME (e.g., PTIME, PSPACE, EXPTIME, etc). 7 is specified by (1) some complexity bound function f , mapping the size of input to the amount of resource available, and (2) the type of resource f refers to, time or space. Furthermore, we assume that the class 7 is determined ’up to a polynomial’, in the sense that it is the union of the complexity classes 7k, k > 0, corresponding to the bounds fk(n)= f (nk). In Section 6 we will instantiate 7 with PTIME and PSPACE. We use the following convention: whenever we state that a problem is in 7 and do not specify what the input size of the problem is we always mean complexity wrt. n, the size of Δ.
We consider a presentation mapping to be 7 -effective whenever, given Δ as input, we are able to enumerate in 7 a subset of the m-ary transitions of P , say S, such that S fully captures the behaviour of small processes in the following sense: every transition starting from a small process is either contained in S or it can be obtained as the synchronization of a transition in S and an idle transition. In the
∗
following, for notational convenience, we allow the transition ϵ → (ϵ,... , ϵ).
Definition 5.2 We say a set S of →-transitions is sufficient for P iff whenever
a	'  a	'	'	∗
α → (α1,... , αm) and α is small then there is α → (α1,... , αm) ∈ S and β →
(β1,... , βm) such that α = α'β, α1 = α' β1, .. ., αm = α' βm.
1	m
Definition 5.3 We say P is 7 -effective if every P = P(Δ) has a sufficient set that, given Δ as input, can be enumerated in 7 .
Observe that we do not require to compute and store the sufficient set: we only need to enumerate it, i.e., generate each of its transitions in a systematic way for further processing. For the rest of this section we need:
Assumption 2 Presentation mapping P is 7 -effective.
Proposition 5.4 Given an action a ∈ Act, and a small process α, the following

sets can be enumerated in 7
a
succa(α)= {(α1,... , αm): α → (α1,... , αm)},
a
n — r — succa(α)= {β : α —→n−r β}.

Decision Procedure
The initial insight behind our procedure is this: since ≈P satisfies unique decom- position it can be represented by a unique decomposition base [6].
Definition 5.5 A (norm-preserving) unique decomposition base for the variables Vi = {X1,... , Xi} of V is a pair D = (Π, Γ), where Π ⊆ Vi is a set of primes, and Γ is a set of pairs (X, α) such that α ∈ Π⊗, |X| = |α|, and there is one pair for each variable X ∈ Vi \ Π. Γ is thought to specify for each non-prime variable X a decomposition into primes. The primes of a decomposition base are, a priori, arbitrarily chosen and not to be confused with the primes wrt. a given congruence. D induces a relation ≡D on Vi⊗: α ≡D β iff the prime decompositions of α and β are equal. For Vi = V we simply call D a unique decomposition base.
Proposition 5.6 Let D be a unique decomposition base.
≡D can be decided in polynomial time wrt. n and the sizes of the two input processes.
For small processes, exp(≡D) can be decided in 7 .
Let ≡ be a norm-preserving congruence and recall from Section 2.3 that the greatest norm-reducing bisimulation contained in ≡ exists and is denoted by gnrb(≡
). By Prop. 2.9 and Corollary 4.5(i) gnrb(≡) has unique decomposition, and is thus representable by a unique decomposition base D. Our core insight is that due to Prop. 2.4 we can construct D inductively, and thus efficiently.
Using this insight we can approximate bisimilarity from above by a sequence of norm-preserving congruences. We start with the greatest such relation, say ≡, and compute the decomposition base D that represents gnrb(≡). If ≡D is a bisim- ulation then we have already reached bisimilarity. Otherwise we can move strictly closer to bisimilarity by intersecting ≡D with exp(≡D). That is, we consider a new congruence ≡' defined by α ≡' β iff α ≡D β and (α, β) satisfies expansion in ≡D. We continue by computing the unique decomposition base that represents gnrb(≡'), and proceed in this fashion until finally we will hit bisimilarity. First of all, we prove the core insight.
Theorem 5.7 Let ≡ be a norm-preserving congruence that, for small processes, can be decided in 7 . Then a unique decomposition base D can be computed in 7 such that ≡D = gnrb(≡).
Proof. For each i ∈ [1,... , k] we define, by induction, a unique decomposition base
Di = (Πi, Γi) for {X1,... , Xi}⊗, with Πi = {P1,... , Pr}, such that:
each Pj is prime wrt. gnrb(≡); and

(Xj,Px1 ... Pxr ) ∈ Γi implies (Xj,Px1 ... Pxr ) ∈ gnrb(≡).
1	r	1	r
Assume there exists a unique decomposition base Di for {X1,... , Xi}⊗ that sat- isfies these two properties. Then the following three claims will hold (c.f. Section 5.3 for the detailed proofs):
Claim 5.8 ≡D = gnrb(≡) holds on the set {X1,... , Xi}⊗.
Claim 5.9 Let α be a composition Px1 ... Pxr .	Then (Xi+1, α) ∈ gnrb(≡) iff
1	r

Xi+1 ≡ α and (Xi+1, α) ∈ n — r — exp(≡Di ∪ {(Xi+1, α)}).
Claim 5.10 It can be decided in 7 whether there is α = Px1 ... Pxr

that satisﬁes

1	r
the right-hand side of Claim 5.9. If there is such α it can be found in 7 .
Claim 5.8 specialized to i = k ensures ≡Dk = gnrb(≡) as required. Claim 5.9 indicates how to extend Di to a unique decomposition base Di+1 that also satis-
fies Properties (1) and (2). By Claim 5.9, Property (1), and since gnrb(≡) has unique decomposition there is at most one α = Px1 ... Pxr such that Xi+1 ≡ α and
1	r
(Xi+1, α) ∈ n — r — exp(≡Di ∪ {(Xi+1, α)}). If there is such α, declare it to be the
decomposition of Xi+1 in Di+1. Otherwise declare Xi+1 to be prime in Di+1. It is clear that Properties (1) and (2) are satisfied. By Claim 5.10 the extension of Di to Di+1 can be computed in 7 . Then overall, Dk can also be computed in 7 . 
Apart from our core theorem we require two lemmas, which are analogous to insights of [6]. The first lemma gives us the means to efficiently check whether we have reached bisimilarity.
Lemma 5.11 Let D = (Π, Γ) be a unique decomposition base.
≡D is a bisimulation iff Γ satisﬁes expansion in ≡D, that is Γ ⊆ exp(≡D).
It can be checked in 7 whether ≡D is a bisimulation.
The second lemma ensures that ≡D ∩ exp(≡D) is a congruence as required, and strictly refines ≡D whenever we have not reached bisimilarity yet.
Lemma 5.12 Let D be a unique decomposition base.
≡D ∩ exp(≡D) is a norm-preserving congruence that, for small processes, can be decided in 7 .
If ≡D is not a bisimulation then some variable decomposable wrt. ≡D is prime wrt. ≡D ∩ exp(≡D).
The algorithm consists of the loop outlined below. In each iteration a given congruence ≡ is refined to a congruence ≡D that is represented by a unique decom- position base D. Then ≡D is in turn reduced to a new congruence, which provides the value of ≡ for the next iteration. Note that ≡ will not be kept explicitly but be available in terms of its decision procedure. The following two invariants hold:
Invariant 1: ≡ is a norm-preserving congruence that, for small processes, can be decided in 7 .
Invariant 2: ≡ and ≡D both subsume bisimilarity: ≈⊆≡ and ≈⊆ ≡D.

Let ≡ be the congruence defined by α ≡ β iff |α| = |β|.
Compute a unique decomposition base D such that ≡D = gnrb(≡). This can be done in 7 by using Theorem 5.7.
If ≡D is a bisimulation then halt and return D.
The condition can be checked in 7 by Lemma 5.11(ii).
Otherwise, redefine ≡ to be the congruence ≡D ∩ exp(≡D). Go to step (2).
Claim 5.13 (Invariants) Invariants 1 and 2 are indeed satisﬁed.
After step (1), Invariant 1 holds by the definition of ≡ and because by Prop. 5.1(ii) and (iv) ≡ is computable in polynomial time. Invariant 2 follows since by Prop. 2.8
≈ is norm-preserving. Step (2) clearly preserves Invariant 2: ≈ is a norm-reducing bisimulation contained in ≡ while ≡D is the greatest such relation. After Step (4), Invariant 1 holds by Lemma 5.12(i). Invariant 2 follows since ≈ ⊆ ≡D and
≈ = exp(≈) ⊆ exp(≡D).
Claim 5.14 (Termination) The algorithm halts after at most n iterations.
By definition ≡D ∩ exp(≡D) is finer than ≡D. This implies that if a variable Xi is prime in D it will also be prime in the decomposition base of the next iteration. Lemma 5.12(ii) ensures that on each iteration at least one variable becomes prime that was not prime before. Thus, the number of iterations is indeed bounded by n.
Claim 5.15 (Complexity) The algorithm works in 7 .
This follows from Claim 5.14 and because each iteration can be completed in 7 .
Claim 5.16 (Correctness) The unique decomposition base D output by the algo- rithm represents bisimilarity: ≡D = ≈.
The inclusion ≈⊆ ≡D follows by Invariant 2 while the opposite inclusion is imme- diate by ≡D being a bisimulation.
Since ≡D can be decided in polynomial time (c.f. Prop. 5.6(i)) altogether we have proved:
Theorem 5.17 For a 7 -effective presentation mapping, the bisimilarity problem is decidable in 7 (wrt. the size of presentation).

Proofs

Proof. [Prop. 5.1] (i) The norms of all variables can be computed in the standard way as the unique solution of the set of linear equations of the form: |X| = W (a)+ 
|αm|, one for each variable X, where αm is given by the norm-reducing transition

a
X —→n−r αm obtained from a rule X
a
—→ (α1,... , αm) from Δ as assured by

Assumption 1; |αm| stands for the sum of norms of all variables in αm. Recall that by Prop. 2.4 in Section 2, the set of equations is ‘acyclic’ and hence has a unique solution.
(ii) follows from (i). (iii) is straightforward considering Assumption 1. (iv) is a consequence of (iii).	 

For the proof of Prop. 5.4 we will use Prop. 5.18 below. In the formulation of this proposition we make use of the following observation: given an idle transition
∗
β → (β1,... , βm), for all j ∈ [1,... , m], βj is uniquely determined by β: if β =
Xa1 ... Xak then βj = βa1 ... βak  where, for j ∈ [1,... , m], i ∈ [1,... k], βi,j is

1	k	1,j
∗
k,j

given by Xi → (βi,1,... , βi,m) ∈ Γ. (Recall that for each variable there is exactly
∗
one idle rule in Γ. Also recall our convention ϵ → (ϵ,... , ϵ).) For two processes α,
α' we write α' ± α iff α' is contained in α as a multiset. We write α\α' for α minus
α' as multisets.
Proposition 5.18 Let α be small, and S be a sufficient set for P.
a	'  a	'	'	'

α → (α1,... , αm) iff there is α → (α1,... , αm) ∈ S	such that α
± α,

α' ± α , .. ., α' ± α
' ∗	'	'

1	1	m
m and α\α
→ (α1\α1,... , αm\αm).

a	' a	'	'	'	'

α —→n−r β iff there is α
α' ± α, and β = (α\α') α'
→ (α1,... , αm) ∈ S such that |α | = W (a)+ |αm|,
.

m
Proof. (i) The only-if direction follows from the definition of sufficient sets. The if-direction follows from the inductive definition of the m-ary transition relation (c.f. Section 2).
(ii) This is immediate with (i) when considering Axiom (C1) of the definition of CRS’.	 
Proof. [Prop. 5.4] (i) We can assume a sufficient set S that can be enumerated in 7 . Then we can enumerate succα(a) in 7 by stepping through the transitions in S as indicated by Prop. 5.18(i). Note that by Assumption 1(i) the idle transitions are contained in Δ and therefore directly available for this computation.
(ii) This similarly follows from Prop. 5.18(ii): in addition consider Prop. 5.1(ii). 
Proof. [Prop. 5.6] (i) A polynomial-time algorithm follows directly from the def- inition of ≡D when considering Prop. 5.1(iv) and that for pairs (X, α) ∈ Γ, α is small.
(ii) This follows from (i) and Prop. 5.4(i).	 
Proof. [Claim 5.8] Let α, β ∈ {X1,... , Xi}⊗. If α ≡D β then by Property (2) and gnrb(≡) being a congruence we can conclude (α, β) ∈ gnrb(≡). For the opposite di- rection, assume (α, β) ∈ gnrb(≡). By Property (2) and gnrb(≡) being a congruence we obtain (α', β') ∈ gnrb(≡) where α' is the prime decomposition of α wrt. Di, and similarly for β'. Then α ≡Di β follows by Property (1) and unique decomposition of gnrb(≡).	 
Proof. [Claim 5.9] Let α  = Px1 ... Pxr .  For the only-if implication, as-
1	r
sume that (Xi+1, α) ∈ gnrb(≡).	By Prop. 2.10 this gives us Xi+1 ≡ α and
(Xi+1, α) ∈ n — r — exp(gnrb(≡)). We will show how the latter implies (Xi+1, α) ∈
n — r — exp(≡Di ∪ {(Xi+1, α)}).

By Prop. 2.4 we know: if Xi+1	a
β then either β = Xi+1
or β ∈

⊗	a	⊗

{X1,... , Xi} ; and, if α —→n−r γ then γ ∈ {X1,... , Xi}
. Thus, using Claim 5.8

we deduce that (Xi+1, α) is element of the set:
n — r — exp(≡D ∪ {(Xi+1, γ): γ ∈ {X1,... , Xi}⊗, (Xi+1, γ) ∈ gnrb(≡)}).

By unique decomposition of gnrb(≡) there can only be one γ ∈ {X1,... , Xi}⊗ satisfying (Xi+1, γ) ∈ gnrb(≡), and this γ must be α. Hence, we indeed obtain that (Xi+1, α) ∈ n — r — exp(≡Di ∪ {(Xi+1, α)}).
To prove the if implication, assume Xi+1 ≡ α and (Xi+1, α) ∈ n — r — exp(≡Di
∪{(Xi+1, α)}).	By Claim 5.8 we obtain (Xi+1, α) ∈  n — r — exp(gnrb(≡) ∪
{(Xi+1, α)}). But then gnrb(≡) ∪ {(Xi+1, α)} is a norm-reducing bisimulation con- tained in ≡, and (Xi+1, α) ∈ gnrb(≡) is immediate because gnrb(≡) is the greatest such relation.	 
Proof. [Claim 5.10] We need to investigate whether there is α = Px1 ... Pxr
1	r
such that Xi+1 ≡ α and (Xi+1, α) ∈ n — r — exp(≡Di  ∪ {(Xi+1, α)}).	Since
|Xi+1| > 0 there must be some norm-reducing transition Xi+1	a	β such that
n−r
β ∈ {X ,... ,X }⊗. Then α must be in the following candidate set: {Py1 ... Pyr :
1	i	1	r
|Py1 ... Pyr | = |X	|, Py1 ... Pyr	a	β', and β' ≡	β}. Below we will show:

1	r	i+1	1
r —→n−r	Di

Claim 5.19 The candidate set can be enumerated in 7 .
Then, for each process α in the candidate set, check if
Xi+1 ≡ α, and
(Xi+1, α) ∈ n — r — exp(≡Di ∪ {(Xi+1, α)}).
The first condition is decidable in 7 by assumption since each process in the candi- date set is small. The second condition amounts to checking whether for all actions a, the processes from n — r — succa(Xi+1), and n — r — succa(α) respectively, in- duce the same set of prime decompositions wrt. Di. This is computable in 7 by Prop. 5.4(ii) and Prop. 5.6(i).
It remains to prove the above claim. Let S be a sufficient set for P that can be enumerated in 7 . Observe that by Prop. 5.18(ii) there are only as many possibilities for α as there are transitions in S. Considering this proposition, we can enumerate the candidate set in 7 as follows. Let βp be the prime decomposition wrt. Di of β.
' a'	'	'	'	'
For each transition α → (α1,... , αm) ∈S do: check whether (1) a = a , (2) α is a
prime decomposition, and (3) |α'|— |α' | = |Xi+1|— |β|. Further check whether the

prime decomposition wrt. Di of α'
, say α'
, is contained in βp (as a multiset). If

all these checks are successful, in βp substitute α' for α'
, and output the result as

an element of the candidate set.	 
Proof. [Lemma 5.11] (i) The iff -direction is obvious. To prove the if -direction suppose Γ ⊆ exp(≡D). Assuming α ≡D β we will show (α, β) ∈ exp(≡D). Let γ be the unique decomposition of α and β into primes: γ is obtained from α and β by substituting all their non-prime variables Xi by γi where (Xi, γi) ∈ Γ. Since each pair of Γ satisfies expansion in ≡D, by Prop. 2.6(ii) this must also hold for the pair (α, β).

(ii) This is a consequence of the first part and Prop. 5.6(ii).	 
Proof. [Lemma 5.12] (i) To see that ≡D ∩ exp(≡D) is a norm-preserving congru- ence consider Prop. 2.6(ii) and that ≡D is a norm-preserving congruence. Decid- ability in 7 follows from Prop. 5.6(i) and (ii).
(ii) Let D = (Π, Γ) where Π = P1,... , Pr. If ≡D is not a bisimulation then
by Lemma 5.11, Γ /⊆ exp(≡D). Let Xi be the variable of smallest index such that (Xi,Px1 ... Pxr ) ∈ Γ but (Xi,Px1 ... Pxr ) does not satisfy expansion in ≡D. We
1	r	1	r
will show that Xi is prime wrt. the congruence ≡D ∩ exp(≡D).
Suppose to the contrary that Xi ≡D α and (Xi, α) satisfies expansion in ≡D, for some α ∈ {Xi,... , Xi−1}⊗. By minimality of i, for every Xj appearing in α, if
(X ,Py1 ... Pyr ) ∈ Γ then this pair satisfies expansion in ≡ . Hence, by X ≡	α

j	1	r
D	i	D

and Prop. 2.6(ii) the pair (α, Px1 ... Pxr ) also satisfies expansion in ≡D, and by
1	r
transitivity, so does (Xi,Px1 ... Pxr ). But this contradicts the choice of Xi.	 
1	r

Results for Concrete Cases
Finally we apply Theorem 5.17 to obtain results for the four concrete process se- mantics introduced in Section 3.
Theorem 6.1
Strong bisimilarity on normed BPPτ is decidable in PTIME.
Distributed bisimilarity on BPPτ is decidable in PTIME.
Proof. As explained in Section 3, the two process semantics are captured by the normed CRS’ represented by a BPPτ process definition in standard form, and dis- tributed standard form respectively, extended with appropriate idle rules. In each case presentation clearly satisfies Assumption 1. The two presentation mappings are PTIME-effective. A sufficient set of transitions can easily be enumerated in PTIME since according to CCS synchronization at most two non-idle transitions can be synchronized: for each pair of complementarily labelled rules in Γ add a τ transition that represents the synchronization of the two rules.	 
Theorem 6.2
Weak bisimilarity on totally normed BPP is decidable in PSPACE.
Branching bisimilarity on totally normed BPP is decidable in PSPACE.
Let Δ be a totally normed BPP definition. In the following, we exhibit two normed CRS’ that characterize the two process semantics, are given by a PSPACE- effective presentation mapping. We will make use of a result by Esparza about communication-free Petri nets. (An analogous result for commutative context-free grammars was first obtained in [7].)
Theorem 6.3 (Theorem 3.2 of [4]) The  reachability  problem  for communication-free Petri nets is NP-complete.

It is well-known that communication-free Petri nets exactly correspond to BPP in standard form [4]. Hence, the theorem carries over to processes of Δ: given processes α, β, whether β can be reached from α by some sequence of transitions
a1	an
α —→ ... —→ β is NP-complete. Further, if we adapt the decision procedure by
only considering the τ -labelled rules of Δ we obtain:
τ	∗
Corollary 6.4 Given two processes α, β, whether α (—→) β can be decided in NP
(in the sizes of Δ, α, and β).

Branching Bisimilarity
Let P be the normed CRS, represented by Δ, that captures branching bisimilarity on totally normed BPP (c.f. Section 3.4). Extend Δ by the idle rule (X, ∗, X,X) for each variable X; this ensures Assumption 1 is satisfied. We will show that this presentation mapping is PSPACE-effective. Recall that P is based on a particular notion of semi-branching bisimulation [1], which only considers transitions


τ	∗	(a)

β (—→) β1 —→ β2.
a
This kind of bisimulation requires a response (3) to each move α —→ α2, whenever
a pair (α, β) is related, such that the pairs (α, β1) and (α2, β2) are related too. This implies that |α| = |β1|, and therefore |β1| = |β|. Knowing this, we assume that the additional requirement
|X| = |α1|
was imposed on the rewrite rules of P (cf. (2) in Section 3.4). This ensures that if β is small the resulting processes β1 and β2 in (3) will remain representable in polynomial space. Using Corollary 6.4 it is then straightforward to enumerate a sufficient set for P .
Lemma 6.5 The presentation mapping of branching bisimilarity is PSPACE- effective.
Proof. Given Δ, one can enumerate the set of all non-idle transitions of P that start from a small process in the following way. Step through every pair of small processes
τ	∗
α, β1. Test whether |α| = |β1| and, using Corollary 6.4, whether α (—→) β1. If

'τ ∗'
both tests are successful then: (1) output α → (β1, β1); (2) output α
'τ ∗ a'
'τ ∗ τ '
→ (β1, β1);

(3) for every rule (X, a, β) ∈ Δ such that X ± β1 output α → (β1, (β1 \ X)β).
The enumerated set is clearly sufficient and can be computed in PSPACE. 

Weak Bisimilarity
The weak bisimilarity case is not as immediate. In particular, the normed CRS exhibited in Section 3 would only lead to an elementary decision procedure. Let Δ be a totally normed BPP definition. We can decide in NP whether there exists a weak transition between two given processes:

a
Lemma 6.6 Given a ∈ Act ∪ {τ }, and processes α, β, whether α =⇒ β can be
decided in NP (in the sizes of Δ, α, and β).
Proof. A transition labelled by τ induces a change of norm ≥ 0 and one labelled by a ∈ Act a change of norm ≥ —1. Hence, we can decide the above problem as follows. Guess processes α', β' such that |α'| ≤ |β| +1 and |β'| ≤ |β|. Using Corollary 6.4

τ	∗ '	a
'	τ	∗	'	'

check whether α (—→) α
—→ β (—→) β. Since α
and β
can be represented in

space polynomial in the input, this clearly runs in NP.	 

Since weak transitions can bring about an unbounded increase of norm, this lemma does not immediately help us to enumerate a sufficient set in PSPACE. As for branching bisimilarity we need a special characterization of weak bisimilarity, which allows us to only consider transitions with a small increase of norm. We use the concept of stratiﬁed bisimilarity by Stirling [16].
aAny   transition α β gives rise to a change of weak norm given by |β|— |α|. As already observed in the previous proof, the change is greater or equal to —1, when
aa                      /= τ , and greater or equal to 0 otherwise. The application of a rule (X γ) ∈ Δ induces a change of norm |γ|—|X| since norm is additive. Denote by K the maximal
achange      of norm exhibited by a rule in Δ: K = max{|γ|— |X| : X γ ∈ Δ}. As the maximal norm of a variable is at most exponential in the size of Δ, K is also so. Stirling’s insight is that, in the definition of weak bisimulation, it is sufficient to consider only those transitions that give rise to a change of norm not larger than K. We call such transitions small weak transitions in the sequel and use the following notation for —1 ≤ k ≤ K:
a	a
α =⇒k β	iff	α =⇒ β and |β|— |α| = k.
Based on the insight, we will now derive another normed CRS P that captures weak bisimilarity. This new P will be similar to the previous one; however, the presentation mapping will be, in contrast to the previous one, PSPACE-effective. The only new ingredient is the treatment of the indices k.
The new synchronization algebra contains more actions. We define Act W =

{'τ ∗aτ ∗'
: a ∈ Act , —1 ≤ k ≤ K}∪ {'τ ∗'
: 0 ≤ k ≤ K}. Similarly to before, the

action names indicate the type of weak transition an action is thought to represent; k describes the change of norm induced by a given action. Operation • is also defined similarly to before, but in addition takes care of the k parameter:
'τ ∗'	• 'τ ∗aτ ∗'	=	'τ ∗aτ ∗'  • 'τ ∗'	=  'τ ∗aτ ∗'	if k + l ≤ K
'τ ∗'	• 'τ ∗'	=  'τ ∗'	if k + l ≤ K
For all other combinations • is undefined.
Note that in the first line —1 ≤ k + l holds since 0 ≤ k.  A weight function
W is associated with Act W analogously to before: W (∗) = 0, W ('τ ∗' ) = 0, and
W ('τ ∗aτ ∗'k) = 1 for all a and k.
Δ represents a CRS P whose set of variables is V (i.e., the same as in Δ), and

whose set of rewrite rules Γ is defined by: for all X ∈ V , a ∈ Act,

(X, 'τ ∗'k
, α) ∈ Γ	iff
τ
X =⇒k α

(X, 'τ ∗aτ ∗' , α) ∈ Γ	iff
(X, ∗,X) ∈ Γ.
a
X =⇒k α

Since Δ is totally normed, P can easily be made normed (c.f. Section 3). The transition relation →P indeed captures the small weak transition relation of Δ:
'τ ∗' k	'τ ∗ aτ ∗' 
k
α → β iff α =τ⇒k β; and, α	→	β iff α =⇒k β, a ∈ Act. We obtain:
Fact 6.7 ≈P coincides with weak bisimilarity on processes of Δ.
Remark 6.8 Note that Act W is of size exponential wrt. the size of Δ, but since we do not consider the synchronization algebra as part of the input this does not affect our complexity result. All we need to show is that the presentation mapping is PSPACE-effective.
To ensure that Assumption 1 is satisfied extend Δ by the rule (X, ∗,X) for each variable X. We are now able to apply Lemma 6.6 to show:
Lemma 6.9 The presentation mapping of weak bisimilarity is PSPACE-effective.
Proof. Given Δ, we can enumerate the set of all non-idle transitions of P starting from a small process in the following way.
For every a ∈ Act ∪ {τ } and every pair of processes α, β such that α is small and
a|β|≤ |α| + K, check whether α   β using Lemma 6.6. If this is the case compute

k = |β|— |α|; output α
'τ ∗' k
→ β if a = τ , and α
'τ ∗ aτ ∗' 
→	β otherwise. The enumerated

set is clearly sufficient and can be computed in PSPACE. (Recall that K is at most exponential in the size of Δ.)	 

Conclusions
We have shown that the idea behind the classical algorithm of Hirshfeld et al. is applicable far beyond bisimilarity on normed BPP; indeed to any process semantics that is commutative and normed in the sense made precise by our notion of normed CRS. With distributed bisimilarity we have seen that normedness can come in many guises. Work in progress suggests that our approach is not restricted to parallel processes but may also be applied to the sequential case, e.g., to normed BPA.
We have phrased the algorithm in a way that allows us to combine it with the theorem of Luttik and van Oostrom, which captures when a partial commutative monoid has unique decomposition. Thus, we were able to put together two impor- tant results in process algebra, and demonstrate the applicability of both of them.
Furthermore, we have captured four a priori very different process semantics in a uniform framework and obtained previously unknown complexity results. In the case of distributed bisimilarity on BPPτ and bisimilarity on normed BPPτ this has made concrete a connection that has already been indicated by previous

work [10,9,3]. On the other hand, we have brought to light unexpected structural similarities between observational equivalences and synchronization.
One motivation of this work was to see how far the classical methods can be extended to more realistic settings with synchronization and observational equiva- lences. We could extend them but there are limitations of course: we cannot capture forced synchronization and neither can we capture both synchronization and obser- vational equivalences at the same time. The limits are set by the requirements on our synchronization alphabet. Further research is needed to investigate how, by suitable abstractions, the results could still be of use in control flow analysis.

References
Basten, T., Branching bisimilarity is an equivalence indeed!, Information Processing Letters 58 (1996),
pp. 141–147.
Burkart, O., D. Caucal, F. Moller and B. Steffen, Verification of infinite structures, in: Handbook of Process Algebra, Elevier, 2001 pp. 545–623.
Christensen, S., “Decidability and Decomposition in process algebras,” Ph.D. thesis, Dept. of Computer Science, University of Edinburgh, UK (1993).
Esparza, J., Petri nets, commutative context-free grammars, and basic parallel processes, Fundamenta Informaticae 31 (1997), pp. 13–26.
Hirshfeld, Y., Bisimulation trees and the decidability of weak bisimulations, Electr. Notes Theor. Comput. Sci. 5 (1996).
Hirshfeld, Y., M. Jerrum and F. Moller, A polynomial time algorithm for deciding bisimulation equivalence of normed Basic Parallel Processes, Mathematical Structures in Computer Science 6 (1996),
pp. 251–259.
Huynh, D. T., Commutative grammars: The complexity of uniform word problems, Information and Control 57 (1983), pp. 21–39.
Janˇcar, P., Bisimilarity of Basic Parallel Processes is PSPACE-complete, in: Proc. LICS’03, 2003, pp. 218–227.
Janˇcar, P. and M. Kot, Bisimilarity on normed Basic Parallel Processes can be decided in time O(n3), in: Proc. AVIS’04, ENTCS (2004).
Janˇcar, P. and Z. Sawa, On distributed bisimilarity over Basic Parallel Processes, in: Proc. AVIS’05, ENTCS (2005).
Lasota, S., A polynomial-time algorithm for deciding true concurrency equivalences of Basic Parallel Processes, in: MFCS’03, LNCS 2747, 2003, pp. 521–530.
Luttik, B. and V. van Oostrom, Decomposition orders—another generalisation of the fundamental theorem of arithmetic, Theor. Comp. Sci. 335 (2005), pp. 147–186.
Mayr, R., “Decidability and Complexity of Model Checking Problems for Infinite-State Systems,” Ph.D. thesis, Technische Universit¨at Mu¨nchen (1998).
Srba, J., Complexity of weak bisimilarity and regularity for BPA and BPP, Mathematical Structures in Computer Science 13 (2003), pp. 567–587.
Srba, J., Strong bisimilarity of simple process algebras: Complexity lower bounds, Acta Informatica 39
(2003), pp. 469–499.
Stirling, C., Decidability of weak bisimilarity for a subset of basic parallel processes, in: FOSSACS’01, LNCS 2030, 2001, pp. 379–393.
van Glabbeek, R. and W. Weijland, Branching time and abstraction in bisimulation semantics, Journal of the ACM 43 (1996), pp. 555–600.
Winskel, G., Synchronization trees, Theor. Comput. Sci. 34 (1984), pp. 33–82.
