Available online at www.sciencedirect.com



Electronic Notes in Theoretical Computer Science 278 (2011) 229–243
www.elsevier.com/locate/entcs

An Epistemic Predicate CTL∗
for Finite Control π-Processes
Dimitar P. Guelev1
Institute of Mathematics and Informatics Bulgarian Academy of Sciences
Sofia, Bulgaria
Mads Dam2
School of Computer Science and Communication Royal Institute of Technology
Stockholm, Sweden

Abstract
We examine model checking of finite control π-calculus processes against specifications in epistemic predicate CTL∗. In contrast to branching time settings such as CTL or the modal μ-calculus, the general problem, even for LTL, is undecidable, essentially because a process can use the environment as unbounded storage. To circumvent this problem attention is restricted to closed processes for which internal communication along a given set of known channels is observable. This allows to model processes operating in a suitably memory-bounded environment. We propose an epistemic predicate full CTL∗ with perfect recall which is interpreted on the computation trees defined by such finite control π-calculus processes. We demonstrate the decidability of model-checking by a reduction to the decidability of validity in quantified full propositional CTL∗.
Keywords: epistemic temporal logic, pi-calculus, model checking


Introduction
The π-calculus [12,16] has attracted a lot of interest as a computational model for distributed systems. Along with most other process algebras the calculus is Turing- complete in general. Therefore most interesting decision problems about the π- calculus are undecidable. Algorithmic support mainly applies to its ﬁnite-control subset, where the use of parallel composition is syntactically restricted.
Epistemic extensions of temporal logic have proved highly valuable to express properties of agents’ evolving knowledge in distributed systems [6]. The π-calculus

1 Email: gelevdp@math.bas.bg
2 Email: mfd@kth.se

1571-0661 © 2011 Published by Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2011.10.018

extends the established computational models of epistemic TLs by the possibility to dynamically create new communication channels. It is of interest to examine how this feature can be accomodated within the epistemic logic framework.
In this paper we introduce a system of predicate epistemic CTL∗ on the compu- tation trees of finite control π-calculus processes. Our epistemic operator conforms with the established view that a fact is known if it is true about all the computations which the knower finds identical to the actual one. Epistemic TLs refer to agent identity and ”knowers”. The π-calculus does not have these notions, but epistemic modalities can be interpreted on π-processes in other ways. Cohen and Dam [4] interpret the epistemic modality in terms of static equivalence [1], but their work addresses only static knowledge. Chadha et al [3] suggest a single knower epistemic TL for π-processes based on a form of trace equivalence. However, it is unclear how this extends to multiple agents, and why 2 and  are the only temporal operators considered. In the experiment reported here we take a different approach: We iden- tify knowers with their observational power, which is determined by a set of initially ”known”, or tapped, channels. This set grows by adding the channel names which become communicated along the channels already tapped. We write Kx1,...,xn ϕ for a knower who initially taps x1,..., xn knows that ϕ.
Directly extending the known decidability results for the pure branching time case [5] to just linear time temporal logic LTL, let alone an epistemic extension of CTL∗ is, however, not possible. Even with the restriction to finite control, exchange with an external environment renders model-checking of LTL properties unsolvable, because of the possibility to restrict the environment to behave as storage for a given Turing machine’s tape, and to state that the machine never terminates. A proof is sketched at the end of the paper. The undecidability carries over to (epistemic extensions of) CTL∗. To side-step this complication, we constrain the environment by shifting attention to closed systems, and assume instead that knowers observe only internal communication along the set of tapped names, communication along which is observable. The upshot is that processes can be predicated only when placed in a fixed finite closing environment.
We prove the decidability of model-checking for our system. We encode the execution tree of the given π-process as a finite Kripke frame and reduce the model- checking of any given predicate epistemic CTL∗ formula ϕ on this tree to the satis- fiability of a translation of ϕ into quantified propositional CTL∗ (QCTL∗) on trees, which is known to be decidable from [8,9].

Background on π-Calculus
Finite control π-terms syntax can be given by the BNF

::= 0 | α.P | (νy)P | P + P | if x = y then P else P | p(y,..., y)
Q ::= 0 | P | Q|Q | (νx)Q

Here P, Q are process terms that use (channel) names x, y for communication. A communication action α is either the input of a name y along a channel named x, written as x(y), or the output of y along x, written xy, or the neutral, unobserv- able action τ . Names can be locally scoped by the operator (νy) which prevents communication along y (but allows y to be passed as a parameter, resulting in so- called scope extrusion of y, as detailed below). Other operators are action prefixing, choice (+), conditionals, and parallel composition. A process is a term of the form Q together with a finite set of definitions of the form p(x1,..., xn) = P , for the recursive invocations in Q and in the definitions’ own righthand sides. Below we elide the distinction between single process terms P and parallel compositions Q, and use P to range over both. The set of all names in a π-term P is denoted by n(P ). The sets of free and bound names are written f n(P ) and bn(P ), respectively, the binders being (νx) and the input prefix x(y), which binds x, resp. y. Binders in- duce a relation of structural congruence ≡ on terms, including α-conversion, briefly
detailed below.
We consider only executions
P 0 −τ→ 1 P 1 −τ→ 2 ··· −τ→	Pk −τ→	···	(1)
which consist entirely of silent steps, in order to prevent environment interactions, as explained in the introduction. Transitions are annotated by the sets Ck of internal communication acts which are possibly observed by knowers. Each Pk has the form
(νx1) ... (νxm)P	(2)
where P has no occurrences of ν. This form can be achieved using structural congruence. Annotations Ck consist of communication acts written in the form
c(x). Annotated transitions are derived by the following axioms and rules, a variant of the so-called early semantics of the π-calculus, cf. [14]:


τ.P −τ→
x(z)
P	x(y).P −→$
xy
[z/y]P	xy.P −→$ P

P −α→C Pj	y /∈ n(α)	y /∈ n(C) (νy)P −α→C (νy)Pj
P1 −α→C Pj
P −α→C Pj	y ∈ n(C) (νy)P −α→C Pj
P2 −α→C Pj
P −α→C Pj
P + Q −α→C Pj
x /= y

if x = x then P1 else P2 −α→C Pj	if x = y then P1 else P2 −α→C Pj

−α→ Qj
bn(α) ∩ fn(Q )= ∅
Q	xy	Qj
x(y)
Q	Q

  1	C	1	1	
  1 −→$	1	2 −→$	2

Q1|Q2 −α→C Qj |Q2
Q1|Q2 −τ→
Qj |Qj

1	{x(y)}	1	2
P −α→C Q	P ≡ Pj	Q ≡ Qj

(Congruence)
Pj −α→C Qj

Symmetric rules for + and parallel composition | are derivable using structural congruence. Annotations can be either ∅, or singletons. Together with the identities A|(νx)B ≡ (νx)(A|B), x /∈ fv (A), and p(x1,..., xn) ≡ P , given p(x1,..., xn)= P , the congruence rule allows to avoid the use of bound output action x(y), and a

dedicated rule about recursive invocations. It is possible to show that P −τ→
{x(y)}

Q according to the above semantics iff P
−τ→ (νx)(νy)Q according to the early

semantics of [14], where one or both of (νx) or (νy) may be absent.

Epistemic Predicate Full CTL∗ on Finite Control π- Processes
Using α-conversion it is easy to write executions such as (1) in such a manner that names are never reused in the following sense.
Definition 2.1 The extent (lifetime) of name x in an execution E written as in

def
(1) is the set LE(x) = {k < ω : x ∈ n(P
k) ∪ n(C
k)}. E is standard if, for every x,

LE(x) is either ∅, or a finite or infinite interval.
A model for EPCTL∗ is the Kripke frame T (P 0) whose paths correspond to the standard executions starting from some given π-term P 0. Fix a countably infinite set D including all names in T (P 0).
Definition 2.2 T (P 0) = ⟨W, R⟩ where W consists of all the pairs of the form
⟨P, C⟩ where P is a process term of the form (2) that occurs in some execution starting from P 0, and C ∈ {∅} ∪ {c(cj) : c, cj ∈ D}. ⟨P j, Cj⟩R⟨Pjj, Cjj⟩ iff either

P −→C∗∗ P
jj, or Pj
= P jj, Cjj
= ∅ and Pj
is either deadlocked or terminated.

The condition ⟨P, C⟩R⟨P, ∅⟩ for terminated and deadlocked P rules out finite maximal paths in T .
Given P 0, there exists a finite set P of ν-free process terms such that the

following condition holds: Let {y1,..., yN } =
P∈P
n(P ) and let A be the set

{∅} ∪ {{yi(yj)} : i, j = 1,...,N } of annotations written using y1,..., yN . Then

all the annotated silent transitions Pk −τ→
P 0 can be written in the form
Ck+1
Pk+1 in executions (1) starting with

σ(νu1) ... (νur)Qj −τ→σB σ(νv1) ... (νvs)Qjj	(3)
where	Qj, Qjj	∈	P,	u1,..., ur, v1,..., vs	∈	{y1,..., yN },	B	∈	A,
def
σ = [[n1/y1,..., nN /yN ] is the substitution of y1,..., yN , by the pairwise distinct
def
names n1,..., nN , and σB = {nj1 (nj2 ): yj1 (yj2 ) ∈ B, j1, j2 = 1,...,N }. We write σ
using [. ] and not [.] to indicate that it affects the bound occurrences of y1,..., yN too.
Since n1,..., nN are required to be distinct, our use of [. ] is semantically correct. In particular, (3) is a derivable transition iff (νu1) ... (νur)Qj −τ→B (νv1) ... (νvs)Qjj is.
We use P as a vocabulary of predicate symbols for T = T (P 0). Each P ∈ P is used as a |fn(P )|-ary predicate symbol. (Note that here P ranges over the ν-free parts of terms in the form (2). The only bound names of P can be the ys in the scope
def
of an x(y).) Given {z1,..., z|fn(P )|} = fn(P ) ⊆ {y1,..., yN }, we fix the ordering
z1,..., z|fn(P )|, and, for any n1,..., n|fn(P )| ∈ D, we define Pf (n1,..., n|fn(P )|) to

hold ⟨Q, A⟩ ∈ W iff Q = [n1/z1,..., n|fn(P )|/z|fn(P )|]P . Similarly, we introduce a binary predicate symbol C for latest communication act, and a temporal proposition T for silent transitions.
This vocabulary may be inconvenient for immediate use, but with existential quantification and disjunction one can easily define predicates like, e.g., Z(n1, n2) for there exist a name y such that the current process term is of the form ... | n1(x).p(n2, x, y) | .. ..
For an annotated execution E written as (1), the set CE(a, k) of the channels
that are tapped by knower a at step k is defined as follows. CE(a, 0) is presumed to be predefined and the same for all E. Given CE(a, k), we put


def
CE(a, k + 1) = CE(a, k) ∪ {c
: c(cj) ∈ C
k+1
,c ∈ CE(a, k)}.	(4)

In words, once a observes the communication of channel name cj, communication over cj becomes observable to a too. Given CE(a, k), k < ω, and two more executions
Fi = Q0 −τ→ 1 ··· −τ→	Qk −τ→	··· , i = 1, 2, we define F1 ∼a,k,E F2 as the
k+1
Ai	Ai	i	Ai
equivalence relation
(∀j ≤ k)(∀c ∈ CE(a, j))(∀cj ∈ D)(c(cj) ∈ Aj ↔ c(cj) ∈ Aj ).
1	2
In words, F1 ∼a,k,E F2 iff F1 and F2 have the same communication over channels that are observed by a in E at all steps j ≤ k. Since F1 ∼a,k,F1 F2 entails CF2 (a, j)= 
CF1 (a, j) for j ≤ k, and therefore F1 ∼a,k,F1 F2 and F1 ∼a,k,F2 F2 are equivalent, and
def

∼a,k
= λF1F2.F1 ∼a,k,F1 F2 is an equivalence relation. F1 and F2 are indiscernible

to a until step k iff F1 ∼a,k F2. We define our epistemic modality by means of ∼a,k.
The syntax of EPCTL∗ is

ϕ ::= ⊥ | P (x,..., x) | ϕ ⇒ ϕ | ∃xϕ | gϕ | ⃝ϕ | (ϕSϕ) | (ϕUϕ) | ∃ϕ | Kx,...,xϕ

where the occurrences of x represent individual variables. The counterparts of standard executions in T are standard R-paths.
Definition 2.3 An infinite sequence
ρ = ⟨P 0, C0⟩,..., ⟨Pk, Ck⟩,... ∈ Wω	(5)
is a standard R-path if P 0 is the process term used to define T  = T (P 0),
C0 = ∅, ⟨Pk, Ck⟩R⟨Pk+1, Ck+1⟩ for all k < ω and the corresponding execution
(1) is standard. Given R-paths ρ1 and ρ2 and channels c1,..., cm ∈ D, we write ρ1 ∼c1,...,cm,k ρ2 if E1 ∼a,k E2 for the corresponding executions E1 and E2, and a such that {c1,..., cm} = CE1 (a, 0) = CE2 (a, 0).
Definition 2.4 Given a standard R-path (5), a valuation v of the individual vari-

ables into D, k < ω and a formula ϕ, f , v, ρ,k |= ϕ is defined by the clauses
f , v, ρ,k |= ⊥
f , v, ρ,k |= P (x1,..., x|fn(P )|) iff Pk is [v(x1)/z1,..., v(x|fn(P )|)/z|fn(P )|]P
f , v, ρ,k |= C(x1, x2)	iff Ck = {v(x1)(v(x2))} f , v, ρ,k |= T	iff Ck = ∅
f , v, ρ,k |= ϕ ⇒ ψ	iff either f , v, ρ,k |= ϕ, or f , v, ρ,k |= ψ
f , v, ρ,k |= Exϕ	iff f , v[x '→ d], ρ,k |= ϕ for some d ∈ D
f , v, ρ,k |= gϕ	iff k > 0 and f , v, ρ,k — 1 |= ϕ
f , v, ρ,k |= ⃝ϕ	iff f , v, ρ,k +1 |= ϕ
f , v, ρ,k |= (ϕSψ)	iff there exists an n ≤ k s.t. f , v, ρ,k — n |= ψ
and f , v, ρ,k — j |= ϕ for j = 0,...,n — 1
f , v, ρ,k |= (ϕUψ)	iff there exists an n < ω s.t. f , v, ρ,k + n |= ψ
and f , v, ρ,k + j |= ϕ for j = 0,...,n — 1

f , v, ρ,k |= Eϕ	iff there exists a standard R-path ρj
s.t. ρj[0..k]= ρ[0..k] and f , v, ρj,k |= ϕ
f , v, ρ,k |= Kx ,...,x ϕ iff f , v, ρj,k |= ϕ for all standard
R-paths ρj s.t. ρ ~v(x ),...,v(x ),k ρj
Here ρ[0..k] stands for the finite prefix of ρ of length k + 1.	As expected,
FV (Kx1,...,xm ϕ)= FV (ϕ) ∪ {x1,..., xm}.
We use T, ч, Λ, V and e as abbreviations in the usual way; I, —  ϕ, ϕ, ϕ, 2ϕ, (ϕWψ) and (ϕVψ) abbreviate the formulas чgT, (TSϕ), ч— чϕ, (TUϕ), ч чϕ, (ϕUψ) V 2ϕ and (ϕSψ) V ϕ, respectively.
Example 2.5 Let P 0 = p(c)|q(c) where
p(x)= xx.p(x)+ (νy)xy.p(y), q(x)= x(y).if x = y then 0 else q(y).

A knower who can initially tap c is in a position to detect the termination of the right operand of | in the process as soon as a tapped channel’s name becomes transmitted along that same channel:
f (P 0),P 0, v, 0 |= 6x6w(C(x, w) ⇒ 62(Ezp(z)|0 ⇒ Kx(Ezp(z)|0)),
where the atomic formula p(z)|0 is underlined for better readability. To achieve this, the knower must follow the communication along the new channels y introduced

at each step. (Each of these channels is used once to announce the name of its successor, and then ”forgotten” by the process.)
From EPCTL∗ on finite control π-processes to QCTL∗
on trees
Consider standard annotated executions (1) with process terms of the form (2) and the representation (3) of transitions in such executions again. The representation
(3) applies if we allow some of n1,..., nN to be the auxiliary symbol ∗ /∈ D too, provided that nj = ∗ only if yj /∈ n(Qj)∪n(Qjj). To facilitate the presentation, in the sequel we use (3) with n1,..., nN ranging over D ∪ {∗} and put σ = [..., ∗/yj,.. .] instead of yj /∈ domσ.

We fix P 0, P, D, {y1,..., yN } =
Q∈P
n(Q) and A for the rest of the section.

Given these, an annotated execution E of the form (1) can be written as
σ0Q0 —τ→	1 ··· —τ→	k σkQk —τ→	k+1 ···	(6) where Qk ∈ P, Bk+1 ∈ A and σk are substitutions as above which satisfy σk+1Qk =
σkQk, and the additional condition ranσk \ {∗} = n(σkQk) ∪ n(σkBk) = n(Pk) ∪
n(Ck) for all k. Then obviously LE(n) = {k < ω : n ∈ ranσk}. In the sequel we additionally require that if σk1 (yi1 ) = σk2 (yi2 ) /= ∗ in the form (6) of E, then i1 = i2, for all k1, k2 ∈ LE(σk1 (yi1 )), that is, a name n should occupy the same slot y throughout its lifetime in E.
Up to a permutation of D, (6) is determined by the sequences Qk, k < ω, and
Bk, 1 ≤ k < ω, and, for each j = 1,...,N , the steps k at which
σk—1(yj) /= σk(yj).	(7)
To realise that, observe that in standard executions (7) is equivalent to k = min LE(σk(yj)) and to k — 1 = max LE(σk—1(yj)), provided that σk(yj) /= ∗ and σk—1(yj) /= ∗, respectively. Consequently, up to permutations of names, the standard executions starting from a given P 0 can be described by means
def
of the finite Kripke frame F  = ⟨W, R, w0⟩ with state space W = P × A ×

P({y ,...,y  }
def ⟨P 0, ∅, n(P 0)⟩ and transition relation R such

1	N ), initial state w0 =
that ⟨P j, Bj,Y j⟩R⟨Pjj, Bjj,Y jj⟩ iff Y jj = (n(P jj) ∪ n(Bjj))Δ(n(Pj) ∪ n(Bj)) and

either P
—→B∗∗ P jj
is a derivable transition, or Pj
def
= P jj
, Bjj
def
= ∅ and Pj

is either deadlocked or terminated. Here n(∅) = ∅, n({yj1 (yj2 )}) = {yj1 , yj2 } and
def
AΔB = A \ B ∪ B \ A, as expected. The component Y of ⟨P, B, Y ⟩ ∈ W is meant
to denote the names from among y1,..., yN , which disappear or (re)appear upon
incoming transitions, respectively.
We use F to model-check the tree of all standard executions starting from P 0 for EPCTL∗ properties. Instead of immediately interpreting EPCTL∗ formulas on F , we use a propositional LTL formula E which describes the set of paths of F . To this

end introduce a finite vocabulary L = {q1,..., qK} and a valuation V : W → P(L). No connection between the values of the variables from L and the structure of the states of F is assumed. We only require V to satisfy V (wj) /= V (wjj) whenever
wj /= wjj, which can be achieved iff K ≥ log2 |W |. Given a state w ∈ W , let

w^def 
q∈V (w) qi Λ
q∈L\V (w) чq. We put

S   w0 Λ	2(w ⇒ ⃝ 
w∈W	w∗∈R(w)


w^j).	(8)

Now the validity of an arbitrary QCTL∗ formula ϕ in M is equivalent to |=QCTL∗ 6S ⇒ ϕ. By chj, busyj , commj,k, j, k = 1,...,N , and tau, we denote boolean combinations of q1,..., qK which, up to equivalence, are determined by the following conditions, where M = ⟨W, R, w0,V ⟩ and w = ⟨Q, B, Y ⟩:

The intended meaning of chj is to indicate that the occupation of yj was changed upon the incoming transition, i.e., either k = 0, or σk—1(yj) /= σk(yj) in the rep- resentation (6) of executions; busyj means that yj currently holds a name and not
∗; tau means that the incoming transition was τ , and commj1,j2 means that the incoming transition was σk(yj1 )(σk(yj2 )).
Given P ∈ P and a sequence of indices j1,..., j|fn(P )| ∈ {1,...,N }, Pj1,...,j|fn (P )| denotes some boolean combination of q1,..., qK such that M, ⟨Q, B, Y ⟩ |= Pj1,...,j|fn (P )| iff Q is [yj1 /z1,..., yj|fn (P )| /z|fn(P )|]P where z1,..., z|fn(P )| is the fixed ordering of fn(P ) previously associated with P .
Next we describe a translation t(.) of EPCTL∗ into QCTL∗ on tree Kripke models. Tree models allow the values of bound propositional variables to vary unrestrictedly along paths, whereas repeated occurrences of states along paths in non-tree models constrain the values of quantified variables at the respective posi-
tions to be the same too. By abuse of notation, we write M = ⟨W, R, w0,V ⟩ for the result of the unravelling of the finite Kripke model M described above into a tree one too. QCTL∗ extends propositional CTL∗ by formulas of the form Eqϕ. M, ρ, k |= Eqϕ holds iff there exists a V j : W → P(L) such that V j(p) = V (p) for p /= q and ⟨W, R, w0,V j⟩, ρ,k |= ϕ.
The QCTL∗ translation t(ϕ) of an EPCTL∗ sentence ϕ satisfies |=QCTL∗ 6S ⇒ t(ϕ) where S is as in (8) iff ϕ is true about all the executions starting with a fixed P 0. As mentioned above, S allows the appearance of names in E to be determined up to a permutation on D. Since we assume ϕ to be a sentence, this is sufficient.
To handle quantification over names in EPCTL∗ we augment the description of the possible executions E which can be derived from S with a description of the identities between the names which appear in E and the values of the (bound) variables of ϕ. Without loss of generality we assume that no individual variable in
ϕ is bound by more than one occurrence of E. Let x1,..., xM be all the individual

variables of ϕ. To describe the occurrences of v(xl) in an execution E for the relevant v, we take the form (6) of E and introduce the propositional variables pj,l, j = 1,...,N . The intended meaning of pj,l at step k is v(xl) = σk(yj). As it

becomes clear below, this enables translating P (xl1 ,..., xlm ) into
j1,...,jm
Pj1,...,jm Λ

pj1,l1 Λ ... pjm,lm .
The translation of a formula of the form Exlψ includes a formula of the form Ep1,l ... EpN,l(ul Λ t(ψ)), in which ul constrains pj,l to mark some possible extent LE(v(xl)) = LE(σk(yj)) of v(xl) in the executions E which correspond to the paths in f and in the corresponding QCTL∗ model M . The case of pj,l being satisfied nowhere along the given path corresponds to the name v(xl) appearing nowhere in
E. Let
Fj,l  pj,l Λ busyj Λ   чpj∗,l Λ  чpj,l∗ .
j∗/=j	l∗/=l
Fj,l means that xl evaluates to σk(yj) at time k, and j is the only one with this property, and no other individual variable evaluates to σk(yj) at time k. The latter condition is included to simplify the handling of atomic formulas built using =. To express that xl evaluates to none of the names σk(yj), we use the formula Gl 

N

j=1
чpj,l. Using Fj,l and Gl, we write
Hj,l  (GlWchj Λ Fj,l Λ ⃝(Fj,l Λ чchjWchj Λ 2Gl)).

The satisfaction of Hj,l at step 0 means that either LE(v(xl)) = ∅, or there exists a k such that σk(yj) /= ∗ for some k and v(xl) = σk∗ (yj) for kj ∈ LE(v(xl)) =

N
LE(σk(yj)). Now we can put ul   —  (I Λ6 
Hj,l). The clauses for the translation,

j=1
except that for epistemic formulas, are as follows:
t(⊥)	  ⊥
t(xl1 = xl2 )	  ⊥ if l1 /= l2
t(xl = xl)	  T

t(P (xl1 ,..., xlm )) 


j1,	,jm

  Pj1,...,jm Λ
m

i=1

pji,li

t(C(xl1 , xl2 ))		(commj1,j2 Λ pj1,l1 Λ pj2,l2 )
j1,j2
t(T )	  tau
t(Xϕ)	  Xt(ϕ) for X ∈ {⃝, g, E}
t((ϕXψ))	  (t(ϕ)Xt(ψ)) for X ∈ {U, S, ⇒}

t(Exlϕ) 
z∈FV (Exlϕ)
t([z/xl]ϕ) V Ep1,l ... EpN,l(ul Λ t(ϕ))

To facilitate translating formulas of the form xl1 = xl2 , the clause for t(Exlϕ)

provides that the values of the free variables of Exlϕ are excluded from the range of xl by treating the cases of v(xl) being one of these values separately.
The translation of formulas of the form Kx1,...,xm ϕ requires us to write a descrip- tion of CE(a, k), k < ω, for an arbitrary execution E and a knower a such that CE(a, 0) = {v(x1),..., v(xm)} in our propositional temporal language. We do this by introducing the propositional variables oj, j = 1,...,N . Just like the variables
pj,l, oj have only bound occurrences in the translations of EPCFL∗ sentences. As- suming that the considered execution E is written in the form (6), the intended meaning of oj in the translation of Ka ... at step k is σk(yj) ∈ CE(a, k). Next we construct an LFL formula to express that oj, j = 1,...,N , behave according
to the defining properties of CE(a, k), k < ω, with respect to the adopted way of propositional description of executions E.
Consider an individual variable xl such that v(xl) ∈ CE(a, 0) and let k < ω.
Then the satisfaction of
Ij,l  Fj,l ⇒ (ojSchj Λ oj) Λ oj Λ ⃝(ojWchj)
at step k means that if k ∈ LE(v(xl)) and v(xl)= σk(yj), then a taps communication over channel σk(yj) throughout its extent LE(σk(yj)) = LE(v(xl)). We put

N
IL	2Ij,l for L ⊆ {1,...,M }.
j=1 l∈L
The satisfaction of IL at step 0 means that a taps communication over the channels denoted by xl, l ∈ L, throughout their extents.
To express the definition (4) of CE(a, k + 1) in terms of CE(a, k), we use the
formula
C  2  (⃝oh e (ч⃝ chh Λ oh) V  oj Λ commj,h).	(9)
The satisfaction of C at step 0, means that communicating a channel name σk(yh) over an observed channel σk(yj) at an arbitrary step k makes communication over σk(yh) observable from step k + 1 on and for the rest of the extent of σk(yh), that is, until eventually a step kj > k is reached such that σk∗ (yh) /= σk(yh), which is
indicated by chh. Let OL be the formula — (I Λ IL Λ C). OL states that oj holds at
step k iff σk(yj) ∈ CE(a, k) for all k < ω and j ∈ L.
Expressing Kx ,...,x furthermore requires reference to executions Ej which ex- hibit the same sequence of observable actions as the actual execution E. To this end

we introduce an extra copy Lj = {qj ,..., qj
} of the vocabulary L of our Kripke

1	K
model M , whose paths we described using the formula S.  We write xj for the
boolean combination [qj/qi : i = 1,..., K]x, x = tau, busyj, commj ,j , chj. Similarly
i	1 2
we assume additional sets pj , oj , j = 1,...,N , l = 1,...,M , of the variables pj,l
and oj, to describe the extents of the values of individual variables and channel observability in Ej, and write Ij , Cj, etc. for the variants of IL, C, etc., written in
the primed vocabulary.

Let the substitutions involved in writing Ej in the form (6) be σj , k < ω. According to our encoding, observing the same actions in E and Ej means that if
oj and commj,h, hold at some step k, then oj∗ and commj ∗ ∗ hold for some jj, hj
such that σk(yj) = σj (yj∗ ) and σk(yh) = σj (yh∗ ). To express the latter identities,
k	k
we introduce the atomic propositions ej,j∗ , j, jj = 1,...,N . The intended meaning
of ej,j∗ at step k is that σk(yj) = σj (yj∗ ) /= ∗, that is, k ∈ LE(n) ∩ LE∗ (n) where
n = σk(yj)= σj (yj∗ ).
The valuation of ej,j∗ , j, jj = 1,...,N , along a path describes correctly a possible overlap of the extents LE(n) and LE∗ (n) of some name n in a pair of executions E and Ej, iff it has the properties which are expressed by the following LFL formulas
ej,j∗ ⇒ busyj Λ busyj ∗ Λ  чeh,j∗ Λ   чej,h∗
h/=j	h∗/=j∗
chj Λ	 чeh,j∗ Λ чchj ∗ Wchj ∗  V
j	j
⎜	j	 h	⎟
	

⎛	  h
j	⎞

ej,j∗ ⇒ ⎜ej,j∗ Λ чchj Λ чchj ∗ V
chj Λg 
 h
чeh,j∗ Λ чchj∗ Vchj∗  V
	⎟

j
chj ∗ Λg 
чej,h
h
Λ чchjVchj	⎠

At step k, the first formula states that σk(yj)= σj (yj∗ ) /= ∗ can hold for at most one pair j, jj. The second and the third formulas state that σk(yj)= σj (yj∗ )= n at step
k implies σk∗ (yj)= σj ∗ (yj∗ ) for all kj ∈ LE(n) ∩ LE∗ (n), σk∗ (yj) /= σj ∗ (yh) for all h
k
and kj ∈ LE(n)\LE∗ (n), and σj ∗ (yj∗ ) /= σk∗ (yh) for all h and kj ∈ LE∗ (n)\LE(n). Let
k
—

Nj,j∗ be the conjunction of these formulas. We denote the formula  (IΛ 62
by N .

j,j∗
Nj,j∗ )

Using the variables ej,j∗ we can express that E and Ej have the same observable
communication by the formulas
oj ⇒  (ej,h ⇒ oj ),	oj ∗ ⇒  (ek,j∗ ⇒ oh)	(10)
h	j
h	h
j
ej,j∗ ⇒ (pj,l e pj∗,l)	(11)
oj Λ commj,h ⇒  (ej,j∗ Λ eh,h∗ Λ commj ∗ ∗ )	(12)

oj ∗ Λ commj ∗
j∗,h∗
∗ ⇒  (ej,j∗ Λ eh,h∗ Λ commj,h).	(13)



The formulas (10) state that CE(a, k) = CE∗ (a, k) for the reference step k. The formula (11) states that the account of the valuation of individual variables given by
pj,l and pj ∗  is consistent with the identities between in E and Ej as described using
ej,j∗ . The formulas (12) and (13) state that the actions on observable channels in the two executions are identical. We denote the conjunction of (10)-(13) by £j,j∗,h,h∗ . We

denote 
j,j∗,h,h∗
£j,j∗,h,h∗ by £. The satisfaction of £ at step k means that E ~a,k Ej

holds, provided that executions E and Ej correspond to the satisfying path, that

is, provided that busyj , chj, tau, commj ,j , busyj ∗ , chj ∗ , tau and commj ∗
∗ correctly

1 2	j	j
j1,j2

describe E and Ej, respectively, pj,l, pj ∗
and ej,j∗ correctly describe the identities

between the names involved in E and Ej, and the values of the individual variables xl, and, finally, oj and oj , correctly describe the observability of channels. This condition is expressed by the conjunction


N Λ S Λ	 
un Λ O{1,...,m} Λ ⎛S j Λ	 
uj Λ Oj	⎞


xn∈FV (ϕ)
n
xn∈FV (ϕ)
{1,...,m}⎠

The subscripts written with i and j, and also l as the main symbol above range over {1,...,N } and {1,...,M }, respectively.
Now we are ready to write a translation clause for Kx1,...,xm ϕ. (The initially
observable channels are chosen to be values of the first m individual variables
x1,..., xm for the sake of simplicity.) Kx1,...,xm ϕ translates into
6qj ... 6qj

1
j
1,1
1
... 6p

j
1,M

... 6p

j
N,1

... 6pj
⎛ N Λ £ Λ S j Λ
⎝


xn∈F V (ϕ)
uj Λ ⎞
⎠



6e1,1 ... 6e1,N ... 6eN,1 ... 6eN,N
The quantifier prefix of t(Kx ,...,x ϕ) provides fresh sets of variables qj ,..., qj to
1	m	1	K
enable the description of Ej, pj ∗ ∗ to describe the identities between the values
of the individual variables and the names involved in Ej, oj and oj ∗ to mark the observability of channels in E and Ej, respectively, and a set of variables ej,j∗ to express whatever identities hold between the names occurring in E and Ej during their various extents. The conditions on these variables which actually force their truth values to give a consistent account of Ej, the way individual variables refer to names in Ej, the observability of channels in both executions, the identities between names occurring in E and Ej, and the fact that E ~a Ej for a knower a who can
initially observe the channels v(x1),..., v(xm) are expressed in the conjunction on

the left of ⇒ in the matrix of the formula by S j,	 
uj , O{1,...,m}, Oj	,

N , and £, respectively. On the whole, the translation states that if a cannot tell apart some Ej from the actual execution E, then the encoding of Ej satisfies t(ϕ) as well, which is the defining condition for the satisfaction of Kx1,...,xm ϕ. The free propositional variables of t(Kx1,...,xm ϕ) are q1,..., qK, and pj,l, j = 1,...,N , xl ∈ FV (ϕ), which describe the actual execution E and the identities between the names occurring in E and the values of the (free) variables of ϕ, provided that their truth values satisfy S and the relevant ul, respectively.
The correctness of our translation can be formuated as follows:
Theorem 3.1 Given a π-process P 0 and an EPCFL∗ sentence ϕ in the respective predicate vocabulary, f (P 0), v, ⟨P 0, ∅⟩ |= ϕ iff |=QCTL∗ S ⇒ t(ϕ).

The proof can be obtained by following the detailed explanation of the meaning of the formulas used to define the various clauses for t(.) above.

Unsolvability of model-checking with external com- munication
Model-checking is not recursively enumerable for finite control π-processes with ex- ternal communication even for the LFL subset of EPCFL∗, without the epistemic modality. To prove this, we define a class of behaviours in which the environment e acts as unbounded storage by an LFL formula. Let I and O be binary predicate symbols which denote input from and output to e, respectively, just like the predi- cate symbol C about internal communication. We intend to state that whenever e receives two names x and y in a row along a dedicated channel cons, it ”registers” the pair ⟨x, y⟩ under some name z and, from that step onwards, whenever given z
along the dedicated channels car (cdr ), e sends back x (y) along reply. A formula
constraining e to behave this way can be written as follows. The formula
silence   6x Λc∈{cons,car,cdr,reply} чI(c, x) Λ чO(c, x) .
states that the latest action was not communication with e. Let
 sϕ  (silenceUϕ) and — sϕ  (silenceSϕ);
R    silence V —  sExI(reply, x).
R states that the latest communication with e, if any, was a reply. Then
—  s(O(cons, y) Λ g—  s(O(cons, x) Λ gR)) ⇒
Ez  s(I(reply, z) Λ ⃝6t2(O(car , z) Λ ⃝  s(I(reply, t) ⇒ t = x)))
states that e is bound to return x whenever asked to retrieve the first member of the pair ⟨x, y⟩ previously registered as z. Similar formulas can be written to express retrieving y, and registering pairs. We leave it to the reader to realise that, with e assumed to behave this way, a finite control process PM can be constructed to
simulate the working of any given Turing machine M , with the parts of M ’s tape on the left and on the right of M ’s current position represented as two lists built of pairs, which can be stored by e in the above fashion. This entails that the non- halting problem for Turing machines M reduces to the model-checking problem for processes of the form PM against the conjunction of the formulas which describe the working of e as storage and a formula which states the non-termination of M . The same plan can be used to show that the problem of model-checking finite- control processes which communicate with a ﬁnite memory environment for predi- cate LFL properties, that is, the problem of whether there exists a finite-control E such that the runs of P | E for a given P have a given property written in the LFL
subset of our EPCFL∗, is recursively enumerable but still undecidable, as long as E

is unrestricted. This can be realised by choosing P to range over the processes PM which simulate Turing machines M as above, and the property in question to be M terminates and E behaves as storage in the above way until M terminates. By restricting M to be deterministic, PM |E can be chosen to have just one run. For
terminating M , the unique run of PM | E will satisfy the above property for any
E which is big enough to serve as storage throughout the terminating run of the
simulated M .

Concluding remarks
We have examined model checking of finite control π-calculus processes against for- mulas in an epistemic extension of predicate CFL∗ with perfect recall. Since model checking is undecidable for open π-calculus processes even for LFL, we instead address closed process terms and tapping internal communication across a distin- guished set of channels. This constrains the storage capacity of processes sufficiently to render model checking decidable.
Model checking the π-calculus has been considered by several authors, but so far only in branching time settings. Dam [5] obtained a first decidability result for a predicate extension of modal μ-calculus. This result has been improved upon in [7,17]. The latter work has been adapted to the stochastic π-calculus [13]. Recent applications of π-calculus and its dialects to security protocol verification mostly appeal to Dolev-Yao type knowledge extraction. An exception is [3], where the use of epistemic reasoning in the context of π-calculus is suggested. An epistemically flavoured extension of modal logic applied to CCS, a precursor of the π-calculus, is proposed in [11].
We leave three main questions open for future investigation. First, we have not explored the practical implications of the closed system modelling approach suggested in this paper, and whether it can offer new approaches to specification and verification, for instance along the lines suggested by [3]. Second, the model checking algorithm presented here is non-elementary and needs to be improved in order to become practically useful. It remains to be seen if existing approaches to model checking of epistemic logics [10,15] can be extended. Third, it is of interest to extend the results presented here to capture also strategic ability, for instance along the lines of AFL [2].

Acknowledgement
Dimitar Guelev worked on the topic of this paper during a research visit to KTH in September, 2009, which was partially supported by the ACCESS Linnaeus Excel- lence Centre, funded by the Swedish National Research Council. The work was also partly supported by Bulgarian National Science Fund Grant ID-09-112. D. Guelev is grateful to Mark Ryan for some comments on a draft version of the paper.

References
Abadi, M. and C. Fournet, Mobile values, new names, and secure communication, in: POPL (2001),
pp. 104–115.
Alur, R., T. A. Henzinger and O. Kupferman, Alternating-time temporal logic, J. ACM 49 (2002),
pp. 672–713.
Chadha, R., S. Delaune and S. Kremer, Epistemic Logic for the Applied Pi Calculus, in:
FMOODS/FORTE, LNCS 5522 (2009), pp. 182–197.
Cohen, M. and M. Dam, A complete axiomatization of knowledge and cryptography, in: LICS (2007),
pp. 77–88.
Dam, M., Model Checking Mobile Processes, Information and Computation 129 (1996), pp. 35–51.
Fagin, R., J. Halpern, Y. Moses and M. Vardi, “Reasoning about Knowledge,” MIT Press, 1995.
Franzen, T., A Theorem-Proving Approach to Deciding properties of Finite-Control Agents (1996).
French, T., Decidability of quantifed propositional branching time logics, in: AI 2001, LNCS 2256
(2001), pp. 165–176.
French, T., “Bisimulation Quantifiers for Modal Logics,” Ph.d. thesis, The University of Western Australia (2006).
Gammie, P. and R. van der Meyden, MCK: Model Checking the Logic of Knowledge, in: CAV, 2004,
pp. 479–483.
Mardare, R., Observing Distributed Computation. A Dynamic-Epistemic Approach, in: CALCO, LNCS
4624 (2007), pp. 379–393.
Milner, R., J. Parrow and D. Walker, A Calculus of Mobile Processes, I, Information and Computation
100 (1992), pp. 1–40.
Norman, G., C. Palamidessi, D. Parker and P. Wu, Model checking the probabilistic pi-calculus, in:
QEST (2007), pp. 169–178.
Parrow, J., An introduction to the π-calculus, in: J. Bergstra, A. Ponse and S. Smolka, editors, Handbook of Process Algebra, Elsevier Science Inc., New York, NY, USA, 2001 pp. 479–544.
Raimondi, F. and A. Lomuscio, Automatic Verification of Multi-agent Systems by Model Checking via Ordered Binary Decision Diagrams, Journal of Applied Logic 5 (2007), pp. 235 – 251.
Sangiorgi, D. and D. Walker, “The π-calculus: a Theory of Mobile Processes,” CUP, 2001.
Yang, P., C. R. Ramakrishnan and S. A. Smolka, A logical encoding of the pi-calculus: model checking mobile processes using tabled resolution, STTT 6 (2004), pp. 38–66.
