Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 319 (2015) 67–82
www.elsevier.com/locate/entcs
A Presheaf Model of Parametric Type Theory
Jean-Philippe Bernardy Thierry Coquand Guilhem Moulin
Chalmers University of Technology and University of Gothenburg
{bernardy,coquand,mouling}@chalmers.se


Abstract
We extend Martin-Lo¨f’s Logical Framework with special constructions and typing rules providing inter- nalized parametricity. Compared to previous similar proposals, this version comes with a denotational semantics which is a refinement of the standard presheaf semantics of dependent type theory. Further, this presheaf semantics is a refinement of the one used to interpret nominal sets with restrictions. The present calculus is a candidate for the core of a proof assistant with internalized parametricity.
Keywords: Parametricity, Presheaf semantics, Type theory

Introduction
Reynolds [17] proved a general abstraction theorem (sometimes called parametric- ity theorem) about polymorphic functions. His argument is about a set theoretic semantic. As he stated it, the underlying idea is that the meanings of an expression in “related” environments will be “related” values. For instance, he proves that if tX is a term of type X → X and if we consider two sets A0, A1 and a relation R ⊆ A0 × A1, then we have R([tX ]X=A0 (a0), [tX ]X=A1 (a1)) whenever R(a0, a1), where [tX ]X=A denotes the meaning of the expression tX where X is interpreted by the set A. As he noted, one can replace binary relations by n-ary relations in this statement, and in particular unary relations (predicates). In the latter case, the statement is the following: if A is a set and P is a predicate on A, then we have
P ([tX ]X=A(a)) whenever P (a) holds. Wadler [18] illustrates by many examples how this result is useful for reasoning about functional programs.
The argument and result of Reynolds are model-theoretic in nature. In the Logical Framework, it is possible to state such an abstraction result in a purely syntactical way. One states for example that if a function f has type (A : U ) → A → A — the type of the polymorphic identity — then f Ax is Leibniz-equal to x, i.e., the following proposition holds:
(A : U ) → (P : A → U ) → (x : A) → P x → P (f Ax)

http://dx.doi.org/10.1016/j.entcs.2015.12.006
1571-0661/© 2015 The Authors. Published by Elsevier B.V.
This is an open access article under the CC BY-NC-ND license (http://creativecommons.org/licenses/by-nc-nd/4.0/).

Indeed Bernardy et al. [9] prove such a result as a (syntactical) meta-theorem about type systems. However this result is not provable internally, i.e., the following proposition is not provable:
(f : (A : U ) → A → A) → (A : U ) → (P : A → U ) → (x : A) → P x → P (f Ax) ( )
Therefore users relying on the parametricity conditions have postulated the para- metricity axiom [3, 11, 16]. However, because postulates do not have computational interpretations, such parametricity conditions can only be used in computationally- irrelevant positions.
Instead, one would like to be able to rely on parametricity conditions within the theory itself. Several attempts have been made [6, 7] — or are currently developed
[2] — for designing an extension of dependent type theory in which such an internal form of parametricity holds. We propose another such system here. Our technical contributions are as follows:
We present an extension of Martin-L¨of’s Logical Framework (Section 2) which internalizes parametricity (as we show in Section Section 3) and can be seen as a simplification and generalization of the systems of Bernardy and Moulin [6, 7]. In particular, we have a special construction (a,i p) which pairs a term a with its parametricity proof p, as well as special projections to extract the proof. As we will show in Section 3.3, these new constructions enable us to prove the proposition (Equation ) internally. (This is not possible with usual pairs and projections since the first projection does not commute with applica- tion.) The name i in the above construction is what we call a “color”; we want internalized parametricity not only for LF but also for the extended calculus, and as explained in [7], colors enable nested parametricity by keeping track of the different uses (this is analogous to building hypercubes and accessing their vertices as in [6]). However, unlike previous type theories with internalized parametricity [6, 7], the system presented here does not compute parametric- ity types: for instance, parametricity conditions are isomorphic to functions, rather than functions themselves. (As shown in Section 3, this does not appear to be an issue in practice.)
We provide a denotational semantics, in the form of a presheaf model, for this type theory (Section 4). This model is a refinement of the presheaf semantics used to interpret nominal sets with restrictions [10, 15].
We conjecture that conversion and type-checking are decidable for this system.
Syntax
In this section we define the syntax and typing rules of our parametric type theory, as well as the equality judgment.
We assume a special symbol ‘0’, and a countably infinite set I of other symbols, called colors. The metasyntactic variables i, j,... range over colors, while ϕ range over I ∪ {0}. We further assume a fixed function fresh(·) such that fresh(I) ∈ I\I

for any finite color set I. The main innovation of the type theory presented here is that terms may depend on (a finite number of) colors. For any term a, we note supp(a) the set of free colors in a.
We do not attempt to explain what lead us to consider a colored type theory; for that we refer to [7] instead.
Definition 2.1 [Syntax of terms and contexts]
A, B, P, T, a, p, t, u := x	variable
| t u	application
| λx : A.t	abstraction
| (x : A) → B	product
| |A|	code
| El(A)	decode
| U	universe
| (a,i p)	colored pair
| (x : A) ×i P	colored type pair
| ⟨t,i u⟩	colored function pair
| A ei a	parametricity type
| a·i	parametricity proof
Γ, Δ := () | Γ,x : A | Γ,i : I
We give a few intuitions to interpret the novel syntax, before formally giving the typing rules of the system.
Reynolds associates each type with a predicate. Here, each type is associated not with a single predicate, but many: one for every color. These multiple predicates are essential to interpret parametricity when it is nested. Indeed, using a single predicate yields inconsistencies. Furthermore these predicates are definable in the logic: the type A ei a expresses that a satisfies the para- metricity predicate associated with the type A on color i. For each term a and color i, the term a(i 0) is the erasure of i in a. It is defined by induction on a (Definition 2.2) and can be understood as a realizer [5] of a.
The term a·i yields a proof of A ei a(i 0).
The forms (a,i p), (x : A)×iP and ⟨t,i u⟩ allow to locally associate parametricity proofs with a given realizer.
Definition 2.2 [Color renaming and erasure] We consider a color i ∈ I and ϕ ∈
I ∪ {0}, and define the term a(i ϕ) by induction on a.
x(i ϕ)= x
(t u)(i ϕ)= (t(i ϕ)) (u(i ϕ))
(λ(x : A).t)(i ϕ)= λ(x : A(i ϕ)).t(i ϕ)
((x : A) → B)(i ϕ)= (x : A(i ϕ)) → (B(i ϕ))

|A|(i ϕ)= |A(i ϕ)|
El(A)(i ϕ)= El(A(i ϕ))
U (i ϕ)= U
(a,i p)(i 0) = a
(a,i p)(ij)= (a,j p)
(a,j p)(i ϕ)= (a(i ϕ),j p(i ϕ))	if i /= j
((x : A) ×i P )(i 0) = A
((x : A) ×i P )(i j)= (x : A) ×j P
((x : A) ×j P )(i ϕ)= (x : A(i ϕ)) ×j P (i ϕ)	if i /= j
⟨t,i u⟩(i 0) = t
⟨t,i u⟩(ij)= ⟨t,j u⟩
⟨t,j u⟩(i ϕ)= ⟨t(i ϕ),j u(i ϕ)⟩			if i /= j (A ei a)(i ϕ)= A(ij)(i ϕ) ej a(i ϕ)		where j = fresh(supp(A)) (A ej a)(i ϕ)= (A(i ϕ)) ej (a(i ϕ))			if i /= j (a · i)(iϕ)= a(ij)(i ϕ) · j	where j = fresh(supp(a))
(a · j)(i ϕ)= a(i ϕ) · j	if i /= j

Definition 2.3 [Typing judgements — a` la Tarski]

Γ ▶ A ei a	Γ,i : I ▶ (x : A) ×i P



Conv
Γ ▶ t : A	A = B


Γ ▶ t : B
Var
Γ ▶	x : A ∈ Γ


Γ ▶ x : A
Code
Γ ▶ A


Γ ▶ |A| : U
Swap
Γ,i : I,j : I, Δ ▶ a : A
Γ,j : I,i : I, Δ ▶ a : A



Lam
Γ,x : A ▶ t : B
App
Γ ▶ t : (x : A) → B[x]	Γ ▶ u : A


	
Γ ▶ λx : A.t : (x : A) → B	Γ ▶ t u : B[u]


In-Abs
In-Fun
Γ ▶ t : ((x : A) → P [x])(i 0)

Γ ▶ a : A(i 0)	Γ ▶ p : A ei a


Γ,i : I ▶ (a,i p): A
Γ ▶ u : (x : A(i 0)) → (xj : A ei x) → P [(x,i xj)] ei tx


Γ,i : I ▶ ⟨t,i u⟩ : (x : A) → P [x]

Color-Elim
Γ,i : I ▶ a : A
Γ ▶ a·i : A ei a(i 0)
The parametricity constructions (· and e) are color binders (they bring colors into scope), while the pairing constructs remove colors from scope. The equality relation used in the Conv rule is detailed below in Definition 2.5. The Swap rules allow us to use Out and Color-Elim with any free color, provided that no variable was introduced after that color (see e.g., Theorem 3.6).
Additionally, for the above system to be well-founded, we need to distinguish small and big types, and allow only small types to be encoded in U . Small types are closed under product, ×i and ei. The distinction between big and small types being standard, and to keep the presentation concise, we leave it implicit in the syntax 1 .
Theorem 2.4 (Color erasure and substitution preserve typing) If Γ,i  :
I ▶ a : A then the terms a(i ϕ) and A(i ϕ) are deﬁned and
Γ ▶ a(i 0) : A(i 0), and
Γ,j : I ▶ a(ij): A(ij).
Proof. By induction on the typing judgment.	2

Definition 2.5 [Conversion] The convertibility of types used in the
Conv
rule

and written simply (=) is defined as the smallest reflexive-symmetric-transitive congruence containing the following rules.

Pair-Param
(a,i p)·i = p
Pair-App
⟨t,i u⟩ a = (t a(i 0),i u a(i 0) (a·i))
Pair-Pred
((x : A) ×i P [x]) ei a = P [a]

Surj-Param
t = (t(i 0),i t·i)
Surj-Typ
T = (x : T (i 0)) ×i (T (ij) ej x)

El(|A|)= A	|El(A)| = A
β
(λx : A.t[x])u = t[u]
η
t x = u





Corollary 2.6 (Surj-Fun) t = ⟨t(i 0),i λxxj.(t(x,i xj))·i⟩
t = λx : A.u

Remark 2.7 In order to be well-typed, any context for the conclusion of the Pair- App, Surj-Param, Surj-Fun and Surj-Typ rules needs to end with a color bind- ing.

1 Our rules are semantically justified in Section 4; the use of codes enables a presentation `a la Tarski, while avoiding us to split each constructor in two flavors, one for small types and one for large ones.

Remark 2.8 Although it looks as if ⟨t,i u⟩ can be definable as λx.(tx,i ux x·i), the latter rebinds i, and does not allow us to prove parametricity for the Church-encoded naturals (Example 3.4) for instance.
Our conversion relation is intensional for functions, but extensional when it comes to dependencies on colors. Because there is at any point only a finite number of colors to consider, we conjecture that our conversion relation is decidable.
Parametricity
In this section we prove that our system properly internalizes unary parametricity; it could naturally be extended to the n-ary case by using further special symbols 1,...,n — 1. We also illustrate the system by giving a few simple proofs relying on parametricity (including iterated parametricity). For the sake of readability, we leave out the distinction between types and their codes, which plays no role here.
Unlike previous type theories with internalized parametricity [6, 7], the system presented here lacks equalities which allow to compute parametricity types. Ex- pressed in our syntax, those equalities would become the conversion rules:
U ei A = A → U , and
((x : A) → B[x]) ei f = (x : A) → (xj : A ei x) → B[(x,i xj)] ei (fx).
The absence of the above equalities allows for a simpler system, but how can we ensure that all parametricity theorems hold? The answer is that the above relation- ships hold as isomorphisms. We say that A is isomorphic to B iff.


there exist f : A → B,
there exist g : B → A,
for any x, f (g x)= x, and
for any x, g (f x)= x.

This notion of isomorphism is quite strong, because the equality used in its definition is the conversion relation (Definition 2.5).
Theorem 3.1 U ei A is isomorphic to A → U.
Proof.


f : (Q : U ei A) → A → U f Q x = (A,i Q) ei x
g : (P : A → U ) → U ei A
gP = ((x : A) ×i (P x))·i

(A,i ((y : A) ×i (Py))·i) ei x = ((y : A) ×i (Py)) ei x = Px by Pair-Param
then Pair-Pred, and we conclude by η-contraction.
((x : A) ×i (A,i Q) ei x) · i = (A,i Q) · i = Q by Surj-Typ (indeed (x : A) ×i
(A,i Q) ei x is typed in a context ending with i : I) and Pair-Pred.	2
Theorem 3.2 ((x : A) → B[x]) ei f is isomorphic to
(x : A) → (xj : A ei x) → B[(x,i xj)] ei (f x)

Proof.
f : (q : ((x : A) → B[x]) ei f ) → (x : A) → (xj : A ei x) → B[(x,i xj)] ei (fx)
f q xxj = ((f,i q)(x,i xj))·i
g : ((x : A) → (xj : A ei x) → B[(x,i xj)] ei (f x)) → ((x : A) → B[x]) ei f gp = ⟨f,i p⟩·i
((f,i ⟨f,i p⟩·i) (x,i x)j)·i = (⟨f,i p⟩ (x,i xj))·i = (f x,i px xj)·i = px xj by Surj- Param then Pair-App (indeed ⟨f,i p⟩ and ⟨f,i p⟩ (x,i xj) are typed in a context ending with i : I) and we conclude by Pair-Param.
⟨f,i λxxj.((f,i q) (x,i xj))·i⟩·i = (f,i q)·i = q by Surj-Fun (indeed (f,i q) is typed in a context ending with i : I) and we conclude by Pair-Param.	2
In practice however, when carrying out parametricity proofs, many of the steps of the above isomorphisms cancel each other and one obtains a simpler proof. This behaviour is illustrated by the following examples: parametricity for the polymor- phic identity and Church-encoded natural numbers.
Example 3.3 Any function f : (X : U ) → X → X is the polymorphic identity,
i.e., its output is Leibniz-equal to its second input. Assume a context
Γ= (f : (X : U ) → X → X, A : U, P : A → U, a : A, p : P a).
Then Γ,i : I ▶ (x : A) ×i (P x) and by Pair-Pred Γ,i : I ▶ (a,i p): (x : A) ×i (P x),
thus Γ,i : I ▶ f ((x : A) ×i (P x)) (a,i p): (x : A) ×i (P x) and finally
Γ ▶ (f ((x : A) ×i (P x)) (a,i p))·i : ((x : A) ×i (P x)) ei (f ((x : A) ×i (P x)) (a,i p))(i 0)
= P (f ((x : A) ×i (P x)) (a,i p))(i 0) = P (f Aa)
Example 3.4 Let N = (X : U ) → X → (X → X) → X. Proving (unary) parametricity for N means that, assuming a context Γ
f : N, A : U, P : A → U, z : A, zj : P z, s : A → A, sj : (x : A) → P x → P (sx),
we can prove P (f Az s).
Indeed Γ,i : I ▶ (x : A) ×i (P x), and by Pair-Pred Γ,i : I ▶ (z,i zj) : (x :
A) ×i (P x) and Γ,i : I ▶ ⟨s,i sj⟩ : (x : A) ×i (P x) → (x : A) ×i (P x), thus
Γ,i : I ▶ f ((x : A) ×i (P x)) (z,i zj) ⟨s,i sj⟩ : (x : A) ×i (P x), and finally
Γ ▶ (f ((x : A) ×i (P x)) (z,i zj) ⟨s,i sj⟩)·i : ((x : A) ×i (P x)) ei (f Az s)= P (f Az s)
As seen in Example 3.4, one needs to use ⟨t,i u⟩ to pair a function with the parametricity proof of its type if one wants to apply that pair to some argument and reduce the application. This is because as noted above, our system does not support direct computation of free theorems: in particular (A → B) ei a does not reduce.
At this point one may wonder, since a new syntactic construction was introduced for function types, whether yet another construction is required for higher order functions. This objection was preemptively refuted by Theorem 3.2: it turns out

that ⟨t,i u⟩ can be combined with (a,i p) to pair higher order functions with the parametricity proof of their type. The following example illustrates this technique:
Example 3.5 Let F = (X : U ) → ((X → X) → X) → X. Proving (unary) parametricity for F means that, assuming a context Γ = f : F, A : U, P : A → U, g : (A → A) → A, gj : (h : A → A) → ((x : A) → P x → P (h x)) → P (g h), we can prove P (f Ag).
Let T = (x : A) ×i (P x). We have Γ,i : I ▶ T and
Γ,h : A → A, hj : (T → T ) ei h, x : A, xj : P x, i : I ▶ (h,i hj): T → T , hence
Γ,h : A → A, hj : (T → T ) ei h, x : A, xj : P x ▶ ((h,i hj) (x,i xj))·i : T ei hx = P (h x)
Γ,h : A → A, hj : (T → T ) ei h ▶ gj h (λ(x : A). λ(xj : P x). ((h,i hj) (x,i xj))·i): P (g h)
Let gjj = λh. λhj. gj h λ(x : A). λ(xj : P x). ((h,i hj) (x,i xj))·i. Since we have Γ ▶ gjj : (h : A → A) → (T → T ) ei h → P (g h) we can pair it with g and Γ,i : I ▶ ⟨g,i gjj⟩ : (T → T ) → T . We can finally conclude as before, that Γ ▶ (f T ⟨g,i gjj⟩)·i : P (f Ag).

Iterating Parametricity
In our system, one can use parametricity generically as follows:
p : (X : U ) → (x : X) → X ei x pX x = x·i
We have already seen that A ei corresponds to a parametricity predicate for the type A. As we hinted at in the introduction, the color index i allows us to distinguish each application of parametricity. (As a side remark, since the Color-elim rule introduces a color, limiting the depth of nested applications of parametricity can trivially be enforced in our system by limiting the number of free colors in the context.) We can iterate the operator A e· to construct relations between parametricity witnesses. That is, given a context with
x : A, y : A ej x, z : A ei x,
the type A ei (x,j y) ej z is well formed (e is left associative), and can be under- stood as a binary relation between the parametricity proofs y and z. The following results about this relation illustrate the expressivity of our system.
Theorem 3.6 If the type A does not depend on either i or j, the relation λyz.A ei
(x,j y) ej z is symmetric.
Proof. We first construct the proof term:
σ1 : (x : A) → (y : A ei x) → (z : A ei x) → A ei (x,j y) ej z → A ej (x,i z) ei y σ1 xy z w = ((x,j y),i (z,j w))·j·i
And, by α-equivalence on colors, A ej (x,i z) ei y = A ei (x,j z) ej y.	2
Theorem 3.7 If the type A does not depend on either i or j, then the types A ei
(x,j y) ej z and A ej (x,i z) ei y are isomorphic.

Proof. We show that σ1 yxz (σ1 xy z w) = w. Let t = ((x,j y),i (z,j w)), wj = t·j·i, tj = ((x,i z),j (y,i wj)). Then tj(i 0) = (x,j y)= t(i 0), tj(j 0) = (x,i z)= t(j 0), and (t·j)(i 0) = y. We now continue to reason by deduction:
wj = t·j·i	by def.
(y,i wj)= t·j	because (t·j)(i 0) = y
tj·j = t·j	by def.
tj = t	because tj(j 0) = t(j 0)
tj = ((x,j y),i (z,j w))	by def.
tj·i = (z,j w)
tj·i·j = w	2
Remark 3.8 At this point one may wonder if the system could have been set up to have t·i·j = t·j·i, and the equality between A ei (x,j y) ej z and A ej (x,i z) ei y rather than an isomorphism. The answer is that the equation
A ei (x,j y) ej z = A ej (x,i z) ei y
is inconsistent: in particular for A = U one gets
U ei (X,j P ) ej Q = U ej (X,i Q) ei P
for arbitrary P and Q of type U ei X. The above equality in turn implies (x : X) → P x → Qx → U = (x : X) → Qx → P x → U
for arbitrary predicates P and Q over X, which is obviously inconsistent.
Theorem 3.9 If the type A and the term a do not depend on either i or j, and
aj : A ei a (not depending on i or j either), then A ei (a,j a·i) ej aj.
Proof. We can construct the following closed term:
q : (A : U ) → (x : A) → (xj : A ei x) → A ei (x,j x·i) ej xj
q : (A : U ) → (x : A) → (xj : A ei x) → A ei x ej xj	by Surj-Param
qA xxj = xj·j
The result is then obtained by substituting a for x and aj for xj.	2
To conclude the section we note that by iterating parametricity n times, one creates n-ary relations between proofs of relations of arity n — 1. Furthermore, the above results carry over to the n-ary case. That is, for each k < n, one can construct a function σk, which exchanges the arguments k and k + 1 of a relation. Furthermore, these functions satisfy the laws of the generators of the symmetric group.
Presheaf model
In this section we show how to interpret our type theory by a presheaf model.

Definition 4.1 If I and J are two ﬁnite subsets of I, we call a color map any function f : I → J ∪ {0} such that i1 = i2 for any i1, i2 ∈ I with f (i1)= f (i2) ∈ J.
Definition 4.2 [Category pI] Let objects be finite color sets and morphisms be color maps (a.k.a. partial injections; the Hom-set I → J denotes functions I → J ∪ {0}). If f : I → J and g : J → K, we define the composition as the Kleisli one: fg : I → K as fg(i)=0 if f (i)=0 and fg(i)= g(f (i)) if f (i) ∈ J. We write 1I : I → I for the identity map. It is easy to check that pI is a category (see [14, ex. 9.7 p. 176] for another description of this category).
If f : I → J, i /∈ I and j /∈ J, let (f, i = j): I, i → J, j (where I, i is a shorthand for I ∪ {i}) denote the map defined by (f, i = j)(i)= j and (f, i = j)(k)= f (k) for every k ∈ I.
If f : I, i → J (resp. f : I, i → J, j) is such that f (i) = 0 (resp. f (i) = j), let
f — i : I → J denote the map defined by (f — i)(k)= f (k) for every k ∈ I.
For any object I and i /∈ I, let ιi : I → I, i denote the inclusion map, defined by
ιi(k)= k for every k ∈ I.
Definition 4.3 [Projection] We say that a morphism α : I → Iα is a projection if
Iα ⊆ I, α(i)=0 for each i ∈ I\Iα, and α(i)= i for each i ∈ Iα.
Definition 4.4 [Total maps] We say that a morphism h : I → J is total, and note
h : I > J, if it is injective, i.e., if h(i) /= 0 for each i ∈ I.
Remark 4.5 [Morphism decomposition] Any morphism f : I → J has a unique decomposition into a projection map α : I → Iα and a total map h : Iα > J.
Definition 4.6 [I-set] Let an I-element be any tuple indexed by the subsets of I: (uJ )J⊆I . An I-set is a set of I-elements. For instance, the elements of an {i, j}-set are of the form u = (u∅, ui, uj, ui,j). Alternatively, such an element can be seen as a tuple (uα) indexed by the projections α : I → Iα.
If a, b are I-elements and j /∈ I, we define the (I, j)-element (a,j b) as (a,j b)J := aJ if j /∈ J and (a,j b)J,j := bJ . Any (I, i)-element can be written u = (uJ )J⊆I,i = (uJ )J⊆I ∪ (uJ,i)J⊆I ; We can therefore define the I-elements u(i 0) := (uJ )J⊆I and u · i := (uJ,i)J⊆I . (Hence by definition u = (u(i 0),i u · i).)
Recall that a presheaf F on pIop is given by a family of sets F (I) together with restriction maps F (I) → F (J), u '→ uf for f : I → J satisfying u1 = u and (uf )g = u(fg). (Note that the category of presheaves on pIop is equivalent to the category Res of nominal restriction sets [14, rem. 9.9 p. 161].) We use a refined presheaf on pIop by requiring two further conditions:
for any object I, F (I) is an I-set; and
for any projection map α : I → Iα, the restriction map F (I) → F (Iα), u '→ uα is the projection operation, i.e., uαJ = uJ for any J ⊆ I (alternatively, seeing I-elements as tuples indexed by projection maps, (uα)β = uαβ).
Unless written otherwise, any presheaf in the remainder of this section is assumed to satisfy these conditions. The refinement is necessary for the interpretation of some

of our syntactic constructions. Indeed, without it, it is not clear how to validate the equality Pair-Pred: ((x : A) ×i P [x]) ei a = P [a].
A context Γ ▶ is interpreted by a (non-refined) presheaf on pIop, i.e., by a family of sets Γ(I) for each object I, together with restriction maps Γ(I) → Γ(J), ρ '→ ρf for f : I → J satisfying the conditions ρ1= ρ and (ρf )g = ρ(fg).
A type Γ ▶ A is interpreted by an I-set Aρ for each object I and ρ ∈ Γ(I), together with restriction maps Aρ → A(ρf ), u '→ uf if f : I → J satisfying u1= u and (uf )g = u(fg) for any g : J → K. Furthermore the map Aρ → A(ρα), u '→ uα is the projection operation.
A term Γ ▶ a : A is interpreted by an I-element aρ ∈ Aρ for each object I and
ρ ∈ Γ(I), such that aρf = a(ρf ) for any f : I → J.
If Γ ▶ and Γ ▶ A we define the interpretation of Δ = (Γ,x : A) by taking
⟨ρ, x = u⟩ ∈ Δ(I) to mean ρ ∈ Γ(I) and u ∈ Aρ. The restriction map is defined by
⟨ρ, x = u⟩f = ⟨ρf, x = uf⟩.
If Γ ▶ we define the interpretation of Δ = (Γ,i : I) by taking [ρ, i = ϕ] ∈ Δ(I) to mean either ϕ = 0 and ρ ∈ Γ(I), or ϕ = j ∈ I and ρ ∈ Γ(I\{j}). The restriction map is defined by [ρ, i = 0]f = [ρf, i = 0] and [ρ, i = j]f = [ρ(f — j),i = f (j)].
Remark 4.7 In other words, Γ,x : A ▶ is interpreted by the cartesian product (ρ ∈ Γ) × Aρ of the interpretations of Γ ▶ and Γ ▶ A, while Γ,i : I ▶ is interpreted by the separated product [14, sec. 3.4 p. 54] Γ ∗ I of the interpretation of Γ ▶ and I ∪ {0}:
Γ ∗ I(I)= {[ρ, i = 0] | ρ ∈ Γ(I)}∪ {[ρ, i = j] | j ∈ I, ρ ∈ Γ(I\{j})}
We also note that Γ,i : I,j : I ▶ and Γ,j : I,i : I ▶ are respectively interpreted as the sets of [ρ, i = ϕ, j = ϕj] and [ρ, j = ϕ, i = ϕj], which are trivially isomorphic.
The semantics we define satisfy the substitution law. That is, if Γ,x : A ▶ B and Γ ▶ a : A then for any ρ ∈ Γ(I) we have B[a]ρ = B⟨ρ, x = aρ⟩. It also satisfies the substitution law on colors, i.e., if Γ,i : I ▶ A then for any ρ ∈ Γ(I) and j /∈ I we have A(i0)ρ = A[ρ, i = 0] = A[ρ, i = j](j 0). (Since [ρ, i = 0] ∈ Γ ∗ I(I) and [ρ, i = j] ∈ Γ ∗ I(I, j), A(i 0)ρ and A[ρ, i = 0] are I-sets while A[ρ, i = j] is a (I, j)-set.) For establishing these properties, we proceed as Aczel [1].
We proceed to interpret each type construction.

Pi.
Assume ρ ∈ Γ(I). We define ((x : A) → B)ρ as a I-set. An I-element of ((x : A) → B)ρ is defined as a tuple λ = (λα), where each λα is a family of elements indexed by a total map f : Iα > J:

λαf ∈	Y
u∈A(ραf )
B⟨ραf, x = u⟩

such that app(λαf , u)g = app(λαfg, ug) for f : Iα > J total and for any
g : J → K (where app is the semantic application). Because any map I → J

has an unique decomposition as a projection and a total map, we can consider
λf for an arbitrary map f : I → J.
If f : I → J is an arbitrary map, we define λf to be the tuple (λfβ) where λfβ
is the family λfβg = λfβg. With this definition, we directly have λαβ = λαβ.
This is similar to the usual interpretation of dependent product in presheaf models [10, 12]; but to satisfy our first extra condition on presheaves we present each element as a tuple, which can be done naturally by repartitioning the family as follows: (λf )f:I→J = (λαg)Iα⊆I,g:Iα>J ∼= ((λαg)g:Iα>J )Iα⊆I .
Universe. The universe U is interpreted as a presheaf over pI. An element A of
U (I) is a tuple (Aα) where each Aα is a family (Aαf ) of U -small sets (where U is a fixed Grothendieck universe) indexed by f : Iα > J total together with restriction maps Aαf → Aαfg, u '→ ug for f : Iα > J total and g : J → K arbitrary, such that u1= u and (ug)h = u(gh).
As before, such data define a set Af for an arbitrary map f : I → J with restriction maps Af → Afg if g : J → K.
If f : I → J is an arbitrary map, we define Af by taking Afβg to be the set Afβg, together with restriction maps Afβg → Afβgh defined as the given maps Afβg → Afβgh. We can then check, as before, that we have Aαβ = Aαβ.
As before, this is similar to the usual interpretation of universe in presheaf models, where each element is presented as a tuple.
Out. Assume ρ ∈ Γ(I). We need to define the I-set (A ei a)ρ. Let j = fresh(I).
We get a (I, j)-set A[ρ, i = j], and the I-element aρ belongs to A(i 0)ρ =
A[ρ, i = 0]= A[ρ, i = j](j0).
We define (A ei a)ρ to be the set of I-elements v such that (aρ,j v) ∈ A[ρ, i = j]. If v is such an element and f : I → J and k = fresh(J), then vf is defined by the equation (aρf,k vf )= (aρ,j v)(f, j = k).

In-Pred.
Assume [ρ, i = ϕ] ∈ Γ ∗ I(I). We define the I-set ((x : A) ×i P )[ρ, i = ϕ]

by case analysis on ϕ ∈ I ∪ {0}. If ϕ = 0 then ρ ∈ Γ(I), and we define
((x : A) ×i P )[ρ, i = 0] as the I-set Aρ. If ϕ = j ∈ I then ρ ∈ Γ(I\{j}), and we define ((x : A) ×i P )[ρ, i = j] as the I-set of (u,j v) where u ∈ Aρ and v ∈ P⟨ρ, x = u⟩.
Decode. Assume ρ ∈ Γ(I). We have Aρ ∈ U (I) and we define El(A)ρ to be the
set Aρ1. The restriction map El(A)ρ → El(A)ρf , u '→ uf is defined using the restriction map Aρ1 → Aρf and the fact that we have Aρf = A(ρf )1.
Remark 4.8 Our calculus does not have any base types, but they could be in- terpreted by modifying their usual interpretation as a constant presheaf into an isomorphic I-set. For instance, the base type of natural numbers would be inter- preted as the I-set of (nJ )J⊆I where n∅ ∈ N and nJ = ∅ for any non-empty J ⊆ I.
We now describe how to interpret terms.
Var. We define x⟨ρ, y = u⟩ to be u if x = y, and xρ otherwise. We define x[ρ, i = ϕ] to be xρ if ϕ = 0, and x(ριj) if ϕ = j.

Lam.
We define app((λx : A.t)ρf , u) to be t⟨ρf, x = u⟩

App. We define (tu)ρ to be app(tρ1, uρ)

In-Abs.
Assume [ρ, i = ϕ] ∈ Γ ∗ I(I). We define the I-element (a,i p)[ρ, i = ϕ] by

case analysis on ϕ ∈ I∪{0}. If ϕ =0 then ρ ∈ Γ(I), and we take (a,i p)[ρ, i = 0]
to be aρ ∈ A(i 0)ρ = A[ρ, i = 0]. If ϕ = j ∈ I then ρ ∈ Γ(I\{j}), and we take (a,i p)[ρ, i = j] to be (aρ,j pρ).

In-Fun.
Assume [ρ, i = ϕ] ∈ Γ ∗ I(I). We define the J-element ⟨t,i u⟩[ρ, i = ϕ]f

by case analysis. If ϕ = 0, then ρ ∈ Γ(I) and ρf ∈ Γ(J); we define w =
⟨t,i u⟩[ρ, i = 0]f by app(w, a) = app(tρf , a). If ϕ = j ∈ I and f (j) = 0, then ρ ∈ Γ(I\{j}) and ρ(f — j) ∈ Γ(J); we define w = ⟨t,i u⟩[ρ, i = j]f by app(w, a)= app(tρf−j, a). If ϕ = j ∈ I and f (j)= k ∈ J, then ρ ∈ Γ(I\{j}) and ρ(f — j) ∈ Γ(J\{k}); we define w = ⟨t,i u⟩[ρ, i = j]f by app(w, (a,k b)) =
(app(tρf−j, a),k app(app(uρf−j, a), b)).
Color-Elim. Assume ρ ∈ Γ(I). We define (a·i)ρ as a[ρ, i = j]·j where j = fresh(J).
Theorem 4.9 (Convertible terms are semantically equal)
If Γ ▶ A1 and Γ ▶ A2 with A1 = A2, then A1ρ = A2ρ for any ρ ∈ Γ(I).
If Γ ▶ a1 : A and Γ ▶ a2 : A with a1 = a2, then a1ρ = a2ρ for any ρ ∈ Γ(I).
Proof. By simultaneous induction on the derivation. We only show the conversion rules Pair-Param, Pair-Pred and Surj-Param here; other rules involving colors can be proven in a similar fashion, while β and η can be proven in the usual way.

Pair-Param.
Let ρ ∈ Γ(I) and j = fresh(I). We have
v ∈ (((x : A) ×i P ) ei a)ρ
iff. (aρ,j v) ∈ ((x : A) ×i P )[ρ, i = j]
iff. (aρ,j v) ∈ {(u,j w) | u ∈ Aρ, w ∈ P⟨ρ, x = u⟩}
iff. v ∈ P⟨ρ, x = aρ⟩
iff. v ∈ P [a]ρ

Pair-Pred. Let ρ ∈ Γ(I) and j = fresh(I). We have ((a,i p) · i)ρ = (a,i p)[ρ, i =
j] · j = (aρ,j pρ) · j = pρ
Surj-Param. For each ρ ∈ Γ(I) we have (t(i 0),i t · i)[ρ, i = 0]= t(i 0)ρ = t[ρ, i =
0], and if j /∈ I then (t(i 0),i t · i)[ρ, i = j] = (t(i 0)ρ,j (t · i)ρ) = (t[ρ, i =
j](j 0),j t[ρ, i = j] · j)= t[ρ, i = j]. Hence (t(i 0),i t· i)ρ = tρ for any ρ ∈ Γ ∗ I(I).
2
Remark 4.10 As noted earlier, the types U  ei  (X,j P )  ej  Q and U ej (X,i Q) ei P are not convertible. Their semantic interpretations are not equal either. Indeed taking ρ ∈ Γ(I), k = fresh(I) and l = fresh(I, k), we have (leaving out the context interpretation ρ for the sake of readability) on the one hand
v ∈ (U ei (X,j P ) ej Q)ρ
iff. (Qρ,k v) ∈ (U ei (X,j P ))[ρ, j = k]
iff. ((X,j P )[ρ, j = k],l (Qρ,k v)) ∈ U (l, k)
iff. ((Xρ,k P ρ),l (Qρ,k v)) ∈ U (l, k)

while on the other hand
v ∈ (U ej (X,i Q) ei P )ρ
iff. (Pρ,k v) ∈ (U ej (X,i Q))[ρ, i = k]
iff. ((X,i Q)[ρ, i = k],l (Pρ,k v)) ∈ U (k, l)
iff. ((Xρ,k Qρ),l (Pρ,k v)) ∈ U (k, l)
hence (U ei (X,j P ) ej Q)ρ /= (U ej (X,i Q) ei P )ρ since the map U (l, k) →
U (k, l), u '→ ug where g(k)= l and g(l)= k is not the identity.
Theorem 4.11 (Validity) If Γ ▶ a : A then aρ ∈ Aρ for any ρ ∈ Γ(I).
Proof. By induction on the typing judgment. We only show the cases In-Abs and Color-Elim. In-Fun is similar to the former, and the other cases match the usual proof (using Theorem 4.9 for Conv).
In-Abs. Assume [ρ, i = ϕ] ∈ Γ∗I(I). We proceed by case analysis on ϕ ∈ I∪{0}. If
ϕ =0 then ρ ∈ Γ(I), and we have (a,i p)[ρ, i = 0]= aρ ∈ A(i 0)ρ = A[ρ, i = 0].
If ϕ = j ∈ I then ρ ∈ Γ(I\{j}), and we have (a,i p)[ρ, i = j] = (aρ,j pρ); Since by induction hypothesis pρ ∈ (A ei a)ρ, we conclude by definition that (aρ,j pρ) ∈ A[ρ, i = j].
Color-Elim. Assume ρ ∈ Γ(I). We need to show that (a · i)ρ ∈ (A ei a(i 0))ρ,
i.e., that (a(i 0)ρ,j (a · i)ρ) ∈ A[ρ, i = j] where j = fresh(I). By induction hypothesis a[ρ, i = j] ∈ A[ρ, i = j], hence we have (a(i 0)ρ,j (a · i)ρ)= (a[ρ, i = j](j 0),j a[ρ, i = j] · j)= a ∈ A[ρ, i = j].	2

Related Work
Our own line of work
This work continues a line of work aiming at a smooth integration of para- metricity with dependent types [5–9]. The present work offers two improvements over previous publications: 1. a denotational semantics, and 2. a much simplified syntax, suitable as the basis of a proof assistant.
The simplification of syntax is allowed by not requiring the preservation of func- tions by parametricity. We call preservation of functions by parametricity the prop- erty that if f were a function, then the canonical proof that f is parametric (denoted f · i here) is also a function. To our knowledge, following Reynolds [17], all para- metric models of parametricity (both syntactical and semantical ones) have this property. However, having this property in the syntax implies that certain function arguments must be swapped when performing the substitution of beta reduction, as identified by Bernardy and Moulin [6]. In the present system, the parametric interpretation of functions is instead merely isomorphic to a function, thanks to the In-Fun rule (Theorem 3.2). This isomorphism (rather than equality) means on the one hand that the swapping of arguments is handled by the usual rules of logic, instead of special-purpose ones. On the other hand, obtaining the usual parametric interpretation of types requires some purely mechanical work by the user of the logic.

Parametric Models of Type Theory vs. Parametric Type Theories
Two pieces of work propose alternative parametric models of type theory [4, 13], but do not integrate parametricity in the syntax of the calculus. This means that, while certain consequences of parametricity can be made available in the logic (e.g., via constants validated by the model), parametricity itself is not available. In this paper, we not only propose a parametric model, but also show how it can be used to interpret parametricity in the syntax of the type theory.
Various kinds of models
Another characterizing feature of proposals for parametricity is the kind of model underlying the semantics. Krishnaswami and Dreyer [13] propose a model based on Q-PER. Atkey et al. [4] propose a model based on reflexive graphs. The model that we use is based on cubes (functions from subsets of colors). In Bernardy and Moulin [6] the cubes were reified as syntax in an underlying calculus, while in the present work they refine a presheaf structure.
Presheaf models
The presheaf construction used in this paper follows a known template, used for example by Bezem et al. [10] and Pitts [15] to model univalence in type theory. Not only do both models use a presheaf, but they also use a category closely connected to the underlying category pI. This means that all these models have an additional cubical structure. We think that it is remarkable that cubical structures are useful for modeling both parametricity and univalence. Altenkirch and Kaposi [2] give a syntax for Bezem et al.’s Cubical Type Theory, effectively modelling univalence by internalization of their model. The present work further refines the model by interpreting terms as I-elements, which is essential to interpret our special-purpose pairing constructions.
Future work and conclusion
We have defined a new type theory with internalized parametricity. Thanks to our model construction, we have proved the consistency of the system. The missing piece to construct a type-checker is a decision algorithm for the conversion relation. This checker could then be used as a minimal proof assistant for a type theory with parametricity.
Acknowledgment
The fact that the category of partial bijections pI should be relevant for internal- ization of parametricity became apparent through discussions between Thorsten Altenkirch and the second author about the paper [6].
We are extremely grateful to Simon Huber for finding a flaw in an earlier version of this paper, and helping us to fix it. We also thank Peter Dybjer, Patrik Jansson, Andrea Vezzosi and the anonymous referees for valuable feedback and discussion.

References
P. Aczel. On relating type theories and set theories. In Proceedings of TYPES’98, volume 1657 of Lecture Notes in Computer Science, pages 1–18. Springer-Verlag, 1998.
T. Altenkirch and A. Kaposi. A syntax for cubical type theory. 2014. URL http://www.cs.nott.ac. uk/~txa/publ/ctt.pdf. Draft.
R. Atkey, S. Lindley, and J. Yallop. Unembedding domain-specific languages. In Proceedings of the 2nd ACM SIGPLAN symposium on Haskell, pages 37–48, New York, NY, USA, 2009. ACM. ISBN 978-1-60558-508-6. doi: http://doi.acm.org/10.1145/1596638.1596644. URL http://doi.acm.org/10. 1145/1596638.1596644.
R. Atkey, N. Ghani, and P. Johann. A relationally parametric model of dependent type theory. In The 41st Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, POPL ’14, San Diego, CA, USA, January 20-21, 2014, pages 503–516, 2014. doi: 10.1145/2535838.2535852.
URL http://doi.acm.org/10.1145/2535838.2535852.
J.-P. Bernardy and M. Lasson. Realizability and parametricity in Pure Type Systems. In M. Hofmann, editor, Foundations Of Software Science And Computational Structures, volume 6604 of Lecture Notes in Computer Science, pages 108–122. Springer, 2011.
J.-P. Bernardy and G. Moulin. A computational interpretation of parametricity. In LICS. IEEE Computer Society, 2012.
J.-P. Bernardy and G. Moulin. Type-theory in color. In Proceedings of the 18th ACM SIGPLAN international conference on Functional Programming, pages 61–72, 2013.
J.-P. Bernardy, P. Jansson, and R. Paterson. Parametricity and dependent types. In Proceedings of the 15th ACM SIGPLAN international conference on Functional programming, pages 345–356, Baltimore, Maryland, 2010. ACM. doi: 10.1145/1863543.1863592.
J.-P. Bernardy, P. Jansson, and R. Paterson. Proofs for free — parametricity for dependent types.
Journal of Functional Programming, 22(02):107–152, 2012. doi: 10.1017/S0956796812000056.
M. Bezem, T. Coquand, and S. Huber. A model of type theory in cubical sets. In 19th International Conference on Types for Proofs and Programs (TYPES 2013), volume 26, pages 107–128, 2014.
A. Chlipala. Parametric higher-order abstract syntax for mechanized semantics. In Proceedings of the 13th ACM SIGPLAN international conference on Functional Programming, pages 143–156, New York, NY, USA, 2008. ACM. ISBN 978-1-59593-919-7. doi: 10.1145/1411204.1411226.
M. Hofmann. Syntax and semantics of dependent types. In Semantics and Logics of Computation, pages 79–130. Cambridge University Press, 1997.
N. R. Krishnaswami and D. Dreyer. Internalizing relational parametricity in the extensional calculus of constructions. In Computer Science Logic 2013 (CSL 2013), CSL 2013, September 2-5, 2013, Torino, Italy, pages 432–451, 2013. doi: 10.4230/LIPIcs.CSL.2013.432. URL http://dx.doi.org/10.4230/ LIPIcs.CSL.2013.432.
A. M. Pitts. Nominal Sets: Names and Symmetry in Computer Science, volume 57 of Cambridge Tracts in Theoretical Computer Science. Cambridge University Press, 2013. ISBN 9781107017788.
A. M. Pitts. An equivalent presentation of the Bezem-Coquand-Huber category of cubical sets. CoRR, abs/1401.7807, 2014. URL http://arxiv.org/abs/1401.7807.
N. Pouillard. Nameless, painless. In Proceedings of the 16th ACM SIGPLAN international conference on Functional Programming, ICFP ’11, pages 320–332, New York, NY, USA, 2011. ACM. to appear.
J. C. Reynolds. Types, abstraction and parametric polymorphism. Information processing, 83(1): 513–523, 1983.
P. Wadler. Theorems for free! In Proceedings of the fourth international conference on Functional programming languages and computer architecture, pages 347–359, Imperial College, London, United Kingdom, 1989. ACM. ISBN 0-89791-328-0. doi: 10.1145/99370.99404. URL http://portal.acm. org/citation.cfm?id=99404.
