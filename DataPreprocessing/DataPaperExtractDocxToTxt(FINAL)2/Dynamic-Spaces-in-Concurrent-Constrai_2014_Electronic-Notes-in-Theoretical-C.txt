Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 305 (2014) 103–121
www.elsevier.com/locate/entcs

Dynamic Spaces in Concurrent Constraint Programming
Carlos Olarte1
Departamento de Electr´onica y Ciencias de la Computaci´on Pontificia Universidad Javeriana-Cali, Colombia
Escola de Ciˆencias e Tecnologia Universidade Federal do Rio Grande do Norte Natal, Brazil
Vivek Nigam2
Departamento de Inform´atica Universidade Federal da Para´ıba Jo˜ao Pessoa, Brazil
Elaine Pimentel3
Departamento de Matem´atica Universidade Federal de Minas Gerais Belo Horizonte, Brazil
Universidade Federal do Rio Grande do Norte Natal, Brazil

Abstract
Concurrent constraint programming (CCP) is a declarative model for concurrency where agents interact with each other by posting (telling) and asking constraints (formulas in logic) in a shared store of partial information. With the advent of emergent applications as security protocols, social networks and cloud computing, the CCP model has been extended in different directions to faithfully model such systems as follows: (1) It has been shown that a name-passing discipline, where agents can communicate local names, can be described through the interplay of local (∃) processes along with universally (∀) quantified asks. This strategy has been used, for instance, to model the generation and communication of fresh values (nonces) in mobile reactive systems as security protocols; and (2) the underlying constraint system in CCP has been enhanced with local stores for the specification of distributed spaces. Then, agents are allowed to share some information with others but keep some facts for themselves. Recently, we have shown that local stores can be neatly represented in CCP by considering a constraint system where constraints are built from a fragment of linear logic with subexponentials (SELLe). In this paper, we explore the use of existential (d) and universal (A) quantification over subexponentials in SELLe in order to endow CCP with the ability to communicate location (space) names. The resulting CCP language that we obtain is a model of distributed
computation where it is possible to dynamically establish new shared spaces for communication. We thus extend the sort of mobility achieved in (1) –for variables – to dynamically change the shared spaces among agents – (2) above. Finally, we argue that the new CCP language can be used in the specification of service oriented computing systems.
Keywords: Concurrent Constraint Programming, Linear Logic, Subexponentials, Mobility, Distributed Spaces.


http://dx.doi.org/10.1016/j.entcs.2014.06.008
1571-0661/© 2014 Elsevier B.V. All rights reserved.

The specification of modern concurrent systems often requires to reason using dif- ferent sorts of modalities, such as time, space, or even the epistemic state of agents. Logic and proof theory have often inspired the design of many of these formalisms. For example, Saraswat and Rinard proposed in [25] Concurrent Constraint Pro- gramming (CCP) [23,26] which is a model for concurrency that combines the tra- ditional operational view of process calculi [14] with a declarative view based on logic. Agents in CCP interact with each other by telling and asking information represented as constraints (formulas in logic) to a global store. Later, Fages et al. in
[6] proposed Linear Concurrent Constraint Programming (lcc), inspired on linear logic [8] and linear logic programming [11], allowing the use of linear constraints, that is, constraints that once used by an agent are removed from the global store. On the other hand, Saraswat et al. proposed Timed CCP (tcc) [24], which is an extension of CCP with time modalities. More recently, Knight et al. [12] proposed another CCP-based language with spatial (sccp) and epistemic (eccp) modalities (see in [20] a survey of the state of the art in CCP).
On the other hand, we have showed in [18] that spatial, temporal and epistemic modalities can be uniformly specified in a single logical framework called SELLA. The proof system SELLA is an extension of SELL (intuitionistic linear logic with
subexponentials) with a pair of quantifiers over subexponentials, namely, A (uni-
versal) and d (existential). These quantifiers allowed the encoding of an existing number of CCP languages that does not seem to be possible with other logical frameworks, such as [28,3]. In fact, the view of subexponentials as “locations” greatly enhance the power of the logical framework that is attached to them, in this case linear logic. Moreover, the ability to reason about locations seems to be the key for capturing different behaviors in CCP. In particular, the above mentioned quantifiers enable the use of an arbitrary number of subexponentials, that plays an important role in the encodings described in [18]. For instance, they are used in the modeling of the unbounded nesting of modalities, which is a common feature of systems involving spatial and epistemic information.
Another important feature of subexponentials is that they can be organized into a pre-order, which specifies the provability relation among them. With the use of quantifiers together with an adequate pre-order over subexponentials, it is possible to specify declaratively the rules in which agents can manipulate information: the boundaries are naturally implied by the pre-order of subexponentials.
The fact is that the results in [18] opened a number of possibilities for the spec- ification and verification of systems that mention modalities. For instance, while in [12] one assumes a finite number of agents, it seems possible to extend these systems in order to handle an infinite number of them via quantification on loca- tions. Moreover, linearity of constraints can be straightforwardly included to these

1 Email: carlos.olarte@gmail.com
2 Email: vivek.nigam@gmail.com
3 Email: elaine@mat.ufmg.br

systems to represent, for instance, agents that can update/change the content of the distributed spaces. Also, by changing the underlying subexponential structure, different modalities can be put in the hands of the modelers and programmers. And most importantly, now it is possible to use all the linear logic meta-theory for reasoning about such systems.
All in all, we can summarize the work done in [18] by

{l, e, s, t, ck}− CCP =⇒ SELLA


where {l, e, s, t, ck}-CCP stands for linear, epistemic, spatial, timed, and common knowledge modalities in CCP.
The present work moves in the opposite direction:

SELLA =⇒ ? − CCP


That is, we ask ourselves what kind of interesting features can be specified in CCP if we enrich the underlying theory of this model with the subexponential discipline.
There are at least two ways of proceeding in this direction. One aspect that could be explored is that of proposing richer subexponential signatures in SELLA, hence having different computational behaviors. For example, it seems that if the initial signature is the [0, 1] interval, then the correspondent calculus has a probabilistic flavor. Hence one could think of more elaborated topological spaces as signatures, like Hilbert spaces for example, achieving in the other side interesting concurrent systems.
In the present work, though, we will explore another possible aspect driven by SELLA: reconﬁgurability of the communication structure, aka mobility. In fact, instead of looking to the initial subexponential signature, we will focus our attention on the quantiﬁcation over subexponentials. That is, we will show how the new subexponentials, created by existential quantification (d), can be used as private locations that can be communicated and shared to other agents via the universal quantification (A). In the context of CCP languages, this is reminiscent of the name-passing discipline (for first-order variables) proposed by Olarte and Valencia in Universal Timed CCP (utcc) [21], where local (∃) processes are used to create nonces (fresh values) that can be accessed through universally quantified asks (∀). The rest of the paper is organized as follows. In Section 2 we recall the frame- work of SELLA first proposed in [18]. Then, we extend the linear constraint system in [6] to consider formulas in a fragment of SELLA. We shall show that processes manipulating such constraints are able to represent interesting behavior in con- current and distributed systems. We rely on the results in [18] to show that the operational semantics of the CCP language here proposed has a strong adequacy
(at the level of derivations) with proofs in SELLA. Section 4 concludes the paper.

Linear Logic and Subexponential Quantifiers
We review some basic proof theory of Girard’s intuitionistic linear logic (ILL) [8] with subexponentials [4]. ILL’s connectives are the conjunctions ⊗ and &; the dis- junction ⊕; the implication −◦; the (first-order) quantifiers ∀ and ∃; the exponentials
!, ?; 4 and the units 1, T and 0.
Due to the exponential !, we can distinguish in linear logic two kinds of formu- las in the left context: the linear ones whose main connective is not a ! and the unbounded ones whose main connective is a !. It turns out that the exponentials are not canonical with respect to the logical equivalence relation. In fact, if, for any reason, we decide to define a blue and red conjunctions (∧b and ∧r respectively) with the standard rules:


 Γ, A, B −→ C  ∧bL	Γ −→ A	Γ −→ B

∧bR

Γ,A ∧b B −→ C
Γ, A,B −→ C


Γ,A ∧r B −→ C
Γ −→ A ∧b B
∧r L	Γ −→ A	Γ −→ B
Γ −→ A ∧ B


∧rR


then it is easy to show that, for any formulas A and B, A∧b B ≡ A∧r B. This means that all the symbols for intuitionistic conjunction belong to the same equivalence class. Hence, we can choose to use as the conjunction’s canonical form any particular color, and provability is not affected by this choice.
However, the same behavior does not hold with the linear logic exponentials. In fact, suppose we have red !r and blue !b exponentials with the standard linear logic rules:


!r Γ −→ F
Γ,F −→ C
!b Γ −→ F	b
Γ,F −→ C
b

!r Γ −→ !r F
!rR


Γ, !r F −→ C
!r L
!b Γ −→ !b F ! R
Γ, !b F −→ C ! L

In this case, we cannot show that !r F ≡ !b F . This thus opens the possibility of defining classes of exponentials.
Formally, intuitionistic linear logic with subexponentials (SELL) shares with ILL all connectives and their inference rules, except the exponentials: instead of having a single pair of exponentials ! and ?, SELL may contain as many labelled exponentials,
!l, ?l, as needed. These are called subexponentials [4]. The subexponential signature
Σ = ⟨I, ≤,U⟩ is built from a set of labels I, U ⊆ I is a set specifying which subexponentials allow weakening and contraction on the left side of a sequent, and
≤ is the pre-order among the elements of I. We assume that U is closed wrt ≤, i.e., if a ∈ U and a ≤ b, then b ∈ U .
The subexponentials introduction rules are as follows. For each a ∈ I, we add the introduction rules corresponding to dereliction and promotion, where we state

4 Although ? is not part of ILL, we can add a linear version of it, not allowing it to be contracted or weakened.

explicitly the first-order signature L of the terms of the language:

L; Γ,F −→ G	a
L; !x1 F1,... !xn Fn −→ G	a

L; Γ, !aF −→ G ! L	and	L; !x1 F1,... !xn Fn −→ !aG ! R
The rules for ?a are dual. Here, the rule !aR (and ?aL) have the side condition that a ≤ xi for all i. That is, one can only introduce a !a on the right (or a ?a on the left) if all other formulas in the sequent are marked with indices that are greater or equal than a.
Observe that this means that provability is preserved downwards: if a formula
!aP is provable from a set of hypothesis, so it is !bP , for b ≤ a.
Furthermore, for all a ∈ U , we add the structural rules:

L; Γ, !aF, !aF −→ G

L; Γ, !aF −→ G	C	and
L;Γ −→ G

L; Γ, !aF −→ G W

That is, we are also free to specify which indices are unbounded (those appearing in the set U ), and which indices are linear or bounded. See the companion technical report of [18] at the authors’ web page for a focused intuitionistic version of the SELLA system.
It is known that subexponentials greatly increase the expressiveness of the sys- tem when compared to linear logic. For instance, subexponentials can be used to represent contexts of proof systems [19], to mark the epistemic state of agents [16], or to specify locations in sequential computations [17].
The key difference to standard presentations of linear logic is that while linear logic has only seven logically distinct prefixes of bangs and question-marks, SELL allows for an unbounded number of such prefixes, e.g., !i, or !i?j. As showed in [18],
by using different prefixes, we are able to interpret subexponentials in more creative ways, such as temporal units or spatial and epistemic modalities in distributed sys- tems. For instance, !iP specifies that the process P is located at space i. Moreover, since !iP −→ P , the information of P can be propagated outside the space i. On the other side, !i?iP specifies that P is located at i but its information is confined to the space i.
The interpretation of the aforementioned modalities in SELL relies on the ability
to quantify on subexponentials. For that, we introduced in [18] the system SELLA
containing two novel connectives: universal (A) and existential (d) quantifiers over
subexponentials.
Subexponential Quantiﬁers
Recall from lattice theory that given a pre-order (I, ≤), the ideal of an element a ∈ I in ≤, written ↓ a, is the set {x | x ≤ a}. The subexponential signature of SELLA is of the form Σ = ⟨I, ≤, F,U⟩, where I is a set of subexponential constants and ≤ is a pre-order among these constants. The new component F = {f1,..., fn} specifies families of subexponentials indices. In particular, a family f ∈ F takes an element of a ∈ I and returns a subexponential index f(a). As it will be clear below,

these families allow us to specify disjoint pre-orders based on ⟨I, ≤⟩. Finally, the set U ⊆ {f(a) | a ∈ I, f ∈ F} is a set of subexponentials generated from families, and as before, it is upwardly closed with respect to ≤: if a ≤ b, where a, b ∈ I, and f(a) ∈ U then f(b) ∈ U . Notice that the SELLA system obtained from the signature
⟨I, ≤, {id},U⟩ conservatively extends the SELL system obtained from ⟨I, ≤,U⟩.
For subexponential quantification, we will be interested in determining whether a subexponential b belongs to the ideal ↓ a of a given subexponential a. This is formally achieved by adding a typing information to subexponentials. Given the signature Σ = ⟨I, ≤, F,U⟩, the judgment s : a is true whenever s ≤ a. Thus we obtain the set AΣ = {s : a | s, a ∈ I, s ≤ a} of typed subexponential constants.
As with the universal quantifier ∀, which introduces eigenvariables to the signa- ture, the universal quantification for subexponentials A introduces subexponential variables l : a, where a is a subexponential constant, i.e., a ∈ I. Thus, SELLA sequents have the form A; L;Γ −→ G, where A = AΣ ∪ {l1 : a1,..., ln : an}, and {l1,..., ln} is a disjoint set of subexponential variables and {a1,..., an} ⊆ I are subexponential constants. Formally, only these subexponential constants and variables may appear free as an index of subexponential bangs and question marks. The introduction rules for the subexponential quantifiers look similar to those introducing the first-order quantifiers, but instead of manipulating the context L, they manipulate the context A, where le is fresh, i.e., not appearing in A nor L and
l : a ∈ A:
 A; L; Γ,P [l/lx] −→ G  A	A, le : a; L; Γ −→ G[le/lx] A
A; L; Γ, Alx : a.P −→ G	L	A; L;Γ −→ Alx : a.G	R
A, le : a; L; Γ,P [le/lx] −→ G d	 A; L; Γ −→ G[l/lx]  d
A; L; Γ, dlx : a.P −→ G	L	A; L;Γ −→ dlx : a.G	R

Intuitively, subexponential variables play a similar role as eigenvariables. The generic variable li : ai represents any subexponential that is in the ideal of the subexponential constant ai. This is formalized by constructing a pre-order, called sequent pre-order, written ≤A. This pre-order is formally used in the side condition of the promotion rule and is defined on subexponentials obtained from applying a family fi ∈ F to an element of I. Formally, it is the transitive and reflexive closure of the sets below.
{f(si : a) ≤A f(sj : b) | f ∈ F, si, sj ∈ I and si ≤ sj} ∪
{f(l : a) ≤A f(s : b) | f ∈ F, l /∈ I, s ∈ I and a ≤ s}

The first component of this set specifies that families preserve the pre-order ≤ in Σ only involving subexponential constants; thus ≤A is a conservative extension of ≤. The second component is the interesting one, which relates subexponential obtained from variables and subexponentials obtained from constants: l : a means that l belongs to the ideal of a and if a ≤ s, then f(l : a) ≤A f(s : sj). Notice that f(li : ai) and f(lj : aj) are unrelated for two different subexponentials variables li


	
Signature (I, ≤)	Typed Subexp. (A, ≤A)

Fig. 1.  a, b, d ∈ I and f(b : a) represents any subexponential constant in the ideal of a and f(b : a) ≤A f(a : a). lx, ly are subexponential variables of type a. Note that f(lx : a) ≤A f(a : a) ≤A f(d : d). Note also that f(lx : a) /≤A f(ly : a), i.e, variables, even of the same type, are unrelated w.r.t ≤A.

and lj (see Figure 1).
The pre-order ≤A is used in the right-introduction of bangs and the left-introduction of question-marks in a similar way as before in SELL


A; L; !f(l1: a1)F1,... !f(ln: an)Fn −→ G

A; L; !f(l1: a1)F1,..., !f(ln: an)Fn −→ !f(l : a)G

!f(l)R




A; L; !f(l1: a1)F1,... !f(ln: an)Fn,P −→ ?f(ln+1: an+1)G


A; L; !f(l1: a1)F1,..., !f(ln: an)Fn, ?f(l : a)P −→ ?f(ln+1: an+1)G

?f(l)L

with the side condition that for all 1 ≤ i ≤ n + 1, f(l : a) ≤A f(li : ai), where ≤A is the sequent pre-order constructed from the signatures Σ and A, as described above. Notice that bangs and question marks use families, while quantifiers use only constants and variables (i.e., typed subexponentials). This interplay allows us to
bind formulas with different families as in the formula Al : a.[!f(l : a)P ⊗ !g(l : a)Pj].
As pointed out in [4], for cut-elimination, one needs to be careful with the structural properties of subexponentials. For subexponential variables, we define f(li : a) to be always bounded, while for subexponential constants, it is similar as before: if f(s : a) ∈ U , then structural rules can be applied.
In [18] we proved that cut-elimination is admissible for the SELLA system.
Theorem 2.1 For any signature Σ, the proof system SELLA admits cut-elimination.
In the remainder of the paper, we shall simply write !f(l) instead of !f(l : a) when the type “: a” can be inferred from the context as in Al : a.(!f(l:a)F ). Similarly for “?.” We shall also write !s and ?s when the family and the type are not important or can be inferred from the context. Moreover, given a sequence of subexponentials of the form s = s1. ··· .sn, we shall write !s to mean !s1 ··· !sn . Similarly for ?s.

SELLA as Constraint System
Concurrent Constraint Programming (CCP) [25,23,26] is a model for concurrency that combines the traditional operational view of process calculi with a declarative view based on logic (see a survey in [20]). This allows CCP to benefit from the large set of reasoning techniques of both process calculi and logic. Processes in CCP interact with each other by telling and asking constraints (pieces of information) in a common store of partial information. The type of constraints processes may act on is not fixed but parametric in a constraint system. Such systems can be formalized as a Scott information system as in [26], or they be can specified as formulas in a suitable fragment of logic e.g., as in [27,15]. Here we build on the ideas of specifying constraint systems as formulas in Girard’s linear logic as in linear CCP (lcc) [6]. More precisely, we allow constraints to be formulas in a fragment of SELLA. As we shall show later, this gives rise toa more powerful CCP language that is able to capture, declaratively, distributed spaces. Furthermore, the new language offers primitives for a name passing discipline (i.e., mobility) upon both, local names (variables) and locations (subexponential indexes). The latter allows agents to define shared spaces of communication.
Let us start by defining the fragment of SELLA that will serve as the basis to the constraint system.
Definition 3.1 [SELLA-Constraint System] A subexponential constraint system (scs for short) is a tuple (Σ, C, ▶Δ) where Σ is a subexponential signature where all subexponentials are unrelated except for a distinguished subexponential l∞, which is the top element of the poset Σ. C is a set of formulas (constraints) built from a first-order signature and the grammar

F := 1 | A | F ⊗ F | ∃x.F | !s?sF

where A is an atomic formula. We shall use c, cJ, d, dJ, etc, to denote elements of
C. Moreover, let Δ be a set of non-logical axioms of the form ∀x[c −◦ cJ] where all free variables in c and cJ are in x. We say that d entails dJ, written as d ▶Δ dJ, iff the sequent C[[Δ ],d −→ dJ is probable in SELLA ( C[[Δ]] is later stated in Definition 3.8). We shall omit the “Δ” in ▶Δ when it is unimportant or it can be inferred from the context.
Let us give some intuitions on the above fragment of SELLA. The connective 1 corresponds to the empty store, i.e., the initial state of computation. The connective
⊗ allows processes to add more information to the store. The existential quantifier hides variables from constraints. The formula !fj (sj :a)?fj (sj :a)c specifies that the constraint c is in the space-location sj of the agent fj and this information is confined to that space (see Proposition 3.2 below). Finally, C[[Δ]] intuitively means that the axioms defined in Δ are available in all the spaces of the system.
Notation 3.1 We shall use both [c]s and `s c to denote the constraint !s?sc for an esthetic reason: the ﬁrst notation will be used when the constraints are inside

processes, while the second when they are in the store.
An interesting behavior of the formula [c]s is that it defines spaces where even inconsistent information can be confined.
Proposition 3.2 (False confinement) Let (Σ, Cs, ▶Δs ) be a scs and assume that the following sequent is provable c ⊗ d —→Δ 0. Then,
[0]s —→ [c]s (any c can be deduced in the space s if its local store is inconsistent);
[0]s /—→ [0]s′ if s /= sj (inconsistency is conﬁned);
C[[Δ ], [c]s, [d]s —→ [0]s (if space s contains both c and d, then it becomes incon- sistent);
C[[Δ ], [c]s, [d]s′ /—→ [0]s if s /= sj (false is not deduced if c and d are in different spaces);
[c]s /—→ c (local information is not global).

The language of Processes
In this section we propose dccp, a CCP-based language able to manipulate con- straints built from a subexponential constraint system. The main design criteria for this language are the following:
distributed agents can be defined where local information is private to them. Here the key aspect is to identify agents as family names in the subexponential signature. For that, notice that subexponentials of two different families are unrelated and then, the information of an agent will be confined to its local store;
agents can have an internal structure, i.e., its local store can be divided into locations. For that, we shall identify such locations as different subexponential indices in the signature as we did in [18]. Unlike sccp [12], we shall allow unbounded and linear locations to specify spaces where information can be updated;
agents can exchange local names, i.e., it is possible to reconfigure the com- munication structure of the system. This is achieved by the interplay of local processes and universally quantified asks as in Universal Timed CCP (utcc)
[21] ; and
agents can create new sub-spaces (local stores) and communicate them to other agents, thus defining new shared spaces for communication.
Similar to most processes calculi, the language of processes of dccp features a small number of constructors and it is powerful enough to express interesting behaviors of concurrent and distributed systems. Common to all languages based on CCP, we include constructs to add (tell) new information to the store, to hide (local) variables and to compose processes in parallel. Following the developments of lcc [6,10] and utcc [21], we allow the quantification of free variables in ask processes. Furthermore, as in lcc, ask agents consume information when evolving due to the

linear nature of the store. Here we notice that, by changing the subexponential structure, we can specify that some stores are persistent while some others are linear. Finally, following the developments of spatial CCP (sccp) [12], we allow processes to be confined to a given space (see [P ]s below). However, unlike sccp, in dccp it is possible to create and communicate shared spaces of communication between agents. Later we show that this ability is not ad hoc since we can give it a declarative meaning thanks to the connectives d and A in SELLA.
Definition 3.3 [Syntax of dccp] Processes in dccp are built from constraints in the underlying subexponential constraint system as follows:

P, Q := tell(c) | (local x; l) Q | (abs x; l; c) Q | P  Q | [P ]f(l) | p(x)

where variables in x and subexponential indexes in l are pairwise distinct. We assume that for each agent in the system there is a unique family name f and the
def
behavior of such agent is defined as Agent f = P . Moreover, for each process
name, there is a unique process definition of the form p(x) =Δ P where the set of
free variables is a subset of x.
Let us give some intuitions about the processes above. The process tell(c) adds c to the current store d producing the new store d ⊗ c. The process (local x; l) Q creates a new set of variables x and a set of new subexponential indexes and declares them to be private to Q. When any of those sets is empty, as in (local x; ∅) Q, we simply write (local x) Q when no confusion arises. Furthermore, instead of (local {x}; {l}) Q we write (local x; l) Q.
The process (abs x; l; c) Q evolves into Q[y, s/x, l] if the (distributed) store en- tails c[y, s/x, l]. When this happens, the constraint c is consumed. When either x or l is empty (or a singleton), we use a similar notational convention as we did for the local process. Furthermore, when all these sets are empty, we simply write ask c then Q instead of (abs ∅; ∅; c) Q. The abs constructor can be then used as a synchronization mechanism based on entailment of constraints.
The parallel composition of P and Q is denoted as P  Q. The processes [P ]l executes and confines the process P in the space l. Finally, given a process definition of the form p(x) =Δ P , the agent p(y) executes the process P [y/x].
Before we go any further, let us note that some processes built from Definition 3.3 may not adhere to the design criteria (i) of the language. For instance, assume the following agent definition
Agent f d=ef (abs l; [c]g(l)) P
In this case, f will query all the spaces in the store of g, and it can possibly consume information from it. Hence, agent f was able to directly read the store of another agent. Now consider the definition
Agent f d=ef [P ]g(l)
Here, f is able to execute the process P in the space of computation of g. In order to avoid this undesired behaviors, we need to impose syntactic restrictions on

all formula in c is indexed by the family fi	R

··· f :
x ; l ;Γ , tell(c); d ··· —→ · ·· f : x ; l ;Γ ; d ⊗ c ··· 
TELL


RTDIS
······ fj : xj ; lj ; Γj ; dj ··· fi : xi; li; Γi, tell([A]fj (l)); di ··· —→ · ·· fj : xj ; lj ; Γj ; dj ⊗ fj (l) A ··· fi : xi; li; Γi; di ··· 

∀j ∈ 1..n, xj ∩ y = fv (dj ) ∩ y = fv (Γj ) ∩ y = ∅
··· f : x ; l ;Γ , (local y; l) Q; d ··· —→ · ·· f : x ∪ y; l ;Γ , (local l) Q; d	RL

	li ∩ l = ∅	 R
f1 : x1; l1; Γ1; d1 , ··· fi : xi; li; Γi, (local y; l) Q; di , ··· fn : xn; ln; Γn; dn	—→


			
f1 : x1; l1 ∪ l; Γ1; d1 , ··· fi : xi; li ∪ l; Γi, (local y) Q; di , ··· fn : xn; ln ∪ l; Γn; dn 

d ▶	j	j  ⊗ e
 
i  c[y /y][l /l]
RA
j	j


··· fi : xi; li; Γi,P ; di —→ · · · fi : xi; li; Γi,P j; di ··· 
··· f :  x ; l ;Γ , Q; d  —→ · · · f : x ; l ;Γ , Qj; d ··· RSTR,	if P ≡ Q and P ≡ Q

 x ; l ;Γ ,P ; d  —→  j  j  j  j  j 
`	`	  j j  j	j `	j  `	RS

p(x) =Δ P
RC
··· fi : ⟨xi; li; Γ, p(y); di⟩··· —→ ··· fi : ⟨xi; li; ΓP [y/x]; di⟩··· 
Fig. 2. Structural Operational Semantics. fv (·) denotes the set of free variables. In RA, the constraint e
is the most general constraint to avoid weakening the store (see [9]). .
the processes and constraints agents can tell and ask:
Definition 3.4 [Well-formed agents] Let f and g be two different agent names. We
defsay that the agent definition Agent f	P is well-formed if:
All process subterm of the form [Q]s in P is of the shape [Q]f(l).
Constraints of the form [c]g(l) only appear in the scope of a tell process.
Restriction (i) prevents agents to execute processes in the space of other agents. Restriction (2) disallows agents able to read from the store of another agent. More- over, as we shall see, processes of the form tell([c]g(l)) in the agent f will be inter- preted as an asynchronous communication from f to g.
def
Notation 3.2 Assume the agent deﬁnition Agent f = P. As a consequence of the
previous restrictions, we shall omit the “f” in a subterm [Q]f(l) in P. Similarly, we shall omit the “f” in the ask agents deﬁned in P. Moreover, we shall understand tell([c]l) as tell([c]f(l)).
Operational Semantics
The operational semantics of dccp is given by the transition relation γ —→ γj
satisfying the rules on Figure 2. A conﬁguration γ is a set of tuples of the form

	
f1 : x1; l1; Γ1; c1 , ..., fn : xn; ln; Γn; cn 

where ci is a constraint specifying the store of agent fi, Γ is a multiset of processes (the behavior of fi), and xi, li are the set of hidden (local) variables and spaces of ci and Γi. The multiset Γ = P1, P2,..., Pn represents the process P1  P2...  Pn. We shall indistinguishably use both notations to denote parallel composition of processes.
Processes are quotiented by a structural congruence relation ∼= satisfying: (1) renaming of bound variables; (2) P  Q ∼= Q  P : and (3) P  (Q  R) ∼= (P  Q)  R; (4) (local ∅; ∅) Q ∼= Q; (5) tell(c ⊗ d) ∼= tell(c)  tell(d).
Let —→∗ be the reflexive and transitive closure of —→. If



f : x ; l ;Γ ; c  , ..., f


: x ; l

;Γ ; c

 —→∗


j	j	j	j 


j	j	j	j 


and the sequent !l∞ Al : ∞.C[[Δ ] , ∃j	j —→ d is provable, we write f :

l	xi. d li.ci	i


	
 xi; li; Γi; ci  ⇓d. If xi = li = ∅ and ci = 1 we simply write fi ⇓d. Intuitively,
for an agent definition of the form Agent fi d=ef P , the set {d ∈ C | fi ⇓d} captures the outputs of P under input 1. The formula C[[Δ]] will be clarified in Definition 3.8.
Given a set of agent declarations of the form Agent f1 d=ef P1, ··· , Agent fn d=ef Pn we shall consider the configuration f1 : ⟨∅; ∅; P1; 1⟩ , ..., fn : ⟨∅; ∅; Pn; 1⟩ as the initial state of the system.
Now we give some intuitions about the operational rules:
RTELL: If all formula in c is indexed by the family fi, the process tell(c) in the agent fi is able to add c to its local store. Notice that a process of the form tell([c]fj (l) ⊗ [d]fi(l′)), via rule (5) of the structural congruence, can be decomposed into tell([c]fj (l))  tell([d]fi(l′)) to fulfill the side condition in this rule.
If an agent f is willing to communicate the atomic formula A to another agent fj, it can asynchronously post the constraint `fj (l) A. Rule RTDIS says that constraints A is “communicated” and added to the store of the agent fj.
A process (local y; l) Q adds the local variables y (resp. the fresh subexponential variables l) to the sets xi (resp. li) as it is shown in Rule RL (resp. RLL). We recall that the left introduction rule of d creates the new location and makes it available to all the families in the system (see [18]). Then, Rule RLL adds l to all the configurations of the agents in the system (see Example 3.7).
j   j 
If the local store di of the agent fi is able to entail c[y /y][l l], then the agent
j   j
(abs y; l; c) Q evolves into Q[y /y][l /l] and consumes the constraint c. Note that

the constraint e in the entailment d ▶ c[yj/y][lj/l] ⊗ e is not necessarily unique. Take for instance the entailment !c ▶ c ⊗ 1 and !c ▶ c ⊗ (!c ⊗ 1). In the first case, we have an unwanted weakening of the store. To avoid this problem, we require e to be the most general choice as in [9]. We recall that the agent f is able to query only its own local store since constraints in the guard c must be marked only with subexponentials of the family f.
Rule RSTR says that congruent processes have the same reductions.

To explain the rule RS, consider the process [tell(c)]l. What we observe from this process is that the constraint [c]l is added to the store. This means that the output of tell(c) is confined to the space l. Now consider the process [ask c then Q]l. In this case, to decide if Q must be executed, we need to infer whether c can
be deduced from the information in location l. Hence, the premise of Rule R considers only the store `fi(l) di. Moreover, the new store in that location, i.e., dj is again placed at location l as shown in the conclusion of the rule.
Rule RC simply unfolds the definition of the process name p.

Programming in dccp
In this section we show some examples of distributed and concurrent behaviors that can be modeled in dccp. We also show how the interplay of local and abs pro- cesses allows us to dynamically create share and private stores among agents. When needed, to avoid formulas in the store not preceded by any subexponential, we as-
defsume    that each agent is defined as Agent f [P ] where out is a subexponential marking the “outermost” space in the store of the agent.
Example 3.5 [Local stores] Let a and b be unbounded subexponentials, P =
tell(c), Q = ask c then tell(d) and R = [P ]a  [Q]b. Let the agent f be defined as
def

Agent f
= [R]out. Here we observe the following:

f : ⟨∅; ∅; [R]out; 1⟩
—→∗ f : ∅; ∅; [[Q]b]out; `f(out) `f(a) c /—→

Then, Q remains blocked since the information c is only available on the space of
a. Note also that the sequent !f(out)?f(out)!f(a)?f(a)c —→ !f(out)?f(out)c is not provable, i.e., information c is confined to the inner space a in f.
Now let R = [P ]a  [Q]a. Then, we observe as a final store the constraint:

  c ⊗     d
f(out) f(a)	f(out) f(a)
This means that Q is able to entail the guard c in the space a to later add d to the store.
Finally, consider R = [[P ] ] [Q] . In this case, P will eventually add the constraint F = `f(out) `f(b) `f(a) c. Since the sequent F —→ `f(out) `f(a) c is not probable, Q remains blocked. This intuitively means that the space that b confers
to a may behave differently (i.e., it contains different information) from the own
space of a.
Example 3.6 [Name/Link Mobility] Name mobility is obtained by the interplay of abs and local processes when variables are considered. Assume for instance an uninterpreted predicate symbol com(·) and let P = (local x) (tell(com(x))  Pj) and

Q = (abs y; com(y)) Qj and R = P
as follows:
Q. Then the agent Agent f
def
= [R]out
behaves



f : ⟨∅; ∅; [R]out; 1⟩
—→∗ f : ⟨x; ∅; [tell(com(x))  Pj  Q]out; 1⟩
—→∗ f :  x; ∅; [P j  Q]out; `f(out) com(x) 
—→∗ f : ⟨x; ∅; [P j  Qj[x/y]]out; 1⟩

Here we assume that out is linear and then, the constraint `f(out) com(x) is con- sumed when the abs process evolves. Note that Pj and Qj share the link (variable) created by P and all the information posted on that variable may be seen by both processes.

Example 3.7 [Structured comm. patterns] Processes in dccp can exchange lo- cations to define shared spaces of information. This mobility is also akin to the π-calculus: processes do not move but links (location variables in our case) do [14]. So, we do not change the structure of agents but we reconﬁgure the communication structure of the system.
Consider a signature with a linear subexponential a and assume two agents f
and g. Let us define the following shortcuts:
def
request(g, f) = (local x, l) (tell([com(x)]g(a))  ask [com(x)]a then (tell([com(x)]g(l))  P ))

accept(g, f) def	a
)  (abs k; [com(y)]k) Q)

= (abs y; [com(y)] ) (tell([com(y)]f(a)
def


def

Furthermore, let Agent f = request(g, f) and Agent g
= accept(g, f). The

transitions for this system are depicted in Figure 3. The process request(g, f) creates a new location l and a fresh variable x. Then it sends com(x) to g through the “public space” a. Agent g consumes this information and sends back to f the constraint com(x). Then f sends again the constraint com(x) but using the new established private space l. Due to the abs process, agent g is able to read com(x) on l.
Some remarks are in order in this example: Note that in SELLA, the existential quantification on locations (d) makes available the new location to all the families in the signature. Then, in the first derivation above, we observe that l is also part of the signature of agent g. In an distributed implementation of the calculus, however, it would be necessary to broadcast an announcement to all the agents that the new location was created. A similar problem arises with the creation of variable x. In the sequent calculus the eignevariable is added and it is “visible” to all the formulas through universal quantification. Again, in an implementation of the calculus, it would be necessary to notify the other sites (or at least the site g) the creation of the variable.


f : ⟨∅; ∅; request(g, f); 1⟩ , g : ⟨∅; ∅; accept(g, f); 1⟩
—→∗ f :  x; l; tell([com(x)]g(a))  ask [com(x)]a then (tell([com(x)]g(l))  P ); 1 ,
g : ⟨x; l; accept(g, f); 1⟩
—→∗ f :  x; l; ask [com(x)]a then (tell([com(x)]g(l))  P ); 1 ,
g : x; l; accept(g, f); `g(a) com(x) 
—→∗ f :  x; l; ask [com(x)]a then (tell([com(x)]g(l))  P ); 1 ,
g :  x; l; tell([com(x)]f(a))  (abs k; [com(x)]k) Q; 1 
—→∗ f :  x; l; ask [com(x)]a then (tell([com(x)]g(l))  P ); `f(a) com(x) ,
g : ⟨x; l; (abs k; [com(x)]k) Q; 1⟩
—→∗ f : ⟨x; l; P ; 1⟩ , g :  x; l; (abs k; [com(x)]k) Q; `g(l) com(x) 
—→∗ f : ⟨x; l; P ; 1⟩ , g : ⟨x; l; Q[l/k]; 1⟩

Fig. 3. Transitions of the system in Example 3.7.

Logical Characterization of Processes
In [18] we showed a strong adequacy result at the level of derivations between SELLA and different flavors of CCP, namely, epistemic, spatial and timed CCP. Here we extend the encodings presented in [18] to consider the process (local l) Q and (abs l; c) Q. As expected, those processes will correspond, respectively, to formulas of the shape dl.F and Al.F where F corresponds to the encoding of Q.
We shall use sequences of the form a.b.c to denote the space [[[]c]b]a and remember
that all subexponentials but ∞ are unrelated and s ≤∞ for all s ∈ I. A constraint of the form `a `b `c d will be represented in the logical view of processes as `a.b.c d, thus allowing us to quantify over such prefixes (or boxes) by using a single quantifier.
We begin by encoding the stores (constraints) produced by processes as follows:
Definition 3.8 [Representation of Constraints] Let c be a constraint. We define the encoding C[[c]]l inductively as follows:
C[[A]]s	= `s A	C[[c ⊗ cj]]s = C[[c]]s ⊗ C[[cj]]s
C[[∃x(c)]]s = ∃x(C[[c]]s)	C[[[c]a]]s	= C[[c]]s.a

where A is an atomic formula or the unit 1.
Note that the axioms Δ of the constraint system must be available to all the spaces and agents of the system. Then, for each agent f, we consider the following

universally quantified formula:
!f(∞)Al : ∞.(∀x.(C[[c]]f(l) —◦ C[[c]]f(l)))
We shall use C[[Δ]] to denote the encoding of all the axioms in Δ.
Definition 3.9 [Logical view of Processes] Consider the following definition Agent f d=ef
P . We shall encode P as the formula P[[P ]]f(out) where:

P[[tell(c)]]s	= C[[c]]s	P[[(abs x; l; c) Q]]s = ∀x.A.l(C[[c]]s —◦ P[[Q]]s)

P[[(local x; l) Q]]s = ∃x. d l.(P[[Q]]s)	P[[P  Q]]s	= P[[P ]]s ⊗ [[Q]]s
P[[[P ]a]]s	= P[[P ]]s.a	P[[p(x)]]s	= C[[p(x)]]s

We assume that for all process definition p(x) =Δ P , and for all agent f, the following
formula is available:
!∞Al : ∞.∀x.(  p(x) —◦ P[[P ]]f(l))
f(l)
Note that the above universal quantification allows us to unfold the definition P in all location where p(x) is invoked. We shall use P[[Υ]] to denote the encoding of all the process definitions in the set Υ.
Following the proof technique in [18], we can show the following adequacy result.

Theorem 3.10 (Adequacy) Let Agent f1 d=ef P1,..., Agent fn d=ef Pn be a set of dccp agents declarations. Let (C, ▶Δ) be a scs and let C[[·]]l and P[[·]]l be as in Deﬁnitions 3.8 and 3.9 respectively. Then for all agent fi 5
fi ⇓c iff C[[Δ ]out, P[[Υ]]out, P[[P1]]f1(out), ..., P[[Pn]]fn(out) —→ C[[c]]fi(out) ⊗T 

Concluding Remarks
Related Work
Process calculi such as the π-calculus [14] allow for the specification of mobile systems, i.e., systems where agents can communicate their local names. Unlike the π-calculus (that is based on point-to-point communication), interaction in CCP is asynchronous as communication takes place thorough the shared store. In the CCP model it is possible to specify mobility in the sense of reconfiguration of the communication structure of the program. This is done by using logical variables that represent communication channels and unification to bind messages to chan- nels [25,23]. However, since logical variables can be bound to a value only once, if two messages are sent through the same channel, then they must be equal to avoid

5 The top erases the formulas corresponding to blocked processes.

an inconsistent store. This problem is often solved by the use of variables as streams and by relying on a communication protocol [13].
An alternative way of endowing CCP with a name-passing discipline, is to tailor π-style communication mechanisms. The cc-pi calculus [2] results from adding to the CCP model synchronous communication operands from the π-calculus. cc-pi provides a treatment of names in terms of restriction and structural axioms closer to nominal calculi than to variables with existential quantification. A distributed and probabilistic extension of CCP with networks of computational nodes, each of them with their own local store, is proposed in [1]. Nodes can send and receive, through communication channels, constraints, agents (processes) and channels themselves. In [22] CCP is endowed with send and receive primitives to allow asynchronous message-based communication. Moreover, the work in [7] defines a model of process mobility for CCP where localities (or sites) allow agents to have their own local store. Sites are organized in a hierarchical way and then, it is possible for an agent to have sub-agents. The reader may also refer to [5] that proposes the π+-calculus, that extends the π-calculus with a constraint store. The language proposed here (dccp) offers also a model of distributed computation in CCP but, unlike the above mentioned works, we preserve the declarative reading of processes as formulas in logic (Theorem 3.10).
Universal Timed CCP (utcc) was proposed in [21] as an orthogonal extension of timed CCP [24] for the specification of mobile reactive systems as security pro- tocols. Basically, utcc uses the interplay of local and abs processes, as described in Example 3.6. The sort of mobility that we can model in dccp is close to that of utcc. Here the reconfiguration of the communication structure is achieved by means of logical quantiﬁcation.

Future Work
We plan to explore the combination of timed modalities along with spatial and epistemic ones. For that, we can rely on the encoding of such modalities in SELLA described in [18].
From the logical point of view, we are currently exploring whether a quantifi- cation on families in the sequent calculus allows us to dynamic create new agents. This new sort of quantification is also required if we consider an infinite number of agents. To see this, note that the axioms (C[[Δ]]) and process definitions (P[[Υ]]) must be available to all the locations and agents in the system. Furthermore, we plan to explore the possibility of defining higher order CCP calculi where processes can be communicated among agents. For that, we could mark processes (not only constraints) with subexponentials and we can still give a declarative interpretation of processes as formulae in SELLA.
Acknowledgment
Olarte, Nigam and Pimentel were supported by CNPq. Pimentel was supported by FAPEMIG. This work has been (partially) supported by Colciencias (Colombia),

and by Digiteo and DGAR (E´cole Polytechnique) funds for visitors.

References
Luca Bortolussi and Herbert Wiklicky. A distributed and probabilistic concurrent constraint programming language. In Maurizio Gabbrielli and Gopal Gupta, editors, ICLP, volume 3668 of LNCS, pages 143–158. Springer, 2005.
Maria Grazia Buscemi and Ugo Montanari. Cc-pi: A constraint-based language for specifying service level agreements. In Rocco De Nicola, editor, ESOP, volume 4421 of LNCS, pages 18–32. Springer, 2007.
Iliano Cervesato, Frank Pfenning, David Walker, and Kevin Watkins. A concurrent logical framework II: Examples and applications. Technical Report CMU-CS-02-102, Carnegie Mellon University, 2003. Revised, May 2003.
Vincent Danos, Jean-Baptiste Joinet, and Harold Schellinx. The structure of exponentials: Uncovering the dynamics of linear logic proofs. In Georg Gottlob, Alexander Leitsch, and Daniele Mundici, editors, Kurt G¨odel Colloquium, volume 713 of LNCS, pages 159–171. Springer, 1993.
Juan Francisco D´ıaz, Camilo Rueda, and Frank D. Valencia. Pi+- calculus: A calculus for concurrent processes with constraints. CLEI Electron. J., 1(2), 1998.
Fran¸cois Fages, Paul Ruet, and Sylvain Soliman. Linear concurrent constraint programming: Operational and phase semantics. Inf. Comput., 165(1):14–41, 2001.
David Gilbert and Catuscia Palamidessi. Concurrent constraint programming with process mobility. In Lloyd et al, editor, Computational Logic, volume 1861 of LNCS, pages 463–477. Springer, 2000.
Jean-Yves Girard. Linear logic. Theor. Comput. Sci., 50:1–102, 1987.
R´emy Haemmerl´e. Observational equivalences for linear logic concurrent constraint languages. TPLP, 11(4-5):469–485, 2011.
R´emy Haemmerl´e, Fran¸cois Fages, and Sylvain Soliman. Closures and modules within linear logic concurrent constraint programming. In Vikraman Arvind and Sanjiva Prasad, editors, FSTTCS, volume 4855 of LNCS, pages 544–556. Springer, 2007.
Joshua Hodas and Dale Miller.  Logic programming in a fragment of intuitionistic linear logic.
Information and Computation, 110(2):327–365, 1994.
Sophia Knight, Catuscia Palamidessi, Prakash Panangaden, and Frank D. Valencia. Spatial and epistemic modalities in constraint-based process calculi. In Maciej Koutny and Irek Ulidowski, editors, CONCUR, volume 7454 of LNCS, pages 317–332. Springer, 2012.
Cosimo Laneve and Ugo Montanari. Mobility in the cc-paradigm. In Ivan M. Havel and Va´clav Koubek, editors, MFCS, volume 629 of LNCS, pages 336–345. Springer, 1992.
Robin Milner, Joachim Parrow, and David Walker. A calculus of mobile processes, Parts I and II. Inf. Comput., 100(1):1–40, 1992.
M. Nielsen, C. Palamidessi, and F. Valencia. Temporal concurrent constraint programming: Denotation, logic and applications. Nordic Journal of Computing, 9(1):145–188, 2002.
Vivek Nigam. On the complexity of linear authorization logics. In LICS, pages 511–520. IEEE, 2012.
Vivek Nigam and Dale Miller. Algorithmic specifications in linear logic with subexponentials. In Ant´onio Porto and Francisco Javier L´opez-Fraguas, editors, PPDP, pages 129–140. ACM, 2009.
Vivek Nigam, Carlos Olarte, and Elaine Pimentel. A general proof system for modalities in concurrent constraint programming. In Pedro R. D’Argenio and Herna´n C. Melgratti, editors, CONCUR, volume 8052 of LNCS, pages 410–424. Springer, 2013.
Vivek Nigam, Elaine Pimentel, and Giselle Reis. Specifying proof systems in linear logic with subexponentials. Electr. Notes Theor. Comput. Sci., 269:109–123, 2011.
Carlos Olarte, Camilo Rueda, and Frank D. Valencia. Models and emerging trends of concurrent constraint programming. Constraints, 18(4):535–578, 2013.
Carlos Olarte and Frank D. Valencia. Universal concurrent constraint programing: symbolic semantics and applications to security. In Roger L. Wainwright and Hisham Haddad, editors, SAC, pages 145–150. ACM, 2008.


Jean-Hugues R´ety. Distributed concurrent constraint programming. Fundam. Inform., 34(3):323–346, 1998.
Vijay A. Saraswat. Concurrent Constraint Programming. MIT Press, 1993.
Vijay A. Saraswat, Radha Jagadeesan, and Vineet Gupta. Timed default concurrent constraint programming. J. Symb. Comput., 22(5/6):475–520, 1996.
Vijay A. Saraswat and Martin C. Rinard. Concurrent constraint programming. In Frances E. Allen, editor, POPL, pages 232–245. ACM Press, 1990.
Vijay A. Saraswat, Martin C. Rinard, and Prakash Panangaden. Semantic foundations of concurrent constraint programming. In David S. Wise, editor, POPL, pages 333–352. ACM Press, 1991.
Gert Smolka. A foundation for higher-order concurrent constraint programming. In J.-P. Jouannaud, editor, Proceedings of Constraints in Computational Logics, volume 845 of LNCS, pages 50–72. Springer-Verlag, 1994.
Kevin Watkins, Iliano Cervesato, Frank Pfenning, and David Walker. A concurrent logical framework I: Judgments and properties. Technical Report CMU-CS-02-101, Carnegie Mellon University, 2003. Revised, May 2003.
