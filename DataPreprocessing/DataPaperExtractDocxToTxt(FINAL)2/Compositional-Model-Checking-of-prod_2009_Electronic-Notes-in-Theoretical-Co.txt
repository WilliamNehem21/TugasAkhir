

Electronic Notes in Theoretical Computer Science 250 (2009) 21–37
www.elsevier.com/locate/entcs

Compositional Model Checking of product-form CTMCs
Paolo Ballarini1 and	Andra´s Horva´th2

Abstract
Product form Markov chains are a class of compositional Markovian models that can be proved to benefit from a decomposed solution of the steady-state distribution (i.e. the steady-state distribution is given by the product of the components’ steady-state distributions). In this paper we focus on the Boucherie product processes, a specific class of product form Continuous Time Markov Chains. We show that the
compositional constraints that lead to the product form result in that class, can be exploited in the model checking problem as well, leading to a decomposed semantics for a fragment of the Continuous Stochastic Logic.
Keywords: Compositional Stochastic Model Checking, Product-form Markov Chains


Introduction
The Continuous Stochastic Logic (CSL) [1,2] has proved to be a valuable language for expressing performance and performability requirements over systems modelled as Continuous Time Markov Chains (CTMCs). CSL properties are verified against a CTMC model by means of appropriate model checking algorithms. Model check- ing procedures for finite state models are sensitive to the size of the model. A considerable amount of works aiming to increase the applicability of model check- ing with respect to the model’s dimension can be found in literature. There are at least three different types of approach for tackling the so-called state-space explosion problem: compacting the state-space representation (i.e. symbolic model checking); reducing the state-space dimension through abstraction; reducing the state-space through decomposition of the original model (i.e. compositional model checking).
For example, symbolic model checking, (for both non-probabilistic [10] and prob- abilistic [9,6] systems), employs specific data structures (BDDs, MTBDDs) to get a compact representation of the state-space. On the other hand, abstraction in model

1 Computing Science Department, University of Glasgow, UK, paolo@dcs.gla.ac.uk
2 Dipartimento Informatica, Universit`a di Torino, Italy, horvath@di.unito.it, partially supported by MIUR through PRIN project Famous and EEC project Crutial.

1571-0661 © 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.08.003

checking aims to look for an abstracted, hence reduced, version of the model which turns out to be equivalent to the original one from some point of view. Compo- sitional veriﬁcation of properties in a given temporal logic, instead, concerns the analysis of the truth of a formula when the given model is obtained by composition of a number of submodels. The goal, in that respect, is to investigate the possibility of inferring the truth of a formula φ by the verification of φ itself, or some other formulae, on the component models. Compositional approaches to model check- ing of non-probabilistic system have been widely studied (see, for example, CTL compositional model checking [7] and module checking [11]).
If lot has been done with respect to the compositional verification of non- probabilistic systems, to the best of our knowledge, the compositional verification of properties referred to probabilistic systems still remains a mainly unexplored area of research. In this paper we consider the CTMC domain of probabilistic systems and we tackle the compositional verification issue with respect to it. Specifically, we take into consideration a compositional framework for CTMCs, namely the Bouche- rie product process [3], in which a K-dimensional CTMC is obtained as the product of K components CTMC. The Boucherie framework is suitable to model systems in which a number of parallel processes compete over a number of mutually exclusive, shared resources. No explicit synchronisation between processes is considered apart from the implicit one due to the mutually exclusive access to shared resources. By the imposition of two constraints on the compositional rule, respectively mutual- exclusion and strong blocking, the relevant results proved by Boucherie is that the steady-state distribution of the product-process M is given by the product of the steady-state distribution of M ’s components.
In this paper we consider the CSL model checking problem for the family of Boucherie processes. We show that compositional verification of a subset of the CSL language can be performed on a Boucherie product process. Hence given a CSL formula φ referred to a K-dimensional process M we show how an equivalent (set of) formula(e) φ', that refer to some of M ’s components, can be derived.
The remainder of the paper is organised as follows. In Section 2 the Boucherie compositional framework is formally described and an example, which will be re- ferred to throughout the paper, is presented. In Section 3 the CSL logic is briefly introduced and the compositional verification is proved for a subset of it. Section 4 discusses the gains we have by applying the proposed approach. Finally Section 5 summarises the work presented in this paper and illustrates guidelines for future work.
CTMC basics. We introduce the basic notions/notations that concern CTMCs. They will be used in the remainder of the paper. Given a set of atomic propositions AP = {a, b, c . . .} a labelled CTMC is denoted M = (S, Q, L) where S is a finite set of states, Q : S × S → R≥0 is the rate matrix, with Q(s, s) = 0, and L : S → 2AP is the labelling function. The transition rate Q(s, s') > 0 if and only if there is a transition from s to s' and the delay of a transition s → s' is governed by an exponential distribution whose parameter is the transition rate Q(s, s'). Any state s such that Q(s, s') = 0 for all s' ∈ S is called absorbing.  The sum of

the outgoing transition rates from a state s is called the exit rate of s and it is denoted by E(s) =  s'∈S Q(s, s'). Whenever Q(s, s') > 0 for more than one state s', then there is a race between different transitions from s. In such a case the
probability that a transition from s to s' (s /= s') occurs within t time units is given
by P (s, s', t) = Q(s,s') ·  1 − e−E(s)·t .  P (s, s') = Q(s,s') represents the embedded
transition probability matrix of M . The probability of leaving a state s ∈ S within a time interval I = [a, b] ⊆ R≥0 is denoted eI (s) = (e−a·E(s) − e−b·E(s)). The steady- state distribution for a CTMC M (i.e. the distribution that indicates the probability of being in a certain state in the long-run) is denoted πM (or simply π whenever indicating M is not relevant in the context of the discourse). For a collection of K > 1 CTMCs, the subscript k will be used for referring to the kth (1 ≤ k ≤ K) CTMC in the collection (e.g. Mk =(Sk, Qk, Lk), APk, Pk, πMk ).

Boucherie product form
In [3], Boucherie introduced a compositional CTMC, M , suitable to model com- petition between concurrent processes over a number of shared resources. Such a model is described as a collection of K ergodic CTMCs, Mk, 1 ≤ k ≤ K, each of them with finite state-space, Sk, transition matrix, Qk and unique steady-state distribution, πk.
An index set, I ⊂ N>0, represents the shared resources. The set of components competing for resource i is denoted by Ui. We assume that Ui contains at least two components for every resource i ∈ I (otherwise the resource would not be shared). The set Cki ⊂ {1,...,K} represents the components competing with component k over resource i ∈ I and Rk ⊂ I indicates the resources component k is competing over. For given k and i ∈ I, Aki denotes the set of states of Mk in which resource i is in use by component k. It is assumed for any component k and any two resources i and j that Aki ∩ Akj = ∅. Ak0 will denote the set of states where no shared resources are used by k 3 . The product process M is characterised by two conditions. Condition 1: each transition can change the state of one component only (i.e., there is no synchronisation). Condition 2 : resources are mutually exclusive and strong blocking, that is, if component k holds resource i then all its competitors (i.e., k' ∈ Cki) are blocked.
Under these assumptions Boucherie proved that the steady state probability of a state s = (s1,..., sk,..., sK) of the composed process, M , is of product form, i.e., it
can be computed as π(s1,..., sk,..., sK) = G   K  πi(si) where πi(si) denotes the
steady state probability of state si in the CTMC describing component i. For the efficient calculation of the normalisation constant, G, see [12]. The state-space, S, is obtained by subtracting from the product Πk∈KSk the set of states that represent a breach of the mutually exclusive condition (the set of these states will be denoted by ME) and the set of states that correspond to circular blocking (the set of these

3 to make it more intuitive we denote non-shared resources with i = 0, whereas in [3] the resource index
i = 1 is used to represent non-shared ones.

states will be denoted by CB). As a result S is formally defined as:

K
S =	Sk \ (ME ∪ CB)	(2.1)
k=1

The set ME can be computed as ME = 


i:i∈I


J:J⊂Ui,|J|≥2

K
k=1
J where DJ =

Aki if k ∈ J and DJ = Sk otherwise, i.e., every state in which a given resource is
used by at least two components must be excluded because it violates the condition of mutual exclusion.
In order to identify the states in CB, we introduce the following notation. A given resource allocation situation will be represented by the vector |r1,..., rK| where ri ∈ I (i.e., component i uses resource ri) or ri = 0 (i.e., component i does not use any shared resource). Then the system is in circular blocking in |r1,..., rK| if there exists a sequence of component indices i1,..., iC, 2 ≤ C ≤ K such that
ri1 ∈ Ui2 , ri2 ∈ Ui3 ,..., riC−1 ∈ UiC , and riC ∈ Ui1 . The set of vectors representing

circular blocking will be denoted by CBr. Then CB =  r:r∈CBr
K
k=1
Akrk  .

The no-synchronisation and strong-blocking constraints Boucherie framework are reflected on the rate-matrix Q of M . For two states, s = (s1,..., sk,..., sK) and
s' = (s' ,..., s' ,..., s' ), Q(s, s') = 0 if s and s' differ in more than one component;
1	k	K
Q(s, s') = Qk(sk, s' ) if s and s' differ only in component k and component k is not blocked in s; Q(s, s') = 0 if s and s' differ only in component k and component k is blocked in s.
In this work we extend the Boucherie framework by assuming that states of component k are labelled with atomic propositions from set APk. For convenience we further assume that sets APk (1 ≤ k ≤ K) are pair-wise disjoint. The set of
atomic propositions of M is AP = ∪K APk.
As an example Boucherie process we consider the stochastic version of the popu- lar Dining Philosophers problem. In such a model K philosophers are sitting around a table on which K chopsticks (or forks) are disposed so that each philosopher share the chopstick on his right with his right neighbour and the chopstick on his left with his left neighbour. A philosopher behaviour is described as an infinite loop consist- ing of two activities: thinking and eating. In order to eat a philosopher must get both chopsticks, which he will release as soon as he starts thinking again.

M1	M2	M3



eat1

eat2

eat3


Fig. 1. Three dining philosophers and corresponding CTMCs

In this paper we refer to the case with K = 3 philosophers where forkk, k ∈
{1, 2, 3}, denotes the resource shared by Mk and M(k+1)mod(K). Furthermore we use the resource eatk which is shared between Mk and its two neighbours. Since we are


Table 1
States of the 3 Dining Philosophers CTMC

considering 3 philosophers only then we have a single eat resource which is shared among the three of them.
Process/resource competition and corresponding CTMCs are shown in Figure 1. States of component Mk are labelled with labels thinkk, Rforkk, Lforkk and eatk (we use tk, Rfk, Lfk and ek as abbreviations for them) according to resources occupation. Transition rates are all assumed to be 1. Philosophers’ competition and the resulting state space partition is summarised as follows:
S1 = A10 ∪ A11 ∪ A13 ∪ A14	state-space
A10 = {think1}	no resource states


M1 :
A13 = {Lfork1}	resource 3 states
A14 = {eat1}	resource 4 states
R1 = {fork1, fork3, eat}	shared resource
C11 = {M2}, C13 = {M3}, C14 = {M2, M3} competing processes






M2 :
S2 = A20 ∪ A21 ∪ A22 ∪ A24
A20 = {think2} A21 = {Lfork2} A22 = {Rfork2} A24 = {eat2}
R2 = {fork1, fork2, eat} C = {M }, C = {M }, C24 = {M1, M3}




M3 :
S3 = A30 ∪ A32 ∪ A33 ∪ A34
A30 = {think3} A32 = {Lfork3} A33 = {Rfork3} A34 = {eat3}
R3 = {fork2, fork3, eat} C = {M }, C = {M }, C34 = {M1, M2}


State-space S of the composed CTMC M is obtained from (2.1) straightfor- wardly. The states corresponding to a breach of the mutually exclusion are the states in which at least two philosophers uses the resource eat or at least one of the forks is used by the two adjacent philosophers.
Also circular blocking is easy to identify in this example. The philosophers are blocked when each of them has the corresponding right or left fork, these states are given by: CB =  A11 × A22 × A33 ∪ A13 × A21 × A32 . Finally we report that for the 3 philosophers example |ME| = 40 and |S| = Πk|Sk|− |ME| = 64 − 40 = 24, i.e., the composed CTMC consists of 24 states which are listed in Table 1.

Compositional CSL model checking for Boucherie pro- cesses
The Continuous Stochastic Logic (CSL) [1,2], is a formal language for expressing properties of a system modelled in terms of a labelled CTMC.
Given a set AP of atomic propositions, a labelled CTMC model M = (S, Q, L) can be verified against properties expressed in CSL formulae. The syntax of CSL state-formulae (φ) and path-formulae (ϕ) is

φ := a | tt | ¬φ | φ ∧ φ | SŒp(φ) | PŒp(ϕ)	(3.1)
ϕ := XI φ | φ UI φ	(3.2)

where a ∈ AP , p ∈ [0, 1], Ð∈ {<, ≤, >, ≥} and I ⊆ R≥0 is a non empty interval. The semantics of CSL formulae is defined in terms of two probability measures:
the steady-state probability and the paths probability. πM (s, φ) denotes the proba-
bility that, in the long-run, a state where φ is true has been reached given that s was the starting state. State s satisfies steady-state formula SŒp(φ) iff πM (s, φ) Ð p. Similarly ProbM (s, ϕ) denotes the probability of paths in M with initial state s that satisfy ϕ (where ϕ is built on the time-bounded extension of the standard Next and Until path operators [8]). A path formula PŒp(ϕ) is satisfied by state s iff ProbM (s, ϕ) Ð p. Formally:

s |= tt forall s ∈ S	s |= φ' ∧ φ'' iff s |= φ' ∧ s |= φ''
s |= a iff a ∈ L(s)	s |= ¬φ iff s |= φ
s |= SŒp(φ) iff πM (s, φ) Œ p	s |= PŒp(ϕ) iff ProbM (s, ϕ) Œ p

Below we report equation (3.3) (taken from [2]) for computing the probability measure of time-bounded Next formulae. It will be referred in the remainder.
Prob(s, XI (ψ)) = eI (s) ·	P (s, s')	(3.3)
s'|=ψ

We consider a K-dimensional labelled Boucherie CTMC M =(S, Q, L) with states
labelled according to their projections, which is: L : S → 2AP : L(s) = ∪K  Lk(sk).
We take into account a restricted CSL syntax in which nesting of probabilistic operators is not permitted. The resulting syntax is given by:

φ ::= ψ | ξ | ϕ | ω | φ ∧ φ | ¬φ	ϕ ::= PŒp(XI (ψ))	ξ ::= SŒp(ψ)
ψ ::= tt | a | ψ ∧ ψ | ¬ψ	ω ::= PŒp(ψ U ψ)

The state formulae φ can be categorised according to the atomic propositions they are built upon. A state formula, φ, in which all the atomic propositions belong to the same component, will be referred to as single component formula. A state formula, φ, in which the atomic propositions refer to more than one component, will be called global formula.
We observe that the compositional semantics of simple boolean formulae (ψ) is a straightforward consequence of the “decomposed” labelling of M . For example, with

respect to a 3-dimensional Boucherie CTMC we have that (s1, s2, s3) |= a1 ∧a2 ∧a3
if and only if s1 |=1 a1, s2 |=2 a2 and s3 |=3 a3.
In the following we introduce the idea of k-move and devise its probability (Lemma 3.1). We refer to a transition Q(s, s') as a k-move if it corresponds to a change of state of component k. We observe that the probability of observing a k-move in state s = (s1,..., sk,..., sK), denoted pk(s), is given by:



pk(s)= 
8< P

Ek (sk )
j∈B(s) Ej (sj )


if k∈B(s)

(3.4)

: 0	if k∈B(s)

where B(s) = {kˆ ∈{1,...,K} : ∃ˆi ∈Rkˆ, ∃k' ∈Ckˆˆi∧sk' ∈Ak'ˆi} is the set of components that are blocked in s. We shall refer to states s for which B(s) = ∅ as a globally non-
blocking states as opposed to partially blocking states, for which B(s) /= ∅ 4 . Note that (3.4) states that there’s a null probability of observing a k-move in any state such that one amongst the competitors of k is using a resource that k is competing for. If that is not the case, instead, the probability of observing a k-move depends on how many amongst the remaining components are free to move (i.e., not blocked because one of the resource they compete for is in use by someone else). Note that if k is the only non-blocked component (i.e., B(s) = {k}), then such probability is equal to 1.
The following lemma states the relation between the embedded transition prob- abilities of the composed process and the embedded transition probabilities of the components.

Lemma 3.1 The probability of a k-move from state s to s' is equal to the probability of the corresponding k-projection (sk → s' ), weighted by the probability of observing a k-move in s. (i.e., the embedded transition matrix P of a Boucherie process M, is a factor of its k-projection).
P (s, s')= Pk(sk, s' ) · pk(s)	(3.5)

In the rest of this section we report that in several cases it can be decided in a compositional way if a given state of the composed process satisfies a state formula or not. In particular, we take into account three types of formulae: Section 3.1 deals with single component Until formulae; Section 3.2 discusses single component Next formulae; Section 3.3 considers global Next formulae.
Essentially, we show that, given a path formula of one of the above three types, the probability of the paths satisfying it can be computed in terms of some derived formulae over the components.
For what concerns formulae involving the steady state operator, since steady state probabilities of the states in the composed process is of product form, their evaluation is straightforward.

4 Note that S is accordingly partitioned.

Single component Until formulae
The following theorem provides a relation between the composed process and its components for untimed paths.
Theorem 3.2 Consider a ﬁnite untimed path σk over one of the K components. The probability of observing a path σ in the composed CTMC whose k-projection is σk is equal to the probability of observing the path σk in the CTMC Mk, i.e.,
Prob{σ : Projk(σ)= σk} = Probk{σk}.

Intuitively, Theorem 3.2 holds because in a Boucherie process a component can block another for a given amount of time but it cannot change the way the other component chooses its next state. A formal proof is given in the appendix.
Theorem 3.2 cannot be generalised to any timed path. Consider the model of the three philosophers and the path σ = (think1, think2, think3), [1, 2], (Rfork1, think2, think3). Since in state (think1, think2, think3) any of the philosophers can
move and since either philosopher 2 and 3 can move into a state in which philoso- pher 1 is blocked, then the probability of σ is not equal to the probability of the path (think1), [1, 2], (Rfork1) in M1.  On the other hand, there exist paths whose
probability can be computed on the single component. E.g., since only philosopher 1 can move in (eat1, think2, think3), we have that Prob((eat1, think2, think3), [1, 2], (think1, think2, think3)) = Prob1((think1), [1, 2], (eat1)).
The following theorem is a direct consequence of Theorem 3.2.
Theorem 3.3 For a state s = (s1,..., sk,..., sK) of a K-dimensional Boucherie CTMC and a single component untimed Until formula ωk, then
(s1,..., sk,..., sK ) |= ωk ⇐⇒ sk |=k ωk

As a consequence of Theorem 3.3, a single component Until formula can simply be checked on the involved component. Finally, we briefly note that Theorem 3.3 can be generalised to nested single component path formulae as well with the restriction that there is not Next operator in the formula.
Single component Next formulae
Assume now that we have a single component Next formula XI (ψk) that refers to component k. The following theorem shows that checking XI (ψk) against the composed process is equivalent to checking a similar Next formula on component k.

Theorem 3.4 For s = (s1,... sk,... sK) a state of a K-dimensional Boucherie CTMC, I = [a, b] ⊆ R+, the probability measure of a time bounded single-component Next formula (XIψk) is given by:
“	”	„	1 ·I	«

where  1  · I =  a  ,  b  . is a shifted time-interval.

Proof. see Appendix.	 
The above result indicates that reasoning about temporal Next properties in a Boucherie framework can be done in a decomposed fashion. In particular the verifi- cation of a single-component Next formula bounded by I against M boils down (in the worst case) to the verification of the same Next formula with a shifted bounding interval I'. Intuitively such time-shift can be explained as a (stochastic) compensa- tion of the decreased concurrency: when we move the focus of our attention from a state (s1,..., sK) of M to its projection sk on Mk, we essentially decrease the number of enabled transitions, hence the likelihood of leaving sk within a given delay increases.
Example 3.5 Let us consider the 3 Dining Philosophers and suppose we are inter- ested in the probability that: from the initial state (t1t2t3) of M , in one-step, the re- source fork1 gets occupied by M1 with a delay in the interval I = [2, 5]. In CSL this can be expressed through the formula ϕ1 ≡ X[2,5](Rf1). To describe the relationship between the probability measure of ϕ1 wrt component M1 (i.e. Prob1(t1, ϕ1)) and wrt the composed CTMC M (i.e. Prob(t1t2t3, ϕ1)) we refer to Figure 2 which shows the unfolding of paths for M1 and M (paths satisfying X(Rf1) are the non-dashed ones). Since E(t1t2t3) = 6 and eI (t1t2t3) = (e−2·6 − e−5·6), then by application of (3.3) wrt M we have that Prob(t1t2t3,X[2,5](Rf1)) = (e−12 − e30) · 1/6. On the other hand wrt to M1, E1(t1) = 2 and eI (t1) = (e−2·2 − e−5·2), thus from (3.3) we have that Prob1(t1,X[2,5](Rf1)) = (e−4 − e10) · 1/2. Since component M1 is not blocked in t1t2t3 and the probability of a 1-move is p1(t1t2t3) = 1/3, then also Prob(t1t2t3,X[2,5](Rf1)) = 1/3·1/2(e−3·4−e−3·10) = p1(t1t2t3)·Prob1(s1,X[6,15]a1).

Global Next formulae
Let ψ be a global formula (i.e. a formula containing atomic propositions that refer to at least 2 different components) written in disjunctive normal form: ψ =
 i j aij. Each conjunct aij is a (possibly negated) atomic proposition referring to one component (i.e., aij ∈ APk for some k). We consider the Next formula XI (ψ), where I = [a, b] ⊆ R+ is a continuous time interval. Given a state s = (s1,... sK) of M then for every component Mk we define the (state-dependent) formula
¬tt	if ∀i ∃j : aij ∈APl,l /= k ∧ sl |= aij
tt	if ∃i ∀j : aij ∈APl,l /= k ∧ sl |= aij

ξk(s)= 
>
^	aij
(3.7)
otherwise

>: i:∇j',aij'∈APl ,l/=k,sl |=aij' j:aij∈APk


M1	M

t1t2t3


Lf1
Rf1

Lf1t2t3

Rf1t2t3 t1Lf2t3  t1Rf2t3 t1t2Lf3  t1t2Rf3


Fig. 2. Paths satisfying a Single-component Next formula

M1	M2	M3
M
t1t2t3



Lf1
Rf1
Lf2
Rf2
Lf3
Rf3
Lf1t2t3  Rf1t2t3  t1Lf2t3  t1Rf2t3 t1t2Lf3	t1t2Rf3


Fig. 3. Paths satisfying a Global Next formula

whose meaning is as follows. Assuming that it will be component k to move, the next state of the composed model will satisfy ψ if and only if the next state of component k will satisfy ξk.
Let us consider a state (s1, s2, s3) of a 3-dimensional CTMC and the formula: ψ = a1 ∧ a2 ∧ b1 ∧ a3   a1 ∧ c1 ∧ c2 ∧ d2 ∧ d3   c3 ∧ b2 and let assume that s1 |= a1∧b1∧c1, s2 |= a2 , and s3 |= c3∧d3. If none of the processes is blocked three different moves must be considered.
1-move: since s3 /|= a3 and s2 /|= d2 and s2 /|= b2 no matter what 1-move we consider ψ will not be satisfied in the resulting next state of the composed process. Accordingly ξ1(s1, s2, s3) = ¬tt.
2-move: thanks to component 1 and component 3, the next composed state will surely satisfy a1 ∧ b1  a1 ∧ c1 ∧ d3  c3. It follows that if and only if the next state of component 2 satisfies either (c2 ∧ d2) or b2, then the next composed state satisfies ψ. It results in ξ2(s1, s2, s3) = (c2∧d2) ∨ b2.
3-move: thanks to component 1 and component 2, the next composed state will surely satisfy a1 ∧a2 ∧b1  a1 ∧c1. It follows that if and only if the next state of component 3 satisfies a3, then the next composed state satisfies ψ. Accordingly ξ3(s1, s2, s3) = a3.
If a k-move happens, in order to satisfy XIψ, the next state of component k has to satisfy ξk(s1,..., sK) and the transition has to happen within I. The resulting theorem is as follows.
Theorem 3.6 For a state s = (s1,... sk,... sK) of a K-dimensional Boucherie CTMC, the probability measure of a time bounded global Next formula (XIψ) is decomposed as follows:


Prob(s, XI ψ)= 
k∈XB(s)

  1  I
pk(s)Probk(sk,X pk (s)

ξk(s1,..., sK ))	(3.8)

Proof. The proof of this theorem can be constructed as the proof of Theorem 3.4. 

Example 3.7 Again let us refer to the 3 Dining Philosophers and suppose we are interested in the probability that, from the initial state, the first move of any philosopher will be to get hold of his right fork with a delay in [2, 5]. This is captured by the global-Next formula ϕ ≡ (X[2,5](Rf1 ∨ Rf2 ∨ Rf 3)). Figure 3 shows the unfolding of paths generating at the initial state of each component Mk and of the composed process M (non-dashed lines denote paths satisfying ϕ ≡ (X[2,5](Lf1 ∨ Lf2 ∨ Lf 3))). By application of (3.3) we obtain straightforwardly


Prob(t1t2t3,X[2,5](Rf1 ∨ Rf2 ∨ Rf 3))= 1/2 · (e−2·6 − e−5·6).

Now we apply theorem 3.6. Note that in the initial state t1t2t3 every compo- nent is free to move. From (3.7) we have ξ1(t1t2t3) = Rf1, ξ2(t1t2t3) = Rf2 and ξ3(t1t2t3) = Rf3. Since the probability of a k-move in t1t2t3 is pk(t1t2t3) = 1/3 for
all k ∈ {1, 2, 3}, the right end of (3.8) is Σ3	1/3 · Probk(tk,X[2·3,5·3]Rfk).  Since
Probk(tk,X[6,15]Rfk) = 1/2 · (e−6·2 − e−15·2) then we have
3
1/3 · Probk(tk,X[6,15]Rfk)= 1/2(e−6·2 − e−15·2)
k=1
= Prob(t1t2t3,X[2,5](Rf1 ∨ Rf2 ∨ Rf 3))

Global (untimed) Until Formulae
In this section we consider Until formulae that refer to more than one component, like, for example, the formula ((think1∧think2)Ueat3) which refer to the likelihood that philosopher M3 wins the competition with both M1 and M2. Unfortunately the derivation of a compositional semantics, similar to the one demonstrated for the single-component Until and Next formulae, is not an easy task in this case. In fact, if the decomposed semantics of single-component Until formulae is a straightforward consequence of the independence of the components CTMCs, the benefit of such independence is lost when we have to look at paths that must simultaneously fulfil conditions on several components, as is the case with global Until formulae.
Nevertheless the possibility for a decomposed verification of global Until formu- lae may be suggested by observing the following property: given that ϕ is a global Until formula and σ a path in M that satisfies it, then, for each component k that is referred to by ϕ, σk, the k-projection of σ, satisfies a single-component Until for- mula ϕk which is derived from ϕ. E.g., if ϕ ≡ ((think1∧think2)Ueat3), the following single-component Until formulae can be derived:
ϕ1 ≡ (think1 U true), ϕ2 ≡ (think2 U true), ϕ3 ≡ (true U eat3)
and, σ |= ϕ =⇒ σk |= ϕk, ∀k ∈ {1, 2, 3}. Unfortunately, we are actually looking for a reversed type of implication, which is: we would like to prove that ϕk formulae exist such that verifying them against the components Mk is equivalent to verify ϕ against M . To do that, we would need to derive an aggregation model that describes how to combine the (local) probabilities of each ϕk, so that their combination is equivalent to the probability of ϕ in M . The derivation of such aggregation model is an hard task and we do not have a solution for it as yet.
To overcome that difficulty we propose an alternative approach. Rather than looking at a (decomposed) semantics equivalence for Until formulae, we see if we can exploit the inherent compositional description of a Boucherie CTMC within the CSL model checking algorithm itself.
For a state s of a labelled CTMC M = (S, Q, L) the probability of satisfying an un-timed Until formula (φ U ψ) in s is computed through the following recursive function [2]:




Prob(s, (φ U ψ)) =
1	if s |= ψ
P (s, s') · Prob(s', (φ U ψ)) if s |= φ ∧ ¬ψ
>: 0	otherwise

The above function can be adapted to a Boucherie CTMC as
1	if s |= ψ
Prob(s, (φ U ψ)) = >< Pk∈B(s) Ps' :s' ∈Sk,s.s' |=φ	if s |= φ ∧ ¬ψ
pk(s)Pk(sk, s' ) · Prob(s.s' , (φ U ψ))
>:	k	k
0	otherwise
where s.s'k denotes the state obtained from s by substituting sk by s' .
The above equation shows that the probability of Until formulae referring to a Boucherie CTMC can be established without having to resort to the probability transition matrix P of the composed model. Note also that in the sum we consider
only those states for which s.s' |= φ which allows for checking in a compositional
manner which are those states of the composed model for which the recursion must be computed. As a result the memory requirement of the model checking algorithm for Until formulae can be lowered with respect to the “uncompositional” approach.

Timed Until formulae
We have shown in Section 3.1 that a single component untimed Until formula re- ferring to component Mk can be verified without considering the other components of the model. When the formula is timed the way in which the other components block and hence “delay” component Mk must be taken into account.
In a given resource allocation situation, the transient behaviour of the composed model can be computed in product form. As a consequence, if a formula is satisfied only by paths along which the resource allocation does not change, then composi- tional verification is possible. This is rarely the case and hence we have to compute probability of path along which transient probabilities are not of product form. Even in this case however we can take advantage of the modular construction of the model for what concerns the storage of Q, the rate matrix of the composed model. In particular, entries of Q can be computed on the fly based on the rate matrices of the components, Qi, 1 ≤ i ≤ K. This approach, which is based on Kronecker algebra (see, for example, [5] for details), results in significant memory saving if the composed model is large. Having the compact representation of the model, model checking techniques for large structured CTMCs can be applied [4].
The state space of the model can be divided into macrostates. Each macrostate is characterised by the current resource usage of the components described by a vector |r1,..., rK| where rj = 0 if component j does not use any shared resource and rj > 0 indicates that resource rj is in use by component j.
Then the rate matrix of the Markov chain of the composed model can be con- structed as a block matrix in which block (i, j) contains transitions from states of macrostate i to states of macrostate j.
Before proceeding with the description of the blocks of Q we introduce the following notation. Qi,j is the submatrix of Qk in which rows are selected according

to states in Aki and columns according to states in Akj. 0i and Ii are the zero and
the identity matrix of size |Aki|× |Aki|, respectively.
Two kinds of blocks must be distinguished because two kinds of transitions can occur: either a transition inside the macrostate or a transition that leads to a dif- ferent macrostate. The block which describes the transitions inside the macrostate is given as

M Ai with Ai =
( Qri,ri if component i is not blocked

(3.9)

i=1
ri	if component i is blocked

where	is the Kronecker sum operator. The block that describes transitions from macrostate r1,..., rj,..., rn to macrostate r1,..., r' ,..., rn is
ri,r'
where   is the Kronecker product operator.
As an example we consider the model of the dining philosophers in a slightly more complicated version. In particular, every state of the philosopher will be represented by 2 states of the corresponding Markov chain. The rate matrix of the chain that corresponds to philosopher i, 1 ≤ i ≤ 3, denoted by Qi is
0  qi,12 qi,13 qi,14 qi,15 qi,16	0	0
qi,21	0  qi,23 qi,24 qi,25 qi,26	0	0
˛	˛

0	0	0  q
˛
i,34
0	0 q
i,37
qi,38

0	0  qi,43	0	0	0  qi,47 qi,48
0	0	0	0	0  qi,56 qi,57 qi,58
0	0	0	0  qi,65	0  qi,67 qi,68
˛	˛
qi,71 qi,72	0	0	0	0	0  qi,78
˛ qi,81 qi,82	0	0	0	0  qi,87	0 ˛


In states 1 and 2 the philosopher thinks, in states 3-4 has only the left fork, in states 5 and 6 has only the right fork and in state 7 and 8 eats.
Let us consider a few blocks of Q. The transitions inside the macrostate in which
all the philosophers think can be written as Q0,0  Q0,0  Q0,0 where Q0,0 is given

in (3.11).
1	2	3	i

The transition inside the macrostate in which philosopher 1 has his left fork and the other two are in thinking phase can be computed as Q3,3   00   Q0,0 where we
have a zero matrix because philosopher 2 is blocked and Q3,3 is as in (3.11).
The transitions that takes from the macrostate in which everybody thinks into the macrostate in which philosopher 1 has his right (resource 1) fork are given by Q0,1  I0  I0 with Q0,1 given in (3.11).

1	2	3

Q0,0 =
1
0  qi,12
˛


Q3,3 =
0	q1,34
˛

Q0,1 = q1,15 q1,16

(3.11)

˛ qi,21	0 ˛	˛ q1,43	0  ˛	˛ q1,25 q1,26 ˛

Let us consider now the transition matrix of the embedded DTMC of the pro- cess, P . Note that P heavily depends on the transition rates of the individual components because “fast” components make moves with higher probability than “slow” components. From the embedded DTMCs of the components, Pi, 1 ≤ i ≤ K,

the transition rates cannot be recovered. For this reason P cannot be built based on the individual embedded DTMCs. We can still however compute entries of P without storing the whole matrix based on the fact that P = I − (diag(Q))−1Q where diag(Q) is the diagonal matrix of Q.

On the gain of decomposed model checking
So far we have seen that the verification of a certain type of CSL formulae against a Boucherie CTMC M is equivalent to the verification of some derived formulae against the component CTMCs Mk. The obvious advantage of such an approach is that if the components processes are smaller than the composed one (which almost always is the case), then the verification of large Boucherie processes through model checking can benefit of that.
Although a precise evaluation of the advantage of such decomposed approach depends very much on the considered model and the formulae to check, we can make some general considerations. If verifying a formula φ against M is equivalent to verifying a derived formula φ' against Mk, then the gain is given by the state- space dimension difference |S|− |Sk|: the larger the difference the greater the gain. By definition of the Boucherie CTMC state-space (2.1) we observe that the number of states in M (hence the difference |S|− |Sk|) depends on the following.
K: the dimension of the Boucherie framework (i.e., the number of compo- nents): the larger the dimension, the greater the gain.
C: the level of competition of the framework: this, in turn, depends on both: the number of shared resources (I), and the distribution of competition amongst them (i.e. the sets Aki). We may say that a resource that is shared by
processes has a lower level of competition that a resource which is shared by
processes. Similarly we may say that a framework in which processes occupy shared resources in single states only, has a lower level of competition than a framework in which processes hold shared resources through a number of different states. As a result the larger the level of competition of a framework, the greater is the gain.
Let us consider the example of the 3 Dining Philosophers and suppose we are interested in determining what is the probability that Philosopher 1 will eat (at some point), which corresponds to the CSL single-component formula ϕ1 ≡ (true U eat1). Because of Theorem 3.2 we know that it is sufficient to verify ϕ1 directly on the 4-states CTMC M1, rather than against the 24- states M , which implies a about 83% gain in state-space. Finally we observe that, in some cases, the verification
of φ against M corresponds to the verification of a number of φ' against Mk (e.g
Global Next). To evaluate the gain in this case we need to consider the number
of φ' we have to verify on each component. If the decomposition of φ results in
nk formulae φ' that has to be verified against component Mk then the gain of
decomposed verification, in this case, is: (|S|− Σk∈{1...K} nk · |Sk|). For example,
as we have seen before, the Global-Next formula ϕ ≡ (X[2,5](Rf1 ∨ Rf2 ∨ Rf 3)) is

decomposed into the following 3 single-component formulae: ϕ1 ≡ (X[6,15](Rf1)), ϕ2 ≡ (X[6,15](Rf2)) and ϕ3 ≡ (X[6,15](Rf3)) each of which has to be verified against the component it is referring to. Hence, the gain of the decomposed semantics, in this case, is 24 − 3 · 4 = 12 (i.e. 50% gain). Note that more significant figures would be obtained for more complex/realistic systems: the 3 Dining Philosophers model is indeed just a toy example.

Conclusion
We have studied a compositional approach to the probabilistic model checking prob- lem. More precisely we have considered a family of compositional (product- form) CTMCs (i.e. the so-called Boucherie process), and we have shown how CSL model checking verification can be “decomposed” for (certain) formulae that are referred to such CTMCs. The obvious implication of such results is that the complexity of CSL model checking can be reduced by some order of magnitudes. The composi- tional results herein demonstrated are referred to CSL non-nested path-formulae only: the extension to nested path-formulae is part of our future goals. Further- more we have argued that a decomposed CSL semantics cannot be derived for timed Until formulae because the transient behaviour of the Boucherie process is not of product form. However it seems possible to develop transient analysis technique that provides the transient behaviour based on computation on the single compo- nents. This technique which we aim to study in the future could lead to developing a compositional verification method for the segment of CSL formulae that we did not deal with in this paper.

References
A. Aziz, K. Sanwal, V. Singhal, and R. Brayton. Model-checking continuous-time Markov chains. ACM Transactions on Computational Logic, Vol. 1:pp. 162–170, 2000.
C. Baier, B. Haverkort, H. Hermann, and J.-P. Katoen. Model-checking algorithms for continuous-time Markov chains. IEEE Trans. on Software Eng., Vol. 29(6):pp. 524–541, June 2003.
R. Boucherie. A characterisation of independence for competing Markov chains with applications to stochastic Petri nets. IEEE Trans. on Software Eng., Vol. 20(7):pp. 536–544, 1994.
P. Buchholz, J.-P. Katoen, P. Kemper, and C. Tepper. Model-checking large structured Markov chains.
J. Log. Algebr. Program., 56(1-2):69–97, 2003.
P. Buchholz and P. Kemper. Kronecker based matrix representations for large markov models. In Validation of Stochastic Systems, volume 2925 of Lecture Notes in Computer Science, pages 256–295, 2004.
C. Baier, E. Clarke, V. Hartonas-Garmhausen, M. Kwiatkowska, and M. Ryan. Symbolic model checking for probabilistic processes. In Proc. of the 24th Int. Coll. on Automata, Languages and Programming, volume 1256 of LNCS, pages pp. 430–440. Springer-Verlag, 1997.
E. Clarke, D. Long, and K. McMillan. Compositional model checking. In Proceedings of the Fourth Annual Symposium on Logic in computer science, pages 353–362, Piscataway, NJ, USA, 1989. IEEE Press.
E. Clarke, E. Emerson, and A. Sistla. Automatic verification of finite-state concurrent systems using temporal logic specifications. ACM Transactions on Programming Languages and Systems, Vol. 8(2):pp. 244–263, 1986.


J.-P. Katoen, M. Kwiatkowska, G. Norman, and D. Parker. Faster and symbolic CTMC Model- Checking. In Proceedings of the Joint International Workshop PAPM-PROBMIV, volume 2165 of LNCS. L. de Alfaro S. Gilmore, 2001.
J.R. Burch, E.M. Clarke, D.L. Dill, K.L. McMillan, and J. Hwang. Symbolic model cheking: 1020 states and beyond. In In Proc. of LICS ’90. IEEE Computer Society Press, 1990.
O. Kupferman and M. Y. Vardi. Module checking. In CAV ’96: Proceedings of the 8th International Conference on Computer Aided Verification, pages 75–86, London, UK, 1996. Springer-Verlag.
M. Sereno. Computational algorithms for product-form of competing markov chains. In 10th International Workshop on Petri Nets and Performance Models (PNPM 2003), Urbana, Illinois, USA, pages 93–102. IEEE Press, sep 2003.
A	Proofs
Proof of Theorem 3.2. On condition that the state of the composed process is (s' ,..., s' , ..., s' ) ∈
1	k	K
S, the probability that the first k-move leads the process to state (s'',..., s'', ..., s'' ) will be denoted
1	k	K
by Fk((s'',..., s'',..., s'' )|(s' ,..., s' , . .., s' )). On condition that the state of the composed process is
1	k	K	1	k	K
(s' ,..., s' , ..., s' ), the probability that the first k-move is the nth move will be denoted by Fk,n((s' ,..., s' ,
1	k	K	1	k
..., s' )).
In any state of the composed process component k is either blocked or it can make a move. By construction of the Boucherie process
component k will make a move in the future with probability one, i.e., P∞  Fk,i((s' , ..., s' ,..., s' ))=1 
assuming that it is component k to make the move, it takes a move according to its own infinitesimal generator Qk.
Based on the above facts
∞	'  ''
F ((s'',..., s'',..., s'' )|(s' ,..., s' ,..., s' )) = X F  ((s' ,..., s' ,..., s' )) Qk (sk, sk )
	


'  ''  ∞
'  ''

= Qk(sk, sk ) X F

	
((s' ,..., s' ,..., s' )) = Qk (sk, sk ) ,



i.e., the next state of component k after the first k-move does not depend on the state of the other com- ponents. Further, the distribution of the next state of component k in the composed CTMC is identical to the distribution of the next state in the single CTMC which implies the theorem.	 

Proof of Theorem 3.4. The probability of satisfying a time bounded next formula (XI ψk) in state s is
given by: Prob(s, XI (ψk)) = eI (s) · Ps'|=ψ  P (s, s') or, equivalently:

Prob “s, XI (ψ )”	=	“e−a·P
Ej (sj )	−b·P
— e
Ej (sj )”	·	X P (s, s').  (A.1)



In order to calculate Prob(s, XI (ψk)) the following cases have to be considered.
k ∈ B(s), sk |=k ψk: in this case the successors of s that may satisfy ψk are only those corresponding to a k-move. Hence, by application of Lemma 3.1 into (A.1) we have:

Prob(s, XI (ψ ))= (e−a·P
Ej (sj )	−b·P
— e
Ej (sj )) · pk(s) · X


P (s , s' )= 

k


  −a· Ek (sk )
j∈B(s)

−b· Ek (sk ) !
j∈B(s)


X



k k
s' |=kψk
„

k

1  [a,b]	«



k ∈ B(s), sk |=k ψk: in this case every successor of s that corresponds to a non-k-move satisfies ψk
whereas a subset of those corresponding to a k-move satisfy ψk. Hence,

“	I	”
 
“ −a·P
Ej (sj )	−b·P
— e
Ej (sj )” ·

260Bpk(s) · X
P (s , s' )1C + 0BX


¯
p (s) ·
X P¯(s¯ , s' )1C37

4@	s' |=kψk	A	@k¯/=k
k  k
s' ∈S¯
k¯ A5

k	k¯
„


k
1  [a,b]	«


k ∈ B(s), sk |=k ψk: since component k is blocked, the path formula is satisfied if the composed process makes a move in I. We have that
Prob “s, XI (ψk)” = “e−a·Pj∈B(s) Ej (sj ) − e−b·Pj∈B(s) Ej (sj )” .

i, ii and iii demonstrate (3.6).	 
