Electronic Notes in Theoretical Computer Science 42 (2001)
URL: http://www.elsevier.nl/locate/entcs/volume42.html 22 pages


Axiomatisation of an Interval Calculus for Theorem Proving

Antonio Cerone 1

Software Verification Research Centre, The University of Queensland, Brisbane, Australia



Abstract
We provide an axiomatisation of the Timed Interval Calculus, a set-theoretic nota- tion for expressing properties of time intervals. We implement the axiomatisation in the Ergo theorem prover in order to allow the machine-checked proof of laws for reasoning about predicates expressed using interval operators. These laws can be then used in the machine-assisted verification of real-time applications.



Introduction
In recent years formalisms based on time intervals have been increasingly used for specifying real time systems. However, the complexity of proofs by hand makes their use in verification hard. There is thus the need to express such cal- culi in an environment that provides a reasonable automatisation for theorem proving. The only work in this direction we are aware of is an early attempt at implementing the Duration Calculus in the PVS theorem prover [13].
In our work we have defined an axiomatisation of the Timed Interval Cal- culus (TIC) [5], a set-theoretic notation for expressing properties of time inter- vals based on work by Mahony and Hayes [6]. Many useful laws for reasoning about predicates expressed in TIC have been developed [5,4,15] and used in verifying a wide range of real-time systems [2,4,15]. However, these laws need a more precise characterisation to allow their implementation in a theorem prover. Our axiomatisation gives the infrastructure for such an implementa- tion. The actual implementation has been carried out using the Ergo theorem prover [14,1].

1 Email: antonio@it.uq.edu.au
◯c 2001 Published by Elsevier Science B. V. Open access under CC BY-NC-ND license.

Timed Interval Calculus
The Timed Interval Calculus (TIC) is based on the notion of a time interval . Given a time domain T, time intervals are represented as the set of all times between some infimum a and supremum b. For instance (a ... b] denotes the left-open and right-closed interval between times a (exclusive) and b (inclu- sive). Similarly for (a ... b), [a ... b) and [a ... b]. The set of all time intervals is denoted by I.
The principal specification tool of TIC consists of special brackets for defin- ing the set of all time intervals during which a given predicate is everywhere true [5]. For instance (-P -] is the set of all left-open and right-closed time in-
tervals i∈I such that for each time t∈i predicate P is true at t . Similarly for (-P -), [-P -) and [-P -]. TIC allows within predicate P occurrences of functions
on I and functions on T that are not applied to arguments; they must be interpreted as applied respectively to the interval i defined by P and to every point t in the whole interval i [7]. However, when implementing the calculus in a theorem prover we need to introduce an explicit notation for such a lifted
form of functions. We also define -	∪ [-P -). Similarly for -	-,

-	-	-
|-(-P -) = (-P -)
|-(-P -], (-P )-|

[-P )-| and |-(-P )-|.
An important capability of TIC is an operator for connecting intervals end-to-end, to support reasoning about sequences of behaviours. The con- catenation of two sets of intervals X and Y is the set X;Y of all the intervals
z such that there exist two disjoint intervals x ∈X and y ∈Y with supremum of x equal to infimum of y and whose union is z .



Time Model
The first step in mechanising an axiomatic approach to the specification of real-time systems is the axiomatisation of the time domain. When specifying real-time systems in TIC the time domain may be the set R of real numbers

[2,5] or an appropriate proper subset of R, such as the set R+
of the non-

negative reals, the set N of natural numbers, or even an appropriate subset of the extension R∞ of R with the +∞ and −∞ special values [4]. In this section we present an axiomatisation of the time domain, whose purpose is to capture the general properties that a time domain has to meet, such as having the same granularity on the whole time flow [3].
Let T denote the open time domain, 0 denote the zero of the time domain,
−∞ denote the infimum of the time domain, +∞ denote the supremum of the time domain, and T∞ denote the closure of the open time domain with the infimum and the supremum.
A first set of axioms (type axioms) defines properties of T and T∞ and


defines the value of non-negative predicate nn on such domains.
T1 T ⊆ T∞	T2 0 : T
T3 nn(T) ⇔ (∀ x : T. (0 ≤ x ))	T4 nn(T∞) ⇔ nn(T)
T5 ∀ x : T∞. (x ∈ T ∨ x = +∞∨ (¬ nn(T) ⇔ x = −∞))
Axioms T1 defines T∞ as an extension of T. Axioms T2 defines a special element (0) of T. T3 and T4 define predicate nn which is true on T and T∞ if the time domain does not contain negative time points. Axiom T5 introduces +∞ as an element of T∞; it also introduces −∞ as an element of T∞ if T contains at least one negative time; moreover it ensures that there are no other elements of T∞ which are not in T.
Axioms (T6–T11) characterise ≤ as a partial order and < as the strict
order. The special values −∞ and +∞ are respectively defined as the bottom and the top of the partial order in T∞.
T6  ∀ x , y : T∞. (x ≤ y ∨ y ≤ x )
T7 ∀ x , y : T∞. (x ≤ y ∧ y ≤ z ⇒ x ≤ z ) T8 ∀ x , y : T∞. (x ≤ y ∧ y ≤ x ⇒ x = y ) T9 ∀ x , y : T∞. (x < y ⇔ x /= y ∧ x ≤ y ) T10  ∀ x : T. (x < +∞)
T11 ¬ nn(T∞) ⇒ ∀ x . T. (−∞ < x )
T12 ∃ x : T. (0 < x )
Axiom T6 ensures that ≤ is defined for every pair of elements of T∞. Ax- iom T7 ensures that ≤ is transitive. Axiom T8 ensures that ≤ is antisym- metric. Axiom T9 defines < in terms of ≤. From Axioms T7, T8 and T9 we can derive the transitivity of <. Axiom T10 characterises +∞ as an upper bound for T∞. Axiom T11 characterises +∞ as a lower bound for T∞. From Axioms T5, T10 and T11 we can derive that +∞ is the least upper bound
(supremum) of T∞ and that −∞ is the geatest lower bound (infimum) of T∞. Axiom T12 ensures that there exists at least a positive time.
Notice that reflexivity of ≤ is an obvious consequence of Axiom T6. More- over, +∞ /∈ T can be derived from T9 and T10, while −∞ /∈ T can be derived from T9 and T11.
The + addition operator is defined for time points by the following axioms.
T13 ∀ x , y : T∞. ((x + y ) : T∞ ⇔ x : T ∨ y : T ∨ x = y )
T14 ∀ x : T∞. (x +0 = x )
T15 ¬ nn(T) ⇒ ∀ x : T. ∃ y : T. (x + y = 0)
T16 ∀ x , y : T∞. (x + y = y + x )
T17 ∀ x , y, z : T∞. (x + (y + z ) = (x + y )+ z ) T18 ∀ x : T∞. (x < +∞⇒ x + (−∞) = −∞) T19 ∀ x : T∞. (−∞ < x ⇒ x + (+∞) = +∞)
Axiom T13 deserves a special remark. It ensures that + is defined between


finite time points or identical infinite time points. This excludes the sum between −∞ and +∞, which would lead to an indefinite result. Axioms T14– T17 define 0 as the identity for +, the existence of the opposite for a time domain that includes negative time points and the properties of commutivity and associativity for +. Axioms T18 and T19 consider the special cases when at least one of the arguments of + is infinite.
Some axioms relate the partial order relation and the sum function.


T20 ∀ x , y : T. (x + y = 0 ⇒ (x ≤ 0 ∧ 0 ≤ y ) ∨ (y ≤ 0 ∧ 0 ≤ x ))
T21 ∀ x , y : T. (0 < y ⇒ x < x + y )
T22 ∀ x , y : T. (y < 0 ⇒ x + y < x )


Axiom T20 ensures that if the sum of two time points is 0, then they cannot be both positive or both negative. Axioms T21 and T22 ensure that a finite time is increased by adding a positive finite time and decreased by adding a finite negative time.
Notice that Axioms T9, T12 and T21 together with the transitivity of
< ensure that there exists an infinite number of positive time points. Anal- ogously, T9 and T22 together with the transitivity of < ensure that if there exists a negative time point, then there exists an infinite number of negative time points.
The last set of axioms define the time distance or duration d between time points.


T23 ∀ x , y : T∞. (d (x , y ) : T∞ ⇔
(x = +∞⇒ y < +∞) ∧ (x = −∞ ⇒ −∞ < y ))
T24 ∀ x , y : T∞. (d (x , y ) : T∞ ⇒ d (x , y ) = d (y, x ))
T25 ∀ x , y, z : T. (d (x , y ) = d (x + z , y + z ))
T26 ∀ x : T. ∀ y : T. (x ≤ y ⇔ x + d (x , y ) = y )
T27 ∀ x : T∞. (d (x , +∞) : T∞ ⇒ d (x , +∞) = +∞)
T28 ∀ x : T∞. (d (x , −∞) : T∞ ⇒ d (x , −∞) = +∞)

Axiom T23 defines d between finite time points or non-identical infinite time points. This excludes d (−∞, −∞) and d (+∞, +∞), which would lead to an indefinite result. T24 is the commutative property. T25 ensures that the granularity of time is the same on the whole time flow [3]. T26 relates sum and distance on finite time points, whereas T27 and T28 define the special cases where at least one of the arguments of distance is an infinite time. It is straightforward to prove that d meets the properties of a distance on a metric space.

Time Intervals and Sets of Intervals
The first set of axioms defines the set I of all well-formed time intervals.
I1 I ⊆ U	I2 ∀ i : I. i ⊆ T	I3 T : I	I4 ¬ ∅ : I
Axiom I1 characterises the set of all time intervals I as a subtype of the class of all sets U, while Axiom I2 ensures that every time interval is a subset of the time domain. According to Axiom I3 the whole time domain T is seen as a time interval, that is, as an element of I. In other words T has type I. I4 prevents ∅ from been considered as a time interval because it has no position in the time domain.
A second set of axioms defines functions α : I → T and ω : I → T, which give respectively the left and right endpoints of an interval, and the predicates lcl and rcl, which are true if the interval is respectively left-closed and right-closed and are false otherwise.
I5 ∀ i : I. ∀ x : T. (α(i ) < x ∧ x < ω(i ) ⇒ x ∈ i )
I6 ∀ i : I. (α(i ) : T∞ ∧ (lcl(i ) ⇔ α(i ) ∈ i ))
I7 ∀ i : I. (ω(i ) : T∞ ∧ (rcl(i ) ⇔ ω(i ) ∈ i ))
Axiom I5 ensures that all the time points that are greater than the left end- point and smaller than the right endpoint belong to the interval. I6 ensures that an interval is left-closed iff the left endpoint belongs to the interval. I7 is analogous for right endpoints of right-closed intervals.
The next set of axioms define the adjacent predicate adj (Axiom I8) and the concatenation function • (Axiom I9).
I8 ∀ i , j : I. (adj(i , j ) ⇔ (ω(i ) = α(j ) ∧ i ∩ j = ∅))
I9 ∀ i , j : I. (adj(i , j ) ⇔ i•j = i ∪ j )
Axiom I8 ensures that intervals i and j are adjacent if the right endpoint of i is the left endpoint of j , but i and j are disjoint. I9 defines the concatenation of adjacent intervals as their union.
A special function φ : I → I denotes the identity function on I. It is defined by the following axiom.
I10 ∀ i : I. φ(i ) = i

Let S denote the the set of all possible interval sets and S denote the extension of S with the empty set.
S1 ∀ I . (I : S ⇔ ∀ i . ((i ∈ I ) ⇒ (i : I)))
S2 ∀ I : S. (I ∪ {∅}) : S)
S3 S ⊆ S
S4 S ⊆ U

While the empty set is not a time interval, there are situations when it is useful to reason with it [15].
The most interesting operation between interval sets is their concatenation.
S5 ∀ I , J : S. (I ; J = {k | ∃ i , j . i ∈ I ∧ j ∈ J ∧ (k = i•j )})
The concatenation of two interval sets I and J is the set of all possible con- catenations of an interval i ∈ I with an interval j ∈ J . If there are no such intervals, then I ; J = ∅. The concatenation can be extended to elements of S through the following axioms.
S6 ∀ I : S. ∀ J : S. ((I ∪ {∅}); J = I ; J ∪ J )
S7 ∀ I : S. ∀ J : S. (I ; (J ∪ {∅}) = I ; J ∪ I )

It is straightforward to verify that {∅} is the unit of concatenation on S.
Lifting Predicates
The central feature of TIC is the use of functions from the time domain (T) and from the time interval domain (I) to model the dynamic behaviour of observable system properties. In order to elide most explicit references to these two domains, functions may be used in a lifted form within predicates [6]. However, to avoid ambiguities in the theorem prover, these uses must be made explicit.
A total function v : T → V from the time domain to V can be lifted within a predicate as v↑. Analogously for a total function from the interval time domain. For instance α : I → T can be lifted as α↑. Let P (v↑, α↑) be a predicate expression containing v↑ and α↑ and no other lifted form, ↓T be
a functional infix operator having a predicate as left argument and a time as right argument and giving a predicate as a result, ↓I be a functional infix operator having a predicate as left argument and an interval as right argument and giving a predicate as a result. Then P may be instantiated with time t using substitution as follows.
P↓Tt = P [v (t )/v↑]
Analogously P (v↑, α↑) may be instantiated with interval i using substitution as follows.
P↓Ii = P [α(i )/α↑]
Functions ↓T and ↓I are axiomatised by giving the following axioms for v and
v↑ and for α and α↑.
ATv v↑↓Tt = v (t )	AIv v↑↓Ii = v↑
ATα α↑↓Tt = α↑	AIα α↑↓Ii = α(i )
ATω ω↑↓Tt = ω↑	AIω ω↑↓Ii = ω(i )


Analogous axioms must be given for all the functions from time and from time intervals that need to be used in a lifted form. Moreover, axioms are needed to define how to propagate the instantiation through the structure of the predicate. Constants are not affected by instantiation, whereas instantiation is propagated through the arguments of (non lifted) functions and functional, relational and logical operators. For example, the following axioms are given for the propagation of the ↓T operator through any constant c, functions v and α, operators +, < =, ∈, ∧ and ⇒ and quantifier ∀.

LTc c↓Tt = c,	for any constant c of any type
LTv v (¯t )↓Tt = v (¯t ↓Tt )
LTα α(¯ı)↓Tt = α(¯ı↓Tt )
LT+ (a + b)↓Tt = ((a↓Tt )+ (b↓Tt )) LT< (a < b)↓Tt = ((a↓Tt ) < (b↓Tt ))) LT= (a = b)↓Tt = ((a↓Tt ) = (b↓Tt )) LT∈ (a ∈ A)↓Tt = ((a↓Tt ) ∈ (A↓Tt )) LT∧ (P ∧ Q )↓Tt = ((P ↓Tt ) ∧ (Q↓Tt )) LT⇒ (P ⇒ Q )↓Tt = ((P ↓Tt ) ⇒ (Q↓Tt ))
LI∀ (∀ x . P )↓Tt = ∀ x . (P↓Tt ),	if x is not free in t
Analogously, the following axioms are given for the propagation of the ↓I operator through any constant c, functions v and α, operators +, < =, ∈, ∧ and ⇒ and quantifier ∀.

LIc c↓Ii = c,	for any constant c of any type
LIv v (t )↓Ii = v (t↓Ii )
LIα α(¯ı)↓Ii = α(¯ı↓Ii )
LI+ (a + b)↓Ii = (a↓Ii )+ (b↓Ii ) LI< (a < b)↓Ii = (a↓Ii ) < (b↓Ii ) LI= (a = b)↓Ii = (a↓Ii ) = (b↓Ii ) LI∈ (a ∈ A)↓Ii = (a↓Ii ) ∈ (A↓Ii ) LI∧ (P ∧ Q )↓Ii = (P↓Ii ) ∧ (Q↓Ii ) LI⇒ (P ⇒ Q )↓Ii = (P↓Ii ) ⇒ (Q↓Ii )
LI∀ (∀ x . P )↓Ii = ∀ x . (P↓Ii ),	if x is not free in i
Notice that LT-axioms and LI-axioms must be given for all function, including the ones that are not used in lifted form.
Then P (v↑, α↑) may be instantiated with both an interval i and a time t
using substitution as follows.

P↓(i, t ) = P [α(i )/α↑, v (t )/v↑]

The ↓ functional infix operator having a predicate as left argument and a pair consisting of an interval and a time as right argument and giving a predicate


as a result can be defined as the composition of ↓I and ↓T.

LD↓ P↓(i, t ) = (P ↓Ii )↓Tt
It is easy to prove the following theorems

LDC (P↓Ii )↓Tt = (P↓Tt )↓Ii LDT (P↓Tt )↓Tt ' = P↓Tt LDI (P↓Ii )↓Ii ' = P↓Ii
Each of the following theorems can be derived from LD↓ and every pair of the corresponding AT-axioms and AI-axioms.

Av v↑↓(i, t ) = v (t )
Aα α↑↓(i, t ) = α(i )
Aω ω↑↓I(i , t ) = ω(i )

Each of the following theorems can be derived from LD↓ and every pair of the corresponding LT-axioms and LI-axioms.

Lc c↓(i, t ) = c,	for any constant c of any type
Lv v (¯t )↓(i, t ) = v (¯t ↓(i, t ))
Lα α(¯ı)↓(i , t ) = α(¯ı↓(i , t ))
L+  (a + b)↓(i, t ) = (a↓(i, t ))+ (b↓(i , t ))
L< (a < b)↓(i, t ) = (a↓(i, t )) < (b↓(i, t ))
L= (a = b)↓(i, t ) = (a↓(i, t )) = (b↓(i, t ))
L∈ (a ∈ A)↓(i, t ) = (a↓(i, t )) ∈ (A↓(i, t ))
L∧ (P ∧ Q )↓(i, t ) = (P ↓(i, t )) ∧ (Q↓(i, t ))
L⇒ (P ⇒ Q )↓(i, t ) = (P ↓(i, t )) ⇒ (Q↓(i, t ))
L∀ (∀ x . P )↓(i, t ) = ∀ x . (P↓(i, t )),	if x is not free in i or in t

It is interesting to notice that the φ identity function on I characterises in its lifted form φ↑ a sort of current interval , which is the interval whose properties are stated by the predicate in which φ↑ occurs.

φ↑↓(i, t ) = φ(i ) = i

We have now the infrastructure necessary to axiomatically define the spe-
cial brackets informally defined in Section 2. The set -	- of all time intervals
|-(-P )-|
i ∈ I such that for each time t ∈ I predicate P is true at t is defined by the
following axiom.
Puu -	- = {i : I | ∀ t : T. (t ∈ i ⇒ (P↓(i, t )))}
|-(-P )-|

The other special brackets can be defined in term of --


-	-	↑-
|-(- )-|
-	-	↑-

Pcu [-P )-| = |-(-P ∧ lcl )-|	Puc |-(-P -] = |-(-P ∧ rcl )-|
-	-	↑-	-	-	↑-
Pou [-P )-| = |-(-P ∧¬ lcl )-|	Puo |-(-P -] = |-(-P ∧¬ lcl )-|

Pcc [-P -] = [-P ∧ rcl↑)-
Poc (-P -] = (-P ∧ rcl↑)-
Pco [-P -) = [-P ∧¬ rcl↑)-
Poo (-P -) = (-P ∧¬ rcl↑)-

Notice that we have used the lifted forms of the lcl and rcl predicate operators within the special brackets. In order to allow nestings of special brackets we need the following axiom.
Pit -	-	-	-
|-(-P )-|↓(i , t ) = |-(-P )-|
Therefore, in case of nesting of special brackets Puu and Pit can be combined
as follows. Let P ( -	-) be a predicate that uses the set of intervals -	-.


-	-	- -
|-(-Q)-|
|-(-Q)-|
-	-

|-(-P (|-(-Q)-|))-| = {i : I | ∀ t : T. (t ∈ i ⇒ (P↓(i, t ))(|-(-Q)-|))}
We can prove this as follows.
-	-	- -
|-(-P (|-(-Q)-|))-|	-	-
= {i : I | ∀ t : T. (t ∈ i ⇒ (P (|-(-Q)-|))↓(i , t ))}	Puu
= {i : I | ∀ t : T. (t ∈ i ⇒ ((P↓(i, t ))( -	- (i , t )))}
|-(-Q)-|↓
L-axioms depending on the structure of P
= {i : I | ∀ t : T. (t ∈ i ⇒ (P↓(i, t ))( -	-)}	Pit


For instance
-	↑	- ↑


↑- -	- ↑	-
|-(-Q)-|

|-(-[0 ... α ] ∈ |-(-α
because
= ω )-|)-| = |-(-α = 0)-|}

(-α↑
= ω↑)- is the set of all intervals consisting of just one point in time;

any interval [0 ... t '], with t ' ∈ T, belongs to such a set if and only if t ' = 0;
therefore the outermost special brackets define all intervals with left end- point equal to 0.
This can be formally proved by applying the given axioms.
-	↑	- ↑	↑- -
|-(-[0 ... α ] ∈ |-(-α = ω )-|)-|	-	-
= {i : I | ∀ t : T. (t ∈ i ⇒ ([0 ... α↑] ∈ |-(-α↑ = ω↑)-|↓(i , t )))}	Puu
= {i : I | ∀ t : T. (t ∈ i ⇒
(([0 ... α↑]↓(i, t )) ∈ ( - α↑ = ω↑- (i , t ))))}	L∈

|-(-
)-|↓	-	-

= {i : I | ∀ t : T. (t ∈ i ⇒ (([0 ... α↑]↓(i, t )) ∈ |-(-α↑ = ω↑)-|))}	Pit
= {i : I | ∀ t : T. (t ∈ i ⇒ ([0 ... α(i )]	- α↑ = ω↑-))}	Aα

= {i : I | ∀ t : T. (t ∈ i ⇒
∈ |-(-
)-|


([0 ... α(i )] ∈ {i' : I | ∀ t ' : T. (t ' ∈ i ' ⇒
(α↑ = ω↑)↓(i', t '))}))}	Aα
= {i : I | ∀ t : T. (t ∈ i ⇒
([0 ... α(i )] ∈ {i' : I | ∀ t ' : T. (t ' ∈ i ' ⇒
(α↑↓(i', t ') = ω↑↓(i', t ')))}))}	L=
= {i : I | ∀ t : T. (t ∈ i ⇒
([0 ... α(i )] ∈ {i' : I | ∀ t ' : T. (t ' ∈ i ' ⇒
(α(i') = ω(i')))}))}	Aα and Aω
= {i : I | ∀ t : T. (t ∈ i ⇒ ([0 ... α(i )] ∈ {[t' ... t '] | t ' : T}))}
= {i : I | ∀ t : T. (t ∈ i ⇒ α(i ) = 0)}
= {i : I | α(i ) = 0}
= {i : I | ∀ t : T. t ∈ i ⇒ α(i ) = 0)}
= {i : I | ∀ t : T. (t ∈ i ⇒ α↑↓(i, t ) = 0)}	Aα
= |-- α↑ = 0)-	Puu
The meaning of lifted predicates within the special brackets is now clear. However we need to define the meaning of predicates at the top level. We introduce other special brackets, ⟨| |⟩ to enclose the top level predicate.
Ptt ⟨|P |⟩ = ∀ i : I. ∀ t : T. (t ∈ i ⇒ (P↓(i, t ))),
with i , t not free in P
When writing a specification on paper we can assume any top level predicate is implicitly enclosed between ⟨| and |⟩. However, in a theorem prover we need to explicitly indicate ⟨| and |⟩. Anyway ⟨| and |⟩ may also appear in a subformula rather than just at the top level. We will see such an example in Section 7.
Since TIC is an interval calculus, lifting a function defined on intervals is more critical than lifting a function defined just on times. When performing proofs we would like to extend properties of intervals to subintervals. How- ever, if the interval is defined through the special brackets from a predicate P that contains lifted forms of functions defined on intervals, P might not be true on the subinterval we are interested in. In order to extend properties to subintervals, which is a very powerful proving mechanism, we introduce another form of special bracket that instantiates all lifted forms of functions defined on intervals.
Pii ⟨⟨P ⟩⟩ = ∀ i : I. (P↓Ii ),	with i not free in P
Implementation in Ergo
Ergo is a term rewriting theorem prover designed and implemented at the Software Verification Research Centre at the University of Queensland. It is based on the window inference [11,8] proof paradigm.




,	v	✏
Standard Theories
✒	✑
/	❅
/	❅
/s	,❅❘  ✏
)























Fig. 1. Theory graph for TIC

In this work we use Ergo 4 [14,1]. The architecture of Ergo 4 consists of the proof engine, which is the core of Ergo, the theory database, which is Ergo’s repository of information containing object logics, and the tactics that implement the command-line interface and a higher level Ergo-Emacs interface [9]. Tactics are user-writable and support the construction of the theory database and control the proof engine. They are written using the Qu- Prolog language [10], a high level extension of Prolog that includes features such as user defined quantifiers.
An Ergo theory is a collection of declarations, axioms, tactics and heuris- tics. Theories can inherit other theories, thus forming a theory graph. The theory graph for TIC is sketched in Figure 1. An oval represents a subgraph of theories while a rectangle represents a single theory that is a node in the theory graph. The theories in thick boxes have been explicitly added to the theory database to implement TIC. Under the names of such theories we have


indicated the corresponding group of axioms introduced in the previous sec- tions.
The ergo theory is the base theory for the theorem prover. The “Stan- dard Theories” box is a subgraph of theories for arithmetic, predicate calculus, equality, types, sets, etc. The “Reals” box is a subgraph of theories for ax- iomatising the real numbers [12]. The dashed arrow between the time theory and the theories in box “Reals” means that the time abstract theory is in- terpreted into the “Reals” current theories. However, the time theory could also be interpreted into the Naturals or into any other consistent domain. The SPEC theory is the specific application that is modelled in TIC. The lifting theory is not a general one; it contains some general axioms such as ATα defined in Section 5, but also axioms specific to the application. For example, ATv is in lifting only if function v is used in SPEC.
We now analyse some details of the Ergo implementation. Fixed values such as 0, +∞, −∞, etc., lifted forms such as v↑, α↑, ω↑, etc. and new domains such as T, I, T∞, S, S, etc. are declared as constants. For instance
declare top_infty. declare ’alpha^’. declare time. declare cltime. declare intvls.
are declarations for +∞, α↑, T, T∞ and I, respectively. Variables to be bound by a quantifier must be declared as object variables (apart from x, which is an object variable by default).
declare_object_variable i. declare_object_variable t.
Functional and logical operators are declared together with their arity. For instance
declare alpha(_). declare omega(_). declare left_closed(_). declare over_time(_,_). declare over_intvl(_,_).
are declarations for functions α, ω : I → T and predicates lcl, ↓T and ↓I, respectively. The ↓ derived operator is implemented as an abbreviation.
abbreviation over_time(P,[i,t]) === over_time(over_intvl(P,i),t)).
Most of the axioms given in the previous section are easily implemented. For instance, Axiom I5 is implemented as follows.
axiom intvl_5 === all i:intvls all x:time (alpha(i) < x and x < omega(i) => x in i).

The axioms of the predintvls theory are more complex to implement. The special brackets defined in Section 5 are implemented in Ergo as quantifiers.
In fact -	- is a set of intervals obtained by quantifying on all possible intervals
|-(-P )-|
i : I and all possible time points t : T such that if t ∈ i then all occurrences of lifted form in P are instantiated on i and t .
The syntax of an Ergo quantifier definition is as follows.
QUANTIFIER ::= define !!NAME OVL BODY === TERM .

This command defines a quantifier called NAME , denoted by !!NAME . OVL is a list of object variables, BODY is a Prolog variable and TERM can be any legal term of the current theory, provided it has no free object variables or meta-variables except for BODY . Also, all occurrences of BODY in TERM must be within a binding of all object variables in OVL.
Therefore Axiom Puu is expressed in Ergo as the following definition.
define !!puu [i,t] P === set_of i:intvls all t:time
(t in i => (over(P,[i,t]))).
The operator set_of is defined in zfc, which is one of the Standard Theories of Ergo and axiomatises the Zermelo Frænkel Set Theory.
Axioms Ptt and Pii are implemented in Ergo as the following definitions.
define !!ptt [i,t] P === all i:intvls all t:time
(t in i => (over(P,[i,t]))).
define !!pii [i] P === all i:intvls (over_intvl(P,i)).
Theories time, intvls, intvlsets, predintvls and lifting are imple- mented respectively by the files time.thy, intvls.thy, intvlsets.thy, predintvls.thy and lifting.thy with a total of about 1000 lines of code, plus additional code to extend lifting.thy depending on the application do- main.

TIC Laws
Modelling an application in TIC consists of constructing a theory SPEC that models the application. In addition, theory lifting defines all lifted forms that have been used in SPEC and contains the axioms for the propagation of the ↓T and ↓I instantiation operators through the arguments of all functions and functional, relational and slash logical operators used in SPEC. The time abstract theory is interpreted in the appriopriate current theory, which may be extended by imposing additional axioms on time. For example, if time is extended with the axiom

T31 nn(T)


and interpreted into the theory of the real numbers, then the resulting time domain is the set of the non-negative real numbers. We can also restrict I to contain only bounded intervals.
I13 ∀ i ∈ I. −∞ < α(i )
I14 ∀ i ∈ I. ω(i ) < +∞
In the following, we will assume TIC theories extended with the axioms T31, I13 and I14 and the time abstract theory interpreted in the Reals.  that
is time domain T = R+ and the set of intervals I contains only unbounded
intervals.
In order to facilitate the proof, high level laws for TIC may be given in the form of theorems and proved in Ergo. Previous works [5,15] contain many such laws. In this paper we consider only the following five laws.

Law1 ⟨|P ⇒ Q|
-	-	-	-

-	-	⟩⇒ |-(-P )-|⊆ |-(-Q)-|

Law2 |-(-P )-
-	- = -	∧	-

Law3 -	-	-	-	-	-
|-(-P )-|∪ |-(-Q)-|⊆ |-(-P ∨ Q)-|

Law4 ⟨|P |
-	- = -	∧	-

⟩⇒ |-(-Q)-|
|-(-Q
P )-|
-	-	-
-	-	-

Law5 {(n · t ... (n + 1) · t ] | n ∈ N}⊆ |-(-⟨⟨P ⟩⟩)-|⇔ |-(-α↑ > 0)-|⊆ |-(-⟨⟨P ⟩⟩)-|
The proofs of these laws are performed using the theories that implement TIC and some “Standard Theories” such as zfc, the Zermelo Frænkel Set Theory, cprop, the Classical Propositional Logic Theory and cpred, the Classical First Order Logic Theory.
Law1 defines the monotonicity of -- on predicates: more restrictive pred-
|-(- )-|
icates define smaller sets of intervals. Notice that P ⇒ Q needs to be enclosed
between ⟨| and |⟩ in order to instantiate all lifted functions on all possible time intervals and points in time
⟨|P ⇒ Q |⟩
= ∀ i : I. ∀ t : T. (t ∈ i ⇒ ((P ⇒ Q )↓(i, t )))	Ptt
= ∀ i : I. ∀ t : T. (t ∈ i ⇒
((P↓(i, t )) ⇒ (Q↓(i, t ))))	L⇒
⇒ ∀ i : -	-	t : T. (t ∈ i ⇒
|-(-P )-|. ∀
((P↓(i, t )) ⇒ (Q↓(i, t ))))	in theory zfc
Moreover, from Puu, again using theory zfc, we have
∀ i : -	-	t : T. (t ∈ i ⇒ (P↓(i, t )))
|-(-P )-|. ∀
The conjunction of these two predicates can be transformed using cprop into the following predicate.

∀ i : -	-
t : T. (t ∈ i ⇒ ((P↓(i, t )) ∧ ((P↓(i, t )) ⇒ (Q↓(i, t )))))

|-(-P )-|. ∀

= ∀ i : -	-	t : T. (t ∈ i ⇒ (Q↓(i, t )))	in theory cprop
|-(-P )-|. ∀-	-
= ∀ i : I. (i ∈ |-(-P )-|⇒ ∀ t : T. (t ∈ i ⇒ (Q↓(i, t ))))	in theory zfc
= ∀ i : I. (i ∈ - P )-	i ∈ |- Q)-)	in theory zfc
|(-	|⇒	(-	|
-	-	-	-	-	-

= |-(-P )-	-	-
in theory zfc

|⊆ |-(-Q)-|
Law2 defines a pleasing relationship between intersection and conjunction.
The proof of Law2 proceeds as follows.
-	-	-	-
|-(-P )-|∩ |-(-Q)-|
= {i : I | ∀ t : T. (t ∈ i ⇒ (P↓(i, t )))}∩ 
{i : I | ∀ t : T. (t ∈ i ⇒ (Q↓(i, t )))}	Puu
= {i : I | (∀ t : T. (t ∈ i ⇒ (P↓(i, t )))) ∧
(∀ t : T. (t ∈ i ⇒ (Q↓(i, t )))}	in theory zfc
= {i : I | (∀ t : T. (t ∈ i ⇒ (P↓(i, t )) ∧
(Q↓(i, t )))}	in theory cpred
= {i : I | ∀ t : T. (t ∈ i ⇒ (P ∧ Q )↓(i, t ))}	L∧
= -	-
|-(-P ∧ Q)-|	Puu
Law3 defines a weaker relationship between union and disjunction. The proof of Law3 proceeds as follows.
-	-	-	-
|-(-P )-|∪ |-(-Q)-|
= {i : I | ∀ t : T. (t ∈ i ⇒ (P↓(i, t )))}∪ 
{i : I | ∀ t : T. (t ∈ i ⇒ (Q↓(i, t )))}	Puu
⊆ {i : I | ∀ t : T. (t ∈ i ⇒ (P↓(i, t )) ∨ (Q↓(i, t )))}∪ 
{i : I | ∀ t : T. (t ∈ i ⇒ (P↓(i, t )) ∨ (Q↓(i, t )))}	in theory zfc
= {i : I | ∀ t : T. (t ∈ i ⇒ (P↓(i, t )) ∨ (Q↓(i, t )))}	in theory zfc
= {i : I | ∀ t : T. (t ∈ i ⇒ (P ∨ Q )↓(i, t ))}	L∨
= -	-
|-(-P ∨ Q)-|	Puu
The relationship between union and disjunction is weaker than the relationship between intersection and conjunction because we can distribute the universal quantification on the conjunction of predicates, but not on the disjunction of predicates. In fact, if the disjunction of two predicates is true on an interval, it is not necessary that one of the two predicates is true on the whole interval. Law4 allows the insertion of a predicate that is true everywhere (i.e. at all points in time) within the special brackets as a conjunction. Let us suppose
that ⟨|P |⟩ is true.
-	-

|-(-Q)-|
= {i : I | ∀ t : T. (t ∈ i ⇒ Q↓(i, t ))}	Puu
= {i : I | ∀ t : T. (t ∈ i ⇒ (Q↓(i, t )) ∧ ⟨|P |⟩)}	since ⟨|P |⟩ is true


= {i : I | ∀ t : T. (t ∈ i ⇒
(Q↓(i, t )) ∧ ∀ i ' : I. ∀ t ' : T. P↓(i', t '))}	Ptt
= {i : I | ∀ t : T. (t ∈ i ⇒
(Q↓(i, t )) ∧ (P↓(i, t )))}	in theory zfc
= {i : I | ∀ t : T. (t ∈ i ⇒ ((Q ∧ P )↓(i, t )))}	L∧
= -	-
|-(-Q ∨ P )-|	Puu
Law5 defines an induction law. It allows a property that holds on all consecutive intervals of a fixed length to be assumed everywhere. The proof of Law5 is the following.

{(n · t ... (n + 1) · t ] | n ∈ N}⊆ |- ⟨⟨P ⟩⟩-

-(-
⇔ ∀ n ∈ N. (n · t ... (n + 1) · t ]
)-|
- ⟨⟨P ⟩⟩-
in theory zfc

∈ |-(-	)-|
⇔ ∀ n ∈ N. (n · t ... (n + 1) · t ] ∈ {i ∈ I | ∀ t ' : T.
t ' ∈ i ⇒ ⟨⟨P ⟩⟩↓(i , t ')}	Puu
⇔ ∀ n ∈ N. ∀ t ' : T. t ' ∈ (n · t ... (n + 1) · t ] ⇒
⟨⟨P ⟩⟩↓((n · t ... (n + 1) · t ], t ')	in theory zfc
⇔ ∀ n ∈ N. ∀ t ' : T. t ' ∈ (n · t ... (n + 1) · t ] ⇒
(∀ i ' : I. P↓Ii ')↓((n · t ... (n + 1) · t ], t ')	Pii
⇔ ∀ n ∈ N. ∀ t ' : T. t ' ∈ (n · t ... (n + 1) · t ] ⇒
(∀ i ' : I. P↓Ii ')↓I(n · t ... (n + 1) · t ]↓Tt '	LD↓
⇔ ∀ n ∈ N. ∀ t ' : T. t ' ∈ (n · t ... (n + 1) · t ] ⇒
(∀ i ' : I. (P↓Ii '↓I(n · t ... (n + 1) · t ]))↓Tt '	LI∀
⇔ ∀ n ∈ N. ∀ t ' : T. t ' ∈ (n · t ... (n + 1) · t ] ⇒
(∀ i ' : I. P↓Ii ')↓Tt '	LDI
⇔ ∀ t ' : T. 0 < t ' ⇒ (∀ i : I. P↓Ii ')↓Tt '	in theory zfc
⇔ ∀ i : I. 0 < α(i ) ⇒ (∀ t ' : T. t ' ∈ i ⇒ (∀ i ' : I. P↓Ii ')↓Tt ')
⇔ ∀ i : I. i ∈ {j : I | 0 < α(j )}⇒ 
i ∈ {j : I | (∀ t ' : T. t ' ∈ j ⇒ (∀ i ' : I. P↓Ii ')↓Tt ')}
in theory zfc
⇔ ∀ i : I. i ∈ {j : I | ∀ t : T. t ∈ j ⇒ 0 < α(j )}⇒ 
i ∈ {j : I | (∀ t ' : T. t ' ∈ j ⇒ (∀ i ' : I. P↓Ii ')↓Tt ')}
in theory zfc
⇔ ∀ i : I. i ∈ {j : I | ∀ t : T. t ∈ j ⇒ 0 < α↑↓(j , t )}⇒ 
i ∈ {j : I | (∀ t ' : T. t ' ∈ j ⇒ (∀ i ' : I. P↓Ii ')↓Tt ')}
Aα
⇔ ∀ i : I. i ∈ {j : I | ∀ t : T. t ∈ j ⇒ 0↓(j , t ) < α↑↓(j , t )}⇒ 
i ∈ {j : I | (∀ t ' : T. t ' ∈ j ⇒ (∀ i ' : I. P↓Ii ')↓Tt ')}
A0

⇔ ∀ i : I. i ∈ {j : I | ∀ t : T. t ∈ j ⇒ (0 < α↑)↓(j , t )}⇒ 
i ∈ {j : I | (∀ t ' : T. t ' ∈ j ⇒ (∀ i ' : I. P↓Ii ')↓Tt ')}
L<
⇔ ∀ i : I. i ∈ --	< α↑)-
|(-0
i ∈ {j : I | (∀ t ' : T. t ' ∈ j ⇒ (∀ i ' : I. P↓Ii ')↓Tt ')}
L<
⇔ ∀ i : I. i ∈ --	< α↑)-
|(-0
i ∈ {j : I | (∀ t ' : T. t ' ∈ j ⇒ (∀ i ' : I. P↓Ii '↓Ij )↓Tt ')}
LDI
⇔ ∀ i : I. i ∈ --	< α↑)-
|(-0
i ∈ {j : I | (∀ t ' : T. t ' ∈ j ⇒ (∀ i ' : I. P↓Ii ')↓Ij ↓Tt ')}
LI∀
⇔ ∀ i : I. i ∈ --	< α↑)-
|(-0
i ∈ {j : I | (∀ t ' : T. t ' ∈ j ⇒ ⟨⟨P ⟩⟩↓Ij ↓Tt ')}
Pii
⇔ ∀ i : I. i ∈ --	< α↑)-	i ∈ {j : I | (∀ t ' : T. t ' ∈ j ⇒ ⟨⟨P ⟩⟩↓(j , t ')}
|(-0
LD↓

⇔ ∀ i : I. i
-	< α↑ -
i	- ⟨⟨P ⟩⟩-
Puu

-	∈ |-(-0	)-|⇒ 
∈ |-(-	)-|

⇔ |(-0 < α↑-	- ⟨⟨P ⟩⟩-
in theory zfc

-	)-|⊆ |-(-	)-|
⇔ |-(-α↑ > -	- ⟨⟨P ⟩⟩-
0)-|⊆ |-(-	)-|

Example
Let us consider a system consisting of an object and a measurement device. The object is moving at a speed whose magnitude never exceeds a constant value V (see Figure 2(a)).
MaxSpeed ⟨| | (ddr /dt )↑ | ≤ V |⟩

where dr : T → R+ defines the distance between the object and the measure- ment device and ddr /dt is the first derivative of the distance with respect to
time, that is the speed of the object.
The requirement of the system is that the device must be able to measure the object’s distance with an accuracy of E (see Figure 2(b)).


Requirement
- α↑ >  -
- s↑ ∈ [dr ↑ − E ... dr ↑	-

|-(-
0)-|⊆ |-(-d
+ E ])-|

where ds : T → R+ defines the distance displayed by the device. At any time after the initial time 0 the measured distance ds must approximate the actual distance dr with an error not greater than E , that is ds = dr ± E .
In a proposal design of the system the device samples the object’s distance




Time
Maximum rate of change

Time
Acceptable error margins

E






0	∆	2∆
3∆	4∆	5∆
6∆	7∆
8∆	9∆
10∆
Time

Periodically sampled measurements
Fig. 2. Parameters of the distance measurement device.


every ∆ time units (see Figure 2(c)).
Design {(n · ∆ ... (n + 1) · ∆] | n ∈ N}⊆ |--

s ↑ = dr (α -

The device samples the distance at times 0, ∆, 2 · ∆, ..., n · ∆, ... and, for every interval (n · ∆ ... (n + 1) · ∆], at each time t in such an interval the displayed distance ds (t ) is equal to the actual distance at the left endpoint of the interval dr (n · ∆).
In order to prove that the design meets the requirement it is necessary to axiomatise the algebraic domains underlying our application. In our example we make use of the domain R+ of the non-negative real numbers to describe




,	v	✏
Standard Theories
✒	✑
/	❅





















Fig. 3. User’s view of the theory graph

the spatial distance, extended with the notion of first derivative with respect to time. This axiomatisation is represented in Figure 3 by the oval block “Application Domain axiomatisation”, which makes use of both the time theory and the “Reals” theory graph. Analogously to what has been done for the “TIC axiomatisation” we can define the theory of “Application Domain Laws”, whose laws are more high level than the axioms in the underlying theory graph. In our proof we are going to use the following application domain law.

LawD1 ⟨| | (ddr /dt )↑ |≤ V ⇒| dr ↑ − dr (α↑) |≤ V (ω↑ − α↑)|⟩

This law ensures that for each time interval i , if the magnitude of the first derivative of the distance dr is not greater than constant V , then the value of









dr (t )
dr (α(i ))


α(i )
t	ω(i )
Time



Fig. 4. Bounded rate of change
the dr distance at any time t within the interval is below the line
y = V · t + dr (α(i )) − α(i ) as shown in Figure 4.
The verification of the requirement is carried out by performing the fol- lowing proof.
{(n · ∆ ... (n + 1) · ∆] | n ∈ N}
-	↑	↑ -
⊆ |-(-ds = dr (α ))-|	Design
-	↑	-
= |-(-ds ↑ = dr (α↑) ∧| (ddr /dt )  |≤ V )-|	Maxspeed and Law4
-	↑	↑	↑	↑	↑	↑ -
⊆ |-(-ds = dr (α ) ∧| dr − dr (α ) |≤ V · (ω − α ))-|
LawD1 and Law1
⊆ |-- ds ↑ = dr (α↑) ∧| dr ↑ − dr (α↑) |≤ V · ∆)-
(-	-|
since ∀ n ∈ N. (ω − α)((n · ∆ ... (n + 1) · ∆]) = ∆
-	↑	↑	↑	↑	↑	-
= |-(-ds = dr (α ) ∧ dr (α ) ∈ [dr − V · ∆ ... dr + V · ∆])-|
-	↑	↑	↑	↑	-
-(-ds = dr (α↑) ∧ ds  ∈ [dr − V · ∆ ... dr + V · ∆])
⊆ |-- ds ↑ ∈ [dr ↑ − V · ∆ ... dr ↑ + V · ∆])-	Law1
(-	-|
Then:
-	-

|-(-α↑ > 0)-|
(-ds ↑
-	↑
∈ [dr ↑
— V · ∆ ... dr ↑
+ V · ∆])-	Law5
-

⊆ |-(-ds
∈ [dr ↑ − E ... dr ↑ + E ])-|	Law1 and V · ∆ ≤ E

the final step tell us the essential relationship between the worst case rate of change V , the acceptable error E , and the sampling period ∆.
We can notice that the proof is performed with no recourse to the axioms used to define TIC. Only TIC Laws and Application Domain Laws, such as

LawD1 are applied in the proof, together with some simple properties of the real numbers. Therefore, a user can perform proofs using only TIC Laws, without any knowledge about the axioms used to implement TIC. Any change to the axiomatisation would be transparent to the user, provided the laws are still valid.

Conclusion
We have provided an axiomatisation for the Timed Interval Calculus. The axiomatisation is based on a general notion of time domain, which captures all the minimal properies that a time domain has to meet [3]. It has been implemented in the Ergo theorem prover and has allowed the machine-assisted proof of many laws, such as those presented in Section 7, for reasoning about predicates expressed using TIC’s special brackets. The proof of some of these laws was actually too complex to be performed in detail without tool support. We are currently using the implementation of TIC in Ergo to prove some of the applications that have been previously verified by hand [2,15].

Acknowledgements
I would like to thank Tony Cant, Colin Fidge, Ian Hayes, Brendan Mahony and Luke Wildman for helpful discussions. Colin also suggested the example used in this paper and reviewed a draft of this paper providing many useful comments. This research has been supported by the Information Technol- ogy Division of the Defence Science & Technology Organisation, and by a University of Queensland ECR grant.

References
H. Becht, A. Bloesch, R. Nickson, and M. Utting. Ergo 4.1 reference manual. Technical Report 96-31, Software Verification Research Centre, School of Information Technology, The University of Queensland, Brisbane, Australia, Nov 1996.
A. Cerone. Process algebra versus axiomatic specification of a real-time protocol. In Algebraic Metodology and Software Technology (AMAST’00), volume 1816 of Lecture Notes in Computer Science, pages 57–72. Springer- Verlag, 2000.
A. Cerone and A. Maggiolo-Schettini. Time-based expressivity of time Petri nets for system specification. Theoretical Computer Science, 216(1–2):1–53, March 1999.
C. J. Fidge, I. J. Hayes, B. P. Mahony, and A. K. Wabenhorst. Real-time specification and reasoning using maximal intervals. In Proc. of the 6th Annual


Australasian Conference on Parallel and Real-Time Systems (PART’99), pages 344–354, Singapore, 1999. Springer-Verlag.
C. J. Fidge, I. J. Hayes, A. P. Martin, and A. K. Wabenhorst. A set-theoretic model for real-time specification and reasoning. In Mathematics of Program Construction (MPC’98), volume 1422 of Lecture Notes in Computer Science, pages 188–206. Springer-Verlag, 1998.
B. P. Mahony and I. J. Hayes. A case-study in timed refinement: A mine pump.
IEEE Transactions on Software Engineering, 18(9):817–826, Sep 1992.
A. Martin and C. Fidge. Lifting in Z. In Computing: The Australasian Theory Symposium (CATS’01), volume 42 of Electronic Notes in Theoretical Computer Science. Elsevier, 2001.
R. Nickson and I. Hayes. Supporting context in program refinement. Science of Computer Programming, 29(1):279–302, 1997.
R. Nickson and M. Utting. A new face for Ergo: Adding a user interface to programmable theorem prover. Technical Report 95-42, Software Verification Research Centre, School of Information Technology, The University of Queensland, Brisbane, Australia, 1995.
P. Robinson and A. Cheng. Qu-Prolog 3.2 refeence manual. Technical Report 93-18, Software Verification Research Centre, School of Information Technology, The University of Queensland, Brisbane, Australia, 1993.
P. J. Robinson and J. Staples. Formalizing a hierarchical structure of practical mathematical reasoning. J. Logic Computat., 3(1):47–61, 1993.
J. Shield, I. Hayes, and D. Carrington. Using theory interpretation to mechanise the reals in a theorem prover. In Computing: The Australasian Theory Symposium (CATS’01), volume 42 of Electronic Notes in Theoretical Computer Science. Elsevier, 2001.
J. U. Skakkebæk. A Verification Assistent for Real-Time Logic. PhD thesis, Department of Computer Science, Technical University of Denmark, NOV 1994.
M. Utting and K. Whitwell. Ergo user manual. Technical Report 93-19, Software Verification Research Centre, School of Information Technology, The University of Queensland, Brisbane, Australia, Feb 1994.
A. Wabenhorst. Induction in the timed interval calculus. Technical Report 99- 36, Software Verification Research Centre, School of Information Technology, The University of Queensland, Brisbane, Australia, Dec. 1999.
