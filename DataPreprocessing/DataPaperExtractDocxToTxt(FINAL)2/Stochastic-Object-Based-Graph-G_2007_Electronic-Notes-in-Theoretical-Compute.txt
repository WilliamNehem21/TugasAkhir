	Electronic Notes in Theoretical Computer Science 184 (2007) 151–170	
www.elsevier.com/locate/entcs

Stochastic Object-Based Graph Grammars
Odorico M. Mendizabal,1	Fernando L. Dotti,
Pontif´ıcia Universidade Cato´lica do Rio Grande do Sul, Porto Alegre - Brazil Email: {omendizabal, fldotti}@inf.pucrs.br
Leila Ribeiro2
Universidade Federal do Rio Grande do Sul, Porto Alegre - Brazil Email: leila@inf.ufrgs.br

Abstract
Object-Based Graph Grammar (OBGG) is a formal visual language suited to the specification of asynchron- ous distributed systems based on message passing. Model-checking of OBGG models is currently supported and a series of case studies have been developed. However, in many situations one has to evaluate non- functional aspects like availability and performance of the system under consideration. In such cases, a stochastic analysis of the system is desired. This paper is a first contribution to the stochastic analysis of OBGG models. OBGG models with occurrence rates associated to rules are translated to Stochastic Auto- mata Networks (SAN). SAN is a Markov Chain equivalent formalism having as advantage its modularity in terms of representation and a compact mathematical solution, allowing the analysis of models with larger state space.
Keywords: Object-based graph grammar, asynchronous system, Stochastics Automata Network


Introduction
A very important aspect during the development of a complex system is the ability to asses both functional and non-functional properties about the system as early as possible. This ability often leads to important savings, as well as to enhancements in the quality of the resulting system.
The development of distributed systems is known as a difficult task. Besides dealing with the inherent complexity of concurrent systems, the developer also has to take distribution aspects into account. In such cases, communication latencies and availability of nodes and services, among others, become important aspects to consider which may lead to the success or not of the application.

1 Author partially sponsored by HP-Brasil/PUCRS agreement.
2 Author partially sponsored by CNPq, project PLATUS

1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2007.03.020

Object Based Graph Grammars (OBGG)[5] is a graphical formal specification language suitable for the specification of asynchronous distributed systems. Mod- els defined with this formalism can be analyzed using verification (through model checking) [4,12].
Although model-checking is an important analysis method, in many situations one has to evaluate, as early as possible during the development, non-functional as- pects like availability and performance of the system under consideration. Moreover, in many classes of applications it is not possible to assure certain properties. In such cases it is important to be able to associate probabilities to satisfaction or not of the property under reasoning.
Stochastic processes allows one to model the interaction of distinct phenomena, each described by a different probability distribution. Among various stochastic pro- cesses, Markov Chains [13] have been extensively investigated and used in computer sciences and engineering. Markov Chains are discrete state stochastic processes that can be continuous or discrete time, and have the memoryless property. This prop- erty assures that the transition to the next state depends only on the current state of the system and not on the previous ones. The use of exponential and geometric probability distributions associated to the transitions assures the memoryless prop- erty for continuous and discrete time Markov Chains, respectively. The solution of a Markov Chain results in the probability of each state of the chain, considering the steady state situation.
Since Markov Chains are transition systems labeled with probability distribu- tions on transitions, they have been used as underlying model for various methods. This is the case for Stochastic Petri Nets (SPN), where the reachability graph of the net is the transition system which is annotated with the probability distributions of the associated transitions [1]. Similarly for Stochastic Process calculi, where the transition system is described by some process calculus, like for instance the π-calculus [11].
In [7] a first step towards the stochastic analysis of graph transformation sys- tems is given. In that contribution, the authors associate (exponential) probability distributions to rules. With this, the transition system obtained from the graph grammar gives raise to a Continuous Time Markov Chain that can be analyzed with existing tools.
In this paper we propose an approach for the stochastic analysis of OBGG models. OBGG is a restricted form of graph grammar and therefore the results of
[7] apply to OBGG as well. However, due to the state-space explosion problem, we avoid using Markov Chains and prefer an equivalent method with better scalability. Stochastic Automata Networks (SAN) [10] is a Markov Chain equivalent formalism having as advantage its modularity in terms of representation and the compact mathematical solution, allowing the analysis of models with larger state space, if compared to Markov Chains [6]. Once a model is represented in SAN, it is possible derive the probabilities associated to the states of interest using the PEPS tool (Performance Evaluation of Parallel Systems) [9].
The main contributions of this paper are: (i) the proposal of a stochastic exten-

sion to OBGG; and (ii) the translation of the extended OBGG to SAN, leading to a stochastic semantics of OBGGs.
The paper is organized as follows: the next section presents OBGG and the running example - the model of a token ring network. Section 3 presents the main characteristics of SAN. The extension of OBGG is proposed in Section 4. The translation from OBGG to SAN is discussed in Section 5. Section 6 analyzes the example and final remarks are in Section 7.

Object-Based Graph Grammars
In this paper, we consider object-based systems with the following characteristics:
a system is composed by many objects. The state of each object is defined by its attributes, that may be elements of abstract data types or references to other objects. One object can not read nor modify the attributes of other objects;
objects are instances of classes, that contain the specifications of the attributes and behavior of the objects belonging to that class;
objects are autonomous entities that communicate through asynchronous message passing.
The specification of an object-based system is done via an (object-based) graph grammar. We will present the kind of graphs and rules that will be used for the specification of object-based systems. These graphs are called object-based graphs and were introduced in [5].
Each graph in an object-based graph grammar may be composed by instances of the vertices and edges shown in Figure 1(a). The vertices represent classes and abstract data types, whereas messages and attributes of classes are modeled as hyperedges (edges with one destination and many source vertices). We defined a distinguished graphical representation for these graphs to increase the readability of the specifications. This representation is shown in Figure 1(b). Elements of abstract data types are allowed as attributes of classes and/or parameters of messages. Note that the graph in Figure 1 defines only a scheme of the kinds of vertices and edges that may occur in a specification, and does not oblige entities or messages to have attributes. For example, this graph specifies that, if a class has attributes, they must be either of type ADT or of type Class.
A rule will express the reaction of an object to the receipt of a message. A rule of an object-based graph grammar consists of:
a left-hand side L: describes the items that must be present in the current state to enable the application of the rule. The restrictions imposed to left-hand sides of rules are:
There must be exactly one message vertex, called trigger message (this is the message treated by this rule).
Only attributes of the object that is the target of the trigger message may appear.
Items of type ADT may be variables, that will be instantiated at the time of


 
(a)	(b)


Figure 1. (a) Object-Based Graph Scheme (b) Graphical Representation of Object-Based Graphs

rule application. Operations defined in the ADTs may be used.
a right-hand side R: describes the items that will be present after the application of the rule. It consists of:
Objects: all objects and attributes present in the left-hand side of the rule, as well as new objects (created by the application of the rule). The values of attributes may change, but attributes can not be deleted;
Messages to all objects appearing in R.
a condition: that must be satisfied for the rule to be applied. This condition is an equation over the attributes of left- and right-hand sides.
Formally, we use typed attributed hypergraphs and rule is a (partial) graph homomorphism with application conditions. The formal definitions are presented in Section 4.
Now we can define an object-based system. It is composed of:
a Type Graph: a graph containing information about all attributes of all classes involved in this system (an attribute may be either of ADT types or a reference to other class) and messages sent/received by each kind of object. This graph can be seen an instantiation of the object-based graph scheme described above.
a set of Rules: these rules specify how the objects behave when receiving messages. For the same kind of message, there may be many rules specifying the intended behavior. Depending on the conditions imposed by these rules (on the values of attributes and/or parameters of the message), they may be mutually exclusive or not. In the latter case, one of them will be chosen non-deterministically to be executed. Note that the behavior of an object when receiving a message is not specified as a series of steps that shall be executed, but rather as an atomic change of the values of the object attributes together with the possible creation of new messages to other (or the same) objects. That is, there is no control structure to govern the application of the rules that specify the behavior of an entity. Our approach is data driven. This has the advantage that unnecessary sequentializations of computation steps are avoided because the specifier only has to care about the causal dependencies between events.
an Initial Graph: this graph specifies the initial values of attributes of the objects, as well as messages that must be sent to these objects when they are created.

The messages in this graph can be seen as triggers of the execution of the object.
The behavior of an OBGG is given by the state transition system generated by applying rules of the grammar starting in the initial state.
Example: The Token-Ring Protocol
In this section we exemplify the use of OBGG. The token-ring protocol is relatively simple, allowing the rapid understanding by the reader as well as the exemplification of the translation process in Section 5.
The token-ring protocol is used to control the access of various stations to the shared transmission medium in a ring topology network [14]. According to the protocol, a special bit pattern, called token, is transmitted from station to station in only one direction. When a station wants to send some content through the network, it awaits for the token, holding it, and sends the message on the ring. The frame circulates the ring and the destination station may copy its contents. When the frame completes the cycle, it is received by the originating station. The originating station then removes the frame from the ring and sends the token to the next station, which then may act as already described. Having only one token, only one station may be transmitting in a given time.
Figure 2(a) is a Type Graph and defines the type Node. Instances of Node have one boolean attribute called sent and may receive two kinds of messages: Msg meaning a frame of data and Token meaning the token. The link to the next Node is given by the object reference next 3 .

(a)	(b)
Figure 2. (a) Type Graph for Node and (b) Initial Graph for the Token Ring model.
The rules that define the behavior of this model are presented in Figure 3.
If a Node receives the token it may send a Msg (rule Send ) or pass the Token (rule Token Pass). If the Node decides to send a Msg, the attribute sent is assigned to true.
When a Msg is received by a Node and it is the originating Node (if its attribute
sent is true) then rule Complete is applied, removing Msg from the ring and gen-

3 Graphical notation: in Figure 2(a) rectangles are vertices and numbers inside circles are the names of these vertices (those symbols are used to indicate the type of each vertex in Figures 2(b) and 3). The items within a vertex are the vertex attributes. Message symbols that appear in Figures 2(a) and 3 are hyperarcs.

erating the Token to the ( next) Node. If the receiving Node is not the originating one (its attribute sent is false) then rule Transmit is applied and Msg is passed to the next Node.





Figure 3. Rules of class Node.


The Initial Graph is shown in Figure 2(b), defining the various instances, attrib- utes and messages of the start situation. A ring with four nodes is defined, called Node1, Node2, Node3 and Node4. The attribute next of each instance refers to the next Node. All sent attributes are initially false and only one Node (Node1 ) has the token. This model is finite-state and generates infinite computations, allowing the steady-state analysis of the generated SAN model.

Stochastic Automata Networks
In the Stochastic Automata Network (SAN) formalism, a system is modeled by interacting subsystems which, in turn, are represented by automata that may behave independently or may have dependencies. According to [13,2], SAN has exactly the same application scope as Markov Chains, with the advantage that models are constructed componentwise and the mathematical solution is optimized in terms of state space [10]. SAN models can be discrete-time or continuous-time. In this paper we focus on the continuous-time case. Here we will use a less general definition of SANs, since we do not need all features of this formalism to describe a sthocastic extension of OBGGs.
An automaton is composed by states and transitions labeled with event names. A SAN model is composed by various automata. These automata may evolve inde- pendently with local events (that may affect only the local state of the automata participating in this event), whereas synchronizing events are used to model joint evolution of two or more automata. With the association of distribution probab- ilities to the events, the labeled transition system generated by a SAN gives raise to a Markov Chain and it is possible to calculate the steady state probability of each state of a SAN. More concretely, to each event there is an occurrence rate associated. The inverse of the occurrence rate is the mean value of the exponential distribution function that regulates the time interval between two occurrences of the event.
Definition 3.1 (Automata) An automaton is a tuple A = (S, T, E, i) where S is a finite set of states, E is a finite set of events, T ⊆ S ×2E ×S is the transition relation and i ∈ S is the initial state. Given an automaton A, we denote its components by SA, TA, EA and iA. Given a state s ∈ S, we denote the set of events that may occur by outputEvents(s) = {e|∃(s, ES, s') ∈ T and e ∈ ES}, and the set of reachable states given an event by outputStates(s, e)= {s'|∃(s, ES, s') ∈ T and e ∈ ES}.
Definition 3.2 (Stochastic Automata Network (SAN)) A stochastic auto- mata network (SAN) is a tuple SAN = (SE, AL, τ ) where SE is a finite set of events, called synchronizing events, AL is a list of automata and τ : E → R+ is the rate function, with E = SE ∪ i∈{1..|AL|}(EAi − SE). A state of a SAN is a tuple s = (s1,... , s|AL|), where si ∈ SAi.
A SAN defines the set of events that are used to synchronize the different auto- mata during the execution. The state changes of SANs are possible when all different automata that may engage in some event are in some state in which a transition labeled with this event is possible. Note that, since there may be different trans- itions labeled with the same event, there may be different reachable state starting with the same state and executing the same event.
Definition 3.3 (Enabled event,  State change) Given a SAN SAN  = (SE, AL, τ ) with |AL| = n and a state s = (s1,... , sn), we say that event e is enabled in s if

6i ∈ {1..n}.e ∈ outputEvent(si) or e /∈ EAi; and
τ (e) /= 0.
If an event e  is enabled in state s	=	(s1,... , sn),	a state	change
may	occur,	leading	to	a	state	s'	=	(s' ,... , s' )	where	s'	=
1	n	i
⎨ x, if x ∈ outputState(si, e) and e ∈ outputEvent(si),
⎩ si, otherwise
Figure 4 depicts an illustrative SAN example. There are two automata rep- resented, Aut1 and Aut2. Their initial states are st1 and st2 (states showed by gray circles), respectively. Synchronized events are specified by sync1 and sync2, whereas the local ones are specified by loc1 and loc2. Note that sync2 will be active only if Aut1 is in st2 and Aut2 is in st1 or st2. The local events are independent of the other automata, e.g. loc1 will be active when Aut1 is in st1, independently of the Aut2 state.
Aut1	Aut2








sync2
sync2







Figure 4. SAN example.



Stochastic Object-Based Graph Grammars
In this section we will define stochastic object-based graph grammars. In a graph grammar, state changes are modeled by rules. Associating occurrence rates to rules (as done for events in SAN and for transitions in SPN, for instance) it is possible to obtain a transition system semantics where each state of the system will have a probability associated, which is the probability of the system being in that state in a steady state situation (i.e. the transition system semantics gives raise to a Continuous Time Markov Chain).
Such information is very useful in the analysis of a concurrent system, and com- plementary to an analysis based on model checking. Some non-functional aspects can be evaluated through stochastic formalisms, such as performance and depend- ability. So, these information are useful to guide the developer to adjust bounds for specific requirements in complex systems.

In the following, we extend the definitions of Object-Based Graph Grammars of
[5] to associate occurrence rates to rules. It is assumed that the reader is familiar with basic notions of algebraic specification.
We shall define stochastic OBGGs, short SOBGGs, over (typed and attributed) hyper graphs, i.e., graphs where edges can be connected to any (finite) number of vertices. Graphically, an edge is depicted as a box (whose shape may vary), and the connections to the vertices are drawn as thin lines, called tentacles. The tentacles of an edge are labeled by natural numbers. The main characteristics of object-based graphs are:
Each object-based graph models a set of objects, in which the internal state of an object (its set of attributes) is described by references to other objects and/or values of pre-defined data types.
Each object has an associated algebra, carrying the values of pre-defined data types that may be used as attributes of objects.
The set of vertices is partitioned into two, modeling object identities and data values, respectively.
The set of (hyper)edges is partitioned into two, modeling messages and attributes of an object, respectively. Each edge has one target (the object that receives the messages/to which the attributes belong) and may have many sources (parameters of the message/attributes of the object).
The definition of OBGGs is based on a category of graphs and partial morphisms.
Definition 4.1 (weak commutativity) Given two partial functions f, f ' : A → B, we say that f is less defined than f ' (and we write f ≤ f ') if dom(f ) ⊆ dom(f ') and f (x) = f '(x) for all x ∈ dom(f ). Given two partial functions f : A → B and f ' : A' → B', and two total functions a : A → A' and b : B → B', we say that the resulting diagram commutes weakly if f ' ◦ a ≤ b ◦ f .
Now we introduce object-based graphs and partial morphisms. As discussed above, each hyperedge has one target vertex, and may have many source vertices. Source vertices are identified by different numbers of the tentacles, that is, a hy- peredge is associated to a list of vertices.
Definition 4.2 (object-based graph, object-based graph morphism) Given an algebraic specification Spec, an object-based graph (OB graph) G = (VG, EG, sG, tG, AG, aG) consists of a set VG of sets of vertices partitioned into sets oVG and aVG (of objects and attributes, respectively), a set EG = (mEG, aEG) of sets of (hyper)edges partitioned into sets mEG and aEG (of messages and attributes, respectively), a total source function sG : EG → V ∗, assigning a list of vertices to each edge, a total target function tG : EG → oVG assigning an object-vertex to each edge, an algebra AG over Spec, and an attribution function aG : aVG → U(AG), assigning to each attribute-vertex a value from a carrier set of AG 4 .

4 U : Alg(SPEC) → Set is the forgetful functor that assigns to each algebra the disjoint union of its carrier sets.

A (partial) OB-graph morphism g : G → H is a tuple (gV , gE, gA), where the first components are partial functions gV = goV ∪ gaV with goV : oV G → oV H and gaV : aV G → aV H and gE = gmE ∪ gaE with gmE : mEG → mEH and gaE : aEG → aEH ; and the third component is a total algebra homomorphism
which are weakly homomorphic, that is g∗ ◦ sG ≥ sH ◦ gE, gV ◦ tG ≥ tH ◦ gE and
U(gA) ◦ aG ≥ aH ◦ gV (if an edge is mapped, the corresponding vertices, if mapped, must have the same sources/target vertex, and if a vertex is mapped, the attributes must be the same). A morphism is called total if both components are total. The category of OB-graphs and partial OB-graph morphisms is denoted by OBGraphP (identities and composition are defined componentwise).

 gE  
_G	_H
 gE  
_G	_H
gV	 


_G	_H

sG	≤
J 
sH	tG	≤
J	J 
tH	aG	≤	aH
J	J	J 

V ∗)
 V ∗
VG 	 V 
U(AG)
 U ( A )

∗	H	gV	H
V
U(gA)	H

To distinguish different kinds of vertices and edges, we will use the notion of typed graphs [3,8]: every graph is equipped with a morphism type to a fixed graph of types 5 . Since the types will constitute the static part of the definition of a class, we will call the graph of types as class graph, and some restrictions will be imposed to guarantee that corresponds to a class in the sense of the object paradigm (the first restriction says that there are no data values in a class graph, they are represented by the name of data types, and the second imposes that each class can have exactly one list of attributes).
Definition 4.3 (typed OB-graphs) Let Spec be a specification. An OB-graph C is called a class graph iff (i) AC is a final algebra over Spec, (ii) for each object vertex v ∈ oVC there is exactly one attribute hyperedge (ae ∈ aEC) with target
v. A typed OB-graph over C is a pair OGC = (OG, typeOG) where OG is an OB-graph called instance graph and typeOG : OG → C is a total OB-graph morphism, called the typing morphism.

A morphism between typed OB-graphs OGC
and OGC
is a partial OB-graph

morphism f : OG1 → OG2 such that typeOG1 ≥ typeOG2 ◦ f . The category of OB- graphs typed over a class graph C, denoted by OBGraphP(C), has OB-graphs over C as objects and morphisms between typed OB-graphs as arrows (identities and composition are the identities and composition of partial OB-graph morphisms).
Rules define how objects react when receiving messages. Each rule expresses how one particular message will be treated (many rules may be necessary to describe all possible reactions to one message).
Definition 4.4 (rule) Let C be a class graph, Spec be a specification and X be a set of variables of sorts of Spec. A rule is a pair (r, Eq) where Eq is a set of equations over the specification Spec and r : L → R is a C-typed OB-graph morphism s.t.

5 Note that, due to the use of partial morphisms, this is not just a comma category construction: the morphism type is total whereas morphisms among graphs are partial, and we need weak commutativity instead of commutativity.

L and R are finite;
a message hyperedge is deleted: ∃!e ∈ mEL, called trigger(r), trigger(r) /∈
dom(rE);
only attributes of the target of the message may appear in L: (aEL = ∅) ∨
((∃!e ∈ aEL) ∧ tL(e)= tL(trigger(r)));
attributes of existing objects may not be deleted nor created: 6o ∈ oVL.(∃e ∈
aEL.tL(e)= o ⇒ ∃e' ∈ aER.tL(e')= rV (o));
objects may not be deleted: 6o ∈ oVL.o ∈ dom(rV );
the algebra of r is a term algebra TSpec'(X) over the specification Spec including a set of equations Eq;
attributes appearing in L may only be variables of X: 6v ∈ (aVL∪aEL).aL(v) ∈
X;
the algebra homomorphism component of r is the identity.
We denote by Rules(C) the set of all rules over a class graph C.
To define a SOBGG, we first define a class graph, modeling the types of objects, messages and attributes that may be present in the system. Then we define the behavior of the system using rules, and the possible initial states (that are graphs containing instances of the types in the class graph).
Definition 4.5 (stochastic object-based graph grammar (SOBGG)) Given a graph of types C. A stochastic object-based graph grammar is a tuple SOBGG = (Spec, X, C,IG, N, n, ρ) where Spec is an algebraic specification, X is a set of variables, C is a class graph, IG is graph typed over C, called the start graph, N is a set of rule names, n : N → Rules(C) assigns a rule to each rule name and ρ : N → R+ assigns a rate to each rule.
The behavior of a SOBGG is obtained by applying the rules successively to a start graph. Each rule application deletes one message (the trigger of the rule) and may change the value of internal attributes, create new messages and/or ob- jects. Formally, the effect of a rule application is obtained by a pushout in the corresponding category (typed object-based graphs).
Definition 4.6 (derivation   step,   derivation)  Let  SOBGG   = (Spec, X, C,IG, N, n, ρ) be an SOBGG, (r : L → R, Eq) ∈ n(N ) be a rule, and IN be a graph typed over C. A match for r in IN is a total morphism
r,m
m : L → IN in OBGraphP(C). A derivation step IN =⇒ OUT using rule
r and match m is a pushout in the category OBGraphP(C).  The morphism
r' : IN → OUT is called derived rule.
A derivation sequence of a SOBGG is a sequence of derivation
ri,mi

	r	 
steps Gi =⇒ Gi+1, i ∈ {0,... , n}, n ∈ N, where G0 = IG

L_	R
m	(PO)	m'
and ri ∈ Rules for all i ∈ {0,... , n}. The class of all de- rivation sequences of an SOBGG is denoted by SDerSOBGG.

J	 J 
IN	'  OUT
The class of all reachable graphs in SDer
r,m
SOBGG
is defined by

r	StateSOBGG = {G | G = IG ∨ IG =⇒ G ∈ SDerSOBGG}

The computations of a SOBGG are exactly the same as the underlying OBGG (grammar without the tax function). The following definition of the behavior se- mantics describes these computations, without considering the stochastic behavior (that will be considered in section 5.2).
Definition 4.7 (SOBGG Behavior Semantics) Given a stochastic Object- Based Graph Grammar SOBGG = (Spec, X, C,IG, N, n, ρ), its behavior semantics BehSem(SOBGG) is defined by the labeled transition system TS = (S, L, q0, →), where:
S = StateSOBGG is the set of states;
L = N is the set of transition labels;
q0 = IG is the initial state;
→ is given by following rule:
nr,m	'
G =⇒ G ∈ SDerSOBGG
nr,m
G
−→ G
Stochastic Semantics of OBGGs
To associate probabilities to the states of the behavior semantics we have to solve the respective stochastic model. To do this, we translate SOBGG to stochastic automata network (SAN), solve the respective SAN, and then finally complete the stochastic semantics of SOBGG.
Translation of OBGGs into SANs
In the translation from SOBGGs to SANs, attributes and messages of SOBGG objects originate SAN automata states and rules are mapped to transitions, events and rates.
The state of each object is associated with a set of automata: one auto- maton for each attribute; one automaton for each object reference; one auto- maton for each type of message that the object may receive. All attributes and messages related to an object are defined by the class graph.  Given a class CG = (VCG, ECG, sCG, tCG, ACG, aCG), the elements of sets oVCG and aVCG rep- resent the types (of objects and data, respectively) that are allowed in the system. The set mECG describes the types of messages of the system, and the set aECG has as components the attribute hyperarcs (that connect each attribute to each object vertex). Elements of mECG may be deleted or created during the execution of the system, whereas the set aECG must be stable (because objects may not loose nor gain attributes).
However, since we are dealing with finite state models, mECG may not grow indefinitely. For each type of message msg ∈ mECG, let max(msg) denote the maximum number of instances of such messages that may exist in some state of an SOBGG. A further restriction is that we do not allow the creation of objects. This latter restriction could be relaxed by allowing a bounded number of objects to be

created, but this is subject to future work.
Based on the class graph and the initial graph of an SOBGG, we will construct the sets of automata states that will be used to build the corresponding SAN. In the following definitions, we will use as attributes of classes and parameters of messages lists of n elements, but note that n may be zero, leading to an empty list. The initial graph will be used to get the information about the data values (defined in the algebra component) and objects that may exist in the system. We will use a function states that, given a vertex, returns the set of values of this type. In case this vertex is the name of a data type, the result is the corresponding carrier set of the algebra. In case it is an object type, it returns the set of vertices of this type (object ids) in the initial graph.
The rules of the graph grammar will give raise to transitions and events of the SAN, and the associated rates will become the rates of the corresponding events.
First, we will define how the event set of the resulting SAN is obtained, and then how each individual automaton is constructed.
Definition 5.1 (translation of rule applications into events) Let SOBGG = (Spec, X,CG, IG, N, n, ρ) be an stochastic object-based graph grammar. We define the set of events E induced by SOBGG, denoted as Events(SOBGG), as
Events(SOBGG)= {e ∈ events(ruleN ame)|6ruleN ame ∈ N }

where events(rn) = {(rn, dr : IN → OUT )|∃ CG-typed graph IN with same algebra as IG, m : L → IN is a surjective match, and dr is the derived rule of the application of n(rn) to m}.
For each event e = (rn, dr) ∈ E, we define message(e) as the message hyperedge deleted by dr, msgType(e) = typeG(message(e)), object(e) = tG(message(e)), ruleName(e)= rn, param(e)= sG(message(e)).
In the instances of a class, an automaton will be created for each attribute, the states of each of these automata represent the values that these attributes may assume, and the transitions describe the possible state changes that were performed by some rule application.
Definition 5.2 (generation  of  attribute  automata)  Let SOBGG  = (Spec, X,CG,IG, N, n, ρ) be an stochastic object-based graph grammar and obj ∈ oVIG be an object identity. The attribute automata generated for obj AutAttrobj is defined as
AutAttrobj = ⟨AutAttr(v1)obj,... , AutAttr(vn)obj⟩
where sIG(ae) = ⟨v1, ..,... , vn⟩, ae is the attribute hyperedge of obj, and each
AutAttr(vi)obj = (Si, Ti, Ei, inii) is an automaton defined as
Si = states(typeIG(vi)),
inii = vi,

the set of transitions Ti is obtained as follows: for each event e = (rn, dr : IN → OUT ) ∈ Events(SOBGG)), if obj = object(e) the attribute vertex ae of obj in IN is deleted by dr and re-created as ae' in OUT , with sIN (ae)= ⟨v1, ..,... , vn⟩,

and sOUT (ae')= ⟨v' , ..,... , v' ⟩, the transition v
{e}
v' is in T .

1	n	i −→ i	i
Ei is the union of the sets of events used as labels of transitions in Ti.
In Figure 5, sent Node1 and next Node1 attribute automata represent the sent and next attributes for the object Node1 of the Token Ring OBGG model according to our translation approach (the initial state of each automata is the gray circle). The names of events used to label transitions are composed of name of applied rule (that gave raise to this event), a list of attribute name and the respective value needed to build the match, and the object that receives the message. Having a rule name and a match uniquely specifies a rule application, that is, an event, and therefore we will not use the derived rule in the graphical representation. The other automata depicted in this figure will be explained along this section.



sent_Node1

Transmit_next_Node2_Node1


false

Send_next_Node2_Node1


Complete_next_Node2_Node1

true

Send_next_Node2_Node1

next_Node1



Node2











Transmit_next_Node2_Node1 Send_next_Node2_Node1 Complete_next_Node2_Node1
Token_Node1

0

Token_Pass_next_Node1_Node4 Complete_next_Node1_Node4
Send_next_Node2_Node1 Token_Pass_next_Node2_Node1

1


Msg_Node1

0


Send_next_Node1_Node4 Transmit_next_Node1_Node4
Complete_next_Node2_Node1 Transmit_next_Node2_Node1

1


Figure 5. Token Ring model translated.

In the generated SAN, there will be an automaton for each kind of message and parameter value that the object may receive, and the states of each of these automata will represent the number of messages of each kind present in the current state of the system. Transitions will model deletion and creation of messages.
Definition 5.3 (generation  of  message  automata)  Let SOBGG  = (Spec, X,CG,IG, N, n, ρ) be an stochastic object-based graph grammar and obj ∈ oVIG be an object identity. The message automata generated for obj AutMsgobj is defined as
AutMsgobj = ((Ai)i∈M Attr )obj

where MAttr = {msg} × states(tv1) × ... × states(tvn), msg ∈ {m ∈ mECG|tCG(m) = class, typeIG(obj) = class} (that is, msg is a message type that may be received by object obj), sCG(msg)= ⟨tv1, ..,... , tvn⟩. Each automata Ai = (Si, Ti, Ei, inii), with i = (msg, v1,... , vn), is defined as follows:
Si = {0..max(msg)},
inii is the number of messages of type msg and parameters ⟨v1, ..,... , vn⟩ present in IG;
the set of transitions Ti is obtained as follows:
events deleting messages of type (msg, v1,... , vn): for each event e = (rn, dr : IN → OUT ) ∈ SE, with msgType(e) = msg, object(e) = obj, parameters param(e)= ⟨v1, ..,... , vn⟩, the following transitions are added to Ti:

{i −e→ i − 1|0 < i ≤ max(msg)}

events creating message of type (msg, v1,... , vn): for each event e = (rn, dr : IN → OUT ) ∈ SE, such that e creates x messages of type (msg, v1,... , vn), the following transitions are added to Ti:

e  i + x|0 < i ≤ max(msg)}

In figure 5, Token Node1 and Msg Node1 are message automata for object Node1, corresponding to messages Token and Msg, respectively. Since these mes- sages do not have parameters, only these message automata will be generated for each object of type Node.
From the initial graph, the initial state of the SAN is derived. This is done by setting the initial state of each automaton of the resulting SAN to represent the attributes, messages and parameters in the initial graph. Using the PEPS tool, this is done by declaring a partial reachability function which defines the initial state of each automaton. For instance, we translate the initial graph depicted in Figure 2(b) into the following partial reachability function:
partial reachability =
(st sent_Node1==false) && (st Token_Node1==1) && (st Msg_Node1==0) && (st sent_Node2==false) && (st Token_Node2==0) && (st Msg_Node2==0) && (st sent_Node3==false) && (st Token_Node3==0) && (st Msg_Node3==0) && (st sent_Node4==false) && (st Token_Node4==0) && (st Msg_Node4==0);


Definition 5.4 (Translation  of  SOBGG  into  SAN) Let SOBGG  = (Spec, X,CG,IG, N, n, ρ) be an stochastic object-based graph grammar. We define the generated SAN SAN = (SE, AL, τ ) inductively as follows:
SE = events(SOBGG);
τ (e)= ρ(rn), where rn = ruleName(e);
AL = (Autobj )obj∈oVIG where Autobj = (AutAttrobj, AutM sgobj), and AutAttrobj is the attribute automaton of obj and AutMsgobj is the message automaton of obj.

Stochastic Semantics of SOBGGs
Now, given a graph typed over a class model graph, that is, a state of an OBGG system, this state can be translated to a set of automata according to the following definition.
Definition 5.5 (translation of OB-graphs to SAN states) Let SOBGG = (Spec, X,CG,IG, N, n, ρ) be an stochastic object-based graph grammar and SAN = (SE, AL, τ ) be the corresponding SAN. Then any reachable state G of SOBGG can be translated to a global state GS as follows:
for all object obj in G:  let ae be the attribute edge of obj and sG(ae) =
⟨v1,... , vn⟩. The state of each attribute automata AutAttr(vi) of obj must be vi.
for all messages msg with parameters ⟨v1,... , vn⟩ in G: let tmsg be the type of message msg in the class graph.	The state of each message automata
AutMsg(tmsg,v1 ,...,vn) must be the number of messages of type tmsg with exactly the same parameter values as msg in graph G.
To define the semantics of a stochastic object-based graph grammar, we just have to translate it to a SAN, solve this SAN, and associate the corresponding probability to each OB-graph.
Definition 5.6 (stochastic  semantics  of  SOBGG) Let SOBGG  = (Spec, X,CG,IG, N, n, ρ) be an stochastic object-based graph grammar and SAN = (SE, AL, τ ) be the corresponding SAN. The stochastic semantics of SOBGG is the transition system stoST = (S, L, q0, →,τ ), where (S, T, q0, →) is the behavior semantics of SOBGG and τ : S → R+ associates a probability to each state s ∈ S by translating this state to a SAN global state and checking the probability of this state.

Model Analysis
This section presents results obtained from the steady state analysis of the Token Ring translated model. We applied the translation steps as stated in Section 5, obtaining a SAN model and evaluated this model with PEPS tool.
A token ring network with four nodes was modeled, having a static topology, i.e. a node does not change its neighbors. Due to the static topology of the example, the automata next Node1 to next Node4, representing the next attribute of the instances are not necessary. Therefore, each node was modeled with three automata. One for the attribute sent and two for the possible input messages. There are two states in each automaton. This results in 12 automata and a product state space of 4096 states. However, considering the initial state as described, only 20 states are reachable.
Assigning rates to the rules of the model and solving the corresponding SAN, we obtain the probability associated to each state of the model. In this example, the rates defined for the rules are illustrative. With the results obtained we can analyze the model with respect to some functional and non-functional requirements. As

example of functional analysis, some scenarios that are not expected in a Token Ring protocol are evaluated. For example:
property 1 : it is impossible that at the same time more than one node receives a token;
property 2 : it is impossible that at the same time more than one node have messages transmitted in the ring;
In order to analyze such cases, we define integration functions with the PEPS tool. An integration function is an expression using the calculated probabilities of the states of the SAN model. For property 1, we observe that the probability of more than one node having Tokens simultaneously is equal to 0.0%. The corresponding integration function is:
more_than_one_token_received =
(nb [Token_Node1 .. Token_Node4] 1) > 1;
In this case, the function nb returns the number of autamata, from Token Node1 to Token Node4 ), simultaneously in state 1. The whole expression returns the probability of more than one node having a token. This probability is 0.0%.
For property 2 the analysis is analogous but we look at the probability of at- tribute sent being true for more then one node. As expected, this probability also is 0.0%. The corresponding integration function is:
more_than_one_token_sent =
(nb [sent_Node1 .. sent_Node4] true) > 1;
Although we can evaluate some functional properties using the probabilities associated to the states, for some properties it is necessary to evaluate the causal dependence of the rule applications. In such cases, model checking OBGG models
[4] is a better choice than solving SOBGG models. On the other hand, in order to evaluate non-functional properties SOBGG is needed.
For the quantitative analysis of the Token Ring model we have analyzed the impact of the rates of the various rules in the probabilities of situations of interest 6 . We associate rates t1, t2, t3, and t4 to rules Token Pass, Send, Complete and Transmit, respectively. Figure 6 presents the rule Complete for the SOBGG model. Note that a rate t3 was added to the original OBGG rule.

Figure 6. SOBGG version to rule Complete.

The probabilities we look at are:

6 In this context, situations of interest means scenarios with different workload.

(i) the probability of the network being used by Node1 (i.e. the probability of attribute sent Node1 being true);
(ii) the probability of the network not being used by Node1 (should be a comple- ment of (i));
(iii) the probability of having a data message being transmitted by any node (i.e. the probability of any of the automata sent Node1 to sent Node4 being in state true) - since all nodes have the same rates, the ring should be shared equally and therefore this value should be 4 times the value of (i);
(iv) the probability of having no data message under transmission (should be a complement of (iii));
(v) the probability of having a token under transmission (should be same as (iv));
Table 6 shows the results for these cases, presenting also the integration function for each situation. The operator st applied to an automaton name means the state of the mentioned automaton.

Table 1
Quantitative analysis of the Token Ring translated model.

These rates mean that the nodes pass the token more often than they send messages. Further, note that when we just decrease the rate associated to sending messages, and increase the rate of passing the token, the occupation of the ring by data messages decreases, as expected.
Other scenarios could be specified changing the values of the rates. This could be useful, for instance, to guide a system developer to predict the network throughput (considering various workloads). The definition of rates to represent a specific reality (a real network) will be addressed in future work.

Final Remarks
In this paper we introduce Stochastic Object-Based Graph Grammars (SOBGG), an extension of Object-Based Graph Grammars (OBGG) to allow the stochastic analysis of the system being modeled. This type of analysis is suitable to evaluate non-functional properties of OBGG systems such as performance and dependability. levels.
In order to solve the stochastic model, we map SOBGG to Stochastic Automata Network (SAN). The solution of the corresponding SAN model with existing tools allows to associate probabilities to the reachable states of the SOBGG. SAN were

preferred due to the compact mathematical solution, allowing to solve models with larger state space if compared to Markov Chains, and also due to the modular presentation.
The mapping of SOBGG to SAN was described. Each instance of an object from the OBGG will generate various automata, one for each attribute and one for each possible input message type. The events and transitions of the automata are given by the rules of the SOBGG. The synchronization offered by SAN events is suitable to express atomicity in rule applications.
Once the corresponding SAN model has been generated and solved, the probab- ilities of each global state can be used for analysis. PEPS further offers integration functions which allow to obtain the probabilities associated to particular states of an automaton, and not only of global states.
As could be noticed, in order to analyse the SOBGG model the user has to know the generated SAN model to extract results. More concretely, the user writes integration functions about the states of the various SAN automata and their prob- ability. One important future work should be to allow the analysis of the model based on the SOBGG abstractions and not on the generated SAN, which should be, ideally, hidden from the user.
Various optimizations can be made on the SAN model obtained from this trans- lation, comprising important topics of future work. For instance, in models with static topology it is possible to eliminate automata for the object references, saving space. It should also be noticed the importance of reducing the state space of each element of the model such that it becomes treatable by a computational tool.
In the case studies carried out so far, we could notice that SOBGG models, when translated to SAN, tend to generate a large product state space but a re- duced reachable state space. The PEPS tool, in the current version, first calculates the product state space and then solves the system, assigning probabilities to the reachable states. Therefore our models are restricted in the product state space. A new version of the PEPS tool is being developed whereby the product state space is avoided and the reachable state space is calculated directly. This enhancement will allow the stochastic analysis of models with considerable size.

References
F. Bause and P.S. Kritzinger. Stochastic Petri Nets. Vieweg Verlag, 2 edition, 2002.
L. Brenner, P. Fernandes, and A. Sales. The need for and the advantages of generalized tensor algebra
for kronecker structured representations. In 20th Annual UK Performance Engineering Workshop, pages 48–60, 2004.
A. Corradini, U. Montanari, and F. Rossi. Graph processes. Fundamenta Informaticae, 26(3/4):241– 265, 1996.
F. L. Dotti, L. Foss, L. Ribeiro, and O. M. Santos. Verification of object-based distributed systems. In 6th International Conference on Formal Methods for Open Object-Based Distributed Systems, volume 2884 of LNCS, pages 261–275, France, 2003. Springer-Verlag.
F. L. Dotti and L. Ribeiro. Specification of mobile code systems using graph grammars. In 4th International Conference on Formal Methods for Open Object-Based Distributed Systems, volume 177, pages 45–63. IFIP Conference Proceedings, Kluwer Academic Publishers, 2000.


P. Fernandes, B. Plateau, and W. J. Stewart. Numerical evaluation of stochastic automata networks. In Proceedings of the Third International Workshop on Modeling, Analysis, and Simulation of Computer and Telecommunication Systems, pages 179–183, 1995.
R. Heckel, G. Lajios, and S. Menge. Stochastic graph transformation systems. In H. Ehrig, G. Engels,
F. Parisi-Presicce, and G. Rozenberg, editors, Proc. 2nd Intl. Conference on Graph Transformations (ICGT 2004), volume 3256 of Lecture Notes in Computer Science, pages 210–225. Springer, 2004.
M. Korff. True concurrency semantics for single pushout graph transformations with applications to actor systems. In R. J. Wieringa and R. B. Feenstra, editors, Information Systems - Correctness and Reusability, pages 33–50. World Scientific, 1995.
B. Plateau and K. Atif. Peps: a package for solving complex Markov models of parallel systems. In Proceedings of the 4th International Conference on Modelling Techniques and Tools for Computer Performance Evaluation, 1988.
Brigitte Plateau. On the stochastic structure of parallelism and synchronization models for distributed algorithms. In SIGMETRICS, pages 147–154, 1985.
C. Priami. The stochastic pi-calculus. The Computer Journal, 38:578–589, 1995.
O. M Santos, F. L. Dotti, and L. Ribeiro. Verifying object-based graph grammars. Eletronic Notes in Theoretical Computer Science, 109:125–136, 2004.
W. J. Stewart. Introduction to the numerical solution of Markov chains. Princeton University Press, 1994.
A. S. Tanenbaum. Computer Networks. Prentice-Hall, Englewood Cliffs, New Jersey, third edition, 1996.
