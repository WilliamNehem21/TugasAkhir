

Electronic Notes in Theoretical Computer Science 223 (2008) 61–70
www.elsevier.com/locate/entcs

Handling Left-Quadratic Rules When Completing Tree Automata
Y. Boichuta, R. Courbisb, P.-C. H´eamb and
O. Kouchnarenkob
a INRIA/PAREO
615 rue du Jardin Botanique BP-101 F-54602 Villers-L`es Nancy Cedex
boichut@loria.fr
b INRIA/CASSIS and LIFC / University of Franche-Comt´e 16 route de Gray F-25030 Besanc¸on Cedex
lastname.firstname@lifc.univ-fcomte.fr

Abstract
This paper addresses the following general problem of tree regular model-checking: decide whether R∗(L) ∩ Lp = ∅ where R∗ is the reflexive and transitive closure of a successor relation induced by a term rewriting system R, and L and Lp are both regular tree languages. We develop an automatic approximation-based technique to handle this – undecidable in general – problem in the case when term rewriting system rules are left-quadratic. The most common practical case is handled this way.
Keywords: Rewriting techniques, tree automata, left-linearity, security.

Introduction
Automatic verification of software systems is one of the most challenging research problems in computer aided verification. In this context, regular model-checking has been proposed as a general framework for analysing and verifying infinite state systems. In this framework, systems are modelled using regular representations: the systems configurations are modelled by finite words or trees (of unbounded size) and the dynamic behaviour of systems is modelled either by a transducer or a (term) rewriting system. Afterwards, a system reachability-based analysis is reduced to the regular languages closure computation under (term) rewriting systems: given a regular language L, a relation R induced by a (term) rewriting system and a regular set LP of bad conﬁgurations, the problem is to decide whether R∗(L)∩Lp = ∅ where R∗ is the reflexive and transitive closure of R. Since R∗(L) is in general neither regular nor decidable, several approaches handle restricted cases of this problem.
In this paper we address this problem for tree regular languages by automat- ically computing over- and under-approximations of R∗(L). Computing an over-

1571-0661 © 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.12.031

approximation Kover of R∗(L) may be useful for the verification if Kover ∩ Lp = ∅, proving that R∗(L)∩Lp = ∅. Dually, under-approximation may be suitable to prove that R∗(L) ∩ Lp /= ∅. This approach is relevant if the computed approximations are not too coarse. Another important point is that in general, there are some restrictions on the rewriting systems in order to ensure the soundness of the above approach. This paper follows and adapts an expert-human guided approximation technique introduced in [18] for left-linear term-rewriting systems. More precisely, the paper 1) extends this approach to term rewriting systems with left-quadratic rules, and 2) illustrates its advantages on examples.
Related Work Given a term rewriting system R and two ground terms s and t,
deciding whether s →∗ t is a central question in automatic proof theory. This prob-
lem is shown decidable for term rewriting systems which are terminating but it is undecidable in general. Several syntactic classes of term rewriting systems have been pointed out to have a decidable accessibility problem, for instance by providing an algorithm to compute R∗(L) when L is a regular tree language [15,13,20,23,25,26]. In [18], authors focus on a general completion based human-guided technique. This technique has been successfully used (not automatically) to prove the security of cryptographic protocols [19] and recently Java Bytecode programs [5]. This frame- work was extended in [24] to languages accepted by AC-tree automata. Several work on tree regular model checking are proposed in [9,1,8,21].
Layout of the paper The paper is organised as follows. Section 2 introduces notations and the basic completion approach. Next, Section 3 presents the main theoretical contributions of the paper, while Section 4 describes a family of examples and gives related security issues. Finally, Section 5 concludes.

Preliminaries
Terms and TRSs
Comprehensive surveys can be found in [16,2] for term rewriting systems, and in [12,20] for tree automata and tree language theory.
Let F be a finite set of symbols, associated with an arity function ar : F → N, and let X be a countable set of variables. T (F, X ) denotes the set of terms, and T (F) denotes the set of ground terms (terms without variables). The set of variables of a term t is denoted by Var(t). A substitution is a function σ from X into T (F, X ), which can be extended uniquely to an endomorphism of T (F, X ). A position p for a term t is a word over N. The empty sequence ϵ denotes the top-most position. The set Pos(t) of positions of a term t is inductively defined by: Pos(t) = {ϵ} if t ∈X 
and Pos(f (t1,..., tn)) = {ϵ}∪ {i.p | 1 ≤ i ≤ n and p ∈ Pos(ti)}. If p ∈ Pos(t),
then t|p denotes the subterm of t at position p and t[s]p denotes the term obtained by replacement of the subterm t|p at position p by the term s. We also denote by t(p) the symbol occurring in t at position p. Given a term t ∈T (F, X ), we denote PosA(t) ⊆ Pos(t) the set of positions of t such that PosA(t) = {p ∈ Pos(t) | t(p) ∈ A}. Thus PosF (t) is the set of functional positions of t.
A term rewriting system (TRS) R is a set of rewrite rules l → r, where l, r ∈

T (F, X ) and l /∈ X . A rewrite rule l → r is left-linear (resp. right-linear) if each variable of l (resp. r) occurs only once within l (resp. r). A TRS R is left-linear (resp. right-linear) if every rewrite rule l → r of R is left-linear (resp. right-linear). A TRS R is linear if it is right and left-linear. The TRS R induces a rewriting relation →R on terms whose reflexive transitive closure is written →٨ . The set of R-
descendants of a set of ground terms E is R∗(E) = {t ∈T (F) | ∃s ∈ E s.t. s →٨ t}.

Tree Automata Completion
Note that R∗(E) is possibly infinite: R may not terminate and/or E may be in- finite. The set R∗(E) is generally not computable [20]. However, it is possible to over-approximate it [18] using tree automata, i.e. a finite representation of infinite (regular) sets of terms. We next define tree automata.
Let Q be a finite set of symbols, of arity 0, called states such that Q∩F = ∅. T (F ∪ Q) is called the set of conﬁgurations A transition is a rewrite rule c → q, where c ∈ T (F ∪ Q) is a configuration and q ∈ Q. A normalised transition is a transition c → q where c = f (q1,..., qn), f ∈ F, ar(f ) = n, and q1,..., qn ∈ Q. A bottom-up non-deterministic finite tree automaton (tree automaton for short)
is a quadruple A = ⟨F, Q, Qf , Δ⟩, Qf ⊆ Q and Δ is a finite set of normalised transitions. The rewriting relation on T (F ∪ Q) induced by the transition set Δ of A is denoted →Δ. When Δ is clear from the context, →Δ is also written →A. The
tree language recognised by A in a state q is L(A, q) = {t ∈ T (F) | t →٨ q}. The
language recognised by A is L(A) =	q∈Qf L(A, q). A tree language is regular if and only if it is recognised by a tree automaton.
Let us now recall how tree automata and TRSs can be used for term reachability analysis. Given a tree automaton A and a TRS R, the tree automata completion
algorithm proposed in [18] computes a tree automaton Ak  such that L(Ak ) =
R∗(L(A)) when it is possible (for the classes of TRSs where an exact computation is possible, see [18]), and such that L(Ak ) ⊇ R∗(L(A)) otherwise.
The tree automata completion works as follows.  From A = A0 completion
builds a sequence A0 , A1 ... Ak of automata such that if s ∈ L(Ai ) and s →R t
R	R	R	R
then t ∈ L(Ai+1). If there is a fix-point automaton Ak such that R∗(L(Ak )) =
R	R	R
L(Ak ), then L(Ak ) = R∗(L(A0 )) (or L(Ak ) ⊇ R∗(L(A)) if R is in no class
R	R	R	R
of [18]). To build Ai+1 from Ai , a completion step is achieved. It consists of
finding critical pairs between →R and → i . To define the notion of critical pair,
R
the substitution definition is extended to terms in T (F ∪ Q). For a substitution
σ : X '→ Q and a rule l → r ∈ R such that Var(r) ⊆ Var(l), if there exists q ∈ Q 

satisfying lσ →∗ i
AR
q then lσ →∗ i
AR
q and lσ →R rσ is a critical pair. Note that since

R and Ai is finite, there is only a finite number of critical pairs. Thus, for every

critical pair detected between R and Ai
such that rσ /→∗ i
AR
q, the tree automaton

Ai+1 is constructed by adding a new transition rσ → q to Ai . Consequently, Ai+1
R	R	R
recognises rσ in q, i.e. rσ → i+1 q.
R
However, the transition rσ → q is not necessarily a normalised transition of the form f (q1,..., qn) → q'. Then, we use abstraction functions whose goal is to

define a set of normalised transitions Norm such that rσ →∗	q. Thus, instead
of adding the transition rσ → q which is not normalised, the set of transitions
Norm is added to Δ, i.e., the transition set of the current automaton Ai . For example, to normalize a transition of the form f (g(a), h(q')) → q, we need to find some states q1, q2, q3 and replace the previous transition by a set of normalized
transitions: {a → q1, g(q1) → q2, h(q') → q3,f (q2, q3) → q}.
Assume that q1, q2, q3 are new states, then adding the transition itself or its normalised form does not make any difference. Now, assume that q1 = q2, the normalised form becomes {a → q1, g(q1) → q1, h(q') → q3,f (q1, q3) → q}. This set of normalised transitions represents the regular set of non normalised transitions of the form f (g٨(a), h(q')) → q; which contains the transition initially we wanted to add amongst many others. Hence, this is an over-approximation. We could have made an even more drastic approximation by identifying q1, q2, q3 with q, for instance.
We give below a very general definition of abstraction functions which allot to each functional position of rσ a state of Q. The role of an abstraction function remains to define equivalence classes of terms where one class corresponds to one state of Q. An abstraction function γ is a function γ : ((R× (X → Q) × Q) '→ N∗) '→ Q such that γ(l → r, σ, q)(ϵ) = q.  Thus, given an abstraction function γ, the normalisation of a transition rσ → q is defined as follows. Let γ be an abstraction function, Δ be a transition set, l → r ∈ R with Var(r) ⊆ Var(l) and
σ : X → Q such that lσ →∗ q. The γ−normalisation of the transition rσ → q,
written Normγ(l → r, σ, q), is defined by:

Normγ(l → r, σ, q) = {r(p)(βp.1,..., βp.n) → β |
p ∈ PosF (r),
q if p = ϵ
β =
⎩ γ(l → r, σ, q)(p) otherwise.



βp.i
= ⎧⎨ σ(r(p.i)) if r(p.i) ∈X 
⎩ γ(l → r, σ, q)(p.i) otherwise.

Example 2.1 Let A = ⟨F, Q, Qf , Δ⟩ be the tree automaton such that F =
{a, b, c, d, e, f, ω} with ar(s) = 1 with s ∈ {a, b, c, d, e, f} and ar(ω) = 0, Q =
{qb, qf , qω}, Qf = {qf } and Δ = {ω → qω, b(qω) → qb, a(qb) → qf }. Thus, L(A) = 
{a(b(ω))}. Given the TRS R = {a(x) → c(d(x)), b(x) → e(f (x))}, two critical pairs

are computed: a(qb) →∗
qf , a(qb) →R c(d(qb)) and b(qω) →∗
b(qω) →R e(f (qω)).

Let γ be the abstraction function such that γ(a(x) → c(d(x)), {x → qb}, qf )(ϵ) = qf ,
γ(a(x) → c(d(x)), {x → qb}, qf )(1) = qf , γ(b(x) → e(f (x)), {x → qω}, qb)(ϵ) = qb
and γ(b(x) → e(f (x)), {x → qω}, qb)(1) = qb. So, Normγ(a(x) → c(d(x)), {x →
qb}, qf ) = {d(qb) → qf , c(qf ) → qf } and Normγ(b(x) → e(f (x)), {x → qω}, qb) = 
{f (qω) → qb, e(qb) → qb}.
Now we formally define what a completion step is. Let A = ⟨F, Q, Qf , Δ⟩ be

a tree automaton, γ an abstraction function and R a left-linear TRS. We define a tree automaton CR(A) = ⟨F, Q', Q' , Δ'⟩ with:
γ	f
Δ' = Δ ∪  l→r∈R, σ:X'→Q, lσ→∗ q,rσ/→∗ q Normγ(l → r, σ, q),
A	A
Q' = {q | c → q ∈ Δ'} and
' = Qf .
Example 2.2 Given A, R and γ of Example 2.1, performing one completion step on A gives the automaton CR(A) such that CR(A) = ⟨F, Q, Qf , Δ'⟩ where Δ' =
γ	γ
Δ∪Normγ(a(x) → c(d(x)), {x → qb}, qf )∪Normγ(b(x) → e(f (x)), {x → qω}, qb) = 
{ω → qω, b(qω) → qb, a(qb) → qf , d(qb) → qf , c(qf ) → qf ,f (qω) → qb, e(qb) → qb}. Notice that CR(A) is R-close, and in fact an over-approximation of R∗(L(A)) is computed. Indeed, the tree automaton CR(A) recognises the term a(e(e(f (ω))))
when
R∗(L(A)) = {a(b(ω)), a(e(f (ω))), c(d(b(ω))), c(d(e(f (ω))))}.
Proposition 2.3 ([18, Theorem 1]) Let A be a tree automaton and R be a TRS such that A is deterministic or R is left-linear, and for every l → r ∈ R, Var(r) ⊆ Var(l). For any abstraction function γ, one has:
L(A) ∪ R(L(A)) ⊆ CR(A).

In addition, an abstraction functions can be defined in such a way only terms, actually reachable, will be computed. This class of abstraction functions is called (A, R)−exact abstraction functions in [3].
Let A = ⟨F, Q, Qf , Δ) be a tree automaton and R be a TRS. Let Im(γ) = {q |
∀l → r ∈ R, ∀p ∈ PosF (r) s.t. γ(l → r, σ, q)(p) = q}. An abstraction function γ is (A, R)−exact if γ is injective and Im(γ) ∩Q = ∅.
By adapting the proof of Theorem 2 in [18] to the new class of abstractions, we show that with such abstraction functions, only reachable terms are computed.
Theorem 2.4 ([18, Theorem 2]) Let A be a tree automaton and R be a TRS such that A is deterministic or R is right-linear. Let α be an (A, R)−exact abstrac- tion function. One has: CR(A) ⊆ R∗(L(A)).
We now give the general result in [18] saying that, if there exists a fix-point automaton, then its language contains all the terms actually reachable by rewriting, at least. (A, R)−exact abstraction functions.
Theorem 2.5 ([18, Theorem 1]) Let A, R and γ be respectively a tree automa- ton, a TRS. For any abstraction function, if there exists N ∈ N and N ≥ 0 such that (CR)(N)(A) = (CR)(N+1)(A), then R∗(L(A)) ⊆ L((CR)(N)(A)).
γ	γ	γ
The above method does not work for all TRSs. For instance, consider a constant
A and the tree automaton A = ({q1, q2, qf }, {A → q1,A → q2,f (q1, q2) → qf }, {qf })
and the TRS R = {f (x, x) → g(x)}. There is no substitution σ such that lσ →∗ q,
for a q in {q1, q2, qf }. Thus, following the procedure, there is no transition to add.

But f (A, A) ∈ L(A). Thus g(A) ∈ R(L(A)). Since g(A) ∈/ L(A), the procedure stops (in fact does not begin) before providing an over-approximation of R∗(L(A)).
Contributions
This section extends an approximation-based technique introduced in [18] for left- linear term-rewriting systems, to TRSs with left-quadratic rules.
Let A = (Q, Δ, Qf ) be a finite bottom-up tree automaton.  The automaton
A▢ = (Q▢, Δ▢, Q▢) is defined by:
Q▢ = {{q} | q ∈ Q}∪ {{q1, q2} | q1, q2 ∈ Q} (states of Q▢ are denoted with a ▢
exponent),
Q▢ = {{q}| q ∈ Qf },
Δ▢ = {f (q▢,..., q▢) → q▢ | ∀q ∈ q▢, ∃q1,..., qn ∈ Q, ∀1 ≤ i ≤ n, qi ∈
1	n
q▢ and f (q1,..., qn) → q ∈ Δ}.
To illustrate the definition above, let’s consider the automaton A whose final state is qf and whose transitions are A → q1, A → q2 and f (q1, q2) → qf . The states of A▢ are all pairs of states and singletons over {q1, q2, qf }, and the transitions are A → {q1}, A → {q2}, A → {q1, q2}, f ({q1}, {q2}) → {qf }, f ({q1, qi}, {q2, qj}) →
{qf } for all i, j ∈ {1, 2,f}. When considering only the accessible states, among all the transitions above we just have the transition f ({q1, q2}, {q2, q1}) → {qf } (i = 2 and j = 1).
Proposition 3.1 One has L(A) = L(A▢).
Proof. By definition of A▢, if f (q1,..., qn) → q ∈ Δ, then f ({q1},..., {qn}) →
{q}∈ Δ▢. Consequently, for every term t such that t →∗ q, one also has t →∗ ▢ {q}.
Since for every qf ∈ Qf , {qf }∈ Q▢, L(A) ⊆ L(A▢).
It remains to prove that L(A▢) ⊆ L(A). We will prove by induction on k that for every k ≥ 1, for every term t, every state q▢ of A▢, if t →k ▢ q▢, then for all
q ∈ q▢, t →k q.
If t →A▢ q▢, then, by definition of Δ▢, t is a constant and for all q ∈ q▢, there exists a transition t → q of A.
Assume now that the claim is true for a fixed positive integer k. Let t be a term and q▢ ∈ A▢ such that t →k+1 q▢. Consequently, there exists f ∈ Fn such that
t →k	f (q▢,......, q▢) → ▢ q▢. It follows that t = f (t ,...,t ) and for all
A▢	1	n	A	1	k

1 ≤ i ≤ k, ti →k ▢ q . Using the induction hypothesis, ti	qi, for all qi
▢	k
∈ q▢.

Consequently, for all q ∈ q▢, f (q1,..., qn) → q ∈ Δ, proving the induction.
So, L(A▢) ⊆ L(A).	 

Lemma 3.2 If C[q1,..., qn] →∗  q and if q▢,... q▢
are states of A▢ satisfying

A	1	n
q ∈ q▢ for all 1 ≤ i ≤ n, then C[q▢,..., q▢] →∗	{q}.

i	i	1
n	A▢

Proof. We prove by induction on k that for every k ≥ 1, if C[q1,..., qn] →k

q and if q▢,... q▢ are states of A▢ satisfying qi ∈ q▢
for all 1 ≤ i ≤ n, then

1	n	i

C[q▢,..., q▢] →k	{q}.
1	n	A▢
If k = 1, then C[q1,..., qn] → q is a transition of A. Therefore, by definition of Δ▢, C[q▢,..., q▢] → {q} is a transition of A▢.
1	n
Assume now that the proposition is true for all j ≤ k and that C[q1,..., qn] →k+1
q. There exist q' ,..., q' states of A and f ∈ Fl such that C[q1,..., qn] →k
1	l	A
f (q' ,..., q' ) →A q. Consequently, C[q1,..., qn] is of the form C[q1,..., qn] = 
1	l
f (t1,..., tl) where the ti’s are terms over F ∪ {q1,..., qn}. Moreover, for all i,
there exists ki ≤ k such that ti →ki {q'} and Σ ki = k. Therefore, by induction
hypothesis, t▢ →ki  {q'} where t▢ is the term obtained from ti by substituting qi
i	A▢	i	i
by q▢. Now, since f (q' ,..., q' ) → q is a transition of A, f ({q' },..., {q' }) → {q}
i	1	l	1	l
is a transition of A▢. It follows that C[q▢,..., q▢] →k+1 {q}, proving the lemma.
1	n	A▢


Lemma 3.3 If t →∗
q1 and t →∗
q2, then t →∗ ▢ {q1, q2}.

Proof. If t →∗
q1 and t →∗
q2, then there exists a function π1 (reps.	π2)

from positions of t into Q such that π1(ε) = q1 (resp. π2(ε) = q2) and for ev- ery position p of t, if tp ∈ Fn, then t(p)(π1(p.1),..., π1(p.n)) → π1(p) (resp. t(p)(π2(p.1),..., π2(p.n)) → π2(p)) is a transition of A. Therefore, by definition of Δ▢, t(p)({π1(p.1), π2(p.1)},..., {π1(p.n), π2(p.n)}) → {π1(p), π2(p)} is in Δ▢. It follows that t →∗ ▢ {q1, q2}.	 
Proposition 3.4 If R is left-quadratic, then R(L(A)) ∪ L(A) ⊆ L(Cg(A▢)).
Proof. Since L(A) = L(A▢) and since L(A▢) ⊆ L(Cg(A▢)), L(A) ⊆ L(Cg(A▢)).
Let t ∈ R(L(A)). By definition there exists a rule l → r ∈ R, a position p of t
and a substitution μ from X into T (F) such that
t = t[rμ]p	and	t[lμ]p ∈ L(A)	(1) It follows there exist states q, qƒ of A such that qƒ is final,



Consequently,
lμ →∗
q	and	t[q]p →∗
qƒ .	(2)

lμ →∗ ▢ {q}	and	t[{q}]p →∗ ▢ {qƒ }.	(3)
A	A
If rμ →∗ ▢ {q}, then (3) implies that t[rμ]p →∗ ▢ {qƒ }. In this case, since t = t[rμ]p
A	A
and since {qƒ } is by construction a final state of A▢, t is in L(A▢), which is a subset of L(Cg(A▢)).
Now we may assume that rμ /→∗ ▢ {q}. Let PL be the set of variable positions
of l; i.e. PL = {p | l(p) ∈ X )}. Set PL = {p1,..., pl}. Since lμ →∗ q, by (2) there
exist states q1,..., ql of A such that


μ(l(pi)) →∗
qi	and	l[q1]p1
... [ql]pÆ
∗ q.	(4)

We define the substitution σ from variables occurring in l into 2Q by: σ(xi) = {qi |
l(pi) = xi}. Since l is left-quadratic, for each xi, σ(xi) contains at most two states.

We claim that lσ →∗ ▢ q. Indeed by (4) and by Lemma 3.3 for each xi occurring in l, μ(xi) →∗ ▢  σ(xi).  It follows that lμ →∗ ▢  lσ.  By (4) and using Lemma
A	A
3.2, lσ →∗ ▢ {q}, proving the claim. By construction of Cg(A▢), rσ →∗	▢  {q}.

A
Moreover, by definition of σ, rμ →∗ ▢ rσ. It follows that
Cγ (A )

t = t[rμ]p →∗ ▢ t[rσ]p →∗	▢ t[{q}]p →∗ ▢ {qƒ },
A	Cγ (A )	A
which completes the proof.	 
Proposition 3.5 If R is right-linear and if α is (A, R)-exact, then L(Cg(A▢)) ⊆ R∗(L(A)).
Proof. This is a direct consequence of Theorem 2.4 and Proposition 3.1.	 

Example and Application Domains
Example
We have tested our approach on the following family of examples. We first con- sider a family of tree automata (An) defined as follows: the set of states of An is {q1,..., q2n+2, qƒ }, the set of final state is {qƒ }, and the set of transitions is
{ω → q1,ω → q2, a(q1) → q1, a(q2) → q2, b(q1) → q1, b(q2) → q2, a(q1) → q3, a(q2) → q4, a(qi) → qi+2, b(qi) → qi+2,f (q2n+1, q2n+2) → qƒ }, for i ≥ 3. The au- tomaton An accepts the set of terms of the form f (t1, t2) where t1 and t2 are terms over {a, b, ω} such that t1|1n−1 and t2|1n−1 exist and are in {a}.{a, b}∗. Roughly speaking, when using word automata, a(b(ω)) denotes ab, and each pair (t1, t2) can be viewed as words of L = {a, b}n−1.{a}.{a, b}∗ satisfying the condition above. We
second consider the term rewriting system R containing the single rule f (x, x) → x, and we want to prove that bn−1a(ω) ∈ R∗(L(An)). Using finitely many times The- orem 2.4 directly on An may not prove the results. However, to prove the results, one can determinise An before using Theorem 2.4. But, the minimal automaton
of L(An) has 2n states at least [22], [Exercise 3.20, p. 73]. Then, the completion should be applied to this automaton. Consequently, this automatic proof requires an exponential time step. Using our approach, one can compute A and apply Proposition 3.5, that provides the proof requiring a polynomial time step.

Left-linearity and Security Issues
Security Protocol Analysis
The TRSs used in the security protocol verification context are often non left- linear. Indeed, there is a lot of protocols that cannot be modeled by left-linear TRSs. Unfortunately, to be sound, the approximation-based analysis described in
[19] requires the use of left-linear TRSs. Nevertheless, this method can still be applied to some non left-linear TRSs, which satisfy some weaker conditions. In [17] the authors propose new linearity conditions. However, these new conditions are not well-adapted to be automatically checked.

In our previous work [6] we explain how to define a criterion on R and A to make the procedure automatically work for industrial protocols analysis. This criterion ensures the soundness of the method described in [19,17]. However, to handle protocols the approach in [6] is based on a kind of constant typing. In [7] we go further and propose a procedure supporting a fully automatic analysis and handling – without typing – algebraic properties like XOR.
Let us first remark that the criterion defined in [17] does not allow managing the XOR non-left linear rule. Second, in [6] we have restricted XOR operations to typed terms to deal with the XOR non-left linear rule. However, some protocols are known to be flawed by type confusing attacks [14,10,11]. Notice that our approach in [7] can be applied to any kinds of TRSs. Moreover, it can cope with exponentiation algebraic properties and this way analyse Diffie-Hellman based protocols.

Backward Analysis of Java Bytecode
A recent work [4], dedicated to the static analysis of Java bytecode programs using term-rewriting systems, provides an automatic procedure to translate a Java byte- code into a term rewriting system modeling the code execution on the Java Virtual Machine. In this context, generated TRSs are left-linear but right-quadratic. In order to compute approximation refinements as in [3] or to manage backward anal- yses that are – in general and in practice – more efficient that forward analyses – term rewriting systems have to be turned left-right, i.e. left- and right-hand sides of rules have to be permuted. By this permutation right-quadratic TRSs become left-quadratic ones.
Conclusion
Regular approximation techniques have been successfully used in the context of security protocol analysis. In order to apply them to other applications, this pa- per proposed an extension of the completion procedure for handling left-quadratic rules. Our contributions allow analysing some reachability problems using poly- nomial steps computing A , rather than automata determinisation steps that are exponential, even in practical cases. Notice that the approach presented only for quadratic rules can be extended to more complex TRSs. We intend to optimise this technique: polynomial is better than exponential but may also lead to huge automata in few steps. We have been implementing the techniques in an efficient rewriting tool in order to investigate complex systems backward analyses.

References
P. A. Abdulla, B. Jonsson, P. Mahata, and J. d’Orso. Regular tree model checking. In E. Brinksma and K. G. Larsen, editors, Computer Aided Verification, volume 2404 of Lecture Notes in Computer Science, pages 555–568. Springer-Verlag, July 27–31 2002.
F. Baader and T. Nipkow. Term Rewriting and All That. Cambridge University Press, 1998.
Y. Boichut, R. Courbis, P.-C. Ham, and O. Kouchnarenko. Finer is better: Abstraction refinement for rewriting approximations. In RTA’08, LNCS, 2008. To appear.


Y. Boichut, Th. Genet, Th. Jensen, and L. Le Roux. Rewriting approximations for fast prototyping of static analyzers. In proceedings of RTA, LNCS 4533, pages 48–62. Springer, 2007.
Y. Boichut, Th. Genet, Th. P. Jensen, and L. Le Roux. Rewriting approximations for fast prototyping of static analyzers. In Franz Baader, editor, Term Rewriting and Applications, 18th International Conference, RTA 2007, Paris, France, June 26-28, 2007, Proceedings, volume 4533 of LNCS, pages 48–62. Springer, 2007.
Y. Boichut, P.-C. H´eam, and O. Kouchnarenko. Automatic Verification of Security Protocols Using Approximations. Technical Report RR-5727, INRIA, 2005.
Y. Boichut, P.-C. H´eam, and O. Kouchnarenko. Handling algebraic properties in automatic analysis of security protocols. In Kamel Barkaoui, Ana Cavalcanti, and Antonio Cerone, editors, ICTAC’06, volume 4281 of LNCS, pages 153–167. Springer, 2006.
A. Bouajjani, P. Habermehl, A. Rogalewicz, and T. Vojnar. Abstract regular tree model checking. In
Infinity’05, volume 149 of Electronic Notes in Theoretical Computer Science, pages 37–48, 2006.
A. Bouajjani and T. Touili. Extrapolating tree transformations. In Ed Brinksma and Kim Guldstrand Larsen, editors, Computer Aided Verification, volume 2404 of Lecture Notes in Computer Science, pages 539–554. Springer-Verlag, July 27–31 2002.
L. Bozga, Y. Lakhnech, and M. Perin. Pattern-based abstraction for verifying secrecy in protocols. In 9th International Conference on Tools and Algorithms for the Construction and Analysis of Systems,TACAS 2003, Proceedings, volume 2619 of LNCS. Springer-Verlag, 2003.
I. Cibrario, L. Durante, R. Sisto, and A. Valenzano. Automatic detection of attacks on cryptographic protocols: A case study. In Christopher Kruegel Klaus Julisch, editor, Intrusion and Malware Detection and Vulnerability Assessment: Second International Conference, volume 3548 of LNCS, Vienna, 2005.
H. Comon, M. Dauchet, R. Gilleron, F. Jacquemard, D. Lugiez, S. Tison, and M. Tommasi. Tree Automata Techniques and Applications, 2002.
J.-L. Coquid´e, M. Dauchet, R. Gilleron, and V´agv¨olgyi S. Bottom-up tree pushdown automata and rewrite systems. In Ronald V. Book, editor, Rewriting Techniques and Applications, 4th International Conference, RTA-91, LNCS 488, pages 287–298, Como, Italy, April 10–12, 1991. Springer-Verlag.
V. Cortier, S. Delaune, and P. Lafourcade. A survey of algebraic properties used in cryptographic protocols. Journal of Computer Security, 14:1–43, 2006.
Dauchet and Tison. The theory of ground rewrite systems is decidable. In LICS: IEEE Symposium on Logic in Computer Science, 1990.
N. Dershowitz and J.-P. Jouannaud. Handbook of Theoretical Computer Science, volume B, chapter 6: Rewrite Systems, pages 244–320. Elsevier Science Publishers B. V, 1990.
G. Feuillade, Th. Genet, and V. Viet Triem Tong. Reachability analysis of term rewriting systems. Technical Report RR-4970, INRIA, 2003. To be published in Journal of Automated Reasoning, 2004.
G. Feuillade, Th. Genet, and V. VietTriemTong. Reachability analysis over term rewriting systems.
Journal of Automated Reasonning, 33 (3-4), 2004.
Th. Genet and F. Klay. Rewriting for Cryptographic Protocol Verification. In proceedings of CADE, volume 1831 of LNCS, pages 271–290. Springer-Verlag, 2000.
R. Gilleron and S. Tison. Regular tree languages and rewrite systems. Fundamenta Informatica, 24(1/2):157–174, 1995.
P. Habermehl, R. Iosif, A. Rogalewicz, and T. Vojnar. Abstract regular tree model checking of complex dynamic data structures. In SAS’06, 13th International Static Analysis Symposium, volume 4134 of LNCS, pages 52–70, 2006.
J. Hopcroft and J. D. Ullman. Introduction to Automata Theory, Languages, and Computation. Addison-Wesley, 1979.
F. Jacquemard. Decidable approximations of term rewriting systems. In proceedings of RTA, volume 1103, pages 362–376. Springer Verlag, 1996.
H. Ohsaki and T. Takai. ACTAS: A system design for associative and commutative tree automata theory. Electr. Notes Theor. Comput. Sci, 124(1):97–111, 2005.
P. R´ety and J. Vuotto. Regular sets of descendants by leftmost strategy. Electr. Notes Theor. Comput. Sci, 70(6), 2002.
K. Salomaa. Deterministic tree pushdown automata and monadic tree rewriting systems. JCSS: Journal of Computer and System Sciences, 37, 1988.
