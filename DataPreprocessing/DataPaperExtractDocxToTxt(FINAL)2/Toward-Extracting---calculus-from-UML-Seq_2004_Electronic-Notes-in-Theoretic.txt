Electronic Notes in Theoretical Computer Science 101 (2004) 51–72  
www.elsevier.com/locate/entcs


Toward Extracting π-calculus from UML Sequence and State Diagrams 1
Katerina Pokozy-Korenblat2 and Corrado Priami3
Department of Informatics and Telecommunications University of Trento
Povo, Italy

Abstract
We propose an automatic translation of UML specifications made up of sequence and state diagrams into π-calculus processes. The central point of the proposed translation is the coherence of the two types of diagrams. We show the feasibility of the approach on case studies.
Keywords: process algebras, π-calculus, UML, sequence diagram, state diagram, specification.


Introduction
The Unified Modelling Language (UML) [3] is a standard notation used to capture high-level design of software systems. It gives structured, semi-formal, graphical methods for specification which are however not strong enough for verification and validation of systems. UML provides the user with different kinds of diagrams, each of them is natural for describing different aspects of complex (software) systems. In this paper we restrict our attention on specifications including only sequence and state diagrams. Such a choice is often sufficient for specifying the communication level of systems and can be considered as a first step in handling multi-diagram UML specifications.

1 This work is partially supported by the DEGAS (Design Environment for Global Applica- tions) project IST-2001-32072 funded by the FET Proactive Initiative on Global Computing
2 Email: pokozy@science.unitn.it
3 Email: priami@dit.unitn.it



1571-0661 © 2004 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2004.09.007


To implement a formal analysis of a UML specification, we propose to translate it to the formal notation of process algebras [13]. Process alge- bras are foundational calculi used to describe the concurrent and distributed structure of systems. They are made up of a few operators such as: i) a.− that describes sequential composition of actions, ii) −| − that is the parallel composition of processes, iii) − + − that denotes a nondeterministic choice. We view here process algebras as an intermediate language into which UML specifications can be translated for the following analysis. Note that pro- cess algebras is a natural formalism for representing communications that is very important in a translation of sequence diagrams and also for compos- ing independent parts of the model that is essential for translation of UML specifications contains several entities. Furthermore, process algebras gives wide possibilities for performance analysis that is critical for communication intensive part of a model that is usually specified by sequence diagrams.
A number of synthesis techniques for building models from interaction di- agrams has been developed. In [15] a way of representation of collaboration diagrams in terms of Colored Petri Nets was proposed. Considering a spec- ification consisting of state and interaction diagrams, a state diagram based approach to translation was presented in [5] and [8]. In those works states are represented as processes and transitions are represented as actions along com- munication channels. However, when we focus on a communication level such an approach is not effective enough. It would be more natural to use messages as a basic element of translation since that better corresponds to the nature of process algebras. In this paper we focus on a sequence diagram based ap- proach, where objects are considered as π-calculus processes and messages as communications between these processes. A state diagram of an object is used for choosing the feasible sequences of the messages occurring in the sequence diagram.
Note that an outcome of our proposal is also the definition of a formal semantics for UML sequence diagrams based on the structural operational semantics of the π-calculus. Many different approaches to define a formal semantics of UML, and in particular, of sequence diagrams and their counter- part from the telecommunication industry message sequence charts have been proposed. One of the approaches generates statechart model (e.g. [19], [4]). In [18] a semantics in terms of labelled transition systems and parallel compo- sition is presented. A process algebras approach presented in [12] permits to compose several message sequence charts. Alur et al. [1] gives the semantics of message sequence charts in terms of partial order of events occurring in the system. A way of formalizing of collaboration diagrams by means of graph transformation rules and graph processes is presented in [10]. An integrated


graph semantics given in [9] allows to specify interaction diagrams in a uni- versal ways together with other types of diagrams. A trace-based semantics was proposed in [2]. In [17] a translation of sequence diagrams into process algebras where messages are represented as actions, is considered. The work focuses on a translation of a set of simple sequence diagrams which correspond to separate scenarios. In contrast we represent a message as a communication between processes and focus on translation of constructions (e.g. branching, assignment) allowing to express complicated behaviour in a single diagram. Specifics and strong side of our process algebra based semantics is that in obtained formal model messages between objects are presented in a natural for communications way that is essential, for example, for security analysis. Note however that defining of formal semantics is not our main concern.
We now briefly discuss the motivations for the present work. We rely on a standard Unified Modelling Language (UML) to use formal methods in the software production process. The challenges we approach in this task are the definition of techniques to extract specifications into process calculi from the possibly excessive or incomplete information in the UML description. The final goal is to have a design environment in which the user only interacts with UML in order to perform formal analysis of his/her applications.
The paper is structured as follows. In section 2 there is a description of those aspects of UML we are interested in. In section 3 an overview of the π-calculus is presented. A translation from sequence diagrams to π-calculus is given in section 4. In section 5 we discuss the joint translation of sequence and state diagrams. Finally, some remarks on the ways of using of the obtained π-calculus specification are given.

Brief UML description
UML is a semi-formal modelling language which is a standard for high-level specification of software systems. There are many different types of UML diagrams which are used to specify different aspects of software systems. In this short presentation we focus on sequence and state diagrams.
A sequence diagram shows how objects interact with one another by rep- resenting examples of executions. A sequence diagram has two dimensions: the vertical dimension represents time and the horizontal one represents dif- ferent objects. Objects can communicate by exchanging messages represented by arrows. To show different kinds of communications the following variations of notation are considered in this paper.
Stick arrowhead is used for synchronous communication. In the case of



'
µ	P {y˜/x˜} −→ P

Act : µ.P −→ P	Ide :
µ
Q(y˜) −→ P
, Q(x˜)= P
'


P −→ P '	P −→ P '

Par :	µ
P |Q −→
P '|Q, bn(µ) ∩ fn(Q)= ∅	Sum : P + Q  µ  P '




P −→ P '
Res :	µ
(νx)P
,x /∈ n(µ)	Open :
'
x(y⟩
P −→ P
x(y)
,y /= x
'

−→ (νx)P
(νy)P −→ P



x(y)
P
x(w) '


x(y⟩  '
x(w) '

Close : P |Q −τ→ (νy)(P '|Q'{y/w}) , y/∈fn(Q)	Com : P |Q −τ→ P '|Q'{y/w}
Table 1
Late transition system for the π-calculus.

nested control flow the entire nested sequence have to be completed before the outer level sequence resume.
Dashed arrow with stick arrowhead is used for returning message.
A message is labelled at least with the message name; one can also include arguments and a condition which acts as a guard for sending the message. Furthermore a message can be associated with an assignment that associates with the assigned variable the value returned after the message.
Messages can be combined in a branching construction which is shown by multiple arrows leaving a single point and means alternative or concurrency of those messages depending of their conditions.
A state diagram describes the sequences of states and transitions through which the modelled element can proceed during its lifetime as a reaction to discrete events. A state diagram is a graph that represents a state machine.
The semantics of a state diagram can be defined in terms of a Kripke structure [11]. Given a state s in a state diagram S, we denote as (s•)• a set of pairs of transitions t1t2 such that there exists a sequence s1[t1⟩s2[t2⟩ of states (si) and transitions (ti) in the Kripke structure of S.

The π-Calculus
In this section we briefly recall the π-calculus [13], a model of concurrent communicating processes providing the notion of naming.
Let N be a countable infinite set of names ranged over by a, b,... with N∩ 
{τ } = ∅. We also assume a set A of agent identiﬁers ranged over by A, A1,.. ..
Processes (denoted by P, Q, R,... ∈ P) are built from names according to the

syntax
P ::= 0 | π.P | P + P | P |P | (νx)P | [x = y]P | A(y1,... , yn)
where π may be x(y) for input, x⟨y⟩ for output (where x is the subject and y the object), ε for empty string, or τ for silent moves. Hereafter, the trailing 0 will be omitted.
The prefix π is the first atomic action that the process π.P can perform. The input prefix binds the name y in the prefixed process. Intuitively, some name y is received along the link named x. The output prefix does not bind the name y which is sent along x. The silent prefix τ denotes an action which is invisible to an external observer of the system. Summation denotes nonde- terministic choice. The operator | describes parallel composition of processes. The operator (νx) acts as a static binder for the name x in the process P that it prefixes. In other words, x is a unique name in P which is different from all the external names. Finally, matching [x = y]P is an if-then operator: process P is activated if x = y. A(y1,... , yn) is the definition of constants (hereafter, y˜ denotes y1,... , yn). Each agent identifier A has a unique defin- ing equation of the form A(y1,... , yn) = P , where the yi are distinct and fn(P ) ⊆ {y1,... , yn} (see below for the definition of free names fn).
A parallel composition of processes P1,... , Pn is written as  i=1...n Pi. For a set of names V = {v1,... vn} we use the notation (νV )P for (νv1) ... (νvn)P and (νv1, v2)P for (νv1)(νv2)P .
We use here a late version of the π-calculus, although early semantics could apply as well. The late operational semantics for the π-calculus is defined in the SOS style, and the labels of the transitions are τ for silent actions, x(y) for input, xy for free output, and x(y) for bound output. We will use µ as a metavariable for the labels of transitions (it is distinct from π, the metavariable for prefixes, though it coincides in two cases). We recall the notion of free names fn(µ), bound names bn(µ), and names n(µ)= fn(µ) ∪ bn(µ) of a label µ.
µ	Kind	fn(µ) bn(µ)
τ	Silent	∅   ∅
xy	Free Output	{x, y}  ∅
x(y), x(y) Input and Bound Output  {x}  {y}
Functions fn, bn and n are extended to processes in the obvious way. Below we assume that the structural congruence ≡ on processes is defined as the least congruence satisfying the following clauses:
P and Q α-equivalent (they only differ in the choice of bound names) implies
P ≡ Q,

(У/≡, +, 0) and (У/≡, |, 0) are commutative monoids,
ε.P ≡ P ,
[x = x]P ≡ P ,
(νx)(νy)P ≡ (νy)(νx)P, (νx)(R | S) ≡ (νx)R | S if x /∈ fn(S), (νx)(R | S) ≡
R | (νx)S if x /∈ fn(R), and (νx)P ≡ P if x /∈ fn(P ).
µ
A variant of P —→ Q is a transition which only differs in that P and
Q have been replaced by structurally congruent processes, and µ has been
α-converted, where a name bound in µ includes Q in its scope.
We report the late transition system for the π-calculus in Tab. 2. The transition in the conclusion of each rule, as well as in the axiom, stands for all its variants.

Translation of Sequence Diagrams
In this section we restrict our attention to UML sequence diagrams. Note that the semantics of UML allows a message in a sequence diagram to be skipped. For simplicity in this section we consider the case of non-skipping messages as it is the common practice of designers (we will deal with skipping of messages later in the paper). Moreover we assume that names of messages are unique, otherwise we rename them before translation.
First we consider sequence diagrams without conditions on messages. We will represent an object from a sequence diagram as a process in the π-calculus and compose all processes arising from the given sequence diagram via parallel composition.
A message between two objects is represented as a communication between the corresponding processes. For each message we create a private channel in the π-calculus representation and translate the message as a synchronization on this channel. In our translation a self-call is represented by the silent action τ . Note that for an assignment construction associated to a self-call it can be essential to express the fact that we assign the variable (e.g. for analyzing of security properties). In such a case self-call can be translated as a communication with an additional internal object.
As far as sequence diagrams show how an object interacts with others, it is natural to consider an object as a sequence of sending and receiving of messages. To translate an object we produce sequentially for each of its sent/received message an input/output of a signal along the corresponding channel.
Given two objects connected by a message m, we translate this message as


	=⇒	(νm)(m | m)
Fig. 1. Translation of a message.


=⇒	(νm1, m2)(([x = true] m1. m2 | m1. m2)+ 
([x = f alse] m2 | m2))

Fig. 2. Translation of a condition.

=⇒	(νm, returnm)([x = true]m. returnm |
m. returnm)
Fig. 3. Translation of a return.
an input on the channel m in the object receiving the message and an output on the same channel in the object sending the message (see Fig. 1).
Consider now a message with a condition.	The message is sent if its condition is satisfied, or it is skipped otherwise. Given a sending message [x]m, we obtain an output on the channel m prefixed by the matching [x = true] if the condition is satisfied, or a skipping of the message prefixed by the matching [x = f alse] otherwise. For a receiving message [x]m we obtain an input on m or a skipping of it, depending on the value of x. Nested messages initialized by a message with a condition including its return will be discarded if the condition is not satisfied. To illustrate the translation of conditions, consider a simple sequence diagram with a single condition x from Fig. 2. It is translated to a summation of two subprocesses representing two possible valuations of x. We translate an explicit return of the message as a usual message with the name return⟨message name⟩. For example, we translate a message [x]m with an
explicit return (Fig. 3) as a sequence of messages ⟨m, returnm⟩.

(νm1, m2, m3, syn) (m1. syn |
=⇒	m2. syn | syn. syn. m3 | m1 | m2 | m3)

Fig. 4. Translation of a branching construction.
A branching of several messages is translated as a parallel composition of these messages synchronized before continuation because all of branched


	=⇒	(νm, returnm)(m. returnm(x) | m. returnm⟨x⟩
Fig. 5. Translation of an assignment.






messages have to be delivered. In more detail, for a sending object we intro- duce an input on the special channel syn after any branched messages. Then we construct a continuation process that is the translation of the remaining messages prefixed by sending of a syn signal for any message in the branching construction. Finally, we compose the translation of the branching structure and the continuation process by parallel composition. In the receiving pro- cess we have a parallel composition of branched messages and continuation without synchronization. We use the syn channel to force the continuation process starting after the delivery of all the branching messages. We illustrate our translation on a simple sequence diagram presenting two parallel messages followed by a reply (see Fig. 4). We use a channel syn to force m3 occurring after m1 and m2.
An assignment construction is generally used for binding an identifier that stores the return value of a message. It can be translated as a message with an explicit return which transfers not a signal but a required variable (see Fig. 5). In other words, we use a real communication rather than a simple synchronization.
We now formally define a translation function from UML sequence dia- grams to the π-calculus. Given a message m, we define a set of nested mes- sages nest(m) in case of an explicit return as the set of messages that become enabled by the sending of m before the return of m (including the return), or as an empty set, otherwise.
By abuse of notation we use the metavariable for processes У to denote prefixes possibly prefixed by a matching.
Fix a sequence diagram SD with a set of objects O, a set of messages Mes  and a set of conditions C. Let ρ : C ∪ {Λ} → Bool be an evaluation function that returns true for the special condition Λ. Given a message m, we define cm as a condition corresponding to m, or as Λ if there is no condition on m. Given an object O and a message m in O, we define the function trρ : O×Mes → У 



as	⎧⎪
⎪

[cm
m

= true] m,  if O sends m and ρ(cm
m

)= true;

[c	= f alse|ε, if O sends m and ρ(c
⎪
)= f alse;

trρ(O, m)= 
⎪⎨ m,	if O sends m and cm = Λ;
m,	if O receives m and ρ(cm)= true;
⎪ ε,	if (O receives m and ρ(cm)= f alse) or
⎪

⎪⎪⎩
(∃m' | m ∈ nest(m') and ρ(cm' )= f alse).

For a given assignment construction x := m() we translate the return of m in a special way. We redefine the function trρ(O, returnm) in case of assignment as returnm(x) for a sending object, or as returnm⟨x⟩ for a receiving object.
Fix an evaluation ρ and an object O defined by a sequence of set of sent/ received messages MO = ⟨M0, M1,... , Mn⟩, where a set Mi = {m1,... , mki }
i	i

represents branching messages and mj
∈ Mes for each i ∈ {1 ... n} and

j ∈ {1 ... ki}. We define the translation function seqρ : O× Mes∗ ×У → У
as follows:
seqρ(O, ⟨ ⟩, tail)= tail, and
seqρ(O, ⟨Mi,... , Mn⟩, tail)= 
⎪trρ(O, m1).seqρ(O, ⟨Mi+1,... , Mn⟩, tail),	if ki =1 
=	j=1...ki trρ(O, mi ).seqρ(O, ⟨Mi+1,... , Mn⟩ |nest(mj ), syn	.tail) |

| synM.i
⎪
... .synMi.seqρ(O, rest(⟨Mi,... , Mn⟩), tail),	if ki > 1

⎩ `	˛k¸i	x
where rest(⟨Mi,... , Mn⟩) is a subsequence of ⟨Mi,... , Mn⟩ starting after re- turns of all messages from Mi.
Eventually, for a fixed evaluation ρ we obtain P ρ =  O∈S seqρ(O, MO).
ρ∈C∪{Λ}×Bool
V = {v | v ∈ M	∨ v = syn	}.
As final remarks, we give some notes for simplifying the result of the trans- lation.
Repeating conditions. We leave in a process only the first instance of a repeating condition if these instances do not divided by an assignment that can change the condition value.
Empty branched subprocesses. In a translation of branching construction because of the false value of a condition we can obtain a parallel subprocess containing only conditions and receiving of a synchronizing message. Such


processes are nonessential for the translation and can be skipped together with a corresponding sending of the synchronizing message. In the case of a single active branched message we can translate it as usual sequence message. An illustration of this point you can see the end of the next subsection.

An Example
To illustrate our translation consider the sequence diagram in Fig. 6 repre- senting a slight variant of the Phone system in [8]. In this example we have two conditions c1 = [busy] and c2 = [not busy]. Thus we obtain two possible valua- tions ρ1 : ρ1(c1)= true, ρ1(c2)= f alse and ρ2 : ρ2(c1)= f alse, ρ2(c2)= true.
Obviously only these two valuation are available. The result of the translation is shown below.

Callerρ1 = lift. dial tone. number. connect tone. busy tone. disconnect. hangs up Callerρ2 = lift. dial tone. number. connect tone. ring tone. talking1. talking2.
disconnect. hangs up


Phoneρ1 = (νsyn1)lift. dial tone. number. (connect tone. syn1 | connect. returnconnect(busy). syn1 | syn1. syn1. [busy = true]busy tone. disconnect. hangs up)
	
Phoneρ2 = (νsyn1, syn2)lift. dial tone. number. (connect tone. syn1 | connect. returnconnect(busy). syn1 | syn1. syn1. Calling)
Calling = [busy = false]ring tone. syn2 | [busy = false]call. answer. returncal.l syn2 | syn2. syn2. disconnect. hangs up
Receiverρ1 = connect. returnconnect⟨busy⟩.ε 
Receiverρ2 = connect. returnconnect⟨busy⟩. call. answer. talking . talking .
1	2
returncall
System = (νV )(P honeρ1 | Receiverρ1 | Callerρ1 )+ (P honeρ2 | Receiverρ2 |
| Callerρ2 ) where V is the set of channels of System.
Now we illustrate the simplification technique of empty branched subpro-
cesses described in the previous section. In P honeρ1 we translate the branching construction {busy tone, ring tone, call} as a single message busy tone be- cause conditions on two other messages are false on a valuation ρ1, and we obtain its translation [busy = true]busy tone instead of [busy = true]syn2 | [busy = true]syn2 | [busy = true]busy tone.syn2 | syn2.syn2.syn2 as it would be done in the general case.

Joint Translation of Sequence and State Diagrams
Each type of UML diagrams has its own most natural way of translation to the π-calculus. To translate a whole system composed of different diagrams



Fig. 6. Sequence diagram of the Phone system.

we choose a driving type of diagrams (here a sequence diagram), and we take necessary additional information about the system from other types of diagrams (here state diagrams). For a joint translation of sequence and state diagrams we have two different approaches which are distinguished in the choice of the driving type of diagrams:
Sequence diagram based translation. According to our translation, each valuation is considered and translated separately so that the obtained π- calculus representation is a summation of subprocesses for all possible val- uations. Additional information from state diagrams helps to determine feasible computations. The problem here is to represent more detailed in- formation from state diagrams because it is not understandable how to translate internal actions of a state diagram not represented in the sequence diagram. It is possible to ignore this detailisation and obtain a translation at a communication level.
State diagram based translation. A state diagram (for each object) is trans- lated as a process parameterized by state name and representing a transi- tion from state to state. Additional information from a sequence diagram is necessary for composing the processes corresponding to different state diagrams. Such approach was used in [5] for producing translation to Per-



Fig. 7. State diagram of the object Phone of the Phone system.
formance Evaluation Process Algebra (PEPA).
The last approach requires a very detailed description of each object of a system. However, sometimes we would prefer to have a high-level specification which does not contain such a detailed specification of all objects. Thats why we choose a sequence diagram based approach in our translation.

Sequence diagram based translation
In the previous section we considered the case of nonskipped messages. How- ever, in a general case messages in a sequence diagram can be skipped. It can be useful, for example, to present alternative use cases in one sequence diagram. If we consider a separate sequence diagram in this paradigm we obtain all possible subsequences of a given sequence of messages. So, we can see only an order of messages but have no information which message has to be skipped in an allowed behaviour.
To illustrate such a situation we add to the Phone system on Fig. 6 a message timeout tone from Caller to P hone between messages dial tone and number. It can be interpreted as follows. If a Caller does not dial a num- ber, after some waiting period it receives a timeout tone and finishes the call. After the timeout tone, the Caller cannot dial a number, but a sequence diagram does not give us such information, and we have a sequence of mes- sages ⟨... dial tone, timeout tone, number .. .⟩ besides the correct sequences
⟨... dial tone, timeout tone, hangs up⟩ and ⟨... dial tone, number .. .⟩.
To consider only correct sequences of messages we need some additional information which can be taken from other types of diagrams. Namely we need an information about branching points in a behaviour model of the sys- tem. By default we consider messages in a sequence diagram sequentially and suppose that for each two sequential messages there is an execution way con-


cluding those two messages. In a point when we skip a message we have two alternatives: to execute messages of the sequence diagram one after another, or to jump to some other message of the diagram. We will call such a situation by a branching point.
In our translation information about branching points will be obtained from state diagrams which describe behaviour of single objects. We restrict a state diagram on a set of transitions representing communications and call it a restricted state diagram. We can talk about branching point for a restricted state diagram if for a given state we have outgoing transitions corresponding to more then one set of branching messages. A skeleton of a state diagram is a restriction of a restricted state diagram on a set of transitions which are belong to some branching point.
For sequence and state diagrams in isolation we can present semantics in terms of π-calculus or some other formalism. However, correlation between different diagrams is not specified formally in UML. So we have to make some assumptions on a relation between these diagrams to be correct in the transla- tion of the whole specification. These assumptions are concern to an agreement on names presenting the same communications in different diagrams.
Given UML specification consisting of a sequence diagram SD and state diagrams OD1,... ODk corresponding to objects O1,... Ok of SD. We will say that a specification is coherent if there is the following relation between messages in sequence diagram and transitions in state diagrams:
Names of messages in SD are unique (it is necessary for correct corre- spondence between messages in the sequence diagram and transitions in the state diagrams).
A message m in SD relating objects Oi and Oj and a transition m in
ODi (ODj) represent the same event in the specified system.
A message m in SD can be skipped iff there is a path in the corresponding state diagram in which a transition m is skipped.
A message m' follows m iff there exists a pair of sequential transitions
m, m' in a skeleton of the corresponding state diagram.
The last point means that we don’t require all messages to be presented in a state diagram, and a message in a sequential part of the diagram can be skipped. Note that a state diagram can include more detailed information than a corresponding sequence diagram. But in this translation we use state dia- grams only for additional information about available sequences of messages. So internal actions of a state diagram are nonessential to our translation.
For readability we present here a translation of a simplified version of sequence diagrams which do not contain a branching construction. Fix an


object O with a sequence of sent/received messages MO = ⟨m1,... , mn⟩. The first step of the translation is to calculate branching points. We define a set of starting states of a message mi+1 recursively as a set of states obtained from starting messages of mi after execution of a transition corresponding to mi. A branching point B(mi) contains a pair (mi, mi+1) and further for each starting state s of mi is constructed in the following way: 6tt' ∈ (s•)•
, B(mi) ∪ (m(t), m(t')),	if m(t)= mi and Et'' /= t'. tt'' ∈ (s•)•;
B(mi)= 
, B(mi) ∪ (skip mi, m(t)), if m(t) /= mi.
Then we modify the translation of sequence diagrams proposed in section 4 by using information about branching points to single out correct execution sequences. The difference from the original algorithm is the definition of the function seqρ. Given an evaluation ρ, we calculate the translation function seqρ : 0× łes∗ → У as follows: seqρ(O, ⟨ ⟩)= 0, and

seqρ(O, ⟨mi,... , mn⟩)=	Σ
{j |(mi,mj )∈B(mi )}
Σ
trρ(O, mi).seqρ(O, ⟨mj,... , mn⟩)+

seqρ(O, ⟨mj,... , mn⟩).

{j |(skip mi,mj )∈B(mi )}
Let us illustrate this approach with the Phone System which was already considered in section 4. Now we represent it by the sequence diagram (Fig. 6) and the state diagram for the object Phone (Fig. 7). An assumption about skipping of messages intuitively means that the Caller can hang up after any of his actions. The result of the translation of an object P hone on the valuation ρ1 is:
P honeρ1 = lift. dial tone. (hangs up + number. hangs up + number. (connect tone. syn1 | connect.returnconnect(busy). syn1 | syn1. syn1. [busy = true]busy tone. hangs up))
A separate problem is a translation of a part-described system. If one of the objects in a sequence diagram related by the message is not described by a state diagram, we can extract information from an existing state diagram. To illustrate this moment let us consider the translation of the object Caller from the Phone System based on the sequence diagram (Fig. 6) and the state diagram for the object Phone (Fig. 7):
Callerρ1 = lif t. dial tone. (hangs up + number. hangs up + number. connect tone. busy tone. hangs up)
Here we suppose that for the receiving of a message number there are three cases: ”ignore the message and finish”, ”finish after the message” and ”continue after the message”, then we have the same cases for the sending of this message.




Fig. 8. An abstract level state diagram.
Compositional translation
To extract the case of one sequence diagram and a set of state diagrams for some of its objects, presented in section 4 we need a possibility to compose several sequence diagrams. We will do it by adding an abstract level state diagram which shows relations between different sequence diagrams.
This information can be obtained also from state diagrams of objects. We can construct an abstract level state diagram from the set of state diagrams of objects as follows. If in a state diagram of an object there are two sequential transitions corresponding to messages from different sequence diagrams, we produce a transition between states presenting those sequence diagrams in an abstract level state diagram.
In this section we propose a translation of a coherent specification con- sisting of an abstract level state diagram, a set of sequence diagrams corre- sponding to some of its states and a set of state diagrams corresponding to objects of sequence diagrams. The natural way of translation of an abstract state diagram is to correspond to each state an agent starting with an action which describes the state and prolonging as an agent for one of the states succeed to the considered one. If there is a sequence diagram corresponding to a given state, an action describing the state is a pair of control signals for initializing and finishing of the agent corresponding to the sequence diagram. Otherwise we suppose a silent action. A sequence diagram is translated as it was shown in section 4 except of the fact that the result of this translation has to be reexecutable because it can be used as a part of abstract state diagram translation. So we have to present a sequence diagram as a recursive agent that initializes a separate agent for each of its objects.
Fix an abstract level state diagram AD with a set of states S, an initial
state sinit and a set of sequence diagrams SD(s) for some of states s from S. For each state s of AD we construct an agent s() as follows:

,⎪ Σ '
' ini s. end s. s'(), if ESD(s) and E{s' | s[⟩s'};

{s |s[⟩s }
⎪

s() =
⎨ ini s. end s,	if ESD(s) and ¬E{s' | s[⟩s'};
Σ{s'|s[⟩s'} τ. s'(),	if ¬ESD(s) and E{s' | s[⟩s'};
⎪, τ,	if ¬ESD(s) and ¬E{s' | s[⟩s'}.

Fix a sequence diagram SD(s) with a set of objects O1,... Ok and an object

Oj that receives the last message in SD(s). Given an evaluation ρ of conditions of SD(s), we translate a sequence diagram as follows:

SDs() = (νV ) Σρ∈C∪{Λ}×Bool


SDs();


SDs() = (νV ')ini s. ini Oρ	ini Oρ. end Oρ. end s. SDs();


Oi() =  ρ∈C∪{Λ}×Bool
1	k	j	ρ
Oρ();

Oρ() = ini Oρ. seq (Oρ,MOρ ). Oρ() 6i ∈ {1 ... k} & i /= j;
i	i	ρ	i	i	i
ρ	ρ	ρ	Oρ	ρ	ρ
Oj () = ini Oj . seqρ(Oj ,M j ). end Oj . Oj ().
The overall translation of the system is P = (νV '')sinit() |  s∈S (SDs() |
O∈SDs O())
Here V ' = {ini Oρ ... , ini Oρ, end Oρ}, V '' = {ini si, end si | ESD(si)}
1	k	j
and V is a set of internal variables of a given sequence diagram as it was
defined in the translation of sequence diagrams in section 4.
As an example of the proposed compositional translation consider a system consisting of an abstract level state diagram in Fig. 8 and a sequence diagram in Fig. 1 corresponding to the state s2. The result of the translation is:
s1() = τ. s2()
s2() = ini s2. end s2. s1() + ini s2. end s2. s2()
SDs2 () = (ν ini O1, ini O2, end O2, m) ini s2. ini O1. ini O2. end O2. end s2. SDs2 ()
Os2 () = ini O1. m. end O1. Os2 ()
1	1
Os2 () = ini O2. m. Os2 ()
2	2
P = (ν ini s1, ini s2, end s1, end s2) s1() | SDs2 () | Os2 () | Os2 ()
1	2
Using the translation
Analysis of process algebras speciﬁcations
The aim of the translation of UML specification to π-calculus
is applying analysis techniques available for process algebras to the UML specification. Here we describe how we can make a performance analysis of system specified in UML using the result of our translation. For this type of analysis we add to the messages in a sequence diagram rates yielding a trans- lation in the stochastic π-calculus (see, e.g. [16]) to express those quantitative measures. Stochastic π-calculus differs from the classical π-calculus in section 3 only for the prefix that has the form ⟨π, λ⟩, where λ is the unique parameter of an exponential distribution. In Fig. 9 you can see the translation of a mes- sage extended by rate to the stochastic π-calculus process. The exponential distribution enables us to recover a continuous time Markov chain from which performance measures are computed by using standard numerical techniques [14].


=⇒	(νm)(⟨m, λ⟩| ⟨m, λ⟩)

Fig. 9. Translation of a stochastic message.
WEB based micro-business case study
Here we apply our translation to a real case study that was developed in the context of the DEGAS project [6]. This case study is a WEB based service that is distributed to the users of a community and that enables the realization of micro-business based on peer-to-peer authentication and communication paradigm. Sequence diagrams are used to detail communication intensive parts of the system.
We present here a translation of a part of the specification that describes the e-commerce process as it seen from a buyer. After a seller has been selected the buyer has to handshake with it, and to authenticate. Then the buyer will search the selling list to get the available items, with which he can prepare its basket to be bought and make an e-commerce transaction. The specifica- tion is composed from an e-commerce abstract level state diagram (Fig. 10) and sequence diagrams describing handshaking (Fig. 12, above), authentica- tion (Fig. 12, below) and searching of the seller list (Fig. 11). The result of the translation is shown in Appendix.
For the given case study the performance aspect is critical. Performance issues arise because the communication links are subject to unpredictable throughput variations. Extending the sequence diagrams with quantitative measures on arrows, we can analyze, for example, dependency of request time from number of requests which can appear concurrently in the system as we present in [7].

Conclusion
In this paper we discussed a translation to the π-calculus of non homogeneous UML specifications. We proposed an approach based on sequence and state diagrams. As a prolongation of this investigation it would be interesting to extract this translation for other types of UML diagrams to present more complex software systems. Furthermore, we are currently implementing our translation and integrating it with open-source UML tools.
This paper is a step towards the use of formal methods in the current practice of software development. The main contribution of our extraction of process algebra specifications from UML diagrams is the hiding of formal details from the designers when performing analysis.
Finally, we have implicitly defined formal semantics of UML sequence di-

agrams based on the operational semantics of the π-calculus.
As a last remark, assuming the semantic model of sequence diagrams pre- sented in [18], we claim that a sequence diagram is behaviourally equivalent to the π-calculus process obtained by our translation.

References
Alur, R., Etessami, K., Yannakakis M.: Inference of message sequence charts. Proc. ICSE’00, Limerick, Ireland (2000)
Aredo, D.B.: Semantics of UML Sequence Diagrams in PVS. Proc. UML2000
Booch, G., Rumbaugh, J. and Jacobson, I.: UML notation guide, version 1.1. Rational Software Corporation, Santa Clara, CA (1997)
Broy, M. et al.: From MSCs to statecharts. Distributed and parallel embedded systems. Kluwer Academic Publisher (1999)
Canevet, C., Gilmore, S., Hillston, J., and Stevens, P.: Performance modelling with UML and stochastic process algebras. Proc. UK PEW (2002)
Caraguili C., Piazza D., Mura I. et al.: Specification in UML of case studies. DEGAS project deliverable 24, http://www.omnys.it/degas/ (2002)
Caraguili C., Priami C. et al.: Static and Dynamic Analysis of case studies. DEGAS project deliverable 25, http://www.omnys.it/degas/ (2003)
Dumond, Y., Girardet, D. and Oquendo, F.: A Relationship Between Sequence and Statechart Diagrams. Proc. <<UML>>2000, York, UK (2000)
Gogolla M., Ziemann P. and Kuske S.: Towards an Integrated Graph Based Semantics for UML, Proc. GT-VMT 2002, Barcelona, Spain (2002)
Heckel R. and Sauer S.: Strengthening UML Collaboration Diagrams by State Transformations.
Proc. FASE 2001
Latella, D., Majzik, I., Massink, M.: Toward a formal operational semantics of UML statechart diagrams. Proc. FMOODS’99, Florence, Italy (1999)
Mauw, S. and Reniers M.A.: Operational semantics for MSC’96. Computer networks (Amsterdam, Netherlands), Vol. 31, N17 (1999)
Milner, R.: Communicating and Mobile Systems: the π-calculus. Cambridge Univ. Press (1999)
Nottegar, C., Priami, C. and Degano, P.: Performance Evaluation of Mobile Processes via Abstract Machines. IEEE Trans. on Software Engineering,Vol. 27/10 (2001)
Pettit IV, R.G. and Gomaa, H.: Validation of Dynamic Behavior in UML Using Colored Petri Nets. Proc. UML2000
Priami, C.: Stochastic π-calculus. The Computer Journal. Vol. 38, N 6 (1995)
Roubtsova, E. and Kuiper R. Process semantics for UML component specifications to assess inheritance. Proc. GT&VMT’02, Elsevier Journal, Electronic Notes in Theoretical Computer Science 72(4), Barcelona, Spain (2002)
Uchitel, S. and Kramer J.: A Workbench for Synthesising Behaviour Models from Scenarios. Proc. ICSE’01, Toronto, Canada. ACM Press, (2001)
Whittle, J. and Schumann J.: Generating Statechart designs from scenarious. ICSE’00, Limerick, Ireland (2000)



Fig. 10. E-Commerce State Diagram.




Appendix
Fig. 11. SearchSellerList sequence diagram.

Result of the translation of the UML case study specification. SelectSeller() =
τ. Handshake()
Handshake() = ini Handshake. end Handshake. SelectSeller() + ini Handshake. end Handshake. Authenticate()
Authenticate() = ini Authenticate. end Authenticate. SearchSellerList() SearchSellerList() =
ini SearchSellerList. end SearchSellerList. PrepareBasket() + ini SearchSellerList. end SearchSellerList. SelectSeller()
PrepareBasket() = τ. 0

SDSearchSellerList() = (νV SearchSellerList)ini SearchSellerList. ini DS.
ini SM1. ini SM2.
	ini LM. end DS.
end  SearchSellerList. SDSearchSellerList()


DSSearchSellerList(SearchItem, info) = 

ini DS. PutMes1⟨SearchItem⟩. returnPutMes1(info). end DS. DSSearchSellerList(SearchItem, info)
SM 1SearchSellerList(EncData) = 

ini SM 1.PutMes1(SearchItem). τ. SecureSend1⟨EncData⟩. SecureSend2(EncData). τ. returnPutMes1⟨info⟩.
SM 1SearchSellerList(EncData)
SM 2SearchSellerList(EncData, data, Result) = 

ini SM 2. SecureSend1(EncData, ). τ. SearchList⟨data⟩. PutMes2(Result).τ. SecureSend2⟨EncData, ⟩.
SM 2SearchSellerList(EncData, data, Result)
LMSearchSellerList(data, Result) = 

ini LM. SearchList(data). PutMes2⟨Result⟩. LMSearchSellerList(data, Result)

SDAuthenticate() = (νV Authenticate)ini Authenticate. ini SM 1. ini SM 2.
		 ini BM. end SM 1. end Authenticate. SDAuthenticate()
SM 1Authenticate(EncData, ) = 
ini SM 1. τ. SecureSend(EncData, ). returnSecureSend. end SM 1. SM 1Authenticate(EncData, )
SM 2Authenticate(Buyer, BuyerData) = 
ini SM 2. SecureSend(EncData, ). τ. RetriveLogPwd(Buyer). returnRetriveLogPwd(BuyerData). τ. returnSecureSend.
SM 2Authenticate(Buyer, BuyerData)
BM Authenticate(Buyer, BuyerData) = 
ini BM. RetriveLogPwd(Buyer). τ. returnRetriveLogPwd. BM Authenticate(Buyer, BuyerData)
SDHandshake() = (νV Handshake)ini Handshake. ini SelM.
ini SM1. ini SM 2.
		 ini BM. end SM 1. end Handshake. SDHandshake()
SelMHandshake(.. .) = 

ini SelM. RetrieveURL(Seller). returnRetrieveU RL (Seller URL). RetrieveKey1(Seller). returnRetrieveKey1 (LastSessionKey).
StoreKey(T hisSessionKey, ). returnStoreKey.SelM Handshake(.. .) SM 1Handshake(.. .) = 

ini SM 1. RetrieveURL(Seller). returnRetrieveURL(Seller URL). RetrieveKey1(Seller). returnRetrieveKey1(LastSessionKey). τ.
SecureSend1(EncData, ). SecureSend2(EncData, ). τ. τ.
StoreKey(T hisSessionKey, ). returnStoreKey. end SM 1.SM 1Handshake(.. .) SM 2Handshake(.. .) = 
ini SM 2. SecureSend1(EncData, ). RetrieveKey2(Buyer). returnRetrieveKey2(LastSessionKey). τ. τ. StoreKey(T hisSessionKey, ). τ. SecureSend2(EncData, ).SM 2Handshake(.. .)
BMHandshake(.. .) = 
ini BM. RetrieveKey2(Buyer). returnRetrieveKey2 (LastSessionKey). StoreKey(T hisSessionKey, ). BMHandshake(.. .)
P = (νV ′)(SelectSeller() | SDHandshake() |

SelMHandshake(Seller, Seller URL, LastSessionKey, T hisSessionKey, EncData, ) |
SM 1Handshake(Seller, Seller URL, LastSessionKey, T hisSessionKey) |
SM 2Handshake(LasSessionKey, T hisSessionKey, EncData, Buyer) |
BMHandshake(LasSessionKey, T hisSessionKey, Buyer) |
SDAuthenticate() | SM 1Authenticate(EncData, ) |
SM 2Authenticate(Buyer, BuyerData) |
BM Authenticate(Buyer, BuyerData) |
SDSearchSellerList() | DSSearchSellerList(EncData) |
SM 1SearchSellerList(EncData, data, Result) | SM 2SearchSellerList(EncData, data, Result) | LMSearchSellerList(data, Result)),
where V = {ini Handshake, end Handshake, ini SearchSellerList,

end SearchSellerList, ini Authenticate, end Authenticate} and V (name⟩ is defined as a set of all messages of the sequence diagram ⟨name⟩; ini O for each object ⟨name⟩ and end O for the object of ⟨name⟩ receiving the last message.








Fig. 12. Handshake (above) and Authenticate (below) sequence diagrams.
