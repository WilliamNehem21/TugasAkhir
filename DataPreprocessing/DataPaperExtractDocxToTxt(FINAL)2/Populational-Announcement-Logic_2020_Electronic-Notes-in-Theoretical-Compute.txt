Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 348 (2020) 105–123
www.elsevier.com/locate/entcs
Populational Announcement Logic (PPAL)
Vitor Machado1,2 Mario Benevides1,3
Institute of Mathematics Federal University of Rio de Janeiro
Rio de Janeiro, Brazil

Abstract
Populational Announcement Logic (PPAL), is a variant of the standard Public Announcement Logic (PAL) with a fuzzy-inspired semantics, where instead of specific agents we have populations and groups. The semantics and the announcement logic are defined, and an example is provided. We show validities analogous to PAL axioms and their proofs, and also provide a proof of decidability. We briefly talk about model checking and compare the framework against probabilistic logic. We conclude that the main advantage of PPAL over PAL is the flexibility to work with previously defined agents.
Keywords: epistemic logic, modal logic, knowledge representation


Introduction
Epistemic logics attempt to provide ways to reason about knowledge representation models [18]. C. I. Lewis published back in 1918 the book “Survey of Symbolic Logic”, possibly the first systematic approach to the matter [15].
Later in 1951, Von Wright’s “An Essay in Modal Logic” introduced a concept called “modality” to better represent the semantics of knowledge [22], providing operators such as “usually” and “always” to qualify propositional statements. It is considered the first important work regarding modal logic.
A further development was Dynamic Logic, which reasons about actions and their effects [12]. Dynamic Epistemic Logic (DEL) is conceived to reason about actions that change agents’ knowledge and beliefs. It is not interested in justifying whether something is knowledge or not, but in inferring something from said knowledge.
The first Dynamic Epistemic Logic was proposed independently by [17] and [10], and is called Public Announcement Logic (PAL), a logic which allows simple public

1 We wish to thank the research agencies CNPq, CAPES and FAPERJ for their support.
2 Email: vmachado@cos.ufrj.br
3 Email: mario@cos.ufrj.br

https://doi.org/10.1016/j.entcs.2020.02.007
1571-0661/© 2020 The Author(s). Published by Elsevier B.V.
This is an open access article under the CC BY license (http://creativecommons.org/licenses/by/4.0/).

actions which alter the state of knowledge for its agents. Later [2,3] proposed the Action Model Logic approach, allowing for more complex reasoning.
In [11] Petr H´ajek has investigated a fuzzy variant of the modal logic S5. It introduces the Kripke models for this variant, and also shows deductive systems and completeness proofs. It does not, however, present any sort of model update (i.e. announcements) mechanisms.
A related approach which also reasons about groups of agents, although in a very different manner, is called Term-Modal Logic [8], and its development Dynamic Term-Modal Logic [13]. This logic features variable binding and substitution in a manner similar to Lambda calculus and other calculi. In term-modal logic, ”terms” which can be constants, variables and parameters, are used as modalities, and this way the logic allows one to specify agents via functions relating agents to other agents, allowing for complex agent naming. It contains formulas such as
∀x(second year student(x) → [x]knows calculus(x)), which means ”every second year student x knows calculus” and ∃y([friend of x(y)]birthday(x)) which means ”there exists a friend y of x which knows x’s birthday”.

Motivation and Objectives
This work aims to specify a variation of PAL where knowledge is represented across populations and groups of populations, instead of discrete agents as it is normally done. The motivation behind this is to provide a framework that is capable of dealing with applications where one intends to reason about evolution of knowledge across populations instead of individual agents. It is specially designed for model checking, because it is not necessary to specify agents (or populations in this case) beforehand, and instead these populations can be defined in the middle of the execution by the announcement operators of the language.
To achieve this we have introduced and defined a “fuzzyfied” variant of PAL that allows partial announcements to its agents (called “populations” and “groups”). We formalize the model, language and semantics, and provide axioms analogous to PAL axioms. We then prove that the logic is decidable and demonstrate the complexity of model checking. We give an example where an initial model is given and some announcements are made which modify it, in order to illustrate its applicability in a scenario where knowledge evolves across populations as announcements are made.

Roadmap
In section 2 we introduce Public Announcement Logic (PAL), which serves as the basis for this work. In section 3, we introduce Populational Announcement Logic (PPAL), explain its purpose and differences with respect to PAL and define its language, semantics and model. We also provide axioms which are analogous to PAL axioms and show proofs of their validities. Still in this section, we prove that PPAL is decidable and demonstrate the complexity of model checking, and briefly talk about the actual model checker implementation. Section 4 provides two basic examples of PPAL, showing how the model evolves after an announcement. Section 5 draws a

quick comparison between PPAL and probabilistic logic, outlining similarities and differences between them. Section 6 provides a conclusion, some final remarks and future works.
Public Announcement Logic (PAL)
Here we will briefly provide definitions for the Public Announcement Logic, an extension to Multi-Agent Epistemic Logic which has been investigated in Computer Science to represent and reason about agents or groups of agents’ knowledge and beliefs [7]. It is the first actual Dynamic Epistemic Logic, developed by Plaza in [17].
Language and Semantics
The language is as follows in BNF notation:
ϕ ::= p |¬ϕ | ϕ1 ∧ ϕ2 | Kaϕ | [φ]ϕ
where p ∈ Φ, the set of countably many proposition symbols, and a ∈ A, a finite set of agents. The operators ∨ and → can be derived from the others similarly to propositional logic.
The modal operator of public announcement [φ]ϕ has the intended meaning: “after the announcement of φ, ϕ holds”. The effect of announcing φ publicly is a restriction in the model to contain only states where φ is true.
Definition 2.1 Given a multi-agent epistemic model M = ⟨S, ∼a,V ⟩, the notion of satisfaction M,s |= ϕ is deﬁned as follows:

M,s |= p iff s ∈ V (p)
M,s |= ¬φ iff M,s |= φ
M,s	|=	φ ∧ ψ	iff M,s	|=
φ and M,s |= ψ
M,s |= Kaφ iff ∀sj ∈ S : s ∼a sj ⇒ M, sj |= φ
M,s  |= [φ]ϕ iff M,s  |= φ  ⇒
M|φ, s |= ϕ

where M|φ is a new model obtained by restricting M to have only states where
φ holds.
Populational Announcement Logic (PPAL)
In this section we will introduce the Populational Announcement Logic (PPAL). It’s most distinguishing feature compared to PAL, is that there are populations and groups instead of agents. It works like a “fuzzyfied” version of PAL, where announcements act upon fractions of populations, so it does not make sense to talk explicitly of private or public announcements. It should be noticed that in the limit case where announcements are made to the whole population, PPAL behaves similarly to PAL with public announcements.
This allows us much more flexibility, as we can define the populations of the system beforehand. Also, it allows expressing partial knowledge in a much more natural way.

As a motivation, consider the following example: A famous politician is under suspicion of money laundering and bribery. Elections are coming up, and this politician expects to be re-elected, but people are less willing to vote for him if they are aware of both charges against him. Not everyone in the population is aware of the charges, however. With PPAL we can model announcements made by a TV program which only a certain amount of the population sees, and then we can assert the overall knowledge of the population in regards to the politician. For instance, the formula
[l]0.3KG(l ∧ b)	(1)
represents an announcement made to a fraction of 0.3 of a group G, that the politician is in fact guilty of money laundering (l), and a subsequent knowledge assertion of whether G knows that the politician is corrupt or not (guilty of money laundering and bribery).
We will return to this example in section 4.

Populations and Groups
Definition 3.1 A population represents a collection of individuals. A population
P has size P ∈ R>0.
It is defined as a real number because announcements split populations into a group with two populations, and their sizes will be then fractions of the population’s size.
Note that while a population represents many individuals, actual individuals are never directly expressed or referenced, unlike DEL. Individuals are represented solely by the size of the population. The motivation for this comes down to the fact that we are mostly interested in representing and working with the knowledge of populations or fractions of populations, thus there is no purpose in modelling actual individuals. Next we will define the notion of groups.
Definition 3.2 A group G can be empty, a population or a disjoint set of groups:
G := ∅ | P | {G0, G1,..., Gn}	(2)
The size of a group G is defined as:
⎧

G =	P	if G = P ,
⎪⎪⎩ ΣGi∈G Gi if G = {G0, G1,..., Gn}.
The reason for having two definitions for “groups” and “populations” is the fact that announcements operate splitting groups into populations, as will be seen in section 3.2 and in subsection 4. Having groups allows one to retain a reference to both splits after an announcement is made.

For instance, if an announcement is made for a population P which then becomes group G = {P 1,P 2}, this group represents the original population by retaining its size, but now composed of two distinct populations, one which received the announcement and another one which didn’t.
Since announcements in the logic apply to fractions of a population or group, they work similarly to private announcements. Due to this, the many worlds approach is used. Each population has its own model, representing its current knowledge of the world.
Definition 3.3 A model for a population P, MP = ⟨T, ∼,V ⟩ is composed of a set of states T, a valuation function V :Φ → 2T that maps propositional symbols in Φ into subsets of T, and a family of binary relations over T denoted ∼= {∼P , G∼1, G∼2
,..., ∼ }, where Gi are the groups of which P is aware of.
For example, a relation indicating the doubts of a group G would be contained in the set ∼G . Note that we define ∼ as a set, because these relations will undergo union operations in the group model definitions, and also their ordering is not important.
Definition 3.4 A model MG, for a group G = {G1, G2,..., Gn} is deﬁned over

the set of models MGi
∪···∪ G∼n,V ⟩.
= ⟨T, Gi,V ⟩ of each of its groups, as M
= ⟨T, G∼1
∪ G∼2


Syntax and semantics
This section presents the syntax and semantics of the PPAL. We begin by defining the language and then proceed to define semantically each of the operators of the logic.
Definition 3.5 The language is as follows in BNF notation:
ϕ ::= p | ¬ϕ | ϕ1 ∧ ϕ2 | ϕ1 ∨ ϕ2 | ϕ1 → ϕ2 |KGϕ | BGϕ | [ϕ1]rϕ2	(3)
where r ∈ U = [0, 1], G denotes a group and p ∈ Φ.
The modal operators have the following intended meaning:
KGϕ and BGϕ: “the group G knows/believes that ϕ is true”;
[ϕ1]rϕ2: “ϕ2 is true after the announcement of ϕ1 to fraction r of the individuals”.
The latter describes a partial announcement which deﬁnes two new groups, only one of which received the announced information.
We can now define the semantics of the operators, and we start by defining the valuation function V introduced in definition 3.3. In order to achieve that, we define an evaluation function e : p × (MG, s) → U as follows:
e(p, (MG, s)) = 1 if s ∈ V (p) , and 0 otherwise	(4) where p ∈ Φ, MG is a model for G, s is a state and U is the unit interval [0, 1].

Below, we give some properties about the fuzzy functions that are used in the definitions of satisfaction. At this point we choose not to define a particular fuzzy semantics and instead define classes for each operation. One can choose any semantics which satisfies the following properties, and we provide an example for each of the classes.
It is also important to note that this work is concerned with model checking and for that the notion of satisfaction is enough. For this reason we did not define the consequence relation.
Fuzzy Negation
A unary operation NOT : U → U is a fuzzy negation if:


NOT (0) = 1;
NOT (1) = 0;
x ≤ y → NOT (y) ≤ NOT (x).

For instance, a possible negation function is NOT (x)=1 − x.
Fuzzy Conjunction
A binary operation AND : U 2 → U is a fuzzy conjunction if:
AND(x, y)= AND(y, x);	• y ≤ z → AND(x, y) ≤ AND(x, z);
AND(x, AND(y, z)) = AND(AND(x, y),•z)A; ND(x, 1) = x.
These also define precisely the class of t-norm functions, which are widely used in fuzzy logics as they are considered “well-behaved” functions [4]. For instance, a possible conjunction function is AND(x, y)= min{x, y}.
Fuzzy Disjunction
A binary operation OR : U 2 → U is a fuzzy disjunction if:


OR(x, y)= OR(y, x);
OR(x, OR(y, z)) = OR(OR(x, y), z);
y ≤ z → OR(x, y) ≤ OR(x, z);
OR(x, 0) = x.

These also define precisely the class of t-conorm functions, analogous to the t-norm class. For instance, a possible disjunction function is OR(x, y)= max{x, y}.
Fuzzy Implication
A binary operation IMP : U 2 → U is a fuzzy implication if:


x ≤ y → IMP (x, z) ≥ IMP (y, z);
y ≥ z → IMP (x, y) ≥ IMP (x, z);
x > y → y ≤ IMP (x, y) ≤ x;
x ≤ y → IMP (x, y)= 1.

For instance, a possible implication function is IMP (x, y)= min{1, 1 − x + y}, also known as the L- ukasiewicz implication.

Fuzzy Knowledge Assertion
A ternary operation K : F × (MS, s) × G → U , where F is the set of formulas of the PPAL, is a fuzzy knowledge assertion if:

if G = P then ∀sj ∈ T|s ∼G sj[E
if G = P then ∀sj ∈ T|s ∼G sj[E
′ (ϕ)=1 → K(ϕ, (MS, s),P ) = 1];
′ (¬ϕ)=1 → K(ϕ, (MS, s),P ) = 0];

K(ϕ, (MS, s), G) ≤ maxG′∈G{K(ϕ, (MS, s), Gj)};
K(ϕ, (MS, s), G) ≥ minG′∈G{K(ϕ, (MS, s), Gj)}.
For instance, a possible knowledge assertion function is


⎧⎪ Σ

G′ K(ϕ, (M

, s), Gj) if G /= P ,

⎪⎨	G′∈G G	S
		
⎪⎪⎩ 0	otherwise.
Intuitively, it means that the knowledge of a group is equal to the weighted average knowledge of its contained groups, is equal to 1 when the group is a single population and ϕ is true in every state connected to state s via ∼, and 0 otherwise. A single population knows something only when it is true in every conceivable world this population contemplates.

Fuzzy Belief Assertion
A ternary operation B : F × (MS, s) × G → U , where F is the set of formulas of the PPAL, is a fuzzy belief assertion if:

if G = P then ∃sj ∈ T|s ∼G sj[E
if G = P then ∃sj ∈ T|s ∼G sj[E
′ (ϕ)=1 → B(ϕ, (MS, s),P ) > 0];
′ (¬ϕ)=1 → B(ϕ, (MS, s),P ) < 1];

if	G = P	then	∀sj ∈ T|s ∼G
K(ϕ, (MS, s),P )];
sj[E
MS,s
′ (ϕ) = 1 → B(ϕ, (MS, s),P ) =

B(ϕ, (MS, s), G) ≤ maxG′∈G{B(ϕ, (MS, s), Gj)};
B(ϕ, (MS, s), G) ≥ minG′∈G{B(ϕ, (MS, s), Gj)}.
For instance, a possible population belief assertion function is



B(ϕ, (M


, s), G)= 
⎧⎪⎪⎨ Σ


G′ B(ϕ, (M
G
EMS,s′ (ϕ)
, s), Gj) if G /= P ,
if G /= ∅,

S	s′∈Ns	Ns
⎪⎩ 0	otherwise.

where Ns =  ′	s are the neighbours of s via relation ∼.
j	G
s ∈T|s~s
Which is functionally similar to K, but allowing any number in the interval [0, 1].
For example, if in half of the states connected to state s via ∼G , ϕ evaluates to 1 and

in the other half to 0, then B(ϕ, (MS, s),P ) = 0.5. And also similarly to K, the belief of a group is equal to the weighted average beliefs of its contained groups.
With these functions, we can then introduce the satisfaction definitions as follows:
EMG,s(p)= e(p, (MG, s))	EMG,s(чϕ)= NOT (EMG,s(ϕ))
EMG,s(ϕ Λ ψ)= AND(EMG,s(ϕ), EMG,s(ψ))	EMG,s(ϕ V ψ)= OR(EMG,s(ϕ), EMG,s(ψ))
EM ,s(ϕ → ψ)= IMP (EM ,s(ϕ), EM ,s(ψ))	EM ,s(KG' ϕ)= K(ϕ, (MG, s), G′)
EM ,s(BG' ϕ)= B(ϕ, (MG, s), G′)	EM ,s([ϕ]rψ)= IMP (EM ,s(ϕ), EM ∗ ,s(ψ))
where ∃G1, G2 such that
G∗ = {G1, G2}	MG∗ = {MG1 , MG2 }
MG1 = MG|ϕ	MG2 = MG

G1 = Gr	G2 = G(1 − r)
MG|ϕ = ⟨T, ∼j,V ⟩, where ∼j= {s ∼ sj ∈ ∼| MG,s |= ϕ and MG, sj |= ϕ}. That is, it is a new model obtained from MG by keeping only relations between states where ϕ holds in both of them.
Some Validities
In this section we prove that some formulas are valid with respect to our semantics. All these formulas are analogous to PAL axioms.
Definition 3.6 We say that a formula ϕ is valid if for all evaluation functions e, all groups G and all states s, EMG ,s(ϕ)= 1.
Valid formulas
In this section we prove that some valid formulas of PAL (axioms), when re-written in PPAL are still valid.
Theorem 3.7 The following formulas are valid in PPAL.


[φ]rp ↔ (φ → p);
[φ]r¬ψ → (φ → ¬[φ]rψ);
[φ]r(ψ ∧ χ) ↔ ([φ]rψ ∧ [φ]rχ);
[φ]rKG ψ ↔ (φ → KG [φ]rψ);
	If φ is valid, infer [ψ]rφ is also valid.

The proofs are derived by direct application of evaluation functions and operator definitions, with the exception of iv which required us to assume the suggested operator implementation. For ease of visualization, we will write functions of the form e(ϕ, (MG , s)) simply as e(ϕ), and EG(ϕ) instead of EMG,s(ϕ).
Proof. Formula i.
EG ([φ]rp → (φ → p)) = IMP (EG ([φ]rp), EG (φ → p)) = IMP (e(p, (MG∗ , s)),IMP (e(φ), e(p))	(5)
Since the valuation function V is the same in MG∗ and MG , we can safely say that
e(p, (MG∗ , s)) = e(p), which gives
IMP (e(p),IMP (e(φ), e(p))	(6)

Given that p is a proposition, we consider each case and use the rules defined in 3.6:
p =1 
· IMP (1,IMP (e(φ), 1)) = IMP (1, 1) = 1;
p =0 
· IMP (0,IMP (e(φ), 0)) = IMP (0, 0) = 1;
Analogously one can demonstrate that the → direction is also valid:
p =1 
· IMP (IMP (e(φ), 1), 1) = IMP (1, 1) = 1;
p =0 
· IMP (IMP (e(φ), 0), 0) = IMP (0, 0) = 1;
Therefore it follows that [φ]rp ↔ (φ → p) is valid.	2
Proof. Formula ii.
EG ([φ]rчψ → (φ → ч[φ]rψ)) = IMP (EG ([φ]rчψ), EG (φ → ч[φ]rψ))
= IMP (EG∗ (чψ),IMP (EG (φ), EG (ч[φ]rψ))) = IMP (NOT (EG∗ (ψ)),IMP (EG (φ),NOT (EG ([φ]rψ))))s
= IMP (NOT (EG∗ (ψ)),IMP (EG (φ),NOT (EG∗ (ψ))))
(7)
Consider the following cases:
NOT (EG∗ (ψ)) ≥ EG (φ)
by the fourth rule in 3.6, we have that
IMP (EG (φ),NOT (EG∗ (ψ))) = 1.
we remain with IMP (NOT (EG∗ (ψ)), 1), which again by the fourth rule in 3.6, must be equal to 1.
NOT (EG∗ (ψ)) < EG (φ)
by the third rule in 3.6, we have that
IMP (EG (φ),NOT (EG∗ (ψ))) ≥ NOT (EG∗ (ψ)).
since the left side of the outermost implication is
NOT (EG∗ (ψ)), and the right-side is ≥ NOT (EG∗ (ψ)), by the fourth rule in 3.6, the result be equal to 1.
Therefore it follows that [φ]r¬ψ → (φ → ¬[φ]rψ) is valid.	2
Proof. Formula iii.
To prove formula iii we show that both sides evaluate to the same expression.
First, consider the evaluation of the left-hand side:
EG ([φ]r(ψ ∧ χ)) = EG∗ (ψ ∧ χ)= AND(EG∗ (ψ), EG∗ (χ))	(8)

And the right-hand side:
EG ([φ]rψ ∧ [φ]rχ)= AND(EG ([φ]rψ), EG ([φ]rχ))
= AND(EG∗ (ψ), EG∗ (χ))


(9)

Since equations 8 and 9 are equal, we can conclude that formula iii is valid. 2

Proof. Formula iv.
EG ([φ]rKG ψ → (φ → KG [φ]rψ)) = IMP (IMP (EG (φ), EG∗ (KG ψ)),IMP (EG (φ), EG (KG [φ]rψ)))
= IMP (IMP (EG (φ),K(ψ, (MG∗ , s), G)),IMP (EG (φ),K([φ]rψ, (MG , s), G)))

Σ G′
′	Σ G′	r
(10)
′

= IMP (IMP (EG (φ),


G' ∈G G
K(ψ, (MG∗ , s), G )),IMP (EG (φ),


G' ∈G G
K([φ] ψ, (MG , s), G )))

We can assume without loss of generality that Gj is a population, because the formula is recursively evaluated until it necessarily reaches a population. Therefore, the first K function will evaluate to 1 if and only if:


6sj
∈ T|s G′ sj
→ EMG∗ ,s′ (ψ)	(11)

And the second K function will evaluate to 1 if and only if:


6sj
∈ T|s G′ sj
→ EMG ,s′ ([φ] ψ)= 6s
∈ T|s G′ sj
→ (EMG ,s′ (φ) → EMG∗ ,s′ (ψ))
(12)

States where φ does not hold will not be ranged over in the first function, and will result in 1 in the second function because EMG ,s′ (φ) = 0. Therefore, both functions will yield the same result, and we can conclude that formula iv is valid.	2

Proof. Formula v.
EG ([ψ]rφ)= EG∗ (φ)	(13)

Since φ is valid by hypothesis, it is valid in any model including MG∗ . Therefore it must be the case that EG∗ (φ)=1 and [ψ]rφ is valid.	2

Non-valid formulas
The following formulas are analogous to some PAL axioms, but are not valid in PPAL:
[φ]rчψ → (φ → ч[φ]rψ); (note that this is similar to the valid formula ii)
′	′
[φ] [ψ] χ x [φ Λ [φ] ψ] χ.
A counterexample for i would be the case where NOT (EG∗ (ψ)) < EG (φ) in the
→ direction. The evaluation equation would be:
EG ((φ → ч[φ]rψ) → [φ]rчψ)= IMP (IMP (EG (φ),NOT (EG∗ (ψ))),NOT (EG∗ (ψ)))
(14)
Given NOT (EG∗ (ψ)) <  EG (φ), we get that IMP (EG (φ),NOT (EG∗ (ψ))) ≥
NOT (EG∗ (ψ)) from the third rule in 3.6. Therefore, we have that
EG ([φ]rчψ → (φ → ч[φ]rψ)) ≤ IMP (EG (φ),NOT (EG∗ (ψ)))	(15)
This can be seen intuitively by the fact that in PAL the inference is standard modus ponens (where F → F = T ). In PPAL however, the implication rules do not necessarily take two “falsy” values and evaluates to 1.

To see why ii is not valid, just consider any case where r = 0, for instance. These announcements can be safely discarded, since they generate a group composed of an empty group ∅, and a group identical to the one from before the announcement, effectively making no difference in calculations. As we discard this announcement, we remain with:
′	′
[ψ] χ x [φ Λ ψ] χ	(16)
which is obviously not valid since ψ /= φ Λ ψ. This is an unsurprising result, since announcements in PPAL are very different from the public announcements of PAL.

Decidability
An important aspect of model checking a logical system is that of decidability. In this section we show that the evaluation of any formula of the PPAL language over a finite model is in fact decidable. Notice, however, that for lemma 3.9 and theorem 3.10 we assume that the knowledge and belief operators are evaluated in a polynomial number of evaluations for each of the group’s subgroups, which is how the suggested implementation for these operators are defined. We use induction over the size s of the formula.
Definition 3.8 The size s of a formula is deﬁned as follows:



s(p)= 1;
s(ϕ1Λϕ2)= s(ϕ1∨ϕ2)= s(ϕ1 → ϕ2)
= s(ϕ1)+ s(ϕ2)+ 1;
s(KGϕ)= s(BGϕ)= s(ϕ)+1+[ G |;

s([ϕ1]rϕ2)= s(ϕ1)+s(ϕ2)+1+[ G |.

It is important to notice that the size of a formula s must be a natural number, and the size of a group G is a real number. This is why we use [ G |.
Lemma 3.9 Let ϕ be a PPAL formula, MG a model and s a state. Then, we compute EMG,s(ϕ) in a ﬁnite number of steps.
Proof. We prove by induction on the size s of ϕ.
Next, we can proceed to the induction basis step where s = 1, that is, the case of a formula consisting of a single propositional symbol. EMG,s(p)= e(p, (MG, s)) evaluates to 1 or 0 in a finite model, and therefore is decidable.
We then consider the induction hypothesis to be that any formula with size s is decidable. Now it remains necessary to take the inductive step, assuming the induction hypothesis and proving that formulas with size s + δ are also decidable, where δ ∈ N>0.
Inductive step:
EMG,s(чϕ)= NOT (EMG,s(ϕ)): NOT evaluates to a value in U for any input in U . Since EMG,s(ϕ) is decidable by hypothesis, this formula is decidable. EMG,s(ϕ Λ ψ), EMG,s(ϕ ∨ ψ) and EMG,s(ϕ → ψ) are all decidable due to the same arguments;
EMG,s(KG′ ϕ)= K (ϕ, (MG, s), Gj):

It is trivially decidable when Gj = ∅, because its evaluation will always be equal to 0;
It is decidable when Gj = P , as the formula is resolved via calculations of
EMG,s′ (ϕ) which is decidable by hypothesis;
In the case where Gj = {Gj , Gj ,..., Gj }, the sizes |Gj| are strictly smaller
0	1	n	i
than |Gj| because by definition the group Gj is composed of a disjoint
set of groups. Due to this, s(KG′ ϕ) < s(KG′ ϕ) and KG′ ϕ is decidable
i	i
by hypothesis. KG′ ϕ is resolved via calculations of KG′ ϕ, therefore, the

EM
formula is decidable.
,s(BG′ ϕ)= B (ϕ, (MG, s), Gj):

It is trivially decidable when Gj = ∅, because its evaluation will always be equal to 0;
When Gj = P , the sum ranges over all neighbours sj of state s, but since the model is finite and EMG,s′ (ϕ) is decidable by hypothesis, it is decidable;
In the case where Gj = {Gj , Gj ,..., Gj }, the same argument used in b
0	1	n
shows this formula is decidable.
	EMG,s([ϕ]rψ)= EMG∗ ,s(ψ): MG is finite and therefore MG∗ is also finite as it contains exactly twice the number of elements in MG. To compute MG∗ we need to calculate EMG,s(ϕ) for every s ∈ T , which are decidable by hypothesis. EMG∗ ,s(ψ) is also decidable by hypothesis. Also note that it is not possible to write a formula that divides the group indefinitely, as that would require us to write down an infinite number of announcements. Therefore, the formula is decidable.
Hence we have covered every possible case and shown that they are all decidable, therefore successfully showing that any formula of the PPAL language over a finite model is decidable using the specified operator functions.	2
Notice however, that we cannot express recursive formulas, such as ϕ := [ϕ]rψ or
ϕ := [ψ]rϕ, they are not in PPAL language.
The above proof gives a clue of the model checking algorithm. This is a standard recursive model checking algorithm, which works top down labelling each state with a sub-formula until a propositional symbol is reached and then it returns its truth value.
Theorem 3.10 Given a ﬁnite model MG, a formula φ and a state s. The complexity of evaluating EMG,s(φ) is polynomial in the size of φ times the size of the model MG.
Proof. It is similar to the proof of lemma 3.9.
We now present the case for the announcement modal operator, and for the knowledge and belief operators.
Inductive step:
φ = KG′ ϕ. We need to calculate EMG,s(KG′ ϕ)= 
= K (ϕ, (MG, s), Gj):
It is straightforward when Gj = ∅, because its evaluation will always be equal to 0;

If Gj = P , as the formula is evaluated via calculations of EM
,s′ (ϕ), for

each neighbor state sj, which is polynomial in the size of ϕ times the size
of the model MG;
In the case where Gj = {Gj , Gj ,..., Gj }, the sizes |Gj| are strictly smaller
0	1	n	i
than |Gj| because by definition the group Gj is composed of a disjoint set
of groups. Due to this, s(KG′ ϕ) < s(KG′ ϕ) and KG′ ϕ is polynomial by
i	i
hypothesis. KG′ ϕ is resolved via a polynomial number of calculations of
K ′ ϕ, therefore, it is polynomial in the size of the formula times the size of
i
the model.
φ = BG′ ϕ. We need to calculate EMG,s(BG′ ϕ)= 
= B (ϕ, (MG, s), Gj): this case is analogous to the previous case.
φ = [ϕ]rψ. We need to calculate EM ,s([ϕ]rψ)= EM ∗ ,s(ψ): MG is finite and therefore MG∗ is also finite as it contains exactly twice the number of elements in MG. To compute MG∗ we need to calculate EMG,s(ϕ) for every s ∈ T , which are polynomial in the size of the model MG times the size of ψ. EMG∗ ,s(ψ) is also polynomial by hypothesis.
The cases for the propositional symbols (basis) and the ч, Λ, ∨ and → operators are straightforward and are omitted due to space constraints. In subitem c of item i, we assumed that the knowledge and belief operators are evaluated in a polynomial number of evaluations for each of the group’s subgroups.
2

Model Checker
A general-purpose Java library implementing the aforementioned language and semantics, and a model checker have been developed. Both programs are covered by unit and integration testing to ensure consistency with the PPAL language and semantics. The source-code of both library and model checker are available on GitHub 4 .
The main current implementations of model checkers available for epistemic logics are MCK [9], MCMAS [16] and DEMO [21]. A recent development called SMCDEL [20] formalizes a new structure to represent DEL models which allows for symbolic model checking, a model which uses binary decision diagrams (BDDs)
[1] to represent models instead of having every state directly represented in the system. Due to this, SMCDEL also provides better performance over the other model checkers.
The Corrupt Politician
In this section we continue the example introduced in section 3, where a simple model is established and some assertions are made to probe the knowledge represented by this model. For clarity’s sake, we name the states with the set of propositional

4 https://github.com/vittau/PPAL


	 

Initial state.
Model MG∗ (P 1’s to the left, P 2’s to the right). Fig. 1. The “Corrupt Politician” models.

symbols, or their negation, that hold in it. For instance, state {a, чb} is the state where a and чb are true. Also, we will omit the full math for some of the simplest equations due to space constraints.

Initial Model

Suppose an initial model composed of a single population P with size P = 1, two propositions l (money laundering) and b (bribery), and a real state r = {l, b}, which means the politician in fact is guilty of the charges against him. The evaluation function is the same as defined before. This model is as shown in figure 1a.
For brevity, let us call ϕ = l Λ b here onwards. As expected if we assert how much of the population would not vote on the politician, that is, if we ask:
EMP ,r(KP (ϕ))	(17)
It will evaluate to 0, as there are P edges connecting the state r to other states.

First Announcement
Then, a TV program aired revealing the politician in fact did money laundering, but given that only 30% of the population watched the program, only a fraction of the population is now aware of this fact. This is equivalent to the announcement [l]0.3, for which we define the resultant group G∗ = {P 1,P 2}, which is a group containing the two populations resulting from the announcement: P 1 who received the announcement, and P 2 who did not. Figure 1b shows the resultant model MG∗ .
If we were now to assert how much of the population would not vote on the politician, we would be asking:
EM ,r([l]0.3KG(ϕ))	(18)
The announcement [l]0.3 generates group G∗, which contains populations P1 and P2, where the former received the announcement. KG(ϕ) will still evaluate to 0, as there are still P1 and P2 edges connecting the state r to other states. That is, both populations remain in doubt about whether r is the real state or not.


 
Fig. 2. Model MG∗∗ . G1’s model to the left, population above received both announcements, below received only the first one; G2’s to the right, population above received only the second announcement, below received none.
We could also make an assertion in regards to the belief of the population, that
is:
EM ,r([l]0.3BG(ϕ))	(19)
To evaluate the belief we must evaluate EMG,r(BG(ϕ)), which expands into


B(ϕ, (MG, r), G)= Σ


′
B(ϕ, (MG, r), G′)= 0.3
EM  ,r(ϕ)
+ 0.7
EMP 2 ,r (ϕ)


G' ∈G G
= 0.3 · 1/2+ 0.7 · 1/4= 0.325
r' ∈Nr	Nr
r' ∈Nr	Nr
(20)

The first sum evaluates to 1/2 because out of two neighbour states to r ({l, b} itself and {l, чb}), ϕ is only true in r. The second has all four states as neighbours, but ϕ is only true in r again. The result 0.325 demonstrates a small belief at this moment that the politician is in fact corrupt.
Second Announcement
Now, let us consider another TV program aired, and this time covering 40% of the same original population, and it was told that the politician is in fact guilty of bribery. This corresponds to the announcement [b]0.4, for which we define the resultant group G∗∗ = {G1, G2}, which is a group containing the two groups resulting from the announcement: G1 who received the announcement, and G2 who did not. The model resulting from both announcements is shown in figure 2.
If we were now to assert how much of the population would not vote on the politician, we would be asking:
EM ,r([l]0.3[b]0.4KG(ϕ))	(21)
At this moment the assertion would evaluate to 0.12, since there are no more edges connecting the state r to anything else for population P 11 in G1.
This example shows how pieces of knowledge can build up to create useful information for certain fractions of the populations, due to them having being exposed enough to these pieces, and how it might not be intuitive to find out how much exactly of a population knows a certain fact.

Comparison with Probabilistic Logic
It might seem reasonable to draw a comparison between PPAL and the probabilistic logic introduced in [6,5], and further expanded with an announcement operator in [14], as both present multi-valued semantics for reasoning about knowledge. However, we will show that there are significant differences, especially in how these announcements work and the results they can achieve.
Formulas in this logic are as follows:
ϕ ::= p |T| чϕ | ϕ Λ ϕ | Kiϕ | [ϕ1]ϕ2 | a1wi(ϕ)+ ... + akwi(ϕ) ≥ c
where p ∈ Φ (the set of primitive propositions), i ∈A (the set of agents), and wi(ϕ) are weight terms.
A model is defined as M = (S, π, κ1, ..., κn, P), where:


S is a set of states;
π is a valuation function;
κi(s) is  an  equivalence relation.
(s, t) ∈ κi(s) if in a world s agent
i considers t a possible world;
μi,s is a probability assignment for the states in κi(s).

Considering the “Corrupt politician” example from before, a possible model is as follows:


S = {s1, s2, s3, s4};
π :Φ '→ 2S;
κi(s) is induced by an uniform distri- bution;
π(l)= {s2, s4};
π(b)= {s3, s4};
lM = {s2, s4};
bM = {s3, s4}.

For example, an expression which checks whether group G knows that l and b is evaluated as follows:
(M, s) |= KG(l Λ b)	(22)
The states where lΛb holds are represented by the expression (lΛb)M = lM ∩bM =
{s4}. Therefore the expression is false, because ∃t ∈ κG(s) such that (M, t) /|= l Λ b, which are the remaining states {s1, s2, s3}.
The major differences appear, however, when we want to make announcements that are equivalent to the ones in the PPAL. It might seem like weight formulas are a viable way to make announcements which behave similarly to the partial announcements in PPAL. However, while an expression containing an announcement such as this one is syntactically valid:
(M, s) |= [wG(l) ≥ 0.5]KGb	(23)
It provides little practical use because, to be useful, such an announcement requires that states where agent i assigns a probability higher or equal than 0.5 to

l exist in the first place. The PPAL on the other hand, instantiates a new group which receives the announcement, no matter how small that group might be. The announcements in this probabilistic logic cannot increase the quantity of states in the model, while PPAL announcements create new groups and new models for these groups.

Final Remarks and Future Works
In this work we introduced and defined a variant of PAL that allows partial an- nouncements to its populations. The main advantage of PPAL over DEL and PAL is the flexibility to work with previously defined agents. It is possible to define an initial population and have it evolve in a more natural way that doesn’t require a formal initial definition of every agent on the system. Therefore we believe it can be a more appropriate logic for practical use, as it would be much easier to manage a knowledge model.
Lastly, we provide a social networks oriented framework which expands the logic making it easier to model simple interactions in a group based social network. The example showcases the kind of practical application that is possible to reason with using this logic.
We also believe this work expands horizons for the definition of “dynamic” logic, as not only accessibility relations are dynamic, but the agents of the world themselves are changing and evolving. As such, it is a worthwhile topic of theoretical discussion, and not only of interest for model checking applications.

Social networks
Social networks are a growing topic of study since the Internet social network services boom starting in the late 1990’s with networks such as Friendster, MySpace, LinkedIn, etc... These services allow people from all over the world to interact in meaningful ways, and as such have gained tremendous importance in popular culture in recent years.
In a broader sense, these networks are commonly defined by a set of entities (individuals, communities or societies), relations between pairs of entities, and a set of social interactions. For instance, in a recent social network such as Facebook, an entity is a person, user of the service; the relations between pairs of entities are the friendship relations and the social interactions are posts which appear on the user’s timeline.
We are currently investigating extensions to the PPAL for social network appli- cations, such as modelling how peer pressure affects the evolution of preferences in a group, or how fake news spread among groups. Perhaps in an approach similar to the one introduced in [19], which defines social networks in terms of “layers” with different similarity levels between agents, or in this case groups, based on their “features” or “interests”.

Symbolic Model Checking
We did not attempt symbolic model checking, a way to represent all reachable states using only sets of states and formulas for transition relations, which can improve performance. One such approach is based on the previously mentioned BDDs, which provide a compact way to represent and check valuations in Boolean functions, and equivalent Boolean sub-expressions are uniquely represented.

References
Akers, S. B., Binary decision diagrams, IEEE Trans. Comput. 27 (1978), pp. 509–516.
Baltag, A. and L. S. Moss, Logics for epistemic programs, Synthese 139 (2004), pp. 165–224.
Baltag, A., L. S. Moss and S. Solecki, The logic of public announcements, common knowledge and private suspicions, Proceedings of TARK’98 (1998), pp. 43–56.
	Esteva, F., L. Godo and C. Noguera, First-order t-norm based fuzzy logics with truth-constants: distinguished semantics and completeness properties, Annals of Pure and Applied Logic 161 (2009),
pp. 185–202.
Fagin, R. and J. Y. Halpern, Reasoning about knowledge and probability, J. ACM 41 (1994), pp. 340–367.
URL http://doi.acm.org/10.1145/174652.174658

Fagin, R., J. Y. Halpern and N. Megiddo, A logic for reasoning about probabilities, Information and Computation 87 (1990), pp. 78–128, special Issue: Selections from 1988 IEEE Symposium on Logic in Computer Science.
URL http://www.sciencedirect.com/science/article/pii/089054019090060U
Fagin, R., J. Y. Halpern, Y. Moses and M. Y. Vardi, Reasoning about knowledge (1995).
Fitting, M., L. Thalmann and A. Voronkov, Term-modal logics, Studia Logica 69 (2001), pp. 133–169.
URL https://doi.org/10.1023/A:1013842612702

	Gammie, P. and R. van der Meyden, MCK: Model checking the logic of knowledge, Computer Aided Verification 3114 (2004), pp. 479–483.
Gerbrandy, J. and P. W. Groeneveld, Reasoning about information change, Journal of Logic, Language and Information (1997), pp. 147–169.
Ha`jek, P., On fuzzy modal logics s5(c), Fuzzy Sets and Systems 161 (2010), pp. 2389–2396, a tribute to Ulrich Ho¨hle on the occasion of his 65th birthday.
URL http://www.sciencedirect.com/science/article/pii/S0165011409005247
Harel, D., “Dynamic Logic,” Springer Netherlands, Dordrecht, 1984 pp. 497–604.
Kooi, B., Dynamic term-modal logic, in: In A Meeting of the Minds (2007), pp. 173–186.
Kooi, B. P., Probabilistic dynamic epistemic logic, Journal of Logic, Language and Information 12
(2003), pp. 381–408.
URL https://doi.org/10.1023/A:1025050800836
Lewis, C. I., A survey of symbolic logic (1918).
Lomuscio, A. and F. Raimondi, MCMAS: A model checker for multi-agent systems, Tools and Algorithms for the Construction and Analysis of Systems 3920 (2006), pp. 450–454.
Plaza, J. A., Logics of public communications, Synthese 158 (1989), pp. 165–179.
Shapiro, S. C., Knowledge representation, Encyclopedia of Cognitive Science 2 (2003), pp. 671–680.
	Smets, S. and F. R. Vel`azquez-Quesada, The creation and change of social networks: a logical study based on group size, Lecture Notes in Computer Science (LNCS) (2017).
	van Benthem, J., J. van Eijck, M. Gattinger and K. Su, Symbolic model checking for dynamic epistemic logic, in: W. van der Hoek, W. H. Holliday and W.-f. Wang, editors, Logic, Rationality, and Interaction, Lecture Notes in Computer Science 9394, Springer Berlin Heidelberg, 2015 pp. 366–378.


	van Ditmarsch, H., J. van Eijck, I. Hern`andez-Ant`on, F. Sietsma, S. Simon and F. Soler-Toscano, Modelling cryptographic keys in dynamic epistemic logic with demo, 10th International Conference on Practical Applications of Agents and Multi-Agent Systems 156 (2012), pp. 155–162.
von Wright, G. H., An essay in modal logic, Philosophy 28 (1953), p. 76–79.
