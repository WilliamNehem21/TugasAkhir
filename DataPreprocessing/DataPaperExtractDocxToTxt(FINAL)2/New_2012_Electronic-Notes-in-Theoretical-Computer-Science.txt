Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 286 (2012) 17–42
www.elsevier.com/locate/entcs
New
Dexter Kozen1,2
Department of Computer Science Cornell University
Ithaca, New York 14853–7501, USA

Abstract
We propose a theoretical device for modeling the creation of new indiscernible semantic objects during program execution. The method fits well with the semantics of imperative, functional, and object-oriented languages and promotes equational reasoning about higher-order state.
Keywords: Operational semantics, functional programming, imperative programming, object-oriented programming, indiscernibles


Introduction
There are many situations in computing in which we want to create something new. Often we do not really care exactly what is created, as long as it has the right properties. For example, when allocating a new heap cell, we do not care exactly what its address in memory is, but only that we can store and retrieve data there. For that purpose, any heap cell is as good as any other. In object- oriented programming, when we create a new object of a class, we only care that it has the right fields and methods and is different from every other object of that class previously created. In the λ-calculus, when we α-convert to rename a bound variable, we do not care what the new variable is as long as it is fresh.
As common as it is, the intuitive act of creating a new object out of nothing does not fit well with set-theoretic foundations. Such situations are commonly modeled as an allocation of one of a previously existing collection of equivalent candidates. One often sees statements such as, “Let Var be a countable set of variables. . . ,” or, “Let L be a countable set of heap cells. . . ” The set is assumed to exist in advance

1 Thanks to Kamal Aboul-Hosn, Robert Constable, Nate Foster, Jean-Baptiste Jeannin, Konstantinos Mamouras, Andrew Myers, Dirk Pattinson, Mark Reitblatt, Alexandra Silva, Aaron Stump, and all the members of the PLDG seminar at Cornell.
2 Email: kozen@cs.cornell.edu

1571-0661 © 2012 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2012.08.003

of its use and is assumed to be large enough that fresh elements can always be obtained when needed. Standard references on the semantics of objects also tend to treat object creation as allocation [1,23,25].
The difficulty here is that the candidates for allocation should be theoretically indiscernible, whereas real implementations must somehow make a deterministic choice. But to choose requires some way of distinguishing the chosen from the un- chosen, thus the candidates cannot be indiscernible after all. Moreover, cardinality constraints often interfere with closure conditions on the language. For example, we only need a countable set of variables to represent an infinitary λ-term, but if all available variables already occur in the term, there would be none left over in case we needed a fresh one for α-conversion. One could permute the variables to free one up, but that is awkward.
The issue is related to the philosophical problem of the identity of indiscernibles. Leibniz proposed that objects that have all the same properties must in fact be the same object. Although the subject of much debate in the philosophical litera- ture [8,9,14], it is certainly desirable in programming language semantics, especially object-oriented programming, to allow the existence of distinct but indiscernible se- mantic objects. But it can also be the source of much confusion, as is well known to anyone who has ever tried to explain to introductory Java students why one should never compare strings with ==.
The issue also arises in systems involving terms with variable binders, such as quantificational logic and the λ-calculus. We would like to treat bound variables as indiscernible for the purposes of α-conversion and safe (capture-avoiding) substitu- tion. Several devices for the generation of fresh variables have been proposed, both practical and theoretical, the earliest possibly being the gensym facility of LISP. Popular variable-avoiding alternative representations of λ-terms include de Bruijn indices and Stoy diagrams [5]. The NuPrl system [3,7] has a facility for generating nonces, or objects for which nothing can be tested except identity. The ν-calculus of Pitts and Stark has a similar objective [6,26]. Nominal logic [11,12,27] is a logical system for reasoning about syntactic terms with binders.
In this paper we propose a device for creating new indiscernible objects in a semantic domain. Simply put, a semantic object is created by allocating a name for it. The object itself is deﬁned to be the congruence class of all its names. A system such as nominal logic or the ν-calculus can be used to handle the generation of names in the syntactic domain.
The idea can be illustrated with a very simple example. Consider a domain of semantic objects D = {a, b, c, . . .}. Let φ be a first-order formula with free variables, say x = y ∧y /= z. According to the usual Tarskian definition of truth, we could interpret φ relative to a valuation σ : Var → D, provided {x, y, z} ⊆ dom σ, and the judgment σ |= φ would have a well-defined truth value. For example, if σ(x)= σ(y)= c and σ(z)= a, then σ would satisfy φ, along with many other other valuations over D.
However, suppose we did not specify the actual values of x, y, z, but only which variables represent the same values. Thus instead of σ : Var → D, we would

have a set of equations α ⊆ Var × Var specifying aliasing relationships between the variables. For the σ above, α would consist of the single equation x = y. The free algebra generated by {x, y, z} modulo the congruence induced by x = y has two elements, namely the two congruence classes {x, y} and {z}. Under the canonical interpretation
x '→ {x, y}	y '→ {x, y}	z '→ {z},
the formula φ is satisfied. The presentation α of the free algebra contains enough information to determine the truth of the formula; there is no need to represent the actual values.
The relation α is called an aliasing relation. It generates a congruence, that is, the smallest relation on terms that contains α and is reflexive, symmetric, transi- tive, and a congruence with respect to any operations defined on the elements. To represent the creation of a new object, we simply update α in a way that ensures that there is no aliasing between the variable instantiated with the new object and others of the same type currently represented in the state. We do not need to worry about how to select a new semantic object from a previously defined set or whether there are enough of them available; in essence, that responsibility is com- pletely borne by the allocation of syntactic names. The advantage of this approach is that objects in the semantic domain can be generated ex nihilo and are truly indiscernible. An added benefit is that we can reason equationally with α, and this appears to align well with popular approaches for reasoning about higher-order program state involving logical relations and bisimulation [2,6,10,13,16,20,26,28].
In this paper we develop this basic idea into an operational semantics for a higher-order functional programming language with imperative and object-oriented features. We give a set of operational rules that describe how the state, as repre- sented by σ and α, should be updated as each atomic action is performed. The semantics is an extension of capsules [17,18,19]. We show how objects, nonces, ref- erences, arrays, and records fit into this framework. As an illustration, we show how to model safe substitution in the λ-calculus with nonces as variables and show that α-conversion is an idempotent operation.
Capsules
Capsules [17,18,19] are a precursor to the system introduced here. Capsule seman- tics does not rely on heaps, stacks, or any other form of explicit memory, but only on names and bindings.
Syntax
A capsule is a pair ⟨e, σ⟩, where e is a λ-term or constant and σ is a partial function from variables to irreducible λ-terms or constants such that
FV(e) ⊆ dom σ, and
if x ∈ dom σ, then FV(σ(x)) ⊆ dom σ,

where FV(e) is the set of free variables of e. Thus the free variables of a capsule are not really free; every variable in ⟨e, σ⟩ either occurs in the scope of a λ or is bound by σ to a constant or irreducible expression, which represents its value. A capsule represents a closed λ-coterm (infinitary λ-term). The closure conditions (i) and (ii) preclude catastrophic failure due to access of unbound variables. There may be circularities, which enables a representation of recursive functions.
Capsules may be α-converted. Abstraction operators λx and the occurrences of x bound to them may be renamed as usual. Variables in dom σ may also be renamed along with all free occurrences. Capsules that are equivalent in this sense represent the same value.
Values are also preserved by garbage collection. A monomorphism of capsules
h : ⟨d, σ⟩→ ⟨e, τ⟩ is an injective map h : dom σ → dom τ such that
τ (h(x)) = h(σ(x)) for all x ∈ dom σ, and
h(d)= e,
where h(e) = e[x/h(x)] (safe substitution). The set of monomorphic preimages of a given capsule contains an initial object that is unique up to a permutation of variables. This is the garbage-collected version of the capsule.
Semantics
Capsule evaluation semantics looks very much like the original evaluation semantics of LISP, with the added twist that a fresh variable is substituted for the parameter in function applications. The relevant small-step rule is
⟨(λx.e) v, σ⟩→ ⟨e[x/y], σ[y/v]⟩,
where y is fresh. In the original evaluation semantics of LISP, the right-hand side is
⟨e, σ[x/v]⟩, which gives dynamic scoping. This simple change faithfully models β- reduction with safe substitution in the λ-calculus, providing static scoping without closures [17,19]. It also handles local variable declaration in recursive functions correctly.
Another evaluation rule of particular note is the assignment rule:
⟨x := v, σ⟩→ ⟨(), σ[x/v]⟩
where v is irreducible. The closure condition (i) of §2.1 ensures that x is already bound in σ, and the assignment rebinds x to v. Assignment is also used to create recursive functions via backpatching, also known as Landin’s knot, without the use of fixpoint combinators.
See [17,18,19] for further details and examples.
Syntax
In this section we define the syntax of our language. We use the same notation for rebinding and substitution. Given a function σ, we write σ[x/v] for the function

such that σ[x/v](y) = σ(y) for y /= x and σ[x/v](x) = v. Given an expression e, we write e[x/d] for the expression e with d substituted for all free occurrences of x, renaming bound variables as necessary to avoid capture.

Types
Our type system distinguishes between constructive types and creative types. Con- structive objects are constants or are constructed from other objects using con- structors. They are represented directly in the state, bound by an environment σ to a variable of the same type. Creative objects, on the other hand, do not exist in advance and are not built from constructors, but are created on the fly during program execution using new. They can be used to model objects (in the sense of object-oriented programming), references, arrays, records, and nonces. Creative objects have a weaker ontological status than constructive objects in that they have no direct representation in the state, but only indirect representation in the form of an aliasing relation α.
The collection of all types is denoted Type. Let Var = {x, y, z, . . .} be an unlim- ited supply of variables. A type environment is a partial function Γ : Var ~ Type with finite domain dom Γ.
Constructive Types
Constructive types are built from type constructors. We have the function space constructor →, products and coproducts, and coinductive types defined with finite systems of fixpoint equations.
Products and coproducts are of the form


Γ= 
x∈dom Γ
Γ(x)	Γ= 
x∈dom Γ
Γ(x)

where Γ is a type environment. The corresponding projections and injections have type
πx : Q Γ → Γ(x)	ιx : Γ(x) → Σ Γ
for x ∈ dom Γ. The unit type  is the empty product, and the type of booleans is
  =  +  .
Our product and coproduct types are not dependent types, as Var is not a type.
All function, product, and coproduct types are constructive.
Creative Types
In addition to constructive types, we have creative types C(Q Γ), where Γ : Var ~
fields named x for x ∈ dom Γ in the sense of object-oriented programming. Values of type C( Γ) are creative objects. The field x has type Γ(x), which can be either constructive or creative.

Coinductive Types
Coinductive types are defined by finite systems of fixpoint equations. For example, the natural numbers are   =  +  , where   is a type variable. Formally,   =
Γ, where Γ(z) =  and Γ(s) =  . The number 3 would be represented by ιs (ιs (ιs (ιz ()))). Since the type is coinductive, there is also an infinite element ιs (ιs (ιs (.. .))).
For another example, lists and streams over   are defined by
intlist =  + (  × intlist)
where intlist is a type variable. Formally, intlist = Σ Δ, where
Δ(nil)=	Δ(cons)= Q Γ	Γ(hd)=	Γ(tl)= intlist
Then
Δ=  +	Γ	ι	:  →	Δ	ι	:	Γ →	Δ
Q Γ=  × intlist	πhd : Q Γ →	πtl : Q Γ → intlist
Both constructive and creative types may appear in a coinductive type definition.
Expressions
Expressions d, e, ... are defined inductively. Variables are expressions, as are typed projections πx and injections ιx. The unit object () is the null tuple of type , and booleans 0 = ιfalse() and 1 = ιtrue() are of type  . We might also include other typed constants.
Compound expressions are formed with the following constructs, subject to typ- ing constraints.
λ-abstraction	λx.e
application	(d e)
assignment	x := e or d.x := e
tupling	(ex | x ∈ dom Γ)
case analysis	[ex | x ∈ dom Γ]
projection	e.x
object creation	new Γ(e)
identity test	d = e
We also have defined expressions




then e ; w () else () in w ()

local definition	let x = d in e	(λx.e) d
recursive definition	let rec x = d in e	let x = ⊥ in (x := d); e
It is not necessary to worry about the capture of free occurrences of x in the com- position, conditional, and while loop because the type of x is  in all cases.
The ⊥ in the definition of let rec is a special constant of the appropriate type designated for this purpose. This technique is known as Landin’s knot. The constant
⊥ is treated specially in the small-step operational semantics (see §4.6) in that a variable bound to it is considered irreducible, effectively allowing Landin’s knot to create self-referential objects.
The let rec construct is used to create recursive functions and values of coinduc- tive types. It specifies a value that is the unique solution of the given equation in a certain final coalgebra. For recursive functions, this is a λ-coterm (infinitary λ-term), as in capsules (see §2). For coinductive datatypes, it is a multigraph re- alization as defined in [22]. In both cases, the infinite object is regular and has a finite representation. For example, the type of integer lists and streams was defined in §3.1.3. An element of this type is the infinite stream of alternating 0s and 1s, which can be defined by
let rec x = ιcons(0, ιcons(1, x)) in e
The mutually recursive definition
let rec x1 = d1 and ... and xn = dn in e
can be coded using the single-variable form of let rec with products and projections or with nested let recs.
The case analysis construct [ex | x ∈ dom Γ] corresponds to a case or match statement of functional languages. It is used to extract the elements of a coproduct based on their types. For example, the map function that maps a given function f :  →  over a given integer list would be defined by let rec to satisfy the equation
map = λ(f :  →  ).[ιnil, λx.ιcons(f (πhd x), map f (πtl x))]
This would be written more conventionally as
map (f :  →  ) (l : intlist): intlist =
case l of
| ιnil() → ιnil()
| ιcons x → ιcons(f (πhd x), map f (πtl x))
Typing Rules
Let Δ : Var ~ Type be a type environment. We write Δ ▶ e : α if the type α can be derived for the expression e by the typing rules of Fig. 1. The constructs let rec x = d in e and let x = d in e are typed as (λx.e) d.
If Δ ▶ e : α for some α, we say that e is Δ-well-typed, or just well-typed if


Δ ▶ c : type(c), c ∈ Const	Δ ▶ x : Δ(x), x ∈ dom Δ


Δ ▶ x : α	Δ ▶ e : β
Δ ▶ λx.e : α → β
Δ ▶ d : α → β	Δ ▶ e : α
Δ ▶ (d e): β



Δ ▶ x : α	Δ ▶ e : α
Δ ▶ x := e : 
Δ ▶ d.x : α	Δ ▶ e : α
Δ ▶ d.x := e : 

Δ ▶ b :	Δ ▶ d : α	Δ ▶ e : α
Δ ▶ if b then d else e : α
Δ ▶ b :	Δ ▶ e : 
Δ ▶ while b do e : 



Δ ▶ d :	Δ ▶ e : α Δ ▶ d ; e : α
Δ ▶ d : C(	Γ)	Δ ▶ e : C(	Γ)
Δ ▶ d = e : 



Δ ▶ e : C(	Γ)	Γ ▶ x : β
Δ ▶ e.x : β
Δ ▶ e :	Γ
Δ ▶ new Γ(e): C(	Γ)



Δ ▶ ex : Γ(x), x ∈ dom Γ Δ ▶ (ex | x ∈ dom Γ) : Q Γ
Δ ▶ ex : Γ(x) → β, x ∈ dom Γ Δ ▶ [ex | x ∈ dom Γ] : Σ Γ → β



Fig. 1. Typing Rules

Δ is understood. Unless otherwise mentioned, we will assume that the use of an expression in the text implies that it is well-typed.
Assignable Expressions
An assignable expression is a Δ-well-typed expression of the form x0 .x1	xn,
n ≥ 0, where xi ∈ Var. It follows from the typing rules that each nonnull proper prefix is creative; that is, there are Γi for 0 ≤ i ≤ n such that Δ = Γ0, Γi(xi) = C(	Γi+1) for 0 ≤ i ≤ n−1, and xn ∈ dom Γn. An assignable expression may appear on the left-hand side of an assignment operator := and is considered irreducible when appearing in that position (although non-irreducible expressions may appear on the left-hand side of an assignment). The set of Δ-well-typed assignable expressions is denoted AΔ. This set can be infinite in general due to coinductive types, but it is a regular set considered as a set of strings over Var. Assignable expressions are denoted u, v, w, . . . .
Assignable expressions can be either constructive or creative. The set of Δ-well- typed creative (respectively, constructive) assignable expressions is denoted CAΔ (respectively, NAΔ). Like AΔ, these sets can be infinite in general.
Irreducible Expressions
Irreducible expressions (or values) are defined relative to a global type environment Δ. They are Δ-well-typed expressions for which no small-step operational rule applies. They include

constants,
λ-abstractions,
creative assignable expressions, i.e. elements of CAΔ,
expressions (vx | x ∈ dom Γ), where all vx are irreducible,
expressions [vx | x ∈ dom Γ], where all vx are irreducible,
expressions ιx v, where v is irreducible.
In addition, for the purpose of Landin’s knot, a constructive variable x is consid- ered irreducible if σ(x)= ⊥; see §4.6. Constructive assignable expressions are not irreducible in general. The set of constructive irreducible expressions is denoted NValΔ.

Aliasing Relations
Let α ⊆ CAΔ × CAΔ be a set of pairs of creative assignable expressions such that if (u, v) ∈ α, then Δ ▶ u : C( Γ) iff Δ ▶ v : C( Γ). The set α is called an aliasing relation. It represents a set of well-typed equations between creative assignable expressions.
The congruence generated by α is the smallest binary relation on AΔ containing α
and closed under the rules of Fig. 2. There is some redundancy among the premises

Fig. 2. Congruence Rules

of the last rule (congruence), as one can show inductively that if α ▶ u = v, then u and v have the same type. Note that u and v can be constructive, even though the elements of α are all creative. The congruence class of v ∈ AΔ is denoted [v]α.
We can form the free algebra AΔ/α = {[u]α | u ∈ AΔ}. It is an algebra in
the sense that the projections .x, regarded as unary operations, are well-defined on congruence classes; that is, if [u]α = [v]α, then by congruence, [u.x]α = [v.x]α whenever u.x is well-typed, so it makes sense to define [u]α.x = [u.x]α. Intuitively, if Δ ▶ u = v, then u and v are aliases for the same object, so the values of the fields
u.x and v.x should also be the same.
As mentioned, the set AΔ can be infinite in general, but the computational rules will maintain the invariant that AΔ/α is finite. One can regard AΔ/α as a finite
graph with nodes [u]α and labeled edges [u]α →x [u.x]α.
We denote by CAΔ/α and NAΔ/α the sets of creative and constructive elements

of AΔ/α, respectively; that is, the sets
CAΔ/α = {[u]α | u ∈ CAΔ}
NAΔ/α = {[u]α | u ∈ NAΔ} = AΔ/α − CAΔ/α.

Equational Reasoning
The congruence generated by α extends inductively to effect-free constructors with the obvious syntactic congruence rule for each constructor. For example, for prod- ucts and injections,


	α ▶ dx = ex, x ∈ dom Γ	
α ▶ (dx | x ∈ dom Γ) = (ex | x ∈ dom Γ)
α ▶ d = e
.
α ▶ ιx d = ιx e

The only nonobvious rule is λ-abstraction, in which we must treat the bound variable specially.
α ▶ d[x/z]= e[x/z], z fresh
.
α ▶ λx.d = λx.e
There is no sound congruence rule for assignment := or new, as these constructs have siQde effects. For example, it would never be the case that new C(	Γ) =
These rules, along with α-conversion, renaming by a permutation, and garbage collection (§3.6) can be used in equational reasoning on program states.

Program States
A program state is represented by a quadruple ⟨e, Δ, σ, α⟩, where:
Δ: Var ~ Type is a type environment
α ⊆ CAΔ × CAΔ is a Δ-well-typed equational presentation
σ : NAΔ/α → NValΔ is a Δ-well-typed valuation
e is a Δ-well-typed expression
The domain of σ is officially NAΔ/α, but we will often abuse notation and write
σ(u) for σ([u]α).
The component e is the expression to be evaluated. The typing of expressions is determined by Δ. The components σ and α comprise an environment that deter- mines the interpretation of free variables. Conditions (i) and (ii) of §2.1 for capsules are implied by the facts that e and σ([u]α) are well-typed and the domain of σ is NAΔ/α. Formally, σ is also defined on bound variables, but that is unnecessary and could be relaxed.
The set of states is a nominal set over the set of names Var in the sense of nominal logic [11,12,27].

Garbage Collection
Our notions of α-conversion and garbage collection are based on capsules (see §2.1) with appropriate modifications to account for the aliasing relation α. As with capsules, values are preserved.
Any variable declared in Δ may be α-converted. If a fresh variable is needed for α-conversion, its type is first declared in Δ. Renaming variables in some type environment Γ used in the declaration of a product or sum does not constitute α-conversion and does not result in an equivalent state.
As with capsules, garbage collection is defined in terms of monomorphisms. A
monomorphism
h : ⟨e, Δ, σ, α⟩→ ⟨ej, Δj, σj, αj⟩
is an injective map h : dom Δ → dom Δj such that
h is type-preserving, that is, Δ(x)= Δj(h(x));
modulo α and αj, h is an algebra monomorphism AΔ/α → AΔ′ /αj;
σj([h(x)]α′ )= h(σ([x]α)) for all [x]α ∈ dom σ; and
ej = h(e),
where h(e) = e[x/h(x)]. Like capsules, every state has an initial monomorphic preimage, which is its garbage-collected version and which is unique up to a per- mutation of variables and variation in the presentation α of AΔ/α.
However, unlike capsules, we cannot collect garbage simply by removing vari- ables inaccessible from e, because some of them may be needed in the equational presentation α of AΔ/α. Removing the equations containing them could cause prop- erty (ii) to be violated; h would be a homomorphism but not a monomorphism. To ensure (ii), we show that AΔ/α has a canonical presentation in which α is minimal and the pairs are of a certain form. This form will also be used in the semantics of assignment (§4.5).
Lemma 3.1 Given an aliasing relation α on AΔ, there is a set of variables X, an extension Δj of Δ with domain X ∪ dom Δ, and an aliasing relation αj on AΔ′ with the following properties:
AΔ/α and AΔ′ /αj are isomorphic;
all pairs in αj are of the form (x, z) or (x.y, z), where x, z ∈ X;
every congruence class in CAΔ′ /αj contains exactly one variable of X. Moreover, Δj and αj can be computed from Δ and α in time O(n α(n)), where α(n)
is the inverse of Ackermann’s function.
Proof. Let A be the set of subterms of terms appearing in α. Form the congruence
closure αˆ of α on A. The congruence closure is the smallest relation on A that
contains α and is closed under the rules of Fig. 2 applied only to terms in A. It is shown in [21] that for s, t ∈ A, α ▶ s = t iff (s, t) ∈ αˆ; that is, one need not go outside of A to prove congruence between two terms in A.

One can form the congruence closure for a signature involving only unary func- tions in time O(n α(n)). The algorithm is essentially the same as that used to minimize deterministic finite-state automata [4,15,24]. By “forming the congru-
ence closure,” we do not mean computing the relation αˆ itself—that would take
too long to write down—but rather forming the congruence classes and associating each element of A with its respective congruence class so that we can subsequently determine whether (s, t) ∈ αˆ (that is, α ▶ s = t) for s, t ∈ A in constant time.
Let X be a set of variables such that each creative α-congruence class contains exactly one element of X. If [u]α does not contain a variable, we can add a fresh variable x and the equation (x, u) to α, although this step is not strictly necessary, as our operational semantics maintains the invariant that every creative congruence class contains a variable. Let Δj be Δ extended as necessary with the appropriate typings for x ∈ X.
Now let

αj = αˆ ∩ ({(x, z) | x ∈ X, z ∈ Var}∪ {(x.y, z) | x, z ∈ X}).

The set αj has the following properties:
For each u ∈ A, there is exactly one x ∈ X such that αj ▶ x = u.
For each x ∈ X and y ∈ dom Γ, where Δj(x)= C(	Γ), there is exactly one z ∈ X
such that (x.y, z) ∈ αj.
It follows that α and αj generate the same congruence closure αˆ, thus AΔ/α and
AΔ′ /αj are isomorphic.	2

Now we can collect garbage by forming the reduced presentation as described in Lemma 3.1 and removing inaccessible variables from Δ, σ, and α, where a variable is accessible if it is in the smallest set of variables containing the variables of e and closed under the following operations:
If x is accessible, (x, z) ∈ α or (x.y, z) ∈ α, and z ∈ X, then z is accessible;
if x is accessible and z occurs in σ([x]α) or σ([x.y]α), then z is accessible.
The monomorphism h is defined on the subalgebra of AΔ/α generated by the ac- cessible variables.


Operational Semantics
The operational semantics of the language is defined by the small-step rules given be- low. In addition, there are context rules that define a standard shallow applicative- order evaluation strategy (leftmost innermost, call-by-value) and left-to-right eval- uation of tuples and expressions e.x.

Function Application
Our rule for function application is adapted from the rule for capsules (see §2.2):
⟨(λx.e) v, Δ, σ, α⟩ → ⟨e[x/y], Δ[y/Δ(x)], σj, αj⟩,
where y is fresh and
(σj, αj)=	(σ[[y]α/v], α)	if Δ(x) is constructive (σ, α ∪ {(y, v)})	if Δ(x) is creative.
As with capsules, a fresh variable y is conjured and given the same type as x, resulting in a new global type environment Δ[y/Δ(x)]. If the type is constructive, σ is updated with the value v, and α is unchanged. If the type is creative, σ is unchanged, but α is updated with the new alias (y, v).
Creation
The following rule creates a new creative object:
⟨new Γ(v), Δ, σ, α⟩ → ⟨y, Δ[y/C(Q Γ)], σj, αj⟩,
where y is fresh and
αj = α ∪ {(y.x, vx) | x ∈ dom Γ, Γ(x) creative}
σ = σ[[y.x]α′ /vx | x ∈ dom Γ, Γ(x) constructive]
The object is represented by a fresh variable y, which is added to the domain of Δ with the appropriate creative type. The value v is a tuple supplying the initial values of the fields. The entities α and σ are updated to assign the fields of the new object their initial values.
Assignment to Constructive Expressions
Assignment for constructive types is essentially the same as for capsules. For u ∈
NAΔ and v irreducible of the same constructive type,
⟨u := v, Δ, σ, α⟩ → ⟨(), Δ, σ[[u]α/v], α⟩.
Here Δ does not need to be updated, because u is already well-typed.
Assignment to Creative Variables
Before we can define the semantics of assignments to creative assignable expressions, we need to lay some groundwork. The issue is that assignment to a creative expres- sion may change the free algebra presented by α if the expression to be assigned is involved in the presentation.

First we consider the case of an assignment x := v to a creative variable x ∈
dom Δ. Let Δj = Δ[z/Δ(x)], where z /∈ dom Δ. Define g : dom Δ → AΔ′ by
g(x)= z	g(u)= u,  u ∈ dom Δ − {x}.	(1)
Define h : dom Δj → AΔ by
h(z)= x	h(x)= v	h(u)= u, u ∈ dom Δj − {z, x}.	(2) Extend h uniquely to a homomorphism h : AΔ′ → AΔ by inductively defining
h(u.y)= h(u).y for y ∈ dom Γ, where Δj ▶ u : C(	Γ). Likewise, extend g uniquely to a homomorphism g : AΔ → AΔ′ . Define a new set of axioms on AΔ′ :
αj = {(x, g(v))}∪ {(g(s), g(t)) | (s, t) ∈ α}.	(3)
Lemma 4.1 Modulo α and αj, the homomorphisms g and h are well deﬁned and are inverses, thus the quotient algebras AΔ/α and AΔ′ /αj are isomorphic.
Proof. First we observe that h is a left inverse of g:
h(g(x)) = h(z)= x	h(g(u)) = h(u)= u,  u ∈ dom Δ − {x}.
Moreover, g is a left inverse of h modulo αj:
g(h(z)) = g(x)= z	g(h(u)) = g(u)= u,  u ∈ dom Δj − {z, x},
and since (x, g(v)) is an axiom of αj and g(h(x)) = g(v),
αj ▶ g(h(x)) = x.

Since h is a left inverse of g on generators dom Δ of AΔ, and since h and g are homomorphisms, h is a left inverse of g on all elements of AΔ. Similarly, g is a left inverse of h modulo αj on all elements of AΔ′ .
Now we claim that
αj ▶ s = t	⇒  α ▶ h(s)= h(t),	(4)
thus h is well-defined modulo α and αj. By general considerations of universal algebra, it suffices to show that (4) holds for the axioms (s, t) ∈ αj. For the axiom (x, g(v)), we wish to show α ▶ h(x) = h(g(v)). This follows immediately from the facts that h(x)= v and h is a left-inverse of g. For the axioms (g(s), g(t)) for (s, t) ∈ α, we have α ▶ s = t, and since h is a left-inverse of g, α ▶ h(g(s)) = h(g(t)). We have shown that h composed with the canonical map AΔ → AΔ/α is well-
defined on αj-congruence classes, therefore reduces to a homomorphism
hj : AΔ′ /αj → AΔ/α.	(5)

Likewise, one can show that α ▶ s = t implies αj ▶ g(s) = g(t) by the same argument, thus g reduces to a homomorphism
g : AΔ/α → AΔ′ /α .	(6)
Finally, since h is a left inverse of g and g is a left inverse of h modulo αj, it follows that gj and hj are inverses, thus constitute an isomorphism between AΔ/α and AΔ′ /αj.	2
Lemma 4.1 allows us to define the semantics of assignment to a creative variable:
⟨x := v, Δ, σ, α⟩ → ⟨(), Δ[z/Δ(x)], σj, αj⟩,
where z is fresh, σj = σ ◦hj, and αj and hj are as defined in (3) and (5), respectively.
Assignment to Creative Fields
Now we treat the case of an assignment u.y := v, where both u and u.y are creative. As before, we need to ensure that u.y is not involved in the axiomatization α of the quotient structure so that the assignment will have no unintended consequences. However, unlike the previous case, if α ▶ u = v, then assigning to u.y also assigns the same value to v.y due to the aliasing. Moreover, there is not necessarily an isomorphism between the two structures.
We first put α into the reduced form of Lemma 3.1. Let X be the set defined in that lemma. We can find variables x, z, w ∈ X such that α ▶ u = x, α ▶ v = w, and (x.y, z) ∈ α. We then define
⟨u.y := v, Δ, σ, α⟩ → ⟨(), Δ, σj, αj⟩
where αj = (α − {(x.y, z)}) ∪ {(x.y, w)} and σj is defined to agree with σ on all constructive expressions of the form r or r.s, where r is a variable. By the form of the reduced presentation, this determines σj completely.
Other Small-Step Rules
⟨x, Δ, σ, α⟩→ ⟨σ([x]α), Δ, σ, α⟩, σ([x]α) /= ⊥, x constructive
⟨x.y, Δ, σ, α⟩→ ⟨σ([x.y]α), Δ, σ, α⟩, x.y constructive
⟨u = v, Δ, σ, α⟩→ ⟨1, Δ, σ, α⟩, α ▶ u = v
⟨u = v, Δ, σ, α⟩→ ⟨0, Δ, σ, α⟩, α /▶ u = v
⟨πy (vx | x ∈ dom Γ), Δ, σ, α⟩→ ⟨vy, Δ, σ, α⟩
⟨[gx | x ∈ dom Γ](ιy v), Δ, σ, α⟩→ ⟨(gy v), Δ, σ, α⟩
Defined rules are
⟨() ; e, Δ, σ, α⟩→ ⟨e, Δ, σ, α⟩
⟨if 1 then d else e, Δ, σ, α⟩→ ⟨d, Δ, σ, α⟩

⟨if 0 then d else e, Δ, σ, α⟩→ ⟨e, Δ, σ, α⟩
⟨while b do e, Δ, σ, α⟩→ ⟨if b then (e ; while b do e) else (), Δ, σ, α⟩
The proviso “σ([x]α) /= ⊥” in (i) effectively makes x irreducible when this property holds. This is to allow Landin’s knot to form self-referential terms. Recall that let rec x = d in e abbreviates let x = ⊥ in (x := d); e. The object ⊥ is meant for this purpose only, and is not meant to be visible as the final value of a computation. In a real implementation one would prevent ⊥ from becoming visible by imposing syntactic guardedness conditions on the form of d, as done for example in OCaml, or by raising a runtime error if the value of ⊥ is ever required in the evaluation of d.

Applications
Nonces
A nonce is a creative object of type C( ). These are objects with no fields. They correspond to the objects created by the new operator in the ν-calculus [6,26]. They can be used as unique identifiers. We illustrate the use of nonces as variables in §6.

Records
A record with fields of type Γ is an object of type C(Q Γ). Note that this is
(y1, y2), whereas there can be distinct creative objects x and y with x.1= y.1 and
x.2= y.2.

References
A reference is a record with a single field named !. The type of the reference is C( Γ), where dom Γ = {!}, and Γ(!) is the type of the datum. For example, an integer reference, which would be represented by the type int ref in OCaml, would have Γ(!) =  . The following OCaml expressions would translate to our language as indicated:


Arrays
An integer array of length m is a record with fields {0, 1,...,m − 1, length}. This would have type C(  Γ), where dom Γ= {0, 1,...,m− 1, length}, Γ(i)=  for 0 ≤ i ≤ m − 1, and Γ(length)=  . The following Java expressions would translate to our language as indicated:



Objects
A creative type C(Q Γ) can be regarded as a class withQfields whose types are
x ∈ dom Γ of the object can be accessed from within the object as self .x. To create a new object of the class, we would say
let rec self = new Γ(v) in self	(7) The value of this expression is a new object in which the references to self in v
have been backpatched via Landin’s knot to refer to the object just created. If we like, we can even have self ∈ dom Γ with Γ(self ) = C(	Γ). The cQomponent of v


Note that the use of Landin’s knot is essential here. The traditional approach involving fixpoint combinators does not work, as the new operator is not referentially transparent.
Here is an example to demonstrate (7). Let dom Γ= {self , f, n} with Γ(self )= C(Q Γ)	Γ(f )=   → ()	Γ(n)=  .
Let us evaluate (7) with v = (self , λy.(self .n := y), 3). Substituting the definitions of let rec and let, we have
let rec self = new Γ(self , λy.(self .n := y), 3) in self
= let self = ⊥ in (self := new Γ(self , λy.(self .n := y), 3)); self
= (λself .(self := new Γ(self , λy.(self .n := y), 3)); self ) ⊥.
Evaluating this expression in a state with Δ, σ, and α would result in the state
⟨(x := new Γ(x, λy.(x.n := y), 3)); x, Δj, σ, αj⟩
where x is fresh, Δj = Δ[x/C(	Γ)], and αj = α ∪ {(x, ⊥)}. One more step of the evaluation would yield
⟨(x := v); x, Δjj, σj, αjj⟩

where v is fresh and
Δjj = Δj[v/C(	Γ)] σj = σ[v.f/λy.(x.n := y)][v.n/3] αjj = αj ∪ {(v.self , x)}.
Now performing the assignment leaves the expression x and changes the aliasing relation to (αjj − {(x, ⊥)}) ∪ {(x, v)}. Applying Lemma 3.1 with x ∈ X and collecting garbage, we are left with the final state
⟨x, Δ[x/C(Q Γ)], σ[x.f/λy.(x.n := y)][x.n/3], α ∪ {(x.self , x)}⟩.
To accommodate nominal classes in the sense of [25, §19.3], one could augment the new construct to allow new C(e), where C = C( Γ) is a class declaration, although we have not done so here.
Substitution and α-Conversion
In this section we demonstrate how syntactic equivalence of computational states gives rise to indiscernability in the semantic domain. We show how to model λ- terms semantically as elements of a coinductive datatype in which variables are nonces. In the semantic domain, α-conversion is an idempotent operation; that is, α-converting twice is the same as α-converting once.
A λ-term is either a λ-variable, an application, or an abstraction. An application is a pair of λ-terms, an abstraction consists of a λ-variable (the parameter) and a λ-term (the body), and λ-variables are nonces. We can thus model λ-terms with the coinductive type
λTerm = λVar + λApp + λAbs	 λ-coterms λApp = λTerm × λTerm	 applications λAbs = λVar × λTerm	abstractions
λVar = C( )	λ-variables
The type also contains λ-coterms (infinitary λ-terms), although they do not figure in our development.
The free variables of a λ-term are defined inductively by
FV(y)= {y}	FV(t1 t2)= FV(t1) ∪ FV(t2)	FV(λy.t0)= FV(t0) − {y}
They can be computed (for well-founded terms) by the following recursive program:
let rec isFreeIn (x : λVar) (t : λTerm):  =
case t of
| ι0 y → y = x
| ι1 (t1, t2) → isFreeIn x t1 ∨ isFreeIn x t2
| ι2 (y, t0) → y /= x ∧ isFreeIn x t0
Likewise, safe (capture-avoiding ) substitution is defined as a fixpoint of a system of equations. The result of substituting e for x in t is denoted t[x/e] and is defined

inductively by

y[x/e]=	e	if y = x
y	if y /= x
(t1 t2)[x/e]= (t1[x/e]  t2[x/e])
⎧⎪⎨λy.t0	if y = x
⎪⎩λz.(t0[y/z][x/e])	otherwise, where z /∈ {x}∪ FV(t0) ∪ FV(e)

In the last rule, to satisfy the proviso z /∈ {x} ∪ FV(t0) ∪ FV(e), it suffices to take
z fresh. This leads to the following recursive program:
let rec subst (t : λTerm) (x : λVar) (e : λTerm): λTerm =
case t of
| ι0 y → if y = x then e else t
| ι1 (t1, t2) → ι1 (subst t1 x e, subst t2 x e)
| ι2 (y, t0) → if y = x then t
else if ч(isFreeIn y e) then ι2 (y, subst t0 x e)
else let z = new λVar in ι2 (z, subst (subst t0 y (ι0 z)) x e)
If e is a variable w, this simplifies to

y[x/w]=	w	if y = x
y	if y /= x
(t1 t2)[x/w]= (t1[x/w]) (t2[x/w])
⎧⎪⎨λy.t0	if y = x
⎪⎩λz.(t0[y/z][x/w])	if w = y /= x, where z /∈ {x, w}∪ FV(t0).

let rec substj (t : λTerm) (x : λVar) (w : λVar): λTerm =
case t of
| ι0 y → if y = x then ι0 w else t
| ι1 (t1, t2) → ι1 (substj t1 x w, substj t2 x w)
| ι2 (y, t0) → if y = x then t
else if y /= w then ι2 (y, substj t0 x w)
else let z = new λVar in ι2 (z, substj (substj t0 y z) x w)

Lemma 6.1 Modulo α-equivalence and garbage collection, the following big-step

rules are sound:


⟨substj (ι0

⟨substj (ι


α ▶ x = y
y) x v, Δ, σ, α⟩ → ⟨ι0
α /▶ x = y
y) x v, Δ, σ, α⟩ → ⟨ι


(8)
v, Δ, σ, α⟩
(9)
y, Δ, σ, α⟩

0	0
⟨substj e0 x v, Δ, σ, α⟩→ ⟨v0, Δ, σ, α⟩	⟨substj e1 x v, Δ, σ, α⟩→ ⟨v1, Δ, σ, α⟩
⟨substj (ι1 (e0, e1)) x v, Δ, σ, α⟩→ ⟨ι1 (v0, v1), Δ, σ, α⟩



⟨substj (ι2

α ▶ x = y
(y, t)) x v, Δ, σ, α⟩→ ⟨ι2
(10)
(11)
(y, t), Δ, σ, α⟩

α /▶ x = y	α /▶ y = v	⟨substj tx v, Δ, σ, α⟩→ ⟨u, Δ, σ, α⟩

⟨substj (ι2
(y, t)) x v, Δ, σ, α⟩→ ⟨ι2
(12)
(y, u), Δ, σ, α⟩

Proof. We start with rule (8). Suppose α ▶ y = x. Let
Δj = Δ[tj/λTerm][xj/λVar][vj/λVar]	Δjj = Δj[yj/λVar]
αj = α ∪ {(x, xj), (v, vj)}	αjj = αj ∪ {(y, yj)}	(13)
σj = σ[tj/ι0 y],
where tj, xj, vj, yj are fresh. We will first give the steps of the derivation, then give a brief justification of each step afterwards.
⟨substj (ι0 y) x v, Δ, σ, α⟩
→ ⟨(λtxw.[λy.if y = x then ι0 w else ι0 y, . . . ] t) (ι0 y) x v, Δ, σ, α⟩	(14)
→ ⟨[λy.if y = xj then ι0 vj else ι0 y, . . . ] tj, Δj, σj, αj⟩	(15)
→ ⟨if yj = xj then ι0 vj else ι0 yj, Δjj, σj, αjj⟩	(16)
→ ⟨ι0 vj, Δjj, σj, αjj⟩	(17)
= ⟨ι0 v, Δjj, σj, αjj⟩	(18)
= ⟨ι0 v, Δ, σ, α⟩.	(19)
For (14), we have just replaced substj with its definition. This is just an application of small-step rule (i) of §4.6.
We obtain (15) from (14) by doing three successive function applications as defined in §4.1. The first allocates a fresh constructive variable tj of type λTerm, substitutes it for t in the body of the function, and binds it to the argument ι0 y in σ to get σj. The second and last allocate fresh creative variables xj and vj of type λVar, substitute them for x and w, respectively, in the body of the function, and equate them to the arguments x and v, respectively, thereby extending α to αj. The new type environment is Δj.
We obtain (16) from (15) by rule (vi) of §4.6, the small-step rule for the case statement. After lookup of tj, its value ι0 y is analyzed and the function corre- sponding to index 0 in the tuple (the one shown) is dispatched. That function is

applied to y, which causes a fresh creative variable yj of type λVar to be allocated, substituted for y in the body, and equated with the argument y in αj to get αjj. The new type environment is Δjj.
For (17), since α ▶ y = x by assumption, we have αjj ▶ yj = xj, therefore the conditional test succeeds, resulting in the value ι0 vj. Since αjj ▶ v = vj, (17) is equivalent to (18). Finally, (19) is obtained by garbage collection, observing that tj, xj, vj, and yj are no longer accessible from ι0 v.
The proof of rule (9) is very similar, except that at step (17) we obtain ι0 yj
instead of ι0 vj because αjj /▶ yj = xj. The proof of rule (11) is also very similar.
For rule (10), let
Δj = Δ[tj/λTerm][xj/λVar][vj/λVar]	Δjj = Δj[yj/λApp]
αj = α ∪ {(x, xj), (v, vj)}
σj = σ[tj/ι1 (e0, e1)]	σjj = σj[yj/(e0, e1)],
where tj, xj, vj, yj are fresh. By reasoning similar to the above, we have
⟨substj (ι1 (e0, e1)) x v, Δ, σ, α⟩
→ ⟨[ ..., λy.ι1 (substj (π0 y) xj vj, substj (π1 y) xj vj), ... ] tj, Δj, σj, αj⟩
→ ⟨ι1 (substj (π0 yj) xj vj, substj (π1 yj) xj vj), Δjj, σjj, αj⟩
= ⟨ι1 (substj (π0 yj) x v, substj (π1 yj) x v), Δjj, σjj, αj⟩.
The last equation follows from the fact that αj ▶ x = xj and αj ▶ v = vj. Now evaluating π0 yj gives e0, and by the left-hand premise of (10), substj e0 xv reduces to v0 in context. Similarly, by the right-hand premise, substj (π0 yj) xv reduces to v1 in context. This leaves us with
⟨ι1 (v0, v1), Δjj, σj, αjj⟩ = ⟨ι1 (v0, v1), Δ, σ, α⟩,
where the right-hand side is obtained from the left by garbage collection.
Finally, for rule (12), let
Δj = Δ[tj/λTerm][xj/λVar][vj/λVar][yj/λAbs]
αj = α ∪ {(x, xj), (v, vj)}	σj = σ[tj/ι2 (y, t)][yj/(y, t)],
where tj, xj, vj, yj are fresh. As above, we have
⟨substj (ι2 (y, t)) x v, Δ, σ, α⟩
→ ⟨ι2 (π0 yj, substj (π1 yj) xj vj), Δj, σj, αj⟩
→ ⟨ι2 (y, substj t xj vj), Δj, σj, αj⟩
= ⟨ι2 (y, substj tx v), Δ, σ, α⟩	(20)
→ ⟨ι2 (y, u), Δ, σ, α⟩.	(21)
with (20) from the fact that αj ▶ x = xj, αj ▶ v = vj, and garbage collection, and
(21) from the premise of (12) applied in context.	2

Lemma 6.2 Let Δ ▶ e : λTerm and x, u, v ∈ dom Δ. Assume that α /▶ y = u and
α /▶ y = v for y = x or any y occurring in e. The states
⟨substj (substj ex u) u v, Δ, σ, α⟩	⟨substj ex v, Δ, σ, α⟩
reduce to equivalent states modulo α-equivalence and garbage collection.
Proof. For the case e = ι0 y and α ▶ y = x, by rule (8) both states reduce to
⟨ι0 v, Δ, σ, α⟩:
⟨substj (substj (ι0 y) x u) u v, Δ, σ, α⟩→ ⟨substj (ι0 u) u v, Δ, σ, α⟩
→ ⟨ι0 v, Δ, σ, α⟩
⟨substj (ι0 y) x v, Δ, σ, α⟩→ ⟨ι0 v, Δ, σ, α⟩.
If α /▶ y = x, by rule (9) both states reduce to ⟨ι0 y, Δ, σ, α⟩:
⟨substj (substj (ι0 y) x u) u v, Δ, σ, α⟩→ ⟨substj (ι0 y) u v, Δ, σ, α⟩
→ ⟨ι0 y, Δ, σ, α⟩
⟨substj (ι0 y) x v, Δ, σ, α⟩→ ⟨ι0 y, Δ, σ, α⟩.
For the case ι1 (e0, e1), we have
⟨substj e0 x u, Δ, σ, α⟩→ ⟨ej , Δ, σ, α⟩ ⟨substj ej u v, Δ, σ, α⟩→ ⟨ejj, Δ, σ, α⟩
0	0	0
⟨substj e1 x u, Δ, σ, α⟩→ ⟨ej , Δ, σ, α⟩  ⟨substj ej u v, Δ, σ, α⟩→ ⟨ejj, Δ, σ, α⟩,
1	1	1
thus
⟨substj (substj e0 x u) u v, Δ, σ, α⟩→ ⟨substj ej u v, Δ, σ, α⟩→ ⟨ejj, Δ, σ, α⟩
0	0
⟨substj (substj e1 x u) u v, Δ, σ, α⟩→ ⟨substj ej u v, Δ, σ, α⟩→ ⟨ejj, Δ, σ, α⟩.
1	1
By the induction hypothesis,
⟨substj e0 x v, Δ, σ, α⟩→ ⟨ejj, Δ, σ, α⟩ ⟨substj e1 x v, Δ, σ, α⟩→ ⟨ejj, Δ, σ, α⟩.
0	1


By rule (10),

⟨substj (ι1 (e0, e1)) x u, Δ, σ, α⟩→ ⟨ι1 (ej , ej ), Δ, σ, α⟩

0	1
⟨substj (ι1 (ej , ej )) u v, Δ, σ, α⟩→ ⟨ι1 (ejj, ejj), Δ, σ, α⟩,
0	1	0	1
therefore
⟨substj (substj (ι1 (e0, e1)) x u) u v, Δ, σ, α⟩→ ⟨substj (ι1 (ej , ej )) u v, Δ, σ, α⟩
0	1
→ ⟨ι1 (ejj, ejj), Δ, σ, α⟩,
0	1
⟨substj (ι1 (ej , ej )) x v, Δ, σ, α⟩→ ⟨ι1 (ejj, ejj), Δ, σ, α⟩.
0	1	0	1

For the case ι2 (y, t), if α ▶ y = x, by rule (11) and the fact that α /▶ u = w for any w occurring in t, we have
⟨substj (substj (ι2 (y, t)) x u) u v, Δ, σ, α⟩→ ⟨substj (ι2 (y, t)) u v, Δ, σ, α⟩
→ ⟨ι2 (y, t), Δ, σ, α⟩
⟨substj (ι2 (y, t)) x v, Δ, σ, α⟩→ ⟨ι2 (y, t), Δ, σ, α⟩.

If α /▶ y = x, we have α /▶ y = u and α /▶ y = v by the assumptions of the lemma, and
⟨substj tx u, Δ, σ, α⟩→ ⟨tj, Δ, σ, α⟩	⟨substj tj u v, Δ, σ, α⟩→ ⟨tjj, Δ, σ, α⟩,
thus
⟨substj (substj tx u) u v, Δ, σ, α⟩→ ⟨substj tj u v, Δ, σ, α⟩→ ⟨tjj, Δ, σ, α⟩.
By the induction hypothesis,
⟨substj tx v, Δ, σ, α⟩→ ⟨tjj, Δ, σ, α⟩.
By rule (12),
⟨substj (ι2 (y, t)) x u, Δ, σ, α⟩→ ⟨ι2 (y, tj), Δ, σ, α⟩
⟨substj (ι2 (y, tj)) u v, Δ, σ, α⟩→ ⟨ι2 (y, tjj), Δ, σ, α⟩
⟨substj (ι2 (y, t)) x v, Δ, σ, α⟩→ ⟨ι2 (y, tjj), Δ, σ, α⟩,
therefore
⟨substj (substj (ι2 (y, t)) x u) u v, Δ, σ, α⟩→ ⟨substj (ι2 (y, tj)) u v, Δ, σ, α⟩
→ ⟨ι2 (y, tjj), Δ, σ, α⟩.

2
To α-convert, we would map λx.e to λz.(e[x/z]), where z ∈/ FV(e) − {x}. We choose z ∈/ FV(e) − {x} to avoid the capture of a free occurrences of z in e as a result of the renaming. Usually we would simply choose a fresh z.
In our language, this would be implemented by a function
alpha : λAbs → λAbs
alpha = λt.let z = new λVar in (z, substj (π1 t) (π0 t) z),
or more informally,
alpha (x, e) = let z = new λVar in (z, substj ex z).

The following theorem illustrates how syntactic equivalence of computational states gives rise to indiscernability in the semantic domain. It states that α- conversion is an idempotent operation; that is, performing it twice gives the same result as performing it once.
Theorem 6.3 Modulo α-equivalence and garbage collection,
alpha (alpha (x, e))= alpha (x, e).
Proof. In the evaluation of ⟨alpha (x, e), Δ, σ, α⟩, let t, u, v be fresh variables and let
Δj = Δ[t/λAbs]	σj = σ[t/(x, e)]	αj = α ∪ {(u, v)}.


Suppose

⟨substj ex u, Δ[u/λVar], σ, α⟩→ ⟨ej, Δ[u/λVar], σ, α⟩.

The evaluation yields the following sequence of states:
⟨alpha (x, e), Δ, σ, α⟩
→ ⟨let z = new λVar in (z, substj (π1 t) (π0 t) z), Δj, σj, α⟩
→ ⟨(λz.(z, substj (π1 t) (π0 t) z)) v, Δj[v/λVar], σj, ⟩
→ ⟨(u, substj (π1 t) (π0 t) u), Δj[v/λVar][u/λVar], σj, αj⟩
→ ⟨(u, substj ex u), Δj[v/λVar][u/λVar], σj, αj⟩
= ⟨(u, substj ex u), Δ[u/λVar], σ, α⟩	(22)
→ ⟨(u, ej), Δ[u/λVar], σ, α⟩.
Step (22) is by garbage collection. Using this,
⟨alpha (alpha (x, e)), Δ, σ, α⟩
= ⟨alpha (u, ej), Δ[u/λVar], σ, α⟩
→ ⟨(v, substj ej u v), Δ[u/λVar][v/λVar], σ, α⟩	(23)
= ⟨(v, substj ex v), Δ[u/λVar][v/λVar], σ, α⟩	(24)
= ⟨(v, substj ex v), Δ[v/λVar], σ, α⟩	(25)
= ⟨(u, substj ex u), Δ[u/λVar], σ, α⟩	(26)
→ ⟨(u, ej), Δ[u/λVar], σ, α⟩.
Step (23) is by the same argument as (22). Step (24) is by Lemma 6.2. Steps (25) and (26) are by garbage collection and renaming of a creative variable.	2
7	Conclusion and Future Directions
We have shown how to model the creation of new indiscernible semantic objects during program execution and how to incorporate this device in a higher-order

functional language with imperative and object-oriented features. Modeling inde- scernables is desirable because it abstracts away from properties needed to allocate objects from a preexisting set, thus allowing the representation of semantic objects at a higher level of abstraction.
We have also shown that the explicit aliasing relation α and the congruence closure algorithm are useful techniques in equational reasoning about higher-order state. An interesting question for further study is the extent to which they can be assimilated in equational deduction systems based on logical relations and bisimu- lation [2,6,10,13,16,20,26,28].

References
Abadi, M. and L. Cardelli, “A Theory of Objects,” Monographs in Computer Science, Springer-Verlag, 2002.
Ahmed, A., D. Dreyer and A. Rossberg, State-dependent representation independence, in: Z. Shao and
B. C. Pierce, editors, Proc. 36th ACM Symp. Principles of Programming Languages (POPL’09) (2009),
pp. 340–353.
Allen, S. F., An abstract semantics for atoms in Nuprl, Technical Report TR2006-2032, Cornell University (2006).
Almeida, M., N. Moreira and R. Reis, Testing equivalence of regular languages, J. Automata, Languages and Combinatorics 15 (2010), pp. 7–25.
Barendregt, H. P., “The Lambda Calculus: Its Syntax and Semantics,” North Holland, 1984.
Benton, N. and V. Koutavas, A mechanized bisimulation for the ν-calculus, Technical Report MSR- TR-2008-129, Microsoft Research (2007).
Bickford, M. and R. Constable, Formal foundations of computer security, in: O. Grumberg, editor,
Formal Logical Methods for System Security and Correctness, IOS Press, 2008 pp. 29–52.
Black, M., The identity of indiscernibles, Mind 61 (1952), pp. 153–164.
Boolos, G., To be is to be a value of a variable (or to be some values of some variables), J. Philosophy
81 (1984), pp. 430–450.
Dreyer, D., G. Neis, A. Rossberg and L. Birkedal, A relational modal logic for higher-order stateful ADTs, in: M. V. Hermenegildo and J. Palsberg, editors, Proc. 37th ACM Symp. Principles of Programming Languages (POPL’10) (2010), pp. 185–198.
Gabbay, M. J. and A. Mathijssen, Nominal universal algebra: equational logic with names and binding,
J. Logic and Computation 19 (2009), pp. 1455–1508.
Gabbay, M. J. and A. M. Pitts, A new approach to abstract syntax with variable binding, Formal Aspects of Computing 13 (2002).
Gibbons, J. and R. Hinze, Just do it: Simple monadic equational reasoning, in: O. Danvy, editor, 16th Int. Conf. Functional Programming (ICFP’11) (2011), pp. 2–14.
Hacking, I., The identity of indiscernibles, J. Philosophy 72 (1975), pp. 249–256.
Hopcroft, J. E. and R. M. Karp, A linear algorithm for testing equivalence of finite automata, Technical Report 71-114, University of California (1971).
Hur, C.-K., D. Dreyer, G. Neis and V. Vafeiadis, The marriage of bisimulations and Kripke logical relations, in: J. Field and M. Hicks, editors, Proc. 39th ACM Symp. Principles of Programming Languages (POPL’12) (2012), pp. 59–72.
Jeannin, J.-B., Capsules and closures, in: M. Mislove and J. Ouaknine, editors, Proc. 27th Conf. Math. Found. Programming Semantics (MFPS XXVII) (2011), pp. 191–213.

Jeannin, J.-B. and D. Kozen, Capsules and separation, in: N. Dershowitz, editor, Proc. 27th ACM/IEEE Symp. Logic in Computer Science (LICS’12) (2012), pp. 425–430.
Jeannin, J.-B. and D. Kozen, Computing with capsules, in: M. Kutrib, N. Moreira and R. Reis, editors, Proc. Conf. Descriptional Complexity of Formal Systems (DCFS 2012), Lecture Notes in Computer Science 7386 (2012), pp. 1–19.
Koutavas, V. and M. Wand, Small bisimulations for reasoning about higher-order imperative programs, in: J. G. Morrisett and S. L. P. Jones, editors, Proc. 33rd ACM Symp. Principles of Programming Languages (POPL’06) (2006), pp. 141–152.
Kozen, D., Complexity of finitely presented algebras, in: Proc. 9th Symp. Theory of Comput., ACM, 1977, pp. 164–177.
Kozen, D., Realization of coinductive types, in: M. Mislove and J. Ouaknine, editors, Proc. 27th Conf. Math. Found. Programming Semantics (MFPS XXVII) (2011), pp. 148–155.
Meyer, B., “Object-Oriented Software Construction,” Prentice Hall, 1997, 2nd edition.
Nieuwenhuis, R. and A. Oliveras, Fast congruence closure and extensions, Information and Computation 205 (2007), pp. 557–580.
Pierce, B. C., “Types and Programming Languages,” MIT Press, 2002.
Pitts, A. M. and I. Stark, Observable properties of higher order functions that dynamically create local names, or: What’s new?, in: Mathematical Foundations of Computer Science: Proceedings of the 18th International Symposium MFCS ’93, number 711 in Lecture Notes in Computer Science (1993), pp. 122–141.
Pitts, A. M. and I. Stark, Operational reasoning for functions with local state, in: A. Gordon and
A. Pitts, editors, Higher Order Operational Techniques in Semantics, Publications of the Newton Institute, Cambridge University Press, 1998 pp. 227–273.
Vytiniotis, D. and V. Koutavas, Relating step-indexed logical relations and bisimulations, Technical Report MSR-TR-2009-25, Microsoft Research (2009).
