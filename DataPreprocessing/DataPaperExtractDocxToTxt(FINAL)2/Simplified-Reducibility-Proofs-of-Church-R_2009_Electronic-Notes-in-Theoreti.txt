

Electronic Notes in Theoretical Computer Science 247 (2009) 85–101
www.elsevier.com/locate/entcs

Simplified Reducibility Proofs of Church-Rosser for β- and βη-reduction
Fairouz Kamareddine and Vincent Rahli 1
ULTRA Group, MACS, Heriot-Watt University, Edinburgh, Scotland, UK

Abstract
The simplest proofs of the Church Rosser Property are usually done by the syntactic method of parallel reduction. On the other hand, reducibility is a semantic method which has been used to prove a number of properties in the λ-calculus and is well known to offer on one hand very general proofs which can be applied to a number of instantiations, and on the other hand, to be quite mysterious and inflexible. In this paper, we concentrate on simplifying a semantic method based on reducibility for proving Church-Rosser for both β- and βη-reduction. Interestingly, this simplification results in a syntactic method (so the semantic aspect
disappears) which is nonetheless projectable into a semantic method. Our contributions are as follows:
We give a simplification of a semantic proof of CR for β-reduction which unlike some common proofs in the literature, avoids any type machinery and is solely carried out in a completely untyped setting.
We give a new proof of CR for βη-reduction which is a generalisation of our simple proof for β-reduction.
Our simplification of the semantic proof results into a syntactic proof which is projectable into a semantic method and can hence be used as a bridge between syntactic and semantic methods.
Keywords: Church-Rosser, Reducibility, Parallel reductions


Introduction
Reducibility is a method based on realisability semantics [9], developed by Tait [14] in order to prove normalisation of some functional theories. The idea is to interpret types by sets of λ-terms closed under some properties. Since its introduction, this method has gone through a number of improvements and generalisations. In par- ticular, Krivine [12] uses reducibility to prove the strong normalisation (SN) of his intersection type system called system D. Koletsos [10] uses reducibility to prove that the set of simply typed λ-terms holds the Church-Rosser property (CR, also known as confluence property) w.r.t. β-reduction. Although it is well known that β-reduction satisfies CR, reducibility proofs of CR are in line with proofs of SN and

1 http://www.macs.hw.ac.uk/ultra/

1571-0661 Crown Copyright © 2009 Published by Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.07.050

hence, one can establish both SN and CR for some calculus using the same method. Moreover, CR proofs can be quite involved. So, reducibility proofs can help within the same machinery to prove the most important properties of a λ-calculus (such as SN, CR or standardisation).
In this paper we simplify a reducibility method for proving CR for β-reduction and we generalise our proof to proving CR for βη-reduction. Our proof of CR for β- reduction is simpler that the ones given by Ghilezan and Kunˇcak [6], by Koletsos and Stavrinos [11] and by Barendregt, Bergstra, Klop and Volken [1,2]. Furthermore, our proof is generalisable into a new proof of CR for βη-reduction. The CR theorem is a strong form of a theorem stated by Church and Rosser [5] proving the consistency of the λ-calculus. The Church-Rosser property of the untyped λ-calculus w.r.t. β- reduction can be stated as follows: for any λ-terms M, M1, M2 such that M →∗ M1 and M →∗ M2 there exists M3 such that M1 →∗ M3 and M2 →∗ M3, where →∗ is

β
the β-reduction relation.
β	β	β

As in a number of other works [11,8], our method to prove CR for a given set of terms w.r.t. a reduction relation (we consider both β-reduction and βη-reduction) consists of two main steps:
Our first step is based on a simplification of a reducibility method used to prove the confluence of developments. We started the construction of our method with a “common” reducibility method. We observed that not all the types were actu- ally needed in the method and that the interpretations of the few needed types corresponded to simple sets of terms satisfying simple closure properties (such as saturation). This led us to the removal of the whole type machinery and we obtained as a result a syntactic method. Interestingly, although our method has turned into a syntactic one, it can still be embedded into a semantic method based on a type system such as Krivine’s system D [12]. 2 As it is crucial to a reducibility method to use a soundness result, we call soudness the corresponding result in our method.
The second step of our method consists in reducing the problem of the confluence of the λ-calculus w.r.t. the considered reduction relation to the problem of the confluence of the defined set of terms w.r.t. the defined reduction. This second step is achieved through a common simulation method used in most proofs of CR. The simulation consists in defining a new simple confluent reduction whose transitive closure is equal to the considered reduction.
To achieve their goals, all of [1,6,11,8] use the notion of developments. Both Koletsos and Stavrinos [11] as well as Kamareddine and Rahli [8] use a complicated handling of developments. On the other hand, Barendregt et al. [1], Ghilezan and Kunˇcak [6] as well as this article are based on some simpler and sufficient notions of developments. These notions of developments are simpler because, as in the so called method of parallel reductions [13,15], they do not deal with residuals. Because this article does not make use of a type system and does not deal with residuals, it is a simplification of the work done by [11] and by [8]. However, this article can

2 The methods of [6] and [11] use the Simply Typed Lambda Calculus λ→ and the type system D [4,3].

also be regarded as a simplification and a generalisation of the work done by:
Barendregt et al. [1], because we do not introduce a new calculus and we do not use the finiteness of developments,
Ghilezan and Kunˇcak [6], because we do not make use of a type system.
In Section 2 we introduce the needed machinery about the λ-calculus and our de- velopments. In Section 3 we give our proof of the Church-Rosser property of the untyped λ-calculus w.r.t. β-reduction. In Section 4 we give our proof of the Church- Rosser property of the untyped λ-calculus w.r.t. βη-reduction. Finally, in Section 5, we compare our solution to the related work in the literature, especially to the work of Ghilezan and Kunˇcak [6], of Koletsos and Stavrinos [11] and to the developments of Tait and Martin-Lo¨f [13,2]. Due to space limitations, we omit the details of the proofs. However, full proofs can be found in the extended version of this article which will always be available at the authors’ web pages.
The Formal Machinery
In this section we provide some known formal machinery and introduce new defini- tions and lemmas that are necessary for the paper. Let n, m be metavariables which range over the set of natural numbers N = {0, 1, 2,.. .}. We take as convention that if a metavariable v ranges over a set s then the metavariables vi such that i ≥ 0 and the metavariables v', v'', etc. also range over s.

Background on the λ-calculus
This section consists of one long definition of some familiar (mostly standard) con- cepts of the λ-calculus and one basic lemma.
Definition 2.1	(i) Let x, y, z range over Var, a countable infinite set of term variables (or just variables). The set of terms of the λ-calculus is defined by:
M ∈ Λ ::= x | (λx.M ) | (M1M2)
We let M, N, P, Q, R range over Λ. We assume the usual convention for parenthesis and omit these when no confusion arises. In particular, we write M N0 ··· Nn instead of (··· ((MN0)N1) ··· Nn−1)Nn. We also assume the usual
definition of subterms and write N ⊆ M if N is a subterm of M (note that M ⊆ M ). We call a term of the form λx.M , a λ-abstraction (or just abstrac- tion) and a term of the form M1M2 an application.
We take terms modulo α-conversion and use the Barendregt convention (BC) where the names of bound variables differ from the free ones. When two terms M and N are equal (modulo α), we write M = N . We write fv(M ) for the set of the free variables of term M .
We define as usual the substitution M [x := N ] of N for all free occurrences of x in M . We let M [x1 := N1,..., xn := Nn] be the simultaneous substitution of Ni for all free occurrences of xi in M for 1 ≤ i ≤ n.
We assume the usual definition of compatibility (see the last line of Figure 1).



Fig. 1. Closure rules

For r ∈ {β, βη}, we define the reduction relation →r on Λ as the least com- patible relation closed under rule (r) : L →r R below, and we call L an r-redex and R the r-contractum of L (or the L r-contractum).
(β): (λx.M )N →β M [x := N ].
(η): λx.Mx →η M where x /∈ fv(M ). We define →βη=→β ∪ →η.
Let r ∈ {β, η, βη}. We use →∗ to denote the reflexive transitive closure (see the rules (refl ) and (tr ) of Figure 1) of →r. We let r denote the equivalence relation induced by →r. If the r-reduction from M to N is in k steps, we write M →k N .
Let r ∈ {β, βη}. A term (λx.M')N' is a direct r-reduct of (λx.M )N iff M →∗
M' and N →∗ N'.
Let r ∈ {β, βη}. We say that M has the Church-Rosser property for r (has
r-CR) if whenever M →∗ M1 and M →∗ M2 then there exists M3 such that
r	r
M1 →∗ M3 and M2 →∗ M3. We define CRr = {M | M has r-CR}. We use CR
r	r
to denote CRβ.
We define the set SAT of the sets satisfying the saturation property as follows:
SAT = {s ⊆ Λ | M [x := N ] ∈ s ⇒ (λx.M )N ∈ s}.
We define the set VAR of the sets satisfying the variable property as follows:
VAR = {s ⊆ Λ | n ≥ 0 ∧ (∀i ∈ {1,..., n}. Mi ∈ s) ⇒ xM1 ··· Mn ∈ s}.
We define the set ABS of the sets satisfying the abstraction property as follows:
ABS = {s ⊆ Λ | M ∈ s ⇒ λx.M ∈ s}.

Lemma 2.2 Let r ∈ {β, βη}. The following hold:
If M →∗ N and P →∗ Q then M [x := P ] →∗ N [x := Q].
r	r	r
fv(M [x := N ]) ⊆ fv((λx.M )N ).
If M →∗ N then fv(N ) ⊆ fv(M ).

If λx.M →∗
N then either N = λx.M' such that M →∗
M' or M →∗ Nx 

such that x /∈ fv(N ).
If x /∈ fv(M ) and Mx →∗

N then M →∗

P and either N = Px or P = λx.N.

If n ≥ 0, Q = (λx.M )N →k P and P is not a direct r-reduct of Q then (a)

k ≥ 1, (b) if k = 1 then P = M [x := N ] and (c) there exists a direct r-reduct
(λx.M')N' of Q such that M'[x := N'] →∗ P.

Let n ≥ 0 and (λx.M )N →∗
P. There exists P' such that P →∗
P' and

M [x := N ] →∗ P'.
a) CRr ∈ SAT	b) CRr ∈ VAR	c) CRr ∈ ABS

Pseudo Development Deﬁnitions
Throughout, we take c to be a distinct metavariables ranging over Var.

Remark 2.3 Such a distinct variable is usually given not as metavariable, but as a new variable or constant [6,11,12]. We noted that this usual way leads to problems.
For example, Ghilezan and Kunˇcak [6] use two of these distinct variables (called
f and g and introduced as “predefined constants” not belonging to the untyped λ- calculus). But the “freezing” function Ψ defined by Ghilezan and Kunˇcak (similar to our function Ψc) is proved to be a function from Λ to Λ0 where Λ0 is defined as
follows: Λ0 = {M ∈ Λ | (∃x1,..., xn)Γ0, x1 : 0,..., xn : 0 ▶ M : 0}, which is the set of terms in Λ which are typable in λ→ (0 is a ground type and Γ0 is a predefined type environment). Hence, by their definition, Λ0 ⊂ Λ. So, it is obvious that their function Ψ does not associate a term in Λ0 to each term in Λ since Ψ adds some f and g to the terms (for example Ψ(xx) = fxx, but fxx /∈ Λ, so fxx /∈ Λ0).
Moreover, typing environments (contexts) are defined as sets of type assignments of the form x : ϕ where x is a term variable and ϕ is a simple type. Later, some contexts are built with type assignments of the form f : ϕ, but f is not defined as a term variable. More generally, the introduction of a new variable or a new constant implies that the considered type system has to be defined on the new calculus.
Koletsos and Stavrinos [11], define two sets CR, CR0 ⊆ Λ which turn out to be
equal to ours. Koletsos and Stavrinos prove that each term typable in the type system D has the Church-Rosser property. The proof of this statement fails, for example, for terms with free variables not belonging to the set of variables of the initial λ-calculus (c is defined as a variable not belonging to this set), since the proof
uses the fact that the free variables of the term belong to the set CR0. But, further,
this statement is used for a term which may contain some c.

We call current redex the occurrence of a redex in a given term M . We call potential redex an application which is not an occurrence of a redex in a given term M but which is the occurrence of a redex in the term obtained after at least one reduction step from M . As done by Krivine [12] and followed by many others [6,11,8], we use c to “freeze” some current or potential redexes in a term. The parametrised calculi (with parameter c) presented in Definition 2.4 are the “frozen” calculi based on the λ-calculus where some reductions are blocked by the use of
c. For example (λx.xy)(λz.z) →β (λz.z)y →β y, but (λx.cxy)(λz.z) →β c(λz.z)y
which does not reduce further. It is easy to see that Λβ ⊂ Λβη ⊂ Λ.
c	c

Definition 2.4 [Λβ, Λβη]	Let ¯x , ¯y ∈ Var = Var \ {c}.
c	c	c
M¯ ∈ Λβ ::= ¯x | λ¯x .M¯ | (λ¯x .M¯ 1)M¯ 2 | cM¯ 1M¯ 2
M¯ ∈ Λβη ::= ¯x | λ¯x .M¯ | (λ¯x .M¯ 1)M¯ 2 | cM¯ 1M¯ 2 | cM¯

We let M¯ , N¯ , P¯ , Q¯ , R¯
range over both Λβ and Λβη.

c	c
Definition 2.5, introduces the “freezing” function which allows to “freeze” the potential redexes of a term. Unlike definitions in the literature [6,11,12,8], with our definition (the third clause below), the current β-redexes of a term are all “un- frozen”. Furthermore, our definition does not freeze any of the current or potential η-redexes. For example, M = λx.(λy.czx)z does not contain any η-redex but con- tains a potential η-redex, since M →β λx.czx = N and N contains a η-redex. As we will see in this paper, it is not necessary to “freeze” the potential η-redexes.
Definition 2.5 [Ψc(−)]	Ψc(−) is defined as follows:
Ψc(x) = x
Ψc(λx.N ) = λx.Ψc(N ), where x /∈ {c}
If P is a λ-abstraction then Ψc(P Q) = Ψc(P )Ψc(Q)
If P is not a λ-abstraction then Ψc(P Q) = cΨc(P )Ψc(Q).
Definition 2.6 introduces the reduction →c which allows to remove the c’s from a term. This reduction can be regarded as a simplification of the reduction →o defined by Ghilezan and Kunˇcak [6].
Definition 2.6 [→c] Let the c-reduction relation →c be the least compatible re- lation on Λ closed under the rule:	(c) : cM →c M
As usual →∗ is the reflexive and transitive closure of →c.
In Definition 2.7, we introduce our β-developments (→1) as well as our βη- developments (→2).
Definition 2.7 [Developments: →1, →2]  Let ⟨r, s⟩∈ {⟨1, β⟩, ⟨2, βη⟩}.
M →r N ⇐⇒ ∃P. Ψc(M ) →∗ P ∧ P →∗ N ∧ c /∈ fv(M ) ∪ fv(N )
s	c
As usual, →∗ is the reflexive and transitive closure of →r. (Note that →r is reflexive, but in order not to have to introduce a new symbol for its transitive closure, we consider →∗.)
Definition 2.8 defines the parametric set of terms Ac built over the parameter c using application. Such terms contain only c’s and no abstraction. This set of terms is especially needed to state Lemma 2.9.vii. The particularity of such terms being that they can be completely erased by the c-reduction (see Lemma 2.9.v).
Definition 2.8 d ∈ Ac ::= c | dd
Lemma 2.9 is informative about the reduction relation →c.

Lemma 2.9	(i) Ψc(M ) →∗ M.
If M →∗ N then fv(M ) \ {c} = fv(N ) \ {c}.
fv(M ) \ {c} = fv(Ψc(M )) \ {c}.
Λβ ∩ A = ∅ = Λβη ∩ A .
c	c	c	c
d M →∗ M.
If M →∗ N then M ∈ Ac iff N ∈ Ac.
Let M →∗ N.
If M = x then N = x.
If M = λx.M1 then N = λx.N1 such that M1 →∗ N1.
If M = M1M2 then either M1 ∈ Ac and M2 →∗ N or N = N1N2 and
M1 →∗ N1 and M2 →∗ N2.
c	c
If M →∗ M', N →∗ N' and x /= c then M [x := N ] →∗ M'[x := N'].
c	c	c
If c /∈ fv(M ) and M →∗ N then M = N.
If M →∗ N, M →∗ P and c /∈ fv(N ) then P →∗ N.
c	c	c
Proof. i,viii,x. By induction on the structure of M .
Corollary of Lemma 2.9.i and Lemma 2.9.ii.

Let M¯ ∈ Λβη. By induction on the structure of M¯
that M¯
/∈ Ac.

By induction on the structure of d.
⇒) By induction on the length of the reduction M →∗ d . ⇐) By induction on
the reduction d →∗ N .
vii,ix. By induction on the length of the reduction M →∗ N .	 
Lemma 2.9.i stresses the relation between →c and the freezing function. Lemma 2.9.vii presents the shape of a term w.r.t. a c-reduction.
Lemma 2.9.x is a sort of weak confluence property w.r.t. →∗.

A simple Church-Rosser proof for β-reduction
Koletsos and Stavrinos [11] gave a proof of the Church-Rosser property for the set of terms typable in an intersection type system called system D [12] w.r.t. β-reduction and showed that this can be used to establish the confluence of β-developments without using strong normalisation. Ghilezan and Kunˇcak [6] gave a proof of the Church-Rosser property for the set of terms typable in λ→ w.r.t. β-reduction and showed that this can be used to establish the confluence of a weak form of β- developments without using strong normalisation.
The first aim of this section, was to simplify the proof of Koletsos and Stavrinos [11]. During this simplification, we obtained a proof that bore some resemblance to the proof of Ghilezan and Kunˇcak [6]. A second simplification of our proof started with the observation that in both proofs of [6,11] only few types were really needed and that one can actually completely get rid of the type system. We considered two type interpretations based on the sets CRβ and CRβη and interpreted the few needed types by sets of terms satisfying simple properties: saturation, variable and

abstraction (see Definition 2.1). Since the calculus used by Koletsos and Stavrinos to prove the confluence of developments is simpler than the one used by Ghilezan and Kunˇcak, a third simplification which led to our actual simple proof has been to come back to the use of a calculus similar to the one used by Koletsos and Stavrinos as well as Krivine [12] before them (see Definition 2.4). As mentioned above, our proof is carried out in an untyped setting but one can relate the first part of the method to the reducibility proof in a semantic method using, for example, the type system D. Interestingly, our proof can also be related to the proof given in [1,2].
The second aim of this section is to provide a framework for our main result: the extension of our proof to βη-reduction where we give a non semantic proof of Church-Rosser for βη-reduction which can be projectable into a semantic proof (Section 4).
As part of our simplification of a reducibility method, Lemma 3.1 states the
“soundness” of our simple calculus (based on the set of terms Λβ w.r.t. the re-
mains of our type interpretation using a set s satisfying the saturation, variable and abstraction properties given in Definition 2.1).
Lemma 3.1 (Soundness) If M¯ ∈ Λβ, fv(M¯ ) \ {c} = {x ,...,x }, for all i ∈
c	1	n
{1,..., n}, Mi ∈ s and s ∈ VAR ∪ SAT ∪ ABS then M¯ [x1 := M1,..., xn := Mn] ∈ s.
Proof. By induction on the structure of M¯ .	 
Using Lemma 3.1, we are now able to prove that each term in Λβ has β-CR.
Corollary 3.2 Λβ ⊆ CR.

Proof. Let	M¯
∈	Λβ	and	fv(M¯ ) \ {c}	=	{x ,...,x }.	By

c	1	n
Lemma 2.2.viii.(a), 2.2.viii.(b) and 2.2.viii.(c), CR ∈ SAT ∪ VAR ∪ ABS and
x1,..., xn ∈ CR. So by Lemma 3.1, M¯ ∈ CR.	 
Lemma 3.3 states that the freezing function associates to each term of the un- typed λ-calculus (which does not contain c) a term in the language Λβ.
Lemma 3.3 If c /∈ fv(M ) then Ψ (M ) ∈ Λβ.
c	c
Proof. By induction on the structure of M .	 
Here is another lemma containing needed technicalities:
Lemma 3.4 Let M¯ , N¯ ∈ Λβ and ¯x ∈ Var .
c	c
M¯ [¯x := N¯ ] ∈ Λβ.

If M¯
→∗ N then N ∈ Λβ.

β	c

If M¯
→∗ N and c /∈ fv(N ) then M¯
→∗ Ψc(N ).

There exists N such that c /∈ fv(N ) and M¯
→∗ N.

Proof. Items i, iii and iv are by induction on the structure of M¯ . Item ii is by
induction on the length of the derivation M¯ →∗ N .	 

The second property (3.4.ii) states that the terms in Λβ β-reduce only to terms
in Λβ.  The fourth property (3.4.iv) expresses that a term in Λβ can always be
c	c
completely reduced w.r.t. →∗.
Lemma 3.5 states that we can simulate the β-reduction of a term in Λβ from
any of its (partially or totally) “unfrozen” versions.

Lemma 3.5	(i) If M¯ 1
∈ Λβ, M¯ 1 →β
N1 and M¯ 1
→∗ M2
then there exists N2
such

that M2 →β N2 and N1 →∗ N2.

(ii) If M¯ 1 ∈ Λβ, M¯ 1 →∗ N1
and M¯ 1
→∗ M2
then there exists N2
such that M2	∗

N2 and N1 →∗ N2.
Proof.
By induction on the structure of M¯ 1.
By induction on the length of the reduction M1 →∗ N1 using Lemma 3.5.i.

Lemma 3.6 is a key lemma of the simulation method of a reduction by some developments. It states that the reflexive and transitive closure of →β is equal to the reflexive and transitive closure of →1.
Lemma 3.6 Let c /∈ fv(M ) ∪ fv(N ), then M →∗ N ⇐⇒ M →∗ N.
β	1
Proof.
⇒) Let M →∗ N . We prove that M →∗ N by induction on the size of the reduction

β
M →∗ N .
⇐) Let M →∗
1

N .  We prove that M →∗

N by induction on the size of the

derivation M →∗ N .

Lemma 3.7 states the confluence of the β-developments.
Lemma 3.7	(i) If M →1 M1 and M →1 M2 then there exists M3 such that
M1 →1 M3 and M2 →1 M3.
(ii) If M →∗ M1 and M →∗ M2 then there exists M3 such that M1 →∗ M3 and
1	1	1
M2 →∗ M3.

Proof.
i By definition, there exist P1, P2 such that Ψc(M ) →∗


P1, Ψc(M ) →∗


P2,

P1 →∗ M1, P2 →∗ M2 and c /∈ fv(M ) ∪ fv(M1) ∪ fv(M2). By Lemma 3.3,

Ψ (M ) ∈ Λβ. So by Corollary 3.2, there exists P
such that P
→∗ P
and

c	c	3
β	3

P →∗ P . By Lemma 3.4.ii, P ,P ,P 
∈ Λβ. By lemma 3.4.iv, there exists

β	3
1	2	3	c

M3 such that P3 →∗ M3 and c /∈ fv(M3). By Lemma 3.4.iii, P1 →∗ Ψc(M1)
c	c
and P2 →∗ Ψc(M2). By Lemma 3.5.ii, there exist Q1, Q2 such that P3 →∗ Q1,
c	c
P3 →∗ Q2, Ψc(M1) →∗ Q1 and Ψc(M2) →∗ Q2. By Lemma 2.9.x, Q1 →∗ M3
c	β	β	c
and Q2 →∗ M3. So M1 →1 M3 and M2 →1 M3.

ii By Lemma 3.7.i

The confluence of the untyped λ-calculus w.r.t. β-reduction is now proved using the confluence of the β-developments and the equality between →∗ and →∗.
β	1
Theorem 3.8 Λ = CR.
Proof. CR ⊆ Λ is trivial, we only prove Λ ⊆ CR. Let M, M1, M2 ∈ Λ such that
M →∗ M1 and M →∗ M2 and c /∈ fv(M ). By Lemma 2.2.iii, c /∈ fv(M1) ∪ fv(M2.).
β	β

By Lemma 3.6, M →∗
M1 and M →∗
M2. By Lemma 3.5.ii, there exists M3

such that M1 →∗ M3 and M2 →∗ M3. By definition c /∈ fv(M3). By Lemma 3.6,
1	1
M1 →∗ M3 and M2 →∗ M3.	 
β	β
A simple Church-Rosser proof for βη-reduction
Now that we have stated the principal steps of the method of the Church-Rosser property of the untyped λ-calculus w.r.t. β-reduction, we will generalise it to βη- reduction following exactly the same steps and using the Λβη language. This gener- alisation can be regarded both as a simplification and an extension of methods by for example Ghilezan and Kunˇcak [6], Kamareddine and Rahli [8] and Barendregt et al. [1,2] (Section 11.2).
As part of our simplification of a reducibility method, Lemma 4.1 states the “soundness” of our simple calculus based on the set of term Λβη w.r.t. the remains of our type interpretation based on a set s satisfying the saturation, variable and abstraction properties (see Definition 2.1).
Lemma 4.1 (Soundness) If M¯ ∈ Λβη, fv(M¯ ) \ {c} = {x ,...,x }, for all i ∈
c	1	n
{1,..., n}, Mi ∈ s and s ∈ SAT ∪ VAR ∪ ABS then M¯ [x1 := M1,..., xn := Mn] ∈ s.
Proof. By induction on the structure of M¯ .	 
Using lemma 4.1, we are now able to prove that each term in Λβη has βη-CR.
Corollary 4.2 Λβη ⊆ CRβη.

Proof. Let	M¯
∈	Λβη
and	fv(M¯ ) \ {c}	=	{x ,...,x }.	By

c	1	n
Lemma 2.2.viii.(a), 2.2.viii.(b) and 2.2.viii.(c),  CRβη	∈  SAT ∪ VAR ∪ ABS
and x1,..., xn ∈ CRβη. So by Lemma 4.1, M¯ ∈ CRβη.	 
Lemma 4.3 states that the freezing function associates to each term of the un- typed λ-calculus (which does not contain the variable c) a term in Λβη. This result
is trivial because Λβ ⊂ Λβη.
c	c
Lemma 4.3 If c /∈ fv(M ) then Ψ (M ) ∈ Λβη.
c	c
Proof. By Lemma 3.3, Ψ (M ) ∈ Λβ. Since Λβ ⊂ Λβη then Ψ (M ) ∈ Λβη.	 
c	c	c	c	c	c
Here is another lemma containing needed technicalities:

Lemma 4.4 Let M¯ , N¯ ∈ Λβη and ¯x ∈ Var .
c	c
M¯ [¯x := N¯ ] ∈ Λβη.

If M¯
∗  N then N ∈ Λβη.

If M¯
→∗ N and c /∈ fv(N ) then M¯
→∗ Ψc(N ).

There exists N such that c /∈ fv(N ) and M¯
→∗ N.

Proof. Items i, iii and iv are by induction on the structure of M¯ . Item ii is by
induction on the length of the derivation M¯	∗  N .	 
The second property (4.4.ii) states that the terms in Λβη β-reduce only terms in Λβη. The fourth property (4.4.iv) expresses that a term in Λβη can always be
c	c
completely reduced w.r.t. →∗.
Lemma 4.5 states that we can simulate the reduction of a term in Λβη from any
of its (partially or totally) “unfrozen” versions.

Lemma 4.5	(i) If M¯ 1
∈ Λβη, M¯ 1
→βη N1
and M¯ 1
→∗ M2
then there exists N2

such that M2 →βη N2 and N1 →∗ N2.

(ii) If M¯ 1
∈ Λβη such that M¯ 1
∗
βη	1
and M¯ 1
→∗ M2
then there exists N2
such

that M2 →∗ N2 and N1 →∗ N2.
Proof. i. By induction on the structure of M1. ii. By Lemma 4.5.i.	 
Lemma 4.6 is a key lemma of the simulation method of a reduction by some developments. It states that the reflexive and transitive closure of →βη is equal to the reflexive and transitive closure of →2.
Lemma 4.6 Let c /∈ fv(M ) ∪ fv(N ), then M →∗ N ⇐⇒ M →∗ N.

Proof.
⇒) Let M →∗


N .  We prove that M →∗


N by induction on the size of the

reduction M →∗ N .

⇐) Let M →∗
N .  We prove that M →∗
N by induction on the size of the

derivation M →∗ N .

It is then easy to deduce the confluence of the βη-developments.
Lemma 4.7	(i) If M →2 M1 and M →2 M2 then there exists M3 such that
M1 →2 M3 and M2 →2 M3.
(ii) If M →∗ M1 and M →∗ M2 then there exists M3 such that M1 →∗ M3 and
2	2	2
M2 →∗ M3.

Proof.
i By definition, there exist P1, P2 such that Ψc(M ) →∗


P1, Ψc(M ) →∗


P2,

P1 →∗ M1, P2 →∗ M2 and c /∈ fv(M ) ∪ fv(M1) ∪ fv(M2). By Lemma 4.3,

Ψ (M ) ∈ Λβη. So by Corollary 4.2, there exists P
such that P  →∗  P  and

c	c	3
βη	3

/ M 
/	 
/	 

/
/
/
I  /	/o
v
Ψ(M )	I
o 

/	/s
/	M1	M2

/	o
/	/	 
/	/
/so/ 
M3	 
 

P / ) Ψ(P ) ) P /s	β /	β	 Q (  Ψ(Q)(  Q



 Ψ	o
 
1
 o 
/
/s/
1 o
/s/o	/

P2	Q2	/
zzz	/

	za
 
 
 
 c β	/
2	/
ˆo	/ I

Ψ(R)	/
ˆΨ /
/
/ 
R
Fig. 2. The method of Ghilezan and Kunˇcak for the confluence of →I


P →∗ P . By Lemma 4.4.ii, P ,P ,P 
∈ Λβη. By lemma 4.4.iv, there exists

βη	3
1	2	3	c

M3 such that P3 →∗ M3 and c /∈ fv(M3). By Lemma 4.4.iii, P1 →∗ Ψc(M1)
c	c
and P2 →∗ Ψc(M2). By Lemma 4.5.ii, there exist Q1, Q2 such that P3 →∗ Q1,

c
P3 →∗ Q2, Ψc(M1) →∗
Q1 and Ψc(M2) →∗
c
Q2. By Lemma 2.9.x, Q1 →∗ M3

c	βη	βη	c
and Q2 →∗ M3. So M1 →2 M3 and M2 →2 M3.
ii Easy by Lemma 4.7.i.

The confluence of the untyped λ-calculus w.r.t. βη-reduction is then proved using
the confluence of the βη-developments and the equality between →∗  and →∗.
Theorem 4.8 Λ = CRβη.
Proof. CRβη ⊆ Λ is trivial, we only prove Λ ⊆ CRβη.  Let M, M1, M2 ∈ Λ and

c /∈ fv(M ) such that M →∗
M1 and M →∗
M2. By Lemma 2.2.iii, c /∈ fv(M1) ∪

fv(M2). By Lemma 4.6, M →∗ M1 and M →∗ M2. By Lemma 4.7.ii, there exists
2	2
M3 such that M1 →∗ M3 and M2 →∗ M3. By definition c /∈ fv(M3). By Lemma 4.6,

M1 →∗
2
M3 and M2 →∗
2
M3.	 

Comparison and Related Work
In this section we compare our proposal to two semantic methods to prove confluence [6,11]. We also compare our developments to those of Tait and Martin-Lo¨f. In this section and only in this section, we consider the confluence property w.r.t. β- reduction. In the Figures 2 and 3, an arrow labelled with c, o or β stands for →∗,
→∗ or →∗ respectively. An arrow labelled with Ψ stands for the application of the
o	β
function with the same name to the term at the start of the arrow.

Comparison to Ghilezan+Kuncak and to Koletsos+Stravinos
In Figure 2 we recall the proof of Ghilezan and Kunˇcak [6] for the confluence of the untyped λ-calculus w.r.t. β-reduction. This proof, based on the embedding of the developments into λ→, uses the confluence w.r.t. another reduction →I (a

development) whose transitive closure is equal to →∗ . The reduction →I is defined
as τ−1◦ →∗ ◦τ where:
τ =→∗ ◦Ψ
→o is the compatible closure of the rule (o) : f (g(λx.M ))N →o (λx.M )N
Ψ is defined on the λ-calculus by: Ψ(x) = x, Ψ(λx.M ) = g(λx.Ψ(M )) and Ψ(MN ) = f Ψ(M )Ψ(N ), where f and g are two constants (see Remark 2.3).
The relation τ enables to “freeze” some β-redexes and the potential β-redexes (the other applications) of a term. (In fact, τ does more, because Ψ does more by encapsulating the λ-abstractions using g. This technicality is needed by Ghilezan and Kunˇcak to prove the typability of a defined set of terms in λ→.) The reduction τ−1 is similar to our erasure relation →c (see Definition 2.6) and to Krivine’s erasure function [12], which “unfreeze” the redexes in a term. By definition of M →I P ,
there exist M1 and P1 such that Ψ(M ) →∗ M1 →∗ P1 and Ψ(P ) →∗ P1 (the left
o	β	o
part of the figure). By definition of M →I Q, there exist M2 and Q1 such that

Ψ(M ) →∗
M2 →∗
Q1 and Ψ(Q) →∗
Q1 (the right part of the figure).  Because

M1 can be different from M2, a confluence lemma for the →o reduction and a
commutation lemma for the reductions →∗ and →∗ are needed. The central part
o	β
of the figure is due to the confluence of the terms typable in λ→. For example, as cited by Ghilezan and Kunˇcak, Koletsos [10] proved this result using a reducibility method. Hence, when combined with Koletsos’s proof of the confluence of λ→, Ghilezan and Kunˇcak’s method can be regarded as the combination of a reducibility method and a simulation method.
The reduction →I designed by Ghilezan and Kunˇcak [6] defines a development without specifying explicitly the set of redexes which are allowed to be reduced (as done for example by Barendregt al. [1] which differs from approaches like those of Barendregt [2] or Hindley [7]). Let us consider the reduction M →I P (unfolded above). First, the function Ψ blocks all the redexes in M . Then →∗ enables to select the set of redexes which are allowed to be reduced in M without explicitly naming them, by unblocking some redexes in Ψ(M ). The reduction M1 →∗ P1 reduces the allowed redexes and their residuals. And finally in Ψ(P ) →∗ P1, the reduction →∗
o	o
selects the set of residuals of the set of redexes in M1 without naming them.
This way of dealing with occurrences of redexes is simple and sufficient enough to prove the Church-Rosser property. However, in some other works, occurrences of redexes are handled in a complicated way, as for example in the work of Krivine [12] or Koletsos and Stavrinos [11]. In these works, occurrences are treated intuitively and not formally. So, the work turns out to be much more complicated than it seems when one wants to “formally” prove the results (see [8]), or even just formally defining the developments. Ghilezan and Kunˇcak [6] do not face the same problem.
The reduction →∗ enables to unblock a certain set of redexes without explicitly
specifying the set of unblocked redexes. In the work of Ghilezan and Kunˇcak, as in the work of Barendregt et al. [1] for example, a development of a term is defined without explicit control on the set of occurrences of reduced redexes, which is not needed.

Although Ghilezan and Kunˇcak [6] consider a simpler definition of develop- ments than the “common” one, the scheme of their proof method is exactly the one followed by Koletsos and Stavrinos [11]. Koletsos and Stavrinos consider the following “common” definition of developments: there exists a development from
M to N iff ⟨M, s1⟩ →∗ ⟨N, s2⟩ where s1 is a set of redexes in M and s2 is
the set of residuals of s1 in N (where →∗ is a new (complex) reduction relation
based on →∗ ). Their proof of the confluence of developments uses, among other
things, the following claim: if ⟨M, s1⟩ →∗ ⟨N, s2⟩ then there exists s4 such that
⟨M, s1 ∪ s3⟩ →∗ ⟨N, s2 ∪ s4⟩, where s3 is a set of redexes of M . It is useful to prove
that if ⟨M, s1⟩ →∗ ⟨M1, s' ⟩ and ⟨M, s2⟩ →∗ ⟨M2, s' ⟩ then there exist s'' and s'' such
d	1	d	2	1	2
that ⟨M, s1 ∪ s2⟩ →∗ ⟨M1, s' ∪ s''⟩ and ⟨M, s2 ∪ s1⟩ →∗ ⟨M2, s' ∪ s''⟩. This corre-
d	1	2	d	2	1
sponds to the proof of the confluence of →∗ of Ghilezan and Kunˇcak, which is useful
to get the reductions (Ψ(M ) →∗ M1 →∗ M3 →∗ P2 and Ψ(P ) →∗ P1 →∗ P2) and
o	o	β	o	o
(Ψ(M ) →∗ M2 →∗ M3 →∗ Q2 and Ψ(Q) →∗ Q1 →∗ Q2). Ghilezan and Kunˇcak
o	o	β	o	o
emphasise this more strongly than Koletsos and Stavrinos.
The differences between the method of Ghilezan and Kunˇcak and that of Baren- dregt et al include:
Ghilezan and Kunˇcak do not use the finiteness of developments when Barendregt et al. do;
Ghilezan and Kunˇcak base their result on a well known result (the confluence of the simply typed λ-terms) to give a simple proof of the confluence of developments when Barendregt et al. have to prove everything;
Ghilezan and Kunˇcak do not really introduce new terms when Barendregt et al. do (the underlined terms are introduced to prove the confluence of developments).
Barendregt et al. also give a definition of developments without explicitly naming an occurrence of a redex (no set of occurrences is defined), introducing among other things, a second abstraction λ. There exists a simple correspondence between the calculus with this second abstraction and the marked calculus introduced by Krivine and reused in this paper and in many other works [12,6,11,8].
In Figure 3 we draw the diagram of our method to prove the confluence of the
λ-calculus. By definition of M →1 P (Definition 2.7), there exists P1 such that Ψ(M ) →∗ P1 and P1 →∗ P (the left part of the figure). By definition of M →1 Q,
β	c
there exists Q1 such that Ψ(M ) →∗ Q1 and Q1 →∗ Q (the right part of the figure).
β	c
Moreover P1 →∗ Ψc(P ) and Q1 →∗ Ψc(Q). So, because P1 and Ψc(P ) might be
c	c
different (as for Q1 and Ψc(Q)), as Ghilezan and Kunˇcak [6], we need a commutation
result for the reductions →∗ and →∗. Then, the whole diagram commutes because
β	c
P2, R1 and Q2 reduce to the same term. Like in Figure 2, the central part is due
to the confluence of a defined set of terms (typable in λ→ for Ghilezan and Kunˇcak and typable in D in our case even though we do not use this fact).
Our method is also based on some kind of simple developments, where first, all the β-redexes are left unblocked and where all the potential β-redexes (all the other applications) are blocked. In this paper we define two simple developments: →1 for the β case and →2 for the βη case. In that way, we do not need the reduction →∗ to



M
/ 
/
/
/
/
/
/
/	Ψ(M )
/	/ 
/	/	 
/
	c	/s		c
P (	 P1	Q1 	) Q
zzz

zz	/ 
/	/

Ψ z’ /sc
/	c    Ψ /

Ψ(P )	β	/ β	Ψ(Q)	/
	  /s	/	/
	R1	/	/

c/  c
/s/	/

	/s
	P2
	\	c
	\
  c \
	/
Q2	/  1
/	/
/	/
/ /

\	/ /
  \ v/r/ /
/s
R
Fig. 3. Our method for the confluence of →1

unblock some redexes in order to perform some reductions. But, it does not seem possible to get rid of the work done by this reduction. Indeed, our choice implies the introduction of some other material which turns out to be similar to the reduction
→∗. Both methods need the introduction of some similar material, but not at the same places. The reduction →∗ is used by Ghilezan and Kunˇcak to unblock some
redexes in order to enable some reductions whereas we use the reduction →∗ to
unblock some redexes which become blocked after some reductions.
As we can see in these two figures, because the occurrences of redexes are not explicitly taken into consideration, the function Ψ (which enables to embed a term in a typed term, by blocking redexes or potential redexes) needs to either block all the redexes of a term or to leave them all unblocked. If all the redexes are blocked by Ψ, a reduction such as →o is needed before being able to perform some reductions (see Figure 2). In this case some technical results are needed such as the confluence of →o. In the other case (Ψ leaves all the redexes unlocked), because a term whose redexes are all unblocked does not necessarily reduce to a term whose redexes are all unblocked, some technical results on a reduction such as →o are also needed as we explained above (see Figure 3).
Finally, although our work derives from the one done by Koletsos and Stavri- nos [11] and Kamareddine and Rahli [8], it turned out that it is also a simplification and generalisation of the work done by Ghilezan and Kunˇcak [6] and Barendregt et al. [1]. Because the work we achieved is more similar to the one of Ghilezan and Kunˇcak, we adapted some of our notations to theirs and focused our comparisons with the related work to their work.
Thereby, the two improvements of the present article can be regarded as the simplification of the work done by Ghilezan and Kunˇcak [6] by getting rid of all the type machinery and the extension of the defined method to the βη-reduction.
As explained above, the main lines of our proof are:
the definition of some simple developments;

the proof of the confluence of a simple calculus w.r.t. the considered reduction (β and βη) using a method based on a simplification of a reducibility method;
the proof of the confluence of the defined developments;
the proof of the equality between the reflexive and transitive closure of the devel- opments and the reflexive and transitive closure of the considered reduction;
the proof of CR of the untyped λ-calculus w.r.t. a given reduction using a simu- lation of the considered reduction by developments.

Comparison to Tait and Martin-Lo¨f
Tait and Martin-Lo¨f’s syntactic proof [13,2] (and its extensions, by for example Takahashi [15]) that the untyped λ-calculus satisfies the Church-Rosser property is the simplest so far. Our method started from the semantic framework when we attempted to simplify and generalise existing semantic proofs. To our surprise, our simplification and generalisation of such semantic proofs led to our method which did not need types anymore. Hence, the type interpretation and the reducibility argument are no longer used in our article. This way our method moved from the semantic camp to the syntactic one. Nonetheless, our method can still be projected into a semantic argument method (something that does not hold for methods like those of Tait and Martin-Lo¨f and Takahashi). In this way, we consider our work to be a bridge between the syntactic and semantic methods. There is another notable difference to our method: our developments allow (strictly) more reductions than those of Takahashi (for both the β and βη cases) as we establish in this section.
Definition 5.1 [[15]] Let r ∈ {β, βη}. We define ⇒r as follows:
M ⇒r M
λx.M ⇒r λx.N if M ⇒r N
MN ⇒r M'N' if M ⇒r M' and N ⇒r N'
(λx.M )N ⇒r M'[x := N'] if M ⇒r M' and N ⇒r N'
λx.Mx ⇒βη N if x /∈ fv(M ) and M ⇒βη N
Lemma 5.2	(i) If M ⇒β N or M ⇒βη N then fv(N ) ⊆ fv(M ).
Let M, N such that c /∈ fv(M ) ∪ fv(N ). If M ⇒β N then M →1 N.
Let M, N such that c /∈ fv(M ) ∪ fv(N ). If M ⇒βη N then M →2 N.
Proof. ii. Let M ⇒β N . The proof is by induction on the size of the derivation of
M ⇒β N and then by case on the last rule of the derivation.
iii. Let M ⇒βη N .  The proof is by induction on the size of the derivation of
M ⇒βη N and then by case on the last rule of the derivation.	 
Remark 5.3	(i) We have M  =  (λx.xx)((λz.z)y)  →1 y((λz.z)y) (where c  /∈
{x, y, z}) because Ψc(M ) = (λx.cxx)((λz.z)y) →β c((λz.z)y))((λz.z)y) →β
cy((λz.z)y) →c y((λz.z)y). But, we do not have M ⇒β y((λz.z)y).

(ii) We have M = λx.y((λz.z)x) →2 y (where c /∈ {x, y, z}) because Ψc(M ) = 
λx.cy((λz.z)x) →β λx.cyx →η cy →c y. But, we do not have M ⇒βη y.

References
H. Barendregt, J. A. Bergstra, J. W. Klop, and H. Volken. Degrees, reductions and representability in the lambda calculus. Technical Report Preprint no. 22, University of Utrecht, Department of Mathematics, 1976.
H. P. Barendregt. The Lambda Calculus: Its Syntax and Semantics. North-Holland, revised edition, 1984.
Henk P. Barendregt. Lambda calculi with types. In Handbook of Logic in Computer Science, Volumes 1 (Background: Mathematical Structures) and 2 (Background: Computational Structures), Abramsky & Gabbay & Maibaum (Eds.), Clarendon, volume 2. 1992.
Alonzo Church. A formulation of the simple theory of types. The Journal of Symbolic Logic, 5(2):56–68, 1940.
Alonzo Church and John B. Rosser. Some properties of conversion. Transactions of the American Mathematical Society, 39(3):472–482, 1936.
Silvia Ghilezan and Viktor Kunˇcak. Confluence of untyped lambda calculus via simple types. Lecture Notes in Computer Science, 2202:38–49, 2001.
R. Hindley. Reductions of residuals are finite. Transactions of the American Mathematical Society, 240:345–361, June 1978.
Fairouz Kamareddine, Vincent Rahli, and J. B. Wells. Reducibility proofs in the λ-calculus. Presented to ITRS ’08, 4th Workshop on Intersection Types and Related Systems, Turin, Italy, 25 March 2008, 2007.
S. C. Kleene. On the interpretation of intuitionistic number theory. The Journal of Symbolic Logic, 10(4):109–124, 1945.
G. Koletsos. Church-Rosser theorem for typed functional systems. Journal of Symbolic Logic, 50(3):782–790, 1985.
G. Koletsos and G. Stavrinos. Church-Rosser property and intersection types. Australasian Journal of Logic, 2007.
J. L. Krivine. Lambda-calcul, types et mod`eles. Dunod, 1990.
Jean-Jacques L´evy. An algebraic interpretation of the lambda beta k-calculus; and an application of a labelled lambda -calculus. Theoretical Compututer Science, 2(1):97–114, 1976.
W. W. Tait. Intensional interpretations of functionals of finite type I. The Journal of Symbolic Logic, 32(2):198–212, 1967.
Masako Takahashi. Parallel reductions in lambda-calculus. Journal of Symbolic Computation, 7(2):113–123, 1989.
