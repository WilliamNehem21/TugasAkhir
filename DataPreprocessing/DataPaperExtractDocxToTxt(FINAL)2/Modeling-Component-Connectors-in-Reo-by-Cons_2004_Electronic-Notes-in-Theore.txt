	Electronic Notes in Theoretical Computer Science 97 (2004) 25–46	
www.elsevier.com/locate/entcs




Modeling Component Connectors in Reo by Constraint Automata
(Extended Abstract)

Farhad Arbaba, Christel Baierb, Jan Ruttena,c, Marjan Sirjania,d
a Centrum voor Wiskunde en Informatica, Department of Software Engineering Kruislaan 413, P.O.Box 94079, 1090 GB Amsterdam, The Netherlands
{Farhad.Arbab,Jan.Rutten,Marjan.Sirjani}@cwi.nl
bInstitut für Informatik I, University of Bonn Römerstraße 164, D-53117 Bonn, Germany baier@cs.uni-bonn.de
c Vrij Universiteit
De Boelelaan 1081, 1081 HV Amsterdam, The Netherlands
d Sharif University of Technology
Azadi Ave., Tehran, Iran


Abstract
Reo is an exogenous coordination language for compositional construction of component connectors based on a calculus of channels. Building automated tools to address such concerns as equivalence or containment of the behavior of two given connectors, verification of the behavior of a connector, etc. requires an operational semantic model suitable for model checking. In this paper we introduce constraint automata and propose them as a semantic model for Reo.
Keywords: Constraint Automata, Reo, Coalgebraic semantics, Streams, Coordination, Components, Composition


Introduction
Reo is a channel-based exogenous coordination model wherein complex coordina- tors, called connectors, are compositionally built out of simpler ones. The simplest connectors in Reo are a set of channels with well-defined behavior supplied by


1571-0661 © 2004 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2004.04.028

users [1]. The emphasis in Reo is on connectors, their behavior, and their compo- sition, not on the entities that connect, communicate, and cooperate through them. The behavior of every connector in Reo imposes a specific coordination pattern on the entities that perform normal I/O operations through that connector, without the knowledge of those entities. This makes Reo a powerful “glue language” for com- positional construction of connectors to combine component instances into a soft- ware system and exogenously orchestrate their mutual interactions. Reo’s notion of components and connectors is depicted in Figure 1, where component instances are represented as boxes, channels as straight lines, and connectors are delineated by dashed lines. Each connector in Reo is, in turn, constructed compositionally out of simpler connectors, which are ultimately composed out of primitive channels. For instance, the connector in Figure 1.a may in fact be a flow-regulator (if its three constituent channels are of the right type, as described in [1]). Figure 1.a would then represent a system composed out of two writer component instances (C1 and C3), plus a reader component instance (C2), glued together by our flow-regulator connector. Every component instance performs its I/O operations following its own timing and logic, independently of the others. None of these component instances is aware of the existence of the others, the specific connector used to glue it with the rest, or even of its own role in the composite system. Nevertheless, the protocol imposed by our flow-regulator glue code (see [1] and [2]) ensures that a data item passes from C1 to C2 only whenever C3 writes a data item (whose actual value is ignored): the “tokens” written by C3, thus, serve as cues to regulate the flow of data items from C1 to C2. The behavior of the connector, in turn, is independent of the components it connects: without their knowledge, it imposes a coordination pattern among C1, C2, and C3 that regulates the precise timing and/or the volume of the data items that pass from C1 to C2, according to the timing and/or the volume of tokens produced by C3. The other connectors in Figure 1 implement more complex coordination patterns.


(a) a 3−way connector	(b) a 6−way connector	(c) two 3−way connectors and a 6−way connector

Fig. 1. components and connectors

A coalgebraic formal semantics for Reo connectors is developed in [2] in terms of relations on infinite timed data streams. With this semantics as our starting point, in this paper we introduce constraint automata and use them to present an operational

model for the behavior of connectors in Reo. Constraint automata can be thought of as conceptual generalizations of probabilistic automata where simple constraints, instead of probabilities, influence applicable state transitions. The single most im- portant composition operator in Reo, join, amounts to a product of automata in this model.
Our notion of constraint automata is in the spirit of I/O-automata and timed port automata [6,3]. In contrast to these, we do not distinguish between input and output ports (and hence, we do not require input enabledness) and use constraints rather than specific data values. Unlike I/O- or timed port automata, we do not follow
a strictly time-synchronous approach, which becomes important when we com- pose constraint automata. Instead, the composition of constraint automata A1 and A2 allows transitions when data occur at the input/output ports that the resulting automaton inherits from only one of the automata Ai, without involving the tran- sitions or states that it inherits from the other automaton (because at that point in
time, there is no data on any of its corresponding ports). Such transitions do not exist in the “one-to-many-composition” of timed port automata.
The rest of this paper is organized as follows. Section 2 is a brief overview of Reo. In Section 3, we define constraint automata and show their utility through describing the behavior of a number of simple Reo channels as examples. The product of constraint automata and hiding, which are necessary to model Reo’s join operator, are defined and applied to a few examples in Section 4. In Section 5 we study various notions of equivalence, forming a foundation for algorithms and tools for verification and derivation of properties of Reo connectors. We conclude in Section 6, hinting at our current and future work on model checking and automated tools for reasoning about Reo connectors.

A Reo primer
Reo defines a number of operations for components to (dynamically) compose, connect to, and perform I/O through connectors. Atomic connectors are channels. The notion of channel in Reo is far more general than its common interpretation. A channel is a primitive communication medium with exactly two ends, each with its own unique identity. There are two types of channel ends: source end through which data enters and sink end through which data leaves a channel. A channel must support a certain set of primitive operations, such as I/O, on its ends; beyond that, Reo places no restriction on the behavior of a channel. This allows an open- ended set of different channel types to be used simultaneously together in Reo, each with its own policy for synchronization, buffering, ordering, computation, data retention/loss, etc.
A connector is a set of channel ends organized in a graph of nodes and edges such

that:
Zero or more channel ends coincide on every node.
Every channel end coincides on exactly one node.
There is an edge between two (not necessarily distinct) nodes iff there is a chan- nel one end of which coincides on each of those nodes.
A node is an important concept in Reo. Not to be confused with a location or a component, a node is a logical construct representing the fundamental topological property of coincidence of a set of channel ends, which has specific implications on the flow of data among and through those channel ends.


a	b	c	d	e

Fig. 2. Nodes in Reo

The set of channel ends coincident on a node N is disjointly partitioned into the sets
Src(N) and Snk(N), denoting the sets of source and sink channel ends that coincide on N, respectively. A node is called a source node if Src(N) /= Λ Snk(N)=  . Analogously, N is called a sink node if Src(N)=  Λ Snk(N) /= . A node N is called a mixed node if Src(N) /= Λ Snk(N) /= . Figures 2.a and b show sink nodes with, respectively, two and three coincident channel ends. Figures 2.c and d show
source nodes with, respectively, two and three coincident channel ends. Figure 2.e shows a mixed node where three sink and two source channel ends coincide.
Reo provides operations that enable components to connect to and perform I/O on source and sink nodes only; components cannot connect to, read from, or write to mixed nodes. At most one component can be connected to a (source or sink) node at a time. A component can write data items to a source node that it is connected to. The write operation succeeds only if all (source) channel ends coincident on the node accept the data item, in which case the data item is transparently written to every source end coincident on the node. A source node, thus, acts as a repli- cator. A component can obtain data items from a sink node that it is connected to through destructive (take) and non-destructive (read) input operations. A take oper- ation succeeds only if at least one of the (sink) channel ends coincident on the node offers a suitable data item; if more than one coincident channel ends offer suitable data items, one is selected nondeterministically. A sink node, thus, acts as a (fair) nondeterministic merger. A mixed node is a self-contained “pumping station” that combines the behavior of a sink node (merger) and a source node (replicator) in an atomic iteration of an endless loop: in every iteration a mixed node nondetermin- istically selects and takes a suitable data item offered by one of its coincident sink

channel ends and replicates it into all of its coincident source channel ends. A data item is suitable for selection in an iteration only if it can be accepted by all source channel ends that coincide on the mixed node.
It follows that every channel represents a (simple) connector with two nodes. More complex connectors are constructed in Reo out of simpler ones using its join op- eration. Joining two nodes destroys both nodes and produces a new node on which all of their coincident channel ends coincide. This single operation allows con- struction of arbitrarily complex connectors involving any combination of channels picked from an open-ended assortment of user-defined channel types. The seman- tics of a connector is defined as a composition of the semantics of its (1) constituent channels, and (2) nodes. The semantics of channels are defined by the users who provide them. Reo defines the semantics of its three types of nodes, mentioned above.
F








in




out

E	B
a	b

Fig. 3. Exclusive router and shift-lossy FIFO1

Figures 3.a and b show two Reo connectors. We consider these connectors in more detail in Examples 4.5 and 4.6, respectively, in Section 4. Here, we use them to in- troduce our visual syntax for presenting Reo connector graphs and some frequently useful channel types. The enclosing thick boxes in these figures represent hiding: the topologies of the nodes (and their edges) inside the box are hidden and cannot be modified, yielding a connector with a number of input/output ports, represented as nodes on the border of the bounding box, which can be used by other entities outside the box to interact with and through the connector.
The simplest channels used in these connectors are synchronous (Sync) channels, represented as simple solid arrows. A Sync channel has a source and a sink end, and no buffer. It accepts a data item through its source end iff it can simultaneously dispense it through its sink. A lossy synchronous (LossySync) channel is similar to

a Sync channel, except that it always accepts all data items through its source end. If it is possible for it to simultaneously dispense the data item through its sink (e.g., there is a take operation pending on its sink) the channel transfers the data item; otherwise the data item is lost. LossySync channels are depicted as dashed arrows, e.g., in Figure 3.a. The edge BD in Figure 3.b represents an asynchronous channel with the bounded capacity of 1 (FIFO1), with the small box in the middle of the arrow representing its buffer. This channel can have an initially empty buffer, or as in Figure 3.b, contain an initial data value (in this case, the “o” in the box represent- ing its buffer). Analogously, the edge AF in Figure 3.b represents an asynchronous FIFO channel with the bounded capacity of 2 (FIFO2), with its obvious semantics. An example of more exotic channels permitted in Reo is the synchronous drain channel (SyncDrain), whose visual symbol appears as the edges XZ and AC in Fig- ures 3.a and b, respectively. A SyncDrain channel has two source ends. Because it has no sink end, no data value can ever be obtained from this channel. It accepts a data item through one of its ends iff a data item is also available for it to simul- taneously accept through its other end as well. All data accepted by this channel are lost. A close kin of SyncDrain is the asynchronous drain (AsyncDrain) channel (not shown in Figure 3): it has two source ends through which it accepts and loses data items, but never simultaneously.

Modeling connectors by constraint automata
The semantics of Reo connectors can be defined in terms of relations on timed data streams (TDSs) as presented in [2]. In this section we introduce the notion of constraint automata and show how they can serve as operational models for the behavior of Reo connectors by relating the languages of these automata with timed data streams. Here, like in [2], we do not consider the dynamic behavior of com- ponents in creating and composing connectors. Our focus is on the Reo circuits, built from basic connectors (channels and merger) via join and hide operations, without considering the further possibility of join or split. We use constraint au- tomata to specify the operational semantics of Reo because this allows us to adapt the known methods for the analysis of finite state automata to work with constraint automata. Ordinary finite automata are not rich enough to represent the seman- tics of Reo. Constraint automata allow us to model subtle timing and input/output constraints of Reo connectors, specifically their combined mix of synchronous and asynchronous transitions. This is reflected in our definition of constraint automata and we will show it further in our examples.

Let V be any set. We define the set V  of all streams (infinite sequences) over V
as V  = { |  : {0, 1, 2,.. .} → V }. For convenience, we consider only infinite

behavior and infinite streams which correspond to infinite “runs” of our automata, omitting final states including deadlocks. We denote individual streams as  = (0, 1, 2,.. .) (or a = (a0, a1, a2,.. .)). We call 0 the initial value of . The (stream) derivative j of a stream  is defined as j = (1, 2, 3,.. .). Note that (j)n = n+1, for all n ≥ 0. We also recall the definition of timed data streams from [2]:
TDS = ⟨, a⟩∈ Data × IR | ∀n ≥ 0 : an < an+1 and lim an = }
+	n→
A timed data stream ⟨, a⟩ consists of a data stream  ∈ Data and a time stream a ∈ IR consisting of increasing positive real numbers. The time stream a indicates for each data item n the moment an at which it is being input or output.
Constraint automata can be viewed as acceptors for tuples of timed data streams that are observed at certain input/output ports A1,..., An of components. The rough idea is that such an automaton observes the data occurring at A1,..., An and either changes its state according to the observed data or rejects it if there is no corre- sponding transition in the automaton. We use constraint automata as a semantic model to describe the TDS-language induced by Reo connector networks.

Definition of constraint automata
In the sequel, Data is a fixed and finite set of data that can be sent (and received) via channels. Constraint automata use a finite set of names, e.g., A1,..., An where Ai stands for the i-th input/output port of a connector or component 1 . A name- data-assignment denotes a function  : N → Data where N ⊆ N . We use notations
 
to any TDS-name A ∈ N the value dA ∈ Data. The transitions of the automata are labeled with pairs consisting of a subset N of {A1,..., An} and a data constraint g. Data constraints are defined by the following grammar:


g ::= false 
true 
data(A)= d 
g1 ∨ g2 
g1 Λ g2


Here, A, B are names and d ∈ Data. 2 Data constraints (DCs) can be viewed as sets of name-data-assignments. In the sequel, we write DC(N , Data) to denote the set of data constraints. We often use derived DCs such as data(A) /=d or

1 Since, in this paper we consider only the static topology of the Reo circuits, there is no need to distinguish between the nodes and channel ends.
2 We assume a global data domain Data for all names. Alternatively, we can assign a data domain
DataA to every name A and require type-consistency in the definition of data constraints.

data(A)= data(B) which stand for the DCs

_

dj∈Data\{d}
(data(A)= dj)	and	_
d∈Data
  (data(A)= d) Λ (data(B)= d)  ,

respectively. The symbol |= stands for the obvious satisfaction relation which re- sults from interpreting DCs over name-data-assignments. For instance,

 data(A)= d1, data(B)= d2, data(C)= d1  |= data(A)= data(C),
 data(A)= d1, data(B)= d2, data(C)= d1  /= |data(A)= data(B)
if d1 /d=2. Satisfiability and validity, logical equivalence ≡ and logical implication
≤ of DCs are defined as usual; e.g.:
g1 ≡ g2 iff for all name-data-assignments :  |= g1 ⇐⇒  |= g2 g1 ≤ g2 iff for all name-data-assignments :  |= g1 =⇒  |= g2
Definition 3.1 [Constraint automata] A constraint automaton (over the data do- main Data) is a tuple A = (Q, N , −→, Q0) where
Q is a finite set of states,
N is a finite set of names,
−→ is a finite subset of Q × 2N × DC × Q, called the transition relation of A,
Q0 ⊆ Q is the set of initial states.

We write q N,g
p instead of (q, N, g, p) ∈−→. We call N the name set and g the

guard of the transition. For every transition
q N,g

we require that (1) N /= and (2) g ∈ DC(N, Data). 
The intuitive operational behavior of a constraint automaton is as follows. It starts in its initial state q0. If the current state is q, then A waits until data items occur at some of the input/output ports Ai ∈ N . Suppose data item d1 occurs at A1 and data item d2 at A2 while (at this moment) no data is observed at the other ports A3,..., An. This triggers the automaton to check the data constraints of the outgoing
{A1, A2}-transitions of state q to choose a transition
q {A1,A2},g



Fig. 4. Deterministic constraint automata for some basic connectors






where  data(A1)= d1, data(A2)= d2  |= g and move to state p.  If there is no
{A1, A2}-transition from q whose data constraint is fulfilled then A rejects.
Having this behavior in mind, the intuitive meaning of conditions (1) and (2) in
Definition 3.1 is as follows. Condition (1) stands for the requirement that automata- transitions can fire only if some data occur at A1,..., An while condition (2) formal- izes the notion that the behavior of an automaton may depend only on its observed data (and not on data that will occur sometime in the future).
Figure 4 shows the constraint automata for some of the basic Reo connectors. The merger automaton in this figure models the merge behavior inherent in sink and mixed nodes in Reo.
Definition 3.1 allows for nondeterministic constraint automata since for a fixed state
q, a nonempty subset N of N , and a given name-data-assignment , there may be

several transitions 3
q N,g1



N,g2

−→ q1, q −→ q2, ... with  |= gi, i = 1, 2,....
A constraint automaton A is called deterministic iff (1) it has a unique initial state and (2) for every state q, every N, and every name-data-assignment  there is at most one transition
q N,g	j
such that  |= g. In fact, all automata in Figure 3.1 are deterministic.

From automata to streams
In this section we show how to define a language of the so-called timed runs for a constraint automaton. Rather than being fully general (which is not more difficult but would require a bit more text), we look at a simple yet representative example.
We consider a constraint automaton A = (Q, N , →, Q0) that models the behavior of a Reo channel through which data elements flow from input port A to output port
B. Thus, we set N = {A, B} and we associate with A and B timed data streams
⟨, a⟩ and ⟨, b⟩ in TDS. We define the language accepted by A as follows:

LTDS(A) =	[
q0∈Q0
LTDS(A, q0)

where LTDS(A, q) denotes the language accepted by the state q of automaton A
which we define by:

LTDS(A, q)  (⟨, a⟩,⟨, b⟩) ∈ TDS × TDS |
(⟨, a⟩,⟨, b⟩) is a timed run for (A, q) }
Here (⟨, a⟩,⟨, b⟩) is a timed run for (A, q) iff there exists a transition q N,g q¯such

that

a0 < b0 Λ N = {A}Λ [data(A)= 0] |= g Λ (⟨j, aj⟩, ⟨, b⟩) ∈ LTDS(A, q¯),

or	b0 < a0 Λ N = {B}Λ [data(B)= 0] |= g Λ (⟨, a⟩,⟨j, bj⟩) ∈ LTDS(A, q¯),
or	a0 = b0 Λ N = {A, B}Λ [data(A)= 0, data(B)= 0] |= gΛ
(⟨j, aj⟩, ⟨j, bj⟩) ∈ LTDS(A, q¯)

3 Observe that if Nj is a proper subset of N and data occur exactly at the input/output ports Ai ∈ N
then only N-transitions (but no Nj-transitions) can fire.

Note that although this definition of LTDS(A, q) is circular (i.e., q¯ may be equal to q) it can be formally defined by means of the greatest fixed point of a suitably chosen monotone operator. The data streams  and  in a timed run (⟨, a⟩,⟨, b⟩) contain the data elements that are being input and output by the channel ends A and
B. The time streams a and b contain for each of them the times at which these input and output actions take place. The relevance of this timing information is restricted to the particular connector, in this case the channel, at hand: what matters is only the relative order of the initial values a0 and b0, which determines which channel ends will be active next. A pair of timed data streams is a timed run for a state
q ∈ Q of the automaton A if at any moment both the set of names of active channel ends and the values of the incoming and outgoing data items ‘match’ the name sets
and constraints of the subsequent transitions of q.
There is more to be said about the relation between the automata model of Reo and the model based on timed data streams than we have space for here. For in- stance, one can prove that the language accepted by the constraint automaton for a 1-bounded FIFO channel equals the set
 (⟨, a⟩,⟨, b⟩) ∈ TDS × TDS |  =  Λ a < b < aj}
In the present paper, we concentrate on the automata model only, and defer such observations to another occasion.
For the operators on constraint automata, the names used in the automata play an important role. For this reason, we consider LTDS(A) as a set of functions N → TDS (or as a subset of TDSN ) rather than just an n-ary relation of TDS. Notation 1 For a constraint automaton A as before, q a state in A, N ⊆ N and
P ⊆ Q, we define
dcA (q, N, P) = _  g : q N,g  p for some p ∈ P }.
If A is understood from the context, we simply write dc(q, N, P). Intuitively, dc(q, N, P) is the weakest DC that ensures there is an N-transition from state q to P. Note that dc(q, N, P)= false if there is no N-transition from q to a P-state. We use dc(q, N) as an abbreviation for dc(q, N, Q). 
Remark 3.2 [Deriving deterministic constraint automata] As for standard finite automata, deterministic constraint automata are as powerful as their nondetermin-
istic variants, if we are interested only in their accepted stream-languages. 4 More precisely, given a nondeterministic constraint automaton A = (Q, N , −→, Q0), one

4 Nevertheless, as for ordinary finite automata, using nondeterministic automata has the advantage that they may be exponentially smaller than their deterministic equivalents.

can use the standard powerset construction to obtain a deterministic constraint au- tomaton
det(A) =  2Q \ { }, N , −→det, Q0 
where the transition relation −→det is defined as follows.5 For P, Pj ⊆ 2Q with
P /= and Pj /= and N ⊆ N :

N,g
−→det
Pj  iff g = _ dc(p, N, Pj)
p∈P

It can be shown that LTDS(A)= LTDS(det(A)). 

Product and hiding
The composition of TDS relations is defined to be similar to the join operator in relational data bases. For instance, given two binary TDS relations R1(A, B) and R2(B,C) 6 the binary relation (R1 da R2)(A, B,C) is given by
R1 da R2 =  (⟨, a⟩,⟨, b⟩,⟨, c⟩) : (⟨, a⟩,⟨, b⟩) ∈ R1 and (⟨, b⟩,⟨, c⟩) ∈ R2 }.
Definition 4.1 [Product-automaton (join)] The product-automaton of the two con- straint automata A1 = (Q1, N1, −→1, Q0,1) and A2 = (Q2, N2, −→2, Q0,2), is:
A1 da A2 = (Q1 × Q2, N1 ∪ N2, −→, Q0,1 × Q0,2)
where −→ is defined by the following rules:

q N1,g1
N2,g2




and
1 −→1 p1, q2 −→2 p2, N1 ∩ N2 = N2 ∩ N1
⟨q1, q2⟩ N1∪N2,g1Λg2 ⟨p1, p2⟩

q1 N,g
p , N ∩ N
= 

−→1
1	2
N,g

⟨q1, q2⟩ −→ ⟨p1, q2⟩
and latter’s symmetric rule. 

5 Of course, we can use the same ideas as for standard finite automata and apply an on-the-fly construction of the reachable part of det(A). This may lead to a smaller state space, but cannot avoid the exponential blowup in the worst-case.
6 We assume that an n-ary TDS relation is a function {A1,... , An}→ TDS rather than just a subset of TDSn. The notation R1(A, B) suggests that R1 is a binary relation that uses name A for its first
argument and B for its second.

Hiding of a name C in a TDS-relation R(A1,...,C,..., An) means existential quan- tification over theC-component. Formally, e.g. for a ternary relation R = R(A, B,C):
∃C[R(A, B,C)] =  (, a⟩,⟨, b⟩) : ∃ TDS ⟨, c⟩ with (, a⟩,⟨, b⟩,⟨, c⟩) ∈ R}
In constraint automata, the hiding operator removes all information about C.
Definition 4.2 [Hiding on constraint automata] Let A = (Q, N , −→, Q0) be a constraint automaton and C ∈ N . The constraint automaton
∃C[A] =  Q, N \ {C}, −→C, Q0,C 
is defined as follows. Let ~∗ be the (transition) relation such that q ~∗ p iff there exists a finite path


q {C},g1
{C},g2
{C},g3	{C},gn

−→ q1
−→ q2
−→ ... −→ qn

where qn = p and g1,..., gn are satisfiable (i.e., gi / ≡false). (Note that the gi’s de-
pen}d only on C.) The set Q0,C of initial states is Q0 ∪ p ∈ Q : q0 ~∗ p for some q0 ∈
Q0 . The transition relation −→C is given by:
q ~∗ p,	p N,g r, Nj = N \ {C} /= , gj = ∃C[g]


where ∃C[g] =	W
d∈Data
j j
−→C r
g[data(C)/d]. 7 

For instance, if Amerger denotes the merger automaton in Figure 4, then ∃C Amerger 
is the same as the automaton for the asynchronous drain.
Note that the product of two deterministic constraint automata is always a deter- ministic automaton, while hiding can turn a deterministic constraint automaton
into a nondeterministic one. However, when modeling Reo networks with con- straint automata, one can derive from ∃C[A] an equivalent deterministic automaton det(∃C[A]); see Remark 3.2.
Example 4.3 [Composition of two FIFO1 channels] Figure 5 shows how a FIFO2 channel can be obtained from two FIFO1 channels AFIFO1(A,C) and AFIFO1(C, B) via product and hiding:
AFIFO2(A, B) = ∃C AFIFO1(A,C) da AFIFO1(C, B) 

7 g[data(C)/d] denotes the DC obtained by syntactically replacing all occurrences of data(C) in g with d. More precisely, we replace the atoms data(C)= dj with true if d = dj and with false if d /d=j.

For simplicity, we deal with a singleton data domain Data = {d} which allows us to skip the DCs of the transitions. Note that the state ⟨q1, p2⟩ is not reachable in AFIFO2(A, B). The reason is that ⟨q1, p2⟩ is entered through C when the data element moves from the buffer of the first channel to that of the second. As we
abstract away from the activities of C, state ⟨q1, p2⟩ can be skipped in AFIFO2(A, B)
(or alternatively, it can be identified with the state ⟨p1, q2⟩). 


Fig. 5. Composition of two FIFO1 channels

Lemma 4.4 [Correctness of join] Let A1 and A2 be two constraint automata as above. Then:
LTDS(A1 da A2) = LTDS(A1) da LTDS(A2).
If N1 = N2 then LTDS(A1 × A2) = LTDS(A1) ∩ LTDS(A2). 
The equality LTDS(∃C[A]) = ∃C[LTDS(A)] does not hold in general. For instance, hiding B in the merger automaton in Figure 4 yields a constraint automaton with a single state q, one {A,C}-transition, and one {C}-transition. Hence, any TDS-pair (⟨, a⟩,⟨, c⟩) with  =  and a = c belongs to the accepted language of ∃B[Amerger].
On the other hand, none of the pairs (⟨, a⟩,⟨, c⟩) with a = c is contained in the

language ∃B[LTDS(Amerger)] because in every timed run of Amerger data occur in- finitely often on B and C but not on A. To remedy the situation we need to add
fairness conditions that declare which automata-transitions must be taken infinitely often (similar to Büchi automata, see e.g. [8]). To keep this extended abstract short, we skip this detail in the sequel.
Example 4.5 [Exclusive router] Figure 3.a shows the Reo network for an exclu- sive router connector. A data item arriving at the input port F flows through to only one of the output ports B or E, depending on which one is ready to consume it. If both output ports are prepared to consume a data item, then one is selected nonde- terministically. The input data is never replicated to more than one of the output ports. 8
Figure 3.a shows that the exclusive router is obtained by composing two LossySync channels (XM, XN), a SyncDrain (XZ) channel, a merger (inherent in the mixed node of Z), and five Sync channels (FX, MW, NU, ME, NB):


AXRouter(F, E, B) = ∃M, N,U,W, X , Z ALossySync(X , M) × ALossySync(X , N)×
ASyncDrain(X , Z) × Amerger(U,W, Z) × ASync(F, X )×
ASync(N,U ) × ASync(M,W ) × ASync(M, E) × ASync(N, B) 
Figure 6 shows how the constraint automaton for our exclusive router is obtained as the product of the constraint automata of its constituent channels followed by hiding of its internal transitions. 

Example 4.6 [Shift-lossy FIFO1 channel] Figure 3.b shows a Reo network for a connector that behaves as a lossy FIFO1 channel with a shift loss-policy. This channel is called shift-lossy FIFO1 (ShiftFIFO1). It behaves as a normal FIFO1 channel, except that if its buffer is full then the arrival of a new data item deletes the existing data item in its buffer, making room for the new arrival. As such, this channel implements a “shift loss-policy” losing the oldest contents in its buffer in favor of the latest arrivals. This is in contrast to the behavior of an overflow-lossy FIFO1 channel, whose “overflow loss-policy” loses the new arrivals when its buffer is full.
The connector in Figure 3.b is composed of an exclusive router, XRouter(F,E,B) (shown in Figure 3.a and explained in Example 4.5), a merger (inherent in the

8 The behavior of this connector is the counterpart of the primitive nondeterministic selection in- herent in the merge that a Reo (sink or mixed) node performs on its multiple input, modeled by the merger in Figure 4.



Fig. 6. Exclusive router obtained through composition of basic Reo channels

mixed node of C), a SyncDrain (AC), an initially full FIFO1 channel (BD), and an initially empty FIFO2 channel (AF):

AShiftFIFO1(A, B) = ∃C, D, E, F AXRouter(F, E, B) × Amerger(E, D,C)×
ASyncDrain(A,C) × AFIFO1(B, D) × AFIFO2(A, F) 
Figure 7 shows how the constraint automaton for our ShiftFIFO1 channel is ob- tained from the constraint automata of its constituents through product and hiding.
 
Our product operator relies on the standard construction for building finite automata for intersection and has similarities with composition operators for similar models, e.g., the one-to-many composition of port automata [3]. On the other hand, the hiding operator for timed port automata is totally different from our construction. The former does not change the structure of the automata but makes certain output



Fig. 7. Shift-lossy FIFO1 channel obtained through composition of other Reo channels

ports invisible. In contrast, our construction removes all information about the hidden names (similar to the deletion of -transitions in ordinary nondeterministic finite automata).

Bisimulation and simulation
As for standard labeled transition systems, branching time relations like bisimula- tion and simulation can be defined for constraint automata. In the context of Reo, we are interested only in the languages induced by Reo networks (or constraint automata) rather than their branching behavior. Nevertheless, branching time rela- tions are important because they yield an alternative characterization of language equivalence/inclusion, and a simple way to verify if two automata are language equivalent, or if the language of one is contained in the language of the other.

Definition 5.1 [Bisimulation] Let A = (Q, N , −→, Q0) be a constraint automaton and R an equivalence relation on Q. R is called a bisimulation for A if for all pairs (q1, q2) ∈ R , all R -equivalence classes C ∈ Q/R , and every N ⊆ N :
dc(q1, N,C) ≡ dc(q2, N,C).
States q1 and q2 are called bisimulation equivalent (denoted q1 ∼ q2) iff there exists a bisimulation R with (q1, q2) ∈ R . 
As usual, two constraint automata A1 and A2 with the same set of names are called bisimulation equivalent (denoted A1 ∼ A2) iff for every initial state q0,1 of A1 there is an initial state q0,2 of A2 such that q0,1 and q0,2 are bisimulation equivalent, and vice versa. Here, A1 and A2 must be combined into a “large” automaton obtained through the disjoint union of (the state spaces of) A1 and A2.


Fig. 8. Similarity and bisimilarity

Example 5.2 In the constraint automata of Figure 8, states q1 and q2 are bisimilar
while q1, q2 /∼q3. To see why q1 and q2 are bisimilar it suffices to establish a bisimulation which contains (q1, q2). In fact, the equivalence R induced by the
partition
Q/R  =  {q1, q2},{q3},{p1, p2, pj },{r1, r2},{u3}}
can be shown to be a bisimulation. Note that, for instance,
dc(q1,{A},{p1, p2, pj }) = true ≡ dc(q2,{A},{p1, p2, pj }).
2	2
On the other hand, q1 and q2 are not bisimilar to q3. The reason is that there is no state reachable from q1 or q2 which is bisimilar to u3 because dc(u3,{B})= dc(u3,{C})= true, while dc(r1,{B})= dc(r2,{B}) = false and dc(p1,{C})= 
dc(p2,{C})= false. 
In the example of Figure 8, states q1, q2, and q3 are language equivalent (i.e., we have LTDS(A, q1)= LTDS(A, q2)LTDS(A, q3)) but bisimulation distinguishes them as non-equivalent. For nondeterministic constraint automata bisimulation is strictly finer than language equivalence. However, for deterministic constraint automata, bisimulation and language equivalence coincide.

Theorem 5.3 [Bisimulation versus language equivalence] Let A1 and A2 be two constraint automata with the same name set N .
If A1 ∼ A2 then LTDS(A1)= LTDS(A2).
If A1 and A2 are deterministic then A1 ∼ A2 iff LTDS(A1)= LTDS(A2).
Proof. (a) is an easy verification. The proof for (b) can be established by showing that given a deterministic constraint automaton A = (Q, N , −→, Q0), the relation R =  (q1, q2) ∈ Q × Q : LTDS(A, q1)= LTDS(A, q2)}
is a bisimulation.	 
We now provide an alternative characterization of language inclusion by means of the simulation preorder which can be viewed as a uni-directional version of bisimulation:
Definition 5.4 [Simulation] Let A = (Q, N , −→, Q0) be a constraint automaton and R a binary relation on Q. R is called a simulation for A if for all pairs (q1, q2) ∈ R , all R -upward closed sets P ⊆ Q, and every N ⊆ N :
dc(q1, N, P) ≤ dc(q2, N, P).
P is called R -upward closed iff for all states p ∈ P and (p, pj) ∈ R we have pj ∈ P. A state q1 is simulated by another state q2 (and q2 simulates q1), denoted as q1 ≤ q2, iff there exists a simulation R with (q1, q2) ∈ R . A constraint automaton A2 simulates another constraint automaton A1 (denoted as A1 ≤ A2) iff every initial state of A1 is simulated by an initial state of A2. 9 
As the logical or (∨) is idempotent, we have that R is a simulation iff dc(q1, N, p) ≤ dc(q2, N, p ↑R ) for all pairs (q1, q2) ∈ R , states p ∈ Q, and N ⊆ N . Here, p ↑R denotes the R -upward closure of {p}, i.e., the set {pj ∈ Q : (p, pj) ∈ R }.
Example 5.5 State q3 in Figure 8 simulates states q1 and q2 in the same figure. Other examples include, in Figure 4:
the automaton for the synchronous drain which simulates the automaton for the synchronous channel,
the automaton for the asynchronous drain which simulates the automaton for the FIFO1 channel, and
the automaton for the synchronous channel which is simulated by the automaton for the lossy synchronous channel. 
Analogous to Theorem 5.3, we obtain:

9 Here, we assume that A1 and A2 rely on the same set of names.

Theorem 5.6 [Simulation versus language inclusion] Let A1 and A2 be two con- straint automata with the same name set N .
If A1 ≤ A2 then LTDS(A1) ⊆ LTDS(A2).
If A1 and A2 are deterministic then A1 ≤ A2 iff LTDS(A1) ⊆ LTDS(A2). 
As for ordinary labeled transition systems, bisimulation equivalence is finer than simulation equivalence ≤∩ ≤—1.
Lemma 5.7 [Bisimulation versus simulation] For all constraint automata A1 and
A2:
If A1 ~ A2 then A1 ≤ A2 (and A2 ≤ A1).
If A1 and A2 are deterministic and A1 ≤ A2, A2 ≤ A1 then A1 ~ A2.
Proof. (a) follows from the fact that any bisimulation is a simulation. (b) follows by observing that for deterministic automata, simulation equivalence is a bisimula- tion.	 
Lemma 5.8 [Compositionality of join and hiding]
If A1 ≤ Aj and A2 ≤ Aj then A1 da A2 ≤ Aj da Aj .
1	2	1	2
If A1 ~ Aj and A2 ~ Aj then A1 da A2 ~ Aj da Aj .
1	2	1	2
If A1 ≤ A2 then EC[A1] ≤ EC[A2].
If A1 ~ A2 then EC[A1] ~ EC[A2].
Proof. To prove (a) and (b), consider the relations
Rsim = (⟨q1, q2⟩,⟨qj , qj ⟩) : q1 ≤ qj , q2 ≤ qj },
1	2	1	2
Rbis = (⟨q1, q2⟩,⟨qj , qj ⟩) : q1 ~ qj , q2 ~ qj }.
1	2	1	2
Then, Rsim is a simulation and Rbis a bisimulation on the product-automata.
We provide the proof for (c) and observe that the proof for (d) is similar. To prove
it suffices to show that given a constraint automaton A = (Q, N , —→, q0), any simulation R for A is a simulation for EC[A]. By considering the {C}-transitions in A, we obtain:
(*) (q1, q2) ∈ R Λ q1 ~∗ qj  =⇒ q2 ~∗ qj for some state qj with (qj , qj ) ∈ R .
1	2	2	1	2
Let (q1, q2) ∈ R , N a nonempty subset of N \ {C}, and P an R -upward closed subset of Q. Then, for all states q ∈ Q:

dcEC[A](q, N, P) =  _
qj∈q∗
 dcA (qj, N, P) V dcA (qj, N ∪ {C}, P) 

where q∗ =  qj ∈ Q : q ~∗ qj}. From (*), we obtain that for every state qj
∈ q∗

there exists a state qj ∈ q∗ with (qj , qj ) ∈ R . Because
2	2	1	2

dcA (qj , N, P)	≤ dcA (qj , N, P),
1	2
dcA (qj , N ∪ {C}, P) ≤ dcA (qj , N ∪ {C}, P),
1	2

we get dcEC[A](q1, N, P) ≤ dcEC[A](q2, N, P).	 


Concluding remarks

Connector construction in Reo is conceptually analogous to the design of asyn- chronous electronic circuits. Among other things, this analogy emphasizes the im- portance of visual environments for design, analysis, verification, and optimization of Reo connectors, as counterparts of tools and facilities available in modern elec- tronic CAD systems. In this context, issues such as whether two Reo connectors have the same observable behavior, or whether one’s behavior is only a refinement of that of the other arise naturally and frequently. Constraint automata enable us to formally phrase such issues in terms of language equivalence or language contain-
ment and check, e.g., whether LTDS(A1)= LTDS(A2) or LTDS(A1) ⊆ LTDS(A2). Known methods for analysis and model checking with ordinary finite state au-
tomata and labeled transition systems can be adapted to work with our constraint automata.
Given deterministic constraint automata A1 and A2, the simplest way to check lan- guage equivalence is to build the bisimulation quotient of the constraint automaton A = A1  A2, which we obtain by taking the disjoint union of the state spaces of A1 and A2, and check whether the initial states of A1 and A2 belong to the same equivalence class. To compute the bisimulation equivalence classes of A, we may apply the prominent partitioning-splitter technique [5,7]. Similarly, to check language inclusion for two deterministic constraint automata A1 and A2, we may check whether A2 simulates A1 by a technique based on the same idea as for labeled transition systems (e.g. [4]).
Nondeterministic constraint automata offer a useful semantic model for Reo con- nector networks which, e.g., avoids the exponential blowup that may result from applying the powerset construction to an automaton EC[A]. The algorithms to com-
pute the bisimulation quotient or simulation preorder can be applied here as a sound
(but incomplete) verification method to show language equivalence or inclusion. Our future work includes the development of temporal logics and model checking algorithms based on constraint automata.

References
Arbab, F., Reo: A channel-based coordination model for component composition, Mathematical Structures in Computer Science (2003).
Arbab, F. and J. J. M. M. Rutten, A coinductive calculus of component connectors, Technical Report SEN- R0216, Centrum voor Wiskunde en Informatica, Kruislaan 413, 1098 SJ Amsterdam, The Netherlands (2002), to appear in the proceedings of WADT’02.
Grosu, R. and B. Rumpe, Concurrent timed port automata, Technical Report TUM-I9533, Techn. Universität München (1995).
Henzinger, M., T. Henzinger and P. Kopke, Computing simulations on finite and infinite graphs, in: Proc. FOCS’95, 1995, pp. 453–462.
Kannelakis, P. and S. Smolka, CCS expressions, finite state processes and three problems of equivalence, in: Proc. 2nd ACM Symposium on the Principles of Distributed Computing, 1983, pp. 228–240.
Lynch, N. and M. Tuttle, An introduction to input/output automata, CWI Quarterly 2 (1989), pp. 219–246.
Paige, R. and R. Tarjan, Three partition refinement algorithms, SIAM Journal of Computing 16 (1987),
pp. 973–989.
Thomas, W., Automata on infinite objects, in: J. van Leeuwen, editor, Handbook of Theoretical Computer Science, Vol. B, Elsevier Science Publishers, Amsterdam, 1990 pp. 135–191.
