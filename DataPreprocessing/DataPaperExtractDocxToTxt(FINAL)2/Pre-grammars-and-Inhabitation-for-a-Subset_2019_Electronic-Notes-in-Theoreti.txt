Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 344 (2019) 25–45
www.elsevier.com/locate/entcs
Pre-grammars and Inhabitation
for a Subset of Rank 2 Intersection Types
Sandra Alves1,3 Sabine Broda2,4
CMUP & DCC/FCUP
University of Porto, Portugal

Abstract
In this paper, we identify a subset of types in the rank 2 intersection type system, where types do not contain positive occurrences of intersections. We extend the notion of pre-grammar of a type and address the type-inhabitation problem for types in this subset, as well as their intersections.
Keywords: Intersection types, Pre-grammars, Inhabitation


Introduction
The inhabitation of types in the lambda calculus has been extensively studied over the years and is of manifest importance to different fields, which range from more foundational aspects to applications in program language theory, where types figure as a main tool for specifying the behaviour of programs. In proof theory algorithms for deciding type-inhabitation can be used for indirectly decide provability. For sim- ple types the problem has been addressed, throughout the years, using a variety of techniques [4,8,21,20,19,6]. Systems with intersection types [9], extend simple types with an intersection operator ∩, which increases their expressive power substan- tially. Intersection types have been used in abstract interpretation, model check-

1 Partially funded by Project ”TEC4Growth - Pervasive Intelligence, Enhancers and Proofs of Concept with Industrial Impact/NORTE-01-0145-FEDER-000020” is financed by the North Portugal Regional Op- erational Programme (NORTE 2020A), under the PORTUGAL 2020 Partnership Agreement, and through the European Regional Development Fund (ERDF).
2 Partially funded by CMUP (UID/MAT/00144/2013), which is funded by FCT (Portugal) with national (MEC) and european structural funds through the programs FEDER, under the partnership agreement PT2020. Partially funded by FCT within project Elven POCI-01-0145-FEDER-016844, Project 9471 - Re- forar a Investigao, o Desenvolvimento Tecnolgico e a Inovao (Project 9471-RIDTI), by project PTDC/EEI- CTP/3506/2014, and by Fundo Comunitrio Europeu FEDER.
3 Email: sandra@dcc.fc.up.pt
4 Email: sbb@dcc.fc.up.pt

https://doi.org/10.1016/j.entcs.2019.07.003 1571-0661/© 2019 Published by Elsevier B.V.
This is an open access article under the CC BY-NC-ND license (http://creativecommons.org/licenses/by-nc-nd/4.0/).

ing, process calculi, dependent types, to mention a few. Furthermore intersection types are an increasingly important feature in modern programming languages, such as TypeScript, Flow and Scala. For an overview on intersection types and some of their applications we refer to [25,10,5,14,1]. Type inhabitation for finite rank intersection types was proved undecidable for ranks over 2 [22,23], and decid- able for rank 2 [17], although exponentially hard. In recent years, the problem of type-inhabitation has been further explored for bounded ranks of non-idempotent intersection types [7,12,11].
More recently [3], type inhabitation problems for simple types were addressed us- ing an alternative representation for types, called the pre-grammar of the type. Pre- grammars capture the underlying structure of types, providing a common frame- work for addressing a number of type-inhabitation related problems such as type- checking, counting and generation of inhabitants. Furthermore, a scheme for a decision algorithm was given, which was instantiated to decide emptiness, counting and principal inhabitation. Closure properties were studied and the notion of pre- grammar and its corresponding methods were extended to sums of intersections of simple types. In this paper, we further explore this formalism for types with in- tersections, by extending the notion of pre-grammar and addressing the emptiness problem for a subset of rank 2 intersection types, that we denote by T −. Types in T − do not contain positive occurrences of intersections, which intuitively means that the result type of a term used at a function position will not be an inter- section. We point out that this is not such a strong restriction on rank 2 types. Actually, systems addressing type assignment for rank 2 [26,15,16] consider even stronger restrictions of the rank 2 system, when compared to the original notion by Leivant [18]. In fact, the same type of restriction is imposed on the strict type as- signment system [24], and the essential type assignment system [25], both of which eliminate superfluous steps, leading to derivations that are syntax directed yet still semantically complete. Note that, when restricted to rank 2, the strict type system is a proper subset of T −, since it forbids the occurrences of intersections to the right of any arrow, and any positive intersection to the left of an arrow is only possible at a rank greater or equal than 3. For example, (a ∩ (a → (a ∩ a)) → a is a type in T − (both occurrences of intersections are negative), but is not a strict rank 2 type (the inner occurrence of an intersection is to the right of an arrow).
From the notion of pre-grammar, the methods in [3] are extended smoothly for T −-types. In fact, when applied to types containing no intersection, the extended definition of pre-grammar will coincide with the one for simple types given in [3]. This nice property suggests that we can address other problems related to type in- habitation, for more expressive types, using the formalism of pre-grammars. We will restrict our methods and definitions to terms in normal form, since each inhabited type in the rank 2 type system, and therefore in any of its restrictions, has a normal inhabitant (intersection types characterize exactly the set of strongly normalising λ-terms). Furthermore, we consider types modulo commutativity, idempotence and associativity, always identifying maximal subtypes containing intersections, that is, in any subtype of the form τ1 ∩· · · ∩ τn, none of the τi is itself an intersection.

The rest of the paper is structured as follows. In the next section we introduce some preliminary notions. In Section 3, we present the set of T −-types and prove some properties. In Section 4, we present the notion of pre-grammar for T −-types. Using the pre-grammar representation, in Section 5 we define a decision procedure for T −-types and in Section 6, we show how to extend the decision procedure to intersections of T −-types. Finally, in Section 7, we draw some conclusions and highlight some future work.

Preliminaries
We assume familiarity with the simply typed λ-calculus `a la Curry [13]. We denote type variables (atoms) by a, b, c,... and arbitrary types (simple or of higher rank) by lower-case Greek letters.
Definition 2.1 The set of intersection types T∩ is inductively defined as follows.
Every type variable is a(n) (intersection) type;
if α and β are types, then α → β is a type;
if α1,..., αn are types and n ≥ 2, then α1 ∩ ··· ∩ αn is a type.
Note that the set of simple types, which we denote by T , is exactly the set of types in T∩, that contain no occurrence of the intersection operator. We assume that ∩ is associative, commutative, idempotent, and that it binds stronger than →. As usual, the operator → associates to the right. For instance, we write α∩β ∩δ → γ → δ instead of ((α ∩ β) ∩ γ) → (γ → δ). In a finite rank intersection type system, intersections on types are allowed only up to a certain depth. The notion of rank was defined for intersection types in [18].
Definition 2.2 The rank of a type in T∩ is defined by the following rules.
rank(α)= 0, if α ∈T ;
rank(α → β)= max(1 + rank(α), rank(β)), when rank(α) > 0 or rank(β) > 0;
rank(α1 ∩ ··· ∩ αn)= max(1, rank(α1),..., rank(αn)) for n ≥ 2. Given r ∈ N, we denote by Tr the set of intersection types of rank ≤ r.
We denote λ-terms by M, N, .. ., which are built from an infinite countable set of term variables V. Unless stated otherwise, we identify terms modulo α-equivalence. For type assignment we consider a system equivalent to the one presented in [17]. A context is a finite set Γ of declarations x : σ, where x ∈ V and σ ∈ T∩, such that all term variables occurring in Γ are distinct from each other. The set of term variables occurring in Γ is denoted by Subj(Γ). The union of contexts is consistent, if it does not contain different type declarations for the same term variable.
Definition 2.3 We say that type θ ∈ T∩ can be assigned to term M in context Γ, and write Γ ▶ M : θ, if and only if this formula can be obtained by applying the

rules below a finite number of times.
Γ ▶ M : σ → τ  Γ ▶ N : σ
var (if x : τ ∈ Γ)	E→


Γ ∪ {x : σ} ▶ N : τ
I→

Γ ▶ x : τ
Γ ▶ MN : τ
Γ ▶ λx.N : σ → τ

Γ ▶ M : τ1 ∩ ··· ∩ τn
E∩
Γ ▶ M : τi (1 ≤ i ≤ n)
Γ ▶ M : τi (1 ≤ i ≤ n, n > 1)
I∩
Γ ▶ M : τ1 ∩ ··· ∩ τn

If Γ = ∅, then we also write ▶ M : θ instead of Γ ▶ M : θ and say that M is an inhabitant of type θ. The set of all β-normal inhabitants of θ is denoted by Nhabs(θ).
It is easy to verify that Γ ▶ M : θ implies that the set of term variables in Γ contains the set of free variables in M , i.e. Subj(Γ) ⊇ FV(M ). A derivation of a formula Γ ▶ M : θ can be represented as a derivation tree Π, in which all nodes are labelled by formulas, such that Γ ▶ M : θ is the root of Π, every internal node is obtained from its children by one of the rules (E→), (I→), (E∩) or (I∩). Every leaf is labelled with an instance of (var).
Example 2.4 Consider type
τ = (((o → o) → o) ∩ (o → ((o → ((o → o) ∩ o)) ∩ o))) → o,
let τ17 = ((o → o) → o) ∩ (o → τ15) and τ15 = (o → ((o → o) ∩ o)) ∩ o. Note that
τ ∈ T2, while τ15, τ17 ∈ T1. The following is a derivation tree of ▶ λx.x(λy.xyy): τ .



x : τ17 ,y : o ▶ x : τ17
var
E∩


var

x : τ17 ,y : o ▶ x : o → τ15
x : τ17 ,y : o ▶ y : o
E→

x : τ17 ,y : o ▶ xy : τ15
E∩
x : τ17 ,y : o ▶ xy : o → ((o → o) ∩ o)

x : τ17 ,y : o ▶ y : o
var
E→


x : τ17 ▶ x : τ17
var
E∩
x : τ17 ,y : o ▶ xyy : (o → o) ∩ o
E∩
x : τ17 ,y : o ▶ xyy : o
I→

x : τ17 ▶ x : (o → o) → o

x : τ17 ▶ x(λy.xyy): o
I→
▶ λx.x(λy.xyy): τ
x : τ17 ▶ λy.xyy : o → o
E→

Definition 2.5 The polarity of occurrences of subtypes in a type is defined as follows.
θ is a positive occurrence of a subtype in θ;
if σ → τ is a positive (resp. negative) occurrence of a subtype in θ, then that occurrence of σ is a negative (resp. positive) and that occurrence of τ is a positive (resp. negative) subtype in θ;
if τ = τ1 ∩· · ·∩ τn is a positive (resp. negative) subtype in θ, where n ≥ 2, then τ1,..., τn are positive (resp. negative) subtypes in θ. We also call τ an intersection in θ of arity n. Subtypes τ1,..., τn are called the components of intersection τ .
Following the notation in [13], we will on occasions write o when referring to a particular occurrence of an object o. Every type τ is either an intersection, or can be uniquely written as τ = τ1 → · · · → τn → θ (n ≥ 0), where θ is a type variable or an intersection θ1 ∩ · · ·∩ θm (m ≥ 2). Subtype θ is called the tail of τ and denoted by tail(τ ). If n ≥ 1, then τ1,..., τn are called the arguments of τ .

An occurrence σ in τ is called a negative subpremise of τ iff it is the argument of a positive occurrence of a subtype in τ .
Example 2.6 Formula θ = a ∩ (b → c ∩ d) ∩ (e ∩ f → g) → h ∩ i contains four subtypes that are intersections. a ∩ (b → c ∩ d) ∩ (e ∩ f → g) is of arity three and is a negative subpremise. c ∩ d is negative, but no subpremise. Both, e ∩ f and h ∩ i are positive occurrences. Note that we do not regard at a ∩ (b → c ∩ d) as an intersection in θ, since we always consider the maximal intersection possible.

T −-Types
From now on, we will focus on inhabitation of rank 2 types that have no positive occurrences of intersections. We denote the set of types with this property by T —. Note that this is no major restriction on the set T2 of rank 2 types. In fact, it follows from Definition 2.2 that each type θ ∈ T2 is either an intersection θ1 ∩· · ·∩ θn with θ1,..., θn ∈ T2 and n ≥ 2, or of the form τ1 → · · · → τm → θj (m ≥ 0), where τi ∈ T1 for 1 ≤ i ≤ m and θj is either an intersection of rank 2 types (recall that we consider intersections to have at least two components) or a type variable. On the other hand, τi ∈ T1 implies that there is no negative occurrence of an intersection in τi, and consequently τi introduces no positive occurrence of an intersection in θ. So the set T — includes all types of this last form, as long as θj is a type variable. Furthermore, in Section 6 we will show how our method can be extended to intersections of types in T —.
In Definition 3.3 we give a set of inference rules for terms in β-normal form,

which for types in T —
is equivalent to the set of rules in Definition 2.3, in the

sense of Proposition 3.4. This suffices for the purpose of type inhabitation, and the system has the property that, for every formula Γ ▶2 N : τ that can be de- rived, one has Subj(Γ) = FV(N ). As stated before, considering only normal terms is sufficient, since every inhabited type has a normal inhabitant. The following, straightforward characterisation of types in T — and in T1 (rank 1) will be used to prove the adequateness of our set of inference rules.
Lemma 3.1 One has θ ∈T — if and only if θ = τ1 → · · · → τn → a, where τi ∈ T1, for 1 ≤ i ≤ n and n ≥ 0, and a is a type variable. In particular, any type in
— is either a type variable or of the form τ → θj, where τ ∈ T1 and θj ∈ T —.
Furthermore, τ ∈ T1 if and only if τ is either (i) a type variable or of the form σ → τj, where σ ∈T (simple type) and τj ∈ T1, or (ii) it is an intersection of types of the form described in (i).
Every β-normal λ-term is of the form λx.N or xN1 ··· Ns, where N, N1,..., Ns are in normal form and s ≥ 0. Similar to the case of the simple type system, the general structure of a derivation tree Π of a formula Γ ▶ M : θ, where M is in β-normal form and θ ∈ T∩, is determined by the structure of M .
Definition 3.2 Consider a derivation tree Π for some formula Γ ▶ M : θ. Let n
be a node in Π with label Γj ▶ N : τ , such that τ is not an intersection. Consider

the maximal subtree Πn of Π, rooted in n such that each node results from another node in Πn by rule (E∩), or results from two other nodes in Πn by rule (I∩).
Since τ is not an intersection, and in Πn only rules (I∩) and (E∩) are used, there must be a leaf nj of Πn labelled with a formula of the form Γj ▶ N : τ1 ∩·· · ∩ τn ∩ τ ,
with n ≥ 0. Consider the 5 tree Πj with (exactly one) leaf nj, labelled with Γj ▶
N : τ1 ∩ · · · ∩ τn ∩ τ , from which Γj ▶ N : τ is derived by (E∩) in case n > 0.

Otherwise, Πj
consists just of nj. This means that Πj
consists always of either of

one or two nodes. We denote by Π[n] the tree obtained from Π by replacing the
complete subtree rooted in node n by Πj , attaching to the (unique) leaf node in Πj
n	n
the subtree, that in Π was rooted in nj.
It is easy to see that, if Π is a derivation tree for some formula Γ ▶ M : θ and n a node with label Γj ▶ N : τ , such that τ is not an intersection, then Π[n] is still a derivation tree for Γ ▶ M : θ.
Definition 3.3 We say that a type θ can be assigned to term M in context Γ, and write Γ ▶2 M : θ, if and only if this formula can be obtained by applying the rules below a finite number of times. For the parameters in these rules we suppose that s ≥ 0, n ≥ 1 and i ∈ {1,..., n}.


{x : τ1 ∩ ··· ∩ τn} ▶2 x : τi
var2
	Γ ▶2 N : τ	
Γ \ {x : σ} ▶2 λx.N : σ → τ
I→2 if Γ ∪ {x : σ} is consistent

 Γ1 ▶2 xN1 ··· Ns : σ → τ1 ∩· · · ∩ τn Γ2 ▶2 Ns+1 : σ Γ1 ∪ Γ2 ▶2 xN1 ··· NsNs+1 : τi
E→2 if Γ1 ∪ Γ2 is consistent

Note 1 Consider a β-normal form M and a derivation tree Π of a formula Γ ▶2 M : θ. It is important to realise that one might have θ /∈T —. Furthermore, even if θ ∈T —, then it is possible that there are formulas Γj ▶2 N : τ in Π with τ /∈T —.
2	2
Proposition 3.4 Consider a β-normal form M and θ ∈ T —. Then, ▶ M : θ  if
and only if ▶2 M : θ.
Proof. We prove the two directions separately.
(⇐) We will prove, by structural induction on M , the following, more general result: if M is in β-nf and Γ ▶2 M : θ, where θ ∈ T∩, thenΓ ▶ M : θ. First note that, in ▶, the following property holds and can easily be proved by induction: if Γ ▶ M : θ, and Γ ∪ {x : τ} is consistent, then Γ ∪ {x : τ}▶ M : θ.
If M = x, then {x : τ1 ∩ · · ·∩ τn} ▶2 x : τi. Therefore, by (var) we have
{x : τ1 ∩· · ·∩ τn}▶ x : τ1 ∩· · ·∩ τn, from which we obtain {x : τ1 ∩· · ·∩ τn}▶ 
x : τi, by (E∩).
If M = λx.N , then Γ\{x : σ} ▶2 λx.N : σ → τ is a consequence of Γ ▶2 N : τ and Γ ∪ {x : σ} being consistent. By the induction hypothesis Γ ▶ N : τ , and by the property above Γ ∪ {x : σ} ▶ N : τ . But Γ ∪ {x : σ} = (Γ \ {x : σ}) ∪ {x : σ}. Thus, Γ \ {x : σ}▶ λx.N : σ → τ follows by (I→).

5 Given some strategy for choosing that leaf, e.g. left-most, this tree is uniquely defined.

If M = xN1 ··· NsNs+1, then Γ1 ∪ Γ2 ▶2 xN1 ··· NsNs+1 : τi is a consequence of Γ1 ▶2 xN1 ··· Ns : σ → τ1 ∩ · · · ∩ τn, Γ2 ▶2 Ns+1 : σ and Γ1 ∪ Γ2 is consistent. By the induction hypothesis Γ1 ▶ xN1 ··· Ns : σ → τ1 ∩ ··· ∩ τn and Γ2 ▶ Ns+1 : σ. Since Γ1 ∪ Γ2 is consistent then, by the property above, Γ1 ∪ Γ2 ▶ xN1 ··· Ns : σ → τ1 ∩ · · · ∩ τn and Γ1 ∪ Γ2 ▶ Ns+1 : σ. By (E→), Γ1 ∪ Γ2 ▶ xN1 ··· NsNs+1 : τ1 ∩· · ·∩ τn, from which follows Γ1 ∪ Γ2 ▶ xN1 ··· NsNs+1 : τi, by (E∩).
(⇒) Consider a derivation tree Π of ▶ M : θ, where θ ∈T —. In the first part of the proof we will construct from Π a derivation tree Πj of ▶ M : θ, for which the following hold.
If a node in Πj is labelled with Γ ▶ N : τ , then x : σ ∈ Γ implies σ ∈ T1.
Every node Γ ▶ λx.N : τ in Πj is such that τ = τ1 → τ2 ∈ T — and results from Γ ∪ {x : τ1}▶ N : τ2 by (I→), where τ1 ∈ T1 and τ2 ∈T —.
Every node Γ ▶ x : τ in Πj, where τ ∈ T — or τ is of rank 1 but is not an intersection, results from Γ ▶ x : τ1 ∩ ··· ∩ τn ∩ τ by rule (var), followed by an application of rule (E∩) in case n > 0.
Every node Γ ▶ xN1 ··· Nk : τ in Πj, where τ ∈T — or τ is of rank 1 but is not an intersection (k ≥ 1), results from two formulas Γ ▶ xN1 ··· Nk—1 : σ → τ1 ∩· · ·∩τn ∩τ and Γ ▶ Nk : σ, where σ ∈T ⊆T — and τ1, ··· , τn ∈ T1 (and consequently σ → τ1 ∩· · ·∩ τn ∩ τ ∈ T1), by rule (E→), followed by an application of rule (E∩) in case n > 0.
Note that, in particular, Πj contains no application of rule (I∩). We construct Πj bottom-up from Π, applying recursively the transformation method, de- scribed below, to nodes labelled with formulas Γ ▶ N : τ , which satisfy the following premises:
all types in Γ are of rank 1;
τ ∈ T —, or N is of the form xN1 ··· Nk and τ is of rank 1 but is not an intersection, for some k ≥ 0.

For the root, (i) is true and also θ ∈ T —
(thus satisfying (ii)). Since M is

closed it has to be of the form λx.N . However, the construction is performed bottom up and we want to consider any node n labelled with a formula of the form Γ ▶ λx.N : τ satisfying the premises. In particular τ ∈ T —. Consider the maximal subtree Πn, rooted in node n, as defined in Definition 3.2, as well as the corresponding tree Πj , whose leaf nj is labelled with a formula Γ ▶ λx.N : τ1 ∩ ··· ∩ τn ∩ τ . Since Πn is maximal this formula must have been derived by rule (I→), and we conclude that n = 0. Thus, Π[n] is obtained from Π by replacement of the entire subtree rooted in n by the subtree rooted in node nj, which has also label Γ ▶ λx.N : τ . Since this formula was derived by rule (I→), τ has to be of the form τ1 → τ2 and Γ ▶ λx.N : τ1 → τ2, was derived from formula Γ∪{x : τ1}▶ N : τ2. It follows from τ ∈T — and from Lemma 3.1 that τ1 ∈ T1 and τ2 ∈T —. Thus, (b) is true, and Γ ∪ {x : τ1}▶ N : τ2 satisfies the premises. We proceed from this node in the new tree.
For (c) consider a node n with label Γ ▶ x : τ , where τ ∈T — or τ is of rank
1 but is not an intersection, and all types in Γ are of rank 1. In Π[n] this node

results from Γ ▶ x : τ1 ∩···∩ τn ∩ τ by rule (var), followed by an application of rule (E∩) in case n > 0.
For the last case consider a node n labelled with Γ ▶ xN1 ··· Nk : τ (k ≥ 1), satisfying the premises, i.e. all types in Γ are of rank 1 and τ ∈ T — or τ is of rank 1 but is not an intersection. Consider again Π[n] obtained from Π and Πj ,

as described in Definition 3.2. The leaf node of Πj
is labelled with a formula of

the form Γ ▶ xN1 ··· Nk : τ1 ∩· · ·∩ τn ∩ τ and has to result by rule (E→) from two nodes, respectively labelled with Γ ▶ xN1 ··· Nk—1 : σ → τ1 ∩· · · ∩ τn ∩ τ and Γ ▶ Nk : σ. Thus, Γ ▶ xN1 ··· Nk : τ is derived from these two formulas by rule (E→), followed by an application of rule (E∩). Since the type declared for x in Γ is of rank 1 and Γ ▶ xN1 ··· Nk—1 : σ → τ1 ∩· · ·∩τn ∩τ (n ≥ 0), then σ ∈T and τ1 ∩···∩ τn ∩ τ ∈ T1, thus σ → τ1 ∩···∩ τn ∩ τ ∈ T1. Consequently,
(d) is true. Also, Γ ▶ xN1 ··· Nk—1 : σ → τ1 ∩ · · ·∩ τn ∩ τ and Γ ▶ Nk : σ satisfy the premises. The construction, continues in the new tree from these two nodes.
Now, the construction of a derivation tree for ▶2 M : θ from Πj is straightfor- ward. We proceed as follows, replacing one after another, one or two derivation steps of a formula Γ ▶ N : τ by a derivation step of formula Γ|FV(N ) ▶ N : τ . Here Γ|FV(N ) denotes the restriction of Γ to the free variables in N . The re- placement is performed top-down, starting at the leafs of Πj.
Any derivation of Γ ▶ x : τ in Πj, resulting from Γ ▶ x : τ1 ∩· · · ∩ τn ∩ τ by
rule (var), followed by an application of rule (E∩) in case n > 0, is replaced by rule {x : τ1 ∩· · ·∩ τn ∩ τ} ▶2 x : τ , where x : τ1 ∩· · ·∩ τn ∩ τ is the type declaration for x in Γ.
Any derivation of Γ ▶ xN1 ··· Nk : τ in Πj, resulting from Γ ▶ xN1 ··· Nk—1 : σ → τ1 ∩· · · ∩ τn ∩ τ and Γ ▶ Nk : σ by rule (E→), followed by an application of rule (E∩) in case n > 0, is replaced by one application of rule (E→2) to

formulas Γ|FV(xN ···N

k−1
) ▶2 xN1 ··· Nk—1 : σ → τ1 ∩· · ·∩ τn ∩ τ and Γ|FV(N ) ▶2

Nk : σ, deriving Γ|FV(xN ···N ) ▶2 xN1 ··· Nk : τ .
1	k
Any derivation of Γ ▶ λx.N : τ1 → τ2 in Πj, resulting from Γ ∪ {x :
τ1} ▶ N : τ2 by (I→), is replaced by one application of (E→2) to (Γ ∪ {x :
τ1})|FV(N ) ▶2 N : τ2, deriving (Γ ∪ {x : τ1})|FV(N ) \ {x : τ1} ▶2 λx.N : τ1 → τ2,
i.e. Γ|FV(λx.N ) ▶2 λx.N : τ1 → τ2.	2
2








Example 3.5 Consider again types τ , τ17 and τ15 and context Γ from Example 2.4 and the normal term M = λx.x(λy.xyy). A deduction for ▶2 M : τ is depicted

below.

 x : τ	▶ x : o → τ	var2	y : o ▶ y : o x : τ17,y : o ▶2 xy : o → ((o → o) ∩ o)

var2
E→2



y : o ▶2 y : o



var2
E→2

x : τ17 ▶2 x : (o → o) → o
var2
 x : τ17 ▶2 x(λy.xyy): o
▶2 λx.x(λy.xyy): τ
  x : τ17, y : o ▶2 xyy : o 
x : τ17 ▶2 λy.xyy : o → o
I→2
I→2 E→2

Note that this deduction tree for ▶2 M : τ was obtained from the deduction tree for ▶ M : τ displayed in Example 2.4, applying the transformation described in the proof of Proposition 3.4. Since in that particular tree there was no application of rule (I∩), in this case the transformation consists essentially of successive substitutions of subtrees of the form
··· 

 Γ ▶2 M : τ1 ∩· · · ∩ τn
rule
E∩
··· 
rule2

Γ ▶2 M : τi	by
where rule ∈ {var, I →, E →}, n ≥ 2 and 1 ≤ i ≤ n.
Γ ▶2 M : τi

The following example shows that one may have more than one derivation for a statement ▶2 M : τ .
Example 3.6 Consider α = (a → b) ∩ (c → b) → a ∩ c → b. There are two derivations for ▶2 λxy.xy : α.

x : (a → b) ∩ (c → b) ▶2 x : a → b
var2
y : a ∩ c ▶2 y : a
var2
E→2

	x : (a → b) ∩ (c → b), y : a ∩ c ▶2 xy : b	
 x : (a → b) ∩ (c → b) ▶2 λy.xy : a ∩ c → b
▶2 λxy.xy : τ
I→2 I→2

The other derivation projects on the second component in intersections.
Consider a term M in β-normal form, a type θ ∈T —, and a ▶2-derivation tree Π of ▶2 M : θ. In the following, we assign occurrences of subtypes of θ, to all variables in Subj(Γ) and to all subterms of N , for every formula Γ ▶2 N : σ appearing in Π. This assignment is crucial to prove correctness of the pre-grammars defined in the next section. Every x ∈ Subj(Γ) is assigned a negative subpremise nsp(x) of θ. Every subterm Nj of N , which is not in function position, i.e. has no arguments, is assigned a positive occurrence pst(Nj) of a subtype of θ. Additionally, every subterm of the form xN1 ··· Ns, with s ≥ 0, is assigned a negative occurrence of a subtype of θ, denoted by nst(xN1 ··· Ns). Note, that subterms of this last form, that have no further arguments, are assigned both a positive, as well as a negative occurrence of a subtype of θ.
Definition 3.7 Consider a term M , a type θ ∈ T —, and a ▶2-derivation tree Π of ▶2 M : θ. The assignment of nsp, nst and pst to occurrences of variables and subtypes in the formulas, that appear in Π, is bottom-up, starting with ▶2 M : θ.

For ▶2 M : θ, let pst(M )= θ (note that M is necessarily of the form λx.N , thus
nst(M ) is not defined).
Now consider Γ \ {x : σ} ▶2 λx.N : σ → τ , because Γ ▶2 N : τ and Γ ∪ {x : σ} is consistent. Consider pst(λx.N )= σ → τ for Γ \ {x : σ} ▶2 λx.N : σ → τ . Then, for Γ ▶2 N : τ let pst(N ) be the occurrence of τ in pst(λx.N ). If x ∈ Subj(Γ), then nsp(x) is the occurrence of σ in σ → τ . All other variables in Subj(Γ) are assigned the same occurrences as for the formula Γ \ {x : σ} ▶2 λx.N : σ → τ .
Finally, consider a formula of the form Γ ▶2 xN1 ··· Nk : τ with k ≥ 0. Note that all elements in Subj(Γ) are already assigned negative subpremises in θ. Also, this occurrence of xN1 ··· Nk is already assigned a positive subtype pst(xN1 ··· Nk)= τ .
If k = 0, then the formula is of the form {x : τ1 ∩· · ·∩ τn} ▶2 x : τi, for n ≥ 1 and i ∈ {1,..., n}. At this point, the occurrence of x in the context is already assigned a negative subpremise nsp(x)= τ1 ∩· · · ∩ τn and the occurrence on the right side of ▶2 is assigned a positive occurrence of a subtype pst(x)= τi. We further assign nst(x) to x on the right side of ▶2, choosing the occurrence of τi in nsp(x), which is a negative subtype in θ.
If k > 0, then there isa subtree Πj of Π that derives formula Γ ▶2 xN1 ··· Nk : τ . In this subtree a declaration of the form {x : τ1 ∩ ··· ∩ τn} ▶2 x : τi is first combined with a derived formula Γ1 ▶2 N1 : σ1 (by some subtree Π1 of Πj). The resulting formula {x : τ1 ∩···∩ τn}∪ Γ1 ▶2 xN1 : τ 1 is then combined with a derived formula Γ2 ▶2 N2 : σ2 (by some subtree Π2 of Πj), etc. In the final formula we have Γ = {x : τ1 ∩ ··· ∩ τn}∪ Γ1 ∪ ··· ∪ Γk. At this point, every occurrence of a variable y in Γ is already assigned a negative subpremise nsp(y). Thus, the same is true for Γ1,..., Γk. We now successively assign, operating top down, negative subtypes to terms x, xN1,..., xN1 ··· Nk, as well as positive subtypes to terms N1,..., Nk, in the formulas in this part of the tree. For x on the right side of {x : τ1 ∩ ··· ∩ τn} ▶2 x : τi let nst(x) be the occurrence of τi in nsp(x) = τ1 ∩· · · ∩ τn. Now, suppose that formula {x : τ1 ∩ · · · ∩ τn}∪ 

Γ ∪ · · · ∪ Γ ▶  xN ··· N
: σ → τj ∩ · · · ∩ τj
is combined with Γ	▶

1	j	2	1	j
1	nj
j+1	2

Nj+1 : σ, deriving {x : τ1 ∩· · ·∩ τn}∪ Γ1 ∪· · ·∪ Γj+1 ▶2 xN1 ··· NjNj+1 : τj ,

where i
j ∈ {1,..., nj}. Consider nst(xN1
··· Nj) =  σ → τj ∩· · · ∩ τj
(which

is already assigned). Then, pst(Nj+1) is the occurrence of σ in nst(xN1 ··· Nj)

and nst(xN1 ··· NjNj+1) is the occurrence of τj
in nst(xN1 ··· Nj).


Pre-grammars for types in T −
In [2,3] it was described how to obtain for a simple type α ∈ T a set of rewriting rules, denoted by pre(α), and called the pre-grammar of α. It was shown how to use pre-grammars to address problems such as type-checking, the emptiness problem and principal inhabitation. Furthermore, closure properties were studied. In particular, it was shown how to obtain, given pre-grammars of two types α and β, a new grammar corresponding exactly to the normal inhabitants of both α and

β, i.e. to the normal inhabitants of α ∩ β.
In order to extend the methods described in [3], in this section we define the notion of pre-grammar for types in T —. The definition of pre-grammars given here will coincide with the one in [3], when applied to types containing no intersections,
i.e. simple types. In Section 6 we will combine pre-grammars, following the method described in [3], to obtain grammars corresponding to intersections of T —-types.
We start by associating to each type τ a set occT(τ ) that contains for every occurrence of a subtype τj a tuple (τj, n, l), where n ∈ N, and l ∈ {var}∪{ n → m | n, m ∈ N }∪{ n1 ∩· · · ∩nm | n1,..., nm ∈ N }. Distinct occurrences of subtypes are assigned distinct tuples. This set is uniquely defined, up to isomorphism between integers used in the tuples.
Definition 4.1 Given a type τ ∈ T2, let occT(τ ) be the smallest set satisfying the following.
For each occurrence of a type variable a in τ there isa tuple (a, n, var) ∈ occT(τ );
if σ1 → τ1 is an occurrence of a subtype of τ , and (σ1, n, lσ1 ), (τ1, m, lτ1 ) ∈ occT(τ ) are the tuples corresponding to σ1 and τ1 in this occurrence, then there is a tuple (σ1 → τ1, k,n → m) ∈ occT(τ );
if α1 ∩ · · · ∩ αm, with m ≥ 2, is an occurrence of a subtype of τ , and (α1, n1, lα1 ),..., (αm, nm, lαm ) ∈ occT(τ ) are the tuples corresponding to α1,..., αm in this occurrence, then (α1 ∩· · · ∩ αm, k, n1 ∩· · · ∩ nm) ∈ occT(τ );
for each n ∈ N there is at most one tuple (σ, n, l) ∈ occT(τ ).
Furthermore, given a particular occurrence τj of a subtype of τ we denote by n(τj) the unique integer n such that (τj, n, l) ∈ occT(τ ). We frequently will refer to n(τj) as the identiﬁer of τj w.r.t. occT(τ ). The type of identifier n is t(n)= τj, its label is lab(n)= l, and N(τ )= { n | (τj, n, l) ∈ occT(τ ) }. Finally, if (α1 ∩ ··· ∩ αm, k, n1 ∩
··· ∩ nm) ∈ occT(τ ) (m ≥ 2), then each of n1,..., nm is called a component of identifier k.
In order to deal correctly with the correspondence between occurrences of sub- types and occurrences of subterms, polarities have to be taken into account. With this purpose, and whenever convenient, we might superscript an integer n with ’+’ if n corresponds to a positive occurrence of a subtype, i.e. an occurrence that can be the type of a subterm of an inhabitant, and with ’−’ if it corresponds to a negative subpremise, i.e. if it corresponds to an occurrence that can be the type of a vari- able in an abstraction sequence. Integers that correspond to a negative occurrence, which is no subpremise, will not be superscripted.
Definition 4.2 We say that two integers n, m ∈ N(τ ) are equivalent w.r.t. occT(τ ), and write n ≡occT m, if and only if t(n)= t(m). The binary relation T (τ ) ⊆ N(τ ) × N(τ ) is defined by (p2, p3) ∈ T (τ ) iff (τ3, p3, p1 → p2) ∈ occT(τ ), i.e. τ3 = τ1 → τ2, n(τ1) = p1, n(τ2) = p2, and n(τ3) = p3. Furthermore, for (p2, p3) ∈ T (τ ) let q(p2, p3)= p1.
Example 4.3 For τ from Example 2.4 the set occT(τ ) contains nineteen tuples

(τj, n, l), where τj, n and l are given below (tuples for occurrences of identical subtypes, i.e. equivalent modulo ≡occT, are displayed in the same line)

where τ1 = (o → o) → o and τ2 = o → (o → (o → o) ∩ o) ∩ o.	The equivalence relation ≡occT partitions N(τ ) into nine equivalence classes, which are
{0—, 1+, 2, 3+, 4+, 5+, 6, 7, 8, 9+},{10+, 11}, {12}, {13}, {14}, {15}, {16},{17—}, and
{18+}. The associated graph T (τ ) is depicted below.

18+	16	14	12	10+	11
17 3 4 10 0 5 

9+	15	13
2	1+	6
0—	3+	4+	5+	7	8	17—


Now, pre(τ ) is constructed from occT(τ ) and T (τ ).
Definition 4.4 Given m, n ∈ N(τ ), we write m ≤∩ n if and only if either m = n and n is not the identifier of an intersection, or n is the identifier of an intersection of arity ≥ 2 and m is a component of n.
Example 4.5 For occT(τ ) from Example 4.3, we have 7, 11 ≤∩ 13, 8, 14 ≤∩ 15,
and 12, 16 ≤∩ 17—.
Definition 4.6 Given a type τ and a set of tuples occT(τ ), we denote by pre(τ ) the smallest set of rules satisfying the following conditions.
If m+, k—, n+ ∈ N(τ ), (β, m, k → n) ∈ occT(τ ), then m := λk.n ∈ pre(τ );

if m+, p—
∈ N(τ ) and (ps, cs—1),..., (p2, c1), (p1, c0) ∈ T (τ ), for some s ≥ 0,

m+ ≡occT cs, cj ≤∩ pj (1 ≤ j ≤ s), q(pi, ci—1) = ni (1 ≤ i ≤ s), then m :=
p0 n1 ··· ns ∈ pre(τ ).
Example 4.7 From occT(τ ) and T (τ ) in Example 4.3 we obtain the following set

pre(τ ) containing twenty eight rewriting rules.
18 := λ17.9
1, 3, 4, 5, 9 := 17345 | 1734 | 17 3 | 17 10 | 0
10 := λ0.1 | 1734 
For instance, we have 9 := 17 10 ∈ pre(τ ), because 9 ≡occT 2, 2 ≤∩ 2, (2, 12) ∈ T (τ ),
12 ≤∩ 17—, and q(2, 12) = 10. Also, 1 := 17 3 4  ∈ pre(τ ), because 1 ≡occT 7,
7 ≤∩ 13, (13, 14) ∈ T (τ ), 14 ≤∩ 15, (15, 16) ∈ T (τ ), 16 ≤∩ 17—, q(15, 16) = 3, and
q(13, 14) = 4.
Intuitively, each rule m+ := ... in this pre-grammar describes the different possibilities of constructing a subterm (of an inhabitant of τ ) of type t(m) (where t(m) is a positive occurrence in τ ), based on the occurrences of subtypes of τ . For instance, rule 18 := λ17.9 means that a subterm of type t(18) can be of the form λx.N , where x is a variable whose type corresponds to the negative occurrence of t(17) in τ , and N is a subterm whose type corresponds to the positive occurrence of t(9) in τ . On the other hand, rule 9 := 17 10 means that a subterm of type t(9) can be of the form xN , where x is a variable whose type corresponds to the negative occurrence of t(17) in τ , and N is a subterm whose type corresponds to the positive occurrence of t(10) in τ . This is due to the fact that t(17) = t(12) ∩ t(16), t(12) = t(10) → t(2), and t(2) = t(9).
Deciding Inhabitation for Types in T −
In this section we define a rewrite-based non-deterministic decision algorithm, that checks if a given type in T — has a normal inhabitant, thus solving the emptiness problem for the set of T — types.
Definition 5.1 Given a type τ ∈ T —, an identifier m ∈ N(τ ) and a set V ⊆ N(τ ),
we write
(m, V ) ~ (n1,V j),..., (ns,V j), if one of the following applies.
If m := λk.n ∈ pre(τ ), then (m, V ) ~ (n, V ∪ {k});
if m := k n1 ··· ns ∈ pre(τ ) and k ∈ V , then (m, V ) ~ (n1,V ),..., (ns,V ).
The definition of ~ extends, in the usual way, to rewriting of sequences of pairs. Then, ~∗ denotes the reflexive, transitive closure of ~.
Definition 5.2 For a particular rewriting sequence of (n(τ ), ∅) ~∗ ϵ, we define a function pair that computes for each (m, V ) in that rewriting sequence a tuple (M, Γ) = pair(m, V ). For convenience, we will use identifiers as indexes of term variables in such a way that the type assigned to a variable with name xn, for n ∈ N(τ ), is always t(n). The function pair is recursively defined as follows.
If (m, V ) ~ (n, V ∪ {k}) because m := λk.n ∈ pre(τ ), then pair(m, V ) = (λxk.N, Γ \ {xk : t(k)}), where (N, Γ) = pair(n, V ∪ {k});
if (m, V ) ~ (n1,V ),..., (ns,V ) because m := k n1 ··· ns ∈ pre(τ ) and k ∈ V ,

then pair(m, V ) = (xk N1 ··· Ns, {xk : t(k)} ∪ Γ1 ∪ · · · ∪ Γs), where (Ni, Γi) = 
pair(ni,V ), for 1 ≤ i ≤ s (s ≥ 0).
Note that function pair actually does not depend on set V , but on the identifier m and on the rule in pre(τ ), which is used in each step of the rewriting sequence. Actually, it is the applicability of a rule, that depends on set V . Nevertheless, it is easy to verify that, xk : t(k) ∈ Γ implies k ∈ V . Consequently, if V = ∅, then we have that Γ = ∅. To guarantee that pair is well-defined, we suppose that in each rewriting step, the corresponding rewriting rule is given, either implicitly or explicitly. The correctness of function pair is stated in the following lemma.
Lemma 5.3 If (m, V ) ~∗ ϵ and (M, Γ) = pair(m, V ) for some rewriting sequence, then Γ ▶2 M : t(m).
Proof. By structural induction on M . We first consider the case where pair(m, V )= (λxk.N, Γ\{xk : t(k)}), which follows from (m, V ) ~ (n, V ∪{k}) ~∗ ϵ because m := λk.n ∈ pre(τ ) and (N, Γ) = pair(n, V ∪{k}). By the induction hypoth- esis, Γ ▶ N : t(n) and by definition Γ ∪ {xk : t(k)} is always consistent. Therefore, Γ ▶ λxk.N : t(k) → t(n)= t(m).
Now consider pair(m, V ) = (xkN1 ··· Ns, {xk : t(k)} ∪ Γ1 ∪ · · · ∪ Γs), which follows from (m, V ) ~ (n1,V ),..., (ns,V ) ~∗ ϵ because m := k n1 ··· ns ∈ pre(τ ) and k ∈ V , (Ni, Γi)= pair(ni,V ), for 1 ≤ i ≤ s (s ≥ 0). By the induction hypothesis Γi ▶ Ni : t(ni) and by definition {xk : t(k)}∪ Γ1 ∪· · ·∪ Γs is consistent. It follows from m := k n1 ··· ns ∈ pre(τ ) that
t(k)= ··· ∩ (t(n ) → t(p )) ∩··· 
`	˛¸	x
t(c0)
t(p1)= ··· ∩ (t(n2) → t(p2)) ∩··· 
`	˛¸	x
t(c1)
.
t(ps—1)= ··· ∩ (t(ns) → t(ps)) ∩··· 
`	˛¸	x
t(cs−1)
t(ps)= ··· ∩ t(cs) ∩ ··· ,
where t(cs) = t(m). By rule (var2), we have {xk : t(k)} ▶2 xk : t(c0). Since Γ1 ▶ N1 : t(n1), we obtain {xk : t(k)}∪ Γ1 ▶ xkN1 : t(c1), by rule (E→2). Repeating this process the necessary number of times, we finally get {xk : t(k)}∪ Γ1 ∪· · ·∪ Γs ▶ xkN1 ··· Ns : t(cs), where t(cs)= t(m).	2
Example 5.4 Consider τ and pre(τ ) from Examples 2.4 and 4.3. Then, (18, ∅) ~ (9, {17}) ~ (10, {17}) ~ (1, {0, 17}) ~ (3, {0, 17}), (4, {0, 17})
~ (4, {0, 17}) ~ ϵ.
For the first two pairs in this rewriting sequence we have respectively pair(17, ∅)= (λx17.x17(λx0.x17x0x0), ∅) and pair(9, {17})  =  (x17(λx0.x17x0x0), {x17  :  t(17)}),
where t(17) = ((o → o) → o) ∩ (o → ((o → ((o → o) ∩ o)) ∩ o)). Also,

▶2 λx17.x17(λx0.x17x0x0)) : t(18) and {x17 : t(17)} ▶2 x17(λx0.x17x0x0) : t(9), where t(18) = τ and t(9) = o.
Theorem 5.5 Let θ ∈T —. Then, Nhabs(θ) /= ∅ if and only if (n(θ), ∅) ~∗ ϵ.
Proof. The ’if’ part follows from Lemma 5.3. For the ’only if’ part, we show that for any term M , context Γ and type σ, if a formula Γ ▶2 M : σ appears in a derivation of
▶2 Mj : θ, then (n(σ), VΓ) ~∗ ϵ, where σ is the positive occurrence of σ in θ assigned to M for that formula, i.e. σ = pst(M ), and VΓ = { n(ρ) | x : ρ ∈ Γ ∧ ρ = nsp(x) }. First, consider M = λx.N and suppose that we have Γ\{x : σ} ▶2 λx.N : σ → τ , because Γ ▶2 N : τ and Γ∪{x : σ} is consistent. Consider the corresponding positive occurrence pst(λx.N )= σ → τ . Then, there is a tuple (σ → τ, m, k → n) ∈ occT(θ), where n(σ → τ ) = m, n(σ) = k, and n(τ ) = n, corresponding to that positive occurrence. The occurrences of σ in σ → τ is, by definition, a negative subpremise and the occurrence of τ is positive. We conclude that m+, k—, n+ ∈ N(θ) and consequently, m := λk.n ∈ pre(θ). Thus, (m, VΓ\{x:σ}) ~ (n, VΓ\{x:σ} ∪ {k}). But,
VΓ\{x:σ} ∪ {k}⊇ VΓ and (n, VΓ) ~∗ ϵ follows from the induction hypothesis.
Now, consider a formula of the form Γ ▶2 xN1 ··· Ns : τ with s ≥ 0 and suppose that this formula was derived, step by step, starting with {x : τ 0∩· · ·∩τ 0 } ▶2 x : τ 0 ,
1	n0	i0
where i0 ∈ {0,,..., n0}. This formula, combined with Γ1 ▶2 N1 : σ1 lead to
{x : τ 0 ∩···∩ τ 0 }∪ Γ1 ▶2 xN1 : τ 1 , etc., until reaching Γ ▶2 xN1 ··· Ns : τs , where
1	n0	i1	is
s = τ . Consider the identifiers p— = n(nsp(x)) and c0 = n(nst(x)) of the negative
occurrences of subtypes of θ, respectively assigned to x in the context and on the right side of ▶2 in the starting formula. Then, c0 ≤∩ p—. Let n1 = n(pst(N1)), where pst(N1) is the positive occurrence of σ1 assigned to N1 for Γ1 ▶2 N1 : σ1.
Necessarily, τ 0 = σ1 → τ 1 ∩ · · · ∩ τ 1 , and we have lab(c0) = n1 → p1, where
i0	1	n1
t(p1)= τ 1 ∩· · ·∩ τ 1 . We conclude that (p1, c0) ∈ T (θ), with q(p1, c0)= n1. Next,
1	n1
let c1 = n(nst(xN1)), assigned for formula {x : τ 0 ∩ · · ·∩ τ 0 }∪ Γ1 ▶2 xN1 : τ 1 .
1	n0	i1
Again, we conclude that c1 ≤∩ p1. This, argument can be repeated until finally

reaching formula Γ ▶2 xN1 ··· Ns : τs
where τs
= τ .  For this formula, term

xN1 ··· Ns is assigned both a negative, as well as a positive, occurrence of subtype
τ . We have cs = n(nst(xN1 ··· Ns)). Furthermore, for m+ = n(pst(xN1 ··· Ns))

we have m+ ≡occT cs, since τs
= τ . From all this, we conclude that there is a

rule m := p0 n1 ··· ns ∈ pre(τ ). On the other hand, p0 ∈ V , thus (m, VΓ) ~
(n1, VΓ),..., (ns, VΓ). By the induction hypothesis, we have (ni, VΓ ) ~∗ ϵ, for

1 ≤ i ≤ s. We conclude that (n(σ1), VΓ),..., (n(σs), VΓ) ~∗ ϵ, since VΓ
⊆ VΓ, for

1 ≤ i ≤ s.	2
Definition 5.6 Given a type τ , let |τ| = |τ|v + |τ|→ + |τ|∩, where |τ|v represents the number of occurrences of type variables in τ , |τ|→ the number of occurrences of → in τ , and |τ|∩ the number of occurrences of ∩ in τ . Furthermore, let |τ|+ and
|τ|— denote the number of positive occurrences of subformulas and the number of negative subpremises in τ , respectively.
Example 5.7 For τ from Examples 2.4 and 4.3, we have |τ| = 19, |τ|+ = 7,
|τ|— = 2.

Now, we present a non-deterministic algorithm to address the emptiness problem of T —-types. In every step of the algorithm there are only a finite number of choices that apply. On the other hand, there is an upper bound on the number of steps that can be performed in each recursive call. Consequently, the algorithm can be used as the foundation for a decision procedure.
Theorem 5.8 Consider θ ∈ T — and let D = |θ|+ · (|θ|— + 1). Then, Nhabs(θ) /= ∅
if and only if the algorithm below terminates with success.
The algorithm operates as follows, starting with the initial call (m, V, i) = (n(θ), ∅, 0):
if i > D the loop aborts with failure;
otherwise the algorithm:
non-deterministically chooses a rule in r ∈  pre(θ) such that (m, V ) ~
(n1,V j),..., (ns,V j);
universally applies to calls (n1,V j,i + 1),..., (ns,V j,i + 1).
Other than by failure, a loop ﬁnishes with success if the rule chosen from pre(θ) is such that s = 0, or if the recursive calls (n1,V j,i + 1),..., (ns,V j,i + 1) (s ≥ 1) all ﬁnish sucessfully. The algorithm ﬁnishes with success, if the initial loop starting with call (n(θ), ∅, 0) ﬁnishes successfully.
Proof. By Theorem 5.5 Nhabs(θ) /= ∅ is equivalent to the existence of an rewriting sequence for (n(θ), ∅) ~∗ ϵ. Each rewriting sequence of (n(θ), ∅) ~∗ ϵ can be represented in the usual way by a unique tree t, whose internal nodes are labelled with tuples (m, V, i) and such that all leafs are labelled with ϵ. The root of t is (N(θ), ∅, 0), and whenever a rule r ∈ pre(θ) is applied to a pair (m, V, i), such that (m, V ) ~ (n1,V j),..., (ns,V j), then the corresponding node in t, labelled with (m, V ), has s children labelled with (n1,V j,i + 1),..., (ns,V j,i + 1) if s > 0, and it has one child labelled with ϵ if s = 0. Consider a node n in t with label (m, V, i). The last coordinate i is the depth of n in t, i.e. the number of edges from node n to the tree’s root node (labelled with (N(θ), ∅, 0)). The subtree rooted in n corresponds to a rewriting sequence (m, V ) ~∗ ϵ. If there are two nodes ni and nj in one branch of t respectively labelled with (m, V, i) and (m, V, j) such that i < j, we call this a repetition. This repetition can be eliminated, if one replaces the subtree of t rooted in ni by the subtree rooted in nj. The resulting tree corresponds still to a (shorter) rewriting sequence of (n(θ), ∅) ~∗ ϵ. Repeating this process, as long as the tree contains repetitions, one eventually obtains a repetition-free tree. The height of a repetition-free tree is thus limited by the number os possible combinations (m, V ) in one branch. On the other hand, if a node nj, with label (mj, Vj, j), is a descendant of a node ni, with label (mi, Vi, i), where i < j, then Vi ⊆ Vj. Since the coordinates m and V in a tuple (m, V, i) are respectively an identifier of a positive occurrence of a subtype in θ, and a set of identifiers of negative subpremises in θ, there are at most |θ|+ different values for m and at most |θ|— +1 different sets V in a branch of a repetition-free tree. Thus, all branches in a repetition-free tree are of height
≤ D = |θ|+ · (|θ|— + 1). Finally, note that for each call (m, V, i) there is only a

finite number of rules r ∈ pre(θ) that apply. This guarantees the termination of the algorithm. We conclude that, Nhabs(θ) /= ∅ if and only if the algorithm terminates with success.	2
Intersections of T −-Types
In this section we recall the method, from [3], of combining pre-grammars of m ≥ 2 types τ1,..., τm, in order to obtain a pre-grammar for Nhabs(τ1) ∩  ∩ Nhabs(τm)= 
Nhabs(τ1 ∩··· ∩τm). For illustrative purposes we then instantiate with a type of the family {T (n)}n≥1 considered in [17], where for each n ≥ 1 type T (n) has a unique inhabitant, which is of size O(2n).
Definition 6.1 Given types τ1,..., τn ∈ T — (n ≥ 2), we define N(τ1 ∩  ∩ τn)= 
N(τ1) × · · ·× N(τn). Furthermore, let pre(τ1 ∩ · · ·∩ τn) denote the smallest set of rules satisfying the following.
If mi	:=	λki.pi	∈	pre(τi) (i	=	1,..., n),	then (m1,..., mn)	:=
λ(k1,..., kn).(p1,..., pn) ∈ pre(τ1 ∩	∩ τn);
if mi := ki pi ··· pi ∈ pre(τi) for i = 1,.	,n and s ≥ 0, then
1	s
(m1,..., mn) := (k1,..., kn) (p1,..., pn) ··· (p1,..., pn) ∈ pre(τ1 ∩· · · ∩ τn).
1	1	s	s
Theorem 6.2 Consider types τ1,..., τn ∈ T —, where n ≥ 2. Then, one has Nhabs(τ1 ∩· · ·∩τn) /= ∅ if and only if ((n(τ1),..., n(τn)), ∅) ~∗ ϵ, with pre-grammar pre(τ1 ∩· · · ∩ τn).
Proof. For the ’only if’ part, suppose that Nhabs(τ1 ∩ ··· ∩ τn) /= ∅ and consider M ∈ Nhabs(τ1∩· · ·∩τn). Then, ▶2 M : τi, for i = 1,..., n. On the other hand, every tuple of identifiers (m1,..., mn) ∈ N(τ1 ∩· · · ∩τn)= N(τ1) ×· · · × N(τn), corresponds directly to a tuple (σ1,..., σn) of subtypes σ1,..., σn, respectively of τ1,..., τn, such that the identifier of σi in occT(τi) is mi, i.e. n(σi) = mi and t(mi) = σi. Now, it remains to adapt the argument in the proof of Theorem 5.5, combining it with the fact that:
mi := λki.pi ∈ pre(τi) for i = 1,..., n, implies that there is a rule (m1,..., mn) :=
λ(k1,..., kn).(p1,..., pn) ∈ pre(τ1 ∩· · · ∩ τn);
mi := ki pi ··· pi ∈ pre(τi) for i = 1,...,n and s ≥ 0, implies that there is a rule
1	s
(m1,..., mn) := (k1,..., kn) (p1,..., pn) ··· (p1,..., pn) ∈ pre(τ1 ∩· · · ∩ τn).
1	1	s	s
For the ’if’ part, following Definition 5.2, we modify the definition of function
pair, including a third argument i ∈ {1,..., n}, in the following way. We use the ab-

breviations m→
= (m1,..., mn), p→ = (p1,..., pn) and →k = (k1,..., kn). Furthermore,

ti(ki) will denote the type occurrence with identifier ki in occT(τi).
If (m→ , V ) ~ (p→, V ∪{→k}) because m→ := λ→k.p→ ∈ pre(τ1∩· · ·∩τn), then pair(m, V, i)= 
(λx→k.N, Γ \ {x→k : ti(ki)}), where (N, Γ) = pair(p, V ∪ {→k}, i);

if (m→ , V ) ~ (p1,V ),..., (ps,V ) because m→
:= →k p→1 ··· p→s ∈ pre(τ1 ∩· · ·∩ τn) and

→k ∈ V , then pair(m, V ) = (x→k N1 ··· Ns, {x→k : ti(ki)} ∪ Γ1 ∪ · · · ∪ Γs), where (Ni, Γi)= pair(ni, V, i), for 1 ≤ i ≤ s (s ≥ 0).

Then, following the proof of Lemma 5.3 one shows that for each i ∈ {1,..., n} we have ▶2 Mi : τi, if (Mi, ∅) = pair((n(τ1),..., n(τn)), ∅, i), for a particular rewriting sequence of ((n(τ1),..., n(τn)), ∅) ~∗ ϵ. Now, it remains to observe that the term Mi constructed by function pair is the same for all i ∈ {1,..., n} (as long as the same rewriting sequence is considered).	2
Example 6.3 Consider the family {T (n)}n≥1 from [17], where T (n) = τ1 ∩

··· ∩ τn and for 1 ≤ i ≤ n, τi  = a →
`Ψ → ·˛·¸· → Ψx
i—1
→ (a  → b) →

(b → a) → · · · → (b → a) → b and Ψ= (a → a) ∩ (b → b).
`	˛¸	x
n—i
The unique inhabitant of

T (3) = τ1 ∩ τ2 ∩ τ3
= (a → (a → b) → (b → a) → (b → a) → b)  ∩
(a → ((a → a) ∩ (b → b)) → (a → b) → (b → a) → b)  ∩
(a → ((a → a) ∩ (b → b)) → ((a → a) ∩ (b → b)) → (a → b) → b)
is

M3  = λx1x2x3x4.x2(x3(x2(x4(x2(x3(x2x1)))))).


Pre-grammars pre(τ1), pre(τ2) and pre(τ3) are as follows.


From this we obtain a pre-grammar below for T (3), applying the construction in Definition 6.1. Note that we only include rules of the form (m1, m2, m3) := (n1, n2, n3)  ( , , ) ··· ( , , ),  if there is some other rule (mj , mj , mj )  :=
1	2	3
λ(n1, n2, n3).( , , ) in the pre-grammar. Otherwise, this rule would be useless,
since there will never be a tuple (n1, n2, n3) in the set of available variables V , during any rewriting sequence starting with (14, 18, 22). So this rule can never be

applied.


(14, 18, 22) := λ(0, 0, 0).(13, 17, 21)
(13, 17, 21) := λ(8, 14, 17).(12, 16, 20)
(12, 16, 20) := λ(9, 12, 18).(11, 15, 19)
(11, 15, 19) := λ(10, 13, 16).(7, 9, 11)
(7, 9, 11) := (8, 14, 17) (1, 3, 3)
(1, 3, 3) := (9, 12, 18) (3, 5, 7)
(3, 5, 7) := (8, 14, 17) (1, 1, 3)
(1, 1, 3) := (10, 13, 16) (5, 7, 9)
(5, 7, 9) := (8, 14, 17) (1, 3, 1)
(1, 3, 1) := (9, 12, 18) (3, 5, 5)
(3, 5, 5) := (8, 14, 17) (1, 1, 1)
(1, 1, 1) := (0, 0, 0)


There is exactly one rewriting sequence ((14, 18, 22), ∅) ~∗ ϵ, depicted below.

((14, 18, 22), ∅) ~∗ ((13, 17, 21), {(0, 0, 0)})
~∗ ((12, 16, 20), {(0, 0, 0), (8, 14, 17)})
~∗ ((11, 15, 19), {(0, 0, 0), (8, 14, 17), (9, 12, 18)})
~∗ ((7, 9, 11), {(0, 0, 0), (8, 14, 17), (9, 12, 18), (10, 13, 16)})
~∗ ((1, 3, 3), {(0, 0, 0), (8, 14, 17), (9, 12, 18), (10, 13, 16)})
~∗ ((3, 5, 7), {(0, 0, 0), (8, 14, 17), (9, 12, 18), (10, 13, 16)})
~∗ ((1, 1, 3), {(0, 0, 0), (8, 14, 17), (9, 12, 18), (10, 13, 16)})
~∗ ((5, 7, 9), {(0, 0, 0), (8, 14, 17), (9, 12, 18), (10, 13, 16)})
~∗ ((1, 3, 1), {(0, 0, 0), (8, 14, 17), (9, 12, 18), (10, 13, 16)})
~∗ ((3, 5, 5), {(0, 0, 0), (8, 14, 17), (9, 12, 18), (10, 13, 16)})
~∗ ((1, 1, 1), {(0, 0, 0), (8, 14, 17), (9, 12, 18), (10, 13, 16)})
~∗ ϵ

For this sequence, pair((14, 18, 22), ∅) ≡α M3.

Conclusions
We studied the notion of pre-grammar in the realm of rank 2 intersection types and addressed the emptiness problem for a rank 2 subsystem. We consider types in T2 without positive occurrences of intersections, for which the previous methods defined for simple types extend in an elegant way. As future work we aim at extending our methods to the full rank 2 type system as well as exploring other, more expressive, related type systems.

References
Jo˜ao Alpuim, Bruno C. d. S. Oliveira, and Zhiyuan Shi. Disjoint polymorphism. In Hongseok Yang, editor, Programming Languages and Systems - 26th European Symposium on Programming, ESOP 2017, Held as Part of the European Joint Conferences on Theory and Practice of Software, ETAPS 2017, Uppsala, Sweden, April 22-29, 2017, Proceedings, volume 10201 of Lecture Notes in Computer Science, pages 1–28. Springer, 2017.
S. Alves and S. Broda. Inhabitation machines: determinism and principality. In Ninth Workshop on Non-Classical Models of Automata and Applications, NCMA 2017, pages 57–70, 2017.
S. Alves and S. Broda. A unifying framework for type inhabitation. In 3rd International Conference on Formal Structures for Computation and Deduction (FSCD 2018), Leibniz International Proceedings in Informatics (LIPIcs), 2018.
Ch. Ben-Yelles. Type Assignment in the Lambda-Calculus: Syntax and Semantics. PhD thesis, University College of Swansea, September 1979.
Flavien Breuvart and Ugo Dal Lago.  On intersection types and probabilistic lambda calculi. In Proceedings of the 20th International Symposium on Principles and Practice of Declarative Programming, PPDP ’18, pages 8:1–8:13, New York, NY, USA, 2018. ACM.
S. Broda and L. Damas. On long normal inhabitants of a type. Journal of Logic and Computation, 15:353–390, June 2005.
A. Bucciarelli, D. Kesner, and S. Ronchi Della Rocca. The inhabitation problem for non-idempotent intersection types. In Theoretical Computer Science - 8th IFIP TC 1/WG 2.2 International Conference, TCS, volume 8705 of Lecture Notes in Computer Science, pages 341–354. Springer, 2014.
M.W. Bunder. Proof finding algorithms for implicational logics. Theoretical Computer Science, 232(12):165 – 186, 2000.
M. Coppo and M. Dezani-Ciancaglini. An extension of the basic functionality theory for the λ-calculus.
Notre Dame Journal of Formal Logic, 21(4):685–693, 1980.
M. Dezani-Ciancaglini, F. Honsell, and Y. Motohama. Compositional characterisations of lambda-terms using intersection types. Theor. Comput. Sci., 340(3):459–495, 2005.
A. Dudenhefner and J.Rehof. Typability in bounded dimension. In 32nd Annual ACM/IEEE Symposium on Logic in Computer Science, LICS 2017, Reykjavik, Iceland, June 20-23, 2017, pages 1–12. IEEE Computer Society, 2017.
A. Dudenhefner and J. Rehof. Intersection type calculi of bounded dimension. In G. Castagna and A. D. Gordon, editors, Proceedings of the 44th ACM SIGPLAN Symposium on Principles of Programming Languages, POPL 2017, Paris, France, January 18-20, 2017, pages 653–665. ACM, 2017.
J.R. Hindley. Basic Simple Type Theory, volume 42 of Cambridge Tracts in Theoretical Computer Science. Cambridge University Press, 1997.
H. Hu¨ttel, I. Lanese, V. T. Vasconcelos, L. Caires, M. Carbone, P.-M. Deni´elou, D. Mostrous,
L. Padovani, A. Ravara, E. Tuosto, H. Torres Vieira, and G.Zavattaro. Foundations of session types and behavioural contracts. ACM Comput. Surv., 49(1):3:1–3:36, 2016.
T. Jim. Rank 2 type systems and recursive definitions, 1995.
T. Jim. What are principal typings and what are they good for? In Proceedings of the 23rd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, POPL ’96, pages 42–53, New York, NY, USA, 1996. ACM.
D. Kusmierek. The inhabitation problem for rank two intersection types. In S. Ronchi Della Rocca, editor, Typed Lambda Calculi and Applications, 8th International Conference, TLCA 2007, Paris, France, June 26-28, 2007, Proceedings, volume 4583 of Lecture Notes in Computer Science, pages 240–254. Springer, 2007.
D. Leivant. Polymorphic type inference. In Proceedings of Principles of Programming Languages (POPL’83), pages 88–98, New York, NY, USA, 1983. ACM Press.
A. Schubert, W. Dekkers, and H.P. Barendregt. Automata theoretic account of proof search. In CSL 2015, pages 128–143, 2015.
R. Statman. Intuitionistic propositional logic is polynomial-space complete. Theoretical Computer Science, 9:67–72, 1979.
M. Takahashi, Y. Akama, and S. Hirokawa. Normal proofs and their grammar. Information and Computation, 125(2):144–153, 1996.


P. Urzyczyn. The emptiness problem for intersection types. Journal of Symbolic Logic, 64(3):1195– 1215, 1999.
P. Urzyczyn. Inhabitation of low-rank intersection types. In TLCA’09, volume 5608 of LNCS, pages 356–370. Springer, 2009.
S. van Bakel. Complete restrictions of the intersection type discipline. Theoretical Computer Science, 102:135–163, 1992.
S. van Bakel. Intersection Type Disciplines in Lambda Calculus and Applicative Term Rewriting Systems. PhD thesis, Department of Computer Science, University of Nijmegen, 1993.
S. van Bakel.	Rank 2 intersection type assignment in term rewriting systems.	Fundamenta Informaticae, 26(2):141–166, April 1996.
