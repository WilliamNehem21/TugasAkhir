

Electronic Notes in Theoretical Computer Science 240 (2009) 221–238
www.elsevier.com/locate/entcs

A TLA+ Formal Specification and Verification of a New Real-Time Communication Protocol
Paul Regnier 1,2 George Lima 3 Aline Andrade 4
Distribued Systems Laboratory (LaSiD) Department of Computer Science (DCC) Federal University of Bahia (UFBA) Cep 40.170-110, Salvador, Bahia, Brazil

Abstract
We describe the formal specification and verification of a new fault-tolerant real-time communication pro- tocol, called DoRiS , which is designed for supporting distributed real-time systems that use a shared high-bandwidth medium. Since such a kind of protocol is reasonably complex and requires high levels of confidence on both timing and safety properties, formal methods are useful. Indeed, the design of DoRiS was strongly based on formal methods, where the TLA+ language and its associated model-checker TLC were the supporting design tool. The protocol conception was improved by using information provided by its formal specification and verification. In the end, a precise and highly reliable protocol description is provided.
Keywords: Formal Specification, Verification, TLA+, Real-Time Protocol


Introduction
New automation and control systems are characterized by the need of high levels of flexibility and service integration in addition to their usual requirements such as fault tolerance and predictability. This has motivated the development of new communication protocols based on high-bandwidth medium, such as Ethernet or Wireless. Interested readers can find good surveys on this topic [4,6,12].
Since designing is a reasonable complex task, the use of formal methods plays an important role to guarantee correct design and reliable implementation. Motivated by noticeable advances in the field [3,7], formal methods have increasingly been

1 This work has received funding support from the Brazilian funding agencies CNPq (Grant number 475851/2006-4) and FAPESB (Grant number 7630/2006).
2 Email: pregnier@ufba.br
3 Email: gmlima@ufba.br
4 Email: aline@ufba.br

1571-0661 © 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.05.054

applied in the study and verification of many of these communication protocols [9,13,1,5], some of which with real-time characteristics.
Presenting the case study of the specification and verification of a new real-time communication protocol, called DoRiS (a Double Ring Service protocol for Real- Time Systems), we illustrate how formal methods can help the design of the protocol as well as its implementation. We have used here the Temporal Logic of Actions and its associated language TLA+ [10]. Our choice of TLA+ to specify and verify DoRiS was motivated by the following reasons. TLA+ provides a modular structure which allows for an incremental process of specification refinements, according to the abstraction level required. Thus, a concrete specification, close to the code level, can be achievable. Also, the TLC model-checker provides an automatic verification of the specification and its properties. Hence, the use of TLA+ has allowed us to carry out both the conception and the specification of DoRiS interactively and progressively as an integrated software engineering process. We present here the final specification and model-checking of DoRiS , which has been successfully used as a basis for the protocol implementation on a Linux-based real-time platform [14]. The remainder of this paper is structured as follows. The protocol is outlined in Section 2. Section 3 gives our modeling assumptions and some initial concepts on TLA+ before addressing the description of the specification itself. Some relevant properties of DoRiS are shown by formal verification. They are commented upon Section 4. In Section 5, we also comment on how the formal specification has been
useful during the design of DoRiS . Conclusions are drawn in Section 6.
The DoRiS protocol
DoRiS is a deterministic protocol built on top of a shared medium communication layer. The protocol works as a logical layer, extending the MAC and LLC layer [8]. It is designed to support hybrid systems where industrial sensors, actuators and controllers share the communication network with other soft applications. In such a hybrid configuration, the processing speed and the communication characteristics of the two types of application may differ considerably [2]. Thus, we assume that a number of industrial appliances (micro-controllers, sensors etc), called hereafter slow nodes, have low processing times when compared to fast nodes such as workstations.
The model and terminology
The set of nodes (slow or fast) connected through a shared medium make up a DoRiS segment. Although many DoRiS segments can be inter-connected by switches or routers, we will restrict our specification and verification to a single DoRiS segment. At each node, a server is responsible for the transmission of hard real-time and best-effort messages. Slow nodes send only hard real-time messages and fast nodes may send both hard and best-effort messages. Each server maintains a hard queue, which stores hard real-time messages to be sent. Fast servers also maintain a soft queue, which stores outgoing best-effort messages. Although there is only a single server in each node, we define HardServ [i ] and SoftServ [i ], the two server threads

of node i dealing with the hard and soft queues, respectively. As there may be many processes executing on a node, some local priority policy has to be defined to schedule messages of different applications. However, this topic is beyond this paper scope, which is focused only on the communication aspects.
We define nServ as the total number of servers and ServID = {1, 2,..., nServ}, as the corresponding set of identifiers. HardServ and SoftServ are identified by the elements of ServID . The sets of HardServ and SoftServ , respectively denoted HardRing and SoftRing , define the two logical rings of a DoRiS segment, where a single token rotates. As all servers must participate in the hard communication, HardRing equals ServID while SoftRing is a subset of ServID .
Messages from slow nodes are short, usually periodic, and have hard real-time constraints. Such messages, called hard messages, are assumed to have a constant length denoted l (e.g. l = 64B over Ethernet). They are processed upon reception by the servers within a maximum processing time, denoted π, which is associated to worst-case processing time of slow nodes. Hard messages are transmitted through the network within a maximum transmission time δ  π. The communication medium can be under-utilized if only slow nodes are present in the DoRiS segment. However, if there are fast nodes sharing the medium, DoRiS allows them to use this spare bandwidth. Messages exchanged by fast nodes, called soft messages, have a variable length denoted L, usually larger than l . (e.g. l ≤ L ≤ 1500B over Ethernet).
We assume a synchronous distributed system. Thus, actions taken by nodes can be synchronized with each other. This assumption is based on the time division scheme of DoRiS , which, as will be seen, has regular and predictable points of synchronism which take place within a small time window. This implies that node clocks are synchronized. We also assume that nodes may crash and transmitted messages may be lost. If some part of the message is altered, by electromagnetic interference for example, it is assumed that a checksum test is performed by the receiver, allowing it to transform this fault in an omission by simply discarding the erroneous message.
The Medium Access Control Scheme
The time of the communication on a DoRiS segment is divided into a series of communication rounds (C-Rd ) and membership rounds (M-Rd ), as illustrated in Figure 1. During M-Rd, the membership control algorithm is responsible for keeping a common membership view before the communication round begins. Since the focus of the specification is on the communication rounds, the membership round will not be further described and we consider hereafter a fixed and shared value of nServ .
Using TDMA (Time Division Multiple Access), each C-Rd is defined as an arbi- trary but fixed number of periodic cycles, which in turn are subdivided into exactly nServ chips (see Figure 1). Each of these chips is subdivided into two windows, hard and soft, denoted WH and WS , respectively, which are associated with hard and non-hard real-time traffics. Hard servers send messages in WH and soft servers



Fig. 1. The DoRiS Time Division Scheme

use WS to transmit theirs. The sizes of WH and WS are denoted ΔH and ΔS , respectively, and the chip size is defined by ΔC = ΔH + ΔS . To allow for some flexibility and message scheduling policy, each hard real-time window WH is fur- ther divided into two slots, the elementary (SE ) and the reservation (SR ) slots. Messages sent in these two slots are hard messages, called elementary and reserva- tion messages, respectively. Once per cycle each hard server sends an elementary message in SE while SR is used to implement a reservation mechanism. In order to tolerate crash failure and provide reliability for the whole system, elementary messages are mandatory.
The reservation mechanism works as follows. Each elementary message sent by a hard server i carries a list of slots this server is interested in for transmitting ad- ditional messages. This list contains the identifiers of such reservation slots in the next nServ chips. Hard server i is only allowed to reserve a slot if two conditions hold: (i) such a slot has not been reserved by another server; and (ii) hard server i is in a consistent state. Condition (ii) holds if i has received the previous nServ elementary messages. Consequently, such a dynamic slot allocation scheme is tol- erant to message omissions. This reservation mechanism is an innovation of DoRiS and allows applications to implement some scheduling policy. Indeed, a hard server has the right to use an elementary slot per cycle and may use up to nServ − 1 other slots.
The medium access control of DoRiS is regulated by an implicit token, which rotates in the hard and soft rings (Section 2.1), according to timing and/or logical conditions built upon observed communication activities. A pure TDMA scheme is used to isolate the two rings of DoRiS . As for the soft ring scheme, the process group membership is dynamically managed using the following mechanism. Elementary messages contain a bit which, whenever set, informs all servers that the sending server will thenceforth participate of the soft ring. When the soft queue of a server

gets empty, it simply unsets the bit flag of its elementary message. During WS , the token rotates, according to the soft ring order, whenever an interruption is issued by the medium device.
The specification
In this section we give a detailed top-down description of the DoRiS specification even though we present only the most relevant protocol actions for the sake of space. 5
In the specification, time varies by discrete unity. Although such a discrete rep- resentation can compromise the model accuracy of asynchronous systems in gen- eral [3], it is acceptable for synchronous message-passing protocols [11]. We also consider that whenever a specified action gets enabled, it either happens without delay or is immediately disabled. This implies that timers are specified with null jitter. Further, since we assume a synchronous model and to avoid the specifica- tion of clock synchronization details, we consider that all nodes share a common global clock. Note that elementary messages are mandatory and frequent enough in comparison with the maximum drift of clocks so that all nodes can synchronize their local clocks with high precision and accuracy, even in the presence of a few message omissions. Before stepping into the specification, some concepts on TLA+ are given.
Concepts on TLA+
The Temporal Logic of Actions (TLA) and its associated formal language (TLA+) combine the Temporal Logic of TLA [10] with the expressiveness of predicate logic and Zermelo-Fraenkel set theory. Equipped with its associated model-checker, TLC [16], one can specify and verify both hardware and distributed protocols. In this section, we present some basic syntax of TLA+. Other information on TLA+ will be given along with the description of the DoRiS specification. Readers inter- ested in a comprehensive description of TLA+ can refer to Lamport’s publication [10].
In a TLA+ specification, a computation of a system is represented as a sequence of states. A state of the system is an assignment of constant values to variables and a sequence of states is called a behavior which describes a history. A pair of consecutive states, i and f say, is named a step, denoted i → f . The prime (') operator is used to distinguish the values of variables on a step. Considering a given step S : i → f and assuming a variable v on S, the unprimed occurrence (v ) refers to its value in i while the primed occurrence (v ') refers to its value in f .
A state predicate is a boolean expression where only unprimed variables occur. A transition function on a step is an expression where primed and unprimed variables occur. For example, if step S is such that v =0 in i and v =1 in f , the transition function [v ' − v ] equals 1 on S . Finally, an action is defined as a boolean-valued

5 The complete specification is available at: http://www.lasid.ufba.br/publicacoes/reltec/DoRiS.zip

transition function on steps. In our example, the action defined by [v ' = v + 1] is true of step S . Note that for a given step S , the next-state relation from state i to state f , usually called state transition function in Finite State Machine formalism, is defined by the set of actions defined on S . As an action can be made up of several other actions, this set is also an action.
TLA+ temporal formulas are boolean assertions about behaviors. A behavior satisfies a formula F if F is a true assertion of this behavior. The temporal logic operator  is used to define the transition relationship between states. The semantic of is defined as follows: for some behavior Σ and some action A, the temporal formula Spec = [A]vars is true - or simply “Σ satisfies Spec” - if and only if for any step S : i → f of Σ that changes the tuple vars of all flexible variables, A is true on S .
Constants and Variables
In order to define a model of the system, a TLA+ specification makes use of con- stants and variables. The following six constants were used here: (i) nServ , the DoRiS server number; (ii) deltaChip, the duration ΔC of a chip; (iii) delta, the transmission time δ of a hard message; (iv) pi , the processing time π of a hard mes- sage by the slowest device of the DoRiS segment; (v) maxTxTime, the transmission time of the largest message (1524 bytes for Ethernet); (vi) horizon, the upper bound on the number of cycles used for model-checking. Observe that two hard messages can be sent in each chip. Thus, the value of ΔC was chosen such that the processing of two hard messages is feasible during a single chip. This restriction implies that
ΔC > 2 ∗ π. Other constants may be defined using the “ = ” symbol. For instance,
the set of servers identifiers ServID , is defined by ServID =Δ  1 .. nServ , where for
i < j , i .. j =Δ  {i, i + 1, ... , j }.
The attributes of DoRiS are grouped into four variables, called Shared , HardState, SoftState and History. Shared is used to represent the common vi- sion of the system shared by all servers. It is made up of six fields: (i) soft holds the current soft ring membership; (ii) chipTimer is an increasing and cyclic timer that range from 0 to deltaChip; (iii) chipCount is an increasing and cyclic modulo-nServ counter, which holds the value of the on-going chip. This counter is periodically incremented by the action NextChip whenever chipTimer times out at the end of each chip (as will be seen in Section 3.6). (iv) cycleCount is an increasing and cyclic horizon-modulo counter; (v) medium represents the physical medium state. If no message is being transmitted, medium equals {}. Otherwise, medium stores the message being transmitted. (vi) macTimer is a counting-down timer, which represents the message transmission time. It equals 0 when the medium is idle. Otherwise, it equals the remaining time to finish an on-going message transmission. Both HardState and SoftState are nServ -tuples whose fields are used to store the local state information of each server. HardState has four fields: (i) msg is the list of hard messages stored in local buffers after their reception by the network device; (ii) execTimer is a decreasing timer that specifies the time remaining to complete the processing of a hard message; (iii) res is the reservation list for the

nServ next chips; (iv) cons is a counter that represents the number of elementary messages received in a complete DoRiS cycle. SoftState has three fields: (i) token is a counter used to control the token circulation during WS ; (ii) list is the list of soft messages waiting to be transmitted; (iii) count is the number of soft messages received during WS .
Finally, History is an observer variable used to check specific temporal proper- ties. It has two fields: (i) elem is the number of elementary messages sent in a cycle, and; (ii) rese is the number of reservation messages sent in a cycle.
The main formula Spec
DoRiS main formula, shown in Figure 2, describes the behaviors of the system through the definition of the set of initial states, called Init, the next-state relation, here based on the disjunct of the two actions, Next or Tick, and a liveness constraint. A behavior Σ satisfies Spec iff the first state of Σ satisfies Init and every step of
Σ satisfies either Next or Tick and the Liveness condition, defined by Liveness =Δ
 Tick . This box formula ensures that a behavior that satisfies Spec eventually progress. In addition, due to the circular time representation, behaviors that satisfy Spec are periodic, allowing for the model-checking of some finite models.

Next


Spec
=Δ	∨ ∃ s ∈ HardRing : ElemSend (s) ∨ ReseSend (s)
∨ ∃ t ∈ SoftRing (Shared.soft ): SoftSend (t )
∨ ∃ msg ∈ Shared.medium : Receive(msg )
= Init ∧  [Next ∨ Tick ]vars ∧ Liveness



Fig. 2. The Next and Spec formulas

Init − The Init predicate defines the initial protocol states by assigning values to all variables used in the specification. Since Init is a long formula that does not describe functionalities of the protocol, it is omitted here.
Next − This action, also shown in Figure 2, describes the protocol func- tionalities that leaves time unchanged.The first line of this formula describes the hard ring sending services. It states that a given hard server s may take one of two actions, ElemSend (s) or ReseSend (s). These actions describe the transmission of an elementary message or a reservation message, respectively. The soft ring sending service is specified in the second line of the formula by means of the SoftSend (t ) action. A soft server t may take the ElemSend (t ) step if it is a member of the soft server group (soft field of the Shared variable). Finally, the third line specifies the reception action that can take place whenever some message is available in the medium. Actually, as will be seen, this action takes two distinct formulations de- pending on whether the incoming message is hard or soft. If no state satisfies the enabling conditions of these five actions, the only remaining possibility is the Tick action, unless deadlock has been reached.
Tick − This action, defined as Tick  =Δ  NextTick ∨ NextChip, represents
the flow of time. To allow for the verification of some finite model, despite the

unbounded nature of time, we use a circular time representation by defining the Tick action as a disjunction of two actions: NextTick , which increments the timers by discrete steps, and NextChip, which implements the time circularity.

The Hard Ring
The actions that specify the hard ring are described in this section.
ElemSend − This action, shown in Figure 3, describes the rules used to send elementary messages. The three enabling predicates of the ElemSend formula state that task t is allowed to send a message when: (i) the previous transmission has finished (medium = {}); (ii) the chip is starting (chipTimer = 0); and (iii) hard server s has the token (i = ChipCount ). Note the use of the construct let to define local variables. Here, the hardID (s) function is used to define the identifier value i of server s, and flag is set to 1 whenever some soft message is waiting to be sent. These three conditions ensure that s only sends one elementary message per DoRiS cycle.

ElemSend (s) =Δ  Shared.medium = {}
∧ Shared.chipTimer =0 
Δ
∧ let i	=	hardID (s)
flag =Δ	if SoftState[i ].list /= ⟨⟩ then 1 else 0
in ∧ Shared.chipCount = i
Δ
∧ let resSet = reservation(i )
in ∧ Shared ' = [Shared except !.macTimer = delta,
!.medium = {[id '→ i , type '→ “hard”,
res '→ resSet, softFlag '→ flag ]}]
∧ HardState' = [HardState except
![i ].cons[i ]= 1,
![i ].res = [j ∈ ServID '→
if j ∈ resSet then i else @[j ]]]
∧ SoftState'  = [SoftState except ![i ].token =
if flag =0 then − 1 else @]
∧ History' = [History except !.elem = @+ 1]

Fig. 3. The ElemSend action

Two others TLA+ constructs appear here. First, indentation is preferred instead of parenthesis.  Hence, the operators ∧ and ∨ are used to con- struct meaningful indented lists. Second, a TLA+ expression like SoftState' = [SoftState except ![i ].token = − 1] means that the record SoftState remains un- changed except for the entry i of its field token, which is set to −1.
As can be seen, the action ElemSend changes the values of the fields macTimer , medium, res and token of the Shared , SoftState and HardState variables (primed variables). macTimer assumes the value of δ, the time it takes to transmit a hard message and medium is filled with the elementary message sent by s. Such a message

piggybacks the sender identifier, its type, which can be either “hard” or “soft”, a reservation set, and the value of the softFlag that indicates whether s will participate of the next WS .
In the second “let ... in” construct, the reservation function is used to generate resSet , the reservation list of s, which indicates the slots s will be interested in for transmitting additional messages. Its definition depends on the needs of the server for extra-bandwidth. For simplicity, we assumed here that all servers try to reserve the maximum number of reservation slots. Recalling Section 2.2, a server can do so if it is in a consistent state (has received all previous nServ elementary messages) and the slots are still not reserved. If s is inconsistent, it is still allowed to carry out the reservation of SR of chip i in the next cycle as no other server could have reserved such a slot before. The reservation function is not shown here since it is related to the application layer.
The field cons of HardState[i ] is a tuple of flags that keeps track of the elemen- tary messages received by each server. The entry cons[j ] is set to 1 whenever an elementary message sent by server j is received by server i or when server i = j sends its elementary message. When an elementary message sent by j is omitted at server i , the corresponding entry of tuple HardState[i ].cons[j ] remains null, allowing for the detection of the failure. As will be seen, the action NextTick resets all values of cons[Shared.chipCount ] to 0.
Finally, the token counter is updated. This counter is used to define the rules of the soft communication as will be seen in Section 3.5. If flag equals 0, token is set to −1, as server s will not participate of the soft communication in the next cycle. The field res of HardState[i ] stores the reservation view of server i . Action ElemSend keeps res[j ] unchanged if no reservation is sent by i for slot j , otherwise it sets its value to i . The definition of HardState[i ].res makes use of the exception clause to state that res is only updated regarding entry i , according to resSet , the reservation set provided by the function reservation. In an exception clause, the @ symbol stands for the original value of the variable, which here is HardState[i ].res[j ].
The symbol '→ is used to assign values to the entries of a record. Here, all entries
j ∈ ServID of HardState'[i ].res are updated.
ReseSend − This action, shown in Figure 4, describes the emission of a reservation message. The two first enabling predicates ensure that the medium is idle and that SR has begun. Then, HardState[i ].res[Shared .chipCount ] = i states that server i has a reservation for the on-going chip. In such a case, macTimer is set to δ to represent the reservation message transmission time. Then, medium is filled with the reservation message, which piggybacks its sender identifier, its message type, and the special value {−1} as the reservation set. Since a reservation message cannot be used to make other reservations, such a message carries the
{−1} special value, which distinguishes it from an elementary message. Then, the sender reservation list is updated by setting the corresponding entry to -1. Finally, the unchanged operator lists the variables whose values are not updated by the action.
Receive − This action, shown in Figure 5, describes the reception of a mes-



ReseSend (s) =Δ
∧ Shared.medium = {}
∧ Shared.chipTimer = delta
Δ
∧ let i = hardID (s)
in ∧ HardState[i ].res[Shared .chipCount ]= i
∧ Shared ' = [Shared except
!.macTimer = delta,
!.medium = {[id '→ i , type '→ “hard”, res '→ { − 1}]}]
∧ HardState' = [j ∈ ServID '→ [HardState[j ] except
!.res[Shared .chipCount ]= − 1]]
∧ History' = [History except !.rese = @+ 1]
∧ unchanged SoftState

Fig. 4. The ReseSend action
sage. Recall from definition of the Next action (see Figure 2) that Receive is enabled if there is some message m in the medium. In such a case, when the transmission of m is completed (macTimer = 0), its reception can happen. According to the message type (“hard” or “soft”), either HardRecv or SoftRecv is enabled.

Receive(m) =Δ
∧ Shared.macTimer =0 
∧ case m.type	= “hard” → HardRecv (m)
  m.type	= “soft” → SoftRecv (m)

Fig. 5. The Receive action

HardRecv − This action, shown in Figure 6, describes the reception of a hard message. According to the information piggybacked on m, different updates of Shared are chosen by the construct “case ... → ... ”. When the res field differs from {−1}, it means that m is an elementary message. In such a case, the soft group is updated, according to the value of softFlag . If softFlag equals 1, the sender of m is added to the soft group indicating that this node has a soft message to transmit. Otherwise, softFlag equals 0, and the sender of m is deleted from the soft group. In this case, the tokenUpdate action, not shown here for the sake of space, is used to update the token accordingly.
Also HardState is updated to represent the reception of a message. The mod- eling of omission faults, specified by the NoRecvSet state function, is not detailed here since it has a simple semantics. For some message m, the set NoRecvSet (m) was defined has an arbitrary subset, possibly empty, of ServID . When an identifier i is an element of NoRecvSet (m), a reception failure of m occurs at server i and the variable HardState remains unchanged. Recall from action ElemSend (see Fig- ure 3) that cons is a tuple of the HardState variable, which is set to 1 whenever an elementary message is received. Hence, the omission failure of receiving a hard message sent by server m.id implies that cons[m.id ] is not set and server i turns



HardRecv (m) =Δ
∧ case m.res /= {− 1}∧ m.softFlag =1 
→ ∧ Shared ' = [Shared except !.medium = {}, !.soft =@ ∪ {m.id}]
∧ unchanged SoftState
	m.res /= {− 1}∧ m.softFlag =0 
→ ∧ Shared ' = [Shared except !.medium = {}, !.soft = @ \ {m.id }]
∧ tokenUpdate(m)
	m.res = {− 1}
→ ∧ Shared ' = [Shared except !.medium = {}]
∧ unchanged SoftState
∧ HardState' =
[i ∈ NoRecvSet (m) '→ HardState[i ]] @@
[i ∈ ServID \ NoRecvSet (m) '→ [HardState[i ] except
!.msg = Append (@, m),
!.execTimer = if Len(HardState[i ].msg )=0 then pi else @,
!.cons[m.id ]= if m.res /= {− 1} then 1 else @,
!.res = if m.res = {− 1}
then [j ∈ ServID '→ if j = m.id then − 1 else @[j ]]
else [j ∈ ServID '→ if j ∈ m.res then m.id else @[j ]]]]
∧ unchanged History

Fig. 6. The HardRecv action

to be inconsistent. Its reservation capacity is then limited (see Figure 3) and the server is not able to send soft message until it is consistent again, as will be show shown when describing Figure 7.
When server i is not in NoRecvSet (m), m is received normally and the various fields of HardState are updated. Message m then is appended to the msg list of incomming messages and the associated timer execTimer is set to the maximum processing time of m if it was not previously set. The entry m.id of cons is set to 1 to represent the successful reception of an elementary message and, finally, the res field is updated, according to the res set piggybacked on m.
As already mentioned, a hard message received by server i can either be an elementary or a reservation message. In the latter case (m.res = ResMsg{−1}), the reservation list regarding the message sender must be reset to −1, accounting for the use of the SR by the sender (m.src). Note that the tuple cons does not change since consistency is related to the reception of elementary messages only. Conversely, when receiving an elementary message, cons is reset and the reservation list is updated according to the list carried by the received message.

The Soft Ring
In the soft ring, the token rotation is based on the observation of the past communi- cation. Hence, the soft token is incremented either when a soft message is received or when a soft server is removed from the soft membership, as described in Figure 6.

SoftSend − This action, shown in Figure 7, describes the emission of a soft message. It gets enabled when the following four predicates hold: (i) a WS has begun; (ii) it has not finished yet; (iii) the medium is empty; and (iv) server s holds the token. This latter predicate appears in the IN clause of the “let ... in” construct, as it makes use of the identifier i of the soft component of server s, defined by the function softID (s, Shared.soft ).

SoftSend (s) =Δ  Shared.medium = {}
∧ 2 ∗ delta ≤ Shared.chipTimer ∧ Shared.chipTimer ≤ deltaChip
Δ
∧ let i	= softID (s, Shared.soft )

lenTX =Δ
d	=Δ
consis =Δ
wait	=Δ
noMsg =Δ
lenMsg (i )
Shared.chipTimer + lenTX
∀ j ∈ ServID : HardState[i ].cons[j ]=1 (d > deltaChip) ∨ (¬consis)
(i ∈ Failed ) ∨ wait

in ∧ i = SoftState[i ].token
∧ Shared ' = [Shared except
!.macTimer = if noMsg then Inﬁnity

else lenTX ,

!.medium = if noMsg then @ else {[id '→ i , type '→ “soft”]}]
∧ SoftState'	= [SoftState except
![i ].list = if wait then @ else tailList (@),
![i ].token = case wait → @
  ¬consis → − 1
  other → next (i , Shared.soft ),
![i ].count = if noMsg then @ else @+ 1]
∧ unchanged ⟨HardState, History⟩

Fig. 7. The SoftSend action

Whenever enabled, SoftSend sets lenTX , the transmission time of message msg that server s wants to send. Then, the local variable d is defined to be the current value of chipTimer plus lenTX . Three state predicates are defined: (i) consis, which is true when no elementary message omission failure has occurred at s in the previous cycle; (ii) wait , which is true when s has to wait for the next WS , either due to lack of time to send msg or because it is in an inconsistent state; (iii) noMsg , which is true either when wait is true or when i ∈ Failed , where Failed is a set of current crashed servers. This set, also not shown here, is defined as a function of the server identifiers and the value of chipCount .
Then the fields of Shared and SoftState are updated. If a message msg is sent, macTimer is set to lenTX and medium is filled with msg . Otherwise, macTimer is deactivated by setting it to infinity and medium remains unchanged.
As for SoftState, three fields are updated regarding server s whose identifier is i . If a message is not transmitted due to lack of time, the field list is kept unchanged. Otherwise, the sent message is deleted from the list by tailList . The fields token and count of SoftState[i ] also remain unchanged is no message is sent because of

lack of time. This means that i holds the right to transmit, waiting for the next WS . However, if server s is inconsistent, its token field is set to −1, meaning that s is not allowed to send message until it becomes consistent again. If a message is sent, the token is passed on to the next server in the ring. Similarly, count needs to be incremented only if a message is sent. This counter is used to avoid deadlock in the presence of omission failures, as will be clear in the next section.
The SoftRecv action is similar to the HardRecv and is omitted here. Upon reception of a soft message, server i updates the value of token and increments count .

Time representation
The Tick action, composed of NextTick and NextChip, deals with the protocol progress.
NextTick − This action, shown in Figure 8, regulates the passage of time. As mentioned in Section 3, time is specified as an integer entity. However, in order to minimize the generation of states during model-checking, the time increment d of a NextTick step is defined as the minimum time value needed to enable a protocol action. First, two conditions variables noRese and noSoft are defined. They represent scenarios where a SR begins and no server has a reservation for this slot (noRese) and a WS begins and no server has soft message to send (noSoft ). Then, the set tmp is defined as the union of the values of the execution timers associated to the processing of received messages by slow nodes, and the remaining time before the end of the current chip, i.e. deltaChip − chipTimer . Three cases must then be considered when defining d : (i) if noRese holds, d = min(delta, tmp);
(ii) if noSoft is true, d = tmp; otherwise (iii) d is the minimum of tmp and the time to receive the next message. Cases (i) and (iii) are necessary for avoiding deadlock conditions.
Once d is determined, the flow of time is represented by updating the value of all timers, operation that is carried out by the timerUpdate action of the “in” clause. As timerUpdate is a simple formula, it is omitted here. Since all the other actions are timed by at least one of these timers, this strategy is safe and efficient. Indeed, some model-checking experiments we carried out showed that this strategy can speed up the model-checking process significantly. This is because the time passes by quanta, stepping from an enabled action to the next, without exploring unnecessary states.
NextChip − This action, omitted here for the sake of space, is responsible for the transition between a chip and its successor. It is enabled when the medium is empty and when chipTimer has timed out (chipTimer = deltaChip ). In such a case, a chip has just finished and action NextChip resets the global counting-up timer chipTimer and increments chipCount modulo nServ . When the next chip belongs to a new cycle, cycleCount is incremented and the soft message list of each server is redefined. Note that the circular time structure of DoRiS is specified by this action through the use of these three fields, chipTimer , chipCount and cycleCount .



NextTick =Δ
Δ

let noRese
= ∧ Shared.medium = {}
∧ Shared.chipTimer = delta
∧ ∀ i ∈ ServID : HardState[i ].res[Shared .chipCount ] /= i

noSoft =Δ
∧ 2 ∗ delta ≤ Shared.chipTimer
∧ Shared.chipTimer ≤ deltaChip
∧ Shared.medium = {}
∧ ∀ j ∈ Shared.soft : SoftState[j ].token /= j

tmp =Δ
{HardState[i ].execTimer : i ∈ ServID}∪ 
{deltaChip − Shared.chipTimer}

d =Δ
case noRese → min({delta}∪ tmp)
   noSoft → min(tmp)
   other → min({Shared.macTimer}∪ tmp)

in ∧ d > 0
∧ timerUpdate(d, noRese, noSoft )
∧ unchanged ⟨SoftState, History⟩




Verification
Fig. 8. The NextTick action

In this section we comment on the running cost obtained by running the TLC model- checker [16] and on some relevant verified properties of the designed protocol.

Performance
In most of the TLC runs for the DoRiS specification, the execution time for some finite models was found to be reasonable, although no comparison was made with other tools. We have used a 2 Ghz Intel Core Duo processor using a java virtual machine with a 512M heap size. Three performance metrics were considered: CPU user time (U ); the total number of generated distinct states (N ); the diameter (D ) of the reachability graph. 6
# Servers
2	4	6	8	10	12	14
Table 1
TLC performance data for verifying the DoRiS specification.

6 This latter metric is the smallest number d such that every state in the reachability graph can be reached from an initial state by a path containing at most d states [10].

Table 1 illustrates the data obtained for some configurations as a function of the number of servers. As can be seen, verifying a model of DoRiS with 14 servers took about 4, 117 seconds to explore N = 9, 540 distinct states with reachability graph with diameter D = 9, 482. It must be noted that D is close to N for all configurations. Three aspects of the specification explain this good performance. First, all actions are guarded by temporal predicates, reducing the number of ex- plored states. Second, communication and fault scenarios were fixed for a given verification. Third, the time increment strategy adopted in the NextTick action (see Figure 8) reduced significantly the number of unnecessary states. Indeed, we compared this strategy with a naive one that increments time by a unit at each step. For a configuration with 6 servers, the naive strategy took 453 seconds to be verified with N = 21, 604 and D = 11, 261. Using 14 servers, no answer was returned by TLC after 20 hours of execution, indicating a rapid state explosion.
Veriﬁcation of DoRiS properties
The absence of deadlocks is automatically checked by TLC. On the other hand, type invariance are elementary properties to be specified. Instead of describing such basic properties, this section focus on those more related to the protocol func- tionalities. More specifically, the following relevant properties of the DoRiS protocol were verified: (i) the protocol provides communication isolation, avoiding collisions;
(ii) each task always sends an elementary message per cycle and no task’s buffer overflow occurs; (iii) the reservation mechanism is safe and correct; and (iv) soft communication fairness holds. What follows is the specification of these properties.



Send (s) =Δ
∨ ∧ s ∈ HardRing
∧ (enabled ElemSend (s) ∨ enabled ReseSend (s)))
∨ ∧ s ∈ SoftRing (Shared.soft )
∧ enabled SoftSend (s))

CollisionAvoidance =Δ
∀ s, t ∈ HardRing ∪ SoftRing (ServID ): 
 (enabled (Send (s) ∧ Send (t )) ⇒ (s = t ))

NoCollisionAvoidance =Δ
∃ s, t ∈ HardRing ∪ SoftRing (ServID ): 
 ((s /= t ) ∧ enabled (Send (s) ∧ Send (t )))



Fig. 9. CollisionAvoidance and NoCollisionAvoidance

CollisionAvoidance − This temporal formula, shown in Figure 9, is true when at most one task can send its message in a given slot. Thus, it ensures that the DoRiS protocol avoids the occurrence of message collision. It is worth mentioning that in order to produce behavioral traces for each checked property, we systematically ran the TLC model-checker twice per property. First, checking the formula and then its contraposition. The NoCollisionAvoidance temporal formula that appears in Figure 9 is the contraposition of predicate CollisionAvoidance.
HardRingCorrectnesss − In this formula, shown in Figure 10, we were

able to check some properties regarding the hard ring. First, it is checked that no buffer overflow occurs, as the size of the msg buffer is at most 3. In the second line, it is asserted that whenever NextChip takes place, the action SendElem has been executed Shared.chipCount times. It is worth noticing the use of an observer, namely History, which has a counter with elem as a field. This counter is reset at the beginning of every cycle and is incremented when the action SendElem is true. Thus, at the end of each chip, History.elem must be equal to Shared.chipCount if each task has sent its mandatory elementary messages. In other words, SendElem is periodically true. Recall that we specified omission failures in the reception action (see Figure 6). This implies that sending omission and crash failures were modeled. For instance, sending omission failure can be seen as reception failures at all nodes and crash failures are permanent sending omission failures. Therefore, it was not necessary to check specific scenarios of message sending omission nor task crash failures.

HardRingCorrectness =Δ
∧ ∀ s ∈ HardRing :  (Len(HardState[hardID (s)].msg ) ≤ 3)
∧  (enabled NextChip ⇒ History.elem = Shared.chipCount )
ReservationSafety =Δ
 ∀ chip, j ∈ ServID : ∧ enabled ReseSend (HardServ [j ])
∧ Shared.chipCount = chip
⇒ ∧ HardState[j ].res[chip]= j )
∧ (∀ i ∈ ServID \ {j } : HardState[i ].res[chip] ∈ {j , − 1})
SoftRingFairness =Δ
∧ ∀ i ∈ ServID :  (i ∈ Shared.soft
⇒ (SoftState[i ].list /= ⟨⟩ ⇒  (i = SoftState[i ].token)))
∧  (∀ i ∈ ServID \ Failed : i ∈ Shared.soft ⇒ Len(SoftState[i ].list )= 0)

Fig. 10. HardRingCorrectness, ReservationSafety and SoftRingFairness

ReservationSafety − This property, shown in Figure 10, asserts that when task j has a reservation for some SR , all other tasks are aware either of this reservation or that they have not reserved such a slot. It implies that two tasks cannot own a reservation for the same slot. Along with the enabling predicate HardState[i ].res[Shared .chipCount ] = i of the ReseSend action, the specification also implies that task i can only send a reservation message in a SR that it has previously reserved.
SoftRingFairness − This property, shown in Figure 10, asserts that all processes will eventually receive the token (first line), and that its list of messages will eventually be exhausted. Should the list of messages of all processes in a cycle exceed the available bandwidth capacity for the soft communication, TLC indicates out the violation of the second line of the formula, as expected.
As can be seen, we were able to verify relevant properties of the DoRiS protocol. It is interesting to note that this properties were verified taking into consideration

omission and crash failures.

Discussion
After the protocol was conceived [15], its formal specification was derived. This for- mer version relied on some specific hardware functionalities. For example, the soft ring management was based on the capacity of the medium activity to be sensed at any given time. Sensing idle periods on the medium was used to implement an implicit token-passing scheme like in other protocols [2]. However, it was noticed afterward that Ethernet network cards, providing such sensing capability, were not easily available. Also, this approach would prevent extensions of the protocol for wireless medium. Then, the specification was updated so that the token-passing scheme would require that explicit messages be sent even when there is no applica- tion message to transmitted. By model-checking this new version of DoRiS , it was noticed the high overhead of this token management scheme before the implementa- tion phase. Indeed, this solution implied too many message receiving events. This motivated the protocol specification described here, which has an adaptive token management scheme.
Another aspect worth mentioning is related to the verification of fault scenarios. Fault occurrences were incorporated into the specification in incremental steps. This required the introduction of extra counters and predicates. However, due to the nature of the TLA+ language, fault scenarios were specified and verified straightforwardly.
Although the protocol specification has given several insights to carry out its implementation, it was not possible to use the specification straightway. Indeed, DoRiS was implemented in a Linux-based real-time operating system [14] which has itself a complex architecture. However, most functions of the protocol could be translated from the specification and adapted into the operating system infrastruc- ture.

Conclusions
A TLA+ specification of DoRiS , a new real-time communication protocol, have been shown in this paper. DoRiS is designed for modern real-time systems, which require predictability, fault tolerance and flexibility. The specification and its properties were checked for several different scenarios. For this purpose, the TLA+ language was found to provide satisfactory levels of abstraction and expressiveness.
¿From a software engineering perspective, the approach used to define DoRiS has shown how one can benefit from formal methods. Indeed, using the TLA+ lan- guage and its tools, we have carried out an interactive design methodology, where specification and model-checking were performed during the definition of the pro- tocol functions. The implementation of DoRiS has been greatly improved by the specification presented here, indicating the strength of the adopted approach.
One aspect that needs further research is regarding how one carries out the im-

plementation of a specified protocol using an existing complex software, such an operating system, as a basic infra-structure. A more automatic way for perform- ing such a task is needed. The development of DoRiS and its described formal specification can well serve as a motivating case study for this field of research.

References
Barboza, F., A. Andrade, F. A. Silva and G. Lima, Specification and verification of the IEEE 802.11 medium access control and an analysis of its applicability to realtime systems, In Proc of BSFM 1 (2006), 9-26.
Carreiro, F. B., J. A. Fonseca and P. Pedreiras, Virtual Token-Passing Ethernet - VTPE, In Proc. FeT2003 5th IFAC Int. Conf. on Fieldbus Systems and their Applications (2003), Portugal.
Clarke, E. M., 0. Grumberg and D. Peled, “Model Checking”, MIT Press, 1999.
Decotignie, J.-D., Ethernet-based real-time and industrial communications, Proc. IEEE (Special issue on industrial communication systems) 6 (2005), 1102-1117.
Hanssen, F., A. Mader and P. G. Jansen, Verifying the distributed real-time network protocol RTnet using UPPAAL, Proc. IEEE of 14th Int. Symp. on Modeling, Analysis and Simulation of Computer and Telecom (2006).
Hanssen, F. T. Y. and P. G. Jansen, “Real-time communication protocols: an overview”, Technical Report TR-CTIT-03-49, University of Twente, 2003.
Henzinger, T., Z. Mannav and A. Pnueli,Temporal proof methodologies for realtime systems, In Proc. of the 18th Annual Symposium on Principles of Programming Languages, ACM Press (1992), 353-366.
IEEE, “Information Technology - Telecommunications and Information exchange between systems - Local and Metropolitan Area Networks specific requirements - part 3: Carrier Sense Multiple Access with Collision Detection (CSMA/CD) access and method Physical Layer Specifications, ISO/IEC 8802- 3”, 2001.
Johnson, J. E., D. E. Langworthy, L. Lamport and F. H. Vogt, Formal specification of a web services protocol, In Proc. of Web Services and Formal Methods (2004), Pisa, Italy.
Lamport, L., “Specifying Systems: The TLA+ language and tools for hardware and software engineers”, 1st edition, Addison Wesley, 2002.
Lamport, L. and M. Melliar-Smith, Real-time model checking is really simple. In Borrione, I. D. and Paul, W. J., editors, Correct Hardware Design and Verification Methods, LNCS 3725 (2005), 162-175.
Marau R., L. Almeida and P. Pedreiras, Enhancing Real-Time Communication over COTS Ethernet switches, Proc. IEEE of International Workshop on Factory Communication Systems (2006), 295-302.
Narayana, P., R. Chen, Y. Zhao, Y. Chen, Z. Fu and H. Zhou, Automatic Vulnerability Checking of IEEE 802.16WiMAX Protocols through TLA+, In Proc. of 2nd IEEE Workshop on Secure Network Protocols (2006).
Regnier, P. “Especifica¸c˜ao formal, verifica¸c˜ao e implementa¸c˜ao de um protocolo de comunica¸c˜ao determinista baseado em ethernet”, Master’s thesis, UFBA, Salvador, Brasil, 2008.
Regnier, P. and G. Lima, Deterministic integration of hard and soft real-time communication over shared-ethernet. In Proc. of Workshop of Tempo Real (2006), Curit´ıba, Brazil.
Yu, Y., P. Manolios and L. Lamport, Model checking TLA+ specifications. Proc. of the 10th IFIP WG
10.5 Advanced Research Working Conference on Correct Hardware Design and Verification Methods, LNCS (1999) 1703, 54-66
