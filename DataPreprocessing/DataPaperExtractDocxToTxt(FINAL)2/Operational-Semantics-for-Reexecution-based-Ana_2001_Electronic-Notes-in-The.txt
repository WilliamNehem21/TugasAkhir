Electronic Notes in Theoretical Computer Science 48 (2001)
URL: http://www.elsevier.nl/locate/entcs/volume48.html pp. 1 – 16



Operational Semantics for Reexecution-based Analysis of Logic Programs with
Delay Declarations

Agostino Cortesi 1,2 Sabina Rossi 1,3
Dipartimento di Informatica Universit`a Ca’ Foscari di Venezia Mestre–Venezia, Italy
Baudouin Le Charlier 4
Institut d’Informatique
Facult`es Universitaires Notre-Dame de la Paix Namur, Belgium


Abstract
We draw concrete and abstract operational semantics towards the analysis of logic programs with delay declarations. This is the basis to generalize the abstract in- terpreter GAIA to deal with logic programs employing dynamic scheduling. The concrete and abstract semantics are introduced explicitly and express both deadlock information and qualified answers. Sure deadlock and sure no deadlock information might be eventually inferred by the resulting analysis.


Introduction
Most of the logic programming languages in use (e.g., SICStus Prolog [10], Prolog-III, CHIP, SEPIA, etc.) do not force the user to follow the Prolog left-to-right scheduling rule; instead, in order to gain efficiency, they provide dynamic scheduling: atom calls are delayed until their arguments are suffi- ciently instantiated, and procedures are augmented with delay declarations. The analysis of logic programs with dynamic scheduling was first investigated

1 Partially supported by the Italian MURST with the National Reserch Project “Certifi- cazione automatica di programmi mediante interpretazione astratta”.
2 Email:cortesi@dsi.unive.it
3 Email:srossi@dsi.unive.it
4 Email:ble@info.fundp.ac.be
◯c 2001 Published by Elsevier Science B. V. Open access under CC BY-NC-ND license.


by Marriott et al. in [15,9]. A more general (denotational) semantics of this class of programs, extended to the general case of CLP, has been presented by Falaschi et al. in [8], while verification and termination issues have been investigated by Apt and Luitjes in [2] and by Marchiori and Teusink in [14], respectively.
In this paper, we discuss an alternative, strictly operational approach to the definition of concrete and abstract semantics for logic programs with delay declarations.
The main intuitions behind our proposal can be summarized as follows:
to define in a uniform way concrete, collecting, and abstract semantics, in the spirit of [11]: this allows us to easily derive correctness proofs of the whole analyses;
to define the analysis as an extension of the framework depicted in [11]: this allows us to reuse existing code for program analysis, with minimal additional effort;
to explicitly derive deadlock information (definite deadlock, possible dead- lock, deadlock freeness), producing as a result of the analysis an approxi- mation of concrete qualified answers;
to apply the reexecution technique developed in [12], that plays a crucial role here: at each step, an atom a whose delay declaration is satisfied by the activation substitution is executed; if its computation fully succeeds, some of the delayed atoms may be awakened by the resulting answer substitutions; if this is not the case (i.e., if during the computation of a a sequence of atoms, such that each of them do not satisfies the corresponding delay declaration, is reached), then atom a is added to the list of delayed atoms that will be reconsidered during the next reexecution step. This strategy allows us to avoid call state explosions.
The main difference between our approach and the ones already presented in literature is that we are mainly focused on analysis issues, in particular on deadlock analysis. This motivates the choice of a strictly operational approach, where deadlock information is explicitly maintained.
This paper illustrates the crucial steps toward the definition and imple- mentation of an extension of the GAIA abstract interpreter [11] to deal with dynamic scheduling. It mainly focuses on the (concrete and abstract) seman- tics, and we believe that this work, even though it can be clearly considered to be just in the preliminaries of the picture above, represents in itself a valuable contribution.
The rest of the paper is organized as follows. Section 2 recalls basic notions about logic programs with delay declarations. Section 3 depicts the concrete semantics transition rules. Section 4 sketches the main features of the col- lecting and abstract semantics, and discusses our generic fixpoint algorithm. Section 5 concludes the paper.

Logic Programs with Delay Declarations
Logic programs with delay declarations consist of two parts: a logic program and a set of delay declarations, one for each of its predicate symbols.
A delay declaration associated for an n-ary predicate symbol p has the form
DELAY p(x1,..., xn) UNTIL Cond (x1,..., xn)
where Cond (x1,..., xn) is a formula in some assertion language. We are not concerned here with the syntax of this language since it is irrelevant for our purposes. The meaning of such a delay declaration is that an atom p(t1,..., tn) can be selected in a query only if the condition Cond (t1,..., tn) is satisfied. In this case we say that the atom p(t1,..., tn) satisfies its delay declaration.
A derivation ξ of a program augmented with delay declarations can be finite or infinite. Let ξ be finite. We say that ξ succeeds if it ends with the empty goal; ξ fails if it ends with a non-empty goal the selected atom of which satisfies its delay declaration but does not unify with the head of any clause in the program; ξ deadlocks if it ends with a non-empty goal no atom of which satisfies its delay declaration. A finite non-failing derivation ξ of a program with delay declarations computes a qualified answer which is a pair
⟨θ, d⟩ where d is the last goal (that is a sequence of delayed atoms) and θ is the substitution obtained by concatenating the computed mgu’s from the initial goal. Notice that if ξ is successful then d is the empty goal and θ restricted to the variables of the initial goal is its computed answer substitution. We denote by qansP (g) the set of qualified answers for a goal g and a program P . We restrict our attention to delay declarations which are closed under instantiation, i.e., if an atom satisfies its delay declaration then also all its instances do. Notice that this is the choice of most of the logic programming systems dealing with delay declarations such as IC-Prolog, NU-Prolog, Prolog-
II, Sicstus-Prolog, Prolog-III, CHIP, Prolog M, SEPIA, etc.
Example 2.1 Consider the programs APPEND and IN ORDER defined below
% append(Xs,Ys,Zs) ← Zs is the result of concatenating the lists Xs and Ys append([H|Xs],Ys,[H|Zs]) ← append(Xs,Ys,Zs).
append([],Ys,Ys).
% in order(Tree,List) ← List is an ordered list of the nodes of Tree in order(tree(Label,Left,Right),Xs) ← in order(Left,Ls),
in order(Right,Rs), append(Ls,[Label|Rs],Xs). in order(void,[]).
together with the query
Q := read tree(Tree), in order(Tree,List), write list(List).
where the predicates read tree and write list are defined elsewhere in the

program. If read tree cannot read the whole tree at once it would be nice to be able to run in order and write list on the available input. This can only be done if one uses a dynamic selection rule (Prolog’s rule would call in order only when read tree had finished, while other fixed rules would immediately diverge). In order to avoid nontermination one should adopt appropriate delay declarations, namely,
DELAY in order(T, ) UNTIL nonvar(T). DELAY append(Ls, , ) UNTIL nonvar(Ls). DELAY write list(Ls, ) UNTIL nonvar(Ls).
These declarations avoid that in order, append and write list be selected “too early”. Notice that with these declarations IN ORDER enjoys a parallel execution by means of interleaving.
Under the assumption that delay declarations are closed under instanti- ation, the following result, which is a variant of Theorem 4 in Yelick and Zachary [18], holds.
Theorem 2.2 Let P be a program augmented with delay declarations, g be a goal and g' be a permutation of g. Then qansP (g) and qansP (g') are equals modulo the ordering of delayed atoms.
It follows that both successful and deadlocked derivations are “indepen- dent” from the choice of the selection rule. Moreover, Theorem 2.2 allows us to treat goals as multisets instead of sequences of atoms.
Concrete Semantics
In this section we describe a concrete semantics for pure Prolog augmented with delay declarations. The concrete semantics is the link between the stan- dard semantics of the language and the abstract one.
We assume a preliminary knowledge of logic programming (see, [1,13]).
Programs are assumed to be normalized according to the abstract syntax given in Fig. 1. The variables occurring in a literal are distinct; distinct procedures have distinct names; all clauses of a procedure have exactly the same head; if a clause uses m different program variables, these variables are e x1,..., xm.
If g := a1,..., an we denote by g \ ai the goal g' := a1,..., ai−1, ai+1,..., an.
Basic Semantic Domains
The basic semantic domains of substitutions are defined as follows.
We assume the existence of two disjoint and infinite sets of variables, de- noted by PV and SV . Elements of PV are called program variables and are denoted by x1, x2, ..., xi, .... The set PV is totally ordered; xi is the i-th element of PV . Elements of SV are called standard variables and are denoted


Fig. 1. Abstract Syntax of Normalized Programs

by letters y and z (possibly subscripted). Terms are built using standard variables only.
Standard substitutions are substitutions in the usual sense [1,13] which use standard variables only. The set of standard substitutions is denoted by SS . Renamings are standard substitutions that define a permutation of standard variables. The domain and the codomain of a standard substitution σ are denoted by dom(σ) and codom(σ), respectively. We denote by mgu(t1, t2) the set of standard substitutions that are a most general unifier of terms t1 and t2.
A program substitution is a set {xi1 /t1,..., xin/tn}, where xi1 ,..., xin are distinct program variables and t1, ..., tn are terms. Program substitutions are not substitutions in the usual sense; they are best understood as a form of program store which expresses the state of the computation at a given program point. It is meaningless to compose them as usual substitutions or to use them to express most general unifiers. The domain of a program substitution θ = {xi1 /t1,..., xin/tn}, denoted by dom(θ), is the set of pro- gram variables {xi1 ,..., xin}. The codomain of θ, denoted by codom(θ), is the set of standard variables occurring in t1,..., tn. Program and standard substitutions cannot be composed. Instead, standard substitutions are ap- plied to program substitutions. The application of a standard substitution σ to a program substitution θ = {xi1 /t1,..., xin/tn} is the program substitution θσ = {xi1 /t1σ, ..., xin/tnσ}. The set of program substitutions is denoted by PS . The application xiθ of a program substitution θ to a program variable xi is defined only if xi ∈ dom(θ); it denotes the term bound to xi in θ. Let D be

a finite subset of PV and θ be a program substitution such that D ⊆ dom(θ). The restriction of θ to D, denoted by θ/D, is the program substitution such that dom(θ/D)= D and xi(θ/D)= xiθ, for all xi ∈ D. We denote by PSD the set of program substitutions whose domain is D.
We consider also the possible states that an output state may enjoy with respect to deadlock. An atom in the body of a clause may belong to three (successive) states: non-activable (when its activation substitution does not satisfies its delay declaration), or reexecutable (when its activation substitu- tion satisfies its delay declaration, but in its derivation tree a deadlock is en- countered that forces the atom to be reconsidered afterwards), or executable. Of course, its computation may get stuck at each stage, giving raise to a dead- lock detection. We represent the deadlock information explicitly, by means of a deadlock state. A deadlock state is an element in the set {δ, ν}, where δ de- notes definite deadlock, and ν denotes no deadlock. This set will be extended in the collecting (and abstract) semantics by introducing an additional state µ (standing for may deadlock).



Concrete Behaviors
The notion of concrete behavior provides a mathematical model for the in- put/output behavior of programs. To simplify the presentation, we do not parameterize the semantics with respect to programs. Instead, we assume given a fixed underlying program P augmented with delay declarations.
We define a concrete behavior as a relation from input states to output states as defined below. The input states have the form
⟨θ, p⟩, where p is the name of a procedure and θ is a program substitu- tion also called activation substitution. Moreover, θ ∈ PS{x1,...,xn}, where x1,..., xn are the variables occurring in the head of every clause of p.
The output states have the form

⟨θ', κ⟩, where θ' ∈ PS{x ,...,x
} and κ is a deadlock state, i.e., κ ∈ {δ, ν}. In

1	n
case of no deadlock (i.e., κ = ν) θ' restricted to the variables {x1,..., xn}
is a computed answer substitution (the one corresponding to a successful derivation), while in case of definite deadlock (i.e., κ = δ) θ' is the substi- tution part of a qualified answer to p and coincides with a partial answer substitution for it.
We use the relation symbol −→ to represent concrete behaviors, i.e., we write ⟨θ, p⟩ '−→ ⟨θ', κ⟩: this notation emphasizes the similarities between this concrete semantics and the structural operational semantics for logic programs defined in [12]. Concrete behaviors are intended to model finite non-failing derivations of atomic queries.

Concrete Semantics Rules

The concrete semantics of an underlying program P with delay declarations is the least fixpoint of a continuous transformation on the set of concrete behaviors. This transformation is defined in terms of ten semantic rules that naturally extend concrete behaviors in order to deal with clauses and atoms.
In particular, a concrete behavior is extended through intermediate states of the form ⟨θ, c⟩ and ⟨θ, g, g¯⟩, where c is a clause and g, g¯ are subsets of a body of a clause of P , in such a way that
each pair ⟨θ, c⟩, where c is a clause, θ ∈ PS{x1,...,xn} and x1,..., xn are the variables occurring in the head of c, is related to an output state ⟨θ', κ⟩, where θ' ∈ PS{x1,...,xn} and κ ∈ {δ, ν} is a deadlock state;
each triplet ⟨θ, g, g¯⟩, where g is a set of atoms not considered yet or whose activation state does not satisfy the delay declaration, g¯ is a set of delayed atoms that have been recognized to be reexecutable, θ ∈ PS{x1,...,xm} and x1,..., xm are the variables occurring in (g, g¯), is related to an output state
⟨θ', κ⟩, where θ' ∈ PS{x1,...,xm} and κ ∈ {δ, ν} is a deadlock state;
We briefly recall here the concrete operations which are used in the defi- nition of the concrete semantics. The reader may refer to [11] for a complete description of all operations but the last two, DELAY and EQUIV, that are brand new.
EXTC is used at clause entry: it extends a substitution on the set of variables occurring in the body of the clause.
RESTRC is used at clause exit: it restricts a substitution on the set of variables occurring in the head of the clause.
RETRG is used when a literal l occurring in the body of a clause is analyzed. Let {xi1 ,..., xin} be the set of variables occurring in l. This operation expresses a substitution in terms of the formal parameters x1,..., xn.
EXTG it is used to combine the analysis of a built-in or a procedure call (ex- pressed in terms of parameters x1,..., xn) with the activating substitution.
UNIF-FUNC and UNIF-VAR are the operations that actually perform the unifi- cation of equations of the form xi = xj or xi1 = f (xi2 ,..., xin ), respectively.
DELAY is the operation that verifies whether the delay declaration associated to an atom is satisfied or not. Let a be an atom in the body of a clause c, D be the set of all the variables occurring in c and θ ∈ PSD. DELAY(a, θ) is true if aθ does not satisfy its delay declaration, false otherwise.
EQUIV is used to verify whether two program substitutions with the same domain are equal modulo renaming of range variables.
The concrete semantic rules are depicted in Fig. 2. The definition proceeds by induction on the syntactic structure of P . The semantics of a program P with delay declarations can be defined as a fixpoint of this transition system.

Rule R1 defines the result of executing a procedure call. This is obtained by executing any clause defining it.
Rule R2 defines the result of executing a clause. This is obtained by exe- cuting its body under the same activation substitution. Notice that, at the beginning, all literals in the body of the clause have to be considered and there are no delayed atoms (i.e., g is the body of c and g¯ is the empty goal denoted by < >).
Rules R3 and R4 specify the execution of built-ins: the usual unification operations are applied. Notice that built-ins can only occur in the g part of the goal, i.e., the subset of literals in the current goal that have not been considered yet.
Rules R5 and R6 define the execution of an atom a in the case that a has not yet been considered and the activation substitution θ satisfies the corresponding delay declaration. The first rule applies when the execution of a is deadlock free. The second rule applies when the execution of a with the current activation substitution falls into deadlock: in this case, a is moved in the delayed atoms list, waiting for a reexecution step.
Rules R7 and R8 are the reexecution rules. Atoms that have been delayed and that might be executable without falling into deadlock now are recon- sidered. Notice that, by the assumption that delay declarations are closed under instantiation, we do not need to check whether an atom in the delayed list verifies its delay declaration, as the activation substitution is possibly more instantiated now. Operation EQUIV in rule R8 guarantees that only atoms whose reexecution produces a more instantiated result are allowed to be reexecuted.
Rule R9 defines a deadlock situation: the activation substitution θ satisfies none of the delay declarations of atoms in g, and all atoms in g¯ deadlock.
Rule R10 defines the result of executing the empty goal, generating a suc- cessful output substitution.

Collecting and Abstract Semantics
In this section we briefly describe how to define abstract semantics for logic programs with delay declarations that are based on the concrete semantics defined in the previous section.
As usual in the Abstract Interpretation literature [6,7], we proceed in three steps. First, we depict a collecting semantics, by lifting the concrete seman- tics to deal with sets of substitutions. Then, any abstract semantics will be defined as an abstraction of the collecting semantics: it is sufficient to provide an abstract domain that enjoys a Galois connection with the concrete domain
℘(Subst), and a suite of abstract operations that safely approximate the con- crete ones. Finally, we draw an algorithm to compute a (post-)fixpoint of an





a is a literal of g g' := g \ a
a := p(xi1 ,..., xin )
¬DELAY(a, θ)
θ1 = RESTRG(a, θ)
(θ1, p⟩ '—→ (θ2,ν⟩ θ3 = EXTG(a, θ, θ2)
(θ3, g', g¯⟩ '—→ (θ', κ⟩
R5		
(θ, g, g¯⟩ '—→ (θ', κ⟩
a is a literal of g g' := g \ a
a := p(xi1 ,..., xin )
¬DELAY(a, θ)
θ1 = RESTRG(a, θ)
(θ1, p⟩ '—→ (θ2, δ⟩ θ3 = EXTG(a, θ, θ2)
(θ3, g', g¯ ∪ {a}⟩ —→ (θ', κ⟩
R6		
(θ, g, g¯⟩ '—→ (θ', κ⟩






g := a1,..., an and ∇ai : DELAY(ai, θ); g¯ := a¯1,..., a¯m and ∇a¯j :
8> a¯j := p(xi1 ,..., xin )
>< θ1 = RESTRG(a¯j , θ)

(θ1, p⟩ '—→ (θ2, δ⟩
>: EQUIV(θ1, θ2)
R9		
(θ, g, g¯⟩ '—→ (θ, δ⟩



R10		
(θ, < >, < >⟩ '—→ (θ, ν⟩

Fig. 2. Concrete Semantic Rules

abstract semantics defined this way. This third step gives the developers the key ideas on how to implement a practical analyser, and can be actually seen as an extension of GAIA [11].
In the rest of the section we describe the main features of these steps.

Collecting Semantics
In the case of logic programs with delay declarations, the collecting semantics cannot be obtained trivially from the concrete one. Fig. 3 contains its rules, whose main differences can be summarized by:
an additional deadlock state µ (may deadlock) is introduced, therefore in all rules κ ∈ {δ, ν, µ};
an additional transition rule '→' is introduced to compute qualified answers even when the µ deadlock state is reached, i.e., when precision about dead- lock is definitely lost. If this is the case, the computation may continue exactly as in the GAIA framework, by completely disregarding the dead- lock information, that will be stationary.
Let us try to briefly motivate these features. Rules R5, R6 and R9 of the concrete semantics require precision when dealing with delay declarations. It is clear that these rules have to be properly extended in order to deal with sets of substitutions whose elements may have opposite behavior with respect to the same declaration. This situation is tackled by rules R10 and R11, the only ones that, in fact, may produce and propagate, respectively, the new deadlock state µ. Rule R10 applies when there are no literals in g which are surely selectable, i.e., there not exist some a ∈ g such that for all θ ∈ Θ:
¬DELAY(a, θ), but for some literal a in g (the literals that have not to be reconsidered), there exists θ1, θ2 such that DELAY(a, θ1) ∧ ¬DELAY(a, θ2). Rule R11 behave the same way, but it applies when imprecision arises during the inner computation of a literal. Finally, observe that rules R10 and R11 force the reexecution of the analysis of some literals, in order to improve the precision of the whole analysis. This is achieved through the use of the auxiliary transition rule −→'.

From the Collecting to the Abstract Semantics
Once the collecting semantics is fixed, deriving abstract semantics is almost an easy job.
Any domain abstracting substitutions can be used to describe abstract ac- tivation states. Similarly to the concrete case, we distinguish among input states and output states. Clearly, the accuracy of deadlock analysis will depend on the matching between delay declarations and the information represented by the abstract domains.
It is easy to understand, by looking at the collecting semantics defined above, that very few additional operations should be implemented on an abstract substitution domain like the ones in [11,4,5], while a great amount of existing specification and coding can be reused for free.
At each step, in the abstract semantics, only an atom in the goals that surely satisfies the corresponding delay declarations is selected. If the empty






c is a clause defining p
(Θ, c⟩ '—→ (Θ', κ⟩
R1		
(Θ, p⟩ '—→ (Θ', κ⟩
c := h : —g
Θ1 = EXTC(c, Θ)
(Θ1, g,< >⟩ '—→ (Θ2, κ⟩
Θ' = RESTRC(c, Θ2)
R2		
(Θ, c⟩ '—→ (Θ', κ⟩



b := xi = xj g' := g \ b
Θ1 = RESTRG(b, Θ) Θ2 = UNIF VAR(Θ1) Θ3 = EXTG(b, Θ, Θ2)
(Θ3, g', g¯⟩ '—→ (Θ', κ⟩
b := xi = f (xi1 ,..., xin ) g' := g \ b
Θ1 = RESTRG(b, Θ) Θ2 = UNIF FUNC(b, Θ1) Θ3 = EXTG(b, Θ, Θ2)
(Θ3, g', g¯⟩ '—→ (Θ', κ⟩




∇a ∈ g and ∇θ ∈ Θ: DELAY(a, θ)
8> a¯ := p(xi1 ,..., xin )
Θ1 = RESTRG(a¯, Θ)

8 a¯ := p(xi1 ,..., xin )
Θ1 = RESTRG(a¯, Θ)
∇a¯ ∈ g¯: >< (Θ1, p⟩ '—→ (Θ2, κ⟩
κ /= ν

∇a¯ ∈ g¯: <>
(Θ , p⟩ '—→ (Θ , δ⟩
EQUIV(Θ , Θ )

>	1	2	>:	1  2

>:> EQUIV(Θ1, Θ2)
R9		
(Θ, g, g¯⟩ '—→ (Θ, δ⟩
(Θ, (g, g¯)⟩ '—→' Θ'
R10		
(Θ, g, g¯⟩ '—→ (Θ', µ⟩



∇a ∈ g, ∃θ ∈ Θ: DELAY(a, θ)
8> a¯ := p(xi1 ,..., xin )
Θ1 = RESTRG(a¯, Θ)
∇a¯ ∈ g¯: < (Θ1, p⟩ '—→ (Θ2, κ⟩
κ /= ν
>: EQUIV(Θ1, Θ2)
∃a¯ ∈ g¯: (Θ1, p⟩ '—→ (Θ2, µ⟩
(Θ, (g, g¯)⟩ '—→' Θ'
R11		
(Θ, g, g¯⟩ '—→ (Θ', µ⟩












R12		
(Θ,< >,< >⟩ '—→ (Θ,ν⟩





Y15		
(Θ,< >⟩ '—→' Θ
(Θ3, g'⟩ '—→' Θ'
Y16		
(Θ, g⟩ '—→' Θ'

Fig. 3. Collecting Semantic Rules
goal is reached, then the interpretation stops and returns an abstraction of the corresponding concrete qualified answers together with no deadlock infor- mation. Otherwise, a goal of the form (g, g) is reached, where for all atoms a occurring in g, the activation substitutions (possibly) does not satisfy its de- lay declaration, and for all atoms a occurring in g, a reexecution process may not refine the corresponding activation substitution. If the abstract domain is accurate enough to infer that a definite deadlock occurs, then the execu- tion ends and returns an abstraction of concrete qualified answers together with definite deadlock information. If this is not the case, then the abstract computation continues by disregarding the deadlock information. In particu- lar, atoms whose activation substitution may satisfy the corresponding delay declaration are selected. In this way we improve the computed abstraction of the corresponding concrete qualified answers while we return the information that the concrete computation may deadlock.

The Fixpoint Algorithm
Fig. 4 reports the final step in the Abstract Interpretation picture described above: an algorithm that computes a post-fixpoint of a given abstract seman- tics that abstracts the collecting one.
As already observed before, most of the operations that are used in the algorithm are simply inherited from the GAIA framework [11]. The only exception is DELAY, the satisfiability test of a delay declaration by an ab- stract substitution, whose specification as three-value function is as follows: DELAY(a, β) is true if for all θ described by β, DELAY(a, θ) is true; DELAY(a, β) is false if for all θ described by β, DELAY(a, θ) is false; otherwise, DELAY(a, β) is maybe.
The operator T (β, g, sat ) in Fig. 4 is defined exactly as Tb in [11] and corresponds to the auxiliary rules of the collecting semantics defining −→'.


TAB (sat )= {(β, p, ⟨β', κ⟩): (β, p) is an input state and ⟨β', κ⟩ = Tp(β, p, sat )}.
Tp(β, p, sat )= UNION(⟨β1, κ1⟩ ..., ⟨βn, κn⟩)
where ⟨βi, κi⟩ = Tc(β, ci, sat ),
c1,..., cn are the clauses defining p.
Tc(β, c, sat )= ⟨RESTRC(c, β'), κ⟩
where ⟨β', κ⟩ = Tb(EXTC(c, β), b,< >, sat ),
b is the body of c.
Tb(β, < >, < >, sat )= ⟨β, ν⟩.
Tb(β, l.g, g¯, sat )= Tb(β3, g, g¯, sat )	if l is a built-in
where  β3 = EXTG(l, β, β2),
β2 = UNIF VAR(β1)	if l is xi = xj ,
UNIF FUNC(l, β1)	if l is xi = f (·· ·),
β1 = RESTRG(l, β).
Tb(β, l.g, g¯, sat ) = Tb(β3, g, g¯, sat )	if l is p(·· ·) and DELAY(l, β)= false and κ = ν Tb(β3, g, l.g¯, sat )	if l is p(·· ·) and DELAY(l, β)= false and κ /= ν
where  β3 = EXTG(l, β, β2),
⟨β2, κ⟩ = sat (β1, p),
β1 = RESTRG(l, β).
Tb(β, g, l.g¯, sat )= Tb(β3, g, g¯, sat )	if l is p(·· ·) and DELAY(l, β) ∈ {true, maybe} and κ = ν

Tb(β3, g, l.g¯, sat )	if l is p(·· ·) and DELAY(l, β) ∈ {true, maybe} and κ =/
where  β3 = EXTG(l, β, β2),
⟨β2, κ⟩ = sat (β1, p)
β1 = RESTRG(l, β).
Tb(β, g, g¯, sat )=	⟨β, δ⟩	if SUSPEND(β, g, g¯)
⟨T (β, (g.g¯), sat ), µ⟩ otherwise.
SUSPEND(β, g, g¯)= true	if ∀a ∈ g: DELAY(a, β) and ∀a¯ ∈ g¯: β1 = β2 where	l is p(·· ·),
⟨β2, δ⟩ = sat (β1, p),
β1 = RESTRG(a, β),
false	if none of the above cases applies.


Fig. 4. The abstract transformation
ν, β1 =/ β2

The correctness of the algorithm in Fig. 4 can be proven the same way as in
[11] and [12]. What about termination ? We may observe that in the collecting semantics the reexecution rule R8 may introduce infinite loops. However, this problem does not arise in the abstract semantics as
the abstract domain is required to be a complete lattice (when this is not the case, and it is just a cpo, an additional widening operation is usually provided by the domain),
the derivation −→ produces a decreasing chain in its first argument.
Example 4.1 Consider the program PERMUTE discussed by Naish in [16].
% perm(Xs,Ys) ← Ys is a permutation of the lists Xs perm(Xs,Ys) ← Xs = [ ],
Ys = [ ].
perm(Xs,Ys) ← Xs = [X|X1s], delete(X,Ys,Zs),

perm(X1s,Zs).
% delete(X,Ys,Zs) ← Zs is the list obtained by removing X from the list Ys delete(X,Ys,Zs) ← Ys = [X|Zs].
delete(X,Ys,Zs) ← Ys = [X|Y1s], Zs = [X|Z1s],
delete(X,Y1s,Z1s).
Clearly, the relation declaratively given by perm is symmetric. Unfortu- nately, the behavior of the program with Prolog (using the leftmost selection rule) is not. In fact, given the query
Q1 := ← perm(Xs, [a, b]).

Prolog will correctly backtrack through the answers Xs = [a, b] and Xs = [b, a]. However, for the query
Q2 := ← perm([a, b], Xs).

Prolog will first return the answer Xs = [a, b] and on subsequent backtracking will fall into an infinite derivation without returning answers anymore.
For languages with delay declarations the program PERMUTE behaves sym- metrically. In particular, if we consider the delay declarations:
DELAY perm(Xs, ) UNTIL nonvar(Xs). DELAY delete( , ,Zs) UNTIL nonvar(Zs).
the query Q2 above does not fall into a deadlock.
Using one of our domains for abstract susbtitutions, like Prop (see [3,17]), and starting from an activation state of the form perm(ground,var) our anal- ysis returns the abstract qualified answer ⟨perm(ground, ground), ν⟩. which provides the information that any corresponding concrete execution is dead- lock free.

Conclusions
The semantics that has been discussed in these pages belongs to the foundation part of a project aimed at integrating most of the work (both theoretical and practical) on abstract interpretation of logic programs developed by the authors in the last years. The goal is to get a practical tool that tackles a variety of problems raised by the recent research and development directions in declarative programming. Dynamic scheduling is an interesting example in that respect. In the next future, we plan to adapt the existing implementations of GAIA systems in order to practically evaluate the accuracy and efficiency of these seminal ideas.

References
Apt, K. R., “From Logic Programming to Prolog,” Prentice Hall, 1997.
Apt, K. R. and I. Luitjes, “Verification of Logic Programs with Delay Declarations,” Lecture Notes in Computer Science 936, Springer-Verlag, New York, 1995 pp. 66–80.
Cortesi, A., G. Fil´e and W. Winsborough, Optimal groundness analysis using propositional logic, Journal of Logic Programming 27 (1996), pp. 137–167.
Cortesi, A., B. Le Charlier and P. Van Hentenryck, Combination of abstract domains for logic programming, in: Proceedings of the 21th ACM SIGPLAN– SIGACT Symposium on Principles of Programming Languages (POPL’94) (1994), pp. 7–21.
Cortesi, A., B. Le Charlier and P. Van Hentenryck, Combination of abstract domains for logic programming: open product and generic pattern construction, Science of Computer Programming 28 (2000), pp. 27–71.
Cousot, P. and R. Cousot, Abstract interpretation: A uniﬁed lattice model for static analysis of programs by construction or approximation of ﬁxpoints, in: Conference Record of Fourth ACM Symposium on Programming Languages (POPL’77) (1977), pp. 238–252.
Cousot, P. and R. Cousot, Systematic design of program analysis frameworks, in: Conference Record of Sixth ACM Symposium on Programming Languages (POPL’79) (1979), pp. 269–282.
Falaschi, M., M. Gabbrielli, K. Marriott and C. Palamidessi, Constraint logic programming with dynamic scheduling: A semantics based on closure operators, Information and Computation 137 (1997), pp. 41–67.
Garcia de la Banda, M., K. Marriott and P. Stuckey, Efficient analysis of logic programs with dynamic scheduling, in: J. Lloyd, editor, Proceedings of the 12st International Logic Programming Symposium (1995), pp. 417–431.
Intelligent Systems Laboratory, Swedish Institute of Computer Science, Kista, Sweden, “SICStus Prolog User’s Manual,” (1998).
URL http://www.sics.se/isl/sicstus/sicstus_toc.html
Le Charlier, B. and P. Van Hentenryck, Experimental Evaluation of a Generic Abstract Interpretation Algorithm for Prolog, ACM Transactions on Programming Languages and Systems (TOPLAS) 16 (1994), pp. 35–101.
Le Charlier, B. and P. Van Hentenryck, Reexecution in abstract interpretation of Prolog, Acta Informatica 32 (1995), pp. 209–253.
Lloyd, J., “Foundations of Logic Programming,” Symbolic Computation – Artificial Intelligence, Springer-Verlag, 1987, second, extended edition.
Marchiori, E. and F. Teusink, Proving termination of logic programs with delay declarations, Journal of Logic Programming 39 (1999), pp. 95–124.


Marriott, K., M. Garcia de la Banda and M. Hermenegildo, Analyzing logic programs with dynamic scheduling, in: Proceedings of the 21st Annual ACM Symp. on Principles of Programming Languages (1994), pp. 240–253.
Naish, L., “Negation and control in Prolog,” Lecture Notes in Computer Science
238, Springer-Verlag, New York, 1986.
Van Hentenryck, P., A. Cortesi and B. Le Charlier, Evaluation of the domain
Prop, Journal of Logic Programming 23 (1995), pp. 237–278.
Yelick, K. and J. Zachary, Moded type systems for logic programming, in: Proceedings of the Sixteenth Annual ACM Symposium on Principles of Programming Languages (POPL’89) (1989), pp. 116–124.
