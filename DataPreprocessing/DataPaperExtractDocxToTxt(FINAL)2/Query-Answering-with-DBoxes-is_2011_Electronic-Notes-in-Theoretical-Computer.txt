Available online at www.sciencedirect.com



Electronic Notes in Theoretical Computer Science 278 (2011) 71–84
www.elsevier.com/locate/entcs
Query Answering with DBoxes is Hard 1
Enrico Franconi2 Yazm´ın Ang´elica Ib´an˜ez-Garc´ıa2
Free University of Bozen-Bolzano
I˙nan¸c Seylan3
Universit¨at Bremen

Abstract
Data in description logic knowledge bases is stored in the form of an ABox. ABoxes are often confusing for developers coming from relational databases because an ABox, in contrast to a database instance, provides an incomplete specification. A recently introduced assertional component of a description logic knowledge base is a DBox, which behaves more like a database instance. In this paper, we study the data complexity of query answering in the description logic DL-LiteF extended with DBoxes. DL-LiteF is a description logic tailored for data intensive applications and the data complexity of query answering in DL-LiteF with ABoxes
is tractable (in AC0). Our main result is that this problem becomes coNP-complete with DBoxes. In some expressive description logics, query answering with DBoxes also leads to a higher (combined) complexity than query answering with ABoxes. As a proof of concept, we relate query answering in ALCFIO, i.e., ALC with F unctional and Inverse roles, and nOminals to the same problem in ALCFI with DBoxes. The exact complexity of the former is an open problem in the description logic literature. Here we show that query answering in ALCFIO and ALCFI with DBoxes are mutually reducible to each other in polynomial time.
All the proofs in this paper are available in the appendix for the reviewers’ convenience.
Keywords: Description logics, conjunctive queries, hybrid logic, model theory.


Introduction
Description Logics (DLs) constitute a family of logics commonly used in knowledge representation; and they are the logical underpinning of the OWL 2 Web Ontology Language [3]. A standard use case for DL-based systems is to store the facts about the application domain in a knowledge base (KB) and then query the KB. Tradi- tionally, a DL KB consists of two components: a TBox and an ABox [3]. The TBox is the intensional part of the KB. For example, in a TBox one can assert that a

1 This work was supported by DFG SFB/TR 8 “Spatial Cognition”
2 Email: [franconi|ibanezgarcia]@inf.unibz.it
3 Email: seylan@informatik.uni-bremen.de

1571-0661 © 2011 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2011.10.007

father is a man with at least one child. The ABox on the other hand is for asserting facts about individuals, e.g., John is a father, Mary is a daughter of John, etc. As for querying the KB, a popular query language is conjunctive queries (CQs) which originate from database theory [1].
The ABox of a DL KB resembles a database instance since it talks about indi- viduals. In contrast to a database instance, an ABox provides an incomplete spec- ification for the predicates appearing in it. Because of this incompleteness, when one talks about answers of a query over a DL KB, one uses the notion of certain an- swers, i.e., answers which hold in every model of the KB. To elaborate, consider the DL KB K = (T , A), where T = {Employee ± ∃worksFor, ∃worksFor− ± Project} and
A = {Employee(john), Project(prja)}. In the TBox T , we assert that every em- ployee works for a project; in the ABox A, we assert that john is an employee and prja is a project. By the semantics of an ABox, we have that there are some models of K for which somebody works for prja and some models for which nobody works for it. Therefore, the certain answers of the query worksFor(x, prja), which asks for all employees working for prja, is empty.
This semantical difference between ABoxes and database instances is often con- fusing for developers with experience in relational database management systems. In order to avoid such problems, DBoxes were introduced recently as an alternative assertional component of DL KBs [16]. Syntactically, a DBox looks very similar to an ABox. For example, the set of assertions above also constitute a DBox D. The difference between A and D is in the semantics because a DBox is similar to a database instance in that the absence of information is interpreted as negative information. In particular, if we replace A by D in K, then the certain answers of the query worksFor(x, prja) is john. DBoxes are closely related to nominals from hybrid logics [2]. In this respect, we think that they provide a nice connection between hybrid logics, DLs, and databases.
For these reasons, it is a natural research topic to study the complexity of query answering in DLs with DBoxes. In this paper, we choose to study this problem for a DL that is oriented towards data intensive applications since DBoxes are the data components of a KB. In particular, we study the data complexity of query answering in DL-LiteF extended with DBoxes. DL-LiteF belongs to the DL-Lite family of DLs [6]. The data complexity of query answering in these logics (with ABoxes) is tractable since these problems can be reduced to query answering in relational databases. Our main result is that query answering in DL-LiteF with DBoxes is coNP-complete.
DL-LiteF with DBoxes is closely related to the expressive DL ALCFIO, i.e., ALC with Functional and Inverse roles, and nOminals. This is because DL-LiteF with DBoxes contains all these three constructs in a restricted way. Since the exact (combined) complexity of query answering in ALCFIO is an open problem in the DL literature, our result about DL-LiteF with DBoxes is also interesting in this sense. As another contribution, we identify an expressive DL, namely ALCFI extended with DBoxes, such that query answering in this logic is polynomially

reducible to the same problem in ALCFIO and vice versa. As a consequence of these reductions, any complexity result about ALCFI with DBoxes is easily transferable to ALCFIO. Another consequence of this result is that we identify an expressive DL, namely ALCFI, for which query answering with DBoxes is strictly harder (coN2ExpTime-hard [7]) than query answering with ABoxes (2-ExpTime- complete [8]).
The paper is structured in the following way. In Section 2, we review some basic notions from description logics and conjunctive queries. In particular, we define the syntax and semantics of the logics we are interested in, as well as, how conjunctive queries are matched in models. Section 3 introduces the notion of DBoxes as an alternative way of representing extensional knowledge in description logics; together with the notion of query entailment with DBoxes. In Section 4, we establish the main results regarding the data complexity of query entailment in DL-LiteF with DBoxes. Finally, in Section 5 we show that query entailment in ALCFIO and query entailment in ALCFI with DBoxes are problems that are polynomially reducible to each other.
Preliminaries
ALCFIO
The language of ALCFIO contains concept names NC = {A0, A1,..., }, role names NR = {P0, P1,.. .}, and individual names NI = {a0, a1,.. .}, such that NC, NR and NI are countably infinite and mutually disjoint sets. Complex roles R and concepts C of this language are defined as follows:
R ::= P | P−,
C ::= T | A | {a} | ¬C | C1 H C2 | ∃R.C |≤ 1R

ALCFI-concepts are defined as above, except they exclude nominals, i.e., concepts of the form {a}.
An ALCFIO-TBox T is a finite set of concept inclusion axioms (or simply concepts inclusions) of the form:
C1 ± C2.
An ALCFIO-ABox is a finite set of assertions of the form:
C(a), P (a, b),
where C is a complex concept, P ∈ NR, a, b ∈ NI . For a role R we set Inv(R) := P−
if R = P ∈ NR, and Inv(R) := P if R = P−, P ∈ NR.
As usual in description logics, the semantics of ALCFIO is given in terms of interpretations. An interpretation I = (ΔI , ·I ), consists of an non empty domain ΔI , and an interpretation function ·I that assigns to each A ∈ NC a subset AI of

ΔI , to each P ∈ NR a binary relation PI ⊆ ΔI × ΔI over the domain, and to each a ∈ NI an element aI ∈ ΔI . Unless otherwise stated, we do not make the unique name assumption (UNA) for individual names, i.e., for all a, b ∈ NI and all interpretations I, if a /= b then it is not necessarily the case that aI /= bI .
Furthermore, ·I is extended to complex ALCFIO-concepts inductively as fol- lows:
TI = ΔI ,
(P−)I = {⟨t, s⟩| ⟨s, t⟩∈ PI },
{a}I = {aI },
(¬C)I = ΔI \ CI ,
(C H D)I = CI ∩ DI ,
(∃R.C)I = {s ∈ ΔI | ∃t ∈ ΔI .⟨s, t⟩∈ RI ∧ t ∈ CI },
(≤ 1R)I = {s ∈ ΔI | ∀t, u ∈ ΔI .⟨s, t⟩∈ RI ∧ ⟨s, u⟩∈ RI → t = u}.
The satisfaction relation |= is also standard. Given an interpretation I, I |= C1 ±
C2 iff CI ⊆ CI ; I |= C(a) iff aI ∈ CI , and I |= P (a, b) iff ⟨aI , bI ⟩∈ PI .
1	2
A knowledge base K = (T , A) is said to be satisfiable (or consistent) if there is
an interpretation I satisfying all members of T and A. In this case we write I |= T
(as well as I |= T and I |= A) and say that I is a model of K (and of T and A). For an ALCFIO-concept C, we denote as sub(C) the set of all its subconcepts,
(i.e., subformulae). For an ALCFIO-TBox T , con(T ) denotes the smallest set of concepts such that (i) if C1 ± C2 ∈T then C1, C2 ∈ con(T ); and (ii) if C1 ∈ con(T ) and C2 ∈ sub(C1) then C2 ∈ con(T ).

DL-LiteF
Basic DL-LiteF -concepts are defined as follows.
B ::= ⊥| A | ∃R
A DL-LiteF TBox, is a finite set of concept inclusion axioms of the form:
B1 ± B2,	B1 ± ¬B2,	or	(funct R)

As usual, the semantics of DL-LiteF -concepts is given in terms of interpretations. As DL-LiteF -concepts are special cases of ALCFIO-concepts, e.g., ⊥ corresponds to ¬T, and ∃R to ∃R.T, we omit the explicit definition of the semantics here.
The satisfaction relation is defined in the same way as for ALCFIO. We only need to extend it for the (global) functionality axioms, i.e., given an interpretation I, I |= (funct R) if for every s, t, u ∈ ΔI , whenever ⟨s, t⟩ ∈ RI and ⟨s, u⟩ ∈ RI , then t = u.
For a DL-LiteF -TBox, con(T ) is the smallest set of concepts such that (i) if B1 ± B2 ∈T then B1, B2 ∈ con(T ); and (ii) if B1 ± ¬B2 ∈T then B1, B2 ∈ con(T ), i.e., the set of basic concepts occurring in T .

Conjunctive Queries
Conjunctive queries (CQs) are the most frequently asked queries in relational database systems [1]. These queries are definable by existential positive first-order formulas and are preserved under homomorphisms. CQs are also common in DLs. In this sec- tion, we define our notation for CQs. In particular, we view concept and role names as unary and binary predicates, respectively. Since DLs are fragments of first-order logic with at most two variables, it does not make much sense to consider predicates of arity more than two.
Let NV be a countably infinite set of variables which is disjoint from NI , i.e., the set of individual names. Together, NV and NI form the set NT of terms. A conjunctive query (CQ) is a first-order formula of the form ∃y.ϕ(x, y), where
x = x1,..., xn and y = y1,..., ym are vectors of variables and
ϕ is a conjunction of concept atoms A(t) and role atoms P (t, tj), where A ∈ NC,
P ∈ NR, and t, tj ∈ NT .
The variables in x are called distinguished variables; and the ones in y are undis- tinguished. We call the query k-ary if there are k distinguished variables. For a CQ q, we denote by terms(q) the set of terms in q.
Let q = ∃y.ϕ(x, y) be a k-ary CQ and I an interpretation. A match for q in I is a mapping ν : terms(q) → Δ£ such that ν(a)= a£ for all a ∈ terms(q) ∩ NI and all atoms in q are satisfied, i.e.,
ν(t) ∈ A£ for all A(t) ∈ q and
⟨ν(t), ν(tj)⟩∈ P£ for all P (t, tj) ∈ q.
If ν is a match for q in I then we write I,ν |= q. If there is a match for q in I then we denote this by I |= q.
For a k-tuple of individual names a = a1,..., ak,a match ν for q in I is called an a-match if ν(xi)= a£ , i ≤ k. We say that a is an answer to q in an interpretation I if there is an a-match for q in I and use ans(q, I) to denote the set of all answers to q in I.

DBoxes
In this section, we introduce the notion of knowledge bases with DBoxes. The syntax and semantics of DBoxes is given by the following definition:
Definition 3.1 A DBox is a finite set of assertions of the form A(a) and P (a, b), where A ∈ NC, P ∈ NR, and a, b ∈ NI . The set of individual names occurring in a DBox D is called the active domain of D and it is denoted by adom(D). The signature of a DBox D, denoted as sig(D), consists of the concepts and role names occurring in D, denoted as con(D) and rol(D), respectively.
Let D be a DBox and I an interpretation. I |= D iff
a£ /= b£ , for all a, b ∈ adom(D) with a /= b;
A£ = {a£ | A(a) ∈ D}, for every A ∈ con(D);

P£ = {⟨a£ , b£ ⟩| P (a, b) ∈ D}, for every P ∈ rol(D).
Intuitively, the semantics of a DBox D, enforces the UNA for the individual names in adom(D), and that the extensions of the concepts and roles occurring in D, i.e., sig(D), are given by the assertions in D, and coincide in every model I of D.
Let L be either DL-LiteF , ALCFI or ALCFIO. A L knowledge base with a DBox (L -KB) K is a pair (T , D), where T is an L -TBox and D is a DBox. For a L -KB K = (T , D), we define the following notions:
con(K)= con(T ) ∪ {A ∈ NC | A(a) ∈ D} ∪ {∃R.T, ∃R−.T| R(a, b) ∈ D};
rol(K) the set of roles occurring in T or D;
sig(K) the set of concept names and role names occurring in T or D;
adom(K) the union of adom(D) and all individuals that appear as nominals, if any, in T .
Let I be an interpretation and K = (T , D). We have that I |= K iff I |= T and I |= D. We say that K is satisﬁable if there is some interpretation such that I |= K.
A certain answer of a k-ary CQ q with respect to the L -KB K = (T , D) is a k-tuple a ∈ adom(D)k such that a ∈ ans(q, I) for all models I of K. The set of certain answers to q over K will be denoted by cert(q, K). Moreover, K |= q iff for all interpretations I, I |= K implies I |= q.
The CQ answering problem can be formulated as follows: given an L -KB K = (T , D) and a CQ q, to compute cert(q, K). The CQ entailment problem is given an L -KB K = (T , D) and a boolean CQ q, i.e., a CQ without any distinguished variables, to decide whether K |= q.
Observe that for a k-ary CQ q = ϕ(x), we have cert(q, K) = {a ∈ adom(D)k | K |= ϕ(a)}, where ϕ(a) denotes the substitution of x by a in ϕ and is a boolean CQ. Since CQ answering can be reduced to CQ entailment in this way and that CQ entailment is a decision problem, in the rest of this paper we will study CQ entailment.
Data Complexity of CQ Entailment in DL-LiteF
In this section, we study the data complexity of query entailment in DL-LiteF with DBoxes. Data complexity is a common measure of complexity in databases [1]. When considering data complexity, the only input considered is the database in- stance, while the query is assumed to be fixed.
Data complexity of query answering in DLs (w.r.t. KBs with ABoxes) is well- studied [5,12]. In this setting, the only input is the ABox, while the TBox and the query are regarded as fixed. As stated in the previously, we are interested in studying the data complexity of query answering in DL-LiteF with DBoxes. In this setting, we consider the DBox as the input, and again the TBox and the query are regarded as fixed.
Our main result in this section is Theorem 4.16. We show that query entailment in DL-LiteF is harder when we consider KBs with DBoxes. It is known that query

entailment in DL-Lite7 with ABoxes is in AC0, for data complexity [6]. However, as we show in Lemma 4.1, the problem becomes coNP-hard for data complexity, when DBoxes are considered. Moreover, we show that this complexity bound is tight (Theorem 4.16). In particular, we show a match with the data complexity of CQ entailment in expressive DLs such as SHIQ, SHOI, and SHOQ [12].
Lemma 4.1 CQ entailment in DL-Lite7 with DBoxes is coNP-hard for data com- plexity.
Proof. The proof is by a reduction of the 3-colorability problem for undirected graphs to non-entailment of a CQ w.r.t. a DL-Lite7 -KB with DBox. An undirected graph G = ⟨V, E⟩ with node set V and edge set E , is said to be 3-colorable if each node in V can be assigned exactly one of three colors, in such a way that no two adjacent nodes are assigned the same color. 3-colorability is the problem of deciding whether a given graph is 3-colorable. It is well-known that 3-colorability is NP-complete [13].
Given an (finite) undirected graph G = ⟨V, E⟩, let KG = (T , DG ), where
DG = {V (av) | v ∈ V} ∪ {E(av, av′ ) | ⟨v, v ⟩∈ E} ∪ {C(r), C(g), C(b)}
and T = {V ± ∃R, ∃R— ± C}, and let q = ∃x, y, z[E(x, y) ∧ R(x, z) ∧ R(y, z)]. In the definition above, we have for all v, vj ∈ V, v /= vj implies av /= av′ , and the semantics of the DBox allows us to fix the extension of C in every model of KG , thus expressing the fact that there are exactly three colors used for coloring. The role name R basically corresponds to the hasColor relation, and the meaning of V and E are self-explanatory. Observe that T and q does not depend on G, which is essential for the correctness of the reduction for data complexity. It can now be shown that G is 3-colorable iff KG |= q.	2
For the upper bound, one can trivially embed DL-Lite7 with DBoxes to ALCFIO. However, the data complexity of query answering in ALCFIO is unknown. Also note that DL-Lite7 with DBoxes can not be trivially embedded in SHIQ, SHOI, and SHOQ since each of these logics lack one of the constructs of DL-Lite7 with DBoxes. For these reasons, we will establish a weak forest model property for our logic in order to show the upper bound. These models consist of several trees and the roots of these trees may be arbitrarily connected to each other. Moreover, there may be back edges from non-root nodes to root nodes. We observe that it is not enough to take only active domains elements as the roots of these trees. This is because the interaction between DBox assertions, inverse roles, and functionality assertions may enforce the existence of elements in the domain that act like active domain elements although they are not. These elements are called new nominals [14]. In order to devise a decision procedure, we have to establish a bound on the number of new nominals, and hence the number of trees in our models. This is the same problem that one faces for CQ entailment in ALCFIO. Note that in high contrast to ALCFIO, the ‘light’ nature of DL-Lite7 allows us to establish a polynomial upper bound on the size of new nominals.

The key observation for establishing a bound on the number of new nominals is that they belong to concepts whose instances are bounded in every model of the KB. Clearly, DBox concepts have a bounded extension in every model. However, TBox axioms may enforce some other concepts, not occurring in the DBox, to have a bounded extension as well. We formalize this in the following definition.
Definition 4.2 Let K = (T , D) bea DL-Lite7 -KB with a DBox. Then Bcon(K) is inductively defined as follows:
Bcon(K)0 = {B ∈ con(K) | B ∈ con(D)}∪ {∃P, ∃P— ∈ con(K) | P ∈ rol(D)}
Bcon(K)i+1 = {B1 ∈ con(K) | B1 ± B2 ∈ T and B2 ∈ Bcon(K)i}∪ {∃Inv(R) ∈
con(T ) | (funct R) ∈T and ∃R ∈ Bcon(K)i}
As there are only finitely many concepts in con(K), there exists j, such that
Bcon(K)j = Bcon(K)j+1. We set Bcon(K) := Bcon(K)j.
Lemma 4.3 Let K = (T , D) be a DL-Lite7 -KB with a DBox. We have that
Bcon(K) ≤ |K|, and
for every model I of K and for all B ∈ Bcon(K), (B£ ) ≤ adom(D).
In order to establish a forest model property for DL-Lite7 with DBoxes, we will work on structures based on graphs instead of interpretations. We call these structures K-graphs because of their intimate connection with a given KB K. Such structures are commonly used in the literature and have many names, e.g., Hintikka structure [15], model graph [9], or even tableau [10]. Modulo some differences, building blocks of these structures are sets of finite concepts each of which is a subset of a relevant concept closure.
Definition 4.4 Let K = (T , D) be KB. A K-graph is a tuple M = (V, E, L), where (V, E ) is a directed graph with adom(D) ⊆ V, and L is a function associating with every v ∈ V a subset of con(K) and with every ⟨v, vj⟩ ∈ E a subset of rol(K). The set of nominals of M is the set of nodes nom(M)= {v ∈V | L(v) ∩ Bcon(K) /= ∅}. We use the notation Rn(v, vj) to express that
⟨v, vj⟩∈E and R ∈ L(v, vj), or
⟨vj, v⟩∈E and Inv(R) ∈ L(vj, v).
We are interested in certain K-graphs that satisfy additional properties.
Definition 4.5 Let K = (T , D) be a DL-Lite7 -KB with a DBox and let M = (V, E, L) be a K-graph. We say M is a K-graph quasimodel if for all v, vj ∈ V, M satisfies the following conditions:
(PA) for all A ∈ con(D), A ∈ L(v) iff v = a and A(a) ∈ D, for some a ∈ adom(D); (PR) for all R ∈ rol(D), Rn(v, vj) iff v = a, vj = b, R(a, b) ∈ D, for some a, b ∈
adom(D);
(P+) for all B1 ± B2 ∈T , if B1 ∈ L(v) then B2 ∈ L(v); (P—) for all B1 ± ¬B2 ∈T , if B1 ∈ L(v) then B2 /∈ L(v);
(P⇐) for all ∃R ∈ con(K), if there is some vj ∈V with Rn(v, vj) then ∃R ∈ L(v);

(P≤) for all (funct R) ∈T , there is at most one vj ∈V with Rn(v, vj).
M is a called a model if in addition to the properties above, it satisfies the following property.
(P⇒) for all ∃R ∈ con(K), if ∃R ∈ L(v) then there is some vj ∈V with Rn(v, vj). We write M▶K to denote that M is a K-graph model.
Query matches in K-graphs are very similar to query matches in interpretations.

Definition 4.6 A match ν for a CQ q in a K-graph M = (V, E, L) is a total function ν : terms(q) → V such that ν(a) = a for each individual name a ∈ terms(q). We write M,ν ▶ q if for every A(t) ∈ q, A ∈ L(ν(t)); and for every R(t, tj) ∈ q, Rn(ν(t), ν(tj)).
The following lemma is a consequence of the definitions above, and establishes that K-graph models capture faithfully the semantics of DL-Lite7 -KBs with DBoxes.

Lemma 4.7 Let K = (T , D) be a DL-Lite7 -KB witha DBox and q be a CQ. Then
K |= q if and only if there is some K-graph model M such that M /▶ q.
Intuitively, a K-graph M is called a K-forest if the structure resulting from removing all edges going to nominals of M is a forest, i.e., a set of disjoint trees.
Definition 4.8 Let M = (V, E, L) be a K-graph. The graph Gf = (V, Ef ), where
Ef = E\ {⟨v, vj⟩∈E | vj ∈ nom(M)}
is called the f-pruning of M. We call M a K-forest if its f -pruning is a forest. The roots of a K-forest M is the roots of its f -pruning and it is denoted by roots(M). The branching degree of a K-forest M is the branching degree of its f -pruning and it is denoted by bdegree(M).
The K-forests we are interested in have as their roots exactly the nominals and their tree parts are uniform.
Definition 4.9 Let M = (V, E, L) be a K-forest. Then M is called uniform if (U1) for all ⟨v, vj⟩∈ E , if vj ∈V \ nom(M) then for some ∃R ∈ L(v), L(v, vj)= {R}
and L(vj)= {B ∈ con(T ) |T |= ∃Inv(R) ± B};
(U2) bdegree(M) ≤ |T | and roots(M)= nom(M);
(U3) for all ⟨v, vj⟩ ∈ E , if v ∈ V \ nom(M), vj ∈ nom(M), and R ∈ L(v, vj) then (funct Inv(R)) /∈T .
It is enough to consider only uniform forest-models of a KB (with polynomially many roots) for deciding CQ entailment. We establish this in the following.
Theorem 4.10 Let K = (T , D) be a DL-Lite7 -KB and let q be a CQ. Then K |= q
if and only if there exists a uniform K-forest model M with M /▶ q.

Thus, we can decide CQ non-entailment by finding a K-forest model M with M /▶ q. At this point, we are faced with the problem that we can not simply construct a K-forest model M and check whether M /▶ q since M can be infinite. However, as we will show, it is possible to represent K-forest models in a finite way. Here the crucial observation is that in a sufficiently big tree in a uniform K-forest model, there is a bounded number of subtrees up to isomorphism.
Definition 4.11 Let M1 = (V1, E1, L1) and M2 = (V2, E2, L2) be two K-graphs. Then M1 and M2 are called isomorphic, written M1 ∼= M2, if and only if there is a bijection β : V1 → V2 such that:
for all a ∈ adom(D) and v ∈ V1, v = a iff β(v)= a;
for all v ∈ V1, L1(v)= L2(β(v));
for all v, vj ∈ V1, ⟨v, vj⟩∈ E1 iff ⟨β(v), β(vj)⟩∈ E2;
for all ⟨v, vj⟩∈ E1, L1(v, vj)= L2(β(v), β(vj));
If we want to specify the bijection explicitly, we use the notation M1 ∼=β M2.
Definition 4.12 Let n ∈ N be a fixed natural number and M = (V, E, L) be a 

K-forest. An n-tree in M is the restriction of M to {v}∪ descn
(v) ∪ nom(M), for

some v ∈ V ∈ \nom(M). Here descn (v) denotes all nodes vj of the subtree of Gf
rooted at v such that the distance between v and vj is at most n.
Now we define the notion of blocking which is a standard technique for devising tableau-based decision procedures in DLs. Our definitions are based on the ones in
[12] with slight variations in the notation.
Definition 4.13 Let M = (V, E, L) be a K-forest. We say that an n-tree Mj in
M has a witness if there is an n-tree Mjj in M such that
Mj ∼= Mjj,
Vj ∩ Vjj = ∅,
vj = descG (v), where vj and v are roots of Mj and Mjj, respectively and descG (v) denotes the set of all descendants of v on the subtree of Gf rooted at v.
In this case, Mjj is called a witness of Mj.
A v ∈ V is directly n-blocked if v /∈ nom(M) and there is an n-tree Mj in M such that v is a leaf of Mj and Mj has a unique witness. A v ∈ V is indirectly n-blocked if v ∈ descG (vj) for some directly n-blocked node vj. Finally v ∈ V is n-blocked if it is directly or indirectly n-blocked.
The class of structures we define next is the finite representation of K-forest models that we are looking for.
Definition 4.14 A uniform K-forest M = (V, E, L) is called an Kn-forest model if
V contains no indirectly n-blocked node;
M is a quasimodel, which satisfies the following property:
(Pn) for all ∃R ∈ con(K) and v ∈ V that is not n-blocked, if ∃R ∈ L(v) then there is some vj ∈V with Rn(v, vj).

Theorem 4.15 Let K = (f , Ð) be a DL-Lite7 -KB with a DBoxes and let q be a CQ. Then K |= q if and only if there is some K|q|-forest model M with M /▶ q.
Proof. [Sketch] Let K = (f , Ð) bea DL-Lite7 -KB and let q be a CQ with |q| = n. We assume that q is connected. A query q is connected if, for all t, tj ∈ terms(q), there exists a sequence t1,..., tm such that t1 = t, tm = tj, and for all i ∈ {1,...,m — 1}, there exists a role name R such that R(ti, ti+1) or R(ti+1, ti) is a conjunct of q. This assumption is w.l.o.g. since entailment of q can be decided by checking the entailment of each connected component of q (viewing q as an undirected graph) separately [14].
(⇒) This is the easy direction of the proof. Suppose K |= q. Then by Theorem 4.10, there is some uniform K-forest model M = (u, S, L) with M /▶ q. We use an inductive construction. As the base case, we set M0 = M. Now for the step from Mi to Mi+1, first we choose a node v ∈ ui that is indirectly n-blocked. Then we define Mi+1 as the restriction of Mi to nodes ui \ ({v}∪ desc(Gi)f (v)), i.e., we ‘chop off’ the tree rooted at v. We have that |Mi+1| < |Mi| and Mi+1 lacks the tree rooted at v. Let Mj = (uj, Sj, Lj) be the K-forest obtained at the limit of this construction. It is easy to see that for every v ∈ uj, v is either not n-blocked or v is directly n-blocked. Because of this and the fact that M is a uniform K-forest model, we have that Mj is a uniform Kn-forest model. Moreover, we have Mj /▶ q since M0 /▶ q and for each step i, Mi+1 is a strict substructure of Mi.
(⇐) Suppose M = (u, S, L) is a uniform Kn-forest model with M /▶ q. The proof is analogous to the one given in [14] (Lemma 42). First we unravel M into a K-forest. Unravelling is a standard construction in modal logics [4]; but in the presence of DBoxes (nominals), inverse roles, and functionality, one has to be more careful. This is because the standard construction can easily lead to the violation of functionality assertions. However, the uniformity of M, more precisely (U3), ensures that this does not happen.
Let Mj be the unravelling of M. It follows by the properties of M that Mj is a uniform K-forest model. One has to show that Mj /▶ q. The proof is then by contradiction. Suppose Mj ▶ q. By using the connectedness of q and Mj ▶ q, we can ensure to find a match ν for the query in M, which then leads to a contradiction.2
Every uniform K|q|-forest model M has a finite size. This is easy to see because there are finitely many |q|-trees in M that are distinct up to isomorphism. For bounds on the size of K|q|-forest models, the reader is referred to [11,12,14]. Here the interesting observation is that the size of |q|-trees in M depend on the size of the f and q. This can be explained as follows. Since the branching degree of M is bounded by |f |, the branching degree of a |q|-tree in M is also bounded by |f |. Moreover, the height of a |q|-tree is bounded by |q|. This means, if we take |f | and
|q| as constant, which is what we will do for data complexity, we have that the size of each tree in M is constant.
Our algorithm for deciding the non entailment of a boolean CQ q from a KB K is as follows. We first guess a K|q|-forest M with bdegree(M) ≤ |f | and roots(M) ≤
|Ð| + |Ð| · |f |. Since by assumption, |f | and |q| are constant, the size of M is

polynomial in |Ð|. Verifying if M is a uniform K|q|-forest model can be done in polynomial time. If M is not a K|q|-forest model then we return “no”. Otherwise, we verify if q matches against this structure. Since |q| is constant, this can be done in time polynomial in |Ð|. Hence, we have a non-deterministic algorithm that runs in PTime and decides the non-entailment of q from K. This immediately yields a coNP upper bound for deciding CQ entailment from a KB. Then by Lemma 4.1, we obtain the following theorem.
Theorem 4.16 CQ entailment in DL-Lite7 with DBoxes is coNP-complete for data complexity.

Relating ALCFIO to ALCFIÐ
The exact (combined) complexity of CQ entailment in ALCFIO (and its extensions above) is a major open problem in DLs: it is known to be decidable [14] (without any upper complexity bound) and coN2ExpTime-hard [7]. In this section, we prove Theorem 5.1, which gives a new perspective to this problem in terms of DBoxes. We believe that this may be useful for tackling the problem.
Theorem 5.1 CQ entailment in ALCFI with DBoxes is reducible to CQ entail- ment in ALCFIO with ABoxes and vice versa.
We start by reducing reasoning with DBoxes to reasoning with nominals in a rather straightforward way. Let K = (f , Ð) be a ALCFI-KB, AQ = {a ∈ adom(Ð) | A(a) ∈ Ð, and ∃PQ = {a ∈ adom(Ð) | ∃aj ∈ adom(Ð),P (a, aj) ∈ Ð}. τ&(K) = (f ∪ f j, A) is the ALCFIO-KB such that A = Ð and f j consist of the following sets of inclusion axioms:
fUNA = {{a}± ¬{b}| a, b ∈ adom(Ð),a /= b};
fcon(Q) = A ≡ {a1}H ... H {an}| A ∈ con(Ð), ai ∈ AQ, 1 ≤ i ≤ n};
frol(Q) = {{a}± ∃P.{b1}H ... H ∃P.{bn}| P ∈ rol(Ð),P (a, bi) ∈ Ð, 1 ≤ i ≤ n} ;
∪ {{a}± ∀P.({b1}H ... H {bn}) | P ∈ rol(Ð),P (a, bi) ∈ Ð, 1 ≤ i ≤ n} ;
∪ ∃P.T± {a1}H ... H {an}| P ∈ rol(Ð), ai ∈ (∃P )Q, 1 ≤ i ≤ n .
In the definition above, fUNA ensures that UNA for DBox individuals is preserved, fcon(Q) fixes the extension of concept names appearing in Ð, and frol(Q) fixes the extension of a role names appearing in Ð.
Lemma 5.2 Let K = (f , Ð) be a ALCFI-KB and q be a CQ. Then K |= q if and only if τ&(K) |= q.
Note that f j is a TBox in ALCO. Thus, 5.2 holds for ALC with DBoxes and any of its extensions we consider.
The reduction on the other direction is a little bit more intricate since UNA is not typically made in ALCFIO; but we have it in ALCFI, if we consider DBoxes. We shall show that, CQ entailment in ALCFIO without UNA can be reduced to

query entailment w.r.t. an ALCFI-KB with DBox Ð, where adom(Ð) = 1. Note that in such KBs the UNA is not relevant.
Let K = (f , A) be an ALCFIO-KB, and q a CQ. We construct the KB τQ(K), and the query δ(q), such that one single individual occurs in τQ(K). For each a ∈ adom(K), introduce a new concept name Aa, and a new role name Ra. We also use a fresh individual name o ∈ NI such that o /∈ adom(K) ∪ adom(q), and a concept name Ao. For each C ∈ con(K), denote by δ(C) the concept obtained from C by replacing every nominal {a} occurring in C with Aa. We extend δ to f as follows: δ(f )= {δ(C) ± δ(D) | C ± D ∈f }.
Set Ð = {Ao(o)}. Then, τQ(K) = (δ(f ) ∪f j, Ð), where f j consists of the following axioms for each a ∈ adom(K).:
Aa ± ∃R—.Ao,
Ao ±≤ 1Ra,
Ao ± ∃Ra.Aa
Furthermore, for each C(a) ∈ A, and each P (a, b) ∈ A, we have the following axioms:
Ao ± ∃Ra.δ(C),
Ao ± ∃Ra.∃P.Ab.
Finally, δ(q) is the CQ obtained from q by replacing every occurrence of a ∈ adom(K) in q with a new variable xa, and appending the atom Aa(xa) to q.
Intuitively, Aa acts as the nominal {a}. With the axioms above we connect the instances of concept names Aa around the only instance of Ao with the functional role Ra. This guarantees that there is at most one instance of Aa in every model of τQ(K). The following lemma shows the correctness of the reduction.
Lemma 5.3 Let K = (f , A) be a ALCFIO-KB and q be a CQ. Then K |= q if and only if τQ(K) |= δ(q).

Discussion
In this paper, we characterized the data complexity of query entailment in DL-Lite7 with DBoxes (Theorem 4.16). The exact combined complexity of this problem remains open. It would also be interesting to study these problems for other logics in the DL-Lite family. The coNP lower bound argument (Lemma 4.1) goes through even for a very simple logic in this family. Then the challenge is to identify a fragment of DL-Lite for which query answering with DBoxes is tractable. In the case of expressive DLs, we showed that the combined complexity of query entailment in ALCFIO is complete for the same complexity class as query entailment in ALCFI with DBoxes (Theorem 5.1). Our reductions do not work for the case of data complexity since they encode the data into the TBox, which is supposed to be fixed. It is an interesting question if such a characterization also exists for data complexity.

References
Abiteboul, S., R. Hull and V. Vianu, “Foundations of Databases,” Addison-Wesley, 1995.
Areces, C. and B. ten Cate, Hybrid logics, in: P. Blackburn, J. van Benthem and F. Wolter, editors,
Handbook of Modal Logic, Elsevier, 2007.
Baader, F., D. Calvanese, D. L. McGuinness, D. Nardi and P. F. Patel-Schneider, editors, “The Description Logic Handbook: Theory, Implementation, and Applications,” Cambridge University Press, 2003.
Blackburn, P., M. de Rijke and Y. Venema, “Modal logic,” Cambridge University Press, New York, NY, USA, 2001.
Calvanese, D., G. D. Giacomo, D. Lembo, M. Lenzerini and R. Rosati, Data complexity of query answering in description logics, in: P. Doherty, J. Mylopoulos and C. A. Welty, editors, KR (2006), pp. 260–270.
Calvanese, D., G. D. Giacomo, D. Lembo, M. Lenzerini and R. Rosati, Tractable reasoning and efficient query answering in description logics: The DL-Lite family 39 (2007), pp. 385–429.
Glimm, B., Y. Kazakov and C. Lutz, Status qio: An update, in: Proceedings of the 24th International Workshop on Description Logics, 2011, to appear.
Glimm, B., C. Lutz, I. Horrocks and U. Sattler, Conjunctive query answering for the description logic shiq, J. Artif. Intell. Res. (JAIR) 31 (2008), pp. 157–204.
Gor´e, R., Tableau methods for modal and temporal logics, in: M. D’Agostino, D. M. Gabbay, R. Hahnle and J. Posegga, editors, Handbook of Tableau Methods (1999), pp. 297–396.
Horrocks, I. and U. Sattler, A tableau decision procedure for SH&£Q, J. Autom. Reason. 39 (2007),
pp. 249–276.
Levy, A. Y. and M.-C. Rousset, Combining horn rules and description logics in carin, Artif. Intell. 104
(1998), pp. 165–209.
Ortiz, M., D. Calvanese and T. Eiter, Data complexity of query answering in expressive description logics via tableaux, J. Autom. Reasoning 41 (2008), pp. 61–98.
Papadimitriou, C. H., “Computational complexity,” Addison-Wesley, 1994.
Rudolph, S. and B. Glimm, Nominals, inverses, counting, and conjunctive queries or: Why infinity is your friend!, J. Artif. Intell. Res. (JAIR) 39 (2010), pp. 429–481.
Schwendimann, S., A new one-pass tableau calculus for pltl, in: TABLEAUX ’98: Proceedings of the International Conference on Automated Reasoning with Analytic Tableaux and Related Methods (1998),
pp. 277–292.
Seylan, I., E. Franconi and J. de Bruijn, Effective query rewriting with ontologies over dboxes, in:
C. Boutilier, editor, IJCAI, 2009, pp. 923–925.
