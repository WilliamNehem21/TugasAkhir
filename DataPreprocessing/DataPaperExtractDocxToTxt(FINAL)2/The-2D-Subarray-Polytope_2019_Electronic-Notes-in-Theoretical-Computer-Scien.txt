Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 346 (2019) 557–566
www.elsevier.com/locate/entcs





The 2D Subarray Polytope
Ivo Kocha,1 Javier Marencob,2
a Instituto de Industria, Universidad Nacional de General Sarmiento, Argentina
b Instituto de Ciencias, Universidad Nacional de General Sarmiento, Argentina

Abstract
Given a d-dimensional array, the maximum subarray problem consists in finding an axis-parallel slice of the array maximizing the sum of its entries. In this work we start a polyhedral study of a natural integer programming formulation for this problem when d = 2. Such an exploration is motivated by the need of solving large-scale instances of the rectilinear picture compression problem (RPC), a problem which arises in different scenarios. The obtained results can be useful to solve the column generation phase of a branch and price approach for RPC, a technique that applies naturally to this problem. We thus define the 2D subarray polytope, explore conditions ensuring the validity of linear inequalities, and provide several families of facet-inducing inequalities.
Keywords: maximum subarray problem, integer programming, facets


Introduction
The rectilinear picture compression problem (RPC) consists in covering all entries with value 1 of a binary matrix M ∈ {0, 1}m×n with a minimum number of submatri- ces having consecutive rows and consecutive columns (henceforth called rectangles), such that each rectangle contains only entries in M with value 1. Although the ini- tial motivation for exploring RPC comes from the compression of monochromatic images (in particular, images coming from rectangular constructs), this problem also has applications in other scenarios.

1 Email: ikoch@ungs.edu.ar
2 Email: jmarenco@ungs.edu.ar

https://doi.org/10.1016/j.entcs.2019.08.049
1571-0661/© 2019 The Author(s). Published by Elsevier B.V.
This is an open access article under the CC BY license (http://creativecommons.org/licenses/by/4.0/).

One such setting, originating challenging instances of RPC, is the synthesis of DNA arrays [7]. As a part of this method, light is selectively allowed through a mask to expose cells in the array, activating the fragments of nucleic acids in that cell. Masks for DNA arrays are built by patterning equipment that generates rectangular regions by a long series of “flashes”, each flash producing a rectangle. Since the cost of a mask is proportional to the number of generated rectangles, a cover of a mask with a minimum number of rectangles is desired. This technique is similar to the one used in the semiconductor industry. Semiconductor-based integrated circuit masks usually consist of orthogonal polygons with each side parallel to one of the axes, and these polygons must be covered by the smallest possible number of rectangles [8].
Another application of RPC is in the processing of access control lists (ACLs). ACLs are used in network routers to determine which arriving packets should be forwarded to their destination and which should be dropped. An ACL can be regarded (with some simplification) as a set of tuples (S, D, a), where S and D are source and destination address ranges, respectively, and a ∈ {0, 1} is a forward (1) or deny (0) action. S and D are specified by binary strings of length w or less, where w is the length of an IP address. Minimization of the size of ACLs allows to improve the access control performance of current state-of-the-art routers. The set of rules of an ACL can be modeled as a 2w × 2w matrix with an entry for each combination of a source and a destination IP address (columns and rows indexed from 0 to 2w − 1). The action of an ACL can be viewed as setting a 1 in an entry if and only if that combination is permitted (i.e., forwarded), and a minimum rectangle cover of the entries with value 1 in the matrix is known as the ACL minimization problem [2]. The earliest reference to RPC seems to be due to Masek [10]. In this work, the author showed that RPC is NP-hard; Berman and DasGupta later proved it MaxSNP-hard [4]. The best known polynomial-time approximation guarantee is
O(√log k), where k is the number of entries with value 1 in the input matrix [1].
A slightly more general version of the problem has also been studied under a poly- hedral approach in [9] and in [11]. In the former, the authors analyze new lower bounds on the optimal cover size based on the fractional solution of the linear pro- gramming relaxation of the proposed formulation. The latter discusses two integer programming models for the rectangle cover of a convex polygon.
Given a binary matrix M ∈ {0, 1}m×n, a rectangle in M is formally defined to be the entry set {(k, l) : i1 ≤ k ≤ i2 and j1 ≤ l ≤ j2} for 1 ≤ i1 ≤ i2 ≤ m and 1 ≤ j1 ≤ j2 ≤ n. We define R(M ) to be the set of rectangles in M that contain only entries with value 1 in M . For each r ∈ R(M ), we introduce a binary variable xr specifying whether rectangle r is chosen in the cover or not. For every entry (i, j) with Mij = 1, at least one rectangle containing (i, j) has to be selected, and we seek to minimize the number of selected rectangles.
min Σ xr	(1)
r∈R(M )

Mij ≤	Σ
r∈R(M ):(i,j)∈r
xr	i = 1,..., m, j = 1,...,n	(2)

xr ∈ {0, 1}	r ∈ R(M )	(3)
The number of rectangles in R(M ) is polynomial, namely |R(M )| ∈ O(n2m2). However, for a medium- to large-sized input matrix, this formulation quickly leads to an impractically large number of variables. In this setting, a natural solution is a column generation approach, i.e., the dynamic generation of rectangle variables for the linear relaxation of the formulation when strong duality is violated. In this scenario, column generation consists in finding a (weighted) rectangle of negative reduced cost. In other words, we seek a 2-dimensional integer array of maximum weight within M . Efficient resolution of this problem is essential for a branch and price scheme that exploits the described column generation. In addition, the linear programming relaxation of the above formulation turns out to be extremely tight, as shown in the experiments conducted in [9]. This makes the branch and price approach even more promising, since it is more likely that nodes are cut off from the search tree, thus speeding up the search for an optimal solution. Both arguments motivate our study of the maximum 2D subarray polytope, which is the main focus of this work.
The maximum subarray problem
Given a d-dimensional real-valued array A, d ≥ 1, the maximum subarray problem consists in finding a contiguous and axis-parallel section of A with maximum sum. We are interested in the case d = 2, which corresponds to a 2-dimensional array A ∈ Rm×n, and asks for row indices i1, i2 ∈ {1,..., m}, i1 ≤ i2, and column indices

j1, j2 ∈ {1,..., n}, j1 ≤ j2, such that Σi2
j2 j=j1
Aij is maximum.

We assume m   n. The classical algorithm described by Bentley solves this
problem in O(m2n) time [3], and subsequent works showed that this problem can be solved in sub-cubic time. Indeed, the algorithm presented in [13] runs in O(m2n(log log m/ log m)1/2 log(n/m)) time, and this bound was improved in [12], with an O(m2n(log log m/ log m)1/2) worst case.
Although sub-cubic, these algorithms may not be of practical use when m and n are close to real-sized images. Furthermore, in a column generation environment we need not solve the column generation problem to optimality, since a column with a negative reduced cost suffices to continue with the procedure. Hence, fast heuristics may be useful for this problem and, in particular, linear programming- based heuristics (e.g., rounding heuristics) may be of interest. Due to these facts, we are interested in an integer-programming based approach for the maximum subarray problem for d = 2.
In this work we start such an issue, by exploring the polytope associated with a natural integer programming formulation of this problem. The final objective of such an undertaking is to identify strong families of valid inequalities that could be useful within a cutting plane procedure for the maximum subarray problem for d = 2. Such families of valid inequalities may also be useful within a linear programming-based rounding heuristic, by strengthening the linear relaxation pre- vious to a rounding phase.

The associated polytope may be regarded as a two-dimensional version of the full interval vectors polytope, i.e., the convex hull of vectors in {0, 1}n having consecutive ones. The corresponding polytope has been studied in [6] and the results therein have inspired some of the results in the current work.

The 2D subarray polytope
We consider a real-valued matrix A with m rows and n columns. Denote by R =
{1,..., m} the set of row indexes, and by C = {1,..., n} the set of column indexes. We also define P = R × C to be the set of entries of A (also called pixels in this context). For (i, j) ∈ P , the binary variable xij takes value 1 if and only if the pixel (i, j) belongs to the represented rectangle.
The rectangular hull of a set S ⊆ P of pixels, denoted by 2(S), is the smallest rectangle including all the pixels in S, i.e., 2(S) = {(k, l) : min(i,j)∈S i ≤ k ≤ max(i,j)∈S i and min(i,j)∈S j   l  max(i,j)∈S j . If S = p, pj with p = (i, j) and pj = (ij, jj), then we also denote 2(S) by 2(p, pj) and by 2(i, j, ij, jj). For (i, j), (ij, jj) ∈ P , we define □(i, j, ij, jj) to be the feasible solution x ∈ {0, 1}mn having xkl =1 if and only if (k, l) ∈ 2(i, j, i , j ).

Definition 3.1 For m ∈ Z+ and n ∈ Z+, we define P 2
= conv {0} ∪ 

j	j	j
m,n
j

{□(i, j, i ,j ):1 ≤ i ≤ i
≤ m and 1 ≤ j ≤ j
≤ n} .

We now give a formulation for the 2D maximum subarray problem as an op-
timization problem over P 2 . For (i, j) ∈ P , Aij is the benefit associated with
picking the pixel (i, j). In this setting, the 2D maximum subarray problem can be formulated as follows.

max Σ
(i,j)∈P
Aijxij

xij + xi(j—2) ≤ xi(j—1) +1	(i, j) ∈ P, j > 2	(4)
xij + x(i—2)j ≤ x(i—1)j +1	(i, j) ∈ P, i > 2	(5)

xij′ + xi′j
j j	j	j

xij + xi′j′ ≤
2	+1	(i, j), (i j ) ∈ P, i < i , j /= j
(6)

xij ∈ {0, 1}	(i, j) ∈ P	(7)
Constraints (4) (resp. (5)) force the variables in the same row (resp. column) to be contiguous. Constraints (6) assure that if pixels (i, j) and (ij, jj), with i < ij, are part of the selected rectangle, then pixels (i, jj) and (ij, j) must be contained in the rectangle as well. This family of constraints is illustrated in Fig. 1.

The convex hull of feasible solutions to (4)-(7) coincides with P 2
. Note that

we allow the empty solution to be a feasible solution, namely 0 ∈ P 2
. This implies

the following result.


Proposition 3.2 P 2
is full-dimensional.



xij
xij'
xij'
xij

	

xi' j
xi' j'
xi' j'
xi' j

(a) Case where j′ > j	(b) Case where j′ < j 

Fig. 1. Constraints (6) of the formulation for the 2D maximum subarray problem. The rectangles represent
2(i, j, i′,j′), and the square dots represent the x-variables that must be set to 1 if xij = xi' j' = 1.
Facets of the 2D subarray polytope
Let π ∈ Zmn. For c ∈ Z, we define Iπ = {(i, j) ∈ P : πij = c} to be the set of
pixels with coefficient c in π. We also define Iπ  to be the set of pixels with positive

coefficient in π, and Iπ
to be the set of pixels with negative coefficient in π. These

definitions allow us to provide a general characterization of valid inequalities for
m,n.
Theorem 4.1 Let π ∈ Zmn and π0 ∈ Z. The inequality πx ≤ π0 is valid for P 2

if and only if

for every S ⊆ Iπ .
Σ

(i,j)∈S
πij +	Σ
(i,j)∈2(S)∩Iπ

πij ≤ π0

Although difficult to check in practice, the condition ensuring validity in Theo- rem 4.1 will be useful in the next sections.

Facet-inducing inequalities with coefficients in {−1, 0, 1}
We first explore valid inequalities with coefficients in {−1, 0, 1}. In this case, The- orem 4.1 implies the following characterization for validity.
Corollary 4.2 Let π ∈ {−1, 0, 1}mn. The inequality πx ≤ 1 is valid for P 2	if
and only if |2(S) ∩ Iπ |≥ |S|− 1 for every S ⊆ I1 .
We say that a pixel (k, l) ∈ P is reachable in π from the pixel (i, j) ∈ P if 2(i, j, k, l)\{(i, j)} ⊆ Iπ, i.e., all pixels in the rectangular hull 2(i, j, k, l) have coefficient 0 in π, with the exception of (i, j).
Theorem 4.3 Let πx ≤ 1 be a valid inequality with π ∈ {−1, 0, 1}mn. If (a) every
pixel in Iπ is reachable from some pixel in Iπ and (b) for every p ∈ Iπ  there exist

0
q, qj ∈ Iπ
1
such that 2(q, qj) ∩ Iπ = {q, qj} and 2(q, qj) ∩ Iπ
—1
= {p}, then πx ≤ 1

1	1	—1
deﬁnes a facet of P 2 .
Theorem 4.3 allows us to derive several families of facet-inducing inequalities
πx ≤ 1 for P 2	with coefficients in {−1, 0, 1} (see Fig. 2 for an example), and
is the starting point for the subsequent theorems. It is important to note that Theorem 4.3 does not characterize all facet-inducing inequalities with coefficients


					
(i)	(ii)	(iii)	(iv)	(v)

Fig. 2. A valid inequality πx ≤ 1 that verifies the hypotheses of Theorem 4.3. The inequality is represented by specifying the nonzero coefficients of π in the corresponding pixels of the input matrix. The gray rectangles in subfigures (i) — (iii) show that Condition (a) of Theorem 4.3 is verified, while the gray rectangles in (iv) and (v) show that Condition (b) is also met.
in {−1, 0, 1}. Indeed, some of the following facet-inducing inequalities do not stem from this result directly.
Theorem 4.4 Let π ∈ {−1, 0, 1}mn. If Iπ = {(i1, j1), (i2, j2)} and Iπ = {(k, l)}⊆ 
1	—1
2(i1, j1, i2, j2), then πx ≤ 1 is valid and facet-inducing for P 2 .


Fig. 3. A valid inequality πx ≤ 1 that verifies the hypotheses of Theorem 4.4, with (i1, j1) = (1, 1), (i2, j2)= (3, 3), and (k, l)= (2, 2).
Theorem 4.4 is a corollary of Theorem 4.3 when i1 < k < i2 and j1 < l < j2 (see Fig. 5 for an example). Facetness in the cases k ∈ {i1, i2} and l ∈ {j1, j2} requires a slightly different proof.
Theorem 4.5 Let π ∈ {−1, 0, 1}mn with |Iπ| = |Iπ | + 1. If I  = {(it, jt)}	with
it ≤ it+1 and jt ≤ jt+1 for t = 1,...,k − 1, and 2(it, jt, it+1, jt+1) contains exactly
one pixel from Iπ  for t = 1,...,k − 1, then πx ≤ 1 is valid and facet-inducing for
m,n.
The family of facet-inducing inequalities specified by Theorem 4.5 includes the interval constraints xi1,j − xi2,j + xi3,j − xi4,j + ··· + xi2k+1,j ≤ 1, with it < it+1 for t = 1,..., 2k, coming from the full interval vectors polytope [6].
Theorem 4.6 Let π ∈ {−1, 0, 1}mn. If Iπ = {p1, p2, p3} and Iπ  = {q1, q2} such

that Iπ
1
∩ 2(p1, p2) ∩ 2(p1, p3)= {q1} and I—1
—1
∩ [2(p2, p3)\2(p1, p2)] = {q2}, then

πx ≤ 1 is valid and facet-inducing for P 2 .


Theorem 4.7 Let π ∈ {−1, 0, 1}mn. If Iπ
= {p1, p2, p3} and Iπ
= {q1, q2, q3}

such that
π  ∩ [2(p1, p2)\(2(p2, p3) ∪ 2(p1, p3))] = {q1},
π  ∩ [2(p2, p3)\(2(p1, p2) ∪ 2(p1, p3))] = {q2},
π  ∩ [2(p1, p3)\(2(p1, p2) ∪ 2(p2, p3))] = {q3},
then πx ≤ 1 is valid and facet-inducing for P 2 .



Fig. 4. A valid inequality πx ≤ 1 that verifies the hypotheses of Theorem 4.6, with p1 = (1, 1), p2 = (3, 2),
p3 = (5, 5), and q1 = (2, 2), q2 = (4, 4).


Fig. 5. A valid inequality πx ≤ 1 that verifies the hypotheses of Theorem 4.7, with p1 = (1, 3), p2 = (3, 5),
p3 = (5, 1), and q1 = (2, 4), q2 = (4, 4), q3 = (1, 1).
It is interesting to note that Theorems 4.4, 4.5 and 4.6 provide facet-inducing inequalities similar to the interval constraints of the full interval vectors polytope,
namely inequalities with |Iπ| = |Iπ | + 1. Theorem 4.7, on the other hand, provides
a facet-inducing inequality with |Iπ| = |Iπ |. It would be interesting to explore
whether this construction can be extended to |Iπ| > 3.
Using the same proof technique as in Theorem 4.3, we can show the following generalization.
Theorem 4.8 Let π ∈ {−1, 0, 1}mn with |Iπ| = |Iπ | + 1. Assume (a) every pixel
in Iπ is reachable from some pixel in Iπ. If there exists a list L = {R1, R2,..., Rk}
of subrectangles such that (b) every pixel in Iπ	is contained in Ri for some i ∈
π	π	π
{1,..., k}, (c) |Ri ∩ I1 | = |Ri ∩ I—1| +1 for i = 1,..., k, and (d) |I—1 ∩ (Ri \
 i—1 Rj)| =1 for i = 1,..., k, then πx ≤ 1 is facet-inducing for P 2 .

R1	R2	R3	R4
Fig. 6. A valid inequality πx ≤ 1 that verifies the hypotheses of Theorem 4.8. The gray rectangles in the subfigures represent the rectangles Ri of the list L of the hipothesis. Notice that hypothesis (b) of Theorem 4.3 is not satisfied.
Interestingly, hypotheses (b)-(d) of Theorem 4.8 seem to be necessary for
facetness of inequalities πx ≤ 1 with π ∈ {−1, 0, 1}mn having |Iπ| = |Iπ | +1 
and satisfying the hypothesis (a). We performed an exhaustive computational ver-
ification of all facet-inducing inequalities of P 2 , P 2 and P 2 , with the help of the

3,5
4,4
3,6

PORTA [5] software package. In all cases (approx. 7700 facet-inducing inequalities
for P 2 , 9900 facet-inducing inequalities for P 2 , and 47500 facet-inducing inequali-
3,5	4,4
ties for P 2 ) a list L satisfying the hypotheses was indeed found. Due to impractical

running times, larger instances could not be checked.

Facet-inducing inequalities with coefficients in {−2, 0, 1} and {−3, 0, 1}
We now explore valid inequalities with at least one coefficient greater than 1 in absolute value.
Theorem 4.9 Let π ∈ {−2, 0, 1}mn. If Iπ = {(i1, j1), (i2, j2), (i3, j3)} with i1 < i2,
j1 < j2, i3 ≤ min{i1, i2}, j3 ≥ max{j1, j2}, and Iπ  = {(i1, j2)}, then πx ≤ 1 is
valid and facet-inducing for P 2 .


Fig. 7. A valid inequality πx ≤ 1 that verifies the hypotheses of Theorem 4.9, with (i1, j1) = (1, 1), (i2, j2)= (2, 3), and (i3, j3)= (1, 4).


Note that the hypotheses concerning the pixels in Iπ
and in Iπ
imply that

(i1, j2) ∈ 2(S) for any S ⊆ Iπ with |S| ≥ 2, so Theorem 4.1 ensures that πx ≤ 1 is indeed valid (see Fig. 7 for an example). Facetness is implied by an argument generalizing the proof of Theorem 4.3.
Theorem 4.10 Let π ∈ {−3, 0, 1}mn.  If Iπ = {p1, p2, p3, p4} with 2(p1, p2) ∩
2(p3, p4)= {q} = Iπ , then πx ≤ 1 is valid and facet-inducing for P 2 .


Fig. 8. A valid inequality πx ≤ 1 that verifies the hypotheses of Theorem 4.10, with p1 = (3, 1), p2 = (2, 3),
p3 = (3, 4), p4 = (4, 3), and q = (3, 3).
It would be interesting to search for further configurations originating valid and facet-inducing inequalities with such large coefficients. In our experiments with small instances, we could not find facet-inducing inequalities with (normalized) integer coefficients outside the range {−3,..., 4}.
Conclusions
We have started in this work a polyhedral study of the polytope associated with a natural integer programming formulation for the maximum subarray problem for d = 2. Our objective is to identify strong families of valid inequalities that could be useful within a cutting plane procedure, or within a linear programming-based

rounding heuristic for this problem. The final goal of this analysis is to obtain a strong column generation algorithm for RPC.
We have found several families of facet-inducing inequalities, many of them with coefficients in {−1, 0, 1}. From a polyhedral point of view, it would be desirable to achieve a more thorough theoretical treatment of these inequalities as, e.g., providing necessary and sufficient conditions ensuring facetness for valid inequalities with coefficients in {−1, 0, 1}. We believe that Theorem 4.8 yields a promising basis for such a characterization, and proof of the remaining necessary condition could be addressed in a future work. Further, since polynomial algorithms for the maximum subarray problem are known, we pose the existence of an integer programming model for the problem with a totally unimodular matrix as an open question.
From a practical point of view, the computational complexity of the separation problems associated with the introduced families is of interest, in particular since exhaustive enumerations do not provide polynomial-time algorithms for all of these problems and, furthermore, may not be practical in medium- to large-sized instances. The design of fast heuristics for separating these families could be of practical interest as well.


References
Anil Kumar, V. S. and H. Ramesh, Covering rectilinear polygons with axis-parallel rectangles, in:
Proceedings of the Thirty-first Annual ACM Symposium on Theory of Computing, STOC ’99 (1999),
pp. 445–454.
URL http://doi.acm.org/10.1145/301250.301369

Applegate, D. A., G. Calinescu, D. S. Johnson, H. Karloff, K. Ligett and J. Wang, Compressing rectilinear pictures and minimizing access control lists, in: Proceedings of the Eighteenth Annual ACM- SIAM Symposium on Discrete Algorithms, SODA ’07 (2007), pp. 1066–1075.
URL http://dl.acm.org/citation.cfm?id=1283383.1283498

Bentley, J., Programming Pearls - Perspective on Performance, Comm. ACM 27 (1984), pp. 1087 – 1092.
Berman, P. and B. DasGupta, Complexities of efficient solutions of rectilinear polygon cover problems, Algorithmica 17 (1997), pp. 331–356.
URL https://doi.org/10.1007/BF02523677
Christof, T., PORTA - a Polyhedron Representation Transformation Algorithm, version 1.4.1.
URL  https://wwwproxy.iwr.uni-heidelberg.de/groups/comopt/software/PORTA/

Dahl, G., Polytopes related to interval vectors and incidence matrices, Linear Algebra and its Applications 435 (2011), pp. 2955 – 2960.
URL http://www.sciencedirect.com/science/article/pii/S0024379511004319

Hannenhalli, S., E. Hubbell, R. Lipshutz and P. A. Pevzner, “Advances in Biochemical Engineering/Biotechnology,” Chip Technology 77, Springer, Berlin, Heidelberg, 2002 .
Hegeds, A., Algorithms for covering polygons by rectangles, Computer-Aided Design 14 (1982), pp. 257 – 260.
URL http://www.sciencedirect.com/science/article/pii/001044858290104X
Heinrich-Litan, L. and M. E. Lu¨bbecke, Rectangle covers revisited computationally, J. Exp. Algorithmics
11 (2007).
URL http://doi.acm.org/10.1145/1187436.1216583
Masek, W. J., Some NP-Complete Set Covering Problems (1979), MIT, Unpublished Manuscript.


Scheithauer, G., Y. Stoyan and T. Romanova, Integer linear programming models for  the  problem  of  covering  a  polygonal  region  by  rectangles,  Radioelectronics &  Informatics  2  (2009),  pp.  4–13.  URL  https://cyberleninka.ru/article/n/
integer-linear-programming-models-for-the-problem-of-covering-a-polygonal-region-by-rectangles

Takaoka, T., Efficient algorithms for the maximum subarray problem by distance matrix multiplication, Electronic Notes in Theoretical Computer Science 61 (2002), pp. 191 – 200, CATS ’02, Computing: the Australasian Theory Symposium.
URL http://www.sciencedirect.com/science/article/pii/S1571066104003135

Tamaki, H. and T. Tokuyama, Algorithms for the maximum subarray problem based on matrix multiplication, in: Proceedings of the Ninth Annual ACM-SIAM Symposium on Discrete Algorithms, SODA ’98 (1998), pp. 446–452.
URL http://dl.acm.org/citation.cfm?id=314613.314823
