

Electronic Notes in Theoretical Computer Science 203 (2009) 37–53
www.elsevier.com/locate/entcs

Towards Component Verification in the Generic Component Framework
Julia Padberg, Hartmut Ehrig1
Fakult¨at IV – Informatik und Elektrotechnik Technische Universita¨t Berlin
Germany
Fernando Orejas2
Departament de Llenguatges i Sistemes Informa`tics Universitat Polit`ecnica de Catalunya
Barcelona, Spain

Abstract
The intention of this paper is to extend the generic component framework presented at FASE 2002 [6] to allow component verification based on export-import implications. In the generic component framework components with explicit import, export interfaces and a body specification connected by embeddings and transformations provide hierarchical composition of components with a compositional transformation semantics.
We introduce implications that relate sentences of the import stating what the component requires to sentences of the export stating what the component guarantees. The main result of this paper is that these import-export implications are compatible with the hierarchical composition as given in [6].
The second part illustrates how this abstract concept can be instantiated to Petri net systems.
Keywords: component architectures, component verification, Petri nets, temporal logic


Introduction
In [6] a generic component framework for system modeling was introduced for a large class of semi-formal and formal modeling techniques. According to this concept a component consists of a body, an import, and an export interface, and connections between import and body as well as export and body. We only require having suit- able notions of embeddings and transformations (e.g. refinements) between specifi- cations. This component technique is generic as it can be instantiated with different

1 Email: {padberg,ehrig}@cs.tu-berlin.de
2 Email:orejas@lsi.upc.edu

1571-0661/© 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.03.025

specification formalisms. Moreover, the connections can be considered generic as they also allow a great variety of instantiations. The basic idea for the generic com- ponent concept stems from data type specification, precisely the algebraic module specifications [5]. It was used for various related algebraic specification techniques as e.g. in [2,11]. The transfer to process description techniques was started in [22] where modules for graph transformation systems and local action systems were in- vestigated. In [16] Petri net modules were introduced independently of the generic framework, but were shown to be compatible in [20]. In [6] algebraic high-level nets and in [17] deterministic automata were demonstrated to be instantiations.
In this paper we extend the component concept with import-export implications of components that are formulas given in an adequate logic. In the export interface the export statement is guaranteed independently of the component’s environment provided the import requirement is met. Based on ideas presented at EKA 2006 [19] we present an approach to component verification that helps to guarantee specific properties. These properties are formalized in terms of a suitable logic over the ba- sic properties of a specification. The underlying idea is that components guarantee specific export statements provided that the import assumptions are satisfied. So, components are equipped with an additional import-export implication. For the hierarchical composition of a requiring component and a providing component the export statement of the providing component has to imply the require assumptions of the requiring component’s import. Then the result of the composition is a com- ponent that guarantees the original exports statements of the requiring component if the import assumptions of the providing component are met.
This paper is organized as follows. First we present in Section 2 the basic concepts and results at the abstract level of the generic component concept. In Section 3 we present the instantiation to place/transition net systems and temporal logic. We conclude with a discussion of related work and the practical impact of this approach.

Component Verification for Generic Components
As the approaches in [6,7,4] this work employs generic specifications, embeddings and transformations to form components. Since not all classes of embeddings and transformations are suitable for this purpose we have to state some general require- ments first. In the concrete specification technique the validity of these requirements needs to be proved when instantiating the generic concept.

General Assumptions of the Transformation based Approach
Our generic technique requires a defined class of specifications together with trans- formations and embeddings. The transformations define a class of refinements for the specifications, so they are used for the connection between export interface and the component body. Since there exist so many notions of refinement, even for a single specification technique, this assumption should not be further formalized at the abstract level. Nevertheless, it has to be spelled out for the instantiation of the

concept.
We require an identity of specifications and a composition operation for trans- formations and embeddings.

Definition 2.1 (Extension Property)
A transformation framework T consists of a class of transformations that includes identical transformations, is closed under composition, and satisfies the following extension property :
For  each  transformation  trafo  :  SPEC1  =⇒  SPEC2  and  each  em-
bedding  i1	:	SPEC1	→	SPEC'	there  is  a  selected  transformation
trafo' : SPEC' =⇒ SPEC' with embedding i2 : SPEC2 → SPEC' ,
1	2	2

called the extension of trafo with respect to i1, leading to the adjacent extension diagram (1). In-
SPEC1
  i1  SP EC'

tuitively, each refinement from SPEC1 to SPEC2
via trafo can be extended to a refinement from
traf o	(1)
cz  i2 
traf o'
cz

'	'	'
SPEC2
 SP EC'

SPEC1 to SPEC2 via trafo .	2
Moreover, we need the possibility to compose vertically and to decompose hori- zontally extension diagrams as stated subsequently.

Definition 2.2 (Vertical composition of extension diagrams)
Given the diagram below and let the squares (1) and (2) be extension diagrams, then the composed square (1 + 2) is an extension diagram as well.

SPEC1   i1  SP EC'

traf o1
(1)
traf o'

cz i2  	cz

SPEC2
 SP EC'

traf o2
(2)
traf o'

cz i3  	cz

SPEC3
 SP EC'


Definition 2.3 (Horizontal decomposition of extension diagrams)
Given the diagram below and let the outer square (1 + 2) be an extension diagram
with i1 = i'' ◦ i' , then there exists trafo'' : SPEC'' =⇒ SPEC'' yielding the two
1	1	1	2
extension diagrams (1) and (2) below.


i1
z˛
SPEC1 	1  SP EC''   1	 SP EC'


traf o
cz
SPEC2 

(1)

'
1

traf o''
cz
SP EC''

(2)

''
1
traf o'
cz
SP EC'

  i2
2 i2
i2
 ¸	2

Components and Composition
Based on the requirements explained above, we are now able to define component specifications and the corresponding hierarchical composition operation.
Definition 2.4 (Component)
A component specification Comp = (IM P, EXP, BOD, imp, exp) consists of a

body specification BOD, an import specification IMP with
EXP

an embedding
imp
IMP −→ BOD
and an export specification
exp

EXP with a transformation EXP =	.
 imp   cz

⇒ BOD

Import-Export Implications
IMP
B OD

Components are self-contained units with a well-defined syntax and semantics. In
[6] semantics of components are defined by considering each possible environment expressed by each possible transformation of the component’s import. According to the transformation-based semantics the notion of import-export implications char- acterize the component with respect to its environment. Based on an adequate logic calculus that allows the formulation of formulas and their translation along transformations, import-export implications can be defined for components.
To define a logic over a specification we need to relate the vocabulary of the logic to the specification SPEC, so we need some signature Σ for SPEC. Then SPEC ∈ Σ the set of all specifications with signature Σ.
Definition 2.5 (Underlying logic)
The underlying logic (Sen(Σ), |=) over the signature Σ consists of the set of formulas over that signature Sen(Σ) and a relation |=Σ⊆ Σ × Sen(Σ) where Σ denotes the set of all specifications with signature Σ.
Definition 2.6 (Translation of the underlying logic)
Given the underlying logic (Sen(Σ), |=) then for each transformation trafo : SPEC1 =⇒ SPEC2 there has to be a translation of sentences Ttrafo : Sen(Σ1) → Sen(Σ2) with SPECi ∈ Σi for 1 ≤ i ≤ 2.
The translation has to be compatible with the morphism composition, i.e. for trans- formations trafoi : SPECi =⇒ SPECi+1 with i ≤ i ≤ 2 there is the translation Ttrafo1◦traf o2 = Ttrafo1 ◦ Ttrafo2 : Sen(Σ1) → Sen(Σ3) for SPECi ∈ Σi.
The translation along an identity has to yield an identical translation, i.e.Tid = ID.
Note that SPEC |= ϕ then SPEC' |= Ttrafo(ϕ) is not demanded as it is too strong for most process specification. E.g. liveness considered as a temporal logic formula over some process specification is usually not preserved by morphisms.
Definition 2.7 (Import-export implication for components)
Given a component Comp = (IMP, EXP, BOD, imp, exp) then an import-export implication ρ ⇒ γ consists of ρ ∈ Sen(IMP ) and γ ∈ Sen(EXP ).
The import-export implication provides information on the component’s body at its interfaces.  This information concerns the assumptions and guarantees of

a component in an arbitrary environment. So, satisfaction of the import-export implications is formulated with respect to an arbitrary environment, formalized by an arbitrary transformation of the import interface. Then we require that if this environment satisfies the translated import assumption, then the corresponding extension will satisfy the translated export statement.

Definition 2.8 (Satisfaction of an import-export implication)
Given a component Comp = (IM P, EXP, BOD, imp, exp) then the import-export implication ρ ⇒ γ with ρ ∈ Sen(IMP ) and γ ∈ Sen(EXP ) is satisfied if we have SPEC |= Ttrafo(ρ) ⇒ SPEC' |= Ttrafo'◦exp(γ) for all extension diagrams:

EXP
exp
  imp   cz

IMP
traf o
B OD
traf o'

cz imp' 	cz

SPEC
SPEC'


A component with guarantees is a component that ensures the export statement for any possible environment provided the import assumptions are met.

Definition 2.9 (Component with guarantees)
A component with guarantees Comp = (IMP, EXP, BOD, imp, exp, ρ, γ) consists of a component (IMP, EXP, BOD, imp, exp) together with the import-export im- plication ρ ⇒ γ that has to be satisfied.

Then hierarchical composition allows the propagation of the export statements, provided the export statement of the imported component implies the import re- quirement of the importing component. This is defined by the connecting condition.

Definition 2.10 (Connecting condition)
Given components Compi = (IMPi, EXPi, BODi, impi, expi, γi, ρi) for i ∈ {1, 2} and a connection transformation con : IMP1 =⇒ EXP2 then the connecting con- dition is satisfied if we have for all transformations trafo : EXP2 =⇒ SPEC:

SPEC |= Ttrafo(γ2) ⇒ SPEC |= Ttrafo◦con(ρ1)

Definition 2.11 (Hierarchical Composition)
Given components Compi = (IMPi, EXPi, BODi, impi, expi, γi, ρi) for i ∈ {1, 2} and a connection transformation con : IMP1 =⇒ EXP2 then the hierarchical composition Comp3 of Comp1 and Comp2 via con : IMP1 =⇒ EXP2 is defined by Comp3 := Comp1 ◦con Comp2 = (IMP3, EXP3, BOD3, imp3, exp3, γ1, ρ2) with imp3 := imp' ◦imp2 and exp3 := h◦exp1 as depicted below where (1) is an extension

diagram :


EXP3 = EXP1
exp1

	imp1	  cz

IMP1
con
cz
EXP2
exp2



(1)
B OD1

h


exp3

 imp2   cz
imp'
c,z 

IMP3 = IMP2	B OD2 	1	 B OD3

imp3

In order to have a compositional approach to component verification we now need to ensure that the hierarchical composition preserves the components guarantees in a suitable way.
Fact 2.12 (Hierarchical composition propagates guarantees)
Given components Comp1 and Comp2 with guarantees and a connection con : IMP1 =⇒ EXP2 satisfying the connecting condition, then the result of the hi- erarchical composition Comp3 = Comp1 ◦con Comp2 is again a component with guarantees.
So, we have to show that the hierarchical composition Comp3 = Comp1 ◦con
Comp2 satisfies the import-export implication ρ2 ⇒ γ1.

Proof. We need to show that SPEC |= Ttrafo(ρ2) ⇒ SPEC' |= Ttrafo'◦exp (γ1)
for any extension (1) in the diagram below:

EXP3 = EXP1
exp1
	imp1	  cz

IMP1
con
B OD1

cz
EXP2	h
exp2
 imp2   cz	imp'	cz
IMP3 = IMP2	B OD2 	1	 B OD3

traf o
(1)
traf o'

cz	  cz
SPEC	i	SPEC'

Due to extension decomposition (Def. 2.3) we have the three extension diagrams

(2), (3) and (4) with i = i1 ◦ i2:


EXP3 = EXP1
exp1

	imp1	  cz

IMP1
con
cz
EXP2
exp2
B OD1

(2)	h

 imp2   cz	imp'	cz
IMP3 = IMP2	B OD2 	1	 B OD3

traf o
(3)
traf o''
(4)
traf o'

cz	i2	  cz	i1	  cz

SPEC
SPEC''
S_P EC'

i

So, we have:
SPEC |= Ttrafo(ρ2) ⇒ SPEC'' |= Ttrafo''◦exp (γ2)
as Comp2 has guarantees,
SPEC'' |= Ttraf o''◦exp (γ2) ⇒ SPEC'' |= Ttraf o''◦exp ◦con(ρ1)
2	2
due to the connecting condition, and
SPEC'' |= Ttraf o''◦exp ◦con(ρ1) ⇒ SPEC' |= Ttraf o'◦h◦exp (γ1)
2	1
as Comp1 has guarantees and due to vertical composition in Def. 2.2

So, we directly conclude:
SPEC |= Ttrafo(ρ2) ⇒ SPEC' |= Ttrafo'◦h'◦exp (γ1)


Basic Concepts for Verification using Petri Net Com- ponents
In this section we give an instantiation of the generic framework and illustrate the basic concepts in terms of place/transition systems and temporal logic. To obtain the results of the previous section we have to ensure that the modeling technique has specific properties, namely the extension property, the composition and decom- position of extension diagrams. And the underlying logic, in this instantiation a linear time logic, needs to be provided with a suitable translation of formulas along the morphisms.
In [16] Petri net components have been first introduced. The import interface specifies resources which are used in the construction of the body, while the export interface specifies the functionality available from the Petri net component to the outside world. The body implements the functionality specified in the export inter- face using the imported functionality. Here, we need to treat the markings explicitly

as we want to verify behavior properties of the components.

Components of Petri Net Systems
First we give a short intuition of the underlying formalism. We use the algebraic notion of Petri nets as introduced in [12]. Hence, a place/transition (PT) net is given by the set of transitions and the set of places and the pre and post domain
function; N = (T  pre  P ⊕) where P⊕ is the free commutative monoid over P –
post
or the set of finite multisets over P . So, an element w ∈ P⊕ can be presented as a linear sum w = Σp∈P λpp and we can extend the usual operations and relations as ⊕, g, ≤, and so on.  The initial marking (and markings in general) can be
understood both as a linear sum, i.e. m ∈ P⊕ as well as a finitely based mapping,
i.e. m^ : P → N.
We use much simpler morphisms than in [16] that do not preserve any specific properties as safety or liveness. The import morphism imp is a plain, injective morphism and describes where the resources of the import are used in the body. The export morphism exp is a t-partial, injective morphism. So, we have a very loose interpretation of refinement: those transition that are not mapped represent some not explicitly specified subnet of the target net.
Definition 3.1 (PT net systems and morphisms)
A PT net system PS = (N, m) is given by a PT net N = (P, T, pre, post) where pre, post : T → P⊕ represent the pre and post domain of a transition, and m : P → N is the initial marking.
A t-partial morphisms h : P S1 → P S2 is a mapping where hP : P1 → P2 is a total function and hT : T1 → T2 is a partial function such that h is arc preserving; for all t ∈ dom(fT ) we have: h⊕ ◦ pre1 = pre2 ◦ hT (t) and h⊕ ◦ post1 = post2 ◦ fT (t).
P	P
Morphisms are plain if hT : T1 → T2 is a total function as well. The class of injective plain morphisms is denoted by I.
Morphisms are marking strict if m1(p) = m2(h(p)) for all p ∈ P1. The class of marking strict t-partial, injective morphisms is denoted by E .
PT net systems and t-partial morphism comprise the category PStp.
Note that the initial marking does not play a role in this category as the mor- phisms do not take it into account. So, all PT systems that consist of the same net, but have different initial markings are isomorphic in PStp. However, we have a unique marking for extension diagrams in Fact 3.4.
The classes I and E are closed under composition and both include identities, but note that I is closed under composition with isomorphisms, whereas E is not.

Fact 3.2 (Pushouts in the category PStp)

Given PT systems PS 
for 0 ≤ i ≤ 2 and morphisms	h1
g1	in the

i	PS1 ←− P S0 −→ P S2

category PS
then here is a pushout	h2
g2	that can be constructed

tp	PS1 −→ PS3 ←− PS2
component-wise for places and transitions and with an arbitrary initial marking for
PS3.


The proof (for details see [18]) uses the standard construction of pushouts in the category of sets Set and in the category of partial sets parSet.


Petri net components consist of three PT systems: the import PT sys- tem (IMP, mI ), the export PT system (EXP, mE), and the body PT system (BOD, mB). Note that there is no marking compatibility required for imp ∈ I. This allows the deletion of parts of the initial marking during the hierarchical com- position, and is needed to remove ”pseudo-initial” tokens that will be provided by the environment (see Subsect. 3.3).
Definition 3.3 (PT system component)
A PT system component PC = ((IMP, mI ), (EXP, mE), (BOD, mB), imp, exp) consists of the import PT system (IMP, mI ), the export PT system (EXP, mE),


BOD, mˆB)
B
exp∈E
←−	EXP, mˆE
I	−→

Extension diagrams are pushouts where one morphism is marking strict and injective and the other is injective and plain. We need to prove that these can be constructed component-wise for any pair of I- and E -morphisms.
Fact 3.4 (Extension diagrams of I- and E -morphisms)
Given PT nets Ni = (Pi, Ti, prei, posti) and PT systems PSi = (Ni, m^i) for 0 ≤ i ≤
P S1 ←− P S0 −→ P S2	1	1
a pushout	h2	g2	with
PS1 −→ PS3 ←− PS2
m2(p2) ; g2(p2) = p ∈/ h2(P1)
3
m1(p1) ; h2(p1) = p
that is an extension diagram with g2 ∈I and h2 ∈ E.
Proof.
P S3 = (N3, m^3) is pushout by construction.	PS0   h1  P S1

Plain morphisms are preserved as total morphisms are pushout stable in parSet. Injective morphisms are preserved as injective morphisms are pushout stable in
g1	(1)	h2
J	J 
PS2	g2  P S3

Set as well as in parSet.  The construction of m^3
directly yields that h2 is marking strict. So, g2 ∈ I and h2 ∈ E. Moreover, the initial marking m^3 is uniquely determined by the requirement h2 ∈ E .	 

Remark 3.5 (Pushout construction)
It is interesting to note that the construction of the PT net N3 coincides with the corresponding construction in [20] where we have used substitution morphisms instead of t-partial morphisms. In fact, the transitions T3 of N3 can be constructed as T3 = (T1 − h1T (T0)) + T2 with inclusion g2T and partial function h2T . These are jointly surjective, s.t. pre3(t) – and similar post3 – is uniquely defined by pre2(t) for t ∈ T2 and by pre1(t) otherwise (for details see [18]).
Fact 3.4 yields the extension property in Def. 2.1. Together with the composition and decomposition of pushouts it also yields the vertical composition in Def. 2.2 and horizontal decomposition in Def. 2.3 of extension diagrams.
Fact 3.6 (Vertical composition of extension diagrams)
Given the diagram below and let the squares (1) and (2) be extension diagrams, then the composed square (1 + 2) is an extension diagram as well.
P S1 	h1  SP EC'
g1	(1)	h2
J  g2  	J 

SPEC2
 SP EC'

g3	(2)	h3
J  g4  	J 

SPEC3
 SP EC'


Proof. The composition of pushouts yields the pushout (1 + 2). Since marking- strict, injective, and t-partial morphisms are closed under composition respectively, we have g3 ◦ g1 ∈ E as well as h3 ◦ h2 ∈ E and h1, g4 ∈ I by assumption. Hence, (1 + 2) is an extension diagram.	 
Fact 3.7 (Horizontal decomposition of extension diagrams)
Given the diagram below and let the outer square (1 + 2) be an extension diagram

with h1 = h'' ◦ h' , then there exists h' : PS' =⇒ PS'
yielding the two extension

1	1	2	1	2
diagrams (1) and (2) below.

h1
z˛
PS0 	1	 P S' 	1	 P S1

g1	(1)
J 


'	(2)	h2
J	J 

PS2
'	 P S'
''	 P S3

g2	2	g2    ¸
g2
Proof. For the decomposition we construct (1) as an extension diagram, so it is

pushout and h'
∈ E. As (1 + 2) and (1) are pushouts, and (2) with g''
as the

induced pushout morphism commutes, we use the pushout decomposition property to conclude that (2) is pushout as well. As plain, injective morphisms are pushout stable we have that (1) and (2) are extension diagrams.	 

Temporal Logic
We use a notation closely related to standard linear time logics (LTL) as e.g. in [13] or [9]. For each net we assume a set of atomic propositions AP over the markings of the net. For a marking m ∈ P⊕ the satisfaction of a atomic proposition is given if the proposition p is true for m.

A LTL formula is an element of the language

f := p |¬ f | f ∧ f | X f | f U f
constructed out of atomic propositions p to which boolean connections ¬ (nega- tion) and ∧ (conjunction), as well as the temporal operators ”until” U and ”next” X are applied.
Since a LTL requires runs of a system we now define runs of a PT system
(N, m^ ) as an infinite sequence of markings δ := m0 · m1 · m2 · ... where m0 = m^ is
the initial marking. Either we have some t ∈ T for each i ≥ 0 so that mi[t > mi+1
or we repeat the last marking, i.e. if there is no t ∈ T such that mi[t > mi+1 then
mj = mi for all j > i.

We assume a set of atomic propositions AP on markings, so that for each mark- ing π : P⊕ → 2AP assigns truth values to the propositions. Thereby we have π(m)( p ) = true for p ∈ AP and m ∈ P⊕ is denoted by p ∈ π(m).
Then we define inductively for formulas f :
for an atomic proposition (δ, j) |= p iff p ∈ π(mj) for p ∈ AP
for the boolean operators (δ, j) |= ¬ f ∈ AP iff not (δ, j) |= f
(δ, j) |= f1 ∧ f2 ∈ AP iff (δ, j) |= f1 and (δ, j) |= f2
for the until operator (δ, j) |= f1 U f2 iff
there is some k ≥ j with (δ, k) |= f2
and for all j ≤ i ≤ k holds (δ, i) |= f1
for the next operator (δ, j) |= X f iff (δ, j + 1) |= f
We abbreviate formulas using the usual boolean operators as they can be defined using the negation and the conjunction. Analogously we can define further temporal operators as ”eventually” or ”future” F by F f := true U f and the operator ”always” or ”globally” G f := ¬ F ¬ f . The set of all LTL formulas with respect to the set of atomic propositions AP is denoted by F.
A net system (N, m^ ) |= f satisfies an LTL formula f ∈ F if for all runs δ of

Definition 3.8 (Underlying logic for PT system components)
The underlying temporal logic (F, |=) over the net N consist of the formulas F over the net N and the relation |=N ⊆ N × F where N = {(N, m)|m ∈ P⊕} the set of all PT systems consisting of the net N and some initial marking m ∈ P⊕.
Next we define the translation of LTL formulas based on a mapping of the atomic

propositions that is compatible with the mapping of the places and show then to be compatible with the composition of morphisms as required in Def. 2.6.
Definition 3.9 (Translation of a formula)
Given PT systems (Ni, mi) with atomic propositions APi and πi : P⊕ → APi for 1 ≤ i ≤ 2, a morphism h : PS1 → P S2, and a mapping of the atomic propositions hAP : AP1 → AP2 that is compatible with the mapping of the places, i.e. π2 ◦ h⊕ =
hAP ◦ π1, then we define Th : FAP1 → FAP2 inductively:
for atomic propositions Th( p ) := hAP ( p )
for the boolean operators Th(¬ f ) := ¬Th( f )
Th( f1 ∧ f2 ) := Th( f1 ) ∧ Th( f2 )
for the until operator Th( f1 U f2 ) := Th( f1 ) U Th( f2 )
for the next operator Th( X f ) := X Th( f )
for the eventually operator Th( F f ) := F Th( f )
for the always operator Th( G f ) := G Th( f )
Fact 3.10 (Composition of Translation)
Given mappings of atomic propositions hAP : AP1 → AP2 and gAP : AP2 → AP3
compatible with h : P S1 → P S2 and g : P S2 → P S3, then we have Tg ◦ Th = Tg◦h.
Proof. We have compatibility of g ◦ h : PS1 → PS3 with π1 and π3 due to π3 ◦ (gP ◦ hP )⊕ = gAP ◦ π2 ◦ h⊕ = gAP ◦ hAP ◦ π1. Moreover (g ◦ h)AP = gAP ◦ hAP , so we can prove inductively the composition of the translations.	 
Results 3.11 (Component-based Verification) We now have
PT system components with guarantees (see Def. 2.9), and
hierarchical composition propagating guarantees (see Def. 2.12).
Due to the fact that PT systems are an instantiation of the generic component framework in Sect. 2.

Example
In this section we give an example to illustrate our approach. The example is merely a structural example without a specific meaning. For the practical impact of this approach see the discussion in Section 4 or [21].

In our example the set AP of of atomic propositions on markings of a PT system (N, m) with places P is given by AP = N × P and for each marking m : P → N we have π(m) = {(m(p), p)|p ∈ P}. This means (n, p) ∈ AP is true under marking m if n = m(p). This allows the definition of the mapping hAP : AP1 → AP2 with hAP (n, p) = (n, hP (p)). This mapping is well-defined as translations are given for E -morphisms only, so hP is injective.
In Fig. 2 we consider a component Comp1 = (IMP1, EXP1, BOD1, ρ1, γ1) where the export statement γ1 := ( G F p5) ensures that the marking with one

token on place p5 is always reachable in any extension of BOD1, provided that the corresponding extension of the import behaves like the transition t2, i.e. once there is a token on the pre-place eventually there will be a token on the post-place and it will stay there. This is denoted by the import requirement ρ1 := (p3 ⇒ F G p4). This excludes refinements of the import where for example a transition removes the token from place p4, or where a transition puts more than one token to place p4.
In the subsequent figures morphisms are indicated by identical names of places and transitions. Those nodes that are not in the codomain of a morphism remain without a name. So, the morphisms are all inclusions and the translations of for- mulas are identities and hence omitted in this example.
Fig. 3 depicts the component Comp2 = (IMP2, EXP2, BOD2, ρ2, γ2) where
ρ2 := (p1 ⇒ F G p2) expresses that if there is one token on place p1 then eventually there will be one token on place p2 and it will stay there. The export statement γ2 := (p3 ⇒ F G p4) states the same for the places p3 and p4.
Both components Comp1 and Comp2 are components with guaran- tees, that is the import-export impli- cations hold for arbitrary extensions. The body of Comp1 still satisfies γ1 if the import is extended by an ar- bitrary PT system PTS in such a

way that if a token is on place p3 then there will be a token on place
Fig. 1. Arbitrary extension of BOD1

p4 and it will stay there. This is quite obvious and the argument is given here informally: by construction of the extension diagram the PT system PTS will be glued into the PT system BOD1 as sketched in Fig. 1 and this PT system will still satisfy the temporal logic formula γ1 := ( G F p5) provided the PT system PTS 
satisfies ρ1 := (p3 ⇒ F G p4). The argument that component Comp2 satisfies its
import-export implication is similar.
Fig. 2. Comp1	Fig. 3. Comp2




The composition of the two compo- nents Comp1 ◦con Comp2 = Comp3 = (IMP2, EXP1, BOD3, ρ2, γ1) is depicted in Fig. 4. It is achieved by gluing the bodies BOD1 and BOD2 along IMP1 resulting in BOD3. The connecting transformation maps the system (IMP1, mI1) to the system (EXP2, mE2) regardless of the markings.
The component Comp3 now guarantees that a marking with a token on place p5 can be always reached again, provided the exten- sion of the import satisfies the import require- ment that a token on place p1 implies that there is eventually a token on place p2 and it will stay there. Note that a token in the initial marking of the body needs not be rep- resented in the export as well. In that case it is independent of the environment and has to be preserved. The marked place in the middle of BOD2 in component Comp2 (in Fig. 3) is


Fig. 4. Comp3

preserved by the composition and is still marked in BOD3 in component Comp3. If a token in the initial marking of the body is represented in the export as well, then it may be dependent on the importing component, and hence needs to be deleted by the composition. So, a token in the initial marking of the export can be either one that is required by the component importing it or it is provided by the firing of the importing component. This is for the imported component indistinguish- able. Either the token is represented in the initial marking of the import of the importing component then it is preserved, or it is not represented in the import then it is deleted. So, ”pseudo-initial” tokens are eliminated by the construction of the extension diagram. The token on place p3 in BOD2 and EXP2 is an example therefore.

Open Questions
As this paper is a first step towards component verification in the generic component framework open questions are still left, e.g.:
Translation of formulas
In this approach here we use a translation that is defined place-wise. It is a straightforward approach that it easy to follow. But it has the drawback that the initial markings are not necessarily mapped onto each other. So, for example the
formula γ1 := ( G F p5) states that the system (EXP1, mE1) is reversible. But
for the system (BOD3, mˆB3) this formula does not state reversibility.

Quantiﬁers
In order to translate formulas with quantifiers the scope of the formula needs to be extended according to the target system. Then it would be possible to translate formulas that deal with all reachable markings or all transitions, as needed for example for liveness.
Satisfaction of import-export implications
Since the import-export implications have to hold for arbitrary extensions the techniques for model checking cannot be applied. In the examples this has not yet been a problem. But for larger applications some proof technique would be very desirable.

Conclusion
Summarizing, we have an assume-guarantee approach to component-based veri- fication that is independent of the underlying specification technique. Formally, a component is given by three specifications, the body specification, the import and the export interface. To express properties of components, an appropriate logic formalism has to be required that allows expressing the desired properties. A component is then equipped with two additional logic formulas that represent the import-export implication. The import assumptions describe in an abstract way the properties the underlying component needs to have to ensure the desired behavior. Then the export guarantees some property denoted by the export statement. Hi- erarchical composition allows concluding the import-export implication where the providing component’s import assumption implies the requiring component’s export statement.

Related work
In model checking the typical approach to verification of components is to check the properties for all possible environments. But there are various approaches, e.g. [10,3,8] that share the underlying hypothesis that the required property can be achieved only in specific environments. In [8] a framework for assume-guarantee paradigm is introduced that uses labeled transition systems to model the behavior of communicating components in a concurrent system. In [3] the interfaces are modeled using input/output automata. The parallel composition of the interfaces is given and criteria for the compatibility are presented, but this approach merely concerns the interfaces. In [10] certain properties, as deadlock freedom are checked based on assumptions that the component makes about the expected interaction behavior of other components.
In [1] concurrent automata are introduced that describe the concurrent behavior of input and output ports in terms of their operations. Considering the automata as the components body and the input ans output ports as the import and export in- terfaces, respectively, maybe allows fitting this approach into the general framework presented in this paper.

Practical Impact
The area of controls for discrete event based systems needs an approach of mod- eling and structuring systems as well as the verification of the systems properties. In [21] we propose to model and verify system properties of discrete event based systems using Petri nets components. Based on import-export implications of Petri net components the temporal logic formula given in the export interface is guaran- teed independently of the component’s environment. We investigate the approach’s feasibility for controlling a technical system and describe parts of a model plant for a packing process using Petri net components. The verification of basic properties makes use of the hierarchical composition and the propagation of the import-export implications.
The Petri net based sequence controller is modeled using the tool Netlab [14] which is a modeling, analysis and simulation environment that also supports the design and synthesis of discrete event - or hybrid systems under Matlab/Simulink. Netlab is a graphic P/T net editor, that allows loading and saving in PNML [15]. We intend to add structuring and verification means to Netlab based on Petri net components as introduced in this paper.

References
J.F.K. Bowles and S. Moschoyiannis. Concurrent logic and automata combined: a semantics for components. In Proc. of CONCUR 2006 - Foundations of Coordination Languages and Software Architectures (FOCLASA’06). Electronic Notes in Theoretical Computer Science, Elsevier Science, 2007. to appear.
F. Cornelius, M. Baldamus, H. Ehrig, and F. Orejas. Abstract and behaviour module specifications.
Mathematical Structures in Computer Science, 9:21–62, 1999.
L. de Alfaro and T.A Henzinger. Interface automata. In ESEC/FSE 01: Proceedings of the Joint 8th European Software Engineering Conference and 9th ACM SIGSOFT International Symposium on the Foundations of Software Engineering, 2001.
H. Ehrig, B. Braatz, M. Klein, F. Orejas, S. P´erez, and E. Pino. Object-oriented connector-component architectures. In Proc. International Workshop on Formal Foundations of Embedded Software and Component-based Software Architectures (FESCA 2005), volume 141 of Electronic Notes in Theoretical Computer Science, Elsevier Science, pages 123–151, 2005.
H. Ehrig and B. Mahr. Fundamentals of Algebraic Specification 2: Module Specifications and Constraints, volume 21 of EATCS Monographs on Theoretical Computer Science. Springer Verlag, Berlin, 1990.
H. Ehrig, F. Orejas, B. Braatz, M. Klein, and M. Piirainen. A Generic Component Concept for System Modeling. In Proc. FASE 2002: Formal Aspects of Software Engineering, volume 2306 of Lecture Notes in Computer Science, pages 32–48. Springer Verlag, 2002.
H. Ehrig, J. Padberg, B. Braatz, M. Klein, F. Orejas, S. P´erez, and E. Pino. A generic framework for connector architectures based on components and transformations. In Proc. International Workshop on Formal Foundations of Embedded Software and Component-based Software Architectures (FESCA 2004), volume 108 of Electronic Notes in Theoretical Computer Science, Elsevier Science, pages 53–67, 2004.
D. Giannakopoulou, C. P˘as˘areanu, and H. Barringer. Assumption generation for software component verification. In Proceedings of ASE-2002: The 17th IEEE Conference on Automated Software Engineering. IEEE CS Press, 2002.
C. Girault and R. Valk, editors. Systems Engineering: a Guide to Modelling, Verification and Applications. Springer, 2003.
Paola Inverardi, Alexander L. Wolf, and Daniel Yankelevich. Static checking of system behaviors using derived component assumptions. ACM Trans. Softw. Eng. Methodol., 9(3):239–272, 2000.

Rosa M. Jim´enez and Fernando Orejas. An algebraic framework for higher-order modules. In FM’99
- Formal Methods, World Congress on Formal Methods in the Development of Computing Systems, volume 1709 of Lecture Notes in Computer Science, pages 1778–1797. Springer, 1999.
J. Meseguer and U. Montanari. Petri Nets are Monoids. Information and Computation, 88(2):105–155, 1990.
Zohar Manna and Amir Pnueli. Temporal Verification of Reactive Systems: Safety. Springer Verlag, 1995.
Institut fu¨r Regelungstechnik, Rheinisch-Westf¨alische Technische Hochschule Aachen. Petrinetz-Tool Netlab (Windows), 2007. http://www.irt.rwth-aachen.de/typo3/index.php?id=101&L=0.
Ph. Orth, U. Ku¨ssel, and D. Abel. Netlab und Netlab Toolbox fu¨r Mat-lab/Simulink-ein Werkzeug zum Rapid Control Prototyping von Steuerungen mittels Petrinetzen. In Tagungsband Entwurf komplexer Automatisierungssysteme EKA 2006, pages 343–353. 2006.
J. Padberg. Petri net modules. Journal on Integrated Design and Process Technology, 6(4):121–137, 2002.
Julia Padberg. Integration of the generic component concepts for system modeling with adhesive HLR systems. EATCS Bulletin, 87:138–155, 2005.
J. Padberg. Formal foundation for transformation-based approach to component verification. Technical Report 2006-12, Technische Universit¨at Berlin,Fakult¨at IV, 2006.
J. Padberg. Formale Techniken fu¨r die Beschreibung von Software-Architekturen. In R. Reussner and
W. Hasselbring, editors, Handbuch der Software-Architektur, pages 465–476. d-punkt Verlag, 2006.
J. Padberg and H. Ehrig. Petri net modules in the transformation-based component framework. Journal of Logic and Algebraic Programming, 67:198–225, 2005.
Julia Padberg and Uwe Ku¨ssel. A component-based verification approach based on Petri net components. In Proc. FORMS/FORMAT 2007 - ”Formal Methods for Automation and Safety in Railway and Automotive Systems”, pages 40–50. GZBV, 2007.
M. Simeoni. A Categorical Approach to Modularization of Graph Transformation Systems using Refinements. PhD thesis, Universit`a Roma La Sapienza, 1999.
