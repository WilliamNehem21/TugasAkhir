Electronic Notes in Theoretical Computer Science 72 (2007) 87–100	
www.elsevier.com/locate/entcs

Conditional Term Graph Rewriting with Indirect Sharing
Enno Ohlebusch1
Faculty of Technology University of Bielefeld 33501 Bielefeld, Germany

Abstract
For reasons of efficiency, term rewriting is usually implemented by term graph rewriting. In term rewriting, expressions are represented as terms, whereas in term graph rewriting these are represented as directed graphs. Unlike terms, graphs allow a sharing of common subexpressions. In previous work, we have shown that conditional term graph rewriting is a sound and complete implementation for a certain class of CTRSs with strict equality, provided that a minimal structure sharing scheme is used. In this paper, we will show that this is also true for two different extensions of normal CTRSs. In contrast to the previous work, however, a non-minimal structure sharing scheme can be used. That is, the amount of sharing is increased.
Keywords: Conditional term rewriting system, term graph rewriting, structure sharing


Introduction
The main result in [15] states that conditional term graph rewriting is a sound and complete implementation of conditional term rewriting for a certain class of CTRSs with strict equality (in a CTRS with strict equality the condition si = ti is satisfied for a substitution σ if siσ and tiσ are reducible to a common ground constructor term; cf. [9]), provided that a minimal structure sharing scheme is used. Soundness ensures that the graph implementation cannot give incorrect results, while completeness ensures that it gives all results. The proof of this result depends on the validity of the parallel moves lemma for these CTRSs. In this paper, we will show that two different extensions of normal CTRSs also satisfy the parallel moves lemma. As a consequence, it will be proven that conditional term graph rewriting is a sound and complete implementation of the two classes of CTRSs, too. However, in contrast to [15], we do not use a minimal structure sharing scheme here. In other words, the amount of sharing is increased.

1 Email: enno@TechFak.Uni-Bielefeld.DE

1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2002.09.008



Table 1

It is well-known that orthogonal normal 2-CTRSs satisfy the parallel moves lemma. Since these systems are the starting point of our investigations, we will first recall the relevant definitions; more details can be found in [16].
In a CTRS (F, R) rules have the form l → r ⇐ s1 = t1,... , sk = tk  with l, r, s1,... , sk, t1,... , tk ∈ T (F, V). The left-hand side l may not be a variable. We frequently abbreviate the conditional part of the rule, that is, the sequence s1 = t1,... , sk = tk, by c. If a rewrite rule has no conditions, we write l → r, demand that Var(r) ⊆ Var(l), and call l → r an unconditional rule. As in [13], rewrite rules l → r ⇐ c will be classified according to the distribution of variables among l, r, and c, as shown in Table 1.
An n-CTRS contains only rewrite rules of type n. For every rule l → r ⇐ c, we define the set of extra variables by
EVar(l → r ⇐ c)= (Var(r) ∪ Var(c)) \ Var(l).
Thus a 1-CTRS has no extra variables, a 2-CTRS has no extra variables on the right-hand sides of rules, and a 3-CTRS may contain extra variables on the right- hand sides of rules provided that these also occur in the conditions.
The unconditional TRS obtained from a CTRS R by omitting the conditions in its rewrite rules is denoted by Ru. Note that (F , Ru) is an unconditional TRS in the usual sense provided that (F, R) is a 2-CTRS. This is not true for 3-CTRSs because rules of type 3 may contain variables on the right-hand sides of rules which do not occur on the corresponding left-hand side. For a CTRS R, notions like left-linearity and constructor term are defined via the system Ru. Since these properties solely depend on the left-hand sides of the system Ru, they are well-defined even if Ru is not a TRS in the usual sense.
The = symbol in the conditions can be interpreted in different ways which lead to different rewrite relations associated with R. In a normal CTRS every rule l → r ⇐ s1 = t1,... , sk = tk in R satisfies the restriction that every ti is a ground normal form with respect to Ru. 2 The rewrite relation →R associated with a normal CTRS R is defined by →R =  n≥0 →Rn , where →R0 = ∅ and, for n > 0, s →Rn t if and only if there is a rule l → r ⇐ c in R, a substitution σ : V → T (F, V) with D(σ) = Var(l → r ⇐ c), and a context C[ ] such that s = C[lσ], t = C[rσ],

and siσ →∗
ti for all si = ti in c. In other words, in a normal CTRS a condition



2 The question of whether a term is a normal form with respect to R is in general undecidable.

si = ti is satisfied for a substitution σ if siσ reduces to the ground Ru-normal form
ti.
If one drops the ground Ru-normal form requirement in the definition of normal CTRSs and allows variables on the right-hand sides ti of the conditions, then there are at least two possibilities to define the rewrite relation:

A condition si = ti is satisfied for a substitution σ if siσ →∗
tiσ (oriented

systems).
A condition si = ti is satisfied for a substitution σ if siσ reduces to a ground Ru-normal form vi such that vi = tiσ (oriented systems with normalizing conditions).
Note that both oriented systems and oriented systems with normalizing condi- tions subsume normal systems. Oriented conditional rewrite systems were stud- ied in [5,7,6,8,3,20,12,16] among others. In particular, Suzuki et al. [20] investi- gated the class of orthogonal properly oriented right-stable 3-CTRSs (the notions right-stability and proper orientation are defined in Definitions 2.5 and 2.9, respec- tively). They showed that these systems are level-confluent (a CTRS R is called level-confluent if every relation →Rn is confluent) although they do not satisfy the parallel moves lemma. Conditional rules from an oriented system will be denoted by l → r ⇐ s1 → t1,... , sk → tk. Oriented systems with normalizing conditions have not yet been studied. They have the advantage over oriented systems that the reduction phase and the matching phase are separated (first try to reduce siσ to ground Ru-normal form and then check whether ti matches the normal form). Conditional rules from oriented systems with normalizing conditions will be denoted by l → r ⇐ s1 →! t1,... , sk →! tk.
Let l1 → r1 ⇐ c1 and l2 → r2 ⇐ c2 be renamed versions of rewrite rules of R such that they have no variables in common. Suppose l1 = C[t] with t /∈ V such that tσ = l2σ for a most general unifier σ. We call ⟨C[r2]σ, r1σ⟩ ⇐ c1σ, c2σ a conditional critical pair of R. If the two rules are renamed versions of the same rewrite rule of R, we do not consider the case C[] =  . A conditional critical pair
⟨s, t⟩ ⇐ s1 → t1,... , sn → tn is feasible if there is a substitution σ which satisfies

sjσ →∗
tjσ for all j ∈ {1,... , n}. Otherwise it is called infeasible. A conditional

critical pair ⟨t, t⟩⇐ s1 → t1,... , sn → tn is called trivial.
A left-linear CTRS is orthogonal if it has no conditional critical pair, and it is almost orthogonal if every conditional critical pair is trivial and results from an overlay (i.e., an overlap at root positions).
It will be shown in this paper that the parallel moves lemma holds for the following classes of CTRSs:
orthogonal right-stable oriented 2-CTRSs,
orthogonal oriented 3-CTRSs with normalizing conditions that are right-stable and properly oriented.
As a consequence, it will be proven that conditional term graph rewriting is a sound and complete implementation of the two classes of CTRSs.

The Parallel Moves Lemma
We start with the parallel moves lemma for orthogonal normal 2-CTRS; see Bergstra and Klop [5].
Definition 2.1 The set Pos(t) of positions in t ∈T (F, V) is defined by:
{ε}	if	t ∈V 
Pos(t)= 
⎩ {ε}∪ {i.p | p ∈ Pos(ti) and 1 ≤ i ≤ n}	if	t = f (t1,... , tn)
A position p within a term t is thus a sequence of natural numbers (where ε denotes the empty sequence and the numbers are separated by dots) describing the path from the root of t to the root of the subterm occurrence t|p, where


t|p
= ⎧⎨ t	if	p = ε
⎩ ti|q	if	p = i.q, 1 ≤ i ≤ n, and t = f (t1,... , tn).

Furthermore, we define VPos(t)= {p ∈ Pos(t) | t|p ∈ V}. That is, VPos(t) denotes the set of all variable positions in t.
Positions are partially ordered by the so-called preﬁx ordering ≥, i.e., p ≥ q if there is an o such that p = q.o. In this case we say that p is below q or q is above
p. Moreover, if p /= q, then we say that p is strictly below q or q is strictly above p. Two positions p and q are independent or disjoint, denoted by p  q, if neither one is below the other.
Definition 2.2 Let A : s →p,l→r⇐c t be a rewrite step in a CTRS R and let
q ∈ Pos(s). The set q\A of descendants of q in t is defined by:
⎧ {q}	if q < p or q  p,
q\A =	{p.p3.p2 | r|p3 = l|p1 } if q = p.p1.p2 with p1 ∈ VPos(l)
⎪⎪⎩ ∅	otherwise.
If Q ⊆ Pos(s), then Q\A denotes the set q∈Q q\A. The notion of descendant is extended to rewrite sequences in the obvious way.
Definition 2.3 Let R be a CTRS. We write s →Rn t if t can be obtained from s by contracting a set of pairwise disjoint redexes in s by →Rn . We write s →t if s →Rn t for some n ∈ N. The minimum such n is called the depth of s →t. The relation → is called parallel rewriting.
The following parallel moves lemma holds for orthogonal normal 2-CTRS; see Bergstra and Klop [5].
Lemma 2.4 If u →Rm u1 and u →Rn u2, then there is a term u3 such that u1 →Rn u3 and u2 →Rm u3. Moreover, the redexes contracted in the parallel reduction step u1 →Rn u3 (u2 →Rm u3) are the descendants in u1 (u2) of the redexes contracted in u →Rn u2 (u →Rm u1).

The preceding parallel moves lemma can be extended to almost orthogonal sys- tems and one may allow infeasible conditional critical pairs. It is thus an immediate corollary to Lemma 2.4 that these systems are level-confluent.
Our next goal is to show that orthogonal right-stable oriented 2-CTRS also satisfy the parallel moves lemma.
Definition 2.5 A CTRS R is called right-stable if every rewrite rule l → r ⇐
s1 = t1,... , sk = tk in R satisfies the following conditions for all i ∈ {1,... , k}:
i−1
(Var(l) ∪	Var(sj = tj) ∪ Var(si)) ∩ Var(ti)= ∅
j=1
and ti is either a linear constructor term or a ground Ru-normal form.
Example 2.6 Given a function mod such that evaluating mod(x, n) gives the re- mainder r of x divided by n (where x and n are natural numbers) and a function eq which tests equality of two natural numbers, we define a function f ilter which filters all elements out of a list of natural numbers that have remainder r when divided by n.
f ilter(n, r, nil) → nil
f ilter(n, r, x : xs) → x : f ilter(n, r, xs) ⇐ mod(x, n) → r', eq(r, r') → true
f ilter(n, r, x : xs) → f ilter(n, r, xs)	⇐ mod(x, n) → r', eq(r, r') → false
The above rules constitute a left-linear right-stable oriented 2-CTRS.
It is convenient to further partition the extra variables in a right-stable system as follows.
Definition 2.7 The set of all bound extra variables in a right-stable conditional rewrite rule ρ : l → r ⇐ s1 = t1,... , sk = tk from R is defined by

EVarb(ρ)=   Var(ti)
i=1
and the set of free variables is EV arf(ρ)= EVar(ρ) \ EV arb(ρ).
For example, if ρ is the rule
f (x) → true ⇐ y ∗ y → z, mod(x, z) → s(0) we have EVarf(ρ)= {y} and EVarb(ρ)= {z}.
Lemma 2.8 The parallel moves lemma holds for orthogonal right-stable oriented 2-CTRSs.
The restrictions imposed in Lemma 2.8 are really necessary as counterexamples in [5,20] show. Analogously to Lemma 2.4, the preceding parallel moves lemma can be extended to almost orthogonal systems and one may allow infeasible conditional critical pairs. Hence it follows that the CTRS from Example 2.6 is level-confluent.

Next we show that under certain conditions, the parallel moves lemma also holds for oriented 3-CTRSs with normalizing conditions (recall that in these systems a condition si = ti is satisfied for a substitution σ if siσ reduces to a ground Ru-normal form vi such that vi = tiσ).
Definition 2.9 A CTRS R is called properly oriented if every conditional rewrite rule l → r ⇐ s1 = t1,... , sk = tk in R with Var(r) /⊆ Var(l) satisfies Var(si) ⊆
i−1
j=1
Definition 2.10 An orthogonal oriented 3-CTRS R with normalizing conditions is called good-natured if it is right-stable and properly oriented.
As an example consider the good-natured CTRS Rfib which computes the Fi- bonacci numbers.
0+ x → x
s(x)+ y → s(x + y)
f ib(0) → ⟨0, s(0)⟩
f ib(s(x)) → ⟨z, y + z⟩⇐ f ib(x) →! ⟨y, z⟩
The following lemma states that in a good-natured CTRS the extra-variables on right-hand sides of rules are not really extra because they belong to the bound variables.
Lemma 2.11 For every rule ρ : l → r ⇐ s1 →! t1,... , sk →! tk in a good-natured CTRS R, we have
Var(r) /⊆ Var(l) implies EVar(ρ)= EV arb(ρ),
Var(r) ⊆ Var(l) ∪ EVarb(ρ).
In good-natured CTRSs extra variables which occur on the right-hand side of a rule are bound (get a value) during the evaluation of the conditions. More pre- cisely, if the left-hand side l of a rewrite rule matches a subterm of the term to be evaluated via substitution σ, then all variables in l are bound. Now the condi- tions are evaluated from left-to-right. The left-hand side s1 of the first condition always contains only variables which also occur in l and thus already have a binding. Then s1σ is rewritten until a ground Ru-normal form, say t' , is obtained. The first condition is satisfied if its right-hand side t1 matches this normal form t' . Now if

t1 = C'[x1,... , xn], where all variables are displayed, then t1 matches t'
if and only

if t' = C'[w1,... , wn]. This is because t1 is linear and its variables do not occur in l
(and s1). Hence every variable in t1 is bound during the match. Now the left-hand side s2 of the second condition contains only variables which occurred already left to it (in l and t1) and are thus bound. The instantiated term s2 is then reduced to a ground Ru-normal form and so on. If all the conditions are satisfied, then all vari- ables in the conditions are bound in the process of evaluating the conditions. Hence the reduct of lσ is well-defined (and unique as we shall see) because the right-hand side r of the rule contains only variables which also appear in the conditions or in

l. These systems allow, for example, local definitions like let and where constructs in good-natured programming.
Lemma 2.12 Good-natured 3-CTRS also satisfy the parallel moves lemma.
It is an immediate consequence of the preceding lemma that every good-natured 3-CTRS R is level-confluent. Again, this parallel moves lemma (and hence level- confluence) can be extended to almost orthogonal systems which may contain infea- sible conditional critical pairs. As a matter of fact, by carefully checking the proofs in Suzuki et al. [20], one finds that level-confluence of good-natured 3-CTRS can be proven in the same manner. However, the results of the next section crucially depend on the validity of the parallel moves lemma. This lemma does not hold if we consider oriented systems instead of oriented systems with normalizing conditions as the following simple example taken from [20, Example 4.4] shows.
Example 2.13 Let
⎧ f (x) → y ⇐ x → y
R =	a → b
⎪⎪⎩ b → c
Then f (a) →R1 a and f (a) →R2 c but not a →R2 c.
Conditional Term Graph Rewriting
For reasons of efficiency, term rewriting is usually implemented by term graph rewriting. In term rewriting, expressions are represented as terms, whereas in term graph rewriting these are represented as directed graphs. Unlike terms, graphs al- low a sharing of common subexpressions. In term graph rewriting expressions are evaluated by rule-based graph transformations. Here we will only consider directed acyclic graphs.
In order to illustrate the advantage of term graph rewriting over term rewriting, consider the rule double(x) → x + x. In the term rewriting step

double	+


the subterm t is copied. If t is a large term, then this operation can be very costly in terms of space and time. Moreover, after this reduction step the value (normal form) of t has to be computed twice unless t is already in normal form. Therefore, this reduction step duplicates the work that is necessary to evaluate t. The usual

way of avoiding these problems is to create two pointers to the subterm t instead of copying it.
double	+


In the resulting directed acyclic graph, the subterm t is shared. An evaluation of t in the directed acyclic graph corresponds to a parallel evaluation of the two oc- currences of t in the term t + t. Thus representing expression as graphs instead of terms saves both time and space. Investigations of term graph rewriting include [19,4,18,10,11,1,14,15,2,17]. It has been shown by Kurihara and Ohuchi [11] that directed acyclic graphs can be represented by well-marked terms; thus graph trans- formations can be modeled by rewriting well-marked terms. We first recapitulate some basic notions. Most of them stem from [11].
Let F be a signature and V be a set of variables. Let M be a countably infinite set of objects called marks (we will use natural numbers as marks). Let F∗ =
{fμ | f ∈ F,μ ∈ M } be the set of marked function symbols. For all fμ ∈ F∗, the arity of fμ coincides with that of f . Moreover, we define symbol(fμ)= f and mark(fμ) = μ. Analogously, let V∗ = {xμ | x ∈ V,μ ∈ M } be the set of marked variables, symbol(xμ) = x, and mark(xμ) = μ. The set of marked terms over F∗ and V∗ is defined in the usual way and is denoted by T (F∗, V∗). The set of all marks appearing in a marked term t∗ ∈ T (F∗, V∗) is denoted by marks(t∗). The
set Tw(F∗, V∗) of well-marked terms over F∗ and V∗ is the subset of T (F∗, V∗) such that t∗ ∈ Tw(F∗, V∗) if and only if, for every pair (t∗, t∗) of subterms of t∗,
1  2
mark(root(t∗)) = mark(root(t∗)) implies t∗ = t∗. For example, the term 01 +0 01 is
1	2	1	2
well-marked but 01 +1 01 is not. Well-marked terms have an exact correspondence to
labeled directed acyclic graphs; the reader is referred to [11] for details. In contrast
to [11], we are solely interested in well-marked terms. Thus, throughout the whole paper, marked stands for well-marked. Two subterms t∗ and t∗ of a marked term
1	2
t∗ are shared in t∗ if t∗ = t∗; e.g. 01 and 01 are shared in 01 +0 01.
1	2
If t∗ is a marked term, then e(t∗) denotes the unmarked term obtained from
t∗ by erasing all marks. Two marked terms s∗ and t∗ are bisimilar 3 (denoted by s∗ ∼ t∗) if and only if e(s∗) = e(t∗). The marks of a marked term s∗ are called fresh w.r.t. another marked term t∗ if marks(s∗) ∩ marks(t∗) = ∅. A marked substitution σ∗ : V∗ → T (F∗, V∗) is a substitution which satisfies xμσ∗ ∼ yνσ∗ for all xμ, yν ∈ D(σ∗) with symbol(xμ) = symbol(yν). This definition of marked substitution ensures that the unmarked substitution σ obtained from σ∗ by erasing all marks is well-defined (i.e., σ really is a substitution). The notion marked context

3 The origin of the notion “bisimilarity” is explained in [2].

is defined in the obvious way.
Definition 3.1 A rule l∗ → r∗ ⇐ c∗ is a marked version of a rule l → r ⇐ c in R if e(l∗) = l, e(r∗) = r, e(c∗) = c, and, for all xμ, yν ∈ Var(l∗ → r∗ ⇐ c∗), symbol(xμ)= symbol(yν) implies mark(xμ)= mark(yν).
The last condition can be rephrased as: every marked occurrence of a variable x ∈ Var(l → r ⇐ c) must have the same mark in l∗ → r∗ ⇐ c∗. For the sake of simplicity, marks on variables in marked rewrite rules will be omitted from now on because these marks are unique anyway. So variables in rewrite rules are maximally shared. In contrast to [15], we do not use a minimal structure sharing scheme here (different structure sharing schemes are discussed in [11]). In that paper, in an application of a marked rule l∗ → r∗ ⇐ c∗ all the marks on function symbols in r∗, c∗, and xσ∗ (for every extra variable x in l → r ⇐ c) were assumed to be fresh and mutually distinct. Here xσ∗ gets fresh marks only if x is a free variable. If x is a bound variable (i.e., it occurs in some t∗), then xσ∗ is the marked term that is
determined by the “match” v∗ ≈ t∗σ∗, where v∗ is a reduct of s∗σ. Let us formally
i	i	i	i
define such a “match”.
Definition 3.2 Let v∗ and t∗ be marked terms with Var(v∗) ∩ Var(t∗)= ∅. Sup- pose moreover that t∗ is a linear constructor term. Let Var(t∗) = {x1,... , xm}
and p1,... , pm ∈ Pos(t∗) such that t∗|p  = xj. We say that t∗ matches v∗ via
substitution σ∗, denoted by v∗ ≈ t∗σ∗, if e(v∗)= e(t∗σ∗) and xjσ∗ = v∗|p .
Now we are in a position to define the conditional term graph rewriting relation.

Definition 3.3 Let R be a right-stable oriented CTRS and s∗, t∗ be marked
terms.	Let ⇒R =  ∅ and, for n  >  0, define s∗ ⇒R t∗ if there exists
0	n
a marked version l∗ → r∗ ⇐ s∗ → t∗,... , s∗ → t∗ of a conditional rewrite rule
1	1	k	k
ρ : l → r ⇐ s1 → t1,... , sk → tk from R, a marked substitution σ∗, and a marked
context C∗[,... , ] such that
s∗ = C∗[l∗σ∗,... , l∗σ∗] and t∗ = C∗[r∗σ∗,... , r∗σ∗],
l∗σ∗ is not a subterm of C∗[,... , ],
for every 1 ≤ i ≤ k, there are marked terms v∗ such that

s∗σ∗ ⇒∗
v∗ ≈ t∗σ∗ if t∗ is a linear constructor term

i	Rn−1  i	i	i

s∗σ∗ ⇒∗
v∗ ∼ t∗
if t∗ is a ground Ru-normal form

i	Rn−1  i	i	i
all marks on function symbols in r∗, s∗, t∗, and xσ∗ (for every free extra variable
i	i
x ∈ EV arf(ρ)) are mutually distinct and fresh w.r.t. s∗.
l∗σ∗ is called the contracted marked redex in s∗. We use the notation s∗ ⇒l∗ σ∗ t∗ in order to specify the contracted marked redex. Note that all shared subterms l∗σ∗ are replaced simultaneously by r∗σ∗.
If we are dealing with oriented CTRSs with normalizing conditions instead of oriented CTRSs, then it is further required in (iii) that e(v∗) is a ground Ru-normal
form.

In order to illustrate how term graph rewriting works, let R be the CTRS
twoTimes(nil) → nil
twoT imes(x : xs) → x : x : twoTimes(xs) fourTimes(nil) → nil
fourTimes(x : xs) → zs ⇐ twoTimes(x : xs) →! ys, twoTimes(ys) →! zs
We have fourTimes0(02 :1 nil3) ⇒R 02 :11 02 :12 02 :14 02 :15 nil17 because
twoTimes4(02 :5 nil3) ⇒R 02 :6 02 :7 twoTimes8(nil3)
⇒R 02 :6 02 :7 nil9
and
twoT imes10(02 :6 02 :7 nil9) ⇒R 02 :11 02 :12 twoTimes13(02 :7 nil9)
⇒R 02 :11 02 :12 02 :14 02 :15 twoTimes16(nil9)
⇒R  02 :11 02 :12 02 :14 02 :15 nil17
Note that in 02 :11 02 :12 02 :14 02 :15 nil17 every element in the list is shared.

Adequacy
In this section it will be shown that conditional term graph rewriting is adequate for simulating conditional term rewriting in orthogonal right-stable 2-CTRSs and good- natured 3-CTRSs, respectively. More precisely, we will show that the mapping e which erases all marks from a well-marked term is an adequate mapping in the sense of Kennaway et al. [10], that is, it is surjective, preserves normal forms, preserves reductions, and is cofinal. Surjectivity ensures that every term can be represented as a directed acyclic graph (well-marked term). The normal form condition ensures that a graph is a final result of a computation if the term which it represents also is, and vice versa. Preservation of reduction ensures that every graph reduction sequence represents some term reduction sequence. Cofinality ensures that for every term rewriting computation, there is a term graph rewriting computation which can be mapped, not necessarily to the term rewriting computation, but to some extension of it.
Theorem 4.1 Let R be an orthogonal right-stable oriented 2-CTRS. For all n ∈ N,
⇒Rn  is an adequate implementation of →Rn , that is,
e is surjective,
∀t∗ ∈ Tw(F∗, V∗): t∗ ∈ NF ( ⇒R ) if and only if e(t∗) ∈ NF (→R ),

∀s∗ ∈ Tw(F∗, V∗): if s∗ ⇒∗
t∗, then e(s∗)→∗
e(t∗),

∀s∗ ∈ Tw(F∗, V∗): if e(s∗)→∗ u, then there is a t∗ ∈ Tw(F∗, V∗) such that
∗	∗	t∗ and u→∗ e(t∗).

Proof. We use induction on n.
Surjectivity is obvious.
The if direction is easily shown. For an indirect proof of the only if direc- tion, suppose e(t∗) /∈ NF (→R ), i.e., e(t∗) = C[lσ]→R C[rσ] by using the rule ρ : l → r ⇐ s1 → t1,... , sk → tk at position p. So, for every si → ti, we
have siσ→∗	tiσ. Let l∗ and σ∗ be marked version of l and σ such that
t∗|p = l∗σ∗ (note that l∗ is left-linear). Let l∗ → r∗ ⇐ s∗ → t∗,... , s∗ → t∗ be
1	1	k	k
a marked version of ρ such that all marks on r∗, s∗, and t∗ are fresh w.r.t.
i	i
t∗ and mutually distinct.	Furthermore, σ∗ is extended to EVar(ρ) as fol-
lows: for all z ∈ EV arf(ρ) let zσ∗ be a marked version of zσ such that all marks are mutually distinct and fresh w.r.t. t∗, r∗,s∗, and t∗. Let C∗[,... , ]
i	i
be the marked context such that t∗ = C∗[l∗σ∗,... , l∗σ∗] and l∗σ∗ is not
a subterm of C∗[,... , ]. We extend σ∗ successively to the bound variables

EVarb(ρ). We have e(s∗σ∗) = s1σ→∗
= t1σ. It follows from the induc-

1	Rn−1
tive hypothesis that there exists a marked term v∗ such that s∗σ∗ ⇒∗	v∗
1	1	Rn−1  1
and t1σ→∗	e(v∗).	If t1 is a ground Ru-normal form, then t1 = e(v∗)
Rn−1	1	1
and hence v∗ ∼ t∗. Otherwise, if t1 is a linear constructor term, it can be
written as t1 = C1[x1,... , xm], where all variables are displayed and pair-

wise distinct.  It follows that e(v∗) = C1[w1,... , wm], where xiσ→∗
wi.

1	Rn−1
Hence v∗ has the form C∗[w∗,... , w∗ ].	We define a substitution σ∗ on
1	1	1	m	1
Var(l) ∪ EV arf(ρ) ∪ Var(t1) by xσ∗ = xσ∗ for all x ∈ Var(l) ∪ EVarf(ρ)

and xiσ∗ = w∗ for 1 ≤ i ≤ m. Clearly, v∗ ≈ t∗σ∗
and s2σ→∗	e(s∗σ∗).

i	1	1 1
Rn−1	2 1

Since s2σ→∗
t2σ as well, it follows from level-confluence of →R that there

is a common reduct u2 of e(s∗σ∗) and t2σ w.r.t. →Rn−1 . Furthermore, there
2 1
is a substitution τ2 such that u2 = t2τ2 because t2 is a linear constructor term
or a ground Ru-normal form (in the latter case τ is the empty substitution).
Applying the inductive hypothesis to e(s∗σ∗)→∗	t2τ2 yields a marked term

v∗ such that s∗σ∗ ⇒∗
2
v∗ and t2τ2→∗
1	Rn−1
e(v∗). As above, we can extend

2	2 1
Rn−1  2
Rn−1	2

σ∗ to Var(t2) yielding σ∗. By continuing along these lines, there exist v∗ and
1	2	i
an extension σ∗ of σ∗ to the bound variables EV arb(ρ) =  k	Var(tk) such

that s∗σ∗ ⇒∗
k	1
v∗ ≈ tiσ∗. Therefore, t∗ ⇒R
i=1
C∗[r∗σ∗,... , r∗σ∗] which con-

i  k	Rn−1  i	k	n
tradicts t∗ ∈ NF ( ⇒R ).
We proceed by induction on the length l of s∗ ⇒∗	t∗.	The base case

l = 0 clearly holds. Thus consider s∗ ⇒l∗ σ∗
u∗ ⇒l
Rn
t∗. According to the

Rn	Rn ∗ ∗

inductive hypothesis on l, e(u∗)→∗
e(t∗). Since s∗ ⇒l σ
u∗, we have s∗ =

C∗[l∗σ∗,... , l∗σ∗], l∗σ∗ is not a subterm of C∗[,... , ], u∗ = C∗[r∗σ∗,... , r∗σ∗],
and, for every s∗ → t∗, there is a marked term v∗ such that s∗σ∗ ⇒∗	v∗ ≈

i	i	i
i	Rn−1 i

t∗σ∗.	Let σ = e(σ∗), i.e., xσ = e(xσ∗) for all x ∈ D(σ∗).	By the in-

ductive hypothesis on n, e(s∗)σ→∗
e(v∗) = e(t∗)σ. Hence lσ→R
rσ and

e(s∗) →+
n
e(t∗).
i	Rn−1	i	i	n

We use induction on the length l of e(s∗)→l
u. The proof is illustrated in

Fig. 1. The case l = 0 is trivial. So we consider e(s∗)→l
u¯→Rn
u. By the

inductive hypothesis on l, there exists a t¯∗ ∈ Tw(F∗, V∗) such that s∗ ⇒∗
t¯∗

e(s∗) −→l	u¯	−→R  u
n
∗⏐ Rn	∗⏐ Rn



s∗	=⇒∗
e(t¯∗) −→∗	v −→∗
t¯∗	=⇒∗
e(t∗) t∗




and u¯→∗
Fig. 1. Proof of Theorem 4.1.
e(t¯∗). Let t¯ = e(t¯∗). Suppose u¯ = C[lσ]→R

C[rσ]= u by using the

rule ρ : l → r ⇐ s1 → t1,... , sk → tk at the position p, i.e., C[lσ]|p = lσ. By
∗
the parallel moves lemma for →Rn , there is a v ∈ T (F, V) such that u →	v
and t¯→Rn v. In particular, the redexes contracted in the step t¯→Rn v are the

descendants p\(u¯→∗
t¯) of p in t¯. Let Q = p\(u¯→∗
t¯). Note that Q ⊆ Pos(t¯)

consists of pairwise independent positions. For every q ∈ Q, t¯∗|q can be written
as t¯∗|q = l∗τ ∗, where l∗ is a marked version of l and τ ∗ is a marked substitution.
q q	q	q
As in the proof of (ii), one can show that l∗τ ∗ ⇒R r∗τ ∗. Let
q q	n	q
Q' = {q' ∈ Pos(t¯∗) | t¯∗|q' = l∗τ ∗ for some q ∈ Q}
q q
Note that Q ⊆ Q'. It is not difficult to prove that Q' consists of pairwise inde- pendent positions. Let t∗ be the marked term obtained from t¯∗ by contracting

all the redexes l∗τ ∗. Let τq = e(τ ∗). Since t¯→R
v by contracting the redexes in

q q	q	n

Q and t¯→Rn
e(t∗) by contracting the redexes in Q', it follows that v →R
e(t∗)

by contracting the redexes in Q' \ Q. All in all, s∗ ⇒∗
t∗ and u→∗
e(t∗).


Theorem 4.2 If R is a good-natured 3-CTRS, then ⇒Rn is an adequate imple- mentation of →Rn for every n ∈ N.
Proof. The proof is essentially the same as that of Theorem 4.1. Only the second paragraph of the proof of (ii) needs some modifications.
We extend σ∗ successively to the bound variables EV arb(ρ). Since e(s∗σ∗) = 

∗ Rn−1
t1σ and t1σ is a ground Ru-normal form, it follows from the inductive

hypothesis that there is a marked term v∗ such that s∗σ∗ ⇒∗	v∗ and e(v∗)= t1σ.
1	1	Rn−1  1	1
If t1 is a ground Ru-normal form, then t1σ = t1 and hence v∗ ∼ t∗. Otherwise, if
1	1
t1 is a linear constructor terms, it can be written as t1 = C1[x1,... , xm], where all
variables are displayed and pairwise distinct. It follows that e(v∗)= C1[w1,... , wm], so that v∗ has the form C∗[w∗,... , w∗ ]. We define σ∗ on Var(t1) by xiσ∗ = w∗ for
1	1	1	m	i
1 ≤ i ≤ m. Clearly, v∗ ≈ t∗σ∗ and e(s∗σ∗)= s2σ. By continuing along these lines,
1	1	2
there exist v∗ and an extension of σ∗ to the bound variables EVarb(ρ) such that

s∗σ∗ ⇒∗
v∗ ≈ t∗σ∗. Therefore, t∗ ⇒R
C∗[r∗σ∗,... , r∗σ∗] which contradicts t∗ ∈

i	Rn−1 i	i	n
NF ( ⇒Rn ).	 
There are the following corollaries for the classes of CTRSs under consideration.

Corollary 4.3  ⇒R is an adequate implementation of →R.

It is a direct consequence of the preceding results that ⇒R is a sound and complete implementation of →R in the sense of Barendregt et al. [4]. Recall that soundness ensures that the graph implementation of a CTRS cannot give incorrect results, while completeness ensures that term graph rewriting gives all results.
Corollary 4.4  ⇒R is a sound and complete implementation of →R, i.e.,

s∗ ⇒∗
t∗ ∈ NF ( ⇒R ) implies e(s∗)→∗
e(t∗) ∈ NF (→R) (soundness),

∀s∗ ∈ Tw(F∗, V∗): if e(s∗)→∗ u ∈ NF (→R), then there is a marked term t∗
such that s∗ ⇒∗ t∗ ∈ NF ( ⇒R ) and e(t∗)= u (completeness).
Note that in the entire section, there is only one place at which we made use of the fact that R is orthogonal: Theorems 4.1 (iv) and 4.2 (iv) crucially depend on the fact that the parallel moves lemma holds for →Rn . Since the parallel moves lemma remains valid if R is almost orthogonal, so do all of the preceding results if we replace orthogonality with almost orthogonality.

References
Ariola, Z. and J. Klop, Equational term graph rewriting, Fundamenta Informaticae 26 (1996), pp. 207– 240.
Ariola, Z., J. Klop and D. Plump, Bisimilarity in term graph rewriting, Information and Computation
156 (2000), pp. 2–24.
Avenhaus, J. and C. Lor´ıa-S´aenz, On conditional rewrite systems with extra variables and deterministic logic programs, in: Proceedings of the 5th International Conference on Logic Programming and Automated Reasoning, Lecture Notes in Artificial Intelligence 822 (1994), pp. 215–229.
Barendregt, H., M. v. Eekelen, J. Glauert, J. Kennaway, M. Plasmeijer and M. Sleep, Term graph rewriting, in: Proceedings of Parallel Architectures and Languages Europe, Lecture Notes in Computer Science 259 (1987), pp. 141–158.
Bergstra, J. and J. Klop, Conditional rewrite rules: Confluence and termination, Journal of Computer and System Sciences 32 (1986), pp. 323–362.
Dershowitz, N. and M. Okada, A rationale for conditional equational programming, Theoretical Computer Science 75 (1990), pp. 111–138.
Dershowitz, N., M. Okada and G. Sivakumar, Canonical conditional rewrite systems, in: Proceedings of the 9th Conference on Automated Deduction, Lecture Notes in Computer Science 310 (1988), pp. 538–549.
Ganzinger, H. and U. Waldmann, Termination proofs of well-moded logic programs via conditional rewrite systems, in: Proceedings of the 3rd International Workshop on Conditional Term Rewriting Systems, Lecture Notes in Computer Science 656 (1993), pp. 113–127.
Hanus, M., On extra variables in (equational) logic programming, in: Proceedings of the 12th International Conference on Logic Programming (1995), pp. 665–679.
Kennaway, J., J. Klop, M. Sleep and F.-J. d. Vries, On the adequacy of term graph rewriting for simulating term rewriting, ACM Transactions on Programming Languages and Systems 16 (1994),
pp. 493–523.
Kurihara, M. and A. Ohuchi, Modularity in noncopying term rewriting, Theoretical Computer Science
152 (1995), pp. 139–169.
Marchiori, M., Unravelings and ultra-properties, in: Proceedings of the 5th International Conference on Algebraic and Logic Programming, Lecture Notes in Computer Science 1139 (1996), pp. 107–121.
Middeldorp, A. and E. Hamoen, Completeness results for basic narrowing, Applicable Algebra in Engineering, Communication and Computing 5 (1994), pp. 213–253.

Ohlebusch, E., A uniform framework for term and graph rewriting applied to combined systems, Information Processing Letters 73 (2000), pp. 53–59.
Ohlebusch, E., Implementing conditional term rewriting by graph rewriting, Theoretical Computer Science 262 (2001), pp. 311–331.
Ohlebusch, E., “Advanced Topics in Term Rewriting,” Springer-Verlag, 2002.
Plump, D., Term graph rewriting, in: Ehrig, H., Engels, G., Kreowski, H.-J., and Rozenberg, G., editors, Handbook of Graph Grammars and Computing by Graph Transformation, vol. 2, World Scientific (1999), pp. 3–61.
Sleep, M., M. Plasmeijer and M. v. Eekelen, editors, “Term Graph Rewriting,” John Wiley & Sons, 1993.
Staples, J., Computation on graph-like expressions, Theoretical Computer Science 10 (1980), pp. 171– 185.
Suzuki, T., A. Middeldorp and T. Ida, Level-confluence of conditional rewrite systems with extra variables in right-hand sides, in: Proceedings of the 6th International Conference on Rewriting Techniques and Applications, Lecture Notes in Computer Science 914 (1995), pp. 179–193.
