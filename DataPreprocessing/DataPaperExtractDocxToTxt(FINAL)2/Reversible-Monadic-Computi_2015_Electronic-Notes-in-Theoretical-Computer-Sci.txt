Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 319 (2015) 217–237
www.elsevier.com/locate/entcs
Reversible Monadic Computing
Chris Heunen1,2
Department of Computer Science University of Oxford
United Kingdom
Martti Karvonen3
Department of Mathematics and Systems Analysis Aalto University
Finland

Abstract
We extend categorical semantics of monadic programming to reversible computing, by considering monoidal closed dagger categories: the dagger gives reversibility, whereas closure gives higher-order expressivity. We demonstrate that Frobenius monads model the appropriate notion of coherence between the dagger and closure by reinforcing Cayley’s theorem; by proving that effectful computations (Kleisli morphisms) are reversible precisely when the monad is Frobenius; by characterizing the largest reversible subcategory of Eilenberg–Moore algebras; and by identifying the latter algebras as measurements in our leading example of quantum computing. Strong Frobenius monads are characterized internally by Frobenius monoids.
Keywords: Frobenius monad, dagger category, reversible computing, quantum measurement


Introduction
The categorical concept of a monad has been tremendously useful in programming, as it extends purely functional programs with nonfunctional effects. For example, using monads one can extend a functional programming language with nondeter- minism, probabilism, stateful computing, error handling, read-only environments, and input and output [51]. Haskell incorporates monads in its core language. On the theoretical side, there are satisfyingly clean categorical semantics. Simply typed λ-calculus, that may be regarded as an idealized functional programming language,

1 Supported by the Engineering and Physical Sciences Research Council Fellowship EP/L002388/1. We thank an anonymous referee for Example 6.4, and Jorik Mandemaker, Sean Tull, and Maciej Pirog for helpful discussions.
2 Email:heunen@cs.ox.ac.uk
3 Email:martti.karvonen@aalto.fi

http://dx.doi.org/10.1016/j.entcs.2015.12.014
1571-0661/© 2015 The Authors. Published by Elsevier B.V.
This is an open access article under the CC BY-NC-ND license (http://creativecommons.org/licenses/by-nc-nd/4.0/).

takes semantics in Cartesian closed categories [31]. The functional programming concept of a monad is modeled by the categorical concept of a monad [36].
In classical computation it is not always possible to reconstruct the input to an algorithm from its output. However, by using auxiliary bits, any classical compu- tation can be turned into a reversible one [48]. Such a computation uses invertible primitive gates, and composition preserves invertibility. As discarding information requires work, reversible computations could in principle be implemented at higher speeds. The only operation costing power is the final discarding of auxiliary bits.
This is brought to a head in quantum computing, where any deterministic evo- lution of quantum bits is invertible, unlike the eventual measurement that converts quantum information to classical information. Another novelty in quantum comput- ing is that it is impossible to copy or delete quantum information. This leads to a linear type theory of resources rather than a classical one [47]: quantum computing takes semantics in monoidal categories, rather than Cartesian ones [2].
Led by quantum computing, this article extends the categorical semantics of monadic programming to reversible computing. To allow for a linear type theory we consider monoidal closed categories. To allow for reversible computations, we consider dagger categories; in general these correspond to bidirectional computa- tions rather than invertible ones, which in the quantum case comes down to the same thing. To allow for monadic effects, we introduce Frobenius monads. In the presence of a dagger, any monad gives rise to a comonad; a Frobenius monad is one that interacts with its comonad counterpart via the following Frobenius law :


=	(1)


Here we used the graphical calculus for monoidal categories [44,34], that will be explained further in Section 2, along with several examples. 4
Our main contribution is to take reversal as a primitive and so justify the claim that Frobenius monads are precisely the right notion as follows:
Section 3 justifies the Frobenius law as a necessary (and sufficient) consequence of coherence between the dagger and closure. In a reversible setting, it is natural to consider involutive monoids. In a monoidal closed category, any monoid em- beds into a canonical one by Cayley’s theorem. We prove that this embedding preserves the involution induced by the dagger if and only if the monoid satis- fies the Frobenius law. This derivation from first principles is a noncommutative generalization of [41, Theorem 4.3] with a new proof.
Section 4 characterizes Frobenius monads internally. Monads are an external no- tion. A good example is the writer monad, that allows programs to keep auxiliary

4 We often need to reason simultaneously about morphisms in a monoidal category and endofunctors on it. Unfortunately there is no sound and complete graphical proof calculus that would handle this yet. Therefore we cannot use the graphical calculus exclusively and also have to use traditional commutative diagrams.

output alongside the computation. These values accumulate according to some monoid. Any monoid gives rise to a strong monad, and Frobenius monoids give rise to strong Frobenius monads. In general this is merely an adjunction and not an equivalence, but we work out that the converse holds in the Frobenius setting. This is a noncommutative generalization of [41, Corollary 4.5]. It also generalizes the classic Eilenberg–Watts theorem from homological algebra to categories that are not necessarily abelian. As Frobenius monoids satisfy the very same law (1) as Frobenius monads, only interpreted in a category rather than by endofunctors on it, this also exhibits that reversible settings are closed under categorification.
We show that the extension of reversible pure computations with effects modeled by a monad results in reversible effectful computations if and only if the monad is a Frobenius monad. More precisely, Section 5 shows that a monad on a dagger category is a Frobenius monad if and only if the dagger extends to the category of Kleisli algebras. This reinforces that Frobenius monads model the right notion of effects for reversible computing. Section 6 identifies the largest subcategory of all algebras with this property, which we call Frobenius–Eilenberg–Moore al- gebras. Section 7 exemplifies them in the quantum setting by arguing that they correspond precisely to measurements via effect handlers [42].
Frobenius monads have been studied before [46,32], and monads have been used as semantics for quantum computing before [15,4,3], but not in a dagger setting, except for [41] that deals with the commutative case abstractly. Conversely, re- versible programming has been modeled in dagger categories [6], but not using monads. Daggers and monads were combined before in coalgebra [20,24], quantum programming languages programming languages [14,45], and matrix algebra [11]. The current work differs by systematically starting from first principles. We intend to fit probabilistic programming in our setup in future work.
Dagger categories
Let us model types as objects A, B, C,.. .in a category, and computations as mor- phisms f, g, h, . . .. To model composite types, we consider monoidal categories, where one can not only compose computations in sequence A f B g C, but also in parallel A ⊗ B f⊗g C ⊗ D. This much is standard [5]. To model reversible com- putations, we need an operation turning a computation A f B into a computation B → A, such that reversing twice doesn’t do anything.
Definition 2.1 A dagger is a functor † : Cop → C satisfying A† = A on objects and f†† = f on morphisms. A dagger category is a category equipped with a dagger.
Dagger categories can behave quite different from ordinary (non-dagger) ones, see e.g. [49, 9.7]. They are especially useful as semantics for quantum comput- ing [19]. Note that reversible computing does not mean computations are invertible. An invertible morphism f in a dagger category is unitary when f† = f−1. Similarly, an endomorphism f is self-adjoint when f = f†. As a rule, any structure in sight should cooperate with the dagger.

Definition 2.2 A monoidal category is called a monoidal dagger category when (f ⊗ g)† = f† ⊗ g†, and all coherence isomorphisms A ⊗ (B ⊗ C) α (A ⊗ B) ⊗ C, I ⊗ A λ A, and A ⊗ I ρ A, are unitary. In a symmetric monoidal dagger category additionally the swap maps A ⊗ B σ B ⊗ A are unitary.
We will mainly consider the following two examples.
Example 2.3 The symmetric monoidal dagger category Rel has sets as objects. Morphisms A → B are relations R ⊆ A × B, with composition S ◦ R = {(a, c) |
∃b : (a, b) ∈ R, (b, c) ∈ S}. The dagger is given by R† = {(b, a) | (a, b ∈ R)}, and the monoidal structure is given by Cartesian products. We may think of Rel as modeling nondeterministic computation [22].
Example 2.4 The symmetric monoidal dagger category FHilb has finite- dimensional complex Hilbert spaces as objects and linear maps as morphisms. The dagger is given by adjoints:  f† is the unique linear function satisfying
⟨f (x) | y⟩ = ⟨x | f†(y)⟩; in terms of matrices it is the conjugate transpose. The monoidal structure is given by tensor products of Hilbert spaces. This models quantum computation [2].
There are many other examples. Reversible probabilistic computation is mod- elled by the category of doubly stochastic maps [7, 2.3.5]; this generalizes to labelled Markov chains [38]. Universal constructions can generate examples with specific properties [40]. Finally, one can formally add daggers to a category in a free or cofree way [16, 3.1.17 and 3.1.19]. We will be interested in the following way to turn a monoidal dagger category into a new one of endofunctors on the old one. It could be regarded as modeling second-order computation, because the compu- tations in the new category may refer to computations in the old one (but not to themselves).
Example 2.5 A functor C F D between dagger categories is a dagger functor when F (f†) = F (f )† on morphisms. Let C be a monoidal dagger category. If F (A) βA G(A) is a natural transformation between dagger functors C F,G C, then
β†
so is G(A) A F (A). Thus the category [C, C]† of dagger functors C → C is again
a monoidal dagger category by G ⊗ F = G ◦ F .
Monoidal dagger categories have a sound and complete graphical calculus, that we briefly recall; for more details, see [44]. A morphism A f B is represented as
, and composition, the tensor product, and the dagger, become:


C	C	B ⊗ D	B	D	A	A

=	=	=


A	A	A ⊗ C	A	C	B	B

Notice that the output wire B ⊗ D of a morphism A f B ⊗ D becomes a pair

of wires labelled B and D coming out of the box labelled f . Also, the dagger reflects in the horizontal axis, which is why we draw the boxes asymmetrically. Distinguished morphisms are often depicted with special diagrams instead of generic boxes as above. For example, the identity A → A is just the line ; the (identity on) the monoidal unit object I is drawn as the empty picture, and the swap map of symmetric monoidal categories becomes . Soundness and completeness means that any equality between morphisms one can prove algebraically using the axioms of monoidal dagger categories can equivalently and rigorously be proven graphically by isotopies of the graphical diagram.
To model higher order computation, we need function types. This is usually done by requiring closed monoidal categories, where the functors −⊗B have right adjoints B ( −. That is, there is a natural bijective correspondence between morphisms
B ⊗ A f C and their curried version A Λ(f ) (B ( C). In the reversible setting
of monoidal dagger categories, this closure operation should cooperate with the dagger: since B ( C is the type of computations B f C, and those computations can be reversed to C f† B, there should be an operation (B ( C) → (C ( B) modelling this internally (we will see this in more detail in Section 3). Therefore we demand that B ( − are dagger functors. It follows that they are not just right adjoint to −⊗ B, but also left adjoint. Now it is a small step to so-called compact dagger categories [33,27], which we make here for the sake of simplicity.
Definition 2.6 A compact dagger category is a symmetric monoidal dagger cate- gory in which every object A has a chosen dual object A∗ and a morphism I u A∗⊗A, drawn as , satisfying (u† ◦ σ) ⊗ id ◦ (id ⊗ u) = id and its dual:


A	A∗

=	=	(2)

A	A∗

Compact dagger categories are automatically closed monoidal, with (B ( C) = B∗ ⊗ C. Think of dual objects B∗ as input types, and primal objects C as output types. By convention we choose A∗∗ = A and (A ⊗ B)∗ = B∗ ⊗ A∗.
Our previous examples in fact already satisfy this closure property of higher order computation: Rel and FHilb are compact dagger categories as follows. In Rel we can take A∗ = A and u = {(∗, (a, a)) | a ∈ A} for I = {∗}. In FHilb we can take H∗ to be the dual Hilbert space of H; if H has an orthonormal basis {e1,..., en},
then H∗ has an orthonormal basis {e∗,..., e∗ }, and we can take u(1) = Σn	e∗ ⊗ei.
1	n	i=1 i
There is also a free compact dagger category on a given (dagger) category C [1].
Let us conclude this preparatory section by contrasting reversible computing and invertible computing. A groupoid is a category where any morphism is invertible; it is always a dagger category with f† = f−1. Any symmetric monoidal closed groupoid G is a so-called compact category with A∗ = (A ( I), as follows. Closure gives isomorphisms (A ( B) ⊗ A ev B for all objects A and B; in particular,

I ∼= A∗ ⊗ A. The morphisms Λ(ev) are isomorphisms A ∼= A∗∗, making G into a so-called ∗-autonomous category [5]. Because G is symmetric monoidal, there are isomorphisms A∗ ⊗ B∗ Λ(ev⊗ev) (A ⊗ B)∗, making G a compact category. However, this is not a compact dagger category unless all swap maps σ are identities.
Frobenius monoids
This section considers monoids in monoidal dagger categories. We will see that, in the higher order setting of closed monoidal categories, our rule of thumb that everything should cooperate with the dagger means considering Frobenius monoids.
Definition 3.1 A monoid in a monoidal category is an object A with morphisms
: A ⊗ A → A and  : I → A, satisfying:

=	= =

It is commutative when	=	◦σ. A Frobenius monoid is a monoid in a monoidal
dagger category satisfying (1). It is special when  ◦  † = id .
A comonoid in C is a monoid in Cop. The Frobenius law (1) makes sense for pairs of a monoid and comonoid on the same object, and most of Section 4 holds in that generality. Each side of the Frobenius law (1) equals ( )† ◦ ; one of these equations is equivalent to (1). It is mostly motivated by observing that Frobenius monoids in specific categories are appropriate well-known mathematical structures.
Example 3.2 Frobenius monoids in FHilb correspond to finite-dimensional C*- algebras [50, Theorem 4.6]. These play a major role in quantum computing [28], but also as semantics for labelled Markov processes with bisimulations [35,43,30,37] and as operational semantics of probabilistic languages [12,13]. Commutative Frobenius monoids in FHilb therefore correspond to orthonormal bases when special [9].
Example 3.3 Frobenius monoids in Rel correspond to (small) groupoids [18,39], which are important to invertible computing.
Example 3.4 In a compact dagger category, A∗ ⊗ A is a Frobenius monoid with  = u, and  being the pair of pants:







A∗	A

This is precisely the monoid A ( A of computations A → A under composition.
Pair of pants are universal, as the following generalization of Cayley’s theorem shows. A monoid homomorphism f satisfies  = f ◦  and f ◦	=	◦ (f ⊗ f ).

Lemma 3.5 Any monoid (A, , ) in a compact category allows a monic monoid homomorphism R into A∗ ⊗ A.
Proof. The following is a monoid homomorphism by (1):


A∗
=	(3)
A
It is monic because it has a left inverse  ()† ⊗ id ◦ R.	2
We will prove that the Cayley embedding of the previous lemma respects daggers precisely when the monoid is a Frobenius monoid. To make precise what it means to respect daggers, we need to internalize the operation f '→ f† from A f A to the monoid A ( A. But the former might not be a well-defined morphism; for example, in FHilb, taking conjugate transpose matrices is anti-linear, not linear, and hence a morphism (A ( A) → (A ( A)∗ rather than an endomorphism. In a compact category, this is modeled by
:=	=
for A f B. The operation f '→ f† additionally is contravariant: (g ◦ f )† = f† ◦ g†. So for it to be a monoid homomorphism the codomain has to have opposite multiplication as the domain.
Lemma 3.6 If (A, , ) is a monoid in a compact category, then so is
(A∗, ∗, ∗), called the opposite monoid.
Proof. The functor f '→ f∗ is (strong) monoidal.	2
Definition 3.7 A monoid (A, , ) in a compact dagger category is an involutive monoid when it is equipped with an involution: a monoid homomorphism A i A∗ satisfying i∗ ◦ i = id. A homomorphism of involutive monoids is a monoid homomorphism A f B satisfying i ◦ f = f∗ ◦ i.
Note that there is a canonical choice of involution:
(4)
For the groupoids of Example 3.3, it is g '→ g−1. For the C*-algebras of Example 3.2, it is a '→ a∗. The following theorem justifies the Frobenius law from first principles, generalizing [41, Theorem 4.3] noncommutatively.

Theorem 3.8 A monoid in a compact dagger category is a Frobenius monoid if and only if (4) makes it involutive and (3) a homomorphism of involutive monoids.
Proof. Write (A, , ) for the monoid, and i for (4). If A is a Frobenius monoid, it follows from (1) that i is indeed an involution. Observe that the involution on A∗ ⊗ A is the identity because of our convention (A ⊗ B)∗ = B∗ ⊗ A∗. So (3) preserves involutions when R∗ ◦ i = R:

A∗	A	A∗
R∗
A∗	=	=	=
i

A

Conversely, assuming R∗ ◦ i = R:


=
=
=	(∗)


Hence, by associativity:


(∗)
=	=
(∗)
=


But this is equivalent to (1).	2
Frobenius monads
A monad is a functor C T C with natural transformations T (T (A)) μA T (A) and A ηA T (A) satisfying certain laws. It is well-known that monads are precisely monoids in categories of functors C → C: Definition 3.1 unfolds to the monad laws
μA ◦ T (μA)= μA ◦ μT (A),
μA ◦ T (ηA)= idT (A) = μA ◦ ηT (A).
There is a dual notion of a comonad. Daggers make any monoid (monad) give rise to a comonoid (comonad). Thus the Frobenius law (1) lifts to monads as follows.
Definition 4.1 A Frobenius monad on a dagger category C is a Frobenius monoid in [C, C]†; explicitly, a monad (T, μ, η) on C with T (f†)= T (f )† and


T (μA) ◦ μ†

It is special when μA ◦ μ† = idT (A).
= μT (A) ◦ T (μ† ).

A

Frobenius monads have been studied before by Street [46,32]. His definition does not take daggers into account, and concerns a monad rather than a monad- comonad pair. However, the natural generalization of the above definition to (non- dagger) monad-comonad pairs results in an equivalent notion to the one studied by Street. The primary example of a Frobenius monad is taking tensor products with a Frobenius monad.
Example 4.2 If (B, , ) is a Frobenius monoid in a monoidal dagger category C, then the functor C −⊗B C, given by A '→ A⊗ B and f '→ f ⊗ id, is a Frobenius monad on C with:


μA =
A



A
A	B
ηA =
B	A


Proof. The Frobenius monad law simply comes down to the Frobenius monoid law:

A	B	B	A B	B

Tμ ◦ μ† =	=	= μT ◦ Tμ†


A B	B	A	B	B

The monad laws become the monoid laws. Taking A = I, we thus see that −⊗ B
is a Frobenius monad if and only if B is a Frobenius monoid.	2
This section characterizes Frobenius monads of this form. There are, however, also other Frobenius monads, as in the following example.
Example 4.3 Consider the monoid Rel(N, N) of all relations N → N as a single- object category. The following define a Frobenius monad on this category:
T (R) ={(2m, 2n) | (m, n) ∈ R}
∪ {(2m + 1, 2n + 1) | (m, n) ∈ R} η ={(2n, 2n + 1) | n ∈ N}
μ ={(4n, 2n) | n ∈ N}∪ {(4n + 3, 2n + 1) | n ∈ N}
The functor −⊗ B comes with a natural transformation α−,−,B, making it a strong functor. This natural transformation respects the monoid structure on B. Before recording some folklore results, we first define what this means for monads.
Definition 4.4 A functor F between monoidal categories is strong when it is
stA,B
equipped with a natural transformation A ⊗ F (B)    F (A ⊗ B) satisfying
st ◦α = F (α) ◦ st ◦(id ⊗ st) and F (λ) ◦ st = λ. A morphism of strong functors is a natural transformation F β G satisfying β ◦ st = st ◦(id ⊗β)A strong monad is a monad (T, μ, η) that is a strong functor satisfying st ◦(id ⊗ μ)= μ ◦ T (st) ◦ st and st ◦(id ⊗ η)= η. A morphism of strong monads is a natural transformation, which is a morphism of the underlying monads and the underlying strong functors.

Proposition 4.5 Let C be a monoidal category. The operations B '→ − ⊗ B and T '→ T (I) deﬁne an adjunction between monoids in C and strong monads on C, with B '→− ⊗ B being the left adjoint.
Proof. See [52]. The unit of the adjunction is I⊗B λB B. The counit is determined
T (ρ)○ st
by A ⊗ T (I)  T (A).	2
In the case of symmetric monoidal categories, there is also a notion of commuta- tivity for strong monads [29,′23]. Given a strong monad T , one can define a natural

transformation T (A) ⊗ B stA,B  T (A ⊗ B) by T (σ
B,A
) ◦ stB,A
σT (A),B
, and

dstA,B := μA⊗B ◦ T (stj
) ◦ stT (A),B

j
A,B
:= μA⊗B ◦ T (stA,B) ◦ stj

A strong monad is commutative when these coincide. Proposition 4.5 restricts to an adjunction between commutative monoids and commutative monads [52].
Definition 4.6 A costrong functor C F D between monoidal categories is a func- tor that is strong when considered as a functor Cop → Dop. Explicitly, it has a

natural transformation F (A ⊗ B) cstA,B  A ⊗ F (B) satisfying F (λ)= λ ◦ cst
I,A
and

cstA⊗B,C ◦F (α)= α◦ (id ⊗ cstB,C) ◦ cstA,B⊗C. A morphism of costrong functors is a natural transformation F β G satisfying cst ◦β = (id ⊗β) ◦ cst. A costrong comonad is a comonad (T, δ, ε) that is a costrong functor, such that (id ⊗ ε) ◦ cst = ε and cst ◦T (cst) ◦δ = (id ⊗δ) ◦ cst. A morphism of costrong comonads is a natural trans- formation, which is a morphism of the underlying comonads and the underlying costrong functors.
Corollary 4.7 Let C be a monoidal category. The operations B '→ − ⊗ B and T '→ T (I) form an adjunction between comonoids in C and costrong comonads on C, but this time B '→− ⊗ B is the right adjoint.	2
In our reversible setting of dagger categories, any strong monad T is automat- ically a costrong comonad under cst = st†, δ = μ†, and ε = η†. According to our motto that everything in sight should cooperate with the dagger, the reverse cst of st should in fact be its inverse, leading to the following definition.
Definition 4.8 A strong Frobenius monad on a monoidal dagger category C is a Frobenius monad (T, μ, η) that is simultaneously a strong monad, such that each stA is unitary. A morphism of strong Frobenius monads is just a morphism of the underlying strong monads.
The following theorem promotes the adjunction of Proposition 4.5 and Corol- lary 4.7 into an equivalence in the dagger setting. It generalizes [41, Theorem 4.5] noncommutatively. It also generalizes the classic Eilenberg–Watts theorem, that characterizes certain endofunctors on abelian categories as being of the form −⊗ B for a monoid B, to monoidal dagger categories; note that there are monoidal dagger categories that are not abelian, such as Rel and Hilb [17, Appendix A].

Theorem 4.9 Let C be a monoidal dagger category. The operations B '→ − ⊗ B and T '→ T (I) deﬁne an equivalence between Frobenius monoids in C and strong Frobenius monads on C.
Proof. We already saw in Example 4.2 that B '→ − ⊗ B preserves the Frobenius law. We prove that T '→ T (I) preserves the Frobenius law, too, in Lemma A.2 in the Appendix. It remains to prove that they form an equivalence. Clearly the unit of the adjunction, I ⊗ B λB  B, is a natural isomorphism. To prove that the counit
T (ρ)○st
A ⊗ T (I)  T (A) is also a natural isomorphism, notice that by definition it is
a morphism of strong monads. In Lemma A.3 in the Appendix we prove that it is also a morphism of comonads. But homomorphisms of Frobenius monoids must be isomorphisms by Lemma A.1.	2
The previous theorem restricts to an equivalence between commutative/special Frobenius monoids and commutative/special strong Frobenius monads (see Corol- lary A.4 in the Appendix).
One might think it too strong to require st to be unitary. The following coun- terexample shows that Theorem 4.9 would fail if we abandoned that requirement.
Example 4.10 Let’s call a Frobenius monad rather strong when it is simultane- ously a strong monad. The operations of Theorem 4.9 do not form an adjunction between Frobenius monoids and rather strong Frobenius monads, because the counit of the adjunction would not be a well-defined morphism. To produce a counterex- ample where the counit does not preserve comultiplication comes down to finding

a rather strong Frobenius monad with T (ηA) ◦ ηA /= μ†
ηA for some A. This

is the case when T is − ⊗ B for a Frobenius monoid B with  ⊗  /= (  )† ◦ . Such Frobenius monoids certainly exist: if G is any nontrivial group, regarded as a Frobenius monoid in Rel via Example 3.3, then  ⊗  is the relation {(∗, (1, 1))}, but ()† ◦  = {(∗, (g, g−1)) | g ∈ G}.
Kleisli algebras
One of the standard categorical constructions when given a monad T is to consider the category CT of its Kleisli algebras. In monadic programming, this category gives semantics for computations with effects modeled by T , whereas the base category C only gives semantics for pure computations [25]. In this section we show that if T is a Frobenius monad, then CT is a dagger category. In fact we also show the converse, under a natural condition about cooperation with daggers. Thus effects modeled by a monad can be added without leaving the setting of reversible computations precisely when the monad is a Frobenius monad.
Definition 5.1 If C T C is a monad, its Kleisli category CT is defined as follows.
f
Objects are the same as in C. A morphism A → B in CT is a morphism A	T (B)
in C. Identities are given by η, and composition of g and f in CT is given by
μ ◦ T (g) ◦ f .
There is a forgetful functor CT → C given by A '→ T (A) on objects and f '→

μ ◦ T (f ) on morphisms. It has a left adjoint C → CT given by A '→ A on objects and f '→ η ◦ f on morphisms.
We now show that for Frobenius monads the Kleisli construction preserves daggers.
Lemma 5.2 If T is a Frobenius monad on a dagger category C, then CT carries a dagger that commutes with the canonical functors CT → C and C → CT .
Proof. A straightforward calculation establishes that
f	η	μ†	T (f†)
T (B)	'→	B	T (B)	T (B)	T (A)
is a dagger on CT commuting with the canonical functors C → CT and CT → C.2
The following theorem proves a converse of the previous lemma, under the nat- ural condition that the “reverse identity morphisms” of the Kleisli category equal their own dagger. This gives another characterization of Frobenius monads, in terms of reversibility of their effectful computations.
Theorem 5.3 A monad T on a dagger category C is a Frobenius monad if and only if CT has a dagger such that:
the functors C → CT and CT → C are dagger functors;
the morphisms μ† : T (A) → T 2(A) of C are self-adjoint when regarded as mor- phisms T (A) → T (A) of CT .
Proof. One direction follows from Lemma 5.2 and the observation that with that dagger the morphism μ† : T (A) → T 2(A) is self-adjoint in CT . For the other direction, we wish to show that the following diagram commutes for arbitrary A.


T 2(A)
μ†
T (μ† )
T 3(A)
μT (A)

T (A)
T 3(A)

T (μA)
T 2(A)


Write C F CT and CT G C for the canonical functors. Note that if we consider idT 2(A) and ηT (A) ◦ μA as morphisms of CT , then we have G(idT 2(A)) = μT (A), G(ηT (A) ◦ μA)= T (μA), and F (μA)= ηT (A) ◦ μA. As G is a dagger functor, we have found preimages of all the morphisms in the diagram. More explicitly, we know that
G idT 2(A) ◦ F (μ† ) = μT (A) ◦ T (μ† ),
G F (μA) ◦ id†	 = T (μA) ◦ μ†	.
T 2(A)	T (A)


Hence it suffices to show id 2	◦ F (μ† )= F (μA) ◦ id†
. As the left hand side

T (A)	A
T 2(A)

is the dagger of the right hand side and μ† is self-adjoint in CT , it suffices to show

that either equals μ†. The following calculation does this for the left-hand side:
idT 2(A) ◦ F (μ† )= μT (A) ◦ T (idT 2(A)) ◦ ηT 2(A) ◦ μ†
A	A
= μT (A) ◦ ηT 2(A) ◦ μ† = μ†
This completes the proof.	2
Kleisli categories of commutative monads on symmetric monoidal categories are again symmetric monoidal [10]. This extends to the reversible setting.
Theorem 5.4 If T is a commutative strong Frobenius monad on a symmetric monoidal dagger category C, then CT is a symmetric monoidal dagger category.
Proof. The monoidal structure on CT is given by A ⊗T B = A ⊗ B on objects and by f ⊗T g = dst ◦(f ⊗ g) on morphisms. The coherence isomorphisms of CT are images of those in C under the functor C → CT . This functor preserves daggers and hence unitaries, making all coherence isomorphisms of CT unitary. It remains to check that the dagger on CT satisfies (f ⊗T g)† = f† ⊗T g†. By Theorem 4.9, T is isomorphic to −⊗ T (I), and it is straightforward to check that this induces an isomorphism between the respective Kleisli categories that preserves daggers and monoidal structure on the nose. Thus it suffices to check that this equation holds on C−⊗T (I), which can be done with a straightforward graphical argument.    2
Frobenius–Eilenberg–Moore algebras
The other canonical standard categorical construction when given a monad T is to consider the category CT of its Eilenberg–Moore algebras. In monadic pro- gramming, these are understood to expand effectful computations to pure compu- tations [25]. This section identifies the largest full subcategory of CT that is still reversible.
Definition 6.1 An Eilenberg–Moore algebra (A, a) for a monad T is a morphism T (A) a A satisfying a◦T (a)= a◦μ and a◦η = id. A morphism of Eilenberg–Moore algebras (A, a) → (B, b) is a morphism A f B satisfying b ◦ T (f ) = f ◦ a. These form a category CT .
We will again need cooperation of such algebras with daggers when present.
Definition 6.2 Let T be a monad on a dagger category C. A Frobenius–Eilenberg– Moore algebra, or FEM-algebra for short, is an Eilenberg–Moore algebra (A, a) that makes the following diagram commute.


T (A)
μ†
T (a)†

T 2(A)
μ	(5)

T 2(A)  T (A)
T (a)

We call this the Frobenius law for Eilenberg–Moore algebras.
Example 6.3 The Kleisli category CT of any monad T sits inside CT as the free algebras (T (A), μA). If T is a Frobenius monad on a dagger category C, any free algebra is an FEM-algebra.
Proof. The Frobenius law for the free algebra is the Frobenius law of the monad.2 There are many EM-algebras that are not FEM-algebras; a family of examples
can be derived from [41, Theorem 6.4]. Here is a concrete example.
Example 6.4 Let A = M2(C) be the Hilbert space of 2-by-2-matrices, with inner product ⟨a, b⟩ = 1 Tr(a† ◦ b). Matrix multiplication gives a map m : A ⊗ A → A making A a Frobenius monoid in FHilb, so that T = −⊗ A is a Frobenius monad. Let u ∈ A be a unitary matrix, and define U : A → A by U (a) = u† ◦ a ◦ u. Now U†(a)= u◦a◦u† and U is an endomorphism of the monoid A, making h = m◦(id⊗U ) an EM-algebra. It is an FEM-algebra if and only if u = u†.
Proof. The Frobenius law (5) means:

=


This comes down to U = (U∗)†, that is, u = u†.	2
The following two results highlight the importance of FEM-algebras to daggers. First, extending from pure computations to FEM–computations is still reversible.
Proposition 6.5 Let T be a Frobenius monad on a dagger category C. The dagger on C induces a dagger on the category of FEM-algebras of T .
Proof. Let f : (A, a) → (B, b) be a morphism of FEM-algebras; we have to show that f† is a morphism (B, b) → (A, a). It suffices to show that b ◦ T (f ) = f ◦ a implies a ◦ T (f†)= f† ◦ b. Consider the following diagram:

Tf†
T (B)  T (A)
id


T 2(B)

(i)
T 2f†
T 2(B)  T 2(A)
(v)
(iv) T 2(A)  T (A)
η†

(iii)
Tf†

(vii)
Ta T (A)
(vi)
a


T (B)  B	A
b	f†

Region (i) is the Frobenius law of (B, b); commutativity of (ii) follows from the assumption that f is a morphism (A, a) → (B, b) by applying T and †; (iii) is naturality of μ; (iv) is the Frobenius law of (A, a); (v) commutes since T is a comonad; (vi) and (vii) commute by naturality of η†.	2
Second, FEM–computations are the largest class that stays reversible.
Theorem 6.6 FEM-algebras form the largest full subcategory of CT containing CT
that carries a dagger commuting with the forgetful functor CT → C.
Proof. Suppose that an EM-algebra (A, a) is such that for any free algebra (T (B), μB) and any morphism f : T (B) → A, f is a morphism of EM-algebras (T (B), μB) → (A, a) iff f† is a morphism (A, a) → (T (B), μB) of EM-algebras. Now (A, a) being an EM-algebra implies that a is a morphism (T (A), μA) → (A, a). Thus by assumption a† is a morphism (A, a) → (T (A), μA), which implies that (A, a) is an FEM-algebra.	2

Quantum measurement
This final section exemplifies the relevance of FEM-algebras to quantum compu- tation, by indicating how quantum measurement fits neatly in effectful functional programming as handlers of Frobenius monads [42,26].
Example 7.1 Let B be a finite-dimensional Hilbert space. A choice of orthonormal basis makes B a commutative Frobenius monoid in FHilb via Example 3.2. Hence T = −⊗ B is a (commutative strong) Frobenius monad on FHilb by Theorem 4.9.
Traditionally, effectful computations are modelled as morphisms in the Kleisli category [36,51]. In the above example, those are just morphisms A → A ⊗ B in FHilb. Quantum measurements are indeed morphisms of this type, but they satisfy more requirements, such as von Neumann’s projection postulate: repeating a measurement is equivalent to copying the outcome of the first measurement. These requirements make the dagger of the morphism A → A ⊗ B precisely an FEM- algebra, see [8, Theorems 1.5 and 1.6]. 5 The following proposition summarizes.
Proposition 7.2 Quantum measurements with outcomes modeled by a commuta- tive strong Frobenius monad on FHilb correspond precisely to its FEM-algebras. 2

Consider the exception monad T that adds exceptions from a set E toa compu- tation by T (A)= A + E. Intercepting exceptions means executing a computation fe for each e ∈ E, and a computation f if no exception is raised. Thus a handler for T specifies an EM-algebra (A, a) and a map f : A → A making the triangle left

5 Technically, the monad has to be lifted to a category of so-called completely positive maps, see [8].

below commute.
A	A
ηA	ηA
A + E  (A, a)	A ⊗ B  (A, a)

This extends to arbitrary algebraic effects T [42]. In particular, it makes sense for quantum measurement, as in the right diagram above. The Frobenius monad −⊗B modeling quantum measurement with outcomes in B is similar to ‘raising exceptions B’, the vertical arrows are Kleisli morphisms, and the lower right handling construct is an FEM-algebra A ⊗ B a A that ‘handles exceptions B’; it involves the unique dashed arrow, that is induced by the free property of the Kleisli algebra A ⊗ B, and is a morphism of FEM-algebras by Example 6.3. Intuitively, Kleisli morphisms A → T (B) are constructors that ‘build’ an effectful computation, whereas FEM algebras T (B) → B are destructors that ‘handle’ the effects.
Thus in general, effectful reversible computation takes place in the category of FEM-algebras of a Frobenius monad, rather than its subcategory of Kleisli algebras. See also [21] for a similar reasoning in different language.
Conclusion
We have proposed Frobenius monads as the appropriate notion to model compu- tational effects in the reversible setting of dagger categories. We have justified their definition from first principles, characterized them internally, shown that their Kleisli categories are again reversible, and identified the largest reversible subcat- egory of their Eilenberg–Moore categories. As an example we phrased quantum measurement in the category of such Frobenius–Eilenberg–Moore algebras.
More examples should be studied. Specifically, noncommutative Frobenius monoids on FHilb might induce monads modelling partial quantum measurement. Also, the relationship between nondeterministic computation in Rel and groupoids should be explored. Finally, we leave probabilistic computation to future work.

References
Abramsky, S., Abstract scalars, loops, and free traced and strongly compact closed categories, Algebra and Coalgebra in Computer Science (2005), p. 2005.
Abramsky, S. and B. Coecke, A categorical semantics of quantum protocols, in: Logic in Computer Science 19 (2004), pp. 415–425.
Altenkirch, T. and J. Grattage, A functional quantum programming language, in: Logic in Computer Science (2005), pp. 249–258.
Altenkirch, T. and A. S. Green, “Semantics Techniques in Quantum Computation,” Cambridge University Press, 2010 pp. 173–205.
Barr, M. and C. Wells, “Category Theory for Computing Science,” Prentice–Hall, 1990.

Bowman, W. J., R. P. James and A. Sabry, Dagger traced symmetric monoidal categories and reversible programming, Reversible Computation (2011).
Coecke, B., E. O. Paquette and D. Pavlovic, “Semantic Techniques in Quantum Computation,” Cambridge University Press, 2009 pp. 29–69.
Coecke, B. and D. Pavlovic, “Quantum measurements without sums,” Taylor and Francis, 2008 pp. 559–596.
Coecke, B., D. Pavlovi´c and J. Vicary, A new description of orthogonal bases, Mathematical Structures in Computer Science 23 (2012), pp. 555–567.
Day, B., On closed category of functors II, in: Sydney Category Theory Seminar, number 420 in Lecture Notes in Mathematics, 1974, pp. 20–54.
de Vos, A. and S. de Baerdemacker, Matrix calculus for classical and quantum circuits, ACM Journal on Emerging Technologies in Computing Systems 11 (2014), p. 9.
Di Pierro, A., C. Hankin and H. Wiklicky, Quantitative relations and approximate process equivalences, in: CONCUR 14, Lecture Notes in Computer Science 2761, 2003, pp. 508–522.
Di Pierro, A. and H. Wiklicky, Operator algebras and the operational semantics of probabilistic languages, in: MFCSIT 3, Electronic Notes in Theoretical Computer Science 161, 2006, pp. 131–150.
Green, A. S., P. L. Lumsdaine, N. J. Ross, P. Selinger and B. Valiron, A scalable quantum programming language, ACM SIGPLAN Notices 48 (2013), pp. 333–342.
Hasuo, I. and N. Hoshino, Semantics of higher-order quantum computation via geometry of interaction, Logic in Computer Science (2011), pp. 237–246.
Heunen, C., “Categorical quantum models and logics,” Ph.D. thesis, Radboud University Nijmegen (2009).
Heunen, C., An embedding theorem for Hilbert categories, Theory and Applications of Categories 22
(2009), pp. 321–344.
Heunen, C., I. Contreras and A. Cattaneo, Relative Frobenius algebras are groupoids, Journal of Pure and Applied Algebra 217 (2013), pp. 114–124.
Heunen, C. and J. Vicary, “Categories for Quantum Theory: An Introduction,” Oxford University Press, 2015.
Jacobs, B., Involutive categories and monoids, with a GNS-correspondence, Foundations of Physics 42
(2012), pp. 874–895.
Jacobs, B., On block structures in quantum computation, in: Mathematical Foundations of Program Semantics, Electronic Notes in Theoretical Computer Science 298, 2013, pp. 233–255.
Jacobs, B. and J. Rutten, A tutorial on (co)algebras and (co)induction, EATCS Bulletin 62 (1997),
pp. 222–259.
Jacobs, B. P. F., Semantics of weakening and contraction, Annals of Pure and Applied Logic 69 (1994),
pp. 73–106.
Jacobs, B. P. F., Coalgebraic walks, in quantum and Turing computation, FoSSaCS, Lecture Notes in Computer Science 6604 (2011), pp. 12–26.
Jacobs, B. P. F., C. Heunen and I. Hasuo, Categorical semantics for arrows, Journal of Functional Programming 19 (2009), pp. 403–438.
Kammar, O., S. Lindley and N. Oury, Handlers in action, in: International Conference on Functional Programming XVIII (2013), pp. 145–148.
Kelly, G. M. and M. L. Laplaza, Coherence for compact closed categories, Journal of Pure and Applied Algebra 19 (1980), pp. 193–213.
Keyl, M., Fundamentals of quantum information theory, Physical Reports 369 (2002), pp. 431–548.
Kock, A., Strong functors and monoidal monads, Archiv der Mathematik 23 (1972), pp. 113–120.
Kozen, D., Semantics of probabilistic programs, Journal of Computer and System Sciences 22 (1981),
pp. 328–350.


Lambek, J. and P. Scott, “Introduction to higher order categorical logic,” Cambridge University Press, 1986.
Lauda, A., Frobenius algebras and ambidextrous adjunctions, Theory and Applicatoins of Categories
16 (2006), pp. 84–122.

Lindner, H., Adjunctions in monoidal categories, Manuscripta Mathematica 26 (1978), pp. 123–139.

Marsden, D., Category theory using string diagrams, arXiv:1401.7220 (2014).

Mislove, M., J. Ouaknine, D. Pavlovic and J. Worrell, Duality for labelled Markov processes, in:
FOSSACS 7, Lecture Notes in Computer Science 2987, 2004, pp. 393–407.
Moggi, E., Notions of computation and monads, Information and Computation 93 (1991), pp. 55–92.

Moshier, M. A. and D. Petri¸san, A duality theorem for real C*-algebras, in: CALCO 3, Lecture Notes in Computer Science 5728, 2009, pp. 284–299.
Panangaden, P., “Labelled Markov processes,” Imperial College Press, 2009.

Pavlovi´c, D., Quantum and classical structures in nondeterministic computation, in: P. B. et al., editor, Third International symposium on Quantum Interaction, Lecture Notes in Artificial Intelligence 5494 (2009), pp. 143–157.

Pavlovic, D., Relating toy models of quantum computation: comprehension, complementarity and dagger mix autonomous categories, in: Quantum Physics and Logic VI, Electronic Notes in Theoretical Computer Science 270, 2009, pp. 121–139.

Pavlovic, D., Geometry of abstraction in quantum computation, in: Classical and Quantum Information Assurance Foundations and Practice, number 09311 in Dagstuhl Seminar Proceedings, 2010.
Plotkin, G. D. and M. Pretnar, Handling algebraic effects, Logical Methods in Computer Science 9
(2013), p. 23.

Saheb-Djahromi, N., Cpo’s of measure for nondeterminism, Theoretical Computer Science 12 (1980),
pp. 19–37.

Selinger, P., A survey of graphical languages for monoidal categories, number 813 in Lecture Notes in Physics (2009), pp. 289–356.

Selinger, P. and B. Valiron, A lambda calculus for quantum computation with classical control, Mathematical Structures in Computer Science 16 (2006), pp. 527–552.

Street, R., Frobenius monads and pseudomonoids, Journal of Mathematical Physics 45 (2004),
pp. 3930–3948.

Szabo, M. E., “Algebra of Proofs,” Number 88 in Studies in Logic and the Foundations of Mathematics, North-Holland, 1978.
Toffoli, T., Reversible computing, Automata, Languages and Programming 85 (1980), pp. 632–644.

Univalent Foundations Program, T., “Homotopy Type Theory: Univalent Foundations of Mathematics,”
http://homotopytypetheory.org/book, Institute for Advanced Study, 2013.
Vicary, J., Categorical formulation of quantum algebras, Communications in Mathematical Physics 304
(2011), pp. 765–796.

Wadler, P., Comprehending monads, Mathematical Structures in Computer Science 2 (1992), pp. 461– 493.
Wolff, H., Monads and monoids on symmetric monoidal closed categories, Archiv der Mathematik 24
(1973), pp. 113–120.

Proofs
This appendix verifies steps used in proofs in Section 4.
Lemma A.1 A monoid homomorphism between Frobenius monoids in a monoidal dagger category, that is also a comonoid homomorphism, is an isomorphism.
Proof. Construct an inverse to A f B as follows:

A






B

The composite with f gives the identity in one direction:

B	B	B	B

=	=	=


B	B

The third equality uses the Frobenius law (1) and unitality. The other composite is the identity by a similar argument.	2
Lemma A.2 The functor T '→ T (I) preserves the Frobenius law.
Proof. Consider the diagram in Fig. A.1. Region (i) commutes because T is a Frobenius monad, (ii) because μ† is natural, (iii) because ρ−1 is natural, (iv) because st† is natural, (v) is a consequence of T being a strong monad, (vi) commutes as ρ is natural, (vii) and (viii) because st is natural, (ix) commutes trivially and (x) because st is natural. Regions (ii)’-(x)’ commute for dual reasons. Hence the outer diagram commutes, and T '→ T (I) preserves the Frobenius law.	2
Lemma A.3 If T is a strong Frobenius monad, the counit of the adjunction of Proposition 4.5 is a morphism of comonads.
Proof. First we show that the counit of the adjunction preserves counits of the comonads. It suffices to see that
A ⊗ T (I)
stA,I
T (A ⊗ I)	A ⊗ I
η†

T (ρA)
A⊗I
A

T (A)	A
†
A

commutes. But the rectangle commutes because η† is natural, and the triangle commutes because T is a strong monad and st is an isomorphism.
To see that that the counit of the adjunction preserves the comultiplication, consider the following diagram:

id ⊗ μ†	id ⊗ T (ρ−1)	id ⊗ st†
A ⊗ T (I)  A ⊗ T 2(I)  A ⊗ T (T (I) ⊗ I)  A ⊗ (T (I) ⊗ T (I))

id
id ⊗ T (ρ)

(ii)
α
id ⊗ st

A ⊗ T 2(I)  A ⊗ T (T (I) ⊗ I)	(A ⊗ T (I)) ⊗ T (I)


st
st
T (α)

st	(i)
T (A ⊗ (T (I) ⊗ I))	T ((A ⊗ T (I)) ⊗ I)


st	T (id ⊗ ρ)
T (ρ)
T (A ⊗ T (I))

T (st)
T (A ⊗ I)	T 2(A ⊗ I)
†


T (ρ)
T 2(ρ)

T (A)	T 2(A)
μ†
Commutativity of region (i) is a consequence of T being a strong monad, and st being an iso, (ii) commutes by definition, (iii) commutes as st is natural, (iv) because T is a strong functor, (v) by coherence and finally (vi) by naturality of μ†. Hence the outer diagram commutes, and the counit of the adjunction preserves the comultiplication.	2
Corollary A.4 The equivalence of Theorem 4.9 restricts to an equivalence between special Frobenius monoids and special strong Frobenius monads.
Proof. The commutative case follows from [52]. If the Frobenius monoid is special, so is the monad, by trivial graphical manipulation of Example 4.2. Conversely, if the Frobenius monad T is special, the following diagram commutes:

μ†
T (I)
T (ρ−1)
T 2(I)  T T (I) ⊗ I
st−1
T (I) ⊗ T (I)

id	id	id
T (I)	T 2(I)  T T (I) ⊗ I 
μ	T (ρ)
and so T (I) is special.	2


T (I) ⊗ T (T (I) ⊗ I)


id ⊗ st†

T (I) ⊗ (T (I) ⊗ T (I))
α


(xii)
T (α)
(T (I) ⊗ T (I)) ⊗ T (I)

st† ⊗id
st ⊗id



(ix)’
T (T (I) ⊗ I) ⊗ T (I))

id ⊗ T (ρ−1)

(x)
T (T (I) ⊗ (T (I) ⊗ I))  T ((T (I) ⊗ T (I)) ⊗ I)	T (T (I) ⊗ I) ⊗ T (I)


T (ρ) ⊗ id

T (id ⊗ ρ−1)
st
(xi)
T (ρ−1)
(viii)’


T (I) ⊗ T 2(I)  T (T (I) ⊗ T (I))	T (T (T (I) ⊗ I) ⊗ I)  T (T 2(I) ⊗ I)  T 2(I) ⊗ T (I)
(vi)’

T (st†)
T (ρ−1)
T 2(ρ)
T (μ ⊗ id)



(iv)

id ⊗ μ†

(v)’
T 2(T (I) ⊗ I)	T 3(I)
μ†
(iii)
T (T (I) ⊗ I)
μ ⊗ id

(ii)
T (I)
st†
)




T (I) ⊗ T (I)
μ†	T 2(I)
st
(i)
μT (I) T 2(ρ−1)
T 2(I)	μ

(ii)’



(v)
T (I) ⊗ T (I)



μ† ⊗ id

(iv)’
T (T (I) ⊗ I)

T (μ† ⊗ id)
(iii)’
T 3(I)	T 2(T (I) ⊗ I)

T (ρ)
T (st)
id ⊗ μ

T 2(I) ⊗ T (I)	st
T (T (ρ−1) ⊗ id)
T (T 2(I) ⊗ I)  T (T (T (I) ⊗ I) ⊗ I)
(vi)

T (T (I) ⊗ T (I))
st†

T (I) ⊗ T 2(I)

(viii)
st (vii)

T (st ⊗id)	T (ρ)
T (α−1)

(xi)’

T (id ⊗ ρ)


(x)’

T (ρ−1) ⊗ id
(ix)
T (T (I) ⊗ I) ⊗ T (I)	T ((T (I) ⊗ T (I)) ⊗ I)  T (T (I) ⊗ (T (I) ⊗ I))

(xii)’

st†
id ⊗ T (ρ)

st ⊗id

T (T (I) ⊗ I) ⊗ T (I)  (T (I) ⊗ T (I)) ⊗ T (I)	T (I) ⊗ (T (I) ⊗ T (I))	T (I) ⊗ T (T (I) ⊗ I)

st† ⊗id
α−1	id ⊗ st
