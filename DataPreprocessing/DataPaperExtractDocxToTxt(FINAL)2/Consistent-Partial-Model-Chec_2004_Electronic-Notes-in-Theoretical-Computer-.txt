Electronic Notes in Theoretical Computer Science 73 (2004) 45–85	
www.elsevier.com/locate/entcs


Consistent Partial Model Checking
Michael Huth1
Department of Computing Imperial College London London, England
Shekhar Pradhan2
Computer Science Department Vassar College
Poughkeepsie, New York

Abstract
We propose assertion-consistency (AC) semi-lattices as suitable orders for the analysis of partial models. Such orders express semantic entailment, multiple-viewpoint and multiple-valued analysis, maintain internal consistency of reasoning, and subsume finite De Morgan lattices. We classify those orders that are finite and distributive and apply them to design an efficient algorithm for multiple-viewpoint checking, where checks are delegated to single-viewpoint models — efficiently driven by the order structure. Instrumentations of this algorithm enable the detection and location of inconsistencies across viewpoint boundaries. To validate the approach, we investigate multiple- valued models and their compositional property semantics over a finite distributive AC lattice. We prove that this semantics is computed by our algorithm above whenever the primes of the AC lattice determine ‘projected’ single viewpoints and the order between primes is preserved as refinements of single-viewpoint models. As a case study, we discuss a multiple-valued notion of state-machines with first-order logic plus transitive closure.
Keywords: lattices, DeMorgan lattices, model checking, viewpoints, requirements, refinement, verification


Introduction
In computer science and computer engineering, models are a popular tool for documenting, specifying or analyzing relevant aspects of a design. As

1 Email: M.Huth@doc.imperial.ac.uk
2 Email: pradhan@cs.vasser.edu



1571-0661 © 2004 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2004.08.003


representative examples we cite state-machines in UML and class diagrams annotated with constraints written in OCL. Ideally, such models are partial: although some aspects of the model are fully described and have to be realized, other aspects of the model are not fully specified and their realization is up to the implementor. Example ontologies that make this distinction between guaranteed and possible aspects explicit are modal transition systems [26,25] and models written in the executable constraint language Alloy [22]. Concep- tually, such models are partial in that they allow a whole set of qualitatively different implementations. In practice, partial models also occur by abstract- ing an existing implementation — a step necessary due to the complexity of implementations — prior to its analysis. In the ongoing effort of automatic verification of software, guaranteed and possible aspects of the abstract model are computed as must- and may-transitions (respectively); see e.g. [31].
It is beneficial to distill a reference ontology for the many material ontolo- gies of partial models and their analysis, be they modal transition systems, Alloy programs, partial Kripke structures [5,6], modal shape graphs [32,19], labeled transition systems with a divergence predicate [35] etc. Our reference ontology has a class of partial models P and a class of total models T such that every total model may be seen as a partial model
T ⊆ P
where the identification of a total as a partial model may involve some casting. There is an implementation relation
impl ⊆P × T
which is reflexive on T since implementations implement themselves. We have a query language L that supports negation ¬ and conjunction ∧, and has a satisfaction relation
|= ⊆T × L
over total models such that all total models are consistent:
∀T ∈T ∀φ ∈ L:	T |= φ ∧ ¬φ. 
Since partial models have a, possibly empty, set of total models as implemen- tations, we can lift |= to partial models in two generally distinct ways:
P |=aφ	iff	∀P ' ∈ P:	(P, P ') ∈ impl ⇒ P ' |= φ
P |=cφ	iff	∃P ' ∈ P:	(P, P ') ∈ impl & P ' |= φ. 
The relation |=a views φ as an assertion and checks its validity with respect to all implementations of a model. Dually, |=c views φ as a consistency check and analyzes whether φ is consistent with respect to a model’s set of imple- mentations. We assume

T |= чφ	iff	T |= φ
T |= φ1 Λ φ2	iff	T |= φ1 and T |= φ2
for all T ∈7 ; φ, φ1, φ2 ∈ L. But then


P |=/
aφ	iff	P |=cчφ

follows for all P ∈ У. The semantics of |= ought to be consistent with those of |=a and |=c. Since impl is reflexive on T
T |= φ	⇒	T |=cφ
T |= чφ	⇒	T |=/ aφ
shows such consistency. It is desirable that the converse implications hold as well. If so, we compute


T |=cφ iff T |= φ iff T |= чφ by (7) iff “not T |=/
aφ” iff T |=aφ .

The validity of these converse relationships is secured by the more stringent demand that implementations that implement each other be indistinguishable by the query logic: for all T, T ' ∈7 ,
(T, T ') ∈ impl	⇒	{φ ∈L | T |= φ} = {φ ∈L | T ' |= φ} .
A partial model P is consistent iff there is some P ' with (P, P ') ∈ impl.
We discuss a material ontology for this reference ontology in some detail in the next section. This paper investigates how well understood concepts from total model checking transfer to this partial setting. Specifically, we study
model theory and semantic entailment,
abstraction and refinement of models,
reasoning about models under multiple points of view,
more efficient multiple-valued model checking, and
the consistency of |=c and |=a at the meta-level
in this setting of partial model checking. To that end, we distill an or- dered structure, assertion-consistency (AC) semi-lattices, that allow the re- development of the notions above for partial models.
Throughout this paper, we work with the reference ontology
(У, 7 , L, |=, impl)
satisfying (1-11), unless indicated otherwise. Such an ontology has a refine- ment relation, a pre-order on У:
P <PP '	iff	6φ ∈ L: P '|=aφ ⇒ P |=aφ. 
We write < if У is determined by context. One may think of P <P ' as spec- ifying that either P is a refinement of P ' or P ' is an abstraction of P . If P


is inconsistent, then {φ ∈ L | P |=aφ} = L and so P <Q holds for all models Q ∈ У. The partial order quotient of the pre-order < identifies models that cannot be distinguished with answers to any assertion checks; in particular, it identifies all inconsistent partial models.
As an example of reasoning within this reference ontology, we show that
impl is contained in the relational inverse of <P: for all P, P ' ∈ У,
(P, P ') ∈ impl ⇒ P '<P . 
Proof by contradiction: If there is an φ ∈L with P |=aφ and P ' |=/ aφ, then the
latter and (10) ensure P ' |= чφ which contradicts P |=aφ as (P, P ') ∈ impl.

Outline of paper
Section 2 presents the constraint language Alloy and its analyzer as an example ontology of the framework set out in the introduction.
In Section 3, we define AC semi-lattices and discuss important examples of such structures arising from partial model checking.
Section 4 classifies those AC semi-lattices that are finite and distributive; these structures often occur in applications and subsume finite distributive De Morgan lattices. These classifications have computational significance as they allow the efficient implementation of algebraic operations via transfor- mations on the order-generating subset of prime elements.
Embeddings of AC semi-lattices into De Morgan lattices are documented in Section 5.
Using a mixed-power order, an internal consistency between satisfiability and validity denotations within AC semi-lattices is realized for partial model checking in Section 6.
In Section 7, we present a novel semantics for partial model checks under multiple viewpoints; it delegates checks to single-viewpoint models driven by a priority pre-order and synthesizes such checks into sets of obligations. Such sets enable the systematic detection and location of inconsistencies across model boundaries.
Section 8 takes a closer look at the role of negation for checks over partial models that are multiple-valued or have multiple viewpoints. In particular, we see that Heyting negations are inadequate in this setting.
Multiple-valued state-machines are discussed in Section 9 as an example application of the technical material and algorithms developed in this paper. In particular, we prove that our algorithm for synthesizing obligation sets also computes a multiple-valued compositional semantics whenever the order on primes is preserved as refinement between projected single-view models.
Section 10 states related work and Section 11 summarizes our findings.

An Example Ontology
Alloy is a constraint language with typed first-order logic plus transitive clo- sure, supported by an automatic analyzer that restricts models to finite scopes [22]. For sake of simplicity, we ignore issues of scope sizes as well as Alloy’s ability to analyze NP and co-NP formulas in this section and merely sketch how Alloy realizes an instance of the ontology (1–11). The set 7 consists of all conventional models of first-order logic: types are interpreted as sets, relation/function symbols are interpreted as relations/functions over the sets that interpret their types (respectively), and transitive closure has the usual meaning. For example, T ∈ 7 may consist of a set X = {a, b} and a binary relation R = {(a, b), (b, b)}⊆ X × X. For the T above, this could be
sig X {
R: set X
}
fact ( some a,b: X | a != b && X = a + b && R = a->a + a->b }
Facts are enforced to hold in an Alloy model. The remaining meaning of this program is self-explanatory given the definition of T . The query logic L for Alloy consists of sentences over typed first-order logic with transitive closure. The satisfaction relation |= is the standard interpretation of such queries over models in 7 .
To explain how to write assertion and consistency checks in Alloy let us consider a more elaborate example. In Figure 2, P is a partial model of the internal structure of classes and objects in an object-oriented programming language — specified through the two signatures and the fact in lines 1-11. The fact specifies that, in all implementations of P , all objects’ methods are declared in their class.
Alloy uses the keyword fun to denote consistency checks; here lines 13-
16. For example, Scenario asks whether one can generate an implementation of P in which the first object has at least one method and its type has all other classes as subtypes; and where a second object is of a different type; its analysis uses implicit existential quantification of its parameters. The invocation ^subtype specifies the transitive closure of subtype.
Alloy uses the keyword assert to denote assertion checks; here lines 18-19. By virtue of (9), the analysis of the assertion Safety may be done by checking its negation: “Is there an implementation of P with an object that has a method which is declared private and public in the object’s class?” Figure 3 shows an implementation of P that satisfies Scenario, so P |=cScenario. In particular, the partial model P is consistent : there is some implementation T


sig X { 
f: X } 
3
4  fact { some a,b,c: X | a->b + a->c in f && b != c }

Fig. 1. A partial model — written in D. Jackson’s Alloy [22] — that is inconsistent as it has no implementations. The source of the inconsistency is subtle. Relations within signatures have the signature type (here X) as first type; if only an atomic type is declared (here X), the relation is a total function f : X → X by default. This contradicts the statement expressed in the fact.

of P . Figure 4 depicts a violation to the assertion Safety in P , from which

we infer P |=/
aSafety.

Alloy’s implementation relation associates to an Alloy program P all total models T that (1) have the same structure and name space for sets, relations, and functions; and (2) satisfy all facts stated in P . We leave it as an exercise to verify that Alloy is an instance of our ontology.
Since Alloy models are signatures plus finitely many constraints, they can easily be inconsistent — e.g. through the insertion or deletion of multiplic- ity constraints — and the detection of such inconsistencies is an important analysis activity supported by Alloy’s analyzer: run a consistency check of a consistent query [21]; if no implementation is found and the scope of analysis was sufficiently large, the model is probably inconsistent. Figure 1 depicts such an inconsistent model P : there is no T with (P, T ) ∈ impl. It is useful to group together those Alloy models that share a common static structure. The static structure of the model in Figure 2, for example, is determined by its two signatures. Queries that refer only to instances of these signatures and their relational components are interpretable in any model of that static structure, as is the case for Safety and Scenario in Figure 2. Our ontology and its properties remain intact if such a restriction is being imposed. Each static structure corresponds to an application, e.g. one can fix static structures for behavioral models such as labeled transition systems and state machines.


AC Semi-lattices
Distinct modes of analysis (‘assertion’ or ‘consistency’ checks) result in distinct modes of meaning. Thus, the lattice {0 < 1} serves as two meaning spaces — one for assertion checks (La) and one for consistency checks (Lc). The logical duality of satisfiability and validity suggest maps чa: La → Lc and чc: Lc → La which swap 0 and 1, so there seems to be no need to tag the lattices or negation maps with modes. As this paper will hopefully demonstrate, there are good reasons for tagging meanings with mode information — even if all partial models in question were consistent. Each mode m ∈ {a, c} and query



sig Class {
pub, priv : set Method,
field : set Field,
subtype: set Class } 5
sig Object {
type : Class,
method : set Method,
field : set Field } 10
11 fact { all o : Object | o.method = o.type.(pub + priv) } 12
fun Scenario(Object_1, Object_0 : Object) {  -- consistency check
some Object_1.method
Object_1.type.^subtype = Class - Object_1.type
Object_1.type != Object_0.type } 17
assert Safety{  -- assertion check
all o:Object | no o.method & o.type.pub & o.type.priv }

Fig. 2. A partial model of the internal structure of classes and objects in an object-oriented programming language — written in D. Jackson’s Alloy [22].

Fig. 3. Alloy’s analyzer finds an implementation of the partial model in Figure 2 that satisfies
Scenario.

Fig. 4. Alloy’s analyzer finds an implementation of the partial model in Figure 2 that violates
Safety.


чaчcφ = φ	ччφ = φ
чcчaφ = φ	ч(φ Λ ψ)= чφ ∨ чψ φ ≤a ψ ⇒ чaψ ≤c чaφ  ч(φ ∨ ψ)= чφ Λ чψ φ ≤c ψ ⇒ чcψ ≤a чcφ  φ ≤ ψ = чψ ≤ чφ
Fig. 5. Axioms for AC semi-lattices (left) and De Morgan lattices [10] (right).


φ determine a set (15)

[| φ |]m d=ef {P ∈У | P |=mφ}.

The partial model of Figure 2 is in [| Safety |]c but not in [| Safety |]a — the latter was established in Figure 4. Evidently, we not only have to be able to compute or determine membership relations of such sets but it is also vital to tag them with the proper mode. Misinterpretations and inconsistent analyzes would follow otherwise.
This paper therefore proposes assertion-consistency semi-lattices — also referred to as AC semi-lattices — as ordered structures for semantics of partial model checks.
Definition 3.1 (i) A partial order (Q, ≤) is an inf-semi-lattice with one (sup-semi-lattice with zero) iff all its finite subsets — including the empty set — have an infimum (supremum).
An AC semi-lattice is a tuple (La, ≤a, чa, Lc, ≤c, чc), where (La, ≤a) and (Lc, ≤c) are partial orders, чa: La → Lc and чc: Lc → La are functions that meet the axioms of Figure 5 (left), and (La, ≤a) is an inf-semi-lattice with one. (We write φ ∨ ψ as a shorthand for ч(чφ Λ чψ).)
An AC semi-lattice (La, ≤a, чa, Lc, ≤c, чc) is an AC lattice iff (La, ≤a) is also a sup-semi-lattice with zero.
A De Morgan lattice is a triple (D, ≤, ч) where (D, ≤) is a lattice and
ч : D → D is a map meeting the axioms of Figure 5 (right).
Since the axioms of Figure 5 (left) spell out a witness to (La, ≤a) and (Lc, ≤−1) being order-isomorphic, we infer that — in every AC semi-lattice — (Lc, ≤c) is a sup-semi-lattice with zero. If we interpret ч in the second and third axiom of Figure 5 (right) as чa and чc (respectively), these axioms also hold in AC semi-lattices. We already discussed the finite distributive AC lattice La = Lc = {0 < 1} with negations чa = чc swapping 0 and 1. This structure also satisfies the axioms of Figure 5 (right) and is therefore a De Morgan lattice.

Our second example of an AC semi-lattice is

(16)
with ordering ⊆ and (17)
Lm = {[| φ |]m | φ ∈ L}

ч [| φ |]m d=ef [| чφ |]¬m,

where чa d=ef c and чc d=ef a. The ordering on Lm encodes semantic entailment over the class У of all partial models and equality in Lm acts as a quotient operation on queries: queries that cannot yield partial models with different answers in mode m are identified in that mode.
Proposition 3.2 The tuple (La, ⊆, чa, Lc, ⊆ чc) is an AC semi-lattice.
All proofs are attached in an appendix. The proof of this proposition re- veals and motivates why AC semi-lattices have finite infima for denotations of assertion checks: such checks universally quantify over all implementations and conjunction distributes over universal quantification; dually, consistency checks existentially quantify over implementations and disjunctions distribute over existential quantification. This also explains why we cannot work with lattices for partial model checks. In general, the set {[| φ |]a, [| ψ |]a} won’t have a suprema in La. The maps чa and чc act as set complements
M '→У \ M: P(У) → P(У)
only if we restrict У in (15) to the subset of consistent models in У. In that AC semi-lattice, the assertion meaning of φ is then a subset of the consistency meaning of φ. But, as Proposition 3.2 testifies, AC semi-lattices are definable even in the presence of inconsistent partial models.
Example 3.3 As a third example, consider a topological space (X, τ ). Let La = τ be the set of opens and Lc = {X \ O | O ∈ τ } be the set of closed sets, both ordered by ⊆. The negation maps are A '→ X \ A. This is an AC lattice but, in general, not a De Morgan lattice; however, La and Lc have a structure- preserving embedding into the distributive De Morgan lattice (P(X), ⊆, \).
Given the existence of such embeddings, one may argue that there is no real need for AC semi-lattices at all. Yet partial model checks still have to remem- ber the modes of semi-lattice elements even if these elements are the image points of such embeddings. For example, this is crucial for obtaining more efficient model-checking algorithms for multiple-valued analysis, as described in subsequent sections. Finally, we note that De Morgan lattices are special kinds of AC lattices in that reasoning about assertions is reasoning about consistencies, as would be the case for total models in (10), but with reversed order.

Proposition 3.4 Every De Morgan lattice (D, ≤, ч) determines an AC lat-

tice (La, ≤a, чa, Lc, ≤c, чc) such that La = Lc, ≤−1
= ≤c, and чa = чc.

Conservely, any such AC lattice determines a De Morgan lattice (La, ≤a, чa)
and the compositions of these constructions are mutually inverse.

Finite Distributive AC and De Morgan Lattices
We prove representation theorems for finite distributive AC semi-lattices and De Morgan lattices. We focus on finite distributive structures since they are important in applications such as multiple-valued and viewpoint-based reason- ing. (Representation theorems for the non-distributive case are the subject of Section 5.) The computational contents of these results yield efficient imple- mentations of the algebraic operations of such orders in terms of their prime elements. These results also recognize De Morgan lattices as AC lattices with an internal symmetry. Readers who focus on model-checking issues may safely skip to Section 6 on page 14.
Lemma 4.1 Every ﬁnite AC semi-lattice is an AC lattice.
Therefore, we may focus on AC lattices in the finite case. Finite distributive lattices are representable as topologies. In our case, this requires an under- standing of the lower power-domain functor and a definition of its logical dual.
Let X be a finite set with a pre-order ≤ and τ the set of upper subsets U of X: x ∈ U and x ≤ y imply y ∈ U . Closed sets are then lower subsets L: y ∈ L and x ≤ y imply x ∈ L. We write L(X, ≤) for the set of lower subsets of X. Let
def
η : (X, ≤) → (L(X, ≤), ⊆)	η (x) = ↓x = {x' ∈ X | x' ≤ x}.
Given a monotone map f : (X, ≤) → (L, ≤) into a complete lattice, we write extL(f ) for the unique sup-map satisfying extL(f ) ◦ ηX = f . (A function f : L → L' between complete lattices L and L' is a sup-map iff f ( A)= f (A) for all A ⊆ L.) This defines the lower power-domain functor [1]
def
L(g) = extL(η  ◦ g)
where g: (X, ≤) → (Y, ±) is a monotone map between pre-orders. Dually, we write U(X, ≤) for the set of upper subsets of X. The maps
\a : (L(X, ≤), ⊆) → (U(X, ≤), ⊇)	\a(A)= X \ A
\c : (U(X, ≤), ⊇) → (L(X, ≤), ⊆)	\c(A)= X \ A
are monotone, as is
ϵX = \a ◦ ηX: (X, ≤) → (U(X, ≤), ⊇) .


For f as above, we write extU (f ) for the unique sup-map satisfying extU (f ) ◦
ϵX = f . This defines the complemented lower power-domain functor
def
U(g) = extU (ϵ  ◦ g)
for g as above. Finally, let Aut(X, ≤) be the set of order-isomorphisms of type (X, ≤) → (X, ≤).
Proposition 4.2 (i) U(·): Pre → Lat is a monotone functor between the categories of pre-orders with monotone maps and complete lattices with sup-maps.
We have \a = extL(ϵX), \c = extU (ηX), ηX = \c ◦ ϵX, and U(f ) =
\a ◦ L(f ) ◦ \c.
For partial orders (X, ≤), the functors L(·) and U(·) induce bijective maps of type Aut(X, ≤) → Aut(L(X, ≤)) and Aut(X, ≤) → Aut(U(X, ≤)) (re- spectively).
We now have all the machinery at our disposal to prove a representation theorem for finite distributive AC lattices.
Theorem 4.3 Every AC semi-lattice (La, ≤a, чa, Lc, ≤c, чc) whose partial or- der (La, ≤a) is a ﬁnite distributive lattice can be represented as
(L(X, ≤), ⊆, extL(ϵX ◦ i), U(X, ≤), ⊆, extU (ηX ◦ i−1))
for some partial order (X, ≤) and some i ∈ Aut(X, ≤).
Example 4.4 Consider the finite partial order (X, ≤), where X = {x, y, z} and y and z are incomparable but greater than x. There are two elements i in Aut(X, ≤). For i being the identity id , ч d=ef extL(ϵ ◦ i) and ч d=ef extU (ηX ◦ i−1) act as A '→ X \ A. For i being the map that swaps y and z and keeps x fixed, we have чa(L)=  {X \ ↓i(v) | v ∈ L} and чc(U )=  {↓i−1(v) | v /∈ U }. For example, чc({z}) = ↓x ∪ ↓z = {x, z} and чa({x, y}) = (X \
↓i(x)) ∪ (X \ ↓i(y)) = {y, z}∪ {y} = {y, z}. In particular, {z}∩ чc({z}) and
{x, y}∩ чa({x, y}) are non-empty.
Given a lower set L ∈ L(X, ≤), its set complement X \ L is in U(X, ≤). If i: (X, ≤) → (X, ≤−1) is an order isomorphism with i◦i = idX, then L '→ {i(x) | x ∈ X \ L} is a map of type L(X, ≤) → L(X, ≤) which makes L(X, ≤) into a De Morgan lattice. The existence of such an i is therefore a sufficient condition for L(X, ≤) being a De Morgan lattice; this condition is also necessary for finite distributive De Morgan lattices.
Theorem 4.5 Every ﬁnite distributive De Morgan lattice (L, ≤, ч) can be represented as (L(X, ≤), ⊆, ч) for a ﬁnite partial order (X, ≤) where
чL = {i(x) | x ∈ X \ L}


for some monotone i: (X, ≤) → (X, ≤−1) with i ◦ i = idX.
It would be of interest to see whether the proof of Theorem 4.5 can be reduced to the one of Theorem 4.3.
Example 4.6  (i) Consider the finite self-dual partial order X = {x, y} in the discrete ordering. There are exactly two monotone maps i: (X, ≤) → (X, ≤−1) with i◦i = idX , the identity idX and sw which permutes x and y. This gives rise to two different De Morgan negations: ч d=ef extL(ϵ ◦ id ) and ч' d=ef extL(ϵ  ◦ sw). We have ч{x} = {y}, and ч{y} = {x}, ч'{x} =
{x}, and ч{y} = {y}. Thus, the first negation is the classical one, and the
second negation renders Belnap’s four-valued logic [3]. By Theorem 4.5, this lattice cannot have any other De Morgan negations.
(ii) For a negative example, consider the finite partial order (X, ≤) of Exam- ple 4.4, where X = {x, y, z} and y and z are incomparable but greater than x. This partial order is not self-dual; in particular, there cannot be a monotone map i: (X, ≤) → (X, ≤−1) with i ◦ i = idX. By The- orem 4.5, L(X, ≤) cannot have a De Morgan negation. To see this ex- plicitly, the third axiom of Figure 5 (right) renders {} = ч{x, y, z} = ч({x, y}∪ {x, z}) = ч{x, y}∩ ч{x, z}. Thus, at least one of the sets ч{x, y} and ч{x, z} has to be empty as all non-empty lower sets contain
x. But then ч cannot be a bijection, since {} = ч{x, y, z}. Of course, (L(X, ≤), ⊆, \a, U(X, ≤), ⊆, \c) is an AC lattice.

Embeddings
This section merely documents some rather obvious embeddings of AC semi- lattices into AC lattices and De Morgan lattices; the reader may therefore skip to Section 6 on page 14 as these embeddings are not used in the remainder of this paper. AC semi-lattices, AC lattices, and De Morgan lattices have structure-preserving maps.
Definition 5.1  (i) The category AC has all AC semi-lattices as objects.
A morphism in AC, f : (L , ≤ , L , ≤ ) → (L' , ≤' , L' , ≤' ), is a pair

(fa, fc) where
a	a	c	c
a	a	c	c

f : (L , ≤ ) → (L' , ≤'
) preserves all finite infima,

a	a	a	a	a
fc: (Lc, ≤c) → (L'c, ≤c') preserves all finite suprema,
fa ◦ чc = ч'c ◦ fc, and
fc ◦ чa = ч'a ◦ fa.
The category ACL has as objects all AC lattices and all morphisms f of
AC such that fa and fc preserve all finite infima and suprema.


The category DM is a full subcategory of ACL whose objects are all De Morgan lattices, represented in the form of Proposition 3.4.
It is routine to verify that these data give rise to categories. There is an analogy between their morphisms and Galois connections [12] in that fa and fc determine each other uniquely:
fa = ч'c ◦ fc ◦ чa	and	fc = ч'a ◦ fa ◦ чc .
We use these categories to formalize an embedding, a “final” construction, of AC lattices into De Morgan lattices. We then conclude this section with formalizing an embedding of AC semi -lattices into De Morgan lattices.

Embedding AC lattices
For every AC lattice (La, ≤a, чa, Lc, ≤c, чc), consider the partial ordering
def
(Q, ≤) = (La, ≤a) × (Lc, ≤c)
and the map ч: (Q, ≤) → (Q, ≤−1) defined by
ч(x, y) = (чcy, чax) .
For (x, y) ≤ (u, v) in (Q, ≤), the axioms for AC semi-lattices render чau≤cчax and чcv≤aчcy from which we infer that ч in (28) is monotone for the type (Q, ≤) → (Q, ≤−1). Similarly, we conclude ч◦ ч = idQ. Therefore, the tuple (Q, ≤, ч, Q, ≤, ч) is an object in DM. The projections πa: (Q, ≤) → (La, ≤a)
def	def
with πa(x, y) = x and πc: (Q, ≤) → (Lc, ≤c) with πc(x, y) = y preserve binary
infima and suprema such that πa ◦ч = чc ◦ πc and πc ◦ч = чa ◦ πa. Thus,
π: (Q, ≤, ч, Q, ≤, ч) → (La, ≤a, чa, Lc, ≤c, чc)
is a morphism in ACL whose source object is a De Morgan lattice. (If (La, ≤a) is distributive, then so is (Q, ≤).) Moreover, for any De Morgan lattice (D, ±
, чD, D, ±, чD) and morphism
α: (D, ±, чD, D, ±, чD) → (La, ≤a, чa, Lc, ≤c, чc)
in ACL, there is a unique morphism
h: (D, ±, чD, D, ±, чD) → (Q, ≤, ч, Q, ≤, ч) with ha = hc
in ACL such that αa = πa ◦ ha and αc = πc ◦ hc: hm(d) = (αa(d), αc(d)) defines hm uniquely since ha = hc. Since αa and αc are lattice morphisms, ha and hc are lattice morphisms as well. Finally, ha ◦ чD = ч◦ hc and hc ◦ чD = ч◦ ha follow from the definition of hm, αa ◦ чD = ч◦ αc, and αc ◦ чD = ч◦ αa.
Thus, AC lattices have a universal embedding into a De Morgan lattice. In particular, this theorem applies to all ﬁnite AC semi-lattices. For general AC semi-lattices, we cannot use (Q, ≤, ч) of (27) since it will neither be an inf-


semi-lattice nor a sup-semi-lattice in general. Note that the set of fixed points of ч in (28) is {(x, чax) | x ∈ La}, which equals {(чcy, y) | y ∈ Lc}.

Embedding AC semi-lattices
We now turn to a construction that embeds AC semi-lattices into De Morgan lattices that are complete, in fact, completely distributive [12]. Given an AC semi-lattice (La, ≤a, чa, Lc, ≤c, чc), we define a completely distributive AC lattice:
(L' , ≤' ) d=ef (L(L , ≤ ), ⊆),
(L' , ≤' ) d=ef (U(L , ≤ ), ⊆), and
its negations ч'a and ч'c act as A '→ La \ A.
The maps ϵ : (L , ≤ ) → (L' , ≤' ) and ϵ : (L , ≤ ) → (L' , ≤' ) are defined as
ϵa(x) = ↓ax
ϵc(x) = La \ ϵa(чcx) .
It is routine to show that ϵa preserves all finite infima, ϵc preserves all finite suprema, and that both are order-isomorphisms onto their respective images. Since ч'c ◦ ϵc = ϵa ◦ чc and ч'a ◦ ϵa = ϵc ◦ чa, we have a morphism


'	'
a	a	a	c	c	c	L a, ≤ a, ч a, L c, ≤ c, ч c

in AC such that its co-domain is completely distributive. We did not in- vestigate whether this construction is a left adjoint for the forgetful functor into AC, which forgets that objects are complete and morphisms preserve all infima and suprema (respectively).
At the object level, we may now compose the two embeddings discussed in this section to embed an AC semi-lattice into a De Morgan lattice.

The Mixed Power-order
The AC semi-lattice of Proposition 3.2 orders queries with respect to the partial models they assert or judge to be consistent. Dually, one may order partial models with respect to their asserted queries, as done in (13).
Definition 6.1 For < as in (13) and S ⊆ У, we write ↓S = {P ∈У | ∃Q ∈ S: P <Q} and ↑S = {P ∈У | ∃Q ∈ S: Q<P }.
The refinement order < maintains consistency at the meta-level if models or queries are consistent.

Proposition 6.2 For every φ ∈ L,
[| φ |]a is a lower set and [| φ |]c is an upper set in (У, <);
the equation
[| φ |]a = ↓([| φ |]a ∩ [| φ |]c)
holds iff φ is consistent; and
if У is restricted to consistent models only, (35) holds for all φ, even inconsistent ones.
Implementations of partial models often need to meet multiple, potentially conflicting, constraints — making inconsistency a real possibility. Queries, however, are checked one at a time, and will rarely ever be inconsistent them- selves. Thus, equation (35) will hold in almost all practical situations: a material ontology can violate (35) only by checking an inconsistent query over a set of models of which some are inconsistent. Equation (35) specifies an element of the mixed power-order over <.
Definition 6.3 The mixed power-order [14,15] M(X,≤) for a pre-order (X, ≤) is the sublattice of (L(X, ≤), ⊆) × (U(X, ≤), ⊇) consisting of all pairs (L, U ) that satisfy the consistency condition
L = {x ∈ X | ∃y ∈ L ∩ U : x ≤ y} .
The original definition of the mixed power-domain [14,15] assumes that ≤ is a partial order, X a domain, and L and U enjoy topological properties.
Example 6.4	(i) Let AΣ be a set of Alloy models with static structure Σ.

Then (A
Σ, <Σ) is a pre-order, [| φ |]Σ = ([| φ |]a , [| φ |]c ) is an element of

M(AΣ ,≺Σ) whenever all models in AΣ are consistent or φ is consistent. In that case, (35) is an instance of (36).
(ii) The set-complement negation (L, U ) → (X \ U, X \ L): M(X,≤) → M(X,≤) is well defined iff ≤ is flat: x ≤ y implies x = y. For if ≤ is not flat, let L = X and U = max(X), where max(X) denotes the set of maximal elements of (X, ≤). Then (L, U ) ∈ M(X,≤) but (X \ U, X \ L)= (L', {}) with L' /= {} and so (X \ U, X \ L) /∈ M(X,≤). If ≤ is flat, the negation is well defined.
Although the set-complement negation in M(P,≺) is not well defined in gen- eral, it is well defined on the subset of its L denotations if all models in У are consistent — by Proposition 6.2(iii). Not every element of M(P,≺) is of that form, e.g. (У, max(У)). In general, mixed power-orders themselves have neither binary infima, suprema [15], nor a De Morgan-like negation operation.
Example 6.5 (i) Consider (X, ≤) = ({∗}, (∗, ∗)), (L1, U1) = ({∗}, {∗}),


and (L2, U2) = ({}, {}). Both pairs are elements of M(X,≤) but (L1 ∪ L2, U1 ∩ U2) = ({∗}, {}) is not. Any upper bound (A, C) of the former two sets in M(X,≤) needs to be such that ∗ ∈ A and C ⊆ {}. Hence (L1, U1) and (L2, U2) cannot have a suprema in M(X,≤).
Let again X = {x, y, z} where y and z are two maximal elements and x
the sole minimal element of (X, ≤). Consider

(L1, U2)= ({x, z}, {z})	(L2, U2)= ({x, y}, {y})
(L, U )= ({}, {y, z})	(L',U ')= ({x}, {x, y, z}) .

All four pairs are elements of M(X,≤). Both (L, U ) and (L',U ') are lower bounds of X = {(L1, U1), (L2, U2)}. If X has an infimum (A, C) in M(X,≤), then
L' ⊆ A follows — i.e. x ∈ A — since (L',U ') is a lower bound of
X . Since (A, C) is another such lower bound, we get A ⊆ {x, z} and A ⊆ {x, y}. Thus, A ⊆ {x, z}∩ {x, y} = {x} shows A = {x} as x ∈ A was already established;
U1 ⊆ C and U2 ⊆ C — i.e. {y, z} ⊆ C since (A, C) is a lower bound of X . Since (A, C) is the greatest such lower bound, we obtain C ⊆ U and C ⊆ U ' which implies C ⊆ {y, z}. Thus, C = {y, z}.
A contradiction arises since (A, C)= ({x}, {y, z}) is not in M(X,≤).
Given any pre-order (X, ≤), assume the existence of a map ч: M(X,≤) → M(X,≤) such that ч◦ч = idM  and (L, U ) ≤ (L',U ') implies ч(L',U ') ≤ ч(L, U ) in M(X,≤). Then M(X,≤) is order-isomorphic to its own dual. Since ({},X) is the least element of M(X,≤), M(X,≤) has a greatest element (A, C). From (X, X) ∈ M(X,≤) we then get X ⊆ A, so A = X. From ({}, {}) ∈ M(X,≤) we conclude C ⊆ {}, so C = {}. But (X, {}) is in M(X,≤) only when X is empty.


If we change the ordering in M(X,≤) such that it be ⊆ in each coordinate, then (L((X, ≤)), ⊆) × (U((X, ≤)), ⊆) is simply the De Morgan lattice of Section 5.1 into which we may embed the AC lattice of Example 3.3 for the topology τ = U((X, ≤)) over (X, ≤). If we restrict Q in (27) to its set of coherent pairs, those pairs that satisfy the mix condition (36) — which does not appeal to the ordering on M(X,≤) — we havea least element ({}, {}) and a greatest element (X, X); alas, Examples 6.4(ii) and 9.5 (on page 26) still stand. Nonetheless, it is still conceivable that another map makes this coherent subset of Q into a De Morgan lattice. We did not investigate this any further.

Multiple Viewpoints

AC semi-lattices are also useful for reasoning in situations where multiple partial models mean to describe the same underlying reality.
For example, distributed agents or systems need to store and share incom- plete information. “Group membership” and “fault detection” are mechanisms used in conflict-resolution in fault-tolerant distributed systems [33]. Groups need to maintain a consistent view of which services are available at which hosts, whereas fault detection specifies information flow regarding the change of such information. Inconsistencies result in scheduling services on hosts that no longer exist or no longer offer such services. Records of such information are partial models since the relevant information is expressed as guarantees (“This host offers that service.”) or possibilities (“It is consistent with what we know that this host offers that service.”).
Another application of multiple partial models is in the context of require- ments engineering and requirements elicitation, where behavioral requirements are encoded as partial models. Since requirements solicitation typically means that different stake-holders come up with different observations (and omissions of those), there is the need to detect and locate inconsistencies across model boundaries [30,29]. Although one could lump together all stake-holders’ con- straints into one master model which would then be checked for consistency, this may not be desirable for two reasons. First, stake-holders may use differ- ent formalisms for specifying partial models — with slight variations of static structures and possibly very different name spaces. Second, even if this obsta- cle can be overcome, one often wants to prioritize requirements [37] in order to aggressively drive the specification and implementation process. This is especially true in goal-oriented approaches to requirements engineering [34], where goals will have implicit or explicit comparative rankings.
Therefore, we propose to work with a partial order of priorities between models of the same underlying artifact. This will naturally lead us to con- sider a generalization of finite AC semi-lattices and, perhaps surprisingly, to more efficient algorithms for multiple-valued model checking. Multiple-valued models and multiple-valued logics have a long-standing tradition (see e.g. [13]). But few works have pushed multiple-valued semantics into the realm of partial models, perhaps as one may think of partial models as three-valued models with Kleene’s strong semantics [24]; e.g. as done successfully by Bruns and Godefroid in [5] for Kripke structures.
In a case study in Section 9, we show that the framework for multiple- viewpoint partial models of this section specializes to a multiple-valued com- positional semantics whenever priorities between partial models are honored

as reﬁnements.
The consistency condition (36) for partial checks reduces to L ⊆ U when- ever the pre-order < is flat: x<y implies x = y, but our semantics in (35) was based on a non-flat pre-order of refinement or abstraction. Such non-flat applications of (36) also occur within the framework of abstract interpreta- tion [9]. Multiple-valued partial models and their analysis are another such non-flat application. In a simplified scenario, each element x of a finite partial order (X, ≤) has a partial model Px ∈У — a different view of a software ar- tifact. The relation x ≤ y expresses that Py has higher or equal priority than Px if we think of these models as implementation goals, demands on existing software, state descriptions etc. The interpretation of ≤ suggests that asser- tions validated at a viewpoint are then obliged to hold at viewpoints of lesser priority. That is, we pretend that ≤ be contained in the refinement relation
< and explore the consequences of this containment. In light of Proposi- tion 6.2(i), queries consistent at a viewpoint are then obliged to be consistent in viewpoints of higher priorities. A semantics [20] collects these obligations of validity {|X:φ|}a and consistency {|X:φ|}c
{|X:φ|}a d=ef {x ∈ X | ∃y ∈ X: x ≤ y, P |=aφ}
{|X:φ|}c d=ef {x ∈ X | ∃y ∈ X: y ≤ x, P |=cφ}
def
{|X:φ|} = ({|X:φ|}a, {|X:φ|}c) .
The set {|X:φ|}a computes the assertion-cone of influence of ≤ for the query φ: if we pretend that ≤ is contained in <, which models assert φ? Similarly, the set {|X:φ|}c computes the consistency-cone of influence, those models for which φ is consistent, if we pretend that ≤ is contained in <. These cones of influence are first-order in that consistencies or validities derived from ≤ don’t interfere with the computation of checks Py|=aφ and Py|=cφ. This guarantees efficient computation of the sets in (37) but may not be desirable in approaches where the analysis uses a proof theory, in which obligations may function as additional assumptions. For example, labeled deduction systems can be used to that end [16].
If ≤ happens to be contained in < — a fact we secure for reductions of multiple-valued model checking in subsequent sections — then we can remove all existential quantifiers in (37) as one can always choose x as a witness for y. This results in non-trivial efficiency gains in multiple-valued model checking, as shown in subsequent sections.
A query φ’s cone of influence {|X:φ|} can be computed efficiently only if model checks Px|=mφ can be decided efficiently. The algorithm for comput- ing {|X:φ|}m is depicted in Figure 6. The number of iterations of its while- statement is bounded by the size of X, but will be significantly less than

if (m == a) { leq = <= } % <= for mode a
else	{ leq = >= } % inverse of <= for mode c U = X;
L = emptyset;
while (U != emptyset) {
% invariants: L contained in { X : phi }^m,
%		{ X : phi }^m contained in L union U for all x in max(U,leq) {
if (check(P_x,phi,m)) {
let A = { y | y leq x } in { L = L union A
U = U \ A
}
} else {
U = U \ { x };
}
}
} % post: L = { X : phi }^m
Fig. 6. Algorithm for computing {|X:φ|}m. The order leq equals ≤ for mode a and ≤−1 for mode
c. The method check(P x,phi,m) decides Px|=mφ, potentially abstracting undecided checks to appropriate boolean values. The method max(U,leq) returns the set of maximal elements of the partial order (U,leq).

this for priority orders occurring in practice. We emphasize that only two things are needed for these computations: a model-checking engine for decid- ing Px|=mφ and an implementation of the partial order (X, ≤). The former is achievable for certain static structures — e.g. partial Kripke structures [5] and CTL have efficient model checks — or by putting bounds on the size of models — as done in the tool Alloy.
Given a finite set Φ of queries, one may use the cone-of-influence seman- tics of (37) for instrumented checks. For example, ∩φ∈Φ{|X:φ|}a identifies those viewpoints that are obliged to assert every query in Φ; and ∩φ∈Φ{|X:φ|}c sin- gles out those viewpoints that are obliged to hold the conjunction Φ to be consistent. If Φ = {φ, чφ} or, more generally, if Φ is inconsistent, this inter- section can detect and locate the source of such inconsistency in the multiple- viewpoint setting. Locating the sources of such conflicts simply amounts to choosing all maximal (for m = a) or minimal (for m = c) witnesses for the existential quantifier that determines membership in each {|X:φ|}m being con- sidered.
Example 7.1 Consider the partial order (X, ≤) with X = {v, x, y, z} of Fig- ure 7, where for each u ∈ X the model Pu is a partial interpretation of the




a: p, q











a: ¬q
c: p, ¬q
a: assertions that hold
c: checks that are consistent






a: ¬p, ¬q c: ¬p, ¬q


a: ¬p, ¬q c: ¬p, ¬q


Fig. 7. A multiple-viewpoint scenario with consistent viewpoints which illustrates (i) that incon- sistencies can be effectively detected and located (Example 7.1); and (ii) that the negation in (39) does not reverse inclusions (Example 8.2).
propositions p and q. For example, in Px we have that p and чq are consis- tent and чq is a valid assertion. The conjunction p Λ q Λ чp Λ чq of all those literals that are consistent in some model Pu, the “master model” alluded to earlier, is clearly inconsistent and this could be tested for with a standard SAT solver. Priorities, however, provide a means for locating potential sources of such inconsistencies. We compute {|X:p|}c = {x, z} and {|X:чp|}c = {v, y, z}. The intersection {|X:p|}c ∩ {|X:чp|}c contains all points (only z) that have an inconsistency based on Φ = {p, чp}. In this case, x is the unique minimal (as m= c) u such that Pu causes z ∈ {|X:p|}c and y is the unique minimal v such that Pv causes z ∈ {|X:чp|}c. Thus, conflict resolution should focus on Px and Py.

Abstract interpretation
In applications, checks P |=mφ may not be decidable. In that case, undecidable instances of check(P x,phi,m) in Figure 6 need to be interpreted as booleans such that the resulting cone of influence be a conservative approximation of the one specified in (37). If (A, C) is the resulting approximation of {|X:φ|}, its soundness is specified as (A, C) ≤ {|X:φ|} in (L((X, ≤)), ⊆)×(U((X, ≤)), ⊇)— the pair (A, C) may not be in M(X,≤). Soundness can be secured if undecided checks are interpreted as ff and tt in mode a and c (respectively). For mode a, whenever Px|=aφ holds but is undecided the algorithm then chooses the else- branch and L will not change. Conversely, any if-branch execution will add elements from {|X:φ|}a only. Thus, A ⊆ {|X:φ|}a follows. For mode c, whenever Px|=cφ holds but is undecided the algorithm then chooses the if-branch and L will add elements that may not be in {|X:φ|}c. Since only if-branch executions change L and since the else-branch is only executed when the check is decided to be ff, we infer {|X:φ|}c ⊆ C as required.
We note that this approximation applies directly to theorem provers if



a: p
c: p

















Fig. 8. A multiple-viewpoint scenario with consistent viewpoints which illustrates (Example 7.3) that the assertion-cone of influence is not contained in the consistency-cone of influence in general.

instances of (5) and (6) are representable as theorems. However, it does not match at all Alloy’s reduction of checks to SAT instances. In Alloy, checks P |=aφ only return with ff or probably true, whereas checks P |=cφ only return with tt or probably false. Thus, the interpretation above would always reply with the same answer, ff in mode a and tt in mode c, and (A, C) would equal ({},X), the least (informative) element of M(X,≤). Alternatively, one may use Alloy’s small-scope hypothesis [22] to obtain an unsound but potentially useful approximation of {|X:φ|}.

Mixed power-order
Denotations of multiple-viewpoint checks are elements of the mixed power- order.
Lemma 7.2 Let (X, ≤) be a pre-order and all models Px be consistent.
For every φ ∈ L, the element {|X:φ|} is in M(X,≤).
If ≤ is contained in <, then {|X:φ|}a ⊆ {|X:φ|}c.
Example 7.3 In general, {|X:p|}a won’t be a subset of {|X:p|}c even if all Px are consistent. For y < x < z, Pz|=ap, Px |/=cp, and Py |/=cp (see Figure 8) we derive x ∈ {|X:p|}a \ {|X:p|}c. In that case, neither y ≤ z nor x ≤ z are instances of <.

Semantic entailment
Semantic entailment is preserved under a multiple-viewpoint interpretation.
Proposition 7.4 For every partial order (X, ≤), the map
def
Φ ([| φ |]) = {|X:φ|}: (La, ⊆) × (Lc, ⊇) → M
is monotone, where [| φ |] = ([| φ |]a, [| φ |]c).


The monotonicity of ΦX is significant. If [| φ |] ≤ [| ψ |] models semantic entail- ment or if У is enriched with a theory of such entailments, then this theory will also hold in the multiple-viewpoint obligation semantics for (X, ≤).
Reﬁnement
The information collected in cones of influence of queries remains valid under refinement of viewpoints. Let (X, ≤) be a finite partial order such that for each x ∈ X there are two partial models Px and Qx with Qx<Px. We write
{|XP :φ|} and {|XQ:φ|} for the cones-of-influence semantics over all Px and Qx, respectively.
Proposition 7.5 For all φ, {|XP :φ|} ≤ {|XQ:φ|} in M(X,≤).
Therefore, the detection and location of inconsistencies, based on {|XP :φ|}, remains to be a valid analysis and diagnostics if single-viewpoint models Px get refined or implemented by some Qx. Naturally, this remains true whenever the semantics in (37) serves as a reduction for a compositional multiple-valued semantics in subsequent sections.
Consistent viewpoints
There are cost-effective tools for guaranteeing the consistency of models Px. We give two examples. Alloy’s constraint analyzer may validate the con- sistency of complex partial models. Alternatively, the static structure may be such that its models are consistent by construction, e.g. the partial Kripke structures of Bruns & Godefroid [5]. Therefore, one may often assume that all models Px are consistent. What is then at issue are inconsistencies that arise from conflicts across models Px and our cone-of-influence semantics should prove a valuable tool.

Negation Over Multiple Viewpoints
We now study possible interpretations of negation on queries in the setting of partial models over multiple viewpoints. We see that the mode-sensitive negation of AC lattices, unlike Heyting negations, harmonizes well with the internal consistency of assertion and consistency checks. By Lemma 7.2(i),
def
ч{|X:φ|} = {|X:чφ|}
has type im(ΦX) → M(P,≺) with component maps чm{|X:φ|}m = {|X:чφ|}¬m,
m ∈ {a, c}. We define
Lm d=ef {{|X:φ|}m | φ ∈ L}	m ∈ {a, c} .


Proposition 8.1 Let ≤ be contained in < and all Px consistent.
The negation in (39) acts as (L, U ) '→ (X \ U, X \ L).
The tuple (La , ⊆, чa , Lc , ⊆, чc ) is an AC semi-lattice.
X	X	X	X
In particular if ≤ is contained in <, then {|X:φ|}m ⊆ {|X:ψ|}m implies that
{|X:чψ|}¬m is contained in {|X:чφ|}¬m. This is no longer true without that assumption.
Example 8.2 Consider the partial order depicted in Figure 7. It assumes that all properties p, q, чp, чq are distinct and states which properties hold in which mode. Properties don’t hold in a mode if they are not stated. E.g. we have Px|=aчq but we don’t have Px|=ap. We compute {|X:p|}a = X \ {v} =
{|X:q|}a, but {|X:чq|}a = X \{z} is not a subset of {|X:чp|}a = X \{x, z}. Note that all models Px, Py, Pz, and Pv are consistent.
What structure does Lm have for general partial orders ≤? With ч as in (39) we retain the first two axioms for AC semi-lattices. If ≤ is not contained in
<, the remaining ones are lost — as seen in Example 8.2. Without the last two axioms, we have no guarantee that (La , ⊆) has finite infima, despite the
fact that Lc has finite suprema. On the bright side, {|X:φ|} ∈ M(X,≤) ensures
the internal consistency of our cone-of-influence semantics.
Each partial order (Lm, ⊆) sits within a finite distributive lattice of lower, respectively, upper sets. If ≤ is not contained in <, one may be tempted to seek an alternative semantics of negation by applying the corresponding Heyting negations of those lattices — чA: L((X, ≤)) → L((X, ≤)) and чC: U((X, ≤)) → U((X, ≤)) — to denotations:
ч L d=ef  {L' ∈ L((X, ≤)) | L ∩ L' = {}}
чCU =  {U ' ∈ U((X, ≤)) | U ∪ U ' = X} .
def
This will restore the last two axioms of AC semi-lattices, but brake the first two axioms. Even worse, such a course of action abandons the consistency condition (36) altogether.
Example 8.3 Let X = {x, y, z} be as in Figure 9. Consider L = {x, y} and U = {y, z}. Then (L, U ) is in M(X,≤) and equals {|X:p|} over consistent models since Py|=ap, Py|=cp, and Pz|=cp are the only holding instances of checks for
p. We compute чAL = {z} since any larger lower set needs to intersect L. Similarly, чCU equals {x, y} since any U ' with U ∪ U ' = X has to contain x and therefore y as well and since {x, y} is such a U '. The pair (чAL, чCU ) is not in M(X,≤) since its sets are non-empty but have empty intersection.


a: p
c: p





c: p


Fig. 9. A multiple-viewpoint scenario with consistent viewpoints which illustrates (Example 8.3) that a negation based on a pairwise Heyting negation won’t map into M(X,≤) in general.
One can further show qualified inclusions and equalities between чM, чm
of (39), and \ and we refer the interested reader to the technical report [20].

Multiple-valued Semantics for Partial Models
We put to use the insights and techniques developed in previous sections by showing that our algorithm of Figure 6 computes a multiple-valued property semantics whenever single-viewpoint models are determined by the primes of the underlying AC lattice and the order between primes is preserved as refine- ment between their corresponding single-viewpoint models. These techniques apply to a wide range of static structures and logics. For example, in [20] we showed this for multiple-valued modal transition systems and a tempo- ral logic with fixed points. Here we choose a case study of multiple-valued state-machines with first-order logic plus transitive closure.
Definition 9.1 Let (X, ≤) be a finite partial order.
We define K(X,≤) to be the set of all those elements (L, U ) of M(X,≤) with
L ⊆ U , in the ordering induced by M(X,≤).
For a set of propositions AP, and a set of states S,a modal multiple-valued state-machine (mmv state-machine) P is a tuple
(S, I: S → K(X,≤), R: S × S → K(X,≤), Lb: AP × S → K(X,≤))
where I identifies initial states, R is a transition function, and Lb a labeling function. We call (AP, (X, ≤)) the type of P and write P = (S, I, R, Lb) if that type is determined by context.
For each s, s' ∈ S and p ∈ AP the sets I(s), R(s, s'), and Lb(p, s) are of the form (L, U ). For those bindings of L and U , we write I(s)m, R(s, s')m, and Lb(p, s)m for the set L (m being a) and U (m being c), respectively.
Since I(s), R(s, s'), and Lb(p, s) are of the form (L, U ) ∈ K(X,≤), we under- stand that L measures the degree of validity and U the degree of consistency of the statements “State s is initial,” “There is a transition from s to s',”


and “Proposition p holds at s” (respectively). Internal consistency is enforced since all witnesses x ∈ L to validity are also witnesses to consistency (x ∈ U ).
Example 9.2 If X = {∗}, then K(X,≤) and M(X,≤) are isomorphic to the par- tial order 1/2 < 0, 1 where 0 and 1 are distinct maximal elements [19]. Thus, mmv state-machines with type (AP, ({∗}, {(∗, ∗)})) correspond to state-based versions of modal transition systems [26]. If I is omitted and R never maps to 1/2, mmv state-machines with that type are the partial Kripke structures of [5,6].
We assume a first-order logic with transitive closure, unary relation symbols p for each p ∈ AP, and a sole binary relation symbol R for R — where +R denotes the transitive closure of R. With u, v etc ranging over a set Var of variables for states, the grammar of the query logic is
φ ::= ⊥ | p(u) | R(u, u) | +R(u, u) | чφ | φ V φ | Eu φ.
In particular, this logic is expressive enough to encode most practical temporal logics, e.g. LTL and CTL. We write φ Λ ψ as a shorthand for ч(чφ V чψ). (In applications, the predicate I(s) may be seen as a special case of p(u), whence we did not include it in (43).) Environments ρ: Var → S bind variables to states. For such environments, we define a compositional query semantics [| φ |]P as the meaning of φ in the mmv state-machine P under environment ρ.
The demands on this semantics are that it
is compositional;
has a formal notion of refinement such that refining models are consistent with but more specified than their refinements;
is sound with respect to this refinement;
has a clean interpretation of negation; and
can be computed by projecting models down to single-valued ones and then using the efficient algorithm of Figure 6.
We expect that meanings [| φ |]P are elements of K(X,≤), establishing their in- ternal consistency. The interpretation of atomic formulas will be consistent due to the consistency of models. The interpretations of disjunction and ex- istential quantification rely on the fact that the mixed power-order has a well defined union operation [14,15]:
(L, U ) H (L',U ') d=ef (L ∪ L',U ∪ U '): M	× M	→ M
which is easily seen to restrict to K(X,≤). Since H is commutative and asso- ciative, we write for the application of H to a, possibly infinite, subset of M(X,≤). We now interpret +R.

Definition 9.3 For mmv state-machines, we interpret +R as a function
R+: S × S → K(X,≤).
For each s, s' ∈ S, R+(s, s') equals (L, U ), where U is defined as all those y for which we can find a finite “consistent” path from s to s' in P : there is some n ≥ 0 and states s = s0, s1, ..., sn = s' such that y ∈  n−1 Rc(si, si+1). (Note that U is an upper subset.) Let L be the set of all those x ∈ X which have an “asserted” path from s to s': there is some m ≥ 0 and states s = t0, t1, ..., tm = s' such that x ∈  m−1 Ra(ti, ti+1). Since Ra(s, s') ⊆ Rc(s, s') for all s, s' ∈ S, we infer L ⊆ U . Thus, the interpretation of +R is well defined.
The compositional query semantics [| φ |]P is depicted in Figure 10. Below, we show that such meanings are elements of K(X,≤) and prove that [| φ |]P equals
{|X:φ|}ρ, where Px is a state-machine with type (AP, ({∗}, {(∗, ∗)})) for each x ∈ X. In particular, such meanings can be efficiently computed with the algorithm in Figure 6.
Lemma 9.4 Let P be a mmv state-machine. Then [| φ |]Pa ⊆ [| φ |]Pc for all φ
ρ	ρ
and ρ.
Somewhat surprisingly, our case study would fail for meanings of type
M(X,≤).
Example 9.5 According to the semantics in Figure 10, conjunction — de- fined through V and ч — is interpreted as (L, U ) H (L',U ') d=ef (L ∩ L',U ∩ U '). This map is not well defined in M(X,≤), justifying our move from M(X,≤) to K(X,≤). Consider the (X, ≤) of Example 4.4 on page 11. The pairs (L, U ) = ({x, z}, {z}) and (L',U ')= ({x, y}, {y}) are in M(X,≤) but the pair (L∩ L',U ∩ U ')= ({x}, {}) is not.
The pair (L, U ) is the denotation of p and (L',U ') is the denotation of q if x asserts p and q; y asserts q and deems q to be consistent; and z asserts p and deems q to be consistent.
One could circumvent this problem by saturating models as follows: If (L, U ) is the meaning of an observable of the model, one can saturate that pair to an observable
(L, ↑L ∪ U )
so in our example the pair (L, U ) would turn into (L, X) and (L',U ') turns into (L',X); thus, the saturated conjunction renders ({x},X) ∈ M(X,≤).
Definition 9.6 Let P be a mmv state-machine as in (42).
For each x ∈ X, the map


πx: K(X,≤) → K({∗},{(∗,∗)})


[|⊥ |]P = ({}, {})	[| p(u) |]P = Lb(p, ρ(u))
ρ	ρ
[| R(u, v) |]P = R(ρ(u), ρ(v))	[| +R(u, v) |]P = R+(ρ(u), ρ(v))
ρ	ρ
[| чφ |]P = (X \ [| φ |]Pc ,X \ [| φ |]Pa )	[| φ V ψ |]P = [| φ |]P H [| ψ |]P

ρ
[| Eu φ |]P = .


s∈S
ρ	ρ
ρ[u'→s].
ρ	ρ	ρ

Fig. 10. Compositional query semantics for mmv state-machines P under environment ρ. We write [| φ |]Pa and [| φ |]Pc for the first and second element of [| φ |]P, respectively.
ρ	ρ	ρ
is defined by πx(L, U ) = ({∗ | x ∈ L}, {∗ | x ∈ U }).
(ii) For each x ∈ X, we define the mmv state-machine


Also, R+ d=ef π

R+.
Px = (S, πx ◦ I, πx ◦ R, πx ◦ L).

x	x
It is elementary to check that the structure Px in (48) is a mmv state-machine of type (AP, ({∗}, {(∗, ∗)})), for L ⊆ U implies {∗ | x ∈ L} ⊆ {∗ | x ∈ U }. Throughout this section, Px refers to the mmv state-machine in (48). We specify the semantics for assertion checks |=a and consistency checks |=c for these models Px, where m ∈ {a, c}:

Px |=/
m⊥;

Px|=mp(u) iff ∗∈ πx(Lbm(p, ρ(u)));
Px|=mR(u, v) iff ∗∈ πx(Rm(ρ(u), ρ(v)));
Px|=m+R(u, v) iff ∗∈ πx((R+)m(ρ(u), ρ(v)));

Px|=mчφ iff Px|=/
¬mφ;

Px|=mφ V ψ iff (Px|=mφ or Px|=mψ);
ρ	ρ	ρ
Px|=mEu φ iff for some s ∈ S, Px|=m	φ.
ρ	ρ[u'→s]
From this definition, we readily obtain Px|=mφ Λ ψ iff (Px|=mφ and Px|=mψ).
ρ	ρ	ρ
We record important facts about these partial models and their compositional
semantics |=m.
Proposition 9.7	(i) For all φ, ρ, and x we have that Px|=aφ implies Px|=c φ.
ρ	ρ
(ii) Whenever x ≤ y, then Px<Py.
Given item (ii) above and the mode-sensitive treatment of negation in AC
lattices, we can now show that [| φ |]P equals {|X:φ|}ρ — where the latter is
defined as in (37) with |=m instead of |=m. In particular, we can compute
the former semantics by using the more efficient algorithm of Figure 6 and computing the single-view models Px whenever needed in its control flow. We


first prove that {|X:φ|}ρ, although computed by a non-compositional synthesis of obligations in (37), is compositional.
Lemma 9.8 Let (Px)x∈X be as in (48).
All models Px are consistent.
For all ρ we have {|X:⊥|}ρ = ({}, {}).
For all p(u) and ρ we have {|X:p(u)|}ρ = Lb(p, ρ(u)).
For all R(u, v) and ρ we have {|X:R(u, v)|}ρ = R(ρ(u), ρ(v)).
For all φ, ρ, and m ∈ {a, c} we have {|X:чφ|}m = X \ {|X:φ|}¬m.
ρ	ρ
For all φ, ψ, and ρ we have {|X:φ V ψ|}ρ = {|X:φ|}ρ H {|X:ψ|}ρ.
For all Eu φ and ρ we have {|X:Eu φ|}ρ = .t∈S {|X:φ|}ρ[u'→t].
With this lemma at hand, we can prove the main result of this section.
Theorem 9.9 For all mmv state-machines P, formulas φ, and environments
ρ we have [| φ |]P = {|X:φ|}ρ.
Example 9.10 Consider the mmv state-machine depicted in Figure 11. We compute [| Ev (+R(v, v) Λ чp(v)) |]P. This query asks whether there is a state that is on a cycle and does not satisfy p. From Figure 10, we infer that this query has meaning (L0 ∪ L1 ∪ L2, U0 ∪ U1 ∪ U2), where

Li = [| +R(v, v) |]Pa
Ui = [| +R(v, v) |]Pc
∩ (X \ [| p(v) |]Pc	)
i
∩ (X \ [| p(v) |]Pa	) .
i

We have L0 = {x}∩ (X \ {u, v, x}) = {} since only x asserts a path from s0 to s0 and only y thinks that p is inconsistent at that state. Similarly, we compute L1 = {x, y}∩ (X \ X)= {} and L2 = {x}∩ (X \ {u, v, y})= {x}.
As for the consistency semantics, we obtain U0 = {u, v, x}∩ (X \ {x})= 
{u, v} since only u, v, and x think that a loop from s0 to s0 is consistent and only x asserts p at that state. Similarly, U1 = X ∩ (X \ {x, y})= {u, v} and U2 = X ∩ (X \ {y}) = {u, v, x}. Thus, [| Ev (+R(v, v) Λ чp(v)) |]P = ({x}, {u, v, x}). This means that x thinks the query is valid; whereas u, v, and x deem the query to be consistent.

Degree of partiality
Our query semantics comes with a measurement of uncertainty. The map
µP : L× Env → {0, 1,... , |X|}, defined by
def
µ (φ, ρ) =| [| φ |]Pc \ [| φ |]Pa |
P	ρ	ρ



a: {y}







s1






s2
a: {y} c: X




Fig. 11. A mmv state-machine with AP = {p} and (X, ≤) as in Figure 12. The labeling function Lb is specified within states; e.g. Lb(p, s0 ) = ({x}, {u, v, x}). Modeling information of the form ({}, {}), be it initial states or transitions, is not shown. The transition into s0 without any source specifies I(s0).
measures the degree of partiality of property φ over the mmv state-machine P in environment ρ. For the check from Example 9.10, this computes to 3 − 1 = 2. For a systematic theory of measurements see [28,27,36].
Reﬁnement
Since [| φ |]P equals {|X:φ|}ρ, Proposition 7.5 ensures soundness of our semantics if P changes to Q such that Qx<Px for all x ∈ X. It is routine to define co- inductive relations for mmv state-machines — similar to the ones for modal transition systems [26] or partial Kripke structures [5] — such that all in- stances of such relations represent refinements between all projected models Qx and Px.
Total models
A mmv state-machine P with type (AP, ({∗}, {(∗, ∗)})) is total iff its functions Lb and R map into the diagonal {({}, {}), ({∗}, {∗})}. For total models of that type, |=a equals |=c and is the usual semantics for Kripke structures.
Example 9.11 Totality cannot be characterized in this way for mvv state- machines whose type contains a non-flat order. Consider the mmv state- machine with one state, one unary predicate p, and no transitions. Figure 12


c: p











Fig. 12. Assertion checks are different from consistency checks for total mmv state-machines in general (Example 9.11).
shows (X, ≤) and the labeling function for that state. The pair (L, U ) = ({x}, {x, u, v}) is maximal in K(X,≤), but L /= U .

Strong semantics
In comparison to the semantics of Section 2, our specification of checks over
Px, put forward in this section, is an abstraction: Px|=aφ V ψ certainly holds
ρ
whenever (P |=aφ or P |=aψ

x  ρ	x
ρ  ), but our compositional semantics makes the

latter also a necessary condition. This results in a loss of precision. Stronger
versions of this semantics exist — e.g. the focus operation of Ball et al. [2] for program analysis and Bruns and Godefroid’s generalized model checking [6] for partial Kripke structures. One can extend generalized model checking to mmv state-machines P through a strong version of the cone-of-influence semantics. Projected models Px are then checked with respect to the strong semantics, which is an instance of our ontology. (However, it is unclear whether this semantics has a meaningful interpretation at the level of mmv state-machines.)
Definition 9.12 Let У be the set of all mmv state-machines of the same type (AP, (X, ≤)) and state space S. For P, Q ∈ У,
P ± Q iff IP ≤ IQ, RP ≤ RQ, and LbP ≤ LbQ in the point-wise ordering of K(X,≤);
Q is total iff Q is maximal with respect to ±: for all K ∈ У, Q ± K
implies K ± Q; and
the implementation relationship is defined as
def
impl = {(P, Q) | P ± Q, Q total}.
It is immediate that P is total iff all its component functions IP , RP , and LbP map into the set of maximal elements of K(X,≤). From Example 9.11 we learn that L = U does not necessarily hold for maximal elements (L, U ) in K(X,≤).
Example 9.13 If P has type (AP, ({∗}, {(∗, ∗)})), then P is a three-valued Kripke structure and TP = {Q | (P, Q) ∈ impl} forms a complete cover [6] of


Kripke structures: every Q ∈ TP refines P and every Kripke structure which refines P is refined by some element of TP , where refinement is defined similar to the completeness order in [6]. Elements Q of TP resolve all modeling information ({}, {∗}) (truth unknown) of P into either ({∗}, {∗}) (true) or ({}, {}) (false).
Definition 9.14	(i) We define a strong semantics |=m(s) for mmv state- machines P of type (AP, ({∗}, {(∗, ∗)})) as in (5–6), where |= turns into
|=ρ, the environment-based standard semantics over Kripke structures.
(ii) The strong cone-of-influence semantics {|X:φ|}s d=ef ({|X:φ|}a(s), {|X:φ|}c(s))
ρ	ρ	ρ
is defined as in (37), expect that we replace all |=m with |=m(s).

The relations |=m(s) represent the strong semantics |=s of [6]. Soundness of our compositional semantics |=m with respect to the strong semantics holds: P |=aφ
implies P |=a(s)φ and P |=c(s)φ implies P |=c φ. Therefore, {|X:φ|}ρ ≤ {|X:φ|}s for
ρ	ρ	ρ	ρ

all φ and ρ. Since |=m(s)
is non-compositional, there is probably no strong

compositional analogue of [| φ |]P.

Related Work
Fitting studies multiple-valued Kripke structures and a multiple-valued proof theory in [11], where a partial order of experts enforces consistency of their assertions about the truth and falsity of transitions and state observables.
Easterbrook and Chechik use Fitting’s models and a De Morgan lattice ‘negotiated’ among experts to derive a multiple-valued version of the temporal logic CTL, its models, and its model checking algorithm (e.g. [8]).
Bruns and Godefroid [7] devise a query checker for temporal logic that, given a Kripke structure and a query with a hole in it as input, returns a (strongest) formula of propositional logic that, when placed into the query’s hole, makes the query true for that Kripke structure. Among other things, this technique is of use in the reverse engineering of systems.
The handbook article by Blamey [4] nicely surveys extant work on partial logics and their semantics, emphasizing linguistics and philosophical logic as applications.
A wide range of multiple-valued logics employ a lattice of truth values, which is often finite and distributive. Semi-bilattices [13] take this further by having two orderings: an information order which captures uncertainty, and a logical order which captures degree of truth.

Conclusions
In this paper we developed proper foundations for partial model checking that subsume work on multiple-viewpoint and multiple-valued checking. We proposed AC semi-lattices as a generalization of De Morgan lattices in the finite distributive case. These structures lead to an efficient algorithm for de- tecting and locating inconsistencies across model boundaries, where models are partially ordered by priorities, which specify the poset of primes for the underlying AC lattice. We also saw that the same algorithm provides a, gen- erally more efficient, implementation of compositional multiple-valued model checking whenever the order on primes leads to refinement between their cor- responding ‘projected’ single-viewpoint models. We also showed that such proper semantic foundations are unlikely to exist if negation is implemented via Heyting negations.
Although our work is completely inspired by and drawn from the work of Fitting in [11] — and programmatically anticipated in the position paper
[17] — our contributions complement his approach in that we
allow experts to under-specify their models,
allow the priority (‘dominance’ in [11]) order not to be reflected as re- finement, turning this mathematical weakness into a practically relevant detection and diagnostics tool,
don’t develop multiple-valued proof theories, but synthesize and instru- ment obligation sets as ordinary model checks, and
make a case for not using Heyting negations.
Item (iii) is central to our approach. For one thing, it allows the use of whatever techniques available to specify and check single-viewpoint models (modular description languages, abstraction, compact data structures etc). For another, it integrates well with design-review techniques, where checks of single-viewpoint queries may be answered by real-life experts whose con- sistency and assertion rulings are based on their fallible domain-specific ex- pertise. The algorithm in Figure 6 and its instrumentations discussed in this paper apply equally well in this setting.

Acknowledgments
We gratefully acknowledge Glenn Bruns and Marsha Chechik for valuable discussions and most useful comments regarding this material. Glenn Bruns and, independently, Gordon Plotkin suggested to consider the possibility of embedding AC lattices into De Morgan lattices.

References
S. Abramsky and A. Jung. Domain theory. In S. Abramsky, D. M. Gabbay, and T. S. E. Maibaum, editors, Handbook of Logic in Computer Science, volume 3, pages 1–168. Oxford Univ. Press, 1994.
T. Ball, A. Podelski, and S. K. Rajamani. Boolean and Cartesian Abstraction for Model Checking C Programs. In T. Margaria and W. Yi, editors, Proceedings of TACAS’2001, volume 2031 of LNCS, pages 268–283, Genova, Italy, April 2001. Springer Verlag.
N. Belnap. A useful four-valued logic. In J. M. Dunn, editor, Modern Uses of Many-Valued Logic, pages 8–37. Reidel, 1977.
S. Blamey. Partial logic. In D. Gabbay and F. Guenthner, editors, Handbook of Philosophical Logic, Volume 3: Alternatives to Classical Logic, pages 1–70, 1986.
G. Bruns and P. Godefroid. Model Checking Partial State Spaces with 3-Valued Temporal Logics. In Proceedings of the 11th Conference on Computer Aided Veriﬁcation, volume 1633 of Lecture Notes in Computer Science, pages 274–287. Springer Verlag, July 1999.
G. Bruns and P. Godefroid. Generalized Model Checking: Reasoning about Partial State Spaces. In Proceedings of CONCUR’2000 (11th International Conference on Concurrency Theory), volume 1877 of Lecture Notes in Computer Science, pages 168–182. Springer Verlag, August 2000.
G. Bruns and P. Godefroid. Temporal Logic Query Checking. In Proceedings of the 16th Annual IEEE Symposium on Logic in Computer Science, pages 409–417, Boston, Massachusetts, 16-19 June 2001. IEEE Computer Society Press.
M. Chechik, B. Devereux, and S. M. Easterbrook. Implementing a Multi-Valued Symbolic Model Checker. In Proceedings of the Fourth European Joint Conferences on Theory and Practice of Software (ETAPS2001) - Tools and Algorithms for the Construction and Analysis of Systems (TACAS 2001), Lecture Notes in Computer Science, pages 404–419, Genova, Italy, 2-6 April 2001. Springer Verlag.
P. Cousot and R. Cousot. Abstract interpretation: a unified lattice model for static analysis of programs. In Proc. 4th ACM Symp. on Principles of Programming Languages, pages 238–252. ACM Press, 1977.
J. M. Dunn. What Is Negation?, chapter A Comparative Study of Various Model-Theoretic Treatments of Negation: A History of Formal Negation. Kluwer Academic Publishers, 1999.
M. Fitting. Many-valued modal logics II. Fundamenta Informaticae, 17:55–73, 1992.
G. Gierz, K. H. Hofmann, K. Keimel, J. D. Lawson, M. Mislove, and D. S. Scott. A Compendium of Continuous Lattices. Springer Verlag, 1980.
M. L. Ginsberg. Multivalued Logics. In Proceedings of the 5th International Conference on Artiﬁcial Intelligence (AAAI’86), pages 243–247. Morgan-Kaufmann, 1986.
C. Gunter. The mixed power domain. Theoretical Computer Science, 103:311–334, 1992.
R. Heckmann. Power domains and second order predicates. Theoretical Computer Science, 111:59–88, 1993.
A. Hunter and B. Nuseibeh. Managing Inconsistent Specifications: Reasoning, Analysis, and Action. ACM Transactions on Software Engineering and Methodology, 7(4):335–367, October 1998.
M. Huth and S. Pradhan. Abstraction and refinement for model checking inconsistent systems. Position paper presented at The Second International Workship on Living with Inconsistencies, 13 May 2001, Toronto, Canada. URL: www.cis.ksu.edu/~huth/lwi2.ps

M. Huth, R. Jagadeesan, and D. Schmidt. Modal transition systems: a foundation for three- valued program analysis. In Sands D., editor, Proceedings of the European Symposium on Programming (ESOP’2001), pages 155–169. Springer Verlag, April 2001.


M. Huth, R. Jagadeesan, and D. A. Schmidt. A domain equation for refinement of partial systems. Accepted for publication in the journal Mathematical Structures in Computer Science, January 2003.
M. Huth and S. Pradhan. Lifting assertion and consistency checkers from single to multiple viewpoints. Technical Report TR 2002/11, Imperial College London, Department of Computing, London, UK, March 2002.
D. Jackson. Alloy: A Lightweight Object Modelling Language. Technical Report TR-797, Laboratory of Computer Science, Massachusetts Institute of Technology, 28 July 2000.
D. Jackson, I. Shlyakhter, and M. Sridharan. A Micromodularity Mechanism. In Proceedings of the ACM SIGSOFT Conference on the Foundations of Software Engineering/European Software Engineering Conference (FSE/ESEC’01), September 2001.
P. T. Johnstone. Stone spaces. Number 3 in Cambridge studies in advanced mathemathics. Cambridge University Press, 1982.
S. C. Kleene. Introduction to Metamathematics. Van Nostrand, 1952.
K. G. Larsen. Modal Specifications. In J. Sifakis, editor, Automatic Veriﬁcation Methods for Finite State Systems, number 407 in Lecture Notes in Computer Science, pages 232–246. Springer Verlag, June 12–14 1989. International Workshop, Grenoble, France.
K. G. Larsen and B. Thomsen. A Modal Process Logic. In Third Annual Symposium on Logic in Computer Science, pages 203–210. IEEE Computer Society Press, 1988.
K. Martin. Nonclassical techniques for models of computation. In Topology Proceedings, volume 24, 1999.
K. Martin. A Foundation for Computation. PhD thesis, Department of Mathematics, Tulane University of Louisiana, New Orleans, LA 70118, 2000.
B. Nuseibeh and S. M. Easterbrook. The Process of Inconsistency Management: A framework for understanding. In Proceedings of the First International Workshop on the Requirements Engineering Process (REP’99), 2-3 September 1999.
B. Nuseibeh, J. Kramer, and A. Finkelstein. A Framework for Expressing the Relationships Between Multiple Views in Requirements Specification. IEEE Transactions on Software Engineering, 20(10):760–773, October 1994.
C. S. Pasareanu, M. B. Dwyer, and W. Visser. Finding Feasible Counter-examples when Model Checking Abstracted Java Programs. In T. Margaria and W. Yi, editors, In: Proc. of the 7th International Conference on Tools and Algorithms for the Construction and Analysis of Systems (TACAS’01), volume 2031 of LNCS, pages 284–298, Genova, Italy, April 2-4 2001. Springer Verlag.
M. Sagiv, T. Reps, and R. Wilhelm. Parametric Shape Analysis via 3-Valued Logic. In Proceedings of the 26th ACM SIGPLAN-SIGACT Symposium on Principles of programming languages, pages 105–118, January 20-22, San Antonio, Texas 1999.
A. Schiper. Failure Detection vs Group Membership. In H. Hermanns and R. Segala, editors, Process Algebra and Probabilistic Methods, Performance Modeling and Veriﬁcation, Second Joint International Workshop PAPM-PROBMIV 2002, volume 2399 of Lecture Notes in Computer Science, pages 1–15, Copenhagen, Denmark, July 25-26 2002. Springer.
A. van Lamsweerde. Goal-Oriented Requirements Engineering. Invited talk at the BSC-RESG One-Day Symposium on “Using Formal Models to Understand Requirements Better.” Imperial College London, 6 November 2002.
D. J. Walker. Bisimulation and divergence. Information and Computation, 85(2):202–241, 1990.
P. Waszkiewicz. Quantitative Continuous Domains. PhD thesis, School of Computer Science, University of Birmingham, Birmingham, B15 2TT, United Kingdom, August 2002.
K. Wiegers. First Things First: Prioritizing Requirements. Software Development Online, September 1999.

Proofs
Proof. [of Proposition 3.2] Verification of the first two axioms in Figure 5 (left) follows from the fact that ччφ and φ are semantically equivalent for |=;
e.g. P |=cччφ iff (there is some P ' with (P, P ') ∈ impl and P ' |= ччφ) iff (there is some P ' with (P, P ') ∈ impl and P ' |= φ) iff P |=cφ. For the third axiom, let

(.1)
[| φ |]a ⊆ [| ψ |]a.

Assume P ∈ чa[| ψ |]a(= [| чψ |]c). We claim that P ∈ чa[| φ |]a(= [| чφ |]c).
Otherwise, P /∈ [| чφ |]c, i.e. P |=/ cчφ. Then (7) renders P |=aφ. By (.1), we
obtain P |=aψ. By assumption, P |=cчψ which means that there is a P ' with (P, P ') ∈ impl and P ' |= чψ. From P |=aψ and (P, P ') ∈ impl we infer P ' |= ψ. But then P ' |= ψ Λ чψ follows, contradicting (4).
For the fourth axiom, we reason in a similar style. Let

(.2)
[| φ |]c ⊆ [| ψ |]c.

Assume P ∈ чc[| ψ |]c(= [| чψ |]a). We claim that P ∈ чc[| φ |]c(= [| чφ |]a). Proof by contradiction: otherwise, P /∈ [| чφ |]a, i.e. P |/=aчφ. But then (5) implies the existence of some P ' with (P, P ') ∈ impl and P ' |= чφ, i.e. P ' |= φ. Then (6) renders P |=cφ. By (.2), P |=cψ as well. But by assumption, P |=aчψ — a contradiction now reasoned as for the third axiom.
Finally, [| φ |]a ∩ [| ψ |]a = [| φ Λ ψ |]a and [| φ V чφ |]a = У is the greatest element of (La, ⊆). Therefore, (La, ⊆) has binary infima and the infimum of the empty set; thus, it is an inf-semi-lattice with one.
 
Proof. [of Proposition 3.4] Given (D, ≤, ч), the tuple (D, ≤, ч, D, ≤−1, ч) is such an AC lattice. Conversely, any such AC lattice determines a De Morgan lattice (La, ≤a, чa).	 
Proof. [of Lemma 4.1] Finite partial orders (La, ≤a) with finite infima have finite suprema; x V y is the infimum of the finite set {l ∈ La | x, y ≤al} and the supremum of the empty set is the infimum of all elements in La. 
Proof. [of Proposition 4.2]
Using U =  x/∈U ϵX (x) for each U ∈ U(X, ≤), extU (f )(U ) has to equal
{f (x) | x /∈ U }. We then can show that the functor U(·) is monotone.
The first three equations are immediate. Finally, \a◦L(f )◦\c is a sup-map so it suffices to show (\a ◦L(f )◦\c)◦ϵX = ϵY ◦f . But (\a ◦L(f )◦\c)◦ϵX =
\a ◦ (L(f ) ◦ ηX )= \a ◦ (ηY ◦ f )= ϵY ◦ f .
Since automorphisms are lifted by functors, f '→ L(f ): Aut(X, ≤) →


Aut(L(X, ≤)) is well defined; it is an injection as the functor is faithful over partial orders. Conversely, given g ∈ Aut(L(X, ≤)), the map g ◦ ηX: (X, ≤) → L(X, ≤) is monotone and so extL(g ◦ ηX) is well defined, but g equals extL(g ◦ ηX ) since g is alsoa sup-map ρ with ρ ◦ ηX = g ◦ ηX. The proof for U(·) follows from this and U(f )= \a ◦ L(f ) ◦ \c.
 
Proof. [of Theorem 4.3] By Stone duality — which in this simple setting amounts to Birkhoff’s Representation Theorem for finite distributive lattices — there exists an order-isomorphism φ: (La, ≤a) ∼= (L(X, ≤), ⊆) [1] for some fi- nite partial order (X, ≤) since (La, ≤a) is a finite distributive lattice. But then \c ◦ φ ◦ чc: (Lc, ≤c) → (U(X, ≤), ⊆) is an order-isomorphism as well. Thus, we may assume (La, ≤a) = (L(X, ≤), ⊆) and (Lc, ≤c) = (U(X, ≤), ⊆). Since чa: (L(X, ≤), ⊆) → (U(X, ≤), ⊇) is an order-isomorphism, it restricts to an order-isomorphism of the respective sets of complete primes. (An element p in a complete lattice L is a complete prime iff for all A ⊆ L, p = A implies p ∈ A.) The set of complete primes of (L(X, ≤), ⊆) is the image of ηX; the set of complete primes of (U(X, ≤), ⊇) is the image of ϵX . Thus, for every x ∈ X there is a unique i(x) ∈ X with чa(ηX(x)) = ϵX (i(x)). Since the map ϵX: (X, ≤) → (U(X, ≤), ⊇) is an order-isomorphism onto its image, i: (X, ≤) → (X, ≤) is monotone. Thus, чa ◦ ηX = ϵX ◦ i implies чa = extL(ϵX ◦ i).
Similarly, we infer the existence of a monotone map j: (X, ≤) → (X, ≤) with чc ◦ ϵX = ηX ◦ j, and so чc = extU (ηX ◦ j). Thus, it suffices to show j = i−1. But ϵX ◦ i = чa ◦ ηX = (чa ◦ \c) ◦ ϵX implies чa ◦ \c = U(i). Dually, ηX ◦ j = чc ◦ ϵX = (чc ◦ \a) ◦ ηX implies чc ◦ \a = L(j). Thus, L(i)= \c ◦ U(i) ◦ \a = \c ◦ (чa ◦ \c) ◦ \a = \c ◦ чa. From this we immediately get that L(i) is the inverse of L(j). Thus, j = i−1 as the functor L(·) is faithful over partial orders.	 
Proof. [of Theorem 4.5] Stone duality again ensures an order-isomorphism φ: (L, ≤) → (L(X, ≤), ⊆) for some finite partial order (X, ≤). But then the map

(.3)
neg d=ef φ ◦ч◦ φ−1

is monotone for the types (L(X, ≤), ⊆) → (L(X, ≤), ⊇) and (L(X, ≤), ⊇) → (L(X, ≤), ⊆). Since neg ◦ neg = idL(X,≤), neg is an order-isomorphism and, therefore, maps complete primes of (L(X, ≤), ⊆) — all elements of the form
↓x — to complete primes of (L(X, ≤), ⊇) — all elements of the form X \
↑x. Hence, neg(↓x) = X \ ↑i(x) for a unique i(x) in X. If x ≤ y, then neg(↓y) ⊆ neg(↓x) follows, from which we infer ↑i(x) ⊆ ↑i(y), i.e. i(y) ≤ i(x). Therefore, x '→ i(x): (X, ≤) → (X, ≤−1) is monotone. Similarly, neg maps


complete primes of (L(X, ≤), ⊇) to complete primes of (L(X, ≤), ⊆). Thus, neg(X \ ↑x) = ↓j(x) for a unique j(x) in X. Similarly, x '→ j(x): (X, ≤) → (X, ≤−1) is shown to be monotone. The equation ↓x = neg(neg(↓x)) renders j(i(x)) = x for all x ∈ X. Dually, equation X \ ↑x = neg(neg(X \ ↑x)) yields i(j(x)) = x for all x ∈ X, so i: (X, ≤) → (X, ≤−1) is an order isomorphism with j: (X, ≤−1) → (X, ≤) as inverse.
We claim that j = i. Since inverses are unique, it suffices to show that
i ◦ i = idX. We com pute ↓x = neg(neg(↓x)) = neg(X \ ↑i(x)) = neg( {↓y |
particular, x is an element of the latter intersection. Therefore we have

(.4)


def
6y ∈ X, i(x) /≤ y implies i(y) /≤ x.

For y = j(x), i(y) = i(j(x)) = x therefore implies i(y) ≤ x and so (.4)
renders i(x) ≤ y = j(x). Since i: (X, ≤) → (X, ≤−1) is monotone, this results in x = i(j(x)) ≤ i(i(x)). Conversely, suppose that it is not the case that i(i(x)) ≤ x. Then x ∈ X \ ↑i(i(x)), i.e. ↓x ⊆ X \ ↑i(i(x)) = neg(↓i(x)). But then ↓i(x) = neg(neg(↓i(x))) ⊆ neg(↓x)= X \ ↑i(x) implies i(x) ∈ X \ ↑i(x), a contradiction.
Finally, we show that neg is defined as in (25). Given L ∈ L(X, ≤), we have

(.5)
neg(L)= neg( 
x'∈L
def
↓x')= 
x'∈L
neg(↓x')= 
x'∈L
X \ ↑i(x') d=ef A.

We claim that A equals B = {i(x) | x ∈ X \ L}:
If y ∈ A, then x' ∈ L implies i(x') /≤ y, i.e. i(y) /≤ x' since i: (X, ≤) → (X, ≤−1) is an order-isomorphism with i as its inverse. Thus, i(y) ∈ X \ L since x' ∈ L was arbitrary. Therefore, y = i(i(y)) ∈ B.
If y ∈ B, then y = i(x) for some x ∈ X \ L. Given x' ∈ L, we have x /≤ x' since x ∈ X \ L and L ∈ L(X, ≤). Thus, i(x') /≤ i(x) = y shows y ∈ X \ ↑i(x'), i.e. y ∈ A.

Proof. [of Proposition 6.2]
Let Q<P .
P ∈ [| φ |]a means P |=aφ and so Q|=aφ follows from Q<P . Therefore,
Q ∈ [| φ |]a and [| φ |]a is a lower set.
Q ∈ [| φ |]c means Q|=cφ. Proof by contradiction: if P |/=cφ, then (5) and (6) render P |=aчφ. From Q<P we then infer Q|=aчφ which con- tradicts Q|=cφ since all total models are consistent. Thus, [| φ |]c is an upper set.
The right-hand side of (35) is always contained in the left-hand side by

item (i). Thus, we focus on the other containment only.
Let φ be consistent and P ∈ [| φ |]a.
If P is consistent, then there is some P ' with (P, P ') ∈ impl. From
P ∈ [| φ |]a we then infer P ' |= φ and so P ∈ [| φ |]a ∩ [| φ |]c.
If P is inconsistent, then P <Q for all partial models Q. Since φ is consistent, there is some T ∈ 7 with T |= φ and so T |=aφ by (10). Thus, T ∈ [| φ |]a ∩ [| φ |]c and P <T prove that P is contained in the right-hand side.
If φ is inconsistent, then [| φ |]a = {P ∈ У | P |=aφ} = {P ∈ У | P is inconsistent} and [| φ |]c = {P ∈ У | P |=cφ} = {} show that (35) cannot hold.
For inconsistent φ, if У is restricted to consistent models only, the left- hand side of (35) now computes to {}, so it satisfies the mix condi- tion (35). For consistent φ, we argue as in the previous item.

Proof. [of Lemma 7.2]
Given x ∈ {|X:φ|}a, there is some y ∈ X with x ≤ y and Py|=aφ. Since
Py is consistent, Py|=aφ implies Py|=cφ. Since y ≤ y we infer x ≤ y ∈
{|X:φ|}a ∩ {|X:φ|}c.
Let x /∈ {|X:φ|}c. So y ≤ x implies Py |=/ cφ, i.e. Py|=aчφ. In particular,
Px|=aчφ since x ≤ x. Proof by contradiction: if x ∈ {|X:φ|}a, there is some y with x ≤ y and Py|=aφ. Since ≤ is contained in < this implies Px|=aφ. Thus, Px|=aφ Λ чφ contradicts that Px is consistent: there is some P ' with (P, P ') ∈ impl and so P ' |= φ Λ чφ would follow for the consistent P '.

Proof. [of Proposition 7.4] Let [| φ |] ≤ [| ψ |] in (La, ⊆) × (Lc, ⊇). For x ∈
{|X:φ|}a there is some y ∈ X with x ≤ y and Py|=aφ. Since [| φ |]a ⊆ [| ψ |]a, we infer Py|=aψ which renders x ∈ {|X:ψ|}a. For x' ∈ {|X:ψ|}c there is some
'	'	'	c	c	c	c
y ∈ X with y ≤ x and Py' |= ψ. Since [| ψ |] ⊆ [| φ |] , we infer Py' |= φ which
renders x' ∈ {|X:φ|}c.

Proof. [of Proposition 7.5] Given x ∈ {|XP :φ|}a, there is some y ∈ X with x ≤ y and Py|=aφ. From Qy<Py we infer Qy|=aφ, and so x ∈ {|XQ:φ|}a. Given u ∈ {|XQ:φ|}c, there is some v ∈ X such that v ≤ u and Qv|=cφ. Together with Qv<Pv, Proposition 6.2(i) renders Pu|=cφ from which we obtain u ∈ {|XP :φ|}c.
 


Proof. [of Proposition 8.1]
For every φ ∈ L, x ∈ X \ {|X:φ|}c iff ↓x ⊆ {y ∈ X | Py |=/ cφ}. Since ≤ is
contained in <, this is equivalent to Px|=/ cφ which, by (9), is equivalent to
Px|=aчφ. But the latter is equivalent to x ∈ {|X:чφ|}a since ≤ is contained
in <. Similarly, x' ∈ X \ {|X:φ|}a iff ↑x' ⊆ {y ∈ X | Py |=/ aφ}. Since ≤
is contained in <, this inclusion holds iff Px |=/ aφ, which is equivalent to
Px|=cчφ by (9), i.e. x ∈ {|X:чφ|}c as ≤ is contained in <.
As for the sup-semi-lattice with zero, the partial order (Lc , ⊆) does have binary suprema and a zero since {|X:φ|}c ∪ {|X:ψ|}c = {|X:φ V ψ|}c and

{} = {|X:φ Λ чφ|}c. Thus, it suffices to show that чa
and чc
are order-

inverses. But this follows from the first item.

Proof. [of Lemma 9.4] We prove this by structural induction on φ. For ⊥, both sides equal {}. For p(u) and R(u, v) this follows from the fact that P ’s transition and labeling functions map into K(X,≤). For +R(u, v), let x ∈ [| +R(u, v) |]Pa . Then there is a path ρ(u) = s0, s1, .. ., sn = ρ(v) such that x ∈ Ra(si, si+1) for all such 0 ≤ i < n. But Ra(si, si+1) ⊆ Rc(si, si+1) then shows x ∈ [| +R(u, v) |]Pc through that same path. The cases чφ, φ V ψ, and Eu φ follow since their interpretations are monotone with respect to inclusion in both coordinates, so they map into K(X,≤); e.g. for the existential quantifier, if (Ls, Us) ∈ K(X,≤) for all s ∈ S, then  s∈S Ls ⊆ s∈S Us.	 
Proof. [of Proposition 9.7]
This is a routine argument (similar to the one in [18]) and omitted.
Given x ≤ y, we show Px<Py by showing the stronger statement

(.6)
“Py|=aφ implies Px|=aφ; and Px|=cφ implies Py|=cφ.”

ρ	ρ	ρ	ρ
for all φ and ρ by structural induction on φ.
For ⊥, (.6) holds trivially.
For p(u), this follows from the fact that the first component of L(p, ρ(u)) is a lower set and the second component is an upper set.
Similarly, for R(u, v) this follows from the fact that the first component of R(ρ(u), ρ(v)) is a lower set and the second component an upper set.
For +R(u, v),
let Py|=a+R(u, v). Then there are m ≥ 0 and a set {ti ∈ S | 0 ≤
i < m} with ρ(u) = t0 and ρ(v) = tm such that y is in the lower set (R+)a(ti, ti+1); but x ≤ y then implies x ∈	(R+)a(ti, ti+1), so
i	a	a i
there is an R -path in Px from t0 to tm, i.e. Px|=ρ+R(u, v);
dually, let Px|=c+R(u, v). Then there are k ≥ 0 and a set {si ∈
S | 0 ≤ i < k} with ρ(u) = s0 and ρ(v) = sk such that x is in the


upper set  i(R+)c(si, si+1); since x ≤ y, we have y ∈  i(R+)c(si, si+1) from which we infer that there is an Rc-path from s0 to sk in Py, i.e. Py|=c+R(u, v).
For чφ,
let Py|=aчφ. Then it is not the case that Py|=cφ. Using induction on
φ	ρ	c	ρ	a
, we also don’t have Px|=ρφ, from which we get Px|=ρчφ
let Px|=cчφ. If Py|=cчφ is not the case, then Py|=aччφ, i.e. Py|=aφ.
ρ	ρ	a	ρ  c	ρ
By induction, this yields Px|=ρφ — contradicting Px|=ρчφ by the def-
inition of |=m.
The proofs for φ V ψ are straightforward and omitted.
For Eu φ, this is easily shown by induction since (.6) quantifies over all environments, so it applies to all ρ[u '→ s] with s ∈ S.


Proof. [of Lemma 9.8]
We claim that Px|=cp(u) V чp(u). Let (L, U ) be L(p, ρ(u)). Assume that

ρ
P |=cp(u
x is not an element of U . Since L ⊆ U ,

x  ρ	) is not the case. Then
x /∈ L, too. But then we don’t have Px|=ap(u) from which we infer
ρ
P |=cчp(u).
x  ρ
This is clear.
Let (L, U ) be L(p, ρ(u)).
let x ∈ {|X:p(u)|}c. Then there is some y ≤ x with Py|=cp(u). Since
ρ	ρ
y ≤ x, Proposition 9.7(ii) ensures Px|=cp(u) which implies x ∈ U ;
c  ρ
conversely, let x ∈ U . Then Px|=ρp(u). Since x ≤ x, this renders
x ∈ {|X:p(u)|}c;
let x ∈ {|X:p(u)|}a. Then there is some x ≤ y with Py|=ap(u). Since
ρ	a	ρ
x ≤ y, Proposition 9.7(ii) ensures Px|=ρp(u) which implies x ∈ L;
conversely, let x ∈ L. Then Px|=ap(u). Since x ≤ x, this renders
x ∈ {|X:p(u)|}a.
For R(u, v), we reason in the same style as for p(u).
For чφ,
let x ∈ {|X:чφ|}c. Then there is some y ≤ x with Py|=cчφ. By Propo- sition 9.7(ii), this implies Pz|=cчφ for all z with x ≤ z as ≤ is tran- sitive. Thus, for any such z it not the case that Pz|=aφ. Therefore
x ∈ X \ {|X:φ|}a. Conversely, let x' ∈ X \ {|X:φ|}a. Then for all z' with
ρ	ρ
'	'	a	'	'
x ≤ z it is not the case that Pz' |= φ. In particular, for z = x this
c	'	'	'	c
implies Px' |= чφ. Since x ≤ x , this shows x ∈ {|X:чφ|}ρ;
the proof for the other mode is dual and omitted;

For φ V ψ,
let x ∈ {|X:φ V ψ|}a. Then there is some y with x ≤ y and Py|=aφ V
ρ	ρ
ψ. Without loss of generality (since |=a interprets V compositionally),

P |=aψ which secures x ∈ {|X:	a
ρ
:φ|}a ∪ {|X:ψ|}a;

y	ρ	ψ|}ρ ⊆ {|X	ρ	ρ
conversely, let x' ∈ {|X:φ|}a ∪ {|X:ψ|}a. Without loss of generality x' ∈
ρ	ρ
{|X:φ|}a so there is some z with x' ≤ z and Pz|=aφ which implies Pz|=aφV
ρ	ρ	ρ
ψ, from which we infer x' ∈ {|X:φ V ψ|}a; and
the proof for the other mode is dual and omitted.
For Eu φ,
let x ∈ {|X:Eu φ|}c; then there is some y ≤ x with Py|=cEu φ. Thus,

ρ
there exists some t' ∈ S such that Py|=c
ρ
φ.  Since y ≤ x, this

implies x ∈ {|X:φ|}c
t’]
which is contained in  t∈S {|X:φ|}c
t];

let x' ∈  t∈S {|X:φ|}c	t]. Then there exists some t'' ∈ S such that x' ∈

{|X:φ|}c	. Therefore, there is some y'
≤ x'
such that Py' |=ρ[u'→t”].

From the latter, we obtain Py' |=ρEu φ. Since y'
x' ∈ {|X:Eu φ|}c, and
the two cases for mode a are dual and omitted.
≤ x', this renders

 

Proof. [of Theorem 9.9] We prove this by structural induction over all φ
and ρ. For all cases but +R(u, v), this follows directly from Lemma 9.8. For
+R(u, v),
let x ∈ {|X:+R(u, v)|}a. Then there is some x ≤ y with Py|=a+R(u, v). So

ρ
there is a finite path ρ(u) = t0, t1,... , tm = ρ(v) with y ∈
ρ
i Ra(ti, ti+1).

Since the latter is a lower set, x ≤ y renders x ∈
x ∈ [| +R(u, v) |]Pa .
i Ra(ti, ti+1). Therefore,

let x ∈ [| +R(u, v) |]Pa . Then there is a finite path ρ(u)= s0, s1,... , sn = ρ(v)
ρ
a	a
this implies x ∈ {|X:+R(u, v)|}a; and
the cases for mode c are dual and omitted.
