Electronic Notes in Theoretical Computer Science 45 (2001)
URL: http://www.elsevier.nl/locate/entcs/volume45.html 26 pages


A Game Semantics of Idealized CSP

J. Laird
COGS, University of Sussex Brighton BN1 9QH, UK
E-mail: jiml@cogs.susx.ac.uk


Abstract
A games semantics is described for a typed functional language which includes primitives for parallel composition and for synchronous communication on private channels. The semantics is based on a category obtained by extending “Hyland- Ong games” with a representation of multiple threads of control using “concur- rency pointers” which express a new kind of causality relation between moves. The semantics is proved to be fully abstract for “channel-free” types with respect to a may-and-must equivalence for the finitary fragment, and with respect to may - equivalence for the whole language, using factorization results to reduce definability to the sequential case.

Introduction
Game semantics has been successfully used to give models of various sequen- tial programming languages, with the distinctive feature that many of the underlying notions are intensional, combining ideas from concurrency theory and from traditional domain theory. A hierarchy of fully abstract models has emerged, based on the Hyland-Ong (HO) model of PCF [12] extended with non-functional (but still sequential) features such as mutable state and store [1,4] and control [13,14], to the point where there is now a thorough analy- sis of sequential functional computation which is to a large extent based on concurrency. Extending existing games models to give an interpretation of concurrent features is therefore a natural development, although it requires a substantial change in perspective, as existing models are based on representa- tion of interaction as alternating sequences of tokens (moves).
One such construction — concurrent games [3] — has been used by Abram- sky and Mellies to model multiplicative-additive linear logic (in which concur- rency is implicit rather than otherwise). The concurrent games are based on a “true concurrency” representation of interaction as information flow, with no notion of moves as discrete pieces of information at all. This paper describes a different representation of concurrent behaviour — “multi-threaded games”
◯c 2001 Published by Elsevier Science B. V. Open access under CC BY-NC-ND license.


— which retains the token-based notion of interaction but adds a represen- tation of multiple threads of control, allowing the rich structure of HO games models of side-effects to be exploited to model explicit concurrency features such as communication on private channels.
Multi-threaded games are used to give a semantics of a typed call-by-name λ-calculus with arithmetic plus a parallel composition operator and (ground- type) message passing along channels with locally declared names. The syntax of this language is essentially the same as that of Brookes’ Idealized CSP [7] and so we have retained this name, although there are several differences in the operational semantics; message passing is synchronous (as opposed to asyncronous in [7]) and there is a key difference in the interpretation of the parallel composition operator; this could be summarized by saying that it is interpreted here as parallel composition of processes, and in [7] as parallel composition of commands.
Nonetheless, the semantic analysis provided by the games model can be regarded as complementary to the functor-category semantics described in [7]. Its distinguishing feature is that it is fully abstract with respect to may test- ing (for the full language), and with respect to may-and-must testing (for the recursion-free fragment). The full abstraction result is restricted to “channel- free” types, although it could be extended to all types by adding a “bad channel” constructor to the language, analogous to the “bad variable” con- structor mkvar which has been added to Idealized Algol for the same purpose [1].
The basic framework of Hyland-Ong games gives us an interpretation of the λ-calculus with arithmetic. The extension to model concurrency has two key features; multi-threading and synchronous message-passing.
The interpretation of multiple threads of control requires the most radical extension to previous work in game semantics, which (with the exception of [3]) has built models of sequential languages by representing interaction of strategies as a sequences of moves. We add a new set of “concurrency pointers” to these sequences, so that they can be seen as representing the interaction of two strategies as a tree of moves. Retaining the sequential ordering on moves, however, allows us to capture synchronizations between moves in different branches of a tree. And by following back control pointers we can extract a “control thread” (a branch of the tree) for each move. These are ordinary sequences from the associated HO game, allowing a subcategory of “sequential strategies” isomorphic to the original HO games and strategies to be defined. There is a natural operation of parallel composition of strategies in the multi- threaded setting, based on interleaving of control threads. Moreover, we show (by factorization) that all branching of control threads in finitary strategies can be obtained from such parallel compositions.
Message passing along private channels is interpreted in “object-oriented” style, as in the functor-category model [7], and the games models of locally bound references [1,4] and exceptions [14]. In fact the interpretation of the

chan type as the products of its “methods”, send and recv, is precisely the same as the interpretation of the type var and its methods (assignment and de- referencing) in the games model of Idealized Algol [1]. Thus the only difference between the semantics of the two features is in the interpretations of the new- variable and new-channel declarations. Both are given in terms of composition with a strategy which violates some of the constraints obeyed by elements corresponding to purely functional terms, and captures the causal relationships between writing and reading or sending and receiving. The key property of the “new-channel” strategy is that it contains a synchronous communication between control threads, and as we show by a factorization result, it can be used to generate all such behaviour in finitary strategies in the model.
The remainder of the paper splits basically into two parts; Sections 2 – 4 define a sound games model of ICSP, and Section 5 refines it into a fully abstract semantics. Accordingly, the first part accomplishes the new construc- tions required to interpret threads and communication in games, whilst the second contains more technical material relating it to the original HO models. The detail of the organization is as follows:
In section 2, a syntax, operational semantics and contextual equivalences are defined for ICSP.
Section 3 describes the category of “multi-threaded games” which is the basis for the model.
Section 4 gives the denotational semantics of ICSP in this category and shows that it is sound and adequate with respect to the operational semantics.
Section 5 refines the semantics, and derives full abstraction results for it. First, a new condition — “pointer-blindness” — is used to cut down the model. Then, a subcategory of sequential strategies is defined; the sequential strate- gies which also satisfy (multi-threaded versions of) the constraints of visibility, innocence and well-bracketing are shown to form a category isomorphic to that used to model PCF in [12]. Finally, we give two factorization results to show that every finitary strategy in the model is definable as a term of ICSP, from which full abstraction follows.

Idealized CSP
Idealized CSP [7], or ICSP, is based on the call-by-name λ-calculus, with types generated from the ground types comm (commands), nat (natural num- bers) and chan (channels for sending and receiving natural numbers). (We shall sometimes use B to represent the atomic or basic types comm and nat, and say that a type is channel-free if it is built from basic types with ⇒.) T ::= comm | nat | chan | T ⇒ T
Terms are formed according to the following grammar:
M ::= x | skip | 0 | succ M | pred M | IF0 M | λx.M | M M | YM
nil | M ; M | M  M | newchan M | send M M | recv M


The language combines the λ-calculus with concurrency primitives (based on CSP [10]) much as Idealized Algol [19] does with imperative features (an in- tellectual debt acknowledged in its name); declaring a new channel name and sending and receiving on it are analogous to declaring, allocating and deal- locating a variable. Typing judgements for the concurrency features are as follows:


Given M : nat,N : B, we shall also write M ; N for ((IF0 M ) N ) N .
The operational semantics is given in terms of a “small-step” reduction re- lation on configurations of ICSP. A configuration C = N1,..., Nk is a multiset of parallel threads — ICSP programs of the same (base) type — containing the free channel names Ch(C). (Equivalently, one could reduce a single pro- gram using structural congruences and scope extrusion.) The reduction rules use the notion of evaluation context to pick out a unique next redex for each thread which is not a value.
Definition 2.1 Evaluation contexts are given by the following grammar:
E[·] ::=[·] | E[·] M | pred E[·] | succ E[·] | IF0 E[·] |
E[·]; M | send M E[·] | send E[·] n | recv E[·] The small-step reduction rules are as follows:
E[λx.M N ],C −→ E[M [N/x]],C E[YM ],C −→ E[M YM ],C 
E[pred (succ M )],C −→ E[M ],C 
E[IF0 0],C −→ E[λxy.x],C 
E[IF0 (succ n)],C −→ E[λxy.y],C 
E[skip; M ],C −→ E[M ],C 
E[M  N ],C −→ E[M ], E[N ],C 
E[newchan M ],C −→ E[M c],C : c /∈ Ch(E[newchan M ], C) E[send a n], E'[recv a],C −→ E[skip], E[n], C.
The operation newchan allows local or private channels to be declared — newchan M supplies a new channel name as an argument to M : chan ⇒ B and adds it to the environment. Evaluation of send is by reducing its second argument to a value (numeral) and then its first argument to a channel name, recv evaluates its argument to a channel name, and send a n and recv a reduce in parallel to skip and n respectively. By contrast to [7], message passing is

synchronous. The process nil : B can be regarded as shorthand for either of the deadlocked processes newchan λc.send c 0 : comm or newchan λc.recv c : nat. Note that evaluating a parallel composition duplicates the evaluation context. This may seem surprising, but makes more sense if we recall that the evaluation context is in effect a representation of the current continuation. So parallel composition of (ground-type) processes means “split the control thread in two and (concurrently) run one argument with the current continuation in each thread”. Thus the parallel composition of two values (say skip and skip) reduces to a configuration consisting of two threads containing these values which cannot be further evaluated.
This is distinct from the interpretation of M  N in [7] which one might call “parallel composition of commands”; M and N are evaluated concurrently and the single value skip is returned if at least one evaluates to skip. So, for instance, the parallel composition of the commands skip and skip is equivalent to skip. Using parallel composition of processes with synchronous communication we can express parallel composition of commands M, N : comm as:
newchan λc.((M ; send c 0)  (N ; send c 0)  (recv c; nil)).
Various other programming constructs such as Algol-style store and non- deterministic choice can be expressed in ICSP. A useful example; for any n > 0 define the program oraclen which erratically produces one of the numbers less than n.
oraclen = newchan λc.((send c 0  send c 1  ... send c (pred n); nil  recv c)
For examples of solutions to more subtle programming problems involving concurrency see e.g. [7].

Convergence testing and operational equivalence
Observational equivalence is defined with respect to a simple test — having at least one convergent thread. This is equivalent to testing for exactly one convergent thread, or at least/exactly n threads for any finite n > 0. Since (as one would expect) nil  M will be denotationally equal to M , we cannot observe the existence of deadlocked threads so it will not be possible to test whether all threads converge.
Definition 2.2 Define the predicate ⇓may (may convergence) on configura- tions of type comm as follows:




C, skip ⇓may
∃C'.C → C' ∧ C' ⇓may


C ⇓may



Terms M, N : T are may-equivalent (M  may
N if for all program contexts

C[·]: comm, C[M ] ⇓may if and only if C[N ] ⇓may.

May-equivalence is a natural equivalence to model using game semantics — as we shall see, it corresponds to trace-equivalence of strategies. However, for an inherently non-deterministic language such as ICSPit is rather weak — it leads to a failure to distinguish programs which always converge from those which may converge or diverge [9,8]. A stronger notion of equivalence can be derived from may-and-must testing.
Definition 2.3 Define the predicate ⇓must (must convergence) on configura- tions:



C, skip ⇓must
∀C'.(C → C') =⇒ C' ⇓must


C ⇓must

Terms M, N : T are must-equivalent if for all closing contexts C[·] : comm,
C[M ] ⇓must if and only if C[N ] ⇓must. We shall write M  M&M N if M and
N are may-equivalent and must-equivalent.
Like games (and other) models of sequential languages, our semantics will reflect β equality as a denotational equivalence — e.g. we have [λx.x skip]] = [[skip ]. Unfortunately, in the presence of infinite reduction sequences (without fairness of evaluation), β-equality is not sound with respect to may-and-must testing. For example, λx.x skip / M&M skip since Yλy.y  λx.x skip /⇓must. This suggests that to give a denotational semantics of ICSP which is even adequate with respect to may and must testing (or a bisimulation equivalence), it will be necessary to incorporate the reduction behaviour of terms into the semantics. Here we shall just give the may-and-must result for the “finitary” fragment of ICSP for which evaluations always terminate; we shall call the language without the Y-combinator finitary ICSP .
Proposition 2.4 There is no infinite series of configurations of finitary ICSP
C1, C2,... Cn,... such that C1 −→ C2 −→ ... −→ Cn −→ .. ..
Proof. Is by a standard ‘computability predicate” based argument.    ✷

Multi-threaded Games
The games constructions which will be used to model ICSPare based on those given by Hyland and Ong [12] and Nickau [16] (and developed in [15,1,4,11]), in which states of the game — interactions between the system and the environ- ment — are represented as justified sequences of moves. However, in order to model concurrency we shall enrich this structure with an additional causality relation between moves, expressed using “concurrency pointers”. This allows a tree of multiple, interleaved “threads of control” to be represented as a sin- gle sequence. However, such a “multi-threaded sequence” carries additional information about the temporal ordering of events in different branches of the tree, and this extra information will be important in modelling syncronization. The structure of a game (the moves, their labels, how they are related) is specified by its arena. This is defined essentially as in [12]; no new structure is required to support multi-threading.	An arena A is a triple ⟨MA, ▶A⊆

(MA)∗ × MA, λA : MA → {Q, A}⟩, where:
MA is a set of tokens called moves,
▶A⊆ (MA)∗ × MA is a relation called enabling,
λA : MA → {Q, A} is a function which labels moves as answers (A) or questions (Q), such that every answer has a unique enabling move which is a question.
We stipulate that a unique polarity for all of the moves in MA can be inferred from the enabling relation using the rule:
m is an O-move if it is initial (i.e. ∗▶ m), or enabled by a P -move, m is a P -move if it is enabled by an O-move.
The simplest arenas are the empty arena 1, with no moves, and the flat arenas with a single, initial Opponent question q enabling a set of Player answers which are used to interpret basic types (here, as in [12] etc.); the interpretation of comm is the flat arena with a single answer (“execution of the command has successfully terminated”) and the interpretation of nat is the flat arena with a set of answers indexed by the natural numbers. The product and function-space constructors from [12] also carry through to the multi-threaded setting.
Product For any set-indexed family of arenas {Ai | i ∈ I}, form the product
A = Πi∈IAi a s follows:
MΠi∈IAi =	i∈I MAi ,
⟨m, i⟩ ▶Πi∈IAi ⟨n, j⟩ if i = j and m ▶Ai n, and ∗ ▶Πi∈IAi ⟨n, j⟩ if ∗ ▶Aj n,

QA
Πi∈IAi
(⟨m, i⟩)= λAi (m).

We shall write Ak for Πk  A.
Function Space For arenas A1, A2, form A1 ⇒ A2 as follows:
MA1⇒A2 = MA1 + MA2 ,
⟨m, i⟩ ▶A1⇒A2 ⟨n, j⟩ if i = j and m ▶ n
or m ∈ MA2 , n ∈ MA1 and ∗ ▶A2 m and ∗ ▶A1 n,
∗▶ ⟨m, i⟩ if m ∈ MA2 and ∗ ▶A2 m,

QA A1⇒A2
(⟨m, i⟩)= λAi (m).

In general l, m,n... will be used to denote the moves of an arena, and a, b, c,... to denote occurrences of these moves in sequences r, s, t. The empty sequence is denoted ε, and for any sequences s, t, s ± t means ‘s is a prefix of t’, sa denotes the sequence s extended by the move a, and st the sequence s extended by the sequence t.
In a sequence of moves sa, a justification pointer for s is a pointer from a to some move in s which enables a. A justified sequence over an arena A is a sequence of elements of MA in which each non-initial move a has a justification pointer. An alternating justified sequence t is one in which Opponent moves are always followed by Player moves, and vice-versa. We shall write JA for the set of alternating justified sequences over A.

Multi-threaded sequences

We shall now define the multi-threaded sequences on which our model is based. They are formed by adding “concurrency pointers” to justified sequences.
Definition 3.1 Let sa be a sequence of moves. A concurrency pointer for a is a pointer from a to some single (occurrence of a) move in s, which distinct from its justification pointer (if any). A move is thread-initial if it does not have a concurrency pointer. Let MTA be the set of multi-threaded sequences — justified sequences with concurrency pointers — over the arena A. A justified sequence without concurrency pointers (that is, the standard notion of justified sequence used in [12]) is said to be “single-threaded”.
By tracing back concurrency pointers, we can extract a series of single-threaded subsequences, or “control threads” from each multi-threaded sequence.
Definition 3.2 The control thread of the last move in a sequence s is defined by induction on length as follows:
CT(a)= a, if a is thread-initial,
CT(satb)= CT(sa)b if b has a concurrency pointer to a.
A multi-threaded legal sequence is a finite sequence with concurrency and jus- tification pointers, such that each thread is an alternating justified sequence:
every O-move which is not thread-initial has a concurrency pointer to a
P -move, and vice-versa,
every non-initial move has a justification pointer to a move in its control thread.
Definition 3.3 For an arena A, define the set of multi-threaded legal se- quences as follows: LMA = {s ∈ MTA | ∀t ± s.CT(t) ∈ JA}.
Definition 3.4 A legal sequence (multi-threaded or single-threaded) is well- opened if it contains at most one initial Opponent move. Let WMA be the set of well-opened (multi-threaded) legal sequences on A:
WMA = {s ∈ LMA | ta ± s∧▶ a =⇒ t = ε}
For example, the well-opened single-threaded sequences on the flat arena [nat]] are at most three moves long, and have the form ε, q or qai for some i ∈ ω. By contrast, for any finite sequence of natural numbers n1n2 ... nk there is a

unique sequence
, _ ¸ ¸
_	¸

 
q ,a¸n1
¸
an2
...  ank

in which each (Player) answer ai has a concurrency (and justification pointer) back to q. This sequence is a representation of a tree of control threads:
 , ¸ zq __ .¸ ,

an1
ı
an2
.	ank

— as we shall see, it is a trace in the strategy [n1  n2  ... nk]].

Representing concurrent interaction
The representation of trees as sequences with pointers can easily be seen to be non-unique; in the example above, any permutation of the answers an1 ,..., ann will give a trace in [n1  n2  ... nk ]. We can recover uniqueness by deeming that all such interleavings of control-threads are equivalent, but one might then ask: what is the point of representing multiple control threads in a sequential form in the first place? The answer is that the sequential ordering of moves is required in order to synchronize events between different threads. However, since Idealized CSP itself contains only limited facilities for such synchro- nizations, multi-threaded sequences still do not give unique representations of interactions between the corresponding strategies. Thus Player-strategies will have only limited power to observe and control the actual ordering of moves in different threads. Player can wait until a given O-move has occurred before giving a response (in ICSP it is possible to suspend evaluation of a thread until an event occurs in another thread). However, Player cannot:
force one P -move to occur before another (Player or Opponent) move, or
observe the order in which two contiguous O-moves occur.
To reflect these constraints, we define a preorder , such that s  t if s can be obtained from t by migrating P moves forward, and migrating O-moves back. We shall require that strategies be closed under  — in other words, if t is a trace of a strategy and s  t then s must also be a trace of the strategy.
Definition 3.5 Let  be the least preorder on multi-threaded legal sequences such that for all sab · t, sba · t ∈ LMA such that λOP (a)= O or λOP (b)= P, sab · t  sba · t.
The original representation of sequential, deterministic Player-strategies [12] is as sets of even-length sequences in which the final move represents the response of Player to the preceding sequence. As observed in [8] this form of representation is not sufficient to model a simple non-deterministic functional language up to may and must equivalence; for example, it identifies a strategy which always converges with one which may converge or diverge. In the multi- threaded setting, the absence of the alternation condition complicates matters further; it is no longer the case that the space of positions is partitioned between those in which it is Opponent’s turn to move, and those in which it is Player’s turn to move. So Player could play a string of moves without waiting for Opponent’s response, or might require several O-moves to prompt a single move in reply. A multi-threaded strategy σ on an arena A will be represented as the set of its traces at which it (possibly) halts, either waiting for ever, or for some more O-moves.
Definition 3.6 Given a set σ ⊆ LMA, let Tσ = {s ∈ LMA | ∃t ∈ σ.s ± t}.
When σ is a strategy, Tσ represents the set of reachable traces of σ.
Definition 3.7 A (multi-threaded) strategy σ : A is a subset of LMA subject

to the following conditions:
ε ∈ σ,
σ is closed with respect to  — s  t and t ∈ σ implies s ∈ σ,
the extension of a reachable position with an O-move is reachable — if
s ∈ Tσ and a is an O-move such that sa ∈ LMA then sa ∈ Tσ,
in any reachable position, σ must either play a P -move or wait for another O-move — if s ∈ Tσ then either s ∈ σ or there is some P -move a such that sa ∈ Tσ.
A single-threaded strategy on A is a subset of LA satisfying these conditions (closure under  is clearly trivial).
To give a fully abstract semantics for may-testing for the full language we shall consider strategies only up to equivalence of reachable traces.
Definition 3.8 σ : A is trace-equivalent to τ : A (σ ≈A τ) if Tσ = Tτ .
We shall now define a category of arenas and strategies. First, extend the notion of restriction to multi-threaded sequences so that it “mends” both justification and concurrency pointers.
Definition 3.9 Given s ∈ L(A1⇒A2)⇒A3 , sT(Ai, Aj) (i < j) is a multi-threaded sequence on Ai ⇒ Aj defined as follows:
εT(Ai, Aj)= ε
saT(Ai, Aj)= sT(Ai, Aj) if a /∈ MAi, MAj saT(Ai, Aj)= (sT(Ai, Aj))a if a ∈ MAi, MAj .
The justifier of a in saT(Ai, Aj) is the most recently played move from Ai or
Aj which hereditarily justifies a. (If there is no such move, then a is initial.) The concurrency pointer from a points to the most recently played move (if any) from Ai or Aj which is in CT(sa).
Lemma 3.10 If s ∈ LM(A1⇒A2)⇒A3 then CT(sT(Ai, Aj)) = CT(s)T(Ai, Aj). As in other models, canonical morphisms are copycat strategies which simply copy Opponent moves between different parts of a game. (However, there is a
difference between the treatment of concurrency and justification pointers; the copy of an O-move a has a concurrency pointer to a itself, and a justification pointer to the move of which the justifier of a was a copy.) The identity strategy is the prime example.
Definition 3.11 Say that s ∈ LMA⇒A is a copycat sequence if for all t ±even s, t T A− = t T A+, and every P -move in s has a concurrency pointer to the preceding O-move. Then idA = {s ∈ LMA⇒A | ∃t.s  t ∧ t is a copycat}.
The ‘parallel composition with hiding’ [5] of strategies is defined as follows.
Definition 3.12 Given σ : A1 → A2 and τ : A2 → A3, let σ; τ = {t ∈
LMA1⇒A3 | ∃s ∈ LM(A1⇒A2)⇒A3 .t = (sTA1, A3) ∧ (sTA1, A2) ∈ σ ∧ (sTA2, A3) ∈
τ }

Lemma 3.13 If σ : A ⇒ B and τ : B ⇒ C, then σ; τ : A ⇒ C.
Proof. The key points are that if s ∈ LM(A1⇒A2)⇒A3 , then s T Ai, Aj is a legal sequence, and closure under . The former follows from the single- threaded case [12], using Lemma 3.10. The latter is proved by showing that, given s ∈ LM(A1⇒A2)⇒A3 and t ∈ LMA1⇒A3 , such that sTA1, A3  t, we can find r ∈ LM(A1⇒A2)⇒A3 such that r T A1, A3 = t, s T A1, A2  r T A1, A2 and sTA2, A3  rTA2, A3. We derive r from s by migrating P -moves in A3 forward, and O-moves in A1 back, and swapping contiguous O-moves and contiguous P -moves.
The proof that composition is associative follows the standard argument from [12], which is little altered by the presence of concurrency pointers and absence of the alternation condition.
Proposition 3.14 For all σ : A ⇒ B, τ : B ⇒ C, ρ : C ⇒ D σ; (τ ; ρ) = (σ; τ ); ρ.
Definition 3.15 To construct a cartesian closed category, however, we need the notion of well-opened strategy. A well-opened strategy σ : A is a subset of WMA (Definition 3.4) satisfying the conditions laid down in Definition 3.7 with respect to well-opened sequences rather than legal sequences.
Composition of well-opened strategies σ : A ⇒ B with τ : B ⇒ C is by “pro- motion” of σ, followed by parallel composition with hiding, where promotion is defined as follows.
Definition 3.16 For a (multi-threaded legal) sequence s containing an initial move a, define sTa to be the the (multi-threaded legal) subsequence of s hered- itarily justified by a:
saTa = a,
sbTa = (sTa)b if a hereditarily justifies b (b has a concurrency pointer to a move in sTb by visibility),
sbTa = sTa otherwise.
For well-opened σ : A, define σ† : A as follows:
s ∈ σ† if and only if for all initial moves a in s, sTa ∈ σ.
We can now define categories GS and GM with arenas as objects, and multi- threaded and single-threaded strategies on A ⇒ B as morphisms from A to B, respectively. Composition is defined σ · τ = σ†; τ . (The well-opened identity strategy on A, IdA, is the restriction of idA to well-opened sequences.)
Proposition 3.17 GM† is a category.

Proof. We use the following facts: for any A, Id†
= idA, and for any well-

opened σ, σ†; IdB = σ.
For well-opened strategies σ : A ⇒ B, τ : B ⇒ C, σ†; τ † = (σ†; τ )†.
Moreover, the CCC structure on single-threaded games [15,4] transfers smoothly to GM; the operation × is a cartesian product with copycat strategies πi :



A1 × A2 → Ai for i = 1, 2:
πi = {s ∈ WA−×A−⇒A+ | ∀t ±

even s.tTA− = tTA+}.

1	2	i
Definition 3.18 For well-opened strategies σ : A → B, τ : A → C, define:
⟨σ, τ ⟩ : A → B × C = {s ∈ LMA⇒B×C | (sTA, B ∈ σ ∧ sTC = ε) ∨ (sTA, C ∈
τ ∧ sTB = ε)}.
The exponential is the function-space arena ⇒ — there are obvious copycat strategies:
App : A × (A ⇒ B) → B and Λ : (A × B) ⇒ C → A ⇒ (B ⇒ C).
Proposition 3.19 GM, 1, ×, ⇒ is a cartesian closed category.
To model recursion, we quotient GM by trace-equivalence (which must be preserved by composition, since each equivalence class contains the strategy which halts on all traces in that class). The result is a cpo-enriched category which is the basis for the may-testing model of ICSP.
Proposition 3.20 Let GM/≈ be the category in which morphisms are ≈- equivalence classes of strategies from GM (with the obvious definition of com- position: [σ] · [τ ]= [σ · τ ]). Then GM/≈ is a cartesian closed category which is cpo-enriched with the ordering [σ] ≤ [τ ] if Tσ ⊆ Tτ .


Semantics of ICSP
As in [1] the interpretation of sequential composition is by defining [Γ ▶ M ; N ]] = ⟨[[Γ ▶ M ]], Γ ▶ N ]]⟩; seq, where seq : comm × comm → comm is a strategy which interrogates each of its arguments once, in turn, before making a response. So a typical control thread of play in seq is as follows.

[[comm]] × [[comm]] ⇒ [[comm]]
q
q a
q
a
a
However, in the multi-threaded setting, we need to be able to define seq as a strategy which behaves in the same way in each control thread. More generally we wish to give an embedding of the original model of PCF in the category of single-threaded strategies into GM.
Definition 4.1 Given single-threaded σ : A, define the multi-threaded strategy multithread(σ): A = {s ∈ LMA| ∀r ± s.CT(r) ∈ Tσ ∧ ∀t.((t  s ∨ s  t) =⇒ CT(t) ∈ σ)}.
Lemma 4.2 The operation multithread is a functor from GS to GM which preserves cartesian closed structure.

Proof. The proof that multithread(σ); multithread(τ ) = multithread(σ; τ ) is based on Lemma 3.10.	✷
Thus we can define the interpretation of sequential composition and the con- ditional as the image under multithread of their single-threaded counterparts. Parallel composition of strategies is by interleaving their responses to the initial move (preserving the concurrency pointers). Say that an arena is well-
opened if it has an unique initial move.
Definition 4.3 Let s = ab1 ... bm and t = ac1 ... cn be sequences in LMA, where A is a well-opened arena. A tail-interleaving of s and t is a sequence ar ∈ LMA such that r is an interleaving of b1 ... bm with c1 ... cn which pre- serves justification and concurrency pointers — e.g. if bj points to a in s then bj points to a in ar, or if bj points to bi in s then bj points to bi in r. We shall write s|t for the set of tail-interleavings of s and t.
Proposition 4.4 For any well-opened arena A and (pointer-blind) strategies
σ, τ : A the parallel composition of σ and τ — σ|τ =	{s|t | s ∈ σ ∧ t ∈ τ }
— is a well-defined (pointer-blind) strategy.
So, for instance, we have a general parallel composition morphism for arenas
with unique initial moves, paraA : A × A → A = πl |πr . A typical play (with
A	A
concurrency pointers) of para[[comm]] is as follows:
[[comm]] × [[comm]] ⇒ [[comm]]

 q	,
ı
,			_	¸
c 
 ¸¸ zq 


,
a ¸¸¸
_q 
a ,¸ ¸
¸

  , a

¸	¸	¸	_	a
We define [Γ ▶ M  N : B]] = [[Γ ▶ M ]]|[[Γ ▶ N ]. We have the property that
(σ|τ ) × ρ; seq = (σ × ρ; seq)|(τ × ρ; seq) — in other words for all M, N : comm, [[(M  N ); L]] = [[(M ; L)  (N ; L)]].
So it remains to give the semantics of locally bound channels. This is based on viewing elements of type chan as ‘objects’ defined by their ‘methods’ — in this case send and recv. This was suggested as an interpretation for reference types by Reynolds [18] and used to give a a functor-category semantics for idealized CSPby Brookes [7]. The interpretation described here is particularly close to the game semantics of store in Idealized Algol [1].
We define [chan]] = [[comm]]ω ×[[nat ] (which is the same as the interpretation of the type var given in [1]).
For sending messages there is a sequential and innocent strategy write : [[nat]] × [[comm]]ω → [[comm ] described in [1] which responds to the initial move by asking the question in [nat ], given the answer n it asks the initial question in the nth part of the product [comm]]ω. When this is answered, it answers the initial question.

We define [Γ ▶ send M N ]] = ⟨[[Γ ▶ M ]]; πl, [[Γ ▶ N ]]⟩; write, which is pre- cisely the same as the interpretation of assignment in [1].
We define [Γ ▶ recv M ]] = [[Γ ▶ M ]]; πr (the interpretation of deallocation in [1]).
Thus the only part of the semantics of channels which is non-functional — and moreover the only part which differs from the game semantics of store in Idealized Algol — is the interpretation of new channel generation. This is defined by composition with a (pointer-blind) strategy ccell : [[nat]] × [[comm]]ω which is similar to the cell strategy used to interpret new in the model of Ideal- ized Algol [1] in the way that it causes interaction between the two read/write or send/receive components of [chan ] but the significant difference is that communication between sending and receiving is concurrent and synchronous rather than sequential. A typical play of ccell (with concurrency pointers) is given below (the questions in the ith “send component” [comm]]ω have been labelled send(i), and their answers as sent(i), the question in the “receive” component [nat ] has been labelled recv, and its ith answer rcvd(i)).
[[comm]]ω ×  [[nat]]
 ,
send(i)
s
ı send(j)

 ¸,
,	sent
,
,
sent
recv, ¸
rcvd(j) recv, ¸
rcvd(i)

Informally, the behaviour of ccell can be described in the following terms. It must respond to any play in which there is both a unanswered send(i) question and an unanswered recv question by matching up such pairs of questions by giving the answer rcvd(i) to the recv question, and the answer sent to send(i). Because answers can be exchanged between any pair of open send and recv moves, ccell is implicitly non-deterministic. In order to satisfy the alternation condition, the send and recv moves must always be in different threads — as one would expect, as synchronous message passing requires the sender and recipient to be in different threads. Formally, ccell can be defined as follows.
Let the balanced sequences of ccell, Bccell ⊆ ccell, be the least set of sequences in LMchan]] containing ε and closed under  and the following rule:
if s ∈ Bccell, then s · send(i) · recv · sent · rcvd(i) ∈ Bccell (where sent has concurrency and justification pointers to send(i), and rcvd(i) to recv).
Let the “waiting to send” sequences of ccell, Sccell, be the least superset of
Bccell such that if s ∈ Sccell, then s · send(i) ∈ Sccell.
Let the set of “waiting to receive” sequences, Rccell, be the least superset of
Bccell such that if s ∈ Rccell, then s · recv ∈ Rccell.

Now let ccell = {s ∈ LM[[chan]] | ∃t.s  t ∧ (t ∈ Sccell ∨ t ∈ Rccell)} and define: [[Γ ▶ newchan M : B]] = ([[Γ ▶ M : chan ⇒ B]] × ccell); App.
Soundness of the semantics
We shall say that a strategy on [comm]] is may convergent if it can answer the initial question at least once, and must convergent if it always gives some response (i.e. does not wait) in response to Opponent’s initial move.
Definition 4.5 For a strategy σ : [[comm]], define σ ↓may if qa ∈ Tσ and σ ↓must
if q /∈ σ.
Soundness of the interpretation — i.e. correspondence between the notions of may and must convergence in the operational and denotational semantics
— can now be established. First, commutativity and associativity of parallel composition, and commutativity of new-channel declaration means that the denotation of a configuration can be defined without ambiguity.
Definition 4.6 For a configuration C = M1 : comm,..., Mn : comm such that
Ch(C)= c1,..., ck, define [[C]] = [[newchan λc1.... newchan λck.M1  ... Mn]].
Say that a configuration is converged if it has the form C, skip, and deadlocked if it is not converged and cannot be further reduced. So if C is converged, then [[C]] ↓may and [C]] ↓must and if C is deadlocked then [C]] /↓may and [C]] /↓must. Soundness of the semantics with respect to may-testing thus boils down to the following fact.
Proposition 4.7 If C −→ C then T[[C']] ⊆ T[[C]].
Proof. The proof is based on the standard properties of a cpo-enriched carte- sian closed category together with the following lemma.
Lemma 4.8 [[E[M  N ]= [[E[M ]  E[N ]]]
[[(newchan λc.M )  N ]] = [[newchan λc.(M  N )]] (c ∈/ FV (N )
[[(newchanλc.M ); N ]] = [[newchan λc.(M ; N )]], (c ∈/ FV (N ))
[[newchan λc.E[send c v]  E'[recv c]  M ]] ⊆ [[newchan λc.E[skip]  E'[v]  M ]].
Soundness of the finitary fragement with respect to must-testing is expressed by the following proposition.
Proposition 4.9 For any non-converged and non-deadlocked configuration C
of finitary ICSP, [[C]] ↓must if [[C']] ↓must for all C' such that C −→ C'.
The proof is based on the equalities/inclusions given in Lemma 4.8 together with the following lemma, (established by analysis of the strategy ccell).
Lemma 4.10 For terms M1, M2,... Mn, define i≤nMi = M1  M2  ... Mn. Suppose we have terms Mi = Ei[send ai vi] : j ≤ mi and Ni = Di [recv ai] : 
j	j	j	k	k
k ≤ li, for i ≤ n, where each Ei[·] and Di [·] is an evaluation context. Then
j	k
 i≤n((  j≤m Mi)  (  k≤l Ni )) =
i	j	i	k


 i≤n((  j≤m M (I, J ))i )  (  k≤l N (I, J, K)i ))
I≤n,J≤mI ,K≤lJ	i	j	i	k
where M (I, J )i = Ei[skip], if i = I and j = J
j	j
M (I, J )i = Mi otherwise,
j	j
and N (I, J, K)i = Ei [vI ] if i = I and k = K,
k	k  J
N (I, J, K)i = Ni, otherwise.
We can now prove Proposition 4.9 by induction on reduction-sequence length. Given C such that if C −→ C' then [C]] ↓must, suppose that there is some reduction C −→ C' which is not an instance of the communication rule. Then by Lemma 4.8, [C]] = [[C']] and [[C]] ↓must by hypothesis. On the other hand, if there is no reduction which is not an instance of communication, then all
threads have the form E[send c n] or E[send c n] and hence by Lemma 4.10,
q /∈ [[C]] =  '	' [[C' ] as required.
C :C−→C

Proposition 4.11 If M : comm is a program of ICSP then M ⇓may if and only if [[M ]] ↓may and if M is a program of finitary ICSP then M ⇓must if and only if [[M ]] ↓must.

Proof. M ⇓may implies [M ]] ↓may and M ⇓must implies [M ]] ↓must by induc- tion on reduction. For terms of finitary ICSP, the converse follows from the fact that evaluation always terminates (Proposition 2.4). To show that [M ]] ⇓may, then M ⇓may for terms containing the Y combinator, we use the fact that [[C[YM ]] ⇓may if and only if there is some finite k such that [C[Mk]]] ⇓may to reduce to the result for finitary ICSP. (Where Mk is the kth approximant to YM , i.e. M 0 = Ω, Mk+1 = M (Mk.)	✷



Definability and Full Abstraction

Our model of ICSP is not fully abstract for may or must equivalence. This is because the presence of control pointers allows distinctions to be made between strategies which do not correspond to distinctions in the language. In this section, we will show how the model can be cut down by eliminating these distinctions, and hence achieve a fully abstract result by proving that every compact strategy is definable.
The constraint which we require says that Player cannot (directly) observe the concurrency pointers from O-moves. This corresponds to the fact that in ICSP it is not directly observable in which location (i.e. which thread) computation is occurring. For example, λx.x : nat ⇒ nat is observationally equivalent to newchan λc.λx.((send c x; nil)  recv c), even though they are in- terpreted as distinct strategies (and hence there is a strategy on [(nat ⇒ nat) ⇒ comm ] which can distinguish them).



[[nat]] ⇒ [[nat]]
% ¸O,
[[nat]] ⇒ [[nat]]
% ¸O,,, ¸

 P¸¸	$
O ,¸¸
¸  &  P
P ¸ ¸¸ $
O	e
P

[[λx.x]]	[[newchan λc.λx.((send c x; nil)  recv c)]].
Definition 5.1 Let ∼O to be the least equivalence relation on multi-threaded
legal sequences closed under the condition:
sa1t1a2t2br ∼O sa1t1a2t2br, if b is an O-move with a concurrency pointer to a1 in the first sequence, and to a2 in the second sequence, and the sequences are otherwise identical.
A strategy σ is (concurrency) pointer-blind if it is closed with respect to ∼O
— i.e. s ∈ σ and s ∼O t implies t ∈ σ.
It is straightforward to show that the pointer-blind strategies form a subcate- gory of GM which contains the denotations of all of the terms of ICSP. Pointer- blindness induces the following “intrinsic equivalences” between strategies which are indistinguishable by a pointer-blind observer.
Definition 5.2 Define the equivalences ≡may, ≡M&M on strategies σ, τ : A: σ ≡may τ if for all ρ : A → [[comm]], σ; ρ ↓may if and only if τ ; ρ ↓may. σ ≡M&M τ if if for all ρ : A → [[comm]], σ; ρ ↓must if and only if τ ; ρ ↓must.
We shall show that every compact pointer-blind strategies on a (channel-free) type-object is definable, up to equivalence, as a term of ICSP, from which it folows by a standard argument that two terms are may (or may-and-must) equivalent if and only if their denotations are may (may-and-must) equivalent. First, however, note that we can characterize ≡may and ≡M&M directly in terms ofa relationship on traces which is a complement of ∼O.
Definition 5.3 Let ∼P be the least equivalence relation on multi-threaded se- quences such that sa1t1a2t2br ∼P sa1t1a2t2br if b is a Player move with a concurrency pointer to a1 in the first sequence and to a2 in the second, and the sequences are otherwise identical.
Define the equivalence ∼ on sets of sequences: σ ∼ τ if ∀s ∈ σ.∃t ∈ τ.s ∼ t
and ∀t ∈ τ.∃s ∈ σ.s ∼ τ.
Proposition 5.4 σ ≡may τ if Tσ ∼ Tτ and σ ≡M&M τ if σ ∼ τ.
Proof. Suppose that Tσ /∼ Tτ , then w.l.o.g. there exists s ∈ Tσ such that for all t ∈ Tτ , t /∼P s. Assume that s is maximal (with this property) with respect to  . Let ρ : A → [[comm ] be the strategy generated by the prefixes of qsa ∈ A ⇒ [[comm ] (where q is the initial question in [comm]] and a is its answer) — i.e. ρ is generated by {t ∈ LM[[T ⇒comm]] | ∃r ± qsa.t  r}. Then qa ∈ Tσ;ρ and qa /∈ Tτ;ρ, since if qs'a qsa, then s s' and hence s' /∈ τ by maximality of s with respect to  . Hence σ /≡may τ as required.
Suppose σ /∼ τ , then either Tσ /∼ Tτ and hence σ /≡M&M τ by the argument

above, or else Tσ ∼ Tτ . Then (w.l.o.g.) we can find a trace on which σ diverges, but τ always makes another move — i.e. there exists s ∈ σ such that s /∈ τ . Let R ⊆ WM[[T ]] be the set of minimal length sequences r such that r ∈ τ and s ± r. Then let ρ be the strategy which converges when it encounters any trace from R which is distinct from s, and diverges otherwise — i.e. ρ is generated by the set of sequences {t ∈ LMA⇒[[comm]] | t  qs ∨ ∃r ∈ R.∃u ±
r.u /= s ∧ rt  qua}. Then q ∈ σ, but q /∈ τ , so σ /≡M&M τ as required.
To show that ≡may and ≡M&M correspond to may and M&M it suffices to show that all finitary pointer-blind strategies are definable (up to ∼P ) as ICSP terms. What is a finitary strategy ? All strategies on type-objects contain infinitely many sequences, so finiteness is defined in terms of the smallest set required to generate these sequences.
Definition 5.5 A generator for a strategy σ is a set of sequences S ⊆ σ such that for all t ∈ σ there exists sr  t such that s ∈ S and r contains only O-moves. We say that σ is finitary if it has a finite generator S, and that it is bounded by k if the length of all sequences in S is less than k.
Finitary strategies suffice to distinguish between denotations of ICSP terms. With respect to may-equivalence, this follows from the observation that the distinguishing strategy ρ defined in the first part of the proof of Proposition 5.4 has a finitary generator. With respect to must-equivalence, finitary strategies suffice to distinguish finite-branching strategies.
Definition 5.6 A strategy σ is finite-branching if for each s ∈ Tσ, the set of minimal length t such that t ∈ σ and s ± t is finite.
It is straightforward to show that all terms of finitary ICSP have finite- branching denotations. Clearly, if σ and τ are finite-branching then the dis- tinguishing strategy ρ defined in the first part of the proof of Proposition 5.4 has a finitary generator.
Lemma 5.7 For any strategies σ, τ : A, σ ≡may τ if and only if for all finitary ρ : A → [[comm]], σ; ρ ↓may if and only if τ ; ρ ↓may. And if σ and τ are finite- branching σ ≡M&M τ if if for all finitary ρ : A → [[comm]], σ; ρ ↓must if and only if τ ; ρ ↓must.
The first part of the proof of definability of finitary pointer-blind strate- gies is a characterisation of the elements which are definable without parallel composition and message passing — in effect, the image of the original HO model of PCF under the embedding multithread. This requires the notion of sequentiality for multi-threaded strategies — a sequential strategy is one which never spawns new threads of control.
Definition 5.8 A multi-threaded sequence s is Player sequential if every O- move in s is the target of at most one concurrency pointer: i.e. if tarc, tar'c' ± s where c, c' are P -moves with concurrency pointers to a, then rc = r'c'.
A strategy σ is sequential if every s ∈ σ is Player sequential.

The visibility and innocence conditions on strategies from [12] can be gen- eralised to the multi-threaded sequential strategies by applying the view - function [12] to each control thread (which is consistent with the intuition that the view represents a certain kind of “relevant history of the sequence” from Player’s perspective).
Definition 5.9 The Player view s’ of a justified sequence s is a sequence with justification pointers, defined inductively on the length of s, as follows:
 ε’ = ε,
 sa’ =  s’a,	if a is a Player move,
 sa’ = a,	if a is an initial Opponent move,
 sa · tb’ = s’ab, if b is an Opponent move justified by a.
Definition 5.10 A strategy σ obeys the visibility condition if for every s ∈
Tσ,  CT(s)’ is a well-formed justified sequence.
A (sequential) strategy is innocent if its response in each control-thread de- pends only on the P-view of that thread. For a multi-threaded strategy σ, let
 σ’ = { CT(s)’ | s ∈ σ}. (If σ is single-threaded, σ’ = { s’ | s ∈ σ}.)
Definition 5.11 A sequential strategy σ is innocent (and deterministic) if it satisfies the visibility condition and σ’ is evenly branching: i.e. if s, t ∈ σ’ and s H t is odd-length then s = t.
Note that although it is not the case in general that multithread(σ) is a pointer- blind strategy, that this does hold if σ is innocent; if an O-move is in the P −view, then the preceding move in the view is its justifier, which must be no later than the target of its concurrency pointer.
Definition 5.12 From a multi-threaded innocent strategy σ, define the single- threaded innocent strategy threads(σ)= {CT(s) | s ∈ σ}.
The following lemma follows from Lemma 3.10.
Lemma 5.13 For single-threaded σ : A → B, τ : B → C, threads(σ); threads(τ )
= threads(σ; τ ).
Lemma 5.14 For any sequential and innocent σ, multithread(threads(σ)) =
σ, and for all single-threaded and innocent τ, threads(multithread(τ )) = τ.
Hence threads is an isomorphism between the multi-threaded, innocent and sequential strategies, and the innocent and single-threaded strategies.
Proposition 5.15 The sequential and innocent strategies form a subcategory of GM which is isomorphic to the category of single-threaded games and in- nocent strategies.
The definability result for ICSP- {, newchan} requires one further constraint
— the bracketing condition on strategies, which requires that each Player- answer must be justified by the most recent open question. (This is the only point at which the question/answer distinction is used — it is not required to define the fully abstract model, only in the proof of definability via the

Hyland-Ong model.)
Definition 5.16 Define the pending questions (a set containing at most one move) of a justified sequence as follows:
pending(ε)= {},
pending(sb)= {b}, if λ(b)= Q,
pending(sbtc)= pending(s) if λ(c)= A and c is justified by b.
A (single-threaded) sequence s is well-bracketed if for all ratb ± s, if λ(b)= A and b is justified by a, then pending(sat)= {a}. A strategy σ is well-bracketed if for every s ∈ Tσ, s’ is well-bracketed.
The isomorphism between innocent, sequential strategies, and innocent, single- threaded strategies extends to the well-bracketed strategies. This gives a proof of the following definability result for innocent, sequential strategies, which is a minor adaptation of the definability theorem for PCF [12], and precisely analogous to definability in Idealized Algol without bad variables [1].
Proposition 5.17 If Γ is a chan-free context and T is a chan-free type, and σ : [[Γ, chank]] → [[T ]] is a sequential and innocent strategy such that σ’ is finite, then there is a term Γ, chank ▶ Mσ : T of ICSP - {, newchan} such that σ = [[Mσ]].
The astute reader will have observed that in fact all denotations of terms of ICSPobey both the visibility and well-bracketing conditions. However, it is not necessary to impose these conditions to get a fully abstract model; as we shall show, every pointer-blind strategy is equivalent (with respect to ∼) to one which obeys both conditions. In other words, we can simulate sequential side-effects such as first-class continuations and reference cells using concurrent ones (these results correspond to syntactic encodings of these features using threads and messages).
Proposition 5.18 For every pointer-blind strategy σ : A, there exists a well- bracketed (pointer-blind) strategy σ^ such that σ ∼ σ^.
To prove this proposition, we use a result proved in [13] — all violations of the bracketing condition can be expressed in terms of the single-threaded strategy Peirce by factorization — together with the fact that there is a well-bracketed multi-threaded strategy P^eirce such that Peirce ∼ P^eirce.
Lemma 5.19 There is a strategy Peirce : [((nat ⇒ nat) ⇒ nat) ⇒ nat]] such that for all finitary strategies σ : A there is a well-bracketed strategy σ˜ : ((([[nat ⇒ nat) ⇒ nat) ⇒ nat]] → A such that Peirce; σ˜ = σ.
Proof. Peirce is formally defined in [13]; a key “typical play” is shown below. The extension of the factorization proof from single-threaded strategies to multi-threaded strategies is straightforward.	✷
Lemma 5.20 There is a well-bracketed (non-sequential) strategy P^eirce =
[[newchan λc.λf.(f λx.(send c x); nil)  recvx]] such that P^eirce ∼ Peirce.

This is proved by comparing the plays of Peirce and P^eirce, for example:

(([[nat]] ⇒ [[nat]]) ⇒ [[nat]]) ⇒ [[nat]]	(([[nat]] ⇒ [[nat]]) ⇒ [[nat]]) ⇒ [[nat]]

, ¸ z˛
O ,
, ¸ z˛
O ¸,

  ,  ¸ O˛
 P¸
P  ¸ , +
  ,  ¸ O˛
 P¸
P ¸ , +s ı
 
,

O ¸¸ ¸¸ ¸ ¸ ¸
O
¸ ¸ ¸  _  ,  &  P
Peirce
,
P
P^eirce.

To prove Proposition 5.18 let σ^ = P^eirce; σ˜ ∼ Peirce; σ = σ.
Similar results apply with respect to the visibility condition.
Proposition 5.21 There is a sequential strategy ucell : [[((comm ⇒ comm) ⇒
(comm ⇒ comm)) ⇒ comm]] such that for all finitary strategies σ : A there is
a strategy σ˜ : [((comm ⇒ comm) ⇒ (comm ⇒ comm)) ⇒ comm]] ⇒ A which
satisfies the visibility condition, such that ucell; σ˜ = σ.
In essence, ucell is a curried version of the cell strategy which is used to factor- ize the visibility condition in [4] (except that it can store only one reference). A typical control thread of play runs as follows (solid arrows represent justi- fication pointers).
[[((comm ⇒ comm) ⇒ (comm ⇒ comm)) ⇒ comm]]
zO˛
z˛P 




 P¸
O
 O,


P

Lemma 5.22 There is a multi-threaded strategy uˆcell such that uˆcell ∼ ucell
and uˆcell satisfies visibility.
u˜cell = [[λf.newchan λc.(f (λx.recv c; x; recvc; nil  skip)) ((send c 0); send c 0)]] A typical play of u˜cell (with concurrency pointers) is as follows.
[[((comm ⇒ comm) ⇒ (comm ⇒ comm)) ⇒ comm]]
O ,


O,¸,¸ ¸¸ _  2 ,
c sP ,¸ ¸
, , P¸¸ , 1

P ¸& ,¸ 
O
¸  O,
 
,

P


To prove Proposition 5.21, let σ^ = uˆcell; σ˜ ∼ ucell; σ˜ = σ.
Factorization
To prove the full abstraction results it remains to show that every finitary strategy satisfying pointer-blindness, well-bracketing and visibility can be re- duced to the composition of an innocent and sequential strategy with a finite number of ccells and parallel compositions. First, a factorization of each fini- tary multi-threaded strategy into a sequential strategy plus parallel composi- tion.
Definition 5.23 Given sa ± t ∈ LMA, define branches(sa, t) to be the num- ber of moves in t which point to a. For finitary σ, let
branches(σ) = max({branches(sa, t) | sa ± t ∈ Tσ ∧ λOP (a)= O}).
Thus σ is sequential if and only if branches(σ) ≤ 1.
Proposition 5.24 Let σ : A be a finitary strategy such that branches(σ)= n. Then there exists a finitary sequential strategy sq(σ): [[comm]] → A such that: [[  i≤nskip]]; sq(σ)= σ.
Proof. The idea behind the factorization is simple. In response to each O- move a in A, sq(σ) makes a move with a concurrency pointer to a in comm, prompting Opponent (playing as [  i≤nskip]]) to give n answers. Then sq(σ) plays as σ, except that where σ plays a move with a pointer a, sq(σ) plays the same move with a pointer to a fresh instance of one of these answers. For example, a factorized play run as follows:
[[comm]]  → A
.

$  ¸	c
, ¸ z. ˛

_zq ˛
a1, ...	an
¸ ¸	,,
¸ ¸	,	.
¸ ¸ , ,¸ _ P
, ,	.
¸ .
P
Let q be the initial question in [comm]] and a1, a2,... an its answers. Suppose that ∀sa ± t.branches(sa, t) ≤ n.
Define a Player-sequential sequence sq(t), by the following induction:
sq(ε)= ε,
sq(sb)= sq(s)bqa1a2 ... an, if b is an O-move,
sq(sbtc)= sq(sbt)c (where c points to ai), if c is a P -move pointing to b, and
branches(sb, sbtc)= i.
Thus sq( ) is a map from LMA to LM[[comm]]→A with the following properties: sq(s) is player-sequential, sq(s)TA = s and sq(s)T[[comm]] ∈ [[  i≤nskip]]. Let sq(σ)= {t ∈ LM[[comm]]⇒A | ∃s ∈ σ.t  sq(s)}.

The factorization of sequential strategies on into innocent strategies via the chan type and ccell strategy is more complex. It resembles the factorization of innocence via the cell strategy [1] in that it uses ccell to encode information about the entire history of the play, but it also uses synchronization in a fundamental way and incorporates the factorization of non-determinism via an “oracle” given in [8]. The factorized strategy runs two threads in parallel, a “master strategy” which operates solely by sending and receiving messages in a context of channels; it observes Opponent moves and dictates Player moves in the main arena via communication with a (generalized) “slave strategy” which moves back and forth between the channels and the main arena, reporting on the progress of play in the latter to the master strategy and executing its commands.
For a finitary strategy σ let responses(σ) be the greatest number of different P -moves which σ can give in response to one position — i.e. responses(σ)= max{|{sa : sa ∈ Tσ ∧ λOP (a)= P }| : s ∈ Tσ}.
Proposition 5.25 For each arena A and k ∈ ω there exists a finitary, se- quential and innocent (deterministic) strategy slavek : nat×nat×chank+2 → A such that if σ : A is a finitary strategy bounded by k and responses(σ) = n, then there is an innocent strategy mas(σ): (nat × nat) × chank+2 × nat → A and such that oraclen × [[0  1]] × ccellk+2; (mas(σ)|slavek)= σ.
Proof. Factorized plays proceed as follows. The slave responds to each Op- ponent move a in A by trying to send an encoding of it (and its view) on channel 1. The master maintains a single open receive question on channel 1, allowing it to learn the entire history of play in A (up to  and ∼O). Once the master and slave have concluded a successful communication on channel 1, the master sends the slave a number 2 < i ≤ k + 2 on channel 2. This number is the name of a private channel, in which the slave immediately plays a receive move, waiting for communication from the master. When the mas- ter has observed that play in A has taken place to which σ would respond with one of the P -moves b0, b2,... bm, he splits the thread of control using the parallel composition [[0  1]], in a special case of the sequentialization factoriza- tion of Proposition 5.24. In one of the threads thus created, he maintains the surveillance of channel 1 by repeating the receive question. In the other, he uses the oracle to generate j ≤ m non-deterministically. If the move bj has a pointer to ai the master then sends an encoding of bj on channel i which is received by the waiting slave, who plays the move bj with a pointer to ai as required.

The factorization theorems together with Proposition 5.17 yield the following definability result.
Corollary 5.26 Every finitary (pointer-blind) strategy σ over a channel-free type-object [[T ]] is definable (up to ∼) as an ICSP term Mσ : T.

The definability result means that the “intrinsic equivalence” on strategies corresponds to observational equivalence. Thus we have a fully abstract model of ICSPvia the standard argument [6,12].

Theorem 5.27 Let T be a channel-free type. For all closed terms M, N : T of ICSP, M may N if and only if [[M ]] ≡may [[N ]] if and only if T[[M]] ∼ T[[N]]. For all closed terms M, N : T of finitary ICSP, M  M&M N if and only if [[M ]] ≡M&M [[N ]] if and only if [[M ]] ∼ [[N ]].



Conclusions

The semantics of ICSP described here can be considered a first step in an attempt to describe concurrency more generally using game semantics. A first priority must be to extend the full abstraction result, either to may-and- must testing for recursively defined process or to a bisimulation equivalence It seems clear that to do so requires the incorporation of the reductions of the operational semantics into the games model. This is certainly possible; one can introduce “silent moves” which belong to neither Player nor Opponent and correspond directly to reductions. It seems likely, however, that this extra “syntactic” element may make the denotational semantics more difficult to reason about.
Another desirable development would be an extension of the full abstrac- tion result to types including channels. Recent work by McCusker on the game semantics of Idealized Algol without bad variables suggests that this is possible using an ordering on legal plays, although in the concurrent case it seems rather more complicated.
Variations on the language itself can be considered. For instance, asyn- chronous message passing as in Brookes’ model [7]. Or we could consider a call-by-value language with thread-identifiers and passing of functions as messages (a kind of “core CML” [17]). It is straightforward to give a call-by- value semantics in the style described here (either directly, or by using the Fam(C) construction [2]), and to extend the interpretation of message passing to higher-order.
As we have described a framework for modelling concurrency using HO- games, there is plenty of scope for more general developments. Varying the definition of the preorder  should yield the opportunity to model concurrency features which give different powers to syncronize events across threads. The relationship with the games semantics of sequential effects such as control and state offers the chance to study the interaction between these features and concurrent ones, including some expressiveness isssues which have been hinted at here.

References

S. Abramsky and G. McCusker. Linearity, Sharing and State: a fully abstract game semantics for Idealized Algol with active expressions. In P.W. O’Hearn and R. Tennent, editors, Algol-like languages. Birkhauser, 1997.
S. Abramsky and G. McCusker.  Call-by-value games.  In M. Neilsen and W. Thomas, editors, Computer Science Logic: 11th Annual workshop proceedings, LNCS, pages 1–17. Springer-Verlag, 1998.
S. Abramsky and P.-A. Mellies. Concurrent games and full completeness. In Proceedings of the 14th annual Symposium on Logic In Computer Science, LICS ’99, 1999.
S. Abramsky, K. Honda, G. McCusker. A fully abstract games semantics for general references. In Proceedings of the 13th Annual Symposium on Logic In Computer Science, LICS ’98, 1998.
S. Abramsky, R. Jagadeesan. Games and full completeness for multiplicative linear logic. Journal of Symbolic Logic, 59:543–574, 1994.
S. Abramsky, R. Jagadeesan and P. Malacaria. Full abstraction for PCF. Accepted for publication in Information and Computation, 1996.
S. Brookes. Idealized CSP: Combining procedures with communicating processes. In Proceedings of MFPS ’97, Electronic notes in Theoretical Computer Science. Elsevier-North Holland, 1997.
R. Harmer and G. McCusker. A fully abstract games semantics for finite non- determinism. In Proceedings of the Fourteenth Annual Symposium on Logic in Computer Science, LICS ‘99. IEEE Press, 1998.
M. Hennessy, and E. Ashcroft. A mathematical semantics for a non- deterministic typed λ-calculus. Theoretical Computer Science, 11:227–245, 1980.
C. A. R. Hoare. Communicating sequential processes. Communications of the ACM, 21(8):666–677, 1978.
K. Honda and N. Yoshida. Game theoretic analysis of call-by-value computation. In Proceedings of 24th International Colloquium on Automata, Languages and Programming, volume 1256 of Lecture Notes in Computer Science. Springer-Verlag, 1997.
J. M. E. Hyland and C.-H. L. Ong. On full abstraction for PCF: I, II and III, 1995. To appear in Theoretical Computer Science.
J. Laird. Full abstraction for functional languages with control. In Proceedings of the Twelfth International Symposium on Logic In Computer Science, LICS ‘97, 1997.


J. Laird. A fully abstract game semantics of local exceptions. In Proceedings of the Sixteenth International Symposium on Logic In Computer Science, LICS ‘01, 2001. To appear.
G. McCusker. Games and full abstraction for a functional metalanguage with recursive types. PhD thesis, Imperial College London, 1996.
H. Nickau. Hereditarily sequential functionals. In Proceedings of the Symposium on Logical Foundations of Computer Science:Logic at St. Petersburg, LNCS. Springer-Verlag, 1994.
J. Reppy. Higher Order Concurrency. PhD thesis, Cornell University, 1992.
J. Reynolds. Syntactic control of interference. In Conf. Record 5th ACM Symposium on Principles of Programming Languages, pages 39–46, 1978.
J. Reynolds. The essence of Algol. In Algorithmic Languages, pages 345–372. North Holland, 1981.
