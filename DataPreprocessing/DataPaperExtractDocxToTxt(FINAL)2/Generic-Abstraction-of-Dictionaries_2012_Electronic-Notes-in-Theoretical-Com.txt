Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 287 (2012) 53–64
www.elsevier.com/locate/entcs


Generic Abstraction of Dictionaries and Arrays
Jędrzej Fulara1,2
Institute of Informatics University of Warsaw

Abstract
We present a generic abstract domain for analysis of dictionary and array content. Our technique is parametrised by the abstractions of scalars, dictionary keys and dictionary values. It can be instantiated with various existing domains, including non-numerical ones (such as domains for analysis of properties of string variables). It is powerful enough to express relations between container content and scalars.
The analysis is fully automatic. The container is partitioned according to properties of the keys, captured by the underlying key abstraction. The precision and cost of the analysis are customisable and depend on the choice of the abstractions of keys, dictionary elements and scalar variables.
We show examples in which the technique is used to reason about arrays as well as string-keyed dictionaries. The approach was also experimentally evaluated.
Keywords: Abstract Interpretation, Abstract Domains, Dictionary Content Analysis

Collections such as dictionaries and arrays are very important building blocks of programs, thus static analysis techniques should be able to reason about the content of such containers. Our goal is to provide a generic solution for modelling arbitrary dictionaries and arrays in static analysis by abstract interpretation [2]. The technique should be fully automatic and it should be possible to adjust its precision/cost ratio. It should be possible to instantiate the technique not only with numerical abstract domains [9,13,15], but also with domains of other types, such as e.g. domains for string analysis [8].
Abstract Interpretation We use the classic definition of abstract interpreta- tion [2]. An abstract domain is a tuple A = ⟨A, Ha, Ha, αa, γa, δa, oa⟩ denoting the set of abstract states, meet, join, abstraction, concretisation, transfer function and widening. We require also a projection ·↓v (called variable elimination), a dual operator ·𝛙v (variable introduction) and a forget operator ·‡v .

1 This work has been partially supported by the Polish Ministry of Science and Higher Education, grant N206 493138
2 Email: fulara@mimuw.edu.pl

1571-0661 © 2012 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2012.09.006

Notation We analyse programs that operate over a set of scalar variables Var (with values in some set V) and dictionaries Varc. The dictionary keys and elements belong to sets K and E, respectively. A concrete program state is a pair (ρ, τ ) ∈ (Var → V) × (Varc → (K - E)). The only dictionary statements that we consider are updates T [v1] → v2 and T [v1] → c, read v2 → T [v1] and boolean predicates φ(T [v1], v2), where T ∈ Varc, v1, v2 ∈ Var and c ∈ E.
Outline Section 1 introduces a structure to represent a single dictionary. In Sec- tion 2 we show how to use it to build an abstract domain. Examples of the domain are shown in Section 3. Section 4 describes an experiment. Related work is sketched in Section 5. We conclude in Section 6. Proofs and additional examples can be found in an extended version of this work [8].
Representation of a Dictionary
We model a dictionary T ∈ Varc as a set of abstract segments. Each abstract seg- ment represents some set of (concrete) keys and corresponding dictionary elements. Let K and V be two abstract domains (with carriers ⟨K , Hk , Hk⟩ and ⟨V , Hv , Hv⟩). An abstract segment is a pair (k, v) ∈ K × V , where k models a set of concrete keys (together with their relations to scalars) and is called an abstract key, while v abstracts the dictionary elements (and their relations to scalars) and is called an ab- stract value. The dictionary abstraction is a (restricted) powerset of the product K × V [3].
Let us introduce some auxiliary terminology. In a lattice ⟨A, Ha, Ha, ⊥a, 𝖳a⟩, a ∈ A
is empty, if a = ⊥a; a ∈ A overlaps with b ∈ A, when a Ha b /= ⊥a.
We define now a lattice ⟨D, Hd, Hd⟩, where D ⊆ Уfin(K × V ) and each d ∈ D fulfils the following additional well-formedness conditions:
for (k1, v1) ∈ d and (k2, v2) ∈ d either (k1, v1)= (k2, v2) or k1 Hk k2 = ⊥k,
for (k, v) ∈ d , k /= ⊥k and v /= ⊥v.
The first condition states that every two abstract segments represent disjoint sets of concrete elements. The second condition forbids abstract segments with empty abstract keys or abstract values. An abstract segment (⊥k , v) would represent an empty fragment of the dictionary, while (k, ⊥v) would model a set of elements that could not have been initialised to any value. Such abstract segments are superfluous in our representation.
For each (concrete) dictionary d : K - E represented by an abstract dictionary d ∈ D and for each key n ∈ Dom(d), there exists an abstract segment (k, v) ∈ d such that n and d(n) are abstracted by k and v, respectively.
Meet and Join The meet a Hd b of a, b ∈ D consists of abstract segments obtained as a point-wise meet of some overlapping segments from a and b:
{(ka Hk kb , va Hv vb ) | (ka, va) ∈ a, (kb , vb ) ∈ b, ka Hk kb /= ⊥k , va Hv vb /= ⊥v} .

Lemma 1.1 The meet operator is well deﬁned, i.e. a Hd b ∈ D.
The join a Hd b of a, b ∈ D should represent all concrete dictionaries abstracted by a or b, thus one could try to define it as a union a ∪ b. However, join defined in this way could violate the first well-formedness condition. We show now how to avoid this problem, i.e. transform an arbitrary set of abstract keys into a set in which no two keys overlap. The idea is to identify groups of overlapping keys and replace each group with its least upper bound.
Let ⟨A, Ha, Ha⟩ be a complete lattice and let S be a finite subset of A.
Definition 1.2 We	say	that	a	finite	family	of	non-empty	sets	X	=
{X1, X2,..., Xk}, where each Xi ⊆ S, is a disjoint partition of S, iff:
X is a partition of S (i.e. S =	X and Xi ∩ Xj = ∅ for i /= j),
for every Xi, Xj ∈ X , where i /= j, it holds that ( a Xi) Ha ( a Xj)= ⊥a.
A disjoint partition of S always exists — if S = ∅, then X  ∅, otherwise one can take X  {S}. If S has multiple disjoint partitions, then we are interested in a partition X of S that does not perform any unnecessary grouping:
Definition 1.3 We say that a disjoint partition C of S is least, if for any disjoint partition X of S it holds that 6C∈C𝖤X∈𝐹 C ⊆ X.
Intuitively, the least disjoint partition groups (puts into the same Xi) these elements of S that must be grouped together in each disjoint partition of S.
Lemma 1.4 The least disjoint partition of S exists and is uniquely deﬁned.
We use the concept of the least disjoint partition to transform arbitrary c ∈ Уfin(K × V ) into an abstract dictionary d ∈ D. Let S denote the set of abstract keys of ”non-empty” abstract segments (k, v) ∈ c:
S  )k | (k, v) ∈ c,k /= ⊥k ,v /= ⊥v} .
Let C denote the least disjoint partition of S. We define a disjoint normalisation
function dNorm : Уfin(K × V ) → D as:
dNorm(c)  )(.k kj, .v vj) | {k1,..., km} ∈ C, (kj, vj) ∈ c,j ∈ {1,..., m}} .

This normalisation can be computed in O(|c|3) time, including the computation of the least disjoint partition C. Now the join a Hd b can be defined just as the normalised union a ∪ b, i.e. a Hd b  dNorm(a ∪ b).
Theorem 1.5 Set D forms a lattice under Hd and Hd.
Widening The widening preserves all segments from the first argument that are disjoint with each segment from the second argument, replaces overlapping segments with their widening in K and V and replaces each segment (l, w) from the second argument that is disjoint with all segments from the first one with (𝖳k , w) [8].

The Domain
We utilise now the lattice defined above to define an abstract domain. The content of each dictionary will be over-approximated using ⟨D, Hd, Hd⟩ defined above. In an abstract segment (k, v), k and v over-approximate sets of keys of concrete elements and of their possible values, respectively. If a key is not abstracted at all, then the corresponding element cannot be initialised.
The abstract keys are modelled within an abstract domain K over the set Var ∪
{vk}, where vk is an artificial key variable used to represent the value of a key. Similarly, the abstract values are represented using an abstract domain V over the set Var ∪ {vv}, where vv is a value-tracking variable that represents the value of a dictionary element. In this approach it is possible to express relations between scalars and keys as well as scalars and dictionary elements.
The lattice D(K , V ) can be used to over-approximate the content of a dictionary, but it does not give any information about which elements must be initialised. We solve this problem by associating with each dictionary also an element of D(K , Bool ) that is used to over-approximate the set of uninitialised dictionary elements. A seg- ment (k, True) means that elements at keys abstracted by k may be uninitialised. If some key is not abstracted by any segment, then the element at this key must be initialised. As False is the bottom in the lattice of booleans, segments (l, False) are automatically removed.
The scalar part of the state is abstracted in some abstract domain A over the set of variables Var . We require also conversion functions κA→K and κK→A between the domains A and K as well as κA→V and κV →A between A and V .
Now we may define the domain C = ⟨C , Hc, Hc, γc, αc, δc, oc⟩. The set of abstract states C is given by C  A × (Varc → D(K , V )) × (Varc → D(K , Bool )). An abstract state will be denoted as (a, d, i) ∈ C .
Domain Operations The meet Hc and join Hc are defined point-wise. The widening oc is defined in a lazy manner, as the dictionary modifications should get stable, when the abstract state a ∈ A of scalars stabilises:
(a1, d1, i1) o (a2, d2, i2)   (a1 oa a2, d1 Hd d2, i1 Hd i2)	if a1 oa a2 /= a1
c	(a1 o a ,d o d ,i o i )	otherwise.

Concretisation The concretisation of scalars is defined using the concretisation γa in the scalar domain A. Let us consider a concrete valuation ρ : Var → V of scalar variables, a dictionary T ∈ Varc. and a concrete key n ∈ K. If there is an abstract segment (k, True) ∈ i(T ) such that n is abstracted by k, then T [n] may be uninitialised. If there is an abstract segment (l, w) ∈ d(T ) such that n is abstracted by l, then T [n] may have some value abstracted by w. If there is neither (k, True) ∈ i(T ) nor (l, w) ∈ d(T ) such that n is abstracted by k or l, then T [n] can be neither initialised nor uninitialised, hence for the valuation ρ of scalars, there is no valuation τ : Varc → (K - E) of dictionaries.
Following these observations, we define a predicate I(ρ, T, n, i) for ρ : Var → V,

d'  λT.dNorm {(δk(I, k), δv(I, v)) | (k, v) ∈ d(T )}
i'  λT.dNorm {(δk(I, k), True) | (k, True) ∈ i(T )}
δc I, (a, d, i)   δa(I, a), d', i'
Fig. 1. Transfer function for a scalar instruction I

T ∈ Varc, n ∈ K and the initialisation part of the abstract state i that holds if and only if T [n] may be uninitialised:
I(ρ, T, n, i)  True ⇔ 𝖤(k,True)∈i(T ) 𝖤σ∈γk(k) σ|Var = ρ, σ(vk)= n .	(1) Similarly, we define a predicate V(ρ, T, n, m, d) for ρ : Var → V, T ∈ Varc, n ∈ K,
m ∈ E that holds when T [n] may be equal to m:
V(ρ, T, n, m, d)  True ⇔ 𝖤(k,v)∈d(T ) 𝖤σk ∈ γk(k) 𝖤σv ∈ γv(v)
σk|Var = σv|Var = ρ, σk(vk)= n, σv(vv)= m . (2) This allows us to define the concretisation γc((a, d, i)) as:
 (ρ, τ ) | ρ ∈ γa(a), 6T ∈Varc 6n∈K n /∈ Dom(τ (T )) and I(ρ, T, n, i) or
 n ∈ Dom(τ (T )) and V(ρ, T, n, τ (T )(n), d) , .

Transfer Function
We provide the transfer functions for scalar and dictionary statements. We illustrate the definitions on examples, where all A, K and V are chosen as the domain of intervals with values in Z. For clarity, in each abstract segment we show only the values of the key and value-tracking variables vk and vv.
Scalar Statements The abstract keys and abstract values model relationships with scalar variables, thus scalar statements are interpreted not only in the scalar domain A, but also in all abstract segments in all containers, as shown in Figure 1. When a scalar variable is modified, all its relations to abstract keys and abstract dictionary elements are updated.
Dictionary Statements An empty dictionary is created by T → new dict:
δc T → new dict, (a, d, i)   a, d[T '→ ∅], i T '→ {(𝖳k , True)}  .
We proceed now with a dictionary read v2 → T [v1], where T ∈ Varc and v1, v2 ∈ Var (see Figure 2). Intuitively, we retrieve from d(T ) all abstract segments (there may be more than one) whose keys overlap with the key for the access T [v1]. Formally, we compute k ∈ K by adding to a the artificial key variable vk, assigning vk → v1 and converting the result into the domain K, i.e. k  κA→K(δa(vk → v1, a𝛙v )). We take the join of all values in all abstract segments (l, w) ∈ d(T ) whose keys overlap with k, i.e. v   v{w | (l, w) ∈ d(T ),l Hk k /= ⊥k}, convert v back to the domain A, assign v2 → vv and eliminate the special value-tracking variable vv. Finally, we invalidate

k  κA→K δa(vk → v1, a𝛙vk )	v	v w | (l, w) ∈ d(T ),k Hk l /= ⊥k
a'  δa(v2 → vv, κV →A(v) Ha a𝛙v )	( , d', i')  (a, d, i)‡v
v	2
δc v2 → T [v1], (a, d, i)   (a'↓v , d', i')
Fig. 2. Transfer rule for v2 → T [v1]
k  κA→K δa(vk → v1, a𝛙vk )	v  κA→V δa(vv → v2, a𝛙vv ) 

x  dNorm d(T ) ∪ {(k, v)}

δc T [v1] → v2, (a, d, i)   (a, d[T '→ x], i)	чSk

Fig. 3. Weak update T [v1] → v2
(k)

the old value of v2 in all abstract segments. The read results in an error, whenever the accessed key may be uninitialised, i.e. {l | (l, True) ∈ i(T ),k Hk l /= ⊥k} /= ∅.
Example 2.1 Let us consider v1 ∈ Var with a(v1)= [1, 4] and T ∈ Varc modelled as
d(T )= {([0, 2], [−2, 1]), ([3, 5], [4, 4]), ([6, 9], [2, 7])} and i(T )= {([8, ∞], True)}. The
read v2 → T [v1] gives a(v2)= [−2, 4].
We define both weak and strong dictionary updates. The strong update can be performed only when for each valuation of the scalars there is at most one possible value of the updated key. We formalise this by defining the following unary predicate S on the domain K:
S(k)= True e 6σ1,σ2∈γk(k)(σ1|Var  = σ2|Var  ⇒ σ1(vk)= σ2(vk)) .
This definition is not very practical, thus we require that the domain K is equipped with a domain-specific predicate Sk that implies S, i.e. 6k∈K Sk(k) ⇒ S(k). If Sk(k)= True, then we say that k is a singleton.
Let us consider an update T [v1] → v2. We compute the abstract key k ∈ K in the same way as in the read. Similarly we obtain the abstract value v ∈ V .
If k is not a singleton (i.e. чSk(k)) then a weak update is performed as de- fined in Figure 3. We add the new abstract segment (k, v) to d(T ) and compute dNorm(d(T ) ∪ {(k, v)}). The initialisation information is not altered.
If k is a singleton, a strong update can be performed. The container d(T ) may already contain an abstract segment (l, w) that describes the updated element, i.e. k Hk l /= ⊥k. The new value should be assigned only to the modified element, all other elements associated with keys abstracted by l should remain unchanged. We need to split l into a collection of smaller keys k, m1, m2,... mj which represent together the same concrete keys as l. We say that a function ζ : K × K → У(K ) is a decomposition of an abstract key l ∈ K with respect to a singleton k ∈ K if:
6m1,m2∈ζ(l,k)∪{k} m1 /= m2 ⇒ m1 Hk m2 = ⊥k,
k /∈ ζ(l, k),
γk(k) ∪	m∈ζ(l,k) γk(m)  = γk(l).
The definition of ζ(l, k) must be provided together with the domain K.
We define an operation  : D(K , V ) × (K × V ) - D(K , V ) so that d  (k, v)

k  κA→K δa(vk → v1, a𝛙vk )	v  κA→V δa(vv → v2, a𝛙vv )
x  d(T )  (k, v)	y  i(T )  (k, False)
δc T [v1] → v2, (a, d, i)   a, d[T '→ x], i[T '→ y]	Sk

Fig. 4. Strong update T [v1] → v2
k  κA→K δa(vk → v1, a𝛙v k )	v .v)w | (l, w) ∈ d(T ),k Hk l /= ⊥k}


(k)



δc φ(T [v1], v2), (a, d, i)   (a, d[T '→ x ], i), (a, d[T '→ x ], i)	k
t	f

Fig. 5. Boolean predicate φ(T [v1], v2)

overwrites in d the elements at keys abstracted by k:

d  (k, v)  d \ (l, w) | (l, w) ∈ d ,l Hk k /= ⊥k	∪ (k, v)
∪ )(m, w) | (l, w) ∈ d ,l Hk k /= ⊥k ,m ∈ ζ(l, k)} .
The operation d  (k, v) is defined only if k is a singleton.
Let k and v be as in the weak update and let k be a singleton. The strong update overwrites in d(T ) the old value associated with the abstract key k and marks in i(T ) that the element at key abstracted by k must be initialised (see Figure 4). The strong update forgets only the old value of the updated element (by the definition of the decomposition) and replaces it with an abstract value that over-approximates the inserted concrete value.
Example 2.2 [Weak update] Consider the same container T ∈ Varc and scalar v1 ∈ Var as in Example 2.1, with an additional scalar v2 ∈ Var such that a(v2) = [8, 8]. The update T [v1] → v2 gives d(T )= {([0, 5], [−2, 8]), ([6, 9], [2, 7])}.
Example 2.3 [Strong update] Consider scalars v1, v2 ∈ Var , such that a(v1) = [2, 2] and a(v2) = [7, 7] and a container T ∈ Varc with d(T ) = {([0, 5], [1, 3])}, i(T ) = {([0, ∞], True)}. The strong update T [v1] → v2 modifies T so that d(T ) = 
{([0, 1], [1, 3]), ([2, 2], [7, 7]), ([3, 5], [1, 3])}. It also marks that the updated element must be initialised, setting i(T )= {([0, 1], True), ([3, ∞], True)}.

Boolean Predicates Boolean predicates (that occur in conditional statements) may operate over a scalar variable and a dictionary access, e.g. φ(T [v1], v2). We restrict the possible values of T [v1] as shown in Figure 5. Let k denote the abstract key for the access T [v1] and v is the corresponding abstract value. If k is a singleton, then we restrict v according to φ(vv, v2).
Example 2.4 Consider v1, v2 ∈ Var such that a(v1)= [4, 4] and a(v2)= [0, 0] and T ∈ Varc such that d(T )= {([0, 4], [−2, 5])}. A test T [v1] ≤ v2 evaluates to two ab- stract states (cTrue, cFalse), in which d(T ) is given by {([0, 3], [−2, 5]), ([4, 4], [−2, 0])}
and {([0, 3], [−2, 5]), ([4, 4], [1, 5])}.

Examples
We present examples, in which the domain is used to reason about arrays and string-keyed dictionaries.

Analysis of Arrays
Let us discuss a partial array initialisation presented in Figure 6(a). Our analysis detects that after this code fragment first j elements of T are initialised.
In this example, we use a very simple relational domain of upper bounds B [8], in which the set of abstract states B is a map Var → У(Var × {<, ≤}). Intuitively, for each variable x, we keep the set of variables greater than x (with an additional indicator whether the inequality is strict).
We instantiate the domain C by fixing A = B(Var ), K = B(Var ∪ {vk}) and
V = B(Var ∪ {vv}). Below we do not write all bounds explicitly. Instead, for each abstract key k we show only constraints for the key variable vk. If (x, D) ∈ k(vk), we write ”Dx”. If (vk, D) ∈ k(y), then we write ”Dy”. If (z, ≤) ∈ k(vk) and (vk, ≤) ∈ k(z), then we use a shortcut ”=z”. For each abstract value v we show only constraints with the value-tracking variable vv. We also assume that in Var there is a special variable v0 that is equal to 0.
The statement T → new array(n) creates a new array, whose indices range over [0, n). Note that at this program point j = 0 and T.length = n, thus the range of indices l of uninitialised array elements can be written as v0 = j ≤ l < n = T.length. This observation justifies the abstract state just before the loop, which is d(T )= ∅ and i(T )= {({<n, <T.length, ≥j, ≥v0}, True)}.
We assume that nothing can be statically determined about the test φ(x). Let us focus now on the array modification T [j] → x in line 5. The abstract key k ∈ K for the array access T [j] contains the constraints vk ≤ j and j ≤ vk, thus k is a singleton and the strong update is performed. The inserted abstract seg- ment is (k, v) = ({=j, <n, ≥v0}, {=x}) (for sake of clarity, we loose here the con- straints not important in the analysis). After this update, the content of the array is modelled as d(T ) = {({=j, <n, ≥v0}, {=x})}. The initialisation information is i(T )= {({=j, <n, ≥v0}, False), ({<n, >j}, True)}.




1: x → 0, j → 0, T → new array(n)
2: while x < n do
3:	x → x +1 
4:	if φ(x) then
5:		T [j] → x, j → j +1 6:	end if
7: end while	(a)
1: at → ”b” 2: repeat
3:	setattr(obj, at, 6) 4:	at → at + ”c”
5: until random() = False
6: if random() = True then
7:	obj.x → 8
8: else
9:	obj.x → ”text” 10: end if
11: print obj.b - 1
12: print obj.bcc - 1
13: print obj.x - 1

(b)

Fig. 6. Partial array initialisation (6(a)) and dynamically added attributes (6(b))

After the statement j → j + 1, d(T ) and i(T ) are equal to
{({<j, <n, ≥v0}, {=x})}	and	{({<j, <n, ≥v0}, False), ({<n, ≥j}, True)} .
In the second loop iteration, x  →  x + 1 modifies d(T ) so that d(T )  =
{({<j, <n, ≥v0}, {<x})} (i(T ) remains unchanged) and T [j] → x results in
d(T ) = {<j, <n, ≥v0}, {<x} , {=j, <n, ≥v0}, {=x} ,
i(T ) = {<j, <n, ≥v0}, False , {=j, <n, ≥v0}, False , {<n, >j}, True , .
Finally, after j → j + 1 we get d(T ) and i(T ) equal to:
{({<j, <n, ≥v0}, {≤x})}	and	{({<j, <n, ≥v0}, False), ({<n, ≥j}, True)} .
When analysing the next loop iteration, it turns out that this is already the loop invariant. The first abstract segment in i(T ) guarantees that all elements at indices smaller than j were initialised, while d(T ) ensures that all values of these elements are smaller than or equal to x.
Dictionaries
In this example we focus on string-keyed dictionaries. This example is inspired by the representation of objects in dynamic programming languages (such as Python): an object is stored as a dictionary, where each entry represents an attribute of the object. Attributes can be added and removed during program execution. Different types of values may be assigned to the same attribute during the program execution. For instance obj.attr may be at some point an integer, at another point a string, while somewhere else it may refer to a function. This flexibility, although sometimes useful and convenient, leads often to serious errors. When a missing attribute is accessed, the program fails with an AttributeError. When an attribute does not match the expected type (e.g. a string is encountered in an arithmetic operation), a runtime TypeError is raised. We show how to use our technique to statically detect such problems.
Attribute Analysis We abstract each attribute of an object by its possible type. For simplicity, we consider only integer and string attributes. The types can be abstracted in a domain T , with the set of abstract states T = Var → У({Int, Str}) and domain operations given as point-wise set union and intersection.
Object Abstraction As already mentioned, we use our dictionary analysis tech- nique to model possible attributes of an object. We use a very simple domain R, where each attribute name is represented using a generalised regular expres- sion [8]. We instantiate the domain C by fixing A as R(Var ), key abstraction as K = R(Var ∪ {vk}) and value abstraction as V = T (Var ∪ {vv}).
Example 3.1 We demonstrate the analysis on the code fragment shown in Fig- ure 6(b).  We write attribute accesses in a python-like style, however they are


Table 1
Array analysis statistics on open-source projects


in fact just dictionary accesses.  And so obj.x is equivalent to obj[’x’] and
setattr(obj,v,u) can be written as obj[v] → u.
In the abstract segments we show only the abstract values of the artificial variables vk and vv. In the first loop iteration, the scalar at is abstracted as a(at) = b. Thus, after setting the attribute in line 3, the object is modelled as d3(obj) = {(b, {Int})} and i3(obj) = {(чb, True)}. In the next loop iteration at is widened to a(at) = bc∗. Since bc∗ is not a singleton, the setattr in line 3 results in a weak update and after the loop we get d5(obj) = {(bc∗, {Int})} and i5(obj) = {(чb, True)}. After the (strong) update in line 7, obj is modelled as d7(obj)= {(bc∗, {Int}), (x, {Int})} and i7(obj)= {(чb ∧ чx, True)}. Similarly, after the assignment in the second branch we get:
d9(obj)= )(bc∗, {Int}), (x, {Str})}	i9(obj)= )(чb ∧ чx, True)} .

Thus, joining the states from lines 7 and 9 gives
d10(obj)= )(bc∗, {Int}), (x, {Int, Str})}	i10(obj)= )(чb ∧ чx, True)} .

We can now prove that the attribute usage in line 11 is correct. The attribute b must be present in obj and it is an integer. The access obj.bcc is detected as unsafe (possible AttributeError). The analysis captured that obj may contain any attribute bc∗, each of type Int, but bcc (or any bc+) does not need to be present in obj. The last instruction is signalled as unsafe, as obj.x does not need to be an integer at this program point (possible TypeError).

Experiment
We have implemented our technique in a prototype analyser for Java source code. The technique was used to array analysis and was instantiated with the domain of Pentagons [12]. We have measured the performance impact of our technique and the number of discovered non-trivial array invariants (i.e. more precise than ’arbitrary value may be at arbitrary index’). The experiment is summarised in Table 1. For each analysed project we report the size (in kilo lines of code), number of methods, time (in minutes) with array analysis turned off and turned on as well as number of detected invariants. Our results are comparable to those reported for FunArray [4].

Related Work
The simplest approaches to array content analysis are array smashing and array expansion [1]. Gopan et al. have proposed a technique, in which array elements are grouped depending on the relation between their indices and scalar variables (elements at indices smaller, equal to and greater than value of some variable) [10]. Halbwachs and P´eron [11] use a similar idea to automatically discover relations on elements of an array or even of distinct arrays. Cousot et al. have proposed a technique, in which an array is segmented using simple expressions over scalar variables [4]. Dillig et al. have introduced a notion of fluid updates that relax the dichotomy between strong and weak updates [5]. Using uninterpreted functions, this technique can be adapted for arbitrary containers [6], but still it is not possible to express any non-trivial properties of non-numerical keys (e.g. that a key matches a regular expression, like in our example). Other approaches employ techniques such as predicate abstraction [7] or counter-example guided abstraction refinement [14].
Conclusion
We have developed a technique for dictionary and array content analysis. The precision/cost of the analysis depends on the choice of abstractions of scalars as well as dictionary keys and values. We have shown examples, in which our approach was applied to analysis of arrays and string-keyed dictionaries. The solution was experimentally evaluated and gave very promising results.

References
Blanchet, B., P. Cousot, R. Cousot, J. Feret, L. Mauborgne, A. Min´e, D. Monniaux and X. Rival, Design and implementation of a special-purpose static program analyzer for safety-critical real-time embedded software, in: The essence of computation, Springer-Verlag, 2002 pp. 85–108.
Cousot, P. and R. Cousot, Abstract interpretation: a unified lattice model for static analysis of programs by construction or approximation of fixpoints, in: POPL ’77, pp. 238–252.
Cousot, P. and R. Cousot, Systematic design of program analysis frameworks, in: POPL ’79, 1979, pp. 269–282.
Cousot, P., R. Cousot and F. Logozzo, A parametric segmentation functor for fully automatic and scalable array content analysis, in: POPL’11 (2011), pp. 105–118.
Dillig, I., T. Dillig and A. Aiken, Fluid updates: Beyond strong vs. weak updates, in: ESOP, 2010, pp. 246–266.
Dillig, I., T. Dillig and A. Aiken, Precise reasoning for programs using containers, in: POPL’11 (2011),
pp. 187–200.
Flanagan, C. and S. Qadeer, Predicate abstraction for software verification, in: POPL ’02 (2002), pp. 191–202.
Fulara, J., “Abstract Analysis of Numerical and Container Variables,” Ph.D. thesis, University of Warsaw (2012).
Fulara, J., K. Durnoga, K. Jakubczyk and A. Schubert, Relational abstract domain of weighted hexagons, Electron. Notes Theor. Comput. Sci. 267 (2010), pp. 59–72.
Gopan, D., T. Reps and M. Sagiv, A framework for numeric analysis of array operations, in: POPL ’05 (2005), pp. 338–350.

Halbwachs, N. and M. P´eron, Discovering properties about arrays in simple programs, in: PLDI, 2008,
pp. 339–348.
Logozzo, F. and M. F¨ahndrich, Pentagons: a weakly relational abstract domain for the efficient validation of array accesses, in: SAC ’08, pp. 184–188.
Min´e, A., The octagon abstract domain, Higher Order Symbol. Comput. 19 (2006), pp. 31–100.
Seghir, M. N., A. Podelski and T. Wies, Abstraction refinement for quantified array assertions, in:
SAS’09 (2009), pp. 3–18.
Simon, A., A. King and J. M. Howe, Two variables per linear inequality as an abstract domain, in:
LOPSTR’02 (2003), pp. 71–89.
