

Electronic Notes in Theoretical Computer Science 259 (2009) 3–19
www.elsevier.com/locate/entcs

A Single Complete Relational Rule for Coalgebraic Refinement
C´esar J. Rodrigues1 J. N. Oliveira2 Luis S. Barbosa3
Dep. Informatics & CCTC, Minho University, Portugal


Abstract
A transition system can be presented either as a binary relation or as a coalgebra for the powerset functor, each representation being obtained from the other by transposition. More generally, a coalgebra for a functor F generalises transition systems in the sense that a shape for transitions is determined by F, typically encoding a signature of methods and observers. This paper explores such a duality to frame in purely relational terms coalgebraic refinement, showing that relational (data) refinement of transition relations,
in its two variants, downward and upward (functional) simulations, is equivalent to coalgebraic refinement based on backward and forward morphisms, respectively. Going deeper, it is also shown that downward simulation provides a complete relational rule to prove coalgebraic refinement. With such a single rule the paper defines a pre-ordered calculus for refinement of coalgebras, with bisimilarity as the induced equivalence. The calculus is monotonic with respect to the main relational operators and arbitrary relator F, therefore providing a framework for structural reasoning about refinement.
Keywords: Transition systems, coalgebraic refinement.


Introduction
Suppose one needs to replace part of a system by another: How safe is such a replacement? The classical answer in a process algebra context, namely after Mil- ner landmark work in Ccs [27], is well-known: they should be bisimilar. Typical concurrent implementations of non-deterministic specifications, for example, are witnessed by bisimilarity. Informally, two systems are bisimilar if they behave in such a way, that an observer cannot distinguish between them and this inability is maintained along the systems evolution. This is captured by a relation among their state spaces which maintains equality of observed effects along the system evolution, i.e., a bisimulation.

1 Email: cjr@di.uminho.pt
2 Email: jno@di.uminho.pt
3 Email: lsb@di.uminho.pt

1571-0661 © 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.12.014

The concept of bisimulation is nowadays discussed in the broader context of coalgebras [37,2], which generalises (labelled) transition systems (LTS). Formally,
given an endofunctor F over Set a F-coalgebra or F-system is a function F S ¸α,S  S .
Set S is referred to as the coalgebra carrier or set of states. Function αS is the F-
transition structure (or dynamics) of the system.
Consider, for illustrating purposes, a LTS represented by a transition relation
Act × P ¸R,  P involving a set of behaviours (or processes) P and a set of obser-
vations and actions Act. Relation R can be transposed to a function R of type
( P ¸,  P )Act so that, for all α ∈ Act, q(R α)p ≡ (α, q) R p 
holds. Wherever R is implicit in the context, notation q←α p (meaning q is reach-
able from p via action or observation α) abbreviates q(R α)p. Clearly, the power- transpose of a given LTS R, PA × P ¸Λ,R  P , is a B-coalgebra for
B X = PA × X
In general, a coalgebra for an arbitrary functor F corresponds to a transition system of shape F and the notion of bisimulation acquires a shape as well.
It is not surprising that, along the last decade, coalgebra theory emerged as a common framework to describe ‘state based’, dynamical systems. Its study along the lines of Universal Algebra, was initiated by J. Rutten in [37]. There are a number of tutorials (see, eg., [23], [17] or [2]) to which the interested reader can be referred to. The proceedings of the Coalgebraic Methods in Computer Science workshop series, initiated in 1998, document current research ranging from the study of concrete coalgebras over different base categories [38] to the development of Set-independent, i.e., purely categorical, presentations of coalgebra theory (see, among others [38,32]), from coalgebraic logic (eg., [28]) to applications. Application examples range from automata [36] to objects [33,21], from process semantics [39] to hybrid transition systems [20]. B. Jacobs and his group, following earlier work by
H. Reichel [33,19] have coined the term coalgebraic speciﬁcation [22,24,35] to denote a style of axiomatic specification involving equations up to bisimilarity acting as constraints on the observable behaviour. Alternatively, the direct use of coalgebraic structures as models of software components is discussed in [6,12].
In both cases, the quest for a suitable notion of refinement for coalgebras emerged as a main concern. The task is demanding because the classical ‘recipe’ to identify a refinement situation (look for an abstraction function to witness it), does not apply. Formally such ‘recipe’ corresponds to looking for a morphism in the relevant category, from the ‘concrete’ to the ‘abstract’ model such that the latter can be recovered from the former up to a suitable notion of equivalence. The problem is that coalgebra morphisms entail bisimilarity, whereas one would expect to have an order relation expressing some sort of behaviour simulation.
The problem was addressed previously by the second and third authors in a series of papers including [25,26] and [7]. In these references refinement is captured by the existence of some form of weak coalgebra morphism (just as bisimulation

amounts to the existence of a standard morphism) with respect to a particular refinement preorder. The latter, on its turn, exploits the structure of the coalgebra dynamics in a number of different ways (leading, correspondingly, to a number of refinement preorders). Finally, such preorders can be used in two dual ways referred to in [25] as forward or backward refinement. In broad terms, the former generalises the usual axis of non determinism reduction in a functorial way, whereas the latter corresponds to a similar functorial generalisation of deﬁnition increase.
In this context, the contribution of this paper is an attempt to frame in purely relational terms coalgebraic refinement, showing that relational (data) refinement of transition relations, in its two variants, downward and upward (functional) simu- lations, is equivalent to coalgebraic refinement for the structural inclusion preorder (i.e., the quotient of structural membership as explained below), based on backward and forward morphisms, respectively. Moreover, we show that downward simula- tion is enough as a single complete relational rule to prove this sort of coalgebraic refinement. Based on such a rule the paper introduces a pre-ordered calculus for the refinement of coalgebras, with bisimilarity as the induced equivalence. The calculus is monotonic with respect to the main relational operators and arbitrary relator F, therefore providing a framework for structural reasoning about refinement.
The following section contains a glimpse of the relational calculus [1,8,4] used in the paper. Then, sections 3 and 4 introduce the paper’s technical contributions as detailed above. Finally, section 5 concludes and provides a few pointers to current work.

Overview of the relational calculus
Relations.
Let B ¸R,  A denote a binary relation on datatypes A (source) and B (target).
We write bRa to mean that pair (b, a) is in R. The underlying partial order on relations will be written R ⊆ S, meaning that S is either more defined or less de- terministic than R, that is, R ⊆ S ≡ bRa ⇒ bSa for all a, b. Equality on relations can be established by ⊆-antisymmetry: R = S ≡ R ⊆ S ∧ S ⊆ R.
Relations can be combined by three basic operators: composition (R·S), converse (R◦) and meet (R ∩ S). R◦ is the relation such that a(R◦)b iff bRa holds. Meet corresponds to set-theoretical intersection and composition is defined in the usual way: b(R·S)c holds wherever there exists some mediating a ∈ A such that bRa∧aSc. Everywhere T = R · S holds, the replacement of T by R · S will be referred to as a factorization and that of R · S by T as fusion.

Coreflexives.
Some standard terminology arises from the id relation: a (endo)relation A ¸R,  A (often called an order ) will be referred to as reflexive iff idA ⊆ R holds and as core- flexive iff R ⊆ idA holds. As a rule, subscripts are dropped wherever types are
implicit or easy to infer.

Coreflexive relations are fragments of the identity relation which can be used to model predicates or sets. The meaning of a predicate p is the coreflexive [p ] such that b[[p]]a ≡ (b = a) ∧ (p a), that is, the relation that maps every a which satisfies p (and only such a) onto itself. The meaning of a set S ⊆ A is [λa.a ∈ S]], that
is, b[[S]]a ≡ (b = a) ∧ a ∈ S . Wherever clear from the context, we will omit the [ ] brackets.

Orders.
Preorders are reflexive, transitive relations, where R is transitive iff R · R ⊆ R holds. Partial orders are anti-symmetric preorders, where R is anti-symmetric wherever R ∩ R◦ ⊆ id holds. A preorder R is an equivalence if it is symmetric, that is, if R = R◦. A total order R is a connected preorder, where R is connected iff R ∪ R◦ = T holds. ∪ is the join of two relations and T is the largest relation of its type. Its dual is ⊥, the smallest such relation.

Taxonomy.
Converse is of paramount importance in establishing a wider taxonomy of binary relations. Let us first define two derived operators, the so-called kernel of a relation
ker R d=ef R◦ · R	(1)
and its image
img R d=ef ker (R◦)	(2)
An alternative to (2) is to define img R = R · R◦, since converse distributes over composition,
(R · S)◦ = S◦ · R◦	(3)
and is involutive, that is,
(R◦)◦ = R	(4)
Kernel and image lead to the following terminology: a relation R is said to be entire (or total) iff its kernel is reflexive; or simple (or functional) iff its image is coreflexive. Dually, R is surjective iff R◦ is entire, and R is injective iff R◦ is simple.

Functions.
A relation is a function iff it is both simple and entire. Functions will be denoted by lowercase letters (f , g, etc.) and are such that bfa means b = f a. Function converses enjoy a number of properties of which the following is singled out because of its rle in pointwise-pointfree conversion [3] : 
b(f◦ · R · g)a ≡ (f b)R(g a)	(5)
The overall taxonomy of binary relations further to the standard classification, includes representations and abstractions. These are classes of relations useful in
data-refinement [29]. Because of ⊆-antisymmetry, img S = id wherever S is an
abstraction and ker R = id wherever R is a representation. This ensures that no

confusion arises in a representation and that all abstract data are reachable by an abstraction (no junk).
Isomorphisms are functions, abstractions and representations at the same time. A particular isomorphism is id, which also is the smallest equivalence relation on a particular data domain. So, b id a means the same as b = a. The topmost relation T is the largest equivalence relation of its type. In fact, it is easy to show that T
is the kernel of every constant function, 1 ¸,!	 A included, where function ! is the
unique function of its type, where 1 denotes the singleton data domain.

Relators.
A relator [5] is a concept which extends functors to relations: F A describes a parametric type while F R is a relation from F A to F B provided R is a relation from A to B. Relators are monotone and distribute over composition, converse and the identity:
F (R · S)= (F R) · (F S)	(6)
F (R◦)= (F R)◦	(7)
F id = id	(8)
The most simple relators are the identity relator Id, which is such that Id A = A and Id R = R, and the constant relator K (for a particular concrete data type K) which is such that K A = K and K R = idK.
Relators can also be multi-parametric. Two well-known examples of binary relators are product and sum,
R × S d=ef ⟨R · π1,S · π2⟩	(9)
R + S d=ef [i1 · R, i2 · S]	(10)
where π1, π2 denote the projection functions of a Cartesian product, i1, i2 denote the injection functions of a disjoint union, and the split/either relational combinators are defined by
⟨R, S⟩ d=ef π◦ · R ∩ π◦ · S	(11)
1	2
[R, S] d=ef (R · i◦) ∪ (S · i◦)	(12)
1	2
By putting these four kinds of relator (product, sum, identity and constant) together with fixpoint definition one is able to specify a large class of parametric structures
— called polynomial — such as those implementable in Haskell.  For instance,
the Maybe datatype is an implementation of polynomial relator F = Id + 1 (i.e.
F A = A + 1), where 1 denotes the singleton datatype.

Membership.
Recall the notion of membership from set theory. Wherever we write a ∈ x, where x is a set, we mean a relation of type A ¸∈,  УA , where УA denotes the set of all subsets of A.

Sentence a ∈ x (meaning that a belongs to x or a occurs in x) can be generalized to x’s other than sets. For instance, one may check whether a particular integer occurs in one or more leaves of a binary tree, or of any other collective or container type F.
Such a generic membership relation will have type A ¸∈,  F A , where F is a type parametric on A. Technically, the parametricity of F is captured by regarding it as a functor.
There is more than one way to generalize A ¸∈,  УA to functors other than the

powerset. For the purpose of this paper it will be enough to say that A ¸∈,F
if it exists, is a lax natural transformation [8], that is,
F A ,

∈F · F R ⊆ R · ∈F	(13)
holds. Moreover, polynomial functors involving +, ×, Id and constants have mem- bership defined inductively as follows:
∈K d=ef ⊥	(14)
∈Id d=ef id	(15)
∈F×G d=ef (∈F ·π1) ∪ (∈G ·π2)	(16)
∈F+G d=ef [∈F, ∈G]	(17)
∈F·G d=ef ∈F · ∈G	(18)

Coalgebraic refinement as data refinement
As mentioned in the Introduction, the existence of a coalgebra morphism between two coalgebras makes them bisimilar. Recall that
Definition 3.1 Let (X, p : X −→ F X) and (Y, q : Y −→ F Y ) be coalgebras for functor F. A morphism connecting p and q is a function h between their carriers such that the following diagram commutes:

X   p  F X
i.e.	q · h = F h · p	(19)

h	F h
J	J 
Y	q	 F Y
To base refinement a weaker notion of morphism was proposed in [26] as follows
Definition 3.2 [Forward (backward) morphism]
Let F be a polynomial functor on Set and consider two F-coalgebras β : FV ←−
V and α : FU ←− U .
A forward morphism h : α ←− β with respect to a preorder ≤, is a function from
V to U such that
.
Fh · β ≤ α · h
.	.
where ≤ is the pointwise lifting of ≤, i.e. f ≤ g ⇔ f ⊆≤ ·g, that is, f and g are such that f b ≤ g b, for all b.

Dually, h is said to be a backward morphism w.r.t ≤ if
.
α · h ≤ Fh · β

The two refinement concepts are parameterized by preorder ≤, which is character- ized in [26,7] as belonging to interval id ⊆ ≤ ⊆ (∈F\∈F). The refinement preorder (∈F\∈F) is known as the structural inclusion associated to functor F.
In the context of this definition, it is proved in [26] that
a forward morphism h preserves the transition relation corresponding to coalgebra
β,

β
v ←− v ⇒ hv
' ←α− hv

a backward morphism h reflects the transition relation corresponding to coalgebra
α,

u' ←α− hv ⇒ ⟨∃ v' : v' ∈ V :
β
v ←− v ∧ u
' = hv'⟩

Relational (data) refinement [13] , on the other hand, is discussed in terms of two forms of simulation: downward and upward. Our first result relates such notions, in their functional variant, to those of coalgebraic foward and backward morphisms.
Lemma 3.3 (Upward simulation and forward morphism) Let h be an up- ward simulation,
γ	α
h · ←⊆ ←· h	(20)
where γ is the transition relation associated to coalgebra ц and, in the same way,
←α  is the transition relation associated to coalgebra α. Then (20) is equivalent to

forward morphism condition
.
Fh · ц ≤ α · h

where ≤ is the structural inclusion preorder.
Proof. The equivalence between upward simulation and forward morphism was proven in one way,
F	.	γ	α
h · ц ≤ α · h ⇒ h· ←⊆← ·h
in [26], for all ≤ belonging to interval id ⊆ ≤ ⊆ (∈F\∈F). The full equivalence is established as follows. Notice, however, the restriction of ≤ to the structural inclusion relation ∈F\∈F.
γ	α
h· ←⊆← ·h
≡	{ ←= ϵF · β}
h · ϵF · ц ⊆ ϵF · α · h
≡	{ ϵF is a natural transformation: ƒ · ϵF = ϵF · Fƒ }
ϵF · Fh · ц ⊆ ϵF · α · h
≡	{ Galois connection for division: R · S ⊆ T ⇔ S ⊆ R\T}
Fh · ц ⊆ ϵF\(ϵF · α · h)

≡	{ property R\(S · ƒ ) = (R\S) · ƒ }
Fh · ц ⊆ (ϵF\ϵF) · α · h
≡	{ ≤= ϵF\ϵF}
Fh · ц ⊆≤ ·α · h
≡	{ lifting of ≤}
.
Fh · ц ≤ α · h

The dual result is established through a similar reasoning:
Lemma 3.4 (Downward simulation and backward morphism) In the con- ditions of the previous lemma, let h be a downward simulation,
γ	α
←· h ⊆ h · ←	(21)
Then (21) is equivalent to forward morphism condition
.
ц · h ≤ Fh · α
where ≤ is again the structural inclusion relation.
Proof. The equivalence between downward simulation and backward morphism has been proven in one way,
.	γ	α
ц · h ≤ Fh · α ⇒← ·h ⊆ h· ←
in [26], for all ≤ belonging to interval id ⊆≤⊆ (∈F\∈F). A proof of the equivalence for the case where the refinement preoder is generic inclusion, follows.
γ	α
← ·h ⊆ h· ←
≡	{ ←= ϵF · β}
ϵF · ц · h ⊆ h · ϵF · α
≡	{ ϵF is a natural transformation: ƒ · ϵF = ϵF · Fƒ }
ϵF · ц · h ⊆ ϵF · Fh · α
≡	{ Galois connection for division: R · S ⊆ T ⇔ S ⊆ R\T}
ц · h ⊆ ϵF\(ϵF · Fh · α)
≡	{ property R\(S · ƒ ) = (R\S) · ƒ }
ц · h ⊆ (ϵF\ϵF) · Fh · α
≡	{ ≤= ϵF\ϵF} ц · h ⊆≤ ·Fh · α
≡	{ lifting of ≤}
.
ц · h ≤ Fh · α



These two lemmas show a close relationship among coalgebras and their rela-
tional counterparts. In fact, for any such coalgebra α, its transition relation is easy to spell out:
←α− d=ef ∈F · α	(22)
Note also that a coalgebra morphim, defined in (3.1), admits the following alterna- tive definition:
Definition 3.5 Let (X, p : X −→ FX) and (Y, q : Y −→ FY ) be coalgebras for functor F. A morphism connecting p and q is a function h between their carriers such that
p	q
h· −→ = −→ ·h	(23)
cf. the following diagram:
X   h  Y 
p	q
−→	−→
J	J 
X	h  Y 
This makes it possible to carry out coalgebraic refinement via relational methods.
In the next section this is pursued even further.

A single complete rule for data refinement
The basic result
The title of this section is intentionally that of a paper [15] which proves (using predicate transformers) that a single complete method is enough, instead of the two standard methods of data (relational) refinement.
The following lemma establishes that for proving coalgebraic refinement a single complete data refinement method is enough. The rule is that of downward simula- tion, this time resorting to relations. Its proof makes use of the two shunting rules, witnessing well-known Galois connections,
ƒ · R ⊆ S ≡ R ⊆ ƒ◦ · S	(24)
R · ƒ◦ ⊆ S ≡ R ⊆ S · ƒ	(25)

Lemma 4.1 (Downward Simulation) For proving coalgebraic reﬁnement down- ward simulation is enough. Actually, upward simulation given by the proof rule
γ	α
h· ←−⊆←− ·h	(26)
can be reduced to
γ	◦	◦	α
←− ·h ⊆ h · ←−	(27)
i.e. downward simulation for a relation which is the converse of a function.

Proof.
h is an upward simulation
≡	{ by definition of upward simulation}
γ	α
h· ←−⊆←− ·h
≡	{ shunting rules}
γ	◦	◦	α
←− ·h ⊆ h · ←−
≡	{ by definition of downward simulation}
h◦ is a downward simulation


A reﬁnement calculus
Lemma (4.1) can be used as a basis of a refinement calculus in which a given coalgebra α is refined via its transition relation ←α−. Its laws are inequations of the form
ц ≤R α
where R = h or R = h◦ for some h, meaning (21) or (27), respectively. Let us establish some of its properties.

≤ is a preorder.
First note that ≤ is a preorder: clearly, it is reflexive (R := id),




and transitive,

α ≤R·S ц
α ≤id α


α ≤R β ∧ β ≤S ц ⇒ α ≤R·S ц

≡	{ by definition of ≤}
α	γ
←− ·R · S ⊆ R · S· ←−
⇐	{ β ≤S ц and transitivity of inclusion}
α	β
←− ·R · S ⊆ R· ←− ·S
⇐	{ monotonicity of (·S), because it is an adjoit in a Galois connection [34]}
α	β
←− ·R ⊆ R· ←−
≡	{ α ≤R β}
True
The statement asserting transitivity is decomposed into the following two for- mulations, for

functions



converses of functions
α ≤h β ∧ β ≤g ц ⇒ α ≤h·g ц


α ≤h◦ β ∧ β ≤g◦ ц ⇒ α ≤(g·h)◦ ц
Relation to bisimilarity is given by the following lemma
Lemma 4.2 (Relation with bisimilarity) Preorder ≤ is related to bisimilarity by


Proof.



α ≤f◦ α ∧ α ≤f α
α ≤f◦ α ∧ α ≤f α ≡ α ∼f α	(28)

≡	{ by definition of ≤}
−α→ ·ƒ◦ ⊆ ƒ◦· −α→ ∧ −α→ ·ƒ ⊆ ƒ· −α→
≡	{ shunting, cf. (24) and (25)}
ƒ· −α→⊆−α→ ·ƒ∧ −α→ ·ƒ ⊆ ƒ· −α→
≡	{ ping-pong: R ⊆ S ∧ S ⊆ R ≡ R = S}
ƒ· −α→=−α→ ·ƒ
≡	{ homomorphism on F-coalgebra α, (23)}
F ƒ · α = α · ƒ
≡	{ (endo)homomorphism iff (functional) bisimulation}
α ∼f α


Since a homomorphism is a functional bisimulation [37], we arrive at the follow-
ing corollary:
Corollary 4.3
α ≤f◦ ц ∧ ц ≤f α ≡ α ∼f ц	(29)
Finally, let us prove the calculus is structural, in the sense that it is monotonic with respect to the main relational operators. For this we need to make transition relations explicit. So, instead of the preorder on coalgebras, we will resort, from now on, to the corresponding preorder on transition relations,
γ	α
←−±R←−
where R = h or R = h◦ for some h, meaning (21) or (27), respectively.

Lemma 4.4 (Monotonicity of converse) Converse is monotonic:
γ	α	γ  ◦	α ◦



Proof.
γ	α
←−±h◦ ←− ≡ ←− ±h◦ ←−
(30)

←−±h◦ ←−
≡	{ by definition of ±}
γ	◦	◦	α
←− ·h ⊆ h · ←−
≡	{ converse:R ⊆ S ≡ R◦ ⊆ S◦}

γ
h· ←−
◦⊆←α−◦ ·h

≡	{ shunting, cf. (24) and (25)}
γ  ◦	◦	◦	α ◦
←− ·h ⊆ h · ←−
≡	{ by definition of ±}
γ  ◦	◦
←− ±h◦ ←−


Note that monotonicity of converse cannot be proved when we replace h◦ by h.

Lemma 4.5 (Monotonicity of ∪) If γ	α  and  β
δ	then

←−±R←−	←−±R←−
( γ	β	α	δ



Proof.
γ
←− ∪ ←−) ±R (←− ∪ ←−)	(31)


α	β	δ

←−±R←− ∧ ←−±R←−
≡	{ definition of ±}
γ	α	β	δ
←− ·R ⊆ R· ←− ∧ ←− ·R ⊆ R· ←−
⇒	{ monotonicity of ∪}
γ	β	α	δ
←− ·R∪ ←− ·R ⊆ R· ←− ∪R· ←−
≡	{ (R·) and (·R) are lower Galois adjoints [34], thus distribute over join}
( γ	β	α	δ
←− ∪ ←−) · R ⊆ R · (←− ∪ ←−)
≡	{ definition of ±}
γ	β	α	δ
←− ∪ ←−±R←− ∪ ←−


Lemma 4.6 (Monotonicity of ∩) If ←α− ·ƒ ⊆ ƒ
· ←−
γ
←− ·ƒ ⊆ ƒ
· ←δ−

then
( α	γ

β	δ

Proof.
α


β	γ	◦	δ

←− ·ƒ ⊆ ƒ
· ←− ∧ ←− ·ƒ ⊆ ƒ · ←−

≡	{ monotonicity of ∩}
α	γ	◦	β	◦	δ
←− ·ƒ∩ ←− ·ƒ ⊆ ƒ · ←− ∩ƒ · ←−
≡	{(ƒ◦·) and (·ƒ ) are upper Galois adjoints [34], thus they distribute over
meet}

( α	γ
β	δ

←− ∩ ←−) · ƒ ⊆ ƒ · (←− ∩ ←−)


If ƒ = ƒ◦ we have the following monotonicity result: if  α	β  and  γ	δ


then ( α	γ ) ± ( β	δ )
←−±f ←−
←−±f ←−

←− ∩ ←−	f ←− ∩ ←−


Lemma 4.7 (Monotonicity of composition) If γ
α and β
δ  then



( γ	β
←−±R←−
α	δ
←−±R←−


Proof.
γ	β
←− · ←−) ±R (←− · ←−)	(33)

←− · ←− ·R
⊆	{ by hypothesis}
γ	δ
←− ·R· ←−
⊆	{ by hypothesis}
R· ←α− · ←δ−


Finally, for an arbitrary relator F,
Lemma 4.8 (F-monotonicity) If γ	α  then
←−±R←−
γ	α
F
←−±FR F ←−	(34)

Proof.
γ	α
←−±R←−
≡	{ by definition of ±}
γ	α
←− ·R ⊆ R· ←−
⇒	{ F-monotonicity}

F(←− ·R
) ⊆ F(R· ←α−)

⇒	{ F distributes over composition}
γ ) · FR ⊆ FR · F ←α−

≡	{ by definition of ±}
F γ	α
←−±FR F ←−


Corollary 4.9 If γ	α  and β
δ	then

←−±R←−
( γ
←−±S←−
β	α	δ

←− × ←−) ±R×S (←− × ←−)	(35)
( γ	β	α	δ
←− + ←−) ±R+S (←− + ←−)	(36)

This calculus avoids the need to resort to complicated downward simulations. Instead, we just need to know that id is a downward simulation and order the transition relations by (converse of) inclusion.
Let’s see what this means. We know that the converse of inclusion is algorithmic refinement for entire relations [34,31]. It also seems reasonable to assume that we are dealing with entire relations, the totalized (transposed [34,30]) versions of every relation. So we have found a simple method of refinement over transition relations which justifies the option of doing coalgebraic refinement indirectly by downward simulation of transition relations.

An example
Consider the transition system S depicted below, whose transition relation is given by −α→.
s0   a  s1  a  · · · 
a	a
J	J 
'	'
0	1

Suppose one wants to calculate an implementation  γ
such that:

γ	α
−→⊆−→	(37)
corresponding to downward simulation id:
γ	α
−→ ·id ⊆ id· −→	(38)
that is, to the following inequation,
ц ≤id α	(39)
We assume that transition relations are entire (the obvious totalization is as- sumed), so the implementation is done by reduction of non-determinism. An obvi- ous implementation at the level of transition relations is obtained as follows,
γ	α	'



To transition relation	γ
−→ = −→ −{(si, si)|i ≥ 0}

one associates the obvious LTS R, a completely deter-

ministic one, depicted as follows:

s0   a  s1  a  · · · 


'	'
0	1
The implementation coalgebra ц, the power transpose of LTS R, is such that
.
ц · id ≤ F id · α	(40)
according to (38), Lemma 3.4 and F = УA × Id. Inequation (40) simplifies to:
.
ц ≤ α	(41)
since F id = id as F, is a functor, and preserves therefore identities.
Conclusion and Future Work
In this paper we have shown that coalgebraic refinement, for the generic inclusion order, as witnessed by a forward morphism or a backward morphism [26,7], is equiv- alent to relational (data) refinement [13,9], as witnessed by an upward simulation or a downward simulation, respectively. Related work includes comparisons between data (relational) refinement [13] and process refinement [18]. The most significant examples (see e.g. [11,10,14]) arise in the context of the unification between refine- ment in Z and in CSP.
We have also shown that a single complete rule for data refinement is enough to prove coalgebraic refinement (cf. the title of [15]). This is because an upward simulation h is equivalent to a downward simulation h◦. We defined a preorder ≤ over coalgebras, which witnesses the downward simulations, and proved that the corresponding preorder ± over transition relations admits structural reasoning and is monotonic relative to the main relational operators. Therefore, we don’t need to define complicated downward simulations. It is enough to note that id is a downward simulation and order the transition relations by (converse of) inclusion,
i.e. algorithmic refinement for entire relations [34,31].
In summary, downward simulation is the refinement concept which unifies alge- braic and coalgebraic implementation, and sequential and concurrent computation. However, our proofs are based on the generic inclusion preorder which is the great- est preorder admissible in coalgebraic refinement, id being the least one, cf. [26,7]. The prospect of extending these results to an arbitrary refinement preorder ≤ in the interval id ⊆≤⊆ (∈T\∈T) is a topic for future research.
On the other hand, there is no coalgebraic counterpart to the factorization of the standard algorithmic refinement partial order studied in [34,31], after the work of Groves [16]. Such a generalization is another topic for future research.

References
C. Aarts, R.C. Backhouse, P. Hoogendijk, E.Voermans, and J. van der Woude. A relational theory of datatypes, December 1992.
J. Adamek. Introduction to coalgebra. Theory and Applications of Categories, 14:157–199, 2005.

K. Backhouse and R.C. Backhouse. Safety of abstract interpretations for free,via logical relations and Galois connections. Science of Computer Programming, 15(1–2):153–196, 2004.
R.C. Backhouse. Mathematics of program construction, June 2004. With help and contributions by Marcel Bijsterveld and Henk Doornbos and Rik van Geldrop and Diethard Michaelis and Jaap van der Woude.
R.C. Backhouse, P. de Bruin, P. Hoogendijk, G. Malcolm, T.S. Voermans, and J. van der Woude. Polynomial relators. In 2nd Int. Conf. Algebraic Methodology and Software Technology (AMAST’91), pages 303–362. Springer LNCS, 1992.
L. S. Barbosa. Components as processes: An exercise in coalgebraic modeling. In S. F. Smith and C. L. Talcott, editors, FMOODS’2000 - Formal Methods for Open Object-Oriented Distributed Systems, pages 397–417. Kluwer Academic Publishers, September 2000.
L. S. Barbosa and J. N. Oliveira. Transposing partial components: an exercise on coalgebraic refinement.
Theor. Comp. Sci., 365(1-2):2–22, 2006.
R. Bird and O. de Moor. Algebra of Programming. Series in Computer Science. Prentice-Hall International, 1997. C.A.R. Hoare, series editor.
E. Boiten and W. de Roever. Getting to the bottom of relational refinement: Relations and correctness, partial and total. In R. Berghammer and B. M¨oller, editors, 7th International Seminar on Relational Methods in Computer Science (RelMiCS 7), pages 82–88. University of Kiel, May 2003.
E. Boiten and J. Derrick. Unifying concurrent and relational refinement. ENTCS, 70(3), 2002. REFINE02-The BCS FACS Refinement Workshop, Denmark July 2002.
C. Bolton, J. Davies, and J. Woodcock. On the refinement and simulation of data types and processes. In IFM, pages 273–292. Springer, 1999.
A. Cruz, L. Barbosa, and J. Oliveira. From algebras to objects: Generation and composition. Journal of Universal Computer Science, 11(10):1580–1612, 2005.
W. de Roever and K. Engelhardt. Data Refinement Model-Oriented Proof methods and their Comparison. Cambridge University Press, 1999. With the assistance of J. Coenen and K.-H. Buth and P. Gardiner and Y. Lakhnech and F. Stomp.
J. Derrick and E. Boiten. Relational concurrent refinement. Formal Aspects of Computing, 15(2- 3):182–214, 2003.
P. Gardiner and C. Morgan. A single complete rule for data refinement. Formal Aspects of Computing, 5(4):367–382, 1993.
L. Groves. Refinement and the Z schema calculus. ENTCS, 70(3), 2002. REFINE02-The BCS FACS Refinement Workshop, Denmark July 2002.
H. Peter Gumm. Elements of the general theory of coalgebras. Technical report, Lecture Notes for LUTACS’99, South Africa, 1999.
J. He. Process refinement. In J. McDermid, editor, The Theory and Practice of Refinement, pages 37–59. Butterworths, 1989.
U. Hensel and H. Reichel. Defining equations in terminal coalgebras. In E. Astesiano, G. Reggio, and
A. Tarlecki, editors, Recent Trends in Data Type Specification, pages 307–318. Springer Lect. Notes Comp. Sci. (906), 1995.
B. Jacobs. Object-oriented hybrid systems of coalgebras plus monoid actions. In M. Wirsing and
M. Nivat, editors, Algebraic Methodology and Software Technology (AMAST), pages 520–535. Springer Lect. Notes Comp. Sci. (1101), 1996.
B. Jacobs. Objects and classes, co-algebraically. In C. Lengauer B. Freitag, C.B. Jones and H.-J. Schek, editors, Object-Orientation with Parallelism and Persistence, pages 83–103. Kluwer Acad. Publ., 1996.
B. Jacobs. Behaviour-refinement of coalgebraic specifications with coinductive correctness proofs. In TAPSOFT’97: Theory and Practice of Software Development, pages 787–802. Springer Lect. Notes Comp. Sci. (1214), 1997.
B. Jacobs and J. Rutten. A tutorial on (co)algebras and (co)induction. EATCS Bulletin, 62:222–159, 1997.
Bart Jacobs. Exercises in coalgebraic specification. In R. Backhouse, R. Crole, and J. Gibbons, editors, Algebraic and Coalgebraic Methods in the Mathematics of Program Construction, pages 237–
280. Springer Lect. Notes Comp. Sci. (2297), 2002.

S. Meng and L.S. Barbosa. On refinement of generic state-based software components. In C. Rettray,
S. Maharaj, and C. Shankland, editors, 10th Int. Conf. Algebraic Methods and Software Technology (AMAST), volume 3116 of Lecture Notes in Computer Science, pages 506–520. Springer, Stirling, July 2004.
Sun Meng and L. S. Barbosa. Components as coalgebras: The refinement dimension. Theor. Comp. Sci., 351:276–294, 2005.
R. Milner. A Calculus of Communicating Systems. Lecture Notes in Computer Science, 92, 1980.
L. Moss. Coalgebraic logic. Ann. Pure & Appl. Logic, 96(1-3):277–317, 1999.
J.N. Oliveira. Software reification using the SETS calculus. In T. Denvir, C.B. Jones, and R.C. Shaw, editors, Proc. of the BCS FACS 5th Refinement Workshop, Theory and Practice of Formal Software Development, London, UK, pages 140–171. Springer-Verlag, 8–10 January 1992.
J.N. Oliveira and C.J. Rodrigues. Transposing relations: from Maybe functions to hash tables. In D. Kozen, editor, MPC’07: Seventh International Conference on Mathematics of Program Construction, 12-14 July, 2004, Stirling, Scotland, UK, volume 3125 of LNCS, pages 334–356. Springer, July 2004.
J.N. Oliveira and C.J. Rodrigues. Pointfree factorization of operation refinement. In FM’06: 14 International Symposium on Formal Methods, 21-27 August, 2006, McMaster University, Hamilton, Ontario, Canada, volume 4085 of Lecture Notes in Computer Science, pages 236–251. Springer, August 2006.
J. Power and H. Watanabe. An axiomatics for categories of coalgebras. In B. Jacobs, L. Moss,
H. Reichel, and J. Rutten, editors, CMCS’98, Elect. Notes in Theor. Comp. Sci., volume 11. Elsevier, March 1998.
H. Reichel. An approach to object semantics based on terminal co-algebras. Math. Struct. in Comp. Sci., 5:129–152, 1995.
C.J. Rodrigues. Foundations of Program Refinement by Calculation. PhD thesis, University of Minho, July 2008.
J. Roth, H. Tews, and B. Jacobs. The coalgebraic class specification language CCSL. Journal of Universal Computer Science, 7(2), 2001.
J. Rutten. Automata and coinduction (an exercise in coalgebra). In Proc. CONCUR’ 98, pages 194–
218. Springer Lect. Notes Comp. Sci. (1466), 1998.
J. Rutten. Universal coalgebra: A theory of systems. Theor. Comp. Sci., 249(1):3–80, 2000. (Revised version of CWI Techn. Rep. CS-R9652, 1996).
Daniele Turi and Jan Rutten. On the foundations of final coalgebra semantics: non-well-founded sets, partial orders, metric spaces. Mathematical Structures in Computer Science, 8(5):481–540, 1998.
U. Wolter. A coalgebraic introduction to csp. In Proc. of CMCS’99, volume 19. Elect. Notes in Theor. Comp. Sci., Elsevier, 1999.
