	Electronic Notes in Theoretical Computer Science 204 (2008) 99–110	
www.elsevier.com/locate/entcs
On Term-Graph Rewrite Strategies 1
Rachid Echahed2
CNRS, LIG Laboratory 46, avenue Felix Viallet 38000 Grenoble
France

Abstract
We tackle the problem of cyclic term-graph rewriting. We first revisit the classical algorithmic approach to term-graph rewriting by providing a definition of rewrite rules of the form lhs → rhs where the left- hand sides are term-graphs and the right-hand sides are sequences of actions. Such actions, which specify how to rewrite a term-graph in a stepwise manner, contribute to simplify substantially the definition of cyclic term-graph rewriting. Then we define a new class of term-graph rewrite systems which are confluent over the so-called admissible term-graphs. Finally, we provide an efficient rewrite strategy which contracts only needed redexes and give pointers to other results regarding optimal rewrite strategies of admissible term-graphs.
Keywords: Term-graphs, Graph Rewrite Systems, Rewrite Strategies.


Introduction
Graph transformation is a general framework which is having various applications in computer science [26,13,14]. In this talk, term-graph rewriting will be considered as the underlying operational semantics of rule-based (functional or logic) program- ming languages (e.g. [24,9,3,23]). We will focus on cyclic term-graphs transfor- mation. For acyclic term-graph rewriting, the reader may consult [25]. There are many reasons that motivate the use of (cyclic) term-graphs. They actually facilitate sharing of subexpressions which lead to efficient computations. They also allow one to go beyond the processing of first-order terms by handling efficiently real-world data-structures represented as cyclic graphs such as doubly-linked lists or circular lists, e.g. [8].
Computing with a term-graph rewrite system (tGRS) is not an easy task in general. Indeed, the classical properties of term rewriting systems (TRS) [27] can-

1 This work has been partly funded by the project ARROWS of the French Agence Nationale de la Recherche.
2 Email:Rachid.Echahed@imag.fr

1571-0661 © 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.03.056

not be lifted without any caution to tGRSs. One of these properties is confluence. Consider for example the rule F (a, a, x) → x where a is a constant and x is a variable. This rule, which constitutes an orthogonal TRS, generates a confluent rewrite relation over (finite or infinite) terms whereas it generates a non confluent rewrite relation over term-graphs (see, e.g., [17]). It is well-known that this source of non-confluence of tGRSs comes from the so-called “collapsing rules” in orthogo- nal tGRSs. A rewrite rule is collapsing if its right-hand side is a variable. However, collapsing rules are very often used in programming and thus cannot be prohibited in any programming discipline. Most of access functions are defined by means of collapsing rules such as :
car(cons(x, u)) → x
cdr(cons(x, u)) → u
left − tree(binTree(l, x, r)) → l right − tree(binTree(l, x, r)) → r

In practice, many programming languages are constructor-based, i.e., opera- tors called constructors, which are intended to construct data structures are dis- tinguished from operators called deﬁned operators which are defined by means of rewrite rules. In this paper, we follow this discipline and consider orthogo- nal constructor-based tGRSs. We first revisit the classical algorithmic approach to term-graph rewriting [5] by providing a definition of rewrite rules of the form lhs → rhs where the left-hand sides are term-graphs and the right-hand sides are sequences of actions. Such actions, which specify how to rewrite a term-graph in a stepwise manner, contribute to simplify substantially the definition of cyclic term-graph rewrite process.
Then, we investigate the rewrite relation over a particular class of term-graphs called admissible. An admissible term-graph is a term-graph whose cycles do not include defined functions. We give a sufficient (syntactic) condition which ensures that the set of admissible graphs is closed under rewriting and we show the con- fluence of admissible graph rewriting relation, even in the presence of collapsing rules.
The confluence of a rewrite relation allows one to evaluate expressions in a deterministic and efficient way by using rewrite strategies. Such strategies have been well investigated in the setting of finite and infinite orthogonal TRSs (e.g., [22,16,18]). In [1], a strategy that computes outermost needed redexes based on definitional trees has been designed in the framework of orthogonal constructor- based TRSs. We show how definitional trees can be useful to design an efficient strategy in presence of orthogonal constructor-based tGRSs. We particularly state that the resulting strategy is c-hyper-normalizing on the class of admissible graphs and develops shortest derivations.
This extended abstract is organized as follows. In the following section, we revisit the definition of term-graph rewrite systems. Section 3 introduces the class of admissible term-graphs and state the confluence property for admissible tGRSs. An efficient rewrite strategy is presented in Section 4. Concluding remarks are given

in Section 5.

Term-Graph Rewrite Systems
Term-graphs [5] extend first-order terms by allowing sharing and cycles. There are many ways to define term-graphs rewriting in the literature. We can distinguish two broad approaches : the algorithmic approaches (e.g., [5]) and the categorical approaches (e.g., [7,15]). In this section we define a class of term-graph rewrite systems, denoted tGRS. We define the shape of its rules as well as the rewriting process. We follow and revisit the algorithmic approach. Our rules are close to those used in the language Lean [6] augmented by local redirection of pointers. The categorical definition of tGRSs following the double-pushout approach can be found in [8].
We start by giving some preliminary technical definitions.
Definition 2.1 A many-sorted signature Σ = ⟨S, Ω⟩ consists of a set S of sorts and an S-indexed family of sets of operation symbols Ω =  s∈SΩs with Ωs =
 w∈S∗ Ωw→s. We shall write f : s1 ... sn → s whenever f ∈ Ωs1...sn→s and say that f is of sort s and rank s1 ... sn.
A term-graph is defined in this paper as a set of nodes and edges between the nodes. Each node may be labeled with an operation symbol or not. A node which is not labeled will act as a variable. Let N = s∈SNs, be an S-indexed family of countable sets of nodes. N is supposed to be fixed throughout the rest of the paper.
Definition 2.2 (Term-Graph)
A term-graph g over ⟨Σ, N⟩ is a tuple g = ⟨Ng, N Ω, Lg, Sg⟩ such that :
Ng is the set of nodes of g, i.e., Ng =  s∈S(Ng)s with (Ng)s ⊆ Ns.
N Ω is the subset of labeled nodes of g, N Ω ⊆ Ng
g	g
Lg, the labeling function of g, is an S-indexed family of functions associating an operation symbol to each labeled node of g, i.e., Lg = s∈S(Lg)s with (Lg)s : (N Ω)s → Ωs.
Sg, the successor function of g, is an S-indexed family of functions associating a (possibly empty) string of nodes to each labeled node of g, i.e., Sg = s∈S(Sg)s with (Sg)s : (N Ω)s → N∗ such that for every node n ∈ (Ng)s :
g	g
if (Lg)s(n) = f with f : s1 ... sk → s, then there exist n1,..., nk ∈ Ng such that (Sg)s(n) = n1 ... nk and ni ∈ (Ng)si for all i ∈ 1..k.
if (Lg)s(n) = c with c ∈ Ωε,s (c is a constant), then (Sg)s(n) = ε (i.e., n has
no successor). We write n ∈ Sg(m) if n is a successor of m.
We write ar(n) the arity of node n which is equal to the length of Sg(n). A rooted term-graph, noted gn, is a term-graph g with a distinguished node n (n ∈ Ng) called the root of g. n will be noted Rootg. Let g be a term-graph and n and m two nodes of g (n, m ∈ Ng), we write n ~g m iff m ∈ Sg(n). We will say that node m is reachable in g from node n iff n ~∗ g m. A rooted term-graph gn consists of and only of nodes reachable from the root n.

In the sequel, we will assume that all formulae we are considering are well-sorted, and thus drop subscripts related to the many-sorted framework.
As the formal definition of term-graphs is not very convenient to write examples, we recall below the linear notation [5] of term-graphs. In the following grammar, the variable A (resp. n) ranges over the set Ω (resp. U ) : 

TermGraph
::=
Node | Node + TermGraph

Node
::=	n:A(Node,. . . ,Node) | n:• | n

The root of a rooted term-graph defined by means of a linear expression is the first node of the expression. n:• means that node n is not labeled.
Definition 2.3 (Homomorphism) Let gn and gm be two rooted term-graphs. A
1	2
homomorphism h from gn to gm is a mapping h : Ugn → Ugm which preserves the
1	2	1	2
root, the labeled nodes and the successor functions, i.e., h(n) = m, h(U Ω ) ⊆ U Ω ,
n	m
1	2
and for each labeled node, p, in gn, Lgm (h(p)) = Lgn (p) and £gm (h(p)) = h∗(£gn (p))
1	2	1	2	1
where h∗ denotes the extension of h to strings (of nodes) deﬁned by h∗(p1 ... pk) = 
h∗(p1) ... h∗(pk).
In [5], a rewrite step consists of diffrents stages such as (i) the build phase, which consists mainly in adding, beside the term-graph to be reduced, an instance of the right-hand side of the considered rule, together with the right connections to already existing nodes (ii) redirection phase, which consists in performing possible required pointer redirections and (iii) garbage collection phase. Definition of stage
(i) is too technical and requires like stage (ii) a particular care in handling the names of nodes. In order to simplify the definition of rewrite steps, we will incorporate the actions required to reduce a term-graph directly in the right-hand sides of the rules. These actions are defined below.
Definition 2.4 (Actions) An action is one of the following forms. We omit to give sort constraints which are quite straightforward and thus assume that all con- structions are well-sorted.
a node definition or node labeling ''α : f (α1,..., αn)'' where α, α1,..., αn are nodes and f is a label of rank s1,..., sn. This means that α is labeled by f and α1 ... αn are the succesor nodes of α (£(α) = α1 ... αn).
an edge redirection or local redirection ''α  i β'' where α, β are nodes and i ∈ {1,..., ar(L(α))}. This is an edge redirection and means that the target of the “ith” edge outgoing α is redirected to point β.
a global redirection ''α  β'' where α and β are nodes. This means that all edges pointing α are redirected to point β.
The result of applying an action a to a term-graph g is denoted by a[g] and is deﬁned as the following term-graph g':
If a = α : f (α1,..., αn) then Ug' = Ug ∪ {α, α1,..., αn}, Lg' (α) = f, Lg' (β) = Lg(β) if β /= α, and £g' (α) = α1 ... αn, £g' (β) = £g(β) if β /= α. ∪ denotes classical union.

If a = α  i β then Ug' = Ug, Lg' = Lg, and if £g(α) = α1 ... αi ..., αn then
£g' (α) = α1 ... αi−1βαi+1 ..., αn and for any node γ we have £g' (γ) = £g(γ) iff
γ /= α.
If a = α  β then Ug' = Ug, Lg' = Lg and for all nodes δ such that α occurs in
£g(δ), i.e., £g(δ) = α1 ... αi ... αn then £g' (δ) = α1 ... αi−1βαi+1 ... αn and for any node γ we have £g' (γ) = £g(γ) iff α does not occur in £g(γ)
The application of an action a to a rooted term-graph gn is a rooted term-graph g'm
such that g' = a[g] and root m is deﬁned as follows :
m = n if a is not of the form n  p.
m = p if a is of the form n  p.
The application of a sequence of actions u to a (rooted) term-graph g is defined inductively as follows : u[g] = g if u is the empty sequence and u[g] = u'[a[g]] if u = a.u' where . is the concatenation operation.
Example 2.5 Let G = n : f (m1, m2, m3).  Let H1 = m1 : h(m1)[G].  Then H1 = n : f (m1 : h(m1), m2, m3). Let H2 = n  2 m1[H1]. Then H2 = n : f (m1 : h(m1), m1, m3). Let H3 = m1   m3[H2]. Then H3 = n : f (m3, m3, m3)+m1 : h(m3).
Definition 2.6 (Node Constraint) A node constraint is a (possibly empty) con-
junction of disequations between nodes:  n  (αi /=. βi). A substitution σ : U → U
is a solution of a constraint φ =  n  (αi /=.  βi) iff for any i ∈ [1..n], we have
σ(αi) /= σ(βi). We denote by sol(φ) the set of solutions of φ.
Definition 2.7 (Rule) A term-graph rewrite rule is an expression of the form [l | c] → r where r is a sequence of actions, c is a constraint and l is a rooted term-graph s.t. for any node α occurring in l, we have Yootl ~∗ l α (i.e. any node occurring in the left-hand side must be reachable from the root Yootl. A rule ρ2 is said to be a variant of a rule ρ1 iff ρ2 is obtained from ρ1 by (one-one) renaming all the nodes in ρ1. A term-graph rewrite system (tGRS ) is a set of term-graph rewrite rules.
Notice that classical first-order term rewrite systems are tGRSs. A term rewrite rule g → d can be easily presented as a term-graph rewrite rule of the form [g | c] → r where the constraint c is empty (true) and r consists of actions which construct the term d followed by the action Yootg  Yootd.
Example 2.8 As noticed above, any term rewrite system can be seen as a term- graph rewrite system. Below, we give some examples which illustrate the use and the benefit of pointer redirections. We define four functions length, reverse, eq and fib. The first function computes the length of a circular list, reverse performs the so-called in-situ list reversal, eq defines an equality operator over natural numbers. eq yields true at once if its arguments are located at the same place. The function fib defines the classical Fibonacci function, but requires a linear number of additions (+).
Length of a circular list :
r : length(p : •) → r : length'(p, p)

r : length'(p1 : cons(n : •, p2 : •), p2) → r : s(0)
[r : length'(p1 : cons(n : •, p2 : •), p3 : •) | p2 /=.

p3] → r : s(q); q : length'(p2, p3)


In-situ list reversal :
: reverse(p : •) → o : reverse'(p, q : nil)
: reverse'(p1 : cons(n : •,q : nil), p2 : •) → p1  2 p2; o  p1
: reverse'(p1 : cons(n : •, p2 : cons(m : •, p3 : •), p4 : •)) → p1  2 p4; o  1
p2; o  2 p1

Equality over naturals :
p : eq(n : •, n) → q : true; p  q
[p : eq(n : 0,m : 0) | n /=. m] → q : true; p  q

[p : eq(n : succ(n' : •),m : succ(m' : •)) | n /=.
m] → p  1 n'; p  1 m'

p : eq(n : succ(n' : •),m : 0) → q : false; p   q
p : eq(n : 0,m : succ(m' : •)) → q : false; p  q

Fibonacci function (numbers) :
r : fib(p : 0) → r : 0 
r : fib(p : succc(0)) → r  p
r : fib(p : succc(succ(n))) → r : f (p, q : succ(0); u : 0)
r : f (p : succc(succ(0)), q, u) → r : +(q, u)
r : f (p : succc(v : succ(succ(n))), q, u) → w : +(q, u); r  1 v; r  2 w; r  3 q

Definition 2.9 (Matching) Let [l | c] → r be a rewrite rule and gn a rooted term- graph. We say that the left-hand side [l | c] matches the term-graph gn at node p, and noted [l | c] ≤ gp iff p is reachable from n (i.e. n ~∗ g p) and there exists a homomorphism, also called matcher, h from l to gp, i.e. h : Ul → Ug such that h(Yootl) = p and h is a solution of constraint c, i.e., h ∈ sol(c)
Definition 2.10 (Rewrite Step) Let ρ be the rewrite rule [l | c] → r and gn be
a rooted term-graph. We say that gn rewrite to gm at node p by using the rule
ρ iff there exists a matcher h : l → gp which is a solution of constraint c and
gm = h(r)[gn]. We write gn →[p, [l|c]→r] gm or simply gn → gm.
1	1	1
One of the main advantages of the class of term-graph rewrite systems described above (see also [8] for a definition of the same class following the categorical double- push out approach) is the ability to define in a natural way, rule-based programs with good space and/or time complexities, thanks to pointer redirection capabili- ties. Unfortunately, the expressiveness of this class has a cost : unlike term rewrite system, the property of confluence is no more ensured for orthogonal tGRSs. There- fore, defining functions (i.e., computing unique normal forms) by means of tGRSs necessitates, in general, to endow reducible term-graphs with some control over re- ducible sub-expressions. Examples of such controls are the annotations introduced in [19] or priorities over the nodes of [12]. These controls are somewhat close in spirit to the sequential ordering of instructions in imperative programs. Another alternative to recover confluence of rewriting consists in considering a sub-class of

term-graphs. This is the subject of the next section.
Admissible Term-Graphs
Computing with general cyclic term-graphs is not such an easy task even in presence of orthogonal rewrite systems. In this section we introduce the class of admissible term-graphs [9] for which confluence results can be stated and efficient strategies can be designed. This class is inspired from the imperative style of programming where defined procedures and functions operate over data-structures built using particular constructors such as records, pointers etc. and where cyclic expressions such as n : fact(n), n : tail(n) or n : +(n, n) are meaningless.
Admissible term-graphs are defined in the context of constructor-based signa- tures.
Definition 3.1 (Constructor-based Signature) A constructor-based signature Σ, is a triple Σ = ⟨S, C, Ð⟩ such that S is a set of sorts, C is an S-indexed family of sets of constructor symbols, Ð is an S-indexed family of sets of defined operations, such that C∩ Ð = ∅ and ⟨S, C Ð⟩ is a signature.
Definition 3.2 (admissible rooted term-graph [9,10]) A rooted term-graph gn is admissible iff for all nodes m, labeled by a deﬁned operation (i.e., Lgn (m) ∈ Ð), m is not reachable from itself (i.e., m does not belong to a cycle m ~/ ∗ g m).
Definition 3.3 (admissible tGRS) Let SP = ⟨Σ, Y⟩ be a constructor-based tGRS. SP is called admissible iff for all rules [l | c] → r in Y the following condi- tions are satisﬁed
l is an admissible term-graph such that only the root of l is labeled by a deﬁned symbol (i.e., Ll(Yootl) ∈ Ð) and the remaining labeled nodes are labeled by constructor symbols.
for all global (respectively, local) redirections of the form p  q (respectively,
p  i q for some i), occurring in the right-hand side r, we have p = Rootl and
q /= Rootl.
for all actions of the form α : f (β1,..., βn), for all i ∈ 1..n, βi /= Rootl
the set of actions of the form α : f (β1,..., βn), appearing in r, do not construct a cycle consisting only of newly introduced nodes in r and including a node labeled with a deﬁned operation. If we note ~r the reachability over the new nodes introduced in r, this condition could be speciﬁed as : for all nodes, α, introduced in r and labeled by a deﬁned operation, α ~/ ∗ r α.
Example 3.4 Examples mentioned in Example 2.8 but the list reversal rules are admissible.
The following proposition states that the class of admissible term-graphs is closed under the rewrite relation induced by an admissible tGRS.
Proposition 3.5 (Closure of admissible term-graphs [9]) Let SP = ⟨Σ, Y⟩
be an admissible tGRS and gn an admissible rooted term-graph. If gn rewrites to

qm via a rewrite rule in Y, then qm is also an admissible rooted term-graph.
Proposition 3.6 (Confluence of weakly orthogonal admissible tGRS [10]) Let SP = ⟨Σ, Y⟩ be a weakly orthogonal admissible tGRS (i.e., if two rules [l1 | c1] → r1 and [l2 | c2] → r2 in Y overlap, then the instantiated right-hand sides produce the same graph up to renaming of nodes). Then SP is confluent (up to renaming of nodes) over the set of admissible term-graphs. That is to say, for all rooted ad-

missible term-graphs gn, gn' , gm and gm' such that gn and gn'
are identical up to

1	2	3	4	1	2
renaming of nodes (gn ∼ gn' ), g  →∗ gm and g  →∗ gm' , there exist two admissible
1	2	1	3	2	4
graphs go and go' such that gm →∗ go, gm' →∗ go' and go ∼ go' .
5	6	3	5	4	6	5	6
Thanks to the confluence of the rewrite relation over admissible term-graphs, stated above, we proposed efficient rewrite strategies which compute only needed derivations. This is the object of the next section.

Efficient Reduction of Admissible Term-graphs
Rewrite strategies are often used in order to reduce the search space generated by a rewrite relation. Several rewrite strategies have been proposed in the literature in the framework of term rewrite systems (see, e.g., [27,16,20]).
In this talk, we will present a sequential rewrite strategy designed to reduce cyclic admissible term-graphs. This strategy contracts only needed outermost redexes and is c-hypernormalizing. This strategy can also be extended to an optimal parallel outermost rewrite strategy. We first introduce some vocabulary.
Definition 4.1 (Strategy)
Let SP = ⟨Σ, Y⟩ be an admissible tGRS. A (sequential) graph rewriting strategy is a partial function £ which takes an admissible graph g and returns a pair (p, R) such that p is a node of g, R is a rewrite rule of Y and g can be rewritten at node p with rule R. We write g →S g' and speak of an £-step from g to g' whenever

£(g) = (p, R) and g →
[p, R]
g'.
→∗ S denotes the reflexive and transitive closure of

→S and we speak of an £-derivation from g to g' whenever g →∗ S g'.
A strategy £ is c-normalizing iff for all admissible graph g admitting a constructor
normal form c, if g →∗ c, then there exists a constructor graph c' such that g →∗ S c'
and c' ∼ c.
A strategy £ is c-hyper-normalizing iff for all admissible graphs g admitting a con- structor normal form c, any derivation D starting with g which uses inﬁnitely many times £-steps ends with a constructor normal form c' such that c ∼ c'.
Definition 4.2 (Constructor Path) We will say that a node p is reachable from a node n0 in a term-graph g through a constructor path iff there exists a path in g, say n0 ~g n1 ~g ... ~g nk ~g p such that, for all i ∈ 0..k, Lg(nj) is a constructor symbol (∈ C).
Definition 4.3 (needed node, outermost redex) Let SP = ⟨Σ, Y⟩ be an ad-
missible tGRS, gn and gm two term-graphs and B = gn →∗ gm a rewrite derivation.
1	2	1	2
A node q labeled with a deﬁned operation in gn and reachable from the root n is a

residual node by B if q remains reachable from the root m in gm. Then, we call
descendant of gq the rooted term-graph gq. A node q in g is needed iff in every
rewriting derivation from g to a constructor normal form, a descendant of gq is rewritten at its root q. A node q labeled with a deﬁned operation in gn is an outer- most node of gn iff q = n or q is reachable from n through a constructor path. A redex u rooted by q in gn is an outermost redex iff q = n or q is reachable from n through a path p0 ~gn p1 ~gn ... ~gn pk such that p0 = n, pk = q and gpi is not a redex for all i ∈ 0..(k − 1).
Remark :  The notions of outermost node and outermost redex are well-defined in the framework of admissible graphs : if p and q are two nodes of an admissible graph labeled with defined operations and such that there exists a path from p to q (i.e., p is outer than q), then, by definition of admissible graphs, there is no path from q to p.
Our strategy is based on the notion of definitional trees introduced by Antoy
[1] and are defined below. Nevertheless, our definition is a bit different from the original one proposed in [1] or those used in the context of graph rewriting [3,9,10]. The main difference comes from the use of branch nodes. We actually introduce the possibility to have some sharing in the left-hand sides of the rules. For that purpose, we distinguish in the definition below between position.branch and share.branch nodes of a definitional tree. position.branch corresponds to the branch nodes in [1] whereas share.branch gives another possibility to specialize patterns according to their topological shapes.
Definition 4.4 (Definitional tree) Let SP = ⟨Σ, Y⟩ be an admissible tGRS. A tree T is a partial definitional tree, or pdt, with pattern π | C iff one of the following cases holds :
T = rule([π | C] → r), where [π | C] → r is a variant of a rule of Y.
T = position.branch([π | C], o, T1,..., Tk), where o is not a labeled node of π, o is of sort s, c1,..., ck (k > 0) are different constructors of the sort s and for all j ∈ 1..k, Tj is a pdt with pattern π[o ← p : cj(o1 : •,..., on : •)], such that n is the number of arguments of cj and p, o1,..., on are new nodes.
T = share.branch([π | C], T1, T2), where T1 is a pdt with pattern [π | C ∧ n /=. m]
such that n and m are nodes occurring in π and the constraint n /=. m does not
occur in C and T2 is a pdt with pattern [π' | C] such that π' is obtained from π
by collapsing the two nodes n and m (and their successors). I.e. π' is obtained
by encoding the constraint n =. m into π.
We write pattern(T ) to denote the pattern argument of a pdt.
A definitional tree T of a deﬁned operation f is a finite pdt with a pattern of the form [p : f (o1 : •,..., on : •) | true], also denoted by p : f (o1 : •,..., on : •), where n is the number of arguments of f, p, o1,..., on are new nodes, and for every rule [l | C] → r of Y, with l of the form f (g1,..., gn), there exists a leaf rule([l' | C'] → r') of T such that [l' | C'] → r' is a variant of [l | C] → r. An inductively sequential tGRS is an admissible tGRS such for every deﬁned function, f, there exists a deﬁnitional

tree of f.
Example 4.5 The reader may verify that the examples mentioned in Example 3.4 are all inductively sequential term-graph rewrite systems.
Definition 4.6 (A term-graph rewrite strategy Φ) Let SP = ⟨Σ, Y⟩ be an inductively sequential tGRS and gn a rooted term-graph. Φ is the partial function deﬁned by Φ(gn) = ϕ(gp, Tf ), where p is reachable from root n through a constructor path in gn, p is labeled with a deﬁned operation f and Tf is a deﬁnitional tree of f. Let gn be a rooted term-graph such that Lgn (n) ∈Ð (i.e. the root n is labeled with a deﬁned operation) and T a pdt such that pattern(T ) ≤ gn. We deﬁne the partial function ϕ :


⎪	[π' | C'] → r' is a variant of [π | C] → r ;


⎪	pattern(Ti) ≤ gn
⎪

for some i ∈ 1..2 ;



ϕ(gn, T ) = ⎪⎨

pattern(Ti) ≤ gn for some i ∈ 1..k ;


[π | C] matches gn at the root n by homomorphism h : π → g,
⎪	h(o) is labeled with a deﬁned operation f (in g),
⎪	T ' is a deﬁnitional tree of f and
⎪	ϕ(gh(o), T ') = (p, R).
Proposition 4.7 Let SP = ⟨Σ, Y⟩ be an inductively sequential tGRS, f a deﬁned operation, Tf a deﬁnitional tree of f, and gn a rooted term-graph whose root is labeled with f (i.e. Lgn (n) = f). If ϕ(g, Tf ) = (p, R) , then (i) in every rewrite derivation from gn to a constructor-rooted term-graph, a descendant of gp is rewritten at the root, in one or more steps, into a constructor-rooted term-graph; (ii) gp is a redex of g matched by the left-hand side of R; (iii) gp is an outermost redex of gn; (iv) if ϕ(gn, T ) is not deﬁned, then gn cannot be rewritten into a constructor-rooted term-graph.
Proposition 4.8 Let SP = ⟨Σ, Y⟩ be an inductively sequential tGRS, and gn a rooted admissible term-graph. If Φ(g) = (p, R), then gp is an outermost needed redex of gn and gn can be rewritten at node p with rule R. If Φ(g) is not deﬁned, then gn cannot be rewritten into a constructor term-graph.
Proposition 4.9 The strategy Φ is c-hyper-normalizing strategy (and thus c-nor- malizing).

Graph rewriting does not duplicate data. Thus the number of rewrite steps which are necessary to compute a constructor normal form may be optimized. We obtain the following result for the strategy Φ.
Theorem 4.10 Let g be an admissible graph and c a constructor graph such that
there exists a rewrite derivation g →∗ c. Then there exists a constructor graph c'
with c' ∼ c such that the length of the Φ-derivation g →∗ Φ c' is less (or equal) to the
length of the derivation g →∗ c.
Conclusion
We characterized the class of admissible term-graphs. For this class, we showed that the property of confluence of (cyclic) term-graph rewriting relation, induced by weakly orthogonal constructor-based tGRSs, can be recovered, even in the presence of collapsing rules. This result leads us to discover an efficient rewrite strategy for inductively sequential term-graph rewrite systems. This strategy, which has been defined precisely, is c-normalizing and optimal for the class of admissible term- graphs. In [21], a lazy graph rewriting strategy close to ours is described, namely the annotated functional strategy, which combines the discriminating position strategy
[24] and rewriting with priority [4]. To our knowledge, no formal result has been proved regarding this strategy.
Our strategy has been successfully extended to parallel rewriting in presence of weakly orthogonal rewrite systems [10]. Its has also been extended in order to develop needed narrowing steps [11,9]. Recently, the framework presented in this paper has been extended in order to deal with non deterministic functions in declarative (functional and logic) languages [3,2]. We are currently investigating new extensions of the presented strategy in a more general setting like term-graphs with priority [12].

References
S. Antoy. Definitional trees. In Proc. of the 4th Intl. Conf. on Algebraic and Logic programming, pages 143–157. Springer Verlag LNCS 632, 1992.
S. Antoy and B. Brassel. Computing with subspaces. In Proc. of the 9th International ACM SIGPLAN Symposium on Principles and Practice of Declarative Programming (PPDP07), pages 121–130. ACM, 2007.
S. Antoy, D. W. Brown, and S.-H. Chiang. Lazy context cloning for non-deterministic graph rewriting.
Electr. Notes Theor. Comput. Sci., 176(1):3–23, 2007.
J. Baeten, J. Bergstra, and J. Klop. Term rewriting systems with priorities. In Proc. of Conference on Rewriting Techniques and Applications, pages 83–94, Bordeaux, 1987. Springer Verlag LNCS 256.
H. Barendregt, M. van Eekelen, J. Glauert, R. Kenneway, M. J. Plasmeijer, and M. Sleep. Term graph rewriting. In PARLE’87, pages 141–158. Springer Verlag LNCS 259, 1987.
H. P. Barendregt, M. C. J. D. van Eekelen, M. J. Plasmeijer, J. R. W. Glauert, R. Kennaway, and M. R. Sleep. Lean: an intermediate language based on graph rewriting. Parallel Computing, 9(2):163–177, 1989.
A. Corradini, U. Montanari, F. Rossi, H. Ehrig, R. Heckel, and M. L¨owe. Algebraic approaches to graph transformation - part I: Basic concepts and double pushout approach. In Handbook of Graph Grammars, pages 163–246, 1997.

D. Duval, R. Echahed, and F. Prost. Modeling pointer redirection as cyclic term-graph rewriting.
Electr. Notes Theor. Comput. Sci., 176(1):65–84, 2007.
R. Echahed and J. C. Janodet. Admissible graph rewriting and narrowing. In Proc. of Joint International Conference and Symposium on Logic Programming (JICSLP’98), pages 325–340. MIT Press, June 1998.
R. Echahed and J.-C. Janodet. Parallel admissible graph rewriting. In Recent Trends in Algebraic Development Techniques, 13th International Workshop, WADT ’98, Lisbon, Portugal, April 2-4, 1998, Selected Papers, volume 1589 of Lecture Notes in Computer Science, pages 122–137. Springer, 1999.
R. Echahed and J.-C. Janodet. Completeness of admissible-graph collapsing narrowing. In Proceedings of the Joint APPLIGRAPH/GETGRATS Workshop on Graph Transformation Systems (GRATRA), pages 123–132, Berlin, March 2000.
R. Echahed and N. Peltier. Non strict confluent rewrite systems for data-structures with pointers. In Term Rewriting and Applications, 18th International Conference, RTA 2007, Paris, France, June 26-28, 2007, Proceedings, volume 4533 of Lecture Notes in Computer Science, pages 137–152. Springer, 2007.
H. Ehrig, G. Engels, H.-J. Kreowski, and G. Rozenberg, editors. Handbook of Graph Grammars and Computing by Graph Transformations, Volume 2: Applications, Languages and Tools. World Scientific, 1999.
H. Ehrig, H.-J. Kreowski, U. Montanari, and G. Rozenberg, editors. Handbook of Graph Grammars and Computing by Graph Transformations, Volume 3: Concurrency, Parallelism and Distribution. World Scientific, 1999.
A. Habel, J. Muller, and D. Plump. Double-pushout graph transformation revisited. Mathematical Structures in Computer Science, 11, 2001.
G. Huet and J.-J. L´evy. Computations in orthogonal term rewriting systems. In J.-L. Lassez and
G. Plotkin, editors, Computational logic: essays in honour of Alan Robinson. MIT Press, Cambridge, MA, 1991. Previous version: Call by need computations in non-ambiguous linear term rewriting systems, Technical Report 359, INRIA, Le Chesnay, France, 1979.
J. R. Kennaway, J. K. Klop, M. R. Sleep, and F. J. D. Vries. On the adequacy of graph rewriting for simulating term rewriting. ACM Transactions on Programming Languages and Systems, 16(3):493– 523, 1994. Previous version: Technical Report CS-R9204, CWI, Amsterdam, 1992.
J. R. Kennaway, J. K. Klop, M. R. Sleep, and F. J. D. Vries. Transfinite reduction in orthogonal term rewriting systems. Information and Computation, pages 18–38, 1995.
R. Kennaway. Implementing term rewrite languages in dactl. Theor. Comput. Sci., 72(2&3):225–249, 1990.
J. W. Klop and A. Middeld¨orp. Sequentiality in orthogonal term rewriting systems. Journal of Symbolic Computation, pages 161–195, 1991.
P. Koopman, J. Smetsers, M. van Eekelen, and M. Plasmeijer. Graph rewriting using the annotated functional strategy. In R. Sleep, R. Plasmeijer, and M. van Eekelen, editors, Term Graph Rewriting: Theory and Practice, chapter 23, pages 317–332. John Wiley, New York, 1993.
M. J. O’Donnell. Computing in Systems Described by Equations. Springer Verlag LNCS 58, 1977.
M. J. Plasmeijer. Clean : a programming environment based on term graph rewriting. Technical report, 1995. On the Web : http://www.elsevier.nl/locate/tcs.
R. Plasmeijer and M. van Eekelen. Functional Programming and Parallel Graph Rewriting. Addison- Wesley, 1993.
D. Plump. Term graph rewriting. In H. Ehrig, G. Engels, H. J. Kreowski, and G. Rozenberg, editors, Handbook of Graph Grammars and Computing by Graph Transformation, volume 2, pages 3–61. World Scientific, 1999.
G. Rozenberg, editor. Handbook of Graph Grammars and Computing by Graph Transformations, Volume 1: Foundations. World Scientific, 1997.
Terese. Term Rewriting Systems, volume 55 of Cambridge Tracts in Theoretical Computer Science. Cambridge University Press, 2003.
