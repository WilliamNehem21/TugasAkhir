

Electronic Notes in Theoretical Computer Science 237 (2009) 3–21
www.elsevier.com/locate/entcs

A Transformational Approach to Prove Outermost Termination Automatically
Matthias Raffelsieper1
Department of Computer Science, TU Eindhoven, P.O. Box 513, 5600 MB Eindhoven, The Netherlands
Hans Zantema2
Department of Computer Science, TU Eindhoven, P.O. Box 513, 5600 MB Eindhoven, The Netherlands
Institute for Computing and Information Sciences, Radboud University Nijmegen, P.O. Box 9010, 6500 GL Nijmegen, The Netherlands

Abstract
We present transformations from a generalized form of left-linear TRSs, called quasi left-linear TRSs, to TRSs such that outermost termination of the original TRS can be concluded from termination of the trans- formed TRS. In this way we can apply state-of-the-art termination tools for automatically proving outermost termination of any given quasi left-linear TRS. Experiments show that this works well for non-trivial ex- amples, some of which could not be automatically proven outermost terminating before. Therefore, our approach substantially increases the class of systems that can be shown outermost terminating automati- cally.

Introduction
A lot of work has been done on automatically proving termination and innermost termination. However, also termination with respect to the outermost strategy makes sense. For instance, this is the standard strategy in the functional program- ming language Haskell [11], and it can be specified in CafeOBJ [4] and Maude [2]. We will focus on the most general variant of the outermost strategy: reducing a redex is always allowed if it is not a proper subterm of another redex. Termination with respect to this strategy we shortly call outermost termination. This is different from the approaches for proving termination of Haskell presented in [7,16], which feature proving termination for a specific set of terms (ground instantiations of a

1 Email: M.Raffelsieper@tue.nl
2 Email: H.Zantema@tue.nl

1571-0661/© 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.03.032

so-called start term), while we only do it for all terms. Another difference is that the language Haskell does not allow overlapping rules, i.e., there is at most one rule applicable for every term.
Let’s consider the following example. The infinite list 0 : 1 : 2 : 3 : ··· can be generated by applying the non-terminating rule
from(x) → x : from(s(x))
to the start term from(0). If we want to check for overflow, e.g., numbers should not be n or higher, we could add the rule
sn(x) : xs → overflow.

Now for sure the TRS remains non-terminating since it still contains the first non- terminating rule. But we expect the combined system to be outermost terminating. This is the kind of examples for which we want to prove outermost termination automatically.
Until now Cariboo [9] was the only tool having facilities for proving outermost termination. Its approach is a stand alone one, while our goal is to make use of the huge effort of the last years to improve the power of termination tools. For making use of the impressive power of termination tools, the natural approach is to make a transformation from TRSs to TRSs such that the modified termination property (in our case outermost termination) of the original TRS can be concluded from termination of the transformed TRS. In the past, a similar approach was successfully applied to context-sensitive termination [5] and liveness problems [8].
The Termination Problem DataBase (TPDB) [15] already contains 6 outermost examples that really require a consideration of the outermost strategy. If no strat- egy is regarded, then all of these examples are non-terminating. For these examples, both Cariboo and our presented transformation together with a termination prover for term rewrite systems without a strategy can prove outermost termination. As will be shown later, using the presented transformation we can prove outermost termination for systems where Cariboo fails to do so. Therefore, this approach increases the number of term rewrite systems that can be shown outermost termi- nating automatically. However, it is not the case that it supersedes Cariboo: There are also examples where Cariboo succeeds while the transformed TRS cannot be shown terminating by any of the termination provers that we tried.
The presented approach deals with ground outermost termination. We will see that when fixing the signature there may be a difference between outermost termination and ground outermost termination, but by adding fresh constants there is no difference any more. Therefore it is not a restriction to focus on ground outermost termination.
The crucial ingredient of our transformation is anti-matching: for L being the
left-hand sides of the given TRS, we need a set SL such that any term matches with a term in SL if and only if it does not match with a term in L. It turns out that if all terms in L are linear, then a finite set SL satisfying this requirement can easily

be constructed, while there are sets L containing non-linear terms such that every set SL satisfying this property is infinite. That’s why we restrict to the class of quasi left-linear TRSs, which are all TRSs where every left-hand side is an instance of a linear left-hand side. Clearly, this class also includes all left-linear TRSs.
Based on this anti-matching we give a straightforward transformation T1 such that every infinite outermost reduction with respect to any quasi left-linear TRS R gives rise to an infinite T1(R)-reduction. We experimented with several variants of the basic transformation and chose the most powerful one in our final definition of the transformation.
Using anti-matching we present two other transformations T2 and T3, based on irreducible contexts. Since these contexts can only capture the first level of nesting, this approach is inherently incomplete. However, experiments show that for some examples these transformations are successful, while the transformation T1 gives rise to a problem that is too hard for existing termination tools.
This paper is structured as follows: After introducing the used notations in Section 2, we present our basic transformation T1 and prove soundness in Section 3. Thereafter, we present our alternative transformations T2 and T3 using contexts in Section 4. In these two sections, we assume that we can construct a set of terms that match those terms not being matched by a left-hand side. This problem of anti-matching is treated in Section 5, which proves that our transformations can be applied automatically for quasi left-linear TRSs. In Section 6 we give a short description of our implementation of the transformations and present a number of examples. We conclude in Section 7.

Preliminaries
This section shall briefly introduce the notations used in this paper. For an intro- duction of term rewriting see for example [1,17].
We consider the set T (Σ, V) of all terms over a set V of variables and a finite, non-empty set Σ of function symbols, called signature, where each f ∈ Σ is associated with a natural number called its arity. If the arity of f ∈ Σ is n ∈ N, then we denote this by arity(f ) = n. Instead of T (Σ, ∅) we also write T (Σ), which we call the set of ground terms. For a term t ∈T (Σ, V) we write V(t) to denote the set of variables
occurring in t. For a non-variable term t = f (t1,..., tn) we say that f is the root of t, denoted by root(t). A term t ∈T (Σ, V) is called linear if every variable occurs at most once in t; we write Tlin(Σ, V) for the set of all linear terms in T (Σ, V).
A position of a term t ∈T (Σ, V) is a sequence of natural numbers, the set of all positions of a term t is denoted Pos(t). The empty sequence is denoted as ϵ. Such a position π ∈ Pos(t) identifies a subterm of t, which is written t|π. The term that we get from replacing the subterm t|π by another term s ∈T (Σ, V) is denoted t[s]π. A substitution σ : V → T (Σ, V) is written as σ = {x1 := t1,..., xm := tm}, which denotes the mapping σ(xi) = ti and σ(x) = x for all x /= xi and 1 ≤ i ≤ m. The set of all substitutions over Σ and V is denoted as SUB(Σ, V). The application of a substitution σ ∈ SUB(Σ, V) to a term t ∈ T (Σ, V) is denoted tσ and replaces

all variables by their corresponding terms. Such a term tσ is called an instance of t. Two terms s, t ∈ 7 (Σ, V) are said to unify, if a uniﬁer σ ∈ SUB(Σ, V) exists such that sσ = tσ. A term s ∈ 7 (Σ, V) is said to match a term t ∈ 7 (Σ, V), if a substitution σ ∈ SUB(Σ, V) exists such that sσ = t.
A standard property relating linearity and unification is the following.
Lemma 2.1 Let t, u ∈ 7lin(Σ, V) be two linear terms with V(t) ∩ V(u) = ∅ that do not unify. Then there is a position π ∈ Pos(t) ∩ Pos(u) such that t|π and u|π are no variables and root(t|π) /= root(u|π).
Proof (Sketch). We refer to [17, Section 7.7], where the standard Martelli- Montanari unification algorithm is given. For linear terms t, u ∈ 7lin(Σ, V) with V(t) ∩ V(u) = ∅ we have as invariant of the algorithm that every variable occurs at most once. Thus, the only way to get the result fail is by having two terms that have different root symbols.	 
A Term Rewrite System (TRS) is a set R ⊆ 7 (Σ, V) ×7 (Σ, V), where instead of (l, r) ∈ R we write l → r ∈ R. 3 The set lhs(R) of left-hand sides of a TRS R is defined as lhs(R) = {l | l → r ∈ R}. A TRS is called left-linear if l is linear for all l ∈ lhs(R) and we call it quasi left-linear if every l ∈ lhs(R) is an instance of a linear l' ∈ lhs(R). A term s ∈ 7 (Σ, V) rewrites to a term t ∈ 7 (Σ, V) with a rule l → r ∈ R at a position π ∈ Pos(s), denoted by s →l→r,π t, iff there exists a substitution σ ∈ SUB(Σ, V) such that s|π = lσ and t = s[rσ]π. The term s|π is called redex. Instead of s →l→r,π t we also write s →R,π t, s →R t, s →π t, or s → t if the term rewrite system R and/or the position π are clear from the context. If for a term s ∈ 7 (Σ, V) and a position π ∈ Pos(s) we have for all t ∈ 7 (Σ, V) that s /→R,π t holds, then we also write s /→R,π or s /→π.
A term s ∈ 7 (Σ, V) outermost rewrites to a term t ∈ 7 (Σ, V) with a rule l → r ∈ R at a position π ∈ Pos(s), denoted s —→o l→r,π t, iff s →l→r,π t and for all positions π' ∈ Pos(s) with π = π' π'' for some π'' ∈ N∗ with π'' /= ϵ we have that s /→R,π' .
A TRS R is called terminating (outermost terminating ), iff there is no infinite sequence t1, t2, t3,... ∈7 (Σ, V) of terms with ti →R ti+1 (ti —→o R ti+1) for all i ∈ N. A TRS R is called ground terminating (outermost ground terminating ), iff there is no infinite sequence t1, t2, t3 ... ∈ 7 (Σ) of ground terms such that ti →R ti+1 (ti —→o R ti+1) for all i ∈ N.
The following example shows that outermost termination for arbitrary terms may differ from outermost ground termination.
Example 2.2 Consider the following term rewrite system R over the signature Σ = {f, a, b}:

R = ⎧⎨
⎩

→	f(x, b)
→	a

3  Note that the standard restrictions l ∈/ V and V(r) ⊆ V(l) are not essential for our results.

For arbitrary terms we have the infinite outermost reduction
f(x, a) → f(x, b) → f(x, a) → · · ·
However, when instantiating x by any arbitrary ground term t ∈7 (Σ), then one of the three rules on the left is applicable at the root position. Hence, the reduction f(t, b) → f(t, a) is no longer an outermost reduction. In fact, the above term rewrite system is outermost ground terminating, as we will show later.
However, this difference only occurs when fixing the signature. It is easy to see that by replacing variables in any infinite outermost reduction by fresh constants, the result is an infinite outermost ground reduction. For quasi left-linear TRSs adding one fresh constant suffices. Hence, we may and shall restrict ourselves to outermost ground termination.
Finally, we want to remark on the restrictions mentioned above in Footnote 3: If we have a rule x → r ∈ R for some x ∈V then clearly the TRS R is not outermost terminating, since this rule can always be applied at the root position. However, the second restriction, V(r) ⊆ V(l), does not directly lead to non-outermost termina-
tion, a counterexample is the outermost terminating TRS R = {a → f(x), f(x) → b}.

The first Transformation
The idea of the first transformation is to only allow a reduction when a certain control symbol down marks the current redex. After having reduced a term, the control symbol is replaced by another control symbol up that is moved outwards. Only when the root of the term is encountered, then the control symbol is replaced by the down symbol again. In order to find the next outermost redex, the symbol down may only descend into subterms when no left-hand side is applicable to the term. For this purpose, we need a set SL such that its elements match exactly those terms that are not matched by a left-hand side. Such a set SL is called anti-matching, which is defined below.
Definition 3.1 A set SL ⊆ 7 (Σ, V) is called anti-matching w.r.t. a set L ⊆ 7 (Σ, V), iff the following holds for all ground terms t ∈7 (Σ):
/ ∃l ∈ L, τ ∈ SUB(Σ, V) : t = lτ ⇐⇒ ∃s ∈ SL,σ ∈ SUB(Σ, V) : t = sσ

Using such an anti-matching set, we can now formally define our transformation that implements the idea outlined above.
Definition 3.2 Let R be a TRS over a signature Σ and let SL ⊆ 7 (Σ, V) be an anti-matching set w.r.t. L = lhs(R).
Choose four fresh unary symbols top, up, down, block /∈ Σ, and let Σq = {fq | f ∈ Σ, arity(f ) > 0} be such that Σ ∩ Σq = ∅. The TRS T1(R) over the signature Σ ∪ Σq ∪ {top, up, down, block} is defined to consist of the following rules:
down(l) → up(r), for all rules l → r of R;

top(up(x)) → top(down(x));
down(f (t1,..., tn))	→	fq(block(t1),..., down(ti),..., block(tn)),	for	all
f (t1,..., tn) ∈ SL and all i ∈ {1,..., n};
fq(block(x1),..., up(xi),..., block(xn)) → up(f (x1,..., xn)), for all f ∈ Σ and all
i ∈ {1,..., n}, where arity(f ) = n and x1,..., xn are distinct variables.
For an infinite TRS R, we clearly have that T1(R) is infinite, too. The TRS T1(R) can also become infinite for a TRS R that is not quasi left-linear, since then an anti-matching set SL might be infinite. This is demonstrated in Section 5. For quasi left-linear TRSs however, we will prove the following theorem by giving a possible construction of a finite anti-matching set SL.
Theorem 3.3 For a quasi left-linear TRS R, there exists a ﬁnite, computable, and (up to variable renaming) unique set SL ⊆ 7lin(Σ, V) that is anti-matching w.r.t. L = lhs(R).
The proof of this theorem is given in Section 5, which deals with the general problem of anti-matching. However, soundness of the transformation does not de- pend on the finiteness of SL.
In the transformation, we introduce the already mentioned symbols down and
up to control the position of the next redex. The symbol top is used to denote the root position of the term, where the search of the next redex has to turn downwards again. The purpose of the symbol block is to disallow evaluations where an up symbol appears at the root position of a term without having applied a rule of the form down(l) → up(r). Furthermore, we create a new marked symbol fq for every function symbol f of the original rewrite system. This makes termination proofs easier, since it can be distinguished whether a symbol is above or below one of the control symbols.
An outermost rewrite step can be modelled by a sequence of steps in the trans- formed system. This is shown in the following lemma.
Lemma 3.4 Let R be a TRS over a signature Σ, let u, v ∈7 (Σ).

If u —→o R v, then down(u) →+
up(v).

Proof. Let u, v ∈7 (Σ) be two ground terms, let u —→o l→r,π v for some rule l → r ∈
R and some position π ∈ Pos(u). Induction is done over the length of π.
In case π = ϵ, we directly have the rule down(l) → up(r) ∈ T1(R), which shows the desired property.
Otherwise, let π = iπ' for some π' ∈ Pos(u|i) and let u = f (u1,..., un). Hence, u /→є and v = f (u1,..., ui−1, vi, ui+1,..., un) for some vi ∈ 7 (Σ). Since u /→є, we have u /= l'τ for all τ ∈ SUB(Σ, V) and all l' ∈ lhs(R). Hence, there is a term s ∈ SL in an anti-matching set SL w.r.t. L = lhs(R) and a substitution σ ∈ SUB(Σ, V) such that sσ = u.  Let s = f (s1,..., sn).  Then a rule down(f (s1,..., sn)) → fq(block(s1),..., down(si),..., block(sn)) ∈ T1(R) exists that is applicable to the term down(u) and therefore gives the reduction down(u) = down(f (u1,..., un)) → fq(block(u1),..., down(ui),..., block(un)).  For

the subterm ui we have ui —→l→r,π' vi. Here, the induction hypothesis is applica- ble and yields a reduction down(ui) →+ up(vi). When applying this together with the rule fq(block(x1),..., up(xi),..., block(xn)) → up(f (x1,..., xn)) ∈ T1(R) the desired result can be shown:
down(u) = down(f (u1,..., un)) →	fq(block(u1),..., down(ui),..., block(un))
→+ fq(block(u1),..., up(vi),..., block(un))
→	up(f (u1,..., ui−1, vi, ui+1,..., un)) = up(v)
 
Using the above lemma we can prove the main theorem which shows that the presented transformation is sound, i.e., from the termination of the transformed TRS the outermost ground termination of the original TRS can be concluded.
Theorem 3.5 Let R be a TRS over a signature Σ for which T1(R) is terminating. Then R is outermost ground terminating.
Proof. Assume R is not outermost ground terminating. Then there is an infinite outermost reduction t1 —→o R t2 —→o R ... for some ground terms t1, t2,... ∈7 (Σ). For
each ti —→o R ti+1 we have that down(ti) →+	up(ti+1) by Lemma 3.4. Due to the
rule top(up(x)) → top(down(x)) we obtain an infinite reduction in the transformed system T1(R),


top(down(t1)) →+	top(up(t2)) →T (R) top(down(t2)) →+
..., 

T1(R)	1	T1(R)
contradicting termination of T1(R).	 
Let us now remark on the situation when (arbitrary) outermost termination shall be considered, not just outermost ground termination. For a quasi left-linear TRS R over the signature Σ we create a new TRS R' which has the same rules as R, but now is defined to be over the signature Σ' = Σ ∪ {c}, where c ∈/ Σ is a fresh constant (i.e., it has arity 0). Then an infinite reduction t1 —→o R t2 —→o R ... for some terms
o	o
t1, t2,... ∈ 7 (Σ, V) implies that t1σ1 —→R' t2σ2 —→R' ... is an infinite reduction of
ground terms tiσi ∈7 (Σ) for substitutions σi = {x := c | x ∈ V(ti)} for i ∈ N. This holds, since no left-hand side of the rewrite system R' matches a subterm of tiσi which R does not match, because no left-hand side of R' contains the constant c. In the other direction, one can replace a symbol c in an infinite reduction w.r.t. R' by a fresh variable, giving an infinite reduction w.r.t. R. Therefore, we have that the term rewrite system R is outermost terminating, iff the term rewrite system R' is outermost ground terminating. Such a TRS R' can then be handled by our transformation to show outermost termination of R.
Other Transformations based on Contexts
There are examples for which the transformed TRS T1(R) cannot be proven ter- minating automatically. However, for some of these examples the transformations

presented in the following are successful. These transformations do not use sym- bols down and up to find the next redex, but only allow to rewrite a redex when a so-called anti-matching context is found. This notion of anti-matching contexts is given in the following definition.
Definition 4.1 For a set L of terms, a set CL ⊆ 7 (Σ, V  { }) is called a set of
anti-matching contexts w.r.t. L, iff
∈/ CL,
occurs exactly once in every term C ∈ CL, and
If for some t ∈ 7 (Σ) we have t|π = lσ for some l ∈ L, some σ ∈ SUB(Σ, V), and some π ∈ Pos(t), and t /= l'σ' holds for all l' ∈ L and all σ' ∈ SUB(Σ, V), then there is a C ∈ CL and a τ ∈ SUB(Σ, V { }) such that t = Cτ and for π' ∈ Pos(C) with C|π' =  we have that π = π' π'' for some π'' ∈ N∗.

Here, the third requirement is similar to the requirements for an anti-matching
set SL. Thus, we can define the set C' = {s[ ]i | s ∈ SL, 1 ≤ i ≤ arity(root(s))},
for which all of the above requirements are fulfilled, as can easily be checked. Using such a set of contexts, we now define another transformation T2.
Definition 4.2 For a TRS R over a signature Σ let CL be a set of anti-matching contexts w.r.t. L = lhs(R). We define a TRS T2(R) over the signature Σ  {top} that consists of the following rules:
top(l) → top(r) for all l → r ∈ R, and
C[l] → C[r] for all l → r ∈ R and all C ∈ CL.
It can easily be shown that T2 is a sound transformation, but we omit this for space reasons. When using the set C' , then the transformed TRS T2(R) of a TRS R is finite if R is both finite and quasi left-linear. The first requirement is obviously
needed. The second requirement stems from the construction of C' which relies on
the set SL. Here, we can observe from Theorem 3.3 that this set, and hence also the construction, can only be guaranteed to be finite if R is quasi left-linear.
One might wonder why in the construction of the set C' the “hole”  is always
introduced at the first argument level, and does not simply replace a variable of the term. Why this latter idea is not sound is illustrated in the next example.
Example 4.3 We consider the below TRS R over the signature Σ = {f, b}:

=	b	 →	f(f(b))	f(f(f(x)))	→	b f(b)	→	b
For L = lhs(R) we have that SL = {f(f(b))}, i.e., there are no variables in the only term contained in SL. Thus, when choosing CL = ∅ then the only rules to be considered are of the form top(l) → top(r). The TRS consisting of only these rules can be shown terminating. However, there exists the following infinite outermost

ground reduction, which shows that this choice of CL is unsound:
f(f(b)) —→o R f(b) —→o R b —→o R f(f(b)) —→o R ... 

It should be noted that CL = ∅ is not a set of anti-matching contexts w.r.t. L. This holds because the term f(f(b)) is irreducible at root position but is reducible at position π = 1. Hence, we have a violation of the third requirement of Definition 4.1.
The next example shows that the transformation T2 is incomplete, regardless of the set CL of anti-matching contexts.
Example 4.4 Consider the following TRS R:

=	f(h(x))	→	f(i(x))	i(x)	→	h(x) f(i(x))	→	a
When this TRS is transformed using the transformation T2, then the context f( ) must be considered, since for example the term f(f(h(x))) is not matched by any left-hand side of R, but it is reducible at the position π = 1. Thus, we have the rules f(f(h(x))) → f(f(i(x))) ∈ T2(R) and f(i(x)) → f(h(x)) ∈ T2(R). For these two rules we get the following infinite reduction:
f(f(h(x))) → f(f(i(x))) → f(f(h(x))) → ... 

However, the TRS R is outermost ground terminating, as can be shown using the transformation T1 of the previous section.
This example failed because we inserted the rule i(x) → h(x) into the context f( ), but such a reduction will never take place due to the left-hand side f(i(x)). An improvement of this transformation does not insert all rules into all contexts, but only those where an outermost reduction could possibly take place. Such an improvement is given in below, which again uses an anti-matching set SL.
Definition 4.5 Let R be a TRS over a signature Σ, let SL ⊆ 7 (Σ, V) be a set of anti-matching terms w.r.t. L = lhs(R). We define a TRS T3(R) over the signature Σ {top} which contains the following rules:
top(l) → top(r) for all l → r ∈ R, and
s[l]iμ → s[r]iμ for all s ∈ SL, all 1 ≤ i ≤ arity(root(s)), and all l → r ∈ R for which s and l are variable disjoint and s|i unifies with l with the most general unifier μ.
The above transformation T3 is still sound, i.e., from termination of a TRS T3(R) one can conclude outermost ground termination of R, but we again have to omit this proof for space reasons. Also for this transformation it can be observed that a finite TRS T3(R) is only achieved if the TRS R is finite and quasi left-linear.
Next we want to compare the transformations T2 and T3. For this purpose, we consider Example 4.4 again, which was the motivation for the transformation T3.

Example 4.6 (Transformed TRS T3(R) for Example 4.4) For this example we have that SL = {h(x), a, f(a), f(f(x))}.

T3(R) = ⎧⎪⎨
⎪⎩

As can be seen above, the rule f(i(x)) → f(h(x)) is not contained in the trans- formed TRS T3(R), which was the cause of T2(R) being non-terminating in Exam- ple 4.4. And indeed, the TRS T3(R) can be shown terminating automatically.
However, this improved transformation is still not complete, as demonstrated in the following example.
Example 4.7
=	from(x)	→	 x : (nil : from(s(x)) s(x) : xs	→	nil
Outermost ground termination of this example can again be shown automati- cally, using the transformation T1. However, we have that nil : xs ∈ SL. Thus, we have the rule nil : from(x) → nil : (x : (nil : from(s(x)))) ∈ T3(R). For this rule we can see that the underlined part of the right-hand side is again matched by the left-hand side of that rule, leading to an infinite reduction.

Anti-matching
We consider a term rewrite system R and a set L matching all terms that can be rewritten by R, for example L = lhs(R). For our transformations we have to find an anti-matching set SL that matches the terms which cannot be rewritten by R. Clearly, this is only depending on the left-hand sides of R. One can imagine that there are several possible sets that satisfy this condition. Our goal is to select the smallest such set and to be able to construct it finitely when this is possible.
In this section we consider the general problem of finding an anti-matching set. Only at the end of this section we restrict ourselves to linear terms, for which it will be shown that the minimal anti-matching set is finite and can be computed.
The problem of finding a set of terms that describe the complement of a set of terms is similar to the problem considered by Lassez and Marriot [14], where an explicit representation of a set is being searched that is described using counter ex-
amples. But their focus is on machine learning, therefore it is hard to directly apply their results. We also want to mention the concept of anti-patterns as introduced in [12]. This is more general since it allows to introduce negation of patterns at
any position in a term, while we are only interested in the negation of a complete pattern. However, this work is not applicable here, since we want a representation of a set that does not match a given term, while an anti-pattern matching problem is to decide whether an anti-pattern matches a single ground term.

The anti-matching problem is similar to the constrained substitutions used for outermost narrowing in [9]. A constrained substitution is a substitution together with disequations that constrain the outermost narrowing of subterms to those where no redex exists at a prefix position. An anti-matching set can be seen as explicit solution of such disequations. This is not required for the outermost nar- rowing in [9], where the implicit formulation is sufficient but must be considered throughout the proof.
Below, we first define a set S' of terms that satisfy the desired property. This set
is usually infinite and contains quite a number of redundant terms, i.e., terms that are already matched by other terms contained in S' . Thus, we define another set
SL that consists only of the minimal elements of S' w.r.t. an order that expresses
whether one term matches the other.
Definition 5.1 Let L ⊆7 (Σ, V) be a set of terms. On terms we define the preorder
≤ by
t ≤ u ⇐⇒ ∃σ : tσ = u
which induces the definition of its strict part to be

t < u ⇐⇒ t ≤ u ∧ ¬(u ≤ t).

Now SL is defined to be the set of minimal elements of the set of terms that do not unify with elements of L, i.e.,

' = {t ∈7 (Σ, V) | / ∃l ∈ L, σ, τ ∈ SUB(Σ, V) : lσ = tτ}

SL = {t ∈ S'
| / ∃u ∈ S'
: u < t}


One might wonder why unification is considered, while term rewriting is con- cerned with matching. This becomes clear when formulating what kind of terms we are looking for: the set of terms that match those terms which are not matched by left-hand sides. This means we have to consider two matchings at the same time, when assuming that the set of variables are disjoint then this gives rise to a unification problem.
As a next step we show that the set S' is closed under substitution. This is of
interest, since we want to consider the ground terms that are matched by a term contained in S' . Thus, it should be the case that every instantiation of a term from
' is also contained in S' , such that especially this holds for ground instances.
Lemma 5.2 {sσ ∈7 (Σ, V) | s ∈ S' ,σ ∈ SUB(Σ, V)} = S' .
L	L

Proof. “⊇”: Holds trivially for σ = id.
“⊆”: Let s ∈ S' ,σ ∈ SUB(Σ, V). Then sσ ∈ {sσ ∈ 7 (Σ, V) | s ∈ S' ,σ ∈
L	L
SUB(Σ, V)}. We have that lσ' /= sτ' for all l ∈ L and all substitutions σ',τ' ∈ SUB(Σ, V). Therefore, especially lσ' /= sστ' holds for all substitutions σ',τ' ∈ SUB(Σ, V). Hence, sσ ∈ S' .	 

The set SL is derived from the set S' by taking only the minimal elements of S'
w.r.t. the order >. These minimal elements exist since this order is well-founded, as for example mentioned in [10, Proposition 3.2].
Lemma 5.3 [10] The relation > from Deﬁnition 5.1 is well-founded.
This lemma can be proved rather straightforwardly for linear terms by counting the number of symbols. For non-linear terms, one must also consider variables being matched by more than one variable.
When removing larger elements from a set w.r.t. ≤, then all terms that are matched by removed terms are still being matched by some term in the set, as shown next. This will be used to show that SL still matches the same terms as S' .
Lemma 5.4 {uσ | u ∈ U, σ ∈ SUB(Σ, V)} = {uσ | u ∈ U ∪ U',σ ∈ SUB(Σ, V)} for every U, U' ⊆7 (Σ, V) with U' = {u' | ∃u ∈ U : u ≤ u'}.
Proof. “⊆”: trivial, since U ⊆ U ∪ U'.
“⊇”: Let u' ∈ U ∪ U', let σ' ∈ SUB(Σ, V). If u' ∈ U , then the property trivially holds. So let u' ∈ U' \ U . Then a u ∈ U exists such that u ≤ u', i.e., there is a substitution τ ∈ SUB(Σ, V) such that u' = uτ . Hence, u'σ' = uτσ' ∈ {uσ | u ∈ U, σ ∈ SUB(Σ, V)}.	 
For the set S' it should be intuitively clear that all terms that are not matched
by a term contained in L are matched by a term in that set. Using the above lemma, we can now show that this already holds for the set SL.
Lemma 5.5 {sσ ∈7 (Σ, V) | s ∈ SL,σ ∈ SUB(Σ, V)} = S' .
Proof. “⊆”: Since SL ⊆ S' , this holds due to Lemma 5.2.
“⊇”: Since > is well-founded due to Lemma 5.3, the existence of the minimal elements in SL is guaranteed. Thus, Lemma 5.4 shows the desired property.	 
This allows us to prove that the ground terms matched by SL are indeed those terms that are not matched by the set L.
Lemma 5.6 7 (Σ) \ {lσ ∈ 7 (Σ) | l ∈ L, σ ∈ SUB(Σ, V)} = {sσ ∈ 7 (Σ) | s ∈
SL,σ ∈ SUB(Σ, V)}.
Proof. This lemma is shown in two steps: First it is proven that {lσ ∈7 (Σ) | l ∈ L, σ ∈ SUB(Σ, V)}∩ {sσ ∈7 (Σ) | s ∈ SL,σ ∈ SUB(Σ, V)} = ∅ (showing “⊇”), and in the second step it is shown that 7 (Σ) = {lσ ∈ 7 (Σ) | l ∈ L, σ ∈ SUB(Σ, V)}∪ 
{sσ ∈7 (Σ) | s ∈ SL,σ ∈ SUB(Σ, V)} (showing “⊆”).
For the first step, let t ∈ {lσ ∈7 (Σ) | l ∈ L, σ ∈ SUB(Σ, V)}∩{sσ ∈7 (Σ) | s ∈
SL,σ ∈ SUB(Σ, V)}. Thus, there exist l ∈ L and σl ∈ SUB(Σ, V) such that t = lσl
and there exist s ∈ SL ⊆ S' and σs ∈ SUB(Σ, V) such that t = sσs. Putting this
together gives lσl = t = sσs, which is a contradiction to the definition of S' .
To show the second step, we observe that clearly {lσ ∈ 7 (Σ) | l ∈ L, σ ∈ SUB(Σ, V)} ∪ {sσ ∈ 7 (Σ) | s ∈ SL,σ ∈ SUB(Σ, V)} ⊆ 7 (Σ). So it remains to be shown that {lσ ∈ 7 (Σ) | l ∈ L, σ ∈ SUB(Σ, V)}∪ {sσ ∈ 7 (Σ) | s ∈ SL,σ ∈

SUB(Σ, V)} ≥ 7 (Σ). For that purpose, let t ∈ 7 (Σ) be an arbitrary ground term. In case there exist l ∈ L and σl ∈ SUB(Σ, V) such that lσl = t the property has been shown. Otherwise, we may assume that for all l ∈ L and all substitutions σ ∈ SUB(Σ, V) that satisfy lσ ∈ 7 (Σ) we have lσ /= t. Since t is a ground term, V(t) = ∅ holds. This means that for any substitution τ ∈ SUB(Σ, V) we have tτ = t. Furthermore, for every term t' ∈7 (Σ, V) with V(t') /= ∅ it holds that t /= t' which allows to conclude that t /= lσ' for all substitutions σ' ∈ SUB(Σ, V) where V(lσ') /= ∅. Putting this together, we get that for all substitutions σ, τ ∈ SUB(Σ, V)
it holds that lσ /= t = tτ . From the definition of S' we get t ∈ S' , and hence
t ∈ {sσ ∈7 (Σ) | s ∈ SL,σ ∈ SUB(Σ, V)} by Lemma 5.5.	 
In the following we restrict ourselves to sets L that only contain linear terms. It should be observed that this also covers the case of a quasi left-linear TRS R: for such a TRS we can define L to be the set of all linear left-hand sides of R and have that L still matches the same terms as lhs(R), due to Lemma 5.4. We want to show that for a linear set L the set SL is finite. For that purpose we need the depth of a term, which is defined as follows.
Definition 5.7 The depth of a term t ∈7 (Σ, V) is defined as depth(t) = 0 if t ∈V 
and depth(f (t1,..., tn)) = 1 + max{depth(t1),..., depth(tn)} for t = f (t1,..., tn).
The depth of a finite set T ⊆7 (Σ, V) is defined as the maximum over the depths of the terms it contains, i.e., depth(T ) = max{depth(t) | t ∈ T}.
Then, we have for example depth(f(x, y)) = 1, while depth(f(a, y)) = 2 for the signature Σ = {f, a}. Using this notion of depth, we can now prove the following lemma. It provides an upper bound on the depth of the terms contained in SL for sets L containing only linear terms.
Lemma 5.8 For a set L ⊆ 7lin(Σ, V) of linear terms we have that depth(s) ≤
depth(L) for all s ∈ SL.
Proof. Assume, there exists a s ∈ SL ⊆ S' with depth(s) > depth(L). Thus, we
have that sσ /= lτ for all l ∈ L and all substitutions σ, τ ∈ SUB(Σ, V). W.l.o.g. we may assume that V(s) and V(l) are disjoint for all l ∈ L. Lemma 2.1 shows that for every l ∈ L a position πl ∈ Pos(l) ∩ Pos(s) exists such that root(l|πÆ ) /= root(s|πÆ ).
By definition of depth(L), we have |πl| < depth(L). Let truncL(s) ∈ 7 (Σ, V) denote the term that is derived from s by replacing all subterms at positions of length depth(L) by fresh variables. By construction, we have depth(truncL(s)) =
depth(L), truncL(s) < s, and root(s|π) = root(truncL(s)|π) for all π ∈ Pos(s) with
|π| < depth(L). Hence, root(truncL(s)|πÆ ) = root(s|πÆ ) /= root(l|πÆ ), i.e., for all substitutions σ, τ ∈ SUB(Σ, V) we have truncL(s)σ /= lτ . Thus truncL(s) ∈ S' , which contradicts the minimality of s.	 
Furthermore, we only have to consider linear terms for the set SL, if we are only interested in the matching of ground terms.
Lemma 5.9 For a set L ⊆ 7lin(Σ, V) of linear terms, we have for every t ∈7 (Σ) ∩
'  that s ∈ SL ∩ 7lin(Σ, V) and σ ∈ SUB(Σ, V) exist with sσ = t.

Proof. Let t ∈7 (Σ) ∩ S' . Then for all l ∈ L and all τ ∈ SUB(Σ, V) we have that lτ /= t. Since 7 (Σ) ⊆ 7lin(Σ, V), we get from Lemma 2.1 that a πl ∈ Pos(l) ∩Pos(t) exists with root(t|πÆ ) /= root(l|πÆ ).
There exist s ∈ SL and σ ∈ SUB(Σ, V) with sσ = t, due to Lemma 5.5. In case
s ∈ 7lin(Σ, V) nothing has to be proven.
Otherwise, we start with the term lin(s) that is created from s by replacing every occurrence of a variable by a fresh variable, thereby generating a linear term. Then clearly, there is a substitution σ' such that lin(s)σ' = t. If there is an l' ∈ L and a substitution τ ∈ SUB(Σ, V) such that lin(s)τ = l'τ (where we assume lin(s) and l' to be variable disjoint), then we replace in s the variable at a position πs ∈ Pos(s) that is a prefix of πl by f (x1,..., xn), where f = root(t|πs ), arity(f ) = n, and the xi are fresh variables. This variable must exist, otherwise l' would match t. This process is repeated until there are no more l' that unify with the thereby constructed term s'. By construction s' is linear and does not unify with any term
from L. Furthermore, this term is minimal in S' w.r.t. >, therefore s' ∈ SL, which
shows our claim.	 
From the above lemmas, we can give the following construction of an anti- matching set SL w.r.t. a set L of linear terms. Let d = depth(L) be the maximal depth of terms occurring in L. Start by S' being the finite set of all linear terms up to renaming of variables of depth ≤ d. Next remove all terms from S' that unify with a term from L. Finally initialize SL to S' and remove all non-minimal elements t from SL, i.e., every term t for which a u ∈ S exists with u < t is removed from SL. From Lemmas 5.8 and 5.9 we then know that all ground terms that are not matched by L are matched by SL.
Using this construction and the above lemmas, we can now show Theorem 3.3. It states that for a quasi left-linear TRS R a finite, computable, and unique anti- matching set SL exists that matches exactly those terms that lhs(R) does not match. Please note that we only have to consider a linear set L that matches all ground terms matched by lhs(R), as we already observed above.
Proof of Theorem 3.3. Let L ⊆ 7lin(Σ, V) be the finite set of linear left-hand sides of R. Then L matches all terms that can be rewritten by R due to Lemma 5.4. Let SL ⊆7 (Σ, V) be defined as given in Definition 5.1. As we can see from Lemma 5.6, we have that for all ground terms t ∈7 (Σ) it holds that t ∈ {sσ ∈7 (Σ) | s ∈ SL,σ ∈ SUB(Σ, V)} iff t ∈/ {lσ ∈ 7 (Σ) | l ∈ L, σ ∈ SUB(Σ, V)}. From Lemma 5.8 we get that SL is finite, since, up to variable renaming, only finitely many terms whose depth is less than or equal to depth(L) exist for a finite signature Σ. Lemma 5.9 shows that SL = SL∩7lin(Σ, V), and finally the sketched construction shows that the set SL is computable and unique since the minimal elements w.r.t. > are unique. 
Finally, we want to further analyze the case of TRSs that are not quasi left- linear. For this purpose, let L = {f(x, x)} be the left-hand sides of a TRS over the signature Σ = {f, g}. Then for every n ∈ N we have f(x, gn(x)) ∈ S' . Furthermore,
there is no term s /= f(x, gn(x)) ∈ S' such that sσ = f(x, gn(x)), which shows that
SL is infinite. To show that this is not due to choosing the set SL, we prove the

proposition below, stating that SL is the smallest set that has the desired property.
Proposition 5.10 Let L ⊆ 7 (Σ, V). For every anti-matching set S ⊆ 7 (Σ, V)
w.r.t. L we have SL ⊆ S ⊆ S' , where we disregard variable renamings.
Proof. The inclusion S ⊆ S' can be seen directly from the definition of S' .
Assume, there is such a set S ⊆ 7 (Σ, V) with SL /⊆ S. Then, there is a term s' ∈ SL such that s' ∈/ S. Furthermore, it must be the case that {sσ | s ∈ S, σ ∈ SUB(Σ, V)} = {sσ | s ∈ SL,σ ∈ SUB(Σ, V)} = S' , i.e., there must be an s ∈ S and a σ ∈ SUB(Σ, V) such that sσ = s'. This implies that s ≤ s'. In case we also have s' ≤ s, then s' ∈ S, contradicting our assumption. But otherwise s < s' holds, which contradicts the minimality of s'.	 

As a consequence of Proposition 5.10 and the previously observed fact that for L = {f(x, x)} it holds that SL ≥ {f(x, gn(x)) | n ∈ N}, we conclude that any set S that matches those terms which are not matched by a term in L must be infinite, since already SL ⊆ S is infinite.

Implementation and Experiments
We have implemented the transformations as described in the previous sections. Even though the construction of the set SL of terms that match those terms not matched by the set L of left-hand sides of the input term rewrite system can certainly be improved, the complete transformation only takes a neglegible amount of time for all of the following examples.
Our implementation allows for a number of different variants of the transforma- tion T1 to be used. In Section 3 only one of these was presented, this proved to be the most effective one in our experiments. In detail, one can choose whether or
not to add the blocking symbol when the symbol down descends into a term that
is not matched by a left-hand side of the original term rewrite system. Also, one can choose whether the symbols upon descending should be rewritten to a marked version of that symbol. As a last option, one can also use a modified version of the
rules for the up symbol, however this modification proved itself not to be effective.
The transformed system was then used as input for the termination provers Jambox [3], TTT2 [13], and AProVE [6], which were the strongest tools of the 2007 termination competition in the TRS category [15]. The reason why we used multiple tools was that the transformation turned out to produce rewrite systems for which sometimes one tool succeeded in proving termination of the transformed TRS, while at least one of the other tools was unable to do so.
Below we present some examples. First, we want to show that Example 2.2 really is outermost ground terminating, as claimed above. When this example is transformed, the following TRS is created:
Example 6.1 (Transformation of Example 2.2)




T1(R) = 
top(up(x))	→	top(down(x))	down(b)	→	up(a)
down(f(x, a))	→	up(f(x, b))	down(f(a, x))	→	up(a)
fq(block(x), up(y))	→	up(f(x, y))	down(f(b, x))	→	up(a)

⎪⎩ fq(up(x), block(y))	→	up(f(x, y))	down(f(f(x, y), z))	→	up(a)
It can be observed that in the transformed TRS there are no rules that allow the symbol down to descend into a term. This holds because we have SL = {a}, such that no rules are created for it. The transformed TRS can easily be shown terminating within a short amount of time by all of the considered tools. For the next example, this is not the case anymore.
Example 6.2
=	a	→	 f(a) f(f(f(f(f(x)))))	→	b
Both AProVE and TTT2 can show termination of T1(R2), while Jambox fails to do so. What is also interesting is that TTT2 uses RFC Match Bounds to show this, while AProVE uses only Dependency Pairs and a large number of rewriting steps, but is able to find this proof much faster than TTT2.
The next example proved to be rather difficult for all of the considered tools. It is the example from the introduction for the case n = 1.
Example 6.3
=	from(x)	→	x : from(s(x)) s(x) : xs	→	overflow
This example could only be proven outermost ground terminating using the tool Jambox, both AProVE and TTT2 failed. However, the techniques used by Jambox to prove termination, namely semantic labelling and polynomial orders, are also implemented in both of the other tools. Hence, this clearly shows that proving termination is also strongly dependent on heuristics and/or search encodings.
If we instantiate n with 2 or 3 in the example given in the introduction, then none of the considered termination tools was able to prove termination of the re- sulting TRS T1(R) in a reasonable amount of time. However, when using one of the
transformations presented in Section 4, then for both values of n the TRSs T2(R) and T3(R) can be proven terminating using the tools Jambox and AProVE. Hence,
even though these transformations are incomplete, they can be used to show out- ermost ground termination of examples where the transformation T1 does not lead to a successful proof.
In the examples that we considered so far, we had that always the right-hand side of the rule that caused the outermost ground termination was a ground term. This is different in the next example.
Example 6.4
=	f(f(g(x)))	→	x
g(b)	→	f(g(b))

This transformed TRS can be shown terminating by the tools TTT2 and Jam- box, while AProVE fails.
In the example below, it is the case that the right-hand sides are not always either growing or detecting a term that has grown too large.
Example 6.5

R5 = ⎧⎨
⎩
f(f(x, y), z)	→	c
f(x, f(y, z))	→	f(f(x, y), z)
a	→	f(a, a)

The transformed TRS T1(R5) can be shown terminating by both AProVE and Jambox, while for this example TTT2 fails to show termination. If the first rule is changed to f(f(x, y), z) → f(c, x), then only AProVE can show the transformed TRS to be terminating.
Next, we want to consider the 6 examples contained in the Termination Problem DataBase (TPDB) [15] that require outermost termination analysis. All of these ex- amples can be proven outermost ground terminating by the tool Cariboo [9], which was mentioned in the introduction. Of these 6 examples, 5 are left-linear, therefore they can be directly handled by our approach. For these, we can show outermost ground termination using Jambox as termination prover. The last example shall be considered in more detail below.
Example 6.6 (Outermost Example 6)


R6 =
f(x, y)	→	x	f(x, i(x))	→	f(x, x)
⎩ g(x)	→	i(x)

As can be seen above, this example has non-linear left-hand sides for the function symbol f. However, these left-hand sides are all instances of the left-hand side f(x, y), which makes this TRS quasi left-linear. Hence, we only have to consider the set L = {f(x, y), g(x)} of linear terms, from which we then compute SL to be SL = {a, i(x)}. Using this set, our transformation yields a finite TRS T1(R6), whose termination can be proven using any of the three considered tools.
Finally, we want to compare the strength of our approach against that of Cari- boo. The following example is non-terminating for normal rewriting, since already the rule h(x) → f(h(x)) allows an infinite reduction.
Example 6.7
=	f(h(x))	→	f(i(x))	h(x)	→	f(h(x)) f(i(x))	→	x	i(x)	→	h(x)

Cariboo is unable to prove outermost ground termination of the TRS R7, while the transformed TRS T1(R7) can be proven terminating by all considered tools. Also Example 6.4 and both variants of Example 6.5 cannot be proven outermost ground terminating by Cariboo.

There are also examples where Cariboo succeeds, whereas our transformation fails. First of all, Cariboo can also handle examples that are not quasi left-linear, while our transformation is not applicable in this case. But there are also quasi left-linear examples where Cariboo can prove outermost ground termination, but none of the considered tools can prove termination of the transformed TRS. Such an example is given below.
Example 6.8


R8 =
f(i(x), h(x))	→	a	i(x)	→	g(x)
⎩ f(x, h(y))	→	f(x, j(y))	j(x)	→	h(x)


This quasi left-linear example can be shown terminating by Cariboo, whereas for all termination provers the transformed TRSs T1(R8) and T3(R8) are too hard, while T2(R8) allows for an infinite reduction.

Conclusion
We have presented different transformations such that outermost ground termina- tion of a TRS follows from termination of the transformed TRS. These transforma- tions are sound for arbitrary term rewrite systems, but only for finite quasi left-linear term rewrite systems the transformed term rewrite system is finite and can be con- structed automatically. For this class of term rewrite systems we implemented the transformations and we were able to prove ground outermost termination of several non-trivial examples, including all 6 examples contained in the TPDB that require an outermost strategy. When comparing the presented approach to the existing one implemented in the tool Cariboo [9], then we have shown that our approach can prove several term rewrite systems to be outermost ground terminating where Cariboo fails. However, it should also be mentioned that for some examples Cariboo succeeds but our transformation fails. Especially, Cariboo is not limited to quasi left-linear TRSs, but also when considering only such TRSs there are examples with this behavior. However, some of these quasi left-linear examples might, due to the nature of our approach, be proven outermost ground terminating in the future us- ing the presented transformation, when the underlying termination provers become even more powerful.
As already presented in Section 4, the transformations based on contexts are not complete, i.e., from the non-termination of the transformed TRS one can not conclude that the original TRS contains an infinite outermost ground reduction. However, recent work suggests that the transformation presented in Section 3 is complete when restricting to TRSs R that satisfy the condition V(r) ⊆ V(l) for all rules l → r ∈ R. Proving this remains a task for the future.
In the present TPDB, the set of TRSs requiring an outermost strategy, so being non-terminating when disregarding the strategy, is quite limited: there are only
6. Therefore, more such examples should be added to the TPDB to allow for a

better comparison of different approaches that try to prove outermost termination automatically.

References
Baader, F. and T. Nipkow, “Term Rewriting and All That,” Cambridge University Press, Cambridge, UK, 1998.
Clavel, M., F. Dur´an, S. Eker, P. Lincoln, N. Mart´ı-Oliet, J. Meseguer and C. Talcott, The Maude
2.0 System, in: Proceedings of the 14th Conference on Rewriting Techniques and Applications, Lecture Notes in Computer Science 2706 (2003), pp. 76–87.
Endrullis, J., Jambox 2.0e, downloadable from http://joerg.endrullis.de.
Futatsugi, K. and R. Diaconescu, editors, “CafeOBJ Report,” World Scientific Publishing Company, 1998.
Giesl, J. and A. Middeldorp, Transformation Techniques for Context-Sensitive Rewrite Systems, Journal of Functional Programming 14 (2004), pp. 379–427.
Giesl, J., P. Schneider-Kamp and R. Thiemann, AProVE 1.2: Automatic Termination Proofs in the Dependency Pair Framework, in: Proceedings of the 3rd International Joint Conference on Automatic Reasoning, Lecture Notes in Computer Science 4130 (2006), pp. 281–286, downloadable from http:
//aprove.informatik.rwth-aachen.de.
Giesl, J., S. Swiderski, P. Schneider-Kamp and R. Thiemann, Automated Termination Analysis for Haskell: From Term Rewriting to Programming Languages, in: Proceedings of the 17th Conference on Rewriting Techniques and Applications, Lecture Notes in Computer Science 4098, 2006, pp. 297–312.
Giesl, J. and H. Zantema, Liveness in Rewriting, in: Proceedings of the 14th Conference on Rewriting Techniques and Applications, Lecture Notes in Computer Science 2706 (2003), pp. 321–336.
Gnaedig, I. and H. Kirchner, Termination of rewriting under strategies, ACM Transactions on Computational Logic (2007), to appear, available at http://tocl.acm.org/accepted/315gnaedig.ps.
Huet, G., Confluent Reductions: Abstract Properties and Applications to Term Rewriting Systems, J. ACM 27 (1980), pp. 797–821.
Jones, S. P., editor, “Haskell 98 Language and Libraries: The Revised Report,” Cambridge University Press, 2003, also available from http://www.haskell.org/definition.
Kirchner, C., R. Kopetz and P.-E. Moreau, Anti-Pattern Matching, in: Proceedings of the 16th European Symposium on Programming, Lecture Notes in Computer Science 4421 (2007), pp. 110–124.
Korp, M., C. Sternagel, H. Zankl and A. Middeldorp, Tyrolean Termination Tool 2 (TTT2), downloadable from http://colo6-c703.uibk.ac.at/ttt2.
Lassez, J.-L. and K. Marriot, Explicit Representation of Terms Defined by Counter Examples, Journal of Automated Reasoning 3 (1987), pp. 301–317.
March´e, C. and H. Zantema, The Termination Competition, in: Proceedings of the 18th Conference on Rewriting Techniques and Applications, Lecture Notes in Computer Science 4533 (2007), pp. 303–313, see also http://www.lri.fr/~marche/termination-competition.
Panitz, S. E. and M. Schmidt-Schauss, TEA: Automatically proving termination of programs in a non- strict higher order functional language, in: Proceedings of the 4th International Symposium on Static Analysis, Lecture Notes in Computer Science 1302, 1997, pp. 345–360.
Terese, “Term Rewriting Systems,” Cambridge University Press, Cambridge, UK, 2003.
