Electronic Notes in Theoretical Computer Science 174 (2007) 29–43	
www.elsevier.com/locate/entcs
Undecidability of Multi-modal Hybrid Logics
Martin Mundhenk1 Thomas Schneider2
Institut fu¨r Informatik Friedrich-Schiller-Universit¨at Jena, Germany

Abstract
This paper establishes undecidability of satisfiability for multi-modal logic equipped with the hybrid binder
↓ , with respect to frame classes over which the same language with only one modality is decidable. This is in contrast to the usual behaviour of many modal and hybrid logics, whose uni-modal and multi-modal versions do not differ in terms of decidability and, quite often, complexity. The results from this paper apply to a wide range of frame classes including temporally and epistemically relevant ones.
Keywords: Computational Complexity, Downarrow Operator, Hybrid Logic, Modal Logic


Introduction
The bottom line of this paper can be informally summarized by the warning
If you hybridize a multi-modal logic Ln, then expect it to become undecidable — even if you only consider frame classes over which the uni-modal hybridized L is decidable.
We explain this statement and formulate it more precisely.
This paper examines the effects of the interaction between the hybrid downarrow operator (↓) and multiple modalities on the decidability of the satisfiability problem of modal logics. The ↓ operator is a very powerful and desirable means of expression. It allows for binding names to points in a model (states, points in time, . . . ) and for referring to these points later on. But this high expressivity makes this operator dangerous in terms of computational costs. Satisfiability for modal logic equipped with ↓ is undecidable in general [1]. However, over restricted frame classes, such as transitive frames, transitive trees, linear orders, or equivalence relations, ↓ is either of no use at all, or the expressive power added does not lead to undecidability [13].

1 Email: mundhenk@cs.uni-jena.de
2 Email: schneider@cs.uni-jena.de

1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2006.11.024


Table 1
Complexity results (completeness) for the hybrid ↓-language with respect to different frame classes. A conclusion from cited work is denoted by “c”.

We show that for these and other frame classes, satisfiability becomes undecidable in the bi-modal or tri-modal case, respectively.
The consequences of the ↓ operator for the satisfiability problem of hybrid logics have been examined in many respects. It has been shown in [17] that decidability over arbitrary frames can be regained under certain syntactic restrictions concerning the interaction of ↓ and the modal operator . In the same paper, decidability has been recovered by restricting the frame class to uni-modal frames of bounded width. Other semantic restrictions by means of temporally relevant frame classes have been shown to sustain decidability in [7] and [13]. In the case of [7], even interactions of ↓ with other hybrid operators have been allowed. The complexity results for different frame classes are summarized in Table 1. Complexity classes are used as defined in [15].
The contribution of this paper is to be seen from two points of view. On the one hand, our results will imply that many of the decidability statements from Table 1 do not carry over to the multi-modal ↓-language. On the other side, this also means that even if we restrict ourselves to frame classes over which ↓ seems to be (mostly)
harmless, adding ↓ to a multi-modal language is much worse in terms of decidability
than adding it to a uni-modal language. This is how the above warning shall be understood.
Precisely speaking, we prove the following results.
For each frame class containing one particular linear frame, satisfiability of the bi-modal ↓-language is undecidable.
For each frame class containing one particular ER 3 frame, satisfiability of the tri-modal ↓-language is undecidable.
It is worth noting that each of these two statements involves a wide range of frame classes, including temporally (in the first case) and epistemically (in the second case) relevant ones. This is in agreeable contrast to the fact that most techniques used to establish complexity results for modal and hybrid logics are not easily transferable to other frame classes. Two positive examples for results involving more than one frame class can be found in [11] and [16]. According to our understanding, the generality of our results is due to the enormous expressive power of ↓ that allows for forcing an arbitrary frame to have many important and very specific properties. Furthermore, our results give another insight into the lack of robustness exhib- ited by ↓ languages. The term “robust” is used in a similar manner as in [9], here denoting the property that the passage from a uni-modal logic to its multi-modal version does not destroy decidability or complexity. Many, but not all, modal and

3 An ER frame is a multi-modal frame in which each relation is an equivalence relation.


Table 2
Complexity results (completeness) for modal and hybrid languages with respect to different frame classes. A conclusion from cited work is denoted by “c”. Our results are typeset in bold, accompanied by the number of the respective theorem.

hybrid logics without ↓ are robust in this sense [10,1,2,8,4], but we will show that
↓-languages lack such a robustness. This contrast becomes vivid in Table 2 which contains complexity results for modal (ML) and hybrid (HL) languages with re- spect to frame classes covered by our results, contrasting uni-modal and multi-modal versions.
This paper is organized as follows. In Section 2 we give the necessary definitions of hybrid logic and tilings, the tool used to establish undecidability. Section 3 contains our results, and Section 4 concludes the paper.

Preliminaries
We define the basic concepts and notations of hybrid logic and tilings. The funda- mentals of hybrid logic can be found in [1,5]; tilings are defined in [18].

Hybrid Logic
Hybrid languages are extensions of the modal language allowing for explicit ref- erences to states. Here we introduce the languages relevant for our work. The definitions and notations are taken from [1,2].
Syntax. Let PROP be a countable set of propositional atoms, NOM be a countable set of nominals, SVAR be a countable set of state variables, ATOM = PROP ∪ NOM
∪ SVAR, and n ∈ N>0. It is common practice to denote propositional atoms by p, q, . . . , nominals by i, j, . . . , and state variables by x, y, . . . The full n-modal hybrid language HL↓,@ is the set of all formulae of the form

ϕ ::= a | ¬ϕ | ϕ ∧ ϕ' |  lϕ | @tϕ | ↓x.ϕ,

where a ∈ ATOM, t ∈ NOM ∪ SVAR, x ∈ SVAR, and l ∈ {1,..., n}. We use the well-known abbreviations ∨, →, ↔, T (“true”), and ⊥ (“false”), as well as
 lϕ = ¬ l¬ϕ.
Whenever we leave ↓ or @ out of the hybrid language, we omit the according superscript of HLn. We call the modal language (i. e. without nominals, @, and ↓) MLn. In the uni-modal case, we omit the subscript 1.


Table 3
Relevant frame classes, their abbreviations and definitions

Semantics for HL↓,@ is defined in terms of Kripke models. A Kripke model is a
triple	=	(	n	)	 , where	is a nonempty set of states,
are binary relations — the accessibility relations — , and V : PROP → P(M ) is a function — the valuation function. The structure F = M, (R1,..., Rn) is called a frame.
A multi-modal hybrid model is a Kripke model with the valuation function V extended to PROP ∪ NOM, where for all i ∈ NOM, |V (i)| = 1. Whenever it is clear from the context, we will omit “hybrid” and/or “multi-modal” when referring to models.
In order to evaluate ↓-formulae, an assignment g : SVAR → M for M is neces-
sary. Given an assignment g, a state variable x and a state m, an x-variant gx of
g is defined by gx (x) = m and gx (x') = g(x') for all x' /= x. For any atom a, let
m	m
[V, g](a) = {g(a)} if a ∈ SVAR, and V (a), otherwise.
Given a model M = M, (R1,..., Rn),V , an assignment g, and a state m ∈ M , the satisfaction relation for hybrid formulae is defined by

M, g,m |= a	iff m ∈ [V, g](a), a ∈ ATOM,
M, g,m |= ¬ϕ	iff M, g,m |= ϕ,
M, g,m |= ϕ ∧ ψ iff M, g,m |= ϕ & M, g,m |= ψ,
M, g,m |=  lϕ	iff ∃n ∈ M (mRln & M, g,n |= ϕ),
M, g,m |= @tϕ	iff ∃n ∈ M (M, g,n |= ϕ & [V, g](t)= {n}),
M, g,m |= ↓x.ϕ	iff M, gx ,m |= ϕ.

A formula ϕ is satisﬁable if there exist a model M = M, (R1,..., Rn),V , an assignment g for M, and a state m ∈ M , such that M, g,m |= ϕ.
Properties of Models and Frames. Let M = M, (R1,..., Rn),V be a hybrid model with the underlying frame F =  M, (R1,..., Rn) . By R+ we denote the
transitive closure of Rl.
If we require the accessibility relations to have certain properties, we restrict the class of relevant frames. The frame classes used in this paper are defined in Table 3, where only the uni-modal case F = (M, R) is considered. If we speak of a multi- modal frame having one of these properties, we mean a frame F = M, (R1,..., Rn) such that each (M, Rl) has this property.

Satisfiability Problems. For any hybrid language HLx and any frame class F, the
satisﬁability problem HLx-F-SAT is defined as follows: Given a formula ϕ ∈ HLx ,
n	n
do there exist a hybrid model M based on a frame from F, an assignment g for M, and a state m ∈ M such that M, g,m |= ϕ ? (If ↓ is not in the considered language, the assignment g can be left out of this formulation.) For example, the satisfiability problem over transitive frames for the bi-modal hybrid ↓ language is denoted by
HL↓-trans-SAT.

Tilings
Domino tiling problems trace back to Wang [19]. A tile is a unit square, di- vided into four triangles by its diagonals.  A tile type is a colouring of these four triangles and cannot be rotated. More formally, a tile type T is a quadru- ple T =  left(T ), right(T ), top(T ), bot(T )  of colours. Given a set T of tile types, a T -tiling is a complete covering of the Z × Z grid with tiles having types from T , such that each point (x, y) is covered by exactly one tile and adjacent tiles have the same colour at their common edges. Formally, a T -tiling is a function τ : Z×Z →T satisfying the following condition for all (x, y) ∈ Z × Z.
right τ (x, y)  = left τ (x + 1, y)  &  top τ (x, y)  = bot τ (x, y + 1) .	(1)

Given a tile type T ∈T , we define RI(T, T ) = {T ' ∈T | right(T ) = left(T ')} and UP(T, T ) = {T' ∈ T | top(T ) = bot(T')} in order to denote the sets of tile types that match T horizontally or vertically, respectively, in a T -tiling. Condition (1), then, is equivalent to

τ (x + 1, y) ∈ RI τ (x, y)	&	τ (x, y + 1) ∈ UP τ (x, y) .
The tiling problem denotes the question whether a given set T of tile types admits a T -tiling of the Z × Z grid. This problem is coRE-complete, hence undecidable [3]. It remains coRE-complete if the grid is restricted to the first quadrant, i. e. N × N. We will make use of both versions in Section 3.

Undecidability of Multi-modal Downarrow Logic
We have observed in Section 1 that for many modal languages, as well as for the basic hybrid language, algorithms deciding their satisfiability can straightforwardly be applied to multi-modal versions of these languages without significant changes. Hence the complexity often does not increase when proceeding from uni-modal to multi-modal languages. However, concerning HL↓, this is not the case because the fundamental properties that led to the proofs of the decidability results do not carry over to multi-modal versions of this language.
In the case of acyclic frames (linear orders or transitive trees), this “fundamental property” is the simple fact that due to the lack of cycles, we can never get back to points named by ↓. In a frame with two acyclic accessibility relations, however,

cycles are possible. For transitive frames, the “fundamental property” consists of the fact that each cycle is a cluster, i. e. a complete subframe. In a transitive frame for a multi-modal language, there can be cycles consisting of edges of different acces- sibility relations which are not necessarily clusters. This renders the argumentation in the respective proof untransferable even to bi-modal HL↓. In the case of equiv- alence relations, the “fundamental property” is the fact that HL↓ is equivalent to the monadic class of first-order logic. This equivalence cannot be established for the bi-modal language.
The bi-modal language with ↓ is in fact strong enough to encode tilings on any
frame class between linear and arbitrary frames. This will lead to the result in Subsection 3.1. Tilings can also be encoded on any frame class between ER frames and arbitrary frames, although three modalites are needed in this case. This result is given in Subsection 3.2. The expressive power of ↓ becomes evident in both encodings.


Between Linear Orders and Arbitrary Frames
In this subsection, we show that HL↓ is able to encode tilings of N × N on any frame class containing one particular linear frame, which we will call Grid in the following. This ability is not too surprising if one considers the fact that ↓ is powerful enough to force the two accessibility relations to behave as the “right neighbour” and “upper neighbour” relations in the N × N grid. Since we are interested in a result as general as possible, we will have to insist on Grid having two linear (i. e. transitive, irreflexive, and trichotomous) accessibility relations when constructing this frame. This may seem artificial at some point, but is justified by the aim to cover as many frame classes as possible.
In order to construct Grid, we start with two accessibility relations Rh (“hori- zontal”) and Rv (“vertical”). The frame will consist of points (x, y) ∈ N2, where (x, y)Rh(x', y') whenever x < x' and y = y', and (x, y)Rv(x', y') whenever x = x' and y < y'. This situation is shown in Figure 1 (a), where a full line denotes an Rh edge, and a dashed line stands for an Rv edge. Note that the transitive closure of both relations is implicit. Clearly, Rh and Rv are irreflexive. For reasons just stated, we make them trichotomous by adding extra edges as given in Figure 1 (b) and taking the transitive closure again. More precisely speaking, we make each point on the nth row see each point on the mth row via Rh, for each m > n; and we make each point on the nth column see each point on the mth column via Rv, for each m > n.
We will need to refer to the lower left point (the “origin” of the grid) several times. For this purpose, we introduce a variant of the Spypoint Technique [6,1]. Apart from the fact that the “origin” behaves almost as a spypoint — i. e. all other points in Grid are accessible from it via some Rh-Rv-path —, we will add a sinkpoint to the model that is accessible from all other points via Rh and that sees the spypoint via Rv, cf. Figure 1 (c). Note that the spypoint-sinkpoint construction does not destroy irreflexivity or trichotomy.

t



Transitive and irreflexive
In addition, trichotomous
The frame Grid
with spy-/sinkpoint


Fig. 1. Simulating the N × N grid with two relations. The transitive closures are not drawn.

Let ∞ denote the sinkpoint. We formally define Grid = N, (Rh, Rv) by

N = N2 ∪ {∞}	(N2 = N × N),
Rh =   (x, y), (x', y') ∈ (N2)2 | (y = y' and x < x') or y < y'} ∪ N2×{∞} ,
Rv =   (x, y), (x', y') ∈ (N2)2 | (x = x' and y < y') or x < x'} ∪  {∞}×N2 .

Clearly, Grid is a linear frame. Whenever we will construct a model based on Grid, we will name the spypoint s and the sinkpoint t, where s and t are nominals. This is reflected in Figure 1 (c), too. We now formulate our result as general as possible.
Theorem 3.1 For any bi-modal frame class F with Grid ∈ F, HL↓-F-SAT is unde-
cidable.
Proof. Let T be a set of tile types. We define a formula ϕT that implements the grid and expresses the tiling. This formula has to be equipped with two properties. On the one hand, it must be satisfied in some model based on Grid, given a T -tiling. On the other side, ϕT must enforce that each satisfying arbitrary model behaves as the T -tiled N × N grid. Hence, when constructing ϕT , we will have to enforce properties like for example transitivity or convergence that hold naturally in Grid, while we do not need to enforce e. g. trichotomy.
We start with the conjuncts of ϕT responsible for the grid.
The spypoint and sinkpoint are as given in Figure 1 (c).

SPY = s ∧  h t ∧  vs 

Before we proceed, we define a useful abbreviation that allows us to refer only to points that are not the sinkpoint.

  ¬tψ =  h(¬t ∧ ψ)	 ¬tψ = ¬ ¬t¬ψ
h	h	h

Another shortcut is used for the “reflexive closure” of the modal operators.

 ∗ψ = ψ ∨  vψ	 ∗ψ = ¬ ∗¬ψ
v	v	v
 ∗ ψ = ψ ∨  ¬tψ	 ∗ ψ = ¬ ∗ ¬ψ
h	h	h	h

Note that the definition of  ∗ already includes  ¬t, hence we do not need to state
h	h
“¬t” explicitly whenever we use  ∗ or  ∗ .
h	h
From now on, we will call all points other than the sinkpoint that are accessible from s via a sequence consisting of at most one Rv edge and at most one Rh edge Rv-Rh-reachable. Within the set of all Rv-Rh-reachable points, we can simulate the @ operator. Suppose x is bound to such a point, then we can assert @xψ at any other point by going directly to the sinkpoint, from there to the spypoint and then
to the point to which x is bound. This idea is captured by the following definition. @xψ =  h t ∧  v s ∧  ∗ ∗ (x ∧ ψ) 
Note that @xψ only works if the point to which x is bound is Rv-Rh-reachable. On the other hand, the point y at which @xψ is satisfied, is enforced to see the sinkpoint horizontally. (As an aside, we could even simulate the “somewhere” modality E if we left out x on the right-hand side of the above definition.)
For the @ operator and subsequent conjuncts to function properly even on arbi- trary frames, it will be necessary to require that every point accessible from Rv-Rh- reachable points is Rv-Rh-reachable again. This is ensured by the following formula enforcing that both relations are transitive within the grid.
For every Rv-Rh-reachable point x, each point accessible from x via two Rv (or
Rh) edges is accessible from x in one Rv (or Rh) step.
TRANS =  ∗ ∗ ↓x.  ¬t ¬t ↓y.@x  hy ∧  v v ↓y.@x  vy 

At first glance, the fact that TRANS uses the @ operator, while the @ operator seems to act on the assumption that the relations are transitive, appears to expose a cyclic definition. This is not the case because TRANS operates in an inductive manner, which will become clear further below when the tiling is constructed from a model satisfying ϕT .
We will need to refer to neighbours of points. A point y is a right neighbour
of x if xRhy and there is no z such that xRhzRhy. Upper neighbours are defined analogously. In order to express neighbours, we define “next” operators to be the following abbreviations.

◯hψ = ↓a. ¬t ↓b. @a¬ h hb ∧ ψ 
◯vψ = ↓a. v ↓b. @a¬ v vb ∧ ψ 

Whenever ◯h and ◯v are employed in the following, a and b must be substituted by fresh state variables. Note that these operators are diamond-style. We will not

introduce an abbreviation for their duals. After we have required every Rv-Rh- reachable point to have exactly one right and one upper neighbour, the new next operators can be used box-style, as well.
Every Rv-Rh-reachable point has exactly one right and exactly one upper neigh- bour.
NEIGH =  ∗ ∗ ↓x. ◯h ↓y.@x¬◯h¬y ∧ ◯v ↓y.@x¬◯v ¬y 
For every Rv-Rh-reachable point x, the unique point y that is the right neigh- bour of the upper neighbour of x coincides with the upper neighbour of the right neighbour of x.
CONV =  ∗ ∗ ↓x.◯v ◯h ↓y.@x◯h◯vy
v  h
Having implemented the grid, it is straightforward to express the tiling on it. For this purpose, we define an atomic proposition T for each tile type in T ∈ T . For the sake of short notation, we will deliberately confuse tile types with their associated atoms.
At each point in the grid lies exactly one tile.


TILE =  ∗ ∗ 

 T ∧   '

¬T' 


The tiling conditions are met.


MATCH =  ∗ ∗ 

 T →    '

◯vT ' ∧   '

◯hT ' 


Let ϕT = SPY ∧ TRANS ∧ NEIGH ∧ CONV ∧ TILE ∧ MATCH. In order to prove the statement of this theorem, it is sufficient to show that the following two propositions hold:
If T admits a tiling, then ϕT is satisfiable in Grid.
If ϕT is satisfiable in an arbitrary model, then T admits a tiling.
Proof of (i). Suppose T is given and admits a tiling of N2. Then there exists a function τ : N2 →T such that for all (x, y) ∈ N2, Condition (1) from Page 5 holds. We construct a model M =  N, (Rh, Rv),V  based on Grid, where V is defined by V (s) = {(0, 0)}, V (t) = {∞}, and V (T ) = {(x, y) | τ (x, y) = T} for each T ∈T .
We claim that M, (0, 0) |= ϕT and show that each conjunct of ϕT is satisfied at (0, 0) in M. Conjunct SPY follows directly from the definitions of Rh and Rv of Grid. Since both relations are transitive, TRANS holds. Conjuncts NEIGH and CONV are satisfied because they express basic properties of Rh and Rv that are based on N2. TILE and MATCH hold due to the tiling.
Proof of (ii). Let M = M, (Rh, Rv),V be an arbitrary model satisfying ϕT . Since s, t are nominals, there exist points m0, m∞ ∈ M such that V (s) = {m0} and V (t) = {m∞}. Conjunct SPY implies m0Rhm∞ and m∞Rvm0. We now define




m0,n








m0
Points on the nth diagonal and their enforced successors
m0	diagonal
Coincidence of mi−1,n+1−i
'
i−1,n+1−i


Fig. 2. The diagonal-wise construction of the grid

a mapping f : N2 → M − {m∞} that satisfies the following conditions for all (x, y) ∈ N2.
If x ≥ 1, then f (x, y) is the right neighbour of f (x − 1, y).
If y ≥ 1, then f (x, y) is the upper neighbour of f (x, y − 1).
If x = 0 and y ≥ 1, then m0Rvf (0, y).
f (x, y) is Rv-Rh-reachable.
f (x, y)Rhm∞.
We construct f by induction on n = x + y, i. e. diagonal-wise with respect to N2. The base case consists of n = 0, 1. For n = 0, we set f (0, 0) = m0. Since m0 is Rv-Rh-reachable, NEIGH together with @ implies that m0 has a unique right neighbour m1,0 and a unique upper neighbour m0,1. Due to the definition of @, they both see the sinkpoint via Rh. Set f (1, 0) = m1,0 and f (0, 1) = m0,1. Now Conditions (iii)–(vii) are satisfied up to the first diagonal.
For the induction step, suppose that f (x, y) has already been defined for all (x, y) with x + y ≤ n (i. e. from the 0th to the nth diagonal), n ≥ 1, and Conditions (iii)–
(vii) hold up to here. Consider the points on the nth diagonal, namely mi,n−i = f (i, n − i) for i = 0,..., n. Because of (vi), NEIGH applies and implies that each mi,n−i has a unique horizontal successor mi+1,n−i and a unique vertical successor

'
i,n+1−i
, see Figure 2 (a). Note that the @ operator works because each mi,n−i

satisfies (vi).
Now for each i = 1,...,n−1, the points a = mi,n+1−i and b = m'

coincide.

To justify this claim, let c = f (i− 1,n− i) (lying on the (n− 1)st diagonal). Since c has the horizontal successor mi,n−i which has the vertical successor b, and c has the vertical successor mi−1,n+1−i which has the horizontal successor a, and (vi) holds for c, CONV implies a = b. See also Figure 2 (b).
Let f (0,n + 1) = m'	and f (i, n +1 − i) = mi,n+1−i, for all i = 1,...,n + 1.
It follows from this construction that Conditions (iii), (iv), and (vii) are satisfied for the “new” (x, y) from the (n + 1)st diagonal. To end the inductive construction, we have to show that the “new” (x, y) also satisfy (v) and (vi).
Condition (v) has to be shown for (0,n + 1). Since according to the induction




q	N = Z2 = Z × Z
R0 = (Z2)2
R1 = Sk,l∈Z minicluster(2k, 2l)
q	R2 = Sk,l∈Z minicluster(2k + 1, 2l + 1)
with minicluster(i, j)= 
{(i, j), (i + 1,j), (i, j + 1), (i + 1,j + 1)}2
q
p	p	p
(a) The grid	(b) Its definition

Fig. 3. Simulating the Z × Z grid with two equivalence relations. Each line represents a bidirectional arrow. The transitive (and hence, reflexive) closures are not drawn.
hypothesis, m0Rvf (0, n), TRANS applied to m0 yields m0Rvf (0,n + 1).
Condition (vi) for (0,n + 1) follows from (v). For the remaining (i, n +1 − i), we argue as follows. Due to the induction hypothesis, mi−1,n+1−i is Rv-Rh-reachable. Hence there is some point a which is accessible from m0 in at most one Rv step and from which mi−1,n+1−i is accessible in at most one Rh step. If the last “at most one” is in fact 0, then we are done. If it is 1, then mi,n+1−i is accessible from a in two Rh steps. Since a is Rv-Rh-reachable, too, TRANS applied to a yields aRhmi,n+1−i, hence mi,n+1−i = f (i, n +1 − i) is Rv-Rh-reachable.
With f at our disposal, we can easily define a function τ : N2 → T as follows. Let τ (x, y) = T if and only if f (x, y) ∈ V (T ), for each (x, y) ∈ N2 and each T ∈T . The correctness of this definition is ensured by the construction of f and TILE. Because of MATCH, τ satisfies the tiling conditions.	 

Between Equivalence Relations and Arbitrary Frames
In this subsection, we show that HL↓ is able to encode tilings on any frame class containing one particular ER frame, which we will call Grid2 in the following. This encoding relies on three modalities, because at least two are necessary to distinguish between the left, right, upper, and lower neighbour of a point in the grid, and the third is needed as a universal modality. For the sake of an easy definition of the accessibility relations, we will consider tilings of the whole Z × Z grid here.
Before we state a result as general as possible, we give a construction of Grid2 and formally define this tri-modal frame to be Grid2 = N, (R0, R1, R2) , where N and Ri are defined in Figure 3 (b). This is visualized in Figure 3 (a), where a full line denotes an R1 edge, and a dashed line stands for an R2 edge. Note that due to symmetry, no arrowheads appear. Furthermore, many edges implied by transitivity have not been drawn for the sake of clarity. The relation R0 is not shown because the whole frame forms an R0 cluster.
Whenever we will construct a model based on Grid2, we will name the spypoint s, where s is a nominal. Furthermore, we will use atomic propositions p, q to label those points that lie on an even column or row, respectively. This will enable us to distinguish between four directions. For this purpose, we define the following

abbreviations.
a = p ∧ q	even row, even column	c = ¬p ∧ ¬q	odd row, odd column
b = ¬p ∧ q	even row, odd col.	d = p ∧ ¬q	odd row, even col. All these settings are reflected in Figure 3 (a), too.
Again, we formulate our result as general as possible, involving each class of frames containing Grid2. This includes the class of ER frames.
Theorem 3.2 For any tri-modal frame class F with Grid2 ∈ F, HL↓-F-SAT is
undecidable.
Proof. Let T be a set of tile types. We define a formula ϕT that implements the grid and expresses the tiling using atomic propositions T for each T ∈ T . First we define abbreviations that allow us to refer to the left, right, upper, and lower neighbour of a given point.
  lψ =  a ∧  2(b∧ψ) ∨ b ∧  1(a∧ψ) ∨ c ∧  1(d∧ψ) ∨ d ∧  2(c∧ψ) 
  rψ =  a ∧  1(b∧ψ) ∨ b ∧  2(a∧ψ) ∨ c ∧  2(d∧ψ) ∨ d ∧  1(c∧ψ) 
  uψ =  a ∧  2(d∧ψ) ∨ b ∧  2(c∧ψ) ∨ c ∧  1(b∧ψ) ∨ d ∧  1(a∧ψ) 
  dψ =  a ∧  1(d∧ψ) ∨ b ∧  1(c∧ψ) ∨ c ∧  2(b∧ψ) ∨ d ∧  2(a∧ψ) 

As usual, the duals are defined by xψ = ¬ x¬ψ, x ∈ {l, r, u, d}. From now on, we call all points accessible from the spypoint via R0 accessible.
The formula ϕT consists of the following conjuncts.
The origin is named s, sees itself via R0 and satisﬁes a.
SPY = s ∧  0s ∧ a
Each accessible point has a unique left, right, upper, and lower neighbour, respec- tively. Each of these four neighbours is connected to the spypoint via R0 in both directions. The three missing conjuncts (“... ”) are analogous.
NEIGH =  0 ↓x.  l ↓y. 0 s ∧  0 y ∧  r(x ∧  ly)  ∧ ... 

Convergence holds, i. e. for each accessible point x, the (uniquely determined) point that is the right neighbour of the upper neighbour of x coincides with the upper neighbour of the right neighbour of x.
CONV =  0 u r ↓x. l d r ux
(Note that it suffices to replace the preﬁx  0 u r by  0, but the given deﬁnition of CONV simpliﬁes the considerations at the end of this proof.)
To encode the tiling, the conjuncts TILE and MATCH from the proof of Theo- rem 3.1 are used, with  ∗ ∗ replaced by  0 and using  u and  r instead of ◯v
v  h
and ◯h, respectively.

Let ϕT = SPY ∧ NEIGH ∧ CONV ∧ TILE ∧ MATCH. Note that we only have to require certain properties of Grid2, but not all of them. For example, it is not necessary to enforce that the Ri are equivalence relations. The properties enforced by ϕT are chosen such that they are satisfied by Grid2 on the one hand, and sufficient for a satisfying model to encode a tiling on the other hand. More precisely, it remains to prove the following two propositions.
If T admits a tiling, then ϕT is satisfiable in Grid2.
If ϕT is satisfiable in an arbitrary model, then T admits a tiling. Proposition (i) is shown as in the proof of Theorem 3.1.
Proof of (ii). Let M = M, (R0, R1, R2),V  be an arbitrary model satisfying ϕT . Since s is a nominal, there exists a point m0 ∈ M such that V (s) = {m0}. Because of SPY, M, m0 |= a and m0R0m0. We define a mapping f : Z2 → M satisfying the following conditions for all (x, y) ∈ Z2.
f (0, 0)R0f (x, y)R0f (0, 0)
(a) 2 | x ⇔ M,f (x, y) |= p
2 | y ⇔ M,f (x, y) |= q
(a) x ≥ 1 ⇒  M,f (x − 1, y) |= p	⇒ f (x − 1, y)R1f (x, y)R1f (x − 1, y) 
x ≥ 1 ⇒  M,f (x − 1, y) |= ¬p ⇒ f (x − 1, y)R2f (x, y)R2f (x − 1, y) 
y ≥ 1 ⇒ M,f (x, y − 1) |= q	⇒ f (x, y − 1)R1f (x, y)R1f (x, y − 1) 
y ≥ 1 ⇒  M,f (x, y − 1) |= ¬q ⇒ f (x, y − 1)R2f (x, y)R2f (x, y − 1) 
We construct f by induction on n = |x| + |y|. For a given n ∈ N, all points (x, y) satisfying |x| + |y| = n lie on a square that is rotated by 45 degrees and whose corners are (n, 0), (−n, 0), (0, n), and (0, −n). In the considerations to follow, we restrict ourselves to the first quadrant, i. e. N×N. The arguments for the other three quadrants are analogous. Note that we cannot restrict the whole proof to N × N since this would cause more intricate definitions of R1, R2, and NEIGH owing to an extra treatment of the margins of the grid.
The base case consists of n = 0, 1. Set f (0, 0) = m0. Now NEIGH implies that there exist m1,0, m0,1 ∈ M such that M, m1,0 |= b; M, m0,1 |= d; and there exist R0- and R1-edges in both directions between m0 and each of these two new points. Set f (1, 0) = m1,0 and f (0, 1) = m0,1. Clearly, Conditions (iii)–(v) hold for all x, y with x + y ≤ 1.
For the induction step, suppose that f (x, y) has already been defined and satisfies Conditions (iii)–(v) for all (x, y) with x + y ≤ n. Consider the points on the nth diagonal, namely mi,n−i = f (i, n − i) for i = 0,..., n. Because of (iii), NEIGH applies, hence each mi,n−i has a unique right neighbour mi+1,n−i and a unique
upper neighbour m'	, see Figure 4.
By an argumentation analogous to that in the proof of Theorem 3.1, we conclude
from CONV that mi,n+1−i and m'	coincide for each i = 1,..., n. Set f (0,n +

'
0,n+1
and f (i, n +1 − i) = mi,n+1−i, i = 1,...,n + 1. Now this construction

and NEIGH imply (iii)–(v) for all x, y with x + y ≤ n + 1.




m0,n












m0
Fig. 4. Points on the nth diagonal and their enforced successors

Now we define τ : Z2 → T as follows. Let τ (x, y) = T if and only if f (x, y) ∈ V (T ), for each (x, y) ∈ Z2 and each T ∈ T . The construction of f , TILE, and MATCH ensure correctness and the tiling conditions.	 

Conclusion
We have shown that the interaction between multiple modalities and the ↓ operator leads to undecidability over a wide range of frame classes. This justifies the warning we gave in the Introduction. Corollary 4.1 provides evidence of the fact that our results cover frame classes well-known from temporal (1) and epistemic (2) logic. Statement (2) refers to many important frame classes whose accessibility relations are generalizations of equivalence relations. Those are not explicitly stated due to the lack of space for more definitions.
Corollary 4.1
For any bi-modal frame class F ∈ {lin, tt, trans}, HL↓-F-SAT is undecidable.
For any tri-modal frame class F containing ER, HL↓-F-SAT is undecidable.
Let us make a technical remark concerning the results stated in Theorems 3.1 and 3.2. A closer look at the formulae ϕT occurring in the proofs reveals that only two nominals s and t are used. They can in fact be replaced by two more bound state variables. Furthermore, the ϕT do not contain any free state variables. Hence, both statements do in fact hold for the nominal-free fragments of all sentences (i. e. formulae without free state variables) of HL↓ or HL↓, respectively.
2	3
Theorem 3.2 leaves one question: Does undecidability hold in the bi-modal case as well? After the reviewing procedure of this paper, we have answered this question by “yes”, see [12]. Hence, the warning “better not hybridize n-modal (epistemic) logic” must be given for n = 2, too.

Acknowledgement
We thank Ulrike Sattler for providing us with the idea to combine hybrid ↓ logics with multimodal logics, and Volker Weber for comments on this work. Furthermore, we appreciate the feedback of the anonymous referees.

References
Areces, C., P. Blackburn and M. Marx, A road-map on complexity for hybrid logics, in: Proc. of the 13th CSL, 1999, LNCS 1683 (1999), pp. 307–321.
Areces, C., P. Blackburn and M. Marx, The computational complexity of hybrid temporal logics, Logic Journal of the IGPL 8 (2000), pp. 653–679.
Berger, R., The undecidability of the domino problem, Memoirs of the American Mathematical Society
66 (1966), pp. 1–72.
Bezhanishvili, N. and B. ten Cate, Transfer results for hybrid logic. Part 1: the case without satisfaction operators, Journal of Logic and Computation 16 (2006), pp. 177–197.
Blackburn, P., Representation, reasoning, and relational structures: a hybrid logic manifesto, Logic Journal of the IGPL 8 (2000), pp. 339–365.
Blackburn, P. and J. Seligman, Hybrid languages, Journal of Logic, Language and Information 4 (1995),
pp. 251–272.
Franceschet, M., M. de Rijke and B.-H. Schlingloff, Hybrid logics on linear structures: Expressivity and complexity, in: Proc. of the 10th TIME, 2003 (2003), pp. 166–173.
Ghilardi, S. and L. Santocanale, Algebraic and model theoretic techniques for fusion decidability in modal logics., in: M. Y. Vardi and A. Voronkov, editors, LPAR, Lecture Notes in Computer Science 2850 (2003), pp. 152–166.
Gradel, E., Why are modal logics so robustly decidable?, Bulletin of the EATCS 68 (1999), pp. 90–103.
Halpern, J. Y. and Y. Moses, A guide to completeness and complexity for modal logics of knowledge and belief, Artificial Intelligence 54 (1992), pp. 319–379.
Ladner, R. E., The computational complexity of provability in systems of modal propositional logic, SIAM Journal on Computing 6 (1977), pp. 467–480.
Mundhenk, M. and T. Schneider, Undecidability of multi-modal hybrid logics, Technical Report 06-11, Reports on Computer Science, Friedrich-Schiller-Universita¨t Jena (2006).
URL  http://www.minet.uni-jena.de/Math-Net/reports/reports.html

Mundhenk, M., T. Schneider, T. Schwentick and V. Weber, Complexity of hybrid logics over transitive frames, in: H. Schlingloff, editor, M4M, Informatik-Berichte 194 (2005), pp. 62–78.
Ono, H. and A. Nakamura, On the size of refutation Kripke models for some linear modal and tense logics, Studia Logica 34 (1980), pp. 325–333.
Papadimitriou, C. H., “Computational Complexity,” Addison-Wesley, 1994.
Spaan, E., “Complexity of modal logics,” Ph.D. thesis, ILLC, University of Amsterdam (1993).
ten Cate, B. and M. Franceschet, On the complexity of hybrid logics with binders, in: Proc. of the 19th CSL, 2005, LNCS 3634 (2005), pp. 339–354.
van Emde Boas, P., The convenience of tilings, in: A. Sorbi, editor, Complexity, Logic, and Recursion Theory, Lecture Notes in Pure and Applied Mathematics, Marcel Dekker Inc., 1997 pp. 331–363.
Wang, H., Proving theorems by pattern recognition II, Bell Systems Technical Journal 40 (1961), pp. 1– 42.
