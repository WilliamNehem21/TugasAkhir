Electronic Notes in Theoretical Computer Science 169 (2007) 7–18	
www.elsevier.com/locate/entcs

Modal Logic Characterization of Markovian Testing and Trace Equivalences
Marco Bernardo, Stefania Botta
Universita` di Urbino “Carlo Bo”
Istituto di Scienze e Tecnologie dell’Informazione Piazza della Repubblica 13, 61029 Urbino, Italy Email: {bernardo, botta}@sti.uniurb.it



Abstract
Markovian testing and trace equivalences have been recently proposed as reasonable alternatives to Marko- vian bisimilarity, as both of them induce at the Markov chain level an aggregation strictly coarser than ordinary lumping that is still exact. In this paper we provide a modal logic characterization for each of the two non-bisimulation-based Markovian behavioral equivalences, which relies on a quantitative interpretation of a variant of the Hennessy-Milner logic. We also show that, unlike the Markovian bisimilarity case, such modal logic characterizations exist only when probabilistic and temporal aspects are treated in a global way.

Introduction
In order to account for performance aspects, in the last two decades algebraic pro- cess calculi have been extended so that stochastic processes can be associated with their terms. In this field, the focus has primarily been on equipping process terms with performance models in the form of continuous-time Markov chains (CTMCs). Several Markovian process calculi have been proposed in the literature (see, e.g., [8,7,2] and the references therein), which differ for the action representation – du- rational actions vs. instantaneous actions separated from time passing – as well as for the synchronization discipline – asymmetric vs. symmetric.
Such Markovian process calculi come equipped with several behavioral equiva- lences, ranging from the usual Markovian bisimilarity [8] to the more recent Marko- vian testing equivalence [3] and Markovian trace equivalence [10]. It is by now well known that Markovian bisimilarity is a congruence with respect to all the typical process algebraic operators, has a sound and complete axiomatization, has modal and temporal logic characterizations, and induces at the CTMC level an exact ag- gregation coinciding with ordinary lumping. In [1] it has recently been proved

1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2006.07.024

that Markovian testing and trace equivalences enjoy similar properties related to congruence (at least for dynamic operators), axiomatization, and exactness.
In this paper we address the problem of investigating modal logic characteriza- tions for Markovian testing and trace equivalences. A solution to this problem for classical testing and trace equivalences can be found in [5]. The modal language that is considered there is a restriction of the Hennessy-Milner logic (HML) [6] in which negation does not occur, hence it is only composed of constant true, logical conjunction, and the diamond operator. Then two satisfaction relations are defined, which express the fact that a process term may or must satisfy a formula of the modal language after accepting an action string. It is finally shown that two pro- cesses are testing equivalent iff, for each action string, they may satisfy the same set of formulas and must satisfy the same set of formulas after accepting that action string. As a consequence, two processes are trace equivalent iff, for each action string, they may satisfy the same set of formulas after accepting that action string. In [9] the same problem is considered for a probabilistic testing equivalence defined over a set of reactive probabilistic processes. There a variant of HML is adopted, which once again leaves out negation. Then a quantitative interpretation of the resulting modal logic is enforced, which is formalized through a function that gives the probability with which a process satisfies a formula. After establishing a bijective correspondence between formulas and tests, it is finally shown that two reactive probabilistic processes are probabilistic testing equivalent – in the sense of passing an arbitrary test with the same probability – iff they satisfy an arbitrary
formula with the same probability.
In our Markovian framework we extend the approach of [9] by means of a finer quantitative interpretation, which is formalized through a function that gives the probability with which a process satisfies a formula within a certain average amount of time. In the case of Markovian testing equivalence, we consider a variant of HML that rules out both negation and logical conjunction while including a conditional version of the diamond operator. In the case of Markovian trace equivalence, in- stead, we consider a restriction of HML that just includes constant true and the diamond operator. We show that the logical characterization result is achieved for both non-bisimulation-based Markovian behavioral equivalences.
The philosophy underlying the modal logic characterizations of Markovian test- ing and trace equivalences is quite different from the one underlying the modal logic characterization of Markovian bisimilarity provided in [4]. There a Markovian ex- tension of HML is defined – instead of considering a variant of HML itself – whose diamond operator has a further parameter expressing the least rate at which the ac- tion has to be executed. Then a classical satisfaction relation is considered – instead of defining a quantitative interpretation – which takes into account the fact that certain sequences of actions, with each individual action having a suitable rate, are executed – instead of the overall probability of executing certain action sequences within an overall average amount of time. In other words, while the modal logic characterization of Markovian bisimilarity treats probabilistic and temporal aspects in a way that is local to the individual actions, the modal logic characterizations of

Markovian testing and trace equivalences treat the same aspects in a global way, as such aspects are related to the action sequences rather than the individual actions composing the sequences. We show that it is not possible to provide Markovian testing and trace equivalences with modal logic characterizations that treat proba- bilistic and temporal aspects in a local way.
This paper is organized as follows. In Sect. 2 we introduce a basic Markovian process calculus generating all the CTMCs with as few operators as possible, then we recall Markovian testing and trace equivalences. In Sect. 3 we provide the modal logic characterization results for the two Markovian behavioral equivalences when the probabilistic and temporal aspects are dealt with in a global way. In Sect. 4 we provide some counterexamples showing that there is no modal logic characterization for Markovian testing and trace equivalences that treats probabilistic and temporal aspects in a local way. Finally, in Sect. 5 we report some concluding remarks.

Markovian Process Terms and Equivalences
In this section we introduce a basic Markovian process calculus called MPC, which generates all the CTMCs with as few operators as possible: the null term, the action prefix operator, the alternative composition operator, and recursion. Then we recall the definitions of Markovian testing and trace equivalences.
Markovian Process Calculus
In MPC every action is durational, hence it is represented as a pair <a, λ>, where a ∈ Name is the name of the action while λ ∈ R>0 is the rate of the exponential distribution quantifying the duration of the action. We denote by Act = Name ×R>0 the set of the actions of MPC. Unlike standard process theory, here we assume that all the actions are observable.
Definition 2.1 The set of the process terms of MPC is generated by the following syntax:
P ::= 0 | <a, λ>.P | P + P | A
where A is a process constant defined through the (possibly recursive) equation
A =Δ P . We denote by P the set of the closed and guarded process terms of MPC. 
The semantics for MPC can be defined in the usual operational style. As a consequence, the behavior of each process term is given by a multitransition system, whose states correspond to process terms and whose transitions – each of which has a multiplicity – are labeled with actions.
The null term 0 cannot execute any action, hence the corresponding labeled mul- titransition system is just a state with no transitions. Term <a, λ>.P can execute an action of name a and average duration 1/λ and then behaves as P :
a,λ
<a, λ>.P −−−→ P
Term P1 + P2 behaves as either P1 or P2 depending on whether P1 or P2 executes an action first:



a,λ
P1 −−−→ P '
a,λ	'
a,λ
P2 −−−→ P '


a,λ	'

P1 + P2 −−−→ P	P1 + P2 −−−→ P
where the actions executable by P1 and those executable by P2 are considered to be in a race, hence each of them has an execution probability proportional to its rate. Finally, process constant A behaves as the right-hand side process term in the defining equation for A itself:

a,λ
P −−−→ P '
a,λ
if A =Δ P

A −−−→ P '

Markovian Testing Equivalence
Two process terms of MPC can be considered to be equivalent if an external observer cannot distinguish between them. The only way that the observer has to infer information about the behavior of a process term is to interact with it by means of tests. The most convenient way to represent a test is through another process term, which interacts with the first one by means of a parallel composition operator that enforces synchronization on all action names. Since a test should be conducted in a finite number of steps, for the test formalization we restrict ourselves to process terms that are finite state and acyclic, hence no recursion is admitted within the tests. In other words, the labeled multitransition systems underlying the tests must have a finite dag-like structure.
In our Markovian framework, the interaction of a process term and a test should be closed with respect to the class of exponential distributions, i.e. it should not give rise to transitions whose rate cannot be expressed through a positive real number representing an exponential distribution. This strictly depends on the synchroniza- tion discipline that is adopted. The simplest way to achieve exponential closure is to enforce the Markovian generative-reactive form of communication [2]. Therefore, only the so-called passive actions can occur within the tests. Passive actions have no duration associated with them. Instead, they are given positive real numbers interpreted as weights, which are used to make a probabilistic selection among a set of passive actions with the same name. The idea is that, in any of its states, a process term to be tested generates the proposal of an action to be executed by means of a race among the exponentially timed actions enabled in that state, then the test reacts by probabilistically selecting a passive action (if any) with the same name as the proposed exponentially timed one.
Definition 2.2 The set T of the tests is generated by the following syntax:
T ::= f | s | Σi∈I <ai, ∗wi >.Ti
where I is a non-empty finite index set, ai ∈ Name, and wi ∈ R>0.	 
The following operational rule defines the generative-reactive interaction of P ∈ P and T ∈T :



a,λ
P −−−→ P '
a,∗w
T −−−→ T '



a,λ·w/weight(T,a)
P  T −−−−−−−−−−−−−−−→ P '  T '
where the total weight with respect to an action name is defined as follows:

weight (T, a)= Σ
'	a,∗w	'


Definition 2.3 Let P ∈ P and T ∈ T . The interaction system of P and T is process term P  T , where we say that:
A configuration is a state of the labeled multitransition system underlying P  T .
A configuration is successful (resp. failed) iff its test component is “s” (resp. “f”).
A computation is a maximal sequence of transitions:

a1,λ1
a2,λ2
an,λn

P0 T0 −−−→ P1 T1 −−−→ ... −−−→ Pn Tn
with P0 ≡ P and T0 ≡ T , such that configuration Pi  Ti is neither successful nor failed for all 0 ≤ i ≤ n − 1.
A computation is successful (resp. failed) iff so is its last configuration. A com- putation that is neither successful nor failed is said to be interrupted.
We denote by C(P, T ) and SC(P, T ) the multisets of the computations and of the successful computations, respectively, of the interaction system of P and T .	 
Definition 2.4 Let P ∈ P, T ∈ T , and c ∈ C(P, T ). The execution probability and the average duration of c are defined by induction on the length of c as follows:
prob(c) = ,⎨ 1	if length (c)=0 
, 	λ	 · prob(c')	if c ≡ P  T −−−→ c'
0	if length (c)=0 
a,λ
1		'	'
rate t(P  T )
where the total exit rate is defined as follows:

rate (P  T )= Σ
'	'	a,λ	'	'

t
We also pose:
{| λ | ∃a, P ,T .P	T −−−→ P	T |}

prob(C)= Σc∈C prob(c)

for all C ⊆ C(P, T ) and:
C≤t = {c ∈ C | time(c) ≤ t}
for all C ⊆ C(P, T ) and t ∈ R≥0.	 
Definition 2.5 Let P1, P2 ∈ P. We say that P1 is Markovian testing equivalent to
P2, written P1 ∼MT P2, iff for all tests T ∈T and average amounts of time t ∈ R≥0:
prob (SC≤t(P1,T )) = prob(SC≤t(P2,T ))

Markovian Trace Equivalence
Unlike Markovian testing equivalence, given a process term P in the case of Marko- vian trace equivalence we no longer consider tests that interact with P . Instead, we directly consider the multiset Cf(P ) of the finite-length computations of P taken in isolation.
Definition 2.6 Let P ∈P and c ∈ Cf(P ). The trace associated with the execution of c is defined by induction on the length of c as follows:
trace (c)= ,⎨ ε	if length(c)= 0
a · trace (c')  if c ≡ P −−−→ c'
where ε is the empty trace.	 
Definition 2.7 Let P ∈ P, c ∈ Cf(P ), and α ∈ Name∗. We say that c is compatible with α iff trace (c) = α. We denote by CC(P, α) the multiset of the finite-length computations of P that are compatible with α.	 
Definition 2.8 Let P ∈ P, α ∈ Name∗, and c ∈ CC(P, α). The execution proba-
bility and the average duration of c are defined by induction on the length of c as follows:
prob (c) = ,⎨ 1	if length(c)= 0
, 	λ	 · prob(c')	if c ≡ P −−−→ c'
time(c) = ,⎨ 0	if length (c)=0 
, 	1	 + time(c')	if c ≡ P −−−→ c'
Definition 2.9 Let P1, P2 ∈ P. We say that P1 is Markovian trace equivalent to P2, written P1 ∼MTr P2, iff for all traces α ∈ Name∗ and average amounts of time t ∈ R≥0:
prob (CC≤t(P1, α)) = prob(CC≤t(P2, α))
Global Characterization Results
In this section we exhibit two modal logic characterizations – one for ∼MT and the other for ∼MTr – in which probabilistic and temporal aspects are dealt with in a global way. These two characterizations are obtained by defining two suitable variants of HML, which are then interpreted quantitatively over P in a way that is inspired by [9]. More precisely, what is measured is the probability that a formula is satisfied quickly enough on average.
Modal Logic Characterization of Markovian Testing Equivalence
In order to achieve a modal logic characterization result for ∼MT, it is worth recalling from [3] an alternative characterization of ∼MT, which allows us to concentrate on a set of canonical tests having a more regular structure than the one of Def. 2.2.

Definition 3.1 The set Tc of the canonical tests is generated by the following syn- tax:
T ::= s | <a, ∗w>.T + Σb∈E−{a} <b, ∗w>.f
where a ∈ Name, w ∈ R>0, and E ⊆ Name such that a ∈ E.	 
Theorem 3.2 Let P1, P2 ∈ P. Then P1 ∼MT P2 iff for all T ∈ Tc and t ∈ R≥0: prob (SC≤t(P1,T )) = prob(SC≤t(P2,T ))
Proof. See [3].	 
In each of its states, a non-trivial canonical test enables a set E of passive actions
representing the environment from the point of view of a process term to be tested
such that only one of them leads to success, while all the others lead to failure in one step. Based on this structure, we now define a variant of HML in which negation and logical conjunction are ruled out, while the diamond operator is made dependent from the environment. We shall see that the formulas of the resulting modal logic have a one-to-one correspondence with the canonical tests, from which the modal logic characterization result for ∼MT will immediately follow.
Definition 3.3 The set of the formulas of the modal logic HMLMT is generated by the following syntax:
φ ::= true | ⟨a|E ⟩φ
where a ∈ Name and E ⊆ Name such that a ∈ E.	 
Definition 3.4 The interpretation of HMLMT over P is given by function [.]] : HMLMT −−−→ (P× R −−−→ R[0,1]) defined by induction on the syntactical structure of the formulas of HMLMT as follows:
[[true]](P, t) = ,⎨ 1	if t ≥ 0
, 0	if t < 0
[[⟨a|E ⟩φ]](P, t) =	Σ		λ	 · [[φ]](P ',t − 	1	 )

a,λ
P −−→ P '
ratec(P |E)
ratec(P |E)

where the conditional exit rate is defined as follows:

rate
(P |E)= Σ
'	b,μ	'

Lemma 3.5 For each T ∈ Tc there exists φT ∈ HMLMT such that for all P ∈ P 
and t ∈ R≥0:
[[φT ]](P, t)= prob(SC≤t(P, T ))
Proof. We proceed by induction on the syntactical structure of T :
Let T ≡ s. If we take φT ≡ true, then for all P ∈P and t ∈ R≥0 we immediately derive:
[[φT ]](P, t)=1= prob(SC≤t(P, T ))

Let T ≡ <a, ∗w>.T ' +	b∈E−{a} <b, ∗w>.f. If we take φT ≡ ⟨a|E ⟩φT ' , then for all P ∈P and t ∈ R≥0 we have:

[[φT ]](P, t)=	Σ
· [[φT ' ]](P ,t −	)


and:
a,λ
P −−→ P '
ratec(P |E)
ratec(P |E)

prob(SC≤t(P, T )) =	Σ
	λ	 · prob(SC≤t− 	1	 (P ',T '))

a,λ
P −−→ P '
ratet(P  T )
ratet(P  T )

In order to avoid trivial cases, let us assume that P can perform a-actions. Ob- served that rate c(P |E)= rate t(P  T ), if t − 	1	 < 0 then for all P ':
[[φT ' ]](P ,t −	)= 0 = prob(SC≤t− 	1	 (P ,T ))

ratec(P |E)
ratet(P  T )

If instead t − 	1	 ≥ 0 then by the induction hypothesis for all P ':
c
[[φT ' ]](P ,t −	)= prob(SC≤t− 	1	 (P ,T ))

The result then follows.
ratec(P |E)
ratet(P  T )


Lemma 3.6 For each φ ∈ HMLMT there exists Tφ ∈ Tc such that for all P ∈ P 
and t ∈ R≥0:
prob(SC≤t(P, Tφ)) = [φ]](P, t)
Proof. We proceed by induction on the syntactical structure of φ:
Let φ ≡ true. If we take Tφ ≡ s, then for all P ∈P and t ∈ R≥0 we immediately derive:
prob(SC≤t(P, Tφ)) = 1 = [φ]](P, t)
Let φ ≡ ⟨a|E ⟩φ'. If we take Tφ ≡ <a, ∗w>.Tφ' +	b∈E−{a} <b, ∗w>.f, then for all
P ∈P and t ∈ R≥0 we have:

prob(SC≤t(P, Tφ)) =	Σ
· prob(SC≤t− 	1	 (P , Tφ' ))


and:
a,λ
P −−→ P '
ratet(P  Tφ)
ratet(P  Tφ )

[[φ]](P, t)=	Σ
	λ	 · [[φ']](P ',t − 	1	 )

a,λ
P −−→ P '
ratec(P |E)
ratec(P |E)

In order to avoid trivial cases, let us assume that P can perform a-actions. Ob- served that rate t(P	Tφ)= rate c(P |E), if t − 	1	 < 0 then for all P ':
φ
prob(SC≤t− 	1	 (P , Tφ' )) =0= [[φ ]](P ,t −	)

ratet(P  Tφ )
ratec(P |E)

If instead t − 	1	 ≥ 0 then by the induction hypothesis for all P ':
t	φ
prob(SC≤t− 	1	 (P , Tφ' )) = [φ ]](P ,t −	)

The result then follows.
ratet(P  Tφ )
ratec(P |E)

Theorem 3.7 Let P1, P2 ∈ P. Then P1 ∼MT P2 iff for all φ ∈ HMLMT and
t ∈ R≥0:
[[φ]](P1, t)= [[φ]](P2, t)
Proof. The result is a straightforward consequence of Thm. 3.2 and of the bijec- tive correspondence between canonical tests and formulas of HMLMT established by Lemmas 3.5 and 3.6.	 

Modal Logic Characterization of Markovian Trace Equivalence
In the case of ∼MTr, we proceed similarly by first considering a restriction of HML in which negation and logical conjunction are ruled out and then showing that the formulas of the resulting modal logic have a one-to-one correspondence with the traces.
Definition 3.8 The set of the formulas of the modal logic HMLMTr is generated by the following syntax:
φ ::= true | ⟨a⟩φ
where a ∈ Name.
Definition 3.9 The interpretation of HMLMTr over P is given by function [.]] : HMLMTr −−−→ (P × R −−−→ R[0,1]) defined by induction on the syntactical struc- ture of the formulas of HMLMTr as follows:
[[true]](P, t) = ⎨ 1	if t ≥ 0
, 0	if t < 0
[[⟨a⟩φ]](P, t) =	Σ		λ	 · [[φ]](P ',t − 	1	)

a,λ
P −−→ P '
ratet(P )
ratet(P )

Lemma 3.10 For each α ∈ Name∗ there exists φα ∈ HMLMTr such that for all
P ∈P and t ∈ R≥0:
[[φα]](P, t)= prob(CC≤t(P, α))
Proof. We proceed by induction on the length of α:
Let length (α) = 0, i.e. α ≡ ε. If we take φα ≡ true, then for all P ∈ P and
t ∈ R≥0 we immediately derive:
[[φα]](P, t)=1= prob(CC≤t(P, α))
Let length (α) > 0, say α ≡ a · α'. If we take φα ≡ ⟨a⟩φα' , then for all P ∈P and
t ∈ R≥0 we have:

[[φα]](P, t)=	Σ
· [[φα' ]](P ,t −	)


and:
a,λ
P −−→ P '
ratet(P )
ratet(P )

prob(CC≤t(P, α)) =	Σ
	λ	 · prob(CC≤t− 	1	 (P ', α'))

a,λ
P −−→ P '
ratet(P )
ratet(P )

In order to avoid trivial cases, let us assume that P can perform a-actions. If

t − 	1	 < 0 then for all P ':
t
[[φα' ]](P ,t −	)= 0 = prob(CC≤t− 	1	 (P , α ))

ratet(P )
ratet(P )

If instead t − 	1	 ≥ 0 then by the induction hypothesis for all P ':
t
[[φα' ]](P ,t −	)= prob(CC≤t− 	1	 (P , α ))

The result then follows.
ratet(P )
ratet(P )


Lemma 3.11 For each φ ∈ HMLMTr there exists αφ ∈ Name∗ such that for all
P ∈P and t ∈ R≥0:
prob(CC≤t(P, αφ)) = [φ]](P, t)
Proof. We proceed by induction on the syntactical structure of φ:
Let φ ≡ true. If we take αφ ≡ ε, then for all P ∈P and t ∈ R≥0 we immediately derive:
prob(CC≤t(P, αφ)) =1= [[φ]](P, t)
Let φ ≡ ⟨a⟩φ'. If we take αφ ≡ a · αφ' , then for all P ∈P and t ∈ R≥0 we have:

prob(CC≤t(P, αφ)) =	Σ
· prob(CC≤t− 	1	 (P , αφ' ))


and:
a,λ
P −−→ P '
ratet(P )
ratet(P )

[[φ]](P, t)=	Σ
	λ	 · [[φ']](P ',t − 	1	)

a,λ
P −−→ P '
ratet(P )
ratet(P )

In order to avoid trivial cases, let us assume that P can perform a-actions. If
t − 	1	 < 0 then for all P ':
t
prob(CC≤t− 	1	 (P , αφ' )) =0= [[φ ]](P ,t −	)

ratet(P )
ratet(P )

If instead t − 	1	 ≥ 0 then by the induction hypothesis for all P ':
t
prob(CC≤t− 	1	 (P , αφ' )) = [φ ]](P ,t −	)

The result then follows.
ratet(P )
ratet(P )


Theorem 3.12 Let P1, P2 ∈ P. Then P1 ∼MTr P2 iff for all φ ∈ HMLMTr and
t ∈ R≥0:
[[φ]](P1, t)= [[φ]](P2, t)
Proof. The result is a straightforward consequence of the bijective correspondence between traces and formulas of HMLMTr established by Lemmas 3.10 and 3.11.	 

Absence of Local Characterizations
The modal logic characterization of Markovian bisimilarity provided in [4] relies on a Markovian extension of HML in which the diamond operator has a further parameter expressing the least rate at which the action has to be executed. More

precisely, process term P satisfies ⟨a⟩νφ iff P has a number of a-transitions, whose total rate is not less than ν, such that all the states reached by such transitions satisfy φ. This amounts to say that P satisfies the formula quickly enough, with the speed being checked locally at each occurrence of the Markovian extension of the diamond operator.
Similarly, one may think of using modal operators like ⟨a|E ⟩p,tφ and ⟨a⟩p,tφ, with p ∈ R]0,1] and t ∈ R≥0, in order to characterize Markovian testing and trace equivalences in a local way. As an example, process term P satisfies ⟨a⟩p,tφ iff 1/rate t(P ) ≤ t and P has a number of a-transitions, whose total execution proba- bility is not less than p, such that all the states reached by such transitions satisfy φ.
Unfortunately, using such Markovian extensions of HMLMT and HMLMTr does not yield any further modal characterization result for Markovian testing and trace equivalences, as the following simple counterexample shows:
P ≡ <a, λ1>.<b, μ>.0 + <a, λ2>.<c, μ>.0
Q ≡ <a, λ1 + λ2>.(<b,  λ1  · μ>.0 + <c,  λ2  · μ>.0)

λ1+λ2
φ ≡ ⟨a⟩1,   1   ⟨b⟩   λ1  ,  1 true
λ1+λ2

λ1 +λ2
λ1+λ2 μ

In fact P ∼MTr Q but only Q satisfies φ.

Conclusion
In this paper we have shown that both Markovian testing equivalence and Markovian trace equivalence have a modal logic characterization, provided that probabilistic and temporal aspects are not locally specified within the single occurrences of the diamond operator. The characterization relies on a quantitative interpretation of a variant of HML, according to which two terms are equivalent if they have the same probability of satisfying quickly enough on average an arbitrary formula of the resulting modal logic.
Observed that similar results may be obtained when considering temporal log- ics – a possibly environment-sensitive, action-based next operator is all we need – for the future we plan to conduct a comparative study of the logical characteriza- tions of bisimilarity, testing equivalence, and trace equivalence in nondeterministic, probabilistic and Markovian settings.

References
M. Bernardo, “Markovian Testing and Trace Equivalences Exactly Lump More Than Markovian Bisimilarity”, in Proc. of the Int. Workshop on Algebraic Process Calculi: The First Twenty Five Years and Beyond (APC 25), ENTCS, Bertinoro (Italy), 2005.
M. Bernardo and M. Bravetti, “Performance Measure Sensitive Congruences for Markovian Process Algebras”, in Theoretical Computer Science 290:117-160, 2003.
M. Bernardo and W.R. Cleaveland, “A Theory of Testing for Markovian Processes”, in Proc. of the 11th Int. Conf. on Concurrency Theory (CONCUR 2000), LNCS 1877:305-319, State College (PA), 2000.


G. Clark, S. Gilmore, and J. Hillston, “Specifying Performance Measures for PEPA”, in Proc. of the 5th AMAST Int. Workshop on Formal Methods for Real Time and Probabilistic Systems (ARTS 1999), LNCS 1601:211-227, Bamberg (Germany), 1999.
M. Hennessy, “Acceptance Trees”, in Journal of the ACM 32:896-928, 1985.
M. Hennessy and R. Milner, “Algebraic Laws for Nondeterminism and Concurrency”, in Journal of the ACM 32:137-162, 1985.
H. Hermanns, “Interactive Markov Chains”, LNCS 2428, 2002.
J. Hillston, “A Compositional Approach to Performance Modelling”, Cambridge University Press, 1996.
M.Z. Kwiatkowska and G.J. Norman, “A Testing Equivalence for Reactive Probabilistic Processes”, in Proc. of the 2nd Int. Workshop on Expressiveness in Concurrency (EXPRESS 1998), ENTCS 16:114- 132, Nice (France), 1998.
V. Wolf, M. Majster-Cederbaum, and C. Baier, “Trace Machines for Observing Continuous-Time Markov Chains”, in Proc. of the 3rd Int. Workshop on Quantitative Aspects of Programming Languages (QAPL 2005), ENTCS, Edinburgh (UK), 2005.
