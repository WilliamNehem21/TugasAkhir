Electronic Notes in Theoretical Computer Science 50 No. 3 (2001) { Proc. GT-VMT 2001 URL:  http://www.elsevier.nl/locate/entcs/volume50.html  8 pages



An Agg Application Supporting Visual Reasoning 1



Andrea  Formisano 2
Dipartimento di Matematica e Informatica, Universit a di Perugia Marta Simeoni 3
Dipartimento di Informatica, Universita  `Ca Foscari' di Venezia



1  Introduction

The map calculus, the arithmetic of dyadic relations (cf. [9]), is a ground equational formalism where one can state properties of dyadic relations over a unspeci ed domain of discourse. It can be seen as an evolution of the theory of relations, an algebraic approach to logic developed by, among others,
A. de Morgan, C. S. Peirce and E. Schroder [8,7].
Direct algebraic manipulation of map expressions seems to be, for human beings, much less natural than developing inferences in rst-order logic; it may in fact appear to be overly machine-oriented for direct hand-based ex- ploitation. However, the situation radically changes when one resorts to a convenient representation of map expressions based on labeled graphs. Beside allowing the abstraction w.r.t inessential features of expressions, such a rep- resentation allows an easy and intuitive visual handling of map speci cations. Approaches of this kind have been proposed, for instance, in [2,1,3,6].
In this work we move the rst step toward the implementation of an au- tomated tool for the mechanization of visual map-reasoning. To this end, we exploit Agg |Algebraic Graph Grammar| [4], which provides a visual programming environment for graph transformation based applications. Such applications are described by graph grammars, which consist of an initial graph and a set of graph rewriting rules. Agg supports the visual handling of both the start graph and the rewriting rules, and, once the graph grammar has been formalized, it allows the manipulation of the start graph. We use

1 This research was partially funded by the Italian IASI-CNR (coordinated project log(SETA)); by MURST|PGR-2000; by the EC TMR Network GETGRATS (GEneral Theory of GRAph Transformation Systems); and by Esprit Working Group APPLIGRAPH.
2  Email:formis@dipmat.unipg.it
3  Email:simeoni@dsi.unive.it
 c 2001 Published by Elsevier Science B. V. Open access under CC BY-NC-ND license.


Agg as a visual proof-assistant for map reasoning: inference mechanisms are implemented as graph rewriting rules and techniques, allowing the transfor- mation of premises into conclusions (forward reasoning), or the reduction of theses |goals| into simpler goals and, ultimately, into known facts (back- ward reasoning).
A detailed exposition of the topics of this paper, comprising a series of worked exampes, can be found in [5].

2	A graphical rendering for equational speci cations

The map calculus is based on L , an equational language devoid of variables. Its basic ingredients are three constants , 1l,  ; in nitely many map letters p1; p2; p3;:: :; three dyadic constructs \, 4, ; of map intersection, map sym- metric di erence, and map composition; and the monadic construct ^ of map conversion. A map expression is any term built up from this signature in the usual manner. A map equality is a writing of the form Q=R, where both Q and R are map expressions.
Once a nonempty domain U has been  xed, the map constants  , 1l,

and   are interpreted by putting:  = =
;,	1l= =
2
Def
U   U , and

  =Def f[a; a] : a 2 U g. On the basis of the usual evaluation rules, by putting subsets p=; p=; p=;::: of U 2 in correspondence with the p s, each map expres-
1	2	3	i
sion P comes to designate a speci c map P =, and each equality Q=R turns
out to be either true or false.
Let us now assume that ' is a conjunction (9 x1)  (9 xk)(L1 ^  ^Ln) of atoms, and that vars(')  fv1; v2;:: :g is the set of all the variables occurring in '. Moreover, assume that x1;::: ; xk 2 vars(') and that each Li is of the form xLi PLi yLi , where xLi ; yLi 2 vars(') are variables (assumed ranging over the domain U of discourse), and PLi is a map expression of L . Clearly, free variables may occur in ' intermixed with existentially quanti ed variables.
An Agg graph G' representing ' is so de ned: given the two alphabets AN =Def f g and AE =Def f  ;  g; for nodes and edges (graphical) labels, we have G' = hGE; GN ; Gs; Gt; Gle; Glni where:
GE =Def f1;::: ; ng is the set of edges; GN =Def vars(') is the set of nodes;
Gs : GE ! GN maps each i 2 GE into xLi (source function); Gt : GE ! GN maps each i 2 GE into yLi (target function);
Gln : GN ! AN maps each node to the unique available label;
Gle : GE ! AE maps each edge to  .
Agg graphs may be attributed by Java objects (i.e instances of Java classes, either imported from standard libraries or user de ned): we exploit the at- tribution mechanism in order to permit suitable manipulation of map expres- sions. More precisely, we introduce the node attribution function type : GN ! fB; Fg such that, for each node x, type(x) is B (resp. F) if x is a bound (resp. free) variable in '. Accordingly, a node is said bound if the corresponding


variable is bound in '. We consider moreover the edge attribution function Esp : G ! L  which associates each edge i, with the map expression P  .
The following Agg rules, which manifestly preserve the meaning of the involved graphs, can be combined to constitute an algorithm for associating an
`unfolded' graph G to a given (compound) map expression P . Two designated (free) nodes, named source and sink, represent the two arguments of P , and every node distinct from these two is regarded as being bound.
Note that X, Y , and P are variables which are instantiated with concrete attribute values when the left-hand side graphs are applied to a certain graph. The rules are applicable when P is instantiated with P1\P2 ( rst rule), P1;P2 (second rule) and P ^ (last rule), where P1 and P2 stand for general map ex- pressions. Their applicability is checked via Java methods. Moreover, the Java methods proj1 and proj2 return the map expressions P1 and P2, respectively.
Representing map equalities. Let us now extend our approach in order to suitably represent map equalities. To this end we convert the graph rep- resentation of a relation P (i.e., (xP y)) into the representation of an equality involving P by bounding the source x and sink y by universal or existential quanti cation. The following equalities (shown on the left-hand side), corre- spond to closed rst-order formulas (shown on the middle), and are rendered in our graphical notation by means of particular node attribute values (shown on the right-hand side).


The node attribute function has been re ned to type : GN ! fB; F; A; E; NEg and the source x and sink y of the graph representing P are attributed ac- cording with the equality to be expressed. We refer to the four kind of graph listed above, by the writings 88, 89, 99, and :99, respectively.
Dealing with complementation. In order to allow (partial) handling of complementation, we introduce the edge label:  , to denote that the associated attributed expression, say P , has to be intended as complemented. The following is a simple graph-rewriting rule related to this convention:
As we will see, a simple (albeit partial), treatment of complementation, allows one to model/represent map inclusions of the form P  Q and, conse- quentely, to describe simple rewriting rules for inferring (new) map inclusions.

3	A proof-assistant based on graph-rewriting techniques

In our context, deriving map equalities from proper axioms, and from laws already known, can be viewed as a graph-rewriting activity. Here we focus our treatment on two particular classes of graphs: the existential graphs of the two types 88 and :99. We call them positive and negative graphs, respectively. These graphs are exploited to represent premises and conclusions, theses, etc. From this perspective, inference mechanisms are seen as graph-rewriting techniques: in forward reasoning, rewriting rules are used to transform premises into conclusions; in backward reasoning, to reduce theses |`goals', as they are often called| into simpler goals and, ultimately, into known and perhaps ob-
vious facts.
As a basic principle, it is legitimate to replace a positive goal by a more de- manding one, and a negative goal by one less demanding. E.g., new attributed edges can be added at will to a positive goal, whereas edges can be removed from a negative goal. Solving the new goal, although not necessarily equivalent to solving the previous goal, will in fact su√Üce for the purpose. Quite often a negative premise represents an inclusion P  Q,  i.e., :(9x)(9y)(xP \ Q y): 
If a subgraph of a positive goal matches the part of the premise which rep- resents Q, then it can be replaced by the part representing P ; in a negative goal, on the opposite, Q may replace P .
From now on, to be more speci c, let us consider negative graphs only.


The above-outlined basic rule is formulated in the Agg graphical language as displayed in Fig.1(1), where the nodes marked 4: and 5: constitute (together with the edges marked 10: and 12:) the negative premise; while the nodes 6: and 9: identify the edge to be replaced during the ring of the rule. Notice that the negative premise P Q remains unchanged in the transformed graph. Moreover, to ensure the soundness of the rule, further conditions have to be imposed. In fact, during the application of the rule, the negative premise must match with a complete connected component of the graph.
The properties of inclusion (e.g., transitivity) easily determine the simple inference rules of Fig.2; further rules for negative goals are shown in Fig.3.
As mentioned, proving a particular map equality in this visual framework amounts to repeatedly reducing the corresponding graph/goal into simplier goals until known facts are derived. Some of these facts, or axioms, related to map-inclusion are:

(A1) P   1l,	(A2) P   P ,	(A3) 1l  P [ P ,	(A4)   ; P   P .
An axiom corresponds to an Agg production whose left-hand side contain the obvious inclusions while the right-hand side is empty. The application of a production of this kind removes obvious facts from the graph.
We describe now a simple example of assisted reasoning. More precisely, we prove that for any map expression N the following holds: 4
Func( N ^ ) ! 1l ; N  N =  ; N: We split the problem into two simpler theses:
(a) 1l ; N  N    ; N ;  and  (b)  Func( N ^ ) !  ; N   1l ; N  N , The following are the proofs of (a) and (b) as obtained by exploiting Agg.
(a) The representation of 1l ; N  N     ; N  as a :99-graph is:

On the right we have added an instance of the axiom (A4) since the rst step will consist in applying rule (2) of Fig.1. As a result we obtain the graph
(i) below, which can be rewritten into graph (ii) by applying a rule imple- menting a generalization of the `De Morgan' law P ; T \Q ; T =(P [ Q) ; T .

(i)	(ii)



By (1) of Fig.3 Agg reduces the goal (ii) into the two goals:

4 Here Func( P ) stands for the map equality P \P ; = P .






(1)








(2)





Fig. 1. Basic inference rules for :99-goals




(1)






(2)





Fig. 2. Simple inference rules for map inclusion



which are then immediately proved by using (A3) and (A2), respectively. This completes the rst part of the proof.

(b) The assumption Func( N ^ ) can be rewriten as  ; N  N , and represented by the graph (i) below; while our thesis originates the starting graph (ii)







(1)





Where R is required to be a composition of maps.




(2)





Where R is required to be an intersection of maps.
Fig. 3. Simple reduction rules for :99-goals involving map inclusion






(i)	(ii)



By applying an instance of rule (2) of Fig.3 |obtained identifying P and Q in (2)| Agg reduces the thesis to two subgoals:
The goal on the right corresponds to our hypothesis Func( N ^ ); the other one can be further reduced as follows

by applying the `compound composition' rule of page 3. A further step re- duces the remaining goal by means of (1) of Fig.3, yielding the two goals:



which are instances of (A1) and (A2), resp.. This completes the proof.

4	Concluding remarks

In this paper we reported on a rst attempt in implementing graphical tech- niques for map representation and reasoning. An interesting further develop- ment would consist in the design and implementation of a more sophisticated proof-assistant: consider for instance the capability of performing backtrack- ing or suggesting the user the `better' rule to apply. The implementation of these features could be considered as a rst step toward the realization of a tool for automated map-reasoning based on graph-transformation techniques.

References

[1] Cantone, D., A. Formisano, E. G. Omodeo and C. G. Zarba, Compiling dyadic
 rst-order speci cations into map algebra, in: Proc. 2nd AMAST|AMILP 2000 (2000), pp. 35{54.
[2] Chiacchiaretta, A., A. Formisano and E. G. Omodeo, Map reasoning through existential multigraphs, Tech. Rep. 05/00, Dip. di Matematica Pura ed Applicata, Univ. di L'Aquila (2000).
[3] Curtis, S. and G. Lowe, Proofs with graphs, Science of Computer Programming
26 (1996), pp. 197{216, Mathematics of program construction, Kloster Irsee.
[4] Ermel, C., M. Rudolf and G. Taentzer, The agg approach: Language and environment, in: H. Ehrig, G. Engels, H.-J. Kreowski and G. Rozenberg, editors, Handbook of Graph Grammars and Computing by Graph Transformation, Vol. 2., World Scienti c, Singapore (1999).
[5] Formisano, A. and M. Simeoni, Graphs and maps: rewriting techniques at work, Tech. Rep. 2001-01, TU-Berlin (2001).
[6] Kahl, W., Relational matching for graphical calculi of relations, Information Sciences 119 (1999), pp. 253{273.
[7] Maddux, R. D., The origin of relation algebras in the development and axiomatization of the calculus of relations, Studia Logica 50 (1991).
[8] Schroder, E., \Vorlesungen uber die Algebra der Logik (exakte Logik)," B.
Teubner, Leipzig, 1891{95, [Reprinted by Chelsea Pub. Co., New York, (1966)].
[9] Tarski, A. and S. Givant, \A formalization of Set Theory without variables," Colloquium Publications 41, American Mathematical Society (1987).
